<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="go">
    <body>
      <group id="go">
        <trans-unit id="0b1b5b05fec2cd6d8e78c93f5a64f37706828f50" translate="yes" xml:space="preserve">
          <source>ModelFunc returns a Model that invokes f to implement the conversion.</source>
          <target state="translated">ModelFunc 返回一个调用 f 来实现转换的 Model。</target>
        </trans-unit>
        <trans-unit id="5361e7791528a917952293ec5274927cfb3ce5f8" translate="yes" xml:space="preserve">
          <source>Models for the standard color types.</source>
          <target state="translated">标准颜色类型的模型。</target>
        </trans-unit>
        <trans-unit id="e56d540b050862c318d1aab05d9e382cf0a4c4af" translate="yes" xml:space="preserve">
          <source>Modf returns integer and fractional floating-point numbers that sum to f. Both values have the same sign as f.</source>
          <target state="translated">Modf返回与f相加的整数和小数浮点数,两个值的符号都与f相同。</target>
        </trans-unit>
        <trans-unit id="c8fdb64fd7614b420c244d4e876ef3defb57abcc" translate="yes" xml:space="preserve">
          <source>Modular exponentation of inputs of a particular size is not a cryptographically constant-time operation.</source>
          <target state="translated">特定大小的输入的模块化指数化不是密码学上的恒时操作。</target>
        </trans-unit>
        <trans-unit id="2dd5487e8328e8658b359aa63c39e650ee5e1172" translate="yes" xml:space="preserve">
          <source>Module represents a module.</source>
          <target state="translated">模块代表一个模块。</target>
        </trans-unit>
        <trans-unit id="b1156729972d424016ec9426afb303f681b9f79f" translate="yes" xml:space="preserve">
          <source>Monotonic Clocks</source>
          <target state="translated">单调钟</target>
        </trans-unit>
        <trans-unit id="082bc378cd60e17a38d99898b21955299c5b60c8" translate="yes" xml:space="preserve">
          <source>Month</source>
          <target state="translated">Month</target>
        </trans-unit>
        <trans-unit id="66f2529dffac9fbc9ec633022a5f8b0bedc8c37f" translate="yes" xml:space="preserve">
          <source>Month returns the month of the year specified by t.</source>
          <target state="translated">Month 返回由 t 指定的年份的月份。</target>
        </trans-unit>
        <trans-unit id="668403e4d2bd4eddcb9aed021f2a174eb200dc88" translate="yes" xml:space="preserve">
          <source>More control over the server's behavior is available by creating a custom Server:</source>
          <target state="translated">通过创建自定义服务器,可以对服务器的行为进行更多的控制。</target>
        </trans-unit>
        <trans-unit id="85e92ae26cba75c5b6d8d17d26d228885ce889bf" translate="yes" xml:space="preserve">
          <source>More intricate examples appear below.</source>
          <target state="translated">更复杂的例子出现在下面。</target>
        </trans-unit>
        <trans-unit id="544eaf68f34e5f73c2388e2ae8096fe2204e2585" translate="yes" xml:space="preserve">
          <source>More reports whether there is another element in the current array or object being parsed.</source>
          <target state="translated">更多报告当前数组或正在解析的对象中是否有另一个元素。</target>
        </trans-unit>
        <trans-unit id="0f3ee8adfe02375a24e073f00bd7e8a1f885bbc4" translate="yes" xml:space="preserve">
          <source>Most callers should instead use Open, which transparently decompresses data and verifies checksums.</source>
          <target state="translated">大多数调用者应该使用Open,它可以透明地解压数据并验证校验和。</target>
        </trans-unit>
        <trans-unit id="204dcf13599d817427dd2073f0e35f29dec05bc1" translate="yes" xml:space="preserve">
          <source>Most clients should use the runtime/pprof package instead of calling GoroutineProfile directly.</source>
          <target state="translated">大多数客户端应该使用运行时/pprof包,而不是直接调用GoroutineProfile。</target>
        </trans-unit>
        <trans-unit id="2d4c0e8a354401dd8233b4356c1a0bfb3bef2533" translate="yes" xml:space="preserve">
          <source>Most clients should use the runtime/pprof package instead of calling MutexProfile directly.</source>
          <target state="translated">大多数客户端应该使用运行时/pprof包,而不是直接调用MutexProfile。</target>
        </trans-unit>
        <trans-unit id="fd55cd96fc64e1ee33e5ec28f8d3ef1539755bd8" translate="yes" xml:space="preserve">
          <source>Most clients should use the runtime/pprof package instead of calling ThreadCreateProfile directly.</source>
          <target state="translated">大多数客户端应该使用运行时/pprof包,而不是直接调用ThreadCreateProfile。</target>
        </trans-unit>
        <trans-unit id="646d3b37e5e676f43944b0bc1ef49ce31304c768" translate="yes" xml:space="preserve">
          <source>Most clients should use the runtime/pprof package or the testing package's -test.blockprofile flag instead of calling BlockProfile directly.</source>
          <target state="translated">大多数客户端应该使用runtime/pprof包或测试包的-test.blockprofile标志,而不是直接调用BlockProfile。</target>
        </trans-unit>
        <trans-unit id="fb5152386c9af905d8957add4efa5a79dbea3046" translate="yes" xml:space="preserve">
          <source>Most clients should use the runtime/pprof package or the testing package's -test.cpuprofile flag instead of calling SetCPUProfileRate directly.</source>
          <target state="translated">大多数客户端应该使用运行时/pprof包或测试包的-test.cpuprofile标志,而不是直接调用SetCPUProfileRate。</target>
        </trans-unit>
        <trans-unit id="cc35c049e953a9f16068abcc035a22ebd5b44d39" translate="yes" xml:space="preserve">
          <source>Most clients should use the runtime/pprof package or the testing package's -test.memprofile flag instead of calling MemProfile directly.</source>
          <target state="translated">大多数客户端应该使用运行时/pprof包或测试包的-test.memprofile标志,而不是直接调用MemProfile。</target>
        </trans-unit>
        <trans-unit id="4ec46c99b7f54aae4ce499a3028a52ae6552a566" translate="yes" xml:space="preserve">
          <source>Most code should use package sql.</source>
          <target state="translated">大多数代码应该使用包sql。</target>
        </trans-unit>
        <trans-unit id="19ad74392792ed9739e1d28d7638006df3165986" translate="yes" xml:space="preserve">
          <source>Most users will open a database via a driver-specific connection helper function that returns a *DB. No database drivers are included in the Go standard library. See &lt;a href=&quot;https://golang.org/s/sqldrivers&quot;&gt;https://golang.org/s/sqldrivers&lt;/a&gt; for a list of third-party drivers.</source>
          <target state="translated">大多数用户将通过特定于驱动程序的连接帮助程序函数来打开数据库，该函数返回* DB。Go标准库中没有数据库驱动程序。有关第三方驱动程序的列表，请参见&lt;a href=&quot;https://golang.org/s/sqldrivers&quot;&gt;https://golang.org/s/sqldrivers&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="99ed633024d8dc0b448fbe281ca6b8177fe27c56" translate="yes" xml:space="preserve">
          <source>Move moves n % r.Len() elements backward (n &amp;lt; 0) or forward (n &amp;gt;= 0) in the ring and returns that ring element. r must not be empty.</source>
          <target state="translated">Move将n％r.Len（）元素在环中向后（n &amp;lt;0）或向前（n&amp;gt; = 0）移动，并返回该环元素。r不能为空。</target>
        </trans-unit>
        <trans-unit id="9b69d844fd11e170cd47ef8ff2a97178038b339b" translate="yes" xml:space="preserve">
          <source>MoveAfter moves element e to its new position after mark. If e or mark is not an element of l, or e == mark, the list is not modified. The element and mark must not be nil.</source>
          <target state="translated">MoveAfter将元素e移动到mark之后的新位置。如果e或mark不是l的元素,或者e==mark,则列表不会被修改。元素和mark不能为零。</target>
        </trans-unit>
        <trans-unit id="33d96c6050800194a8407c20b5ca64f6846c7299" translate="yes" xml:space="preserve">
          <source>MoveBefore moves element e to its new position before mark. If e or mark is not an element of l, or e == mark, the list is not modified. The element and mark must not be nil.</source>
          <target state="translated">MoveBefore将元素e移动到mark之前的新位置。如果e或mark不是l的元素,或者e==mark,则列表不会被修改。元素和mark不能为零。</target>
        </trans-unit>
        <trans-unit id="48e25efa9d98fcd9ecb09e7fe7ed87eb426e273a" translate="yes" xml:space="preserve">
          <source>MoveToBack moves element e to the back of list l. If e is not an element of l, the list is not modified. The element must not be nil.</source>
          <target state="translated">MoveToBack将元素e移动到列表l的后面,如果e不是l的元素,则列表不会被修改。元素不能是nil。</target>
        </trans-unit>
        <trans-unit id="6f362d110c32c4c4500cf8d4c490f31132fbb839" translate="yes" xml:space="preserve">
          <source>MoveToFront moves element e to the front of list l. If e is not an element of l, the list is not modified. The element must not be nil.</source>
          <target state="translated">MoveToFront将元素e移动到列表l的前面,如果e不是l的元素,则列表不会被修改。元素不能是nil。</target>
        </trans-unit>
        <trans-unit id="90114025b275cbc4bcd8b562c1a58b937341fdfb" translate="yes" xml:space="preserve">
          <source>Mul returns the full-width product of x and y: (hi, lo) = x * y with the product bits' upper half returned in hi and the lower half returned in lo.</source>
          <target state="translated">Mul返回x和y的全宽乘积,(hi,lo)=x*y,乘积位的上半部分在hi中返回,下半部分在lo中返回。(hi,lo)=x*y,乘积位的上半部分在hi中返回,下半部分在lo中返回。</target>
        </trans-unit>
        <trans-unit id="26a6e266f6cfb3f2f503215e9850aa02f8f9da06" translate="yes" xml:space="preserve">
          <source>Mul returns the vector p*k.</source>
          <target state="translated">Mul返回向量p*k。</target>
        </trans-unit>
        <trans-unit id="da7ddc591d70c1b455e617b48abf92f18b455b2b" translate="yes" xml:space="preserve">
          <source>Mul sets z to the product x*y and returns z.</source>
          <target state="translated">Mul将z设为乘积x*y并返回z。</target>
        </trans-unit>
        <trans-unit id="77d0b9f0608c4902ed59d2c704e92843cbc28318" translate="yes" xml:space="preserve">
          <source>Mul sets z to the rounded product x*y and returns z. Precision, rounding, and accuracy reporting are as for Add. Mul panics with ErrNaN if one operand is zero and the other operand an infinity. The value of z is undefined in that case.</source>
          <target state="translated">Mul将z设置为四舍五入的乘积x*y并返回z。精度、四舍五入和准确度报告与 Add 相同。如果一个操作数为零,而另一个操作数为无穷大,Mul会用ErrNaN恐慌。在这种情况下,z 的值是未定义的。</target>
        </trans-unit>
        <trans-unit id="b861b19bddbd0bc8bab01f2fb9899e8f0de45d9e" translate="yes" xml:space="preserve">
          <source>Mul32 returns the 64-bit product of x and y: (hi, lo) = x * y with the product bits' upper half returned in hi and the lower half returned in lo.</source>
          <target state="translated">Mul32返回x和y的64位乘积。(hi,lo)=x*y,乘积位的上半部分返回hi,下半部分返回lo。</target>
        </trans-unit>
        <trans-unit id="a25ed66383b36d2221150102c89edba8efbb0c02" translate="yes" xml:space="preserve">
          <source>Mul64 returns the 128-bit product of x and y: (hi, lo) = x * y with the product bits' upper half returned in hi and the lower half returned in lo.</source>
          <target state="translated">Mul64返回x和y的128位乘积。(hi,lo)=x*y,乘积位的上半部分返回hi,下半部分返回lo。</target>
        </trans-unit>
        <trans-unit id="9b4ec4f00f8b7fc0f34cde307521a1856a53aa0b" translate="yes" xml:space="preserve">
          <source>MulRange sets z to the product of all integers in the range [a, b] inclusively and returns z. If a &amp;gt; b (empty range), the result is 1.</source>
          <target state="translated">MulRange将z设置为[a，b]范围内的所有整数的乘积，并返回z。如果a&amp;gt; b（空范围），则结果为1。</target>
        </trans-unit>
        <trans-unit id="9eaaace92dc7df7151a8f45536ad19d09279e182" translate="yes" xml:space="preserve">
          <source>MultiReader</source>
          <target state="translated">MultiReader</target>
        </trans-unit>
        <trans-unit id="5d860fccf2fdf207ce3f3ccf216ed942057c9707" translate="yes" xml:space="preserve">
          <source>MultiReader returns a Reader that's the logical concatenation of the provided input readers. They're read sequentially. Once all inputs have returned EOF, Read will return EOF. If any of the readers return a non-nil, non-EOF error, Read will return that error.</source>
          <target state="translated">MultiReader返回一个Reader,它是所提供的输入阅读器的逻辑连接。它们是按顺序读取的。一旦所有输入都返回EOF,Read将返回EOF。如果任何一个读取器返回一个非零、非EOF的错误,Read将返回该错误。</target>
        </trans-unit>
        <trans-unit id="4faad6c802b39e83086bf59c7e2903092d5a691b" translate="yes" xml:space="preserve">
          <source>MultiWriter</source>
          <target state="translated">MultiWriter</target>
        </trans-unit>
        <trans-unit id="0e1b7f58a5f86256f9545cb408ae583680594854" translate="yes" xml:space="preserve">
          <source>MultiWriter creates a writer that duplicates its writes to all the provided writers, similar to the Unix tee(1) command.</source>
          <target state="translated">MultiWriter 创建一个写入器,将其写入的内容复制到所有提供的写入器,类似于 Unix 的 tee(1)命令。</target>
        </trans-unit>
        <trans-unit id="3688e77a9282752c7dda127e113710f59d4dafc0" translate="yes" xml:space="preserve">
          <source>MulticastAddrs returns a list of multicast, joined group addresses for a specific interface.</source>
          <target state="translated">MulticastAddrs 返回一个特定接口的多播、加入组地址列表。</target>
        </trans-unit>
        <trans-unit id="b9bb2b61e03ad9524ce2fff2bf8e39b44ea3373a" translate="yes" xml:space="preserve">
          <source>MultipartReader returns a MIME multipart reader if this is a multipart/form-data or a multipart/mixed POST request, else returns nil and an error. Use this function instead of ParseMultipartForm to process the request body as a stream.</source>
          <target state="translated">如果这是一个multipart/form-data或multipart/mixed POST请求,MultipartReader返回一个MIME multipart reader,否则返回nil和一个错误。使用这个函数代替ParseMultipartForm来处理作为流的请求体。</target>
        </trans-unit>
        <trans-unit id="a782cf6ce52ba3c0409a2a494107b5e5d1c07de1" translate="yes" xml:space="preserve">
          <source>Multiple example functions for a package/type/function/method may be provided by appending a distinct suffix to the name. The suffix must start with a lower-case letter.</source>
          <target state="translated">一个包/类型/函数/方法的多个示例函数,可以通过在名称后添加一个不同的后缀来提供。后缀必须以一个小写字母开头。</target>
        </trans-unit>
        <trans-unit id="97b40210f32960166bd52edfda4ec341de71235b" translate="yes" xml:space="preserve">
          <source>Multiple goroutines may invoke methods on a Conn simultaneously.</source>
          <target state="translated">多个goroutine可以同时调用Conn上的方法。</target>
        </trans-unit>
        <trans-unit id="6556b625ec1c61ad052df5128208f619bcfcc88f" translate="yes" xml:space="preserve">
          <source>Multiple goroutines may invoke methods on a Listener simultaneously.</source>
          <target state="translated">多个goroutine可以同时调用一个Listener上的方法。</target>
        </trans-unit>
        <trans-unit id="d58239811314fdc4f9e0084cf7b627a6e3f8ff5f" translate="yes" xml:space="preserve">
          <source>Multiple goroutines may invoke methods on a PacketConn simultaneously.</source>
          <target state="translated">多个goroutine可以同时调用PacketConn上的方法。</target>
        </trans-unit>
        <trans-unit id="df2c141b4f12a4ff075a8eeb676ff9cf5032e4dc" translate="yes" xml:space="preserve">
          <source>MultiplePackageError describes a directory containing multiple buildable Go source files for multiple packages.</source>
          <target state="translated">MultiplePackageError描述了一个包含多个包的可构建Go源文件的目录。</target>
        </trans-unit>
        <trans-unit id="79a3dc65878a83d5c3f20c9bd1c6028718af5b1b" translate="yes" xml:space="preserve">
          <source>Multistream controls whether the reader supports multistream files.</source>
          <target state="translated">多流控制阅读器是否支持多流文件。</target>
        </trans-unit>
        <trans-unit id="5d72b823f6e2f60a18b59bcf20086228b774dfee" translate="yes" xml:space="preserve">
          <source>Must is a helper that wraps a call to a function returning (*Template, error) and panics if the error is non-nil. It is intended for use in variable initializations such as</source>
          <target state="translated">Must是一个帮助程序,它封装了对函数的调用,返回(*Template,error),并在错误为非nil时进行恐慌。它用于变量初始化,如</target>
        </trans-unit>
        <trans-unit id="a51f1ed56a509883e121438647786188d9af7d2f" translate="yes" xml:space="preserve">
          <source>MustCompile is like Compile but panics if the expression cannot be parsed. It simplifies safe initialization of global variables holding compiled regular expressions.</source>
          <target state="translated">MustCompile 和 Compile 一样,但如果表达式不能被解析,它就会惊慌失措。它简化了持有已编译正则表达式的全局变量的安全初始化。</target>
        </trans-unit>
        <trans-unit id="9116a0a3a6e98be619745d64aa7d73bda9c8d13e" translate="yes" xml:space="preserve">
          <source>MustCompilePOSIX is like CompilePOSIX but panics if the expression cannot be parsed. It simplifies safe initialization of global variables holding compiled regular expressions.</source>
          <target state="translated">MustCompilePOSIX 与 CompilePOSIX 类似,但如果表达式不能被解析,它就会惊慌失措。它简化了持有已编译正则表达式的全局变量的安全初始化。</target>
        </trans-unit>
        <trans-unit id="3784bc24f8a3c7e8d169e2b4535e09805ebe5ca0" translate="yes" xml:space="preserve">
          <source>MutexProfile returns n, the number of records in the current mutex profile. If len(p) &amp;gt;= n, MutexProfile copies the profile into p and returns n, true. Otherwise, MutexProfile does not change p, and returns n, false.</source>
          <target state="translated">MutexProfile返回n，即当前互斥配置文件中的记录数。如果len（p）&amp;gt; = n，则MutexProfile将配置文件复制到p中并返回n，为true。否则，MutexProfile不会更改p，并返回n，false。</target>
        </trans-unit>
        <trans-unit id="5d847ec5889f3982ffb9b7ffa72ed90e47750577" translate="yes" xml:space="preserve">
          <source>NArg is the number of arguments remaining after flags have been processed.</source>
          <target state="translated">NArg是处理完标志后剩余的参数数量。</target>
        </trans-unit>
        <trans-unit id="2f24c1c2739257b059d4d3dc9321f1cdf1115063" translate="yes" xml:space="preserve">
          <source>NFlag returns the number of command-line flags that have been set.</source>
          <target state="translated">NFlag返回已设置的命令行标志的数量。</target>
        </trans-unit>
        <trans-unit id="810e97bcf54f7c38d780b8018b94bedc96063ac9" translate="yes" xml:space="preserve">
          <source>NFlag returns the number of flags that have been set.</source>
          <target state="translated">NFlag返回已设置的标志数量。</target>
        </trans-unit>
        <trans-unit id="c725fb1ef92b939b16dd002af225b2de23e38031" translate="yes" xml:space="preserve">
          <source>NRGBA is an in-memory image whose At method returns color.NRGBA values.</source>
          <target state="translated">NRGBA是一个内存中的图像,其At方法返回color.NRGBA值。</target>
        </trans-unit>
        <trans-unit id="d8bb0d248591faba7b18624bf05d5a4e94d4a0a2" translate="yes" xml:space="preserve">
          <source>NRGBA represents a non-alpha-premultiplied 32-bit color.</source>
          <target state="translated">NRGBA代表一个非阿尔法预增的32位颜色。</target>
        </trans-unit>
        <trans-unit id="5b8e9eaa83b4e60710ae3746671221d4b97e37ff" translate="yes" xml:space="preserve">
          <source>NRGBA64 is an in-memory image whose At method returns color.NRGBA64 values.</source>
          <target state="translated">NRGBA64是一个内存中的图像,其At方法返回color.NRGBA64值。</target>
        </trans-unit>
        <trans-unit id="0c537b2ac3425dc17a66dbbf5b63bd3a7a48fb29" translate="yes" xml:space="preserve">
          <source>NRGBA64 represents a non-alpha-premultiplied 64-bit color, having 16 bits for each of red, green, blue and alpha.</source>
          <target state="translated">NRGBA64表示非alpha预增的64位颜色,红、绿、蓝和alpha各为16位。</target>
        </trans-unit>
        <trans-unit id="2cacdaed348d8c69a0481b79dcd2e483e182ae7b" translate="yes" xml:space="preserve">
          <source>NType values; used in core files.</source>
          <target state="translated">NType值;在核心文件中使用。</target>
        </trans-unit>
        <trans-unit id="dfe809819a7c3bc6a6cb826d8f87edea50d7df8a" translate="yes" xml:space="preserve">
          <source>NYCbCrA is an in-memory image of non-alpha-premultiplied Y'CbCr-with-alpha colors. A and AStride are analogous to the Y and YStride fields of the embedded YCbCr.</source>
          <target state="translated">NYCbCrA是一个非alpha预乘Y'CbCr-with-alpha颜色的内存图像。A和AStride类似于嵌入式YCbCr的Y和YStride字段。</target>
        </trans-unit>
        <trans-unit id="381ced7e52d37e0dab6bd72178c010245712478e" translate="yes" xml:space="preserve">
          <source>NYCbCrA represents a non-alpha-premultiplied Y'CbCr-with-alpha color, having 8 bits each for one luma, two chroma and one alpha component.</source>
          <target state="translated">NYCbCrA表示一个非alpha预增的Y'CbCr-with-alpha颜色,有8位,分别代表一个luma、两个chroma和一个alpha分量。</target>
        </trans-unit>
        <trans-unit id="3ddf7ce6d18dffcfd157667c9d84e86a1c6b7d4e" translate="yes" xml:space="preserve">
          <source>NYCbCrAModel is the Model for non-alpha-premultiplied Y'CbCr-with-alpha colors.</source>
          <target state="translated">NYCbCrAModel是非alpha预乘Y'CbCr-with-alpha颜色的模型。</target>
        </trans-unit>
        <trans-unit id="57d5b53b7b3ad276283b2d42d51634e430be6df3" translate="yes" xml:space="preserve">
          <source>NaN returns a complex &amp;ldquo;not-a-number&amp;rdquo; value.</source>
          <target state="translated">NaN返回一个复杂的&amp;ldquo;非数字&amp;rdquo;值。</target>
        </trans-unit>
        <trans-unit id="01647cea0fd9639449467ddb347270a0682c015d" translate="yes" xml:space="preserve">
          <source>NaN returns an IEEE 754 &amp;ldquo;not-a-number&amp;rdquo; value.</source>
          <target state="translated">NaN返回IEEE 754&amp;ldquo;非数字&amp;rdquo;值。</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="458abd2d58ca4f6a99a8329ebea64a0b18022e43" translate="yes" xml:space="preserve">
          <source>Name Resolution</source>
          <target state="translated">名称解析</target>
        </trans-unit>
        <trans-unit id="99409b3041e22d0d0c5a802c5fd9d08e77da5379" translate="yes" xml:space="preserve">
          <source>Name constraints in the intermediates will be applied to all names claimed in the chain, not just opts.DNSName. Thus it is invalid for a leaf to claim example.com if an intermediate doesn't permit it, even if example.com is not the name being validated. Note that DirectoryName constraints are not supported.</source>
          <target state="translated">中间体中的名称约束将被应用于链中所有的名称,而不仅仅是opts.DNSName。因此,如果中间体不允许叶子声明example.com,即使example.com不是被验证的名称,叶子声明example.com也是无效的。注意,不支持DirectoryName约束。</target>
        </trans-unit>
        <trans-unit id="0fba782366c931b096922fa065c94888533271bf" translate="yes" xml:space="preserve">
          <source>Name represents an X.509 distinguished name. This only includes the common elements of a DN. When parsing, all elements are stored in Names and non-standard elements can be extracted from there. When marshaling, elements in ExtraNames are appended and override other values with the same OID.</source>
          <target state="translated">名称代表一个X.509区分的名称。这只包括DN的普通元素。当解析时,所有元素都存储在Names中,非标准元素可以从那里提取。当marshaling时,ExtraNames中的元素会被附加,并覆盖其他具有相同OID的值。</target>
        </trans-unit>
        <trans-unit id="e3f01020dd86fefd968bc57f34e6cf3dc39dbcdc" translate="yes" xml:space="preserve">
          <source>Name resolution maps each identifier (ast.Ident) in the program to the language object (Object) it denotes. Use Info.{Defs,Uses,Implicits} for the results of name resolution.</source>
          <target state="translated">名称解析将程序中的每个标识符(ast.Ident)映射到它所表示的语言对象(Object)上。使用Info.{Defs,Uses,Implicits}获取名称解析的结果。</target>
        </trans-unit>
        <trans-unit id="dff2bc150a13aad1afbb3a0e77b91c6f29404d25" translate="yes" xml:space="preserve">
          <source>Name returns the file name of file f as registered with AddFile.</source>
          <target state="translated">Name 返回用 AddFile 注册的文件 f 的文件名。</target>
        </trans-unit>
        <trans-unit id="dbf0685fdc3e1fc7383fb6378b40c72d45ba31cf" translate="yes" xml:space="preserve">
          <source>Name returns the name of basic type b.</source>
          <target state="translated">名称返回基本类型b的名称。</target>
        </trans-unit>
        <trans-unit id="8fcb1133e9348f92420cdfc4678a083c2132530b" translate="yes" xml:space="preserve">
          <source>Name returns the name of the file as presented to Open.</source>
          <target state="translated">Name 返回提交给 Open 的文件名称。</target>
        </trans-unit>
        <trans-unit id="ddf8f3d9e671d5c8526b346806d1b0aee8900f60" translate="yes" xml:space="preserve">
          <source>Name returns the name of the flag set.</source>
          <target state="translated">名称返回标志集的名称。</target>
        </trans-unit>
        <trans-unit id="2302d490bb5c27edeb93f2429b3dd3925a94667d" translate="yes" xml:space="preserve">
          <source>Name returns the name of the function.</source>
          <target state="translated">Name 返回函数的名称。</target>
        </trans-unit>
        <trans-unit id="1e85527ce244650d2eef45c942c6fb4c49d00958" translate="yes" xml:space="preserve">
          <source>Name returns the name of the running test or benchmark.</source>
          <target state="translated">Name 返回正在运行的测试或基准的名称。</target>
        </trans-unit>
        <trans-unit id="ae31bd0a4e13087d9881916ed12efd37cc202962" translate="yes" xml:space="preserve">
          <source>Name returns the name of the template.</source>
          <target state="translated">名称返回模板的名称。</target>
        </trans-unit>
        <trans-unit id="9d0afdb2756b72089c5803a1fea5a6f6af89abf2" translate="yes" xml:space="preserve">
          <source>Name returns the name or alias of the column.</source>
          <target state="translated">Name 返回列的名称或别名。</target>
        </trans-unit>
        <trans-unit id="6fdae4adddc5e0ab59190994aa36753a8da75cde" translate="yes" xml:space="preserve">
          <source>Name returns the object's (package-local, unqualified) name.</source>
          <target state="translated">Name 返回对象的(package-local,unqualified)名称。</target>
        </trans-unit>
        <trans-unit id="715e38c6f54ac0414267875866ec7639f2185b6c" translate="yes" xml:space="preserve">
          <source>Name returns the package name.</source>
          <target state="translated">Name返回包名。</target>
        </trans-unit>
        <trans-unit id="f2f1501e711468701351739094e89f2faaa9754b" translate="yes" xml:space="preserve">
          <source>Name returns this profile's name, which can be passed to Lookup to reobtain the profile.</source>
          <target state="translated">Name返回这个配置文件的名称,它可以被传递给Lookup以重新获取配置文件。</target>
        </trans-unit>
        <trans-unit id="07ef5638500e255787c53cfed76765c95ef368f8" translate="yes" xml:space="preserve">
          <source>Named character classes as character class elements:</source>
          <target state="translated">将字符类命名为字符类元素。</target>
        </trans-unit>
        <trans-unit id="5214e3c70b9463e72846eff24f10e0e17205139c" translate="yes" xml:space="preserve">
          <source>Named provides a more concise way to create NamedArg values.</source>
          <target state="translated">Named提供了一种更简洁的方式来创建NamedArg值。</target>
        </trans-unit>
        <trans-unit id="9f9c1c1ca0e676e9e2072afd4d97cad1c4edafd2" translate="yes" xml:space="preserve">
          <source>NamedValue holds both the value name and value.</source>
          <target state="translated">NamedValue同时拥有值名和值。</target>
        </trans-unit>
        <trans-unit id="c99f38d2678a853989d8a832348bdca952de6c49" translate="yes" xml:space="preserve">
          <source>NamedValueChecker may be optionally implemented by Conn or Stmt. It provides the driver more control to handle Go and database types beyond the default Values types allowed.</source>
          <target state="translated">NamedValueChecker可以选择由Conn或Stmt实现。它为驱动程序提供了更多的控制,以处理Go和数据库类型,而不是默认允许的Value类型。</target>
        </trans-unit>
        <trans-unit id="4abb0014fb99c3ea27630821804136f4a291ddd2" translate="yes" xml:space="preserve">
          <source>Names returns the scope's element names in sorted order.</source>
          <target state="translated">Names按排序顺序返回作用域的元素名称。</target>
        </trans-unit>
        <trans-unit id="68be7148b1d69811d870e9714f9a627c5b3b1099" translate="yes" xml:space="preserve">
          <source>Naming a file dns_windows.go will cause it to be included only when building the package for Windows; similarly, math_386.s will be included only when building the package for 32-bit x86.</source>
          <target state="translated">将文件 dns_windows.go 命名为 dns_windows.go 将导致它只在为 Windows 构建包时被包含;同样,math_386.s 将只在为 32 位 x86 构建包时被包含。</target>
        </trans-unit>
        <trans-unit id="cabaa7d294786796f928e96fc93a4f221988121e" translate="yes" xml:space="preserve">
          <source>Nano returns ts as the number of nanoseconds elapsed since the Unix epoch.</source>
          <target state="translated">Nano 返回 ts,表示自 Unix 纪元以来经过的纳秒数。</target>
        </trans-unit>
        <trans-unit id="7cc13f72d19e3af8ee9e16f480775aaded9f3087" translate="yes" xml:space="preserve">
          <source>Nano returns tv as the number of nanoseconds elapsed since the Unix epoch.</source>
          <target state="translated">Nano 返回 tv,表示自 Unix 时代以来经过的纳秒数。</target>
        </trans-unit>
        <trans-unit id="0e6c24671bd350d239a637f4eb004b1ac035f0f6" translate="yes" xml:space="preserve">
          <source>Nanosecond returns the nanosecond offset within the second specified by t, in the range [0, 999999999].</source>
          <target state="translated">Nanosecond 返回t指定的秒内的纳秒偏移量,范围为[0,999999999]。</target>
        </trans-unit>
        <trans-unit id="9254412c6c417a32ffd67afde8a4d3f64458a58f" translate="yes" xml:space="preserve">
          <source>Nanoseconds returns the duration as an integer nanosecond count.</source>
          <target state="translated">Nanoseconds 返回以整数纳秒计算的持续时间。</target>
        </trans-unit>
        <trans-unit id="ba032ae40abdc5925e0860a082adf4aba20cf4c6" translate="yes" xml:space="preserve">
          <source>Neg sets z to -x and returns z.</source>
          <target state="translated">Neg设置z为-x,并返回z。</target>
        </trans-unit>
        <trans-unit id="381b641c01f8a09410b41524ec6b9c342099d866" translate="yes" xml:space="preserve">
          <source>Neg sets z to the (possibly rounded) value of x with its sign negated, and returns z.</source>
          <target state="translated">Neg设置z为x的(可能是四舍五入)值,并将其符号否定,然后返回z。</target>
        </trans-unit>
        <trans-unit id="8646ff662d17d59189bbe1c09e1b45ec2fcbe881" translate="yes" xml:space="preserve">
          <source>Nested template definitions</source>
          <target state="translated">嵌套模板定义</target>
        </trans-unit>
        <trans-unit id="d8c5cfb403999ea3c1717d789cd51587c786bc53" translate="yes" xml:space="preserve">
          <source>NetlinkMessage represents a netlink message.</source>
          <target state="translated">NetlinkMessage表示一个网链消息。</target>
        </trans-unit>
        <trans-unit id="9c4870d25f2151dc7bae14a92d6848398da82d87" translate="yes" xml:space="preserve">
          <source>NetlinkRIB returns routing information base, as known as RIB, which consists of network facility information, states and parameters.</source>
          <target state="translated">NetlinkRIB返回路由信息库,即RIB,它由网络设施信息、状态和参数组成。</target>
        </trans-unit>
        <trans-unit id="602233e97016bb5f79aa0bd9f5a926d8f7889c93" translate="yes" xml:space="preserve">
          <source>NetlinkRouteAttr represents a netlink route attribute.</source>
          <target state="translated">NetlinkRouteAttr表示一个网链路由属性。</target>
        </trans-unit>
        <trans-unit id="44279944636fb5149ee9e75b524255aa96e79a4e" translate="yes" xml:space="preserve">
          <source>NetlinkRouteRequest represents a request message to receive routing and link states from the kernel.</source>
          <target state="translated">NetlinkRouteRequest表示从内核接收路由和链路状态的请求消息。</target>
        </trans-unit>
        <trans-unit id="884a4650baee52e272bb3c5efceff09f71b0dc8c" translate="yes" xml:space="preserve">
          <source>Network returns the address's network name, &quot;ip&quot;.</source>
          <target state="translated">Network 返回地址的网络名 &quot;ip&quot;。</target>
        </trans-unit>
        <trans-unit id="872aebe8ec9741bc61a3685b3731dbde3529008c" translate="yes" xml:space="preserve">
          <source>Network returns the address's network name, &quot;ip+net&quot;.</source>
          <target state="translated">Network 返回地址的网络名 &quot;ip+net&quot;。</target>
        </trans-unit>
        <trans-unit id="fa465c71127a452dc67c99401e7bc2d64148685d" translate="yes" xml:space="preserve">
          <source>Network returns the address's network name, &quot;tcp&quot;.</source>
          <target state="translated">Network 返回地址的网络名 &quot;tcp&quot;。</target>
        </trans-unit>
        <trans-unit id="985257f66305f39d2139512f1ac004ba3741bdd6" translate="yes" xml:space="preserve">
          <source>Network returns the address's network name, &quot;udp&quot;.</source>
          <target state="translated">Network 返回地址的网络名 &quot;udp&quot;。</target>
        </trans-unit>
        <trans-unit id="85eeab19d1e5738f817203c5a4d550375f022dc2" translate="yes" xml:space="preserve">
          <source>Network returns the address's network name, &quot;unix&quot;, &quot;unixgram&quot; or &quot;unixpacket&quot;.</source>
          <target state="translated">Network 返回地址的网络名称 &quot;unix&quot;、&quot;unixgram &quot;或 &quot;unixpacket&quot;。</target>
        </trans-unit>
        <trans-unit id="6403f2b7eb2aaafe6de34cbf2a029b01afebc512" translate="yes" xml:space="preserve">
          <source>New</source>
          <target state="translated">New</target>
        </trans-unit>
        <trans-unit id="73e705a3151bc08fd1addfd7992ec83ec85bc2d3" translate="yes" xml:space="preserve">
          <source>New (Errorf)</source>
          <target state="translated">新(错误)</target>
        </trans-unit>
        <trans-unit id="ce9f1f28f9b789d29a4ccd4ff058458cc3933476" translate="yes" xml:space="preserve">
          <source>New (File)</source>
          <target state="translated">新(文件)</target>
        </trans-unit>
        <trans-unit id="13a673772e81bed6fd77076f80c7ff1f6ee89e61" translate="yes" xml:space="preserve">
          <source>New allocates a new HTML template associated with the given one and with the same delimiters. The association, which is transitive, allows one template to invoke another with a {{template}} action.</source>
          <target state="translated">New分配一个新的HTML模板,该模板与给定的模板相关联,并使用相同的定界符。这种关联是转义的,允许一个模板用{{template}}动作调用另一个模板。</target>
        </trans-unit>
        <trans-unit id="1c98d75d213247ac29168d2da24b2789a4dbb7a8" translate="yes" xml:space="preserve">
          <source>New allocates a new HTML template with the given name.</source>
          <target state="translated">新建一个给定名称的HTML模板。</target>
        </trans-unit>
        <trans-unit id="34bc55c1fb0c505ee8f76b87c91bd2fc06fc027b" translate="yes" xml:space="preserve">
          <source>New allocates a new parse tree with the given name.</source>
          <target state="translated">New分配一个新的给定名称的解析树。</target>
        </trans-unit>
        <trans-unit id="685d42b22fd5f12d0d18a35ac55a1b6c69615a8a" translate="yes" xml:space="preserve">
          <source>New allocates a new, undefined template associated with the given one and with the same delimiters. The association, which is transitive, allows one template to invoke another with a {{template}} action.</source>
          <target state="translated">New分配一个新的、未定义的模板,该模板与给定的模板相关联,并且具有相同的定界符。这种关联是转义的,允许一个模板用{{template}}动作调用另一个模板。</target>
        </trans-unit>
        <trans-unit id="1bfbe44c21200e9acb8918513405e990a5ad64ec" translate="yes" xml:space="preserve">
          <source>New allocates a new, undefined template with the given name.</source>
          <target state="translated">新建分配一个新的、未定义的模板,并使用给定的名称。</target>
        </trans-unit>
        <trans-unit id="d58e7e7be4ff87f86b4026a755b5a08e8395893d" translate="yes" xml:space="preserve">
          <source>New changes in the system cert pool might not be reflected in subsequent calls.</source>
          <target state="translated">系统证书池中的新变化可能不会反映在后续调用中。</target>
        </trans-unit>
        <trans-unit id="e8732c118b0cc7bc660fa4e5273983e4bed17a5c" translate="yes" xml:space="preserve">
          <source>New computes the package documentation for the given package AST. New takes ownership of the AST pkg and may edit or overwrite it.</source>
          <target state="translated">New计算给定包AST的包文档。New 会拥有 AST pkg 的所有权,并可以编辑或覆盖它。</target>
        </trans-unit>
        <trans-unit id="42a02872376b9cd15170d6472cf48d2f256d4269" translate="yes" xml:space="preserve">
          <source>New creates a new Index for data. Index creation time is O(N) for N = len(data).</source>
          <target state="translated">New为数据创建一个新的Index。对于N=len(data),索引创建时间为O(N)。</target>
        </trans-unit>
        <trans-unit id="1938bcca0d3c4801a22481ce59e7278f4b6da953" translate="yes" xml:space="preserve">
          <source>New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line. The flag argument defines the logging properties.</source>
          <target state="translated">新建一个新的记录仪。out 变量设置了日志数据将被写入的目的地。前缀出现在每个生成的日志行的开头。标志参数定义了日志属性。</target>
        </trans-unit>
        <trans-unit id="9a296c49d13ddf053bb1930fb55493ded12e0b12" translate="yes" xml:space="preserve">
          <source>New creates a new hash.Hash32 computing the CRC-32 checksum using the polynomial represented by the Table. Its Sum method will lay the value out in big-endian byte order. The returned Hash32 also implements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to marshal and unmarshal the internal state of the hash.</source>
          <target state="translated">New创建一个新的哈希.Hash32使用Table表示的多项式计算CRC-32校验和。它的Sum方法将按大字节顺序列出值。返回的Hash32还实现了encoding.BinaryMarshaler和encoding.BinaryUnmarshaler来对哈希的内部状态进行marshal和unmarshal。</target>
        </trans-unit>
        <trans-unit id="f96eb28144daf2fb90bf412860be6e76ca52cf10" translate="yes" xml:space="preserve">
          <source>New creates a new hash.Hash64 computing the CRC-64 checksum using the polynomial represented by the Table. Its Sum method will lay the value out in big-endian byte order. The returned Hash64 also implements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to marshal and unmarshal the internal state of the hash.</source>
          <target state="translated">New创建一个新的Hash.Hash64使用Table表示的多项式计算CRC-64校验和。它的Sum方法将按大字节顺序列出值。返回的Hash64还实现了encoding.BinaryMarshaler和encoding.BinaryUnmarshaler来对哈希的内部状态进行marshal和unmarshal。</target>
        </trans-unit>
        <trans-unit id="44ec7b7b536da273869e89c5cb90df2959fd9688" translate="yes" xml:space="preserve">
          <source>New creates a ring of n elements.</source>
          <target state="translated">新建一个n元素的环。</target>
        </trans-unit>
        <trans-unit id="e7fd8b4c480fbc496999332eaae2de8518c1f830" translate="yes" xml:space="preserve">
          <source>New establishes a new connection to the system log daemon. Each write to the returned writer sends a log message with the given priority (a combination of the syslog facility and severity) and prefix tag. If tag is empty, the os.Args[0] is used.</source>
          <target state="translated">New建立一个与系统日志守护进程的新连接。每一次向返回的写入器写入时,都会用给定的优先级(syslog设施和严重性的组合)和前缀 tag 发送一条日志消息。如果 tag 为空,则使用 os.Args[0]。</target>
        </trans-unit>
        <trans-unit id="2c433bff47e0e23c62ed805b07cbec0f2f0b6f46" translate="yes" xml:space="preserve">
          <source>New returns a Value representing a pointer to a new zero value for the specified type. That is, the returned Value's Type is PtrTo(typ).</source>
          <target state="translated">New返回一个Value,表示指向指定类型的新零值的指针,也就是说,返回的Value的类型是PtrTo(ty)。也就是说,返回的Value的类型是PtrTo(ty)。</target>
        </trans-unit>
        <trans-unit id="0c3bbfe7ec852d2a1508f7c286818c11369b8298" translate="yes" xml:space="preserve">
          <source>New returns a new Data object initialized from the given parameters. Rather than calling this function directly, clients should typically use the DWARF method of the File type of the appropriate package debug/elf, debug/macho, or debug/pe.</source>
          <target state="translated">New返回一个从给定参数初始化的新Data对象。客户端通常不需要直接调用这个函数,而是使用相应包debug/elf、debug/macho或debug/pe的文件类型的DWARF方法。</target>
        </trans-unit>
        <trans-unit id="34063232a48f53eca99c828d036ef36cf5de37bb" translate="yes" xml:space="preserve">
          <source>New returns a new HMAC hash using the given hash.Hash type and key. Note that unlike other hash implementations in the standard library, the returned Hash does not implement encoding.BinaryMarshaler or encoding.BinaryUnmarshaler.</source>
          <target state="translated">New使用给定的hash.Hash类型和密钥返回一个新的HMAC哈希。请注意,与标准库中的其他哈希实现不同,返回的Hash没有实现encoding.BinaryMarshaler或encoding.BinaryUnmarshaler。</target>
        </trans-unit>
        <trans-unit id="dae1d45948f3340a826a534080ea715da59576dc" translate="yes" xml:space="preserve">
          <source>New returns a new Rand that uses random values from src to generate other random values.</source>
          <target state="translated">New返回一个新的Rand,使用src的随机值来生成其他随机值。</target>
        </trans-unit>
        <trans-unit id="99c2c428e0dc030c03d2e8b41267ed3ddbe36dfb" translate="yes" xml:space="preserve">
          <source>New returns a new cookie jar. A nil *Options is equivalent to a zero Options.</source>
          <target state="translated">New返回一个新的cookie罐。nil *Options相当于Options为零。</target>
        </trans-unit>
        <trans-unit id="1f821272946e1801b5f1d4a05a86314806248536" translate="yes" xml:space="preserve">
          <source>New returns a new hash.Hash calculating the given hash function. New panics if the hash function is not linked into the binary.</source>
          <target state="translated">New返回一个新的hash.Hash,计算给定的哈希函数。如果哈希函数没有链接到二进制中,New会惊慌失措。</target>
        </trans-unit>
        <trans-unit id="1098b04617924fcea48eac93732552bb3d10a9b9" translate="yes" xml:space="preserve">
          <source>New returns a new hash.Hash computing the MD5 checksum. The Hash also implements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to marshal and unmarshal the internal state of the hash.</source>
          <target state="translated">New返回一个新的计算MD5校验和的hash.Hash。Hash还实现了encoding.BinaryMarshaler和encoding.BinaryUnmarshaler来对哈希的内部状态进行marshal和unmarshal。</target>
        </trans-unit>
        <trans-unit id="f0a16128a32aa274883c639054d37ccdc6937e39" translate="yes" xml:space="preserve">
          <source>New returns a new hash.Hash computing the SHA-512 checksum.</source>
          <target state="translated">New返回一个新的Hash.Hash计算SHA-512校验和。</target>
        </trans-unit>
        <trans-unit id="cf1f289ea19766f37df0d90899ff5c24c8ae2c4a" translate="yes" xml:space="preserve">
          <source>New returns a new hash.Hash computing the SHA1 checksum. The Hash also implements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to marshal and unmarshal the internal state of the hash.</source>
          <target state="translated">New返回一个新的计算SHA1校验和的hash.Hash。Hash还实现了encoding.BinaryMarshaler和encoding.BinaryUnmarshaler来对哈希的内部状态进行marshal和unmarshal。</target>
        </trans-unit>
        <trans-unit id="4fd916c9b4b6d94508616e145a5d3f06d397cd5d" translate="yes" xml:space="preserve">
          <source>New returns a new hash.Hash computing the SHA256 checksum. The Hash also implements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to marshal and unmarshal the internal state of the hash.</source>
          <target state="translated">New返回一个新的计算SHA256校验和的hash.Hash。Hash还实现了encoding.BinaryMarshaler和encoding.BinaryUnmarshaler来对哈希的内部状态进行marshal和unmarshal。</target>
        </trans-unit>
        <trans-unit id="f8209c7edf904061031f392b03dfd5924df101b5" translate="yes" xml:space="preserve">
          <source>New returns a new hash.Hash32 computing the Adler-32 checksum. Its Sum method will lay the value out in big-endian byte order. The returned Hash32 also implements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to marshal and unmarshal the internal state of the hash.</source>
          <target state="translated">New返回一个新的哈希.Hash32计算Adler-32校验和。它的Sum方法将按大字节顺序列出值。返回的Hash32还实现了encoding.BinaryMarshaler和encoding.BinaryUnmarshaler来对哈希的内部状态进行marshal和unmarshal。</target>
        </trans-unit>
        <trans-unit id="e84f60f6e65d95fd4ece96b0004a9de85df6b343" translate="yes" xml:space="preserve">
          <source>New returns an error that formats as the given text. Each call to New returns a distinct error value even if the text is identical.</source>
          <target state="translated">New返回一个格式为给定文本的错误。每次调用New都会返回一个不同的错误值,即使文本是相同的。</target>
        </trans-unit>
        <trans-unit id="2d8951b361a0209c54ff9386028d34a39773602f" translate="yes" xml:space="preserve">
          <source>New returns an initialized list.</source>
          <target state="translated">New返回一个初始化的列表。</target>
        </trans-unit>
        <trans-unit id="5801fe069c8fe2aaa55fda0624f44928b4775b87" translate="yes" xml:space="preserve">
          <source>New uses JavaScript's &quot;new&quot; operator with value v as constructor and the given arguments. It panics if v is not a JavaScript function. The arguments get mapped to JavaScript values according to the ValueOf function.</source>
          <target state="translated">New使用JavaScript的 &quot;new &quot;操作符,将值v作为构造函数和给定参数。如果v不是JavaScript函数,它就会惊慌失措。根据ValueOf函数,参数会被映射到JavaScript值。</target>
        </trans-unit>
        <trans-unit id="de47e55b8079b059389f17b105e9ffd1afb3a3e3" translate="yes" xml:space="preserve">
          <source>New128 returns a new 128-bit FNV-1 hash.Hash. Its Sum method will lay the value out in big-endian byte order.</source>
          <target state="translated">New128返回一个新的128位FNV-1哈希.Hash。它的Sum方法将按大字节顺序排列数值。</target>
        </trans-unit>
        <trans-unit id="a8005a100f6b39010fda63d549052f17d08741bd" translate="yes" xml:space="preserve">
          <source>New128a returns a new 128-bit FNV-1a hash.Hash. Its Sum method will lay the value out in big-endian byte order.</source>
          <target state="translated">New128a返回一个新的128位FNV-1a哈希.Hash。它的Sum方法将按大字节顺序排列数值。</target>
        </trans-unit>
        <trans-unit id="0ce753ca8c15a0a1b2e753ae81ad1104c1644498" translate="yes" xml:space="preserve">
          <source>New224 returns a new hash.Hash computing the SHA224 checksum.</source>
          <target state="translated">New224返回一个新的Hash.Hash计算SHA224校验和。</target>
        </trans-unit>
        <trans-unit id="ccc0f5023730b0e5ae85216a310b3047f4aa8ea2" translate="yes" xml:space="preserve">
          <source>New32 returns a new 32-bit FNV-1 hash.Hash. Its Sum method will lay the value out in big-endian byte order.</source>
          <target state="translated">New32返回一个新的32位FNV-1哈希.Hash。它的Sum方法将按大字节顺序排列数值。</target>
        </trans-unit>
        <trans-unit id="d56753001efd2485e723a8e5a73fff58d273b67c" translate="yes" xml:space="preserve">
          <source>New32a returns a new 32-bit FNV-1a hash.Hash. Its Sum method will lay the value out in big-endian byte order.</source>
          <target state="translated">New32a返回一个新的32位FNV-1a哈希.Hash。它的Sum方法将按大字节顺序排列数值。</target>
        </trans-unit>
        <trans-unit id="7d5d99bcf25b2336b4de3cdadf8a35eaf7a0c199" translate="yes" xml:space="preserve">
          <source>New384 returns a new hash.Hash computing the SHA-384 checksum.</source>
          <target state="translated">New384返回一个新的Hash.Hash计算SHA-384校验和。</target>
        </trans-unit>
        <trans-unit id="4b7f283752df73a2e87a9802891e3f0dd0c8d4d7" translate="yes" xml:space="preserve">
          <source>New512_224 returns a new hash.Hash computing the SHA-512/224 checksum.</source>
          <target state="translated">New512_224返回一个新的Hash.Hash计算SHA-512/224校验和。</target>
        </trans-unit>
        <trans-unit id="825abc60343f43e649b2364900655dff3568736f" translate="yes" xml:space="preserve">
          <source>New512_256 returns a new hash.Hash computing the SHA-512/256 checksum.</source>
          <target state="translated">New512_256返回一个新的Hash.Hash计算SHA-512/256校验和。</target>
        </trans-unit>
        <trans-unit id="d87077707d6ea0d456a51c30f664d7873c8bd355" translate="yes" xml:space="preserve">
          <source>New64 returns a new 64-bit FNV-1 hash.Hash. Its Sum method will lay the value out in big-endian byte order.</source>
          <target state="translated">New64返回一个新的64位FNV-1哈希.Hash。它的Sum方法将按大字节顺序排列数值。</target>
        </trans-unit>
        <trans-unit id="46dd6ddaccb45d3f0be1865973ec33eaa9f63cd3" translate="yes" xml:space="preserve">
          <source>New64a returns a new 64-bit FNV-1a hash.Hash. Its Sum method will lay the value out in big-endian byte order.</source>
          <target state="translated">New64a返回一个新的64位FNV-1a哈希.Hash。它的Sum方法将按大字节顺序排列数值。</target>
        </trans-unit>
        <trans-unit id="7b22f1177470c7c4e87fe25b4cd79c1fd84c6501" translate="yes" xml:space="preserve">
          <source>NewAlpha returns a new Alpha image with the given bounds.</source>
          <target state="translated">NewAlpha返回一个新的Alpha图像。</target>
        </trans-unit>
        <trans-unit id="add0bb0be61493133a58e39dd7700e6c9889401b" translate="yes" xml:space="preserve">
          <source>NewAlpha16 returns a new Alpha16 image with the given bounds.</source>
          <target state="translated">NewAlpha16返回给定边界的新Alpha16图像。</target>
        </trans-unit>
        <trans-unit id="4c61d8963b5a530bd472131f346eba16878a4408" translate="yes" xml:space="preserve">
          <source>NewArray returns a new array type for the given element type and length. A negative length indicates an unknown length.</source>
          <target state="translated">NewArray 返回给定元素类型和长度的新数组类型。长度为负数时表示未知长度。</target>
        </trans-unit>
        <trans-unit id="638c31aba3c5c6f8398df36fb530211241e94c4c" translate="yes" xml:space="preserve">
          <source>NewAt returns a Value representing a pointer to a value of the specified type, using p as that pointer.</source>
          <target state="translated">NewAt返回一个Value,代表指向指定类型的值的指针,使用p作为该指针。</target>
        </trans-unit>
        <trans-unit id="72dec367b963904f8628c7bf12ee4335879a75b8" translate="yes" xml:space="preserve">
          <source>NewBuffer creates and initializes a new Buffer using buf as its initial contents. The new Buffer takes ownership of buf, and the caller should not use buf after this call. NewBuffer is intended to prepare a Buffer to read existing data. It can also be used to set the initial size of the internal buffer for writing. To do that, buf should have the desired capacity but a length of zero.</source>
          <target state="translated">NewBuffer使用buf作为初始内容创建并初始化一个新的Buffer。新的Buffer拥有buf的所有权,调用者在调用后不应该使用buf。NewBuffer的目的是为读取现有数据准备一个Buffer。它也可以用来设置写入内部缓冲区的初始大小。要做到这一点,buf应该具有所需的容量,但长度为零。</target>
        </trans-unit>
        <trans-unit id="ed5f25f81fed45774081165b1641415b15da1746" translate="yes" xml:space="preserve">
          <source>NewBufferString creates and initializes a new Buffer using string s as its initial contents. It is intended to prepare a buffer to read an existing string.</source>
          <target state="translated">NewBufferString使用字符串s作为初始内容创建并初始化一个新的Buffer。它的目的是为了准备一个缓冲区来读取一个现有的字符串。</target>
        </trans-unit>
        <trans-unit id="22844417cd1bd7e56381df290ad9aba37327ed60" translate="yes" xml:space="preserve">
          <source>NewCBCDecrypter</source>
          <target state="translated">NewCBCDecrypter</target>
        </trans-unit>
        <trans-unit id="ca52eb6c91f944ba65ea2ffb0b84fcc2a10abe90" translate="yes" xml:space="preserve">
          <source>NewCBCDecrypter returns a BlockMode which decrypts in cipher block chaining mode, using the given Block. The length of iv must be the same as the Block's block size and must match the iv used to encrypt the data.</source>
          <target state="translated">NewCBCDecrypter返回一个BlockMode,它使用给定的Block以密码块链模式进行解密。iv的长度必须与Block的块大小相同,并且必须与用于加密数据的iv相匹配。</target>
        </trans-unit>
        <trans-unit id="255e7115ae5f4d3fbd66659d8c19d19341701776" translate="yes" xml:space="preserve">
          <source>NewCBCEncrypter</source>
          <target state="translated">NewCBCEncrypter</target>
        </trans-unit>
        <trans-unit id="fa88ee5beeb923f46e28b0b6307e4efcac6244ff" translate="yes" xml:space="preserve">
          <source>NewCBCEncrypter returns a BlockMode which encrypts in cipher block chaining mode, using the given Block. The length of iv must be the same as the Block's block size.</source>
          <target state="translated">NewCBCEncrypter返回一个BlockMode,使用给定的Block以密码块链模式进行加密。iv的长度必须与Block的块大小相同。</target>
        </trans-unit>
        <trans-unit id="38ff31a554e5558a01b8168178cf0796b7209a44" translate="yes" xml:space="preserve">
          <source>NewCFBDecrypter</source>
          <target state="translated">NewCFBDecrypter</target>
        </trans-unit>
        <trans-unit id="2d168991a51faf9df3fede3ceed6622acdae5d65" translate="yes" xml:space="preserve">
          <source>NewCFBDecrypter returns a Stream which decrypts with cipher feedback mode, using the given Block. The iv must be the same length as the Block's block size.</source>
          <target state="translated">NewCFBDecrypter使用给定的Block返回一个使用密码反馈模式解密的Stream。iv必须与Block的块大小相同的长度。</target>
        </trans-unit>
        <trans-unit id="08b4648ba8de6f7a55002e90d7740de77aaee124" translate="yes" xml:space="preserve">
          <source>NewCFBEncrypter</source>
          <target state="translated">NewCFBEncrypter</target>
        </trans-unit>
        <trans-unit id="46ae2754dd56eaa723f258dcc13d30b6a837033a" translate="yes" xml:space="preserve">
          <source>NewCFBEncrypter returns a Stream which encrypts with cipher feedback mode, using the given Block. The iv must be the same length as the Block's block size.</source>
          <target state="translated">NewCFBEncrypter使用给定的Block返回一个使用密码反馈模式加密的Stream。iv必须与Block的块大小相同的长度。</target>
        </trans-unit>
        <trans-unit id="253cccaa3711561810055bfc51a9b95d2ac7b353" translate="yes" xml:space="preserve">
          <source>NewCMYK returns a new CMYK image with the given bounds.</source>
          <target state="translated">NewCMYK 返回一个给定边界的新 CMYK 图像。</target>
        </trans-unit>
        <trans-unit id="f23a2508c9195bfe11e43b2f877a2121ff4896e8" translate="yes" xml:space="preserve">
          <source>NewCTR</source>
          <target state="translated">NewCTR</target>
        </trans-unit>
        <trans-unit id="48cf25f578fd7e4d9bde53a1056264acc0f6565d" translate="yes" xml:space="preserve">
          <source>NewCTR returns a Stream which encrypts/decrypts using the given Block in counter mode. The length of iv must be the same as the Block's block size.</source>
          <target state="translated">NewCTR返回一个流,它以计数器模式使用给定的Block进行加密/解密。iv的长度必须与Block的块大小相同。</target>
        </trans-unit>
        <trans-unit id="78b43a9ea76afd66f0e904c5af7000251dc2615e" translate="yes" xml:space="preserve">
          <source>NewCertPool returns a new, empty CertPool.</source>
          <target state="translated">NewCertPool 返回一个新的、空的 CertPool。</target>
        </trans-unit>
        <trans-unit id="24df68fca6c4873d326ba2cccc1b01b5610f3e8e" translate="yes" xml:space="preserve">
          <source>NewChan returns a new channel type for the given direction and element type.</source>
          <target state="translated">NewChan 返回给定方向和元素类型的新通道类型。</target>
        </trans-unit>
        <trans-unit id="62fa4bf0653f8c5396d1118a3de960d9396357d1" translate="yes" xml:space="preserve">
          <source>NewChecker returns a new Checker instance for a given package. Package files may be added incrementally via checker.Files.</source>
          <target state="translated">NewChecker为给定包返回一个新的Checker实例。软件包文件可以通过checker.Files.Files增量添加。</target>
        </trans-unit>
        <trans-unit id="2380ca2f8a09151f6aa44494bd0336745a8e73ba" translate="yes" xml:space="preserve">
          <source>NewChunkedReader is not needed by normal applications. The http package automatically decodes chunking when reading response bodies.</source>
          <target state="translated">一般的应用程序不需要NewChunkedReader。http包在读取响应体时,会自动解码chunking。</target>
        </trans-unit>
        <trans-unit id="f0cf338b02e3e48fa365cda270fb9dee555b3d17" translate="yes" xml:space="preserve">
          <source>NewChunkedReader returns a new chunkedReader that translates the data read from r out of HTTP &quot;chunked&quot; format before returning it. The chunkedReader returns io.EOF when the final 0-length chunk is read.</source>
          <target state="translated">NewChunkedReader返回一个新的chunkedReader,它将从r读取的数据翻译成HTTP &quot;chunked &quot;格式后再返回。当读取到最后一个0长度的分块时,chunkedReader会返回io.EOF。</target>
        </trans-unit>
        <trans-unit id="349a471f1f7196f4cd28f8d83c309c02f591534f" translate="yes" xml:space="preserve">
          <source>NewChunkedWriter is not needed by normal applications. The http package adds chunking automatically if handlers don't set a Content-Length header. Using NewChunkedWriter inside a handler would result in double chunking or chunking with a Content-Length length, both of which are wrong.</source>
          <target state="translated">一般的应用程序不需要NewChunkedWriter。如果处理程序没有设置Content-Length头,http包会自动添加分块。在处理程序中使用 NewChunkedWriter 会导致双重分块或带有 Content-Length 长度的分块,这两种情况都是错误的。</target>
        </trans-unit>
        <trans-unit id="b746b9ef76b22845d6f63dc9d95e97e36a08dd5c" translate="yes" xml:space="preserve">
          <source>NewChunkedWriter is not needed by normal applications. The http package adds chunking automatically if handlers don't set a Content-Length header. Using newChunkedWriter inside a handler would result in double chunking or chunking with a Content-Length length, both of which are wrong.</source>
          <target state="translated">一般的应用程序不需要NewChunkedWriter。如果处理程序没有设置Content-Length头,http包会自动添加分块。在处理程序中使用newChunkedWriter会导致双重分块或带有Content-Length长度的分块,这两种情况都是错误的。</target>
        </trans-unit>
        <trans-unit id="bbde3c49be540aed6f3b9a07213ce9f0f0985a47" translate="yes" xml:space="preserve">
          <source>NewChunkedWriter returns a new chunkedWriter that translates writes into HTTP &quot;chunked&quot; format before writing them to w. Closing the returned chunkedWriter sends the final 0-length chunk that marks the end of the stream but does not send the final CRLF that appears after trailers; trailers and the last CRLF must be written separately.</source>
          <target state="translated">NewChunkedWriter返回一个新的chunkedWriter,它将写的内容翻译成HTTP &quot;chunked &quot;格式,然后再写到w中,关闭返回的chunkedWriter会发送最后的0长度的chunk,标志着流的结束,但不会发送出现在预告片后的最后CRLF;预告片和最后的CRLF必须分开写。</target>
        </trans-unit>
        <trans-unit id="0f92d63907abdded9ec398f437e0cf965d51343f" translate="yes" xml:space="preserve">
          <source>NewCipher creates and returns a new Cipher. The key argument should be the RC4 key, at least 1 byte and at most 256 bytes.</source>
          <target state="translated">NewCipher创建并返回一个新的Cipher。密钥参数应该是RC4密钥,至少1个字节,最多256个字节。</target>
        </trans-unit>
        <trans-unit id="8328cb0f867c2e756f382b0ca63e4950d8850883" translate="yes" xml:space="preserve">
          <source>NewCipher creates and returns a new cipher.Block.</source>
          <target state="translated">NewCipher创建并返回一个新的cipher.Block。</target>
        </trans-unit>
        <trans-unit id="6b22b2787fd6b2ed8659da500429f9fa3fe86072" translate="yes" xml:space="preserve">
          <source>NewCipher creates and returns a new cipher.Block. The key argument should be the AES key, either 16, 24, or 32 bytes to select AES-128, AES-192, or AES-256.</source>
          <target state="translated">NewCipher创建并返回一个新的cipher.Block。密钥参数应该是AES密钥,可以是16、24或32字节,可以选择AES-128、AES-192或AES-256。</target>
        </trans-unit>
        <trans-unit id="b860dfa2340445fd2cf308e5a3748fea60faee9b" translate="yes" xml:space="preserve">
          <source>NewClient returns a new Client to handle requests to the set of services at the other end of the connection. It adds a buffer to the write side of the connection so the header and payload are sent as a unit.</source>
          <target state="translated">NewClient返回一个新的Client来处理对连接另一端的服务集的请求。它在连接的写端添加了一个缓冲区,因此头和有效载荷是作为一个单元发送的。</target>
        </trans-unit>
        <trans-unit id="b078c0d5ff1e636af20c5c0ed8dd22f85b7f4282" translate="yes" xml:space="preserve">
          <source>NewClient returns a new Client using an existing connection and host as a server name to be used when authenticating.</source>
          <target state="translated">NewClient返回一个新的客户端,使用现有的连接和主机作为服务器名称,在验证时使用。</target>
        </trans-unit>
        <trans-unit id="f8fb1181ae8a229864a05cfebb15c90112fff65c" translate="yes" xml:space="preserve">
          <source>NewClient returns a new rpc.Client to handle requests to the set of services at the other end of the connection.</source>
          <target state="translated">NewClient返回一个新的rpc.Client来处理对连接另一端的服务集的请求。</target>
        </trans-unit>
        <trans-unit id="856bbb45168cae23811fbc886f1b4d3be27846fe" translate="yes" xml:space="preserve">
          <source>NewClientCodec returns a new rpc.ClientCodec using JSON-RPC on conn.</source>
          <target state="translated">NewClientCodec在conn上使用JSON-RPC返回一个新的rpc.ClientCodec。</target>
        </trans-unit>
        <trans-unit id="b7383a602fa795d357297b4de95d8575b00a78ab" translate="yes" xml:space="preserve">
          <source>NewClientConn is an artifact of Go's early HTTP implementation. It is low-level, old, and unused by Go's current HTTP stack. We should have deleted it before Go 1.</source>
          <target state="translated">NewClientConn是Go早期HTTP实现的一个产物。它是低级的、旧的,而且没有被Go当前的HTTP栈使用。我们应该在Go 1之前删除它。</target>
        </trans-unit>
        <trans-unit id="4aa403c83da74918792480724a9f264584f0a604" translate="yes" xml:space="preserve">
          <source>NewClientWithCodec is like NewClient but uses the specified codec to encode requests and decode responses.</source>
          <target state="translated">NewClientWithCodec与NewClient类似,但使用指定的编解码器来编码请求和解码响应。</target>
        </trans-unit>
        <trans-unit id="413a5b89d02aeac4a6363a735de94f49289195bd" translate="yes" xml:space="preserve">
          <source>NewCommentMap creates a new comment map by associating comment groups of the comments list with the nodes of the AST specified by node.</source>
          <target state="translated">NewCommentMap通过将评论列表的评论组与节点指定的AST的节点关联起来,创建一个新的评论图。</target>
        </trans-unit>
        <trans-unit id="9378822df6d0b7340f61509bcb85e6fd00318896" translate="yes" xml:space="preserve">
          <source>NewCommentMap tries to associate a comment group to the &quot;largest&quot; node possible: For instance, if the comment is a line comment trailing an assignment, the comment is associated with the entire assignment rather than just the last operand in the assignment.</source>
          <target state="translated">NewCommentMap 试图将一个注释组关联到可能的 &quot;最大 &quot;节点。例如,如果注释是一个赋值后面的行注释,那么注释将与整个赋值相关联,而不仅仅是赋值中的最后一个操作数。</target>
        </trans-unit>
        <trans-unit id="4fd7049b9f856641359b9b5ca0cbb7b1cd2c0fac" translate="yes" xml:space="preserve">
          <source>NewCond returns a new Cond with Locker l.</source>
          <target state="translated">NewCond返回一个新的Cond与Locker l。</target>
        </trans-unit>
        <trans-unit id="eee961cdebdc3886242b174d6b32a3a25041270b" translate="yes" xml:space="preserve">
          <source>NewConn returns a new Conn using conn for I/O.</source>
          <target state="translated">NewConn返回一个使用conn作为I/O的新Conn。</target>
        </trans-unit>
        <trans-unit id="f81c5ab59d9f6c3c64039d6d5945f0e9cc54b88d" translate="yes" xml:space="preserve">
          <source>NewConst returns a new constant with value val. The remaining arguments set the attributes found with all Objects.</source>
          <target state="translated">NewConst 返回一个值为 val 的新常量。其余的参数设置了所有对象的属性。</target>
        </trans-unit>
        <trans-unit id="bdc96fab96f7e5d7b8628b8398bba38bf6580815" translate="yes" xml:space="preserve">
          <source>NewDecoder constructs a new ascii85 stream decoder.</source>
          <target state="translated">NewDecoder构造一个新的ascii85流解码器。</target>
        </trans-unit>
        <trans-unit id="369f6e69c20c8e4d13528053c51cd1d3a61e68de" translate="yes" xml:space="preserve">
          <source>NewDecoder constructs a new base32 stream decoder.</source>
          <target state="translated">NewDecoder构造一个新的base32流解码器。</target>
        </trans-unit>
        <trans-unit id="d864a240d883e7dc24b71e88a8d5c0c1948d801c" translate="yes" xml:space="preserve">
          <source>NewDecoder constructs a new base64 stream decoder.</source>
          <target state="translated">NewDecoder构造一个新的base64流解码器。</target>
        </trans-unit>
        <trans-unit id="060a7de61a5514feea18b0489167470b12d0112a" translate="yes" xml:space="preserve">
          <source>NewDecoder creates a new XML parser reading from r. If r does not implement io.ByteReader, NewDecoder will do its own buffering.</source>
          <target state="translated">如果r没有实现io.ByteReader,NewDecoder将自己进行缓冲。</target>
        </trans-unit>
        <trans-unit id="89572a28c9f62f14398327362d699001d2142b0d" translate="yes" xml:space="preserve">
          <source>NewDecoder returns a new decoder that reads from r.</source>
          <target state="translated">NewDecoder返回一个新的从r中读取的解码器。</target>
        </trans-unit>
        <trans-unit id="96af6984e1ed3c2ee798e01c4c02872b06029e89" translate="yes" xml:space="preserve">
          <source>NewDecoder returns a new decoder that reads from the io.Reader. If r does not also implement io.ByteReader, it will be wrapped in a bufio.Reader.</source>
          <target state="translated">NewDecoder 返回一个新的解码器,它从 io.Reader.Reader 中读取。如果r没有实现io.ByteReader,它将被包装在一个bufio.Reader中。</target>
        </trans-unit>
        <trans-unit id="56f76b42c4fa44e21b83722e16f9a4c656264781" translate="yes" xml:space="preserve">
          <source>NewDecoder returns an io.Reader that decodes hexadecimal characters from r. NewDecoder expects that r contain only an even number of hexadecimal characters.</source>
          <target state="translated">NewDecoder返回一个io.Reader,用于解码r中的十六进制字符,NewDecoder希望r中只包含偶数的十六进制字符。</target>
        </trans-unit>
        <trans-unit id="815c279b763f19acec3e56299892af2ccb9c6e0b" translate="yes" xml:space="preserve">
          <source>NewDecoder wraps an io.Reader interface around Decode.</source>
          <target state="translated">NewDecoder围绕Decode封装了一个io.Reader接口。</target>
        </trans-unit>
        <trans-unit id="415b5e5928dc67ca5917ce4d88ceda8c89e1b092" translate="yes" xml:space="preserve">
          <source>NewEncoder</source>
          <target state="translated">NewEncoder</target>
        </trans-unit>
        <trans-unit id="018ed3a7983059a17dab1b137a9844370d5a2b74" translate="yes" xml:space="preserve">
          <source>NewEncoder returns a new ascii85 stream encoder. Data written to the returned writer will be encoded and then written to w. Ascii85 encodings operate in 32-bit blocks; when finished writing, the caller must Close the returned encoder to flush any trailing partial block.</source>
          <target state="translated">NewEncoder返回一个新的ascii85流编码器。写入到返回的写入器的数据将被编码,然后写入到w中。Ascii85编码以32位块操作;当完成写入时,调用者必须关闭返回的编码器,以清除任何尾部的部分块。</target>
        </trans-unit>
        <trans-unit id="dd7f4a301864c468eb1cb40a57cdfbd02a050c05" translate="yes" xml:space="preserve">
          <source>NewEncoder returns a new base32 stream encoder. Data written to the returned writer will be encoded using enc and then written to w. Base32 encodings operate in 5-byte blocks; when finished writing, the caller must Close the returned encoder to flush any partially written blocks.</source>
          <target state="translated">NewEncoder返回一个新的base32流编码器。写入到返回的写入器中的数据将使用 enc 编码,然后写入到 w 中。base32 编码以 5 字节块为单位运行;当完成写入时,调用者必须关闭返回的编码器,以清除任何部分写入的块。</target>
        </trans-unit>
        <trans-unit id="44ee1dd433d92306638dd13e3127df94408d4089" translate="yes" xml:space="preserve">
          <source>NewEncoder returns a new base64 stream encoder. Data written to the returned writer will be encoded using enc and then written to w. Base64 encodings operate in 4-byte blocks; when finished writing, the caller must Close the returned encoder to flush any partially written blocks.</source>
          <target state="translated">NewEncoder返回一个新的base64流编码器。写入到返回的写入器中的数据将使用 enc 编码,然后写入到 w 中。Base64 编码以 4 字节块的形式运行;当完成写入时,调用者必须关闭返回的编码器以清除任何部分写入的块。</target>
        </trans-unit>
        <trans-unit id="d754a23d4130a807a013e53a62e7006beaa7e442" translate="yes" xml:space="preserve">
          <source>NewEncoder returns a new encoder that will transmit on the io.Writer.</source>
          <target state="translated">NewEncoder返回一个新的编码器,将在io.Writer.Writer上传输。</target>
        </trans-unit>
        <trans-unit id="d092172077c4670e0835be93cc4b418229db1d7a" translate="yes" xml:space="preserve">
          <source>NewEncoder returns a new encoder that writes to w.</source>
          <target state="translated">NewEncoder返回一个写入w的新编码器。</target>
        </trans-unit>
        <trans-unit id="6bc807b2bebb618f92c16dd28d4ba73b4801ef86" translate="yes" xml:space="preserve">
          <source>NewEncoder returns an io.Writer that writes lowercase hexadecimal characters to w.</source>
          <target state="translated">NewEncoder返回一个io.Writer,将小写的十六进制字符写入w。</target>
        </trans-unit>
        <trans-unit id="ec3215d4f7a860c50c96d8ebe05c612fbb607223" translate="yes" xml:space="preserve">
          <source>NewEncoding returns a new Encoding defined by the given alphabet, which must be a 32-byte string.</source>
          <target state="translated">NewEncoding 返回一个由给定字母定义的新编码,它必须是一个 32 字节的字符串。</target>
        </trans-unit>
        <trans-unit id="a225db48b3273b7eabd0d6e7950dc3ffe5785055" translate="yes" xml:space="preserve">
          <source>NewEncoding returns a new padded Encoding defined by the given alphabet, which must be a 64-byte string that does not contain the padding character or CR / LF ('\r', '\n'). The resulting Encoding uses the default padding character ('='), which may be changed or disabled via WithPadding.</source>
          <target state="translated">NewEncoding返回一个由给定字母定义的新的填充编码,它必须是一个64字节的字符串,不包含填充字符或CR/LF('\r','\n')。产生的Encoding使用默认的padding字符('='),可以通过WithPadding改变或禁用。</target>
        </trans-unit>
        <trans-unit id="e3eb6effd2379105d96f5ae281be769ac968f9b4" translate="yes" xml:space="preserve">
          <source>NewFatFile creates a new FatFile for accessing all the Mach-O images in a universal binary. The Mach-O binary is expected to start at position 0 in the ReaderAt.</source>
          <target state="translated">NewFatFile创建一个新的FatFile,用于访问通用二进制中的所有Mach-O图像。Mach-O二进制文件应该从ReaderAt的0位置开始。</target>
        </trans-unit>
        <trans-unit id="d86df188426dbb1a1da9539d4f76b961b9e5801b" translate="yes" xml:space="preserve">
          <source>NewField returns a new variable representing a struct field. For embedded fields, the name is the unqualified type name / under which the field is accessible.</source>
          <target state="translated">NewField返回一个新的变量,代表一个结构字段。对于嵌入的字段,名称是字段可以访问的非限定类型名称。</target>
        </trans-unit>
        <trans-unit id="fa49724aa2bb7b06a7e49b7b14c21627f72f66fe" translate="yes" xml:space="preserve">
          <source>NewFile creates a new File for accessing a Mach-O binary in an underlying reader. The Mach-O binary is expected to start at position 0 in the ReaderAt.</source>
          <target state="translated">NewFile创建一个新的文件,用于访问底层阅读器中的Mach-O二进制文件。Mach-O二进制文件应该从ReaderAt的0位置开始。</target>
        </trans-unit>
        <trans-unit id="c4cb0bcb5da3b7cb9c222f07d952f1deb79331f9" translate="yes" xml:space="preserve">
          <source>NewFile creates a new File for accessing a PE binary in an underlying reader.</source>
          <target state="translated">NewFile创建一个新文件,用于访问底层读卡器中的PE二进制文件。</target>
        </trans-unit>
        <trans-unit id="fb3c69eb6155088ad1b0a5da31e3f5031165ea55" translate="yes" xml:space="preserve">
          <source>NewFile creates a new File for accessing a Plan 9 binary in an underlying reader. The Plan 9 binary is expected to start at position 0 in the ReaderAt.</source>
          <target state="translated">NewFile创建了一个新文件,用于访问底层读卡器中的Plan 9二进制文件。Plan 9二进制文件将从ReaderAt的0位置开始。</target>
        </trans-unit>
        <trans-unit id="02c382510f60f7ac0e7f9dd332c2062d9f122bae" translate="yes" xml:space="preserve">
          <source>NewFile creates a new File for accessing an ELF binary in an underlying reader. The ELF binary is expected to start at position 0 in the ReaderAt.</source>
          <target state="translated">NewFile创建一个新的文件,用于访问底层阅读器中的ELF二进制文件。ELF二进制文件被期望从ReaderAt的0位置开始。</target>
        </trans-unit>
        <trans-unit id="dd7d78c4172dcb2fe6cfcff9bb7e67f44f614ee3" translate="yes" xml:space="preserve">
          <source>NewFile returns a new File with the given file descriptor and name. The returned value will be nil if fd is not a valid file descriptor. On Unix systems, if the file descriptor is in non-blocking mode, NewFile will attempt to return a pollable File (one for which the SetDeadline methods work).</source>
          <target state="translated">NewFile 用给定的文件描述符和名称返回一个新文件。如果fd不是一个有效的文件描述符,那么返回的值将是nil。在Unix系统中,如果文件描述符处于非阻塞模式,NewFile将尝试返回一个可轮询的文件(SetDeadline方法可以使用的文件)。</target>
        </trans-unit>
        <trans-unit id="146b2f1f1201d86650233642cb2b7d8638ac3e22" translate="yes" xml:space="preserve">
          <source>NewFileSet creates a new file set.</source>
          <target state="translated">NewFileSet创建一个新的文件集。</target>
        </trans-unit>
        <trans-unit id="39ae9e749e1c008bbfaf63f08fa2bb4e930b56b2" translate="yes" xml:space="preserve">
          <source>NewFileTransport returns a new RoundTripper, serving the provided FileSystem. The returned RoundTripper ignores the URL host in its incoming requests, as well as most other properties of the request.</source>
          <target state="translated">NewFileTransport 返回一个新的 RoundTripper,为提供的 FileSystem 服务。返回的 RoundTripper 忽略传入请求中的 URL 主机以及请求的大多数其他属性。</target>
        </trans-unit>
        <trans-unit id="f495b9657d10d27f36446d430fd6f4942c405b7b" translate="yes" xml:space="preserve">
          <source>NewFlagSet returns a new, empty flag set with the specified name and error handling property. If the name is not empty, it will be printed in the default usage message and in error messages.</source>
          <target state="translated">NewFlagSet返回一个新的、空的标志集,它具有指定的名称和错误处理属性。如果名称不是空的,它将被打印在默认的使用信息和错误信息中。</target>
        </trans-unit>
        <trans-unit id="6c1be2205981424ac6113bbac1c50ddc8e645067" translate="yes" xml:space="preserve">
          <source>NewFloat allocates and returns a new Float set to x, with precision 53 and rounding mode ToNearestEven. NewFloat panics with ErrNaN if x is a NaN.</source>
          <target state="translated">NewFloat分配并返回一个新的Float集到x,精度为53,舍入模式为ToNearestEven。如果x是一个NaN,NewFloat会用ErrNaN恐慌。</target>
        </trans-unit>
        <trans-unit id="62cad2834cd366b48375257d77d59b7e9a0915c1" translate="yes" xml:space="preserve">
          <source>NewFunc returns a new function with the given signature, representing the function's type.</source>
          <target state="translated">NewFunc 用给定的签名返回一个新函数,代表函数的类型。</target>
        </trans-unit>
        <trans-unit id="1ab1fbb5a4b914ad66a4cae1cb655fa076b9ba96" translate="yes" xml:space="preserve">
          <source>NewGCM (Decrypt)</source>
          <target state="translated">NewGCM(解密)</target>
        </trans-unit>
        <trans-unit id="88779115714f813ff34a3c2fff6aef4d291f21ae" translate="yes" xml:space="preserve">
          <source>NewGCM (Encrypt)</source>
          <target state="translated">新GCM(加密)</target>
        </trans-unit>
        <trans-unit id="d8e7f4fd8eb6323a1d235af8804d7f84b6c49124" translate="yes" xml:space="preserve">
          <source>NewGCM returns the given 128-bit, block cipher wrapped in Galois Counter Mode with the standard nonce length.</source>
          <target state="translated">NewGCM返回给定的128位、以伽罗瓦计数器模式封装的标准非ce长度的块密码。</target>
        </trans-unit>
        <trans-unit id="1973de63c4df3596c58655e33db1f26efd7af742" translate="yes" xml:space="preserve">
          <source>NewGCMWithNonceSize returns the given 128-bit, block cipher wrapped in Galois Counter Mode, which accepts nonces of the given length.</source>
          <target state="translated">NewGCMWithNonceSize返回给定的128位,以Galois Counter Mode封装的块密码,它接受给定长度的nonces。</target>
        </trans-unit>
        <trans-unit id="c89798890939059366d5fe1d2975869f4976a143" translate="yes" xml:space="preserve">
          <source>NewGCMWithTagSize returns the given 128-bit, block cipher wrapped in Galois Counter Mode, which generates tags with the given length.</source>
          <target state="translated">NewGCMWithTagSize返回给定的128位,以Galois Counter模式封装的块密码,生成给定长度的标签。</target>
        </trans-unit>
        <trans-unit id="454b2fc86978be3ab7ad864f00d10ff49dc84b08" translate="yes" xml:space="preserve">
          <source>NewGray returns a new Gray image with the given bounds.</source>
          <target state="translated">NewGray 返回一个给定边界的新格雷图像。</target>
        </trans-unit>
        <trans-unit id="3f20d3a865eb95651d9773b55020e283c7cda789" translate="yes" xml:space="preserve">
          <source>NewGray16 returns a new Gray16 image with the given bounds.</source>
          <target state="translated">NewGray16 返回一个给定边界的新的 Gray16 图像。</target>
        </trans-unit>
        <trans-unit id="7063568571cff8011c550348a1d249dbcd1b3164" translate="yes" xml:space="preserve">
          <source>NewIEEE creates a new hash.Hash32 computing the CRC-32 checksum using the IEEE polynomial. Its Sum method will lay the value out in big-endian byte order. The returned Hash32 also implements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to marshal and unmarshal the internal state of the hash.</source>
          <target state="translated">NewIEEE创建一个新的哈希.Hash32使用IEEE多项式计算CRC-32校验和。它的Sum方法将按大字节顺序排列出值。返回的Hash32还实现了encoding.BinaryMarshaler和encoding.BinaryUnmarshaler来对哈希的内部状态进行marshal和unmarshal。</target>
        </trans-unit>
        <trans-unit id="4d0116b71b732a25476a4fce3bfdd9a186665b0a" translate="yes" xml:space="preserve">
          <source>NewIdent creates a new Ident without position. Useful for ASTs generated by code other than the Go parser.</source>
          <target state="translated">NewIdent 创建一个没有位置的新Ident。对由Go解析器以外的代码生成的AST有用。</target>
        </trans-unit>
        <trans-unit id="a1da620d7851b36eddceb2d1155bd10520ef1e3d" translate="yes" xml:space="preserve">
          <source>NewIdentifier returns a new IdentifierNode with the given identifier name.</source>
          <target state="translated">NewIdentifier返回一个带有给定标识符名称的新IdentifierNode。</target>
        </trans-unit>
        <trans-unit id="525b5936156155224309c259d63dc7a201bbb3b9" translate="yes" xml:space="preserve">
          <source>NewInt allocates and returns a new Int set to x.</source>
          <target state="translated">NewInt分配并返回一个新的Int集到x。</target>
        </trans-unit>
        <trans-unit id="ce33b2838258d1a7fb77fc3c2496c70b71309e0c" translate="yes" xml:space="preserve">
          <source>NewInterface returns a new (incomplete) interface for the given methods and embedded types. Each embedded type must have an underlying type of interface type. NewInterface takes ownership of the provided methods and may modify their types by setting missing receivers. To compute the method set of the interface, Complete must be called.</source>
          <target state="translated">NewInterface为给定的方法和嵌入式类型返回一个新的(不完整的)接口。每个嵌入式类型必须有一个底层的接口类型。NewInterface拥有所给方法的所有权,并可以通过设置缺失的接收器来修改它们的类型。要计算接口的方法集,必须调用Complete。</target>
        </trans-unit>
        <trans-unit id="c1879314ab1ca85d9a540a3d842506cb8e3d5935" translate="yes" xml:space="preserve">
          <source>NewInterfaceType returns a new (incomplete) interface for the given methods and embedded types. Each embedded type must have an underlying type of interface type (this property is not verified for defined types, which may be in the process of being set up and which don't have a valid underlying type yet). NewInterfaceType takes ownership of the provided methods and may modify their types by setting missing receivers. To compute the method set of the interface, Complete must be called.</source>
          <target state="translated">NewInterfaceType为给定的方法和嵌入式类型返回一个新的(不完整的)接口。每个嵌入式类型必须有一个接口类型的底层类型(对于定义的类型,这个属性没有经过验证,因为这些类型可能正在设置过程中,还没有一个有效的底层类型)。NewInterfaceType对所提供的方法拥有所有权,并可以通过设置缺失的接收器来修改其类型。要计算接口的方法集,必须调用 Complete。</target>
        </trans-unit>
        <trans-unit id="412fcf56e8322a2530a374f7516c3ab81d822a6e" translate="yes" xml:space="preserve">
          <source>NewKeyFromSeed calculates a private key from a seed. It will panic if len(seed) is not SeedSize. This function is provided for interoperability with RFC 8032. RFC 8032's private keys correspond to seeds in this package.</source>
          <target state="translated">NewKeyFromSeed从种子中计算出一个私钥。如果len(seed)不是SeedSize,它将会恐慌。提供这个函数是为了与 RFC 8032 互操作。RFC 8032 的私钥对应于这个包中的种子。</target>
        </trans-unit>
        <trans-unit id="7f204c9bcbc69e7346a4be4a91e71094cadba874" translate="yes" xml:space="preserve">
          <source>NewLRUClientSessionCache returns a ClientSessionCache with the given capacity that uses an LRU strategy. If capacity is &amp;lt; 1, a default capacity is used instead.</source>
          <target state="translated">NewLRUClientSessionCache返回具有使用LRU策略的给定容量的ClientSessionCache。如果容量&amp;lt;1，则使用默认容量。</target>
        </trans-unit>
        <trans-unit id="e85de83deae1f6ea413617fafa918347032b364d" translate="yes" xml:space="preserve">
          <source>NewLabel returns a new label.</source>
          <target state="translated">NewLabel 返回一个新标签。</target>
        </trans-unit>
        <trans-unit id="c00322f2990498c11eaea48009e4263db8d2b147" translate="yes" xml:space="preserve">
          <source>NewLineTable returns a new PC/line table corresponding to the encoded data. Text must be the start address of the corresponding text segment.</source>
          <target state="translated">NewLineTable 返回一个与编码数据相对应的新 PC/行表。文本必须是相应文本段的起始地址。</target>
        </trans-unit>
        <trans-unit id="ee273ce2cc40669abe88f8cbd5b969c8b99cc1d8" translate="yes" xml:space="preserve">
          <source>NewListener creates a Listener which accepts connections from an inner Listener and wraps each connection with Server. The configuration config must be non-nil and must include at least one certificate or else set GetCertificate.</source>
          <target state="translated">NewListener创建了一个Listener,它接受来自内部Listener的连接,并用Server包装每个连接。配置config必须是非零,并且必须包含至少一个证书,否则设置GetCertificate。</target>
        </trans-unit>
        <trans-unit id="b8ae0fc1fd1b3795d43931c769132b8b76d67124" translate="yes" xml:space="preserve">
          <source>NewLogger creates a log.Logger whose output is written to the system log service with the specified priority, a combination of the syslog facility and severity. The logFlag argument is the flag set passed through to log.New to create the Logger.</source>
          <target state="translated">NewLogger创建一个log.Logger,其输出以指定的优先级写入系统日志服务,这是syslog设施和严重性的组合。logFlag参数是传递给log.New创建Logger的标志集。</target>
        </trans-unit>
        <trans-unit id="c2cf8bf27d6896fb60a3c00c2f29046150140e53" translate="yes" xml:space="preserve">
          <source>NewMap returns a new map for the given key and element types.</source>
          <target state="translated">NewMap返回给定键和元素类型的新地图。</target>
        </trans-unit>
        <trans-unit id="02aaaae9f75a28f52b63beb3faa08f1c64a67962" translate="yes" xml:space="preserve">
          <source>NewMethodSet returns the method set for the given type T. It always returns a non-nil method set, even if it is empty.</source>
          <target state="translated">NewMethodSet 返回给定类型 T 的方法集。它总是返回一个非零的方法集,即使它是空的。</target>
        </trans-unit>
        <trans-unit id="8a80c96af1db7665cca4280156494ace76054fb6" translate="yes" xml:space="preserve">
          <source>NewNRGBA returns a new NRGBA image with the given bounds.</source>
          <target state="translated">NewNRGBA 返回一个给定边界的新 NRGBA 图像。</target>
        </trans-unit>
        <trans-unit id="91846ee562c7c231bc0d057ad08777b2cf971613" translate="yes" xml:space="preserve">
          <source>NewNRGBA64 returns a new NRGBA64 image with the given bounds.</source>
          <target state="translated">NewNRGBA64 返回一个给定边界的新 NRGBA64 图像。</target>
        </trans-unit>
        <trans-unit id="808f42c5f206bd7e6ba827599de3fbf867803134" translate="yes" xml:space="preserve">
          <source>NewNYCbCrA returns a new NYCbCrA image with the given bounds and subsample ratio.</source>
          <target state="translated">NewNYCbCrA返回一个新的NYCbCrA图像,具有给定的边界和子样本比。</target>
        </trans-unit>
        <trans-unit id="1fd8ffb265de65f1861cce1196f85b25e1d6856a" translate="yes" xml:space="preserve">
          <source>NewNamed returns a new named type for the given type name, underlying type, and associated methods. If the given type name obj doesn't have a type yet, its type is set to the returned named type. The underlying type must not be a *Named.</source>
          <target state="translated">NewNamed为给定的类型名、底层类型和相关方法返回一个新的命名类型。如果给定的类型名obj还没有类型,那么它的类型将被设置为返回的命名类型。底层类型必须不是一个*Named。</target>
        </trans-unit>
        <trans-unit id="e782c15bb55a8ae8ebce9f874df5b1a0c46216d1" translate="yes" xml:space="preserve">
          <source>NewOFB</source>
          <target state="translated">NewOFB</target>
        </trans-unit>
        <trans-unit id="b57f2ce3c1f5586132093d982185af2e0ee68f6c" translate="yes" xml:space="preserve">
          <source>NewOFB returns a Stream that encrypts or decrypts using the block cipher b in output feedback mode. The initialization vector iv's length must be equal to b's block size.</source>
          <target state="translated">NewOFB返回一个使用输出反馈模式下的块密码b进行加密或解密的Stream。初始化向量iv的长度必须等于b的块大小。</target>
        </trans-unit>
        <trans-unit id="8ec79b70c4182bbf15d13c7ed9c2f93fc95d113e" translate="yes" xml:space="preserve">
          <source>NewObj creates a new object of a given kind and name.</source>
          <target state="translated">NewObj创建一个给定种类和名称的新对象。</target>
        </trans-unit>
        <trans-unit id="36552f14153f539c86094444ec1ce5a1a1e5bd03" translate="yes" xml:space="preserve">
          <source>NewPackage creates a new Package node from a set of File nodes. It resolves unresolved identifiers across files and updates each file's Unresolved list accordingly. If a non-nil importer and universe scope are provided, they are used to resolve identifiers not declared in any of the package files. Any remaining unresolved identifiers are reported as undeclared. If the files belong to different packages, one package name is selected and files with different package names are reported and then ignored. The result is a package node and a scanner.ErrorList if there were errors.</source>
          <target state="translated">NewPackage 从一组 File 节点中创建一个新的 Package 节点。它跨文件解析未解析的标识符,并相应地更新每个文件的未解析列表。如果提供了一个非零的导入器和宇宙范围,它们将被用来解析未在任何包文件中声明的标识符。任何剩余的未解析的标识符都会被报告为未声明。如果文件属于不同的包,则选择一个包名,报告不同包名的文件,然后忽略。结果是一个包节点和一个 scanner.ErrorList(如果有错误)。</target>
        </trans-unit>
        <trans-unit id="8b93023f444decd83a57effbd1356f40d43944cd" translate="yes" xml:space="preserve">
          <source>NewPackage returns a new Package for the given package path and name. The package is not complete and contains no explicit imports.</source>
          <target state="translated">NewPackage 返回给定包的路径和名称的新包。该包并不完整,也不包含任何显式导入。</target>
        </trans-unit>
        <trans-unit id="7604882861f8171ac92bb5a0ff3402c04452837d" translate="yes" xml:space="preserve">
          <source>NewPaletted returns a new Paletted image with the given width, height and palette.</source>
          <target state="translated">NewPaletted以给定的宽度、高度和调色板返回一个新的Paletted图像。</target>
        </trans-unit>
        <trans-unit id="8157edaefd4d8244aead4c748c2239a1e9cdf406" translate="yes" xml:space="preserve">
          <source>NewParam returns a new variable representing a function parameter.</source>
          <target state="translated">NewParam 返回一个代表函数参数的新变量。</target>
        </trans-unit>
        <trans-unit id="760c953eeca5555c276ff2137d11f1ac464a3878" translate="yes" xml:space="preserve">
          <source>NewPkgName returns a new PkgName object representing an imported package. The remaining arguments set the attributes found with all Objects.</source>
          <target state="translated">NewPkgName 返回一个新的 PkgName 对象,代表一个导入的软件包。其余的参数设置了所有 Objects 的属性。</target>
        </trans-unit>
        <trans-unit id="7267fd8d7fb296d4d49d2c7f2fba8f9caa6a9909" translate="yes" xml:space="preserve">
          <source>NewPointer returns a new pointer type for the given element (base) type.</source>
          <target state="translated">NewPointer返回给定元素(base)类型的新指针类型。</target>
        </trans-unit>
        <trans-unit id="ad8326fa0e1c2920bea4e6fdd7be9537d18c5951" translate="yes" xml:space="preserve">
          <source>NewProfile creates a new profile with the given name. If a profile with that name already exists, NewProfile panics. The convention is to use a 'import/path.' prefix to create separate name spaces for each package. For compatibility with various tools that read pprof data, profile names should not contain spaces.</source>
          <target state="translated">NewProfile 用给定的名称创建一个新的配置文件。如果已经存在一个具有该名称的配置文件,NewProfile就会惊慌失措。惯例是使用 &quot;import/path.&quot;前缀来为每个包创建单独的名字空格。为了与各种读取 pprof 数据的工具兼容,profile 名称不应包含空格。</target>
        </trans-unit>
        <trans-unit id="7dee9fd54a2c7c0d2e2445231875724a5129fb2a" translate="yes" xml:space="preserve">
          <source>NewProxyClientConn is an artifact of Go's early HTTP implementation. It is low-level, old, and unused by Go's current HTTP stack. We should have deleted it before Go 1.</source>
          <target state="translated">NewProxyClientConn是Go早期HTTP实现的产物。它是低级的、旧的,而且没有被Go当前的HTTP栈使用。我们应该在Go 1之前删除它。</target>
        </trans-unit>
        <trans-unit id="7013b5c7630f0f9aff6a55861942f65a617ff634" translate="yes" xml:space="preserve">
          <source>NewRGBA returns a new RGBA image with the given bounds.</source>
          <target state="translated">NewRGBA 返回一个给定边界的新 RGBA 图像。</target>
        </trans-unit>
        <trans-unit id="06634c84293e78aa59af4c55605513918ba019e7" translate="yes" xml:space="preserve">
          <source>NewRGBA64 returns a new RGBA64 image with the given bounds.</source>
          <target state="translated">NewRGBA64 以给定的边界返回一个新的 RGBA64 图像。</target>
        </trans-unit>
        <trans-unit id="00d97e53207565a29c223d381563f8ace2580585" translate="yes" xml:space="preserve">
          <source>NewRat creates a new Rat with numerator a and denominator b.</source>
          <target state="translated">NewRat创建一个新的Rat,分子a和分母b。</target>
        </trans-unit>
        <trans-unit id="8b51e66ddf0c0bc242e2972b3ed47f8e19aa8aff" translate="yes" xml:space="preserve">
          <source>NewReadLogger returns a reader that behaves like r except that it logs (using log.Printf) each read to standard error, printing the prefix and the hexadecimal data read.</source>
          <target state="translated">NewReadLogger返回一个阅读器,它的行为与r类似,除了它将每次读取的数据记录(使用log.Printf)为标准错误,打印前缀和读取的十六进制数据。</target>
        </trans-unit>
        <trans-unit id="4ddd20c3c7ab3b134b41334b4749254502eec73c" translate="yes" xml:space="preserve">
          <source>NewReadWriter allocates a new ReadWriter that dispatches to r and w.</source>
          <target state="translated">NewReadWriter分配一个新的ReadWriter,派发给r和w。</target>
        </trans-unit>
        <trans-unit id="abdd552b8a6a378c711658cbda39673b4658c843" translate="yes" xml:space="preserve">
          <source>NewReader</source>
          <target state="translated">NewReader</target>
        </trans-unit>
        <trans-unit id="656b7888dc8300d6258cc09514612ef897a06356" translate="yes" xml:space="preserve">
          <source>NewReader creates a new ReadCloser. Reads from the returned ReadCloser read and decompress data from r. If r does not implement io.ByteReader, the decompressor may read more data than necessary from r. It is the caller's responsibility to call Close on the ReadCloser when done.</source>
          <target state="translated">NewReader创建一个新的ReadCloser.如果r没有实现io.ByteReader,那么解压器可能会从r中读取更多的数据。如果r没有实现io.ByteReader,解压器可能会从r中读取超过必要的数据,完成后调用Close ReadCloser是调用者的责任。</target>
        </trans-unit>
        <trans-unit id="03de0f94de657abcdcd727d93d1385934f4b4c2a" translate="yes" xml:space="preserve">
          <source>NewReader creates a new Reader reading from r.</source>
          <target state="translated">NewReader创建一个新的Reader,从r中读取。</target>
        </trans-unit>
        <trans-unit id="9310cd05d389a1e08ddfb9e4317d864d066d18ff" translate="yes" xml:space="preserve">
          <source>NewReader creates a new Reader reading the given reader. If r does not also implement io.ByteReader, the decompressor may read more data than necessary from r.</source>
          <target state="translated">NewReader创建一个新的Reader,读取给定的阅读器。如果r没有实现io.ByteReader,解压器可能会从r中读取超过必要的数据。</target>
        </trans-unit>
        <trans-unit id="1afded549345ec0238483e2ba55aa75ed2ded5bd" translate="yes" xml:space="preserve">
          <source>NewReader creates a new io.ReadCloser. Reads from the returned io.ReadCloser read and decompress data from r. If r does not also implement io.ByteReader, the decompressor may read more data than necessary from r. It is the caller's responsibility to call Close on the ReadCloser when finished reading. The number of bits to use for literal codes, litWidth, must be in the range [2,8] and is typically 8. It must equal the litWidth used during compression.</source>
          <target state="translated">NewReader创建一个新的io.ReadCloser。从返回的io.ReadCloser中读取并解压r中的数据。如果r没有实现io.ByteReader,解压器可能会从r中读取更多的数据,而不是必要的。用于文字代码的位数litWidth必须在[2,8]范围内,通常为8,它必须等于压缩过程中使用的litWidth。</target>
        </trans-unit>
        <trans-unit id="104785202390e0ba0e171f6e70831714a74466f6" translate="yes" xml:space="preserve">
          <source>NewReader creates a new multipart Reader reading from r using the given MIME boundary.</source>
          <target state="translated">NewReader使用给定的MIME边界创建一个新的多部分Reader从r中读取。</target>
        </trans-unit>
        <trans-unit id="c18de38552330a3ffd438fa2e288016ca23d0e4e" translate="yes" xml:space="preserve">
          <source>NewReader returns a new ReadCloser that can be used to read the uncompressed version of r. If r does not also implement io.ByteReader, the decompressor may read more data than necessary from r. It is the caller's responsibility to call Close on the ReadCloser when finished reading.</source>
          <target state="translated">NewReader返回一个新的ReadCloser,它可以用来读取r的非压缩版本。如果r没有实现io.ByteReader,那么解压器可能会从r中读取更多不必要的数据。</target>
        </trans-unit>
        <trans-unit id="36241ff4da2c1821f96dba25272112a2ddbe76ee" translate="yes" xml:space="preserve">
          <source>NewReader returns a new Reader reading from b.</source>
          <target state="translated">NewReader从b中返回一个新的Reader读数。</target>
        </trans-unit>
        <trans-unit id="9e007e6c23a0a667f419ff954033af0ca806b580" translate="yes" xml:space="preserve">
          <source>NewReader returns a new Reader reading from r, which is assumed to have the given size in bytes.</source>
          <target state="translated">NewReader返回一个新的Reader,从r中读取,假设它有给定的字节大小。</target>
        </trans-unit>
        <trans-unit id="0a237744e6cd622e08bcaadcb57e9896c2c1bd36" translate="yes" xml:space="preserve">
          <source>NewReader returns a new Reader reading from r.</source>
          <target state="translated">NewReader从r返回一个新的Reader读物。</target>
        </trans-unit>
        <trans-unit id="8809e71360f0f480fd09d2bb6c73d758eb20bf24" translate="yes" xml:space="preserve">
          <source>NewReader returns a new Reader reading from s. It is similar to bytes.NewBufferString but more efficient and read-only.</source>
          <target state="translated">NewReader返回一个从s读取的新Reader,它类似于bytes.NewBufferString,但更高效且只读。</target>
        </trans-unit>
        <trans-unit id="4b591a6aa8b2fa42d203301d41858890dc4a8ba3" translate="yes" xml:space="preserve">
          <source>NewReader returns a new Reader that reads from r.</source>
          <target state="translated">NewReader返回一个新的Reader,从r中读取。</target>
        </trans-unit>
        <trans-unit id="c08939cbf0fe51e296c0a2ccf3a3311832697807" translate="yes" xml:space="preserve">
          <source>NewReader returns a new Reader whose buffer has the default size.</source>
          <target state="translated">NewReader返回一个新的Reader,它的缓冲区有默认的大小。</target>
        </trans-unit>
        <trans-unit id="ab008cb6047aabfffe29520f5a1d9f6947d1bb37" translate="yes" xml:space="preserve">
          <source>NewReader returns a quoted-printable reader, decoding from r.</source>
          <target state="translated">NewReader返回一个可引用打印的阅读器,由r解码。</target>
        </trans-unit>
        <trans-unit id="15423ba5dc90eb7ca320aa86b1e4769688d373ee" translate="yes" xml:space="preserve">
          <source>NewReader returns an io.Reader which decompresses bzip2 data from r. If r does not also implement io.ByteReader, the decompressor may read more data than necessary from r.</source>
          <target state="translated">NewReader返回一个io.Reader,它可以从r中解压bzip2数据。如果r没有实现io.ByteReader,解压器可能会从r中读取超过必要的数据。</target>
        </trans-unit>
        <trans-unit id="ceca3110c418c227d4c22c9ca1803e30b1fbc6a9" translate="yes" xml:space="preserve">
          <source>NewReaderDict is like NewReader but initializes the reader with a preset dictionary. The returned Reader behaves as if the uncompressed data stream started with the given dictionary, which has already been read. NewReaderDict is typically used to read data compressed by NewWriterDict.</source>
          <target state="translated">NewReaderDict和NewReader一样,但是用一个预设的字典来初始化阅读器。返回的Reader的行为就像未压缩的数据流从给定的字典开始,它已经被读取。NewReaderDict通常用于读取由NewWriterDict压缩的数据。</target>
        </trans-unit>
        <trans-unit id="15dcb5ef9b327e52dad13c8a81c8c78369449efa" translate="yes" xml:space="preserve">
          <source>NewReaderDict is like NewReader but uses a preset dictionary. NewReaderDict ignores the dictionary if the compressed data does not refer to it. If the compressed data refers to a different dictionary, NewReaderDict returns ErrDictionary.</source>
          <target state="translated">NewReaderDict和NewReader一样,但使用了预设的字典。如果压缩数据没有引用字典,NewReaderDict会忽略它。如果压缩数据引用了不同的字典,NewReaderDict返回ErrDictionary。</target>
        </trans-unit>
        <trans-unit id="62226d4a3a7ef180876e33ca9f9e3e5dd9d4d275" translate="yes" xml:space="preserve">
          <source>NewReaderSize returns a new Reader whose buffer has at least the specified size. If the argument io.Reader is already a Reader with large enough size, it returns the underlying Reader.</source>
          <target state="translated">NewReaderSize 返回一个新的Reader,其缓冲区至少有指定的大小。如果参数io.Reader已经是一个足够大的Reader,它返回底层Reader。</target>
        </trans-unit>
        <trans-unit id="9a90b37d52d4387ba6d3b8a70e9b4fe0675a973d" translate="yes" xml:space="preserve">
          <source>NewRecorder returns an initialized ResponseRecorder.</source>
          <target state="translated">NewRecorder 返回一个初始化的 ResponseRecorder。</target>
        </trans-unit>
        <trans-unit id="cc38b91034f7148cfc66856688fcf7b15792b799" translate="yes" xml:space="preserve">
          <source>NewReplacer</source>
          <target state="translated">NewReplacer</target>
        </trans-unit>
        <trans-unit id="98fb98214a91e4f9ae6ab220237b228d86508a63" translate="yes" xml:space="preserve">
          <source>NewReplacer panics if given an odd number of arguments.</source>
          <target state="translated">如果给定奇数的参数,NewReplacer会感到恐慌。</target>
        </trans-unit>
        <trans-unit id="2061a29533176cb14bbeea4aaacbdde390807809" translate="yes" xml:space="preserve">
          <source>NewReplacer returns a new Replacer from a list of old, new string pairs. Replacements are performed in the order they appear in the target string, without overlapping matches. The old string comparisons are done in argument order.</source>
          <target state="translated">NewReplacer从新旧字符串对的列表中返回一个新的Replacer。替换是按照目标字符串中出现的顺序进行的,没有重叠的匹配。旧的字符串比较是按照参数顺序进行的。</target>
        </trans-unit>
        <trans-unit id="06ae50f5cf1308acbe8676644fb3a80e68b35dfc" translate="yes" xml:space="preserve">
          <source>NewRequest panics on error for ease of use in testing, where a panic is acceptable.</source>
          <target state="translated">NewRequest在出错时慌乱,方便在测试中使用,其中慌乱是可以接受的。</target>
        </trans-unit>
        <trans-unit id="dbad5b531961f7dd8c542979ba9a9f6fb56fe9e3" translate="yes" xml:space="preserve">
          <source>NewRequest returns a new incoming server Request, suitable for passing to an http.Handler for testing.</source>
          <target state="translated">NewRequest返回一个新的传入服务器Request,适合传递给http.Handler进行测试。</target>
        </trans-unit>
        <trans-unit id="5c6d605363051e92ce514815fc8e9cdd4cb00b63" translate="yes" xml:space="preserve">
          <source>NewRequest wraps NewRequestWithContext using the background context.</source>
          <target state="translated">NewRequest使用后台上下文包装NewRequestWithContext。</target>
        </trans-unit>
        <trans-unit id="9035fed12b576aa1b44e2c5e5447b9c7c51d7382" translate="yes" xml:space="preserve">
          <source>NewRequestWithContext returns a Request suitable for use with Client.Do or Transport.RoundTrip. To create a request for use with testing a Server Handler, either use the NewRequest function in the net/http/httptest package, use ReadRequest, or manually update the Request fields. For an outgoing client request, the context controls the entire lifetime of a request and its response: obtaining a connection, sending the request, and reading the response headers and body. See the Request type's documentation for the difference between inbound and outbound request fields.</source>
          <target state="translated">NewRequestWithContext返回一个适合用于Client.Do或Transport.RoundTrip的Request。要创建一个用于测试服务器处理程序的请求,可以使用net/http/httptest包中的NewRequest函数,使用ReadRequest,或者手动更新Request字段。对于一个传出的客户端请求,上下文控制着请求及其响应的整个生命周期:获取连接、发送请求、读取响应头和body。关于入站请求字段和出站请求字段的区别,请参见Request类型的文档。</target>
        </trans-unit>
        <trans-unit id="1c9af43cdfcafd0e3590f3e143e4db860b3e1b49" translate="yes" xml:space="preserve">
          <source>NewRequestWithContext returns a new Request given a method, URL, and optional body.</source>
          <target state="translated">NewRequestWithContext返回一个给定方法、URL和可选body的新Request。</target>
        </trans-unit>
        <trans-unit id="6032a09b3acaf432867b7a2e2a1165faa7e1e7a1" translate="yes" xml:space="preserve">
          <source>NewScanner returns a new Scanner to read from r. The split function defaults to ScanLines.</source>
          <target state="translated">NewScanner 会返回一个新的 Scanner 来读取 r。</target>
        </trans-unit>
        <trans-unit id="95df7c8275be1758c09804f6f255a61f60fde088" translate="yes" xml:space="preserve">
          <source>NewScope creates a new scope nested in the outer scope.</source>
          <target state="translated">NewScope创建一个嵌套在外层作用域中的新作用域。</target>
        </trans-unit>
        <trans-unit id="80fe301e9f5c51453bef4cd9884ae93f5be56853" translate="yes" xml:space="preserve">
          <source>NewScope returns a new, empty scope contained in the given parent scope, if any. The comment is for debugging only.</source>
          <target state="translated">NewScope 返回包含在给定父作用域中的新的空作用域(如果有的话)。注释仅用于调试。</target>
        </trans-unit>
        <trans-unit id="11c7ae4097aa2447e01ff30db2236f8b8bdd3d07" translate="yes" xml:space="preserve">
          <source>NewSectionReader returns a SectionReader that reads from r starting at offset off and stops with EOF after n bytes.</source>
          <target state="translated">NewSectionReader返回一个SectionReader,该SectionReader从偏移量off开始读取,并在n个字节后以EOF停止。</target>
        </trans-unit>
        <trans-unit id="92cc00b8df6d155a718390d6b132a73074091695" translate="yes" xml:space="preserve">
          <source>NewServeMux allocates and returns a new ServeMux.</source>
          <target state="translated">NewServeMux分配并返回一个新的ServeMux。</target>
        </trans-unit>
        <trans-unit id="f4c25e90df416fbb8a0117d35fe5407fe24aa713" translate="yes" xml:space="preserve">
          <source>NewServer returns a new Server.</source>
          <target state="translated">NewServer返回一个新的服务器。</target>
        </trans-unit>
        <trans-unit id="babde56071601a12e116397bafca814c40fa7cd4" translate="yes" xml:space="preserve">
          <source>NewServer starts and returns a new Server. The caller should call Close when finished, to shut it down.</source>
          <target state="translated">NewServer启动并返回一个新的Server。调用者应该在完成后调用Close来关闭它。</target>
        </trans-unit>
        <trans-unit id="c2a60c8cf74ea37683e9a87d1c42a435ef059ce9" translate="yes" xml:space="preserve">
          <source>NewServerCodec returns a new rpc.ServerCodec using JSON-RPC on conn.</source>
          <target state="translated">NewServerCodec在conn上使用JSON-RPC返回一个新的rpc.ServerCodec。</target>
        </trans-unit>
        <trans-unit id="8ce930cf303061e4c3d16d518dfb921dd3f19755" translate="yes" xml:space="preserve">
          <source>NewServerConn is an artifact of Go's early HTTP implementation. It is low-level, old, and unused by Go's current HTTP stack. We should have deleted it before Go 1.</source>
          <target state="translated">NewServerConn是Go早期HTTP实现的一个产物。它是低级的、旧的,而且没有被Go当前的HTTP栈使用。我们应该在Go 1之前删除它。</target>
        </trans-unit>
        <trans-unit id="af189f332f7b93936d5df009ddc216614f2c215d" translate="yes" xml:space="preserve">
          <source>NewSignature returns a new function type for the given receiver, parameters, and results, either of which may be nil. If variadic is set, the function is variadic, it must have at least one parameter, and the last parameter must be of unnamed slice type.</source>
          <target state="translated">NewSignature为给定的接收器、参数和结果返回一个新的函数类型,其中任何一个都可以是nil。如果设置了variadic,则该函数是变型的,它必须至少有一个参数,并且最后一个参数必须是未命名的分片类型。</target>
        </trans-unit>
        <trans-unit id="f456531de00193a99678056eea0c8fcdbfa6dfa5" translate="yes" xml:space="preserve">
          <source>NewSingleHostReverseProxy returns a new ReverseProxy that routes URLs to the scheme, host, and base path provided in target. If the target's path is &quot;/base&quot; and the incoming request was for &quot;/dir&quot;, the target request will be for /base/dir. NewSingleHostReverseProxy does not rewrite the Host header. To rewrite Host headers, use ReverseProxy directly with a custom Director policy.</source>
          <target state="translated">NewSingleHostReverseProxy返回一个新的ReverseProxy,将URL路由到target中提供的scheme、host和base路径。如果target的路径是&quot;/base&quot;,而传入的请求是&quot;/dir&quot;,那么target的请求将是/base/dir。NewSingleHostReverseProxy不会重写Host头。要重写Host头,请直接使用ReverseProxy和自定义Director策略。</target>
        </trans-unit>
        <trans-unit id="881af40d9181550600eb2130180e0aa0b7ef4fc9" translate="yes" xml:space="preserve">
          <source>NewSlice returns a new slice type for the given element type.</source>
          <target state="translated">NewSlice 返回给定元素类型的新片类型。</target>
        </trans-unit>
        <trans-unit id="e721e99b1b2d7da11daa968d62a8bde773167ca1" translate="yes" xml:space="preserve">
          <source>NewSource returns a new pseudo-random Source seeded with the given value. Unlike the default Source used by top-level functions, this source is not safe for concurrent use by multiple goroutines.</source>
          <target state="translated">NewSource返回一个新的伪随机Source,其种子为给定的值。与顶层函数使用的默认Source不同,这个Source对于多个goroutine的并发使用是不安全的。</target>
        </trans-unit>
        <trans-unit id="2632cf950aa513ee1017bf4dcbadbfbcd59a77fb" translate="yes" xml:space="preserve">
          <source>NewStruct returns a new struct with the given fields and corresponding field tags. If a field with index i has a tag, tags[i] must be that tag, but len(tags) may be only as long as required to hold the tag with the largest index i. Consequently, if no field has a tag, tags may be nil.</source>
          <target state="translated">NewStruct 返回一个包含给定字段和相应字段标签的新结构。如果索引为 i 的字段有标签,则 tags[i]必须是该标签,但 len(tags)的长度可能只相当于持有索引为 i 的最大标签所需的长度,因此,如果没有字段有标签,则 tags 可能为 nil。</target>
        </trans-unit>
        <trans-unit id="103ea95c3f50f8126d8830a74f99ac0e3f79bcc5" translate="yes" xml:space="preserve">
          <source>NewSyscallError returns, as an error, a new SyscallError with the given system call name and error details. As a convenience, if err is nil, NewSyscallError returns nil.</source>
          <target state="translated">NewSyscallError作为一个错误返回一个新的SyscallError,其中包含给定的系统调用名和错误细节。为了方便起见,如果err为nil,NewSyscallError返回nil。</target>
        </trans-unit>
        <trans-unit id="15af8e116827b7526d8d125b743d53ce97e9ccf0" translate="yes" xml:space="preserve">
          <source>NewTLSServer</source>
          <target state="translated">NewTLSServer</target>
        </trans-unit>
        <trans-unit id="ee9c0929ee87d66c85d071ce6743847eebd27e1d" translate="yes" xml:space="preserve">
          <source>NewTLSServer starts and returns a new Server using TLS. The caller should call Close when finished, to shut it down.</source>
          <target state="translated">NewTLSServer使用TLS启动并返回一个新的服务器。调用者应该在完成后调用Close来关闭它。</target>
        </trans-unit>
        <trans-unit id="00d18b3ba661f69ed9cfe9015dd706b999fa00de" translate="yes" xml:space="preserve">
          <source>NewTable decodes the Go symbol table (the &quot;.gosymtab&quot; section in ELF), returning an in-memory representation. Starting with Go 1.3, the Go symbol table no longer includes symbol data.</source>
          <target state="translated">NewTable 对 Go 符号表(ELF 中的&quot;.gosymtab &quot;部分)进行解码,返回一个内存中的表示。从Go 1.3开始,Go符号表不再包含符号数据。</target>
        </trans-unit>
        <trans-unit id="6c3faf897ce3b4d9467485319643370fa9199652" translate="yes" xml:space="preserve">
          <source>NewTask creates a task instance with the type taskType and returns it along with a Context that carries the task. If the input context contains a task, the new task is its subtask.</source>
          <target state="translated">NewTask创建一个具有taskType类型的任务实例,并将其与携带该任务的Context一起返回。如果输入上下文包含一个任务,新任务就是它的子任务。</target>
        </trans-unit>
        <trans-unit id="b8fb5e998a5bfa39f457a0e00d00ff8fbdd42ef8" translate="yes" xml:space="preserve">
          <source>NewTicker</source>
          <target state="translated">NewTicker</target>
        </trans-unit>
        <trans-unit id="b035640e964a55296a2efb5506fa864ce9c9bfff" translate="yes" xml:space="preserve">
          <source>NewTicker returns a new Ticker containing a channel that will send the time with a period specified by the duration argument. It adjusts the intervals or drops ticks to make up for slow receivers. The duration d must be greater than zero; if not, NewTicker will panic. Stop the ticker to release associated resources.</source>
          <target state="translated">NewTicker返回一个新的Ticker,其中包含一个通道,该通道将以duration参数指定的周期发送时间。它调整时间间隔或丢弃ticks来弥补慢速接收者。持续时间d必须大于零,如果不大于零,NewTicker会恐慌。停止ticker以释放相关资源。</target>
        </trans-unit>
        <trans-unit id="bf6547887c37f917a009906b59fe98e227a67450" translate="yes" xml:space="preserve">
          <source>NewTimer creates a new Timer that will send the current time on its channel after at least duration d.</source>
          <target state="translated">NewTimer创建了一个新的定时器,它将在至少持续时间d后在其通道上发送当前时间。</target>
        </trans-unit>
        <trans-unit id="09aa7464c6b6cfad4c77e4bd499188c3746a2702" translate="yes" xml:space="preserve">
          <source>NewTokenDecoder creates a new XML parser using an underlying token stream.</source>
          <target state="translated">NewTokenDecoder使用底层的token流创建一个新的XML解析器。</target>
        </trans-unit>
        <trans-unit id="4a23d472e6b06cb6e963edf429927add90a46a91" translate="yes" xml:space="preserve">
          <source>NewTripleDESCipher</source>
          <target state="translated">NewTripleDESCipher</target>
        </trans-unit>
        <trans-unit id="84af04213903c43ab9d1e733d66e68af85c238b7" translate="yes" xml:space="preserve">
          <source>NewTripleDESCipher creates and returns a new cipher.Block.</source>
          <target state="translated">NewTripleDESCipher创建并返回一个新的cipher.Block。</target>
        </trans-unit>
        <trans-unit id="f40b69134a3f0736deea2eaa2750678b0c5b55ae" translate="yes" xml:space="preserve">
          <source>NewTuple returns a new tuple for the given variables.</source>
          <target state="translated">NewTuple 返回给定变量的新元组。</target>
        </trans-unit>
        <trans-unit id="c765721cc8a5281c315a4053b16ddc74c0799a82" translate="yes" xml:space="preserve">
          <source>NewTypeName returns a new type name denoting the given typ. The remaining arguments set the attributes found with all Objects.</source>
          <target state="translated">NewTypeName返回一个新的类型名,表示给定的类型。其余的参数设置了所有 Objects 的属性。</target>
        </trans-unit>
        <trans-unit id="fc82f99da3f381417b3f2ddf213f8678bc887a05" translate="yes" xml:space="preserve">
          <source>NewUnstartedServer returns a new Server but doesn't start it.</source>
          <target state="translated">NewUnstartedServer返回一个新的服务器,但不启动它。</target>
        </trans-unit>
        <trans-unit id="077e4a879a7f7aeb3402f9e60fcfed25d2f462f1" translate="yes" xml:space="preserve">
          <source>NewVar returns a new variable. The arguments set the attributes found with all Objects.</source>
          <target state="translated">NewVar返回一个新变量。参数设置了所有对象的属性。</target>
        </trans-unit>
        <trans-unit id="931cae5ffd260d5017ab39bc76af1f4af39d3c45" translate="yes" xml:space="preserve">
          <source>NewWriteLogger returns a writer that behaves like w except that it logs (using log.Printf) each write to standard error, printing the prefix and the hexadecimal data written.</source>
          <target state="translated">NewWriteLogger返回了一个写入器,它的行为与w类似,除了它记录(使用log.Printf)每次写入的标准错误,打印前缀和写入的十六进制数据。</target>
        </trans-unit>
        <trans-unit id="32dc084c221b7ac68250900d07e80ef98477176c" translate="yes" xml:space="preserve">
          <source>NewWriter</source>
          <target state="translated">NewWriter</target>
        </trans-unit>
        <trans-unit id="db406b8d211203f1503f7b49dc65e93e6c1d2ac9" translate="yes" xml:space="preserve">
          <source>NewWriter allocates and initializes a new tabwriter.Writer. The parameters are the same as for the Init function.</source>
          <target state="translated">NewWriter分配并初始化一个新的tabwriter.Writer。参数与Init函数相同。</target>
        </trans-unit>
        <trans-unit id="eb99a0a4fd37c15275e7565ffb0b13403d80a96e" translate="yes" xml:space="preserve">
          <source>NewWriter creates a new Writer writing to w.</source>
          <target state="translated">NewWriter创建一个新的Writer写到w。</target>
        </trans-unit>
        <trans-unit id="3c66bbe4244d139551b9b86abb1f943bea6cca3c" translate="yes" xml:space="preserve">
          <source>NewWriter creates a new Writer. Writes to the returned Writer are compressed and written to w.</source>
          <target state="translated">NewWriter创建一个新的Writer。对返回的Writer的写入会被压缩并写入w。</target>
        </trans-unit>
        <trans-unit id="6d237dd5c37ca4fbda972f04e6f597bc8e44916c" translate="yes" xml:space="preserve">
          <source>NewWriter creates a new io.WriteCloser. Writes to the returned io.WriteCloser are compressed and written to w. It is the caller's responsibility to call Close on the WriteCloser when finished writing. The number of bits to use for literal codes, litWidth, must be in the range [2,8] and is typically 8. Input bytes must be less than 1&amp;lt;&amp;lt;litWidth.</source>
          <target state="translated">NewWriter创建一个新的io.WriteCloser。写入返回的io.WriteCloser被压缩并写入w。完成写入后，调用方有责任在WriteCloser上调用Close。用于文字代码的位数litWidth必须在[2,8]范围内，通常为8。输入字节必须小于1 &amp;lt;&amp;lt; litWidth。</target>
        </trans-unit>
        <trans-unit id="5d8c71239de18e81bb2408f6be3d174f8b53cc5b" translate="yes" xml:space="preserve">
          <source>NewWriter returns a new Writer compressing data at the given level. Following zlib, levels range from 1 (BestSpeed) to 9 (BestCompression); higher levels typically run slower but compress more. Level 0 (NoCompression) does not attempt any compression; it only adds the necessary DEFLATE framing. Level -1 (DefaultCompression) uses the default compression level. Level -2 (HuffmanOnly) will use Huffman compression only, giving a very fast compression for all types of input, but sacrificing considerable compression efficiency.</source>
          <target state="translated">NewWriter返回一个新的Writer,在给定的级别上压缩数据。按照zlib,级别范围从1(BestSpeed)到9(BestCompression);更高的级别通常运行得更慢,但压缩得更多。0级(NoCompression)不尝试任何压缩;它只添加必要的DEFLATE帧。级别-1(DefaultCompression)使用默认的压缩级别。级别-2(HuffmanOnly)将只使用Huffman压缩,为所有类型的输入提供非常快速的压缩,但牺牲了相当大的压缩效率。</target>
        </trans-unit>
        <trans-unit id="77a9ef9463dc28c378543b4ca1ab833768dcb916" translate="yes" xml:space="preserve">
          <source>NewWriter returns a new Writer that writes to w.</source>
          <target state="translated">NewWriter返回一个新的Writer,写到w。</target>
        </trans-unit>
        <trans-unit id="6ed1faccc6afb2894578d5ce15a1b66df2ed7562" translate="yes" xml:space="preserve">
          <source>NewWriter returns a new Writer whose buffer has the default size.</source>
          <target state="translated">NewWriter返回一个新的Writer,其缓冲区的大小是默认的。</target>
        </trans-unit>
        <trans-unit id="28df5b8c07e84a79a10bcd4ad1689f3c9f232d1d" translate="yes" xml:space="preserve">
          <source>NewWriter returns a new Writer writing a zip file to w.</source>
          <target state="translated">NewWriter返回一个新的Writer,向w写一个zip文件。</target>
        </trans-unit>
        <trans-unit id="15d873b5f31a0567bb2f33a96b73193d43330bbf" translate="yes" xml:space="preserve">
          <source>NewWriter returns a new Writer writing to w.</source>
          <target state="translated">NewWriter返回一个新的Writer写作到w。</target>
        </trans-unit>
        <trans-unit id="8553cec920a1bbc2b884d29ae54a45cdb28b9a7f" translate="yes" xml:space="preserve">
          <source>NewWriter returns a new Writer. Writes to the returned writer are compressed and written to w.</source>
          <target state="translated">NewWriter返回一个新的Writer。写入返回的writer的内容会被压缩并写入w。</target>
        </trans-unit>
        <trans-unit id="41a8b4d0cc45c1f4744d9ed11afc5cc850ba9075" translate="yes" xml:space="preserve">
          <source>NewWriter returns a new multipart Writer with a random boundary, writing to w.</source>
          <target state="translated">NewWriter返回一个新的具有随机边界的多部分Writer,写到w。</target>
        </trans-unit>
        <trans-unit id="ba4df4f4844996231636be43db04ad5d9a575122" translate="yes" xml:space="preserve">
          <source>NewWriterDict is like NewWriter but initializes the new Writer with a preset dictionary. The returned Writer behaves as if the dictionary had been written to it without producing any compressed output. The compressed data written to w can only be decompressed by a Reader initialized with the same dictionary.</source>
          <target state="translated">NewWriterDict 与 NewWriter 类似,但用预设的字典初始化新的 Writer。返回的Writer的行为就像字典已经被写入它而不产生任何压缩输出一样。写入 w 的压缩数据只能由一个用相同字典初始化的 Reader 解压。</target>
        </trans-unit>
        <trans-unit id="d66b95134ebabf02390f85e665bafa07e307f028" translate="yes" xml:space="preserve">
          <source>NewWriterLevel is like NewWriter but specifies the compression level instead of assuming DefaultCompression.</source>
          <target state="translated">NewWriterLevel和NewWriter一样,但是指定了压缩级别,而不是假设DefaultCompression。</target>
        </trans-unit>
        <trans-unit id="2244762bcd986f7cb2bc9adec833aa8f04c34752" translate="yes" xml:space="preserve">
          <source>NewWriterLevelDict is like NewWriterLevel but specifies a dictionary to compress with.</source>
          <target state="translated">NewWriterLevelDict和NewWriterLevel一样,但是指定了一个要压缩的字典。</target>
        </trans-unit>
        <trans-unit id="fba4df7d4f867ec10b6be90ace669ea6f21a1c64" translate="yes" xml:space="preserve">
          <source>NewWriterSize returns a new Writer whose buffer has at least the specified size. If the argument io.Writer is already a Writer with large enough size, it returns the underlying Writer.</source>
          <target state="translated">NewWriterSize返回一个新的Writer,其缓冲区至少有指定的大小,如果参数io.Writer已经是一个足够大的Writer,它返回底层Writer。如果参数io.Writer已经是一个足够大的Writer,它将返回底层Writer。</target>
        </trans-unit>
        <trans-unit id="6a8e1967a776dd6bc255e00e323e531b785051db" translate="yes" xml:space="preserve">
          <source>NewYCbCr returns a new YCbCr image with the given bounds and subsample ratio.</source>
          <target state="translated">NewYCbCr 返回一个新的 YCbCr 图像,该图像具有给定的边界和子样本比。</target>
        </trans-unit>
        <trans-unit id="24448d424137595a3746992f824b6edb3b30eda0" translate="yes" xml:space="preserve">
          <source>NewZipf returns a Zipf variate generator. The generator generates values k &amp;isin; [0, imax] such that P(k) is proportional to (v + k) ** (-s). Requirements: s &amp;gt; 1 and v &amp;gt;= 1.</source>
          <target state="translated">NewZipf返回一个Zipf变量生成器。生成器生成值k&amp;isin;[0，imax]，使得P（k）与（v + k）**（-s）成比例。要求：s&amp;gt; 1和v&amp;gt; = 1。</target>
        </trans-unit>
        <trans-unit id="7ce32fccbc1a59952ff2a17d5ecf204917f2f0f8" translate="yes" xml:space="preserve">
          <source>Newlines and commas may be included in a quoted-field</source>
          <target state="translated">在引号栏中可以包含新行和逗号。</target>
        </trans-unit>
        <trans-unit id="680ad9f662c74a9364f8a6a8275f58c7b8082fcd" translate="yes" xml:space="preserve">
          <source>Next advances the map iterator and reports whether there is another entry. It returns false when the iterator is exhausted; subsequent calls to Key, Value, or Next will panic.</source>
          <target state="translated">Next推进map迭代器,并报告是否有其他条目。当迭代器耗尽时,它返回false;随后对Key、Value或Next的调用会产生恐慌。</target>
        </trans-unit>
        <trans-unit id="a3886733d4cb9e8e0a30e9e159418bfd55e791d5" translate="yes" xml:space="preserve">
          <source>Next advances to the next entry in the tar archive. The Header.Size determines how many bytes can be read for the next file. Any remaining data in the current file is automatically discarded.</source>
          <target state="translated">Next前进到tar存档的下一个条目。Header.Size 决定下一个文件可以读取多少字节。当前文件中的任何剩余数据将被自动丢弃。</target>
        </trans-unit>
        <trans-unit id="4901308d5dc25a2990110e9739d7a18a2e5ad01b" translate="yes" xml:space="preserve">
          <source>Next prepares the next result row for reading with the Scan method. It returns true on success, or false if there is no next result row or an error happened while preparing it. Err should be consulted to distinguish between the two cases.</source>
          <target state="translated">Next准备下一条结果行,以便用Scan方法读取。如果成功的话,它返回true,如果没有下一条结果行或者在准备时发生了错误,则返回false。应该参考Err来区分这两种情况。</target>
        </trans-unit>
        <trans-unit id="4b13fef4541a1e8d67cdfed20bd2375d09afaf54" translate="yes" xml:space="preserve">
          <source>Next reads and returns the next Unicode character. It returns EOF at the end of the source. It reports a read error by calling s.Error, if not nil; otherwise it prints an error message to os.Stderr. Next does not update the Scanner's Position field; use Pos() to get the current position.</source>
          <target state="translated">Next读取并返回下一个Unicode字符。它在源码结束时返回 EOF。如果不是 nil,它通过调用 s.Error 报告读取错误;否则,它会向 os.Stderr 打印错误信息。Next 不会更新 Scanner 的 Position 字段;使用 Pos()来获取当前位置。</target>
        </trans-unit>
        <trans-unit id="f9300d09b7df4ad5d5720f19adfdc038ac61f1df" translate="yes" xml:space="preserve">
          <source>Next reads the next entry from the encoded entry stream. It returns nil, nil when it reaches the end of the section. It returns an error if the current offset is invalid or the data at the offset cannot be decoded as a valid Entry.</source>
          <target state="translated">Next从编码后的条目流中读取下一个条目。它返回nil,当它到达该部分结束时,返回nil。如果当前偏移量无效,或者偏移量处的数据不能被解码为有效的条目,它将返回一个错误。</target>
        </trans-unit>
        <trans-unit id="5e6ab5cae4a8ae2aa846c67f99d971fa518e2e06" translate="yes" xml:space="preserve">
          <source>Next reports whether there are more iterations to execute.</source>
          <target state="translated">下一步报告是否有更多的迭代要执行。</target>
        </trans-unit>
        <trans-unit id="93f915543eeb533b1a50713e83a0f24c2c27db55" translate="yes" xml:space="preserve">
          <source>Next returns a slice containing the next n bytes from the buffer, advancing the buffer as if the bytes had been returned by Read. If there are fewer than n bytes in the buffer, Next returns the entire buffer. The slice is only valid until the next call to a read or write method.</source>
          <target state="translated">Next返回一个包含缓冲区中下一个n个字节的分片,就像Read返回的字节一样前进缓冲区。如果缓冲区中的字节数少于n个,Next将返回整个缓冲区。该分片只在下一次调用读或写方法之前有效。</target>
        </trans-unit>
        <trans-unit id="c448db08820ee5a2da21a99a2f7ee9ecfecee2a6" translate="yes" xml:space="preserve">
          <source>Next returns frame information for the next caller. If more is false, there are no more callers (the Frame value is valid).</source>
          <target state="translated">Next返回下一个调用者的帧信息。如果more为false,则没有更多的调用者(Frame值有效)。</target>
        </trans-unit>
        <trans-unit id="330b3e94c1faae753e446839e4e00b09aaa021f5" translate="yes" xml:space="preserve">
          <source>Next returns the next id for a request/response pair.</source>
          <target state="translated">Next返回请求/响应对的下一个id。</target>
        </trans-unit>
        <trans-unit id="31070c09d9898d8d82df0861c7359cedd6d1bee8" translate="yes" xml:space="preserve">
          <source>Next returns the next list element or nil.</source>
          <target state="translated">Next返回下一个列表元素或nil。</target>
        </trans-unit>
        <trans-unit id="835c3bdc06b3af77ee23ce1cd0bc1f932319b6e0" translate="yes" xml:space="preserve">
          <source>Next returns the next ring element. r must not be empty.</source>
          <target state="translated">Next返回下一个环元素,r不能为空。</target>
        </trans-unit>
        <trans-unit id="3515095d5db1d9b6b3020f18bccf17c7141a06e9" translate="yes" xml:space="preserve">
          <source>Next sets *entry to the next row in this line table and moves to the next row. If there are no more entries and the line table is properly terminated, it returns io.EOF.</source>
          <target state="translated">Next将*条目设置为该行表的下一行,并移动到下一行。如果没有更多的条目,并且行表被正确地终止,它将返回io.EOF。</target>
        </trans-unit>
        <trans-unit id="59243d78d75adcc23308fcf3c7522b53b0e48d6d" translate="yes" xml:space="preserve">
          <source>NextPart returns the next part in the multipart or an error. When there are no more parts, the error io.EOF is returned.</source>
          <target state="translated">NextPart返回multipart中的下一个part或一个错误。当没有更多的部件时,返回错误io.EOF。</target>
        </trans-unit>
        <trans-unit id="7fe82d0a11eaa23908a02323edde641d4f84c09e" translate="yes" xml:space="preserve">
          <source>NextResultSet prepares the next result set for reading. It reports whether there is further result sets, or false if there is no further result set or if there is an error advancing to it. The Err method should be consulted to distinguish between the two cases.</source>
          <target state="translated">NextResultSet为读取下一个结果集做准备。它报告是否有进一步的结果集,如果没有进一步的结果集或者有错误前进到该结果集,则报告false。应参考Err方法来区分这两种情况。</target>
        </trans-unit>
        <trans-unit id="98468e4766dcce0e39d3ad725e6449c114807ef7" translate="yes" xml:space="preserve">
          <source>Nextafter returns the next representable float64 value after x towards y.</source>
          <target state="translated">Nextafter在x之后向y返回下一个可表示的float64值。</target>
        </trans-unit>
        <trans-unit id="75d1da7ce66cd551626a0d105347dbf7bbebadb0" translate="yes" xml:space="preserve">
          <source>Nextafter32 returns the next representable float32 value after x towards y.</source>
          <target state="translated">Nextafter32返回x之后朝y方向的下一个可表示的float32值。</target>
        </trans-unit>
        <trans-unit id="f22ed1e707c4376c926b166081941a42b8018a27" translate="yes" xml:space="preserve">
          <source>Nil represents the predeclared value nil.</source>
          <target state="translated">Nil代表预先声明的值nil。</target>
        </trans-unit>
        <trans-unit id="7b09d67cac8107c868d3a3b7af77e77ea7720296" translate="yes" xml:space="preserve">
          <source>NilNode holds the special identifier 'nil' representing an untyped nil constant.</source>
          <target state="translated">NilNode持有特殊的标识符'nil',代表一个非类型的nil常量。</target>
        </trans-unit>
        <trans-unit id="b524d9a99adffa02a516e6aa0d4d13aac2897fdc" translate="yes" xml:space="preserve">
          <source>NoBody is an io.ReadCloser with no bytes. Read always returns EOF and Close always returns nil. It can be used in an outgoing client request to explicitly signal that a request has zero bytes. An alternative, however, is to simply set Request.Body to nil.</source>
          <target state="translated">NoBody是一个没有字节的io.ReadCloser。Read总是返回EOF,Close总是返回nil。它可以在传出的客户端请求中使用,以明确地表示请求的字节数为零。然而,一个替代方案是简单地将Request.Body设置为nil。</target>
        </trans-unit>
        <trans-unit id="52ef1a3746a958c4a53a19c9d87395684668883e" translate="yes" xml:space="preserve">
          <source>NoGoError is the error used by Import to describe a directory containing no buildable Go source files. (It may still contain test files, files hidden by build tags, and so on.)</source>
          <target state="translated">NoGoError是Import用来描述一个目录的错误,该目录中不包含可构建的Go源文件(它可能仍然包含测试文件、被构建标签隐藏的文件等)。(它可能仍然包含测试文件、被构建标签隐藏的文件等。)</target>
        </trans-unit>
        <trans-unit id="260f7a8cd4f6938b3cc185a619847cb83d670219" translate="yes" xml:space="preserve">
          <source>Node</source>
          <target state="translated">Node</target>
        </trans-unit>
        <trans-unit id="14b0e62d6fc1422eb757516da0b18c46890cfc16" translate="yes" xml:space="preserve">
          <source>Node formats node in canonical gofmt style and writes the result to dst.</source>
          <target state="translated">节点以规范的gofmt样式格式化节点,并将结果写入dst。</target>
        </trans-unit>
        <trans-unit id="da15215d50f0207cc3f3bf867716d8b653cbbf4d" translate="yes" xml:space="preserve">
          <source>NodeType identifies the type of a parse tree node.</source>
          <target state="translated">NodeType标识一个解析树节点的类型。</target>
        </trans-unit>
        <trans-unit id="b2c069378b3bfe6ff1e505ef1691402f0b8b4e2b" translate="yes" xml:space="preserve">
          <source>Non-Go programs that call Go code</source>
          <target state="translated">调用围棋代码的非围棋程序</target>
        </trans-unit>
        <trans-unit id="902b501103969363a75f55b1d4ea5e8e3aaa9ff5" translate="yes" xml:space="preserve">
          <source>Non-string values can be used in JavaScript contexts. If {{.}} is</source>
          <target state="translated">非字符串值可以在JavaScript上下文中使用。如果{{.}}是</target>
        </trans-unit>
        <trans-unit id="3d2c97b640a04b4cfaa42b436b4f88eedd1e3354" translate="yes" xml:space="preserve">
          <source>Noop sends the NOOP command to the server. It does nothing but check that the connection to the server is okay.</source>
          <target state="translated">Noop向服务器发送NOOP命令。它什么也不做,只是检查与服务器的连接是否正常。</target>
        </trans-unit>
        <trans-unit id="85cca9a9c13590980a1e26da797767deb94d87fd" translate="yes" xml:space="preserve">
          <source>NopCloser returns a ReadCloser with a no-op Close method wrapping the provided Reader r.</source>
          <target state="translated">NopCloser返回一个ReadCloser,它有一个无操作的Close方法,包裹着提供的Reader r。</target>
        </trans-unit>
        <trans-unit id="7bc360841341e5ff79e2d9db0ccaba1681a641e9" translate="yes" xml:space="preserve">
          <source>NormFloat64 returns a normally distributed float64 in the range -math.MaxFloat64 through +math.MaxFloat64 inclusive, with standard normal distribution (mean = 0, stddev = 1). To produce a different normal distribution, callers can adjust the output using:</source>
          <target state="translated">NormFloat64返回一个正态分布的float64,范围从-math.MaxFloat64到+math.MaxFloat64,包含标准正态分布(平均值=0,stddev=1)。要产生不同的正态分布,调用者可以使用调整输出。</target>
        </trans-unit>
        <trans-unit id="584a03e17a58b140265f4319a3b8d37d0b326573" translate="yes" xml:space="preserve">
          <source>NormFloat64 returns a normally distributed float64 in the range [-math.MaxFloat64, +math.MaxFloat64] with standard normal distribution (mean = 0, stddev = 1) from the default Source. To produce a different normal distribution, callers can adjust the output using:</source>
          <target state="translated">NormFloat64从默认的Source返回一个正态分布的float64,范围是[-math.MaxFloat64,+math.MaxFloat64],具有标准正态分布(平均值=0,stddev=1)。要产生不同的正态分布,调用者可以使用调整输出。</target>
        </trans-unit>
        <trans-unit id="16ef8f27fb77f3e3923ae623df4ac9f719342330" translate="yes" xml:space="preserve">
          <source>Not all drivers and databases support OUTPUT value parameters.</source>
          <target state="translated">并非所有的驱动程序和数据库都支持OUTPUT值参数。</target>
        </trans-unit>
        <trans-unit id="28197ebc86a75fec0d20747340a0a7790f4e6e65" translate="yes" xml:space="preserve">
          <source>Not all methods apply to all kinds of types. Restrictions, if any, are noted in the documentation for each method. Use the Kind method to find out the kind of type before calling kind-specific methods. Calling a method inappropriate to the kind of type causes a run-time panic.</source>
          <target state="translated">并非所有方法都适用于所有类型。如果有任何限制,会在每个方法的文档中注明。在调用特定类型的方法之前,请使用 Kind 方法找出类型的种类。调用不适合类型种类的方法会引起运行时的恐慌。</target>
        </trans-unit>
        <trans-unit id="aebe464c9e025a8d065addc9b1418e295beb91ab" translate="yes" xml:space="preserve">
          <source>Not all methods apply to all kinds of values. Restrictions, if any, are noted in the documentation for each method. Use the Kind method to find out the kind of value before calling kind-specific methods. Calling a method inappropriate to the kind of type causes a run time panic.</source>
          <target state="translated">并非所有方法都适用于所有类型的数值。如果有任何限制,会在每个方法的文档中注明。在调用特定种类的方法之前,请使用种类方法找出值的种类。调用不适合类型的方法会导致运行时的恐慌。</target>
        </trans-unit>
        <trans-unit id="0ad6482316efeb0367fac0cef294df9931657e21" translate="yes" xml:space="preserve">
          <source>Not sets z = ^x and returns z.</source>
          <target state="translated">不设置z=^x,并返回z。</target>
        </trans-unit>
        <trans-unit id="7742382b9eb1d24a7003bcf20989045729354b55" translate="yes" xml:space="preserve">
          <source>NotFound replies to the request with an HTTP 404 not found error.</source>
          <target state="translated">NotFound以HTTP 404 not found错误来回复该请求。</target>
        </trans-unit>
        <trans-unit id="d73243f8dff55155dc23697de39081a99659e339" translate="yes" xml:space="preserve">
          <source>NotFoundHandler</source>
          <target state="translated">NotFoundHandler</target>
        </trans-unit>
        <trans-unit id="4cb94eae88a4f55a499c64d3eb533d60d5f636a3" translate="yes" xml:space="preserve">
          <source>NotFoundHandler returns a simple request handler that replies to each request with a &amp;ldquo;404 page not found&amp;rdquo; reply.</source>
          <target state="translated">NotFoundHandler返回一个简单的请求处理程序，该处理程序使用&amp;ldquo; 404页面未找到&amp;rdquo;答复来答复每个请求。</target>
        </trans-unit>
        <trans-unit id="fa1f72946015817c3defa6f9ca3e62b13a4cbe23" translate="yes" xml:space="preserve">
          <source>NotNilFilter returns true for field values that are not nil; it returns false otherwise.</source>
          <target state="translated">NotNilFilter对非零的字段值返回true,否则返回false。</target>
        </trans-unit>
        <trans-unit id="48697afd9134ab8c796d4134241a98bd8c0e1e0e" translate="yes" xml:space="preserve">
          <source>NotNull is a type that implements ValueConverter by disallowing nil values but otherwise delegating to another ValueConverter.</source>
          <target state="translated">NotNull是一个实现ValueConverter的类型,它不允许nil值,但在其他方面委托给另一个ValueConverter。</target>
        </trans-unit>
        <trans-unit id="ea5ffd3d5d924f61e0aab5c8328c4565de280e8f" translate="yes" xml:space="preserve">
          <source>Notational convention: Incoming method parameters (including the receiver) are named consistently in the API to clarify their use. Incoming operands are usually named x, y, a, b, and so on, but never z. A parameter specifying the result is named z (typically the receiver).</source>
          <target state="translated">符号惯例。输入的方法参数(包括接收者)在API中的命名是一致的,以明确其用途。输入的操作数通常被命名为x、y、a、b等,但从不命名为z。指定结果的参数被命名为z(通常是接收方)。</target>
        </trans-unit>
        <trans-unit id="08dfc0b4556c0a1e642330802e9a9fdabdeafde7" translate="yes" xml:space="preserve">
          <source>Note that *os.File implements the io.ReadSeeker interface.</source>
          <target state="translated">请注意,*os.File实现了io.ReadSeeker接口。</target>
        </trans-unit>
        <trans-unit id="c7438b24f5f10d8ed5111e3a3eeea38cdce805d1" translate="yes" xml:space="preserve">
          <source>Note that DWARF line tables only permit sequential, forward scans. Hence, in the worst case, this takes time linear in the size of the line table. If the caller wishes to do repeated fast PC lookups, it should build an appropriate index of the line table.</source>
          <target state="translated">请注意,DWARF行表只允许进行顺序的正向扫描。因此,在最坏的情况下,这需要的时间与行表的大小呈线性关系。如果调用者希望进行重复的快速PC查找,就应该建立行表的适当索引。</target>
        </trans-unit>
        <trans-unit id="d08c2aea787a35db90158742ee5e75a3c73282a4" translate="yes" xml:space="preserve">
          <source>Note that Dir will allow access to files and directories starting with a period, which could expose sensitive directories like a .git directory or sensitive files like .htpasswd. To exclude files with a leading period, remove the files/directories from the server or create a custom FileSystem implementation.</source>
          <target state="translated">请注意,Dir将允许访问以句号开头的文件和目录,这可能会暴露敏感目录,如.git目录或敏感文件,如.htpasswd。要排除以句号开头的文件,请从服务器上删除这些文件/目录,或者创建一个自定义的FileSystem实现。</target>
        </trans-unit>
        <trans-unit id="74976bc5278e7780a62cf9ceb79267a86a939300" translate="yes" xml:space="preserve">
          <source>Note that FIPS 186-3 section 4.6 specifies that the hash should be truncated to the byte-length of the subgroup. This function does not perform that truncation itself.</source>
          <target state="translated">请注意,FIPS 186-3 第 4.6 节规定,哈希应该被截断到子组的字节长度。这个函数本身并不执行这种截断。</target>
        </trans-unit>
        <trans-unit id="bbf97d3b36e492a77bf717cf84e9406daab3263a" translate="yes" xml:space="preserve">
          <source>Note that Init may call err if there is an error in the first character of the file.</source>
          <target state="translated">请注意,如果文件的第一个字符有错误,Init可能会调用err。</target>
        </trans-unit>
        <trans-unit id="7a0c39680eb9df4d26108a728fd58d66d7905a72" translate="yes" xml:space="preserve">
          <source>Note that LineContinuations are not allowed. JSStr(&quot;foo\\nbar&quot;) is fine, but JSStr(&quot;foo\\\nbar&quot;) is not.</source>
          <target state="translated">注意,不允许使用LineContinuations。JSStr(&quot;foo\\nbar&quot;)可以,但JSStr(&quot;foo\\nbar&quot;)不可以。</target>
        </trans-unit>
        <trans-unit id="b706c905f9e49dd39547ae798a12e332969a754b" translate="yes" xml:space="preserve">
          <source>Note that Push and Pop in this interface are for package heap's implementation to call. To add and remove things from the heap, use heap.Push and heap.Pop.</source>
          <target state="translated">注意,这个接口中的Push和Pop是给包heap的实现调用的。要从堆中添加和删除东西,可以使用heap.Push和heap.Pop。</target>
        </trans-unit>
        <trans-unit id="57724cba67b0754543683d705a43db50bcf5c63d" translate="yes" xml:space="preserve">
          <source>Note that both conversions must appear in the same expression, with only the intervening arithmetic between them:</source>
          <target state="translated">需要注意的是,这两种转换必须出现在同一个表达式中,它们之间只有中间的算式。</target>
        </trans-unit>
        <trans-unit id="00d2f4b507ea636132af470ff7c66414d9db9755" translate="yes" xml:space="preserve">
          <source>Note that calls with a positive delta that occur when the counter is zero must happen before a Wait. Calls with a negative delta, or calls with a positive delta that start when the counter is greater than zero, may happen at any time. Typically this means the calls to Add should execute before the statement creating the goroutine or other event to be waited for. If a WaitGroup is reused to wait for several independent sets of events, new Add calls must happen after all previous Wait calls have returned. See the WaitGroup example.</source>
          <target state="translated">请注意,当计数器为零时发生的正delta的呼叫必须在Wait之前发生。负delta的调用,或者当计数器大于零时开始的正delta的调用,可以在任何时候发生。通常这意味着对Add的调用应该在创建goroutine或其他要等待的事件的语句之前执行。如果重用一个WaitGroup来等待几组独立的事件,那么新的Add调用必须在所有之前的Wait调用返回后发生。请看WaitGroup的例子。</target>
        </trans-unit>
        <trans-unit id="5455acc6a0156c4dfa920acddbd7ebf8cf932467" translate="yes" xml:space="preserve">
          <source>Note that even for ResponseWriters that support Flush, if the client is connected through an HTTP proxy, the buffered data may not reach the client until the response completes.</source>
          <target state="translated">请注意,即使对于支持Flush的ResponseWriters,如果客户端是通过HTTP代理连接的,在响应完成之前,缓冲的数据可能不会到达客户端。</target>
        </trans-unit>
        <trans-unit id="5c3bd0ea640e306f27d50ba34f2f7b783e999786" translate="yes" xml:space="preserve">
          <source>Note that formatting of Go source code changes over time, so tools relying on consistent formatting should execute a specific version of the gofmt binary instead of using this package. That way, the formatting will be stable, and the tools won't need to be recompiled each time gofmt changes.</source>
          <target state="translated">请注意,Go源代码的格式化会随着时间的推移而改变,所以依赖一致格式化的工具应该执行特定版本的gofmt二进制,而不是使用这个包。这样一来,格式化将是稳定的,而且每次gofmt改变时,工具都不需要重新编译。</target>
        </trans-unit>
        <trans-unit id="e22ab49cba234a39b62136e423150811ceaf9eb2" translate="yes" xml:space="preserve">
          <source>Note that if len(b) == 0 and len(oob) &amp;gt; 0, this function will still read (and discard) 1 byte from the connection.</source>
          <target state="translated">请注意，如果len（b）== 0且len（oob）&amp;gt; 0，则此函数仍将从连接中读取（并丢弃）1个字节。</target>
        </trans-unit>
        <trans-unit id="1c2f06f3a5255f8d8b8129f0755c03b6610969a5" translate="yes" xml:space="preserve">
          <source>Note that if len(b) == 0 and len(oob) &amp;gt; 0, this function will still write 1 byte to the connection.</source>
          <target state="translated">请注意，如果len（b）== 0且len（oob）&amp;gt; 0，则此函数仍将向连接写入1个字节。</target>
        </trans-unit>
        <trans-unit id="6530be365312a7c4f8e32cd5888520ad9f3f1f1d" translate="yes" xml:space="preserve">
          <source>Note that if the session key is too small then it may be possible for an attacker to brute-force it. If they can do that then they can learn whether a random value was used (because it'll be different for the same ciphertext) and thus whether the padding was correct. This defeats the point of this function. Using at least a 16-byte key will protect against this attack.</source>
          <target state="translated">请注意,如果会话密钥太小,那么攻击者可能会对其进行强行破解。如果他们能做到这一点,那么他们就可以了解到是否使用了随机值(因为对于相同的密文,它将是不同的),从而了解到填充是否正确。这就违背了这个函数的意义。使用至少16字节的密钥可以防止这种攻击。</target>
        </trans-unit>
        <trans-unit id="344ecaa4cf851728d938597c41196d419ce8996a" translate="yes" xml:space="preserve">
          <source>Note that in this documentation, referring to an IP address as an IPv4 address or an IPv6 address is a semantic property of the address, not just the length of the byte slice: a 16-byte slice can still be an IPv4 address.</source>
          <target state="translated">请注意,在本文档中,将一个IP地址称为IPv4地址或IPv6地址是地址的语义属性,而不仅仅是字节分片的长度:一个16字节的分片仍然可以是一个IPv4地址。</target>
        </trans-unit>
        <trans-unit id="a249db9e2c9671edb18dbf9a7216586dc071e0a3" translate="yes" xml:space="preserve">
          <source>Note that it is not possible to use Reset's return value correctly, as there is a race condition between draining the channel and the new timer expiring. Reset should always be invoked on stopped or expired channels, as described above. The return value exists to preserve compatibility with existing programs.</source>
          <target state="translated">请注意,不可能正确使用Reset的返回值,因为在耗尽通道和新的定时器到期之间有一个竞赛条件。如上所述,Reset应始终在停止或过期的通道上调用。返回值的存在是为了保持与现有程序的兼容性。</target>
        </trans-unit>
        <trans-unit id="cbcbc6dbbe1cd946285db0917941f30791e5e34b" translate="yes" xml:space="preserve">
          <source>Note that obj.Parent() may be different from the returned scope if the object was inserted into the scope and already had a parent at that time (see Insert, below). This can only happen for dot-imported objects whose scope is the scope of the package that exported them.</source>
          <target state="translated">请注意,如果对象被插入到了作用域中,并且当时已经有了父对象,那么obj.Parent()可能会与返回的作用域不同(参见下面的插入)。这只可能发生在点导入的对象上,其作用域是导出它们的包的作用域。</target>
        </trans-unit>
        <trans-unit id="295b47a82aa942008478736d689df68628de7e25" translate="yes" xml:space="preserve">
          <source>Note that since a pattern ending in a slash names a rooted subtree, the pattern &quot;/&quot; matches all paths not matched by other registered patterns, not just the URL with Path == &quot;/&quot;.</source>
          <target state="translated">请注意,由于以斜杠结尾的模式命名了一个根的子树,所以模式&quot;/&quot;匹配所有未被其他注册模式匹配的路径,而不仅仅是路径==&quot;/&quot;的URL。</target>
        </trans-unit>
        <trans-unit id="5f4e1f66b103f275a7a85fe240ec0793b18c4588" translate="yes" xml:space="preserve">
          <source>Note that the 'x' form is the one used by most other languages and libraries.</source>
          <target state="translated">请注意,&quot;x &quot;形式是大多数其他语言和库所使用的形式。</target>
        </trans-unit>
        <trans-unit id="62af18353b85ece5ad43a8e2791ac7b4ef16a2b9" translate="yes" xml:space="preserve">
          <source>Note that the Go == operator compares not just the time instant but also the Location and the monotonic clock reading. See the documentation for the Time type for a discussion of equality testing for Time values.</source>
          <target state="translated">请注意,Go ==运算符不仅比较时间瞬间,还比较位置和单调时钟读数。参见时间类型的文档,了解时间值的平等测试。</target>
        </trans-unit>
        <trans-unit id="9bc5465e665f7d6206122a236966d74814c47dbc" translate="yes" xml:space="preserve">
          <source>Note that the Go == operator compares not just the time instant but also the Location and the monotonic clock reading. Therefore, Time values should not be used as map or database keys without first guaranteeing that the identical Location has been set for all values, which can be achieved through use of the UTC or Local method, and that the monotonic clock reading has been stripped by setting t = t.Round(0). In general, prefer t.Equal(u) to t == u, since t.Equal uses the most accurate comparison available and correctly handles the case when only one of its arguments has a monotonic clock reading.</source>
          <target state="translated">请注意,Go ==运算符不仅比较时间的瞬间,而且比较位置和单调时钟读数。因此,在没有首先保证所有值都设置了相同的Location(可以通过使用UTC或Local方法来实现),以及通过设置t=t.Round(0)来剥离单调时钟读数的情况下,不应该将时间值用作地图或数据库键。一般来说,更倾向于使用t.Equal(u)而不是t ==u,因为t.Equal使用了最精确的比较,并且正确处理了只有一个参数具有单调时钟读数的情况。</target>
        </trans-unit>
        <trans-unit id="f47d1736b65573bc0db0e46ddb437d8586c42dc1" translate="yes" xml:space="preserve">
          <source>Note that the Go runtime writes to standard error for panics and crashes; closing Stderr may cause those messages to go elsewhere, perhaps to a file opened later.</source>
          <target state="translated">请注意,围棋运行时会将恐慌和崩溃的信息写入标准错误;关闭 Stderr 可能会导致这些信息转到其他地方,也许是以后打开的文件。</target>
        </trans-unit>
        <trans-unit id="7b94d521ccf655c50db2b1ef784ea75e16313781" translate="yes" xml:space="preserve">
          <source>Note that the Path field is stored in decoded form: /%47%6f%2f becomes /Go/. A consequence is that it is impossible to tell which slashes in the Path were slashes in the raw URL and which were %2f. This distinction is rarely important, but when it is, the code should use RawPath, an optional field which only gets set if the default encoding is different from Path.</source>
          <target state="translated">请注意,路径字段是以解码形式存储的。/%47%6f%2f变成了/Go/。这样做的结果是,无法区分Path中哪些是原始URL中的斜线,哪些是%2f。这种区分很少是重要的,但是当它是重要的时候,代码应该使用RawPath,这是一个可选的字段,只有当默认编码与Path不同时才会被设置。</target>
        </trans-unit>
        <trans-unit id="6fb073049f21533864d69200a5feb9b782ae4382" translate="yes" xml:space="preserve">
          <source>Note that the RFC822, RFC850, and RFC1123 formats should be applied only to local times. Applying them to UTC times will use &quot;UTC&quot; as the time zone abbreviation, while strictly speaking those RFCs require the use of &quot;GMT&quot; in that case. In general RFC1123Z should be used instead of RFC1123 for servers that insist on that format, and RFC3339 should be preferred for new protocols. RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting; when used with time.Parse they do not accept all the time formats permitted by the RFCs. The RFC3339Nano format removes trailing zeros from the seconds field and thus may not sort correctly once formatted.</source>
          <target state="translated">请注意,RFC822、RFC850和RFC1123格式只能应用于本地时间。将它们应用于UTC时间将使用 &quot;UTC &quot;作为时区缩写,而严格来说,这些RFC要求在这种情况下使用 &quot;GMT&quot;。一般来说,对于坚持这种格式的服务器,应该使用RFC1123Z而不是RFC1123,对于新协议,应该首选RFC3339。RFC3339、RFC822、RFC822Z、RFC1123和RFC1123Z对格式化很有用;当与time.Parse一起使用时,它们并不接受RFC所允许的所有时间格式。RFC3339Nano格式从秒字段中去掉了尾部的零,因此一旦格式化后可能无法正确排序。</target>
        </trans-unit>
        <trans-unit id="bf45110f19f93211e34437dda6c947478fbddd92" translate="yes" xml:space="preserve">
          <source>Note that the examples in this package assume a Unix system. They may not run on Windows, and they do not run in the Go Playground used by golang.org and godoc.org.</source>
          <target state="translated">请注意,这个软件包中的例子是以Unix系统为前提的。它们可能无法在 Windows 上运行,也无法在 golang.org 和 godoc.org 使用的 Go Playground 中运行。</target>
        </trans-unit>
        <trans-unit id="cabbff14cb2952c80edb181213c130b459a02692" translate="yes" xml:space="preserve">
          <source>Note that the pointer must point into an allocated object, so it may not be nil.</source>
          <target state="translated">请注意,指针必须指向一个已分配的对象,所以它不可能是零。</target>
        </trans-unit>
        <trans-unit id="ee73d643f6fa22eddd036e602800c4d837e9ec70" translate="yes" xml:space="preserve">
          <source>Note that using CGI means starting a new process to handle each request, which is typically less efficient than using a long-running server. This package is intended primarily for compatibility with existing systems.</source>
          <target state="translated">请注意,使用CGI意味着启动一个新的进程来处理每个请求,这通常比使用一个长期运行的服务器效率低。这个软件包的目的主要是为了与现有系统兼容。</target>
        </trans-unit>
        <trans-unit id="e229bb3e45eb0475b8c930c1335cc5ff4dab911b" translate="yes" xml:space="preserve">
          <source>Note that whether this function returns an error or not discloses secret information. If an attacker can cause this function to run repeatedly and learn whether each instance returned an error then they can decrypt and forge signatures as if they had the private key. See DecryptPKCS1v15SessionKey for a way of solving this problem.</source>
          <target state="translated">注意,这个函数是否返回错误会泄露秘密信息。如果攻击者可以使这个函数反复运行,并了解到每个实例是否返回错误,那么他们就可以像拥有私钥一样解密和伪造签名。解决这个问题的方法请参见DecryptPKCS1v15SessionKey。</target>
        </trans-unit>
        <trans-unit id="916171d84342fed453d228a3166add2d096261bc" translate="yes" xml:space="preserve">
          <source>Note: Eval and CheckExpr should not be used instead of running Check to compute types and values, but in addition to Check, as these functions ignore the context in which an expression is used (e.g., an assignment). Thus, top-level untyped constants will return an untyped type rather then the respective context-specific type.</source>
          <target state="translated">注意:Eval和CheckExpr不应该被用来代替运行Check来计算类型和值,而是应该被用来代替Check,因为这些函数忽略了使用表达式的上下文(例如,赋值)。因此,顶层的非类型常量将返回一个非类型的类型,而不是各自的上下文特定类型。</target>
        </trans-unit>
        <trans-unit id="bd05f6d0d39a629d554e37dad544b0971bdc2e22" translate="yes" xml:space="preserve">
          <source>Note: Fscan etc. can read one character (rune) past the input they return, which means that a loop calling a scan routine may skip some of the input. This is usually a problem only when there is no space between input values. If the reader provided to Fscan implements ReadRune, that method will be used to read characters. If the reader also implements UnreadRune, that method will be used to save the character and successive calls will not lose data. To attach ReadRune and UnreadRune methods to a reader without that capability, use bufio.NewReader.</source>
          <target state="translated">注意:Fscan等可以从它们返回的输入中读取一个字符(符文),这意味着调用扫描例程的循环可能会跳过一些输入。这通常只有在输入值之间没有空格时才会出现问题。如果提供给Fscan的阅读器实现了ReadRune,那么该方法将被用来读取字符。如果阅读器也实现了UnreadRune,那么该方法将被用来保存字符,并且连续的调用不会丢失数据。要将ReadRune和UnreadRune方法附加到一个没有该功能的阅读器上,请使用bufio.NewReader.NewReader。</target>
        </trans-unit>
        <trans-unit id="2262c6082b97775886bda26c19137facc9855b36" translate="yes" xml:space="preserve">
          <source>Note: Since gobs can be stored permanently, it is good design to guarantee the encoding used by a GobEncoder is stable as the software evolves. For instance, it might make sense for GobEncode to include a version number in the encoding.</source>
          <target state="translated">注意:由于gob可以永久保存,所以保证GobEncoder使用的编码随着软件的发展而稳定是一个好的设计。例如,GobEncode在编码中包含一个版本号可能是有意义的。</target>
        </trans-unit>
        <trans-unit id="a1a8b94ea000b0ee13d1c73b1460cd401f581d14" translate="yes" xml:space="preserve">
          <source>Note: The maximum number of concurrent operations on a File may be limited by the OS or the system. The number should be high, but exceeding it may degrade performance or cause other issues.</source>
          <target state="translated">注意:一个文件上的最大并发操作数可能受到操作系统或系统的限制。这个数字应该很高,但超过这个数字可能会降低性能或导致其他问题。</target>
        </trans-unit>
        <trans-unit id="e27a7e32b7a1bd280289613fd2ddd6c441487040" translate="yes" xml:space="preserve">
          <source>Notice logs a message with severity LOG_NOTICE, ignoring the severity passed to New.</source>
          <target state="translated">Notice会记录一条严重性为LOG_NOTICE的消息,忽略传递给New的严重性。</target>
        </trans-unit>
        <trans-unit id="6c03ee54ad3a51fc92a1d69943e99667847705b6" translate="yes" xml:space="preserve">
          <source>Notify</source>
          <target state="translated">Notify</target>
        </trans-unit>
        <trans-unit id="f32ad9d0db01cf6742ecb4a7f760ed9166d4e428" translate="yes" xml:space="preserve">
          <source>Notify (AllSignals)</source>
          <target state="translated">通知 (AllSignals)</target>
        </trans-unit>
        <trans-unit id="ec0a8c1ae8d23b04c5ac40659f605bd7d0769148" translate="yes" xml:space="preserve">
          <source>Notify causes package signal to relay incoming signals to c. If no signals are provided, all incoming signals will be relayed to c. Otherwise, just the provided signals will.</source>
          <target state="translated">如果没有提供信号,则所有输入的信号将被中继到c,否则,仅提供信号。</target>
        </trans-unit>
        <trans-unit id="1dd2e9632e1d54f09b183732b58f92622a16dfc8" translate="yes" xml:space="preserve">
          <source>Notify disables the default behavior for a given set of asynchronous signals and instead delivers them over one or more registered channels. Specifically, it applies to the signals SIGHUP, SIGINT, SIGQUIT, SIGABRT, and SIGTERM. It also applies to the job control signals SIGTSTP, SIGTTIN, and SIGTTOU, in which case the system default behavior does not occur. It also applies to some signals that otherwise cause no action: SIGUSR1, SIGUSR2, SIGPIPE, SIGALRM, SIGCHLD, SIGCONT, SIGURG, SIGXCPU, SIGXFSZ, SIGVTALRM, SIGWINCH, SIGIO, SIGPWR, SIGSYS, SIGINFO, SIGTHR, SIGWAITING, SIGLWP, SIGFREEZE, SIGTHAW, SIGLOST, SIGXRES, SIGJVM1, SIGJVM2, and any real time signals used on the system. Note that not all of these signals are available on all systems.</source>
          <target state="translated">Notify禁用给定异步信号集的默认行为,而是通过一个或多个注册通道来传递它们。具体来说,它适用于信号SIGHUP、SIGINT、SIGQUIT、SIGABRT和SIGTERM。它也适用于作业控制信号SIGTSTP、SIGTTIN和SIGTTOU,在这种情况下,系统默认行为不会发生。它也适用于一些其他情况下不会引起任何动作的信号。SIGUSR1、SIGUSR2、SIGPIPE、SIGALRM、SIGCHLD、SIGCONT、SIGURG、SIGXCPU、SIGXFSZ、SIGVTALRM、SIGWINCH、SIGIO、SIGPWR、SIGSYS、SIGINFO、SIGTHR、SIGWAITING、SIGLWP、SIGFREEZE、SIGTHAW、SIGLOST、SIGXRES、SIGJVM1、SIGJVM2以及系统上使用的任何实时信号。需要注意的是,并不是所有的系统都能使用这些信号。</target>
        </trans-unit>
        <trans-unit id="a03da0ac3a6fe09e0b74b0584dcf52f14832da35" translate="yes" xml:space="preserve">
          <source>Now returns the current local time.</source>
          <target state="translated">现在返回当前当地时间。</target>
        </trans-unit>
        <trans-unit id="12f30fd28d8fbc7bdfb188f1073bae8ad0c81a0a" translate="yes" xml:space="preserve">
          <source>NsPerOp returns the &quot;ns/op&quot; metric.</source>
          <target state="translated">NsPerOp返回 &quot;ns/op &quot;指标。</target>
        </trans-unit>
        <trans-unit id="e3f04b0789ea5fe434b5bac945daef8d6c790ae0" translate="yes" xml:space="preserve">
          <source>NsecToTimespec takes a number of nanoseconds since the Unix epoch and returns the corresponding Timespec value.</source>
          <target state="translated">NsecToTimespec取Unix纪元以来的纳秒数,并返回相应的Timespec值。</target>
        </trans-unit>
        <trans-unit id="ba97613a512663d90a9d8bf323b048ee6483da36" translate="yes" xml:space="preserve">
          <source>NsecToTimeval takes a number of nanoseconds since the Unix epoch and returns the corresponding Timeval value.</source>
          <target state="translated">NsecToTimeval取Unix纪元以来的纳秒数,并返回相应的Timeval值。</target>
        </trans-unit>
        <trans-unit id="50a5fe209ccfd051610f95a63741ad7f7b729cb1" translate="yes" xml:space="preserve">
          <source>Null is a type that implements ValueConverter by allowing nil values but otherwise delegating to another ValueConverter.</source>
          <target state="translated">Null是一个实现ValueConverter的类型,它允许nil值,但在其他情况下委托给另一个ValueConverter。</target>
        </trans-unit>
        <trans-unit id="98cd8ff39a93a75c21d65e0a235ee463a7bbb829" translate="yes" xml:space="preserve">
          <source>Null returns the JavaScript value &quot;null&quot;.</source>
          <target state="translated">Null返回JavaScript值 &quot;null&quot;。</target>
        </trans-unit>
        <trans-unit id="6f8b0f41b489cc3f5ce2776f939ca31dc0509085" translate="yes" xml:space="preserve">
          <source>NullBool represents a bool that may be null. NullBool implements the Scanner interface so it can be used as a scan destination, similar to NullString.</source>
          <target state="translated">NullBool代表一个可能为空的bool。NullBool实现了Scanner接口,所以它可以作为一个扫描目标,类似于NullString。</target>
        </trans-unit>
        <trans-unit id="6792a3139e23717e375cad9a592c4bd259439184" translate="yes" xml:space="preserve">
          <source>NullBytes contains bytes representing the DER-encoded ASN.1 NULL type.</source>
          <target state="translated">NullBytes包含代表DER编码的ASN.1 NULL类型的字节。</target>
        </trans-unit>
        <trans-unit id="5f6d3dcfb1e3aa678952637bbe19fdc90b78b127" translate="yes" xml:space="preserve">
          <source>NullFloat64 represents a float64 that may be null. NullFloat64 implements the Scanner interface so it can be used as a scan destination, similar to NullString.</source>
          <target state="translated">NullFloat64表示一个可能为空的float64。NullFloat64实现了Scanner接口,所以它可以被用作扫描目标,类似于NullString。</target>
        </trans-unit>
        <trans-unit id="9e472847699046a5829bc4e4e7c408ab93169a01" translate="yes" xml:space="preserve">
          <source>NullInt32 represents an int32 that may be null. NullInt32 implements the Scanner interface so it can be used as a scan destination, similar to NullString.</source>
          <target state="translated">NullInt32代表一个可能是空的int32。NullInt32实现了Scanner接口,所以它可以被用作扫描目标,类似于NullString。</target>
        </trans-unit>
        <trans-unit id="9129057ccbbeafcc9b65fe6615ea2dfe0d92de58" translate="yes" xml:space="preserve">
          <source>NullInt64 represents an int64 that may be null. NullInt64 implements the Scanner interface so it can be used as a scan destination, similar to NullString.</source>
          <target state="translated">NullInt64代表一个可能是空的int64。NullInt64实现了Scanner接口,所以它可以被用作扫描目标,类似于NullString。</target>
        </trans-unit>
        <trans-unit id="d0dce04dd9159fa0b0caa17ec78453211e1469bd" translate="yes" xml:space="preserve">
          <source>NullRawValue is a RawValue with its Tag set to the ASN.1 NULL type tag (5).</source>
          <target state="translated">NullRawValue是一个RawValue,它的Tag设置为ASN.1 NULL类型标签(5)。</target>
        </trans-unit>
        <trans-unit id="74f3d9e74fdee0a23974ea8f9c10c75b52420438" translate="yes" xml:space="preserve">
          <source>NullString represents a string that may be null. NullString implements the Scanner interface so it can be used as a scan destination:</source>
          <target state="translated">NullString表示一个可能是空的字符串。NullString实现了Scanner接口,所以它可以被用作扫描目标。</target>
        </trans-unit>
        <trans-unit id="764711d7b7a7e05fa628aa8a88164882909b5ea1" translate="yes" xml:space="preserve">
          <source>NullTime represents a time.Time that may be null. NullTime implements the Scanner interface so it can be used as a scan destination, similar to NullString.</source>
          <target state="translated">NullTime代表一个可能是空的time.Time。NullTime实现了Scanner接口,所以它可以被用作扫描目标,类似于NullString。</target>
        </trans-unit>
        <trans-unit id="f04c9d785121ddad7627d64968a461809b36b14b" translate="yes" xml:space="preserve">
          <source>Nullable reports whether the column may be null. If a driver does not support this property ok will be false.</source>
          <target state="translated">Nullable报告列是否为空。如果一个驱动程序不支持这个属性,那么ok将为false。</target>
        </trans-unit>
        <trans-unit id="b616503fdba110413e1c79f07f22ca93729b1af0" translate="yes" xml:space="preserve">
          <source>Num returns the numerator of x; it may be &amp;lt;= 0. The result is a reference to x's numerator; it may change if a new value is assigned to x, and vice versa. The sign of the numerator corresponds to the sign of x.</source>
          <target state="translated">Num返回x的分子；结果可能是&amp;lt;=0。结果是对x分子的引用；如果将新值分配给x，它可能会更改，反之亦然。分子的符号与x的符号相对应。</target>
        </trans-unit>
        <trans-unit id="49dfb6250d5c5b7065edd1796c9ba60b2981b754" translate="yes" xml:space="preserve">
          <source>Num returns the numerator of x; x must be Int, Float, or Unknown. If x is Unknown, or if it is too large or small to represent as a fraction, the result is Unknown. Otherwise the result is an Int with the same sign as x.</source>
          <target state="translated">Num 返回 x 的分子;x 必须是 Int、Float 或 Unknown。如果x是未知数,或者如果它太大或太小而不能作为分数表示,结果就是未知数。否则,结果是一个与x同号的Int。</target>
        </trans-unit>
        <trans-unit id="07e8e8142272a14853fc3d4225faf1955a80ec0e" translate="yes" xml:space="preserve">
          <source>NumCPU returns the number of logical CPUs usable by the current process.</source>
          <target state="translated">NumCPU返回当前进程可使用的逻辑CPU数量。</target>
        </trans-unit>
        <trans-unit id="3bdcf0e9793febfba96be526d3f799da8d6c4599" translate="yes" xml:space="preserve">
          <source>NumCgoCall returns the number of cgo calls made by the current process.</source>
          <target state="translated">NumCgoCall返回当前进程的cgo调用次数。</target>
        </trans-unit>
        <trans-unit id="99d769aca95925934bfe7234523a8e266cfa3e86" translate="yes" xml:space="preserve">
          <source>NumChildren returns the number of scopes nested in s.</source>
          <target state="translated">NumChildren返回嵌套在s中的作用域的数量。</target>
        </trans-unit>
        <trans-unit id="7f8d5fa9c98c840bdcabc50036c605aaa61914fa" translate="yes" xml:space="preserve">
          <source>NumEmbeddeds returns the number of embedded types in interface t.</source>
          <target state="translated">NumEmbeddeds返回接口t中嵌入类型的数量。</target>
        </trans-unit>
        <trans-unit id="48274f29256d93bd977745ada6c383a46661d04c" translate="yes" xml:space="preserve">
          <source>NumError</source>
          <target state="translated">NumError</target>
        </trans-unit>
        <trans-unit id="085f257e02817fe0403777855cdf9b9d714c7182" translate="yes" xml:space="preserve">
          <source>NumExplicitMethods returns the number of explicitly declared methods of interface t.</source>
          <target state="translated">NumExplicitMethods 返回接口 t 的显式声明方法的数量。</target>
        </trans-unit>
        <trans-unit id="dc69c4938a12562dfc9db7decbe294fadc96a88a" translate="yes" xml:space="preserve">
          <source>NumField returns the number of fields in the struct v. It panics if v's Kind is not Struct.</source>
          <target state="translated">NumField返回v结构中的字段数,如果v的Kind不是Struct,它就会惊慌失措。</target>
        </trans-unit>
        <trans-unit id="37d55c8516ca892bb76b586c5b36e164d3bfee83" translate="yes" xml:space="preserve">
          <source>NumFields returns the number of fields in the struct (including blank and embedded fields).</source>
          <target state="translated">NumFields返回结构中的字段数(包括空白字段和嵌入字段)。</target>
        </trans-unit>
        <trans-unit id="67aa508431878c89dfc1facabaf28776d55930aa" translate="yes" xml:space="preserve">
          <source>NumFields returns the number of parameters or struct fields represented by a FieldList.</source>
          <target state="translated">NumFields 返回一个 FieldList 所代表的参数或结构域的数量。</target>
        </trans-unit>
        <trans-unit id="64877a16861b7f92b7b931c3dd32e6bffe105163" translate="yes" xml:space="preserve">
          <source>NumGoroutine returns the number of goroutines that currently exist.</source>
          <target state="translated">NumGoroutine 返回当前存在的goroutine的数量。</target>
        </trans-unit>
        <trans-unit id="20f482d6f3d78d176b8cba126c2420b8ebb6a1e9" translate="yes" xml:space="preserve">
          <source>NumMethod returns the number of exported methods in the value's method set.</source>
          <target state="translated">NumMethod返回值的方法集中导出的方法数量。</target>
        </trans-unit>
        <trans-unit id="e16da0849c5c39aaf5008c6fb5c0acd6258e7143" translate="yes" xml:space="preserve">
          <source>NumMethods returns the number of explicit methods whose receiver is named type t.</source>
          <target state="translated">NumMethods 返回显式方法的数量,这些方法的接收者被命名为t类型。</target>
        </trans-unit>
        <trans-unit id="efca93e8ccf5085b691b876b60dbb50f530aac0f" translate="yes" xml:space="preserve">
          <source>NumMethods returns the total number of methods of interface t.</source>
          <target state="translated">NumMethods返回接口t的方法总数。</target>
        </trans-unit>
        <trans-unit id="f56f8cd32be5e8eed5e5b31f9ccdc038bef949c9" translate="yes" xml:space="preserve">
          <source>NumSubexp returns the number of parenthesized subexpressions in this Regexp.</source>
          <target state="translated">NumSubexp返回该Regexpression中括号内子表达式的数量。</target>
        </trans-unit>
        <trans-unit id="8bd18a7cf0e1d4bc6bca5d9c1e222116af743cd5" translate="yes" xml:space="preserve">
          <source>NumberNode holds a number: signed or unsigned integer, float, or complex. The value is parsed and stored under all the types that can represent the value. This simulates in a small amount of code the behavior of Go's ideal constants.</source>
          <target state="translated">NumberNode持有一个数字:有符号或无符号整数、浮点数或复数。该值被解析并存储在所有可以表示该值的类型下。这在少量的代码中模拟了围棋理想常量的行为。</target>
        </trans-unit>
        <trans-unit id="aebc8ea3b91ff7b79f4c3ee912e30d014d9c0e7c" translate="yes" xml:space="preserve">
          <source>Numbers are translated by reading and writing fixed-size values. A fixed-size value is either a fixed-size arithmetic type (bool, int8, uint8, int16, float32, complex64, ...) or an array or struct containing only fixed-size values.</source>
          <target state="translated">数字是通过读写固定大小的值来翻译的。一个固定大小的值可以是一个固定大小的算术类型(bool,int8,uint8,int16,float32,complex64,...),也可以是一个只包含固定大小值的数组或结构。</target>
        </trans-unit>
        <trans-unit id="514d0c82a993264caef98a3606fa7dc9d584da1d" translate="yes" xml:space="preserve">
          <source>Numbers fundamental to the encoding.</source>
          <target state="translated">编码的基本数字。</target>
        </trans-unit>
        <trans-unit id="f72c4497b8297399ea538316ed693eb0b0f69dbb" translate="yes" xml:space="preserve">
          <source>Numeric Conversions</source>
          <target state="translated">数值转换</target>
        </trans-unit>
        <trans-unit id="294de652150e65884a04c4fc22af8edbb1682a0b" translate="yes" xml:space="preserve">
          <source>Numeric time zone offsets format as follows:</source>
          <target state="translated">数值时区偏移的格式如下:</target>
        </trans-unit>
        <trans-unit id="42abdd30b855d13cdf926751fede5f671a054974" translate="yes" xml:space="preserve">
          <source>OAEP is parameterised by a hash function that is used as a random oracle. Encryption and decryption of a given message must use the same hash function and sha256.New() is a reasonable choice.</source>
          <target state="translated">OAEP的参数化是由一个哈希函数作为随机神谕。对给定消息的加密和解密必须使用相同的哈希函数,sha256.New()是一个合理的选择。</target>
        </trans-unit>
        <trans-unit id="7c5f4d9d83e4f742a8c6f7a878b2a58947298d00" translate="yes" xml:space="preserve">
          <source>OAEPOptions is an interface for passing options to OAEP decryption using the crypto.Decrypter interface.</source>
          <target state="translated">OAEPOptions是一个接口,用于向使用crypto.Decrypter接口的OAEP解密传递选项。</target>
        </trans-unit>
        <trans-unit id="ad8427a11879cfd2d8db1b9e8e8f59a37957814e" translate="yes" xml:space="preserve">
          <source>OCSPResponse returns the stapled OCSP response from the TLS server, if any. (Only valid for client connections.)</source>
          <target state="translated">OCSPResponse返回来自TLS服务器的钉书机OCSP响应(如果有的话)。(只对客户端连接有效。)</target>
        </trans-unit>
        <trans-unit id="e8520e97ccf3aeee86e1f8ac2f743514a534e58a" translate="yes" xml:space="preserve">
          <source>OSABI is found in Header.Ident[EI_OSABI] and Header.OSABI.</source>
          <target state="translated">OSABI在Header.Ident[EI_OSABI]和Header.OSABI中找到。</target>
        </trans-unit>
        <trans-unit id="68fe95dd58ed02ddd93208f0b1d291299be0c119" translate="yes" xml:space="preserve">
          <source>Obj returns the object denoted by x.f; a *Var for a field selection, and a *Func in all other cases.</source>
          <target state="translated">Obj返回x.f所表示的对象;对于字段选择,返回一个*Var,对于其他情况,返回一个*Func。</target>
        </trans-unit>
        <trans-unit id="9eb16182993cc59927b4da07ba021ca619da9eaa" translate="yes" xml:space="preserve">
          <source>Obj returns the type name for the named type t.</source>
          <target state="translated">Obj返回命名类型t的类型名。</target>
        </trans-unit>
        <trans-unit id="ea5997c7d13deb46517727f9e2dc50eb58fb0ac9" translate="yes" xml:space="preserve">
          <source>ObjKind describes what an object represents.</source>
          <target state="translated">ObjKind描述了一个对象所代表的内容。</target>
        </trans-unit>
        <trans-unit id="148bd125b03ec79b1e809f1705cff50161dd08f8" translate="yes" xml:space="preserve">
          <source>ObjectOf returns the object denoted by the specified id, or nil if not found.</source>
          <target state="translated">ObjectOf返回指定id所表示的对象,如果没有找到,则返回nil。</target>
        </trans-unit>
        <trans-unit id="696fabf5d47e7927b31c4529cb32de76645f9e45" translate="yes" xml:space="preserve">
          <source>ObjectString returns the string form of obj. The Qualifier controls the printing of package-level objects, and may be nil.</source>
          <target state="translated">ObjectString 返回 obj 的字符串形式。该限定符控制包级对象的打印,也可以为零。</target>
        </trans-unit>
        <trans-unit id="2a0a0f32e63d21edc60ea1562ca9a173b5386b67" translate="yes" xml:space="preserve">
          <source>Of the asynchronous signals, the SIGHUP signal is sent when a program loses its controlling terminal. The SIGINT signal is sent when the user at the controlling terminal presses the interrupt character, which by default is ^C (Control-C). The SIGQUIT signal is sent when the user at the controlling terminal presses the quit character, which by default is ^\ (Control-Backslash). In general you can cause a program to simply exit by pressing ^C, and you can cause it to exit with a stack dump by pressing ^\.</source>
          <target state="translated">在异步信号中,SIGHUP信号是在程序失去控制终端时发出的。当用户在控制端按下中断字符时发送SIGINT信号,默认为^C(Control-C)。SIGQUIT信号是在控制终端的用户按下退出字符时发出的,默认情况下是^C(Control-Backlash)。一般来说,你可以通过按^C使程序简单地退出,也可以通过按^\使程序以堆栈转储的方式退出。</target>
        </trans-unit>
        <trans-unit id="65a759f4644d298e31d53fd1d1620c7a2eccb79e" translate="yes" xml:space="preserve">
          <source>Offset returns the offset for the given file position p; p must be a valid Pos value in that file. f.Offset(f.Pos(offset)) == offset.</source>
          <target state="translated">Offset返回给定文件位置p的偏移量;p必须是该文件中有效的Pos值。f.Offset(f.Pos(offset))==offset。</target>
        </trans-unit>
        <trans-unit id="e668fecf796eebcf71860aea79f4acfd32998a26" translate="yes" xml:space="preserve">
          <source>Offsetof returns the offset within the struct of the field represented by x, which must be of the form structValue.field. In other words, it returns the number of bytes between the start of the struct and the start of the field. The return value of Offsetof is a Go constant.</source>
          <target state="translated">Offsetof返回x代表的字段在结构中的偏移量,其形式必须是structValue.field。换句话说,它返回结构的开始和字段的开始之间的字节数。Offsetof的返回值是一个围棋常量。</target>
        </trans-unit>
        <trans-unit id="0ac54daba3530c56c22c7ab5fd0f77563ce7acd3" translate="yes" xml:space="preserve">
          <source>Often, ascii85-encoded data is wrapped in &amp;lt;~ and ~&amp;gt; symbols. Encode does not add these.</source>
          <target state="translated">通常，ASCII85编码的数据用&amp;lt;〜和〜&amp;gt;符号包装。编码不添加这些。</target>
        </trans-unit>
        <trans-unit id="23cc25224e88c84b965606d1525d366853ed4824" translate="yes" xml:space="preserve">
          <source>On AIX, DragonFly BSD, NetBSD, OpenBSD, Plan 9 and Solaris, the MulticastAddrs method of Interface is not implemented.</source>
          <target state="translated">在AIX、DragonFly BSD、NetBSD、OpenBSD、Plan 9和Solaris上,没有实现Interface的MulticastAddrs方法。</target>
        </trans-unit>
        <trans-unit id="a1d045aa427adecabc2fe461f86a4e36227e3495" translate="yes" xml:space="preserve">
          <source>On ARM, x86-32, and 32-bit MIPS, it is the caller's responsibility to arrange for 64-bit alignment of 64-bit words accessed atomically. The first word in a variable or in an allocated struct, array, or slice can be relied upon to be 64-bit aligned.</source>
          <target state="translated">在ARM、x86-32和32位MIPS上,调用者有责任安排原子访问的64位字的64位对齐。变量或分配的结构、数组或片中的第一个字可以依靠64位对齐。</target>
        </trans-unit>
        <trans-unit id="78d4a89f2d2e09c9cf23ea8b902790da4d5ff91d" translate="yes" xml:space="preserve">
          <source>On DragonFly BSD and OpenBSD, listening on the &quot;tcp&quot; and &quot;udp&quot; networks does not listen for both IPv4 and IPv6 connections. This is due to the fact that IPv4 traffic will not be routed to an IPv6 socket - two separate sockets are required if both address families are to be supported. See inet6(4) for details.</source>
          <target state="translated">在DragonFly BSD和OpenBSD上,&quot;tcp &quot;和 &quot;udp &quot;网络上的监听不能同时监听IPv4和IPv6连接。这是由于 IPv4 流量不会被路由到 IPv6 套接字--如果要支持两个地址族,则需要两个单独的套接字。详情请参见 inet6(4)。</target>
        </trans-unit>
        <trans-unit id="bc2494255e41ee3a52e5ab617366af15ab263764" translate="yes" xml:space="preserve">
          <source>On JS and NaCl, methods and functions related to Interface are not implemented.</source>
          <target state="translated">在JS和NaCl上,没有实现与Interface相关的方法和功能。</target>
        </trans-unit>
        <trans-unit id="a22fcd32dddc8742d71eeb00fd66a97a307dec2b" translate="yes" xml:space="preserve">
          <source>On JS, NaCl and Plan 9, methods and functions related to IPConn are not implemented.</source>
          <target state="translated">在JS、NaCl和Plan 9上,没有实施与IPConnect相关的方法和功能。</target>
        </trans-unit>
        <trans-unit id="c330a67c6571f090abbe696684e69b144f23ffce" translate="yes" xml:space="preserve">
          <source>On JS, NaCl and Plan 9, methods and functions related to UnixConn and UnixListener are not implemented.</source>
          <target state="translated">在JS、NaCl和Plan 9上,没有实现UnixConn和UnixListener的相关方法和功能。</target>
        </trans-unit>
        <trans-unit id="187bea53a3943264ca3ab448938a9eb5588890ad" translate="yes" xml:space="preserve">
          <source>On JS, NaCl and Plan 9, the Control, Read and Write methods of syscall.RawConn are not implemented.</source>
          <target state="translated">在JS、NaCl和Plan 9上,没有实现syscall.RawConn的控制、读和写方法。</target>
        </trans-unit>
        <trans-unit id="8af01a3a36621e313c89de20d229f16557b6c642" translate="yes" xml:space="preserve">
          <source>On JS, NaCl and Windows, the File method of TCPConn and TCPListener is not implemented.</source>
          <target state="translated">在JS、NaCl和Windows上,没有实现TCPConn和TCPListener的File方法。</target>
        </trans-unit>
        <trans-unit id="c3a3c87314e5ae7220ae61af7b9a4aaad742b9fa" translate="yes" xml:space="preserve">
          <source>On JS, NaCl and Windows, the FileConn, FileListener and FilePacketConn functions are not implemented.</source>
          <target state="translated">在JS、NaCl和Windows上,没有实现FileConn、FileListener和FilePacketConn函数。</target>
        </trans-unit>
        <trans-unit id="50eadbc0d323969884ecf9cc0009e49c34ea969b" translate="yes" xml:space="preserve">
          <source>On JS, methods and functions related to UDPConn are not implemented.</source>
          <target state="translated">在JS上,没有实现与UDPConn相关的方法和功能。</target>
        </trans-unit>
        <trans-unit id="a1c684d38068da43548a6ff99a071652823f3627" translate="yes" xml:space="preserve">
          <source>On Linux and FreeBSD, Reader uses getrandom(2) if available, /dev/urandom otherwise. On OpenBSD, Reader uses getentropy(2). On other Unix-like systems, Reader reads from /dev/urandom. On Windows systems, Reader uses the CryptGenRandom API. On Wasm, Reader uses the Web Crypto API.</source>
          <target state="translated">在Linux和FreeBSD上,Reader使用getrandom(2),如果可用的话,否则使用/dev/urandom。在 OpenBSD 上,Reader 使用 getentropy(2)。在其他类似Unix的系统上,Reader从/dev/urandom读取。在Windows系统上,Reader使用CryptGenRandom API。在Wasm系统上,Reader使用Web Crypto API。</target>
        </trans-unit>
        <trans-unit id="c8ff5cc97c5ee66d154a1695c234ed4080927ad5" translate="yes" xml:space="preserve">
          <source>On NaCl and Plan 9, the ReadMsgUDP and WriteMsgUDP methods of UDPConn are not implemented.</source>
          <target state="translated">在NaCl和Plan 9上,UDPConn的ReadMsgUDP和WriteMsgUDP方法没有实现。</target>
        </trans-unit>
        <trans-unit id="87e667c5ede44ae5764673fc28b292659a0f5bd8" translate="yes" xml:space="preserve">
          <source>On NaCl, the ListenMulticastUDP function is not implemented.</source>
          <target state="translated">在NaCl上,没有实现ListenMulticastUDP功能。</target>
        </trans-unit>
        <trans-unit id="a330e696a92e2d53090bac7c262b179695141719" translate="yes" xml:space="preserve">
          <source>On POSIX systems Gid contains a decimal number representing the group ID.</source>
          <target state="translated">在POSIX系统中,Gid包含一个代表组ID的十进制数。</target>
        </trans-unit>
        <trans-unit id="2703d3b45f73f82bdf72e3fead14e53678acde02" translate="yes" xml:space="preserve">
          <source>On Plan 9, signals have type syscall.Note, which is a string. Calling Notify with a syscall.Note will cause that value to be sent on the channel when that string is posted as a note.</source>
          <target state="translated">在计划9上,信号的类型是syscall.Note,这是一个字符串。用syscall.Note调用Notify,当该字符串作为备注发布时,将导致该值在通道上发送。</target>
        </trans-unit>
        <trans-unit id="4b29c33c1c929a09e8c06f8cea419c82c9628ed0" translate="yes" xml:space="preserve">
          <source>On Plan 9, the mode's permission bits, ModeAppend, ModeExclusive, and ModeTemporary are used.</source>
          <target state="translated">在计划9上,使用了模式的权限位,即ModeAppend、ModeExclusive和ModeTemporary。</target>
        </trans-unit>
        <trans-unit id="f8763fb392ab0ac0ea38c3b25946a7a1236134b7" translate="yes" xml:space="preserve">
          <source>On Plan 9, the resolver always accesses /net/cs and /net/dns.</source>
          <target state="translated">在计划9中,解析器总是访问/net/cs和/net/dns。</target>
        </trans-unit>
        <trans-unit id="a1fe82f792d7b21f9ebd6296c1d86e735f0892e1" translate="yes" xml:space="preserve">
          <source>On Solaris, it returns one of the logical network interfaces sharing the logical data link; for more precision use InterfaceByName.</source>
          <target state="translated">在Solaris上,它返回共享逻辑数据链路的逻辑网络接口之一;为了更精确,使用InterfaceByName。</target>
        </trans-unit>
        <trans-unit id="d85518513a854a5111d381e48be350b2e36728b6" translate="yes" xml:space="preserve">
          <source>On UNIX systems the environment variables SSL_CERT_FILE and SSL_CERT_DIR can be used to override the system default locations for the SSL certificate file and SSL certificate files directory, respectively.</source>
          <target state="translated">在UNIX系统中,环境变量SSL_CERT_FILE和SSL_CERT_DIR可以分别用来覆盖SSL证书文件和SSL证书文件目录的系统默认位置。</target>
        </trans-unit>
        <trans-unit id="88f58a825e10f84944f638859f6290d9816daa64" translate="yes" xml:space="preserve">
          <source>On Unix systems, FindProcess always succeeds and returns a Process for the given pid, regardless of whether the process exists.</source>
          <target state="translated">在Unix系统中,无论进程是否存在,FindProcess总是成功地返回一个给定pid的进程。</target>
        </trans-unit>
        <trans-unit id="98e3b9345fcee9a653cd9ea250ff090f5fd5a0bd" translate="yes" xml:space="preserve">
          <source>On Unix systems, it returns $TMPDIR if non-empty, else /tmp. On Windows, it uses GetTempPath, returning the first non-empty value from %TMP%, %TEMP%, %USERPROFILE%, or the Windows directory. On Plan 9, it returns /tmp.</source>
          <target state="translated">在Unix系统中,如果是非空的,则返回$TMPDIR,否则返回/tmp.在Windows系统中,它使用GetTempPath,从%TMP%、%TEMP%、%USERPROFILE%或Windows目录中返回第一个非空值。在Windows系统中,它使用GetTempPath,从%TMP%、%TEMP%、%USERPROFILE%或Windows目录中返回第一个非空值。在Plan 9上,它返回/tmp.在Windows上,它使用GetTempPath,从%TMP%、%TEMP%、%USERPROFILE%或Windows目录返回第一个非空值。</target>
        </trans-unit>
        <trans-unit id="a069a183e2963c2a249b77ad664c6a016ed84b52" translate="yes" xml:space="preserve">
          <source>On Unix systems, it returns $XDG_CACHE_HOME as specified by &lt;a href=&quot;https://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html&quot;&gt;https://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html&lt;/a&gt; if non-empty, else $HOME/.cache. On Darwin, it returns $HOME/Library/Caches. On Windows, it returns %LocalAppData%. On Plan 9, it returns $home/lib/cache.</source>
          <target state="translated">在Unix系统上，如果非空，则返回&lt;a href=&quot;https://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html&quot;&gt;https://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html&lt;/a&gt;指定的$ XDG_CACHE_HOME，否则返回$ HOME / .cache。在Darwin上，它返回$ HOME / Library / Caches。在Windows上，它返回％LocalAppData％。在计划9中，它返回$ home / lib / cache。</target>
        </trans-unit>
        <trans-unit id="1807151e52b0b2b36b5236bbf2d0ef14a9ec1abc" translate="yes" xml:space="preserve">
          <source>On Unix systems, it returns $XDG_CONFIG_HOME as specified by &lt;a href=&quot;https://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html&quot;&gt;https://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html&lt;/a&gt; if non-empty, else $HOME/.config. On Darwin, it returns $HOME/Library/Application Support. On Windows, it returns %AppData%. On Plan 9, it returns $home/lib.</source>
          <target state="translated">在Unix系统上，如果非空，则返回&lt;a href=&quot;https://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html&quot;&gt;https://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html&lt;/a&gt;指定的$ XDG_CONFIG_HOME，否则返回$ HOME / .config。在Darwin上，它返回$ HOME / Library / Application Support。在Windows上，它返回％AppData％。在计划9中，它返回$ home / lib。</target>
        </trans-unit>
        <trans-unit id="2893f193d590bc3c2b7840d64034a29f26c7240a" translate="yes" xml:space="preserve">
          <source>On Unix systems, the resolver has two options for resolving names. It can use a pure Go resolver that sends DNS requests directly to the servers listed in /etc/resolv.conf, or it can use a cgo-based resolver that calls C library routines such as getaddrinfo and getnameinfo.</source>
          <target state="translated">在Unix系统中,解析器有两种解析名称的选择。它可以使用纯粹的Go解析器,将DNS请求直接发送到/etc/resolv.conf中列出的服务器,也可以使用基于cgo的解析器,调用getaddrinfo和getnameinfo等C库例程。</target>
        </trans-unit>
        <trans-unit id="3c7408069288e442b0e9334096b1f9423749a2cb" translate="yes" xml:space="preserve">
          <source>On Unix, including macOS, it returns the $HOME environment variable. On Windows, it returns %USERPROFILE%. On Plan 9, it returns the $home environment variable.</source>
          <target state="translated">在Unix上,包括macOS,它返回$HOME环境变量,在Windows上,它返回%USERPROFILE%。在Windows上,它返回%USERPROFILE%。在Plan 9上,它返回$home环境变量。</target>
        </trans-unit>
        <trans-unit id="5c4d1d5958d138a86f133f67425aa5377e82d717" translate="yes" xml:space="preserve">
          <source>On Unix, the mode's permission bits, ModeSetuid, ModeSetgid, and ModeSticky are used.</source>
          <target state="translated">在Unix上,使用模式的权限位ModeSetuid、ModeSetgid和ModeSticky。</target>
        </trans-unit>
        <trans-unit id="b3748b447fc18cd33fa72cfd10ff7a8e4c810a41" translate="yes" xml:space="preserve">
          <source>On Unix-like systems, StartCPUProfile does not work by default for Go code built with -buildmode=c-archive or -buildmode=c-shared. StartCPUProfile relies on the SIGPROF signal, but that signal will be delivered to the main program's SIGPROF signal handler (if any) not to the one used by Go. To make it work, call os/signal.Notify for syscall.SIGPROF, but note that doing so may break any profiling being done by the main program.</source>
          <target state="translated">在类似 Unix 的系统中,对于以 -buildmode=c-archive 或 -buildmode=c-shared 构建的 Go 代码,StartCPUProfile 默认不工作。StartCPUProfile依赖于SIGPROF信号,但该信号将被传递给主程序的SIGPROF信号处理程序(如果有的话),而不是Go使用的信号处理程序。为了使它工作,调用 os/signal.Notify 来获取 syscall.SIGPROF,但注意这样做可能会破坏主程序正在进行的任何剖析。</target>
        </trans-unit>
        <trans-unit id="38c48a0935e355c448766738061267dd6c7374a5" translate="yes" xml:space="preserve">
          <source>On Windows a ^C (Control-C) or ^BREAK (Control-Break) normally cause the program to exit. If Notify is called for os.Interrupt, ^C or ^BREAK will cause os.Interrupt to be sent on the channel, and the program will not exit. If Reset is called, or Stop is called on all channels passed to Notify, then the default behavior will be restored.</source>
          <target state="translated">在 Windows 上,^C (Control-C)或 ^BREAK (Control-Break)通常会导致程序退出。如果调用Notify来处理os.Interrupt,^C或^BREAK将导致os.Interrupt被发送到该通道上,而程序不会退出。如果调用Reset,或者在所有传递给Notify的通道上调用Stop,那么将恢复默认行为。</target>
        </trans-unit>
        <trans-unit id="84cb9183f88acab7f0a3e8615676023c95cfe1f4" translate="yes" xml:space="preserve">
          <source>On Windows or Plan 9, Chown always returns the syscall.EWINDOWS or EPLAN9 error, wrapped in *PathError.</source>
          <target state="translated">在Windows或Plan 9上,Chown总是返回syscall.EWINDOWS或EPLAN9错误,包裹在*PathError中。</target>
        </trans-unit>
        <trans-unit id="f5c6a1e271d70b402bf7e630854ac58bbcf34f9f" translate="yes" xml:space="preserve">
          <source>On Windows, MIME types are extracted from the registry.</source>
          <target state="translated">在Windows上,MIME类型是从注册表中提取的。</target>
        </trans-unit>
        <trans-unit id="5350be8357b453f05f4ce5a07cf3bf1dba9318a4" translate="yes" xml:space="preserve">
          <source>On Windows, escaping is disabled. Instead, '\\' is treated as path separator.</source>
          <target state="translated">在Windows系统中,转义符被禁用。取而代之的是,'\\'被当作路径分隔符。</target>
        </trans-unit>
        <trans-unit id="a41bed9c4201556ec574f1ac26f677457e930cdc" translate="yes" xml:space="preserve">
          <source>On Windows, it always returns the syscall.EWINDOWS error, wrapped in *PathError.</source>
          <target state="translated">在Windows上,它总是返回syscall.EWINDOWS错误,包裹在*PathError中。</target>
        </trans-unit>
        <trans-unit id="6f31a978cb1a7e83893ce791c5aa32ff7ac495fa" translate="yes" xml:space="preserve">
          <source>On Windows, it returns -1.</source>
          <target state="translated">在Windows下,它返回-1。</target>
        </trans-unit>
        <trans-unit id="6a02f4fe5f583e59f31f6cbc5e10b9216b10a0af" translate="yes" xml:space="preserve">
          <source>On Windows, it returns syscall.EWINDOWS. See the os/user package for a possible alternative.</source>
          <target state="translated">在 Windows 上,它返回 syscall.EWINDOWS。请参阅 os/user 软件包以获得一个可能的替代方案。</target>
        </trans-unit>
        <trans-unit id="0d3a0f41f0df73942f4fecfe70a64ca015408110" translate="yes" xml:space="preserve">
          <source>On Windows, methods and functions related to UnixConn and UnixListener don't work for &quot;unixgram&quot; and &quot;unixpacket&quot;.</source>
          <target state="translated">在Windows上,与UnixConn和UnixListener相关的方法和函数对 &quot;unixgram &quot;和 &quot;unixpacket &quot;不起作用。</target>
        </trans-unit>
        <trans-unit id="bd2981a73df24a936314bf6d1873afd69dc8adde" translate="yes" xml:space="preserve">
          <source>On Windows, only the 0200 bit (owner writable) of mode is used; it controls whether the file's read-only attribute is set or cleared. The other bits are currently unused. For compatibility with Go 1.12 and earlier, use a non-zero mode. Use mode 0400 for a read-only file and 0600 for a readable+writable file.</source>
          <target state="translated">在Windows上,只使用模式的0200位(所有者可写);它控制文件的只读属性是被设置还是被清除。其他位目前未被使用。为了与围棋1.12及更早的版本兼容,请使用非零模式。对只读文件使用模式0400,对可读+可写文件使用模式0600。</target>
        </trans-unit>
        <trans-unit id="2612d030cdd95b20b0743477158be3874169bfe3" translate="yes" xml:space="preserve">
          <source>On Windows, processes receive the whole command line as a single string and do their own parsing. Command combines and quotes Args into a command line string with an algorithm compatible with applications using CommandLineToArgvW (which is the most common way). Notable exceptions are msiexec.exe and cmd.exe (and thus, all batch files), which have a different unquoting algorithm. In these or other similar cases, you can do the quoting yourself and provide the full command line in SysProcAttr.CmdLine, leaving Args empty.</source>
          <target state="translated">在Windows上,进程以单个字符串的形式接收整个命令行,并进行自己的解析。Command将Args组合并引用成一个命令行字符串,其算法与使用CommandLineToArgvW(这是最常见的方式)的应用程序兼容。值得注意的例外是msiexec.exe和cmd.exe(因此,所有批处理文件),它们有不同的解引号算法。在这些或其他类似的情况下,你可以自己做引号,并在SysProcAttr.CmdLine中提供完整的命令行,将Args留空。</target>
        </trans-unit>
        <trans-unit id="0058230d55ce789eb5612e2b93e4da6eea793a83" translate="yes" xml:space="preserve">
          <source>On Windows, the File method of IPConn is not implemented.</source>
          <target state="translated">在Windows上,没有实现IPConnect的File方法。</target>
        </trans-unit>
        <trans-unit id="d755b555a5935f43a3d90e65b76056dcf10027ed" translate="yes" xml:space="preserve">
          <source>On Windows, the File method of UDPConn is not implemented.</source>
          <target state="translated">在Windows上,UDPConn的File方法没有实现。</target>
        </trans-unit>
        <trans-unit id="f31f810d1a4482b639a8bee446be568ce053ee4a" translate="yes" xml:space="preserve">
          <source>On Windows, the Write method of syscall.RawConn does not integrate with the runtime's network poller. It cannot wait for the connection to become writeable, and does not respect deadlines. If the user-provided callback returns false, the Write method will fail immediately.</source>
          <target state="translated">在Windows上,syscall.RawConn的Write方法没有与运行时的网络轮询器集成。它不能等待连接变得可写,也不尊重截止日期。如果用户提供的回调返回false,Write方法将立即失败。</target>
        </trans-unit>
        <trans-unit id="8b8fbd99e87c243a50d7f3fe8f96df26bcf452aa" translate="yes" xml:space="preserve">
          <source>On Windows, the resolver always uses C library functions, such as GetAddrInfo and DnsQuery.</source>
          <target state="translated">在Windows上,解析器总是使用C库函数,如GetAddrInfo和DnsQuery。</target>
        </trans-unit>
        <trans-unit id="bf70d5852ec76636f3807a9db0f77a9465a35084" translate="yes" xml:space="preserve">
          <source>On all platforms, the traceback function is invoked when a call from Go to C to Go requests a stack trace. On linux/amd64, linux/ppc64le, and freebsd/amd64, the traceback function is also invoked when a signal is received by a thread that is executing a cgo call. The traceback function should not make assumptions about when it is called, as future versions of Go may make additional calls.</source>
          <target state="translated">在所有平台上,当从Go到C到Go的调用请求堆栈跟踪时,会调用traceback函数。在linux/amd64、linux/ppc64le和freebsd/amd64上,当一个正在执行cgo调用的线程接收到一个信号时,也会调用traceback函数。追溯函数不应该对它被调用的时间做出假设,因为未来的Go版本可能会进行额外的调用。</target>
        </trans-unit>
        <trans-unit id="d6c40e8d8a1cb9c0f6c9d4c03dcd550161059582" translate="yes" xml:space="preserve">
          <source>On certain machines, for certain types of connections, this is optimized into an OS-specific batch write operation (such as &quot;writev&quot;).</source>
          <target state="translated">在某些机器上,对于某些类型的连接,这被优化为操作系统特定的批量写入操作(如 &quot;writev&quot;)。</target>
        </trans-unit>
        <trans-unit id="c77b73816658f653733e14c2986094f012e8e513" translate="yes" xml:space="preserve">
          <source>On error, any Response can be ignored. A non-nil Response with a non-nil error only occurs when CheckRedirect fails, and even then the returned Response.Body is already closed.</source>
          <target state="translated">出错时,可以忽略任何Response。只有当CheckRedirect失败时,才会出现一个非nil错误的Response,即使如此,返回的Response.Body也已经被关闭。</target>
        </trans-unit>
        <trans-unit id="13e02db1965a04d36b6a5db4b5d676787f23298f" translate="yes" xml:space="preserve">
          <source>On every POSIX platform, reads from the &quot;ip4&quot; network using the ReadFrom or ReadFromIP method might not return a complete IPv4 packet, including its header, even if there is space available. This can occur even in cases where Read or ReadMsgIP could return a complete packet. For this reason, it is recommended that you do not use these methods if it is important to receive a full packet.</source>
          <target state="translated">在每个POSIX平台上,使用ReadFrom或ReadFromIP方法从 &quot;ip4 &quot;网络读取数据时,即使有可用空间,也可能无法返回一个完整的IPv4数据包,包括它的头。即使在Read或ReadMsgIP可以返回一个完整数据包的情况下,这种情况也会发生。基于这个原因,如果你对接收完整的数据包很重要,建议不要使用这些方法。</target>
        </trans-unit>
        <trans-unit id="3c23c9c1e399b461c8c28a7144948fd27bdb61bb" translate="yes" xml:space="preserve">
          <source>On many Linux systems, /etc/ssl/cert.pem will contain the system wide set of root CAs in a format suitable for this function.</source>
          <target state="translated">在许多Linux系统中,/etc/ssl/cert.pem将包含系统范围内的根CA集,其格式适合该功能。</target>
        </trans-unit>
        <trans-unit id="ca1a155daae24035a913fb63720c32b8136a4b91" translate="yes" xml:space="preserve">
          <source>On non-Linux ARM, the 64-bit functions use instructions unavailable before the ARMv6k core.</source>
          <target state="translated">在非Linux ARM上,64位函数使用ARMv6k内核之前不可用的指令。</target>
        </trans-unit>
        <trans-unit id="1357e885cae46582ed3a6ff4521cb427fb02bd90" translate="yes" xml:space="preserve">
          <source>On some systems the monotonic clock will stop if the computer goes to sleep. On such a system, t.Sub(u) may not accurately reflect the actual time that passed between t and u.</source>
          <target state="translated">在某些系统中,如果计算机进入睡眠状态,单调时钟将停止。在这样的系统中,t.Sub(u)可能无法准确反映t和u之间的实际时间。</target>
        </trans-unit>
        <trans-unit id="66c05351e7478785f8f137c02ebcef5c050b614d" translate="yes" xml:space="preserve">
          <source>On the other hand, a free list maintained as part of a short-lived object is not a suitable use for a Pool, since the overhead does not amortize well in that scenario. It is more efficient to have such objects implement their own free list.</source>
          <target state="translated">另一方面,作为短命对象的一部分维护的自由列表并不适合用于Pool,因为在这种情况下,开销不能很好地摊销。让这类对象实现自己的自由列表更为有效。</target>
        </trans-unit>
        <trans-unit id="389950f4460ec73a72ec78dde5ba3b73d32c35ab" translate="yes" xml:space="preserve">
          <source>On x86-32, the 64-bit functions use instructions unavailable before the Pentium MMX.</source>
          <target state="translated">在x86-32上,64位函数使用了Pentium MMX之前不可用的指令。</target>
        </trans-unit>
        <trans-unit id="d9c768782ea8653d485fb3b7f5aba21cb2ca7bf3" translate="yes" xml:space="preserve">
          <source>Once</source>
          <target state="translated">Once</target>
        </trans-unit>
        <trans-unit id="d104fb961a8c78122b2f62dee3ef43757b182f86" translate="yes" xml:space="preserve">
          <source>Once Shutdown has been called on a server, it may not be reused; future calls to methods such as Serve will return ErrServerClosed.</source>
          <target state="translated">一旦在服务器上调用了Shutdown,它就不能被重复使用;未来对Serve等方法的调用将返回ErrServerClosed。</target>
        </trans-unit>
        <trans-unit id="843e914dc9185fa382b5f053202ed67b742aeba3" translate="yes" xml:space="preserve">
          <source>Once f returns and err is nil, the Conn will continue to be usable until Conn.Close is called.</source>
          <target state="translated">一旦f返回,err为nil,Conn将继续可用,直到Conn.Close被调用。</target>
        </trans-unit>
        <trans-unit id="0c1d5279ebafd6b3423844bd2276728e8cc52fbd" translate="yes" xml:space="preserve">
          <source>Once is an object that will perform exactly one action.</source>
          <target state="translated">Once是一个对象,它将准确地执行一个动作。</target>
        </trans-unit>
        <trans-unit id="7227e9a075a44764452a578989f4cc83bbee577f" translate="yes" xml:space="preserve">
          <source>Once parsed, a template may be executed safely in parallel, although if parallel executions share a Writer the output may be interleaved.</source>
          <target state="translated">一旦解析完毕,模板可以安全地并行执行,尽管如果并行执行共享一个Writer,输出可能会交错。</target>
        </trans-unit>
        <trans-unit id="0281f78c03be67c1f2a3acafcdaa61c0cdc49c86" translate="yes" xml:space="preserve">
          <source>One or two minus signs may be used; they are equivalent. The last form is not permitted for boolean flags because the meaning of the command</source>
          <target state="translated">可以使用一个或两个减号,它们是等价的。布尔标志不允许使用最后一种形式,因为命令的含义为</target>
        </trans-unit>
        <trans-unit id="69577389d4c08755d52755f4e17faf59267dd621" translate="yes" xml:space="preserve">
          <source>OneByteReader returns a Reader that implements each non-empty Read by reading one byte from r.</source>
          <target state="translated">OneByteReader返回一个Reader,通过从r中读取一个字节来实现每个非空的Read。</target>
        </trans-unit>
        <trans-unit id="99aaec6fa8f2d0bdb9045bd117dd6c71497e9a74" translate="yes" xml:space="preserve">
          <source>OnesCount</source>
          <target state="translated">OnesCount</target>
        </trans-unit>
        <trans-unit id="433a6ff8b314e9c198548ae00ba6fcecd1eee098" translate="yes" xml:space="preserve">
          <source>OnesCount returns the number of one bits (&quot;population count&quot;) in x.</source>
          <target state="translated">OnesCount 返回 x 中的一比特数(&quot;人口数&quot;)。</target>
        </trans-unit>
        <trans-unit id="c380e0ef7643051dda1d040515dc580f28605550" translate="yes" xml:space="preserve">
          <source>OnesCount16</source>
          <target state="translated">OnesCount16</target>
        </trans-unit>
        <trans-unit id="0999fcac9097d75e1573b11d0ffd816e52cf5855" translate="yes" xml:space="preserve">
          <source>OnesCount16 returns the number of one bits (&quot;population count&quot;) in x.</source>
          <target state="translated">OnesCount16 返回 x 中的 1 位数(&quot;人口数&quot;)。</target>
        </trans-unit>
        <trans-unit id="11a58244491d18b07e203d19e0549197d7478647" translate="yes" xml:space="preserve">
          <source>OnesCount32</source>
          <target state="translated">OnesCount32</target>
        </trans-unit>
        <trans-unit id="5f0db4433d3c95e463c6c2a1eadf16ccd1d19ea6" translate="yes" xml:space="preserve">
          <source>OnesCount32 returns the number of one bits (&quot;population count&quot;) in x.</source>
          <target state="translated">OnesCount32 返回 x 中的 1 位数(&quot;人口数&quot;)。</target>
        </trans-unit>
        <trans-unit id="f8bf5b0787d28b51c08417f12183c3a8050bbddf" translate="yes" xml:space="preserve">
          <source>OnesCount64</source>
          <target state="translated">OnesCount64</target>
        </trans-unit>
        <trans-unit id="f4aecef923e1b31d46e0ebe7b85940e72b4c07f4" translate="yes" xml:space="preserve">
          <source>OnesCount64 returns the number of one bits (&quot;population count&quot;) in x.</source>
          <target state="translated">OnesCount64 返回 x 中的 1 位数(&quot;人口数&quot;)。</target>
        </trans-unit>
        <trans-unit id="d82a2ce39ad5e48e37815f9f28a1215fe50fea08" translate="yes" xml:space="preserve">
          <source>OnesCount8</source>
          <target state="translated">OnesCount8</target>
        </trans-unit>
        <trans-unit id="cb4e53f8fd7e82903aefdeda2e2114c5812e0d65" translate="yes" xml:space="preserve">
          <source>OnesCount8 returns the number of one bits (&quot;population count&quot;) in x.</source>
          <target state="translated">OnesCount8 返回 x 中的 1 位数(&quot;人口数&quot;)。</target>
        </trans-unit>
        <trans-unit id="e2a07178400736bcb7be81ae2feca4dcd008d7f5" translate="yes" xml:space="preserve">
          <source>Only methods that satisfy these criteria will be made available for remote access; other methods will be ignored:</source>
          <target state="translated">只有满足这些标准的方法才会被提供给远程访问,其他方法将被忽略。</target>
        </trans-unit>
        <trans-unit id="f19caf46e787ec1b99d851f024d8d32d31c130ae" translate="yes" xml:space="preserve">
          <source>Only one call to Dial is necessary. On write failures, the syslog client will attempt to reconnect to the server and write again.</source>
          <target state="translated">只需要调用一次Dial。在写入失败时,syslog客户端将尝试重新连接到服务器并再次写入。</target>
        </trans-unit>
        <trans-unit id="0bb2640773cf0b724d4c0f4b422833704c7b1dde" translate="yes" xml:space="preserve">
          <source>Only some kinds of files support setting a deadline. Calls to SetDeadline for files that do not support deadlines will return ErrNoDeadline. On most systems ordinary files do not support deadlines, but pipes do.</source>
          <target state="translated">只有某些类型的文件支持设置截止日期。对于不支持截止日期的文件,调用SetDeadline会返回ErrNoDeadline。在大多数系统中,普通文件不支持截止日期,但管道支持。</target>
        </trans-unit>
        <trans-unit id="1f2bc4d6c6973cdf7add1d2aa0d072a9bc333db3" translate="yes" xml:space="preserve">
          <source>Only use this function if you require compatibility with an existing cryptosystem that uses non-standard nonce lengths. All other users should use NewGCM, which is faster and more resistant to misuse.</source>
          <target state="translated">只有当您需要与使用非标准非ce长度的现有密码系统兼容时才使用此函数。所有其他用户应该使用NewGCM,它速度更快,更能防止滥用。</target>
        </trans-unit>
        <trans-unit id="15128cc4fc0390673cf1d5ff25c809ffa9a2a0a9" translate="yes" xml:space="preserve">
          <source>Only use this function if you require compatibility with an existing cryptosystem that uses non-standard tag lengths. All other users should use NewGCM, which is more resistant to misuse.</source>
          <target state="translated">只有当您需要与使用非标准标签长度的现有密码系统兼容时,才使用此功能。所有其他用户应该使用NewGCM,它更容易被滥用。</target>
        </trans-unit>
        <trans-unit id="1b727317ee1d6f8ec7fdb2282449eaeba440af19" translate="yes" xml:space="preserve">
          <source>Op is a Porter-Duff compositing operator.</source>
          <target state="translated">Op是Porter-Duff的合成操作员。</target>
        </trans-unit>
        <trans-unit id="5af1dc92a9e2658f3244c1615c860d1105099061" translate="yes" xml:space="preserve">
          <source>OpError is the error type usually returned by functions in the net package. It describes the operation, network type, and address of an error.</source>
          <target state="translated">OpError是通常由net包中的函数返回的错误类型。它描述了错误的操作、网络类型和地址。</target>
        </trans-unit>
        <trans-unit id="18f672481765f9d884600846dfaa4fd9da765b39" translate="yes" xml:space="preserve">
          <source>Opaque scans the entire image and reports whether it is fully opaque.</source>
          <target state="translated">不透明扫描整个图像并报告是否完全不透明。</target>
        </trans-unit>
        <trans-unit id="b7443a4b74ca4cfa1bcd5bba9250ca69f1869f28" translate="yes" xml:space="preserve">
          <source>Open implements FileSystem using os.Open, opening files for reading rooted and relative to the directory d.</source>
          <target state="translated">Open使用os.Open实现FileSystem,打开根目录和相对目录d的文件进行阅读。</target>
        </trans-unit>
        <trans-unit id="6171c49e2bc16b1abb139c13c4d94d148a1c46f3" translate="yes" xml:space="preserve">
          <source>Open may just validate its arguments without creating a connection to the database. To verify that the data source name is valid, call Ping.</source>
          <target state="translated">Open可能只是验证其参数,而不创建与数据库的连接。要验证数据源名称是否有效,请调用Ping。</target>
        </trans-unit>
        <trans-unit id="5020abe2d6e35be83ee66706a97f7b42a3cce7b0" translate="yes" xml:space="preserve">
          <source>Open opens a Go plugin. If a path has already been opened, then the existing *Plugin is returned. It is safe for concurrent use by multiple goroutines.</source>
          <target state="translated">Open打开一个围棋插件,如果已经打开一个路径,则返回现有的*Plugin。如果已经打开了一个路径,则返回现有的*Plugin。它对多个goroutine的并发使用是安全的。</target>
        </trans-unit>
        <trans-unit id="66a147f16950427bc220b36b7335c4430f2e435a" translate="yes" xml:space="preserve">
          <source>Open opens a database specified by its database driver name and a driver-specific data source name, usually consisting of at least a database name and connection information.</source>
          <target state="translated">Open打开由其数据库驱动程序名称和特定驱动程序的数据源名称指定的数据库,通常至少由数据库名称和连接信息组成。</target>
        </trans-unit>
        <trans-unit id="37d7b9b7fb804765c0c890c3a9927f5e792e10c2" translate="yes" xml:space="preserve">
          <source>Open opens and returns the FileHeader's associated File.</source>
          <target state="translated">打开并返回FileHeader的相关文件。</target>
        </trans-unit>
        <trans-unit id="9f531c4cd3491cbb25cd300045e949a3c6a2f783" translate="yes" xml:space="preserve">
          <source>Open opens the named file for reading. If successful, methods on the returned file can be used for reading; the associated file descriptor has mode O_RDONLY. If there is an error, it will be of type *PathError.</source>
          <target state="translated">Open打开命名的文件进行读取。如果成功,返回的文件上的方法可以用于读取;相关文件描述符的模式为O_RDONLY。如果出现错误,将是*PathError类型。</target>
        </trans-unit>
        <trans-unit id="371cc608c2ba1c0990eaf9fb6894bbf2a52158f7" translate="yes" xml:space="preserve">
          <source>Open opens the named file using os.Open and prepares it for use as a Mach-O binary.</source>
          <target state="translated">Open 使用 os.Open 打开命名的文件,并准备将其作为 Mach-O 二进制文件使用。</target>
        </trans-unit>
        <trans-unit id="7d04ca361fd4f73d2b0f9d528191bbbad4f3caa9" translate="yes" xml:space="preserve">
          <source>Open opens the named file using os.Open and prepares it for use as a PE binary.</source>
          <target state="translated">Open 使用 os.Open 打开命名的文件,并准备将其作为 PE 二进制文件使用。</target>
        </trans-unit>
        <trans-unit id="401e69358b39b00234c49cca571dfb25656931d2" translate="yes" xml:space="preserve">
          <source>Open opens the named file using os.Open and prepares it for use as a Plan 9 a.out binary.</source>
          <target state="translated">Open 使用 os.Open 打开命名的文件,并准备将其作为 Plan 9 a.out 二进制文件使用。</target>
        </trans-unit>
        <trans-unit id="9b1194bbc276659f78fdca3adfdc9b10d19c8660" translate="yes" xml:space="preserve">
          <source>Open opens the named file using os.Open and prepares it for use as an ELF binary.</source>
          <target state="translated">Open 使用 os.Open 打开命名的文件,并准备将其作为 ELF 二进制文件使用。</target>
        </trans-unit>
        <trans-unit id="f50055a1ded1f305ba4233bb037ec0d820624aa9" translate="yes" xml:space="preserve">
          <source>Open returns a ReadCloser that provides access to the File's contents. Multiple files may be read concurrently.</source>
          <target state="translated">Open返回一个ReadCloser,提供对文件内容的访问。可以同时读取多个文件。</target>
        </trans-unit>
        <trans-unit id="dc15ea0e79b5a5fd3585bbb7eb793bc7927e0c43" translate="yes" xml:space="preserve">
          <source>Open returns a new ReadSeeker reading the ELF program body.</source>
          <target state="translated">Open返回一个新的读取ELF程序体的ReadSeeker。</target>
        </trans-unit>
        <trans-unit id="cb2948f8796f4e20787b4c3d93aa97d5e5dd5298" translate="yes" xml:space="preserve">
          <source>Open returns a new ReadSeeker reading the ELF section. Even if the section is stored compressed in the ELF file, the ReadSeeker reads uncompressed data.</source>
          <target state="translated">Open返回一个新的ReadSeeker,读取ELF部分。即使ELF文件中存储的是压缩的部分,ReadSeeker也会读取未压缩的数据。</target>
        </trans-unit>
        <trans-unit id="21b5b726e4f4ade0871cc002a3334fa728428adc" translate="yes" xml:space="preserve">
          <source>Open returns a new ReadSeeker reading the Mach-O section.</source>
          <target state="translated">Open返回一个新的读取Mach-O部分的ReadSeeker。</target>
        </trans-unit>
        <trans-unit id="b61efb693d7cf70cb90d5aedf0d5a372c5aa6512" translate="yes" xml:space="preserve">
          <source>Open returns a new ReadSeeker reading the PE section s.</source>
          <target state="translated">Open返回一个新的读取PE段s的ReadSeeker。</target>
        </trans-unit>
        <trans-unit id="84fc1af6d68e3cc755958db236fc07677794c372" translate="yes" xml:space="preserve">
          <source>Open returns a new ReadSeeker reading the Plan 9 a.out section.</source>
          <target state="translated">Open返回一个新的读取Plan 9 a.out部分的ReadSeeker。</target>
        </trans-unit>
        <trans-unit id="387b57706c30c22b6f03a484c6bd4b511d83f9ce" translate="yes" xml:space="preserve">
          <source>Open returns a new ReadSeeker reading the segment.</source>
          <target state="translated">Open返回一个新的读取段的ReadSeeker。</target>
        </trans-unit>
        <trans-unit id="1007daa5b98f8257c13edf3ea065301dd1ebaf2b" translate="yes" xml:space="preserve">
          <source>OpenDB may just validate its arguments without creating a connection to the database. To verify that the data source name is valid, call Ping.</source>
          <target state="translated">OpenDB可能只是验证其参数,而不创建与数据库的连接。要验证数据源名称是否有效,请调用Ping。</target>
        </trans-unit>
        <trans-unit id="25e1b5a42de4942dfe6b4bfced8324ba7ad01162" translate="yes" xml:space="preserve">
          <source>OpenDB opens a database using a Connector, allowing drivers to bypass a string based data source name.</source>
          <target state="translated">OpenDB使用Connector打开数据库,允许驱动程序绕过基于字符串的数据源名称。</target>
        </trans-unit>
        <trans-unit id="02205221603211c0f70a26822c2a5ea1275e3176" translate="yes" xml:space="preserve">
          <source>OpenFat opens the named file using os.Open and prepares it for use as a Mach-O universal binary.</source>
          <target state="translated">OpenFat 使用 os.Open 打开命名的文件,并准备将其作为 Mach-O 通用二进制文件使用。</target>
        </trans-unit>
        <trans-unit id="f89511e6449f4d72c17e5b2730171b3d593b5ed7" translate="yes" xml:space="preserve">
          <source>OpenFile</source>
          <target state="translated">OpenFile</target>
        </trans-unit>
        <trans-unit id="0c82063df1128e3daff7e360a09afecb32d7114a" translate="yes" xml:space="preserve">
          <source>OpenFile (Append)</source>
          <target state="translated">OpenFile (Append)</target>
        </trans-unit>
        <trans-unit id="4fc4a091591f11a5786d39de5a16c7ed7ce1eeab" translate="yes" xml:space="preserve">
          <source>OpenFile is the generalized open call; most users will use Open or Create instead. It opens the named file with specified flag (O_RDONLY etc.). If the file does not exist, and the O_CREATE flag is passed, it is created with mode perm (before umask). If successful, methods on the returned File can be used for I/O. If there is an error, it will be of type *PathError.</source>
          <target state="translated">OpenFile是通用的打开调用;大多数用户会使用Open或Create来代替。它用指定的标志(O_RDONLY等)打开命名的文件。如果文件不存在,并且传递了O_CREATE标志,则用perm模式(在umask之前)创建文件。如果成功,返回的File上的方法可以用于I/O。如果有一个错误,它的类型将是*PathError。</target>
        </trans-unit>
        <trans-unit id="154227f07677e156add449cf112307bf838866a9" translate="yes" xml:space="preserve">
          <source>OpenReader will open the Zip file specified by name and return a ReadCloser.</source>
          <target state="translated">OpenReader将打开由名称指定的Zip文件,并返回一个ReadCloser。</target>
        </trans-unit>
        <trans-unit id="6cbb449ad00bd956208ebf3bc7a9b2a9d9466e94" translate="yes" xml:space="preserve">
          <source>Operating systems provide both a &amp;ldquo;wall clock,&amp;rdquo; which is subject to changes for clock synchronization, and a &amp;ldquo;monotonic clock,&amp;rdquo; which is not. The general rule is that the wall clock is for telling time and the monotonic clock is for measuring time. Rather than split the API, in this package the Time returned by time.Now contains both a wall clock reading and a monotonic clock reading; later time-telling operations use the wall clock reading, but later time-measuring operations, specifically comparisons and subtractions, use the monotonic clock reading.</source>
          <target state="translated">操作系统同时提供&amp;ldquo;挂钟&amp;rdquo;和&amp;ldquo;单调时钟&amp;rdquo;，&amp;ldquo;挂钟&amp;rdquo;会随时钟同步的变化而变化。一般规则是壁钟用于指示时间，单调时钟用于测量时间。在该程序包中，不是拆分API，而是按时间返回时间。现在，它既包含挂钟读数又包含单调时钟读数。以后的计时操作将使用挂钟读数，但以后的时间测量操作（尤其是比较和减法）将使用单调时钟读数。</target>
        </trans-unit>
        <trans-unit id="f30cabbd8e785b594ba56b3801fd9d4f1260078a" translate="yes" xml:space="preserve">
          <source>Operations always take pointer arguments (*Float) rather than Float values, and each unique Float value requires its own unique *Float pointer. To &quot;copy&quot; a Float value, an existing (or newly allocated) Float must be set to a new value using the Float.Set method; shallow copies of Floats are not supported and may lead to errors.</source>
          <target state="translated">操作总是取指针参数(*Float)而不是Float值,每个唯一的Float值都需要自己唯一的*Float指针。要 &quot;复制 &quot;一个Float值,必须使用Float.Set方法将一个现有的(或新分配的)Float设置为一个新的值;不支持Float的浅层复制,并可能导致错误。</target>
        </trans-unit>
        <trans-unit id="b1165d6e4bac8282c929350a1919aee2062c5958" translate="yes" xml:space="preserve">
          <source>Operations always take pointer arguments (*Int) rather than Int values, and each unique Int value requires its own unique *Int pointer. To &quot;copy&quot; an Int value, an existing (or newly allocated) Int must be set to a new value using the Int.Set method; shallow copies of Ints are not supported and may lead to errors.</source>
          <target state="translated">操作总是取指针参数(*Int)而不是Int值,每个唯一的Int值都需要它自己唯一的*Int指针。要 &quot;复制 &quot;一个Int值,必须使用Int.Set方法将一个现有的(或新分配的)Int设置为一个新的值;不支持对Ints的浅层复制,并可能导致错误。</target>
        </trans-unit>
        <trans-unit id="be2237e984f46419a4f93c71fc7a1e90b45fca20" translate="yes" xml:space="preserve">
          <source>Operations always take pointer arguments (*Rat) rather than Rat values, and each unique Rat value requires its own unique *Rat pointer. To &quot;copy&quot; a Rat value, an existing (or newly allocated) Rat must be set to a new value using the Rat.Set method; shallow copies of Rats are not supported and may lead to errors.</source>
          <target state="translated">操作总是采取指针参数(*Rat)而不是Rat值,每个独特的Rat值需要它自己独特的*Rat指针。要 &quot;复制 &quot;一个Rat值,必须使用Rat.Set方法将一个现有的(或新分配的)Rat设置为一个新的值;不支持Rat的浅层复制,并可能导致错误。</target>
        </trans-unit>
        <trans-unit id="5ff98727eb74457bb348de0295d7fc660d04eb4a" translate="yes" xml:space="preserve">
          <source>Operations to set or modify these public variables are atomic.</source>
          <target state="translated">设置或修改这些公共变量的操作是原子的。</target>
        </trans-unit>
        <trans-unit id="a344aa2f0644d620585ef6109d1a2e6c58d16a89" translate="yes" xml:space="preserve">
          <source>Option sets options for the template. Options are described by strings, either a simple string or &quot;key=value&quot;. There can be at most one equals sign in an option string. If the option string is unrecognized or otherwise invalid, Option panics.</source>
          <target state="translated">Option设置模板的选项。选项用字符串来描述,可以是简单的字符串,也可以是 &quot;key=value&quot;。一个选项字符串中最多只能有一个等号。如果选项字符串未被识别或无效,Option就会崩溃。</target>
        </trans-unit>
        <trans-unit id="22bdd06043dd23aedf196f8c5aa67a749424f26f" translate="yes" xml:space="preserve">
          <source>Options are the encoding parameters.</source>
          <target state="translated">选项是编码参数。</target>
        </trans-unit>
        <trans-unit id="2ae1ba4c5551ccfa17f3cc4234e6c983b6c4a751" translate="yes" xml:space="preserve">
          <source>Options are the encoding parameters. Quality ranges from 1 to 100 inclusive, higher is better.</source>
          <target state="translated">选项是编码参数。质量范围从1到100(含),越高越好。</target>
        </trans-unit>
        <trans-unit id="3574245ef01db27c04b70bab947169f3717705e6" translate="yes" xml:space="preserve">
          <source>Options are the options for creating a new Jar.</source>
          <target state="translated">选项是创建新Jar的选项。</target>
        </trans-unit>
        <trans-unit id="adec537139c73f02b553920372adc3c02c28272e" translate="yes" xml:space="preserve">
          <source>Or sets z = x | y and returns z.</source>
          <target state="translated">或者设置z=x | y并返回z。</target>
        </trans-unit>
        <trans-unit id="1b4b94d1371289b3526620aa944ef691c23c5e97" translate="yes" xml:space="preserve">
          <source>Or to collect a 5-second execution trace:</source>
          <target state="translated">或者收集5秒的执行跟踪。</target>
        </trans-unit>
        <trans-unit id="50c67b4d826544d33e4676d47eb11f1c27fb8432" translate="yes" xml:space="preserve">
          <source>Or to look at a 30-second CPU profile:</source>
          <target state="translated">或者看一下30秒的CPU曲线。</target>
        </trans-unit>
        <trans-unit id="b615664e9607d56a174a9eae8d3c5a2c6e80bd6a" translate="yes" xml:space="preserve">
          <source>Or to look at the goroutine blocking profile, after calling runtime.SetBlockProfileRate in your program:</source>
          <target state="translated">或者在程序中调用runtime.SetBlockProfileRate后,看看goroutine阻塞配置文件。</target>
        </trans-unit>
        <trans-unit id="9e825dc80cfaf2eaa80db6ce23de3b3fc8a8346c" translate="yes" xml:space="preserve">
          <source>Or to look at the holders of contended mutexes, after calling runtime.SetMutexProfileFraction in your program:</source>
          <target state="translated">或者在程序中调用runtime.SetMutexProfileFraction后,查看争用的mutexes的持有者。</target>
        </trans-unit>
        <trans-unit id="8ab86bd1259ac4f40dd163dea09a395538c7b9f8" translate="yes" xml:space="preserve">
          <source>Or you can create custom flags that satisfy the Value interface (with pointer receivers) and couple them to flag parsing by</source>
          <target state="translated">或者你可以创建满足Value接口的自定义标志(带有指针接收器),并通过以下方式将它们与标志解析结合起来</target>
        </trans-unit>
        <trans-unit id="9e10a8547b0d36316e030b08eda98a7d2a3b8233" translate="yes" xml:space="preserve">
          <source>Order specifies the bit ordering in an LZW data stream.</source>
          <target state="translated">顺序指定LZW数据流中的位顺序。</target>
        </trans-unit>
        <trans-unit id="5cbea92714ef396bc3e8932074a0396b90c6e75c" translate="yes" xml:space="preserve">
          <source>Other ASN.1 types are not supported; if it encounters them, Unmarshal returns a parse error.</source>
          <target state="translated">不支持其他ASN.1类型;如果遇到这些类型,Unmarshal会返回一个解析错误。</target>
        </trans-unit>
        <trans-unit id="7ba1580fd9fc904fa02322480bcec7e07c54f2cc" translate="yes" xml:space="preserve">
          <source>Other definitions of spacing characters are set by category Z and property Pattern_White_Space.</source>
          <target state="translated">其他间距字符的定义由类别Z和属性Pattern_White_Space设置。</target>
        </trans-unit>
        <trans-unit id="b7a56a76d64dcdb6eb16b696315251945b43a236" translate="yes" xml:space="preserve">
          <source>Other flags:</source>
          <target state="translated">其他旗帜:</target>
        </trans-unit>
        <trans-unit id="bd1405bb0e6eee6e420fe2dfb40f43a986aa8880" translate="yes" xml:space="preserve">
          <source>Other idioms, such as time.Since(start), time.Until(deadline), and time.Now().Before(deadline), are similarly robust against wall clock resets.</source>
          <target state="translated">其他成语,如time.Since(start)、time.Until(deadline)和time.Now().Before(deadline),对挂钟重设也有类似的健壮性。</target>
        </trans-unit>
        <trans-unit id="aa4d97b3571d62fa73ceb918bc9a47b9937e01e1" translate="yes" xml:space="preserve">
          <source>Other packages</source>
          <target state="translated">其他配套</target>
        </trans-unit>
        <trans-unit id="e7cf6fa65416b27793d90a051b00b5c18e902844" translate="yes" xml:space="preserve">
          <source>Other values - numbers, bools, strings, and channels - are deeply equal if they are equal using Go's == operator.</source>
          <target state="translated">其他值--数字、bool、字符串和通道--如果使用围棋的==运算符相等,那么它们就会深度相等。</target>
        </trans-unit>
        <trans-unit id="68cac93271438e6498e5c369aaaa0b2b44f4aa36" translate="yes" xml:space="preserve">
          <source>Otherwise Context will be a value previously returned by a call to the context function. The traceback function should gather a stack trace from that saved point in the program execution. The traceback function may be called from an execution thread other than the one that recorded the context, but only when the context is known to be valid and unchanging. The traceback function may also be called deeper in the call stack on the same thread that recorded the context. The traceback function may be called multiple times with the same Context value; it will usually be appropriate to cache the result, if possible, the first time this is called for a specific context value.</source>
          <target state="translated">否则Context将是之前调用context函数返回的值。回溯函数应该收集程序执行中那个保存点的堆栈跟踪。回溯函数可以从记录上下文的线程以外的执行线程中调用,但只有当上下文是有效的并且没有变化的时候才可以调用。回溯函数也可以在记录上下文的同一线程的调用堆栈的更深处被调用。回溯函数可以用同一个Context值被多次调用;如果可能的话,通常在第一次调用一个特定的上下文值时,将结果缓存起来是合适的。</target>
        </trans-unit>
        <trans-unit id="440873215b88a6b8697d85d1d64d02df4a4da93f" translate="yes" xml:space="preserve">
          <source>Otherwise, Marshal uses the following type-dependent default encodings:</source>
          <target state="translated">否则,Marshal使用以下类型相关的默认编码。</target>
        </trans-unit>
        <trans-unit id="23286c7a365f916cfdea50d5123a3b0bcae1d4f3" translate="yes" xml:space="preserve">
          <source>Otherwise, the Scanner advances the input. If the token is not nil, the Scanner returns it to the user. If the token is nil, the Scanner reads more data and continues scanning; if there is no more data--if atEOF was true--the Scanner returns. If the data does not yet hold a complete token, for instance if it has no newline while scanning lines, a SplitFunc can return (0, nil, nil) to signal the Scanner to read more data into the slice and try again with a longer slice starting at the same point in the input.</source>
          <target state="translated">否则,扫描器将推进输入。如果token不是零,扫描器将其返回给用户。如果标记为零,扫描器读取更多数据并继续扫描;如果没有更多数据--如果 atEOF 为真,扫描器返回。如果数据中还没有完整的标记,例如在扫描行时没有换行,SplitFunc可以返回(0,nil,nil),提示扫描器读取更多的数据到分片中,并从输入的相同点开始,用更长的分片再次尝试。</target>
        </trans-unit>
        <trans-unit id="c58abb3a56ad02906deb5ed411e41c1942d916f5" translate="yes" xml:space="preserve">
          <source>Otherwise, the name is taken to be a location name corresponding to a file in the IANA Time Zone database, such as &quot;America/New_York&quot;.</source>
          <target state="translated">否则,取名为与IANA时区数据库中的文件对应的位置名,如 &quot;America/New_York&quot;。</target>
        </trans-unit>
        <trans-unit id="074d0906fc55c8d6c513fa44707b8b377c627c79" translate="yes" xml:space="preserve">
          <source>Out may be used to retrieve OUTPUT value parameters from stored procedures.</source>
          <target state="translated">Out可用于从存储过程中检索OUTPUT值参数。</target>
        </trans-unit>
        <trans-unit id="62f29f77d6256848fed5f348aeadebd7d0572e5e" translate="yes" xml:space="preserve">
          <source>Output returns the destination for usage and error messages. os.Stderr is returned if output was not set or was set to nil.</source>
          <target state="translated">如果output没有设置或设置为nil,则返回os.Stderr。</target>
        </trans-unit>
        <trans-unit id="e449133aa4e97be80abdfc0c46f50787b1e6cc66" translate="yes" xml:space="preserve">
          <source>Output runs the command and returns its standard output. Any returned error will usually be of type *ExitError. If c.Stderr was nil, Output populates ExitError.Stderr.</source>
          <target state="translated">Output运行命令并返回其标准输出。任何返回的错误通常都是*ExitError类型的。如果c.Stderr为nil,Output会填充ExitError.Stderr。</target>
        </trans-unit>
        <trans-unit id="7ecc8307c727787c0796f59aebc9997243dec020" translate="yes" xml:space="preserve">
          <source>Output writes the output for a logging event. The string s contains the text to print after the prefix specified by the flags of the Logger. A newline is appended if the last character of s is not already a newline. Calldepth is the count of the number of frames to skip when computing the file name and line number if Llongfile or Lshortfile is set; a value of 1 will print the details for the caller of Output.</source>
          <target state="translated">输出写出一个日志事件的输出。字符串 s 包含要打印的文本,位于日志记录器的标志指定的前缀之后。如果s的最后一个字符不是换行符,则会附加一个换行符。Calldepth是指如果设置了Llongfile或Lshortfile,在计算文件名和行号时要跳过的帧数;值为1时,将为Output的调用者打印详细信息。</target>
        </trans-unit>
        <trans-unit id="c217d8994a3f1426d43eb0166f8c3a35d6d34515" translate="yes" xml:space="preserve">
          <source>Output writes the output for a logging event. The string s contains the text to print after the prefix specified by the flags of the Logger. A newline is appended if the last character of s is not already a newline. Calldepth is used to recover the PC and is provided for generality, although at the moment on all pre-defined paths it will be 2.</source>
          <target state="translated">输出写出一个日志事件的输出。字符串 s 包含要打印的文本,位于日志记录器的标志指定的前缀之后。如果s的最后一个字符不是换行符,则会附加一个换行符。Calldepth用于恢复PC,是为了通用性而提供的,尽管目前在所有预定义的路径上都是2。</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="4fa36fa9b33d97810f39e28fc36e995589f3d560" translate="yes" xml:space="preserve">
          <source>Output: &quot;ZgotmplZ&quot; Example:</source>
          <target state="translated">输出。&quot;ZgotmplZ&quot; 示例:</target>
        </trans-unit>
        <trans-unit id="75e718b4932f1994826e9ab2559b67ffd1e17df7" translate="yes" xml:space="preserve">
          <source>Outside of those two special cases, ServeFile does not use r.URL.Path for selecting the file or directory to serve; only the file or directory provided in the name argument is used.</source>
          <target state="translated">除了这两种特殊情况外,ServeFile不使用r.URL.Path来选择要服务的文件或目录,只使用name参数中提供的文件或目录。</target>
        </trans-unit>
        <trans-unit id="c3a7fdb472ac14ee470a8708bdbde30a747ecc04" translate="yes" xml:space="preserve">
          <source>OverflowComplex reports whether the complex128 x cannot be represented by v's type. It panics if v's Kind is not Complex64 or Complex128.</source>
          <target state="translated">OverflowComplex报告复数128的x是否不能由v的类型表示。如果v的类型不是Complex64或Complex128,它就会恐慌。</target>
        </trans-unit>
        <trans-unit id="b0ed609ef26db1230ec310f05f6a41e74b4a279d" translate="yes" xml:space="preserve">
          <source>OverflowFloat reports whether the float64 x cannot be represented by v's type. It panics if v's Kind is not Float32 or Float64.</source>
          <target state="translated">OverflowFloat报告float64 x是否不能用v的类型表示。如果v的类型不是Float32或Float64,它就会恐慌。</target>
        </trans-unit>
        <trans-unit id="7200bfe476f81acadc4a0ccf748e1684d1005b1a" translate="yes" xml:space="preserve">
          <source>OverflowInt reports whether the int64 x cannot be represented by v's type. It panics if v's Kind is not Int, Int8, Int16, Int32, or Int64.</source>
          <target state="translated">OverflowInt报告int64 x是否不能用v的类型来表示,如果v的类型不是Int、Int8、Int16、Int32或Int64,它就会恐慌。如果v的类型不是Int、Int8、Int16、Int32或Int64,它就会恐慌。</target>
        </trans-unit>
        <trans-unit id="2b4b5d40028c4ba9e1027f58dcb6f18125d975d5" translate="yes" xml:space="preserve">
          <source>OverflowUint reports whether the uint64 x cannot be represented by v's type. It panics if v's Kind is not Uint, Uintptr, Uint8, Uint16, Uint32, or Uint64.</source>
          <target state="translated">OverflowUint报告uint64 x是否不能由v的类型来表示,如果v的类型不是Uint,Uintptr,Uint8,Uint16,Uint32,或Uint64,它就会恐慌。如果v的类型不是Uint、Uintptr、Uint8、Uint16、Uint32或Uint64,它就会恐慌。</target>
        </trans-unit>
        <trans-unit id="2f7f8328b596e3ddecd6faa4ad494433682975d9" translate="yes" xml:space="preserve">
          <source>Overlaps reports whether r and s have a non-empty intersection.</source>
          <target state="translated">重叠报告r和s是否有一个非空的交点。</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="540bc829190ced5e9ba3735dc9ac84a0059b79f4" translate="yes" xml:space="preserve">
          <source>P224 returns a Curve which implements P-224 (see FIPS 186-3, section D.2.2).</source>
          <target state="translated">P224返回一个实现P-224的曲线(见FIPS 186-3,D.2.2节)。</target>
        </trans-unit>
        <trans-unit id="f9ccdfec57f69f0c0af7d347e1e194be5e3da78a" translate="yes" xml:space="preserve">
          <source>P256 returns a Curve which implements P-256 (see FIPS 186-3, section D.2.3)</source>
          <target state="translated">P256 返回一个实现 P-256 的曲线(见 FIPS 186-3,D.2.3 节)。</target>
        </trans-unit>
        <trans-unit id="0d2178f68bbde9fa3217033c113d8df97da47a28" translate="yes" xml:space="preserve">
          <source>P384 returns a Curve which implements P-384 (see FIPS 186-3, section D.2.4)</source>
          <target state="translated">P384返回一个实现P-384的曲线(见FIPS 186-3,D.2.4节)。</target>
        </trans-unit>
        <trans-unit id="c9a508dd7c665008acf0e38e607e3196bfcd6cf9" translate="yes" xml:space="preserve">
          <source>P521 returns a Curve which implements P-521 (see FIPS 186-3, section D.2.5)</source>
          <target state="translated">P521返回一个实现P-521的曲线(见FIPS 186-3,D.2.5节)。</target>
        </trans-unit>
        <trans-unit id="39161099723c9e406b69587afd22627144ad7720" translate="yes" xml:space="preserve">
          <source>PCToFunc returns the function containing the program counter pc, or nil if there is no such function.</source>
          <target state="translated">PCToFunc返回包含程序计数器pc的函数,如果没有这个函数,则返回nil。</target>
        </trans-unit>
        <trans-unit id="aabe0db5b758e9cbc954a1f7a208c14d080cb6c6" translate="yes" xml:space="preserve">
          <source>PCToLine looks up line number information for a program counter. If there is no information, it returns fn == nil.</source>
          <target state="translated">PCToLine查找程序计数器的行号信息。如果没有信息,则返回fn ==nil。</target>
        </trans-unit>
        <trans-unit id="841d78ecc2d24b8758f6afc447a9a64df99960bb" translate="yes" xml:space="preserve">
          <source>PCToLine returns the line number for the given program counter.</source>
          <target state="translated">PCToLine返回给定程序计数器的行号。</target>
        </trans-unit>
        <trans-unit id="d8139323c6d19479f54e5ea9ba69d4546948a8d4" translate="yes" xml:space="preserve">
          <source>PKCS1v15DecrypterOpts is for passing options to PKCS#1 v1.5 decryption using the crypto.Decrypter interface.</source>
          <target state="translated">PKCS1v15DecrypterOpts是用于向使用crypto.Decrypter接口的PKCS#1 v1.5解密传递选项。</target>
        </trans-unit>
        <trans-unit id="3010ccb1954efdb7b7065a86234a1d7d460fba48" translate="yes" xml:space="preserve">
          <source>PSSOptions contains options for creating and verifying PSS signatures.</source>
          <target state="translated">PSSOptions包含创建和验证PSS签名的选项。</target>
        </trans-unit>
        <trans-unit id="7431e3df243c5be33cffa0b28ca2a76b93f0538c" translate="yes" xml:space="preserve">
          <source>Package</source>
          <target state="translated">Package</target>
        </trans-unit>
        <trans-unit id="6de038894baa09edba875dcb5414f5284bdf18fd" translate="yes" xml:space="preserve">
          <source>Package (Autoescaping)</source>
          <target state="translated">包装(自动剪枝)</target>
        </trans-unit>
        <trans-unit id="efd760e5022b210b4ab3b28e3b7050f4cfe5597a" translate="yes" xml:space="preserve">
          <source>Package (Basic)</source>
          <target state="translated">套餐(基本)</target>
        </trans-unit>
        <trans-unit id="2f75473a87f737dac84d4da0d9f9f7e3db9e0c4a" translate="yes" xml:space="preserve">
          <source>Package (BinaryMarshaler)</source>
          <target state="translated">包(BinaryMarshaler)</target>
        </trans-unit>
        <trans-unit id="521cf6815d29f653ce707f251cb067182d8071f5" translate="yes" xml:space="preserve">
          <source>Package (ComplexNumbers)</source>
          <target state="translated">包(复数)</target>
        </trans-unit>
        <trans-unit id="f1ea6c4ac2e70daab523cce5ae048f3dea0d83bb" translate="yes" xml:space="preserve">
          <source>Package (CustomMarshalJSON)</source>
          <target state="translated">包(CustomMarshalJSON)</target>
        </trans-unit>
        <trans-unit id="53c1354bffac6774daf658fbd5e85b47d709a40a" translate="yes" xml:space="preserve">
          <source>Package (CustomMarshalXML)</source>
          <target state="translated">包(CustomMarshalXML)</target>
        </trans-unit>
        <trans-unit id="bf806559bf4e10f3c8039c45350fd1cd892af724" translate="yes" xml:space="preserve">
          <source>Package (DecodeConfig)</source>
          <target state="translated">包(DecodeConfig)</target>
        </trans-unit>
        <trans-unit id="5c13dd8a74667052e5635f9f7455a54e1f9be1f3" translate="yes" xml:space="preserve">
          <source>Package (Dictionary)</source>
          <target state="translated">包(词典)</target>
        </trans-unit>
        <trans-unit id="fcafbcc962aec3c3d83b146b18f61ef5463aef43" translate="yes" xml:space="preserve">
          <source>Package (EConvergents)</source>
          <target state="translated">包(EConvergents)</target>
        </trans-unit>
        <trans-unit id="71630f752f5d0a16ab8b1a3c38461b76d37e5fed" translate="yes" xml:space="preserve">
          <source>Package (Elastic)</source>
          <target state="translated">包装(弹性)</target>
        </trans-unit>
        <trans-unit id="3dc381377e54ebe3f92f7916ec8fdf96578a8e4b" translate="yes" xml:space="preserve">
          <source>Package (EncodeDecode)</source>
          <target state="translated">包(EncodeDecode)</target>
        </trans-unit>
        <trans-unit id="252573860775d14759f48467c37c1fc311083728" translate="yes" xml:space="preserve">
          <source>Package (Escape)</source>
          <target state="translated">包裹(逃生)</target>
        </trans-unit>
        <trans-unit id="25f707cfdaffe7b9a529ff95591583c8c03bc6af" translate="yes" xml:space="preserve">
          <source>Package (Fibonacci)</source>
          <target state="translated">包(斐波那契)</target>
        </trans-unit>
        <trans-unit id="338a17f2623ba97dc73fc6452b147c9a5a0e8298" translate="yes" xml:space="preserve">
          <source>Package (Formats)</source>
          <target state="translated">包装(格式)</target>
        </trans-unit>
        <trans-unit id="426c20e3d54491dcaa33e4dd0bebe004b79c0135" translate="yes" xml:space="preserve">
          <source>Package (IntHeap)</source>
          <target state="translated">包(IntHeap)</target>
        </trans-unit>
        <trans-unit id="0c999d293b130996c88c6f0ebf97cfecc7e78201" translate="yes" xml:space="preserve">
          <source>Package (Interface)</source>
          <target state="translated">包装(接口)</target>
        </trans-unit>
        <trans-unit id="dd11444f3f52c88a7e33585300bd5ea9526ef9c4" translate="yes" xml:space="preserve">
          <source>Package (Is)</source>
          <target state="translated">包装(是)</target>
        </trans-unit>
        <trans-unit id="24d024864b73227ebe67578e60455dbd5c73297f" translate="yes" xml:space="preserve">
          <source>Package (IsIdentRune)</source>
          <target state="translated">包(IsIdentRune)</target>
        </trans-unit>
        <trans-unit id="748caafd5bbe2c55ebabfb05417c48bc6922ffcf" translate="yes" xml:space="preserve">
          <source>Package (Minimal)</source>
          <target state="translated">包裹(最小值)</target>
        </trans-unit>
        <trans-unit id="4c4a86eeb8002b47d70510d7c23e7eb0eeebd8db" translate="yes" xml:space="preserve">
          <source>Package (Mode)</source>
          <target state="translated">包装(模式)</target>
        </trans-unit>
        <trans-unit id="be479fe7812a33e53549975551961ada92e137a5" translate="yes" xml:space="preserve">
          <source>Package (OpenDBCLI)</source>
          <target state="translated">包(OpenDBCLI)</target>
        </trans-unit>
        <trans-unit id="afacd609e03942d0e0a9efefefa3cc27d29c774c" translate="yes" xml:space="preserve">
          <source>Package (OpenDBService)</source>
          <target state="translated">包(OpenDBService)</target>
        </trans-unit>
        <trans-unit id="867dd5ed3ca2062c464faebd1a831d2ea55231a1" translate="yes" xml:space="preserve">
          <source>Package (Printers)</source>
          <target state="translated">包装(打印机)</target>
        </trans-unit>
        <trans-unit id="944f7ea8e45283f6aee9c663f196d84201347430" translate="yes" xml:space="preserve">
          <source>Package (PriorityQueue)</source>
          <target state="translated">包(PriorityQueue)</target>
        </trans-unit>
        <trans-unit id="e76c0b4be64237d4de2b6bc5f73a9204c1c70fde" translate="yes" xml:space="preserve">
          <source>Package (Rand)</source>
          <target state="translated">包裹(兰特)</target>
        </trans-unit>
        <trans-unit id="a8e65e58fc97f49428772dd3c9910ec49b3603a7" translate="yes" xml:space="preserve">
          <source>Package (Reset)</source>
          <target state="translated">包装(复位)</target>
        </trans-unit>
        <trans-unit id="0676e5f7c44f1428abe1688347a4a67985619798" translate="yes" xml:space="preserve">
          <source>Package (RetrievePositionInfo)</source>
          <target state="translated">包(RetrievePositionInfo)</target>
        </trans-unit>
        <trans-unit id="3918e789c00aa71d83a0d25f288c82afb2e9dc19" translate="yes" xml:space="preserve">
          <source>Package (SortKeys)</source>
          <target state="translated">包(SortKeys)</target>
        </trans-unit>
        <trans-unit id="fc31bf6d702c41d4e65fa2c8464a648d0253335d" translate="yes" xml:space="preserve">
          <source>Package (SortMultiKeys)</source>
          <target state="translated">包 (SortMultiKeys)</target>
        </trans-unit>
        <trans-unit id="be587b9c8d7d28588b076a30e4390f166b763389" translate="yes" xml:space="preserve">
          <source>Package (SortWrapper)</source>
          <target state="translated">包(SortWrapper)</target>
        </trans-unit>
        <trans-unit id="039d4d77bcfce9ea65f0437ee2733cacb35d30d2" translate="yes" xml:space="preserve">
          <source>Package (Sqrt2)</source>
          <target state="translated">包(Sqrt2)</target>
        </trans-unit>
        <trans-unit id="978d6874fbbc2bbed5f65358c7eadec1499de368" translate="yes" xml:space="preserve">
          <source>Package (Synchronization)</source>
          <target state="translated">包(同步)</target>
        </trans-unit>
        <trans-unit id="d74eef6782bc61ea34233345eec7439ddb2209f0" translate="yes" xml:space="preserve">
          <source>Package (TextMarshalJSON)</source>
          <target state="translated">包(TextMarshalJSON)</target>
        </trans-unit>
        <trans-unit id="00ea20ac0a3062f6e781d5f03ac4f931f7e664e0" translate="yes" xml:space="preserve">
          <source>Package (TextMarshalXML)</source>
          <target state="translated">包(TextMarshalXML)</target>
        </trans-unit>
        <trans-unit id="9d3479f34953d267211484567770a976cf5f7423" translate="yes" xml:space="preserve">
          <source>Package (TrailingTab)</source>
          <target state="translated">包(尾部标签)</target>
        </trans-unit>
        <trans-unit id="db41f4bcaa84e2ad0f8ea9b730005966564c99d0" translate="yes" xml:space="preserve">
          <source>Package (Whitespace)</source>
          <target state="translated">包装(空白)</target>
        </trans-unit>
        <trans-unit id="3fb9a413fc3704254de1eb68fffddbb472a23f33" translate="yes" xml:space="preserve">
          <source>Package (WriterReader)</source>
          <target state="translated">包(WriterReader)</target>
        </trans-unit>
        <trans-unit id="92c0af89beed6181e00c988e8e650e8fbbda5fcb" translate="yes" xml:space="preserve">
          <source>Package adler32</source>
          <target state="translated">包adler32</target>
        </trans-unit>
        <trans-unit id="d6bd7681a9453e693c6a651037643ef4b5bef6e4" translate="yes" xml:space="preserve">
          <source>Package adler32 implements the Adler-32 checksum.</source>
          <target state="translated">包adler32实现了Adler-32校验和。</target>
        </trans-unit>
        <trans-unit id="e90a3804ce06c2050a2cae1b40859d0d4b3dc725" translate="yes" xml:space="preserve">
          <source>Package aes</source>
          <target state="translated">包裹aes</target>
        </trans-unit>
        <trans-unit id="d496233c286ca50cea980f949b6ce9d0a2fbee51" translate="yes" xml:space="preserve">
          <source>Package aes implements AES encryption (formerly Rijndael), as defined in U.S. Federal Information Processing Standards Publication 197.</source>
          <target state="translated">包aes实现了美国联邦信息处理标准出版物197中定义的AES加密(以前的Rijndael)。</target>
        </trans-unit>
        <trans-unit id="0d926b729b85354785bc0db2b7d8a423a023029c" translate="yes" xml:space="preserve">
          <source>Package ascii85</source>
          <target state="translated">包ascii85</target>
        </trans-unit>
        <trans-unit id="e3765c8a35f98ca3f4cb583e00d1c90614882045" translate="yes" xml:space="preserve">
          <source>Package ascii85 implements the ascii85 data encoding as used in the btoa tool and Adobe's PostScript and PDF document formats.</source>
          <target state="translated">包ascii85实现了btoa工具和Adobe的PostScript和PDF文档格式中使用的ascii85数据编码。</target>
        </trans-unit>
        <trans-unit id="180c9a93d5ae7703f2646b742a79d37379696e26" translate="yes" xml:space="preserve">
          <source>Package asn1</source>
          <target state="translated">包裹asn1</target>
        </trans-unit>
        <trans-unit id="cb9e56c303fa3f867a92e5ec0e898886f01abb4e" translate="yes" xml:space="preserve">
          <source>Package asn1 implements parsing of DER-encoded ASN.1 data structures, as defined in ITU-T Rec X.690.</source>
          <target state="translated">包asn1实现了ITU-T Rec X.690中定义的DER编码ASN.1数据结构的解析。</target>
        </trans-unit>
        <trans-unit id="c08d789dfd150c497744e5eae59ce25bf42b161c" translate="yes" xml:space="preserve">
          <source>Package ast</source>
          <target state="translated">包裹星</target>
        </trans-unit>
        <trans-unit id="93ce17c079d14adf086a4a91c618dc024db4dcea" translate="yes" xml:space="preserve">
          <source>Package ast declares the types used to represent syntax trees for Go packages.</source>
          <target state="translated">包 ast 声明了用于表示 Go 包语法树的类型。</target>
        </trans-unit>
        <trans-unit id="abc4155f0dfe705449b74dd36086fa20264918b2" translate="yes" xml:space="preserve">
          <source>Package atomic</source>
          <target state="translated">原子包</target>
        </trans-unit>
        <trans-unit id="6ccbd2fd52492c5f3e2a1a498498664cb5ffa588" translate="yes" xml:space="preserve">
          <source>Package atomic provides low-level atomic memory primitives useful for implementing synchronization algorithms.</source>
          <target state="translated">包atomic提供了对实现同步算法有用的低级原子内存基元。</target>
        </trans-unit>
        <trans-unit id="4ae1e53a5fe2ac3a3b380e5791057e84bdf2fcee" translate="yes" xml:space="preserve">
          <source>Package base32</source>
          <target state="translated">包base32</target>
        </trans-unit>
        <trans-unit id="3b12a0015b14e3cc130f8b62c8c17d7c8624a97a" translate="yes" xml:space="preserve">
          <source>Package base32 implements base32 encoding as specified by RFC 4648.</source>
          <target state="translated">包base32实现了RFC 4648规定的base32编码。</target>
        </trans-unit>
        <trans-unit id="38a49427af734eb5994d226888d46a2e48a7e089" translate="yes" xml:space="preserve">
          <source>Package base64</source>
          <target state="translated">包base64</target>
        </trans-unit>
        <trans-unit id="2daca13cb62da6b7b33a641f5439803312f106f9" translate="yes" xml:space="preserve">
          <source>Package base64 implements base64 encoding as specified by RFC 4648.</source>
          <target state="translated">包base64实现了RFC 4648规定的base64编码。</target>
        </trans-unit>
        <trans-unit id="03b1336c942a57d9960d475b8b394ed19dde9d0c" translate="yes" xml:space="preserve">
          <source>Package big</source>
          <target state="translated">包装大</target>
        </trans-unit>
        <trans-unit id="b4e5fa3ccf50e02964b74ff445efc105e444e505" translate="yes" xml:space="preserve">
          <source>Package big implements arbitrary-precision arithmetic (big numbers).</source>
          <target state="translated">包big实现了任意精度的算术(大数)。</target>
        </trans-unit>
        <trans-unit id="4e4c386fba82f93790e8829cc10da0258293e392" translate="yes" xml:space="preserve">
          <source>Package big implements arbitrary-precision arithmetic (big numbers). The following numeric types are supported:</source>
          <target state="translated">包big实现了任意精度的算术(大数)。支持以下数字类型。</target>
        </trans-unit>
        <trans-unit id="c20a791c17d35561b3248e9f4e27c1fc641c805c" translate="yes" xml:space="preserve">
          <source>Package binary</source>
          <target state="translated">二进制包</target>
        </trans-unit>
        <trans-unit id="a02abb66bca85bad533ac6ecbbd5730f265b40da" translate="yes" xml:space="preserve">
          <source>Package binary implements simple translation between numbers and byte sequences and encoding and decoding of varints.</source>
          <target state="translated">二进制包实现了数字和字节序列之间的简单转换以及变位数的编码和解码。</target>
        </trans-unit>
        <trans-unit id="b4585c8f5f16a7a3bbd64f720869325930c04b14" translate="yes" xml:space="preserve">
          <source>Package bits</source>
          <target state="translated">包装位</target>
        </trans-unit>
        <trans-unit id="f121f6160680c1e9d47eb4f125af85e968cef0c7" translate="yes" xml:space="preserve">
          <source>Package bits implements bit counting and manipulation functions for the predeclared unsigned integer types.</source>
          <target state="translated">包bit实现了预先声明的无符号整数类型的位计数和操作功能。</target>
        </trans-unit>
        <trans-unit id="83caad2c4e72c3c320f775fbd8a1a35e735677a9" translate="yes" xml:space="preserve">
          <source>Package bufio</source>
          <target state="translated">包裹bufio</target>
        </trans-unit>
        <trans-unit id="880f9f9e86187c3ab9594c87162508890d92b1e0" translate="yes" xml:space="preserve">
          <source>Package bufio implements buffered I/O. It wraps an io.Reader or io.Writer object, creating another object (Reader or Writer) that also implements the interface but provides buffering and some help for textual I/O.</source>
          <target state="translated">包 bufio 实现了缓冲的 I/O。它封装了一个io.Reader或io.Writer对象,创建了另一个对象(Reader或Writer),该对象也实现了该接口,但提供了缓冲和文本I/O的一些帮助。</target>
        </trans-unit>
        <trans-unit id="8f54827014010e49f148fc60f5174298cb86d1a9" translate="yes" xml:space="preserve">
          <source>Package build</source>
          <target state="translated">包建</target>
        </trans-unit>
        <trans-unit id="044aa6ad5cb13105de3d1dfe1e14ba517afc7dc8" translate="yes" xml:space="preserve">
          <source>Package build gathers information about Go packages.</source>
          <target state="translated">包的构建收集了Go包的信息。</target>
        </trans-unit>
        <trans-unit id="47ff1a6f77a6fab0a4ec0e7b02acecd8b23bea55" translate="yes" xml:space="preserve">
          <source>Package builtin</source>
          <target state="translated">内置包</target>
        </trans-unit>
        <trans-unit id="bc6082d4c1ffc50e8646c383c442de7a0853f3b7" translate="yes" xml:space="preserve">
          <source>Package builtin provides documentation for Go's predeclared identifiers. The items documented here are not actually in package builtin but their descriptions here allow godoc to present documentation for the language's special identifiers.</source>
          <target state="translated">包buildin提供了Go的预声明标识符的文档。这里所记录的项目实际上并不在包buildin中,但它们在这里的描述允许godoc为语言的特殊标识符提供文档。</target>
        </trans-unit>
        <trans-unit id="f18adabe10f881275c2b2d516cabb008577c2f65" translate="yes" xml:space="preserve">
          <source>Package bytes</source>
          <target state="translated">包装字节数</target>
        </trans-unit>
        <trans-unit id="48c486630207fb1f7940fbb120ac097a31665a2b" translate="yes" xml:space="preserve">
          <source>Package bytes implements functions for the manipulation of byte slices. It is analogous to the facilities of the strings package.</source>
          <target state="translated">包字节实现了操作字节片的函数。它类似于字符串包的功能。</target>
        </trans-unit>
        <trans-unit id="406c2304145d14ae40562458c269fc1090a1b790" translate="yes" xml:space="preserve">
          <source>Package bzip2</source>
          <target state="translated">包bzip2</target>
        </trans-unit>
        <trans-unit id="8eb7c863e2530f3f68b4ee1a3003e658910e2132" translate="yes" xml:space="preserve">
          <source>Package bzip2 implements bzip2 decompression.</source>
          <target state="translated">包bzip2实现了bzip2解压。</target>
        </trans-unit>
        <trans-unit id="872b31b797dd9ef4b907e19e6db917bdf3d1c013" translate="yes" xml:space="preserve">
          <source>Package cgi</source>
          <target state="translated">包裹cgi</target>
        </trans-unit>
        <trans-unit id="25ac46feb1a43e83003062fe9e6ccdab9ea2b191" translate="yes" xml:space="preserve">
          <source>Package cgi implements CGI (Common Gateway Interface) as specified in RFC 3875.</source>
          <target state="translated">包cgi实现了RFC 3875中指定的CGI(通用网关接口)。</target>
        </trans-unit>
        <trans-unit id="25e89bccb479aa882a9bfc5409a3323ae38e9e25" translate="yes" xml:space="preserve">
          <source>Package cgo</source>
          <target state="translated">包裹cgo</target>
        </trans-unit>
        <trans-unit id="0e3e2e5c14219e52219e14faf9778f4b602d6c0d" translate="yes" xml:space="preserve">
          <source>Package cgo contains runtime support for code generated by the cgo tool.</source>
          <target state="translated">包cgo包含对cgo工具生成的代码的运行时支持。</target>
        </trans-unit>
        <trans-unit id="6e62ea60a0dd1e82f411152a3d6419b7bf76fb06" translate="yes" xml:space="preserve">
          <source>Package cgo contains runtime support for code generated by the cgo tool. See the documentation for the cgo command for details on using cgo.</source>
          <target state="translated">包cgo包含对cgo工具生成的代码的运行时支持。关于cgo的使用细节,请参见cgo命令的文档。</target>
        </trans-unit>
        <trans-unit id="012f0d22cbfff5b4121f59681774b6bcdc6c8bf7" translate="yes" xml:space="preserve">
          <source>Package cipher</source>
          <target state="translated">包装密码</target>
        </trans-unit>
        <trans-unit id="30f3e7b90bc36d4a04ee0c6ee4fede5b412b7a90" translate="yes" xml:space="preserve">
          <source>Package cipher implements standard block cipher modes that can be wrapped around low-level block cipher implementations.</source>
          <target state="translated">封装密码实现了标准的块密码模式,可以围绕低级块密码实现进行封装。</target>
        </trans-unit>
        <trans-unit id="991a9a7de6b61fdec46bfd3e8877fa7f538b6fb2" translate="yes" xml:space="preserve">
          <source>Package cipher implements standard block cipher modes that can be wrapped around low-level block cipher implementations. See &lt;a href=&quot;https://csrc.nist.gov/groups/ST/toolkit/BCM/current_modes.html&quot;&gt;https://csrc.nist.gov/groups/ST/toolkit/BCM/current_modes.html&lt;/a&gt; and NIST Special Publication 800-38A.</source>
          <target state="translated">包密码实现标准的分组密码模式，可以将其包装在低级分组密码实现中。请参阅&lt;a href=&quot;https://csrc.nist.gov/groups/ST/toolkit/BCM/current_modes.html&quot;&gt;https://csrc.nist.gov/groups/ST/toolkit/BCM/current_modes.html&lt;/a&gt;和NIST特殊出版物800-38A。</target>
        </trans-unit>
        <trans-unit id="2b6816262bb29ee185f0f48249d8bc3daaf55582" translate="yes" xml:space="preserve">
          <source>Package cmplx</source>
          <target state="translated">包cmplx</target>
        </trans-unit>
        <trans-unit id="baf57dd7a6b5ac4706888aba9eb1258cba96f27c" translate="yes" xml:space="preserve">
          <source>Package cmplx provides basic constants and mathematical functions for complex numbers.</source>
          <target state="translated">包 cmplx 提供了复数的基本常量和数学函数。</target>
        </trans-unit>
        <trans-unit id="37d8c891f48030e536dd7b758ded3702c02139dc" translate="yes" xml:space="preserve">
          <source>Package color</source>
          <target state="translated">包装颜色</target>
        </trans-unit>
        <trans-unit id="0c0c35fbc62909ad60418ab34664b2ed01195fb4" translate="yes" xml:space="preserve">
          <source>Package color implements a basic color library.</source>
          <target state="translated">包color实现了一个基本的颜色库。</target>
        </trans-unit>
        <trans-unit id="1bcb3d15e235264a42cb3594781e34e58e7e4025" translate="yes" xml:space="preserve">
          <source>Package constant</source>
          <target state="translated">恒定包</target>
        </trans-unit>
        <trans-unit id="cc9ee19fe4a55fca4b94e371e7f50f3a89a325d9" translate="yes" xml:space="preserve">
          <source>Package constant implements Values representing untyped Go constants and their corresponding operations.</source>
          <target state="translated">包constant实现了代表非类型围棋常量的Val值和它们相应的操作。</target>
        </trans-unit>
        <trans-unit id="f37b57ba6586f71a43fafcb43910fbb2fb02fc3b" translate="yes" xml:space="preserve">
          <source>Package context</source>
          <target state="translated">包装背景</target>
        </trans-unit>
        <trans-unit id="d3934777ec3c952a9b50c31b8ba59b107a7a5d55" translate="yes" xml:space="preserve">
          <source>Package context defines the Context type, which carries deadlines, cancellation signals, and other request-scoped values across API boundaries and between processes.</source>
          <target state="translated">包上下文定义了Context类型,它承载着跨越API边界和进程之间的截止日期、取消信号和其他请求范围的值。</target>
        </trans-unit>
        <trans-unit id="2959c61a1310320ade48360831ded95782ef16b3" translate="yes" xml:space="preserve">
          <source>Package cookiejar</source>
          <target state="translated">包装cookiejar</target>
        </trans-unit>
        <trans-unit id="8c90ea9e027ef93e3a9e5e3949e57755bbbd286c" translate="yes" xml:space="preserve">
          <source>Package cookiejar implements an in-memory RFC 6265-compliant http.CookieJar.</source>
          <target state="translated">包cookiejar实现了一个符合RFC 6265标准的http.CookieJar的内存。</target>
        </trans-unit>
        <trans-unit id="9b8215374e5e8361fe90b06ebf351541009e3e3e" translate="yes" xml:space="preserve">
          <source>Package crc32</source>
          <target state="translated">包crc32</target>
        </trans-unit>
        <trans-unit id="b3a9ccd429f36d4cdadd48a9085d7744e115a2de" translate="yes" xml:space="preserve">
          <source>Package crc32 implements the 32-bit cyclic redundancy check, or CRC-32, checksum.</source>
          <target state="translated">包crc32实现了32位循环冗余检查,或CRC-32的校验和。</target>
        </trans-unit>
        <trans-unit id="e7dea81d74d4673657a098152e4028683fa05c21" translate="yes" xml:space="preserve">
          <source>Package crc32 implements the 32-bit cyclic redundancy check, or CRC-32, checksum. See &lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&lt;/a&gt; for information.</source>
          <target state="translated">软件包crc32实现32位循环冗余校验或CRC-32校验和。有关信息，请参见&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bd8911118f577811f18d0e59d8eb3416d753ee3d" translate="yes" xml:space="preserve">
          <source>Package crc64</source>
          <target state="translated">包crc64</target>
        </trans-unit>
        <trans-unit id="3f711a93350858163dc7138684052f433c0da645" translate="yes" xml:space="preserve">
          <source>Package crc64 implements the 64-bit cyclic redundancy check, or CRC-64, checksum.</source>
          <target state="translated">包crc64实现了64位循环冗余检查,或CRC-64,检查和。</target>
        </trans-unit>
        <trans-unit id="ddff3dc011b09fe55bbaec41ef9b74c6f1146846" translate="yes" xml:space="preserve">
          <source>Package crc64 implements the 64-bit cyclic redundancy check, or CRC-64, checksum. See &lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&lt;/a&gt; for information.</source>
          <target state="translated">程序包crc64实现64位循环冗余校验或CRC-64校验和。有关信息，请参见&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4f6d2ede86f313691ef17454cdcdea04be0dbbb5" translate="yes" xml:space="preserve">
          <source>Package crypto</source>
          <target state="translated">包装加密</target>
        </trans-unit>
        <trans-unit id="50dd6822d044a230766309da5791bbd273ba8e97" translate="yes" xml:space="preserve">
          <source>Package crypto collects common cryptographic constants.</source>
          <target state="translated">包 crypto 收集了常见的加密常量。</target>
        </trans-unit>
        <trans-unit id="6ce5f5b5df462bd32a5711f5f5fa215ca1b166ed" translate="yes" xml:space="preserve">
          <source>Package csv</source>
          <target state="translated">包csv</target>
        </trans-unit>
        <trans-unit id="40dd7303701bdcc70dc0c5df42eb5d6ee214e250" translate="yes" xml:space="preserve">
          <source>Package csv reads and writes comma-separated values (CSV) files.</source>
          <target state="translated">包csv读取和写入逗号分隔的值(CSV)文件。</target>
        </trans-unit>
        <trans-unit id="d150a0359eb47f620b34dee9c311dced79bcede8" translate="yes" xml:space="preserve">
          <source>Package csv reads and writes comma-separated values (CSV) files. There are many kinds of CSV files; this package supports the format described in RFC 4180.</source>
          <target state="translated">包 csv 读取和写入逗号分隔的值(CSV)文件。CSV文件有很多种,这个包支持RFC 4180中描述的格式。</target>
        </trans-unit>
        <trans-unit id="c161780a1f5eed6cb5eacae516343d9cf53f40a2" translate="yes" xml:space="preserve">
          <source>Package debug</source>
          <target state="translated">包调试</target>
        </trans-unit>
        <trans-unit id="e18c0cfe3c81fb4f011a9c8574f9e5713e35fc2f" translate="yes" xml:space="preserve">
          <source>Package debug contains facilities for programs to debug themselves while they are running.</source>
          <target state="translated">包调试包含了程序在运行时进行自我调试的设施。</target>
        </trans-unit>
        <trans-unit id="923e094a4a23dcbdaf9a79a349be666ee4da178a" translate="yes" xml:space="preserve">
          <source>Package des</source>
          <target state="translated">套餐</target>
        </trans-unit>
        <trans-unit id="f4273b555bae00c756bb38c4bdb36871d156fde9" translate="yes" xml:space="preserve">
          <source>Package des implements the Data Encryption Standard (DES) and the Triple Data Encryption Algorithm (TDEA) as defined in U.S. Federal Information Processing Standards Publication 46-3.</source>
          <target state="translated">包des实现了美国联邦信息处理标准出版物46-3中定义的数据加密标准(DES)和三重数据加密算法(TDEA)。</target>
        </trans-unit>
        <trans-unit id="6bf60b0613abca5907226299b84a4808f25c054a" translate="yes" xml:space="preserve">
          <source>Package doc</source>
          <target state="translated">文件包</target>
        </trans-unit>
        <trans-unit id="994d342a4898c4785e34e9db0e04a8dc47ee5ddc" translate="yes" xml:space="preserve">
          <source>Package doc extracts source code documentation from a Go AST.</source>
          <target state="translated">Package doc从Go AST中提取源代码文档。</target>
        </trans-unit>
        <trans-unit id="5069be6dcffa96eefcc7e1232c85b45e87fe235f" translate="yes" xml:space="preserve">
          <source>Package draw</source>
          <target state="translated">包装抽奖</target>
        </trans-unit>
        <trans-unit id="969fe7ec8173399610653b077ab51865992b53af" translate="yes" xml:space="preserve">
          <source>Package draw provides image composition functions.</source>
          <target state="translated">包draw提供图像合成功能。</target>
        </trans-unit>
        <trans-unit id="b15191fdde73d73923a18606c1904389361bc1f7" translate="yes" xml:space="preserve">
          <source>Package driver</source>
          <target state="translated">软件包驱动程序</target>
        </trans-unit>
        <trans-unit id="5c56f884cb2d5a4829273b5f372f47a0c56fc3c2" translate="yes" xml:space="preserve">
          <source>Package driver defines interfaces to be implemented by database drivers as used by package sql.</source>
          <target state="translated">包驱动定义了数据库驱动所要实现的接口,正如包sql所使用的那样。</target>
        </trans-unit>
        <trans-unit id="75bfd93d536faf5b82f79c9e4a6af54202df462f" translate="yes" xml:space="preserve">
          <source>Package dsa</source>
          <target state="translated">包裹dsa</target>
        </trans-unit>
        <trans-unit id="1e5b1f9060cf17d69c4113c4252756af952bfee1" translate="yes" xml:space="preserve">
          <source>Package dsa implements the Digital Signature Algorithm, as defined in FIPS 186-3.</source>
          <target state="translated">包 dsa 实现了 FIPS 186-3 中定义的数字签名算法。</target>
        </trans-unit>
        <trans-unit id="bba8e43639aa6507cfdd4c58cc34c9fb8b2cf7ed" translate="yes" xml:space="preserve">
          <source>Package dwarf</source>
          <target state="translated">侏儒包</target>
        </trans-unit>
        <trans-unit id="14e7ceae4640d2c62b637a66be95977203616d50" translate="yes" xml:space="preserve">
          <source>Package dwarf provides access to DWARF debugging information loaded from executable files, as defined in the DWARF 2.0 Standard at &lt;a href=&quot;http://dwarfstd.org/doc/dwarf-2.0.0.pdf&quot;&gt;http://dwarfstd.org/doc/dwarf-2.0.0.pdf&lt;/a&gt;</source>
          <target state="translated">dwarf软件包提供对从可执行文件加载的DWARF调试信息的访问权限，如DWARF 2.0标准中所定义，该信息位于&lt;a href=&quot;http://dwarfstd.org/doc/dwarf-2.0.0.pdf&quot;&gt;http://dwarfstd.org/doc/dwarf-2.0.0.pdf&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ccd56c1dfed1c041a4d12453cec3b05cda768eb7" translate="yes" xml:space="preserve">
          <source>Package ecdsa</source>
          <target state="translated">包材ecdsa</target>
        </trans-unit>
        <trans-unit id="352bd4aa5e4bbbc282580a9c214c315f78762a78" translate="yes" xml:space="preserve">
          <source>Package ecdsa implements the Elliptic Curve Digital Signature Algorithm, as defined in FIPS 186-3.</source>
          <target state="translated">包 ecdsa 实现了 FIPS 186-3 中定义的椭圆曲线数字签名算法。</target>
        </trans-unit>
        <trans-unit id="22f041b9e4b005e5e63601ee047c6784ff58304a" translate="yes" xml:space="preserve">
          <source>Package ed25519</source>
          <target state="translated">包件ed25519</target>
        </trans-unit>
        <trans-unit id="fb8453c2683c8a0379237947977a4025115b54f4" translate="yes" xml:space="preserve">
          <source>Package ed25519 implements the Ed25519 signature algorithm.</source>
          <target state="translated">包ed25519实现了Ed25519签名算法。</target>
        </trans-unit>
        <trans-unit id="59626533c02e37a4826df5b84fcfc9afa7203b79" translate="yes" xml:space="preserve">
          <source>Package ed25519 implements the Ed25519 signature algorithm. See &lt;a href=&quot;https://ed25519.cr.yp.to/&quot;&gt;https://ed25519.cr.yp.to/&lt;/a&gt;.</source>
          <target state="translated">软件包ed25519实现了Ed25519签名算法。参见&lt;a href=&quot;https://ed25519.cr.yp.to/&quot;&gt;https://ed25519.cr.yp.to/&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="22876ea6aba1d18293913d0db2521ad8767018c8" translate="yes" xml:space="preserve">
          <source>Package elf</source>
          <target state="translated">包装精灵</target>
        </trans-unit>
        <trans-unit id="e380ec79714ca14aed830146e07f72516490e0b8" translate="yes" xml:space="preserve">
          <source>Package elf implements access to ELF object files.</source>
          <target state="translated">包elf实现了对ELF对象文件的访问。</target>
        </trans-unit>
        <trans-unit id="c011316b96f999a9e3cf849a36b3fc15797d8e99" translate="yes" xml:space="preserve">
          <source>Package elliptic</source>
          <target state="translated">椭圆包</target>
        </trans-unit>
        <trans-unit id="3bab3655adc3a192a092b071bc83e45652e1d476" translate="yes" xml:space="preserve">
          <source>Package elliptic implements several standard elliptic curves over prime fields.</source>
          <target state="translated">包椭圆实现了几种标准的素域上的椭圆曲线。</target>
        </trans-unit>
        <trans-unit id="e1b2d294cf9a0cfac69d667bd45e68644ccbf3c6" translate="yes" xml:space="preserve">
          <source>Package encoding</source>
          <target state="translated">包装编码</target>
        </trans-unit>
        <trans-unit id="ed189180f83e61e5ab517f381324404e9d31f4c0" translate="yes" xml:space="preserve">
          <source>Package encoding defines interfaces shared by other packages that convert data to and from byte-level and textual representations. Packages that check for these interfaces include encoding/gob, encoding/json, and encoding/xml. As a result, implementing an interface once can make a type useful in multiple encodings. Standard types that implement these interfaces include time.Time and net.IP. The interfaces come in pairs that produce and consume encoded data.</source>
          <target state="translated">包编码定义了由其他包共享的接口,这些接口将数据转换为字节级和文本表示。检查这些接口的包包括 encoding/gob、encoding/json 和 encoding/xml。因此,实现一次接口可以使一个类型在多种编码中有用。实现这些接口的标准类型包括time.Time和net.IP。这些接口成对地产生和消耗编码数据。</target>
        </trans-unit>
        <trans-unit id="6ee23de7e1e5b835e55c54376bdadcfebe218831" translate="yes" xml:space="preserve">
          <source>Package errors</source>
          <target state="translated">包装错误</target>
        </trans-unit>
        <trans-unit id="4a3bda8668f0f7be8e4653eb9de5b1df5a4b72ae" translate="yes" xml:space="preserve">
          <source>Package errors implements functions to manipulate errors.</source>
          <target state="translated">包错误实现了操作错误的函数。</target>
        </trans-unit>
        <trans-unit id="7627f68608d0501d49a4083a780c7eb361e07f6d" translate="yes" xml:space="preserve">
          <source>Package exec</source>
          <target state="translated">包执行</target>
        </trans-unit>
        <trans-unit id="ee030f10ad063000193fa361b43cfffc1bcc3c8c" translate="yes" xml:space="preserve">
          <source>Package exec runs external commands.</source>
          <target state="translated">Package exec运行外部命令。</target>
        </trans-unit>
        <trans-unit id="7b3a0dfc0fae8cd217bc6e25080e713ad98645d6" translate="yes" xml:space="preserve">
          <source>Package exec runs external commands. It wraps os.StartProcess to make it easier to remap stdin and stdout, connect I/O with pipes, and do other adjustments.</source>
          <target state="translated">包exec运行外部命令。它封装了os.StartProcess,使其更容易重映射stdin和stdout,用管道连接I/O,并进行其他调整。</target>
        </trans-unit>
        <trans-unit id="56d612eb4d8eb6cceb1e7052a93aac6c0e863c13" translate="yes" xml:space="preserve">
          <source>Package expvar</source>
          <target state="translated">包expvar</target>
        </trans-unit>
        <trans-unit id="8556b9ff068352b9cd4f96c39543b774957282c2" translate="yes" xml:space="preserve">
          <source>Package expvar provides a standardized interface to public variables, such as operation counters in servers. It exposes these variables via HTTP at /debug/vars in JSON format.</source>
          <target state="translated">包expvar为公共变量提供了一个标准化的接口,比如服务器中的操作计数器。它通过HTTP以JSON格式在/debug/vars中公开这些变量。</target>
        </trans-unit>
        <trans-unit id="7753afb6ef13a60250c22070f9d8cb74aca0cdd9" translate="yes" xml:space="preserve">
          <source>Package fcgi</source>
          <target state="translated">包fcgi</target>
        </trans-unit>
        <trans-unit id="2130ff15a15a985590dbae853cbc6bd5f16bc412" translate="yes" xml:space="preserve">
          <source>Package fcgi implements the FastCGI protocol.</source>
          <target state="translated">包fcgi实现了FastCGI协议。</target>
        </trans-unit>
        <trans-unit id="2f468670b5944c845b0cba8a76b0cc4bc25c4814" translate="yes" xml:space="preserve">
          <source>Package filepath</source>
          <target state="translated">包文件路径</target>
        </trans-unit>
        <trans-unit id="aad84fa78fc1a5621f1a8d48a9f041dd752165f9" translate="yes" xml:space="preserve">
          <source>Package filepath implements utility routines for manipulating filename paths in a way compatible with the target operating system-defined file paths.</source>
          <target state="translated">包filepath实现了实用程序,用于以与目标操作系统定义的文件路径兼容的方式操作文件名路径。</target>
        </trans-unit>
        <trans-unit id="20c64fec5374a451273360446201779aff8c1424" translate="yes" xml:space="preserve">
          <source>Package files</source>
          <target state="translated">包装文件</target>
        </trans-unit>
        <trans-unit id="e5471378272dfaa2efadcd1f53861518b9f099f7" translate="yes" xml:space="preserve">
          <source>Package flag</source>
          <target state="translated">包装旗</target>
        </trans-unit>
        <trans-unit id="e7d9cd955d937c95fcd6a1739c4bfae5a8cbabd2" translate="yes" xml:space="preserve">
          <source>Package flag implements command-line flag parsing.</source>
          <target state="translated">包标志实现命令行标志解析。</target>
        </trans-unit>
        <trans-unit id="a337ebb67872d5c06c8e204854b5aa24937ec53e" translate="yes" xml:space="preserve">
          <source>Package flate</source>
          <target state="translated">包片</target>
        </trans-unit>
        <trans-unit id="cd21214e87a49e1d6a376d93be54459975506452" translate="yes" xml:space="preserve">
          <source>Package flate implements the DEFLATE compressed data format, described in RFC 1951. The gzip and zlib packages implement access to DEFLATE-based file formats.</source>
          <target state="translated">包flate实现了RFC 1951中描述的DEFLATE压缩数据格式。gzip和zlib包实现了对基于DEFLATE的文件格式的访问。</target>
        </trans-unit>
        <trans-unit id="803b763e8c63b8639017426b9ddb6efdb2934c44" translate="yes" xml:space="preserve">
          <source>Package fmt</source>
          <target state="translated">fmt包</target>
        </trans-unit>
        <trans-unit id="d4c2ac9d05c1a7be572af9a00f7d2ee2c86ace0b" translate="yes" xml:space="preserve">
          <source>Package fmt implements formatted I/O with functions analogous to C's printf and scanf. The format 'verbs' are derived from C's but are simpler.</source>
          <target state="translated">包fmt实现了格式化的I/O,其功能类似于C的printf和scanf。格式 &quot;动词 &quot;是从C语言中衍生出来的,但更简单。</target>
        </trans-unit>
        <trans-unit id="d7f1bbda6df0adc48225339cb988bf008c879f32" translate="yes" xml:space="preserve">
          <source>Package fnv</source>
          <target state="translated">包裹fnv</target>
        </trans-unit>
        <trans-unit id="1ed450736ae5a7fac5851c4ce48e5c295154cd82" translate="yes" xml:space="preserve">
          <source>Package fnv implements FNV-1 and FNV-1a, non-cryptographic hash functions created by Glenn Fowler, Landon Curt Noll, and Phong Vo.</source>
          <target state="translated">包fnv实现了FNV-1和FNV-1a,由Glenn Fowler、Landon Curt Noll和Phong Vo创建的非加密哈希函数。</target>
        </trans-unit>
        <trans-unit id="3bfeda77f81e7eb63d4ceaa90d61b0d8cdf6c313" translate="yes" xml:space="preserve">
          <source>Package fnv implements FNV-1 and FNV-1a, non-cryptographic hash functions created by Glenn Fowler, Landon Curt Noll, and Phong Vo. See &lt;a href=&quot;https://en.wikipedia.org/wiki/Fowler-Noll-Vo_hash_function&quot;&gt;https://en.wikipedia.org/wiki/Fowler-Noll-Vo_hash_function&lt;/a&gt;.</source>
          <target state="translated">软件包fnv实现了FNV-1和FNV-1a，这是由Glenn Fowler，Landon Curt Noll和Phong Vo创建的非加密哈希函数。参见&lt;a href=&quot;https://en.wikipedia.org/wiki/Fowler-Noll-Vo_hash_function&quot;&gt;https://en.wikipedia.org/wiki/Fowler-Noll-Vo_hash_function&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6e1e99b0cea0f06b1bed3052795d0456203e66ac" translate="yes" xml:space="preserve">
          <source>Package format</source>
          <target state="translated">包装格式</target>
        </trans-unit>
        <trans-unit id="44b5a52572ad981c0279cfa1b8249c656292c37c" translate="yes" xml:space="preserve">
          <source>Package format implements standard formatting of Go source.</source>
          <target state="translated">包格式实现了Go源代码的标准格式化。</target>
        </trans-unit>
        <trans-unit id="b91f9f521a74becec1958e73da770098048f55a7" translate="yes" xml:space="preserve">
          <source>Package gif</source>
          <target state="translated">包裹gif</target>
        </trans-unit>
        <trans-unit id="10af1984ddf2d910dc561741c129eaf2fb3d93fc" translate="yes" xml:space="preserve">
          <source>Package gif implements a GIF image decoder and encoder.</source>
          <target state="translated">包gif实现了一个GIF图像解码器和编码器。</target>
        </trans-unit>
        <trans-unit id="e3be21e16b230bb3bdb8bf1710ba144ad69deeeb" translate="yes" xml:space="preserve">
          <source>Package gob</source>
          <target state="translated">包裹口罩</target>
        </trans-unit>
        <trans-unit id="a418c33843d2c062092d6d7c6a4b5816c45727d5" translate="yes" xml:space="preserve">
          <source>Package gob manages streams of gobs - binary values exchanged between an Encoder (transmitter) and a Decoder (receiver).</source>
          <target state="translated">包gob管理gob流--编码器(发送器)和解码器(接收器)之间交换的二进制值。</target>
        </trans-unit>
        <trans-unit id="44cd01d964bb483f352db2a1b5d4abe8f1b01e5e" translate="yes" xml:space="preserve">
          <source>Package gob manages streams of gobs - binary values exchanged between an Encoder (transmitter) and a Decoder (receiver). A typical use is transporting arguments and results of remote procedure calls (RPCs) such as those provided by package &quot;net/rpc&quot;.</source>
          <target state="translated">包gob管理gob流--编码器(发送器)和解码器(接收器)之间交换的二进制值。一个典型的用途是传输远程过程调用(RPC)的参数和结果,如 &quot;net/rpc &quot;包提供的那些。</target>
        </trans-unit>
        <trans-unit id="00c000f3850e24bf28c662891a897dac5381ac6c" translate="yes" xml:space="preserve">
          <source>Package gosym</source>
          <target state="translated">包裹 gosym</target>
        </trans-unit>
        <trans-unit id="2e38d0f781b2d46a7d764ec5db29147877b83b80" translate="yes" xml:space="preserve">
          <source>Package gosym implements access to the Go symbol and line number tables embedded in Go binaries generated by the gc compilers.</source>
          <target state="translated">包 gosym 实现了对 gc 编译器生成的 Go 二进制文件中嵌入的 Go 符号和行号表的访问。</target>
        </trans-unit>
        <trans-unit id="7a918ba298748f37d152f5cb60e30e14a28d12c9" translate="yes" xml:space="preserve">
          <source>Package gzip</source>
          <target state="translated">包gzip</target>
        </trans-unit>
        <trans-unit id="29dec348206cd4001b61a9c9f0a5d0e43fd7f769" translate="yes" xml:space="preserve">
          <source>Package gzip implements reading and writing of gzip format compressed files, as specified in RFC 1952.</source>
          <target state="translated">包gzip实现了RFC 1952中规定的gzip格式压缩文件的读写。</target>
        </trans-unit>
        <trans-unit id="14ea7753f344ada7c0aa1963e2baed63cdc13331" translate="yes" xml:space="preserve">
          <source>Package hash</source>
          <target state="translated">包的哈希值</target>
        </trans-unit>
        <trans-unit id="a85d6200368ac18f684b218608b5fa8afb33d33f" translate="yes" xml:space="preserve">
          <source>Package hash provides interfaces for hash functions.</source>
          <target state="translated">包哈希提供了哈希函数的接口。</target>
        </trans-unit>
        <trans-unit id="3a59626485ffbd81c7d5e90634cb6e93e7c34e5b" translate="yes" xml:space="preserve">
          <source>Package heap</source>
          <target state="translated">包装堆</target>
        </trans-unit>
        <trans-unit id="e93c407a24d497fcea18deaab136750e41bee04c" translate="yes" xml:space="preserve">
          <source>Package heap provides heap operations for any type that implements heap.Interface. A heap is a tree with the property that each node is the minimum-valued node in its subtree.</source>
          <target state="translated">包 heap 为任何实现 heap.Interface 的类型提供堆操作。一个堆是一棵树,其属性是每个节点都是其子树中最小值的节点。</target>
        </trans-unit>
        <trans-unit id="7b0d8dd93b6da00a5a3853f6a8971b11d3be119a" translate="yes" xml:space="preserve">
          <source>Package hex</source>
          <target state="translated">六角包</target>
        </trans-unit>
        <trans-unit id="7413aef6d1364ce17833992530bdefe998ac3dba" translate="yes" xml:space="preserve">
          <source>Package hex implements hexadecimal encoding and decoding.</source>
          <target state="translated">包hex实现了十六进制的编码和解码。</target>
        </trans-unit>
        <trans-unit id="1ae2b94353abc10afddd7e75ff8292b5ec664627" translate="yes" xml:space="preserve">
          <source>Package hmac</source>
          <target state="translated">包hmac</target>
        </trans-unit>
        <trans-unit id="5862414bf4e6f484aa549d995a6f4852a7f9b0df" translate="yes" xml:space="preserve">
          <source>Package hmac implements the Keyed-Hash Message Authentication Code (HMAC) as defined in U.S. Federal Information Processing Standards Publication 198.</source>
          <target state="translated">包 hmac 实现了美国联邦信息处理标准出版物 198 中定义的 Keyed-Hash Message Authentication Code(HMAC)。</target>
        </trans-unit>
        <trans-unit id="993a4c7f2aa0bc17bb821bd77a5cdca08736959a" translate="yes" xml:space="preserve">
          <source>Package hmac implements the Keyed-Hash Message Authentication Code (HMAC) as defined in U.S. Federal Information Processing Standards Publication 198. An HMAC is a cryptographic hash that uses a key to sign a message. The receiver verifies the hash by recomputing it using the same key.</source>
          <target state="translated">包hmac实现了美国联邦信息处理标准出版物198中定义的密钥散列消息认证码(HMAC)。HMAC是一个加密的散列码,它使用一个密钥来签署一个消息。接收者通过使用相同的密钥重新计算来验证该哈希值。</target>
        </trans-unit>
        <trans-unit id="fb848edc1bb28a05f8c5d03e75ae2933d6b8c193" translate="yes" xml:space="preserve">
          <source>Package html</source>
          <target state="translated">html包</target>
        </trans-unit>
        <trans-unit id="ee6e4064cc07f14cce23003d26486bcbe481c4c8" translate="yes" xml:space="preserve">
          <source>Package html provides functions for escaping and unescaping HTML text.</source>
          <target state="translated">包html提供了转义和取消转义HTML文本的功能。</target>
        </trans-unit>
        <trans-unit id="93aded6e94d278e605519fd733984fb105ebc8cb" translate="yes" xml:space="preserve">
          <source>Package http</source>
          <target state="translated">http包</target>
        </trans-unit>
        <trans-unit id="565f53df2ba05962d275cc2ddb64a0ff5b302111" translate="yes" xml:space="preserve">
          <source>Package http provides HTTP client and server implementations.</source>
          <target state="translated">http包提供了HTTP客户端和服务器的实现。</target>
        </trans-unit>
        <trans-unit id="60c2fddc445e71feb989d0582a02f4947d2d457d" translate="yes" xml:space="preserve">
          <source>Package httptest</source>
          <target state="translated">httptest包</target>
        </trans-unit>
        <trans-unit id="aa8780d1e29dd261a3c2246607eef7a72b8bbb1d" translate="yes" xml:space="preserve">
          <source>Package httptest provides utilities for HTTP testing.</source>
          <target state="translated">包httptest提供HTTP测试的工具。</target>
        </trans-unit>
        <trans-unit id="0f537d98dbab242ca895592a50db6e67fd272c97" translate="yes" xml:space="preserve">
          <source>Package httptrace</source>
          <target state="translated">包 httptrace</target>
        </trans-unit>
        <trans-unit id="813e220dd05ef49b41ec90a3fc88de9ec143f032" translate="yes" xml:space="preserve">
          <source>Package httptrace provides mechanisms to trace the events within HTTP client requests.</source>
          <target state="translated">包httptrace提供了跟踪HTTP客户端请求中事件的机制。</target>
        </trans-unit>
        <trans-unit id="9613bdf01a4050ee78eaddb84e11fc64ec270990" translate="yes" xml:space="preserve">
          <source>Package httputil</source>
          <target state="translated">包 httputil</target>
        </trans-unit>
        <trans-unit id="76d80a4fa32f388098c8efd95fe330b71ff09bd9" translate="yes" xml:space="preserve">
          <source>Package httputil provides HTTP utility functions, complementing the more common ones in the net/http package.</source>
          <target state="translated">包httputil提供了HTTP的实用功能,补充了net/http包中比较常见的功能。</target>
        </trans-unit>
        <trans-unit id="421a469bd8c6ddf7b1af341ec45254a3934f90ed" translate="yes" xml:space="preserve">
          <source>Package image</source>
          <target state="translated">包装图片</target>
        </trans-unit>
        <trans-unit id="4aa8ef8dbcca06a643631802f3d7a141211d42b0" translate="yes" xml:space="preserve">
          <source>Package image implements a basic 2-D image library.</source>
          <target state="translated">包image实现了一个基本的二维图像库。</target>
        </trans-unit>
        <trans-unit id="2dc8e28a838b11d0551b3a0d88ebb2a4408dab5b" translate="yes" xml:space="preserve">
          <source>Package importer</source>
          <target state="translated">包装进口商</target>
        </trans-unit>
        <trans-unit id="420252f85bc81d5c6c24a04bcbd00100b4357969" translate="yes" xml:space="preserve">
          <source>Package importer provides access to export data importers.</source>
          <target state="translated">包导入器提供对导出数据导入器的访问。</target>
        </trans-unit>
        <trans-unit id="93b91053c7ffebf57a4a0530d2af3609eb527706" translate="yes" xml:space="preserve">
          <source>Package internal</source>
          <target state="translated">包装内部</target>
        </trans-unit>
        <trans-unit id="ae4bbcb538c3d4b00aa18c51e1cf94d759fc3060" translate="yes" xml:space="preserve">
          <source>Package internal contains HTTP internals shared by net/http and net/http/httputil.</source>
          <target state="translated">包内部包含net/http和net/http/httputil共享的HTTP内部结构。</target>
        </trans-unit>
        <trans-unit id="e9636058f09cfb43189cb98a195789b7f0f244da" translate="yes" xml:space="preserve">
          <source>Package io</source>
          <target state="translated">包裹io</target>
        </trans-unit>
        <trans-unit id="32668f487482a47ba7dcd798b007284f2070596c" translate="yes" xml:space="preserve">
          <source>Package io provides basic interfaces to I/O primitives. Its primary job is to wrap existing implementations of such primitives, such as those in package os, into shared public interfaces that abstract the functionality, plus some other related primitives.</source>
          <target state="translated">包io提供了I/O基元的基本接口。它的主要工作是将这些基元的现有实现(如包os中的实现)包装成共享的公共接口,这些接口抽象了这些功能,再加上一些其他相关的基元。</target>
        </trans-unit>
        <trans-unit id="30cb02e7eab55914ca42d64df94b0246f5f91b46" translate="yes" xml:space="preserve">
          <source>Package iotest</source>
          <target state="translated">包iotest</target>
        </trans-unit>
        <trans-unit id="2188f45ca7e2af66c7f08124940a486765a3a1d3" translate="yes" xml:space="preserve">
          <source>Package iotest implements Readers and Writers useful mainly for testing.</source>
          <target state="translated">包iotest实现了主要用于测试的读写器。</target>
        </trans-unit>
        <trans-unit id="f634706aadf3538974af07a1962d2af1e6651011" translate="yes" xml:space="preserve">
          <source>Package ioutil</source>
          <target state="translated">包ioutil</target>
        </trans-unit>
        <trans-unit id="b7b8fc12300546d76dd9c8e4af13cff6a6ad7548" translate="yes" xml:space="preserve">
          <source>Package ioutil implements some I/O utility functions.</source>
          <target state="translated">包ioutil实现了一些I/O实用功能。</target>
        </trans-unit>
        <trans-unit id="c9fe1f4196a35af3e90e6bd308c01296038ce831" translate="yes" xml:space="preserve">
          <source>Package is the documentation for an entire package.</source>
          <target state="translated">包是整个包的文档。</target>
        </trans-unit>
        <trans-unit id="4c1d637bde171a0a8b7330b1b7e32fbe44f587a8" translate="yes" xml:space="preserve">
          <source>Package jpeg</source>
          <target state="translated">包jpeg</target>
        </trans-unit>
        <trans-unit id="be891878e9ef59cdb50913b5ceb2d5944c8960f6" translate="yes" xml:space="preserve">
          <source>Package jpeg implements a JPEG image decoder and encoder.</source>
          <target state="translated">包jpeg实现了一个JPEG图像解码器和编码器。</target>
        </trans-unit>
        <trans-unit id="5232feffa0151247920dae06a9ddd5d55973aeb8" translate="yes" xml:space="preserve">
          <source>Package js</source>
          <target state="translated">包 js</target>
        </trans-unit>
        <trans-unit id="8dacbfd07dd845e3d61f3d13d059dcc9341b5c76" translate="yes" xml:space="preserve">
          <source>Package js gives access to the WebAssembly host environment when using the js/wasm architecture.</source>
          <target state="translated">包js在使用js/wasm架构时,可以访问WebAssembly主机环境。</target>
        </trans-unit>
        <trans-unit id="455c332edf437e87334e708fb429cc6e36a5ac4c" translate="yes" xml:space="preserve">
          <source>Package js gives access to the WebAssembly host environment when using the js/wasm architecture. Its API is based on JavaScript semantics.</source>
          <target state="translated">包js在使用js/wasm架构时,可以访问WebAssembly主机环境。它的API是基于JavaScript语义的。</target>
        </trans-unit>
        <trans-unit id="3857092de217368375e6707dd2db2ce13bf5c6d4" translate="yes" xml:space="preserve">
          <source>Package json</source>
          <target state="translated">包json</target>
        </trans-unit>
        <trans-unit id="7ba30886d6ae888888da2bc78eb7b020f20e938d" translate="yes" xml:space="preserve">
          <source>Package json implements encoding and decoding of JSON as defined in RFC 7159.</source>
          <target state="translated">包 json 实现了 RFC 7159 中定义的 JSON 的编码和解码。</target>
        </trans-unit>
        <trans-unit id="87906380a06bba048f9b4e8bd43cd1fc7f064c58" translate="yes" xml:space="preserve">
          <source>Package json implements encoding and decoding of JSON as defined in RFC 7159. The mapping between JSON and Go values is described in the documentation for the Marshal and Unmarshal functions.</source>
          <target state="translated">包 json 实现了 RFC 7159 中定义的 JSON 的编码和解码。JSON和Go值之间的映射在Marshal和Unmarshal函数的文档中描述。</target>
        </trans-unit>
        <trans-unit id="89d676dca8ece21fde225b9a51b937ba3f6ad6a6" translate="yes" xml:space="preserve">
          <source>Package jsonrpc</source>
          <target state="translated">包 jsonrpc</target>
        </trans-unit>
        <trans-unit id="1c78124a6a4761b03c5384a07f14a75cc4666f38" translate="yes" xml:space="preserve">
          <source>Package jsonrpc implements a JSON-RPC 1.0 ClientCodec and ServerCodec for the rpc package.</source>
          <target state="translated">包jsonrpc为rpc包实现了JSON-RPC 1.0 ClientCodec和ServerCodec。</target>
        </trans-unit>
        <trans-unit id="09af982985244ee30f92c80e2ab36bc0138d5a7f" translate="yes" xml:space="preserve">
          <source>Package jsonrpc implements a JSON-RPC 1.0 ClientCodec and ServerCodec for the rpc package. For JSON-RPC 2.0 support, see &lt;a href=&quot;https://godoc.org/?q=json-rpc+2.0&quot;&gt;https://godoc.org/?q=json-rpc+2.0&lt;/a&gt;</source>
          <target state="translated">包jsonrpc为rpc包实现了JSON-RPC 1.0 ClientCodec和ServerCodec。有关JSON-RPC 2.0的支持，请参见&lt;a href=&quot;https://godoc.org/?q=json-rpc+2.0&quot;&gt;https://godoc.org/?q=json-rpc+2.0&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="329023972d7b1c502617105ef48cde0a78cc6333" translate="yes" xml:space="preserve">
          <source>Package list</source>
          <target state="translated">包装清单</target>
        </trans-unit>
        <trans-unit id="e56f44c63fe9d6afdfff2ff8bc53c3b472803b64" translate="yes" xml:space="preserve">
          <source>Package list implements a doubly linked list.</source>
          <target state="translated">包列表实现了一个双链接的列表。</target>
        </trans-unit>
        <trans-unit id="39f07fcf96398e5964be22f3a7e100e6e4714031" translate="yes" xml:space="preserve">
          <source>Package log</source>
          <target state="translated">包装日志</target>
        </trans-unit>
        <trans-unit id="c01d2cd8db1d9fe6fc80ae05326ed0052a2926ca" translate="yes" xml:space="preserve">
          <source>Package log implements a simple logging package. It defines a type, Logger, with methods for formatting output. It also has a predefined 'standard' Logger accessible through helper functions Print[f|ln], Fatal[f|ln], and Panic[f|ln], which are easier to use than creating a Logger manually. That logger writes to standard error and prints the date and time of each logged message. Every log message is output on a separate line: if the message being printed does not end in a newline, the logger will add one. The Fatal functions call os.Exit(1) after writing the log message. The Panic functions call panic after writing the log message.</source>
          <target state="translated">包log实现了一个简单的日志包。它定义了一个类型,Logger,以及用于格式化输出的方法。它也有一个预定义的 &quot;标准 &quot;Logger,可以通过帮助函数Print[f|ln]、Fatal[f|ln]和Panic[f|ln]来访问,这比手动创建一个Logger更容易使用。该日志器将写入标准错误,并打印每条日志消息的日期和时间。每条日志消息都会在单独的一行上输出:如果被打印的消息没有以换行结束,记录器就会添加一个换行。Fatal 函数在写完日志消息后会调用 os.Exit(1)。Panic 函数在写完日志消息后调用 panic。</target>
        </trans-unit>
        <trans-unit id="2736ca6dade93fff8e3bc211ddd7f28c53ea115b" translate="yes" xml:space="preserve">
          <source>Package lzw</source>
          <target state="translated">包lzw</target>
        </trans-unit>
        <trans-unit id="c4777021f1dd4b6564d1ec41e7d3abc076b6187e" translate="yes" xml:space="preserve">
          <source>Package lzw implements the Lempel-Ziv-Welch compressed data format, described in T. A. Welch, &amp;ldquo;A Technique for High-Performance Data Compression&amp;rdquo;, Computer, 17(6) (June 1984), pp 8-19.</source>
          <target state="translated">软件包lzw实施了Le Welch-Ziv-Welch压缩数据格式，该格式在TA Welch，&amp;ldquo;高性能数据压缩技术&amp;rdquo;，计算机，第17（6）版（1984年6月），第8-19页中进行了介绍。</target>
        </trans-unit>
        <trans-unit id="0e8e7d95f57fe8be09d8faaa0ea86acf1a5fc077" translate="yes" xml:space="preserve">
          <source>Package macho</source>
          <target state="translated">包装大男子主义</target>
        </trans-unit>
        <trans-unit id="92e8c827c8c83c12e1e7b7f121d38fd11d3d6bba" translate="yes" xml:space="preserve">
          <source>Package macho implements access to Mach-O object files.</source>
          <target state="translated">包macho实现了对Mach-O对象文件的访问。</target>
        </trans-unit>
        <trans-unit id="6fe93114653da182b59c5cf973ab0a06ef574c15" translate="yes" xml:space="preserve">
          <source>Package mail</source>
          <target state="translated">包裹邮件</target>
        </trans-unit>
        <trans-unit id="6f8e8eb862b5bec7f5c8edcb6c15137f3e2e3084" translate="yes" xml:space="preserve">
          <source>Package mail implements parsing of mail messages.</source>
          <target state="translated">包邮件实现了邮件信息的解析。</target>
        </trans-unit>
        <trans-unit id="383fe77ace45b295ad208a38e47b35209b6b894f" translate="yes" xml:space="preserve">
          <source>Package math</source>
          <target state="translated">套餐数学</target>
        </trans-unit>
        <trans-unit id="b6130e3233ca7fa326fe0f65160f4609452fcc5c" translate="yes" xml:space="preserve">
          <source>Package math provides basic constants and mathematical functions.</source>
          <target state="translated">包数学提供了基本常量和数学函数。</target>
        </trans-unit>
        <trans-unit id="91905953ed9b218a4bdf61f1b0e37fe7e7362ece" translate="yes" xml:space="preserve">
          <source>Package md5</source>
          <target state="translated">包md5</target>
        </trans-unit>
        <trans-unit id="91e121cc95845f0e275412a014e511801fa15c71" translate="yes" xml:space="preserve">
          <source>Package md5 implements the MD5 hash algorithm as defined in RFC 1321.</source>
          <target state="translated">包md5实现了RFC 1321中定义的MD5哈希算法。</target>
        </trans-unit>
        <trans-unit id="6e452f6ff2b6f89e6e2fddfc0bc47cc6ea9d38e3" translate="yes" xml:space="preserve">
          <source>Package mime</source>
          <target state="translated">包裹哑剧</target>
        </trans-unit>
        <trans-unit id="fb5b7d35717be7356677497c60f984d8bae7427b" translate="yes" xml:space="preserve">
          <source>Package mime implements parts of the MIME spec.</source>
          <target state="translated">包mime实现了MIME规范的部分内容。</target>
        </trans-unit>
        <trans-unit id="a4afe7ca5ec65b45429532cb822f68e7b1f969e3" translate="yes" xml:space="preserve">
          <source>Package multipart</source>
          <target state="translated">包装多部分</target>
        </trans-unit>
        <trans-unit id="0975c17eab222919880be81a12a600e92a6d534f" translate="yes" xml:space="preserve">
          <source>Package multipart implements MIME multipart parsing, as defined in RFC 2046.</source>
          <target state="translated">Package multipart实现了RFC 2046中定义的MIME多部分解析。</target>
        </trans-unit>
        <trans-unit id="30c5d58023a5520f3b07d9da146a5ed1519a8f7c" translate="yes" xml:space="preserve">
          <source>Package net</source>
          <target state="translated">包装网</target>
        </trans-unit>
        <trans-unit id="43d696099850d935770e8f7b1c038c883c0137cb" translate="yes" xml:space="preserve">
          <source>Package net provides a portable interface for network I/O, including TCP/IP, UDP, domain name resolution, and Unix domain sockets.</source>
          <target state="translated">Package net为网络I/O提供了一个可移植的接口,包括TCP/IP、UDP、域名解析和Unix域套接字。</target>
        </trans-unit>
        <trans-unit id="7ab70b00aa79e1b268257a5e997962ee78d287d2" translate="yes" xml:space="preserve">
          <source>Package os</source>
          <target state="translated">包os</target>
        </trans-unit>
        <trans-unit id="c733a9fd7f2534638a02811f5ea17d1a129c8b5c" translate="yes" xml:space="preserve">
          <source>Package os provides a platform-independent interface to operating system functionality. The design is Unix-like, although the error handling is Go-like; failing calls return values of type error rather than error numbers. Often, more information is available within the error. For example, if a call that takes a file name fails, such as Open or Stat, the error will include the failing file name when printed and will be of type *PathError, which may be unpacked for more information.</source>
          <target state="translated">包os提供了一个独立于平台的操作系统功能接口。它的设计类似于Unix,尽管错误处理类似于Go;失败的调用会返回错误类型的值,而不是错误号。通常情况下,错误中会有更多信息。例如,如果一个取文件名的调用失败了,如Open或Stat,那么打印时错误将包括失败的文件名,并且类型为*PathError,可以解包获取更多信息。</target>
        </trans-unit>
        <trans-unit id="04c8aee5e23a788ea2bcb38b074f985eac2786a8" translate="yes" xml:space="preserve">
          <source>Package palette</source>
          <target state="translated">托盘包装</target>
        </trans-unit>
        <trans-unit id="cf2f1921f30936ace0261b5025892d44ffab8eb3" translate="yes" xml:space="preserve">
          <source>Package palette provides standard color palettes.</source>
          <target state="translated">包装托盘提供标准色托盘。</target>
        </trans-unit>
        <trans-unit id="0242c171ef1c568c8ae1ca39756ba02bb57c4a9d" translate="yes" xml:space="preserve">
          <source>Package parse</source>
          <target state="translated">解析包</target>
        </trans-unit>
        <trans-unit id="417bd6bafe4778a0805898be461125c5d876274b" translate="yes" xml:space="preserve">
          <source>Package parse builds parse trees for templates as defined by text/template and html/template.</source>
          <target state="translated">Package parse为text/template和html/template定义的模板建立解析树。</target>
        </trans-unit>
        <trans-unit id="9c526058ffd19e7a03ef67d38acb87f2af58bf19" translate="yes" xml:space="preserve">
          <source>Package parse builds parse trees for templates as defined by text/template and html/template. Clients should use those packages to construct templates rather than this one, which provides shared internal data structures not intended for general use.</source>
          <target state="translated">Package parse为text/template和html/template定义的模板构建解析树。客户端应该使用这些包来构建模板,而不是使用这个包,因为它提供了共享的内部数据结构,并不打算用于一般用途。</target>
        </trans-unit>
        <trans-unit id="66cc9b613eb8bc3269dbf5d021ee51da1590e18b" translate="yes" xml:space="preserve">
          <source>Package parser</source>
          <target state="translated">解析器包</target>
        </trans-unit>
        <trans-unit id="6de3fe85bffa2dfbd3030929ab437e9f7594c3fc" translate="yes" xml:space="preserve">
          <source>Package parser implements a parser for Go source files. Input may be provided in a variety of forms (see the various Parse* functions); the output is an abstract syntax tree (AST) representing the Go source. The parser is invoked through one of the Parse* functions.</source>
          <target state="translated">Package parser 实现了一个 Go 源文件的解析器,它可以以各种形式提供输入 (参见各种 Parse*函数);输出是代表 Go 源文件的抽象语法树 (AST)。输入可以以各种形式提供(参见各种 Parse*函数);输出是代表 Go 源文件的抽象语法树(AST)。该解析器是通过Parse*函数之一来调用的。</target>
        </trans-unit>
        <trans-unit id="3373a46035bdd1245ec67bf0a2c65e10dfd0f4ad" translate="yes" xml:space="preserve">
          <source>Package path</source>
          <target state="translated">包装路径</target>
        </trans-unit>
        <trans-unit id="db836e38d040774081537fe657365110292aec91" translate="yes" xml:space="preserve">
          <source>Package path implements utility routines for manipulating slash-separated paths.</source>
          <target state="translated">包路径实现了用于操作斜线分离路径的实用程序。</target>
        </trans-unit>
        <trans-unit id="9d24a47a68584686a4df522a7f5e3f005ddc259f" translate="yes" xml:space="preserve">
          <source>Package pe</source>
          <target state="translated">包裹同行</target>
        </trans-unit>
        <trans-unit id="ce301de224be1f8c3d1c1c5dfcb12d983b03bd77" translate="yes" xml:space="preserve">
          <source>Package pe implements access to PE (Microsoft Windows Portable Executable) files.</source>
          <target state="translated">包pe实现了对PE(Microsoft Windows Portable Executable)文件的访问。</target>
        </trans-unit>
        <trans-unit id="e152e56cf87bc67e469bb5da6106c6e936b14368" translate="yes" xml:space="preserve">
          <source>Package pem</source>
          <target state="translated">包装pem</target>
        </trans-unit>
        <trans-unit id="f41f7d23d767dfe9afe9b6e7dfc54ee5c677365e" translate="yes" xml:space="preserve">
          <source>Package pem implements the PEM data encoding, which originated in Privacy Enhanced Mail.</source>
          <target state="translated">包pem实现了PEM数据编码,它起源于隐私增强邮件。</target>
        </trans-unit>
        <trans-unit id="0d4c900b99f74302177b2bea20055842f0e52c09" translate="yes" xml:space="preserve">
          <source>Package pem implements the PEM data encoding, which originated in Privacy Enhanced Mail. The most common use of PEM encoding today is in TLS keys and certificates. See RFC 1421.</source>
          <target state="translated">包pem实现了PEM数据编码,它起源于隐私增强邮件。目前最常见的PEM编码是在TLS密钥和证书中使用。参见RFC 1421。</target>
        </trans-unit>
        <trans-unit id="38d910b9de0ef4ae8b19f042eb74647af6042913" translate="yes" xml:space="preserve">
          <source>Package pkix</source>
          <target state="translated">包装 pkix</target>
        </trans-unit>
        <trans-unit id="dc33e58126376b6213633925214424947582c3a3" translate="yes" xml:space="preserve">
          <source>Package pkix contains shared, low level structures used for ASN.1 parsing and serialization of X.509 certificates, CRL and OCSP.</source>
          <target state="translated">包pkix包含了用于ASN.1解析和序列化X.509证书、CRL和OCSP的共享、低级结构。</target>
        </trans-unit>
        <trans-unit id="67b226d60325490b566c70691138cd1c6d21b193" translate="yes" xml:space="preserve">
          <source>Package plan9obj</source>
          <target state="translated">包plan9obj</target>
        </trans-unit>
        <trans-unit id="4665855b57b9b8af3bee702ebd462244986f00bf" translate="yes" xml:space="preserve">
          <source>Package plan9obj implements access to Plan 9 a.out object files.</source>
          <target state="translated">包plan9obj实现了对Plan 9 a.out对象文件的访问。</target>
        </trans-unit>
        <trans-unit id="3cd1d7122e8b0e42817d81ce5dc7226d253ae194" translate="yes" xml:space="preserve">
          <source>Package plugin</source>
          <target state="translated">插件包</target>
        </trans-unit>
        <trans-unit id="723391b754af075d19bf19a6d72b4aca8b612706" translate="yes" xml:space="preserve">
          <source>Package plugin implements loading and symbol resolution of Go plugins.</source>
          <target state="translated">包插件实现了Go插件的加载和符号解析。</target>
        </trans-unit>
        <trans-unit id="18f40a30c66d89382a5e8d5c5fa97aad2d850e59" translate="yes" xml:space="preserve">
          <source>Package png</source>
          <target state="translated">包装 png</target>
        </trans-unit>
        <trans-unit id="7d75e3a56a64d92564c27a07179bd65f150fd42a" translate="yes" xml:space="preserve">
          <source>Package png implements a PNG image decoder and encoder.</source>
          <target state="translated">包png实现了一个PNG图像解码器和编码器。</target>
        </trans-unit>
        <trans-unit id="bbb9e684e1674ad5ea70ff8d94149cfba70c0322" translate="yes" xml:space="preserve">
          <source>Package pprof</source>
          <target state="translated">包pprof</target>
        </trans-unit>
        <trans-unit id="6b696f2047997085f203f8e5ea4ab96764716e57" translate="yes" xml:space="preserve">
          <source>Package pprof serves via its HTTP server runtime profiling data in the format expected by the pprof visualization tool.</source>
          <target state="translated">包pprof通过其HTTP服务器运行时以pprof可视化工具所期望的格式提供剖析数据。</target>
        </trans-unit>
        <trans-unit id="f35eefcb5de07eee157ab4d725a5a9c718348ce1" translate="yes" xml:space="preserve">
          <source>Package pprof writes runtime profiling data in the format expected by the pprof visualization tool.</source>
          <target state="translated">包pprof以pprof可视化工具所期望的格式写入运行时剖析数据。</target>
        </trans-unit>
        <trans-unit id="bd0a361bc1df19412b2288989fa693bf033d1e94" translate="yes" xml:space="preserve">
          <source>Package printer</source>
          <target state="translated">包装打印机</target>
        </trans-unit>
        <trans-unit id="7508f680f0bd7ace72d4e37d8bf4124dd8618769" translate="yes" xml:space="preserve">
          <source>Package printer implements printing of AST nodes.</source>
          <target state="translated">包装打印机实现了AST节点的打印。</target>
        </trans-unit>
        <trans-unit id="5a2f6f777ac49a0a6e1a6283c8172aaf45ada261" translate="yes" xml:space="preserve">
          <source>Package quick</source>
          <target state="translated">包装快速</target>
        </trans-unit>
        <trans-unit id="b11b2a9f0787ff668038fd60730c27709091efd5" translate="yes" xml:space="preserve">
          <source>Package quick implements utility functions to help with black box testing.</source>
          <target state="translated">包快速实现实用功能,帮助进行黑盒测试。</target>
        </trans-unit>
        <trans-unit id="5a939d420f6017187bd02b98ed377adb9120365c" translate="yes" xml:space="preserve">
          <source>Package quotedprintable</source>
          <target state="translated">套餐报价可打印</target>
        </trans-unit>
        <trans-unit id="195c159d436820f6a7d39ac4579d1905b0c74821" translate="yes" xml:space="preserve">
          <source>Package quotedprintable implements quoted-printable encoding as specified by RFC 2045.</source>
          <target state="translated">包quotedprintable实现了RFC 2045指定的引号可打印编码。</target>
        </trans-unit>
        <trans-unit id="d7dd09c477f4383baa2235b2b5f02beab77e4389" translate="yes" xml:space="preserve">
          <source>Package race</source>
          <target state="translated">包场赛</target>
        </trans-unit>
        <trans-unit id="a5c1c2be3bea40e10437334b0813837bf205008a" translate="yes" xml:space="preserve">
          <source>Package race implements data race detection logic.</source>
          <target state="translated">包竞赛实现了数据竞赛检测逻辑。</target>
        </trans-unit>
        <trans-unit id="96ff3f6524e366a1f85999a9889633b5758b7e5b" translate="yes" xml:space="preserve">
          <source>Package race implements data race detection logic. No public interface is provided. For details about the race detector see &lt;a href=&quot;https://golang.org/doc/articles/race_detector.html&quot;&gt;https://golang.org/doc/articles/race_detector.html&lt;/a&gt;</source>
          <target state="translated">包竞争实现了数据竞争检测逻辑。没有提供公共接口。有关种族探测器的详细信息，请参见&lt;a href=&quot;https://golang.org/doc/articles/race_detector.html&quot;&gt;https://golang.org/doc/articles/race_detector.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="83c163892e45f479d6597f9c22d2df740381ff44" translate="yes" xml:space="preserve">
          <source>Package rand</source>
          <target state="translated">包裹rand</target>
        </trans-unit>
        <trans-unit id="cc752fea52bb25978322b7eaf4569384e9741709" translate="yes" xml:space="preserve">
          <source>Package rand implements a cryptographically secure random number generator.</source>
          <target state="translated">包rand实现了一个加密安全的随机数发生器。</target>
        </trans-unit>
        <trans-unit id="b3b18e540dfae96ee4bfa44eff2fe6364db2a649" translate="yes" xml:space="preserve">
          <source>Package rand implements pseudo-random number generators.</source>
          <target state="translated">包rand实现了伪随机数生成器。</target>
        </trans-unit>
        <trans-unit id="d31a1689b285cdf109ef7adc6ecc82f9e08e66cb" translate="yes" xml:space="preserve">
          <source>Package rc4</source>
          <target state="translated">包材rc4</target>
        </trans-unit>
        <trans-unit id="9d9070b30c94fbd8ece92c972cff45482e84ea73" translate="yes" xml:space="preserve">
          <source>Package rc4 implements RC4 encryption, as defined in Bruce Schneier's Applied Cryptography.</source>
          <target state="translated">包rc4实现了Bruce Schneier的Applied Cryptography中定义的RC4加密。</target>
        </trans-unit>
        <trans-unit id="16eeac7c41dd94aba1ce95ebc38efce516d7ede5" translate="yes" xml:space="preserve">
          <source>Package reflect</source>
          <target state="translated">包装反映</target>
        </trans-unit>
        <trans-unit id="ea99463dc27a541bcea8f216ce8b537d53c786f4" translate="yes" xml:space="preserve">
          <source>Package reflect implements run-time reflection, allowing a program to manipulate objects with arbitrary types. The typical use is to take a value with static type interface{} and extract its dynamic type information by calling TypeOf, which returns a Type.</source>
          <target state="translated">包reflect实现了运行时反射,允许程序操作任意类型的对象。典型的用法是取一个具有静态类型interface{}的值,并通过调用TypeOf提取其动态类型信息,TypeOf返回一个Type。</target>
        </trans-unit>
        <trans-unit id="f6906a6b73a6d72eeebe325c95a7fd2b66657106" translate="yes" xml:space="preserve">
          <source>Package reflect's Value methods named Pointer and UnsafeAddr return type uintptr instead of unsafe.Pointer to keep callers from changing the result to an arbitrary type without first importing &quot;unsafe&quot;. However, this means that the result is fragile and must be converted to Pointer immediately after making the call, in the same expression:</source>
          <target state="translated">包reflect的名为Pointer和UnsafeAddr的Value方法返回类型为uintptr而不是unsafe.Pointer,以防止调用者在没有先导入 &quot;unsafe &quot;的情况下将结果改为任意类型。然而,这意味着结果是脆弱的,必须在进行调用后立即转换为Pointer,在同一个表达式中。</target>
        </trans-unit>
        <trans-unit id="296c31de17cebe68d7ff50dd54df6ff57cb7cdbd" translate="yes" xml:space="preserve">
          <source>Package regexp</source>
          <target state="translated">包regexp</target>
        </trans-unit>
        <trans-unit id="8db88ff2fae80db5efc49abe986d69219c995b2a" translate="yes" xml:space="preserve">
          <source>Package regexp implements regular expression search.</source>
          <target state="translated">包regexp实现了正则表达式搜索。</target>
        </trans-unit>
        <trans-unit id="8f3fe52956764f5ab5a7617348d70f67990e27be" translate="yes" xml:space="preserve">
          <source>Package ring</source>
          <target state="translated">包装环</target>
        </trans-unit>
        <trans-unit id="24781dde0d3396b2f7a5d8de96bf17e6c6511838" translate="yes" xml:space="preserve">
          <source>Package ring implements operations on circular lists.</source>
          <target state="translated">包环实现了对循环列表的操作。</target>
        </trans-unit>
        <trans-unit id="4ac8d28b6f5f90e5f57c49bd02cae6ff1cc3103e" translate="yes" xml:space="preserve">
          <source>Package rpc</source>
          <target state="translated">包材 rpc</target>
        </trans-unit>
        <trans-unit id="29c7a976ba21e5e3d539285fcef131a0900d481a" translate="yes" xml:space="preserve">
          <source>Package rpc provides access to the exported methods of an object across a network or other I/O connection.</source>
          <target state="translated">包rpc提供了通过网络或其他I/O连接访问对象的导出方法。</target>
        </trans-unit>
        <trans-unit id="89036cae903feb95d9bf22ecb370849d3856aa14" translate="yes" xml:space="preserve">
          <source>Package rpc provides access to the exported methods of an object across a network or other I/O connection. A server registers an object, making it visible as a service with the name of the type of the object. After registration, exported methods of the object will be accessible remotely. A server may register multiple objects (services) of different types but it is an error to register multiple objects of the same type.</source>
          <target state="translated">包rpc提供了通过网络或其他I/O连接访问对象的导出方法。服务器注册一个对象,使其以对象类型的名称作为服务可见。注册后,将可以远程访问对象的导出方法。一个服务器可以注册多个不同类型的对象(服务),但注册多个相同类型的对象是错误的。</target>
        </trans-unit>
        <trans-unit id="3dd9b23cfd1948413bbf148dd0474b59ad766e9f" translate="yes" xml:space="preserve">
          <source>Package rsa</source>
          <target state="translated">包裹 rsa</target>
        </trans-unit>
        <trans-unit id="9ba02848b97a1b268666b78b127c28a6770b462d" translate="yes" xml:space="preserve">
          <source>Package rsa implements RSA encryption as specified in PKCS#1.</source>
          <target state="translated">包rsa实现了PKCS#1中指定的RSA加密。</target>
        </trans-unit>
        <trans-unit id="4ebd8f5b99b65c7601e3f5f2bad88bd7ec2de054" translate="yes" xml:space="preserve">
          <source>Package runtime</source>
          <target state="translated">包装运行时间</target>
        </trans-unit>
        <trans-unit id="469b95dee031c267f910a82eae21961d70838630" translate="yes" xml:space="preserve">
          <source>Package runtime contains operations that interact with Go's runtime system, such as functions to control goroutines. It also includes the low-level type information used by the reflect package; see reflect's documentation for the programmable interface to the run-time type system.</source>
          <target state="translated">包运行时包含与Go的运行时系统交互的操作,例如控制goroutine的函数。它还包括反射包使用的低级类型信息;关于运行时类型系统的可编程接口,请参阅反射的文档。</target>
        </trans-unit>
        <trans-unit id="82776b2ed593a3609079c4ab84f51091ff8daaf8" translate="yes" xml:space="preserve">
          <source>Package scanner</source>
          <target state="translated">包装扫描器</target>
        </trans-unit>
        <trans-unit id="37829fd57a47182e751d5d54158a385e61ab833d" translate="yes" xml:space="preserve">
          <source>Package scanner implements a scanner for Go source text. It takes a []byte as source which can then be tokenized through repeated calls to the Scan method.</source>
          <target state="translated">包 scanner 实现了一个围棋源文本的扫描器,它将一个[]字节作为源文本,然后通过重复调用 Scan 方法进行标记化。它以[]字节作为源文本,然后通过重复调用Scan方法将其标记化。</target>
        </trans-unit>
        <trans-unit id="cff89fb02b03b32b0811fa214e2e7a1126ee135b" translate="yes" xml:space="preserve">
          <source>Package scanner provides a scanner and tokenizer for UTF-8-encoded text. It takes an io.Reader providing the source, which then can be tokenized through repeated calls to the Scan function. For compatibility with existing tools, the NUL character is not allowed. If the first character in the source is a UTF-8 encoded byte order mark (BOM), it is discarded.</source>
          <target state="translated">包 scanner 提供了一个 UTF-8 编码文本的扫描器和标记器,它需要一个 io.Reader 提供源码,然后通过重复调用 Scan 函数对源码进行标记。它需要一个io.Reader提供源码,然后通过重复调用Scan函数对其进行标记。为了与现有工具兼容,不允许使用NUL字符。如果源文件中的第一个字符是UTF-8编码的字节序标记(BOM),它将被丢弃。</target>
        </trans-unit>
        <trans-unit id="6e0759392e3584cd8a2a3d2a6c4931673b5e35b2" translate="yes" xml:space="preserve">
          <source>Package sha1</source>
          <target state="translated">包Sha1</target>
        </trans-unit>
        <trans-unit id="db1a6662e07e0565a4b3c55f6347a0baeacc49fb" translate="yes" xml:space="preserve">
          <source>Package sha1 implements the SHA-1 hash algorithm as defined in RFC 3174.</source>
          <target state="translated">包 sha1 实现了 RFC 3174 中定义的 SHA-1 哈希算法。</target>
        </trans-unit>
        <trans-unit id="f6ad23ee3ab99920af8ac5cfc82080a0e1b3b09f" translate="yes" xml:space="preserve">
          <source>Package sha256</source>
          <target state="translated">包裹sha256</target>
        </trans-unit>
        <trans-unit id="c9317efee8c5fefb81226a055344cf996daf2874" translate="yes" xml:space="preserve">
          <source>Package sha256 implements the SHA224 and SHA256 hash algorithms as defined in FIPS 180-4.</source>
          <target state="translated">包 sha256 实现了 FIPS 180-4 中定义的 SHA224 和 SHA256 哈希算法。</target>
        </trans-unit>
        <trans-unit id="4e4623212d4095d72a62997c9796888b7d1b95c9" translate="yes" xml:space="preserve">
          <source>Package sha512</source>
          <target state="translated">包裹sha512</target>
        </trans-unit>
        <trans-unit id="65d83f8c0979c324f75579653a6e20dcc05fc8a1" translate="yes" xml:space="preserve">
          <source>Package sha512 implements the SHA-384, SHA-512, SHA-512/224, and SHA-512/256 hash algorithms as defined in FIPS 180-4.</source>
          <target state="translated">包 sha512 实现了 FIPS 180-4 中定义的 SHA-384、SHA-512、SHA-512/224 和 SHA-512/256 哈希算法。</target>
        </trans-unit>
        <trans-unit id="80e54559e475073190cfed119c9847e346d01634" translate="yes" xml:space="preserve">
          <source>Package signal</source>
          <target state="translated">包装信号</target>
        </trans-unit>
        <trans-unit id="59f2e9e157e5e2c56d4bb35edf223ce0a7c75cdf" translate="yes" xml:space="preserve">
          <source>Package signal implements access to incoming signals.</source>
          <target state="translated">包信号实现对传入信号的访问。</target>
        </trans-unit>
        <trans-unit id="0e49eafb9bb1f34b1ff3d2c9a1f4a0ec52ecdba3" translate="yes" xml:space="preserve">
          <source>Package signal will not block sending to c: the caller must ensure that c has sufficient buffer space to keep up with the expected signal rate. For a channel used for notification of just one signal value, a buffer of size 1 is sufficient.</source>
          <target state="translated">包信号不会阻止向c发送:调用者必须确保c有足够的缓冲空间来跟上预期的信号速率。对于一个只用于通知一个信号值的通道,大小为1的缓冲区就足够了。</target>
        </trans-unit>
        <trans-unit id="fc75b3c455c2cde737da3fcce8266dd282fe7922" translate="yes" xml:space="preserve">
          <source>Package smtp</source>
          <target state="translated">软件包smtp</target>
        </trans-unit>
        <trans-unit id="b50b30b8ea306091fbb446aaa4ed61109401fff0" translate="yes" xml:space="preserve">
          <source>Package smtp implements the Simple Mail Transfer Protocol as defined in RFC 5321.</source>
          <target state="translated">包smtp实现了RFC 5321中定义的简单邮件传输协议。</target>
        </trans-unit>
        <trans-unit id="1fe6e79dac787b0d56b7abea30c16ebab918d57e" translate="yes" xml:space="preserve">
          <source>Package smtp implements the Simple Mail Transfer Protocol as defined in RFC 5321. It also implements the following extensions:</source>
          <target state="translated">包smtp实现了RFC 5321中定义的简单邮件传输协议。它还实现了以下扩展。</target>
        </trans-unit>
        <trans-unit id="71f7fab9acf61b6109216266ded759b751fdf3ba" translate="yes" xml:space="preserve">
          <source>Package sort</source>
          <target state="translated">包装分类</target>
        </trans-unit>
        <trans-unit id="0962324992fa79918c2dd6cf47c8b372c511e5ff" translate="yes" xml:space="preserve">
          <source>Package sort provides primitives for sorting slices and user-defined collections.</source>
          <target state="translated">包排序提供了对切片和用户定义的集合进行排序的基元。</target>
        </trans-unit>
        <trans-unit id="9bd1b867b8811e4a5059325426012d1ac3fbe070" translate="yes" xml:space="preserve">
          <source>Package sql</source>
          <target state="translated">包 sql</target>
        </trans-unit>
        <trans-unit id="9e262166973b441cf1a6b45fe03044818008c94a" translate="yes" xml:space="preserve">
          <source>Package sql provides a generic interface around SQL (or SQL-like) databases.</source>
          <target state="translated">包sql提供了一个围绕SQL(或类SQL)数据库的通用接口。</target>
        </trans-unit>
        <trans-unit id="8b57c7d54ee7ea7e0a45d8c13b8a29358c7a1a59" translate="yes" xml:space="preserve">
          <source>Package strconv</source>
          <target state="translated">strconv包</target>
        </trans-unit>
        <trans-unit id="3c44c13248967ffe512eec5e12e0ac2d83aaabcb" translate="yes" xml:space="preserve">
          <source>Package strconv implements conversions to and from string representations of basic data types.</source>
          <target state="translated">包 strconv 实现了基本数据类型的字符串表示之间的转换。</target>
        </trans-unit>
        <trans-unit id="28ec3487bac9bff1cd40dd5bfdaac3e5f0f7e66b" translate="yes" xml:space="preserve">
          <source>Package strings</source>
          <target state="translated">包装字符串</target>
        </trans-unit>
        <trans-unit id="30f2d5d3c8bcd3201c529ed7194820953f047942" translate="yes" xml:space="preserve">
          <source>Package strings implements simple functions to manipulate UTF-8 encoded strings.</source>
          <target state="translated">包strings实现了简单的函数来操作UTF-8编码的字符串。</target>
        </trans-unit>
        <trans-unit id="5f3a2aafe35539648afeeb350719fa852f88f7f2" translate="yes" xml:space="preserve">
          <source>Package subtle</source>
          <target state="translated">包装精巧</target>
        </trans-unit>
        <trans-unit id="af533feda0fe1c8229caece2fdfd190444424ea5" translate="yes" xml:space="preserve">
          <source>Package subtle implements functions that are often useful in cryptographic code but require careful thought to use correctly.</source>
          <target state="translated">Package subtle实现了在加密代码中经常有用,但需要仔细思考才能正确使用的函数。</target>
        </trans-unit>
        <trans-unit id="39d17df25323190f4cc53202e597d56f35dfee6b" translate="yes" xml:space="preserve">
          <source>Package suffixarray</source>
          <target state="translated">后缀array包</target>
        </trans-unit>
        <trans-unit id="7980bb666cc38cba6c4aaf92417db33415ccfaa1" translate="yes" xml:space="preserve">
          <source>Package suffixarray implements substring search in logarithmic time using an in-memory suffix array.</source>
          <target state="translated">包 suffixarray 使用内存中的后缀数组实现了对数时间的子串搜索。</target>
        </trans-unit>
        <trans-unit id="346a1d63b09ad3c0b05c14691bf67091b87cabe5" translate="yes" xml:space="preserve">
          <source>Package sync</source>
          <target state="translated">包装同步</target>
        </trans-unit>
        <trans-unit id="aea6d23bbc4ed584bf5042d03479be247cbf1087" translate="yes" xml:space="preserve">
          <source>Package sync provides basic synchronization primitives such as mutual exclusion locks. Other than the Once and WaitGroup types, most are intended for use by low-level library routines. Higher-level synchronization is better done via channels and communication.</source>
          <target state="translated">包 sync 提供了基本的同步基元,如互斥锁。除了Once和WaitGroup类型之外,大多数都是供低级库例程使用的。更高层次的同步最好通过通道和通信来完成。</target>
        </trans-unit>
        <trans-unit id="fe4c913bf7c7c5e8773000f095ebe490accad3a2" translate="yes" xml:space="preserve">
          <source>Package syntax</source>
          <target state="translated">包装语法</target>
        </trans-unit>
        <trans-unit id="a713eae229dc7c92d21e8a224e10ceffb09512c2" translate="yes" xml:space="preserve">
          <source>Package syntax parses regular expressions into parse trees and compiles parse trees into programs.</source>
          <target state="translated">包语法将正则表达式解析成解析树,并将解析树编译成程序。</target>
        </trans-unit>
        <trans-unit id="a70c7eb9cc685b98a0a5536eddbf6dbc0cba4ac8" translate="yes" xml:space="preserve">
          <source>Package syntax parses regular expressions into parse trees and compiles parse trees into programs. Most clients of regular expressions will use the facilities of package regexp (such as Compile and Match) instead of this package.</source>
          <target state="translated">包语法将正则表达式解析成解析树,并将解析树编译成程序。大多数正则表达式的客户端会使用包regexp的设施(如编译和匹配)来代替这个包。</target>
        </trans-unit>
        <trans-unit id="11e76797e8363318c05ceb15b2d2b47e39353883" translate="yes" xml:space="preserve">
          <source>Package sys</source>
          <target state="translated">包装系统</target>
        </trans-unit>
        <trans-unit id="d21a124cf49a1b492319130693efdb9b8a34c61d" translate="yes" xml:space="preserve">
          <source>Package syscall</source>
          <target state="translated">包装系统调用</target>
        </trans-unit>
        <trans-unit id="0f53f1418ab827df34bf754bfae7d8d0c010c7cc" translate="yes" xml:space="preserve">
          <source>Package syscall contains an interface to the low-level operating system primitives. The details vary depending on the underlying system, and by default, godoc will display the syscall documentation for the current system. If you want godoc to display syscall documentation for another system, set $GOOS and $GOARCH to the desired system. For example, if you want to view documentation for freebsd/arm on linux/amd64, set $GOOS to freebsd and $GOARCH to arm. The primary use of syscall is inside other packages that provide a more portable interface to the system, such as &quot;os&quot;, &quot;time&quot; and &quot;net&quot;. Use those packages rather than this one if you can. For details of the functions and data types in this package consult the manuals for the appropriate operating system. These calls return err == nil to indicate success; otherwise err is an operating system error describing the failure. On most systems, that error has type syscall.Errno.</source>
          <target state="translated">包syscall包含一个低级操作系统基元的接口。其细节取决于底层系统,默认情况下,godoc将显示当前系统的syscall文档,如果想让godoc显示另一个系统的syscall文档,可以将$GOOS和$GOARCH设置为所需系统。如果您想让 godoc 显示另一个系统的 syscall 文档,请将 $GOOS 和 $GOARCH 设置为所需系统。例如,如果您想在linux/amd64上查看freebsd/arm的文档,就把$GOOS设置为freebsd,把$GOARCH设置为arm。syscall的主要用途是在其他提供更便携的系统接口的包里面,比如 &quot;os&quot;、&quot;time &quot;和 &quot;net&quot;。如果可以的话,请使用这些包而不是这个包。关于这个包中的函数和数据类型的细节,请查阅相应操作系统的手册。这些调用返回err ==nil表示成功,否则err是一个描述失败的操作系统错误。在大多数系统中,该错误的类型为syscall.Errno。</target>
        </trans-unit>
        <trans-unit id="f90ba2ae4e2d681143f3d41fb43a2f79b7c3197e" translate="yes" xml:space="preserve">
          <source>Package syslog</source>
          <target state="translated">系统日志包</target>
        </trans-unit>
        <trans-unit id="396038b0a959cfae15beae20a0f48bc80b80cf43" translate="yes" xml:space="preserve">
          <source>Package syslog provides a simple interface to the system log service.</source>
          <target state="translated">包syslog提供了一个简单的系统日志服务接口。</target>
        </trans-unit>
        <trans-unit id="d1f55ec1734bdf22b075380ad35ee09a577ec002" translate="yes" xml:space="preserve">
          <source>Package syslog provides a simple interface to the system log service. It can send messages to the syslog daemon using UNIX domain sockets, UDP or TCP.</source>
          <target state="translated">包syslog提供了一个简单的系统日志服务的接口,它可以使用UNIX域套接字、UDP或TCP向syslog守护进程发送消息。它可以使用UNIX域套接字、UDP或TCP向syslog守护进程发送消息。</target>
        </trans-unit>
        <trans-unit id="007cb2c9dc06f8f699c331e9716d599817f048b5" translate="yes" xml:space="preserve">
          <source>Package tabwriter</source>
          <target state="translated">包tabwriter</target>
        </trans-unit>
        <trans-unit id="f7841eb33056b73d4a3597207ce6dc7e384c846d" translate="yes" xml:space="preserve">
          <source>Package tabwriter implements a write filter (tabwriter.Writer) that translates tabbed columns in input into properly aligned text.</source>
          <target state="translated">包tabwriter实现了一个写过滤器(tabwriter.Writer),它可以将输入中的标签栏翻译成正确对齐的文本。</target>
        </trans-unit>
        <trans-unit id="bec4ed72f4fd10dfa620d0e5687ebc626dc193a1" translate="yes" xml:space="preserve">
          <source>Package tar</source>
          <target state="translated">焦油包</target>
        </trans-unit>
        <trans-unit id="b3d0f0f238631cf9655cf5816e9f94b6db370098" translate="yes" xml:space="preserve">
          <source>Package tar implements access to tar archives.</source>
          <target state="translated">包 tar 实现了对 tar 存档的访问。</target>
        </trans-unit>
        <trans-unit id="7ac2ec5b1841ff39f85ad1d4687cc3abfa906a39" translate="yes" xml:space="preserve">
          <source>Package template</source>
          <target state="translated">包装模板</target>
        </trans-unit>
        <trans-unit id="aba87a8492b37ccf916bdea97ed3b469ce8125f0" translate="yes" xml:space="preserve">
          <source>Package template (html/template) implements data-driven templates for generating HTML output safe against code injection.</source>
          <target state="translated">包模板(html/template)实现了数据驱动的模板,用于生成防止代码注入的HTML输出。</target>
        </trans-unit>
        <trans-unit id="9776451c8a221b1dfd29d6efbaff6d2de3fbf0aa" translate="yes" xml:space="preserve">
          <source>Package template (html/template) implements data-driven templates for generating HTML output safe against code injection. It provides the same interface as package text/template and should be used instead of text/template whenever the output is HTML.</source>
          <target state="translated">包模板 (html/template)实现了数据驱动的模板,用于生成防止代码注入的 HTML 输出。它提供了与包text/template相同的接口,只要输出的是HTML,就应该使用它来代替text/template。</target>
        </trans-unit>
        <trans-unit id="12fb252e998414c68ff5f9998dbcdff046a0fe8f" translate="yes" xml:space="preserve">
          <source>Package template implements data-driven templates for generating textual output.</source>
          <target state="translated">包模板实现了数据驱动的模板,用于生成文本输出。</target>
        </trans-unit>
        <trans-unit id="8f2f8d22daa6bdd34d84049e31c95592348695b8" translate="yes" xml:space="preserve">
          <source>Package testing</source>
          <target state="translated">包装测试</target>
        </trans-unit>
        <trans-unit id="9c91ae9ffc226daabd50a55612fc0b4ce9280216" translate="yes" xml:space="preserve">
          <source>Package testing provides support for automated testing of Go packages. It is intended to be used in concert with the &amp;ldquo;go test&amp;rdquo; command, which automates execution of any function of the form</source>
          <target state="translated">软件包测试为Go软件包的自动化测试提供支持。它旨在与&amp;ldquo; go test&amp;rdquo;命令配合使用，该命令可自动执行表格中的任何功能</target>
        </trans-unit>
        <trans-unit id="10fa2d9109fabc6fd9b96730e5f6c29a2ec7c36f" translate="yes" xml:space="preserve">
          <source>Package textproto</source>
          <target state="translated">包textproto</target>
        </trans-unit>
        <trans-unit id="3dc8f07b5e53239f3d16cf68abc4c177c52d10af" translate="yes" xml:space="preserve">
          <source>Package textproto implements generic support for text-based request/response protocols in the style of HTTP, NNTP, and SMTP.</source>
          <target state="translated">包textproto实现了对基于文本的请求/响应协议的通用支持,风格为HTTP、NNTP和SMTP。</target>
        </trans-unit>
        <trans-unit id="e0896056124ecab0339d61326880bfb542bc907f" translate="yes" xml:space="preserve">
          <source>Package time</source>
          <target state="translated">包装时间</target>
        </trans-unit>
        <trans-unit id="5305dc12a988a4ce552cf3341269cdd34206dbc0" translate="yes" xml:space="preserve">
          <source>Package time provides functionality for measuring and displaying time.</source>
          <target state="translated">包装时间提供测量和显示时间的功能。</target>
        </trans-unit>
        <trans-unit id="2870bb3df8e650dbc1e60be06a2c5ae58d30789e" translate="yes" xml:space="preserve">
          <source>Package tls</source>
          <target state="translated">包裹tls</target>
        </trans-unit>
        <trans-unit id="7f75931d43fdfef0a07153ddf14ad51258da3f69" translate="yes" xml:space="preserve">
          <source>Package tls partially implements TLS 1.2, as specified in RFC 5246, and TLS 1.3, as specified in RFC 8446.</source>
          <target state="translated">包tls部分实现了RFC 5246中规定的TLS 1.2和RFC 8446中规定的TLS 1.3。</target>
        </trans-unit>
        <trans-unit id="71cf571a2e2d9b69987d70384e5e0a349bbf13f6" translate="yes" xml:space="preserve">
          <source>Package token</source>
          <target state="translated">包裹令牌</target>
        </trans-unit>
        <trans-unit id="3de5e73d48412b9fa410e9f04a2075f5ec3be3f1" translate="yes" xml:space="preserve">
          <source>Package token defines constants representing the lexical tokens of the Go programming language and basic operations on tokens (printing, predicates).</source>
          <target state="translated">包令牌定义了代表Go编程语言的词性令牌和对令牌的基本操作(打印、谓词)的常量。</target>
        </trans-unit>
        <trans-unit id="7e450a321c355f3612aca2e34d0a073905f6e6ac" translate="yes" xml:space="preserve">
          <source>Package trace</source>
          <target state="translated">包装跟踪</target>
        </trans-unit>
        <trans-unit id="025720b70dde0a472ee8ed25e4b132eb460e89d0" translate="yes" xml:space="preserve">
          <source>Package trace contains facilities for programs to generate traces for the Go execution tracer.</source>
          <target state="translated">包trace包含了为Go执行跟踪器生成跟踪程序的功能。</target>
        </trans-unit>
        <trans-unit id="3e63d422df1350bbdcfb3a251a3dd0dcdbbc02d1" translate="yes" xml:space="preserve">
          <source>Package trace provides user annotation APIs that can be used to log interesting events during execution.</source>
          <target state="translated">包跟踪提供了用户注释API,可以用来记录执行过程中的有趣事件。</target>
        </trans-unit>
        <trans-unit id="b954397c4a071e1cc2e5aec57815cae94675ccf5" translate="yes" xml:space="preserve">
          <source>Package types</source>
          <target state="translated">包装类型</target>
        </trans-unit>
        <trans-unit id="046779ebad1597aa59c89817459594972c347086" translate="yes" xml:space="preserve">
          <source>Package types declares the data types and implements the algorithms for type-checking of Go packages. Use Config.Check to invoke the type checker for a package. Alternatively, create a new type checker with NewChecker and invoke it incrementally by calling Checker.Files.</source>
          <target state="translated">包类型声明了数据类型,并实现了用于Go包类型检查的算法。使用 Config.Check 来调用包的类型检查器。或者,使用NewChecker创建一个新的类型检查器,并通过调用Checker.Files来递增调用它。</target>
        </trans-unit>
        <trans-unit id="ab9e4b9642ec1eafa3034c351ee1c61944a1812d" translate="yes" xml:space="preserve">
          <source>Package unicode</source>
          <target state="translated">包的unicode</target>
        </trans-unit>
        <trans-unit id="1d363f9997c96fdcfdb92764e225e66454bc7d90" translate="yes" xml:space="preserve">
          <source>Package unicode provides data and functions to test some properties of Unicode code points.</source>
          <target state="translated">包unicode提供数据和函数来测试Unicode码点的一些属性。</target>
        </trans-unit>
        <trans-unit id="ed360d93d2eb692bc3647fbb297fd557060587f2" translate="yes" xml:space="preserve">
          <source>Package unsafe</source>
          <target state="translated">包装不安全</target>
        </trans-unit>
        <trans-unit id="f3779d5060271e804458c7a976ac1ca5792c1c2a" translate="yes" xml:space="preserve">
          <source>Package unsafe contains operations that step around the type safety of Go programs.</source>
          <target state="translated">包不安全包含了绕过围棋程序类型安全的操作。</target>
        </trans-unit>
        <trans-unit id="7fd4c1e0c59a537b7729289d4b67c4a3c1f81ee5" translate="yes" xml:space="preserve">
          <source>Package url</source>
          <target state="translated">包裹网址</target>
        </trans-unit>
        <trans-unit id="4387dda0da368c99a229d78b0b38d344b8ddba79" translate="yes" xml:space="preserve">
          <source>Package url parses URLs and implements query escaping.</source>
          <target state="translated">包url解析URL并实现查询转义。</target>
        </trans-unit>
        <trans-unit id="fa2e3df3b1c8d0f2ae6af8b9831692e368e35553" translate="yes" xml:space="preserve">
          <source>Package user</source>
          <target state="translated">包装用户</target>
        </trans-unit>
        <trans-unit id="36a98acad58d4786ee6c07f69161ac71cff79f1c" translate="yes" xml:space="preserve">
          <source>Package user allows user account lookups by name or id.</source>
          <target state="translated">包用户允许通过名称或id查找用户账户。</target>
        </trans-unit>
        <trans-unit id="950f17b07369b94da04e57b90cd290ee5b7ab329" translate="yes" xml:space="preserve">
          <source>Package utf16</source>
          <target state="translated">包utf16</target>
        </trans-unit>
        <trans-unit id="a91481384b6ca45acef08e50a0a602f6b354aa0d" translate="yes" xml:space="preserve">
          <source>Package utf16 implements encoding and decoding of UTF-16 sequences.</source>
          <target state="translated">包utf16实现了UTF-16序列的编码和解码。</target>
        </trans-unit>
        <trans-unit id="82c84de36eee3827503136824453e15f86291f2b" translate="yes" xml:space="preserve">
          <source>Package utf8</source>
          <target state="translated">包utf8</target>
        </trans-unit>
        <trans-unit id="2d558781d2038e750681faba06d532094ebcdee0" translate="yes" xml:space="preserve">
          <source>Package utf8 implements functions and constants to support text encoded in UTF-8.</source>
          <target state="translated">包 utf8 实现了支持 UTF-8 编码文本的函数和常量。</target>
        </trans-unit>
        <trans-unit id="c4336946f769b3e34f747cb0c522858f6f2bca8f" translate="yes" xml:space="preserve">
          <source>Package utf8 implements functions and constants to support text encoded in UTF-8. It includes functions to translate between runes and UTF-8 byte sequences.</source>
          <target state="translated">包 utf8 实现了支持 UTF-8 编码文本的函数和常量。它包括在符文和UTF-8字节序列之间进行翻译的函数。</target>
        </trans-unit>
        <trans-unit id="e005285bbb9f85e9b954bed4a6e12999ae03a672" translate="yes" xml:space="preserve">
          <source>Package x509</source>
          <target state="translated">包材x509</target>
        </trans-unit>
        <trans-unit id="90de220d2bc052deab02c2c4de98a3e71c3ef316" translate="yes" xml:space="preserve">
          <source>Package x509 parses X.509-encoded keys and certificates.</source>
          <target state="translated">包 x509 解析 X.509 编码的密钥和证书。</target>
        </trans-unit>
        <trans-unit id="10ff4b7cfdffba3a4767c605c3ebace89b42f92c" translate="yes" xml:space="preserve">
          <source>Package xml</source>
          <target state="translated">包xml</target>
        </trans-unit>
        <trans-unit id="93a9b657d94cd318e7ad743005d8b996f9595c6e" translate="yes" xml:space="preserve">
          <source>Package xml implements a simple XML 1.0 parser that understands XML name spaces.</source>
          <target state="translated">包xml实现了一个简单的XML 1.0解析器,它能理解XML名称空间。</target>
        </trans-unit>
        <trans-unit id="c19f04e6d6be831ab25449a487f0756316b351f6" translate="yes" xml:space="preserve">
          <source>Package zip</source>
          <target state="translated">包装拉链</target>
        </trans-unit>
        <trans-unit id="dfaad266283daad5d81fc0dfbfdf6760dc866668" translate="yes" xml:space="preserve">
          <source>Package zip provides support for reading and writing ZIP archives.</source>
          <target state="translated">包zip提供了对ZIP档案的读写支持。</target>
        </trans-unit>
        <trans-unit id="588377b14974d4da962ee44fcd3a951c7da0ddbc" translate="yes" xml:space="preserve">
          <source>Package zlib</source>
          <target state="translated">包zlib</target>
        </trans-unit>
        <trans-unit id="b8d40d3cbcb305861fd98b2ba9ad33cfda1fe2f6" translate="yes" xml:space="preserve">
          <source>Package zlib implements reading and writing of zlib format compressed data, as specified in RFC 1950.</source>
          <target state="translated">包zlib实现了RFC 1950中规定的zlib格式压缩数据的读写。</target>
        </trans-unit>
        <trans-unit id="e6ebfcdbe4d41913bba3eb021c5e2f7faa2a5af8" translate="yes" xml:space="preserve">
          <source>PackageExports reports whether there are exported declarations; it returns false otherwise.</source>
          <target state="translated">PackageExports 报告是否有导出的声明,否则返回 false。</target>
        </trans-unit>
        <trans-unit id="d9ae56929a397151dd71c50540c8ba9f7a374f8b" translate="yes" xml:space="preserve">
          <source>PackageExports trims the AST for a Go package in place such that only exported nodes remain. The pkg.Files list is not changed, so that file names and top-level package comments don't get lost.</source>
          <target state="translated">PackageExports 对 Go 包的 AST 进行了就地修剪,从而只保留导出的节点。pkg.Files 列表不会被改变,因此文件名和顶层包注释不会丢失。</target>
        </trans-unit>
        <trans-unit id="74867f01a0f6f645509d530ed289df047c6ca5df" translate="yes" xml:space="preserve">
          <source>PackageName returns the package part of the symbol name, or the empty string if there is none.</source>
          <target state="translated">PackageName 返回符号名称的包部分,如果没有,则返回空字符串。</target>
        </trans-unit>
        <trans-unit id="17c03b27b19d3b24962032b7096b91392545e063" translate="yes" xml:space="preserve">
          <source>Packages that import unsafe may be non-portable and are not protected by the Go 1 compatibility guidelines.</source>
          <target state="translated">导入不安全的软件包可能是不可移植的,不受Go 1兼容性准则的保护。</target>
        </trans-unit>
        <trans-unit id="85b5ee2819eb33cd78762cf51c0b4a5dd5523cb8" translate="yes" xml:space="preserve">
          <source>PacketConn is a generic packet-oriented network connection.</source>
          <target state="translated">PacketConn是一个面向数据包的通用网络连接。</target>
        </trans-unit>
        <trans-unit id="a0ac68089bb018405a8a46934512cae685b010b0" translate="yes" xml:space="preserve">
          <source>Palette is a palette of colors.</source>
          <target state="translated">调色板是一种颜色的调色板。</target>
        </trans-unit>
        <trans-unit id="8345eec10c921c39ee65aec65372e629adf963d0" translate="yes" xml:space="preserve">
          <source>Paletted is an in-memory image of uint8 indices into a given palette.</source>
          <target state="translated">Paletted是uint8指数到给定调色板的内存图像。</target>
        </trans-unit>
        <trans-unit id="811857fbbfb6bbe0a3457e5ca72c3cf06e353567" translate="yes" xml:space="preserve">
          <source>PalettedImage is an image whose colors may come from a limited palette. If m is a PalettedImage and m.ColorModel() returns a color.Palette p, then m.At(x, y) should be equivalent to p[m.ColorIndexAt(x, y)]. If m's color model is not a color.Palette, then ColorIndexAt's behavior is undefined.</source>
          <target state="translated">PalettedImage是一个图像,它的颜色可能来自一个有限的调色板。如果m是PalettedImage,并且m.ColorModel()返回一个color.Palette p,那么m.At(x,y)应该等同于p[m.ColorIndexAt(x,y)].如果m的颜色模型不是color.Palette,那么ColorIndexAt的行为是未定义的。如果m的颜色模型不是color.Palette,那么ColorIndexAt的行为是未定义的。</target>
        </trans-unit>
        <trans-unit id="a512c7d0f9809b6517eee35249de666659ba9bfb" translate="yes" xml:space="preserve">
          <source>Panic is equivalent to Print() followed by a call to panic().</source>
          <target state="translated">Panic相当于Print()之后调用panic()。</target>
        </trans-unit>
        <trans-unit id="70327e98d175663a82976707da91eda94bf1b6a7" translate="yes" xml:space="preserve">
          <source>Panic is equivalent to l.Print() followed by a call to panic().</source>
          <target state="translated">Panic相当于l.Print()后调用panic()。</target>
        </trans-unit>
        <trans-unit id="acc202ec50a5ea3772bacf3218be7877d69941fa" translate="yes" xml:space="preserve">
          <source>Panicf is equivalent to Printf() followed by a call to panic().</source>
          <target state="translated">Panicf相当于Printf()之后调用panic()。</target>
        </trans-unit>
        <trans-unit id="609a5ff18403fc4ba9beec643b7a217eafb712bf" translate="yes" xml:space="preserve">
          <source>Panicf is equivalent to l.Printf() followed by a call to panic().</source>
          <target state="translated">Panicf相当于l.Printf()后调用panic()。</target>
        </trans-unit>
        <trans-unit id="de496f946eb01de54aacea36389a2930b2b5fea9" translate="yes" xml:space="preserve">
          <source>Panicln is equivalent to Println() followed by a call to panic().</source>
          <target state="translated">Panicln相当于Println()后调用panic()。</target>
        </trans-unit>
        <trans-unit id="42b6fefdbb3fe1d6cc946346feb02780fc4954d4" translate="yes" xml:space="preserve">
          <source>Panicln is equivalent to l.Println() followed by a call to panic().</source>
          <target state="translated">Panicln相当于l.Println()后调用panic()。</target>
        </trans-unit>
        <trans-unit id="3f233f952852726c76f955efdb8cfad2984864f8" translate="yes" xml:space="preserve">
          <source>Panics if x is not one of the expected types.</source>
          <target state="translated">如果x不是预期的类型之一,则惊慌失措。</target>
        </trans-unit>
        <trans-unit id="2656e6fe95970497f2da4ae50b709bea0cd1bc5b" translate="yes" xml:space="preserve">
          <source>Parallel signals that this test is to be run in parallel with (and only with) other parallel tests. When a test is run multiple times due to use of -test.count or -test.cpu, multiple instances of a single test never run in parallel with each other.</source>
          <target state="translated">并行信号,表示这个测试要与其他并行测试并行运行(而且只能与其他并行测试并行运行)。当一个测试由于使用-test.count或-test.cpu而被多次运行时,一个测试的多个实例永远不会相互平行运行。</target>
        </trans-unit>
        <trans-unit id="2ff45dda694203612652ce58eb32539f9ea39636" translate="yes" xml:space="preserve">
          <source>ParameterSizes is an enumeration of the acceptable bit lengths of the primes in a set of DSA parameters. See FIPS 186-3, section 4.2.</source>
          <target state="translated">ParameterSizes是一组DSA参数中可接受的质数位长的枚举。参见FIPS 186-3,4.2节。</target>
        </trans-unit>
        <trans-unit id="a38d6c7adf0ef721d51b09e9ef7d3dab505e3376" translate="yes" xml:space="preserve">
          <source>Parameters represents the domain parameters for a key. These parameters can be shared across many keys. The bit length of Q must be a multiple of 8.</source>
          <target state="translated">Parameters表示一个键的域参数,这些参数可以在多个键之间共享。这些参数可以在多个密钥之间共享。Q的位长必须是8的倍数。</target>
        </trans-unit>
        <trans-unit id="f2a595a7d8c4b648ee6f267ac2a444e5bcc46523" translate="yes" xml:space="preserve">
          <source>Params returns the parameters of signature s, or nil.</source>
          <target state="translated">Params返回签名s的参数,或者nil。</target>
        </trans-unit>
        <trans-unit id="21b514799f92100d51f5995498a76d50a6591d7f" translate="yes" xml:space="preserve">
          <source>Parent returns the scope in which the object is declared. The result is nil for methods and struct fields.</source>
          <target state="translated">Parent 返回声明对象的作用域。对于方法和结构域,结果为零。</target>
        </trans-unit>
        <trans-unit id="6d2ab1d9170cbc23bb71b0003b207c4504e77bc1" translate="yes" xml:space="preserve">
          <source>Parent returns the scope's containing (parent) scope.</source>
          <target state="translated">Parent 返回 scope 的包含(父)作用域。</target>
        </trans-unit>
        <trans-unit id="b7e45a36ff3610e06a3801fd14fa6c1e6b89312f" translate="yes" xml:space="preserve">
          <source>Parse</source>
          <target state="translated">Parse</target>
        </trans-unit>
        <trans-unit id="eadd3db51adcf33e03ef4c729d1f1d357ded94ad" translate="yes" xml:space="preserve">
          <source>Parse may be called multiple times to assemble the various associated templates; see the ParseFiles and ParseGlob functions and methods for simple ways to parse related templates stored in files.</source>
          <target state="translated">可以多次调用Parse来组装各种相关的模板;请参见ParseFiles和ParseGlob函数和方法,以获得解析存储在文件中的相关模板的简单方法。</target>
        </trans-unit>
        <trans-unit id="8d5c1289f5e01bfdc5e745aca9c64851f068edc1" translate="yes" xml:space="preserve">
          <source>Parse parses a URL in the context of the receiver. The provided URL may be relative or absolute. Parse returns nil, err on parse failure, otherwise its return value is the same as ResolveReference.</source>
          <target state="translated">在接收者的上下文中解析一个URL。所提供的URL可以是相对的,也可以是绝对的,如果解析失败则返回nil或err,否则其返回值与ResolveReference相同。Parse返回nil,解析失败则返回err,否则其返回值与ResolveReference相同。</target>
        </trans-unit>
        <trans-unit id="8516fe9b2b0e681b5f1a19c09c598e09f76c0a92" translate="yes" xml:space="preserve">
          <source>Parse parses a formatted string and returns the time value it represents. The layout defines the format by showing how the reference time, defined to be</source>
          <target state="translated">Parse解析一个格式化的字符串,并返回它所代表的时间值。布局通过显示参考时间(定义为</target>
        </trans-unit>
        <trans-unit id="db84b44056db6c0589142cb550f7685b84290b5a" translate="yes" xml:space="preserve">
          <source>Parse parses a regular expression string s, controlled by the specified Flags, and returns a regular expression parse tree. The syntax is described in the top-level comment.</source>
          <target state="translated">Parse解析一个由指定的Flags控制的正则表达式字符串s,并返回一个正则表达式解析树。语法在顶层注释中描述。</target>
        </trans-unit>
        <trans-unit id="be0cb24027bbf7f03a0c792dd455fd65c8a881c5" translate="yes" xml:space="preserve">
          <source>Parse parses a single RFC 5322 address of the form &quot;Gogh Fir &amp;lt;gf@example.com&amp;gt;&quot; or &quot;foo@example.com&quot;.</source>
          <target state="translated">解析解析单个RFC 5322地址，格式为&amp;ldquo; Gogh Fir &amp;lt;gf@example.com&amp;gt;&amp;rdquo;或&amp;ldquo; foo@example.com&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="6329cd5d9d98d1f00f6752cb84cd2b25ccb27456" translate="yes" xml:space="preserve">
          <source>Parse parses flag definitions from the argument list, which should not include the command name. Must be called after all flags in the FlagSet are defined and before flags are accessed by the program. The return value will be ErrHelp if -help or -h were set but not defined.</source>
          <target state="translated">Parse从参数列表中解析标志定义,参数列表中不应该包括命令名。必须在FlagSet中的所有标志被定义之后,并且在程序访问标志之前调用。如果设置了-help或-h但没有定义,则返回值为ErrHelp。</target>
        </trans-unit>
        <trans-unit id="18bad4ea2cc97c8a9f4948e0f21e613e7890178a" translate="yes" xml:space="preserve">
          <source>Parse parses rawurl into a URL structure.</source>
          <target state="translated">解析将rawurl解析成一个URL结构。</target>
        </trans-unit>
        <trans-unit id="68237f10d24bed5fb80b0763ff0184c661ba1727" translate="yes" xml:space="preserve">
          <source>Parse parses s which must contain a text representation of a floating- point number with a mantissa in the given conversion base (the exponent is always a decimal number), or a string representing an infinite value.</source>
          <target state="translated">解析分析s必须包含一个浮点数的文本表示,在给定的转换基数中带有一个尾数(指数总是一个小数),或者一个表示无限值的字符串。</target>
        </trans-unit>
        <trans-unit id="36bbed9dac5fc81c047e065b17ee658b65e3a5a6" translate="yes" xml:space="preserve">
          <source>Parse parses text as a template body for t. Named template definitions ({{define ...}} or {{block ...}} statements) in text define additional templates associated with t and are removed from the definition of t itself.</source>
          <target state="translated">Parse将文本解析为t的模板体,文本中的命名模板定义({{define ...}}或{{block ...}}语句)定义了与t相关的附加模板,并从t本身的定义中删除。</target>
        </trans-unit>
        <trans-unit id="b0827d39a9b548f4f8b5bce9dee6cdaa918b52e5" translate="yes" xml:space="preserve">
          <source>Parse parses the command-line flags from os.Args[1:]. Must be called after all flags are defined and before flags are accessed by the program.</source>
          <target state="translated">Parse 从 os.Args[1:]中解析命令行标志。必须在定义了所有标志之后,在程序访问标志之前调用。</target>
        </trans-unit>
        <trans-unit id="b42efe8079bb64df560c33d7d830ca75ae8ed877" translate="yes" xml:space="preserve">
          <source>Parse parses the template definition string to construct a representation of the template for execution. If either action delimiter string is empty, the default (&quot;{{&quot; or &quot;}}&quot;) is used. Embedded template definitions are added to the treeSet map.</source>
          <target state="translated">Parse解析模板定义字符串,以构建模板的表示,以便执行。如果任一动作定界符字符串为空,则使用默认值(&quot;{{&quot;或&quot;}}&quot;)。嵌入的模板定义会被添加到 treeSet 地图中。</target>
        </trans-unit>
        <trans-unit id="45783abf61a9fbf7fb39991bfe339c1b46133bb7" translate="yes" xml:space="preserve">
          <source>Parse returns a map from template name to parse.Tree, created by parsing the templates described in the argument string. The top-level template will be given the specified name. If an error is encountered, parsing stops and an empty map is returned with the error.</source>
          <target state="translated">Parse 返回一个从模板名称到 parse.Tree 的映射,该映射是通过解析参数字符串中描述的模板创建的。顶层模板将被赋予指定的名称。如果遇到错误,则停止解析,并返回一个带错误的空映射。</target>
        </trans-unit>
        <trans-unit id="66daff607d3735d4a8218dfbf123ab6dbc3c14bd" translate="yes" xml:space="preserve">
          <source>ParseAddress</source>
          <target state="translated">ParseAddress</target>
        </trans-unit>
        <trans-unit id="845f64c05cb52df568c8a8ad63c74420b1248668" translate="yes" xml:space="preserve">
          <source>ParseAddress parses a single RFC 5322 address, e.g. &quot;Barry Gibbs &amp;lt;bg@example.com&amp;gt;&quot;</source>
          <target state="translated">ParseAddress解析单个RFC 5322地址，例如&amp;ldquo; Barry Gibbs &amp;lt;bg@example.com&amp;gt;&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="ff9201bea61c197b726cdbdba040febe1fb6e8d1" translate="yes" xml:space="preserve">
          <source>ParseAddressList</source>
          <target state="translated">ParseAddressList</target>
        </trans-unit>
        <trans-unit id="ac5ae9b34b3307e496577d3e37b7a87a645c4e1d" translate="yes" xml:space="preserve">
          <source>ParseAddressList parses the given string as a list of addresses.</source>
          <target state="translated">ParseAddressList将给定的字符串解析为一个地址列表。</target>
        </trans-unit>
        <trans-unit id="6a0560d771cdd8a3e81f49597b77c74c345d99ff" translate="yes" xml:space="preserve">
          <source>ParseBool</source>
          <target state="translated">ParseBool</target>
        </trans-unit>
        <trans-unit id="48e4dd268460af7ff4ba4ae65e2a683e5e2d3f52" translate="yes" xml:space="preserve">
          <source>ParseBool returns the boolean value represented by the string. It accepts 1, t, T, TRUE, true, True, 0, f, F, FALSE, false, False. Any other value returns an error.</source>
          <target state="translated">ParseBool返回字符串所代表的布尔值。它接受1、t、T、TRUE、true、True、0、f、F、FALSE、false、False。任何其他值都会返回一个错误。</target>
        </trans-unit>
        <trans-unit id="22e1b2e318d4e5834961059fa9d10ad0bddc3198" translate="yes" xml:space="preserve">
          <source>ParseBool, ParseFloat, ParseInt, and ParseUint convert strings to values:</source>
          <target state="translated">ParseBool,ParseFloat,ParseInt,和 ParseUint 将字符串转换为数值。</target>
        </trans-unit>
        <trans-unit id="b287ba3d9ab143c06c570eef216327abbf80cd22" translate="yes" xml:space="preserve">
          <source>ParseCIDR</source>
          <target state="translated">ParseCIDR</target>
        </trans-unit>
        <trans-unit id="753119985829ad20f5fb77b43aff8f713890c2d1" translate="yes" xml:space="preserve">
          <source>ParseCIDR parses s as a CIDR notation IP address and prefix length, like &quot;192.0.2.0/24&quot; or &quot;2001:db8::/32&quot;, as defined in RFC 4632 and RFC 4291.</source>
          <target state="translated">ParseCIDR将s解析为CIDR符号IP地址和前缀长度,如 &quot;192.0.2.0/24 &quot;或 &quot;2001:db8::/32&quot;,如RFC 4632和RFC 4291所定义。</target>
        </trans-unit>
        <trans-unit id="3db7887ddb0dc9836c9d867b0da11217386b066e" translate="yes" xml:space="preserve">
          <source>ParseCRL parses a CRL from the given bytes. It's often the case that PEM encoded CRLs will appear where they should be DER encoded, so this function will transparently handle PEM encoding as long as there isn't any leading garbage.</source>
          <target state="translated">ParseCRL从给定的字节中解析出一个CRL。通常情况下,PEM编码的CRL会出现在它们应该是DER编码的地方,所以只要没有任何前导垃圾,这个函数就会透明地处理PEM编码。</target>
        </trans-unit>
        <trans-unit id="13bcfda4565f496b59a919b4e59789ae5fb7deb1" translate="yes" xml:space="preserve">
          <source>ParseCertificate parses a single certificate from the given ASN.1 DER data.</source>
          <target state="translated">ParseCertificate从给定的ASN.1 DER数据中解析一个证书。</target>
        </trans-unit>
        <trans-unit id="d4b98b2809a870dbc00f34abcb696de9660e20f1" translate="yes" xml:space="preserve">
          <source>ParseCertificateRequest parses a single certificate request from the given ASN.1 DER data.</source>
          <target state="translated">ParseCertificateRequest从给定的ASN.1 DER数据中解析一个证书请求。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
