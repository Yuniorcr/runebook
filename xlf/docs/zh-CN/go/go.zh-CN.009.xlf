<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="go">
    <body>
      <group id="go">
        <trans-unit id="232f8c7f5eea097cc9451d2d90b51db6b069254d" translate="yes" xml:space="preserve">
          <source>The zero Map is empty and ready for use. A Map must not be copied after first use.</source>
          <target state="translated">零地图是空的,可以使用。一个地图在第一次使用后不得复制。</target>
        </trans-unit>
        <trans-unit id="ba5155e1e3916eee99a712d5244dcde8e9982094" translate="yes" xml:space="preserve">
          <source>The zero Value represents no value. Its IsValid method returns false, its Kind method returns Invalid, its String method returns &quot;&amp;lt;invalid Value&amp;gt;&quot;, and all other methods panic. Most functions and methods never return an invalid value. If one does, its documentation states the conditions explicitly.</source>
          <target state="translated">零值表示无值。它的IsValid方法返回false，其Kind方法返回Invalid，其String方法返回&amp;ldquo; &amp;lt;invalid Value&amp;gt;&amp;rdquo;，所有其他方法都出现紧急情况。大多数函数和方法从不返回无效值。如果是这样，则其文档会明确说明条件。</target>
        </trans-unit>
        <trans-unit id="384c750c13afaffcbd5ebf58e8afec2b8768e946" translate="yes" xml:space="preserve">
          <source>The zero value for Pos is NoPos; there is no file and line information associated with it, and NoPos.IsValid() is false. NoPos is always smaller than any other Pos value. The corresponding Position value for NoPos is the zero value for Position.</source>
          <target state="translated">Pos的零值是NoPos;没有与之相关的文件和行信息,NoPos.IsValid()是false。NoPos总是小于其他任何Pos值。NoPos对应的Position值就是Position的零值。</target>
        </trans-unit>
        <trans-unit id="3f5973e68195ed6a7dd12c4c7dc485f8bde0523d" translate="yes" xml:space="preserve">
          <source>The zero value for an Int, Rat, or Float correspond to 0. Thus, new values can be declared in the usual ways and denote 0 without further initialization:</source>
          <target state="translated">Int、Rat或Float的零值对应于0,因此,新的值可以用通常的方式声明,并表示0,而无需进一步初始化。</target>
        </trans-unit>
        <trans-unit id="5d5aa4f538fd1571e15874ad0969ae7c0fda3040" translate="yes" xml:space="preserve">
          <source>The zero value for each field is equivalent to dialing without that option. Dialing with the zero value of Dialer is therefore equivalent to just calling the Dial function.</source>
          <target state="translated">每个字段的零值相当于没有该选项的拨号。因此,用Dialer的零值拨号相当于只调用Dial函数。</target>
        </trans-unit>
        <trans-unit id="beb5a289f20083f1018df67115c647d61b968230" translate="yes" xml:space="preserve">
          <source>The zero value of type Time is January 1, year 1, 00:00:00.000000000 UTC. As this time is unlikely to come up in practice, the IsZero method gives a simple way of detecting a time that has not been initialized explicitly.</source>
          <target state="translated">Time类型的零值是1年1月1日,00:00:00.000000000 UTC。由于这个时间在实际中不太可能出现,IsZero方法给出了一个简单的方法来检测没有被显式初始化的时间。</target>
        </trans-unit>
        <trans-unit id="4752552a303f0f1e8a6bd4b3555705dcb31c63a8" translate="yes" xml:space="preserve">
          <source>Then it can make a remote call:</source>
          <target state="translated">然后就可以进行远程通话了。</target>
        </trans-unit>
        <trans-unit id="c5d500f53dcbe43654b22f15924d609c47bcfc3c" translate="yes" xml:space="preserve">
          <source>Then use the pprof tool to look at the heap profile:</source>
          <target state="translated">然后使用pprof工具查看堆配置文件。</target>
        </trans-unit>
        <trans-unit id="d249cadab1a19289ed9fd8f524a7048ff9efb13f" translate="yes" xml:space="preserve">
          <source>There are 16 methods of Regexp that match a regular expression and identify the matched text. Their names are matched by this regular expression:</source>
          <target state="translated">Regexp有16种方法可以匹配正则表达式并识别匹配的文本。它们的名称与这个正则表达式相匹配。</target>
        </trans-unit>
        <trans-unit id="089af1af9f031a6d4cb36f253f88e22a554b4d75" translate="yes" xml:space="preserve">
          <source>There are many commands available from the pprof command line. Commonly used commands include &quot;top&quot;, which prints a summary of the top program hot-spots, and &quot;web&quot;, which opens an interactive graph of hot-spots and their call graphs. Use &quot;help&quot; for information on all pprof commands.</source>
          <target state="translated">在pprof命令行中有很多命令可以使用,常用的命令有 &quot;top&quot;,它可以打印出最热门的程序热点汇总,&quot;web &quot;可以打开热点及其调用图的交互图。常用的命令包括 &quot;top&quot;,它可以打印顶级程序热点的摘要,以及 &quot;web&quot;,它可以打开热点的交互式图表和它们的调用图表。使用 &quot;help &quot;可以获得所有pprof命令的信息。</target>
        </trans-unit>
        <trans-unit id="6fa5b171535b7941feffabcf1c5f915fe3f02940" translate="yes" xml:space="preserve">
          <source>There are no build tags for beta or minor releases.</source>
          <target state="translated">测试版或次要版本没有构建标签。</target>
        </trans-unit>
        <trans-unit id="f4ebe0322e94e23eec9f295ca340080dec64dffd" translate="yes" xml:space="preserve">
          <source>There are three types of user annotations: log messages, regions, and tasks.</source>
          <target state="translated">用户注释有三种类型:日志消息、区域和任务。</target>
        </trans-unit>
        <trans-unit id="311b843be371a8c7fc9f6f81df2189e5f92e44e5" translate="yes" xml:space="preserve">
          <source>There is also a set of binary comparison operators defined as functions:</source>
          <target state="translated">还有一组定义为函数的二进制比较运算符。</target>
        </trans-unit>
        <trans-unit id="5f5077a9bb275171893d0be52e74cbffe4b19888" translate="yes" xml:space="preserve">
          <source>There is also a standard HTTP interface to profiling data. Adding the following line will install handlers under the /debug/pprof/ URL to download live profiles:</source>
          <target state="translated">还有一个标准的HTTP接口来剖析数据。添加以下一行将在/debug/pprof/URL下安装处理程序来下载实时配置文件。</target>
        </trans-unit>
        <trans-unit id="f5962f465f0b5c003c4585058fcce10ec6a63c36" translate="yes" xml:space="preserve">
          <source>There is also a standard HTTP interface to trace data. Adding the following line will install a handler under the /debug/pprof/trace URL to download a live trace:</source>
          <target state="translated">还有一个标准的HTTP接口来跟踪数据。添加以下一行将在/debug/pprof/trace URL下安装一个处理程序来下载实时跟踪数据。</target>
        </trans-unit>
        <trans-unit id="669c09ef6ba443f4e07a76e5e520b09339b0d7ba" translate="yes" xml:space="preserve">
          <source>There is also a subset of the methods that can be applied to text read from a RuneReader:</source>
          <target state="translated">还有一个方法的子集,可以应用于从RuneReader读取的文本。</target>
        </trans-unit>
        <trans-unit id="e5e187581cfc7675624afa1252d945d3159b9872" translate="yes" xml:space="preserve">
          <source>There is no mechanism for full case folding, that is, for characters that involve multiple runes in the input or output.</source>
          <target state="translated">对于输入或输出中涉及多个符文的字符,没有全宗折叠的机制。</target>
        </trans-unit>
        <trans-unit id="4e416754d4e74f38af1b48194c67cf3710f22527" translate="yes" xml:space="preserve">
          <source>These are predefined layouts for use in Time.Format and time.Parse. The reference time used in the layouts is the specific time:</source>
          <target state="translated">这些是预定义的布局,用于Time.Format和time.Parse。布局中使用的参考时间是具体时间。</target>
        </trans-unit>
        <trans-unit id="622b937b45492ef40cc6c554bb302fd36d24a9dd" translate="yes" xml:space="preserve">
          <source>These are the errors that can be returned in ParseError.Err.</source>
          <target state="translated">这些是可以在ParseError.Err中返回的错误。</target>
        </trans-unit>
        <trans-unit id="df2271a2f22e4450d78c23577801038a703976de" translate="yes" xml:space="preserve">
          <source>These assume decimal and the Go int type.</source>
          <target state="translated">这些假设是十进制和Go int类型。</target>
        </trans-unit>
        <trans-unit id="e44cf0ddaa746164e3256589314495380a8d22a3" translate="yes" xml:space="preserve">
          <source>These constants are copied from the flate package, so that code that imports &quot;compress/gzip&quot; does not also have to import &quot;compress/flate&quot;.</source>
          <target state="translated">这些常量是从 flate 包中复制过来的,所以导入 &quot;compress/gzip&quot; 的代码不必同时导入 &quot;compress/flate&quot;。</target>
        </trans-unit>
        <trans-unit id="9b53ffb7fd51347180d120a25b5986ecdfdf8a40" translate="yes" xml:space="preserve">
          <source>These constants are copied from the flate package, so that code that imports &quot;compress/zlib&quot; does not also have to import &quot;compress/flate&quot;.</source>
          <target state="translated">这些常量是从flate包中复制过来的,所以导入 &quot;compress/zlib &quot;的代码不必同时导入 &quot;compress/flate&quot;。</target>
        </trans-unit>
        <trans-unit id="a6caaf07cd62c3bce0c1d44802c32e939959f7c6" translate="yes" xml:space="preserve">
          <source>These constants cause FlagSet.Parse to behave as described if the parse fails.</source>
          <target state="translated">这些常量导致FlagSet.Parse在解析失败时的行为与描述的一样。</target>
        </trans-unit>
        <trans-unit id="c3e135e518f3071cd6e6de5ee8eb8509897ca8e4" translate="yes" xml:space="preserve">
          <source>These constants define supported rounding modes.</source>
          <target state="translated">这些常数定义了支持的四舍五入模式。</target>
        </trans-unit>
        <trans-unit id="e9b81d06567b4f6ea4a134b77b7d8d68b11092d0" translate="yes" xml:space="preserve">
          <source>These examples demonstrate the basics of printing using a format string. Printf, Sprintf, and Fprintf all take a format string that specifies how to format the subsequent arguments. For example, %d (we call that a 'verb') says to print the corresponding argument, which must be an integer (or something containing an integer, such as a slice of ints) in decimal. The verb %v ('v' for 'value') always formats the argument in its default form, just how Print or Println would show it. The special verb %T ('T' for 'Type') prints the type of the argument rather than its value. The examples are not exhaustive; see the package comment for all the details.</source>
          <target state="translated">这些例子演示了使用格式字符串进行打印的基础知识。Printf、Sprintf和Fprintf都取一个格式字符串,指定如何格式化后面的参数。例如,%d(我们称之为 &quot;动词&quot;)说要打印相应的参数,它必须是一个整数(或包含一个整数的东西,如ints的一个片断),用十进制表示。动词%v('v'表示'value')总是以默认的形式格式化参数,就像Print或Println会显示的那样。特殊的动词%T('T'代表'Type')打印参数的类型,而不是它的值。这些例子并不详尽,所有细节请参见软件包注释。</target>
        </trans-unit>
        <trans-unit id="1b31c3c54ac0eb3ff04d00595a12fb566e8fcf7e" translate="yes" xml:space="preserve">
          <source>These flags define which text to prefix to each log entry generated by the Logger. Bits are or'ed together to control what's printed. There is no control over the order they appear (the order listed here) or the format they present (as described in the comments). The prefix is followed by a colon only when Llongfile or Lshortfile is specified. For example, flags Ldate | Ltime (or LstdFlags) produce,</source>
          <target state="translated">这些标志定义了记录仪生成的每个日志条目的前缀文本。位是或'ed一起控制打印的内容。无法控制它们出现的顺序(这里列出的顺序)或它们呈现的格式(如注释中所述)。只有当指定了Llongfile或Lshortfile时,前缀后面才会有一个冒号。例如,标志Ldate | Ltime(或LstdFlags)会产生。</target>
        </trans-unit>
        <trans-unit id="eab8374633319fa49ea516b7b757172cc6a3ee35" translate="yes" xml:space="preserve">
          <source>These flags define which text to prefix to each log entry generated by the Logger. Bits are or'ed together to control what's printed. With the exception of the Lmsgprefix flag, there is no control over the order they appear (the order listed here) or the format they present (as described in the comments). The prefix is followed by a colon only when Llongfile or Lshortfile is specified. For example, flags Ldate | Ltime (or LstdFlags) produce,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc9914d5780e96c178ba8969a057705144577da8" translate="yes" xml:space="preserve">
          <source>These functions are also compatible with the &amp;ldquo;Ed25519&amp;rdquo; function defined in RFC 8032. However, unlike RFC 8032's formulation, this package's private key representation includes a public key suffix to make multiple signing operations with the same key more efficient. This package refers to the RFC 8032 private key as the &amp;ldquo;seed&amp;rdquo;.</source>
          <target state="translated">这些功能还与RFC 8032中定义的&amp;ldquo; Ed25519&amp;rdquo;功能兼容。但是，与RFC 8032的表述不同，此程序包的私钥表示形式包含一个公钥后缀，以使使用同一密钥的多个签名操作更加有效。该软件包将RFC 8032私钥称为&amp;ldquo;种子&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="2034a99a91b57c3247261a1a8004621e6e0c4e1f" translate="yes" xml:space="preserve">
          <source>These functions require great care to be used correctly. Except for special, low-level applications, synchronization is better done with channels or the facilities of the sync package. Share memory by communicating; don't communicate by sharing memory.</source>
          <target state="translated">这些功能需要非常小心才能正确使用。除了特殊的低级应用外,同步最好用通道或同步包的设施来完成。通过通信来共享内存,不要通过共享内存来通信。</target>
        </trans-unit>
        <trans-unit id="54aa9a67852a83f3350017dd1b9500c555360772" translate="yes" xml:space="preserve">
          <source>These packages are part of the Go Project but outside the main Go tree. They are developed under looser &lt;a href=&quot;https://golang.org/doc/go1compat&quot;&gt;compatibility requirements&lt;/a&gt; than the Go core. Install them with &quot;&lt;a href=&quot;https://golang.org/cmd/go/#hdr-Download_and_install_packages_and_dependencies&quot;&gt;go get&lt;/a&gt;&quot;.</source>
          <target state="translated">这些软件包是Go项目的一部分，但在主Go树之外。它们是在比Go内核更&lt;a href=&quot;https://golang.org/doc/go1compat&quot;&gt;严格&lt;/a&gt;的兼容性要求下开发的。用&amp;ldquo; &lt;a href=&quot;https://golang.org/cmd/go/#hdr-Download_and_install_packages_and_dependencies&quot;&gt;go get&lt;/a&gt; &amp;rdquo; 安装它们。</target>
        </trans-unit>
        <trans-unit id="07168c583c59c9cae9d4bb3facc94a52fb2a21e9" translate="yes" xml:space="preserve">
          <source>These predefined profiles maintain themselves and panic on an explicit Add or Remove method call.</source>
          <target state="translated">这些预定义的配置文件会自我维护,并在明确的添加或删除方法调用时发生恐慌。</target>
        </trans-unit>
        <trans-unit id="8dc4875980e26530686b9e8a46a4183aeaf7943d" translate="yes" xml:space="preserve">
          <source>These services can help you find Open Source packages provided by the community.</source>
          <target state="translated">这些服务可以帮助你找到社区提供的开源包。</target>
        </trans-unit>
        <trans-unit id="6ba17173fd7e73d9151d0d7cdef890f5dd3a0a3f" translate="yes" xml:space="preserve">
          <source>These three formatting routines call the Qualifier for each package-level object O, and if the Qualifier returns a non-empty string p, the object is printed in the form p.O. If it returns an empty string, only the object name O is printed.</source>
          <target state="translated">这三个格式化例程对每个包级对象O调用限定符,如果限定符返回非空字符串p,则以p.O的形式打印对象,如果返回空字符串,则只打印对象名称O。</target>
        </trans-unit>
        <trans-unit id="2207cae6c61d669eed106af825a6dce66aef87d1" translate="yes" xml:space="preserve">
          <source>These variables have type *RangeTable.</source>
          <target state="translated">这些变量的类型为*RangeTable。</target>
        </trans-unit>
        <trans-unit id="610a8603a5a8aeac74a533f57b0c5eb7122b7d43" translate="yes" xml:space="preserve">
          <source>This cannot be done concurrent to other receives from the Timer's channel or other calls to the Timer's Stop method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1166cbd43d7ca0f544abde3cc256ae8afc9cd0b1" translate="yes" xml:space="preserve">
          <source>This cannot be done concurrent to other receives from the Timer's channel.</source>
          <target state="translated">这不能与定时器通道的其他接收同时进行。</target>
        </trans-unit>
        <trans-unit id="b00ff4b1fd4c120a5db60ce99d175dd291630987" translate="yes" xml:space="preserve">
          <source>This declares an integer flag, -flagname, stored in the pointer ip, with type *int.</source>
          <target state="translated">这声明了一个整数标志,-flagname,存储在指针ip中,类型为*int。</target>
        </trans-unit>
        <trans-unit id="f1681bf43fc257c44b551cfb0077dc2be75b4283" translate="yes" xml:space="preserve">
          <source>This declares an integer flag, -n, stored in the pointer nFlag, with type *int:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="631f1841cf17bb7db8a22b0767e5099ebe5b8b09" translate="yes" xml:space="preserve">
          <source>This defines two templates, T1 and T2, and a third T3 that invokes the other two when it is executed. Finally it invokes T3. If executed this template will produce the text</source>
          <target state="translated">这就定义了两个模板,T1和T2,还有第三个T3,当它被执行时,会调用其他两个模板。最后它调用T3。如果执行这个模板,将产生文本</target>
        </trans-unit>
        <trans-unit id="07be652fe77b2bc1e633b76695cc662deba999dd" translate="yes" xml:space="preserve">
          <source>This example creates a PriorityQueue with some items, adds and manipulates an item, and then removes the items in priority order.</source>
          <target state="translated">这个例子用一些项目创建了一个PriorityQueue,添加并操作一个项目,然后按照优先级顺序删除项目。</target>
        </trans-unit>
        <trans-unit id="11e8e47e8373159f24438e9584e5f85d6b5441f2" translate="yes" xml:space="preserve">
          <source>This example demonstrates a custom function to process template text. It installs the strings.Title function and uses it to Make Title Text Look Good In Our Template's Output.</source>
          <target state="translated">这个例子演示了一个自定义函数来处理模板文本。它安装了strings.Title函数,并使用它来使标题文本在我们的模板输出中看起来不错。</target>
        </trans-unit>
        <trans-unit id="dfa54d108334a66ba7ab5757d71b4364db5ae271" translate="yes" xml:space="preserve">
          <source>This example demonstrates how a value can be passed to the context and also how to retrieve it if it exists.</source>
          <target state="translated">这个例子演示了如何将一个值传递给上下文,以及如何在它存在时检索它。</target>
        </trans-unit>
        <trans-unit id="cbed8edb3aa3c802bdc2c523c3a0a851457324e3" translate="yes" xml:space="preserve">
          <source>This example demonstrates how to inspect the AST of a Go program.</source>
          <target state="translated">这个例子演示了如何检查一个Go程序的AST。</target>
        </trans-unit>
        <trans-unit id="165d3019bf668cef6d1995c8165503ac097763bd" translate="yes" xml:space="preserve">
          <source>This example demonstrates how to use big.Int to compute the smallest Fibonacci number with 100 decimal digits and to test whether it is prime.</source>
          <target state="translated">这个例子演示了如何使用big.Int来计算100位小数的最小斐波那契数,并测试它是否是质数。</target>
        </trans-unit>
        <trans-unit id="0059484fefd6cd0e894a9be3837a0c3c538eda17" translate="yes" xml:space="preserve">
          <source>This example demonstrates how to use big.Rat to compute the first 15 terms in the sequence of rational convergents for the constant e (base of natural logarithm).</source>
          <target state="translated">这个例子演示了如何使用big.Rat计算常数e(自然对数的基数)的有理收敛序列的前15项。</target>
        </trans-unit>
        <trans-unit id="b29080504869eb07c938bd169b02dbf661e6a627" translate="yes" xml:space="preserve">
          <source>This example demonstrates how to use one group of driver templates with distinct sets of helper templates.</source>
          <target state="translated">这个例子演示了如何使用一组驱动模板与不同的辅助模板集。</target>
        </trans-unit>
        <trans-unit id="ba0650f40679135f634bca363681740adeafe34a" translate="yes" xml:space="preserve">
          <source>This example demonstrates one way to share some templates and use them in different contexts. In this variant we add multiple driver templates by hand to an existing bundle of templates.</source>
          <target state="translated">这个例子演示了一种共享一些模板并在不同环境下使用它们的方法。在这个变体中,我们通过手工将多个驱动程序模板添加到现有的模板捆绑中。</target>
        </trans-unit>
        <trans-unit id="0ba078883e861f3b147ecf053f6c06d8a3174cd3" translate="yes" xml:space="preserve">
          <source>This example demonstrates searching a list sorted in ascending order.</source>
          <target state="translated">这个例子演示了如何搜索一个按升序排列的列表。</target>
        </trans-unit>
        <trans-unit id="7888c65ff5bdcbe2c823d7d7283ee2975bf6366b" translate="yes" xml:space="preserve">
          <source>This example demonstrates searching a list sorted in descending order. The approach is the same as searching a list in ascending order, but with the condition inverted.</source>
          <target state="translated">这个例子演示了如何搜索一个按降序排序的列表。其方法与按升序搜索列表相同,但条件倒置。</target>
        </trans-unit>
        <trans-unit id="2db6a343e7f8129baf91fac5d3ebedf3e8666279" translate="yes" xml:space="preserve">
          <source>This example demonstrates the use of a cancelable context to prevent a goroutine leak. By the end of the example function, the goroutine started by gen will return without leaking.</source>
          <target state="translated">这个例子演示了使用可取消上下文来防止goroutine泄漏。在本例函数结束时,由gen启动的goroutine将无泄漏地返回。</target>
        </trans-unit>
        <trans-unit id="f5ede30ffc3c68340a6fb2445f68975fd1d677b3" translate="yes" xml:space="preserve">
          <source>This example demonstrates unmarshaling an XML excerpt into a value with some preset fields. Note that the Phone field isn't modified and that the XML &amp;lt;Company&amp;gt; element is ignored. Also, the Groups field is assigned considering the element path provided in its tag.</source>
          <target state="translated">此示例演示了如何将XML摘录编组为具有某些预设字段的值。请注意，&amp;ldquo;电话&amp;rdquo;字段未修改，并且XML &amp;lt;Company&amp;gt;元素被忽略。同样，考虑到其标签中提供的元素路径来分配&amp;ldquo;组&amp;rdquo;字段。</target>
        </trans-unit>
        <trans-unit id="363362d5c2e9f91c6b9857ffd69fe714bafa9ced" translate="yes" xml:space="preserve">
          <source>This example fetches several URLs concurrently, using a WaitGroup to block until all the fetches are complete.</source>
          <target state="translated">这个例子同时获取多个URL,使用WaitGroup阻塞,直到所有的获取完成。</target>
        </trans-unit>
        <trans-unit id="06701ebad78061b44ebf3ff359db4a889929ed4c" translate="yes" xml:space="preserve">
          <source>This example illustrates how to remove a variable declaration in a Go program while maintaining correct comment association using an ast.CommentMap.</source>
          <target state="translated">这个例子说明了如何使用 ast.CommentMap 来删除 Go 程序中的变量声明,同时保持正确的注释关联。</target>
        </trans-unit>
        <trans-unit id="5b8dbce47ef4472e55b03e0ab77f57e1bbd03498" translate="yes" xml:space="preserve">
          <source>This example illustrates how to use NewFromFiles to compute package documentation with examples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a88fa5b5d7ed0c65b753c3fe2d8b6cdc87e0d250" translate="yes" xml:space="preserve">
          <source>This example inserts several ints into an IntHeap, checks the minimum, and removes them in order of priority.</source>
          <target state="translated">这个例子将几个ints插入到IntHeap中,检查最小值,并按优先级顺序删除它们。</target>
        </trans-unit>
        <trans-unit id="e36be68d73234a9e2fb853054688b98fefd0444d" translate="yes" xml:space="preserve">
          <source>This example passes a context with a timeout to tell a blocking function that it should abandon its work after the timeout elapses.</source>
          <target state="translated">这个例子通过一个带有超时的上下文来告诉阻塞函数在超时后应该放弃它的工作。</target>
        </trans-unit>
        <trans-unit id="eac2b4a123d3756695f2f19424362998d49962a1" translate="yes" xml:space="preserve">
          <source>This example passes a context with an arbitrary deadline to tell a blocking function that it should abandon its work as soon as it gets to it.</source>
          <target state="translated">这个例子通过一个带有任意deadline的上下文来告诉阻塞函数,它应该在到达阻塞函数后立即放弃它的工作。</target>
        </trans-unit>
        <trans-unit id="df7ace59807aa52b6b44602449d158b9635a420e" translate="yes" xml:space="preserve">
          <source>This example reads 10 cryptographically secure pseudorandom numbers from rand.Reader and writes them to a byte slice.</source>
          <target state="translated">这个例子从rand.Reader中读取10个加密安全的伪随机数,并将它们写入一个字节片断。</target>
        </trans-unit>
        <trans-unit id="d0f63cae6959df0e63ff45ed07152e8d354e9432" translate="yes" xml:space="preserve">
          <source>This example shows how csv.Reader can be configured to handle other types of CSV files.</source>
          <target state="translated">这个例子展示了如何配置csv.Reader来处理其他类型的CSV文件。</target>
        </trans-unit>
        <trans-unit id="1cca172f7759e3ba0050255d1746af87f660b76a" translate="yes" xml:space="preserve">
          <source>This example shows how to encode an interface value. The key distinction from regular types is to register the concrete type that implements the interface.</source>
          <target state="translated">这个例子展示了如何对一个接口值进行编码。与常规类型的关键区别在于注册实现接口的具体类型。</target>
        </trans-unit>
        <trans-unit id="a3357a230dfc48b693b3b94d9c6611698fcf1171" translate="yes" xml:space="preserve">
          <source>This example shows how to use big.Float to compute the square root of 2 with a precision of 200 bits, and how to print the result as a decimal number.</source>
          <target state="translated">这个例子展示了如何使用big.Float计算精度为200位的2的平方根,以及如何将结果打印为十进制数。</target>
        </trans-unit>
        <trans-unit id="efe429413e771069e2a76db974f921ef42dbdd60" translate="yes" xml:space="preserve">
          <source>This example shows the basic usage of the package: Create an encoder, transmit some values, receive them with a decoder.</source>
          <target state="translated">这个例子展示了这个包的基本用法。创建一个编码器,传输一些值,用解码器接收它们。</target>
        </trans-unit>
        <trans-unit id="4e20892924831ca17c2f745e5365e20b64d74b0e" translate="yes" xml:space="preserve">
          <source>This example shows the use of each of the methods on a *Rand. The use of the global functions is the same, without the receiver.</source>
          <target state="translated">这个例子显示了每个方法在*Rand上的使用。全局函数的使用是一样的,没有接收器。</target>
        </trans-unit>
        <trans-unit id="9dae51dea551843f94a869c5f0aec8bf68e765cc" translate="yes" xml:space="preserve">
          <source>This example shows what an AST looks like when printed for debugging.</source>
          <target state="translated">这个例子显示了AST在打印调试时的样子。</target>
        </trans-unit>
        <trans-unit id="3d4d87b6b74c64cd8a077a3429d1b650786c492b" translate="yes" xml:space="preserve">
          <source>This example transmits a value that implements the custom encoding and decoding methods.</source>
          <target state="translated">这个例子传送了一个实现自定义编码和解码方法的值。</target>
        </trans-unit>
        <trans-unit id="5ad4aea6278dc849132cadb70003c4716078bb1f" translate="yes" xml:space="preserve">
          <source>This example uses RawMessage to delay parsing part of a JSON message.</source>
          <target state="translated">这个例子使用RawMessage来延迟解析JSON消息的一部分。</target>
        </trans-unit>
        <trans-unit id="f3c7cd2790bc702e1c4e8248c880538aa9480232" translate="yes" xml:space="preserve">
          <source>This example uses RawMessage to use a precomputed JSON during marshal.</source>
          <target state="translated">这个例子在marshal过程中使用RawMessage来使用预计算的JSON。</target>
        </trans-unit>
        <trans-unit id="0980067335654187fe3f7c133925d1affa51d747" translate="yes" xml:space="preserve">
          <source>This example uses a Decoder to decode a stream of distinct JSON values.</source>
          <target state="translated">这个例子使用解码器来解码不同的JSON值流。</target>
        </trans-unit>
        <trans-unit id="03fbac2b83cd3991555ff62920bdc91549cc27eb" translate="yes" xml:space="preserve">
          <source>This example uses a Decoder to decode a streaming array of JSON objects.</source>
          <target state="translated">这个例子使用解码器来解码JSON对象的流式数组。</target>
        </trans-unit>
        <trans-unit id="f5365f6fa06883e90b95f7b5b17bc92e07aa1a04" translate="yes" xml:space="preserve">
          <source>This function is deterministic. Thus, if the set of possible messages is small, an attacker may be able to build a map from messages to signatures and identify the signed messages. As ever, signatures provide authenticity, not confidentiality.</source>
          <target state="translated">这个函数是确定性的。因此,如果可能的消息集很小,攻击者可能能够从消息到签名建立一个映射,并识别签名的消息。与以往一样,签名提供的是真实性,而不是保密性。</target>
        </trans-unit>
        <trans-unit id="2d0f1a75b2c9ccfa817de559e09c94b8dbca3151" translate="yes" xml:space="preserve">
          <source>This function will call x509.ParseCertificate unless c.Leaf is set, which can incur a significant performance cost.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21dc4eae53c9012a7d2a049dd7f00db6a6938f5b" translate="yes" xml:space="preserve">
          <source>This function's execution time does not depend on the inputs.</source>
          <target state="translated">这个函数的执行时间不取决于输入。</target>
        </trans-unit>
        <trans-unit id="87202fef0c6c5ae187b02620dfd26b630d0392d4" translate="yes" xml:space="preserve">
          <source>This functionality should only be used with legacy web sites. RFC 2396 warns that interpreting Userinfo this way &amp;ldquo;is NOT RECOMMENDED, because the passing of authentication information in clear text (such as URI) has proven to be a security risk in almost every case where it has been used.&amp;rdquo;</source>
          <target state="translated">此功能只能与旧版网站一起使用。RFC 2396警告说，&amp;ldquo;以这种方式解释Userinfo是不推荐的，因为在几乎所有已使用身份验证信息的情况下，都已证明以明文（例如URI）传递身份验证信息存在安全风险。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="898688304c78e7f2468d53e47407efc6f38af32f" translate="yes" xml:space="preserve">
          <source>This implementation derives the nonce from an AES-CTR CSPRNG keyed by ChopMD(256, SHA2-512(priv.D || entropy || hash)). The CSPRNG key is IRO by a result of Coron; the AES-CTR stream is IRO under standard assumptions.</source>
          <target state="translated">本实施例从AES-CTR CSPRNG中导出非ce,其密钥由ChopMD(256,SHA2-512(priv.D || entropy || hash))获得。CSPRNG的密钥根据Coron的结果是IRO的;AES-CTR流在标准假设下是IRO的。</target>
        </trans-unit>
        <trans-unit id="689c9dd99bb5162e68a9aedd41062dfeb2de0804" translate="yes" xml:space="preserve">
          <source>This implementation derives the nonce from an AES-CTR CSPRNG keyed by:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d67c9b0649198706841943ee7eba2049c49bcdb3" translate="yes" xml:space="preserve">
          <source>This is handled as if &quot;my:data-href&quot; was just &quot;data-href&quot; and not &quot;href&quot; as it would be if the &quot;data-&quot; prefix were to be ignored too. Thus at parse time this becomes just</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2d5c7329f986ca3d31bfdba2057014f5f44ad7d" translate="yes" xml:space="preserve">
          <source>This is only needed to install the handler in a non-standard location.</source>
          <target state="translated">这只需要在非标准位置安装处理程序。</target>
        </trans-unit>
        <trans-unit id="4726b7b6e93eb25607ca12b6c92e41d048948273" translate="yes" xml:space="preserve">
          <source>This is unnecessary as the next call to WriteHeader or Close will implicitly flush out the file's padding.</source>
          <target state="translated">这是不需要的,因为下一次调用WriteHeader或Close会隐含地冲掉文件的padding。</target>
        </trans-unit>
        <trans-unit id="8eba79d25cd0ac07c169a84af16002b1daff283c" translate="yes" xml:space="preserve">
          <source>This kind of key is commonly encoded in PEM blocks of type &quot;EC PRIVATE KEY&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb1b3ed68f800415903edd6e38e6c00b58c4b66a" translate="yes" xml:space="preserve">
          <source>This kind of key is commonly encoded in PEM blocks of type &quot;EC PRIVATE KEY&quot;. For a more flexible key format which is not EC specific, use MarshalPKCS8PrivateKey.</source>
          <target state="translated">这种密钥通常用 &quot;EC PRIVATE KEY &quot;类型的PEM块进行编码。如果想获得更灵活的密钥格式,而且不是EC专用的,可以使用MarshalPKCS8PrivateKey。</target>
        </trans-unit>
        <trans-unit id="56bef0ed59f36389d7550a0e4c48802187b81f7d" translate="yes" xml:space="preserve">
          <source>This kind of key is commonly encoded in PEM blocks of type &quot;EC PUBLIC KEY&quot;.</source>
          <target state="translated">这种密钥通常用 &quot;EC公共密钥 &quot;类型的PEM块进行编码。</target>
        </trans-unit>
        <trans-unit id="dfe352de6a0131091f458f18e937a358eab3152e" translate="yes" xml:space="preserve">
          <source>This kind of key is commonly encoded in PEM blocks of type &quot;PRIVATE KEY&quot;.</source>
          <target state="translated">这种密钥通常用 &quot;PRIVATE KEY &quot;类型的PEM块进行编码。</target>
        </trans-unit>
        <trans-unit id="42db7a056c64d4d64e474ea59fd1650377d9bc54" translate="yes" xml:space="preserve">
          <source>This kind of key is commonly encoded in PEM blocks of type &quot;PUBLIC KEY&quot;.</source>
          <target state="translated">这种密钥通常用 &quot;PUBLIC KEY &quot;类型的PEM块进行编码。</target>
        </trans-unit>
        <trans-unit id="64ab07dfb34f7d2feff364506aca7067a4453b39" translate="yes" xml:space="preserve">
          <source>This kind of key is commonly encoded in PEM blocks of type &quot;RSA PRIVATE KEY&quot;.</source>
          <target state="translated">这种密钥通常用 &quot;RSA PRIVATE KEY &quot;类型的PEM块进行编码。</target>
        </trans-unit>
        <trans-unit id="98a803d28f3224bf7891d32a0db324db326e4afd" translate="yes" xml:space="preserve">
          <source>This kind of key is commonly encoded in PEM blocks of type &quot;RSA PRIVATE KEY&quot;. For a more flexible key format which is not RSA specific, use MarshalPKCS8PrivateKey.</source>
          <target state="translated">这种密钥通常用 &quot;RSA PRIVATE KEY &quot;类型的PEM块进行编码。如果想获得更灵活的密钥格式,而且不是RSA专用的,可以使用MarshalPKCS8PrivateKey。</target>
        </trans-unit>
        <trans-unit id="5d8222cc13301829f5dbdc649eec16abab7d33d6" translate="yes" xml:space="preserve">
          <source>This kind of key is commonly encoded in PEM blocks of type &quot;RSA PUBLIC KEY&quot;.</source>
          <target state="translated">这种密钥通常用 &quot;RSA公共密钥 &quot;类型的PEM块进行编码。</target>
        </trans-unit>
        <trans-unit id="67c7b63689264a63777784c1588c7be8f2ebeb83" translate="yes" xml:space="preserve">
          <source>This means that, by default, command line programs will behave like typical Unix command line programs, while other programs will not crash with SIGPIPE when writing to a closed network connection.</source>
          <target state="translated">这意味着,在默认情况下,命令行程序会像典型的Unix命令行程序一样,而其他程序在写入封闭的网络连接时,不会用SIGPIPE崩溃。</target>
        </trans-unit>
        <trans-unit id="53c41745078961e0cbeedf1ad29b01ea99fe7434" translate="yes" xml:space="preserve">
          <source>This mechanism can be used to cancel long operations on the server if the client has disconnected before the response is ready.</source>
          <target state="translated">如果客户端在响应准备好之前断开了连接,这个机制可以用来取消对服务器的长时间操作。</target>
        </trans-unit>
        <trans-unit id="d3191056acdbdc6fd1ca936f76914f75eb4f8098" translate="yes" xml:space="preserve">
          <source>This mechanism is intended only for trailers that are not known prior to the headers being written. If the set of trailers is fixed or known before the header is written, the normal Go trailers mechanism is preferred:</source>
          <target state="translated">这种机制只适用于在写头之前不知道的线索。如果在写入头之前,跟踪器的集合是固定的或已知的,则首选正常的Go跟踪器机制。</target>
        </trans-unit>
        <trans-unit id="34dfd520d192c4e8193a79a528c0369751354149" translate="yes" xml:space="preserve">
          <source>This method consults the following fields of the response r:</source>
          <target state="translated">本方法会查询响应r的以下字段。</target>
        </trans-unit>
        <trans-unit id="6857cb2d00e6efa4c19dc849fe5f85bb657fb149" translate="yes" xml:space="preserve">
          <source>This method implements crypto.Signer, which is an interface to support keys where the private part is kept in, for example, a hardware module. Common uses should use the Sign function in this package directly.</source>
          <target state="translated">这个方法实现了crypto.Signer,它是一个接口,支持私密部分保存在硬件模块等地方的密钥。普通用途应该直接使用这个包中的Sign函数。</target>
        </trans-unit>
        <trans-unit id="dca73678d958fc56a6644aad153e6b5ae346adb8" translate="yes" xml:space="preserve">
          <source>This method implements crypto.Signer, which is an interface to support keys where the private part is kept in, for example, a hardware module. Common uses should use the Sign* functions in this package directly.</source>
          <target state="translated">这个方法实现了crypto.Signer,它是一个接口,支持私密部分保存在硬件模块等地方的密钥。普通用途应该直接使用这个包中的Sign*函数。</target>
        </trans-unit>
        <trans-unit id="6162e9fff452fe7b81839fc43d5a9b956682d1db" translate="yes" xml:space="preserve">
          <source>This package assumes that template authors are trusted, that Execute's data parameter is not, and seeks to preserve the properties below in the face of untrusted data:</source>
          <target state="translated">本包假设模板作者是受信任的,Execute的数据参数是不受信任的,在面对不受信任的数据时,力求保留以下属性。</target>
        </trans-unit>
        <trans-unit id="646741784bedcfbc50f393efbc21b4c2b803f33a" translate="yes" xml:space="preserve">
          <source>This package does not guarantee bit-identical results across architectures.</source>
          <target state="translated">这个软件包不保证不同架构的位相同结果。</target>
        </trans-unit>
        <trans-unit id="25b183f3fa47240bd162a6084ce81041d00db47f" translate="yes" xml:space="preserve">
          <source>This package does not support disk spanning.</source>
          <target state="translated">这个软件包不支持磁盘跨度。</target>
        </trans-unit>
        <trans-unit id="917226455af3a3e84812552f61aaf5f000d19a66" translate="yes" xml:space="preserve">
          <source>This package favors simplicity over efficiency. Clients that require high-performance serialization, especially for large data structures, should look at more advanced solutions such as the encoding/gob package or protocol buffers.</source>
          <target state="translated">这个包偏重于简单而非效率。需要高性能序列化的客户,特别是对于大型数据结构,应该考虑更高级的解决方案,如编码/gob包或协议缓冲器。</target>
        </trans-unit>
        <trans-unit id="91400ec0be490a039f54a2e8ea4991f07061b72f" translate="yes" xml:space="preserve">
          <source>This package is EXPERIMENTAL. Its current scope is only to allow tests to run, but not yet to provide a comprehensive API for users. It is exempt from the Go compatibility promise.</source>
          <target state="translated">这个包是实验性的。它目前的范围只是允许测试运行,但还没有为用户提供一个全面的API。它免于Go的兼容性承诺。</target>
        </trans-unit>
        <trans-unit id="f172ad46509f2996426e887fe6f7f5b737ccb0ba" translate="yes" xml:space="preserve">
          <source>This package is not implemented on NaCl (Native Client).</source>
          <target state="translated">这个包在NaCl(Native Client)上没有实现。</target>
        </trans-unit>
        <trans-unit id="70b7c3d76332df2a567dd4571a1dd43d36bb3d95" translate="yes" xml:space="preserve">
          <source>This package is not implemented on Plan 9.</source>
          <target state="translated">本套方案在计划9上没有实施。</target>
        </trans-unit>
        <trans-unit id="089323f3519ab53b437d7cbe9878efc86f18d94a" translate="yes" xml:space="preserve">
          <source>This package is not implemented on Windows. As the syslog package is frozen, Windows users are encouraged to use a package outside of the standard library. For background, see &lt;a href=&quot;https://golang.org/issue/1108&quot;&gt;https://golang.org/issue/1108&lt;/a&gt;.</source>
          <target state="translated">Windows上未实现此程序包。由于syslog程序包被冻结，因此鼓励Windows用户使用标准库之外的程序包。有关背景，请参见&lt;a href=&quot;https://golang.org/issue/1108&quot;&gt;https://golang.org/issue/1108&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4c28db944fb8406ea70640148283b4f2b07cfe75" translate="yes" xml:space="preserve">
          <source>This package understands HTML, CSS, JavaScript, and URIs. It adds sanitizing functions to each simple action pipeline, so given the excerpt</source>
          <target state="translated">这个包了解HTML、CSS、JavaScript和URI。它为每个简单的动作流水线添加了消毒功能,所以给定的摘录是</target>
        </trans-unit>
        <trans-unit id="63f9c654258649e0fec61304d0149ff6b7e1fac2" translate="yes" xml:space="preserve">
          <source>This package wraps package text/template so you can share its template API to parse and execute HTML templates safely.</source>
          <target state="translated">这个包封装了package text/template,这样你就可以分享它的模板API来安全地解析和执行HTML模板。</target>
        </trans-unit>
        <trans-unit id="12b81feb5020b97e164b3bd1ab6605720164a33f" translate="yes" xml:space="preserve">
          <source>This palette was used in the Plan 9 Operating System, described at &lt;a href=&quot;https://9p.io/magic/man2html/6/color&quot;&gt;https://9p.io/magic/man2html/6/color&lt;/a&gt;</source>
          <target state="translated">此选板用于&lt;a href=&quot;https://9p.io/magic/man2html/6/color&quot;&gt;https://9p.io/magic/man2html/6/color&lt;/a&gt;中的Plan 9操作系统。</target>
        </trans-unit>
        <trans-unit id="53f264e60d97dda7c8e598fd892c840f64c77bcb" translate="yes" xml:space="preserve">
          <source>This returns a Writer to which the file contents should be written. The file's contents must be written to the io.Writer before the next call to Create, CreateHeader, or Close.</source>
          <target state="translated">这将返回一个写入文件内容的Writer。在下一次调用Create、CreateHeader或Close之前,文件的内容必须被写入io.Writer。</target>
        </trans-unit>
        <trans-unit id="3636f2d8cb7dce3b52ad380d63ea631656bb70da" translate="yes" xml:space="preserve">
          <source>This runtime/trace package provides APIs to add equivalent tracing support to a standalone program. See the Example that demonstrates how to use this API to enable tracing.</source>
          <target state="translated">这个运行时/跟踪包提供了API,可以为独立的程序添加同等的跟踪支持。请参阅示例,演示如何使用该API来启用跟踪。</target>
        </trans-unit>
        <trans-unit id="eb3d7236d288f19d5e07330ec9b641abb7a1c736" translate="yes" xml:space="preserve">
          <source>This section documents the encoding, details that are not important for most users. Details are presented bottom-up.</source>
          <target state="translated">本节记录了编码、细节,这些细节对大多数用户来说并不重要。细节是自下而上的介绍。</target>
        </trans-unit>
        <trans-unit id="8d97dde3cffa35e96f0901463ccd21bc2b7e33d2" translate="yes" xml:space="preserve">
          <source>This set may grow. Note that regular expression matches may need to examine text beyond the text returned by a match, so the methods that match text from a RuneReader may read arbitrarily far into the input before returning.</source>
          <target state="translated">这个集合可能会增加。请注意,正则表达式匹配可能需要检查匹配返回的文本之外的文本,因此匹配来自RuneReader的文本的方法可能会在返回之前任意读取输入的内容。</target>
        </trans-unit>
        <trans-unit id="13155ea54999e3f67a0c6d8a556ef2fb922860ce" translate="yes" xml:space="preserve">
          <source>This should not be done concurrent to other receives from the Timer's channel.</source>
          <target state="translated">这不应该与定时器通道的其他接收同时进行。</target>
        </trans-unit>
        <trans-unit id="0da770375be11542fa319ca413fcc3ece2b576a4" translate="yes" xml:space="preserve">
          <source>This type should be considered identical to sql.IsolationLevel along with any values defined on it.</source>
          <target state="translated">这个类型应该和 sql.IsolationLevel 以及在它上面定义的任何值被认为是相同的。</target>
        </trans-unit>
        <trans-unit id="5cefc7416c362c1afcf6c674cc1720ba6d02139f" translate="yes" xml:space="preserve">
          <source>This type should be considered identical to sql.TxOptions.</source>
          <target state="translated">这个类型应该被认为与 sql.TxOptions 相同。</target>
        </trans-unit>
        <trans-unit id="23bb56893bd9c167f4933bba0f06ea209969209a" translate="yes" xml:space="preserve">
          <source>ThreadCreateProfile returns n, the number of records in the thread creation profile. If len(p) &amp;gt;= n, ThreadCreateProfile copies the profile into p and returns n, true. If len(p) &amp;lt; n, ThreadCreateProfile does not change p and returns n, false.</source>
          <target state="translated">ThreadCreateProfile返回n，即线程创建配置文件中的记录数。如果len（p）&amp;gt; = n，则ThreadCreateProfile将配置文件复制到p中并返回n，为true。如果len（p）&amp;lt;n，则ThreadCreateProfile不会更改p并返回n，否则为false。</target>
        </trans-unit>
        <trans-unit id="aeddfe22a01fc0ff5fb0fe691b08db0b2e2a26c7" translate="yes" xml:space="preserve">
          <source>Tick</source>
          <target state="translated">Tick</target>
        </trans-unit>
        <trans-unit id="26c9fc157a3f52de1aca92922ccb9a288e5fa386" translate="yes" xml:space="preserve">
          <source>Tick is a convenience wrapper for NewTicker providing access to the ticking channel only. While Tick is useful for clients that have no need to shut down the Ticker, be aware that without a way to shut it down the underlying Ticker cannot be recovered by the garbage collector; it &quot;leaks&quot;. Unlike NewTicker, Tick will return nil if d &amp;lt;= 0.</source>
          <target state="translated">Tick是NewTicker的便捷包装，仅提供对滴答通道的访问。虽然Tick对于不需要关闭Ticker的客户端很有用，但是请注意，如果没有关闭Ticker的方法，则垃圾收集器无法恢复基础Ticker；它&amp;ldquo;泄漏&amp;rdquo;。与NewTicker不同，如果d &amp;lt;= 0，则Tick将返回nil。</target>
        </trans-unit>
        <trans-unit id="464b9c4863cbad4e03c3166e6a41a020f20219b8" translate="yes" xml:space="preserve">
          <source>Time instants can be compared using the Before, After, and Equal methods. The Sub method subtracts two instants, producing a Duration. The Add method adds a Time and a Duration, producing a Time.</source>
          <target state="translated">可以使用 &quot;之前&quot;、&quot;之后 &quot;和 &quot;等值 &quot;方法比较时间瞬时。Sub方法减去两个实例,产生一个Duration。添加方法添加一个时间和一个持续时间,产生一个时间。</target>
        </trans-unit>
        <trans-unit id="7e0d5fdb48c2796b9cc511f84f1969b59a9bd1cf" translate="yes" xml:space="preserve">
          <source>Time.Add</source>
          <target state="translated">Time.Add</target>
        </trans-unit>
        <trans-unit id="5c2e779ba4c8677013ab3eb4de9c1e6bf9c9924b" translate="yes" xml:space="preserve">
          <source>Time.AddDate</source>
          <target state="translated">Time.AddDate</target>
        </trans-unit>
        <trans-unit id="730b4aa03b8316a2a6c19e05b72ec5d4eb05e78c" translate="yes" xml:space="preserve">
          <source>Time.After</source>
          <target state="translated">Time.After</target>
        </trans-unit>
        <trans-unit id="d5e86b615c46a18260de62e172d7e06cc20f7083" translate="yes" xml:space="preserve">
          <source>Time.AppendFormat</source>
          <target state="translated">Time.AppendFormat</target>
        </trans-unit>
        <trans-unit id="88be4309d5e0539eff6218d7e8c02ecf0c7b2e65" translate="yes" xml:space="preserve">
          <source>Time.Before</source>
          <target state="translated">Time.Before</target>
        </trans-unit>
        <trans-unit id="480d1c53462d365532b2348e82a3f0dcb963c99e" translate="yes" xml:space="preserve">
          <source>Time.Date</source>
          <target state="translated">Time.Date</target>
        </trans-unit>
        <trans-unit id="ae2638b80e7bdac6e6725adc567cf7badedc6abe" translate="yes" xml:space="preserve">
          <source>Time.Day</source>
          <target state="translated">Time.Day</target>
        </trans-unit>
        <trans-unit id="d4766b7b3328342b5ba1a667334b95afb4c840fd" translate="yes" xml:space="preserve">
          <source>Time.Equal</source>
          <target state="translated">Time.Equal</target>
        </trans-unit>
        <trans-unit id="092fc9098aafde18e6cec288675831ee7d77f8a8" translate="yes" xml:space="preserve">
          <source>Time.Format</source>
          <target state="translated">Time.Format</target>
        </trans-unit>
        <trans-unit id="dd61b8e28117a6a8c31fd714a3696b1193538443" translate="yes" xml:space="preserve">
          <source>Time.Format (Pad)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3768befc26b5bc40a2c6b38ecc6f26a0656a5d40" translate="yes" xml:space="preserve">
          <source>Time.Round</source>
          <target state="translated">Time.Round</target>
        </trans-unit>
        <trans-unit id="5b138a17083c1c36c8bab2fd64e7493a32a70b68" translate="yes" xml:space="preserve">
          <source>Time.String</source>
          <target state="translated">Time.String</target>
        </trans-unit>
        <trans-unit id="e126e45961c85339227ad3c92517287507ec5152" translate="yes" xml:space="preserve">
          <source>Time.Sub</source>
          <target state="translated">Time.Sub</target>
        </trans-unit>
        <trans-unit id="d3f1777c34673ecabb71603383f8d1fd8d6be9c4" translate="yes" xml:space="preserve">
          <source>Time.Truncate</source>
          <target state="translated">Time.Truncate</target>
        </trans-unit>
        <trans-unit id="c4ee117595e7091017dcf807233ec5e3324552ac" translate="yes" xml:space="preserve">
          <source>Time.Unix</source>
          <target state="translated">Time.Unix</target>
        </trans-unit>
        <trans-unit id="f8fc7e6bb582b1829de5a848ff872dea68eff61d" translate="yes" xml:space="preserve">
          <source>TimeFormat is the time format to use when generating times in HTTP headers. It is like time.RFC1123 but hard-codes GMT as the time zone. The time being formatted must be in UTC for Format to generate the correct format.</source>
          <target state="translated">TimeFormat是在HTTP头文件中生成时间时使用的时间格式。它类似于time.RFC1123,但硬编码为GMT作为时区。被格式化的时间必须是UTC,这样Format才能生成正确的格式。</target>
        </trans-unit>
        <trans-unit id="9827d1afd02311b970b1c9ab5d2482ee7f917a5d" translate="yes" xml:space="preserve">
          <source>Timeout reports whether the DNS lookup is known to have timed out. This is not always known; a DNS lookup may fail due to a timeout and return a DNSError for which Timeout returns false.</source>
          <target state="translated">超时报告是否已知DNS查找已经超时。这并不总是已知的;DNS查找可能会因为超时而失败,并返回一个DNSError,Timeout返回false。</target>
        </trans-unit>
        <trans-unit id="927810e8434679578bc9bf07a4312dbfd80340d4" translate="yes" xml:space="preserve">
          <source>Timeout reports whether this error represents a timeout.</source>
          <target state="translated">超时报告该错误是否代表超时。</target>
        </trans-unit>
        <trans-unit id="e7860bff1be7d01a8121a71b30616b2279f825c3" translate="yes" xml:space="preserve">
          <source>TimeoutHandler returns a Handler that runs h with the given time limit.</source>
          <target state="translated">TimeoutHandler返回一个以给定时间限制运行h的处理程序。</target>
        </trans-unit>
        <trans-unit id="41f375b226e7f8e10a9acde2441f73751822f0d4" translate="yes" xml:space="preserve">
          <source>TimeoutHandler supports the Flusher and Pusher interfaces but does not support the Hijacker interface.</source>
          <target state="translated">TimeoutHandler支持Flusher和Pusher接口,但不支持Hijacker接口。</target>
        </trans-unit>
        <trans-unit id="229f8a47d6424d21cc11a27228c5b3dd3021912d" translate="yes" xml:space="preserve">
          <source>TimeoutHandler supports the Pusher interface but does not support the Hijacker or Flusher interfaces.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b94b20b16ca4b5f916aaa1eb8d24553f8d4b92c2" translate="yes" xml:space="preserve">
          <source>TimeoutReader returns ErrTimeout on the second read with no data. Subsequent calls to read succeed.</source>
          <target state="translated">TimeoutReader在第二次读取时返回ErrTimeout,没有数据。随后的读取调用成功。</target>
        </trans-unit>
        <trans-unit id="8bdae2bbf616fbfd5c5eefd29c8a537bd886144c" translate="yes" xml:space="preserve">
          <source>TimespecToNsec converts a Timespec value into a number of nanoseconds since the Unix epoch.</source>
          <target state="translated">TimespecToNsec将Timespec值转换为Unix纪元后的纳秒数。</target>
        </trans-unit>
        <trans-unit id="71641b558817e2a09b865dac9868550ced5db039" translate="yes" xml:space="preserve">
          <source>TimevalToNsec converts a Timeval value into a number of nanoseconds since the Unix epoch.</source>
          <target state="translated">TimevalToNsec将Timeval值转换为Unix纪元后的纳秒数。</target>
        </trans-unit>
        <trans-unit id="768e0c1c69573fb588f61f1308a015c11468e05f" translate="yes" xml:space="preserve">
          <source>Title</source>
          <target state="translated">Title</target>
        </trans-unit>
        <trans-unit id="ee048df59e1fe3a78061c7c9271c635869379b9b" translate="yes" xml:space="preserve">
          <source>Title returns a copy of the string s with all Unicode letters that begin words mapped to their Unicode title case.</source>
          <target state="translated">Title返回字符串s的副本,其中包含所有单词开头的Unicode字母,并映射到Unicode标题大小写。</target>
        </trans-unit>
        <trans-unit id="173f12648645a6edd8fcbab7c7ed0369c007806c" translate="yes" xml:space="preserve">
          <source>Title treats s as UTF-8-encoded bytes and returns a copy with all Unicode letters that begin words mapped to their title case.</source>
          <target state="translated">Title将s视为UTF-8编码的字节,并返回一个包含所有Unicode字母的副本,这些Unicode字母开始的单词都映射到它们的标题大小写。</target>
        </trans-unit>
        <trans-unit id="ae79ea1e9c6391a9ed83a2e18a031b835feec0c9" translate="yes" xml:space="preserve">
          <source>To</source>
          <target state="translated">To</target>
        </trans-unit>
        <trans-unit id="616d61f65a9f91c650c28db92d9cb8984a1f52bd" translate="yes" xml:space="preserve">
          <source>To add equivalent profiling support to a standalone program, add code like the following to your main function:</source>
          <target state="translated">要在独立的程序中添加等效的剖析支持,在你的主函数中添加类似下面的代码。</target>
        </trans-unit>
        <trans-unit id="f6f5822190a6e77b3f6e2423fce4abac430f1e8d" translate="yes" xml:space="preserve">
          <source>To avoid denial of service attacks, the provided bufio.Reader should be reading from an io.LimitReader or similar Reader to bound the size of responses.</source>
          <target state="translated">为了避免拒绝服务攻击,提供的bufio.Reader应该从io.LimitReader或类似的Reader中读取,以约束响应的大小。</target>
        </trans-unit>
        <trans-unit id="87386ad5a06e96430212748899697cda9d7a3724" translate="yes" xml:space="preserve">
          <source>To avoid recursion in cases such as</source>
          <target state="translated">为了避免递归的情况,如</target>
        </trans-unit>
        <trans-unit id="a87f0fb7c131221874ae3b0c17104f44ee1c34bc" translate="yes" xml:space="preserve">
          <source>To be backwards compatible the FileHeader has both 32 and 64 bit Size fields. The 64 bit fields will always contain the correct value and for normal archives both fields will be the same. For files requiring the ZIP64 format the 32 bit fields will be 0xffffffff and the 64 bit fields must be used instead.</source>
          <target state="translated">为了向后兼容,FileHeader有32位和64位大小字段。64位的字段将始终包含正确的值,对于普通的存档,两个字段将是相同的。对于需要ZIP64格式的文件,32位字段为0xffffffffff,必须使用64位字段。</target>
        </trans-unit>
        <trans-unit id="f0c9c2ba0d3b42114f628f0336b7d63f8138a666" translate="yes" xml:space="preserve">
          <source>To build a file only when using cgo, and only on Linux and OS X:</source>
          <target state="translated">只有在使用cgo时才能建立文件,而且只能在Linux和OS X上建立。</target>
        </trans-unit>
        <trans-unit id="b59fa373960766ba2850aeb1bfd6ebb3acccc2d0" translate="yes" xml:space="preserve">
          <source>To build strings more efficiently, see the strings.Builder type.</source>
          <target state="translated">为了更有效地构建字符串,请参见strings.Builder类型。</target>
        </trans-unit>
        <trans-unit id="65822ab438826bd3303521dc362fbdb7385f9c68" translate="yes" xml:space="preserve">
          <source>To change the destination for flag messages, call CommandLine.SetOutput.</source>
          <target state="translated">要改变标志信息的目的地,请调用CommandLine.SetOutput。</target>
        </trans-unit>
        <trans-unit id="697c0150c9b1eec40f18c8aa7919a2878d3bf00a" translate="yes" xml:space="preserve">
          <source>To compare two Values, compare the results of the Interface method. Using == on two Values does not compare the underlying values they represent.</source>
          <target state="translated">要比较两个值,比较接口方法的结果。在两个值上使用==不会比较它们所代表的基本值。</target>
        </trans-unit>
        <trans-unit id="26bcf90200ee4c383ef61356b62c1cde915663a4" translate="yes" xml:space="preserve">
          <source>To complete the example above, the following code tries to find the value x in an integer slice data sorted in ascending order:</source>
          <target state="translated">为了完成上面的例子,下面的代码试图在一个升序排序的整数片数据中找到值x。</target>
        </trans-unit>
        <trans-unit id="48862e3dd334f932c3f29aca76cb78295d40632d" translate="yes" xml:space="preserve">
          <source>To compute the number of allocations, the function will first be run once as a warm-up. The average number of allocations over the specified number of runs will then be measured and returned.</source>
          <target state="translated">要计算分配数量,首先要运行一次函数作为热身。然后测量并返回指定运行次数的平均分配数量。</target>
        </trans-unit>
        <trans-unit id="a1b4d9690ab97f466c6d326d8c742f5be1f15108" translate="yes" xml:space="preserve">
          <source>To convert an integer number of units to a Duration, multiply:</source>
          <target state="translated">要将整数单位转换为持续时间,请乘以。</target>
        </trans-unit>
        <trans-unit id="c70ea98cf5f708e17c34d681b2e9583414cbfaae" translate="yes" xml:space="preserve">
          <source>To count the number of units in a Duration, divide:</source>
          <target state="translated">要计算一个Duration中的单位数,除以。</target>
        </trans-unit>
        <trans-unit id="a8a481566ee5c9f4011b251f076b7cff25d2b336" translate="yes" xml:space="preserve">
          <source>To create a new request with a context, use NewRequestWithContext. To change the context of a request (such as an incoming) you then also want to modify to send back out, use Request.Clone. Between those two uses, it's rare to need WithContext.</source>
          <target state="translated">要创建一个带有上下文的新请求,使用NewRequestWithContext。要改变一个请求的上下文(比如一个传入的请求),然后你也想修改后再发送出去,使用Request.Clone.WithContext。在这两种用法之间,很少需要WithContext。</target>
        </trans-unit>
        <trans-unit id="df17ef73a333723433e10a65752b7d97c8d742ec" translate="yes" xml:space="preserve">
          <source>To create a new request with a context, use NewRequestWithContext. To change the context of a request, such as an incoming request you want to modify before sending back out, use Request.Clone. Between those two uses, it's rare to need WithContext.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1ce4e028f3adf6fe5e3e3ea8b7a3ce1d7c4cce0" translate="yes" xml:space="preserve">
          <source>To create the Pos value for a specific source offset (measured in bytes), first add the respective file to the current file set using FileSet.AddFile and then call File.Pos(offset) for that file. Given a Pos value p for a specific file set fset, the corresponding Position value is obtained by calling fset.Position(p).</source>
          <target state="translated">要为特定的源偏移量(以字节为单位)创建Pos值,首先使用FileSet.AddFile将相应的文件添加到当前的文件集中,然后为该文件调用File.Pos(offset)。给定一个特定文件集fset的Pos值p,通过调用fset.Position(p)获得相应的Position值。</target>
        </trans-unit>
        <trans-unit id="ffa6362a850b5571ec14ab520e75aaa3f0b772a0" translate="yes" xml:space="preserve">
          <source>To define a type, the encoder chooses an unused, positive type id and sends the pair (-type id, encoded-type) where encoded-type is the gob encoding of a wireType description, constructed from these types:</source>
          <target state="translated">为了定义一个类型,编码器选择一个未使用的正类型id,并发送一对(-type id,encoded-type),其中encoded-type是wireType描述的gob编码,由这些类型构造而成。</target>
        </trans-unit>
        <trans-unit id="da43583df08c2ff7e4692ba80d3b2cf801b80a61" translate="yes" xml:space="preserve">
          <source>To define your own format, write down what the reference time would look like formatted your way; see the values of constants like ANSIC, StampMicro or Kitchen for examples. The model is to demonstrate what the reference time looks like so that the Format and Parse methods can apply the same transformation to a general time value.</source>
          <target state="translated">要定义你自己的格式,请写下参考时间按你的方式格式化后的样子;参见ANSIC、StampMicro或Kitchen等常量的值来举例。这个模型是为了演示参考时间是什么样子的,这样Format和Parse方法就可以对一般的时间值进行同样的转换。</target>
        </trans-unit>
        <trans-unit id="79806cf1eaac70011a5e985d3751306c16fa37ee" translate="yes" xml:space="preserve">
          <source>To distinguish build constraints from package documentation, a series of build constraints must be followed by a blank line.</source>
          <target state="translated">为了将构建约束与包文档区分开来,一系列的构建约束后面必须有一个空行。</target>
        </trans-unit>
        <trans-unit id="a50607887789cbea54ccb0db0c455e312a84417e" translate="yes" xml:space="preserve">
          <source>To ensure the channel is empty after a call to Stop, check the return value and drain the channel. For example, assuming the program has not received from t.C already:</source>
          <target state="translated">为了确保在调用Stop后通道是空的,检查返回值并排出通道。例如,假设程序还没有从t.C接收到。</target>
        </trans-unit>
        <trans-unit id="dc7659d0594b1222a7c79baf65726fd2fc8fc92f" translate="yes" xml:space="preserve">
          <source>To escape a text segment, bracket it with Escape characters. For instance, the tab in this string &quot;Ignore this tab: \xff\t\xff&quot; does not terminate a cell and constitutes a single character of width one for formatting purposes.</source>
          <target state="translated">要转义一个文本段,请用Escape字符将其括起来。例如,这个字符串中的制表符 &quot;忽略这个制表符。\xffff/t/xff &quot;并没有结束一个单元格,而是构成一个宽度为1的单字符,用于格式化。</target>
        </trans-unit>
        <trans-unit id="a3866d2c65d6d17db1dce0e7ab464336a1186960" translate="yes" xml:space="preserve">
          <source>To force integer division of Int operands, use op == token.QUO_ASSIGN instead of token.QUO; the result is guaranteed to be Int in this case. Division by zero leads to a run-time panic.</source>
          <target state="translated">要强制Int操作数的整数除法,使用op ==token.QUO_ASSIGN取代token.QUO;在这种情况下,保证结果是Int。除以零会导致运行时的恐慌。</target>
        </trans-unit>
        <trans-unit id="93f96dd1110bc83e45c261305087ab59ccdab5c6" translate="yes" xml:space="preserve">
          <source>To generate HTML output, see package html/template, which has the same interface as this package but automatically secures HTML output against certain attacks.</source>
          <target state="translated">要生成HTML输出,请参见包html/template,它的界面与本包相同,但能自动保证HTML输出不受某些攻击。</target>
        </trans-unit>
        <trans-unit id="0f37e1016d8b746740d606c5f03bd61a370f62be" translate="yes" xml:space="preserve">
          <source>To generate a client HTTP request instead of a server request, see the NewRequest function in the net/http package.</source>
          <target state="translated">要生成一个客户端的HTTP请求而不是服务器请求,请参见net/http包中的NewRequest函数。</target>
        </trans-unit>
        <trans-unit id="06a96f64d7d0f413489f0372ff0c9c5459591c5b" translate="yes" xml:space="preserve">
          <source>To include every allocated block in the profile, set MemProfileRate to 1. To turn off profiling entirely, set MemProfileRate to 0.</source>
          <target state="translated">要将每个分配的块都包含在配置文件中,将MemProfileRate设置为1。 要完全关闭配置文件,将MemProfileRate设置为0。</target>
        </trans-unit>
        <trans-unit id="1cf82e7adf1a06dc5b4204dd8949c669c22a6ce1" translate="yes" xml:space="preserve">
          <source>To include every blocking event in the profile, pass rate = 1. To turn off profiling entirely, pass rate &amp;lt;= 0.</source>
          <target state="translated">要将每个阻止事件包括在配置文件中，合格率=1。要完全关闭分析，合格率&amp;lt;= 0。</target>
        </trans-unit>
        <trans-unit id="5634feb2ac7b66d9d403fa3ba44d3dd35de4aafa" translate="yes" xml:space="preserve">
          <source>To insert a literal $ in the output, use $$ in the template.</source>
          <target state="translated">要在输出中插入一个字面的$,请在模板中使用$。</target>
        </trans-unit>
        <trans-unit id="fc7c25c25b23cfac629203b1f680a734ada8bcd7" translate="yes" xml:space="preserve">
          <source>To iterate over a list (where l is a *List):</source>
          <target state="translated">遍历一个列表(其中l是一个*List)。</target>
        </trans-unit>
        <trans-unit id="04464b93c140cce60515e90ab741d559641a3b86" translate="yes" xml:space="preserve">
          <source>To keep a file from being considered for the build:</source>
          <target state="translated">为了防止一个文件被认为是构建。</target>
        </trans-unit>
        <trans-unit id="b8dd565d2e14c4949f658d07fd948bd6982afd99" translate="yes" xml:space="preserve">
          <source>To make a request with custom headers, use NewRequest and Client.Do.</source>
          <target state="translated">要使用自定义头信息进行请求,请使用NewRequest和Client.Do。</target>
        </trans-unit>
        <trans-unit id="5032a2d57ff9e66d730ea600879b156b0a5e02a1" translate="yes" xml:space="preserve">
          <source>To make a request with custom headers, use NewRequest and DefaultClient.Do.</source>
          <target state="translated">要使用自定义头信息进行请求,请使用NewRequest和DefaultClient.Do。</target>
        </trans-unit>
        <trans-unit id="706ee8ff1d514d4082de19c46038d881341df0b9" translate="yes" xml:space="preserve">
          <source>To maps the rune to the specified case: UpperCase, LowerCase, or TitleCase.</source>
          <target state="translated">要将符文映射到指定的大小写。大写,小写,或标题大小写。</target>
        </trans-unit>
        <trans-unit id="13858e1fce15a0a8116d4d08d0813cfa32d04dd1" translate="yes" xml:space="preserve">
          <source>To prevent IP spoofing, be sure to delete any pre-existing X-Forwarded-For header coming from the client or an untrusted proxy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16db8fa630b8ed6e5e098c9ecc986852e23449ff" translate="yes" xml:space="preserve">
          <source>To prevent duplicate operations, ErrBadConn should NOT be returned if there's a possibility that the database server might have performed the operation. Even if the server sends back an error, you shouldn't return ErrBadConn.</source>
          <target state="translated">为了防止重复操作,如果数据库服务器有可能执行了操作,就不应该返回ErrBadConn。即使服务器发回一个错误,也不应该返回ErrBadConn。</target>
        </trans-unit>
        <trans-unit id="367a95ef6b89677c6010e99bfe83911bb6aa0ff5" translate="yes" xml:space="preserve">
          <source>To remove a prefix, use TrimPrefix instead.</source>
          <target state="translated">要删除前缀,请使用 TrimPrefix。</target>
        </trans-unit>
        <trans-unit id="651b4bc851ab5004fd129e9e0ff7675d7d666cef" translate="yes" xml:space="preserve">
          <source>To remove a suffix, use TrimSuffix instead.</source>
          <target state="translated">要删除后缀,请使用 TrimSuffix。</target>
        </trans-unit>
        <trans-unit id="c83bbc4183fb8f4e0540869ebe8099226ccd8816" translate="yes" xml:space="preserve">
          <source>To set custom headers, use NewRequest and Client.Do.</source>
          <target state="translated">要设置自定义的头,使用NewRequest和Client.Do。</target>
        </trans-unit>
        <trans-unit id="71135b9f4481c76b2f670b0d39a1f656b3961a0f" translate="yes" xml:space="preserve">
          <source>To set custom headers, use NewRequest and DefaultClient.Do.</source>
          <target state="translated">要设置自定义的头,使用NewRequest和DefaultClient.Do。</target>
        </trans-unit>
        <trans-unit id="db9b30900d9da4419f81d83d998e553e2dab25bb" translate="yes" xml:space="preserve">
          <source>To support custom data types, implement NamedValueChecker. NamedValueChecker also allows queries to accept per-query options as a parameter by returning ErrRemoveArgument from CheckNamedValue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75e0a568234c8cc832fa169bfc3c25d385870808" translate="yes" xml:space="preserve">
          <source>To translate these PCs into symbolic information such as function names and line numbers, use CallersFrames. CallersFrames accounts for inlined functions and adjusts the return program counters into call program counters. Iterating over the returned slice of PCs directly is discouraged, as is using FuncForPC on any of the returned PCs, since these cannot account for inlining or return program counter adjustment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83002d8cdc0fe4d874cff59ee6e149e3669f91df" translate="yes" xml:space="preserve">
          <source>To translate these PCs into symbolic information such as function names and line numbers, use CallersFrames. CallersFrames accounts for inlined functions and adjusts the return program counters into call program counters. Iterating over the returned slice of PCs directly is discouraged, as is using FuncForPC on any of the returned PCs, since these cannot account for inlining or return program counter adjustment. go:noinline</source>
          <target state="translated">要将这些PC转化为函数名和行号等符号信息,可以使用CallersFrames。CallersFrames对内联函数进行核算,并将返回的程序计数器调整为调用程序计数器。不鼓励直接在返回的PC片上进行迭代,也不鼓励在任何返回的PC上使用FuncForPC,因为这些不能说明内联或返回程序计数器的调整。 go:noinline</target>
        </trans-unit>
        <trans-unit id="3b553336a2ed0371927e0210cc490999d6f454c6" translate="yes" xml:space="preserve">
          <source>To turn off profiling entirely, pass rate 0. To just read the current rate, pass rate &amp;lt; 0. (For n&amp;gt;1 the details of sampling may change.)</source>
          <target state="translated">要完全关闭性能分析，请通过率0。要仅读取当前速率，请通过率&amp;lt;0。（对于n&amp;gt; 1，采样的详细信息可能会更改。）</target>
        </trans-unit>
        <trans-unit id="ec0c40fcb609291204c17f8d3e9e4a0cf0fb716d" translate="yes" xml:space="preserve">
          <source>To unmarshal JSON into a pointer, Unmarshal first handles the case of the JSON being the JSON literal null. In that case, Unmarshal sets the pointer to nil. Otherwise, Unmarshal unmarshals the JSON into the value pointed at by the pointer. If the pointer is nil, Unmarshal allocates a new value for it to point to.</source>
          <target state="translated">要将JSON解压缩成一个指针,Unmarshal首先要处理JSON是JSON文字空的情况。在这种情况下,Unmarshal会将指针设置为nil。否则,Unmarshal会将JSON解马尔什化为指针指向的值。如果指针为nil,Unmarshal为其分配一个新的值。</target>
        </trans-unit>
        <trans-unit id="9ec7dbd6621b41728144a0cd3fc2c36f64948e68" translate="yes" xml:space="preserve">
          <source>To unmarshal JSON into a struct, Unmarshal matches incoming object keys to the keys used by Marshal (either the struct field name or its tag), preferring an exact match but also accepting a case-insensitive match. By default, object keys which don't have a corresponding struct field are ignored (see Decoder.DisallowUnknownFields for an alternative).</source>
          <target state="translated">为了将JSON解压缩成结构体,Unmarshal将传入的对象键与Marshal使用的键(结构体字段名或它的标签)进行匹配,喜欢完全匹配,但也接受不区分大小写的匹配。默认情况下,没有对应的结构体字段的对象键会被忽略(参见Decoder.DisallowUnknownFields获取替代方案)。</target>
        </trans-unit>
        <trans-unit id="a6bdbb20d4135a3bc4596a68aa8c2c34912d504d" translate="yes" xml:space="preserve">
          <source>To unmarshal JSON into a value implementing the Unmarshaler interface, Unmarshal calls that value's UnmarshalJSON method, including when the input is a JSON null. Otherwise, if the value implements encoding.TextUnmarshaler and the input is a JSON quoted string, Unmarshal calls that value's UnmarshalText method with the unquoted form of the string.</source>
          <target state="translated">要将JSON解马尔什到一个实现Unmarshaler接口的值中,Unmarshal调用该值的UnmarshalJSON方法,包括当输入是JSON null时。否则,如果值实现了encoding.TextUnmarshaler,并且输入是JSON引号的字符串,Unmarshal就用字符串的未引号形式调用该值的UnmarshalText方法。</target>
        </trans-unit>
        <trans-unit id="c66b5ce0cf55557d8e9fd777ec15355bade4e117" translate="yes" xml:space="preserve">
          <source>To unmarshal JSON into an interface value, Unmarshal stores one of these in the interface value:</source>
          <target state="translated">要将JSON解读成一个接口值,Unmarshal会在接口值中存储其中一个。</target>
        </trans-unit>
        <trans-unit id="94c1b420cdca6fe4940f209d9a41f19875bfb4e7" translate="yes" xml:space="preserve">
          <source>To unmarshal a JSON array into a Go array, Unmarshal decodes JSON array elements into corresponding Go array elements. If the Go array is smaller than the JSON array, the additional JSON array elements are discarded. If the JSON array is smaller than the Go array, the additional Go array elements are set to zero values.</source>
          <target state="translated">要将JSON数组拆解为Go数组,Unmarshal将JSON数组元素解码为相应的Go数组元素。如果Go数组小于JSON数组,那么额外的JSON数组元素将被丢弃。如果JSON数组小于Go数组,则额外的Go数组元素被设置为零值。</target>
        </trans-unit>
        <trans-unit id="ed4bdd964a47161b70a00bdaa7dc00eb114dff57" translate="yes" xml:space="preserve">
          <source>To unmarshal a JSON array into a slice, Unmarshal resets the slice length to zero and then appends each element to the slice. As a special case, to unmarshal an empty JSON array into a slice, Unmarshal replaces the slice with a new empty slice.</source>
          <target state="translated">要将一个JSON数组解马尔什化为一个分片,Unmarshal将分片长度重置为零,然后将每个元素追加到分片中。作为一种特殊情况,如果要将一个空的JSON数组解马尔什化为一个分片,Unmarshal会用一个新的空分片来替换这个分片。</target>
        </trans-unit>
        <trans-unit id="007b32960f68d5d51b318bb76ca9ea0286f4126d" translate="yes" xml:space="preserve">
          <source>To unmarshal a JSON object into a map, Unmarshal first establishes a map to use. If the map is nil, Unmarshal allocates a new map. Otherwise Unmarshal reuses the existing map, keeping existing entries. Unmarshal then stores key-value pairs from the JSON object into the map. The map's key type must either be a string, an integer, or implement encoding.TextUnmarshaler.</source>
          <target state="translated">要将一个JSON对象拆解成地图,Unmarshal首先要建立一个要使用的地图。如果地图是nil,Unmarshal会分配一个新的地图。否则,Unmarshal会重新使用现有的地图,保留现有的条目。然后Unmarshal将JSON对象中的键值对存储到map中。地图的键类型必须是字符串、整数或实现 encoding.TextUnmarshaler。</target>
        </trans-unit>
        <trans-unit id="6d6fc53f4b0d33aa877b6d747d45b96f410c47fc" translate="yes" xml:space="preserve">
          <source>To unmarshal a JSON object into a map, Unmarshal first establishes a map to use. If the map is nil, Unmarshal allocates a new map. Otherwise Unmarshal reuses the existing map, keeping existing entries. Unmarshal then stores key-value pairs from the JSON object into the map. The map's key type must either be any string type, an integer, implement json.Unmarshaler, or implement encoding.TextUnmarshaler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b87bf4d25ca4624c96c72d4062afc898f384fa73" translate="yes" xml:space="preserve">
          <source>To use a Pipeline p to manage multiple clients on a connection, each client should run:</source>
          <target state="translated">要使用Pipeline p来管理一个连接上的多个客户端,每个客户端都应该运行。</target>
        </trans-unit>
        <trans-unit id="f6369ce890fdc06aa42e060bacdc465b9893f8d9" translate="yes" xml:space="preserve">
          <source>To use a fixed length slice, or a preallocated one, use FillBytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="800eefdd201759f89cf9257524a524d86be67a56" translate="yes" xml:space="preserve">
          <source>To use an existing prepared statement on this transaction, see Tx.Stmt.</source>
          <target state="translated">若要使用现有的已编制的报表进行交易,请参见Tx.Stmt.</target>
        </trans-unit>
        <trans-unit id="0c3bf1a32c9b769f727db4118e0b83ca4bb4efa4" translate="yes" xml:space="preserve">
          <source>To use gobs, create an Encoder and present it with a series of data items as values or addresses that can be dereferenced to values. The Encoder makes sure all type information is sent before it is needed. At the receive side, a Decoder retrieves values from the encoded stream and unpacks them into local variables.</source>
          <target state="translated">要使用gobs,请创建一个Encoder,并将一系列数据项以值或地址的形式呈现给它,这些值或地址可以被导出引用到值。Encoder确保所有的类型信息在需要之前被发送。在接收端,解码器从编码流中检索值,并将它们解包到本地变量中。</target>
        </trans-unit>
        <trans-unit id="8212c55a0bf9e12d2e296b39237ee5f72cae9d11" translate="yes" xml:space="preserve">
          <source>To use pprof, link this package into your program:</source>
          <target state="translated">要使用pprof,请将这个软件包链接到你的程序中。</target>
        </trans-unit>
        <trans-unit id="5c29e8288fd1ed9e073fe203fb55fbea12d062de" translate="yes" xml:space="preserve">
          <source>To use the operating system's file system implementation, use http.Dir:</source>
          <target state="translated">要使用操作系统的文件系统实现,使用http.Dir。</target>
        </trans-unit>
        <trans-unit id="467272919dc8f37262b26b52d65afd618589f7ff" translate="yes" xml:space="preserve">
          <source>To view all available profiles, open &lt;a href=&quot;http://localhost:6060/debug/pprof/&quot;&gt;http://localhost:6060/debug/pprof/&lt;/a&gt; in your browser.</source>
          <target state="translated">要查看所有可用的配置文件，请在浏览器中打开&lt;a href=&quot;http://localhost:6060/debug/pprof/&quot;&gt;http：// localhost：6060 / debug / pprof /&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4193fe2d5f7ce0c7cb324cbe3968e7d5bd540d92" translate="yes" xml:space="preserve">
          <source>To write a new test suite, create a file whose name ends _test.go that contains the TestXxx functions as described here. Put the file in the same package as the one being tested. The file will be excluded from regular package builds but will be included when the &quot;go test&quot; command is run. For more detail, run &quot;go help test&quot; and &quot;go help testflag&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1229c7d06cb687b015bf9729398a1b9b76a455a" translate="yes" xml:space="preserve">
          <source>To write a new test suite, create a file whose name ends _test.go that contains the TestXxx functions as described here. Put the file in the same package as the one being tested. The file will be excluded from regular package builds but will be included when the &amp;ldquo;go test&amp;rdquo; command is run. For more detail, run &amp;ldquo;go help test&amp;rdquo; and &amp;ldquo;go help testflag&amp;rdquo;.</source>
          <target state="translated">要编写新的测试套件，请创建一个名称以_test.go结尾的文件，其中包含TestXxx函数，如此处所述。将文件与要测试的文件放在同一软件包中。该文件将从常规软件包生成中排除，但在运行&amp;ldquo; go test&amp;rdquo;命令时将包括在内。有关更多详细信息，请运行&amp;ldquo; go help test&amp;rdquo;和&amp;ldquo; go help testflag&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="2392dbedc5657df0a5a8c5b158593f759c811858" translate="yes" xml:space="preserve">
          <source>To16 converts the IP address ip to a 16-byte representation. If ip is not an IP address (it is the wrong length), To16 returns nil.</source>
          <target state="translated">To16 将 IP 地址 ip 转换为 16 字节的表示形式。如果ip不是一个IP地址(长度不对),To16返回nil。</target>
        </trans-unit>
        <trans-unit id="4294dda7ebb07f9702b0ce5cc1cb8bbf6e004822" translate="yes" xml:space="preserve">
          <source>To4 converts the IPv4 address ip to a 4-byte representation. If ip is not an IPv4 address, To4 returns nil.</source>
          <target state="translated">To4 将 IPv4 地址 ip 转换为一个 4 字节的表示形式,如果 ip 不是 IPv4 地址,To4 返回 nil。如果ip不是IPv4地址,To4返回nil。</target>
        </trans-unit>
        <trans-unit id="7deadbf704990f79d3e4df9686f8846e15431131" translate="yes" xml:space="preserve">
          <source>ToComplex converts x to a Complex value if x is representable as a Complex. Otherwise it returns an Unknown.</source>
          <target state="translated">如果x可以表示为复数,ToComplex将x转换为一个复数值,否则返回一个未知值。否则返回一个未知值。</target>
        </trans-unit>
        <trans-unit id="95e3b1fabb27004c6322f401e410b77c8beecafb" translate="yes" xml:space="preserve">
          <source>ToFloat converts x to a Float value if x is representable as a Float. Otherwise it returns an Unknown.</source>
          <target state="translated">如果x可表示为Float,ToFloat将x转换为Float值。否则它返回一个未知值。</target>
        </trans-unit>
        <trans-unit id="f5e30e0ab3c38971ff0a23a0823ee7ab2da27587" translate="yes" xml:space="preserve">
          <source>ToHTML converts comment text to formatted HTML. The comment was prepared by DocReader, so it is known not to have leading, trailing blank lines nor to have trailing spaces at the end of lines. The comment markers have already been removed.</source>
          <target state="translated">ToHTML将注释文本转换为格式化的HTML。该注释是由DocReader编写的,所以已知它没有前导、尾部的空行,也没有行末的尾部空格。注释标记已经被删除。</target>
        </trans-unit>
        <trans-unit id="2f4af6e587a0b093dcea21d741f457946dac2539" translate="yes" xml:space="preserve">
          <source>ToInt converts x to an Int value if x is representable as an Int. Otherwise it returns an Unknown.</source>
          <target state="translated">如果x可以表示为Int,则ToInt将x转换为Int值。否则返回一个未知值。</target>
        </trans-unit>
        <trans-unit id="2458b21542ecbc0f90f413b7ee46521686d711b0" translate="yes" xml:space="preserve">
          <source>ToLower</source>
          <target state="translated">ToLower</target>
        </trans-unit>
        <trans-unit id="6fec192e916332e15759b9ef1699226d11bdd209" translate="yes" xml:space="preserve">
          <source>ToLower maps the rune to lower case giving priority to the special mapping.</source>
          <target state="translated">ToLower将符文映射为小写,优先考虑特殊映射。</target>
        </trans-unit>
        <trans-unit id="0d0c9cd1331838718de8a67a4fe3f8edaf0bf598" translate="yes" xml:space="preserve">
          <source>ToLower maps the rune to lower case.</source>
          <target state="translated">ToLower将符文映射为小写。</target>
        </trans-unit>
        <trans-unit id="0ad2eff81c68ba7feeec4169aa737e669765ecb3" translate="yes" xml:space="preserve">
          <source>ToLower returns a copy of the byte slice s with all Unicode letters mapped to their lower case.</source>
          <target state="translated">ToLower 返回所有 Unicode 字母映射为小写的字节片断 s 的副本。</target>
        </trans-unit>
        <trans-unit id="9ce8fb31583c9a3f9db4dda94a7dc14fcb01df77" translate="yes" xml:space="preserve">
          <source>ToLower returns s with all Unicode letters mapped to their lower case.</source>
          <target state="translated">ToLower 返回所有 Unicode 字母映射为小写的 s。</target>
        </trans-unit>
        <trans-unit id="7c6c5994143b17fa29690098b9cf21d8ab0c9626" translate="yes" xml:space="preserve">
          <source>ToLowerSpecial</source>
          <target state="translated">ToLowerSpecial</target>
        </trans-unit>
        <trans-unit id="a0c9710a46fb772958369a0897c7471714aeeeb8" translate="yes" xml:space="preserve">
          <source>ToLowerSpecial returns a copy of the string s with all Unicode letters mapped to their lower case using the case mapping specified by c.</source>
          <target state="translated">ToLowerSpecial返回字符串s的副本,并使用c指定的大小写映射将所有Unicode字母映射为小写。</target>
        </trans-unit>
        <trans-unit id="cb046f134facad4d83f3df18153937dc0992ea81" translate="yes" xml:space="preserve">
          <source>ToLowerSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their lower case, giving priority to the special casing rules.</source>
          <target state="translated">ToLowerSpecial将s视为UTF-8编码的字节,并返回一个包含所有Unicode字母映射为小写字母的副本,优先考虑特殊的编码规则。</target>
        </trans-unit>
        <trans-unit id="494e4ed4c22e6b9204664a8671089fb351d285ee" translate="yes" xml:space="preserve">
          <source>ToRDNSequence converts n into a single RDNSequence. The following attributes are encoded as multi-value RDNs:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2915308ca78a335773afea42473f5f868e85f100" translate="yes" xml:space="preserve">
          <source>ToSlash returns the result of replacing each separator character in path with a slash ('/') character. Multiple separators are replaced by multiple slashes.</source>
          <target state="translated">ToSlash 返回用斜线('/')替换路径中每个分隔符的结果。多个分隔符会被多个斜线代替。</target>
        </trans-unit>
        <trans-unit id="ce9610dd835f1269c70383a5f4c28b5a0b063015" translate="yes" xml:space="preserve">
          <source>ToText prepares comment text for presentation in textual output. It wraps paragraphs of text to width or fewer Unicode code points and then prefixes each line with the indent. In preformatted sections (such as program text), it prefixes each non-blank line with preIndent.</source>
          <target state="translated">ToText 为文本输出中的注释文本做准备。它将文本段落包装成宽度或更少的Unicode码点,然后在每行前加上缩进。在预格式化的部分(如程序文本)中,它将每一行非空白行前缀为preIndent。</target>
        </trans-unit>
        <trans-unit id="687882b6dd58f630b4dc72d2b748bc2e5e517506" translate="yes" xml:space="preserve">
          <source>ToTitle</source>
          <target state="translated">ToTitle</target>
        </trans-unit>
        <trans-unit id="16626ca02836f3e96b71ac083f67d856672bee6a" translate="yes" xml:space="preserve">
          <source>ToTitle maps the rune to title case giving priority to the special mapping.</source>
          <target state="translated">ToTitle将符文映射到标题案,优先考虑特殊映射。</target>
        </trans-unit>
        <trans-unit id="82652cb33ebff96d0745bbb70b7b14b2b4f648b7" translate="yes" xml:space="preserve">
          <source>ToTitle maps the rune to title case.</source>
          <target state="translated">ToTitle将符文映射到标题案。</target>
        </trans-unit>
        <trans-unit id="b6339ce57388ab9579ed7dea7397386892cd79b3" translate="yes" xml:space="preserve">
          <source>ToTitle returns a copy of the string s with all Unicode letters mapped to their Unicode title case.</source>
          <target state="translated">ToTitle返回字符串s的副本,所有Unicode字母都映射到Unicode标题大小写。</target>
        </trans-unit>
        <trans-unit id="7c8bdbfdcd905744bd6bd92b5f2c2fe7b0b2a605" translate="yes" xml:space="preserve">
          <source>ToTitle treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their title case.</source>
          <target state="translated">ToTitle将s视为UTF-8编码的字节,并返回一个包含所有Unicode字母映射到标题大小写的副本。</target>
        </trans-unit>
        <trans-unit id="a7e031c3da9f939af57fa1eda658027190b07385" translate="yes" xml:space="preserve">
          <source>ToTitleSpecial</source>
          <target state="translated">ToTitleSpecial</target>
        </trans-unit>
        <trans-unit id="6c2252d5e081e10993ad66199a6ce0f9c88000da" translate="yes" xml:space="preserve">
          <source>ToTitleSpecial returns a copy of the string s with all Unicode letters mapped to their Unicode title case, giving priority to the special casing rules.</source>
          <target state="translated">ToTitleSpecial返回字符串s的副本,其中所有Unicode字母都被映射到Unicode标题大小写中,优先考虑特殊的编码规则。</target>
        </trans-unit>
        <trans-unit id="03ad764cc2cf6e71773b140dd2607d85f903d19e" translate="yes" xml:space="preserve">
          <source>ToTitleSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their title case, giving priority to the special casing rules.</source>
          <target state="translated">ToTitleSpecial将s视为UTF-8编码的字节,并返回一个包含所有Unicode字母映射到其标题大小写的副本,优先考虑特殊的编码规则。</target>
        </trans-unit>
        <trans-unit id="0c72db5394ee29e5b12a191ab1a0f08579c43c0b" translate="yes" xml:space="preserve">
          <source>ToUpper</source>
          <target state="translated">ToUpper</target>
        </trans-unit>
        <trans-unit id="8830c3933f2751182fd45204e5ac41041c190ab0" translate="yes" xml:space="preserve">
          <source>ToUpper maps the rune to upper case giving priority to the special mapping.</source>
          <target state="translated">ToUpper将符文映射为大写,优先考虑特殊映射。</target>
        </trans-unit>
        <trans-unit id="9762b6a1a0f8f68d12efc0853373d81b1198caf9" translate="yes" xml:space="preserve">
          <source>ToUpper maps the rune to upper case.</source>
          <target state="translated">ToUpper将符文映射为大写。</target>
        </trans-unit>
        <trans-unit id="587e23bede12f256b7a2b187d202dc77575c043c" translate="yes" xml:space="preserve">
          <source>ToUpper returns a copy of the byte slice s with all Unicode letters mapped to their upper case.</source>
          <target state="translated">ToUpper 返回所有 Unicode 字母映射为大写的字节片断 s 的副本。</target>
        </trans-unit>
        <trans-unit id="1567cbaa93e2803c0387b5e052b94febf77b0dce" translate="yes" xml:space="preserve">
          <source>ToUpper returns s with all Unicode letters mapped to their upper case.</source>
          <target state="translated">ToUpper 返回所有 Unicode 字母映射为大写的 s。</target>
        </trans-unit>
        <trans-unit id="e8e18cf71c085c852139f777c3a777629eaba1d4" translate="yes" xml:space="preserve">
          <source>ToUpperSpecial</source>
          <target state="translated">ToUpperSpecial</target>
        </trans-unit>
        <trans-unit id="ca298ca7f1f797ffc04335283b821c4509371407" translate="yes" xml:space="preserve">
          <source>ToUpperSpecial returns a copy of the string s with all Unicode letters mapped to their upper case using the case mapping specified by c.</source>
          <target state="translated">ToUpperSpecial返回字符串s的副本,并使用c指定的大小写映射将所有Unicode字母映射为大写。</target>
        </trans-unit>
        <trans-unit id="e092426a213e149b750e5c739fd48245f35d6f1d" translate="yes" xml:space="preserve">
          <source>ToUpperSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their upper case, giving priority to the special casing rules.</source>
          <target state="translated">ToUpperSpecial将s视为UTF-8编码的字节,并返回一个包含所有Unicode字母映射为大写字母的副本,优先考虑特殊的编码规则。</target>
        </trans-unit>
        <trans-unit id="2918f3c11590ab69ac359dd26f3078e378d4433f" translate="yes" xml:space="preserve">
          <source>ToValidUTF8 returns a copy of the string s with each run of invalid UTF-8 byte sequences replaced by the replacement string, which may be empty.</source>
          <target state="translated">ToValidUTF8返回字符串s的副本,每运行一次无效的UTF-8字节序列就被替换字符串所取代,该字符串可能是空的。</target>
        </trans-unit>
        <trans-unit id="8ddb5599f330dcf8a14e657f65440d11567b1275" translate="yes" xml:space="preserve">
          <source>ToValidUTF8 treats s as UTF-8-encoded bytes and returns a copy with each run of bytes representing invalid UTF-8 replaced with the bytes in replacement, which may be empty.</source>
          <target state="translated">ToValidUTF8将s视为UTF-8编码的字节,并返回一个副本,每运行一次代表无效UTF-8的字节就替换成替换中的字节,替换中的字节可能是空的。</target>
        </trans-unit>
        <trans-unit id="0e6e43d719b59d2f4b6d64b0d7506414e902ac66" translate="yes" xml:space="preserve">
          <source>Token expands self-closing elements such as &amp;lt;br/&amp;gt; into separate start and end elements returned by successive calls.</source>
          <target state="translated">令牌将诸如&amp;lt;br/&amp;gt;之类的自闭合元素扩展为由连续调用返回的单独的开始和结束元素。</target>
        </trans-unit>
        <trans-unit id="76c580b187cf47d391aca0669ed50d6bdc842bd1" translate="yes" xml:space="preserve">
          <source>Token guarantees that the StartElement and EndElement tokens it returns are properly nested and matched: if Token encounters an unexpected end element or EOF before all expected end elements, it will return an error.</source>
          <target state="translated">Token保证它返回的StartElement和EndElement标记是正确嵌套和匹配的:如果Token遇到一个意外的结束元素或在所有预期的结束元素之前的EOF,它将返回一个错误。</target>
        </trans-unit>
        <trans-unit id="20226a10555b22d829b042743665e60ca5ccfcef" translate="yes" xml:space="preserve">
          <source>Token guarantees that the delimiters [ ] { } it returns are properly nested and matched: if Token encounters an unexpected delimiter in the input, it will return an error.</source>
          <target state="translated">Token 保证它返回的定界符[]{}是正确嵌套和匹配的:如果 Token 在输入中遇到一个意外的定界符,它将返回一个错误。</target>
        </trans-unit>
        <trans-unit id="d280a9431f5d23758a555c6128dd19caf82e90f5" translate="yes" xml:space="preserve">
          <source>Token implements XML name spaces as described by &lt;a href=&quot;https://www.w3.org/TR/REC-xml-names/&quot;&gt;https://www.w3.org/TR/REC-xml-names/&lt;/a&gt;. Each of the Name structures contained in the Token has the Space set to the URL identifying its name space when known. If Token encounters an unrecognized name space prefix, it uses the prefix as the Space rather than report an error.</source>
          <target state="translated">令牌实现了&lt;a href=&quot;https://www.w3.org/TR/REC-xml-names/&quot;&gt;https://www.w3.org/TR/REC-xml-names/中&lt;/a&gt;描述的XML名称空间。令牌中包含的每个名称结构都有一个设置为URL的空格，以便在知道时标识其名称空间。如果令牌遇到无法识别的名称空间前缀，它将使用该前缀作为空格，而不是报告错误。</target>
        </trans-unit>
        <trans-unit id="3daac00da8a20a3986aa0fc3ba367725df5511ad" translate="yes" xml:space="preserve">
          <source>Token is the set of lexical tokens of the Go programming language.</source>
          <target state="translated">Token是围棋编程语言的词性标记集。</target>
        </trans-unit>
        <trans-unit id="347b518b7ad14bbb5cbe2525a0e1cce83a18759e" translate="yes" xml:space="preserve">
          <source>Token returns the next JSON token in the input stream. At the end of the input stream, Token returns nil, io.EOF.</source>
          <target state="translated">Token返回输入流中的下一个JSON token,在输入流结束时,Token返回nil,io.EOF。在输入流结束时,Token返回nil,io.EOF。</target>
        </trans-unit>
        <trans-unit id="fb460c5b7cbda3e107ef11644b412428d80a074a" translate="yes" xml:space="preserve">
          <source>Token returns the next XML token in the input stream. At the end of the input stream, Token returns nil, io.EOF.</source>
          <target state="translated">Token返回输入流中的下一个XML token,在输入流结束时,Token返回nil,io.EOF。在输入流结束时,Token返回nil,io.EOF。</target>
        </trans-unit>
        <trans-unit id="1f5c5f661288844b6f2ecd574998016319ee9039" translate="yes" xml:space="preserve">
          <source>TokenString returns a printable string for a token or Unicode character.</source>
          <target state="translated">TokenString 返回一个可打印的标记或Unicode字符的字符串。</target>
        </trans-unit>
        <trans-unit id="1a94c716310bd537564c947b302962f8f4ba3d71" translate="yes" xml:space="preserve">
          <source>TokenText returns the string corresponding to the most recently scanned token. Valid after calling Scan and in calls of Scanner.Error.</source>
          <target state="translated">TokenText 返回最近扫描的标记对应的字符串。在调用Scan后和调用Scanner.Error.TokenText时有效。</target>
        </trans-unit>
        <trans-unit id="a7a728d87ab600f19a872de7d10dd426fc51a410" translate="yes" xml:space="preserve">
          <source>ToolDir is the directory containing build tools.</source>
          <target state="translated">ToolDir是包含构建工具的目录。</target>
        </trans-unit>
        <trans-unit id="84f632ebde53766b4762c1e662046a0bdb1f9bee" translate="yes" xml:space="preserve">
          <source>Trace responds with the execution trace in binary form. Tracing lasts for duration specified in seconds GET parameter, or for 1 second if not specified. The package initialization registers it as /debug/pprof/trace.</source>
          <target state="translated">跟踪以二进制形式响应执行跟踪。追踪的持续时间用GET参数second指定,如果没有指定则为1秒。软件包初始化时将其注册为/debug/pprof/trace。</target>
        </trans-unit>
        <trans-unit id="37fcf61c233a1ae946b84a69b2de57281c31900c" translate="yes" xml:space="preserve">
          <source>Tracing runtime activities</source>
          <target state="translated">追踪运行时活动</target>
        </trans-unit>
        <trans-unit id="bf930f74e883c038922957814259a08b1e5e21b8" translate="yes" xml:space="preserve">
          <source>TrailerPrefix is a magic prefix for ResponseWriter.Header map keys that, if present, signals that the map entry is actually for the response trailers, and not the response headers. The prefix is stripped after the ServeHTTP call finishes and the values are sent in the trailers.</source>
          <target state="translated">TrailerPrefix是ResponseWriter.Header映射键的一个神奇的前缀,如果存在,则表明该映射条目实际上是针对响应拖车的,而不是响应头。这个前缀会在ServeHTTP调用完成后被剥离,并在拖车中发送值。</target>
        </trans-unit>
        <trans-unit id="d08af63de6fd07c70bf3724749899391ccd80f36" translate="yes" xml:space="preserve">
          <source>TrailingZeroBits returns the number of consecutive least significant zero bits of |x|.</source>
          <target state="translated">TrailingZeroBits 返回 |x| 的连续最小有效零位数。</target>
        </trans-unit>
        <trans-unit id="173da913d8c53620762557efaa7f685234fe0888" translate="yes" xml:space="preserve">
          <source>TrailingZeros returns the number of trailing zero bits in x; the result is UintSize for x == 0.</source>
          <target state="translated">TrailingZeros 返回 x 中的尾部零位数;对于 x ==0,结果是 UintSize。</target>
        </trans-unit>
        <trans-unit id="3880be13b458ed7d8fd6226152f09a84df60affe" translate="yes" xml:space="preserve">
          <source>TrailingZeros16</source>
          <target state="translated">TrailingZeros16</target>
        </trans-unit>
        <trans-unit id="ac0e8b17c92ec54246a916c7c60a5898e47d2440" translate="yes" xml:space="preserve">
          <source>TrailingZeros16 returns the number of trailing zero bits in x; the result is 16 for x == 0.</source>
          <target state="translated">TrailingZeros16 返回x中的尾部零位数;对于x ==0,结果是16。</target>
        </trans-unit>
        <trans-unit id="9ccb48d1009c49f2458e70054ffb06de2c2e52b1" translate="yes" xml:space="preserve">
          <source>TrailingZeros32</source>
          <target state="translated">TrailingZeros32</target>
        </trans-unit>
        <trans-unit id="ef12b2bd72258ab1ea24487faaf1b36b6624d53b" translate="yes" xml:space="preserve">
          <source>TrailingZeros32 returns the number of trailing zero bits in x; the result is 32 for x == 0.</source>
          <target state="translated">TrailingZeros32 返回x中的尾部零位数;对于x ==0,结果是32。</target>
        </trans-unit>
        <trans-unit id="8645dda5fc4ccfbadfe816f019759dd903a6b384" translate="yes" xml:space="preserve">
          <source>TrailingZeros64</source>
          <target state="translated">TrailingZeros64</target>
        </trans-unit>
        <trans-unit id="9c1806ac56295eeda1305a5c016e361813241700" translate="yes" xml:space="preserve">
          <source>TrailingZeros64 returns the number of trailing zero bits in x; the result is 64 for x == 0.</source>
          <target state="translated">TrailingZeros64 返回x中的尾部零位数;对于x ==0,结果是64。</target>
        </trans-unit>
        <trans-unit id="56b19e298a41e007826d31fb347a4fad087efb44" translate="yes" xml:space="preserve">
          <source>TrailingZeros8</source>
          <target state="translated">TrailingZeros8</target>
        </trans-unit>
        <trans-unit id="a51f3a70d56ba40f5381588670a32ee940f76014" translate="yes" xml:space="preserve">
          <source>TrailingZeros8 returns the number of trailing zero bits in x; the result is 8 for x == 0.</source>
          <target state="translated">TrailingZeros8返回x中的尾部零位数;对于x==0,结果是8。</target>
        </trans-unit>
        <trans-unit id="c46e526f87b0902843d5c82001fbd44e74d2f2d7" translate="yes" xml:space="preserve">
          <source>Transport is an implementation of RoundTripper that supports HTTP, HTTPS, and HTTP proxies (for either HTTP or HTTPS with CONNECT).</source>
          <target state="translated">Transport是RoundTripper的一个实现,支持HTTP、HTTPS和HTTP代理(对于HTTP或HTTPS与CONNECT)。</target>
        </trans-unit>
        <trans-unit id="28030ddb48df392e29b838aa75a73353cb5390cf" translate="yes" xml:space="preserve">
          <source>Transport only retries a request upon encountering a network error if the request is idempotent and either has no body or has its Request.GetBody defined. HTTP requests are considered idempotent if they have HTTP methods GET, HEAD, OPTIONS, or TRACE; or if their Header map contains an &quot;Idempotency-Key&quot; or &quot;X-Idempotency-Key&quot; entry. If the idempotency key value is a zero-length slice, the request is treated as idempotent but the header is not sent on the wire.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a7dd5c9993ccdafc8353b9b9fef9d118c35957f" translate="yes" xml:space="preserve">
          <source>Transport only retries a request upon encountering a network error if the request is idempotent and either has no body or has its Request.GetBody defined. HTTP requests are considered idempotent if they have HTTP methods GET, HEAD, OPTIONS, or TRACE; or if their Header map contains an &quot;Idempotency-Key&quot; or &quot;X-Idempotency-Key&quot; entry. If the idempotency key value is an zero-length slice, the request is treated as idempotent but the header is not sent on the wire.</source>
          <target state="translated">如果请求是idempotent的,并且没有body或者定义了Request.GetBody,那么Transport只会在遇到网络错误时重试请求。如果HTTP请求有HTTP方法GET、HEAD、OPTIONS或TRACE,或者它们的Header映射包含 &quot;Idempotency-Key &quot;或 &quot;X-Idempotency-Key &quot;条目,则被认为是幂等的。如果idempotency key的值是一个零长度的分片,那么该请求将被视为idempotent,但线上不会发送头。</target>
        </trans-unit>
        <trans-unit id="a83654a5778fc158c90c291f8461263d34090fc9" translate="yes" xml:space="preserve">
          <source>Transport uses HTTP/1.1 for HTTP URLs and either HTTP/1.1 or HTTP/2 for HTTPS URLs, depending on whether the server supports HTTP/2, and how the Transport is configured. The DefaultTransport supports HTTP/2. To explicitly enable HTTP/2 on a transport, use golang.org/x/net/http2 and call ConfigureTransport. See the package docs for more about HTTP/2.</source>
          <target state="translated">Transport对HTTP URL使用HTTP/1.1,对HTTPS URL使用HTTP/1.1或HTTP/2,这取决于服务器是否支持HTTP/2,以及Transport的配置方式。DefaultTransport支持HTTP/2。要在传输中明确启用 HTTP/2,请使用 golang.org/x/net/http2 并调用 ConfigureTransport。有关HTTP/2的更多信息,请参见软件包文档。</target>
        </trans-unit>
        <trans-unit id="5cba3ebebe9967d6b406fbd61cc05ffea9ddcf56" translate="yes" xml:space="preserve">
          <source>Transports should be reused instead of created as needed. Transports are safe for concurrent use by multiple goroutines.</source>
          <target state="translated">移植应该被重复使用,而不是根据需要创建。移植是安全的,可以被多个goroutine同时使用。</target>
        </trans-unit>
        <trans-unit id="cf5547182a53dd7a581affea62258ee59e262b85" translate="yes" xml:space="preserve">
          <source>Tree is the representation of a single parsed template.</source>
          <target state="translated">树是单个解析模板的表示。</target>
        </trans-unit>
        <trans-unit id="0266abd25371ad4670b041dda4dc487ed199d641" translate="yes" xml:space="preserve">
          <source>Trim</source>
          <target state="translated">Trim</target>
        </trans-unit>
        <trans-unit id="abb910d5bd0bd319cf1d5ef7ad6a5112dc6c0823" translate="yes" xml:space="preserve">
          <source>Trim returns a slice of the string s with all leading and trailing Unicode code points contained in cutset removed.</source>
          <target state="translated">Trim返回字符串s的一个片断,其中包含在cutet中的所有前导和后导Unicode码点。</target>
        </trans-unit>
        <trans-unit id="4f07669cc579ec14df811b3ca5fc72fde4f78f58" translate="yes" xml:space="preserve">
          <source>Trim returns a subslice of s by slicing off all leading and trailing UTF-8-encoded code points contained in cutset.</source>
          <target state="translated">Trim通过切断cutet中包含的所有前导和尾部UTF-8编码的代码点来返回s的子片。</target>
        </trans-unit>
        <trans-unit id="ba1962dfeb4e006658709dd72ff841213f7d1db0" translate="yes" xml:space="preserve">
          <source>TrimBytes returns b without leading and trailing ASCII space.</source>
          <target state="translated">TrimBytes 返回 b,不含前导和尾部 ASCII 空间。</target>
        </trans-unit>
        <trans-unit id="a48987784fdcef3e797c48099ede26a7260db2de" translate="yes" xml:space="preserve">
          <source>TrimFunc</source>
          <target state="translated">TrimFunc</target>
        </trans-unit>
        <trans-unit id="03343404f4f9dd2a23fda87bf2a4805f3806059d" translate="yes" xml:space="preserve">
          <source>TrimFunc returns a slice of the string s with all leading and trailing Unicode code points c satisfying f(c) removed.</source>
          <target state="translated">TrimFunc 返回字符串 s 的一个片断,其中包含所有满足 f(c)的前导和尾部 Unicode 码点。</target>
        </trans-unit>
        <trans-unit id="625b4a484772db3f9992725f710f3d189c47d0db" translate="yes" xml:space="preserve">
          <source>TrimFunc returns a subslice of s by slicing off all leading and trailing UTF-8-encoded code points c that satisfy f(c).</source>
          <target state="translated">TrimFunc通过切掉所有满足f(c)的前导和尾部UTF-8编码的码点c来返回s的子片。</target>
        </trans-unit>
        <trans-unit id="b796ff265d1cc90c9b78c76a3f12dd8cbff027a6" translate="yes" xml:space="preserve">
          <source>TrimLeft</source>
          <target state="translated">TrimLeft</target>
        </trans-unit>
        <trans-unit id="3406f99b35b8781b2e30c5d4f1fb92b18ccfb0a0" translate="yes" xml:space="preserve">
          <source>TrimLeft returns a slice of the string s with all leading Unicode code points contained in cutset removed.</source>
          <target state="translated">TrimLeft 返回字符串 s 的一个片断,其中包含在 cutet 中的所有前导 Unicode 码点。</target>
        </trans-unit>
        <trans-unit id="b52b880dc01fa22cd46ff385a39b5609f426247b" translate="yes" xml:space="preserve">
          <source>TrimLeft returns a subslice of s by slicing off all leading UTF-8-encoded code points contained in cutset.</source>
          <target state="translated">TrimLeft通过切断cutet中包含的所有前导UTF-8编码的码点来返回s的子片。</target>
        </trans-unit>
        <trans-unit id="0dda8e3188c1b3df6f3a5c77e5010dd280c96425" translate="yes" xml:space="preserve">
          <source>TrimLeftFunc</source>
          <target state="translated">TrimLeftFunc</target>
        </trans-unit>
        <trans-unit id="2a771ac81b0579d70a2a4390b741d5fed266d711" translate="yes" xml:space="preserve">
          <source>TrimLeftFunc returns a slice of the string s with all leading Unicode code points c satisfying f(c) removed.</source>
          <target state="translated">TrimLeftFunc返回字符串s的一个片断,并删除所有满足f(c)的Unicode前导码点c。</target>
        </trans-unit>
        <trans-unit id="49c15e330f226f8800b406f97802237df2f3f947" translate="yes" xml:space="preserve">
          <source>TrimLeftFunc treats s as UTF-8-encoded bytes and returns a subslice of s by slicing off all leading UTF-8-encoded code points c that satisfy f(c).</source>
          <target state="translated">TrimLeftFunc将s视为UTF-8编码的字节,并通过切掉所有满足f(c)的前导UTF-8编码码点c来返回s的子片。</target>
        </trans-unit>
        <trans-unit id="f6781400f56acf5b8bc035e02b3cdac08b09ae64" translate="yes" xml:space="preserve">
          <source>TrimPrefix</source>
          <target state="translated">TrimPrefix</target>
        </trans-unit>
        <trans-unit id="0cdb8742fe0e8f96e729ab0932195bcd75f8a8b2" translate="yes" xml:space="preserve">
          <source>TrimPrefix returns s without the provided leading prefix string. If s doesn't start with prefix, s is returned unchanged.</source>
          <target state="translated">TrimPrefix返回s,不包含提供的前缀字符串。如果s不以前缀开始,则返回s不变。</target>
        </trans-unit>
        <trans-unit id="3a3dc250671844d052f305fc24e91daa5dfaf78b" translate="yes" xml:space="preserve">
          <source>TrimRight</source>
          <target state="translated">TrimRight</target>
        </trans-unit>
        <trans-unit id="f36ec5b5c4656d60b56116c5bdb688d629f84c86" translate="yes" xml:space="preserve">
          <source>TrimRight returns a slice of the string s, with all trailing Unicode code points contained in cutset removed.</source>
          <target state="translated">TrimRight返回字符串s的一个片断,并删除所有包含在cuteset中的尾部Unicode码点。</target>
        </trans-unit>
        <trans-unit id="3ca08db3862d11ac280fa859c98a5062cca7758f" translate="yes" xml:space="preserve">
          <source>TrimRight returns a subslice of s by slicing off all trailing UTF-8-encoded code points that are contained in cutset.</source>
          <target state="translated">TrimRight通过切掉所有包含在cutset中的尾部UTF-8编码的码点来返回s的子片。</target>
        </trans-unit>
        <trans-unit id="2face4904f1360f377438b017515ff3c2359f581" translate="yes" xml:space="preserve">
          <source>TrimRightFunc</source>
          <target state="translated">TrimRightFunc</target>
        </trans-unit>
        <trans-unit id="91f9e348fa7e18e840cf0ac3e8dc3a6295b78762" translate="yes" xml:space="preserve">
          <source>TrimRightFunc returns a slice of the string s with all trailing Unicode code points c satisfying f(c) removed.</source>
          <target state="translated">TrimRightFunc 返回字符串 s 的一个片断,并删除所有满足 f(c)的 Unicode 码点。</target>
        </trans-unit>
        <trans-unit id="af58ad241c06498d7e5d96dabf6a334e19cb450d" translate="yes" xml:space="preserve">
          <source>TrimRightFunc returns a subslice of s by slicing off all trailing UTF-8-encoded code points c that satisfy f(c).</source>
          <target state="translated">TrimRightFunc通过切掉所有满足f(c)的UTF-8编码的尾部码点c来返回s的子片。</target>
        </trans-unit>
        <trans-unit id="3b9759ef917cd034e3fff66af6781ac1144ddf76" translate="yes" xml:space="preserve">
          <source>TrimSpace</source>
          <target state="translated">TrimSpace</target>
        </trans-unit>
        <trans-unit id="fb7131e90264c0cc3ce43bd31575b4282b5313c8" translate="yes" xml:space="preserve">
          <source>TrimSpace returns a slice of the string s, with all leading and trailing white space removed, as defined by Unicode.</source>
          <target state="translated">TrimSpace返回字符串s的一个片断,其中所有的前导和尾部的空白空间都被删除,如Unicode所定义。</target>
        </trans-unit>
        <trans-unit id="a187e5cf0dba2afc1b0487c662e640873854f7ec" translate="yes" xml:space="preserve">
          <source>TrimSpace returns a subslice of s by slicing off all leading and trailing white space, as defined by Unicode.</source>
          <target state="translated">TrimSpace通过切去Unicode定义的所有前导和尾部的空白空间来返回s的子片段。</target>
        </trans-unit>
        <trans-unit id="b11fe2b91f56619862961192ca92d40d14d67c9d" translate="yes" xml:space="preserve">
          <source>TrimString returns s without leading and trailing ASCII space.</source>
          <target state="translated">TrimString返回不含前导和尾部ASCII空格的s。</target>
        </trans-unit>
        <trans-unit id="31564f1b1fc10c6dcf98b0ba8f0d174cf833e697" translate="yes" xml:space="preserve">
          <source>TrimSuffix</source>
          <target state="translated">TrimSuffix</target>
        </trans-unit>
        <trans-unit id="92a8263afbc0fa4c5341e4098b039907219bbb45" translate="yes" xml:space="preserve">
          <source>TrimSuffix returns s without the provided trailing suffix string. If s doesn't end with suffix, s is returned unchanged.</source>
          <target state="translated">TrimSuffix返回s,不包含提供的后缀字符串。如果s不以后缀结尾,则返回s不变。</target>
        </trans-unit>
        <trans-unit id="0b8272d0bb8c9199c72411e406f2643a93b7ccca" translate="yes" xml:space="preserve">
          <source>Trunc</source>
          <target state="translated">Trunc</target>
        </trans-unit>
        <trans-unit id="4ac265259166695b742658a267b27c17c43d2d87" translate="yes" xml:space="preserve">
          <source>Trunc returns the integer value of x.</source>
          <target state="translated">Trunc返回x的整数值。</target>
        </trans-unit>
        <trans-unit id="a6f2f1d850d6a1bef2ab8b526d322b73779287f1" translate="yes" xml:space="preserve">
          <source>Truncate changes the size of the file. It does not change the I/O offset. If there is an error, it will be of type *PathError.</source>
          <target state="translated">Truncate会改变文件的大小。它不改变I/O偏移量。如果有错误,它的类型是*PathError。</target>
        </trans-unit>
        <trans-unit id="062334176014417d736c93d4f00898bc3b617151" translate="yes" xml:space="preserve">
          <source>Truncate changes the size of the named file. If the file is a symbolic link, it changes the size of the link's target. If there is an error, it will be of type *PathError.</source>
          <target state="translated">Truncate改变命名文件的大小。如果文件是一个符号链接,它将改变链接目标的大小。如果有一个错误,它的类型是*PathError。</target>
        </trans-unit>
        <trans-unit id="e8c4ef35e7ba4d40ba29121e1bd589ff3e80bcb3" translate="yes" xml:space="preserve">
          <source>Truncate discards all but the first n unread bytes from the buffer but continues to use the same allocated storage. It panics if n is negative or greater than the length of the buffer.</source>
          <target state="translated">Truncate丢弃缓冲区中除前n个未读字节外的所有字节,但继续使用相同的分配存储空间。如果n为负数或大于缓冲区的长度,它会惊慌失措。</target>
        </trans-unit>
        <trans-unit id="32beb0b08a1549453f279d1334d844a2afaea49a" translate="yes" xml:space="preserve">
          <source>Truncate operates on the time as an absolute duration since the zero time; it does not operate on the presentation form of the time. Thus, Truncate(Hour) may return a time with a non-zero minute, depending on the time's Location.</source>
          <target state="translated">Truncate 对时间的操作是指从零点开始的绝对持续时间;它不对时间的表现形式进行操作。因此,Truncate(Hour)可能会返回一个非零分钟的时间,这取决于时间的位置。</target>
        </trans-unit>
        <trans-unit id="71998d5a06a6fc24a70aad616e3e9f7ea3e57939" translate="yes" xml:space="preserve">
          <source>Truncate returns the result of rounding d toward zero to a multiple of m. If m &amp;lt;= 0, Truncate returns d unchanged.</source>
          <target state="translated">截断返回将d朝零舍入到m的倍数的结果。如果m &amp;lt;= 0，则Truncate不变地返回d。</target>
        </trans-unit>
        <trans-unit id="498fecdf2960f4ea8c81a3634a3c6208f18d44bd" translate="yes" xml:space="preserve">
          <source>Truncate returns the result of rounding t down to a multiple of d (since the zero time). If d &amp;lt;= 0, Truncate returns t stripped of any monotonic clock reading but otherwise unchanged.</source>
          <target state="translated">Truncate返回将t向下舍入为d的倍数的结果（因为零时间）。如果d &amp;lt;= 0，则Truncate返回t，去除了任何单调时钟读数，但未更改。</target>
        </trans-unit>
        <trans-unit id="7a922bb8e2913cab6dcad5ba9140345fb42fa502" translate="yes" xml:space="preserve">
          <source>TruncateWriter returns a Writer that writes to w but stops silently after n bytes.</source>
          <target state="translated">TruncateWriter 返回一个向 w 写入但在 n 个字节后默默停止的 Writer。</target>
        </trans-unit>
        <trans-unit id="66617c3163f43664fa6ddb9c95a7d88a932b782b" translate="yes" xml:space="preserve">
          <source>Truthy returns the JavaScript &quot;truthiness&quot; of the value v. In JavaScript, false, 0, &quot;&quot;, null, undefined, and NaN are &quot;falsy&quot;, and everything else is &quot;truthy&quot;. See &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Truthy&quot;&gt;https://developer.mozilla.org/en-US/docs/Glossary/Truthy&lt;/a&gt;.</source>
          <target state="translated">Truthy返回值v的JavaScript&amp;ldquo;真实性&amp;rdquo;。在JavaScript中，false，0，&amp;ldquo;&amp;rdquo;，null，undefined和NaN为&amp;ldquo; falsy&amp;rdquo;，其他所有内容均为&amp;ldquo; truthy&amp;rdquo;。请参阅&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Truthy&quot;&gt;https://developer.mozilla.org/en-US/docs/Glossary/Truthy&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c26728b3acc2b9a34150900b5536db30082f4043" translate="yes" xml:space="preserve">
          <source>TryRecv attempts to receive a value from the channel v but will not block. It panics if v's Kind is not Chan. If the receive delivers a value, x is the transferred value and ok is true. If the receive cannot finish without blocking, x is the zero Value and ok is false. If the channel is closed, x is the zero value for the channel's element type and ok is false.</source>
          <target state="translated">TryRecv 试图从通道 v 中接收一个值,但不会阻塞。如果v的Kind不是Chan,它就会恐慌。如果接收到一个值,x是传输的值,ok为true。如果receive不能在不阻塞的情况下完成,x为零值,ok为假。如果通道被关闭,x是通道的元素类型的零值,ok为假。</target>
        </trans-unit>
        <trans-unit id="febc1b0170a31256a4ba31c38646abd1c14c7afb" translate="yes" xml:space="preserve">
          <source>TrySend attempts to send x on the channel v but will not block. It panics if v's Kind is not Chan. It reports whether the value was sent. As in Go, x's value must be assignable to the channel's element type.</source>
          <target state="translated">TrySend试图在v通道上发送x,但不会被阻止。如果v的Kind不是Chan,它就会恐慌。它报告值是否被发送。在围棋中,x的值必须可以分配给通道的元素类型。</target>
        </trans-unit>
        <trans-unit id="7fd5a63a31a17c2aa8f2b5b0d5183f5173b04681" translate="yes" xml:space="preserve">
          <source>Two keys are only considered to have the same value if they have the same Curve value. Note that for example elliptic.P256() and elliptic.P256().Params() are different values, as the latter is a generic not constant time implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad904f452afce8318d85fd92e9c6e068ca4fed6e" translate="yes" xml:space="preserve">
          <source>Two sets of interfaces are included in this package. When a more abstract interface isn't necessary, there are functions for encrypting/decrypting with v1.5/OAEP and signing/verifying with v1.5/PSS. If one needs to abstract over the public key primitive, the PrivateKey type implements the Decrypter and Signer interfaces from the crypto package.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="042f2d498c44806f60201f1f05491910d5c73fe8" translate="yes" xml:space="preserve">
          <source>Two sets of interfaces are included in this package. When a more abstract interface isn't necessary, there are functions for encrypting/decrypting with v1.5/OAEP and signing/verifying with v1.5/PSS. If one needs to abstract over the public-key primitive, the PrivateKey struct implements the Decrypter and Signer interfaces from the crypto package.</source>
          <target state="translated">本包中包含两套接口。当不需要更抽象的接口时,有一些函数用于用v1.5/OAEP加密/解密和用v1.5/PSS签名/验证。如果需要对公钥基元进行抽象,那么PrivateKey结构实现了crypto包中的Decrypter和Signer接口。</target>
        </trans-unit>
        <trans-unit id="021677bbd9ee4b61e5a1312cf21d452a27661c48" translate="yes" xml:space="preserve">
          <source>Tx is a transaction.</source>
          <target state="translated">Tx是一种交易。</target>
        </trans-unit>
        <trans-unit id="02cdcf0d841ea4d5e8abf2653c842d138120149a" translate="yes" xml:space="preserve">
          <source>Tx is an in-progress database transaction.</source>
          <target state="translated">Tx是一个进行中的数据库事务。</target>
        </trans-unit>
        <trans-unit id="41b6053676814b4fe97b2c9be9a306ee614bfa3d" translate="yes" xml:space="preserve">
          <source>Tx.ExecContext</source>
          <target state="translated">Tx.ExecContext</target>
        </trans-unit>
        <trans-unit id="2825856698e10e430365413d889b83a20654a02a" translate="yes" xml:space="preserve">
          <source>Tx.Prepare</source>
          <target state="translated">Tx.Prepare</target>
        </trans-unit>
        <trans-unit id="ef76ba4edb63dbd2cd7bf54f9037e276e1229e5a" translate="yes" xml:space="preserve">
          <source>Tx.Rollback</source>
          <target state="translated">Tx.Rollback</target>
        </trans-unit>
        <trans-unit id="a83fe983647bcf7e1590d7bef39b1b437680667a" translate="yes" xml:space="preserve">
          <source>TxOptions holds the transaction options to be used in DB.BeginTx.</source>
          <target state="translated">TxOptions持有DB.BeginTx中要使用的事务选项。</target>
        </trans-unit>
        <trans-unit id="46eaf072cf758f74571ec8685b65883630652645" translate="yes" xml:space="preserve">
          <source>TxOptions holds the transaction options.</source>
          <target state="translated">TxOptions持有交易选项。</target>
        </trans-unit>
        <trans-unit id="68e7b01d33d203d9281e2f2dd8f3398104376276" translate="yes" xml:space="preserve">
          <source>Typ contains the predeclared *Basic types indexed by their corresponding BasicKind.</source>
          <target state="translated">Typ包含由其对应的BasicKind索引的预先声明的*Basic类型。</target>
        </trans-unit>
        <trans-unit id="64f24b17ea9baa36a77dc3d1afdc32b1a420fb9e" translate="yes" xml:space="preserve">
          <source>Type flags for Header.Typeflag.</source>
          <target state="translated">Header.Typeflag的类型标志。</target>
        </trans-unit>
        <trans-unit id="04ccb52737e3e40430c97b234b8f24e390173f8b" translate="yes" xml:space="preserve">
          <source>Type inference computes the type (Type) of every expression (ast.Expr) and checks for compliance with the language specification. Use Info.Types[expr].Type for the results of type inference.</source>
          <target state="translated">类型推理计算每个表达式(ast.Expr)的类型(Type),并检查是否符合语言规范。使用Info.Types[expr].Type来获取类型推理的结果。</target>
        </trans-unit>
        <trans-unit id="8035b14525c84dd4e5349419c0ff657e153c1c32" translate="yes" xml:space="preserve">
          <source>Type is found in Header.Type.</source>
          <target state="translated">Type在Header.Type中找到。</target>
        </trans-unit>
        <trans-unit id="ec7bc4958b2c43e87f98f2ef7e1adb5d065d5c5e" translate="yes" xml:space="preserve">
          <source>Type is here for the purposes of documentation only. It is a stand-in for any Go type, but represents the same type for any given function invocation.</source>
          <target state="translated">类型在这里只是为了文档的目的。它是任何Go类型的替身,但对于任何给定的函数调用来说,它代表的是相同的类型。</target>
        </trans-unit>
        <trans-unit id="233ac19906546712346f536e7ee3880b82162310" translate="yes" xml:space="preserve">
          <source>Type is the documentation for a type declaration.</source>
          <target state="translated">类型是类型声明的文档。</target>
        </trans-unit>
        <trans-unit id="d3c0b263d515209e36ac606a05719bce899addba" translate="yes" xml:space="preserve">
          <source>Type is the representation of a Go type.</source>
          <target state="translated">类型是围棋类型的表示。</target>
        </trans-unit>
        <trans-unit id="c3bca7d619ddc3b0ec61fb8f295216cb63f22eb4" translate="yes" xml:space="preserve">
          <source>Type reads the type at off in the DWARF &amp;ldquo;info&amp;rdquo; section.</source>
          <target state="translated">Type在DWARF&amp;ldquo;信息&amp;rdquo;部分中关闭时读取类型。</target>
        </trans-unit>
        <trans-unit id="1fce0b09390d2c3838db788c0cf76f63a5bf80a9" translate="yes" xml:space="preserve">
          <source>Type represents the JavaScript type of a Value.</source>
          <target state="translated">Type表示Value的JavaScript类型。</target>
        </trans-unit>
        <trans-unit id="e06c5701673348f2eed499aa753a2ba395d1a12d" translate="yes" xml:space="preserve">
          <source>Type returns itself and provides an easy default implementation for embedding in a Node. Embedded in all non-trivial Nodes.</source>
          <target state="translated">类型返回自身,并为嵌入Node提供了一个简单的默认实现。嵌入到所有非平凡的Node中。</target>
        </trans-unit>
        <trans-unit id="4726645469f41dd7bcb1d47132c78e582530c7e1" translate="yes" xml:space="preserve">
          <source>Type returns the JavaScript type of the value v. It is similar to JavaScript's typeof operator, except that it returns TypeNull instead of TypeObject for null.</source>
          <target state="translated">Type返回值v的JavaScript类型,它类似于JavaScript的typeof操作符,除了它返回TypeNull而不是TypeObject的null。</target>
        </trans-unit>
        <trans-unit id="2fa9db8cb436bbb192eec5d03d6240277e6eeffd" translate="yes" xml:space="preserve">
          <source>Type returns the object's type.</source>
          <target state="translated">Type 返回对象的类型。</target>
        </trans-unit>
        <trans-unit id="d1407fc8c8322906d1372dd8a45dc51e6205559f" translate="yes" xml:space="preserve">
          <source>Type returns the type of x.f, which may be different from the type of f. See Selection for more information.</source>
          <target state="translated">Type 返回 x.f 的类型,它可能与 f 的类型不同。更多信息请参见 Selection。</target>
        </trans-unit>
        <trans-unit id="372fc3db84eb7f93272dcba175262aaab1565f30" translate="yes" xml:space="preserve">
          <source>Type returns v's type.</source>
          <target state="translated">Type返回v的类型。</target>
        </trans-unit>
        <trans-unit id="55dbc1b43ee6cb3b1548172b193bc2a7d3e5eca5" translate="yes" xml:space="preserve">
          <source>Type values are comparable, such as with the == operator, so they can be used as map keys. Two Type values are equal if they represent identical types.</source>
          <target state="translated">类型值是可以比较的,比如用==运算符,所以它们可以作为映射键使用。如果两个类型值代表相同的类型,则它们是相等的。</target>
        </trans-unit>
        <trans-unit id="7bdac7349f75285c99f4a03ea2e2de6365f45c2a" translate="yes" xml:space="preserve">
          <source>Type-checking consists of several interdependent phases:</source>
          <target state="translated">类型检查包括几个相互依赖的阶段。</target>
        </trans-unit>
        <trans-unit id="26984be5e6e3b06475f717ab4d76ce6f4ff88c54" translate="yes" xml:space="preserve">
          <source>Type1 is here for the purposes of documentation only. It is a stand-in for any Go type, but represents the same type for any given function invocation.</source>
          <target state="translated">Type1在这里只是为了文档的目的。它是任何围棋类型的替身,但对于任何给定的函数调用来说,它代表的是同一类型。</target>
        </trans-unit>
        <trans-unit id="7ace60c9c3dbd05ce39ba29e759c6ad4a52088eb" translate="yes" xml:space="preserve">
          <source>TypeAndValue reports the type and value (for constants) of the corresponding expression.</source>
          <target state="translated">TypeAndValue报告相应表达式的类型和值(对于常量)。</target>
        </trans-unit>
        <trans-unit id="2bc75a2b4beae4c84f906bb525769e97f38f0823" translate="yes" xml:space="preserve">
          <source>TypeByExtension returns the MIME type associated with the file extension ext. The extension ext should begin with a leading dot, as in &quot;.html&quot;. When ext has no associated type, TypeByExtension returns &quot;&quot;.</source>
          <target state="translated">TypeByExtension 返回与文件扩展名 ext 相关联的 MIME 类型。扩展名 ext 应该以前导点开始,如&quot;.html&quot;。当ext没有关联类型时,TypeByExtension返回&quot;&quot;。</target>
        </trans-unit>
        <trans-unit id="263318bcaf840ab395175e373b1ab05080a86fda" translate="yes" xml:space="preserve">
          <source>TypeOf</source>
          <target state="translated">TypeOf</target>
        </trans-unit>
        <trans-unit id="94969a4aec167529cd20467de358b3733a4d1890" translate="yes" xml:space="preserve">
          <source>TypeOf returns the reflection Type that represents the dynamic type of i. If i is a nil interface value, TypeOf returns nil.</source>
          <target state="translated">TypeOf返回代表i的动态类型的反射类型,如果i是一个nil接口值,TypeOf返回nil。</target>
        </trans-unit>
        <trans-unit id="610b14205855f95702d99da6e19e5297b1301163" translate="yes" xml:space="preserve">
          <source>TypeOf returns the type of expression e, or nil if not found. Precondition: the Types, Uses and Defs maps are populated.</source>
          <target state="translated">TypeOf返回表达式e的类型,如果没有找到,则返回nil。前提条件:Types、Uses和Defs映射被填充。</target>
        </trans-unit>
        <trans-unit id="af91dac9977c975dbcb45d1e0c495727ba389f89" translate="yes" xml:space="preserve">
          <source>TypeString returns the string representation of typ. The Qualifier controls the printing of package-level objects, and may be nil.</source>
          <target state="translated">TypeString 返回 typ.Type 的字符串表示。该限定符控制包级对象的打印,可以是零。</target>
        </trans-unit>
        <trans-unit id="70c0f61c1717bc58a510efe98bd7a3251bcbbcc7" translate="yes" xml:space="preserve">
          <source>Typed Strings</source>
          <target state="translated">字符串</target>
        </trans-unit>
        <trans-unit id="802976d08e8f16b7d83d8d12b5129fe9e25c37e3" translate="yes" xml:space="preserve">
          <source>Types HTML, JS, URL, and others from content.go can carry safe content that is exempted from escaping.</source>
          <target state="translated">内容.go中的HTML、JS、URL等类型可以携带免于逃逸的安全内容。</target>
        </trans-unit>
        <trans-unit id="cea554202fc0c5ff6482d3e61417b6640fc17af4" translate="yes" xml:space="preserve">
          <source>Types and Values</source>
          <target state="translated">类型和数值</target>
        </trans-unit>
        <trans-unit id="4a237767760223207248b2b72e8a0eb1c03dbe30" translate="yes" xml:space="preserve">
          <source>Types implementing Valuer interface are able to convert themselves to a driver Value.</source>
          <target state="translated">实现Valuer接口的类型能够将自己转换为驱动Value。</target>
        </trans-unit>
        <trans-unit id="738f4e11bb80f11f67d45a4481cf366179186823" translate="yes" xml:space="preserve">
          <source>Types of signals</source>
          <target state="translated">信号类型</target>
        </trans-unit>
        <trans-unit id="b842957498ea8405dcbf49648de63b65b478d2cb" translate="yes" xml:space="preserve">
          <source>UDPAddr represents the address of a UDP end point.</source>
          <target state="translated">UDPAddr代表UDP端点的地址。</target>
        </trans-unit>
        <trans-unit id="b3b4fc6834e1c9d716c787f9ac0d161736c5f604" translate="yes" xml:space="preserve">
          <source>UDPConn is the implementation of the Conn and PacketConn interfaces for UDP network connections.</source>
          <target state="translated">UDPConn是Conn和PacketConn接口在UDP网络连接中的实现。</target>
        </trans-unit>
        <trans-unit id="b499255e82796e4d28d962954395ad3d893bac9c" translate="yes" xml:space="preserve">
          <source>UDPConn.WriteTo</source>
          <target state="translated">UDPConn.WriteTo</target>
        </trans-unit>
        <trans-unit id="0e2d9b0777a485c1276de0803c12a7d76fbc5c39" translate="yes" xml:space="preserve">
          <source>URL</source>
          <target state="translated">URL</target>
        </trans-unit>
        <trans-unit id="2113a36dc330dedde4db70e90a71dcb67bd4a9a2" translate="yes" xml:space="preserve">
          <source>URL (Roundtrip)</source>
          <target state="translated">URL(往返)</target>
        </trans-unit>
        <trans-unit id="a727ea70072d81d7b63c816962c8a756b508329a" translate="yes" xml:space="preserve">
          <source>URL encapsulates a known safe URL or URL substring (see RFC 3986). A URL like `javascript:checkThatFormNotEditedBeforeLeavingPage()` from a trusted source should go in the page, but by default dynamic `javascript:` URLs are filtered out since they are a frequently exploited injection vector.</source>
          <target state="translated">URL封装一个已知的安全URL或URL子串(见RFC 3986)。像 &quot;javascript:checkThatFormNotEditedBeforeLeavingPage()&quot;这样来自受信任来源的URL应该放在页面中,但默认情况下动态的 &quot;javascript:&quot;URL会被过滤掉,因为它们是一个经常被利用的注入向量。</target>
        </trans-unit>
        <trans-unit id="9f6702283d55dba63f2c15c6981885271e829853" translate="yes" xml:space="preserve">
          <source>URL's String method uses the EscapedPath method to obtain the path. See the EscapedPath method for more details.</source>
          <target state="translated">URL的String方法使用EscapedPath方法来获取路径。更多细节请参见EscapedPath方法。</target>
        </trans-unit>
        <trans-unit id="a7ffebe53d073d64da891027cdca3ef31de6ee7a" translate="yes" xml:space="preserve">
          <source>URL.EscapedFragment</source>
          <target state="translated">URL.EscapedFragment</target>
        </trans-unit>
        <trans-unit id="fb15045a2812519f4e1083e5cb90b2d16bf5e0e2" translate="yes" xml:space="preserve">
          <source>URL.EscapedPath</source>
          <target state="translated">URL.EscapedPath</target>
        </trans-unit>
        <trans-unit id="4966fe66780da2ec3d10c8599e72fff7ab08a49a" translate="yes" xml:space="preserve">
          <source>URL.Hostname</source>
          <target state="translated">URL.Hostname</target>
        </trans-unit>
        <trans-unit id="93c3fa248c55505922464e5ed8d1899f54880821" translate="yes" xml:space="preserve">
          <source>URL.IsAbs</source>
          <target state="translated">URL.IsAbs</target>
        </trans-unit>
        <trans-unit id="c5ff099f399baf8e187d09b758e991f007d9fdbb" translate="yes" xml:space="preserve">
          <source>URL.MarshalBinary</source>
          <target state="translated">URL.MarshalBinary</target>
        </trans-unit>
        <trans-unit id="1f5b4a1bd876c3d2e848fa8ad0b5bcdecf59f3eb" translate="yes" xml:space="preserve">
          <source>URL.Parse</source>
          <target state="translated">URL.Parse</target>
        </trans-unit>
        <trans-unit id="df308e5c8e7a40f3e06e1c8f29546df6edd0815c" translate="yes" xml:space="preserve">
          <source>URL.Port</source>
          <target state="translated">URL.Port</target>
        </trans-unit>
        <trans-unit id="1f4af3bd8a928ef1166e58b54f440e84607bbe48" translate="yes" xml:space="preserve">
          <source>URL.Query</source>
          <target state="translated">URL.Query</target>
        </trans-unit>
        <trans-unit id="f2cbc812759bc0bcb35214d0c86a7a333cdc5ac4" translate="yes" xml:space="preserve">
          <source>URL.Redacted</source>
          <target state="translated">URL.Redacted</target>
        </trans-unit>
        <trans-unit id="2f6fe106a87daa55540bf1b3e2faa597e4637d72" translate="yes" xml:space="preserve">
          <source>URL.RequestURI</source>
          <target state="translated">URL.RequestURI</target>
        </trans-unit>
        <trans-unit id="5ef9cfae68b8e79167af493274ea7b99357dad6d" translate="yes" xml:space="preserve">
          <source>URL.ResolveReference</source>
          <target state="translated">URL.ResolveReference</target>
        </trans-unit>
        <trans-unit id="aae15178969446ff357ff699287cc769e108c1ee" translate="yes" xml:space="preserve">
          <source>URL.String</source>
          <target state="translated">URL.String</target>
        </trans-unit>
        <trans-unit id="ce84e8c5399c507871045bd05a22f805d2c4f2bd" translate="yes" xml:space="preserve">
          <source>URL.UnmarshalBinary</source>
          <target state="translated">URL.UnmarshalBinary</target>
        </trans-unit>
        <trans-unit id="ac64d1ff5ad8c8e979a983967383931627c1db93" translate="yes" xml:space="preserve">
          <source>URLEncoding is the alternate base64 encoding defined in RFC 4648. It is typically used in URLs and file names.</source>
          <target state="translated">URLEncoding是RFC 4648中定义的备用base64编码。它通常用于URL和文件名中。</target>
        </trans-unit>
        <trans-unit id="c9df7bde57a8aa1d95e4f472d843c333da35563f" translate="yes" xml:space="preserve">
          <source>URLQueryEscaper returns the escaped value of the textual representation of its arguments in a form suitable for embedding in a URL query.</source>
          <target state="translated">URLQueryEscaper以适合嵌入到URL查询中的形式返回其参数的文本表示的转义值。</target>
        </trans-unit>
        <trans-unit id="f75c8002cbe8f09b52b12100920f39a5c64e72ab" translate="yes" xml:space="preserve">
          <source>URLs in the comment text are converted into links; if the URL also appears in the words map, the link is taken from the map (if the corresponding map value is the empty string, the URL is not converted into a link).</source>
          <target state="translated">注释文本中的URL会被转换为链接;如果URL也出现在词条地图中,则链接取自地图(如果对应的地图值为空字符串,则URL不会被转换为链接)。</target>
        </trans-unit>
        <trans-unit id="66e91d3bfc1c62180f622950dd4b88caee7fb5f3" translate="yes" xml:space="preserve">
          <source>URLs that do not start with a slash after the scheme are interpreted as:</source>
          <target state="translated">方案后不以斜杠开头的URL会被解释为。</target>
        </trans-unit>
        <trans-unit id="0809917b6f7b4556e78a9d2c239213f16de1592f" translate="yes" xml:space="preserve">
          <source>UTC represents Universal Coordinated Time (UTC).</source>
          <target state="translated">UTC代表世界协调时间(UTC)。</target>
        </trans-unit>
        <trans-unit id="2910e9336b266393bd7b3bb04c8ff09ab1ad423c" translate="yes" xml:space="preserve">
          <source>UTC returns t with the location set to UTC.</source>
          <target state="translated">UTC返回t,并将位置设置为UTC。</target>
        </trans-unit>
        <trans-unit id="bd4707cd474a6d0f83da094caeed9e471bb79e5c" translate="yes" xml:space="preserve">
          <source>Uint defines a uint flag with specified name, default value, and usage string. The return value is the address of a uint variable that stores the value of the flag.</source>
          <target state="translated">Uint定义了一个uint标志,具有指定的名称、默认值和使用字符串。返回值是一个存储标志值的uint变量的地址。</target>
        </trans-unit>
        <trans-unit id="c10a1c74871016b345bc36d5bdb30897f19968dc" translate="yes" xml:space="preserve">
          <source>Uint returns v's underlying value, as a uint64. It panics if v's Kind is not Uint, Uintptr, Uint8, Uint16, Uint32, or Uint64.</source>
          <target state="translated">Uint 返回 v 的底层值,是一个 uint64。如果v的Kind不是Uint、Uintptr、Uint8、Uint16、Uint32或Uint64,它就会恐慌。</target>
        </trans-unit>
        <trans-unit id="8c727e75a1c262fee3ed280d320bad7f8659ca56" translate="yes" xml:space="preserve">
          <source>Uint32 returns a pseudo-random 32-bit value as a uint32 from the default Source.</source>
          <target state="translated">Uint32从默认的Source返回一个伪随机的32位值作为uint32。</target>
        </trans-unit>
        <trans-unit id="e19c9ecfe9082dbf421a298c1c766023a8f7f823" translate="yes" xml:space="preserve">
          <source>Uint32 returns a pseudo-random 32-bit value as a uint32.</source>
          <target state="translated">Uint32以uint32的形式返回一个伪随机的32位值。</target>
        </trans-unit>
        <trans-unit id="030a2cb864d68ff2aba5fa883929c569cc36b65c" translate="yes" xml:space="preserve">
          <source>Uint64 defines a uint64 flag with specified name, default value, and usage string. The return value is the address of a uint64 variable that stores the value of the flag.</source>
          <target state="translated">Uint64定义了一个uint64标志,具有指定的名称、默认值和使用字符串。返回值是一个存储标志值的uint64变量的地址。</target>
        </trans-unit>
        <trans-unit id="6d3dffebe2bfc2c33c20643972b94062f6925708" translate="yes" xml:space="preserve">
          <source>Uint64 returns a pseudo-random 64-bit value as a uint64 from the default Source.</source>
          <target state="translated">Uint64从默认的Source返回一个伪随机的64位值作为uint64。</target>
        </trans-unit>
        <trans-unit id="4324e0d2d9e747146788fb1da362fb5053ac15fe" translate="yes" xml:space="preserve">
          <source>Uint64 returns a pseudo-random 64-bit value as a uint64.</source>
          <target state="translated">Uint64返回一个伪随机64位的uint64值。</target>
        </trans-unit>
        <trans-unit id="8f4f108ba23391540c5f57a2d283a1654c92a932" translate="yes" xml:space="preserve">
          <source>Uint64 returns a value drawn from the Zipf distribution described by the Zipf object.</source>
          <target state="translated">Uint64返回一个从Zipf对象描述的Zipf分布中提取的值。</target>
        </trans-unit>
        <trans-unit id="0e960db65d7bc2609ac63eaaddb18d0ce30fd34e" translate="yes" xml:space="preserve">
          <source>Uint64 returns the uint64 representation of x. If x cannot be represented in a uint64, the result is undefined.</source>
          <target state="translated">Uint64返回x的uint64表示,如果x不能用uint64表示,则结果为未定义。</target>
        </trans-unit>
        <trans-unit id="4059a3fbb04daacbe98a3ac34acbb5b4f0511d79" translate="yes" xml:space="preserve">
          <source>Uint64 returns the unsigned integer resulting from truncating x towards zero. If 0 &amp;lt;= x &amp;lt;= math.MaxUint64, the result is Exact if x is an integer and Below otherwise. The result is (0, Above) for x &amp;lt; 0, and (math.MaxUint64, Below) for x &amp;gt; math.MaxUint64.</source>
          <target state="translated">Uint64返回将x截断为零而得到的无符号整数。如果0 &amp;lt;= x &amp;lt;= math.MaxUint64，则如果x为整数，则结果为Exact，否则为Under。对于x &amp;lt;0，结果为（0，高于），对于x&amp;gt; math.MaxUint64，结果为（math.MaxUint64，低于）。</target>
        </trans-unit>
        <trans-unit id="eee8610c675fa51e59aceef9ba15ad48fc3f7656" translate="yes" xml:space="preserve">
          <source>Uint64Val returns the Go uint64 value of x and whether the result is exact; x must be an Int or an Unknown. If the result is not exact, its value is undefined. If x is Unknown, the result is (0, false).</source>
          <target state="translated">Uint64Val 返回 x 的 Go uint64 值以及结果是否精确;x 必须是 Int 或 Unknown。如果结果不精确,它的值是未定义的。如果x是未知值,结果是(0,false)。</target>
        </trans-unit>
        <trans-unit id="f8a9446572ec072b0dca42654febb328f4183bda" translate="yes" xml:space="preserve">
          <source>Uint64Var defines a uint64 flag with specified name, default value, and usage string. The argument p points to a uint64 variable in which to store the value of the flag.</source>
          <target state="translated">Uint64Var定义了一个uint64标志,它具有指定的名称、默认值和使用字符串,参数p指向一个uint64变量,用来存储标志的值。参数p指向一个uint64变量,用来存储标志的值。</target>
        </trans-unit>
        <trans-unit id="496dd0effb0126ef9e845598a59198590bcd043e" translate="yes" xml:space="preserve">
          <source>UintSize is the size of a uint in bits.</source>
          <target state="translated">UintSize是uint的大小,单位是比特。</target>
        </trans-unit>
        <trans-unit id="dbe3f8f6ae38a6c86be38b30cc7b136b0e0c8b33" translate="yes" xml:space="preserve">
          <source>UintVar defines a uint flag with specified name, default value, and usage string. The argument p points to a uint variable in which to store the value of the flag.</source>
          <target state="translated">UintVar定义了一个uint标志,它具有指定的名称、默认值和用法字符串,参数p指向一个uint变量,用来存储标志的值。参数p指向一个uint变量,用来存储标志的值。</target>
        </trans-unit>
        <trans-unit id="70e0b7ef4850aca01e0f7f10e5400e6c9147df8c" translate="yes" xml:space="preserve">
          <source>UnaryOp</source>
          <target state="translated">UnaryOp</target>
        </trans-unit>
        <trans-unit id="07e07a445fa30cc6121d05f031b487faccb7d573" translate="yes" xml:space="preserve">
          <source>UnaryOp returns the result of the unary expression op y. The operation must be defined for the operand. If prec &amp;gt; 0 it specifies the ^ (xor) result size in bits. If y is Unknown, the result is Unknown.</source>
          <target state="translated">UnaryOp返回一元表达式op y的结果。必须为操作数定义操作。如果prec&amp;gt; 0，则以位为单位指定^（异或）结果大小。如果y为未知，则结果为未知。</target>
        </trans-unit>
        <trans-unit id="65ac12608f350c5da84519394457136c59d339ec" translate="yes" xml:space="preserve">
          <source>Undefined returns the JavaScript value &quot;undefined&quot;.</source>
          <target state="translated">Undefined返回JavaScript值 &quot;undefined&quot;。</target>
        </trans-unit>
        <trans-unit id="9933a40ae911d6dfb846e287c51e34fc4040de25" translate="yes" xml:space="preserve">
          <source>UnescapeString</source>
          <target state="translated">UnescapeString</target>
        </trans-unit>
        <trans-unit id="d8d400b63495a426dfadc8a4f1e5fdcfa4a8e536" translate="yes" xml:space="preserve">
          <source>UnescapeString unescapes entities like &quot;&amp;amp;lt;&quot; to become &quot;&amp;lt;&quot;. It unescapes a larger range of entities than EscapeString escapes. For example, &quot;&amp;amp;aacute;&quot; unescapes to &quot;&amp;aacute;&quot;, as does &quot;&amp;amp;#225;&quot; and &quot;&amp;amp;#xE1;&quot;. UnescapeString(EscapeString(s)) == s always holds, but the converse isn't always true.</source>
          <target state="translated">UnescapeString取消转义&amp;ldquo;＆lt;&amp;rdquo;之类的实体 成为&amp;ldquo; &amp;lt;&amp;rdquo;。与EscapeString转义相比，它转义更大范围的实体。例如，&amp;ldquo;＆aacute;&amp;rdquo; 和&amp;ldquo;＆＃225;&amp;rdquo;一样，转义为&amp;ldquo;&amp;aacute;&amp;rdquo; 和&amp;ldquo;＆＃xE1;&amp;rdquo;。UnescapeString（EscapeString（s））== s总是成立，但是相反的情况并非总是如此。</target>
        </trans-unit>
        <trans-unit id="c698e3c309a2ed8c52f6f41c34c41e2935c68bed" translate="yes" xml:space="preserve">
          <source>Uniform is an infinite-sized Image of uniform color. It implements the color.Color, color.Model, and Image interfaces.</source>
          <target state="translated">Uniform是一个统一颜色的无限大小的Image。它实现了color.Color、color.Model和Image接口。</target>
        </trans-unit>
        <trans-unit id="c9b92cda61a2bd5ee7e67c31c67ae298972c3694" translate="yes" xml:space="preserve">
          <source>Union returns the smallest rectangle that contains both r and s.</source>
          <target state="translated">Union返回包含r和s的最小矩形。</target>
        </trans-unit>
        <trans-unit id="c30c209545f6cf55ee27d591debf698152bcbfd9" translate="yes" xml:space="preserve">
          <source>Unix returns t as a Unix time, the number of seconds elapsed since January 1, 1970 UTC. The result does not depend on the location associated with t.</source>
          <target state="translated">Unix以Unix时间的形式返回t,即自1970年1月1日UTC以来经过的秒数。结果不取决于与t相关联的位置。</target>
        </trans-unit>
        <trans-unit id="0739141adf792995ead54a41a03b2314aaccc261" translate="yes" xml:space="preserve">
          <source>Unix returns t as a Unix time, the number of seconds elapsed since January 1, 1970 UTC. The result does not depend on the location associated with t. Unix-like operating systems often record time as a 32-bit count of seconds, but since the method here returns a 64-bit value it is valid for billions of years into the past or future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c849502e5926e7f6de51dcd5dae32180a6c8fc5" translate="yes" xml:space="preserve">
          <source>Unix returns the local Time corresponding to the given Unix time, sec seconds and nsec nanoseconds since January 1, 1970 UTC. It is valid to pass nsec outside the range [0, 999999999]. Not all sec values have a corresponding time value. One such value is 1&amp;lt;&amp;lt;63-1 (the largest int64 value).</source>
          <target state="translated">从1970年1月1日UTC开始，Unix返回与给定的Unix时间，秒秒和nsec纳秒相对应的本地时间。通过nsec超出[0，999999999]范围是有效的。并非所有秒值都有相应的时间值。这样的值之一就是1 &amp;lt;&amp;lt; 63-1（最大的int64值）。</target>
        </trans-unit>
        <trans-unit id="7f49edfe928a8998235ec038d3202681fe6091b3" translate="yes" xml:space="preserve">
          <source>Unix returns ts as the number of seconds and nanoseconds elapsed since the Unix epoch.</source>
          <target state="translated">Unix 将 ts 作为 Unix 纪元以来的秒数和纳秒数返回。</target>
        </trans-unit>
        <trans-unit id="36e051fac71bd9f38c8bee21a4fbf639eb952b84" translate="yes" xml:space="preserve">
          <source>Unix returns tv as the number of seconds and nanoseconds elapsed since the Unix epoch.</source>
          <target state="translated">Unix 将 tv 作为 Unix 纪元以来的秒数和纳秒数返回。</target>
        </trans-unit>
        <trans-unit id="4d2a03437e4146025835f0a7a6ccd0e75af8c754" translate="yes" xml:space="preserve">
          <source>UnixAddr represents the address of a Unix domain socket end point.</source>
          <target state="translated">UnixAddr表示Unix域套接字端点的地址。</target>
        </trans-unit>
        <trans-unit id="04cdae900c7738c2f31e4e0db5e46a21f1971317" translate="yes" xml:space="preserve">
          <source>UnixConn is an implementation of the Conn interface for connections to Unix domain sockets.</source>
          <target state="translated">UnixConn是Conn接口的一个实现,用于连接到Unix域套接字。</target>
        </trans-unit>
        <trans-unit id="fd1ae11b5100fed8de8a53db38bf7aed0bddf628" translate="yes" xml:space="preserve">
          <source>UnixCredentials encodes credentials into a socket control message for sending to another process. This can be used for authentication.</source>
          <target state="translated">UnixCredentials 将凭证编码到套接字控制消息中,以便发送至另一个进程。这可以用于验证。</target>
        </trans-unit>
        <trans-unit id="aea7fd85f724d84dccda1e26d2c29b04dd2edf2d" translate="yes" xml:space="preserve">
          <source>UnixListener is a Unix domain socket listener. Clients should typically use variables of type Listener instead of assuming Unix domain sockets.</source>
          <target state="translated">UnixListener是一个Unix域套接字监听器。客户端通常应该使用Listener类型的变量,而不是假设Unix域套接字。</target>
        </trans-unit>
        <trans-unit id="2a27b45fc326b4542c26186dc68da8cc5a7e5d10" translate="yes" xml:space="preserve">
          <source>UnixNano returns t as a Unix time, the number of nanoseconds elapsed since January 1, 1970 UTC. The result is undefined if the Unix time in nanoseconds cannot be represented by an int64 (a date before the year 1678 or after 2262). Note that this means the result of calling UnixNano on the zero Time is undefined. The result does not depend on the location associated with t.</source>
          <target state="translated">UnixNano 返回 t 作为 Unix 时间,即 1970 年 1 月 1 日 UTC 以来的纳秒数。如果以纳秒为单位的Unix时间不能用int64表示(1678年之前的日期或2262年之后的日期),那么结果是未定义的。注意,这意味着在零时间上调用UnixNano的结果是未定义的。结果不取决于与t相关联的位置。</target>
        </trans-unit>
        <trans-unit id="b17a6e6eff6f04c581ee8cd1e56b3e493458a9f8" translate="yes" xml:space="preserve">
          <source>UnixRights encodes a set of open file descriptors into a socket control message for sending to another process.</source>
          <target state="translated">UnixRights 将一组打开的文件描述符编码成套接字控制消息,以便发送给另一个进程。</target>
        </trans-unit>
        <trans-unit id="dbe53cfcde936dfcaf7c8175938f51e315034103" translate="yes" xml:space="preserve">
          <source>UnknownAuthorityError results when the certificate issuer is unknown</source>
          <target state="translated">未知授权错误(UnknownAuthorityError)在证书颁发者未知时产生。</target>
        </trans-unit>
        <trans-unit id="81414e166f7a74fc8a4df3127afc6add584dadf1" translate="yes" xml:space="preserve">
          <source>UnknownFileError represents a failure to find the specific file in the symbol table.</source>
          <target state="translated">UnknownFileError表示在符号表中找不到特定的文件。</target>
        </trans-unit>
        <trans-unit id="71d6e61364d65cc6b10f85900b022e3a712387e7" translate="yes" xml:space="preserve">
          <source>UnknownGroupError is returned by LookupGroup when a group cannot be found.</source>
          <target state="translated">当找不到组时,LookupGroup会返回UnknownGroupError。</target>
        </trans-unit>
        <trans-unit id="8395a289704405eac7a12dd0a91f81ec7b638b6b" translate="yes" xml:space="preserve">
          <source>UnknownGroupIdError is returned by LookupGroupId when a group cannot be found.</source>
          <target state="translated">当找不到组时,LookupGroupId会返回UnknownGroupIdError。</target>
        </trans-unit>
        <trans-unit id="ea06d94bc0ee6404fba69dbd6d9433ca16ab32bf" translate="yes" xml:space="preserve">
          <source>UnknownLineError represents a failure to map a line to a program counter, either because the line is beyond the bounds of the file or because there is no code on the given line.</source>
          <target state="translated">UnknownLineError表示未能将某行映射到程序计数器,原因是该行超出了文件的边界,或者是给定的行上没有代码。</target>
        </trans-unit>
        <trans-unit id="161a93107711086546bec71b893d5cad7e7be15e" translate="yes" xml:space="preserve">
          <source>UnknownUserError is returned by Lookup when a user cannot be found.</source>
          <target state="translated">当找不到用户时,未知用户错误(UnknownUserError)被Lookup返回。</target>
        </trans-unit>
        <trans-unit id="6017e893f322aa54de196845bc71d4f23b1edfcb" translate="yes" xml:space="preserve">
          <source>UnknownUserIdError is returned by LookupId when a user cannot be found.</source>
          <target state="translated">当找不到用户时,LookupId会返回UnknownUserIdError。</target>
        </trans-unit>
        <trans-unit id="47025f2669ef0e585c9e4472fd182fc3f82a586e" translate="yes" xml:space="preserve">
          <source>Unless an explicit codec is set up, package encoding/gob is used to transport the data.</source>
          <target state="translated">除非设置了明确的编解码器,否则会使用包编码/gob来传输数据。</target>
        </trans-unit>
        <trans-unit id="e7e8c7e799f9b4c265f8eb16ca2467638931db85" translate="yes" xml:space="preserve">
          <source>Unless otherwise noted, these are defined in RFC 7231 section 4.3.</source>
          <target state="translated">除非另有说明,否则这些都是在RFC 7231的4.3节中定义的。</target>
        </trans-unit>
        <trans-unit id="ad0d769d8f434903817312e6a1ab62dd81dfa28b" translate="yes" xml:space="preserve">
          <source>Unless specified otherwise, all operations (including setters) that specify a *Float variable for the result (usually via the receiver with the exception of MantExp), round the numeric result according to the precision and rounding mode of the result variable.</source>
          <target state="translated">除非另有规定,所有为结果指定*Float变量的操作(包括设置器)(通常通过接收器,MantExp除外),都会根据结果变量的精度和四舍五入模式对数值结果进行四舍五入。</target>
        </trans-unit>
        <trans-unit id="a99463bcf73aeb4ac48f9dbe6e1c4e0ad970639e" translate="yes" xml:space="preserve">
          <source>Unlike NextPart, it does not have special handling for &quot;Content-Transfer-Encoding: quoted-printable&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce1ab5c402bafab7c2f436e8311567b966b147df" translate="yes" xml:space="preserve">
          <source>Unlike in C, it is not valid to advance a pointer just beyond the end of its original allocation:</source>
          <target state="translated">与C语言不同的是,将一个指针提前到刚刚超过其原始分配的终点是无效的。</target>
        </trans-unit>
        <trans-unit id="522a3a646a834223c2e98bb2c21ff8e76c01dd11" translate="yes" xml:space="preserve">
          <source>Unlike runtime.Callers, the PC values returned should, when passed to the symbolizer function, return the file/line of the call instruction. No additional subtraction is required or appropriate.</source>
          <target state="translated">与runtime.Callers不同,返回的PC值在传递给符号化函数时,应该返回调用指令的文件/行。不需要或适当地做额外的减法。</target>
        </trans-unit>
        <trans-unit id="406ad3e57d6ca887a28b68d7deb07d96e9cd7dc1" translate="yes" xml:space="preserve">
          <source>Unlike the &quot;system&quot; library call from C and other languages, the os/exec package intentionally does not invoke the system shell and does not expand any glob patterns or handle other expansions, pipelines, or redirections typically done by shells. The package behaves more like C's &quot;exec&quot; family of functions. To expand glob patterns, either call the shell directly, taking care to escape any dangerous input, or use the path/filepath package's Glob function. To expand environment variables, use package os's ExpandEnv.</source>
          <target state="translated">与 C 和其他语言的 &quot;system &quot;库调用不同,os/exec 包故意不调用系统 shell,也不扩展任何 glob 模式或处理其他通常由 shell 完成的扩展、管道或重定向。这个包的行为更像 C 的 &quot;exec&quot; 系列函数。要扩展glob模式,可以直接调用shell,注意转义任何危险的输入,或者使用path/filepath包的Glob函数。要扩展环境变量,使用包os的ExpandEnv。</target>
        </trans-unit>
        <trans-unit id="abe91b52586dc5bbb2e6b3566c5e2c39387cbbd6" translate="yes" xml:space="preserve">
          <source>Unlink removes n % r.Len() elements from the ring r, starting at r.Next(). If n % r.Len() == 0, r remains unchanged. The result is the removed subring. r must not be empty.</source>
          <target state="translated">Unlink从r.Next()开始,从环r中删除n % r.Len()元素。如果n % r.Len()==0,则r保持不变。结果是被删除的子环,r不能为空。</target>
        </trans-unit>
        <trans-unit id="f1750196ed6e86ab6e565436971490e6b17346e5" translate="yes" xml:space="preserve">
          <source>Unlock unlocks m. It is a run-time error if m is not locked on entry to Unlock.</source>
          <target state="translated">如果m在进入Unlock时没有被锁定,则会出现运行时错误。</target>
        </trans-unit>
        <trans-unit id="1031b448939f378b7eec7282357fd0c8f02e0dd3" translate="yes" xml:space="preserve">
          <source>Unlock unlocks rw for writing. It is a run-time error if rw is not locked for writing on entry to Unlock.</source>
          <target state="translated">Unlock解锁rw的写入。如果rw在进入Unlock时没有被锁定以便写入,则会出现运行时错误。</target>
        </trans-unit>
        <trans-unit id="2769f111e84de5efeaaffb059d166476e34adffc" translate="yes" xml:space="preserve">
          <source>UnlockOSThread undoes an earlier call to LockOSThread. If this drops the number of active LockOSThread calls on the calling goroutine to zero, it unwires the calling goroutine from its fixed operating system thread. If there are no active LockOSThread calls, this is a no-op.</source>
          <target state="translated">UnlockOSThread撤销了之前对LockOSThread的调用。如果这使调用的goroutine上的活动LockOSThread调用次数降为零,则将调用的goroutine从其固定的操作系统线程中解开。如果没有主动的LockOSThread调用,这就是一个无操作。</target>
        </trans-unit>
        <trans-unit id="c0c55cc87781bbcbbe014b61cd39f339918efe82" translate="yes" xml:space="preserve">
          <source>Unmarshal</source>
          <target state="translated">Unmarshal</target>
        </trans-unit>
        <trans-unit id="b902b427877022323b14bf2942e7b4318af381ef" translate="yes" xml:space="preserve">
          <source>Unmarshal converts a point, serialized by Marshal, into an x, y pair. It is an error if the point is not in uncompressed form or is not on the curve. On error, x = nil.</source>
          <target state="translated">Unmarshal 将 Marshal 序列化的点转换为一个 x,y 对。如果这个点不是以未压缩的形式存在,或者不在曲线上,那就是一个错误。错误时,x=nil。</target>
        </trans-unit>
        <trans-unit id="05d9d3d65b2b20105c2330ab2953dfbf47f42b20" translate="yes" xml:space="preserve">
          <source>Unmarshal maps an XML element or attribute value to a bool by setting it to the boolean value represented by the string. Whitespace is trimmed and ignored.</source>
          <target state="translated">Unmarshal 通过将一个 XML 元素或属性值设置为由字符串代表的布尔值,从而将其映射为一个 bool。虚位会被修剪和忽略。</target>
        </trans-unit>
        <trans-unit id="a20ffd00f170a26037fda94503e504e8f14a2140" translate="yes" xml:space="preserve">
          <source>Unmarshal maps an XML element or attribute value to a slice by extending the length of the slice and mapping the element or attribute to the newly created value.</source>
          <target state="translated">Unmarshal通过扩展分片的长度并将元素或属性映射到新创建的值,从而将XML元素或属性值映射到分片。</target>
        </trans-unit>
        <trans-unit id="f49e594c7cd50f427b1321468c3f00b6805b3bc7" translate="yes" xml:space="preserve">
          <source>Unmarshal maps an XML element or attribute value to an integer or floating-point field by setting the field to the result of interpreting the string value in decimal. There is no check for overflow. Whitespace is trimmed and ignored.</source>
          <target state="translated">Unmarshal通过将字段设置为用十进制解释字符串值的结果,将一个XML元素或属性值映射到一个整数或浮点字段。没有对溢出进行检查。虚位会被修剪和忽略。</target>
        </trans-unit>
        <trans-unit id="e3d47c5ca4b3a002e5a1a94281405e13a887e601" translate="yes" xml:space="preserve">
          <source>Unmarshal maps an XML element to a Name by recording the element name.</source>
          <target state="translated">Unmarshal通过记录元素名称将一个XML元素映射到一个Name上。</target>
        </trans-unit>
        <trans-unit id="96b027c2d930b698a1ed10b0bb721de215ae272f" translate="yes" xml:space="preserve">
          <source>Unmarshal maps an XML element to a pointer by setting the pointer to a freshly allocated value and then mapping the element to that value.</source>
          <target state="translated">Unmarshal通过将指针设置为一个新分配的值,然后将元素映射到该值上,从而将XML元素映射到一个指针上。</target>
        </trans-unit>
        <trans-unit id="6674f1401888e867e969567800411704118b6e15" translate="yes" xml:space="preserve">
          <source>Unmarshal maps an XML element to a string or []byte by saving the concatenation of that element's character data in the string or []byte. The saved []byte is never nil.</source>
          <target state="translated">Unmarshal通过在字符串或[]字节中保存该元素的字符数据的连接,将一个XML元素映射到字符串或[]字节。保存的[]字节绝不是零。</target>
        </trans-unit>
        <trans-unit id="a09403355ff68d791492810d3a6fdc52e5bc5f23" translate="yes" xml:space="preserve">
          <source>Unmarshal maps an XML element to a struct using the following rules. In the rules, the tag of a field refers to the value associated with the key 'xml' in the struct field's tag (see the example above).</source>
          <target state="translated">Unmarshal 使用以下规则将一个 XML 元素映射到一个 struct。在规则中,字段的标签指的是与结构字段标签中的键 &quot;xml &quot;相关联的值(见上面的例子)。</target>
        </trans-unit>
        <trans-unit id="252b3357e8880736b5df5514f3757c07707118ae" translate="yes" xml:space="preserve">
          <source>Unmarshal maps an attribute value to a string or []byte by saving the value in the string or slice.</source>
          <target state="translated">Unmarshal通过将值保存在字符串或分片中,将属性值映射到字符串或[]字节。</target>
        </trans-unit>
        <trans-unit id="bb18922b79397b807a3d5909559848bfe9436488" translate="yes" xml:space="preserve">
          <source>Unmarshal maps an attribute value to an Attr by saving the attribute, including its name, in the Attr.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daa56a09ffbf4f0b35b7c340fa9c8ae81aa1dac5" translate="yes" xml:space="preserve">
          <source>Unmarshal parses the DER-encoded ASN.1 data structure b and uses the reflect package to fill in an arbitrary value pointed at by val. Because Unmarshal uses the reflect package, the structs being written to must use upper case field names.</source>
          <target state="translated">Unmarshal解析了DER编码的ASN.1数据结构b,并使用reflect包填入一个由val指向的任意值。因为Unmarshal使用了reflect包,所以写入的结构必须使用大写的字段名。</target>
        </trans-unit>
        <trans-unit id="6a9e198e98aaf9144ec031242893dd0ad5675a2b" translate="yes" xml:space="preserve">
          <source>Unmarshal parses the JSON-encoded data and stores the result in the value pointed to by v. If v is nil or not a pointer, Unmarshal returns an InvalidUnmarshalError.</source>
          <target state="translated">Unmarshal解析JSON编码的数据,并将结果存储在v指向的值中,如果v为nil或不是指针,Unmarshal将返回一个InvalidUnmarshalError。</target>
        </trans-unit>
        <trans-unit id="ed1d87c314d03ac8a80eec05352fd3a2e828f6fd" translate="yes" xml:space="preserve">
          <source>Unmarshal parses the XML-encoded data and stores the result in the value pointed to by v, which must be an arbitrary struct, slice, or string. Well-formed data that does not fit into v is discarded.</source>
          <target state="translated">Unmarshal解析XML编码的数据,并将结果存储在v所指向的值中,v必须是一个任意的结构、片断或字符串。不适合v的格式良好的数据会被丢弃。</target>
        </trans-unit>
        <trans-unit id="40f5f3bf6806f78bc75f412c5c5def4697b027f5" translate="yes" xml:space="preserve">
          <source>Unmarshal uses the inverse of the encodings that Marshal uses, allocating maps, slices, and pointers as necessary, with the following additional rules:</source>
          <target state="translated">Unmarshal使用与Marshal使用的编码相反的编码,根据需要分配地图、切片和指针,附加规则如下。</target>
        </trans-unit>
        <trans-unit id="8a48a17f3248cfe923e11a8bf58b4b7fb9c77d34" translate="yes" xml:space="preserve">
          <source>UnmarshalBinary implements the encoding.BinaryUnmarshaler interface.</source>
          <target state="translated">UnmarshalBinary实现了encoding.BinaryUnmarshaler接口。</target>
        </trans-unit>
        <trans-unit id="3e8a767165b3da81fab334a0479c29a17b19b26e" translate="yes" xml:space="preserve">
          <source>UnmarshalBinary must be able to decode the form generated by MarshalBinary. UnmarshalBinary must copy the data if it wishes to retain the data after returning.</source>
          <target state="translated">UnmarshalBinary必须能够解码MarshalBinary生成的表单。如果UnmarshalBinary希望在返回后保留数据,它必须复制数据。</target>
        </trans-unit>
        <trans-unit id="c0f8f106115bed98d4438b712b344fc8e65ac7a2" translate="yes" xml:space="preserve">
          <source>UnmarshalCompressed converts a point, serialized by MarshalCompressed, into an x, y pair. It is an error if the point is not in compressed form or is not on the curve. On error, x = nil.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1f2034d1f5318f262d82d2c3d3d1a1f573ff376" translate="yes" xml:space="preserve">
          <source>UnmarshalJSON implements the json.Unmarshaler interface.</source>
          <target state="translated">UnmarshalJSON实现了json.Unmarshaler接口。</target>
        </trans-unit>
        <trans-unit id="ac481b848955fbdb07ec4ed8b1f2094acec90508" translate="yes" xml:space="preserve">
          <source>UnmarshalJSON implements the json.Unmarshaler interface. The time is expected to be a quoted string in RFC 3339 format.</source>
          <target state="translated">UnmarshalJSON实现了json.Unmarshaler接口。时间应该是RFC 3339格式的引号字符串。</target>
        </trans-unit>
        <trans-unit id="501d2e87e0671202c95a53d1a0ea534ac74ed463" translate="yes" xml:space="preserve">
          <source>UnmarshalJSON sets *m to a copy of data.</source>
          <target state="translated">UnmarshalJSON将*m设置为数据的副本。</target>
        </trans-unit>
        <trans-unit id="766c1d65184cba1147b7a3545fa3391dee2740d7" translate="yes" xml:space="preserve">
          <source>UnmarshalText implements the encoding.TextUnmarshaler interface.</source>
          <target state="translated">UnmarshalText实现了encoding.TextUnmarshaler接口。</target>
        </trans-unit>
        <trans-unit id="85ec5d5725d7fc8b15d01b424436803971c310f0" translate="yes" xml:space="preserve">
          <source>UnmarshalText implements the encoding.TextUnmarshaler interface. The IP address is expected in a form accepted by ParseIP.</source>
          <target state="translated">UnmarshalText实现了encoding.TextUnmarshaler接口。IP地址需要以ParseIP接受的形式出现。</target>
        </trans-unit>
        <trans-unit id="131593f7a0c50a040c83c26b3def1697240de177" translate="yes" xml:space="preserve">
          <source>UnmarshalText implements the encoding.TextUnmarshaler interface. The result is rounded per the precision and rounding mode of z. If z's precision is 0, it is changed to 64 before rounding takes effect.</source>
          <target state="translated">UnmarshalText实现了encoding.TextUnmarshaler接口。结果根据z的精度和四舍五入模式进行四舍五入,如果z的精度为0,则在四舍五入生效前将其改为64。</target>
        </trans-unit>
        <trans-unit id="7b15f389f52fa3ed23e4bbf98f836b42c06e5eba" translate="yes" xml:space="preserve">
          <source>UnmarshalText implements the encoding.TextUnmarshaler interface. The time is expected to be in RFC 3339 format.</source>
          <target state="translated">UnmarshalText实现了encoding.TextUnmarshaler接口。时间预计为RFC 3339格式。</target>
        </trans-unit>
        <trans-unit id="6b7f1ab4fc569112930c20562985da8185544c87" translate="yes" xml:space="preserve">
          <source>UnmarshalText must be able to decode the form generated by MarshalText. UnmarshalText must copy the text if it wishes to retain the text after returning.</source>
          <target state="translated">UnmarshalText必须能够解码MarshalText生成的表单。如果UnmarshalText希望在返回后保留文本,它必须复制文本。</target>
        </trans-unit>
        <trans-unit id="bd65d49d42bce927940aedf915c377e4dd09e40d" translate="yes" xml:space="preserve">
          <source>UnmarshalWithParams allows field parameters to be specified for the top-level element. The form of the params is the same as the field tags.</source>
          <target state="translated">UnmarshalWithParams允许为顶层元素指定字段参数。参数的形式与字段标签相同。</target>
        </trans-unit>
        <trans-unit id="b3bf6c68384d3fb37cb6c7555cff99e7fce3bb41" translate="yes" xml:space="preserve">
          <source>UnmarshalXML decodes a single XML element beginning with the given start element. If it returns an error, the outer call to Unmarshal stops and returns that error. UnmarshalXML must consume exactly one XML element. One common implementation strategy is to unmarshal into a separate value with a layout matching the expected XML using d.DecodeElement, and then to copy the data from that value into the receiver. Another common strategy is to use d.Token to process the XML object one token at a time. UnmarshalXML may not use d.RawToken.</source>
          <target state="translated">UnmarshalXML 解码一个从给定的起始元素开始的单个 XML 元素,如果它返回错误,则外部调用 Unmarshal 停止并返回该错误。如果它返回一个错误,对Unmarshal的外部调用会停止并返回该错误。UnmarshalXML必须正好消耗一个XML元素。一个常见的实现策略是使用d.DecodeElement将unmarshal转化为一个单独的值,其布局与预期的XML相匹配,然后将该值中的数据复制到接收器中。另一种常见的策略是使用d.Token一次处理一个token的XML对象。UnmarshalXML可能不会使用d.RawToken。</target>
        </trans-unit>
        <trans-unit id="acecbda4c97cb520576b3b10bc8d83fa35017c1a" translate="yes" xml:space="preserve">
          <source>UnmarshalXMLAttr decodes a single XML attribute. If it returns an error, the outer call to Unmarshal stops and returns that error. UnmarshalXMLAttr is used only for struct fields with the &quot;attr&quot; option in the field tag.</source>
          <target state="translated">UnmarshalXMLAttr解码一个XML属性。如果它返回一个错误,对Unmarshal的外部调用将停止并返回该错误。UnmarshalXMLAttr仅用于字段标签中带有 &quot;attr &quot;选项的结构体字段。</target>
        </trans-unit>
        <trans-unit id="74aa3bc85e3cd4c389b5c2ee32e0f9e728ff011a" translate="yes" xml:space="preserve">
          <source>Unmarshaler is the interface implemented by objects that can unmarshal an XML element description of themselves.</source>
          <target state="translated">Unmarshaler是由对象实现的接口,它可以对自己的XML元素描述进行解密。</target>
        </trans-unit>
        <trans-unit id="da8c67afda9119d4c5ae65e92c29582ea2cf5d56" translate="yes" xml:space="preserve">
          <source>Unmarshaler is the interface implemented by types that can unmarshal a JSON description of themselves. The input can be assumed to be a valid encoding of a JSON value. UnmarshalJSON must copy the JSON data if it wishes to retain the data after returning.</source>
          <target state="translated">Unmarshaler是由类型实现的接口,可以对自己的JSON描述进行解密。输入的内容可以假设为JSON值的有效编码。如果UnmarshalJSON希望在返回后保留数据,那么它必须复制JSON数据。</target>
        </trans-unit>
        <trans-unit id="53e6478e1491aec13688a3a1ab544532e2362899" translate="yes" xml:space="preserve">
          <source>UnmarshalerAttr is the interface implemented by objects that can unmarshal an XML attribute description of themselves.</source>
          <target state="translated">UnmarshalerAttr是由对象实现的接口,它可以对自己的XML属性描述进行解密。</target>
        </trans-unit>
        <trans-unit id="3db9a5e29909b34e2551d8477bb97dce0e5cc013" translate="yes" xml:space="preserve">
          <source>Unquote</source>
          <target state="translated">Unquote</target>
        </trans-unit>
        <trans-unit id="d3b6eaa5a8adda6c17843b82fa332f2940b5c172" translate="yes" xml:space="preserve">
          <source>Unquote and UnquoteChar unquote Go string and rune literals.</source>
          <target state="translated">Unquote和UnquoteChar unquote去串和符文字。</target>
        </trans-unit>
        <trans-unit id="eb183728a78695573a325619f75443a862dbd0b9" translate="yes" xml:space="preserve">
          <source>Unquote interprets s as a single-quoted, double-quoted, or backquoted Go string literal, returning the string value that s quotes. (If s is single-quoted, it would be a Go character literal; Unquote returns the corresponding one-character string.)</source>
          <target state="translated">Unquote 将 s 解释为单引号、双引号或反引号的 Go 字符串,返回 s 引述的字符串值。(如果 s 是单引号,它将是一个围棋字符文字;Unquote 返回相应的单字符字符串。)</target>
        </trans-unit>
        <trans-unit id="944cb633773df2e1ec790dd961a8146fba14fec2" translate="yes" xml:space="preserve">
          <source>UnquoteChar</source>
          <target state="translated">UnquoteChar</target>
        </trans-unit>
        <trans-unit id="29375f10dc5a5623870f8be238ab4c2e02bc8067" translate="yes" xml:space="preserve">
          <source>UnquoteChar decodes the first character or byte in the escaped string or character literal represented by the string s. It returns four values:</source>
          <target state="translated">UnquoteChar对字符串s所代表的转义字符串或字符文字中的第一个字符或字节进行解码,它返回四个值。</target>
        </trans-unit>
        <trans-unit id="b53dd6b78670edea47b93cdb0a942d08f61ad422" translate="yes" xml:space="preserve">
          <source>UnquoteUsage extracts a back-quoted name from the usage string for a flag and returns it and the un-quoted usage. Given &quot;a `name` to show&quot; it returns (&quot;name&quot;, &quot;a name to show&quot;). If there are no back quotes, the name is an educated guess of the type of the flag's value, or the empty string if the flag is boolean.</source>
          <target state="translated">UnquoteUsage从标志的用法字符串中提取一个反引的名称,并返回它和未引的用法。给定 &quot;一个要显示的`名字`&quot;,它就返回(&quot;name&quot;,&quot;a name to show&quot;)。如果没有反引号,这个名字是对标志值类型的有根据的猜测,如果标志是布尔值,则返回空字符串。</target>
        </trans-unit>
        <trans-unit id="31604e0bbb76d839a9e20bc3ad471c203d67835a" translate="yes" xml:space="preserve">
          <source>UnreadByte causes the next call to ReadByte to return the same byte as the previous call to ReadByte. It may be an error to call UnreadByte twice without an intervening call to ReadByte.</source>
          <target state="translated">UnreadByte会使下一次调用ReadByte时返回与上一次调用ReadByte相同的字节。在没有调用ReadByte的情况下,两次调用UnreadByte可能是错误的。</target>
        </trans-unit>
        <trans-unit id="f50817f3bd6d2c35e72fde2b0a932fd55a8206aa" translate="yes" xml:space="preserve">
          <source>UnreadByte complements ReadByte in implementing the io.ByteScanner interface.</source>
          <target state="translated">UnreadByte在实现io.ByteScanner接口时补充了ReadByte。</target>
        </trans-unit>
        <trans-unit id="77c7dde06491fe4b9339041eb3796382445874b6" translate="yes" xml:space="preserve">
          <source>UnreadByte returns an error if the most recent method called on the Reader was not a read operation. Notably, Peek is not considered a read operation.</source>
          <target state="translated">如果最近一次调用Reader的方法不是读取操作,UnreadByte会返回一个错误。值得注意的是,Peek不被认为是一个读操作。</target>
        </trans-unit>
        <trans-unit id="85bb36da753f37d1b461fc793f6153ef59c80214" translate="yes" xml:space="preserve">
          <source>UnreadByte unreads the last byte returned by the most recent successful read operation that read at least one byte. If a write has happened since the last read, if the last read returned an error, or if the read read zero bytes, UnreadByte returns an error.</source>
          <target state="translated">UnreadByte解读最近一次成功读取至少一个字节的操作所返回的最后一个字节。如果自上次读取后发生了写,如果上次读取返回了错误,或者读取了零字节,UnreadByte将返回一个错误。</target>
        </trans-unit>
        <trans-unit id="965a6610c5d757c591de2c22877d96263eb8aa9d" translate="yes" xml:space="preserve">
          <source>UnreadByte unreads the last byte. Only the most recently read byte can be unread.</source>
          <target state="translated">UnreadByte取消读取最后一个字节。只有最近读过的字节才可以未读。</target>
        </trans-unit>
        <trans-unit id="4b29ee18a300641e642a50770d2b768bae903a75" translate="yes" xml:space="preserve">
          <source>UnreadRune causes the next call to ReadRune to return the same rune as the previous call to ReadRune. It may be an error to call UnreadRune twice without an intervening call to ReadRune.</source>
          <target state="translated">UnreadRune会使下一次对ReadRune的调用返回与上一次对ReadRune的调用相同的符文。在没有中间调用ReadRune的情况下,两次调用UnreadRune可能是一个错误。</target>
        </trans-unit>
        <trans-unit id="53822d24e97f8bde421daa61dcb508cacfde9d9a" translate="yes" xml:space="preserve">
          <source>UnreadRune complements ReadRune in implementing the io.RuneScanner interface.</source>
          <target state="translated">UnreadRune补充ReadRune实现了io.RuneScanner接口。</target>
        </trans-unit>
        <trans-unit id="a4e42f86f3f39d57a5422eae590b939a777bcf43" translate="yes" xml:space="preserve">
          <source>UnreadRune unreads the last rune returned by ReadRune. If the most recent read or write operation on the buffer was not a successful ReadRune, UnreadRune returns an error. (In this regard it is stricter than UnreadByte, which will unread the last byte from any read operation.)</source>
          <target state="translated">UnreadRune解读ReadRune返回的最后一个符文。如果最近一次对缓冲区的读或写操作不是成功的ReadRune,UnreadRune会返回一个错误。(在这方面,它比UnreadByte更严格,UnreadByte将从任何读操作中解读最后一个字节)。</target>
        </trans-unit>
        <trans-unit id="19847ace49c568ee229c8734fba08cf124cc864f" translate="yes" xml:space="preserve">
          <source>UnreadRune unreads the last rune. If the most recent method called on the Reader was not a ReadRune, UnreadRune returns an error. (In this regard it is stricter than UnreadByte, which will unread the last byte from any read operation.)</source>
          <target state="translated">UnreadRune解读最后一个符文。如果最近在Reader上调用的方法不是ReadRune,UnreadRune会返回一个错误。在这方面,它比UnreadByte更严格,后者将从任何读取操作中解读最后一个字节)。</target>
        </trans-unit>
        <trans-unit id="50c3f847c58ba55e1737c9ae778e9a6278576b57" translate="yes" xml:space="preserve">
          <source>UnsafeAddr returns a pointer to v's data. It is for advanced clients that also import the &quot;unsafe&quot; package. It panics if v is not addressable.</source>
          <target state="translated">UnsafeAddr返回一个指向v数据的指针。它适用于同时导入 &quot;unsafe &quot;包的高级客户端。如果v不可寻址,它就会恐慌。</target>
        </trans-unit>
        <trans-unit id="504ce26fbf37c2ede64fba6d4661638e260a1239" translate="yes" xml:space="preserve">
          <source>Unsetenv</source>
          <target state="translated">Unsetenv</target>
        </trans-unit>
        <trans-unit id="182ea105f6e57aa2c2130dff922916a82bfc3855" translate="yes" xml:space="preserve">
          <source>Unsetenv unsets a single environment variable.</source>
          <target state="translated">Unsetenv 取消设置一个环境变量。</target>
        </trans-unit>
        <trans-unit id="5d092e34b5869cce62568374e8b69ed2285d4b5a" translate="yes" xml:space="preserve">
          <source>UnsupportedTypeError is returned when Marshal encounters a type that cannot be converted into XML.</source>
          <target state="translated">当Marshal遇到一个不能转换为XML的类型时,会返回UnsupportedTypeError。</target>
        </trans-unit>
        <trans-unit id="e92f4283009858bf9a4050cedd8fe684e6e6d055" translate="yes" xml:space="preserve">
          <source>Until returns the duration until t. It is shorthand for t.Sub(time.Now()).</source>
          <target state="translated">Until是t.Sub(time.Now())的简写。</target>
        </trans-unit>
        <trans-unit id="90df4c2aff351c99774ec32df813be4f64cfabcd" translate="yes" xml:space="preserve">
          <source>Unwrap returns the result of calling the Unwrap method on err, if err's type contains an Unwrap method returning error. Otherwise, Unwrap returns nil.</source>
          <target state="translated">如果err的类型中包含一个返回error的Unwrap方法,则Unwrap返回调用err上的Unwrap方法的结果。否则,Unwrap返回nil。</target>
        </trans-unit>
        <trans-unit id="0674f5735125e15a98a0dd1cdad0bd08b0642deb" translate="yes" xml:space="preserve">
          <source>Unwrap returns the underlying error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2facf8e427018a05d97ad6fa738413f526dc52de" translate="yes" xml:space="preserve">
          <source>Unwrap unpacks wrapped errors. If its argument's type has an Unwrap method, it calls the method once. Otherwise, it returns nil.</source>
          <target state="translated">Unwrap解开包装的错误。如果它的参数类型有一个Unwrap方法,它就调用一次该方法。否则,它返回nil。</target>
        </trans-unit>
        <trans-unit id="2a313ddb07d29b1265d5875102d8b2f23477d34a" translate="yes" xml:space="preserve">
          <source>Update replaces an old node in the comment map with the new node and returns the new node. Comments that were associated with the old node are associated with the new node.</source>
          <target state="translated">更新用新节点替换评论地图中的旧节点,并返回新节点。与旧节点相关联的评论会与新节点相关联。</target>
        </trans-unit>
        <trans-unit id="edb9e0c28d17431f4e5d015de98ef6d3ddc2e66d" translate="yes" xml:space="preserve">
          <source>Update returns the result of adding the bytes in p to the crc.</source>
          <target state="translated">更新返回将p中的字节添加到crc的结果。</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="cec856deaea9fb4090c73c99e87c26b997d6e715" translate="yes" xml:space="preserve">
          <source>Usage prints a usage message documenting all defined command-line flags to CommandLine's output, which by default is os.Stderr. It is called when an error occurs while parsing flags. The function is a variable that may be changed to point to a custom function. By default it prints a simple header and calls PrintDefaults; for details about the format of the output and how to control it, see the documentation for PrintDefaults. Custom usage functions may choose to exit the program; by default exiting happens anyway as the command line's error handling strategy is set to ExitOnError.</source>
          <target state="translated">Usage 会将所有定义的命令行标志的使用信息打印到 CommandLine 的输出中,默认为 os.Stderr。当解析标志时发生错误时,它会被调用。该函数是一个变量,可以被修改为指向一个自定义函数。默认情况下,它打印一个简单的头,并调用 PrintDefaults;关于输出的格式和如何控制它的细节,请参阅 PrintDefaults 的文档。自定义使用函数可以选择退出程序;默认情况下,退出还是会发生,因为命令行的错误处理策略被设置为ExitOnError。</target>
        </trans-unit>
        <trans-unit id="08b2986bb9311484289ed77e8cb011bc1a1a4415" translate="yes" xml:space="preserve">
          <source>Use GoTokens to configure the Scanner such that it accepts all Go literal tokens including Go identifiers. Comments will be skipped.</source>
          <target state="translated">使用 GoTokens 配置扫描仪,使其接受所有 Go 字面标记,包括 Go 标识符。注释将被跳过。</target>
        </trans-unit>
        <trans-unit id="e7059998d0ef4d38492eb586594b1a7f2fda5597" translate="yes" xml:space="preserve">
          <source>Use a Scanner to implement a simple word-count utility by scanning the input as a sequence of space-delimited tokens.</source>
          <target state="translated">使用Scanner来实现一个简单的单词计数工具,通过扫描输入作为一个空间限制的标记序列。</target>
        </trans-unit>
        <trans-unit id="c7ed138fa83b46f7078f3eba45cc612903e73703" translate="yes" xml:space="preserve">
          <source>Use a Scanner with a custom split function (built by wrapping ScanWords) to validate 32-bit decimal input.</source>
          <target state="translated">使用带有自定义分割函数(通过包装ScanWords建立)的Scanner来验证32位十进制输入。</target>
        </trans-unit>
        <trans-unit id="a131c39c2cc3965eeb7903a72d441b0e6edc8b39" translate="yes" xml:space="preserve">
          <source>Use a Scanner with a custom split function to parse a comma-separated list with an empty final value.</source>
          <target state="translated">使用带有自定义分割函数的Scanner来解析一个最终值为空的逗号分隔的列表。</target>
        </trans-unit>
        <trans-unit id="3fe5cc9def42296a11d7d9a0af9fc8ea7342706f" translate="yes" xml:space="preserve">
          <source>Use context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions.</source>
          <target state="translated">仅将上下文值用于传递进程和API的请求范围内的数据,而不是用于向函数传递可选参数。</target>
        </trans-unit>
        <trans-unit id="b7726ad2d6a51eae4064f8abdd4f91a30451b9da" translate="yes" xml:space="preserve">
          <source>Use of this type presents a security risk: the encapsulated content should come from a trusted source, as it will be included verbatim in the template output.</source>
          <target state="translated">使用这种类型会带来安全风险:封装的内容应该来自可信的来源,因为它将被逐字包含在模板输出中。</target>
        </trans-unit>
        <trans-unit id="34a9c66123dc40ac60f0472d60867161abcd1901" translate="yes" xml:space="preserve">
          <source>UseNumber causes the Decoder to unmarshal a number into an interface{} as a Number instead of as a float64.</source>
          <target state="translated">UseNumber会使解码器将一个数字作为Number而不是float64解密到接口{}中。</target>
        </trans-unit>
        <trans-unit id="b20930a62f52b49ee0781be625003d945b67da4b" translate="yes" xml:space="preserve">
          <source>User annotation</source>
          <target state="translated">用户注释</target>
        </trans-unit>
        <trans-unit id="fc3da515c7dc35d47639ea550f79310b8bc9a78e" translate="yes" xml:space="preserve">
          <source>User represents a user account.</source>
          <target state="translated">用户代表一个用户账户。</target>
        </trans-unit>
        <trans-unit id="d2b201b196f2c09ea10aa903c6f2d9d3642adbdc" translate="yes" xml:space="preserve">
          <source>User returns a Userinfo containing the provided username and no password set.</source>
          <target state="translated">User返回一个Userinfo,其中包含提供的用户名,没有设置密码。</target>
        </trans-unit>
        <trans-unit id="68b7ed6f3fe5a5fff91e1492620a3db521e39f64" translate="yes" xml:space="preserve">
          <source>UserAgent returns the client's User-Agent, if sent in the request.</source>
          <target state="translated">UserAgent返回客户端的User-Agent(如果在请求中发送)。</target>
        </trans-unit>
        <trans-unit id="4ea06ed977eda51c2aa11c6b438af4cabec784b4" translate="yes" xml:space="preserve">
          <source>UserCacheDir returns the default root directory to use for user-specific cached data. Users should create their own application-specific subdirectory within this one and use that.</source>
          <target state="translated">UserCacheDir返回默认的根目录,用于用户特定的缓存数据。用户应该在这个目录中创建自己的应用程序专用子目录,并使用它。</target>
        </trans-unit>
        <trans-unit id="a2ed520c964d93e9ec6ba0898145eda2b4839b40" translate="yes" xml:space="preserve">
          <source>UserConfigDir returns the default root directory to use for user-specific configuration data. Users should create their own application-specific subdirectory within this one and use that.</source>
          <target state="translated">UserConfigDir 返回默认的根目录,用于用户特定的配置数据。用户应该在这个目录中创建他们自己的应用程序特定的子目录并使用它。</target>
        </trans-unit>
        <trans-unit id="28c75db53e54c3bd7c5a9e9bf84aa07645cd4dd7" translate="yes" xml:space="preserve">
          <source>UserHomeDir returns the current user's home directory.</source>
          <target state="translated">UserHomeDir 返回当前用户的主目录。</target>
        </trans-unit>
        <trans-unit id="e4af3b1e17fb9be937bdb3790d770684874f4388" translate="yes" xml:space="preserve">
          <source>UserPassword returns a Userinfo containing the provided username and password.</source>
          <target state="translated">UserPassword返回一个包含所提供的用户名和密码的Userinfo。</target>
        </trans-unit>
        <trans-unit id="02f3110477b79296b9a835ccdda4c40254dba20b" translate="yes" xml:space="preserve">
          <source>UserTime returns the user CPU time of the exited process and its children.</source>
          <target state="translated">UserTime 返回退出的进程及其子进程的用户 CPU 时间。</target>
        </trans-unit>
        <trans-unit id="596b2947d671a1bd54b3952e3987a478fe9edb86" translate="yes" xml:space="preserve">
          <source>Username returns the username.</source>
          <target state="translated">Username 返回用户名。</target>
        </trans-unit>
        <trans-unit id="dc8f2880e32de7bce1932889e7d7d51c71d3c62a" translate="yes" xml:space="preserve">
          <source>Using GOOS=android matches build tags and files as for GOOS=linux in addition to android tags and files.</source>
          <target state="translated">使用GOOS=android,除了android标签和文件外,还可以匹配GOOS=linux的构建标签和文件。</target>
        </trans-unit>
        <trans-unit id="9ef58be31d291026b75b8271910eb178dd6cbe45" translate="yes" xml:space="preserve">
          <source>Using GOOS=illumos matches build tags and files as for GOOS=solaris in addition to illumos tags and files.</source>
          <target state="translated">使用 GOOS=illumos,除了 illumos 标签和文件外,还匹配了 GOOS=solaris 的构建标签和文件。</target>
        </trans-unit>
        <trans-unit id="c3fe6f0d858556f91b252b308d506eedd3cb2ddd" translate="yes" xml:space="preserve">
          <source>Using JS to include valid but untrusted JSON is not safe. A safe alternative is to parse the JSON with json.Unmarshal and then pass the resultant object into the template, where it will be converted to sanitized JSON when presented in a JavaScript context.</source>
          <target state="translated">使用JS来包含有效但不受信任的JSON是不安全的。一个安全的替代方法是用json.Unmarshal解析JSON,然后将结果对象传递到模板中,当在JavaScript上下文中呈现时,它将被转换为净化的JSON。</target>
        </trans-unit>
        <trans-unit id="9d9125a7eed89278993fd187aca47dc4a1d76ad9" translate="yes" xml:space="preserve">
          <source>Using a nil Qualifier is equivalent to using (*Package).Path: the object is qualified by the import path, e.g., &quot;encoding/json.Marshal&quot;.</source>
          <target state="translated">使用nil限定符相当于使用(*Package).Path:对象由导入路径限定,例如 &quot;encoding/json.Marshal&quot;。</target>
        </trans-unit>
        <trans-unit id="2513c3904b3d8adc521d8c82ea1568602dc6d76b" translate="yes" xml:space="preserve">
          <source>Uvarint</source>
          <target state="translated">Uvarint</target>
        </trans-unit>
        <trans-unit id="cd0cf1cee138a1f47260e7774925bd884f2375a8" translate="yes" xml:space="preserve">
          <source>Uvarint decodes a uint64 from buf and returns that value and the number of bytes read (&amp;gt; 0). If an error occurred, the value is 0 and the number of bytes n is &amp;lt;= 0 meaning:</source>
          <target state="translated">Uvarint从buf解码uint64并返回该值和读取的字节数（&amp;gt; 0）。如果发生错误，则值为0，字节数n为&amp;lt;= 0，表示：</target>
        </trans-unit>
        <trans-unit id="66771bf9a86898929e11d8280264a532271f941a" translate="yes" xml:space="preserve">
          <source>Val</source>
          <target state="translated">Val</target>
        </trans-unit>
        <trans-unit id="2bc81c70eb02eae4099191aef1e57849a8e8f03d" translate="yes" xml:space="preserve">
          <source>Val returns the constant's value.</source>
          <target state="translated">Val返回常量的值。</target>
        </trans-unit>
        <trans-unit id="b0f7ad9f186c50db1236f5511239fa9e5948970e" translate="yes" xml:space="preserve">
          <source>Val returns the underlying value for a given constant. Since it returns an interface, it is up to the caller to type assert the result to the expected type. The possible dynamic return types are:</source>
          <target state="translated">Val返回一个给定常量的基本值。由于它返回的是一个接口,所以调用者要对结果进行类型断言,使其符合预期的类型。可能的动态返回类型有</target>
        </trans-unit>
        <trans-unit id="2559cc6528d308a907426a71ef2ddf45113dcc96" translate="yes" xml:space="preserve">
          <source>Val returns the value associated with attribute Attr in Entry, or nil if there is no such attribute.</source>
          <target state="translated">Val返回与Entry中属性Attr相关联的值,如果没有这个属性,则返回nil。</target>
        </trans-unit>
        <trans-unit id="a4aefa35c3b5ad26cd56f18c500001b89f66a9ce" translate="yes" xml:space="preserve">
          <source>Valid</source>
          <target state="translated">Valid</target>
        </trans-unit>
        <trans-unit id="46c122fc5457cc399b8b858419e492a06b376755" translate="yes" xml:space="preserve">
          <source>Valid reports whether data is a valid JSON encoding.</source>
          <target state="translated">Valid报告数据是否为有效的JSON编码。</target>
        </trans-unit>
        <trans-unit id="806cc965cf7a7b71a612856c03f868243e886f5c" translate="yes" xml:space="preserve">
          <source>Valid reports whether p consists entirely of valid UTF-8-encoded runes.</source>
          <target state="translated">Valid报告p是否完全由有效的UTF-8编码的符文组成。</target>
        </trans-unit>
        <trans-unit id="2c3cda690d8c1884d7b10ef8e13e38f05dfb3167" translate="yes" xml:space="preserve">
          <source>ValidRune</source>
          <target state="translated">ValidRune</target>
        </trans-unit>
        <trans-unit id="3e8899c82439ff69d29e69515b50bcac879155d8" translate="yes" xml:space="preserve">
          <source>ValidRune reports whether r can be legally encoded as UTF-8. Code points that are out of range or a surrogate half are illegal.</source>
          <target state="translated">ValidRune报告r是否可以合法地编码为UTF-8。代码点超出范围或代用半数都是非法的。</target>
        </trans-unit>
        <trans-unit id="a9473e977cedeea3732bd1f0e634158b2fc8bc9c" translate="yes" xml:space="preserve">
          <source>ValidString</source>
          <target state="translated">ValidString</target>
        </trans-unit>
        <trans-unit id="1965e2764de3dba462118d2aa14e90df90d22255" translate="yes" xml:space="preserve">
          <source>ValidString reports whether s consists entirely of valid UTF-8-encoded runes.</source>
          <target state="translated">ValidString报告s是否完全由有效的UTF-8编码符文组成。</target>
        </trans-unit>
        <trans-unit id="c0a9babdac4db73aebddcf7c19ed25ebb45d7a5b" translate="yes" xml:space="preserve">
          <source>Validate performs basic sanity checks on the key. It returns nil if the key is valid, or else an error describing a problem.</source>
          <target state="translated">Validate对密钥进行基本的安全检查。如果密钥是有效的,则返回nil,否则返回一个描述问题的错误。</target>
        </trans-unit>
        <trans-unit id="884a21f08ecc170ab0e83923a5cddfcafa2f19e8" translate="yes" xml:space="preserve">
          <source>Validator may be implemented by Conn to allow drivers to signal if a connection is valid or if it should be discarded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dce170de238b1feda2ecd9674ea3ca0d068fbcb" translate="yes" xml:space="preserve">
          <source>Value</source>
          <target state="translated">Value</target>
        </trans-unit>
        <trans-unit id="f3016ae4e1764c831e22db266c9f3792b104f577" translate="yes" xml:space="preserve">
          <source>Value (Config)</source>
          <target state="translated">值(配置)</target>
        </trans-unit>
        <trans-unit id="3b939f106840debe33fe7912aa5a94c4386c469d" translate="yes" xml:space="preserve">
          <source>Value (ReadMostly)</source>
          <target state="translated">值(ReadMostly)</target>
        </trans-unit>
        <trans-unit id="2a2d06d73feadc3e81a5b950d3c3a1578785b1f4" translate="yes" xml:space="preserve">
          <source>Value implements the driver Valuer interface.</source>
          <target state="translated">Value实现了驱动Valuer接口。</target>
        </trans-unit>
        <trans-unit id="dd218fab688fcead8af77b81093aadd12637b021" translate="yes" xml:space="preserve">
          <source>Value is a value that drivers must be able to handle. It is either nil, a type handled by a database driver's NamedValueChecker interface, or an instance of one of these types:</source>
          <target state="translated">Value是一个驱动程序必须能够处理的值,它要么是nil,要么是由数据库驱动程序的NamedValueChecker接口处理的类型,要么是这些类型中的一个实例。它要么是nil,要么是数据库驱动程序的NamedValueChecker接口处理的类型,要么是这些类型中的一个实例。</target>
        </trans-unit>
        <trans-unit id="9752a7f3e66998d9403b579aaf11f5b93a26f7c0" translate="yes" xml:space="preserve">
          <source>Value is the documentation for a (possibly grouped) var or const declaration.</source>
          <target state="translated">值是一个(可能是分组的)var或const声明的文档。</target>
        </trans-unit>
        <trans-unit id="fc8bc38b52edf0162032e19caad204a132e1edc6" translate="yes" xml:space="preserve">
          <source>Value is the interface to the dynamic value stored in a flag. (The default value is represented as a string.)</source>
          <target state="translated">Value是存储在标志中的动态值的接口。默认值用字符串表示)。</target>
        </trans-unit>
        <trans-unit id="2c289f13fb553c52397f1f031c283edf2f75ba5d" translate="yes" xml:space="preserve">
          <source>Value is the reflection interface to a Go value.</source>
          <target state="translated">值是围棋值的反映接口。</target>
        </trans-unit>
        <trans-unit id="f874cfa2eae8a5288d6bb67626a8a5b202b1f1d3" translate="yes" xml:space="preserve">
          <source>Value represents a JavaScript value. The zero value is the JavaScript value &quot;undefined&quot;.</source>
          <target state="translated">Value代表一个JavaScript值。零值是JavaScript值 &quot;undefined&quot;。</target>
        </trans-unit>
        <trans-unit id="12bd1222cbe13b8343d523bcfbb727dc870d622e" translate="yes" xml:space="preserve">
          <source>Value represents a JavaScript value. The zero value is the JavaScript value &quot;undefined&quot;. Values can be checked for equality with the Equal method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bea9dc918e0d02a53c6ed34890033d051d6e5b45" translate="yes" xml:space="preserve">
          <source>Value returns an arbitrary value of the given type. If the type implements the Generator interface, that will be used. Note: To create arbitrary values for structs, all the fields must be exported.</source>
          <target state="translated">Value 返回给定类型的任意值。如果该类型实现了Generator接口,则将使用该接口。注意:要为结构体创建任意值,必须导出所有的字段。</target>
        </trans-unit>
        <trans-unit id="010d442068b6dc0c175fb3be2478e451331b7772" translate="yes" xml:space="preserve">
          <source>Value returns the value of the iterator's current map entry.</source>
          <target state="translated">Value 返回迭代器当前地图条目的值。</target>
        </trans-unit>
        <trans-unit id="4814e1e8c0abd0c5b67abd9fa764cdfa19868250" translate="yes" xml:space="preserve">
          <source>ValueConverter is the interface providing the ConvertValue method.</source>
          <target state="translated">ValueConverter是提供ConvertValue方法的接口。</target>
        </trans-unit>
        <trans-unit id="4ee806fbc08f89d25017504477016f81d87178b9" translate="yes" xml:space="preserve">
          <source>ValueOf returns a new Value initialized to the concrete value stored in the interface i. ValueOf(nil) returns the zero Value.</source>
          <target state="translated">ValueOf(nil)返回一个新的Value,初始化为存储在接口i中的具体值。ValueOf(nil)返回零值。</target>
        </trans-unit>
        <trans-unit id="73fa7582a50fd6ffa7153d229b6170f753731b5a" translate="yes" xml:space="preserve">
          <source>ValueOf returns x as a JavaScript value:</source>
          <target state="translated">ValueOf返回x作为JavaScript值。</target>
        </trans-unit>
        <trans-unit id="f18975e8d6052ff98ae55792b39100c67475c7da" translate="yes" xml:space="preserve">
          <source>Valuer is the interface providing the Value method.</source>
          <target state="translated">Valuer是提供Value方法的接口。</target>
        </trans-unit>
        <trans-unit id="b1564f6b1512cbfa3cfcebc9a5badb6b239954f1" translate="yes" xml:space="preserve">
          <source>Values</source>
          <target state="translated">Values</target>
        </trans-unit>
        <trans-unit id="4c4b32df8b9b0ab6cff257dc64ed3eb643572b49" translate="yes" xml:space="preserve">
          <source>Values containing the types defined in this package should not be copied.</source>
          <target state="translated">包含本包中定义的类型的值不应被复制。</target>
        </trans-unit>
        <trans-unit id="db0f016ee293f8c7fb961ef81d6b041a8271fcde" translate="yes" xml:space="preserve">
          <source>Values maps a string key to a list of values. It is typically used for query parameters and form values. Unlike in the http.Header map, the keys in a Values map are case-sensitive.</source>
          <target state="translated">Values将一个字符串键映射到一个值的列表。它通常用于查询参数和表单值。与 http.Header 映射不同,Values 映射中的键是区分大小写的。</target>
        </trans-unit>
        <trans-unit id="ed9ae6e1ddce7aa950c188cea7070152cbaaef3a" translate="yes" xml:space="preserve">
          <source>Values of IMAGE_FILE_HEADER.Characteristics. These can be combined together.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1b6d5f206af70bb39bd5fc526ef574743992a54" translate="yes" xml:space="preserve">
          <source>Values of the Image interface are created either by calling functions such as NewRGBA and NewPaletted, or by calling Decode on an io.Reader containing image data in a format such as GIF, JPEG or PNG. Decoding any particular image format requires the prior registration of a decoder function. Registration is typically automatic as a side effect of initializing that format's package so that, to decode a PNG image, it suffices to have</source>
          <target state="translated">Image接口的值是通过调用NewRGBA和NewPaletted等函数来创建的,或者通过在包含GIF、JPEG或PNG等格式的图像数据的io.Reader上调用Decode来创建的。解码任何特定的图像格式都需要事先注册一个解码器函数。注册通常是自动的,作为初始化该格式的包的一个副作用,因此,要解码一个PNG图像,只需有以下功能即可</target>
        </trans-unit>
        <trans-unit id="b65743fb1655a6d5656fe5188b8219e485d45a6c" translate="yes" xml:space="preserve">
          <source>Values returns all values associated with the given key. It is case insensitive; CanonicalMIMEHeaderKey is used to canonicalize the provided key. To use non-canonical keys, access the map directly. The returned slice is not a copy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0f032ed754eb781ca5f1ab9c0d5896202022c92" translate="yes" xml:space="preserve">
          <source>Values returns all values associated with the given key. It is case insensitive; textproto.CanonicalMIMEHeaderKey is used to canonicalize the provided key. To use non-canonical keys, access the map directly. The returned slice is not a copy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="556542fae1b8220ad354f73db7960fdf03643304" translate="yes" xml:space="preserve">
          <source>Values that are shared by both R_PPC and R_PPC64 are prefixed with R_POWERPC_ in the ELF standard. For the R_PPC type, the relevant shared relocations have been renamed with the prefix R_PPC_. The original name follows the value in a comment.</source>
          <target state="translated">在ELF标准中,R_PPC和R_PPC64共享的值以R_POWERPC_为前缀。对于R_PPC类型,相关的共享重定位已经用前缀R_PPC_重新命名。原来的名称在注释中的值后面。</target>
        </trans-unit>
        <trans-unit id="35513df4822daf6991ea9831d940cbcb44ab9510" translate="yes" xml:space="preserve">
          <source>Values that are shared by both R_PPC and R_PPC64 are prefixed with R_POWERPC_ in the ELF standard. For the R_PPC64 type, the relevant shared relocations have been renamed with the prefix R_PPC64_. The original name follows the value in a comment.</source>
          <target state="translated">在ELF标准中,R_PPC和R_PPC64共享的值以R_POWERPC_为前缀。对于R_PPC64类型,相关的共享重定位已经用前缀R_PPC64_重新命名。原来的名称在注释中的值后面。</target>
        </trans-unit>
        <trans-unit id="5491dd2526a7b6a12fe2eb7a45fdc97e08387c1a" translate="yes" xml:space="preserve">
          <source>Var defines a flag with the specified name and usage string. The type and value of the flag are represented by the first argument, of type Value, which typically holds a user-defined implementation of Value. For instance, the caller could create a flag that turns a comma-separated string into a slice of strings by giving the slice the methods of Value; in particular, Set would decompose the comma-separated string into the slice.</source>
          <target state="translated">Var定义了一个具有指定名称和用法字符串的标志。标志的类型和值由第一个参数表示,类型为Value,它通常持有用户定义的Value的实现。例如,调用者可以创建一个标志,通过给分片Value的方法,将一个逗号分隔的字符串变成一个分片的字符串;特别是,Set将把逗号分隔的字符串分解到分片中。</target>
        </trans-unit>
        <trans-unit id="ce2b2698fd744904596b638fadb24e9ac560ff55" translate="yes" xml:space="preserve">
          <source>Var is an abstract type for all exported variables.</source>
          <target state="translated">Var是所有导出变量的抽象类型。</target>
        </trans-unit>
        <trans-unit id="2fe39193f9c048f94aabb561a65b8ad4ebd4664a" translate="yes" xml:space="preserve">
          <source>VariableNode holds a list of variable names, possibly with chained field accesses. The dollar sign is part of the (first) name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac018db1f7b00972061adff843d37497d8ee153c" translate="yes" xml:space="preserve">
          <source>Variables</source>
          <target state="translated">Variables</target>
        </trans-unit>
        <trans-unit id="f9c863db27e83db40f4468fc4bc690e601042fdf" translate="yes" xml:space="preserve">
          <source>Variables previously declared can also be assigned, using the syntax</source>
          <target state="translated">之前声明的变量也可以被分配,使用的语法是</target>
        </trans-unit>
        <trans-unit id="ca11a0cc5def9c210a74faf8ede1798e07fe2571" translate="yes" xml:space="preserve">
          <source>Variadic reports whether the signature s is variadic.</source>
          <target state="translated">Variadic报告签名s是否为可变的。</target>
        </trans-unit>
        <trans-unit id="41d79747265706c0afa494f13a1d7304f4478119" translate="yes" xml:space="preserve">
          <source>Varint</source>
          <target state="translated">Varint</target>
        </trans-unit>
        <trans-unit id="f5ebfb0ae8769b5ca2188331b009d7eba5a85341" translate="yes" xml:space="preserve">
          <source>Varint decodes an int64 from buf and returns that value and the number of bytes read (&amp;gt; 0). If an error occurred, the value is 0 and the number of bytes n is &amp;lt;= 0 with the following meaning:</source>
          <target state="translated">Varint从buf解码int64并返回该值和读取的字节数（&amp;gt; 0）。如果发生错误，则值为0，字节数n为&amp;lt;= 0，含义如下：</target>
        </trans-unit>
        <trans-unit id="d24fa62b1d834d7cd3cd0e8882051f85d094eda3" translate="yes" xml:space="preserve">
          <source>Various errors contained in OpError.</source>
          <target state="translated">OpError中包含的各种错误。</target>
        </trans-unit>
        <trans-unit id="1a2978dcc531a211271eca6e53e9367381806a65" translate="yes" xml:space="preserve">
          <source>Various implementations of ValueConverter are provided by the driver package to provide consistent implementations of conversions between drivers. The ValueConverters have several uses:</source>
          <target state="translated">驱动程序包提供了ValueConverter的各种实现,以提供驱动程序之间转换的一致实现。ValueConverters有几种用途。</target>
        </trans-unit>
        <trans-unit id="677405d5dfca724a737bda64c6dc1ddb03f2bb84" translate="yes" xml:space="preserve">
          <source>Various isolation levels that drivers may support in BeginTx. If a driver does not support a given isolation level an error may be returned.</source>
          <target state="translated">BeginTx中的驱动程序可能支持的各种隔离级别。如果一个驱动程序不支持给定的隔离级别,则可能会返回一个错误。</target>
        </trans-unit>
        <trans-unit id="cc21bbee9a9b0425c95545ecf2f53bc29369d55b" translate="yes" xml:space="preserve">
          <source>Various methods support conversions between strings and corresponding numeric values, and vice versa: *Int, *Rat, and *Float values implement the Stringer interface for a (default) string representation of the value, but also provide SetString methods to initialize a value from a string in a variety of supported formats (see the respective SetString documentation).</source>
          <target state="translated">各种方法支持字符串和相应的数值之间的转换,反之亦然。*Int、*Rat和*Float值实现了Stringer接口,用于(默认)数值的字符串表示,但也提供了SetString方法,以各种支持的格式从字符串中初始化数值(见各自的SetString文档)。</target>
        </trans-unit>
        <trans-unit id="fe5502979be4e45317e06e3f4bc8dea3c27b9d68" translate="yes" xml:space="preserve">
          <source>Verbose reports whether the -test.v flag is set.</source>
          <target state="translated">Verbose报告是否设置了-test.v标志。</target>
        </trans-unit>
        <trans-unit id="155a05e64e4d5e6d0dbf5afad455ef4b2c7d215e" translate="yes" xml:space="preserve">
          <source>Verify attempts to verify c by building one or more chains from c to a certificate in opts.Roots, using certificates in opts.Intermediates if needed. If successful, it returns one or more chains where the first element of the chain is c and the last element is from opts.Roots.</source>
          <target state="translated">验证试图通过建立一个或多个从c到opts.Root中的证书的链来验证c,必要时使用opts.Intermediates中的证书。如果成功,它将返回一个或多个链,链的第一个元素是c,最后一个元素来自opts.Root。</target>
        </trans-unit>
        <trans-unit id="8f646662ac01cb1ef7a3f3dbe169c861f558bcfa" translate="yes" xml:space="preserve">
          <source>Verify checks the validity of an email address on the server. If Verify returns nil, the address is valid. A non-nil return does not necessarily indicate an invalid address. Many servers will not verify addresses for security reasons.</source>
          <target state="translated">Verify检查服务器上电子邮件地址的有效性。如果Verify返回nil,则说明该地址有效。非零的返回值不一定是一个无效的地址。许多服务器出于安全考虑不会验证地址。</target>
        </trans-unit>
        <trans-unit id="5f78fb77229812b310f6d30ba2f8eeb1a758e0db" translate="yes" xml:space="preserve">
          <source>Verify reports whether sig is a valid signature of message by publicKey. It will panic if len(publicKey) is not PublicKeySize.</source>
          <target state="translated">验证报告sig是否是消息的有效签名,通过publicKey。如果len(publicKey)不是PublicKeySize,它将恐慌。</target>
        </trans-unit>
        <trans-unit id="afa19e9e5042f2e1366a51a651d0d42c62c9a9dc" translate="yes" xml:space="preserve">
          <source>Verify verifies the signature in r, s of hash using the public key, pub. It reports whether the signature is valid.</source>
          <target state="translated">验证使用公钥pub对哈希的r,s中的签名进行验证。它报告签名是否有效。</target>
        </trans-unit>
        <trans-unit id="29e311050b6e4da19e97375079ff2944ac6c7fb5" translate="yes" xml:space="preserve">
          <source>Verify verifies the signature in r, s of hash using the public key, pub. Its return value records whether the signature is valid.</source>
          <target state="translated">验证使用公钥pub对哈希的r,s中的签名进行验证。它的返回值记录了签名是否有效。</target>
        </trans-unit>
        <trans-unit id="145232aacf42696b4e278956de6bab24512004cd" translate="yes" xml:space="preserve">
          <source>VerifyASN1 verifies the ASN.1 encoded signature, sig, of hash using the public key, pub. Its return value records whether the signature is valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c77ce67480dc146ec9f71541bb8eac40755f84ee" translate="yes" xml:space="preserve">
          <source>VerifyHostname checks that the peer certificate chain is valid for connecting to host. If so, it returns nil; if not, it returns an error describing the problem.</source>
          <target state="translated">VerifyHostname检查对等体证书链是否对连接到主机有效。如果有效,则返回nil;如果无效,则返回一个描述问题的错误。</target>
        </trans-unit>
        <trans-unit id="4d87443c0e8c5a2665736c35fe304b37073dc32e" translate="yes" xml:space="preserve">
          <source>VerifyHostname returns nil if c is a valid certificate for the named host. Otherwise it returns an error describing the mismatch.</source>
          <target state="translated">如果 c 是指定主机的有效证书,VerifyHostname 返回 nil。否则,它会返回一个错误,描述不匹配的情况。</target>
        </trans-unit>
        <trans-unit id="f86ef4530b45b573b44981bfecb27623cddb836c" translate="yes" xml:space="preserve">
          <source>VerifyOptions contains parameters for Certificate.Verify.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cca137a6af7f592d32076ad3b96f2dd532d13e4" translate="yes" xml:space="preserve">
          <source>VerifyOptions contains parameters for Certificate.Verify. It's a structure because other PKIX verification APIs have ended up needing many options.</source>
          <target state="translated">VerifyOptions 包含 Certificate.Verify 的参数。这是一个结构,因为其他PKIX验证API最后需要很多选项。</target>
        </trans-unit>
        <trans-unit id="904631d00687a7288866da49169708056e59b147" translate="yes" xml:space="preserve">
          <source>VerifyPKCS1v15</source>
          <target state="translated">VerifyPKCS1v15</target>
        </trans-unit>
        <trans-unit id="03648c01c4f8ec482385a7d7d5a6f43278916d7d" translate="yes" xml:space="preserve">
          <source>VerifyPKCS1v15 verifies an RSA PKCS #1 v1.5 signature. hashed is the result of hashing the input message using the given hash function and sig is the signature. A valid signature is indicated by returning a nil error. If hash is zero then hashed is used directly. This isn't advisable except for interoperability.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fac2ac8cef2b4f2fce0053008362560cd0a7f6f" translate="yes" xml:space="preserve">
          <source>VerifyPKCS1v15 verifies an RSA PKCS#1 v1.5 signature. hashed is the result of hashing the input message using the given hash function and sig is the signature. A valid signature is indicated by returning a nil error. If hash is zero then hashed is used directly. This isn't advisable except for interoperability.</source>
          <target state="translated">VerifyPKCS1v15 验证 RSA PKCS#1 v1.5 的签名,hash 是使用给定的散列函数对输入信息进行散列的结果,sig 是签名。一个有效的签名是通过返回一个nil错误来表示的。如果hash为0,则直接使用hash。这并不可取,除非是为了互操作性。</target>
        </trans-unit>
        <trans-unit id="22849df5c99a08214a361cc786e111d1f4ddafec" translate="yes" xml:space="preserve">
          <source>VerifyPSS verifies a PSS signature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a12022e4f1f957db46b6ad31ae0c6d8b5b335f06" translate="yes" xml:space="preserve">
          <source>VerifyPSS verifies a PSS signature. hashed is the result of hashing the input message using the given hash function and sig is the signature. A valid signature is indicated by returning a nil error. The opts argument may be nil, in which case sensible defaults are used.</source>
          <target state="translated">VerifyPSS 验证 PSS 签名。hash 是使用给定的散列函数对输入消息进行散列的结果,sig 是签名。一个有效的签名会以返回一个nil错误来表示。opts参数可能是nil,在这种情况下,会使用合理的默认值。</target>
        </trans-unit>
        <trans-unit id="fc50bdb16e95dd81d5ab93336a4873d743e71e10" translate="yes" xml:space="preserve">
          <source>Version is found in Header.Ident[EI_VERSION] and Header.Version.</source>
          <target state="translated">版本在Header.Ident[EI_VERSION]和Header.Version中找到。</target>
        </trans-unit>
        <trans-unit id="4d5c372788d86ffb1bb307fe18c33d0d35dfaf32" translate="yes" xml:space="preserve">
          <source>Version is the Unicode edition from which the tables are derived.</source>
          <target state="translated">版本是Unicode版本,这些表格是由Unicode版本衍生出来的。</target>
        </trans-unit>
        <trans-unit id="50de89df378f68937423c4c0b0df29cc9d671898" translate="yes" xml:space="preserve">
          <source>Version returns the Go tree's version string. It is either the commit hash and date at the time of the build or, when possible, a release tag like &quot;go1.3&quot;.</source>
          <target state="translated">Version 返回 Go 树的版本字符串。它是构建时的提交哈希和日期,或者在可能的情况下,是一个发布标签,如 &quot;go1.3&quot;。</target>
        </trans-unit>
        <trans-unit id="a9f8b9e002c84b093e85fe6340e9e2446c0f01f6" translate="yes" xml:space="preserve">
          <source>Very large values overflow to -1 or +Inf.</source>
          <target state="translated">非常大的值溢出到-1或+Inf。</target>
        </trans-unit>
        <trans-unit id="62ec9d14e878063c7140d04d700991af277e0332" translate="yes" xml:space="preserve">
          <source>Very large values overflow to 0 or +Inf. Very small values underflow to 1.</source>
          <target state="translated">非常大的值溢出到0或+Inf.,非常小的值溢出到1。非常小的值下溢为1。</target>
        </trans-unit>
        <trans-unit id="548f7438120baf452d57249c7ed1e4259eddd666" translate="yes" xml:space="preserve">
          <source>Visit visits the command-line flags in lexicographical order, calling fn for each. It visits only those flags that have been set.</source>
          <target state="translated">访问按词典顺序访问命令行标志,对每个标志调用fn。它只访问那些已经设置的标志。</target>
        </trans-unit>
        <trans-unit id="3d71d97888658f2741fa47ca0e6dafd3ee5bd8d5" translate="yes" xml:space="preserve">
          <source>Visit visits the flags in lexicographical order, calling fn for each. It visits only those flags that have been set.</source>
          <target state="translated">访问按词法顺序访问旗帜,对每个旗帜调用fn。它只访问那些已经设置的标志。</target>
        </trans-unit>
        <trans-unit id="fe139ba7798500e37c921c3f2eca473d92def875" translate="yes" xml:space="preserve">
          <source>VisitAll visits the command-line flags in lexicographical order, calling fn for each. It visits all flags, even those not set.</source>
          <target state="translated">VisitAll 按词典顺序访问命令行标志,对每个标志调用 fn。它访问所有的标志,即使是那些没有设置的标志。</target>
        </trans-unit>
        <trans-unit id="91926cb218ad9a9f08c7f40210f9b3b594b76515" translate="yes" xml:space="preserve">
          <source>VisitAll visits the flags in lexicographical order, calling fn for each. It visits all flags, even those not set.</source>
          <target state="translated">VisitAll 按词法顺序访问标志,对每个标志调用 fn。它访问所有的标志,即使是那些没有设置的标志。</target>
        </trans-unit>
        <trans-unit id="82b27aedf84d8e8a368898854887f1a9db2938b6" translate="yes" xml:space="preserve">
          <source>VolumeName returns leading volume name. Given &quot;C:\foo\bar&quot; it returns &quot;C:&quot; on Windows. Given &quot;\\host\share\foo&quot; it returns &quot;\\host\share&quot;. On other platforms it returns &quot;&quot;.</source>
          <target state="translated">VolumeName返回前面的卷名。给定 &quot;C:\foo\bar&quot;,在Windows上返回 &quot;C:&quot;。给定&quot;\host\share\foo&quot;,它返回&quot;\host\share&quot;。在其他平台上,它返回&quot;&quot;。</target>
        </trans-unit>
        <trans-unit id="116af4a220931a113874c3a9a8fb8b67e737c229" translate="yes" xml:space="preserve">
          <source>WARNING: this function doesn't do any revocation checking.</source>
          <target state="translated">警告:这个函数不做任何撤销检查。</target>
        </trans-unit>
        <trans-unit id="ac3ed0238ed01e1e125ce49b809e2689db256bfa" translate="yes" xml:space="preserve">
          <source>WARNING: use of this function to encrypt plaintexts other than session keys is dangerous. Use RSA OAEP in new protocols.</source>
          <target state="translated">警告:使用该函数加密会话密钥以外的明文是危险的。在新协议中使用RSA OAEP。</target>
        </trans-unit>
        <trans-unit id="d791440e471e57ef06317ea366a55351a6722e8d" translate="yes" xml:space="preserve">
          <source>Wait atomically unlocks c.L and suspends execution of the calling goroutine. After later resuming execution, Wait locks c.L before returning. Unlike in other systems, Wait cannot return unless awoken by Broadcast or Signal.</source>
          <target state="translated">Wait原子性地解锁c.L并暂停执行调用的goroutine。之后恢复执行后,Wait在返回前锁定c.L。与其他系统不同,除非被Broadcast或Signal唤醒,否则Wait不能返回。</target>
        </trans-unit>
        <trans-unit id="c1e4ec07809f552042a2744ebd76a1ff9cdfd927" translate="yes" xml:space="preserve">
          <source>Wait blocks until the WaitGroup counter is zero.</source>
          <target state="translated">等待块,直到WaitGroup计数器为零。</target>
        </trans-unit>
        <trans-unit id="a2b93a450c159447eb449f1d44b9509d23d1eff8" translate="yes" xml:space="preserve">
          <source>Wait releases any resources associated with the Cmd.</source>
          <target state="translated">等待释放与Cmd相关的任何资源。</target>
        </trans-unit>
        <trans-unit id="cecb6db143b18629c77edfdcfa6e40a828bd3ecd" translate="yes" xml:space="preserve">
          <source>Wait waits for the Process to exit, and then returns a ProcessState describing its status and an error, if any. Wait releases any resources associated with the Process. On most operating systems, the Process must be a child of the current process or an error will be returned.</source>
          <target state="translated">Wait等待进程退出,然后返回一个描述其状态的ProcessState和一个错误(如果有)。Wait会释放与Process相关的任何资源。在大多数操作系统上,进程必须是当前进程的子进程,否则将返回一个错误。</target>
        </trans-unit>
        <trans-unit id="ef4d163f70a5558cd92581c6468ca54f951f10cb" translate="yes" xml:space="preserve">
          <source>Wait waits for the command to exit and waits for any copying to stdin or copying from stdout or stderr to complete.</source>
          <target state="translated">等待等待命令退出,并等待任何复制到stdin或从stdout或stderr复制完成。</target>
        </trans-unit>
        <trans-unit id="aea382006d640fdfa58d59c1e0ad39798008158f" translate="yes" xml:space="preserve">
          <source>Wait will close the pipe after seeing the command exit, so most callers need not close the pipe themselves. It is thus incorrect to call Wait before all reads from the pipe have completed. For the same reason, it is incorrect to call Run when using StdoutPipe. See the example for idiomatic usage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d3243a3ead84d3a842320a1e7a6c5fbcf29075e" translate="yes" xml:space="preserve">
          <source>Wait will close the pipe after seeing the command exit, so most callers need not close the pipe themselves. It is thus incorrect to call Wait before all reads from the pipe have completed. For the same reason, it is incorrect to use Run when using StderrPipe. See the StdoutPipe example for idiomatic usage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e61dcf7176445918332c5c75e515641021cd367b" translate="yes" xml:space="preserve">
          <source>Wait will close the pipe after seeing the command exit, so most callers need not close the pipe themselves; however, an implication is that it is incorrect to call Wait before all reads from the pipe have completed. For the same reason, it is incorrect to call Run when using StdoutPipe. See the example for idiomatic usage.</source>
          <target state="translated">Wait会在看到命令退出后关闭管道,所以大多数调用者不需要自己关闭管道;但是,一个意思是,在管道的所有读取完成之前调用Wait是不正确的。出于同样的原因,在使用StdoutPipe时调用Run是不正确的。参见示例中的习惯用法。</target>
        </trans-unit>
        <trans-unit id="6e2d628a299984437542474f102b1e387913aa4f" translate="yes" xml:space="preserve">
          <source>Wait will close the pipe after seeing the command exit, so most callers need not close the pipe themselves; however, an implication is that it is incorrect to call Wait before all reads from the pipe have completed. For the same reason, it is incorrect to use Run when using StderrPipe. See the StdoutPipe example for idiomatic usage.</source>
          <target state="translated">Wait会在看到命令退出后关闭管道,所以大多数调用者不需要自己关闭管道;但是,一个含义是,在管道的所有读取完成之前调用Wait是不正确的。出于同样的原因,在使用StderrPipe时使用Run是不正确的。参见StdoutPipe的例子,了解其习惯用法。</target>
        </trans-unit>
        <trans-unit id="66edd56a29d8f65f00197517346652171bdf474e" translate="yes" xml:space="preserve">
          <source>WaitGroup</source>
          <target state="translated">WaitGroup</target>
        </trans-unit>
        <trans-unit id="e0c705d18e3fae4506d7273bda6435690cdbde08" translate="yes" xml:space="preserve">
          <source>Walk</source>
          <target state="translated">Walk</target>
        </trans-unit>
        <trans-unit id="9272862a0570cd3c8a576242d0e65b3cfcf9dde3" translate="yes" xml:space="preserve">
          <source>Walk traverses an AST in depth-first order: It starts by calling v.Visit(node); node must not be nil. If the visitor w returned by v.Visit(node) is not nil, Walk is invoked recursively with visitor w for each of the non-nil children of node, followed by a call of w.Visit(nil).</source>
          <target state="translated">Walk以深度优先的顺序遍历一个AST,它通过调用v.Visit(node)开始,node必须不是nil。它首先调用v.Visit(node);node不能是nil.如果v.Visit(node)返回的访问者w不是nil,Walk就会对node的每一个非nil的子节点递归调用访问者w。如果v.Visit(node)返回的访问者w不是nil,那么Walk将对node的每个非nil子节点递归调用访问者w,然后调用w.Visit(nil)。</target>
        </trans-unit>
        <trans-unit id="844997b7d380cfffe958c2b4b63e117129683358" translate="yes" xml:space="preserve">
          <source>Walk walks the file tree rooted at root, calling walkFn for each file or directory in the tree, including root. All errors that arise visiting files and directories are filtered by walkFn. The files are walked in lexical order, which makes the output deterministic but means that for very large directories Walk can be inefficient. Walk does not follow symbolic links.</source>
          <target state="translated">Walk走过以根为根的文件树,对树上的每个文件或目录(包括根)调用 walkFn。所有在访问文件和目录时产生的错误都会被 walkFn 过滤掉。文件是按词法顺序走的,这使得输出是确定性的,但这意味着对于非常大的目录,Walk的效率会很低。Walk不遵循符号链接。</target>
        </trans-unit>
        <trans-unit id="ea8fd18744a5b8a94a61df0e6be7f9d622440bee" translate="yes" xml:space="preserve">
          <source>WalkFunc is the type of the function called for each file or directory visited by Walk. The path argument contains the argument to Walk as a prefix; that is, if Walk is called with &quot;dir&quot;, which is a directory containing the file &quot;a&quot;, the walk function will be called with argument &quot;dir/a&quot;. The info argument is the os.FileInfo for the named path.</source>
          <target state="translated">WalkFunc是Walk每访问一个文件或目录所调用的函数类型。路径参数包含作为前缀的Walk参数;也就是说,如果用 &quot;dir &quot;来调用Walk,即包含文件 &quot;a &quot;的目录,那么Walk函数将用参数 &quot;dir/a &quot;来调用。info参数是命名路径的os.FileInfo。</target>
        </trans-unit>
        <trans-unit id="2918ed6d5c509e3ed1b93a9bceda4782bc8dd955" translate="yes" xml:space="preserve">
          <source>Warning logs a message with severity LOG_WARNING, ignoring the severity passed to New.</source>
          <target state="translated">Warning记录一条严重性为LOG_WARNING的消息,忽略传递给New的严重性。</target>
        </trans-unit>
        <trans-unit id="6dda0897da5609f90207d91adc268a59c4a1ed0a" translate="yes" xml:space="preserve">
          <source>We define codes for each error that manifests while escaping templates, but escaped templates may also fail at runtime.</source>
          <target state="translated">我们为每个在转义模板时表现出来的错误定义了代码,但转义模板也可能在运行时失败。</target>
        </trans-unit>
        <trans-unit id="4c1d860c4500491f651fd6c28babc0fc5252a9c1" translate="yes" xml:space="preserve">
          <source>WebSafe is a 216-color palette that was popularized by early versions of Netscape Navigator. It is also known as the Netscape Color Cube.</source>
          <target state="translated">WebSafe是一个216色的调色板,它是由早期版本的Netscape Navigator所流行的。它也被称为Netscape色彩立方体。</target>
        </trans-unit>
        <trans-unit id="9b612a9be3daa519fe810c831ee09c50cb694cd9" translate="yes" xml:space="preserve">
          <source>Weekday returns the day of the week specified by t.</source>
          <target state="translated">Weekday 返回由t指定的一周中的一天。</target>
        </trans-unit>
        <trans-unit id="f665bbd01fb3804e446b49c63f8771aa2a58f0dc" translate="yes" xml:space="preserve">
          <source>Well-known IPv4 addresses</source>
          <target state="translated">著名的IPv4地址</target>
        </trans-unit>
        <trans-unit id="d1c37cf7857b91d487793e2b066aa7768c44b584" translate="yes" xml:space="preserve">
          <source>Well-known IPv6 addresses</source>
          <target state="translated">著名的IPv6地址</target>
        </trans-unit>
        <trans-unit id="423b2ce203c11b513c12b2cf5a302bece806d9e9" translate="yes" xml:space="preserve">
          <source>When Go code is built with options like -buildmode=c-shared, it will be run as part of an existing non-Go program. The non-Go code may have already installed signal handlers when the Go code starts (that may also happen in unusual cases when using cgo or SWIG; in that case, the discussion here applies). For -buildmode=c-archive the Go runtime will initialize signals at global constructor time. For -buildmode=c-shared the Go runtime will initialize signals when the shared library is loaded.</source>
          <target state="translated">当围棋代码使用-buildmode=c-shared等选项构建时,它将作为现有非围棋程序的一部分运行。当围棋代码启动时,非围棋代码可能已经安装了信号处理程序(在使用cgo或SWIG时,这种情况也可能发生;在这种情况下,这里的讨论适用)。对于-buildmode=c-archive,围棋运行时将在全局构造函数时初始化信号。对于-buildmode=c-shared,Go运行时将在加载共享库时初始化信号。</target>
        </trans-unit>
        <trans-unit id="157b3f39795f3c1bb26d85adf87f02f3367ef226" translate="yes" xml:space="preserve">
          <source>When Read encounters an error or end-of-file condition after successfully reading n &amp;gt; 0 bytes, it returns the number of bytes read. It may return the (non-nil) error from the same call or return the error (and n == 0) from a subsequent call. An instance of this general case is that a Reader returning a non-zero number of bytes at the end of the input stream may return either err == EOF or err == nil. The next Read should return 0, EOF.</source>
          <target state="translated">当成功读取n&amp;gt; 0个字节后，Read遇到错误或文件结束条件时，它将返回读取的字节数。它可能从同一调用返回（非nil）错误，或者从后续调用返回错误（n == 0）。这种一般情况的一个实例是，读取器在输入流的末尾返回非零字节数的情况下，可能返回err == EOF或err == nil。下一次读取应返回0，EOF。</target>
        </trans-unit>
        <trans-unit id="d6278f9f812d1e00a798b88f0d43a4c07f1b736e" translate="yes" xml:space="preserve">
          <source>When ReadAt returns n &amp;lt; len(p), it returns a non-nil error explaining why more bytes were not returned. In this respect, ReadAt is stricter than Read.</source>
          <target state="translated">当ReadAt返回n &amp;lt;len（p）时，它返回一个非nil错误，解释了为什么不返回更多字节。在这方面，ReadAt比Read更严格。</target>
        </trans-unit>
        <trans-unit id="e42e8857e0f2dbf41e5d11d0b713339895c2d306" translate="yes" xml:space="preserve">
          <source>When Shutdown is called, Serve, ListenAndServe, and ListenAndServeTLS immediately return ErrServerClosed. Make sure the program doesn't exit and waits instead for Shutdown to return.</source>
          <target state="translated">当调用Shutdown时,Serve、ListenAndServe和ListenAndServeTLS立即返回ErrServerClosed。确保程序不会退出,而是等待Shutdown返回。</target>
        </trans-unit>
        <trans-unit id="a1346033e8cd0c36ddc0423c4dcbbce227d0c225" translate="yes" xml:space="preserve">
          <source>When TestMain is called, flag.Parse has not been run. If TestMain depends on command-line flags, including those of the testing package, it should call flag.Parse explicitly. Command line flags are always parsed by the time test or benchmark functions run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52cedf2625524a5c08d35a591f2ee66394bc79d6" translate="yes" xml:space="preserve">
          <source>When Token encounters an error or end-of-file condition after successfully reading a token, it returns the token. It may return the (non-nil) error from the same call or return the error (and a nil token) from a subsequent call. An instance of this general case is that a TokenReader returning a non-nil token at the end of the token stream may return either io.EOF or a nil error. The next Read should return nil, io.EOF.</source>
          <target state="translated">当Token在成功读取一个token后遇到错误或文件结束的情况时,它将返回token,它可能会从同一个调用中返回错误(非零),或者从后续调用中返回错误(和一个nil token)。它可能会从同一个调用中返回(非零)错误,也可能会从后续调用中返回错误(和一个nil token)。这个一般情况的一个例子是,一个TokenReader在token流结束时返回一个非nil token,可能会返回io.EOF或nil错误。下一个Read应该返回nil,io.EOF。</target>
        </trans-unit>
        <trans-unit id="3250a941e5738a81aa69e5097500ef947e64f456" translate="yes" xml:space="preserve">
          <source>When a Go program writes to a broken pipe, the kernel will raise a SIGPIPE signal.</source>
          <target state="translated">当围棋程序向断管写入时,内核会发出SIGPIPE信号。</target>
        </trans-unit>
        <trans-unit id="ed858d1cf0b08d8b30624984289eaf84deee9351" translate="yes" xml:space="preserve">
          <source>When a data value is not plain text, you can make sure it is not over-escaped by marking it with its type.</source>
          <target state="translated">当一个数据值不是纯文本时,你可以通过用它的类型标记来确保它不被过度捕获。</target>
        </trans-unit>
        <trans-unit id="dcc36ea4f1110a5d9628600e555148a98813c271" translate="yes" xml:space="preserve">
          <source>When a plugin is first opened, the init functions of all packages not already part of the program are called. The main function is not run. A plugin is only initialized once, and cannot be closed.</source>
          <target state="translated">当一个插件第一次被打开时,所有尚未成为程序一部分的包的init函数都会被调用。主函数不会被运行。一个插件只初始化一次,不能关闭。</target>
        </trans-unit>
        <trans-unit id="34098c7334f20e516928585d3dd596a221004580" translate="yes" xml:space="preserve">
          <source>When adding a new file, a file base must be provided. That can be any integer value that is past the end of any interval of any file already in the file set. For convenience, FileSet.Base provides such a value, which is simply the end of the Pos interval of the most recently added file, plus one. Unless there is a need to extend an interval later, using the FileSet.Base should be used as argument for FileSet.AddFile.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82668902c85167e64c6f0f47b4424c5d8da33aca" translate="yes" xml:space="preserve">
          <source>When calling SetCgoTraceback, the version argument is the version number of the structs that the functions expect to receive. Currently this must be zero.</source>
          <target state="translated">当调用SetCgoTraceback时,版本参数是函数期望接收的结构的版本号。目前这个参数必须为零。</target>
        </trans-unit>
        <trans-unit id="bb4ae77735024f9be2c837577d3897cb72653910" translate="yes" xml:space="preserve">
          <source>When cgo is available, cgo-based (libc-backed) code is used by default. This can be overridden by using osusergo build tag, which enforces the pure Go implementation.</source>
          <target state="translated">当cgo可用时,默认使用基于cgo(libc支持)的代码。这可以通过使用 osusergo build tag 来重写,它强制执行纯 Go 实现。</target>
        </trans-unit>
        <trans-unit id="752b47af0ec8b502ec7dd916b2f8679be6d9d28e" translate="yes" xml:space="preserve">
          <source>When err is nil, resp always contains a non-nil resp.Body. Caller should close resp.Body when done reading from it.</source>
          <target state="translated">当err为nil时,resp总是包含一个非nil的resp.Body。调用者应该在完成对resp.Body的读取后关闭它。</target>
        </trans-unit>
        <trans-unit id="01d9fbd4a2ba2cf83a0b45d054350614384bbdc9" translate="yes" xml:space="preserve">
          <source>When execution begins, $ is set to the data argument passed to Execute, that is, to the starting value of dot.</source>
          <target state="translated">当执行开始时,$被设置为传递给Execute的数据参数,也就是点的起始值。</target>
        </trans-unit>
        <trans-unit id="8919d4f071112552ffa9917647b1e1053256e035" translate="yes" xml:space="preserve">
          <source>When following redirects, the Client will forward all headers set on the initial Request except:</source>
          <target state="translated">当跟随重定向时,客户端将转发初始请求中设置的所有头信息,但以下情况除外。</target>
        </trans-unit>
        <trans-unit id="9524b6877cae25b318411b88de97b53bfbb0506c" translate="yes" xml:space="preserve">
          <source>When matching against text, the regexp returns a match that begins as early as possible in the input (leftmost), and among those it chooses the one that a backtracking search would have found first. This so-called leftmost-first matching is the same semantics that Perl, Python, and other implementations use, although this package implements it without the expense of backtracking. For POSIX leftmost-longest matching, see CompilePOSIX.</source>
          <target state="translated">当与文本进行匹配时,regexp 会返回一个在输入中尽可能早开始的匹配(最左端),并在这些匹配中选择一个回溯搜索会首先找到的匹配。这种所谓的最左首匹配与Perl、Python和其他实现所使用的语义是一样的,尽管这个包在实现它的时候没有进行回溯搜索。关于 POSIX 最左最长匹配,请参见 CompilePOSIX。</target>
        </trans-unit>
        <trans-unit id="c6e22a9991087594c0b8cf7617afd5eef2db8623" translate="yes" xml:space="preserve">
          <source>When parsing a template, another template may be defined and associated with the template being parsed. Template definitions must appear at the top level of the template, much like global variables in a Go program.</source>
          <target state="translated">在解析一个模板时,可以定义另一个模板,并与被解析的模板相关联。模板定义必须出现在模板的顶层,就像Go程序中的全局变量一样。</target>
        </trans-unit>
        <trans-unit id="017afe59414197ba093e7c01bd629debe47b73b4" translate="yes" xml:space="preserve">
          <source>When parsing a time with a zone abbreviation like MST, if the zone abbreviation has a defined offset in the current location, then that offset is used. The zone abbreviation &quot;UTC&quot; is recognized as UTC regardless of location. If the zone abbreviation is unknown, Parse records the time as being in a fabricated location with the given zone abbreviation and a zero offset. This choice means that such a time can be parsed and reformatted with the same layout losslessly, but the exact instant used in the representation will differ by the actual zone offset. To avoid such problems, prefer time layouts that use a numeric zone offset, or use ParseInLocation.</source>
          <target state="translated">当解析一个带有区域缩写(如MST)的时间时,如果该区域缩写在当前位置有一个定义的偏移,那么就会使用该偏移。区段缩写 &quot;UTC &quot;会被识别为UTC,与位置无关。如果区域缩写是未知的,Parsse会将时间记录为在给定的区域缩写和零偏移的编造位置。这种选择意味着这样的时间可以无损地以相同的布局进行解析和重新格式化,但在表示中使用的确切瞬间会因实际的区域偏移而不同。为了避免这样的问题,请优先选择使用数字区偏移量的时间布局,或者使用ParseInLocation。</target>
        </trans-unit>
        <trans-unit id="6cdce46cbdd242d854181ed07c3441caefe581b7" translate="yes" xml:space="preserve">
          <source>When parsing a time with a zone offset like -0700, if the offset corresponds to a time zone used by the current location (Local), then Parse uses that location and zone in the returned time. Otherwise it records the time as being in a fabricated location with time fixed at the given zone offset.</source>
          <target state="translated">当解析一个带有区间偏移的时间时,比如-0700,如果偏移量对应于当前位置(Local)使用的时区,那么Parse在返回的时间中使用该位置和区间。否则,它将把时间记录为在一个编造的位置,时间固定在给定的区间偏移。</target>
        </trans-unit>
        <trans-unit id="67cd941accf04bdb338f577638abdd5419252ad9" translate="yes" xml:space="preserve">
          <source>When parsing multiple files with the same name in different directories, the last one mentioned will be the one that results.</source>
          <target state="translated">当解析不同目录下的多个同名文件时,以最后提到的那个文件为结果。</target>
        </trans-unit>
        <trans-unit id="ddcdf8b97f4b2868ce974b91b64fece54bf4c923" translate="yes" xml:space="preserve">
          <source>When parsing multiple files with the same name in different directories, the last one mentioned will be the one that results. For instance, ParseFiles(&quot;a/foo&quot;, &quot;b/foo&quot;) stores &quot;b/foo&quot; as the template named &quot;foo&quot;, while &quot;a/foo&quot; is unavailable.</source>
          <target state="translated">当解析不同目录下的多个同名文件时,最后提到的那个文件将是结果。例如,ParseFiles(&quot;a/foo&quot;,&quot;b/foo&quot;)将 &quot;b/foo &quot;存储为名为 &quot;foo &quot;的模板,而 &quot;a/foo &quot;则不可用。</target>
        </trans-unit>
        <trans-unit id="34e29899665d5e8ad85e485fb7f40717928c9cd2" translate="yes" xml:space="preserve">
          <source>When printing a struct, fmt cannot and therefore does not invoke formatting methods such as Error or String on unexported fields.</source>
          <target state="translated">当打印一个结构体时,fmt不能,因此也不会对未导出的字段调用Error或String等格式化方法。</target>
        </trans-unit>
        <trans-unit id="328b930d804aecf09f06d9e00e3215a83c9fe31a" translate="yes" xml:space="preserve">
          <source>When running a large set of sequential test cases, checking Coverage after each one can be useful for identifying which test cases exercise new code paths. It is not a replacement for the reports generated by 'go test -cover' and 'go tool cover'.</source>
          <target state="translated">当运行一大堆连续的测试用例时,在每个测试用例之后检查覆盖率对于确定哪些测试用例使用了新的代码路径是很有用的,它不能替代 &quot;go test -cover &quot;和 &quot;go tool cover &quot;生成的报告。它并不能取代 &quot;go test -cover &quot;和 &quot;go tool cover &quot;所生成的报告。</target>
        </trans-unit>
        <trans-unit id="909e63ef88f23df70a053ead84b3a43d68a17641" translate="yes" xml:space="preserve">
          <source>When template execution invokes a function with an argument list, that list must be assignable to the function's parameter types. Functions meant to apply to arguments of arbitrary type can use parameters of type interface{} or of type reflect.Value. Similarly, functions meant to return a result of arbitrary type can return interface{} or reflect.Value.</source>
          <target state="translated">当模板执行调用一个带有参数列表的函数时,该列表必须可以分配给函数的参数类型。用于应用于任意类型的参数的函数可以使用类型为interface{}或类型为reflect.Value的参数,同样,用于返回任意类型的结果的函数也可以返回interface{}或reflect.Value。同样,用于返回任意类型结果的函数可以返回interface{}或reflect.Value。</target>
        </trans-unit>
        <trans-unit id="05dd6446129205c413b187abb37a98c5e685666d" translate="yes" xml:space="preserve">
          <source>When unmarshaling quoted strings, invalid UTF-8 or invalid UTF-16 surrogate pairs are not treated as an error. Instead, they are replaced by the Unicode replacement character U+FFFD.</source>
          <target state="translated">当解开引号字符串时,无效的UTF-8或无效的UTF-16代用对不会被视为错误,而会被U+FFFD替换为Unicode替换字符。相反,它们会被Unicode替换字符U+FFFD取代。</target>
        </trans-unit>
        <trans-unit id="33fa3fdb7bbbbb81e834f8787f2ce9d1e3b0b605" translate="yes" xml:space="preserve">
          <source>When using TCP, and the host in the address parameter resolves to multiple network addresses, any dial timeout (from d.Timeout or ctx) is spread over each consecutive dial, such that each is given an appropriate fraction of the time to connect. For example, if a host has 4 IP addresses and the timeout is 1 minute, the connect to each single address will be given 15 seconds to complete before trying the next one.</source>
          <target state="translated">当使用TCP,并且地址参数中的主机解析到多个网络地址时,任何拨号超时(来自d.Timeout或ctx)都会分散到每个连续的拨号中,这样每个拨号都会获得适当的连接时间分数。例如,如果一个主机有4个IP地址,超时时间是1分钟,那么在尝试下一个地址之前,将给每个单一地址15秒的时间完成连接。</target>
        </trans-unit>
        <trans-unit id="81ad3fb58a9738071410987f567b6f63ba760aad" translate="yes" xml:space="preserve">
          <source>When using the host C library resolver, at most one result will be returned. To bypass the host resolver, use a custom Resolver.</source>
          <target state="translated">当使用主机C库解析器时,最多只能返回一个结果。要绕过主机解析器,请使用自定义解析器。</target>
        </trans-unit>
        <trans-unit id="b6af75ad725ff03ac3899006f586c6815dee0ab6" translate="yes" xml:space="preserve">
          <source>Whether and how a comment is associated with a node depends on the interpretation of the syntax tree by the manipulating program: Except for Doc and Comment comments directly associated with nodes, the remaining comments are &quot;free-floating&quot; (see also issues #18593, #20744).</source>
          <target state="translated">评论是否以及如何与节点关联取决于操作程序对语法树的解释。除了与节点直接相关的Doc和Comment评论外,其余评论都是 &quot;自由浮动的&quot;(另见问题#18593、#20744)。</target>
        </trans-unit>
        <trans-unit id="1761aeba17f1966adf699cab82838ede9543b2ce" translate="yes" xml:space="preserve">
          <source>While it would be correct for the context function to record a complete a stack trace whenever it is called, and simply copy that out in the traceback function, in a typical program the context function will be called many times without ever recording a traceback for that context. Recording a complete stack trace in a call to the context function is likely to be inefficient.</source>
          <target state="translated">虽然每当调用上下文函数时,记录一个完整的堆栈跟踪,并在回溯函数中简单地复制出来是正确的,但在一个典型的程序中,上下文函数会被多次调用,而从未记录过该上下文的回溯。在对上下文函数的调用中记录一个完整的堆栈跟踪很可能是低效的。</target>
        </trans-unit>
        <trans-unit id="97ac8575a01bb9731d0aacbb0c00a32106d3caac" translate="yes" xml:space="preserve">
          <source>While the FileSystem.Open method takes '/'-separated paths, a Dir's string value is a filename on the native file system, not a URL, so it is separated by filepath.Separator, which isn't necessarily '/'.</source>
          <target state="translated">虽然FileSystem.Open方法采用'/'分隔的路径,但Dir的字符串值是原生文件系统中的文件名,而不是URL,所以要用filepath.Separator分隔,不一定是'/'。</target>
        </trans-unit>
        <trans-unit id="7d448d6e99b8642847a099da6f3145e12a69b2bf" translate="yes" xml:space="preserve">
          <source>White space is considered part of a field.</source>
          <target state="translated">白色空间被认为是一个领域的一部分。</target>
        </trans-unit>
        <trans-unit id="3462ed046f134fdadd9007f0e6ba397654359adc" translate="yes" xml:space="preserve">
          <source>Width and precision are measured in units of Unicode code points, that is, runes. (This differs from C's printf where the units are always measured in bytes.) Either or both of the flags may be replaced with the character '*', causing their values to be obtained from the next operand (preceding the one to format), which must be of type int.</source>
          <target state="translated">宽度和精度以Unicode码点为单位,也就是Runes,(这与C语言的printf不同,后者的单位总是以字节为单位)。(这与C语言的printf不同,在printf中,单位总是以字节为单位。)标志中的任何一个或两个都可以用字符'*'代替,从而使它们的值从下一个操作数(在要格式化的操作数之前)获得,而这个操作数的类型必须是int。</target>
        </trans-unit>
        <trans-unit id="285e52d2a4d90abe10ddf2c19e952396f894982a" translate="yes" xml:space="preserve">
          <source>Width is interpreted in the input text but there is no syntax for scanning with a precision (no %5.2f, just %5f). If width is provided, it applies after leading spaces are trimmed and specifies the maximum number of runes to read to satisfy the verb. For example,</source>
          <target state="translated">宽度在输入文本中解释,但没有用精度扫描的语法(没有%5.2f,只有%5f)。如果提供了宽度,则在前导空格被修剪后适用,并指定满足动词的最大读取符文数。例如</target>
        </trans-unit>
        <trans-unit id="798e2836ace5e24780c7dc5d76140278c0905170" translate="yes" xml:space="preserve">
          <source>Width is specified by an optional decimal number immediately preceding the verb. If absent, the width is whatever is necessary to represent the value. Precision is specified after the (optional) width by a period followed by a decimal number. If no period is present, a default precision is used. A period with no following number specifies a precision of zero. Examples:</source>
          <target state="translated">宽度由紧接在动词前的一个可选的十进制数指定。如果没有指定,则宽度为表示数值所需的任何数值。精度是在(可选)宽度之后用一个句号和一个小数来指定的,如果没有句号,则使用默认精度。如果没有句号,则使用默认精度。句号后面没有数字,则表示精度为零。示例。</target>
        </trans-unit>
        <trans-unit id="26d9c28d789c254f71ea99a3463b99a7ccc2f4fa" translate="yes" xml:space="preserve">
          <source>Windows</source>
          <target state="translated">Windows</target>
        </trans-unit>
        <trans-unit id="90527ca0c17e71be4b659b364a4632417bd48fd0" translate="yes" xml:space="preserve">
          <source>With HTTP Basic Authentication the provided username and password are not encrypted.</source>
          <target state="translated">在HTTP基本认证中,所提供的用户名和密码是不加密的。</target>
        </trans-unit>
        <trans-unit id="9c7242429a52b5edef337779ea090fbcc2bb6019" translate="yes" xml:space="preserve">
          <source>With the exceptions of comments, which are skipped if SkipComments is set, unrecognized tokens are not ignored. Instead, the scanner simply returns the respective individual characters (or possibly sub-tokens). For instance, if the mode is ScanIdents (not ScanStrings), the string &quot;foo&quot; is scanned as the token sequence '&quot;' Ident '&quot;'.</source>
          <target state="translated">除了注释(如果设置了SkipComments,则会跳过注释)之外,未识别的标记不会被忽略。相反,扫描仪只会返回各自的单独字符(或可能的子标记)。例如,如果模式是ScanIdents(而不是ScanStrings),字符串 &quot;foo &quot;将被扫描为标记序列'&quot;'。Ident'&quot;'。</target>
        </trans-unit>
        <trans-unit id="cfa2b7a12432ca7dde89800a43beb434b01e3ea5" translate="yes" xml:space="preserve">
          <source>WithCancel</source>
          <target state="translated">WithCancel</target>
        </trans-unit>
        <trans-unit id="10592d7ad2855a7180469ae213405203a2d50e89" translate="yes" xml:space="preserve">
          <source>WithCancel returns a copy of parent with a new Done channel. The returned context's Done channel is closed when the returned cancel function is called or when the parent context's Done channel is closed, whichever happens first.</source>
          <target state="translated">WithCancel返回一个带有新Done通道的父语境副本。当返回的cancel函数被调用或父上下文的Done通道被关闭时,返回的上下文的Done通道被关闭,以先发生的为准。</target>
        </trans-unit>
        <trans-unit id="2261f632aeaf0a3059b969971069ca975c9ce32e" translate="yes" xml:space="preserve">
          <source>WithClientTrace returns a new context based on the provided parent ctx. HTTP client requests made with the returned context will use the provided trace hooks, in addition to any previous hooks registered with ctx. Any hooks defined in the provided trace will be called first.</source>
          <target state="translated">WithClientTrace基于提供的父ctx返回一个新的上下文。使用返回的上下文进行的 HTTP 客户端请求将使用所提供的跟踪钩子,以及之前在 ctx 中注册的任何钩子。任何在所提供的跟踪中定义的钩子将首先被调用。</target>
        </trans-unit>
        <trans-unit id="f1cd36566b14c3bbf36e47b0c1cd6c5053972eb6" translate="yes" xml:space="preserve">
          <source>WithContext returns a shallow copy of r with its context changed to ctx. The provided ctx must be non-nil.</source>
          <target state="translated">WithContext 返回 r 的一个浅层副本,并将其上下文改为 ctx。提供的ctx必须是非零。</target>
        </trans-unit>
        <trans-unit id="c81570667b5d5149acbef6b90b5b11ce74038f5e" translate="yes" xml:space="preserve">
          <source>WithDeadline</source>
          <target state="translated">WithDeadline</target>
        </trans-unit>
        <trans-unit id="4330da7d2b110737e8fe5953a232fb49e41e1165" translate="yes" xml:space="preserve">
          <source>WithDeadline returns a copy of the parent context with the deadline adjusted to be no later than d. If the parent's deadline is already earlier than d, WithDeadline(parent, d) is semantically equivalent to parent. The returned context's Done channel is closed when the deadline expires, when the returned cancel function is called, or when the parent context's Done channel is closed, whichever happens first.</source>
          <target state="translated">WithDeadline返回父上下文的副本,并将截止日期调整为不晚于d。如果父上下文的截止日期已经早于d,WithDeadline(parent,d)在语义上等同于parent。当deadline过期时,当返回的取消函数被调用时,或者当父上下文的Done通道被关闭时,返回的上下文的Done通道被关闭,以先发生的为准。</target>
        </trans-unit>
        <trans-unit id="7a280665a50cba23581e10e39947347ff060fae9" translate="yes" xml:space="preserve">
          <source>WithLabels returns a new context.Context with the given labels added. A label overwrites a prior label with the same key.</source>
          <target state="translated">WithLabels返回一个添加了给定标签的新context.Context。一个标签会覆盖一个相同键的先前标签。</target>
        </trans-unit>
        <trans-unit id="236c68ad351c473bc67a76a1e7d06f3261fc4a99" translate="yes" xml:space="preserve">
          <source>WithNode represents a {{with}} action and its commands.</source>
          <target state="translated">WithNode表示一个{{with}}动作及其命令。</target>
        </trans-unit>
        <trans-unit id="85e6eeaf95e5aa7f5b566d2c8422da42f9a49e6b" translate="yes" xml:space="preserve">
          <source>WithPadding creates a new encoding identical to enc except with a specified padding character, or NoPadding to disable padding. The padding character must not be '\r' or '\n', must not be contained in the encoding's alphabet and must be a rune equal or below '\xff'.</source>
          <target state="translated">WithPadding会创建一个与enc相同的新编码,但会使用指定的填充字符,NoPadding会禁用填充字符。填充字符不能是'\r'或'\n',不能包含在编码的字母表中,并且必须是等于或低于'\xff'的符文。</target>
        </trans-unit>
        <trans-unit id="5778ff939e404ecb571d1f18f70396417807a915" translate="yes" xml:space="preserve">
          <source>WithRegion starts a region associated with its calling goroutine, runs fn, and then ends the region. If the context carries a task, the region is associated with the task. Otherwise, the region is attached to the background task.</source>
          <target state="translated">WithRegion启动一个与其调用的goroutine相关联的区域,运行fn,然后结束该区域。如果上下文携带了一个任务,则该区域与该任务相关联,否则,该区域与后台任务相关联。否则,该区域被附加到后台任务。</target>
        </trans-unit>
        <trans-unit id="62be5942fce8ef05c30b8e260f8696b13a223891" translate="yes" xml:space="preserve">
          <source>WithTimeout</source>
          <target state="translated">WithTimeout</target>
        </trans-unit>
        <trans-unit id="a33c8495b67fd90d2c81864d1a61ba4ce0d40352" translate="yes" xml:space="preserve">
          <source>WithTimeout returns WithDeadline(parent, time.Now().Add(timeout)).</source>
          <target state="translated">WithTimeout 返回 WithDeadline(parent,time.Now().Add(timeout))。</target>
        </trans-unit>
        <trans-unit id="279940ad9c32263d7660d6c51743f4751457b645" translate="yes" xml:space="preserve">
          <source>WithValue</source>
          <target state="translated">WithValue</target>
        </trans-unit>
        <trans-unit id="2898c9db2caddba545b8a166da25b81ca353383a" translate="yes" xml:space="preserve">
          <source>WithValue returns a copy of parent in which the value associated with key is val.</source>
          <target state="translated">WithValue返回父的副本,其中与key相关的值是val。</target>
        </trans-unit>
        <trans-unit id="dfe12e37662d514bcaf6fcc843d9df3dde82c783" translate="yes" xml:space="preserve">
          <source>Within a quoted-field a quote character followed by a second quote character is considered a single quote.</source>
          <target state="translated">在一个引号字段中,一个引号字符后面的第二个引号字符被认为是一个单引号。</target>
        </trans-unit>
        <trans-unit id="901066df97460a79742d81059c2788736730f5c0" translate="yes" xml:space="preserve">
          <source>Within the format string, an underscore _ represents a space that may be replaced by a digit if the following number (a day) has two digits; for compatibility with fixed-width Unix time formats.</source>
          <target state="translated">在格式字符串中,下划线_代表一个空格,如果下面的数字(一天)有两个数字,可以用数字代替;为了与固定宽度的Unix时间格式兼容。</target>
        </trans-unit>
        <trans-unit id="1c2c5d43029917c507b88694188d3a95ec1f427e" translate="yes" xml:space="preserve">
          <source>Within these functions, use the Error, Fail or related methods to signal failure.</source>
          <target state="translated">在这些函数中,使用Error、Fail或相关方法来发出失败信号。</target>
        </trans-unit>
        <trans-unit id="4fb5cfd12779f801d815c760deefde65ff5bc667" translate="yes" xml:space="preserve">
          <source>Without the KeepAlive call, the finalizer could run at the start of syscall.Read, closing the file descriptor before syscall.Read makes the actual system call.</source>
          <target state="translated">如果没有KeepAlive调用,定稿器可以在syscall.Read开始时运行,在syscall.Read进行实际系统调用之前关闭文件描述符。</target>
        </trans-unit>
        <trans-unit id="428a7b20bf173784e9461082a1c6c2949a2b1583" translate="yes" xml:space="preserve">
          <source>WordDecoder.Decode</source>
          <target state="translated">WordDecoder.Decode</target>
        </trans-unit>
        <trans-unit id="122969737c394ec9bcddf4fffdb9da8fe8488ec1" translate="yes" xml:space="preserve">
          <source>WordDecoder.DecodeHeader</source>
          <target state="translated">WordDecoder.DecodeHeader</target>
        </trans-unit>
        <trans-unit id="ca26286ada26b2f279a44ca503bd79bc511af845" translate="yes" xml:space="preserve">
          <source>WordEncoder.Encode</source>
          <target state="translated">WordEncoder.Encode</target>
        </trans-unit>
        <trans-unit id="9edf039575eecbdc47593f3a3127b9885c19c419" translate="yes" xml:space="preserve">
          <source>Wrapper is implemented by types that are backed by a JavaScript value.</source>
          <target state="translated">Wrapper是由JavaScript值支持的类型实现的。</target>
        </trans-unit>
        <trans-unit id="4a48932789d199bbed709777e2d743ca2bafdc6c" translate="yes" xml:space="preserve">
          <source>Write</source>
          <target state="translated">Write</target>
        </trans-unit>
        <trans-unit id="44c42e5743dc2d87774645171aeb25d381fb4f87" translate="yes" xml:space="preserve">
          <source>Write (Multi)</source>
          <target state="translated">写(多)字</target>
        </trans-unit>
        <trans-unit id="5eb828845650151ac0990caac081e2cd286fb917" translate="yes" xml:space="preserve">
          <source>Write appends the contents of p to b's buffer. Write always returns len(p), nil.</source>
          <target state="translated">写将p的内容追加到b的缓冲区。Write总是返回len(p),nil。</target>
        </trans-unit>
        <trans-unit id="b973088870c119f57839cb1ba17bfc298f02ce66" translate="yes" xml:space="preserve">
          <source>Write appends the contents of p to the buffer, growing the buffer as needed. The return value n is the length of p; err is always nil. If the buffer becomes too large, Write will panic with ErrTooLarge.</source>
          <target state="translated">写将p的内容追加到缓冲区,并根据需要增加缓冲区。返回值n是p的长度;err总是nil。如果缓冲区变得太大了,Write会用ErrTooLarge恐慌。</target>
        </trans-unit>
        <trans-unit id="60ad0a48218711b95918ac117d9d0d440fb89fc0" translate="yes" xml:space="preserve">
          <source>Write calls encode to serialize the file set s.</source>
          <target state="translated">写调用encode对文件集s进行序列化。</target>
        </trans-unit>
        <trans-unit id="4d381bda5cffa89f8c78e5e9e48f6d22b0c0fe8a" translate="yes" xml:space="preserve">
          <source>Write encodes p using quoted-printable encoding and writes it to the underlying io.Writer. It limits line length to 76 characters. The encoded bytes are not necessarily flushed until the Writer is closed.</source>
          <target state="translated">Write使用引号可打印编码对p进行编码,并将其写入底层的io.Writer。它将行长限制为76个字符。在关闭Writer之前,编码的字节不一定会被刷新。</target>
        </trans-unit>
        <trans-unit id="abed405f7389701bb0c85514b2f8df63eaba5491" translate="yes" xml:space="preserve">
          <source>Write implements http.ResponseWriter. The data in buf is written to rw.Body, if not nil.</source>
          <target state="translated">Write 实现 http.ResponseWriter。如果不是nil,则将buf中的数据写入rw.Body。</target>
        </trans-unit>
        <trans-unit id="0dd6308ff3bf6bfd3bf539e49da279261acb0c3a" translate="yes" xml:space="preserve">
          <source>Write implements the Conn Write method.</source>
          <target state="translated">Write实现Conn Write方法。</target>
        </trans-unit>
        <trans-unit id="40ae3050f43a58bc383d76e5c6844f88fe681399" translate="yes" xml:space="preserve">
          <source>Write implements the standard Write interface: it writes data to the pipe, blocking until one or more readers have consumed all the data or the read end is closed. If the read end is closed with an error, that err is returned as err; otherwise err is ErrClosedPipe.</source>
          <target state="translated">Write实现了标准的Write接口:它向管道写入数据,阻塞直到一个或多个读取器消耗完所有数据或读取端被关闭。如果读端因错误而关闭,则以err返回;否则err为ErrClosedPipe。</target>
        </trans-unit>
        <trans-unit id="9b4e831d3734f201df9676e633bc0a291038b26a" translate="yes" xml:space="preserve">
          <source>Write sends a log message to the syslog daemon.</source>
          <target state="translated">Write向syslog守护进程发送日志信息。</target>
        </trans-unit>
        <trans-unit id="fcbd0cbe7dbf34b528b9d5e4c3ddbc95f5c5bc1c" translate="yes" xml:space="preserve">
          <source>Write writes a compressed form of p to the underlying io.Writer. The compressed bytes are not necessarily flushed until the Writer is closed or explicitly flushed.</source>
          <target state="translated">Write 将 p 的压缩形式写入底层的 io.Writer。压缩的字节不一定会被刷新,直到Writer被关闭或显式刷新。</target>
        </trans-unit>
        <trans-unit id="df6d5ec5f9e15cdd83d68aca607ef7b43da4dca2" translate="yes" xml:space="preserve">
          <source>Write writes a compressed form of p to the underlying io.Writer. The compressed bytes are not necessarily flushed until the Writer is closed.</source>
          <target state="translated">Write 将 p 的压缩形式写入底层的 io.Writer。压缩后的字节不一定会被刷新,直到Writer关闭。</target>
        </trans-unit>
        <trans-unit id="f5afb6da9a73d93fa35e1f17efdeec955deb05f0" translate="yes" xml:space="preserve">
          <source>Write writes a header in wire format.</source>
          <target state="translated">写入以导线格式写出一个头。</target>
        </trans-unit>
        <trans-unit id="1dd8b6e982bed7434f946dd63ac00a5595f87b17" translate="yes" xml:space="preserve">
          <source>Write writes a request. An ErrPersistEOF error is returned if the connection has been closed in an HTTP keep-alive sense. If req.Close equals true, the keep-alive connection is logically closed after this request and the opposing server is informed. An ErrUnexpectedEOF indicates the remote closed the underlying TCP connection, which is usually considered as graceful close.</source>
          <target state="translated">Write写入一个请求。如果在HTTP keep-alive意义上连接已经关闭,则返回ErrPersistEOF错误。如果req.Close等于true,则在此请求后逻辑上关闭了keep-alive连接,并通知对方服务器。ErrUnexpectedEOF表示远程关闭了底层TCP连接,通常认为是优雅关闭。</target>
        </trans-unit>
        <trans-unit id="c84078d3fc4fa89a2b25f7737991bb090acc5be4" translate="yes" xml:space="preserve">
          <source>Write writes a single CSV record to w along with any necessary quoting. A record is a slice of strings with each string being one field. Writes are buffered, so Flush must eventually be called to ensure that the record is written to the underlying io.Writer.</source>
          <target state="translated">写入将一条CSV记录连同任何必要的引号一起写入w。一个记录是一个字符串的片断,每个字符串是一个字段。写入是有缓冲的,所以最终必须调用Flush来确保记录被写入底层的io.Writer。</target>
        </trans-unit>
        <trans-unit id="1b1f8c7998d40b420b2a6a020d42520c0cfdb552" translate="yes" xml:space="preserve">
          <source>Write writes an HTTP/1.1 request, which is the header and body, in wire format. This method consults the following fields of the request:</source>
          <target state="translated">写以wire格式写一个HTTP/1.1请求,也就是头和体。这个方法会查询请求的以下字段。</target>
        </trans-unit>
        <trans-unit id="0668c9219aeba7077b51b78a1b8f39636f232281" translate="yes" xml:space="preserve">
          <source>Write writes buf to the writer b. The only errors returned are ones encountered while writing to the underlying output stream.</source>
          <target state="translated">将buf写入写入器b,返回的只有在写入底层输出流时遇到的错误。</target>
        </trans-unit>
        <trans-unit id="82a04e0fc25183cb5f9b91509c74fe012f744729" translate="yes" xml:space="preserve">
          <source>Write writes data to the connection.</source>
          <target state="translated">写入将数据写入连接。</target>
        </trans-unit>
        <trans-unit id="ec334dcff7799f1d647716dee3ecbc314693f181" translate="yes" xml:space="preserve">
          <source>Write writes data to w, which will eventually write the compressed form of data to its underlying writer.</source>
          <target state="translated">Write将数据写入w,w最终会将数据的压缩形式写入其底层写入器。</target>
        </trans-unit>
        <trans-unit id="b3b5ffbd7094344c5c64fdfaaee4e1ac8b0d0d73" translate="yes" xml:space="preserve">
          <source>Write writes len(b) bytes to the File. It returns the number of bytes written and an error, if any. Write returns a non-nil error when n != len(b).</source>
          <target state="translated">Write 向文件写入 len(b)字节。如果有错误,它将返回写入的字节数和一个错误。当n !=len(b)时,Write返回一个非零错误。</target>
        </trans-unit>
        <trans-unit id="bc6f468fb42c60c9aa3d3403f67792ca68e56337" translate="yes" xml:space="preserve">
          <source>Write writes len(p) bytes from p to the underlying data stream. It returns the number of bytes written from p (0 &amp;lt;= n &amp;lt;= len(p)) and any error encountered that caused the write to stop early. Write must return a non-nil error if it returns n &amp;lt; len(p). Write must not modify the slice data, even temporarily.</source>
          <target state="translated">Write将len中的len（p）个字节从p写入基础数据流。它返回从p（0 &amp;lt;= n &amp;lt;= len（p））写入的字节数，以及遇到的任何导致写入提前停止的错误。如果写入返回n &amp;lt;len（p），则必须返回一个非nil错误。写操作不得修改切片数据，即使是临时的。</target>
        </trans-unit>
        <trans-unit id="8d63636955bd89c2cf8a7af170c604cdce197b80" translate="yes" xml:space="preserve">
          <source>Write writes r to w in the HTTP/1.x server response format, including the status line, headers, body, and optional trailer.</source>
          <target state="translated">以HTTP/1.x服务器响应格式将r写入w,包括状态行、头文件、正文和可选的预告片。</target>
        </trans-unit>
        <trans-unit id="540dcdd5a6a217068d019b75b00fcd61e7a04d31" translate="yes" xml:space="preserve">
          <source>Write writes resp in response to req. To close the connection gracefully, set the Response.Close field to true. Write should be considered operational until it returns an error, regardless of any errors returned on the Read side.</source>
          <target state="translated">写入响应req的resps。要优雅地关闭连接,请将Response.Close字段设置为true。写入在返回错误之前应该被认为是可操作的,不管Read端是否有任何错误返回。</target>
        </trans-unit>
        <trans-unit id="67e15dd48b8a4dfa3a0d9587fc9c9c38dda0a150" translate="yes" xml:space="preserve">
          <source>Write writes the binary representation of data into w. Data must be a fixed-size value or a slice of fixed-size values, or a pointer to such data. Boolean values encode as one byte: 1 for true, and 0 for false. Bytes written to w are encoded using the specified byte order and read from successive fields of the data. When writing structs, zero values are written for fields with blank (_) field names.</source>
          <target state="translated">写入将数据的二进制表示写入w中。数据必须是一个固定大小的值或一个固定大小的值的片断,或者是一个指向这些数据的指针。布尔值编码为一个字节:1代表真,0代表假。写入w的字节使用指定的字节顺序进行编码,并从数据的连续字段中读取。当写入结构时,对于带有空白(_)字段名的字段,会写入零值。</target>
        </trans-unit>
        <trans-unit id="1aedca15daa2824cc7a6db34a6e59e022ccdde6b" translate="yes" xml:space="preserve">
          <source>Write writes the contents of p into the buffer. It returns the number of bytes written. If nn &amp;lt; len(p), it also returns an error explaining why the write is short.</source>
          <target state="translated">写操作将p的内容写入缓冲区。它返回写入的字节数。如果nn &amp;lt;len（p），它还会返回一个错误，解释为什么写时间短。</target>
        </trans-unit>
        <trans-unit id="979c6b0be612eaeecc0a5795d58b592f39b6a7cc" translate="yes" xml:space="preserve">
          <source>Write writes the index x to w.</source>
          <target state="translated">写将索引x写入w。</target>
        </trans-unit>
        <trans-unit id="4bb1c277541d19952bb3d44e887bd82c7760bdb9" translate="yes" xml:space="preserve">
          <source>Write writes to the current file in the tar archive. Write returns the error ErrWriteTooLong if more than Header.Size bytes are written after WriteHeader.</source>
          <target state="translated">Write 向 tar 存档中的当前文件写入。如果在WriteHeader之后写入的字节数超过Header.Size,Write将返回错误ErrWriteTooLong。</target>
        </trans-unit>
        <trans-unit id="0224fd253898a9aef4ac0177d7201684f5813e08" translate="yes" xml:space="preserve">
          <source>WriteAll writes multiple CSV records to w using Write and then calls Flush, returning any error from the Flush.</source>
          <target state="translated">WriteAll使用Write向w写入多条CSV记录,然后调用Flush,返回Flush的任何错误。</target>
        </trans-unit>
        <trans-unit id="577d19fec1f13e0c1b297c086a7a9e7aaffc9552" translate="yes" xml:space="preserve">
          <source>WriteAt writes len(b) bytes to the File starting at byte offset off. It returns the number of bytes written and an error, if any. WriteAt returns a non-nil error when n != len(b).</source>
          <target state="translated">WriteAt从字节偏移off开始向文件写入len(b)字节。如果有错误,它将返回写入的字节数和一个错误。当n !=len(b)时,WriteAt返回一个非零错误。</target>
        </trans-unit>
        <trans-unit id="913c43952e7ba95faf4dd01c5c3386903926e88f" translate="yes" xml:space="preserve">
          <source>WriteAt writes len(p) bytes from p to the underlying data stream at offset off. It returns the number of bytes written from p (0 &amp;lt;= n &amp;lt;= len(p)) and any error encountered that caused the write to stop early. WriteAt must return a non-nil error if it returns n &amp;lt; len(p).</source>
          <target state="translated">WriteAt将偏移量为off的len（p）个字节从p写入基础数据流。它返回从p（0 &amp;lt;= n &amp;lt;= len（p））写入的字节数，以及遇到的任何导致写入提前停止的错误。如果WriteAt返回n &amp;lt;len（p），则必须返回非nil错误。</target>
        </trans-unit>
        <trans-unit id="299aad410b1c59608b367a7d4cb870a456df8096" translate="yes" xml:space="preserve">
          <source>WriteByte appends the byte c to b's buffer. The returned error is always nil.</source>
          <target state="translated">WriteByte将字节c追加到b的缓冲区。返回的错误总是nil。</target>
        </trans-unit>
        <trans-unit id="f1124aa2cccac4bc8c094488b7bc39b62c0cdd5a" translate="yes" xml:space="preserve">
          <source>WriteByte appends the byte c to the buffer, growing the buffer as needed. The returned error is always nil, but is included to match bufio.Writer's WriteByte. If the buffer becomes too large, WriteByte will panic with ErrTooLarge.</source>
          <target state="translated">WriteByte将字节c追加到缓冲区,根据需要增长缓冲区。返回的错误总是nil,但被包含在bufio.Writer的WriteByte中。如果缓冲区变得太大了,WriteByte会用ErrTooLarge恐慌。</target>
        </trans-unit>
        <trans-unit id="709e9a78ca951be47b51eaa8c43161a4a68b13de" translate="yes" xml:space="preserve">
          <source>WriteByte writes a single byte.</source>
          <target state="translated">WriteByte 写入单个字节。</target>
        </trans-unit>
        <trans-unit id="b0fa0c9c90b10c53cd3030a178df8c5bc4b748e3" translate="yes" xml:space="preserve">
          <source>WriteCloser is the interface that groups the basic Write and Close methods.</source>
          <target state="translated">WriteCloser是一个接口,它将基本的写入和关闭方法分组。</target>
        </trans-unit>
        <trans-unit id="a5b4dc8d0bfd74b6d0a363e79ed44899e4d10a7a" translate="yes" xml:space="preserve">
          <source>WriteExpr writes the (possibly shortened) string representation for x to buf. Shortened representations are suitable for user interfaces but may not necessarily follow Go syntax.</source>
          <target state="translated">WriteExpr将x的字符串表示法(可能是缩短的)写入buf。简化后的表示方式适用于用户界面,但不一定遵循Go语法。</target>
        </trans-unit>
        <trans-unit id="a2fc53b6ae37f84446440bfa3e46d55b1daae44f" translate="yes" xml:space="preserve">
          <source>WriteField calls CreateFormField and then writes the given value.</source>
          <target state="translated">WriteField调用CreateFormField,然后写入给定的值。</target>
        </trans-unit>
        <trans-unit id="94dee2fafe1d10d5ce6db659eb0c0fcb3d5842be" translate="yes" xml:space="preserve">
          <source>WriteFile</source>
          <target state="translated">WriteFile</target>
        </trans-unit>
        <trans-unit id="f1a08dac7451fee22a938f078c0cf3128fd334ab" translate="yes" xml:space="preserve">
          <source>WriteFile writes data to a file named by filename. If the file does not exist, WriteFile creates it with permissions perm (before umask); otherwise WriteFile truncates it before writing, without changing permissions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef73f34a1517d5e481c55ca7ffbc2a25494b2019" translate="yes" xml:space="preserve">
          <source>WriteFile writes data to a file named by filename. If the file does not exist, WriteFile creates it with permissions perm; otherwise WriteFile truncates it before writing.</source>
          <target state="translated">WriteFile 将数据写入一个以 filename 命名的文件。如果文件不存在,WriteFile会以perm的权限创建它;否则WriteFile会在写入前截断它。</target>
        </trans-unit>
        <trans-unit id="966a2c28275a12b7d85d4ef9e4fb4bdd7daf03b9" translate="yes" xml:space="preserve">
          <source>WriteHeader implements http.ResponseWriter.</source>
          <target state="translated">WriteHeader实现了http.ResponseWriter.WriteHeader。</target>
        </trans-unit>
        <trans-unit id="5278a175f457ff599653e584e10d0da21d75e04a" translate="yes" xml:space="preserve">
          <source>WriteHeader writes hdr and prepares to accept the file's contents. The Header.Size determines how many bytes can be written for the next file. If the current file is not fully written, then this returns an error. This implicitly flushes any padding necessary before writing the header.</source>
          <target state="translated">WriteHeader 写入 hdr 并准备接受文件的内容。Header.Size决定了下一个文件可以写入多少字节。如果当前文件没有被完全写入,那么将返回一个错误。在写入头之前,这将隐式地刷新任何必要的填充。</target>
        </trans-unit>
        <trans-unit id="3ca8ba0518cad3338405c38e79e75e9c13b24b43" translate="yes" xml:space="preserve">
          <source>WriteHeapDump suspends the execution of all goroutines until the heap dump is completely written. Thus, the file descriptor must not be connected to a pipe or socket whose other end is in the same Go process; instead, use a temporary file or network socket.</source>
          <target state="translated">WriteHeapDump会暂停所有goroutine的执行,直到堆转储被完全写入。因此,文件描述符不能连接到一个管道或套接字上,其另一端在同一个Go进程中;而是使用一个临时文件或网络套接字。</target>
        </trans-unit>
        <trans-unit id="6a06afdd85eafc1200fe0ffc3dbde0309767d7ac" translate="yes" xml:space="preserve">
          <source>WriteHeapDump writes a description of the heap and the objects in it to the given file descriptor.</source>
          <target state="translated">WriteHeapDump将堆和堆中对象的描述写入给定的文件描述符。</target>
        </trans-unit>
        <trans-unit id="e3abbd24fb479c9ecfc16a57b4a2dfe1f2c03f20" translate="yes" xml:space="preserve">
          <source>WriteHeapProfile is shorthand for Lookup(&quot;heap&quot;).WriteTo(w, 0). It is preserved for backwards compatibility.</source>
          <target state="translated">WriteHeapProfile是Lookup(&quot;堆&quot;).WriteTo(w,0)的简写。它的保留是为了向后兼容。</target>
        </trans-unit>
        <trans-unit id="60029a6d43efd94d3594516e2528881eb15af008" translate="yes" xml:space="preserve">
          <source>WriteMsgIP writes a message to addr via c, copying the payload from b and the associated out-of-band data from oob. It returns the number of payload and out-of-band bytes written.</source>
          <target state="translated">WriteMsgIP通过c向addr写入一条消息,从b复制有效载荷,从ob复制相关的带外数据。它返回写入的有效载荷和带外字节数。</target>
        </trans-unit>
        <trans-unit id="97f4683eac3d5fc32a65061e292f2190af0bf38c" translate="yes" xml:space="preserve">
          <source>WriteMsgUDP writes a message to addr via c if c isn't connected, or to c's remote address if c is connected (in which case addr must be nil). The payload is copied from b and the associated out-of-band data is copied from oob. It returns the number of payload and out-of-band bytes written.</source>
          <target state="translated">WriteMsgUDP在c没有连接的情况下通过c向addr写消息,如果c连接了则向c的远程地址写消息(在这种情况下addr必须是nil)。有效载荷从b复制,相关的带外数据从ob复制。它返回写入的有效载荷和带外数据的字节数。</target>
        </trans-unit>
        <trans-unit id="8193c21ac5c2ea950e2bde14d77250380df04e5a" translate="yes" xml:space="preserve">
          <source>WriteMsgUnix writes a message to addr via c, copying the payload from b and the associated out-of-band data from oob. It returns the number of payload and out-of-band bytes written.</source>
          <target state="translated">WriteMsgUnix通过c向addr写入一条消息,从b复制有效载荷,从ob复制相关的带外数据。它返回写入的有效载荷和带外字节数。</target>
        </trans-unit>
        <trans-unit id="05a4cbe90da51b5a60d7ce652f38c76395d34c38" translate="yes" xml:space="preserve">
          <source>WriteProxy is like Write but writes the request in the form expected by an HTTP proxy. In particular, WriteProxy writes the initial Request-URI line of the request with an absolute URI, per section 5.3 of RFC 7230, including the scheme and host. In either case, WriteProxy also writes a Host header, using either r.Host or r.URL.Host.</source>
          <target state="translated">WriteProxy和Write一样,但是以HTTP代理所期望的形式写入请求。特别是,WriteProxy根据RFC 7230的第5.3节,用绝对URI来写入请求的初始Request-URI行,包括scheme和host。在这两种情况下,WriteProxy也会使用r.Host或r.URL.Host来写一个Host头。</target>
        </trans-unit>
        <trans-unit id="c69fd535ec2a61d9f0cd55c49694d03e060751bc" translate="yes" xml:space="preserve">
          <source>WriteRune appends the UTF-8 encoding of Unicode code point r to b's buffer. It returns the length of r and a nil error.</source>
          <target state="translated">WriteRune将Unicode码点r的UTF-8编码附加到b的缓冲区。它返回r的长度和一个nil错误。</target>
        </trans-unit>
        <trans-unit id="50419d360e1454c08d1e726980bb9af5c883fdf2" translate="yes" xml:space="preserve">
          <source>WriteRune appends the UTF-8 encoding of Unicode code point r to the buffer, returning its length and an error, which is always nil but is included to match bufio.Writer's WriteRune. The buffer is grown as needed; if it becomes too large, WriteRune will panic with ErrTooLarge.</source>
          <target state="translated">WriteRune将Unicode码点r的UTF-8编码附加到缓冲区,返回其长度和一个错误,这个错误总是nil,但包含在bufio.Writer的WriteRune中。缓冲区会根据需要增长;如果缓冲区变得过大,WriteRune会用ErrTooLarge恐慌。</target>
        </trans-unit>
        <trans-unit id="8539205ffda07e4fc93063bbff49ea5a24bdfb57" translate="yes" xml:space="preserve">
          <source>WriteRune writes a single Unicode code point, returning the number of bytes written and any error.</source>
          <target state="translated">WriteRune写入一个Unicode码点,返回写入的字节数和任何错误。</target>
        </trans-unit>
        <trans-unit id="c4cdb9aa52cc1444def4915c41a6238a5b9dce01" translate="yes" xml:space="preserve">
          <source>WriteSeeker is the interface that groups the basic Write and Seek methods.</source>
          <target state="translated">WriteSeeker是将基本的Write和Seek方法分组的接口。</target>
        </trans-unit>
        <trans-unit id="4c4e530f7fc3720d0a0b9dd1699773a51975bcd0" translate="yes" xml:space="preserve">
          <source>WriteSignature writes the representation of the signature sig to buf, without a leading &quot;func&quot; keyword. The Qualifier controls the printing of package-level objects, and may be nil.</source>
          <target state="translated">WriteSignature 将签名的表示方式 sig 写入 buf,不使用前导的 &quot;func &quot;关键字。限定符控制打印包级对象,可以为零。</target>
        </trans-unit>
        <trans-unit id="2fafa28d75b28a484b0d11704a5f73dc2a397a9b" translate="yes" xml:space="preserve">
          <source>WriteString</source>
          <target state="translated">WriteString</target>
        </trans-unit>
        <trans-unit id="dcea71a3d2530b8c16e73859a42e5c1339cc7b3a" translate="yes" xml:space="preserve">
          <source>WriteString appends the contents of s to b's buffer. It returns the length of s and a nil error.</source>
          <target state="translated">WriteString将s的内容追加到b的缓冲区。它返回s的长度和一个nil错误。</target>
        </trans-unit>
        <trans-unit id="f0863225004b8002965c5f1f30cabf45ec0ce003" translate="yes" xml:space="preserve">
          <source>WriteString appends the contents of s to the buffer, growing the buffer as needed. The return value n is the length of s; err is always nil. If the buffer becomes too large, WriteString will panic with ErrTooLarge.</source>
          <target state="translated">WriteString将s的内容追加到缓冲区,并根据需要增加缓冲区。返回值n是s的长度;err总是nil。如果缓冲区变得过大,WriteString会用ErrTooLarge恐慌。</target>
        </trans-unit>
        <trans-unit id="5906492d4ad1f77da2e42a5903d5b14910e74bdc" translate="yes" xml:space="preserve">
          <source>WriteString implements io.StringWriter. The data in str is written to rw.Body, if not nil.</source>
          <target state="translated">WriteString实现了io.StringWriter.WriteString的功能。如果不为nil,str中的数据将被写入rw.Body。</target>
        </trans-unit>
        <trans-unit id="2881565b760b26a4f8a2f57e00f09267df1fc3c7" translate="yes" xml:space="preserve">
          <source>WriteString is like Write, but writes the contents of string s rather than a slice of bytes.</source>
          <target state="translated">WriteString和Write一样,但写的是字符串s的内容,而不是字节的片断。</target>
        </trans-unit>
        <trans-unit id="5e86374df4dcf5990aedc6d23a06ec17779ecb41" translate="yes" xml:space="preserve">
          <source>WriteString writes a string. It returns the number of bytes written. If the count is less than len(s), it also returns an error explaining why the write is short.</source>
          <target state="translated">WriteString 写入一个字符串。它返回写入的字节数。如果写入的字节数小于len(s),它还会返回一个错误,解释为什么写入的字节数很短。</target>
        </trans-unit>
        <trans-unit id="b06770a08018ebad1f55b3701993d6f12040309c" translate="yes" xml:space="preserve">
          <source>WriteString writes s to w with all replacements performed.</source>
          <target state="translated">WriteString将s写入w,并进行全部替换。</target>
        </trans-unit>
        <trans-unit id="269915f1206072ee8dbb37610e3b9dfdc6260f9a" translate="yes" xml:space="preserve">
          <source>WriteString writes the contents of the string s to w, which accepts a slice of bytes. If w implements StringWriter, its WriteString method is invoked directly. Otherwise, w.Write is called exactly once.</source>
          <target state="translated">WriteString将字符串s的内容写入w,w接受一个字节片。如果w实现了StringWriter,则直接调用它的WriteString方法。否则,w.Write会被准确地调用一次。</target>
        </trans-unit>
        <trans-unit id="14e283952e32e7284849c90772991995a0d08383" translate="yes" xml:space="preserve">
          <source>WriteSubset writes a header in wire format. If exclude is not nil, keys where exclude[key] == true are not written.</source>
          <target state="translated">WriteSubset以wire格式写入一个头。如果exclude不是nil,那么exclude[key]==true的键不会被写入。</target>
        </trans-unit>
        <trans-unit id="d674cf2f9ed846b78f239ed6b5be115ab29ab2d6" translate="yes" xml:space="preserve">
          <source>WriteSubset writes a header in wire format. If exclude is not nil, keys where exclude[key] == true are not written. Keys are not canonicalized before checking the exclude map.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="049d63dec358580d0ec0653e5b3c153d3b077135" translate="yes" xml:space="preserve">
          <source>WriteTo implements io.WriterTo. This may make multiple calls to the Read method of the underlying Reader. If the underlying reader supports the WriteTo method, this calls the underlying WriteTo without buffering.</source>
          <target state="translated">WriteTo实现了io.WriterTo.Read方法。这可能会对底层阅读器的Read方法进行多次调用。如果底层阅读器支持WriteTo方法,则会调用底层的WriteTo,而不需要缓冲。</target>
        </trans-unit>
        <trans-unit id="8139263f4318d7564d44a96fc8dbff5e63bb96fd" translate="yes" xml:space="preserve">
          <source>WriteTo implements the PacketConn WriteTo method.</source>
          <target state="translated">WriteTo实现PacketConn WriteTo方法。</target>
        </trans-unit>
        <trans-unit id="1dd6cb0fb603b3372044d7453914baf64dbeabc3" translate="yes" xml:space="preserve">
          <source>WriteTo implements the io.WriterTo interface.</source>
          <target state="translated">WriteTo实现了io.WriterTo接口。</target>
        </trans-unit>
        <trans-unit id="8c7bb5378a7a840f064c83d707986b7492eb31e2" translate="yes" xml:space="preserve">
          <source>WriteTo writes a pprof-formatted snapshot of the profile to w. If a write to w returns an error, WriteTo returns that error. Otherwise, WriteTo returns nil.</source>
          <target state="translated">WriteTo 将配置文件的 pprof 格式化快照写入 w,如果写入 w 时返回一个错误,WriteTo 将返回该错误。否则,WriteTo返回nil。</target>
        </trans-unit>
        <trans-unit id="489e07f5de5485be9543961aadd05292560f9aca" translate="yes" xml:space="preserve">
          <source>WriteTo writes a string representation of the scope to w, with the scope elements sorted by name. The level of indentation is controlled by n &amp;gt;= 0, with n == 0 for no indentation. If recurse is set, it also writes nested (children) scopes.</source>
          <target state="translated">WriteTo将范围的字符串表示形式写入w，范围元素按名称排序。压痕级别由n&amp;gt; = 0控制，其中n == 0表示无压痕。如果设置了递归，它还将写入嵌套（子级）作用域。</target>
        </trans-unit>
        <trans-unit id="d1e7dcb553ab192fce6fd288394665a1afcd3f5c" translate="yes" xml:space="preserve">
          <source>WriteTo writes data to w until the buffer is drained or an error occurs. The return value n is the number of bytes written; it always fits into an int, but it is int64 to match the io.WriterTo interface. Any error encountered during the write is also returned.</source>
          <target state="translated">WriteTo向w写入数据,直到缓冲区耗尽或发生错误。返回值n是写入的字节数;它总是适合于一个int,但它是int64,以匹配io.WriterTo接口。写入过程中遇到的任何错误也会被返回。</target>
        </trans-unit>
        <trans-unit id="675b06c215e20183689acb9dd6a02dde0ececcfe" translate="yes" xml:space="preserve">
          <source>WriteTo writes data to w until there's no more data to write or when an error occurs. The return value n is the number of bytes written. Any error encountered during the write is also returned.</source>
          <target state="translated">WriteTo将数据写入w,直到没有数据可写或发生错误。返回值n是写入的字节数。写入过程中遇到的任何错误也会被返回。</target>
        </trans-unit>
        <trans-unit id="16524feb66448f891798c4e2c2b003dede383877" translate="yes" xml:space="preserve">
          <source>WriteToIP acts like WriteTo but takes an IPAddr.</source>
          <target state="translated">WriteToIP的作用类似于WriteTo,但需要一个IPAddr。</target>
        </trans-unit>
        <trans-unit id="5439ba90be07d98d78a0acbb16e701c88430c920" translate="yes" xml:space="preserve">
          <source>WriteToUDP acts like WriteTo but takes a UDPAddr.</source>
          <target state="translated">WriteToUDP的作用类似于WriteTo,但需要一个UDPAddr。</target>
        </trans-unit>
        <trans-unit id="70bfc7011539dc3fcd8cb976e79375745c81efb6" translate="yes" xml:space="preserve">
          <source>WriteToUnix acts like WriteTo but takes a UnixAddr.</source>
          <target state="translated">WriteToUnix的作用类似于WriteTo,但需要一个UnixAddr。</target>
        </trans-unit>
        <trans-unit id="bf93ade9d0116866c9989c0d6db8fe0a1790197b" translate="yes" xml:space="preserve">
          <source>WriteType writes the string representation of typ to buf. The Qualifier controls the printing of package-level objects, and may be nil.</source>
          <target state="translated">WriteType 将 typ 的字符串表示写入 buf。Qualifier控制包级对象的打印,可以为零。</target>
        </trans-unit>
        <trans-unit id="5f435830a7c07f19c4072a88821b38028c3f69e6" translate="yes" xml:space="preserve">
          <source>Writer</source>
          <target state="translated">Writer</target>
        </trans-unit>
        <trans-unit id="27739d4166f1a372ecad9e26dae552acbbf96378" translate="yes" xml:space="preserve">
          <source>Writer implements a zip file writer.</source>
          <target state="translated">Writer实现了一个zip文件写入器。</target>
        </trans-unit>
        <trans-unit id="0a56b3c1ebc71cca6811d5ea42cfcd61b9d39529" translate="yes" xml:space="preserve">
          <source>Writer implements buffering for an io.Writer object. If an error occurs writing to a Writer, no more data will be accepted and all subsequent writes, and Flush, will return the error. After all data has been written, the client should call the Flush method to guarantee all data has been forwarded to the underlying io.Writer.</source>
          <target state="translated">Writer实现了对io.Writer对象的缓冲。如果向Writer写入时发生错误,将不再接受数据,所有后续的写入以及Flush都将返回错误。在所有数据被写入后,客户端应该调用Flush方法来保证所有数据都被转发到底层的io.Writer。</target>
        </trans-unit>
        <trans-unit id="ef9d03832983cf4b271bb5441f954111b4dc0e1e" translate="yes" xml:space="preserve">
          <source>Writer is the interface that wraps the basic Write method.</source>
          <target state="translated">Writer是包装基本Write方法的接口。</target>
        </trans-unit>
        <trans-unit id="427cfe70a00ca8d321faf6329909145b93655f1d" translate="yes" xml:space="preserve">
          <source>Writer provides sequential writing of a tar archive. Write.WriteHeader begins a new file with the provided Header, and then Writer can be treated as an io.Writer to supply that file's data.</source>
          <target state="translated">Writer 提供了对 tar 存档的顺序写入。Write.WriteHeader用提供的Header开始一个新文件,然后Writer可以被当作io.Writer来提供该文件的数据。</target>
        </trans-unit>
        <trans-unit id="7acd853acb07fa87c4b8bfe4031a755b61ba3bf3" translate="yes" xml:space="preserve">
          <source>Writer returns the output destination for the logger.</source>
          <target state="translated">Writer 返回记录器的输出目的地。</target>
        </trans-unit>
        <trans-unit id="3d5fe142bef0cbbd3b816be820156528e0933482" translate="yes" xml:space="preserve">
          <source>Writer returns the output destination for the standard logger.</source>
          <target state="translated">Writer 返回标准记录器的输出目的地。</target>
        </trans-unit>
        <trans-unit id="cc5f6bbc6d4441180bb267f283d2d032dc1c0a51" translate="yes" xml:space="preserve">
          <source>Writer, to write dot-encoded text blocks.</source>
          <target state="translated">Writer,用来编写点阵文字块。</target>
        </trans-unit>
        <trans-unit id="18f7957bfe6eb1c4e6c6911f16343b2aefa987f8" translate="yes" xml:space="preserve">
          <source>Writer.Init</source>
          <target state="translated">Writer.Init</target>
        </trans-unit>
        <trans-unit id="c077ca30988f9da9fa06bdada12777468be255fd" translate="yes" xml:space="preserve">
          <source>Writer.RegisterCompressor</source>
          <target state="translated">Writer.RegisterCompressor</target>
        </trans-unit>
        <trans-unit id="52b3549fe3dc7eeb9e682e0957e12c6a11a932c4" translate="yes" xml:space="preserve">
          <source>Writer.WriteAll</source>
          <target state="translated">Writer.WriteAll</target>
        </trans-unit>
        <trans-unit id="aeee2e0685aa932cc2aaeffa26f77224718c1152" translate="yes" xml:space="preserve">
          <source>WriterAt is the interface that wraps the basic WriteAt method.</source>
          <target state="translated">WriterAt是包装基本WriteAt方法的接口。</target>
        </trans-unit>
        <trans-unit id="8ab71dde8a6f8d04cee549ea8541c77aaebdcab8" translate="yes" xml:space="preserve">
          <source>WriterTo is the interface that wraps the WriteTo method.</source>
          <target state="translated">WriterTo是封装WriteTo方法的接口。</target>
        </trans-unit>
        <trans-unit id="1b39f0e4afe7201d767e5fbbce52d4c2e5b87a3a" translate="yes" xml:space="preserve">
          <source>WroteRequestInfo contains information provided to the WroteRequest hook.</source>
          <target state="translated">WroteRequestInfo包含提供给WroteRequest钩子的信息。</target>
        </trans-unit>
        <trans-unit id="127aef9b4a6638a4da9d60eee45faca81817967a" translate="yes" xml:space="preserve">
          <source>X509KeyPair</source>
          <target state="translated">X509KeyPair</target>
        </trans-unit>
        <trans-unit id="512f6338fce5f83658ade589125789680e0a180a" translate="yes" xml:space="preserve">
          <source>X509KeyPair (HttpServer)</source>
          <target state="translated">X509KeyPair (HttpServer)</target>
        </trans-unit>
        <trans-unit id="eb6cfabefa86cc7130f0ceaa6c99558292a8fb32" translate="yes" xml:space="preserve">
          <source>X509KeyPair parses a public/private key pair from a pair of PEM encoded data. On successful return, Certificate.Leaf will be nil because the parsed form of the certificate is not retained.</source>
          <target state="translated">X509KeyPair 从一对 PEM 编码数据中解析出一个公钥/私钥对。成功返回后,Certificate.Leaf将为零,因为证书的解析形式不会被保留。</target>
        </trans-unit>
        <trans-unit id="db992a4f131e511a8d9ce5936d82355a68509183" translate="yes" xml:space="preserve">
          <source>XORKeyStream sets dst to the result of XORing src with the key stream. Dst and src must overlap entirely or not at all.</source>
          <target state="translated">XORKeyStream 将 dst 设置为 XORing src 与密钥流的结果。Dst和src必须完全重合或完全不重合。</target>
        </trans-unit>
        <trans-unit id="63c6c5be8d1c945e475df745ac44a459209b8818" translate="yes" xml:space="preserve">
          <source>Xor sets z = x ^ y and returns z.</source>
          <target state="translated">Xor设z=x ^ y并返回z。</target>
        </trans-unit>
        <trans-unit id="b579a9d9b11366f490071fb238c298157a4151d9" translate="yes" xml:space="preserve">
          <source>Y0 returns the order-zero Bessel function of the second kind.</source>
          <target state="translated">Y0返回第二种类型的零阶贝塞尔函数。</target>
        </trans-unit>
        <trans-unit id="e0b0a19d715ece09aeb410f412b0c7d445934330" translate="yes" xml:space="preserve">
          <source>Y1 returns the order-one Bessel function of the second kind.</source>
          <target state="translated">Y1返回第二种类型的阶一贝塞尔函数。</target>
        </trans-unit>
        <trans-unit id="993c29f2dccf3899bcb16c0c3c3e58cbb4ff26a3" translate="yes" xml:space="preserve">
          <source>YCbCr is an in-memory image of Y'CbCr colors. There is one Y sample per pixel, but each Cb and Cr sample can span one or more pixels. YStride is the Y slice index delta between vertically adjacent pixels. CStride is the Cb and Cr slice index delta between vertically adjacent pixels that map to separate chroma samples. It is not an absolute requirement, but YStride and len(Y) are typically multiples of 8, and:</source>
          <target state="translated">YCbCr是Y'CbCr颜色的内存图像。每个像素有一个Y样本,但每个Cb和Cr样本可以跨越一个或多个像素。YStride是垂直相邻像素之间的Y片指数delta。CStride是垂直相邻像素之间的Cb和Cr片断指数delta,它们映射到单独的色度样本。这不是一个绝对的要求,但YStride和len(Y)通常是8的倍数,并且。</target>
        </trans-unit>
        <trans-unit id="04b6d1d571fb2541a796ccff17941677d6e94116" translate="yes" xml:space="preserve">
          <source>YCbCr represents a fully opaque 24-bit Y'CbCr color, having 8 bits each for one luma and two chroma components.</source>
          <target state="translated">YCbCr表示一个完全不透明的24位Y'CbCr颜色,有8位分别代表一个luma和两个chroma成分。</target>
        </trans-unit>
        <trans-unit id="569302883a982b6ecca1dff87d53f57a317c9e3e" translate="yes" xml:space="preserve">
          <source>YCbCrModel is the Model for Y'CbCr colors.</source>
          <target state="translated">YCbCrModel是Y'CbCr颜色的模型。</target>
        </trans-unit>
        <trans-unit id="c3eb9b9a99d34d53e98e4c42a8f496bcc27b2dd4" translate="yes" xml:space="preserve">
          <source>YCbCrSubsampleRatio is the chroma subsample ratio used in a YCbCr image.</source>
          <target state="translated">YCbCrSubsampleRatio是YCbCr图像中使用的色度子样本比。</target>
        </trans-unit>
        <trans-unit id="7c2a18a269291c4a568eeda22c7b8012ba05d3cc" translate="yes" xml:space="preserve">
          <source>YCbCrToRGB converts a Y'CbCr triple to an RGB triple.</source>
          <target state="translated">YCbCrToRGB将Y'CbCr三元组转换为RGB三元组。</target>
        </trans-unit>
        <trans-unit id="2cc85e17988c35ca87fe9396bebb3408abc4139c" translate="yes" xml:space="preserve">
          <source>YOffset returns the index of the first element of Y that corresponds to the pixel at (x, y).</source>
          <target state="translated">YOffset返回Y中对应于(x,y)像素的第一个元素的索引。</target>
        </trans-unit>
        <trans-unit id="0ae67455f11e2f617f0f533036db82246ea0f1ba" translate="yes" xml:space="preserve">
          <source>Year returns the year in which t occurs.</source>
          <target state="translated">Year返回t发生的年份。</target>
        </trans-unit>
        <trans-unit id="a0e093613a2a058d01beb5d9e83df474d4a7948e" translate="yes" xml:space="preserve">
          <source>YearDay returns the day of the year specified by t, in the range [1,365] for non-leap years, and [1,366] in leap years.</source>
          <target state="translated">YearDay 返回 t 指定的一年中的某一天,对于非闰年来说,范围为 [1,365],对于闰年来说,范围为 [1,366]。</target>
        </trans-unit>
        <trans-unit id="fbc86f73dd0143c109fc555dff3f9f4721e59b11" translate="yes" xml:space="preserve">
          <source>Yn returns the order-n Bessel function of the second kind.</source>
          <target state="translated">Yn 返回第二种类型的阶-n Bessel 函数。</target>
        </trans-unit>
        <trans-unit id="1e7f3945f480c58bbf5b45878f32cae6f3cbe3e1" translate="yes" xml:space="preserve">
          <source>ZP is the zero Point.</source>
          <target state="translated">ZP是零点。</target>
        </trans-unit>
        <trans-unit id="4bedd2eb81ef394e3788fa98b69d1ca4f77655ed" translate="yes" xml:space="preserve">
          <source>ZR is the zero Rectangle.</source>
          <target state="translated">ZR是零矩形。</target>
        </trans-unit>
        <trans-unit id="1c6d3d57e5f186ce1aa4706dba2af53b9ebdfe54" translate="yes" xml:space="preserve">
          <source>Zero returns a Value representing the zero value for the specified type. The result is different from the zero value of the Value struct, which represents no value at all. For example, Zero(TypeOf(42)) returns a Value with Kind Int and value 0. The returned value is neither addressable nor settable.</source>
          <target state="translated">Zero返回一个代表指定类型的零值的Value。其结果与Value结构的零值不同,它根本不代表任何值。例如,Zero(TypeOf(42))返回一个Kind Int和值为0的Value。返回的值既不可寻址,也不可设置。</target>
        </trans-unit>
        <trans-unit id="5ec7a8085e409e2fdcc504c5c24961579ad364d7" translate="yes" xml:space="preserve">
          <source>Zone computes the time zone in effect at time t, returning the abbreviated name of the zone (such as &quot;CET&quot;) and its offset in seconds east of UTC.</source>
          <target state="translated">Zone计算在时间t生效的时区,返回时区的缩写名称(如 &quot;CET&quot;)和它在UTC以东的偏移量(秒)。</target>
        </trans-unit>
        <trans-unit id="d95a582393c950008420678e089bcb6fb6005a66" translate="yes" xml:space="preserve">
          <source>[1] US patent 4405829 (1972, expired) [2] &lt;a href=&quot;http://www.cacr.math.uwaterloo.ca/techreports/2006/cacr2006-16.pdf&quot;&gt;http://www.cacr.math.uwaterloo.ca/techreports/2006/cacr2006-16.pdf&lt;/a&gt;</source>
          <target state="translated">[1]美国专利4405829（1972年到期）[2] &lt;a href=&quot;http://www.cacr.math.uwaterloo.ca/techreports/2006/cacr2006-16.pdf&quot;&gt;http://www.cacr.math.uwaterloo.ca/techreports/2006/cacr2006-16.pdf&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e9ce7a3611a7e8082ceef88c829a5b4bd38a883b" translate="yes" xml:space="preserve">
          <source>a and b may be positive, zero or negative. (Before Go 1.14 both had to be &amp;gt; 0.) Regardless of the signs of a and b, z is always &amp;gt;= 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c868a399ecee19d2ae9d23c5ac270d4627ec37c2" translate="yes" xml:space="preserve">
          <source>adler32</source>
          <target state="translated">adler32</target>
        </trans-unit>
        <trans-unit id="3bc4dea27b862dd8aa4e815187d2cdd3be2a75c7" translate="yes" xml:space="preserve">
          <source>adler32.Checksum()</source>
          <target state="translated">adler32.Checksum()</target>
        </trans-unit>
        <trans-unit id="fdae41220d5cd5d881fd4909d397ab172b7b713d" translate="yes" xml:space="preserve">
          <source>adler32.New()</source>
          <target state="translated">adler32.New()</target>
        </trans-unit>
        <trans-unit id="b9e516580969fb81fe1efdac7be863ede058820d" translate="yes" xml:space="preserve">
          <source>adler32.go</source>
          <target state="translated">adler32.go</target>
        </trans-unit>
        <trans-unit id="9b214a0fbc91794f9b2f7c03b2ffdadc705bb106" translate="yes" xml:space="preserve">
          <source>aes</source>
          <target state="translated">aes</target>
        </trans-unit>
        <trans-unit id="4a6e483e4c655c235bfae76e4cff3a9491b844fe" translate="yes" xml:space="preserve">
          <source>aes.KeySizeError</source>
          <target state="translated">aes.KeySizeError</target>
        </trans-unit>
        <trans-unit id="eaae49997213c0be97b3d20ac0b21bf6b5ea2211" translate="yes" xml:space="preserve">
          <source>aes.KeySizeError.Error()</source>
          <target state="translated">aes.KeySizeError.Error()</target>
        </trans-unit>
        <trans-unit id="39b985982e7b3543046a3bf2ac7d7a7b8ce71274" translate="yes" xml:space="preserve">
          <source>aes.NewCipher()</source>
          <target state="translated">aes.NewCipher()</target>
        </trans-unit>
        <trans-unit id="0fb27eee12ade1a38a95e36453c1e554b462484b" translate="yes" xml:space="preserve">
          <source>and to read that data back:</source>
          <target state="translated">并读回这些数据。</target>
        </trans-unit>
        <trans-unit id="ebfb55f4432b592119a10592e4f26272cc72359e" translate="yes" xml:space="preserve">
          <source>archive</source>
          <target state="translated">archive</target>
        </trans-unit>
        <trans-unit id="599b006359811c99dc41f2f30a3e4da1a269aab7" translate="yes" xml:space="preserve">
          <source>archive/tar</source>
          <target state="translated">archive/tar</target>
        </trans-unit>
        <trans-unit id="36627ccd71d39d88b5319bafd6f742e95ad7efbb" translate="yes" xml:space="preserve">
          <source>archive/zip</source>
          <target state="translated">archive/zip</target>
        </trans-unit>
        <trans-unit id="5711ec9a54403a9271f1ec98d0532f337d096f48" translate="yes" xml:space="preserve">
          <source>are considered benchmarks, and are executed by the &quot;go test&quot; command when its -bench flag is provided. Benchmarks are run sequentially.</source>
          <target state="translated">被认为是基准,并在提供-bench标志时由 &quot;go test &quot;命令执行。基准按顺序运行。</target>
        </trans-unit>
        <trans-unit id="2f4d46fbed13b2d5ff12c543a95ead3c2d7d0b4e" translate="yes" xml:space="preserve">
          <source>ascii85</source>
          <target state="translated">ascii85</target>
        </trans-unit>
        <trans-unit id="c709c878860d1c843277aa3c7fafe85ebe2fdbbf" translate="yes" xml:space="preserve">
          <source>ascii85.CorruptInputError</source>
          <target state="translated">ascii85.CorruptInputError</target>
        </trans-unit>
        <trans-unit id="58459a79830f2fbd0ecae6834d288cc61d744b76" translate="yes" xml:space="preserve">
          <source>ascii85.CorruptInputError.Error()</source>
          <target state="translated">ascii85.CorruptInputError.Error()</target>
        </trans-unit>
        <trans-unit id="59d4f41c4d68ec4771eaba0f7e123bfcd8825ea8" translate="yes" xml:space="preserve">
          <source>ascii85.Decode()</source>
          <target state="translated">ascii85.Decode()</target>
        </trans-unit>
        <trans-unit id="8d4003545eb5e35693ca34599af4f472b3ea1e75" translate="yes" xml:space="preserve">
          <source>ascii85.Encode()</source>
          <target state="translated">ascii85.Encode()</target>
        </trans-unit>
        <trans-unit id="bf3560ccbab3bd109332df53c1a3532db455ea63" translate="yes" xml:space="preserve">
          <source>ascii85.MaxEncodedLen()</source>
          <target state="translated">ascii85.MaxEncodedLen()</target>
        </trans-unit>
        <trans-unit id="70cbc7b778e1d7ce35bd8d42cc75b6c69fc1ac8a" translate="yes" xml:space="preserve">
          <source>ascii85.NewDecoder()</source>
          <target state="translated">ascii85.NewDecoder()</target>
        </trans-unit>
        <trans-unit id="5a619b434aa961150c63a00555d9caa30389e0a7" translate="yes" xml:space="preserve">
          <source>ascii85.NewEncoder()</source>
          <target state="translated">ascii85.NewEncoder()</target>
        </trans-unit>
        <trans-unit id="5d4c0e749c8b30f76f313c377c2c53071120924c" translate="yes" xml:space="preserve">
          <source>ascii85.go</source>
          <target state="translated">ascii85.go</target>
        </trans-unit>
        <trans-unit id="9edf4240018976bf964cf31c1a24d34fde8d517d" translate="yes" xml:space="preserve">
          <source>asn1</source>
          <target state="translated">asn1</target>
        </trans-unit>
        <trans-unit id="3b25fcd0e7aac867ba1b902a9bad74c32fd06f7a" translate="yes" xml:space="preserve">
          <source>asn1.BitString</source>
          <target state="translated">asn1.BitString</target>
        </trans-unit>
        <trans-unit id="b6f72489fb5ca7587375a5bdd653f7f1df476dc4" translate="yes" xml:space="preserve">
          <source>asn1.BitString.At()</source>
          <target state="translated">asn1.BitString.At()</target>
        </trans-unit>
        <trans-unit id="4c41e6f4e9eb61025667c2d062c9558e1f1e6497" translate="yes" xml:space="preserve">
          <source>asn1.BitString.RightAlign()</source>
          <target state="translated">asn1.BitString.RightAlign()</target>
        </trans-unit>
        <trans-unit id="8cdba2268b9ac8546eddd752887146141a709a59" translate="yes" xml:space="preserve">
          <source>asn1.Enumerated</source>
          <target state="translated">asn1.Enumerated</target>
        </trans-unit>
        <trans-unit id="0bda2d2df59ae7e05b1eec034907a553d7c7a42b" translate="yes" xml:space="preserve">
          <source>asn1.Flag</source>
          <target state="translated">asn1.Flag</target>
        </trans-unit>
        <trans-unit id="b6fd1eca6f1af508581a7ec1afa96ca5c77fdcef" translate="yes" xml:space="preserve">
          <source>asn1.Marshal()</source>
          <target state="translated">asn1.Marshal()</target>
        </trans-unit>
        <trans-unit id="1dd69ab12f931e65b184412035dbdf691ef75671" translate="yes" xml:space="preserve">
          <source>asn1.MarshalWithParams()</source>
          <target state="translated">asn1.MarshalWithParams()</target>
        </trans-unit>
        <trans-unit id="967f6161afbc84e65192ed4145c8fb2886ef1b34" translate="yes" xml:space="preserve">
          <source>asn1.ObjectIdentifier</source>
          <target state="translated">asn1.ObjectIdentifier</target>
        </trans-unit>
        <trans-unit id="eb5273c3d4afff6a018248c1d3b92ecf13f1b251" translate="yes" xml:space="preserve">
          <source>asn1.ObjectIdentifier.Equal()</source>
          <target state="translated">asn1.ObjectIdentifier.Equal()</target>
        </trans-unit>
        <trans-unit id="9104208a312cff3364923b64231855dcb6182420" translate="yes" xml:space="preserve">
          <source>asn1.ObjectIdentifier.String()</source>
          <target state="translated">asn1.ObjectIdentifier.String()</target>
        </trans-unit>
        <trans-unit id="fa1326ed75bd447347a012e931b2cb50f6277993" translate="yes" xml:space="preserve">
          <source>asn1.RawContent</source>
          <target state="translated">asn1.RawContent</target>
        </trans-unit>
        <trans-unit id="11afa151ffea7be0e51569d7278af02c01d14648" translate="yes" xml:space="preserve">
          <source>asn1.RawValue</source>
          <target state="translated">asn1.RawValue</target>
        </trans-unit>
        <trans-unit id="c7e196c13ac871177aa305816ccdd2f214844f1f" translate="yes" xml:space="preserve">
          <source>asn1.StructuralError</source>
          <target state="translated">asn1.StructuralError</target>
        </trans-unit>
        <trans-unit id="ede541b4e84339ed235682099c483b8d0ea9d195" translate="yes" xml:space="preserve">
          <source>asn1.StructuralError.Error()</source>
          <target state="translated">asn1.StructuralError.Error()</target>
        </trans-unit>
        <trans-unit id="6f92f6f304a340128dbbc8d8d5d1d24bb934dd1c" translate="yes" xml:space="preserve">
          <source>asn1.SyntaxError</source>
          <target state="translated">asn1.SyntaxError</target>
        </trans-unit>
        <trans-unit id="2cc0c7c5b17f8fbf4c99fe144d21fdcb86a4e4d5" translate="yes" xml:space="preserve">
          <source>asn1.SyntaxError.Error()</source>
          <target state="translated">asn1.SyntaxError.Error()</target>
        </trans-unit>
        <trans-unit id="b4620fdf4cc070561d9028cca9eebe3527fab3bb" translate="yes" xml:space="preserve">
          <source>asn1.Unmarshal()</source>
          <target state="translated">asn1.Unmarshal()</target>
        </trans-unit>
        <trans-unit id="db2421d96b2365ce2873e4bdc3dd1b1884fb7a9e" translate="yes" xml:space="preserve">
          <source>asn1.UnmarshalWithParams()</source>
          <target state="translated">asn1.UnmarshalWithParams()</target>
        </trans-unit>
        <trans-unit id="c24c0248770ae98831f8a654310d4c2e07514c61" translate="yes" xml:space="preserve">
          <source>ast</source>
          <target state="translated">ast</target>
        </trans-unit>
        <trans-unit id="befa22645af2b2c57ff1d061bee4609e465ce151" translate="yes" xml:space="preserve">
          <source>ast.ArrayType</source>
          <target state="translated">ast.ArrayType</target>
        </trans-unit>
        <trans-unit id="3aaa1f08029690a9ad3162fe7f0aeb4221534ddc" translate="yes" xml:space="preserve">
          <source>ast.ArrayType.End()</source>
          <target state="translated">ast.ArrayType.End()</target>
        </trans-unit>
        <trans-unit id="7400ff1c7cb92a2976bfa3daf41ae2f354273958" translate="yes" xml:space="preserve">
          <source>ast.ArrayType.Pos()</source>
          <target state="translated">ast.ArrayType.Pos()</target>
        </trans-unit>
        <trans-unit id="8f7ff0499c577334d405d39760346407f6352d95" translate="yes" xml:space="preserve">
          <source>ast.AssignStmt</source>
          <target state="translated">ast.AssignStmt</target>
        </trans-unit>
        <trans-unit id="a4eadbf257f6ac901889cf9a6bb1024e24a65284" translate="yes" xml:space="preserve">
          <source>ast.AssignStmt.End()</source>
          <target state="translated">ast.AssignStmt.End()</target>
        </trans-unit>
        <trans-unit id="2d16762ab296b2e910461becfd95d333facceb3a" translate="yes" xml:space="preserve">
          <source>ast.AssignStmt.Pos()</source>
          <target state="translated">ast.AssignStmt.Pos()</target>
        </trans-unit>
        <trans-unit id="ea70196c82482d305608466884903c9a043e9178" translate="yes" xml:space="preserve">
          <source>ast.BadDecl</source>
          <target state="translated">ast.BadDecl</target>
        </trans-unit>
        <trans-unit id="8b1817d76ef00b508173afe2cfbf9777b5fb2077" translate="yes" xml:space="preserve">
          <source>ast.BadDecl.End()</source>
          <target state="translated">ast.BadDecl.End()</target>
        </trans-unit>
        <trans-unit id="4deb107b4c3af556a6324d9162f029f4f4e1ab9d" translate="yes" xml:space="preserve">
          <source>ast.BadDecl.Pos()</source>
          <target state="translated">ast.BadDecl.Pos()</target>
        </trans-unit>
        <trans-unit id="fd50cb7d9bdbcdf5cbc147580c9a8b40d97b0d06" translate="yes" xml:space="preserve">
          <source>ast.BadExpr</source>
          <target state="translated">ast.BadExpr</target>
        </trans-unit>
        <trans-unit id="d2fa322f959652eda770c38075241e33463480a5" translate="yes" xml:space="preserve">
          <source>ast.BadExpr.End()</source>
          <target state="translated">ast.BadExpr.End()</target>
        </trans-unit>
        <trans-unit id="9b83d6d18f65ed71ddfbc157d967fa64ca7fe3cc" translate="yes" xml:space="preserve">
          <source>ast.BadExpr.Pos()</source>
          <target state="translated">ast.BadExpr.Pos()</target>
        </trans-unit>
        <trans-unit id="aa7a3ebb9ae1f1a5f3082d8520b04a78ac2064d7" translate="yes" xml:space="preserve">
          <source>ast.BadStmt</source>
          <target state="translated">ast.BadStmt</target>
        </trans-unit>
        <trans-unit id="7985d77e4e120c475b0777e4460cfbd66c182a3f" translate="yes" xml:space="preserve">
          <source>ast.BadStmt.End()</source>
          <target state="translated">ast.BadStmt.End()</target>
        </trans-unit>
        <trans-unit id="611c00a04c5ad6fc35d6b2b0553c31ad6c2c9afd" translate="yes" xml:space="preserve">
          <source>ast.BadStmt.Pos()</source>
          <target state="translated">ast.BadStmt.Pos()</target>
        </trans-unit>
        <trans-unit id="a332f7650fd36f4dd02d99d3b8ec6e1a8507c809" translate="yes" xml:space="preserve">
          <source>ast.BasicLit</source>
          <target state="translated">ast.BasicLit</target>
        </trans-unit>
        <trans-unit id="a98f149f6185847f9599a498ffe20bdbe234ca79" translate="yes" xml:space="preserve">
          <source>ast.BasicLit.End()</source>
          <target state="translated">ast.BasicLit.End()</target>
        </trans-unit>
        <trans-unit id="0e3e9e0fe19152d6958f147d0962725dbce04684" translate="yes" xml:space="preserve">
          <source>ast.BasicLit.Pos()</source>
          <target state="translated">ast.BasicLit.Pos()</target>
        </trans-unit>
        <trans-unit id="9ec47fda282a56476d3ee59b3f89d74ad43722db" translate="yes" xml:space="preserve">
          <source>ast.BinaryExpr</source>
          <target state="translated">ast.BinaryExpr</target>
        </trans-unit>
        <trans-unit id="d9ca2bfa7b901986b5e133efaf148e7bfa73fda0" translate="yes" xml:space="preserve">
          <source>ast.BinaryExpr.End()</source>
          <target state="translated">ast.BinaryExpr.End()</target>
        </trans-unit>
        <trans-unit id="b540b3db7c164e96ddb28ee245b6fef0191d37eb" translate="yes" xml:space="preserve">
          <source>ast.BinaryExpr.Pos()</source>
          <target state="translated">ast.BinaryExpr.Pos()</target>
        </trans-unit>
        <trans-unit id="53ad55929540909d0e0c0c6d1a14db54405be438" translate="yes" xml:space="preserve">
          <source>ast.BlockStmt</source>
          <target state="translated">ast.BlockStmt</target>
        </trans-unit>
        <trans-unit id="2a8369a80640f3347a935c1c0c735ec709358dd1" translate="yes" xml:space="preserve">
          <source>ast.BlockStmt.End()</source>
          <target state="translated">ast.BlockStmt.End()</target>
        </trans-unit>
        <trans-unit id="851c7137cbb678223bbeb3430399d5059b29e277" translate="yes" xml:space="preserve">
          <source>ast.BlockStmt.Pos()</source>
          <target state="translated">ast.BlockStmt.Pos()</target>
        </trans-unit>
        <trans-unit id="53d494d40d484db0e354b674a369eaa485186d69" translate="yes" xml:space="preserve">
          <source>ast.BranchStmt</source>
          <target state="translated">ast.BranchStmt</target>
        </trans-unit>
        <trans-unit id="006cb666be74c0e0ee36d0e1ed3b722a9839add9" translate="yes" xml:space="preserve">
          <source>ast.BranchStmt.End()</source>
          <target state="translated">ast.BranchStmt.End()</target>
        </trans-unit>
        <trans-unit id="e624885b40ec9930e0e4fd5546fea07c4309f64a" translate="yes" xml:space="preserve">
          <source>ast.BranchStmt.Pos()</source>
          <target state="translated">ast.BranchStmt.Pos()</target>
        </trans-unit>
        <trans-unit id="d6ff240d9cd77565e3fdf528d15c0d3e77aae78a" translate="yes" xml:space="preserve">
          <source>ast.CallExpr</source>
          <target state="translated">ast.CallExpr</target>
        </trans-unit>
        <trans-unit id="8a4191ffec5d62d08911cd982b546ba76a9e5277" translate="yes" xml:space="preserve">
          <source>ast.CallExpr.End()</source>
          <target state="translated">ast.CallExpr.End()</target>
        </trans-unit>
        <trans-unit id="34bacfb498513ccfab3294638b6955e96b607eff" translate="yes" xml:space="preserve">
          <source>ast.CallExpr.Pos()</source>
          <target state="translated">ast.CallExpr.Pos()</target>
        </trans-unit>
        <trans-unit id="908cabf810e388d4f96ee3b484f6fcc63f3a633e" translate="yes" xml:space="preserve">
          <source>ast.CaseClause</source>
          <target state="translated">ast.CaseClause</target>
        </trans-unit>
        <trans-unit id="9bf625cb99111aa416d920ee5d6aa42ad53c2a20" translate="yes" xml:space="preserve">
          <source>ast.CaseClause.End()</source>
          <target state="translated">ast.CaseClause.End()</target>
        </trans-unit>
        <trans-unit id="5a4f8b1a228bb80bdb4bf93e1ba2e0372f5f4436" translate="yes" xml:space="preserve">
          <source>ast.CaseClause.Pos()</source>
          <target state="translated">ast.CaseClause.Pos()</target>
        </trans-unit>
        <trans-unit id="df184106f71e2042d31c9c581eea0f2a15d7e71a" translate="yes" xml:space="preserve">
          <source>ast.ChanDir</source>
          <target state="translated">ast.ChanDir</target>
        </trans-unit>
        <trans-unit id="d9894c3ef3fe79412fc727115570d01ffbfbe371" translate="yes" xml:space="preserve">
          <source>ast.ChanType</source>
          <target state="translated">ast.ChanType</target>
        </trans-unit>
        <trans-unit id="a2d3c384b591665fddb01c653b8cba6f42964707" translate="yes" xml:space="preserve">
          <source>ast.ChanType.End()</source>
          <target state="translated">ast.ChanType.End()</target>
        </trans-unit>
        <trans-unit id="b0d99e4fe9e408caf8079a70db85f1516d3ca640" translate="yes" xml:space="preserve">
          <source>ast.ChanType.Pos()</source>
          <target state="translated">ast.ChanType.Pos()</target>
        </trans-unit>
        <trans-unit id="afe2fe744c7228a28664b3f99a19fbe01eaab7ae" translate="yes" xml:space="preserve">
          <source>ast.CommClause</source>
          <target state="translated">ast.CommClause</target>
        </trans-unit>
        <trans-unit id="748b6c2557f1f18e86e976cbd1e96523b3b6d20f" translate="yes" xml:space="preserve">
          <source>ast.CommClause.End()</source>
          <target state="translated">ast.CommClause.End()</target>
        </trans-unit>
        <trans-unit id="76469ceeb1ed92aaa0251ce9a2f5a4d18c58e648" translate="yes" xml:space="preserve">
          <source>ast.CommClause.Pos()</source>
          <target state="translated">ast.CommClause.Pos()</target>
        </trans-unit>
        <trans-unit id="eb410c5b03c33912d6440a324168677d85ea4084" translate="yes" xml:space="preserve">
          <source>ast.Comment</source>
          <target state="translated">ast.Comment</target>
        </trans-unit>
        <trans-unit id="2f74f8850964cdea428b72cbb0bd8306188b40cc" translate="yes" xml:space="preserve">
          <source>ast.Comment.End()</source>
          <target state="translated">ast.Comment.End()</target>
        </trans-unit>
        <trans-unit id="8da5aaee99b97985300a17a57207881036cfc8a5" translate="yes" xml:space="preserve">
          <source>ast.Comment.Pos()</source>
          <target state="translated">ast.Comment.Pos()</target>
        </trans-unit>
        <trans-unit id="d482672bd74456c8614c239b9de80f42d9daf6ac" translate="yes" xml:space="preserve">
          <source>ast.CommentGroup</source>
          <target state="translated">ast.CommentGroup</target>
        </trans-unit>
        <trans-unit id="291fb0d01c213b675214864708e38aac78c965df" translate="yes" xml:space="preserve">
          <source>ast.CommentGroup.End()</source>
          <target state="translated">ast.CommentGroup.End()</target>
        </trans-unit>
        <trans-unit id="7ec5ba7e20d2f8b73cfdda6dd5a5bafef1a471ad" translate="yes" xml:space="preserve">
          <source>ast.CommentGroup.Pos()</source>
          <target state="translated">ast.CommentGroup.Pos()</target>
        </trans-unit>
        <trans-unit id="db0b452520c4081b875986a5b08603bfa7cf27db" translate="yes" xml:space="preserve">
          <source>ast.CommentGroup.Text()</source>
          <target state="translated">ast.CommentGroup.Text()</target>
        </trans-unit>
        <trans-unit id="49b8300f7bfddf0b6f0c42c6dedb29841231a049" translate="yes" xml:space="preserve">
          <source>ast.CommentMap</source>
          <target state="translated">ast.CommentMap</target>
        </trans-unit>
        <trans-unit id="138e15e3c47ac21027b750aa86d1b4d8df53eec7" translate="yes" xml:space="preserve">
          <source>ast.CommentMap.Comments()</source>
          <target state="translated">ast.CommentMap.Comments()</target>
        </trans-unit>
        <trans-unit id="2a275924c14d2d5bda8b6efa1638b2ec1b5a618b" translate="yes" xml:space="preserve">
          <source>ast.CommentMap.Filter()</source>
          <target state="translated">ast.CommentMap.Filter()</target>
        </trans-unit>
        <trans-unit id="df6eab6e6f03363da7369f68bcb68c05efd35841" translate="yes" xml:space="preserve">
          <source>ast.CommentMap.String()</source>
          <target state="translated">ast.CommentMap.String()</target>
        </trans-unit>
        <trans-unit id="0f2fc4844e739382be4a668668f79c30a8928df8" translate="yes" xml:space="preserve">
          <source>ast.CommentMap.Update()</source>
          <target state="translated">ast.CommentMap.Update()</target>
        </trans-unit>
        <trans-unit id="3a34308cd756c0e7977abc07b327473d4c5e13c9" translate="yes" xml:space="preserve">
          <source>ast.CompositeLit</source>
          <target state="translated">ast.CompositeLit</target>
        </trans-unit>
        <trans-unit id="9bb0da22db2db807a80446404d4b271a65e7aab7" translate="yes" xml:space="preserve">
          <source>ast.CompositeLit.End()</source>
          <target state="translated">ast.CompositeLit.End()</target>
        </trans-unit>
        <trans-unit id="a52feba5850623b44256bed6165f0d82ada4137b" translate="yes" xml:space="preserve">
          <source>ast.CompositeLit.Pos()</source>
          <target state="translated">ast.CompositeLit.Pos()</target>
        </trans-unit>
        <trans-unit id="9b37ee9927929c783d31dbe64e672109b3492683" translate="yes" xml:space="preserve">
          <source>ast.Decl</source>
          <target state="translated">ast.Decl</target>
        </trans-unit>
        <trans-unit id="98b759c2b999b973be88a5d07cfbab3927683195" translate="yes" xml:space="preserve">
          <source>ast.DeclStmt</source>
          <target state="translated">ast.DeclStmt</target>
        </trans-unit>
        <trans-unit id="d9c77d027698da2fc0d108e953b1083d16e69416" translate="yes" xml:space="preserve">
          <source>ast.DeclStmt.End()</source>
          <target state="translated">ast.DeclStmt.End()</target>
        </trans-unit>
        <trans-unit id="78a21564f0f1d72a43aaeb48f47154c52db3176a" translate="yes" xml:space="preserve">
          <source>ast.DeclStmt.Pos()</source>
          <target state="translated">ast.DeclStmt.Pos()</target>
        </trans-unit>
        <trans-unit id="a88c75402a7cf7a0dc33b87900e61ca2f2cb224d" translate="yes" xml:space="preserve">
          <source>ast.DeferStmt</source>
          <target state="translated">ast.DeferStmt</target>
        </trans-unit>
        <trans-unit id="56a6d8b85ed2f1106d5011cc30be75871a6f333e" translate="yes" xml:space="preserve">
          <source>ast.DeferStmt.End()</source>
          <target state="translated">ast.DeferStmt.End()</target>
        </trans-unit>
        <trans-unit id="00435a1620cdf12444d2655e5741d7351bc9d952" translate="yes" xml:space="preserve">
          <source>ast.DeferStmt.Pos()</source>
          <target state="translated">ast.DeferStmt.Pos()</target>
        </trans-unit>
        <trans-unit id="d85c5eae8637be960ca473b6d19e86f92dadc2b1" translate="yes" xml:space="preserve">
          <source>ast.Ellipsis</source>
          <target state="translated">ast.Ellipsis</target>
        </trans-unit>
        <trans-unit id="6e8302a49c68476d2a9804dff9dc78d3fa9453ff" translate="yes" xml:space="preserve">
          <source>ast.Ellipsis.End()</source>
          <target state="translated">ast.Ellipsis.End()</target>
        </trans-unit>
        <trans-unit id="aa13456258be7dfca118f86ab0d7cd8681f91663" translate="yes" xml:space="preserve">
          <source>ast.Ellipsis.Pos()</source>
          <target state="translated">ast.Ellipsis.Pos()</target>
        </trans-unit>
        <trans-unit id="83ec929cb12fbac363e83149d20e153666193591" translate="yes" xml:space="preserve">
          <source>ast.EmptyStmt</source>
          <target state="translated">ast.EmptyStmt</target>
        </trans-unit>
        <trans-unit id="1dcc01433f78cd9d1b21499a51d59136b3e66135" translate="yes" xml:space="preserve">
          <source>ast.EmptyStmt.End()</source>
          <target state="translated">ast.EmptyStmt.End()</target>
        </trans-unit>
        <trans-unit id="d15ee08589510f58fcd6aeeadb8b06acc40aae8f" translate="yes" xml:space="preserve">
          <source>ast.EmptyStmt.Pos()</source>
          <target state="translated">ast.EmptyStmt.Pos()</target>
        </trans-unit>
        <trans-unit id="429b94c0e48e600788d6c40b157d869b51271dfd" translate="yes" xml:space="preserve">
          <source>ast.Expr</source>
          <target state="translated">ast.Expr</target>
        </trans-unit>
        <trans-unit id="ddb6850692bf98131494cb5b4ea6a8c1a5257388" translate="yes" xml:space="preserve">
          <source>ast.ExprStmt</source>
          <target state="translated">ast.ExprStmt</target>
        </trans-unit>
        <trans-unit id="fd6a374b8d32132e7eb765f925013baf3fb247f0" translate="yes" xml:space="preserve">
          <source>ast.ExprStmt.End()</source>
          <target state="translated">ast.ExprStmt.End()</target>
        </trans-unit>
        <trans-unit id="3bbdc36acdb6e801295d7762e2d71d186f8ec5dc" translate="yes" xml:space="preserve">
          <source>ast.ExprStmt.Pos()</source>
          <target state="translated">ast.ExprStmt.Pos()</target>
        </trans-unit>
        <trans-unit id="fe35306cfa6c33d1e08c38078ed6418b57cc5c44" translate="yes" xml:space="preserve">
          <source>ast.Field</source>
          <target state="translated">ast.Field</target>
        </trans-unit>
        <trans-unit id="b8ce598b99eab4821c1f05610e4e7c5da11843e3" translate="yes" xml:space="preserve">
          <source>ast.Field.End()</source>
          <target state="translated">ast.Field.End()</target>
        </trans-unit>
        <trans-unit id="31f3f6875ba87eb89fd1c8f4ff6e5652a7d06d46" translate="yes" xml:space="preserve">
          <source>ast.Field.Pos()</source>
          <target state="translated">ast.Field.Pos()</target>
        </trans-unit>
        <trans-unit id="35a61eacd2d4a8d7a2086110a29c7cae70367172" translate="yes" xml:space="preserve">
          <source>ast.FieldFilter</source>
          <target state="translated">ast.FieldFilter</target>
        </trans-unit>
        <trans-unit id="a5cbb8ee53c7545ba520cd4ef0b543279f93ac51" translate="yes" xml:space="preserve">
          <source>ast.FieldList</source>
          <target state="translated">ast.FieldList</target>
        </trans-unit>
        <trans-unit id="079acca70ea605f868cb5458fcd3113961f82bf9" translate="yes" xml:space="preserve">
          <source>ast.FieldList.End()</source>
          <target state="translated">ast.FieldList.End()</target>
        </trans-unit>
        <trans-unit id="0959206159b04b0f7ba0463fe7822ba39164edbe" translate="yes" xml:space="preserve">
          <source>ast.FieldList.NumFields()</source>
          <target state="translated">ast.FieldList.NumFields()</target>
        </trans-unit>
        <trans-unit id="54e713cf18d22bb14498eefdbee876cd84643301" translate="yes" xml:space="preserve">
          <source>ast.FieldList.Pos()</source>
          <target state="translated">ast.FieldList.Pos()</target>
        </trans-unit>
        <trans-unit id="824559735927a3878ee55aa114ff909a4a761fd5" translate="yes" xml:space="preserve">
          <source>ast.File</source>
          <target state="translated">ast.File</target>
        </trans-unit>
        <trans-unit id="9c13ff5d91937bd63b024c5111fe98c16f08d0e1" translate="yes" xml:space="preserve">
          <source>ast.File.End()</source>
          <target state="translated">ast.File.End()</target>
        </trans-unit>
        <trans-unit id="908fdb94b0f7d7928c2e598e507365591a215184" translate="yes" xml:space="preserve">
          <source>ast.File.Pos()</source>
          <target state="translated">ast.File.Pos()</target>
        </trans-unit>
        <trans-unit id="6fc04c6e8365c1e2a348b8d85aea6af30f73a3e7" translate="yes" xml:space="preserve">
          <source>ast.FileExports()</source>
          <target state="translated">ast.FileExports()</target>
        </trans-unit>
        <trans-unit id="515afaadbe65dbb56510d1001b0cea4fb212985a" translate="yes" xml:space="preserve">
          <source>ast.Filter</source>
          <target state="translated">ast.Filter</target>
        </trans-unit>
        <trans-unit id="725c1315b64f2159e1d535cc17c67990c3eb9407" translate="yes" xml:space="preserve">
          <source>ast.FilterDecl()</source>
          <target state="translated">ast.FilterDecl()</target>
        </trans-unit>
        <trans-unit id="9b23fe99e5e78579edea9b2685c0beef40fc5bdf" translate="yes" xml:space="preserve">
          <source>ast.FilterFile()</source>
          <target state="translated">ast.FilterFile()</target>
        </trans-unit>
        <trans-unit id="d0077c13020f893bea04504e4f7edbf31c696173" translate="yes" xml:space="preserve">
          <source>ast.FilterPackage()</source>
          <target state="translated">ast.FilterPackage()</target>
        </trans-unit>
        <trans-unit id="010df2eadbc0b289bbb3ed3dfe1f015c9eaf7589" translate="yes" xml:space="preserve">
          <source>ast.ForStmt</source>
          <target state="translated">ast.ForStmt</target>
        </trans-unit>
        <trans-unit id="7bec230190c220ed154122611c547a4ee061a0d9" translate="yes" xml:space="preserve">
          <source>ast.ForStmt.End()</source>
          <target state="translated">ast.ForStmt.End()</target>
        </trans-unit>
        <trans-unit id="ce1b26151d92491e06fabf1a68f974b70dd064b2" translate="yes" xml:space="preserve">
          <source>ast.ForStmt.Pos()</source>
          <target state="translated">ast.ForStmt.Pos()</target>
        </trans-unit>
        <trans-unit id="9e23cc076f7fa7c25511d66eeb511d7de3fa35f8" translate="yes" xml:space="preserve">
          <source>ast.Fprint()</source>
          <target state="translated">ast.Fprint()</target>
        </trans-unit>
        <trans-unit id="bff7cf7e949bd5b1d09817c599f73bf69122daad" translate="yes" xml:space="preserve">
          <source>ast.FuncDecl</source>
          <target state="translated">ast.FuncDecl</target>
        </trans-unit>
        <trans-unit id="62fa27f1159e359248a085d818004bac79095e10" translate="yes" xml:space="preserve">
          <source>ast.FuncDecl.End()</source>
          <target state="translated">ast.FuncDecl.End()</target>
        </trans-unit>
        <trans-unit id="ca288db889162827b386d6cf407850d0256d0306" translate="yes" xml:space="preserve">
          <source>ast.FuncDecl.Pos()</source>
          <target state="translated">ast.FuncDecl.Pos()</target>
        </trans-unit>
        <trans-unit id="eaa722591c8d3bb5ec7c07884ae4d044acd81acd" translate="yes" xml:space="preserve">
          <source>ast.FuncLit</source>
          <target state="translated">ast.FuncLit</target>
        </trans-unit>
        <trans-unit id="76e1942fbc8f515400fb974985257f1f150278b2" translate="yes" xml:space="preserve">
          <source>ast.FuncLit.End()</source>
          <target state="translated">ast.FuncLit.End()</target>
        </trans-unit>
        <trans-unit id="cf7a4f37978363b411c184f235404cf42419323e" translate="yes" xml:space="preserve">
          <source>ast.FuncLit.Pos()</source>
          <target state="translated">ast.FuncLit.Pos()</target>
        </trans-unit>
        <trans-unit id="77ef0acfcbf1e91989489e4b465f7749a502cee2" translate="yes" xml:space="preserve">
          <source>ast.FuncType</source>
          <target state="translated">ast.FuncType</target>
        </trans-unit>
        <trans-unit id="8bef62cd074cbb9b8bb549f7f37fdd4c9556cec9" translate="yes" xml:space="preserve">
          <source>ast.FuncType.End()</source>
          <target state="translated">ast.FuncType.End()</target>
        </trans-unit>
        <trans-unit id="4f06513dc949b59ca3fe6fb82cf436d570af99bc" translate="yes" xml:space="preserve">
          <source>ast.FuncType.Pos()</source>
          <target state="translated">ast.FuncType.Pos()</target>
        </trans-unit>
        <trans-unit id="49e3462052836776f7475e211320d9c2f0839757" translate="yes" xml:space="preserve">
          <source>ast.GenDecl</source>
          <target state="translated">ast.GenDecl</target>
        </trans-unit>
        <trans-unit id="df8f73ecfd0e7618f102077a8d04eadb08d8aae2" translate="yes" xml:space="preserve">
          <source>ast.GenDecl.End()</source>
          <target state="translated">ast.GenDecl.End()</target>
        </trans-unit>
        <trans-unit id="ec91647151e8a76006d16cb06b8e4e4fa790d995" translate="yes" xml:space="preserve">
          <source>ast.GenDecl.Pos()</source>
          <target state="translated">ast.GenDecl.Pos()</target>
        </trans-unit>
        <trans-unit id="7c40561ab6c64f38a088066a7a0d84b95a7ca19b" translate="yes" xml:space="preserve">
          <source>ast.GoStmt</source>
          <target state="translated">ast.GoStmt</target>
        </trans-unit>
        <trans-unit id="c367671365811674fb44775dd6b4f6d17871b617" translate="yes" xml:space="preserve">
          <source>ast.GoStmt.End()</source>
          <target state="translated">ast.GoStmt.End()</target>
        </trans-unit>
        <trans-unit id="75c800281efd0cbeb0f676a13fbb76dc6b040afc" translate="yes" xml:space="preserve">
          <source>ast.GoStmt.Pos()</source>
          <target state="translated">ast.GoStmt.Pos()</target>
        </trans-unit>
        <trans-unit id="b593a228205ecc5da27ea376c37c8b0feb887b3c" translate="yes" xml:space="preserve">
          <source>ast.Ident</source>
          <target state="translated">ast.Ident</target>
        </trans-unit>
        <trans-unit id="90b434e4582522ff9fdc5e749f4a807e629845d4" translate="yes" xml:space="preserve">
          <source>ast.Ident.End()</source>
          <target state="translated">ast.Ident.End()</target>
        </trans-unit>
        <trans-unit id="330869bf46f759ab5b34542ae5e64e2a8e6d7acb" translate="yes" xml:space="preserve">
          <source>ast.Ident.IsExported()</source>
          <target state="translated">ast.Ident.IsExported()</target>
        </trans-unit>
        <trans-unit id="5880d5cb49703e46da66c8a8df06d571ca83c5a1" translate="yes" xml:space="preserve">
          <source>ast.Ident.Pos()</source>
          <target state="translated">ast.Ident.Pos()</target>
        </trans-unit>
        <trans-unit id="379a5baec0aec6967ea9fdc9a921d6518c56bfab" translate="yes" xml:space="preserve">
          <source>ast.Ident.String()</source>
          <target state="translated">ast.Ident.String()</target>
        </trans-unit>
        <trans-unit id="e8b32504ea1616bed57b72a615485e6c5bcf3eb4" translate="yes" xml:space="preserve">
          <source>ast.IfStmt</source>
          <target state="translated">ast.IfStmt</target>
        </trans-unit>
        <trans-unit id="178670415eb055924ac40df950534ad2e2cfb177" translate="yes" xml:space="preserve">
          <source>ast.IfStmt.End()</source>
          <target state="translated">ast.IfStmt.End()</target>
        </trans-unit>
        <trans-unit id="3168e394231032c60de9860d2f24dcdcf6b63f8e" translate="yes" xml:space="preserve">
          <source>ast.IfStmt.Pos()</source>
          <target state="translated">ast.IfStmt.Pos()</target>
        </trans-unit>
        <trans-unit id="bfcf544bdc28ccecfe31d3153402dfc7ba3c84e8" translate="yes" xml:space="preserve">
          <source>ast.ImportSpec</source>
          <target state="translated">ast.ImportSpec</target>
        </trans-unit>
        <trans-unit id="6520064d174144509bdcbce66766ec930bfa8221" translate="yes" xml:space="preserve">
          <source>ast.ImportSpec.End()</source>
          <target state="translated">ast.ImportSpec.End()</target>
        </trans-unit>
        <trans-unit id="1685b88851dbb057469baaa190bd21d978cbe0bc" translate="yes" xml:space="preserve">
          <source>ast.ImportSpec.Pos()</source>
          <target state="translated">ast.ImportSpec.Pos()</target>
        </trans-unit>
        <trans-unit id="9550a9427b344b71e40dd82d19c601c869a4d9cf" translate="yes" xml:space="preserve">
          <source>ast.Importer</source>
          <target state="translated">ast.Importer</target>
        </trans-unit>
        <trans-unit id="e2409ba06fc76d3584c545f92f449b798355f6f0" translate="yes" xml:space="preserve">
          <source>ast.IncDecStmt</source>
          <target state="translated">ast.IncDecStmt</target>
        </trans-unit>
        <trans-unit id="c525b2e381256702c099bdbe34dc9ce4f6ac65c9" translate="yes" xml:space="preserve">
          <source>ast.IncDecStmt.End()</source>
          <target state="translated">ast.IncDecStmt.End()</target>
        </trans-unit>
        <trans-unit id="035fb511709238ab8b28e76ac438ffe702de2d43" translate="yes" xml:space="preserve">
          <source>ast.IncDecStmt.Pos()</source>
          <target state="translated">ast.IncDecStmt.Pos()</target>
        </trans-unit>
        <trans-unit id="b0307e9b16d106daf0b035e58376cabbc9e6926c" translate="yes" xml:space="preserve">
          <source>ast.IndexExpr</source>
          <target state="translated">ast.IndexExpr</target>
        </trans-unit>
        <trans-unit id="ba7fa4f2659716219910cf4d2905f1a1b287fc30" translate="yes" xml:space="preserve">
          <source>ast.IndexExpr.End()</source>
          <target state="translated">ast.IndexExpr.End()</target>
        </trans-unit>
        <trans-unit id="2bd354950c6821edaad7739a8fcba724b547e4fa" translate="yes" xml:space="preserve">
          <source>ast.IndexExpr.Pos()</source>
          <target state="translated">ast.IndexExpr.Pos()</target>
        </trans-unit>
        <trans-unit id="369af34cd5ed40ef9cb2e2c7caefd90a2a428e6c" translate="yes" xml:space="preserve">
          <source>ast.Inspect()</source>
          <target state="translated">ast.Inspect()</target>
        </trans-unit>
        <trans-unit id="25ee0d24e4bdefca08baba42c5b499bef2631939" translate="yes" xml:space="preserve">
          <source>ast.InterfaceType</source>
          <target state="translated">ast.InterfaceType</target>
        </trans-unit>
        <trans-unit id="e7f5beaab84d5a400eb7088597b485d9c2b81693" translate="yes" xml:space="preserve">
          <source>ast.InterfaceType.End()</source>
          <target state="translated">ast.InterfaceType.End()</target>
        </trans-unit>
        <trans-unit id="9d487418673ccb980bc30730b740aa18ffd002e0" translate="yes" xml:space="preserve">
          <source>ast.InterfaceType.Pos()</source>
          <target state="translated">ast.InterfaceType.Pos()</target>
        </trans-unit>
        <trans-unit id="faf203ccf1d8661b112ef0afb394d238113f79de" translate="yes" xml:space="preserve">
          <source>ast.IsExported()</source>
          <target state="translated">ast.IsExported()</target>
        </trans-unit>
        <trans-unit id="f6e29963cd47848646766055861fb753020b2381" translate="yes" xml:space="preserve">
          <source>ast.KeyValueExpr</source>
          <target state="translated">ast.KeyValueExpr</target>
        </trans-unit>
        <trans-unit id="676038a7674ff4180b98b9c95d7f00e44e5ff675" translate="yes" xml:space="preserve">
          <source>ast.KeyValueExpr.End()</source>
          <target state="translated">ast.KeyValueExpr.End()</target>
        </trans-unit>
        <trans-unit id="a7f2488b03dc9603b5fb5ade012894c27963a348" translate="yes" xml:space="preserve">
          <source>ast.KeyValueExpr.Pos()</source>
          <target state="translated">ast.KeyValueExpr.Pos()</target>
        </trans-unit>
        <trans-unit id="d578e8b479cd8e3a67f7d13b952dbdca8d433665" translate="yes" xml:space="preserve">
          <source>ast.LabeledStmt</source>
          <target state="translated">ast.LabeledStmt</target>
        </trans-unit>
        <trans-unit id="f9fd73232548487ac9de1e96e0d63c270ef3ed95" translate="yes" xml:space="preserve">
          <source>ast.LabeledStmt.End()</source>
          <target state="translated">ast.LabeledStmt.End()</target>
        </trans-unit>
        <trans-unit id="b995ca7a0e7388a2d44edaed5a861f6522bc498f" translate="yes" xml:space="preserve">
          <source>ast.LabeledStmt.Pos()</source>
          <target state="translated">ast.LabeledStmt.Pos()</target>
        </trans-unit>
        <trans-unit id="df9495e93abd4f028fe83b85ec5d23acf6607070" translate="yes" xml:space="preserve">
          <source>ast.MapType</source>
          <target state="translated">ast.MapType</target>
        </trans-unit>
        <trans-unit id="7dcd2d302ff7af724275f98b21395263c7226284" translate="yes" xml:space="preserve">
          <source>ast.MapType.End()</source>
          <target state="translated">ast.MapType.End()</target>
        </trans-unit>
        <trans-unit id="b276b6e6eb9e5e3cc5b5890b552ee1d81c6c3143" translate="yes" xml:space="preserve">
          <source>ast.MapType.Pos()</source>
          <target state="translated">ast.MapType.Pos()</target>
        </trans-unit>
        <trans-unit id="ed54ab4ffb1b7117db7ec8c11c2036e13aa354f4" translate="yes" xml:space="preserve">
          <source>ast.MergeMode</source>
          <target state="translated">ast.MergeMode</target>
        </trans-unit>
        <trans-unit id="8a4a1c271018958b6131692bf9772b17140ab60d" translate="yes" xml:space="preserve">
          <source>ast.MergePackageFiles()</source>
          <target state="translated">ast.MergePackageFiles()</target>
        </trans-unit>
        <trans-unit id="d69af0e77986430aeba3a0af081860fe115b6cb4" translate="yes" xml:space="preserve">
          <source>ast.NewCommentMap()</source>
          <target state="translated">ast.NewCommentMap()</target>
        </trans-unit>
        <trans-unit id="5129de288f81e4c27120a9f4a90516ac8d4b5f34" translate="yes" xml:space="preserve">
          <source>ast.NewIdent()</source>
          <target state="translated">ast.NewIdent()</target>
        </trans-unit>
        <trans-unit id="c06ec5f816ad3b7780a18100eac31a6eaf527921" translate="yes" xml:space="preserve">
          <source>ast.NewObj()</source>
          <target state="translated">ast.NewObj()</target>
        </trans-unit>
        <trans-unit id="2b4163acf274523447a3956d93acc0e5781621e5" translate="yes" xml:space="preserve">
          <source>ast.NewPackage()</source>
          <target state="translated">ast.NewPackage()</target>
        </trans-unit>
        <trans-unit id="3b2efbff7f108d5a3dd7383a2f0e3a22b96a0b95" translate="yes" xml:space="preserve">
          <source>ast.NewScope()</source>
          <target state="translated">ast.NewScope()</target>
        </trans-unit>
        <trans-unit id="0adb216e4d94a3ee5529c0e5a9c370f04452e1a6" translate="yes" xml:space="preserve">
          <source>ast.Node</source>
          <target state="translated">ast.Node</target>
        </trans-unit>
        <trans-unit id="623b088bf971f65916f212c72e905cba2b1e8069" translate="yes" xml:space="preserve">
          <source>ast.NotNilFilter()</source>
          <target state="translated">ast.NotNilFilter()</target>
        </trans-unit>
        <trans-unit id="c8b5e6f4a48dae1e13b59cf334752c12dc83b6cf" translate="yes" xml:space="preserve">
          <source>ast.ObjKind</source>
          <target state="translated">ast.ObjKind</target>
        </trans-unit>
        <trans-unit id="f5c5c8806d07aa2e15518741ee67e202bf7dc08f" translate="yes" xml:space="preserve">
          <source>ast.ObjKind.String()</source>
          <target state="translated">ast.ObjKind.String()</target>
        </trans-unit>
        <trans-unit id="bae83b15a576524838f52dbcd6b8b9af033fbbc3" translate="yes" xml:space="preserve">
          <source>ast.Object</source>
          <target state="translated">ast.Object</target>
        </trans-unit>
        <trans-unit id="f9e118af1e4c93586afaf493c284454a19e8b2c2" translate="yes" xml:space="preserve">
          <source>ast.Object.Pos()</source>
          <target state="translated">ast.Object.Pos()</target>
        </trans-unit>
        <trans-unit id="567486dd6cb64bbe9c3106e27aeb037e6d45db3a" translate="yes" xml:space="preserve">
          <source>ast.Package</source>
          <target state="translated">ast.Package</target>
        </trans-unit>
        <trans-unit id="6e7c36460bfe0ea5135ce8fd31205777d5d60c12" translate="yes" xml:space="preserve">
          <source>ast.Package.End()</source>
          <target state="translated">ast.Package.End()</target>
        </trans-unit>
        <trans-unit id="ee7f2c2f5781253733dea51da1d4e081a9748e4c" translate="yes" xml:space="preserve">
          <source>ast.Package.Pos()</source>
          <target state="translated">ast.Package.Pos()</target>
        </trans-unit>
        <trans-unit id="9de5513df1193074b34ab02d7da8cb4e741796b1" translate="yes" xml:space="preserve">
          <source>ast.PackageExports()</source>
          <target state="translated">ast.PackageExports()</target>
        </trans-unit>
        <trans-unit id="139f231cb638880028d85320734757527c82ac60" translate="yes" xml:space="preserve">
          <source>ast.ParenExpr</source>
          <target state="translated">ast.ParenExpr</target>
        </trans-unit>
        <trans-unit id="d126b416ff09631be4e4c4f6c8d43bf9f7f3839b" translate="yes" xml:space="preserve">
          <source>ast.ParenExpr.End()</source>
          <target state="translated">ast.ParenExpr.End()</target>
        </trans-unit>
        <trans-unit id="04e88d4d23aafe693674ecc9cfe48d7a6c2cd129" translate="yes" xml:space="preserve">
          <source>ast.ParenExpr.Pos()</source>
          <target state="translated">ast.ParenExpr.Pos()</target>
        </trans-unit>
        <trans-unit id="fed56f5a529bbbdad3be7095347db89f91335f9e" translate="yes" xml:space="preserve">
          <source>ast.Print()</source>
          <target state="translated">ast.Print()</target>
        </trans-unit>
        <trans-unit id="ca1f91b57c98735d5e2724adaa27b0d01a506579" translate="yes" xml:space="preserve">
          <source>ast.RangeStmt</source>
          <target state="translated">ast.RangeStmt</target>
        </trans-unit>
        <trans-unit id="2b3df827347af65c5220ad0699cabf973a66c936" translate="yes" xml:space="preserve">
          <source>ast.RangeStmt.End()</source>
          <target state="translated">ast.RangeStmt.End()</target>
        </trans-unit>
        <trans-unit id="405f7515494c4809d791b345db37d8cd690219d6" translate="yes" xml:space="preserve">
          <source>ast.RangeStmt.Pos()</source>
          <target state="translated">ast.RangeStmt.Pos()</target>
        </trans-unit>
        <trans-unit id="5fc9b43eecceb9d8865e778bc56693be1bd04af5" translate="yes" xml:space="preserve">
          <source>ast.ReturnStmt</source>
          <target state="translated">ast.ReturnStmt</target>
        </trans-unit>
        <trans-unit id="3acfc24d47f39c0c780bdb543aee8a14e2f6b398" translate="yes" xml:space="preserve">
          <source>ast.ReturnStmt.End()</source>
          <target state="translated">ast.ReturnStmt.End()</target>
        </trans-unit>
        <trans-unit id="b25c08db40485d577c3cf52a7df5652307cfd082" translate="yes" xml:space="preserve">
          <source>ast.ReturnStmt.Pos()</source>
          <target state="translated">ast.ReturnStmt.Pos()</target>
        </trans-unit>
        <trans-unit id="3c4f3fcf698e11ad4ef0d1d860bc42d79c1d6335" translate="yes" xml:space="preserve">
          <source>ast.Scope</source>
          <target state="translated">ast.Scope</target>
        </trans-unit>
        <trans-unit id="a7f2353ab10d058df49025107d7f80776e4b06c2" translate="yes" xml:space="preserve">
          <source>ast.Scope.Insert()</source>
          <target state="translated">ast.Scope.Insert()</target>
        </trans-unit>
        <trans-unit id="f14b79f9fc6e1ae02e48c6c9b700065f052bd6ff" translate="yes" xml:space="preserve">
          <source>ast.Scope.Lookup()</source>
          <target state="translated">ast.Scope.Lookup()</target>
        </trans-unit>
        <trans-unit id="5b95cd8378b36dac9f7e271f67bf4ced58ac82b6" translate="yes" xml:space="preserve">
          <source>ast.Scope.String()</source>
          <target state="translated">ast.Scope.String()</target>
        </trans-unit>
        <trans-unit id="6ffc6174e0346c5eb0bd447799e285ceb2b67a7a" translate="yes" xml:space="preserve">
          <source>ast.SelectStmt</source>
          <target state="translated">ast.SelectStmt</target>
        </trans-unit>
        <trans-unit id="94ada0a282cd66c315cedca378236abe2b55e42b" translate="yes" xml:space="preserve">
          <source>ast.SelectStmt.End()</source>
          <target state="translated">ast.SelectStmt.End()</target>
        </trans-unit>
        <trans-unit id="60ab7074daf140138b422f554ad2e121cb70a88e" translate="yes" xml:space="preserve">
          <source>ast.SelectStmt.Pos()</source>
          <target state="translated">ast.SelectStmt.Pos()</target>
        </trans-unit>
        <trans-unit id="9fd58c075f3747285b6e7d6b057656caea4dfb15" translate="yes" xml:space="preserve">
          <source>ast.SelectorExpr</source>
          <target state="translated">ast.SelectorExpr</target>
        </trans-unit>
        <trans-unit id="aab656a4e3befeb695f9c09da789411215f9e81c" translate="yes" xml:space="preserve">
          <source>ast.SelectorExpr.End()</source>
          <target state="translated">ast.SelectorExpr.End()</target>
        </trans-unit>
        <trans-unit id="e24ee60e56bdb1d72f60635d1abb6a7fe6b3489c" translate="yes" xml:space="preserve">
          <source>ast.SelectorExpr.Pos()</source>
          <target state="translated">ast.SelectorExpr.Pos()</target>
        </trans-unit>
        <trans-unit id="e09be7cece8df7fea15336136ca6cd2b20b01ea0" translate="yes" xml:space="preserve">
          <source>ast.SendStmt</source>
          <target state="translated">ast.SendStmt</target>
        </trans-unit>
        <trans-unit id="8d8cfca6d27eb8024cf957aa9aab02ceb80f2a96" translate="yes" xml:space="preserve">
          <source>ast.SendStmt.End()</source>
          <target state="translated">ast.SendStmt.End()</target>
        </trans-unit>
        <trans-unit id="3cd30925ad3333b551bee09d78fdd41c6a5ce183" translate="yes" xml:space="preserve">
          <source>ast.SendStmt.Pos()</source>
          <target state="translated">ast.SendStmt.Pos()</target>
        </trans-unit>
        <trans-unit id="939932c50298b92117488c46251f13b11e7b47b9" translate="yes" xml:space="preserve">
          <source>ast.SliceExpr</source>
          <target state="translated">ast.SliceExpr</target>
        </trans-unit>
        <trans-unit id="f849fa118f03aa5fc3b7c517d60e19956c2dc69a" translate="yes" xml:space="preserve">
          <source>ast.SliceExpr.End()</source>
          <target state="translated">ast.SliceExpr.End()</target>
        </trans-unit>
        <trans-unit id="66822f43b70f862fe3d114dea48400685c5ea7be" translate="yes" xml:space="preserve">
          <source>ast.SliceExpr.Pos()</source>
          <target state="translated">ast.SliceExpr.Pos()</target>
        </trans-unit>
        <trans-unit id="4c2d369f7096af0d255334de26cf26af744bd73e" translate="yes" xml:space="preserve">
          <source>ast.SortImports()</source>
          <target state="translated">ast.SortImports()</target>
        </trans-unit>
        <trans-unit id="b05c11f1a97da11082ad9d609677eabadfeb85a6" translate="yes" xml:space="preserve">
          <source>ast.Spec</source>
          <target state="translated">ast.Spec</target>
        </trans-unit>
        <trans-unit id="647bd402923d8756230898c1ba5e288311b035c1" translate="yes" xml:space="preserve">
          <source>ast.StarExpr</source>
          <target state="translated">ast.StarExpr</target>
        </trans-unit>
        <trans-unit id="1964d6b8d522047a124104e27818c8e2359c3692" translate="yes" xml:space="preserve">
          <source>ast.StarExpr.End()</source>
          <target state="translated">ast.StarExpr.End()</target>
        </trans-unit>
        <trans-unit id="50986ca8f36ea9c3fa33e8b919d7f85757eac03f" translate="yes" xml:space="preserve">
          <source>ast.StarExpr.Pos()</source>
          <target state="translated">ast.StarExpr.Pos()</target>
        </trans-unit>
        <trans-unit id="86f0f7a23d86131b9800aa9a989271077f20efab" translate="yes" xml:space="preserve">
          <source>ast.Stmt</source>
          <target state="translated">ast.Stmt</target>
        </trans-unit>
        <trans-unit id="b0dd6f652568d7067080d2ca2b56d2c88a8de03e" translate="yes" xml:space="preserve">
          <source>ast.StructType</source>
          <target state="translated">ast.StructType</target>
        </trans-unit>
        <trans-unit id="1e930ddc8c4a5774d8053572f446cfe1f98baf5e" translate="yes" xml:space="preserve">
          <source>ast.StructType.End()</source>
          <target state="translated">ast.StructType.End()</target>
        </trans-unit>
        <trans-unit id="974d34f27a1b29932a04081b3b62b729e35d50ad" translate="yes" xml:space="preserve">
          <source>ast.StructType.Pos()</source>
          <target state="translated">ast.StructType.Pos()</target>
        </trans-unit>
        <trans-unit id="3bfefae46bec9a84aa0dcdec1fdb96fe9e8dc5e9" translate="yes" xml:space="preserve">
          <source>ast.SwitchStmt</source>
          <target state="translated">ast.SwitchStmt</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
