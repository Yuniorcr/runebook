<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="go">
    <body>
      <group id="go">
        <trans-unit id="043f79dd25246a384c5fa68242e8b0950e54d69e" translate="yes" xml:space="preserve">
          <source>The comparison functions work on any values whose type Go defines as comparable. For basic types such as integers, the rules are relaxed: size and exact type are ignored, so any integer value, signed or unsigned, may be compared with any other integer value. (The arithmetic value is compared, not the bit pattern, so all negative integers are less than all unsigned integers.) However, as usual, one may not compare an int with a float32 and so on.</source>
          <target state="translated">比较函数适用于 Go 定义为可比较类型的任何值。对于基本类型(如整数),这些规则被放宽了:大小和精确类型被忽略,因此任何整数值,无论是有符号还是无符号,都可以与任何其他整数值进行比较。(比较的是算术值,而不是位模式,因此所有负整数都小于所有无符号整数)。(比较的是算术值,而不是位模式,所以所有负整数都小于所有无符号整数。)但一样平常不得将一个int与float32等进行比较。</target>
        </trans-unit>
        <trans-unit id="53528cbdfa92cb465406c07ac6068163f15d8aff" translate="yes" xml:space="preserve">
          <source>The comparison functions work on basic types only (or named basic types, such as &quot;type Celsius float32&quot;). They implement the Go rules for comparison of values, except that size and exact type are ignored, so any integer value, signed or unsigned, may be compared with any other integer value. (The arithmetic value is compared, not the bit pattern, so all negative integers are less than all unsigned integers.) However, as usual, one may not compare an int with a float32 and so on.</source>
          <target state="translated">比较函数只适用于基本类型(或命名的基本类型,如 &quot;type Celsius float32&quot;)。它们实现了围棋的数值比较规则,除了忽略大小和精确类型之外,所以任何整数值,不管是有符号还是无符号,都可以和任何其他整数值进行比较。(比较的是算术值,而不是位模式,所以所有负整数都小于所有无符号整数)。但一样平常不得将int与float32等进行比较。</target>
        </trans-unit>
        <trans-unit id="3947ad8b82d2733c9797fbc944569005335da23c" translate="yes" xml:space="preserve">
          <source>The compiler handles a Pointer converted to a uintptr in the argument list of a call to a function implemented in assembly by arranging that the referenced allocated object, if any, is retained and not moved until the call completes, even though from the types alone it would appear that the object is no longer needed during the call.</source>
          <target state="translated">编译器处理调用汇编实现的函数的参数列表中的Pointer转换为uintptr时,会安排保留被引用的分配对象(如果有的话),直到调用完成为止,即使单从类型上看,该对象在调用期间似乎不再需要。</target>
        </trans-unit>
        <trans-unit id="fbe6ac33b06dc273e75926ad2490d8b3832a0214" translate="yes" xml:space="preserve">
          <source>The complex built-in function constructs a complex value from two floating-point values. The real and imaginary parts must be of the same size, either float32 or float64 (or assignable to them), and the return value will be the corresponding complex type (complex64 for float32, complex128 for float64).</source>
          <target state="translated">复杂内置函数从两个浮点值中构造一个复杂值。实部和虚部的大小必须相同,要么是float32,要么是float64(或可分配给它们),返回值将是相应的复数类型(float32为complex64,float64为complex128)。</target>
        </trans-unit>
        <trans-unit id="ef38d7c2bab871a13bc3d0543cc12b1189486358" translate="yes" xml:space="preserve">
          <source>The compression level can be DefaultCompression, NoCompression, HuffmanOnly or any integer value between BestSpeed and BestCompression inclusive. The error returned will be nil if the level is valid.</source>
          <target state="translated">压缩级别可以是DefaultCompression、NoCompression、HuffmanOnly或BestSpeed和BestCompression之间的任何整数值。如果压缩级别有效,返回的错误将是nil。</target>
        </trans-unit>
        <trans-unit id="0a1efe910d68e12343aa1a848eb28de270b6d379" translate="yes" xml:space="preserve">
          <source>The computed hash values depend only on the initial seed and the sequence of bytes provided to the Hash object, not on the way in which the bytes are provided. For example, the three sequences</source>
          <target state="translated">计算出的哈希值只取决于初始种子和提供给哈希对象的字节序列,而不取决于提供字节的方式。例如,三个序列</target>
        </trans-unit>
        <trans-unit id="351f67248e4d8a5518193363a02cfe1c83014012" translate="yes" xml:space="preserve">
          <source>The constant UpperLower has an otherwise impossible delta value.</source>
          <target state="translated">常量UpperLower有一个原本不可能的delta值。</target>
        </trans-unit>
        <trans-unit id="8c8706295858fb442cc0b27075b7f68668230e3c" translate="yes" xml:space="preserve">
          <source>The content's Seek method must work: ServeContent uses a seek to the end of the content to determine its size.</source>
          <target state="translated">内容的Seek方法必须工作。ServeContent使用寻求方法来确定内容的大小。</target>
        </trans-unit>
        <trans-unit id="7a49805d773fd718112af263e9a481b6533ee15e" translate="yes" xml:space="preserve">
          <source>The context function will be called with a single argument, a pointer to a struct:</source>
          <target state="translated">调用上下文函数时,只需要一个参数,即指向一个结构的指针。</target>
        </trans-unit>
        <trans-unit id="d756f1871d5d4f318cef847f3f882a9119bd1f8d" translate="yes" xml:space="preserve">
          <source>The conversion rules are:</source>
          <target state="translated">换算规则是:</target>
        </trans-unit>
        <trans-unit id="8b9249f4b562855e188c8c6e04ee31f39d350295" translate="yes" xml:space="preserve">
          <source>The copy built-in function copies elements from a source slice into a destination slice. (As a special case, it also will copy bytes from a string to a slice of bytes.) The source and destination may overlap. Copy returns the number of elements copied, which will be the minimum of len(src) and len(dst).</source>
          <target state="translated">复制内置函数将一个源片断中的元素复制到一个目标片断中。(作为一种特殊情况,它也会将一个字符串中的字节复制到一个字节分片中。)源片和目的片可以重叠。Copy 返回被复制的元素数量,它将是 len(src)和 len(dst)的最小值。</target>
        </trans-unit>
        <trans-unit id="7003f654a24cc0fe7e8417bb3241f59de9fe836b" translate="yes" xml:space="preserve">
          <source>The count determines the number of substrings to return:</source>
          <target state="translated">计数决定了要返回的子串数量。</target>
        </trans-unit>
        <trans-unit id="5dbb8e654b6fb0895661f0c315a08864e55ec239" translate="yes" xml:space="preserve">
          <source>The crypto/tls package only implements some countermeasures against Lucky13 attacks on CBC-mode encryption, and only on SHA1 variants. See &lt;a href=&quot;http://www.isg.rhul.ac.uk/tls/TLStiming.pdf&quot;&gt;http://www.isg.rhul.ac.uk/tls/TLStiming.pdf&lt;/a&gt; and &lt;a href=&quot;https://www.imperialviolet.org/2013/02/04/luckythirteen.html&quot;&gt;https://www.imperialviolet.org/2013/02/04/luckythirteen.html&lt;/a&gt;.</source>
          <target state="translated">crypto / tls软件包仅对CBC模式加密且仅对SHA1变体实施针对Lucky13攻击的一些对策。参见&lt;a href=&quot;http://www.isg.rhul.ac.uk/tls/TLStiming.pdf&quot;&gt;http://www.isg.rhul.ac.uk/tls/TLStiming.pdf&lt;/a&gt;和&lt;a href=&quot;https://www.imperialviolet.org/2013/02/04/luckythirteen.html&quot;&gt;https://www.imperialviolet.org/2013/02/04/luckythirteen.html&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3df95d2be07bff158f354793704b39fa0b17441d" translate="yes" xml:space="preserve">
          <source>The cryptographic operations are implemented using constant-time algorithms.</source>
          <target state="translated">加密运算采用恒时算法实现。</target>
        </trans-unit>
        <trans-unit id="7eab6b01982b7d5d0967ad563265ae830b1ba245" translate="yes" xml:space="preserve">
          <source>The cryptographic operations do not use constant-time algorithms.</source>
          <target state="translated">加密运算不使用恒时算法。</target>
        </trans-unit>
        <trans-unit id="27e1f3bd597aed109fd98be320131ab37e282b69" translate="yes" xml:space="preserve">
          <source>The currently supported key types are *rsa.PublicKey, *ecdsa.PublicKey and ed25519.PublicKey. pub must be a supported key type, and priv must be a crypto.Signer with a supported public key.</source>
          <target state="translated">目前支持的密钥类型有*rsa.PublicKey、*ecdsa.PublicKey和ed25519.PublicKey。 pub必须是支持的密钥类型,priv必须是支持公钥的crypto.Signer。</target>
        </trans-unit>
        <trans-unit id="5f866cd795794ee9a8943b941d8f0f21dd57c5d8" translate="yes" xml:space="preserve">
          <source>The d argument is the fs.DirEntry for the named path.</source>
          <target state="translated">参数d是命名路径的fs.DirEntry。</target>
        </trans-unit>
        <trans-unit id="7a6143ad908fa5d13101f2932405343a9fc3dd21" translate="yes" xml:space="preserve">
          <source>The debug parameter enables additional output. Passing debug=0 prints only the hexadecimal addresses that pprof needs. Passing debug=1 adds comments translating addresses to function names and line numbers, so that a programmer can read the profile without tools.</source>
          <target state="translated">debug参数允许额外的输出。通过debug=0可以只打印pprof需要的十六进制地址。传递 debug=1 会添加注释,将地址翻译成函数名和行号,这样程序员就可以在没有工具的情况下阅读配置文件。</target>
        </trans-unit>
        <trans-unit id="0fb33327b278ec03a78f307167cc6e36a7617010" translate="yes" xml:space="preserve">
          <source>The debug parameter enables additional output. Passing debug=0 writes the gzip-compressed protocol buffer described in &lt;a href=&quot;https://github.com/google/pprof/tree/master/proto#overview&quot;&gt;https://github.com/google/pprof/tree/master/proto#overview&lt;/a&gt;. Passing debug=1 writes the legacy text format with comments translating addresses to function names and line numbers, so that a programmer can read the profile without tools.</source>
          <target state="translated">debug参数启用其他输出。传递debug = 0会写入&lt;a href=&quot;https://github.com/google/pprof/tree/master/proto#overview&quot;&gt;https://github.com/google/pprof/tree/master/proto#overview中&lt;/a&gt;所述的gzip压缩协议缓冲区。传递debug = 1会写入带有注释的旧文本格式，该注释会将地址翻译为函数名称和行号，以便程序员无需工具即可读取配置文件。</target>
        </trans-unit>
        <trans-unit id="bcfadeab38a63378303009891c62ea08d3a9f648" translate="yes" xml:space="preserve">
          <source>The decision can also be forced while building the Go source tree by setting the netgo or netcgo build tag.</source>
          <target state="translated">在构建Go源代码树时,也可以通过设置netgo或netcgo构建标签来强制决定。</target>
        </trans-unit>
        <trans-unit id="e55a5ed5aee48109c8f556983bc2b6ba47049c1e" translate="yes" xml:space="preserve">
          <source>The decoded form returned by the Reader's Read method rewrites the &quot;\r\n&quot; line endings into the simpler &quot;\n&quot;, removes leading dot escapes if present, and stops with error io.EOF after consuming (and discarding) the end-of-sequence line.</source>
          <target state="translated">由Reader's Read方法返回的解码形式将&quot;\r\n &quot;行结尾重写成更简单的&quot;\n&quot;,如果存在,则删除前导点转义,并在消耗(并丢弃)序列末行后以错误io.EOF停止。</target>
        </trans-unit>
        <trans-unit id="ade9eaf300f62ddbbf2f36e130c2f06e8467d26d" translate="yes" xml:space="preserve">
          <source>The decoder introduces its own buffering and may read data from r beyond the JSON values requested.</source>
          <target state="translated">解码器引入了自己的缓冲,可能会从r中读取超出请求的JSON值的数据。</target>
        </trans-unit>
        <trans-unit id="500a9025cc154f7f8f86d7b577b23c5a4330caf0" translate="yes" xml:space="preserve">
          <source>The default HTTP/1.x and HTTP/2 ResponseWriter implementations support Flusher, but ResponseWriter wrappers may not. Handlers should always test for this ability at runtime.</source>
          <target state="translated">默认的 HTTP/1.x 和 HTTP/2 ResponseWriter 实现支持 Flusher,但 ResponseWriter 包装器可能不支持。处理程序应该总是在运行时测试这个能力。</target>
        </trans-unit>
        <trans-unit id="dbfff1190b706ff9c82ad5d939db53ac5e19b8d5" translate="yes" xml:space="preserve">
          <source>The default ResponseWriter for HTTP/1.x connections supports Hijacker, but HTTP/2 connections intentionally do not. ResponseWriter wrappers may also not support Hijacker. Handlers should always test for this ability at runtime.</source>
          <target state="translated">HTTP/1.x连接的默认ResponseWriter支持Hijacker,但HTTP/2连接故意不支持。ResponseWriter 包装器也可能不支持 Hijacker。处理程序应该总是在运行时测试这种能力。</target>
        </trans-unit>
        <trans-unit id="29a4bf6e98ccc92440a0810fcad76a8019aec7ff" translate="yes" xml:space="preserve">
          <source>The default behavior is to unlink the socket file only when package net created it. That is, when the listener and the underlying socket file were created by a call to Listen or ListenUnix, then by default closing the listener will remove the socket file. but if the listener was created by a call to FileListener to use an already existing socket file, then by default closing the listener will not remove the socket file.</source>
          <target state="translated">默认的行为是只有在包net创建套接字文件时才会解除链接。也就是说,当监听器和底层的套接字文件是通过调用Listen或ListenUnix来创建的,那么默认情况下关闭监听器就会删除套接字文件,但是如果监听器是通过调用FileListener来使用已经存在的套接字文件,那么默认情况下关闭监听器就不会删除套接字文件。</target>
        </trans-unit>
        <trans-unit id="f3bd4ca778e016b570e20fa99bcd057793129198" translate="yes" xml:space="preserve">
          <source>The default format for %v is:</source>
          <target state="translated">%v的默认格式是:</target>
        </trans-unit>
        <trans-unit id="e5fbfa4bdd17cdbfb6f18b5cea533902d960ee26" translate="yes" xml:space="preserve">
          <source>The default max idle connections is currently 2. This may change in a future release.</source>
          <target state="translated">目前默认的最大空闲连接数为2,这可能会在未来的版本中改变。</target>
        </trans-unit>
        <trans-unit id="385f08ab994be40fdde70d56e38ccb63bb65d078" translate="yes" xml:space="preserve">
          <source>The default set of command-line flags is controlled by top-level functions. The FlagSet type allows one to define independent sets of flags, such as to implement subcommands in a command-line interface. The methods of FlagSet are analogous to the top-level functions for the command-line flag set.</source>
          <target state="translated">默认的命令行标志集由顶层函数控制。FlagSet类型允许人们定义独立的标志集,例如在命令行接口中实现子命令。FlagSet的方法类似于命令行标志集的顶层函数。</target>
        </trans-unit>
        <trans-unit id="a05d93e44d2bb1f3518c258e77ecac2e52df5b7c" translate="yes" xml:space="preserve">
          <source>The define action names the template being created by providing a string constant. Here is a simple example:</source>
          <target state="translated">define操作通过提供一个字符串常量来命名正在创建的模板。下面是一个简单的例子。</target>
        </trans-unit>
        <trans-unit id="1752a2a854e41ac9841751567fab2d2b00d5fd9e" translate="yes" xml:space="preserve">
          <source>The defined file mode bits are the most significant bits of the FileMode. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added.</source>
          <target state="translated">定义的文件模式位是FileMode中最重要的位。九个最不重要的位是标准的Unix rwxrwxrwx权限。这些位的值应该被认为是公共API的一部分,可以在线协议或磁盘表示中使用:虽然可能会添加新的位,但它们不能被改变。</target>
        </trans-unit>
        <trans-unit id="5cff7ee8fa31e3f6a6739a2dee232b717a523c6f" translate="yes" xml:space="preserve">
          <source>The delete built-in function deletes the element with the specified key (m[key]) from the map. If m is nil or there is no such element, delete is a no-op.</source>
          <target state="translated">delete 内建函数从地图中删除指定键 (m[key])的元素。如果 m 为 nil 或没有这样的元素,delete 是一个 no-op。</target>
        </trans-unit>
        <trans-unit id="7be6f8c0500d37b62c7237cb3172e8612a1be7ae" translate="yes" xml:space="preserve">
          <source>The dictionary may be nil. If not, its contents should not be modified until the Writer is closed.</source>
          <target state="translated">字典可以是nil。如果不是,在关闭Writer之前,它的内容不应该被修改。</target>
        </trans-unit>
        <trans-unit id="4b0f9980f9925bb5ac741f7cd28fdb88d41be31b" translate="yes" xml:space="preserve">
          <source>The difference is that &amp;lsquo;image/*&amp;rsquo; embeds &amp;lsquo;image/.tempfile&amp;rsquo; while &amp;lsquo;image&amp;rsquo; does not.</source>
          <target state="translated">区别在于，&amp;ldquo; image / *&amp;rdquo;嵌入&amp;ldquo; image / .tempfile&amp;rdquo;，而&amp;ldquo; image&amp;rdquo;没有嵌入。</target>
        </trans-unit>
        <trans-unit id="88f694bd36bf5619a0472bfb05ef008949d8b1c4" translate="yes" xml:space="preserve">
          <source>The differences between WalkDirFunc compared to filepath.WalkFunc are:</source>
          <target state="translated">与filepath.WalkFunc相比,WalkDirFunc的区别在于:。</target>
        </trans-unit>
        <trans-unit id="bc9a068b7cdbaff9efc9114bb2316dc6eaf9165d" translate="yes" xml:space="preserve">
          <source>The direction of a channel is indicated by one of these constants.</source>
          <target state="translated">通道的方向由这些常数之一表示。</target>
        </trans-unit>
        <trans-unit id="46b217ce09d8bd67e6158257fb40490e88a671dd" translate="yes" xml:space="preserve">
          <source>The direction of a channel type is indicated by a bit mask including one or both of the following constants.</source>
          <target state="translated">通道类型的方向由包括以下一个或两个常数的位掩码表示:</target>
        </trans-unit>
        <trans-unit id="b6be0a4961d7acbc941fa11a19835445036b49c8" translate="yes" xml:space="preserve">
          <source>The directive must immediately precede a line containing the declaration of a single variable. Only blank lines and &amp;lsquo;//&amp;rsquo; line comments are permitted between the directive and the declaration.</source>
          <target state="translated">该指令必须紧接在包含单个变量声明的行之前。在指令和声明之间仅允许空行和'//'行注释。</target>
        </trans-unit>
        <trans-unit id="eee9b912ab49812886d0cf5f9ad11f8fdfc055f4" translate="yes" xml:space="preserve">
          <source>The directory and file are joined with Join, which may clean the directory name: if Walk is called with the root argument &quot;x/../dir&quot; and finds a file named &quot;a&quot; in that directory, the walk function will be called with argument &quot;dir/a&quot;, not &quot;x/../dir/a&quot;.</source>
          <target state="translated">用Join加入目录和文件,可能会清理目录名:如果用根参数 &quot;x/.../dir &quot;调用Walk,发现该目录下有一个名为 &quot;a &quot;的文件,则会用参数 &quot;dir/a &quot;调用Walk函数,而不是 &quot;x/.../dir/a&quot;。</target>
        </trans-unit>
        <trans-unit id="7dfb11306d6f3241074422bcaa067904172344cc" translate="yes" xml:space="preserve">
          <source>The directory is neither guaranteed to exist nor have accessible permissions.</source>
          <target state="translated">该目录既不保证存在,也没有访问权限。</target>
        </trans-unit>
        <trans-unit id="565d684eeda7e9edb8f7bb0c103897df1854d973" translate="yes" xml:space="preserve">
          <source>The documentation for http.Request.Write details which fields of req are included in the dump.</source>
          <target state="translated">http.Request.Write的文档详细说明了转储中包含了req的哪些字段。</target>
        </trans-unit>
        <trans-unit id="07211f6185f4e6de4337f341c2cdb69d4cc499c7" translate="yes" xml:space="preserve">
          <source>The documentation here focuses on the security features of the package. For information about how to program the templates themselves, see the documentation for text/template.</source>
          <target state="translated">这里的文档主要是关于软件包的安全功能。关于如何对模板本身进行编程的信息,请参阅text/template的文档。</target>
        </trans-unit>
        <trans-unit id="155a6f0a50ad424a0f77dec85fedb05aad3e6814" translate="yes" xml:space="preserve">
          <source>The driver interface has evolved over time. Drivers should implement Connector and DriverContext interfaces. The Connector.Connect and Driver.Open methods should never return ErrBadConn. ErrBadConn should only be returned from Validator, SessionResetter, or a query method if the connection is already in an invalid (e.g. closed) state.</source>
          <target state="translated">驱动程序接口随着时间的推移而发展。驱动程序应该实现Connector和DriverContext接口。Connector.Connect和Driver.Open方法绝不应该返回ErrBadConn。只有当连接已经处于无效(例如关闭)状态时,才应该从Validator、SessionResetter或查询方法返回ErrBadConn。</target>
        </trans-unit>
        <trans-unit id="d608ae58f506a273826ac24fbe8a6e832c7cfa18" translate="yes" xml:space="preserve">
          <source>The earlier index entries are the indices of the embedded fields implicitly traversed to get from (the type of) x to f, starting at embedding depth 0.</source>
          <target state="translated">前面的索引项是隐式遍历从(类型)x到f的嵌入字段的索引,从嵌入深度0开始。</target>
        </trans-unit>
        <trans-unit id="9969cd1fd12276c81b2d25b52e841cee1f38a6af" translate="yes" xml:space="preserve">
          <source>The earlier index entries are the indices of the embedded struct fields traversed to get to the found entry, starting at depth 0.</source>
          <target state="translated">前面的索引条目是为了得到找到的条目而遍历的嵌入结构域的索引,从深度0开始。</target>
        </trans-unit>
        <trans-unit id="55f7215f8e7a1256ecd44a2e72424fdc36866f77" translate="yes" xml:space="preserve">
          <source>The encoded form is:</source>
          <target state="translated">编码形式为:</target>
        </trans-unit>
        <trans-unit id="58738aa6dbb46f39a2d83f07741091a7022a1024" translate="yes" xml:space="preserve">
          <source>The encoding handles 4-byte chunks, using a special encoding for the last fragment, so Encode is not appropriate for use on individual blocks of a large data stream. Use NewEncoder() instead.</source>
          <target state="translated">编码处理4字节的块,对最后一个片段使用特殊的编码,所以Encode不适合用于大型数据流的单个块。使用NewEncoder()代替。</target>
        </trans-unit>
        <trans-unit id="352cf3ce7f63c6b9e4ef698575b243f2f7eab5f4" translate="yes" xml:space="preserve">
          <source>The encoding of each struct field can be customized by the format string stored under the &quot;json&quot; key in the struct field's tag. The format string gives the name of the field, possibly followed by a comma-separated list of options. The name may be empty in order to specify options without overriding the default field name.</source>
          <target state="translated">每个结构体字段的编码可以通过存储在结构体字段标签中 &quot;json &quot;键下的格式字符串来定制。格式字符串给出了字段的名称,后面可能是一个以逗号分隔的选项列表。为了在不覆盖默认字段名的情况下指定选项,名称可以为空。</target>
        </trans-unit>
        <trans-unit id="17b6791f4c87db95fbf5fcc1580f710e0b98bcc7" translate="yes" xml:space="preserve">
          <source>The encoding pads the output to a multiple of 4 bytes, so Encode is not appropriate for use on individual blocks of a large data stream. Use NewEncoder() instead.</source>
          <target state="translated">编码将输出填充到4字节的倍数,因此Encode不适合用于大型数据流的单个块。使用NewEncoder()代替。</target>
        </trans-unit>
        <trans-unit id="f9b92d6b313993a8570c418851ae0a82ee1d08b2" translate="yes" xml:space="preserve">
          <source>The encoding pads the output to a multiple of 8 bytes, so Encode is not appropriate for use on individual blocks of a large data stream. Use NewEncoder() instead.</source>
          <target state="translated">编码将输出填充到8字节的倍数,因此Encode不适合用于大型数据流的单个块。使用NewEncoder()代替。</target>
        </trans-unit>
        <trans-unit id="f21e6b7ab20b84c2608ae859489552989b9c9ded" translate="yes" xml:space="preserve">
          <source>The entire test file is presented as the example when it contains a single example function, at least one other function, type, variable, or constant declaration, and no test or benchmark functions.</source>
          <target state="translated">当整个测试文件包含一个示例函数、至少一个其他函数、类型、变量或常量声明,并且没有测试或基准函数时,整个测试文件将作为示例呈现。</target>
        </trans-unit>
        <trans-unit id="8a5b41cf040dd894c5f5818385e864bb8f5f4256" translate="yes" xml:space="preserve">
          <source>The environment values may be either a complete URL or a &quot;host[:port]&quot;, in which case the &quot;http&quot; scheme is assumed. An error is returned if the value is a different form.</source>
          <target state="translated">环境值可以是一个完整的URL,也可以是 &quot;host[:port]&quot;,在这种情况下,假定使用 &quot;http &quot;方案。如果值是不同的形式,将返回一个错误。</target>
        </trans-unit>
        <trans-unit id="118f5185e20d76d2e409557c089e1ce07b52abd5" translate="yes" xml:space="preserve">
          <source>The err argument reports an error related to path, signaling that Walk will not walk into that directory. The function can decide how to handle that error; as described earlier, returning the error will cause Walk to stop walking the entire tree.</source>
          <target state="translated">err参数报告一个与路径有关的错误,标志着Walk将不会走入该目录。该函数可以决定如何处理该错误;如前所述,返回该错误将导致Walk停止行走整个树。</target>
        </trans-unit>
        <trans-unit id="282f6346653700d9616b9fe704e3acbbfd78027c" translate="yes" xml:space="preserve">
          <source>The err argument reports an error related to path, signaling that WalkDir will not walk into that directory. The function can decide how to handle that error; as described earlier, returning the error will cause WalkDir to stop walking the entire tree.</source>
          <target state="translated">err参数报告一个与路径有关的错误,标志着WalkDir将不会走入该目录。该函数可以决定如何处理该错误;如前所述,返回该错误将导致WalkDir停止行走整个树。</target>
        </trans-unit>
        <trans-unit id="63d88a909a5214b04c717d2600360e2bf8c34633" translate="yes" xml:space="preserve">
          <source>The error built-in interface type is the conventional interface for representing an error condition, with the nil value representing no error.</source>
          <target state="translated">错误内置接口类型是表示错误条件的常规接口,nil值代表没有错误。</target>
        </trans-unit>
        <trans-unit id="057113f0f11fb7ab423f9c5529d153f0951fafc6" translate="yes" xml:space="preserve">
          <source>The error is EOF only if no bytes were read. If an EOF happens after reading some but not all the bytes, Read returns ErrUnexpectedEOF.</source>
          <target state="translated">只有在没有读到字节的情况下,才会发生EOF错误。如果在读取部分但不是全部字节后发生EOF,Read返回ErrUnexpectedEOF。</target>
        </trans-unit>
        <trans-unit id="eeed3acdc77455956d53c59d08490cc51e5c519c" translate="yes" xml:space="preserve">
          <source>The error result returned by the function controls how Walk continues. If the function returns the special value SkipDir, Walk skips the current directory (path if info.IsDir() is true, otherwise path's parent directory). Otherwise, if the function returns a non-nil error, Walk stops entirely and returns that error.</source>
          <target state="translated">函数返回的错误结果控制着Walk如何继续。如果函数返回特殊值SkipDir,Walk会跳过当前目录(如果info.IsDir()为真,则跳过path的父目录)。否则,如果函数返回一个非零的错误,Walk将完全停止并返回该错误。</target>
        </trans-unit>
        <trans-unit id="0bdf1212e16d5b6273e524308d0d3b1c562326fa" translate="yes" xml:space="preserve">
          <source>The error result returned by the function controls how WalkDir continues. If the function returns the special value SkipDir, WalkDir skips the current directory (path if d.IsDir() is true, otherwise path's parent directory). Otherwise, if the function returns a non-nil error, WalkDir stops entirely and returns that error.</source>
          <target state="translated">函数返回的错误结果控制WalkDir如何继续。如果函数返回特殊值SkipDir,WalkDir会跳过当前目录(如果d.IsDir()为真,则跳过path的父目录)。否则,如果函数返回一个非零的错误,WalkDir将完全停止并返回该错误。</target>
        </trans-unit>
        <trans-unit id="53b8936240ed1387970343e072546b9e5c4ce38c" translate="yes" xml:space="preserve">
          <source>The errors that ParseComplex returns have concrete type *NumError and include err.Num = s.</source>
          <target state="translated">ParseComplex返回的错误具有具体的类型*NumError,并包括err.Num=s。</target>
        </trans-unit>
        <trans-unit id="e19a9195a1344f79f24fd7f396a97d73332aa946" translate="yes" xml:space="preserve">
          <source>The errors that ParseFloat returns have concrete type *NumError and include err.Num = s.</source>
          <target state="translated">ParseFloat返回的错误有具体的类型*NumError,包括err.Num=s。</target>
        </trans-unit>
        <trans-unit id="235cee0ee469905c73061c3ebbf12b0afd87e749" translate="yes" xml:space="preserve">
          <source>The errors that ParseInt returns have concrete type *NumError and include err.Num = s. If s is empty or contains invalid digits, err.Err = ErrSyntax and the returned value is 0; if the value corresponding to s cannot be represented by a signed integer of the given size, err.Err = ErrRange and the returned value is the maximum magnitude integer of the appropriate bitSize and sign.</source>
          <target state="translated">ParseInt返回的错误有具体的类型*NumError,包括err.Num=s,如果s为空或包含无效数字,err.Err=ErrSyntax,返回值为0;如果s对应的值不能用给定大小的有符号整数表示,err.Err=ErrRange,返回值为相应位数大小和符号的最大幅度整数。</target>
        </trans-unit>
        <trans-unit id="1079b4c215daaeaddfd42a5c24ae40421a24ca31" translate="yes" xml:space="preserve">
          <source>The exact method of division of a binary into separate Objs is an internal detail of the symbol table format.</source>
          <target state="translated">将二进制划分为独立的Objs的具体方法是符号表格式的内部细节。</target>
        </trans-unit>
        <trans-unit id="704442846624164254cefb0621f909b9f8e7b255" translate="yes" xml:space="preserve">
          <source>The executable example for Time.Format demonstrates the working of the layout string in detail and is a good reference.</source>
          <target state="translated">Time.Format的可执行示例详细演示了布局字符串的工作原理,是一个很好的参考。</target>
        </trans-unit>
        <trans-unit id="d1e6774ae13e892b5b495469c8177e657ea29b91" translate="yes" xml:space="preserve">
          <source>The execution trace captures a wide range of execution events such as goroutine creation/blocking/unblocking, syscall enter/exit/block, GC-related events, changes of heap size, processor start/stop, etc. A precise nanosecond-precision timestamp and a stack trace is captured for most events. The generated trace can be interpreted using `go tool trace`.</source>
          <target state="translated">执行跟踪可以捕获广泛的执行事件,如goroutine的创建/阻塞/取消阻塞,系统调用进入/退出/阻塞,GC相关事件,堆大小的变化,处理器的启动/停止等。大多数事件都会被捕获一个精确的纳秒级时间戳和一个堆栈跟踪。生成的跟踪可以用 &quot;go tool trace &quot;来解释。</target>
        </trans-unit>
        <trans-unit id="0bb8da556b82de3d2273cd84d139d0610336a88a" translate="yes" xml:space="preserve">
          <source>The familiar base-setting prefixes 0b (binary), 0o and 0 (octal), and 0x (hexadecimal) are accepted when scanning integers without a format or with the %v verb, as are digit-separating underscores.</source>
          <target state="translated">当扫描没有格式的整数或使用%v动词时,可以接受熟悉的定基前缀0b(二进制)、0o和0(八进制)以及0x(十六进制),也可以接受以数字分隔的下划线。</target>
        </trans-unit>
        <trans-unit id="f9ffee1670410a5e7cd11d5f1bee248ae5a136bc" translate="yes" xml:space="preserve">
          <source>The field semantics differ slightly between client and server usage. In addition to the notes on the fields below, see the documentation for Request.Write and RoundTripper.</source>
          <target state="translated">字段的语义在客户端和服务器的用法上略有不同。除了下面关于字段的说明外,请看Request.Write和RoundTripper的文档。</target>
        </trans-unit>
        <trans-unit id="055e51145f588ea85435a4c1863b09a1b1141496" translate="yes" xml:space="preserve">
          <source>The file name table of a compilation unit is not fixed. Files returns the file table as of the current position in the line table. This may contain more entries than the file table at an earlier position in the line table, though existing entries never change.</source>
          <target state="translated">编译单元的文件名表不固定。Files返回行表中当前位置的文件表。它可能比行表中较早位置的文件表包含更多的条目,尽管现有的条目不会改变。</target>
        </trans-unit>
        <trans-unit id="bc18f2dd0c8c98e57212ed20f1a2ef2dc2747c6d" translate="yes" xml:space="preserve">
          <source>The file's data can then be read into a slice of bytes. Read and Write take their byte counts from the length of the argument slice.</source>
          <target state="translated">然后文件的数据可以被读入一个字节片。读和写从参数片的长度中提取字节数。</target>
        </trans-unit>
        <trans-unit id="bf3df07f08dd9391973ec022887d04b86f02f1b9" translate="yes" xml:space="preserve">
          <source>The filepath package uses either forward slashes or backslashes, depending on the operating system. To process paths such as URLs that always use forward slashes regardless of the operating system, see the path package.</source>
          <target state="translated">文件路径包根据操作系统的不同,使用正斜线或反斜线。要处理诸如URL等无论操作系统如何都使用正斜线的路径,请参阅路径包。</target>
        </trans-unit>
        <trans-unit id="44d9396e877785e7c01e9d43d99cf0cdefb65dc4" translate="yes" xml:space="preserve">
          <source>The files are walked in lexical order, which makes the output deterministic but requires Walk to read an entire directory into memory before proceeding to walk that directory.</source>
          <target state="translated">文件是按照词法顺序走的,这使得输出是确定性的,但需要Walk将整个目录读入内存,然后再继续走该目录。</target>
        </trans-unit>
        <trans-unit id="d47cce3bdf876fa4c8fd7554f61be344c06ff401" translate="yes" xml:space="preserve">
          <source>The files are walked in lexical order, which makes the output deterministic but requires WalkDir to read an entire directory into memory before proceeding to walk that directory.</source>
          <target state="translated">文件是按照词法顺序走的,这使得输出是确定性的,但需要WalkDir将整个目录读入内存,然后再继续走该目录。</target>
        </trans-unit>
        <trans-unit id="e2a5de21556a23ce2ab6268f51afe1d5e198e5ff" translate="yes" xml:space="preserve">
          <source>The finalizer is scheduled to run at some arbitrary time after the program can no longer reach the object to which obj points. There is no guarantee that finalizers will run before a program exits, so typically they are useful only for releasing non-memory resources associated with an object during a long-running program. For example, an os.File object could use a finalizer to close the associated operating system file descriptor when a program discards an os.File without calling Close, but it would be a mistake to depend on a finalizer to flush an in-memory I/O buffer such as a bufio.Writer, because the buffer would not be flushed at program exit.</source>
          <target state="translated">定盘器被安排在程序无法再到达obj指向的对象后的某个任意时间运行。不能保证最终确定器会在程序退出之前运行,所以通常它们只在长期运行的程序中释放与对象相关的非内存资源时有用。例如,一个 os.File 对象可以在程序丢弃 os.File 而不调用 Close 时,使用定标器来关闭相关的操作系统文件描述符,但是依靠定标器来刷新内存中的 I/O 缓冲区(如 bufio.Writer)是错误的,因为缓冲区不会在程序退出时被刷新。</target>
        </trans-unit>
        <trans-unit id="b1e301ef4e8e6bbc26fb8b640366f5d912e010bd" translate="yes" xml:space="preserve">
          <source>The first call to ReadContinuedLine will return &quot;Line 1 continued...&quot; and the second will return &quot;Line 2&quot;.</source>
          <target state="translated">第一次调用ReadContinuedLine将返回 &quot;Line 1 continued...&quot;,第二次将返回 &quot;Line 2&quot;。</target>
        </trans-unit>
        <trans-unit id="aa248e4cf567dddf42fcb3d7320a5fbdd025b032" translate="yes" xml:space="preserve">
          <source>The first call will cache the current user information. Subsequent calls will return the cached value and will not reflect changes to the current user.</source>
          <target state="translated">第一次调用将缓存当前用户信息。随后的调用将返回缓存的值,不会反映当前用户的变化。</target>
        </trans-unit>
        <trans-unit id="da786a1e6a510514415594e5971ba9d3b0ef0c66" translate="yes" xml:space="preserve">
          <source>The first key will be used when creating new tickets, while all keys can be used for decrypting tickets. It is safe to call this function while the server is running in order to rotate the session ticket keys. The function will panic if keys is empty.</source>
          <target state="translated">第一个密钥将在创建新票据时使用,而所有密钥都可以用于解密票据。在服务器运行的时候调用这个函数是安全的,以便轮换会话票据密钥。如果keys为空,该函数会发出警报。</target>
        </trans-unit>
        <trans-unit id="f9bea105d5515e425130c674b9a6d60024d04428" translate="yes" xml:space="preserve">
          <source>The first step to profiling a Go program is to enable profiling. Support for profiling benchmarks built with the standard testing package is built into go test. For example, the following command runs benchmarks in the current directory and writes the CPU and memory profiles to cpu.prof and mem.prof:</source>
          <target state="translated">对Go程序进行剖析的第一步是启用剖析。go test中内置了对标准测试包所构建的基准的剖析支持。例如,以下命令在当前目录下运行基准,并将CPU和内存配置文件写入cpu.prof和mem.prof中。</target>
        </trans-unit>
        <trans-unit id="436dd80ca68673a729fce026c246571c6f61d421" translate="yes" xml:space="preserve">
          <source>The first time the function is called for a particular traceback, all the fields except PC will be 0. The function should fill in the other fields if possible, setting them to 0/nil if the information is not available. The Data field may be used to store any useful information across calls. The More field should be set to non-zero if there is more information for this PC, zero otherwise. If More is set non-zero, the function will be called again with the same PC, and may return different information (this is intended for use with inlined functions). If More is zero, the function will be called with the next PC value in the traceback. When the traceback is complete, the function will be called once more with PC set to zero; this may be used to free any information. Each call will leave the fields of the struct set to the same values they had upon return, except for the PC field when the More field is zero. The function must not keep a copy of the struct pointer between calls.</source>
          <target state="translated">第一次调用该函数时,除了PC外,所有字段都为0,如果可能的话,该函数应该填写其他字段,如果信息不可用,则将其设置为0/nil。数据字段可用于存储跨调用的任何有用信息。如果该PC有更多信息,则More字段应设置为非零,否则为零。如果More字段被设置为非零,函数将对同一台PC再次调用,并可能返回不同的信息(这是为了与内联函数一起使用)。如果More为零,函数将用回溯中的下一个PC值进行调用。当回溯完成后,函数将被再次调用,PC设置为0;这可以用来释放任何信息。每次调用都会使结构体的字段设置为返回时的相同值,但当More字段为零时,PC字段除外。该函数在两次调用之间不得保留结构体指针的副本。</target>
        </trans-unit>
        <trans-unit id="1c12332b1a7f816e653faac5972323a1a86f4075" translate="yes" xml:space="preserve">
          <source>The fmt package's Errorf function lets us use the package's formatting features to create descriptive error messages.</source>
          <target state="translated">fmt软件包的Errorf功能让我们可以使用软件包的格式化功能来创建描述性的错误信息。</target>
        </trans-unit>
        <trans-unit id="daed29ba07a438b86a35f4ffceadf0ee0b2962c4" translate="yes" xml:space="preserve">
          <source>The following environment variables ($name or %name%, depending on the host operating system) control the run-time behavior of Go programs. The meanings and use may change from release to release.</source>
          <target state="translated">以下环境变量($name 或 %name%,取决于主机操作系统)控制围棋程序的运行时行为。这些变量的含义和用途可能会随着版本的不同而改变。</target>
        </trans-unit>
        <trans-unit id="d76a76a5baf9188ebac1a65a2793d054e97d3403" translate="yes" xml:space="preserve">
          <source>The following example shows how to maintain a scalable frequently read, but infrequently updated data structure using copy-on-write idiom.</source>
          <target state="translated">下面的例子展示了如何使用copy-on-write成语来维护一个可扩展的经常读取,但不经常更新的数据结构。</target>
        </trans-unit>
        <trans-unit id="3f0a6fe70878d3ed973c5f4c4f9e11a4b37e3d2a" translate="yes" xml:space="preserve">
          <source>The following example shows how to use Value for periodic program config updates and propagation of the changes to worker goroutines.</source>
          <target state="translated">下面的例子显示了如何使用Value进行周期性的程序配置更新,并将变化传播给worker goroutine。</target>
        </trans-unit>
        <trans-unit id="2cccb14470014df050daea92c16a16fd189e8367" translate="yes" xml:space="preserve">
          <source>The following forms are permitted:</source>
          <target state="translated">允许采用以下形式:</target>
        </trans-unit>
        <trans-unit id="f535af253987553534ec7b604b13bea0bafaf89a" translate="yes" xml:space="preserve">
          <source>The following key types are currently supported: *rsa.PrivateKey, *ecdsa.PrivateKey and ed25519.PrivateKey. Unsupported key types result in an error.</source>
          <target state="translated">目前支持以下密钥类型。*rsa.PrivateKey、*ecdsa.PrivateKey和ed25519.PrivateKey。不支持的密钥类型会导致错误。</target>
        </trans-unit>
        <trans-unit id="db7a430d5590cf9adf90b727249460131ab84e28" translate="yes" xml:space="preserve">
          <source>The following key types are currently supported: *rsa.PublicKey, *ecdsa.PublicKey and ed25519.PublicKey. Unsupported key types result in an error.</source>
          <target state="translated">目前支持以下密钥类型。*rsa.PublicKey、*ecdsa.PublicKey和ed25519.PublicKey。不支持的密钥类型会导致一个错误。</target>
        </trans-unit>
        <trans-unit id="575dc13df3822635a20233f0d934b2828c4cbcc1" translate="yes" xml:space="preserve">
          <source>The following patterns involving Pointer are valid. Code not using these patterns is likely to be invalid today or to become invalid in the future. Even the valid patterns below come with important caveats.</source>
          <target state="translated">以下涉及Pointer的模式是有效的。没有使用这些模式的代码很可能在今天是无效的,或者在将来也是无效的。即使是下面的有效模式也有重要的注意事项。</target>
        </trans-unit>
        <trans-unit id="ea1b5d42ec809a44272262968add764fd0382aa5" translate="yes" xml:space="preserve">
          <source>The following table captures the capabilities of each format:</source>
          <target state="translated">下表列出了每种格式的能力。</target>
        </trans-unit>
        <trans-unit id="00ec28c9d7b575a36a11e5441e71a7350e3c8790" translate="yes" xml:space="preserve">
          <source>The following tags on struct fields have special meaning to Unmarshal:</source>
          <target state="translated">以下结构字段的标签对Unmarshal有特殊意义。</target>
        </trans-unit>
        <trans-unit id="b74a12e0ee03ebdd96a1e5698ef65e80645b4c11" translate="yes" xml:space="preserve">
          <source>The format fmt and precision prec have the same meaning as in FormatFloat. It rounds the result assuming that the original was obtained from a complex value of bitSize bits, which must be 64 for complex64 and 128 for complex128.</source>
          <target state="translated">格式fmt和精度prec的含义与FormatFloat中的相同。它对结果进行四舍五入,假设原件是从位数位的复杂值中得到的,对于复杂64来说必须是64,对于复杂128来说必须是128。</target>
        </trans-unit>
        <trans-unit id="89924ba6250a79536c8a80bb6ca7f28f4193a60a" translate="yes" xml:space="preserve">
          <source>The format fmt is one of 'b' (-ddddp&amp;plusmn;ddd, a binary exponent), 'e' (-d.dddde&amp;plusmn;dd, a decimal exponent), 'E' (-d.ddddE&amp;plusmn;dd, a decimal exponent), 'f' (-ddd.dddd, no exponent), 'g' ('e' for large exponents, 'f' otherwise), 'G' ('E' for large exponents, 'f' otherwise), 'x' (-0xd.ddddp&amp;plusmn;ddd, a hexadecimal fraction and binary exponent), or 'X' (-0Xd.ddddP&amp;plusmn;ddd, a hexadecimal fraction and binary exponent).</source>
          <target state="translated">格式fmt是'b'（-ddddp&amp;plusmn;ddd，二进制指数），'e'（-d.dddde&amp;plusmn;dd，十进制指数），'E'（-d.ddddE&amp;plusmn;dd，十进制指数）之一），&amp;ldquo; f&amp;rdquo;（-ddd.dddd，无指数），&amp;ldquo; g&amp;rdquo;（&amp;ldquo; e&amp;rdquo;代表大指数，否则为&amp;ldquo; f&amp;rdquo;），&amp;ldquo; G&amp;rdquo;（&amp;ldquo; E&amp;rdquo;代表大指数，否则为&amp;ldquo; f&amp;rdquo;），&amp;ldquo; x'（-0xd.ddddp&amp;plusmn;ddd，十六进制分数和二进制指数）或'X'（-0Xd.ddddP&amp;plusmn;ddd，十六进制分数和二进制指数）。</target>
        </trans-unit>
        <trans-unit id="f76288ef40c91d2e63963863e41869428543cdec" translate="yes" xml:space="preserve">
          <source>The formats 2, _2, and 02 are unpadded, space-padded, and zero-padded day of month. The formats __2 and 002 are space-padded and zero-padded three-character day of year; there is no unpadded day of year format.</source>
          <target state="translated">格式2、_2、02为无垫、有空格、零垫的月日。格式 __2 和 002 是空格填充和零填充的三字符年月日,没有无填充的年月日格式。</target>
        </trans-unit>
        <trans-unit id="1f639fab95b9f7e1b599aa2a265c8aee60d79d31" translate="yes" xml:space="preserve">
          <source>The formfeed character acts like a newline but it also terminates all columns in the current line (effectively calling Flush). Tab- terminated cells in the next line start new columns. Unless found inside an HTML tag or inside an escaped text segment, formfeed characters appear as newlines in the output.</source>
          <target state="translated">formfeed字符的作用类似于换行,但它也终止了当前行中的所有列(有效地调用Flush)。下一行中Tab终止的单元格开始新的列。除非在HTML标签内或转义文本段内发现,否则formfeed字符在输出中会作为换行符出现。</target>
        </trans-unit>
        <trans-unit id="6c966e528430f5e8f847d49a893afb0bf98faff4" translate="yes" xml:space="preserve">
          <source>The function is never called with an empty data slice unless atEOF is true. If atEOF is true, however, data may be non-empty and, as always, holds unprocessed text.</source>
          <target state="translated">除非 atEOF 为真,否则该函数不会在数据片为空的情况下被调用。但是,如果atEOF为真,数据可能是非空的,并且一如既往地保存未处理的文本。</target>
        </trans-unit>
        <trans-unit id="bb0e0b68d3018d9e09f97b972052414d315bce69" translate="yes" xml:space="preserve">
          <source>The function may return early (before the entire result is written) and return a formatting error, for instance due to an incorrect AST.</source>
          <target state="translated">该函数可能会提前返回(在整个结果写入之前),并返回一个格式化错误,例如由于一个错误的AST。</target>
        </trans-unit>
        <trans-unit id="f82da77fd5615642bd9b732fd9350b4315a5dea8" translate="yes" xml:space="preserve">
          <source>The function panics if the provided interface is not a slice.</source>
          <target state="translated">如果所提供的接口不是分片,该函数就会恐慌。</target>
        </trans-unit>
        <trans-unit id="4a5f1ee976b1b1f94f517d27ee9603ea7e455c85" translate="yes" xml:space="preserve">
          <source>The function panics if z &amp;lt; 0. The value of z is undefined in that case.</source>
          <target state="translated">如果z &amp;lt;0，函数将出现紧急情况。在这种情况下，z的值不确定。</target>
        </trans-unit>
        <trans-unit id="d83c73a08df2f74bc57a61017e163cb8c0547bd2" translate="yes" xml:space="preserve">
          <source>The functions in this package allow a program to change the way Go programs handle signals.</source>
          <target state="translated">本包中的函数允许程序改变围棋程序处理信号的方式。</target>
        </trans-unit>
        <trans-unit id="c621ec21270aea7b19125c0f31ddb234d896d492" translate="yes" xml:space="preserve">
          <source>The fundamental interface is called Image. An Image contains colors, which are described in the image/color package.</source>
          <target state="translated">基本的接口叫做Image。一个Image包含颜色,这些颜色在image/color包中有描述。</target>
        </trans-unit>
        <trans-unit id="3e95d4d070ede79d500e36cf5c238c24c3001c9d" translate="yes" xml:space="preserve">
          <source>The gc runtime imposes a limit of 64 kB on channel element types. If t's size is equal to or exceeds this limit, ChanOf panics.</source>
          <target state="translated">gc运行时对通道元素类型施加了64 kB的限制,如果t的大小等于或超过这个限制,ChanOf就会惊慌失措。如果t的大小等于或超过这个限制,ChanOf就会崩溃。</target>
        </trans-unit>
        <trans-unit id="0b2d97be3dbe373d310641088f98b283534b1dcf" translate="yes" xml:space="preserve">
          <source>The general form represented is:</source>
          <target state="translated">代表的一般形式是:</target>
        </trans-unit>
        <trans-unit id="e818a1eefc582415dc190e3c644893b44536faa0" translate="yes" xml:space="preserve">
          <source>The gzip file stores a header giving metadata about the compressed file. That header is exposed as the fields of the Writer and Reader structs.</source>
          <target state="translated">gzip文件存储了一个头,给出了压缩文件的元数据。这个头以Writer和Reader结构的字段形式出现。</target>
        </trans-unit>
        <trans-unit id="d55115d1e7ac93246c076c18ab9827900516047e" translate="yes" xml:space="preserve">
          <source>The handler is typically nil, in which case the DefaultServeMux is used.</source>
          <target state="translated">该处理程序通常为nil,在这种情况下,使用DefaultServeMux。</target>
        </trans-unit>
        <trans-unit id="19708f111db26407005495f3eafb1c4b25430791" translate="yes" xml:space="preserve">
          <source>The handling of spaces and newlines differs from that of C's scanf family: in C, newlines are treated as any other space, and it is never an error when a run of spaces in the format string finds no spaces to consume in the input.</source>
          <target state="translated">对空格和换行的处理与C语言的scanf系列不同:在C语言中,换行与其他空格一样,当格式字符串中的空格运行时,发现输入中没有空格消耗时,绝不会出错。</target>
        </trans-unit>
        <trans-unit id="1093dd8291a3801884d5894ab223242420be1682" translate="yes" xml:space="preserve">
          <source>The hash functions are collision-resistant but not cryptographically secure. (See crypto/sha256 and crypto/sha512 for cryptographic use.)</source>
          <target state="translated">哈希函数是抗碰撞的,但不是密码学上的安全。关于密码学的使用,请参见crypto/sha256和crypto/sha512)。</target>
        </trans-unit>
        <trans-unit id="9eef6c0a2cccc47289259f60f06bd6983ba13a4d" translate="yes" xml:space="preserve">
          <source>The hash functions are not cryptographically secure. (See crypto/sha256 and crypto/sha512 for cryptographic use.)</source>
          <target state="translated">哈希函数在密码学上是不安全的。(关于密码学用途,请参见crypto/sha256和crypto/sha512)。</target>
        </trans-unit>
        <trans-unit id="5be9b697fdd2e64517c87254bb1809a8bac3a286" translate="yes" xml:space="preserve">
          <source>The hash value of a given byte sequence is consistent within a single process, but will be different in different processes.</source>
          <target state="translated">一个给定字节序列的哈希值在单个进程中是一致的,但在不同的进程中会有所不同。</target>
        </trans-unit>
        <trans-unit id="e507edab6e88a1637c49a21b0db27e0ccae398e0" translate="yes" xml:space="preserve">
          <source>The heap dump format is defined at &lt;a href=&quot;https://golang.org/s/go15heapdump&quot;&gt;https://golang.org/s/go15heapdump&lt;/a&gt;.</source>
          <target state="translated">堆转储格式在&lt;a href=&quot;https://golang.org/s/go15heapdump&quot;&gt;https://golang.org/s/go15heapdump&lt;/a&gt;上定义。</target>
        </trans-unit>
        <trans-unit id="8b009325b4464d415a87b0e6547346de038d0c47" translate="yes" xml:space="preserve">
          <source>The heap profile reports statistics as of the most recently completed garbage collection; it elides more recent allocation to avoid skewing the profile away from live data and toward garbage. If there has been no garbage collection at all, the heap profile reports all known allocations. This exception helps mainly in programs running without garbage collection enabled, usually for debugging purposes.</source>
          <target state="translated">堆配置文件报告了最近完成的垃圾收集的统计数据;它省略了最近的分配,以避免使配置文件偏离实时数据而偏向垃圾。如果根本没有进行过垃圾收集,堆配置文件会报告所有已知的分配情况。这种例外情况主要是在没有启用垃圾收集的情况下运行的程序中起帮助作用,通常是为了调试的目的。</target>
        </trans-unit>
        <trans-unit id="421272feeab82226233835220df71bd5575dfeaf" translate="yes" xml:space="preserve">
          <source>The heap profile tracks both the allocation sites for all live objects in the application memory and for all objects allocated since the program start. Pprof's -inuse_space, -inuse_objects, -alloc_space, and -alloc_objects flags select which to display, defaulting to -inuse_space (live objects, scaled by size).</source>
          <target state="translated">Pprof的-inuse_space,-inuse_objects,-alloc_space,和 -alloc_objects标志可以选择显示哪个标志,默认为-inuse_space(实时对象)和-alloc_objects。Pprof的-inuse_space、-inuse_objects、-alloc_space和-alloc_objects标志选择显示哪一个,默认为-inuse_space(实时对象,按大小缩放)。</target>
        </trans-unit>
        <trans-unit id="9054b52054ed118bba62807238e18c27e8900f1e" translate="yes" xml:space="preserve">
          <source>The http package's Transport and Server both automatically enable HTTP/2 support for simple configurations. To enable HTTP/2 for more complex configurations, to use lower-level HTTP/2 features, or to use a newer version of Go's http2 package, import &quot;golang.org/x/net/http2&quot; directly and use its ConfigureTransport and/or ConfigureServer functions. Manually configuring HTTP/2 via the golang.org/x/net/http2 package takes precedence over the net/http package's built-in HTTP/2 support.</source>
          <target state="translated">http包的Transport和Server都会自动为简单配置启用HTTP/2支持。如果要为更复杂的配置启用 HTTP/2,使用较低级别的 HTTP/2 功能,或者使用较新版本的 Go 的 http2 包,可以直接导入 &quot;golang.org/x/net/http2&quot; 并使用它的 ConfigureTransport 和/或 ConfigureServer 函数。通过 golang.org/x/net/http2 软件包手动配置 HTTP/2,优先于 net/http 软件包内置的 HTTP/2 支持。</target>
        </trans-unit>
        <trans-unit id="7901eb39a7a77a33e17eff2e48d2aac1d7c0d97c" translate="yes" xml:space="preserve">
          <source>The identification of global unicast addresses uses address type identification as defined in RFC 1122, RFC 4632 and RFC 4291 with the exception of IPv4 directed broadcast addresses. It returns true even if ip is in IPv4 private address space or local IPv6 unicast address space.</source>
          <target state="translated">全局单播地址的识别使用RFC 1122、RFC 4632和RFC 4291中定义的地址类型识别,IPv4定向广播地址除外。即使ip处于IPv4私有地址空间或本地IPv6单播地址空间,它也会返回true。</target>
        </trans-unit>
        <trans-unit id="b257c667cd0c9ffb7ee1c476e193cf63abc04956" translate="yes" xml:space="preserve">
          <source>The imag built-in function returns the imaginary part of the complex number c. The return value will be floating point type corresponding to the type of c.</source>
          <target state="translated">imag内置函数返回复数c的虚部,返回值将是c类型对应的浮点类型。</target>
        </trans-unit>
        <trans-unit id="bba6c5ec151d11520ba69091805c64672051a283" translate="yes" xml:space="preserve">
          <source>The implementation compiles a custom codec for each data type in the stream and is most efficient when a single Encoder is used to transmit a stream of values, amortizing the cost of compilation.</source>
          <target state="translated">该实现为流中的每一种数据类型编译一个自定义的编解码器,当使用一个Encoder来传输值流时,效率最高,可以摊销编译的成本。</target>
        </trans-unit>
        <trans-unit id="cc59eb7da6cf17b91e5a422524763e1124d23ad5" translate="yes" xml:space="preserve">
          <source>The implementation fn can assume that the argument Value slice has the number and type of arguments given by typ. If typ describes a variadic function, the final Value is itself a slice representing the variadic arguments, as in the body of a variadic function. The result Value slice returned by fn must have the number and type of results given by typ.</source>
          <target state="translated">实现 fn 可以假设参数 Value 分片具有 typ 给出的参数数量和类型。如果ty描述的是一个变量函数,那么最后的Value本身就是一个代表变量参数的分片,就像变量函数的主体一样。fn 返回的结果 Value 分片必须具有 typ 给出的结果数量和类型。</target>
        </trans-unit>
        <trans-unit id="a41481e84f45a7e3719a2630303073b44edd9b5b" translate="yes" xml:space="preserve">
          <source>The implementation is sufficient for HTTP (RFC 2388) and the multipart bodies generated by popular browsers.</source>
          <target state="translated">该实现足以满足HTTP(RFC 2388)和流行的浏览器生成的多部分体。</target>
        </trans-unit>
        <trans-unit id="bd36b82add2ec8e45a6f77ef7cf720308cbe3f24" translate="yes" xml:space="preserve">
          <source>The implementation provides filters that uncompress during reading and compress during writing. For example, to write compressed data to a buffer:</source>
          <target state="translated">该实现提供了在读取时解压和在写入时压缩的过滤器。例如,将压缩数据写入缓冲区。</target>
        </trans-unit>
        <trans-unit id="624abcf8f99d9c1ecd5f126ae0b1b1d2736d4655" translate="yes" xml:space="preserve">
          <source>The info argument is the fs.FileInfo for the named path.</source>
          <target state="translated">info参数是命名路径的fs.FileInfo。</target>
        </trans-unit>
        <trans-unit id="4c05b349b9c7f15622f23c1c3f50e289a6f9207b" translate="yes" xml:space="preserve">
          <source>The input stream consists of basic JSON values&amp;mdash;bool, string, number, and null&amp;mdash;along with delimiters [ ] { } of type Delim to mark the start and end of arrays and objects. Commas and colons are elided.</source>
          <target state="translated">输入流由基本JSON值（布尔，字符串，数字和null）以及Delim类型的定界符[] {}组成，以标记数组和对象的开始和结束。逗号和冒号被删除。</target>
        </trans-unit>
        <trans-unit id="12da2b29ce7b4618ed043885dc9bb14fc4b7647d" translate="yes" xml:space="preserve">
          <source>The input text for a template is UTF-8-encoded text in any format. &quot;Actions&quot;--data evaluations or control structures--are delimited by &quot;{{&quot; and &quot;}}&quot;; all text outside actions is copied to the output unchanged. Except for raw strings, actions may not span newlines, although comments can.</source>
          <target state="translated">模板的输入文本是任何格式的UTF-8编码文本。&quot;动作&quot;--数据评估或控制结构--以&quot;{{&quot;和&quot;}}&quot;为界;动作之外的所有文本都会被复制到输出中,不会有任何变化。除了原始字符串外,动作不能跨行,但注释可以。</target>
        </trans-unit>
        <trans-unit id="4540c375047525b02ad242a07ddc447e593cb543" translate="yes" xml:space="preserve">
          <source>The issuer distinguished name CRL field and authority key identifier extension are populated using the issuer certificate. issuer must have SubjectKeyId set.</source>
          <target state="translated">签发人区别名称CRL字段和权威密钥标识符扩展是使用签发人证书来填充的。</target>
        </trans-unit>
        <trans-unit id="4ba307a7ab47ab6e6c8f50d8bbcb53f28f406fab" translate="yes" xml:space="preserve">
          <source>The issuer may not be nil, and the crlSign bit must be set in KeyUsage in order to use it as a CRL issuer.</source>
          <target state="translated">签发人不能为零,必须在KeyUsage中设置crlSign位,才能将其作为CRL签发人。</target>
        </trans-unit>
        <trans-unit id="0fe0f673e6c94e25d76ca7000237cacb398b340e" translate="yes" xml:space="preserve">
          <source>The key name will be used if it's a non-empty string consisting of only Unicode letters, digits, and ASCII punctuation except quotation marks, backslash, and comma.</source>
          <target state="translated">如果键名是一个非空字符串,除了引号、反斜杠和逗号之外,只包含Unicode字母、数字和ASCII标点符号,那么就会被使用。</target>
        </trans-unit>
        <trans-unit id="56c8d36b799fc9e0b2026b0edca00b49c8b68568" translate="yes" xml:space="preserve">
          <source>The keys should be in canonical form, as returned by CanonicalHeaderKey.</source>
          <target state="translated">键值应该是规范的形式,由CanonicalHeaderKey返回。</target>
        </trans-unit>
        <trans-unit id="aafd41e452c62afe966c7e13f3df11b54dbc58d9" translate="yes" xml:space="preserve">
          <source>The label parameter may contain arbitrary data that will not be encrypted, but which gives important context to the message. For example, if a given public key is used to decrypt two types of messages then distinct label values could be used to ensure that a ciphertext for one purpose cannot be used for another by an attacker. If not required it can be empty.</source>
          <target state="translated">标签参数可以包含任意的数据,这些数据不会被加密,但可以为消息提供重要的背景。例如,如果一个给定的公钥被用来解密两种类型的消息,那么不同的标签值可以用来确保一个用于一个目的的密文不能被攻击者用于另一个目的。如果不需要,它可以是空的。</target>
        </trans-unit>
        <trans-unit id="8cac55c132cd1a101696d231efd1dd2e57c66e06" translate="yes" xml:space="preserve">
          <source>The label parameter must match the value given when encrypting. See EncryptOAEP for details.</source>
          <target state="translated">标签参数必须与加密时给出的值相匹配。详情请参见EncryptOAEP。</target>
        </trans-unit>
        <trans-unit id="1f23b14d8824650d5d93ee806d28aa66402f402a" translate="yes" xml:space="preserve">
          <source>The last index entry is the field or method index in the (possibly embedded) type where the entry was found, either:</source>
          <target state="translated">最后一个索引条目是找到该条目的(可能是嵌入的)类型中的字段或方法索引,要么。</target>
        </trans-unit>
        <trans-unit id="4b9b3d3444da612bde04769b5c20561ed18e861d" translate="yes" xml:space="preserve">
          <source>The legacy Common Name field is ignored unless it's a valid hostname, the certificate doesn't have any Subject Alternative Names, and the GODEBUG environment variable is set to &quot;x509ignoreCN=0&quot;. Support for Common Name is deprecated will be entirely removed in the future.</source>
          <target state="translated">传统的通用名字段会被忽略,除非它是一个有效的主机名,证书没有任何主题替代名,并且GODEBUG环境变量被设置为 &quot;x509ignoreCN=0&quot;。对Common Name的支持已被废弃,今后将完全删除。</target>
        </trans-unit>
        <trans-unit id="feec6e46b5f96d5f768a208b14b5f1c441e6736a" translate="yes" xml:space="preserve">
          <source>The len built-in function returns the length of v, according to its type:</source>
          <target state="translated">len内置函数根据v的类型,返回v的长度。</target>
        </trans-unit>
        <trans-unit id="37c7e993d252a1780b2d17b25f28b15858ed3005" translate="yes" xml:space="preserve">
          <source>The less function must satisfy the same requirements as the Interface type's Less method.</source>
          <target state="translated">Less函数必须满足与接口类型的Less方法相同的要求。</target>
        </trans-unit>
        <trans-unit id="67e3ff53cc19034aa94ce5014984a3863b3ceaa2" translate="yes" xml:space="preserve">
          <source>The limit controls the number of operating system threads, not the number of goroutines. A Go program creates a new thread only when a goroutine is ready to run but all the existing threads are blocked in system calls, cgo calls, or are locked to other goroutines due to use of runtime.LockOSThread.</source>
          <target state="translated">该限制控制的是操作系统线程的数量,而不是goroutine的数量。一个围棋程序只有在一个goroutine准备运行时才会创建一个新的线程,但所有现有的线程都在系统调用、cgo调用中被阻塞,或者由于使用runtime.LockOSThread而被锁定在其他goroutine上。</target>
        </trans-unit>
        <trans-unit id="b7d62826dea7a7db650a9558cf682cb6d6d5b0e1" translate="yes" xml:space="preserve">
          <source>The list is sorted by ID. Note that the default cipher suites selected by this package might depend on logic that can't be captured by a static list.</source>
          <target state="translated">列表是按ID排序的。需要注意的是,这个软件包所选择的默认密码套件可能取决于静态列表无法捕获的逻辑。</target>
        </trans-unit>
        <trans-unit id="61b31a135931a0a96f45c468dd4c1356b142f056" translate="yes" xml:space="preserve">
          <source>The list of possible Object kinds.</source>
          <target state="translated">可能的对象种类列表。</target>
        </trans-unit>
        <trans-unit id="f82cdeb26140d2ac8d4f27048ef361e35bc34e51" translate="yes" xml:space="preserve">
          <source>The list of tokens.</source>
          <target state="translated">代币清单。</target>
        </trans-unit>
        <trans-unit id="744b107073d50b7c5d979152623baf7c98836ce1" translate="yes" xml:space="preserve">
          <source>The load and store operations, implemented by the LoadT and StoreT functions, are the atomic equivalents of &quot;return *addr&quot; and &quot;*addr = val&quot;.</source>
          <target state="translated">LoadT和StoreT函数实现的加载和存储操作,是 &quot;返回*addr &quot;和 &quot;*addr=val &quot;的原子等价物。</target>
        </trans-unit>
        <trans-unit id="d80346c4a6d83f0a2408ae318740b75196640a27" translate="yes" xml:space="preserve">
          <source>The lookup function is called each time the resulting importer needs to resolve an import path. In this mode the importer can only be invoked with canonical import paths (not relative or absolute ones); it is assumed that the translation to canonical import paths is being done by the client of the importer.</source>
          <target state="translated">每次当生成的导入器需要解析导入路径时,都会调用查找函数。在这种模式下,进口商只能使用规范的进口路径(不是相对或绝对路径)来调用;假定进口商的客户端正在进行向规范进口路径的转换。</target>
        </trans-unit>
        <trans-unit id="d42ee39ba69d607990bf6285f526cdb4d05cd8c5" translate="yes" xml:space="preserve">
          <source>The low bit is therefore analogous to a sign bit, but making it the complement bit instead guarantees that the largest negative integer is not a special case. For example, -129=^128=(^256&amp;gt;&amp;gt;1) encodes as (FE 01 01).</source>
          <target state="translated">因此，低位类似于符号位，但是将其设为补码位可确保最大的负整数不是特殊情况。例如，-129 = ^ 128 =（^ 256 &amp;gt;&amp;gt; 1）编码为（FE 01 01）。</target>
        </trans-unit>
        <trans-unit id="e23983031d30e849dd601f8a9a147a11b178b7e1" translate="yes" xml:space="preserve">
          <source>The main use case is finding resources located relative to an executable.</source>
          <target state="translated">主要的用例是寻找相对于可执行文件的资源。</target>
        </trans-unit>
        <trans-unit id="ae651dd57d8aac89d2244b121832135b42a78e22" translate="yes" xml:space="preserve">
          <source>The make built-in function allocates and initializes an object of type slice, map, or chan (only). Like new, the first argument is a type, not a value. Unlike new, make's return type is the same as the type of its argument, not a pointer to it. The specification of the result depends on the type:</source>
          <target state="translated">make内置函数分配并初始化一个类型为slice、map或chan(仅)的对象。和new一样,第一个参数是一个类型,而不是一个值。与new不同,make的返回类型与它的参数类型相同,而不是指向它的指针。结果的规格取决于类型。</target>
        </trans-unit>
        <trans-unit id="38a5e445a42e339cecb3a2e57e70485eff805e93" translate="yes" xml:space="preserve">
          <source>The map need not include parent directories for files contained in the map; those will be synthesized if needed. But a directory can still be included by setting the MapFile.Mode's ModeDir bit; this may be necessary for detailed control over the directory's FileInfo or to create an empty directory.</source>
          <target state="translated">地图不需要包含地图中所包含的文件的父目录;如果需要的话,这些目录将被合成。但仍然可以通过设置 MapFile.Mode 的 ModeDir 位来包含目录;这对于详细控制目录的 FileInfo 或创建一个空目录可能是必要的。</target>
        </trans-unit>
        <trans-unit id="ad15554627caa64494fe09878e570067f5641170" translate="yes" xml:space="preserve">
          <source>The meaning of the parameters fset, pkg, and pos is the same as in CheckExpr. An error is returned if expr cannot be parsed successfully, or the resulting expr AST cannot be type-checked.</source>
          <target state="translated">参数fset、pkg和pos的含义与CheckExpr相同。如果expr不能被成功解析,或者产生的expr AST不能进行类型检查,则返回一个错误。</target>
        </trans-unit>
        <trans-unit id="76f7a0e267f75e03932754601186fb88901bc244" translate="yes" xml:space="preserve">
          <source>The message must be no longer than the length of the public modulus minus twice the hash length, minus a further 2.</source>
          <target state="translated">该消息必须不长于公共模数的长度减去哈希长度的两倍,再减去2。</target>
        </trans-unit>
        <trans-unit id="f50438ca0e284cc49442d4b96ed8422098542b37" translate="yes" xml:space="preserve">
          <source>The method for resolving domain names, whether indirectly with functions like Dial or directly with functions like LookupHost and LookupAddr, varies by operating system.</source>
          <target state="translated">解析域名的方法,无论是间接使用Dial等函数,还是直接使用LookupHost和LookupAddr等函数,都因操作系统而异。</target>
        </trans-unit>
        <trans-unit id="fd8e3459dc1d93b8b2959d9f7ce9e888fe72a14d" translate="yes" xml:space="preserve">
          <source>The method's first argument represents the arguments provided by the caller; the second argument represents the result parameters to be returned to the caller. The method's return value, if non-nil, is passed back as a string that the client sees as if created by errors.New. If an error is returned, the reply parameter will not be sent back to the client.</source>
          <target state="translated">该方法的第一个参数代表调用者提供的参数;第二个参数代表要返回给调用者的结果参数。该方法的返回值如果是非nil,则会以字符串的形式传回,客户端看到的字符串就像由错误.New创建的一样。如果返回错误,则不会将回复参数发回给客户端。</target>
        </trans-unit>
        <trans-unit id="eebd4cc8d1b396bccc721d19c4bd56800d60e192" translate="yes" xml:space="preserve">
          <source>The methods should behave the same as those on an *os.File.</source>
          <target state="translated">这些方法的行为应该与*os.File.Methods上的方法相同。</target>
        </trans-unit>
        <trans-unit id="3351c33da5b9bc73dd81d983421271485dd91e09" translate="yes" xml:space="preserve">
          <source>The minimal source code for a binary-only package was therefore:</source>
          <target state="translated">因此,二进制包的最小源代码是。</target>
        </trans-unit>
        <trans-unit id="ba0d7c85cb07c29f22bceee0e488a79cf0a2c300" translate="yes" xml:space="preserve">
          <source>The minimum element in the tree is the root, at index 0.</source>
          <target state="translated">树中最小的元素是根,索引为0。</target>
        </trans-unit>
        <trans-unit id="6cf2c8c68bd743b1d5a4e29ae7301dad5d49bcb2" translate="yes" xml:space="preserve">
          <source>The mode parameter controls the amount of source text parsed and other optional parser functionality. Position information is recorded in the file set fset, which must not be nil.</source>
          <target state="translated">模式参数控制源文本的解析量和其他可选的解析器功能。位置信息记录在文件集fset中,fset不能为零。</target>
        </trans-unit>
        <trans-unit id="7d1773f39818c5825c59e48b1236b92119b0b32e" translate="yes" xml:space="preserve">
          <source>The month, day, hour, min, sec, and nsec values may be outside their usual ranges and will be normalized during the conversion. For example, October 32 converts to November 1.</source>
          <target state="translated">月、日、时、分、秒和nsec的值可能超出了它们的通常范围,并将在转换过程中被标准化。例如,10月32日转换为11月1日。</target>
        </trans-unit>
        <trans-unit id="a5541e290e27715c3d35b2115cad871f3ab99ccb" translate="yes" xml:space="preserve">
          <source>The most common numeric conversions are Atoi (string to int) and Itoa (int to string).</source>
          <target state="translated">最常见的数字转换是Atoi(字符串到int)和Itoa(int到字符串)。</target>
        </trans-unit>
        <trans-unit id="4bbbacdbad6d2c99ac68260aad07ecb869838903" translate="yes" xml:space="preserve">
          <source>The most common use of this pattern is to access fields in a struct or elements of an array:</source>
          <target state="translated">该模式最常见的用法是访问结构中的字段或数组中的元素。</target>
        </trans-unit>
        <trans-unit id="ac8cc81db3fc49af2479176c9231b929d55cdbd8" translate="yes" xml:space="preserve">
          <source>The msg parameter should be an RFC 822-style email with headers first, a blank line, and then the message body. The lines of msg should be CRLF terminated. The msg headers should usually include fields such as &quot;From&quot;, &quot;To&quot;, &quot;Subject&quot;, and &quot;Cc&quot;. Sending &quot;Bcc&quot; messages is accomplished by including an email address in the to parameter but not including it in the msg headers.</source>
          <target state="translated">msg 参数应该是 RFC 822 风格的电子邮件,先是标题,再是空行,然后是邮件正文。msg 的行应该以 CRLF 结尾。msg 头部通常应该包括诸如 &quot;发件人&quot;、&quot;收件人&quot;、&quot;主题 &quot;和 &quot;抄送 &quot;等字段。发送 &quot;Bcc &quot;信息的方法是在 to 参数中包含一个电子邮件地址,但不包含在 msg 头部。</target>
        </trans-unit>
        <trans-unit id="410aa7b0a0304575a8915750342dc577b832f74c" translate="yes" xml:space="preserve">
          <source>The name for the XML elements is taken from, in order of preference:</source>
          <target state="translated">XML元素的名称依次取自。</target>
        </trans-unit>
        <trans-unit id="57b088fc8d39478c2345773281e5eb271805f7ea" translate="yes" xml:space="preserve">
          <source>The naming convention to declare examples for the package, a function F, a type T and method M on type T are:</source>
          <target state="translated">为包、函数F、类型T和类型T上的方法M声明例子的命名惯例是:</target>
        </trans-unit>
        <trans-unit id="7b9b492a2e0fbf406f8b8d17e034f78a30b6eb8c" translate="yes" xml:space="preserve">
          <source>The net, net/http, and crypto/tls packages also refer to debugging variables in GODEBUG. See the documentation for those packages for details.</source>
          <target state="translated">net、net/http和crypto/tls包也引用了GODEBUG中的调试变量。详情请参见这些包的文档。</target>
        </trans-unit>
        <trans-unit id="69954652d3ee14598bd31e60017ff5be6ec75582" translate="yes" xml:space="preserve">
          <source>The net/http/cookiejar package provides a CookieJar implementation.</source>
          <target state="translated">net/http/cookiejar包提供了一个CookieJar的实现。</target>
        </trans-unit>
        <trans-unit id="7815d9693c2e8fba3de7740f99dda917ebde80d7" translate="yes" xml:space="preserve">
          <source>The net/rpc package is frozen and is not accepting new features.</source>
          <target state="translated">net/rpc包被冻结,不接受新功能。</target>
        </trans-unit>
        <trans-unit id="b67ec9dd23234843cefc446704be9276e0333344" translate="yes" xml:space="preserve">
          <source>The network must be &quot;tcp&quot;, &quot;tcp4&quot;, &quot;tcp6&quot;, &quot;unix&quot; or &quot;unixpacket&quot;.</source>
          <target state="translated">网络必须是 &quot;tcp&quot;、&quot;tcp4&quot;、&quot;tcp6&quot;、&quot;unix &quot;或 &quot;unixpacket&quot;。</target>
        </trans-unit>
        <trans-unit id="f78c2675c0a1b78facf549c913ce29c8786aed4f" translate="yes" xml:space="preserve">
          <source>The network must be &quot;udp&quot;, &quot;udp4&quot;, &quot;udp6&quot;, &quot;unixgram&quot;, or an IP transport. The IP transports are &quot;ip&quot;, &quot;ip4&quot;, or &quot;ip6&quot; followed by a colon and a literal protocol number or a protocol name, as in &quot;ip:1&quot; or &quot;ip:icmp&quot;.</source>
          <target state="translated">网络必须是 &quot;udp&quot;、&quot;udp4&quot;、&quot;udp6&quot;、&quot;unixgram &quot;或IP传输。IP传输是 &quot;ip&quot;、&quot;ip4 &quot;或 &quot;ip6&quot;,后面跟着一个冒号和一个协议号或协议名,如 &quot;ip:1 &quot;或 &quot;ip:icmp&quot;。</target>
        </trans-unit>
        <trans-unit id="f62f0c6bf3637b6bd91fbed73590e0c5ec059d67" translate="yes" xml:space="preserve">
          <source>The network must be &quot;unix&quot; or &quot;unixpacket&quot;.</source>
          <target state="translated">网络必须是 &quot;unix &quot;或 &quot;unixpacket&quot;。</target>
        </trans-unit>
        <trans-unit id="961ea2a9664370be05fda243ace29bf62f0b8b14" translate="yes" xml:space="preserve">
          <source>The network must be &quot;unixgram&quot;.</source>
          <target state="translated">网络必须是 &quot;unixgram&quot;。</target>
        </trans-unit>
        <trans-unit id="143c1ec61594ea23a84fdfc668726a693ff1d059" translate="yes" xml:space="preserve">
          <source>The network must be a TCP network name.</source>
          <target state="translated">网络必须是TCP网络名。</target>
        </trans-unit>
        <trans-unit id="54bb9136f9b37f7468411dbae5b647c63059a3a1" translate="yes" xml:space="preserve">
          <source>The network must be a TCP network name; see func Dial for details.</source>
          <target state="translated">网络必须是一个TCP网络名,详情请看func Dial。</target>
        </trans-unit>
        <trans-unit id="a35132d711d8945bdb8b272ee67848e4c94a5a16" translate="yes" xml:space="preserve">
          <source>The network must be a UDP network name.</source>
          <target state="translated">网络必须是UDP网络名。</target>
        </trans-unit>
        <trans-unit id="89ed96066a0fbc9b6b82696daa8ba7effb94e0a8" translate="yes" xml:space="preserve">
          <source>The network must be a UDP network name; see func Dial for details.</source>
          <target state="translated">网络必须是UDP网络名,详情请看func Dial。</target>
        </trans-unit>
        <trans-unit id="199d17e2fe63f354db9a6b916c396629d6b88dda" translate="yes" xml:space="preserve">
          <source>The network must be a Unix network name.</source>
          <target state="translated">网络必须是Unix网络名。</target>
        </trans-unit>
        <trans-unit id="b6cf9d29e750ed948316e5ba40edb44e452845b1" translate="yes" xml:space="preserve">
          <source>The network must be a Unix network name; see func Dial for details.</source>
          <target state="translated">网络必须是Unix网络名,详情请看func Dial。</target>
        </trans-unit>
        <trans-unit id="61f5a2270318ecc8414142178aaa1a53165f97e7" translate="yes" xml:space="preserve">
          <source>The network must be an IP network name.</source>
          <target state="translated">网络必须是IP网络名。</target>
        </trans-unit>
        <trans-unit id="b881d6aafa14d5f635aad510160f9473031ecf6f" translate="yes" xml:space="preserve">
          <source>The network must be an IP network name; see func Dial for details.</source>
          <target state="translated">网络必须是一个IP网络名,详情请看func Dial。</target>
        </trans-unit>
        <trans-unit id="882441c96cbf8f9716ac8a79d3a5eb4e3af0bcfd" translate="yes" xml:space="preserve">
          <source>The new Handler calls h.ServeHTTP to handle each request, but if a call runs for longer than its time limit, the handler responds with a 503 Service Unavailable error and the given message in its body. (If msg is empty, a suitable default message will be sent.) After such a timeout, writes by h to its ResponseWriter will return ErrHandlerTimeout.</source>
          <target state="translated">新的处理程序调用h.ServeHTTP来处理每个请求,但是如果一个调用运行的时间超过了它的时间限制,处理程序就会以503服务不可用的错误和在它的正文中给出的消息来响应。 (如果msg是空的,就会发送合适的默认消息。)在这样的超时之后,h向它的ResponseWriter写的东西会返回ErrHandlerTimeout。(如果msg为空,则会发送一个合适的默认消息。)在这样的超时之后,h对其ResponseWriter的写入将返回ErrHandlerTimeout。</target>
        </trans-unit>
        <trans-unit id="3cf0c81686ac1acb508bf9e67780a55cee7159d9" translate="yes" xml:space="preserve">
          <source>The new built-in function allocates memory. The first argument is a type, not a value, and the value returned is a pointer to a newly allocated zero value of that type.</source>
          <target state="translated">新的内置函数分配内存。第一个参数是一个类型,而不是一个值,返回的值是一个指向该类型新分配的零值的指针。</target>
        </trans-unit>
        <trans-unit id="902360dabebdea5b3a521c7b72fed85e30d4437d" translate="yes" xml:space="preserve">
          <source>The node type must be *ast.File, *printer.CommentedNode, []ast.Decl, []ast.Stmt, or assignment-compatible to ast.Expr, ast.Decl, ast.Spec, or ast.Stmt. Node does not modify node. Imports are not sorted for nodes representing partial source files (for instance, if the node is not an *ast.File or a *printer.CommentedNode not wrapping an *ast.File).</source>
          <target state="translated">节点类型必须是*ast.File、*printer.CommentedNode、[]ast.Decl、[]ast.Stmt,或与 ast.Expr、 ast.Decl、 ast.Spec 或 ast.Stmt 兼容的赋值。节点不修改节点。对于代表部分源文件的节点,导入不排序(例如,如果节点不是*ast.File或*printer.CommentedNode没有包装*ast.File)。</target>
        </trans-unit>
        <trans-unit id="56cff2c7a026fcff6621abd1c298d8e39f80b3ef" translate="yes" xml:space="preserve">
          <source>The non-Go code should not change the signal mask on any threads created by the Go runtime. If the non-Go code starts new threads of its own, it may set the signal mask as it pleases.</source>
          <target state="translated">非围棋代码不应改变围棋运行时创建的任何线程的信号掩码。如果非围棋代码自己启动新的线程,它可以随意设置信号掩码。</target>
        </trans-unit>
        <trans-unit id="67289d2a1e8eb416b3a82eb9f3e75a285c0158f6" translate="yes" xml:space="preserve">
          <source>The number represented by s must be of the form N, Ni, or N&amp;plusmn;Ni, where N stands for a floating-point number as recognized by ParseFloat, and i is the imaginary component. If the second N is unsigned, a + sign is required between the two components as indicated by the &amp;plusmn;. If the second N is NaN, only a + sign is accepted. The form may be parenthesized and cannot contain any spaces. The resulting complex number consists of the two components converted by ParseFloat.</source>
          <target state="translated">s表示的数字必须采用N，Ni或N&amp;plusmn;Ni的形式，其中N代表ParseFloat识别的浮点数，而i是虚数。如果第二个N是无符号的，则在两个分量之间需要一个+号，如&amp;plusmn;所示。如果第二个N为NaN，则仅接受+号。表格可以用括号括起来，不能包含任何空格。生成的复数由ParseFloat转换的两个组件组成。</target>
        </trans-unit>
        <trans-unit id="8ca31cdbe931eb86d33c507cac75f440d062f995" translate="yes" xml:space="preserve">
          <source>The ok result is false if the -timeout flag indicates &amp;ldquo;no timeout&amp;rdquo; (0).</source>
          <target state="translated">如果-timeout标志指示&amp;ldquo;无超时&amp;rdquo;（0），则确定结果为false。</target>
        </trans-unit>
        <trans-unit id="b32a27700c08984e10653750973205a0166116d3" translate="yes" xml:space="preserve">
          <source>The only signal values guaranteed to be present in the os package on all systems are os.Interrupt (send the process an interrupt) and os.Kill (force the process to exit). On Windows, sending os.Interrupt to a process with os.Process.Signal is not implemented; it will return an error instead of sending a signal.</source>
          <target state="translated">在所有系统的os包中保证存在的信号值只有os.Interrupt(向进程发送一个中断)和os.Kill(强制进程退出)。在 Windows 上,用 os.Process.Signal 向进程发送 os.Interrupt 是无法实现的;它将返回一个错误而不是发送一个信号。</target>
        </trans-unit>
        <trans-unit id="ff422009eedfd53fa7602cbdd94de8292f5f25ce" translate="yes" xml:space="preserve">
          <source>The original specification for encryption and signatures with RSA is PKCS #1 and the terms &quot;RSA encryption&quot; and &quot;RSA signatures&quot; by default refer to PKCS #1 version 1.5. However, that specification has flaws and new designs should use version 2, usually called by just OAEP and PSS, where possible.</source>
          <target state="translated">用RSA进行加密和签名的原始规范是PKCS #1,&quot;RSA加密 &quot;和 &quot;RSA签名 &quot;这两个术语默认指的是PKCS #1的1.5版本。但是,该规范存在缺陷,新的设计应尽可能使用第2版,通常只用OAEP和PSS来称呼。</target>
        </trans-unit>
        <trans-unit id="8c37b0a4e6fab650a215cbd5edb17eee82ff53db" translate="yes" xml:space="preserve">
          <source>The original specification for encryption and signatures with RSA is PKCS#1 and the terms &quot;RSA encryption&quot; and &quot;RSA signatures&quot; by default refer to PKCS#1 version 1.5. However, that specification has flaws and new designs should use version two, usually called by just OAEP and PSS, where possible.</source>
          <target state="translated">用RSA进行加密和签名的原始规范是PKCS#1,&quot;RSA加密 &quot;和 &quot;RSA签名 &quot;这两个术语默认指的是PKCS#1 1.5版本。但是,该规范存在缺陷,新的设计应尽可能使用第二版本,通常只用OAEP和PSS来称呼。</target>
        </trans-unit>
        <trans-unit id="540d9d25cf4179e22c8285de7096ab16e1c12b86" translate="yes" xml:space="preserve">
          <source>The original tar format was introduced in Unix V7. Since then, there have been multiple competing formats attempting to standardize or extend the V7 format to overcome its limitations. The most common formats are the USTAR, PAX, and GNU formats, each with their own advantages and limitations.</source>
          <target state="translated">最初的焦油格式是在Unix V7中引入的。从那时起,就有多种竞争性格式试图标准化或扩展 V7 格式以克服其局限性。最常见的格式是UTAR、PAX和GNU格式,每种格式都有自己的优势和局限性。</target>
        </trans-unit>
        <trans-unit id="447ae61382377495d9bb3dcbc7167cc095d3d833" translate="yes" xml:space="preserve">
          <source>The os interface is intended to be uniform across all operating systems. Features not generally available appear in the system-specific package syscall.</source>
          <target state="translated">os接口的目的是为了在所有操作系统中统一。一般不可用的功能会出现在系统专用的软件包syscall中。</target>
        </trans-unit>
        <trans-unit id="826c8f633f039e53ad0aac6dce5e00961c47baef" translate="yes" xml:space="preserve">
          <source>The other reporting methods, such as the variations of Log and Error, may be called simultaneously from multiple goroutines.</source>
          <target state="translated">其他报告方法,如日志和错误的变化,可以从多个goroutine中同时调用。</target>
        </trans-unit>
        <trans-unit id="314818cec484a0a4f79c6a3bd12ea1e65d6a5497" translate="yes" xml:space="preserve">
          <source>The output of a command will be either one value or two values, the second of which has type error. If that second value is present and evaluates to non-nil, execution terminates and the error is returned to the caller of Execute.</source>
          <target state="translated">命令的输出将是一个值或两个值,其中第二个值的类型为错误。如果第二个值存在,并且值为非nil,则执行终止,错误返回给Execute的调用者。</target>
        </trans-unit>
        <trans-unit id="8552b51b4b43726af9d21d2953952aab9f9eccb4" translate="yes" xml:space="preserve">
          <source>The package also exports a handler that serves execution trace data for the &quot;go tool trace&quot; command. To collect a 5-second execution trace:</source>
          <target state="translated">该软件包还输出了一个处理程序,为 &quot;go tool trace &quot;命令提供执行跟踪数据。要收集一个5秒的执行跟踪数据。</target>
        </trans-unit>
        <trans-unit id="01b79b49ed9f5aef9d64418cf5de61a045616033" translate="yes" xml:space="preserve">
          <source>The package also runs and verifies example code. Example functions may include a concluding line comment that begins with &quot;Output:&quot; and is compared with the standard output of the function when the tests are run. (The comparison ignores leading and trailing space.) These are examples of an example:</source>
          <target state="translated">该软件包还可以运行和验证示例代码。示例函数可能包含一个以 &quot;Output:&quot;开头的结尾行注释,并在测试运行时与函数的标准输出进行比较。(比较会忽略前导空格和后导空格。)这些都是例子的例子。</target>
        </trans-unit>
        <trans-unit id="a842fba56dd27e8e683543ed1da0bb8ec8237f57" translate="yes" xml:space="preserve">
          <source>The package is marked as complete if no errors occurred, otherwise it is incomplete. See Config.Error for controlling behavior in the presence of errors.</source>
          <target state="translated">如果没有发生错误,则该包被标记为完整,否则就是不完整。参见Config.Error,了解如何在出现错误时控制行为。</target>
        </trans-unit>
        <trans-unit id="084533be70387d373858b81e63ee3fdbb938556c" translate="yes" xml:space="preserve">
          <source>The package is sometimes only imported for the side effect of registering its HTTP handler and the above variables. To use it this way, link this package into your program:</source>
          <target state="translated">这个包有时只是为了注册它的HTTP处理程序和上述变量的副作用而导入的。如果要这样使用,请将这个包链接到你的程序中。</target>
        </trans-unit>
        <trans-unit id="a76fef8dda549c1a3db0f0948e9255bd119d522e" translate="yes" xml:space="preserve">
          <source>The package is specified by a list of *ast.Files and corresponding file set, and the package path the package is identified with. The clean path must not be empty or dot (&quot;.&quot;).</source>
          <target state="translated">包是由*ast.Files和对应的文件集的列表,以及包所标识的包路径来指定的。清理路径不得为空或点(&quot;.&quot;)。</target>
        </trans-unit>
        <trans-unit id="385716c34a6382063c2f2e6bebfaff89eee0a50e" translate="yes" xml:space="preserve">
          <source>The package is specified by a list of *ast.Files and corresponding file set, which must not be nil. NewFromFiles uses all provided files when computing documentation, so it is the caller's responsibility to provide only the files that match the desired build context. &quot;go/build&quot;.Context.MatchFile can be used for determining whether a file matches a build context with the desired GOOS and GOARCH values, and other build constraints. The import path of the package is specified by importPath.</source>
          <target state="translated">包由*ast.Files和对应的文件集列表指定,该列表不能为零。NewFromFiles在计算文档时使用所有提供的文件,所以调用者有责任只提供与所需构建上下文相匹配的文件。&quot;go/build&quot;.Context.MatchFile可以用来确定一个文件是否与所需的GOOS和GOARCH值以及其他构建约束相匹配的构建上下文。包的导入路径由importPath指定。</target>
        </trans-unit>
        <trans-unit id="399fd3ad30378409e2dc4bdf013d129681dab5d4" translate="yes" xml:space="preserve">
          <source>The package is typically only imported for the side effect of registering its HTTP handlers. The handled paths all begin with /debug/pprof/.</source>
          <target state="translated">这个包通常只是为了注册它的HTTP处理程序而导入的。处理的路径都是以/debug/pprof/开头的。</target>
        </trans-unit>
        <trans-unit id="1435a203fd8b96db3ad7b17b180e6f206d92f47b" translate="yes" xml:space="preserve">
          <source>The package is using the Elastic Tabstops algorithm described at &lt;a href=&quot;http://nickgravgaard.com/elastictabstops/index.html&quot;&gt;http://nickgravgaard.com/elastictabstops/index.html&lt;/a&gt;.</source>
          <target state="translated">该程序包使用&lt;a href=&quot;http://nickgravgaard.com/elastictabstops/index.html&quot;&gt;http://nickgravgaard.com/elastictabstops/index.html中&lt;/a&gt;描述的Elastic Tabstops算法。</target>
        </trans-unit>
        <trans-unit id="2d8c628767f33f2351dada491bfefd34f51b3140" translate="yes" xml:space="preserve">
          <source>The package provides:</source>
          <target state="translated">该方案提供:</target>
        </trans-unit>
        <trans-unit id="fdd304cc0ffa560e98ef7d6ccf98bb51070237a4" translate="yes" xml:space="preserve">
          <source>The packages golang.org/x/net/ipv4 and golang.org/x/net/ipv6 can be used to manipulate IP-level socket options in oob.</source>
          <target state="translated">golang.org/x/net/ipv4和golang.org/x/net/ipv6这两个包可以用来操作oob中的IP级socket选项。</target>
        </trans-unit>
        <trans-unit id="e31e979e3edc39254b9a5c52d82e5a30deadc675" translate="yes" xml:space="preserve">
          <source>The panic built-in function stops normal execution of the current goroutine. When a function F calls panic, normal execution of F stops immediately. Any functions whose execution was deferred by F are run in the usual way, and then F returns to its caller. To the caller G, the invocation of F then behaves like a call to panic, terminating G's execution and running any deferred functions. This continues until all functions in the executing goroutine have stopped, in reverse order. At that point, the program is terminated with a non-zero exit code. This termination sequence is called panicking and can be controlled by the built-in function recover.</source>
          <target state="translated">panic内置函数停止当前goroutine的正常执行。当函数F调用panic时,F的正常执行立即停止。任何被F推迟执行的函数都会以通常的方式运行,然后F返回给它的调用者。对调用者G来说,F的调用就像对panic的调用一样,终止G的执行,并运行任何推迟执行的函数。这种情况一直持续到正在执行的goroutine中的所有函数都停止,顺序相反。这时,程序以一个非零的退出代码终止。这个终止序列称为panicking,可以通过内置函数recover来控制。</target>
        </trans-unit>
        <trans-unit id="af4f035528815b22e373ca233969d1eeb80da9ab" translate="yes" xml:space="preserve">
          <source>The parse functions return the widest type (float64, int64, and uint64), but if the size argument specifies a narrower width the result can be converted to that narrower type without data loss:</source>
          <target state="translated">解析函数返回最宽的类型(float64、int64和uint64),但如果size参数指定了一个较窄的宽度,结果可以转换为该较窄的类型,而不会丢失数据。</target>
        </trans-unit>
        <trans-unit id="a18efb4bf749b7c5acc3a4bfaddc4a2e6898762f" translate="yes" xml:space="preserve">
          <source>The parser accepts a larger language than is syntactically permitted by the Go spec, for simplicity, and for improved robustness in the presence of syntax errors. For instance, in method declarations, the receiver is treated like an ordinary parameter list and thus may contain multiple entries where the spec permits exactly one. Consequently, the corresponding field in the AST (ast.FuncDecl.Recv) field is not restricted to one entry.</source>
          <target state="translated">为了简单起见,也为了提高语法错误时的鲁棒性,解析器接受的语言比Go规范所允许的语法更大。例如,在方法声明中,接受者被当作普通的参数列表,因此可能包含多个条目,而规范只允许一个。因此,AST(ast.FuncDecl.Recv)字段中相应的字段不限于一个条目。</target>
        </trans-unit>
        <trans-unit id="f1b15ae7c535ec21c3b3214f780b2381f7617014" translate="yes" xml:space="preserve">
          <source>The path and host are used unchanged for CONNECT requests.</source>
          <target state="translated">在CONNECT请求中,路径和主机是不变的。</target>
        </trans-unit>
        <trans-unit id="623d365b943b6e8d95767b246041604e7f8848f2" translate="yes" xml:space="preserve">
          <source>The path argument contains the argument to Walk as a prefix. That is, if Walk is called with root argument &quot;dir&quot; and finds a file named &quot;a&quot; in that directory, the walk function will be called with argument &quot;dir/a&quot;.</source>
          <target state="translated">path参数包含了Walk的参数作为前缀。也就是说,如果用根参数 &quot;dir &quot;来调用Walk,并在该目录下找到一个名为 &quot;a &quot;的文件,那么Walk函数将用参数 &quot;dir/a &quot;来调用。</target>
        </trans-unit>
        <trans-unit id="147552bd39d536fc2b6830c38de35cab2fd698e6" translate="yes" xml:space="preserve">
          <source>The path argument contains the argument to WalkDir as a prefix. That is, if WalkDir is called with root argument &quot;dir&quot; and finds a file named &quot;a&quot; in that directory, the walk function will be called with argument &quot;dir/a&quot;.</source>
          <target state="translated">path参数包含WalkDir的参数作为前缀。也就是说,如果用根参数 &quot;dir &quot;调用WalkDir,并在该目录下找到一个名为 &quot;a &quot;的文件,则会用参数 &quot;dir/a &quot;调用Walk函数。</target>
        </trans-unit>
        <trans-unit id="185477acd3fd456d75fb7c4fc53e2fc58b8c4aaf" translate="yes" xml:space="preserve">
          <source>The path package should only be used for paths separated by forward slashes, such as the paths in URLs. This package does not deal with Windows paths with drive letters or backslashes; to manipulate operating system paths, use the path/filepath package.</source>
          <target state="translated">path包只能用于处理用斜线分隔的路径,比如URL中的路径。这个包并不处理Windows系统中带有驱动器字母或反斜杠的路径;如果要操作操作系统的路径,请使用path/filepath包。</target>
        </trans-unit>
        <trans-unit id="26954c9ca56cc48a56a0453ce2488e2f260ed60b" translate="yes" xml:space="preserve">
          <source>The pkg/ directory holds installed package objects. As in the Go tree, each target operating system and architecture pair has its own subdirectory of pkg (pkg/GOOS_GOARCH).</source>
          <target state="translated">pkg/目录下存放着已安装的包对象。和围棋树一样,每个目标操作系统和架构对都有自己的 pkg 子目录 (pkg/GOOS_GOARCH)。</target>
        </trans-unit>
        <trans-unit id="5a87eb4ca6fbc546df6339993053151079409112" translate="yes" xml:space="preserve">
          <source>The precision prec controls the number of digits (excluding the exponent) printed by the 'e', 'E', 'f', 'g', 'G', 'x', and 'X' formats. For 'e', 'E', 'f', 'x', and 'X', it is the number of digits after the decimal point. For 'g' and 'G' it is the maximum number of significant digits (trailing zeros are removed). The special precision -1 uses the smallest number of digits necessary such that ParseFloat will return f exactly.</source>
          <target state="translated">精度prec控制'e'、'E'、'f'、'g'、'G'、'x'和'X'格式打印的位数(不包括指数)。对于'e'、'E'、'f'、'x'和'X',它是小数点后的数字。对于'g'和'G',它是最大的有意义的数字(去掉了尾部的零)。特殊精度-1使用的是必要的最小数字,这样ParseFloat将准确地返回f。</target>
        </trans-unit>
        <trans-unit id="69078c80b7be9ecb1f89b1ab519c7b7264b1d687" translate="yes" xml:space="preserve">
          <source>The precision prec controls the number of digits (excluding the exponent) printed by the 'e', 'E', 'f', 'g', 'G', and 'x' formats. For 'e', 'E', 'f', and 'x', it is the number of digits after the decimal point. For 'g' and 'G' it is the total number of digits. A negative precision selects the smallest number of decimal digits necessary to identify the value x uniquely using x.Prec() mantissa bits. The prec value is ignored for the 'b' and 'p' formats.</source>
          <target state="translated">精度prec控制'e'、'E'、'f'、'g'、'G'和'x'格式打印的位数(不包括指数)。对于'e'、'E'、'f'和'x',它是小数点后的数字。对于'g'和'G',它是数字的总数。负精度选择了使用x.Prec()mantissa位来唯一识别值x所需的最小的十进制位数。对于'b'和'p'格式,prec值被忽略。</target>
        </trans-unit>
        <trans-unit id="456c4a02a800a4453e3d726e233dc51ff74f0fc9" translate="yes" xml:space="preserve">
          <source>The predefined profiles may assign meaning to other debug values; for example, when printing the &quot;goroutine&quot; profile, debug=2 means to print the goroutine stacks in the same form that a Go program uses when dying due to an unrecovered panic.</source>
          <target state="translated">预定义的配置文件可以给其他调试值赋予意义;例如,当打印 &quot;goroutine &quot;配置文件时,debug=2意味着以与围棋程序因未恢复的恐慌而死亡时相同的形式打印goroutine堆栈。</target>
        </trans-unit>
        <trans-unit id="58481973143a6de618e8538c648e764b31b42f2b" translate="yes" xml:space="preserve">
          <source>The print built-in function formats its arguments in an implementation-specific way and writes the result to standard error. Print is useful for bootstrapping and debugging; it is not guaranteed to stay in the language.</source>
          <target state="translated">print内置函数以特定于实现的方式格式化其参数,并将结果写入标准错误。print对于引导和调试是有用的,它不保证会留在语言中。</target>
        </trans-unit>
        <trans-unit id="91f04de49b9af203098665c6f8b752b5392b78a0" translate="yes" xml:space="preserve">
          <source>The println built-in function formats its arguments in an implementation-specific way and writes the result to standard error. Spaces are always added between arguments and a newline is appended. Println is useful for bootstrapping and debugging; it is not guaranteed to stay in the language.</source>
          <target state="translated">println内置函数以特定于实现的方式格式化其参数,并将结果写入标准错误。参数之间总是添加空格,并附加一个换行。Println对引导和调试很有用;它并不保证会留在语言中。</target>
        </trans-unit>
        <trans-unit id="151eef92ef01a650c4a9036a013718d694ffc693" translate="yes" xml:space="preserve">
          <source>The provided Context must be non-nil. If the context expires before the connection is complete, an error is returned. Once successfully connected, any expiration of the context will not affect the connection.</source>
          <target state="translated">提供的Context必须为非零。如果上下文在连接完成前过期,将返回一个错误。一旦连接成功,任何过期的上下文将不会影响连接。</target>
        </trans-unit>
        <trans-unit id="0e411a42789a39be423654b810b14a1d819d3f7a" translate="yes" xml:space="preserve">
          <source>The provided TxOptions is optional and may be nil if defaults should be used. If a non-default isolation level is used that the driver doesn't support, an error will be returned.</source>
          <target state="translated">提供的TxOptions是可选的,如果应该使用默认值,则可能为零。如果使用了驱动不支持的非默认隔离级别,将返回一个错误。</target>
        </trans-unit>
        <trans-unit id="decd2b405e8241c6f8e12f33bd5a3bb2cc5dc04e" translate="yes" xml:space="preserve">
          <source>The provided body may be nil. If the body is of type *bytes.Reader, *strings.Reader, or *bytes.Buffer, the Request.ContentLength is set.</source>
          <target state="translated">所提供的body可以是nil.如果body的类型是*bytes.Reader、*strings.Reader或*bytes.Buffer,则设置Request.ContentLength。如果body的类型是*bytes.Reader、*strings.Reader或*bytes.Buffer,则设置Request.ContentLength。</target>
        </trans-unit>
        <trans-unit id="58ddb87ccdb3a3bbf17dded9af2e6f690f9fa593" translate="yes" xml:space="preserve">
          <source>The provided code should be in the 3xx range and is usually StatusMovedPermanently, StatusFound or StatusSeeOther.</source>
          <target state="translated">提供的代码应该在3xx范围内,通常是StatusMovedPermanently、StatusFound或StatusSeeOther。</target>
        </trans-unit>
        <trans-unit id="86be20106cb95d195cb582ade394435819f24514" translate="yes" xml:space="preserve">
          <source>The provided context is used for the preparation of the statement, not for the execution of the statement.</source>
          <target state="translated">所提供的上下文用于编制语句,而不是执行语句。</target>
        </trans-unit>
        <trans-unit id="dd14eed153c5e1b07e7490871396f032fee4f925" translate="yes" xml:space="preserve">
          <source>The provided context is used to kill the process (by calling os.Process.Kill) if the context becomes done before the command completes on its own.</source>
          <target state="translated">如果上下文在命令完成之前就已经完成了,那么所提供的上下文将被用来杀死进程(通过调用os.Process.Kill)。</target>
        </trans-unit>
        <trans-unit id="a4964ee167f777b88ff9017caa2a6e7f575494e2" translate="yes" xml:space="preserve">
          <source>The provided context is used until the transaction is committed or rolled back. If the context is canceled, the sql package will roll back the transaction. Tx.Commit will return an error if the context provided to BeginTx is canceled.</source>
          <target state="translated">所提供的上下文被使用,直到事务被提交或回滚。如果上下文被取消,sql包将回滚事务。如果提供给BeginTx的上下文被取消,Tx.Commit将返回一个错误。</target>
        </trans-unit>
        <trans-unit id="08a11fcf0761deb535b1afddd2450e0cb1b073dd" translate="yes" xml:space="preserve">
          <source>The provided context will be used for the preparation of the context, not for the execution of the returned statement. The returned statement will run in the transaction context.</source>
          <target state="translated">所提供的上下文将用于上下文的准备,而不是用于执行返回的语句。返回的语句将在事务上下文中运行。</target>
        </trans-unit>
        <trans-unit id="36087efe71a5f2727d53bfdfa94ece516eb41424" translate="yes" xml:space="preserve">
          <source>The provided key must be comparable and should not be of type string or any other built-in type to avoid collisions between packages using context. Users of WithValue should define their own types for keys. To avoid allocating when assigning to an interface{}, context keys often have concrete type struct{}. Alternatively, exported context key variables' static type should be a pointer or interface.</source>
          <target state="translated">所提供的键必须是可比较的,并且不应该是字符串或任何其他内置类型,以避免使用上下文的包之间发生碰撞。WithValue的用户应该自己定义键的类型。为了避免分配到接口{}时的分配,上下文键通常具有具体的类型struct{}。另外,导出的上下文键变量的静态类型应该是指针或接口。</target>
        </trans-unit>
        <trans-unit id="85ad36caa7041b29ad99437d10d43da203313ed0" translate="yes" xml:space="preserve">
          <source>The race detector kills the program if it exceeds 8192 concurrent goroutines, so use care when running parallel tests with the -race flag set.</source>
          <target state="translated">赛跑检测器会在超过8192个并发goroutines的情况下杀死程序,所以在设置-race标志的情况下运行并行测试时要小心。</target>
        </trans-unit>
        <trans-unit id="8b5744dbc3f5965d88d3d9f6581899823cd536e1" translate="yes" xml:space="preserve">
          <source>The rand parameter is used as a source of entropy to ensure that encrypting the same message twice doesn't result in the same ciphertext.</source>
          <target state="translated">rand参数作为熵的来源,以确保对同一消息加密两次不会产生相同的密文。</target>
        </trans-unit>
        <trans-unit id="9b3902f0d9da9da0e87784ba5652f4c8601d4919" translate="yes" xml:space="preserve">
          <source>The random parameter is used as a source of entropy to ensure that encrypting the same message twice doesn't result in the same ciphertext.</source>
          <target state="translated">随机参数作为熵的来源,以确保对同一消息加密两次不会产生相同的密文。</target>
        </trans-unit>
        <trans-unit id="cf169dddc14ea8341fcb30899e22a5fa61df4712" translate="yes" xml:space="preserve">
          <source>The random parameter, if not nil, is used to blind the private-key operation and avoid timing side-channel attacks. Blinding is purely internal to this function &amp;ndash; the random data need not match that used when encrypting.</source>
          <target state="translated">随机参数（如果不为nil）用于使私钥操作失效，并避免定时进行边信道攻击。盲处理纯粹是此功能的内部功能&amp;ndash;随机数据不必与加密时使用的数据匹配。</target>
        </trans-unit>
        <trans-unit id="2314ea9b04c810fb371325317bf102a02d2d59d0" translate="yes" xml:space="preserve">
          <source>The rawurl may be relative (a path, without a host) or absolute (starting with a scheme). Trying to parse a hostname and path without a scheme is invalid but may not necessarily return an error, due to parsing ambiguities.</source>
          <target state="translated">rawurl可以是相对的(一个路径,没有主机)或绝对的(以scheme开始)。试图解析一个没有方案的主机名和路径是无效的,但由于解析的模糊性,不一定会返回错误。</target>
        </trans-unit>
        <trans-unit id="239176c955d354cb84e342df1da6a160a09d1822" translate="yes" xml:space="preserve">
          <source>The read and write halves of the connection are serialized independently, so no interlocking is required. However each half may be accessed concurrently so the implementation of conn should protect against concurrent reads or concurrent writes.</source>
          <target state="translated">连接的读写两半是独立序列化的,所以不需要互锁。然而每一半都可能被并发访问,所以conn的实现应该防止并发读或并发写。</target>
        </trans-unit>
        <trans-unit id="b43ec28ed349612adbaa799bb6c92934c3b075dc" translate="yes" xml:space="preserve">
          <source>The real built-in function returns the real part of the complex number c. The return value will be floating point type corresponding to the type of c.</source>
          <target state="translated">实数内置函数返回复数c的实数部分,返回值将是c类型对应的浮点类型。</target>
        </trans-unit>
        <trans-unit id="9bb09164885f351e6fb900da553f1e63b375bfa9" translate="yes" xml:space="preserve">
          <source>The recognized day of week formats are &quot;Mon&quot; and &quot;Monday&quot;. The recognized month formats are &quot;Jan&quot; and &quot;January&quot;.</source>
          <target state="translated">公认的星期格式是 &quot;Mon &quot;和 &quot;Monday&quot;。公认的月份格式是 &quot;Jan &quot;和 &quot;January&quot;。</target>
        </trans-unit>
        <trans-unit id="2c571daa54e2fb7d0c128741daf715a11d1e44fe" translate="yes" xml:space="preserve">
          <source>The recover built-in function allows a program to manage behavior of a panicking goroutine. Executing a call to recover inside a deferred function (but not any function called by it) stops the panicking sequence by restoring normal execution and retrieves the error value passed to the call of panic. If recover is called outside the deferred function it will not stop a panicking sequence. In this case, or when the goroutine is not panicking, or if the argument supplied to panic was nil, recover returns nil. Thus the return value from recover reports whether the goroutine is panicking.</source>
          <target state="translated">内建的recover函数允许程序管理一个恐慌性程序的行为。在递延函数(但不包括被它调用的任何函数)中执行对recover的调用,通过恢复正常执行来停止恐慌序列,并检索传递给panic调用的错误值。如果在递延函数之外调用recover,则不会停止恐慌序列。在这种情况下,或者当goroutine没有恐慌时,或者如果提供给panic的参数是nil,recover就会返回nil。因此,recover的返回值会报告goroutine是否正在恐慌。</target>
        </trans-unit>
        <trans-unit id="ff14ed6c9720c452a0294998e96d92039ec86474" translate="yes" xml:space="preserve">
          <source>The regexp implementation provided by this package is guaranteed to run in time linear in the size of the input. (This is a property not guaranteed by most open source implementations of regular expressions.) For more information about this property, see</source>
          <target state="translated">本包提供的regexp实现保证在时间上以输入的大小线性运行。(这是大多数正则表达式的开源实现所不能保证的属性。)关于这个属性的更多信息,请参见</target>
        </trans-unit>
        <trans-unit id="e4c94cab05a4e2263ef4f912bc17e254d9de85c1" translate="yes" xml:space="preserve">
          <source>The regionType is used to classify regions, so there should be only a handful of unique region types.</source>
          <target state="translated">regionType用于对区域进行分类,所以应该只有少数独特的区域类型。</target>
        </trans-unit>
        <trans-unit id="613161bf225c19a5f2c8859dc32ad7cbf64fe341" translate="yes" xml:space="preserve">
          <source>The regular expression syntax understood by this package when parsing with the Perl flag is as follows. Parts of the syntax can be disabled by passing alternate flags to Parse.</source>
          <target state="translated">当使用Perl标志进行解析时,本包所理解的正则表达式语法如下。可以通过向 Parse 传递备用标志来禁用部分语法。</target>
        </trans-unit>
        <trans-unit id="414d3f9a62c65f403de754cbbecda8b294ef6a05" translate="yes" xml:space="preserve">
          <source>The remaining patterns enumerate the only valid conversions from uintptr to Pointer.</source>
          <target state="translated">剩下的模式列举了唯一有效的从uintptr到Pointer的转换。</target>
        </trans-unit>
        <trans-unit id="f01d454f6a8093b81d93ec48391c3d15861fea72" translate="yes" xml:space="preserve">
          <source>The remaining signals are asynchronous signals. They are not triggered by program errors, but are instead sent from the kernel or from some other program.</source>
          <target state="translated">其余的信号是异步信号,它们不是由程序错误触发的,而是由内核或其他程序发送的。它们不是由程序错误触发的,而是由内核或其他程序发送的。</target>
        </trans-unit>
        <trans-unit id="b6f243f72fd3fe537acd4a5fca41b95e81ce45b9" translate="yes" xml:space="preserve">
          <source>The representation of types is described below. When a type is defined on a given connection between an Encoder and Decoder, it is assigned a signed integer type id. When Encoder.Encode(v) is called, it makes sure there is an id assigned for the type of v and all its elements and then it sends the pair (typeid, encoded-v) where typeid is the type id of the encoded type of v and encoded-v is the gob encoding of the value v.</source>
          <target state="translated">类型的表示方法如下所述。当一个类型被定义在给定的编码器和解码器之间的连接上时,它会被分配一个有符号的整数类型id。当Encoder.Encode(v)被调用时,它确保为v的类型和它的所有元素分配了一个id,然后它发送一对(typeid,encoded-v),其中typeid是v的编码类型的类型id,encoded-v是值v的gob编码。</target>
        </trans-unit>
        <trans-unit id="cd667628565a5086d3e9895b56322424dc5621cd" translate="yes" xml:space="preserve">
          <source>The request Body, if non-nil, will be closed by the underlying Transport, even on errors.</source>
          <target state="translated">如果请求主体为非零,则会被底层传输关闭,即使出现错误。</target>
        </trans-unit>
        <trans-unit id="d4e026c3f59ca2f49146d499574e033e155a3b79" translate="yes" xml:space="preserve">
          <source>The resolver decision can be overridden by setting the netdns value of the GODEBUG environment variable (see package runtime) to go or cgo, as in:</source>
          <target state="translated">可以通过将GODEBUG环境变量(见包运行时)的netdns值设置为go或cgo来覆盖解析器的决定,如。</target>
        </trans-unit>
        <trans-unit id="85ba008f9a41b800d285074394b704f73cc09894" translate="yes" xml:space="preserve">
          <source>The rest of this package comment may be skipped on first reading; it includes details necessary to understand escaping contexts and error messages. Most users will not need to understand these details.</source>
          <target state="translated">这个包评论的其余部分可以在第一次阅读时跳过;它包含了理解转义上下文和错误信息所必需的细节。大多数用户不需要了解这些细节。</target>
        </trans-unit>
        <trans-unit id="5f29380aa9a229b911cfb4cbcef02c25951562ac" translate="yes" xml:space="preserve">
          <source>The rest of this section gives the precise details of how operations use monotonic clocks, but understanding those details is not required to use this package.</source>
          <target state="translated">本节其余部分给出了操作如何使用单调时钟的精确细节,但了解这些细节并不是使用这个包的必要条件。</target>
        </trans-unit>
        <trans-unit id="b7f11101676a7b7c4f383ade5d8d3f82131c1b53" translate="yes" xml:space="preserve">
          <source>The result of Scan is one of these tokens or a Unicode character.</source>
          <target state="translated">扫描的结果是这些标记中的一个或一个Unicode字符。</target>
        </trans-unit>
        <trans-unit id="4646462be207e1c8f655d521c7883b8db5be5339" translate="yes" xml:space="preserve">
          <source>The results of a benchmark run.</source>
          <target state="translated">基准运行的结果。</target>
        </trans-unit>
        <trans-unit id="6be7e87ff9924a05b7bc2a7006d807f1fab39e3d" translate="yes" xml:space="preserve">
          <source>The returned *Float f is nil and the value of z is valid but not defined if an error is reported.</source>
          <target state="translated">返回的*Float f为nil,z的值是有效的,但如果报错,则没有定义。</target>
        </trans-unit>
        <trans-unit id="bac86830681be1d31b72f9f7791b1c44ac2452e7" translate="yes" xml:space="preserve">
          <source>The returned Cmd's Args field is constructed from the command name followed by the elements of arg, so arg should not include the command name itself. For example, Command(&quot;echo&quot;, &quot;hello&quot;). Args[0] is always name, not the possibly resolved Path.</source>
          <target state="translated">返回的Cmd的Args字段是由命令名后面的arg元素构造的,所以arg不应该包括命令名本身。例如,Command(&quot;echo&quot;,&quot;hello&quot;)。Args[0]总是name,而不是可能解析的Path。</target>
        </trans-unit>
        <trans-unit id="fe921f2e96cf2be56c2bf49f4740170d8dd45071" translate="yes" xml:space="preserve">
          <source>The returned Conn, if any, will always be of type *Conn.</source>
          <target state="translated">返回的Conn,如果有的话,将始终是*Conn类型。</target>
        </trans-unit>
        <trans-unit id="3bc6a14f8ce0d88107543f9f02901b96c67b460c" translate="yes" xml:space="preserve">
          <source>The returned DB is safe for concurrent use by multiple goroutines and maintains its own pool of idle connections. Thus, the Open function should be called just once. It is rarely necessary to close a DB.</source>
          <target state="translated">返回的DB可以安全地被多个goroutine并发使用,并维护自己的空闲连接池。因此,Open函数应该只被调用一次。很少需要关闭一个DB。</target>
        </trans-unit>
        <trans-unit id="c94572c3b7d816968d78d57402944f7efb4246e7" translate="yes" xml:space="preserve">
          <source>The returned DB is safe for concurrent use by multiple goroutines and maintains its own pool of idle connections. Thus, the OpenDB function should be called just once. It is rarely necessary to close a DB.</source>
          <target state="translated">返回的DB对于多个goroutine并发使用是安全的,并且维护自己的空闲连接池。因此,OpenDB函数应该只被调用一次。很少需要关闭一个DB。</target>
        </trans-unit>
        <trans-unit id="33f1666e076b57e7a3379acacb81a7ec24e7d31d" translate="yes" xml:space="preserve">
          <source>The returned RawConn only supports calling Control. Read and Write return an error.</source>
          <target state="translated">返回的RawConn只支持调用Control。读和写都会返回一个错误。</target>
        </trans-unit>
        <trans-unit id="00382818b7b561dcf8c2e41afc3acbf78809ee7a" translate="yes" xml:space="preserve">
          <source>The returned Response will have at least its StatusCode, Header, Body, and optionally Trailer populated. More fields may be populated in the future, so callers should not DeepEqual the result in tests.</source>
          <target state="translated">返回的Response将至少填充其StatusCode、Header、Body和可选的Trailer。未来可能会有更多的字段被填充,所以调用者不应该在测试中对结果进行DeepEqual。</target>
        </trans-unit>
        <trans-unit id="f4f37717fc57244b8b099472fa87f281f196d58d" translate="yes" xml:space="preserve">
          <source>The returned context is always non-nil; it defaults to the background context.</source>
          <target state="translated">返回的上下文总是非零,它默认为背景上下文。</target>
        </trans-unit>
        <trans-unit id="9cbe06fbabaade2695a345469e46bbf5011eaae5" translate="yes" xml:space="preserve">
          <source>The returned end function is used to mark the task's end. The trace tool measures task latency as the time between task creation and when the end function is called, and provides the latency distribution per task type. If the end function is called multiple times, only the first call is used in the latency measurement.</source>
          <target state="translated">返回的结束函数用于标记任务的结束。跟踪工具将任务延迟测量为从任务创建到调用结束函数之间的时间,并提供每个任务类型的延迟分布。如果结束函数被多次调用,则延迟测量中只使用第一次调用。</target>
        </trans-unit>
        <trans-unit id="f0a8feeaa4dbaf36e773a52f49c0b0ac6bb7e74a" translate="yes" xml:space="preserve">
          <source>The returned error is nil if the command runs, has no problems copying stdin, stdout, and stderr, and exits with a zero exit status.</source>
          <target state="translated">如果命令运行,复制stdin、stdout和stderr没有问题,并且退出状态为零,则返回的错误为nil。</target>
        </trans-unit>
        <trans-unit id="4d6b3f09dc97620be2a232fb3dc17468c15d1426" translate="yes" xml:space="preserve">
          <source>The returned list does not identify the associated interface; use Interfaces and Interface.Addrs for more detail.</source>
          <target state="translated">返回的列表并不能识别相关的接口;使用Interfaces和Interface.Addrs了解更多细节。</target>
        </trans-unit>
        <trans-unit id="c6a6b1723d6bc4ac24e64af0ce75d94122db9245" translate="yes" xml:space="preserve">
          <source>The returned memory allocator statistics are up to date as of the call to ReadMemStats. This is in contrast with a heap profile, which is a snapshot as of the most recently completed garbage collection cycle.</source>
          <target state="translated">返回的内存分配器统计数据在调用ReadMemStats时是最新的。这与堆配置文件不同,堆配置文件是最近完成的垃圾收集周期的快照。</target>
        </trans-unit>
        <trans-unit id="a6ee6f83dacc73003b6dade23a5eca55ab60b66f" translate="yes" xml:space="preserve">
          <source>The returned os.File's file descriptor is different from the connection's. Attempting to change properties of the original using this duplicate may or may not have the desired effect.</source>
          <target state="translated">返回的 os.File 的文件描述符与连接的不同。试图使用这个副本来改变原始文件的属性,可能会或可能不会达到预期的效果。</target>
        </trans-unit>
        <trans-unit id="5927f2050b65cd29032e207117c8b2d6ca472e54" translate="yes" xml:space="preserve">
          <source>The returned path ends in a slash only if it is the root &quot;/&quot;.</source>
          <target state="translated">只有当路径是根目录&quot;/&quot;时,返回的路径才以斜线结束。</target>
        </trans-unit>
        <trans-unit id="004ac519a1c16ea761d189382ea9cc0c1b68b7d1" translate="yes" xml:space="preserve">
          <source>The returned path ends in a slash only if it represents a root directory, such as &quot;/&quot; on Unix or `C:\` on Windows.</source>
          <target state="translated">返回的路径只有在代表根目录的情况下才以斜线结尾,比如Unix上的&quot;/&quot;或Windows上的`C:\`。</target>
        </trans-unit>
        <trans-unit id="709611ccac6cb61ed7ee0c2fc8499ed7e268fed4" translate="yes" xml:space="preserve">
          <source>The returned profile may be up to two garbage collection cycles old. This is to avoid skewing the profile toward allocations; because allocations happen in real time but frees are delayed until the garbage collector performs sweeping, the profile only accounts for allocations that have had a chance to be freed by the garbage collector.</source>
          <target state="translated">返回的配置文件可能是两个垃圾收集周期前的。这是为了避免配置文件偏向于分配;因为分配是实时发生的,但释放是延迟的,直到垃圾收集器执行扫除,所以配置文件只记录有机会被垃圾收集器释放的分配。</target>
        </trans-unit>
        <trans-unit id="2fcbc7cecfbd88a968cff813905d726fdf40b131" translate="yes" xml:space="preserve">
          <source>The returned slice is the certificate in DER encoding.</source>
          <target state="translated">返回的分片是DER编码的证书。</target>
        </trans-unit>
        <trans-unit id="01c758564c188da314abf0218bd7cfbe2c752f80" translate="yes" xml:space="preserve">
          <source>The returned slice is the certificate request in DER encoding.</source>
          <target state="translated">返回的分片是DER编码的证书请求。</target>
        </trans-unit>
        <trans-unit id="56ef9da288a159e17f780d686422f0dfcfa221a7" translate="yes" xml:space="preserve">
          <source>The returned statement operates within the transaction and can no longer be used once the transaction has been committed or rolled back.</source>
          <target state="translated">返回的语句在事务中操作,一旦事务被提交或回滚,就不能再使用。</target>
        </trans-unit>
        <trans-unit id="eaef2ac25b5ec95632c077f9297b6bf55f5dd3f6" translate="yes" xml:space="preserve">
          <source>The returned statement operates within the transaction and will be closed when the transaction has been committed or rolled back.</source>
          <target state="translated">被退回的报表在交易内操作,当交易被承诺或回滚时,将被关闭。</target>
        </trans-unit>
        <trans-unit id="10df7eea472cec1ead17a66cb1fdaefe2e6578cc" translate="yes" xml:space="preserve">
          <source>The returned string is meant for debugging; for a stable serialized representation, use t.MarshalText, t.MarshalBinary, or t.Format with an explicit format string.</source>
          <target state="translated">返回的字符串是用来调试的;要想获得稳定的序列化表示,请使用t.MarshalText、t.MarshalBinary或t.Format,并使用明确的格式字符串。</target>
        </trans-unit>
        <trans-unit id="48866f9aa69c2bb04dcb85d20c5a3c1d2d405ca8" translate="yes" xml:space="preserve">
          <source>The rule Title uses for word boundaries does not handle Unicode punctuation properly.</source>
          <target state="translated">Title使用的单词边界规则不能正确处理Unicode标点符号。</target>
        </trans-unit>
        <trans-unit id="f80f01b0edf7103d5ecb8ca06eb4e22919710f70" translate="yes" xml:space="preserve">
          <source>The same Context may be passed to functions running in different goroutines; Contexts are safe for simultaneous use by multiple goroutines.</source>
          <target state="translated">同一上下文可以传递给在不同的goroutine中运行的函数;上下文对于多个goroutine同时使用是安全的。</target>
        </trans-unit>
        <trans-unit id="a401c4efb67cc0055f52caa84dcf2de0d8f63cd7" translate="yes" xml:space="preserve">
          <source>The second argument, quote, specifies the type of literal being parsed and therefore which escaped quote character is permitted. If set to a single quote, it permits the sequence \' and disallows unescaped '. If set to a double quote, it permits \&quot; and disallows unescaped &quot;. If set to zero, it does not permit either escape and allows both quote characters to appear unescaped.</source>
          <target state="translated">第二个参数quote指定了被解析的文字类型,因此允许使用哪种转义引号字符。如果设置为单引号,它允许使用序列&quot;/&quot;,而不允许使用未转义的&quot;&quot;。如果设置为双引号,则允许使用&quot;/&quot;,不允许使用未封顶的&quot;&quot;。如果设置为零,则不允许任何一个转义字符,允许两个引号字符都不封顶。</target>
        </trans-unit>
        <trans-unit id="40a1d3ecbed0bf217ec97ece1c42e914315bd313" translate="yes" xml:space="preserve">
          <source>The security model used by this package assumes that template authors are trusted, while Execute's data parameter is not. More details are provided below.</source>
          <target state="translated">本包使用的安全模型假设模板作者是可信的,而Execute的数据参数是不可信的。下面提供更多细节。</target>
        </trans-unit>
        <trans-unit id="a70cb84ae80d93013971dc3c09e0dd11fbe3a660" translate="yes" xml:space="preserve">
          <source>The server calls (for HTTP service):</source>
          <target state="translated">服务器调用(用于HTTP服务)。</target>
        </trans-unit>
        <trans-unit id="4694acea63f5ebf8b8be35e4e84982505cd7d21a" translate="yes" xml:space="preserve">
          <source>The server may handle requests on a single connection by calling ServeConn. More typically it will create a network listener and call Accept or, for an HTTP listener, HandleHTTP and http.Serve.</source>
          <target state="translated">服务器可以通过调用ServeConn来处理单个连接上的请求,更典型的是它会创建网络监听器并调用Accept,或者对于HTTP监听器,调用HandleHTTP和http.Serve。更典型的是,它将创建一个网络监听器并调用Accept,或者对于一个HTTP监听器,调用HandleHTTP和http.Serve。</target>
        </trans-unit>
        <trans-unit id="901fd3527b931189389dc8b05aa80a401b308de0" translate="yes" xml:space="preserve">
          <source>The set of available CPUs is checked by querying the operating system at process startup. Changes to operating system CPU allocation after process startup are not reflected.</source>
          <target state="translated">在进程启动时通过查询操作系统来检查可用CPU的集合。进程启动后操作系统CPU分配的变化不会被反映出来。</target>
        </trans-unit>
        <trans-unit id="a4ffb207191c8f11d25b769c7eab3f4bd62e8f7a" translate="yes" xml:space="preserve">
          <source>The set of metrics defined by this package may evolve as the runtime itself evolves, and also enables variation across Go implementations, whose relevant metric sets may not intersect.</source>
          <target state="translated">这个包所定义的度量集可能会随着运行时本身的发展而发展,也可以实现不同Go实现之间的变化,其相关的度量集可能不会相交。</target>
        </trans-unit>
        <trans-unit id="10e3cd17c3685da24fcde871ef4da00a080771a9" translate="yes" xml:space="preserve">
          <source>The signals SIGKILL and SIGSTOP may not be caught by a program, and therefore cannot be affected by this package.</source>
          <target state="translated">信号SIGKILL和SIGSTOP可能不会被程序捕获,因此不会受到这个软件包的影响。</target>
        </trans-unit>
        <trans-unit id="7621705ac03f21ac222836c967959708135562eb" translate="yes" xml:space="preserve">
          <source>The simplest use of a Scanner, to read standard input as a set of lines.</source>
          <target state="translated">扫描仪最简单的用法,就是将标准输入作为一组行来读取。</target>
        </trans-unit>
        <trans-unit id="9c0657904725889b0c9ba75534abc4f635bc0b2b" translate="yes" xml:space="preserve">
          <source>The size of a CRC-32 checksum in bytes.</source>
          <target state="translated">CRC-32校验和的大小,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="3ff608e7233df0580119a8a262ba634622895d8a" translate="yes" xml:space="preserve">
          <source>The size of a CRC-64 checksum in bytes.</source>
          <target state="translated">CRC-64校验和的大小,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="caae8e5aad6dbb0160181390b9818b080d122c80" translate="yes" xml:space="preserve">
          <source>The size of a SHA-1 checksum in bytes.</source>
          <target state="translated">SHA-1校验和的大小,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="cea16f97cc88534275f0e03f305d57951a36e34b" translate="yes" xml:space="preserve">
          <source>The size of a SHA224 checksum in bytes.</source>
          <target state="translated">SHA224校验和的大小,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="3a1556147bf25a0038243a962f16bc9d44b98e20" translate="yes" xml:space="preserve">
          <source>The size of a SHA256 checksum in bytes.</source>
          <target state="translated">SHA256校验和的大小,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="fb49c909a50ec86545c33e34c0f3d64148914e03" translate="yes" xml:space="preserve">
          <source>The size of an Adler-32 checksum in bytes.</source>
          <target state="translated">以字节为单位的Adler-32校验和的大小。</target>
        </trans-unit>
        <trans-unit id="edf1ef16cc66ffa121682ca1207ef5467651c4f4" translate="yes" xml:space="preserve">
          <source>The size of an MD5 checksum in bytes.</source>
          <target state="translated">MD5校验和的大小,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="248e03e24b52c36053fea2b5fabdbb42fe255abb" translate="yes" xml:space="preserve">
          <source>The skip parameter has the same meaning as runtime.Caller's skip and controls where the stack trace begins. Passing skip=0 begins the trace in the function calling Add. For example, given this execution stack:</source>
          <target state="translated">skip参数与runtime.Caller的skip意义相同,控制堆栈跟踪的开始位置。传递 skip=0,则在调用 Add 的函数中开始跟踪。例如,给定这个执行栈。</target>
        </trans-unit>
        <trans-unit id="b675e8a3e2a529e23f6f667c1adf36c39ed93efb" translate="yes" xml:space="preserve">
          <source>The slice returned by this method consists of all the substrings of s not contained in the slice returned by FindAllString. When called on an expression that contains no metacharacters, it is equivalent to strings.SplitN.</source>
          <target state="translated">本方法返回的分片由FindAllString返回的分片中未包含的s的所有子串组成。当调用一个不包含元字符的表达式时,它相当于strings.SplitN。</target>
        </trans-unit>
        <trans-unit id="37fc7946d5ac5fa1638ca298818fb97686f9142e" translate="yes" xml:space="preserve">
          <source>The smtp package is frozen and is not accepting new features. Some external packages provide more functionality. See:</source>
          <target state="translated">smtp包被冻结,不接受新功能。一些外部软件包提供了更多的功能。请看:</target>
        </trans-unit>
        <trans-unit id="37671db71f74ceff10a366ff8f17e7a0a28fae66" translate="yes" xml:space="preserve">
          <source>The sort is not guaranteed to be stable. For a stable sort, use SliceStable.</source>
          <target state="translated">不保证排序的稳定性。对于稳定的排序,请使用 SliceStable。</target>
        </trans-unit>
        <trans-unit id="bda42a397fbbab417ff8adfb3aa5399f5d54b818" translate="yes" xml:space="preserve">
          <source>The sort is not guaranteed to be stable: equal elements may be reversed from their original order. For a stable sort, use SliceStable.</source>
          <target state="translated">排序并不保证稳定:相等的元素可能会与原来的顺序相反。对于稳定的排序,请使用 SliceStable。</target>
        </trans-unit>
        <trans-unit id="17c5e77086e67a3f2c51a48bac9596dffc360456" translate="yes" xml:space="preserve">
          <source>The source and destination values/types need not correspond exactly. For structs, fields (identified by name) that are in the source but absent from the receiving variable will be ignored. Fields that are in the receiving variable but missing from the transmitted type or value will be ignored in the destination. If a field with the same name is present in both, their types must be compatible. Both the receiver and transmitter will do all necessary indirection and dereferencing to convert between gobs and actual Go values. For instance, a gob type that is schematically,</source>
          <target state="translated">源和目标值/类型不需要完全对应。对于结构,源变量中的字段(用名称标识),但接收变量中没有的字段将被忽略。对于结构体来说,源变量中的字段(用名字标识)在接收变量中,但在接收变量中不存在的字段将被忽略;在目标变量中,在接收变量中但在传输的类型或值中缺失的字段将被忽略。如果一个名字相同的字段出现在两个变量中,它们的类型必须是兼容的。接收器和发送器都会做所有必要的内推和去引用,以便在gob和实际的围棋值之间进行转换。例如,一个gob类型在原理上是:</target>
        </trans-unit>
        <trans-unit id="0268779129500cf4856c5f56fd67106abaf097eb" translate="yes" xml:space="preserve">
          <source>The source code could include additional Go code. That code was never compiled but would be processed by tools like godoc and might be useful as end-user documentation.</source>
          <target state="translated">源代码可以包括额外的Go代码。这些代码从未被编译过,但会被像godoc这样的工具处理,并可能作为终端用户的文档。</target>
        </trans-unit>
        <trans-unit id="535d0edaef1db8d5c1dc136b1a303868255bb996" translate="yes" xml:space="preserve">
          <source>The source:</source>
          <target state="translated">来源:</target>
        </trans-unit>
        <trans-unit id="e645e5bfb164f126d92a3414aa1a585176c8e465" translate="yes" xml:space="preserve">
          <source>The sql package checks for value checkers in the following order, stopping at the first found match: Stmt.NamedValueChecker, Conn.NamedValueChecker, Stmt.ColumnConverter, DefaultParameterConverter.</source>
          <target state="translated">sql包按照以下顺序检查值检查器,在第一个发现的匹配处停止。Stmt.NamedValueChecker,Conn.NamedValueChecker,Stmt.ColumnConverter,DefaultParameterConverter.</target>
        </trans-unit>
        <trans-unit id="bf35db5d84a5c59679d57c2063978bf2973a302c" translate="yes" xml:space="preserve">
          <source>The sql package creates and frees connections automatically; it also maintains a free pool of idle connections. If the database has a concept of per-connection state, such state can be reliably observed within a transaction (Tx) or connection (Conn). Once DB.Begin is called, the returned Tx is bound to a single connection. Once Commit or Rollback is called on the transaction, that transaction's connection is returned to DB's idle connection pool. The pool size can be controlled with SetMaxIdleConns.</source>
          <target state="translated">sql包会自动创建和释放连接;它还会维护一个空闲的连接池。如果数据库有每个连接状态的概念,那么这种状态可以在一个事务(Tx)或连接(Conn)中可靠地观察到。一旦DB.Begin被调用,返回的Tx就会被绑定到单个连接上。一旦在事务上调用Commit或Rollback,该事务的连接就会返回到DB的空闲连接池中。池的大小可以通过SetMaxIdleConns来控制。</target>
        </trans-unit>
        <trans-unit id="14c50009f306ef9ba308a3f9f45cb12ceab6e041" translate="yes" xml:space="preserve">
          <source>The sql package must be used in conjunction with a database driver. See &lt;a href=&quot;https://golang.org/s/sqldrivers&quot;&gt;https://golang.org/s/sqldrivers&lt;/a&gt; for a list of drivers.</source>
          <target state="translated">sql程序包必须与数据库驱动程序一起使用。有关驱动程序列表，请参见&lt;a href=&quot;https://golang.org/s/sqldrivers&quot;&gt;https://golang.org/s/sqldrivers&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ff11c76849e5520b5d3c1908876a0a08249bbd90" translate="yes" xml:space="preserve">
          <source>The src/ directory holds source code. The path below 'src' determines the import path or executable name.</source>
          <target state="translated">src/目录下存放的是源代码。src &quot;下面的路径决定了导入路径或可执行文件的名称。</target>
        </trans-unit>
        <trans-unit id="51fce287253a04b9aa4e50fe0cda26970eb0eeca" translate="yes" xml:space="preserve">
          <source>The statements prepared for a transaction by calling the transaction's Prepare or Stmt methods are closed by the call to Commit or Rollback.</source>
          <target state="translated">通过调用事务的Prepare或Stmt方法为事务准备的语句,通过调用Commit或Rollback关闭。</target>
        </trans-unit>
        <trans-unit id="7aaae34f98e3bd969409b9d4ab9b72c26d296745" translate="yes" xml:space="preserve">
          <source>The stop function releases resources associated with it, so code should call stop as soon as the operations running in this Context complete and signals no longer need to be diverted to the context.</source>
          <target state="translated">stop函数释放与之相关的资源,因此,一旦在这个Context中运行的操作完成,不再需要将信号转移到上下文中,代码就应该立即调用stop。</target>
        </trans-unit>
        <trans-unit id="0e3f26a83995cf9b083b94337323c62f8d2e679a" translate="yes" xml:space="preserve">
          <source>The stop function unregisters the signal behavior, which, like signal.Reset, may restore the default behavior for a given signal. For example, the default behavior of a Go program receiving os.Interrupt is to exit. Calling NotifyContext(parent, os.Interrupt) will change the behavior to cancel the returned context. Future interrupts received will not trigger the default (exit) behavior until the returned stop function is called.</source>
          <target state="translated">stop函数可以解除对信号行为的注册,它和signal.Reset一样,可以恢复某个信号的默认行为。例如,一个Go程序接收到os.中断时的默认行为是退出。调用NotifyContext(parent,os.Interrupt)将改变行为,取消返回的上下文。未来接收到的中断将不会触发默认(退出)行为,直到返回的停止函数被调用。</target>
        </trans-unit>
        <trans-unit id="266ee83c3a485624a9ce3be711986c42904d65df" translate="yes" xml:space="preserve">
          <source>The swap operation, implemented by the SwapT functions, is the atomic equivalent of:</source>
          <target state="translated">由SwapT函数实现的交换操作,其原子等价物为:。</target>
        </trans-unit>
        <trans-unit id="78109ee602f829fc62630aa0958e0668bde1d9d0" translate="yes" xml:space="preserve">
          <source>The symbolizer function may be nil, in which case the results of the traceback function will be displayed as numbers. If the traceback function is nil, the symbolizer function will never be called. The context function may be nil, in which case the traceback function will only be called with the context field set to zero. If the context function is nil, then calls from Go to C to Go will not show a traceback for the C portion of the call stack.</source>
          <target state="translated">符号化函数可能为零,在这种情况下,回溯函数的结果将显示为数字。如果回溯函数为零,符号函数将永远不会被调用。上下文函数可能为零,在这种情况下,只有当上下文字段设置为零时,才会调用回溯函数。如果上下文函数为nil,那么从Go到C到Go的调用将不会显示调用栈中C部分的回溯。</target>
        </trans-unit>
        <trans-unit id="7f3f65f4777096791e56d64b25eeec76abb44bfa" translate="yes" xml:space="preserve">
          <source>The symbolizer function will be called with a single argument, a pointer to a struct:</source>
          <target state="translated">符号化函数将被调用,只有一个参数,即一个指向结构体的指针。</target>
        </trans-unit>
        <trans-unit id="826b161e82b6e953fc66964167887f9fb128e89d" translate="yes" xml:space="preserve">
          <source>The syntax of such definitions is to surround each template declaration with a &quot;define&quot; and &quot;end&quot; action.</source>
          <target state="translated">这种定义的语法是在每个模板声明的周围加上一个 &quot;定义 &quot;和 &quot;结束 &quot;的动作。</target>
        </trans-unit>
        <trans-unit id="a896d242a72cd56df044b310d3d7e48636436044" translate="yes" xml:space="preserve">
          <source>The syntax of the regular expressions accepted is the same general syntax used by Perl, Python, and other languages. More precisely, it is the syntax accepted by RE2 and described at &lt;a href=&quot;https://golang.org/s/re2syntax&quot;&gt;https://golang.org/s/re2syntax&lt;/a&gt;, except for \C. For an overview of the syntax, run</source>
          <target state="translated">接受的正则表达式的语法与Perl，Python和其他语言使用的常规语法相同。更准确地说，它是RE2接受的语法，并在&lt;a href=&quot;https://golang.org/s/re2syntax&quot;&gt;https://golang.org/s/re2syntax中进行了&lt;/a&gt;描述，除了\ C。有关语法的概述，请运行</target>
        </trans-unit>
        <trans-unit id="ba2393e2ef8002ea106da87efa718a59742fc7ac" translate="yes" xml:space="preserve">
          <source>The syslog package is frozen and is not accepting new features. Some external packages provide more functionality. See:</source>
          <target state="translated">syslog包被冻结,不接受新功能。一些外部软件包提供了更多的功能。请看:</target>
        </trans-unit>
        <trans-unit id="99e701177eab165c110f7e05395c5e3f3462fc8b" translate="yes" xml:space="preserve">
          <source>The table's lower portion shows specialized features of each format, such as supported string encodings, support for sub-second timestamps, or support for sparse files.</source>
          <target state="translated">该表的下半部分显示了每种格式的特殊功能,如支持的字符串编码、对亚秒级时间戳的支持或对稀疏文件的支持。</target>
        </trans-unit>
        <trans-unit id="e6cfcc2895da4e068fb4279dd7ba0aaf57b5ca4f" translate="yes" xml:space="preserve">
          <source>The table's upper portion shows the Header fields, where each format reports the maximum number of bytes allowed for each string field and the integer type used to store each numeric field (where timestamps are stored as the number of seconds since the Unix epoch).</source>
          <target state="translated">该表的上半部分显示了Header字段,其中每种格式都报告了每个字符串字段允许的最大字节数,以及用于存储每个数字字段的整数类型(其中时间戳被存储为Unix纪元以来的秒数)。</target>
        </trans-unit>
        <trans-unit id="b0a984b621ec68366c5b1261f609a8ab7bb45ea3" translate="yes" xml:space="preserve">
          <source>The tag must be one that takes string values: DT_NEEDED, DT_SONAME, DT_RPATH, or DT_RUNPATH.</source>
          <target state="translated">该标签必须是接受字符串值的标签。DT_NEEDED、DT_SONAME、DT_RPATH或DT_RUNPATH。</target>
        </trans-unit>
        <trans-unit id="cbe588a5ff1a44ccc9c3b05cfac0b378253441ae" translate="yes" xml:space="preserve">
          <source>The target is the RFC 7230 &quot;request-target&quot;: it may be either a path or an absolute URL. If target is an absolute URL, the host name from the URL is used. Otherwise, &quot;example.com&quot; is used.</source>
          <target state="translated">target是RFC 7230 &quot;request-target&quot;:它可以是一个路径,也可以是一个绝对URL。如果目标是绝对URL,则使用URL中的主机名。否则,使用 &quot;example.com&quot;。</target>
        </trans-unit>
        <trans-unit id="a6f845f916ddb97993362899697ada283b05c4e3" translate="yes" xml:space="preserve">
          <source>The taskType is used to classify task instances. Analysis tools like the Go execution tracer may assume there are only a bounded number of unique task types in the system.</source>
          <target state="translated">taskType用于对任务实例进行分类。像围棋执行跟踪器这样的分析工具可能会假设系统中只有一定数量的唯一任务类型。</target>
        </trans-unit>
        <trans-unit id="87c98cdec407269913a37379692f0119d00836f4" translate="yes" xml:space="preserve">
          <source>The template</source>
          <target state="translated">模板</target>
        </trans-unit>
        <trans-unit id="8dbf1659d9b474dfc6de39448622e749ace9eba6" translate="yes" xml:space="preserve">
          <source>The testing/quick package is frozen and is not accepting new features.</source>
          <target state="translated">测试/快速包被冻结,不接受新功能。</target>
        </trans-unit>
        <trans-unit id="450bac070fc3c1d570ed998a1290dd681976d259" translate="yes" xml:space="preserve">
          <source>The text returned from ReadLine does not include the line end (&quot;\r\n&quot; or &quot;\n&quot;). No indication or error is given if the input ends without a final line end. Calling UnreadByte after ReadLine will always unread the last byte read (possibly a character belonging to the line end) even if that byte is not part of the line returned by ReadLine.</source>
          <target state="translated">ReadLine返回的文本不包括行尾(&quot;\r\n &quot;或&quot;\n&quot;)。如果输入结束时没有最后的行结束符,则不会给出任何指示或错误。在ReadLine之后调用UnreadByte将总是取消读取最后一个字节(可能是属于行尾的字符),即使该字节不是ReadLine返回的行的一部分。</target>
        </trans-unit>
        <trans-unit id="e19ad8a62ebb2f930cd2d412533e63ab163f9e7f" translate="yes" xml:space="preserve">
          <source>The text/tabwriter package is frozen and is not accepting new features.</source>
          <target state="translated">text/tabwriter包被冻结,不接受新功能。</target>
        </trans-unit>
        <trans-unit id="b8b4c6c4010154e59471f9dc5acececde45e4c79" translate="yes" xml:space="preserve">
          <source>The time zone database needed by LoadLocation may not be present on all systems, especially non-Unix systems. LoadLocation looks in the directory or uncompressed zip file named by the ZONEINFO environment variable, if any, then looks in known installation locations on Unix systems, and finally looks in $GOROOT/lib/time/zoneinfo.zip.</source>
          <target state="translated">LoadLocation 所需的时区数据库可能并不是在所有系统上都存在,尤其是非 Unix 系统。LoadLocation会在ZONEINFO环境变量命名的目录或未压缩的zip文件中查找(如果有的话),然后在Unix系统中查找已知的安装位置,最后在$GOROOT/lib/time/zoneinfo.zip中查找。</target>
        </trans-unit>
        <trans-unit id="d9d95ea8fa35077316d58a8c096d78c878d9e8de" translate="yes" xml:space="preserve">
          <source>The timeout includes name resolution, if required. When using TCP, and the host in the address parameter resolves to multiple IP addresses, the timeout is spread over each consecutive dial, such that each is given an appropriate fraction of the time to connect.</source>
          <target state="translated">如果需要,超时时间包括名称解析。当使用TCP,并且地址参数中的主机解析到多个IP地址时,超时时间将分摊到每一个连续的拨号中,这样每个拨号都有适当的部分时间来连接。</target>
        </trans-unit>
        <trans-unit id="1be65b230e905dbffd21fbadb56320938e08062d" translate="yes" xml:space="preserve">
          <source>The tools that process the memory profiles assume that the profile rate is constant across the lifetime of the program and equal to the current value. Programs that change the memory profiling rate should do so just once, as early as possible in the execution of the program (for example, at the beginning of main).</source>
          <target state="translated">处理内存剖面的工具假设剖面率在程序的整个生命周期内是恒定的,并且等于当前的值。程序如果要改变内存剖面率,应该只改变一次,在程序执行的早期(例如,在main开始时)。</target>
        </trans-unit>
        <trans-unit id="1a177d1df849e44bddcb9ba4d4be3d9812f21f16" translate="yes" xml:space="preserve">
          <source>The trace tool computes the latency of a task by measuring the time between the task creation and the task end and provides latency distributions for each task type found in the trace.</source>
          <target state="translated">跟踪工具通过测量任务创建和任务结束之间的时间来计算任务的延迟,并为跟踪中发现的每种任务类型提供延迟分布。</target>
        </trans-unit>
        <trans-unit id="62d0bac03a171fb89c5dd19570b301f5442565f7" translate="yes" xml:space="preserve">
          <source>The traceback and context functions may be called from a signal handler, and must therefore use only async-signal safe functions. The symbolizer function may be called while the program is crashing, and so must be cautious about using memory. None of the functions may call back into Go.</source>
          <target state="translated">追溯函数和上下文函数可能会被信号处理程序调用,因此必须只使用异步信号安全函数。符号化函数可能在程序崩溃时被调用,因此必须谨慎使用内存。这些函数都不可以调用回Go。</target>
        </trans-unit>
        <trans-unit id="64b5d618701b94606e91495371f70fb5b100120e" translate="yes" xml:space="preserve">
          <source>The traceback function will be called with a single argument, a pointer to a struct:</source>
          <target state="translated">回溯函数将被调用,只有一个参数,即指向结构体的指针。</target>
        </trans-unit>
        <trans-unit id="fbcd1af40286bdefbe9605ee1269e5d70a141d29" translate="yes" xml:space="preserve">
          <source>The two methods Network and String conventionally return strings that can be passed as the arguments to Dial, but the exact form and meaning of the strings is up to the implementation.</source>
          <target state="translated">Network和String这两个方法约定俗成地返回可以作为参数传递给Dial的字符串,但字符串的具体形式和含义由实现者决定。</target>
        </trans-unit>
        <trans-unit id="ee1fff48d57b4264c60df5732fa6d287858ca513" translate="yes" xml:space="preserve">
          <source>The typ argument may be a defined (Named) type or an alias type. It may also be nil such that the returned TypeName can be used as argument for NewNamed, which will set the TypeName's type as a side- effect.</source>
          <target state="translated">typ参数可以是一个定义的(Named)类型或一个别名类型。它也可以是nil,这样返回的TypeName可以作为NewNamed的参数,NewNamed将设置TypeName的类型作为副作用。</target>
        </trans-unit>
        <trans-unit id="626d44cfd72353f5912709705dc90b7455988913" translate="yes" xml:space="preserve">
          <source>The type of the variable must be a string type, or a slice of a byte type, or FS (or an alias of FS).</source>
          <target state="translated">变量的类型必须是字符串类型,或字节类型的片断,或FS(或FS的别名)。</target>
        </trans-unit>
        <trans-unit id="761242af94989502320341408ab25169d28b2151" translate="yes" xml:space="preserve">
          <source>The typical use case for NewFileTransport is to register the &quot;file&quot; protocol with a Transport, as in:</source>
          <target state="translated">NewFileTransport的典型用例是将 &quot;文件 &quot;协议注册到一个Transport中,如。</target>
        </trans-unit>
        <trans-unit id="c9dec8fd9ff2613dd03956d5301652519fcaec0c" translate="yes" xml:space="preserve">
          <source>The underlying filesystem may truncate or round the values to a less precise time unit. If there is an error, it will be of type *PathError.</source>
          <target state="translated">底层文件系统可能会截断或四舍五入这些值,使其成为一个不太精确的时间单位。如果有错误,它的类型将是*PathError。</target>
        </trans-unit>
        <trans-unit id="bc08db1aae610f1545a452a1bb5a7582597ab3b7" translate="yes" xml:space="preserve">
          <source>The usage message will appear on a separate line for anything but a bool flag with a one-byte name. For bool flags, the type is omitted and if the flag name is one byte the usage message appears on the same line. The parenthetical default is omitted if the default is the zero value for the type. The listed type, here int, can be changed by placing a back-quoted name in the flag's usage string; the first such item in the message is taken to be a parameter name to show in the message and the back quotes are stripped from the message when displayed. For instance, given</source>
          <target state="translated">除了一个名字为一个字节的布尔标志外,其他任何标志的使用信息都会出现在单独的一行上,对于布尔标志,类型会被省略,如果标志的名字是一个字节,则使用信息会出现在同一行上。对于bool标志,类型会被省略,如果标志名是一个字节,使用信息会出现在同一行。如果默认是类型的零值,则省略括号中的默认值。列举的类型,这里是int,可以通过在标志的用法字符串中放置一个反引号的名称来改变,消息中的第一个这样的项目被当作参数名称显示在消息中,显示时,反引号会从消息中剥离。例如,给定</target>
        </trans-unit>
        <trans-unit id="7175f6a7da0429173b6be919d1c9513e0498e3e7" translate="yes" xml:space="preserve">
          <source>The value 0xff was chosen because it cannot appear in a valid UTF-8 sequence.</source>
          <target state="translated">选择0xff是因为它不能出现在有效的UTF-8序列中。</target>
        </trans-unit>
        <trans-unit id="e4328a7e24cd2970818970fe425c0b1b3c86f9d7" translate="yes" xml:space="preserve">
          <source>The variadic argument controls whether the function is variadic. FuncOf panics if the in[len(in)-1] does not represent a slice and variadic is true.</source>
          <target state="translated">variadic参数控制函数是否为变量。如果in[len(in)-1]不代表一个片,并且variadic为真,FuncOf会恐慌。</target>
        </trans-unit>
        <trans-unit id="1e72c26ccaadcb98e76249dcd1c8f3cdb175e9de" translate="yes" xml:space="preserve">
          <source>The varint functions encode and decode single integer values using a variable-length encoding; smaller values require fewer bytes. For a specification, see &lt;a href=&quot;https://developers.google.com/protocol-buffers/docs/encoding&quot;&gt;https://developers.google.com/protocol-buffers/docs/encoding&lt;/a&gt;.</source>
          <target state="translated">varint函数使用可变长度编码对单个整数值进行编码和解码；较小的值需要较少的字节。有关规范，请参见&lt;a href=&quot;https://developers.google.com/protocol-buffers/docs/encoding&quot;&gt;https://developers.google.com/protocol-buffers/docs/encoding&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5cdb175715a8f3e26508e589b1b8622549f73fd8" translate="yes" xml:space="preserve">
          <source>The verbs behave analogously to those of Printf. For example, %x will scan an integer as a hexadecimal number, and %v will scan the default representation format for the value. The Printf verbs %p and %T and the flags # and + are not implemented. For floating-point and complex values, all valid formatting verbs (%b %e %E %f %F %g %G %x %X and %v) are equivalent and accept both decimal and hexadecimal notation (for example: &quot;2.3e+7&quot;, &quot;0x4.5p-8&quot;) and digit-separating underscores (for example: &quot;3.14159_26535_89793&quot;).</source>
          <target state="translated">这些动词的行为类似于Printf的行为。例如,%x将扫描一个整数作为十六进制数,而%v将扫描该值的默认表示格式。Printf动词%p和%T以及标志#和+没有实现。对于浮点和复数,所有有效的格式动词(%b %e %E %f %F %g %G %x %X和%v)都是等价的,并且接受十进制和十六进制符号(例如:&quot;2.3e+7&quot;,&quot;0x4.5p-8&quot;)和数字分隔的下划线(例如:&quot;3.14159_26535_89793&quot;)。</target>
        </trans-unit>
        <trans-unit id="a6ebe1343c13ca95e202e147b7f816ef1bc435a4" translate="yes" xml:space="preserve">
          <source>The verbs:</source>
          <target state="translated">的动词。</target>
        </trans-unit>
        <trans-unit id="3ce9ac6782ffe3c2b00e6a4b78b2ec7b810f1491" translate="yes" xml:space="preserve">
          <source>The writes of individual records are buffered. After all data has been written, the client should call the Flush method to guarantee all data has been forwarded to the underlying io.Writer. Any errors that occurred should be checked by calling the Error method.</source>
          <target state="translated">单个记录的写入是有缓冲的。在所有数据被写入后,客户端应该调用Flush方法,以保证所有数据都被转发到底层的io.Writer。发生的任何错误都应该通过调用Error方法进行检查。</target>
        </trans-unit>
        <trans-unit id="c7efdce3a929526f7cd0a0a9c837645401afe311" translate="yes" xml:space="preserve">
          <source>The zero (uninitialized) value for a Float is ready to use and represents the number +0.0 exactly, with precision 0 and rounding mode ToNearestEven.</source>
          <target state="translated">Float的零值(未初始化)可以使用了,准确表示数字+0.0,精度为0,取整模式为ToNearestEven。</target>
        </trans-unit>
        <trans-unit id="0956e2f948a72c4e4d0d06cd6f921545906690fb" translate="yes" xml:space="preserve">
          <source>The zero Hash is a valid Hash ready to use. A zero Hash chooses a random seed for itself during the first call to a Reset, Write, Seed, Sum64, or Seed method. For control over the seed, use SetSeed.</source>
          <target state="translated">零哈希是一个准备使用的有效哈希。在第一次调用Reset、Write、Seed、Sum64或Seed方法时,零散列会为自己选择一个随机种子。要控制种子,请使用SetSeed。</target>
        </trans-unit>
        <trans-unit id="232f8c7f5eea097cc9451d2d90b51db6b069254d" translate="yes" xml:space="preserve">
          <source>The zero Map is empty and ready for use. A Map must not be copied after first use.</source>
          <target state="translated">零地图是空的,可以使用。一个地图在第一次使用后不得复制。</target>
        </trans-unit>
        <trans-unit id="ba5155e1e3916eee99a712d5244dcde8e9982094" translate="yes" xml:space="preserve">
          <source>The zero Value represents no value. Its IsValid method returns false, its Kind method returns Invalid, its String method returns &quot;&amp;lt;invalid Value&amp;gt;&quot;, and all other methods panic. Most functions and methods never return an invalid value. If one does, its documentation states the conditions explicitly.</source>
          <target state="translated">零值表示无值。它的IsValid方法返回false，其Kind方法返回Invalid，其String方法返回&amp;ldquo; &amp;lt;invalid Value&amp;gt;&amp;rdquo;，所有其他方法都出现紧急情况。大多数函数和方法从不返回无效值。如果是这样，则其文档会明确说明条件。</target>
        </trans-unit>
        <trans-unit id="384c750c13afaffcbd5ebf58e8afec2b8768e946" translate="yes" xml:space="preserve">
          <source>The zero value for Pos is NoPos; there is no file and line information associated with it, and NoPos.IsValid() is false. NoPos is always smaller than any other Pos value. The corresponding Position value for NoPos is the zero value for Position.</source>
          <target state="translated">Pos的零值是NoPos;没有与之相关的文件和行信息,NoPos.IsValid()是false。NoPos总是小于其他任何Pos值。NoPos对应的Position值就是Position的零值。</target>
        </trans-unit>
        <trans-unit id="3f5973e68195ed6a7dd12c4c7dc485f8bde0523d" translate="yes" xml:space="preserve">
          <source>The zero value for an Int, Rat, or Float correspond to 0. Thus, new values can be declared in the usual ways and denote 0 without further initialization:</source>
          <target state="translated">Int、Rat或Float的零值对应于0,因此,新的值可以用通常的方式声明,并表示0,而无需进一步初始化。</target>
        </trans-unit>
        <trans-unit id="5d5aa4f538fd1571e15874ad0969ae7c0fda3040" translate="yes" xml:space="preserve">
          <source>The zero value for each field is equivalent to dialing without that option. Dialing with the zero value of Dialer is therefore equivalent to just calling the Dial function.</source>
          <target state="translated">每个字段的零值相当于没有该选项的拨号。因此,用Dialer的零值拨号相当于只调用Dial函数。</target>
        </trans-unit>
        <trans-unit id="beb5a289f20083f1018df67115c647d61b968230" translate="yes" xml:space="preserve">
          <source>The zero value of type Time is January 1, year 1, 00:00:00.000000000 UTC. As this time is unlikely to come up in practice, the IsZero method gives a simple way of detecting a time that has not been initialized explicitly.</source>
          <target state="translated">Time类型的零值是1年1月1日,00:00:00.000000000 UTC。由于这个时间在实际中不太可能出现,IsZero方法给出了一个简单的方法来检测没有被显式初始化的时间。</target>
        </trans-unit>
        <trans-unit id="4752552a303f0f1e8a6bd4b3555705dcb31c63a8" translate="yes" xml:space="preserve">
          <source>Then it can make a remote call:</source>
          <target state="translated">然后就可以进行远程通话了。</target>
        </trans-unit>
        <trans-unit id="c5d500f53dcbe43654b22f15924d609c47bcfc3c" translate="yes" xml:space="preserve">
          <source>Then use the pprof tool to look at the heap profile:</source>
          <target state="translated">然后使用pprof工具查看堆配置文件。</target>
        </trans-unit>
        <trans-unit id="d249cadab1a19289ed9fd8f524a7048ff9efb13f" translate="yes" xml:space="preserve">
          <source>There are 16 methods of Regexp that match a regular expression and identify the matched text. Their names are matched by this regular expression:</source>
          <target state="translated">Regexp有16种方法可以匹配正则表达式并识别匹配的文本。它们的名称与这个正则表达式相匹配。</target>
        </trans-unit>
        <trans-unit id="089af1af9f031a6d4cb36f253f88e22a554b4d75" translate="yes" xml:space="preserve">
          <source>There are many commands available from the pprof command line. Commonly used commands include &quot;top&quot;, which prints a summary of the top program hot-spots, and &quot;web&quot;, which opens an interactive graph of hot-spots and their call graphs. Use &quot;help&quot; for information on all pprof commands.</source>
          <target state="translated">在pprof命令行中有很多命令可以使用,常用的命令有 &quot;top&quot;,它可以打印出最热门的程序热点汇总,&quot;web &quot;可以打开热点及其调用图的交互图。常用的命令包括 &quot;top&quot;,它可以打印顶级程序热点的摘要,以及 &quot;web&quot;,它可以打开热点的交互式图表和它们的调用图表。使用 &quot;help &quot;可以获得所有pprof命令的信息。</target>
        </trans-unit>
        <trans-unit id="6fa5b171535b7941feffabcf1c5f915fe3f02940" translate="yes" xml:space="preserve">
          <source>There are no build tags for beta or minor releases.</source>
          <target state="translated">测试版或次要版本没有构建标签。</target>
        </trans-unit>
        <trans-unit id="f4ebe0322e94e23eec9f295ca340080dec64dffd" translate="yes" xml:space="preserve">
          <source>There are three types of user annotations: log messages, regions, and tasks.</source>
          <target state="translated">用户注释有三种类型:日志消息、区域和任务。</target>
        </trans-unit>
        <trans-unit id="311b843be371a8c7fc9f6f81df2189e5f92e44e5" translate="yes" xml:space="preserve">
          <source>There is also a set of binary comparison operators defined as functions:</source>
          <target state="translated">还有一组定义为函数的二进制比较运算符。</target>
        </trans-unit>
        <trans-unit id="5f5077a9bb275171893d0be52e74cbffe4b19888" translate="yes" xml:space="preserve">
          <source>There is also a standard HTTP interface to profiling data. Adding the following line will install handlers under the /debug/pprof/ URL to download live profiles:</source>
          <target state="translated">还有一个标准的HTTP接口来剖析数据。添加以下一行将在/debug/pprof/URL下安装处理程序来下载实时配置文件。</target>
        </trans-unit>
        <trans-unit id="f5962f465f0b5c003c4585058fcce10ec6a63c36" translate="yes" xml:space="preserve">
          <source>There is also a standard HTTP interface to trace data. Adding the following line will install a handler under the /debug/pprof/trace URL to download a live trace:</source>
          <target state="translated">还有一个标准的HTTP接口来跟踪数据。添加以下一行将在/debug/pprof/trace URL下安装一个处理程序来下载实时跟踪数据。</target>
        </trans-unit>
        <trans-unit id="669c09ef6ba443f4e07a76e5e520b09339b0d7ba" translate="yes" xml:space="preserve">
          <source>There is also a subset of the methods that can be applied to text read from a RuneReader:</source>
          <target state="translated">还有一个方法的子集,可以应用于从RuneReader读取的文本。</target>
        </trans-unit>
        <trans-unit id="e5e187581cfc7675624afa1252d945d3159b9872" translate="yes" xml:space="preserve">
          <source>There is no mechanism for full case folding, that is, for characters that involve multiple runes in the input or output.</source>
          <target state="translated">对于输入或输出中涉及多个符文的字符,没有全宗折叠的机制。</target>
        </trans-unit>
        <trans-unit id="4e416754d4e74f38af1b48194c67cf3710f22527" translate="yes" xml:space="preserve">
          <source>These are predefined layouts for use in Time.Format and time.Parse. The reference time used in the layouts is the specific time:</source>
          <target state="translated">这些是预定义的布局,用于Time.Format和time.Parse。布局中使用的参考时间是具体时间。</target>
        </trans-unit>
        <trans-unit id="622b937b45492ef40cc6c554bb302fd36d24a9dd" translate="yes" xml:space="preserve">
          <source>These are the errors that can be returned in ParseError.Err.</source>
          <target state="translated">这些是可以在ParseError.Err中返回的错误。</target>
        </trans-unit>
        <trans-unit id="df2271a2f22e4450d78c23577801038a703976de" translate="yes" xml:space="preserve">
          <source>These assume decimal and the Go int type.</source>
          <target state="translated">这些假设是十进制和Go int类型。</target>
        </trans-unit>
        <trans-unit id="e44cf0ddaa746164e3256589314495380a8d22a3" translate="yes" xml:space="preserve">
          <source>These constants are copied from the flate package, so that code that imports &quot;compress/gzip&quot; does not also have to import &quot;compress/flate&quot;.</source>
          <target state="translated">这些常量是从 flate 包中复制过来的,所以导入 &quot;compress/gzip&quot; 的代码不必同时导入 &quot;compress/flate&quot;。</target>
        </trans-unit>
        <trans-unit id="9b53ffb7fd51347180d120a25b5986ecdfdf8a40" translate="yes" xml:space="preserve">
          <source>These constants are copied from the flate package, so that code that imports &quot;compress/zlib&quot; does not also have to import &quot;compress/flate&quot;.</source>
          <target state="translated">这些常量是从flate包中复制过来的,所以导入 &quot;compress/zlib &quot;的代码不必同时导入 &quot;compress/flate&quot;。</target>
        </trans-unit>
        <trans-unit id="a6caaf07cd62c3bce0c1d44802c32e939959f7c6" translate="yes" xml:space="preserve">
          <source>These constants cause FlagSet.Parse to behave as described if the parse fails.</source>
          <target state="translated">这些常量导致FlagSet.Parse在解析失败时的行为与描述的一样。</target>
        </trans-unit>
        <trans-unit id="c3e135e518f3071cd6e6de5ee8eb8509897ca8e4" translate="yes" xml:space="preserve">
          <source>These constants define supported rounding modes.</source>
          <target state="translated">这些常数定义了支持的四舍五入模式。</target>
        </trans-unit>
        <trans-unit id="e9b81d06567b4f6ea4a134b77b7d8d68b11092d0" translate="yes" xml:space="preserve">
          <source>These examples demonstrate the basics of printing using a format string. Printf, Sprintf, and Fprintf all take a format string that specifies how to format the subsequent arguments. For example, %d (we call that a 'verb') says to print the corresponding argument, which must be an integer (or something containing an integer, such as a slice of ints) in decimal. The verb %v ('v' for 'value') always formats the argument in its default form, just how Print or Println would show it. The special verb %T ('T' for 'Type') prints the type of the argument rather than its value. The examples are not exhaustive; see the package comment for all the details.</source>
          <target state="translated">这些例子演示了使用格式字符串进行打印的基础知识。Printf、Sprintf和Fprintf都取一个格式字符串,指定如何格式化后面的参数。例如,%d(我们称之为 &quot;动词&quot;)说要打印相应的参数,它必须是一个整数(或包含一个整数的东西,如ints的一个片断),用十进制表示。动词%v('v'表示'value')总是以默认的形式格式化参数,就像Print或Println会显示的那样。特殊的动词%T('T'代表'Type')打印参数的类型,而不是它的值。这些例子并不详尽,所有细节请参见软件包注释。</target>
        </trans-unit>
        <trans-unit id="1b31c3c54ac0eb3ff04d00595a12fb566e8fcf7e" translate="yes" xml:space="preserve">
          <source>These flags define which text to prefix to each log entry generated by the Logger. Bits are or'ed together to control what's printed. There is no control over the order they appear (the order listed here) or the format they present (as described in the comments). The prefix is followed by a colon only when Llongfile or Lshortfile is specified. For example, flags Ldate | Ltime (or LstdFlags) produce,</source>
          <target state="translated">这些标志定义了记录仪生成的每个日志条目的前缀文本。位是或'ed一起控制打印的内容。无法控制它们出现的顺序(这里列出的顺序)或它们呈现的格式(如注释中所述)。只有当指定了Llongfile或Lshortfile时,前缀后面才会有一个冒号。例如,标志Ldate | Ltime(或LstdFlags)会产生。</target>
        </trans-unit>
        <trans-unit id="eab8374633319fa49ea516b7b757172cc6a3ee35" translate="yes" xml:space="preserve">
          <source>These flags define which text to prefix to each log entry generated by the Logger. Bits are or'ed together to control what's printed. With the exception of the Lmsgprefix flag, there is no control over the order they appear (the order listed here) or the format they present (as described in the comments). The prefix is followed by a colon only when Llongfile or Lshortfile is specified. For example, flags Ldate | Ltime (or LstdFlags) produce,</source>
          <target state="translated">这些标志定义了记录仪生成的每个日志条目的前缀文本。字符串在一起以控制打印的内容。除了 Lmsgprefix 标志外,无法控制它们出现的顺序(这里列出的顺序)或它们呈现的格式(如注释中所述)。只有当指定了Llongfile或Lshortfile时,前缀后面才会有一个冒号。例如,标志Ldate | Ltime(或LstdFlags)会产生。</target>
        </trans-unit>
        <trans-unit id="fc9914d5780e96c178ba8969a057705144577da8" translate="yes" xml:space="preserve">
          <source>These functions are also compatible with the &amp;ldquo;Ed25519&amp;rdquo; function defined in RFC 8032. However, unlike RFC 8032's formulation, this package's private key representation includes a public key suffix to make multiple signing operations with the same key more efficient. This package refers to the RFC 8032 private key as the &amp;ldquo;seed&amp;rdquo;.</source>
          <target state="translated">这些功能还与RFC 8032中定义的&amp;ldquo; Ed25519&amp;rdquo;功能兼容。但是，与RFC 8032的表述不同，此程序包的私钥表示形式包含一个公钥后缀，以使使用同一密钥的多个签名操作更加有效。该软件包将RFC 8032私钥称为&amp;ldquo;种子&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="2034a99a91b57c3247261a1a8004621e6e0c4e1f" translate="yes" xml:space="preserve">
          <source>These functions require great care to be used correctly. Except for special, low-level applications, synchronization is better done with channels or the facilities of the sync package. Share memory by communicating; don't communicate by sharing memory.</source>
          <target state="translated">这些功能需要非常小心才能正确使用。除了特殊的低级应用外,同步最好用通道或同步包的设施来完成。通过通信来共享内存,不要通过共享内存来通信。</target>
        </trans-unit>
        <trans-unit id="54aa9a67852a83f3350017dd1b9500c555360772" translate="yes" xml:space="preserve">
          <source>These packages are part of the Go Project but outside the main Go tree. They are developed under looser &lt;a href=&quot;https://golang.org/doc/go1compat&quot;&gt;compatibility requirements&lt;/a&gt; than the Go core. Install them with &quot;&lt;a href=&quot;https://golang.org/cmd/go/#hdr-Download_and_install_packages_and_dependencies&quot;&gt;go get&lt;/a&gt;&quot;.</source>
          <target state="translated">这些软件包是Go项目的一部分，但在主Go树之外。它们是在比Go内核更&lt;a href=&quot;https://golang.org/doc/go1compat&quot;&gt;严格&lt;/a&gt;的兼容性要求下开发的。用&amp;ldquo; &lt;a href=&quot;https://golang.org/cmd/go/#hdr-Download_and_install_packages_and_dependencies&quot;&gt;go get&lt;/a&gt; &amp;rdquo; 安装它们。</target>
        </trans-unit>
        <trans-unit id="07168c583c59c9cae9d4bb3facc94a52fb2a21e9" translate="yes" xml:space="preserve">
          <source>These predefined profiles maintain themselves and panic on an explicit Add or Remove method call.</source>
          <target state="translated">这些预定义的配置文件会自我维护,并在明确的添加或删除方法调用时发生恐慌。</target>
        </trans-unit>
        <trans-unit id="8dc4875980e26530686b9e8a46a4183aeaf7943d" translate="yes" xml:space="preserve">
          <source>These services can help you find Open Source packages provided by the community.</source>
          <target state="translated">这些服务可以帮助你找到社区提供的开源包。</target>
        </trans-unit>
        <trans-unit id="6ba17173fd7e73d9151d0d7cdef890f5dd3a0a3f" translate="yes" xml:space="preserve">
          <source>These three formatting routines call the Qualifier for each package-level object O, and if the Qualifier returns a non-empty string p, the object is printed in the form p.O. If it returns an empty string, only the object name O is printed.</source>
          <target state="translated">这三个格式化例程对每个包级对象O调用限定符,如果限定符返回非空字符串p,则以p.O的形式打印对象,如果返回空字符串,则只打印对象名称O。</target>
        </trans-unit>
        <trans-unit id="2207cae6c61d669eed106af825a6dce66aef87d1" translate="yes" xml:space="preserve">
          <source>These variables have type *RangeTable.</source>
          <target state="translated">这些变量的类型为*RangeTable。</target>
        </trans-unit>
        <trans-unit id="610a8603a5a8aeac74a533f57b0c5eb7122b7d43" translate="yes" xml:space="preserve">
          <source>This cannot be done concurrent to other receives from the Timer's channel or other calls to the Timer's Stop method.</source>
          <target state="translated">这不能与定时器通道的其他接收或定时器停止方法的其他调用同时进行。</target>
        </trans-unit>
        <trans-unit id="1166cbd43d7ca0f544abde3cc256ae8afc9cd0b1" translate="yes" xml:space="preserve">
          <source>This cannot be done concurrent to other receives from the Timer's channel.</source>
          <target state="translated">这不能与定时器通道的其他接收同时进行。</target>
        </trans-unit>
        <trans-unit id="b00ff4b1fd4c120a5db60ce99d175dd291630987" translate="yes" xml:space="preserve">
          <source>This declares an integer flag, -flagname, stored in the pointer ip, with type *int.</source>
          <target state="translated">这声明了一个整数标志,-flagname,存储在指针ip中,类型为*int。</target>
        </trans-unit>
        <trans-unit id="f1681bf43fc257c44b551cfb0077dc2be75b4283" translate="yes" xml:space="preserve">
          <source>This declares an integer flag, -n, stored in the pointer nFlag, with type *int:</source>
          <target state="translated">这声明了一个整数标志,-n,存储在指针nFlag中,类型为*int。</target>
        </trans-unit>
        <trans-unit id="631f1841cf17bb7db8a22b0767e5099ebe5b8b09" translate="yes" xml:space="preserve">
          <source>This defines two templates, T1 and T2, and a third T3 that invokes the other two when it is executed. Finally it invokes T3. If executed this template will produce the text</source>
          <target state="translated">这就定义了两个模板,T1和T2,还有第三个T3,当它被执行时,会调用其他两个模板。最后它调用T3。如果执行这个模板,将产生文本</target>
        </trans-unit>
        <trans-unit id="07be652fe77b2bc1e633b76695cc662deba999dd" translate="yes" xml:space="preserve">
          <source>This example creates a PriorityQueue with some items, adds and manipulates an item, and then removes the items in priority order.</source>
          <target state="translated">这个例子用一些项目创建了一个PriorityQueue,添加并操作一个项目,然后按照优先级顺序删除项目。</target>
        </trans-unit>
        <trans-unit id="11e8e47e8373159f24438e9584e5f85d6b5441f2" translate="yes" xml:space="preserve">
          <source>This example demonstrates a custom function to process template text. It installs the strings.Title function and uses it to Make Title Text Look Good In Our Template's Output.</source>
          <target state="translated">这个例子演示了一个自定义函数来处理模板文本。它安装了strings.Title函数,并使用它来使标题文本在我们的模板输出中看起来不错。</target>
        </trans-unit>
        <trans-unit id="dfa54d108334a66ba7ab5757d71b4364db5ae271" translate="yes" xml:space="preserve">
          <source>This example demonstrates how a value can be passed to the context and also how to retrieve it if it exists.</source>
          <target state="translated">这个例子演示了如何将一个值传递给上下文,以及如何在它存在时检索它。</target>
        </trans-unit>
        <trans-unit id="cbed8edb3aa3c802bdc2c523c3a0a851457324e3" translate="yes" xml:space="preserve">
          <source>This example demonstrates how to inspect the AST of a Go program.</source>
          <target state="translated">这个例子演示了如何检查一个Go程序的AST。</target>
        </trans-unit>
        <trans-unit id="165d3019bf668cef6d1995c8165503ac097763bd" translate="yes" xml:space="preserve">
          <source>This example demonstrates how to use big.Int to compute the smallest Fibonacci number with 100 decimal digits and to test whether it is prime.</source>
          <target state="translated">这个例子演示了如何使用big.Int来计算100位小数的最小斐波那契数,并测试它是否是质数。</target>
        </trans-unit>
        <trans-unit id="0059484fefd6cd0e894a9be3837a0c3c538eda17" translate="yes" xml:space="preserve">
          <source>This example demonstrates how to use big.Rat to compute the first 15 terms in the sequence of rational convergents for the constant e (base of natural logarithm).</source>
          <target state="translated">这个例子演示了如何使用big.Rat计算常数e(自然对数的基数)的有理收敛序列的前15项。</target>
        </trans-unit>
        <trans-unit id="b29080504869eb07c938bd169b02dbf661e6a627" translate="yes" xml:space="preserve">
          <source>This example demonstrates how to use one group of driver templates with distinct sets of helper templates.</source>
          <target state="translated">这个例子演示了如何使用一组驱动模板与不同的辅助模板集。</target>
        </trans-unit>
        <trans-unit id="ba0650f40679135f634bca363681740adeafe34a" translate="yes" xml:space="preserve">
          <source>This example demonstrates one way to share some templates and use them in different contexts. In this variant we add multiple driver templates by hand to an existing bundle of templates.</source>
          <target state="translated">这个例子演示了一种共享一些模板并在不同环境下使用它们的方法。在这个变体中,我们通过手工将多个驱动程序模板添加到现有的模板捆绑中。</target>
        </trans-unit>
        <trans-unit id="0ba078883e861f3b147ecf053f6c06d8a3174cd3" translate="yes" xml:space="preserve">
          <source>This example demonstrates searching a list sorted in ascending order.</source>
          <target state="translated">这个例子演示了如何搜索一个按升序排列的列表。</target>
        </trans-unit>
        <trans-unit id="7888c65ff5bdcbe2c823d7d7283ee2975bf6366b" translate="yes" xml:space="preserve">
          <source>This example demonstrates searching a list sorted in descending order. The approach is the same as searching a list in ascending order, but with the condition inverted.</source>
          <target state="translated">这个例子演示了如何搜索一个按降序排序的列表。其方法与按升序搜索列表相同,但条件倒置。</target>
        </trans-unit>
        <trans-unit id="2db6a343e7f8129baf91fac5d3ebedf3e8666279" translate="yes" xml:space="preserve">
          <source>This example demonstrates the use of a cancelable context to prevent a goroutine leak. By the end of the example function, the goroutine started by gen will return without leaking.</source>
          <target state="translated">这个例子演示了使用可取消上下文来防止goroutine泄漏。在本例函数结束时,由gen启动的goroutine将无泄漏地返回。</target>
        </trans-unit>
        <trans-unit id="f5ede30ffc3c68340a6fb2445f68975fd1d677b3" translate="yes" xml:space="preserve">
          <source>This example demonstrates unmarshaling an XML excerpt into a value with some preset fields. Note that the Phone field isn't modified and that the XML &amp;lt;Company&amp;gt; element is ignored. Also, the Groups field is assigned considering the element path provided in its tag.</source>
          <target state="translated">此示例演示了如何将XML摘录编组为具有某些预设字段的值。请注意，&amp;ldquo;电话&amp;rdquo;字段未修改，并且XML &amp;lt;Company&amp;gt;元素被忽略。同样，考虑到其标签中提供的元素路径来分配&amp;ldquo;组&amp;rdquo;字段。</target>
        </trans-unit>
        <trans-unit id="363362d5c2e9f91c6b9857ffd69fe714bafa9ced" translate="yes" xml:space="preserve">
          <source>This example fetches several URLs concurrently, using a WaitGroup to block until all the fetches are complete.</source>
          <target state="translated">这个例子同时获取多个URL,使用WaitGroup阻塞,直到所有的获取完成。</target>
        </trans-unit>
        <trans-unit id="06701ebad78061b44ebf3ff359db4a889929ed4c" translate="yes" xml:space="preserve">
          <source>This example illustrates how to remove a variable declaration in a Go program while maintaining correct comment association using an ast.CommentMap.</source>
          <target state="translated">这个例子说明了如何使用 ast.CommentMap 来删除 Go 程序中的变量声明,同时保持正确的注释关联。</target>
        </trans-unit>
        <trans-unit id="5b8dbce47ef4472e55b03e0ab77f57e1bbd03498" translate="yes" xml:space="preserve">
          <source>This example illustrates how to use NewFromFiles to compute package documentation with examples.</source>
          <target state="translated">这个例子说明了如何使用NewFromFiles来计算包文档与实例。</target>
        </trans-unit>
        <trans-unit id="a88fa5b5d7ed0c65b753c3fe2d8b6cdc87e0d250" translate="yes" xml:space="preserve">
          <source>This example inserts several ints into an IntHeap, checks the minimum, and removes them in order of priority.</source>
          <target state="translated">这个例子将几个ints插入到IntHeap中,检查最小值,并按优先级顺序删除它们。</target>
        </trans-unit>
        <trans-unit id="6720a93331216084a88085596ce48ea8bc49ea13" translate="yes" xml:space="preserve">
          <source>This example passes a context with a signal to tell a blocking function that it should abandon its work after a signal is received.</source>
          <target state="translated">这个例子通过一个带有信号的上下文来告诉阻塞函数,它应该在收到信号后放弃工作。</target>
        </trans-unit>
        <trans-unit id="e36be68d73234a9e2fb853054688b98fefd0444d" translate="yes" xml:space="preserve">
          <source>This example passes a context with a timeout to tell a blocking function that it should abandon its work after the timeout elapses.</source>
          <target state="translated">这个例子通过一个带有超时的上下文来告诉阻塞函数在超时后应该放弃它的工作。</target>
        </trans-unit>
        <trans-unit id="eac2b4a123d3756695f2f19424362998d49962a1" translate="yes" xml:space="preserve">
          <source>This example passes a context with an arbitrary deadline to tell a blocking function that it should abandon its work as soon as it gets to it.</source>
          <target state="translated">这个例子通过一个带有任意deadline的上下文来告诉阻塞函数,它应该在到达阻塞函数后立即放弃它的工作。</target>
        </trans-unit>
        <trans-unit id="df7ace59807aa52b6b44602449d158b9635a420e" translate="yes" xml:space="preserve">
          <source>This example reads 10 cryptographically secure pseudorandom numbers from rand.Reader and writes them to a byte slice.</source>
          <target state="translated">这个例子从rand.Reader中读取10个加密安全的伪随机数,并将它们写入一个字节片断。</target>
        </trans-unit>
        <trans-unit id="d0f63cae6959df0e63ff45ed07152e8d354e9432" translate="yes" xml:space="preserve">
          <source>This example shows how csv.Reader can be configured to handle other types of CSV files.</source>
          <target state="translated">这个例子展示了如何配置csv.Reader来处理其他类型的CSV文件。</target>
        </trans-unit>
        <trans-unit id="1cca172f7759e3ba0050255d1746af87f660b76a" translate="yes" xml:space="preserve">
          <source>This example shows how to encode an interface value. The key distinction from regular types is to register the concrete type that implements the interface.</source>
          <target state="translated">这个例子展示了如何对一个接口值进行编码。与常规类型的关键区别在于注册实现接口的具体类型。</target>
        </trans-unit>
        <trans-unit id="a3357a230dfc48b693b3b94d9c6611698fcf1171" translate="yes" xml:space="preserve">
          <source>This example shows how to use big.Float to compute the square root of 2 with a precision of 200 bits, and how to print the result as a decimal number.</source>
          <target state="translated">这个例子展示了如何使用big.Float计算精度为200位的2的平方根,以及如何将结果打印为十进制数。</target>
        </trans-unit>
        <trans-unit id="efe429413e771069e2a76db974f921ef42dbdd60" translate="yes" xml:space="preserve">
          <source>This example shows the basic usage of the package: Create an encoder, transmit some values, receive them with a decoder.</source>
          <target state="translated">这个例子展示了这个包的基本用法。创建一个编码器,传输一些值,用解码器接收它们。</target>
        </trans-unit>
        <trans-unit id="4e20892924831ca17c2f745e5365e20b64d74b0e" translate="yes" xml:space="preserve">
          <source>This example shows the use of each of the methods on a *Rand. The use of the global functions is the same, without the receiver.</source>
          <target state="translated">这个例子显示了每个方法在*Rand上的使用。全局函数的使用是一样的,没有接收器。</target>
        </trans-unit>
        <trans-unit id="9dae51dea551843f94a869c5f0aec8bf68e765cc" translate="yes" xml:space="preserve">
          <source>This example shows what an AST looks like when printed for debugging.</source>
          <target state="translated">这个例子显示了AST在打印调试时的样子。</target>
        </trans-unit>
        <trans-unit id="3d4d87b6b74c64cd8a077a3429d1b650786c492b" translate="yes" xml:space="preserve">
          <source>This example transmits a value that implements the custom encoding and decoding methods.</source>
          <target state="translated">这个例子传送了一个实现自定义编码和解码方法的值。</target>
        </trans-unit>
        <trans-unit id="5ad4aea6278dc849132cadb70003c4716078bb1f" translate="yes" xml:space="preserve">
          <source>This example uses RawMessage to delay parsing part of a JSON message.</source>
          <target state="translated">这个例子使用RawMessage来延迟解析JSON消息的一部分。</target>
        </trans-unit>
        <trans-unit id="f3c7cd2790bc702e1c4e8248c880538aa9480232" translate="yes" xml:space="preserve">
          <source>This example uses RawMessage to use a precomputed JSON during marshal.</source>
          <target state="translated">这个例子在marshal过程中使用RawMessage来使用预计算的JSON。</target>
        </trans-unit>
        <trans-unit id="0980067335654187fe3f7c133925d1affa51d747" translate="yes" xml:space="preserve">
          <source>This example uses a Decoder to decode a stream of distinct JSON values.</source>
          <target state="translated">这个例子使用解码器来解码不同的JSON值流。</target>
        </trans-unit>
        <trans-unit id="03fbac2b83cd3991555ff62920bdc91549cc27eb" translate="yes" xml:space="preserve">
          <source>This example uses a Decoder to decode a streaming array of JSON objects.</source>
          <target state="translated">这个例子使用解码器来解码JSON对象的流式数组。</target>
        </trans-unit>
        <trans-unit id="f5365f6fa06883e90b95f7b5b17bc92e07aa1a04" translate="yes" xml:space="preserve">
          <source>This function is deterministic. Thus, if the set of possible messages is small, an attacker may be able to build a map from messages to signatures and identify the signed messages. As ever, signatures provide authenticity, not confidentiality.</source>
          <target state="translated">这个函数是确定性的。因此,如果可能的消息集很小,攻击者可能能够从消息到签名建立一个映射,并识别签名的消息。与以往一样,签名提供的是真实性,而不是保密性。</target>
        </trans-unit>
        <trans-unit id="fd018c9debfe4b296d2cfc4264240cd8fd943b8a" translate="yes" xml:space="preserve">
          <source>This function predates errors.Is, and the notion of whether an error indicates a timeout can be ambiguous. For example, the Unix error EWOULDBLOCK sometimes indicates a timeout and sometimes does not. New code should use errors.Is with a value appropriate to the call returning the error, such as os.ErrDeadlineExceeded.</source>
          <target state="translated">这个函数比 errors.Is 更早,而且错误是否表示超时的概念可能是模糊的。例如,Unix 错误 EWOULDBLOCK 有时表示超时,有时不表示。新的代码应该使用 errors.Is,其值应该适合于返回错误的调用,例如 os.ErrDeadlineExceeded。</target>
        </trans-unit>
        <trans-unit id="0b76ff62ea1ae6e83678ff4ff974ab310fb4c608" translate="yes" xml:space="preserve">
          <source>This function predates errors.Is. It only supports errors returned by the os package. New code should use errors.Is(err, os.ErrExist).</source>
          <target state="translated">这个函数早于 errors.Is.,它只支持 os 包返回的错误。它只支持os包返回的错误。新代码应该使用 errors.Is(err,os.ErrExist)。</target>
        </trans-unit>
        <trans-unit id="6ac909599248ff292672881014f89872aa8e2750" translate="yes" xml:space="preserve">
          <source>This function predates errors.Is. It only supports errors returned by the os package. New code should use errors.Is(err, os.ErrNotExist).</source>
          <target state="translated">这个函数早于 errors.Is.,它只支持 os 包返回的错误。它只支持os包返回的错误。新代码应该使用 errors.Is(err,os.ErrNotExist)。</target>
        </trans-unit>
        <trans-unit id="4065f7f0b0bbe706f58a16388dc6fed510ded429" translate="yes" xml:space="preserve">
          <source>This function predates errors.Is. It only supports errors returned by the os package. New code should use errors.Is(err, os.ErrPermission).</source>
          <target state="translated">这个函数早于 errors.Is.,它只支持 os 包返回的错误。它只支持os包返回的错误。新代码应该使用 errors.Is(err,os.ErrPermission)。</target>
        </trans-unit>
        <trans-unit id="2d0f1a75b2c9ccfa817de559e09c94b8dbca3151" translate="yes" xml:space="preserve">
          <source>This function will call x509.ParseCertificate unless c.Leaf is set, which can incur a significant performance cost.</source>
          <target state="translated">除非设置了c.Leaf,否则该函数将调用x509.ParseCertificate,这可能会产生巨大的性能成本。</target>
        </trans-unit>
        <trans-unit id="21dc4eae53c9012a7d2a049dd7f00db6a6938f5b" translate="yes" xml:space="preserve">
          <source>This function's execution time does not depend on the inputs.</source>
          <target state="translated">这个函数的执行时间不取决于输入。</target>
        </trans-unit>
        <trans-unit id="87202fef0c6c5ae187b02620dfd26b630d0392d4" translate="yes" xml:space="preserve">
          <source>This functionality should only be used with legacy web sites. RFC 2396 warns that interpreting Userinfo this way &amp;ldquo;is NOT RECOMMENDED, because the passing of authentication information in clear text (such as URI) has proven to be a security risk in almost every case where it has been used.&amp;rdquo;</source>
          <target state="translated">此功能只能与旧版网站一起使用。RFC 2396警告说，&amp;ldquo;以这种方式解释Userinfo是不推荐的，因为在几乎所有已使用身份验证信息的情况下，都已证明以明文（例如URI）传递身份验证信息存在安全风险。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="898688304c78e7f2468d53e47407efc6f38af32f" translate="yes" xml:space="preserve">
          <source>This implementation derives the nonce from an AES-CTR CSPRNG keyed by ChopMD(256, SHA2-512(priv.D || entropy || hash)). The CSPRNG key is IRO by a result of Coron; the AES-CTR stream is IRO under standard assumptions.</source>
          <target state="translated">本实施例从AES-CTR CSPRNG中导出非ce,其密钥由ChopMD(256,SHA2-512(priv.D || entropy || hash))获得。CSPRNG的密钥根据Coron的结果是IRO的;AES-CTR流在标准假设下是IRO的。</target>
        </trans-unit>
        <trans-unit id="689c9dd99bb5162e68a9aedd41062dfeb2de0804" translate="yes" xml:space="preserve">
          <source>This implementation derives the nonce from an AES-CTR CSPRNG keyed by:</source>
          <target state="translated">本实施例从AES-CTR CSPRNG键入的nonce中导出。</target>
        </trans-unit>
        <trans-unit id="b4c1ec8dd63ceb69c820647454432eed0e8ec308" translate="yes" xml:space="preserve">
          <source>This interface predates the fs.FS interface, which can be used instead: the FS adapter function converts an fs.FS to a FileSystem.</source>
          <target state="translated">这个接口的前身是fs.FS接口,它可以用来代替:FS适配器函数将fs.FS转换为FileSystem。</target>
        </trans-unit>
        <trans-unit id="d67c9b0649198706841943ee7eba2049c49bcdb3" translate="yes" xml:space="preserve">
          <source>This is handled as if &quot;my:data-href&quot; was just &quot;data-href&quot; and not &quot;href&quot; as it would be if the &quot;data-&quot; prefix were to be ignored too. Thus at parse time this becomes just</source>
          <target state="translated">这就好像 &quot;my:data-href &quot;只是 &quot;data-href &quot;而不是 &quot;href &quot;一样,如果 &quot;data-&quot;前缀也被忽略的话。因此在解析时,这就变成了</target>
        </trans-unit>
        <trans-unit id="d2d5c7329f986ca3d31bfdba2057014f5f44ad7d" translate="yes" xml:space="preserve">
          <source>This is only needed to install the handler in a non-standard location.</source>
          <target state="translated">这只需要在非标准位置安装处理程序。</target>
        </trans-unit>
        <trans-unit id="4726b7b6e93eb25607ca12b6c92e41d048948273" translate="yes" xml:space="preserve">
          <source>This is unnecessary as the next call to WriteHeader or Close will implicitly flush out the file's padding.</source>
          <target state="translated">这是不需要的,因为下一次调用WriteHeader或Close会隐含地冲掉文件的padding。</target>
        </trans-unit>
        <trans-unit id="8eba79d25cd0ac07c169a84af16002b1daff283c" translate="yes" xml:space="preserve">
          <source>This kind of key is commonly encoded in PEM blocks of type &quot;EC PRIVATE KEY&quot;.</source>
          <target state="translated">这种密钥通常用 &quot;EC PRIVATE KEY &quot;类型的PEM块进行编码。</target>
        </trans-unit>
        <trans-unit id="eb1b3ed68f800415903edd6e38e6c00b58c4b66a" translate="yes" xml:space="preserve">
          <source>This kind of key is commonly encoded in PEM blocks of type &quot;EC PRIVATE KEY&quot;. For a more flexible key format which is not EC specific, use MarshalPKCS8PrivateKey.</source>
          <target state="translated">这种密钥通常用 &quot;EC PRIVATE KEY &quot;类型的PEM块进行编码。如果想获得更灵活的密钥格式,而且不是EC专用的,可以使用MarshalPKCS8PrivateKey。</target>
        </trans-unit>
        <trans-unit id="56bef0ed59f36389d7550a0e4c48802187b81f7d" translate="yes" xml:space="preserve">
          <source>This kind of key is commonly encoded in PEM blocks of type &quot;EC PUBLIC KEY&quot;.</source>
          <target state="translated">这种密钥通常用 &quot;EC公共密钥 &quot;类型的PEM块进行编码。</target>
        </trans-unit>
        <trans-unit id="dfe352de6a0131091f458f18e937a358eab3152e" translate="yes" xml:space="preserve">
          <source>This kind of key is commonly encoded in PEM blocks of type &quot;PRIVATE KEY&quot;.</source>
          <target state="translated">这种密钥通常用 &quot;PRIVATE KEY &quot;类型的PEM块进行编码。</target>
        </trans-unit>
        <trans-unit id="42db7a056c64d4d64e474ea59fd1650377d9bc54" translate="yes" xml:space="preserve">
          <source>This kind of key is commonly encoded in PEM blocks of type &quot;PUBLIC KEY&quot;.</source>
          <target state="translated">这种密钥通常用 &quot;PUBLIC KEY &quot;类型的PEM块进行编码。</target>
        </trans-unit>
        <trans-unit id="64ab07dfb34f7d2feff364506aca7067a4453b39" translate="yes" xml:space="preserve">
          <source>This kind of key is commonly encoded in PEM blocks of type &quot;RSA PRIVATE KEY&quot;.</source>
          <target state="translated">这种密钥通常用 &quot;RSA PRIVATE KEY &quot;类型的PEM块进行编码。</target>
        </trans-unit>
        <trans-unit id="98a803d28f3224bf7891d32a0db324db326e4afd" translate="yes" xml:space="preserve">
          <source>This kind of key is commonly encoded in PEM blocks of type &quot;RSA PRIVATE KEY&quot;. For a more flexible key format which is not RSA specific, use MarshalPKCS8PrivateKey.</source>
          <target state="translated">这种密钥通常用 &quot;RSA PRIVATE KEY &quot;类型的PEM块进行编码。如果想获得更灵活的密钥格式,而且不是RSA专用的,可以使用MarshalPKCS8PrivateKey。</target>
        </trans-unit>
        <trans-unit id="5d8222cc13301829f5dbdc649eec16abab7d33d6" translate="yes" xml:space="preserve">
          <source>This kind of key is commonly encoded in PEM blocks of type &quot;RSA PUBLIC KEY&quot;.</source>
          <target state="translated">这种密钥通常用 &quot;RSA公共密钥 &quot;类型的PEM块进行编码。</target>
        </trans-unit>
        <trans-unit id="67c7b63689264a63777784c1588c7be8f2ebeb83" translate="yes" xml:space="preserve">
          <source>This means that, by default, command line programs will behave like typical Unix command line programs, while other programs will not crash with SIGPIPE when writing to a closed network connection.</source>
          <target state="translated">这意味着,在默认情况下,命令行程序会像典型的Unix命令行程序一样,而其他程序在写入封闭的网络连接时,不会用SIGPIPE崩溃。</target>
        </trans-unit>
        <trans-unit id="53c41745078961e0cbeedf1ad29b01ea99fe7434" translate="yes" xml:space="preserve">
          <source>This mechanism can be used to cancel long operations on the server if the client has disconnected before the response is ready.</source>
          <target state="translated">如果客户端在响应准备好之前断开了连接,这个机制可以用来取消对服务器的长时间操作。</target>
        </trans-unit>
        <trans-unit id="d3191056acdbdc6fd1ca936f76914f75eb4f8098" translate="yes" xml:space="preserve">
          <source>This mechanism is intended only for trailers that are not known prior to the headers being written. If the set of trailers is fixed or known before the header is written, the normal Go trailers mechanism is preferred:</source>
          <target state="translated">这种机制只适用于在写头之前不知道的线索。如果在写入头之前,跟踪器的集合是固定的或已知的,则首选正常的Go跟踪器机制。</target>
        </trans-unit>
        <trans-unit id="34dfd520d192c4e8193a79a528c0369751354149" translate="yes" xml:space="preserve">
          <source>This method consults the following fields of the response r:</source>
          <target state="translated">本方法会查询响应r的以下字段。</target>
        </trans-unit>
        <trans-unit id="6857cb2d00e6efa4c19dc849fe5f85bb657fb149" translate="yes" xml:space="preserve">
          <source>This method implements crypto.Signer, which is an interface to support keys where the private part is kept in, for example, a hardware module. Common uses should use the Sign function in this package directly.</source>
          <target state="translated">这个方法实现了crypto.Signer,它是一个接口,支持私密部分保存在硬件模块等地方的密钥。普通用途应该直接使用这个包中的Sign函数。</target>
        </trans-unit>
        <trans-unit id="dca73678d958fc56a6644aad153e6b5ae346adb8" translate="yes" xml:space="preserve">
          <source>This method implements crypto.Signer, which is an interface to support keys where the private part is kept in, for example, a hardware module. Common uses should use the Sign* functions in this package directly.</source>
          <target state="translated">这个方法实现了crypto.Signer,它是一个接口,支持私密部分保存在硬件模块等地方的密钥。普通用途应该直接使用这个包中的Sign*函数。</target>
        </trans-unit>
        <trans-unit id="6162e9fff452fe7b81839fc43d5a9b956682d1db" translate="yes" xml:space="preserve">
          <source>This package assumes that template authors are trusted, that Execute's data parameter is not, and seeks to preserve the properties below in the face of untrusted data:</source>
          <target state="translated">本包假设模板作者是受信任的,Execute的数据参数是不受信任的,在面对不受信任的数据时,力求保留以下属性。</target>
        </trans-unit>
        <trans-unit id="646741784bedcfbc50f393efbc21b4c2b803f33a" translate="yes" xml:space="preserve">
          <source>This package does not guarantee bit-identical results across architectures.</source>
          <target state="translated">这个软件包不保证不同架构的位相同结果。</target>
        </trans-unit>
        <trans-unit id="25b183f3fa47240bd162a6084ce81041d00db47f" translate="yes" xml:space="preserve">
          <source>This package does not support disk spanning.</source>
          <target state="translated">这个软件包不支持磁盘跨度。</target>
        </trans-unit>
        <trans-unit id="917226455af3a3e84812552f61aaf5f000d19a66" translate="yes" xml:space="preserve">
          <source>This package favors simplicity over efficiency. Clients that require high-performance serialization, especially for large data structures, should look at more advanced solutions such as the encoding/gob package or protocol buffers.</source>
          <target state="translated">这个包偏重于简单而非效率。需要高性能序列化的客户,特别是对于大型数据结构,应该考虑更高级的解决方案,如编码/gob包或协议缓冲器。</target>
        </trans-unit>
        <trans-unit id="91400ec0be490a039f54a2e8ea4991f07061b72f" translate="yes" xml:space="preserve">
          <source>This package is EXPERIMENTAL. Its current scope is only to allow tests to run, but not yet to provide a comprehensive API for users. It is exempt from the Go compatibility promise.</source>
          <target state="translated">这个包是实验性的。它目前的范围只是允许测试运行,但还没有为用户提供一个全面的API。它免于Go的兼容性承诺。</target>
        </trans-unit>
        <trans-unit id="f172ad46509f2996426e887fe6f7f5b737ccb0ba" translate="yes" xml:space="preserve">
          <source>This package is not implemented on NaCl (Native Client).</source>
          <target state="translated">这个包在NaCl(Native Client)上没有实现。</target>
        </trans-unit>
        <trans-unit id="70b7c3d76332df2a567dd4571a1dd43d36bb3d95" translate="yes" xml:space="preserve">
          <source>This package is not implemented on Plan 9.</source>
          <target state="translated">本套方案在计划9上没有实施。</target>
        </trans-unit>
        <trans-unit id="089323f3519ab53b437d7cbe9878efc86f18d94a" translate="yes" xml:space="preserve">
          <source>This package is not implemented on Windows. As the syslog package is frozen, Windows users are encouraged to use a package outside of the standard library. For background, see &lt;a href=&quot;https://golang.org/issue/1108&quot;&gt;https://golang.org/issue/1108&lt;/a&gt;.</source>
          <target state="translated">Windows上未实现此程序包。由于syslog程序包被冻结，因此鼓励Windows用户使用标准库之外的程序包。有关背景，请参见&lt;a href=&quot;https://golang.org/issue/1108&quot;&gt;https://golang.org/issue/1108&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="37ad2d1270c390f993e16f89ffda81efa69cc5ba" translate="yes" xml:space="preserve">
          <source>This package parses both the original &amp;ldquo;// +build&amp;rdquo; syntax and the &amp;ldquo;//go:build&amp;rdquo; syntax that will be added in Go 1.17. The parser is being included in Go 1.16 to allow tools that need to process Go 1.17 source code to still be built against the Go 1.16 release. See &lt;a href=&quot;https://golang.org/design/draft-gobuild&quot;&gt;https://golang.org/design/draft-gobuild&lt;/a&gt; for details about the &amp;ldquo;//go:build&amp;rdquo; syntax.</source>
          <target state="translated">该程序包解析原始的&amp;ldquo; // + build&amp;rdquo;语法和将在Go 1.17中添加的&amp;ldquo; // go：build&amp;rdquo;语法。该解析器包含在Go 1.16中，以允许仍根据Go 1.16版本构建需要处理Go 1.17源代码的工具。有关&amp;ldquo; // go：build&amp;rdquo;语法的详细信息，请参见&lt;a href=&quot;https://golang.org/design/draft-gobuild&quot;&gt;https://golang.org/design/draft-gobuild&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e0a342a318c5bf238d0752ca434eaa7de9a66322" translate="yes" xml:space="preserve">
          <source>This package should normally be imported by a program's main package, not by a library. Libraries normally shouldn't decide whether to include the timezone database in a program.</source>
          <target state="translated">这个包通常应该由程序的主包导入,而不是由库导入。库通常不应该决定是否在程序中包含时区数据库。</target>
        </trans-unit>
        <trans-unit id="6d4fcbbffc8fc9a4336682d220cd948063216551" translate="yes" xml:space="preserve">
          <source>This package supports metrics whose values have a floating-point representation. In order to improve ease-of-use, this package promises to never produce the following classes of floating-point values: NaN, infinity.</source>
          <target state="translated">这个软件包支持浮点表示的度量值,为了提高易用性,这个软件包承诺不会产生以下类别的浮点值。为了提高易用性,本包承诺永远不会产生以下类别的浮点值。NaN,infinity.</target>
        </trans-unit>
        <trans-unit id="4c28db944fb8406ea70640148283b4f2b07cfe75" translate="yes" xml:space="preserve">
          <source>This package understands HTML, CSS, JavaScript, and URIs. It adds sanitizing functions to each simple action pipeline, so given the excerpt</source>
          <target state="translated">这个包了解HTML、CSS、JavaScript和URI。它为每个简单的动作流水线添加了消毒功能,所以给定的摘录是</target>
        </trans-unit>
        <trans-unit id="df567a8ebe9ff3e3072f56ef8a4b9eaa7e757875" translate="yes" xml:space="preserve">
          <source>This package will be automatically imported if you build with -tags timetzdata.</source>
          <target state="translated">如果你使用-tags timetzdata进行构建,这个包将被自动导入。</target>
        </trans-unit>
        <trans-unit id="63f9c654258649e0fec61304d0149ff6b7e1fac2" translate="yes" xml:space="preserve">
          <source>This package wraps package text/template so you can share its template API to parse and execute HTML templates safely.</source>
          <target state="translated">这个包封装了package text/template,这样你就可以分享它的模板API来安全地解析和执行HTML模板。</target>
        </trans-unit>
        <trans-unit id="12b81feb5020b97e164b3bd1ab6605720164a33f" translate="yes" xml:space="preserve">
          <source>This palette was used in the Plan 9 Operating System, described at &lt;a href=&quot;https://9p.io/magic/man2html/6/color&quot;&gt;https://9p.io/magic/man2html/6/color&lt;/a&gt;</source>
          <target state="translated">此选板用于&lt;a href=&quot;https://9p.io/magic/man2html/6/color&quot;&gt;https://9p.io/magic/man2html/6/color&lt;/a&gt;中的Plan 9操作系统。</target>
        </trans-unit>
        <trans-unit id="53f264e60d97dda7c8e598fd892c840f64c77bcb" translate="yes" xml:space="preserve">
          <source>This returns a Writer to which the file contents should be written. The file's contents must be written to the io.Writer before the next call to Create, CreateHeader, or Close.</source>
          <target state="translated">这将返回一个写入文件内容的Writer。在下一次调用Create、CreateHeader或Close之前,文件的内容必须被写入io.Writer。</target>
        </trans-unit>
        <trans-unit id="3636f2d8cb7dce3b52ad380d63ea631656bb70da" translate="yes" xml:space="preserve">
          <source>This runtime/trace package provides APIs to add equivalent tracing support to a standalone program. See the Example that demonstrates how to use this API to enable tracing.</source>
          <target state="translated">这个运行时/跟踪包提供了API,可以为独立的程序添加同等的跟踪支持。请参阅示例,演示如何使用该API来启用跟踪。</target>
        </trans-unit>
        <trans-unit id="eb3d7236d288f19d5e07330ec9b641abb7a1c736" translate="yes" xml:space="preserve">
          <source>This section documents the encoding, details that are not important for most users. Details are presented bottom-up.</source>
          <target state="translated">本节记录了编码、细节,这些细节对大多数用户来说并不重要。细节是自下而上的介绍。</target>
        </trans-unit>
        <trans-unit id="8d97dde3cffa35e96f0901463ccd21bc2b7e33d2" translate="yes" xml:space="preserve">
          <source>This set may grow. Note that regular expression matches may need to examine text beyond the text returned by a match, so the methods that match text from a RuneReader may read arbitrarily far into the input before returning.</source>
          <target state="translated">这个集合可能会增加。请注意,正则表达式匹配可能需要检查匹配返回的文本之外的文本,因此匹配来自RuneReader的文本的方法可能会在返回之前任意读取输入的内容。</target>
        </trans-unit>
        <trans-unit id="13155ea54999e3f67a0c6d8a556ef2fb922860ce" translate="yes" xml:space="preserve">
          <source>This should not be done concurrent to other receives from the Timer's channel.</source>
          <target state="translated">这不应该与定时器通道的其他接收同时进行。</target>
        </trans-unit>
        <trans-unit id="0da770375be11542fa319ca413fcc3ece2b576a4" translate="yes" xml:space="preserve">
          <source>This type should be considered identical to sql.IsolationLevel along with any values defined on it.</source>
          <target state="translated">这个类型应该和 sql.IsolationLevel 以及在它上面定义的任何值被认为是相同的。</target>
        </trans-unit>
        <trans-unit id="5cefc7416c362c1afcf6c674cc1720ba6d02139f" translate="yes" xml:space="preserve">
          <source>This type should be considered identical to sql.TxOptions.</source>
          <target state="translated">这个类型应该被认为与 sql.TxOptions 相同。</target>
        </trans-unit>
        <trans-unit id="23bb56893bd9c167f4933bba0f06ea209969209a" translate="yes" xml:space="preserve">
          <source>ThreadCreateProfile returns n, the number of records in the thread creation profile. If len(p) &amp;gt;= n, ThreadCreateProfile copies the profile into p and returns n, true. If len(p) &amp;lt; n, ThreadCreateProfile does not change p and returns n, false.</source>
          <target state="translated">ThreadCreateProfile返回n，即线程创建配置文件中的记录数。如果len（p）&amp;gt; = n，则ThreadCreateProfile将配置文件复制到p中并返回n，为true。如果len（p）&amp;lt;n，则ThreadCreateProfile不会更改p并返回n，否则为false。</target>
        </trans-unit>
        <trans-unit id="053a6e5ff5756153adf26636a41ad3c9d51f80be" translate="yes" xml:space="preserve">
          <source>Thus, users of this API are encouraged to sample supported metrics defined by the slice returned by All to remain compatible across Go versions. Of course, situations arise where reading specific metrics is critical. For these cases, users are encouraged to use build tags, and although metrics may be deprecated and removed, users should consider this to be an exceptional and rare event, coinciding with a very large change in a particular Go implementation.</source>
          <target state="translated">因此,我们鼓励该API的用户对All返回的分片所定义的支持的度量进行采样,以便在不同的Go版本中保持兼容。当然,会出现读取特定度量指标至关重要的情况。对于这些情况,我们鼓励用户使用构建标签,虽然度量可能会被废弃和删除,但用户应该认为这是一个特殊和罕见的事件,恰好与特定Go实现中非常大的变化相吻合。</target>
        </trans-unit>
        <trans-unit id="aeddfe22a01fc0ff5fb0fe691b08db0b2e2a26c7" translate="yes" xml:space="preserve">
          <source>Tick</source>
          <target state="translated">Tick</target>
        </trans-unit>
        <trans-unit id="26c9fc157a3f52de1aca92922ccb9a288e5fa386" translate="yes" xml:space="preserve">
          <source>Tick is a convenience wrapper for NewTicker providing access to the ticking channel only. While Tick is useful for clients that have no need to shut down the Ticker, be aware that without a way to shut it down the underlying Ticker cannot be recovered by the garbage collector; it &quot;leaks&quot;. Unlike NewTicker, Tick will return nil if d &amp;lt;= 0.</source>
          <target state="translated">Tick是NewTicker的便捷包装，仅提供对滴答通道的访问。虽然Tick对于不需要关闭Ticker的客户端很有用，但是请注意，如果没有关闭Ticker的方法，则垃圾收集器无法恢复基础Ticker；它&amp;ldquo;泄漏&amp;rdquo;。与NewTicker不同，如果d &amp;lt;= 0，则Tick将返回nil。</target>
        </trans-unit>
        <trans-unit id="464b9c4863cbad4e03c3166e6a41a020f20219b8" translate="yes" xml:space="preserve">
          <source>Time instants can be compared using the Before, After, and Equal methods. The Sub method subtracts two instants, producing a Duration. The Add method adds a Time and a Duration, producing a Time.</source>
          <target state="translated">可以使用 &quot;之前&quot;、&quot;之后 &quot;和 &quot;等值 &quot;方法比较时间瞬时。Sub方法减去两个实例,产生一个Duration。添加方法添加一个时间和一个持续时间,产生一个时间。</target>
        </trans-unit>
        <trans-unit id="7e0d5fdb48c2796b9cc511f84f1969b59a9bd1cf" translate="yes" xml:space="preserve">
          <source>Time.Add</source>
          <target state="translated">Time.Add</target>
        </trans-unit>
        <trans-unit id="5c2e779ba4c8677013ab3eb4de9c1e6bf9c9924b" translate="yes" xml:space="preserve">
          <source>Time.AddDate</source>
          <target state="translated">Time.AddDate</target>
        </trans-unit>
        <trans-unit id="730b4aa03b8316a2a6c19e05b72ec5d4eb05e78c" translate="yes" xml:space="preserve">
          <source>Time.After</source>
          <target state="translated">Time.After</target>
        </trans-unit>
        <trans-unit id="d5e86b615c46a18260de62e172d7e06cc20f7083" translate="yes" xml:space="preserve">
          <source>Time.AppendFormat</source>
          <target state="translated">Time.AppendFormat</target>
        </trans-unit>
        <trans-unit id="88be4309d5e0539eff6218d7e8c02ecf0c7b2e65" translate="yes" xml:space="preserve">
          <source>Time.Before</source>
          <target state="translated">Time.Before</target>
        </trans-unit>
        <trans-unit id="480d1c53462d365532b2348e82a3f0dcb963c99e" translate="yes" xml:space="preserve">
          <source>Time.Date</source>
          <target state="translated">Time.Date</target>
        </trans-unit>
        <trans-unit id="ae2638b80e7bdac6e6725adc567cf7badedc6abe" translate="yes" xml:space="preserve">
          <source>Time.Day</source>
          <target state="translated">Time.Day</target>
        </trans-unit>
        <trans-unit id="d4766b7b3328342b5ba1a667334b95afb4c840fd" translate="yes" xml:space="preserve">
          <source>Time.Equal</source>
          <target state="translated">Time.Equal</target>
        </trans-unit>
        <trans-unit id="092fc9098aafde18e6cec288675831ee7d77f8a8" translate="yes" xml:space="preserve">
          <source>Time.Format</source>
          <target state="translated">Time.Format</target>
        </trans-unit>
        <trans-unit id="dd61b8e28117a6a8c31fd714a3696b1193538443" translate="yes" xml:space="preserve">
          <source>Time.Format (Pad)</source>
          <target state="translated">时间.格式(Pad)</target>
        </trans-unit>
        <trans-unit id="3768befc26b5bc40a2c6b38ecc6f26a0656a5d40" translate="yes" xml:space="preserve">
          <source>Time.Round</source>
          <target state="translated">Time.Round</target>
        </trans-unit>
        <trans-unit id="5b138a17083c1c36c8bab2fd64e7493a32a70b68" translate="yes" xml:space="preserve">
          <source>Time.String</source>
          <target state="translated">Time.String</target>
        </trans-unit>
        <trans-unit id="e126e45961c85339227ad3c92517287507ec5152" translate="yes" xml:space="preserve">
          <source>Time.Sub</source>
          <target state="translated">Time.Sub</target>
        </trans-unit>
        <trans-unit id="d3f1777c34673ecabb71603383f8d1fd8d6be9c4" translate="yes" xml:space="preserve">
          <source>Time.Truncate</source>
          <target state="translated">Time.Truncate</target>
        </trans-unit>
        <trans-unit id="c4ee117595e7091017dcf807233ec5e3324552ac" translate="yes" xml:space="preserve">
          <source>Time.Unix</source>
          <target state="translated">Time.Unix</target>
        </trans-unit>
        <trans-unit id="f8fc7e6bb582b1829de5a848ff872dea68eff61d" translate="yes" xml:space="preserve">
          <source>TimeFormat is the time format to use when generating times in HTTP headers. It is like time.RFC1123 but hard-codes GMT as the time zone. The time being formatted must be in UTC for Format to generate the correct format.</source>
          <target state="translated">TimeFormat是在HTTP头文件中生成时间时使用的时间格式。它类似于time.RFC1123,但硬编码为GMT作为时区。被格式化的时间必须是UTC,这样Format才能生成正确的格式。</target>
        </trans-unit>
        <trans-unit id="9827d1afd02311b970b1c9ab5d2482ee7f917a5d" translate="yes" xml:space="preserve">
          <source>Timeout reports whether the DNS lookup is known to have timed out. This is not always known; a DNS lookup may fail due to a timeout and return a DNSError for which Timeout returns false.</source>
          <target state="translated">超时报告是否已知DNS查找已经超时。这并不总是已知的;DNS查找可能会因为超时而失败,并返回一个DNSError,Timeout返回false。</target>
        </trans-unit>
        <trans-unit id="927810e8434679578bc9bf07a4312dbfd80340d4" translate="yes" xml:space="preserve">
          <source>Timeout reports whether this error represents a timeout.</source>
          <target state="translated">超时报告该错误是否代表超时。</target>
        </trans-unit>
        <trans-unit id="e7860bff1be7d01a8121a71b30616b2279f825c3" translate="yes" xml:space="preserve">
          <source>TimeoutHandler returns a Handler that runs h with the given time limit.</source>
          <target state="translated">TimeoutHandler返回一个以给定时间限制运行h的处理程序。</target>
        </trans-unit>
        <trans-unit id="41f375b226e7f8e10a9acde2441f73751822f0d4" translate="yes" xml:space="preserve">
          <source>TimeoutHandler supports the Flusher and Pusher interfaces but does not support the Hijacker interface.</source>
          <target state="translated">TimeoutHandler支持Flusher和Pusher接口,但不支持Hijacker接口。</target>
        </trans-unit>
        <trans-unit id="229f8a47d6424d21cc11a27228c5b3dd3021912d" translate="yes" xml:space="preserve">
          <source>TimeoutHandler supports the Pusher interface but does not support the Hijacker or Flusher interfaces.</source>
          <target state="translated">TimeoutHandler支持Pusher接口,但不支持Hijacker或Flusher接口。</target>
        </trans-unit>
        <trans-unit id="b94b20b16ca4b5f916aaa1eb8d24553f8d4b92c2" translate="yes" xml:space="preserve">
          <source>TimeoutReader returns ErrTimeout on the second read with no data. Subsequent calls to read succeed.</source>
          <target state="translated">TimeoutReader在第二次读取时返回ErrTimeout,没有数据。随后的读取调用成功。</target>
        </trans-unit>
        <trans-unit id="092b95acf2f2e3d735b1b9d6eb619d6f9b285116" translate="yes" xml:space="preserve">
          <source>TimespecToNSec returns the time stored in ts as nanoseconds.</source>
          <target state="translated">TimespecToNSec以纳秒的形式返回存储在ts中的时间。</target>
        </trans-unit>
        <trans-unit id="8bdae2bbf616fbfd5c5eefd29c8a537bd886144c" translate="yes" xml:space="preserve">
          <source>TimespecToNsec converts a Timespec value into a number of nanoseconds since the Unix epoch.</source>
          <target state="translated">TimespecToNsec将Timespec值转换为Unix纪元后的纳秒数。</target>
        </trans-unit>
        <trans-unit id="71641b558817e2a09b865dac9868550ced5db039" translate="yes" xml:space="preserve">
          <source>TimevalToNsec converts a Timeval value into a number of nanoseconds since the Unix epoch.</source>
          <target state="translated">TimevalToNsec将Timeval值转换为Unix纪元后的纳秒数。</target>
        </trans-unit>
        <trans-unit id="88a226b5c5421dc95c12f9851cda7185d1ebf771" translate="yes" xml:space="preserve">
          <source>TimevalToNsec returns the time stored in tv as nanoseconds.</source>
          <target state="translated">TimevalToNsec 返回存储在tv中的纳秒时间。</target>
        </trans-unit>
        <trans-unit id="768e0c1c69573fb588f61f1308a015c11468e05f" translate="yes" xml:space="preserve">
          <source>Title</source>
          <target state="translated">Title</target>
        </trans-unit>
        <trans-unit id="ee048df59e1fe3a78061c7c9271c635869379b9b" translate="yes" xml:space="preserve">
          <source>Title returns a copy of the string s with all Unicode letters that begin words mapped to their Unicode title case.</source>
          <target state="translated">Title返回字符串s的副本,其中包含所有单词开头的Unicode字母,并映射到Unicode标题大小写。</target>
        </trans-unit>
        <trans-unit id="173f12648645a6edd8fcbab7c7ed0369c007806c" translate="yes" xml:space="preserve">
          <source>Title treats s as UTF-8-encoded bytes and returns a copy with all Unicode letters that begin words mapped to their title case.</source>
          <target state="translated">Title将s视为UTF-8编码的字节,并返回一个包含所有Unicode字母的副本,这些Unicode字母开始的单词都映射到它们的标题大小写。</target>
        </trans-unit>
        <trans-unit id="ae79ea1e9c6391a9ed83a2e18a031b835feec0c9" translate="yes" xml:space="preserve">
          <source>To</source>
          <target state="translated">To</target>
        </trans-unit>
        <trans-unit id="616d61f65a9f91c650c28db92d9cb8984a1f52bd" translate="yes" xml:space="preserve">
          <source>To add equivalent profiling support to a standalone program, add code like the following to your main function:</source>
          <target state="translated">要在独立的程序中添加等效的剖析支持,在你的主函数中添加类似下面的代码。</target>
        </trans-unit>
        <trans-unit id="f6f5822190a6e77b3f6e2423fce4abac430f1e8d" translate="yes" xml:space="preserve">
          <source>To avoid denial of service attacks, the provided bufio.Reader should be reading from an io.LimitReader or similar Reader to bound the size of responses.</source>
          <target state="translated">为了避免拒绝服务攻击,提供的bufio.Reader应该从io.LimitReader或类似的Reader中读取,以约束响应的大小。</target>
        </trans-unit>
        <trans-unit id="87386ad5a06e96430212748899697cda9d7a3724" translate="yes" xml:space="preserve">
          <source>To avoid recursion in cases such as</source>
          <target state="translated">为了避免递归的情况,如</target>
        </trans-unit>
        <trans-unit id="a87f0fb7c131221874ae3b0c17104f44ee1c34bc" translate="yes" xml:space="preserve">
          <source>To be backwards compatible the FileHeader has both 32 and 64 bit Size fields. The 64 bit fields will always contain the correct value and for normal archives both fields will be the same. For files requiring the ZIP64 format the 32 bit fields will be 0xffffffff and the 64 bit fields must be used instead.</source>
          <target state="translated">为了向后兼容,FileHeader有32位和64位大小字段。64位的字段将始终包含正确的值,对于普通的存档,两个字段将是相同的。对于需要ZIP64格式的文件,32位字段为0xffffffffff,必须使用64位字段。</target>
        </trans-unit>
        <trans-unit id="f0c9c2ba0d3b42114f628f0336b7d63f8138a666" translate="yes" xml:space="preserve">
          <source>To build a file only when using cgo, and only on Linux and OS X:</source>
          <target state="translated">只有在使用cgo时才能建立文件,而且只能在Linux和OS X上建立。</target>
        </trans-unit>
        <trans-unit id="b59fa373960766ba2850aeb1bfd6ebb3acccc2d0" translate="yes" xml:space="preserve">
          <source>To build strings more efficiently, see the strings.Builder type.</source>
          <target state="translated">为了更有效地构建字符串,请参见strings.Builder类型。</target>
        </trans-unit>
        <trans-unit id="65822ab438826bd3303521dc362fbdb7385f9c68" translate="yes" xml:space="preserve">
          <source>To change the destination for flag messages, call CommandLine.SetOutput.</source>
          <target state="translated">要改变标志信息的目的地,请调用CommandLine.SetOutput。</target>
        </trans-unit>
        <trans-unit id="697c0150c9b1eec40f18c8aa7919a2878d3bf00a" translate="yes" xml:space="preserve">
          <source>To compare two Values, compare the results of the Interface method. Using == on two Values does not compare the underlying values they represent.</source>
          <target state="translated">要比较两个值,比较接口方法的结果。在两个值上使用==不会比较它们所代表的基本值。</target>
        </trans-unit>
        <trans-unit id="26bcf90200ee4c383ef61356b62c1cde915663a4" translate="yes" xml:space="preserve">
          <source>To complete the example above, the following code tries to find the value x in an integer slice data sorted in ascending order:</source>
          <target state="translated">为了完成上面的例子,下面的代码试图在一个升序排序的整数片数据中找到值x。</target>
        </trans-unit>
        <trans-unit id="48862e3dd334f932c3f29aca76cb78295d40632d" translate="yes" xml:space="preserve">
          <source>To compute the number of allocations, the function will first be run once as a warm-up. The average number of allocations over the specified number of runs will then be measured and returned.</source>
          <target state="translated">要计算分配数量,首先要运行一次函数作为热身。然后测量并返回指定运行次数的平均分配数量。</target>
        </trans-unit>
        <trans-unit id="a1b4d9690ab97f466c6d326d8c742f5be1f15108" translate="yes" xml:space="preserve">
          <source>To convert an integer number of units to a Duration, multiply:</source>
          <target state="translated">要将整数单位转换为持续时间,请乘以。</target>
        </trans-unit>
        <trans-unit id="c70ea98cf5f708e17c34d681b2e9583414cbfaae" translate="yes" xml:space="preserve">
          <source>To count the number of units in a Duration, divide:</source>
          <target state="translated">要计算一个Duration中的单位数,除以。</target>
        </trans-unit>
        <trans-unit id="a8a481566ee5c9f4011b251f076b7cff25d2b336" translate="yes" xml:space="preserve">
          <source>To create a new request with a context, use NewRequestWithContext. To change the context of a request (such as an incoming) you then also want to modify to send back out, use Request.Clone. Between those two uses, it's rare to need WithContext.</source>
          <target state="translated">要创建一个带有上下文的新请求,使用NewRequestWithContext。要改变一个请求的上下文(比如一个传入的请求),然后你也想修改后再发送出去,使用Request.Clone.WithContext。在这两种用法之间,很少需要WithContext。</target>
        </trans-unit>
        <trans-unit id="df17ef73a333723433e10a65752b7d97c8d742ec" translate="yes" xml:space="preserve">
          <source>To create a new request with a context, use NewRequestWithContext. To change the context of a request, such as an incoming request you want to modify before sending back out, use Request.Clone. Between those two uses, it's rare to need WithContext.</source>
          <target state="translated">要创建一个带有上下文的新请求,使用NewRequestWithContext。要改变一个请求的上下文,比如你想在发送出去之前修改一个传入的请求,使用Request.Clone.Clone。在这两种用法之间,很少需要WithContext。</target>
        </trans-unit>
        <trans-unit id="d1ce4e028f3adf6fe5e3e3ea8b7a3ce1d7c4cce0" translate="yes" xml:space="preserve">
          <source>To create the Pos value for a specific source offset (measured in bytes), first add the respective file to the current file set using FileSet.AddFile and then call File.Pos(offset) for that file. Given a Pos value p for a specific file set fset, the corresponding Position value is obtained by calling fset.Position(p).</source>
          <target state="translated">要为特定的源偏移量(以字节为单位)创建Pos值,首先使用FileSet.AddFile将相应的文件添加到当前的文件集中,然后为该文件调用File.Pos(offset)。给定一个特定文件集fset的Pos值p,通过调用fset.Position(p)获得相应的Position值。</target>
        </trans-unit>
        <trans-unit id="ffa6362a850b5571ec14ab520e75aaa3f0b772a0" translate="yes" xml:space="preserve">
          <source>To define a type, the encoder chooses an unused, positive type id and sends the pair (-type id, encoded-type) where encoded-type is the gob encoding of a wireType description, constructed from these types:</source>
          <target state="translated">为了定义一个类型,编码器选择一个未使用的正类型id,并发送一对(-type id,encoded-type),其中encoded-type是wireType描述的gob编码,由这些类型构造而成。</target>
        </trans-unit>
        <trans-unit id="da43583df08c2ff7e4692ba80d3b2cf801b80a61" translate="yes" xml:space="preserve">
          <source>To define your own format, write down what the reference time would look like formatted your way; see the values of constants like ANSIC, StampMicro or Kitchen for examples. The model is to demonstrate what the reference time looks like so that the Format and Parse methods can apply the same transformation to a general time value.</source>
          <target state="translated">要定义你自己的格式,请写下参考时间按你的方式格式化后的样子;参见ANSIC、StampMicro或Kitchen等常量的值来举例。这个模型是为了演示参考时间是什么样子的,这样Format和Parse方法就可以对一般的时间值进行同样的转换。</target>
        </trans-unit>
        <trans-unit id="79806cf1eaac70011a5e985d3751306c16fa37ee" translate="yes" xml:space="preserve">
          <source>To distinguish build constraints from package documentation, a series of build constraints must be followed by a blank line.</source>
          <target state="translated">为了将构建约束与包文档区分开来,一系列的构建约束后面必须有一个空行。</target>
        </trans-unit>
        <trans-unit id="a50607887789cbea54ccb0db0c455e312a84417e" translate="yes" xml:space="preserve">
          <source>To ensure the channel is empty after a call to Stop, check the return value and drain the channel. For example, assuming the program has not received from t.C already:</source>
          <target state="translated">为了确保在调用Stop后通道是空的,检查返回值并排出通道。例如,假设程序还没有从t.C接收到。</target>
        </trans-unit>
        <trans-unit id="dc7659d0594b1222a7c79baf65726fd2fc8fc92f" translate="yes" xml:space="preserve">
          <source>To escape a text segment, bracket it with Escape characters. For instance, the tab in this string &quot;Ignore this tab: \xff\t\xff&quot; does not terminate a cell and constitutes a single character of width one for formatting purposes.</source>
          <target state="translated">要转义一个文本段,请用Escape字符将其括起来。例如,这个字符串中的制表符 &quot;忽略这个制表符。\xffff/t/xff &quot;并没有结束一个单元格,而是构成一个宽度为1的单字符,用于格式化。</target>
        </trans-unit>
        <trans-unit id="a3866d2c65d6d17db1dce0e7ab464336a1186960" translate="yes" xml:space="preserve">
          <source>To force integer division of Int operands, use op == token.QUO_ASSIGN instead of token.QUO; the result is guaranteed to be Int in this case. Division by zero leads to a run-time panic.</source>
          <target state="translated">要强制Int操作数的整数除法,使用op ==token.QUO_ASSIGN取代token.QUO;在这种情况下,保证结果是Int。除以零会导致运行时的恐慌。</target>
        </trans-unit>
        <trans-unit id="93f96dd1110bc83e45c261305087ab59ccdab5c6" translate="yes" xml:space="preserve">
          <source>To generate HTML output, see package html/template, which has the same interface as this package but automatically secures HTML output against certain attacks.</source>
          <target state="translated">要生成HTML输出,请参见包html/template,它的界面与本包相同,但能自动保证HTML输出不受某些攻击。</target>
        </trans-unit>
        <trans-unit id="0f37e1016d8b746740d606c5f03bd61a370f62be" translate="yes" xml:space="preserve">
          <source>To generate a client HTTP request instead of a server request, see the NewRequest function in the net/http package.</source>
          <target state="translated">要生成一个客户端的HTTP请求而不是服务器请求,请参见net/http包中的NewRequest函数。</target>
        </trans-unit>
        <trans-unit id="06a96f64d7d0f413489f0372ff0c9c5459591c5b" translate="yes" xml:space="preserve">
          <source>To include every allocated block in the profile, set MemProfileRate to 1. To turn off profiling entirely, set MemProfileRate to 0.</source>
          <target state="translated">要将每个分配的块都包含在配置文件中,将MemProfileRate设置为1。 要完全关闭配置文件,将MemProfileRate设置为0。</target>
        </trans-unit>
        <trans-unit id="1cf82e7adf1a06dc5b4204dd8949c669c22a6ce1" translate="yes" xml:space="preserve">
          <source>To include every blocking event in the profile, pass rate = 1. To turn off profiling entirely, pass rate &amp;lt;= 0.</source>
          <target state="translated">要将每个阻止事件包括在配置文件中，合格率=1。要完全关闭分析，合格率&amp;lt;= 0。</target>
        </trans-unit>
        <trans-unit id="5634feb2ac7b66d9d403fa3ba44d3dd35de4aafa" translate="yes" xml:space="preserve">
          <source>To insert a literal $ in the output, use $$ in the template.</source>
          <target state="translated">要在输出中插入一个字面的$,请在模板中使用$。</target>
        </trans-unit>
        <trans-unit id="fc7c25c25b23cfac629203b1f680a734ada8bcd7" translate="yes" xml:space="preserve">
          <source>To iterate over a list (where l is a *List):</source>
          <target state="translated">遍历一个列表(其中l是一个*List)。</target>
        </trans-unit>
        <trans-unit id="04464b93c140cce60515e90ab741d559641a3b86" translate="yes" xml:space="preserve">
          <source>To keep a file from being considered for the build:</source>
          <target state="translated">为了防止一个文件被认为是构建。</target>
        </trans-unit>
        <trans-unit id="b8dd565d2e14c4949f658d07fd948bd6982afd99" translate="yes" xml:space="preserve">
          <source>To make a request with custom headers, use NewRequest and Client.Do.</source>
          <target state="translated">要使用自定义头信息进行请求,请使用NewRequest和Client.Do。</target>
        </trans-unit>
        <trans-unit id="5032a2d57ff9e66d730ea600879b156b0a5e02a1" translate="yes" xml:space="preserve">
          <source>To make a request with custom headers, use NewRequest and DefaultClient.Do.</source>
          <target state="translated">要使用自定义头信息进行请求,请使用NewRequest和DefaultClient.Do。</target>
        </trans-unit>
        <trans-unit id="706ee8ff1d514d4082de19c46038d881341df0b9" translate="yes" xml:space="preserve">
          <source>To maps the rune to the specified case: UpperCase, LowerCase, or TitleCase.</source>
          <target state="translated">要将符文映射到指定的大小写。大写,小写,或标题大小写。</target>
        </trans-unit>
        <trans-unit id="13858e1fce15a0a8116d4d08d0813cfa32d04dd1" translate="yes" xml:space="preserve">
          <source>To prevent IP spoofing, be sure to delete any pre-existing X-Forwarded-For header coming from the client or an untrusted proxy.</source>
          <target state="translated">为了防止IP欺骗,请确保删除任何来自客户端或不受信任的代理的预先存在的X-Forwarded-For头。</target>
        </trans-unit>
        <trans-unit id="16db8fa630b8ed6e5e098c9ecc986852e23449ff" translate="yes" xml:space="preserve">
          <source>To prevent duplicate operations, ErrBadConn should NOT be returned if there's a possibility that the database server might have performed the operation. Even if the server sends back an error, you shouldn't return ErrBadConn.</source>
          <target state="translated">为了防止重复操作,如果数据库服务器有可能执行了操作,就不应该返回ErrBadConn。即使服务器发回一个错误,也不应该返回ErrBadConn。</target>
        </trans-unit>
        <trans-unit id="367a95ef6b89677c6010e99bfe83911bb6aa0ff5" translate="yes" xml:space="preserve">
          <source>To remove a prefix, use TrimPrefix instead.</source>
          <target state="translated">要删除前缀,请使用 TrimPrefix。</target>
        </trans-unit>
        <trans-unit id="651b4bc851ab5004fd129e9e0ff7675d7d666cef" translate="yes" xml:space="preserve">
          <source>To remove a suffix, use TrimSuffix instead.</source>
          <target state="translated">要删除后缀,请使用 TrimSuffix。</target>
        </trans-unit>
        <trans-unit id="c83bbc4183fb8f4e0540869ebe8099226ccd8816" translate="yes" xml:space="preserve">
          <source>To set custom headers, use NewRequest and Client.Do.</source>
          <target state="translated">要设置自定义的头,使用NewRequest和Client.Do。</target>
        </trans-unit>
        <trans-unit id="71135b9f4481c76b2f670b0d39a1f656b3961a0f" translate="yes" xml:space="preserve">
          <source>To set custom headers, use NewRequest and DefaultClient.Do.</source>
          <target state="translated">要设置自定义的头,使用NewRequest和DefaultClient.Do。</target>
        </trans-unit>
        <trans-unit id="db9b30900d9da4419f81d83d998e553e2dab25bb" translate="yes" xml:space="preserve">
          <source>To support custom data types, implement NamedValueChecker. NamedValueChecker also allows queries to accept per-query options as a parameter by returning ErrRemoveArgument from CheckNamedValue.</source>
          <target state="translated">要支持自定义数据类型,请实现NamedValueChecker。NamedValueChecker还允许查询通过从CheckNamedValue返回ErrRemoveArgument来接受每个查询选项作为参数。</target>
        </trans-unit>
        <trans-unit id="9522949e411b2165edb986c411282650712ef336" translate="yes" xml:space="preserve">
          <source>To support tools that analyze Go packages, the patterns found in //go:embed lines are available in &amp;ldquo;go list&amp;rdquo; output. See the EmbedPatterns, TestEmbedPatterns, and XTestEmbedPatterns fields in the &amp;ldquo;go help list&amp;rdquo; output.</source>
          <target state="translated">为了支持分析Go软件包的工具，在// go：嵌入行中找到的模式在&amp;ldquo; go list&amp;rdquo;输出中可用。请参阅&amp;ldquo;转到帮助列表&amp;rdquo;输出中的EmbedPatterns，TestEmbedPatterns和XTestEmbedPatterns字段。</target>
        </trans-unit>
        <trans-unit id="75e0a568234c8cc832fa169bfc3c25d385870808" translate="yes" xml:space="preserve">
          <source>To translate these PCs into symbolic information such as function names and line numbers, use CallersFrames. CallersFrames accounts for inlined functions and adjusts the return program counters into call program counters. Iterating over the returned slice of PCs directly is discouraged, as is using FuncForPC on any of the returned PCs, since these cannot account for inlining or return program counter adjustment.</source>
          <target state="translated">要将这些PC转化为函数名和行号等符号信息,可以使用CallersFrames。CallersFrames对内联函数进行核算,并将返回的程序计数器调整为调用程序计数器。不鼓励直接在返回的PC片上进行迭代,也不鼓励在任何返回的PC上使用FuncForPC,因为这些不能说明内联或返回程序计数器的调整。</target>
        </trans-unit>
        <trans-unit id="83002d8cdc0fe4d874cff59ee6e149e3669f91df" translate="yes" xml:space="preserve">
          <source>To translate these PCs into symbolic information such as function names and line numbers, use CallersFrames. CallersFrames accounts for inlined functions and adjusts the return program counters into call program counters. Iterating over the returned slice of PCs directly is discouraged, as is using FuncForPC on any of the returned PCs, since these cannot account for inlining or return program counter adjustment. go:noinline</source>
          <target state="translated">要将这些PC转化为函数名和行号等符号信息,可以使用CallersFrames。CallersFrames对内联函数进行核算,并将返回的程序计数器调整为调用程序计数器。不鼓励直接在返回的PC片上进行迭代,也不鼓励在任何返回的PC上使用FuncForPC,因为这些不能说明内联或返回程序计数器的调整。 go:noinline</target>
        </trans-unit>
        <trans-unit id="3b553336a2ed0371927e0210cc490999d6f454c6" translate="yes" xml:space="preserve">
          <source>To turn off profiling entirely, pass rate 0. To just read the current rate, pass rate &amp;lt; 0. (For n&amp;gt;1 the details of sampling may change.)</source>
          <target state="translated">要完全关闭性能分析，请通过率0。要仅读取当前速率，请通过率&amp;lt;0。（对于n&amp;gt; 1，采样的详细信息可能会更改。）</target>
        </trans-unit>
        <trans-unit id="ec0c40fcb609291204c17f8d3e9e4a0cf0fb716d" translate="yes" xml:space="preserve">
          <source>To unmarshal JSON into a pointer, Unmarshal first handles the case of the JSON being the JSON literal null. In that case, Unmarshal sets the pointer to nil. Otherwise, Unmarshal unmarshals the JSON into the value pointed at by the pointer. If the pointer is nil, Unmarshal allocates a new value for it to point to.</source>
          <target state="translated">要将JSON解压缩成一个指针,Unmarshal首先要处理JSON是JSON文字空的情况。在这种情况下,Unmarshal会将指针设置为nil。否则,Unmarshal会将JSON解马尔什化为指针指向的值。如果指针为nil,Unmarshal为其分配一个新的值。</target>
        </trans-unit>
        <trans-unit id="9ec7dbd6621b41728144a0cd3fc2c36f64948e68" translate="yes" xml:space="preserve">
          <source>To unmarshal JSON into a struct, Unmarshal matches incoming object keys to the keys used by Marshal (either the struct field name or its tag), preferring an exact match but also accepting a case-insensitive match. By default, object keys which don't have a corresponding struct field are ignored (see Decoder.DisallowUnknownFields for an alternative).</source>
          <target state="translated">为了将JSON解压缩成结构体,Unmarshal将传入的对象键与Marshal使用的键(结构体字段名或它的标签)进行匹配,喜欢完全匹配,但也接受不区分大小写的匹配。默认情况下,没有对应的结构体字段的对象键会被忽略(参见Decoder.DisallowUnknownFields获取替代方案)。</target>
        </trans-unit>
        <trans-unit id="a6bdbb20d4135a3bc4596a68aa8c2c34912d504d" translate="yes" xml:space="preserve">
          <source>To unmarshal JSON into a value implementing the Unmarshaler interface, Unmarshal calls that value's UnmarshalJSON method, including when the input is a JSON null. Otherwise, if the value implements encoding.TextUnmarshaler and the input is a JSON quoted string, Unmarshal calls that value's UnmarshalText method with the unquoted form of the string.</source>
          <target state="translated">要将JSON解马尔什到一个实现Unmarshaler接口的值中,Unmarshal调用该值的UnmarshalJSON方法,包括当输入是JSON null时。否则,如果值实现了encoding.TextUnmarshaler,并且输入是JSON引号的字符串,Unmarshal就用字符串的未引号形式调用该值的UnmarshalText方法。</target>
        </trans-unit>
        <trans-unit id="c66b5ce0cf55557d8e9fd777ec15355bade4e117" translate="yes" xml:space="preserve">
          <source>To unmarshal JSON into an interface value, Unmarshal stores one of these in the interface value:</source>
          <target state="translated">要将JSON解读成一个接口值,Unmarshal会在接口值中存储其中一个。</target>
        </trans-unit>
        <trans-unit id="94c1b420cdca6fe4940f209d9a41f19875bfb4e7" translate="yes" xml:space="preserve">
          <source>To unmarshal a JSON array into a Go array, Unmarshal decodes JSON array elements into corresponding Go array elements. If the Go array is smaller than the JSON array, the additional JSON array elements are discarded. If the JSON array is smaller than the Go array, the additional Go array elements are set to zero values.</source>
          <target state="translated">要将JSON数组拆解为Go数组,Unmarshal将JSON数组元素解码为相应的Go数组元素。如果Go数组小于JSON数组,那么额外的JSON数组元素将被丢弃。如果JSON数组小于Go数组,则额外的Go数组元素被设置为零值。</target>
        </trans-unit>
        <trans-unit id="ed4bdd964a47161b70a00bdaa7dc00eb114dff57" translate="yes" xml:space="preserve">
          <source>To unmarshal a JSON array into a slice, Unmarshal resets the slice length to zero and then appends each element to the slice. As a special case, to unmarshal an empty JSON array into a slice, Unmarshal replaces the slice with a new empty slice.</source>
          <target state="translated">要将一个JSON数组解马尔什化为一个分片,Unmarshal将分片长度重置为零,然后将每个元素追加到分片中。作为一种特殊情况,如果要将一个空的JSON数组解马尔什化为一个分片,Unmarshal会用一个新的空分片来替换这个分片。</target>
        </trans-unit>
        <trans-unit id="007b32960f68d5d51b318bb76ca9ea0286f4126d" translate="yes" xml:space="preserve">
          <source>To unmarshal a JSON object into a map, Unmarshal first establishes a map to use. If the map is nil, Unmarshal allocates a new map. Otherwise Unmarshal reuses the existing map, keeping existing entries. Unmarshal then stores key-value pairs from the JSON object into the map. The map's key type must either be a string, an integer, or implement encoding.TextUnmarshaler.</source>
          <target state="translated">要将一个JSON对象拆解成地图,Unmarshal首先要建立一个要使用的地图。如果地图是nil,Unmarshal会分配一个新的地图。否则,Unmarshal会重新使用现有的地图,保留现有的条目。然后Unmarshal将JSON对象中的键值对存储到map中。地图的键类型必须是字符串、整数或实现 encoding.TextUnmarshaler。</target>
        </trans-unit>
        <trans-unit id="6d6fc53f4b0d33aa877b6d747d45b96f410c47fc" translate="yes" xml:space="preserve">
          <source>To unmarshal a JSON object into a map, Unmarshal first establishes a map to use. If the map is nil, Unmarshal allocates a new map. Otherwise Unmarshal reuses the existing map, keeping existing entries. Unmarshal then stores key-value pairs from the JSON object into the map. The map's key type must either be any string type, an integer, implement json.Unmarshaler, or implement encoding.TextUnmarshaler.</source>
          <target state="translated">要将一个JSON对象拆解成地图,Unmarshal首先要建立一个要使用的地图。如果地图是nil,Unmarshal会分配一个新的地图。否则,Unmarshal会重新使用现有的地图,保留现有的条目。然后Unmarshal将JSON对象中的键值对存储到map中。地图的键类型必须是任何字符串类型、整数、实现json.Unmarshaler或实现encoding.TextUnmarshaler。</target>
        </trans-unit>
        <trans-unit id="b87bf4d25ca4624c96c72d4062afc898f384fa73" translate="yes" xml:space="preserve">
          <source>To use a Pipeline p to manage multiple clients on a connection, each client should run:</source>
          <target state="translated">要使用Pipeline p来管理一个连接上的多个客户端,每个客户端都应该运行。</target>
        </trans-unit>
        <trans-unit id="f6369ce890fdc06aa42e060bacdc465b9893f8d9" translate="yes" xml:space="preserve">
          <source>To use a fixed length slice, or a preallocated one, use FillBytes.</source>
          <target state="translated">要使用固定长度的片断,或预分配的片断,使用FillBytes。</target>
        </trans-unit>
        <trans-unit id="800eefdd201759f89cf9257524a524d86be67a56" translate="yes" xml:space="preserve">
          <source>To use an existing prepared statement on this transaction, see Tx.Stmt.</source>
          <target state="translated">若要使用现有的已编制的报表进行交易,请参见Tx.Stmt.</target>
        </trans-unit>
        <trans-unit id="2a7b3f715f9964aa312835dc3f2ae71cd3041225" translate="yes" xml:space="preserve">
          <source>To use an fs.FS implementation, use http.FS to convert it:</source>
          <target state="translated">要使用fs.FS实现,请使用http.FS来转换。</target>
        </trans-unit>
        <trans-unit id="0c3bf1a32c9b769f727db4118e0b83ca4bb4efa4" translate="yes" xml:space="preserve">
          <source>To use gobs, create an Encoder and present it with a series of data items as values or addresses that can be dereferenced to values. The Encoder makes sure all type information is sent before it is needed. At the receive side, a Decoder retrieves values from the encoded stream and unpacks them into local variables.</source>
          <target state="translated">要使用gobs,请创建一个Encoder,并将一系列数据项以值或地址的形式呈现给它,这些值或地址可以被导出引用到值。Encoder确保所有的类型信息在需要之前被发送。在接收端,解码器从编码流中检索值,并将它们解包到本地变量中。</target>
        </trans-unit>
        <trans-unit id="8212c55a0bf9e12d2e296b39237ee5f72cae9d11" translate="yes" xml:space="preserve">
          <source>To use pprof, link this package into your program:</source>
          <target state="translated">要使用pprof,请将这个软件包链接到你的程序中。</target>
        </trans-unit>
        <trans-unit id="5c29e8288fd1ed9e073fe203fb55fbea12d062de" translate="yes" xml:space="preserve">
          <source>To use the operating system's file system implementation, use http.Dir:</source>
          <target state="translated">要使用操作系统的文件系统实现,使用http.Dir。</target>
        </trans-unit>
        <trans-unit id="467272919dc8f37262b26b52d65afd618589f7ff" translate="yes" xml:space="preserve">
          <source>To view all available profiles, open &lt;a href=&quot;http://localhost:6060/debug/pprof/&quot;&gt;http://localhost:6060/debug/pprof/&lt;/a&gt; in your browser.</source>
          <target state="translated">要查看所有可用的配置文件，请在浏览器中打开&lt;a href=&quot;http://localhost:6060/debug/pprof/&quot;&gt;http：// localhost：6060 / debug / pprof /&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4193fe2d5f7ce0c7cb324cbe3968e7d5bd540d92" translate="yes" xml:space="preserve">
          <source>To write a new test suite, create a file whose name ends _test.go that contains the TestXxx functions as described here. Put the file in the same package as the one being tested. The file will be excluded from regular package builds but will be included when the &quot;go test&quot; command is run. For more detail, run &quot;go help test&quot; and &quot;go help testflag&quot;.</source>
          <target state="translated">要编写一个新的测试套件,创建一个以_test.go结尾的文件,其中包含TestXxx函数,如这里所述。把这个文件放到和被测试的包一样的包里。这个文件将被排除在常规的软件包构建之外,但是当运行 &quot;go test&quot; 命令时,这个文件将被包含在内。更多细节,请运行 &quot;go help test&quot; 和 &quot;go help testflag&quot;。</target>
        </trans-unit>
        <trans-unit id="f1229c7d06cb687b015bf9729398a1b9b76a455a" translate="yes" xml:space="preserve">
          <source>To write a new test suite, create a file whose name ends _test.go that contains the TestXxx functions as described here. Put the file in the same package as the one being tested. The file will be excluded from regular package builds but will be included when the &amp;ldquo;go test&amp;rdquo; command is run. For more detail, run &amp;ldquo;go help test&amp;rdquo; and &amp;ldquo;go help testflag&amp;rdquo;.</source>
          <target state="translated">要编写新的测试套件，请创建一个名称以_test.go结尾的文件，其中包含TestXxx函数，如此处所述。将文件与要测试的文件放在同一软件包中。该文件将从常规软件包生成中排除，但在运行&amp;ldquo; go test&amp;rdquo;命令时将包括在内。有关更多详细信息，请运行&amp;ldquo; go help test&amp;rdquo;和&amp;ldquo; go help testflag&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="2392dbedc5657df0a5a8c5b158593f759c811858" translate="yes" xml:space="preserve">
          <source>To16 converts the IP address ip to a 16-byte representation. If ip is not an IP address (it is the wrong length), To16 returns nil.</source>
          <target state="translated">To16 将 IP 地址 ip 转换为 16 字节的表示形式。如果ip不是一个IP地址(长度不对),To16返回nil。</target>
        </trans-unit>
        <trans-unit id="4294dda7ebb07f9702b0ce5cc1cb8bbf6e004822" translate="yes" xml:space="preserve">
          <source>To4 converts the IPv4 address ip to a 4-byte representation. If ip is not an IPv4 address, To4 returns nil.</source>
          <target state="translated">To4 将 IPv4 地址 ip 转换为一个 4 字节的表示形式,如果 ip 不是 IPv4 地址,To4 返回 nil。如果ip不是IPv4地址,To4返回nil。</target>
        </trans-unit>
        <trans-unit id="7deadbf704990f79d3e4df9686f8846e15431131" translate="yes" xml:space="preserve">
          <source>ToComplex converts x to a Complex value if x is representable as a Complex. Otherwise it returns an Unknown.</source>
          <target state="translated">如果x可以表示为复数,ToComplex将x转换为一个复数值,否则返回一个未知值。否则返回一个未知值。</target>
        </trans-unit>
        <trans-unit id="95e3b1fabb27004c6322f401e410b77c8beecafb" translate="yes" xml:space="preserve">
          <source>ToFloat converts x to a Float value if x is representable as a Float. Otherwise it returns an Unknown.</source>
          <target state="translated">如果x可表示为Float,ToFloat将x转换为Float值。否则它返回一个未知值。</target>
        </trans-unit>
        <trans-unit id="f5e30e0ab3c38971ff0a23a0823ee7ab2da27587" translate="yes" xml:space="preserve">
          <source>ToHTML converts comment text to formatted HTML. The comment was prepared by DocReader, so it is known not to have leading, trailing blank lines nor to have trailing spaces at the end of lines. The comment markers have already been removed.</source>
          <target state="translated">ToHTML将注释文本转换为格式化的HTML。该注释是由DocReader编写的,所以已知它没有前导、尾部的空行,也没有行末的尾部空格。注释标记已经被删除。</target>
        </trans-unit>
        <trans-unit id="2f4af6e587a0b093dcea21d741f457946dac2539" translate="yes" xml:space="preserve">
          <source>ToInt converts x to an Int value if x is representable as an Int. Otherwise it returns an Unknown.</source>
          <target state="translated">如果x可以表示为Int,则ToInt将x转换为Int值。否则返回一个未知值。</target>
        </trans-unit>
        <trans-unit id="2458b21542ecbc0f90f413b7ee46521686d711b0" translate="yes" xml:space="preserve">
          <source>ToLower</source>
          <target state="translated">ToLower</target>
        </trans-unit>
        <trans-unit id="6fec192e916332e15759b9ef1699226d11bdd209" translate="yes" xml:space="preserve">
          <source>ToLower maps the rune to lower case giving priority to the special mapping.</source>
          <target state="translated">ToLower将符文映射为小写,优先考虑特殊映射。</target>
        </trans-unit>
        <trans-unit id="0d0c9cd1331838718de8a67a4fe3f8edaf0bf598" translate="yes" xml:space="preserve">
          <source>ToLower maps the rune to lower case.</source>
          <target state="translated">ToLower将符文映射为小写。</target>
        </trans-unit>
        <trans-unit id="0ad2eff81c68ba7feeec4169aa737e669765ecb3" translate="yes" xml:space="preserve">
          <source>ToLower returns a copy of the byte slice s with all Unicode letters mapped to their lower case.</source>
          <target state="translated">ToLower 返回所有 Unicode 字母映射为小写的字节片断 s 的副本。</target>
        </trans-unit>
        <trans-unit id="9ce8fb31583c9a3f9db4dda94a7dc14fcb01df77" translate="yes" xml:space="preserve">
          <source>ToLower returns s with all Unicode letters mapped to their lower case.</source>
          <target state="translated">ToLower 返回所有 Unicode 字母映射为小写的 s。</target>
        </trans-unit>
        <trans-unit id="7c6c5994143b17fa29690098b9cf21d8ab0c9626" translate="yes" xml:space="preserve">
          <source>ToLowerSpecial</source>
          <target state="translated">ToLowerSpecial</target>
        </trans-unit>
        <trans-unit id="a0c9710a46fb772958369a0897c7471714aeeeb8" translate="yes" xml:space="preserve">
          <source>ToLowerSpecial returns a copy of the string s with all Unicode letters mapped to their lower case using the case mapping specified by c.</source>
          <target state="translated">ToLowerSpecial返回字符串s的副本,并使用c指定的大小写映射将所有Unicode字母映射为小写。</target>
        </trans-unit>
        <trans-unit id="cb046f134facad4d83f3df18153937dc0992ea81" translate="yes" xml:space="preserve">
          <source>ToLowerSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their lower case, giving priority to the special casing rules.</source>
          <target state="translated">ToLowerSpecial将s视为UTF-8编码的字节,并返回一个包含所有Unicode字母映射为小写字母的副本,优先考虑特殊的编码规则。</target>
        </trans-unit>
        <trans-unit id="494e4ed4c22e6b9204664a8671089fb351d285ee" translate="yes" xml:space="preserve">
          <source>ToRDNSequence converts n into a single RDNSequence. The following attributes are encoded as multi-value RDNs:</source>
          <target state="translated">ToRDNSequence 将 n 转换为单个 RDNSequence。以下属性被编码为多值RDN。</target>
        </trans-unit>
        <trans-unit id="2915308ca78a335773afea42473f5f868e85f100" translate="yes" xml:space="preserve">
          <source>ToSlash returns the result of replacing each separator character in path with a slash ('/') character. Multiple separators are replaced by multiple slashes.</source>
          <target state="translated">ToSlash 返回用斜线('/')替换路径中每个分隔符的结果。多个分隔符会被多个斜线代替。</target>
        </trans-unit>
        <trans-unit id="ce9610dd835f1269c70383a5f4c28b5a0b063015" translate="yes" xml:space="preserve">
          <source>ToText prepares comment text for presentation in textual output. It wraps paragraphs of text to width or fewer Unicode code points and then prefixes each line with the indent. In preformatted sections (such as program text), it prefixes each non-blank line with preIndent.</source>
          <target state="translated">ToText 为文本输出中的注释文本做准备。它将文本段落包装成宽度或更少的Unicode码点,然后在每行前加上缩进。在预格式化的部分(如程序文本)中,它将每一行非空白行前缀为preIndent。</target>
        </trans-unit>
        <trans-unit id="687882b6dd58f630b4dc72d2b748bc2e5e517506" translate="yes" xml:space="preserve">
          <source>ToTitle</source>
          <target state="translated">ToTitle</target>
        </trans-unit>
        <trans-unit id="16626ca02836f3e96b71ac083f67d856672bee6a" translate="yes" xml:space="preserve">
          <source>ToTitle maps the rune to title case giving priority to the special mapping.</source>
          <target state="translated">ToTitle将符文映射到标题案,优先考虑特殊映射。</target>
        </trans-unit>
        <trans-unit id="82652cb33ebff96d0745bbb70b7b14b2b4f648b7" translate="yes" xml:space="preserve">
          <source>ToTitle maps the rune to title case.</source>
          <target state="translated">ToTitle将符文映射到标题案。</target>
        </trans-unit>
        <trans-unit id="b6339ce57388ab9579ed7dea7397386892cd79b3" translate="yes" xml:space="preserve">
          <source>ToTitle returns a copy of the string s with all Unicode letters mapped to their Unicode title case.</source>
          <target state="translated">ToTitle返回字符串s的副本,所有Unicode字母都映射到Unicode标题大小写。</target>
        </trans-unit>
        <trans-unit id="7c8bdbfdcd905744bd6bd92b5f2c2fe7b0b2a605" translate="yes" xml:space="preserve">
          <source>ToTitle treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their title case.</source>
          <target state="translated">ToTitle将s视为UTF-8编码的字节,并返回一个包含所有Unicode字母映射到标题大小写的副本。</target>
        </trans-unit>
        <trans-unit id="a7e031c3da9f939af57fa1eda658027190b07385" translate="yes" xml:space="preserve">
          <source>ToTitleSpecial</source>
          <target state="translated">ToTitleSpecial</target>
        </trans-unit>
        <trans-unit id="6c2252d5e081e10993ad66199a6ce0f9c88000da" translate="yes" xml:space="preserve">
          <source>ToTitleSpecial returns a copy of the string s with all Unicode letters mapped to their Unicode title case, giving priority to the special casing rules.</source>
          <target state="translated">ToTitleSpecial返回字符串s的副本,其中所有Unicode字母都被映射到Unicode标题大小写中,优先考虑特殊的编码规则。</target>
        </trans-unit>
        <trans-unit id="03ad764cc2cf6e71773b140dd2607d85f903d19e" translate="yes" xml:space="preserve">
          <source>ToTitleSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their title case, giving priority to the special casing rules.</source>
          <target state="translated">ToTitleSpecial将s视为UTF-8编码的字节,并返回一个包含所有Unicode字母映射到其标题大小写的副本,优先考虑特殊的编码规则。</target>
        </trans-unit>
        <trans-unit id="0c72db5394ee29e5b12a191ab1a0f08579c43c0b" translate="yes" xml:space="preserve">
          <source>ToUpper</source>
          <target state="translated">ToUpper</target>
        </trans-unit>
        <trans-unit id="8830c3933f2751182fd45204e5ac41041c190ab0" translate="yes" xml:space="preserve">
          <source>ToUpper maps the rune to upper case giving priority to the special mapping.</source>
          <target state="translated">ToUpper将符文映射为大写,优先考虑特殊映射。</target>
        </trans-unit>
        <trans-unit id="9762b6a1a0f8f68d12efc0853373d81b1198caf9" translate="yes" xml:space="preserve">
          <source>ToUpper maps the rune to upper case.</source>
          <target state="translated">ToUpper将符文映射为大写。</target>
        </trans-unit>
        <trans-unit id="587e23bede12f256b7a2b187d202dc77575c043c" translate="yes" xml:space="preserve">
          <source>ToUpper returns a copy of the byte slice s with all Unicode letters mapped to their upper case.</source>
          <target state="translated">ToUpper 返回所有 Unicode 字母映射为大写的字节片断 s 的副本。</target>
        </trans-unit>
        <trans-unit id="1567cbaa93e2803c0387b5e052b94febf77b0dce" translate="yes" xml:space="preserve">
          <source>ToUpper returns s with all Unicode letters mapped to their upper case.</source>
          <target state="translated">ToUpper 返回所有 Unicode 字母映射为大写的 s。</target>
        </trans-unit>
        <trans-unit id="e8e18cf71c085c852139f777c3a777629eaba1d4" translate="yes" xml:space="preserve">
          <source>ToUpperSpecial</source>
          <target state="translated">ToUpperSpecial</target>
        </trans-unit>
        <trans-unit id="ca298ca7f1f797ffc04335283b821c4509371407" translate="yes" xml:space="preserve">
          <source>ToUpperSpecial returns a copy of the string s with all Unicode letters mapped to their upper case using the case mapping specified by c.</source>
          <target state="translated">ToUpperSpecial返回字符串s的副本,并使用c指定的大小写映射将所有Unicode字母映射为大写。</target>
        </trans-unit>
        <trans-unit id="e092426a213e149b750e5c739fd48245f35d6f1d" translate="yes" xml:space="preserve">
          <source>ToUpperSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their upper case, giving priority to the special casing rules.</source>
          <target state="translated">ToUpperSpecial将s视为UTF-8编码的字节,并返回一个包含所有Unicode字母映射为大写字母的副本,优先考虑特殊的编码规则。</target>
        </trans-unit>
        <trans-unit id="2918f3c11590ab69ac359dd26f3078e378d4433f" translate="yes" xml:space="preserve">
          <source>ToValidUTF8 returns a copy of the string s with each run of invalid UTF-8 byte sequences replaced by the replacement string, which may be empty.</source>
          <target state="translated">ToValidUTF8返回字符串s的副本,每运行一次无效的UTF-8字节序列就被替换字符串所取代,该字符串可能是空的。</target>
        </trans-unit>
        <trans-unit id="8ddb5599f330dcf8a14e657f65440d11567b1275" translate="yes" xml:space="preserve">
          <source>ToValidUTF8 treats s as UTF-8-encoded bytes and returns a copy with each run of bytes representing invalid UTF-8 replaced with the bytes in replacement, which may be empty.</source>
          <target state="translated">ToValidUTF8将s视为UTF-8编码的字节,并返回一个副本,每运行一次代表无效UTF-8的字节就替换成替换中的字节,替换中的字节可能是空的。</target>
        </trans-unit>
        <trans-unit id="0e6e43d719b59d2f4b6d64b0d7506414e902ac66" translate="yes" xml:space="preserve">
          <source>Token expands self-closing elements such as &amp;lt;br/&amp;gt; into separate start and end elements returned by successive calls.</source>
          <target state="translated">令牌将诸如&amp;lt;br/&amp;gt;之类的自闭合元素扩展为由连续调用返回的单独的开始和结束元素。</target>
        </trans-unit>
        <trans-unit id="76c580b187cf47d391aca0669ed50d6bdc842bd1" translate="yes" xml:space="preserve">
          <source>Token guarantees that the StartElement and EndElement tokens it returns are properly nested and matched: if Token encounters an unexpected end element or EOF before all expected end elements, it will return an error.</source>
          <target state="translated">Token保证它返回的StartElement和EndElement标记是正确嵌套和匹配的:如果Token遇到一个意外的结束元素或在所有预期的结束元素之前的EOF,它将返回一个错误。</target>
        </trans-unit>
        <trans-unit id="20226a10555b22d829b042743665e60ca5ccfcef" translate="yes" xml:space="preserve">
          <source>Token guarantees that the delimiters [ ] { } it returns are properly nested and matched: if Token encounters an unexpected delimiter in the input, it will return an error.</source>
          <target state="translated">Token 保证它返回的定界符[]{}是正确嵌套和匹配的:如果 Token 在输入中遇到一个意外的定界符,它将返回一个错误。</target>
        </trans-unit>
        <trans-unit id="d280a9431f5d23758a555c6128dd19caf82e90f5" translate="yes" xml:space="preserve">
          <source>Token implements XML name spaces as described by &lt;a href=&quot;https://www.w3.org/TR/REC-xml-names/&quot;&gt;https://www.w3.org/TR/REC-xml-names/&lt;/a&gt;. Each of the Name structures contained in the Token has the Space set to the URL identifying its name space when known. If Token encounters an unrecognized name space prefix, it uses the prefix as the Space rather than report an error.</source>
          <target state="translated">令牌实现了&lt;a href=&quot;https://www.w3.org/TR/REC-xml-names/&quot;&gt;https://www.w3.org/TR/REC-xml-names/中&lt;/a&gt;描述的XML名称空间。令牌中包含的每个名称结构都有一个设置为URL的空格，以便在知道时标识其名称空间。如果令牌遇到无法识别的名称空间前缀，它将使用该前缀作为空格，而不是报告错误。</target>
        </trans-unit>
        <trans-unit id="3daac00da8a20a3986aa0fc3ba367725df5511ad" translate="yes" xml:space="preserve">
          <source>Token is the set of lexical tokens of the Go programming language.</source>
          <target state="translated">Token是围棋编程语言的词性标记集。</target>
        </trans-unit>
        <trans-unit id="347b518b7ad14bbb5cbe2525a0e1cce83a18759e" translate="yes" xml:space="preserve">
          <source>Token returns the next JSON token in the input stream. At the end of the input stream, Token returns nil, io.EOF.</source>
          <target state="translated">Token返回输入流中的下一个JSON token,在输入流结束时,Token返回nil,io.EOF。在输入流结束时,Token返回nil,io.EOF。</target>
        </trans-unit>
        <trans-unit id="fb460c5b7cbda3e107ef11644b412428d80a074a" translate="yes" xml:space="preserve">
          <source>Token returns the next XML token in the input stream. At the end of the input stream, Token returns nil, io.EOF.</source>
          <target state="translated">Token返回输入流中的下一个XML token,在输入流结束时,Token返回nil,io.EOF。在输入流结束时,Token返回nil,io.EOF。</target>
        </trans-unit>
        <trans-unit id="1f5c5f661288844b6f2ecd574998016319ee9039" translate="yes" xml:space="preserve">
          <source>TokenString returns a printable string for a token or Unicode character.</source>
          <target state="translated">TokenString 返回一个可打印的标记或Unicode字符的字符串。</target>
        </trans-unit>
        <trans-unit id="1a94c716310bd537564c947b302962f8f4ba3d71" translate="yes" xml:space="preserve">
          <source>TokenText returns the string corresponding to the most recently scanned token. Valid after calling Scan and in calls of Scanner.Error.</source>
          <target state="translated">TokenText 返回最近扫描的标记对应的字符串。在调用Scan后和调用Scanner.Error.TokenText时有效。</target>
        </trans-unit>
        <trans-unit id="a7a728d87ab600f19a872de7d10dd426fc51a410" translate="yes" xml:space="preserve">
          <source>ToolDir is the directory containing build tools.</source>
          <target state="translated">ToolDir是包含构建工具的目录。</target>
        </trans-unit>
        <trans-unit id="4fa8cc860c52b268dc6a3adcde7305e9415db5bb" translate="yes" xml:space="preserve">
          <source>Tools</source>
          <target state="translated">Tools</target>
        </trans-unit>
        <trans-unit id="84f632ebde53766b4762c1e662046a0bdb1f9bee" translate="yes" xml:space="preserve">
          <source>Trace responds with the execution trace in binary form. Tracing lasts for duration specified in seconds GET parameter, or for 1 second if not specified. The package initialization registers it as /debug/pprof/trace.</source>
          <target state="translated">跟踪以二进制形式响应执行跟踪。追踪的持续时间用GET参数second指定,如果没有指定则为1秒。软件包初始化时将其注册为/debug/pprof/trace。</target>
        </trans-unit>
        <trans-unit id="37fcf61c233a1ae946b84a69b2de57281c31900c" translate="yes" xml:space="preserve">
          <source>Tracing runtime activities</source>
          <target state="translated">追踪运行时活动</target>
        </trans-unit>
        <trans-unit id="bf930f74e883c038922957814259a08b1e5e21b8" translate="yes" xml:space="preserve">
          <source>TrailerPrefix is a magic prefix for ResponseWriter.Header map keys that, if present, signals that the map entry is actually for the response trailers, and not the response headers. The prefix is stripped after the ServeHTTP call finishes and the values are sent in the trailers.</source>
          <target state="translated">TrailerPrefix是ResponseWriter.Header映射键的一个神奇的前缀,如果存在,则表明该映射条目实际上是针对响应拖车的,而不是响应头。这个前缀会在ServeHTTP调用完成后被剥离,并在拖车中发送值。</target>
        </trans-unit>
        <trans-unit id="d08af63de6fd07c70bf3724749899391ccd80f36" translate="yes" xml:space="preserve">
          <source>TrailingZeroBits returns the number of consecutive least significant zero bits of |x|.</source>
          <target state="translated">TrailingZeroBits 返回 |x| 的连续最小有效零位数。</target>
        </trans-unit>
        <trans-unit id="173da913d8c53620762557efaa7f685234fe0888" translate="yes" xml:space="preserve">
          <source>TrailingZeros returns the number of trailing zero bits in x; the result is UintSize for x == 0.</source>
          <target state="translated">TrailingZeros 返回 x 中的尾部零位数;对于 x ==0,结果是 UintSize。</target>
        </trans-unit>
        <trans-unit id="3880be13b458ed7d8fd6226152f09a84df60affe" translate="yes" xml:space="preserve">
          <source>TrailingZeros16</source>
          <target state="translated">TrailingZeros16</target>
        </trans-unit>
        <trans-unit id="ac0e8b17c92ec54246a916c7c60a5898e47d2440" translate="yes" xml:space="preserve">
          <source>TrailingZeros16 returns the number of trailing zero bits in x; the result is 16 for x == 0.</source>
          <target state="translated">TrailingZeros16 返回x中的尾部零位数;对于x ==0,结果是16。</target>
        </trans-unit>
        <trans-unit id="9ccb48d1009c49f2458e70054ffb06de2c2e52b1" translate="yes" xml:space="preserve">
          <source>TrailingZeros32</source>
          <target state="translated">TrailingZeros32</target>
        </trans-unit>
        <trans-unit id="ef12b2bd72258ab1ea24487faaf1b36b6624d53b" translate="yes" xml:space="preserve">
          <source>TrailingZeros32 returns the number of trailing zero bits in x; the result is 32 for x == 0.</source>
          <target state="translated">TrailingZeros32 返回x中的尾部零位数;对于x ==0,结果是32。</target>
        </trans-unit>
        <trans-unit id="8645dda5fc4ccfbadfe816f019759dd903a6b384" translate="yes" xml:space="preserve">
          <source>TrailingZeros64</source>
          <target state="translated">TrailingZeros64</target>
        </trans-unit>
        <trans-unit id="9c1806ac56295eeda1305a5c016e361813241700" translate="yes" xml:space="preserve">
          <source>TrailingZeros64 returns the number of trailing zero bits in x; the result is 64 for x == 0.</source>
          <target state="translated">TrailingZeros64 返回x中的尾部零位数;对于x ==0,结果是64。</target>
        </trans-unit>
        <trans-unit id="56b19e298a41e007826d31fb347a4fad087efb44" translate="yes" xml:space="preserve">
          <source>TrailingZeros8</source>
          <target state="translated">TrailingZeros8</target>
        </trans-unit>
        <trans-unit id="a51f3a70d56ba40f5381588670a32ee940f76014" translate="yes" xml:space="preserve">
          <source>TrailingZeros8 returns the number of trailing zero bits in x; the result is 8 for x == 0.</source>
          <target state="translated">TrailingZeros8返回x中的尾部零位数;对于x==0,结果是8。</target>
        </trans-unit>
        <trans-unit id="c46e526f87b0902843d5c82001fbd44e74d2f2d7" translate="yes" xml:space="preserve">
          <source>Transport is an implementation of RoundTripper that supports HTTP, HTTPS, and HTTP proxies (for either HTTP or HTTPS with CONNECT).</source>
          <target state="translated">Transport是RoundTripper的一个实现,支持HTTP、HTTPS和HTTP代理(对于HTTP或HTTPS与CONNECT)。</target>
        </trans-unit>
        <trans-unit id="28030ddb48df392e29b838aa75a73353cb5390cf" translate="yes" xml:space="preserve">
          <source>Transport only retries a request upon encountering a network error if the request is idempotent and either has no body or has its Request.GetBody defined. HTTP requests are considered idempotent if they have HTTP methods GET, HEAD, OPTIONS, or TRACE; or if their Header map contains an &quot;Idempotency-Key&quot; or &quot;X-Idempotency-Key&quot; entry. If the idempotency key value is a zero-length slice, the request is treated as idempotent but the header is not sent on the wire.</source>
          <target state="translated">如果请求是idempotent的,并且没有body或者定义了Request.GetBody,那么Transport只会在遇到网络错误时重试请求。如果HTTP请求有HTTP方法GET、HEAD、OPTIONS或TRACE,或者它们的Header映射包含 &quot;Idempotency-Key &quot;或 &quot;X-Idempotency-Key &quot;条目,则被认为是幂等的。如果idempotency key的值是一个零长度的分片,那么该请求将被视为idempotent,但线上不会发送头。</target>
        </trans-unit>
        <trans-unit id="3a7dd5c9993ccdafc8353b9b9fef9d118c35957f" translate="yes" xml:space="preserve">
          <source>Transport only retries a request upon encountering a network error if the request is idempotent and either has no body or has its Request.GetBody defined. HTTP requests are considered idempotent if they have HTTP methods GET, HEAD, OPTIONS, or TRACE; or if their Header map contains an &quot;Idempotency-Key&quot; or &quot;X-Idempotency-Key&quot; entry. If the idempotency key value is an zero-length slice, the request is treated as idempotent but the header is not sent on the wire.</source>
          <target state="translated">如果请求是idempotent的,并且没有body或者定义了Request.GetBody,那么Transport只会在遇到网络错误时重试请求。如果HTTP请求有HTTP方法GET、HEAD、OPTIONS或TRACE,或者它们的Header映射包含 &quot;Idempotency-Key &quot;或 &quot;X-Idempotency-Key &quot;条目,则被认为是幂等的。如果idempotency key的值是一个零长度的分片,那么该请求将被视为idempotent,但线上不会发送头。</target>
        </trans-unit>
        <trans-unit id="a83654a5778fc158c90c291f8461263d34090fc9" translate="yes" xml:space="preserve">
          <source>Transport uses HTTP/1.1 for HTTP URLs and either HTTP/1.1 or HTTP/2 for HTTPS URLs, depending on whether the server supports HTTP/2, and how the Transport is configured. The DefaultTransport supports HTTP/2. To explicitly enable HTTP/2 on a transport, use golang.org/x/net/http2 and call ConfigureTransport. See the package docs for more about HTTP/2.</source>
          <target state="translated">Transport对HTTP URL使用HTTP/1.1,对HTTPS URL使用HTTP/1.1或HTTP/2,这取决于服务器是否支持HTTP/2,以及Transport的配置方式。DefaultTransport支持HTTP/2。要在传输中明确启用 HTTP/2,请使用 golang.org/x/net/http2 并调用 ConfigureTransport。有关HTTP/2的更多信息,请参见软件包文档。</target>
        </trans-unit>
        <trans-unit id="5cba3ebebe9967d6b406fbd61cc05ffea9ddcf56" translate="yes" xml:space="preserve">
          <source>Transports should be reused instead of created as needed. Transports are safe for concurrent use by multiple goroutines.</source>
          <target state="translated">移植应该被重复使用,而不是根据需要创建。移植是安全的,可以被多个goroutine同时使用。</target>
        </trans-unit>
        <trans-unit id="cf5547182a53dd7a581affea62258ee59e262b85" translate="yes" xml:space="preserve">
          <source>Tree is the representation of a single parsed template.</source>
          <target state="translated">树是单个解析模板的表示。</target>
        </trans-unit>
        <trans-unit id="0266abd25371ad4670b041dda4dc487ed199d641" translate="yes" xml:space="preserve">
          <source>Trim</source>
          <target state="translated">Trim</target>
        </trans-unit>
        <trans-unit id="abb910d5bd0bd319cf1d5ef7ad6a5112dc6c0823" translate="yes" xml:space="preserve">
          <source>Trim returns a slice of the string s with all leading and trailing Unicode code points contained in cutset removed.</source>
          <target state="translated">Trim返回字符串s的一个片断,其中包含在cutet中的所有前导和后导Unicode码点。</target>
        </trans-unit>
        <trans-unit id="4f07669cc579ec14df811b3ca5fc72fde4f78f58" translate="yes" xml:space="preserve">
          <source>Trim returns a subslice of s by slicing off all leading and trailing UTF-8-encoded code points contained in cutset.</source>
          <target state="translated">Trim通过切断cutet中包含的所有前导和尾部UTF-8编码的代码点来返回s的子片。</target>
        </trans-unit>
        <trans-unit id="ba1962dfeb4e006658709dd72ff841213f7d1db0" translate="yes" xml:space="preserve">
          <source>TrimBytes returns b without leading and trailing ASCII space.</source>
          <target state="translated">TrimBytes 返回 b,不含前导和尾部 ASCII 空间。</target>
        </trans-unit>
        <trans-unit id="a48987784fdcef3e797c48099ede26a7260db2de" translate="yes" xml:space="preserve">
          <source>TrimFunc</source>
          <target state="translated">TrimFunc</target>
        </trans-unit>
        <trans-unit id="03343404f4f9dd2a23fda87bf2a4805f3806059d" translate="yes" xml:space="preserve">
          <source>TrimFunc returns a slice of the string s with all leading and trailing Unicode code points c satisfying f(c) removed.</source>
          <target state="translated">TrimFunc 返回字符串 s 的一个片断,其中包含所有满足 f(c)的前导和尾部 Unicode 码点。</target>
        </trans-unit>
        <trans-unit id="625b4a484772db3f9992725f710f3d189c47d0db" translate="yes" xml:space="preserve">
          <source>TrimFunc returns a subslice of s by slicing off all leading and trailing UTF-8-encoded code points c that satisfy f(c).</source>
          <target state="translated">TrimFunc通过切掉所有满足f(c)的前导和尾部UTF-8编码的码点c来返回s的子片。</target>
        </trans-unit>
        <trans-unit id="b796ff265d1cc90c9b78c76a3f12dd8cbff027a6" translate="yes" xml:space="preserve">
          <source>TrimLeft</source>
          <target state="translated">TrimLeft</target>
        </trans-unit>
        <trans-unit id="3406f99b35b8781b2e30c5d4f1fb92b18ccfb0a0" translate="yes" xml:space="preserve">
          <source>TrimLeft returns a slice of the string s with all leading Unicode code points contained in cutset removed.</source>
          <target state="translated">TrimLeft 返回字符串 s 的一个片断,其中包含在 cutet 中的所有前导 Unicode 码点。</target>
        </trans-unit>
        <trans-unit id="b52b880dc01fa22cd46ff385a39b5609f426247b" translate="yes" xml:space="preserve">
          <source>TrimLeft returns a subslice of s by slicing off all leading UTF-8-encoded code points contained in cutset.</source>
          <target state="translated">TrimLeft通过切断cutet中包含的所有前导UTF-8编码的码点来返回s的子片。</target>
        </trans-unit>
        <trans-unit id="0dda8e3188c1b3df6f3a5c77e5010dd280c96425" translate="yes" xml:space="preserve">
          <source>TrimLeftFunc</source>
          <target state="translated">TrimLeftFunc</target>
        </trans-unit>
        <trans-unit id="2a771ac81b0579d70a2a4390b741d5fed266d711" translate="yes" xml:space="preserve">
          <source>TrimLeftFunc returns a slice of the string s with all leading Unicode code points c satisfying f(c) removed.</source>
          <target state="translated">TrimLeftFunc返回字符串s的一个片断,并删除所有满足f(c)的Unicode前导码点c。</target>
        </trans-unit>
        <trans-unit id="49c15e330f226f8800b406f97802237df2f3f947" translate="yes" xml:space="preserve">
          <source>TrimLeftFunc treats s as UTF-8-encoded bytes and returns a subslice of s by slicing off all leading UTF-8-encoded code points c that satisfy f(c).</source>
          <target state="translated">TrimLeftFunc将s视为UTF-8编码的字节,并通过切掉所有满足f(c)的前导UTF-8编码码点c来返回s的子片。</target>
        </trans-unit>
        <trans-unit id="f6781400f56acf5b8bc035e02b3cdac08b09ae64" translate="yes" xml:space="preserve">
          <source>TrimPrefix</source>
          <target state="translated">TrimPrefix</target>
        </trans-unit>
        <trans-unit id="0cdb8742fe0e8f96e729ab0932195bcd75f8a8b2" translate="yes" xml:space="preserve">
          <source>TrimPrefix returns s without the provided leading prefix string. If s doesn't start with prefix, s is returned unchanged.</source>
          <target state="translated">TrimPrefix返回s,不包含提供的前缀字符串。如果s不以前缀开始,则返回s不变。</target>
        </trans-unit>
        <trans-unit id="3a3dc250671844d052f305fc24e91daa5dfaf78b" translate="yes" xml:space="preserve">
          <source>TrimRight</source>
          <target state="translated">TrimRight</target>
        </trans-unit>
        <trans-unit id="f36ec5b5c4656d60b56116c5bdb688d629f84c86" translate="yes" xml:space="preserve">
          <source>TrimRight returns a slice of the string s, with all trailing Unicode code points contained in cutset removed.</source>
          <target state="translated">TrimRight返回字符串s的一个片断,并删除所有包含在cuteset中的尾部Unicode码点。</target>
        </trans-unit>
        <trans-unit id="3ca08db3862d11ac280fa859c98a5062cca7758f" translate="yes" xml:space="preserve">
          <source>TrimRight returns a subslice of s by slicing off all trailing UTF-8-encoded code points that are contained in cutset.</source>
          <target state="translated">TrimRight通过切掉所有包含在cutset中的尾部UTF-8编码的码点来返回s的子片。</target>
        </trans-unit>
        <trans-unit id="2face4904f1360f377438b017515ff3c2359f581" translate="yes" xml:space="preserve">
          <source>TrimRightFunc</source>
          <target state="translated">TrimRightFunc</target>
        </trans-unit>
        <trans-unit id="91f9e348fa7e18e840cf0ac3e8dc3a6295b78762" translate="yes" xml:space="preserve">
          <source>TrimRightFunc returns a slice of the string s with all trailing Unicode code points c satisfying f(c) removed.</source>
          <target state="translated">TrimRightFunc 返回字符串 s 的一个片断,并删除所有满足 f(c)的 Unicode 码点。</target>
        </trans-unit>
        <trans-unit id="af58ad241c06498d7e5d96dabf6a334e19cb450d" translate="yes" xml:space="preserve">
          <source>TrimRightFunc returns a subslice of s by slicing off all trailing UTF-8-encoded code points c that satisfy f(c).</source>
          <target state="translated">TrimRightFunc通过切掉所有满足f(c)的UTF-8编码的尾部码点c来返回s的子片。</target>
        </trans-unit>
        <trans-unit id="3b9759ef917cd034e3fff66af6781ac1144ddf76" translate="yes" xml:space="preserve">
          <source>TrimSpace</source>
          <target state="translated">TrimSpace</target>
        </trans-unit>
        <trans-unit id="fb7131e90264c0cc3ce43bd31575b4282b5313c8" translate="yes" xml:space="preserve">
          <source>TrimSpace returns a slice of the string s, with all leading and trailing white space removed, as defined by Unicode.</source>
          <target state="translated">TrimSpace返回字符串s的一个片断,其中所有的前导和尾部的空白空间都被删除,如Unicode所定义。</target>
        </trans-unit>
        <trans-unit id="a187e5cf0dba2afc1b0487c662e640873854f7ec" translate="yes" xml:space="preserve">
          <source>TrimSpace returns a subslice of s by slicing off all leading and trailing white space, as defined by Unicode.</source>
          <target state="translated">TrimSpace通过切去Unicode定义的所有前导和尾部的空白空间来返回s的子片段。</target>
        </trans-unit>
        <trans-unit id="b11fe2b91f56619862961192ca92d40d14d67c9d" translate="yes" xml:space="preserve">
          <source>TrimString returns s without leading and trailing ASCII space.</source>
          <target state="translated">TrimString返回不含前导和尾部ASCII空格的s。</target>
        </trans-unit>
        <trans-unit id="31564f1b1fc10c6dcf98b0ba8f0d174cf833e697" translate="yes" xml:space="preserve">
          <source>TrimSuffix</source>
          <target state="translated">TrimSuffix</target>
        </trans-unit>
        <trans-unit id="92a8263afbc0fa4c5341e4098b039907219bbb45" translate="yes" xml:space="preserve">
          <source>TrimSuffix returns s without the provided trailing suffix string. If s doesn't end with suffix, s is returned unchanged.</source>
          <target state="translated">TrimSuffix返回s,不包含提供的后缀字符串。如果s不以后缀结尾,则返回s不变。</target>
        </trans-unit>
        <trans-unit id="0b8272d0bb8c9199c72411e406f2643a93b7ccca" translate="yes" xml:space="preserve">
          <source>Trunc</source>
          <target state="translated">Trunc</target>
        </trans-unit>
        <trans-unit id="4ac265259166695b742658a267b27c17c43d2d87" translate="yes" xml:space="preserve">
          <source>Trunc returns the integer value of x.</source>
          <target state="translated">Trunc返回x的整数值。</target>
        </trans-unit>
        <trans-unit id="a6f2f1d850d6a1bef2ab8b526d322b73779287f1" translate="yes" xml:space="preserve">
          <source>Truncate changes the size of the file. It does not change the I/O offset. If there is an error, it will be of type *PathError.</source>
          <target state="translated">Truncate会改变文件的大小。它不改变I/O偏移量。如果有错误,它的类型是*PathError。</target>
        </trans-unit>
        <trans-unit id="062334176014417d736c93d4f00898bc3b617151" translate="yes" xml:space="preserve">
          <source>Truncate changes the size of the named file. If the file is a symbolic link, it changes the size of the link's target. If there is an error, it will be of type *PathError.</source>
          <target state="translated">Truncate改变命名文件的大小。如果文件是一个符号链接,它将改变链接目标的大小。如果有一个错误,它的类型是*PathError。</target>
        </trans-unit>
        <trans-unit id="e8c4ef35e7ba4d40ba29121e1bd589ff3e80bcb3" translate="yes" xml:space="preserve">
          <source>Truncate discards all but the first n unread bytes from the buffer but continues to use the same allocated storage. It panics if n is negative or greater than the length of the buffer.</source>
          <target state="translated">Truncate丢弃缓冲区中除前n个未读字节外的所有字节,但继续使用相同的分配存储空间。如果n为负数或大于缓冲区的长度,它会惊慌失措。</target>
        </trans-unit>
        <trans-unit id="32beb0b08a1549453f279d1334d844a2afaea49a" translate="yes" xml:space="preserve">
          <source>Truncate operates on the time as an absolute duration since the zero time; it does not operate on the presentation form of the time. Thus, Truncate(Hour) may return a time with a non-zero minute, depending on the time's Location.</source>
          <target state="translated">Truncate 对时间的操作是指从零点开始的绝对持续时间;它不对时间的表现形式进行操作。因此,Truncate(Hour)可能会返回一个非零分钟的时间,这取决于时间的位置。</target>
        </trans-unit>
        <trans-unit id="71998d5a06a6fc24a70aad616e3e9f7ea3e57939" translate="yes" xml:space="preserve">
          <source>Truncate returns the result of rounding d toward zero to a multiple of m. If m &amp;lt;= 0, Truncate returns d unchanged.</source>
          <target state="translated">截断返回将d朝零舍入到m的倍数的结果。如果m &amp;lt;= 0，则Truncate不变地返回d。</target>
        </trans-unit>
        <trans-unit id="498fecdf2960f4ea8c81a3634a3c6208f18d44bd" translate="yes" xml:space="preserve">
          <source>Truncate returns the result of rounding t down to a multiple of d (since the zero time). If d &amp;lt;= 0, Truncate returns t stripped of any monotonic clock reading but otherwise unchanged.</source>
          <target state="translated">Truncate返回将t向下舍入为d的倍数的结果（因为零时间）。如果d &amp;lt;= 0，则Truncate返回t，去除了任何单调时钟读数，但未更改。</target>
        </trans-unit>
        <trans-unit id="7a922bb8e2913cab6dcad5ba9140345fb42fa502" translate="yes" xml:space="preserve">
          <source>TruncateWriter returns a Writer that writes to w but stops silently after n bytes.</source>
          <target state="translated">TruncateWriter 返回一个向 w 写入但在 n 个字节后默默停止的 Writer。</target>
        </trans-unit>
        <trans-unit id="66617c3163f43664fa6ddb9c95a7d88a932b782b" translate="yes" xml:space="preserve">
          <source>Truthy returns the JavaScript &quot;truthiness&quot; of the value v. In JavaScript, false, 0, &quot;&quot;, null, undefined, and NaN are &quot;falsy&quot;, and everything else is &quot;truthy&quot;. See &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Truthy&quot;&gt;https://developer.mozilla.org/en-US/docs/Glossary/Truthy&lt;/a&gt;.</source>
          <target state="translated">Truthy返回值v的JavaScript&amp;ldquo;真实性&amp;rdquo;。在JavaScript中，false，0，&amp;ldquo;&amp;rdquo;，null，undefined和NaN为&amp;ldquo; falsy&amp;rdquo;，其他所有内容均为&amp;ldquo; truthy&amp;rdquo;。请参阅&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Truthy&quot;&gt;https://developer.mozilla.org/en-US/docs/Glossary/Truthy&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c26728b3acc2b9a34150900b5536db30082f4043" translate="yes" xml:space="preserve">
          <source>TryRecv attempts to receive a value from the channel v but will not block. It panics if v's Kind is not Chan. If the receive delivers a value, x is the transferred value and ok is true. If the receive cannot finish without blocking, x is the zero Value and ok is false. If the channel is closed, x is the zero value for the channel's element type and ok is false.</source>
          <target state="translated">TryRecv 试图从通道 v 中接收一个值,但不会阻塞。如果v的Kind不是Chan,它就会恐慌。如果接收到一个值,x是传输的值,ok为true。如果receive不能在不阻塞的情况下完成,x为零值,ok为假。如果通道被关闭,x是通道的元素类型的零值,ok为假。</target>
        </trans-unit>
        <trans-unit id="febc1b0170a31256a4ba31c38646abd1c14c7afb" translate="yes" xml:space="preserve">
          <source>TrySend attempts to send x on the channel v but will not block. It panics if v's Kind is not Chan. It reports whether the value was sent. As in Go, x's value must be assignable to the channel's element type.</source>
          <target state="translated">TrySend试图在v通道上发送x,但不会被阻止。如果v的Kind不是Chan,它就会恐慌。它报告值是否被发送。在围棋中,x的值必须可以分配给通道的元素类型。</target>
        </trans-unit>
        <trans-unit id="7fd5a63a31a17c2aa8f2b5b0d5183f5173b04681" translate="yes" xml:space="preserve">
          <source>Two keys are only considered to have the same value if they have the same Curve value. Note that for example elliptic.P256() and elliptic.P256().Params() are different values, as the latter is a generic not constant time implementation.</source>
          <target state="translated">只有当两个键具有相同的Curve值时,才认为它们具有相同的值。请注意,例如elliptic.P256()和elliptic.P256().Params()是不同的值,因为后者是一个通用的不是恒定时间的实现。</target>
        </trans-unit>
        <trans-unit id="ad904f452afce8318d85fd92e9c6e068ca4fed6e" translate="yes" xml:space="preserve">
          <source>Two sets of interfaces are included in this package. When a more abstract interface isn't necessary, there are functions for encrypting/decrypting with v1.5/OAEP and signing/verifying with v1.5/PSS. If one needs to abstract over the public key primitive, the PrivateKey type implements the Decrypter and Signer interfaces from the crypto package.</source>
          <target state="translated">本包中包含两套接口。当不需要更抽象的接口时,有一些函数用于用v1.5/OAEP加密/解密和用v1.5/PSS签名/验证。如果需要对公钥基元进行抽象,PrivateKey类型实现了crypto包中的Decrypter和Signer接口。</target>
        </trans-unit>
        <trans-unit id="042f2d498c44806f60201f1f05491910d5c73fe8" translate="yes" xml:space="preserve">
          <source>Two sets of interfaces are included in this package. When a more abstract interface isn't necessary, there are functions for encrypting/decrypting with v1.5/OAEP and signing/verifying with v1.5/PSS. If one needs to abstract over the public-key primitive, the PrivateKey struct implements the Decrypter and Signer interfaces from the crypto package.</source>
          <target state="translated">本包中包含两套接口。当不需要更抽象的接口时,有一些函数用于用v1.5/OAEP加密/解密和用v1.5/PSS签名/验证。如果需要对公钥基元进行抽象,那么PrivateKey结构实现了crypto包中的Decrypter和Signer接口。</target>
        </trans-unit>
        <trans-unit id="021677bbd9ee4b61e5a1312cf21d452a27661c48" translate="yes" xml:space="preserve">
          <source>Tx is a transaction.</source>
          <target state="translated">Tx是一种交易。</target>
        </trans-unit>
        <trans-unit id="02cdcf0d841ea4d5e8abf2653c842d138120149a" translate="yes" xml:space="preserve">
          <source>Tx is an in-progress database transaction.</source>
          <target state="translated">Tx是一个进行中的数据库事务。</target>
        </trans-unit>
        <trans-unit id="41b6053676814b4fe97b2c9be9a306ee614bfa3d" translate="yes" xml:space="preserve">
          <source>Tx.ExecContext</source>
          <target state="translated">Tx.ExecContext</target>
        </trans-unit>
        <trans-unit id="2825856698e10e430365413d889b83a20654a02a" translate="yes" xml:space="preserve">
          <source>Tx.Prepare</source>
          <target state="translated">Tx.Prepare</target>
        </trans-unit>
        <trans-unit id="ef76ba4edb63dbd2cd7bf54f9037e276e1229e5a" translate="yes" xml:space="preserve">
          <source>Tx.Rollback</source>
          <target state="translated">Tx.Rollback</target>
        </trans-unit>
        <trans-unit id="a83fe983647bcf7e1590d7bef39b1b437680667a" translate="yes" xml:space="preserve">
          <source>TxOptions holds the transaction options to be used in DB.BeginTx.</source>
          <target state="translated">TxOptions持有DB.BeginTx中要使用的事务选项。</target>
        </trans-unit>
        <trans-unit id="46eaf072cf758f74571ec8685b65883630652645" translate="yes" xml:space="preserve">
          <source>TxOptions holds the transaction options.</source>
          <target state="translated">TxOptions持有交易选项。</target>
        </trans-unit>
        <trans-unit id="68e7b01d33d203d9281e2f2dd8f3398104376276" translate="yes" xml:space="preserve">
          <source>Typ contains the predeclared *Basic types indexed by their corresponding BasicKind.</source>
          <target state="translated">Typ包含由其对应的BasicKind索引的预先声明的*Basic类型。</target>
        </trans-unit>
        <trans-unit id="64f24b17ea9baa36a77dc3d1afdc32b1a420fb9e" translate="yes" xml:space="preserve">
          <source>Type flags for Header.Typeflag.</source>
          <target state="translated">Header.Typeflag的类型标志。</target>
        </trans-unit>
        <trans-unit id="04ccb52737e3e40430c97b234b8f24e390173f8b" translate="yes" xml:space="preserve">
          <source>Type inference computes the type (Type) of every expression (ast.Expr) and checks for compliance with the language specification. Use Info.Types[expr].Type for the results of type inference.</source>
          <target state="translated">类型推理计算每个表达式(ast.Expr)的类型(Type),并检查是否符合语言规范。使用Info.Types[expr].Type来获取类型推理的结果。</target>
        </trans-unit>
        <trans-unit id="8035b14525c84dd4e5349419c0ff657e153c1c32" translate="yes" xml:space="preserve">
          <source>Type is found in Header.Type.</source>
          <target state="translated">Type在Header.Type中找到。</target>
        </trans-unit>
        <trans-unit id="ec7bc4958b2c43e87f98f2ef7e1adb5d065d5c5e" translate="yes" xml:space="preserve">
          <source>Type is here for the purposes of documentation only. It is a stand-in for any Go type, but represents the same type for any given function invocation.</source>
          <target state="translated">类型在这里只是为了文档的目的。它是任何Go类型的替身,但对于任何给定的函数调用来说,它代表的是相同的类型。</target>
        </trans-unit>
        <trans-unit id="233ac19906546712346f536e7ee3880b82162310" translate="yes" xml:space="preserve">
          <source>Type is the documentation for a type declaration.</source>
          <target state="translated">类型是类型声明的文档。</target>
        </trans-unit>
        <trans-unit id="d3c0b263d515209e36ac606a05719bce899addba" translate="yes" xml:space="preserve">
          <source>Type is the representation of a Go type.</source>
          <target state="translated">类型是围棋类型的表示。</target>
        </trans-unit>
        <trans-unit id="c3bca7d619ddc3b0ec61fb8f295216cb63f22eb4" translate="yes" xml:space="preserve">
          <source>Type reads the type at off in the DWARF &amp;ldquo;info&amp;rdquo; section.</source>
          <target state="translated">Type在DWARF&amp;ldquo;信息&amp;rdquo;部分中关闭时读取类型。</target>
        </trans-unit>
        <trans-unit id="1fce0b09390d2c3838db788c0cf76f63a5bf80a9" translate="yes" xml:space="preserve">
          <source>Type represents the JavaScript type of a Value.</source>
          <target state="translated">Type表示Value的JavaScript类型。</target>
        </trans-unit>
        <trans-unit id="e06c5701673348f2eed499aa753a2ba395d1a12d" translate="yes" xml:space="preserve">
          <source>Type returns itself and provides an easy default implementation for embedding in a Node. Embedded in all non-trivial Nodes.</source>
          <target state="translated">类型返回自身,并为嵌入Node提供了一个简单的默认实现。嵌入到所有非平凡的Node中。</target>
        </trans-unit>
        <trans-unit id="4726645469f41dd7bcb1d47132c78e582530c7e1" translate="yes" xml:space="preserve">
          <source>Type returns the JavaScript type of the value v. It is similar to JavaScript's typeof operator, except that it returns TypeNull instead of TypeObject for null.</source>
          <target state="translated">Type返回值v的JavaScript类型,它类似于JavaScript的typeof操作符,除了它返回TypeNull而不是TypeObject的null。</target>
        </trans-unit>
        <trans-unit id="2fa9db8cb436bbb192eec5d03d6240277e6eeffd" translate="yes" xml:space="preserve">
          <source>Type returns the object's type.</source>
          <target state="translated">Type 返回对象的类型。</target>
        </trans-unit>
        <trans-unit id="d1407fc8c8322906d1372dd8a45dc51e6205559f" translate="yes" xml:space="preserve">
          <source>Type returns the type of x.f, which may be different from the type of f. See Selection for more information.</source>
          <target state="translated">Type 返回 x.f 的类型,它可能与 f 的类型不同。更多信息请参见 Selection。</target>
        </trans-unit>
        <trans-unit id="55e720628bd8b49b52419d5886faf349fa86465b" translate="yes" xml:space="preserve">
          <source>Type returns type bits in m (m &amp;amp; ModeType).</source>
          <target state="translated">Type返回以m为单位的类型位（m和ModeType）。</target>
        </trans-unit>
        <trans-unit id="372fc3db84eb7f93272dcba175262aaab1565f30" translate="yes" xml:space="preserve">
          <source>Type returns v's type.</source>
          <target state="translated">Type返回v的类型。</target>
        </trans-unit>
        <trans-unit id="55dbc1b43ee6cb3b1548172b193bc2a7d3e5eca5" translate="yes" xml:space="preserve">
          <source>Type values are comparable, such as with the == operator, so they can be used as map keys. Two Type values are equal if they represent identical types.</source>
          <target state="translated">类型值是可以比较的,比如用==运算符,所以它们可以作为映射键使用。如果两个类型值代表相同的类型,则它们是相等的。</target>
        </trans-unit>
        <trans-unit id="7bdac7349f75285c99f4a03ea2e2de6365f45c2a" translate="yes" xml:space="preserve">
          <source>Type-checking consists of several interdependent phases:</source>
          <target state="translated">类型检查包括几个相互依赖的阶段。</target>
        </trans-unit>
        <trans-unit id="26984be5e6e3b06475f717ab4d76ce6f4ff88c54" translate="yes" xml:space="preserve">
          <source>Type1 is here for the purposes of documentation only. It is a stand-in for any Go type, but represents the same type for any given function invocation.</source>
          <target state="translated">Type1在这里只是为了文档的目的。它是任何围棋类型的替身,但对于任何给定的函数调用来说,它代表的是同一类型。</target>
        </trans-unit>
        <trans-unit id="7ace60c9c3dbd05ce39ba29e759c6ad4a52088eb" translate="yes" xml:space="preserve">
          <source>TypeAndValue reports the type and value (for constants) of the corresponding expression.</source>
          <target state="translated">TypeAndValue报告相应表达式的类型和值(对于常量)。</target>
        </trans-unit>
        <trans-unit id="2bc75a2b4beae4c84f906bb525769e97f38f0823" translate="yes" xml:space="preserve">
          <source>TypeByExtension returns the MIME type associated with the file extension ext. The extension ext should begin with a leading dot, as in &quot;.html&quot;. When ext has no associated type, TypeByExtension returns &quot;&quot;.</source>
          <target state="translated">TypeByExtension 返回与文件扩展名 ext 相关联的 MIME 类型。扩展名 ext 应该以前导点开始,如&quot;.html&quot;。当ext没有关联类型时,TypeByExtension返回&quot;&quot;。</target>
        </trans-unit>
        <trans-unit id="263318bcaf840ab395175e373b1ab05080a86fda" translate="yes" xml:space="preserve">
          <source>TypeOf</source>
          <target state="translated">TypeOf</target>
        </trans-unit>
        <trans-unit id="94969a4aec167529cd20467de358b3733a4d1890" translate="yes" xml:space="preserve">
          <source>TypeOf returns the reflection Type that represents the dynamic type of i. If i is a nil interface value, TypeOf returns nil.</source>
          <target state="translated">TypeOf返回代表i的动态类型的反射类型,如果i是一个nil接口值,TypeOf返回nil。</target>
        </trans-unit>
        <trans-unit id="610b14205855f95702d99da6e19e5297b1301163" translate="yes" xml:space="preserve">
          <source>TypeOf returns the type of expression e, or nil if not found. Precondition: the Types, Uses and Defs maps are populated.</source>
          <target state="translated">TypeOf返回表达式e的类型,如果没有找到,则返回nil。前提条件:Types、Uses和Defs映射被填充。</target>
        </trans-unit>
        <trans-unit id="af91dac9977c975dbcb45d1e0c495727ba389f89" translate="yes" xml:space="preserve">
          <source>TypeString returns the string representation of typ. The Qualifier controls the printing of package-level objects, and may be nil.</source>
          <target state="translated">TypeString 返回 typ.Type 的字符串表示。该限定符控制包级对象的打印,可以是零。</target>
        </trans-unit>
        <trans-unit id="70c0f61c1717bc58a510efe98bd7a3251bcbbcc7" translate="yes" xml:space="preserve">
          <source>Typed Strings</source>
          <target state="translated">字符串</target>
        </trans-unit>
        <trans-unit id="802976d08e8f16b7d83d8d12b5129fe9e25c37e3" translate="yes" xml:space="preserve">
          <source>Types HTML, JS, URL, and others from content.go can carry safe content that is exempted from escaping.</source>
          <target state="translated">内容.go中的HTML、JS、URL等类型可以携带免于逃逸的安全内容。</target>
        </trans-unit>
        <trans-unit id="cea554202fc0c5ff6482d3e61417b6640fc17af4" translate="yes" xml:space="preserve">
          <source>Types and Values</source>
          <target state="translated">类型和数值</target>
        </trans-unit>
        <trans-unit id="4a237767760223207248b2b72e8a0eb1c03dbe30" translate="yes" xml:space="preserve">
          <source>Types implementing Valuer interface are able to convert themselves to a driver Value.</source>
          <target state="translated">实现Valuer接口的类型能够将自己转换为驱动Value。</target>
        </trans-unit>
        <trans-unit id="738f4e11bb80f11f67d45a4481cf366179186823" translate="yes" xml:space="preserve">
          <source>Types of signals</source>
          <target state="translated">信号类型</target>
        </trans-unit>
        <trans-unit id="4a68e8d3eb65d7282f5ff466196272be854598ae" translate="yes" xml:space="preserve">
          <source>Typical usage inside a test is:</source>
          <target state="translated">测试里面的典型用法是。</target>
        </trans-unit>
        <trans-unit id="b842957498ea8405dcbf49648de63b65b478d2cb" translate="yes" xml:space="preserve">
          <source>UDPAddr represents the address of a UDP end point.</source>
          <target state="translated">UDPAddr代表UDP端点的地址。</target>
        </trans-unit>
        <trans-unit id="b3b4fc6834e1c9d716c787f9ac0d161736c5f604" translate="yes" xml:space="preserve">
          <source>UDPConn is the implementation of the Conn and PacketConn interfaces for UDP network connections.</source>
          <target state="translated">UDPConn是Conn和PacketConn接口在UDP网络连接中的实现。</target>
        </trans-unit>
        <trans-unit id="b499255e82796e4d28d962954395ad3d893bac9c" translate="yes" xml:space="preserve">
          <source>UDPConn.WriteTo</source>
          <target state="translated">UDPConn.WriteTo</target>
        </trans-unit>
        <trans-unit id="0e2d9b0777a485c1276de0803c12a7d76fbc5c39" translate="yes" xml:space="preserve">
          <source>URL</source>
          <target state="translated">URL</target>
        </trans-unit>
        <trans-unit id="2113a36dc330dedde4db70e90a71dcb67bd4a9a2" translate="yes" xml:space="preserve">
          <source>URL (Roundtrip)</source>
          <target state="translated">URL(往返)</target>
        </trans-unit>
        <trans-unit id="a727ea70072d81d7b63c816962c8a756b508329a" translate="yes" xml:space="preserve">
          <source>URL encapsulates a known safe URL or URL substring (see RFC 3986). A URL like `javascript:checkThatFormNotEditedBeforeLeavingPage()` from a trusted source should go in the page, but by default dynamic `javascript:` URLs are filtered out since they are a frequently exploited injection vector.</source>
          <target state="translated">URL封装一个已知的安全URL或URL子串(见RFC 3986)。像 &quot;javascript:checkThatFormNotEditedBeforeLeavingPage()&quot;这样来自受信任来源的URL应该放在页面中,但默认情况下动态的 &quot;javascript:&quot;URL会被过滤掉,因为它们是一个经常被利用的注入向量。</target>
        </trans-unit>
        <trans-unit id="9f6702283d55dba63f2c15c6981885271e829853" translate="yes" xml:space="preserve">
          <source>URL's String method uses the EscapedPath method to obtain the path. See the EscapedPath method for more details.</source>
          <target state="translated">URL的String方法使用EscapedPath方法来获取路径。更多细节请参见EscapedPath方法。</target>
        </trans-unit>
        <trans-unit id="a7ffebe53d073d64da891027cdca3ef31de6ee7a" translate="yes" xml:space="preserve">
          <source>URL.EscapedFragment</source>
          <target state="translated">URL.EscapedFragment</target>
        </trans-unit>
        <trans-unit id="fb15045a2812519f4e1083e5cb90b2d16bf5e0e2" translate="yes" xml:space="preserve">
          <source>URL.EscapedPath</source>
          <target state="translated">URL.EscapedPath</target>
        </trans-unit>
        <trans-unit id="4966fe66780da2ec3d10c8599e72fff7ab08a49a" translate="yes" xml:space="preserve">
          <source>URL.Hostname</source>
          <target state="translated">URL.Hostname</target>
        </trans-unit>
        <trans-unit id="93c3fa248c55505922464e5ed8d1899f54880821" translate="yes" xml:space="preserve">
          <source>URL.IsAbs</source>
          <target state="translated">URL.IsAbs</target>
        </trans-unit>
        <trans-unit id="c5ff099f399baf8e187d09b758e991f007d9fdbb" translate="yes" xml:space="preserve">
          <source>URL.MarshalBinary</source>
          <target state="translated">URL.MarshalBinary</target>
        </trans-unit>
        <trans-unit id="1f5b4a1bd876c3d2e848fa8ad0b5bcdecf59f3eb" translate="yes" xml:space="preserve">
          <source>URL.Parse</source>
          <target state="translated">URL.Parse</target>
        </trans-unit>
        <trans-unit id="df308e5c8e7a40f3e06e1c8f29546df6edd0815c" translate="yes" xml:space="preserve">
          <source>URL.Port</source>
          <target state="translated">URL.Port</target>
        </trans-unit>
        <trans-unit id="1f4af3bd8a928ef1166e58b54f440e84607bbe48" translate="yes" xml:space="preserve">
          <source>URL.Query</source>
          <target state="translated">URL.Query</target>
        </trans-unit>
        <trans-unit id="f2cbc812759bc0bcb35214d0c86a7a333cdc5ac4" translate="yes" xml:space="preserve">
          <source>URL.Redacted</source>
          <target state="translated">URL.Redacted</target>
        </trans-unit>
        <trans-unit id="2f6fe106a87daa55540bf1b3e2faa597e4637d72" translate="yes" xml:space="preserve">
          <source>URL.RequestURI</source>
          <target state="translated">URL.RequestURI</target>
        </trans-unit>
        <trans-unit id="5ef9cfae68b8e79167af493274ea7b99357dad6d" translate="yes" xml:space="preserve">
          <source>URL.ResolveReference</source>
          <target state="translated">URL.ResolveReference</target>
        </trans-unit>
        <trans-unit id="aae15178969446ff357ff699287cc769e108c1ee" translate="yes" xml:space="preserve">
          <source>URL.String</source>
          <target state="translated">URL.String</target>
        </trans-unit>
        <trans-unit id="ce84e8c5399c507871045bd05a22f805d2c4f2bd" translate="yes" xml:space="preserve">
          <source>URL.UnmarshalBinary</source>
          <target state="translated">URL.UnmarshalBinary</target>
        </trans-unit>
        <trans-unit id="ac64d1ff5ad8c8e979a983967383931627c1db93" translate="yes" xml:space="preserve">
          <source>URLEncoding is the alternate base64 encoding defined in RFC 4648. It is typically used in URLs and file names.</source>
          <target state="translated">URLEncoding是RFC 4648中定义的备用base64编码。它通常用于URL和文件名中。</target>
        </trans-unit>
        <trans-unit id="c9df7bde57a8aa1d95e4f472d843c333da35563f" translate="yes" xml:space="preserve">
          <source>URLQueryEscaper returns the escaped value of the textual representation of its arguments in a form suitable for embedding in a URL query.</source>
          <target state="translated">URLQueryEscaper以适合嵌入到URL查询中的形式返回其参数的文本表示的转义值。</target>
        </trans-unit>
        <trans-unit id="f75c8002cbe8f09b52b12100920f39a5c64e72ab" translate="yes" xml:space="preserve">
          <source>URLs in the comment text are converted into links; if the URL also appears in the words map, the link is taken from the map (if the corresponding map value is the empty string, the URL is not converted into a link).</source>
          <target state="translated">注释文本中的URL会被转换为链接;如果URL也出现在词条地图中,则链接取自地图(如果对应的地图值为空字符串,则URL不会被转换为链接)。</target>
        </trans-unit>
        <trans-unit id="66e91d3bfc1c62180f622950dd4b88caee7fb5f3" translate="yes" xml:space="preserve">
          <source>URLs that do not start with a slash after the scheme are interpreted as:</source>
          <target state="translated">方案后不以斜杠开头的URL会被解释为。</target>
        </trans-unit>
        <trans-unit id="0809917b6f7b4556e78a9d2c239213f16de1592f" translate="yes" xml:space="preserve">
          <source>UTC represents Universal Coordinated Time (UTC).</source>
          <target state="translated">UTC代表世界协调时间(UTC)。</target>
        </trans-unit>
        <trans-unit id="2910e9336b266393bd7b3bb04c8ff09ab1ad423c" translate="yes" xml:space="preserve">
          <source>UTC returns t with the location set to UTC.</source>
          <target state="translated">UTC返回t,并将位置设置为UTC。</target>
        </trans-unit>
        <trans-unit id="bd4707cd474a6d0f83da094caeed9e471bb79e5c" translate="yes" xml:space="preserve">
          <source>Uint defines a uint flag with specified name, default value, and usage string. The return value is the address of a uint variable that stores the value of the flag.</source>
          <target state="translated">Uint定义了一个uint标志,具有指定的名称、默认值和使用字符串。返回值是一个存储标志值的uint变量的地址。</target>
        </trans-unit>
        <trans-unit id="c10a1c74871016b345bc36d5bdb30897f19968dc" translate="yes" xml:space="preserve">
          <source>Uint returns v's underlying value, as a uint64. It panics if v's Kind is not Uint, Uintptr, Uint8, Uint16, Uint32, or Uint64.</source>
          <target state="translated">Uint 返回 v 的底层值,是一个 uint64。如果v的Kind不是Uint、Uintptr、Uint8、Uint16、Uint32或Uint64,它就会恐慌。</target>
        </trans-unit>
        <trans-unit id="8c727e75a1c262fee3ed280d320bad7f8659ca56" translate="yes" xml:space="preserve">
          <source>Uint32 returns a pseudo-random 32-bit value as a uint32 from the default Source.</source>
          <target state="translated">Uint32从默认的Source返回一个伪随机的32位值作为uint32。</target>
        </trans-unit>
        <trans-unit id="e19c9ecfe9082dbf421a298c1c766023a8f7f823" translate="yes" xml:space="preserve">
          <source>Uint32 returns a pseudo-random 32-bit value as a uint32.</source>
          <target state="translated">Uint32以uint32的形式返回一个伪随机的32位值。</target>
        </trans-unit>
        <trans-unit id="030a2cb864d68ff2aba5fa883929c569cc36b65c" translate="yes" xml:space="preserve">
          <source>Uint64 defines a uint64 flag with specified name, default value, and usage string. The return value is the address of a uint64 variable that stores the value of the flag.</source>
          <target state="translated">Uint64定义了一个uint64标志,具有指定的名称、默认值和使用字符串。返回值是一个存储标志值的uint64变量的地址。</target>
        </trans-unit>
        <trans-unit id="6d3dffebe2bfc2c33c20643972b94062f6925708" translate="yes" xml:space="preserve">
          <source>Uint64 returns a pseudo-random 64-bit value as a uint64 from the default Source.</source>
          <target state="translated">Uint64从默认的Source返回一个伪随机的64位值作为uint64。</target>
        </trans-unit>
        <trans-unit id="4324e0d2d9e747146788fb1da362fb5053ac15fe" translate="yes" xml:space="preserve">
          <source>Uint64 returns a pseudo-random 64-bit value as a uint64.</source>
          <target state="translated">Uint64返回一个伪随机64位的uint64值。</target>
        </trans-unit>
        <trans-unit id="8f4f108ba23391540c5f57a2d283a1654c92a932" translate="yes" xml:space="preserve">
          <source>Uint64 returns a value drawn from the Zipf distribution described by the Zipf object.</source>
          <target state="translated">Uint64返回一个从Zipf对象描述的Zipf分布中提取的值。</target>
        </trans-unit>
        <trans-unit id="1ef36be6f6e6e03fddea6aa5e34904aadf0ca3e4" translate="yes" xml:space="preserve">
          <source>Uint64 returns the internal uint64 value for the metric.</source>
          <target state="translated">Uint64 返回度量的内部 uint64 值。</target>
        </trans-unit>
        <trans-unit id="0e960db65d7bc2609ac63eaaddb18d0ce30fd34e" translate="yes" xml:space="preserve">
          <source>Uint64 returns the uint64 representation of x. If x cannot be represented in a uint64, the result is undefined.</source>
          <target state="translated">Uint64返回x的uint64表示,如果x不能用uint64表示,则结果为未定义。</target>
        </trans-unit>
        <trans-unit id="4059a3fbb04daacbe98a3ac34acbb5b4f0511d79" translate="yes" xml:space="preserve">
          <source>Uint64 returns the unsigned integer resulting from truncating x towards zero. If 0 &amp;lt;= x &amp;lt;= math.MaxUint64, the result is Exact if x is an integer and Below otherwise. The result is (0, Above) for x &amp;lt; 0, and (math.MaxUint64, Below) for x &amp;gt; math.MaxUint64.</source>
          <target state="translated">Uint64返回将x截断为零而得到的无符号整数。如果0 &amp;lt;= x &amp;lt;= math.MaxUint64，则如果x为整数，则结果为Exact，否则为Under。对于x &amp;lt;0，结果为（0，高于），对于x&amp;gt; math.MaxUint64，结果为（math.MaxUint64，低于）。</target>
        </trans-unit>
        <trans-unit id="eee8610c675fa51e59aceef9ba15ad48fc3f7656" translate="yes" xml:space="preserve">
          <source>Uint64Val returns the Go uint64 value of x and whether the result is exact; x must be an Int or an Unknown. If the result is not exact, its value is undefined. If x is Unknown, the result is (0, false).</source>
          <target state="translated">Uint64Val 返回 x 的 Go uint64 值以及结果是否精确;x 必须是 Int 或 Unknown。如果结果不精确,它的值是未定义的。如果x是未知值,结果是(0,false)。</target>
        </trans-unit>
        <trans-unit id="f8a9446572ec072b0dca42654febb328f4183bda" translate="yes" xml:space="preserve">
          <source>Uint64Var defines a uint64 flag with specified name, default value, and usage string. The argument p points to a uint64 variable in which to store the value of the flag.</source>
          <target state="translated">Uint64Var定义了一个uint64标志,它具有指定的名称、默认值和使用字符串,参数p指向一个uint64变量,用来存储标志的值。参数p指向一个uint64变量,用来存储标志的值。</target>
        </trans-unit>
        <trans-unit id="496dd0effb0126ef9e845598a59198590bcd043e" translate="yes" xml:space="preserve">
          <source>UintSize is the size of a uint in bits.</source>
          <target state="translated">UintSize是uint的大小,单位是比特。</target>
        </trans-unit>
        <trans-unit id="dbe3f8f6ae38a6c86be38b30cc7b136b0e0c8b33" translate="yes" xml:space="preserve">
          <source>UintVar defines a uint flag with specified name, default value, and usage string. The argument p points to a uint variable in which to store the value of the flag.</source>
          <target state="translated">UintVar定义了一个uint标志,它具有指定的名称、默认值和用法字符串,参数p指向一个uint变量,用来存储标志的值。参数p指向一个uint变量,用来存储标志的值。</target>
        </trans-unit>
        <trans-unit id="70e0b7ef4850aca01e0f7f10e5400e6c9147df8c" translate="yes" xml:space="preserve">
          <source>UnaryOp</source>
          <target state="translated">UnaryOp</target>
        </trans-unit>
        <trans-unit id="07e07a445fa30cc6121d05f031b487faccb7d573" translate="yes" xml:space="preserve">
          <source>UnaryOp returns the result of the unary expression op y. The operation must be defined for the operand. If prec &amp;gt; 0 it specifies the ^ (xor) result size in bits. If y is Unknown, the result is Unknown.</source>
          <target state="translated">UnaryOp返回一元表达式op y的结果。必须为操作数定义操作。如果prec&amp;gt; 0，则以位为单位指定^（异或）结果大小。如果y为未知，则结果为未知。</target>
        </trans-unit>
        <trans-unit id="65ac12608f350c5da84519394457136c59d339ec" translate="yes" xml:space="preserve">
          <source>Undefined returns the JavaScript value &quot;undefined&quot;.</source>
          <target state="translated">Undefined返回JavaScript值 &quot;undefined&quot;。</target>
        </trans-unit>
        <trans-unit id="9933a40ae911d6dfb846e287c51e34fc4040de25" translate="yes" xml:space="preserve">
          <source>UnescapeString</source>
          <target state="translated">UnescapeString</target>
        </trans-unit>
        <trans-unit id="d8d400b63495a426dfadc8a4f1e5fdcfa4a8e536" translate="yes" xml:space="preserve">
          <source>UnescapeString unescapes entities like &quot;&amp;amp;lt;&quot; to become &quot;&amp;lt;&quot;. It unescapes a larger range of entities than EscapeString escapes. For example, &quot;&amp;amp;aacute;&quot; unescapes to &quot;&amp;aacute;&quot;, as does &quot;&amp;amp;#225;&quot; and &quot;&amp;amp;#xE1;&quot;. UnescapeString(EscapeString(s)) == s always holds, but the converse isn't always true.</source>
          <target state="translated">UnescapeString取消转义&amp;ldquo;＆lt;&amp;rdquo;之类的实体 成为&amp;ldquo; &amp;lt;&amp;rdquo;。与EscapeString转义相比，它转义更大范围的实体。例如，&amp;ldquo;＆aacute;&amp;rdquo; 和&amp;ldquo;＆＃225;&amp;rdquo;一样，转义为&amp;ldquo;&amp;aacute;&amp;rdquo; 和&amp;ldquo;＆＃xE1;&amp;rdquo;。UnescapeString（EscapeString（s））== s总是成立，但是相反的情况并非总是如此。</target>
        </trans-unit>
        <trans-unit id="32ea3c11e3a0c9441edc34338d9ee1468d7b9e70" translate="yes" xml:space="preserve">
          <source>Unicode character classes are those in unicode.Categories and unicode.Scripts.</source>
          <target state="translated">Unicode字符类是unicode.Categories和unicode.Scripts中的字符。</target>
        </trans-unit>
        <trans-unit id="c698e3c309a2ed8c52f6f41c34c41e2935c68bed" translate="yes" xml:space="preserve">
          <source>Uniform is an infinite-sized Image of uniform color. It implements the color.Color, color.Model, and Image interfaces.</source>
          <target state="translated">Uniform是一个统一颜色的无限大小的Image。它实现了color.Color、color.Model和Image接口。</target>
        </trans-unit>
        <trans-unit id="c9b92cda61a2bd5ee7e67c31c67ae298972c3694" translate="yes" xml:space="preserve">
          <source>Union returns the smallest rectangle that contains both r and s.</source>
          <target state="translated">Union返回包含r和s的最小矩形。</target>
        </trans-unit>
        <trans-unit id="c30c209545f6cf55ee27d591debf698152bcbfd9" translate="yes" xml:space="preserve">
          <source>Unix returns t as a Unix time, the number of seconds elapsed since January 1, 1970 UTC. The result does not depend on the location associated with t.</source>
          <target state="translated">Unix以Unix时间的形式返回t,即自1970年1月1日UTC以来经过的秒数。结果不取决于与t相关联的位置。</target>
        </trans-unit>
        <trans-unit id="0739141adf792995ead54a41a03b2314aaccc261" translate="yes" xml:space="preserve">
          <source>Unix returns t as a Unix time, the number of seconds elapsed since January 1, 1970 UTC. The result does not depend on the location associated with t. Unix-like operating systems often record time as a 32-bit count of seconds, but since the method here returns a 64-bit value it is valid for billions of years into the past or future.</source>
          <target state="translated">Unix以Unix时间的形式返回t,即自1970年1月1日UTC以来经过的秒数。结果并不取决于与t相关联的位置。类似Unix的操作系统通常将时间记录为32位的秒数,但由于这里的方法返回的是64位的值,所以它对过去或未来的数十亿年都有效。</target>
        </trans-unit>
        <trans-unit id="8c849502e5926e7f6de51dcd5dae32180a6c8fc5" translate="yes" xml:space="preserve">
          <source>Unix returns the local Time corresponding to the given Unix time, sec seconds and nsec nanoseconds since January 1, 1970 UTC. It is valid to pass nsec outside the range [0, 999999999]. Not all sec values have a corresponding time value. One such value is 1&amp;lt;&amp;lt;63-1 (the largest int64 value).</source>
          <target state="translated">从1970年1月1日UTC开始，Unix返回与给定的Unix时间，秒秒和nsec纳秒相对应的本地时间。通过nsec超出[0，999999999]范围是有效的。并非所有秒值都有相应的时间值。这样的值之一就是1 &amp;lt;&amp;lt; 63-1（最大的int64值）。</target>
        </trans-unit>
        <trans-unit id="416b8be7737316cebb3c9cebf5753060cd3fcb1d" translate="yes" xml:space="preserve">
          <source>Unix returns the time stored in ts as seconds plus nanoseconds.</source>
          <target state="translated">Unix以秒加纳秒的形式返回存储在ts中的时间。</target>
        </trans-unit>
        <trans-unit id="164bbe899c45be28d564c4c79dd8c5d574ad3bc8" translate="yes" xml:space="preserve">
          <source>Unix returns the time stored in tv as seconds plus nanoseconds.</source>
          <target state="translated">Unix 将存储在 tv 中的时间返回为秒加纳秒。</target>
        </trans-unit>
        <trans-unit id="7f49edfe928a8998235ec038d3202681fe6091b3" translate="yes" xml:space="preserve">
          <source>Unix returns ts as the number of seconds and nanoseconds elapsed since the Unix epoch.</source>
          <target state="translated">Unix 将 ts 作为 Unix 纪元以来的秒数和纳秒数返回。</target>
        </trans-unit>
        <trans-unit id="36e051fac71bd9f38c8bee21a4fbf639eb952b84" translate="yes" xml:space="preserve">
          <source>Unix returns tv as the number of seconds and nanoseconds elapsed since the Unix epoch.</source>
          <target state="translated">Unix 将 tv 作为 Unix 纪元以来的秒数和纳秒数返回。</target>
        </trans-unit>
        <trans-unit id="4d2a03437e4146025835f0a7a6ccd0e75af8c754" translate="yes" xml:space="preserve">
          <source>UnixAddr represents the address of a Unix domain socket end point.</source>
          <target state="translated">UnixAddr表示Unix域套接字端点的地址。</target>
        </trans-unit>
        <trans-unit id="04cdae900c7738c2f31e4e0db5e46a21f1971317" translate="yes" xml:space="preserve">
          <source>UnixConn is an implementation of the Conn interface for connections to Unix domain sockets.</source>
          <target state="translated">UnixConn是Conn接口的一个实现,用于连接到Unix域套接字。</target>
        </trans-unit>
        <trans-unit id="fd1ae11b5100fed8de8a53db38bf7aed0bddf628" translate="yes" xml:space="preserve">
          <source>UnixCredentials encodes credentials into a socket control message for sending to another process. This can be used for authentication.</source>
          <target state="translated">UnixCredentials 将凭证编码到套接字控制消息中,以便发送至另一个进程。这可以用于验证。</target>
        </trans-unit>
        <trans-unit id="aea7fd85f724d84dccda1e26d2c29b04dd2edf2d" translate="yes" xml:space="preserve">
          <source>UnixListener is a Unix domain socket listener. Clients should typically use variables of type Listener instead of assuming Unix domain sockets.</source>
          <target state="translated">UnixListener是一个Unix域套接字监听器。客户端通常应该使用Listener类型的变量,而不是假设Unix域套接字。</target>
        </trans-unit>
        <trans-unit id="2a27b45fc326b4542c26186dc68da8cc5a7e5d10" translate="yes" xml:space="preserve">
          <source>UnixNano returns t as a Unix time, the number of nanoseconds elapsed since January 1, 1970 UTC. The result is undefined if the Unix time in nanoseconds cannot be represented by an int64 (a date before the year 1678 or after 2262). Note that this means the result of calling UnixNano on the zero Time is undefined. The result does not depend on the location associated with t.</source>
          <target state="translated">UnixNano 返回 t 作为 Unix 时间,即 1970 年 1 月 1 日 UTC 以来的纳秒数。如果以纳秒为单位的Unix时间不能用int64表示(1678年之前的日期或2262年之后的日期),那么结果是未定义的。注意,这意味着在零时间上调用UnixNano的结果是未定义的。结果不取决于与t相关联的位置。</target>
        </trans-unit>
        <trans-unit id="b17a6e6eff6f04c581ee8cd1e56b3e493458a9f8" translate="yes" xml:space="preserve">
          <source>UnixRights encodes a set of open file descriptors into a socket control message for sending to another process.</source>
          <target state="translated">UnixRights 将一组打开的文件描述符编码成套接字控制消息,以便发送给另一个进程。</target>
        </trans-unit>
        <trans-unit id="dbe53cfcde936dfcaf7c8175938f51e315034103" translate="yes" xml:space="preserve">
          <source>UnknownAuthorityError results when the certificate issuer is unknown</source>
          <target state="translated">未知授权错误(UnknownAuthorityError)在证书颁发者未知时产生。</target>
        </trans-unit>
        <trans-unit id="81414e166f7a74fc8a4df3127afc6add584dadf1" translate="yes" xml:space="preserve">
          <source>UnknownFileError represents a failure to find the specific file in the symbol table.</source>
          <target state="translated">UnknownFileError表示在符号表中找不到特定的文件。</target>
        </trans-unit>
        <trans-unit id="71d6e61364d65cc6b10f85900b022e3a712387e7" translate="yes" xml:space="preserve">
          <source>UnknownGroupError is returned by LookupGroup when a group cannot be found.</source>
          <target state="translated">当找不到组时,LookupGroup会返回UnknownGroupError。</target>
        </trans-unit>
        <trans-unit id="8395a289704405eac7a12dd0a91f81ec7b638b6b" translate="yes" xml:space="preserve">
          <source>UnknownGroupIdError is returned by LookupGroupId when a group cannot be found.</source>
          <target state="translated">当找不到组时,LookupGroupId会返回UnknownGroupIdError。</target>
        </trans-unit>
        <trans-unit id="ea06d94bc0ee6404fba69dbd6d9433ca16ab32bf" translate="yes" xml:space="preserve">
          <source>UnknownLineError represents a failure to map a line to a program counter, either because the line is beyond the bounds of the file or because there is no code on the given line.</source>
          <target state="translated">UnknownLineError表示未能将某行映射到程序计数器,原因是该行超出了文件的边界,或者是给定的行上没有代码。</target>
        </trans-unit>
        <trans-unit id="161a93107711086546bec71b893d5cad7e7be15e" translate="yes" xml:space="preserve">
          <source>UnknownUserError is returned by Lookup when a user cannot be found.</source>
          <target state="translated">当找不到用户时,未知用户错误(UnknownUserError)被Lookup返回。</target>
        </trans-unit>
        <trans-unit id="6017e893f322aa54de196845bc71d4f23b1edfcb" translate="yes" xml:space="preserve">
          <source>UnknownUserIdError is returned by LookupId when a user cannot be found.</source>
          <target state="translated">当找不到用户时,LookupId会返回UnknownUserIdError。</target>
        </trans-unit>
        <trans-unit id="47025f2669ef0e585c9e4472fd182fc3f82a586e" translate="yes" xml:space="preserve">
          <source>Unless an explicit codec is set up, package encoding/gob is used to transport the data.</source>
          <target state="translated">除非设置了明确的编解码器,否则会使用包编码/gob来传输数据。</target>
        </trans-unit>
        <trans-unit id="e7e8c7e799f9b4c265f8eb16ca2467638931db85" translate="yes" xml:space="preserve">
          <source>Unless otherwise noted, these are defined in RFC 7231 section 4.3.</source>
          <target state="translated">除非另有说明,否则这些都是在RFC 7231的4.3节中定义的。</target>
        </trans-unit>
        <trans-unit id="ad0d769d8f434903817312e6a1ab62dd81dfa28b" translate="yes" xml:space="preserve">
          <source>Unless specified otherwise, all operations (including setters) that specify a *Float variable for the result (usually via the receiver with the exception of MantExp), round the numeric result according to the precision and rounding mode of the result variable.</source>
          <target state="translated">除非另有规定,所有为结果指定*Float变量的操作(包括设置器)(通常通过接收器,MantExp除外),都会根据结果变量的精度和四舍五入模式对数值结果进行四舍五入。</target>
        </trans-unit>
        <trans-unit id="a99463bcf73aeb4ac48f9dbe6e1c4e0ad970639e" translate="yes" xml:space="preserve">
          <source>Unlike NextPart, it does not have special handling for &quot;Content-Transfer-Encoding: quoted-printable&quot;.</source>
          <target state="translated">与NextPart不同,它没有对 &quot;Content-Transfer-Encoding:quoted-printable &quot;进行特殊处理。</target>
        </trans-unit>
        <trans-unit id="ce1ab5c402bafab7c2f436e8311567b966b147df" translate="yes" xml:space="preserve">
          <source>Unlike in C, it is not valid to advance a pointer just beyond the end of its original allocation:</source>
          <target state="translated">与C语言不同的是,将一个指针提前到刚刚超过其原始分配的终点是无效的。</target>
        </trans-unit>
        <trans-unit id="522a3a646a834223c2e98bb2c21ff8e76c01dd11" translate="yes" xml:space="preserve">
          <source>Unlike runtime.Callers, the PC values returned should, when passed to the symbolizer function, return the file/line of the call instruction. No additional subtraction is required or appropriate.</source>
          <target state="translated">与runtime.Callers不同,返回的PC值在传递给符号化函数时,应该返回调用指令的文件/行。不需要或适当地做额外的减法。</target>
        </trans-unit>
        <trans-unit id="406ad3e57d6ca887a28b68d7deb07d96e9cd7dc1" translate="yes" xml:space="preserve">
          <source>Unlike the &quot;system&quot; library call from C and other languages, the os/exec package intentionally does not invoke the system shell and does not expand any glob patterns or handle other expansions, pipelines, or redirections typically done by shells. The package behaves more like C's &quot;exec&quot; family of functions. To expand glob patterns, either call the shell directly, taking care to escape any dangerous input, or use the path/filepath package's Glob function. To expand environment variables, use package os's ExpandEnv.</source>
          <target state="translated">与 C 和其他语言的 &quot;system &quot;库调用不同,os/exec 包故意不调用系统 shell,也不扩展任何 glob 模式或处理其他通常由 shell 完成的扩展、管道或重定向。这个包的行为更像 C 的 &quot;exec&quot; 系列函数。要扩展glob模式,可以直接调用shell,注意转义任何危险的输入,或者使用path/filepath包的Glob函数。要扩展环境变量,使用包os的ExpandEnv。</target>
        </trans-unit>
        <trans-unit id="abe91b52586dc5bbb2e6b3566c5e2c39387cbbd6" translate="yes" xml:space="preserve">
          <source>Unlink removes n % r.Len() elements from the ring r, starting at r.Next(). If n % r.Len() == 0, r remains unchanged. The result is the removed subring. r must not be empty.</source>
          <target state="translated">Unlink从r.Next()开始,从环r中删除n % r.Len()元素。如果n % r.Len()==0,则r保持不变。结果是被删除的子环,r不能为空。</target>
        </trans-unit>
        <trans-unit id="f1750196ed6e86ab6e565436971490e6b17346e5" translate="yes" xml:space="preserve">
          <source>Unlock unlocks m. It is a run-time error if m is not locked on entry to Unlock.</source>
          <target state="translated">如果m在进入Unlock时没有被锁定,则会出现运行时错误。</target>
        </trans-unit>
        <trans-unit id="1031b448939f378b7eec7282357fd0c8f02e0dd3" translate="yes" xml:space="preserve">
          <source>Unlock unlocks rw for writing. It is a run-time error if rw is not locked for writing on entry to Unlock.</source>
          <target state="translated">Unlock解锁rw的写入。如果rw在进入Unlock时没有被锁定以便写入,则会出现运行时错误。</target>
        </trans-unit>
        <trans-unit id="2769f111e84de5efeaaffb059d166476e34adffc" translate="yes" xml:space="preserve">
          <source>UnlockOSThread undoes an earlier call to LockOSThread. If this drops the number of active LockOSThread calls on the calling goroutine to zero, it unwires the calling goroutine from its fixed operating system thread. If there are no active LockOSThread calls, this is a no-op.</source>
          <target state="translated">UnlockOSThread撤销了之前对LockOSThread的调用。如果这使调用的goroutine上的活动LockOSThread调用次数降为零,则将调用的goroutine从其固定的操作系统线程中解开。如果没有主动的LockOSThread调用,这就是一个无操作。</target>
        </trans-unit>
        <trans-unit id="c0c55cc87781bbcbbe014b61cd39f339918efe82" translate="yes" xml:space="preserve">
          <source>Unmarshal</source>
          <target state="translated">Unmarshal</target>
        </trans-unit>
        <trans-unit id="b902b427877022323b14bf2942e7b4318af381ef" translate="yes" xml:space="preserve">
          <source>Unmarshal converts a point, serialized by Marshal, into an x, y pair. It is an error if the point is not in uncompressed form or is not on the curve. On error, x = nil.</source>
          <target state="translated">Unmarshal 将 Marshal 序列化的点转换为一个 x,y 对。如果这个点不是以未压缩的形式存在,或者不在曲线上,那就是一个错误。错误时,x=nil。</target>
        </trans-unit>
        <trans-unit id="05d9d3d65b2b20105c2330ab2953dfbf47f42b20" translate="yes" xml:space="preserve">
          <source>Unmarshal maps an XML element or attribute value to a bool by setting it to the boolean value represented by the string. Whitespace is trimmed and ignored.</source>
          <target state="translated">Unmarshal 通过将一个 XML 元素或属性值设置为由字符串代表的布尔值,从而将其映射为一个 bool。虚位会被修剪和忽略。</target>
        </trans-unit>
        <trans-unit id="a20ffd00f170a26037fda94503e504e8f14a2140" translate="yes" xml:space="preserve">
          <source>Unmarshal maps an XML element or attribute value to a slice by extending the length of the slice and mapping the element or attribute to the newly created value.</source>
          <target state="translated">Unmarshal通过扩展分片的长度并将元素或属性映射到新创建的值,从而将XML元素或属性值映射到分片。</target>
        </trans-unit>
        <trans-unit id="f49e594c7cd50f427b1321468c3f00b6805b3bc7" translate="yes" xml:space="preserve">
          <source>Unmarshal maps an XML element or attribute value to an integer or floating-point field by setting the field to the result of interpreting the string value in decimal. There is no check for overflow. Whitespace is trimmed and ignored.</source>
          <target state="translated">Unmarshal通过将字段设置为用十进制解释字符串值的结果,将一个XML元素或属性值映射到一个整数或浮点字段。没有对溢出进行检查。虚位会被修剪和忽略。</target>
        </trans-unit>
        <trans-unit id="e3d47c5ca4b3a002e5a1a94281405e13a887e601" translate="yes" xml:space="preserve">
          <source>Unmarshal maps an XML element to a Name by recording the element name.</source>
          <target state="translated">Unmarshal通过记录元素名称将一个XML元素映射到一个Name上。</target>
        </trans-unit>
        <trans-unit id="96b027c2d930b698a1ed10b0bb721de215ae272f" translate="yes" xml:space="preserve">
          <source>Unmarshal maps an XML element to a pointer by setting the pointer to a freshly allocated value and then mapping the element to that value.</source>
          <target state="translated">Unmarshal通过将指针设置为一个新分配的值,然后将元素映射到该值上,从而将XML元素映射到一个指针上。</target>
        </trans-unit>
        <trans-unit id="6674f1401888e867e969567800411704118b6e15" translate="yes" xml:space="preserve">
          <source>Unmarshal maps an XML element to a string or []byte by saving the concatenation of that element's character data in the string or []byte. The saved []byte is never nil.</source>
          <target state="translated">Unmarshal通过在字符串或[]字节中保存该元素的字符数据的连接,将一个XML元素映射到字符串或[]字节。保存的[]字节绝不是零。</target>
        </trans-unit>
        <trans-unit id="a09403355ff68d791492810d3a6fdc52e5bc5f23" translate="yes" xml:space="preserve">
          <source>Unmarshal maps an XML element to a struct using the following rules. In the rules, the tag of a field refers to the value associated with the key 'xml' in the struct field's tag (see the example above).</source>
          <target state="translated">Unmarshal 使用以下规则将一个 XML 元素映射到一个 struct。在规则中,字段的标签指的是与结构字段标签中的键 &quot;xml &quot;相关联的值(见上面的例子)。</target>
        </trans-unit>
        <trans-unit id="252b3357e8880736b5df5514f3757c07707118ae" translate="yes" xml:space="preserve">
          <source>Unmarshal maps an attribute value to a string or []byte by saving the value in the string or slice.</source>
          <target state="translated">Unmarshal通过将值保存在字符串或分片中,将属性值映射到字符串或[]字节。</target>
        </trans-unit>
        <trans-unit id="bb18922b79397b807a3d5909559848bfe9436488" translate="yes" xml:space="preserve">
          <source>Unmarshal maps an attribute value to an Attr by saving the attribute, including its name, in the Attr.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daa56a09ffbf4f0b35b7c340fa9c8ae81aa1dac5" translate="yes" xml:space="preserve">
          <source>Unmarshal parses the DER-encoded ASN.1 data structure b and uses the reflect package to fill in an arbitrary value pointed at by val. Because Unmarshal uses the reflect package, the structs being written to must use upper case field names.</source>
          <target state="translated">Unmarshal解析了DER编码的ASN.1数据结构b,并使用reflect包填入一个由val指向的任意值。因为Unmarshal使用了reflect包,所以写入的结构必须使用大写的字段名。</target>
        </trans-unit>
        <trans-unit id="896b9d75411fe008ac002fa69d65a02d32ae68e8" translate="yes" xml:space="preserve">
          <source>Unmarshal parses the DER-encoded ASN.1 data structure b and uses the reflect package to fill in an arbitrary value pointed at by val. Because Unmarshal uses the reflect package, the structs being written to must use upper case field names. If val is nil or not a pointer, Unmarshal returns an error.</source>
          <target state="translated">Unmarshal解析了DER编码的ASN.1数据结构b,并使用reflect包填入一个由val指向的任意值。因为Unmarshal使用反射包,所以写入的结构必须使用大写的字段名。如果 val 是 nil 或不是指针,Unmarshal 会返回一个错误。</target>
        </trans-unit>
        <trans-unit id="6a9e198e98aaf9144ec031242893dd0ad5675a2b" translate="yes" xml:space="preserve">
          <source>Unmarshal parses the JSON-encoded data and stores the result in the value pointed to by v. If v is nil or not a pointer, Unmarshal returns an InvalidUnmarshalError.</source>
          <target state="translated">Unmarshal解析JSON编码的数据,并将结果存储在v指向的值中,如果v为nil或不是指针,Unmarshal将返回一个InvalidUnmarshalError。</target>
        </trans-unit>
        <trans-unit id="ed1d87c314d03ac8a80eec05352fd3a2e828f6fd" translate="yes" xml:space="preserve">
          <source>Unmarshal parses the XML-encoded data and stores the result in the value pointed to by v, which must be an arbitrary struct, slice, or string. Well-formed data that does not fit into v is discarded.</source>
          <target state="translated">Unmarshal解析XML编码的数据,并将结果存储在v所指向的值中,v必须是一个任意的结构、片断或字符串。不适合v的格式良好的数据会被丢弃。</target>
        </trans-unit>
        <trans-unit id="40f5f3bf6806f78bc75f412c5c5def4697b027f5" translate="yes" xml:space="preserve">
          <source>Unmarshal uses the inverse of the encodings that Marshal uses, allocating maps, slices, and pointers as necessary, with the following additional rules:</source>
          <target state="translated">Unmarshal使用与Marshal使用的编码相反的编码,根据需要分配地图、切片和指针,附加规则如下。</target>
        </trans-unit>
        <trans-unit id="8a48a17f3248cfe923e11a8bf58b4b7fb9c77d34" translate="yes" xml:space="preserve">
          <source>UnmarshalBinary implements the encoding.BinaryUnmarshaler interface.</source>
          <target state="translated">UnmarshalBinary实现了encoding.BinaryUnmarshaler接口。</target>
        </trans-unit>
        <trans-unit id="3e8a767165b3da81fab334a0479c29a17b19b26e" translate="yes" xml:space="preserve">
          <source>UnmarshalBinary must be able to decode the form generated by MarshalBinary. UnmarshalBinary must copy the data if it wishes to retain the data after returning.</source>
          <target state="translated">UnmarshalBinary必须能够解码MarshalBinary生成的表单。如果UnmarshalBinary希望在返回后保留数据,它必须复制数据。</target>
        </trans-unit>
        <trans-unit id="c0f8f106115bed98d4438b712b344fc8e65ac7a2" translate="yes" xml:space="preserve">
          <source>UnmarshalCompressed converts a point, serialized by MarshalCompressed, into an x, y pair. It is an error if the point is not in compressed form or is not on the curve. On error, x = nil.</source>
          <target state="translated">UnmarshalCompressed 将一个由 MarshalCompressed 序列化的点转换成一个 x,y 对。如果该点不是以压缩的形式存在,或者不在曲线上,则会出现错误。错误时,x=nil。</target>
        </trans-unit>
        <trans-unit id="a1f2034d1f5318f262d82d2c3d3d1a1f573ff376" translate="yes" xml:space="preserve">
          <source>UnmarshalJSON implements the json.Unmarshaler interface.</source>
          <target state="translated">UnmarshalJSON实现了json.Unmarshaler接口。</target>
        </trans-unit>
        <trans-unit id="ac481b848955fbdb07ec4ed8b1f2094acec90508" translate="yes" xml:space="preserve">
          <source>UnmarshalJSON implements the json.Unmarshaler interface. The time is expected to be a quoted string in RFC 3339 format.</source>
          <target state="translated">UnmarshalJSON实现了json.Unmarshaler接口。时间应该是RFC 3339格式的引号字符串。</target>
        </trans-unit>
        <trans-unit id="501d2e87e0671202c95a53d1a0ea534ac74ed463" translate="yes" xml:space="preserve">
          <source>UnmarshalJSON sets *m to a copy of data.</source>
          <target state="translated">UnmarshalJSON将*m设置为数据的副本。</target>
        </trans-unit>
        <trans-unit id="766c1d65184cba1147b7a3545fa3391dee2740d7" translate="yes" xml:space="preserve">
          <source>UnmarshalText implements the encoding.TextUnmarshaler interface.</source>
          <target state="translated">UnmarshalText实现了encoding.TextUnmarshaler接口。</target>
        </trans-unit>
        <trans-unit id="85ec5d5725d7fc8b15d01b424436803971c310f0" translate="yes" xml:space="preserve">
          <source>UnmarshalText implements the encoding.TextUnmarshaler interface. The IP address is expected in a form accepted by ParseIP.</source>
          <target state="translated">UnmarshalText实现了encoding.TextUnmarshaler接口。IP地址需要以ParseIP接受的形式出现。</target>
        </trans-unit>
        <trans-unit id="131593f7a0c50a040c83c26b3def1697240de177" translate="yes" xml:space="preserve">
          <source>UnmarshalText implements the encoding.TextUnmarshaler interface. The result is rounded per the precision and rounding mode of z. If z's precision is 0, it is changed to 64 before rounding takes effect.</source>
          <target state="translated">UnmarshalText实现了encoding.TextUnmarshaler接口。结果根据z的精度和四舍五入模式进行四舍五入,如果z的精度为0,则在四舍五入生效前将其改为64。</target>
        </trans-unit>
        <trans-unit id="7b15f389f52fa3ed23e4bbf98f836b42c06e5eba" translate="yes" xml:space="preserve">
          <source>UnmarshalText implements the encoding.TextUnmarshaler interface. The time is expected to be in RFC 3339 format.</source>
          <target state="translated">UnmarshalText实现了encoding.TextUnmarshaler接口。时间预计为RFC 3339格式。</target>
        </trans-unit>
        <trans-unit id="6b7f1ab4fc569112930c20562985da8185544c87" translate="yes" xml:space="preserve">
          <source>UnmarshalText must be able to decode the form generated by MarshalText. UnmarshalText must copy the text if it wishes to retain the text after returning.</source>
          <target state="translated">UnmarshalText必须能够解码MarshalText生成的表单。如果UnmarshalText希望在返回后保留文本,它必须复制文本。</target>
        </trans-unit>
        <trans-unit id="bd65d49d42bce927940aedf915c377e4dd09e40d" translate="yes" xml:space="preserve">
          <source>UnmarshalWithParams allows field parameters to be specified for the top-level element. The form of the params is the same as the field tags.</source>
          <target state="translated">UnmarshalWithParams允许为顶层元素指定字段参数。参数的形式与字段标签相同。</target>
        </trans-unit>
        <trans-unit id="b3bf6c68384d3fb37cb6c7555cff99e7fce3bb41" translate="yes" xml:space="preserve">
          <source>UnmarshalXML decodes a single XML element beginning with the given start element. If it returns an error, the outer call to Unmarshal stops and returns that error. UnmarshalXML must consume exactly one XML element. One common implementation strategy is to unmarshal into a separate value with a layout matching the expected XML using d.DecodeElement, and then to copy the data from that value into the receiver. Another common strategy is to use d.Token to process the XML object one token at a time. UnmarshalXML may not use d.RawToken.</source>
          <target state="translated">UnmarshalXML 解码一个从给定的起始元素开始的单个 XML 元素,如果它返回错误,则外部调用 Unmarshal 停止并返回该错误。如果它返回一个错误,对Unmarshal的外部调用会停止并返回该错误。UnmarshalXML必须正好消耗一个XML元素。一个常见的实现策略是使用d.DecodeElement将unmarshal转化为一个单独的值,其布局与预期的XML相匹配,然后将该值中的数据复制到接收器中。另一种常见的策略是使用d.Token一次处理一个token的XML对象。UnmarshalXML可能不会使用d.RawToken。</target>
        </trans-unit>
        <trans-unit id="acecbda4c97cb520576b3b10bc8d83fa35017c1a" translate="yes" xml:space="preserve">
          <source>UnmarshalXMLAttr decodes a single XML attribute. If it returns an error, the outer call to Unmarshal stops and returns that error. UnmarshalXMLAttr is used only for struct fields with the &quot;attr&quot; option in the field tag.</source>
          <target state="translated">UnmarshalXMLAttr解码一个XML属性。如果它返回一个错误,对Unmarshal的外部调用将停止并返回该错误。UnmarshalXMLAttr仅用于字段标签中带有 &quot;attr &quot;选项的结构体字段。</target>
        </trans-unit>
        <trans-unit id="74aa3bc85e3cd4c389b5c2ee32e0f9e728ff011a" translate="yes" xml:space="preserve">
          <source>Unmarshaler is the interface implemented by objects that can unmarshal an XML element description of themselves.</source>
          <target state="translated">Unmarshaler是由对象实现的接口,它可以对自己的XML元素描述进行解密。</target>
        </trans-unit>
        <trans-unit id="da8c67afda9119d4c5ae65e92c29582ea2cf5d56" translate="yes" xml:space="preserve">
          <source>Unmarshaler is the interface implemented by types that can unmarshal a JSON description of themselves. The input can be assumed to be a valid encoding of a JSON value. UnmarshalJSON must copy the JSON data if it wishes to retain the data after returning.</source>
          <target state="translated">Unmarshaler是由类型实现的接口,可以对自己的JSON描述进行解密。输入的内容可以假设为JSON值的有效编码。如果UnmarshalJSON希望在返回后保留数据,那么它必须复制JSON数据。</target>
        </trans-unit>
        <trans-unit id="53e6478e1491aec13688a3a1ab544532e2362899" translate="yes" xml:space="preserve">
          <source>UnmarshalerAttr is the interface implemented by objects that can unmarshal an XML attribute description of themselves.</source>
          <target state="translated">UnmarshalerAttr是由对象实现的接口,它可以对自己的XML属性描述进行解密。</target>
        </trans-unit>
        <trans-unit id="3db9a5e29909b34e2551d8477bb97dce0e5cc013" translate="yes" xml:space="preserve">
          <source>Unquote</source>
          <target state="translated">Unquote</target>
        </trans-unit>
        <trans-unit id="d3b6eaa5a8adda6c17843b82fa332f2940b5c172" translate="yes" xml:space="preserve">
          <source>Unquote and UnquoteChar unquote Go string and rune literals.</source>
          <target state="translated">Unquote和UnquoteChar unquote去串和符文字。</target>
        </trans-unit>
        <trans-unit id="eb183728a78695573a325619f75443a862dbd0b9" translate="yes" xml:space="preserve">
          <source>Unquote interprets s as a single-quoted, double-quoted, or backquoted Go string literal, returning the string value that s quotes. (If s is single-quoted, it would be a Go character literal; Unquote returns the corresponding one-character string.)</source>
          <target state="translated">Unquote 将 s 解释为单引号、双引号或反引号的 Go 字符串,返回 s 引述的字符串值。(如果 s 是单引号,它将是一个围棋字符文字;Unquote 返回相应的单字符字符串。)</target>
        </trans-unit>
        <trans-unit id="944cb633773df2e1ec790dd961a8146fba14fec2" translate="yes" xml:space="preserve">
          <source>UnquoteChar</source>
          <target state="translated">UnquoteChar</target>
        </trans-unit>
        <trans-unit id="29375f10dc5a5623870f8be238ab4c2e02bc8067" translate="yes" xml:space="preserve">
          <source>UnquoteChar decodes the first character or byte in the escaped string or character literal represented by the string s. It returns four values:</source>
          <target state="translated">UnquoteChar对字符串s所代表的转义字符串或字符文字中的第一个字符或字节进行解码,它返回四个值。</target>
        </trans-unit>
        <trans-unit id="b53dd6b78670edea47b93cdb0a942d08f61ad422" translate="yes" xml:space="preserve">
          <source>UnquoteUsage extracts a back-quoted name from the usage string for a flag and returns it and the un-quoted usage. Given &quot;a `name` to show&quot; it returns (&quot;name&quot;, &quot;a name to show&quot;). If there are no back quotes, the name is an educated guess of the type of the flag's value, or the empty string if the flag is boolean.</source>
          <target state="translated">UnquoteUsage从标志的用法字符串中提取一个反引的名称,并返回它和未引的用法。给定 &quot;一个要显示的`名字`&quot;,它就返回(&quot;name&quot;,&quot;a name to show&quot;)。如果没有反引号,这个名字是对标志值类型的有根据的猜测,如果标志是布尔值,则返回空字符串。</target>
        </trans-unit>
        <trans-unit id="31604e0bbb76d839a9e20bc3ad471c203d67835a" translate="yes" xml:space="preserve">
          <source>UnreadByte causes the next call to ReadByte to return the same byte as the previous call to ReadByte. It may be an error to call UnreadByte twice without an intervening call to ReadByte.</source>
          <target state="translated">UnreadByte会使下一次调用ReadByte时返回与上一次调用ReadByte相同的字节。在没有调用ReadByte的情况下,两次调用UnreadByte可能是错误的。</target>
        </trans-unit>
        <trans-unit id="f50817f3bd6d2c35e72fde2b0a932fd55a8206aa" translate="yes" xml:space="preserve">
          <source>UnreadByte complements ReadByte in implementing the io.ByteScanner interface.</source>
          <target state="translated">UnreadByte在实现io.ByteScanner接口时补充了ReadByte。</target>
        </trans-unit>
        <trans-unit id="5f3d5858f8afa80b57a7c212de39d0a9aff8df3f" translate="yes" xml:space="preserve">
          <source>UnreadByte implements the io.ByteScanner interface.</source>
          <target state="translated">UnreadByte实现了io.ByteScanner接口。</target>
        </trans-unit>
        <trans-unit id="77c7dde06491fe4b9339041eb3796382445874b6" translate="yes" xml:space="preserve">
          <source>UnreadByte returns an error if the most recent method called on the Reader was not a read operation. Notably, Peek is not considered a read operation.</source>
          <target state="translated">如果最近一次调用Reader的方法不是读取操作,UnreadByte会返回一个错误。值得注意的是,Peek不被认为是一个读操作。</target>
        </trans-unit>
        <trans-unit id="85bb36da753f37d1b461fc793f6153ef59c80214" translate="yes" xml:space="preserve">
          <source>UnreadByte unreads the last byte returned by the most recent successful read operation that read at least one byte. If a write has happened since the last read, if the last read returned an error, or if the read read zero bytes, UnreadByte returns an error.</source>
          <target state="translated">UnreadByte解读最近一次成功读取至少一个字节的操作所返回的最后一个字节。如果自上次读取后发生了写,如果上次读取返回了错误,或者读取了零字节,UnreadByte将返回一个错误。</target>
        </trans-unit>
        <trans-unit id="965a6610c5d757c591de2c22877d96263eb8aa9d" translate="yes" xml:space="preserve">
          <source>UnreadByte unreads the last byte. Only the most recently read byte can be unread.</source>
          <target state="translated">UnreadByte取消读取最后一个字节。只有最近读过的字节才可以未读。</target>
        </trans-unit>
        <trans-unit id="4b29ee18a300641e642a50770d2b768bae903a75" translate="yes" xml:space="preserve">
          <source>UnreadRune causes the next call to ReadRune to return the same rune as the previous call to ReadRune. It may be an error to call UnreadRune twice without an intervening call to ReadRune.</source>
          <target state="translated">UnreadRune会使下一次对ReadRune的调用返回与上一次对ReadRune的调用相同的符文。在没有中间调用ReadRune的情况下,两次调用UnreadRune可能是一个错误。</target>
        </trans-unit>
        <trans-unit id="53822d24e97f8bde421daa61dcb508cacfde9d9a" translate="yes" xml:space="preserve">
          <source>UnreadRune complements ReadRune in implementing the io.RuneScanner interface.</source>
          <target state="translated">UnreadRune补充ReadRune实现了io.RuneScanner接口。</target>
        </trans-unit>
        <trans-unit id="8842945f04ec11d52129a0fe96a5f0b4f9dd3388" translate="yes" xml:space="preserve">
          <source>UnreadRune implements the io.RuneScanner interface.</source>
          <target state="translated">UnreadRune实现了io.RuneScanner接口。</target>
        </trans-unit>
        <trans-unit id="a4e42f86f3f39d57a5422eae590b939a777bcf43" translate="yes" xml:space="preserve">
          <source>UnreadRune unreads the last rune returned by ReadRune. If the most recent read or write operation on the buffer was not a successful ReadRune, UnreadRune returns an error. (In this regard it is stricter than UnreadByte, which will unread the last byte from any read operation.)</source>
          <target state="translated">UnreadRune解读ReadRune返回的最后一个符文。如果最近一次对缓冲区的读或写操作不是成功的ReadRune,UnreadRune会返回一个错误。(在这方面,它比UnreadByte更严格,UnreadByte将从任何读操作中解读最后一个字节)。</target>
        </trans-unit>
        <trans-unit id="19847ace49c568ee229c8734fba08cf124cc864f" translate="yes" xml:space="preserve">
          <source>UnreadRune unreads the last rune. If the most recent method called on the Reader was not a ReadRune, UnreadRune returns an error. (In this regard it is stricter than UnreadByte, which will unread the last byte from any read operation.)</source>
          <target state="translated">UnreadRune解读最后一个符文。如果最近在Reader上调用的方法不是ReadRune,UnreadRune会返回一个错误。在这方面,它比UnreadByte更严格,后者将从任何读取操作中解读最后一个字节)。</target>
        </trans-unit>
        <trans-unit id="50c3f847c58ba55e1737c9ae778e9a6278576b57" translate="yes" xml:space="preserve">
          <source>UnsafeAddr returns a pointer to v's data. It is for advanced clients that also import the &quot;unsafe&quot; package. It panics if v is not addressable.</source>
          <target state="translated">UnsafeAddr返回一个指向v数据的指针。它适用于同时导入 &quot;unsafe &quot;包的高级客户端。如果v不可寻址,它就会恐慌。</target>
        </trans-unit>
        <trans-unit id="504ce26fbf37c2ede64fba6d4661638e260a1239" translate="yes" xml:space="preserve">
          <source>Unsetenv</source>
          <target state="translated">Unsetenv</target>
        </trans-unit>
        <trans-unit id="182ea105f6e57aa2c2130dff922916a82bfc3855" translate="yes" xml:space="preserve">
          <source>Unsetenv unsets a single environment variable.</source>
          <target state="translated">Unsetenv 取消设置一个环境变量。</target>
        </trans-unit>
        <trans-unit id="5d092e34b5869cce62568374e8b69ed2285d4b5a" translate="yes" xml:space="preserve">
          <source>UnsupportedTypeError is returned when Marshal encounters a type that cannot be converted into XML.</source>
          <target state="translated">当Marshal遇到一个不能转换为XML的类型时,会返回UnsupportedTypeError。</target>
        </trans-unit>
        <trans-unit id="e92f4283009858bf9a4050cedd8fe684e6e6d055" translate="yes" xml:space="preserve">
          <source>Until returns the duration until t. It is shorthand for t.Sub(time.Now()).</source>
          <target state="translated">Until是t.Sub(time.Now())的简写。</target>
        </trans-unit>
        <trans-unit id="90df4c2aff351c99774ec32df813be4f64cfabcd" translate="yes" xml:space="preserve">
          <source>Unwrap returns the result of calling the Unwrap method on err, if err's type contains an Unwrap method returning error. Otherwise, Unwrap returns nil.</source>
          <target state="translated">如果err的类型中包含一个返回error的Unwrap方法,则Unwrap返回调用err上的Unwrap方法的结果。否则,Unwrap返回nil。</target>
        </trans-unit>
        <trans-unit id="0674f5735125e15a98a0dd1cdad0bd08b0642deb" translate="yes" xml:space="preserve">
          <source>Unwrap returns the underlying error.</source>
          <target state="translated">Unwrap返回底层错误。</target>
        </trans-unit>
        <trans-unit id="2facf8e427018a05d97ad6fa738413f526dc52de" translate="yes" xml:space="preserve">
          <source>Unwrap unpacks wrapped errors. If its argument's type has an Unwrap method, it calls the method once. Otherwise, it returns nil.</source>
          <target state="translated">Unwrap解开包装的错误。如果它的参数类型有一个Unwrap方法,它就调用一次该方法。否则,它返回nil。</target>
        </trans-unit>
        <trans-unit id="2a313ddb07d29b1265d5875102d8b2f23477d34a" translate="yes" xml:space="preserve">
          <source>Update replaces an old node in the comment map with the new node and returns the new node. Comments that were associated with the old node are associated with the new node.</source>
          <target state="translated">更新用新节点替换评论地图中的旧节点,并返回新节点。与旧节点相关联的评论会与新节点相关联。</target>
        </trans-unit>
        <trans-unit id="edb9e0c28d17431f4e5d015de98ef6d3ddc2e66d" translate="yes" xml:space="preserve">
          <source>Update returns the result of adding the bytes in p to the crc.</source>
          <target state="translated">更新返回将p中的字节添加到crc的结果。</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="cec856deaea9fb4090c73c99e87c26b997d6e715" translate="yes" xml:space="preserve">
          <source>Usage prints a usage message documenting all defined command-line flags to CommandLine's output, which by default is os.Stderr. It is called when an error occurs while parsing flags. The function is a variable that may be changed to point to a custom function. By default it prints a simple header and calls PrintDefaults; for details about the format of the output and how to control it, see the documentation for PrintDefaults. Custom usage functions may choose to exit the program; by default exiting happens anyway as the command line's error handling strategy is set to ExitOnError.</source>
          <target state="translated">Usage 会将所有定义的命令行标志的使用信息打印到 CommandLine 的输出中,默认为 os.Stderr。当解析标志时发生错误时,它会被调用。该函数是一个变量,可以被修改为指向一个自定义函数。默认情况下,它打印一个简单的头,并调用 PrintDefaults;关于输出的格式和如何控制它的细节,请参阅 PrintDefaults 的文档。自定义使用函数可以选择退出程序;默认情况下,退出还是会发生,因为命令行的错误处理策略被设置为ExitOnError。</target>
        </trans-unit>
        <trans-unit id="08b2986bb9311484289ed77e8cb011bc1a1a4415" translate="yes" xml:space="preserve">
          <source>Use GoTokens to configure the Scanner such that it accepts all Go literal tokens including Go identifiers. Comments will be skipped.</source>
          <target state="translated">使用 GoTokens 配置扫描仪,使其接受所有 Go 字面标记,包括 Go 标识符。注释将被跳过。</target>
        </trans-unit>
        <trans-unit id="e7059998d0ef4d38492eb586594b1a7f2fda5597" translate="yes" xml:space="preserve">
          <source>Use a Scanner to implement a simple word-count utility by scanning the input as a sequence of space-delimited tokens.</source>
          <target state="translated">使用Scanner来实现一个简单的单词计数工具,通过扫描输入作为一个空间限制的标记序列。</target>
        </trans-unit>
        <trans-unit id="c7ed138fa83b46f7078f3eba45cc612903e73703" translate="yes" xml:space="preserve">
          <source>Use a Scanner with a custom split function (built by wrapping ScanWords) to validate 32-bit decimal input.</source>
          <target state="translated">使用带有自定义分割函数(通过包装ScanWords建立)的Scanner来验证32位十进制输入。</target>
        </trans-unit>
        <trans-unit id="a131c39c2cc3965eeb7903a72d441b0e6edc8b39" translate="yes" xml:space="preserve">
          <source>Use a Scanner with a custom split function to parse a comma-separated list with an empty final value.</source>
          <target state="translated">使用带有自定义分割函数的Scanner来解析一个最终值为空的逗号分隔的列表。</target>
        </trans-unit>
        <trans-unit id="3fe5cc9def42296a11d7d9a0af9fc8ea7342706f" translate="yes" xml:space="preserve">
          <source>Use context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions.</source>
          <target state="translated">仅将上下文值用于传递进程和API的请求范围内的数据,而不是用于向函数传递可选参数。</target>
        </trans-unit>
        <trans-unit id="b7726ad2d6a51eae4064f8abdd4f91a30451b9da" translate="yes" xml:space="preserve">
          <source>Use of this type presents a security risk: the encapsulated content should come from a trusted source, as it will be included verbatim in the template output.</source>
          <target state="translated">使用这种类型会带来安全风险:封装的内容应该来自可信的来源,因为它将被逐字包含在模板输出中。</target>
        </trans-unit>
        <trans-unit id="34a9c66123dc40ac60f0472d60867161abcd1901" translate="yes" xml:space="preserve">
          <source>UseNumber causes the Decoder to unmarshal a number into an interface{} as a Number instead of as a float64.</source>
          <target state="translated">UseNumber会使解码器将一个数字作为Number而不是float64解密到接口{}中。</target>
        </trans-unit>
        <trans-unit id="b20930a62f52b49ee0781be625003d945b67da4b" translate="yes" xml:space="preserve">
          <source>User annotation</source>
          <target state="translated">用户注释</target>
        </trans-unit>
        <trans-unit id="fc3da515c7dc35d47639ea550f79310b8bc9a78e" translate="yes" xml:space="preserve">
          <source>User represents a user account.</source>
          <target state="translated">用户代表一个用户账户。</target>
        </trans-unit>
        <trans-unit id="d2b201b196f2c09ea10aa903c6f2d9d3642adbdc" translate="yes" xml:space="preserve">
          <source>User returns a Userinfo containing the provided username and no password set.</source>
          <target state="translated">User返回一个Userinfo,其中包含提供的用户名,没有设置密码。</target>
        </trans-unit>
        <trans-unit id="68b7ed6f3fe5a5fff91e1492620a3db521e39f64" translate="yes" xml:space="preserve">
          <source>UserAgent returns the client's User-Agent, if sent in the request.</source>
          <target state="translated">UserAgent返回客户端的User-Agent(如果在请求中发送)。</target>
        </trans-unit>
        <trans-unit id="4ea06ed977eda51c2aa11c6b438af4cabec784b4" translate="yes" xml:space="preserve">
          <source>UserCacheDir returns the default root directory to use for user-specific cached data. Users should create their own application-specific subdirectory within this one and use that.</source>
          <target state="translated">UserCacheDir返回默认的根目录,用于用户特定的缓存数据。用户应该在这个目录中创建自己的应用程序专用子目录,并使用它。</target>
        </trans-unit>
        <trans-unit id="a2ed520c964d93e9ec6ba0898145eda2b4839b40" translate="yes" xml:space="preserve">
          <source>UserConfigDir returns the default root directory to use for user-specific configuration data. Users should create their own application-specific subdirectory within this one and use that.</source>
          <target state="translated">UserConfigDir 返回默认的根目录,用于用户特定的配置数据。用户应该在这个目录中创建他们自己的应用程序特定的子目录并使用它。</target>
        </trans-unit>
        <trans-unit id="28c75db53e54c3bd7c5a9e9bf84aa07645cd4dd7" translate="yes" xml:space="preserve">
          <source>UserHomeDir returns the current user's home directory.</source>
          <target state="translated">UserHomeDir 返回当前用户的主目录。</target>
        </trans-unit>
        <trans-unit id="e4af3b1e17fb9be937bdb3790d770684874f4388" translate="yes" xml:space="preserve">
          <source>UserPassword returns a Userinfo containing the provided username and password.</source>
          <target state="translated">UserPassword返回一个包含所提供的用户名和密码的Userinfo。</target>
        </trans-unit>
        <trans-unit id="02f3110477b79296b9a835ccdda4c40254dba20b" translate="yes" xml:space="preserve">
          <source>UserTime returns the user CPU time of the exited process and its children.</source>
          <target state="translated">UserTime 返回退出的进程及其子进程的用户 CPU 时间。</target>
        </trans-unit>
        <trans-unit id="596b2947d671a1bd54b3952e3987a478fe9edb86" translate="yes" xml:space="preserve">
          <source>Username returns the username.</source>
          <target state="translated">Username 返回用户名。</target>
        </trans-unit>
        <trans-unit id="dc8f2880e32de7bce1932889e7d7d51c71d3c62a" translate="yes" xml:space="preserve">
          <source>Using GOOS=android matches build tags and files as for GOOS=linux in addition to android tags and files.</source>
          <target state="translated">使用GOOS=android,除了android标签和文件外,还可以匹配GOOS=linux的构建标签和文件。</target>
        </trans-unit>
        <trans-unit id="9ef58be31d291026b75b8271910eb178dd6cbe45" translate="yes" xml:space="preserve">
          <source>Using GOOS=illumos matches build tags and files as for GOOS=solaris in addition to illumos tags and files.</source>
          <target state="translated">使用 GOOS=illumos,除了 illumos 标签和文件外,还匹配了 GOOS=solaris 的构建标签和文件。</target>
        </trans-unit>
        <trans-unit id="c3fe6f0d858556f91b252b308d506eedd3cb2ddd" translate="yes" xml:space="preserve">
          <source>Using JS to include valid but untrusted JSON is not safe. A safe alternative is to parse the JSON with json.Unmarshal and then pass the resultant object into the template, where it will be converted to sanitized JSON when presented in a JavaScript context.</source>
          <target state="translated">使用JS来包含有效但不受信任的JSON是不安全的。一个安全的替代方法是用json.Unmarshal解析JSON,然后将结果对象传递到模板中,当在JavaScript上下文中呈现时,它将被转换为净化的JSON。</target>
        </trans-unit>
        <trans-unit id="9d9125a7eed89278993fd187aca47dc4a1d76ad9" translate="yes" xml:space="preserve">
          <source>Using a nil Qualifier is equivalent to using (*Package).Path: the object is qualified by the import path, e.g., &quot;encoding/json.Marshal&quot;.</source>
          <target state="translated">使用nil限定符相当于使用(*Package).Path:对象由导入路径限定,例如 &quot;encoding/json.Marshal&quot;。</target>
        </trans-unit>
        <trans-unit id="2513c3904b3d8adc521d8c82ea1568602dc6d76b" translate="yes" xml:space="preserve">
          <source>Uvarint</source>
          <target state="translated">Uvarint</target>
        </trans-unit>
        <trans-unit id="cd0cf1cee138a1f47260e7774925bd884f2375a8" translate="yes" xml:space="preserve">
          <source>Uvarint decodes a uint64 from buf and returns that value and the number of bytes read (&amp;gt; 0). If an error occurred, the value is 0 and the number of bytes n is &amp;lt;= 0 meaning:</source>
          <target state="translated">Uvarint从buf解码uint64并返回该值和读取的字节数（&amp;gt; 0）。如果发生错误，则值为0，字节数n为&amp;lt;= 0，表示：</target>
        </trans-unit>
        <trans-unit id="66771bf9a86898929e11d8280264a532271f941a" translate="yes" xml:space="preserve">
          <source>Val</source>
          <target state="translated">Val</target>
        </trans-unit>
        <trans-unit id="2bc81c70eb02eae4099191aef1e57849a8e8f03d" translate="yes" xml:space="preserve">
          <source>Val returns the constant's value.</source>
          <target state="translated">Val返回常量的值。</target>
        </trans-unit>
        <trans-unit id="b0f7ad9f186c50db1236f5511239fa9e5948970e" translate="yes" xml:space="preserve">
          <source>Val returns the underlying value for a given constant. Since it returns an interface, it is up to the caller to type assert the result to the expected type. The possible dynamic return types are:</source>
          <target state="translated">Val返回一个给定常量的基本值。由于它返回的是一个接口,所以调用者要对结果进行类型断言,使其符合预期的类型。可能的动态返回类型有</target>
        </trans-unit>
        <trans-unit id="2559cc6528d308a907426a71ef2ddf45113dcc96" translate="yes" xml:space="preserve">
          <source>Val returns the value associated with attribute Attr in Entry, or nil if there is no such attribute.</source>
          <target state="translated">Val返回与Entry中属性Attr相关联的值,如果没有这个属性,则返回nil。</target>
        </trans-unit>
        <trans-unit id="a4aefa35c3b5ad26cd56f18c500001b89f66a9ce" translate="yes" xml:space="preserve">
          <source>Valid</source>
          <target state="translated">Valid</target>
        </trans-unit>
        <trans-unit id="46c122fc5457cc399b8b858419e492a06b376755" translate="yes" xml:space="preserve">
          <source>Valid reports whether data is a valid JSON encoding.</source>
          <target state="translated">Valid报告数据是否为有效的JSON编码。</target>
        </trans-unit>
        <trans-unit id="806cc965cf7a7b71a612856c03f868243e886f5c" translate="yes" xml:space="preserve">
          <source>Valid reports whether p consists entirely of valid UTF-8-encoded runes.</source>
          <target state="translated">Valid报告p是否完全由有效的UTF-8编码的符文组成。</target>
        </trans-unit>
        <trans-unit id="9519df7a8cc1237bbc29245d3ead17c2ceaba31e" translate="yes" xml:space="preserve">
          <source>ValidPath reports whether the given path name is valid for use in a call to Open.</source>
          <target state="translated">ValidPath报告给定的路径名在调用Open时是否有效。</target>
        </trans-unit>
        <trans-unit id="2c3cda690d8c1884d7b10ef8e13e38f05dfb3167" translate="yes" xml:space="preserve">
          <source>ValidRune</source>
          <target state="translated">ValidRune</target>
        </trans-unit>
        <trans-unit id="3e8899c82439ff69d29e69515b50bcac879155d8" translate="yes" xml:space="preserve">
          <source>ValidRune reports whether r can be legally encoded as UTF-8. Code points that are out of range or a surrogate half are illegal.</source>
          <target state="translated">ValidRune报告r是否可以合法地编码为UTF-8。代码点超出范围或代用半数都是非法的。</target>
        </trans-unit>
        <trans-unit id="a9473e977cedeea3732bd1f0e634158b2fc8bc9c" translate="yes" xml:space="preserve">
          <source>ValidString</source>
          <target state="translated">ValidString</target>
        </trans-unit>
        <trans-unit id="1965e2764de3dba462118d2aa14e90df90d22255" translate="yes" xml:space="preserve">
          <source>ValidString reports whether s consists entirely of valid UTF-8-encoded runes.</source>
          <target state="translated">ValidString报告s是否完全由有效的UTF-8编码符文组成。</target>
        </trans-unit>
        <trans-unit id="c0a9babdac4db73aebddcf7c19ed25ebb45d7a5b" translate="yes" xml:space="preserve">
          <source>Validate performs basic sanity checks on the key. It returns nil if the key is valid, or else an error describing a problem.</source>
          <target state="translated">Validate对密钥进行基本的安全检查。如果密钥是有效的,则返回nil,否则返回一个描述问题的错误。</target>
        </trans-unit>
        <trans-unit id="884a21f08ecc170ab0e83923a5cddfcafa2f19e8" translate="yes" xml:space="preserve">
          <source>Validator may be implemented by Conn to allow drivers to signal if a connection is valid or if it should be discarded.</source>
          <target state="translated">验证器可以由Conn实现,以允许驱动程序发出信号,如果一个连接是有效的,或者是否应该被丢弃。</target>
        </trans-unit>
        <trans-unit id="8dce170de238b1feda2ecd9674ea3ca0d068fbcb" translate="yes" xml:space="preserve">
          <source>Value</source>
          <target state="translated">Value</target>
        </trans-unit>
        <trans-unit id="f3016ae4e1764c831e22db266c9f3792b104f577" translate="yes" xml:space="preserve">
          <source>Value (Config)</source>
          <target state="translated">值(配置)</target>
        </trans-unit>
        <trans-unit id="3b939f106840debe33fe7912aa5a94c4386c469d" translate="yes" xml:space="preserve">
          <source>Value (ReadMostly)</source>
          <target state="translated">值(ReadMostly)</target>
        </trans-unit>
        <trans-unit id="2a2d06d73feadc3e81a5b950d3c3a1578785b1f4" translate="yes" xml:space="preserve">
          <source>Value implements the driver Valuer interface.</source>
          <target state="translated">Value实现了驱动Valuer接口。</target>
        </trans-unit>
        <trans-unit id="dd218fab688fcead8af77b81093aadd12637b021" translate="yes" xml:space="preserve">
          <source>Value is a value that drivers must be able to handle. It is either nil, a type handled by a database driver's NamedValueChecker interface, or an instance of one of these types:</source>
          <target state="translated">Value是一个驱动程序必须能够处理的值,它要么是nil,要么是由数据库驱动程序的NamedValueChecker接口处理的类型,要么是这些类型中的一个实例。它要么是nil,要么是数据库驱动程序的NamedValueChecker接口处理的类型,要么是这些类型中的一个实例。</target>
        </trans-unit>
        <trans-unit id="9752a7f3e66998d9403b579aaf11f5b93a26f7c0" translate="yes" xml:space="preserve">
          <source>Value is the documentation for a (possibly grouped) var or const declaration.</source>
          <target state="translated">值是一个(可能是分组的)var或const声明的文档。</target>
        </trans-unit>
        <trans-unit id="fc8bc38b52edf0162032e19caad204a132e1edc6" translate="yes" xml:space="preserve">
          <source>Value is the interface to the dynamic value stored in a flag. (The default value is represented as a string.)</source>
          <target state="translated">Value是存储在标志中的动态值的接口。默认值用字符串表示)。</target>
        </trans-unit>
        <trans-unit id="2c289f13fb553c52397f1f031c283edf2f75ba5d" translate="yes" xml:space="preserve">
          <source>Value is the reflection interface to a Go value.</source>
          <target state="translated">值是围棋值的反映接口。</target>
        </trans-unit>
        <trans-unit id="f874cfa2eae8a5288d6bb67626a8a5b202b1f1d3" translate="yes" xml:space="preserve">
          <source>Value represents a JavaScript value. The zero value is the JavaScript value &quot;undefined&quot;.</source>
          <target state="translated">Value代表一个JavaScript值。零值是JavaScript值 &quot;undefined&quot;。</target>
        </trans-unit>
        <trans-unit id="12bd1222cbe13b8343d523bcfbb727dc870d622e" translate="yes" xml:space="preserve">
          <source>Value represents a JavaScript value. The zero value is the JavaScript value &quot;undefined&quot;. Values can be checked for equality with the Equal method.</source>
          <target state="translated">Value代表一个JavaScript值。零值是JavaScript值 &quot;undefined&quot;。可以用Equal方法检查值是否相等。</target>
        </trans-unit>
        <trans-unit id="678d207a532dcdea8e626b9a2f73dbb88876a486" translate="yes" xml:space="preserve">
          <source>Value represents a metric value returned by the runtime.</source>
          <target state="translated">值代表运行时返回的度量值。</target>
        </trans-unit>
        <trans-unit id="bea9dc918e0d02a53c6ed34890033d051d6e5b45" translate="yes" xml:space="preserve">
          <source>Value returns an arbitrary value of the given type. If the type implements the Generator interface, that will be used. Note: To create arbitrary values for structs, all the fields must be exported.</source>
          <target state="translated">Value 返回给定类型的任意值。如果该类型实现了Generator接口,则将使用该接口。注意:要为结构体创建任意值,必须导出所有的字段。</target>
        </trans-unit>
        <trans-unit id="010d442068b6dc0c175fb3be2478e451331b7772" translate="yes" xml:space="preserve">
          <source>Value returns the value of the iterator's current map entry.</source>
          <target state="translated">Value 返回迭代器当前地图条目的值。</target>
        </trans-unit>
        <trans-unit id="4814e1e8c0abd0c5b67abd9fa764cdfa19868250" translate="yes" xml:space="preserve">
          <source>ValueConverter is the interface providing the ConvertValue method.</source>
          <target state="translated">ValueConverter是提供ConvertValue方法的接口。</target>
        </trans-unit>
        <trans-unit id="bfff933f54248b785748322ae516a5abd89e358e" translate="yes" xml:space="preserve">
          <source>ValueKind is a tag for a metric Value which indicates its type.</source>
          <target state="translated">ValueKind是度量值的标签,表示其类型。</target>
        </trans-unit>
        <trans-unit id="4ee806fbc08f89d25017504477016f81d87178b9" translate="yes" xml:space="preserve">
          <source>ValueOf returns a new Value initialized to the concrete value stored in the interface i. ValueOf(nil) returns the zero Value.</source>
          <target state="translated">ValueOf(nil)返回一个新的Value,初始化为存储在接口i中的具体值。ValueOf(nil)返回零值。</target>
        </trans-unit>
        <trans-unit id="73fa7582a50fd6ffa7153d229b6170f753731b5a" translate="yes" xml:space="preserve">
          <source>ValueOf returns x as a JavaScript value:</source>
          <target state="translated">ValueOf返回x作为JavaScript值。</target>
        </trans-unit>
        <trans-unit id="f18975e8d6052ff98ae55792b39100c67475c7da" translate="yes" xml:space="preserve">
          <source>Valuer is the interface providing the Value method.</source>
          <target state="translated">Valuer是提供Value方法的接口。</target>
        </trans-unit>
        <trans-unit id="b1564f6b1512cbfa3cfcebc9a5badb6b239954f1" translate="yes" xml:space="preserve">
          <source>Values</source>
          <target state="translated">Values</target>
        </trans-unit>
        <trans-unit id="4c4b32df8b9b0ab6cff257dc64ed3eb643572b49" translate="yes" xml:space="preserve">
          <source>Values containing the types defined in this package should not be copied.</source>
          <target state="translated">包含本包中定义的类型的值不应被复制。</target>
        </trans-unit>
        <trans-unit id="db0f016ee293f8c7fb961ef81d6b041a8271fcde" translate="yes" xml:space="preserve">
          <source>Values maps a string key to a list of values. It is typically used for query parameters and form values. Unlike in the http.Header map, the keys in a Values map are case-sensitive.</source>
          <target state="translated">Values将一个字符串键映射到一个值的列表。它通常用于查询参数和表单值。与 http.Header 映射不同,Values 映射中的键是区分大小写的。</target>
        </trans-unit>
        <trans-unit id="ed9ae6e1ddce7aa950c188cea7070152cbaaef3a" translate="yes" xml:space="preserve">
          <source>Values of IMAGE_FILE_HEADER.Characteristics. These can be combined together.</source>
          <target state="translated">IMAGE_FILE_HEADER.Characteristics的值。这些值可以组合在一起。</target>
        </trans-unit>
        <trans-unit id="e1b6d5f206af70bb39bd5fc526ef574743992a54" translate="yes" xml:space="preserve">
          <source>Values of the Image interface are created either by calling functions such as NewRGBA and NewPaletted, or by calling Decode on an io.Reader containing image data in a format such as GIF, JPEG or PNG. Decoding any particular image format requires the prior registration of a decoder function. Registration is typically automatic as a side effect of initializing that format's package so that, to decode a PNG image, it suffices to have</source>
          <target state="translated">Image接口的值是通过调用NewRGBA和NewPaletted等函数来创建的,或者通过在包含GIF、JPEG或PNG等格式的图像数据的io.Reader上调用Decode来创建的。解码任何特定的图像格式都需要事先注册一个解码器函数。注册通常是自动的,作为初始化该格式的包的一个副作用,因此,要解码一个PNG图像,只需有以下功能即可</target>
        </trans-unit>
        <trans-unit id="b65743fb1655a6d5656fe5188b8219e485d45a6c" translate="yes" xml:space="preserve">
          <source>Values returns all values associated with the given key. It is case insensitive; CanonicalMIMEHeaderKey is used to canonicalize the provided key. To use non-canonical keys, access the map directly. The returned slice is not a copy.</source>
          <target state="translated">Values返回与给定key相关联的所有值。它不区分大小写;CanonicalMIMEHeaderKey用于规范化所提供的密钥。要使用非规范键,直接访问映射。返回的分片不是副本。</target>
        </trans-unit>
        <trans-unit id="d0f032ed754eb781ca5f1ab9c0d5896202022c92" translate="yes" xml:space="preserve">
          <source>Values returns all values associated with the given key. It is case insensitive; textproto.CanonicalMIMEHeaderKey is used to canonicalize the provided key. To use non-canonical keys, access the map directly. The returned slice is not a copy.</source>
          <target state="translated">Values 返回与给定键相关的所有值。它不区分大小写;textproto.CanonicalMIMEHeaderKey用于规范化给定的键。要使用非规范键,直接访问映射。返回的分片不是副本。</target>
        </trans-unit>
        <trans-unit id="556542fae1b8220ad354f73db7960fdf03643304" translate="yes" xml:space="preserve">
          <source>Values that are shared by both R_PPC and R_PPC64 are prefixed with R_POWERPC_ in the ELF standard. For the R_PPC type, the relevant shared relocations have been renamed with the prefix R_PPC_. The original name follows the value in a comment.</source>
          <target state="translated">在ELF标准中,R_PPC和R_PPC64共享的值以R_POWERPC_为前缀。对于R_PPC类型,相关的共享重定位已经用前缀R_PPC_重新命名。原来的名称在注释中的值后面。</target>
        </trans-unit>
        <trans-unit id="35513df4822daf6991ea9831d940cbcb44ab9510" translate="yes" xml:space="preserve">
          <source>Values that are shared by both R_PPC and R_PPC64 are prefixed with R_POWERPC_ in the ELF standard. For the R_PPC64 type, the relevant shared relocations have been renamed with the prefix R_PPC64_. The original name follows the value in a comment.</source>
          <target state="translated">在ELF标准中,R_PPC和R_PPC64共享的值以R_POWERPC_为前缀。对于R_PPC64类型,相关的共享重定位已经用前缀R_PPC64_重新命名。原来的名称在注释中的值后面。</target>
        </trans-unit>
        <trans-unit id="5491dd2526a7b6a12fe2eb7a45fdc97e08387c1a" translate="yes" xml:space="preserve">
          <source>Var defines a flag with the specified name and usage string. The type and value of the flag are represented by the first argument, of type Value, which typically holds a user-defined implementation of Value. For instance, the caller could create a flag that turns a comma-separated string into a slice of strings by giving the slice the methods of Value; in particular, Set would decompose the comma-separated string into the slice.</source>
          <target state="translated">Var定义了一个具有指定名称和用法字符串的标志。标志的类型和值由第一个参数表示,类型为Value,它通常持有用户定义的Value的实现。例如,调用者可以创建一个标志,通过给分片Value的方法,将一个逗号分隔的字符串变成一个分片的字符串;特别是,Set将把逗号分隔的字符串分解到分片中。</target>
        </trans-unit>
        <trans-unit id="ce2b2698fd744904596b638fadb24e9ac560ff55" translate="yes" xml:space="preserve">
          <source>Var is an abstract type for all exported variables.</source>
          <target state="translated">Var是所有导出变量的抽象类型。</target>
        </trans-unit>
        <trans-unit id="2fe39193f9c048f94aabb561a65b8ad4ebd4664a" translate="yes" xml:space="preserve">
          <source>VariableNode holds a list of variable names, possibly with chained field accesses. The dollar sign is part of the (first) name.</source>
          <target state="translated">VariableNode持有一个变量名的列表,可能有链式字段访问。美元符号是(第一个)名称的一部分。</target>
        </trans-unit>
        <trans-unit id="ac018db1f7b00972061adff843d37497d8ee153c" translate="yes" xml:space="preserve">
          <source>Variables</source>
          <target state="translated">Variables</target>
        </trans-unit>
        <trans-unit id="f9c863db27e83db40f4468fc4bc690e601042fdf" translate="yes" xml:space="preserve">
          <source>Variables previously declared can also be assigned, using the syntax</source>
          <target state="translated">之前声明的变量也可以被分配,使用的语法是</target>
        </trans-unit>
        <trans-unit id="ca11a0cc5def9c210a74faf8ede1798e07fe2571" translate="yes" xml:space="preserve">
          <source>Variadic reports whether the signature s is variadic.</source>
          <target state="translated">Variadic报告签名s是否为可变的。</target>
        </trans-unit>
        <trans-unit id="41d79747265706c0afa494f13a1d7304f4478119" translate="yes" xml:space="preserve">
          <source>Varint</source>
          <target state="translated">Varint</target>
        </trans-unit>
        <trans-unit id="f5ebfb0ae8769b5ca2188331b009d7eba5a85341" translate="yes" xml:space="preserve">
          <source>Varint decodes an int64 from buf and returns that value and the number of bytes read (&amp;gt; 0). If an error occurred, the value is 0 and the number of bytes n is &amp;lt;= 0 with the following meaning:</source>
          <target state="translated">Varint从buf解码int64并返回该值和读取的字节数（&amp;gt; 0）。如果发生错误，则值为0，字节数n为&amp;lt;= 0，含义如下：</target>
        </trans-unit>
        <trans-unit id="d24fa62b1d834d7cd3cd0e8882051f85d094eda3" translate="yes" xml:space="preserve">
          <source>Various errors contained in OpError.</source>
          <target state="translated">OpError中包含的各种错误。</target>
        </trans-unit>
        <trans-unit id="1a2978dcc531a211271eca6e53e9367381806a65" translate="yes" xml:space="preserve">
          <source>Various implementations of ValueConverter are provided by the driver package to provide consistent implementations of conversions between drivers. The ValueConverters have several uses:</source>
          <target state="translated">驱动程序包提供了ValueConverter的各种实现,以提供驱动程序之间转换的一致实现。ValueConverters有几种用途。</target>
        </trans-unit>
        <trans-unit id="677405d5dfca724a737bda64c6dc1ddb03f2bb84" translate="yes" xml:space="preserve">
          <source>Various isolation levels that drivers may support in BeginTx. If a driver does not support a given isolation level an error may be returned.</source>
          <target state="translated">BeginTx中的驱动程序可能支持的各种隔离级别。如果一个驱动程序不支持给定的隔离级别,则可能会返回一个错误。</target>
        </trans-unit>
        <trans-unit id="cc21bbee9a9b0425c95545ecf2f53bc29369d55b" translate="yes" xml:space="preserve">
          <source>Various methods support conversions between strings and corresponding numeric values, and vice versa: *Int, *Rat, and *Float values implement the Stringer interface for a (default) string representation of the value, but also provide SetString methods to initialize a value from a string in a variety of supported formats (see the respective SetString documentation).</source>
          <target state="translated">各种方法支持字符串和相应的数值之间的转换,反之亦然。*Int、*Rat和*Float值实现了Stringer接口,用于(默认)数值的字符串表示,但也提供了SetString方法,以各种支持的格式从字符串中初始化数值(见各自的SetString文档)。</target>
        </trans-unit>
        <trans-unit id="fe5502979be4e45317e06e3f4bc8dea3c27b9d68" translate="yes" xml:space="preserve">
          <source>Verbose reports whether the -test.v flag is set.</source>
          <target state="translated">Verbose报告是否设置了-test.v标志。</target>
        </trans-unit>
        <trans-unit id="155a05e64e4d5e6d0dbf5afad455ef4b2c7d215e" translate="yes" xml:space="preserve">
          <source>Verify attempts to verify c by building one or more chains from c to a certificate in opts.Roots, using certificates in opts.Intermediates if needed. If successful, it returns one or more chains where the first element of the chain is c and the last element is from opts.Roots.</source>
          <target state="translated">验证试图通过建立一个或多个从c到opts.Root中的证书的链来验证c,必要时使用opts.Intermediates中的证书。如果成功,它将返回一个或多个链,链的第一个元素是c,最后一个元素来自opts.Root。</target>
        </trans-unit>
        <trans-unit id="8f646662ac01cb1ef7a3f3dbe169c861f558bcfa" translate="yes" xml:space="preserve">
          <source>Verify checks the validity of an email address on the server. If Verify returns nil, the address is valid. A non-nil return does not necessarily indicate an invalid address. Many servers will not verify addresses for security reasons.</source>
          <target state="translated">Verify检查服务器上电子邮件地址的有效性。如果Verify返回nil,则说明该地址有效。非零的返回值不一定是一个无效的地址。许多服务器出于安全考虑不会验证地址。</target>
        </trans-unit>
        <trans-unit id="5f78fb77229812b310f6d30ba2f8eeb1a758e0db" translate="yes" xml:space="preserve">
          <source>Verify reports whether sig is a valid signature of message by publicKey. It will panic if len(publicKey) is not PublicKeySize.</source>
          <target state="translated">验证报告sig是否是消息的有效签名,通过publicKey。如果len(publicKey)不是PublicKeySize,它将恐慌。</target>
        </trans-unit>
        <trans-unit id="afa19e9e5042f2e1366a51a651d0d42c62c9a9dc" translate="yes" xml:space="preserve">
          <source>Verify verifies the signature in r, s of hash using the public key, pub. It reports whether the signature is valid.</source>
          <target state="translated">验证使用公钥pub对哈希的r,s中的签名进行验证。它报告签名是否有效。</target>
        </trans-unit>
        <trans-unit id="29e311050b6e4da19e97375079ff2944ac6c7fb5" translate="yes" xml:space="preserve">
          <source>Verify verifies the signature in r, s of hash using the public key, pub. Its return value records whether the signature is valid.</source>
          <target state="translated">验证使用公钥pub对哈希的r,s中的签名进行验证。它的返回值记录了签名是否有效。</target>
        </trans-unit>
        <trans-unit id="145232aacf42696b4e278956de6bab24512004cd" translate="yes" xml:space="preserve">
          <source>VerifyASN1 verifies the ASN.1 encoded signature, sig, of hash using the public key, pub. Its return value records whether the signature is valid.</source>
          <target state="translated">VerifyASN1使用公钥pub验证哈希的ASN.1编码签名sig。它的返回值记录了签名是否有效。</target>
        </trans-unit>
        <trans-unit id="c77ce67480dc146ec9f71541bb8eac40755f84ee" translate="yes" xml:space="preserve">
          <source>VerifyHostname checks that the peer certificate chain is valid for connecting to host. If so, it returns nil; if not, it returns an error describing the problem.</source>
          <target state="translated">VerifyHostname检查对等体证书链是否对连接到主机有效。如果有效,则返回nil;如果无效,则返回一个描述问题的错误。</target>
        </trans-unit>
        <trans-unit id="4d87443c0e8c5a2665736c35fe304b37073dc32e" translate="yes" xml:space="preserve">
          <source>VerifyHostname returns nil if c is a valid certificate for the named host. Otherwise it returns an error describing the mismatch.</source>
          <target state="translated">如果 c 是指定主机的有效证书,VerifyHostname 返回 nil。否则,它会返回一个错误,描述不匹配的情况。</target>
        </trans-unit>
        <trans-unit id="f86ef4530b45b573b44981bfecb27623cddb836c" translate="yes" xml:space="preserve">
          <source>VerifyOptions contains parameters for Certificate.Verify.</source>
          <target state="translated">VerifyOptions 包含 Certificate.Verify 的参数。</target>
        </trans-unit>
        <trans-unit id="3cca137a6af7f592d32076ad3b96f2dd532d13e4" translate="yes" xml:space="preserve">
          <source>VerifyOptions contains parameters for Certificate.Verify. It's a structure because other PKIX verification APIs have ended up needing many options.</source>
          <target state="translated">VerifyOptions 包含 Certificate.Verify 的参数。这是一个结构,因为其他PKIX验证API最后需要很多选项。</target>
        </trans-unit>
        <trans-unit id="904631d00687a7288866da49169708056e59b147" translate="yes" xml:space="preserve">
          <source>VerifyPKCS1v15</source>
          <target state="translated">VerifyPKCS1v15</target>
        </trans-unit>
        <trans-unit id="03648c01c4f8ec482385a7d7d5a6f43278916d7d" translate="yes" xml:space="preserve">
          <source>VerifyPKCS1v15 verifies an RSA PKCS #1 v1.5 signature. hashed is the result of hashing the input message using the given hash function and sig is the signature. A valid signature is indicated by returning a nil error. If hash is zero then hashed is used directly. This isn't advisable except for interoperability.</source>
          <target state="translated">VerifyPKCS1v15 验证 RSA PKCS #1 v1.5 签名。hash 是使用给定的散列函数对输入信息进行散列的结果,sig 是签名。一个有效的签名是通过返回一个nil错误来表示的。如果hash为0,则直接使用hash。这并不可取,除非是为了互操作性。</target>
        </trans-unit>
        <trans-unit id="7fac2ac8cef2b4f2fce0053008362560cd0a7f6f" translate="yes" xml:space="preserve">
          <source>VerifyPKCS1v15 verifies an RSA PKCS#1 v1.5 signature. hashed is the result of hashing the input message using the given hash function and sig is the signature. A valid signature is indicated by returning a nil error. If hash is zero then hashed is used directly. This isn't advisable except for interoperability.</source>
          <target state="translated">VerifyPKCS1v15 验证 RSA PKCS#1 v1.5 的签名,hash 是使用给定的散列函数对输入信息进行散列的结果,sig 是签名。一个有效的签名是通过返回一个nil错误来表示的。如果hash为0,则直接使用hash。这并不可取,除非是为了互操作性。</target>
        </trans-unit>
        <trans-unit id="22849df5c99a08214a361cc786e111d1f4ddafec" translate="yes" xml:space="preserve">
          <source>VerifyPSS verifies a PSS signature.</source>
          <target state="translated">VerifyPSS验证PSS签名。</target>
        </trans-unit>
        <trans-unit id="a12022e4f1f957db46b6ad31ae0c6d8b5b335f06" translate="yes" xml:space="preserve">
          <source>VerifyPSS verifies a PSS signature. hashed is the result of hashing the input message using the given hash function and sig is the signature. A valid signature is indicated by returning a nil error. The opts argument may be nil, in which case sensible defaults are used.</source>
          <target state="translated">VerifyPSS 验证 PSS 签名。hash 是使用给定的散列函数对输入消息进行散列的结果,sig 是签名。一个有效的签名会以返回一个nil错误来表示。opts参数可能是nil,在这种情况下,会使用合理的默认值。</target>
        </trans-unit>
        <trans-unit id="fc50bdb16e95dd81d5ab93336a4873d743e71e10" translate="yes" xml:space="preserve">
          <source>Version is found in Header.Ident[EI_VERSION] and Header.Version.</source>
          <target state="translated">版本在Header.Ident[EI_VERSION]和Header.Version中找到。</target>
        </trans-unit>
        <trans-unit id="4d5c372788d86ffb1bb307fe18c33d0d35dfaf32" translate="yes" xml:space="preserve">
          <source>Version is the Unicode edition from which the tables are derived.</source>
          <target state="translated">版本是Unicode版本,这些表格是由Unicode版本衍生出来的。</target>
        </trans-unit>
        <trans-unit id="50de89df378f68937423c4c0b0df29cc9d671898" translate="yes" xml:space="preserve">
          <source>Version returns the Go tree's version string. It is either the commit hash and date at the time of the build or, when possible, a release tag like &quot;go1.3&quot;.</source>
          <target state="translated">Version 返回 Go 树的版本字符串。它是构建时的提交哈希和日期,或者在可能的情况下,是一个发布标签,如 &quot;go1.3&quot;。</target>
        </trans-unit>
        <trans-unit id="a9f8b9e002c84b093e85fe6340e9e2446c0f01f6" translate="yes" xml:space="preserve">
          <source>Very large values overflow to -1 or +Inf.</source>
          <target state="translated">非常大的值溢出到-1或+Inf。</target>
        </trans-unit>
        <trans-unit id="62ec9d14e878063c7140d04d700991af277e0332" translate="yes" xml:space="preserve">
          <source>Very large values overflow to 0 or +Inf. Very small values underflow to 1.</source>
          <target state="translated">非常大的值溢出到0或+Inf.,非常小的值溢出到1。非常小的值下溢为1。</target>
        </trans-unit>
        <trans-unit id="548f7438120baf452d57249c7ed1e4259eddd666" translate="yes" xml:space="preserve">
          <source>Visit visits the command-line flags in lexicographical order, calling fn for each. It visits only those flags that have been set.</source>
          <target state="translated">访问按词典顺序访问命令行标志,对每个标志调用fn。它只访问那些已经设置的标志。</target>
        </trans-unit>
        <trans-unit id="3d71d97888658f2741fa47ca0e6dafd3ee5bd8d5" translate="yes" xml:space="preserve">
          <source>Visit visits the flags in lexicographical order, calling fn for each. It visits only those flags that have been set.</source>
          <target state="translated">访问按词法顺序访问旗帜,对每个旗帜调用fn。它只访问那些已经设置的标志。</target>
        </trans-unit>
        <trans-unit id="fe139ba7798500e37c921c3f2eca473d92def875" translate="yes" xml:space="preserve">
          <source>VisitAll visits the command-line flags in lexicographical order, calling fn for each. It visits all flags, even those not set.</source>
          <target state="translated">VisitAll 按词典顺序访问命令行标志,对每个标志调用 fn。它访问所有的标志,即使是那些没有设置的标志。</target>
        </trans-unit>
        <trans-unit id="91926cb218ad9a9f08c7f40210f9b3b594b76515" translate="yes" xml:space="preserve">
          <source>VisitAll visits the flags in lexicographical order, calling fn for each. It visits all flags, even those not set.</source>
          <target state="translated">VisitAll 按词法顺序访问标志,对每个标志调用 fn。它访问所有的标志,即使是那些没有设置的标志。</target>
        </trans-unit>
        <trans-unit id="82b27aedf84d8e8a368898854887f1a9db2938b6" translate="yes" xml:space="preserve">
          <source>VolumeName returns leading volume name. Given &quot;C:\foo\bar&quot; it returns &quot;C:&quot; on Windows. Given &quot;\\host\share\foo&quot; it returns &quot;\\host\share&quot;. On other platforms it returns &quot;&quot;.</source>
          <target state="translated">VolumeName返回前面的卷名。给定 &quot;C:\foo\bar&quot;,在Windows上返回 &quot;C:&quot;。给定&quot;\host\share\foo&quot;,它返回&quot;\host\share&quot;。在其他平台上,它返回&quot;&quot;。</target>
        </trans-unit>
        <trans-unit id="116af4a220931a113874c3a9a8fb8b67e737c229" translate="yes" xml:space="preserve">
          <source>WARNING: this function doesn't do any revocation checking.</source>
          <target state="translated">警告:这个函数不做任何撤销检查。</target>
        </trans-unit>
        <trans-unit id="ac3ed0238ed01e1e125ce49b809e2689db256bfa" translate="yes" xml:space="preserve">
          <source>WARNING: use of this function to encrypt plaintexts other than session keys is dangerous. Use RSA OAEP in new protocols.</source>
          <target state="translated">警告:使用该函数加密会话密钥以外的明文是危险的。在新协议中使用RSA OAEP。</target>
        </trans-unit>
        <trans-unit id="d791440e471e57ef06317ea366a55351a6722e8d" translate="yes" xml:space="preserve">
          <source>Wait atomically unlocks c.L and suspends execution of the calling goroutine. After later resuming execution, Wait locks c.L before returning. Unlike in other systems, Wait cannot return unless awoken by Broadcast or Signal.</source>
          <target state="translated">Wait原子性地解锁c.L并暂停执行调用的goroutine。之后恢复执行后,Wait在返回前锁定c.L。与其他系统不同,除非被Broadcast或Signal唤醒,否则Wait不能返回。</target>
        </trans-unit>
        <trans-unit id="c1e4ec07809f552042a2744ebd76a1ff9cdfd927" translate="yes" xml:space="preserve">
          <source>Wait blocks until the WaitGroup counter is zero.</source>
          <target state="translated">等待块,直到WaitGroup计数器为零。</target>
        </trans-unit>
        <trans-unit id="a2b93a450c159447eb449f1d44b9509d23d1eff8" translate="yes" xml:space="preserve">
          <source>Wait releases any resources associated with the Cmd.</source>
          <target state="translated">等待释放与Cmd相关的任何资源。</target>
        </trans-unit>
        <trans-unit id="cecb6db143b18629c77edfdcfa6e40a828bd3ecd" translate="yes" xml:space="preserve">
          <source>Wait waits for the Process to exit, and then returns a ProcessState describing its status and an error, if any. Wait releases any resources associated with the Process. On most operating systems, the Process must be a child of the current process or an error will be returned.</source>
          <target state="translated">Wait等待进程退出,然后返回一个描述其状态的ProcessState和一个错误(如果有)。Wait会释放与Process相关的任何资源。在大多数操作系统上,进程必须是当前进程的子进程,否则将返回一个错误。</target>
        </trans-unit>
        <trans-unit id="ef4d163f70a5558cd92581c6468ca54f951f10cb" translate="yes" xml:space="preserve">
          <source>Wait waits for the command to exit and waits for any copying to stdin or copying from stdout or stderr to complete.</source>
          <target state="translated">等待等待命令退出,并等待任何复制到stdin或从stdout或stderr复制完成。</target>
        </trans-unit>
        <trans-unit id="aea382006d640fdfa58d59c1e0ad39798008158f" translate="yes" xml:space="preserve">
          <source>Wait will close the pipe after seeing the command exit, so most callers need not close the pipe themselves. It is thus incorrect to call Wait before all reads from the pipe have completed. For the same reason, it is incorrect to call Run when using StdoutPipe. See the example for idiomatic usage.</source>
          <target state="translated">Wait会在看到命令退出后关闭管道,所以大多数调用者不需要自己关闭管道。因此,在管道的所有读取完成之前调用Wait是不正确的。出于同样的原因,在使用StdoutPipe时调用Run也是不正确的。参见示例中的习惯用法。</target>
        </trans-unit>
        <trans-unit id="4d3243a3ead84d3a842320a1e7a6c5fbcf29075e" translate="yes" xml:space="preserve">
          <source>Wait will close the pipe after seeing the command exit, so most callers need not close the pipe themselves. It is thus incorrect to call Wait before all reads from the pipe have completed. For the same reason, it is incorrect to use Run when using StderrPipe. See the StdoutPipe example for idiomatic usage.</source>
          <target state="translated">Wait会在看到命令退出后关闭管道,所以大多数调用者不需要自己关闭管道。因此,在管道的所有读取完成之前调用Wait是不正确的。出于同样的原因,在使用StderrPipe时使用Run也是不正确的。请参阅 StdoutPipe 示例了解其习惯用法。</target>
        </trans-unit>
        <trans-unit id="e61dcf7176445918332c5c75e515641021cd367b" translate="yes" xml:space="preserve">
          <source>Wait will close the pipe after seeing the command exit, so most callers need not close the pipe themselves; however, an implication is that it is incorrect to call Wait before all reads from the pipe have completed. For the same reason, it is incorrect to call Run when using StdoutPipe. See the example for idiomatic usage.</source>
          <target state="translated">Wait会在看到命令退出后关闭管道,所以大多数调用者不需要自己关闭管道;但是,一个意思是,在管道的所有读取完成之前调用Wait是不正确的。出于同样的原因,在使用StdoutPipe时调用Run是不正确的。参见示例中的习惯用法。</target>
        </trans-unit>
        <trans-unit id="6e2d628a299984437542474f102b1e387913aa4f" translate="yes" xml:space="preserve">
          <source>Wait will close the pipe after seeing the command exit, so most callers need not close the pipe themselves; however, an implication is that it is incorrect to call Wait before all reads from the pipe have completed. For the same reason, it is incorrect to use Run when using StderrPipe. See the StdoutPipe example for idiomatic usage.</source>
          <target state="translated">Wait会在看到命令退出后关闭管道,所以大多数调用者不需要自己关闭管道;但是,一个含义是,在管道的所有读取完成之前调用Wait是不正确的。出于同样的原因,在使用StderrPipe时使用Run是不正确的。参见StdoutPipe的例子,了解其习惯用法。</target>
        </trans-unit>
        <trans-unit id="66edd56a29d8f65f00197517346652171bdf474e" translate="yes" xml:space="preserve">
          <source>WaitGroup</source>
          <target state="translated">WaitGroup</target>
        </trans-unit>
        <trans-unit id="e0c705d18e3fae4506d7273bda6435690cdbde08" translate="yes" xml:space="preserve">
          <source>Walk</source>
          <target state="translated">Walk</target>
        </trans-unit>
        <trans-unit id="52552b817eeffba362a3c98137f71c8293e62c3c" translate="yes" xml:space="preserve">
          <source>Walk calls the function with a non-nil err argument in two cases.</source>
          <target state="translated">Walk在两种情况下调用带有非nil err参数的函数。</target>
        </trans-unit>
        <trans-unit id="d9374260d790571a0abca3c2ad0ee8f4b2fee093" translate="yes" xml:space="preserve">
          <source>Walk does not follow symbolic links.</source>
          <target state="translated">步行不遵循符号链接。</target>
        </trans-unit>
        <trans-unit id="29ff2f8a0272ea96bdd57633837c4d9205c5c003" translate="yes" xml:space="preserve">
          <source>Walk is less efficient than WalkDir, introduced in Go 1.16, which avoids calling os.Lstat on every visited file or directory.</source>
          <target state="translated">Walk的效率比Go 1.16中引入的WalkDir要低,它避免了在每一个被访问的文件或目录上调用os.Lstat。</target>
        </trans-unit>
        <trans-unit id="9272862a0570cd3c8a576242d0e65b3cfcf9dde3" translate="yes" xml:space="preserve">
          <source>Walk traverses an AST in depth-first order: It starts by calling v.Visit(node); node must not be nil. If the visitor w returned by v.Visit(node) is not nil, Walk is invoked recursively with visitor w for each of the non-nil children of node, followed by a call of w.Visit(nil).</source>
          <target state="translated">Walk以深度优先的顺序遍历一个AST,它通过调用v.Visit(node)开始,node必须不是nil。它首先调用v.Visit(node);node不能是nil.如果v.Visit(node)返回的访问者w不是nil,Walk就会对node的每一个非nil的子节点递归调用访问者w。如果v.Visit(node)返回的访问者w不是nil,那么Walk将对node的每个非nil子节点递归调用访问者w,然后调用w.Visit(nil)。</target>
        </trans-unit>
        <trans-unit id="448218872286b5074a9a3f4fa32510a7919bca39" translate="yes" xml:space="preserve">
          <source>Walk walks the file tree rooted at root, calling fn for each file or directory in the tree, including root.</source>
          <target state="translated">Walk行走以根为根的文件树,对树中的每个文件或目录(包括根)调用fn。</target>
        </trans-unit>
        <trans-unit id="844997b7d380cfffe958c2b4b63e117129683358" translate="yes" xml:space="preserve">
          <source>Walk walks the file tree rooted at root, calling walkFn for each file or directory in the tree, including root. All errors that arise visiting files and directories are filtered by walkFn. The files are walked in lexical order, which makes the output deterministic but means that for very large directories Walk can be inefficient. Walk does not follow symbolic links.</source>
          <target state="translated">Walk走过以根为根的文件树,对树上的每个文件或目录(包括根)调用 walkFn。所有在访问文件和目录时产生的错误都会被 walkFn 过滤掉。文件是按词法顺序走的,这使得输出是确定性的,但这意味着对于非常大的目录,Walk的效率会很低。Walk不遵循符号链接。</target>
        </trans-unit>
        <trans-unit id="3474b62445a988d8dd7132a772a85658690ff2ba" translate="yes" xml:space="preserve">
          <source>WalkDir calls the function with a non-nil err argument in two cases.</source>
          <target state="translated">WalkDir在两种情况下调用该函数,其err参数为非nil。</target>
        </trans-unit>
        <trans-unit id="2909c3003cad6334b97769f490356bda189f1f4c" translate="yes" xml:space="preserve">
          <source>WalkDir does not follow symbolic links found in directories, but if root itself is a symbolic link, its target will be walked.</source>
          <target state="translated">WalkDir不遵循在目录中发现的符号链接,但如果root本身是一个符号链接,它的目标将被行走。</target>
        </trans-unit>
        <trans-unit id="2944078867d26e9f67caf63090c30efa8665e473" translate="yes" xml:space="preserve">
          <source>WalkDir does not follow symbolic links.</source>
          <target state="translated">WalkDir不遵循符号链接。</target>
        </trans-unit>
        <trans-unit id="4671bbf058367649fe2ca3dc374a89674b38ba9a" translate="yes" xml:space="preserve">
          <source>WalkDir walks the file tree rooted at root, calling fn for each file or directory in the tree, including root.</source>
          <target state="translated">WalkDir以根为根行走文件树,对树中的每个文件或目录(包括根)调用fn。</target>
        </trans-unit>
        <trans-unit id="71a3cdec2023da7868097ad68f8742c9c0a18055" translate="yes" xml:space="preserve">
          <source>WalkDirFunc is the type of the function called by WalkDir to visit each file or directory.</source>
          <target state="translated">WalkDirFunc是WalkDir调用的函数类型,用于访问每个文件或目录。</target>
        </trans-unit>
        <trans-unit id="2a839647907d9b3be60eae8967669c7e1dc729b5" translate="yes" xml:space="preserve">
          <source>WalkFunc is the type of the function called by Walk to visit each each file or directory.</source>
          <target state="translated">WalkFunc是Walk调用的函数类型,用于访问每一个文件或目录。</target>
        </trans-unit>
        <trans-unit id="ea8fd18744a5b8a94a61df0e6be7f9d622440bee" translate="yes" xml:space="preserve">
          <source>WalkFunc is the type of the function called for each file or directory visited by Walk. The path argument contains the argument to Walk as a prefix; that is, if Walk is called with &quot;dir&quot;, which is a directory containing the file &quot;a&quot;, the walk function will be called with argument &quot;dir/a&quot;. The info argument is the os.FileInfo for the named path.</source>
          <target state="translated">WalkFunc是Walk每访问一个文件或目录所调用的函数类型。路径参数包含作为前缀的Walk参数;也就是说,如果用 &quot;dir &quot;来调用Walk,即包含文件 &quot;a &quot;的目录,那么Walk函数将用参数 &quot;dir/a &quot;来调用。info参数是命名路径的os.FileInfo。</target>
        </trans-unit>
        <trans-unit id="2918ed6d5c509e3ed1b93a9bceda4782bc8dd955" translate="yes" xml:space="preserve">
          <source>Warning logs a message with severity LOG_WARNING, ignoring the severity passed to New.</source>
          <target state="translated">Warning记录一条严重性为LOG_WARNING的消息,忽略传递给New的严重性。</target>
        </trans-unit>
        <trans-unit id="6dda0897da5609f90207d91adc268a59c4a1ed0a" translate="yes" xml:space="preserve">
          <source>We define codes for each error that manifests while escaping templates, but escaped templates may also fail at runtime.</source>
          <target state="translated">我们为每个在转义模板时表现出来的错误定义了代码,但转义模板也可能在运行时失败。</target>
        </trans-unit>
        <trans-unit id="4c1d860c4500491f651fd6c28babc0fc5252a9c1" translate="yes" xml:space="preserve">
          <source>WebSafe is a 216-color palette that was popularized by early versions of Netscape Navigator. It is also known as the Netscape Color Cube.</source>
          <target state="translated">WebSafe是一个216色的调色板,它是由早期版本的Netscape Navigator所流行的。它也被称为Netscape色彩立方体。</target>
        </trans-unit>
        <trans-unit id="9b612a9be3daa519fe810c831ee09c50cb694cd9" translate="yes" xml:space="preserve">
          <source>Weekday returns the day of the week specified by t.</source>
          <target state="translated">Weekday 返回由t指定的一周中的一天。</target>
        </trans-unit>
        <trans-unit id="f665bbd01fb3804e446b49c63f8771aa2a58f0dc" translate="yes" xml:space="preserve">
          <source>Well-known IPv4 addresses</source>
          <target state="translated">著名的IPv4地址</target>
        </trans-unit>
        <trans-unit id="d1c37cf7857b91d487793e2b066aa7768c44b584" translate="yes" xml:space="preserve">
          <source>Well-known IPv6 addresses</source>
          <target state="translated">著名的IPv6地址</target>
        </trans-unit>
        <trans-unit id="423b2ce203c11b513c12b2cf5a302bece806d9e9" translate="yes" xml:space="preserve">
          <source>When Go code is built with options like -buildmode=c-shared, it will be run as part of an existing non-Go program. The non-Go code may have already installed signal handlers when the Go code starts (that may also happen in unusual cases when using cgo or SWIG; in that case, the discussion here applies). For -buildmode=c-archive the Go runtime will initialize signals at global constructor time. For -buildmode=c-shared the Go runtime will initialize signals when the shared library is loaded.</source>
          <target state="translated">当围棋代码使用-buildmode=c-shared等选项构建时,它将作为现有非围棋程序的一部分运行。当围棋代码启动时,非围棋代码可能已经安装了信号处理程序(在使用cgo或SWIG时,这种情况也可能发生;在这种情况下,这里的讨论适用)。对于-buildmode=c-archive,围棋运行时将在全局构造函数时初始化信号。对于-buildmode=c-shared,Go运行时将在加载共享库时初始化信号。</target>
        </trans-unit>
        <trans-unit id="157b3f39795f3c1bb26d85adf87f02f3367ef226" translate="yes" xml:space="preserve">
          <source>When Read encounters an error or end-of-file condition after successfully reading n &amp;gt; 0 bytes, it returns the number of bytes read. It may return the (non-nil) error from the same call or return the error (and n == 0) from a subsequent call. An instance of this general case is that a Reader returning a non-zero number of bytes at the end of the input stream may return either err == EOF or err == nil. The next Read should return 0, EOF.</source>
          <target state="translated">当成功读取n&amp;gt; 0个字节后，Read遇到错误或文件结束条件时，它将返回读取的字节数。它可能从同一调用返回（非nil）错误，或者从后续调用返回错误（n == 0）。这种一般情况的一个实例是，读取器在输入流的末尾返回非零字节数的情况下，可能返回err == EOF或err == nil。下一次读取应返回0，EOF。</target>
        </trans-unit>
        <trans-unit id="d6278f9f812d1e00a798b88f0d43a4c07f1b736e" translate="yes" xml:space="preserve">
          <source>When ReadAt returns n &amp;lt; len(p), it returns a non-nil error explaining why more bytes were not returned. In this respect, ReadAt is stricter than Read.</source>
          <target state="translated">当ReadAt返回n &amp;lt;len（p）时，它返回一个非nil错误，解释了为什么不返回更多字节。在这方面，ReadAt比Read更严格。</target>
        </trans-unit>
        <trans-unit id="e42e8857e0f2dbf41e5d11d0b713339895c2d306" translate="yes" xml:space="preserve">
          <source>When Shutdown is called, Serve, ListenAndServe, and ListenAndServeTLS immediately return ErrServerClosed. Make sure the program doesn't exit and waits instead for Shutdown to return.</source>
          <target state="translated">当调用Shutdown时,Serve、ListenAndServe和ListenAndServeTLS立即返回ErrServerClosed。确保程序不会退出,而是等待Shutdown返回。</target>
        </trans-unit>
        <trans-unit id="a1346033e8cd0c36ddc0423c4dcbbce227d0c225" translate="yes" xml:space="preserve">
          <source>When TestMain is called, flag.Parse has not been run. If TestMain depends on command-line flags, including those of the testing package, it should call flag.Parse explicitly. Command line flags are always parsed by the time test or benchmark functions run.</source>
          <target state="translated">当TestMain被调用时,flag.Parse还没有被运行。如果TestMain依赖于命令行标志,包括测试包的标志,它应该明确地调用flag.Parse。命令行标志总是在测试或基准函数运行时被解析。</target>
        </trans-unit>
        <trans-unit id="52cedf2625524a5c08d35a591f2ee66394bc79d6" translate="yes" xml:space="preserve">
          <source>When Token encounters an error or end-of-file condition after successfully reading a token, it returns the token. It may return the (non-nil) error from the same call or return the error (and a nil token) from a subsequent call. An instance of this general case is that a TokenReader returning a non-nil token at the end of the token stream may return either io.EOF or a nil error. The next Read should return nil, io.EOF.</source>
          <target state="translated">当Token在成功读取一个token后遇到错误或文件结束的情况时,它将返回token,它可能会从同一个调用中返回错误(非零),或者从后续调用中返回错误(和一个nil token)。它可能会从同一个调用中返回(非零)错误,也可能会从后续调用中返回错误(和一个nil token)。这个一般情况的一个例子是,一个TokenReader在token流结束时返回一个非nil token,可能会返回io.EOF或nil错误。下一个Read应该返回nil,io.EOF。</target>
        </trans-unit>
        <trans-unit id="3250a941e5738a81aa69e5097500ef947e64f456" translate="yes" xml:space="preserve">
          <source>When a Go program writes to a broken pipe, the kernel will raise a SIGPIPE signal.</source>
          <target state="translated">当围棋程序向断管写入时,内核会发出SIGPIPE信号。</target>
        </trans-unit>
        <trans-unit id="ed858d1cf0b08d8b30624984289eaf84deee9351" translate="yes" xml:space="preserve">
          <source>When a data value is not plain text, you can make sure it is not over-escaped by marking it with its type.</source>
          <target state="translated">当一个数据值不是纯文本时,你可以通过用它的类型标记来确保它不被过度捕获。</target>
        </trans-unit>
        <trans-unit id="dcc36ea4f1110a5d9628600e555148a98813c271" translate="yes" xml:space="preserve">
          <source>When a plugin is first opened, the init functions of all packages not already part of the program are called. The main function is not run. A plugin is only initialized once, and cannot be closed.</source>
          <target state="translated">当一个插件第一次被打开时,所有尚未成为程序一部分的包的init函数都会被调用。主函数不会被运行。一个插件只初始化一次,不能关闭。</target>
        </trans-unit>
        <trans-unit id="34098c7334f20e516928585d3dd596a221004580" translate="yes" xml:space="preserve">
          <source>When adding a new file, a file base must be provided. That can be any integer value that is past the end of any interval of any file already in the file set. For convenience, FileSet.Base provides such a value, which is simply the end of the Pos interval of the most recently added file, plus one. Unless there is a need to extend an interval later, using the FileSet.Base should be used as argument for FileSet.AddFile.</source>
          <target state="translated">当添加新文件时,必须提供一个文件库。这可以是任何整数值,它可以是已经在文件集中的任何文件的任何区间末尾。为了方便起见,FileSet.Base提供了这样一个值,它只是最近添加的文件的Pos区间末尾加一。除非以后需要扩展一个区间,否则使用FileSet.Base应该作为FileSet.AddFile的参数。</target>
        </trans-unit>
        <trans-unit id="82668902c85167e64c6f0f47b4424c5d8da33aca" translate="yes" xml:space="preserve">
          <source>When calling SetCgoTraceback, the version argument is the version number of the structs that the functions expect to receive. Currently this must be zero.</source>
          <target state="translated">当调用SetCgoTraceback时,版本参数是函数期望接收的结构的版本号。目前这个参数必须为零。</target>
        </trans-unit>
        <trans-unit id="bb4ae77735024f9be2c837577d3897cb72653910" translate="yes" xml:space="preserve">
          <source>When cgo is available, cgo-based (libc-backed) code is used by default. This can be overridden by using osusergo build tag, which enforces the pure Go implementation.</source>
          <target state="translated">当cgo可用时,默认使用基于cgo(libc支持)的代码。这可以通过使用 osusergo build tag 来重写,它强制执行纯 Go 实现。</target>
        </trans-unit>
        <trans-unit id="3d68b88a257e3f62b9428ba8c7fdd32a8b354868" translate="yes" xml:space="preserve">
          <source>When decoding an ASN.1 value with an IMPLICIT tag into a string field, Unmarshal will default to a PrintableString, which doesn't support characters such as '@' and '&amp;amp;'. To force other encodings, use the following tags:</source>
          <target state="translated">当将具有IMPLICIT标签的ASN.1值解码为字符串字段时，Unmarshal将默认为PrintableString，该字符串不支持'@'和'＆'等字符。要强制使用其他编码，请使用以下标签：</target>
        </trans-unit>
        <trans-unit id="752b47af0ec8b502ec7dd916b2f8679be6d9d28e" translate="yes" xml:space="preserve">
          <source>When err is nil, resp always contains a non-nil resp.Body. Caller should close resp.Body when done reading from it.</source>
          <target state="translated">当err为nil时,resp总是包含一个非nil的resp.Body。调用者应该在完成对resp.Body的读取后关闭它。</target>
        </trans-unit>
        <trans-unit id="01d9fbd4a2ba2cf83a0b45d054350614384bbdc9" translate="yes" xml:space="preserve">
          <source>When execution begins, $ is set to the data argument passed to Execute, that is, to the starting value of dot.</source>
          <target state="translated">当执行开始时,$被设置为传递给Execute的数据参数,也就是点的起始值。</target>
        </trans-unit>
        <trans-unit id="8919d4f071112552ffa9917647b1e1053256e035" translate="yes" xml:space="preserve">
          <source>When following redirects, the Client will forward all headers set on the initial Request except:</source>
          <target state="translated">当跟随重定向时,客户端将转发初始请求中设置的所有头信息,但以下情况除外。</target>
        </trans-unit>
        <trans-unit id="9524b6877cae25b318411b88de97b53bfbb0506c" translate="yes" xml:space="preserve">
          <source>When matching against text, the regexp returns a match that begins as early as possible in the input (leftmost), and among those it chooses the one that a backtracking search would have found first. This so-called leftmost-first matching is the same semantics that Perl, Python, and other implementations use, although this package implements it without the expense of backtracking. For POSIX leftmost-longest matching, see CompilePOSIX.</source>
          <target state="translated">当与文本进行匹配时,regexp 会返回一个在输入中尽可能早开始的匹配(最左端),并在这些匹配中选择一个回溯搜索会首先找到的匹配。这种所谓的最左首匹配与Perl、Python和其他实现所使用的语义是一样的,尽管这个包在实现它的时候没有进行回溯搜索。关于 POSIX 最左最长匹配,请参见 CompilePOSIX。</target>
        </trans-unit>
        <trans-unit id="c6e22a9991087594c0b8cf7617afd5eef2db8623" translate="yes" xml:space="preserve">
          <source>When parsing a template, another template may be defined and associated with the template being parsed. Template definitions must appear at the top level of the template, much like global variables in a Go program.</source>
          <target state="translated">在解析一个模板时,可以定义另一个模板,并与被解析的模板相关联。模板定义必须出现在模板的顶层,就像Go程序中的全局变量一样。</target>
        </trans-unit>
        <trans-unit id="017afe59414197ba093e7c01bd629debe47b73b4" translate="yes" xml:space="preserve">
          <source>When parsing a time with a zone abbreviation like MST, if the zone abbreviation has a defined offset in the current location, then that offset is used. The zone abbreviation &quot;UTC&quot; is recognized as UTC regardless of location. If the zone abbreviation is unknown, Parse records the time as being in a fabricated location with the given zone abbreviation and a zero offset. This choice means that such a time can be parsed and reformatted with the same layout losslessly, but the exact instant used in the representation will differ by the actual zone offset. To avoid such problems, prefer time layouts that use a numeric zone offset, or use ParseInLocation.</source>
          <target state="translated">当解析一个带有区域缩写(如MST)的时间时,如果该区域缩写在当前位置有一个定义的偏移,那么就会使用该偏移。区段缩写 &quot;UTC &quot;会被识别为UTC,与位置无关。如果区域缩写是未知的,Parsse会将时间记录为在给定的区域缩写和零偏移的编造位置。这种选择意味着这样的时间可以无损地以相同的布局进行解析和重新格式化,但在表示中使用的确切瞬间会因实际的区域偏移而不同。为了避免这样的问题,请优先选择使用数字区偏移量的时间布局,或者使用ParseInLocation。</target>
        </trans-unit>
        <trans-unit id="6cdce46cbdd242d854181ed07c3441caefe581b7" translate="yes" xml:space="preserve">
          <source>When parsing a time with a zone offset like -0700, if the offset corresponds to a time zone used by the current location (Local), then Parse uses that location and zone in the returned time. Otherwise it records the time as being in a fabricated location with time fixed at the given zone offset.</source>
          <target state="translated">当解析一个带有区间偏移的时间时,比如-0700,如果偏移量对应于当前位置(Local)使用的时区,那么Parse在返回的时间中使用该位置和区间。否则,它将把时间记录为在一个编造的位置,时间固定在给定的区间偏移。</target>
        </trans-unit>
        <trans-unit id="67cd941accf04bdb338f577638abdd5419252ad9" translate="yes" xml:space="preserve">
          <source>When parsing multiple files with the same name in different directories, the last one mentioned will be the one that results.</source>
          <target state="translated">当解析不同目录下的多个同名文件时,以最后提到的那个文件为结果。</target>
        </trans-unit>
        <trans-unit id="ddcdf8b97f4b2868ce974b91b64fece54bf4c923" translate="yes" xml:space="preserve">
          <source>When parsing multiple files with the same name in different directories, the last one mentioned will be the one that results. For instance, ParseFiles(&quot;a/foo&quot;, &quot;b/foo&quot;) stores &quot;b/foo&quot; as the template named &quot;foo&quot;, while &quot;a/foo&quot; is unavailable.</source>
          <target state="translated">当解析不同目录下的多个同名文件时,最后提到的那个文件将是结果。例如,ParseFiles(&quot;a/foo&quot;,&quot;b/foo&quot;)将 &quot;b/foo &quot;存储为名为 &quot;foo &quot;的模板,而 &quot;a/foo &quot;则不可用。</target>
        </trans-unit>
        <trans-unit id="34e29899665d5e8ad85e485fb7f40717928c9cd2" translate="yes" xml:space="preserve">
          <source>When printing a struct, fmt cannot and therefore does not invoke formatting methods such as Error or String on unexported fields.</source>
          <target state="translated">当打印一个结构体时,fmt不能,因此也不会对未导出的字段调用Error或String等格式化方法。</target>
        </trans-unit>
        <trans-unit id="328b930d804aecf09f06d9e00e3215a83c9fe31a" translate="yes" xml:space="preserve">
          <source>When running a large set of sequential test cases, checking Coverage after each one can be useful for identifying which test cases exercise new code paths. It is not a replacement for the reports generated by 'go test -cover' and 'go tool cover'.</source>
          <target state="translated">当运行一大堆连续的测试用例时,在每个测试用例之后检查覆盖率对于确定哪些测试用例使用了新的代码路径是很有用的,它不能替代 &quot;go test -cover &quot;和 &quot;go tool cover &quot;生成的报告。它并不能取代 &quot;go test -cover &quot;和 &quot;go tool cover &quot;所生成的报告。</target>
        </trans-unit>
        <trans-unit id="909e63ef88f23df70a053ead84b3a43d68a17641" translate="yes" xml:space="preserve">
          <source>When template execution invokes a function with an argument list, that list must be assignable to the function's parameter types. Functions meant to apply to arguments of arbitrary type can use parameters of type interface{} or of type reflect.Value. Similarly, functions meant to return a result of arbitrary type can return interface{} or reflect.Value.</source>
          <target state="translated">当模板执行调用一个带有参数列表的函数时,该列表必须可以分配给函数的参数类型。用于应用于任意类型的参数的函数可以使用类型为interface{}或类型为reflect.Value的参数,同样,用于返回任意类型的结果的函数也可以返回interface{}或reflect.Value。同样,用于返回任意类型结果的函数可以返回interface{}或reflect.Value。</target>
        </trans-unit>
        <trans-unit id="05dd6446129205c413b187abb37a98c5e685666d" translate="yes" xml:space="preserve">
          <source>When unmarshaling quoted strings, invalid UTF-8 or invalid UTF-16 surrogate pairs are not treated as an error. Instead, they are replaced by the Unicode replacement character U+FFFD.</source>
          <target state="translated">当解开引号字符串时,无效的UTF-8或无效的UTF-16代用对不会被视为错误,而会被U+FFFD替换为Unicode替换字符。相反,它们会被Unicode替换字符U+FFFD取代。</target>
        </trans-unit>
        <trans-unit id="33fa3fdb7bbbbb81e834f8787f2ce9d1e3b0b605" translate="yes" xml:space="preserve">
          <source>When using TCP, and the host in the address parameter resolves to multiple network addresses, any dial timeout (from d.Timeout or ctx) is spread over each consecutive dial, such that each is given an appropriate fraction of the time to connect. For example, if a host has 4 IP addresses and the timeout is 1 minute, the connect to each single address will be given 15 seconds to complete before trying the next one.</source>
          <target state="translated">当使用TCP,并且地址参数中的主机解析到多个网络地址时,任何拨号超时(来自d.Timeout或ctx)都会分散到每个连续的拨号中,这样每个拨号都会获得适当的连接时间分数。例如,如果一个主机有4个IP地址,超时时间是1分钟,那么在尝试下一个地址之前,将给每个单一地址15秒的时间完成连接。</target>
        </trans-unit>
        <trans-unit id="81ad3fb58a9738071410987f567b6f63ba760aad" translate="yes" xml:space="preserve">
          <source>When using the host C library resolver, at most one result will be returned. To bypass the host resolver, use a custom Resolver.</source>
          <target state="translated">当使用主机C库解析器时,最多只能返回一个结果。要绕过主机解析器,请使用自定义解析器。</target>
        </trans-unit>
        <trans-unit id="b6af75ad725ff03ac3899006f586c6815dee0ab6" translate="yes" xml:space="preserve">
          <source>Whether and how a comment is associated with a node depends on the interpretation of the syntax tree by the manipulating program: Except for Doc and Comment comments directly associated with nodes, the remaining comments are &quot;free-floating&quot; (see also issues #18593, #20744).</source>
          <target state="translated">评论是否以及如何与节点关联取决于操作程序对语法树的解释。除了与节点直接相关的Doc和Comment评论外,其余评论都是 &quot;自由浮动的&quot;(另见问题#18593、#20744)。</target>
        </trans-unit>
        <trans-unit id="1761aeba17f1966adf699cab82838ede9543b2ce" translate="yes" xml:space="preserve">
          <source>While it would be correct for the context function to record a complete a stack trace whenever it is called, and simply copy that out in the traceback function, in a typical program the context function will be called many times without ever recording a traceback for that context. Recording a complete stack trace in a call to the context function is likely to be inefficient.</source>
          <target state="translated">虽然每当调用上下文函数时,记录一个完整的堆栈跟踪,并在回溯函数中简单地复制出来是正确的,但在一个典型的程序中,上下文函数会被多次调用,而从未记录过该上下文的回溯。在对上下文函数的调用中记录一个完整的堆栈跟踪很可能是低效的。</target>
        </trans-unit>
        <trans-unit id="97ac8575a01bb9731d0aacbb0c00a32106d3caac" translate="yes" xml:space="preserve">
          <source>While the FileSystem.Open method takes '/'-separated paths, a Dir's string value is a filename on the native file system, not a URL, so it is separated by filepath.Separator, which isn't necessarily '/'.</source>
          <target state="translated">虽然FileSystem.Open方法采用'/'分隔的路径,但Dir的字符串值是原生文件系统中的文件名,而不是URL,所以要用filepath.Separator分隔,不一定是'/'。</target>
        </trans-unit>
        <trans-unit id="7d448d6e99b8642847a099da6f3145e12a69b2bf" translate="yes" xml:space="preserve">
          <source>White space is considered part of a field.</source>
          <target state="translated">白色空间被认为是一个领域的一部分。</target>
        </trans-unit>
        <trans-unit id="3462ed046f134fdadd9007f0e6ba397654359adc" translate="yes" xml:space="preserve">
          <source>Width and precision are measured in units of Unicode code points, that is, runes. (This differs from C's printf where the units are always measured in bytes.) Either or both of the flags may be replaced with the character '*', causing their values to be obtained from the next operand (preceding the one to format), which must be of type int.</source>
          <target state="translated">宽度和精度以Unicode码点为单位,也就是Runes,(这与C语言的printf不同,后者的单位总是以字节为单位)。(这与C语言的printf不同,在printf中,单位总是以字节为单位。)标志中的任何一个或两个都可以用字符'*'代替,从而使它们的值从下一个操作数(在要格式化的操作数之前)获得,而这个操作数的类型必须是int。</target>
        </trans-unit>
        <trans-unit id="285e52d2a4d90abe10ddf2c19e952396f894982a" translate="yes" xml:space="preserve">
          <source>Width is interpreted in the input text but there is no syntax for scanning with a precision (no %5.2f, just %5f). If width is provided, it applies after leading spaces are trimmed and specifies the maximum number of runes to read to satisfy the verb. For example,</source>
          <target state="translated">宽度在输入文本中解释,但没有用精度扫描的语法(没有%5.2f,只有%5f)。如果提供了宽度,则在前导空格被修剪后适用,并指定满足动词的最大读取符文数。例如</target>
        </trans-unit>
        <trans-unit id="798e2836ace5e24780c7dc5d76140278c0905170" translate="yes" xml:space="preserve">
          <source>Width is specified by an optional decimal number immediately preceding the verb. If absent, the width is whatever is necessary to represent the value. Precision is specified after the (optional) width by a period followed by a decimal number. If no period is present, a default precision is used. A period with no following number specifies a precision of zero. Examples:</source>
          <target state="translated">宽度由紧接在动词前的一个可选的十进制数指定。如果没有指定,则宽度为表示数值所需的任何数值。精度是在(可选)宽度之后用一个句号和一个小数来指定的,如果没有句号,则使用默认精度。如果没有句号,则使用默认精度。句号后面没有数字,则表示精度为零。示例。</target>
        </trans-unit>
        <trans-unit id="26d9c28d789c254f71ea99a3463b99a7ccc2f4fa" translate="yes" xml:space="preserve">
          <source>Windows</source>
          <target state="translated">Windows</target>
        </trans-unit>
        <trans-unit id="90527ca0c17e71be4b659b364a4632417bd48fd0" translate="yes" xml:space="preserve">
          <source>With HTTP Basic Authentication the provided username and password are not encrypted.</source>
          <target state="translated">在HTTP基本认证中,所提供的用户名和密码是不加密的。</target>
        </trans-unit>
        <trans-unit id="9c7242429a52b5edef337779ea090fbcc2bb6019" translate="yes" xml:space="preserve">
          <source>With the exceptions of comments, which are skipped if SkipComments is set, unrecognized tokens are not ignored. Instead, the scanner simply returns the respective individual characters (or possibly sub-tokens). For instance, if the mode is ScanIdents (not ScanStrings), the string &quot;foo&quot; is scanned as the token sequence '&quot;' Ident '&quot;'.</source>
          <target state="translated">除了注释(如果设置了SkipComments,则会跳过注释)之外,未识别的标记不会被忽略。相反,扫描仪只会返回各自的单独字符(或可能的子标记)。例如,如果模式是ScanIdents(而不是ScanStrings),字符串 &quot;foo &quot;将被扫描为标记序列'&quot;'。Ident'&quot;'。</target>
        </trans-unit>
        <trans-unit id="cfa2b7a12432ca7dde89800a43beb434b01e3ea5" translate="yes" xml:space="preserve">
          <source>WithCancel</source>
          <target state="translated">WithCancel</target>
        </trans-unit>
        <trans-unit id="10592d7ad2855a7180469ae213405203a2d50e89" translate="yes" xml:space="preserve">
          <source>WithCancel returns a copy of parent with a new Done channel. The returned context's Done channel is closed when the returned cancel function is called or when the parent context's Done channel is closed, whichever happens first.</source>
          <target state="translated">WithCancel返回一个带有新Done通道的父语境副本。当返回的cancel函数被调用或父上下文的Done通道被关闭时,返回的上下文的Done通道被关闭,以先发生的为准。</target>
        </trans-unit>
        <trans-unit id="2261f632aeaf0a3059b969971069ca975c9ce32e" translate="yes" xml:space="preserve">
          <source>WithClientTrace returns a new context based on the provided parent ctx. HTTP client requests made with the returned context will use the provided trace hooks, in addition to any previous hooks registered with ctx. Any hooks defined in the provided trace will be called first.</source>
          <target state="translated">WithClientTrace基于提供的父ctx返回一个新的上下文。使用返回的上下文进行的 HTTP 客户端请求将使用所提供的跟踪钩子,以及之前在 ctx 中注册的任何钩子。任何在所提供的跟踪中定义的钩子将首先被调用。</target>
        </trans-unit>
        <trans-unit id="f1cd36566b14c3bbf36e47b0c1cd6c5053972eb6" translate="yes" xml:space="preserve">
          <source>WithContext returns a shallow copy of r with its context changed to ctx. The provided ctx must be non-nil.</source>
          <target state="translated">WithContext 返回 r 的一个浅层副本,并将其上下文改为 ctx。提供的ctx必须是非零。</target>
        </trans-unit>
        <trans-unit id="c81570667b5d5149acbef6b90b5b11ce74038f5e" translate="yes" xml:space="preserve">
          <source>WithDeadline</source>
          <target state="translated">WithDeadline</target>
        </trans-unit>
        <trans-unit id="4330da7d2b110737e8fe5953a232fb49e41e1165" translate="yes" xml:space="preserve">
          <source>WithDeadline returns a copy of the parent context with the deadline adjusted to be no later than d. If the parent's deadline is already earlier than d, WithDeadline(parent, d) is semantically equivalent to parent. The returned context's Done channel is closed when the deadline expires, when the returned cancel function is called, or when the parent context's Done channel is closed, whichever happens first.</source>
          <target state="translated">WithDeadline返回父上下文的副本,并将截止日期调整为不晚于d。如果父上下文的截止日期已经早于d,WithDeadline(parent,d)在语义上等同于parent。当deadline过期时,当返回的取消函数被调用时,或者当父上下文的Done通道被关闭时,返回的上下文的Done通道被关闭,以先发生的为准。</target>
        </trans-unit>
        <trans-unit id="7a280665a50cba23581e10e39947347ff060fae9" translate="yes" xml:space="preserve">
          <source>WithLabels returns a new context.Context with the given labels added. A label overwrites a prior label with the same key.</source>
          <target state="translated">WithLabels返回一个添加了给定标签的新context.Context。一个标签会覆盖一个相同键的先前标签。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
