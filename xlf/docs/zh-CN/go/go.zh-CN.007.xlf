<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="go">
    <body>
      <group id="go">
        <trans-unit id="e7cf6fa65416b27793d90a051b00b5c18e902844" translate="yes" xml:space="preserve">
          <source>Other values - numbers, bools, strings, and channels - are deeply equal if they are equal using Go's == operator.</source>
          <target state="translated">其他值--数字、bool、字符串和通道--如果使用围棋的==运算符相等,那么它们就会深度相等。</target>
        </trans-unit>
        <trans-unit id="68cac93271438e6498e5c369aaaa0b2b44f4aa36" translate="yes" xml:space="preserve">
          <source>Otherwise Context will be a value previously returned by a call to the context function. The traceback function should gather a stack trace from that saved point in the program execution. The traceback function may be called from an execution thread other than the one that recorded the context, but only when the context is known to be valid and unchanging. The traceback function may also be called deeper in the call stack on the same thread that recorded the context. The traceback function may be called multiple times with the same Context value; it will usually be appropriate to cache the result, if possible, the first time this is called for a specific context value.</source>
          <target state="translated">否则Context将是之前调用context函数返回的值。回溯函数应该收集程序执行中那个保存点的堆栈跟踪。回溯函数可以从记录上下文的线程以外的执行线程中调用,但只有当上下文是有效的并且没有变化的时候才可以调用。回溯函数也可以在记录上下文的同一线程的调用堆栈的更深处被调用。回溯函数可以用同一个Context值被多次调用;如果可能的话,通常在第一次调用一个特定的上下文值时,将结果缓存起来是合适的。</target>
        </trans-unit>
        <trans-unit id="440873215b88a6b8697d85d1d64d02df4a4da93f" translate="yes" xml:space="preserve">
          <source>Otherwise, Marshal uses the following type-dependent default encodings:</source>
          <target state="translated">否则,Marshal使用以下类型相关的默认编码。</target>
        </trans-unit>
        <trans-unit id="23286c7a365f916cfdea50d5123a3b0bcae1d4f3" translate="yes" xml:space="preserve">
          <source>Otherwise, the Scanner advances the input. If the token is not nil, the Scanner returns it to the user. If the token is nil, the Scanner reads more data and continues scanning; if there is no more data--if atEOF was true--the Scanner returns. If the data does not yet hold a complete token, for instance if it has no newline while scanning lines, a SplitFunc can return (0, nil, nil) to signal the Scanner to read more data into the slice and try again with a longer slice starting at the same point in the input.</source>
          <target state="translated">否则,扫描器将推进输入。如果token不是零,扫描器将其返回给用户。如果标记为零,扫描器读取更多数据并继续扫描;如果没有更多数据--如果 atEOF 为真,扫描器返回。如果数据中还没有完整的标记,例如在扫描行时没有换行,SplitFunc可以返回(0,nil,nil),提示扫描器读取更多的数据到分片中,并从输入的相同点开始,用更长的分片再次尝试。</target>
        </trans-unit>
        <trans-unit id="c58abb3a56ad02906deb5ed411e41c1942d916f5" translate="yes" xml:space="preserve">
          <source>Otherwise, the name is taken to be a location name corresponding to a file in the IANA Time Zone database, such as &quot;America/New_York&quot;.</source>
          <target state="translated">否则,取名为与IANA时区数据库中的文件对应的位置名,如 &quot;America/New_York&quot;。</target>
        </trans-unit>
        <trans-unit id="074d0906fc55c8d6c513fa44707b8b377c627c79" translate="yes" xml:space="preserve">
          <source>Out may be used to retrieve OUTPUT value parameters from stored procedures.</source>
          <target state="translated">Out可用于从存储过程中检索OUTPUT值参数。</target>
        </trans-unit>
        <trans-unit id="62f29f77d6256848fed5f348aeadebd7d0572e5e" translate="yes" xml:space="preserve">
          <source>Output returns the destination for usage and error messages. os.Stderr is returned if output was not set or was set to nil.</source>
          <target state="translated">如果output没有设置或设置为nil,则返回os.Stderr。</target>
        </trans-unit>
        <trans-unit id="e449133aa4e97be80abdfc0c46f50787b1e6cc66" translate="yes" xml:space="preserve">
          <source>Output runs the command and returns its standard output. Any returned error will usually be of type *ExitError. If c.Stderr was nil, Output populates ExitError.Stderr.</source>
          <target state="translated">Output运行命令并返回其标准输出。任何返回的错误通常都是*ExitError类型的。如果c.Stderr为nil,Output会填充ExitError.Stderr。</target>
        </trans-unit>
        <trans-unit id="7ecc8307c727787c0796f59aebc9997243dec020" translate="yes" xml:space="preserve">
          <source>Output writes the output for a logging event. The string s contains the text to print after the prefix specified by the flags of the Logger. A newline is appended if the last character of s is not already a newline. Calldepth is the count of the number of frames to skip when computing the file name and line number if Llongfile or Lshortfile is set; a value of 1 will print the details for the caller of Output.</source>
          <target state="translated">输出写出一个日志事件的输出。字符串 s 包含要打印的文本,位于日志记录器的标志指定的前缀之后。如果s的最后一个字符不是换行符,则会附加一个换行符。Calldepth是指如果设置了Llongfile或Lshortfile,在计算文件名和行号时要跳过的帧数;值为1时,将为Output的调用者打印详细信息。</target>
        </trans-unit>
        <trans-unit id="c217d8994a3f1426d43eb0166f8c3a35d6d34515" translate="yes" xml:space="preserve">
          <source>Output writes the output for a logging event. The string s contains the text to print after the prefix specified by the flags of the Logger. A newline is appended if the last character of s is not already a newline. Calldepth is used to recover the PC and is provided for generality, although at the moment on all pre-defined paths it will be 2.</source>
          <target state="translated">输出写出一个日志事件的输出。字符串 s 包含要打印的文本,位于日志记录器的标志指定的前缀之后。如果s的最后一个字符不是换行符,则会附加一个换行符。Calldepth用于恢复PC,是为了通用性而提供的,尽管目前在所有预定义的路径上都是2。</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="4fa36fa9b33d97810f39e28fc36e995589f3d560" translate="yes" xml:space="preserve">
          <source>Output: &quot;ZgotmplZ&quot; Example:</source>
          <target state="translated">输出。&quot;ZgotmplZ&quot; 示例:</target>
        </trans-unit>
        <trans-unit id="75e718b4932f1994826e9ab2559b67ffd1e17df7" translate="yes" xml:space="preserve">
          <source>Outside of those two special cases, ServeFile does not use r.URL.Path for selecting the file or directory to serve; only the file or directory provided in the name argument is used.</source>
          <target state="translated">除了这两种特殊情况外,ServeFile不使用r.URL.Path来选择要服务的文件或目录,只使用name参数中提供的文件或目录。</target>
        </trans-unit>
        <trans-unit id="c3a7fdb472ac14ee470a8708bdbde30a747ecc04" translate="yes" xml:space="preserve">
          <source>OverflowComplex reports whether the complex128 x cannot be represented by v's type. It panics if v's Kind is not Complex64 or Complex128.</source>
          <target state="translated">OverflowComplex报告复数128的x是否不能由v的类型表示。如果v的类型不是Complex64或Complex128,它就会恐慌。</target>
        </trans-unit>
        <trans-unit id="b0ed609ef26db1230ec310f05f6a41e74b4a279d" translate="yes" xml:space="preserve">
          <source>OverflowFloat reports whether the float64 x cannot be represented by v's type. It panics if v's Kind is not Float32 or Float64.</source>
          <target state="translated">OverflowFloat报告float64 x是否不能用v的类型表示。如果v的类型不是Float32或Float64,它就会恐慌。</target>
        </trans-unit>
        <trans-unit id="7200bfe476f81acadc4a0ccf748e1684d1005b1a" translate="yes" xml:space="preserve">
          <source>OverflowInt reports whether the int64 x cannot be represented by v's type. It panics if v's Kind is not Int, Int8, Int16, Int32, or Int64.</source>
          <target state="translated">OverflowInt报告int64 x是否不能用v的类型来表示,如果v的类型不是Int、Int8、Int16、Int32或Int64,它就会恐慌。如果v的类型不是Int、Int8、Int16、Int32或Int64,它就会恐慌。</target>
        </trans-unit>
        <trans-unit id="2b4b5d40028c4ba9e1027f58dcb6f18125d975d5" translate="yes" xml:space="preserve">
          <source>OverflowUint reports whether the uint64 x cannot be represented by v's type. It panics if v's Kind is not Uint, Uintptr, Uint8, Uint16, Uint32, or Uint64.</source>
          <target state="translated">OverflowUint报告uint64 x是否不能由v的类型来表示,如果v的类型不是Uint,Uintptr,Uint8,Uint16,Uint32,或Uint64,它就会恐慌。如果v的类型不是Uint、Uintptr、Uint8、Uint16、Uint32或Uint64,它就会恐慌。</target>
        </trans-unit>
        <trans-unit id="2f7f8328b596e3ddecd6faa4ad494433682975d9" translate="yes" xml:space="preserve">
          <source>Overlaps reports whether r and s have a non-empty intersection.</source>
          <target state="translated">重叠报告r和s是否有一个非空的交点。</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="540bc829190ced5e9ba3735dc9ac84a0059b79f4" translate="yes" xml:space="preserve">
          <source>P224 returns a Curve which implements P-224 (see FIPS 186-3, section D.2.2).</source>
          <target state="translated">P224返回一个实现P-224的曲线(见FIPS 186-3,D.2.2节)。</target>
        </trans-unit>
        <trans-unit id="7a02481719ad494cd5efe50d160cc7726bf135c0" translate="yes" xml:space="preserve">
          <source>P256 returns a Curve which implements NIST P-256 (FIPS 186-3, section D.2.3), also known as secp256r1 or prime256v1. The CurveParams.Name of this Curve is &quot;P-256&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9ccdfec57f69f0c0af7d347e1e194be5e3da78a" translate="yes" xml:space="preserve">
          <source>P256 returns a Curve which implements P-256 (see FIPS 186-3, section D.2.3)</source>
          <target state="translated">P256 返回一个实现 P-256 的曲线(见 FIPS 186-3,D.2.3 节)。</target>
        </trans-unit>
        <trans-unit id="315a8a8dcda4a2d0941fe0f30068b28ba243beb9" translate="yes" xml:space="preserve">
          <source>P384 returns a Curve which implements NIST P-384 (FIPS 186-3, section D.2.4), also known as secp384r1. The CurveParams.Name of this Curve is &quot;P-384&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d2178f68bbde9fa3217033c113d8df97da47a28" translate="yes" xml:space="preserve">
          <source>P384 returns a Curve which implements P-384 (see FIPS 186-3, section D.2.4)</source>
          <target state="translated">P384返回一个实现P-384的曲线(见FIPS 186-3,D.2.4节)。</target>
        </trans-unit>
        <trans-unit id="4cca307fc3187b85217d38451ccf6632766474b3" translate="yes" xml:space="preserve">
          <source>P521 returns a Curve which implements NIST P-521 (FIPS 186-3, section D.2.5), also known as secp521r1. The CurveParams.Name of this Curve is &quot;P-521&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9a508dd7c665008acf0e38e607e3196bfcd6cf9" translate="yes" xml:space="preserve">
          <source>P521 returns a Curve which implements P-521 (see FIPS 186-3, section D.2.5)</source>
          <target state="translated">P521返回一个实现P-521的曲线(见FIPS 186-3,D.2.5节)。</target>
        </trans-unit>
        <trans-unit id="39161099723c9e406b69587afd22627144ad7720" translate="yes" xml:space="preserve">
          <source>PCToFunc returns the function containing the program counter pc, or nil if there is no such function.</source>
          <target state="translated">PCToFunc返回包含程序计数器pc的函数,如果没有这个函数,则返回nil。</target>
        </trans-unit>
        <trans-unit id="aabe0db5b758e9cbc954a1f7a208c14d080cb6c6" translate="yes" xml:space="preserve">
          <source>PCToLine looks up line number information for a program counter. If there is no information, it returns fn == nil.</source>
          <target state="translated">PCToLine查找程序计数器的行号信息。如果没有信息,则返回fn ==nil。</target>
        </trans-unit>
        <trans-unit id="841d78ecc2d24b8758f6afc447a9a64df99960bb" translate="yes" xml:space="preserve">
          <source>PCToLine returns the line number for the given program counter.</source>
          <target state="translated">PCToLine返回给定程序计数器的行号。</target>
        </trans-unit>
        <trans-unit id="9f22bb4f4b5879dcdd3ed13d36e5eadeb879d5ee" translate="yes" xml:space="preserve">
          <source>PKCS1v15DecrypterOpts is for passing options to PKCS #1 v1.5 decryption using the crypto.Decrypter interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8139323c6d19479f54e5ea9ba69d4546948a8d4" translate="yes" xml:space="preserve">
          <source>PKCS1v15DecrypterOpts is for passing options to PKCS#1 v1.5 decryption using the crypto.Decrypter interface.</source>
          <target state="translated">PKCS1v15DecrypterOpts是用于向使用crypto.Decrypter接口的PKCS#1 v1.5解密传递选项。</target>
        </trans-unit>
        <trans-unit id="3010ccb1954efdb7b7065a86234a1d7d460fba48" translate="yes" xml:space="preserve">
          <source>PSSOptions contains options for creating and verifying PSS signatures.</source>
          <target state="translated">PSSOptions包含创建和验证PSS签名的选项。</target>
        </trans-unit>
        <trans-unit id="7431e3df243c5be33cffa0b28ca2a76b93f0538c" translate="yes" xml:space="preserve">
          <source>Package</source>
          <target state="translated">Package</target>
        </trans-unit>
        <trans-unit id="6de038894baa09edba875dcb5414f5284bdf18fd" translate="yes" xml:space="preserve">
          <source>Package (Autoescaping)</source>
          <target state="translated">包装(自动剪枝)</target>
        </trans-unit>
        <trans-unit id="efd760e5022b210b4ab3b28e3b7050f4cfe5597a" translate="yes" xml:space="preserve">
          <source>Package (Basic)</source>
          <target state="translated">套餐(基本)</target>
        </trans-unit>
        <trans-unit id="2f75473a87f737dac84d4da0d9f9f7e3db9e0c4a" translate="yes" xml:space="preserve">
          <source>Package (BinaryMarshaler)</source>
          <target state="translated">包(BinaryMarshaler)</target>
        </trans-unit>
        <trans-unit id="521cf6815d29f653ce707f251cb067182d8071f5" translate="yes" xml:space="preserve">
          <source>Package (ComplexNumbers)</source>
          <target state="translated">包(复数)</target>
        </trans-unit>
        <trans-unit id="f1ea6c4ac2e70daab523cce5ae048f3dea0d83bb" translate="yes" xml:space="preserve">
          <source>Package (CustomMarshalJSON)</source>
          <target state="translated">包(CustomMarshalJSON)</target>
        </trans-unit>
        <trans-unit id="53c1354bffac6774daf658fbd5e85b47d709a40a" translate="yes" xml:space="preserve">
          <source>Package (CustomMarshalXML)</source>
          <target state="translated">包(CustomMarshalXML)</target>
        </trans-unit>
        <trans-unit id="bf806559bf4e10f3c8039c45350fd1cd892af724" translate="yes" xml:space="preserve">
          <source>Package (DecodeConfig)</source>
          <target state="translated">包(DecodeConfig)</target>
        </trans-unit>
        <trans-unit id="5c13dd8a74667052e5635f9f7455a54e1f9be1f3" translate="yes" xml:space="preserve">
          <source>Package (Dictionary)</source>
          <target state="translated">包(词典)</target>
        </trans-unit>
        <trans-unit id="fcafbcc962aec3c3d83b146b18f61ef5463aef43" translate="yes" xml:space="preserve">
          <source>Package (EConvergents)</source>
          <target state="translated">包(EConvergents)</target>
        </trans-unit>
        <trans-unit id="71630f752f5d0a16ab8b1a3c38461b76d37e5fed" translate="yes" xml:space="preserve">
          <source>Package (Elastic)</source>
          <target state="translated">包装(弹性)</target>
        </trans-unit>
        <trans-unit id="3dc381377e54ebe3f92f7916ec8fdf96578a8e4b" translate="yes" xml:space="preserve">
          <source>Package (EncodeDecode)</source>
          <target state="translated">包(EncodeDecode)</target>
        </trans-unit>
        <trans-unit id="252573860775d14759f48467c37c1fc311083728" translate="yes" xml:space="preserve">
          <source>Package (Escape)</source>
          <target state="translated">包裹(逃生)</target>
        </trans-unit>
        <trans-unit id="25f707cfdaffe7b9a529ff95591583c8c03bc6af" translate="yes" xml:space="preserve">
          <source>Package (Fibonacci)</source>
          <target state="translated">包(斐波那契)</target>
        </trans-unit>
        <trans-unit id="338a17f2623ba97dc73fc6452b147c9a5a0e8298" translate="yes" xml:space="preserve">
          <source>Package (Formats)</source>
          <target state="translated">包装(格式)</target>
        </trans-unit>
        <trans-unit id="426c20e3d54491dcaa33e4dd0bebe004b79c0135" translate="yes" xml:space="preserve">
          <source>Package (IntHeap)</source>
          <target state="translated">包(IntHeap)</target>
        </trans-unit>
        <trans-unit id="0c999d293b130996c88c6f0ebf97cfecc7e78201" translate="yes" xml:space="preserve">
          <source>Package (Interface)</source>
          <target state="translated">包装(接口)</target>
        </trans-unit>
        <trans-unit id="dd11444f3f52c88a7e33585300bd5ea9526ef9c4" translate="yes" xml:space="preserve">
          <source>Package (Is)</source>
          <target state="translated">包装(是)</target>
        </trans-unit>
        <trans-unit id="24d024864b73227ebe67578e60455dbd5c73297f" translate="yes" xml:space="preserve">
          <source>Package (IsIdentRune)</source>
          <target state="translated">包(IsIdentRune)</target>
        </trans-unit>
        <trans-unit id="748caafd5bbe2c55ebabfb05417c48bc6922ffcf" translate="yes" xml:space="preserve">
          <source>Package (Minimal)</source>
          <target state="translated">包裹(最小值)</target>
        </trans-unit>
        <trans-unit id="4c4a86eeb8002b47d70510d7c23e7eb0eeebd8db" translate="yes" xml:space="preserve">
          <source>Package (Mode)</source>
          <target state="translated">包装(模式)</target>
        </trans-unit>
        <trans-unit id="be479fe7812a33e53549975551961ada92e137a5" translate="yes" xml:space="preserve">
          <source>Package (OpenDBCLI)</source>
          <target state="translated">包(OpenDBCLI)</target>
        </trans-unit>
        <trans-unit id="afacd609e03942d0e0a9efefefa3cc27d29c774c" translate="yes" xml:space="preserve">
          <source>Package (OpenDBService)</source>
          <target state="translated">包(OpenDBService)</target>
        </trans-unit>
        <trans-unit id="867dd5ed3ca2062c464faebd1a831d2ea55231a1" translate="yes" xml:space="preserve">
          <source>Package (Printers)</source>
          <target state="translated">包装(打印机)</target>
        </trans-unit>
        <trans-unit id="944f7ea8e45283f6aee9c663f196d84201347430" translate="yes" xml:space="preserve">
          <source>Package (PriorityQueue)</source>
          <target state="translated">包(PriorityQueue)</target>
        </trans-unit>
        <trans-unit id="e76c0b4be64237d4de2b6bc5f73a9204c1c70fde" translate="yes" xml:space="preserve">
          <source>Package (Rand)</source>
          <target state="translated">包裹(兰特)</target>
        </trans-unit>
        <trans-unit id="a8e65e58fc97f49428772dd3c9910ec49b3603a7" translate="yes" xml:space="preserve">
          <source>Package (Reset)</source>
          <target state="translated">包装(复位)</target>
        </trans-unit>
        <trans-unit id="0676e5f7c44f1428abe1688347a4a67985619798" translate="yes" xml:space="preserve">
          <source>Package (RetrievePositionInfo)</source>
          <target state="translated">包(RetrievePositionInfo)</target>
        </trans-unit>
        <trans-unit id="3918e789c00aa71d83a0d25f288c82afb2e9dc19" translate="yes" xml:space="preserve">
          <source>Package (SortKeys)</source>
          <target state="translated">包(SortKeys)</target>
        </trans-unit>
        <trans-unit id="fc31bf6d702c41d4e65fa2c8464a648d0253335d" translate="yes" xml:space="preserve">
          <source>Package (SortMultiKeys)</source>
          <target state="translated">包 (SortMultiKeys)</target>
        </trans-unit>
        <trans-unit id="be587b9c8d7d28588b076a30e4390f166b763389" translate="yes" xml:space="preserve">
          <source>Package (SortWrapper)</source>
          <target state="translated">包(SortWrapper)</target>
        </trans-unit>
        <trans-unit id="039d4d77bcfce9ea65f0437ee2733cacb35d30d2" translate="yes" xml:space="preserve">
          <source>Package (Sqrt2)</source>
          <target state="translated">包(Sqrt2)</target>
        </trans-unit>
        <trans-unit id="978d6874fbbc2bbed5f65358c7eadec1499de368" translate="yes" xml:space="preserve">
          <source>Package (Synchronization)</source>
          <target state="translated">包(同步)</target>
        </trans-unit>
        <trans-unit id="d74eef6782bc61ea34233345eec7439ddb2209f0" translate="yes" xml:space="preserve">
          <source>Package (TextMarshalJSON)</source>
          <target state="translated">包(TextMarshalJSON)</target>
        </trans-unit>
        <trans-unit id="00ea20ac0a3062f6e781d5f03ac4f931f7e664e0" translate="yes" xml:space="preserve">
          <source>Package (TextMarshalXML)</source>
          <target state="translated">包(TextMarshalXML)</target>
        </trans-unit>
        <trans-unit id="9d3479f34953d267211484567770a976cf5f7423" translate="yes" xml:space="preserve">
          <source>Package (TrailingTab)</source>
          <target state="translated">包(尾部标签)</target>
        </trans-unit>
        <trans-unit id="db41f4bcaa84e2ad0f8ea9b730005966564c99d0" translate="yes" xml:space="preserve">
          <source>Package (Whitespace)</source>
          <target state="translated">包装(空白)</target>
        </trans-unit>
        <trans-unit id="3fb9a413fc3704254de1eb68fffddbb472a23f33" translate="yes" xml:space="preserve">
          <source>Package (WriterReader)</source>
          <target state="translated">包(WriterReader)</target>
        </trans-unit>
        <trans-unit id="92c0af89beed6181e00c988e8e650e8fbbda5fcb" translate="yes" xml:space="preserve">
          <source>Package adler32</source>
          <target state="translated">包adler32</target>
        </trans-unit>
        <trans-unit id="d6bd7681a9453e693c6a651037643ef4b5bef6e4" translate="yes" xml:space="preserve">
          <source>Package adler32 implements the Adler-32 checksum.</source>
          <target state="translated">包adler32实现了Adler-32校验和。</target>
        </trans-unit>
        <trans-unit id="e90a3804ce06c2050a2cae1b40859d0d4b3dc725" translate="yes" xml:space="preserve">
          <source>Package aes</source>
          <target state="translated">包裹aes</target>
        </trans-unit>
        <trans-unit id="d496233c286ca50cea980f949b6ce9d0a2fbee51" translate="yes" xml:space="preserve">
          <source>Package aes implements AES encryption (formerly Rijndael), as defined in U.S. Federal Information Processing Standards Publication 197.</source>
          <target state="translated">包aes实现了美国联邦信息处理标准出版物197中定义的AES加密(以前的Rijndael)。</target>
        </trans-unit>
        <trans-unit id="0d926b729b85354785bc0db2b7d8a423a023029c" translate="yes" xml:space="preserve">
          <source>Package ascii85</source>
          <target state="translated">包ascii85</target>
        </trans-unit>
        <trans-unit id="e3765c8a35f98ca3f4cb583e00d1c90614882045" translate="yes" xml:space="preserve">
          <source>Package ascii85 implements the ascii85 data encoding as used in the btoa tool and Adobe's PostScript and PDF document formats.</source>
          <target state="translated">包ascii85实现了btoa工具和Adobe的PostScript和PDF文档格式中使用的ascii85数据编码。</target>
        </trans-unit>
        <trans-unit id="180c9a93d5ae7703f2646b742a79d37379696e26" translate="yes" xml:space="preserve">
          <source>Package asn1</source>
          <target state="translated">包裹asn1</target>
        </trans-unit>
        <trans-unit id="cb9e56c303fa3f867a92e5ec0e898886f01abb4e" translate="yes" xml:space="preserve">
          <source>Package asn1 implements parsing of DER-encoded ASN.1 data structures, as defined in ITU-T Rec X.690.</source>
          <target state="translated">包asn1实现了ITU-T Rec X.690中定义的DER编码ASN.1数据结构的解析。</target>
        </trans-unit>
        <trans-unit id="c08d789dfd150c497744e5eae59ce25bf42b161c" translate="yes" xml:space="preserve">
          <source>Package ast</source>
          <target state="translated">包裹星</target>
        </trans-unit>
        <trans-unit id="93ce17c079d14adf086a4a91c618dc024db4dcea" translate="yes" xml:space="preserve">
          <source>Package ast declares the types used to represent syntax trees for Go packages.</source>
          <target state="translated">包 ast 声明了用于表示 Go 包语法树的类型。</target>
        </trans-unit>
        <trans-unit id="abc4155f0dfe705449b74dd36086fa20264918b2" translate="yes" xml:space="preserve">
          <source>Package atomic</source>
          <target state="translated">原子包</target>
        </trans-unit>
        <trans-unit id="6ccbd2fd52492c5f3e2a1a498498664cb5ffa588" translate="yes" xml:space="preserve">
          <source>Package atomic provides low-level atomic memory primitives useful for implementing synchronization algorithms.</source>
          <target state="translated">包atomic提供了对实现同步算法有用的低级原子内存基元。</target>
        </trans-unit>
        <trans-unit id="4ae1e53a5fe2ac3a3b380e5791057e84bdf2fcee" translate="yes" xml:space="preserve">
          <source>Package base32</source>
          <target state="translated">包base32</target>
        </trans-unit>
        <trans-unit id="3b12a0015b14e3cc130f8b62c8c17d7c8624a97a" translate="yes" xml:space="preserve">
          <source>Package base32 implements base32 encoding as specified by RFC 4648.</source>
          <target state="translated">包base32实现了RFC 4648规定的base32编码。</target>
        </trans-unit>
        <trans-unit id="38a49427af734eb5994d226888d46a2e48a7e089" translate="yes" xml:space="preserve">
          <source>Package base64</source>
          <target state="translated">包base64</target>
        </trans-unit>
        <trans-unit id="2daca13cb62da6b7b33a641f5439803312f106f9" translate="yes" xml:space="preserve">
          <source>Package base64 implements base64 encoding as specified by RFC 4648.</source>
          <target state="translated">包base64实现了RFC 4648规定的base64编码。</target>
        </trans-unit>
        <trans-unit id="03b1336c942a57d9960d475b8b394ed19dde9d0c" translate="yes" xml:space="preserve">
          <source>Package big</source>
          <target state="translated">包装大</target>
        </trans-unit>
        <trans-unit id="b4e5fa3ccf50e02964b74ff445efc105e444e505" translate="yes" xml:space="preserve">
          <source>Package big implements arbitrary-precision arithmetic (big numbers).</source>
          <target state="translated">包big实现了任意精度的算术(大数)。</target>
        </trans-unit>
        <trans-unit id="4e4c386fba82f93790e8829cc10da0258293e392" translate="yes" xml:space="preserve">
          <source>Package big implements arbitrary-precision arithmetic (big numbers). The following numeric types are supported:</source>
          <target state="translated">包big实现了任意精度的算术(大数)。支持以下数字类型。</target>
        </trans-unit>
        <trans-unit id="c20a791c17d35561b3248e9f4e27c1fc641c805c" translate="yes" xml:space="preserve">
          <source>Package binary</source>
          <target state="translated">二进制包</target>
        </trans-unit>
        <trans-unit id="a02abb66bca85bad533ac6ecbbd5730f265b40da" translate="yes" xml:space="preserve">
          <source>Package binary implements simple translation between numbers and byte sequences and encoding and decoding of varints.</source>
          <target state="translated">二进制包实现了数字和字节序列之间的简单转换以及变位数的编码和解码。</target>
        </trans-unit>
        <trans-unit id="b4585c8f5f16a7a3bbd64f720869325930c04b14" translate="yes" xml:space="preserve">
          <source>Package bits</source>
          <target state="translated">包装位</target>
        </trans-unit>
        <trans-unit id="f121f6160680c1e9d47eb4f125af85e968cef0c7" translate="yes" xml:space="preserve">
          <source>Package bits implements bit counting and manipulation functions for the predeclared unsigned integer types.</source>
          <target state="translated">包bit实现了预先声明的无符号整数类型的位计数和操作功能。</target>
        </trans-unit>
        <trans-unit id="83caad2c4e72c3c320f775fbd8a1a35e735677a9" translate="yes" xml:space="preserve">
          <source>Package bufio</source>
          <target state="translated">包裹bufio</target>
        </trans-unit>
        <trans-unit id="880f9f9e86187c3ab9594c87162508890d92b1e0" translate="yes" xml:space="preserve">
          <source>Package bufio implements buffered I/O. It wraps an io.Reader or io.Writer object, creating another object (Reader or Writer) that also implements the interface but provides buffering and some help for textual I/O.</source>
          <target state="translated">包 bufio 实现了缓冲的 I/O。它封装了一个io.Reader或io.Writer对象,创建了另一个对象(Reader或Writer),该对象也实现了该接口,但提供了缓冲和文本I/O的一些帮助。</target>
        </trans-unit>
        <trans-unit id="8f54827014010e49f148fc60f5174298cb86d1a9" translate="yes" xml:space="preserve">
          <source>Package build</source>
          <target state="translated">包建</target>
        </trans-unit>
        <trans-unit id="044aa6ad5cb13105de3d1dfe1e14ba517afc7dc8" translate="yes" xml:space="preserve">
          <source>Package build gathers information about Go packages.</source>
          <target state="translated">包的构建收集了Go包的信息。</target>
        </trans-unit>
        <trans-unit id="47ff1a6f77a6fab0a4ec0e7b02acecd8b23bea55" translate="yes" xml:space="preserve">
          <source>Package builtin</source>
          <target state="translated">内置包</target>
        </trans-unit>
        <trans-unit id="bc6082d4c1ffc50e8646c383c442de7a0853f3b7" translate="yes" xml:space="preserve">
          <source>Package builtin provides documentation for Go's predeclared identifiers. The items documented here are not actually in package builtin but their descriptions here allow godoc to present documentation for the language's special identifiers.</source>
          <target state="translated">包buildin提供了Go的预声明标识符的文档。这里所记录的项目实际上并不在包buildin中,但它们在这里的描述允许godoc为语言的特殊标识符提供文档。</target>
        </trans-unit>
        <trans-unit id="f18adabe10f881275c2b2d516cabb008577c2f65" translate="yes" xml:space="preserve">
          <source>Package bytes</source>
          <target state="translated">包装字节数</target>
        </trans-unit>
        <trans-unit id="48c486630207fb1f7940fbb120ac097a31665a2b" translate="yes" xml:space="preserve">
          <source>Package bytes implements functions for the manipulation of byte slices. It is analogous to the facilities of the strings package.</source>
          <target state="translated">包字节实现了操作字节片的函数。它类似于字符串包的功能。</target>
        </trans-unit>
        <trans-unit id="406c2304145d14ae40562458c269fc1090a1b790" translate="yes" xml:space="preserve">
          <source>Package bzip2</source>
          <target state="translated">包bzip2</target>
        </trans-unit>
        <trans-unit id="8eb7c863e2530f3f68b4ee1a3003e658910e2132" translate="yes" xml:space="preserve">
          <source>Package bzip2 implements bzip2 decompression.</source>
          <target state="translated">包bzip2实现了bzip2解压。</target>
        </trans-unit>
        <trans-unit id="872b31b797dd9ef4b907e19e6db917bdf3d1c013" translate="yes" xml:space="preserve">
          <source>Package cgi</source>
          <target state="translated">包裹cgi</target>
        </trans-unit>
        <trans-unit id="25ac46feb1a43e83003062fe9e6ccdab9ea2b191" translate="yes" xml:space="preserve">
          <source>Package cgi implements CGI (Common Gateway Interface) as specified in RFC 3875.</source>
          <target state="translated">包cgi实现了RFC 3875中指定的CGI(通用网关接口)。</target>
        </trans-unit>
        <trans-unit id="25e89bccb479aa882a9bfc5409a3323ae38e9e25" translate="yes" xml:space="preserve">
          <source>Package cgo</source>
          <target state="translated">包裹cgo</target>
        </trans-unit>
        <trans-unit id="0e3e2e5c14219e52219e14faf9778f4b602d6c0d" translate="yes" xml:space="preserve">
          <source>Package cgo contains runtime support for code generated by the cgo tool.</source>
          <target state="translated">包cgo包含对cgo工具生成的代码的运行时支持。</target>
        </trans-unit>
        <trans-unit id="6e62ea60a0dd1e82f411152a3d6419b7bf76fb06" translate="yes" xml:space="preserve">
          <source>Package cgo contains runtime support for code generated by the cgo tool. See the documentation for the cgo command for details on using cgo.</source>
          <target state="translated">包cgo包含对cgo工具生成的代码的运行时支持。关于cgo的使用细节,请参见cgo命令的文档。</target>
        </trans-unit>
        <trans-unit id="012f0d22cbfff5b4121f59681774b6bcdc6c8bf7" translate="yes" xml:space="preserve">
          <source>Package cipher</source>
          <target state="translated">包装密码</target>
        </trans-unit>
        <trans-unit id="30f3e7b90bc36d4a04ee0c6ee4fede5b412b7a90" translate="yes" xml:space="preserve">
          <source>Package cipher implements standard block cipher modes that can be wrapped around low-level block cipher implementations.</source>
          <target state="translated">封装密码实现了标准的块密码模式,可以围绕低级块密码实现进行封装。</target>
        </trans-unit>
        <trans-unit id="991a9a7de6b61fdec46bfd3e8877fa7f538b6fb2" translate="yes" xml:space="preserve">
          <source>Package cipher implements standard block cipher modes that can be wrapped around low-level block cipher implementations. See &lt;a href=&quot;https://csrc.nist.gov/groups/ST/toolkit/BCM/current_modes.html&quot;&gt;https://csrc.nist.gov/groups/ST/toolkit/BCM/current_modes.html&lt;/a&gt; and NIST Special Publication 800-38A.</source>
          <target state="translated">包密码实现标准的分组密码模式，可以将其包装在低级分组密码实现中。请参阅&lt;a href=&quot;https://csrc.nist.gov/groups/ST/toolkit/BCM/current_modes.html&quot;&gt;https://csrc.nist.gov/groups/ST/toolkit/BCM/current_modes.html&lt;/a&gt;和NIST特殊出版物800-38A。</target>
        </trans-unit>
        <trans-unit id="2b6816262bb29ee185f0f48249d8bc3daaf55582" translate="yes" xml:space="preserve">
          <source>Package cmplx</source>
          <target state="translated">包cmplx</target>
        </trans-unit>
        <trans-unit id="baf57dd7a6b5ac4706888aba9eb1258cba96f27c" translate="yes" xml:space="preserve">
          <source>Package cmplx provides basic constants and mathematical functions for complex numbers.</source>
          <target state="translated">包 cmplx 提供了复数的基本常量和数学函数。</target>
        </trans-unit>
        <trans-unit id="cec1c5cc750dac259d8c1d78dff5abb6d6052171" translate="yes" xml:space="preserve">
          <source>Package cmplx provides basic constants and mathematical functions for complex numbers. Special case handling conforms to the C99 standard Annex G IEC 60559-compatible complex arithmetic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37d8c891f48030e536dd7b758ded3702c02139dc" translate="yes" xml:space="preserve">
          <source>Package color</source>
          <target state="translated">包装颜色</target>
        </trans-unit>
        <trans-unit id="0c0c35fbc62909ad60418ab34664b2ed01195fb4" translate="yes" xml:space="preserve">
          <source>Package color implements a basic color library.</source>
          <target state="translated">包color实现了一个基本的颜色库。</target>
        </trans-unit>
        <trans-unit id="1bcb3d15e235264a42cb3594781e34e58e7e4025" translate="yes" xml:space="preserve">
          <source>Package constant</source>
          <target state="translated">恒定包</target>
        </trans-unit>
        <trans-unit id="cc9ee19fe4a55fca4b94e371e7f50f3a89a325d9" translate="yes" xml:space="preserve">
          <source>Package constant implements Values representing untyped Go constants and their corresponding operations.</source>
          <target state="translated">包constant实现了代表非类型围棋常量的Val值和它们相应的操作。</target>
        </trans-unit>
        <trans-unit id="24c9a6d37d35bffec10a3bb7669106848323d2dd" translate="yes" xml:space="preserve">
          <source>Package constraint</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98b045c5225f0d57e5243e2a0fcd0b0b44b8c1a2" translate="yes" xml:space="preserve">
          <source>Package constraint implements parsing and evaluation of build constraint lines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd0d1549bfb32741dae188d59915c9f5c6bf61cb" translate="yes" xml:space="preserve">
          <source>Package constraint implements parsing and evaluation of build constraint lines. See &lt;a href=&quot;https://golang.org/cmd/go/#hdr-Build_constraints&quot;&gt;https://golang.org/cmd/go/#hdr-Build_constraints&lt;/a&gt; for documentation about build constraints themselves.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f37b57ba6586f71a43fafcb43910fbb2fb02fc3b" translate="yes" xml:space="preserve">
          <source>Package context</source>
          <target state="translated">包装背景</target>
        </trans-unit>
        <trans-unit id="d3934777ec3c952a9b50c31b8ba59b107a7a5d55" translate="yes" xml:space="preserve">
          <source>Package context defines the Context type, which carries deadlines, cancellation signals, and other request-scoped values across API boundaries and between processes.</source>
          <target state="translated">包上下文定义了Context类型,它承载着跨越API边界和进程之间的截止日期、取消信号和其他请求范围的值。</target>
        </trans-unit>
        <trans-unit id="2959c61a1310320ade48360831ded95782ef16b3" translate="yes" xml:space="preserve">
          <source>Package cookiejar</source>
          <target state="translated">包装cookiejar</target>
        </trans-unit>
        <trans-unit id="8c90ea9e027ef93e3a9e5e3949e57755bbbd286c" translate="yes" xml:space="preserve">
          <source>Package cookiejar implements an in-memory RFC 6265-compliant http.CookieJar.</source>
          <target state="translated">包cookiejar实现了一个符合RFC 6265标准的http.CookieJar的内存。</target>
        </trans-unit>
        <trans-unit id="9b8215374e5e8361fe90b06ebf351541009e3e3e" translate="yes" xml:space="preserve">
          <source>Package crc32</source>
          <target state="translated">包crc32</target>
        </trans-unit>
        <trans-unit id="b3a9ccd429f36d4cdadd48a9085d7744e115a2de" translate="yes" xml:space="preserve">
          <source>Package crc32 implements the 32-bit cyclic redundancy check, or CRC-32, checksum.</source>
          <target state="translated">包crc32实现了32位循环冗余检查,或CRC-32的校验和。</target>
        </trans-unit>
        <trans-unit id="e7dea81d74d4673657a098152e4028683fa05c21" translate="yes" xml:space="preserve">
          <source>Package crc32 implements the 32-bit cyclic redundancy check, or CRC-32, checksum. See &lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&lt;/a&gt; for information.</source>
          <target state="translated">软件包crc32实现32位循环冗余校验或CRC-32校验和。有关信息，请参见&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bd8911118f577811f18d0e59d8eb3416d753ee3d" translate="yes" xml:space="preserve">
          <source>Package crc64</source>
          <target state="translated">包crc64</target>
        </trans-unit>
        <trans-unit id="3f711a93350858163dc7138684052f433c0da645" translate="yes" xml:space="preserve">
          <source>Package crc64 implements the 64-bit cyclic redundancy check, or CRC-64, checksum.</source>
          <target state="translated">包crc64实现了64位循环冗余检查,或CRC-64,检查和。</target>
        </trans-unit>
        <trans-unit id="ddff3dc011b09fe55bbaec41ef9b74c6f1146846" translate="yes" xml:space="preserve">
          <source>Package crc64 implements the 64-bit cyclic redundancy check, or CRC-64, checksum. See &lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&lt;/a&gt; for information.</source>
          <target state="translated">程序包crc64实现64位循环冗余校验或CRC-64校验和。有关信息，请参见&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4f6d2ede86f313691ef17454cdcdea04be0dbbb5" translate="yes" xml:space="preserve">
          <source>Package crypto</source>
          <target state="translated">包装加密</target>
        </trans-unit>
        <trans-unit id="50dd6822d044a230766309da5791bbd273ba8e97" translate="yes" xml:space="preserve">
          <source>Package crypto collects common cryptographic constants.</source>
          <target state="translated">包 crypto 收集了常见的加密常量。</target>
        </trans-unit>
        <trans-unit id="6ce5f5b5df462bd32a5711f5f5fa215ca1b166ed" translate="yes" xml:space="preserve">
          <source>Package csv</source>
          <target state="translated">包csv</target>
        </trans-unit>
        <trans-unit id="40dd7303701bdcc70dc0c5df42eb5d6ee214e250" translate="yes" xml:space="preserve">
          <source>Package csv reads and writes comma-separated values (CSV) files.</source>
          <target state="translated">包csv读取和写入逗号分隔的值(CSV)文件。</target>
        </trans-unit>
        <trans-unit id="d150a0359eb47f620b34dee9c311dced79bcede8" translate="yes" xml:space="preserve">
          <source>Package csv reads and writes comma-separated values (CSV) files. There are many kinds of CSV files; this package supports the format described in RFC 4180.</source>
          <target state="translated">包 csv 读取和写入逗号分隔的值(CSV)文件。CSV文件有很多种,这个包支持RFC 4180中描述的格式。</target>
        </trans-unit>
        <trans-unit id="c161780a1f5eed6cb5eacae516343d9cf53f40a2" translate="yes" xml:space="preserve">
          <source>Package debug</source>
          <target state="translated">包调试</target>
        </trans-unit>
        <trans-unit id="e18c0cfe3c81fb4f011a9c8574f9e5713e35fc2f" translate="yes" xml:space="preserve">
          <source>Package debug contains facilities for programs to debug themselves while they are running.</source>
          <target state="translated">包调试包含了程序在运行时进行自我调试的设施。</target>
        </trans-unit>
        <trans-unit id="923e094a4a23dcbdaf9a79a349be666ee4da178a" translate="yes" xml:space="preserve">
          <source>Package des</source>
          <target state="translated">套餐</target>
        </trans-unit>
        <trans-unit id="f4273b555bae00c756bb38c4bdb36871d156fde9" translate="yes" xml:space="preserve">
          <source>Package des implements the Data Encryption Standard (DES) and the Triple Data Encryption Algorithm (TDEA) as defined in U.S. Federal Information Processing Standards Publication 46-3.</source>
          <target state="translated">包des实现了美国联邦信息处理标准出版物46-3中定义的数据加密标准(DES)和三重数据加密算法(TDEA)。</target>
        </trans-unit>
        <trans-unit id="6bf60b0613abca5907226299b84a4808f25c054a" translate="yes" xml:space="preserve">
          <source>Package doc</source>
          <target state="translated">文件包</target>
        </trans-unit>
        <trans-unit id="994d342a4898c4785e34e9db0e04a8dc47ee5ddc" translate="yes" xml:space="preserve">
          <source>Package doc extracts source code documentation from a Go AST.</source>
          <target state="translated">Package doc从Go AST中提取源代码文档。</target>
        </trans-unit>
        <trans-unit id="5069be6dcffa96eefcc7e1232c85b45e87fe235f" translate="yes" xml:space="preserve">
          <source>Package draw</source>
          <target state="translated">包装抽奖</target>
        </trans-unit>
        <trans-unit id="969fe7ec8173399610653b077ab51865992b53af" translate="yes" xml:space="preserve">
          <source>Package draw provides image composition functions.</source>
          <target state="translated">包draw提供图像合成功能。</target>
        </trans-unit>
        <trans-unit id="b15191fdde73d73923a18606c1904389361bc1f7" translate="yes" xml:space="preserve">
          <source>Package driver</source>
          <target state="translated">软件包驱动程序</target>
        </trans-unit>
        <trans-unit id="5c56f884cb2d5a4829273b5f372f47a0c56fc3c2" translate="yes" xml:space="preserve">
          <source>Package driver defines interfaces to be implemented by database drivers as used by package sql.</source>
          <target state="translated">包驱动定义了数据库驱动所要实现的接口,正如包sql所使用的那样。</target>
        </trans-unit>
        <trans-unit id="75bfd93d536faf5b82f79c9e4a6af54202df462f" translate="yes" xml:space="preserve">
          <source>Package dsa</source>
          <target state="translated">包裹dsa</target>
        </trans-unit>
        <trans-unit id="1e5b1f9060cf17d69c4113c4252756af952bfee1" translate="yes" xml:space="preserve">
          <source>Package dsa implements the Digital Signature Algorithm, as defined in FIPS 186-3.</source>
          <target state="translated">包 dsa 实现了 FIPS 186-3 中定义的数字签名算法。</target>
        </trans-unit>
        <trans-unit id="bba8e43639aa6507cfdd4c58cc34c9fb8b2cf7ed" translate="yes" xml:space="preserve">
          <source>Package dwarf</source>
          <target state="translated">侏儒包</target>
        </trans-unit>
        <trans-unit id="14e7ceae4640d2c62b637a66be95977203616d50" translate="yes" xml:space="preserve">
          <source>Package dwarf provides access to DWARF debugging information loaded from executable files, as defined in the DWARF 2.0 Standard at &lt;a href=&quot;http://dwarfstd.org/doc/dwarf-2.0.0.pdf&quot;&gt;http://dwarfstd.org/doc/dwarf-2.0.0.pdf&lt;/a&gt;</source>
          <target state="translated">dwarf软件包提供对从可执行文件加载的DWARF调试信息的访问权限，如DWARF 2.0标准中所定义，该信息位于&lt;a href=&quot;http://dwarfstd.org/doc/dwarf-2.0.0.pdf&quot;&gt;http://dwarfstd.org/doc/dwarf-2.0.0.pdf&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ccd56c1dfed1c041a4d12453cec3b05cda768eb7" translate="yes" xml:space="preserve">
          <source>Package ecdsa</source>
          <target state="translated">包材ecdsa</target>
        </trans-unit>
        <trans-unit id="352bd4aa5e4bbbc282580a9c214c315f78762a78" translate="yes" xml:space="preserve">
          <source>Package ecdsa implements the Elliptic Curve Digital Signature Algorithm, as defined in FIPS 186-3.</source>
          <target state="translated">包 ecdsa 实现了 FIPS 186-3 中定义的椭圆曲线数字签名算法。</target>
        </trans-unit>
        <trans-unit id="22f041b9e4b005e5e63601ee047c6784ff58304a" translate="yes" xml:space="preserve">
          <source>Package ed25519</source>
          <target state="translated">包件ed25519</target>
        </trans-unit>
        <trans-unit id="fb8453c2683c8a0379237947977a4025115b54f4" translate="yes" xml:space="preserve">
          <source>Package ed25519 implements the Ed25519 signature algorithm.</source>
          <target state="translated">包ed25519实现了Ed25519签名算法。</target>
        </trans-unit>
        <trans-unit id="59626533c02e37a4826df5b84fcfc9afa7203b79" translate="yes" xml:space="preserve">
          <source>Package ed25519 implements the Ed25519 signature algorithm. See &lt;a href=&quot;https://ed25519.cr.yp.to/&quot;&gt;https://ed25519.cr.yp.to/&lt;/a&gt;.</source>
          <target state="translated">软件包ed25519实现了Ed25519签名算法。参见&lt;a href=&quot;https://ed25519.cr.yp.to/&quot;&gt;https://ed25519.cr.yp.to/&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="22876ea6aba1d18293913d0db2521ad8767018c8" translate="yes" xml:space="preserve">
          <source>Package elf</source>
          <target state="translated">包装精灵</target>
        </trans-unit>
        <trans-unit id="e380ec79714ca14aed830146e07f72516490e0b8" translate="yes" xml:space="preserve">
          <source>Package elf implements access to ELF object files.</source>
          <target state="translated">包elf实现了对ELF对象文件的访问。</target>
        </trans-unit>
        <trans-unit id="c011316b96f999a9e3cf849a36b3fc15797d8e99" translate="yes" xml:space="preserve">
          <source>Package elliptic</source>
          <target state="translated">椭圆包</target>
        </trans-unit>
        <trans-unit id="3bab3655adc3a192a092b071bc83e45652e1d476" translate="yes" xml:space="preserve">
          <source>Package elliptic implements several standard elliptic curves over prime fields.</source>
          <target state="translated">包椭圆实现了几种标准的素域上的椭圆曲线。</target>
        </trans-unit>
        <trans-unit id="50d1b2632f0717d2aa181f074409034967564a4c" translate="yes" xml:space="preserve">
          <source>Package embed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe7d97c649fe8203079542be753a5d538190fc89" translate="yes" xml:space="preserve">
          <source>Package embed provides access to files embedded in the running Go program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1b2d294cf9a0cfac69d667bd45e68644ccbf3c6" translate="yes" xml:space="preserve">
          <source>Package encoding</source>
          <target state="translated">包装编码</target>
        </trans-unit>
        <trans-unit id="ed189180f83e61e5ab517f381324404e9d31f4c0" translate="yes" xml:space="preserve">
          <source>Package encoding defines interfaces shared by other packages that convert data to and from byte-level and textual representations. Packages that check for these interfaces include encoding/gob, encoding/json, and encoding/xml. As a result, implementing an interface once can make a type useful in multiple encodings. Standard types that implement these interfaces include time.Time and net.IP. The interfaces come in pairs that produce and consume encoded data.</source>
          <target state="translated">包编码定义了由其他包共享的接口,这些接口将数据转换为字节级和文本表示。检查这些接口的包包括 encoding/gob、encoding/json 和 encoding/xml。因此,实现一次接口可以使一个类型在多种编码中有用。实现这些接口的标准类型包括time.Time和net.IP。这些接口成对地产生和消耗编码数据。</target>
        </trans-unit>
        <trans-unit id="6ee23de7e1e5b835e55c54376bdadcfebe218831" translate="yes" xml:space="preserve">
          <source>Package errors</source>
          <target state="translated">包装错误</target>
        </trans-unit>
        <trans-unit id="4a3bda8668f0f7be8e4653eb9de5b1df5a4b72ae" translate="yes" xml:space="preserve">
          <source>Package errors implements functions to manipulate errors.</source>
          <target state="translated">包错误实现了操作错误的函数。</target>
        </trans-unit>
        <trans-unit id="7627f68608d0501d49a4083a780c7eb361e07f6d" translate="yes" xml:space="preserve">
          <source>Package exec</source>
          <target state="translated">包执行</target>
        </trans-unit>
        <trans-unit id="ee030f10ad063000193fa361b43cfffc1bcc3c8c" translate="yes" xml:space="preserve">
          <source>Package exec runs external commands.</source>
          <target state="translated">Package exec运行外部命令。</target>
        </trans-unit>
        <trans-unit id="7b3a0dfc0fae8cd217bc6e25080e713ad98645d6" translate="yes" xml:space="preserve">
          <source>Package exec runs external commands. It wraps os.StartProcess to make it easier to remap stdin and stdout, connect I/O with pipes, and do other adjustments.</source>
          <target state="translated">包exec运行外部命令。它封装了os.StartProcess,使其更容易重映射stdin和stdout,用管道连接I/O,并进行其他调整。</target>
        </trans-unit>
        <trans-unit id="56d612eb4d8eb6cceb1e7052a93aac6c0e863c13" translate="yes" xml:space="preserve">
          <source>Package expvar</source>
          <target state="translated">包expvar</target>
        </trans-unit>
        <trans-unit id="8556b9ff068352b9cd4f96c39543b774957282c2" translate="yes" xml:space="preserve">
          <source>Package expvar provides a standardized interface to public variables, such as operation counters in servers. It exposes these variables via HTTP at /debug/vars in JSON format.</source>
          <target state="translated">包expvar为公共变量提供了一个标准化的接口,比如服务器中的操作计数器。它通过HTTP以JSON格式在/debug/vars中公开这些变量。</target>
        </trans-unit>
        <trans-unit id="7753afb6ef13a60250c22070f9d8cb74aca0cdd9" translate="yes" xml:space="preserve">
          <source>Package fcgi</source>
          <target state="translated">包fcgi</target>
        </trans-unit>
        <trans-unit id="2130ff15a15a985590dbae853cbc6bd5f16bc412" translate="yes" xml:space="preserve">
          <source>Package fcgi implements the FastCGI protocol.</source>
          <target state="translated">包fcgi实现了FastCGI协议。</target>
        </trans-unit>
        <trans-unit id="2f468670b5944c845b0cba8a76b0cc4bc25c4814" translate="yes" xml:space="preserve">
          <source>Package filepath</source>
          <target state="translated">包文件路径</target>
        </trans-unit>
        <trans-unit id="aad84fa78fc1a5621f1a8d48a9f041dd752165f9" translate="yes" xml:space="preserve">
          <source>Package filepath implements utility routines for manipulating filename paths in a way compatible with the target operating system-defined file paths.</source>
          <target state="translated">包filepath实现了实用程序,用于以与目标操作系统定义的文件路径兼容的方式操作文件名路径。</target>
        </trans-unit>
        <trans-unit id="20c64fec5374a451273360446201779aff8c1424" translate="yes" xml:space="preserve">
          <source>Package files</source>
          <target state="translated">包装文件</target>
        </trans-unit>
        <trans-unit id="e5471378272dfaa2efadcd1f53861518b9f099f7" translate="yes" xml:space="preserve">
          <source>Package flag</source>
          <target state="translated">包装旗</target>
        </trans-unit>
        <trans-unit id="e7d9cd955d937c95fcd6a1739c4bfae5a8cbabd2" translate="yes" xml:space="preserve">
          <source>Package flag implements command-line flag parsing.</source>
          <target state="translated">包标志实现命令行标志解析。</target>
        </trans-unit>
        <trans-unit id="a337ebb67872d5c06c8e204854b5aa24937ec53e" translate="yes" xml:space="preserve">
          <source>Package flate</source>
          <target state="translated">包片</target>
        </trans-unit>
        <trans-unit id="cd21214e87a49e1d6a376d93be54459975506452" translate="yes" xml:space="preserve">
          <source>Package flate implements the DEFLATE compressed data format, described in RFC 1951. The gzip and zlib packages implement access to DEFLATE-based file formats.</source>
          <target state="translated">包flate实现了RFC 1951中描述的DEFLATE压缩数据格式。gzip和zlib包实现了对基于DEFLATE的文件格式的访问。</target>
        </trans-unit>
        <trans-unit id="803b763e8c63b8639017426b9ddb6efdb2934c44" translate="yes" xml:space="preserve">
          <source>Package fmt</source>
          <target state="translated">fmt包</target>
        </trans-unit>
        <trans-unit id="d4c2ac9d05c1a7be572af9a00f7d2ee2c86ace0b" translate="yes" xml:space="preserve">
          <source>Package fmt implements formatted I/O with functions analogous to C's printf and scanf. The format 'verbs' are derived from C's but are simpler.</source>
          <target state="translated">包fmt实现了格式化的I/O,其功能类似于C的printf和scanf。格式 &quot;动词 &quot;是从C语言中衍生出来的,但更简单。</target>
        </trans-unit>
        <trans-unit id="d7f1bbda6df0adc48225339cb988bf008c879f32" translate="yes" xml:space="preserve">
          <source>Package fnv</source>
          <target state="translated">包裹fnv</target>
        </trans-unit>
        <trans-unit id="1ed450736ae5a7fac5851c4ce48e5c295154cd82" translate="yes" xml:space="preserve">
          <source>Package fnv implements FNV-1 and FNV-1a, non-cryptographic hash functions created by Glenn Fowler, Landon Curt Noll, and Phong Vo.</source>
          <target state="translated">包fnv实现了FNV-1和FNV-1a,由Glenn Fowler、Landon Curt Noll和Phong Vo创建的非加密哈希函数。</target>
        </trans-unit>
        <trans-unit id="3bfeda77f81e7eb63d4ceaa90d61b0d8cdf6c313" translate="yes" xml:space="preserve">
          <source>Package fnv implements FNV-1 and FNV-1a, non-cryptographic hash functions created by Glenn Fowler, Landon Curt Noll, and Phong Vo. See &lt;a href=&quot;https://en.wikipedia.org/wiki/Fowler-Noll-Vo_hash_function&quot;&gt;https://en.wikipedia.org/wiki/Fowler-Noll-Vo_hash_function&lt;/a&gt;.</source>
          <target state="translated">软件包fnv实现了FNV-1和FNV-1a，这是由Glenn Fowler，Landon Curt Noll和Phong Vo创建的非加密哈希函数。参见&lt;a href=&quot;https://en.wikipedia.org/wiki/Fowler-Noll-Vo_hash_function&quot;&gt;https://en.wikipedia.org/wiki/Fowler-Noll-Vo_hash_function&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6e1e99b0cea0f06b1bed3052795d0456203e66ac" translate="yes" xml:space="preserve">
          <source>Package format</source>
          <target state="translated">包装格式</target>
        </trans-unit>
        <trans-unit id="44b5a52572ad981c0279cfa1b8249c656292c37c" translate="yes" xml:space="preserve">
          <source>Package format implements standard formatting of Go source.</source>
          <target state="translated">包格式实现了Go源代码的标准格式化。</target>
        </trans-unit>
        <trans-unit id="ea471709f1096aad48e7c76286e5acfe1b4f1658" translate="yes" xml:space="preserve">
          <source>Package fs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecc170182343b9acbc49399a571c0bf5cdaa286e" translate="yes" xml:space="preserve">
          <source>Package fs defines basic interfaces to a file system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48e9e53ed3536d4912df46e0962f56c550d05b56" translate="yes" xml:space="preserve">
          <source>Package fs defines basic interfaces to a file system. A file system can be provided by the host operating system but also by other packages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10794fc70844a16a1ca02980500d4bade1aabcb2" translate="yes" xml:space="preserve">
          <source>Package fstest</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="730297a3843e81d6e02a169d9ecb873ab96a3dae" translate="yes" xml:space="preserve">
          <source>Package fstest implements support for testing implementations and users of file systems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b91f9f521a74becec1958e73da770098048f55a7" translate="yes" xml:space="preserve">
          <source>Package gif</source>
          <target state="translated">包裹gif</target>
        </trans-unit>
        <trans-unit id="10af1984ddf2d910dc561741c129eaf2fb3d93fc" translate="yes" xml:space="preserve">
          <source>Package gif implements a GIF image decoder and encoder.</source>
          <target state="translated">包gif实现了一个GIF图像解码器和编码器。</target>
        </trans-unit>
        <trans-unit id="e3be21e16b230bb3bdb8bf1710ba144ad69deeeb" translate="yes" xml:space="preserve">
          <source>Package gob</source>
          <target state="translated">包裹口罩</target>
        </trans-unit>
        <trans-unit id="a418c33843d2c062092d6d7c6a4b5816c45727d5" translate="yes" xml:space="preserve">
          <source>Package gob manages streams of gobs - binary values exchanged between an Encoder (transmitter) and a Decoder (receiver).</source>
          <target state="translated">包gob管理gob流--编码器(发送器)和解码器(接收器)之间交换的二进制值。</target>
        </trans-unit>
        <trans-unit id="44cd01d964bb483f352db2a1b5d4abe8f1b01e5e" translate="yes" xml:space="preserve">
          <source>Package gob manages streams of gobs - binary values exchanged between an Encoder (transmitter) and a Decoder (receiver). A typical use is transporting arguments and results of remote procedure calls (RPCs) such as those provided by package &quot;net/rpc&quot;.</source>
          <target state="translated">包gob管理gob流--编码器(发送器)和解码器(接收器)之间交换的二进制值。一个典型的用途是传输远程过程调用(RPC)的参数和结果,如 &quot;net/rpc &quot;包提供的那些。</target>
        </trans-unit>
        <trans-unit id="00c000f3850e24bf28c662891a897dac5381ac6c" translate="yes" xml:space="preserve">
          <source>Package gosym</source>
          <target state="translated">包裹 gosym</target>
        </trans-unit>
        <trans-unit id="2e38d0f781b2d46a7d764ec5db29147877b83b80" translate="yes" xml:space="preserve">
          <source>Package gosym implements access to the Go symbol and line number tables embedded in Go binaries generated by the gc compilers.</source>
          <target state="translated">包 gosym 实现了对 gc 编译器生成的 Go 二进制文件中嵌入的 Go 符号和行号表的访问。</target>
        </trans-unit>
        <trans-unit id="7a918ba298748f37d152f5cb60e30e14a28d12c9" translate="yes" xml:space="preserve">
          <source>Package gzip</source>
          <target state="translated">包gzip</target>
        </trans-unit>
        <trans-unit id="29dec348206cd4001b61a9c9f0a5d0e43fd7f769" translate="yes" xml:space="preserve">
          <source>Package gzip implements reading and writing of gzip format compressed files, as specified in RFC 1952.</source>
          <target state="translated">包gzip实现了RFC 1952中规定的gzip格式压缩文件的读写。</target>
        </trans-unit>
        <trans-unit id="14ea7753f344ada7c0aa1963e2baed63cdc13331" translate="yes" xml:space="preserve">
          <source>Package hash</source>
          <target state="translated">包的哈希值</target>
        </trans-unit>
        <trans-unit id="a85d6200368ac18f684b218608b5fa8afb33d33f" translate="yes" xml:space="preserve">
          <source>Package hash provides interfaces for hash functions.</source>
          <target state="translated">包哈希提供了哈希函数的接口。</target>
        </trans-unit>
        <trans-unit id="3a59626485ffbd81c7d5e90634cb6e93e7c34e5b" translate="yes" xml:space="preserve">
          <source>Package heap</source>
          <target state="translated">包装堆</target>
        </trans-unit>
        <trans-unit id="e93c407a24d497fcea18deaab136750e41bee04c" translate="yes" xml:space="preserve">
          <source>Package heap provides heap operations for any type that implements heap.Interface. A heap is a tree with the property that each node is the minimum-valued node in its subtree.</source>
          <target state="translated">包 heap 为任何实现 heap.Interface 的类型提供堆操作。一个堆是一棵树,其属性是每个节点都是其子树中最小值的节点。</target>
        </trans-unit>
        <trans-unit id="7b0d8dd93b6da00a5a3853f6a8971b11d3be119a" translate="yes" xml:space="preserve">
          <source>Package hex</source>
          <target state="translated">六角包</target>
        </trans-unit>
        <trans-unit id="7413aef6d1364ce17833992530bdefe998ac3dba" translate="yes" xml:space="preserve">
          <source>Package hex implements hexadecimal encoding and decoding.</source>
          <target state="translated">包hex实现了十六进制的编码和解码。</target>
        </trans-unit>
        <trans-unit id="1ae2b94353abc10afddd7e75ff8292b5ec664627" translate="yes" xml:space="preserve">
          <source>Package hmac</source>
          <target state="translated">包hmac</target>
        </trans-unit>
        <trans-unit id="5862414bf4e6f484aa549d995a6f4852a7f9b0df" translate="yes" xml:space="preserve">
          <source>Package hmac implements the Keyed-Hash Message Authentication Code (HMAC) as defined in U.S. Federal Information Processing Standards Publication 198.</source>
          <target state="translated">包 hmac 实现了美国联邦信息处理标准出版物 198 中定义的 Keyed-Hash Message Authentication Code(HMAC)。</target>
        </trans-unit>
        <trans-unit id="993a4c7f2aa0bc17bb821bd77a5cdca08736959a" translate="yes" xml:space="preserve">
          <source>Package hmac implements the Keyed-Hash Message Authentication Code (HMAC) as defined in U.S. Federal Information Processing Standards Publication 198. An HMAC is a cryptographic hash that uses a key to sign a message. The receiver verifies the hash by recomputing it using the same key.</source>
          <target state="translated">包hmac实现了美国联邦信息处理标准出版物198中定义的密钥散列消息认证码(HMAC)。HMAC是一个加密的散列码,它使用一个密钥来签署一个消息。接收者通过使用相同的密钥重新计算来验证该哈希值。</target>
        </trans-unit>
        <trans-unit id="fb848edc1bb28a05f8c5d03e75ae2933d6b8c193" translate="yes" xml:space="preserve">
          <source>Package html</source>
          <target state="translated">html包</target>
        </trans-unit>
        <trans-unit id="ee6e4064cc07f14cce23003d26486bcbe481c4c8" translate="yes" xml:space="preserve">
          <source>Package html provides functions for escaping and unescaping HTML text.</source>
          <target state="translated">包html提供了转义和取消转义HTML文本的功能。</target>
        </trans-unit>
        <trans-unit id="93aded6e94d278e605519fd733984fb105ebc8cb" translate="yes" xml:space="preserve">
          <source>Package http</source>
          <target state="translated">http包</target>
        </trans-unit>
        <trans-unit id="565f53df2ba05962d275cc2ddb64a0ff5b302111" translate="yes" xml:space="preserve">
          <source>Package http provides HTTP client and server implementations.</source>
          <target state="translated">http包提供了HTTP客户端和服务器的实现。</target>
        </trans-unit>
        <trans-unit id="60c2fddc445e71feb989d0582a02f4947d2d457d" translate="yes" xml:space="preserve">
          <source>Package httptest</source>
          <target state="translated">httptest包</target>
        </trans-unit>
        <trans-unit id="aa8780d1e29dd261a3c2246607eef7a72b8bbb1d" translate="yes" xml:space="preserve">
          <source>Package httptest provides utilities for HTTP testing.</source>
          <target state="translated">包httptest提供HTTP测试的工具。</target>
        </trans-unit>
        <trans-unit id="0f537d98dbab242ca895592a50db6e67fd272c97" translate="yes" xml:space="preserve">
          <source>Package httptrace</source>
          <target state="translated">包 httptrace</target>
        </trans-unit>
        <trans-unit id="813e220dd05ef49b41ec90a3fc88de9ec143f032" translate="yes" xml:space="preserve">
          <source>Package httptrace provides mechanisms to trace the events within HTTP client requests.</source>
          <target state="translated">包httptrace提供了跟踪HTTP客户端请求中事件的机制。</target>
        </trans-unit>
        <trans-unit id="9613bdf01a4050ee78eaddb84e11fc64ec270990" translate="yes" xml:space="preserve">
          <source>Package httputil</source>
          <target state="translated">包 httputil</target>
        </trans-unit>
        <trans-unit id="76d80a4fa32f388098c8efd95fe330b71ff09bd9" translate="yes" xml:space="preserve">
          <source>Package httputil provides HTTP utility functions, complementing the more common ones in the net/http package.</source>
          <target state="translated">包httputil提供了HTTP的实用功能,补充了net/http包中比较常见的功能。</target>
        </trans-unit>
        <trans-unit id="421a469bd8c6ddf7b1af341ec45254a3934f90ed" translate="yes" xml:space="preserve">
          <source>Package image</source>
          <target state="translated">包装图片</target>
        </trans-unit>
        <trans-unit id="4aa8ef8dbcca06a643631802f3d7a141211d42b0" translate="yes" xml:space="preserve">
          <source>Package image implements a basic 2-D image library.</source>
          <target state="translated">包image实现了一个基本的二维图像库。</target>
        </trans-unit>
        <trans-unit id="2dc8e28a838b11d0551b3a0d88ebb2a4408dab5b" translate="yes" xml:space="preserve">
          <source>Package importer</source>
          <target state="translated">包装进口商</target>
        </trans-unit>
        <trans-unit id="420252f85bc81d5c6c24a04bcbd00100b4357969" translate="yes" xml:space="preserve">
          <source>Package importer provides access to export data importers.</source>
          <target state="translated">包导入器提供对导出数据导入器的访问。</target>
        </trans-unit>
        <trans-unit id="93b91053c7ffebf57a4a0530d2af3609eb527706" translate="yes" xml:space="preserve">
          <source>Package internal</source>
          <target state="translated">包装内部</target>
        </trans-unit>
        <trans-unit id="ae4bbcb538c3d4b00aa18c51e1cf94d759fc3060" translate="yes" xml:space="preserve">
          <source>Package internal contains HTTP internals shared by net/http and net/http/httputil.</source>
          <target state="translated">包内部包含net/http和net/http/httputil共享的HTTP内部结构。</target>
        </trans-unit>
        <trans-unit id="e9636058f09cfb43189cb98a195789b7f0f244da" translate="yes" xml:space="preserve">
          <source>Package io</source>
          <target state="translated">包裹io</target>
        </trans-unit>
        <trans-unit id="32668f487482a47ba7dcd798b007284f2070596c" translate="yes" xml:space="preserve">
          <source>Package io provides basic interfaces to I/O primitives. Its primary job is to wrap existing implementations of such primitives, such as those in package os, into shared public interfaces that abstract the functionality, plus some other related primitives.</source>
          <target state="translated">包io提供了I/O基元的基本接口。它的主要工作是将这些基元的现有实现(如包os中的实现)包装成共享的公共接口,这些接口抽象了这些功能,再加上一些其他相关的基元。</target>
        </trans-unit>
        <trans-unit id="30cb02e7eab55914ca42d64df94b0246f5f91b46" translate="yes" xml:space="preserve">
          <source>Package iotest</source>
          <target state="translated">包iotest</target>
        </trans-unit>
        <trans-unit id="2188f45ca7e2af66c7f08124940a486765a3a1d3" translate="yes" xml:space="preserve">
          <source>Package iotest implements Readers and Writers useful mainly for testing.</source>
          <target state="translated">包iotest实现了主要用于测试的读写器。</target>
        </trans-unit>
        <trans-unit id="f634706aadf3538974af07a1962d2af1e6651011" translate="yes" xml:space="preserve">
          <source>Package ioutil</source>
          <target state="translated">包ioutil</target>
        </trans-unit>
        <trans-unit id="b7b8fc12300546d76dd9c8e4af13cff6a6ad7548" translate="yes" xml:space="preserve">
          <source>Package ioutil implements some I/O utility functions.</source>
          <target state="translated">包ioutil实现了一些I/O实用功能。</target>
        </trans-unit>
        <trans-unit id="c9fe1f4196a35af3e90e6bd308c01296038ce831" translate="yes" xml:space="preserve">
          <source>Package is the documentation for an entire package.</source>
          <target state="translated">包是整个包的文档。</target>
        </trans-unit>
        <trans-unit id="4c1d637bde171a0a8b7330b1b7e32fbe44f587a8" translate="yes" xml:space="preserve">
          <source>Package jpeg</source>
          <target state="translated">包jpeg</target>
        </trans-unit>
        <trans-unit id="be891878e9ef59cdb50913b5ceb2d5944c8960f6" translate="yes" xml:space="preserve">
          <source>Package jpeg implements a JPEG image decoder and encoder.</source>
          <target state="translated">包jpeg实现了一个JPEG图像解码器和编码器。</target>
        </trans-unit>
        <trans-unit id="5232feffa0151247920dae06a9ddd5d55973aeb8" translate="yes" xml:space="preserve">
          <source>Package js</source>
          <target state="translated">包 js</target>
        </trans-unit>
        <trans-unit id="8dacbfd07dd845e3d61f3d13d059dcc9341b5c76" translate="yes" xml:space="preserve">
          <source>Package js gives access to the WebAssembly host environment when using the js/wasm architecture.</source>
          <target state="translated">包js在使用js/wasm架构时,可以访问WebAssembly主机环境。</target>
        </trans-unit>
        <trans-unit id="455c332edf437e87334e708fb429cc6e36a5ac4c" translate="yes" xml:space="preserve">
          <source>Package js gives access to the WebAssembly host environment when using the js/wasm architecture. Its API is based on JavaScript semantics.</source>
          <target state="translated">包js在使用js/wasm架构时,可以访问WebAssembly主机环境。它的API是基于JavaScript语义的。</target>
        </trans-unit>
        <trans-unit id="3857092de217368375e6707dd2db2ce13bf5c6d4" translate="yes" xml:space="preserve">
          <source>Package json</source>
          <target state="translated">包json</target>
        </trans-unit>
        <trans-unit id="7ba30886d6ae888888da2bc78eb7b020f20e938d" translate="yes" xml:space="preserve">
          <source>Package json implements encoding and decoding of JSON as defined in RFC 7159.</source>
          <target state="translated">包 json 实现了 RFC 7159 中定义的 JSON 的编码和解码。</target>
        </trans-unit>
        <trans-unit id="87906380a06bba048f9b4e8bd43cd1fc7f064c58" translate="yes" xml:space="preserve">
          <source>Package json implements encoding and decoding of JSON as defined in RFC 7159. The mapping between JSON and Go values is described in the documentation for the Marshal and Unmarshal functions.</source>
          <target state="translated">包 json 实现了 RFC 7159 中定义的 JSON 的编码和解码。JSON和Go值之间的映射在Marshal和Unmarshal函数的文档中描述。</target>
        </trans-unit>
        <trans-unit id="89d676dca8ece21fde225b9a51b937ba3f6ad6a6" translate="yes" xml:space="preserve">
          <source>Package jsonrpc</source>
          <target state="translated">包 jsonrpc</target>
        </trans-unit>
        <trans-unit id="1c78124a6a4761b03c5384a07f14a75cc4666f38" translate="yes" xml:space="preserve">
          <source>Package jsonrpc implements a JSON-RPC 1.0 ClientCodec and ServerCodec for the rpc package.</source>
          <target state="translated">包jsonrpc为rpc包实现了JSON-RPC 1.0 ClientCodec和ServerCodec。</target>
        </trans-unit>
        <trans-unit id="09af982985244ee30f92c80e2ab36bc0138d5a7f" translate="yes" xml:space="preserve">
          <source>Package jsonrpc implements a JSON-RPC 1.0 ClientCodec and ServerCodec for the rpc package. For JSON-RPC 2.0 support, see &lt;a href=&quot;https://godoc.org/?q=json-rpc+2.0&quot;&gt;https://godoc.org/?q=json-rpc+2.0&lt;/a&gt;</source>
          <target state="translated">包jsonrpc为rpc包实现了JSON-RPC 1.0 ClientCodec和ServerCodec。有关JSON-RPC 2.0的支持，请参见&lt;a href=&quot;https://godoc.org/?q=json-rpc+2.0&quot;&gt;https://godoc.org/?q=json-rpc+2.0&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="329023972d7b1c502617105ef48cde0a78cc6333" translate="yes" xml:space="preserve">
          <source>Package list</source>
          <target state="translated">包装清单</target>
        </trans-unit>
        <trans-unit id="e56f44c63fe9d6afdfff2ff8bc53c3b472803b64" translate="yes" xml:space="preserve">
          <source>Package list implements a doubly linked list.</source>
          <target state="translated">包列表实现了一个双链接的列表。</target>
        </trans-unit>
        <trans-unit id="39f07fcf96398e5964be22f3a7e100e6e4714031" translate="yes" xml:space="preserve">
          <source>Package log</source>
          <target state="translated">包装日志</target>
        </trans-unit>
        <trans-unit id="c01d2cd8db1d9fe6fc80ae05326ed0052a2926ca" translate="yes" xml:space="preserve">
          <source>Package log implements a simple logging package. It defines a type, Logger, with methods for formatting output. It also has a predefined 'standard' Logger accessible through helper functions Print[f|ln], Fatal[f|ln], and Panic[f|ln], which are easier to use than creating a Logger manually. That logger writes to standard error and prints the date and time of each logged message. Every log message is output on a separate line: if the message being printed does not end in a newline, the logger will add one. The Fatal functions call os.Exit(1) after writing the log message. The Panic functions call panic after writing the log message.</source>
          <target state="translated">包log实现了一个简单的日志包。它定义了一个类型,Logger,以及用于格式化输出的方法。它也有一个预定义的 &quot;标准 &quot;Logger,可以通过帮助函数Print[f|ln]、Fatal[f|ln]和Panic[f|ln]来访问,这比手动创建一个Logger更容易使用。该日志器将写入标准错误,并打印每条日志消息的日期和时间。每条日志消息都会在单独的一行上输出:如果被打印的消息没有以换行结束,记录器就会添加一个换行。Fatal 函数在写完日志消息后会调用 os.Exit(1)。Panic 函数在写完日志消息后调用 panic。</target>
        </trans-unit>
        <trans-unit id="2736ca6dade93fff8e3bc211ddd7f28c53ea115b" translate="yes" xml:space="preserve">
          <source>Package lzw</source>
          <target state="translated">包lzw</target>
        </trans-unit>
        <trans-unit id="c4777021f1dd4b6564d1ec41e7d3abc076b6187e" translate="yes" xml:space="preserve">
          <source>Package lzw implements the Lempel-Ziv-Welch compressed data format, described in T. A. Welch, &amp;ldquo;A Technique for High-Performance Data Compression&amp;rdquo;, Computer, 17(6) (June 1984), pp 8-19.</source>
          <target state="translated">软件包lzw实施了Le Welch-Ziv-Welch压缩数据格式，该格式在TA Welch，&amp;ldquo;高性能数据压缩技术&amp;rdquo;，计算机，第17（6）版（1984年6月），第8-19页中进行了介绍。</target>
        </trans-unit>
        <trans-unit id="0e8e7d95f57fe8be09d8faaa0ea86acf1a5fc077" translate="yes" xml:space="preserve">
          <source>Package macho</source>
          <target state="translated">包装大男子主义</target>
        </trans-unit>
        <trans-unit id="92e8c827c8c83c12e1e7b7f121d38fd11d3d6bba" translate="yes" xml:space="preserve">
          <source>Package macho implements access to Mach-O object files.</source>
          <target state="translated">包macho实现了对Mach-O对象文件的访问。</target>
        </trans-unit>
        <trans-unit id="6fe93114653da182b59c5cf973ab0a06ef574c15" translate="yes" xml:space="preserve">
          <source>Package mail</source>
          <target state="translated">包裹邮件</target>
        </trans-unit>
        <trans-unit id="6f8e8eb862b5bec7f5c8edcb6c15137f3e2e3084" translate="yes" xml:space="preserve">
          <source>Package mail implements parsing of mail messages.</source>
          <target state="translated">包邮件实现了邮件信息的解析。</target>
        </trans-unit>
        <trans-unit id="a187699c2d623561de3c74219fd194073fc12ad0" translate="yes" xml:space="preserve">
          <source>Package maphash</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9648f416f81b26989caa5e33a93eec78f1682daa" translate="yes" xml:space="preserve">
          <source>Package maphash provides hash functions on byte sequences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ccb1245d8ae5c41c54040e7ae73136e5b36abc1" translate="yes" xml:space="preserve">
          <source>Package maphash provides hash functions on byte sequences. These hash functions are intended to be used to implement hash tables or other data structures that need to map arbitrary strings or byte sequences to a uniform distribution on unsigned 64-bit integers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbbd4bd77faa074039c44407845db0caf5578b1e" translate="yes" xml:space="preserve">
          <source>Package maphash provides hash functions on byte sequences. These hash functions are intended to be used to implement hash tables or other data structures that need to map arbitrary strings or byte sequences to a uniform distribution on unsigned 64-bit integers. Each different instance of a hash table or data structure should use its own Seed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="383fe77ace45b295ad208a38e47b35209b6b894f" translate="yes" xml:space="preserve">
          <source>Package math</source>
          <target state="translated">套餐数学</target>
        </trans-unit>
        <trans-unit id="b6130e3233ca7fa326fe0f65160f4609452fcc5c" translate="yes" xml:space="preserve">
          <source>Package math provides basic constants and mathematical functions.</source>
          <target state="translated">包数学提供了基本常量和数学函数。</target>
        </trans-unit>
        <trans-unit id="91905953ed9b218a4bdf61f1b0e37fe7e7362ece" translate="yes" xml:space="preserve">
          <source>Package md5</source>
          <target state="translated">包md5</target>
        </trans-unit>
        <trans-unit id="91e121cc95845f0e275412a014e511801fa15c71" translate="yes" xml:space="preserve">
          <source>Package md5 implements the MD5 hash algorithm as defined in RFC 1321.</source>
          <target state="translated">包md5实现了RFC 1321中定义的MD5哈希算法。</target>
        </trans-unit>
        <trans-unit id="51897b2c91f40b3cb9e9cd4fd40fe158e6ab22c6" translate="yes" xml:space="preserve">
          <source>Package metrics</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="530c83639110b995814f71ccaa8918d25839eefb" translate="yes" xml:space="preserve">
          <source>Package metrics provides a stable interface to access implementation-defined metrics exported by the Go runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c8e50bd95b8d24834893907762db017f6df4ef5" translate="yes" xml:space="preserve">
          <source>Package metrics provides a stable interface to access implementation-defined metrics exported by the Go runtime. This package is similar to existing functions like runtime.ReadMemStats and debug.ReadGCStats, but significantly more general.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e452f6ff2b6f89e6e2fddfc0bc47cc6ea9d38e3" translate="yes" xml:space="preserve">
          <source>Package mime</source>
          <target state="translated">包裹哑剧</target>
        </trans-unit>
        <trans-unit id="fb5b7d35717be7356677497c60f984d8bae7427b" translate="yes" xml:space="preserve">
          <source>Package mime implements parts of the MIME spec.</source>
          <target state="translated">包mime实现了MIME规范的部分内容。</target>
        </trans-unit>
        <trans-unit id="a4afe7ca5ec65b45429532cb822f68e7b1f969e3" translate="yes" xml:space="preserve">
          <source>Package multipart</source>
          <target state="translated">包装多部分</target>
        </trans-unit>
        <trans-unit id="0975c17eab222919880be81a12a600e92a6d534f" translate="yes" xml:space="preserve">
          <source>Package multipart implements MIME multipart parsing, as defined in RFC 2046.</source>
          <target state="translated">Package multipart实现了RFC 2046中定义的MIME多部分解析。</target>
        </trans-unit>
        <trans-unit id="30c5d58023a5520f3b07d9da146a5ed1519a8f7c" translate="yes" xml:space="preserve">
          <source>Package net</source>
          <target state="translated">包装网</target>
        </trans-unit>
        <trans-unit id="43d696099850d935770e8f7b1c038c883c0137cb" translate="yes" xml:space="preserve">
          <source>Package net provides a portable interface for network I/O, including TCP/IP, UDP, domain name resolution, and Unix domain sockets.</source>
          <target state="translated">Package net为网络I/O提供了一个可移植的接口,包括TCP/IP、UDP、域名解析和Unix域套接字。</target>
        </trans-unit>
        <trans-unit id="7ab70b00aa79e1b268257a5e997962ee78d287d2" translate="yes" xml:space="preserve">
          <source>Package os</source>
          <target state="translated">包os</target>
        </trans-unit>
        <trans-unit id="c733a9fd7f2534638a02811f5ea17d1a129c8b5c" translate="yes" xml:space="preserve">
          <source>Package os provides a platform-independent interface to operating system functionality. The design is Unix-like, although the error handling is Go-like; failing calls return values of type error rather than error numbers. Often, more information is available within the error. For example, if a call that takes a file name fails, such as Open or Stat, the error will include the failing file name when printed and will be of type *PathError, which may be unpacked for more information.</source>
          <target state="translated">包os提供了一个独立于平台的操作系统功能接口。它的设计类似于Unix,尽管错误处理类似于Go;失败的调用会返回错误类型的值,而不是错误号。通常情况下,错误中会有更多信息。例如,如果一个取文件名的调用失败了,如Open或Stat,那么打印时错误将包括失败的文件名,并且类型为*PathError,可以解包获取更多信息。</target>
        </trans-unit>
        <trans-unit id="04c8aee5e23a788ea2bcb38b074f985eac2786a8" translate="yes" xml:space="preserve">
          <source>Package palette</source>
          <target state="translated">托盘包装</target>
        </trans-unit>
        <trans-unit id="cf2f1921f30936ace0261b5025892d44ffab8eb3" translate="yes" xml:space="preserve">
          <source>Package palette provides standard color palettes.</source>
          <target state="translated">包装托盘提供标准色托盘。</target>
        </trans-unit>
        <trans-unit id="0242c171ef1c568c8ae1ca39756ba02bb57c4a9d" translate="yes" xml:space="preserve">
          <source>Package parse</source>
          <target state="translated">解析包</target>
        </trans-unit>
        <trans-unit id="417bd6bafe4778a0805898be461125c5d876274b" translate="yes" xml:space="preserve">
          <source>Package parse builds parse trees for templates as defined by text/template and html/template.</source>
          <target state="translated">Package parse为text/template和html/template定义的模板建立解析树。</target>
        </trans-unit>
        <trans-unit id="9c526058ffd19e7a03ef67d38acb87f2af58bf19" translate="yes" xml:space="preserve">
          <source>Package parse builds parse trees for templates as defined by text/template and html/template. Clients should use those packages to construct templates rather than this one, which provides shared internal data structures not intended for general use.</source>
          <target state="translated">Package parse为text/template和html/template定义的模板构建解析树。客户端应该使用这些包来构建模板,而不是使用这个包,因为它提供了共享的内部数据结构,并不打算用于一般用途。</target>
        </trans-unit>
        <trans-unit id="66cc9b613eb8bc3269dbf5d021ee51da1590e18b" translate="yes" xml:space="preserve">
          <source>Package parser</source>
          <target state="translated">解析器包</target>
        </trans-unit>
        <trans-unit id="6de3fe85bffa2dfbd3030929ab437e9f7594c3fc" translate="yes" xml:space="preserve">
          <source>Package parser implements a parser for Go source files. Input may be provided in a variety of forms (see the various Parse* functions); the output is an abstract syntax tree (AST) representing the Go source. The parser is invoked through one of the Parse* functions.</source>
          <target state="translated">Package parser 实现了一个 Go 源文件的解析器,它可以以各种形式提供输入 (参见各种 Parse*函数);输出是代表 Go 源文件的抽象语法树 (AST)。输入可以以各种形式提供(参见各种 Parse*函数);输出是代表 Go 源文件的抽象语法树(AST)。该解析器是通过Parse*函数之一来调用的。</target>
        </trans-unit>
        <trans-unit id="3373a46035bdd1245ec67bf0a2c65e10dfd0f4ad" translate="yes" xml:space="preserve">
          <source>Package path</source>
          <target state="translated">包装路径</target>
        </trans-unit>
        <trans-unit id="db836e38d040774081537fe657365110292aec91" translate="yes" xml:space="preserve">
          <source>Package path implements utility routines for manipulating slash-separated paths.</source>
          <target state="translated">包路径实现了用于操作斜线分离路径的实用程序。</target>
        </trans-unit>
        <trans-unit id="9d24a47a68584686a4df522a7f5e3f005ddc259f" translate="yes" xml:space="preserve">
          <source>Package pe</source>
          <target state="translated">包裹同行</target>
        </trans-unit>
        <trans-unit id="ce301de224be1f8c3d1c1c5dfcb12d983b03bd77" translate="yes" xml:space="preserve">
          <source>Package pe implements access to PE (Microsoft Windows Portable Executable) files.</source>
          <target state="translated">包pe实现了对PE(Microsoft Windows Portable Executable)文件的访问。</target>
        </trans-unit>
        <trans-unit id="e152e56cf87bc67e469bb5da6106c6e936b14368" translate="yes" xml:space="preserve">
          <source>Package pem</source>
          <target state="translated">包装pem</target>
        </trans-unit>
        <trans-unit id="f41f7d23d767dfe9afe9b6e7dfc54ee5c677365e" translate="yes" xml:space="preserve">
          <source>Package pem implements the PEM data encoding, which originated in Privacy Enhanced Mail.</source>
          <target state="translated">包pem实现了PEM数据编码,它起源于隐私增强邮件。</target>
        </trans-unit>
        <trans-unit id="0d4c900b99f74302177b2bea20055842f0e52c09" translate="yes" xml:space="preserve">
          <source>Package pem implements the PEM data encoding, which originated in Privacy Enhanced Mail. The most common use of PEM encoding today is in TLS keys and certificates. See RFC 1421.</source>
          <target state="translated">包pem实现了PEM数据编码,它起源于隐私增强邮件。目前最常见的PEM编码是在TLS密钥和证书中使用。参见RFC 1421。</target>
        </trans-unit>
        <trans-unit id="38d910b9de0ef4ae8b19f042eb74647af6042913" translate="yes" xml:space="preserve">
          <source>Package pkix</source>
          <target state="translated">包装 pkix</target>
        </trans-unit>
        <trans-unit id="dc33e58126376b6213633925214424947582c3a3" translate="yes" xml:space="preserve">
          <source>Package pkix contains shared, low level structures used for ASN.1 parsing and serialization of X.509 certificates, CRL and OCSP.</source>
          <target state="translated">包pkix包含了用于ASN.1解析和序列化X.509证书、CRL和OCSP的共享、低级结构。</target>
        </trans-unit>
        <trans-unit id="67b226d60325490b566c70691138cd1c6d21b193" translate="yes" xml:space="preserve">
          <source>Package plan9obj</source>
          <target state="translated">包plan9obj</target>
        </trans-unit>
        <trans-unit id="4665855b57b9b8af3bee702ebd462244986f00bf" translate="yes" xml:space="preserve">
          <source>Package plan9obj implements access to Plan 9 a.out object files.</source>
          <target state="translated">包plan9obj实现了对Plan 9 a.out对象文件的访问。</target>
        </trans-unit>
        <trans-unit id="3cd1d7122e8b0e42817d81ce5dc7226d253ae194" translate="yes" xml:space="preserve">
          <source>Package plugin</source>
          <target state="translated">插件包</target>
        </trans-unit>
        <trans-unit id="723391b754af075d19bf19a6d72b4aca8b612706" translate="yes" xml:space="preserve">
          <source>Package plugin implements loading and symbol resolution of Go plugins.</source>
          <target state="translated">包插件实现了Go插件的加载和符号解析。</target>
        </trans-unit>
        <trans-unit id="18f40a30c66d89382a5e8d5c5fa97aad2d850e59" translate="yes" xml:space="preserve">
          <source>Package png</source>
          <target state="translated">包装 png</target>
        </trans-unit>
        <trans-unit id="7d75e3a56a64d92564c27a07179bd65f150fd42a" translate="yes" xml:space="preserve">
          <source>Package png implements a PNG image decoder and encoder.</source>
          <target state="translated">包png实现了一个PNG图像解码器和编码器。</target>
        </trans-unit>
        <trans-unit id="bbb9e684e1674ad5ea70ff8d94149cfba70c0322" translate="yes" xml:space="preserve">
          <source>Package pprof</source>
          <target state="translated">包pprof</target>
        </trans-unit>
        <trans-unit id="6b696f2047997085f203f8e5ea4ab96764716e57" translate="yes" xml:space="preserve">
          <source>Package pprof serves via its HTTP server runtime profiling data in the format expected by the pprof visualization tool.</source>
          <target state="translated">包pprof通过其HTTP服务器运行时以pprof可视化工具所期望的格式提供剖析数据。</target>
        </trans-unit>
        <trans-unit id="f35eefcb5de07eee157ab4d725a5a9c718348ce1" translate="yes" xml:space="preserve">
          <source>Package pprof writes runtime profiling data in the format expected by the pprof visualization tool.</source>
          <target state="translated">包pprof以pprof可视化工具所期望的格式写入运行时剖析数据。</target>
        </trans-unit>
        <trans-unit id="bd0a361bc1df19412b2288989fa693bf033d1e94" translate="yes" xml:space="preserve">
          <source>Package printer</source>
          <target state="translated">包装打印机</target>
        </trans-unit>
        <trans-unit id="7508f680f0bd7ace72d4e37d8bf4124dd8618769" translate="yes" xml:space="preserve">
          <source>Package printer implements printing of AST nodes.</source>
          <target state="translated">包装打印机实现了AST节点的打印。</target>
        </trans-unit>
        <trans-unit id="5a2f6f777ac49a0a6e1a6283c8172aaf45ada261" translate="yes" xml:space="preserve">
          <source>Package quick</source>
          <target state="translated">包装快速</target>
        </trans-unit>
        <trans-unit id="b11b2a9f0787ff668038fd60730c27709091efd5" translate="yes" xml:space="preserve">
          <source>Package quick implements utility functions to help with black box testing.</source>
          <target state="translated">包快速实现实用功能,帮助进行黑盒测试。</target>
        </trans-unit>
        <trans-unit id="5a939d420f6017187bd02b98ed377adb9120365c" translate="yes" xml:space="preserve">
          <source>Package quotedprintable</source>
          <target state="translated">套餐报价可打印</target>
        </trans-unit>
        <trans-unit id="195c159d436820f6a7d39ac4579d1905b0c74821" translate="yes" xml:space="preserve">
          <source>Package quotedprintable implements quoted-printable encoding as specified by RFC 2045.</source>
          <target state="translated">包quotedprintable实现了RFC 2045指定的引号可打印编码。</target>
        </trans-unit>
        <trans-unit id="d7dd09c477f4383baa2235b2b5f02beab77e4389" translate="yes" xml:space="preserve">
          <source>Package race</source>
          <target state="translated">包场赛</target>
        </trans-unit>
        <trans-unit id="a5c1c2be3bea40e10437334b0813837bf205008a" translate="yes" xml:space="preserve">
          <source>Package race implements data race detection logic.</source>
          <target state="translated">包竞赛实现了数据竞赛检测逻辑。</target>
        </trans-unit>
        <trans-unit id="96ff3f6524e366a1f85999a9889633b5758b7e5b" translate="yes" xml:space="preserve">
          <source>Package race implements data race detection logic. No public interface is provided. For details about the race detector see &lt;a href=&quot;https://golang.org/doc/articles/race_detector.html&quot;&gt;https://golang.org/doc/articles/race_detector.html&lt;/a&gt;</source>
          <target state="translated">包竞争实现了数据竞争检测逻辑。没有提供公共接口。有关种族探测器的详细信息，请参见&lt;a href=&quot;https://golang.org/doc/articles/race_detector.html&quot;&gt;https://golang.org/doc/articles/race_detector.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="83c163892e45f479d6597f9c22d2df740381ff44" translate="yes" xml:space="preserve">
          <source>Package rand</source>
          <target state="translated">包裹rand</target>
        </trans-unit>
        <trans-unit id="cc752fea52bb25978322b7eaf4569384e9741709" translate="yes" xml:space="preserve">
          <source>Package rand implements a cryptographically secure random number generator.</source>
          <target state="translated">包rand实现了一个加密安全的随机数发生器。</target>
        </trans-unit>
        <trans-unit id="b3b18e540dfae96ee4bfa44eff2fe6364db2a649" translate="yes" xml:space="preserve">
          <source>Package rand implements pseudo-random number generators.</source>
          <target state="translated">包rand实现了伪随机数生成器。</target>
        </trans-unit>
        <trans-unit id="d31a1689b285cdf109ef7adc6ecc82f9e08e66cb" translate="yes" xml:space="preserve">
          <source>Package rc4</source>
          <target state="translated">包材rc4</target>
        </trans-unit>
        <trans-unit id="9d9070b30c94fbd8ece92c972cff45482e84ea73" translate="yes" xml:space="preserve">
          <source>Package rc4 implements RC4 encryption, as defined in Bruce Schneier's Applied Cryptography.</source>
          <target state="translated">包rc4实现了Bruce Schneier的Applied Cryptography中定义的RC4加密。</target>
        </trans-unit>
        <trans-unit id="16eeac7c41dd94aba1ce95ebc38efce516d7ede5" translate="yes" xml:space="preserve">
          <source>Package reflect</source>
          <target state="translated">包装反映</target>
        </trans-unit>
        <trans-unit id="ea99463dc27a541bcea8f216ce8b537d53c786f4" translate="yes" xml:space="preserve">
          <source>Package reflect implements run-time reflection, allowing a program to manipulate objects with arbitrary types. The typical use is to take a value with static type interface{} and extract its dynamic type information by calling TypeOf, which returns a Type.</source>
          <target state="translated">包reflect实现了运行时反射,允许程序操作任意类型的对象。典型的用法是取一个具有静态类型interface{}的值,并通过调用TypeOf提取其动态类型信息,TypeOf返回一个Type。</target>
        </trans-unit>
        <trans-unit id="f6906a6b73a6d72eeebe325c95a7fd2b66657106" translate="yes" xml:space="preserve">
          <source>Package reflect's Value methods named Pointer and UnsafeAddr return type uintptr instead of unsafe.Pointer to keep callers from changing the result to an arbitrary type without first importing &quot;unsafe&quot;. However, this means that the result is fragile and must be converted to Pointer immediately after making the call, in the same expression:</source>
          <target state="translated">包reflect的名为Pointer和UnsafeAddr的Value方法返回类型为uintptr而不是unsafe.Pointer,以防止调用者在没有先导入 &quot;unsafe &quot;的情况下将结果改为任意类型。然而,这意味着结果是脆弱的,必须在进行调用后立即转换为Pointer,在同一个表达式中。</target>
        </trans-unit>
        <trans-unit id="296c31de17cebe68d7ff50dd54df6ff57cb7cdbd" translate="yes" xml:space="preserve">
          <source>Package regexp</source>
          <target state="translated">包regexp</target>
        </trans-unit>
        <trans-unit id="8db88ff2fae80db5efc49abe986d69219c995b2a" translate="yes" xml:space="preserve">
          <source>Package regexp implements regular expression search.</source>
          <target state="translated">包regexp实现了正则表达式搜索。</target>
        </trans-unit>
        <trans-unit id="8f3fe52956764f5ab5a7617348d70f67990e27be" translate="yes" xml:space="preserve">
          <source>Package ring</source>
          <target state="translated">包装环</target>
        </trans-unit>
        <trans-unit id="24781dde0d3396b2f7a5d8de96bf17e6c6511838" translate="yes" xml:space="preserve">
          <source>Package ring implements operations on circular lists.</source>
          <target state="translated">包环实现了对循环列表的操作。</target>
        </trans-unit>
        <trans-unit id="4ac8d28b6f5f90e5f57c49bd02cae6ff1cc3103e" translate="yes" xml:space="preserve">
          <source>Package rpc</source>
          <target state="translated">包材 rpc</target>
        </trans-unit>
        <trans-unit id="29c7a976ba21e5e3d539285fcef131a0900d481a" translate="yes" xml:space="preserve">
          <source>Package rpc provides access to the exported methods of an object across a network or other I/O connection.</source>
          <target state="translated">包rpc提供了通过网络或其他I/O连接访问对象的导出方法。</target>
        </trans-unit>
        <trans-unit id="89036cae903feb95d9bf22ecb370849d3856aa14" translate="yes" xml:space="preserve">
          <source>Package rpc provides access to the exported methods of an object across a network or other I/O connection. A server registers an object, making it visible as a service with the name of the type of the object. After registration, exported methods of the object will be accessible remotely. A server may register multiple objects (services) of different types but it is an error to register multiple objects of the same type.</source>
          <target state="translated">包rpc提供了通过网络或其他I/O连接访问对象的导出方法。服务器注册一个对象,使其以对象类型的名称作为服务可见。注册后,将可以远程访问对象的导出方法。一个服务器可以注册多个不同类型的对象(服务),但注册多个相同类型的对象是错误的。</target>
        </trans-unit>
        <trans-unit id="3dd9b23cfd1948413bbf148dd0474b59ad766e9f" translate="yes" xml:space="preserve">
          <source>Package rsa</source>
          <target state="translated">包裹 rsa</target>
        </trans-unit>
        <trans-unit id="e8ee0119074c7588f25b970331b4e7b4a2623cbf" translate="yes" xml:space="preserve">
          <source>Package rsa implements RSA encryption as specified in PKCS #1 and RFC 8017.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ba02848b97a1b268666b78b127c28a6770b462d" translate="yes" xml:space="preserve">
          <source>Package rsa implements RSA encryption as specified in PKCS#1.</source>
          <target state="translated">包rsa实现了PKCS#1中指定的RSA加密。</target>
        </trans-unit>
        <trans-unit id="4ebd8f5b99b65c7601e3f5f2bad88bd7ec2de054" translate="yes" xml:space="preserve">
          <source>Package runtime</source>
          <target state="translated">包装运行时间</target>
        </trans-unit>
        <trans-unit id="469b95dee031c267f910a82eae21961d70838630" translate="yes" xml:space="preserve">
          <source>Package runtime contains operations that interact with Go's runtime system, such as functions to control goroutines. It also includes the low-level type information used by the reflect package; see reflect's documentation for the programmable interface to the run-time type system.</source>
          <target state="translated">包运行时包含与Go的运行时系统交互的操作,例如控制goroutine的函数。它还包括反射包使用的低级类型信息;关于运行时类型系统的可编程接口,请参阅反射的文档。</target>
        </trans-unit>
        <trans-unit id="82776b2ed593a3609079c4ab84f51091ff8daaf8" translate="yes" xml:space="preserve">
          <source>Package scanner</source>
          <target state="translated">包装扫描器</target>
        </trans-unit>
        <trans-unit id="37829fd57a47182e751d5d54158a385e61ab833d" translate="yes" xml:space="preserve">
          <source>Package scanner implements a scanner for Go source text. It takes a []byte as source which can then be tokenized through repeated calls to the Scan method.</source>
          <target state="translated">包 scanner 实现了一个围棋源文本的扫描器,它将一个[]字节作为源文本,然后通过重复调用 Scan 方法进行标记化。它以[]字节作为源文本,然后通过重复调用Scan方法将其标记化。</target>
        </trans-unit>
        <trans-unit id="cff89fb02b03b32b0811fa214e2e7a1126ee135b" translate="yes" xml:space="preserve">
          <source>Package scanner provides a scanner and tokenizer for UTF-8-encoded text. It takes an io.Reader providing the source, which then can be tokenized through repeated calls to the Scan function. For compatibility with existing tools, the NUL character is not allowed. If the first character in the source is a UTF-8 encoded byte order mark (BOM), it is discarded.</source>
          <target state="translated">包 scanner 提供了一个 UTF-8 编码文本的扫描器和标记器,它需要一个 io.Reader 提供源码,然后通过重复调用 Scan 函数对源码进行标记。它需要一个io.Reader提供源码,然后通过重复调用Scan函数对其进行标记。为了与现有工具兼容,不允许使用NUL字符。如果源文件中的第一个字符是UTF-8编码的字节序标记(BOM),它将被丢弃。</target>
        </trans-unit>
        <trans-unit id="6e0759392e3584cd8a2a3d2a6c4931673b5e35b2" translate="yes" xml:space="preserve">
          <source>Package sha1</source>
          <target state="translated">包Sha1</target>
        </trans-unit>
        <trans-unit id="db1a6662e07e0565a4b3c55f6347a0baeacc49fb" translate="yes" xml:space="preserve">
          <source>Package sha1 implements the SHA-1 hash algorithm as defined in RFC 3174.</source>
          <target state="translated">包 sha1 实现了 RFC 3174 中定义的 SHA-1 哈希算法。</target>
        </trans-unit>
        <trans-unit id="f6ad23ee3ab99920af8ac5cfc82080a0e1b3b09f" translate="yes" xml:space="preserve">
          <source>Package sha256</source>
          <target state="translated">包裹sha256</target>
        </trans-unit>
        <trans-unit id="c9317efee8c5fefb81226a055344cf996daf2874" translate="yes" xml:space="preserve">
          <source>Package sha256 implements the SHA224 and SHA256 hash algorithms as defined in FIPS 180-4.</source>
          <target state="translated">包 sha256 实现了 FIPS 180-4 中定义的 SHA224 和 SHA256 哈希算法。</target>
        </trans-unit>
        <trans-unit id="4e4623212d4095d72a62997c9796888b7d1b95c9" translate="yes" xml:space="preserve">
          <source>Package sha512</source>
          <target state="translated">包裹sha512</target>
        </trans-unit>
        <trans-unit id="65d83f8c0979c324f75579653a6e20dcc05fc8a1" translate="yes" xml:space="preserve">
          <source>Package sha512 implements the SHA-384, SHA-512, SHA-512/224, and SHA-512/256 hash algorithms as defined in FIPS 180-4.</source>
          <target state="translated">包 sha512 实现了 FIPS 180-4 中定义的 SHA-384、SHA-512、SHA-512/224 和 SHA-512/256 哈希算法。</target>
        </trans-unit>
        <trans-unit id="80e54559e475073190cfed119c9847e346d01634" translate="yes" xml:space="preserve">
          <source>Package signal</source>
          <target state="translated">包装信号</target>
        </trans-unit>
        <trans-unit id="59f2e9e157e5e2c56d4bb35edf223ce0a7c75cdf" translate="yes" xml:space="preserve">
          <source>Package signal implements access to incoming signals.</source>
          <target state="translated">包信号实现对传入信号的访问。</target>
        </trans-unit>
        <trans-unit id="0e49eafb9bb1f34b1ff3d2c9a1f4a0ec52ecdba3" translate="yes" xml:space="preserve">
          <source>Package signal will not block sending to c: the caller must ensure that c has sufficient buffer space to keep up with the expected signal rate. For a channel used for notification of just one signal value, a buffer of size 1 is sufficient.</source>
          <target state="translated">包信号不会阻止向c发送:调用者必须确保c有足够的缓冲空间来跟上预期的信号速率。对于一个只用于通知一个信号值的通道,大小为1的缓冲区就足够了。</target>
        </trans-unit>
        <trans-unit id="fc75b3c455c2cde737da3fcce8266dd282fe7922" translate="yes" xml:space="preserve">
          <source>Package smtp</source>
          <target state="translated">软件包smtp</target>
        </trans-unit>
        <trans-unit id="b50b30b8ea306091fbb446aaa4ed61109401fff0" translate="yes" xml:space="preserve">
          <source>Package smtp implements the Simple Mail Transfer Protocol as defined in RFC 5321.</source>
          <target state="translated">包smtp实现了RFC 5321中定义的简单邮件传输协议。</target>
        </trans-unit>
        <trans-unit id="1fe6e79dac787b0d56b7abea30c16ebab918d57e" translate="yes" xml:space="preserve">
          <source>Package smtp implements the Simple Mail Transfer Protocol as defined in RFC 5321. It also implements the following extensions:</source>
          <target state="translated">包smtp实现了RFC 5321中定义的简单邮件传输协议。它还实现了以下扩展。</target>
        </trans-unit>
        <trans-unit id="71f7fab9acf61b6109216266ded759b751fdf3ba" translate="yes" xml:space="preserve">
          <source>Package sort</source>
          <target state="translated">包装分类</target>
        </trans-unit>
        <trans-unit id="0962324992fa79918c2dd6cf47c8b372c511e5ff" translate="yes" xml:space="preserve">
          <source>Package sort provides primitives for sorting slices and user-defined collections.</source>
          <target state="translated">包排序提供了对切片和用户定义的集合进行排序的基元。</target>
        </trans-unit>
        <trans-unit id="9bd1b867b8811e4a5059325426012d1ac3fbe070" translate="yes" xml:space="preserve">
          <source>Package sql</source>
          <target state="translated">包 sql</target>
        </trans-unit>
        <trans-unit id="9e262166973b441cf1a6b45fe03044818008c94a" translate="yes" xml:space="preserve">
          <source>Package sql provides a generic interface around SQL (or SQL-like) databases.</source>
          <target state="translated">包sql提供了一个围绕SQL(或类SQL)数据库的通用接口。</target>
        </trans-unit>
        <trans-unit id="8b57c7d54ee7ea7e0a45d8c13b8a29358c7a1a59" translate="yes" xml:space="preserve">
          <source>Package strconv</source>
          <target state="translated">strconv包</target>
        </trans-unit>
        <trans-unit id="3c44c13248967ffe512eec5e12e0ac2d83aaabcb" translate="yes" xml:space="preserve">
          <source>Package strconv implements conversions to and from string representations of basic data types.</source>
          <target state="translated">包 strconv 实现了基本数据类型的字符串表示之间的转换。</target>
        </trans-unit>
        <trans-unit id="28ec3487bac9bff1cd40dd5bfdaac3e5f0f7e66b" translate="yes" xml:space="preserve">
          <source>Package strings</source>
          <target state="translated">包装字符串</target>
        </trans-unit>
        <trans-unit id="30f2d5d3c8bcd3201c529ed7194820953f047942" translate="yes" xml:space="preserve">
          <source>Package strings implements simple functions to manipulate UTF-8 encoded strings.</source>
          <target state="translated">包strings实现了简单的函数来操作UTF-8编码的字符串。</target>
        </trans-unit>
        <trans-unit id="5f3a2aafe35539648afeeb350719fa852f88f7f2" translate="yes" xml:space="preserve">
          <source>Package subtle</source>
          <target state="translated">包装精巧</target>
        </trans-unit>
        <trans-unit id="af533feda0fe1c8229caece2fdfd190444424ea5" translate="yes" xml:space="preserve">
          <source>Package subtle implements functions that are often useful in cryptographic code but require careful thought to use correctly.</source>
          <target state="translated">Package subtle实现了在加密代码中经常有用,但需要仔细思考才能正确使用的函数。</target>
        </trans-unit>
        <trans-unit id="39d17df25323190f4cc53202e597d56f35dfee6b" translate="yes" xml:space="preserve">
          <source>Package suffixarray</source>
          <target state="translated">后缀array包</target>
        </trans-unit>
        <trans-unit id="7980bb666cc38cba6c4aaf92417db33415ccfaa1" translate="yes" xml:space="preserve">
          <source>Package suffixarray implements substring search in logarithmic time using an in-memory suffix array.</source>
          <target state="translated">包 suffixarray 使用内存中的后缀数组实现了对数时间的子串搜索。</target>
        </trans-unit>
        <trans-unit id="346a1d63b09ad3c0b05c14691bf67091b87cabe5" translate="yes" xml:space="preserve">
          <source>Package sync</source>
          <target state="translated">包装同步</target>
        </trans-unit>
        <trans-unit id="aea6d23bbc4ed584bf5042d03479be247cbf1087" translate="yes" xml:space="preserve">
          <source>Package sync provides basic synchronization primitives such as mutual exclusion locks. Other than the Once and WaitGroup types, most are intended for use by low-level library routines. Higher-level synchronization is better done via channels and communication.</source>
          <target state="translated">包 sync 提供了基本的同步基元,如互斥锁。除了Once和WaitGroup类型之外,大多数都是供低级库例程使用的。更高层次的同步最好通过通道和通信来完成。</target>
        </trans-unit>
        <trans-unit id="fe4c913bf7c7c5e8773000f095ebe490accad3a2" translate="yes" xml:space="preserve">
          <source>Package syntax</source>
          <target state="translated">包装语法</target>
        </trans-unit>
        <trans-unit id="a713eae229dc7c92d21e8a224e10ceffb09512c2" translate="yes" xml:space="preserve">
          <source>Package syntax parses regular expressions into parse trees and compiles parse trees into programs.</source>
          <target state="translated">包语法将正则表达式解析成解析树,并将解析树编译成程序。</target>
        </trans-unit>
        <trans-unit id="a70c7eb9cc685b98a0a5536eddbf6dbc0cba4ac8" translate="yes" xml:space="preserve">
          <source>Package syntax parses regular expressions into parse trees and compiles parse trees into programs. Most clients of regular expressions will use the facilities of package regexp (such as Compile and Match) instead of this package.</source>
          <target state="translated">包语法将正则表达式解析成解析树,并将解析树编译成程序。大多数正则表达式的客户端会使用包regexp的设施(如编译和匹配)来代替这个包。</target>
        </trans-unit>
        <trans-unit id="11e76797e8363318c05ceb15b2d2b47e39353883" translate="yes" xml:space="preserve">
          <source>Package sys</source>
          <target state="translated">包装系统</target>
        </trans-unit>
        <trans-unit id="d21a124cf49a1b492319130693efdb9b8a34c61d" translate="yes" xml:space="preserve">
          <source>Package syscall</source>
          <target state="translated">包装系统调用</target>
        </trans-unit>
        <trans-unit id="0f53f1418ab827df34bf754bfae7d8d0c010c7cc" translate="yes" xml:space="preserve">
          <source>Package syscall contains an interface to the low-level operating system primitives. The details vary depending on the underlying system, and by default, godoc will display the syscall documentation for the current system. If you want godoc to display syscall documentation for another system, set $GOOS and $GOARCH to the desired system. For example, if you want to view documentation for freebsd/arm on linux/amd64, set $GOOS to freebsd and $GOARCH to arm. The primary use of syscall is inside other packages that provide a more portable interface to the system, such as &quot;os&quot;, &quot;time&quot; and &quot;net&quot;. Use those packages rather than this one if you can. For details of the functions and data types in this package consult the manuals for the appropriate operating system. These calls return err == nil to indicate success; otherwise err is an operating system error describing the failure. On most systems, that error has type syscall.Errno.</source>
          <target state="translated">包syscall包含一个低级操作系统基元的接口。其细节取决于底层系统,默认情况下,godoc将显示当前系统的syscall文档,如果想让godoc显示另一个系统的syscall文档,可以将$GOOS和$GOARCH设置为所需系统。如果您想让 godoc 显示另一个系统的 syscall 文档,请将 $GOOS 和 $GOARCH 设置为所需系统。例如,如果您想在linux/amd64上查看freebsd/arm的文档,就把$GOOS设置为freebsd,把$GOARCH设置为arm。syscall的主要用途是在其他提供更便携的系统接口的包里面,比如 &quot;os&quot;、&quot;time &quot;和 &quot;net&quot;。如果可以的话,请使用这些包而不是这个包。关于这个包中的函数和数据类型的细节,请查阅相应操作系统的手册。这些调用返回err ==nil表示成功,否则err是一个描述失败的操作系统错误。在大多数系统中,该错误的类型为syscall.Errno。</target>
        </trans-unit>
        <trans-unit id="f90ba2ae4e2d681143f3d41fb43a2f79b7c3197e" translate="yes" xml:space="preserve">
          <source>Package syslog</source>
          <target state="translated">系统日志包</target>
        </trans-unit>
        <trans-unit id="396038b0a959cfae15beae20a0f48bc80b80cf43" translate="yes" xml:space="preserve">
          <source>Package syslog provides a simple interface to the system log service.</source>
          <target state="translated">包syslog提供了一个简单的系统日志服务接口。</target>
        </trans-unit>
        <trans-unit id="d1f55ec1734bdf22b075380ad35ee09a577ec002" translate="yes" xml:space="preserve">
          <source>Package syslog provides a simple interface to the system log service. It can send messages to the syslog daemon using UNIX domain sockets, UDP or TCP.</source>
          <target state="translated">包syslog提供了一个简单的系统日志服务的接口,它可以使用UNIX域套接字、UDP或TCP向syslog守护进程发送消息。它可以使用UNIX域套接字、UDP或TCP向syslog守护进程发送消息。</target>
        </trans-unit>
        <trans-unit id="007cb2c9dc06f8f699c331e9716d599817f048b5" translate="yes" xml:space="preserve">
          <source>Package tabwriter</source>
          <target state="translated">包tabwriter</target>
        </trans-unit>
        <trans-unit id="f7841eb33056b73d4a3597207ce6dc7e384c846d" translate="yes" xml:space="preserve">
          <source>Package tabwriter implements a write filter (tabwriter.Writer) that translates tabbed columns in input into properly aligned text.</source>
          <target state="translated">包tabwriter实现了一个写过滤器(tabwriter.Writer),它可以将输入中的标签栏翻译成正确对齐的文本。</target>
        </trans-unit>
        <trans-unit id="bec4ed72f4fd10dfa620d0e5687ebc626dc193a1" translate="yes" xml:space="preserve">
          <source>Package tar</source>
          <target state="translated">焦油包</target>
        </trans-unit>
        <trans-unit id="b3d0f0f238631cf9655cf5816e9f94b6db370098" translate="yes" xml:space="preserve">
          <source>Package tar implements access to tar archives.</source>
          <target state="translated">包 tar 实现了对 tar 存档的访问。</target>
        </trans-unit>
        <trans-unit id="7ac2ec5b1841ff39f85ad1d4687cc3abfa906a39" translate="yes" xml:space="preserve">
          <source>Package template</source>
          <target state="translated">包装模板</target>
        </trans-unit>
        <trans-unit id="aba87a8492b37ccf916bdea97ed3b469ce8125f0" translate="yes" xml:space="preserve">
          <source>Package template (html/template) implements data-driven templates for generating HTML output safe against code injection.</source>
          <target state="translated">包模板(html/template)实现了数据驱动的模板,用于生成防止代码注入的HTML输出。</target>
        </trans-unit>
        <trans-unit id="9776451c8a221b1dfd29d6efbaff6d2de3fbf0aa" translate="yes" xml:space="preserve">
          <source>Package template (html/template) implements data-driven templates for generating HTML output safe against code injection. It provides the same interface as package text/template and should be used instead of text/template whenever the output is HTML.</source>
          <target state="translated">包模板 (html/template)实现了数据驱动的模板,用于生成防止代码注入的 HTML 输出。它提供了与包text/template相同的接口,只要输出的是HTML,就应该使用它来代替text/template。</target>
        </trans-unit>
        <trans-unit id="12fb252e998414c68ff5f9998dbcdff046a0fe8f" translate="yes" xml:space="preserve">
          <source>Package template implements data-driven templates for generating textual output.</source>
          <target state="translated">包模板实现了数据驱动的模板,用于生成文本输出。</target>
        </trans-unit>
        <trans-unit id="8f2f8d22daa6bdd34d84049e31c95592348695b8" translate="yes" xml:space="preserve">
          <source>Package testing</source>
          <target state="translated">包装测试</target>
        </trans-unit>
        <trans-unit id="4387ddd6a0700cb89e62a2fdffa74807135c1d64" translate="yes" xml:space="preserve">
          <source>Package testing provides support for automated testing of Go packages. It is intended to be used in concert with the &quot;go test&quot; command, which automates execution of any function of the form</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c91ae9ffc226daabd50a55612fc0b4ce9280216" translate="yes" xml:space="preserve">
          <source>Package testing provides support for automated testing of Go packages. It is intended to be used in concert with the &amp;ldquo;go test&amp;rdquo; command, which automates execution of any function of the form</source>
          <target state="translated">软件包测试为Go软件包的自动化测试提供支持。它旨在与&amp;ldquo; go test&amp;rdquo;命令配合使用，该命令可自动执行表格中的任何功能</target>
        </trans-unit>
        <trans-unit id="10fa2d9109fabc6fd9b96730e5f6c29a2ec7c36f" translate="yes" xml:space="preserve">
          <source>Package textproto</source>
          <target state="translated">包textproto</target>
        </trans-unit>
        <trans-unit id="3dc8f07b5e53239f3d16cf68abc4c177c52d10af" translate="yes" xml:space="preserve">
          <source>Package textproto implements generic support for text-based request/response protocols in the style of HTTP, NNTP, and SMTP.</source>
          <target state="translated">包textproto实现了对基于文本的请求/响应协议的通用支持,风格为HTTP、NNTP和SMTP。</target>
        </trans-unit>
        <trans-unit id="e0896056124ecab0339d61326880bfb542bc907f" translate="yes" xml:space="preserve">
          <source>Package time</source>
          <target state="translated">包装时间</target>
        </trans-unit>
        <trans-unit id="5305dc12a988a4ce552cf3341269cdd34206dbc0" translate="yes" xml:space="preserve">
          <source>Package time provides functionality for measuring and displaying time.</source>
          <target state="translated">包装时间提供测量和显示时间的功能。</target>
        </trans-unit>
        <trans-unit id="2870bb3df8e650dbc1e60be06a2c5ae58d30789e" translate="yes" xml:space="preserve">
          <source>Package tls</source>
          <target state="translated">包裹tls</target>
        </trans-unit>
        <trans-unit id="7f75931d43fdfef0a07153ddf14ad51258da3f69" translate="yes" xml:space="preserve">
          <source>Package tls partially implements TLS 1.2, as specified in RFC 5246, and TLS 1.3, as specified in RFC 8446.</source>
          <target state="translated">包tls部分实现了RFC 5246中规定的TLS 1.2和RFC 8446中规定的TLS 1.3。</target>
        </trans-unit>
        <trans-unit id="71cf571a2e2d9b69987d70384e5e0a349bbf13f6" translate="yes" xml:space="preserve">
          <source>Package token</source>
          <target state="translated">包裹令牌</target>
        </trans-unit>
        <trans-unit id="3de5e73d48412b9fa410e9f04a2075f5ec3be3f1" translate="yes" xml:space="preserve">
          <source>Package token defines constants representing the lexical tokens of the Go programming language and basic operations on tokens (printing, predicates).</source>
          <target state="translated">包令牌定义了代表Go编程语言的词性令牌和对令牌的基本操作(打印、谓词)的常量。</target>
        </trans-unit>
        <trans-unit id="7e450a321c355f3612aca2e34d0a073905f6e6ac" translate="yes" xml:space="preserve">
          <source>Package trace</source>
          <target state="translated">包装跟踪</target>
        </trans-unit>
        <trans-unit id="025720b70dde0a472ee8ed25e4b132eb460e89d0" translate="yes" xml:space="preserve">
          <source>Package trace contains facilities for programs to generate traces for the Go execution tracer.</source>
          <target state="translated">包trace包含了为Go执行跟踪器生成跟踪程序的功能。</target>
        </trans-unit>
        <trans-unit id="3e63d422df1350bbdcfb3a251a3dd0dcdbbc02d1" translate="yes" xml:space="preserve">
          <source>Package trace provides user annotation APIs that can be used to log interesting events during execution.</source>
          <target state="translated">包跟踪提供了用户注释API,可以用来记录执行过程中的有趣事件。</target>
        </trans-unit>
        <trans-unit id="b954397c4a071e1cc2e5aec57815cae94675ccf5" translate="yes" xml:space="preserve">
          <source>Package types</source>
          <target state="translated">包装类型</target>
        </trans-unit>
        <trans-unit id="046779ebad1597aa59c89817459594972c347086" translate="yes" xml:space="preserve">
          <source>Package types declares the data types and implements the algorithms for type-checking of Go packages. Use Config.Check to invoke the type checker for a package. Alternatively, create a new type checker with NewChecker and invoke it incrementally by calling Checker.Files.</source>
          <target state="translated">包类型声明了数据类型,并实现了用于Go包类型检查的算法。使用 Config.Check 来调用包的类型检查器。或者,使用NewChecker创建一个新的类型检查器,并通过调用Checker.Files来递增调用它。</target>
        </trans-unit>
        <trans-unit id="813dcf6547764f2f968934a11d3c4a86a0407f1c" translate="yes" xml:space="preserve">
          <source>Package tzdata</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a8f4d83bd9a090f2188b9855b65bbac117a7f9e" translate="yes" xml:space="preserve">
          <source>Package tzdata provides an embedded copy of the timezone database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a7aa1b6a03b1ea3399574248eee32f7c7d186f6" translate="yes" xml:space="preserve">
          <source>Package tzdata provides an embedded copy of the timezone database. If this package is imported anywhere in the program, then if the time package cannot find tzdata files on the system, it will use this embedded information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab9e4b9642ec1eafa3034c351ee1c61944a1812d" translate="yes" xml:space="preserve">
          <source>Package unicode</source>
          <target state="translated">包的unicode</target>
        </trans-unit>
        <trans-unit id="1d363f9997c96fdcfdb92764e225e66454bc7d90" translate="yes" xml:space="preserve">
          <source>Package unicode provides data and functions to test some properties of Unicode code points.</source>
          <target state="translated">包unicode提供数据和函数来测试Unicode码点的一些属性。</target>
        </trans-unit>
        <trans-unit id="ed360d93d2eb692bc3647fbb297fd557060587f2" translate="yes" xml:space="preserve">
          <source>Package unsafe</source>
          <target state="translated">包装不安全</target>
        </trans-unit>
        <trans-unit id="f3779d5060271e804458c7a976ac1ca5792c1c2a" translate="yes" xml:space="preserve">
          <source>Package unsafe contains operations that step around the type safety of Go programs.</source>
          <target state="translated">包不安全包含了绕过围棋程序类型安全的操作。</target>
        </trans-unit>
        <trans-unit id="7fd4c1e0c59a537b7729289d4b67c4a3c1f81ee5" translate="yes" xml:space="preserve">
          <source>Package url</source>
          <target state="translated">包裹网址</target>
        </trans-unit>
        <trans-unit id="4387dda0da368c99a229d78b0b38d344b8ddba79" translate="yes" xml:space="preserve">
          <source>Package url parses URLs and implements query escaping.</source>
          <target state="translated">包url解析URL并实现查询转义。</target>
        </trans-unit>
        <trans-unit id="fa2e3df3b1c8d0f2ae6af8b9831692e368e35553" translate="yes" xml:space="preserve">
          <source>Package user</source>
          <target state="translated">包装用户</target>
        </trans-unit>
        <trans-unit id="36a98acad58d4786ee6c07f69161ac71cff79f1c" translate="yes" xml:space="preserve">
          <source>Package user allows user account lookups by name or id.</source>
          <target state="translated">包用户允许通过名称或id查找用户账户。</target>
        </trans-unit>
        <trans-unit id="950f17b07369b94da04e57b90cd290ee5b7ab329" translate="yes" xml:space="preserve">
          <source>Package utf16</source>
          <target state="translated">包utf16</target>
        </trans-unit>
        <trans-unit id="a91481384b6ca45acef08e50a0a602f6b354aa0d" translate="yes" xml:space="preserve">
          <source>Package utf16 implements encoding and decoding of UTF-16 sequences.</source>
          <target state="translated">包utf16实现了UTF-16序列的编码和解码。</target>
        </trans-unit>
        <trans-unit id="82c84de36eee3827503136824453e15f86291f2b" translate="yes" xml:space="preserve">
          <source>Package utf8</source>
          <target state="translated">包utf8</target>
        </trans-unit>
        <trans-unit id="2d558781d2038e750681faba06d532094ebcdee0" translate="yes" xml:space="preserve">
          <source>Package utf8 implements functions and constants to support text encoded in UTF-8.</source>
          <target state="translated">包 utf8 实现了支持 UTF-8 编码文本的函数和常量。</target>
        </trans-unit>
        <trans-unit id="c4336946f769b3e34f747cb0c522858f6f2bca8f" translate="yes" xml:space="preserve">
          <source>Package utf8 implements functions and constants to support text encoded in UTF-8. It includes functions to translate between runes and UTF-8 byte sequences.</source>
          <target state="translated">包 utf8 实现了支持 UTF-8 编码文本的函数和常量。它包括在符文和UTF-8字节序列之间进行翻译的函数。</target>
        </trans-unit>
        <trans-unit id="09fcd10fda7e23015ec9957b448561783febe505" translate="yes" xml:space="preserve">
          <source>Package utf8 implements functions and constants to support text encoded in UTF-8. It includes functions to translate between runes and UTF-8 byte sequences. See &lt;a href=&quot;https://en.wikipedia.org/wiki/UTF-8&quot;&gt;https://en.wikipedia.org/wiki/UTF-8&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e005285bbb9f85e9b954bed4a6e12999ae03a672" translate="yes" xml:space="preserve">
          <source>Package x509</source>
          <target state="translated">包材x509</target>
        </trans-unit>
        <trans-unit id="90de220d2bc052deab02c2c4de98a3e71c3ef316" translate="yes" xml:space="preserve">
          <source>Package x509 parses X.509-encoded keys and certificates.</source>
          <target state="translated">包 x509 解析 X.509 编码的密钥和证书。</target>
        </trans-unit>
        <trans-unit id="10ff4b7cfdffba3a4767c605c3ebace89b42f92c" translate="yes" xml:space="preserve">
          <source>Package xml</source>
          <target state="translated">包xml</target>
        </trans-unit>
        <trans-unit id="93a9b657d94cd318e7ad743005d8b996f9595c6e" translate="yes" xml:space="preserve">
          <source>Package xml implements a simple XML 1.0 parser that understands XML name spaces.</source>
          <target state="translated">包xml实现了一个简单的XML 1.0解析器,它能理解XML名称空间。</target>
        </trans-unit>
        <trans-unit id="c19f04e6d6be831ab25449a487f0756316b351f6" translate="yes" xml:space="preserve">
          <source>Package zip</source>
          <target state="translated">包装拉链</target>
        </trans-unit>
        <trans-unit id="dfaad266283daad5d81fc0dfbfdf6760dc866668" translate="yes" xml:space="preserve">
          <source>Package zip provides support for reading and writing ZIP archives.</source>
          <target state="translated">包zip提供了对ZIP档案的读写支持。</target>
        </trans-unit>
        <trans-unit id="588377b14974d4da962ee44fcd3a951c7da0ddbc" translate="yes" xml:space="preserve">
          <source>Package zlib</source>
          <target state="translated">包zlib</target>
        </trans-unit>
        <trans-unit id="b8d40d3cbcb305861fd98b2ba9ad33cfda1fe2f6" translate="yes" xml:space="preserve">
          <source>Package zlib implements reading and writing of zlib format compressed data, as specified in RFC 1950.</source>
          <target state="translated">包zlib实现了RFC 1950中规定的zlib格式压缩数据的读写。</target>
        </trans-unit>
        <trans-unit id="e6ebfcdbe4d41913bba3eb021c5e2f7faa2a5af8" translate="yes" xml:space="preserve">
          <source>PackageExports reports whether there are exported declarations; it returns false otherwise.</source>
          <target state="translated">PackageExports 报告是否有导出的声明,否则返回 false。</target>
        </trans-unit>
        <trans-unit id="d9ae56929a397151dd71c50540c8ba9f7a374f8b" translate="yes" xml:space="preserve">
          <source>PackageExports trims the AST for a Go package in place such that only exported nodes remain. The pkg.Files list is not changed, so that file names and top-level package comments don't get lost.</source>
          <target state="translated">PackageExports 对 Go 包的 AST 进行了就地修剪,从而只保留导出的节点。pkg.Files 列表不会被改变,因此文件名和顶层包注释不会丢失。</target>
        </trans-unit>
        <trans-unit id="74867f01a0f6f645509d530ed289df047c6ca5df" translate="yes" xml:space="preserve">
          <source>PackageName returns the package part of the symbol name, or the empty string if there is none.</source>
          <target state="translated">PackageName 返回符号名称的包部分,如果没有,则返回空字符串。</target>
        </trans-unit>
        <trans-unit id="17c03b27b19d3b24962032b7096b91392545e063" translate="yes" xml:space="preserve">
          <source>Packages that import unsafe may be non-portable and are not protected by the Go 1 compatibility guidelines.</source>
          <target state="translated">导入不安全的软件包可能是不可移植的,不受Go 1兼容性准则的保护。</target>
        </trans-unit>
        <trans-unit id="85b5ee2819eb33cd78762cf51c0b4a5dd5523cb8" translate="yes" xml:space="preserve">
          <source>PacketConn is a generic packet-oriented network connection.</source>
          <target state="translated">PacketConn是一个面向数据包的通用网络连接。</target>
        </trans-unit>
        <trans-unit id="a0ac68089bb018405a8a46934512cae685b010b0" translate="yes" xml:space="preserve">
          <source>Palette is a palette of colors.</source>
          <target state="translated">调色板是一种颜色的调色板。</target>
        </trans-unit>
        <trans-unit id="8345eec10c921c39ee65aec65372e629adf963d0" translate="yes" xml:space="preserve">
          <source>Paletted is an in-memory image of uint8 indices into a given palette.</source>
          <target state="translated">Paletted是uint8指数到给定调色板的内存图像。</target>
        </trans-unit>
        <trans-unit id="811857fbbfb6bbe0a3457e5ca72c3cf06e353567" translate="yes" xml:space="preserve">
          <source>PalettedImage is an image whose colors may come from a limited palette. If m is a PalettedImage and m.ColorModel() returns a color.Palette p, then m.At(x, y) should be equivalent to p[m.ColorIndexAt(x, y)]. If m's color model is not a color.Palette, then ColorIndexAt's behavior is undefined.</source>
          <target state="translated">PalettedImage是一个图像,它的颜色可能来自一个有限的调色板。如果m是PalettedImage,并且m.ColorModel()返回一个color.Palette p,那么m.At(x,y)应该等同于p[m.ColorIndexAt(x,y)].如果m的颜色模型不是color.Palette,那么ColorIndexAt的行为是未定义的。如果m的颜色模型不是color.Palette,那么ColorIndexAt的行为是未定义的。</target>
        </trans-unit>
        <trans-unit id="a512c7d0f9809b6517eee35249de666659ba9bfb" translate="yes" xml:space="preserve">
          <source>Panic is equivalent to Print() followed by a call to panic().</source>
          <target state="translated">Panic相当于Print()之后调用panic()。</target>
        </trans-unit>
        <trans-unit id="70327e98d175663a82976707da91eda94bf1b6a7" translate="yes" xml:space="preserve">
          <source>Panic is equivalent to l.Print() followed by a call to panic().</source>
          <target state="translated">Panic相当于l.Print()后调用panic()。</target>
        </trans-unit>
        <trans-unit id="acc202ec50a5ea3772bacf3218be7877d69941fa" translate="yes" xml:space="preserve">
          <source>Panicf is equivalent to Printf() followed by a call to panic().</source>
          <target state="translated">Panicf相当于Printf()之后调用panic()。</target>
        </trans-unit>
        <trans-unit id="609a5ff18403fc4ba9beec643b7a217eafb712bf" translate="yes" xml:space="preserve">
          <source>Panicf is equivalent to l.Printf() followed by a call to panic().</source>
          <target state="translated">Panicf相当于l.Printf()后调用panic()。</target>
        </trans-unit>
        <trans-unit id="de496f946eb01de54aacea36389a2930b2b5fea9" translate="yes" xml:space="preserve">
          <source>Panicln is equivalent to Println() followed by a call to panic().</source>
          <target state="translated">Panicln相当于Println()后调用panic()。</target>
        </trans-unit>
        <trans-unit id="42b6fefdbb3fe1d6cc946346feb02780fc4954d4" translate="yes" xml:space="preserve">
          <source>Panicln is equivalent to l.Println() followed by a call to panic().</source>
          <target state="translated">Panicln相当于l.Println()后调用panic()。</target>
        </trans-unit>
        <trans-unit id="3f233f952852726c76f955efdb8cfad2984864f8" translate="yes" xml:space="preserve">
          <source>Panics if x is not one of the expected types.</source>
          <target state="translated">如果x不是预期的类型之一,则惊慌失措。</target>
        </trans-unit>
        <trans-unit id="2656e6fe95970497f2da4ae50b709bea0cd1bc5b" translate="yes" xml:space="preserve">
          <source>Parallel signals that this test is to be run in parallel with (and only with) other parallel tests. When a test is run multiple times due to use of -test.count or -test.cpu, multiple instances of a single test never run in parallel with each other.</source>
          <target state="translated">并行信号,表示这个测试要与其他并行测试并行运行(而且只能与其他并行测试并行运行)。当一个测试由于使用-test.count或-test.cpu而被多次运行时,一个测试的多个实例永远不会相互平行运行。</target>
        </trans-unit>
        <trans-unit id="2ff45dda694203612652ce58eb32539f9ea39636" translate="yes" xml:space="preserve">
          <source>ParameterSizes is an enumeration of the acceptable bit lengths of the primes in a set of DSA parameters. See FIPS 186-3, section 4.2.</source>
          <target state="translated">ParameterSizes是一组DSA参数中可接受的质数位长的枚举。参见FIPS 186-3,4.2节。</target>
        </trans-unit>
        <trans-unit id="a38d6c7adf0ef721d51b09e9ef7d3dab505e3376" translate="yes" xml:space="preserve">
          <source>Parameters represents the domain parameters for a key. These parameters can be shared across many keys. The bit length of Q must be a multiple of 8.</source>
          <target state="translated">Parameters表示一个键的域参数,这些参数可以在多个键之间共享。这些参数可以在多个密钥之间共享。Q的位长必须是8的倍数。</target>
        </trans-unit>
        <trans-unit id="f2a595a7d8c4b648ee6f267ac2a444e5bcc46523" translate="yes" xml:space="preserve">
          <source>Params returns the parameters of signature s, or nil.</source>
          <target state="translated">Params返回签名s的参数,或者nil。</target>
        </trans-unit>
        <trans-unit id="21b514799f92100d51f5995498a76d50a6591d7f" translate="yes" xml:space="preserve">
          <source>Parent returns the scope in which the object is declared. The result is nil for methods and struct fields.</source>
          <target state="translated">Parent 返回声明对象的作用域。对于方法和结构域,结果为零。</target>
        </trans-unit>
        <trans-unit id="6d2ab1d9170cbc23bb71b0003b207c4504e77bc1" translate="yes" xml:space="preserve">
          <source>Parent returns the scope's containing (parent) scope.</source>
          <target state="translated">Parent 返回 scope 的包含(父)作用域。</target>
        </trans-unit>
        <trans-unit id="b7e45a36ff3610e06a3801fd14fa6c1e6b89312f" translate="yes" xml:space="preserve">
          <source>Parse</source>
          <target state="translated">Parse</target>
        </trans-unit>
        <trans-unit id="eadd3db51adcf33e03ef4c729d1f1d357ded94ad" translate="yes" xml:space="preserve">
          <source>Parse may be called multiple times to assemble the various associated templates; see the ParseFiles and ParseGlob functions and methods for simple ways to parse related templates stored in files.</source>
          <target state="translated">可以多次调用Parse来组装各种相关的模板;请参见ParseFiles和ParseGlob函数和方法,以获得解析存储在文件中的相关模板的简单方法。</target>
        </trans-unit>
        <trans-unit id="8d5c1289f5e01bfdc5e745aca9c64851f068edc1" translate="yes" xml:space="preserve">
          <source>Parse parses a URL in the context of the receiver. The provided URL may be relative or absolute. Parse returns nil, err on parse failure, otherwise its return value is the same as ResolveReference.</source>
          <target state="translated">在接收者的上下文中解析一个URL。所提供的URL可以是相对的,也可以是绝对的,如果解析失败则返回nil或err,否则其返回值与ResolveReference相同。Parse返回nil,解析失败则返回err,否则其返回值与ResolveReference相同。</target>
        </trans-unit>
        <trans-unit id="8516fe9b2b0e681b5f1a19c09c598e09f76c0a92" translate="yes" xml:space="preserve">
          <source>Parse parses a formatted string and returns the time value it represents. The layout defines the format by showing how the reference time, defined to be</source>
          <target state="translated">Parse解析一个格式化的字符串,并返回它所代表的时间值。布局通过显示参考时间(定义为</target>
        </trans-unit>
        <trans-unit id="db84b44056db6c0589142cb550f7685b84290b5a" translate="yes" xml:space="preserve">
          <source>Parse parses a regular expression string s, controlled by the specified Flags, and returns a regular expression parse tree. The syntax is described in the top-level comment.</source>
          <target state="translated">Parse解析一个由指定的Flags控制的正则表达式字符串s,并返回一个正则表达式解析树。语法在顶层注释中描述。</target>
        </trans-unit>
        <trans-unit id="be0cb24027bbf7f03a0c792dd455fd65c8a881c5" translate="yes" xml:space="preserve">
          <source>Parse parses a single RFC 5322 address of the form &quot;Gogh Fir &amp;lt;gf@example.com&amp;gt;&quot; or &quot;foo@example.com&quot;.</source>
          <target state="translated">解析解析单个RFC 5322地址，格式为&amp;ldquo; Gogh Fir &amp;lt;gf@example.com&amp;gt;&amp;rdquo;或&amp;ldquo; foo@example.com&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="752dc6bd0eac2233d3708db7188652b9f75b7d68" translate="yes" xml:space="preserve">
          <source>Parse parses a single build constraint line of the form &amp;ldquo;//go:build ...&amp;rdquo; or &amp;ldquo;// +build ...&amp;rdquo; and returns the corresponding boolean expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6329cd5d9d98d1f00f6752cb84cd2b25ccb27456" translate="yes" xml:space="preserve">
          <source>Parse parses flag definitions from the argument list, which should not include the command name. Must be called after all flags in the FlagSet are defined and before flags are accessed by the program. The return value will be ErrHelp if -help or -h were set but not defined.</source>
          <target state="translated">Parse从参数列表中解析标志定义,参数列表中不应该包括命令名。必须在FlagSet中的所有标志被定义之后,并且在程序访问标志之前调用。如果设置了-help或-h但没有定义,则返回值为ErrHelp。</target>
        </trans-unit>
        <trans-unit id="18bad4ea2cc97c8a9f4948e0f21e613e7890178a" translate="yes" xml:space="preserve">
          <source>Parse parses rawurl into a URL structure.</source>
          <target state="translated">解析将rawurl解析成一个URL结构。</target>
        </trans-unit>
        <trans-unit id="68237f10d24bed5fb80b0763ff0184c661ba1727" translate="yes" xml:space="preserve">
          <source>Parse parses s which must contain a text representation of a floating- point number with a mantissa in the given conversion base (the exponent is always a decimal number), or a string representing an infinite value.</source>
          <target state="translated">解析分析s必须包含一个浮点数的文本表示,在给定的转换基数中带有一个尾数(指数总是一个小数),或者一个表示无限值的字符串。</target>
        </trans-unit>
        <trans-unit id="36bbed9dac5fc81c047e065b17ee658b65e3a5a6" translate="yes" xml:space="preserve">
          <source>Parse parses text as a template body for t. Named template definitions ({{define ...}} or {{block ...}} statements) in text define additional templates associated with t and are removed from the definition of t itself.</source>
          <target state="translated">Parse将文本解析为t的模板体,文本中的命名模板定义({{define ...}}或{{block ...}}语句)定义了与t相关的附加模板,并从t本身的定义中删除。</target>
        </trans-unit>
        <trans-unit id="b0827d39a9b548f4f8b5bce9dee6cdaa918b52e5" translate="yes" xml:space="preserve">
          <source>Parse parses the command-line flags from os.Args[1:]. Must be called after all flags are defined and before flags are accessed by the program.</source>
          <target state="translated">Parse 从 os.Args[1:]中解析命令行标志。必须在定义了所有标志之后,在程序访问标志之前调用。</target>
        </trans-unit>
        <trans-unit id="b42efe8079bb64df560c33d7d830ca75ae8ed877" translate="yes" xml:space="preserve">
          <source>Parse parses the template definition string to construct a representation of the template for execution. If either action delimiter string is empty, the default (&quot;{{&quot; or &quot;}}&quot;) is used. Embedded template definitions are added to the treeSet map.</source>
          <target state="translated">Parse解析模板定义字符串,以构建模板的表示,以便执行。如果任一动作定界符字符串为空,则使用默认值(&quot;{{&quot;或&quot;}}&quot;)。嵌入的模板定义会被添加到 treeSet 地图中。</target>
        </trans-unit>
        <trans-unit id="45783abf61a9fbf7fb39991bfe339c1b46133bb7" translate="yes" xml:space="preserve">
          <source>Parse returns a map from template name to parse.Tree, created by parsing the templates described in the argument string. The top-level template will be given the specified name. If an error is encountered, parsing stops and an empty map is returned with the error.</source>
          <target state="translated">Parse 返回一个从模板名称到 parse.Tree 的映射,该映射是通过解析参数字符串中描述的模板创建的。顶层模板将被赋予指定的名称。如果遇到错误,则停止解析,并返回一个带错误的空映射。</target>
        </trans-unit>
        <trans-unit id="66daff607d3735d4a8218dfbf123ab6dbc3c14bd" translate="yes" xml:space="preserve">
          <source>ParseAddress</source>
          <target state="translated">ParseAddress</target>
        </trans-unit>
        <trans-unit id="845f64c05cb52df568c8a8ad63c74420b1248668" translate="yes" xml:space="preserve">
          <source>ParseAddress parses a single RFC 5322 address, e.g. &quot;Barry Gibbs &amp;lt;bg@example.com&amp;gt;&quot;</source>
          <target state="translated">ParseAddress解析单个RFC 5322地址，例如&amp;ldquo; Barry Gibbs &amp;lt;bg@example.com&amp;gt;&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="ff9201bea61c197b726cdbdba040febe1fb6e8d1" translate="yes" xml:space="preserve">
          <source>ParseAddressList</source>
          <target state="translated">ParseAddressList</target>
        </trans-unit>
        <trans-unit id="ac5ae9b34b3307e496577d3e37b7a87a645c4e1d" translate="yes" xml:space="preserve">
          <source>ParseAddressList parses the given string as a list of addresses.</source>
          <target state="translated">ParseAddressList将给定的字符串解析为一个地址列表。</target>
        </trans-unit>
        <trans-unit id="6a0560d771cdd8a3e81f49597b77c74c345d99ff" translate="yes" xml:space="preserve">
          <source>ParseBool</source>
          <target state="translated">ParseBool</target>
        </trans-unit>
        <trans-unit id="48e4dd268460af7ff4ba4ae65e2a683e5e2d3f52" translate="yes" xml:space="preserve">
          <source>ParseBool returns the boolean value represented by the string. It accepts 1, t, T, TRUE, true, True, 0, f, F, FALSE, false, False. Any other value returns an error.</source>
          <target state="translated">ParseBool返回字符串所代表的布尔值。它接受1、t、T、TRUE、true、True、0、f、F、FALSE、false、False。任何其他值都会返回一个错误。</target>
        </trans-unit>
        <trans-unit id="22e1b2e318d4e5834961059fa9d10ad0bddc3198" translate="yes" xml:space="preserve">
          <source>ParseBool, ParseFloat, ParseInt, and ParseUint convert strings to values:</source>
          <target state="translated">ParseBool,ParseFloat,ParseInt,和 ParseUint 将字符串转换为数值。</target>
        </trans-unit>
        <trans-unit id="b287ba3d9ab143c06c570eef216327abbf80cd22" translate="yes" xml:space="preserve">
          <source>ParseCIDR</source>
          <target state="translated">ParseCIDR</target>
        </trans-unit>
        <trans-unit id="753119985829ad20f5fb77b43aff8f713890c2d1" translate="yes" xml:space="preserve">
          <source>ParseCIDR parses s as a CIDR notation IP address and prefix length, like &quot;192.0.2.0/24&quot; or &quot;2001:db8::/32&quot;, as defined in RFC 4632 and RFC 4291.</source>
          <target state="translated">ParseCIDR将s解析为CIDR符号IP地址和前缀长度,如 &quot;192.0.2.0/24 &quot;或 &quot;2001:db8::/32&quot;,如RFC 4632和RFC 4291所定义。</target>
        </trans-unit>
        <trans-unit id="3db7887ddb0dc9836c9d867b0da11217386b066e" translate="yes" xml:space="preserve">
          <source>ParseCRL parses a CRL from the given bytes. It's often the case that PEM encoded CRLs will appear where they should be DER encoded, so this function will transparently handle PEM encoding as long as there isn't any leading garbage.</source>
          <target state="translated">ParseCRL从给定的字节中解析出一个CRL。通常情况下,PEM编码的CRL会出现在它们应该是DER编码的地方,所以只要没有任何前导垃圾,这个函数就会透明地处理PEM编码。</target>
        </trans-unit>
        <trans-unit id="13bcfda4565f496b59a919b4e59789ae5fb7deb1" translate="yes" xml:space="preserve">
          <source>ParseCertificate parses a single certificate from the given ASN.1 DER data.</source>
          <target state="translated">ParseCertificate从给定的ASN.1 DER数据中解析一个证书。</target>
        </trans-unit>
        <trans-unit id="d4b98b2809a870dbc00f34abcb696de9660e20f1" translate="yes" xml:space="preserve">
          <source>ParseCertificateRequest parses a single certificate request from the given ASN.1 DER data.</source>
          <target state="translated">ParseCertificateRequest从给定的ASN.1 DER数据中解析一个证书请求。</target>
        </trans-unit>
        <trans-unit id="9d2d10677b59853b34c04edbc18da2141f6ef823" translate="yes" xml:space="preserve">
          <source>ParseCertificates parses one or more certificates from the given ASN.1 DER data. The certificates must be concatenated with no intermediate padding.</source>
          <target state="translated">ParseCertificates从给定的ASN.1 DER数据中解析一个或多个证书。证书必须是连在一起的,没有中间的填充。</target>
        </trans-unit>
        <trans-unit id="2cab629150d21e9f3c9fe4049ab7a14ed1660bb2" translate="yes" xml:space="preserve">
          <source>ParseComplex converts the string s to a complex number with the precision specified by bitSize: 64 for complex64, or 128 for complex128. When bitSize=64, the result still has type complex128, but it will be convertible to complex64 without changing its value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fa30c63d37bc2001c3a764872c0890c61f8acf6" translate="yes" xml:space="preserve">
          <source>ParseDERCRL parses a DER encoded CRL from the given bytes.</source>
          <target state="translated">ParseDERCRL从给定的字节中解析出一个DER编码的CRL。</target>
        </trans-unit>
        <trans-unit id="f3ec2edc0774eff41258539b91058f5d4cf9cd35" translate="yes" xml:space="preserve">
          <source>ParseDate parses an RFC 5322 date string.</source>
          <target state="translated">ParseDate解析一个RFC 5322日期字符串。</target>
        </trans-unit>
        <trans-unit id="758fe9e9cbf2d56e3666f652d8acda7c98141564" translate="yes" xml:space="preserve">
          <source>ParseDir calls ParseFile for all files with names ending in &quot;.go&quot; in the directory specified by path and returns a map of package name -&amp;gt; package AST with all the packages found.</source>
          <target state="translated">ParseDir在路径指定的目录中对名称以&amp;ldquo; .go&amp;rdquo;结尾的所有文件调用ParseFile，并返回包名称-&amp;gt;包AST的映射，其中找到了所有包。</target>
        </trans-unit>
        <trans-unit id="047621ddb91e82c184423e2a73f8e0cee328837e" translate="yes" xml:space="preserve">
          <source>ParseDirent parses up to max directory entries in buf, appending the names to names. It returns the number of bytes consumed from buf, the number of entries added to names, and the new names slice.</source>
          <target state="translated">ParseDirent 最多解析 buf 中的最大目录条目,将名字追加到 names 中。它返回从buf中消耗的字节数,添加到names中的条目数,以及新的names slice。</target>
        </trans-unit>
        <trans-unit id="ba15ad44a0d5b5aa5c04df3157000d88065b3088" translate="yes" xml:space="preserve">
          <source>ParseDuration</source>
          <target state="translated">ParseDuration</target>
        </trans-unit>
        <trans-unit id="0ccdc47cbfb062465c3ce4028258bbb8cace970b" translate="yes" xml:space="preserve">
          <source>ParseDuration parses a duration string. A duration string is a possibly signed sequence of decimal numbers, each with optional fraction and a unit suffix, such as &quot;300ms&quot;, &quot;-1.5h&quot; or &quot;2h45m&quot;. Valid time units are &quot;ns&quot;, &quot;us&quot; (or &quot;&amp;micro;s&quot;), &quot;ms&quot;, &quot;s&quot;, &quot;m&quot;, &quot;h&quot;.</source>
          <target state="translated">ParseDuration解析持续时间字符串。持续时间字符串是可能带符号的十进制数字序列，每个序列都有可选的分数和一个单位后缀，例如&amp;ldquo; 300ms&amp;rdquo;，&amp;ldquo;-1.5h&amp;rdquo;或&amp;ldquo; 2h45m&amp;rdquo;。有效时间单位为&amp;ldquo; ns&amp;rdquo;，&amp;ldquo; us&amp;rdquo;（或&amp;ldquo; &amp;micro;s&amp;rdquo;），&amp;ldquo; ms&amp;rdquo;，&amp;ldquo; s&amp;rdquo;，&amp;ldquo; m&amp;rdquo;，&amp;ldquo; h&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="67fb1e245593c79c4ca873f961b0227d64ccfe30" translate="yes" xml:space="preserve">
          <source>ParseECPrivateKey parses an EC private key in SEC 1, ASN.1 DER form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6665378bb888147fd38985161b70b786f3c21803" translate="yes" xml:space="preserve">
          <source>ParseECPrivateKey parses an EC public key in SEC 1, ASN.1 DER form.</source>
          <target state="translated">ParseECPrivateKey解析SEC 1、ASN.1 DER形式的EC公钥。</target>
        </trans-unit>
        <trans-unit id="892fbba930b3566d06f9df2030763cda6ce95827" translate="yes" xml:space="preserve">
          <source>ParseError describes a problem parsing a time string.</source>
          <target state="translated">ParseError描述了一个解析时间字符串的问题。</target>
        </trans-unit>
        <trans-unit id="9a582c1b02184d48074757655b946996d9f55882" translate="yes" xml:space="preserve">
          <source>ParseExpr is a convenience function for obtaining the AST of an expression x. The position information recorded in the AST is undefined. The filename used in error messages is the empty string.</source>
          <target state="translated">ParseExpr是一个获取表达式x的AST的方便函数,AST中记录的位置信息是未定义的。错误信息中使用的文件名是空字符串。</target>
        </trans-unit>
        <trans-unit id="4fb56e49503c8edcde61d5f7c76a772eeec3484c" translate="yes" xml:space="preserve">
          <source>ParseExprFrom is a convenience function for parsing an expression. The arguments have the same meaning as for ParseFile, but the source must be a valid Go (type or value) expression. Specifically, fset must not be nil.</source>
          <target state="translated">ParseExprFrom 是一个用于解析表达式的方便函数,其参数与 ParseFile 的意义相同,但源必须是有效的 Go(类型或值)表达式。参数的含义与 ParseFile 相同,但源必须是有效的 Go(类型或值)表达式。具体来说,fset不能是nil。</target>
        </trans-unit>
        <trans-unit id="952e5591ef32d1313e1d0274155bf47019e78eb9" translate="yes" xml:space="preserve">
          <source>ParseFS is like ParseFiles or ParseGlob but reads from the file system fs instead of the host operating system's file system. It accepts a list of glob patterns. (Note that most file names serve as glob patterns matching only themselves.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3f721297f1ca751ee9487c4af009140afa4a6a0" translate="yes" xml:space="preserve">
          <source>ParseFS is like ParseFiles or ParseGlob but reads from the file system fsys instead of the host operating system's file system. It accepts a list of glob patterns. (Note that most file names serve as glob patterns matching only themselves.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1451f0a6821c5b4b2901efe0f3d53819e7c6a483" translate="yes" xml:space="preserve">
          <source>ParseFile</source>
          <target state="translated">ParseFile</target>
        </trans-unit>
        <trans-unit id="8e9f94dbd4c4295f5a413cdec1747ee6881cd1da" translate="yes" xml:space="preserve">
          <source>ParseFile parses the source code of a single Go source file and returns the corresponding ast.File node. The source code may be provided via the filename of the source file, or via the src parameter.</source>
          <target state="translated">ParseFile 解析单个 Go 源文件的源代码并返回相应的 ast.File 节点。源代码可以通过源文件的文件名或src参数来提供。</target>
        </trans-unit>
        <trans-unit id="af492bad6c90c31471d746324ef2632bf8eb772d" translate="yes" xml:space="preserve">
          <source>ParseFiles creates a new Template and parses the template definitions from the named files. The returned template's name will have the (base) name and (parsed) contents of the first file. There must be at least one file. If an error occurs, parsing stops and the returned *Template is nil.</source>
          <target state="translated">ParseFiles创建一个新的Template并从命名的文件中解析模板定义。返回的模板的名称将有第一个文件的(基础)名称和(解析的)内容。必须至少有一个文件。如果发生错误,解析将停止,返回的*Template为nil。</target>
        </trans-unit>
        <trans-unit id="8327ff213ed2179b27e0e16f606053c1fb04d28d" translate="yes" xml:space="preserve">
          <source>ParseFiles creates a new Template and parses the template definitions from the named files. The returned template's name will have the base name and parsed contents of the first file. There must be at least one file. If an error occurs, parsing stops and the returned *Template is nil.</source>
          <target state="translated">ParseFiles创建一个新的Template,并从命名的文件中解析模板定义。返回的模板的名称将有第一个文件的基本名称和解析的内容。必须至少有一个文件。如果发生错误,解析将停止,返回的*Template为nil。</target>
        </trans-unit>
        <trans-unit id="ce6f3fc6adf60ff33bcdf40a608ef536cc90aa22" translate="yes" xml:space="preserve">
          <source>ParseFiles parses the named files and associates the resulting templates with t. If an error occurs, parsing stops and the returned template is nil; otherwise it is t. There must be at least one file.</source>
          <target state="translated">ParseFiles解析命名的文件,并将产生的模板与t相关联。如果发生错误,解析将停止,返回的模板为nil;否则为t。必须至少有一个文件。</target>
        </trans-unit>
        <trans-unit id="79c733c837a6ce524269772c4ef5bf48fb11ea5a" translate="yes" xml:space="preserve">
          <source>ParseFiles parses the named files and associates the resulting templates with t. If an error occurs, parsing stops and the returned template is nil; otherwise it is t. There must be at least one file. Since the templates created by ParseFiles are named by the base names of the argument files, t should usually have the name of one of the (base) names of the files. If it does not, depending on t's contents before calling ParseFiles, t.Execute may fail. In that case use t.ExecuteTemplate to execute a valid template.</source>
          <target state="translated">ParseFiles解析被命名的文件,并将得到的模板与t相关联。如果发生错误,解析停止,返回的模板为nil;否则就是t。由于ParseFiles创建的模板是由参数文件的基名命名的,所以t通常应该具有文件的(基)名之一。如果没有,根据调用 ParseFiles 之前 t 的内容,t.Execute 可能会失败。在这种情况下,使用t.ExecuteTemplate来执行一个有效的模板。</target>
        </trans-unit>
        <trans-unit id="91b51eccc60ebf92659e48c7256549a53f281cf8" translate="yes" xml:space="preserve">
          <source>ParseFiles returns an error if t or any associated template has already been executed.</source>
          <target state="translated">如果t或任何相关模板已经被执行,ParseFiles将返回一个错误。</target>
        </trans-unit>
        <trans-unit id="6b854a59dfcaea7000b265f3f7af7b0441340249" translate="yes" xml:space="preserve">
          <source>ParseFloat</source>
          <target state="translated">ParseFloat</target>
        </trans-unit>
        <trans-unit id="a968f6b35cbd445c2c3e17a676a673ab0f036e6d" translate="yes" xml:space="preserve">
          <source>ParseFloat accepts decimal and hexadecimal floating-point number syntax. If s is well-formed and near a valid floating-point number, ParseFloat returns the nearest floating-point number rounded using IEEE754 unbiased rounding. (Parsing a hexadecimal floating-point value only rounds when there are more bits in the hexadecimal representation than will fit in the mantissa.)</source>
          <target state="translated">ParseFloat接受十进制和十六进制的浮点数语法。如果s是一个格式良好且接近有效的浮点数,ParseFloat返回最近的浮点数,并使用IEEE754无偏四舍五入。(解析十六进制浮点数时,只有当十六进制表示法中的位数多于尾数时,才会进行四舍五入。)</target>
        </trans-unit>
        <trans-unit id="af48529cc69b2749ba1cfbd0072a925bc4216cca" translate="yes" xml:space="preserve">
          <source>ParseFloat converts the string s to a floating-point number with the precision specified by bitSize: 32 for float32, or 64 for float64. When bitSize=32, the result still has type float64, but it will be convertible to float32 without changing its value.</source>
          <target state="translated">ParseFloat 将字符串 s 转换为浮点数,其精度由 bitSize 指定:32 表示 float32,64 表示 float64。当bitSize=32时,结果的类型仍然是float64,但它将被转换为float32,而不会改变其值。</target>
        </trans-unit>
        <trans-unit id="f8f279e3e47cdc9cf9d872e61192822459d62d17" translate="yes" xml:space="preserve">
          <source>ParseFloat is like f.Parse(s, base) with f set to the given precision and rounding mode.</source>
          <target state="translated">ParseFloat 就像 f.Parse(s,base)一样,f 设置为给定的精度和四舍五入模式。</target>
        </trans-unit>
        <trans-unit id="fd5ce5b41aa64ac617d720e123321224a7f4d140" translate="yes" xml:space="preserve">
          <source>ParseFloat recognizes the strings &quot;NaN&quot;, &quot;+Inf&quot;, and &quot;-Inf&quot; as their respective special floating point values. It ignores case when matching.</source>
          <target state="translated">ParseFloat 识别字符串 &quot;NaN&quot;、&quot;+Inf &quot;和&quot;-Inf &quot;作为它们各自的特殊浮点值。它在匹配时忽略了大小写。</target>
        </trans-unit>
        <trans-unit id="8650e12cd7045e56563668c7ff1087423737dd23" translate="yes" xml:space="preserve">
          <source>ParseFloat recognizes the strings &quot;NaN&quot;, and the (possibly signed) strings &quot;Inf&quot; and &quot;Infinity&quot; as their respective special floating point values. It ignores case when matching.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7da060a59d225b78f860ce3acdb64ab957496796" translate="yes" xml:space="preserve">
          <source>ParseForm populates r.Form and r.PostForm.</source>
          <target state="translated">ParseForm填充r.Form和r.PostForm。</target>
        </trans-unit>
        <trans-unit id="07f8973752a66d43b70ef7fb0a84b494aed23663" translate="yes" xml:space="preserve">
          <source>ParseGlob creates a new Template and parses the template definitions from the files identified by the pattern. The files are matched according to the semantics of filepath.Match, and the pattern must match at least one file. The returned template will have the (base) name and (parsed) contents of the first file matched by the pattern. ParseGlob is equivalent to calling ParseFiles with the list of files matched by the pattern.</source>
          <target state="translated">ParseGlob创建一个新的Template,并从模式识别的文件中解析模板定义。文件根据filepath.Match的语义进行匹配,并且模式必须至少匹配一个文件。返回的模板将具有模式匹配的第一个文件的(基础)名称和(解析的)内容。ParseGlob相当于用模式匹配的文件列表调用ParseFiles。</target>
        </trans-unit>
        <trans-unit id="0041d2aedbde4c39f613a021a871fa8b33bebd33" translate="yes" xml:space="preserve">
          <source>ParseGlob parses the template definitions in the files identified by the pattern and associates the resulting templates with t. The files are matched according to the semantics of filepath.Match, and the pattern must match at least one file. ParseGlob is equivalent to calling t.ParseFiles with the list of files matched by the pattern.</source>
          <target state="translated">ParseGlob解析模式所标识的文件中的模板定义,并将得到的模板与t相关联。文件根据filepath.Match的语义进行匹配,并且模式必须至少匹配一个文件。ParseGlob相当于用模式匹配的文件列表调用t.ParseFiles。</target>
        </trans-unit>
        <trans-unit id="57508561e68db8f352026127277c4527c06f1494" translate="yes" xml:space="preserve">
          <source>ParseGlob returns an error if t or any associated template has already been executed.</source>
          <target state="translated">如果t或任何相关模板已经被执行,ParseGlob将返回一个错误。</target>
        </trans-unit>
        <trans-unit id="1c95736c9372d59f539bafb6f91f3448c1e25ac0" translate="yes" xml:space="preserve">
          <source>ParseHTTPVersion parses a HTTP version string. &quot;HTTP/1.0&quot; returns (1, 0, true).</source>
          <target state="translated">ParseHTTPVersion解析一个HTTP版本字符串。&quot;HTTP/1.0 &quot;返回(1,0,true)。</target>
        </trans-unit>
        <trans-unit id="d7d53bd1e0c1908e14a24fac95a6c063838225ad" translate="yes" xml:space="preserve">
          <source>ParseHTTPVersion parses an HTTP version string. &quot;HTTP/1.0&quot; returns (1, 0, true).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6238bd01ff6944e78dfd936bd2b841304ebe18fe" translate="yes" xml:space="preserve">
          <source>ParseIP</source>
          <target state="translated">ParseIP</target>
        </trans-unit>
        <trans-unit id="571efae0ba53198c7ce6853ee4da1a9ca8b3d31b" translate="yes" xml:space="preserve">
          <source>ParseIP parses s as an IP address, returning the result. The string s can be in IPv4 dotted decimal (&quot;192.0.2.1&quot;), IPv6 (&quot;2001:db8::68&quot;), or IPv4-mapped IPv6 (&quot;::ffff:192.0.2.1&quot;) form. If s is not a valid textual representation of an IP address, ParseIP returns nil.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5c3f7806dc6261b34a424f0eac37be19bc2181d" translate="yes" xml:space="preserve">
          <source>ParseIP parses s as an IP address, returning the result. The string s can be in dotted decimal (&quot;192.0.2.1&quot;) or IPv6 (&quot;2001:db8::68&quot;) form. If s is not a valid textual representation of an IP address, ParseIP returns nil.</source>
          <target state="translated">ParseIP 将 s 解析为一个 IP 地址,并返回结果。字符串s可以是点阵十进制(&quot;192.0.2.1&quot;)或IPv6(&quot;2001:db8::68&quot;)形式。如果s不是IP地址的有效文本表示,ParseIP返回nil。</target>
        </trans-unit>
        <trans-unit id="c329eecfda46c75a2f5a9732976e5ca2eab67b96" translate="yes" xml:space="preserve">
          <source>ParseInLocation</source>
          <target state="translated">ParseInLocation</target>
        </trans-unit>
        <trans-unit id="b946980b6995c0bdde650965df500396097ee47e" translate="yes" xml:space="preserve">
          <source>ParseInLocation is like Parse but differs in two important ways. First, in the absence of time zone information, Parse interprets a time as UTC; ParseInLocation interprets the time as in the given location. Second, when given a zone offset or abbreviation, Parse tries to match it against the Local location; ParseInLocation uses the given location.</source>
          <target state="translated">ParseInLocation 和 Parse 一样,但有两个重要的不同之处:第一,在没有时区信息的情况下,Parse 将时间解释为 UTC;ParseInLocation 将时间解释为给定地点。首先,在没有时区信息的情况下,Parse 将时间解释为 UTC;ParseInLocation 将时间解释为给定位置的时间。第二,当给定一个区域偏移量或缩写时,Parse 试图将其与 Local 位置进行匹配;ParseInLocation 使用给定的位置。</target>
        </trans-unit>
        <trans-unit id="fd43b39f1cc6436ed26bf5ddd12e6461d48a315e" translate="yes" xml:space="preserve">
          <source>ParseInt</source>
          <target state="translated">ParseInt</target>
        </trans-unit>
        <trans-unit id="da8e97b7f44fd2f5e3e7756990fdef1ef6036785" translate="yes" xml:space="preserve">
          <source>ParseInt interprets a string s in the given base (0, 2 to 36) and bit size (0 to 64) and returns the corresponding value i.</source>
          <target state="translated">ParseInt解释给定基数(0,2到36)和位数(0到64)的字符串s,并返回相应的值i。</target>
        </trans-unit>
        <trans-unit id="da7fc45328cc9114fb2744e73272d12d929fea5f" translate="yes" xml:space="preserve">
          <source>ParseList parses the given string as a list of comma-separated addresses of the form &quot;Gogh Fir &amp;lt;gf@example.com&amp;gt;&quot; or &quot;foo@example.com&quot;.</source>
          <target state="translated">ParseList将给定的字符串解析为逗号分隔的地址列表，格式为&amp;ldquo; Gogh Fir &amp;lt;gf@example.com&amp;gt;&amp;rdquo;或&amp;ldquo; foo@example.com&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="721a0c1b5d6d1ee41cb2e1ce2ccd8399686328dd" translate="yes" xml:space="preserve">
          <source>ParseMAC parses s as an IEEE 802 MAC-48, EUI-48, EUI-64, or a 20-octet IP over InfiniBand link-layer address using one of the following formats:</source>
          <target state="translated">ParseMAC使用以下格式之一将s解析为IEEE 802 MAC-48、EUI-48、EUI-64或20字节的IP over InfiniBand链路层地址。</target>
        </trans-unit>
        <trans-unit id="c4421efbff2b17851a18162d590161832e04ac88" translate="yes" xml:space="preserve">
          <source>ParseMediaType</source>
          <target state="translated">ParseMediaType</target>
        </trans-unit>
        <trans-unit id="76d8884907e134cde6d1ae2f450cf0d83b8102aa" translate="yes" xml:space="preserve">
          <source>ParseMediaType parses a media type value and any optional parameters, per RFC 1521. Media types are the values in Content-Type and Content-Disposition headers (RFC 2183). On success, ParseMediaType returns the media type converted to lowercase and trimmed of white space and a non-nil map. If there is an error parsing the optional parameter, the media type will be returned along with the error ErrInvalidMediaParameter. The returned map, params, maps from the lowercase attribute to the attribute value with its case preserved.</source>
          <target state="translated">ParseMediaType根据RFC 1521解析媒体类型值和任何可选参数。媒体类型是Content-Type和Content-Disposition头文件(RFC 2183)中的值。解析成功后,ParseMediaType会返回转换为小写的媒体类型,并修剪掉空白和一个非零的映射。如果在解析可选参数时出现错误,媒体类型将和错误ErrInvalidMediaParameter一起返回。返回的映射,params,从小写属性映射到保留大小写的属性值。</target>
        </trans-unit>
        <trans-unit id="bb8befc3cebb8742e6d50cfeac64769f0a3fff7a" translate="yes" xml:space="preserve">
          <source>ParseMultipartForm calls ParseForm automatically. ParseForm is idempotent.</source>
          <target state="translated">ParseMultipartForm自动调用ParseForm。ParseForm是幂等的。</target>
        </trans-unit>
        <trans-unit id="4205ffb0814fbcba9218830e9ad58589fcb016f6" translate="yes" xml:space="preserve">
          <source>ParseMultipartForm parses a request body as multipart/form-data. The whole request body is parsed and up to a total of maxMemory bytes of its file parts are stored in memory, with the remainder stored on disk in temporary files. ParseMultipartForm calls ParseForm if necessary. After one call to ParseMultipartForm, subsequent calls have no effect.</source>
          <target state="translated">ParseMultipartForm将一个请求体解析为multipart/form-data。整个请求体被解析后,它的文件部分最多总共有maxMemory字节存储在内存中,其余部分则存储在磁盘的临时文件中。ParseMultipartForm在必要时调用ParseForm。对ParseMultipartForm调用一次后,后续的调用没有任何效果。</target>
        </trans-unit>
        <trans-unit id="eecdedc3b85cbbe7f7cb2f75d45c36832c9b2317" translate="yes" xml:space="preserve">
          <source>ParseNetlinkMessage parses b as an array of netlink messages and returns the slice containing the NetlinkMessage structures.</source>
          <target state="translated">ParseNetlinkMessage将b解析为一个netlink消息数组,并返回包含NetlinkMessage结构的片断。</target>
        </trans-unit>
        <trans-unit id="2f0d8e60be2a0b26156f23d2b913830f42953f1b" translate="yes" xml:space="preserve">
          <source>ParseNetlinkRouteAttr parses m's payload as an array of netlink route attributes and returns the slice containing the NetlinkRouteAttr structures.</source>
          <target state="translated">ParseNetlinkRouteAttr将m的有效载荷解析为一个网链路由属性数组,并返回包含NetlinkRouteAttr结构的片断。</target>
        </trans-unit>
        <trans-unit id="a52b587a767bf1c632bedd738233c237df6d3c78" translate="yes" xml:space="preserve">
          <source>ParsePKCS1PrivateKey parses an RSA private key in PKCS #1, ASN.1 DER form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca8ea4136f1532755b07a48dc5268d78ecf1507c" translate="yes" xml:space="preserve">
          <source>ParsePKCS1PrivateKey parses an RSA private key in PKCS#1, ASN.1 DER form.</source>
          <target state="translated">ParsePKCS1PrivateKey解析PKCS#1、ASN.1 DER形式的RSA私钥。</target>
        </trans-unit>
        <trans-unit id="619bab7e2604776223fd615db8a092b41e8c25c2" translate="yes" xml:space="preserve">
          <source>ParsePKCS1PublicKey parses an RSA public key in PKCS #1, ASN.1 DER form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37bf10698677a842cf4d973614d5f0307c9b4ece" translate="yes" xml:space="preserve">
          <source>ParsePKCS1PublicKey parses an RSA public key in PKCS#1, ASN.1 DER form.</source>
          <target state="translated">ParsePKCS1PublicKey解析PKCS#1、ASN.1 DER形式的RSA公钥。</target>
        </trans-unit>
        <trans-unit id="b68e3b8c9444e28652781f01507938e01d6187fc" translate="yes" xml:space="preserve">
          <source>ParsePKCS8PrivateKey parses an unencrypted private key in PKCS #8, ASN.1 DER form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="585855469081df34619bcab57c0395b99ac9b879" translate="yes" xml:space="preserve">
          <source>ParsePKCS8PrivateKey parses an unencrypted private key in PKCS#8, ASN.1 DER form.</source>
          <target state="translated">ParsePKCS8PrivateKey解析PKCS#8,ASN.1 DER形式的未加密私钥。</target>
        </trans-unit>
        <trans-unit id="53e14792de36ed6cd3349fb2645358e6cd29fbb8" translate="yes" xml:space="preserve">
          <source>ParsePKIXPublicKey</source>
          <target state="translated">ParsePKIXPublicKey</target>
        </trans-unit>
        <trans-unit id="6a4599b4f783a30e67850f302db74a263e5ed679" translate="yes" xml:space="preserve">
          <source>ParsePKIXPublicKey parses a public key in PKIX, ASN.1 DER form.</source>
          <target state="translated">ParsePKIXPublicKey解析PKIX、ASN.1 DER形式的公钥。</target>
        </trans-unit>
        <trans-unit id="e7171526935278226200717c1ff03247778459d2" translate="yes" xml:space="preserve">
          <source>ParsePKIXPublicKey parses a public key in PKIX, ASN.1 DER form. The encoded public key is a SubjectPublicKeyInfo structure (see RFC 5280, Section 4.1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e247d1a303dadeb36ebb627b0c5ca3e52bc27fd" translate="yes" xml:space="preserve">
          <source>ParseQuery</source>
          <target state="translated">ParseQuery</target>
        </trans-unit>
        <trans-unit id="7c00812498355c3d782c270a326950a437297e57" translate="yes" xml:space="preserve">
          <source>ParseQuery parses the URL-encoded query string and returns a map listing the values specified for each key. ParseQuery always returns a non-nil map containing all the valid query parameters found; err describes the first decoding error encountered, if any.</source>
          <target state="translated">ParseQuery解析URL编码的查询字符串,并返回一个映射,列出为每个键指定的值。ParseQuery总是返回一个非零的映射,包含所有找到的有效查询参数;err描述了遇到的第一个解码错误(如果有的话)。</target>
        </trans-unit>
        <trans-unit id="3d5fafc8859915dea1eca90debdb2203d7081d9e" translate="yes" xml:space="preserve">
          <source>ParseRequestURI parses rawurl into a URL structure. It assumes that rawurl was received in an HTTP request, so the rawurl is interpreted only as an absolute URI or an absolute path. The string rawurl is assumed not to have a #fragment suffix. (Web browsers strip #fragment before sending the URL to a web server.)</source>
          <target state="translated">ParseRequestURI将rawurl解析成一个URL结构。它假设rawurl是在HTTP请求中接收到的,所以rawurl只被解释为一个绝对URI或绝对路径。字符串rawurl被认为没有#fragment后缀。(Web浏览器在向Web服务器发送URL之前会将#fragment去掉)。</target>
        </trans-unit>
        <trans-unit id="303cbaa0aec4b7b4cb545ea3bdd253a60da46165" translate="yes" xml:space="preserve">
          <source>ParseSocketControlMessage parses b as an array of socket control messages.</source>
          <target state="translated">ParseSocketControlMessage将b解析为一个套接字控制消息数组。</target>
        </trans-unit>
        <trans-unit id="68f8375ee4255e9bdd0c3030df2260150e5493b0" translate="yes" xml:space="preserve">
          <source>ParseTime parses a time header (such as the Date: header), trying each of the three formats allowed by HTTP/1.1: TimeFormat, time.RFC850, and time.ANSIC.</source>
          <target state="translated">ParseTime解析一个时间头(如Date:头),尝试HTTP/1.1允许的三种格式。TimeFormat、time.RFC850和time.ANSIC。</target>
        </trans-unit>
        <trans-unit id="d09c9d04f1ff3f62cff402b66559957826b67ae1" translate="yes" xml:space="preserve">
          <source>ParseUint</source>
          <target state="translated">ParseUint</target>
        </trans-unit>
        <trans-unit id="7c5c32fd6cd92c39f679dc5ed50b80a4f8a1e92b" translate="yes" xml:space="preserve">
          <source>ParseUint is like ParseInt but for unsigned numbers.</source>
          <target state="translated">ParseUint 和 ParseInt 一样,但适用于无符号数。</target>
        </trans-unit>
        <trans-unit id="5bf4d74ce6c1b340caf3e896ab5b84ef49cf1719" translate="yes" xml:space="preserve">
          <source>ParseUnixCredentials decodes a socket control message that contains credentials in a Ucred structure. To receive such a message, the SO_PASSCRED option must be enabled on the socket.</source>
          <target state="translated">ParseUnixCredentials 解码一个包含在 Ucred 结构中的凭证的套接字控制消息。要接收这样的消息,必须在套接字上启用SO_PASSCRED选项。</target>
        </trans-unit>
        <trans-unit id="f2cd01c6af8de29d78551fd8726d012bba380c6c" translate="yes" xml:space="preserve">
          <source>ParseUnixRights decodes a socket control message that contains an integer array of open file descriptors from another process.</source>
          <target state="translated">ParseUnixRights对一个套接字控制消息进行解码,该消息包含来自另一个进程的打开文件描述符的整数组。</target>
        </trans-unit>
        <trans-unit id="32ac0722953b3173953c3c4db2a050c68e2bace4" translate="yes" xml:space="preserve">
          <source>Parsed reports whether f.Parse has been called.</source>
          <target state="translated">Parsed报告f.Parsse是否被调用。</target>
        </trans-unit>
        <trans-unit id="3448f815420bc7428adf585d197c1f125467f90e" translate="yes" xml:space="preserve">
          <source>Parsed reports whether the command-line flags have been parsed.</source>
          <target state="translated">Parsed报告命令行标志是否已被解析。</target>
        </trans-unit>
        <trans-unit id="dc2eb8678f8e8ede0972857e44c6282f328cc1fa" translate="yes" xml:space="preserve">
          <source>Passing skip=0 begins the stack trace at the call to Add inside rpc.NewClient. Passing skip=1 begins the stack trace at the call to NewClient inside mypkg.Run.</source>
          <target state="translated">传递 skip=0 开始在 rpc.NewClient 里调用 Add 的堆栈跟踪。通过 skip=1 开始 mypkg.Run.NewClient 调用时的堆栈跟踪。</target>
        </trans-unit>
        <trans-unit id="bc137142636c80e92c407f2aa46fcdf54313c790" translate="yes" xml:space="preserve">
          <source>Password returns the password in case it is set, and whether it is set.</source>
          <target state="translated">密码在设置的情况下返回密码,是否设置。</target>
        </trans-unit>
        <trans-unit id="f13ee82061477b5d5f181659b252f63dfd901dcb" translate="yes" xml:space="preserve">
          <source>Path names passed to open are UTF-8-encoded, unrooted, slash-separated sequences of path elements, like &amp;ldquo;x/y/z&amp;rdquo;. Path names must not contain an element that is &amp;ldquo;.&amp;rdquo; or &amp;ldquo;..&amp;rdquo; or the empty string, except for the special case that the root directory is named &amp;ldquo;.&amp;rdquo;. Paths must not start or end with a slash: &amp;ldquo;/x&amp;rdquo; and &amp;ldquo;x/&amp;rdquo; are invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c6302867f847fe663bbe8d220f8e92a48796687" translate="yes" xml:space="preserve">
          <source>Path returns the package path.</source>
          <target state="translated">Path 返回包的路径。</target>
        </trans-unit>
        <trans-unit id="d0506b7bdb505a3150b81c4c616dee83d176fcfa" translate="yes" xml:space="preserve">
          <source>PathError records an error and the operation and file path that caused it.</source>
          <target state="translated">PathError记录了一个错误和造成该错误的操作和文件路径。</target>
        </trans-unit>
        <trans-unit id="e7599081a40b17f0e8c56bbb5dfa806da5a30888" translate="yes" xml:space="preserve">
          <source>PathEscape escapes the string so it can be safely placed inside a URL path segment, replacing special characters (including /) with %XX sequences as needed.</source>
          <target state="translated">PathEscape可以将字符串安全地放置在URL路径段中,根据需要用%XX序列替换特殊字符(包括/)。</target>
        </trans-unit>
        <trans-unit id="5c3a77b47b5350edac8b6dbc79888f216cc42e3c" translate="yes" xml:space="preserve">
          <source>PathUnescape does the inverse transformation of PathEscape, converting each 3-byte encoded substring of the form &quot;%AB&quot; into the hex-decoded byte 0xAB. It returns an error if any % is not followed by two hexadecimal digits.</source>
          <target state="translated">PathUnescape对PathEscape进行逆向转换,将每个3字节编码的&quot;%AB &quot;形式的子串转换为十六进制解码的字节0xAB。如果任何%后面没有两个十六进制数字,它将返回一个错误。</target>
        </trans-unit>
        <trans-unit id="40463bc26e83c862cf3b0e60286130df1ab877d6" translate="yes" xml:space="preserve">
          <source>PathUnescape is identical to QueryUnescape except that it does not unescape '+' to ' ' (space).</source>
          <target state="translated">PathUnescape与QueryUnescape相同,只是它不会将'+'去掉''(空格)。</target>
        </trans-unit>
        <trans-unit id="cda78fe9f7d0595a1e181ce1981b7483036ab29c" translate="yes" xml:space="preserve">
          <source>Patterns may optionally begin with a host name, restricting matches to URLs on that host only. Host-specific patterns take precedence over general patterns, so that a handler might register for the two patterns &quot;/codesearch&quot; and &quot;codesearch.google.com/&quot; without also taking over requests for &quot;&lt;a href=&quot;http://www.google.com/&quot;&gt;http://www.google.com/&lt;/a&gt;&quot;.</source>
          <target state="translated">模式可以选择以主机名开头，仅将匹配项限制在该主机上。特定于主机的模式优先于常规模式，因​​此处理程序可以注册&amp;ldquo; / codesearch&amp;rdquo;和&amp;ldquo; codesearch.google.com/&amp;rdquo;这两种模式，而无需接管对&amp;ldquo; &lt;a href=&quot;http://www.google.com/&quot;&gt;http://www.google.com/&lt;/a&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="9a97ef77b7d4a4a34405a8ad58960e3185e5b856" translate="yes" xml:space="preserve">
          <source>Patterns may optionally begin with a host name, restricting matches to URLs on that host only. Host-specific patterns take precedence over general patterns, so that a handler might register for the two patterns &quot;/codesearch&quot; and &quot;codesearch.google.com/&quot; without also taking over requests for &quot;&lt;a href=&quot;https://www.google.com/&quot;&gt;http://www.google.com/&lt;/a&gt;&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35bc941d4ad694a76b17fe9da3d7ad2fa01041f0" translate="yes" xml:space="preserve">
          <source>Patterns must not match files outside the package's module, such as &amp;lsquo;.git/*&amp;rsquo; or symbolic links. Matches for empty directories are ignored. After that, each pattern in a //go:embed line must match at least one file or non-empty directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c47c55adf239beb3a291abbb9f63d307ef60c16f" translate="yes" xml:space="preserve">
          <source>Patterns name fixed, rooted paths, like &quot;/favicon.ico&quot;, or rooted subtrees, like &quot;/images/&quot; (note the trailing slash). Longer patterns take precedence over shorter ones, so that if there are handlers registered for both &quot;/images/&quot; and &quot;/images/thumbnails/&quot;, the latter handler will be called for paths beginning &quot;/images/thumbnails/&quot; and the former will receive requests for any other paths in the &quot;/images/&quot; subtree.</source>
          <target state="translated">模式命名固定的、有根的路径,比如&quot;/favicon.ico&quot;,或者有根的子树,比如&quot;/images/&quot;(注意后面的斜杠)。较长的模式优先于较短的模式,因此,如果有同时注册了&quot;/images/&quot;和&quot;/images/thumbnails/&quot;的处理程序,那么后一个处理程序将被调用以&quot;/images/thumbnails/&quot;开头的路径,而前一个处理程序将接收对&quot;/images/&quot;子树中任何其他路径的请求。</target>
        </trans-unit>
        <trans-unit id="f28eb62c201920349ad82fd89183cea2a77fc0ce" translate="yes" xml:space="preserve">
          <source>Peek returns the next Unicode character in the source without advancing the scanner. It returns EOF if the scanner's position is at the last character of the source.</source>
          <target state="translated">Peek返回源码中的下一个Unicode字符,而不会使扫描器前进。如果扫描器的位置在源码的最后一个字符处,则返回EOF。</target>
        </trans-unit>
        <trans-unit id="2959c1935503c7a46c0b1958e9d8a81763a0ed6a" translate="yes" xml:space="preserve">
          <source>Peek returns the next n bytes without advancing the reader. The bytes stop being valid at the next read call. If Peek returns fewer than n bytes, it also returns an error explaining why the read is short. The error is ErrBufferFull if n is larger than b's buffer size.</source>
          <target state="translated">Peek返回下一个n个字节,而不推进读取器。这些字节在下一次读取调用时停止有效。如果Peek返回的字节数少于n个,它还会返回一个错误,解释为什么读短了。如果n大于b的缓冲区大小,则错误为ErrBufferFull。</target>
        </trans-unit>
        <trans-unit id="eb621fcca2c83af4eb20df9787fc904ec33fe0d9" translate="yes" xml:space="preserve">
          <source>Pending returns the number of unanswered requests that have been received on the connection.</source>
          <target state="translated">Pending(待处理)返回连接上已收到的未回复请求的数量。</target>
        </trans-unit>
        <trans-unit id="c6855a32465d5bf0f448eaa4af31e378ea6b4379" translate="yes" xml:space="preserve">
          <source>Pending returns the number of unanswered requests that have been sent on the connection.</source>
          <target state="translated">Pending(待处理)返回连接上已发送的未响应请求的数量。</target>
        </trans-unit>
        <trans-unit id="c7ceccb01b416098f13eef5c65da35dd4ef29c59" translate="yes" xml:space="preserve">
          <source>Perl character classes (all ASCII-only):</source>
          <target state="translated">Perl字符类(全部为ASCII码)。</target>
        </trans-unit>
        <trans-unit id="327a2b8cad2b9a6ef158a641755a49d69b9cc93f" translate="yes" xml:space="preserve">
          <source>Perm</source>
          <target state="translated">Perm</target>
        </trans-unit>
        <trans-unit id="3a2d3439b42d65bbd3e91c5161e12b3e5af6e212" translate="yes" xml:space="preserve">
          <source>Perm returns the Unix permission bits in m (m &amp;amp; ModePerm).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4cbc1d379695fc60a43435dd6614970bc7cf1c8" translate="yes" xml:space="preserve">
          <source>Perm returns the Unix permission bits in m.</source>
          <target state="translated">Perm返回m中的Unix权限位。</target>
        </trans-unit>
        <trans-unit id="6ed0eddcb867d78e7678ca142786b03c98fcc1cf" translate="yes" xml:space="preserve">
          <source>Perm returns, as a slice of n ints, a pseudo-random permutation of the integers [0,n) from the default Source.</source>
          <target state="translated">Perm作为n个ints的片断,从默认的Source返回一个整数[0,n]的伪随机排列。</target>
        </trans-unit>
        <trans-unit id="62a4f6eab662c10e8c22fcd7a13a5adce4b9aeef" translate="yes" xml:space="preserve">
          <source>Perm returns, as a slice of n ints, a pseudo-random permutation of the integers [0,n).</source>
          <target state="translated">Perm以n个ints的分片形式返回整数[0,n)的伪随机排列。</target>
        </trans-unit>
        <trans-unit id="2eb6560251a01ddeba6819d546ca94bf5106de3c" translate="yes" xml:space="preserve">
          <source>Phase returns the phase (also called the argument) of x. The returned value is in the range [-Pi, Pi].</source>
          <target state="translated">Phase 返回 x 的相位(也称为参数),返回值的范围是 [-Pi,Pi]。</target>
        </trans-unit>
        <trans-unit id="c62187a44c4849f243c0d01a0cd965d235c59c18" translate="yes" xml:space="preserve">
          <source>Pid returns the process id of the exited process.</source>
          <target state="translated">Pid返回退出的进程的进程ID。</target>
        </trans-unit>
        <trans-unit id="aaf942e54daedd7cb953cee036ee4e01d73e3a05" translate="yes" xml:space="preserve">
          <source>Ping verifies a connection to the database is still alive, establishing a connection if necessary.</source>
          <target state="translated">Ping验证与数据库的连接是否还在,必要时建立连接。</target>
        </trans-unit>
        <trans-unit id="1616a118fdcaf54f337c10d117d16aaa99fd0b14" translate="yes" xml:space="preserve">
          <source>PingContext verifies a connection to the database is still alive, establishing a connection if necessary.</source>
          <target state="translated">PingContext验证与数据库的连接是否仍然有效,必要时建立一个连接。</target>
        </trans-unit>
        <trans-unit id="8c943ad1575fde013a5e267aa7a5a04d105d169b" translate="yes" xml:space="preserve">
          <source>PingContext verifies the connection to the database is still alive.</source>
          <target state="translated">PingContext验证与数据库的连接是否仍然有效。</target>
        </trans-unit>
        <trans-unit id="7a788a1af96c8d9977c69732be97c930615c2f24" translate="yes" xml:space="preserve">
          <source>Pinger is an optional interface that may be implemented by a Conn.</source>
          <target state="translated">Pinger是一个可选的接口,可以由Conn.Pinger实现。</target>
        </trans-unit>
        <trans-unit id="00dae071c082bb73eaed17b4bb3429280e110e8c" translate="yes" xml:space="preserve">
          <source>Pipe</source>
          <target state="translated">Pipe</target>
        </trans-unit>
        <trans-unit id="e40f59609b56b44e5054b6b92f52ff52a16d5fa3" translate="yes" xml:space="preserve">
          <source>Pipe creates a synchronous in-memory pipe. It can be used to connect code expecting an io.Reader with code expecting an io.Writer.</source>
          <target state="translated">Pipe创建了一个同步的内存管道,它可以用来连接期待io.Reader的代码和期待io.Writer的代码。它可以用来连接期待io.Reader的代码和期待io.Writer的代码。</target>
        </trans-unit>
        <trans-unit id="da50f6a47a89e9218a08186e61e447aeaa977683" translate="yes" xml:space="preserve">
          <source>Pipe creates a synchronous, in-memory, full duplex network connection; both ends implement the Conn interface. Reads on one end are matched with writes on the other, copying data directly between the two; there is no internal buffering.</source>
          <target state="translated">Pipe建立一个同步的、内存中的、全双工的网络连接;两端实现Conn接口。一端的读与另一端的写相匹配,直接在两端之间复制数据;没有内部缓冲。</target>
        </trans-unit>
        <trans-unit id="2a31ea2b0e32b3e571d1bceba86196d7bad1fcb8" translate="yes" xml:space="preserve">
          <source>Pipe returns a connected pair of Files; reads from r return bytes written to w. It returns the files and an error, if any.</source>
          <target state="translated">管子返回一对连接的Files;从r中读取返回写入w的字节,如果有的话,它会返回文件和一个错误。</target>
        </trans-unit>
        <trans-unit id="20f3a37d20161b0046bc712fcc1c973a57a664dc" translate="yes" xml:space="preserve">
          <source>PipeNode holds a pipeline with optional declaration</source>
          <target state="translated">PipeNode持有一个管道,并可选择声明。</target>
        </trans-unit>
        <trans-unit id="f28715a2c22fba2d801918b67be067614e3917c8" translate="yes" xml:space="preserve">
          <source>Pipeline, to manage pipelined requests and responses in a client.</source>
          <target state="translated">管道,用于管理客户端中的管道式请求和响应。</target>
        </trans-unit>
        <trans-unit id="c5df1e14fdba13b1a3f9690f736bcb2aac132e72" translate="yes" xml:space="preserve">
          <source>Pipelines</source>
          <target state="translated">Pipelines</target>
        </trans-unit>
        <trans-unit id="06fc1a48588c809599455a2829c6d8c93dab2807" translate="yes" xml:space="preserve">
          <source>PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y).</source>
          <target state="translated">PixOffset返回Pix中对应于(x,y)像素的第一个元素的索引。</target>
        </trans-unit>
        <trans-unit id="bf14eb94c114379d054dbd030d4c5c1a50c1bc82" translate="yes" xml:space="preserve">
          <source>Pkg returns the package to which the object belongs. The result is nil for labels and objects in the Universe scope.</source>
          <target state="translated">Pkg 返回对象所属的包。对于Universe作用域中的标签和对象,结果为零。</target>
        </trans-unit>
        <trans-unit id="6b25672d57f482ab04e1df337de0aebb92458d0d" translate="yes" xml:space="preserve">
          <source>PlainAuth</source>
          <target state="translated">PlainAuth</target>
        </trans-unit>
        <trans-unit id="0e0cce6c4e84e3f28344ac03eb2bbf3c7be04c28" translate="yes" xml:space="preserve">
          <source>PlainAuth returns an Auth that implements the PLAIN authentication mechanism as defined in RFC 4616. The returned Auth uses the given username and password to authenticate to host and act as identity. Usually identity should be the empty string, to act as username.</source>
          <target state="translated">PlainAuth 返回一个实现 RFC 4616 中定义的 PLAIN 认证机制的 Auth。返回的Auth使用给定的用户名和密码来验证主机并作为身份认证。通常identity应该是空字符串,作为用户名。</target>
        </trans-unit>
        <trans-unit id="32488aca0b25b337080ddc28faef0ad97faab0e7" translate="yes" xml:space="preserve">
          <source>PlainAuth will only send the credentials if the connection is using TLS or is connected to localhost. Otherwise authentication will fail with an error, without sending the credentials.</source>
          <target state="translated">只有当连接使用TLS或连接到localhost时,PlainAuth才会发送凭证。否则,验证将以错误的方式失败,而不会发送凭证。</target>
        </trans-unit>
        <trans-unit id="b8996c869faa8282ed1dc0af722f7f384a441369" translate="yes" xml:space="preserve">
          <source>Plan 9</source>
          <target state="translated">计划9</target>
        </trans-unit>
        <trans-unit id="fcc50dd97b375efa9e5795002087751fd071d726" translate="yes" xml:space="preserve">
          <source>Plan9 is a 256-color palette that partitions the 24-bit RGB space into 4&amp;times;4&amp;times;4 subdivision, with 4 shades in each subcube. Compared to the WebSafe, the idea is to reduce the color resolution by dicing the color cube into fewer cells, and to use the extra space to increase the intensity resolution. This results in 16 gray shades (4 gray subcubes with 4 samples in each), 13 shades of each primary and secondary color (3 subcubes with 4 samples plus black) and a reasonable selection of colors covering the rest of the color cube. The advantage is better representation of continuous tones.</source>
          <target state="translated">Plan9是256色调色板，它将24位RGB空间划分为4&amp;times;4&amp;times;4细分，每个子多维数据集中有4个阴影。与WebSafe相比，该想法是通过将彩色立方体切成更少的单元格来降低颜色分辨率，并使用额外的空间来提高强度分辨率。这样就可以得到16个灰色阴影（每个带有4个样本的4个灰色子立方体），每种原色和次要颜色13个阴影（3个带有4个样本加黑色的子立方体）以及覆盖其余颜色立方体的合理颜色选择。优点是可以更好地表示连续色调。</target>
        </trans-unit>
        <trans-unit id="9d8a06b24fa70984798bf322daaec557c2b6f1b4" translate="yes" xml:space="preserve">
          <source>Playable Examples must be in a package whose name ends in &quot;_test&quot;. An Example is &quot;playable&quot; (the Play field is non-nil) in either of these circumstances:</source>
          <target state="translated">可播放的实例必须在一个包中,其名称以&quot;_test &quot;结尾。在这两种情况下,一个例子都是 &quot;可玩的&quot;(Play字段是非nil)。</target>
        </trans-unit>
        <trans-unit id="2c6beabd4a6c27d664359314bb0b7be1a4bee461" translate="yes" xml:space="preserve">
          <source>Plugin is a loaded Go plugin.</source>
          <target state="translated">插件是一个加载中的围棋插件。</target>
        </trans-unit>
        <trans-unit id="7e76b66514ee8b4bc312a760611a574aac64892b" translate="yes" xml:space="preserve">
          <source>PlusBuildLines returns a sequence of &amp;ldquo;// +build&amp;rdquo; lines that evaluate to the build expression x. If the expression is too complex to convert directly to &amp;ldquo;// +build&amp;rdquo; lines, PlusBuildLines returns an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79d975c909286257ed2dc841463cf2221331b8a7" translate="yes" xml:space="preserve">
          <source>Pointer represents a pointer to an arbitrary type. There are four special operations available for type Pointer that are not available for other types:</source>
          <target state="translated">Pointer表示一个指向任意类型的指针。对于Pointer类型,有四种特殊的操作是其他类型所没有的。</target>
        </trans-unit>
        <trans-unit id="c0c031e92d2b285f06539e450cbc88db48ddddac" translate="yes" xml:space="preserve">
          <source>Pointer returns v's value as a uintptr. It returns uintptr instead of unsafe.Pointer so that code using reflect cannot obtain unsafe.Pointers without importing the unsafe package explicitly. It panics if v's Kind is not Chan, Func, Map, Ptr, Slice, or UnsafePointer.</source>
          <target state="translated">Pointer以uintptr的形式返回v的值。它返回的是uintptr而不是unsafe.Pointer,因此使用reflect的代码在没有显式导入unsafe包的情况下无法获得unsafe.Pointers。如果v的Kind不是Chan、Func、Map、Ptr、Slice或UnsafePointer,它就会恐慌。</target>
        </trans-unit>
        <trans-unit id="baef0ef34fa58ab846963eb42f08d22cc0916958" translate="yes" xml:space="preserve">
          <source>Pointer therefore allows a program to defeat the type system and read and write arbitrary memory. It should be used with extreme care.</source>
          <target state="translated">因此,指针允许程序击败类型系统,读写任意内存。使用它时应格外小心。</target>
        </trans-unit>
        <trans-unit id="c228a838e9e7815109b6016259a9375cc32a3ee5" translate="yes" xml:space="preserve">
          <source>Pointer values are deeply equal if they are equal using Go's == operator or if they point to deeply equal values.</source>
          <target state="translated">如果使用围棋的==运算符使指针值相等,或者它们指向的是深层相等的值,那么指针值就是深层相等的。</target>
        </trans-unit>
        <trans-unit id="ab46185459d2a7d78c59879c795ee53dd26dd358" translate="yes" xml:space="preserve">
          <source>Pointer values encode as the value pointed to. A nil pointer encodes as the null JSON value.</source>
          <target state="translated">指针值编码为所指向的值。nil指针编码为空JSON值。</target>
        </trans-unit>
        <trans-unit id="d2cde07b059e3c084c9da753efae9fdd148fa375" translate="yes" xml:space="preserve">
          <source>Pointer:</source>
          <target state="translated">Pointer:</target>
        </trans-unit>
        <trans-unit id="b64fba6378c386a82e71d5a623e279c432da4e08" translate="yes" xml:space="preserve">
          <source>Polar</source>
          <target state="translated">Polar</target>
        </trans-unit>
        <trans-unit id="a5fb429c2bb667a352c2046e02293fc421f8310b" translate="yes" xml:space="preserve">
          <source>Polar returns the absolute value r and phase &amp;theta; of x, such that x = r * e**&amp;theta;i. The phase is in the range [-Pi, Pi].</source>
          <target state="translated">Polar返回x的绝对值r和相位&amp;theta;，从而x = r * e **&amp;theta;i。相位在[-Pi，Pi]范围内。</target>
        </trans-unit>
        <trans-unit id="8e6bda38a58104dfd742e2b251475f4fc7ad35e0" translate="yes" xml:space="preserve">
          <source>Polynomials are represented in LSB-first form also known as reversed representation.</source>
          <target state="translated">多项式用LSB优先的形式表示,也称为反向表示。</target>
        </trans-unit>
        <trans-unit id="778627418cb4b30cdfe47281afdbf30f1a173700" translate="yes" xml:space="preserve">
          <source>Pool</source>
          <target state="translated">Pool</target>
        </trans-unit>
        <trans-unit id="62976d6c6dce665baf19823706626b87a619028b" translate="yes" xml:space="preserve">
          <source>Pool's purpose is to cache allocated but unused items for later reuse, relieving pressure on the garbage collector. That is, it makes it easy to build efficient, thread-safe free lists. However, it is not suitable for all free lists.</source>
          <target state="translated">Pool的目的是缓存已分配但未使用的项目,以便以后重复使用,减轻垃圾收集器的压力。也就是说,它可以轻松构建高效、线程安全的自由列表。但是,它并不适合所有的自由列表。</target>
        </trans-unit>
        <trans-unit id="a894961424546348d9d455a430167c6470d0b453" translate="yes" xml:space="preserve">
          <source>Pop removes and returns the minimum element (according to Less) from the heap. The complexity is O(log n) where n = h.Len(). Pop is equivalent to Remove(h, 0).</source>
          <target state="translated">Pop从堆中移除并返回最小元素(根据Less)。复杂度为O(log n),其中n=h.Len()。Pop相当于Remove(h,0)。</target>
        </trans-unit>
        <trans-unit id="1c331ce3bd04c4d21d66fc2ae1a5de46dd73eec8" translate="yes" xml:space="preserve">
          <source>Port returns the port part of u.Host, without the leading colon.</source>
          <target state="translated">Port 返回 u.Host 的端口部分,不含前导冒号。</target>
        </trans-unit>
        <trans-unit id="42cb37e41618d46d1d0e8d0bf5e059552b858cb3" translate="yes" xml:space="preserve">
          <source>Portable analogs of some common system call errors.</source>
          <target state="translated">一些常见系统调用错误的便携式类比。</target>
        </trans-unit>
        <trans-unit id="97e4fd0d08cb7c58f4698b53bcfb9441c857ebec" translate="yes" xml:space="preserve">
          <source>Pos and End describe the scope's source code extent [pos, end). The results are guaranteed to be valid only if the type-checked AST has complete position information. The extent is undefined for Universe and package scopes.</source>
          <target state="translated">pos和End描述了作用域的源代码范围[pos,end)。只有当经过类型检查的AST有完整的位置信息时,才能保证结果是有效的。对于Universe和包的作用域,这个范围是未定义的。</target>
        </trans-unit>
        <trans-unit id="4c60ba97a8cb410a549bfe181eeaa63408b55cba" translate="yes" xml:space="preserve">
          <source>Pos computes the source position of the declaration of an object name. The result may be an invalid position if it cannot be computed (obj.Decl may be nil or not correct).</source>
          <target state="translated">Pos计算一个对象名声明的源位置,如果不能计算,结果可能是无效的(obj.Decl可能为nil或不正确)。如果不能计算,结果可能是一个无效的位置(obj.Decl可能是nil或不正确)。</target>
        </trans-unit>
        <trans-unit id="a0ec3702b899c2917ee8242be4cbe0bff05b9658" translate="yes" xml:space="preserve">
          <source>Pos is a compact encoding of a source position within a file set. It can be converted into a Position for a more convenient, but much larger, representation.</source>
          <target state="translated">Pos 是一个文件集内源位置的紧凑编码。它可以转换为Position,以便更方便,但更大的表示。</target>
        </trans-unit>
        <trans-unit id="1b9fa7b2eba24dae9008da03956b9fa4fe5bac8a" translate="yes" xml:space="preserve">
          <source>Pos represents a byte position in the original input text from which this template was parsed.</source>
          <target state="translated">Pos代表原始输入文本中的一个字节位置,该模板是从该文本中解析出来的。</target>
        </trans-unit>
        <trans-unit id="edf92f1280756c43fc75532da3d73537cdede740" translate="yes" xml:space="preserve">
          <source>Pos returns the Pos value for the given file offset; the offset must be &amp;lt;= f.Size(). f.Pos(f.Offset(p)) == p.</source>
          <target state="translated">Pos返回给定文件偏移量的Pos值；偏移量必须小于等于f.Size（）。f.Pos（f.Offset（p））== p。</target>
        </trans-unit>
        <trans-unit id="5ff010dde5f69bdb9f99370ef921975c8f9209ff" translate="yes" xml:space="preserve">
          <source>Pos returns the declaration position of the object's identifier.</source>
          <target state="translated">Pos返回对象标识符的声明位置。</target>
        </trans-unit>
        <trans-unit id="cd367287d957f8b0726b9d88a222f0d52b30fd66" translate="yes" xml:space="preserve">
          <source>Pos returns the position of the character immediately after the character or token returned by the last call to Next or Scan. Use the Scanner's Position field for the start position of the most recently scanned token.</source>
          <target state="translated">Pos 返回紧接上一次调用 Next 或 Scan 返回的字符或标记之后的字符位置。使用扫描器的位置字段表示最近扫描的标记的起始位置。</target>
        </trans-unit>
        <trans-unit id="e31be0876f71b9f08f689f98e0ab92c2ffe225b9" translate="yes" xml:space="preserve">
          <source>Pos values can be compared directly with the usual comparison operators: If two Pos values p and q are in the same file, comparing p and q is equivalent to comparing the respective source file offsets. If p and q are in different files, p &amp;lt; q is true if the file implied by p was added to the respective file set before the file implied by q.</source>
          <target state="translated">Pos值可以直接与常规比较运算符进行比较：如果两个Pos值p和q在同一文件中，则比较p和q等效于比较各自的源文件偏移量。如果p和q位于不同的文件中，则如果p隐含的文件被添加到q隐含的文件之前的相应文件集中，则p &amp;lt;q为true。</target>
        </trans-unit>
        <trans-unit id="5fc2fa994bbd914263ceb34efcf25eb956fe5e38" translate="yes" xml:space="preserve">
          <source>Position converts a Pos p in the fileset into a Position value. Calling s.Position(p) is equivalent to calling s.PositionFor(p, true).</source>
          <target state="translated">Position 将 fileset 中的 Pos p 转换为 Position 值。调用 s.Position(p)等同于调用 s.PositionFor(p,true)。</target>
        </trans-unit>
        <trans-unit id="b93209a85028bf6019382a8729f55ac8145e29b1" translate="yes" xml:space="preserve">
          <source>Position describes an arbitrary source position including the file, line, and column location. A Position is valid if the line number is &amp;gt; 0.</source>
          <target state="translated">位置描述任意源位置，包括文件，行和列的位置。如果行号&amp;gt; 0，则&amp;ldquo;位置&amp;rdquo;有效。</target>
        </trans-unit>
        <trans-unit id="d1086db7e34e995911902270435427be7e528699" translate="yes" xml:space="preserve">
          <source>Position returns the Position value for the given file position p. Calling f.Position(p) is equivalent to calling f.PositionFor(p, true).</source>
          <target state="translated">调用f.Position(p)相当于调用f.PositionFor(p,true)。</target>
        </trans-unit>
        <trans-unit id="9bee67f02828c19ef6ab2c5867d78daacd16a5b6" translate="yes" xml:space="preserve">
          <source>PositionFor converts a Pos p in the fileset into a Position value. If adjusted is set, the position may be adjusted by position-altering //line comments; otherwise those comments are ignored. p must be a Pos value in s or NoPos.</source>
          <target state="translated">PositionFor 将文件集中的 Pos p 转换为 Position 值。如果设置了adjusted,位置可以通过位置改变的//行注释来调整,否则这些注释将被忽略。p必须是s或NoPos中的Pos值。</target>
        </trans-unit>
        <trans-unit id="3d4ffd5f491d5a7cdece709329d95542f519d748" translate="yes" xml:space="preserve">
          <source>PositionFor returns the Position value for the given file position p. If adjusted is set, the position may be adjusted by position-altering //line comments; otherwise those comments are ignored. p must be a Pos value in f or NoPos.</source>
          <target state="translated">PositionFor返回给定文件位置p的位置值,如果设置了adjusted,则可以通过改变位置的//行注释来调整位置,否则这些注释将被忽略。p必须是f或NoPos中的Pos值。</target>
        </trans-unit>
        <trans-unit id="9ac52c588d2d22788d46da883fda78a4165f3071" translate="yes" xml:space="preserve">
          <source>Possible values for the EncryptPEMBlock encryption algorithm.</source>
          <target state="translated">EncryptPEMBlock加密算法的可能值。</target>
        </trans-unit>
        <trans-unit id="e039b08aed18ef386a63d77f040148c0406ea827" translate="yes" xml:space="preserve">
          <source>Post is a wrapper around DefaultClient.Post.</source>
          <target state="translated">Post是DefaultClient.Post的封装器。</target>
        </trans-unit>
        <trans-unit id="4ccc94f360bffe8b14b21c70371bc08f8fc85aba" translate="yes" xml:space="preserve">
          <source>Post issues a POST to the specified URL.</source>
          <target state="translated">Post向指定的URL发出POST。</target>
        </trans-unit>
        <trans-unit id="cf67d20c1f3d564f229d45c7bbe51d8dd1d5c4f9" translate="yes" xml:space="preserve">
          <source>PostForm is a wrapper around DefaultClient.PostForm.</source>
          <target state="translated">PostForm是DefaultClient.PostForm的封装器。</target>
        </trans-unit>
        <trans-unit id="44be7db278a3bb23e34b6df9cf0308f04a22ef65" translate="yes" xml:space="preserve">
          <source>PostForm issues a POST to the specified URL, with data's keys and values URL-encoded as the request body.</source>
          <target state="translated">PostForm向指定的URL发出一个POST,数据的键和值的URL编码作为请求体。</target>
        </trans-unit>
        <trans-unit id="be4e82ca926447e7fa579fe9a0de6822470bae52" translate="yes" xml:space="preserve">
          <source>PostFormValue returns the first value for the named component of the POST, PATCH, or PUT request body. URL query parameters are ignored. PostFormValue calls ParseMultipartForm and ParseForm if necessary and ignores any errors returned by these functions. If key is not present, PostFormValue returns the empty string.</source>
          <target state="translated">PostFormValue返回POST、PATCH或PUT请求体中命名组件的第一个值。URL查询参数会被忽略。PostFormValue在必要时调用ParseMultipartForm和ParseForm,并忽略这些函数返回的任何错误。如果key不存在,PostFormValue将返回空字符串。</target>
        </trans-unit>
        <trans-unit id="be28cb761efe315e0e552f0578874dbad93fb2dd" translate="yes" xml:space="preserve">
          <source>Pow</source>
          <target state="translated">Pow</target>
        </trans-unit>
        <trans-unit id="f475da806450b4216a6a39ef8f751e26584a0aa3" translate="yes" xml:space="preserve">
          <source>Pow returns x**y, the base-x exponential of y.</source>
          <target state="translated">Pow返回x**y,即y的基x指数。</target>
        </trans-unit>
        <trans-unit id="6d31ee5908c32da0243ccfa92f5fe1c7b3e3aeaf" translate="yes" xml:space="preserve">
          <source>Pow returns x**y, the base-x exponential of y. For generalized compatibility with math.Pow:</source>
          <target state="translated">Pow返回x**y,即y的基数-x指数,与math.Pow.Pow通用。</target>
        </trans-unit>
        <trans-unit id="f348c46b140ea99d08517640a0cfa8eff3f40986" translate="yes" xml:space="preserve">
          <source>Pow10</source>
          <target state="translated">Pow10</target>
        </trans-unit>
        <trans-unit id="aee903bac5380775ed6f4d539640fd38f8839815" translate="yes" xml:space="preserve">
          <source>Pow10 returns 10**n, the base-10 exponential of n.</source>
          <target state="translated">Pow10返回10**n,n的基数10指数。</target>
        </trans-unit>
        <trans-unit id="5411be6b25a0cd127e0815f04ee1c12c71a3cf9d" translate="yes" xml:space="preserve">
          <source>Prec returns the mantissa precision of x in bits. The result may be 0 for |x| == 0 and |x| == Inf.</source>
          <target state="translated">Prec 返回 x 的位数精度。对于|x| ==0和|x| ==Inf,结果可能是0。</target>
        </trans-unit>
        <trans-unit id="012c1f9cb43bafa38c87d810c24d42b2a0e95129" translate="yes" xml:space="preserve">
          <source>Precedence returns the operator precedence of the binary operator op. If op is not a binary operator, the result is LowestPrecedence.</source>
          <target state="translated">Precedence 返回二进制运算符 op 的运算符优先级。如果运算符op不是二进制运算符,那么结果是LowestPrecedence。</target>
        </trans-unit>
        <trans-unit id="06b7f0534bb083dff059cb7b1d374b3c3f1e0a29" translate="yes" xml:space="preserve">
          <source>Precompute performs some calculations that speed up private key operations in the future.</source>
          <target state="translated">预计算会进行一些计算,加快未来私钥操作的速度。</target>
        </trans-unit>
        <trans-unit id="34240aca8e0c8b909225cdb2f4dfdd60a5391649" translate="yes" xml:space="preserve">
          <source>Precondition: the Uses and Defs maps are populated.</source>
          <target state="translated">前提:Uses和Defs地图已被填充。</target>
        </trans-unit>
        <trans-unit id="7070c5f6250bbd470fe7f73bafbee45d2955ddb3" translate="yes" xml:space="preserve">
          <source>Predefined global functions are named as follows.</source>
          <target state="translated">预定义的全局函数命名如下:</target>
        </trans-unit>
        <trans-unit id="e21e54618fe5bb45663e64ef56fb6717d24f3e6f" translate="yes" xml:space="preserve">
          <source>Predefined layouts ANSIC, UnixDate, RFC3339 and others describe standard and convenient representations of the reference time. For more information about the formats and the definition of the reference time, see the documentation for ANSIC and the other constants defined by this package.</source>
          <target state="translated">预定义的布局ANSIC、UnixDate、RFC3339等描述了参考时间的标准和方便的表示方式。关于参考时间的格式和定义的更多信息,请参见ANSIC和本软件包定义的其他常量的文档。</target>
        </trans-unit>
        <trans-unit id="19d40016f56bfc80ec50dda03a3f66d54afe65d3" translate="yes" xml:space="preserve">
          <source>Predefined layouts ANSIC, UnixDate, RFC3339 and others describe standard and convenient representations of the reference time. For more information about the formats and the definition of the reference time, see the documentation for ANSIC and the other constants defined by this package. Also, the executable example for Time.Format demonstrates the working of the layout string in detail and is a good reference.</source>
          <target state="translated">预定义的布局ANSIC、UnixDate、RFC3339等描述了参考时间的标准和方便的表示方式。有关格式和参考时间定义的更多信息,请参见ANSIC和本包定义的其他常量的文档。另外,Time.Format的可执行示例详细演示了布局字符串的工作原理,是一个很好的参考。</target>
        </trans-unit>
        <trans-unit id="019d3598b39c078722d988d313bff8da4d9cf574" translate="yes" xml:space="preserve">
          <source>Predefined mode bits to control recognition of tokens. For instance, to configure a Scanner such that it only recognizes (Go) identifiers, integers, and skips comments, set the Scanner's Mode field to:</source>
          <target state="translated">预定义的模式位,用于控制标记的识别。例如,要将扫描仪配置为只识别(Go)标识符、整数并跳过注释,请将扫描仪的模式字段设置为:。</target>
        </trans-unit>
        <trans-unit id="0eea29821ab0f93a1960c9475350fbefcdab3d2f" translate="yes" xml:space="preserve">
          <source>Predefined polynomials.</source>
          <target state="translated">预定义多项式。</target>
        </trans-unit>
        <trans-unit id="0d4a9c1b8dc6a14ced81402c9c52d4cba69192f5" translate="yes" xml:space="preserve">
          <source>Prefix returns a literal string that all matches for the regexp must start with. Complete is true if the prefix is the entire match.</source>
          <target state="translated">Prefix 返回一个字面字符串,所有匹配的regexp都必须以这个字符串开始。如果前缀是整个匹配项,则Complete为true。</target>
        </trans-unit>
        <trans-unit id="07aedbb616a135989fac4d8d72b5c4a5c5d60c82" translate="yes" xml:space="preserve">
          <source>Prefix returns the output prefix for the logger.</source>
          <target state="translated">Prefix 返回记录仪的输出前缀。</target>
        </trans-unit>
        <trans-unit id="d115a4bd5d23f67905e010343d63485a225c3e87" translate="yes" xml:space="preserve">
          <source>Prefix returns the output prefix for the standard logger.</source>
          <target state="translated">Prefix 返回标准记录器的输出前缀。</target>
        </trans-unit>
        <trans-unit id="8a0ad1efe973aa121d35889249f93a7d412bb0f0" translate="yes" xml:space="preserve">
          <source>Prepare creates a prepared statement for later queries or executions. Multiple queries or executions may be run concurrently from the returned statement. The caller must call the statement's Close method when the statement is no longer needed.</source>
          <target state="translated">Prepare为以后的查询或执行创建一个准备好的语句。可以从返回的语句中同时运行多个查询或执行。当不再需要该语句时,调用者必须调用语句的关闭方法。</target>
        </trans-unit>
        <trans-unit id="a2f69751c5da712872417f2a510b17bd5264a134" translate="yes" xml:space="preserve">
          <source>Prepare creates a prepared statement for use within a transaction.</source>
          <target state="translated">Prepare 创建一个准备好的报表,供交易中使用。</target>
        </trans-unit>
        <trans-unit id="19c3c9a0f98a28102c0e736d9c3bf4d64087898f" translate="yes" xml:space="preserve">
          <source>PrepareContext creates a prepared statement for later queries or executions. Multiple queries or executions may be run concurrently from the returned statement. The caller must call the statement's Close method when the statement is no longer needed.</source>
          <target state="translated">PrepareContext为以后的查询或执行创建一个准备好的语句。可以从返回的语句中并发运行多个查询或执行。当不再需要该语句时,调用者必须调用语句的Close方法。</target>
        </trans-unit>
        <trans-unit id="a6597b9664b9651bf9f54fe07c6db1a86396a5f0" translate="yes" xml:space="preserve">
          <source>PrepareContext creates a prepared statement for use within a transaction.</source>
          <target state="translated">PrepareContext创建了一个准备好的语句,供在事务中使用。</target>
        </trans-unit>
        <trans-unit id="152856201f7dfb04864788231e3dca46c0bc77c0" translate="yes" xml:space="preserve">
          <source>Prev returns the previous list element or nil.</source>
          <target state="translated">Prev 返回上一个列表元素或nil。</target>
        </trans-unit>
        <trans-unit id="c4d145ba4ec6ded69ec8461fe1ea7b2b7ec58ca2" translate="yes" xml:space="preserve">
          <source>Prev returns the previous ring element. r must not be empty.</source>
          <target state="translated">Prev 返回上一个环元素,r不能为空。</target>
        </trans-unit>
        <trans-unit id="88971ab7b2fead8d5aa7c50c15f575453db641e4" translate="yes" xml:space="preserve">
          <source>Prime returns a number, p, of the given size, such that p is prime with high probability. Prime will return error for any error returned by rand.Read or if bits &amp;lt; 2.</source>
          <target state="translated">素数返回给定大小的数字p，因此p是极有可能的素数。如果rand.Read返回的任何错误或位&amp;lt;2，Prime将返回错误。</target>
        </trans-unit>
        <trans-unit id="5b221e9c2a451799d8f37e2b9874409d5e03ab05" translate="yes" xml:space="preserve">
          <source>Print</source>
          <target state="translated">Print</target>
        </trans-unit>
        <trans-unit id="f10e9ffa0b7bfc2f4378fe30b103cef0c696cbab" translate="yes" xml:space="preserve">
          <source>Print calls Output to print to the standard logger. Arguments are handled in the manner of fmt.Print.</source>
          <target state="translated">Print调用Output打印到标准记录器。参数的处理方式与fmt.Print相同。</target>
        </trans-unit>
        <trans-unit id="da7a32afaab2e92c2ad95514fe5016080d044d92" translate="yes" xml:space="preserve">
          <source>Print calls l.Output to print to the logger. Arguments are handled in the manner of fmt.Print.</source>
          <target state="translated">Print调用l.Output打印到记录仪。参数的处理方式与fmt.Print相同。</target>
        </trans-unit>
        <trans-unit id="ef0199bdcf8fc8fa33bd7d6ab92875f9706a01bd" translate="yes" xml:space="preserve">
          <source>Print formats using the default formats for its operands and writes to standard output. Spaces are added between operands when neither is a string. It returns the number of bytes written and any write error encountered.</source>
          <target state="translated">使用操作数的默认格式打印格式,并写入标准输出。当操作数都不是字符串时,操作数之间会添加空格。它返回写入的字节数和遇到的任何写入错误。</target>
        </trans-unit>
        <trans-unit id="5d837aa33f1404ff26202e67efb03427b1d31566" translate="yes" xml:space="preserve">
          <source>Print prints x to standard output, skipping nil fields. Print(fset, x) is the same as Fprint(os.Stdout, fset, x, NotNilFilter).</source>
          <target state="translated">Print 将 x 打印到标准输出,跳过 nil 字段。Print(fset,x)和 Fprint(os.Stdout,fset,x,NotNilFilter)是一样的。</target>
        </trans-unit>
        <trans-unit id="fff8914dcd8a6ac6b5cf34d89aeea00386da1b24" translate="yes" xml:space="preserve">
          <source>Print, Println, and Printf lay out their arguments differently. In this example we can compare their behaviors. Println always adds blanks between the items it prints, while Print adds blanks only between non-string arguments and Printf does exactly what it is told. Sprint, Sprintln, Sprintf, Fprint, Fprintln, and Fprintf behave the same as their corresponding Print, Println, and Printf functions shown here.</source>
          <target state="translated">Print、Println和Printf的参数布局不同。在这个例子中,我们可以比较它们的行为。Println总是在打印的项目之间添加空白,而Print只在非字符串参数之间添加空白,Printf则完全按照命令行事。Sprint、Sprintln、Sprintf、Fprint、Fprintln和Fprintf的行为和它们对应的Print、Println和Printf函数的行为一样。</target>
        </trans-unit>
        <trans-unit id="809bcd004fc9b80aebb7cc5d33f0d171da74d5a1" translate="yes" xml:space="preserve">
          <source>PrintDefaults prints, to standard error unless configured otherwise, a usage message showing the default settings of all defined command-line flags. For an integer valued flag x, the default output has the form</source>
          <target state="translated">PrintDefaults以标准的错误方式打印,除非另有配置,否则打印出一条使用信息,显示所有定义的命令行标志的默认设置。对于一个整数值的标志x,默认的输出形式为</target>
        </trans-unit>
        <trans-unit id="66f194d8340d19b81ae4cbbaf04b180769f0bc50" translate="yes" xml:space="preserve">
          <source>PrintDefaults prints, to standard error unless configured otherwise, the default values of all defined command-line flags in the set. See the documentation for the global function PrintDefaults for more information.</source>
          <target state="translated">除非另有配置,否则PrintDefaults会以标准错误打印出集合中所有定义的命令行标志的默认值。更多信息请参见全局函数PrintDefaults的文档。</target>
        </trans-unit>
        <trans-unit id="0413304ebeab6806f19cc2877f7f0a8ff6c54cbc" translate="yes" xml:space="preserve">
          <source>PrintError is a utility function that prints a list of errors to w, one error per line, if the err parameter is an ErrorList. Otherwise it prints the err string.</source>
          <target state="translated">PrintError是一个实用函数,如果err参数是ErrorList,则打印错误列表到w,每行一个错误。否则会打印出err字符串。</target>
        </trans-unit>
        <trans-unit id="ebb2a34b39577c89ac6bbac4cad20176461fcd0b" translate="yes" xml:space="preserve">
          <source>PrintRanges defines the set of printable characters according to Go. ASCII space, U+0020, is handled separately.</source>
          <target state="translated">PrintRanges根据围棋定义了可打印字符集。ASCII空间,U+0020,单独处理。</target>
        </trans-unit>
        <trans-unit id="e979fdd38cfa18a2850ab6725519f82f13a4893f" translate="yes" xml:space="preserve">
          <source>PrintStack prints to standard error the stack trace returned by runtime.Stack.</source>
          <target state="translated">PrintStack将runtime.Stack.Runtime.Stack返回的堆栈跟踪打印成标准错误。</target>
        </trans-unit>
        <trans-unit id="49c6710eb43a270c0d99f60d369594f6b1f09d42" translate="yes" xml:space="preserve">
          <source>Printf</source>
          <target state="translated">Printf</target>
        </trans-unit>
        <trans-unit id="d092eac8d8c7315f01318a4675b38dcda90f6b2f" translate="yes" xml:space="preserve">
          <source>Printf calls Output to print to the standard logger. Arguments are handled in the manner of fmt.Printf.</source>
          <target state="translated">Printf调用Output打印到标准记录器。参数的处理方式与fmt.Printf相同。</target>
        </trans-unit>
        <trans-unit id="d34579b37294eb8c93cd5f76572f924816678d0e" translate="yes" xml:space="preserve">
          <source>Printf calls l.Output to print to the logger. Arguments are handled in the manner of fmt.Printf.</source>
          <target state="translated">Printf调用l.Output打印到记录仪。参数的处理方式与fmt.Printf相同。</target>
        </trans-unit>
        <trans-unit id="e063c30289e6b7981e882f4697ef852c1f482795" translate="yes" xml:space="preserve">
          <source>Printf formats according to a format specifier and writes to standard output. It returns the number of bytes written and any write error encountered.</source>
          <target state="translated">Printf根据格式指定器格式化并写入标准输出。它返回写入的字节数和遇到的任何写入错误。</target>
        </trans-unit>
        <trans-unit id="28fa9c40e9ffd74bb5b4f094116329456de9f692" translate="yes" xml:space="preserve">
          <source>PrintfLine writes the formatted output followed by \r\n.</source>
          <target state="translated">PrintfLine将格式化的输出写在后面。</target>
        </trans-unit>
        <trans-unit id="f16eadab2a72ff13044cc806dbcf2c117b32244f" translate="yes" xml:space="preserve">
          <source>Printing</source>
          <target state="translated">Printing</target>
        </trans-unit>
        <trans-unit id="9be957a1debff697aafdc7801a3e8785262f0c15" translate="yes" xml:space="preserve">
          <source>Println</source>
          <target state="translated">Println</target>
        </trans-unit>
        <trans-unit id="29f11f56c6deffe1a15f67edc9a4aa4f5e39f28b" translate="yes" xml:space="preserve">
          <source>Println calls Output to print to the standard logger. Arguments are handled in the manner of fmt.Println.</source>
          <target state="translated">Println调用Output打印到标准记录器。参数的处理方式与fmt.Println相同。</target>
        </trans-unit>
        <trans-unit id="cddfe7aeafd7792bfbbf9d5f8715705f967fa901" translate="yes" xml:space="preserve">
          <source>Println calls l.Output to print to the logger. Arguments are handled in the manner of fmt.Println.</source>
          <target state="translated">Println调用l.Output打印到记录器。参数的处理方式与fmt.Println相同。</target>
        </trans-unit>
        <trans-unit id="811e4464a94616bb8d26e71f2e575488ec162b1d" translate="yes" xml:space="preserve">
          <source>Println formats using the default formats for its operands and writes to standard output. Spaces are always added between operands and a newline is appended. It returns the number of bytes written and any write error encountered.</source>
          <target state="translated">Println使用默认的操作数格式进行格式化,并写入标准输出。操作数之间总是添加空格,并附加一个换行。它返回写入的字节数和遇到的任何写入错误。</target>
        </trans-unit>
        <trans-unit id="ca8881cd0811d2e92d6c86ae2702d8e81b20152f" translate="yes" xml:space="preserve">
          <source>PrivateKey is the type of Ed25519 private keys. It implements crypto.Signer.</source>
          <target state="translated">PrivateKey是Ed25519私钥的类型。它实现了crypto.Signer。</target>
        </trans-unit>
        <trans-unit id="0a4394946d56678a7614480ff518a3bad620dfd6" translate="yes" xml:space="preserve">
          <source>PrivateKey represents a DSA private key.</source>
          <target state="translated">PrivateKey表示一个DSA私钥。</target>
        </trans-unit>
        <trans-unit id="5828291a45f65d96ddf669061359c25c2c15c6d0" translate="yes" xml:space="preserve">
          <source>PrivateKey represents a private key using an unspecified algorithm.</source>
          <target state="translated">PrivateKey表示使用未指定算法的私钥。</target>
        </trans-unit>
        <trans-unit id="6a98b6c2702640d21b9c48b8d270c3e30325339a" translate="yes" xml:space="preserve">
          <source>PrivateKey represents an ECDSA private key.</source>
          <target state="translated">PrivateKey表示ECDSA私钥。</target>
        </trans-unit>
        <trans-unit id="5d801231cb01d152413f0eb3fd1b96b8b8b32f86" translate="yes" xml:space="preserve">
          <source>ProbablyPrime is 100% accurate for inputs less than 2⁶⁴. See Menezes et al., Handbook of Applied Cryptography, 1997, pp. 145-149, and FIPS 186-4 Appendix F for further discussion of the error probabilities.</source>
          <target state="translated">ProbablyPrime对于小于2⁶⁴的输入是100%准确的。参见Menezes等人,Handbook of Applied Cryptography,1997,第145-149页,以及FIPS 186-4附录F对错误概率的进一步讨论。</target>
        </trans-unit>
        <trans-unit id="442fffca41b5ff8be9e7d3c5a0d5bb3bcdd79c79" translate="yes" xml:space="preserve">
          <source>ProbablyPrime is not suitable for judging primes that an adversary may have crafted to fool the test.</source>
          <target state="translated">ProbablyPrime不适合判断对手可能精心制作的primes来骗取测试。</target>
        </trans-unit>
        <trans-unit id="c5acf5649dd4748b450f268e217b8fc03d7e5d83" translate="yes" xml:space="preserve">
          <source>ProbablyPrime reports whether x is probably prime, applying the Miller-Rabin test with n pseudorandomly chosen bases as well as a Baillie-PSW test.</source>
          <target state="translated">ProbablyPrime报告x是否可能是质数,应用Miller-Rabin测试与n个伪随机选择的碱基以及Baillie-PSW测试。</target>
        </trans-unit>
        <trans-unit id="f565348ea6c07ff9cfffba23f4ddef524854d6c5" translate="yes" xml:space="preserve">
          <source>ProcAttr holds attributes that will be applied to a new process started by StartProcess.</source>
          <target state="translated">ProcAttr持有应用于StartProcess启动的新进程的属性。</target>
        </trans-unit>
        <trans-unit id="e12810a35fd4b52423e92a433b314e79f5156c70" translate="yes" xml:space="preserve">
          <source>ProcAttr holds the attributes that will be applied to a new process started by StartProcess.</source>
          <target state="translated">ProcAttr持有将应用于StartProcess启动的新进程的属性。</target>
        </trans-unit>
        <trans-unit id="5373df2ffeb91866eef2c38e2502d77f1e33d970" translate="yes" xml:space="preserve">
          <source>Process stores the information about a process created by StartProcess.</source>
          <target state="translated">Process存储了StartProcess创建的进程的信息。</target>
        </trans-unit>
        <trans-unit id="7be9488d8073639c8b5c8f975d63715a76c9482d" translate="yes" xml:space="preserve">
          <source>ProcessEnv returns FastCGI environment variables associated with the request r for which no effort was made to be included in the request itself - the data is hidden in the request's context. As an example, if REMOTE_USER is set for a request, it will not be found anywhere in r, but it will be included in ProcessEnv's response (via r's context).</source>
          <target state="translated">ProcessEnv返回与请求r相关联的FastCGI环境变量,这些变量没有被努力包含在请求本身中--数据被隐藏在请求的上下文中。举个例子,如果为请求设置了REMOTE_USER,那么在r中任何地方都找不到它,但它会被包含在ProcessEnv的响应中(通过r的上下文)。</target>
        </trans-unit>
        <trans-unit id="9471e4ecfd3d8f84d8e198229a6e563cc60bb5bd" translate="yes" xml:space="preserve">
          <source>ProcessState stores information about a process, as reported by Wait.</source>
          <target state="translated">ProcessState存储了一个进程的信息,由Wait报告。</target>
        </trans-unit>
        <trans-unit id="1ccb21389489c4ce498c4e53d4d69158c5c216b7" translate="yes" xml:space="preserve">
          <source>Profile responds with the pprof-formatted cpu profile. Profiling lasts for duration specified in seconds GET parameter, or for 30 seconds if not specified. The package initialization registers it as /debug/pprof/profile.</source>
          <target state="translated">配置文件以pprof格式化的cpu配置文件响应。配置文件的持续时间用GET参数secondes指定,如果没有指定,则持续30秒。软件包初始化将其注册为/debug/pprof/profile。</target>
        </trans-unit>
        <trans-unit id="a111deba4cb386ad7d27a3a5da110f46f90e53f3" translate="yes" xml:space="preserve">
          <source>Profiles are only as good as the kernel support used to generate them. See &lt;a href=&quot;https://golang.org/issue/13841&quot;&gt;https://golang.org/issue/13841&lt;/a&gt; for details about known problems.</source>
          <target state="translated">概要文件仅与用于生成概要文件的内核支持一样好。有关已知问题的详细信息，请参见&lt;a href=&quot;https://golang.org/issue/13841&quot;&gt;https://golang.org/issue/13841&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f633a064ff1568b947a4aec717cb8ff7b8d5f4c3" translate="yes" xml:space="preserve">
          <source>Profiles can then be visualized with the pprof tool:</source>
          <target state="translated">然后,可以使用pprof工具对配置文件进行可视化。</target>
        </trans-unit>
        <trans-unit id="f43cf39e026d58fac3cfa9c9d78bd864d77127ed" translate="yes" xml:space="preserve">
          <source>Profiles returns a slice of all the known profiles, sorted by name.</source>
          <target state="translated">Profiles(配置文件)返回按名称排序的所有已知配置文件的片断。</target>
        </trans-unit>
        <trans-unit id="e204c80d31036e0e024c0b7ffd8999a887af815c" translate="yes" xml:space="preserve">
          <source>Profiling a Go program</source>
          <target state="translated">剖析一个围棋程序</target>
        </trans-unit>
        <trans-unit id="cd24f23a82cfebc48d38726d6b4c3ec7db051af8" translate="yes" xml:space="preserve">
          <source>Prog.Flag</source>
          <target state="translated">Prog.Flag</target>
        </trans-unit>
        <trans-unit id="48f3611555518363414a9b1db2fa49f474f76e67" translate="yes" xml:space="preserve">
          <source>Prog.Type</source>
          <target state="translated">Prog.Type</target>
        </trans-unit>
        <trans-unit id="2301ced48f29c8456865c04cd47334c707828d9b" translate="yes" xml:space="preserve">
          <source>Programs that use Contexts should follow these rules to keep interfaces consistent across packages and enable static analysis tools to check context propagation:</source>
          <target state="translated">使用Contexts的程序应该遵循这些规则,以保持不同包的接口一致,并使静态分析工具能够检查上下文传播。</target>
        </trans-unit>
        <trans-unit id="3ac27ec45d4018361c7d594bf7eaa91a1292edd0" translate="yes" xml:space="preserve">
          <source>Programs using times should typically store and pass them as values, not pointers. That is, time variables and struct fields should be of type time.Time, not *time.Time.</source>
          <target state="translated">使用时间的程序通常应该以值的形式存储和传递时间,而不是指针。也就是说,时间变量和结构域的类型应该是time.Time,而不是*time.Time。</target>
        </trans-unit>
        <trans-unit id="c9ee0039dcc32da9c4cde1d419e8461ac1dfbdc7" translate="yes" xml:space="preserve">
          <source>Properties is the set of Unicode property tables.</source>
          <target state="translated">属性是Unicode属性表的集合。</target>
        </trans-unit>
        <trans-unit id="8768305a872da3684ae4bda3f68612735ba56c08" translate="yes" xml:space="preserve">
          <source>Properties of basic types.</source>
          <target state="translated">基本类型的属性。</target>
        </trans-unit>
        <trans-unit id="8a0d90b2918aadcefa0c95820abf21b6534492f2" translate="yes" xml:space="preserve">
          <source>ProtoAtLeast reports whether the HTTP protocol used in the request is at least major.minor.</source>
          <target state="translated">ProtoAtLeast报告请求中使用的HTTP协议是否至少是major.minor。</target>
        </trans-unit>
        <trans-unit id="ff9e390e5de482119dc42236df206efa900791fc" translate="yes" xml:space="preserve">
          <source>ProtoAtLeast reports whether the HTTP protocol used in the response is at least major.minor.</source>
          <target state="translated">ProtoAtLeast报告响应中使用的HTTP协议是否至少是major.minor。</target>
        </trans-unit>
        <trans-unit id="5829d5d1675f9485036e8bdae05dd67dac955b66" translate="yes" xml:space="preserve">
          <source>ProtocolError represents an HTTP protocol error.</source>
          <target state="translated">ProtocolError表示HTTP协议错误。</target>
        </trans-unit>
        <trans-unit id="c78f3a99754e80287f834beff8dcfd502a6d93a8" translate="yes" xml:space="preserve">
          <source>Provided that T2 is no larger than T1 and that the two share an equivalent memory layout, this conversion allows reinterpreting data of one type as data of another type. An example is the implementation of math.Float64bits:</source>
          <target state="translated">只要T2不大于T1,并且两者共享等效的内存布局,这种转换允许将一种类型的数据重新解释为另一种类型的数据。一个例子是math.Float64bits的实现。</target>
        </trans-unit>
        <trans-unit id="2667527e2309cea50315245bf9e96ef013a2321b" translate="yes" xml:space="preserve">
          <source>ProxyFromEnvironment returns the URL of the proxy to use for a given request, as indicated by the environment variables HTTP_PROXY, HTTPS_PROXY and NO_PROXY (or the lowercase versions thereof). HTTPS_PROXY takes precedence over HTTP_PROXY for https requests.</source>
          <target state="translated">ProxyFromEnvironment返回代理服务器的URL,用于给定的请求,如环境变量HTTP_PROXY、HTTPS_PROXY和NO_PROXY(或其小写版本)所示。对于https请求,HTTPS_PROXY优先于HTTP_PROXY。</target>
        </trans-unit>
        <trans-unit id="ce1c8acc8d3a18105ad805c3050485bfd7af1196" translate="yes" xml:space="preserve">
          <source>ProxyURL returns a proxy function (for use in a Transport) that always returns the same URL.</source>
          <target state="translated">ProxyURL 返回一个总是返回相同 URL 的代理函数(用于传输)。</target>
        </trans-unit>
        <trans-unit id="256df6693e9938b002805ef141a169ee9b0517c0" translate="yes" xml:space="preserve">
          <source>Pt is shorthand for Point{X, Y}.</source>
          <target state="translated">Pt是Point{X,Y}的简写。</target>
        </trans-unit>
        <trans-unit id="72df9c957a8f34680bd544544cf16bd450f7c686" translate="yes" xml:space="preserve">
          <source>PtrTo returns the pointer type with element t. For example, if t represents type Foo, PtrTo(t) represents *Foo.</source>
          <target state="translated">例如,如果t代表类型Foo,PtrTo(t)代表*Foo。</target>
        </trans-unit>
        <trans-unit id="1b89d49d722a1ef7d3c4ddfb234a1400f1a92cf6" translate="yes" xml:space="preserve">
          <source>Public returns the PublicKey corresponding to priv.</source>
          <target state="translated">Public返回与priv对应的PublicKey。</target>
        </trans-unit>
        <trans-unit id="2649f0278f57fd7af2dbdfb64c901b42e9d9789a" translate="yes" xml:space="preserve">
          <source>Public returns the public key corresponding to priv.</source>
          <target state="translated">Public 返回与priv对应的公钥。</target>
        </trans-unit>
        <trans-unit id="0d04adf8945e312c7d47fec2108c21b2684c9af5" translate="yes" xml:space="preserve">
          <source>PublicKey is the type of Ed25519 public keys.</source>
          <target state="translated">PublicKey是Ed25519公钥的类型。</target>
        </trans-unit>
        <trans-unit id="5001eedc91686ba11ee390e67cd1a676465f5d14" translate="yes" xml:space="preserve">
          <source>PublicKey represents a DSA public key.</source>
          <target state="translated">PublicKey代表一个DSA公钥。</target>
        </trans-unit>
        <trans-unit id="3acd186c84de8cd73322d4669ae9a4bf40b59d13" translate="yes" xml:space="preserve">
          <source>PublicKey represents a public key using an unspecified algorithm.</source>
          <target state="translated">PublicKey表示一个使用未指定算法的公钥。</target>
        </trans-unit>
        <trans-unit id="2f28570f8dc7131bd19dca1ee8af4ed1f0eeb1b5" translate="yes" xml:space="preserve">
          <source>PublicKey represents an ECDSA public key.</source>
          <target state="translated">PublicKey表示ECDSA公钥。</target>
        </trans-unit>
        <trans-unit id="b2140dd5a5a558ac28d58aa5d36d6a21620f906f" translate="yes" xml:space="preserve">
          <source>PublicSuffixList provides the public suffix of a domain. For example:</source>
          <target state="translated">PublicSuffixList提供了一个域名的公共后缀。例如</target>
        </trans-unit>
        <trans-unit id="edb82c4a8bbcf78c8a1448e29c8d98e501e15f1e" translate="yes" xml:space="preserve">
          <source>Publish declares a named exported variable. This should be called from a package's init function when it creates its Vars. If the name is already registered then this will log.Panic.</source>
          <target state="translated">发布声明一个命名的导出变量。当包创建其Vars时,应该从包的init函数中调用这个变量。如果名字已经被注册了,那么这将会log.Panic。</target>
        </trans-unit>
        <trans-unit id="2bf5378cf82463ae57e7e9a30e9ba5b326dba3d6" translate="yes" xml:space="preserve">
          <source>Push pushes the element x onto the heap. The complexity is O(log n) where n = h.Len().</source>
          <target state="translated">Push将元素x推到堆上。复杂度为O(log n),其中n=h.Len()。</target>
        </trans-unit>
        <trans-unit id="f4b202999ae2b93ddb6f5cd751aefdf3cb3293cf" translate="yes" xml:space="preserve">
          <source>PushBack inserts a new element e with value v at the back of list l and returns e.</source>
          <target state="translated">PushBack在列表l的后面插入一个新元素e,其值为v,并返回e。</target>
        </trans-unit>
        <trans-unit id="a50f3f664eb834d0bdb9f4d025dcb754c041066d" translate="yes" xml:space="preserve">
          <source>PushBackList inserts a copy of an other list at the back of list l. The lists l and other may be the same. They must not be nil.</source>
          <target state="translated">PushBackList在列表l的后面插入一个其他列表的副本。 列表l和其他列表可以是相同的。它们不能为零。</target>
        </trans-unit>
        <trans-unit id="041686901c1ec554a5144a12f7885b83447ca8ec" translate="yes" xml:space="preserve">
          <source>PushBackList inserts a copy of another list at the back of list l. The lists l and other may be the same. They must not be nil.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8c99a25179d82d5afa3406e22b548a0252f1474" translate="yes" xml:space="preserve">
          <source>PushFront inserts a new element e with value v at the front of list l and returns e.</source>
          <target state="translated">PushFront在列表l的前面插入一个新元素e,其值为v,并返回e。</target>
        </trans-unit>
        <trans-unit id="13a7ef38dc8b3d5639e9784f576b7dc8f0a8b795" translate="yes" xml:space="preserve">
          <source>PushFrontList inserts a copy of an other list at the front of list l. The lists l and other may be the same. They must not be nil.</source>
          <target state="translated">PushFrontList在列表l的前面插入了一个其他列表的副本,列表l和其他列表可以是相同的。它们不能为零。</target>
        </trans-unit>
        <trans-unit id="f3e24593e7558d1391736c35c920af73f9fb3935" translate="yes" xml:space="preserve">
          <source>PushFrontList inserts a copy of another list at the front of list l. The lists l and other may be the same. They must not be nil.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5520408cb4fcced642940bef6746727866edb323" translate="yes" xml:space="preserve">
          <source>PushOptions describes options for Pusher.Push.</source>
          <target state="translated">PushOptions描述了Pusher.Push的选项。</target>
        </trans-unit>
        <trans-unit id="192422b7c0ce1637e319052ddc27aa0f79641ec0" translate="yes" xml:space="preserve">
          <source>Pusher is the interface implemented by ResponseWriters that support HTTP/2 server push. For more background, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7540#section-8.2&quot;&gt;https://tools.ietf.org/html/rfc7540#section-8.2&lt;/a&gt;.</source>
          <target state="translated">Pusher是由ResponseWriters实现的支持HTTP / 2服务器推送的接口。有关更多背景信息，请参见&lt;a href=&quot;https://tools.ietf.org/html/rfc7540#section-8.2&quot;&gt;https://tools.ietf.org/html/rfc7540#section-8.2&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5810d2cea2c4c839a1cbc6f93eed06050e059bdc" translate="yes" xml:space="preserve">
          <source>Put adds x to the pool.</source>
          <target state="translated">把增加X到池中。</target>
        </trans-unit>
        <trans-unit id="6b32dae99e29878f191b30318e13ee160e3e9c11" translate="yes" xml:space="preserve">
          <source>PutUvarint</source>
          <target state="translated">PutUvarint</target>
        </trans-unit>
        <trans-unit id="d471216e431bf21e4cd2b9153a740d7d8a93b34a" translate="yes" xml:space="preserve">
          <source>PutUvarint encodes a uint64 into buf and returns the number of bytes written. If the buffer is too small, PutUvarint will panic.</source>
          <target state="translated">PutUvarint 将一个 uint64 编码成 buf,并返回写入的字节数。如果缓冲区太小,PutUvarint会惊慌失措。</target>
        </trans-unit>
        <trans-unit id="88299e1b8aa44f2b22e86375ae77e2d6a8112536" translate="yes" xml:space="preserve">
          <source>PutVarint</source>
          <target state="translated">PutVarint</target>
        </trans-unit>
        <trans-unit id="bd00eee1df8f0b67019e2ad70e9156e5fa1de99c" translate="yes" xml:space="preserve">
          <source>PutVarint encodes an int64 into buf and returns the number of bytes written. If the buffer is too small, PutVarint will panic.</source>
          <target state="translated">PutVarint将一个int64编码到buf中,并返回写入的字节数。如果缓冲区太小,PutVarint会惊慌失措。</target>
        </trans-unit>
        <trans-unit id="95ab58079356ed9aa8893c2df192745f32d71297" translate="yes" xml:space="preserve">
          <source>Quantizer produces a palette for an image.</source>
          <target state="translated">量子化器为图像生成一个调色板。</target>
        </trans-unit>
        <trans-unit id="05437837ec4647b7c23a7c5944b51f3ac43e58c7" translate="yes" xml:space="preserve">
          <source>Query executes a prepared query statement with the given arguments and returns the query results as a *Rows.</source>
          <target state="translated">Query执行一个带有给定参数的准备好的查询语句,并将查询结果以*Rows的形式返回。</target>
        </trans-unit>
        <trans-unit id="d610ca285b8521b4fbaa375322142cf95d05446a" translate="yes" xml:space="preserve">
          <source>Query executes a query that returns rows, typically a SELECT.</source>
          <target state="translated">Query执行一个返回行的查询,通常是一个SELECT。</target>
        </trans-unit>
        <trans-unit id="e1388b391779ee3280bdae6ba4b75470fb85b182" translate="yes" xml:space="preserve">
          <source>Query executes a query that returns rows, typically a SELECT. The args are for any placeholder parameters in the query.</source>
          <target state="translated">Query执行一个返回行的查询,通常是一个SELECT。args是查询中的任何占位参数。</target>
        </trans-unit>
        <trans-unit id="73ccd82bfd6eca331cabb2dba278895a7773c1c8" translate="yes" xml:space="preserve">
          <source>Query is expected to be a list of key=value settings separated by ampersands or semicolons. A setting without an equals sign is interpreted as a key set to an empty value.</source>
          <target state="translated">查询应该是一个键=值设置的列表,由安培或分号分隔。没有等号的设置被解释为键设置为空值。</target>
        </trans-unit>
        <trans-unit id="4501151d792df2b730db74682f29db9657ef7ffb" translate="yes" xml:space="preserve">
          <source>Query may return ErrSkip.</source>
          <target state="translated">查询可能返回ErrSkip。</target>
        </trans-unit>
        <trans-unit id="e1b497d6ece5d419609d5ec0635dc46c1d21b395" translate="yes" xml:space="preserve">
          <source>Query parses RawQuery and returns the corresponding values. It silently discards malformed value pairs. To check errors use ParseQuery.</source>
          <target state="translated">Query解析RawQuery并返回相应的值。它默默地丢弃错误的值对。要检查错误,请使用ParseQuery。</target>
        </trans-unit>
        <trans-unit id="8a08387889457a5be56952e049ecbbf787ca1008" translate="yes" xml:space="preserve">
          <source>QueryContext executes a prepared query statement with the given arguments and returns the query results as a *Rows.</source>
          <target state="translated">QueryContext执行一个带有给定参数的准备好的查询语句,并以*Rows的形式返回查询结果。</target>
        </trans-unit>
        <trans-unit id="90f64cb7930640d89ee4991b926e5cee52278a6e" translate="yes" xml:space="preserve">
          <source>QueryContext executes a query that returns rows, typically a SELECT.</source>
          <target state="translated">QueryContext执行一个返回行的查询,通常是一个SELECT。</target>
        </trans-unit>
        <trans-unit id="610270ccdd5f9415ac6596bb377b874f11fadbf3" translate="yes" xml:space="preserve">
          <source>QueryContext executes a query that returns rows, typically a SELECT. The args are for any placeholder parameters in the query.</source>
          <target state="translated">QueryContext执行一个返回行的查询,通常是一个SELECT。args是查询中的任何占位参数。</target>
        </trans-unit>
        <trans-unit id="7370d9d4f8639b69a2498dbee7578b05f64c38fb" translate="yes" xml:space="preserve">
          <source>QueryEscape escapes the string so it can be safely placed inside a URL query.</source>
          <target state="translated">QueryEscape对字符串进行转义,这样它就可以安全地放在URL查询中。</target>
        </trans-unit>
        <trans-unit id="4ddc8a6f5079b6c63ba14548ae3605122eaf2692" translate="yes" xml:space="preserve">
          <source>QueryRow executes a prepared query statement with the given arguments. If an error occurs during the execution of the statement, that error will be returned by a call to Scan on the returned *Row, which is always non-nil. If the query selects no rows, the *Row's Scan will return ErrNoRows. Otherwise, the *Row's Scan scans the first selected row and discards the rest.</source>
          <target state="translated">QueryRow用给定的参数执行一个准备好的查询语句。如果在执行语句的过程中发生错误,该错误将通过调用返回的*Row上的Scan来返回,Scan总是非零。如果查询没有选择行,则*Row的Scan将返回ErrNoRows。否则,*Row的Scan将扫描第一条被选中的行,并丢弃其余的行。</target>
        </trans-unit>
        <trans-unit id="0573144afbb38c9c195cafc127ff8c5f7fcc98f1" translate="yes" xml:space="preserve">
          <source>QueryRow executes a query that is expected to return at most one row. QueryRow always returns a non-nil value. Errors are deferred until Row's Scan method is called. If the query selects no rows, the *Row's Scan will return ErrNoRows. Otherwise, the *Row's Scan scans the first selected row and discards the rest.</source>
          <target state="translated">QueryRow执行一个预期最多返回一条记录的查询。QueryRow总是返回一个非零值。错误会被推迟到Row的Scan方法被调用。如果查询没有选择记录,那么*Row的Scan将返回ErrNoRows。否则,*Row's Scan将扫描第一条被选中的行,并丢弃其余的行。</target>
        </trans-unit>
        <trans-unit id="5b9f01963f310c9b55f64de5af1de9e922ab703a" translate="yes" xml:space="preserve">
          <source>QueryRowContext executes a prepared query statement with the given arguments. If an error occurs during the execution of the statement, that error will be returned by a call to Scan on the returned *Row, which is always non-nil. If the query selects no rows, the *Row's Scan will return ErrNoRows. Otherwise, the *Row's Scan scans the first selected row and discards the rest.</source>
          <target state="translated">QueryRowContext用给定的参数执行一个准备好的查询语句。如果在执行语句的过程中发生了错误,该错误将通过调用返回的*Row上的Scan来返回,该*Row总是非零。如果查询没有选择行,则*Row的Scan将返回ErrNoRows。否则,*Row的Scan将扫描第一条被选中的行,并丢弃其余的行。</target>
        </trans-unit>
        <trans-unit id="297d4c57ac1fe022d65f3f9afe2a0b04f607cea7" translate="yes" xml:space="preserve">
          <source>QueryRowContext executes a query that is expected to return at most one row. QueryRowContext always returns a non-nil value. Errors are deferred until Row's Scan method is called. If the query selects no rows, the *Row's Scan will return ErrNoRows. Otherwise, the *Row's Scan scans the first selected row and discards the rest.</source>
          <target state="translated">QueryRowContext执行一个预期最多返回一条记录的查询。QueryRowContext总是返回一个非零值。错误会被推迟到Row的Scan方法被调用。如果查询没有选择记录,那么*Row的Scan将返回ErrNoRows。否则,*Row's Scan将扫描第一条被选中的行,并丢弃其余的行。</target>
        </trans-unit>
        <trans-unit id="dcdd15a746401ad098faa59578b02f667ab6f1ed" translate="yes" xml:space="preserve">
          <source>QueryUnescape does the inverse transformation of QueryEscape, converting each 3-byte encoded substring of the form &quot;%AB&quot; into the hex-decoded byte 0xAB. It returns an error if any % is not followed by two hexadecimal digits.</source>
          <target state="translated">QueryUnescape 对 QueryEscape 进行逆向转换,将每个 3 字节编码的&quot;%AB &quot;形式的子串转换为十六进制解码的字节 0xAB。如果任何%后面没有两个十六进制数字,它将返回一个错误。</target>
        </trans-unit>
        <trans-unit id="02d2728197191f99f0589563ffe142aff0d31057" translate="yes" xml:space="preserve">
          <source>Queryer is an optional interface that may be implemented by a Conn.</source>
          <target state="translated">Queryer是一个可选的接口,它可以由Conn.NET实现。</target>
        </trans-unit>
        <trans-unit id="1c47ac983cb47637ae28fbb6e2c18b4b8c42e06e" translate="yes" xml:space="preserve">
          <source>QueryerContext is an optional interface that may be implemented by a Conn.</source>
          <target state="translated">QueryerContext是一个可选的接口,可以由Conn.Conn.Context实现。</target>
        </trans-unit>
        <trans-unit id="0013523fcda039d68ac4ad5f69b453c942a978cf" translate="yes" xml:space="preserve">
          <source>QueryerContext may return ErrSkip.</source>
          <target state="translated">QueryerContext可能返回ErrSkip。</target>
        </trans-unit>
        <trans-unit id="c63975c9274fd71acb9468b157e86657fe44318f" translate="yes" xml:space="preserve">
          <source>QueryerContext must honor the context timeout and return when the context is canceled.</source>
          <target state="translated">QueryerContext必须尊重上下文超时,并在上下文被取消时返回。</target>
        </trans-unit>
        <trans-unit id="9769d5fe0c55a8ef8d81aaad984f657373379c37" translate="yes" xml:space="preserve">
          <source>Quit sends the QUIT command and closes the connection to the server.</source>
          <target state="translated">Quit发送QUIT命令,关闭与服务器的连接。</target>
        </trans-unit>
        <trans-unit id="ef7d2daa6720a5dcac943446fb8685f517730120" translate="yes" xml:space="preserve">
          <source>Quo sets z to the quotient x/y and returns z. If y == 0, Quo panics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e1aae2dbf075bb68d93d724ad6566e5e4a1c5e3" translate="yes" xml:space="preserve">
          <source>Quo sets z to the quotient x/y and returns z. If y == 0, a division-by-zero run-time panic occurs.</source>
          <target state="translated">Quo将z设为商x/y,并返回z。如果y==0,则会发生除以零的运行时恐慌。</target>
        </trans-unit>
        <trans-unit id="a7929eb506dd3242d50cf4b52d276a4b8cb9c07b" translate="yes" xml:space="preserve">
          <source>Quo sets z to the quotient x/y for y != 0 and returns z. If y == 0, a division-by-zero run-time panic occurs. Quo implements truncated division (like Go); see QuoRem for more details.</source>
          <target state="translated">Quo将z设为y !=0的商x/y,并返回z。如果y ==0,则会发生按零除法的运行时恐慌。Quo实现了截断式除法(像Go一样);更多细节参见QuoRem。</target>
        </trans-unit>
        <trans-unit id="1572bc36f1694a28504f4543686c15ca4cc42af5" translate="yes" xml:space="preserve">
          <source>Quo sets z to the rounded quotient x/y and returns z. Precision, rounding, and accuracy reporting are as for Add. Quo panics with ErrNaN if both operands are zero or infinities. The value of z is undefined in that case.</source>
          <target state="translated">Quo 将 z 设置为四舍五入的商 x/y 并返回 z。精度、四舍五入和精度报告与 Add 相同。如果两个操作数都是零或无穷大,Quo会用ErrNaN恐慌。在这种情况下,z 的值是未定义的。</target>
        </trans-unit>
        <trans-unit id="99e212957f2d4b215b9b3d9954ca4d24b4f7b7f8" translate="yes" xml:space="preserve">
          <source>QuoRem implements T-division and modulus (like Go):</source>
          <target state="translated">QuoRem实现了T-division和modulus(像Go一样)。</target>
        </trans-unit>
        <trans-unit id="c9ddbdd15bfd376c21e0a62b9370cde6334dc1f4" translate="yes" xml:space="preserve">
          <source>QuoRem sets z to the quotient x/y and r to the remainder x%y and returns the pair (z, r) for y != 0. If y == 0, a division-by-zero run-time panic occurs.</source>
          <target state="translated">QuoRem将z设为商x/y,r设为余数x%y,并返回y !=0的对子(z,r),如果y==0,则会发生逐零除法的运行时恐慌。</target>
        </trans-unit>
        <trans-unit id="309028a9e01273ac7a88142bf26446f3f2a8f06c" translate="yes" xml:space="preserve">
          <source>Quote</source>
          <target state="translated">Quote</target>
        </trans-unit>
        <trans-unit id="02a6b721c3cbad5a2ac35c25089d53ad320899bd" translate="yes" xml:space="preserve">
          <source>Quote and QuoteToASCII convert strings to quoted Go string literals. The latter guarantees that the result is an ASCII string, by escaping any non-ASCII Unicode with \u:</source>
          <target state="translated">Quote 和 QuoteToASCII 将字符串转换为引号的围棋字符串字面。后者通过对任何非ASCII的Unicode进行转义,保证结果是一个ASCII字符串。</target>
        </trans-unit>
        <trans-unit id="3617a988d68c2550b56a0533be32b6f532f0c980" translate="yes" xml:space="preserve">
          <source>Quote returns a double-quoted Go string literal representing s. The returned string uses Go escape sequences (\t, \n, \xFF, \u0100) for control characters and non-printable characters as defined by IsPrint.</source>
          <target state="translated">返回的字符串使用Go转义序列(\t,\n,\xFF,\u0100)来表示控制字符和IsPrint定义的不可打印字符。</target>
        </trans-unit>
        <trans-unit id="6f31dc77f679cfa7aaf16ecb978ab9c3d8982f6f" translate="yes" xml:space="preserve">
          <source>QuoteMeta</source>
          <target state="translated">QuoteMeta</target>
        </trans-unit>
        <trans-unit id="37da03d2f50ceab91ce8002d89f395e8b70d32e3" translate="yes" xml:space="preserve">
          <source>QuoteMeta returns a string that escapes all regular expression metacharacters inside the argument text; the returned string is a regular expression matching the literal text.</source>
          <target state="translated">QuoteMeta 返回一个字符串,该字符串可以转义所有参数文本中的正则表达式元字符;返回的字符串是一个与文字匹配的正则表达式。</target>
        </trans-unit>
        <trans-unit id="e4b2ad9113103116d841b51eb9a5a4bb79d43dd5" translate="yes" xml:space="preserve">
          <source>QuoteRune</source>
          <target state="translated">QuoteRune</target>
        </trans-unit>
        <trans-unit id="642db102936be1179d9fd316324babf33d424684" translate="yes" xml:space="preserve">
          <source>QuoteRune and QuoteRuneToASCII are similar but accept runes and return quoted Go rune literals.</source>
          <target state="translated">QuoteRune 和 QuoteRuneToASCII 类似,但接受符文并返回引用的围棋符文字面。</target>
        </trans-unit>
        <trans-unit id="279cda9da221d3eced1baaee13fb941915b0ad94" translate="yes" xml:space="preserve">
          <source>QuoteRune returns a single-quoted Go character literal representing the rune. The returned string uses Go escape sequences (\t, \n, \xFF, \u0100) for control characters and non-printable characters as defined by IsPrint.</source>
          <target state="translated">QuoteRune返回一个代表符文的单引号Go字符文字。返回的字符串使用围棋转义序列(\t,\n,\xFF,\u0100)作为控制字符和IsPrint定义的不可打印字符。</target>
        </trans-unit>
        <trans-unit id="c3b760977eead2353634f7488bfbfd8e6f53c7d3" translate="yes" xml:space="preserve">
          <source>QuoteRuneToASCII</source>
          <target state="translated">QuoteRuneToASCII</target>
        </trans-unit>
        <trans-unit id="53e2d039ada874ffb648eee9f937362314f5598e" translate="yes" xml:space="preserve">
          <source>QuoteRuneToASCII returns a single-quoted Go character literal representing the rune. The returned string uses Go escape sequences (\t, \n, \xFF, \u0100) for non-ASCII characters and non-printable characters as defined by IsPrint.</source>
          <target state="translated">QuoteRuneToASCII返回一个代表符文的单引号Go字符文字。返回的字符串对非ASCII字符和IsPrint定义的不可打印字符使用围棋转义序列(\t,\n,\xFF,\u0100)。</target>
        </trans-unit>
        <trans-unit id="0b7fc6950d658f88c7fbca21f506d8678210ba4b" translate="yes" xml:space="preserve">
          <source>QuoteRuneToGraphic</source>
          <target state="translated">QuoteRuneToGraphic</target>
        </trans-unit>
        <trans-unit id="6df82b7440744d392453e7ffacfb94618d53a85f" translate="yes" xml:space="preserve">
          <source>QuoteRuneToGraphic returns a single-quoted Go character literal representing the rune. If the rune is not a Unicode graphic character, as defined by IsGraphic, the returned string will use a Go escape sequence (\t, \n, \xFF, \u0100).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7acc4ec0f4c890982546aed330f635d958aaa08" translate="yes" xml:space="preserve">
          <source>QuoteRuneToGraphic returns a single-quoted Go character literal representing the rune. The returned string uses Go escape sequences (\t, \n, \xFF, \u0100) for non-ASCII characters and non-printable characters as defined by IsGraphic.</source>
          <target state="translated">QuoteRuneToGraphic返回一个代表符文的单引号Go字符文字。返回的字符串使用围棋转义序列(\t,\n,\xFF,\u0100)来表示非ASCII字符和IsGraphic定义的不可打印字符。</target>
        </trans-unit>
        <trans-unit id="1c5941bc9d5a3819ff2354cecea7900bb16d81ce" translate="yes" xml:space="preserve">
          <source>QuoteToASCII</source>
          <target state="translated">QuoteToASCII</target>
        </trans-unit>
        <trans-unit id="1903845d523cb092b2910db9e417c9681642b306" translate="yes" xml:space="preserve">
          <source>QuoteToASCII returns a double-quoted Go string literal representing s. The returned string uses Go escape sequences (\t, \n, \xFF, \u0100) for non-ASCII characters and non-printable characters as defined by IsPrint.</source>
          <target state="translated">返回的字符串对非ASCII字符和IsPrint定义的不可打印字符使用Go转义序列(\t,\n,\xFF,\u0100)。</target>
        </trans-unit>
        <trans-unit id="4621ad4d6c0a75793529926b49a9e0ff472d7a25" translate="yes" xml:space="preserve">
          <source>QuoteToGraphic</source>
          <target state="translated">QuoteToGraphic</target>
        </trans-unit>
        <trans-unit id="989eba63a51b2ee78ebbd70a94ce50a7d2a7dea9" translate="yes" xml:space="preserve">
          <source>QuoteToGraphic returns a double-quoted Go string literal representing s. The returned string leaves Unicode graphic characters, as defined by IsGraphic, unchanged and uses Go escape sequences (\t, \n, \xFF, \u0100) for non-graphic characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29d4d4e582c2a53b8be9f8063c3bfb0f71cbfd71" translate="yes" xml:space="preserve">
          <source>QuoteToGraphic returns a double-quoted Go string literal representing s. The returned string uses Go escape sequences (\t, \n, \xFF, \u0100) for non-ASCII characters and non-printable characters as defined by IsGraphic.</source>
          <target state="translated">QuoteToGraphic返回一个双引号的代表s的Go字符串文字。返回的字符串对非ASCII字符和IsGraphic定义的不可打印字符使用Go转义序列(\t,\n,\xFF,\u0100)。</target>
        </trans-unit>
        <trans-unit id="fd12f86a63d23d37e2246e2c7fa6e414286f5f3b" translate="yes" xml:space="preserve">
          <source>RC4 is cryptographically broken and should not be used for secure applications.</source>
          <target state="translated">RC4在密码学上是有缺陷的,不应该用于安全应用。</target>
        </trans-unit>
        <trans-unit id="bc475e86eb000cdc90e36723f96df5f3d9198891" translate="yes" xml:space="preserve">
          <source>RGBA is an in-memory image whose At method returns color.RGBA values.</source>
          <target state="translated">RGBA是一个内存图像,其At方法返回color.RGBA值。</target>
        </trans-unit>
        <trans-unit id="04d387f558acb0866f18159db1f3ea813711e9ce" translate="yes" xml:space="preserve">
          <source>RGBA represents a traditional 32-bit alpha-premultiplied color, having 8 bits for each of red, green, blue and alpha.</source>
          <target state="translated">RGBA代表传统的32位alpha预乘色,红、绿、蓝和alpha各8位。</target>
        </trans-unit>
        <trans-unit id="46da93f2d89b5f7316108ef78fe128ccbb04c72c" translate="yes" xml:space="preserve">
          <source>RGBA64 is an in-memory image whose At method returns color.RGBA64 values.</source>
          <target state="translated">RGBA64是一个内存图像,其At方法返回color.RGBA64值。</target>
        </trans-unit>
        <trans-unit id="dd5b935255bb5c16c695e848211ad0d21f5142a6" translate="yes" xml:space="preserve">
          <source>RGBA64 represents a 64-bit alpha-premultiplied color, having 16 bits for each of red, green, blue and alpha.</source>
          <target state="translated">RGBA64表示64位alpha预乘色,红、绿、蓝和alpha各为16位。</target>
        </trans-unit>
        <trans-unit id="33f4c44fe26c52f4a8501dd0d6638972bee0c02a" translate="yes" xml:space="preserve">
          <source>RGBToCMYK converts an RGB triple to a CMYK quadruple.</source>
          <target state="translated">RGBToCMYK将RGB三倍转换为CMYK四倍。</target>
        </trans-unit>
        <trans-unit id="b770a15a910f2bcdc5fe9614ef9593fa435bc817" translate="yes" xml:space="preserve">
          <source>RGBToYCbCr converts an RGB triple to a Y'CbCr triple.</source>
          <target state="translated">RGBToYCbCr将一个RGB三原色转换为Y'CbCr三原色。</target>
        </trans-unit>
        <trans-unit id="80bfa68e1e388f84eb032cb18125580dfa1ad40c" translate="yes" xml:space="preserve">
          <source>RLock locks rw for reading.</source>
          <target state="translated">RLock锁住Rw进行读取。</target>
        </trans-unit>
        <trans-unit id="437fa597804ed80cc48e0b7bbfe7afd323e52a8f" translate="yes" xml:space="preserve">
          <source>RLocker returns a Locker interface that implements the Lock and Unlock methods by calling rw.RLock and rw.RUnlock.</source>
          <target state="translated">RLocker通过调用rw.RLock和rw.RUnlock返回一个实现Lock和Unlock方法的Locker接口。</target>
        </trans-unit>
        <trans-unit id="e9e1378ed0c7150ba139600e4e6dab65e5c1015c" translate="yes" xml:space="preserve">
          <source>RSA is a single, fundamental operation that is used in this package to implement either public-key encryption or public-key signatures.</source>
          <target state="translated">RSA是一个单一的、基本的操作,在这个软件包中用来实现公钥加密或公钥签名。</target>
        </trans-unit>
        <trans-unit id="ea29bda7df062dd06d2efdde6aa5df97bda09cc0" translate="yes" xml:space="preserve">
          <source>RSA is able to encrypt only a very limited amount of data. In order to encrypt reasonable amounts of data a hybrid scheme is commonly used: RSA is used to encrypt a key for a symmetric primitive like AES-GCM. Before encrypting, data is &amp;ldquo;padded&amp;rdquo; by embedding it in a known structure. This is done for a number of reasons, but the most obvious is to ensure that the value is large enough that the exponentiation is larger than the modulus. (Otherwise it could be decrypted with a square-root.) In these designs, when using PKCS #1 v1.5, it's vitally important to avoid disclosing whether the received RSA message was well-formed (that is, whether the result of decrypting is a correctly padded message) because this leaks secret information. DecryptPKCS1v15SessionKey is designed for this situation and copies the decrypted, symmetric key (if well-formed) in constant-time over a buffer that contains a random key. Thus, if the RSA result isn't well-formed, the implementation uses a random key in constant time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5491899defb867c4967ebbebdd0bd5970a6aab7" translate="yes" xml:space="preserve">
          <source>RSA is able to encrypt only a very limited amount of data. In order to encrypt reasonable amounts of data a hybrid scheme is commonly used: RSA is used to encrypt a key for a symmetric primitive like AES-GCM. Before encrypting, data is &amp;ldquo;padded&amp;rdquo; by embedding it in a known structure. This is done for a number of reasons, but the most obvious is to ensure that the value is large enough that the exponentiation is larger than the modulus. (Otherwise it could be decrypted with a square-root.) In these designs, when using PKCS#1 v1.5, it's vitally important to avoid disclosing whether the received RSA message was well-formed (that is, whether the result of decrypting is a correctly padded message) because this leaks secret information. DecryptPKCS1v15SessionKey is designed for this situation and copies the decrypted, symmetric key (if well-formed) in constant-time over a buffer that contains a random key. Thus, if the RSA result isn't well-formed, the implementation uses a random key in constant time.</source>
          <target state="translated">RSA只能加密非常有限的数据。为了加密合理数量的数据，通常使用混合方案：RSA用于加密对称原语（例如AES-GCM）的密钥。在加密之前，通过将数据嵌入已知结构来&amp;ldquo;填充&amp;rdquo;数据。这样做有多种原因，但最明显的是确保该值足够大，以使幂运算大于模数。 （否则，可以使用平方根解密。）在这些设计中，当使用PKCS＃1 v1.5时，避免泄漏所接收的RSA消息是否格式正确（即解密的结果是否公开）至关重要。是正确填充的消息），因为这会泄漏机密信息。 DecryptPKCS1v15SessionKey专门用于这种情况，并复制解密后的内容，对称密钥（如果格式正确）在包含随机密钥的缓冲区上持续固定时间。因此，如果RSA结果格式不正确，则实现将在恒定时间内使用随机密钥。</target>
        </trans-unit>
        <trans-unit id="0d73a3a42eb35fcb3f1a5896de985a3713b16b03" translate="yes" xml:space="preserve">
          <source>RUnlock undoes a single RLock call; it does not affect other simultaneous readers. It is a run-time error if rw is not locked for reading on entry to RUnlock.</source>
          <target state="translated">RUnlock会撤销一个RLock调用,它不会影响其他同时读取的程序。如果rw在进入RUnlock时没有被锁定读取,则会出现运行时错误。</target>
        </trans-unit>
        <trans-unit id="b74aed63ef335b4d50b7ff503e63deda9fc37c24" translate="yes" xml:space="preserve">
          <source>Rand sets z to a pseudo-random number in [0, n) and returns z.</source>
          <target state="translated">Rand将z设为[0,n)中的一个伪随机数,并返回z。</target>
        </trans-unit>
        <trans-unit id="cd54bd9d380c9fc6a34adb64461692fb6d87443f" translate="yes" xml:space="preserve">
          <source>Random numbers are generated by a Source. Top-level functions, such as Float64 and Int, use a default shared Source that produces a deterministic sequence of values each time a program is run. Use the Seed function to initialize the default Source if different behavior is required for each run. The default Source is safe for concurrent use by multiple goroutines, but Sources created by NewSource are not.</source>
          <target state="translated">随机数是由Source产生的。顶级函数,如Float64和Int,使用一个默认的共享Source,每次程序运行时都会产生一个确定性的值序列。如果每次运行需要不同的行为,可以使用Seed函数来初始化默认的Source。默认的Source对于多个goroutine的并发使用是安全的,但NewSource创建的Sources则不安全。</target>
        </trans-unit>
        <trans-unit id="8185befebe4b99fc7f08cc0f98bec64eff9d397b" translate="yes" xml:space="preserve">
          <source>Range calls f sequentially for each key and value present in the map. If f returns false, range stops the iteration.</source>
          <target state="translated">Range对地图中的每个键和值依次调用f。如果f返回false,range停止迭代。</target>
        </trans-unit>
        <trans-unit id="e20ffc43a19a831487646a9ec91a15662b93326d" translate="yes" xml:space="preserve">
          <source>Range does not necessarily correspond to any consistent snapshot of the Map's contents: no key will be visited more than once, but if the value for any key is stored or deleted concurrently, Range may reflect any mapping for that key from any point during the Range call.</source>
          <target state="translated">Range不一定对应于Map内容的任何一致的快照:没有一个键会被访问不止一次,但如果任何键的值被同时存储或删除,Range可能会反映该键在Range调用期间任何点的任何映射。</target>
        </trans-unit>
        <trans-unit id="faec537bfdedcf391dd6afc93a601559afbe0c69" translate="yes" xml:space="preserve">
          <source>Range may be O(N) with the number of elements in the map even if f returns false after a constant number of calls.</source>
          <target state="translated">Range可能是O(N)与映射中的元素数,即使f在调用次数不变后返回false。</target>
        </trans-unit>
        <trans-unit id="dc094bef8459881bcfd6a354dcd57e410a9ea71d" translate="yes" xml:space="preserve">
          <source>Range16 represents of a range of 16-bit Unicode code points. The range runs from Lo to Hi inclusive and has the specified stride.</source>
          <target state="translated">Range16表示16位Unicode码点的范围。该范围从Lo到Hi(含),并具有指定的跨度。</target>
        </trans-unit>
        <trans-unit id="8ceb0b8d7c66b188254058f3e47e0188e8c2c9ca" translate="yes" xml:space="preserve">
          <source>Range32 represents of a range of Unicode code points and is used when one or more of the values will not fit in 16 bits. The range runs from Lo to Hi inclusive and has the specified stride. Lo and Hi must always be &amp;gt;= 1&amp;lt;&amp;lt;16.</source>
          <target state="translated">Range32代表一系列Unicode代码点，并且当一个或多个值不适合16位时使用。范围从Lo到Hi（含），并具有指定的跨度。Lo和Hi必须始终为&amp;gt; = 1 &amp;lt;&amp;lt; 16。</target>
        </trans-unit>
        <trans-unit id="3c231e0e20b34ad9b3302a62e18606f8e55490f0" translate="yes" xml:space="preserve">
          <source>RangeNode represents a {{range}} action and its commands.</source>
          <target state="translated">RangeNode表示一个{{range}}动作及其命令。</target>
        </trans-unit>
        <trans-unit id="abf434f30dd2288f852577f0e6ac91164ff1a3d8" translate="yes" xml:space="preserve">
          <source>RangeTable defines a set of Unicode code points by listing the ranges of code points within the set. The ranges are listed in two slices to save space: a slice of 16-bit ranges and a slice of 32-bit ranges. The two slices must be in sorted order and non-overlapping. Also, R32 should contain only values &amp;gt;= 0x10000 (1&amp;lt;&amp;lt;16).</source>
          <target state="translated">RangeTable通过列出一组Unicode代码点的范围来定义它。为了节省空间，在两个切片中列出了范围：切片的16位范围和切片的32位范围。这两个片必须按排序顺序且不重叠。同样，R32应该只包含&amp;gt; = 0x10000（1 &amp;lt;&amp;lt; 16）的值。</target>
        </trans-unit>
        <trans-unit id="c2ee87a3ff54a0745b9a4a39ad5daff79dc82bc0" translate="yes" xml:space="preserve">
          <source>Ranges returns the PC ranges covered by e, a slice of [low,high) pairs. Only some entry types, such as TagCompileUnit or TagSubprogram, have PC ranges; for others, this will return nil with no error.</source>
          <target state="translated">Ranges 返回 e 所覆盖的 PC 范围,即 [low,high]对的片断。只有某些条目类型,如TagCompileUnit或TagSubprogram,才有PC范围;对于其他类型,这将返回无错误的nil。</target>
        </trans-unit>
        <trans-unit id="81de462dc83f2812dc32eb06897fa3d4b38ae7e7" translate="yes" xml:space="preserve">
          <source>Rat returns the rational number corresponding to x; or nil if x is an infinity. The result is Exact if x is not an Inf. If a non-nil *Rat argument z is provided, Rat stores the result in z instead of allocating a new Rat.</source>
          <target state="translated">Rat返回x对应的有理数;如果x是无穷大,则返回nil。如果x不是无穷大,则返回结果为Exact。如果提供了一个非零的*Rat参数z,Rat将把结果存储在z中,而不是分配一个新的Rat。</target>
        </trans-unit>
        <trans-unit id="50ea5863423e0f2515585dcf8c4cb2e31c788a51" translate="yes" xml:space="preserve">
          <source>Rat.Scan</source>
          <target state="translated">Rat.Scan</target>
        </trans-unit>
        <trans-unit id="c5f08baa94ad88996a91c67be38be8fe61b40881" translate="yes" xml:space="preserve">
          <source>Rat.SetString</source>
          <target state="translated">Rat.SetString</target>
        </trans-unit>
        <trans-unit id="ef746adb638d3b60d53628e5d2f1455b1d2e8157" translate="yes" xml:space="preserve">
          <source>RatString returns a string representation of x in the form &quot;a/b&quot; if b != 1, and in the form &quot;a&quot; if b == 1.</source>
          <target state="translated">RatString返回x的字符串表示,如果b !=1,则以 &quot;a/b &quot;的形式表示,如果b ==1,则以 &quot;a &quot;的形式表示。</target>
        </trans-unit>
        <trans-unit id="641d010f14e2f18c1619afc2268deaff20c97455" translate="yes" xml:space="preserve">
          <source>Raw executes f exposing the underlying driver connection for the duration of f. The driverConn must not be used outside of f.</source>
          <target state="translated">Raw执行f,在f的持续时间内暴露底层的驱动连接,driverConn不能在f之外使用。</target>
        </trans-unit>
        <trans-unit id="26c83b72700cdd4952e72476a8d6589b2a87a210" translate="yes" xml:space="preserve">
          <source>RawBytes is a byte slice that holds a reference to memory owned by the database itself. After a Scan into a RawBytes, the slice is only valid until the next call to Next, Scan, or Close.</source>
          <target state="translated">RawBytes是一个字节分片,它保存着对数据库本身所拥有的内存的引用。在扫描到RawBytes后,该分片只在下一次调用Next、Scan或Close之前有效。</target>
        </trans-unit>
        <trans-unit id="3e2984f789eabe0509843f2607db31c184bddf19" translate="yes" xml:space="preserve">
          <source>RawContent is used to signal that the undecoded, DER data needs to be preserved for a struct. To use it, the first field of the struct must have this type. It's an error for any of the other fields to have this type.</source>
          <target state="translated">RawContent用于发出信号,表示需要为一个结构保留未解码的DER数据。要使用它,结构的第一个字段必须具有这种类型。任何其他字段具有这种类型都是错误的。</target>
        </trans-unit>
        <trans-unit id="40ee0825120347a6625b948e8e5d6cf21e430f3f" translate="yes" xml:space="preserve">
          <source>RawMessage (Marshal)</source>
          <target state="translated">RawMessage (Marshal)</target>
        </trans-unit>
        <trans-unit id="d988676cc711a8df55ed7c79d1c3ecdfedc6d2cd" translate="yes" xml:space="preserve">
          <source>RawMessage (Unmarshal)</source>
          <target state="translated">RawMessage (Unmarshal)</target>
        </trans-unit>
        <trans-unit id="1b6da1274d970ef16e862ce3a549bfc22e374a82" translate="yes" xml:space="preserve">
          <source>RawMessage is a raw encoded JSON value. It implements Marshaler and Unmarshaler and can be used to delay JSON decoding or precompute a JSON encoding.</source>
          <target state="translated">RawMessage是一个原始编码的JSON值。它实现了Marshaler和Unmarshaler,可以用来延迟JSON解码或预计算JSON编码。</target>
        </trans-unit>
        <trans-unit id="b92ccd29d9bf661a3766af996d8af025383bbfe8" translate="yes" xml:space="preserve">
          <source>RawStdEncoding is the standard raw, unpadded base64 encoding, as defined in RFC 4648 section 3.2. This is the same as StdEncoding but omits padding characters.</source>
          <target state="translated">RawStdEncoding是标准的原始、无填充的base64编码,定义在RFC 4648第3.2节。这与StdEncoding相同,但省略了填充字符。</target>
        </trans-unit>
        <trans-unit id="6e753058a412394f90ee90228dcf31c4e858e385" translate="yes" xml:space="preserve">
          <source>RawToken is like Token but does not verify that start and end elements match and does not translate name space prefixes to their corresponding URLs.</source>
          <target state="translated">RawToken和Token一样,但不验证开始和结束元素是否匹配,也不将名称空间前缀翻译成相应的URL。</target>
        </trans-unit>
        <trans-unit id="166fbd6be28a6fdfe4f94b440b329268727101a8" translate="yes" xml:space="preserve">
          <source>RawURLEncoding is the unpadded alternate base64 encoding defined in RFC 4648. It is typically used in URLs and file names. This is the same as URLEncoding but omits padding characters.</source>
          <target state="translated">RawURLEncoding是RFC 4648中定义的无填充的备用base64编码。它通常用于URL和文件名中。这与URLEncoding相同,但省略了填充字符。</target>
        </trans-unit>
        <trans-unit id="b05c645148a5f30bf1ff0257be7322f1e5b30562" translate="yes" xml:space="preserve">
          <source>Rcpt issues a RCPT command to the server using the provided email address. A call to Rcpt must be preceded by a call to Mail and may be followed by a Data call or another Rcpt call.</source>
          <target state="translated">Rcpt 使用提供的电子邮件地址向服务器发出 RCPT 命令。对Rcpt的调用必须在调用Mail之前进行,并且可以在调用Data或其他Rcpt调用之后进行。</target>
        </trans-unit>
        <trans-unit id="852b438f91ad9eb2cdd84419a675a216d543c687" translate="yes" xml:space="preserve">
          <source>Read</source>
          <target state="translated">Read</target>
        </trans-unit>
        <trans-unit id="1fab142ac33b47994d5f7bd4bebd0d391e21aa89" translate="yes" xml:space="preserve">
          <source>Read (Multi)</source>
          <target state="translated">读取(多)</target>
        </trans-unit>
        <trans-unit id="4616684d2875f90666103e0a2381658c802ee8fa" translate="yes" xml:space="preserve">
          <source>Read (ReadingAllMetrics)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="056841d4c802087a4a98816675796eebe48b69ab" translate="yes" xml:space="preserve">
          <source>Read (ReadingOneMetric)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d9a4bfe253412dcb5fa31eea7ed6b71a69c4521" translate="yes" xml:space="preserve">
          <source>Read calls decode to deserialize a file set into s; s must not be nil.</source>
          <target state="translated">读取调用解码,将一个文件集反序列化到s中;s不能为零。</target>
        </trans-unit>
        <trans-unit id="cf8ca129127382252f21178b2e38598c4c8bdae5" translate="yes" xml:space="preserve">
          <source>Read can be made to time out and return a net.Error with Timeout() == true after a fixed time limit; see SetDeadline and SetReadDeadline.</source>
          <target state="translated">读取可以在固定的时间限制后,用Timeout()==true使其超时并返回一个net.Error;参见SetDeadline和SetReadDeadline。</target>
        </trans-unit>
        <trans-unit id="f1410843edc88c2b9c942b455b313f9ec9a6aa42" translate="yes" xml:space="preserve">
          <source>Read generates len(p) random bytes and writes them into p. It always returns len(p) and a nil error. Read should not be called concurrently with any other Rand method.</source>
          <target state="translated">Read 生成 len(p)随机字节并将它们写入 p 中。它总是返回 len(p)和一个 nil 错误。Read 不应与其他任何 Rand 方法同时调用。</target>
        </trans-unit>
        <trans-unit id="1059017001f226c432850be91279c7915ab436ce" translate="yes" xml:space="preserve">
          <source>Read generates len(p) random bytes from the default Source and writes them into p. It always returns len(p) and a nil error. Read, unlike the Rand.Read method, is safe for concurrent use.</source>
          <target state="translated">Read 从默认的 Source 生成 len(p)随机字节,并将它们写入 p 中,它总是返回 len(p)和一个 nil 错误。Read与Rand.Read方法不同,它的并发使用是安全的。</target>
        </trans-unit>
        <trans-unit id="a6208c052d923f9826a6caa2665b94a206f4ce81" translate="yes" xml:space="preserve">
          <source>Read implements io.Reader, reading uncompressed bytes from its underlying Reader.</source>
          <target state="translated">Read实现了io.Reader,从其底层Reader中读取未压缩的字节。</target>
        </trans-unit>
        <trans-unit id="702bfd00bb1c14225a9197a21d99befbae954266" translate="yes" xml:space="preserve">
          <source>Read implements the Conn Read method.</source>
          <target state="translated">Read实现Conn Read方法。</target>
        </trans-unit>
        <trans-unit id="516c851188aa6fc002db294d7651c5ec750120d8" translate="yes" xml:space="preserve">
          <source>Read implements the io.Reader interface.</source>
          <target state="translated">Read实现了io.Reader接口。</target>
        </trans-unit>
        <trans-unit id="13632ff4ca176eb49e2ded2120c8bd44145f6430" translate="yes" xml:space="preserve">
          <source>Read implements the standard Read interface: it reads data from the pipe, blocking until a writer arrives or the write end is closed. If the write end is closed with an error, that error is returned as err; otherwise err is EOF.</source>
          <target state="translated">Read实现了标准的Read接口:它从管道中读取数据,阻塞直到写入端到达或写入端关闭。如果写端因错误而关闭,则该错误以err的形式返回;否则err为EOF。</target>
        </trans-unit>
        <trans-unit id="852b19fc6db1a887a68fe0a33719da8f3df7f6a7" translate="yes" xml:space="preserve">
          <source>Read is a helper function that calls Reader.Read using io.ReadFull. On return, n == len(b) if and only if err == nil.</source>
          <target state="translated">Read是一个帮助函数,它使用io.ReadFull调用Reader.Read。返回时,如果且仅当err ==nil时,n ==len(b)。</target>
        </trans-unit>
        <trans-unit id="b67213600ee7c7c65b18452fd9f7225abb869291" translate="yes" xml:space="preserve">
          <source>Read populates each Value field in the given slice of metric samples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6027400201b1aeffebb229f97e47437dd5103716" translate="yes" xml:space="preserve">
          <source>Read reads and decodes quoted-printable data from the underlying reader.</source>
          <target state="translated">Read从底层阅读器中读取和解码可引用打印的数据。</target>
        </trans-unit>
        <trans-unit id="e39e4192f44c501e67a65cfba45076430efcd47a" translate="yes" xml:space="preserve">
          <source>Read reads data from the connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="099ba490bf08acc0d4ea27ba7af0e8caf12990cd" translate="yes" xml:space="preserve">
          <source>Read reads data into p. It returns the number of bytes read into p. The bytes are taken from at most one Read on the underlying Reader, hence n may be less than len(p). To read exactly len(p) bytes, use io.ReadFull(b, p). At EOF, the count will be zero and err will be io.EOF.</source>
          <target state="translated">Read 将数据读到 p 中,返回读到 p 中的字节数。字节数最多来自于底层阅读器上的一次读取,因此 n 可能小于 len(p)。要精确读取len(p)字节,使用io.ReadFull(b,p)。在EOF时,计数将为零,err将为io.EOF.ReadFull(b,p)。</target>
        </trans-unit>
        <trans-unit id="16ce634004d504a55e55d47a3800c80b22768a4e" translate="yes" xml:space="preserve">
          <source>Read reads from the current file in the tar archive. It returns (0, io.EOF) when it reaches the end of that file, until Next is called to advance to the next file.</source>
          <target state="translated">Read 从 tar 归档文件中读取当前文件。当读到该文件的结尾时,它返回 (0,io.EOF),直到调用 Next 来前进到下一个文件。</target>
        </trans-unit>
        <trans-unit id="8672c69a1ddaf5ba6848a36cbea552f79e4309ae" translate="yes" xml:space="preserve">
          <source>Read reads one record (a slice of fields) from r. If the record has an unexpected number of fields, Read returns the record along with the error ErrFieldCount. Except for that case, Read always returns either a non-nil record or a non-nil error, but not both. If there is no data left to be read, Read returns nil, io.EOF. If ReuseRecord is true, the returned slice may be shared between multiple calls to Read.</source>
          <target state="translated">Read从r中读取一条记录(字段的片断)。如果记录的字段数出乎意料,Read会将记录和错误ErrFieldCount一起返回。除了这种情况,Read总是返回一个非零记录或一个非零错误,但不会同时返回。如果没有剩余数据可读,Read返回nil,io.EOF。如果ReuseRecord为真,返回的分片可以在多个Read调用之间共享。</target>
        </trans-unit>
        <trans-unit id="2a7ebad97783211e0c50dee195a81d2fcc00a21a" translate="yes" xml:space="preserve">
          <source>Read reads structured binary data from r into data. Data must be a pointer to a fixed-size value or a slice of fixed-size values. Bytes read from r are decoded using the specified byte order and written to successive fields of the data. When decoding boolean values, a zero byte is decoded as false, and any other non-zero byte is decoded as true. When reading into structs, the field data for fields with blank (_) field names is skipped; i.e., blank field names may be used for padding. When reading into a struct, all non-blank fields must be exported or Read may panic.</source>
          <target state="translated">Read从r中读取结构化的二进制数据到数据中。数据必须是一个固定大小值的指针或固定大小值的片断。从r读取的字节使用指定的字节顺序进行解码,并写入数据的连续字段。当对布尔值进行解码时,零字节被解码为false,任何其他非零字节被解码为true。读入结构体时,跳过带有空白(_)字段名的字段数据;也就是说,空白字段名可以用于填充。当读入结构体时,必须导出所有非空白字段,否则Read可能会恐慌。</target>
        </trans-unit>
        <trans-unit id="13d3208ebb1aa7a1ba1e0de8a255452e3b6f8318" translate="yes" xml:space="preserve">
          <source>Read reads the body of a part, after its headers and before the next part (if any) begins.</source>
          <target state="translated">读取一个部分的主体,在其标题之后,下一个部分(如果有的话)开始之前。</target>
        </trans-unit>
        <trans-unit id="bbca8871624a3fc59330b4b25dd8f3ecce95f77a" translate="yes" xml:space="preserve">
          <source>Read reads the index from r into x; x must not be nil.</source>
          <target state="translated">Read将r的索引读入x,x不能为零。</target>
        </trans-unit>
        <trans-unit id="f50cd5c21ed9fed72a69eacf7363def3849c51d8" translate="yes" xml:space="preserve">
          <source>Read reads the next len(p) bytes from the buffer or until the buffer is drained. The return value n is the number of bytes read. If the buffer has no data to return, err is io.EOF (unless len(p) is zero); otherwise it is nil.</source>
          <target state="translated">Read从缓冲区中读取下一个len(p)字节,或者直到缓冲区耗尽。返回值n是读取的字节数。如果缓冲区没有数据要返回,err为io.EOF(除非len(p)为零);否则为nil。</target>
        </trans-unit>
        <trans-unit id="dd7574617c7b02af539a5115f14c74adf24afa51" translate="yes" xml:space="preserve">
          <source>Read reads the next response from the wire. A valid response might be returned together with an ErrPersistEOF, which means that the remote requested that this be the last request serviced. Read can be called concurrently with Write, but not with another Read.</source>
          <target state="translated">Read从线上读取下一个响应。一个有效的响应可能会和一个ErrPersistEOF一起返回,这意味着远程要求这是最后一个被服务的请求。Read可以与Write同时调用,但不能与另一个Read同时调用。</target>
        </trans-unit>
        <trans-unit id="e877852fb33acd1c13bf6498df79e2e968ae525c" translate="yes" xml:space="preserve">
          <source>Read reads up to len(b) bytes from the File. It returns the number of bytes read and any error encountered. At end of file, Read returns 0, io.EOF.</source>
          <target state="translated">从文件中读取最多 len(b)字节。它返回读取的字节数和遇到的任何错误。在文件结束时,Read返回0,io.EOF。</target>
        </trans-unit>
        <trans-unit id="5d839b22857eca34207c84ba0a055c6ee9c74ec5" translate="yes" xml:space="preserve">
          <source>Read reads up to len(p) bytes into p. It returns the number of bytes read (0 &amp;lt;= n &amp;lt;= len(p)) and any error encountered. Even if Read returns n &amp;lt; len(p), it may use all of p as scratch space during the call. If some data is available but not len(p) bytes, Read conventionally returns what is available instead of waiting for more.</source>
          <target state="translated">读取最多将len（p）个字节读入p。它返回读取的字节数（0 &amp;lt;= n &amp;lt;= len（p））和遇到的任何错误。即使Read返回n &amp;lt;len（p），也可能在调用期间将所有p用作暂存空间。如果某些数据可用，但不是len（p）个字节，按常规，Read将返回可用数据，而不是等待更多数据。</target>
        </trans-unit>
        <trans-unit id="232135a13eb14d8c77efc7e8763b8a54f14d853d" translate="yes" xml:space="preserve">
          <source>Read returns the next request on the wire. An ErrPersistEOF is returned if it is gracefully determined that there are no more requests (e.g. after the first request on an HTTP/1.0 connection, or after a Connection:close on a HTTP/1.1 connection).</source>
          <target state="translated">Read返回线上的下一个请求,如果它被优雅地确定没有更多的请求(例如在HTTP/1.0连接上的第一个请求之后,或者在HTTP/1.0连接上的Connection:close之后,返回一个ErrPersistEOF。如果优雅地确定没有更多的请求,则返回ErrPersistEOF(例如,在HTTP/1.0连接的第一个请求之后,或者在HTTP/1.1连接的Connection:close之后)。</target>
        </trans-unit>
        <trans-unit id="8577ab4df6483a129452d0551a62e50aac1ada00" translate="yes" xml:space="preserve">
          <source>ReadAll</source>
          <target state="translated">ReadAll</target>
        </trans-unit>
        <trans-unit id="c220dc4ba473358c1d6061cf0c9c7708ee93e92a" translate="yes" xml:space="preserve">
          <source>ReadAll reads all the remaining records from r. Each record is a slice of fields. A successful call returns err == nil, not err == io.EOF. Because ReadAll is defined to read until EOF, it does not treat end of file as an error to be reported.</source>
          <target state="translated">ReadAll从r中读取所有剩余的记录,每条记录是一个字段的片断,调用成功后返回err ==nil,而不是err ==io.EOF。调用成功会返回err ==nil,而不是err ==io.EOF。因为ReadAll被定义为读取直到EOF,所以它不会将文件结束作为一个错误来报告。</target>
        </trans-unit>
        <trans-unit id="a2e746d4cfb2608d3ae0cefc64ac787887ba2c28" translate="yes" xml:space="preserve">
          <source>ReadAll reads from r until an error or EOF and returns the data it read. A successful call returns err == nil, not err == EOF. Because ReadAll is defined to read from src until EOF, it does not treat an EOF from Read as an error to be reported.</source>
          <target state="translated">ReadAll从r读取数据,直到出现错误或EOF,并返回读取的数据。成功的调用返回err ==nil,而不是err ==EOF。因为ReadAll被定义为从src读取数据直到EOF,所以它不会将Read的EOF视为一个需要报告的错误。</target>
        </trans-unit>
        <trans-unit id="f4cbf689398d7442e9b49d9483e3d4cc75c10fd1" translate="yes" xml:space="preserve">
          <source>ReadAt implements the io.ReaderAt interface.</source>
          <target state="translated">ReadAt实现了io.ReaderAt接口。</target>
        </trans-unit>
        <trans-unit id="64ae50d9b868e0114af3da28a0f440e42207678f" translate="yes" xml:space="preserve">
          <source>ReadAt reads len(b) bytes from the File starting at byte offset off. It returns the number of bytes read and the error, if any. ReadAt always returns a non-nil error when n &amp;lt; len(b). At end of file, that error is io.EOF.</source>
          <target state="translated">ReadAt从字节偏移量开始从文件读取len（b）个字节。它返回读取的字节数和错误（如果有）。当n &amp;lt;len（b）时，ReadAt始终返回非nil错误。在文件末尾，该错误是io.EOF。</target>
        </trans-unit>
        <trans-unit id="c0bb2352984c400f258aa80aba0c3141b53cce96" translate="yes" xml:space="preserve">
          <source>ReadAt reads len(p) bytes into p starting at offset off in the underlying input source. It returns the number of bytes read (0 &amp;lt;= n &amp;lt;= len(p)) and any error encountered.</source>
          <target state="translated">ReadAt从基础输入源中的offset off处读取len（p）个字节到p中。它返回读取的字节数（0 &amp;lt;= n &amp;lt;= len（p））和遇到的任何错误。</target>
        </trans-unit>
        <trans-unit id="e76e529805447d2ff346a5397f1147a3e02108f4" translate="yes" xml:space="preserve">
          <source>ReadAtLeast</source>
          <target state="translated">ReadAtLeast</target>
        </trans-unit>
        <trans-unit id="dde64f711702d58fa68344cc075ded7169e93092" translate="yes" xml:space="preserve">
          <source>ReadAtLeast reads from r into buf until it has read at least min bytes. It returns the number of bytes copied and an error if fewer bytes were read. The error is EOF only if no bytes were read. If an EOF happens after reading fewer than min bytes, ReadAtLeast returns ErrUnexpectedEOF. If min is greater than the length of buf, ReadAtLeast returns ErrShortBuffer. On return, n &amp;gt;= min if and only if err == nil. If r returns an error having read at least min bytes, the error is dropped.</source>
          <target state="translated">ReadAtLeast从r读取到buf，直到它至少读取了最小字节。它返回复制的字节数，如果读取的字节数少则返回错误。仅当未读取任何字节时，错误才是EOF。如果在读取少于最小字节后发生EOF，则ReadAtLeast返回ErrUnexpectedEOF。如果min大于buf的长度，则ReadAtLeast返回ErrShortBuffer。返回时，当且仅当err == nil时，n&amp;gt; = min。如果r返回至少读取了最小字节的错误，则丢弃该错误。</target>
        </trans-unit>
        <trans-unit id="5eb984a81bf137b794c952d3bb6893f123d7859e" translate="yes" xml:space="preserve">
          <source>ReadBuildInfo returns the build information embedded in the running binary. The information is available only in binaries built with module support.</source>
          <target state="translated">ReadBuildInfo 返回嵌入在运行中的二进制文件中的构建信息。这些信息只有在模块支持下构建的二进制文件中才有。</target>
        </trans-unit>
        <trans-unit id="b60f1ee86705e93ab48e53804a8b6eaae8d1a5a6" translate="yes" xml:space="preserve">
          <source>ReadByte implements the io.ByteReader interface.</source>
          <target state="translated">ReadByte实现了io.ByteReader接口。</target>
        </trans-unit>
        <trans-unit id="d432106a1ae20b1859bbefe8636f0c563d8fc86f" translate="yes" xml:space="preserve">
          <source>ReadByte provides an efficient interface for byte-at-time processing. A Reader that does not implement ByteReader can be wrapped using bufio.NewReader to add this method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88fc89f806641e6821f93c159732d09d121182a0" translate="yes" xml:space="preserve">
          <source>ReadByte reads and returns a single byte. If no byte is available, returns an error.</source>
          <target state="translated">ReadByte读取并返回一个字节。如果没有可用的字节,返回一个错误。</target>
        </trans-unit>
        <trans-unit id="8ccc7f3f4551a8da89db7d7f4659a2bcc7f6f5b1" translate="yes" xml:space="preserve">
          <source>ReadByte reads and returns the next byte from the buffer. If no byte is available, it returns error io.EOF.</source>
          <target state="translated">ReadByte从缓冲区中读取并返回下一个字节。如果没有可用的字节,它将返回错误io.EOF。</target>
        </trans-unit>
        <trans-unit id="159679671477045d937418ced34fc2e8ac5df5f4" translate="yes" xml:space="preserve">
          <source>ReadByte reads and returns the next byte from the input or any error encountered. If ReadByte returns an error, no input byte was consumed, and the returned byte value is undefined.</source>
          <target state="translated">ReadByte读取并返回输入的下一个字节或遇到的任何错误。如果ReadByte返回一个错误,则没有消耗任何输入字节,并且返回的字节值是未定义的。</target>
        </trans-unit>
        <trans-unit id="3d347b2a2e7f91e4c72a8f8310b1aba11bc78e6c" translate="yes" xml:space="preserve">
          <source>ReadBytes reads until the first occurrence of delim in the input, returning a slice containing the data up to and including the delimiter. If ReadBytes encounters an error before finding a delimiter, it returns the data read before the error and the error itself (often io.EOF). ReadBytes returns err != nil if and only if the returned data does not end in delim.</source>
          <target state="translated">ReadBytes 读取直到输入中第一次出现 delim,返回一个包含数据的片断,直到并包括定界符。如果ReadBytes在找到定界符之前遇到了错误,它将返回在错误之前读取的数据和错误本身(通常是io.EOF)。如果且仅当返回的数据不是以 delim 结尾时,ReadBytes 会返回 err !=nil。</target>
        </trans-unit>
        <trans-unit id="aba4d297566c98e6e0d191f056016ef94b731d93" translate="yes" xml:space="preserve">
          <source>ReadBytes reads until the first occurrence of delim in the input, returning a slice containing the data up to and including the delimiter. If ReadBytes encounters an error before finding a delimiter, it returns the data read before the error and the error itself (often io.EOF). ReadBytes returns err != nil if and only if the returned data does not end in delim. For simple uses, a Scanner may be more convenient.</source>
          <target state="translated">ReadBytes 读取直到输入中第一次出现 delim,返回一个包含数据的片断,直到并包括定界符。如果ReadBytes在找到定界符之前遇到了错误,它将返回在错误之前读取的数据和错误本身(通常是io.EOF)。如果且仅当返回的数据不是以 delim 结尾时,ReadBytes 会返回 err !=nil。对于简单的使用,一个Scanner可能更方便。</target>
        </trans-unit>
        <trans-unit id="2f66b132ca8c3970b58c8bfa0ea1a17d65ac03b4" translate="yes" xml:space="preserve">
          <source>ReadCloser is the interface that groups the basic Read and Close methods.</source>
          <target state="translated">ReadCloser 是将基本的读取和关闭方法分组的接口。</target>
        </trans-unit>
        <trans-unit id="db676df84bb4b6b56dfdcd9f6b6ecaede84207b6" translate="yes" xml:space="preserve">
          <source>ReadCodeLine reads a response code line of the form</source>
          <target state="translated">ReadCodeLine读取响应代码行,其形式为</target>
        </trans-unit>
        <trans-unit id="8ff6713d1fd28b36b70ff99ddd8c0b4506ace228" translate="yes" xml:space="preserve">
          <source>ReadContinuedLine reads a possibly continued line from r, eliding the final trailing ASCII white space. Lines after the first are considered continuations if they begin with a space or tab character. In the returned data, continuation lines are separated from the previous line only by a single space: the newline and leading white space are removed.</source>
          <target state="translated">ReadContinuedLine从r中读取可能的续行,省略最后的ASCII空格。如果第一行之后的行以空格或制表符开头,则被认为是延续行。在返回的数据中,延续行与前一行之间只用一个空格隔开:新行和前导空格被删除。</target>
        </trans-unit>
        <trans-unit id="1e5b6ed6dd4e790ba932357704f154ece64c0736" translate="yes" xml:space="preserve">
          <source>ReadContinuedLineBytes is like ReadContinuedLine but returns a []byte instead of a string.</source>
          <target state="translated">ReadContinuedLineBytes与ReadContinuedLine类似,但返回的是[]字节而不是字符串。</target>
        </trans-unit>
        <trans-unit id="5967a3c48bcceae8eab866aea588318eebdf12d2" translate="yes" xml:space="preserve">
          <source>ReadDir</source>
          <target state="translated">ReadDir</target>
        </trans-unit>
        <trans-unit id="e3ffdfb2e99d8ad0f3e485d4bfcbe96628fa0f98" translate="yes" xml:space="preserve">
          <source>ReadDir reads and returns the entire named directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d24fd481881b94b17a7c225ebe811c636d045c9c" translate="yes" xml:space="preserve">
          <source>ReadDir reads the contents of the directory associated with the file f and returns a slice of DirEntry values in directory order. Subsequent calls on the same file will yield later DirEntry records in the directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72f7f069b44009fbb8ef194258dfcf70cde80055" translate="yes" xml:space="preserve">
          <source>ReadDir reads the directory named by dirname and returns a list of directory entries sorted by filename.</source>
          <target state="translated">ReadDir读取以dirname命名的目录,并返回一个按文件名排序的目录条目列表。</target>
        </trans-unit>
        <trans-unit id="a117bc89ee7a58ce94a7bd20601b8394f08f3bdd" translate="yes" xml:space="preserve">
          <source>ReadDir reads the directory named by dirname and returns a list of fs.FileInfo for the directory's contents, sorted by filename. If an error occurs reading the directory, ReadDir returns no directory entries along with the error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b9ccff86903ac2da4f4f24340c2c76e4d2a37b1" translate="yes" xml:space="preserve">
          <source>ReadDir reads the named directory and returns a list of directory entries sorted by filename.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ac52331cecfd61e77a64c6ed3e845672b840901" translate="yes" xml:space="preserve">
          <source>ReadDir reads the named directory, returning all its directory entries sorted by filename. If an error occurs reading the directory, ReadDir returns the entries it was able to read before the error, along with the error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="901b3974155e855f8ae85e1ccd9e42646ec0dfe6" translate="yes" xml:space="preserve">
          <source>ReadDirFS is the interface implemented by a file system that provides an optimized implementation of ReadDir.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e66536e5f97de59d6908b95e869d13fc9d1ef4b6" translate="yes" xml:space="preserve">
          <source>ReadDotBytes reads a dot-encoding and returns the decoded data.</source>
          <target state="translated">ReadDotBytes读取一个点阵编码并返回解码数据。</target>
        </trans-unit>
        <trans-unit id="9fa4950dafc4de63dd721dcb4ac0ca1c8418dcbe" translate="yes" xml:space="preserve">
          <source>ReadDotLines reads a dot-encoding and returns a slice containing the decoded lines, with the final \r\n or \n elided from each.</source>
          <target state="translated">ReadDotLines读取一个点阵编码,并返回一个包含解码行的片断,每个片断都省略了最后的/r/n或/n。</target>
        </trans-unit>
        <trans-unit id="d7fd01a502310e8357802950d90a33ad1c88b094" translate="yes" xml:space="preserve">
          <source>ReadFile</source>
          <target state="translated">ReadFile</target>
        </trans-unit>
        <trans-unit id="ba2198b4c615c842eb050dcdc8f047c40682d77b" translate="yes" xml:space="preserve">
          <source>ReadFile reads and returns the content of the named file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3227226a36d1c67d762cccdcef04ee8eaa0dc15" translate="yes" xml:space="preserve">
          <source>ReadFile reads the file named by filename and returns the contents. A successful call returns err == nil, not err == EOF. Because ReadFile reads the whole file, it does not treat an EOF from Read as an error to be reported.</source>
          <target state="translated">ReadFile读取以filename命名的文件并返回其内容,调用成功后返回err ==nil,而不是err ==EOF。成功的调用将返回err ==nil,而不是err ==EOF。因为ReadFile读取的是整个文件,所以它不会将Read中的EOF作为一个错误来报告。</target>
        </trans-unit>
        <trans-unit id="0184ee306277f6406b88bfbf30c84725887b7b06" translate="yes" xml:space="preserve">
          <source>ReadFile reads the named file and returns the contents. A successful call returns err == nil, not err == EOF. Because ReadFile reads the whole file, it does not treat an EOF from Read as an error to be reported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42ecfa7b59855d0a3784c20dd698c25d1d040885" translate="yes" xml:space="preserve">
          <source>ReadFile reads the named file from the file system fs and returns its contents. A successful call returns a nil error, not io.EOF. (Because ReadFile reads the whole file, the expected EOF from the final Read is not treated as an error to be reported.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c42b448471c62ad479643716bab34e4001debe6" translate="yes" xml:space="preserve">
          <source>ReadFileFS is the interface implemented by a file system that provides an optimized implementation of ReadFile.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af2c9d5288821671fae0d9ea11877f8aa4dfd64b" translate="yes" xml:space="preserve">
          <source>ReadForm parses an entire multipart message whose parts have a Content-Disposition of &quot;form-data&quot;. It stores up to maxMemory bytes + 10MB (reserved for non-file parts) in memory. File parts which can't be stored in memory will be stored on disk in temporary files. It returns ErrMessageTooLarge if all non-file parts can't be stored in memory.</source>
          <target state="translated">ReadForm解析整个多部分消息,其部分的Content-Disposition为 &quot;form-data&quot;。它在内存中最多存储maxMemory字节+10MB(为非文件部分保留)。不能存储在内存中的文件部分将被存储在磁盘的临时文件中。如果所有非文件部分不能存储在内存中,它将返回ErrMessageTooLarge。</target>
        </trans-unit>
        <trans-unit id="1ca77a9c7966395af7bb282b824bc2b56b183684" translate="yes" xml:space="preserve">
          <source>ReadFrom implements io.ReaderFrom.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e93b4927342ab7184e8df9a62d919ab56aa652d" translate="yes" xml:space="preserve">
          <source>ReadFrom implements io.ReaderFrom. If the underlying writer supports the ReadFrom method, and b has no buffered data yet, this calls the underlying ReadFrom without buffering.</source>
          <target state="translated">ReadFrom实现了io.ReaderFrom。如果底层写作者支持ReadFrom方法,并且b还没有缓冲数据,这将调用底层的ReadFrom而不进行缓冲。</target>
        </trans-unit>
        <trans-unit id="deeb7efc315fb646ef56c6fc1f93867b106373b0" translate="yes" xml:space="preserve">
          <source>ReadFrom implements the PacketConn ReadFrom method.</source>
          <target state="translated">ReadFrom实现PacketConn ReadFrom方法。</target>
        </trans-unit>
        <trans-unit id="f608142e8cc80b99bfcbe865eecfbb0322dd6e96" translate="yes" xml:space="preserve">
          <source>ReadFrom implements the io.ReaderFrom ReadFrom method.</source>
          <target state="translated">ReadFrom 实现了 io.ReaderFrom ReadFrom 方法。</target>
        </trans-unit>
        <trans-unit id="00b3806bd8fc8bcfbcad0f6f7f7286cb5b8785f4" translate="yes" xml:space="preserve">
          <source>ReadFrom reads data from r until EOF and appends it to the buffer, growing the buffer as needed. The return value n is the number of bytes read. Any error except io.EOF encountered during the read is also returned. If the buffer becomes too large, ReadFrom will panic with ErrTooLarge.</source>
          <target state="translated">ReadFrom从r中读取数据直到EOF,并将其追加到缓冲区,根据需要增长缓冲区。返回值n是读取的字节数。除了io.EOF之外,在读取过程中遇到的任何错误也会被返回。如果缓冲区变得过大,ReadFrom会用ErrTooLarge恐慌。</target>
        </trans-unit>
        <trans-unit id="6cc11523bdab806a0f9e0e27c50d4a9d778ad3ce" translate="yes" xml:space="preserve">
          <source>ReadFrom reads data from r until EOF or error. The return value n is the number of bytes read. Any error except EOF encountered during the read is also returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="454fdea2d34a8c45cb668b5c543dbc3f7058787c" translate="yes" xml:space="preserve">
          <source>ReadFrom reads data from r until EOF or error. The return value n is the number of bytes read. Any error except io.EOF encountered during the read is also returned.</source>
          <target state="translated">ReadFrom从r中读取数据,直到EOF或出错。返回值n是读取的字节数。除了io.EOF之外,读取过程中遇到的任何错误也会被返回。</target>
        </trans-unit>
        <trans-unit id="ea32f98cbdf74be7e58789bf5c2555022985c09b" translate="yes" xml:space="preserve">
          <source>ReadFromIP acts like ReadFrom but returns an IPAddr.</source>
          <target state="translated">ReadFromIP的行为与ReadFrom类似,但返回的是IPAddr。</target>
        </trans-unit>
        <trans-unit id="95ff932341b82ae81f7960462c1442dddf49af3c" translate="yes" xml:space="preserve">
          <source>ReadFromUDP acts like ReadFrom but returns a UDPAddr.</source>
          <target state="translated">ReadFromUDP的行为与ReadFrom类似,但返回一个UDPAddr。</target>
        </trans-unit>
        <trans-unit id="715d754a562178b348b7a0a9528cfbf66635230e" translate="yes" xml:space="preserve">
          <source>ReadFromUnix acts like ReadFrom but returns a UnixAddr.</source>
          <target state="translated">ReadFromUnix的行为与ReadFrom类似,但返回一个UnixAddr。</target>
        </trans-unit>
        <trans-unit id="6b877746bfc4fdb60829d292eb383e9e72074e71" translate="yes" xml:space="preserve">
          <source>ReadFull</source>
          <target state="translated">ReadFull</target>
        </trans-unit>
        <trans-unit id="f41363ee55bdca4d655d8c43955b9b66f37cac52" translate="yes" xml:space="preserve">
          <source>ReadFull reads exactly len(buf) bytes from r into buf. It returns the number of bytes copied and an error if fewer bytes were read. The error is EOF only if no bytes were read. If an EOF happens after reading some but not all the bytes, ReadFull returns ErrUnexpectedEOF. On return, n == len(buf) if and only if err == nil. If r returns an error having read at least len(buf) bytes, the error is dropped.</source>
          <target state="translated">ReadFull 将 r 的 len(buf)字节准确地读入 buf。它返回复制的字节数,如果读取的字节数较少,则返回错误。只有当没有读到字节时才会出现错误,即EOF。如果在读取部分但不是全部字节后发生EOF,ReadFull返回ErrUnexpectedEOF。返回时,如果且仅当err ==nil时,n ==len(buf)。如果r在读取至少len(buf)字节后返回错误,则错误被丢弃。</target>
        </trans-unit>
        <trans-unit id="4528be7d31ac119b15adb0d44e8e10acc6a61277" translate="yes" xml:space="preserve">
          <source>ReadGCStats reads statistics about garbage collection into stats. The number of entries in the pause history is system-dependent; stats.Pause slice will be reused if large enough, reallocated otherwise. ReadGCStats may use the full capacity of the stats.Pause slice. If stats.PauseQuantiles is non-empty, ReadGCStats fills it with quantiles summarizing the distribution of pause time. For example, if len(stats.PauseQuantiles) is 5, it will be filled with the minimum, 25%, 50%, 75%, and maximum pause times.</source>
          <target state="translated">ReadGCStats将有关垃圾收集的统计数据读取到stats.Pause片中。暂停历史记录的条数与系统有关,如果stats.Pause slice足够大,将被重用,否则将被重新分配。ReadGCStats可能会使用 stats.Pause slice 的全部容量。如果 stats.PauseQuantiles是非空的,ReadGCStats 就会用总结暂停时间分布的量子来填充它。例如,如果len(stats.PauseQuantiles)是5,它将被填充最小、25%、50%、75%和最大的暂停时间。</target>
        </trans-unit>
        <trans-unit id="a6882fab97e53a8d3c4b1deb078269fff567ed19" translate="yes" xml:space="preserve">
          <source>ReadLine is a low-level line-reading primitive. Most callers should use ReadBytes('\n') or ReadString('\n') instead or use a Scanner.</source>
          <target state="translated">ReadLine是一个低级的读行基元,大多数调用者应该使用ReadBytes('\n')或ReadString(\n)来代替,或者使用Scanner。大多数调用者应该使用ReadBytes('\n')或ReadString('\n')来代替或使用Scanner。</target>
        </trans-unit>
        <trans-unit id="70e3e4d68a5bd26786fe6816067d028f52581c71" translate="yes" xml:space="preserve">
          <source>ReadLine reads a single line from r, eliding the final \n or \r\n from the returned string.</source>
          <target state="translated">ReadLine从r中读取一行,从返回的字符串中省略最后的\n或\r\n。</target>
        </trans-unit>
        <trans-unit id="d5bdeff155b2aec65cb49ea2eabeba1181d7c31c" translate="yes" xml:space="preserve">
          <source>ReadLine tries to return a single line, not including the end-of-line bytes. If the line was too long for the buffer then isPrefix is set and the beginning of the line is returned. The rest of the line will be returned from future calls. isPrefix will be false when returning the last fragment of the line. The returned buffer is only valid until the next call to ReadLine. ReadLine either returns a non-nil line or it returns an error, never both.</source>
          <target state="translated">ReadLine试图返回一行,不包括行末字节。如果该行对缓冲区来说太长,那么isPrefix将被设置,并返回该行的开头。当返回行的最后一个片段时,isPrefix将为false。返回的缓冲区只在下次调用ReadLine之前有效。ReadLine要么返回一个非零行,要么返回一个错误,而不是两者兼而有之。</target>
        </trans-unit>
        <trans-unit id="30af98b166430a4d07ac11a60a37dce8c9897d44" translate="yes" xml:space="preserve">
          <source>ReadLineBytes is like ReadLine but returns a []byte instead of a string.</source>
          <target state="translated">ReadLineBytes与ReadLine类似,但返回的是[]字节而不是字符串。</target>
        </trans-unit>
        <trans-unit id="34955aedc1edab445c06914ea85435c83aa1659d" translate="yes" xml:space="preserve">
          <source>ReadMIMEHeader reads a MIME-style header from r. The header is a sequence of possibly continued Key: Value lines ending in a blank line. The returned map m maps CanonicalMIMEHeaderKey(key) to a sequence of values in the same order encountered in the input.</source>
          <target state="translated">ReadMIMEHeader从r中读取一个MIME风格的头,这个头是一个可能持续的Key.Value行的序列,以空行结束。值行,以空行结束。返回的映射m将CanonicalMIMEHeaderKey(key)映射到与输入中遇到的相同顺序的值序列。</target>
        </trans-unit>
        <trans-unit id="e81ba86f59e436daff158e41fbec08f65b2c4f42" translate="yes" xml:space="preserve">
          <source>ReadMemStats populates m with memory allocator statistics.</source>
          <target state="translated">ReadMemStats用内存分配器统计数据填充m。</target>
        </trans-unit>
        <trans-unit id="acb49a6f36fe4a7034527475afbfe7647980d6b9" translate="yes" xml:space="preserve">
          <source>ReadMessage</source>
          <target state="translated">ReadMessage</target>
        </trans-unit>
        <trans-unit id="1551b34da55e8d458cfae44e4a334da9f414dea8" translate="yes" xml:space="preserve">
          <source>ReadMessage reads a message from r. The headers are parsed, and the body of the message will be available for reading from msg.Body.</source>
          <target state="translated">ReadMessage 读取来自 r 的消息,头信息被解析,消息的主体将可从 msg.Body 中读取。</target>
        </trans-unit>
        <trans-unit id="6f05b0c16954598270f35347bda5383a6c522b11" translate="yes" xml:space="preserve">
          <source>ReadMsgIP reads a message from c, copying the payload into b and the associated out-of-band data into oob. It returns the number of bytes copied into b, the number of bytes copied into oob, the flags that were set on the message and the source address of the message.</source>
          <target state="translated">ReadMsgIP从c中读取一条消息,将有效载荷复制到b中,将相关的带外数据复制到ob中。它返回复制到b中的字节数,复制到ob中的字节数,在消息上设置的标志和消息的源地址。</target>
        </trans-unit>
        <trans-unit id="47bd88248b7a6aeb9fe7003935965fcbc4c14b6e" translate="yes" xml:space="preserve">
          <source>ReadMsgUDP reads a message from c, copying the payload into b and the associated out-of-band data into oob. It returns the number of bytes copied into b, the number of bytes copied into oob, the flags that were set on the message and the source address of the message.</source>
          <target state="translated">ReadMsgUDP从c中读取一条消息,将有效载荷复制到b中,将相关的带外数据复制到ob中。它返回复制到b中的字节数、复制到ob中的字节数、在消息上设置的标志和消息的源地址。</target>
        </trans-unit>
        <trans-unit id="f80f0770ba07805dfad9fed9021802994b16c79f" translate="yes" xml:space="preserve">
          <source>ReadMsgUnix reads a message from c, copying the payload into b and the associated out-of-band data into oob. It returns the number of bytes copied into b, the number of bytes copied into oob, the flags that were set on the message and the source address of the message.</source>
          <target state="translated">ReadMsgUnix从c中读取一条消息,将有效载荷复制到b中,将相关的带外数据复制到ob中。它返回复制到b中的字节数,复制到ob中的字节数,在消息上设置的标志和消息的源地址。</target>
        </trans-unit>
        <trans-unit id="25bb46ad3055b508b0608be3bcb05d4dc7a218ac" translate="yes" xml:space="preserve">
          <source>ReadRequest is a low-level function and should only be used for specialized applications; most code should use the Server to read requests and handle them via the Handler interface. ReadRequest only supports HTTP/1.x requests. For HTTP/2, use golang.org/x/net/http2.</source>
          <target state="translated">ReadRequest是一个低级函数,只应该用于专门的应用程序;大多数代码应该使用Server来读取请求,并通过Handler接口处理它们。ReadRequest只支持HTTP/1.x请求。对于HTTP/2,请使用golang.org/x/net/http2。</target>
        </trans-unit>
        <trans-unit id="b1b66f29f0f459c92aabcbebb68a77d5a6970744" translate="yes" xml:space="preserve">
          <source>ReadRequest reads and parses an incoming request from b.</source>
          <target state="translated">ReadRequest读取并解析来自b的传入请求。</target>
        </trans-unit>
        <trans-unit id="25d27159145d0774b1fadc397fe48b995c46c5de" translate="yes" xml:space="preserve">
          <source>ReadResponse reads a multi-line response of the form:</source>
          <target state="translated">ReadResponse读取形式为多行的响应。</target>
        </trans-unit>
        <trans-unit id="ee99ce8c11934415337cdc7bec2e604ef18e71ae" translate="yes" xml:space="preserve">
          <source>ReadResponse reads and returns an HTTP response from r. The req parameter optionally specifies the Request that corresponds to this Response. If nil, a GET request is assumed. Clients must call resp.Body.Close when finished reading resp.Body. After that call, clients can inspect resp.Trailer to find key/value pairs included in the response trailer.</source>
          <target state="translated">ReadResponse 读取并返回来自 r 的 HTTP 响应,req 参数可选择指定与该响应对应的 Request。如果为nil,则假定为GET请求。客户端在读取完resp.Body后必须调用resp.Body.Close。在该调用之后,客户端可以检查resp.Trailer来查找响应预告片中包含的键/值对。</target>
        </trans-unit>
        <trans-unit id="476255423e82d011c96cc157a1f2c1336b3b2a0a" translate="yes" xml:space="preserve">
          <source>ReadRune implements the io.RuneReader interface.</source>
          <target state="translated">ReadRune实现了io.RuneReader接口。</target>
        </trans-unit>
        <trans-unit id="2149703d832b9af2c76dd9abfe510fdf6ec21b40" translate="yes" xml:space="preserve">
          <source>ReadRune reads a single UTF-8 encoded Unicode character and returns the rune and its size in bytes. If no character is available, err will be set.</source>
          <target state="translated">ReadRune读取一个UTF-8编码的Unicode字符,并返回符文和它的字节数。如果没有可用的字符,将设置err。</target>
        </trans-unit>
        <trans-unit id="6414ea883495287275cdc53b35ffd14e0008ac3b" translate="yes" xml:space="preserve">
          <source>ReadRune reads a single UTF-8 encoded Unicode character and returns the rune and its size in bytes. If the encoded rune is invalid, it consumes one byte and returns unicode.ReplacementChar (U+FFFD) with a size of 1.</source>
          <target state="translated">ReadRune读取一个UTF-8编码的Unicode字符,并以字节为单位返回符文和它的大小,如果编码的符文无效,则消耗一个字节并返回大小为1的unicode.ReplaceChar(U+FFFD)。如果编码后的符文无效,则消耗一个字节并返回大小为1的unicode.ReplaceterChar(U+FFFD)。</target>
        </trans-unit>
        <trans-unit id="6486828e56b295be35e03a3674dd21e96b49a79c" translate="yes" xml:space="preserve">
          <source>ReadRune reads and returns the next UTF-8-encoded Unicode code point from the buffer. If no bytes are available, the error returned is io.EOF. If the bytes are an erroneous UTF-8 encoding, it consumes one byte and returns U+FFFD, 1.</source>
          <target state="translated">ReadRune从缓冲区中读取并返回下一个UTF-8编码的Unicode码点。如果没有可用的字节,返回的错误是io.EOF。如果字节是错误的UTF-8编码,则消耗一个字节并返回U+FFFD,1。</target>
        </trans-unit>
        <trans-unit id="27b545019c29fef4339b5d0234bb596b1ca821e9" translate="yes" xml:space="preserve">
          <source>ReadSeekCloser is the interface that groups the basic Read, Seek and Close methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78176debea1a291ba3e7ca916182c7ec7d43ab66" translate="yes" xml:space="preserve">
          <source>ReadSeeker is the interface that groups the basic Read and Seek methods.</source>
          <target state="translated">ReadSeeker是对基本的Read和Seek方法进行分组的接口。</target>
        </trans-unit>
        <trans-unit id="6f83dddca1aa94fb6e401f10df5bd11c4e328c97" translate="yes" xml:space="preserve">
          <source>ReadSlice reads until the first occurrence of delim in the input, returning a slice pointing at the bytes in the buffer. The bytes stop being valid at the next read. If ReadSlice encounters an error before finding a delimiter, it returns all the data in the buffer and the error itself (often io.EOF). ReadSlice fails with error ErrBufferFull if the buffer fills without a delim. Because the data returned from ReadSlice will be overwritten by the next I/O operation, most clients should use ReadBytes or ReadString instead. ReadSlice returns err != nil if and only if line does not end in delim.</source>
          <target state="translated">ReadSlice读取直到输入中第一次出现delim,返回一个指向缓冲区中字节的slice。这些字节在下一次读取时停止有效。如果ReadSlice在找到定界符之前遇到了错误,它将返回缓冲区中的所有数据和错误本身(通常是io.EOF)。如果缓冲区在没有找到定界符的情况下被填满,ReadSlice就会以ErrBufferFull错误失败。因为ReadSlice返回的数据会被下一个I/O操作覆盖,所以大多数客户端应该使用ReadBytes或ReadString来代替。如果且仅当行没有以 delim 结尾时,ReadSlice 会返回 err !=nil。</target>
        </trans-unit>
        <trans-unit id="396715e6dd5c32bdbbf83af9027e47c30dc1faa8" translate="yes" xml:space="preserve">
          <source>ReadString reads until the first occurrence of delim in the input, returning a string containing the data up to and including the delimiter. If ReadString encounters an error before finding a delimiter, it returns the data read before the error and the error itself (often io.EOF). ReadString returns err != nil if and only if the returned data does not end in delim.</source>
          <target state="translated">ReadString 读取直到输入中第一次出现 delim,返回一个包含数据的字符串,直到并包括定界符。如果ReadString在找到定界符之前遇到了错误,它将返回在错误之前读取的数据和错误本身(通常是io.EOF)。如果且仅当返回的数据不是以 delim 结尾时,ReadString 会返回 err !=nil。</target>
        </trans-unit>
        <trans-unit id="aaa3e0c7b34f04c5ff175180dbf3748d0757b57f" translate="yes" xml:space="preserve">
          <source>ReadString reads until the first occurrence of delim in the input, returning a string containing the data up to and including the delimiter. If ReadString encounters an error before finding a delimiter, it returns the data read before the error and the error itself (often io.EOF). ReadString returns err != nil if and only if the returned data does not end in delim. For simple uses, a Scanner may be more convenient.</source>
          <target state="translated">ReadString 读取直到输入中第一次出现 delim,返回一个包含数据的字符串,直到并包括定界符。如果ReadString在找到定界符之前遇到了错误,它将返回在错误之前读取的数据和错误本身(通常是io.EOF)。如果且仅当返回的数据不以 delim 结尾时,ReadString 会返回 err !=nil。对于简单的使用,一个Scanner可能更方便。</target>
        </trans-unit>
        <trans-unit id="24714d7c8185be718fff60550f6b7e029b2b159c" translate="yes" xml:space="preserve">
          <source>ReadTrace returns the next chunk of binary tracing data, blocking until data is available. If tracing is turned off and all the data accumulated while it was on has been returned, ReadTrace returns nil. The caller must copy the returned data before calling ReadTrace again. ReadTrace must be called from one goroutine at a time.</source>
          <target state="translated">ReadTrace 返回下一个二进制跟踪数据块,阻塞直到数据可用。如果跟踪被关闭,并且所有在开启时积累的数据都已返回,ReadTrace返回nil。调用者必须在再次调用ReadTrace之前复制返回的数据。ReadTrace必须一次从一个goroutine调用。</target>
        </trans-unit>
        <trans-unit id="989bf43b9a2dfe020990e99dd409325328b3ade3" translate="yes" xml:space="preserve">
          <source>ReadUvarint reads an encoded unsigned integer from r and returns it as a uint64.</source>
          <target state="translated">ReadUvarint从r中读取一个编码的无符号整数,并将其作为一个uint64返回。</target>
        </trans-unit>
        <trans-unit id="675541f596de4c802da653f83b46f8b7718858d0" translate="yes" xml:space="preserve">
          <source>ReadVarint reads an encoded signed integer from r and returns it as an int64.</source>
          <target state="translated">ReadVarint从r中读取一个编码的有符号整数,并以int64的形式返回。</target>
        </trans-unit>
        <trans-unit id="069fcaa32c060bf9bd8bfac5e82274aaead1bc50" translate="yes" xml:space="preserve">
          <source>ReadWriteCloser is the interface that groups the basic Read, Write and Close methods.</source>
          <target state="translated">ReadWriteCloser是将基本的读、写和关闭方法分组的接口。</target>
        </trans-unit>
        <trans-unit id="341b30c9c3b78089bcaa44b8a26a94b9bc0c8ea6" translate="yes" xml:space="preserve">
          <source>ReadWriteSeeker is the interface that groups the basic Read, Write and Seek methods.</source>
          <target state="translated">ReadWriteSeeker是将基本的Read、Write和Seek方法分组的接口。</target>
        </trans-unit>
        <trans-unit id="eb7ce11fb3f6f0101cd6b5288463e8de90a96b51" translate="yes" xml:space="preserve">
          <source>ReadWriter is the interface that groups the basic Read and Write methods.</source>
          <target state="translated">ReadWriter是将基本的读和写方法分组的接口。</target>
        </trans-unit>
        <trans-unit id="dfaac4087d8cb10eb5b8f29ddefebdcafd42a5af" translate="yes" xml:space="preserve">
          <source>ReadWriter stores pointers to a Reader and a Writer. It implements io.ReadWriter.</source>
          <target state="translated">ReadWriter存储了一个Reader和一个Writer的指针。它实现了io.ReadWriter。</target>
        </trans-unit>
        <trans-unit id="79f16a4d9874784deac866dfbd0ce6545be6e239" translate="yes" xml:space="preserve">
          <source>Readdir reads the contents of the directory associated with file and returns a slice of up to n FileInfo values, as would be returned by Lstat, in directory order. Subsequent calls on the same file will yield further FileInfos.</source>
          <target state="translated">Readdir 读取与文件相关联的目录的内容,并按目录顺序返回一个最多 n 个 FileInfo 值的片断,就像 Lstat 所返回的那样。随后对同一文件的调用将产生更多的FileInfos。</target>
        </trans-unit>
        <trans-unit id="501d22e73b2af73a4cd2cda27f0147a879d2d29f" translate="yes" xml:space="preserve">
          <source>Readdirnames reads the contents of the directory associated with file and returns a slice of up to n names of files in the directory, in directory order. Subsequent calls on the same file will yield further names.</source>
          <target state="translated">Readdirnames读取与文件相关联的目录的内容,并按照目录顺序返回目录中最多n个文件名称的片断。随后对同一文件的调用将产生更多的文件名。</target>
        </trans-unit>
        <trans-unit id="ac5bbe8292ed1b69e0f95e5bdaa035569a295fd7" translate="yes" xml:space="preserve">
          <source>Reader</source>
          <target state="translated">Reader</target>
        </trans-unit>
        <trans-unit id="a764e12131a971febc3401d23317f0234b4049b8" translate="yes" xml:space="preserve">
          <source>Reader (Options)</source>
          <target state="translated">读者(选项)</target>
        </trans-unit>
        <trans-unit id="df3472ca3dd5a57262b56d74dcad15e820ebf2eb" translate="yes" xml:space="preserve">
          <source>Reader implements buffering for an io.Reader object.</source>
          <target state="translated">Reader为一个io.Reader对象实现了缓冲。</target>
        </trans-unit>
        <trans-unit id="96784a034a712bc8c815b4587872dbfdfd0582a9" translate="yes" xml:space="preserve">
          <source>Reader is a global, shared instance of a cryptographically secure random number generator.</source>
          <target state="translated">Reader是一个全局的、共享的加密安全随机数生成器实例。</target>
        </trans-unit>
        <trans-unit id="bf613e0e0a803852368392b2dfe7b4682657c458" translate="yes" xml:space="preserve">
          <source>Reader is a quoted-printable decoder.</source>
          <target state="translated">Reader是一个可引用打印的解码器。</target>
        </trans-unit>
        <trans-unit id="b49691ad8407ed7de43e614957e75ec4095c4b28" translate="yes" xml:space="preserve">
          <source>Reader is an iterator over parts in a MIME multipart body. Reader's underlying parser consumes its input as needed. Seeking isn't supported.</source>
          <target state="translated">Reader是一个迭代MIME多部分主体的迭代器。Reader的底层解析器根据需要消耗它的输入。不支持寻找。</target>
        </trans-unit>
        <trans-unit id="21dadd14b38a36c18741cf2c47ad38cb0675eedf" translate="yes" xml:space="preserve">
          <source>Reader is the interface that wraps the basic Read method.</source>
          <target state="translated">Reader是包装基本Read方法的接口。</target>
        </trans-unit>
        <trans-unit id="9bdf18ff83881db62f68bf47e6ac4c6f41d55f66" translate="yes" xml:space="preserve">
          <source>Reader provides sequential access to the contents of a tar archive. Reader.Next advances to the next file in the archive (including the first), and then Reader can be treated as an io.Reader to access the file's data.</source>
          <target state="translated">Reader提供了对tar压缩文件内容的顺序访问。Reader.Next前进到存档中的下一个文件(包括第一个),然后Reader可以被当作io.Reader来访问文件的数据。</target>
        </trans-unit>
        <trans-unit id="cac70aa62b26f1281fbe4d19090a262412eed7e3" translate="yes" xml:space="preserve">
          <source>Reader returns a new Reader for Data. The reader is positioned at byte offset 0 in the DWARF &amp;ldquo;info&amp;rdquo; section.</source>
          <target state="translated">Reader返回一个新的Data Reader。阅读器位于DWARF&amp;ldquo;信息&amp;rdquo;部分的字节偏移量0处。</target>
        </trans-unit>
        <trans-unit id="8049ec93e81c7083091b44ed801d9d9d92c309d9" translate="yes" xml:space="preserve">
          <source>Reader, to read numeric response code lines, key: value headers, lines wrapped with leading spaces on continuation lines, and whole text blocks ending with a dot on a line by itself.</source>
          <target state="translated">读取器,用于读取数字响应码行、键:值头、续行上用前导空格包裹的行、以及行上以点自行结束的整个文本块。</target>
        </trans-unit>
        <trans-unit id="d0009a603321ffa4322fc5ace74c08013f3502dc" translate="yes" xml:space="preserve">
          <source>Reader.Len</source>
          <target state="translated">Reader.Len</target>
        </trans-unit>
        <trans-unit id="52b9ae6b2c685e2a877bd9bbf8defead7e5d5ac7" translate="yes" xml:space="preserve">
          <source>Reader.Multistream</source>
          <target state="translated">Reader.Multistream</target>
        </trans-unit>
        <trans-unit id="23e9cef150e9609032f02dcc6e3ec9a05ca806c3" translate="yes" xml:space="preserve">
          <source>Reader.ReadAll</source>
          <target state="translated">Reader.ReadAll</target>
        </trans-unit>
        <trans-unit id="976c7b59d336efab6bbe07f071aa8d432cb7a047" translate="yes" xml:space="preserve">
          <source>ReaderAt is the interface that wraps the basic ReadAt method.</source>
          <target state="translated">ReaderAt是包装基本ReadAt方法的接口。</target>
        </trans-unit>
        <trans-unit id="29ae6f40e1ba95a55db0a9760f63eada1ab4e398" translate="yes" xml:space="preserve">
          <source>ReaderFrom is the interface that wraps the ReadFrom method.</source>
          <target state="translated">ReaderFrom是封装ReadFrom方法的接口。</target>
        </trans-unit>
        <trans-unit id="b5bdadfe357edf2d398dc3767642063de731a14c" translate="yes" xml:space="preserve">
          <source>Readlink returns the destination of the named symbolic link. If there is an error, it will be of type *PathError.</source>
          <target state="translated">Readlink返回命名的符号链接的目的地。如果有错误,它的类型是*PathError。</target>
        </trans-unit>
        <trans-unit id="3680e45cb759e7b231139c55beb835dcb36f290f" translate="yes" xml:space="preserve">
          <source>Reads and Writes on the pipe are matched one to one except when multiple Reads are needed to consume a single Write. That is, each Write to the PipeWriter blocks until it has satisfied one or more Reads from the PipeReader that fully consume the written data. The data is copied directly from the Write to the corresponding Read (or Reads); there is no internal buffering.</source>
          <target state="translated">管道上的读和写是一对一匹配的,除非需要多个读来消耗一个写。也就是说,对PipeWriter的每个Write都会阻塞,直到它满足了一个或多个来自PipeReader的Reads,完全消耗了所写数据。数据直接从Write复制到相应的Read(或Reads),没有内部缓冲。</target>
        </trans-unit>
        <trans-unit id="96964e0a893395e3b89017fa3370fe50203e0f58" translate="yes" xml:space="preserve">
          <source>Real returns the real part of x, which must be a numeric or unknown value. If x is Unknown, the result is Unknown.</source>
          <target state="translated">Real 返回 x 的实数部分,它必须是一个数值或未知值。如果x是未知值,结果是未知值。</target>
        </trans-unit>
        <trans-unit id="a4e7e73832091a1dd0eb45c5e3535f9fc0bb0385" translate="yes" xml:space="preserve">
          <source>ReceiverName returns the receiver type name of this symbol, or the empty string if there is none.</source>
          <target state="translated">ReceiverName 返回这个符号的接收器类型名称,如果没有,则返回空字符串。</target>
        </trans-unit>
        <trans-unit id="76042968d1a5f484d7ec99013213446b06dc9be8" translate="yes" xml:space="preserve">
          <source>Receivers should be careful to use Equal to compare MACs in order to avoid timing side-channels:</source>
          <target state="translated">接收机应注意使用Equal来比较MAC,以避免定时侧信道。</target>
        </trans-unit>
        <trans-unit id="baede57b4fd75bbaf39e019c76771e5b57cbf06e" translate="yes" xml:space="preserve">
          <source>RecordHeaderError is returned when a TLS record header is invalid.</source>
          <target state="translated">当TLS记录头无效时,将返回RecordHeaderError。</target>
        </trans-unit>
        <trans-unit id="2614b13193f400f1a9992deddc528f2f896c1029" translate="yes" xml:space="preserve">
          <source>Rect is shorthand for Rectangle{Pt(x0, y0), Pt(x1, y1)}. The returned rectangle has minimum and maximum coordinates swapped if necessary so that it is well-formed.</source>
          <target state="translated">Rect 是 Rectangle{Pt(x0,y0),Pt(x1,y1)}的简写。返回的矩形的最小和最大坐标在必要时被调换,所以它的形状很好。</target>
        </trans-unit>
        <trans-unit id="1937bfd09178388c39ec43cf08d134d3d9d1898f" translate="yes" xml:space="preserve">
          <source>Rect returns the complex number x with polar coordinates r, &amp;theta;.</source>
          <target state="translated">Rect返回具有极坐标r，&amp;theta;的复数x。</target>
        </trans-unit>
        <trans-unit id="94dab483158e13564ee6a455c353913588b6dbd1" translate="yes" xml:space="preserve">
          <source>Recv receives and returns a value from the channel v. It panics if v's Kind is not Chan. The receive blocks until a value is ready. The boolean value ok is true if the value x corresponds to a send on the channel, false if it is a zero value received because the channel is closed.</source>
          <target state="translated">Recv从通道v中接收并返回一个值,如果v的Kind不是Chan,它就会恐慌。receive会阻塞,直到一个值准备好。如果值x对应于通道上的发送,则布尔值ok为真,如果因为通道关闭而接收到的是一个零值,则为假。</target>
        </trans-unit>
        <trans-unit id="03b8f406324956c22ef3f439d41bfd0bef6159ba" translate="yes" xml:space="preserve">
          <source>Recv returns the receiver of signature s (if a method), or nil if a function. It is ignored when comparing signatures for identity.</source>
          <target state="translated">Recv 返回签名 s 的接收者(如果是方法),如果是函数,则返回 nil。在比较身份的签名时,它被忽略。</target>
        </trans-unit>
        <trans-unit id="5ae5c546dd23f367221f8f4d367950523d9cf3bb" translate="yes" xml:space="preserve">
          <source>Recv returns the type of x in x.f.</source>
          <target state="translated">Recv返回x.f中x的类型。</target>
        </trans-unit>
        <trans-unit id="b921a74df750022333aabad842917542b9bf6fc4" translate="yes" xml:space="preserve">
          <source>Redacted is like String but replaces any password with &quot;xxxxx&quot;. Only the password in u.URL is redacted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9250d7c2a971eb24cc4eedcfff481ae3439946cf" translate="yes" xml:space="preserve">
          <source>Redirect replies to the request with a redirect to url, which may be a path relative to the request path.</source>
          <target state="translated">重定向以重定向到url的方式回复请求,这个url可以是相对于请求路径的路径。</target>
        </trans-unit>
        <trans-unit id="c909a75a26a89b05691be1108e0ab3c2e1bcdb1a" translate="yes" xml:space="preserve">
          <source>RedirectHandler returns a request handler that redirects each request it receives to the given url using the given status code.</source>
          <target state="translated">RedirectHandler返回一个请求处理程序,该处理程序使用给定的状态码将收到的每个请求重定向到给定的url。</target>
        </trans-unit>
        <trans-unit id="9d1e4e7d27b519b1da3d7266c9c87d7861741080" translate="yes" xml:space="preserve">
          <source>References:</source>
          <target state="translated">References:</target>
        </trans-unit>
        <trans-unit id="d6ec8155461c38d823e4b635ac46022ba360bb68" translate="yes" xml:space="preserve">
          <source>Referer is misspelled as in the request itself, a mistake from the earliest days of HTTP. This value can also be fetched from the Header map as Header[&quot;Referer&quot;]; the benefit of making it available as a method is that the compiler can diagnose programs that use the alternate (correct English) spelling req.Referrer() but cannot diagnose programs that use Header[&quot;Referrer&quot;].</source>
          <target state="translated">Referer在请求本身中拼写错误,这是HTTP最早时期的错误。这个值也可以作为Header[&quot;Referer&quot;]从Header map中获取;把它作为方法提供的好处是,编译器可以诊断出使用备用(正确的英文)拼写req.Referer()的程序,但不能诊断出使用Header[&quot;Referer&quot;]的程序。</target>
        </trans-unit>
        <trans-unit id="07d5e3dfcd70520a1bbdb2fa9dbe2bae91c99a57" translate="yes" xml:space="preserve">
          <source>Referer returns the referring URL, if sent in the request.</source>
          <target state="translated">Referer返回引用的URL(如果在请求中发送)。</target>
        </trans-unit>
        <trans-unit id="6ac251dfde6b7c655d39dbc21c40c658e7f0e5ba" translate="yes" xml:space="preserve">
          <source>Regardless of the verb, if an operand is an interface value, the internal concrete value is used, not the interface itself. Thus:</source>
          <target state="translated">不管是哪个动词,如果操作数是接口值,则使用内部具体值,而不是接口本身。因此:</target>
        </trans-unit>
        <trans-unit id="ae8b91c59ed7a48ada5b7396ec353e27cc7c57cd" translate="yes" xml:space="preserve">
          <source>Regexp is the representation of a compiled regular expression. A Regexp is safe for concurrent use by multiple goroutines, except for configuration methods, such as Longest.</source>
          <target state="translated">Regexp是编译后的正则表达式的表示。一个Regexp可以被多个goroutine安全地并发使用,但配置方法除外,比如Longest。</target>
        </trans-unit>
        <trans-unit id="b84f40722bc57d5dce890a8a11e5c4fee08f3c9c" translate="yes" xml:space="preserve">
          <source>Regexp.Expand</source>
          <target state="translated">Regexp.Expand</target>
        </trans-unit>
        <trans-unit id="3dd017106e6cb747b2a0cd305e5bb9fdade3a8d1" translate="yes" xml:space="preserve">
          <source>Regexp.ExpandString</source>
          <target state="translated">Regexp.ExpandString</target>
        </trans-unit>
        <trans-unit id="ec3956758c005d81eaf9415a4c61a2390b4ec0f2" translate="yes" xml:space="preserve">
          <source>Regexp.Find</source>
          <target state="translated">Regexp.Find</target>
        </trans-unit>
        <trans-unit id="5a4d1168fbbea65dfa0185be8ce3c71cdc597f4b" translate="yes" xml:space="preserve">
          <source>Regexp.FindAll</source>
          <target state="translated">Regexp.FindAll</target>
        </trans-unit>
        <trans-unit id="c5811b80e718b804e1204a3871c02f744194e46b" translate="yes" xml:space="preserve">
          <source>Regexp.FindAllIndex</source>
          <target state="translated">Regexp.FindAllIndex</target>
        </trans-unit>
        <trans-unit id="9a7a55d789a0b84db34a38b56a2f4242a4cf127c" translate="yes" xml:space="preserve">
          <source>Regexp.FindAllString</source>
          <target state="translated">Regexp.FindAllString</target>
        </trans-unit>
        <trans-unit id="f7e56583e4dcc297ccf2aa23c322191411764c7e" translate="yes" xml:space="preserve">
          <source>Regexp.FindAllStringSubmatch</source>
          <target state="translated">Regexp.FindAllStringSubmatch</target>
        </trans-unit>
        <trans-unit id="e4337ecbd053cf4beaa55b4111d3d25165c547a3" translate="yes" xml:space="preserve">
          <source>Regexp.FindAllStringSubmatchIndex</source>
          <target state="translated">Regexp.FindAllStringSubmatchIndex</target>
        </trans-unit>
        <trans-unit id="55182b4c005261d0e66f0c8c4df35946648e43bd" translate="yes" xml:space="preserve">
          <source>Regexp.FindAllSubmatch</source>
          <target state="translated">Regexp.FindAllSubmatch</target>
        </trans-unit>
        <trans-unit id="752406799d805cf76b21ac4473155fcd9c435cf1" translate="yes" xml:space="preserve">
          <source>Regexp.FindAllSubmatchIndex</source>
          <target state="translated">Regexp.FindAllSubmatchIndex</target>
        </trans-unit>
        <trans-unit id="ca21e70b0b76817fc6bc10e7f6cc4170f855d5aa" translate="yes" xml:space="preserve">
          <source>Regexp.FindIndex</source>
          <target state="translated">Regexp.FindIndex</target>
        </trans-unit>
        <trans-unit id="21fdf1e48587944dc1c11b68645cfe5138e0b116" translate="yes" xml:space="preserve">
          <source>Regexp.FindString</source>
          <target state="translated">Regexp.FindString</target>
        </trans-unit>
        <trans-unit id="dc52dbc2324ccd5021b173c341b811e2472a4206" translate="yes" xml:space="preserve">
          <source>Regexp.FindStringIndex</source>
          <target state="translated">Regexp.FindStringIndex</target>
        </trans-unit>
        <trans-unit id="a2b5fabc1cf5de45d659c3142098c4fde4339cdc" translate="yes" xml:space="preserve">
          <source>Regexp.FindStringSubmatch</source>
          <target state="translated">Regexp.FindStringSubmatch</target>
        </trans-unit>
        <trans-unit id="e27002b196cee520413e84f76c97dc77b353b852" translate="yes" xml:space="preserve">
          <source>Regexp.FindSubmatch</source>
          <target state="translated">Regexp.FindSubmatch</target>
        </trans-unit>
        <trans-unit id="fec6de782af8c1c02211813d203aef224fcb0882" translate="yes" xml:space="preserve">
          <source>Regexp.FindSubmatchIndex</source>
          <target state="translated">Regexp.FindSubmatchIndex</target>
        </trans-unit>
        <trans-unit id="9a2ff01cdd93ba73a6c7e52b6f4aa5baac4a6940" translate="yes" xml:space="preserve">
          <source>Regexp.Longest</source>
          <target state="translated">Regexp.Longest</target>
        </trans-unit>
        <trans-unit id="0008582d6bb9067aadd263f03da910a66e6e0e19" translate="yes" xml:space="preserve">
          <source>Regexp.Match</source>
          <target state="translated">Regexp.Match</target>
        </trans-unit>
        <trans-unit id="2c0eada8b9cfbb5d24aadca2e8fa445cbe3b7e2b" translate="yes" xml:space="preserve">
          <source>Regexp.MatchString</source>
          <target state="translated">Regexp.MatchString</target>
        </trans-unit>
        <trans-unit id="a15c3526305a73e97c8461348cc47b4634011556" translate="yes" xml:space="preserve">
          <source>Regexp.NumSubexp</source>
          <target state="translated">Regexp.NumSubexp</target>
        </trans-unit>
        <trans-unit id="add2b36777d2133814845c70e8cb4211b4283aa6" translate="yes" xml:space="preserve">
          <source>Regexp.ReplaceAll</source>
          <target state="translated">Regexp.ReplaceAll</target>
        </trans-unit>
        <trans-unit id="4c687a2a42e7f3d60c9f98f0993362b9c2735490" translate="yes" xml:space="preserve">
          <source>Regexp.ReplaceAllLiteralString</source>
          <target state="translated">Regexp.ReplaceAllLiteralString</target>
        </trans-unit>
        <trans-unit id="9fececaf13096d7dc9ffe3d2d93e25169cf762e1" translate="yes" xml:space="preserve">
          <source>Regexp.ReplaceAllString</source>
          <target state="translated">Regexp.ReplaceAllString</target>
        </trans-unit>
        <trans-unit id="5f97458d8e33d7f5f2c52b953c172d5ccb890b23" translate="yes" xml:space="preserve">
          <source>Regexp.ReplaceAllStringFunc</source>
          <target state="translated">Regexp.ReplaceAllStringFunc</target>
        </trans-unit>
        <trans-unit id="60f05fd13196ffa4dd89663cf41abb4f862a263c" translate="yes" xml:space="preserve">
          <source>Regexp.Split</source>
          <target state="translated">Regexp.Split</target>
        </trans-unit>
        <trans-unit id="4cd159d81359cd6aaae754a6f32c4b3350801c2a" translate="yes" xml:space="preserve">
          <source>Regexp.SubexpIndex</source>
          <target state="translated">Regexp.SubexpIndex</target>
        </trans-unit>
        <trans-unit id="b36b7852ff6e5f89fe309ce0324c7c9f6dac2ab6" translate="yes" xml:space="preserve">
          <source>Regexp.SubexpNames</source>
          <target state="translated">Regexp.SubexpNames</target>
        </trans-unit>
        <trans-unit id="96a2105b6d183387bea55013dc84567e629210a2" translate="yes" xml:space="preserve">
          <source>Region is a region of code whose execution time interval is traced.</source>
          <target state="translated">Region是指执行时间间隔被追踪的代码区域。</target>
        </trans-unit>
        <trans-unit id="95c213e4f5521f3f5195554245abca05424ff590" translate="yes" xml:space="preserve">
          <source>Register makes a database driver available by the provided name. If Register is called twice with the same name or if driver is nil, it panics.</source>
          <target state="translated">Register通过提供的名称提供一个数据库驱动程序。如果Register被调用了两次相同的名字,或者如果driver为nil,它就会崩溃。</target>
        </trans-unit>
        <trans-unit id="64aef767785d208425e3e70c5d2194fcd9c84c85" translate="yes" xml:space="preserve">
          <source>Register publishes in the server the set of methods of the receiver value that satisfy the following conditions:</source>
          <target state="translated">Register在服务器上发布满足以下条件的接收值的方法集。</target>
        </trans-unit>
        <trans-unit id="cbe295e9d864bc0bca7f28c205cb5395eba55d05" translate="yes" xml:space="preserve">
          <source>Register publishes the receiver's methods in the DefaultServer.</source>
          <target state="translated">注册在DefaultServer中发布接收器的方法。</target>
        </trans-unit>
        <trans-unit id="c181d095749a9fa33757c1798befea770ef8d4eb" translate="yes" xml:space="preserve">
          <source>Register records a type, identified by a value for that type, under its internal type name. That name will identify the concrete type of a value sent or received as an interface variable. Only types that will be transferred as implementations of interface values need to be registered. Expecting to be used only during initialization, it panics if the mapping between types and names is not a bijection.</source>
          <target state="translated">注册表在其内部类型名下记录一个类型,由该类型的值来标识。该名称将标识作为接口变量发送或接收的值的具体类型。只有那些将作为接口值的实现而被传输的类型才需要被注册。期待只在初始化期间使用,如果类型和名称之间的映射不是双射,它就会恐慌。</target>
        </trans-unit>
        <trans-unit id="fceb2cf0f9b16aaaaa6d86b667b93fcaf25ae6c9" translate="yes" xml:space="preserve">
          <source>RegisterCompressor registers custom compressors for a specified method ID. The common methods Store and Deflate are built in.</source>
          <target state="translated">RegisterCompressor为指定的方法ID注册自定义的压缩器。常用的方法Store和Deflate是内置的。</target>
        </trans-unit>
        <trans-unit id="4a803c7a9e0d15c2a5bd92b06180759964dddc4a" translate="yes" xml:space="preserve">
          <source>RegisterCompressor registers or overrides a custom compressor for a specific method ID. If a compressor for a given method is not found, Writer will default to looking up the compressor at the package level.</source>
          <target state="translated">RegisterCompressor 为一个特定的方法 ID 注册或覆盖一个自定义的压缩器。如果没有找到给定方法的压缩器,Writer将默认为在包级别查找压缩器。</target>
        </trans-unit>
        <trans-unit id="75b2829cabbf108c3c7f621e80ccf782333f2745" translate="yes" xml:space="preserve">
          <source>RegisterCover records the coverage data accumulators for the tests. NOTE: This function is internal to the testing infrastructure and may change. It is not covered (yet) by the Go 1 compatibility guidelines.</source>
          <target state="translated">RegisterCover记录测试的覆盖数据累加器。注意:这个功能是测试基础架构的内部功能,可能会改变。Go 1 兼容性指南还没有涉及到它。</target>
        </trans-unit>
        <trans-unit id="0efe5941ddd4024eca3486bcfdaa1b04b1d68c96" translate="yes" xml:space="preserve">
          <source>RegisterDecompressor allows custom decompressors for a specified method ID. The common methods Store and Deflate are built in.</source>
          <target state="translated">RegisterDecompressor允许为指定的方法ID定制解压器。常用的方法Store和Deflate是内置的。</target>
        </trans-unit>
        <trans-unit id="f8201de27600ded04eed1497b03a93af78ab1356" translate="yes" xml:space="preserve">
          <source>RegisterDecompressor registers or overrides a custom decompressor for a specific method ID. If a decompressor for a given method is not found, Reader will default to looking up the decompressor at the package level.</source>
          <target state="translated">RegisterDecompressor 注册或覆盖特定方法 ID 的自定义解压器。如果没有找到特定方法的解压器,Reader将默认为在包级别查找解压器。</target>
        </trans-unit>
        <trans-unit id="9306a2a96e5923311a823aa140641259832a6493" translate="yes" xml:space="preserve">
          <source>RegisterFormat registers an image format for use by Decode. Name is the name of the format, like &quot;jpeg&quot; or &quot;png&quot;. Magic is the magic prefix that identifies the format's encoding. The magic string can contain &quot;?&quot; wildcards that each match any one byte. Decode is the function that decodes the encoded image. DecodeConfig is the function that decodes just its configuration.</source>
          <target state="translated">RegisterFormat 注册一个供 Decode 使用的图像格式。Name是格式的名称,如 &quot;jpeg &quot;或 &quot;png&quot;。Magic是标识格式编码的魔术前缀。Magic字符串可以包含&quot;? &quot;通配符,每个通配符匹配任意一个字节。Decode是对编码后的图像进行解码的函数。DecodeConfig是只对其配置进行解码的函数。</target>
        </trans-unit>
        <trans-unit id="d2728f688707b63db693060d8790bf4683f92102" translate="yes" xml:space="preserve">
          <source>RegisterHash registers a function that returns a new instance of the given hash function. This is intended to be called from the init function in packages that implement hash functions.</source>
          <target state="translated">RegisterHash 注册一个函数,返回给定哈希函数的新实例。这个函数在实现哈希函数的包中的init函数中被调用。</target>
        </trans-unit>
        <trans-unit id="f205fffb3fe13999a49ce9f8f1c25ec589135c4d" translate="yes" xml:space="preserve">
          <source>RegisterName is like Register but uses the provided name for the type instead of the receiver's concrete type.</source>
          <target state="translated">RegisterName与Register类似,但使用提供的类型名称而不是接收者的具体类型。</target>
        </trans-unit>
        <trans-unit id="25332b231573649cd9dd5719e7982ea3f0248d42" translate="yes" xml:space="preserve">
          <source>RegisterName is like Register but uses the provided name rather than the type's default.</source>
          <target state="translated">RegisterName与Register类似,但使用提供的名称而不是类型的默认名称。</target>
        </trans-unit>
        <trans-unit id="080e1d8d3669508473b55784b1056c2f096d29a9" translate="yes" xml:space="preserve">
          <source>RegisterOnShutdown registers a function to call on Shutdown. This can be used to gracefully shutdown connections that have undergone ALPN protocol upgrade or that have been hijacked. This function should start protocol-specific graceful shutdown, but should not wait for shutdown to complete.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50c9507f9819b5006da79dc0a05071eebeda3b66" translate="yes" xml:space="preserve">
          <source>RegisterOnShutdown registers a function to call on Shutdown. This can be used to gracefully shutdown connections that have undergone NPN/ALPN protocol upgrade or that have been hijacked. This function should start protocol-specific graceful shutdown, but should not wait for shutdown to complete.</source>
          <target state="translated">RegisterOnShutdown 注册一个在Shutdown时调用的函数。这可以用来优雅地关闭经过NPN/ALPN协议升级或被劫持的连接。这个函数应该启动特定协议的优雅关机,但不应该等待关机完成。</target>
        </trans-unit>
        <trans-unit id="f09b3e8729145f382cce24a789165716e1f6f581" translate="yes" xml:space="preserve">
          <source>RegisterProtocol can be used by other packages to provide implementations of protocol schemes like &quot;ftp&quot; or &quot;file&quot;.</source>
          <target state="translated">RegisterProtocol可以被其他软件包用来提供协议方案的实现,比如 &quot;ftp &quot;或 &quot;file&quot;。</target>
        </trans-unit>
        <trans-unit id="dbed30c09a7f4317da85a08f890897f3a240daa9" translate="yes" xml:space="preserve">
          <source>RegisterProtocol registers a new protocol with scheme. The Transport will pass requests using the given scheme to rt. It is rt's responsibility to simulate HTTP request semantics.</source>
          <target state="translated">RegisterProtocol用scheme注册一个新协议。Transport将使用给定的scheme将请求传递给rt,rt的责任是模拟HTTP请求语义。</target>
        </trans-unit>
        <trans-unit id="95f136e8903a5338ba8f8a6eba4b4b48f4b69ff6" translate="yes" xml:space="preserve">
          <source>Regs386 is the Mach-O 386 register structure.</source>
          <target state="translated">Regs386是Mach-O 386寄存器结构。</target>
        </trans-unit>
        <trans-unit id="2fcecaafbea673f4dcd43eda2b8e308980d372b2" translate="yes" xml:space="preserve">
          <source>RegsAMD64 is the Mach-O AMD64 register structure.</source>
          <target state="translated">RegsAMD64是Mach-O AMD64寄存器结构。</target>
        </trans-unit>
        <trans-unit id="e042b10a368397c92fb60dbef856be3d5a1c4f5c" translate="yes" xml:space="preserve">
          <source>Rel</source>
          <target state="translated">Rel</target>
        </trans-unit>
        <trans-unit id="1fb867ac152e76d351e8dfda8aca4022a73396b3" translate="yes" xml:space="preserve">
          <source>Rel returns a relative path that is lexically equivalent to targpath when joined to basepath with an intervening separator. That is, Join(basepath, Rel(basepath, targpath)) is equivalent to targpath itself. On success, the returned path will always be relative to basepath, even if basepath and targpath share no elements. An error is returned if targpath can't be made relative to basepath or if knowing the current working directory would be necessary to compute it. Rel calls Clean on the result.</source>
          <target state="translated">Rel 返回一个相对路径,当它与 basepath 连接时,在词义上等同于 targpath,中间有一个分隔符。也就是说,Join(basepath,Rel(basepath,targpath))等同于targpath本身。成功后,返回的路径将始终是相对于basepath的,即使basepath和targpath没有共享元素。如果targpath不能与basepath相对,或者需要知道当前工作目录才能计算,则返回错误。Rel在结果上调用Clean。</target>
        </trans-unit>
        <trans-unit id="c91ec177ba02dafca5c024ef643b47566dd89ce7" translate="yes" xml:space="preserve">
          <source>Relationship between Tok value and Specs element type:</source>
          <target state="translated">Tok值和Specs元素类型之间的关系。</target>
        </trans-unit>
        <trans-unit id="b6abe7b7ff14b910183c9aec85ce50c4ba39a8a2" translate="yes" xml:space="preserve">
          <source>RelativeTo returns a Qualifier that fully qualifies members of all packages other than pkg.</source>
          <target state="translated">RelativeTo 返回一个 Qualifier,它可以完全限定 pkg 以外的所有包的成员。</target>
        </trans-unit>
        <trans-unit id="97b37138ea9a73172899c8018d830214258b5899" translate="yes" xml:space="preserve">
          <source>Release frees up resources allocated for the function. The function must not be invoked after calling Release.</source>
          <target state="translated">Release释放了为函数分配的资源。在调用Release之后,不得再调用该函数。</target>
        </trans-unit>
        <trans-unit id="6414caed589f7d3548350fb30719f67f7cc3b1cd" translate="yes" xml:space="preserve">
          <source>Release frees up resources allocated for the function. The function must not be invoked after calling Release. It is allowed to call Release while the function is still running.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c955e9bb05dd10804916da733d223f9b35d93831" translate="yes" xml:space="preserve">
          <source>Release releases any resources associated with the Process p, rendering it unusable in the future. Release only needs to be called if Wait is not.</source>
          <target state="translated">Release释放与进程p相关联的任何资源,使其在未来无法使用。只有在Wait没有被调用的情况下,才需要调用Release。</target>
        </trans-unit>
        <trans-unit id="74b4353ac8d321669700f92b4b41fd9bf3c282ea" translate="yes" xml:space="preserve">
          <source>Reloc represents a PE COFF relocation. Each section contains its own relocation list.</source>
          <target state="translated">Reloc 代表 PE COFF 重置。每个部分都包含自己的重定位列表。</target>
        </trans-unit>
        <trans-unit id="06f15fe6a2a2d8aaac59472278e750857f76ab13" translate="yes" xml:space="preserve">
          <source>Relocation types for 386.</source>
          <target state="translated">386的搬迁类型。</target>
        </trans-unit>
        <trans-unit id="d75a9d4eea543b3382ef4c2ebb9e3847ab91fd45" translate="yes" xml:space="preserve">
          <source>Relocation types for 64-bit PowerPC or Power Architecture processors.</source>
          <target state="translated">64位PowerPC或Power架构处理器的重定位类型。</target>
        </trans-unit>
        <trans-unit id="cf64299a5f4f83507314f139a3920dac3975ef27" translate="yes" xml:space="preserve">
          <source>Relocation types for AArch64 (aka arm64)</source>
          <target state="translated">AArch64(又名arm64)的重定位类型</target>
        </trans-unit>
        <trans-unit id="ef97dc2ae262d8f689d2dbae4ceb64c7c62edcc6" translate="yes" xml:space="preserve">
          <source>Relocation types for ARM.</source>
          <target state="translated">ARM的搬迁类型。</target>
        </trans-unit>
        <trans-unit id="2557c954121a635ff74fb9af9fe06dc80e27b715" translate="yes" xml:space="preserve">
          <source>Relocation types for Alpha.</source>
          <target state="translated">阿尔法的搬迁类型。</target>
        </trans-unit>
        <trans-unit id="1a1e40660756b62ef3239b6ced113d0caf0dbeda" translate="yes" xml:space="preserve">
          <source>Relocation types for MIPS.</source>
          <target state="translated">MIPS的搬迁类型。</target>
        </trans-unit>
        <trans-unit id="37b372c8b8cafc23d3fe71c2d91eeb8c48e4e130" translate="yes" xml:space="preserve">
          <source>Relocation types for PowerPC.</source>
          <target state="translated">PowerPC的搬迁类型。</target>
        </trans-unit>
        <trans-unit id="515822ec7faf1b82351dd8cb58bc45abc27332b8" translate="yes" xml:space="preserve">
          <source>Relocation types for RISC-V processors.</source>
          <target state="translated">RISC-V处理器的重新定位类型。</target>
        </trans-unit>
        <trans-unit id="28595645ef003fbc741125cd77426e420a3c93bb" translate="yes" xml:space="preserve">
          <source>Relocation types for SPARC.</source>
          <target state="translated">SPARC的搬迁类型。</target>
        </trans-unit>
        <trans-unit id="c8eeb8ad932e590ca3c9a184613db792a1b7d221" translate="yes" xml:space="preserve">
          <source>Relocation types for s390x processors.</source>
          <target state="translated">s390x处理器的搬迁类型。</target>
        </trans-unit>
        <trans-unit id="65d84f2017b766a2f893b1d9391a10aba054030c" translate="yes" xml:space="preserve">
          <source>Relocation types for x86-64.</source>
          <target state="translated">x86-64的搬迁类型。</target>
        </trans-unit>
        <trans-unit id="255e665567383d4dd16b956acc5187ba8c43936a" translate="yes" xml:space="preserve">
          <source>Rem returns the remainder of (hi, lo) divided by y. Rem panics for y == 0 (division by zero) but, unlike Div, it doesn't panic on a quotient overflow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f46f12d749f237f3883c4c5a62ab9b4f4409ae12" translate="yes" xml:space="preserve">
          <source>Rem sets z to the remainder x%y for y != 0 and returns z. If y == 0, a division-by-zero run-time panic occurs. Rem implements truncated modulus (like Go); see QuoRem for more details.</source>
          <target state="translated">Rem将z设为y !=0的余数x%y,并返回z。如果y ==0,则会发生逐零除法的运行时恐慌。Rem实现了截断模数(像Go一样);更多细节请参见QuoRem。</target>
        </trans-unit>
        <trans-unit id="7e9a6ae202c8dd3bb17cb040fe5aad5564198eb2" translate="yes" xml:space="preserve">
          <source>Rem32 returns the remainder of (hi, lo) divided by y. Rem32 panics for y == 0 (division by zero) but, unlike Div32, it doesn't panic on a quotient overflow.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
