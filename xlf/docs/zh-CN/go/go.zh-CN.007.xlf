<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="go">
    <body>
      <group id="go">
        <trans-unit id="9d2d10677b59853b34c04edbc18da2141f6ef823" translate="yes" xml:space="preserve">
          <source>ParseCertificates parses one or more certificates from the given ASN.1 DER data. The certificates must be concatenated with no intermediate padding.</source>
          <target state="translated">ParseCertificates从给定的ASN.1 DER数据中解析一个或多个证书。证书必须是连在一起的,没有中间的填充。</target>
        </trans-unit>
        <trans-unit id="0fa30c63d37bc2001c3a764872c0890c61f8acf6" translate="yes" xml:space="preserve">
          <source>ParseDERCRL parses a DER encoded CRL from the given bytes.</source>
          <target state="translated">ParseDERCRL从给定的字节中解析出一个DER编码的CRL。</target>
        </trans-unit>
        <trans-unit id="f3ec2edc0774eff41258539b91058f5d4cf9cd35" translate="yes" xml:space="preserve">
          <source>ParseDate parses an RFC 5322 date string.</source>
          <target state="translated">ParseDate解析一个RFC 5322日期字符串。</target>
        </trans-unit>
        <trans-unit id="758fe9e9cbf2d56e3666f652d8acda7c98141564" translate="yes" xml:space="preserve">
          <source>ParseDir calls ParseFile for all files with names ending in &quot;.go&quot; in the directory specified by path and returns a map of package name -&amp;gt; package AST with all the packages found.</source>
          <target state="translated">ParseDir在路径指定的目录中对名称以&amp;ldquo; .go&amp;rdquo;结尾的所有文件调用ParseFile，并返回包名称-&amp;gt;包AST的映射，其中找到了所有包。</target>
        </trans-unit>
        <trans-unit id="047621ddb91e82c184423e2a73f8e0cee328837e" translate="yes" xml:space="preserve">
          <source>ParseDirent parses up to max directory entries in buf, appending the names to names. It returns the number of bytes consumed from buf, the number of entries added to names, and the new names slice.</source>
          <target state="translated">ParseDirent 最多解析 buf 中的最大目录条目,将名字追加到 names 中。它返回从buf中消耗的字节数,添加到names中的条目数,以及新的names slice。</target>
        </trans-unit>
        <trans-unit id="ba15ad44a0d5b5aa5c04df3157000d88065b3088" translate="yes" xml:space="preserve">
          <source>ParseDuration</source>
          <target state="translated">ParseDuration</target>
        </trans-unit>
        <trans-unit id="0ccdc47cbfb062465c3ce4028258bbb8cace970b" translate="yes" xml:space="preserve">
          <source>ParseDuration parses a duration string. A duration string is a possibly signed sequence of decimal numbers, each with optional fraction and a unit suffix, such as &quot;300ms&quot;, &quot;-1.5h&quot; or &quot;2h45m&quot;. Valid time units are &quot;ns&quot;, &quot;us&quot; (or &quot;&amp;micro;s&quot;), &quot;ms&quot;, &quot;s&quot;, &quot;m&quot;, &quot;h&quot;.</source>
          <target state="translated">ParseDuration解析持续时间字符串。持续时间字符串是可能带符号的十进制数字序列，每个序列都有可选的分数和一个单位后缀，例如&amp;ldquo; 300ms&amp;rdquo;，&amp;ldquo;-1.5h&amp;rdquo;或&amp;ldquo; 2h45m&amp;rdquo;。有效时间单位为&amp;ldquo; ns&amp;rdquo;，&amp;ldquo; us&amp;rdquo;（或&amp;ldquo; &amp;micro;s&amp;rdquo;），&amp;ldquo; ms&amp;rdquo;，&amp;ldquo; s&amp;rdquo;，&amp;ldquo; m&amp;rdquo;，&amp;ldquo; h&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="6665378bb888147fd38985161b70b786f3c21803" translate="yes" xml:space="preserve">
          <source>ParseECPrivateKey parses an EC public key in SEC 1, ASN.1 DER form.</source>
          <target state="translated">ParseECPrivateKey解析SEC 1、ASN.1 DER形式的EC公钥。</target>
        </trans-unit>
        <trans-unit id="892fbba930b3566d06f9df2030763cda6ce95827" translate="yes" xml:space="preserve">
          <source>ParseError describes a problem parsing a time string.</source>
          <target state="translated">ParseError描述了一个解析时间字符串的问题。</target>
        </trans-unit>
        <trans-unit id="9a582c1b02184d48074757655b946996d9f55882" translate="yes" xml:space="preserve">
          <source>ParseExpr is a convenience function for obtaining the AST of an expression x. The position information recorded in the AST is undefined. The filename used in error messages is the empty string.</source>
          <target state="translated">ParseExpr是一个获取表达式x的AST的方便函数,AST中记录的位置信息是未定义的。错误信息中使用的文件名是空字符串。</target>
        </trans-unit>
        <trans-unit id="4fb56e49503c8edcde61d5f7c76a772eeec3484c" translate="yes" xml:space="preserve">
          <source>ParseExprFrom is a convenience function for parsing an expression. The arguments have the same meaning as for ParseFile, but the source must be a valid Go (type or value) expression. Specifically, fset must not be nil.</source>
          <target state="translated">ParseExprFrom 是一个用于解析表达式的方便函数,其参数与 ParseFile 的意义相同,但源必须是有效的 Go(类型或值)表达式。参数的含义与 ParseFile 相同,但源必须是有效的 Go(类型或值)表达式。具体来说,fset不能是nil。</target>
        </trans-unit>
        <trans-unit id="1451f0a6821c5b4b2901efe0f3d53819e7c6a483" translate="yes" xml:space="preserve">
          <source>ParseFile</source>
          <target state="translated">ParseFile</target>
        </trans-unit>
        <trans-unit id="8e9f94dbd4c4295f5a413cdec1747ee6881cd1da" translate="yes" xml:space="preserve">
          <source>ParseFile parses the source code of a single Go source file and returns the corresponding ast.File node. The source code may be provided via the filename of the source file, or via the src parameter.</source>
          <target state="translated">ParseFile 解析单个 Go 源文件的源代码并返回相应的 ast.File 节点。源代码可以通过源文件的文件名或src参数来提供。</target>
        </trans-unit>
        <trans-unit id="af492bad6c90c31471d746324ef2632bf8eb772d" translate="yes" xml:space="preserve">
          <source>ParseFiles creates a new Template and parses the template definitions from the named files. The returned template's name will have the (base) name and (parsed) contents of the first file. There must be at least one file. If an error occurs, parsing stops and the returned *Template is nil.</source>
          <target state="translated">ParseFiles创建一个新的Template并从命名的文件中解析模板定义。返回的模板的名称将有第一个文件的(基础)名称和(解析的)内容。必须至少有一个文件。如果发生错误,解析将停止,返回的*Template为nil。</target>
        </trans-unit>
        <trans-unit id="8327ff213ed2179b27e0e16f606053c1fb04d28d" translate="yes" xml:space="preserve">
          <source>ParseFiles creates a new Template and parses the template definitions from the named files. The returned template's name will have the base name and parsed contents of the first file. There must be at least one file. If an error occurs, parsing stops and the returned *Template is nil.</source>
          <target state="translated">ParseFiles创建一个新的Template,并从命名的文件中解析模板定义。返回的模板的名称将有第一个文件的基本名称和解析的内容。必须至少有一个文件。如果发生错误,解析将停止,返回的*Template为nil。</target>
        </trans-unit>
        <trans-unit id="ce6f3fc6adf60ff33bcdf40a608ef536cc90aa22" translate="yes" xml:space="preserve">
          <source>ParseFiles parses the named files and associates the resulting templates with t. If an error occurs, parsing stops and the returned template is nil; otherwise it is t. There must be at least one file.</source>
          <target state="translated">ParseFiles解析命名的文件,并将产生的模板与t相关联。如果发生错误,解析将停止,返回的模板为nil;否则为t。必须至少有一个文件。</target>
        </trans-unit>
        <trans-unit id="79c733c837a6ce524269772c4ef5bf48fb11ea5a" translate="yes" xml:space="preserve">
          <source>ParseFiles parses the named files and associates the resulting templates with t. If an error occurs, parsing stops and the returned template is nil; otherwise it is t. There must be at least one file. Since the templates created by ParseFiles are named by the base names of the argument files, t should usually have the name of one of the (base) names of the files. If it does not, depending on t's contents before calling ParseFiles, t.Execute may fail. In that case use t.ExecuteTemplate to execute a valid template.</source>
          <target state="translated">ParseFiles解析被命名的文件,并将得到的模板与t相关联。如果发生错误,解析停止,返回的模板为nil;否则就是t。由于ParseFiles创建的模板是由参数文件的基名命名的,所以t通常应该具有文件的(基)名之一。如果没有,根据调用 ParseFiles 之前 t 的内容,t.Execute 可能会失败。在这种情况下,使用t.ExecuteTemplate来执行一个有效的模板。</target>
        </trans-unit>
        <trans-unit id="91b51eccc60ebf92659e48c7256549a53f281cf8" translate="yes" xml:space="preserve">
          <source>ParseFiles returns an error if t or any associated template has already been executed.</source>
          <target state="translated">如果t或任何相关模板已经被执行,ParseFiles将返回一个错误。</target>
        </trans-unit>
        <trans-unit id="6b854a59dfcaea7000b265f3f7af7b0441340249" translate="yes" xml:space="preserve">
          <source>ParseFloat</source>
          <target state="translated">ParseFloat</target>
        </trans-unit>
        <trans-unit id="a968f6b35cbd445c2c3e17a676a673ab0f036e6d" translate="yes" xml:space="preserve">
          <source>ParseFloat accepts decimal and hexadecimal floating-point number syntax. If s is well-formed and near a valid floating-point number, ParseFloat returns the nearest floating-point number rounded using IEEE754 unbiased rounding. (Parsing a hexadecimal floating-point value only rounds when there are more bits in the hexadecimal representation than will fit in the mantissa.)</source>
          <target state="translated">ParseFloat接受十进制和十六进制的浮点数语法。如果s是一个格式良好且接近有效的浮点数,ParseFloat返回最近的浮点数,并使用IEEE754无偏四舍五入。(解析十六进制浮点数时,只有当十六进制表示法中的位数多于尾数时,才会进行四舍五入。)</target>
        </trans-unit>
        <trans-unit id="af48529cc69b2749ba1cfbd0072a925bc4216cca" translate="yes" xml:space="preserve">
          <source>ParseFloat converts the string s to a floating-point number with the precision specified by bitSize: 32 for float32, or 64 for float64. When bitSize=32, the result still has type float64, but it will be convertible to float32 without changing its value.</source>
          <target state="translated">ParseFloat 将字符串 s 转换为浮点数,其精度由 bitSize 指定:32 表示 float32,64 表示 float64。当bitSize=32时,结果的类型仍然是float64,但它将被转换为float32,而不会改变其值。</target>
        </trans-unit>
        <trans-unit id="f8f279e3e47cdc9cf9d872e61192822459d62d17" translate="yes" xml:space="preserve">
          <source>ParseFloat is like f.Parse(s, base) with f set to the given precision and rounding mode.</source>
          <target state="translated">ParseFloat 就像 f.Parse(s,base)一样,f 设置为给定的精度和四舍五入模式。</target>
        </trans-unit>
        <trans-unit id="fd5ce5b41aa64ac617d720e123321224a7f4d140" translate="yes" xml:space="preserve">
          <source>ParseFloat recognizes the strings &quot;NaN&quot;, &quot;+Inf&quot;, and &quot;-Inf&quot; as their respective special floating point values. It ignores case when matching.</source>
          <target state="translated">ParseFloat 识别字符串 &quot;NaN&quot;、&quot;+Inf &quot;和&quot;-Inf &quot;作为它们各自的特殊浮点值。它在匹配时忽略了大小写。</target>
        </trans-unit>
        <trans-unit id="7da060a59d225b78f860ce3acdb64ab957496796" translate="yes" xml:space="preserve">
          <source>ParseForm populates r.Form and r.PostForm.</source>
          <target state="translated">ParseForm填充r.Form和r.PostForm。</target>
        </trans-unit>
        <trans-unit id="07f8973752a66d43b70ef7fb0a84b494aed23663" translate="yes" xml:space="preserve">
          <source>ParseGlob creates a new Template and parses the template definitions from the files identified by the pattern. The files are matched according to the semantics of filepath.Match, and the pattern must match at least one file. The returned template will have the (base) name and (parsed) contents of the first file matched by the pattern. ParseGlob is equivalent to calling ParseFiles with the list of files matched by the pattern.</source>
          <target state="translated">ParseGlob创建一个新的Template,并从模式识别的文件中解析模板定义。文件根据filepath.Match的语义进行匹配,并且模式必须至少匹配一个文件。返回的模板将具有模式匹配的第一个文件的(基础)名称和(解析的)内容。ParseGlob相当于用模式匹配的文件列表调用ParseFiles。</target>
        </trans-unit>
        <trans-unit id="0041d2aedbde4c39f613a021a871fa8b33bebd33" translate="yes" xml:space="preserve">
          <source>ParseGlob parses the template definitions in the files identified by the pattern and associates the resulting templates with t. The files are matched according to the semantics of filepath.Match, and the pattern must match at least one file. ParseGlob is equivalent to calling t.ParseFiles with the list of files matched by the pattern.</source>
          <target state="translated">ParseGlob解析模式所标识的文件中的模板定义,并将得到的模板与t相关联。文件根据filepath.Match的语义进行匹配,并且模式必须至少匹配一个文件。ParseGlob相当于用模式匹配的文件列表调用t.ParseFiles。</target>
        </trans-unit>
        <trans-unit id="57508561e68db8f352026127277c4527c06f1494" translate="yes" xml:space="preserve">
          <source>ParseGlob returns an error if t or any associated template has already been executed.</source>
          <target state="translated">如果t或任何相关模板已经被执行,ParseGlob将返回一个错误。</target>
        </trans-unit>
        <trans-unit id="1c95736c9372d59f539bafb6f91f3448c1e25ac0" translate="yes" xml:space="preserve">
          <source>ParseHTTPVersion parses a HTTP version string. &quot;HTTP/1.0&quot; returns (1, 0, true).</source>
          <target state="translated">ParseHTTPVersion解析一个HTTP版本字符串。&quot;HTTP/1.0 &quot;返回(1,0,true)。</target>
        </trans-unit>
        <trans-unit id="6238bd01ff6944e78dfd936bd2b841304ebe18fe" translate="yes" xml:space="preserve">
          <source>ParseIP</source>
          <target state="translated">ParseIP</target>
        </trans-unit>
        <trans-unit id="e5c3f7806dc6261b34a424f0eac37be19bc2181d" translate="yes" xml:space="preserve">
          <source>ParseIP parses s as an IP address, returning the result. The string s can be in dotted decimal (&quot;192.0.2.1&quot;) or IPv6 (&quot;2001:db8::68&quot;) form. If s is not a valid textual representation of an IP address, ParseIP returns nil.</source>
          <target state="translated">ParseIP 将 s 解析为一个 IP 地址,并返回结果。字符串s可以是点阵十进制(&quot;192.0.2.1&quot;)或IPv6(&quot;2001:db8::68&quot;)形式。如果s不是IP地址的有效文本表示,ParseIP返回nil。</target>
        </trans-unit>
        <trans-unit id="c329eecfda46c75a2f5a9732976e5ca2eab67b96" translate="yes" xml:space="preserve">
          <source>ParseInLocation</source>
          <target state="translated">ParseInLocation</target>
        </trans-unit>
        <trans-unit id="b946980b6995c0bdde650965df500396097ee47e" translate="yes" xml:space="preserve">
          <source>ParseInLocation is like Parse but differs in two important ways. First, in the absence of time zone information, Parse interprets a time as UTC; ParseInLocation interprets the time as in the given location. Second, when given a zone offset or abbreviation, Parse tries to match it against the Local location; ParseInLocation uses the given location.</source>
          <target state="translated">ParseInLocation 和 Parse 一样,但有两个重要的不同之处:第一,在没有时区信息的情况下,Parse 将时间解释为 UTC;ParseInLocation 将时间解释为给定地点。首先,在没有时区信息的情况下,Parse 将时间解释为 UTC;ParseInLocation 将时间解释为给定位置的时间。第二,当给定一个区域偏移量或缩写时,Parse 试图将其与 Local 位置进行匹配;ParseInLocation 使用给定的位置。</target>
        </trans-unit>
        <trans-unit id="fd43b39f1cc6436ed26bf5ddd12e6461d48a315e" translate="yes" xml:space="preserve">
          <source>ParseInt</source>
          <target state="translated">ParseInt</target>
        </trans-unit>
        <trans-unit id="da8e97b7f44fd2f5e3e7756990fdef1ef6036785" translate="yes" xml:space="preserve">
          <source>ParseInt interprets a string s in the given base (0, 2 to 36) and bit size (0 to 64) and returns the corresponding value i.</source>
          <target state="translated">ParseInt解释给定基数(0,2到36)和位数(0到64)的字符串s,并返回相应的值i。</target>
        </trans-unit>
        <trans-unit id="da7fc45328cc9114fb2744e73272d12d929fea5f" translate="yes" xml:space="preserve">
          <source>ParseList parses the given string as a list of comma-separated addresses of the form &quot;Gogh Fir &amp;lt;gf@example.com&amp;gt;&quot; or &quot;foo@example.com&quot;.</source>
          <target state="translated">ParseList将给定的字符串解析为逗号分隔的地址列表，格式为&amp;ldquo; Gogh Fir &amp;lt;gf@example.com&amp;gt;&amp;rdquo;或&amp;ldquo; foo@example.com&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="721a0c1b5d6d1ee41cb2e1ce2ccd8399686328dd" translate="yes" xml:space="preserve">
          <source>ParseMAC parses s as an IEEE 802 MAC-48, EUI-48, EUI-64, or a 20-octet IP over InfiniBand link-layer address using one of the following formats:</source>
          <target state="translated">ParseMAC使用以下格式之一将s解析为IEEE 802 MAC-48、EUI-48、EUI-64或20字节的IP over InfiniBand链路层地址。</target>
        </trans-unit>
        <trans-unit id="76d8884907e134cde6d1ae2f450cf0d83b8102aa" translate="yes" xml:space="preserve">
          <source>ParseMediaType parses a media type value and any optional parameters, per RFC 1521. Media types are the values in Content-Type and Content-Disposition headers (RFC 2183). On success, ParseMediaType returns the media type converted to lowercase and trimmed of white space and a non-nil map. If there is an error parsing the optional parameter, the media type will be returned along with the error ErrInvalidMediaParameter. The returned map, params, maps from the lowercase attribute to the attribute value with its case preserved.</source>
          <target state="translated">ParseMediaType根据RFC 1521解析媒体类型值和任何可选参数。媒体类型是Content-Type和Content-Disposition头文件(RFC 2183)中的值。解析成功后,ParseMediaType会返回转换为小写的媒体类型,并修剪掉空白和一个非零的映射。如果在解析可选参数时出现错误,媒体类型将和错误ErrInvalidMediaParameter一起返回。返回的映射,params,从小写属性映射到保留大小写的属性值。</target>
        </trans-unit>
        <trans-unit id="bb8befc3cebb8742e6d50cfeac64769f0a3fff7a" translate="yes" xml:space="preserve">
          <source>ParseMultipartForm calls ParseForm automatically. ParseForm is idempotent.</source>
          <target state="translated">ParseMultipartForm自动调用ParseForm。ParseForm是幂等的。</target>
        </trans-unit>
        <trans-unit id="4205ffb0814fbcba9218830e9ad58589fcb016f6" translate="yes" xml:space="preserve">
          <source>ParseMultipartForm parses a request body as multipart/form-data. The whole request body is parsed and up to a total of maxMemory bytes of its file parts are stored in memory, with the remainder stored on disk in temporary files. ParseMultipartForm calls ParseForm if necessary. After one call to ParseMultipartForm, subsequent calls have no effect.</source>
          <target state="translated">ParseMultipartForm将一个请求体解析为multipart/form-data。整个请求体被解析后,它的文件部分最多总共有maxMemory字节存储在内存中,其余部分则存储在磁盘的临时文件中。ParseMultipartForm在必要时调用ParseForm。对ParseMultipartForm调用一次后,后续的调用没有任何效果。</target>
        </trans-unit>
        <trans-unit id="eecdedc3b85cbbe7f7cb2f75d45c36832c9b2317" translate="yes" xml:space="preserve">
          <source>ParseNetlinkMessage parses b as an array of netlink messages and returns the slice containing the NetlinkMessage structures.</source>
          <target state="translated">ParseNetlinkMessage将b解析为一个netlink消息数组,并返回包含NetlinkMessage结构的片断。</target>
        </trans-unit>
        <trans-unit id="2f0d8e60be2a0b26156f23d2b913830f42953f1b" translate="yes" xml:space="preserve">
          <source>ParseNetlinkRouteAttr parses m's payload as an array of netlink route attributes and returns the slice containing the NetlinkRouteAttr structures.</source>
          <target state="translated">ParseNetlinkRouteAttr将m的有效载荷解析为一个网链路由属性数组,并返回包含NetlinkRouteAttr结构的片断。</target>
        </trans-unit>
        <trans-unit id="ca8ea4136f1532755b07a48dc5268d78ecf1507c" translate="yes" xml:space="preserve">
          <source>ParsePKCS1PrivateKey parses an RSA private key in PKCS#1, ASN.1 DER form.</source>
          <target state="translated">ParsePKCS1PrivateKey解析PKCS#1、ASN.1 DER形式的RSA私钥。</target>
        </trans-unit>
        <trans-unit id="37bf10698677a842cf4d973614d5f0307c9b4ece" translate="yes" xml:space="preserve">
          <source>ParsePKCS1PublicKey parses an RSA public key in PKCS#1, ASN.1 DER form.</source>
          <target state="translated">ParsePKCS1PublicKey解析PKCS#1、ASN.1 DER形式的RSA公钥。</target>
        </trans-unit>
        <trans-unit id="585855469081df34619bcab57c0395b99ac9b879" translate="yes" xml:space="preserve">
          <source>ParsePKCS8PrivateKey parses an unencrypted private key in PKCS#8, ASN.1 DER form.</source>
          <target state="translated">ParsePKCS8PrivateKey解析PKCS#8,ASN.1 DER形式的未加密私钥。</target>
        </trans-unit>
        <trans-unit id="53e14792de36ed6cd3349fb2645358e6cd29fbb8" translate="yes" xml:space="preserve">
          <source>ParsePKIXPublicKey</source>
          <target state="translated">ParsePKIXPublicKey</target>
        </trans-unit>
        <trans-unit id="6a4599b4f783a30e67850f302db74a263e5ed679" translate="yes" xml:space="preserve">
          <source>ParsePKIXPublicKey parses a public key in PKIX, ASN.1 DER form.</source>
          <target state="translated">ParsePKIXPublicKey解析PKIX、ASN.1 DER形式的公钥。</target>
        </trans-unit>
        <trans-unit id="9e247d1a303dadeb36ebb627b0c5ca3e52bc27fd" translate="yes" xml:space="preserve">
          <source>ParseQuery</source>
          <target state="translated">ParseQuery</target>
        </trans-unit>
        <trans-unit id="7c00812498355c3d782c270a326950a437297e57" translate="yes" xml:space="preserve">
          <source>ParseQuery parses the URL-encoded query string and returns a map listing the values specified for each key. ParseQuery always returns a non-nil map containing all the valid query parameters found; err describes the first decoding error encountered, if any.</source>
          <target state="translated">ParseQuery解析URL编码的查询字符串,并返回一个映射,列出为每个键指定的值。ParseQuery总是返回一个非零的映射,包含所有找到的有效查询参数;err描述了遇到的第一个解码错误(如果有的话)。</target>
        </trans-unit>
        <trans-unit id="3d5fafc8859915dea1eca90debdb2203d7081d9e" translate="yes" xml:space="preserve">
          <source>ParseRequestURI parses rawurl into a URL structure. It assumes that rawurl was received in an HTTP request, so the rawurl is interpreted only as an absolute URI or an absolute path. The string rawurl is assumed not to have a #fragment suffix. (Web browsers strip #fragment before sending the URL to a web server.)</source>
          <target state="translated">ParseRequestURI将rawurl解析成一个URL结构。它假设rawurl是在HTTP请求中接收到的,所以rawurl只被解释为一个绝对URI或绝对路径。字符串rawurl被认为没有#fragment后缀。(Web浏览器在向Web服务器发送URL之前会将#fragment去掉)。</target>
        </trans-unit>
        <trans-unit id="303cbaa0aec4b7b4cb545ea3bdd253a60da46165" translate="yes" xml:space="preserve">
          <source>ParseSocketControlMessage parses b as an array of socket control messages.</source>
          <target state="translated">ParseSocketControlMessage将b解析为一个套接字控制消息数组。</target>
        </trans-unit>
        <trans-unit id="68f8375ee4255e9bdd0c3030df2260150e5493b0" translate="yes" xml:space="preserve">
          <source>ParseTime parses a time header (such as the Date: header), trying each of the three formats allowed by HTTP/1.1: TimeFormat, time.RFC850, and time.ANSIC.</source>
          <target state="translated">ParseTime解析一个时间头(如Date:头),尝试HTTP/1.1允许的三种格式。TimeFormat、time.RFC850和time.ANSIC。</target>
        </trans-unit>
        <trans-unit id="d09c9d04f1ff3f62cff402b66559957826b67ae1" translate="yes" xml:space="preserve">
          <source>ParseUint</source>
          <target state="translated">ParseUint</target>
        </trans-unit>
        <trans-unit id="7c5c32fd6cd92c39f679dc5ed50b80a4f8a1e92b" translate="yes" xml:space="preserve">
          <source>ParseUint is like ParseInt but for unsigned numbers.</source>
          <target state="translated">ParseUint 和 ParseInt 一样,但适用于无符号数。</target>
        </trans-unit>
        <trans-unit id="5bf4d74ce6c1b340caf3e896ab5b84ef49cf1719" translate="yes" xml:space="preserve">
          <source>ParseUnixCredentials decodes a socket control message that contains credentials in a Ucred structure. To receive such a message, the SO_PASSCRED option must be enabled on the socket.</source>
          <target state="translated">ParseUnixCredentials 解码一个包含在 Ucred 结构中的凭证的套接字控制消息。要接收这样的消息,必须在套接字上启用SO_PASSCRED选项。</target>
        </trans-unit>
        <trans-unit id="f2cd01c6af8de29d78551fd8726d012bba380c6c" translate="yes" xml:space="preserve">
          <source>ParseUnixRights decodes a socket control message that contains an integer array of open file descriptors from another process.</source>
          <target state="translated">ParseUnixRights对一个套接字控制消息进行解码,该消息包含来自另一个进程的打开文件描述符的整数组。</target>
        </trans-unit>
        <trans-unit id="32ac0722953b3173953c3c4db2a050c68e2bace4" translate="yes" xml:space="preserve">
          <source>Parsed reports whether f.Parse has been called.</source>
          <target state="translated">Parsed报告f.Parsse是否被调用。</target>
        </trans-unit>
        <trans-unit id="3448f815420bc7428adf585d197c1f125467f90e" translate="yes" xml:space="preserve">
          <source>Parsed reports whether the command-line flags have been parsed.</source>
          <target state="translated">Parsed报告命令行标志是否已被解析。</target>
        </trans-unit>
        <trans-unit id="dc2eb8678f8e8ede0972857e44c6282f328cc1fa" translate="yes" xml:space="preserve">
          <source>Passing skip=0 begins the stack trace at the call to Add inside rpc.NewClient. Passing skip=1 begins the stack trace at the call to NewClient inside mypkg.Run.</source>
          <target state="translated">传递 skip=0 开始在 rpc.NewClient 里调用 Add 的堆栈跟踪。通过 skip=1 开始 mypkg.Run.NewClient 调用时的堆栈跟踪。</target>
        </trans-unit>
        <trans-unit id="bc137142636c80e92c407f2aa46fcdf54313c790" translate="yes" xml:space="preserve">
          <source>Password returns the password in case it is set, and whether it is set.</source>
          <target state="translated">密码在设置的情况下返回密码,是否设置。</target>
        </trans-unit>
        <trans-unit id="2c6302867f847fe663bbe8d220f8e92a48796687" translate="yes" xml:space="preserve">
          <source>Path returns the package path.</source>
          <target state="translated">Path 返回包的路径。</target>
        </trans-unit>
        <trans-unit id="d0506b7bdb505a3150b81c4c616dee83d176fcfa" translate="yes" xml:space="preserve">
          <source>PathError records an error and the operation and file path that caused it.</source>
          <target state="translated">PathError记录了一个错误和造成该错误的操作和文件路径。</target>
        </trans-unit>
        <trans-unit id="e7599081a40b17f0e8c56bbb5dfa806da5a30888" translate="yes" xml:space="preserve">
          <source>PathEscape escapes the string so it can be safely placed inside a URL path segment, replacing special characters (including /) with %XX sequences as needed.</source>
          <target state="translated">PathEscape可以将字符串安全地放置在URL路径段中,根据需要用%XX序列替换特殊字符(包括/)。</target>
        </trans-unit>
        <trans-unit id="5c3a77b47b5350edac8b6dbc79888f216cc42e3c" translate="yes" xml:space="preserve">
          <source>PathUnescape does the inverse transformation of PathEscape, converting each 3-byte encoded substring of the form &quot;%AB&quot; into the hex-decoded byte 0xAB. It returns an error if any % is not followed by two hexadecimal digits.</source>
          <target state="translated">PathUnescape对PathEscape进行逆向转换,将每个3字节编码的&quot;%AB &quot;形式的子串转换为十六进制解码的字节0xAB。如果任何%后面没有两个十六进制数字,它将返回一个错误。</target>
        </trans-unit>
        <trans-unit id="40463bc26e83c862cf3b0e60286130df1ab877d6" translate="yes" xml:space="preserve">
          <source>PathUnescape is identical to QueryUnescape except that it does not unescape '+' to ' ' (space).</source>
          <target state="translated">PathUnescape与QueryUnescape相同,只是它不会将'+'去掉''(空格)。</target>
        </trans-unit>
        <trans-unit id="cda78fe9f7d0595a1e181ce1981b7483036ab29c" translate="yes" xml:space="preserve">
          <source>Patterns may optionally begin with a host name, restricting matches to URLs on that host only. Host-specific patterns take precedence over general patterns, so that a handler might register for the two patterns &quot;/codesearch&quot; and &quot;codesearch.google.com/&quot; without also taking over requests for &quot;&lt;a href=&quot;http://www.google.com/&quot;&gt;http://www.google.com/&lt;/a&gt;&quot;.</source>
          <target state="translated">模式可以选择以主机名开头，仅将匹配项限制在该主机上。特定于主机的模式优先于常规模式，因​​此处理程序可以注册&amp;ldquo; / codesearch&amp;rdquo;和&amp;ldquo; codesearch.google.com/&amp;rdquo;这两种模式，而无需接管对&amp;ldquo; &lt;a href=&quot;http://www.google.com/&quot;&gt;http://www.google.com/&lt;/a&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="c47c55adf239beb3a291abbb9f63d307ef60c16f" translate="yes" xml:space="preserve">
          <source>Patterns name fixed, rooted paths, like &quot;/favicon.ico&quot;, or rooted subtrees, like &quot;/images/&quot; (note the trailing slash). Longer patterns take precedence over shorter ones, so that if there are handlers registered for both &quot;/images/&quot; and &quot;/images/thumbnails/&quot;, the latter handler will be called for paths beginning &quot;/images/thumbnails/&quot; and the former will receive requests for any other paths in the &quot;/images/&quot; subtree.</source>
          <target state="translated">模式命名固定的、有根的路径,比如&quot;/favicon.ico&quot;,或者有根的子树,比如&quot;/images/&quot;(注意后面的斜杠)。较长的模式优先于较短的模式,因此,如果有同时注册了&quot;/images/&quot;和&quot;/images/thumbnails/&quot;的处理程序,那么后一个处理程序将被调用以&quot;/images/thumbnails/&quot;开头的路径,而前一个处理程序将接收对&quot;/images/&quot;子树中任何其他路径的请求。</target>
        </trans-unit>
        <trans-unit id="f28eb62c201920349ad82fd89183cea2a77fc0ce" translate="yes" xml:space="preserve">
          <source>Peek returns the next Unicode character in the source without advancing the scanner. It returns EOF if the scanner's position is at the last character of the source.</source>
          <target state="translated">Peek返回源码中的下一个Unicode字符,而不会使扫描器前进。如果扫描器的位置在源码的最后一个字符处,则返回EOF。</target>
        </trans-unit>
        <trans-unit id="2959c1935503c7a46c0b1958e9d8a81763a0ed6a" translate="yes" xml:space="preserve">
          <source>Peek returns the next n bytes without advancing the reader. The bytes stop being valid at the next read call. If Peek returns fewer than n bytes, it also returns an error explaining why the read is short. The error is ErrBufferFull if n is larger than b's buffer size.</source>
          <target state="translated">Peek返回下一个n个字节,而不推进读取器。这些字节在下一次读取调用时停止有效。如果Peek返回的字节数少于n个,它还会返回一个错误,解释为什么读短了。如果n大于b的缓冲区大小,则错误为ErrBufferFull。</target>
        </trans-unit>
        <trans-unit id="eb621fcca2c83af4eb20df9787fc904ec33fe0d9" translate="yes" xml:space="preserve">
          <source>Pending returns the number of unanswered requests that have been received on the connection.</source>
          <target state="translated">Pending(待处理)返回连接上已收到的未回复请求的数量。</target>
        </trans-unit>
        <trans-unit id="c6855a32465d5bf0f448eaa4af31e378ea6b4379" translate="yes" xml:space="preserve">
          <source>Pending returns the number of unanswered requests that have been sent on the connection.</source>
          <target state="translated">Pending(待处理)返回连接上已发送的未响应请求的数量。</target>
        </trans-unit>
        <trans-unit id="c7ceccb01b416098f13eef5c65da35dd4ef29c59" translate="yes" xml:space="preserve">
          <source>Perl character classes (all ASCII-only):</source>
          <target state="translated">Perl字符类(全部为ASCII码)。</target>
        </trans-unit>
        <trans-unit id="327a2b8cad2b9a6ef158a641755a49d69b9cc93f" translate="yes" xml:space="preserve">
          <source>Perm</source>
          <target state="translated">Perm</target>
        </trans-unit>
        <trans-unit id="b4cbc1d379695fc60a43435dd6614970bc7cf1c8" translate="yes" xml:space="preserve">
          <source>Perm returns the Unix permission bits in m.</source>
          <target state="translated">Perm返回m中的Unix权限位。</target>
        </trans-unit>
        <trans-unit id="6ed0eddcb867d78e7678ca142786b03c98fcc1cf" translate="yes" xml:space="preserve">
          <source>Perm returns, as a slice of n ints, a pseudo-random permutation of the integers [0,n) from the default Source.</source>
          <target state="translated">Perm作为n个ints的片断,从默认的Source返回一个整数[0,n]的伪随机排列。</target>
        </trans-unit>
        <trans-unit id="62a4f6eab662c10e8c22fcd7a13a5adce4b9aeef" translate="yes" xml:space="preserve">
          <source>Perm returns, as a slice of n ints, a pseudo-random permutation of the integers [0,n).</source>
          <target state="translated">Perm以n个ints的分片形式返回整数[0,n)的伪随机排列。</target>
        </trans-unit>
        <trans-unit id="2eb6560251a01ddeba6819d546ca94bf5106de3c" translate="yes" xml:space="preserve">
          <source>Phase returns the phase (also called the argument) of x. The returned value is in the range [-Pi, Pi].</source>
          <target state="translated">Phase 返回 x 的相位(也称为参数),返回值的范围是 [-Pi,Pi]。</target>
        </trans-unit>
        <trans-unit id="c62187a44c4849f243c0d01a0cd965d235c59c18" translate="yes" xml:space="preserve">
          <source>Pid returns the process id of the exited process.</source>
          <target state="translated">Pid返回退出的进程的进程ID。</target>
        </trans-unit>
        <trans-unit id="aaf942e54daedd7cb953cee036ee4e01d73e3a05" translate="yes" xml:space="preserve">
          <source>Ping verifies a connection to the database is still alive, establishing a connection if necessary.</source>
          <target state="translated">Ping验证与数据库的连接是否还在,必要时建立连接。</target>
        </trans-unit>
        <trans-unit id="1616a118fdcaf54f337c10d117d16aaa99fd0b14" translate="yes" xml:space="preserve">
          <source>PingContext verifies a connection to the database is still alive, establishing a connection if necessary.</source>
          <target state="translated">PingContext验证与数据库的连接是否仍然有效,必要时建立一个连接。</target>
        </trans-unit>
        <trans-unit id="8c943ad1575fde013a5e267aa7a5a04d105d169b" translate="yes" xml:space="preserve">
          <source>PingContext verifies the connection to the database is still alive.</source>
          <target state="translated">PingContext验证与数据库的连接是否仍然有效。</target>
        </trans-unit>
        <trans-unit id="7a788a1af96c8d9977c69732be97c930615c2f24" translate="yes" xml:space="preserve">
          <source>Pinger is an optional interface that may be implemented by a Conn.</source>
          <target state="translated">Pinger是一个可选的接口,可以由Conn.Pinger实现。</target>
        </trans-unit>
        <trans-unit id="00dae071c082bb73eaed17b4bb3429280e110e8c" translate="yes" xml:space="preserve">
          <source>Pipe</source>
          <target state="translated">Pipe</target>
        </trans-unit>
        <trans-unit id="e40f59609b56b44e5054b6b92f52ff52a16d5fa3" translate="yes" xml:space="preserve">
          <source>Pipe creates a synchronous in-memory pipe. It can be used to connect code expecting an io.Reader with code expecting an io.Writer.</source>
          <target state="translated">Pipe创建了一个同步的内存管道,它可以用来连接期待io.Reader的代码和期待io.Writer的代码。它可以用来连接期待io.Reader的代码和期待io.Writer的代码。</target>
        </trans-unit>
        <trans-unit id="da50f6a47a89e9218a08186e61e447aeaa977683" translate="yes" xml:space="preserve">
          <source>Pipe creates a synchronous, in-memory, full duplex network connection; both ends implement the Conn interface. Reads on one end are matched with writes on the other, copying data directly between the two; there is no internal buffering.</source>
          <target state="translated">Pipe建立一个同步的、内存中的、全双工的网络连接;两端实现Conn接口。一端的读与另一端的写相匹配,直接在两端之间复制数据;没有内部缓冲。</target>
        </trans-unit>
        <trans-unit id="2a31ea2b0e32b3e571d1bceba86196d7bad1fcb8" translate="yes" xml:space="preserve">
          <source>Pipe returns a connected pair of Files; reads from r return bytes written to w. It returns the files and an error, if any.</source>
          <target state="translated">管子返回一对连接的Files;从r中读取返回写入w的字节,如果有的话,它会返回文件和一个错误。</target>
        </trans-unit>
        <trans-unit id="20f3a37d20161b0046bc712fcc1c973a57a664dc" translate="yes" xml:space="preserve">
          <source>PipeNode holds a pipeline with optional declaration</source>
          <target state="translated">PipeNode持有一个管道,并可选择声明。</target>
        </trans-unit>
        <trans-unit id="f28715a2c22fba2d801918b67be067614e3917c8" translate="yes" xml:space="preserve">
          <source>Pipeline, to manage pipelined requests and responses in a client.</source>
          <target state="translated">管道,用于管理客户端中的管道式请求和响应。</target>
        </trans-unit>
        <trans-unit id="c5df1e14fdba13b1a3f9690f736bcb2aac132e72" translate="yes" xml:space="preserve">
          <source>Pipelines</source>
          <target state="translated">Pipelines</target>
        </trans-unit>
        <trans-unit id="06fc1a48588c809599455a2829c6d8c93dab2807" translate="yes" xml:space="preserve">
          <source>PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y).</source>
          <target state="translated">PixOffset返回Pix中对应于(x,y)像素的第一个元素的索引。</target>
        </trans-unit>
        <trans-unit id="bf14eb94c114379d054dbd030d4c5c1a50c1bc82" translate="yes" xml:space="preserve">
          <source>Pkg returns the package to which the object belongs. The result is nil for labels and objects in the Universe scope.</source>
          <target state="translated">Pkg 返回对象所属的包。对于Universe作用域中的标签和对象,结果为零。</target>
        </trans-unit>
        <trans-unit id="6b25672d57f482ab04e1df337de0aebb92458d0d" translate="yes" xml:space="preserve">
          <source>PlainAuth</source>
          <target state="translated">PlainAuth</target>
        </trans-unit>
        <trans-unit id="0e0cce6c4e84e3f28344ac03eb2bbf3c7be04c28" translate="yes" xml:space="preserve">
          <source>PlainAuth returns an Auth that implements the PLAIN authentication mechanism as defined in RFC 4616. The returned Auth uses the given username and password to authenticate to host and act as identity. Usually identity should be the empty string, to act as username.</source>
          <target state="translated">PlainAuth 返回一个实现 RFC 4616 中定义的 PLAIN 认证机制的 Auth。返回的Auth使用给定的用户名和密码来验证主机并作为身份认证。通常identity应该是空字符串,作为用户名。</target>
        </trans-unit>
        <trans-unit id="32488aca0b25b337080ddc28faef0ad97faab0e7" translate="yes" xml:space="preserve">
          <source>PlainAuth will only send the credentials if the connection is using TLS or is connected to localhost. Otherwise authentication will fail with an error, without sending the credentials.</source>
          <target state="translated">只有当连接使用TLS或连接到localhost时,PlainAuth才会发送凭证。否则,验证将以错误的方式失败,而不会发送凭证。</target>
        </trans-unit>
        <trans-unit id="b8996c869faa8282ed1dc0af722f7f384a441369" translate="yes" xml:space="preserve">
          <source>Plan 9</source>
          <target state="translated">计划9</target>
        </trans-unit>
        <trans-unit id="fcc50dd97b375efa9e5795002087751fd071d726" translate="yes" xml:space="preserve">
          <source>Plan9 is a 256-color palette that partitions the 24-bit RGB space into 4&amp;times;4&amp;times;4 subdivision, with 4 shades in each subcube. Compared to the WebSafe, the idea is to reduce the color resolution by dicing the color cube into fewer cells, and to use the extra space to increase the intensity resolution. This results in 16 gray shades (4 gray subcubes with 4 samples in each), 13 shades of each primary and secondary color (3 subcubes with 4 samples plus black) and a reasonable selection of colors covering the rest of the color cube. The advantage is better representation of continuous tones.</source>
          <target state="translated">Plan9是256色调色板，它将24位RGB空间划分为4&amp;times;4&amp;times;4细分，每个子多维数据集中有4个阴影。与WebSafe相比，该想法是通过将彩色立方体切成更少的单元格来降低颜色分辨率，并使用额外的空间来提高强度分辨率。这样就可以得到16个灰色阴影（每个带有4个样本的4个灰色子立方体），每种原色和次要颜色13个阴影（3个带有4个样本加黑色的子立方体）以及覆盖其余颜色立方体的合理颜色选择。优点是可以更好地表示连续色调。</target>
        </trans-unit>
        <trans-unit id="9d8a06b24fa70984798bf322daaec557c2b6f1b4" translate="yes" xml:space="preserve">
          <source>Playable Examples must be in a package whose name ends in &quot;_test&quot;. An Example is &quot;playable&quot; (the Play field is non-nil) in either of these circumstances:</source>
          <target state="translated">可播放的实例必须在一个包中,其名称以&quot;_test &quot;结尾。在这两种情况下,一个例子都是 &quot;可玩的&quot;(Play字段是非nil)。</target>
        </trans-unit>
        <trans-unit id="2c6beabd4a6c27d664359314bb0b7be1a4bee461" translate="yes" xml:space="preserve">
          <source>Plugin is a loaded Go plugin.</source>
          <target state="translated">插件是一个加载中的围棋插件。</target>
        </trans-unit>
        <trans-unit id="79d975c909286257ed2dc841463cf2221331b8a7" translate="yes" xml:space="preserve">
          <source>Pointer represents a pointer to an arbitrary type. There are four special operations available for type Pointer that are not available for other types:</source>
          <target state="translated">Pointer表示一个指向任意类型的指针。对于Pointer类型,有四种特殊的操作是其他类型所没有的。</target>
        </trans-unit>
        <trans-unit id="c0c031e92d2b285f06539e450cbc88db48ddddac" translate="yes" xml:space="preserve">
          <source>Pointer returns v's value as a uintptr. It returns uintptr instead of unsafe.Pointer so that code using reflect cannot obtain unsafe.Pointers without importing the unsafe package explicitly. It panics if v's Kind is not Chan, Func, Map, Ptr, Slice, or UnsafePointer.</source>
          <target state="translated">Pointer以uintptr的形式返回v的值。它返回的是uintptr而不是unsafe.Pointer,因此使用reflect的代码在没有显式导入unsafe包的情况下无法获得unsafe.Pointers。如果v的Kind不是Chan、Func、Map、Ptr、Slice或UnsafePointer,它就会恐慌。</target>
        </trans-unit>
        <trans-unit id="baef0ef34fa58ab846963eb42f08d22cc0916958" translate="yes" xml:space="preserve">
          <source>Pointer therefore allows a program to defeat the type system and read and write arbitrary memory. It should be used with extreme care.</source>
          <target state="translated">因此,指针允许程序击败类型系统,读写任意内存。使用它时应格外小心。</target>
        </trans-unit>
        <trans-unit id="c228a838e9e7815109b6016259a9375cc32a3ee5" translate="yes" xml:space="preserve">
          <source>Pointer values are deeply equal if they are equal using Go's == operator or if they point to deeply equal values.</source>
          <target state="translated">如果使用围棋的==运算符使指针值相等,或者它们指向的是深层相等的值,那么指针值就是深层相等的。</target>
        </trans-unit>
        <trans-unit id="ab46185459d2a7d78c59879c795ee53dd26dd358" translate="yes" xml:space="preserve">
          <source>Pointer values encode as the value pointed to. A nil pointer encodes as the null JSON value.</source>
          <target state="translated">指针值编码为所指向的值。nil指针编码为空JSON值。</target>
        </trans-unit>
        <trans-unit id="d2cde07b059e3c084c9da753efae9fdd148fa375" translate="yes" xml:space="preserve">
          <source>Pointer:</source>
          <target state="translated">Pointer:</target>
        </trans-unit>
        <trans-unit id="b64fba6378c386a82e71d5a623e279c432da4e08" translate="yes" xml:space="preserve">
          <source>Polar</source>
          <target state="translated">Polar</target>
        </trans-unit>
        <trans-unit id="a5fb429c2bb667a352c2046e02293fc421f8310b" translate="yes" xml:space="preserve">
          <source>Polar returns the absolute value r and phase &amp;theta; of x, such that x = r * e**&amp;theta;i. The phase is in the range [-Pi, Pi].</source>
          <target state="translated">Polar返回x的绝对值r和相位&amp;theta;，从而x = r * e **&amp;theta;i。相位在[-Pi，Pi]范围内。</target>
        </trans-unit>
        <trans-unit id="8e6bda38a58104dfd742e2b251475f4fc7ad35e0" translate="yes" xml:space="preserve">
          <source>Polynomials are represented in LSB-first form also known as reversed representation.</source>
          <target state="translated">多项式用LSB优先的形式表示,也称为反向表示。</target>
        </trans-unit>
        <trans-unit id="778627418cb4b30cdfe47281afdbf30f1a173700" translate="yes" xml:space="preserve">
          <source>Pool</source>
          <target state="translated">Pool</target>
        </trans-unit>
        <trans-unit id="62976d6c6dce665baf19823706626b87a619028b" translate="yes" xml:space="preserve">
          <source>Pool's purpose is to cache allocated but unused items for later reuse, relieving pressure on the garbage collector. That is, it makes it easy to build efficient, thread-safe free lists. However, it is not suitable for all free lists.</source>
          <target state="translated">Pool的目的是缓存已分配但未使用的项目,以便以后重复使用,减轻垃圾收集器的压力。也就是说,它可以轻松构建高效、线程安全的自由列表。但是,它并不适合所有的自由列表。</target>
        </trans-unit>
        <trans-unit id="a894961424546348d9d455a430167c6470d0b453" translate="yes" xml:space="preserve">
          <source>Pop removes and returns the minimum element (according to Less) from the heap. The complexity is O(log n) where n = h.Len(). Pop is equivalent to Remove(h, 0).</source>
          <target state="translated">Pop从堆中移除并返回最小元素(根据Less)。复杂度为O(log n),其中n=h.Len()。Pop相当于Remove(h,0)。</target>
        </trans-unit>
        <trans-unit id="1c331ce3bd04c4d21d66fc2ae1a5de46dd73eec8" translate="yes" xml:space="preserve">
          <source>Port returns the port part of u.Host, without the leading colon.</source>
          <target state="translated">Port 返回 u.Host 的端口部分,不含前导冒号。</target>
        </trans-unit>
        <trans-unit id="42cb37e41618d46d1d0e8d0bf5e059552b858cb3" translate="yes" xml:space="preserve">
          <source>Portable analogs of some common system call errors.</source>
          <target state="translated">一些常见系统调用错误的便携式类比。</target>
        </trans-unit>
        <trans-unit id="97e4fd0d08cb7c58f4698b53bcfb9441c857ebec" translate="yes" xml:space="preserve">
          <source>Pos and End describe the scope's source code extent [pos, end). The results are guaranteed to be valid only if the type-checked AST has complete position information. The extent is undefined for Universe and package scopes.</source>
          <target state="translated">pos和End描述了作用域的源代码范围[pos,end)。只有当经过类型检查的AST有完整的位置信息时,才能保证结果是有效的。对于Universe和包的作用域,这个范围是未定义的。</target>
        </trans-unit>
        <trans-unit id="4c60ba97a8cb410a549bfe181eeaa63408b55cba" translate="yes" xml:space="preserve">
          <source>Pos computes the source position of the declaration of an object name. The result may be an invalid position if it cannot be computed (obj.Decl may be nil or not correct).</source>
          <target state="translated">Pos计算一个对象名声明的源位置,如果不能计算,结果可能是无效的(obj.Decl可能为nil或不正确)。如果不能计算,结果可能是一个无效的位置(obj.Decl可能是nil或不正确)。</target>
        </trans-unit>
        <trans-unit id="a0ec3702b899c2917ee8242be4cbe0bff05b9658" translate="yes" xml:space="preserve">
          <source>Pos is a compact encoding of a source position within a file set. It can be converted into a Position for a more convenient, but much larger, representation.</source>
          <target state="translated">Pos 是一个文件集内源位置的紧凑编码。它可以转换为Position,以便更方便,但更大的表示。</target>
        </trans-unit>
        <trans-unit id="1b9fa7b2eba24dae9008da03956b9fa4fe5bac8a" translate="yes" xml:space="preserve">
          <source>Pos represents a byte position in the original input text from which this template was parsed.</source>
          <target state="translated">Pos代表原始输入文本中的一个字节位置,该模板是从该文本中解析出来的。</target>
        </trans-unit>
        <trans-unit id="edf92f1280756c43fc75532da3d73537cdede740" translate="yes" xml:space="preserve">
          <source>Pos returns the Pos value for the given file offset; the offset must be &amp;lt;= f.Size(). f.Pos(f.Offset(p)) == p.</source>
          <target state="translated">Pos返回给定文件偏移量的Pos值；偏移量必须小于等于f.Size（）。f.Pos（f.Offset（p））== p。</target>
        </trans-unit>
        <trans-unit id="5ff010dde5f69bdb9f99370ef921975c8f9209ff" translate="yes" xml:space="preserve">
          <source>Pos returns the declaration position of the object's identifier.</source>
          <target state="translated">Pos返回对象标识符的声明位置。</target>
        </trans-unit>
        <trans-unit id="cd367287d957f8b0726b9d88a222f0d52b30fd66" translate="yes" xml:space="preserve">
          <source>Pos returns the position of the character immediately after the character or token returned by the last call to Next or Scan. Use the Scanner's Position field for the start position of the most recently scanned token.</source>
          <target state="translated">Pos 返回紧接上一次调用 Next 或 Scan 返回的字符或标记之后的字符位置。使用扫描器的位置字段表示最近扫描的标记的起始位置。</target>
        </trans-unit>
        <trans-unit id="e31be0876f71b9f08f689f98e0ab92c2ffe225b9" translate="yes" xml:space="preserve">
          <source>Pos values can be compared directly with the usual comparison operators: If two Pos values p and q are in the same file, comparing p and q is equivalent to comparing the respective source file offsets. If p and q are in different files, p &amp;lt; q is true if the file implied by p was added to the respective file set before the file implied by q.</source>
          <target state="translated">Pos值可以直接与常规比较运算符进行比较：如果两个Pos值p和q在同一文件中，则比较p和q等效于比较各自的源文件偏移量。如果p和q位于不同的文件中，则如果p隐含的文件被添加到q隐含的文件之前的相应文件集中，则p &amp;lt;q为true。</target>
        </trans-unit>
        <trans-unit id="5fc2fa994bbd914263ceb34efcf25eb956fe5e38" translate="yes" xml:space="preserve">
          <source>Position converts a Pos p in the fileset into a Position value. Calling s.Position(p) is equivalent to calling s.PositionFor(p, true).</source>
          <target state="translated">Position 将 fileset 中的 Pos p 转换为 Position 值。调用 s.Position(p)等同于调用 s.PositionFor(p,true)。</target>
        </trans-unit>
        <trans-unit id="b93209a85028bf6019382a8729f55ac8145e29b1" translate="yes" xml:space="preserve">
          <source>Position describes an arbitrary source position including the file, line, and column location. A Position is valid if the line number is &amp;gt; 0.</source>
          <target state="translated">位置描述任意源位置，包括文件，行和列的位置。如果行号&amp;gt; 0，则&amp;ldquo;位置&amp;rdquo;有效。</target>
        </trans-unit>
        <trans-unit id="d1086db7e34e995911902270435427be7e528699" translate="yes" xml:space="preserve">
          <source>Position returns the Position value for the given file position p. Calling f.Position(p) is equivalent to calling f.PositionFor(p, true).</source>
          <target state="translated">调用f.Position(p)相当于调用f.PositionFor(p,true)。</target>
        </trans-unit>
        <trans-unit id="9bee67f02828c19ef6ab2c5867d78daacd16a5b6" translate="yes" xml:space="preserve">
          <source>PositionFor converts a Pos p in the fileset into a Position value. If adjusted is set, the position may be adjusted by position-altering //line comments; otherwise those comments are ignored. p must be a Pos value in s or NoPos.</source>
          <target state="translated">PositionFor 将文件集中的 Pos p 转换为 Position 值。如果设置了adjusted,位置可以通过位置改变的//行注释来调整,否则这些注释将被忽略。p必须是s或NoPos中的Pos值。</target>
        </trans-unit>
        <trans-unit id="3d4ffd5f491d5a7cdece709329d95542f519d748" translate="yes" xml:space="preserve">
          <source>PositionFor returns the Position value for the given file position p. If adjusted is set, the position may be adjusted by position-altering //line comments; otherwise those comments are ignored. p must be a Pos value in f or NoPos.</source>
          <target state="translated">PositionFor返回给定文件位置p的位置值,如果设置了adjusted,则可以通过改变位置的//行注释来调整位置,否则这些注释将被忽略。p必须是f或NoPos中的Pos值。</target>
        </trans-unit>
        <trans-unit id="9ac52c588d2d22788d46da883fda78a4165f3071" translate="yes" xml:space="preserve">
          <source>Possible values for the EncryptPEMBlock encryption algorithm.</source>
          <target state="translated">EncryptPEMBlock加密算法的可能值。</target>
        </trans-unit>
        <trans-unit id="e039b08aed18ef386a63d77f040148c0406ea827" translate="yes" xml:space="preserve">
          <source>Post is a wrapper around DefaultClient.Post.</source>
          <target state="translated">Post是DefaultClient.Post的封装器。</target>
        </trans-unit>
        <trans-unit id="4ccc94f360bffe8b14b21c70371bc08f8fc85aba" translate="yes" xml:space="preserve">
          <source>Post issues a POST to the specified URL.</source>
          <target state="translated">Post向指定的URL发出POST。</target>
        </trans-unit>
        <trans-unit id="cf67d20c1f3d564f229d45c7bbe51d8dd1d5c4f9" translate="yes" xml:space="preserve">
          <source>PostForm is a wrapper around DefaultClient.PostForm.</source>
          <target state="translated">PostForm是DefaultClient.PostForm的封装器。</target>
        </trans-unit>
        <trans-unit id="44be7db278a3bb23e34b6df9cf0308f04a22ef65" translate="yes" xml:space="preserve">
          <source>PostForm issues a POST to the specified URL, with data's keys and values URL-encoded as the request body.</source>
          <target state="translated">PostForm向指定的URL发出一个POST,数据的键和值的URL编码作为请求体。</target>
        </trans-unit>
        <trans-unit id="be4e82ca926447e7fa579fe9a0de6822470bae52" translate="yes" xml:space="preserve">
          <source>PostFormValue returns the first value for the named component of the POST, PATCH, or PUT request body. URL query parameters are ignored. PostFormValue calls ParseMultipartForm and ParseForm if necessary and ignores any errors returned by these functions. If key is not present, PostFormValue returns the empty string.</source>
          <target state="translated">PostFormValue返回POST、PATCH或PUT请求体中命名组件的第一个值。URL查询参数会被忽略。PostFormValue在必要时调用ParseMultipartForm和ParseForm,并忽略这些函数返回的任何错误。如果key不存在,PostFormValue将返回空字符串。</target>
        </trans-unit>
        <trans-unit id="be28cb761efe315e0e552f0578874dbad93fb2dd" translate="yes" xml:space="preserve">
          <source>Pow</source>
          <target state="translated">Pow</target>
        </trans-unit>
        <trans-unit id="f475da806450b4216a6a39ef8f751e26584a0aa3" translate="yes" xml:space="preserve">
          <source>Pow returns x**y, the base-x exponential of y.</source>
          <target state="translated">Pow返回x**y,即y的基x指数。</target>
        </trans-unit>
        <trans-unit id="6d31ee5908c32da0243ccfa92f5fe1c7b3e3aeaf" translate="yes" xml:space="preserve">
          <source>Pow returns x**y, the base-x exponential of y. For generalized compatibility with math.Pow:</source>
          <target state="translated">Pow返回x**y,即y的基数-x指数,与math.Pow.Pow通用。</target>
        </trans-unit>
        <trans-unit id="f348c46b140ea99d08517640a0cfa8eff3f40986" translate="yes" xml:space="preserve">
          <source>Pow10</source>
          <target state="translated">Pow10</target>
        </trans-unit>
        <trans-unit id="aee903bac5380775ed6f4d539640fd38f8839815" translate="yes" xml:space="preserve">
          <source>Pow10 returns 10**n, the base-10 exponential of n.</source>
          <target state="translated">Pow10返回10**n,n的基数10指数。</target>
        </trans-unit>
        <trans-unit id="5411be6b25a0cd127e0815f04ee1c12c71a3cf9d" translate="yes" xml:space="preserve">
          <source>Prec returns the mantissa precision of x in bits. The result may be 0 for |x| == 0 and |x| == Inf.</source>
          <target state="translated">Prec 返回 x 的位数精度。对于|x| ==0和|x| ==Inf,结果可能是0。</target>
        </trans-unit>
        <trans-unit id="012c1f9cb43bafa38c87d810c24d42b2a0e95129" translate="yes" xml:space="preserve">
          <source>Precedence returns the operator precedence of the binary operator op. If op is not a binary operator, the result is LowestPrecedence.</source>
          <target state="translated">Precedence 返回二进制运算符 op 的运算符优先级。如果运算符op不是二进制运算符,那么结果是LowestPrecedence。</target>
        </trans-unit>
        <trans-unit id="06b7f0534bb083dff059cb7b1d374b3c3f1e0a29" translate="yes" xml:space="preserve">
          <source>Precompute performs some calculations that speed up private key operations in the future.</source>
          <target state="translated">预计算会进行一些计算,加快未来私钥操作的速度。</target>
        </trans-unit>
        <trans-unit id="34240aca8e0c8b909225cdb2f4dfdd60a5391649" translate="yes" xml:space="preserve">
          <source>Precondition: the Uses and Defs maps are populated.</source>
          <target state="translated">前提:Uses和Defs地图已被填充。</target>
        </trans-unit>
        <trans-unit id="7070c5f6250bbd470fe7f73bafbee45d2955ddb3" translate="yes" xml:space="preserve">
          <source>Predefined global functions are named as follows.</source>
          <target state="translated">预定义的全局函数命名如下:</target>
        </trans-unit>
        <trans-unit id="e21e54618fe5bb45663e64ef56fb6717d24f3e6f" translate="yes" xml:space="preserve">
          <source>Predefined layouts ANSIC, UnixDate, RFC3339 and others describe standard and convenient representations of the reference time. For more information about the formats and the definition of the reference time, see the documentation for ANSIC and the other constants defined by this package.</source>
          <target state="translated">预定义的布局ANSIC、UnixDate、RFC3339等描述了参考时间的标准和方便的表示方式。关于参考时间的格式和定义的更多信息,请参见ANSIC和本软件包定义的其他常量的文档。</target>
        </trans-unit>
        <trans-unit id="19d40016f56bfc80ec50dda03a3f66d54afe65d3" translate="yes" xml:space="preserve">
          <source>Predefined layouts ANSIC, UnixDate, RFC3339 and others describe standard and convenient representations of the reference time. For more information about the formats and the definition of the reference time, see the documentation for ANSIC and the other constants defined by this package. Also, the executable example for Time.Format demonstrates the working of the layout string in detail and is a good reference.</source>
          <target state="translated">预定义的布局ANSIC、UnixDate、RFC3339等描述了参考时间的标准和方便的表示方式。有关格式和参考时间定义的更多信息,请参见ANSIC和本包定义的其他常量的文档。另外,Time.Format的可执行示例详细演示了布局字符串的工作原理,是一个很好的参考。</target>
        </trans-unit>
        <trans-unit id="019d3598b39c078722d988d313bff8da4d9cf574" translate="yes" xml:space="preserve">
          <source>Predefined mode bits to control recognition of tokens. For instance, to configure a Scanner such that it only recognizes (Go) identifiers, integers, and skips comments, set the Scanner's Mode field to:</source>
          <target state="translated">预定义的模式位,用于控制标记的识别。例如,要将扫描仪配置为只识别(Go)标识符、整数并跳过注释,请将扫描仪的模式字段设置为:。</target>
        </trans-unit>
        <trans-unit id="0eea29821ab0f93a1960c9475350fbefcdab3d2f" translate="yes" xml:space="preserve">
          <source>Predefined polynomials.</source>
          <target state="translated">预定义多项式。</target>
        </trans-unit>
        <trans-unit id="0d4a9c1b8dc6a14ced81402c9c52d4cba69192f5" translate="yes" xml:space="preserve">
          <source>Prefix returns a literal string that all matches for the regexp must start with. Complete is true if the prefix is the entire match.</source>
          <target state="translated">Prefix 返回一个字面字符串,所有匹配的regexp都必须以这个字符串开始。如果前缀是整个匹配项,则Complete为true。</target>
        </trans-unit>
        <trans-unit id="07aedbb616a135989fac4d8d72b5c4a5c5d60c82" translate="yes" xml:space="preserve">
          <source>Prefix returns the output prefix for the logger.</source>
          <target state="translated">Prefix 返回记录仪的输出前缀。</target>
        </trans-unit>
        <trans-unit id="d115a4bd5d23f67905e010343d63485a225c3e87" translate="yes" xml:space="preserve">
          <source>Prefix returns the output prefix for the standard logger.</source>
          <target state="translated">Prefix 返回标准记录器的输出前缀。</target>
        </trans-unit>
        <trans-unit id="8a0ad1efe973aa121d35889249f93a7d412bb0f0" translate="yes" xml:space="preserve">
          <source>Prepare creates a prepared statement for later queries or executions. Multiple queries or executions may be run concurrently from the returned statement. The caller must call the statement's Close method when the statement is no longer needed.</source>
          <target state="translated">Prepare为以后的查询或执行创建一个准备好的语句。可以从返回的语句中同时运行多个查询或执行。当不再需要该语句时,调用者必须调用语句的关闭方法。</target>
        </trans-unit>
        <trans-unit id="a2f69751c5da712872417f2a510b17bd5264a134" translate="yes" xml:space="preserve">
          <source>Prepare creates a prepared statement for use within a transaction.</source>
          <target state="translated">Prepare 创建一个准备好的报表,供交易中使用。</target>
        </trans-unit>
        <trans-unit id="19c3c9a0f98a28102c0e736d9c3bf4d64087898f" translate="yes" xml:space="preserve">
          <source>PrepareContext creates a prepared statement for later queries or executions. Multiple queries or executions may be run concurrently from the returned statement. The caller must call the statement's Close method when the statement is no longer needed.</source>
          <target state="translated">PrepareContext为以后的查询或执行创建一个准备好的语句。可以从返回的语句中并发运行多个查询或执行。当不再需要该语句时,调用者必须调用语句的Close方法。</target>
        </trans-unit>
        <trans-unit id="a6597b9664b9651bf9f54fe07c6db1a86396a5f0" translate="yes" xml:space="preserve">
          <source>PrepareContext creates a prepared statement for use within a transaction.</source>
          <target state="translated">PrepareContext创建了一个准备好的语句,供在事务中使用。</target>
        </trans-unit>
        <trans-unit id="152856201f7dfb04864788231e3dca46c0bc77c0" translate="yes" xml:space="preserve">
          <source>Prev returns the previous list element or nil.</source>
          <target state="translated">Prev 返回上一个列表元素或nil。</target>
        </trans-unit>
        <trans-unit id="c4d145ba4ec6ded69ec8461fe1ea7b2b7ec58ca2" translate="yes" xml:space="preserve">
          <source>Prev returns the previous ring element. r must not be empty.</source>
          <target state="translated">Prev 返回上一个环元素,r不能为空。</target>
        </trans-unit>
        <trans-unit id="88971ab7b2fead8d5aa7c50c15f575453db641e4" translate="yes" xml:space="preserve">
          <source>Prime returns a number, p, of the given size, such that p is prime with high probability. Prime will return error for any error returned by rand.Read or if bits &amp;lt; 2.</source>
          <target state="translated">素数返回给定大小的数字p，因此p是极有可能的素数。如果rand.Read返回的任何错误或位&amp;lt;2，Prime将返回错误。</target>
        </trans-unit>
        <trans-unit id="5b221e9c2a451799d8f37e2b9874409d5e03ab05" translate="yes" xml:space="preserve">
          <source>Print</source>
          <target state="translated">Print</target>
        </trans-unit>
        <trans-unit id="f10e9ffa0b7bfc2f4378fe30b103cef0c696cbab" translate="yes" xml:space="preserve">
          <source>Print calls Output to print to the standard logger. Arguments are handled in the manner of fmt.Print.</source>
          <target state="translated">Print调用Output打印到标准记录器。参数的处理方式与fmt.Print相同。</target>
        </trans-unit>
        <trans-unit id="da7a32afaab2e92c2ad95514fe5016080d044d92" translate="yes" xml:space="preserve">
          <source>Print calls l.Output to print to the logger. Arguments are handled in the manner of fmt.Print.</source>
          <target state="translated">Print调用l.Output打印到记录仪。参数的处理方式与fmt.Print相同。</target>
        </trans-unit>
        <trans-unit id="ef0199bdcf8fc8fa33bd7d6ab92875f9706a01bd" translate="yes" xml:space="preserve">
          <source>Print formats using the default formats for its operands and writes to standard output. Spaces are added between operands when neither is a string. It returns the number of bytes written and any write error encountered.</source>
          <target state="translated">使用操作数的默认格式打印格式,并写入标准输出。当操作数都不是字符串时,操作数之间会添加空格。它返回写入的字节数和遇到的任何写入错误。</target>
        </trans-unit>
        <trans-unit id="5d837aa33f1404ff26202e67efb03427b1d31566" translate="yes" xml:space="preserve">
          <source>Print prints x to standard output, skipping nil fields. Print(fset, x) is the same as Fprint(os.Stdout, fset, x, NotNilFilter).</source>
          <target state="translated">Print 将 x 打印到标准输出,跳过 nil 字段。Print(fset,x)和 Fprint(os.Stdout,fset,x,NotNilFilter)是一样的。</target>
        </trans-unit>
        <trans-unit id="fff8914dcd8a6ac6b5cf34d89aeea00386da1b24" translate="yes" xml:space="preserve">
          <source>Print, Println, and Printf lay out their arguments differently. In this example we can compare their behaviors. Println always adds blanks between the items it prints, while Print adds blanks only between non-string arguments and Printf does exactly what it is told. Sprint, Sprintln, Sprintf, Fprint, Fprintln, and Fprintf behave the same as their corresponding Print, Println, and Printf functions shown here.</source>
          <target state="translated">Print、Println和Printf的参数布局不同。在这个例子中,我们可以比较它们的行为。Println总是在打印的项目之间添加空白,而Print只在非字符串参数之间添加空白,Printf则完全按照命令行事。Sprint、Sprintln、Sprintf、Fprint、Fprintln和Fprintf的行为和它们对应的Print、Println和Printf函数的行为一样。</target>
        </trans-unit>
        <trans-unit id="809bcd004fc9b80aebb7cc5d33f0d171da74d5a1" translate="yes" xml:space="preserve">
          <source>PrintDefaults prints, to standard error unless configured otherwise, a usage message showing the default settings of all defined command-line flags. For an integer valued flag x, the default output has the form</source>
          <target state="translated">PrintDefaults以标准的错误方式打印,除非另有配置,否则打印出一条使用信息,显示所有定义的命令行标志的默认设置。对于一个整数值的标志x,默认的输出形式为</target>
        </trans-unit>
        <trans-unit id="66f194d8340d19b81ae4cbbaf04b180769f0bc50" translate="yes" xml:space="preserve">
          <source>PrintDefaults prints, to standard error unless configured otherwise, the default values of all defined command-line flags in the set. See the documentation for the global function PrintDefaults for more information.</source>
          <target state="translated">除非另有配置,否则PrintDefaults会以标准错误打印出集合中所有定义的命令行标志的默认值。更多信息请参见全局函数PrintDefaults的文档。</target>
        </trans-unit>
        <trans-unit id="0413304ebeab6806f19cc2877f7f0a8ff6c54cbc" translate="yes" xml:space="preserve">
          <source>PrintError is a utility function that prints a list of errors to w, one error per line, if the err parameter is an ErrorList. Otherwise it prints the err string.</source>
          <target state="translated">PrintError是一个实用函数,如果err参数是ErrorList,则打印错误列表到w,每行一个错误。否则会打印出err字符串。</target>
        </trans-unit>
        <trans-unit id="ebb2a34b39577c89ac6bbac4cad20176461fcd0b" translate="yes" xml:space="preserve">
          <source>PrintRanges defines the set of printable characters according to Go. ASCII space, U+0020, is handled separately.</source>
          <target state="translated">PrintRanges根据围棋定义了可打印字符集。ASCII空间,U+0020,单独处理。</target>
        </trans-unit>
        <trans-unit id="e979fdd38cfa18a2850ab6725519f82f13a4893f" translate="yes" xml:space="preserve">
          <source>PrintStack prints to standard error the stack trace returned by runtime.Stack.</source>
          <target state="translated">PrintStack将runtime.Stack.Runtime.Stack返回的堆栈跟踪打印成标准错误。</target>
        </trans-unit>
        <trans-unit id="49c6710eb43a270c0d99f60d369594f6b1f09d42" translate="yes" xml:space="preserve">
          <source>Printf</source>
          <target state="translated">Printf</target>
        </trans-unit>
        <trans-unit id="d092eac8d8c7315f01318a4675b38dcda90f6b2f" translate="yes" xml:space="preserve">
          <source>Printf calls Output to print to the standard logger. Arguments are handled in the manner of fmt.Printf.</source>
          <target state="translated">Printf调用Output打印到标准记录器。参数的处理方式与fmt.Printf相同。</target>
        </trans-unit>
        <trans-unit id="d34579b37294eb8c93cd5f76572f924816678d0e" translate="yes" xml:space="preserve">
          <source>Printf calls l.Output to print to the logger. Arguments are handled in the manner of fmt.Printf.</source>
          <target state="translated">Printf调用l.Output打印到记录仪。参数的处理方式与fmt.Printf相同。</target>
        </trans-unit>
        <trans-unit id="e063c30289e6b7981e882f4697ef852c1f482795" translate="yes" xml:space="preserve">
          <source>Printf formats according to a format specifier and writes to standard output. It returns the number of bytes written and any write error encountered.</source>
          <target state="translated">Printf根据格式指定器格式化并写入标准输出。它返回写入的字节数和遇到的任何写入错误。</target>
        </trans-unit>
        <trans-unit id="28fa9c40e9ffd74bb5b4f094116329456de9f692" translate="yes" xml:space="preserve">
          <source>PrintfLine writes the formatted output followed by \r\n.</source>
          <target state="translated">PrintfLine将格式化的输出写在后面。</target>
        </trans-unit>
        <trans-unit id="f16eadab2a72ff13044cc806dbcf2c117b32244f" translate="yes" xml:space="preserve">
          <source>Printing</source>
          <target state="translated">Printing</target>
        </trans-unit>
        <trans-unit id="9be957a1debff697aafdc7801a3e8785262f0c15" translate="yes" xml:space="preserve">
          <source>Println</source>
          <target state="translated">Println</target>
        </trans-unit>
        <trans-unit id="29f11f56c6deffe1a15f67edc9a4aa4f5e39f28b" translate="yes" xml:space="preserve">
          <source>Println calls Output to print to the standard logger. Arguments are handled in the manner of fmt.Println.</source>
          <target state="translated">Println调用Output打印到标准记录器。参数的处理方式与fmt.Println相同。</target>
        </trans-unit>
        <trans-unit id="cddfe7aeafd7792bfbbf9d5f8715705f967fa901" translate="yes" xml:space="preserve">
          <source>Println calls l.Output to print to the logger. Arguments are handled in the manner of fmt.Println.</source>
          <target state="translated">Println调用l.Output打印到记录器。参数的处理方式与fmt.Println相同。</target>
        </trans-unit>
        <trans-unit id="811e4464a94616bb8d26e71f2e575488ec162b1d" translate="yes" xml:space="preserve">
          <source>Println formats using the default formats for its operands and writes to standard output. Spaces are always added between operands and a newline is appended. It returns the number of bytes written and any write error encountered.</source>
          <target state="translated">Println使用默认的操作数格式进行格式化,并写入标准输出。操作数之间总是添加空格,并附加一个换行。它返回写入的字节数和遇到的任何写入错误。</target>
        </trans-unit>
        <trans-unit id="ca8881cd0811d2e92d6c86ae2702d8e81b20152f" translate="yes" xml:space="preserve">
          <source>PrivateKey is the type of Ed25519 private keys. It implements crypto.Signer.</source>
          <target state="translated">PrivateKey是Ed25519私钥的类型。它实现了crypto.Signer。</target>
        </trans-unit>
        <trans-unit id="0a4394946d56678a7614480ff518a3bad620dfd6" translate="yes" xml:space="preserve">
          <source>PrivateKey represents a DSA private key.</source>
          <target state="translated">PrivateKey表示一个DSA私钥。</target>
        </trans-unit>
        <trans-unit id="5828291a45f65d96ddf669061359c25c2c15c6d0" translate="yes" xml:space="preserve">
          <source>PrivateKey represents a private key using an unspecified algorithm.</source>
          <target state="translated">PrivateKey表示使用未指定算法的私钥。</target>
        </trans-unit>
        <trans-unit id="6a98b6c2702640d21b9c48b8d270c3e30325339a" translate="yes" xml:space="preserve">
          <source>PrivateKey represents an ECDSA private key.</source>
          <target state="translated">PrivateKey表示ECDSA私钥。</target>
        </trans-unit>
        <trans-unit id="5d801231cb01d152413f0eb3fd1b96b8b8b32f86" translate="yes" xml:space="preserve">
          <source>ProbablyPrime is 100% accurate for inputs less than 2⁶⁴. See Menezes et al., Handbook of Applied Cryptography, 1997, pp. 145-149, and FIPS 186-4 Appendix F for further discussion of the error probabilities.</source>
          <target state="translated">ProbablyPrime对于小于2⁶⁴的输入是100%准确的。参见Menezes等人,Handbook of Applied Cryptography,1997,第145-149页,以及FIPS 186-4附录F对错误概率的进一步讨论。</target>
        </trans-unit>
        <trans-unit id="442fffca41b5ff8be9e7d3c5a0d5bb3bcdd79c79" translate="yes" xml:space="preserve">
          <source>ProbablyPrime is not suitable for judging primes that an adversary may have crafted to fool the test.</source>
          <target state="translated">ProbablyPrime不适合判断对手可能精心制作的primes来骗取测试。</target>
        </trans-unit>
        <trans-unit id="c5acf5649dd4748b450f268e217b8fc03d7e5d83" translate="yes" xml:space="preserve">
          <source>ProbablyPrime reports whether x is probably prime, applying the Miller-Rabin test with n pseudorandomly chosen bases as well as a Baillie-PSW test.</source>
          <target state="translated">ProbablyPrime报告x是否可能是质数,应用Miller-Rabin测试与n个伪随机选择的碱基以及Baillie-PSW测试。</target>
        </trans-unit>
        <trans-unit id="f565348ea6c07ff9cfffba23f4ddef524854d6c5" translate="yes" xml:space="preserve">
          <source>ProcAttr holds attributes that will be applied to a new process started by StartProcess.</source>
          <target state="translated">ProcAttr持有应用于StartProcess启动的新进程的属性。</target>
        </trans-unit>
        <trans-unit id="e12810a35fd4b52423e92a433b314e79f5156c70" translate="yes" xml:space="preserve">
          <source>ProcAttr holds the attributes that will be applied to a new process started by StartProcess.</source>
          <target state="translated">ProcAttr持有将应用于StartProcess启动的新进程的属性。</target>
        </trans-unit>
        <trans-unit id="5373df2ffeb91866eef2c38e2502d77f1e33d970" translate="yes" xml:space="preserve">
          <source>Process stores the information about a process created by StartProcess.</source>
          <target state="translated">Process存储了StartProcess创建的进程的信息。</target>
        </trans-unit>
        <trans-unit id="7be9488d8073639c8b5c8f975d63715a76c9482d" translate="yes" xml:space="preserve">
          <source>ProcessEnv returns FastCGI environment variables associated with the request r for which no effort was made to be included in the request itself - the data is hidden in the request's context. As an example, if REMOTE_USER is set for a request, it will not be found anywhere in r, but it will be included in ProcessEnv's response (via r's context).</source>
          <target state="translated">ProcessEnv返回与请求r相关联的FastCGI环境变量,这些变量没有被努力包含在请求本身中--数据被隐藏在请求的上下文中。举个例子,如果为请求设置了REMOTE_USER,那么在r中任何地方都找不到它,但它会被包含在ProcessEnv的响应中(通过r的上下文)。</target>
        </trans-unit>
        <trans-unit id="9471e4ecfd3d8f84d8e198229a6e563cc60bb5bd" translate="yes" xml:space="preserve">
          <source>ProcessState stores information about a process, as reported by Wait.</source>
          <target state="translated">ProcessState存储了一个进程的信息,由Wait报告。</target>
        </trans-unit>
        <trans-unit id="1ccb21389489c4ce498c4e53d4d69158c5c216b7" translate="yes" xml:space="preserve">
          <source>Profile responds with the pprof-formatted cpu profile. Profiling lasts for duration specified in seconds GET parameter, or for 30 seconds if not specified. The package initialization registers it as /debug/pprof/profile.</source>
          <target state="translated">配置文件以pprof格式化的cpu配置文件响应。配置文件的持续时间用GET参数secondes指定,如果没有指定,则持续30秒。软件包初始化将其注册为/debug/pprof/profile。</target>
        </trans-unit>
        <trans-unit id="a111deba4cb386ad7d27a3a5da110f46f90e53f3" translate="yes" xml:space="preserve">
          <source>Profiles are only as good as the kernel support used to generate them. See &lt;a href=&quot;https://golang.org/issue/13841&quot;&gt;https://golang.org/issue/13841&lt;/a&gt; for details about known problems.</source>
          <target state="translated">概要文件仅与用于生成概要文件的内核支持一样好。有关已知问题的详细信息，请参见&lt;a href=&quot;https://golang.org/issue/13841&quot;&gt;https://golang.org/issue/13841&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f633a064ff1568b947a4aec717cb8ff7b8d5f4c3" translate="yes" xml:space="preserve">
          <source>Profiles can then be visualized with the pprof tool:</source>
          <target state="translated">然后,可以使用pprof工具对配置文件进行可视化。</target>
        </trans-unit>
        <trans-unit id="f43cf39e026d58fac3cfa9c9d78bd864d77127ed" translate="yes" xml:space="preserve">
          <source>Profiles returns a slice of all the known profiles, sorted by name.</source>
          <target state="translated">Profiles(配置文件)返回按名称排序的所有已知配置文件的片断。</target>
        </trans-unit>
        <trans-unit id="e204c80d31036e0e024c0b7ffd8999a887af815c" translate="yes" xml:space="preserve">
          <source>Profiling a Go program</source>
          <target state="translated">剖析一个围棋程序</target>
        </trans-unit>
        <trans-unit id="cd24f23a82cfebc48d38726d6b4c3ec7db051af8" translate="yes" xml:space="preserve">
          <source>Prog.Flag</source>
          <target state="translated">Prog.Flag</target>
        </trans-unit>
        <trans-unit id="48f3611555518363414a9b1db2fa49f474f76e67" translate="yes" xml:space="preserve">
          <source>Prog.Type</source>
          <target state="translated">Prog.Type</target>
        </trans-unit>
        <trans-unit id="2301ced48f29c8456865c04cd47334c707828d9b" translate="yes" xml:space="preserve">
          <source>Programs that use Contexts should follow these rules to keep interfaces consistent across packages and enable static analysis tools to check context propagation:</source>
          <target state="translated">使用Contexts的程序应该遵循这些规则,以保持不同包的接口一致,并使静态分析工具能够检查上下文传播。</target>
        </trans-unit>
        <trans-unit id="3ac27ec45d4018361c7d594bf7eaa91a1292edd0" translate="yes" xml:space="preserve">
          <source>Programs using times should typically store and pass them as values, not pointers. That is, time variables and struct fields should be of type time.Time, not *time.Time.</source>
          <target state="translated">使用时间的程序通常应该以值的形式存储和传递时间,而不是指针。也就是说,时间变量和结构域的类型应该是time.Time,而不是*time.Time。</target>
        </trans-unit>
        <trans-unit id="c9ee0039dcc32da9c4cde1d419e8461ac1dfbdc7" translate="yes" xml:space="preserve">
          <source>Properties is the set of Unicode property tables.</source>
          <target state="translated">属性是Unicode属性表的集合。</target>
        </trans-unit>
        <trans-unit id="8768305a872da3684ae4bda3f68612735ba56c08" translate="yes" xml:space="preserve">
          <source>Properties of basic types.</source>
          <target state="translated">基本类型的属性。</target>
        </trans-unit>
        <trans-unit id="8a0d90b2918aadcefa0c95820abf21b6534492f2" translate="yes" xml:space="preserve">
          <source>ProtoAtLeast reports whether the HTTP protocol used in the request is at least major.minor.</source>
          <target state="translated">ProtoAtLeast报告请求中使用的HTTP协议是否至少是major.minor。</target>
        </trans-unit>
        <trans-unit id="ff9e390e5de482119dc42236df206efa900791fc" translate="yes" xml:space="preserve">
          <source>ProtoAtLeast reports whether the HTTP protocol used in the response is at least major.minor.</source>
          <target state="translated">ProtoAtLeast报告响应中使用的HTTP协议是否至少是major.minor。</target>
        </trans-unit>
        <trans-unit id="5829d5d1675f9485036e8bdae05dd67dac955b66" translate="yes" xml:space="preserve">
          <source>ProtocolError represents an HTTP protocol error.</source>
          <target state="translated">ProtocolError表示HTTP协议错误。</target>
        </trans-unit>
        <trans-unit id="c78f3a99754e80287f834beff8dcfd502a6d93a8" translate="yes" xml:space="preserve">
          <source>Provided that T2 is no larger than T1 and that the two share an equivalent memory layout, this conversion allows reinterpreting data of one type as data of another type. An example is the implementation of math.Float64bits:</source>
          <target state="translated">只要T2不大于T1,并且两者共享等效的内存布局,这种转换允许将一种类型的数据重新解释为另一种类型的数据。一个例子是math.Float64bits的实现。</target>
        </trans-unit>
        <trans-unit id="2667527e2309cea50315245bf9e96ef013a2321b" translate="yes" xml:space="preserve">
          <source>ProxyFromEnvironment returns the URL of the proxy to use for a given request, as indicated by the environment variables HTTP_PROXY, HTTPS_PROXY and NO_PROXY (or the lowercase versions thereof). HTTPS_PROXY takes precedence over HTTP_PROXY for https requests.</source>
          <target state="translated">ProxyFromEnvironment返回代理服务器的URL,用于给定的请求,如环境变量HTTP_PROXY、HTTPS_PROXY和NO_PROXY(或其小写版本)所示。对于https请求,HTTPS_PROXY优先于HTTP_PROXY。</target>
        </trans-unit>
        <trans-unit id="ce1c8acc8d3a18105ad805c3050485bfd7af1196" translate="yes" xml:space="preserve">
          <source>ProxyURL returns a proxy function (for use in a Transport) that always returns the same URL.</source>
          <target state="translated">ProxyURL 返回一个总是返回相同 URL 的代理函数(用于传输)。</target>
        </trans-unit>
        <trans-unit id="256df6693e9938b002805ef141a169ee9b0517c0" translate="yes" xml:space="preserve">
          <source>Pt is shorthand for Point{X, Y}.</source>
          <target state="translated">Pt是Point{X,Y}的简写。</target>
        </trans-unit>
        <trans-unit id="72df9c957a8f34680bd544544cf16bd450f7c686" translate="yes" xml:space="preserve">
          <source>PtrTo returns the pointer type with element t. For example, if t represents type Foo, PtrTo(t) represents *Foo.</source>
          <target state="translated">例如,如果t代表类型Foo,PtrTo(t)代表*Foo。</target>
        </trans-unit>
        <trans-unit id="1b89d49d722a1ef7d3c4ddfb234a1400f1a92cf6" translate="yes" xml:space="preserve">
          <source>Public returns the PublicKey corresponding to priv.</source>
          <target state="translated">Public返回与priv对应的PublicKey。</target>
        </trans-unit>
        <trans-unit id="2649f0278f57fd7af2dbdfb64c901b42e9d9789a" translate="yes" xml:space="preserve">
          <source>Public returns the public key corresponding to priv.</source>
          <target state="translated">Public 返回与priv对应的公钥。</target>
        </trans-unit>
        <trans-unit id="0d04adf8945e312c7d47fec2108c21b2684c9af5" translate="yes" xml:space="preserve">
          <source>PublicKey is the type of Ed25519 public keys.</source>
          <target state="translated">PublicKey是Ed25519公钥的类型。</target>
        </trans-unit>
        <trans-unit id="5001eedc91686ba11ee390e67cd1a676465f5d14" translate="yes" xml:space="preserve">
          <source>PublicKey represents a DSA public key.</source>
          <target state="translated">PublicKey代表一个DSA公钥。</target>
        </trans-unit>
        <trans-unit id="3acd186c84de8cd73322d4669ae9a4bf40b59d13" translate="yes" xml:space="preserve">
          <source>PublicKey represents a public key using an unspecified algorithm.</source>
          <target state="translated">PublicKey表示一个使用未指定算法的公钥。</target>
        </trans-unit>
        <trans-unit id="2f28570f8dc7131bd19dca1ee8af4ed1f0eeb1b5" translate="yes" xml:space="preserve">
          <source>PublicKey represents an ECDSA public key.</source>
          <target state="translated">PublicKey表示ECDSA公钥。</target>
        </trans-unit>
        <trans-unit id="b2140dd5a5a558ac28d58aa5d36d6a21620f906f" translate="yes" xml:space="preserve">
          <source>PublicSuffixList provides the public suffix of a domain. For example:</source>
          <target state="translated">PublicSuffixList提供了一个域名的公共后缀。例如</target>
        </trans-unit>
        <trans-unit id="edb82c4a8bbcf78c8a1448e29c8d98e501e15f1e" translate="yes" xml:space="preserve">
          <source>Publish declares a named exported variable. This should be called from a package's init function when it creates its Vars. If the name is already registered then this will log.Panic.</source>
          <target state="translated">发布声明一个命名的导出变量。当包创建其Vars时,应该从包的init函数中调用这个变量。如果名字已经被注册了,那么这将会log.Panic。</target>
        </trans-unit>
        <trans-unit id="2bf5378cf82463ae57e7e9a30e9ba5b326dba3d6" translate="yes" xml:space="preserve">
          <source>Push pushes the element x onto the heap. The complexity is O(log n) where n = h.Len().</source>
          <target state="translated">Push将元素x推到堆上。复杂度为O(log n),其中n=h.Len()。</target>
        </trans-unit>
        <trans-unit id="f4b202999ae2b93ddb6f5cd751aefdf3cb3293cf" translate="yes" xml:space="preserve">
          <source>PushBack inserts a new element e with value v at the back of list l and returns e.</source>
          <target state="translated">PushBack在列表l的后面插入一个新元素e,其值为v,并返回e。</target>
        </trans-unit>
        <trans-unit id="a50f3f664eb834d0bdb9f4d025dcb754c041066d" translate="yes" xml:space="preserve">
          <source>PushBackList inserts a copy of an other list at the back of list l. The lists l and other may be the same. They must not be nil.</source>
          <target state="translated">PushBackList在列表l的后面插入一个其他列表的副本。 列表l和其他列表可以是相同的。它们不能为零。</target>
        </trans-unit>
        <trans-unit id="a8c99a25179d82d5afa3406e22b548a0252f1474" translate="yes" xml:space="preserve">
          <source>PushFront inserts a new element e with value v at the front of list l and returns e.</source>
          <target state="translated">PushFront在列表l的前面插入一个新元素e,其值为v,并返回e。</target>
        </trans-unit>
        <trans-unit id="13a7ef38dc8b3d5639e9784f576b7dc8f0a8b795" translate="yes" xml:space="preserve">
          <source>PushFrontList inserts a copy of an other list at the front of list l. The lists l and other may be the same. They must not be nil.</source>
          <target state="translated">PushFrontList在列表l的前面插入了一个其他列表的副本,列表l和其他列表可以是相同的。它们不能为零。</target>
        </trans-unit>
        <trans-unit id="5520408cb4fcced642940bef6746727866edb323" translate="yes" xml:space="preserve">
          <source>PushOptions describes options for Pusher.Push.</source>
          <target state="translated">PushOptions描述了Pusher.Push的选项。</target>
        </trans-unit>
        <trans-unit id="192422b7c0ce1637e319052ddc27aa0f79641ec0" translate="yes" xml:space="preserve">
          <source>Pusher is the interface implemented by ResponseWriters that support HTTP/2 server push. For more background, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7540#section-8.2&quot;&gt;https://tools.ietf.org/html/rfc7540#section-8.2&lt;/a&gt;.</source>
          <target state="translated">Pusher是由ResponseWriters实现的支持HTTP / 2服务器推送的接口。有关更多背景信息，请参见&lt;a href=&quot;https://tools.ietf.org/html/rfc7540#section-8.2&quot;&gt;https://tools.ietf.org/html/rfc7540#section-8.2&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5810d2cea2c4c839a1cbc6f93eed06050e059bdc" translate="yes" xml:space="preserve">
          <source>Put adds x to the pool.</source>
          <target state="translated">把增加X到池中。</target>
        </trans-unit>
        <trans-unit id="6b32dae99e29878f191b30318e13ee160e3e9c11" translate="yes" xml:space="preserve">
          <source>PutUvarint</source>
          <target state="translated">PutUvarint</target>
        </trans-unit>
        <trans-unit id="d471216e431bf21e4cd2b9153a740d7d8a93b34a" translate="yes" xml:space="preserve">
          <source>PutUvarint encodes a uint64 into buf and returns the number of bytes written. If the buffer is too small, PutUvarint will panic.</source>
          <target state="translated">PutUvarint 将一个 uint64 编码成 buf,并返回写入的字节数。如果缓冲区太小,PutUvarint会惊慌失措。</target>
        </trans-unit>
        <trans-unit id="88299e1b8aa44f2b22e86375ae77e2d6a8112536" translate="yes" xml:space="preserve">
          <source>PutVarint</source>
          <target state="translated">PutVarint</target>
        </trans-unit>
        <trans-unit id="bd00eee1df8f0b67019e2ad70e9156e5fa1de99c" translate="yes" xml:space="preserve">
          <source>PutVarint encodes an int64 into buf and returns the number of bytes written. If the buffer is too small, PutVarint will panic.</source>
          <target state="translated">PutVarint将一个int64编码到buf中,并返回写入的字节数。如果缓冲区太小,PutVarint会惊慌失措。</target>
        </trans-unit>
        <trans-unit id="95ab58079356ed9aa8893c2df192745f32d71297" translate="yes" xml:space="preserve">
          <source>Quantizer produces a palette for an image.</source>
          <target state="translated">量子化器为图像生成一个调色板。</target>
        </trans-unit>
        <trans-unit id="05437837ec4647b7c23a7c5944b51f3ac43e58c7" translate="yes" xml:space="preserve">
          <source>Query executes a prepared query statement with the given arguments and returns the query results as a *Rows.</source>
          <target state="translated">Query执行一个带有给定参数的准备好的查询语句,并将查询结果以*Rows的形式返回。</target>
        </trans-unit>
        <trans-unit id="d610ca285b8521b4fbaa375322142cf95d05446a" translate="yes" xml:space="preserve">
          <source>Query executes a query that returns rows, typically a SELECT.</source>
          <target state="translated">Query执行一个返回行的查询,通常是一个SELECT。</target>
        </trans-unit>
        <trans-unit id="e1388b391779ee3280bdae6ba4b75470fb85b182" translate="yes" xml:space="preserve">
          <source>Query executes a query that returns rows, typically a SELECT. The args are for any placeholder parameters in the query.</source>
          <target state="translated">Query执行一个返回行的查询,通常是一个SELECT。args是查询中的任何占位参数。</target>
        </trans-unit>
        <trans-unit id="73ccd82bfd6eca331cabb2dba278895a7773c1c8" translate="yes" xml:space="preserve">
          <source>Query is expected to be a list of key=value settings separated by ampersands or semicolons. A setting without an equals sign is interpreted as a key set to an empty value.</source>
          <target state="translated">查询应该是一个键=值设置的列表,由安培或分号分隔。没有等号的设置被解释为键设置为空值。</target>
        </trans-unit>
        <trans-unit id="4501151d792df2b730db74682f29db9657ef7ffb" translate="yes" xml:space="preserve">
          <source>Query may return ErrSkip.</source>
          <target state="translated">查询可能返回ErrSkip。</target>
        </trans-unit>
        <trans-unit id="e1b497d6ece5d419609d5ec0635dc46c1d21b395" translate="yes" xml:space="preserve">
          <source>Query parses RawQuery and returns the corresponding values. It silently discards malformed value pairs. To check errors use ParseQuery.</source>
          <target state="translated">Query解析RawQuery并返回相应的值。它默默地丢弃错误的值对。要检查错误,请使用ParseQuery。</target>
        </trans-unit>
        <trans-unit id="8a08387889457a5be56952e049ecbbf787ca1008" translate="yes" xml:space="preserve">
          <source>QueryContext executes a prepared query statement with the given arguments and returns the query results as a *Rows.</source>
          <target state="translated">QueryContext执行一个带有给定参数的准备好的查询语句,并以*Rows的形式返回查询结果。</target>
        </trans-unit>
        <trans-unit id="90f64cb7930640d89ee4991b926e5cee52278a6e" translate="yes" xml:space="preserve">
          <source>QueryContext executes a query that returns rows, typically a SELECT.</source>
          <target state="translated">QueryContext执行一个返回行的查询,通常是一个SELECT。</target>
        </trans-unit>
        <trans-unit id="610270ccdd5f9415ac6596bb377b874f11fadbf3" translate="yes" xml:space="preserve">
          <source>QueryContext executes a query that returns rows, typically a SELECT. The args are for any placeholder parameters in the query.</source>
          <target state="translated">QueryContext执行一个返回行的查询,通常是一个SELECT。args是查询中的任何占位参数。</target>
        </trans-unit>
        <trans-unit id="7370d9d4f8639b69a2498dbee7578b05f64c38fb" translate="yes" xml:space="preserve">
          <source>QueryEscape escapes the string so it can be safely placed inside a URL query.</source>
          <target state="translated">QueryEscape对字符串进行转义,这样它就可以安全地放在URL查询中。</target>
        </trans-unit>
        <trans-unit id="4ddc8a6f5079b6c63ba14548ae3605122eaf2692" translate="yes" xml:space="preserve">
          <source>QueryRow executes a prepared query statement with the given arguments. If an error occurs during the execution of the statement, that error will be returned by a call to Scan on the returned *Row, which is always non-nil. If the query selects no rows, the *Row's Scan will return ErrNoRows. Otherwise, the *Row's Scan scans the first selected row and discards the rest.</source>
          <target state="translated">QueryRow用给定的参数执行一个准备好的查询语句。如果在执行语句的过程中发生错误,该错误将通过调用返回的*Row上的Scan来返回,Scan总是非零。如果查询没有选择行,则*Row的Scan将返回ErrNoRows。否则,*Row的Scan将扫描第一条被选中的行,并丢弃其余的行。</target>
        </trans-unit>
        <trans-unit id="0573144afbb38c9c195cafc127ff8c5f7fcc98f1" translate="yes" xml:space="preserve">
          <source>QueryRow executes a query that is expected to return at most one row. QueryRow always returns a non-nil value. Errors are deferred until Row's Scan method is called. If the query selects no rows, the *Row's Scan will return ErrNoRows. Otherwise, the *Row's Scan scans the first selected row and discards the rest.</source>
          <target state="translated">QueryRow执行一个预期最多返回一条记录的查询。QueryRow总是返回一个非零值。错误会被推迟到Row的Scan方法被调用。如果查询没有选择记录,那么*Row的Scan将返回ErrNoRows。否则,*Row's Scan将扫描第一条被选中的行,并丢弃其余的行。</target>
        </trans-unit>
        <trans-unit id="5b9f01963f310c9b55f64de5af1de9e922ab703a" translate="yes" xml:space="preserve">
          <source>QueryRowContext executes a prepared query statement with the given arguments. If an error occurs during the execution of the statement, that error will be returned by a call to Scan on the returned *Row, which is always non-nil. If the query selects no rows, the *Row's Scan will return ErrNoRows. Otherwise, the *Row's Scan scans the first selected row and discards the rest.</source>
          <target state="translated">QueryRowContext用给定的参数执行一个准备好的查询语句。如果在执行语句的过程中发生了错误,该错误将通过调用返回的*Row上的Scan来返回,该*Row总是非零。如果查询没有选择行,则*Row的Scan将返回ErrNoRows。否则,*Row的Scan将扫描第一条被选中的行,并丢弃其余的行。</target>
        </trans-unit>
        <trans-unit id="297d4c57ac1fe022d65f3f9afe2a0b04f607cea7" translate="yes" xml:space="preserve">
          <source>QueryRowContext executes a query that is expected to return at most one row. QueryRowContext always returns a non-nil value. Errors are deferred until Row's Scan method is called. If the query selects no rows, the *Row's Scan will return ErrNoRows. Otherwise, the *Row's Scan scans the first selected row and discards the rest.</source>
          <target state="translated">QueryRowContext执行一个预期最多返回一条记录的查询。QueryRowContext总是返回一个非零值。错误会被推迟到Row的Scan方法被调用。如果查询没有选择记录,那么*Row的Scan将返回ErrNoRows。否则,*Row's Scan将扫描第一条被选中的行,并丢弃其余的行。</target>
        </trans-unit>
        <trans-unit id="dcdd15a746401ad098faa59578b02f667ab6f1ed" translate="yes" xml:space="preserve">
          <source>QueryUnescape does the inverse transformation of QueryEscape, converting each 3-byte encoded substring of the form &quot;%AB&quot; into the hex-decoded byte 0xAB. It returns an error if any % is not followed by two hexadecimal digits.</source>
          <target state="translated">QueryUnescape 对 QueryEscape 进行逆向转换,将每个 3 字节编码的&quot;%AB &quot;形式的子串转换为十六进制解码的字节 0xAB。如果任何%后面没有两个十六进制数字,它将返回一个错误。</target>
        </trans-unit>
        <trans-unit id="02d2728197191f99f0589563ffe142aff0d31057" translate="yes" xml:space="preserve">
          <source>Queryer is an optional interface that may be implemented by a Conn.</source>
          <target state="translated">Queryer是一个可选的接口,它可以由Conn.NET实现。</target>
        </trans-unit>
        <trans-unit id="1c47ac983cb47637ae28fbb6e2c18b4b8c42e06e" translate="yes" xml:space="preserve">
          <source>QueryerContext is an optional interface that may be implemented by a Conn.</source>
          <target state="translated">QueryerContext是一个可选的接口,可以由Conn.Conn.Context实现。</target>
        </trans-unit>
        <trans-unit id="0013523fcda039d68ac4ad5f69b453c942a978cf" translate="yes" xml:space="preserve">
          <source>QueryerContext may return ErrSkip.</source>
          <target state="translated">QueryerContext可能返回ErrSkip。</target>
        </trans-unit>
        <trans-unit id="c63975c9274fd71acb9468b157e86657fe44318f" translate="yes" xml:space="preserve">
          <source>QueryerContext must honor the context timeout and return when the context is canceled.</source>
          <target state="translated">QueryerContext必须尊重上下文超时,并在上下文被取消时返回。</target>
        </trans-unit>
        <trans-unit id="9769d5fe0c55a8ef8d81aaad984f657373379c37" translate="yes" xml:space="preserve">
          <source>Quit sends the QUIT command and closes the connection to the server.</source>
          <target state="translated">Quit发送QUIT命令,关闭与服务器的连接。</target>
        </trans-unit>
        <trans-unit id="7e1aae2dbf075bb68d93d724ad6566e5e4a1c5e3" translate="yes" xml:space="preserve">
          <source>Quo sets z to the quotient x/y and returns z. If y == 0, a division-by-zero run-time panic occurs.</source>
          <target state="translated">Quo将z设为商x/y,并返回z。如果y==0,则会发生除以零的运行时恐慌。</target>
        </trans-unit>
        <trans-unit id="a7929eb506dd3242d50cf4b52d276a4b8cb9c07b" translate="yes" xml:space="preserve">
          <source>Quo sets z to the quotient x/y for y != 0 and returns z. If y == 0, a division-by-zero run-time panic occurs. Quo implements truncated division (like Go); see QuoRem for more details.</source>
          <target state="translated">Quo将z设为y !=0的商x/y,并返回z。如果y ==0,则会发生按零除法的运行时恐慌。Quo实现了截断式除法(像Go一样);更多细节参见QuoRem。</target>
        </trans-unit>
        <trans-unit id="1572bc36f1694a28504f4543686c15ca4cc42af5" translate="yes" xml:space="preserve">
          <source>Quo sets z to the rounded quotient x/y and returns z. Precision, rounding, and accuracy reporting are as for Add. Quo panics with ErrNaN if both operands are zero or infinities. The value of z is undefined in that case.</source>
          <target state="translated">Quo 将 z 设置为四舍五入的商 x/y 并返回 z。精度、四舍五入和精度报告与 Add 相同。如果两个操作数都是零或无穷大,Quo会用ErrNaN恐慌。在这种情况下,z 的值是未定义的。</target>
        </trans-unit>
        <trans-unit id="99e212957f2d4b215b9b3d9954ca4d24b4f7b7f8" translate="yes" xml:space="preserve">
          <source>QuoRem implements T-division and modulus (like Go):</source>
          <target state="translated">QuoRem实现了T-division和modulus(像Go一样)。</target>
        </trans-unit>
        <trans-unit id="c9ddbdd15bfd376c21e0a62b9370cde6334dc1f4" translate="yes" xml:space="preserve">
          <source>QuoRem sets z to the quotient x/y and r to the remainder x%y and returns the pair (z, r) for y != 0. If y == 0, a division-by-zero run-time panic occurs.</source>
          <target state="translated">QuoRem将z设为商x/y,r设为余数x%y,并返回y !=0的对子(z,r),如果y==0,则会发生逐零除法的运行时恐慌。</target>
        </trans-unit>
        <trans-unit id="309028a9e01273ac7a88142bf26446f3f2a8f06c" translate="yes" xml:space="preserve">
          <source>Quote</source>
          <target state="translated">Quote</target>
        </trans-unit>
        <trans-unit id="02a6b721c3cbad5a2ac35c25089d53ad320899bd" translate="yes" xml:space="preserve">
          <source>Quote and QuoteToASCII convert strings to quoted Go string literals. The latter guarantees that the result is an ASCII string, by escaping any non-ASCII Unicode with \u:</source>
          <target state="translated">Quote 和 QuoteToASCII 将字符串转换为引号的围棋字符串字面。后者通过对任何非ASCII的Unicode进行转义,保证结果是一个ASCII字符串。</target>
        </trans-unit>
        <trans-unit id="3617a988d68c2550b56a0533be32b6f532f0c980" translate="yes" xml:space="preserve">
          <source>Quote returns a double-quoted Go string literal representing s. The returned string uses Go escape sequences (\t, \n, \xFF, \u0100) for control characters and non-printable characters as defined by IsPrint.</source>
          <target state="translated">返回的字符串使用Go转义序列(\t,\n,\xFF,\u0100)来表示控制字符和IsPrint定义的不可打印字符。</target>
        </trans-unit>
        <trans-unit id="6f31dc77f679cfa7aaf16ecb978ab9c3d8982f6f" translate="yes" xml:space="preserve">
          <source>QuoteMeta</source>
          <target state="translated">QuoteMeta</target>
        </trans-unit>
        <trans-unit id="37da03d2f50ceab91ce8002d89f395e8b70d32e3" translate="yes" xml:space="preserve">
          <source>QuoteMeta returns a string that escapes all regular expression metacharacters inside the argument text; the returned string is a regular expression matching the literal text.</source>
          <target state="translated">QuoteMeta 返回一个字符串,该字符串可以转义所有参数文本中的正则表达式元字符;返回的字符串是一个与文字匹配的正则表达式。</target>
        </trans-unit>
        <trans-unit id="e4b2ad9113103116d841b51eb9a5a4bb79d43dd5" translate="yes" xml:space="preserve">
          <source>QuoteRune</source>
          <target state="translated">QuoteRune</target>
        </trans-unit>
        <trans-unit id="642db102936be1179d9fd316324babf33d424684" translate="yes" xml:space="preserve">
          <source>QuoteRune and QuoteRuneToASCII are similar but accept runes and return quoted Go rune literals.</source>
          <target state="translated">QuoteRune 和 QuoteRuneToASCII 类似,但接受符文并返回引用的围棋符文字面。</target>
        </trans-unit>
        <trans-unit id="279cda9da221d3eced1baaee13fb941915b0ad94" translate="yes" xml:space="preserve">
          <source>QuoteRune returns a single-quoted Go character literal representing the rune. The returned string uses Go escape sequences (\t, \n, \xFF, \u0100) for control characters and non-printable characters as defined by IsPrint.</source>
          <target state="translated">QuoteRune返回一个代表符文的单引号Go字符文字。返回的字符串使用围棋转义序列(\t,\n,\xFF,\u0100)作为控制字符和IsPrint定义的不可打印字符。</target>
        </trans-unit>
        <trans-unit id="c3b760977eead2353634f7488bfbfd8e6f53c7d3" translate="yes" xml:space="preserve">
          <source>QuoteRuneToASCII</source>
          <target state="translated">QuoteRuneToASCII</target>
        </trans-unit>
        <trans-unit id="53e2d039ada874ffb648eee9f937362314f5598e" translate="yes" xml:space="preserve">
          <source>QuoteRuneToASCII returns a single-quoted Go character literal representing the rune. The returned string uses Go escape sequences (\t, \n, \xFF, \u0100) for non-ASCII characters and non-printable characters as defined by IsPrint.</source>
          <target state="translated">QuoteRuneToASCII返回一个代表符文的单引号Go字符文字。返回的字符串对非ASCII字符和IsPrint定义的不可打印字符使用围棋转义序列(\t,\n,\xFF,\u0100)。</target>
        </trans-unit>
        <trans-unit id="0b7fc6950d658f88c7fbca21f506d8678210ba4b" translate="yes" xml:space="preserve">
          <source>QuoteRuneToGraphic</source>
          <target state="translated">QuoteRuneToGraphic</target>
        </trans-unit>
        <trans-unit id="d7acc4ec0f4c890982546aed330f635d958aaa08" translate="yes" xml:space="preserve">
          <source>QuoteRuneToGraphic returns a single-quoted Go character literal representing the rune. The returned string uses Go escape sequences (\t, \n, \xFF, \u0100) for non-ASCII characters and non-printable characters as defined by IsGraphic.</source>
          <target state="translated">QuoteRuneToGraphic返回一个代表符文的单引号Go字符文字。返回的字符串使用围棋转义序列(\t,\n,\xFF,\u0100)来表示非ASCII字符和IsGraphic定义的不可打印字符。</target>
        </trans-unit>
        <trans-unit id="1c5941bc9d5a3819ff2354cecea7900bb16d81ce" translate="yes" xml:space="preserve">
          <source>QuoteToASCII</source>
          <target state="translated">QuoteToASCII</target>
        </trans-unit>
        <trans-unit id="1903845d523cb092b2910db9e417c9681642b306" translate="yes" xml:space="preserve">
          <source>QuoteToASCII returns a double-quoted Go string literal representing s. The returned string uses Go escape sequences (\t, \n, \xFF, \u0100) for non-ASCII characters and non-printable characters as defined by IsPrint.</source>
          <target state="translated">返回的字符串对非ASCII字符和IsPrint定义的不可打印字符使用Go转义序列(\t,\n,\xFF,\u0100)。</target>
        </trans-unit>
        <trans-unit id="4621ad4d6c0a75793529926b49a9e0ff472d7a25" translate="yes" xml:space="preserve">
          <source>QuoteToGraphic</source>
          <target state="translated">QuoteToGraphic</target>
        </trans-unit>
        <trans-unit id="29d4d4e582c2a53b8be9f8063c3bfb0f71cbfd71" translate="yes" xml:space="preserve">
          <source>QuoteToGraphic returns a double-quoted Go string literal representing s. The returned string uses Go escape sequences (\t, \n, \xFF, \u0100) for non-ASCII characters and non-printable characters as defined by IsGraphic.</source>
          <target state="translated">QuoteToGraphic返回一个双引号的代表s的Go字符串文字。返回的字符串对非ASCII字符和IsGraphic定义的不可打印字符使用Go转义序列(\t,\n,\xFF,\u0100)。</target>
        </trans-unit>
        <trans-unit id="fd12f86a63d23d37e2246e2c7fa6e414286f5f3b" translate="yes" xml:space="preserve">
          <source>RC4 is cryptographically broken and should not be used for secure applications.</source>
          <target state="translated">RC4在密码学上是有缺陷的,不应该用于安全应用。</target>
        </trans-unit>
        <trans-unit id="bc475e86eb000cdc90e36723f96df5f3d9198891" translate="yes" xml:space="preserve">
          <source>RGBA is an in-memory image whose At method returns color.RGBA values.</source>
          <target state="translated">RGBA是一个内存图像,其At方法返回color.RGBA值。</target>
        </trans-unit>
        <trans-unit id="04d387f558acb0866f18159db1f3ea813711e9ce" translate="yes" xml:space="preserve">
          <source>RGBA represents a traditional 32-bit alpha-premultiplied color, having 8 bits for each of red, green, blue and alpha.</source>
          <target state="translated">RGBA代表传统的32位alpha预乘色,红、绿、蓝和alpha各8位。</target>
        </trans-unit>
        <trans-unit id="46da93f2d89b5f7316108ef78fe128ccbb04c72c" translate="yes" xml:space="preserve">
          <source>RGBA64 is an in-memory image whose At method returns color.RGBA64 values.</source>
          <target state="translated">RGBA64是一个内存图像,其At方法返回color.RGBA64值。</target>
        </trans-unit>
        <trans-unit id="dd5b935255bb5c16c695e848211ad0d21f5142a6" translate="yes" xml:space="preserve">
          <source>RGBA64 represents a 64-bit alpha-premultiplied color, having 16 bits for each of red, green, blue and alpha.</source>
          <target state="translated">RGBA64表示64位alpha预乘色,红、绿、蓝和alpha各为16位。</target>
        </trans-unit>
        <trans-unit id="33f4c44fe26c52f4a8501dd0d6638972bee0c02a" translate="yes" xml:space="preserve">
          <source>RGBToCMYK converts an RGB triple to a CMYK quadruple.</source>
          <target state="translated">RGBToCMYK将RGB三倍转换为CMYK四倍。</target>
        </trans-unit>
        <trans-unit id="b770a15a910f2bcdc5fe9614ef9593fa435bc817" translate="yes" xml:space="preserve">
          <source>RGBToYCbCr converts an RGB triple to a Y'CbCr triple.</source>
          <target state="translated">RGBToYCbCr将一个RGB三原色转换为Y'CbCr三原色。</target>
        </trans-unit>
        <trans-unit id="80bfa68e1e388f84eb032cb18125580dfa1ad40c" translate="yes" xml:space="preserve">
          <source>RLock locks rw for reading.</source>
          <target state="translated">RLock锁住Rw进行读取。</target>
        </trans-unit>
        <trans-unit id="437fa597804ed80cc48e0b7bbfe7afd323e52a8f" translate="yes" xml:space="preserve">
          <source>RLocker returns a Locker interface that implements the Lock and Unlock methods by calling rw.RLock and rw.RUnlock.</source>
          <target state="translated">RLocker通过调用rw.RLock和rw.RUnlock返回一个实现Lock和Unlock方法的Locker接口。</target>
        </trans-unit>
        <trans-unit id="e9e1378ed0c7150ba139600e4e6dab65e5c1015c" translate="yes" xml:space="preserve">
          <source>RSA is a single, fundamental operation that is used in this package to implement either public-key encryption or public-key signatures.</source>
          <target state="translated">RSA是一个单一的、基本的操作,在这个软件包中用来实现公钥加密或公钥签名。</target>
        </trans-unit>
        <trans-unit id="c5491899defb867c4967ebbebdd0bd5970a6aab7" translate="yes" xml:space="preserve">
          <source>RSA is able to encrypt only a very limited amount of data. In order to encrypt reasonable amounts of data a hybrid scheme is commonly used: RSA is used to encrypt a key for a symmetric primitive like AES-GCM. Before encrypting, data is &amp;ldquo;padded&amp;rdquo; by embedding it in a known structure. This is done for a number of reasons, but the most obvious is to ensure that the value is large enough that the exponentiation is larger than the modulus. (Otherwise it could be decrypted with a square-root.) In these designs, when using PKCS#1 v1.5, it's vitally important to avoid disclosing whether the received RSA message was well-formed (that is, whether the result of decrypting is a correctly padded message) because this leaks secret information. DecryptPKCS1v15SessionKey is designed for this situation and copies the decrypted, symmetric key (if well-formed) in constant-time over a buffer that contains a random key. Thus, if the RSA result isn't well-formed, the implementation uses a random key in constant time.</source>
          <target state="translated">RSA只能加密非常有限的数据。为了加密合理数量的数据，通常使用混合方案：RSA用于加密对称原语（例如AES-GCM）的密钥。在加密之前，通过将数据嵌入已知结构来&amp;ldquo;填充&amp;rdquo;数据。这样做有多种原因，但最明显的是确保该值足够大，以使幂运算大于模数。 （否则，可以使用平方根解密。）在这些设计中，当使用PKCS＃1 v1.5时，避免泄漏所接收的RSA消息是否格式正确（即解密的结果是否公开）至关重要。是正确填充的消息），因为这会泄漏机密信息。 DecryptPKCS1v15SessionKey专门用于这种情况，并复制解密后的内容，对称密钥（如果格式正确）在包含随机密钥的缓冲区上持续固定时间。因此，如果RSA结果格式不正确，则实现将在恒定时间内使用随机密钥。</target>
        </trans-unit>
        <trans-unit id="0d73a3a42eb35fcb3f1a5896de985a3713b16b03" translate="yes" xml:space="preserve">
          <source>RUnlock undoes a single RLock call; it does not affect other simultaneous readers. It is a run-time error if rw is not locked for reading on entry to RUnlock.</source>
          <target state="translated">RUnlock会撤销一个RLock调用,它不会影响其他同时读取的程序。如果rw在进入RUnlock时没有被锁定读取,则会出现运行时错误。</target>
        </trans-unit>
        <trans-unit id="b74aed63ef335b4d50b7ff503e63deda9fc37c24" translate="yes" xml:space="preserve">
          <source>Rand sets z to a pseudo-random number in [0, n) and returns z.</source>
          <target state="translated">Rand将z设为[0,n)中的一个伪随机数,并返回z。</target>
        </trans-unit>
        <trans-unit id="cd54bd9d380c9fc6a34adb64461692fb6d87443f" translate="yes" xml:space="preserve">
          <source>Random numbers are generated by a Source. Top-level functions, such as Float64 and Int, use a default shared Source that produces a deterministic sequence of values each time a program is run. Use the Seed function to initialize the default Source if different behavior is required for each run. The default Source is safe for concurrent use by multiple goroutines, but Sources created by NewSource are not.</source>
          <target state="translated">随机数是由Source产生的。顶级函数,如Float64和Int,使用一个默认的共享Source,每次程序运行时都会产生一个确定性的值序列。如果每次运行需要不同的行为,可以使用Seed函数来初始化默认的Source。默认的Source对于多个goroutine的并发使用是安全的,但NewSource创建的Sources则不安全。</target>
        </trans-unit>
        <trans-unit id="8185befebe4b99fc7f08cc0f98bec64eff9d397b" translate="yes" xml:space="preserve">
          <source>Range calls f sequentially for each key and value present in the map. If f returns false, range stops the iteration.</source>
          <target state="translated">Range对地图中的每个键和值依次调用f。如果f返回false,range停止迭代。</target>
        </trans-unit>
        <trans-unit id="e20ffc43a19a831487646a9ec91a15662b93326d" translate="yes" xml:space="preserve">
          <source>Range does not necessarily correspond to any consistent snapshot of the Map's contents: no key will be visited more than once, but if the value for any key is stored or deleted concurrently, Range may reflect any mapping for that key from any point during the Range call.</source>
          <target state="translated">Range不一定对应于Map内容的任何一致的快照:没有一个键会被访问不止一次,但如果任何键的值被同时存储或删除,Range可能会反映该键在Range调用期间任何点的任何映射。</target>
        </trans-unit>
        <trans-unit id="faec537bfdedcf391dd6afc93a601559afbe0c69" translate="yes" xml:space="preserve">
          <source>Range may be O(N) with the number of elements in the map even if f returns false after a constant number of calls.</source>
          <target state="translated">Range可能是O(N)与映射中的元素数,即使f在调用次数不变后返回false。</target>
        </trans-unit>
        <trans-unit id="dc094bef8459881bcfd6a354dcd57e410a9ea71d" translate="yes" xml:space="preserve">
          <source>Range16 represents of a range of 16-bit Unicode code points. The range runs from Lo to Hi inclusive and has the specified stride.</source>
          <target state="translated">Range16表示16位Unicode码点的范围。该范围从Lo到Hi(含),并具有指定的跨度。</target>
        </trans-unit>
        <trans-unit id="8ceb0b8d7c66b188254058f3e47e0188e8c2c9ca" translate="yes" xml:space="preserve">
          <source>Range32 represents of a range of Unicode code points and is used when one or more of the values will not fit in 16 bits. The range runs from Lo to Hi inclusive and has the specified stride. Lo and Hi must always be &amp;gt;= 1&amp;lt;&amp;lt;16.</source>
          <target state="translated">Range32代表一系列Unicode代码点，并且当一个或多个值不适合16位时使用。范围从Lo到Hi（含），并具有指定的跨度。Lo和Hi必须始终为&amp;gt; = 1 &amp;lt;&amp;lt; 16。</target>
        </trans-unit>
        <trans-unit id="3c231e0e20b34ad9b3302a62e18606f8e55490f0" translate="yes" xml:space="preserve">
          <source>RangeNode represents a {{range}} action and its commands.</source>
          <target state="translated">RangeNode表示一个{{range}}动作及其命令。</target>
        </trans-unit>
        <trans-unit id="abf434f30dd2288f852577f0e6ac91164ff1a3d8" translate="yes" xml:space="preserve">
          <source>RangeTable defines a set of Unicode code points by listing the ranges of code points within the set. The ranges are listed in two slices to save space: a slice of 16-bit ranges and a slice of 32-bit ranges. The two slices must be in sorted order and non-overlapping. Also, R32 should contain only values &amp;gt;= 0x10000 (1&amp;lt;&amp;lt;16).</source>
          <target state="translated">RangeTable通过列出一组Unicode代码点的范围来定义它。为了节省空间，在两个切片中列出了范围：切片的16位范围和切片的32位范围。这两个片必须按排序顺序且不重叠。同样，R32应该只包含&amp;gt; = 0x10000（1 &amp;lt;&amp;lt; 16）的值。</target>
        </trans-unit>
        <trans-unit id="c2ee87a3ff54a0745b9a4a39ad5daff79dc82bc0" translate="yes" xml:space="preserve">
          <source>Ranges returns the PC ranges covered by e, a slice of [low,high) pairs. Only some entry types, such as TagCompileUnit or TagSubprogram, have PC ranges; for others, this will return nil with no error.</source>
          <target state="translated">Ranges 返回 e 所覆盖的 PC 范围,即 [low,high]对的片断。只有某些条目类型,如TagCompileUnit或TagSubprogram,才有PC范围;对于其他类型,这将返回无错误的nil。</target>
        </trans-unit>
        <trans-unit id="81de462dc83f2812dc32eb06897fa3d4b38ae7e7" translate="yes" xml:space="preserve">
          <source>Rat returns the rational number corresponding to x; or nil if x is an infinity. The result is Exact if x is not an Inf. If a non-nil *Rat argument z is provided, Rat stores the result in z instead of allocating a new Rat.</source>
          <target state="translated">Rat返回x对应的有理数;如果x是无穷大,则返回nil。如果x不是无穷大,则返回结果为Exact。如果提供了一个非零的*Rat参数z,Rat将把结果存储在z中,而不是分配一个新的Rat。</target>
        </trans-unit>
        <trans-unit id="50ea5863423e0f2515585dcf8c4cb2e31c788a51" translate="yes" xml:space="preserve">
          <source>Rat.Scan</source>
          <target state="translated">Rat.Scan</target>
        </trans-unit>
        <trans-unit id="c5f08baa94ad88996a91c67be38be8fe61b40881" translate="yes" xml:space="preserve">
          <source>Rat.SetString</source>
          <target state="translated">Rat.SetString</target>
        </trans-unit>
        <trans-unit id="ef746adb638d3b60d53628e5d2f1455b1d2e8157" translate="yes" xml:space="preserve">
          <source>RatString returns a string representation of x in the form &quot;a/b&quot; if b != 1, and in the form &quot;a&quot; if b == 1.</source>
          <target state="translated">RatString返回x的字符串表示,如果b !=1,则以 &quot;a/b &quot;的形式表示,如果b ==1,则以 &quot;a &quot;的形式表示。</target>
        </trans-unit>
        <trans-unit id="641d010f14e2f18c1619afc2268deaff20c97455" translate="yes" xml:space="preserve">
          <source>Raw executes f exposing the underlying driver connection for the duration of f. The driverConn must not be used outside of f.</source>
          <target state="translated">Raw执行f,在f的持续时间内暴露底层的驱动连接,driverConn不能在f之外使用。</target>
        </trans-unit>
        <trans-unit id="26c83b72700cdd4952e72476a8d6589b2a87a210" translate="yes" xml:space="preserve">
          <source>RawBytes is a byte slice that holds a reference to memory owned by the database itself. After a Scan into a RawBytes, the slice is only valid until the next call to Next, Scan, or Close.</source>
          <target state="translated">RawBytes是一个字节分片,它保存着对数据库本身所拥有的内存的引用。在扫描到RawBytes后,该分片只在下一次调用Next、Scan或Close之前有效。</target>
        </trans-unit>
        <trans-unit id="3e2984f789eabe0509843f2607db31c184bddf19" translate="yes" xml:space="preserve">
          <source>RawContent is used to signal that the undecoded, DER data needs to be preserved for a struct. To use it, the first field of the struct must have this type. It's an error for any of the other fields to have this type.</source>
          <target state="translated">RawContent用于发出信号,表示需要为一个结构保留未解码的DER数据。要使用它,结构的第一个字段必须具有这种类型。任何其他字段具有这种类型都是错误的。</target>
        </trans-unit>
        <trans-unit id="40ee0825120347a6625b948e8e5d6cf21e430f3f" translate="yes" xml:space="preserve">
          <source>RawMessage (Marshal)</source>
          <target state="translated">RawMessage (Marshal)</target>
        </trans-unit>
        <trans-unit id="d988676cc711a8df55ed7c79d1c3ecdfedc6d2cd" translate="yes" xml:space="preserve">
          <source>RawMessage (Unmarshal)</source>
          <target state="translated">RawMessage (Unmarshal)</target>
        </trans-unit>
        <trans-unit id="1b6da1274d970ef16e862ce3a549bfc22e374a82" translate="yes" xml:space="preserve">
          <source>RawMessage is a raw encoded JSON value. It implements Marshaler and Unmarshaler and can be used to delay JSON decoding or precompute a JSON encoding.</source>
          <target state="translated">RawMessage是一个原始编码的JSON值。它实现了Marshaler和Unmarshaler,可以用来延迟JSON解码或预计算JSON编码。</target>
        </trans-unit>
        <trans-unit id="b92ccd29d9bf661a3766af996d8af025383bbfe8" translate="yes" xml:space="preserve">
          <source>RawStdEncoding is the standard raw, unpadded base64 encoding, as defined in RFC 4648 section 3.2. This is the same as StdEncoding but omits padding characters.</source>
          <target state="translated">RawStdEncoding是标准的原始、无填充的base64编码,定义在RFC 4648第3.2节。这与StdEncoding相同,但省略了填充字符。</target>
        </trans-unit>
        <trans-unit id="6e753058a412394f90ee90228dcf31c4e858e385" translate="yes" xml:space="preserve">
          <source>RawToken is like Token but does not verify that start and end elements match and does not translate name space prefixes to their corresponding URLs.</source>
          <target state="translated">RawToken和Token一样,但不验证开始和结束元素是否匹配,也不将名称空间前缀翻译成相应的URL。</target>
        </trans-unit>
        <trans-unit id="166fbd6be28a6fdfe4f94b440b329268727101a8" translate="yes" xml:space="preserve">
          <source>RawURLEncoding is the unpadded alternate base64 encoding defined in RFC 4648. It is typically used in URLs and file names. This is the same as URLEncoding but omits padding characters.</source>
          <target state="translated">RawURLEncoding是RFC 4648中定义的无填充的备用base64编码。它通常用于URL和文件名中。这与URLEncoding相同,但省略了填充字符。</target>
        </trans-unit>
        <trans-unit id="b05c645148a5f30bf1ff0257be7322f1e5b30562" translate="yes" xml:space="preserve">
          <source>Rcpt issues a RCPT command to the server using the provided email address. A call to Rcpt must be preceded by a call to Mail and may be followed by a Data call or another Rcpt call.</source>
          <target state="translated">Rcpt 使用提供的电子邮件地址向服务器发出 RCPT 命令。对Rcpt的调用必须在调用Mail之前进行,并且可以在调用Data或其他Rcpt调用之后进行。</target>
        </trans-unit>
        <trans-unit id="852b438f91ad9eb2cdd84419a675a216d543c687" translate="yes" xml:space="preserve">
          <source>Read</source>
          <target state="translated">Read</target>
        </trans-unit>
        <trans-unit id="1fab142ac33b47994d5f7bd4bebd0d391e21aa89" translate="yes" xml:space="preserve">
          <source>Read (Multi)</source>
          <target state="translated">读取(多)</target>
        </trans-unit>
        <trans-unit id="7d9a4bfe253412dcb5fa31eea7ed6b71a69c4521" translate="yes" xml:space="preserve">
          <source>Read calls decode to deserialize a file set into s; s must not be nil.</source>
          <target state="translated">读取调用解码,将一个文件集反序列化到s中;s不能为零。</target>
        </trans-unit>
        <trans-unit id="cf8ca129127382252f21178b2e38598c4c8bdae5" translate="yes" xml:space="preserve">
          <source>Read can be made to time out and return a net.Error with Timeout() == true after a fixed time limit; see SetDeadline and SetReadDeadline.</source>
          <target state="translated">读取可以在固定的时间限制后,用Timeout()==true使其超时并返回一个net.Error;参见SetDeadline和SetReadDeadline。</target>
        </trans-unit>
        <trans-unit id="f1410843edc88c2b9c942b455b313f9ec9a6aa42" translate="yes" xml:space="preserve">
          <source>Read generates len(p) random bytes and writes them into p. It always returns len(p) and a nil error. Read should not be called concurrently with any other Rand method.</source>
          <target state="translated">Read 生成 len(p)随机字节并将它们写入 p 中。它总是返回 len(p)和一个 nil 错误。Read 不应与其他任何 Rand 方法同时调用。</target>
        </trans-unit>
        <trans-unit id="1059017001f226c432850be91279c7915ab436ce" translate="yes" xml:space="preserve">
          <source>Read generates len(p) random bytes from the default Source and writes them into p. It always returns len(p) and a nil error. Read, unlike the Rand.Read method, is safe for concurrent use.</source>
          <target state="translated">Read 从默认的 Source 生成 len(p)随机字节,并将它们写入 p 中,它总是返回 len(p)和一个 nil 错误。Read与Rand.Read方法不同,它的并发使用是安全的。</target>
        </trans-unit>
        <trans-unit id="a6208c052d923f9826a6caa2665b94a206f4ce81" translate="yes" xml:space="preserve">
          <source>Read implements io.Reader, reading uncompressed bytes from its underlying Reader.</source>
          <target state="translated">Read实现了io.Reader,从其底层Reader中读取未压缩的字节。</target>
        </trans-unit>
        <trans-unit id="702bfd00bb1c14225a9197a21d99befbae954266" translate="yes" xml:space="preserve">
          <source>Read implements the Conn Read method.</source>
          <target state="translated">Read实现Conn Read方法。</target>
        </trans-unit>
        <trans-unit id="516c851188aa6fc002db294d7651c5ec750120d8" translate="yes" xml:space="preserve">
          <source>Read implements the io.Reader interface.</source>
          <target state="translated">Read实现了io.Reader接口。</target>
        </trans-unit>
        <trans-unit id="13632ff4ca176eb49e2ded2120c8bd44145f6430" translate="yes" xml:space="preserve">
          <source>Read implements the standard Read interface: it reads data from the pipe, blocking until a writer arrives or the write end is closed. If the write end is closed with an error, that error is returned as err; otherwise err is EOF.</source>
          <target state="translated">Read实现了标准的Read接口:它从管道中读取数据,阻塞直到写入端到达或写入端关闭。如果写端因错误而关闭,则该错误以err的形式返回;否则err为EOF。</target>
        </trans-unit>
        <trans-unit id="852b19fc6db1a887a68fe0a33719da8f3df7f6a7" translate="yes" xml:space="preserve">
          <source>Read is a helper function that calls Reader.Read using io.ReadFull. On return, n == len(b) if and only if err == nil.</source>
          <target state="translated">Read是一个帮助函数,它使用io.ReadFull调用Reader.Read。返回时,如果且仅当err ==nil时,n ==len(b)。</target>
        </trans-unit>
        <trans-unit id="6027400201b1aeffebb229f97e47437dd5103716" translate="yes" xml:space="preserve">
          <source>Read reads and decodes quoted-printable data from the underlying reader.</source>
          <target state="translated">Read从底层阅读器中读取和解码可引用打印的数据。</target>
        </trans-unit>
        <trans-unit id="099ba490bf08acc0d4ea27ba7af0e8caf12990cd" translate="yes" xml:space="preserve">
          <source>Read reads data into p. It returns the number of bytes read into p. The bytes are taken from at most one Read on the underlying Reader, hence n may be less than len(p). To read exactly len(p) bytes, use io.ReadFull(b, p). At EOF, the count will be zero and err will be io.EOF.</source>
          <target state="translated">Read 将数据读到 p 中,返回读到 p 中的字节数。字节数最多来自于底层阅读器上的一次读取,因此 n 可能小于 len(p)。要精确读取len(p)字节,使用io.ReadFull(b,p)。在EOF时,计数将为零,err将为io.EOF.ReadFull(b,p)。</target>
        </trans-unit>
        <trans-unit id="16ce634004d504a55e55d47a3800c80b22768a4e" translate="yes" xml:space="preserve">
          <source>Read reads from the current file in the tar archive. It returns (0, io.EOF) when it reaches the end of that file, until Next is called to advance to the next file.</source>
          <target state="translated">Read 从 tar 归档文件中读取当前文件。当读到该文件的结尾时,它返回 (0,io.EOF),直到调用 Next 来前进到下一个文件。</target>
        </trans-unit>
        <trans-unit id="8672c69a1ddaf5ba6848a36cbea552f79e4309ae" translate="yes" xml:space="preserve">
          <source>Read reads one record (a slice of fields) from r. If the record has an unexpected number of fields, Read returns the record along with the error ErrFieldCount. Except for that case, Read always returns either a non-nil record or a non-nil error, but not both. If there is no data left to be read, Read returns nil, io.EOF. If ReuseRecord is true, the returned slice may be shared between multiple calls to Read.</source>
          <target state="translated">Read从r中读取一条记录(字段的片断)。如果记录的字段数出乎意料,Read会将记录和错误ErrFieldCount一起返回。除了这种情况,Read总是返回一个非零记录或一个非零错误,但不会同时返回。如果没有剩余数据可读,Read返回nil,io.EOF。如果ReuseRecord为真,返回的分片可以在多个Read调用之间共享。</target>
        </trans-unit>
        <trans-unit id="2a7ebad97783211e0c50dee195a81d2fcc00a21a" translate="yes" xml:space="preserve">
          <source>Read reads structured binary data from r into data. Data must be a pointer to a fixed-size value or a slice of fixed-size values. Bytes read from r are decoded using the specified byte order and written to successive fields of the data. When decoding boolean values, a zero byte is decoded as false, and any other non-zero byte is decoded as true. When reading into structs, the field data for fields with blank (_) field names is skipped; i.e., blank field names may be used for padding. When reading into a struct, all non-blank fields must be exported or Read may panic.</source>
          <target state="translated">Read从r中读取结构化的二进制数据到数据中。数据必须是一个固定大小值的指针或固定大小值的片断。从r读取的字节使用指定的字节顺序进行解码,并写入数据的连续字段。当对布尔值进行解码时,零字节被解码为false,任何其他非零字节被解码为true。读入结构体时,跳过带有空白(_)字段名的字段数据;也就是说,空白字段名可以用于填充。当读入结构体时,必须导出所有非空白字段,否则Read可能会恐慌。</target>
        </trans-unit>
        <trans-unit id="13d3208ebb1aa7a1ba1e0de8a255452e3b6f8318" translate="yes" xml:space="preserve">
          <source>Read reads the body of a part, after its headers and before the next part (if any) begins.</source>
          <target state="translated">读取一个部分的主体,在其标题之后,下一个部分(如果有的话)开始之前。</target>
        </trans-unit>
        <trans-unit id="bbca8871624a3fc59330b4b25dd8f3ecce95f77a" translate="yes" xml:space="preserve">
          <source>Read reads the index from r into x; x must not be nil.</source>
          <target state="translated">Read将r的索引读入x,x不能为零。</target>
        </trans-unit>
        <trans-unit id="f50cd5c21ed9fed72a69eacf7363def3849c51d8" translate="yes" xml:space="preserve">
          <source>Read reads the next len(p) bytes from the buffer or until the buffer is drained. The return value n is the number of bytes read. If the buffer has no data to return, err is io.EOF (unless len(p) is zero); otherwise it is nil.</source>
          <target state="translated">Read从缓冲区中读取下一个len(p)字节,或者直到缓冲区耗尽。返回值n是读取的字节数。如果缓冲区没有数据要返回,err为io.EOF(除非len(p)为零);否则为nil。</target>
        </trans-unit>
        <trans-unit id="dd7574617c7b02af539a5115f14c74adf24afa51" translate="yes" xml:space="preserve">
          <source>Read reads the next response from the wire. A valid response might be returned together with an ErrPersistEOF, which means that the remote requested that this be the last request serviced. Read can be called concurrently with Write, but not with another Read.</source>
          <target state="translated">Read从线上读取下一个响应。一个有效的响应可能会和一个ErrPersistEOF一起返回,这意味着远程要求这是最后一个被服务的请求。Read可以与Write同时调用,但不能与另一个Read同时调用。</target>
        </trans-unit>
        <trans-unit id="e877852fb33acd1c13bf6498df79e2e968ae525c" translate="yes" xml:space="preserve">
          <source>Read reads up to len(b) bytes from the File. It returns the number of bytes read and any error encountered. At end of file, Read returns 0, io.EOF.</source>
          <target state="translated">从文件中读取最多 len(b)字节。它返回读取的字节数和遇到的任何错误。在文件结束时,Read返回0,io.EOF。</target>
        </trans-unit>
        <trans-unit id="5d839b22857eca34207c84ba0a055c6ee9c74ec5" translate="yes" xml:space="preserve">
          <source>Read reads up to len(p) bytes into p. It returns the number of bytes read (0 &amp;lt;= n &amp;lt;= len(p)) and any error encountered. Even if Read returns n &amp;lt; len(p), it may use all of p as scratch space during the call. If some data is available but not len(p) bytes, Read conventionally returns what is available instead of waiting for more.</source>
          <target state="translated">读取最多将len（p）个字节读入p。它返回读取的字节数（0 &amp;lt;= n &amp;lt;= len（p））和遇到的任何错误。即使Read返回n &amp;lt;len（p），也可能在调用期间将所有p用作暂存空间。如果某些数据可用，但不是len（p）个字节，按常规，Read将返回可用数据，而不是等待更多数据。</target>
        </trans-unit>
        <trans-unit id="232135a13eb14d8c77efc7e8763b8a54f14d853d" translate="yes" xml:space="preserve">
          <source>Read returns the next request on the wire. An ErrPersistEOF is returned if it is gracefully determined that there are no more requests (e.g. after the first request on an HTTP/1.0 connection, or after a Connection:close on a HTTP/1.1 connection).</source>
          <target state="translated">Read返回线上的下一个请求,如果它被优雅地确定没有更多的请求(例如在HTTP/1.0连接上的第一个请求之后,或者在HTTP/1.0连接上的Connection:close之后,返回一个ErrPersistEOF。如果优雅地确定没有更多的请求,则返回ErrPersistEOF(例如,在HTTP/1.0连接的第一个请求之后,或者在HTTP/1.1连接的Connection:close之后)。</target>
        </trans-unit>
        <trans-unit id="8577ab4df6483a129452d0551a62e50aac1ada00" translate="yes" xml:space="preserve">
          <source>ReadAll</source>
          <target state="translated">ReadAll</target>
        </trans-unit>
        <trans-unit id="c220dc4ba473358c1d6061cf0c9c7708ee93e92a" translate="yes" xml:space="preserve">
          <source>ReadAll reads all the remaining records from r. Each record is a slice of fields. A successful call returns err == nil, not err == io.EOF. Because ReadAll is defined to read until EOF, it does not treat end of file as an error to be reported.</source>
          <target state="translated">ReadAll从r中读取所有剩余的记录,每条记录是一个字段的片断,调用成功后返回err ==nil,而不是err ==io.EOF。调用成功会返回err ==nil,而不是err ==io.EOF。因为ReadAll被定义为读取直到EOF,所以它不会将文件结束作为一个错误来报告。</target>
        </trans-unit>
        <trans-unit id="a2e746d4cfb2608d3ae0cefc64ac787887ba2c28" translate="yes" xml:space="preserve">
          <source>ReadAll reads from r until an error or EOF and returns the data it read. A successful call returns err == nil, not err == EOF. Because ReadAll is defined to read from src until EOF, it does not treat an EOF from Read as an error to be reported.</source>
          <target state="translated">ReadAll从r读取数据,直到出现错误或EOF,并返回读取的数据。成功的调用返回err ==nil,而不是err ==EOF。因为ReadAll被定义为从src读取数据直到EOF,所以它不会将Read的EOF视为一个需要报告的错误。</target>
        </trans-unit>
        <trans-unit id="f4cbf689398d7442e9b49d9483e3d4cc75c10fd1" translate="yes" xml:space="preserve">
          <source>ReadAt implements the io.ReaderAt interface.</source>
          <target state="translated">ReadAt实现了io.ReaderAt接口。</target>
        </trans-unit>
        <trans-unit id="64ae50d9b868e0114af3da28a0f440e42207678f" translate="yes" xml:space="preserve">
          <source>ReadAt reads len(b) bytes from the File starting at byte offset off. It returns the number of bytes read and the error, if any. ReadAt always returns a non-nil error when n &amp;lt; len(b). At end of file, that error is io.EOF.</source>
          <target state="translated">ReadAt从字节偏移量开始从文件读取len（b）个字节。它返回读取的字节数和错误（如果有）。当n &amp;lt;len（b）时，ReadAt始终返回非nil错误。在文件末尾，该错误是io.EOF。</target>
        </trans-unit>
        <trans-unit id="c0bb2352984c400f258aa80aba0c3141b53cce96" translate="yes" xml:space="preserve">
          <source>ReadAt reads len(p) bytes into p starting at offset off in the underlying input source. It returns the number of bytes read (0 &amp;lt;= n &amp;lt;= len(p)) and any error encountered.</source>
          <target state="translated">ReadAt从基础输入源中的offset off处读取len（p）个字节到p中。它返回读取的字节数（0 &amp;lt;= n &amp;lt;= len（p））和遇到的任何错误。</target>
        </trans-unit>
        <trans-unit id="e76e529805447d2ff346a5397f1147a3e02108f4" translate="yes" xml:space="preserve">
          <source>ReadAtLeast</source>
          <target state="translated">ReadAtLeast</target>
        </trans-unit>
        <trans-unit id="dde64f711702d58fa68344cc075ded7169e93092" translate="yes" xml:space="preserve">
          <source>ReadAtLeast reads from r into buf until it has read at least min bytes. It returns the number of bytes copied and an error if fewer bytes were read. The error is EOF only if no bytes were read. If an EOF happens after reading fewer than min bytes, ReadAtLeast returns ErrUnexpectedEOF. If min is greater than the length of buf, ReadAtLeast returns ErrShortBuffer. On return, n &amp;gt;= min if and only if err == nil. If r returns an error having read at least min bytes, the error is dropped.</source>
          <target state="translated">ReadAtLeast从r读取到buf，直到它至少读取了最小字节。它返回复制的字节数，如果读取的字节数少则返回错误。仅当未读取任何字节时，错误才是EOF。如果在读取少于最小字节后发生EOF，则ReadAtLeast返回ErrUnexpectedEOF。如果min大于buf的长度，则ReadAtLeast返回ErrShortBuffer。返回时，当且仅当err == nil时，n&amp;gt; = min。如果r返回至少读取了最小字节的错误，则丢弃该错误。</target>
        </trans-unit>
        <trans-unit id="5eb984a81bf137b794c952d3bb6893f123d7859e" translate="yes" xml:space="preserve">
          <source>ReadBuildInfo returns the build information embedded in the running binary. The information is available only in binaries built with module support.</source>
          <target state="translated">ReadBuildInfo 返回嵌入在运行中的二进制文件中的构建信息。这些信息只有在模块支持下构建的二进制文件中才有。</target>
        </trans-unit>
        <trans-unit id="b60f1ee86705e93ab48e53804a8b6eaae8d1a5a6" translate="yes" xml:space="preserve">
          <source>ReadByte implements the io.ByteReader interface.</source>
          <target state="translated">ReadByte实现了io.ByteReader接口。</target>
        </trans-unit>
        <trans-unit id="88fc89f806641e6821f93c159732d09d121182a0" translate="yes" xml:space="preserve">
          <source>ReadByte reads and returns a single byte. If no byte is available, returns an error.</source>
          <target state="translated">ReadByte读取并返回一个字节。如果没有可用的字节,返回一个错误。</target>
        </trans-unit>
        <trans-unit id="8ccc7f3f4551a8da89db7d7f4659a2bcc7f6f5b1" translate="yes" xml:space="preserve">
          <source>ReadByte reads and returns the next byte from the buffer. If no byte is available, it returns error io.EOF.</source>
          <target state="translated">ReadByte从缓冲区中读取并返回下一个字节。如果没有可用的字节,它将返回错误io.EOF。</target>
        </trans-unit>
        <trans-unit id="159679671477045d937418ced34fc2e8ac5df5f4" translate="yes" xml:space="preserve">
          <source>ReadByte reads and returns the next byte from the input or any error encountered. If ReadByte returns an error, no input byte was consumed, and the returned byte value is undefined.</source>
          <target state="translated">ReadByte读取并返回输入的下一个字节或遇到的任何错误。如果ReadByte返回一个错误,则没有消耗任何输入字节,并且返回的字节值是未定义的。</target>
        </trans-unit>
        <trans-unit id="3d347b2a2e7f91e4c72a8f8310b1aba11bc78e6c" translate="yes" xml:space="preserve">
          <source>ReadBytes reads until the first occurrence of delim in the input, returning a slice containing the data up to and including the delimiter. If ReadBytes encounters an error before finding a delimiter, it returns the data read before the error and the error itself (often io.EOF). ReadBytes returns err != nil if and only if the returned data does not end in delim.</source>
          <target state="translated">ReadBytes 读取直到输入中第一次出现 delim,返回一个包含数据的片断,直到并包括定界符。如果ReadBytes在找到定界符之前遇到了错误,它将返回在错误之前读取的数据和错误本身(通常是io.EOF)。如果且仅当返回的数据不是以 delim 结尾时,ReadBytes 会返回 err !=nil。</target>
        </trans-unit>
        <trans-unit id="aba4d297566c98e6e0d191f056016ef94b731d93" translate="yes" xml:space="preserve">
          <source>ReadBytes reads until the first occurrence of delim in the input, returning a slice containing the data up to and including the delimiter. If ReadBytes encounters an error before finding a delimiter, it returns the data read before the error and the error itself (often io.EOF). ReadBytes returns err != nil if and only if the returned data does not end in delim. For simple uses, a Scanner may be more convenient.</source>
          <target state="translated">ReadBytes 读取直到输入中第一次出现 delim,返回一个包含数据的片断,直到并包括定界符。如果ReadBytes在找到定界符之前遇到了错误,它将返回在错误之前读取的数据和错误本身(通常是io.EOF)。如果且仅当返回的数据不是以 delim 结尾时,ReadBytes 会返回 err !=nil。对于简单的使用,一个Scanner可能更方便。</target>
        </trans-unit>
        <trans-unit id="2f66b132ca8c3970b58c8bfa0ea1a17d65ac03b4" translate="yes" xml:space="preserve">
          <source>ReadCloser is the interface that groups the basic Read and Close methods.</source>
          <target state="translated">ReadCloser 是将基本的读取和关闭方法分组的接口。</target>
        </trans-unit>
        <trans-unit id="db676df84bb4b6b56dfdcd9f6b6ecaede84207b6" translate="yes" xml:space="preserve">
          <source>ReadCodeLine reads a response code line of the form</source>
          <target state="translated">ReadCodeLine读取响应代码行,其形式为</target>
        </trans-unit>
        <trans-unit id="8ff6713d1fd28b36b70ff99ddd8c0b4506ace228" translate="yes" xml:space="preserve">
          <source>ReadContinuedLine reads a possibly continued line from r, eliding the final trailing ASCII white space. Lines after the first are considered continuations if they begin with a space or tab character. In the returned data, continuation lines are separated from the previous line only by a single space: the newline and leading white space are removed.</source>
          <target state="translated">ReadContinuedLine从r中读取可能的续行,省略最后的ASCII空格。如果第一行之后的行以空格或制表符开头,则被认为是延续行。在返回的数据中,延续行与前一行之间只用一个空格隔开:新行和前导空格被删除。</target>
        </trans-unit>
        <trans-unit id="1e5b6ed6dd4e790ba932357704f154ece64c0736" translate="yes" xml:space="preserve">
          <source>ReadContinuedLineBytes is like ReadContinuedLine but returns a []byte instead of a string.</source>
          <target state="translated">ReadContinuedLineBytes与ReadContinuedLine类似,但返回的是[]字节而不是字符串。</target>
        </trans-unit>
        <trans-unit id="5967a3c48bcceae8eab866aea588318eebdf12d2" translate="yes" xml:space="preserve">
          <source>ReadDir</source>
          <target state="translated">ReadDir</target>
        </trans-unit>
        <trans-unit id="72f7f069b44009fbb8ef194258dfcf70cde80055" translate="yes" xml:space="preserve">
          <source>ReadDir reads the directory named by dirname and returns a list of directory entries sorted by filename.</source>
          <target state="translated">ReadDir读取以dirname命名的目录,并返回一个按文件名排序的目录条目列表。</target>
        </trans-unit>
        <trans-unit id="e66536e5f97de59d6908b95e869d13fc9d1ef4b6" translate="yes" xml:space="preserve">
          <source>ReadDotBytes reads a dot-encoding and returns the decoded data.</source>
          <target state="translated">ReadDotBytes读取一个点阵编码并返回解码数据。</target>
        </trans-unit>
        <trans-unit id="9fa4950dafc4de63dd721dcb4ac0ca1c8418dcbe" translate="yes" xml:space="preserve">
          <source>ReadDotLines reads a dot-encoding and returns a slice containing the decoded lines, with the final \r\n or \n elided from each.</source>
          <target state="translated">ReadDotLines读取一个点阵编码,并返回一个包含解码行的片断,每个片断都省略了最后的/r/n或/n。</target>
        </trans-unit>
        <trans-unit id="d7fd01a502310e8357802950d90a33ad1c88b094" translate="yes" xml:space="preserve">
          <source>ReadFile</source>
          <target state="translated">ReadFile</target>
        </trans-unit>
        <trans-unit id="e3227226a36d1c67d762cccdcef04ee8eaa0dc15" translate="yes" xml:space="preserve">
          <source>ReadFile reads the file named by filename and returns the contents. A successful call returns err == nil, not err == EOF. Because ReadFile reads the whole file, it does not treat an EOF from Read as an error to be reported.</source>
          <target state="translated">ReadFile读取以filename命名的文件并返回其内容,调用成功后返回err ==nil,而不是err ==EOF。成功的调用将返回err ==nil,而不是err ==EOF。因为ReadFile读取的是整个文件,所以它不会将Read中的EOF作为一个错误来报告。</target>
        </trans-unit>
        <trans-unit id="af2c9d5288821671fae0d9ea11877f8aa4dfd64b" translate="yes" xml:space="preserve">
          <source>ReadForm parses an entire multipart message whose parts have a Content-Disposition of &quot;form-data&quot;. It stores up to maxMemory bytes + 10MB (reserved for non-file parts) in memory. File parts which can't be stored in memory will be stored on disk in temporary files. It returns ErrMessageTooLarge if all non-file parts can't be stored in memory.</source>
          <target state="translated">ReadForm解析整个多部分消息,其部分的Content-Disposition为 &quot;form-data&quot;。它在内存中最多存储maxMemory字节+10MB(为非文件部分保留)。不能存储在内存中的文件部分将被存储在磁盘的临时文件中。如果所有非文件部分不能存储在内存中,它将返回ErrMessageTooLarge。</target>
        </trans-unit>
        <trans-unit id="0e93b4927342ab7184e8df9a62d919ab56aa652d" translate="yes" xml:space="preserve">
          <source>ReadFrom implements io.ReaderFrom. If the underlying writer supports the ReadFrom method, and b has no buffered data yet, this calls the underlying ReadFrom without buffering.</source>
          <target state="translated">ReadFrom实现了io.ReaderFrom。如果底层写作者支持ReadFrom方法,并且b还没有缓冲数据,这将调用底层的ReadFrom而不进行缓冲。</target>
        </trans-unit>
        <trans-unit id="deeb7efc315fb646ef56c6fc1f93867b106373b0" translate="yes" xml:space="preserve">
          <source>ReadFrom implements the PacketConn ReadFrom method.</source>
          <target state="translated">ReadFrom实现PacketConn ReadFrom方法。</target>
        </trans-unit>
        <trans-unit id="f608142e8cc80b99bfcbe865eecfbb0322dd6e96" translate="yes" xml:space="preserve">
          <source>ReadFrom implements the io.ReaderFrom ReadFrom method.</source>
          <target state="translated">ReadFrom 实现了 io.ReaderFrom ReadFrom 方法。</target>
        </trans-unit>
        <trans-unit id="00b3806bd8fc8bcfbcad0f6f7f7286cb5b8785f4" translate="yes" xml:space="preserve">
          <source>ReadFrom reads data from r until EOF and appends it to the buffer, growing the buffer as needed. The return value n is the number of bytes read. Any error except io.EOF encountered during the read is also returned. If the buffer becomes too large, ReadFrom will panic with ErrTooLarge.</source>
          <target state="translated">ReadFrom从r中读取数据直到EOF,并将其追加到缓冲区,根据需要增长缓冲区。返回值n是读取的字节数。除了io.EOF之外,在读取过程中遇到的任何错误也会被返回。如果缓冲区变得过大,ReadFrom会用ErrTooLarge恐慌。</target>
        </trans-unit>
        <trans-unit id="454fdea2d34a8c45cb668b5c543dbc3f7058787c" translate="yes" xml:space="preserve">
          <source>ReadFrom reads data from r until EOF or error. The return value n is the number of bytes read. Any error except io.EOF encountered during the read is also returned.</source>
          <target state="translated">ReadFrom从r中读取数据,直到EOF或出错。返回值n是读取的字节数。除了io.EOF之外,读取过程中遇到的任何错误也会被返回。</target>
        </trans-unit>
        <trans-unit id="ea32f98cbdf74be7e58789bf5c2555022985c09b" translate="yes" xml:space="preserve">
          <source>ReadFromIP acts like ReadFrom but returns an IPAddr.</source>
          <target state="translated">ReadFromIP的行为与ReadFrom类似,但返回的是IPAddr。</target>
        </trans-unit>
        <trans-unit id="95ff932341b82ae81f7960462c1442dddf49af3c" translate="yes" xml:space="preserve">
          <source>ReadFromUDP acts like ReadFrom but returns a UDPAddr.</source>
          <target state="translated">ReadFromUDP的行为与ReadFrom类似,但返回一个UDPAddr。</target>
        </trans-unit>
        <trans-unit id="715d754a562178b348b7a0a9528cfbf66635230e" translate="yes" xml:space="preserve">
          <source>ReadFromUnix acts like ReadFrom but returns a UnixAddr.</source>
          <target state="translated">ReadFromUnix的行为与ReadFrom类似,但返回一个UnixAddr。</target>
        </trans-unit>
        <trans-unit id="6b877746bfc4fdb60829d292eb383e9e72074e71" translate="yes" xml:space="preserve">
          <source>ReadFull</source>
          <target state="translated">ReadFull</target>
        </trans-unit>
        <trans-unit id="f41363ee55bdca4d655d8c43955b9b66f37cac52" translate="yes" xml:space="preserve">
          <source>ReadFull reads exactly len(buf) bytes from r into buf. It returns the number of bytes copied and an error if fewer bytes were read. The error is EOF only if no bytes were read. If an EOF happens after reading some but not all the bytes, ReadFull returns ErrUnexpectedEOF. On return, n == len(buf) if and only if err == nil. If r returns an error having read at least len(buf) bytes, the error is dropped.</source>
          <target state="translated">ReadFull 将 r 的 len(buf)字节准确地读入 buf。它返回复制的字节数,如果读取的字节数较少,则返回错误。只有当没有读到字节时才会出现错误,即EOF。如果在读取部分但不是全部字节后发生EOF,ReadFull返回ErrUnexpectedEOF。返回时,如果且仅当err ==nil时,n ==len(buf)。如果r在读取至少len(buf)字节后返回错误,则错误被丢弃。</target>
        </trans-unit>
        <trans-unit id="4528be7d31ac119b15adb0d44e8e10acc6a61277" translate="yes" xml:space="preserve">
          <source>ReadGCStats reads statistics about garbage collection into stats. The number of entries in the pause history is system-dependent; stats.Pause slice will be reused if large enough, reallocated otherwise. ReadGCStats may use the full capacity of the stats.Pause slice. If stats.PauseQuantiles is non-empty, ReadGCStats fills it with quantiles summarizing the distribution of pause time. For example, if len(stats.PauseQuantiles) is 5, it will be filled with the minimum, 25%, 50%, 75%, and maximum pause times.</source>
          <target state="translated">ReadGCStats将有关垃圾收集的统计数据读取到stats.Pause片中。暂停历史记录的条数与系统有关,如果stats.Pause slice足够大,将被重用,否则将被重新分配。ReadGCStats可能会使用 stats.Pause slice 的全部容量。如果 stats.PauseQuantiles是非空的,ReadGCStats 就会用总结暂停时间分布的量子来填充它。例如,如果len(stats.PauseQuantiles)是5,它将被填充最小、25%、50%、75%和最大的暂停时间。</target>
        </trans-unit>
        <trans-unit id="a6882fab97e53a8d3c4b1deb078269fff567ed19" translate="yes" xml:space="preserve">
          <source>ReadLine is a low-level line-reading primitive. Most callers should use ReadBytes('\n') or ReadString('\n') instead or use a Scanner.</source>
          <target state="translated">ReadLine是一个低级的读行基元,大多数调用者应该使用ReadBytes('\n')或ReadString(\n)来代替,或者使用Scanner。大多数调用者应该使用ReadBytes('\n')或ReadString('\n')来代替或使用Scanner。</target>
        </trans-unit>
        <trans-unit id="70e3e4d68a5bd26786fe6816067d028f52581c71" translate="yes" xml:space="preserve">
          <source>ReadLine reads a single line from r, eliding the final \n or \r\n from the returned string.</source>
          <target state="translated">ReadLine从r中读取一行,从返回的字符串中省略最后的\n或\r\n。</target>
        </trans-unit>
        <trans-unit id="d5bdeff155b2aec65cb49ea2eabeba1181d7c31c" translate="yes" xml:space="preserve">
          <source>ReadLine tries to return a single line, not including the end-of-line bytes. If the line was too long for the buffer then isPrefix is set and the beginning of the line is returned. The rest of the line will be returned from future calls. isPrefix will be false when returning the last fragment of the line. The returned buffer is only valid until the next call to ReadLine. ReadLine either returns a non-nil line or it returns an error, never both.</source>
          <target state="translated">ReadLine试图返回一行,不包括行末字节。如果该行对缓冲区来说太长,那么isPrefix将被设置,并返回该行的开头。当返回行的最后一个片段时,isPrefix将为false。返回的缓冲区只在下次调用ReadLine之前有效。ReadLine要么返回一个非零行,要么返回一个错误,而不是两者兼而有之。</target>
        </trans-unit>
        <trans-unit id="30af98b166430a4d07ac11a60a37dce8c9897d44" translate="yes" xml:space="preserve">
          <source>ReadLineBytes is like ReadLine but returns a []byte instead of a string.</source>
          <target state="translated">ReadLineBytes与ReadLine类似,但返回的是[]字节而不是字符串。</target>
        </trans-unit>
        <trans-unit id="34955aedc1edab445c06914ea85435c83aa1659d" translate="yes" xml:space="preserve">
          <source>ReadMIMEHeader reads a MIME-style header from r. The header is a sequence of possibly continued Key: Value lines ending in a blank line. The returned map m maps CanonicalMIMEHeaderKey(key) to a sequence of values in the same order encountered in the input.</source>
          <target state="translated">ReadMIMEHeader从r中读取一个MIME风格的头,这个头是一个可能持续的Key.Value行的序列,以空行结束。值行,以空行结束。返回的映射m将CanonicalMIMEHeaderKey(key)映射到与输入中遇到的相同顺序的值序列。</target>
        </trans-unit>
        <trans-unit id="e81ba86f59e436daff158e41fbec08f65b2c4f42" translate="yes" xml:space="preserve">
          <source>ReadMemStats populates m with memory allocator statistics.</source>
          <target state="translated">ReadMemStats用内存分配器统计数据填充m。</target>
        </trans-unit>
        <trans-unit id="acb49a6f36fe4a7034527475afbfe7647980d6b9" translate="yes" xml:space="preserve">
          <source>ReadMessage</source>
          <target state="translated">ReadMessage</target>
        </trans-unit>
        <trans-unit id="1551b34da55e8d458cfae44e4a334da9f414dea8" translate="yes" xml:space="preserve">
          <source>ReadMessage reads a message from r. The headers are parsed, and the body of the message will be available for reading from msg.Body.</source>
          <target state="translated">ReadMessage 读取来自 r 的消息,头信息被解析,消息的主体将可从 msg.Body 中读取。</target>
        </trans-unit>
        <trans-unit id="6f05b0c16954598270f35347bda5383a6c522b11" translate="yes" xml:space="preserve">
          <source>ReadMsgIP reads a message from c, copying the payload into b and the associated out-of-band data into oob. It returns the number of bytes copied into b, the number of bytes copied into oob, the flags that were set on the message and the source address of the message.</source>
          <target state="translated">ReadMsgIP从c中读取一条消息,将有效载荷复制到b中,将相关的带外数据复制到ob中。它返回复制到b中的字节数,复制到ob中的字节数,在消息上设置的标志和消息的源地址。</target>
        </trans-unit>
        <trans-unit id="47bd88248b7a6aeb9fe7003935965fcbc4c14b6e" translate="yes" xml:space="preserve">
          <source>ReadMsgUDP reads a message from c, copying the payload into b and the associated out-of-band data into oob. It returns the number of bytes copied into b, the number of bytes copied into oob, the flags that were set on the message and the source address of the message.</source>
          <target state="translated">ReadMsgUDP从c中读取一条消息,将有效载荷复制到b中,将相关的带外数据复制到ob中。它返回复制到b中的字节数、复制到ob中的字节数、在消息上设置的标志和消息的源地址。</target>
        </trans-unit>
        <trans-unit id="f80f0770ba07805dfad9fed9021802994b16c79f" translate="yes" xml:space="preserve">
          <source>ReadMsgUnix reads a message from c, copying the payload into b and the associated out-of-band data into oob. It returns the number of bytes copied into b, the number of bytes copied into oob, the flags that were set on the message and the source address of the message.</source>
          <target state="translated">ReadMsgUnix从c中读取一条消息,将有效载荷复制到b中,将相关的带外数据复制到ob中。它返回复制到b中的字节数,复制到ob中的字节数,在消息上设置的标志和消息的源地址。</target>
        </trans-unit>
        <trans-unit id="25bb46ad3055b508b0608be3bcb05d4dc7a218ac" translate="yes" xml:space="preserve">
          <source>ReadRequest is a low-level function and should only be used for specialized applications; most code should use the Server to read requests and handle them via the Handler interface. ReadRequest only supports HTTP/1.x requests. For HTTP/2, use golang.org/x/net/http2.</source>
          <target state="translated">ReadRequest是一个低级函数,只应该用于专门的应用程序;大多数代码应该使用Server来读取请求,并通过Handler接口处理它们。ReadRequest只支持HTTP/1.x请求。对于HTTP/2,请使用golang.org/x/net/http2。</target>
        </trans-unit>
        <trans-unit id="b1b66f29f0f459c92aabcbebb68a77d5a6970744" translate="yes" xml:space="preserve">
          <source>ReadRequest reads and parses an incoming request from b.</source>
          <target state="translated">ReadRequest读取并解析来自b的传入请求。</target>
        </trans-unit>
        <trans-unit id="25d27159145d0774b1fadc397fe48b995c46c5de" translate="yes" xml:space="preserve">
          <source>ReadResponse reads a multi-line response of the form:</source>
          <target state="translated">ReadResponse读取形式为多行的响应。</target>
        </trans-unit>
        <trans-unit id="ee99ce8c11934415337cdc7bec2e604ef18e71ae" translate="yes" xml:space="preserve">
          <source>ReadResponse reads and returns an HTTP response from r. The req parameter optionally specifies the Request that corresponds to this Response. If nil, a GET request is assumed. Clients must call resp.Body.Close when finished reading resp.Body. After that call, clients can inspect resp.Trailer to find key/value pairs included in the response trailer.</source>
          <target state="translated">ReadResponse 读取并返回来自 r 的 HTTP 响应,req 参数可选择指定与该响应对应的 Request。如果为nil,则假定为GET请求。客户端在读取完resp.Body后必须调用resp.Body.Close。在该调用之后,客户端可以检查resp.Trailer来查找响应预告片中包含的键/值对。</target>
        </trans-unit>
        <trans-unit id="476255423e82d011c96cc157a1f2c1336b3b2a0a" translate="yes" xml:space="preserve">
          <source>ReadRune implements the io.RuneReader interface.</source>
          <target state="translated">ReadRune实现了io.RuneReader接口。</target>
        </trans-unit>
        <trans-unit id="2149703d832b9af2c76dd9abfe510fdf6ec21b40" translate="yes" xml:space="preserve">
          <source>ReadRune reads a single UTF-8 encoded Unicode character and returns the rune and its size in bytes. If no character is available, err will be set.</source>
          <target state="translated">ReadRune读取一个UTF-8编码的Unicode字符,并返回符文和它的字节数。如果没有可用的字符,将设置err。</target>
        </trans-unit>
        <trans-unit id="6414ea883495287275cdc53b35ffd14e0008ac3b" translate="yes" xml:space="preserve">
          <source>ReadRune reads a single UTF-8 encoded Unicode character and returns the rune and its size in bytes. If the encoded rune is invalid, it consumes one byte and returns unicode.ReplacementChar (U+FFFD) with a size of 1.</source>
          <target state="translated">ReadRune读取一个UTF-8编码的Unicode字符,并以字节为单位返回符文和它的大小,如果编码的符文无效,则消耗一个字节并返回大小为1的unicode.ReplaceChar(U+FFFD)。如果编码后的符文无效,则消耗一个字节并返回大小为1的unicode.ReplaceterChar(U+FFFD)。</target>
        </trans-unit>
        <trans-unit id="6486828e56b295be35e03a3674dd21e96b49a79c" translate="yes" xml:space="preserve">
          <source>ReadRune reads and returns the next UTF-8-encoded Unicode code point from the buffer. If no bytes are available, the error returned is io.EOF. If the bytes are an erroneous UTF-8 encoding, it consumes one byte and returns U+FFFD, 1.</source>
          <target state="translated">ReadRune从缓冲区中读取并返回下一个UTF-8编码的Unicode码点。如果没有可用的字节,返回的错误是io.EOF。如果字节是错误的UTF-8编码,则消耗一个字节并返回U+FFFD,1。</target>
        </trans-unit>
        <trans-unit id="78176debea1a291ba3e7ca916182c7ec7d43ab66" translate="yes" xml:space="preserve">
          <source>ReadSeeker is the interface that groups the basic Read and Seek methods.</source>
          <target state="translated">ReadSeeker是对基本的Read和Seek方法进行分组的接口。</target>
        </trans-unit>
        <trans-unit id="6f83dddca1aa94fb6e401f10df5bd11c4e328c97" translate="yes" xml:space="preserve">
          <source>ReadSlice reads until the first occurrence of delim in the input, returning a slice pointing at the bytes in the buffer. The bytes stop being valid at the next read. If ReadSlice encounters an error before finding a delimiter, it returns all the data in the buffer and the error itself (often io.EOF). ReadSlice fails with error ErrBufferFull if the buffer fills without a delim. Because the data returned from ReadSlice will be overwritten by the next I/O operation, most clients should use ReadBytes or ReadString instead. ReadSlice returns err != nil if and only if line does not end in delim.</source>
          <target state="translated">ReadSlice读取直到输入中第一次出现delim,返回一个指向缓冲区中字节的slice。这些字节在下一次读取时停止有效。如果ReadSlice在找到定界符之前遇到了错误,它将返回缓冲区中的所有数据和错误本身(通常是io.EOF)。如果缓冲区在没有找到定界符的情况下被填满,ReadSlice就会以ErrBufferFull错误失败。因为ReadSlice返回的数据会被下一个I/O操作覆盖,所以大多数客户端应该使用ReadBytes或ReadString来代替。如果且仅当行没有以 delim 结尾时,ReadSlice 会返回 err !=nil。</target>
        </trans-unit>
        <trans-unit id="396715e6dd5c32bdbbf83af9027e47c30dc1faa8" translate="yes" xml:space="preserve">
          <source>ReadString reads until the first occurrence of delim in the input, returning a string containing the data up to and including the delimiter. If ReadString encounters an error before finding a delimiter, it returns the data read before the error and the error itself (often io.EOF). ReadString returns err != nil if and only if the returned data does not end in delim.</source>
          <target state="translated">ReadString 读取直到输入中第一次出现 delim,返回一个包含数据的字符串,直到并包括定界符。如果ReadString在找到定界符之前遇到了错误,它将返回在错误之前读取的数据和错误本身(通常是io.EOF)。如果且仅当返回的数据不是以 delim 结尾时,ReadString 会返回 err !=nil。</target>
        </trans-unit>
        <trans-unit id="aaa3e0c7b34f04c5ff175180dbf3748d0757b57f" translate="yes" xml:space="preserve">
          <source>ReadString reads until the first occurrence of delim in the input, returning a string containing the data up to and including the delimiter. If ReadString encounters an error before finding a delimiter, it returns the data read before the error and the error itself (often io.EOF). ReadString returns err != nil if and only if the returned data does not end in delim. For simple uses, a Scanner may be more convenient.</source>
          <target state="translated">ReadString 读取直到输入中第一次出现 delim,返回一个包含数据的字符串,直到并包括定界符。如果ReadString在找到定界符之前遇到了错误,它将返回在错误之前读取的数据和错误本身(通常是io.EOF)。如果且仅当返回的数据不以 delim 结尾时,ReadString 会返回 err !=nil。对于简单的使用,一个Scanner可能更方便。</target>
        </trans-unit>
        <trans-unit id="24714d7c8185be718fff60550f6b7e029b2b159c" translate="yes" xml:space="preserve">
          <source>ReadTrace returns the next chunk of binary tracing data, blocking until data is available. If tracing is turned off and all the data accumulated while it was on has been returned, ReadTrace returns nil. The caller must copy the returned data before calling ReadTrace again. ReadTrace must be called from one goroutine at a time.</source>
          <target state="translated">ReadTrace 返回下一个二进制跟踪数据块,阻塞直到数据可用。如果跟踪被关闭,并且所有在开启时积累的数据都已返回,ReadTrace返回nil。调用者必须在再次调用ReadTrace之前复制返回的数据。ReadTrace必须一次从一个goroutine调用。</target>
        </trans-unit>
        <trans-unit id="989bf43b9a2dfe020990e99dd409325328b3ade3" translate="yes" xml:space="preserve">
          <source>ReadUvarint reads an encoded unsigned integer from r and returns it as a uint64.</source>
          <target state="translated">ReadUvarint从r中读取一个编码的无符号整数,并将其作为一个uint64返回。</target>
        </trans-unit>
        <trans-unit id="675541f596de4c802da653f83b46f8b7718858d0" translate="yes" xml:space="preserve">
          <source>ReadVarint reads an encoded signed integer from r and returns it as an int64.</source>
          <target state="translated">ReadVarint从r中读取一个编码的有符号整数,并以int64的形式返回。</target>
        </trans-unit>
        <trans-unit id="069fcaa32c060bf9bd8bfac5e82274aaead1bc50" translate="yes" xml:space="preserve">
          <source>ReadWriteCloser is the interface that groups the basic Read, Write and Close methods.</source>
          <target state="translated">ReadWriteCloser是将基本的读、写和关闭方法分组的接口。</target>
        </trans-unit>
        <trans-unit id="341b30c9c3b78089bcaa44b8a26a94b9bc0c8ea6" translate="yes" xml:space="preserve">
          <source>ReadWriteSeeker is the interface that groups the basic Read, Write and Seek methods.</source>
          <target state="translated">ReadWriteSeeker是将基本的Read、Write和Seek方法分组的接口。</target>
        </trans-unit>
        <trans-unit id="eb7ce11fb3f6f0101cd6b5288463e8de90a96b51" translate="yes" xml:space="preserve">
          <source>ReadWriter is the interface that groups the basic Read and Write methods.</source>
          <target state="translated">ReadWriter是将基本的读和写方法分组的接口。</target>
        </trans-unit>
        <trans-unit id="dfaac4087d8cb10eb5b8f29ddefebdcafd42a5af" translate="yes" xml:space="preserve">
          <source>ReadWriter stores pointers to a Reader and a Writer. It implements io.ReadWriter.</source>
          <target state="translated">ReadWriter存储了一个Reader和一个Writer的指针。它实现了io.ReadWriter。</target>
        </trans-unit>
        <trans-unit id="79f16a4d9874784deac866dfbd0ce6545be6e239" translate="yes" xml:space="preserve">
          <source>Readdir reads the contents of the directory associated with file and returns a slice of up to n FileInfo values, as would be returned by Lstat, in directory order. Subsequent calls on the same file will yield further FileInfos.</source>
          <target state="translated">Readdir 读取与文件相关联的目录的内容,并按目录顺序返回一个最多 n 个 FileInfo 值的片断,就像 Lstat 所返回的那样。随后对同一文件的调用将产生更多的FileInfos。</target>
        </trans-unit>
        <trans-unit id="501d22e73b2af73a4cd2cda27f0147a879d2d29f" translate="yes" xml:space="preserve">
          <source>Readdirnames reads the contents of the directory associated with file and returns a slice of up to n names of files in the directory, in directory order. Subsequent calls on the same file will yield further names.</source>
          <target state="translated">Readdirnames读取与文件相关联的目录的内容,并按照目录顺序返回目录中最多n个文件名称的片断。随后对同一文件的调用将产生更多的文件名。</target>
        </trans-unit>
        <trans-unit id="ac5bbe8292ed1b69e0f95e5bdaa035569a295fd7" translate="yes" xml:space="preserve">
          <source>Reader</source>
          <target state="translated">Reader</target>
        </trans-unit>
        <trans-unit id="a764e12131a971febc3401d23317f0234b4049b8" translate="yes" xml:space="preserve">
          <source>Reader (Options)</source>
          <target state="translated">读者(选项)</target>
        </trans-unit>
        <trans-unit id="df3472ca3dd5a57262b56d74dcad15e820ebf2eb" translate="yes" xml:space="preserve">
          <source>Reader implements buffering for an io.Reader object.</source>
          <target state="translated">Reader为一个io.Reader对象实现了缓冲。</target>
        </trans-unit>
        <trans-unit id="96784a034a712bc8c815b4587872dbfdfd0582a9" translate="yes" xml:space="preserve">
          <source>Reader is a global, shared instance of a cryptographically secure random number generator.</source>
          <target state="translated">Reader是一个全局的、共享的加密安全随机数生成器实例。</target>
        </trans-unit>
        <trans-unit id="bf613e0e0a803852368392b2dfe7b4682657c458" translate="yes" xml:space="preserve">
          <source>Reader is a quoted-printable decoder.</source>
          <target state="translated">Reader是一个可引用打印的解码器。</target>
        </trans-unit>
        <trans-unit id="b49691ad8407ed7de43e614957e75ec4095c4b28" translate="yes" xml:space="preserve">
          <source>Reader is an iterator over parts in a MIME multipart body. Reader's underlying parser consumes its input as needed. Seeking isn't supported.</source>
          <target state="translated">Reader是一个迭代MIME多部分主体的迭代器。Reader的底层解析器根据需要消耗它的输入。不支持寻找。</target>
        </trans-unit>
        <trans-unit id="21dadd14b38a36c18741cf2c47ad38cb0675eedf" translate="yes" xml:space="preserve">
          <source>Reader is the interface that wraps the basic Read method.</source>
          <target state="translated">Reader是包装基本Read方法的接口。</target>
        </trans-unit>
        <trans-unit id="9bdf18ff83881db62f68bf47e6ac4c6f41d55f66" translate="yes" xml:space="preserve">
          <source>Reader provides sequential access to the contents of a tar archive. Reader.Next advances to the next file in the archive (including the first), and then Reader can be treated as an io.Reader to access the file's data.</source>
          <target state="translated">Reader提供了对tar压缩文件内容的顺序访问。Reader.Next前进到存档中的下一个文件(包括第一个),然后Reader可以被当作io.Reader来访问文件的数据。</target>
        </trans-unit>
        <trans-unit id="cac70aa62b26f1281fbe4d19090a262412eed7e3" translate="yes" xml:space="preserve">
          <source>Reader returns a new Reader for Data. The reader is positioned at byte offset 0 in the DWARF &amp;ldquo;info&amp;rdquo; section.</source>
          <target state="translated">Reader返回一个新的Data Reader。阅读器位于DWARF&amp;ldquo;信息&amp;rdquo;部分的字节偏移量0处。</target>
        </trans-unit>
        <trans-unit id="8049ec93e81c7083091b44ed801d9d9d92c309d9" translate="yes" xml:space="preserve">
          <source>Reader, to read numeric response code lines, key: value headers, lines wrapped with leading spaces on continuation lines, and whole text blocks ending with a dot on a line by itself.</source>
          <target state="translated">读取器,用于读取数字响应码行、键:值头、续行上用前导空格包裹的行、以及行上以点自行结束的整个文本块。</target>
        </trans-unit>
        <trans-unit id="d0009a603321ffa4322fc5ace74c08013f3502dc" translate="yes" xml:space="preserve">
          <source>Reader.Len</source>
          <target state="translated">Reader.Len</target>
        </trans-unit>
        <trans-unit id="52b9ae6b2c685e2a877bd9bbf8defead7e5d5ac7" translate="yes" xml:space="preserve">
          <source>Reader.Multistream</source>
          <target state="translated">Reader.Multistream</target>
        </trans-unit>
        <trans-unit id="23e9cef150e9609032f02dcc6e3ec9a05ca806c3" translate="yes" xml:space="preserve">
          <source>Reader.ReadAll</source>
          <target state="translated">Reader.ReadAll</target>
        </trans-unit>
        <trans-unit id="976c7b59d336efab6bbe07f071aa8d432cb7a047" translate="yes" xml:space="preserve">
          <source>ReaderAt is the interface that wraps the basic ReadAt method.</source>
          <target state="translated">ReaderAt是包装基本ReadAt方法的接口。</target>
        </trans-unit>
        <trans-unit id="29ae6f40e1ba95a55db0a9760f63eada1ab4e398" translate="yes" xml:space="preserve">
          <source>ReaderFrom is the interface that wraps the ReadFrom method.</source>
          <target state="translated">ReaderFrom是封装ReadFrom方法的接口。</target>
        </trans-unit>
        <trans-unit id="b5bdadfe357edf2d398dc3767642063de731a14c" translate="yes" xml:space="preserve">
          <source>Readlink returns the destination of the named symbolic link. If there is an error, it will be of type *PathError.</source>
          <target state="translated">Readlink返回命名的符号链接的目的地。如果有错误,它的类型是*PathError。</target>
        </trans-unit>
        <trans-unit id="3680e45cb759e7b231139c55beb835dcb36f290f" translate="yes" xml:space="preserve">
          <source>Reads and Writes on the pipe are matched one to one except when multiple Reads are needed to consume a single Write. That is, each Write to the PipeWriter blocks until it has satisfied one or more Reads from the PipeReader that fully consume the written data. The data is copied directly from the Write to the corresponding Read (or Reads); there is no internal buffering.</source>
          <target state="translated">管道上的读和写是一对一匹配的,除非需要多个读来消耗一个写。也就是说,对PipeWriter的每个Write都会阻塞,直到它满足了一个或多个来自PipeReader的Reads,完全消耗了所写数据。数据直接从Write复制到相应的Read(或Reads),没有内部缓冲。</target>
        </trans-unit>
        <trans-unit id="96964e0a893395e3b89017fa3370fe50203e0f58" translate="yes" xml:space="preserve">
          <source>Real returns the real part of x, which must be a numeric or unknown value. If x is Unknown, the result is Unknown.</source>
          <target state="translated">Real 返回 x 的实数部分,它必须是一个数值或未知值。如果x是未知值,结果是未知值。</target>
        </trans-unit>
        <trans-unit id="a4e7e73832091a1dd0eb45c5e3535f9fc0bb0385" translate="yes" xml:space="preserve">
          <source>ReceiverName returns the receiver type name of this symbol, or the empty string if there is none.</source>
          <target state="translated">ReceiverName 返回这个符号的接收器类型名称,如果没有,则返回空字符串。</target>
        </trans-unit>
        <trans-unit id="76042968d1a5f484d7ec99013213446b06dc9be8" translate="yes" xml:space="preserve">
          <source>Receivers should be careful to use Equal to compare MACs in order to avoid timing side-channels:</source>
          <target state="translated">接收机应注意使用Equal来比较MAC,以避免定时侧信道。</target>
        </trans-unit>
        <trans-unit id="baede57b4fd75bbaf39e019c76771e5b57cbf06e" translate="yes" xml:space="preserve">
          <source>RecordHeaderError is returned when a TLS record header is invalid.</source>
          <target state="translated">当TLS记录头无效时,将返回RecordHeaderError。</target>
        </trans-unit>
        <trans-unit id="2614b13193f400f1a9992deddc528f2f896c1029" translate="yes" xml:space="preserve">
          <source>Rect is shorthand for Rectangle{Pt(x0, y0), Pt(x1, y1)}. The returned rectangle has minimum and maximum coordinates swapped if necessary so that it is well-formed.</source>
          <target state="translated">Rect 是 Rectangle{Pt(x0,y0),Pt(x1,y1)}的简写。返回的矩形的最小和最大坐标在必要时被调换,所以它的形状很好。</target>
        </trans-unit>
        <trans-unit id="1937bfd09178388c39ec43cf08d134d3d9d1898f" translate="yes" xml:space="preserve">
          <source>Rect returns the complex number x with polar coordinates r, &amp;theta;.</source>
          <target state="translated">Rect返回具有极坐标r，&amp;theta;的复数x。</target>
        </trans-unit>
        <trans-unit id="94dab483158e13564ee6a455c353913588b6dbd1" translate="yes" xml:space="preserve">
          <source>Recv receives and returns a value from the channel v. It panics if v's Kind is not Chan. The receive blocks until a value is ready. The boolean value ok is true if the value x corresponds to a send on the channel, false if it is a zero value received because the channel is closed.</source>
          <target state="translated">Recv从通道v中接收并返回一个值,如果v的Kind不是Chan,它就会恐慌。receive会阻塞,直到一个值准备好。如果值x对应于通道上的发送,则布尔值ok为真,如果因为通道关闭而接收到的是一个零值,则为假。</target>
        </trans-unit>
        <trans-unit id="03b8f406324956c22ef3f439d41bfd0bef6159ba" translate="yes" xml:space="preserve">
          <source>Recv returns the receiver of signature s (if a method), or nil if a function. It is ignored when comparing signatures for identity.</source>
          <target state="translated">Recv 返回签名 s 的接收者(如果是方法),如果是函数,则返回 nil。在比较身份的签名时,它被忽略。</target>
        </trans-unit>
        <trans-unit id="5ae5c546dd23f367221f8f4d367950523d9cf3bb" translate="yes" xml:space="preserve">
          <source>Recv returns the type of x in x.f.</source>
          <target state="translated">Recv返回x.f中x的类型。</target>
        </trans-unit>
        <trans-unit id="9250d7c2a971eb24cc4eedcfff481ae3439946cf" translate="yes" xml:space="preserve">
          <source>Redirect replies to the request with a redirect to url, which may be a path relative to the request path.</source>
          <target state="translated">重定向以重定向到url的方式回复请求,这个url可以是相对于请求路径的路径。</target>
        </trans-unit>
        <trans-unit id="c909a75a26a89b05691be1108e0ab3c2e1bcdb1a" translate="yes" xml:space="preserve">
          <source>RedirectHandler returns a request handler that redirects each request it receives to the given url using the given status code.</source>
          <target state="translated">RedirectHandler返回一个请求处理程序,该处理程序使用给定的状态码将收到的每个请求重定向到给定的url。</target>
        </trans-unit>
        <trans-unit id="d6ec8155461c38d823e4b635ac46022ba360bb68" translate="yes" xml:space="preserve">
          <source>Referer is misspelled as in the request itself, a mistake from the earliest days of HTTP. This value can also be fetched from the Header map as Header[&quot;Referer&quot;]; the benefit of making it available as a method is that the compiler can diagnose programs that use the alternate (correct English) spelling req.Referrer() but cannot diagnose programs that use Header[&quot;Referrer&quot;].</source>
          <target state="translated">Referer在请求本身中拼写错误,这是HTTP最早时期的错误。这个值也可以作为Header[&quot;Referer&quot;]从Header map中获取;把它作为方法提供的好处是,编译器可以诊断出使用备用(正确的英文)拼写req.Referer()的程序,但不能诊断出使用Header[&quot;Referer&quot;]的程序。</target>
        </trans-unit>
        <trans-unit id="07d5e3dfcd70520a1bbdb2fa9dbe2bae91c99a57" translate="yes" xml:space="preserve">
          <source>Referer returns the referring URL, if sent in the request.</source>
          <target state="translated">Referer返回引用的URL(如果在请求中发送)。</target>
        </trans-unit>
        <trans-unit id="6ac251dfde6b7c655d39dbc21c40c658e7f0e5ba" translate="yes" xml:space="preserve">
          <source>Regardless of the verb, if an operand is an interface value, the internal concrete value is used, not the interface itself. Thus:</source>
          <target state="translated">不管是哪个动词,如果操作数是接口值,则使用内部具体值,而不是接口本身。因此:</target>
        </trans-unit>
        <trans-unit id="ae8b91c59ed7a48ada5b7396ec353e27cc7c57cd" translate="yes" xml:space="preserve">
          <source>Regexp is the representation of a compiled regular expression. A Regexp is safe for concurrent use by multiple goroutines, except for configuration methods, such as Longest.</source>
          <target state="translated">Regexp是编译后的正则表达式的表示。一个Regexp可以被多个goroutine安全地并发使用,但配置方法除外,比如Longest。</target>
        </trans-unit>
        <trans-unit id="b84f40722bc57d5dce890a8a11e5c4fee08f3c9c" translate="yes" xml:space="preserve">
          <source>Regexp.Expand</source>
          <target state="translated">Regexp.Expand</target>
        </trans-unit>
        <trans-unit id="3dd017106e6cb747b2a0cd305e5bb9fdade3a8d1" translate="yes" xml:space="preserve">
          <source>Regexp.ExpandString</source>
          <target state="translated">Regexp.ExpandString</target>
        </trans-unit>
        <trans-unit id="ec3956758c005d81eaf9415a4c61a2390b4ec0f2" translate="yes" xml:space="preserve">
          <source>Regexp.Find</source>
          <target state="translated">Regexp.Find</target>
        </trans-unit>
        <trans-unit id="5a4d1168fbbea65dfa0185be8ce3c71cdc597f4b" translate="yes" xml:space="preserve">
          <source>Regexp.FindAll</source>
          <target state="translated">Regexp.FindAll</target>
        </trans-unit>
        <trans-unit id="9a7a55d789a0b84db34a38b56a2f4242a4cf127c" translate="yes" xml:space="preserve">
          <source>Regexp.FindAllString</source>
          <target state="translated">Regexp.FindAllString</target>
        </trans-unit>
        <trans-unit id="f7e56583e4dcc297ccf2aa23c322191411764c7e" translate="yes" xml:space="preserve">
          <source>Regexp.FindAllStringSubmatch</source>
          <target state="translated">Regexp.FindAllStringSubmatch</target>
        </trans-unit>
        <trans-unit id="e4337ecbd053cf4beaa55b4111d3d25165c547a3" translate="yes" xml:space="preserve">
          <source>Regexp.FindAllStringSubmatchIndex</source>
          <target state="translated">Regexp.FindAllStringSubmatchIndex</target>
        </trans-unit>
        <trans-unit id="55182b4c005261d0e66f0c8c4df35946648e43bd" translate="yes" xml:space="preserve">
          <source>Regexp.FindAllSubmatch</source>
          <target state="translated">Regexp.FindAllSubmatch</target>
        </trans-unit>
        <trans-unit id="752406799d805cf76b21ac4473155fcd9c435cf1" translate="yes" xml:space="preserve">
          <source>Regexp.FindAllSubmatchIndex</source>
          <target state="translated">Regexp.FindAllSubmatchIndex</target>
        </trans-unit>
        <trans-unit id="ca21e70b0b76817fc6bc10e7f6cc4170f855d5aa" translate="yes" xml:space="preserve">
          <source>Regexp.FindIndex</source>
          <target state="translated">Regexp.FindIndex</target>
        </trans-unit>
        <trans-unit id="21fdf1e48587944dc1c11b68645cfe5138e0b116" translate="yes" xml:space="preserve">
          <source>Regexp.FindString</source>
          <target state="translated">Regexp.FindString</target>
        </trans-unit>
        <trans-unit id="dc52dbc2324ccd5021b173c341b811e2472a4206" translate="yes" xml:space="preserve">
          <source>Regexp.FindStringIndex</source>
          <target state="translated">Regexp.FindStringIndex</target>
        </trans-unit>
        <trans-unit id="a2b5fabc1cf5de45d659c3142098c4fde4339cdc" translate="yes" xml:space="preserve">
          <source>Regexp.FindStringSubmatch</source>
          <target state="translated">Regexp.FindStringSubmatch</target>
        </trans-unit>
        <trans-unit id="e27002b196cee520413e84f76c97dc77b353b852" translate="yes" xml:space="preserve">
          <source>Regexp.FindSubmatch</source>
          <target state="translated">Regexp.FindSubmatch</target>
        </trans-unit>
        <trans-unit id="0008582d6bb9067aadd263f03da910a66e6e0e19" translate="yes" xml:space="preserve">
          <source>Regexp.Match</source>
          <target state="translated">Regexp.Match</target>
        </trans-unit>
        <trans-unit id="2c0eada8b9cfbb5d24aadca2e8fa445cbe3b7e2b" translate="yes" xml:space="preserve">
          <source>Regexp.MatchString</source>
          <target state="translated">Regexp.MatchString</target>
        </trans-unit>
        <trans-unit id="4c687a2a42e7f3d60c9f98f0993362b9c2735490" translate="yes" xml:space="preserve">
          <source>Regexp.ReplaceAllLiteralString</source>
          <target state="translated">Regexp.ReplaceAllLiteralString</target>
        </trans-unit>
        <trans-unit id="9fececaf13096d7dc9ffe3d2d93e25169cf762e1" translate="yes" xml:space="preserve">
          <source>Regexp.ReplaceAllString</source>
          <target state="translated">Regexp.ReplaceAllString</target>
        </trans-unit>
        <trans-unit id="5f97458d8e33d7f5f2c52b953c172d5ccb890b23" translate="yes" xml:space="preserve">
          <source>Regexp.ReplaceAllStringFunc</source>
          <target state="translated">Regexp.ReplaceAllStringFunc</target>
        </trans-unit>
        <trans-unit id="60f05fd13196ffa4dd89663cf41abb4f862a263c" translate="yes" xml:space="preserve">
          <source>Regexp.Split</source>
          <target state="translated">Regexp.Split</target>
        </trans-unit>
        <trans-unit id="b36b7852ff6e5f89fe309ce0324c7c9f6dac2ab6" translate="yes" xml:space="preserve">
          <source>Regexp.SubexpNames</source>
          <target state="translated">Regexp.SubexpNames</target>
        </trans-unit>
        <trans-unit id="96a2105b6d183387bea55013dc84567e629210a2" translate="yes" xml:space="preserve">
          <source>Region is a region of code whose execution time interval is traced.</source>
          <target state="translated">Region是指执行时间间隔被追踪的代码区域。</target>
        </trans-unit>
        <trans-unit id="95c213e4f5521f3f5195554245abca05424ff590" translate="yes" xml:space="preserve">
          <source>Register makes a database driver available by the provided name. If Register is called twice with the same name or if driver is nil, it panics.</source>
          <target state="translated">Register通过提供的名称提供一个数据库驱动程序。如果Register被调用了两次相同的名字,或者如果driver为nil,它就会崩溃。</target>
        </trans-unit>
        <trans-unit id="64aef767785d208425e3e70c5d2194fcd9c84c85" translate="yes" xml:space="preserve">
          <source>Register publishes in the server the set of methods of the receiver value that satisfy the following conditions:</source>
          <target state="translated">Register在服务器上发布满足以下条件的接收值的方法集。</target>
        </trans-unit>
        <trans-unit id="cbe295e9d864bc0bca7f28c205cb5395eba55d05" translate="yes" xml:space="preserve">
          <source>Register publishes the receiver's methods in the DefaultServer.</source>
          <target state="translated">注册在DefaultServer中发布接收器的方法。</target>
        </trans-unit>
        <trans-unit id="c181d095749a9fa33757c1798befea770ef8d4eb" translate="yes" xml:space="preserve">
          <source>Register records a type, identified by a value for that type, under its internal type name. That name will identify the concrete type of a value sent or received as an interface variable. Only types that will be transferred as implementations of interface values need to be registered. Expecting to be used only during initialization, it panics if the mapping between types and names is not a bijection.</source>
          <target state="translated">注册表在其内部类型名下记录一个类型,由该类型的值来标识。该名称将标识作为接口变量发送或接收的值的具体类型。只有那些将作为接口值的实现而被传输的类型才需要被注册。期待只在初始化期间使用,如果类型和名称之间的映射不是双射,它就会恐慌。</target>
        </trans-unit>
        <trans-unit id="fceb2cf0f9b16aaaaa6d86b667b93fcaf25ae6c9" translate="yes" xml:space="preserve">
          <source>RegisterCompressor registers custom compressors for a specified method ID. The common methods Store and Deflate are built in.</source>
          <target state="translated">RegisterCompressor为指定的方法ID注册自定义的压缩器。常用的方法Store和Deflate是内置的。</target>
        </trans-unit>
        <trans-unit id="4a803c7a9e0d15c2a5bd92b06180759964dddc4a" translate="yes" xml:space="preserve">
          <source>RegisterCompressor registers or overrides a custom compressor for a specific method ID. If a compressor for a given method is not found, Writer will default to looking up the compressor at the package level.</source>
          <target state="translated">RegisterCompressor 为一个特定的方法 ID 注册或覆盖一个自定义的压缩器。如果没有找到给定方法的压缩器,Writer将默认为在包级别查找压缩器。</target>
        </trans-unit>
        <trans-unit id="75b2829cabbf108c3c7f621e80ccf782333f2745" translate="yes" xml:space="preserve">
          <source>RegisterCover records the coverage data accumulators for the tests. NOTE: This function is internal to the testing infrastructure and may change. It is not covered (yet) by the Go 1 compatibility guidelines.</source>
          <target state="translated">RegisterCover记录测试的覆盖数据累加器。注意:这个功能是测试基础架构的内部功能,可能会改变。Go 1 兼容性指南还没有涉及到它。</target>
        </trans-unit>
        <trans-unit id="0efe5941ddd4024eca3486bcfdaa1b04b1d68c96" translate="yes" xml:space="preserve">
          <source>RegisterDecompressor allows custom decompressors for a specified method ID. The common methods Store and Deflate are built in.</source>
          <target state="translated">RegisterDecompressor允许为指定的方法ID定制解压器。常用的方法Store和Deflate是内置的。</target>
        </trans-unit>
        <trans-unit id="f8201de27600ded04eed1497b03a93af78ab1356" translate="yes" xml:space="preserve">
          <source>RegisterDecompressor registers or overrides a custom decompressor for a specific method ID. If a decompressor for a given method is not found, Reader will default to looking up the decompressor at the package level.</source>
          <target state="translated">RegisterDecompressor 注册或覆盖特定方法 ID 的自定义解压器。如果没有找到特定方法的解压器,Reader将默认为在包级别查找解压器。</target>
        </trans-unit>
        <trans-unit id="9306a2a96e5923311a823aa140641259832a6493" translate="yes" xml:space="preserve">
          <source>RegisterFormat registers an image format for use by Decode. Name is the name of the format, like &quot;jpeg&quot; or &quot;png&quot;. Magic is the magic prefix that identifies the format's encoding. The magic string can contain &quot;?&quot; wildcards that each match any one byte. Decode is the function that decodes the encoded image. DecodeConfig is the function that decodes just its configuration.</source>
          <target state="translated">RegisterFormat 注册一个供 Decode 使用的图像格式。Name是格式的名称,如 &quot;jpeg &quot;或 &quot;png&quot;。Magic是标识格式编码的魔术前缀。Magic字符串可以包含&quot;? &quot;通配符,每个通配符匹配任意一个字节。Decode是对编码后的图像进行解码的函数。DecodeConfig是只对其配置进行解码的函数。</target>
        </trans-unit>
        <trans-unit id="d2728f688707b63db693060d8790bf4683f92102" translate="yes" xml:space="preserve">
          <source>RegisterHash registers a function that returns a new instance of the given hash function. This is intended to be called from the init function in packages that implement hash functions.</source>
          <target state="translated">RegisterHash 注册一个函数,返回给定哈希函数的新实例。这个函数在实现哈希函数的包中的init函数中被调用。</target>
        </trans-unit>
        <trans-unit id="f205fffb3fe13999a49ce9f8f1c25ec589135c4d" translate="yes" xml:space="preserve">
          <source>RegisterName is like Register but uses the provided name for the type instead of the receiver's concrete type.</source>
          <target state="translated">RegisterName与Register类似,但使用提供的类型名称而不是接收者的具体类型。</target>
        </trans-unit>
        <trans-unit id="25332b231573649cd9dd5719e7982ea3f0248d42" translate="yes" xml:space="preserve">
          <source>RegisterName is like Register but uses the provided name rather than the type's default.</source>
          <target state="translated">RegisterName与Register类似,但使用提供的名称而不是类型的默认名称。</target>
        </trans-unit>
        <trans-unit id="50c9507f9819b5006da79dc0a05071eebeda3b66" translate="yes" xml:space="preserve">
          <source>RegisterOnShutdown registers a function to call on Shutdown. This can be used to gracefully shutdown connections that have undergone NPN/ALPN protocol upgrade or that have been hijacked. This function should start protocol-specific graceful shutdown, but should not wait for shutdown to complete.</source>
          <target state="translated">RegisterOnShutdown 注册一个在Shutdown时调用的函数。这可以用来优雅地关闭经过NPN/ALPN协议升级或被劫持的连接。这个函数应该启动特定协议的优雅关机,但不应该等待关机完成。</target>
        </trans-unit>
        <trans-unit id="f09b3e8729145f382cce24a789165716e1f6f581" translate="yes" xml:space="preserve">
          <source>RegisterProtocol can be used by other packages to provide implementations of protocol schemes like &quot;ftp&quot; or &quot;file&quot;.</source>
          <target state="translated">RegisterProtocol可以被其他软件包用来提供协议方案的实现,比如 &quot;ftp &quot;或 &quot;file&quot;。</target>
        </trans-unit>
        <trans-unit id="dbed30c09a7f4317da85a08f890897f3a240daa9" translate="yes" xml:space="preserve">
          <source>RegisterProtocol registers a new protocol with scheme. The Transport will pass requests using the given scheme to rt. It is rt's responsibility to simulate HTTP request semantics.</source>
          <target state="translated">RegisterProtocol用scheme注册一个新协议。Transport将使用给定的scheme将请求传递给rt,rt的责任是模拟HTTP请求语义。</target>
        </trans-unit>
        <trans-unit id="95f136e8903a5338ba8f8a6eba4b4b48f4b69ff6" translate="yes" xml:space="preserve">
          <source>Regs386 is the Mach-O 386 register structure.</source>
          <target state="translated">Regs386是Mach-O 386寄存器结构。</target>
        </trans-unit>
        <trans-unit id="2fcecaafbea673f4dcd43eda2b8e308980d372b2" translate="yes" xml:space="preserve">
          <source>RegsAMD64 is the Mach-O AMD64 register structure.</source>
          <target state="translated">RegsAMD64是Mach-O AMD64寄存器结构。</target>
        </trans-unit>
        <trans-unit id="e042b10a368397c92fb60dbef856be3d5a1c4f5c" translate="yes" xml:space="preserve">
          <source>Rel</source>
          <target state="translated">Rel</target>
        </trans-unit>
        <trans-unit id="1fb867ac152e76d351e8dfda8aca4022a73396b3" translate="yes" xml:space="preserve">
          <source>Rel returns a relative path that is lexically equivalent to targpath when joined to basepath with an intervening separator. That is, Join(basepath, Rel(basepath, targpath)) is equivalent to targpath itself. On success, the returned path will always be relative to basepath, even if basepath and targpath share no elements. An error is returned if targpath can't be made relative to basepath or if knowing the current working directory would be necessary to compute it. Rel calls Clean on the result.</source>
          <target state="translated">Rel 返回一个相对路径,当它与 basepath 连接时,在词义上等同于 targpath,中间有一个分隔符。也就是说,Join(basepath,Rel(basepath,targpath))等同于targpath本身。成功后,返回的路径将始终是相对于basepath的,即使basepath和targpath没有共享元素。如果targpath不能与basepath相对,或者需要知道当前工作目录才能计算,则返回错误。Rel在结果上调用Clean。</target>
        </trans-unit>
        <trans-unit id="c91ec177ba02dafca5c024ef643b47566dd89ce7" translate="yes" xml:space="preserve">
          <source>Relationship between Tok value and Specs element type:</source>
          <target state="translated">Tok值和Specs元素类型之间的关系。</target>
        </trans-unit>
        <trans-unit id="b6abe7b7ff14b910183c9aec85ce50c4ba39a8a2" translate="yes" xml:space="preserve">
          <source>RelativeTo returns a Qualifier that fully qualifies members of all packages other than pkg.</source>
          <target state="translated">RelativeTo 返回一个 Qualifier,它可以完全限定 pkg 以外的所有包的成员。</target>
        </trans-unit>
        <trans-unit id="97b37138ea9a73172899c8018d830214258b5899" translate="yes" xml:space="preserve">
          <source>Release frees up resources allocated for the function. The function must not be invoked after calling Release.</source>
          <target state="translated">Release释放了为函数分配的资源。在调用Release之后,不得再调用该函数。</target>
        </trans-unit>
        <trans-unit id="c955e9bb05dd10804916da733d223f9b35d93831" translate="yes" xml:space="preserve">
          <source>Release releases any resources associated with the Process p, rendering it unusable in the future. Release only needs to be called if Wait is not.</source>
          <target state="translated">Release释放与进程p相关联的任何资源,使其在未来无法使用。只有在Wait没有被调用的情况下,才需要调用Release。</target>
        </trans-unit>
        <trans-unit id="74b4353ac8d321669700f92b4b41fd9bf3c282ea" translate="yes" xml:space="preserve">
          <source>Reloc represents a PE COFF relocation. Each section contains its own relocation list.</source>
          <target state="translated">Reloc 代表 PE COFF 重置。每个部分都包含自己的重定位列表。</target>
        </trans-unit>
        <trans-unit id="06f15fe6a2a2d8aaac59472278e750857f76ab13" translate="yes" xml:space="preserve">
          <source>Relocation types for 386.</source>
          <target state="translated">386的搬迁类型。</target>
        </trans-unit>
        <trans-unit id="d75a9d4eea543b3382ef4c2ebb9e3847ab91fd45" translate="yes" xml:space="preserve">
          <source>Relocation types for 64-bit PowerPC or Power Architecture processors.</source>
          <target state="translated">64位PowerPC或Power架构处理器的重定位类型。</target>
        </trans-unit>
        <trans-unit id="cf64299a5f4f83507314f139a3920dac3975ef27" translate="yes" xml:space="preserve">
          <source>Relocation types for AArch64 (aka arm64)</source>
          <target state="translated">AArch64(又名arm64)的重定位类型</target>
        </trans-unit>
        <trans-unit id="ef97dc2ae262d8f689d2dbae4ceb64c7c62edcc6" translate="yes" xml:space="preserve">
          <source>Relocation types for ARM.</source>
          <target state="translated">ARM的搬迁类型。</target>
        </trans-unit>
        <trans-unit id="2557c954121a635ff74fb9af9fe06dc80e27b715" translate="yes" xml:space="preserve">
          <source>Relocation types for Alpha.</source>
          <target state="translated">阿尔法的搬迁类型。</target>
        </trans-unit>
        <trans-unit id="1a1e40660756b62ef3239b6ced113d0caf0dbeda" translate="yes" xml:space="preserve">
          <source>Relocation types for MIPS.</source>
          <target state="translated">MIPS的搬迁类型。</target>
        </trans-unit>
        <trans-unit id="37b372c8b8cafc23d3fe71c2d91eeb8c48e4e130" translate="yes" xml:space="preserve">
          <source>Relocation types for PowerPC.</source>
          <target state="translated">PowerPC的搬迁类型。</target>
        </trans-unit>
        <trans-unit id="515822ec7faf1b82351dd8cb58bc45abc27332b8" translate="yes" xml:space="preserve">
          <source>Relocation types for RISC-V processors.</source>
          <target state="translated">RISC-V处理器的重新定位类型。</target>
        </trans-unit>
        <trans-unit id="28595645ef003fbc741125cd77426e420a3c93bb" translate="yes" xml:space="preserve">
          <source>Relocation types for SPARC.</source>
          <target state="translated">SPARC的搬迁类型。</target>
        </trans-unit>
        <trans-unit id="c8eeb8ad932e590ca3c9a184613db792a1b7d221" translate="yes" xml:space="preserve">
          <source>Relocation types for s390x processors.</source>
          <target state="translated">s390x处理器的搬迁类型。</target>
        </trans-unit>
        <trans-unit id="65d84f2017b766a2f893b1d9391a10aba054030c" translate="yes" xml:space="preserve">
          <source>Relocation types for x86-64.</source>
          <target state="translated">x86-64的搬迁类型。</target>
        </trans-unit>
        <trans-unit id="f46f12d749f237f3883c4c5a62ab9b4f4409ae12" translate="yes" xml:space="preserve">
          <source>Rem sets z to the remainder x%y for y != 0 and returns z. If y == 0, a division-by-zero run-time panic occurs. Rem implements truncated modulus (like Go); see QuoRem for more details.</source>
          <target state="translated">Rem将z设为y !=0的余数x%y,并返回z。如果y ==0,则会发生逐零除法的运行时恐慌。Rem实现了截断模数(像Go一样);更多细节请参见QuoRem。</target>
        </trans-unit>
        <trans-unit id="5a90835af9526ee1f92955fe811ed706ded57897" translate="yes" xml:space="preserve">
          <source>Remainder returns the IEEE 754 floating-point remainder of x/y.</source>
          <target state="translated">Remainder 返回 x/y 的 IEEE 754 浮点余数。</target>
        </trans-unit>
        <trans-unit id="2dbe95bdd28a0d327a2826a1eef6ea3b725d6372" translate="yes" xml:space="preserve">
          <source>RemoteAddr returns the remote network address.</source>
          <target state="translated">RemoteAddr 返回远程网络地址。</target>
        </trans-unit>
        <trans-unit id="8f214e8a0c44c6dd9e0f980e84dc95f63540d94a" translate="yes" xml:space="preserve">
          <source>RemoteAddr returns the remote network address. The Addr returned is shared by all invocations of RemoteAddr, so do not modify it.</source>
          <target state="translated">RemoteAddr返回远程网络地址。返回的Addr是所有调用RemoteAddr的次数所共享的,所以不要修改它。</target>
        </trans-unit>
        <trans-unit id="90f28a6964f1d3561d308698fa02c4f609406cc1" translate="yes" xml:space="preserve">
          <source>Remove removes and returns the element at index i from the heap. The complexity is O(log n) where n = h.Len().</source>
          <target state="translated">Remove从堆中移除并返回索引i处的元素。复杂度为O(log n),其中n=h.Len()。</target>
        </trans-unit>
        <trans-unit id="63f1e9035000ecf346c434c7cac5dc81f24b1fd9" translate="yes" xml:space="preserve">
          <source>Remove removes e from l if e is an element of list l. It returns the element value e.Value. The element must not be nil.</source>
          <target state="translated">如果e是列表l中的元素,则Remove从l中删除e,并返回元素值e.Value。元素不能是nil。</target>
        </trans-unit>
        <trans-unit id="e157d0f3ede189bf26b7e5070547dae063fd8af3" translate="yes" xml:space="preserve">
          <source>Remove removes the execution stack associated with value from the profile. It is a no-op if the value is not in the profile.</source>
          <target state="translated">移除从配置文件中移除与值相关联的执行栈。如果该值不在配置文件中,则为no-op。</target>
        </trans-unit>
        <trans-unit id="737a090d3844bc76afa279471870777ff484d715" translate="yes" xml:space="preserve">
          <source>Remove removes the named file or (empty) directory. If there is an error, it will be of type *PathError.</source>
          <target state="translated">移除移除命名的文件或(空)目录,如果有错误,它的类型是*PathError。如果有错误,它的类型将是*PathError。</target>
        </trans-unit>
        <trans-unit id="2570a819a5c470bfe2d2d19b6aafa9194f77567b" translate="yes" xml:space="preserve">
          <source>RemoveAll removes any temporary files associated with a Form.</source>
          <target state="translated">RemoveAll删除与表格相关的任何临时文件。</target>
        </trans-unit>
        <trans-unit id="4fad214b70e3f0d318c435f74dd889aca7ef4dce" translate="yes" xml:space="preserve">
          <source>RemoveAll removes path and any children it contains. It removes everything it can but returns the first error it encounters. If the path does not exist, RemoveAll returns nil (no error). If there is an error, it will be of type *PathError.</source>
          <target state="translated">RemoveAll删除路径和它所包含的任何子程序。它删除了所有能删除的内容,但会在遇到第一个错误时返回。如果路径不存在,RemoveAll返回nil(没有错误)。如果有一个错误,它的类型是*PathError。</target>
        </trans-unit>
        <trans-unit id="a4df6c6f5aeda6e3a5e7e46422d0e2c2213a3c07" translate="yes" xml:space="preserve">
          <source>RemoveMultiples sorts an ErrorList and removes all but the first error per line.</source>
          <target state="translated">RemoveMultiples对ErrorList进行排序,并删除每行中除第一个错误以外的所有错误。</target>
        </trans-unit>
        <trans-unit id="c2642ac096483cfaf0dfa99c4fbd35ae36daa1eb" translate="yes" xml:space="preserve">
          <source>Rename renames (moves) oldpath to newpath. If newpath already exists and is not a directory, Rename replaces it. OS-specific restrictions may apply when oldpath and newpath are in different directories. If there is an error, it will be of type *LinkError.</source>
          <target state="translated">Rename 将 oldpath 重命名(移动)到 newpath。如果newpath已经存在并且不是一个目录,那么Rename会替换它。当 oldpath 和 newpath 在不同的目录中时,可能会有操作系统特有的限制。如果有一个错误,它的类型将是*LinkError。</target>
        </trans-unit>
        <trans-unit id="fdd5e93217a24d0127aee52fa57edae8bdb219bf" translate="yes" xml:space="preserve">
          <source>Renegotiation is not defined in TLS 1.3.</source>
          <target state="translated">TLS 1.3中没有定义重新协商。</target>
        </trans-unit>
        <trans-unit id="592ed73cf658d5bb06fa571424af0b382c1c93a8" translate="yes" xml:space="preserve">
          <source>RenegotiationSupport enumerates the different levels of support for TLS renegotiation. TLS renegotiation is the act of performing subsequent handshakes on a connection after the first. This significantly complicates the state machine and has been the source of numerous, subtle security issues. Initiating a renegotiation is not supported, but support for accepting renegotiation requests may be enabled.</source>
          <target state="translated">RenegotiationSupport枚举了对TLS重新协商的不同级别的支持。TLS重新协商是指在第一次握手后对一个连接进行后续的握手。这使得状态机变得非常复杂,并且是许多微妙的安全问题的来源。不支持发起重新协商,但可以支持接受重新协商请求。</target>
        </trans-unit>
        <trans-unit id="659eba121958f4a29fab3d29d61cedc55a892334" translate="yes" xml:space="preserve">
          <source>Repeat</source>
          <target state="translated">Repeat</target>
        </trans-unit>
        <trans-unit id="599d1421a3d35ed387e2145047d3b7a4416981b0" translate="yes" xml:space="preserve">
          <source>Repeat returns a new byte slice consisting of count copies of b.</source>
          <target state="translated">重复返回一个由b的计数拷贝组成的新字节片断。</target>
        </trans-unit>
        <trans-unit id="0843316565926f24e0d78b098353e903c702fd32" translate="yes" xml:space="preserve">
          <source>Repeat returns a new string consisting of count copies of the string s.</source>
          <target state="translated">Repeat 返回一个由字符串 s 的计数副本组成的新字符串。</target>
        </trans-unit>
        <trans-unit id="b93ec95436616b79bd94ec117ace8a646628d209" translate="yes" xml:space="preserve">
          <source>Repetitions:</source>
          <target state="translated">Repetitions:</target>
        </trans-unit>
        <trans-unit id="a7cf7b25a703b308887c7f1d100c4326ef20ac46" translate="yes" xml:space="preserve">
          <source>Replace</source>
          <target state="translated">Replace</target>
        </trans-unit>
        <trans-unit id="14a86b576c43d99c7af38126a244d77d20b45014" translate="yes" xml:space="preserve">
          <source>Replace returns a copy of s with all replacements performed.</source>
          <target state="translated">替换返回s的副本,并进行所有替换。</target>
        </trans-unit>
        <trans-unit id="486c15b931366bdf03143c243ee2b4d97be57dd7" translate="yes" xml:space="preserve">
          <source>Replace returns a copy of the slice s with the first n non-overlapping instances of old replaced by new. If old is empty, it matches at the beginning of the slice and after each UTF-8 sequence, yielding up to k+1 replacements for a k-rune slice. If n &amp;lt; 0, there is no limit on the number of replacements.</source>
          <target state="translated">Replace返回slice的副本，其中s的副本具有old的前n个不重叠的实例，并由new实例替换。如果old为空，则它在切片的开头和每个UTF-8序列之后匹配，最多可产生k个符文切片的k + 1个替换。如果n &amp;lt;0，则替换次数没有限制。</target>
        </trans-unit>
        <trans-unit id="db4d7af1ecfbb4c54ae4d472073701051302c13a" translate="yes" xml:space="preserve">
          <source>Replace returns a copy of the string s with the first n non-overlapping instances of old replaced by new. If old is empty, it matches at the beginning of the string and after each UTF-8 sequence, yielding up to k+1 replacements for a k-rune string. If n &amp;lt; 0, there is no limit on the number of replacements.</source>
          <target state="translated">Replace返回字符串s的副本，其中旧的前n个非重叠实例被新的替换。如果old为空，则它在字符串的开头和每个UTF-8序列之后匹配，最多可产生k个符文字符串的k + 1个替换。如果n &amp;lt;0，则替换次数没有限制。</target>
        </trans-unit>
        <trans-unit id="6eadb25ec304f683e79d867595086d352904b5b3" translate="yes" xml:space="preserve">
          <source>ReplaceAll</source>
          <target state="translated">ReplaceAll</target>
        </trans-unit>
        <trans-unit id="73ca5d06cabf37b075a8580fb5101f87650ad229" translate="yes" xml:space="preserve">
          <source>ReplaceAll returns a copy of src, replacing matches of the Regexp with the replacement text repl. Inside repl, $ signs are interpreted as in Expand, so for instance $1 represents the text of the first submatch.</source>
          <target state="translated">ReplaceAll 返回 src 的副本,用替换文本 repl 替换 Regexp 的匹配。在 repl 中,$ 符号的解释与 Expand 一样,所以例如 $1 代表第一个子匹配的文本。</target>
        </trans-unit>
        <trans-unit id="506447353e7b3822dcf4613a0f93ab71e29d1735" translate="yes" xml:space="preserve">
          <source>ReplaceAll returns a copy of the slice s with all non-overlapping instances of old replaced by new. If old is empty, it matches at the beginning of the slice and after each UTF-8 sequence, yielding up to k+1 replacements for a k-rune slice.</source>
          <target state="translated">ReplaceAll 返回一个片断 s 的副本,其中所有非重叠的 old 实例被 new 替换。如果 old 是空的,它就会在片断的开头和每个 UTF-8 序列之后进行匹配,产生 k-rune 片断的最多 k+1 次替换。</target>
        </trans-unit>
        <trans-unit id="435dc323288417e80211f8927c3695e3ce359257" translate="yes" xml:space="preserve">
          <source>ReplaceAll returns a copy of the string s with all non-overlapping instances of old replaced by new. If old is empty, it matches at the beginning of the string and after each UTF-8 sequence, yielding up to k+1 replacements for a k-rune string.</source>
          <target state="translated">ReplaceAll 返回字符串 s 的副本,并将所有非重叠的 old 实例替换为 new。如果 old 为空,则在字符串的开头和每个 UTF-8 序列之后进行匹配,对 k-rune 字符串进行最多 k+1 次替换。</target>
        </trans-unit>
        <trans-unit id="3d66ecd6da17fab5c8cd96769f904257ef13a398" translate="yes" xml:space="preserve">
          <source>ReplaceAllFunc returns a copy of src in which all matches of the Regexp have been replaced by the return value of function repl applied to the matched byte slice. The replacement returned by repl is substituted directly, without using Expand.</source>
          <target state="translated">ReplaceAllFunc 返回 src 的副本,其中所有匹配的 Regexp 都已被应用于匹配的字节片的函数 repl 的返回值替换。repl返回的替换值是直接替换的,不使用Expand。</target>
        </trans-unit>
        <trans-unit id="2a17131c7994cd05d7daea07beea0ef31e257581" translate="yes" xml:space="preserve">
          <source>ReplaceAllLiteral returns a copy of src, replacing matches of the Regexp with the replacement bytes repl. The replacement repl is substituted directly, without using Expand.</source>
          <target state="translated">ReplaceAllLiteral 返回 src 的副本,将 Regexp 的匹配项替换为替换字节 repl。替换后的 repl 是直接替换的,不使用 Expand。</target>
        </trans-unit>
        <trans-unit id="87232f03b040c072f8f75219db9d85c61ff38e7c" translate="yes" xml:space="preserve">
          <source>ReplaceAllLiteralString returns a copy of src, replacing matches of the Regexp with the replacement string repl. The replacement repl is substituted directly, without using Expand.</source>
          <target state="translated">ReplaceAllLiteralString 返回 src 的副本,用替换字符串 repl 替换 Regexp 的匹配项。替换后的 repl 是直接替换的,不需要使用 Expand。</target>
        </trans-unit>
        <trans-unit id="bef70f919214d0f77e4d3a42c824dfffa5202cf4" translate="yes" xml:space="preserve">
          <source>ReplaceAllString returns a copy of src, replacing matches of the Regexp with the replacement string repl. Inside repl, $ signs are interpreted as in Expand, so for instance $1 represents the text of the first submatch.</source>
          <target state="translated">ReplaceAllString 返回 src 的副本,用替换字符串 repl 替换 Regexp 的匹配。在 repl 中,$ 符号的解释与 Expand 一样,所以例如 $1 代表第一个子匹配的文本。</target>
        </trans-unit>
        <trans-unit id="a3e275047465f9460cb043d0b2093b457293bb06" translate="yes" xml:space="preserve">
          <source>ReplaceAllStringFunc returns a copy of src in which all matches of the Regexp have been replaced by the return value of function repl applied to the matched substring. The replacement returned by repl is substituted directly, without using Expand.</source>
          <target state="translated">ReplaceAllStringFunc 返回 src 的副本,其中所有匹配的 Regexp 都被应用于匹配子串的函数 repl 的返回值替换。repl返回的替换值是直接替换的,不使用Expand。</target>
        </trans-unit>
        <trans-unit id="15e8ece6d83eb79a1b1a825152f49a545610894e" translate="yes" xml:space="preserve">
          <source>Replacer replaces a list of strings with replacements. It is safe for concurrent use by multiple goroutines.</source>
          <target state="translated">Replacer用替换的方式替换一个字符串列表。它对多个goroutine的并发使用是安全的。</target>
        </trans-unit>
        <trans-unit id="5cf96ab71fbe348ef9fe46121c7813b382500496" translate="yes" xml:space="preserve">
          <source>Replacing the sign in the format with a Z triggers the ISO 8601 behavior of printing Z instead of an offset for the UTC zone. Thus:</source>
          <target state="translated">将格式中的符号替换为Z,会触发ISO 8601行为,即打印Z而不是UTC区的偏移。因此:</target>
        </trans-unit>
        <trans-unit id="4b4d5cf4e6e2109de9a6b60e939d3a3fb07ec141" translate="yes" xml:space="preserve">
          <source>ReportAllocs enables malloc statistics for this benchmark. It is equivalent to setting -test.benchmem, but it only affects the benchmark function that calls ReportAllocs.</source>
          <target state="translated">ReportAllocs 启用了这个基准的 malloc 统计。它相当于设置-test.benchmem,但它只影响调用ReportAllocs的基准函数。</target>
        </trans-unit>
        <trans-unit id="ca2f164e5206d2fe2c80e762a870dbd7b150154b" translate="yes" xml:space="preserve">
          <source>ReportMetric adds &quot;n unit&quot; to the reported benchmark results. If the metric is per-iteration, the caller should divide by b.N, and by convention units should end in &quot;/op&quot;. ReportMetric overrides any previously reported value for the same unit. ReportMetric panics if unit is the empty string or if unit contains any whitespace. If unit is a unit normally reported by the benchmark framework itself (such as &quot;allocs/op&quot;), ReportMetric will override that metric. Setting &quot;ns/op&quot; to 0 will suppress that built-in metric.</source>
          <target state="translated">ReportMetric在报告的基准结果中加入 &quot;n单位&quot;。如果度量是每迭代,调用者应该除以b.N,按照惯例单位应该以&quot;/op &quot;结尾。ReportMetric会覆盖之前报告的同一单位的任何值。如果 unit 是空字符串或者 unit 包含任何空格,ReportMetric 会感到恐慌。如果单位是基准框架本身通常报告的单位(如 &quot;allocs/op&quot;),ReportMetric将覆盖该度量。将 &quot;ns/op &quot;设置为0将抑制该内置度量。</target>
        </trans-unit>
        <trans-unit id="bbfd1ef8b32af00f36af4ce56ffc90aaec2642df" translate="yes" xml:space="preserve">
          <source>Representations of a Time value saved by the GobEncode, MarshalBinary, MarshalJSON, and MarshalText methods store the Time.Location's offset, but not the location name. They therefore lose information about Daylight Saving Time.</source>
          <target state="translated">由GobEncode、MarshalBinary、MarshalJSON和MarshalText方法保存的时间值的表示方式存储了Time.Location的偏移量,但没有存储位置名称。因此,它们失去了夏令时的信息。</target>
        </trans-unit>
        <trans-unit id="034f490ecab4d9730ca1969131b6a78b84d524bf" translate="yes" xml:space="preserve">
          <source>Request is a header written before every RPC call. It is used internally but documented here as an aid to debugging, such as when analyzing network traffic.</source>
          <target state="translated">Request是写在每次RPC调用前的头。它在内部使用,但在这里被记录下来,作为调试的辅助工具,例如在分析网络流量时。</target>
        </trans-unit>
        <trans-unit id="7fe490925acca7c7d2d43d098e092cfd78223216" translate="yes" xml:space="preserve">
          <source>Request returns the HTTP request as represented in the current environment. This assumes the current program is being run by a web server in a CGI environment. The returned Request's Body is populated, if applicable.</source>
          <target state="translated">Request返回当前环境下所代表的HTTP请求。这假定当前程序是由CGI环境下的Web服务器运行的。如果适用的话,返回的Request的Body会被填充。</target>
        </trans-unit>
        <trans-unit id="d122cdaacba1573bfe57f160ca47386cbda87132" translate="yes" xml:space="preserve">
          <source>RequestFromMap creates an http.Request from CGI variables. The returned Request's Body field is not populated.</source>
          <target state="translated">RequestFromMap通过CGI变量创建一个http.Request。返回的Request的Body字段不被填充。</target>
        </trans-unit>
        <trans-unit id="27b1cff1ae1ef7bb8ea746c0ebbfe176f573422d" translate="yes" xml:space="preserve">
          <source>RequestURI returns the encoded path?query or opaque?query string that would be used in an HTTP request for u.</source>
          <target state="translated">RequestURI返回编码的路径?query或不透明的?query字符串,该字符串将用于对u的HTTP请求。</target>
        </trans-unit>
        <trans-unit id="3b21fedf00a3371e3f28d17145c5a692c6831e7c" translate="yes" xml:space="preserve">
          <source>Reset changes the timer to expire after duration d. It returns true if the timer had been active, false if the timer had expired or been stopped.</source>
          <target state="translated">如果计时器一直处于活动状态,则返回true;如果计时器过期或停止,则返回false。</target>
        </trans-unit>
        <trans-unit id="1eaa7c3f868073620d91cca86ce9b81e6921a9e0" translate="yes" xml:space="preserve">
          <source>Reset clears the state of the Writer z such that it is equivalent to its initial state from NewWriterLevel or NewWriterLevelDict, but instead writing to w.</source>
          <target state="translated">Reset清除Writer z的状态,使其相当于NewWriterLevel或NewWriterLevelDict的初始状态,而是写到w。</target>
        </trans-unit>
        <trans-unit id="8fad0a06171db3d325d00805f309209741be9985" translate="yes" xml:space="preserve">
          <source>Reset discards any buffered data, resets all state, and switches the buffered reader to read from r.</source>
          <target state="translated">Reset丢弃任何缓冲数据,重置所有状态,并将缓冲读卡器切换为从r读取。</target>
        </trans-unit>
        <trans-unit id="ddec4089b2023a9f5966b6899a6d86b3c6ba6d0e" translate="yes" xml:space="preserve">
          <source>Reset discards any unflushed buffered data, clears any error, and resets b to write its output to w.</source>
          <target state="translated">重置会丢弃任何未刷新的缓冲数据,清除任何错误,并重置b将其输出写入w。</target>
        </trans-unit>
        <trans-unit id="0f6193249698e8c1cc414024f184ff9d63a0b799" translate="yes" xml:space="preserve">
          <source>Reset discards the Reader z's state and makes it equivalent to the result of its original state from NewReader, but reading from r instead. This permits reusing a Reader rather than allocating a new one.</source>
          <target state="translated">重置丢弃Reader z的状态,并使其等同于NewReader的原始状态的结果,但从r读取。这允许重复使用一个Reader,而不是分配一个新的Reader。</target>
        </trans-unit>
        <trans-unit id="d8366944feb20881339d2bc39051aaaff11ba2e7" translate="yes" xml:space="preserve">
          <source>Reset discards the Writer z's state and makes it equivalent to the result of its original state from NewWriter or NewWriterLevel, but writing to w instead. This permits reusing a Writer rather than allocating a new one.</source>
          <target state="translated">重置丢弃Writer z的状态,使其等同于NewWriter或NewWriterLevel的原始状态的结果,但写到w。这允许重复使用一个Writer,而不是分配一个新的Writer。</target>
        </trans-unit>
        <trans-unit id="1192ba3cfdd5644c337b189600cac9374ed9f399" translate="yes" xml:space="preserve">
          <source>Reset discards the writer's state and makes it equivalent to the result of NewWriter or NewWriterDict called with dst and w's level and dictionary.</source>
          <target state="translated">Reset会丢弃writer的状态,并使其等同于用dst和w的级别和字典调用NewWriter或NewWriterDict的结果。</target>
        </trans-unit>
        <trans-unit id="f44016b53cb6e5efb7b07f97bdd7a58a3f9acd27" translate="yes" xml:space="preserve">
          <source>Reset repositions the line table reader at the beginning of the line table.</source>
          <target state="translated">重置将行表阅读器重新放置在行表的开头。</target>
        </trans-unit>
        <trans-unit id="fc5e1e89a723101da37c5f7cdde61464338d0205" translate="yes" xml:space="preserve">
          <source>Reset resets an ErrorList to no errors.</source>
          <target state="translated">Reset将ErrorList重置为无错误。</target>
        </trans-unit>
        <trans-unit id="06a254b1693f024953c4504eb0ab4b1efccfe485" translate="yes" xml:space="preserve">
          <source>Reset resets the Builder to be empty.</source>
          <target state="translated">重置将生成器重置为空。</target>
        </trans-unit>
        <trans-unit id="e5afd25b08aea0811ed90f3f30191e4fc43f9115" translate="yes" xml:space="preserve">
          <source>Reset resets the Reader to be reading from b.</source>
          <target state="translated">重置将阅读器重置为从b处读取。</target>
        </trans-unit>
        <trans-unit id="15670331b1298dacd5ea205176b1269922b3d2b5" translate="yes" xml:space="preserve">
          <source>Reset resets the Reader to be reading from s.</source>
          <target state="translated">重置将阅读器重置为从s读取。</target>
        </trans-unit>
        <trans-unit id="170c10bab8e54e5cf030eb670497e5196563378e" translate="yes" xml:space="preserve">
          <source>Reset resets the buffer to be empty, but it retains the underlying storage for use by future writes. Reset is the same as Truncate(0).</source>
          <target state="translated">Reset将缓冲区重置为空,但它保留了底层的存储空间,供将来的写入使用。重置与Truncate(0)相同。</target>
        </trans-unit>
        <trans-unit id="1cf78ba3d25ca4518fc926a9a64e46d873a5c2b0" translate="yes" xml:space="preserve">
          <source>Reset sends the RSET command to the server, aborting the current mail transaction.</source>
          <target state="translated">重置将RSET命令发送到服务器,中止当前的邮件事务。</target>
        </trans-unit>
        <trans-unit id="a8bd7c2aca0a58855a450ef3c393b7f8dd845541" translate="yes" xml:space="preserve">
          <source>Reset should be invoked only on stopped or expired timers with drained channels. If a program has already received a value from t.C, the timer is known to have expired and the channel drained, so t.Reset can be used directly. If a program has not yet received a value from t.C, however, the timer must be stopped and&amp;mdash;if Stop reports that the timer expired before being stopped&amp;mdash;the channel explicitly drained:</source>
          <target state="translated">只能在通道耗尽的停止或到期计时器上调用复位。如果程序已经从tC接收到一个值，则已知计时器已到期且通道已耗尽，因此可以直接使用t.Reset。但是，如果程序尚未从tC接收到值，则必须停止计时器，并且-如果Stop报告计时器在停止之前已到期，则该通道将被清空：</target>
        </trans-unit>
        <trans-unit id="c62db3fae7c3e711fbf34aadc1b1afc1b9253c1a" translate="yes" xml:space="preserve">
          <source>Reset undoes the effect of any prior calls to Notify for the provided signals. If no signals are provided, all signal handlers will be reset.</source>
          <target state="translated">重置会撤销之前对所提供信号的任何通知调用的效果。如果没有提供信号,所有信号处理程序将被重置。</target>
        </trans-unit>
        <trans-unit id="27fa1b9793c51dfd946a69a14c0ddb57c10ad547" translate="yes" xml:space="preserve">
          <source>Reset zeros the key data and makes the Cipher unusable.</source>
          <target state="translated">重置将密钥数据清零,使密码无法使用。</target>
        </trans-unit>
        <trans-unit id="f310c59e5a0084054073df7b5f573d812cdd0fd8" translate="yes" xml:space="preserve">
          <source>ResetTimer zeroes the elapsed benchmark time and memory allocation counters and deletes user-reported metrics. It does not affect whether the timer is running.</source>
          <target state="translated">ResetTimer 将经过的基准时间和内存分配计数器归零,并删除用户报告的指标。它不影响定时器是否在运行。</target>
        </trans-unit>
        <trans-unit id="33ee9712ca346c749995f4d74bcd18ae6c0b0650" translate="yes" xml:space="preserve">
          <source>Resetter resets a ReadCloser returned by NewReader or NewReaderDict to switch to a new underlying Reader. This permits reusing a ReadCloser instead of allocating a new one.</source>
          <target state="translated">Resetter重置由NewReader或NewReaderDict返回的ReadCloser,以切换到一个新的底层Reader。这允许重复使用一个ReadCloser,而不是分配一个新的ReadCloser。</target>
        </trans-unit>
        <trans-unit id="7007d754cde94120e44343157ab76b14a831c26c" translate="yes" xml:space="preserve">
          <source>ResolveIPAddr returns an address of IP end point.</source>
          <target state="translated">ResolveIPAddr返回一个IP端点的地址。</target>
        </trans-unit>
        <trans-unit id="07b69306928a5a3a0b8c2314c2531e10de93c9cf" translate="yes" xml:space="preserve">
          <source>ResolveReference resolves a URI reference to an absolute URI from an absolute base URI u, per RFC 3986 Section 5.2. The URI reference may be relative or absolute. ResolveReference always returns a new URL instance, even if the returned URL is identical to either the base or reference. If ref is an absolute URL, then ResolveReference ignores base and returns a copy of ref.</source>
          <target state="translated">ResolveReference 根据 RFC 3986 第 5.2 节的规定,将 URI 引用从一个绝对的基本 URI u 解析为一个绝对的 URI。URI引用可以是相对的或绝对的。ResolveReference 总是返回一个新的 URL 实例,即使返回的 URL 与 base 或 reference 相同。如果ref是一个绝对的URL,那么ResolveReference会忽略base,并返回ref的副本。</target>
        </trans-unit>
        <trans-unit id="3273804861eaad79df80c3d22cf109398eb595c4" translate="yes" xml:space="preserve">
          <source>ResolveTCPAddr returns an address of TCP end point.</source>
          <target state="translated">ResolveTCPAddr 返回 TCP 端点的地址。</target>
        </trans-unit>
        <trans-unit id="d940491c716336f4aaf080189bdb0c28cf1b6ec4" translate="yes" xml:space="preserve">
          <source>ResolveUDPAddr returns an address of UDP end point.</source>
          <target state="translated">ResolveUDPAddr返回UDP端点的地址。</target>
        </trans-unit>
        <trans-unit id="2928800c224397786b541e4886439dcdc0ecfc66" translate="yes" xml:space="preserve">
          <source>ResolveUnixAddr returns an address of Unix domain socket end point.</source>
          <target state="translated">ResolveUnixAddr返回Unix域套接字端点的地址。</target>
        </trans-unit>
        <trans-unit id="3dd3f1ec80ee28cb3dd53e5b932daca2d3fdd951" translate="yes" xml:space="preserve">
          <source>Response is a header written before every RPC return. It is used internally but documented here as an aid to debugging, such as when analyzing network traffic.</source>
          <target state="translated">Response是写在每个RPC返回之前的头。它在内部使用,但在这里被记录下来,作为调试的辅助工具,例如在分析网络流量时。</target>
        </trans-unit>
        <trans-unit id="78fa8e7076763a708a759f35e6fdf9c8c2792c3e" translate="yes" xml:space="preserve">
          <source>Response represents the response from an HTTP request.</source>
          <target state="translated">Response表示HTTP请求的响应。</target>
        </trans-unit>
        <trans-unit id="2c870a02afd7772b1a5c1104af64d975949d9837" translate="yes" xml:space="preserve">
          <source>ResponseRecorder</source>
          <target state="translated">ResponseRecorder</target>
        </trans-unit>
        <trans-unit id="294d856644ce3293fbb784b42f79f661b3d60595" translate="yes" xml:space="preserve">
          <source>ResponseRecorder is an implementation of http.ResponseWriter that records its mutations for later inspection in tests.</source>
          <target state="translated">ResponseRecorder 是 http.ResponseWriter 的一个实现,它记录了它的突变,以便以后在测试中检查。</target>
        </trans-unit>
        <trans-unit id="d0d0da2350df38e89f18eec0c8c277a390ef8032" translate="yes" xml:space="preserve">
          <source>ResponseWriter (Trailers)</source>
          <target state="translated">回應作家 (預告)</target>
        </trans-unit>
        <trans-unit id="3f9f60a3d963394dba2b9af5ad21d7cf9b8efc40" translate="yes" xml:space="preserve">
          <source>Responses with status codes in the 1xx range are either handled automatically (100 expect-continue) or ignored. The one exception is HTTP status code 101 (Switching Protocols), which is considered a terminal status and returned by RoundTrip. To see the ignored 1xx responses, use the httptrace trace package's ClientTrace.Got1xxResponse.</source>
          <target state="translated">状态码在1xx范围内的响应,要么自动处理(100期待-继续),要么忽略。唯一的例外是HTTP状态码101(Switching Protocols),它被认为是终端状态,并由RoundTrip返回。要查看被忽略的1xx响应,请使用httptrace跟踪包的ClientTrace.Got1xxResponse。</target>
        </trans-unit>
        <trans-unit id="c92c6b4dd981d78fca3ec0b5b13d22c3c7e3c9ff" translate="yes" xml:space="preserve">
          <source>Result is the result of a query execution.</source>
          <target state="translated">结果是查询执行的结果。</target>
        </trans-unit>
        <trans-unit id="1f4d7bab508f22f797e449d5f6998b16e4434cbe" translate="yes" xml:space="preserve">
          <source>Result must only be called after the handler has finished running.</source>
          <target state="translated">Result必须在处理程序运行结束后才能被调用。</target>
        </trans-unit>
        <trans-unit id="1b5febf7558713f1ecb2fbd2c227fbc55af9bbed" translate="yes" xml:space="preserve">
          <source>Result returns the response generated by the handler.</source>
          <target state="translated">Result返回处理程序产生的响应。</target>
        </trans-unit>
        <trans-unit id="2d5559e8af761fd8963b92d10b52cc8627380cc7" translate="yes" xml:space="preserve">
          <source>ResultNoRows is a pre-defined Result for drivers to return when a DDL command (such as a CREATE TABLE) succeeds. It returns an error for both LastInsertId and RowsAffected.</source>
          <target state="translated">ResultNoRows是一个预先定义的结果,当DDL命令(如CREATE TABLE)成功时,驱动程序将返回这个结果。它对LastInsertId和RowsAffected都返回一个错误。</target>
        </trans-unit>
        <trans-unit id="c3b838adfac99fd155c663831ad38556581e0407" translate="yes" xml:space="preserve">
          <source>Results returns the results of signature s, or nil.</source>
          <target state="translated">结果返回签名s的结果,或者nil。</target>
        </trans-unit>
        <trans-unit id="962f14cb7eca51d5151fcfbeb4ab3ed937db54aa" translate="yes" xml:space="preserve">
          <source>Return the most recent call to Scan as a []byte.</source>
          <target state="translated">以[]字节的形式返回最近一次对Scan的调用。</target>
        </trans-unit>
        <trans-unit id="57f9933768794f845d000833d367d5698393211d" translate="yes" xml:space="preserve">
          <source>Reverse</source>
          <target state="translated">Reverse</target>
        </trans-unit>
        <trans-unit id="902e55a122fa4891a6dae083e18230ea968dc9a3" translate="yes" xml:space="preserve">
          <source>Reverse returns the reverse order for data.</source>
          <target state="translated">Reverse返回数据的相反顺序。</target>
        </trans-unit>
        <trans-unit id="78b0b4cb759dec2da3c6713767fbf6f4bc040c4d" translate="yes" xml:space="preserve">
          <source>Reverse returns the value of x with its bits in reversed order.</source>
          <target state="translated">反向返回x的值,并将其位数反过来。</target>
        </trans-unit>
        <trans-unit id="92de4737778eb41e55ca2f7a627a47fd6ba4a889" translate="yes" xml:space="preserve">
          <source>Reverse16</source>
          <target state="translated">Reverse16</target>
        </trans-unit>
        <trans-unit id="b383f837c66d7bdba479cd898a8ff90df6a54bdc" translate="yes" xml:space="preserve">
          <source>Reverse16 returns the value of x with its bits in reversed order.</source>
          <target state="translated">Reverse16返回x的值,其位数的顺序是相反的。</target>
        </trans-unit>
        <trans-unit id="bc5bc5fb62f24a53fcf7486ea47cb526c49ed16b" translate="yes" xml:space="preserve">
          <source>Reverse32</source>
          <target state="translated">Reverse32</target>
        </trans-unit>
        <trans-unit id="31e983ab5d2fdae281f62da27af16c6410c88366" translate="yes" xml:space="preserve">
          <source>Reverse32 returns the value of x with its bits in reversed order.</source>
          <target state="translated">Reverse32返回x的值,其位数的顺序是相反的。</target>
        </trans-unit>
        <trans-unit id="4b8d738bc3f5b572852bef49d9d1b74649451478" translate="yes" xml:space="preserve">
          <source>Reverse64</source>
          <target state="translated">Reverse64</target>
        </trans-unit>
        <trans-unit id="0a95ddc6b008b1c60668050345ad2bbd0048d26d" translate="yes" xml:space="preserve">
          <source>Reverse64 returns the value of x with its bits in reversed order.</source>
          <target state="translated">Reverse64返回x的值,其位数顺序相反。</target>
        </trans-unit>
        <trans-unit id="8b7d623b04231c73d009937cc199213fab60a116" translate="yes" xml:space="preserve">
          <source>Reverse8</source>
          <target state="translated">Reverse8</target>
        </trans-unit>
        <trans-unit id="4e2cfa80f1f3211b8d7b8f97b9c866dc8e5602ee" translate="yes" xml:space="preserve">
          <source>Reverse8 returns the value of x with its bits in reversed order.</source>
          <target state="translated">Reverse8返回x的值,其位数的顺序是相反的。</target>
        </trans-unit>
        <trans-unit id="be39e968e6f8b02161cf145a91c2242f8ac3e738" translate="yes" xml:space="preserve">
          <source>ReverseBytes returns the value of x with its bytes in reversed order.</source>
          <target state="translated">ReverseBytes返回x的值,并将其字节顺序颠倒。</target>
        </trans-unit>
        <trans-unit id="b3a8220fbdce3c882a295efbc513cc8d73cb1a7a" translate="yes" xml:space="preserve">
          <source>ReverseBytes16</source>
          <target state="translated">ReverseBytes16</target>
        </trans-unit>
        <trans-unit id="2a7c652af5267d559395a2d601cef862d0dc08f3" translate="yes" xml:space="preserve">
          <source>ReverseBytes16 returns the value of x with its bytes in reversed order.</source>
          <target state="translated">ReverseBytes16返回x的值,并以相反的顺序返回其字节。</target>
        </trans-unit>
        <trans-unit id="0b3b6869428b45a4008a611a88e1d858c7f82ca5" translate="yes" xml:space="preserve">
          <source>ReverseBytes32</source>
          <target state="translated">ReverseBytes32</target>
        </trans-unit>
        <trans-unit id="bd4bbc4dc35b34c8851580c4ed26f1553540d805" translate="yes" xml:space="preserve">
          <source>ReverseBytes32 returns the value of x with its bytes in reversed order.</source>
          <target state="translated">ReverseBytes32返回x的值,并以相反的顺序返回其字节。</target>
        </trans-unit>
        <trans-unit id="27b3c718307e25ebd0df6355d5ba2181fe72066f" translate="yes" xml:space="preserve">
          <source>ReverseBytes64</source>
          <target state="translated">ReverseBytes64</target>
        </trans-unit>
        <trans-unit id="2bfe4d5fab882bedb4ed52db5659be4b630cad79" translate="yes" xml:space="preserve">
          <source>ReverseBytes64 returns the value of x with its bytes in reversed order.</source>
          <target state="translated">ReverseBytes64返回x的值,并以相反的顺序返回其字节。</target>
        </trans-unit>
        <trans-unit id="08e888d81afdf833be45fe65662c8198e86a5832" translate="yes" xml:space="preserve">
          <source>ReverseProxy</source>
          <target state="translated">ReverseProxy</target>
        </trans-unit>
        <trans-unit id="9bfcf9ccffddea8678782d891a9bd8387a2cdb0f" translate="yes" xml:space="preserve">
          <source>ReverseProxy is an HTTP Handler that takes an incoming request and sends it to another server, proxying the response back to the client.</source>
          <target state="translated">ReverseProxy是一个HTTP处理程序,它接收一个传入的请求并将其发送到另一个服务器,将响应代理回客户端。</target>
        </trans-unit>
        <trans-unit id="36bf57062b0695082d5c3ab1cea707663eb8d688" translate="yes" xml:space="preserve">
          <source>RevokedCertificate represents the ASN.1 structure of the same name. See RFC 5280, section 5.1.</source>
          <target state="translated">RevokedCertificate表示同名的ASN.1结构。参见RFC 5280,5.1节。</target>
        </trans-unit>
        <trans-unit id="1dbb08e5127fb312affa46a438163965fc7ebf23" translate="yes" xml:space="preserve">
          <source>RightAlign returns a slice where the padding bits are at the beginning. The slice may share memory with the BitString.</source>
          <target state="translated">RightAlign 返回一个填充位在开头的分片。该分片可以与BitString共享内存。</target>
        </trans-unit>
        <trans-unit id="86681d4d51562a20e98b2b7ff856763c761235e0" translate="yes" xml:space="preserve">
          <source>Ring.Do</source>
          <target state="translated">Ring.Do</target>
        </trans-unit>
        <trans-unit id="c3de3d65f1bf374c9d07b4dfcda75c2206063f2b" translate="yes" xml:space="preserve">
          <source>Ring.Len</source>
          <target state="translated">Ring.Len</target>
        </trans-unit>
        <trans-unit id="ef738e03a934b3cea0ed8b70a7545fe51b5d290c" translate="yes" xml:space="preserve">
          <source>Ring.Link</source>
          <target state="translated">Ring.Link</target>
        </trans-unit>
        <trans-unit id="7fd8ab417197e9dee9db859427b5d7f544203d42" translate="yes" xml:space="preserve">
          <source>Ring.Move</source>
          <target state="translated">Ring.Move</target>
        </trans-unit>
        <trans-unit id="0851656843c7ec1e30ec39e3f0f5e84ae6a75fcd" translate="yes" xml:space="preserve">
          <source>Ring.Next</source>
          <target state="translated">Ring.Next</target>
        </trans-unit>
        <trans-unit id="61b297ba7e636a60d4221303b63f5d9cc41422d9" translate="yes" xml:space="preserve">
          <source>Ring.Prev</source>
          <target state="translated">Ring.Prev</target>
        </trans-unit>
        <trans-unit id="d7d905b26d8d9e9d4ae570e8e8161e643805b969" translate="yes" xml:space="preserve">
          <source>Ring.Unlink</source>
          <target state="translated">Ring.Unlink</target>
        </trans-unit>
        <trans-unit id="1a9da6de639f9bb2699bfe42d158358d7d6e5dc9" translate="yes" xml:space="preserve">
          <source>Rollback aborts the transaction.</source>
          <target state="translated">回滚中止交易。</target>
        </trans-unit>
        <trans-unit id="b1d06a98df3a5bd7537bc07af57648fbe210073d" translate="yes" xml:space="preserve">
          <source>RotateLeft returns the value of x rotated left by (k mod UintSize) bits. To rotate x right by k bits, call RotateLeft(x, -k).</source>
          <target state="translated">RotateLeft 返回 x 向左旋转 (k mod UintSize)位的值。要将 x 向右旋转 k 位,调用 RotateLeft(x,-k)。</target>
        </trans-unit>
        <trans-unit id="761f01b6be4cc6f5188ea10477b0dc7cd1161d8c" translate="yes" xml:space="preserve">
          <source>RotateLeft16</source>
          <target state="translated">RotateLeft16</target>
        </trans-unit>
        <trans-unit id="d66c06db349417bfddd607ad14fa9bf5a5638d62" translate="yes" xml:space="preserve">
          <source>RotateLeft16 returns the value of x rotated left by (k mod 16) bits. To rotate x right by k bits, call RotateLeft16(x, -k).</source>
          <target state="translated">RotateLeft16 返回 x 向左旋转了 (k mod 16)位的值。要将x向右旋转k位,调用RotateLeft16(x,-k)。</target>
        </trans-unit>
        <trans-unit id="60bcbc4fb2bbce0ec43078cea8be747ff9281e19" translate="yes" xml:space="preserve">
          <source>RotateLeft32</source>
          <target state="translated">RotateLeft32</target>
        </trans-unit>
        <trans-unit id="c60016746c6ad6b197ec5092101071fc87f7021a" translate="yes" xml:space="preserve">
          <source>RotateLeft32 returns the value of x rotated left by (k mod 32) bits. To rotate x right by k bits, call RotateLeft32(x, -k).</source>
          <target state="translated">RotateLeft32 返回 x 向左旋转了 (k mod 32)位的值。要将x向右旋转k位,调用RotateLeft32(x,-k)。</target>
        </trans-unit>
        <trans-unit id="6dc01719e1f445b08ee2ebc7136ef6822502932a" translate="yes" xml:space="preserve">
          <source>RotateLeft64</source>
          <target state="translated">RotateLeft64</target>
        </trans-unit>
        <trans-unit id="c0ff555090cb3bc9a90815cda1f96719ce3d40be" translate="yes" xml:space="preserve">
          <source>RotateLeft64 returns the value of x rotated left by (k mod 64) bits. To rotate x right by k bits, call RotateLeft64(x, -k).</source>
          <target state="translated">RotateLeft64 返回 x 向左旋转了 (k mod 64)位的值。要将x向右旋转k位,调用RotateLeft64(x,-k)。</target>
        </trans-unit>
        <trans-unit id="fdef633274845494879cbf0afeac8f854e3ba879" translate="yes" xml:space="preserve">
          <source>RotateLeft8</source>
          <target state="translated">RotateLeft8</target>
        </trans-unit>
        <trans-unit id="26ebe86c57d1d128d3a27bb9fd4358573f445da7" translate="yes" xml:space="preserve">
          <source>RotateLeft8 returns the value of x rotated left by (k mod 8) bits. To rotate x right by k bits, call RotateLeft8(x, -k).</source>
          <target state="translated">RotateLeft8 返回 x 向左旋转了 (k mod 8)位的值。要将x向右旋转k位,调用RotateLeft8(x,-k)。</target>
        </trans-unit>
        <trans-unit id="ec7b59833520bb2b53fd4d44b3d581720b55c442" translate="yes" xml:space="preserve">
          <source>Round</source>
          <target state="translated">Round</target>
        </trans-unit>
        <trans-unit id="000868eccd1432acf77f6949a96b4844d59b1fce" translate="yes" xml:space="preserve">
          <source>Round operates on the time as an absolute duration since the zero time; it does not operate on the presentation form of the time. Thus, Round(Hour) may return a time with a non-zero minute, depending on the time's Location.</source>
          <target state="translated">Round对时间的操作是指从零点开始的绝对持续时间;它不对时间的表现形式进行操作。因此,Round(Hour)可能会返回一个非零分钟的时间,这取决于时间的位置。</target>
        </trans-unit>
        <trans-unit id="b948ea2f553b57093a9dabad37c8d45230573ca2" translate="yes" xml:space="preserve">
          <source>Round returns the nearest integer, rounding half away from zero.</source>
          <target state="translated">Round 返回最接近的整数,从零开始四舍五入。</target>
        </trans-unit>
        <trans-unit id="09b508228bc941d31ad58d40d683a414360f74b0" translate="yes" xml:space="preserve">
          <source>Round returns the result of rounding d to the nearest multiple of m. The rounding behavior for halfway values is to round away from zero. If the result exceeds the maximum (or minimum) value that can be stored in a Duration, Round returns the maximum (or minimum) duration. If m &amp;lt;= 0, Round returns d unchanged.</source>
          <target state="translated">舍入运算将d舍入到m的最接近倍数的结果。中途值的舍入行为是从零舍入。如果结果超过可以在&amp;ldquo;持续时间&amp;rdquo;中存储的最大（或最小）值，则&amp;ldquo;回合&amp;rdquo;返回最大（或最小）持续时间。如果m &amp;lt;= 0，则Round返回d不变。</target>
        </trans-unit>
        <trans-unit id="46948003a0f2b7ed98f113a7c6a561fd40784b4d" translate="yes" xml:space="preserve">
          <source>Round returns the result of rounding t to the nearest multiple of d (since the zero time). The rounding behavior for halfway values is to round up. If d &amp;lt;= 0, Round returns t stripped of any monotonic clock reading but otherwise unchanged.</source>
          <target state="translated">舍入运算将t舍入到d的最接近倍数（从零开始）的结果。中途值的舍入行为是向上舍入。如果d &amp;lt;= 0，则Round返回t，去除了任何单调时钟读数，但未更改。</target>
        </trans-unit>
        <trans-unit id="bd8a6768cc1684f5b293529415380ca31ee44b5b" translate="yes" xml:space="preserve">
          <source>RoundToEven</source>
          <target state="translated">RoundToEven</target>
        </trans-unit>
        <trans-unit id="721a33257fa34d285056f870605bb51c3b9a00a0" translate="yes" xml:space="preserve">
          <source>RoundToEven returns the nearest integer, rounding ties to even.</source>
          <target state="translated">RoundToEven 返回最接近的整数,四舍五入为偶数。</target>
        </trans-unit>
        <trans-unit id="31fa67ead55ff94cd48d5e48d25e6ab30cbcca05" translate="yes" xml:space="preserve">
          <source>RoundTrip implements the RoundTripper interface.</source>
          <target state="translated">RoundTrip实现了RoundTripper接口。</target>
        </trans-unit>
        <trans-unit id="aef4d01bc99ecc3d07fd6dbc9d4b0127aaa57cd4" translate="yes" xml:space="preserve">
          <source>RoundTripper is an interface representing the ability to execute a single HTTP transaction, obtaining the Response for a given Request.</source>
          <target state="translated">RoundTripper是一个接口,代表执行单个HTTP事务的能力,为给定的Request获取Response。</target>
        </trans-unit>
        <trans-unit id="14ab950eb98caa165c8e3b8a580c9eeda3c87fc0" translate="yes" xml:space="preserve">
          <source>RoundingMode</source>
          <target state="translated">RoundingMode</target>
        </trans-unit>
        <trans-unit id="e0448d85da96897c679953ae05b1d33acf337b63" translate="yes" xml:space="preserve">
          <source>RoundingMode determines how a Float value is rounded to the desired precision. Rounding may change the Float value; the rounding error is described by the Float's Accuracy.</source>
          <target state="translated">RoundingMode决定如何将Float值四舍五入到所需精度。四舍五入可能会改变Float值;四舍五入错误由Float的Accuracy描述。</target>
        </trans-unit>
        <trans-unit id="b1898ce5b72c9fe9acbd96617227555ca58001da" translate="yes" xml:space="preserve">
          <source>Row is the result of calling QueryRow to select a single row.</source>
          <target state="translated">Row是调用QueryRow选择单行的结果。</target>
        </trans-unit>
        <trans-unit id="52d0b35277ee4b2b66ec4016620c658d99c7b57a" translate="yes" xml:space="preserve">
          <source>Rows</source>
          <target state="translated">Rows</target>
        </trans-unit>
        <trans-unit id="40bc6f7b056d7162e958bb7c34f2141aad10960f" translate="yes" xml:space="preserve">
          <source>Rows are always in order of increasing entry.Address, but entry.Line may go forward or backward.</source>
          <target state="translated">行总是按递增的顺序录入.地址,但录入.行可以向前或向后。</target>
        </trans-unit>
        <trans-unit id="136224253b0a1cede998fd8310adbf37059cd8b9" translate="yes" xml:space="preserve">
          <source>Rows is an iterator over an executed query's results.</source>
          <target state="translated">Rows是执行查询结果的迭代器。</target>
        </trans-unit>
        <trans-unit id="5bf0da8d1e143c858970004b1d4e4fc2c3190c46" translate="yes" xml:space="preserve">
          <source>Rows is the result of a query. Its cursor starts before the first row of the result set. Use Next to advance from row to row.</source>
          <target state="translated">Rows是一个查询的结果。它的光标开始于结果集的第一行之前。使用 &quot;下一步 &quot;可以从一行前进到另一行。</target>
        </trans-unit>
        <trans-unit id="c7e43ca77abe23e5cf32ea7c3a359b9f55d612a0" translate="yes" xml:space="preserve">
          <source>RowsAffected implements Result for an INSERT or UPDATE operation which mutates a number of rows.</source>
          <target state="translated">RowsAffected实现了一个INSERT或UPDATE操作的Result,该操作会对一些行进行突变。</target>
        </trans-unit>
        <trans-unit id="ef8ccf0ef3b6629b0198be9228cd5d4456951fd1" translate="yes" xml:space="preserve">
          <source>RowsColumnTypeDatabaseTypeName may be implemented by Rows. It should return the database system type name without the length. Type names should be uppercase. Examples of returned types: &quot;VARCHAR&quot;, &quot;NVARCHAR&quot;, &quot;VARCHAR2&quot;, &quot;CHAR&quot;, &quot;TEXT&quot;, &quot;DECIMAL&quot;, &quot;SMALLINT&quot;, &quot;INT&quot;, &quot;BIGINT&quot;, &quot;BOOL&quot;, &quot;[]BIGINT&quot;, &quot;JSONB&quot;, &quot;XML&quot;, &quot;TIMESTAMP&quot;.</source>
          <target state="translated">RowsColumnTypeDatabaseTypeName可以由Rows实现。它应该返回不含长度的数据库系统类型名。类型名应该是大写的。返回类型的例子。&quot;VARCHAR&quot;、&quot;NVARCHAR&quot;、&quot;VARCHAR2&quot;、&quot;CHAR&quot;、&quot;TEXT&quot;、&quot;DECIMAL&quot;、&quot;SMALLINT&quot;、&quot;INT&quot;、&quot;BIGINT&quot;、&quot;BOOL&quot;、&quot;[]BIGINT&quot;、&quot;JSONB&quot;、&quot;XML&quot;、&quot;TIMESTAMP&quot;。</target>
        </trans-unit>
        <trans-unit id="3c91b4c84603ef829584c3342618f9e341f34eef" translate="yes" xml:space="preserve">
          <source>RowsColumnTypeLength may be implemented by Rows. It should return the length of the column type if the column is a variable length type. If the column is not a variable length type ok should return false. If length is not limited other than system limits, it should return math.MaxInt64. The following are examples of returned values for various types:</source>
          <target state="translated">RowsColumnTypeLength可以由Rows实现。如果该列是可变长度类型,它应该返回该列类型的长度。如果列不是可变长度类型ok应该返回false。如果长度除了系统限制之外没有其他限制,它应该返回math.MaxInt64。下面是各种类型的返回值的例子。</target>
        </trans-unit>
        <trans-unit id="e25b9be843083730384947899329e16d7e8ce2ee" translate="yes" xml:space="preserve">
          <source>RowsColumnTypeNullable may be implemented by Rows. The nullable value should be true if it is known the column may be null, or false if the column is known to be not nullable. If the column nullability is unknown, ok should be false.</source>
          <target state="translated">RowsColumnTypeNullable可以由Rows实现。如果知道该列可能为空,则nullable值应该为true,如果知道该列不可为空,则为false。如果列的可空性未知,则ok应该为false。</target>
        </trans-unit>
        <trans-unit id="11e1119cb21771faadd92c0fac63385e0fabd647" translate="yes" xml:space="preserve">
          <source>RowsColumnTypePrecisionScale may be implemented by Rows. It should return the precision and scale for decimal types. If not applicable, ok should be false. The following are examples of returned values for various types:</source>
          <target state="translated">RowsColumnTypePrecisionScale可以由Rows实现。它应该返回十进制类型的精度和比例。如果不适用,ok应该是false。下面是各种类型的返回值的例子。</target>
        </trans-unit>
        <trans-unit id="c4ef56c355e3d98c76299376ceea4adea3479a58" translate="yes" xml:space="preserve">
          <source>RowsColumnTypeScanType may be implemented by Rows. It should return the value type that can be used to scan types into. For example, the database column type &quot;bigint&quot; this should return &quot;reflect.TypeOf(int64(0))&quot;.</source>
          <target state="translated">RowsColumnTypeScanType可以由Rows实现。它应该返回可以用来扫描类型到的值类型。例如,数据库列类型 &quot;bigint &quot;这应该返回 &quot;reflect.TypeOf(int64(0))&quot;。</target>
        </trans-unit>
        <trans-unit id="7efce4893f3ac361f87721da26fe098b878a1c27" translate="yes" xml:space="preserve">
          <source>RowsNextResultSet extends the Rows interface by providing a way to signal the driver to advance to the next result set.</source>
          <target state="translated">RowsNextResultSet扩展了Rows接口,它提供了一种信号,让驱动程序前进到下一个结果集。</target>
        </trans-unit>
        <trans-unit id="1ab76c953a9e273e85fb13e73235ab1aa106b9cd" translate="yes" xml:space="preserve">
          <source>Rsh sets z = x &amp;gt;&amp;gt; n and returns z.</source>
          <target state="translated">Rsh设置z = x &amp;gt;&amp;gt; n并返回z。</target>
        </trans-unit>
        <trans-unit id="64578d8b2d51c5abcc22005302c8d44dd6d930ad" translate="yes" xml:space="preserve">
          <source>Run benchmarks f as a subbenchmark with the given name. It reports whether there were any failures.</source>
          <target state="translated">将基准f作为给定名称的子基准运行。它报告是否有任何失败。</target>
        </trans-unit>
        <trans-unit id="872b6e9fc5c925d028b4808b5136d4cf35164f22" translate="yes" xml:space="preserve">
          <source>Run does not return until parallel subtests have completed, providing a way to clean up after a group of parallel tests:</source>
          <target state="translated">在并行子测试完成之前,运行不会返回,提供了一种清理一组并行测试后的方法。</target>
        </trans-unit>
        <trans-unit id="f8c556db4b76966a7511e9f2b360cd616f36f626" translate="yes" xml:space="preserve">
          <source>Run may be called simultaneously from multiple goroutines, but all such calls must return before the outer test function for t returns.</source>
          <target state="translated">可以从多个goroutine中同时调用Run,但所有这些调用都必须在t的外部测试函数返回之前返回。</target>
        </trans-unit>
        <trans-unit id="d90bfc177fd90c93bbd1a663aa066ee65d25e1b1" translate="yes" xml:space="preserve">
          <source>Run runs f as a subtest of t called name. It runs f in a separate goroutine and blocks until f returns or calls t.Parallel to become a parallel test. Run reports whether f succeeded (or at least did not fail before calling t.Parallel).</source>
          <target state="translated">Run 将 f 作为 t 的子测试运行,称为 name。它在一个单独的goroutine中运行f,并阻塞直到f返回或调用t.Parallel成为一个并行测试。Run报告f是否成功(或者至少在调用t.Parallel之前没有失败)。</target>
        </trans-unit>
        <trans-unit id="53e0451894d3b3781ea079b9077c47afbf558128" translate="yes" xml:space="preserve">
          <source>Run runs the tests. It returns an exit code to pass to os.Exit.</source>
          <target state="translated">Run 运行测试。它返回一个退出代码,传递给 os.Exit。</target>
        </trans-unit>
        <trans-unit id="48c893a581570ffe26dfe952410c12f6cdc2e260" translate="yes" xml:space="preserve">
          <source>Run starts the specified command and waits for it to complete.</source>
          <target state="translated">运行启动指定的命令并等待其完成。</target>
        </trans-unit>
        <trans-unit id="452df5dd646b599a67dd36e4b5527c206ddf15e5" translate="yes" xml:space="preserve">
          <source>RunParallel runs a benchmark in parallel. It creates multiple goroutines and distributes b.N iterations among them. The number of goroutines defaults to GOMAXPROCS. To increase parallelism for non-CPU-bound benchmarks, call SetParallelism before RunParallel. RunParallel is usually used with the go test -cpu flag.</source>
          <target state="translated">RunParallel 以并行方式运行一个基准。它创建多个goroutine,并在它们之间分配b.N次迭代。goroutines 的数量默认为 GOMAXPROCS。要增加非CPU绑定基准的并行性,请在RunParallel之前调用SetParallelism。RunParallel 通常与 go test -cpu 标志一起使用。</target>
        </trans-unit>
        <trans-unit id="c1304d4ae46895f99bd865fe49bce5376fb7e0b6" translate="yes" xml:space="preserve">
          <source>RuneCount</source>
          <target state="translated">RuneCount</target>
        </trans-unit>
        <trans-unit id="ed1038ffbfe375ac70c3f1a1ca67f29234afffbf" translate="yes" xml:space="preserve">
          <source>RuneCount returns the number of runes in p. Erroneous and short encodings are treated as single runes of width 1 byte.</source>
          <target state="translated">RuneCount返回p中的符文数量,错误的和较短的编码将作为宽度为1字节的单个符文处理。</target>
        </trans-unit>
        <trans-unit id="78c4e1dde9ab6b8f5586f9612a115ee5d698d2fb" translate="yes" xml:space="preserve">
          <source>RuneCountInString</source>
          <target state="translated">RuneCountInString</target>
        </trans-unit>
        <trans-unit id="f740d84fa32707ddc183ab07c7c8f221a896cf18" translate="yes" xml:space="preserve">
          <source>RuneCountInString is like RuneCount but its input is a string.</source>
          <target state="translated">RuneCountInString类似于RuneCount,但它的输入是一个字符串。</target>
        </trans-unit>
        <trans-unit id="7f39387ee01e0d6561f94fb1cc196d068d979052" translate="yes" xml:space="preserve">
          <source>RuneLen</source>
          <target state="translated">RuneLen</target>
        </trans-unit>
        <trans-unit id="da827d364b8d785022152482b581a5b08129882b" translate="yes" xml:space="preserve">
          <source>RuneLen returns the number of bytes required to encode the rune. It returns -1 if the rune is not a valid value to encode in UTF-8.</source>
          <target state="translated">RuneLen 返回对符文进行编码所需的字节数。如果符文不是UTF-8编码的有效值,则返回-1。</target>
        </trans-unit>
        <trans-unit id="cf36c219da8d056dc79efd005cdbeaf40198de2a" translate="yes" xml:space="preserve">
          <source>RuneReader is the interface that wraps the ReadRune method.</source>
          <target state="translated">RuneReader是封装ReadRune方法的接口。</target>
        </trans-unit>
        <trans-unit id="8dce52bc0fa438508ccfe7940691e478794d8014" translate="yes" xml:space="preserve">
          <source>RuneScanner is the interface that adds the UnreadRune method to the basic ReadRune method.</source>
          <target state="translated">RuneScanner是在基本的ReadRune方法上增加UnreadRune方法的接口。</target>
        </trans-unit>
        <trans-unit id="48c879258018813f4ec13050feaaab65a67d910b" translate="yes" xml:space="preserve">
          <source>RuneStart</source>
          <target state="translated">RuneStart</target>
        </trans-unit>
        <trans-unit id="6b79de7db8117808de36133366c8ef414e9c5c82" translate="yes" xml:space="preserve">
          <source>RuneStart reports whether the byte could be the first byte of an encoded, possibly invalid rune. Second and subsequent bytes always have the top two bits set to 10.</source>
          <target state="translated">RuneStart报告该字节是否是一个已编码的、可能无效的符文的第一个字节。第二个和随后的字节的前两个位总是设置为10。</target>
        </trans-unit>
        <trans-unit id="6756bd3e1a442e2ce0d16a235b1d5c8c2882b1e6" translate="yes" xml:space="preserve">
          <source>Runes</source>
          <target state="translated">Runes</target>
        </trans-unit>
        <trans-unit id="9a62b7b5f90f9e424bb04160b8de2eb558ee92a9" translate="yes" xml:space="preserve">
          <source>Runes interprets s as a sequence of UTF-8-encoded code points. It returns a slice of runes (Unicode code points) equivalent to s.</source>
          <target state="translated">Runes将s解释为一个UTF-8编码的代码点序列。它返回一个与s等价的符文片(Unicode码点)。</target>
        </trans-unit>
        <trans-unit id="f5d45a3fe840544aad462798c4e4ed8942f7ef58" translate="yes" xml:space="preserve">
          <source>Running &quot;go vet&quot; can help find uses of Pointer that do not conform to these patterns, but silence from &quot;go vet&quot; is not a guarantee that the code is valid.</source>
          <target state="translated">运行 &quot;go vet &quot;可以帮助找到不符合这些模式的Pointer用法,但 &quot;go vet &quot;的沉默并不能保证代码有效。</target>
        </trans-unit>
        <trans-unit id="aeacdbd801cd3a6c88be9cbc91df0dca2b46aba8" translate="yes" xml:space="preserve">
          <source>SHA-1 is cryptographically broken and should not be used for secure applications.</source>
          <target state="translated">SHA-1在密码学上是有缺陷的,不应该用于安全应用。</target>
        </trans-unit>
        <trans-unit id="7b3caa78fa594eb19ef5d1955f9e6f4a06aac1d4" translate="yes" xml:space="preserve">
          <source>SIGPIPE</source>
          <target state="translated">SIGPIPE</target>
        </trans-unit>
        <trans-unit id="91d8535876524df724c0df972b3fd914eb03fb2f" translate="yes" xml:space="preserve">
          <source>SameFile reports whether fi1 and fi2 describe the same file. For example, on Unix this means that the device and inode fields of the two underlying structures are identical; on other systems the decision may be based on the path names. SameFile only applies to results returned by this package's Stat. It returns false in other cases.</source>
          <target state="translated">SameFile 报告 fi1 和 fi2 是否描述同一个文件。例如,在Unix上,这意味着两个底层结构的设备和inode字段是相同的;在其它系统上,可能是根据路径名来决定的。SameFile只适用于本包的Stat返回的结果。在其他情况下,它返回false。</target>
        </trans-unit>
        <trans-unit id="9f57e34c6960ba52fd743b2bc0ff1557eb707bd2" translate="yes" xml:space="preserve">
          <source>SameSite allows a server to define a cookie attribute making it impossible for the browser to send this cookie along with cross-site requests. The main goal is to mitigate the risk of cross-origin information leakage, and provide some protection against cross-site request forgery attacks.</source>
          <target state="translated">SameSite允许服务器定义一个cookie属性,使得浏览器无法在跨站请求时发送这个cookie。其主要目的是为了降低跨源信息泄露的风险,并提供一定的保护,防止跨站请求伪造攻击。</target>
        </trans-unit>
        <trans-unit id="b8abf172daab8b3ea3c6865151b033d1cd5e837c" translate="yes" xml:space="preserve">
          <source>Scan adds line information to the file added to the file set with Init. Token positions are relative to that file and thus relative to the file set.</source>
          <target state="translated">扫描将行信息添加到用Init添加到文件集的文件中。令牌位置是相对于该文件的,因此是相对于文件集的。</target>
        </trans-unit>
        <trans-unit id="e4ac4597c96634ebcbf4b7a158793f756f373f9c" translate="yes" xml:space="preserve">
          <source>Scan advances the Scanner to the next token, which will then be available through the Bytes or Text method. It returns false when the scan stops, either by reaching the end of the input or an error. After Scan returns false, the Err method will return any error that occurred during scanning, except that if it was io.EOF, Err will return nil. Scan panics if the split function returns too many empty tokens without advancing the input. This is a common error mode for scanners.</source>
          <target state="translated">扫描将扫描器推进到下一个标记,然后通过Bytes或Text方法获得该标记。当扫描停止时,它将返回false,或者是到达输入的终点,或者是出现错误。在Scan返回false后,Err方法将返回扫描过程中发生的任何错误,除了如果是io.EOF,Err将返回nil。如果拆分函数在没有推进输入的情况下返回过多的空令牌,Scan就会恐慌。这是扫描器常见的错误模式。</target>
        </trans-unit>
        <trans-unit id="19b1c6ecbd861a4833fc5e32bbb8df547210090f" translate="yes" xml:space="preserve">
          <source>Scan also converts between string and numeric types, as long as no information would be lost. While Scan stringifies all numbers scanned from numeric database columns into *string, scans into numeric types are checked for overflow. For example, a float64 with value 300 or a string with value &quot;300&quot; can scan into a uint16, but not into a uint8, though float64(255) or &quot;255&quot; can scan into a uint8. One exception is that scans of some float64 numbers to strings may lose information when stringifying. In general, scan floating point columns into *float64.</source>
          <target state="translated">扫描也可以在字符串和数字类型之间进行转换,只要不丢失信息即可。Scan将所有从数字数据库列中扫描的数字字符串化为*string,而扫描到数字类型的数字会被检查是否有溢出。例如,值为300的float64或值为 &quot;300 &quot;的字符串可以扫描成uint16,但不能扫描成uint8,不过float64(255)或 &quot;255 &quot;可以扫描成uint8。有一个例外,就是将一些浮点64数字扫描成字符串,在字符串化时可能会丢失信息。一般来说,将浮点列扫描成*float64。</target>
        </trans-unit>
        <trans-unit id="feb542d2e67b91b0880c1fd1b4cf7b50af77bd5b" translate="yes" xml:space="preserve">
          <source>Scan can also convert a cursor returned from a query, such as &quot;select cursor(select * from my_table) from dual&quot;, into a *Rows value that can itself be scanned from. The parent select query will close any cursor *Rows if the parent *Rows is closed.</source>
          <target state="translated">扫描也可以将查询返回的游标,如 &quot;select cursor(select*from my_table)from dual&quot;,转换为本身可以扫描的*Rows值。如果父级选择查询关闭了任何游标*Rows,则父级选择查询将关闭任何游标*Rows。</target>
        </trans-unit>
        <trans-unit id="48ec4d9dec15d05d875f1baa84e9dcd1d7cc9f07" translate="yes" xml:space="preserve">
          <source>Scan converts columns read from the database into the following common Go types and special types provided by the sql package:</source>
          <target state="translated">扫描将从数据库中读取的列转换为以下常见的围棋类型和sql包提供的特殊类型。</target>
        </trans-unit>
        <trans-unit id="2677a1f2dd5662fd0ec43cba40359a57293f1867" translate="yes" xml:space="preserve">
          <source>Scan copies the columns from the matched row into the values pointed at by dest. See the documentation on Rows.Scan for details. If more than one row matches the query, Scan uses the first row and discards the rest. If no row matches the query, Scan returns ErrNoRows.</source>
          <target state="translated">扫描将匹配行中的列复制到 dest 所指向的值中。详情请参见Rows.Scan的文档。如果有多条记录与查询匹配,Scan会使用第一条记录,并丢弃其余的记录。如果没有记录与查询匹配,Scan将返回ErrNoRows。</target>
        </trans-unit>
        <trans-unit id="d701545494296850286215953fde0ddf540061d1" translate="yes" xml:space="preserve">
          <source>Scan copies the columns in the current row into the values pointed at by dest. The number of values in dest must be the same as the number of columns in Rows.</source>
          <target state="translated">扫描将当前行中的列复制到 dest 指向的值中。dest中的值的数量必须与Rows中的列数相同。</target>
        </trans-unit>
        <trans-unit id="0a799e57e8d283a9aa1ec133950cd6bd3e127332" translate="yes" xml:space="preserve">
          <source>Scan implements the Scanner interface.</source>
          <target state="translated">Scan实现了Scanner接口。</target>
        </trans-unit>
        <trans-unit id="bd92cac731a36521f9119e135b2c47485aabb150" translate="yes" xml:space="preserve">
          <source>Scan is a support routine for fmt.Scanner. It accepts the formats 'e', 'E', 'f', 'F', 'g', 'G', and 'v'. All formats are equivalent.</source>
          <target state="translated">Scan 是 fmt.Scanner 的一个支持例程,它接受'e'、'E'、'f'、'F'、'g'、'G'和'v'等格式。它接受'e'、'E'、'f'、'F'、'g'、'G'和'v'等格式。所有的格式都是等价的,它可以接受'e'、'E'、'f'、'F'、'g'、'G'和'v'等格式。</target>
        </trans-unit>
        <trans-unit id="d953d557a4046bfc8df6c55ce44c304f6ff14a59" translate="yes" xml:space="preserve">
          <source>Scan is a support routine for fmt.Scanner; it sets z to the value of the scanned number. It accepts formats whose verbs are supported by fmt.Scan for floating point values, which are: 'b' (binary), 'e', 'E', 'f', 'F', 'g' and 'G'. Scan doesn't handle &amp;plusmn;Inf.</source>
          <target state="translated">扫描是fmt.Scanner的支持例程；它将z设置为扫描编号的值。它接受动词受fmt支持的格式。扫描浮点值，即：``b''（二进制），``e''，``E''，``f''，``F''，``g''和``G''。扫描不处理&amp;plusmn;Inf。</target>
        </trans-unit>
        <trans-unit id="ac6efbbbf8b516bb14977cb03cef43746936b2f5" translate="yes" xml:space="preserve">
          <source>Scan is a support routine for fmt.Scanner; it sets z to the value of the scanned number. It accepts the formats 'b' (binary), 'o' (octal), 'd' (decimal), 'x' (lowercase hexadecimal), and 'X' (uppercase hexadecimal).</source>
          <target state="translated">Scan 是 fmt.Scanner 的一个支持例程;它将 z 设置为被扫描的数字的值,它接受 'b' (二进制)、'o' (八进制)、'd' (十进制)、'x' (小写十六进制)和 'X' (大写十六进制)等格式。它接受'b'(二进制)、'o'(八进制)、'd'(十进制)、'x'(小写十六进制)和'X'(大写十六进制)等格式。</target>
        </trans-unit>
        <trans-unit id="386a7678b7de663dffac69cf7ab3e1a7092be8f9" translate="yes" xml:space="preserve">
          <source>Scan reads the next token or Unicode character from source and returns it. It only recognizes tokens t for which the respective Mode bit (1&amp;lt;&amp;lt;-t) is set. It returns EOF at the end of the source. It reports scanner errors (read and token errors) by calling s.Error, if not nil; otherwise it prints an error message to os.Stderr.</source>
          <target state="translated">扫描从源中读取下一个标记或Unicode字符并将其返回。它仅识别设置了相应的模式位（1 &amp;lt;&amp;lt;-t）的令牌t。它在源末尾返回EOF。它通过调用s.Error（如果不是nil）来报告扫描程序错误（读取和令牌错误）。否则，它会向os.Stderr打印一条错误消息。</target>
        </trans-unit>
        <trans-unit id="981608b22833d116739df1bad639bfec043f4338" translate="yes" xml:space="preserve">
          <source>Scan scans text read from standard input, storing successive space-separated values into successive arguments. Newlines count as space. It returns the number of items successfully scanned. If that is less than the number of arguments, err will report why.</source>
          <target state="translated">扫描扫描从标准输入中读取的文本,将连续的空格分隔的值存储到连续的参数中。换行也算作空格。它返回成功扫描的项目数。如果少于参数数,err将报告原因。</target>
        </trans-unit>
        <trans-unit id="9421db6432c3608ab7d6333584635bf58a2d9300" translate="yes" xml:space="preserve">
          <source>Scan scans the next token and returns the token position, the token, and its literal string if applicable. The source end is indicated by token.EOF.</source>
          <target state="translated">Scan扫描下一个token,并返回token位置、token和它的字面串(如果适用)。源端由token.EOF表示。</target>
        </trans-unit>
        <trans-unit id="b3d5e9556bfff0957b67d0485be76ef988e69293" translate="yes" xml:space="preserve">
          <source>Scan, Fscan, Sscan treat newlines in the input as spaces.</source>
          <target state="translated">扫描、Fscan、Sscan将输入中的新行视为空格。</target>
        </trans-unit>
        <trans-unit id="f2ef262aa067e44dfcde945e7bebf0433b1baaed" translate="yes" xml:space="preserve">
          <source>ScanBytes is a split function for a Scanner that returns each byte as a token.</source>
          <target state="translated">ScanBytes是Scanner的一个分割函数,它将每个字节作为一个标记返回。</target>
        </trans-unit>
        <trans-unit id="d509b35e48ef6a5d396ee01678b179a959774867" translate="yes" xml:space="preserve">
          <source>ScanLines is a split function for a Scanner that returns each line of text, stripped of any trailing end-of-line marker. The returned line may be empty. The end-of-line marker is one optional carriage return followed by one mandatory newline. In regular expression notation, it is `\r?\n`. The last non-empty line of input will be returned even if it has no newline.</source>
          <target state="translated">ScanLines 是 Scanner 的一个分割函数,用于返回每一行文本,并去掉任何尾部的行尾标记。返回的行可以是空的。行末标记是一个可选的回车符,后面是一个强制性的换行符。在正则表达式中,它是`\r?\n`。即使没有换行符,输入的最后一行非空行也会被返回。</target>
        </trans-unit>
        <trans-unit id="b4049bc82d2e16ae520fd9c175cc98d3e8214592" translate="yes" xml:space="preserve">
          <source>ScanRunes is a split function for a Scanner that returns each UTF-8-encoded rune as a token. The sequence of runes returned is equivalent to that from a range loop over the input as a string, which means that erroneous UTF-8 encodings translate to U+FFFD = &quot;\xef\xbf\xbd&quot;. Because of the Scan interface, this makes it impossible for the client to distinguish correctly encoded replacement runes from encoding errors.</source>
          <target state="translated">ScanRunes是Scanner的一个分割函数,它将每个UTF-8编码的符文作为一个标记返回。返回的符文序列相当于对输入的字符串进行范围循环,这意味着错误的UTF-8编码转化为U+FFFD=&quot;\xef\xbf\xbd&quot;。由于Scan接口的存在,这使得客户端无法区分正确编码的替换符文和编码错误。</target>
        </trans-unit>
        <trans-unit id="f4641d488fdcb83f61b3c11fd542f4c6a3c4ffa5" translate="yes" xml:space="preserve">
          <source>ScanState represents the scanner state passed to custom scanners. Scanners may do rune-at-a-time scanning or ask the ScanState to discover the next space-delimited token.</source>
          <target state="translated">ScanState表示传递给自定义扫描器的扫描器状态。扫描仪可以进行逐次扫描或要求ScanState发现下一个空间限定的标记。</target>
        </trans-unit>
        <trans-unit id="59161b57fccdcbdd902cc6d57c2979e0dc44f79e" translate="yes" xml:space="preserve">
          <source>ScanType returns a Go type suitable for scanning into using Rows.Scan. If a driver does not support this property ScanType will return the type of an empty interface.</source>
          <target state="translated">ScanType返回一个适合使用Rows.Scan扫描到的Go类型。如果一个驱动程序不支持这个属性,ScanType将返回一个空接口的类型。</target>
        </trans-unit>
        <trans-unit id="faa25d7e517bfa0b7ebed36b40faf73e8faf8ace" translate="yes" xml:space="preserve">
          <source>ScanWords is a split function for a Scanner that returns each space-separated word of text, with surrounding spaces deleted. It will never return an empty string. The definition of space is set by unicode.IsSpace.</source>
          <target state="translated">ScanWords 是 Scanner 的一个分割函数,它可以返回每个以空格分隔的文本字,并删除周围的空格。它永远不会返回一个空字符串。空格的定义由unicode.IsSpace设置。</target>
        </trans-unit>
        <trans-unit id="bc0d545831527f222a939e3851bf7f5c1605d659" translate="yes" xml:space="preserve">
          <source>Scanf scans text read from standard input, storing successive space-separated values into successive arguments as determined by the format. It returns the number of items successfully scanned. If that is less than the number of arguments, err will report why. Newlines in the input must match newlines in the format. The one exception: the verb %c always scans the next rune in the input, even if it is a space (or tab etc.) or newline.</source>
          <target state="translated">Scanf扫描从标准输入中读取的文本,将连续的空格分隔的值存储到由格式决定的连续参数中。它返回成功扫描的项目数。如果少于参数数,err将报告原因。输入中的换行必须与格式中的换行相匹配。唯一的例外是:动词%c总是扫描输入中的下一个符文,即使它是一个空格(或制表符等)或换行。</target>
        </trans-unit>
        <trans-unit id="6f640beb056a4e8e9aa6bfcd8d1f5bf1b4feaaee" translate="yes" xml:space="preserve">
          <source>Scanf, Fscanf, and Sscanf parse the arguments according to a format string, analogous to that of Printf. In the text that follows, 'space' means any Unicode whitespace character except newline.</source>
          <target state="translated">Scanf、Fscanf和Sscanf根据类似于Printf的格式字符串来解析参数。在下面的文字中,&quot;空格 &quot;是指除换行以外的任何Unicode空白字符。</target>
        </trans-unit>
        <trans-unit id="c8ed7e72e9070ffbdd1df56f018a211791f2dcc9" translate="yes" xml:space="preserve">
          <source>Scanln is similar to Scan, but stops scanning at a newline and after the final item there must be a newline or EOF.</source>
          <target state="translated">Scanln与Scan类似,但在换行处停止扫描,在最后一项后必须有一个换行或EOF。</target>
        </trans-unit>
        <trans-unit id="22a932411390fa7368633b6d040508332e0196e9" translate="yes" xml:space="preserve">
          <source>Scanln, Fscanln and Sscanln stop scanning at a newline and require that the items be followed by a newline or EOF.</source>
          <target state="translated">Scanln、Fscanln和Sscanln在换行时停止扫描,并要求在项目后面加上换行或EOF。</target>
        </trans-unit>
        <trans-unit id="01c8580ef4911b472b2f5804014f5bd82d1af7aa" translate="yes" xml:space="preserve">
          <source>Scanner (Custom)</source>
          <target state="translated">扫描仪(自定义</target>
        </trans-unit>
        <trans-unit id="1d4892a40553aaa21bb91693fe76c51b9f51e530" translate="yes" xml:space="preserve">
          <source>Scanner (EmptyFinalToken)</source>
          <target state="translated">扫描器(EmptyFinalToken)</target>
        </trans-unit>
        <trans-unit id="d1ca38099d8459b3cc3f6b48eaf9fc6b340ae9b4" translate="yes" xml:space="preserve">
          <source>Scanner (Lines)</source>
          <target state="translated">扫描仪(线)</target>
        </trans-unit>
        <trans-unit id="ab67b93c24c839ac0830f79b29ad7b412a9dc7b4" translate="yes" xml:space="preserve">
          <source>Scanner (Words)</source>
          <target state="translated">扫描仪(字数)</target>
        </trans-unit>
        <trans-unit id="2192924325d3946492271abc8671373e1f38daa1" translate="yes" xml:space="preserve">
          <source>Scanner is an interface used by Scan.</source>
          <target state="translated">Scanner是Scan使用的一个接口。</target>
        </trans-unit>
        <trans-unit id="16f1f8a9cae9f1e07478a7953ec158b0c2b03d9c" translate="yes" xml:space="preserve">
          <source>Scanner is implemented by any value that has a Scan method, which scans the input for the representation of a value and stores the result in the receiver, which must be a pointer to be useful. The Scan method is called for any argument to Scan, Scanf, or Scanln that implements it.</source>
          <target state="translated">Scanner是由任何有Scan方法的值实现的,它扫描输入的值的表示,并将结果存储在接收器中,接收器必须是一个指针才有用。任何实现Scan、Scanf或Scanln的参数都会调用Scan方法。</target>
        </trans-unit>
        <trans-unit id="76f47cb3079e4595ce1c03abbd158345ae636c90" translate="yes" xml:space="preserve">
          <source>Scanner provides a convenient interface for reading data such as a file of newline-delimited lines of text. Successive calls to the Scan method will step through the 'tokens' of a file, skipping the bytes between the tokens. The specification of a token is defined by a split function of type SplitFunc; the default split function breaks the input into lines with line termination stripped. Split functions are defined in this package for scanning a file into lines, bytes, UTF-8-encoded runes, and space-delimited words. The client may instead provide a custom split function.</source>
          <target state="translated">Scanner提供了一个方便的接口,用于读取数据,如一个以新行分隔的文本文件。对Scan方法的连续调用将跳过文件的 &quot;标记&quot;,跳过标记之间的字节。token的规格是由类型为SplitFunc的分割函数定义的;默认的分割函数将输入的内容分割成行,并去除行终止符。本包中定义了分割函数,用于将文件扫描成行、字节、UTF-8编码的符文和空格分隔的单词。客户端可以提供一个自定义的分割函数。</target>
        </trans-unit>
        <trans-unit id="221c21d253261d097c5eddd34e07f0e854f9f8be" translate="yes" xml:space="preserve">
          <source>Scanner.Bytes</source>
          <target state="translated">Scanner.Bytes</target>
        </trans-unit>
        <trans-unit id="db2650dfa50b9653ed3b24b83e400aa246e21e57" translate="yes" xml:space="preserve">
          <source>Scanner.Scan</source>
          <target state="translated">Scanner.Scan</target>
        </trans-unit>
        <trans-unit id="e230f66cb2480e61c70e7940e1168e3d3dc1b2cf" translate="yes" xml:space="preserve">
          <source>Scanning</source>
          <target state="translated">Scanning</target>
        </trans-unit>
        <trans-unit id="0e43a71fd5dc304b08b8c37610739914b52545a4" translate="yes" xml:space="preserve">
          <source>Scanning stops if the function returns an error, in which case some of the input may be discarded.</source>
          <target state="translated">如果函数返回错误,则停止扫描,在这种情况下,部分输入可能会被丢弃。</target>
        </trans-unit>
        <trans-unit id="d3672319a15266023841ffc344b2b9ae68437119" translate="yes" xml:space="preserve">
          <source>Scanning stops unrecoverably at EOF, the first I/O error, or a token too large to fit in the buffer. When a scan stops, the reader may have advanced arbitrarily far past the last token. Programs that need more control over error handling or large tokens, or must run sequential scans on a reader, should use bufio.Reader instead.</source>
          <target state="translated">扫描在EOF、第一个I/O错误或令牌过大而无法放入缓冲区时停止,无法恢复。当扫描停止时,读卡器可能已经任意前进了很远,超过了最后一个令牌。如果程序需要更多的控制错误处理或大标记,或者必须在读取器上运行顺序扫描,应该使用bufio.Reader来代替。</target>
        </trans-unit>
        <trans-unit id="4651a34e4df9619783ad372f905d6d3b84e9d76d" translate="yes" xml:space="preserve">
          <source>Scope</source>
          <target state="translated">Scope</target>
        </trans-unit>
        <trans-unit id="2ebfb1a9903c43a33373f64197eeaf8911c9f134" translate="yes" xml:space="preserve">
          <source>Scope returns the (complete or incomplete) package scope holding the objects declared at package level (TypeNames, Consts, Vars, and Funcs).</source>
          <target state="translated">Scope 返回(完整或不完整的)包的作用域,该作用域持有在包级声明的对象(TypeNames,Consts,Vars,and Funcs)。</target>
        </trans-unit>
        <trans-unit id="f31d3986ec66463fe9a83dfd9a2accc1b70877c7" translate="yes" xml:space="preserve">
          <source>Scope returns the scope of the function's body block.</source>
          <target state="translated">Scope 返回函数主体块的范围。</target>
        </trans-unit>
        <trans-unit id="caf135bc624d4b0feb9650ec0d00441eafcdc77d" translate="yes" xml:space="preserve">
          <source>Scripts is the set of Unicode script tables.</source>
          <target state="translated">脚本是Unicode脚本表的集合。</target>
        </trans-unit>
        <trans-unit id="bce06414177f72ab70e6387b6af9f8ceef0d6049" translate="yes" xml:space="preserve">
          <source>Search</source>
          <target state="translated">Search</target>
        </trans-unit>
        <trans-unit id="f3e40d362f51c406a8e1778fc061f0dd3ad57de4" translate="yes" xml:space="preserve">
          <source>Search (DescendingOrder)</source>
          <target state="translated">搜索(降序)</target>
        </trans-unit>
        <trans-unit id="fdbb604a543d329419799366cc3a9af7390d3bcf" translate="yes" xml:space="preserve">
          <source>Search returns the result of applying SearchFloat64s to the receiver and x.</source>
          <target state="translated">搜索返回将SearchFloat64s应用于接收器和x的结果。</target>
        </trans-unit>
        <trans-unit id="1ab6c8f0fd768a91b3e79c036cb01cc452193fe2" translate="yes" xml:space="preserve">
          <source>Search returns the result of applying SearchInts to the receiver and x.</source>
          <target state="translated">搜索返回将SearchInts应用到接收器和x的结果。</target>
        </trans-unit>
        <trans-unit id="1c4f638fca65e5a738654ac393880f806f3b7f65" translate="yes" xml:space="preserve">
          <source>Search returns the result of applying SearchStrings to the receiver and x.</source>
          <target state="translated">搜索返回将SearchStrings应用于接收器和x的结果。</target>
        </trans-unit>
        <trans-unit id="794b977a863a1d9dc8d7b0fd80d6eef6736bd69e" translate="yes" xml:space="preserve">
          <source>Search uses binary search to find and return the smallest index i in [0, n) at which f(i) is true, assuming that on the range [0, n), f(i) == true implies f(i+1) == true. That is, Search requires that f is false for some (possibly empty) prefix of the input range [0, n) and then true for the (possibly empty) remainder; Search returns the first true index. If there is no such index, Search returns n. (Note that the &quot;not found&quot; return value is not -1 as in, for instance, strings.Index.) Search calls f(i) only for i in the range [0, n).</source>
          <target state="translated">Search使用二进制搜索来寻找并返回[0,n)中f(i)为真的最小索引i,假设在范围[0,n)上,f(i)==真意味着f(i+1)==真。也就是说,Search要求f对输入范围[0,n)的某些(可能是空的)前缀为假,然后对(可能是空的)剩余部分为真;Search返回第一个真索引。如果没有这样的索引,Search返回n。(注意 &quot;未找到 &quot;的返回值不是-1,例如strings.Index。)Search只对[0,n)范围内的i调用f(i)。</target>
        </trans-unit>
        <trans-unit id="895f11590a6ed175f7bac01b38c2ec5640f6fc28" translate="yes" xml:space="preserve">
          <source>SearchFloat64s searches for x in a sorted slice of float64s and returns the index as specified by Search. The return value is the index to insert x if x is not present (it could be len(a)). The slice must be sorted in ascending order.</source>
          <target state="translated">SearchFloat64s在float64s的排序片中搜索x,并返回Search指定的索引。如果x不存在,返回值是插入x的索引(可以是len(a))。分片必须按升序排序。</target>
        </trans-unit>
        <trans-unit id="b48f643546b25f6e6918e845a0e8a3ab0175ad09" translate="yes" xml:space="preserve">
          <source>SearchInts searches for x in a sorted slice of ints and returns the index as specified by Search. The return value is the index to insert x if x is not present (it could be len(a)). The slice must be sorted in ascending order.</source>
          <target state="translated">SearchInts在ints的排序片中搜索x,并返回由Search指定的索引。如果x不存在,返回值是插入x的索引(可以是len(a))。分片必须按升序排序。</target>
        </trans-unit>
        <trans-unit id="ed762c6e866455b20a9bc0ff477d563626862413" translate="yes" xml:space="preserve">
          <source>SearchStrings searches for x in a sorted slice of strings and returns the index as specified by Search. The return value is the index to insert x if x is not present (it could be len(a)). The slice must be sorted in ascending order.</source>
          <target state="translated">SearchStrings在字符串的排序片断中搜索x,并返回由Search指定的索引。如果x不存在,返回值是插入x的索引(可以是len(a))。切片必须按升序排序。</target>
        </trans-unit>
        <trans-unit id="d1110c735a627c55e67957485addfcd1740c3fa1" translate="yes" xml:space="preserve">
          <source>Searching data sorted in descending order would use the &amp;lt;= operator instead of the &amp;gt;= operator.</source>
          <target state="translated">搜索按降序排序的数据将使用&amp;lt;=运算符而不是&amp;gt; =运算符。</target>
        </trans-unit>
        <trans-unit id="0feecc756efff0f52e43fa2ad18e92887874359a" translate="yes" xml:space="preserve">
          <source>Second returns the second offset within the minute specified by t, in the range [0, 59].</source>
          <target state="translated">Second 返回t指定的分钟内的秒偏移量,范围为[0,59]。</target>
        </trans-unit>
        <trans-unit id="aec1eca3aa532659c858922be555e4b78f91472b" translate="yes" xml:space="preserve">
          <source>Seconds returns the duration as a floating point number of seconds.</source>
          <target state="translated">Seconds 返回浮点数的秒数。</target>
        </trans-unit>
        <trans-unit id="883d7225a5feea9c004792c2e5762e5e8b90b937" translate="yes" xml:space="preserve">
          <source>Section compression type.</source>
          <target state="translated">段压缩型。</target>
        </trans-unit>
        <trans-unit id="23c76af95b6f5d08de2ecfd9a9b5758fd241b4b6" translate="yes" xml:space="preserve">
          <source>Section flags.</source>
          <target state="translated">科室旗帜。</target>
        </trans-unit>
        <trans-unit id="62f89d87896d7ef06a64cbb776d3fd356378e295" translate="yes" xml:space="preserve">
          <source>Section provides access to PE COFF section.</source>
          <target state="translated">节提供访问PE COFF节。</target>
        </trans-unit>
        <trans-unit id="0a9d0e16d038258c30fb66c2551ff2e94b6e8ab2" translate="yes" xml:space="preserve">
          <source>Section returns a section with the given name, or nil if no such section exists.</source>
          <target state="translated">Section 返回一个带有给定名称的section,如果没有这个section,则返回nil。</target>
        </trans-unit>
        <trans-unit id="fc54ab0b090fa88e8cee7f8d9e554c227fd11b85" translate="yes" xml:space="preserve">
          <source>Section returns the first section with the given name, or nil if no such section exists.</source>
          <target state="translated">Section 返回带有给定名称的第一个section,如果没有这个section,则返回nil。</target>
        </trans-unit>
        <trans-unit id="8743382bf5087384ab8d5b7b47a198bf1c224282" translate="yes" xml:space="preserve">
          <source>Section type.</source>
          <target state="translated">科室类型:</target>
        </trans-unit>
        <trans-unit id="d498edd9cfc2fe612ccd52dd5a6b59dfb6cad8e5" translate="yes" xml:space="preserve">
          <source>SectionByType returns the first section in f with the given type, or nil if there is no such section.</source>
          <target state="translated">SectionByType 返回f中给定类型的第一个节,如果没有这个节,则返回nil。</target>
        </trans-unit>
        <trans-unit id="dbabe3978d24b41c968a7e3b657294f716964e11" translate="yes" xml:space="preserve">
          <source>SectionHeader is similar to SectionHeader32 with Name field replaced by Go string.</source>
          <target state="translated">SectionHeader类似于SectionHeader32,Name字段被Go字符串代替。</target>
        </trans-unit>
        <trans-unit id="236a39825c17abffb62d175c97b2ff1d1ddf6257" translate="yes" xml:space="preserve">
          <source>SectionHeader32 represents real PE COFF section header.</source>
          <target state="translated">SectionHeader32表示真正的PE COFF节头。</target>
        </trans-unit>
        <trans-unit id="36fac8b648a8b963f174eff7d8e38ad8b061b47f" translate="yes" xml:space="preserve">
          <source>SectionReader</source>
          <target state="translated">SectionReader</target>
        </trans-unit>
        <trans-unit id="7c71d38d1e94fa11b5d9d25b519a23c96d399f77" translate="yes" xml:space="preserve">
          <source>SectionReader implements Read, Seek, and ReadAt on a section of an underlying ReaderAt.</source>
          <target state="translated">SectionReader在底层ReaderAt的某一节上实现了Read、Seek和ReadAt。</target>
        </trans-unit>
        <trans-unit id="559bf9fc1a7e8d17f180e11f63d09376be0206a5" translate="yes" xml:space="preserve">
          <source>SectionReader.ReadAt</source>
          <target state="translated">SectionReader.ReadAt</target>
        </trans-unit>
        <trans-unit id="665de6075b0f11336eab3dd46baf160774a5a70d" translate="yes" xml:space="preserve">
          <source>SectionReader.Seek</source>
          <target state="translated">SectionReader.Seek</target>
        </trans-unit>
        <trans-unit id="0f309ea1521bd5ca8e406b86f34f3a7a0ebff642" translate="yes" xml:space="preserve">
          <source>Security Model</source>
          <target state="translated">安全模式</target>
        </trans-unit>
        <trans-unit id="01953de86431ce77344577ae5495196d927df9a0" translate="yes" xml:space="preserve">
          <source>See &quot;Gobs of data&quot; for a design discussion of the gob wire format: &lt;a href=&quot;https://blog.golang.org/gobs-of-data&quot;&gt;https://blog.golang.org/gobs-of-data&lt;/a&gt;</source>
          <target state="translated">有关&amp;ldquo; gob连线&amp;rdquo;格式的设计讨论，请参见&amp;ldquo;数据的gobs&amp;rdquo;：&lt;a href=&quot;https://blog.golang.org/gobs-of-data&quot;&gt;https&lt;/a&gt; : //blog.golang.org/gobs-of-data</target>
        </trans-unit>
        <trans-unit id="3774cda758049661070b6c5a6625f40ce94f1003" translate="yes" xml:space="preserve">
          <source>See &quot;JSON and Go&quot; for an introduction to this package: &lt;a href=&quot;https://golang.org/doc/articles/json_and_go.html&quot;&gt;https://golang.org/doc/articles/json_and_go.html&lt;/a&gt;</source>
          <target state="translated">有关此程序包的介绍，请参见&amp;ldquo; JSON和Go&amp;rdquo;：&lt;a href=&quot;https://golang.org/doc/articles/json_and_go.html&quot;&gt;https&lt;/a&gt; : //golang.org/doc/articles/json_and_go.html</target>
        </trans-unit>
        <trans-unit id="2434441ee0019a17c985accfc44984c0fc83f78c" translate="yes" xml:space="preserve">
          <source>See &quot;The Go image package&quot; for more details: &lt;a href=&quot;https://golang.org/doc/articles/image_package.html&quot;&gt;https://golang.org/doc/articles/image_package.html&lt;/a&gt;</source>
          <target state="translated">有关更多详细信息，请参见&amp;ldquo; Go图片包&amp;rdquo;：&lt;a href=&quot;https://golang.org/doc/articles/image_package.html&quot;&gt;https&lt;/a&gt; : //golang.org/doc/articles/image_package.html</target>
        </trans-unit>
        <trans-unit id="f5ff28b5d6f4a465abbce4a3d8096187a236d24e" translate="yes" xml:space="preserve">
          <source>See &quot;The Go image/draw package&quot; for an introduction to this package: &lt;a href=&quot;https://golang.org/doc/articles/image_draw.html&quot;&gt;https://golang.org/doc/articles/image_draw.html&lt;/a&gt;</source>
          <target state="translated">有关此程序包的介绍，请参见&amp;ldquo; Go image / draw程序包&amp;rdquo;：&lt;a href=&quot;https://golang.org/doc/articles/image_draw.html&quot;&gt;https&lt;/a&gt; : //golang.org/doc/articles/image_draw.html</target>
        </trans-unit>
        <trans-unit id="f837700d9a3417d92fc3f9f0548fd849b9aa7119" translate="yes" xml:space="preserve">
          <source>See &quot;The Laws of Reflection&quot; for an introduction to reflection in Go: &lt;a href=&quot;https://golang.org/doc/articles/laws_of_reflection.html&quot;&gt;https://golang.org/doc/articles/laws_of_reflection.html&lt;/a&gt;</source>
          <target state="translated">有关Go语言中反射的介绍，请参见&amp;ldquo;反射法则&amp;rdquo;：&lt;a href=&quot;https://golang.org/doc/articles/laws_of_reflection.html&quot;&gt;https&lt;/a&gt;：//golang.org/doc/articles/laws_of_reflection.html</target>
        </trans-unit>
        <trans-unit id="cd38865133cd9a5c006edfe52fb23197b681651e" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://blog.golang.org/context&quot;&gt;https://blog.golang.org/context&lt;/a&gt; for example code for a server that uses Contexts.</source>
          <target state="translated">有关使用上下文的服务器的示例代码，请参见&lt;a href=&quot;https://blog.golang.org/context&quot;&gt;https://blog.golang.org/context&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f8fa4b86ca7a1947812b5144ad80bb7923b98b76" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://blog.golang.org/http-tracing&quot;&gt;https://blog.golang.org/http-tracing&lt;/a&gt; for more.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;https://blog.golang.org/http-tracing&quot;&gt;https://blog.golang.org/http-tracing&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="55fd6381c1e6f556a9d9a122b9ddab024cd5623c" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels&quot;&gt;https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels&lt;/a&gt;.</source>
          <target state="translated">请参阅&lt;a href=&quot;https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels&quot;&gt;https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5b6207cb402edce8d859bdca9debb6fc32598a7f" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematics_of_cyclic_redundancy_checks#Reversed_representations_and_reciprocal_polynomials&quot;&gt;https://en.wikipedia.org/wiki/Mathematics_of_cyclic_redundancy_checks#Reversed_representations_and_reciprocal_polynomials&lt;/a&gt; for information.</source>
          <target state="translated">有关信息，请参见&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematics_of_cyclic_redundancy_checks#Reversed_representations_and_reciprocal_polynomials&quot;&gt;https://en.wikipedia.org/wiki/Mathematics_of_cyclic_redundancy_checks#Reversed_representations_and_reciprocal_polynomials&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="822defb6e38c1c8b51e3bd857cd8e75be7930a08" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://en.wikipedia.org/wiki/Web_colors#Web-safe_colors&quot;&gt;https://en.wikipedia.org/wiki/Web_colors#Web-safe_colors&lt;/a&gt; for details.</source>
          <target state="translated">有关详细信息，请参见&lt;a href=&quot;https://en.wikipedia.org/wiki/Web_colors#Web-safe_colors&quot;&gt;https://en.wikipedia.org/wiki/Web_colors#Web-safe_colors&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="012d19a411e4e0484271ae09bcb7f34da4a9a591" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://fast-cgi.github.io/&quot;&gt;https://fast-cgi.github.io/&lt;/a&gt; for an unofficial mirror of the original documentation.</source>
          <target state="translated">请参阅&lt;a href=&quot;https://fast-cgi.github.io/&quot;&gt;https://fast-cgi.github.io/&lt;/a&gt;以获取原始文档的非官方镜像。</target>
        </trans-unit>
        <trans-unit id="c591b3698d1803b8997f519f5ea5ff42b510cd7a" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00&quot;&gt;https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00&lt;/a&gt; for details.</source>
          <target state="translated">有关详细信息，请参见&lt;a href=&quot;https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00&quot;&gt;https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ebe2d422131406c7b8b8363b0278a5d60f19e086" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;https://tools.ietf.org/html/rfc6265&lt;/a&gt; for details.</source>
          <target state="translated">有关详细信息，请参见&lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;https://tools.ietf.org/html/rfc6265&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cfeb891e01c83428f5fff33780366881bea259da" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://www.w3.org/TR/css3-syntax/#parsing&quot;&gt;https://www.w3.org/TR/css3-syntax/#parsing&lt;/a&gt; and &lt;a href=&quot;https://web.archive.org/web/20090211114933/http://w3.org/TR/css3-syntax#style&quot;&gt;https://web.archive.org/web/20090211114933/http://w3.org/TR/css3-syntax#style&lt;/a&gt;</source>
          <target state="translated">参见&lt;a href=&quot;https://www.w3.org/TR/css3-syntax/#parsing&quot;&gt;https://www.w3.org/TR/css3-syntax/#parsing&lt;/a&gt;和&lt;a href=&quot;https://web.archive.org/web/20090211114933/http://w3.org/TR/css3-syntax#style&quot;&gt;https://web.archive.org/web/20090211114933/http://w3.org/TR/css3-syntax#style&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b12c5bb65217a01227ad162d33c3fed71b0401c9" translate="yes" xml:space="preserve">
          <source>See MarshalIndent for an example.</source>
          <target state="translated">参见MarshalIndent的例子。</target>
        </trans-unit>
        <trans-unit id="4a1e97ca1a62398cd193e09c77540d6a3a116112" translate="yes" xml:space="preserve">
          <source>See also &amp;ldquo;A Layman's Guide to a Subset of ASN.1, BER, and DER,&amp;rdquo; &lt;a href=&quot;http://luca.ntop.org/Teaching/Appunti/asn1.html&quot;&gt;http://luca.ntop.org/Teaching/Appunti/asn1.html&lt;/a&gt;.</source>
          <target state="translated">另请参见&amp;ldquo; ASN.1，BER和DER子集的Layman指南&amp;rdquo;，&lt;a href=&quot;http://luca.ntop.org/Teaching/Appunti/asn1.html&quot;&gt;http：//luca.ntop.org/Teaching/Appunti/asn1.html&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f35fe0b7c2e4d6b79cc655771a00378e8038d6ad" translate="yes" xml:space="preserve">
          <source>See also Rob Pike, &amp;ldquo;Lexical File Names in Plan 9 or Getting Dot-Dot Right,&amp;rdquo; &lt;a href=&quot;https://9p.io/sys/doc/lexnames.html&quot;&gt;https://9p.io/sys/doc/lexnames.html&lt;/a&gt;</source>
          <target state="translated">另请参见Rob Pike，&amp;ldquo; Plan 9中的词汇文件名或正确的点对点&amp;rdquo;，&lt;a href=&quot;https://9p.io/sys/doc/lexnames.html&quot;&gt;https：//9p.io/sys/doc/lexnames.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c57c543e703b305eac0e44a135198463dbeead16" translate="yes" xml:space="preserve">
          <source>See func Dial for a description of the host and port parameters.</source>
          <target state="translated">有关主机和端口参数的描述,请参见 func Dial。</target>
        </trans-unit>
        <trans-unit id="b9538b240ebef42fb9902c82f39f4d8fe015d462" translate="yes" xml:space="preserve">
          <source>See func Dial for a description of the hostport parameter, and host and port results.</source>
          <target state="translated">关于主机端口参数、主机和端口结果的描述,请参见 func Dial。</target>
        </trans-unit>
        <trans-unit id="f55bd52960d8a9b74f8c169b63b303f83068df0d" translate="yes" xml:space="preserve">
          <source>See func Dial for a description of the network and address parameters.</source>
          <target state="translated">有关网络和地址参数的描述,请参见 func Dial。</target>
        </trans-unit>
        <trans-unit id="27af5de3a2347f6faceaa84c4b1f14ae1dbd0c9d" translate="yes" xml:space="preserve">
          <source>See func Listen for a description of the network and address parameters.</source>
          <target state="translated">有关网络和地址参数的描述,请参见 func Listen。</target>
        </trans-unit>
        <trans-unit id="6b6b3dee4908b79bcc47570b27eb5ceec2a78402" translate="yes" xml:space="preserve">
          <source>See func ListenPacket for a description of the network and address parameters.</source>
          <target state="translated">有关网络和地址参数的描述,请参见func ListenPacket。</target>
        </trans-unit>
        <trans-unit id="ad4f4bb8708490d77806cbbb7379b205b4ed91be" translate="yes" xml:space="preserve">
          <source>See package json to understand how non-string content is marshaled for embedding in JavaScript contexts.</source>
          <target state="translated">请参阅包json,了解非字符串内容是如何在JavaScript上下文中嵌入的。</target>
        </trans-unit>
        <trans-unit id="6e66c2f2a3fcd4dca444d07ce7d1a4b916782623" translate="yes" xml:space="preserve">
          <source>See page 36 of RFC 959 (&lt;a href=&quot;https://www.ietf.org/rfc/rfc959.txt&quot;&gt;https://www.ietf.org/rfc/rfc959.txt&lt;/a&gt;) for details of another form of response accepted:</source>
          <target state="translated">有关接受的另一种形式的响应，请参阅RFC 959（&lt;a href=&quot;https://www.ietf.org/rfc/rfc959.txt&quot;&gt;https://www.ietf.org/rfc/rfc959.txt&lt;/a&gt;）的第36页：</target>
        </trans-unit>
        <trans-unit id="89753a3f5bb64713c93e9dd202de0a7448a21cee" translate="yes" xml:space="preserve">
          <source>See the Client.Do method documentation for details on how redirects are handled.</source>
          <target state="translated">关于如何处理重定向,请参见Client.Do方法文档。</target>
        </trans-unit>
        <trans-unit id="ca6b0bd4889c5a06e76626f48ec79733e1fde8b5" translate="yes" xml:space="preserve">
          <source>See the Decoder.Strict and Decoder.Entity fields' documentation.</source>
          <target state="translated">参见Decoder.Strict和Decoder.Entity字段的文档。</target>
        </trans-unit>
        <trans-unit id="69633a7324ac73d11db8887864a0a74fd2f5588f" translate="yes" xml:space="preserve">
          <source>See the documentation for Marshal for details about the conversion of Go values to JSON.</source>
          <target state="translated">关于将Go值转换为JSON的细节,请参见Marshal的文档。</target>
        </trans-unit>
        <trans-unit id="45c89cab840adb83eec8d88d66bfe51744007d64" translate="yes" xml:space="preserve">
          <source>See the documentation for Marshal for details about the conversion of Go values to XML.</source>
          <target state="translated">关于将Go值转换为XML的细节,请参见Marshal的文档。</target>
        </trans-unit>
        <trans-unit id="f6ad8d64ce7abf48e48759b114cf5bbde1ec1217" translate="yes" xml:space="preserve">
          <source>See the documentation for Reader's DotReader method for details about dot-encoding.</source>
          <target state="translated">请参阅Reader的DotReader方法的文档,了解点阵编码的细节。</target>
        </trans-unit>
        <trans-unit id="07bb2782143cae54efbc20f97e601c6258fdfa3a" translate="yes" xml:space="preserve">
          <source>See the documentation for Unmarshal for details about the conversion of JSON into a Go value.</source>
          <target state="translated">关于将JSON转换为Go值的细节,请参见Unmarshal的文档。</target>
        </trans-unit>
        <trans-unit id="5b7d9e398b9767ef1472ee8144b5fcbf7154f428" translate="yes" xml:space="preserve">
          <source>See the documentation for the DotReader method for details about dot-encoding.</source>
          <target state="translated">请参阅DotReader方法的文档,了解关于点阵编码的详细信息。</target>
        </trans-unit>
        <trans-unit id="20a56feb05a514c49115ca9854f4e8b6ab081007" translate="yes" xml:space="preserve">
          <source>See the documentation of ErrorCode for details.</source>
          <target state="translated">详见ErrorCode的文档。</target>
        </trans-unit>
        <trans-unit id="130b144345eef54088939126445f2041356e9967" translate="yes" xml:space="preserve">
          <source>See the net/http/pprof package for more details about all of the debug endpoints installed by this import.</source>
          <target state="translated">参见net/http/pprof包,以了解更多关于此导入安装的所有调试端点的细节。</target>
        </trans-unit>
        <trans-unit id="8ea13af2c476fd8c34b53410467a8c4eec967244" translate="yes" xml:space="preserve">
          <source>See the net/http/pprof package for more details.</source>
          <target state="translated">详见net/http/pprof包。</target>
        </trans-unit>
        <trans-unit id="d95f74a97d247876324f75dbbfb30fd3fdf53de6" translate="yes" xml:space="preserve">
          <source>See: &lt;a href=&quot;https://www.pkware.com/appnote&quot;&gt;https://www.pkware.com/appnote&lt;/a&gt;</source>
          <target state="translated">请参阅：&lt;a href=&quot;https://www.pkware.com/appnote&quot;&gt;https&lt;/a&gt;：//www.pkware.com/appnote</target>
        </trans-unit>
        <trans-unit id="421cab07939e4ef921a875d22fec2c50b6b26cc4" translate="yes" xml:space="preserve">
          <source>Seed returns the private key seed corresponding to priv. It is provided for interoperability with RFC 8032. RFC 8032's private keys correspond to seeds in this package.</source>
          <target state="translated">Seed返回对应于priv.Seed的私钥种子,它与RFC 8032提供了互操作性。它是为了与RFC 8032的互操作性而提供的。RFC 8032的私钥对应于这个包中的种子。</target>
        </trans-unit>
        <trans-unit id="a2daea0c21550e6b91614c2942780e2e38582d89" translate="yes" xml:space="preserve">
          <source>Seed uses the provided seed value to initialize the default Source to a deterministic state. If Seed is not called, the generator behaves as if seeded by Seed(1). Seed values that have the same remainder when divided by 2^31-1 generate the same pseudo-random sequence. Seed, unlike the Rand.Seed method, is safe for concurrent use.</source>
          <target state="translated">Seed 使用提供的种子值将默认的 Source 初始化为确定性状态。如果不调用Seed,则生成器的行为与Seed(1)的种子值相同。当种子值除以2^31-1时具有相同余数的种子值会产生相同的伪随机序列。与Rand.Seed方法不同,Seed对于并发使用是安全的。</target>
        </trans-unit>
        <trans-unit id="06599ffd87d9ecfcc5955a8a8f6f2e80af71b779" translate="yes" xml:space="preserve">
          <source>Seed uses the provided seed value to initialize the generator to a deterministic state. Seed should not be called concurrently with any other Rand method.</source>
          <target state="translated">Seed 使用提供的种子值将生成器初始化为确定性状态。Seed不应该与其他任何Rand方法同时调用。</target>
        </trans-unit>
        <trans-unit id="63eada0c1ee90c191cced8ff6a478d23ec01c7bb" translate="yes" xml:space="preserve">
          <source>Seek implements the io.Seeker interface.</source>
          <target state="translated">Seek实现了io.Seeker接口。</target>
        </trans-unit>
        <trans-unit id="410f9d629b5b2020b5303452364dec83676d0a30" translate="yes" xml:space="preserve">
          <source>Seek positions the Reader at offset off in the encoded entry stream. Offset 0 can be used to denote the first entry.</source>
          <target state="translated">Seek将读卡器定位在编码输入流中的偏移量上,偏移量0可以用来表示第一个输入。偏移量0可以用来表示第一个条目。</target>
        </trans-unit>
        <trans-unit id="73550a62d2076f2c392030c22ea826a5948745a2" translate="yes" xml:space="preserve">
          <source>Seek restores the line table reader to a position returned by Tell.</source>
          <target state="translated">Seek将行表阅读器恢复到Tell返回的位置。</target>
        </trans-unit>
        <trans-unit id="6d637ad9eaafe14fbed4d5e3bc3eb33df03f11cb" translate="yes" xml:space="preserve">
          <source>Seek sets the offset for the next Read or Write on file to offset, interpreted according to whence: 0 means relative to the origin of the file, 1 means relative to the current offset, and 2 means relative to the end. It returns the new offset and an error, if any. The behavior of Seek on a file opened with O_APPEND is not specified.</source>
          <target state="translated">Seek设置下一次对文件的读或写的偏移量为offset,根据whence解释。0表示相对于文件的原点,1表示相对于当前的偏移量,2表示相对于文件的终点.如果有的话,它返回新的偏移量和一个错误。对于用O_APPEND打开的文件,没有指定Seek的行为。</target>
        </trans-unit>
        <trans-unit id="e00a273e91af976fc6df810663ccae8e6326bc28" translate="yes" xml:space="preserve">
          <source>Seek sets the offset for the next Read or Write to offset, interpreted according to whence: SeekStart means relative to the start of the file, SeekCurrent means relative to the current offset, and SeekEnd means relative to the end. Seek returns the new offset relative to the start of the file and an error, if any.</source>
          <target state="translated">Seek设置下一次读或写的偏移量,根据whence解释。SeekStart表示相对于文件的开始,SeekCurrent表示相对于当前的偏移量,SeekEnd表示相对于文件的结束.Seek返回相对于文件开始的新偏移量,如果有错误,则返回一个错误。</target>
        </trans-unit>
        <trans-unit id="f2691430f4c04cd93d687e7abb0ccf591170c83f" translate="yes" xml:space="preserve">
          <source>Seek whence values.</source>
          <target state="translated">寻求当值。</target>
        </trans-unit>
        <trans-unit id="69cfaf772b14f0b576e9cb0bbd8f02155636d19d" translate="yes" xml:space="preserve">
          <source>SeekPC returns the Entry for the compilation unit that includes pc, and positions the reader to read the children of that unit. If pc is not covered by any unit, SeekPC returns ErrUnknownPC and the position of the reader is undefined.</source>
          <target state="translated">SeekPC返回包括pc在内的编译单元的条目,并定位读取器以读取该单元的子单元。如果pc没有被任何单元覆盖,SeekPC返回ErrUnknownPC,并且读取器的位置是未定义的。</target>
        </trans-unit>
        <trans-unit id="ce674d68613294249c458dda3fd950d087fbda52" translate="yes" xml:space="preserve">
          <source>SeekPC sets *entry to the LineEntry that includes pc and positions the reader on the next entry in the line table. If necessary, this will seek backwards to find pc.</source>
          <target state="translated">SeekPC将*entry设置为包含pc的LineEntry,并将读取器定位在行表的下一个条目上。如果有必要,这将向后寻找pc。</target>
        </trans-unit>
        <trans-unit id="9d91685eee68f0702fc5f565a2ad58bdb01cbd6c" translate="yes" xml:space="preserve">
          <source>Seeker is the interface that wraps the basic Seek method.</source>
          <target state="translated">Seeker是包装基本Seek方法的接口。</target>
        </trans-unit>
        <trans-unit id="c221b3bf48536c91e36f1aa582e0e6ad14671a86" translate="yes" xml:space="preserve">
          <source>Seeking to an offset before the start of the file is an error. Seeking to any positive offset is legal, but the behavior of subsequent I/O operations on the underlying object is implementation-dependent.</source>
          <target state="translated">在文件开始前寻找偏移量是错误的。对任何正偏移量的查找都是合法的,但是对底层对象的后续I/O操作的行为是依赖于实现的。</target>
        </trans-unit>
        <trans-unit id="d283b12149f88184eedb3514ba9c006d88d9d635" translate="yes" xml:space="preserve">
          <source>Segment returns the first Segment with the given name, or nil if no such segment exists.</source>
          <target state="translated">Segment返回第一个给定名称的Segment,如果不存在,则返回nil。</target>
        </trans-unit>
        <trans-unit id="4ee9c170709717ea62d8ec2ac63808bf3b81d532" translate="yes" xml:space="preserve">
          <source>Select executes a select operation described by the list of cases. Like the Go select statement, it blocks until at least one of the cases can proceed, makes a uniform pseudo-random choice, and then executes that case. It returns the index of the chosen case and, if that case was a receive operation, the value received and a boolean indicating whether the value corresponds to a send on the channel (as opposed to a zero value received because the channel is closed).</source>
          <target state="translated">Select执行一个由case列表描述的选择操作。和Go选择语句一样,它阻塞到至少有一个case可以进行,进行统一的伪随机选择,然后执行该case。它返回所选情况的索引,如果该情况是接收操作,则返回接收到的值和一个布尔值,表示该值是否对应于通道上的发送(而不是因为通道关闭而接收到的零值)。</target>
        </trans-unit>
        <trans-unit id="7716a94c0a405511b91cc23c646dfce03e542371" translate="yes" xml:space="preserve">
          <source>SelectionKind describes the kind of a selector expression x.f (excluding qualified identifiers).</source>
          <target state="translated">SelectionKind描述了选择器表达式x.f的种类(不包括限定标识符)。</target>
        </trans-unit>
        <trans-unit id="656dfc577aeb6e9f277a9a8820fcfc6e5db75f21" translate="yes" xml:space="preserve">
          <source>SelectionString returns the string form of s. The Qualifier controls the printing of package-level objects, and may be nil.</source>
          <target state="translated">SelectionString 返回 s 的字符串形式,限定符控制包级对象的打印,可以为零。</target>
        </trans-unit>
        <trans-unit id="edad40365c9764afdd964f9245649f6856af2d11" translate="yes" xml:space="preserve">
          <source>Send sends x on the channel v. It panics if v's kind is not Chan or if x's type is not the same type as v's element type. As in Go, x's value must be assignable to the channel's element type.</source>
          <target state="translated">如果v的种类不是Chan或者x的类型与v的元素类型不一样,它就会惊慌失措。在围棋中,x的值必须可以分配给通道的元素类型。</target>
        </trans-unit>
        <trans-unit id="2750b0f06411195ed08fefe45f59d520ab6f8353" translate="yes" xml:space="preserve">
          <source>SendMail</source>
          <target state="translated">SendMail</target>
        </trans-unit>
        <trans-unit id="1a5bbac84e0744da338847af3ed794816ef236ce" translate="yes" xml:space="preserve">
          <source>SendMail connects to the server at addr, switches to TLS if possible, authenticates with the optional mechanism a if possible, and then sends an email from address from, to addresses to, with message msg. The addr must include a port, as in &quot;mail.example.com:smtp&quot;.</source>
          <target state="translated">SendMail 在addr处连接到服务器,如果可能的话切换到TLS,如果可能的话使用可选的机制a进行验证,然后从addr地址向addr地址发送邮件,并发送msg。addr必须包含一个端口,如 &quot;mail.example.com:smtp&quot;。</target>
        </trans-unit>
        <trans-unit id="9866b4faed06fd643cf801f0e203a46a3fe6c756" translate="yes" xml:space="preserve">
          <source>Serve accepts incoming FastCGI connections on the listener l, creating a new goroutine for each. The goroutine reads requests and then calls handler to reply to them. If l is nil, Serve accepts connections from os.Stdin. If handler is nil, http.DefaultServeMux is used.</source>
          <target state="translated">Serve在监听器l上接受传入的FastCGI连接,为每个连接创建一个新的goroutine。goroutine 读取请求,然后调用 handler 来回复它们。如果 l 为 nil,Serve 接受来自 os.Stdin 的连接。如果 handler 为 nil,则使用 http.DefaultServeMux。</target>
        </trans-unit>
        <trans-unit id="d8de44e0fb5292324dadb958bb0ec67283e1e920" translate="yes" xml:space="preserve">
          <source>Serve accepts incoming HTTP connections on the listener l, creating a new service goroutine for each. The service goroutines read requests and then call handler to reply to them.</source>
          <target state="translated">Serve在监听器l上接受传入的HTTP连接,为每个连接创建一个新的服务goroutine。服务goroutine读取请求,然后调用handler来回复请求。</target>
        </trans-unit>
        <trans-unit id="fb2fbb4a3d173feafc83e986b5d91f4c043b98cd" translate="yes" xml:space="preserve">
          <source>Serve accepts incoming connections on the Listener l, creating a new service goroutine for each. The service goroutines read requests and then call srv.Handler to reply to them.</source>
          <target state="translated">Serve在Listener l上接受传入的连接,为每个连接创建一个新的服务goroutine。服务goroutine读取请求,然后调用srv.Handler来回复请求。</target>
        </trans-unit>
        <trans-unit id="f65496b12ef6ef062ca261d02fdcc1afec4ce5ea" translate="yes" xml:space="preserve">
          <source>Serve always returns a non-nil error and closes l. After Shutdown or Close, the returned error is ErrServerClosed.</source>
          <target state="translated">Serve总是返回一个非零的错误并关闭l,关机或关闭后,返回的错误是ErrServerClosed。</target>
        </trans-unit>
        <trans-unit id="4671511496e9d853a658f8c526e4dbf184a2c34c" translate="yes" xml:space="preserve">
          <source>Serve always returns a non-nil error.</source>
          <target state="translated">Serve总是返回一个非零的错误。</target>
        </trans-unit>
        <trans-unit id="497078ba977bfc095dad2477b3172dcb26f1c0ab" translate="yes" xml:space="preserve">
          <source>Serve executes the provided Handler on the currently active CGI request, if any. If there's no current CGI environment an error is returned. The provided handler may be nil to use http.DefaultServeMux.</source>
          <target state="translated">Serve在当前活动的CGI请求上执行所提供的处理程序(如果有的话)。如果当前没有CGI环境,将返回一个错误。所提供的处理程序可能是nil,以使用http.DefaultServeMux。</target>
        </trans-unit>
        <trans-unit id="dbfb7d2b5b789e7fe76f3c2462b4817839783a1b" translate="yes" xml:space="preserve">
          <source>ServeCodec is like ServeConn but uses the specified codec to decode requests and encode responses.</source>
          <target state="translated">ServeCodec和ServeConn一样,但使用指定的编解码器来解码请求和编码响应。</target>
        </trans-unit>
        <trans-unit id="09ac76223546ffdd3d100d24b6bc49c0b7956df0" translate="yes" xml:space="preserve">
          <source>ServeConn runs the DefaultServer on a single connection. ServeConn blocks, serving the connection until the client hangs up. The caller typically invokes ServeConn in a go statement. ServeConn uses the gob wire format (see package gob) on the connection. To use an alternate codec, use ServeCodec. See NewClient's comment for information about concurrent access.</source>
          <target state="translated">ServeConn在单个连接上运行DefaultServer。ServeConn阻塞,为连接服务,直到客户端挂断。调用者通常在go语句中调用ServeConn。ServeConn在连接上使用gob线格式(参见包gob)。要使用其他的编解码器,请使用ServeCodec。关于并发访问的信息,请参见NewClient的注释。</target>
        </trans-unit>
        <trans-unit id="d136d0992046f83551cea5f2576de13dc7e39384" translate="yes" xml:space="preserve">
          <source>ServeConn runs the JSON-RPC server on a single connection. ServeConn blocks, serving the connection until the client hangs up. The caller typically invokes ServeConn in a go statement.</source>
          <target state="translated">ServeConn在单个连接上运行JSON-RPC服务器。ServeConn阻塞,为连接服务,直到客户端挂断。调用者通常在go语句中调用ServeConn。</target>
        </trans-unit>
        <trans-unit id="2f01374418f76760c6cb616cbabd675e38909787" translate="yes" xml:space="preserve">
          <source>ServeConn runs the server on a single connection. ServeConn blocks, serving the connection until the client hangs up. The caller typically invokes ServeConn in a go statement. ServeConn uses the gob wire format (see package gob) on the connection. To use an alternate codec, use ServeCodec. See NewClient's comment for information about concurrent access.</source>
          <target state="translated">ServeConn在单个连接上运行服务器。ServeConn阻塞,为连接服务,直到客户端挂断。调用者通常在go语句中调用ServeConn。ServeConn在连接上使用gob线格式(参见包gob)。要使用其他的编解码器,请使用ServeCodec。关于并发访问的信息,请参见NewClient的注释。</target>
        </trans-unit>
        <trans-unit id="ef53643ab98faf2b116983a1f327c585aaa8a435" translate="yes" xml:space="preserve">
          <source>ServeContent replies to the request using the content in the provided ReadSeeker. The main benefit of ServeContent over io.Copy is that it handles Range requests properly, sets the MIME type, and handles If-Match, If-Unmodified-Since, If-None-Match, If-Modified-Since, and If-Range requests.</source>
          <target state="translated">ServeContent使用提供的ReadSeeker中的内容来回复请求。与io.Copy相比,ServeContent的主要好处是它能正确处理Range请求,设置MIME类型,并处理If-Match、If-Unmodified-Since、If-None-Match、If-Modified-Since和If-Range请求。</target>
        </trans-unit>
        <trans-unit id="cfd658fe667ad1d964897018a5c4cf11bec05335" translate="yes" xml:space="preserve">
          <source>ServeFile replies to the request with the contents of the named file or directory.</source>
          <target state="translated">ServeFile用命名的文件或目录的内容来回复请求。</target>
        </trans-unit>
        <trans-unit id="049197d23952867737fe7bc77daa12a248c70057" translate="yes" xml:space="preserve">
          <source>ServeHTTP calls f(w, r).</source>
          <target state="translated">ServeHTTP调用f(w,r)。</target>
        </trans-unit>
        <trans-unit id="4c4916bc850460672f4222f24dda17f824b214d6" translate="yes" xml:space="preserve">
          <source>ServeHTTP dispatches the request to the handler whose pattern most closely matches the request URL.</source>
          <target state="translated">ServeHTTP将请求发送到与请求URL最匹配的模式的处理程序。</target>
        </trans-unit>
        <trans-unit id="21deb32922a44f4fb534ed8afc10e377cb3ed92e" translate="yes" xml:space="preserve">
          <source>ServeHTTP implements an http.Handler that answers RPC requests.</source>
          <target state="translated">ServeHTTP实现了一个http.Handler,用于响应RPC请求。</target>
        </trans-unit>
        <trans-unit id="6b5f212880feffc9d4b20ece24bb964f1dfe9a0e" translate="yes" xml:space="preserve">
          <source>ServeHTTP should write reply headers and data to the ResponseWriter and then return. Returning signals that the request is finished; it is not valid to use the ResponseWriter or read from the Request.Body after or concurrently with the completion of the ServeHTTP call.</source>
          <target state="translated">ServeHTTP应该向ResponseWriter写入回复头和数据,然后返回。返回标志着请求已完成;在ServeHTTP调用完成后或与之同时使用ResponseWriter或从Request.Body读取数据是无效的。</target>
        </trans-unit>
        <trans-unit id="643b76d4394a8e8ca4ec7165cbad824736ed0dab" translate="yes" xml:space="preserve">
          <source>ServeMux also takes care of sanitizing the URL request path and the Host header, stripping the port number and redirecting any request containing . or .. elements or repeated slashes to an equivalent, cleaner URL.</source>
          <target state="translated">ServeMux还负责净化URL请求路径和Host头,去除端口号,并将任何包含.或.元素或重复斜杠的请求重定向到一个等价的、更干净的URL。</target>
        </trans-unit>
        <trans-unit id="c2c623da8699103087cc62f3c47b54b0c6fbdef4" translate="yes" xml:space="preserve">
          <source>ServeMux is an HTTP request multiplexer. It matches the URL of each incoming request against a list of registered patterns and calls the handler for the pattern that most closely matches the URL.</source>
          <target state="translated">ServeMux是一个HTTP请求复用器。它将每个传入请求的URL与注册模式列表进行匹配,并调用与URL最匹配的模式的处理程序。</target>
        </trans-unit>
        <trans-unit id="d57d6d29bc00d69dcb5016e00c29678f29b25c20" translate="yes" xml:space="preserve">
          <source>ServeMux.Handle</source>
          <target state="translated">ServeMux.Handle</target>
        </trans-unit>
        <trans-unit id="a2ccb85e8b555a7018f6848932b3cf1638f89e04" translate="yes" xml:space="preserve">
          <source>ServeRequest is like ServeCodec but synchronously serves a single request. It does not close the codec upon completion.</source>
          <target state="translated">ServeRequest与ServeCodec类似,但同步服务于单个请求。它不会在完成后关闭编解码器。</target>
        </trans-unit>
        <trans-unit id="914b527f3acbaa5705eeffe44b971ef90f12446b" translate="yes" xml:space="preserve">
          <source>ServeTLS accepts incoming HTTPS connections on the listener l, creating a new service goroutine for each. The service goroutines read requests and then call handler to reply to them.</source>
          <target state="translated">ServeTLS在监听器l上接受传入的HTTPS连接,为每个连接创建一个新的服务goroutine。服务goroutine读取请求,然后调用handler来回复请求。</target>
        </trans-unit>
        <trans-unit id="0a96e454a3074cfb2a672bba732fc55cf3ace063" translate="yes" xml:space="preserve">
          <source>ServeTLS accepts incoming connections on the Listener l, creating a new service goroutine for each. The service goroutines perform TLS setup and then read requests, calling srv.Handler to reply to them.</source>
          <target state="translated">ServeTLS接受监听器l上的传入连接,为每个连接创建一个新的服务goroutine。服务goroutine执行TLS设置,然后读取请求,调用srv.Handler来回复请求。</target>
        </trans-unit>
        <trans-unit id="5d05c42df2acb99153f40488ff8b30bf621e7c31" translate="yes" xml:space="preserve">
          <source>ServeTLS always returns a non-nil error.</source>
          <target state="translated">ServeTLS总是返回一个非零的错误。</target>
        </trans-unit>
        <trans-unit id="49b6a1abd7e8e016f95152133848467bef1659cf" translate="yes" xml:space="preserve">
          <source>ServeTLS always returns a non-nil error. After Shutdown or Close, the returned error is ErrServerClosed.</source>
          <target state="translated">ServeTLS总是返回一个非零的错误。关机或关闭后,返回的错误是ErrServerClosed。</target>
        </trans-unit>
        <trans-unit id="cb0cb170d106f8e8d5af1e05bbdbd3a96a7de197" translate="yes" xml:space="preserve">
          <source>Server</source>
          <target state="translated">Server</target>
        </trans-unit>
        <trans-unit id="4ddf4403b77024142dd6473786b6571dc8b196f9" translate="yes" xml:space="preserve">
          <source>Server represents an RPC Server.</source>
          <target state="translated">服务器代表一个RPC服务器。</target>
        </trans-unit>
        <trans-unit id="313ac33490fd78320856fae075839a276bcab472" translate="yes" xml:space="preserve">
          <source>Server returns a new TLS server side connection using conn as the underlying transport. The configuration config must be non-nil and must include at least one certificate or else set GetCertificate.</source>
          <target state="translated">服务器返回一个新的TLS服务器端连接,使用conn作为底层传输。配置config必须为非零,并且必须包含至少一个证书,否则设置GetCertificate。</target>
        </trans-unit>
        <trans-unit id="e0b4e659e40eb8a8a1e289fa3271bf98ef6e2706" translate="yes" xml:space="preserve">
          <source>Server.Shutdown</source>
          <target state="translated">Server.Shutdown</target>
        </trans-unit>
        <trans-unit id="e8983457da1ab21a6c85c2a9507e94af92a8934d" translate="yes" xml:space="preserve">
          <source>ServerConn is an artifact of Go's early HTTP implementation. It is low-level, old, and unused by Go's current HTTP stack. We should have deleted it before Go 1.</source>
          <target state="translated">ServerConn是Go早期HTTP实现的产物。它是低级的、旧的,而且没有被Go当前的HTTP栈使用。我们应该在Go 1之前删除它。</target>
        </trans-unit>
        <trans-unit id="e48e77ca43f54c7c217d619efb9bd95f1a1f8aba" translate="yes" xml:space="preserve">
          <source>ServerError represents an error that has been returned from the remote side of the RPC connection.</source>
          <target state="translated">ServerError表示从RPC连接的远程端返回的错误。</target>
        </trans-unit>
        <trans-unit id="547b92e886182f3f71367607ff47558fb0fe8029" translate="yes" xml:space="preserve">
          <source>ServerInfo records information about an SMTP server.</source>
          <target state="translated">ServerInfo 记录了一个 SMTP 服务器的信息。</target>
        </trans-unit>
        <trans-unit id="870594a7b5d015bba7a8d2c0875c56f2fce85f71" translate="yes" xml:space="preserve">
          <source>SessionResetter may be implemented by Conn to allow drivers to reset the session state associated with the connection and to signal a bad connection.</source>
          <target state="translated">SessionResetter可以由Conn实现,以允许驱动程序重置与连接相关联的会话状态,并发出坏连接的信号。</target>
        </trans-unit>
        <trans-unit id="aab8e5c4d0aeae85893fd621bc37db1b1a73696a" translate="yes" xml:space="preserve">
          <source>Set assigns x to the value v. It panics if CanSet returns false. As in Go, x's value must be assignable to v's type.</source>
          <target state="translated">Set将x赋值给值v,如果CanSet返回false,它就会恐慌。和围棋中一样,x的值必须可以分配给v的类型。</target>
        </trans-unit>
        <trans-unit id="1d2a8709f5b7f411cc9ba583a652581b21b6d185" translate="yes" xml:space="preserve">
          <source>Set is called once, in command line order, for each flag present. The flag package may call the String method with a zero-valued receiver, such as a nil pointer.</source>
          <target state="translated">Set按照命令行顺序,对每个存在的标志调用一次。标志包可以用一个零值的接收器,比如一个nil指针来调用String方法。</target>
        </trans-unit>
        <trans-unit id="e8fb40cfeae3d73e6b30e01495ac2c9fe7ff8cc2" translate="yes" xml:space="preserve">
          <source>Set sets the JavaScript property p of value v to ValueOf(x). It panics if v is not a JavaScript object.</source>
          <target state="translated">Set将值v的JavaScript属性p设置为ValueOf(x)。如果v不是JavaScript对象,它就会恐慌。</target>
        </trans-unit>
        <trans-unit id="87f6096d8457ac4b04a70faa68ba0c62c9f61ecc" translate="yes" xml:space="preserve">
          <source>Set sets the header entries associated with key to the single element value. It replaces any existing values associated with key.</source>
          <target state="translated">设置将与key相关联的头条目设置为单元素值。它替换任何与key相关联的现有值。</target>
        </trans-unit>
        <trans-unit id="82fcf24728ab76cc9481c998a3f5414cead1eb36" translate="yes" xml:space="preserve">
          <source>Set sets the header entries associated with key to the single element value. It replaces any existing values associated with key. The key is case insensitive; it is canonicalized by textproto.CanonicalMIMEHeaderKey. To use non-canonical keys, assign to the map directly.</source>
          <target state="translated">设置将与key相关联的头条目设置为单元素值。它替换任何与key相关联的现有值。key不区分大小写;它由textproto.CanonicalMIMEHeaderKey规范化。要使用非规范的键,请直接分配给地图。</target>
        </trans-unit>
        <trans-unit id="ac88d8d813ac589b26e82c68ebe23a65cc8513a6" translate="yes" xml:space="preserve">
          <source>Set sets the key to value. It replaces any existing values.</source>
          <target state="translated">Set将键值设置为值。它替换任何现有的值。</target>
        </trans-unit>
        <trans-unit id="03d2da815b81b3b89a818437487ee57f67fe7d66" translate="yes" xml:space="preserve">
          <source>Set sets the value of the named command-line flag.</source>
          <target state="translated">设置设置命名的命令行标志的值。</target>
        </trans-unit>
        <trans-unit id="f73f9638b07619a017d2f6dac015fd0d243d8333" translate="yes" xml:space="preserve">
          <source>Set sets the value of the named flag.</source>
          <target state="translated">设置设置命名标志的值。</target>
        </trans-unit>
        <trans-unit id="2c301753363dd5c13e85e87be14b65f72e0bdbb9" translate="yes" xml:space="preserve">
          <source>Set sets v to value.</source>
          <target state="translated">设将v设为值。</target>
        </trans-unit>
        <trans-unit id="0e0649c67f5fc5e092366b50d2ec623dd85834a8" translate="yes" xml:space="preserve">
          <source>Set sets z to the (possibly rounded) value of x and returns z. If z's precision is 0, it is changed to the precision of x before setting z (and rounding will have no effect). Rounding is performed according to z's precision and rounding mode; and z's accuracy reports the result error relative to the exact (not rounded) result.</source>
          <target state="translated">设置z为x的(可能是四舍五入)值,并返回z。如果z的精度为0,则在设置z之前将其改为x的精度(四舍五入没有影响)。四舍五入是根据z的精度和四舍五入模式进行的;z的精度报告了相对于精确(未四舍五入)结果的误差。</target>
        </trans-unit>
        <trans-unit id="74c097d8a8db6198a9f30d1da9cc40810faf97ea" translate="yes" xml:space="preserve">
          <source>Set sets z to x (by making a copy of x) and returns z.</source>
          <target state="translated">设置z为x(通过复制x)并返回z。</target>
        </trans-unit>
        <trans-unit id="2de2c16a0340db2bee0118ccf9d1587fd704cd50" translate="yes" xml:space="preserve">
          <source>Set sets z to x and returns z.</source>
          <target state="translated">设z为x,并返回z。</target>
        </trans-unit>
        <trans-unit id="fd19264e05439f601808981687979a9cbd55329f" translate="yes" xml:space="preserve">
          <source>SetBasicAuth sets the request's Authorization header to use HTTP Basic Authentication with the provided username and password.</source>
          <target state="translated">SetBasicAuth设置请求的授权头使用提供的用户名和密码进行HTTP基本认证。</target>
        </trans-unit>
        <trans-unit id="22bdae472d3db85cab5c57989c6be910d803a01e" translate="yes" xml:space="preserve">
          <source>SetBit sets z to x, with x's i'th bit set to b (0 or 1). That is, if b is 1 SetBit sets z = x | (1 &amp;lt;&amp;lt; i); if b is 0 SetBit sets z = x &amp;amp;^ (1 &amp;lt;&amp;lt; i). If b is not 0 or 1, SetBit will panic.</source>
          <target state="translated">SetBit将z设置为x，将x的第i位设置为b（0或1）。即，如果b为1，则SetBit设置z = x | | | | |。（1 &amp;lt;&amp;lt;我）; 如果b为0 SetBit设置z = x＆^（1 &amp;lt;&amp;lt; i）。如果b不为0或1，则SetBit将发生恐慌。</target>
        </trans-unit>
        <trans-unit id="feba31f1e1635889b9235c6993fbb340077ba325" translate="yes" xml:space="preserve">
          <source>SetBits provides raw (unchecked but fast) access to z by setting its value to abs, interpreted as a little-endian Word slice, and returning z. The result and abs share the same underlying array. SetBits is intended to support implementation of missing low-level Int functionality outside this package; it should be avoided otherwise.</source>
          <target state="translated">SetBits通过将z的值设置为abs来提供对z的原始访问(未被选中但速度很快),将其解释为一个小二进制的Word片断,然后返回z。结果和abs共享同一个底层数组。SetBits的目的是为了支持在本包之外实现缺失的低级Int功能;否则应该避免使用它。</target>
        </trans-unit>
        <trans-unit id="f0a90ede61cca8ba0e26af9fe2c3c6480079bf80" translate="yes" xml:space="preserve">
          <source>SetBlockProfileRate controls the fraction of goroutine blocking events that are reported in the blocking profile. The profiler aims to sample an average of one blocking event per rate nanoseconds spent blocked.</source>
          <target state="translated">SetBlockProfileRate控制在阻塞配置文件中报告的goroutine阻塞事件的分数。剖析器的目标是平均每花一个速率纳秒阻塞事件的样本。</target>
        </trans-unit>
        <trans-unit id="459d3a69d65d385fb3b3fbe398bb9c85138ddcc2" translate="yes" xml:space="preserve">
          <source>SetBool sets v's underlying value. It panics if v's Kind is not Bool or if CanSet() is false.</source>
          <target state="translated">SetBool设置v的底层值,如果v的Kind不是Bool或者CanSet()是false,它就会恐慌。如果v的Kind不是Bool或者CanSet()是false,它就会恐慌。</target>
        </trans-unit>
        <trans-unit id="7e2455227631da0419c37dea6613f51644e9e03d" translate="yes" xml:space="preserve">
          <source>SetBoundary must be called before any parts are created, may only contain certain ASCII characters, and must be non-empty and at most 70 bytes long.</source>
          <target state="translated">SetBoundary必须在创建任何部件之前被调用,只能包含某些ASCII字符,并且必须是非空的,最多只能有70字节长。</target>
        </trans-unit>
        <trans-unit id="b06cf4ca1fda2091c2541de19f0b4a515ade4ba9" translate="yes" xml:space="preserve">
          <source>SetBoundary overrides the Writer's default randomly-generated boundary separator with an explicit value.</source>
          <target state="translated">SetBoundary用一个明确的值覆盖了Writer的默认随机生成的边界分隔符。</target>
        </trans-unit>
        <trans-unit id="6106f2ae31464af3b2e7f9b63e64b76356750152" translate="yes" xml:space="preserve">
          <source>SetBytes interprets buf as the bytes of a big-endian unsigned integer, sets z to that value, and returns z.</source>
          <target state="translated">SetBytes 将 buf 解释为一个大段无符号整数的字节,将 z 设置为该值,并返回 z。</target>
        </trans-unit>
        <trans-unit id="7a0583b12bc86b9434e36c34c4ce6e8b5c26ba75" translate="yes" xml:space="preserve">
          <source>SetBytes records the number of bytes processed in a single operation. If this is called, the benchmark will report ns/op and MB/s.</source>
          <target state="translated">SetBytes记录单次操作中处理的字节数。如果调用此功能,基准将报告ns/op和MB/s。</target>
        </trans-unit>
        <trans-unit id="bba92654aa999e9512f4dfa6313cb2838144dfe3" translate="yes" xml:space="preserve">
          <source>SetBytes sets v's underlying value. It panics if v's underlying value is not a slice of bytes.</source>
          <target state="translated">SetBytes设置v的底层值。如果v的底层值不是一个字节的片断,它就会惊慌失措。</target>
        </trans-unit>
        <trans-unit id="344d8ddf2a696d0cf0cc16a1825af1241c772a89" translate="yes" xml:space="preserve">
          <source>SetCPUProfileRate sets the CPU profiling rate to hz samples per second. If hz &amp;lt;= 0, SetCPUProfileRate turns off profiling. If the profiler is on, the rate cannot be changed without first turning it off.</source>
          <target state="translated">SetCPUProfileRate将CPU分析速率设置为每秒hz个样本。如果hz &amp;lt;= 0，则SetCPUProfileRate关闭分析。如果探查器已打开，则必须先将其关闭才能更改速率。</target>
        </trans-unit>
        <trans-unit id="1afcde63337e23e05a9b84c1c7b85f57c0092cd7" translate="yes" xml:space="preserve">
          <source>SetCap sets v's capacity to n. It panics if v's Kind is not Slice or if n is smaller than the length or greater than the capacity of the slice.</source>
          <target state="translated">SetCap将v的容量设置为n。如果v的Kind不是Slice,或者n小于长度或大于分片的容量,它就会恐慌。</target>
        </trans-unit>
        <trans-unit id="44731bc16b3d80516224c7c852f64732d07d62c1" translate="yes" xml:space="preserve">
          <source>SetCgoTraceback records three C functions to use to gather traceback information from C code and to convert that traceback information into symbolic information. These are used when printing stack traces for a program that uses cgo.</source>
          <target state="translated">SetCgoTraceback记录了三个C函数,用于从C代码中收集回溯信息,并将回溯信息转换为符号信息。这些函数在打印使用cgo的程序的堆栈跟踪信息时使用。</target>
        </trans-unit>
        <trans-unit id="348727b9cf484ab1b9762cea6ba0daa8dde8a933" translate="yes" xml:space="preserve">
          <source>SetCgoTraceback should be called only once, ideally from an init function.</source>
          <target state="translated">SetCgoTraceback应该只被调用一次,最好是在一个init函数中调用。</target>
        </trans-unit>
        <trans-unit id="67fdfbbba9d56846727e0eb32ef8332c0bf20f53" translate="yes" xml:space="preserve">
          <source>SetComment sets the end-of-central-directory comment field. It can only be called before Close.</source>
          <target state="translated">SetComment 设置中心目录结束时的注释字段。它只能在关闭之前被调用。</target>
        </trans-unit>
        <trans-unit id="64f03250bccb0b87aeb45d79cb945d1dd0319cb9" translate="yes" xml:space="preserve">
          <source>SetComplex sets v's underlying value to x. It panics if v's Kind is not Complex64 or Complex128, or if CanSet() is false.</source>
          <target state="translated">如果v的Kind不是Complex64或Complex128,或者CanSet()为false,它就会恐慌。</target>
        </trans-unit>
        <trans-unit id="ac6f79734771b4e3adca460b8931ae634206e20f" translate="yes" xml:space="preserve">
          <source>SetConnMaxLifetime sets the maximum amount of time a connection may be reused.</source>
          <target state="translated">SetConnMaxLifetime设置一个连接可以重复使用的最大时间。</target>
        </trans-unit>
        <trans-unit id="cdfc398e60b71e846a0a56ba3b1860f275a8c713" translate="yes" xml:space="preserve">
          <source>SetCookie adds a Set-Cookie header to the provided ResponseWriter's headers. The provided cookie must have a valid Name. Invalid cookies may be silently dropped.</source>
          <target state="translated">SetCookie 会在所提供的 ResponseWriter 的头文件中添加一个 Set-Cookie 头文件。提供的 cookie 必须有一个有效的 Name。无效的cookie可能会被静静地放弃。</target>
        </trans-unit>
        <trans-unit id="b1b53737e17baa71a51a0e5ede6a121ccba30720" translate="yes" xml:space="preserve">
          <source>SetCookies implements the SetCookies method of the http.CookieJar interface.</source>
          <target state="translated">SetCookies实现了http.CookieJar接口的SetCookies方法。</target>
        </trans-unit>
        <trans-unit id="d3cec8d8761e8a9c75efaa51883455428c208775" translate="yes" xml:space="preserve">
          <source>SetDeadline implements the Conn SetDeadline method.</source>
          <target state="translated">SetDeadline实现Conn SetDeadline方法。</target>
        </trans-unit>
        <trans-unit id="c0b50695667af085ed75f6ae0d7d496b50008cd3" translate="yes" xml:space="preserve">
          <source>SetDeadline sets the deadline associated with the listener. A zero time value disables the deadline.</source>
          <target state="translated">SetDeadline设置与监听器相关联的截止时间。时间值为零则禁用截止时间。</target>
        </trans-unit>
        <trans-unit id="a7b4723a8859169359d85b5290587d68a0fc3307" translate="yes" xml:space="preserve">
          <source>SetDeadline sets the read and write deadlines associated with the connection. A zero value for t means Read and Write will not time out. After a Write has timed out, the TLS state is corrupt and all future writes will return the same error.</source>
          <target state="translated">SetDeadline设置与连接相关的读写截止时间。t的值为零意味着读和写不会超时。写入超时后,TLS状态就会损坏,以后所有的写入都会返回同样的错误。</target>
        </trans-unit>
        <trans-unit id="883b1167470e9a9bc17df175940ef7113ec71b15" translate="yes" xml:space="preserve">
          <source>SetDeadline sets the read and write deadlines for a File. It is equivalent to calling both SetReadDeadline and SetWriteDeadline.</source>
          <target state="translated">SetDeadline设置文件的读和写截止时间。它相当于同时调用SetReadDeadline和SetWriteDeadline。</target>
        </trans-unit>
        <trans-unit id="7aad8c47d1ea7eb52b60d62c5b63c9894a7f6a08" translate="yes" xml:space="preserve">
          <source>SetEscapeHTML specifies whether problematic HTML characters should be escaped inside JSON quoted strings. The default behavior is to escape &amp;amp;, &amp;lt;, and &amp;gt; to \u0026, \u003c, and \u003e to avoid certain safety problems that can arise when embedding JSON in HTML.</source>
          <target state="translated">SetEscapeHTML指定是否应在JSON引用的字符串内转义有问题的HTML字符。缺省行为是将＆，&amp;lt;和&amp;gt;转义为\ u0026，\ u003c和\ u003e，以避免在将JSON嵌入HTML时可能出现的某些安全问题。</target>
        </trans-unit>
        <trans-unit id="dd27241a174aea4c1fb70802e55de9c35c7e1aca" translate="yes" xml:space="preserve">
          <source>SetFinalizer sets the finalizer associated with obj to the provided finalizer function. When the garbage collector finds an unreachable block with an associated finalizer, it clears the association and runs finalizer(obj) in a separate goroutine. This makes obj reachable again, but now without an associated finalizer. Assuming that SetFinalizer is not called again, the next time the garbage collector sees that obj is unreachable, it will free obj.</source>
          <target state="translated">SetFinalizer将与obj关联的finalizer设置为提供的finalizer函数。当垃圾回收器发现一个不可到达的块,并有一个关联的finalizer时,它会清除关联,并在一个单独的goroutine中运行finalizer(obj)。这使得obj再次可达,但现在没有关联的终结器。假设SetFinalizer没有被再次调用,下次垃圾回收器看到obj不可到达时,它将释放obj。</target>
        </trans-unit>
        <trans-unit id="516de8a9b6e7300def0c0d80a14119cce09c9af1" translate="yes" xml:space="preserve">
          <source>SetFinalizer(obj, nil) clears any finalizer associated with obj.</source>
          <target state="translated">SetFinalizer(obj,nil)清除任何与obj相关联的定标器。</target>
        </trans-unit>
        <trans-unit id="fce6aef209330cc8b12176816b79927fb4cacd60" translate="yes" xml:space="preserve">
          <source>SetFlags sets the output flags for the logger.</source>
          <target state="translated">SetFlags 设置记录仪的输出标志。</target>
        </trans-unit>
        <trans-unit id="dd0ec7930cc082a2a1ef8ed98443be56c5746d85" translate="yes" xml:space="preserve">
          <source>SetFlags sets the output flags for the standard logger.</source>
          <target state="translated">SetFlags 设置标准记录器的输出标志。</target>
        </trans-unit>
        <trans-unit id="a44e49f661219c769f20780167a6964483f17f7a" translate="yes" xml:space="preserve">
          <source>SetFloat sets v's underlying value to x. It panics if v's Kind is not Float32 or Float64, or if CanSet() is false.</source>
          <target state="translated">如果v的种类不是Float32或Float64,或者CanSet()为false,它就会恐慌。</target>
        </trans-unit>
        <trans-unit id="8e47d96a49d3af2841a8dc184d5134cb1a32de48" translate="yes" xml:space="preserve">
          <source>SetFloat64 sets z to exactly f and returns z. If f is not finite, SetFloat returns nil.</source>
          <target state="translated">SetFloat64将z精确地设置为f并返回z。如果f不是有限的,SetFloat返回nil。</target>
        </trans-unit>
        <trans-unit id="7d8e2534e02690c3fed1859413bf2f8f63c436f1" translate="yes" xml:space="preserve">
          <source>SetFloat64 sets z to the (possibly rounded) value of x and returns z. If z's precision is 0, it is changed to 53 (and rounding will have no effect). SetFloat64 panics with ErrNaN if x is a NaN.</source>
          <target state="translated">SetFloat64将z设置为x的(可能是四舍五入)值,并返回z。如果z的精度为0,则改为53(四舍五入没有影响)。如果x是NaN,SetFloat64会用ErrNaN恐慌。</target>
        </trans-unit>
        <trans-unit id="7b801568b0fa82e3d000c6cfdb98f7b328836a9b" translate="yes" xml:space="preserve">
          <source>SetFrac sets z to a/b and returns z.</source>
          <target state="translated">SetFrac将z设置为a/b,并返回z。</target>
        </trans-unit>
        <trans-unit id="45fde5eac415722d6b8394ea7547d400d1373021" translate="yes" xml:space="preserve">
          <source>SetFrac64 sets z to a/b and returns z.</source>
          <target state="translated">SetFrac64将z设置为a/b并返回z。</target>
        </trans-unit>
        <trans-unit id="805636f93a7dd0b6aa2183e35b0d00ca6d7104e9" translate="yes" xml:space="preserve">
          <source>SetGCPercent sets the garbage collection target percentage: a collection is triggered when the ratio of freshly allocated data to live data remaining after the previous collection reaches this percentage. SetGCPercent returns the previous setting. The initial setting is the value of the GOGC environment variable at startup, or 100 if the variable is not set. A negative percentage disables garbage collection.</source>
          <target state="translated">SetGCPercent设置垃圾收集目标百分比:当上一次收集后新分配的数据与剩余的活数据的比例达到这个百分比时,就会触发一次收集。SetGCPercent返回之前的设置。初始设置是启动时GOGC环境变量的值,如果没有设置该变量,则为100。负的百分比会禁用垃圾收集。</target>
        </trans-unit>
        <trans-unit id="906978195b1fb386902e36080f453c88d02f6211" translate="yes" xml:space="preserve">
          <source>SetGoroutineLabels sets the current goroutine's labels to match ctx. A new goroutine inherits the labels of the goroutine that created it. This is a lower-level API than Do, which should be used instead when possible.</source>
          <target state="translated">SetGoroutineLabels 设置当前goroutine的标签以匹配ctx。新的goroutine会继承创建它的goroutine的标签。这是一个比Do更低级的API,在可能的情况下应该使用Do。</target>
        </trans-unit>
        <trans-unit id="7c95fdd46823686f50f0d15060d185e4b4e5d563" translate="yes" xml:space="preserve">
          <source>SetImports sets the list of explicitly imported packages to list. It is the caller's responsibility to make sure list elements are unique.</source>
          <target state="translated">SetImports 将显式导入的软件包列表设置为 list。调用者有责任确保列表元素是唯一的。</target>
        </trans-unit>
        <trans-unit id="e7fb2cb55e4274d490452e6757d30cb84eb70855" translate="yes" xml:space="preserve">
          <source>SetIndent instructs the encoder to format each subsequent encoded value as if indented by the package-level function Indent(dst, src, prefix, indent). Calling SetIndent(&quot;&quot;, &quot;&quot;) disables indentation.</source>
          <target state="translated">SetIndent 指示编码器将随后的每个编码值格式化,就像包级函数 Indent(dst,src,prefix,indent)一样缩进。调用SetIndent(&quot;&quot;,&quot;&quot;)会禁用缩进。</target>
        </trans-unit>
        <trans-unit id="17d73d2c7105e3ec880ec1de340daf4f290af178" translate="yes" xml:space="preserve">
          <source>SetIndex sets the JavaScript index i of value v to ValueOf(x). It panics if v is not a JavaScript object.</source>
          <target state="translated">SetIndex将值v的JavaScript索引i设置为ValueOf(x)。如果v不是JavaScript对象,它就会惊慌失措。</target>
        </trans-unit>
        <trans-unit id="cea11721fc2a69428fc01f2bd7212d126248c97a" translate="yes" xml:space="preserve">
          <source>SetInf sets z to the infinite Float -Inf if signbit is set, or +Inf if signbit is not set, and returns z. The precision of z is unchanged and the result is always Exact.</source>
          <target state="translated">SetInf如果设置了signbit,则将z设置为无穷大的Float -Inf,如果没有设置signbit,则设置为+Inf,并返回z,z的精度不变,结果始终为Exact。</target>
        </trans-unit>
        <trans-unit id="7fbe79d67709b54bb947c5fb56d1678d22a06e68" translate="yes" xml:space="preserve">
          <source>SetInt sets v's underlying value to x. It panics if v's Kind is not Int, Int8, Int16, Int32, or Int64, or if CanSet() is false.</source>
          <target state="translated">如果v的Kind不是Int、Int8、Int16、Int32或Int64,或者CanSet()为false,它就会恐慌。</target>
        </trans-unit>
        <trans-unit id="e9791f172aed7c20562244430ee2933689079ec7" translate="yes" xml:space="preserve">
          <source>SetInt sets z to the (possibly rounded) value of x and returns z. If z's precision is 0, it is changed to the larger of x.BitLen() or 64 (and rounding will have no effect).</source>
          <target state="translated">SetInt将z设置为x的(可能是四舍五入)值,并返回z。如果z的精度为0,则改为x.BitLen()或64中较大的一个(四舍五入没有影响)。</target>
        </trans-unit>
        <trans-unit id="512491a3910b089e941ff0967a1c4600d38512e1" translate="yes" xml:space="preserve">
          <source>SetInt sets z to x (by making a copy of x) and returns z.</source>
          <target state="translated">SetInt将z设置为x(通过复制x)并返回z。</target>
        </trans-unit>
        <trans-unit id="e98bca88644a6b411de0d879f43c3dc3a73ef347" translate="yes" xml:space="preserve">
          <source>SetInt64 sets z to the (possibly rounded) value of x and returns z. If z's precision is 0, it is changed to 64 (and rounding will have no effect).</source>
          <target state="translated">SetInt64将z设置为x的(可能是四舍五入)值,并返回z。如果z的精度为0,则改为64(四舍五入没有影响)。</target>
        </trans-unit>
        <trans-unit id="b8bc149266ba57391034d803e65399926af1a382" translate="yes" xml:space="preserve">
          <source>SetInt64 sets z to x and returns z.</source>
          <target state="translated">SetInt64将z设置为x并返回z。</target>
        </trans-unit>
        <trans-unit id="d8ce7465b1093a7258c6cd344217beee671aa978" translate="yes" xml:space="preserve">
          <source>SetKeepAlive sets whether the operating system should send keep-alive messages on the connection.</source>
          <target state="translated">SetKeepAlive设置操作系统是否应该在连接上发送保持活力的消息。</target>
        </trans-unit>
        <trans-unit id="89bf3d4dd275ff44ab7379e669050fce6f5a7eee" translate="yes" xml:space="preserve">
          <source>SetKeepAlivePeriod sets period between keep-alives.</source>
          <target state="translated">SetKeepAlivePeriod设置保持生命的周期。</target>
        </trans-unit>
        <trans-unit id="582102a7fa3d8dd186ee22dfa213a701e54c1846" translate="yes" xml:space="preserve">
          <source>SetKeepAlivesEnabled controls whether HTTP keep-alives are enabled. By default, keep-alives are always enabled. Only very resource-constrained environments or servers in the process of shutting down should disable them.</source>
          <target state="translated">SetKeepAlivesEnabled控制HTTP keep-alives是否被启用。默认情况下,keep-alives总是被启用。只有资源非常有限的环境或正在关闭的服务器才应该禁用它们。</target>
        </trans-unit>
        <trans-unit id="26dfe6afebdd675610dd8f1d4858b29cc7ee92db" translate="yes" xml:space="preserve">
          <source>SetLen sets v's length to n. It panics if v's Kind is not Slice or if n is negative or greater than the capacity of the slice.</source>
          <target state="translated">SetLen 将 v 的长度设置为 n。如果 v 的 Kind 不是 Slice,或者 n 为负值或大于 slice 的容量,它就会恐慌。</target>
        </trans-unit>
        <trans-unit id="549c2b676df9b698394503e0fb62c18e8fa20e0b" translate="yes" xml:space="preserve">
          <source>SetLines sets the line offsets for a file and reports whether it succeeded. The line offsets are the offsets of the first character of each line; for instance for the content &quot;ab\nc\n&quot; the line offsets are {0, 3}. An empty file has an empty line offset table. Each line offset must be larger than the offset for the previous line and smaller than the file size; otherwise SetLines fails and returns false. Callers must not mutate the provided slice after SetLines returns.</source>
          <target state="translated">SetLines设置文件的行偏移量并报告是否成功。行偏移量是每行第一个字符的偏移量;例如对于内容 &quot;ab\nc\n&quot;,行偏移量是{0,3}。一个空文件的行偏移表是空的。每一行的偏移量必须大于前一行的偏移量,并且小于文件大小;否则SetLines会失败并返回false。调用者在SetLines返回后不得突变提供的分片。</target>
        </trans-unit>
        <trans-unit id="d21966bc8423cbdfca9062e709a1e1bfe2b23f9c" translate="yes" xml:space="preserve">
          <source>SetLinesForContent sets the line offsets for the given file content. It ignores position-altering //line comments.</source>
          <target state="translated">SetLinesForContent 设置给定文件内容的行偏移量。它忽略了位置改变的//行注释。</target>
        </trans-unit>
        <trans-unit id="7ead5ff3e458c012090db0e3e46dd956293c59f9" translate="yes" xml:space="preserve">
          <source>SetLinger sets the behavior of Close on a connection which still has data waiting to be sent or to be acknowledged.</source>
          <target state="translated">SetLinger设置关闭连接的行为,如果连接上还有数据等待发送或确认。</target>
        </trans-unit>
        <trans-unit id="be9cec1a054bdf6dae13515b712cb92bca8f03d8" translate="yes" xml:space="preserve">
          <source>SetMantExp sets z to mant &amp;times; 2**exp and returns z. The result z has the same precision and rounding mode as mant. SetMantExp is an inverse of MantExp but does not require 0.5 &amp;lt;= |mant| &amp;lt; 1.0. Specifically:</source>
          <target state="translated">SetMantExp将z设置为mant&amp;times;2 ** exp并返回z。结果z具有与mant相同的精度和舍入模式。SetMantExp是MantExp的倒数，但不需要0.5 &amp;lt;= | mant | &amp;lt;1.0。特别：</target>
        </trans-unit>
        <trans-unit id="e756f252cafbddbad755f1c06583ad4489564d92" translate="yes" xml:space="preserve">
          <source>SetMapIndex sets the element associated with key in the map v to elem. It panics if v's Kind is not Map. If elem is the zero Value, SetMapIndex deletes the key from the map. Otherwise if v holds a nil map, SetMapIndex will panic. As in Go, key's elem must be assignable to the map's key type, and elem's value must be assignable to the map's elem type.</source>
          <target state="translated">SetMapIndex将地图v中与key关联的元素设置为elem。如果v的Kind不是Map,SetMapIndex就会惊慌失措。如果elem是零值,SetMapIndex会从地图中删除key。否则,如果v持有一个nil的地图,SetMapIndex就会惊慌失措。在Go中,key的elem必须可以分配给map的key类型,elem的value必须可以分配给map的elem类型。</target>
        </trans-unit>
        <trans-unit id="b83dfa89acb5e3c977158b5fc2760de63b71e48b" translate="yes" xml:space="preserve">
          <source>SetMaxIdleConns sets the maximum number of connections in the idle connection pool.</source>
          <target state="translated">SetMaxIdleConns设置空闲连接池中的最大连接数。</target>
        </trans-unit>
        <trans-unit id="aa3863aa142a9c48791c290f00a7c4c3d76f3b6e" translate="yes" xml:space="preserve">
          <source>SetMaxOpenConns sets the maximum number of open connections to the database.</source>
          <target state="translated">SetMaxOpenConns设置数据库的最大开放连接数。</target>
        </trans-unit>
        <trans-unit id="f71d21e95f096f232e72fff30f80b920b1e3f9f5" translate="yes" xml:space="preserve">
          <source>SetMaxStack is useful mainly for limiting the damage done by goroutines that enter an infinite recursion. It only limits future stack growth.</source>
          <target state="translated">SetMaxStack的作用主要是限制进入无限递归的goroutine所造成的伤害。它只限制未来的堆栈增长。</target>
        </trans-unit>
        <trans-unit id="eeacbe78a8fd0d4396f1b6456e34f5857612c565" translate="yes" xml:space="preserve">
          <source>SetMaxStack sets the maximum amount of memory that can be used by a single goroutine stack. If any goroutine exceeds this limit while growing its stack, the program crashes. SetMaxStack returns the previous setting. The initial setting is 1 GB on 64-bit systems, 250 MB on 32-bit systems.</source>
          <target state="translated">SetMaxStack设置单个goroutine栈可以使用的最大内存量。如果任何goroutine在增长其堆栈时超过了这个限制,程序就会崩溃。SetMaxStack返回之前的设置。64位系统的初始设置为1GB,32位系统为250MB。</target>
        </trans-unit>
        <trans-unit id="67aff5f59d34d3ecd519adad914c8c6423eaf752" translate="yes" xml:space="preserve">
          <source>SetMaxThreads is useful mainly for limiting the damage done by programs that create an unbounded number of threads. The idea is to take down the program before it takes down the operating system.</source>
          <target state="translated">SetMaxThreads的作用主要是限制那些创建无限制线程数量的程序所造成的损害。这个想法是在程序击垮操作系统之前就将其击垮。</target>
        </trans-unit>
        <trans-unit id="c6d8bc8cae003fe5d78cf6cda31fbae67e36c482" translate="yes" xml:space="preserve">
          <source>SetMaxThreads sets the maximum number of operating system threads that the Go program can use. If it attempts to use more than this many, the program crashes. SetMaxThreads returns the previous setting. The initial setting is 10,000 threads.</source>
          <target state="translated">SetMaxThreads设置了Go程序可以使用的最大操作系统线程数。如果它试图使用超过这个数量的线程,程序就会崩溃。SetMaxThreads 会返回之前的设置。初始设置为10,000个线程。</target>
        </trans-unit>
        <trans-unit id="806ff185f3a93cc6a21f24b12259c49de358388c" translate="yes" xml:space="preserve">
          <source>SetModTime sets the Modified, ModifiedTime, and ModifiedDate fields to the given time in UTC.</source>
          <target state="translated">SetModTime将Modified、ModifiedTime和ModifiedDate字段设置为给定的UTC时间。</target>
        </trans-unit>
        <trans-unit id="e9c592771061ffaaa3d588fb3aae3da84d0635b8" translate="yes" xml:space="preserve">
          <source>SetMode changes the permission and mode bits for the FileHeader.</source>
          <target state="translated">SetMode改变FileHeader的权限和模式位。</target>
        </trans-unit>
        <trans-unit id="de45da11e316c622a3816956315a15e8817585f9" translate="yes" xml:space="preserve">
          <source>SetMode sets z's rounding mode to mode and returns an exact z. z remains unchanged otherwise. z.SetMode(z.Mode()) is a cheap way to set z's accuracy to Exact.</source>
          <target state="translated">z.SetMode将z的四舍五入模式设置为模式,并返回一个精确的z,否则z将保持不变。z.SetMode(z.Mode())是将z的精度设置为精确的廉价方法。</target>
        </trans-unit>
        <trans-unit id="b01a08220867d2b1a3c66f3bf6f8b7ca7ea5c1ae" translate="yes" xml:space="preserve">
          <source>SetMutexProfileFraction controls the fraction of mutex contention events that are reported in the mutex profile. On average 1/rate events are reported. The previous rate is returned.</source>
          <target state="translated">SetMutexProfileFraction控制在mutex profile中报告的mutex争夺事件的分数。平均报告1/率事件。返回之前的速率。</target>
        </trans-unit>
        <trans-unit id="8c38b4a404d96b417f171861cd9ebaba18b51eaf" translate="yes" xml:space="preserve">
          <source>SetName sets the package name.</source>
          <target state="translated">SetName设置软件包的名称。</target>
        </trans-unit>
        <trans-unit id="d31306f3f7eb161aa0c0b28fdb6eed5363c589c3" translate="yes" xml:space="preserve">
          <source>SetNoDelay controls whether the operating system should delay packet transmission in hopes of sending fewer packets (Nagle's algorithm). The default is true (no delay), meaning that data is sent as soon as possible after a Write.</source>
          <target state="translated">SetNoDelay控制操作系统是否应该延迟数据包传输,以希望发送更少的数据包(Nagle算法)。默认值为true(无延迟),即在写入后尽快发送数据。</target>
        </trans-unit>
        <trans-unit id="27a3c03ba54fb2a44f36a6c425cfa58520c56752" translate="yes" xml:space="preserve">
          <source>SetOffset sets the offset of the beginning of the zip data within the underlying writer. It should be used when the zip data is appended to an existing file, such as a binary executable. It must be called before any data is written.</source>
          <target state="translated">SetOffset 设置 zip 数据在底层写入器中开始的偏移量。当zip数据被附加到一个现有的文件,如二进制可执行文件时,它应该被使用。它必须在任何数据被写入之前被调用。</target>
        </trans-unit>
        <trans-unit id="004613f6cff6f004aabdb462fd19757cc3df0edb" translate="yes" xml:space="preserve">
          <source>SetOutput sets the destination for usage and error messages. If output is nil, os.Stderr is used.</source>
          <target state="translated">SetOutput 设置使用情况和错误信息的目的地,如果输出为nil,则使用os.Stderr。如果输出为nil,则使用os.Stderr。</target>
        </trans-unit>
        <trans-unit id="36faf63cafa162e1ef49476325f422ab20f856dd" translate="yes" xml:space="preserve">
          <source>SetOutput sets the output destination for the logger.</source>
          <target state="translated">SetOutput 设置记录仪的输出目的地。</target>
        </trans-unit>
        <trans-unit id="76988d10d7783ed1525981a82207c054e24adba8" translate="yes" xml:space="preserve">
          <source>SetOutput sets the output destination for the standard logger.</source>
          <target state="translated">SetOutput 设置标准记录仪的输出目的地。</target>
        </trans-unit>
        <trans-unit id="2547ce0f12468d65a113d53c2cfbf0ddbb6dc9bb" translate="yes" xml:space="preserve">
          <source>SetPanicOnFault controls the runtime's behavior when a program faults at an unexpected (non-nil) address. Such faults are typically caused by bugs such as runtime memory corruption, so the default response is to crash the program. Programs working with memory-mapped files or unsafe manipulation of memory may cause faults at non-nil addresses in less dramatic situations; SetPanicOnFault allows such programs to request that the runtime trigger only a panic, not a crash. SetPanicOnFault applies only to the current goroutine. It returns the previous setting.</source>
          <target state="translated">SetPanicOnFault控制运行时的行为,当程序在一个意外(非零)的地址发生故障时。这种故障通常是由运行时内存损坏等错误引起的,所以默认的响应是使程序崩溃。使用内存映射文件或不安全的内存操作的程序可能会在不太引人注目的情况下引起非零地址的故障;SetPanicOnFault允许这类程序要求运行时只触发恐慌,而不是崩溃。SetPanicOnFault只适用于当前的goroutine。它返回之前的设置。</target>
        </trans-unit>
        <trans-unit id="72fac8e6222bd170971f1f697af6f11d0715e763" translate="yes" xml:space="preserve">
          <source>SetParallelism sets the number of goroutines used by RunParallel to p*GOMAXPROCS. There is usually no need to call SetParallelism for CPU-bound benchmarks. If p is less than 1, this call will have no effect.</source>
          <target state="translated">SetParallelism将RunParallel使用的goroutine数量设置为p*GOMAXPROCS。对于CPU绑定的基准,通常不需要调用SetParallelism。如果p小于1,这个调用将没有任何效果。</target>
        </trans-unit>
        <trans-unit id="8bcdfe56d7b7abb5a2feda191bae07f8cec5d4b8" translate="yes" xml:space="preserve">
          <source>SetPointer sets the unsafe.Pointer value v to x. It panics if v's Kind is not UnsafePointer.</source>
          <target state="translated">SetPointer将unsafe.Pointer值v设置为x,如果v的Kind不是UnsafePointer,它就会恐慌。</target>
        </trans-unit>
        <trans-unit id="59bd457f6414829faae9decbaede734f70a9845c" translate="yes" xml:space="preserve">
          <source>SetPos sets the position. NewIdentifier is a public method so we can't modify its signature. Chained for convenience. TODO: fix one day?</source>
          <target state="translated">SetPos设置位置。NewIdentifier是一个公共方法,所以我们不能修改它的签名。为了方便起见,链式。TODO:某天修复?</target>
        </trans-unit>
        <trans-unit id="d6d5511f09814008767ff9cfe0f77abca174ef5c" translate="yes" xml:space="preserve">
          <source>SetPrec sets z's precision to prec and returns the (possibly) rounded value of z. Rounding occurs according to z's rounding mode if the mantissa cannot be represented in prec bits without loss of precision. SetPrec(0) maps all finite values to &amp;plusmn;0; infinite values remain unchanged. If prec &amp;gt; MaxPrec, it is set to MaxPrec.</source>
          <target state="translated">SetPrec将z的精度设置为prec并返回z（可能）的舍入值。如果尾数不能以精度位表示的精确尾数，则根据z的舍入模式进行舍入。SetPrec（0）将所有有限值映射为&amp;plusmn;0；无限值保持不变。如果prec&amp;gt; MaxPrec，则将其设置为MaxPrec。</target>
        </trans-unit>
        <trans-unit id="d2d0c71771db3b5022796766d08921a2f8600461" translate="yes" xml:space="preserve">
          <source>SetPrefix sets the output prefix for the logger.</source>
          <target state="translated">SetPrefix 设置记录仪的输出前缀。</target>
        </trans-unit>
        <trans-unit id="6bbad9fae1ec236892af0fd5032d525acd1599d4" translate="yes" xml:space="preserve">
          <source>SetPrefix sets the output prefix for the standard logger.</source>
          <target state="translated">SetPrefix 设置标准记录仪的输出前缀。</target>
        </trans-unit>
        <trans-unit id="ad88a7e02a294ade703b1e817a40a72d93a7117f" translate="yes" xml:space="preserve">
          <source>SetRat sets z to the (possibly rounded) value of x and returns z. If z's precision is 0, it is changed to the largest of a.BitLen(), b.BitLen(), or 64; with x = a/b.</source>
          <target state="translated">SetRat将z设置为x的(可能是四舍五入)值,并返回z。如果z的精度为0,则改为a.BitLen()、b.BitLen()或64中最大的一个;x=a/b。</target>
        </trans-unit>
        <trans-unit id="6d4064f9d933c367ae2ed00ed675edff7a545a0e" translate="yes" xml:space="preserve">
          <source>SetReadBuffer sets the size of the operating system's receive buffer associated with the connection.</source>
          <target state="translated">SetReadBuffer设置操作系统与连接相关的接收缓冲区的大小。</target>
        </trans-unit>
        <trans-unit id="ccd6113cf88478a21eac0a31572f18b8edd4bad3" translate="yes" xml:space="preserve">
          <source>SetReadDeadline implements the Conn SetReadDeadline method.</source>
          <target state="translated">SetReadDeadline实现Conn SetReadDeadline方法。</target>
        </trans-unit>
        <trans-unit id="73112eb9e955bd18073b2a5d03cd0dc0569c7e77" translate="yes" xml:space="preserve">
          <source>SetReadDeadline sets the deadline for future Read calls and any currently-blocked Read call. A zero value for t means Read will not time out. Not all files support setting deadlines; see SetDeadline.</source>
          <target state="translated">SetReadDeadline 设置未来的 Read 调用和任何当前阻塞的 Read 调用的截止时间。t的值为零意味着Read不会超时。并非所有文件都支持设置截止时间,请参见SetDeadline。</target>
        </trans-unit>
        <trans-unit id="fed46b093271b3a5ec6430ef1d4235557caf69e8" translate="yes" xml:space="preserve">
          <source>SetReadDeadline sets the read deadline on the underlying connection. A zero value for t means Read will not time out.</source>
          <target state="translated">SetReadDeadline设置底层连接的读取截止时间。t的值为零意味着读取不会超时。</target>
        </trans-unit>
        <trans-unit id="c85e891cbcac943a2a1c3092ec5cc6bdcd4ebc48" translate="yes" xml:space="preserve">
          <source>SetSessionTicketKeys updates the session ticket keys for a server. The first key will be used when creating new tickets, while all keys can be used for decrypting tickets. It is safe to call this function while the server is running in order to rotate the session ticket keys. The function will panic if keys is empty.</source>
          <target state="translated">SetSessionTicketKeys更新服务器的会话票据密钥。第一个密钥将在创建新票据时使用,而所有密钥都可以用于解密票据。在服务器运行时调用这个函数是安全的,以便轮换会话票据密钥。如果keys为空,该函数会发出警报。</target>
        </trans-unit>
        <trans-unit id="8a945e442cacd2fa72eff38e8c9f6290d8ddbda2" translate="yes" xml:space="preserve">
          <source>SetString sets v's underlying value to x. It panics if v's Kind is not String or if CanSet() is false.</source>
          <target state="translated">如果v的Kind不是String或者CanSet()为false,它就会恐慌。</target>
        </trans-unit>
        <trans-unit id="e889ea521a067b34dab32ac1ec6528fffbf097cc" translate="yes" xml:space="preserve">
          <source>SetString sets z to the value of s and returns z and a boolean indicating success. s can be given as a (possibly signed) fraction &quot;a/b&quot;, or as a floating-point number optionally followed by an exponent. If a fraction is provided, both the dividend and the divisor may be a decimal integer or independently use a prefix of &amp;ldquo;0b&amp;rdquo;, &amp;ldquo;0&amp;rdquo; or &amp;ldquo;0o&amp;rdquo;, or &amp;ldquo;0x&amp;rdquo; (or their upper-case variants) to denote a binary, octal, or hexadecimal integer, respectively. The divisor may not be signed. If a floating-point number is provided, it may be in decimal form or use any of the same prefixes as above but for &amp;ldquo;0&amp;rdquo; to denote a non-decimal mantissa. A leading &amp;ldquo;0&amp;rdquo; is considered a decimal leading 0; it does not indicate octal representation in this case. An optional base-10 &amp;ldquo;e&amp;rdquo; or base-2 &amp;ldquo;p&amp;rdquo; (or their upper-case variants) exponent may be provided as well, except for hexadecimal floats which only accept an (optional) &amp;ldquo;p&amp;rdquo; exponent (because an &amp;ldquo;e&amp;rdquo; or &amp;ldquo;E&amp;rdquo; cannot be distinguished from a mantissa digit). The entire string, not just a prefix, must be valid for success. If the operation failed, the value of z is undefined but the returned value is nil.</source>
          <target state="translated">SetString将z设置为s的值，并返回z和一个指示成功的布尔值。 s可以作为（可能是带符号的）分数&amp;ldquo; a / b&amp;rdquo;给出，也可以作为浮点数（可选地后面跟一个指数）给出。如果提供分数，则除数和除数都可以是十进制整数，或者可以单独使用前缀&amp;ldquo; 0b&amp;rdquo;，&amp;ldquo; 0&amp;rdquo;或&amp;ldquo; 0o&amp;rdquo;或&amp;ldquo; 0x&amp;rdquo;（或它们的大写变体）来表示a二进制，八进制或十六进制整数。除数可能未签名。如果提供了浮点数，则它可以采用十进制形式，也可以使用与上述相同的任何前缀，但&amp;ldquo; 0&amp;rdquo;表示非十进制尾数。前导&amp;ldquo; 0&amp;rdquo;被认为是十进制前导0；在这种情况下，它不表示八进制表示形式。还可以提供可选的base-10&amp;ldquo; e&amp;rdquo;或base-2&amp;ldquo; p​​&amp;rdquo;（或其大写变体）指数，十六进制浮点数除外，该十六进制浮点数仅接受（可选）&amp;ldquo; p&amp;rdquo;指数（因为无法将&amp;ldquo; e&amp;rdquo;或&amp;ldquo; E&amp;rdquo;与尾数位区分开）。整个字符串（不仅仅是前缀）必须有效才能成功。如果操作失败，则z的值不确定，但返回的值为nil。</target>
        </trans-unit>
        <trans-unit id="efbb232582df792d37509713c9b27b267d546a58" translate="yes" xml:space="preserve">
          <source>SetString sets z to the value of s and returns z and a boolean indicating success. s must be a floating-point number of the same format as accepted by Parse, with base argument 0. The entire string (not just a prefix) must be valid for success. If the operation failed, the value of z is undefined but the returned value is nil.</source>
          <target state="translated">SetString将z设置为s的值,并返回z和一个表示成功的布尔值。s必须是一个浮点数,格式与Parse接受的格式相同,基数为0。如果操作失败,z的值是未定义的,但返回的值是nil。</target>
        </trans-unit>
        <trans-unit id="63e18202e9d9aea4fa241b783984e3dc354de835" translate="yes" xml:space="preserve">
          <source>SetString sets z to the value of s, interpreted in the given base, and returns z and a boolean indicating success. The entire string (not just a prefix) must be valid for success. If SetString fails, the value of z is undefined but the returned value is nil.</source>
          <target state="translated">SetString将z设置为s的值,用给定的基数解释,并返回z和一个表示成功的布尔值。整个字符串(不仅仅是前缀)必须是有效的才能成功。如果SetString失败,z的值是未定义的,但返回的值是nil。</target>
        </trans-unit>
        <trans-unit id="38dbbaefe7e4a783f76cb46c7ca92c9417de8b66" translate="yes" xml:space="preserve">
          <source>SetTraceback sets the amount of detail printed by the runtime in the traceback it prints before exiting due to an unrecovered panic or an internal runtime error. The level argument takes the same values as the GOTRACEBACK environment variable. For example, SetTraceback(&quot;all&quot;) ensure that the program prints all goroutines when it crashes. See the package runtime documentation for details. If SetTraceback is called with a level lower than that of the environment variable, the call is ignored.</source>
          <target state="translated">SetTraceback设置运行时在因未恢复的恐慌或内部运行时错误而退出前打印的traceback中的细节量。level参数的取值与GOTRACEBACK环境变量相同。例如,SetTraceback(&quot;all&quot;)确保程序在崩溃时打印所有的goroutine。详情请参见包运行时文档。如果调用SetTraceback的级别低于环境变量的级别,则会被忽略。</target>
        </trans-unit>
        <trans-unit id="2fefbf475ce2643229d0cfdbfe83dace76ec0745" translate="yes" xml:space="preserve">
          <source>SetTree sets the parent tree for the node. NewIdentifier is a public method so we can't modify its signature. Chained for convenience. TODO: fix one day?</source>
          <target state="translated">SetTree设置节点的父树。NewIdentifier是一个公共方法,所以我们不能修改它的签名。为方便起见,采用链式。TODO:某天修复?</target>
        </trans-unit>
        <trans-unit id="c67115f13df235c71277ca4e4cc4cdf9edef929f" translate="yes" xml:space="preserve">
          <source>SetUint sets v's underlying value to x. It panics if v's Kind is not Uint, Uintptr, Uint8, Uint16, Uint32, or Uint64, or if CanSet() is false.</source>
          <target state="translated">如果v的Kind不是Uint、Uintptr、Uint8、Uint16、Uint32或Uint64,或者CanSet()为false,它就会恐慌。</target>
        </trans-unit>
        <trans-unit id="a0d44c574be3e0563cede63a8860a8c3c9c0ea08" translate="yes" xml:space="preserve">
          <source>SetUint64 sets z to the (possibly rounded) value of x and returns z. If z's precision is 0, it is changed to 64 (and rounding will have no effect).</source>
          <target state="translated">SetUint64将z设置为x的(可能是四舍五入)值,并返回z。如果z的精度为0,则改为64(四舍五入没有影响)。</target>
        </trans-unit>
        <trans-unit id="0241edc0d224ec2868d9f80a9b9550102e93ffe8" translate="yes" xml:space="preserve">
          <source>SetUint64 sets z to x and returns z.</source>
          <target state="translated">SetUint64将z设置为x并返回z。</target>
        </trans-unit>
        <trans-unit id="d938745882d5a8df95a9972a3a9bbbee174d3301" translate="yes" xml:space="preserve">
          <source>SetUnderlying sets the underlying type and marks t as complete.</source>
          <target state="translated">SetUnderlying设置底层类型并将t标记为完成。</target>
        </trans-unit>
        <trans-unit id="6743e47079d741cfccfdce2738e02e6efcdc6dc1" translate="yes" xml:space="preserve">
          <source>SetUnlinkOnClose sets whether the underlying socket file should be removed from the file system when the listener is closed.</source>
          <target state="translated">SetUnlinkOnClose设置当监听器关闭时是否应该从文件系统中删除底层套接字文件。</target>
        </trans-unit>
        <trans-unit id="3a7d70c082a7c060c7f1583bead1a8cb995d2129" translate="yes" xml:space="preserve">
          <source>SetWriteBuffer sets the size of the operating system's transmit buffer associated with the connection.</source>
          <target state="translated">SetWriteBuffer设置操作系统与连接相关联的传输缓冲区的大小。</target>
        </trans-unit>
        <trans-unit id="ce72366b97c1e87523bdc3b4986d2a5ed5efea78" translate="yes" xml:space="preserve">
          <source>SetWriteDeadline implements the Conn SetWriteDeadline method.</source>
          <target state="translated">SetWriteDeadline实现Conn SetWriteDeadline方法。</target>
        </trans-unit>
        <trans-unit id="94da0323d7e4b44c2641176fd8ed70132d7e560c" translate="yes" xml:space="preserve">
          <source>SetWriteDeadline sets the deadline for any future Write calls and any currently-blocked Write call. Even if Write times out, it may return n &amp;gt; 0, indicating that some of the data was successfully written. A zero value for t means Write will not time out. Not all files support setting deadlines; see SetDeadline.</source>
          <target state="translated">SetWriteDeadline设置任何将来的Write调用和任何当前阻止的Write调用的截止日期。即使Write超时，它也可能返回n&amp;gt; 0，这表示某些数据已成功写入。t的值为零表示写入不会超时。并非所有文件都支持设置期限。请参阅SetDeadline。</target>
        </trans-unit>
        <trans-unit id="e383d386b9651b389cbae33232566bb47ae2af13" translate="yes" xml:space="preserve">
          <source>SetWriteDeadline sets the write deadline on the underlying connection. A zero value for t means Write will not time out. After a Write has timed out, the TLS state is corrupt and all future writes will return the same error.</source>
          <target state="translated">SetWriteDeadline设置底层连接的写入截止时间。t的值为零意味着Write不会超时。写入超时后,TLS状态就会损坏,以后所有的写入都会返回同样的错误。</target>
        </trans-unit>
        <trans-unit id="308be1977132bdbc81c0f89a2767dd32da76c702" translate="yes" xml:space="preserve">
          <source>Setenv sets the value of the environment variable named by the key. It returns an error, if any.</source>
          <target state="translated">Setenv设置键命名的环境变量的值。如果有错误,它会返回一个错误。</target>
        </trans-unit>
        <trans-unit id="509f2c6d0467d5d83c9526f638c505af46797567" translate="yes" xml:space="preserve">
          <source>Setters, numeric operations and predicates are represented as methods of the form:</source>
          <target state="translated">设置器、数值运算和谓词都以方法的形式表示。</target>
        </trans-unit>
        <trans-unit id="8b84f9f04ca185b4b399c76c8fc7c01ef4f564e3" translate="yes" xml:space="preserve">
          <source>Shift returns the result of the shift expression x op s with op == token.SHL or token.SHR (&amp;lt;&amp;lt; or &amp;gt;&amp;gt;). x must be an Int or an Unknown. If x is Unknown, the result is x.</source>
          <target state="translated">Shift返回带有op == token.SHL或token.SHR（&amp;lt;&amp;lt;或&amp;gt;&amp;gt;）的移位表达式x op s的结果。x必须是Int或Unknown。如果x为未知，则结果为x。</target>
        </trans-unit>
        <trans-unit id="fde43f2305da307b56958af17198c21e47808653" translate="yes" xml:space="preserve">
          <source>Short reports whether the -test.short flag is set.</source>
          <target state="translated">Short报告是否设置了-test.short标志。</target>
        </trans-unit>
        <trans-unit id="5b772b7bfd0a43273fb7c5f49a6c16d837261f35" translate="yes" xml:space="preserve">
          <source>Shuffle</source>
          <target state="translated">Shuffle</target>
        </trans-unit>
        <trans-unit id="79a2c163367d393e517ed372229f5d310534a9d9" translate="yes" xml:space="preserve">
          <source>Shuffle (SlicesInUnison)</source>
          <target state="translated">Shuffle (SlicesInUnison)</target>
        </trans-unit>
        <trans-unit id="732d9d1b7fa9ce160a254c0eec34ec29c54e1b79" translate="yes" xml:space="preserve">
          <source>Shuffle pseudo-randomizes the order of elements using the default Source. n is the number of elements. Shuffle panics if n &amp;lt; 0. swap swaps the elements with indexes i and j.</source>
          <target state="translated">使用默认Source随机伪随机化元素的顺序。n是元素数。如果n &amp;lt;0，则洗礼恐慌。swap交换索引为i和j的元素。</target>
        </trans-unit>
        <trans-unit id="6d3cd15e0fd6a7a5b1756b9af5c51872006c475b" translate="yes" xml:space="preserve">
          <source>Shuffle pseudo-randomizes the order of elements. n is the number of elements. Shuffle panics if n &amp;lt; 0. swap swaps the elements with indexes i and j.</source>
          <target state="translated">随机伪随机化元素的顺序。n是元素数。如果n &amp;lt;0，则洗礼恐慌。swap交换索引为i和j的元素。</target>
        </trans-unit>
        <trans-unit id="8e0c7b7cdf248102d52e5f44dcd474d4d82c359e" translate="yes" xml:space="preserve">
          <source>Shutdown does not attempt to close nor wait for hijacked connections such as WebSockets. The caller of Shutdown should separately notify such long-lived connections of shutdown and wait for them to close, if desired. See RegisterOnShutdown for a way to register shutdown notification functions.</source>
          <target state="translated">Shutdown不会试图关闭也不会等待被劫持的连接,比如WebSockets。如果需要的话,Shutdown的调用者应该单独通知这些长期存在的连接关闭并等待它们关闭。参见RegisterOnShutdown,了解注册关机通知函数的方法。</target>
        </trans-unit>
        <trans-unit id="38dcf86ad76a9ad474561d4239201b3f812c81b9" translate="yes" xml:space="preserve">
          <source>Shutdown gracefully shuts down the server without interrupting any active connections. Shutdown works by first closing all open listeners, then closing all idle connections, and then waiting indefinitely for connections to return to idle and then shut down. If the provided context expires before the shutdown is complete, Shutdown returns the context's error, otherwise it returns any error returned from closing the Server's underlying Listener(s).</source>
          <target state="translated">Shutdown可以在不中断任何活动连接的情况下优雅地关闭服务器。Shutdown的工作方式是首先关闭所有打开的监听器,然后关闭所有空闲的连接,然后无限期地等待连接恢复到空闲状态,然后关闭。如果所提供的上下文在关闭完成之前过期,Shutdown 将返回上下文的错误,否则它将返回关闭服务器的底层监听器所返回的任何错误。</target>
        </trans-unit>
        <trans-unit id="8b3d8d665a765918b70a3f5f0378d51df00b92dd" translate="yes" xml:space="preserve">
          <source>Sign</source>
          <target state="translated">Sign</target>
        </trans-unit>
        <trans-unit id="4dc2181e93ae969f803429357fe579abd176b4b4" translate="yes" xml:space="preserve">
          <source>Sign returns -1, 0, or 1 depending on whether x &amp;lt; 0, x == 0, or x &amp;gt; 0; x must be numeric or Unknown. For complex values x, the sign is 0 if x == 0, otherwise it is != 0. If x is Unknown, the result is 1.</source>
          <target state="translated">根据x &amp;lt;0，x == 0或x&amp;gt; 0，符号返回-1、0或1。x必须为数字或未知。对于复数值x，如果x == 0，则符号为0，否则为！=0。如果x为Unknown，则结果为1。</target>
        </trans-unit>
        <trans-unit id="b52aac6f1207124113d4a678eb49a1b5cf712f7a" translate="yes" xml:space="preserve">
          <source>Sign returns:</source>
          <target state="translated">签回。</target>
        </trans-unit>
        <trans-unit id="6589591f2f20ffb39adee81e8ba10edbe7dacc2e" translate="yes" xml:space="preserve">
          <source>Sign signs a hash (which should be the result of hashing a larger message) using the private key, priv. If the hash is longer than the bit-length of the private key's curve order, the hash will be truncated to that length. It returns the signature as a pair of integers. The security of the private key depends on the entropy of rand.</source>
          <target state="translated">Sign使用私钥priv签署一个哈希值(应该是对一个较大的消息进行哈希的结果)。如果散列的长度超过了私钥的曲线顺序的位长,那么散列将被截断到这个长度。它以一对整数的形式返回签名。私钥的安全性取决于rand的熵。</target>
        </trans-unit>
        <trans-unit id="311212195f2e7e53bfbdc1974b3a767400f6e3ff" translate="yes" xml:space="preserve">
          <source>Sign signs an arbitrary length hash (which should be the result of hashing a larger message) using the private key, priv. It returns the signature as a pair of integers. The security of the private key depends on the entropy of rand.</source>
          <target state="translated">Sign使用私钥priv签署一个任意长度的散列(应该是对一个较大的消息进行散列的结果)。它以一对整数的形式返回签名。私钥的安全性取决于 rand 的熵。</target>
        </trans-unit>
        <trans-unit id="cd714756dfd32673e7a5fdf4e7a7d3f4c1f0476c" translate="yes" xml:space="preserve">
          <source>Sign signs digest with priv, reading randomness from rand. If opts is a *PSSOptions then the PSS algorithm will be used, otherwise PKCS#1 v1.5 will be used.</source>
          <target state="translated">用priv进行标志数字化,从rand中读取随机性。如果opts是一个*PSSOptions,那么将使用PSS算法,否则将使用PKCS#1 v1.5。</target>
        </trans-unit>
        <trans-unit id="725a324c83bff5484063c9fb79ed06b1a642a7c9" translate="yes" xml:space="preserve">
          <source>Sign signs digest with priv, reading randomness from rand. The opts argument is not currently used but, in keeping with the crypto.Signer interface, should be the hash function used to digest the message.</source>
          <target state="translated">Sign用priv签署摘要,从rand读取随机性。opts 参数目前还没有使用,但为了与 crypto.Signer 接口保持一致,应该是用来消化消息的哈希函数。</target>
        </trans-unit>
        <trans-unit id="cb5cc6baa9959aae2928064eeabac37026d1fdd3" translate="yes" xml:space="preserve">
          <source>Sign signs the given message with priv. Ed25519 performs two passes over messages to be signed and therefore cannot handle pre-hashed messages. Thus opts.HashFunc() must return zero to indicate the message hasn't been hashed. This can be achieved by passing crypto.Hash(0) as the value for opts.</source>
          <target state="translated">Sign 用 priv.Sign 对给定的消息进行签名。Ed25519 会对要签名的消息进行两次传递,因此不能处理预哈希的消息。因此 opts.HashFunc()必须返回 0 来表示消息还没有被哈希。这可以通过传递 crypto.Hash(0)作为 opts.HashFunc()的值来实现。</target>
        </trans-unit>
        <trans-unit id="8d9bc9097d624689f3abd051873c0827e390ddd8" translate="yes" xml:space="preserve">
          <source>Sign signs the message with privateKey and returns a signature. It will panic if len(privateKey) is not PrivateKeySize.</source>
          <target state="translated">Sign用privateKey签署消息并返回签名。如果len(privateKey)不是PrivateKeySize,它将会恐慌。</target>
        </trans-unit>
        <trans-unit id="73058d5661f51255d2d044bad5e22d1dbeb1615f" translate="yes" xml:space="preserve">
          <source>SignPKCS1v15</source>
          <target state="translated">SignPKCS1v15</target>
        </trans-unit>
        <trans-unit id="76a7f1a903c9bd79d05146e331e0afbf510916e4" translate="yes" xml:space="preserve">
          <source>SignPKCS1v15 calculates the signature of hashed using RSASSA-PKCS1-V1_5-SIGN from RSA PKCS#1 v1.5. Note that hashed must be the result of hashing the input message using the given hash function. If hash is zero, hashed is signed directly. This isn't advisable except for interoperability.</source>
          <target state="translated">SignPKCS1v15使用RSASSA-PKCS1-V1_5-SIGN从RSA PKCS#1 v1.5计算哈希的签名。注意,哈希必须是使用给定的哈希函数对输入信息进行哈希处理的结果。如果哈希值为零,则直接对哈希值进行签名。除了为了互操作性,这并不可取。</target>
        </trans-unit>
        <trans-unit id="4dc02ffb85c827150cad191cf75b74252c850c11" translate="yes" xml:space="preserve">
          <source>SignPSS calculates the signature of hashed using RSASSA-PSS [1]. Note that hashed must be the result of hashing the input message using the given hash function. The opts argument may be nil, in which case sensible defaults are used.</source>
          <target state="translated">SignPSS使用RSASSA-PSS[1]计算哈希的签名。注意哈希必须是使用给定的哈希函数对输入信息进行哈希处理的结果。opts参数可能为零,在这种情况下,会使用合理的默认值。</target>
        </trans-unit>
        <trans-unit id="456ecb37c3fc5855213ab977448f009637d487e9" translate="yes" xml:space="preserve">
          <source>Signal sends a signal to the Process. Sending Interrupt on Windows is not implemented.</source>
          <target state="translated">信号向进程发送信号。在Windows上没有实现发送中断。</target>
        </trans-unit>
        <trans-unit id="113054b65e3d478c55ce8ee9e7136eef91adbb6a" translate="yes" xml:space="preserve">
          <source>Signal wakes one goroutine waiting on c, if there is any.</source>
          <target state="translated">如果有的话,信号会唤醒一个等待c的goroutine。</target>
        </trans-unit>
        <trans-unit id="2346a18ea3002ff04eca3a130c7f40e65c56f0c9" translate="yes" xml:space="preserve">
          <source>Signals</source>
          <target state="translated">Signals</target>
        </trans-unit>
        <trans-unit id="9a761dffcc7f2df5b531ae01c6e9c1d10354c3aa" translate="yes" xml:space="preserve">
          <source>Signals are primarily used on Unix-like systems. For the use of this package on Windows and Plan 9, see below.</source>
          <target state="translated">信号主要用于类Unix系统上。关于在Windows和Plan 9上使用该软件包,请参见下文。</target>
        </trans-unit>
        <trans-unit id="be08fe4d5181cd9a339446858cf8e98d5d370ad9" translate="yes" xml:space="preserve">
          <source>SignatureScheme identifies a signature algorithm supported by TLS. See RFC 8446, Section 4.2.3.</source>
          <target state="translated">SignatureScheme标识TLS支持的签名算法。参见RFC 8446,4.2.3节。</target>
        </trans-unit>
        <trans-unit id="72364e765319ca6184606bdfcbeaf4bae3efe083" translate="yes" xml:space="preserve">
          <source>Signbit reports whether x is negative or negative zero.</source>
          <target state="translated">Signbit报告x是负数还是负零。</target>
        </trans-unit>
        <trans-unit id="06f0622cc55ee3b1ba8ef5291dd67f388a633bbf" translate="yes" xml:space="preserve">
          <source>Signed integers may be received into any signed integer variable: int, int16, etc.; unsigned integers may be received into any unsigned integer variable; and floating point values may be received into any floating point variable. However, the destination variable must be able to represent the value or the decode operation will fail.</source>
          <target state="translated">有符号整数可以接收到任何有符号整数变量:int、int16等;无符号整数可以接收到任何无符号整数变量;浮点值可以接收到任何浮点变量。但是,目的变量必须能够表示该值,否则解码操作将失败。</target>
        </trans-unit>
        <trans-unit id="ae900b849a1bf306b492bb9034be4bb3bc19b163" translate="yes" xml:space="preserve">
          <source>Signer is an interface for an opaque private key that can be used for signing operations. For example, an RSA key kept in a hardware module.</source>
          <target state="translated">Signer是一个不透明的私钥的接口,可以用来进行签名操作。例如,保存在硬件模块中的RSA密钥。</target>
        </trans-unit>
        <trans-unit id="38f4531ed194c331b7b23a6d3502ef6906c2f74a" translate="yes" xml:space="preserve">
          <source>SignerOpts contains options for signing with a Signer.</source>
          <target state="translated">SignerOpts包含了与签名者签名的选项。</target>
        </trans-unit>
        <trans-unit id="966d50452c96c3fa11f316a011f44cf776d22a17" translate="yes" xml:space="preserve">
          <source>SimpleFold</source>
          <target state="translated">SimpleFold</target>
        </trans-unit>
        <trans-unit id="8bf97e6e8efa121264307227008493331dea504d" translate="yes" xml:space="preserve">
          <source>SimpleFold iterates over Unicode code points equivalent under the Unicode-defined simple case folding. Among the code points equivalent to rune (including rune itself), SimpleFold returns the smallest rune &amp;gt; r if one exists, or else the smallest rune &amp;gt;= 0. If r is not a valid Unicode code point, SimpleFold(r) returns r.</source>
          <target state="translated">SimpleFold遍历Unicode定义的简单大小写折叠下的等效Unicode代码点。在相当于符文的代码点（包括符文本身）中，如果存在，则SimpleFold返回最小的符文&amp;gt; r，否则，返回最小的符文&amp;gt; =0。如果r不是有效的Unicode代码点，则Si​​mpleFold（r）返回r。</target>
        </trans-unit>
        <trans-unit id="b27adf68197f928a987f44243ba3dcfcda229444" translate="yes" xml:space="preserve">
          <source>Simplify returns a regexp equivalent to re but without counted repetitions and with various other simplifications, such as rewriting /(?:a+)+/ to /a+/. The resulting regexp will execute correctly but its string representation will not produce the same parse tree, because capturing parentheses may have been duplicated or removed. For example, the simplified form for /(x){1,2}/ is /(x)(x)?/ but both parentheses capture as $1. The returned regexp may share structure with or be the original.</source>
          <target state="translated">Simplify 返回一个与 re 相当的 regexp,但没有计数重复,并进行了各种其他简化,例如将 /(?:a+)+/重写为 /a+/。由此产生的regexp将正确执行,但它的字符串表示方式将不会产生相同的解析树,因为捕获括号可能被重复或删除。例如,/(x){1,2}/的简化形式是/(x)(x)?/,但两个小括号都被捕获为$1.返回的regexp可能与原始的regexp共享结构,也可能是原始的regexp。</target>
        </trans-unit>
        <trans-unit id="1baaf4288309b641acaf8ca1164546c4028a35a7" translate="yes" xml:space="preserve">
          <source>Sin</source>
          <target state="translated">Sin</target>
        </trans-unit>
        <trans-unit id="60fef841296be9ebf7de4bce978c61ea99668ac2" translate="yes" xml:space="preserve">
          <source>Sin returns the sine of the radian argument x.</source>
          <target state="translated">Sin 返回弧度参数x的正弦值。</target>
        </trans-unit>
        <trans-unit id="2d7deeeba21d579c050c2a33e2db608612f16ced" translate="yes" xml:space="preserve">
          <source>Sin returns the sine of x.</source>
          <target state="translated">Sin 返回 x 的正弦值。</target>
        </trans-unit>
        <trans-unit id="032d0e9143af25fee0463a47b08e83403e61fbe1" translate="yes" xml:space="preserve">
          <source>Since os.FileInfo's Name method only returns the base name of the file it describes, it may be necessary to modify Header.Name to provide the full path name of the file.</source>
          <target state="translated">由于 os.FileInfo 的 Name 方法只返回它所描述的文件的基本名称,因此可能需要修改 Header.Name 来提供文件的完整路径名。</target>
        </trans-unit>
        <trans-unit id="b67e676cda98cae04b5ce1604ab8e9db4fbb0636" translate="yes" xml:space="preserve">
          <source>Since returns the time elapsed since t. It is shorthand for time.Now().Sub(t).</source>
          <target state="translated">它是time.Now().Sub(t)的速记。</target>
        </trans-unit>
        <trans-unit id="4aada6d4483746dcd60dcf298d86136630d9cd91" translate="yes" xml:space="preserve">
          <source>Sincos</source>
          <target state="translated">Sincos</target>
        </trans-unit>
        <trans-unit id="602eea7f1523e01bb1b745122d12becc2cb4a99c" translate="yes" xml:space="preserve">
          <source>Sincos returns Sin(x), Cos(x).</source>
          <target state="translated">Sincos 返回 Sin(x),Cos(x)。</target>
        </trans-unit>
        <trans-unit id="bc9965f20c0e26db0501d3424c1430869ed3389f" translate="yes" xml:space="preserve">
          <source>Single characters:</source>
          <target state="translated">单字。</target>
        </trans-unit>
        <trans-unit id="e5d65368cdcef8d43d81f8b1167171bcc9e4d453" translate="yes" xml:space="preserve">
          <source>Sinh</source>
          <target state="translated">Sinh</target>
        </trans-unit>
        <trans-unit id="f35b8f7d99b41bcac88dc066f89ded4a25031767" translate="yes" xml:space="preserve">
          <source>Sinh returns the hyperbolic sine of x.</source>
          <target state="translated">Sinh返回x的双曲正弦。</target>
        </trans-unit>
        <trans-unit id="9d9b9bb8ffbb101e667ceeb0c6df4b2d00eca63e" translate="yes" xml:space="preserve">
          <source>Size returns how many bytes Write would generate to encode the value v, which must be a fixed-size value or a slice of fixed-size values, or a pointer to such data. If v is neither of these, Size returns -1.</source>
          <target state="translated">Size 返回 Write 将产生多少字节来编码 v 值,它必须是一个固定大小的值或固定大小值的片断,或者是一个指向此类数据的指针。如果v不是这两种,Size返回-1。</target>
        </trans-unit>
        <trans-unit id="07f99b9766acbd34a40dce6ae52199b1df82e565" translate="yes" xml:space="preserve">
          <source>Size returns r's width and height.</source>
          <target state="translated">Size 返回 r 的宽度和高度。</target>
        </trans-unit>
        <trans-unit id="08603885cb8f4581e6caff80c9587384030d6fb2" translate="yes" xml:space="preserve">
          <source>Size returns the length, in bytes, of a digest resulting from the given hash function. It doesn't require that the hash function in question be linked into the program.</source>
          <target state="translated">Size 返回由给定哈希函数产生的摘要的长度,以字节为单位。它并不要求相关的哈希函数被链接到程序中。</target>
        </trans-unit>
        <trans-unit id="e25ab5f340eca2d7c5b223c77e15ee75cde585ef" translate="yes" xml:space="preserve">
          <source>Size returns the modulus size in bytes. Raw signatures and ciphertexts for or by this public key will have the same size.</source>
          <target state="translated">Size 返回以字节为单位的模数大小。原始签名和这个公钥的加密文本的大小是一样的。</target>
        </trans-unit>
        <trans-unit id="e670e1a5854b86fb3e790eec7802ceb4072867ce" translate="yes" xml:space="preserve">
          <source>Size returns the number of leading ones and total bits in the mask. If the mask is not in the canonical form--ones followed by zeros--then Size returns 0, 0.</source>
          <target state="translated">Size 返回掩码中的前导一和总位数。</target>
        </trans-unit>
        <trans-unit id="e50e49a71b6948817b0c75a5802d436dcfbbd3d4" translate="yes" xml:space="preserve">
          <source>Size returns the original length of the underlying byte slice. Size is the number of bytes available for reading via ReadAt. The returned value is always the same and is not affected by calls to any other method.</source>
          <target state="translated">Size 返回底层字节分片的原始长度。Size是通过ReadAt读取的可用字节数。返回的值总是相同的,并且不受任何其他方法调用的影响。</target>
        </trans-unit>
        <trans-unit id="20090954ae229cf40fcf85ad90018bc0a50c14a6" translate="yes" xml:space="preserve">
          <source>Size returns the original length of the underlying string. Size is the number of bytes available for reading via ReadAt. The returned value is always the same and is not affected by calls to any other method.</source>
          <target state="translated">Size 返回底层字符串的原始长度。Size是通过ReadAt读取的可用字节数。返回的值总是相同的,并且不受任何其他方法调用的影响。</target>
        </trans-unit>
        <trans-unit id="5a0d609fe825a666e200f379bb9b290e727375b4" translate="yes" xml:space="preserve">
          <source>Size returns the size of file f as registered with AddFile.</source>
          <target state="translated">Size 返回用 AddFile 注册的文件 f 的大小。</target>
        </trans-unit>
        <trans-unit id="5716d3e163196d9c451e87a39bff7287017defa9" translate="yes" xml:space="preserve">
          <source>Size returns the size of the section in bytes.</source>
          <target state="translated">Size 以字节为单位返回该部分的大小。</target>
        </trans-unit>
        <trans-unit id="33687cc2c12d65398be28bdfb49be5c9af20dea4" translate="yes" xml:space="preserve">
          <source>Size returns the size of the underlying buffer in bytes.</source>
          <target state="translated">Size以字节为单位返回底层缓冲区的大小。</target>
        </trans-unit>
        <trans-unit id="ad326c620cb25aa3f6f88fe50584af3756cb7137" translate="yes" xml:space="preserve">
          <source>Sizeof takes an expression x of any type and returns the size in bytes of a hypothetical variable v as if v was declared via var v = x. The size does not include any memory possibly referenced by x. For instance, if x is a slice, Sizeof returns the size of the slice descriptor, not the size of the memory referenced by the slice. The return value of Sizeof is a Go constant.</source>
          <target state="translated">Sizeof接受一个任意类型的表达式x,并以字节为单位返回一个假设变量v的大小,就像v是通过var v=x声明的一样。例如,如果x是一个分片,Sizeof返回分片描述符的大小,而不是分片所引用的内存的大小。Sizeof 的返回值是一个 Go 常量。</target>
        </trans-unit>
        <trans-unit id="b19905df7d36355c364fc4d465be7029063705c6" translate="yes" xml:space="preserve">
          <source>Sizes defines the sizing functions for package unsafe.</source>
          <target state="translated">Sizes定义了包不安全的大小函数。</target>
        </trans-unit>
        <trans-unit id="58588dd4d69fcc2bebbb32cb3311a65197ef6d80" translate="yes" xml:space="preserve">
          <source>SizesFor returns the Sizes used by a compiler for an architecture. The result is nil if a compiler/architecture pair is not known.</source>
          <target state="translated">SizesFor 返回一个编译器对一个架构使用的 Sizes。如果不知道编译器/架构对,结果为零。</target>
        </trans-unit>
        <trans-unit id="f2bf90f6b1f23cb7aca2de8f99806d297f79d8f6" translate="yes" xml:space="preserve">
          <source>Skip is equivalent to Log followed by SkipNow.</source>
          <target state="translated">跳过相当于Log,后面是SkipNow。</target>
        </trans-unit>
        <trans-unit id="16403f951a4dfc8a1c243a0f8eb301e145aaacf2" translate="yes" xml:space="preserve">
          <source>Skip reads tokens until it has consumed the end element matching the most recent start element already consumed. It recurs if it encounters a start element, so it can be used to skip nested structures. It returns nil if it finds an end element matching the start element; otherwise it returns an error describing the problem.</source>
          <target state="translated">跳过读取标记,直到消耗完与最近消耗的起始元素相匹配的结束元素。如果遇到起始元素,它就会递归,所以它可以用来跳过嵌套结构。如果它发现了一个与起始元素相匹配的结束元素,它就返回nil;否则它就返回一个描述问题的错误。</target>
        </trans-unit>
        <trans-unit id="70514769bf0cf43aa1fd9a8170e861cfc268114d" translate="yes" xml:space="preserve">
          <source>SkipChildren skips over the child entries associated with the last Entry returned by Next. If that Entry did not have children or Next has not been called, SkipChildren is a no-op.</source>
          <target state="translated">SkipChildren 跳过与 Next 返回的最后一个条目相关联的子条目。如果该条目没有子条目,或者Next没有被调用,SkipChildren是一个no-op。</target>
        </trans-unit>
        <trans-unit id="306f2cf9cd44bb1158534a5fe5beb03317afa4af" translate="yes" xml:space="preserve">
          <source>SkipDir is used as a return value from WalkFuncs to indicate that the directory named in the call is to be skipped. It is not returned as an error by any function.</source>
          <target state="translated">SkipDir是WalkFuncs的一个返回值,用于指示调用中命名的目录要被跳过。任何函数都不会将其作为错误返回。</target>
        </trans-unit>
        <trans-unit id="a9f977172633094ba7da3e08af3ab05c0c517aa4" translate="yes" xml:space="preserve">
          <source>SkipNow marks the test as having been skipped and stops its execution by calling runtime.Goexit. If a test fails (see Error, Errorf, Fail) and is then skipped, it is still considered to have failed. Execution will continue at the next test or benchmark. See also FailNow. SkipNow must be called from the goroutine running the test, not from other goroutines created during the test. Calling SkipNow does not stop those other goroutines.</source>
          <target state="translated">SkipNow 将测试标记为已被跳过,并通过调用 runtime.Goexit 停止其执行。如果一个测试失败了(见Error,Errorf,Fail),然后被跳过,它仍然被认为是失败的。执行将在下一个测试或基准继续。也请参见FailNow。SkipNow必须从运行测试的goroutine中调用,而不是从测试期间创建的其他goroutine中调用。调用SkipNow并不会使这些其他goroutine停止。</target>
        </trans-unit>
        <trans-unit id="332b0733aeb219d3842af5da1737b4332e8bb58a" translate="yes" xml:space="preserve">
          <source>Skipf is equivalent to Logf followed by SkipNow.</source>
          <target state="translated">Skipf相当于Logf,其次是SkipNow。</target>
        </trans-unit>
        <trans-unit id="416b07f26916aed7cb9e2ecd9aa8ab976885e47e" translate="yes" xml:space="preserve">
          <source>Skipped reports whether the test was skipped.</source>
          <target state="translated">Skipped(跳过)报告是否跳过测试。</target>
        </trans-unit>
        <trans-unit id="22c22c92516b167e48a8850862fd9d43b049ad6a" translate="yes" xml:space="preserve">
          <source>Skipping</source>
          <target state="translated">Skipping</target>
        </trans-unit>
        <trans-unit id="3cac34e674464c2b62286054cd9a2d2c81149efc" translate="yes" xml:space="preserve">
          <source>Sleep</source>
          <target state="translated">Sleep</target>
        </trans-unit>
        <trans-unit id="53bb6e499b626b0d907f8d7f80059af55f685b40" translate="yes" xml:space="preserve">
          <source>Sleep pauses the current goroutine for at least the duration d. A negative or zero duration causes Sleep to return immediately.</source>
          <target state="translated">睡眠暂停当前goroutine至少持续时间d,负值或零持续时间会使睡眠立即返回。</target>
        </trans-unit>
        <trans-unit id="0c8525a31f225d6db84222cdc68f43cb8c6c18bf" translate="yes" xml:space="preserve">
          <source>Slice</source>
          <target state="translated">Slice</target>
        </trans-unit>
        <trans-unit id="4972372ab292852581dde17e7410c1a0a34536d2" translate="yes" xml:space="preserve">
          <source>Slice returns v[i:j]. It panics if v's Kind is not Array, Slice or String, or if v is an unaddressable array, or if the indexes are out of bounds.</source>
          <target state="translated">Slice 返回 v[i:j]。如果v的类型不是Array、Slice或String,或者v是一个不可寻址的数组,或者索引超出了边界,它就会恐慌。</target>
        </trans-unit>
        <trans-unit id="f664f65e07ee83c0603b67c75f98aa98e653bee6" translate="yes" xml:space="preserve">
          <source>Slice sorts the provided slice given the provided less function.</source>
          <target state="translated">Slice对所提供的slice进行排序,给定了所提供的less函数。</target>
        </trans-unit>
        <trans-unit id="c9c2b1fb38f90f114fb07f736146472316c1fd01" translate="yes" xml:space="preserve">
          <source>Slice values are deeply equal when all of the following are true: they are both nil or both non-nil, they have the same length, and either they point to the same initial entry of the same underlying array (that is, &amp;amp;x[0] == &amp;amp;y[0]) or their corresponding elements (up to length) are deeply equal. Note that a non-nil empty slice and a nil slice (for example, []byte{} and []byte(nil)) are not deeply equal.</source>
          <target state="translated">当满足以下所有条件时，切片值将完全相等：它们均为nil或均为非nil，它们具有相同的长度，并且它们指向同一基础数组的相同初始条目（即＆x [0 ] ==＆y [0]）或它们相应的元素（最大长度）相等。请注意，非nil空片和nil片（例如[] byte {}和[] byte（nil））并不完全相等。</target>
        </trans-unit>
        <trans-unit id="187ce922ba02cf6f5feb1dc1495c357805a44a28" translate="yes" xml:space="preserve">
          <source>Slice3 is the 3-index form of the slice operation: it returns v[i:j:k]. It panics if v's Kind is not Array or Slice, or if v is an unaddressable array, or if the indexes are out of bounds.</source>
          <target state="translated">Slice3 是分片操作的 3 个索引形式:它返回 v[i:j:k]。如果v的Kind不是Array或Slice,或者v是一个不可寻址的数组,或者索引出界,它就会恐慌。</target>
        </trans-unit>
        <trans-unit id="036571bfad79ab866cb35b30d706649dfea91e3e" translate="yes" xml:space="preserve">
          <source>Slice:</source>
          <target state="translated">Slice:</target>
        </trans-unit>
        <trans-unit id="0294a1ce63eca0958f1a3380376dd5b3772daeaa" translate="yes" xml:space="preserve">
          <source>SliceHeader is the runtime representation of a slice. It cannot be used safely or portably and its representation may change in a later release. Moreover, the Data field is not sufficient to guarantee the data it references will not be garbage collected, so programs must keep a separate, correctly typed pointer to the underlying data.</source>
          <target state="translated">SliceHeader 是切片的运行时表示。它不能安全地或可移植地使用,它的表示方式可能会在以后的版本中改变。此外,Data字段不足以保证它所引用的数据不会被垃圾回收,所以程序必须保留一个单独的、正确类型的指针,指向底层数据。</target>
        </trans-unit>
        <trans-unit id="c22ee253fc38582e76e1a487b795c3ec911e294a" translate="yes" xml:space="preserve">
          <source>SliceIsSorted tests whether a slice is sorted.</source>
          <target state="translated">SliceIsSorted 测试一个切片是否被排序。</target>
        </trans-unit>
        <trans-unit id="45eaaaf070f6c38ebb684650d2e76ac52a7e3905" translate="yes" xml:space="preserve">
          <source>SliceOf returns the slice type with element type t. For example, if t represents int, SliceOf(t) represents []int.</source>
          <target state="translated">例如,如果t代表int,那么SliceOf(t)代表[]int。</target>
        </trans-unit>
        <trans-unit id="d3f5d8267a68290ad1478266ac0100b64a9ec9d9" translate="yes" xml:space="preserve">
          <source>SlicePtrFromStrings converts a slice of strings to a slice of pointers to NUL-terminated byte arrays. If any string contains a NUL byte, it returns (nil, EINVAL).</source>
          <target state="translated">SlicePtrFromStrings将字符串的片断转换为指向NUL结尾的字节数组的片断。如果任何字符串包含一个NUL字节,它将返回(nil,EINVAL)。</target>
        </trans-unit>
        <trans-unit id="1c864d92c212ef8abfd9b5a7229b7d9cb38de7a2" translate="yes" xml:space="preserve">
          <source>SliceStable</source>
          <target state="translated">SliceStable</target>
        </trans-unit>
        <trans-unit id="291aafdf1861d62c9bc50f1c83d1800a3cb0913c" translate="yes" xml:space="preserve">
          <source>SliceStable sorts the provided slice given the provided less function while keeping the original order of equal elements.</source>
          <target state="translated">SliceStable对所提供的分片进行排序,同时保持原有的等元素顺序。</target>
        </trans-unit>
        <trans-unit id="24220363f4bcd3c6462dbe1e7e4afff4012817f0" translate="yes" xml:space="preserve">
          <source>Slices of bytes in the returned token data refer to the parser's internal buffer and remain valid only until the next call to Token. To acquire a copy of the bytes, call CopyToken or the token's Copy method.</source>
          <target state="translated">返回的token数据中的字节片段是指解析器的内部缓冲区,并且只在下次调用Token之前有效。要获取字节的副本,请调用CopyToken或token的Copy方法。</target>
        </trans-unit>
        <trans-unit id="fc7f681747838baecdc0ee29795205530bc0b270" translate="yes" xml:space="preserve">
          <source>SocketControlMessage represents a socket control message.</source>
          <target state="translated">SocketControlMessage表示一个套接字控制消息。</target>
        </trans-unit>
        <trans-unit id="4457c2edf950c3c3e9063b3a5f5427cad62d71ba" translate="yes" xml:space="preserve">
          <source>Some protocols may impose additional requirements on pre-escaping the username and password. For instance, when used with OAuth2, both arguments must be URL encoded first with url.QueryEscape.</source>
          <target state="translated">有些协议可能会对用户名和密码的预封装提出额外的要求,例如,当使用OAuth2时,两个参数必须先用url.QueryEscape进行URL编码。例如,当使用OAuth2时,两个参数都必须先用url.QueryEscape进行URL编码。</target>
        </trans-unit>
        <trans-unit id="0b8c5ca797beb6df3a3a7d32f3dea277a5bafd3c" translate="yes" xml:space="preserve">
          <source>Some valid layouts are invalid time values for time.Parse, due to formats such as _ for space padding and Z for zone information.</source>
          <target state="translated">一些有效的布局对time.Parse来说是无效的时间值,这是由于格式,如_表示空格填充,Z表示区域信息。</target>
        </trans-unit>
        <trans-unit id="89fbdcfdf1cfcd667a49cfe3f7c3c0bdc4ce5124" translate="yes" xml:space="preserve">
          <source>Sort is a convenience method.</source>
          <target state="translated">排序是一种方便的方法。</target>
        </trans-unit>
        <trans-unit id="f520ad1ca9ea89523277ded79bfeb4e271e735a8" translate="yes" xml:space="preserve">
          <source>Sort sorts an ErrorList. *Error entries are sorted by position, other errors are sorted by error message, and before any *Error entry.</source>
          <target state="translated">Sort对ErrorList进行排序。*错误条目按位置排序,其他错误按错误信息排序,并在任何*错误条目之前排序。</target>
        </trans-unit>
        <trans-unit id="f8bf7dfcfaee16c58648d64101d25f3215cc22e2" translate="yes" xml:space="preserve">
          <source>Sort sorts data. It makes one call to data.Len to determine n, and O(n*log(n)) calls to data.Less and data.Swap. The sort is not guaranteed to be stable.</source>
          <target state="translated">Sort对数据进行排序。它对data.Len进行一次调用以确定n,对data.Less和data.Swap进行O(n*log(n))次调用。排序不保证稳定。</target>
        </trans-unit>
        <trans-unit id="decd49ac7a46241d55346a11f6d2fb74335dc7a9" translate="yes" xml:space="preserve">
          <source>SortImports sorts runs of consecutive import lines in import blocks in f. It also removes duplicate imports when it is possible to do so without data loss.</source>
          <target state="translated">SortImports对f中的导入块中的连续导入行进行排序,当可以做到不丢失数据时,它还可以删除重复的导入。</target>
        </trans-unit>
        <trans-unit id="6e2693fb2fa2b916dd95d972bbcb32b0b6b566ec" translate="yes" xml:space="preserve">
          <source>Source formats src in canonical gofmt style and returns the result or an (I/O or syntax) error. src is expected to be a syntactically correct Go source file, or a list of Go declarations or statements.</source>
          <target state="translated">源文件以规范的gofmt风格格式化src,并返回结果或(I/O或语法)错误。src应该是一个语法正确的Go源文件,或Go声明或语句的列表。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
