<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="go">
    <body>
      <group id="go">
        <trans-unit id="b05ffc1d15462ca6f99d23dad5504fcb24e01652" translate="yes" xml:space="preserve">
          <source>Filenames containing a certificate and matching private key for the server must be provided if neither the Server's TLSConfig.Certificates nor TLSConfig.GetCertificate are populated. If the certificate is signed by a certificate authority, the certFile should be the concatenation of the server's certificate, any intermediates, and the CA's certificate.</source>
          <target state="translated">如果服务器的 TLSConfig.Certificates 和 TLSConfig.GetCertificate 都没有被填充,则必须提供包含服务器的证书和匹配私钥的文件名。如果证书是由证书颁发机构签署的,那么 certFile 应该是服务器的证书、任何中介机构和 CA 的证书的连接。</target>
        </trans-unit>
        <trans-unit id="73595851a6091a7492042c8776979e91c6d3c91f" translate="yes" xml:space="preserve">
          <source>Files checks the provided files as part of the checker's package.</source>
          <target state="translated">Files检查所提供的文件作为检查器软件包的一部分。</target>
        </trans-unit>
        <trans-unit id="f2677f06472fc0feb492ada82a2c4649c4e1df36" translate="yes" xml:space="preserve">
          <source>Files containing a certificate and matching private key for the server must be provided if neither the Server's TLSConfig.Certificates nor TLSConfig.GetCertificate are populated. If the certificate is signed by a certificate authority, the certFile should be the concatenation of the server's certificate, any intermediates, and the CA's certificate.</source>
          <target state="translated">如果服务器的 TLSConfig.Certificates 和 TLSConfig.GetCertificate 都没有被填充,则必须提供包含服务器的证书和匹配私钥的文件。如果证书是由证书颁发机构签署的,那么 certFile 应该是服务器的证书、任何中介机构和 CA 的证书的连接。</target>
        </trans-unit>
        <trans-unit id="5e509fe0addedea68b64c5b0175672be70d59e89" translate="yes" xml:space="preserve">
          <source>Files returns the file name table of this compilation unit as of the current position in the line table. The file name table may be referenced from attributes in this compilation unit such as AttrDeclFile.</source>
          <target state="translated">Files返回该编译单元在行表中当前位置的文件名表。文件名表可以从这个编译单元的属性中引用,比如AttrDeclFile。</target>
        </trans-unit>
        <trans-unit id="32b9b62ab260f2308e9b093a7911d09a04032958" translate="yes" xml:space="preserve">
          <source>FillBytes sets buf to the absolute value of x, storing it as a zero-extended big-endian byte slice, and returns buf.</source>
          <target state="translated">FillBytes 将 buf 设置为 x 的绝对值,将其存储为一个零扩展的大字节片断,并返回 buf。</target>
        </trans-unit>
        <trans-unit id="916600c69a73c67f62481a2e3b48aac8b70b5d49" translate="yes" xml:space="preserve">
          <source>FillFromRDNSequence populates n from the provided RDNSequence. Multi-entry RDNs are flattened, all entries are added to the relevant n fields, and the grouping is not preserved.</source>
          <target state="translated">FillFromRDNSequence从提供的RDNSequence中填充n。多条目的 RDN 会被扁平化,所有条目都会被添加到相关的 n 字段中,并且不会保留分组。</target>
        </trans-unit>
        <trans-unit id="9c30ef34cd44738f2300a9d1c8d2644305bfe659" translate="yes" xml:space="preserve">
          <source>Filter eliminates documentation for names that don't pass through the filter f. TODO(gri): Recognize &quot;Type.Method&quot; as a name.</source>
          <target state="translated">过滤器消除了没有通过过滤器的名称的文档 f.TODO(gri):将 &quot;Type.Method &quot;识别为名称。</target>
        </trans-unit>
        <trans-unit id="8fe9542ddb9636eaf7f6d18a2a5c93cd3e032943" translate="yes" xml:space="preserve">
          <source>Filter returns a new comment map consisting of only those entries of cmap for which a corresponding node exists in the AST specified by node.</source>
          <target state="translated">过滤器返回一个新的注解映射,只包含cmap的那些条目,而这些条目在node指定的AST中存在对应的节点。</target>
        </trans-unit>
        <trans-unit id="99334f5ff24d09e0e43146c7ab17eed8e9e83ed8" translate="yes" xml:space="preserve">
          <source>FilterDecl reports whether there are any declared names left after filtering.</source>
          <target state="translated">FilterDecl报告过滤后是否还有声明的名字。</target>
        </trans-unit>
        <trans-unit id="a98ad9f1ce33b85f6650faa2d18060284cd00443" translate="yes" xml:space="preserve">
          <source>FilterDecl trims the AST for a Go declaration in place by removing all names (including struct field and interface method names, but not from parameter lists) that don't pass through the filter f.</source>
          <target state="translated">FilterDecl通过删除所有不通过过滤器f的名称(包括结构域和接口方法名,但不包括参数列表),原地修剪一个Go声明的AST。</target>
        </trans-unit>
        <trans-unit id="c1ed367ffc6ba55dd5b60bff81664a2c439a8484" translate="yes" xml:space="preserve">
          <source>FilterFile reports whether there are any top-level declarations left after filtering.</source>
          <target state="translated">FilterFile报告过滤后是否还有顶层声明。</target>
        </trans-unit>
        <trans-unit id="7a9fa766ec80d5d59f245ed962a927a61c070075" translate="yes" xml:space="preserve">
          <source>FilterFile trims the AST for a Go file in place by removing all names from top-level declarations (including struct field and interface method names, but not from parameter lists) that don't pass through the filter f. If the declaration is empty afterwards, the declaration is removed from the AST. Import declarations are always removed. The File.Comments list is not changed.</source>
          <target state="translated">FilterFile通过从顶层声明(包括结构域和接口方法名,但不包括参数列表)中删除所有没有通过过滤器f的名称来就地修剪一个Go文件的AST,如果之后声明为空,则声明会从AST中删除。导入声明总是被删除。File.Comments列表不会被改变。</target>
        </trans-unit>
        <trans-unit id="616d0d4a74fcef85e72d4edac004eabd14b32293" translate="yes" xml:space="preserve">
          <source>FilterPackage reports whether there are any top-level declarations left after filtering.</source>
          <target state="translated">FilterPackage报告过滤后是否还有顶层声明。</target>
        </trans-unit>
        <trans-unit id="cc812cc8b170b6479d3dcdf5fdfae2947c9e732a" translate="yes" xml:space="preserve">
          <source>FilterPackage trims the AST for a Go package in place by removing all names from top-level declarations (including struct field and interface method names, but not from parameter lists) that don't pass through the filter f. If the declaration is empty afterwards, the declaration is removed from the AST. The pkg.Files list is not changed, so that file names and top-level package comments don't get lost.</source>
          <target state="translated">FilterPackage 通过从顶层声明中删除所有没有通过过滤器 f 的名称(包括结构域和接口方法名,但不包括参数列表)来就地修剪 Go 包的 AST。pkg.Files 列表不会改变,这样文件名和顶层包注释就不会丢失。</target>
        </trans-unit>
        <trans-unit id="64167db3c8ee867d45eebbc9c53b064e2bb836d4" translate="yes" xml:space="preserve">
          <source>Finalizers are run in dependency order: if A points at B, both have finalizers, and they are otherwise unreachable, only the finalizer for A runs; once A is freed, the finalizer for B can run. If a cyclic structure includes a block with a finalizer, that cycle is not guaranteed to be garbage collected and the finalizer is not guaranteed to run, because there is no ordering that respects the dependencies.</source>
          <target state="translated">定标器是按照依赖顺序运行的:如果A指向B,两者都有定标器,并且它们在其他情况下无法到达,那么只有A的定标器运行;一旦A被释放,B的定标器可以运行。如果一个循环结构中包含了一个带有定标器的块,那么这个循环就不能保证被垃圾回收,定标器也不能保证运行,因为没有尊重依赖关系的排序。</target>
        </trans-unit>
        <trans-unit id="04c286b7e901d165a790bb4d85625ee624e6c5de" translate="yes" xml:space="preserve">
          <source>Finally, *Int, *Rat, and *Float satisfy the fmt package's Scanner interface for scanning and (except for *Rat) the Formatter interface for formatted printing.</source>
          <target state="translated">最后,*Int、*Rat和*Float满足了fmt包的Scanner接口的扫描和(除了*Rat)Formatter接口的格式化打印。</target>
        </trans-unit>
        <trans-unit id="26ec87dd2b9f83faa210cf241d5b474c8a62da6b" translate="yes" xml:space="preserve">
          <source>Finally, any occurrences of slash are replaced by Separator.</source>
          <target state="translated">最后,任何出现的斜线都会被Separator取代。</target>
        </trans-unit>
        <trans-unit id="2e283acb4f254ad8296a8a754d3d7b44acc43a52" translate="yes" xml:space="preserve">
          <source>Finally, each message created by a call to Encode is preceded by an encoded unsigned integer count of the number of bytes remaining in the message. After the initial type name, interface values are wrapped the same way; in effect, the interface value acts like a recursive invocation of Encode.</source>
          <target state="translated">最后,每个由Encode调用创建的消息前面都有一个编码的无符号整数,表示消息中剩余的字节数。在初始类型名之后,接口值也以同样的方式封装;实际上,接口值的作用就像Encode的递归调用。</target>
        </trans-unit>
        <trans-unit id="26fb85ce34e42f69c76353a6f2b051f404c7f2c9" translate="yes" xml:space="preserve">
          <source>Find returns a slice holding the text of the leftmost match in b of the regular expression. A return value of nil indicates no match.</source>
          <target state="translated">Find 返回正则表达式 b 中最左边匹配的文本的分片。返回值为nil表示没有匹配。</target>
        </trans-unit>
        <trans-unit id="3939b43a8656fedf8c713b119be8032947dc3ecd" translate="yes" xml:space="preserve">
          <source>FindAll is the 'All' version of Find; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match.</source>
          <target state="translated">FindAll是Find的 &quot;全部 &quot;版本;它返回表达式的所有连续匹配的片断,正如包注释中的 &quot;全部 &quot;描述所定义的那样。返回值为nil表示没有匹配。</target>
        </trans-unit>
        <trans-unit id="36cb8b2ff6a76516bc1c892450ee61ae3139b098" translate="yes" xml:space="preserve">
          <source>FindAllIndex is the 'All' version of FindIndex; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match.</source>
          <target state="translated">FindAllIndex是FindIndex的 &quot;全部 &quot;版本;它返回表达式的所有连续匹配的片断,正如包注释中的 &quot;全部 &quot;描述所定义的那样。返回值为nil表示没有匹配。</target>
        </trans-unit>
        <trans-unit id="f5f37301641ba46ce0b020d50232dcdae9f0dad0" translate="yes" xml:space="preserve">
          <source>FindAllIndex returns a sorted list of non-overlapping matches of the regular expression r, where a match is a pair of indices specifying the matched slice of x.Bytes(). If n &amp;lt; 0, all matches are returned in successive order. Otherwise, at most n matches are returned and they may not be successive. The result is nil if there are no matches, or if n == 0.</source>
          <target state="translated">FindAllIndex返回正则表达式r的非重叠匹配的排序列表，其中匹配是一对索引，指定x.Bytes（）的匹配切片。如果n &amp;lt;0，则以连续顺序返回所有匹配项。否则，最多返回n个匹配项，并且它们可能不是连续的。如果没有匹配项，或者n == 0，则结​​果为nil。</target>
        </trans-unit>
        <trans-unit id="9de88adfecc3f20e0c2ffdbb0f036f7a79d80f3b" translate="yes" xml:space="preserve">
          <source>FindAllString is the 'All' version of FindString; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match.</source>
          <target state="translated">FindAllString是FindString的 &quot;全部 &quot;版本;它返回表达式所有连续匹配的片断,正如包注释中的 &quot;全部 &quot;描述所定义的那样。返回值为nil表示没有匹配。</target>
        </trans-unit>
        <trans-unit id="50f5df0a72b99ef5ef4ba48205043bd703872dd1" translate="yes" xml:space="preserve">
          <source>FindAllStringIndex is the 'All' version of FindStringIndex; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match.</source>
          <target state="translated">FindAllStringIndex是FindStringIndex的 &quot;全部 &quot;版本;它返回表达式所有连续匹配的片断,正如包注释中的 &quot;全部 &quot;描述所定义的那样。返回值为nil表示没有匹配。</target>
        </trans-unit>
        <trans-unit id="fd030004e8ba710e67858c9136cb59800b720d8e" translate="yes" xml:space="preserve">
          <source>FindAllStringSubmatch is the 'All' version of FindStringSubmatch; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match.</source>
          <target state="translated">FindAllStringSubmatch是FindStringSubmatch的 &quot;全部 &quot;版本;它返回表达式所有连续匹配的片断,正如包注释中的 &quot;全部 &quot;描述所定义的那样。返回值为nil表示没有匹配。</target>
        </trans-unit>
        <trans-unit id="866672036e7565c5590c34ec3cdc6d2f77a921c5" translate="yes" xml:space="preserve">
          <source>FindAllStringSubmatchIndex is the 'All' version of FindStringSubmatchIndex; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match.</source>
          <target state="translated">FindAllStringSubmatchIndex是FindStringSubmatchIndex的 &quot;全部 &quot;版本;它返回表达式的所有连续匹配的片断,正如包注释中的 &quot;全部 &quot;描述所定义的那样。返回值为nil表示没有匹配。</target>
        </trans-unit>
        <trans-unit id="3be6622b78b7a355447dee918503ed5111144cd3" translate="yes" xml:space="preserve">
          <source>FindAllSubmatch is the 'All' version of FindSubmatch; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match.</source>
          <target state="translated">FindAllSubmatch是FindSubmatch的 &quot;全部 &quot;版本;它返回表达式的所有连续匹配的片断,正如包注释中的 &quot;全部 &quot;描述所定义的那样。返回值为nil表示没有匹配。</target>
        </trans-unit>
        <trans-unit id="c52ee6c792ee96296da432c07ce6bac841f99f98" translate="yes" xml:space="preserve">
          <source>FindAllSubmatchIndex is the 'All' version of FindSubmatchIndex; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match.</source>
          <target state="translated">FindAllSubmatchIndex是FindSubmatchIndex的 &quot;全部 &quot;版本;它返回表达式的所有连续匹配的片断,正如包注释中的 &quot;全部 &quot;描述所定义的那样。返回值为nil表示没有匹配。</target>
        </trans-unit>
        <trans-unit id="42e5b0dfb84ada5e535dcd7bb2807e917d046ce8" translate="yes" xml:space="preserve">
          <source>FindIndex returns a two-element slice of integers defining the location of the leftmost match in b of the regular expression. The match itself is at b[loc[0]:loc[1]]. A return value of nil indicates no match.</source>
          <target state="translated">FindIndex 返回一个两元素的整数片断,定义正则表达式 b 中最左边匹配的位置。匹配值本身在 b[loc[0]:loc[1]]。返回值为nil表示没有匹配。</target>
        </trans-unit>
        <trans-unit id="5e8a7de41165a099a274921bab815b24b2852407" translate="yes" xml:space="preserve">
          <source>FindProcess looks for a running process by its pid.</source>
          <target state="translated">FindProcess通过其pid查找正在运行的进程。</target>
        </trans-unit>
        <trans-unit id="4911a1ccdd694282d198f0794f5539db98ac7df1" translate="yes" xml:space="preserve">
          <source>FindReaderIndex returns a two-element slice of integers defining the location of the leftmost match of the regular expression in text read from the RuneReader. The match text was found in the input stream at byte offset loc[0] through loc[1]-1. A return value of nil indicates no match.</source>
          <target state="translated">FindReaderIndex 返回一个两元素的整数片,定义从 RuneReader 读取的文本中正则表达式的最左匹配位置。匹配文本在输入流中的字节偏移loc[0]到loc[1]-1处被找到。返回值为nil表示没有匹配。</target>
        </trans-unit>
        <trans-unit id="1d35aea7e01a3055400cfb5abc273aa2a48d9a9f" translate="yes" xml:space="preserve">
          <source>FindReaderSubmatchIndex returns a slice holding the index pairs identifying the leftmost match of the regular expression of text read by the RuneReader, and the matches, if any, of its subexpressions, as defined by the 'Submatch' and 'Index' descriptions in the package comment. A return value of nil indicates no match.</source>
          <target state="translated">FindReaderSubmatchIndex 返回一个片断,该片断持有标识 RuneReader 读取的文本正则表达式最左边匹配的索引对,以及匹配的子表达式(如果有的话),如包注释中的 &quot;Submatch &quot;和 &quot;Index &quot;描述所定义。返回值为nil表示没有匹配。</target>
        </trans-unit>
        <trans-unit id="e9a327cf77fbaf9bbe1a604d4bcf583f4d07fb1a" translate="yes" xml:space="preserve">
          <source>FindString returns a string holding the text of the leftmost match in s of the regular expression. If there is no match, the return value is an empty string, but it will also be empty if the regular expression successfully matches an empty string. Use FindStringIndex or FindStringSubmatch if it is necessary to distinguish these cases.</source>
          <target state="translated">FindString 返回一个持有正则表达式 s 中最左边匹配文本的字符串。如果没有匹配,返回值是一个空字符串,但如果正则表达式成功匹配了一个空字符串,它也将是空的。如果需要区分这些情况,可以使用FindStringIndex或FindStringSubmatch。</target>
        </trans-unit>
        <trans-unit id="531bff01dd38db5d072dffaff07b7a369f4e48aa" translate="yes" xml:space="preserve">
          <source>FindStringIndex returns a two-element slice of integers defining the location of the leftmost match in s of the regular expression. The match itself is at s[loc[0]:loc[1]]. A return value of nil indicates no match.</source>
          <target state="translated">FindStringIndex 返回一个两元素的整数片断,定义正则表达式 s 中最左边匹配的位置。匹配值本身位于s[loc[0]:loc[1]]。返回值为nil表示没有匹配。</target>
        </trans-unit>
        <trans-unit id="a789ded76b89d56fcfc993f95abd7a8461164bf2" translate="yes" xml:space="preserve">
          <source>FindStringSubmatch returns a slice of strings holding the text of the leftmost match of the regular expression in s and the matches, if any, of its subexpressions, as defined by the 'Submatch' description in the package comment. A return value of nil indicates no match.</source>
          <target state="translated">FindStringSubmatch 返回一个字符串片断,该片断包含s中正则表达式最左边的匹配文本及其子表达式的匹配(如果有的话),如包注释中的 &quot;Submatch &quot;描述所定义。返回值为nil表示没有匹配。</target>
        </trans-unit>
        <trans-unit id="716a3ff38a9d712fef426438e6f03f83ab81e7b5" translate="yes" xml:space="preserve">
          <source>FindStringSubmatchIndex returns a slice holding the index pairs identifying the leftmost match of the regular expression in s and the matches, if any, of its subexpressions, as defined by the 'Submatch' and 'Index' descriptions in the package comment. A return value of nil indicates no match.</source>
          <target state="translated">FindStringSubmatchIndex 返回一个片断,该片断持有索引对,该索引对标识s中正则表达式的最左端匹配,以及它的子表达式的匹配(如果有的话),如包注释中的 &quot;Submatch &quot;和 &quot;Index &quot;描述所定义。返回值为nil表示没有匹配。</target>
        </trans-unit>
        <trans-unit id="ffa69da36fb7ee45dba39b18243a0f710f826bb2" translate="yes" xml:space="preserve">
          <source>FindSubmatch returns a slice of slices holding the text of the leftmost match of the regular expression in b and the matches, if any, of its subexpressions, as defined by the 'Submatch' descriptions in the package comment. A return value of nil indicates no match.</source>
          <target state="translated">FindSubmatch 返回一个片断,其中包含 b 中正则表达式最左边匹配的文本及其子表达式的匹配(如果有的话),如包注释中的 &quot;Submatch &quot;描述所定义。返回值为nil表示没有匹配。</target>
        </trans-unit>
        <trans-unit id="7965df00e3cbe474d92d31bb0bd5221f067573f7" translate="yes" xml:space="preserve">
          <source>FindSubmatchIndex returns a slice holding the index pairs identifying the leftmost match of the regular expression in b and the matches, if any, of its subexpressions, as defined by the 'Submatch' and 'Index' descriptions in the package comment. A return value of nil indicates no match.</source>
          <target state="translated">FindSubmatchIndex 返回一个片断,该片断持有索引对,该索引对标识 b 中正则表达式的最左端匹配以及其子表达式的匹配(如果有的话),如包注释中的 &quot;Submatch &quot;和 &quot;Index &quot;描述所定义。返回值为nil表示没有匹配。</target>
        </trans-unit>
        <trans-unit id="156ee4c1a5140190bfb3141b9e1f8498489f2c44" translate="yes" xml:space="preserve">
          <source>First, if an os.Lstat on the root directory or any directory or file in the tree fails, Walk calls the function with path set to that directory or file's path, info set to nil, and err set to the error from os.Lstat.</source>
          <target state="translated">首先,如果根目录或树中任何目录或文件的os.Lstat失败,Walk会调用该函数,路径设置为该目录或文件的路径,info设置为nil,err设置为os.Lstat的错误。</target>
        </trans-unit>
        <trans-unit id="6469fd45880f3c8255beb2244dc0bd626a3c8ad4" translate="yes" xml:space="preserve">
          <source>First, if the initial fs.Stat on the root directory fails, WalkDir calls the function with path set to root, d set to nil, and err set to the error from fs.Stat.</source>
          <target state="translated">首先,如果根目录上的fs.Stat初始化失败,WalkDir调用该函数时,路径设置为root,d设置为nil,err设置为fs.Stat的错误。</target>
        </trans-unit>
        <trans-unit id="316c8fcfd0429ed17b8857dd6ccdd403f5640491" translate="yes" xml:space="preserve">
          <source>Fix re-establishes the heap ordering after the element at index i has changed its value. Changing the value of the element at index i and then calling Fix is equivalent to, but less expensive than, calling Remove(h, i) followed by a Push of the new value. The complexity is O(log n) where n = h.Len().</source>
          <target state="translated">Fix在索引i处的元素改变其值后重新建立堆排序。改变索引i处元素的值,然后调用Fix等同于调用Remove(h,i),然后再推送新的值,但成本更低。复杂度为O(log n),其中n=h.Len()。</target>
        </trans-unit>
        <trans-unit id="3d7cfcda1db5ca5e3bcb0a9677bf0dd4d80ac6e4" translate="yes" xml:space="preserve">
          <source>FixedZone</source>
          <target state="translated">FixedZone</target>
        </trans-unit>
        <trans-unit id="d8dd9f2c3ea7d8b26856edf904ee0771c7d5fc47" translate="yes" xml:space="preserve">
          <source>FixedZone returns a Location that always uses the given zone name and offset (seconds east of UTC).</source>
          <target state="translated">FixedZone 返回一个始终使用给定区域名称和偏移量(UTC以东秒数)的位置。</target>
        </trans-unit>
        <trans-unit id="08425e752eb21d741faf32b7c85e71d44fa0561c" translate="yes" xml:space="preserve">
          <source>Flag names must be unique within a FlagSet. An attempt to define a flag whose name is already in use will cause a panic.</source>
          <target state="translated">在一个FlagSet中,标志名称必须是唯一的。试图定义一个名字已经被使用的标志会引起恐慌。</target>
        </trans-unit>
        <trans-unit id="2c7a643e1bb2320ed4f231588740bf7ac2e291cd" translate="yes" xml:space="preserve">
          <source>Flag parsing stops just before the first non-flag argument (&quot;-&quot; is a non-flag argument) or after the terminator &quot;--&quot;.</source>
          <target state="translated">标志解析在第一个非标志参数(&quot;-&quot;是一个非标志参数)之前或终结符&quot;--&quot;之后停止。</target>
        </trans-unit>
        <trans-unit id="6fdd311ef8e9ef566cf48b8fece102302ba2cc48" translate="yes" xml:space="preserve">
          <source>Flags are ignored by verbs that do not expect them. For example there is no alternate decimal format, so %#d and %d behave identically.</source>
          <target state="translated">标志会被不期望它们的动词所忽略。例如,没有备用的十进制格式,所以%#d和%d的行为是相同的。</target>
        </trans-unit>
        <trans-unit id="af3386ff8f43c1696f153b0da6ee0a837cb1976a" translate="yes" xml:space="preserve">
          <source>Flags control the behavior of the parser and record information about regexp context.</source>
          <target state="translated">标志控制解析器的行为,并记录有关regexp上下文的信息。</target>
        </trans-unit>
        <trans-unit id="16c488a94448ea7f6f8bcea47a1cbbb9b2216fc9" translate="yes" xml:space="preserve">
          <source>Flags may then be used directly. If you're using the flags themselves, they are all pointers; if you bind to variables, they're values.</source>
          <target state="translated">然后可以直接使用标志。如果你使用的是标志本身,它们都是指针;如果你绑定到变量,它们就是值。</target>
        </trans-unit>
        <trans-unit id="8b5f3f5f47f0c72df0bc10a5003e3c8534841d99" translate="yes" xml:space="preserve">
          <source>Flags returns the output flags for the logger.</source>
          <target state="translated">Flags 返回记录仪的输出标志。</target>
        </trans-unit>
        <trans-unit id="f6c4e9587ed10cf97056188e5fee0abe91201a63" translate="yes" xml:space="preserve">
          <source>Flags returns the output flags for the logger. The flag bits are Ldate, Ltime, and so on.</source>
          <target state="translated">标志位返回记录仪的输出标志位,标志位有Ldate、Ltime等。标志位有Ldate、Ltime等。</target>
        </trans-unit>
        <trans-unit id="ab784ad102a2c124d297f0684145d0588e53e2ce" translate="yes" xml:space="preserve">
          <source>Flags returns the output flags for the standard logger.</source>
          <target state="translated">Flags 返回标准记录器的输出标志。</target>
        </trans-unit>
        <trans-unit id="2fc6ca1c2bb40c98076e96a0885f4d91179665d9" translate="yes" xml:space="preserve">
          <source>Flags returns the output flags for the standard logger. The flag bits are Ldate, Ltime, and so on.</source>
          <target state="translated">Flags 返回标准记录器的输出标志。标志位有Ldate、Ltime等。</target>
        </trans-unit>
        <trans-unit id="49886552d225c91289351966a030fb2ce1479645" translate="yes" xml:space="preserve">
          <source>Flags to OpenFile wrapping those of the underlying system. Not all flags may be implemented on a given system.</source>
          <target state="translated">OpenFile的标志,包含了底层系统的标志。并非所有的标志都能在特定的系统上实现。</target>
        </trans-unit>
        <trans-unit id="e4dce7c8ab9c22a7b9475e937cb3027b98a99140" translate="yes" xml:space="preserve">
          <source>Float (Shift)</source>
          <target state="translated">浮动(移位)</target>
        </trans-unit>
        <trans-unit id="44e98719e5ce5b2d4401b4abb5dc0f8819be8a88" translate="yes" xml:space="preserve">
          <source>Float is a 64-bit float variable that satisfies the Var interface.</source>
          <target state="translated">Float是一个满足Var接口的64位浮动变量。</target>
        </trans-unit>
        <trans-unit id="10efe1f5142078fa491d28fd6eb4b8558bc300d7" translate="yes" xml:space="preserve">
          <source>Float returns the value v as a float64. It panics if v is not a JavaScript number.</source>
          <target state="translated">Float以float64的形式返回值v。如果v不是JavaScript数字,它就会恐慌。</target>
        </trans-unit>
        <trans-unit id="8ce5b8413e70edd589cd645e2e4c3403f1aae941" translate="yes" xml:space="preserve">
          <source>Float returns v's underlying value, as a float64. It panics if v's Kind is not Float32 or Float64</source>
          <target state="translated">Float 返回 v 的底层值,为 float64。如果v的Kind不是Float32或Float64,它就会恐慌。</target>
        </trans-unit>
        <trans-unit id="eeec2beb5f657aee9f544ee180ec6e738a4d2d1a" translate="yes" xml:space="preserve">
          <source>Float.Add</source>
          <target state="translated">Float.Add</target>
        </trans-unit>
        <trans-unit id="ad02b5997c5669d53745f3d1c236de0ca407890e" translate="yes" xml:space="preserve">
          <source>Float.Cmp</source>
          <target state="translated">Float.Cmp</target>
        </trans-unit>
        <trans-unit id="fec48acd5df26f0383b2951f8c9e9ae9c4ff8998" translate="yes" xml:space="preserve">
          <source>Float.Scan</source>
          <target state="translated">Float.Scan</target>
        </trans-unit>
        <trans-unit id="27a60da3c6927b3e7808077db5c420b80b923197" translate="yes" xml:space="preserve">
          <source>Float.SetString</source>
          <target state="translated">Float.SetString</target>
        </trans-unit>
        <trans-unit id="b29933c6b53142cadd8d7b922f23fae52793b020" translate="yes" xml:space="preserve">
          <source>Float32 returns the float32 value nearest to x. If x is too small to be represented by a float32 (|x| &amp;lt; math.SmallestNonzeroFloat32), the result is (0, Below) or (-0, Above), respectively, depending on the sign of x. If x is too large to be represented by a float32 (|x| &amp;gt; math.MaxFloat32), the result is (+Inf, Above) or (-Inf, Below), depending on the sign of x.</source>
          <target state="translated">Float32返回最接近x的float32值。如果x太小而无法用float32（| x | &amp;lt;math.SmallestNonzeroFloat32）表示，则结果取决于x的符号分别为（0，低于）或（-0，高于）。如果x太大而不能用float32（| x |&amp;gt; math.MaxFloat32）表示，则结果是（+ Inf，Above）或（-Inf，below），具体取决于x的符号。</target>
        </trans-unit>
        <trans-unit id="f0d283c114b964a75d4c408e464182f402cb0b18" translate="yes" xml:space="preserve">
          <source>Float32 returns the nearest float32 value for x and a bool indicating whether f represents x exactly. If the magnitude of x is too large to be represented by a float32, f is an infinity and exact is false. The sign of f always matches the sign of x, even if f == 0.</source>
          <target state="translated">Float32返回x的最近的float32值和一个表示f是否精确表示x的bool。如果x的量级太大,无法用float32表示,那么f是无穷大,exact为false。f的符号总是与x的符号相匹配,即使f ==0。</target>
        </trans-unit>
        <trans-unit id="eb048248df2600ce9ef5e83d147f9a17ca26adc9" translate="yes" xml:space="preserve">
          <source>Float32 returns, as a float32, a pseudo-random number in [0.0,1.0) from the default Source.</source>
          <target state="translated">Float32以float32的形式,从默认的Source中返回一个[0.0,1.0]的伪随机数。</target>
        </trans-unit>
        <trans-unit id="119557e6710e4b086bbd4a2b0b1939505b2ba07f" translate="yes" xml:space="preserve">
          <source>Float32 returns, as a float32, a pseudo-random number in [0.0,1.0).</source>
          <target state="translated">Float32以float32的形式返回一个[0.0,1.0)中的伪随机数。</target>
        </trans-unit>
        <trans-unit id="4b84b66f83430db58763aa54b8b6d03936e54bbe" translate="yes" xml:space="preserve">
          <source>Float32Val is like Float64Val but for float32 instead of float64.</source>
          <target state="translated">Float32Val就像Float64Val一样,但适用于float32而不是float64。</target>
        </trans-unit>
        <trans-unit id="105737d03460ae3ded6de0ef2ecd36f638e30d1b" translate="yes" xml:space="preserve">
          <source>Float32bits returns the IEEE 754 binary representation of f, with the sign bit of f and the result in the same bit position. Float32bits(Float32frombits(x)) == x.</source>
          <target state="translated">Float32bits返回f的IEEE 754二进制表示,f的符号位和结果在同一个位上。Float32bits(Float32frombits(x))==x。</target>
        </trans-unit>
        <trans-unit id="7a6760b22e35a08f8123f6341f83087ea51bc753" translate="yes" xml:space="preserve">
          <source>Float32frombits returns the floating-point number corresponding to the IEEE 754 binary representation b, with the sign bit of b and the result in the same bit position. Float32frombits(Float32bits(x)) == x.</source>
          <target state="translated">Float32frombits返回与IEEE 754二进制表示法b对应的浮点数,b的符号位和结果在同一个位上。Float32frombits(Float32bits(x))==x。</target>
        </trans-unit>
        <trans-unit id="e33f8d6b4fe7a74df8d041793f6b8728167aa373" translate="yes" xml:space="preserve">
          <source>Float64 defines a float64 flag with specified name, default value, and usage string. The return value is the address of a float64 variable that stores the value of the flag.</source>
          <target state="translated">Float64定义了一个float64标志,具有指定的名称、默认值和使用字符串。返回值是存储标志值的float64变量的地址。</target>
        </trans-unit>
        <trans-unit id="932e539e33ca068476000955a48af619cccb5721" translate="yes" xml:space="preserve">
          <source>Float64 returns the float64 value nearest to x. If x is too small to be represented by a float64 (|x| &amp;lt; math.SmallestNonzeroFloat64), the result is (0, Below) or (-0, Above), respectively, depending on the sign of x. If x is too large to be represented by a float64 (|x| &amp;gt; math.MaxFloat64), the result is (+Inf, Above) or (-Inf, Below), depending on the sign of x.</source>
          <target state="translated">Float64返回最接近x的float64值。如果x太小而不能用float64（| x | &amp;lt;math.SmallestNonzeroFloat64）表示，则根据x的符号，结果分别为（0，低于）或（-0，高于）。如果x太大而不能用float64（| x |&amp;gt; math.MaxFloat64）表示，则结果是（+ Inf，Above）或（-Inf，below），具体取决于x的符号。</target>
        </trans-unit>
        <trans-unit id="dc045688c2b10e541f35cd8fc5a73c8305f2eb7e" translate="yes" xml:space="preserve">
          <source>Float64 returns the internal float64 value for the metric.</source>
          <target state="translated">Float64 返回度量的内部 float64 值。</target>
        </trans-unit>
        <trans-unit id="9246cdfb5427d2669759af0d644a975a43bcf09a" translate="yes" xml:space="preserve">
          <source>Float64 returns the nearest float64 value for x and a bool indicating whether f represents x exactly. If the magnitude of x is too large to be represented by a float64, f is an infinity and exact is false. The sign of f always matches the sign of x, even if f == 0.</source>
          <target state="translated">Float64返回x的最近的float64值和一个表示f是否精确表示x的bool。如果x的量级太大,无法用float64表示,那么f是无穷大,exact为false。f的符号总是与x的符号相匹配,即使f ==0。</target>
        </trans-unit>
        <trans-unit id="fb72db19ea2b309695153285bf2c38294276e222" translate="yes" xml:space="preserve">
          <source>Float64 returns the number as a float64.</source>
          <target state="translated">Float64 以 float64 的形式返回数字。</target>
        </trans-unit>
        <trans-unit id="20e645bfba6b519f6d6f9f504b9c2a836ed66b68" translate="yes" xml:space="preserve">
          <source>Float64 returns, as a float64, a pseudo-random number in [0.0,1.0) from the default Source.</source>
          <target state="translated">Float64以float64的形式,从默认的Source中返回一个[0.0,1.0]的伪随机数。</target>
        </trans-unit>
        <trans-unit id="39abd5b0f47630ce640acfdfa7a56a26bd48772c" translate="yes" xml:space="preserve">
          <source>Float64 returns, as a float64, a pseudo-random number in [0.0,1.0).</source>
          <target state="translated">Float64以float64的形式返回一个[0.0,1.0)中的伪随机数。</target>
        </trans-unit>
        <trans-unit id="3044c9d35d4c2e395ec952bd2c1f124b00a34e5a" translate="yes" xml:space="preserve">
          <source>Float64Histogram represents a distribution of float64 values.</source>
          <target state="translated">Float64Histogram表示float64值的分布。</target>
        </trans-unit>
        <trans-unit id="e78d2601d317a5e13ee64826b30b75657ca96c0e" translate="yes" xml:space="preserve">
          <source>Float64Histogram returns the internal *Float64Histogram value for the metric.</source>
          <target state="translated">Float64Histogram返回度量的内部*Float64Histogram值。</target>
        </trans-unit>
        <trans-unit id="653daf75fab3a49fdd7213b2a24c9eb000e8f80b" translate="yes" xml:space="preserve">
          <source>Float64Slice attaches the methods of Interface to []float64, sorting in increasing order (not-a-number values are treated as less than other values).</source>
          <target state="translated">Float64Slice将Interface的方法附加到[]float64上,按递增顺序排序(非数字值被视为小于其他值)。</target>
        </trans-unit>
        <trans-unit id="f906cc84916bc0dd00d17ca51f9d5dd6448fa3ef" translate="yes" xml:space="preserve">
          <source>Float64Slice implements Interface for a []float64, sorting in increasing order, with not-a-number (NaN) values ordered before other values.</source>
          <target state="translated">Float64Slice实现了[]float64的接口,按递增顺序排序,非数字(NaN)值排序在其他值之前。</target>
        </trans-unit>
        <trans-unit id="6d5aaf48b420a680701da91064c2099910f7a459" translate="yes" xml:space="preserve">
          <source>Float64Val returns the nearest Go float64 value of x and whether the result is exact; x must be numeric or an Unknown, but not Complex. For values too small (too close to 0) to represent as float64, Float64Val silently underflows to 0. The result sign always matches the sign of x, even for 0. If x is Unknown, the result is (0, false).</source>
          <target state="translated">Float64Val返回x的最近的Go float64值,以及结果是否精确;x必须是数字或未知值,但不是复杂值。对于太小的值(太接近0),不能用float64表示,Float64Val默默地下溢到0。结果符号总是与x的符号匹配,即使是0。</target>
        </trans-unit>
        <trans-unit id="f480bc564117c47157609272dad009564b4f9701" translate="yes" xml:space="preserve">
          <source>Float64Var defines a float64 flag with specified name, default value, and usage string. The argument p points to a float64 variable in which to store the value of the flag.</source>
          <target state="translated">Float64Var定义了一个float64标志,具有指定的名称、默认值和使用字符串。参数p指向一个float64变量,用来存储标志的值。</target>
        </trans-unit>
        <trans-unit id="5b76d09c27fdfd38a6732c012baed4272833ca08" translate="yes" xml:space="preserve">
          <source>Float64bits returns the IEEE 754 binary representation of f, with the sign bit of f and the result in the same bit position, and Float64bits(Float64frombits(x)) == x.</source>
          <target state="translated">Float64bits返回f的IEEE 754二进制表示法,f的符号位和结果在同一个位上,Float64bits(Float64frombits(x))==x。</target>
        </trans-unit>
        <trans-unit id="13821cdc42fa2ea9b35bbae95ee0c4f0016322fc" translate="yes" xml:space="preserve">
          <source>Float64frombits returns the floating-point number corresponding to the IEEE 754 binary representation b, with the sign bit of b and the result in the same bit position. Float64frombits(Float64bits(x)) == x.</source>
          <target state="translated">Float64frombits返回与IEEE 754二进制表示法b相对应的浮点数,b的符号位和结果在同一个位上。Float64frombits(Float64bits(x))==x。</target>
        </trans-unit>
        <trans-unit id="9528abfae7394b5c9ba7f685b93bd097bf04d6fb" translate="yes" xml:space="preserve">
          <source>Float64s</source>
          <target state="translated">Float64s</target>
        </trans-unit>
        <trans-unit id="6d807816d1f16d759e0177078b58ba0a3f78cc89" translate="yes" xml:space="preserve">
          <source>Float64s sorts a slice of float64s in increasing order (not-a-number values are treated as less than other values).</source>
          <target state="translated">Float64s按递增顺序对float64s的一个片断进行排序(非数字值被视为小于其他值)。</target>
        </trans-unit>
        <trans-unit id="e76c800c50d12be0d0ffe3d12ab4347b885eba2b" translate="yes" xml:space="preserve">
          <source>Float64s sorts a slice of float64s in increasing order. Not-a-number (NaN) values are ordered before other values.</source>
          <target state="translated">Float64s 按递增顺序对 float64s 的片断进行排序。非数字(NaN)值在其他值之前排序。</target>
        </trans-unit>
        <trans-unit id="423599a7986fad94bdc1d6990e093d25432d1712" translate="yes" xml:space="preserve">
          <source>Float64sAreSorted</source>
          <target state="translated">Float64sAreSorted</target>
        </trans-unit>
        <trans-unit id="7420edb10083ef184106f9d40b1aeb6592603e4a" translate="yes" xml:space="preserve">
          <source>Float64sAreSorted reports whether the slice x is sorted in increasing order, with not-a-number (NaN) values before any other values.</source>
          <target state="translated">Float64sAreSorted报告切片x是否按递增顺序排序,在任何其他值之前使用非数字(NaN)值。</target>
        </trans-unit>
        <trans-unit id="4b88d9ca0f421f91022935615e41cacbe0162795" translate="yes" xml:space="preserve">
          <source>Float64sAreSorted tests whether a slice of float64s is sorted in increasing order (not-a-number values are treated as less than other values).</source>
          <target state="translated">Float64sAreSorted测试float64s的一个片断是否按递增顺序排序(not-a-number值被视为小于其他值)。</target>
        </trans-unit>
        <trans-unit id="2d47ae20529c410d30f8acaae289ca9d51484938" translate="yes" xml:space="preserve">
          <source>FloatString returns a string representation of x in decimal form with prec digits of precision after the radix point. The last digit is rounded to nearest, with halves rounded away from zero.</source>
          <target state="translated">FloatString 返回一个以十进制形式表示 x 的字符串,在弧度点之后是精确的前几位数。最后一位数字四舍五入,从零开始四舍五入。</target>
        </trans-unit>
        <trans-unit id="05a1f94d542ff10ae04a25aa8e277a76154c76d0" translate="yes" xml:space="preserve">
          <source>FloatType is here for the purposes of documentation only. It is a stand-in for either float type: float32 or float64.</source>
          <target state="translated">FloatType在这里只是为了文档的目的。它是浮点类型的替身:float32或float64。</target>
        </trans-unit>
        <trans-unit id="062cea8bd0e8167673b6851fa82870b7db8d7c76" translate="yes" xml:space="preserve">
          <source>Floating point, integer, and Number values encode as JSON numbers.</source>
          <target state="translated">浮点、整数和Number值编码为JSON数字。</target>
        </trans-unit>
        <trans-unit id="d8d6ee865f2a29fd1629088910ea491c9698ff5c" translate="yes" xml:space="preserve">
          <source>Floating-point and complex constituents:</source>
          <target state="translated">浮点和复杂成分。</target>
        </trans-unit>
        <trans-unit id="b844d202032ef470ba06e9916c2c520ac0ae8998" translate="yes" xml:space="preserve">
          <source>Floating-point limit values. Max is the largest finite value representable by the type. SmallestNonzero is the smallest positive, non-zero value representable by the type.</source>
          <target state="translated">浮点极限值。最大值是指类型所能代表的最大有限值。SmallestNonzero是该类型可表示的最小的正值,非零值。</target>
        </trans-unit>
        <trans-unit id="58315571a008eb8b389dc1e86460decd0968399f" translate="yes" xml:space="preserve">
          <source>Floating-point numbers are always sent as a representation of a float64 value. That value is converted to a uint64 using math.Float64bits. The uint64 is then byte-reversed and sent as a regular unsigned integer. The byte-reversal means the exponent and high-precision part of the mantissa go first. Since the low bits are often zero, this can save encoding bytes. For instance, 17.0 is encoded in only three bytes (FE 31 40).</source>
          <target state="translated">浮点数总是以float64值的表示形式发送。该值使用math.Float64bits转换为uint64。然后将uint64进行字节反转,并作为常规无符号整数发送。字节反转意味着mantissa的指数和高精度部分先被发送。由于低位通常为零,这可以节省编码字节。例如,17.0只用三个字节编码(FE 31 40)。</target>
        </trans-unit>
        <trans-unit id="7db82f74092fc3160e6bc0d9e9bd4849c5c06c0f" translate="yes" xml:space="preserve">
          <source>Floor</source>
          <target state="translated">Floor</target>
        </trans-unit>
        <trans-unit id="ecdffd0cc36f2aad9aef8da98d7fbdd7cd3a98c8" translate="yes" xml:space="preserve">
          <source>Floor returns the greatest integer value less than or equal to x.</source>
          <target state="translated">Floor 返回小于或等于 x 的最大整数值。</target>
        </trans-unit>
        <trans-unit id="563e65b909d8ae6e49711cd799a32c5eb753dc00" translate="yes" xml:space="preserve">
          <source>FloydSteinberg is a Drawer that is the Src Op with Floyd-Steinberg error diffusion.</source>
          <target state="translated">FloydSteinberg是一个抽屉,是具有Floyd-Steinberg误差扩散的Src Op。</target>
        </trans-unit>
        <trans-unit id="589b0d2e5704bd529f61be95ef5544d324be7a14" translate="yes" xml:space="preserve">
          <source>Flush finishes writing the current file's block padding. The current file must be fully written before Flush can be called.</source>
          <target state="translated">Flush完成写入当前文件的块填充。在调用Flush之前,必须将当前文件完全写入。</target>
        </trans-unit>
        <trans-unit id="843ff9ecc07dad8fd240920fbaff659c8bd3b2af" translate="yes" xml:space="preserve">
          <source>Flush flushes any buffered XML to the underlying writer. See the EncodeToken documentation for details about when it is necessary.</source>
          <target state="translated">Flush 将任何缓冲的 XML 冲洗到底层写入器。请参阅EncodeToken文档,了解何时需要这样做。</target>
        </trans-unit>
        <trans-unit id="7757e81dddaaa31ce1e5de4d9b235a8f3a0853cd" translate="yes" xml:space="preserve">
          <source>Flush flushes any buffered data to the underlying writer. Calling Flush is not normally necessary; calling Close is sufficient.</source>
          <target state="translated">Flush将任何缓冲数据刷新到底层写入器。通常不需要调用Flush,调用Close就可以了。</target>
        </trans-unit>
        <trans-unit id="96dda344b5d691957686f7fdb72b5295f5fa20bb" translate="yes" xml:space="preserve">
          <source>Flush flushes any pending compressed data to the underlying writer.</source>
          <target state="translated">Flush将任何待处理的压缩数据刷新到底层写入器。</target>
        </trans-unit>
        <trans-unit id="3d5ed753caad4196a8e88cd94331064662192c20" translate="yes" xml:space="preserve">
          <source>Flush flushes any pending data to the underlying writer. It is useful mainly in compressed network protocols, to ensure that a remote reader has enough data to reconstruct a packet. Flush does not return until the data has been written. Calling Flush when there is no pending data still causes the Writer to emit a sync marker of at least 4 bytes. If the underlying writer returns an error, Flush returns that error.</source>
          <target state="translated">Flush将任何待处理的数据刷新到底层写入器。它主要在压缩网络协议中有用,以确保远程读者有足够的数据来重建数据包。在数据被写入之前,Flush不会返回。当没有待处理的数据时调用Flush仍然会使Writer发出一个至少4字节的同步标记。如果底层写入器返回一个错误,Flush就会返回该错误。</target>
        </trans-unit>
        <trans-unit id="18258ea43eb9026bfa3ba6a07c0a3a31739171f2" translate="yes" xml:space="preserve">
          <source>Flush flushes the Writer to its underlying io.Writer.</source>
          <target state="translated">Flush将Writer刷新到其底层的io.Writer。</target>
        </trans-unit>
        <trans-unit id="729311d07e8c1334af4a5f862a0dd14b0dd93238" translate="yes" xml:space="preserve">
          <source>Flush implements http.Flusher. To test whether Flush was called, see rw.Flushed.</source>
          <target state="translated">Flush 实现了 http.Flusher。要测试Flush是否被调用,请参见rw.Flushed。</target>
        </trans-unit>
        <trans-unit id="5d24f3ea0b3c10e2043b05ee2cd79df1306cedcb" translate="yes" xml:space="preserve">
          <source>Flush should be called after the last call to Write to ensure that any data buffered in the Writer is written to output. Any incomplete escape sequence at the end is considered complete for formatting purposes.</source>
          <target state="translated">应在最后一次调用Write后调用Flush,以确保Writeer中缓冲的任何数据被写入输出。为了格式化的目的,最后任何不完整的转义序列都被认为是完整的。</target>
        </trans-unit>
        <trans-unit id="ea94514228dc595c44d2b25610d0fa2d54b246e4" translate="yes" xml:space="preserve">
          <source>Flush writes any buffered data to the underlying io.Writer.</source>
          <target state="translated">Flush将任何缓冲的数据写入底层的io.Writer。</target>
        </trans-unit>
        <trans-unit id="ae89e3b744d5bf8ef751ee2c788427617846f85a" translate="yes" xml:space="preserve">
          <source>Flush writes any buffered data to the underlying io.Writer. To check if an error occurred during the Flush, call Error.</source>
          <target state="translated">Flush将任何缓冲的数据写入底层的io.Writer。要检查在Flush过程中是否发生了错误,请调用Error。</target>
        </trans-unit>
        <trans-unit id="9f472a0c2c904654bddc286404214aebce731987" translate="yes" xml:space="preserve">
          <source>FlushAfterChunkWriter signals from the caller of NewChunkedWriter that each chunk should be followed by a flush. It is used by the http.Transport code to keep the buffering behavior for headers and trailers, but flush out chunks aggressively in the middle for request bodies which may be generated slowly. See Issue 6574.</source>
          <target state="translated">FlushAfterChunkWriter 从 NewChunkedWriter 的调用者那里发出信号,表明每个 chunk 后面应该有一个 flush。http.Transport代码使用它来保持头文件和尾文件的缓冲行为,但对于生成速度较慢的请求体,则在中间积极地冲掉分块。参见问题 6574。</target>
        </trans-unit>
        <trans-unit id="772a9c77dc26ab2b684cccb97da47b2e2cdf95ac" translate="yes" xml:space="preserve">
          <source>FoldCategory maps a category name to a table of code points outside the category that are equivalent under simple case folding to code points inside the category. If there is no entry for a category name, there are no such points.</source>
          <target state="translated">FoldCategory 将一个类别名称映射到类别外的代码点表中,这些代码点在简单的大小写折叠下等同于类别内的代码点。如果一个类别名称没有条目,则没有这样的点。</target>
        </trans-unit>
        <trans-unit id="3df43e93d81327f2c6837f681b29802a81ed9d8c" translate="yes" xml:space="preserve">
          <source>FoldScript maps a script name to a table of code points outside the script that are equivalent under simple case folding to code points inside the script. If there is no entry for a script name, there are no such points.</source>
          <target state="translated">FoldScript 将脚本名称映射到脚本外部的代码点表中,这些代码点在简单的大小写折叠下等同于脚本内部的代码点。如果一个脚本名没有条目,那么就没有这样的代码点。</target>
        </trans-unit>
        <trans-unit id="2a306a62652b9cfbec638f004e0203911d315836" translate="yes" xml:space="preserve">
          <source>For IP networks, the network must be &quot;ip&quot;, &quot;ip4&quot; or &quot;ip6&quot; followed by a colon and a literal protocol number or a protocol name, and the address has the form &quot;host&quot;. The host must be a literal IP address or a literal IPv6 address with zone. It depends on each operating system how the operating system behaves with a non-well known protocol number such as &quot;0&quot; or &quot;255&quot;.</source>
          <target state="translated">对于IP网络,网络必须是 &quot;ip&quot;、&quot;ip4 &quot;或 &quot;ip6&quot;,后面跟着一个冒号和一个字面协议号或协议名,地址的形式是 &quot;host&quot;。主机必须是一个字面的IP地址或一个带区域的IPv6地址。这取决于每个操作系统如何处理一个非众所周知的协议号,如 &quot;0 &quot;或 &quot;255&quot;。</target>
        </trans-unit>
        <trans-unit id="a986939ec86bd91233d7b82449d187d316efcfcb" translate="yes" xml:space="preserve">
          <source>For POST, PUT, and PATCH requests, it also parses the request body as a form and puts the results into both r.PostForm and r.Form. Request body parameters take precedence over URL query string values in r.Form.</source>
          <target state="translated">对于POST、PUT和PATCH请求,它也会将请求体解析为表单,并将结果放入r.PostForm和r.Form中。在r.Form中,请求体参数优先于URL查询字符串值。</target>
        </trans-unit>
        <trans-unit id="225b1c801f3e5dbb06167528a23dd7b472f86786" translate="yes" xml:space="preserve">
          <source>For POST, PUT, and PATCH requests, it also reads the request body, parses it as a form and puts the results into both r.PostForm and r.Form. Request body parameters take precedence over URL query string values in r.Form.</source>
          <target state="translated">对于POST、PUT和PATCH请求,它也会读取请求体,将其解析为表单,并将结果放入r.PostForm和r.Form中。在r.Form中,请求体参数优先于URL查询字符串值。</target>
        </trans-unit>
        <trans-unit id="961435f4e8342868021020dbf9e49c6cd0fb855a" translate="yes" xml:space="preserve">
          <source>For TCP and UDP networks, the address has the form &quot;host:port&quot;. The host must be a literal IP address, or a host name that can be resolved to IP addresses. The port must be a literal port number or a service name. If the host is a literal IPv6 address it must be enclosed in square brackets, as in &quot;[2001:db8::1]:80&quot; or &quot;[fe80::1%zone]:80&quot;. The zone specifies the scope of the literal IPv6 address as defined in RFC 4007. The functions JoinHostPort and SplitHostPort manipulate a pair of host and port in this form. When using TCP, and the host resolves to multiple IP addresses, Dial will try each IP address in order until one succeeds.</source>
          <target state="translated">对于TCP和UDP网络,地址的形式为 &quot;host:port&quot;。主机必须是一个字面的IP地址,或一个可以解析为IP地址的主机名。端口必须是一个字面的端口号或服务名称。如果主机是一个IPv6地址,它必须用方括号括起来,如&quot;[2001:db8::1]:80 &quot;或&quot;[fe80::1%zone]:80&quot;。区域指定了RFC 4007中定义的IPv6地址的范围,它必须用方括号括起来,如&quot;[2001:db8::1]:80 &quot;或&quot;[fe80::1%zone]:80&quot;。函数JoinHostPort和SplitHostPort以这种形式操作一对主机和端口。当使用TCP,并且主机解析到多个IP地址时,Dial将依次尝试每个IP地址,直到一个成功为止。</target>
        </trans-unit>
        <trans-unit id="03c81916838d3414948e1c22f701e5ce4a3a4855" translate="yes" xml:space="preserve">
          <source>For TCP networks, if the host in the address parameter is empty or a literal unspecified IP address, Listen listens on all available unicast and anycast IP addresses of the local system. To only use IPv4, use network &quot;tcp4&quot;. The address can use a host name, but this is not recommended, because it will create a listener for at most one of the host's IP addresses. If the port in the address parameter is empty or &quot;0&quot;, as in &quot;127.0.0.1:&quot; or &quot;[::1]:0&quot;, a port number is automatically chosen. The Addr method of Listener can be used to discover the chosen port.</source>
          <target state="translated">对于TCP网络,如果地址参数中的主机是空的,或者是一个字面未指定的IP地址,Listen会监听本地系统所有可用的单播和任播IP地址。如果只使用IPv4,则使用网络 &quot;tcp4&quot;。地址可以使用主机名,但不建议这样做,因为它最多只能为主机的一个IP地址创建一个监听器。如果地址参数中的端口为空或 &quot;0&quot;,如 &quot;127.0.0.1:&quot;或&quot;[::1]:0&quot;,则会自动选择一个端口号。可以使用Listener的Addr方法来发现所选的端口。</target>
        </trans-unit>
        <trans-unit id="bc11a7bec3f66f8d391db1eaf65bf359662c3096" translate="yes" xml:space="preserve">
          <source>For TCP, UDP and IP networks, if the host is empty or a literal unspecified IP address, as in &quot;:80&quot;, &quot;0.0.0.0:80&quot; or &quot;[::]:80&quot; for TCP and UDP, &quot;&quot;, &quot;0.0.0.0&quot; or &quot;::&quot; for IP, the local system is assumed.</source>
          <target state="translated">对于TCP、UDP和IP网络,如果主机为空或者是一个未指定的IP地址,如TCP和UDP为&quot;:80&quot;、&quot;0.0.0.0:80 &quot;或&quot;[::]:80&quot;,IP为&quot;&quot;、&quot;0.0.0.0 &quot;或&quot;::&quot;,则假设为本地系统。</target>
        </trans-unit>
        <trans-unit id="f2ddf19f5cd72f2d3b549235c60d91767535d03b" translate="yes" xml:space="preserve">
          <source>For UDP and IP networks, if the host in the address parameter is empty or a literal unspecified IP address, ListenPacket listens on all available IP addresses of the local system except multicast IP addresses. To only use IPv4, use network &quot;udp4&quot; or &quot;ip4:proto&quot;. The address can use a host name, but this is not recommended, because it will create a listener for at most one of the host's IP addresses. If the port in the address parameter is empty or &quot;0&quot;, as in &quot;127.0.0.1:&quot; or &quot;[::1]:0&quot;, a port number is automatically chosen. The LocalAddr method of PacketConn can be used to discover the chosen port.</source>
          <target state="translated">对于UDP和IP网络,如果地址参数中的主机是空的,或者是一个字面未指定的IP地址,ListenPacket就会监听本地系统中除多播IP地址以外的所有可用IP地址。如果要只使用IPv4,请使用网络 &quot;udp4 &quot;或 &quot;ip4:proto&quot;。地址可以使用主机名,但不建议这样做,因为这样做最多只能为主机的一个IP地址创建一个监听器。如果地址参数中的端口为空或 &quot;0&quot;,如 &quot;127.0.0.1:&quot;或&quot;[::1]:0&quot;,则会自动选择一个端口号。PacketConn的LocalAddr方法可以用来发现所选的端口。</target>
        </trans-unit>
        <trans-unit id="4aa2c0bd0a7ad04b8f9986a2d00cc56ef314d18a" translate="yes" xml:space="preserve">
          <source>For Unix networks, the address must be a file system path.</source>
          <target state="translated">对于Unix网络,地址必须是文件系统路径。</target>
        </trans-unit>
        <trans-unit id="55388abcc16d920a08a97c993d2242d3821d48ea" translate="yes" xml:space="preserve">
          <source>For a Timer created with AfterFunc(d, f), Reset either reschedules when f will run, in which case Reset returns true, or schedules f to run again, in which case it returns false. When Reset returns false, Reset neither waits for the prior f to complete before returning nor does it guarantee that the subsequent goroutine running f does not run concurrently with the prior one. If the caller needs to know whether the prior execution of f is completed, it must coordinate with f explicitly.</source>
          <target state="translated">对于一个用AfterFunc(d,f)创建的Timer,Reset要么重新安排f的运行时间,在这种情况下Reset返回true,要么安排f再次运行,在这种情况下返回false。当Reset返回false时,Reset既不等待前一个f完成后再返回,也不保证后续运行f的goroutine不与前一个同时运行。如果调用者需要知道前一个f的执行是否完成,就必须明确地与f协调。</target>
        </trans-unit>
        <trans-unit id="abbce471eb362731eac46a382c7b5f3c54982be7" translate="yes" xml:space="preserve">
          <source>For a Timer created with NewTimer, Reset should be invoked only on stopped or expired timers with drained channels.</source>
          <target state="translated">对于用NewTimer创建的定时器,只有在停止的或过期的定时器的通道耗尽时,才应调用Reset。</target>
        </trans-unit>
        <trans-unit id="6cd90d9b68fe83f1b691af955f9ccbfffd46f969" translate="yes" xml:space="preserve">
          <source>For a description of the testing flags, see &lt;a href=&quot;https://golang.org/cmd/go/#hdr-Testing_flags&quot;&gt;https://golang.org/cmd/go/#hdr-Testing_flags&lt;/a&gt;</source>
          <target state="translated">有关测试标志的说明，请参见&lt;a href=&quot;https://golang.org/cmd/go/#hdr-Testing_flags&quot;&gt;https://golang.org/cmd/go/#hdr-Testing_flags&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="73db7630962b7d9bfe80901d992afe02ab8d444e" translate="yes" xml:space="preserve">
          <source>For a more concise way to create NamedArg values, see the Named function.</source>
          <target state="translated">关于创建NamedArg值的更简洁的方法,请参阅Named函数。</target>
        </trans-unit>
        <trans-unit id="2e93a7b63c6c1c22251cdfa7d2125bbcb4c1d807" translate="yes" xml:space="preserve">
          <source>For a study of the facility in action, visit</source>
          <target state="translated">如需了解该设施的运行情况,请访问</target>
        </trans-unit>
        <trans-unit id="ea8b0e15d8c10094163cd876f62393b64628d456" translate="yes" xml:space="preserve">
          <source>For a timer created with AfterFunc(d, f), if t.Stop returns false, then the timer has already expired and the function f has been started in its own goroutine; Stop does not wait for f to complete before returning. If the caller needs to know whether f is completed, it must coordinate with f explicitly.</source>
          <target state="translated">对于一个用AfterFunc(d,f)创建的定时器,如果t.Stop返回false,那么定时器已经过期,函数f已经在自己的goroutine中启动,Stop不会等待f完成后再返回。如果调用者需要知道f是否已经完成,必须与f显式协调。</target>
        </trans-unit>
        <trans-unit id="adbed43366f7734c782e1358f999b46beb1e3fca" translate="yes" xml:space="preserve">
          <source>For a tutorial, see &lt;a href=&quot;https://golang.org/s/types-tutorial&quot;&gt;https://golang.org/s/types-tutorial&lt;/a&gt;.</source>
          <target state="translated">有关教程，请参见&lt;a href=&quot;https://golang.org/s/types-tutorial&quot;&gt;https://golang.org/s/types-tutorial&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e18ade19ed4a3115a9d9e3c880c80a5a49514530" translate="yes" xml:space="preserve">
          <source>For all requests, ParseForm parses the raw query from the URL and updates r.Form.</source>
          <target state="translated">对于所有请求,ParseForm从URL中解析出原始查询,并更新r.Form。</target>
        </trans-unit>
        <trans-unit id="a78bb4acd6502d15dc3957871fac3c0be9d9b00b" translate="yes" xml:space="preserve">
          <source>For an abstract method, Recv returns the enclosing interface either as a *Named or an *Interface. Due to embedding, an interface may contain methods whose receiver type is a different interface.</source>
          <target state="translated">对于一个抽象方法,Recv以*Named或*Interface的形式返回外层接口。由于嵌入的原因,一个接口可能包含的方法的接收者类型是不同的接口。</target>
        </trans-unit>
        <trans-unit id="4e330719ad337b4c9602641929cab60cae09925d" translate="yes" xml:space="preserve">
          <source>For an outgoing client request, the context controls the entire lifetime of a request and its response: obtaining a connection, sending the request, and reading the response headers and body.</source>
          <target state="translated">对于一个传出的客户端请求,上下文控制了请求及其响应的整个生命周期:获取连接、发送请求、读取响应头和主体。</target>
        </trans-unit>
        <trans-unit id="d8c341cebb2371fc4554d9fb0c6e54c2c5900936" translate="yes" xml:space="preserve">
          <source>For base 0, an underscore character &amp;ldquo;_&amp;rdquo; may appear between a base prefix and an adjacent digit, and between successive digits; such underscores do not change the value of the number, or the returned digit count. Incorrect placement of underscores is reported as an error if there are no other errors. If base != 0, underscores are not recognized and thus terminate scanning like any other character that is not a valid radix point or digit.</source>
          <target state="translated">对于以0为底的下划线字符&amp;ldquo; _&amp;rdquo;可能出现在基本前缀和相邻数字之间以及连续数字之间；这样的下划线不会更改数字的值或返回的数字计数。如果没有其他错误，则将下划线的错误放置报告为错误。如果base！= 0，则下划线将不被识别，从而像其他不是有效小数点或数字的字符一样终止扫描。</target>
        </trans-unit>
        <trans-unit id="e5942b37cf590ae4aabd1b760f075ef90fd1c294" translate="yes" xml:space="preserve">
          <source>For base 0, an underscore character &amp;ldquo;_&amp;rdquo; may appear between a base prefix and an adjacent digit, and between successive digits; such underscores do not change the value of the number. Incorrect placement of underscores is reported as an error if there are no other errors. If base != 0, underscores are not recognized and act like any other character that is not a valid digit.</source>
          <target state="translated">对于以0为底的下划线字符&amp;ldquo; _&amp;rdquo;可能出现在基本前缀和相邻数字之间以及连续数字之间；这样的下划线不会更改数字的值。如果没有其他错误，则将下划线的错误放置报告为错误。如果基数！= 0，则下划线将不被识别，其作用类似于无效数字的任何其他字符。</target>
        </trans-unit>
        <trans-unit id="5f1ac8df1f8e77c9fdc27bc0637f8b872484b6a1" translate="yes" xml:space="preserve">
          <source>For base 0, the number prefix determines the actual base: A prefix of &amp;ldquo;0b&amp;rdquo; or &amp;ldquo;0B&amp;rdquo; selects base 2, &amp;ldquo;0o&amp;rdquo; or &amp;ldquo;0O&amp;rdquo; selects base 8, and &amp;ldquo;0x&amp;rdquo; or &amp;ldquo;0X&amp;rdquo; selects base 16. Otherwise, the actual base is 10 and no prefix is accepted. The octal prefix &quot;0&quot; is not supported (a leading &quot;0&quot; is simply considered a &quot;0&quot;).</source>
          <target state="translated">对于以0为底的数字，数字前缀确定实际的底数：前缀&amp;ldquo; 0b&amp;rdquo;或&amp;ldquo; 0B&amp;rdquo;选择以2为底，&amp;ldquo; 0o&amp;rdquo;或&amp;ldquo; 0O&amp;rdquo;选择以8为底，&amp;ldquo; 0x&amp;rdquo;或&amp;ldquo; 0X&amp;rdquo;选择以16为底。 ，实际基数为10，不接受前缀。不支持八进制前缀&amp;ldquo; 0&amp;rdquo;（前导&amp;ldquo; 0&amp;rdquo;仅被视为&amp;ldquo; 0&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="8da96f7777bef60314c708eb513a45527fc86e1a" translate="yes" xml:space="preserve">
          <source>For bases &amp;lt;= 36, lower and upper case letters are considered the same: The letters 'a' to 'z' and 'A' to 'Z' represent digit values 10 to 35. For bases &amp;gt; 36, the upper case letters 'A' to 'Z' represent the digit values 36 to 61.</source>
          <target state="translated">对于基数&amp;lt;= 36，小写和大写字母被认为是相同的：字母'a'到'z'和'A'到'Z'代表数字值10到35。对于基数&amp;gt; 36，大写字母' A'至'Z'代表数字值36至61。</target>
        </trans-unit>
        <trans-unit id="1cda30f1e34e7fc3ab26bca0abe9bc827de94de0" translate="yes" xml:space="preserve">
          <source>For calls ForCompiler with a new FileSet.</source>
          <target state="translated">对于用新的FileSet调用ForCompiler。</target>
        </trans-unit>
        <trans-unit id="7777ccd24b8bd654eee8980ccc52774364f6122b" translate="yes" xml:space="preserve">
          <source>For compatibility with Go 1.0, Symbols omits the null symbol at index 0. After retrieving the symbols as symtab, an externally supplied index x corresponds to symtab[x-1], not symtab[x].</source>
          <target state="translated">为了与 Go 1.0 兼容,Symbols 省略了索引 0 的空符号。以 symtab 的形式检索符号后,外部提供的索引 x 对应于 symtab[x-1],而不是 symtab[x]。</target>
        </trans-unit>
        <trans-unit id="bd3f39afacd60fc39b35ccda1637af8ff2e8c205" translate="yes" xml:space="preserve">
          <source>For compatibility with Symbols, DynamicSymbols omits the null symbol at index 0. After retrieving the symbols as symtab, an externally supplied index x corresponds to symtab[x-1], not symtab[x].</source>
          <target state="translated">为了与Symbols兼容,DynamicSymbols省略了索引0处的空符号。检索符号为 symtab 后,外部提供的索引 x 对应于 symtab[x-1],而不是 symtab[x]。</target>
        </trans-unit>
        <trans-unit id="ceff07027a0562aae7bcfc8fafd438b3054bb3ea" translate="yes" xml:space="preserve">
          <source>For complex numbers, the width and precision apply to the two components independently and the result is parenthesized, so %f applied to 1.2+3.4i produces (1.200000+3.400000i).</source>
          <target state="translated">对于复数,宽度和精度分别适用于两个分量,结果用小括号表示,所以%f应用于1.2+3.4i产生(1.200000+3.400000i)。</target>
        </trans-unit>
        <trans-unit id="9b540b6ad368c9fd7ce41d2cd5a4983671593e81" translate="yes" xml:space="preserve">
          <source>For compound objects, the elements are printed using these rules, recursively, laid out like this:</source>
          <target state="translated">对于复合对象,使用这些规则,递归地打印出元素,是这样排列的。</target>
        </trans-unit>
        <trans-unit id="33fb692c25f138c6447e3086029bcccc81bc7da5" translate="yes" xml:space="preserve">
          <source>For compound operands such as slices and structs, the format applies to the elements of each operand, recursively, not to the operand as a whole. Thus %q will quote each element of a slice of strings, and %6.2f will control formatting for each element of a floating-point array.</source>
          <target state="translated">对于复合操作数,如切片和结构,格式适用于每个操作数的元素,递归,而不是操作数的整体。因此,%q将引用字符串切片中的每个元素,而%6.2f将控制浮点数组中每个元素的格式。</target>
        </trans-unit>
        <trans-unit id="5cab5826d638fdbcb2ad7a5200731c473b3d7274" translate="yes" xml:space="preserve">
          <source>For control over HTTP client headers, redirect policy, and other settings, create a Client:</source>
          <target state="translated">为了控制HTTP客户端头、重定向策略和其他设置,创建一个客户端。</target>
        </trans-unit>
        <trans-unit id="c05d2d3e27ddcc721da61cee1a36f988089cfb17" translate="yes" xml:space="preserve">
          <source>For control over canceling or setting a timeout on a handshake, use the Dialer's DialContext method.</source>
          <target state="translated">为了控制取消或设置握手的超时,使用Dialer的DialContext方法。</target>
        </trans-unit>
        <trans-unit id="d0c2ce00eb37f48324b8088e1562b15a52ee733a" translate="yes" xml:space="preserve">
          <source>For control over proxies, TLS configuration, keep-alives, compression, and other settings, create a Transport:</source>
          <target state="translated">为了控制代理,TLS配置,保持生命,压缩和其他设置,创建一个传输。</target>
        </trans-unit>
        <trans-unit id="993c8adfef972ba1b068a5731b030b2c3e0c3fdb" translate="yes" xml:space="preserve">
          <source>For correct printing of source code containing comments (using packages go/format and go/printer), special care must be taken to update comments when a File's syntax tree is modified: For printing, comments are interspersed between tokens based on their position. If syntax tree nodes are removed or moved, relevant comments in their vicinity must also be removed (from the File.Comments list) or moved accordingly (by updating their positions). A CommentMap may be used to facilitate some of these operations.</source>
          <target state="translated">为了正确打印包含注释的源代码(使用包go/format和go/printer),当文件的语法树被修改时,必须特别注意更新注释。对于打印来说,注释会根据其位置穿插在标记之间。如果语法树节点被删除或移动,其附近的相关注释也必须相应地被删除(从 File.Comments 列表中)或移动(通过更新其位置)。可以使用CommentMap来方便其中的一些操作。</target>
        </trans-unit>
        <trans-unit id="483fb4b25526c306ca9ffc7060d999d1af757359" translate="yes" xml:space="preserve">
          <source>For debugging, the result of t.String does include the monotonic clock reading if present. If t != u because of different monotonic clock readings, that difference will be visible when printing t.String() and u.String().</source>
          <target state="translated">为了调试,t.String的结果确实包括了单调时钟的读数,如果存在的话。如果t !=u,因为单调时钟读数不同,那么在打印t.String()和u.String()时就会看到这个差异。</target>
        </trans-unit>
        <trans-unit id="c8abfac368bfa911449148a175097af24838350b" translate="yes" xml:space="preserve">
          <source>For each Printf-like function, there is also a Print function that takes no format and is equivalent to saying %v for every operand. Another variant Println inserts blanks between operands and appends a newline.</source>
          <target state="translated">对于每个类似Printf的函数,还有一个Print函数,它不需要格式,相当于对每个操作数说%v。另一个变体Println在操作数之间插入空白并附加一个新行。</target>
        </trans-unit>
        <trans-unit id="2a2f4f1a729ce7677e5cf80bd12ad7a79baf850c" translate="yes" xml:space="preserve">
          <source>For embedding a single file, a variable of type string or []byte is often best. The FS type enables embedding a tree of files, such as a directory of static web server content, as in the example above.</source>
          <target state="translated">对于单个文件的嵌入,通常最好使用string或[]byte类型的变量。FS类型可以嵌入一棵文件树,比如上面例子中的静态Web服务器内容目录。</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="0691fc88626f896c5b4d0c9d21eb150c4440f732" translate="yes" xml:space="preserve">
          <source>For example, a client might run a HELP command that returns a dot-body by using:</source>
          <target state="translated">例如,客户可以运行HELP命令,通过使用以下方法返回一个点体。</target>
        </trans-unit>
        <trans-unit id="d2c85d01a63eaf87fca388b5018e0aae0a907e1f" translate="yes" xml:space="preserve">
          <source>For example, a plugin defined as</source>
          <target state="translated">例如,一个插件定义为</target>
        </trans-unit>
        <trans-unit id="b604de3a3134fd6e14b1dedf12ca2289afcd00f8" translate="yes" xml:space="preserve">
          <source>For example, assume that we decided to froth milk, extract coffee, and mix milk and coffee in separate goroutines. With a task, the trace tool can identify the goroutines involved in a specific cappuccino order.</source>
          <target state="translated">例如,假设我们决定在不同的goroutine中分别打奶泡、萃取咖啡、混合牛奶和咖啡。通过一个任务,跟踪工具可以识别特定卡布奇诺订单中涉及的goroutine。</target>
        </trans-unit>
        <trans-unit id="eb2f502c06edd8d48f9eb402147b9d0d02234fdf" translate="yes" xml:space="preserve">
          <source>For example, consider this input:</source>
          <target state="translated">例如,考虑这个输入。</target>
        </trans-unit>
        <trans-unit id="32f7515ac15513dae926420ef8347c405e749ac1" translate="yes" xml:space="preserve">
          <source>For example, given the content variable in the example above, we can write:</source>
          <target state="translated">例如,给定上面例子中的内容变量,我们可以写。</target>
        </trans-unit>
        <trans-unit id="e07ff3b2f7ec128082cb6d47f79493ae88ad678a" translate="yes" xml:space="preserve">
          <source>For example, here are three ways to embed a file named hello.txt and then print its contents at run time.</source>
          <target state="translated">例如,以下是嵌入一个名为hello.txt的文件,然后在运行时打印其内容的三种方法。</target>
        </trans-unit>
        <trans-unit id="4c08416096093138a9f21f98db3e35296861799a" translate="yes" xml:space="preserve">
          <source>For example, if p points to a struct that contains a file descriptor d, and p has a finalizer that closes that file descriptor, and if the last use of p in a function is a call to syscall.Write(p.d, buf, size), then p may be unreachable as soon as the program enters syscall.Write. The finalizer may run at that moment, closing p.d, causing syscall.Write to fail because it is writing to a closed file descriptor (or, worse, to an entirely different file descriptor opened by a different goroutine). To avoid this problem, call runtime.KeepAlive(p) after the call to syscall.Write.</source>
          <target state="translated">例如,如果p指向一个包含文件描述符d的结构体,并且p有一个关闭该文件描述符的定标器,如果p在函数中的最后一次使用是对syscall.Write(p.d,buf,size)的调用,那么程序一进入syscall.Write,p就可能无法到达。定稿器可能会在那一刻运行,关闭p.d,导致syscall.Write失败,因为它是写到一个关闭的文件描述符(或者,更糟糕的是,写到一个完全不同的由不同的goroutine打开的文件描述符)。为了避免这个问题,在调用syscall.Write之后调用runtime.KeepAlive(p)。</target>
        </trans-unit>
        <trans-unit id="b7f27996d14898d381b2006768c093d3591a4f75" translate="yes" xml:space="preserve">
          <source>For example, if p points to a struct, such as os.File, that contains a file descriptor d, and p has a finalizer that closes that file descriptor, and if the last use of p in a function is a call to syscall.Write(p.d, buf, size), then p may be unreachable as soon as the program enters syscall.Write. The finalizer may run at that moment, closing p.d, causing syscall.Write to fail because it is writing to a closed file descriptor (or, worse, to an entirely different file descriptor opened by a different goroutine). To avoid this problem, call runtime.KeepAlive(p) after the call to syscall.Write.</source>
          <target state="translated">例如,如果p指向一个结构,如os.File,其中包含一个文件描述符d,而且p有一个关闭该文件描述符的终结器,如果p在函数中的最后一次使用是调用syscall.Write(p.d,buf,size),那么程序一进入syscall.Write,p就可能无法到达。定稿器可能会在那一刻运行,关闭p.d,导致syscall.Write失败,因为它是写到一个关闭的文件描述符(或者,更糟糕的是,写到一个完全不同的由不同的goroutine打开的文件描述符)。为了避免这个问题,在调用syscall.Write之后调用runtime.KeepAlive(p)。</target>
        </trans-unit>
        <trans-unit id="648df35862f0618dac59c24e1f3c2197d967fa5c" translate="yes" xml:space="preserve">
          <source>For example, pre-submit checks that use this package directly would behave differently depending on what Go version each developer uses, causing the check to be inherently fragile.</source>
          <target state="translated">例如,直接使用这个包的预提交检查会根据每个开发者使用的Go版本不同而表现不同,导致检查本身很脆弱。</target>
        </trans-unit>
        <trans-unit id="b70afa30fe71b5984e96c509da8feab3dc9a6c66" translate="yes" xml:space="preserve">
          <source>For example, this code always computes a positive elapsed time of approximately 20 milliseconds, even if the wall clock is changed during the operation being timed:</source>
          <target state="translated">例如,这段代码总是计算出大约20毫秒的正经过时间,即使在被计时的操作过程中改变了墙上的时钟。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="b900be25452bfa919448d61bc68d11256350e2d5" translate="yes" xml:space="preserve">
          <source>For floating-point values, width sets the minimum width of the field and precision sets the number of places after the decimal, if appropriate, except that for %g/%G precision sets the maximum number of significant digits (trailing zeros are removed). For example, given 12.345 the format %6.3f prints 12.345 while %.3g prints 12.3. The default precision for %e, %f and %#g is 6; for %g it is the smallest number of digits necessary to identify the value uniquely.</source>
          <target state="translated">对于浮点值,宽度设置字段的最小宽度,精度设置小数点后的位数,但对于%g/%G,精度设置最大的有意义数字(去掉尾部的零)。例如,给定12.345,格式%6.3f打印12.345,而%.3g打印12.3。%e、%f和%#g的默认精度是6;对于%g,它是唯一识别数值所需的最小数字。</target>
        </trans-unit>
        <trans-unit id="8acb9c872d25848ac32729a8857f27d0fe460ece" translate="yes" xml:space="preserve">
          <source>For forward compatibility, users that retrieve a Header from Reader.Next, mutate it in some ways, and then pass it back to Writer.WriteHeader should do so by creating a new Header and copying the fields that they are interested in preserving.</source>
          <target state="translated">为了向前兼容,用户从Reader.Next中获取一个Header,以某些方式改变它,然后把它传回Writer.WriteHeader,应该通过创建一个新的Header并复制他们感兴趣的保留字段来实现。</target>
        </trans-unit>
        <trans-unit id="e4409a51b04b7b882dd788481aa8d78b52daf5f6" translate="yes" xml:space="preserve">
          <source>For higher-level HTTP client support (such as handling of cookies and redirects), see Get, Post, and the Client type.</source>
          <target state="translated">关于更高级别的HTTP客户端支持(如处理Cookie和重定向),请参阅Get、Post和客户端类型。</target>
        </trans-unit>
        <trans-unit id="ccf573cb88fa50261bc0cb844250e5c546113d3a" translate="yes" xml:space="preserve">
          <source>For incoming server requests, the context is canceled when the client's connection closes, the request is canceled (with HTTP/2), or when the ServeHTTP method returns.</source>
          <target state="translated">对于传入的服务器请求,当客户端连接关闭、请求被取消(使用HTTP/2)或ServeHTTP方法返回时,上下文被取消。</target>
        </trans-unit>
        <trans-unit id="fbc897ff158a8e45243f9b229fc5329d56c63ca4" translate="yes" xml:space="preserve">
          <source>For information about UTF-8 strings in Go, see &lt;a href=&quot;https://blog.golang.org/strings&quot;&gt;https://blog.golang.org/strings&lt;/a&gt;.</source>
          <target state="translated">有关Go中UTF-8字符串的信息，请参见&lt;a href=&quot;https://blog.golang.org/strings&quot;&gt;https://blog.golang.org/strings&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="63fe9b03e1c707dfe354f7496b7b0ea1047361fe" translate="yes" xml:space="preserve">
          <source>For instance, NewInt(x) returns an *Int set to the value of the int64 argument x, NewRat(a, b) returns a *Rat set to the fraction a/b where a and b are int64 values, and NewFloat(f) returns a *Float initialized to the float64 argument f. More flexibility is provided with explicit setters, for instance:</source>
          <target state="translated">例如,NewInt(x)返回一个*Int,设置为int64参数x的值,NewRat(a,b)返回一个*Rat,设置为分数a/b,其中a和b是int64值,NewFloat(f)返回一个*Float,初始化为float64参数f。例如,使用显式设置器可以提供更多的灵活性。</target>
        </trans-unit>
        <trans-unit id="ef36fa9bc6685ceb9dbf97a5a5da2cffd6025d4b" translate="yes" xml:space="preserve">
          <source>For instance, given a slice data sorted in ascending order, the call Search(len(data), func(i int) bool { return data[i] &amp;gt;= 23 }) returns the smallest index i such that data[i] &amp;gt;= 23. If the caller wants to find whether 23 is in the slice, it must test data[i] == 23 separately.</source>
          <target state="translated">例如，给定切片数据按升序排序，则调用Search（len（data），func（i int）bool {return data [i]&amp;gt; = 23}）返回最小索引i，使得data [i]&amp;gt; =23。如果调用方要查找切片中是否包含23，则它必须分别测试data [i] == 23。</target>
        </trans-unit>
        <trans-unit id="c7dfa4cd456b849ced74b774ac752b76885a540c" translate="yes" xml:space="preserve">
          <source>For instance, the arguments for (*Int).Add are named x and y, and because the receiver specifies the result destination, it is called z:</source>
          <target state="translated">例如,(*Int).Add的参数被命名为x和y,由于接收方指定了结果目的地,所以被称为z。</target>
        </trans-unit>
        <trans-unit id="8f07f1d3d8e7f6b87f995e34e12a6b2b7256d6aa" translate="yes" xml:space="preserve">
          <source>For instance, when executing the template whose source is</source>
          <target state="translated">例如,当执行模板的来源是</target>
        </trans-unit>
        <trans-unit id="d7e0bab67441455c755b896ba0e2e68a1eb05350" translate="yes" xml:space="preserve">
          <source>For layouts specifying the two-digit year 06, a value NN &amp;gt;= 69 will be treated as 19NN and a value NN &amp;lt; 69 will be treated as 20NN.</source>
          <target state="translated">对于指定两位数字的年份06的布局，值NN&amp;gt; = 69将被视为19NN，而值NN &amp;lt;69将被视为20NN。</target>
        </trans-unit>
        <trans-unit id="c9e462fa1286e4f10051fc8442af5645f8b6918a" translate="yes" xml:space="preserve">
          <source>For more details on the precise definition of the metric key's path and unit formats, see the documentation of the Name field of the Description struct.</source>
          <target state="translated">关于度量键的路径和单位格式的精确定义,详见描述结构的Name字段文档。</target>
        </trans-unit>
        <trans-unit id="6018681f8b36b5a67b809b220861a7e3eea4cf91" translate="yes" xml:space="preserve">
          <source>For more information about pprof, see &lt;a href=&quot;https://github.com/google/pprof/blob/master/doc/README.md&quot;&gt;https://github.com/google/pprof/blob/master/doc/README.md&lt;/a&gt;.</source>
          <target state="translated">有关pprof的更多信息，请参见&lt;a href=&quot;https://github.com/google/pprof/blob/master/doc/README.md&quot;&gt;https://github.com/google/pprof/blob/master/doc/README.md&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d996431a64b6bd8bf9d3bd0300d40b96d810b5b1" translate="yes" xml:space="preserve">
          <source>For more tolerant parsing, Scan will return a valid token if possible even if a syntax error was encountered. Thus, even if the resulting token sequence contains no illegal tokens, a client may not assume that no error occurred. Instead it must check the scanner's ErrorCount or the number of calls of the error handler, if there was one installed.</source>
          <target state="translated">为了进行更宽容的解析,即使遇到语法错误,Scan也会尽可能返回一个有效的标记,因此,即使产生的标记序列不包含非法标记,客户端也不会认为没有发生错误。因此,即使生成的令牌序列不包含非法令牌,客户端也不能认为没有发生错误。相反,它必须检查扫描仪的 ErrorCount 或错误处理程序的调用次数(如果安装了错误处理程序)。</target>
        </trans-unit>
        <trans-unit id="ee92c8f279c1f6e92caa92b507d20eceb3f7bf2a" translate="yes" xml:space="preserve">
          <source>For most Unix systems, this package has two internal implementations of resolving user and group ids to names. One is written in pure Go and parses /etc/passwd and /etc/group. The other is cgo-based and relies on the standard C library (libc) routines such as getpwuid_r and getgrnam_r.</source>
          <target state="translated">对于大多数Unix系统来说,这个软件包有两个内部实现,可以将用户和组的id解析为名字。一个是用纯Go编写的,解析/etc/passwd和/etc/group。另一个是基于cgo的,依赖于标准的C库(libc)例程,如getpwuid_r和getgrnam_r。</target>
        </trans-unit>
        <trans-unit id="c4cdb94c601192f951b8e3c2e58421475088397d" translate="yes" xml:space="preserve">
          <source>For most values, width is the minimum number of runes to output, padding the formatted form with spaces if necessary.</source>
          <target state="translated">对于大多数值来说,宽度是要输出的最小符文数,必要时用空格填充格式化表格。</target>
        </trans-unit>
        <trans-unit id="515255bc358ef4ff5aa5412e1b66dcc8c403a8d9" translate="yes" xml:space="preserve">
          <source>For non-interface types V, or if static is set, V implements T if all methods of T are present in V. Otherwise (V is an interface and static is not set), MissingMethod only checks that methods of T which are also present in V have matching types (e.g., for a type assertion x.(T) where x is of interface type V).</source>
          <target state="translated">对于非接口类型的V,或者如果设置了static,如果V中存在T的所有方法,则V实现T,否则(V是接口且未设置static),MissingMethod只检查V中也存在的T的方法是否具有匹配的类型(例如,对于类型断言x.(T),其中x是接口类型V)。</target>
        </trans-unit>
        <trans-unit id="b71be130422309f072d39771550fbade7a681c88" translate="yes" xml:space="preserve">
          <source>For other HTTP methods, or when the Content-Type is not application/x-www-form-urlencoded, the request Body is not read, and r.PostForm is initialized to a non-nil, empty value.</source>
          <target state="translated">对于其他HTTP方法,或者当Content-Type不是application/x-www-form-urlencoded时,请求Body不被读取,r.PostForm初始化为一个非nil的空值。</target>
        </trans-unit>
        <trans-unit id="90fd7feae6eaa72525957265644b35d2d7178aab" translate="yes" xml:space="preserve">
          <source>For outgoing client request, the context controls the entire lifetime of a request and its response: obtaining a connection, sending the request, and reading the response headers and body.</source>
          <target state="translated">对于传出的客户端请求,上下文控制了请求及其响应的整个生命周期:获取连接、发送请求、读取响应头和正文。</target>
        </trans-unit>
        <trans-unit id="d9dd41b387dea5f2e387ef2638e22692d5781ada" translate="yes" xml:space="preserve">
          <source>For outgoing client requests, the context controls cancellation.</source>
          <target state="translated">对于传出的客户端请求,上下文控制取消。</target>
        </trans-unit>
        <trans-unit id="a001fc47d27546732ba34a6c50953e3947ee9592" translate="yes" xml:space="preserve">
          <source>For parsing this time format, see ParseTime.</source>
          <target state="translated">对于这种时间格式的解析,请参见ParseTime。</target>
        </trans-unit>
        <trans-unit id="f71ccb724292b936b826fde518652933240dfacc" translate="yes" xml:space="preserve">
          <source>For portability, the status code should be in the range [0, 125].</source>
          <target state="translated">为了便于携带,状态码的范围应该是[0,125]。</target>
        </trans-unit>
        <trans-unit id="bf654bcdb4217ef6a979d8f651f736b1fbda2ae7" translate="yes" xml:space="preserve">
          <source>For random numbers suitable for security-sensitive work, see the crypto/rand package.</source>
          <target state="translated">对于适合安全敏感工作的随机数,请参见crypto/rand包。</target>
        </trans-unit>
        <trans-unit id="8dac1d0bb1e2323543dc0dee447715c7804fe438" translate="yes" xml:space="preserve">
          <source>For scanning into *bool, the source may be true, false, 1, 0, or string inputs parseable by strconv.ParseBool.</source>
          <target state="translated">对于扫描成*bool,源可以是true、false、1、0,或者是可由strconv.ParseBool解析的字符串输入。</target>
        </trans-unit>
        <trans-unit id="22a8f63617a1059c9b07e1b34be114b05733ec0f" translate="yes" xml:space="preserve">
          <source>For simpler multi-way equality tests, eq (only) accepts two or more arguments and compares the second and subsequent to the first, returning in effect</source>
          <target state="translated">对于更简单的多向平等检验,eq (only)接受两个或更多的参数,并将第二个参数和后面的参数与第一个参数进行比较,实际上返回的是</target>
        </trans-unit>
        <trans-unit id="b0a480a0eda63e237a87664c806578f92d694410" translate="yes" xml:space="preserve">
          <source>For simplicity in setup, the connection is defined to understand these types a priori, as well as the basic gob types int, uint, etc. Their ids are:</source>
          <target state="translated">为了简化设置,连接的定义是先验地理解这些类型,以及基本的gob类型int、uint等。它们的id是</target>
        </trans-unit>
        <trans-unit id="2a1206bb6c7f79687004103bffb38cbee66ebc60" translate="yes" xml:space="preserve">
          <source>For some arguments, such as a simple array expression, the result can be a constant. See the Go language specification's &quot;Length and capacity&quot; section for details.</source>
          <target state="translated">对于一些参数,例如简单的数组表达式,结果可以是一个常量。详见Go语言规范的 &quot;长度和容量 &quot;部分。</target>
        </trans-unit>
        <trans-unit id="b73ee93bdb118cfdcf76b1431924d083213a9b9c" translate="yes" xml:space="preserve">
          <source>For some arguments, such as a string literal or a simple array expression, the result can be a constant. See the Go language specification's &quot;Length and capacity&quot; section for details.</source>
          <target state="translated">对于一些参数,如字符串文字或简单的数组表达式,结果可以是一个常量。详见Go语言规范的 &quot;长度和容量 &quot;部分。</target>
        </trans-unit>
        <trans-unit id="6fd5303b38861cc1f75ea4005c27f0d0e4bc73ba" translate="yes" xml:space="preserve">
          <source>For strings, byte slices and byte arrays, however, precision limits the length of the input to be formatted (not the size of the output), truncating if necessary. Normally it is measured in runes, but for these types when formatted with the %x or %X format it is measured in bytes.</source>
          <target state="translated">然而,对于字符串、字节片和字节数组来说,精度限制了要格式化的输入长度(而不是输出的大小),必要时进行截断。通常它是以符文为单位的,但对于这些类型,当使用%x或%X格式进行格式化时,它是以字节为单位的。</target>
        </trans-unit>
        <trans-unit id="751d670356e91a449ec7c80c4156cc58a03922ea" translate="yes" xml:space="preserve">
          <source>For such flags, the default value is just the initial value of the variable.</source>
          <target state="translated">对于这种标志,默认值只是变量的初始值。</target>
        </trans-unit>
        <trans-unit id="fe319d30e4ff1d3bb9c9679e1d41b020cb9fc422" translate="yes" xml:space="preserve">
          <source>For testing: clients can set this flag to force creation of IPv6 sockets to return EAFNOSUPPORT.</source>
          <target state="translated">为了测试:客户端可以设置这个标志来强制创建IPv6套接字以返回EAFNOSUPPORT。</target>
        </trans-unit>
        <trans-unit id="0d0e9615cbad5d104943c88a1e426bb41d0d3626" translate="yes" xml:space="preserve">
          <source>For the compiler to recognize this pattern, the conversion must appear in the argument list:</source>
          <target state="translated">为了让编译器识别这种模式,转换必须出现在参数列表中。</target>
        </trans-unit>
        <trans-unit id="13732a80c7c6067fbd8ddcc6a6ec2963b831f009" translate="yes" xml:space="preserve">
          <source>For the most part, LineTable's methods should be treated as an internal detail of the package; callers should use the methods on Table instead.</source>
          <target state="translated">在大多数情况下,LineTable的方法应该被视为包的内部细节;调用者应该使用Table上的方法来代替。</target>
        </trans-unit>
        <trans-unit id="82aa2e5faa1102c849b424650d24e3f7def76f8e" translate="yes" xml:space="preserve">
          <source>For the most part, this package follows the syntax as specified by RFC 5322 and extended by RFC 6532. Notable divergences:</source>
          <target state="translated">在大多数情况下,这个包遵循RFC 5322指定的语法,并由RFC 6532扩展。值得注意的不同之处:</target>
        </trans-unit>
        <trans-unit id="9dbc53494237ff152fc67f06045073fe509d54b4" translate="yes" xml:space="preserve">
          <source>For the power-of-two exponent formats, the mantissa is printed in normalized form:</source>
          <target state="translated">对于二幂指数格式,咒语是以标准化形式打印的。</target>
        </trans-unit>
        <trans-unit id="f64016515259f77234a6cb253ce7855821350f37" translate="yes" xml:space="preserve">
          <source>For the synchronous signals and SIGPIPE, the Go runtime will install a signal handler. It will save any existing signal handler. If a synchronous signal arrives while executing non-Go code, the Go runtime will invoke the existing signal handler instead of the Go signal handler.</source>
          <target state="translated">对于同步信号和SIGPIPE,Go运行时将安装一个信号处理程序。它将保存任何现有的信号处理程序。如果同步信号在执行非围棋代码时到达,围棋运行时将调用现有的信号处理程序而不是围棋信号处理程序。</target>
        </trans-unit>
        <trans-unit id="cee851057097c0db5b5b8a9c0d45d60cedf064a6" translate="yes" xml:space="preserve">
          <source>For these internal escaping functions, if an action pipeline evaluates to a nil interface value, it is treated as though it were an empty string.</source>
          <target state="translated">对于这些内部的转义函数,如果一个动作管道评估为nil接口值,它将被当作一个空字符串处理。</target>
        </trans-unit>
        <trans-unit id="94cdbab58de221c0845a1f0bccdc6ab6b9dfee7c" translate="yes" xml:space="preserve">
          <source>For this trimming, the definition of white space characters is the same as in Go: space, horizontal tab, carriage return, and newline.</source>
          <target state="translated">对于这种修饰,白色空格字符的定义和围棋中的一样:空格、水平制表符、回车和换行。</target>
        </trans-unit>
        <trans-unit id="c4dda3b24b75ceb8fb66edf8e6d50d204c1750ea" translate="yes" xml:space="preserve">
          <source>For unrecognized or vendor-defined attributes, Class may be ClassUnknown.</source>
          <target state="translated">对于未识别或供应商定义的属性,Class可能是ClassUnknown。</target>
        </trans-unit>
        <trans-unit id="a2c58c0bacd7ac1887ab982a2597ef55f18dc028" translate="yes" xml:space="preserve">
          <source>For usage examples, see the wiki page at &lt;a href=&quot;https://golang.org/s/sqlwiki&quot;&gt;https://golang.org/s/sqlwiki&lt;/a&gt;.</source>
          <target state="translated">有关用法示例，请参见Wiki页面，&lt;a href=&quot;https://golang.org/s/sqlwiki&quot;&gt;网址&lt;/a&gt;为https://golang.org/s/sqlwiki。</target>
        </trans-unit>
        <trans-unit id="988918abc4e75847a40cae9d31b2ff0b26774a56" translate="yes" xml:space="preserve">
          <source>ForCompiler returns an Importer for importing from installed packages for the compilers &quot;gc&quot; and &quot;gccgo&quot;, or for importing directly from the source if the compiler argument is &quot;source&quot;. In this latter case, importing may fail under circumstances where the exported API is not entirely defined in pure Go source code (if the package API depends on cgo-defined entities, the type checker won't have access to those).</source>
          <target state="translated">ForCompiler返回一个导入器,用于从已安装的包中导入 &quot;gc &quot;和 &quot;gccgo &quot;编译器,如果编译器参数是 &quot;source&quot;,则直接从源码导入。在后一种情况下,如果导出的API不是完全在纯Go源代码中定义的,导入可能会失败(如果包的API依赖于cgo定义的实体,类型检查器将无法访问这些实体)。</target>
        </trans-unit>
        <trans-unit id="133285841cd925c282a101cb331b225c1c71812e" translate="yes" xml:space="preserve">
          <source>ForLabels invokes f with each label set on the context. The function f should return true to continue iteration or false to stop iteration early.</source>
          <target state="translated">ForLabels对上下文上设置的每个标签调用f。函数f应该返回true来继续迭代,或者返回false来提前停止迭代。</target>
        </trans-unit>
        <trans-unit id="353aeb4085eb053c5afffba4c97380c4860aca38" translate="yes" xml:space="preserve">
          <source>Form is a parsed multipart form. Its File parts are stored either in memory or on disk, and are accessible via the *FileHeader's Open method. Its Value parts are stored as strings. Both are keyed by field name.</source>
          <target state="translated">Form是一个经过解析的多部分表格。它的文件部分存储在内存或磁盘上,可以通过*FileHeader的Open方法访问。它的值部分以字符串的形式存储。两者都以字段名为键。</target>
        </trans-unit>
        <trans-unit id="eccde56e16564dc7c7df2c5cc1796440a15f9401" translate="yes" xml:space="preserve">
          <source>FormDataContentType returns the Content-Type for an HTTP multipart/form-data with this Writer's Boundary.</source>
          <target state="translated">FormDataContentType返回这个Writer's Boundary的HTTP multipart/form-data的Content-Type。</target>
        </trans-unit>
        <trans-unit id="a49e5a35587aa21155c47ca684122af3589d1687" translate="yes" xml:space="preserve">
          <source>FormFile returns the first file for the provided form key. FormFile calls ParseMultipartForm and ParseForm if necessary.</source>
          <target state="translated">FormFile返回所提供的表单键的第一个文件。如果需要,FormFile会调用ParseMultipartForm和ParseForm。</target>
        </trans-unit>
        <trans-unit id="5d5c015330e69759a40946c508bd098ecc8416e4" translate="yes" xml:space="preserve">
          <source>FormName returns the name parameter if p has a Content-Disposition of type &quot;form-data&quot;. Otherwise it returns the empty string.</source>
          <target state="translated">如果p的Content-Disposition类型为 &quot;form-data&quot;,则FormName返回name参数。否则返回空字符串。</target>
        </trans-unit>
        <trans-unit id="445b64c2c00e9bf0c6abebdbd962d04b7f9f105c" translate="yes" xml:space="preserve">
          <source>FormValue returns the first value for the named component of the query. POST and PUT body parameters take precedence over URL query string values. FormValue calls ParseMultipartForm and ParseForm if necessary and ignores any errors returned by these functions. If key is not present, FormValue returns the empty string. To access multiple values of the same key, call ParseForm and then inspect Request.Form directly.</source>
          <target state="translated">FormValue返回查询中命名组件的第一个值。POST和PUT体参数优先于URL查询字符串值。FormValue在必要时调用ParseMultipartForm和ParseForm,并忽略这些函数返回的任何错误。如果key不存在,FormValue将返回空字符串。如果要访问同一键的多个值,可以调用ParseForm,然后直接检查Request.Form。</target>
        </trans-unit>
        <trans-unit id="b90d813e4920205a13e7a3e3ea46b1033f09615e" translate="yes" xml:space="preserve">
          <source>Format errors:</source>
          <target state="translated">格式错误。</target>
        </trans-unit>
        <trans-unit id="bd81fbee8cc623aef03682c00bd263e80dddfcaa" translate="yes" xml:space="preserve">
          <source>Format implements fmt.Formatter. It accepts all the regular formats for floating-point numbers ('b', 'e', 'E', 'f', 'F', 'g', 'G', 'x') as well as 'p' and 'v'. See (*Float).Text for the interpretation of 'p'. The 'v' format is handled like 'g'. Format also supports specification of the minimum precision in digits, the output field width, as well as the format flags '+' and ' ' for sign control, '0' for space or zero padding, and '-' for left or right justification. See the fmt package for details.</source>
          <target state="translated">Format 实现了 fmt.Formatter。它接受所有浮点数的常规格式('b','e','E','f','F','g','G','x')以及'p'和'v'。关于'p'的解释,请参见(*Float).Text。'v'格式的处理方式与'g'相同。Format还支持以数字为单位的最小精度、输出字段宽度以及用于符号控制的格式标志'+'和''、用于空格或零填充的'0'以及用于左右对齐的'-'。详情请参见fmt包。</target>
        </trans-unit>
        <trans-unit id="ddca00e8215628107f30d61b04b8094c67090fc1" translate="yes" xml:space="preserve">
          <source>Format implements fmt.Formatter. It accepts the formats 'b' (binary), 'o' (octal with 0 prefix), 'O' (octal with 0o prefix), 'd' (decimal), 'x' (lowercase hexadecimal), and 'X' (uppercase hexadecimal). Also supported are the full suite of package fmt's format flags for integral types, including '+' and ' ' for sign control, '#' for leading zero in octal and for hexadecimal, a leading &quot;0x&quot; or &quot;0X&quot; for &quot;%#x&quot; and &quot;%#X&quot; respectively, specification of minimum digits precision, output field width, space or zero padding, and '-' for left or right justification.</source>
          <target state="translated">Format实现了fmt.Formatter.Format,它接受'b'(二进制)、'o'(前缀为0的八进制)、'o'(前缀为0o的八进制)、'd'(十进制)、'x'(十进制)等格式。它接受'b'(二进制)、'o'(前缀为0的八进制)、'O'(前缀为0o的八进制)、'd'(十进制)、'x'(小写十六进制)和'X'(大写十六进制)等格式。此外,还支持软件包 fmt 对积分类型的全套格式标志,包括'+'和''用于符号控制,'#'用于八进制和十六进制中的前导零,'%#x'和'%#X'的前导 &quot;0x &quot;或 &quot;0X&quot;,最小数字精度、输出字段宽度、空格或零填充,以及'-'用于左或右对齐。</target>
        </trans-unit>
        <trans-unit id="81a5476108fadb465e67c178e260599d04ddc2e8" translate="yes" xml:space="preserve">
          <source>Format represents the tar archive format.</source>
          <target state="translated">格式代表焦油存档格式。</target>
        </trans-unit>
        <trans-unit id="8d4885fbdac6d0d14accf79b985b4ce78e6bdd62" translate="yes" xml:space="preserve">
          <source>Format returns a textual representation of the time value formatted according to layout, which defines the format by showing how the reference time, defined to be</source>
          <target state="translated">格式化返回时间值的文本表示,根据布局的格式化,它通过显示参考时间(定义为)如何定义为</target>
        </trans-unit>
        <trans-unit id="b3ee515426820c27b536513d4c839dfeda89b51d" translate="yes" xml:space="preserve">
          <source>FormatBool</source>
          <target state="translated">FormatBool</target>
        </trans-unit>
        <trans-unit id="1b75ed131650db00babc41765f3ab4d40a495482" translate="yes" xml:space="preserve">
          <source>FormatBool returns &quot;true&quot; or &quot;false&quot; according to the value of b.</source>
          <target state="translated">FormatBool根据b的值返回 &quot;true &quot;或 &quot;false&quot;。</target>
        </trans-unit>
        <trans-unit id="6afd52cbbbdc2288edb941b965e52c2fc0f3f529" translate="yes" xml:space="preserve">
          <source>FormatBool, FormatFloat, FormatInt, and FormatUint convert values to strings:</source>
          <target state="translated">FormatBool、FormatFloat、FormatInt和FormatUint将值转换为字符串。</target>
        </trans-unit>
        <trans-unit id="7cde6838cd6d9db48f444c3319801df0ed449cfb" translate="yes" xml:space="preserve">
          <source>FormatComplex converts the complex number c to a string of the form (a+bi) where a and b are the real and imaginary parts, formatted according to the format fmt and precision prec.</source>
          <target state="translated">FormatComplex将复数c转换为形式为(a+bi)的字符串,其中a和b是实部和虚部,根据格式fmt和精度prec进行格式化。</target>
        </trans-unit>
        <trans-unit id="cf02981ef6c41fa3e9a421259a94865e8c2df157" translate="yes" xml:space="preserve">
          <source>FormatError is returned by some operations if the data does not have the correct format for an object file.</source>
          <target state="translated">如果数据的格式不符合对象文件的正确格式,某些操作会返回FormatError。</target>
        </trans-unit>
        <trans-unit id="9be4c97132e0f61e257dba73681e0455cf421f26" translate="yes" xml:space="preserve">
          <source>FormatError is unused. The type is retained for compatibility.</source>
          <target state="translated">FormatError未被使用。为了兼容性,保留了该类型。</target>
        </trans-unit>
        <trans-unit id="66155c8335bf85f47e7201829386a88e599875d5" translate="yes" xml:space="preserve">
          <source>FormatFloat</source>
          <target state="translated">FormatFloat</target>
        </trans-unit>
        <trans-unit id="8ab806a123a3e3bc36a09fdd9698930a4aafbfb9" translate="yes" xml:space="preserve">
          <source>FormatFloat converts the floating-point number f to a string, according to the format fmt and precision prec. It rounds the result assuming that the original was obtained from a floating-point value of bitSize bits (32 for float32, 64 for float64).</source>
          <target state="translated">FormatFloat根据格式fmt和精度prec将浮点数f转换为字符串。它假设原始值是由一个比特大小的浮点值获得的(float32为32,float64为64),对结果进行四舍五入。</target>
        </trans-unit>
        <trans-unit id="54acac612d12c84fbb587187170a9d2f5002e9e1" translate="yes" xml:space="preserve">
          <source>FormatInt</source>
          <target state="translated">FormatInt</target>
        </trans-unit>
        <trans-unit id="ac942d8c471010cc2511b6465b29a4a4eaf7e487" translate="yes" xml:space="preserve">
          <source>FormatInt returns the string representation of i in the given base, for 2 &amp;lt;= base &amp;lt;= 36. The result uses the lower-case letters 'a' to 'z' for digit values &amp;gt;= 10.</source>
          <target state="translated">FormatInt以2 &amp;lt;= base &amp;lt;= 36的形式返回给定基数i的字符串表示形式。结果使用小写字母'a'到'z'表示数字值&amp;gt; = 10。</target>
        </trans-unit>
        <trans-unit id="7d726d8b9675ed9de10e3a267d41a3004b409192" translate="yes" xml:space="preserve">
          <source>FormatMediaType</source>
          <target state="translated">FormatMediaType</target>
        </trans-unit>
        <trans-unit id="7ffe85b478b1a8a795e300c5a2b13589a4aacd1b" translate="yes" xml:space="preserve">
          <source>FormatMediaType serializes mediatype t and the parameters param as a media type conforming to RFC 2045 and RFC 2616. The type and parameter names are written in lower-case. When any of the arguments result in a standard violation then FormatMediaType returns the empty string.</source>
          <target state="translated">FormatMediaType将mediatype t和参数param序列化为符合RFC 2045和RFC 2616的媒体类型。类型和参数名都用小写。当任何一个参数导致违反标准时,那么FormatMediaType将返回空字符串。</target>
        </trans-unit>
        <trans-unit id="457b9a9d61506e909562e056e83daf32584b6e03" translate="yes" xml:space="preserve">
          <source>FormatUint</source>
          <target state="translated">FormatUint</target>
        </trans-unit>
        <trans-unit id="29e428f2dcc8699c0417730387a64fac7ddd1961" translate="yes" xml:space="preserve">
          <source>FormatUint returns the string representation of i in the given base, for 2 &amp;lt;= base &amp;lt;= 36. The result uses the lower-case letters 'a' to 'z' for digit values &amp;gt;= 10.</source>
          <target state="translated">FormatUint以2 &amp;lt;= base &amp;lt;= 36的形式返回给定基数i的字符串表示形式。结果使用小写字母'a'到'z'表示数字值&amp;gt; = 10。</target>
        </trans-unit>
        <trans-unit id="5c8097315c949db11f3c54f81dd03fc38d2dca5c" translate="yes" xml:space="preserve">
          <source>Formatter is implemented by any value that has a Format method. The implementation controls how State and rune are interpreted, and may call Sprint(f) or Fprint(f) etc. to generate its output.</source>
          <target state="translated">Formatter由任何有Format方法的值实现。该实现控制了State和Rune的解释方式,可以调用Sprint(f)或Fprint(f)等来生成其输出。</target>
        </trans-unit>
        <trans-unit id="74de65e787a3b1e89f96cc3e3b260c1d5a19f78c" translate="yes" xml:space="preserve">
          <source>Formatter is the interface implemented by values with a custom formatter. The implementation of Format may call Sprint(f) or Fprint(f) etc. to generate its output.</source>
          <target state="translated">Formatter是由值与自定义格式化器实现的接口。Format的实现可以调用Sprint(f)或Fprint(f)等来生成其输出。</target>
        </trans-unit>
        <trans-unit id="d3a818c703590da441ab8fb9d8bac8b6144c0764" translate="yes" xml:space="preserve">
          <source>Formatting can be controlled with these flags.</source>
          <target state="translated">可以通过这些标志来控制格式化。</target>
        </trans-unit>
        <trans-unit id="75a6bd1d5df471e18e5ef09488e671afbb943a27" translate="yes" xml:space="preserve">
          <source>Fprint</source>
          <target state="translated">Fprint</target>
        </trans-unit>
        <trans-unit id="8c8522f1e4d59e7911ef9e37ddbccae99dbf77c6" translate="yes" xml:space="preserve">
          <source>Fprint &quot;pretty-prints&quot; an AST node to output for a given configuration cfg. Position information is interpreted relative to the file set fset. The node type must be *ast.File, *CommentedNode, []ast.Decl, []ast.Stmt, or assignment-compatible to ast.Expr, ast.Decl, ast.Spec, or ast.Stmt.</source>
          <target state="translated">Fprint &quot;pretty-prints &quot;一个AST节点来输出给给定的配置cfg。位置信息是相对于文件集fset来解释的。节点类型必须是 *ast.File,*CommentedNode,[]ast.Decl,[]ast.Stmt,或与 ast.Expr,ast.Decl,ast.Spec,或 ast.Stmt 的赋值兼容。</target>
        </trans-unit>
        <trans-unit id="f8a539386d013173d33a590058d75eefbdb15fa6" translate="yes" xml:space="preserve">
          <source>Fprint &quot;pretty-prints&quot; an AST node to output. It calls Config.Fprint with default settings. Note that gofmt uses tabs for indentation but spaces for alignment; use format.Node (package go/format) for output that matches gofmt.</source>
          <target state="translated">Fprint &quot;漂亮地打印 &quot;一个AST节点到输出。它使用默认设置调用 Config.Fprint。请注意,gofmt使用制表符进行缩进,但使用空格进行对齐;使用format.Node (package go/format)进行符合gofmt的输出。</target>
        </trans-unit>
        <trans-unit id="104c28c9f2550f07e8ce3bfa8162280f3f8c80ca" translate="yes" xml:space="preserve">
          <source>Fprint formats using the default formats for its operands and writes to w. Spaces are added between operands when neither is a string. It returns the number of bytes written and any write error encountered.</source>
          <target state="translated">Fprint使用默认的操作数格式进行格式化,并写入w。当操作数都不是字符串时,操作数之间会添加空格。它返回写入的字节数和遇到的任何写入错误。</target>
        </trans-unit>
        <trans-unit id="6a536bd9e7bf91ae60cda20d0ea5db515bbd6c7b" translate="yes" xml:space="preserve">
          <source>Fprint prints the (sub-)tree starting at AST node x to w. If fset != nil, position information is interpreted relative to that file set. Otherwise positions are printed as integer values (file set specific offsets).</source>
          <target state="translated">如果fset !=nil,位置信息将被解释为相对于该文件集的。否则,位置将被打印为整数值(文件集的特定偏移)。</target>
        </trans-unit>
        <trans-unit id="d20e1fe41e4983b3d1227303d39b1a75b7115f30" translate="yes" xml:space="preserve">
          <source>Fprintf</source>
          <target state="translated">Fprintf</target>
        </trans-unit>
        <trans-unit id="a13c0d787117a7941cdce4981a12d040db7f0953" translate="yes" xml:space="preserve">
          <source>Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered.</source>
          <target state="translated">Fprintf根据格式指定器进行格式化,并写入w。</target>
        </trans-unit>
        <trans-unit id="46197102442051b0256d5e8d44d3fa71b3e0ca3a" translate="yes" xml:space="preserve">
          <source>Fprintln</source>
          <target state="translated">Fprintln</target>
        </trans-unit>
        <trans-unit id="b390d66055f3fb09a9893ca4c02d4466e93e9f7e" translate="yes" xml:space="preserve">
          <source>Fprintln formats using the default formats for its operands and writes to w. Spaces are always added between operands and a newline is appended. It returns the number of bytes written and any write error encountered.</source>
          <target state="translated">Fprintln使用默认的操作数格式进行格式化,并写入w。操作数之间总是添加空格,并附加一个新行。它返回写入的字节数和遇到的任何写入错误。</target>
        </trans-unit>
        <trans-unit id="c52284236b3cbc2d437f96673b062717eea95c7a" translate="yes" xml:space="preserve">
          <source>Frame is the information returned by Frames for each call frame.</source>
          <target state="translated">Frame是Frames返回的每个调用帧的信息。</target>
        </trans-unit>
        <trans-unit id="e3e7a3833d19706ebf33b2c3baf8e05deeed7bca" translate="yes" xml:space="preserve">
          <source>Frames</source>
          <target state="translated">Frames</target>
        </trans-unit>
        <trans-unit id="6a32e149e9d6773e4f6967f48bf708bb90588f99" translate="yes" xml:space="preserve">
          <source>Frames may be used to get function/file/line information for a slice of PC values returned by Callers.</source>
          <target state="translated">帧可用于获取Callers返回的PC值的片断的函数/文件/行信息。</target>
        </trans-unit>
        <trans-unit id="971e42ae8bcc68c1d3c0b0b0f45fd394dc7d0afe" translate="yes" xml:space="preserve">
          <source>FreeOSMemory forces a garbage collection followed by an attempt to return as much memory to the operating system as possible. (Even if this is not called, the runtime gradually returns memory to the operating system in a background task.)</source>
          <target state="translated">FreeOSMemory强制进行垃圾收集,然后尝试将尽可能多的内存返回给操作系统。即使没有调用这个功能,运行时也会在后台任务中逐渐将内存返回给操作系统)。</target>
        </trans-unit>
        <trans-unit id="2d6c189d92419208a8893cd5a97e05687d681927" translate="yes" xml:space="preserve">
          <source>Frexp breaks f into a normalized fraction and an integral power of two. It returns frac and exp satisfying f == frac &amp;times; 2**exp, with the absolute value of frac in the interval [&amp;frac12;, 1).</source>
          <target state="translated">Frexp将f分解为归一化分数和2的整数次方。它返回frac和exp，满足f == frac&amp;times;2 ** exp，而frac的绝对值在[1/2，1）区间内。</target>
        </trans-unit>
        <trans-unit id="fa23c274e14dd5cc1e7fa9a8a9b29bf34200b44f" translate="yes" xml:space="preserve">
          <source>FromSlash returns the result of replacing each slash ('/') character in path with a separator character. Multiple slashes are replaced by multiple separators.</source>
          <target state="translated">FromSlash 返回将路径中的每个斜线('/')字符替换为分隔符的结果。多个斜线会被多个分隔符替换。</target>
        </trans-unit>
        <trans-unit id="164e0e9caa51bad7048b8f096c49d9b2c2ab5e89" translate="yes" xml:space="preserve">
          <source>Front returns the first element of list l or nil if the list is empty.</source>
          <target state="translated">Front返回列表l的第一个元素,如果列表为空,则返回nil。</target>
        </trans-unit>
        <trans-unit id="52c1852fe9f31cf9deb2025a2022f1fc079a5aee" translate="yes" xml:space="preserve">
          <source>Fscan scans text read from r, storing successive space-separated values into successive arguments. Newlines count as space. It returns the number of items successfully scanned. If that is less than the number of arguments, err will report why.</source>
          <target state="translated">Fscan扫描从r中读取的文本,将连续的空格分隔的值存储到连续的参数中。新行也算作空格。它返回成功扫描的项目数。如果少于参数数,err将报告原因。</target>
        </trans-unit>
        <trans-unit id="554810832552956da9a7da2eee0a73593dca23e7" translate="yes" xml:space="preserve">
          <source>Fscanf</source>
          <target state="translated">Fscanf</target>
        </trans-unit>
        <trans-unit id="8bd3b6e023a616305dbe6b056ba1a191e7adb603" translate="yes" xml:space="preserve">
          <source>Fscanf scans text read from r, storing successive space-separated values into successive arguments as determined by the format. It returns the number of items successfully parsed. Newlines in the input must match newlines in the format.</source>
          <target state="translated">Fscanf扫描从r中读取的文本,将连续的空格分隔的值存储到由格式决定的连续参数中。它返回成功解析的项数。输入中的换行必须与格式中的换行相匹配。</target>
        </trans-unit>
        <trans-unit id="24ce0d47eda270ec1be1d5faf6933fc84f496fc9" translate="yes" xml:space="preserve">
          <source>Fscanln</source>
          <target state="translated">Fscanln</target>
        </trans-unit>
        <trans-unit id="6ba607f7da03e13291dee0bc0511128cd6a13033" translate="yes" xml:space="preserve">
          <source>Fscanln is similar to Fscan, but stops scanning at a newline and after the final item there must be a newline or EOF.</source>
          <target state="translated">Fscanln与Fscan类似,但在换行处停止扫描,最后一项后必须有换行或EOF。</target>
        </trans-unit>
        <trans-unit id="18339496bb65d9199e22c7756d8d353de7e08bb1" translate="yes" xml:space="preserve">
          <source>FullName finds real name of symbol sym. Normally name is stored in sym.Name, but if it is longer then 8 characters, it is stored in COFF string table st instead.</source>
          <target state="translated">FullName查找符号sym的真实名称。通常名称存储在sym.Name中,但如果名称超过8个字符,则存储在COFF字符串表st中。</target>
        </trans-unit>
        <trans-unit id="7902524eb980d3f158a430d41566b78e54c0f4a8" translate="yes" xml:space="preserve">
          <source>FullName returns the package- or receiver-type-qualified name of function or method obj.</source>
          <target state="translated">FullName 返回函数或方法 obj 的包或接收类型限定的名称。</target>
        </trans-unit>
        <trans-unit id="b3483c701e937232d5e060b21f7fb965b230aa71" translate="yes" xml:space="preserve">
          <source>FullRune</source>
          <target state="translated">FullRune</target>
        </trans-unit>
        <trans-unit id="81aa0878662ea86cc86d82ed1ab7992029d672d9" translate="yes" xml:space="preserve">
          <source>FullRune reports whether the bytes in p begin with a full UTF-8 encoding of a rune. An invalid encoding is considered a full Rune since it will convert as a width-1 error rune.</source>
          <target state="translated">FullRune报告p中的字节是否以一个完整的UTF-8编码的符文开始。一个无效的编码被认为是一个完整的符文,因为它将转换为一个宽度为1的错误符文。</target>
        </trans-unit>
        <trans-unit id="e05115514df90c085c4af490f89158b561b0d92c" translate="yes" xml:space="preserve">
          <source>FullRuneInString</source>
          <target state="translated">FullRuneInString</target>
        </trans-unit>
        <trans-unit id="95812f07b4917317402c5d2167338a188da0ce79" translate="yes" xml:space="preserve">
          <source>FullRuneInString is like FullRune but its input is a string.</source>
          <target state="translated">FullRuneInString和FullRune一样,但它的输入是一个字符串。</target>
        </trans-unit>
        <trans-unit id="d14c246c1269ccb4359c67583949d6908348f108" translate="yes" xml:space="preserve">
          <source>Func</source>
          <target state="translated">Func</target>
        </trans-unit>
        <trans-unit id="6f03ac155657e14e643cdb5dc79319887df7f634" translate="yes" xml:space="preserve">
          <source>Func defines a flag with the specified name and usage string. Each time the flag is seen, fn is called with the value of the flag. If fn returns a non-nil error, it will be treated as a flag value parsing error.</source>
          <target state="translated">Func定义了一个具有指定名称和用法字符串的标志。每次看到flag时,都会用flag的值调用fn。如果fn返回一个非nil的错误,将被视为一个标志值解析错误。</target>
        </trans-unit>
        <trans-unit id="279955fd7d680432dfab90fbe069c9bfd8dc8495" translate="yes" xml:space="preserve">
          <source>Func implements Var by calling the function and formatting the returned value using JSON.</source>
          <target state="translated">Func通过调用函数和使用JSON格式化返回的值来实现Var。</target>
        </trans-unit>
        <trans-unit id="524a0d206f4cbf19e946f5d4ed3f42690d7a8676" translate="yes" xml:space="preserve">
          <source>Func is a wrapped Go function to be called by JavaScript.</source>
          <target state="translated">Func是一个封装的Go函数,可以被JavaScript调用。</target>
        </trans-unit>
        <trans-unit id="9f43fd9d5faa1fad98bda7488e8199738c579a5f" translate="yes" xml:space="preserve">
          <source>Func is the documentation for a func declaration.</source>
          <target state="translated">Func是func声明的文档。</target>
        </trans-unit>
        <trans-unit id="1428a5974ab9a5d9bb8050c81e92e9a085606a0b" translate="yes" xml:space="preserve">
          <source>Func values are deeply equal if both are nil; otherwise they are not deeply equal.</source>
          <target state="translated">如果两者都为零,则Func值深度相等;否则不深度相等。</target>
        </trans-unit>
        <trans-unit id="c6b073315fc317c2d847f10bda8f819f0b734264" translate="yes" xml:space="preserve">
          <source>Func.Release must be called to free up resources when the function will not be invoked any more.</source>
          <target state="translated">当函数不再被调用时,必须调用Func.Release来释放资源。</target>
        </trans-unit>
        <trans-unit id="4b4c67efe336d8800eb50760aa412d1cd7318a96" translate="yes" xml:space="preserve">
          <source>Func.Release must be called to free up resources when the function will not be used any more.</source>
          <target state="translated">当函数不再使用时,必须调用Func.Release来释放资源。</target>
        </trans-unit>
        <trans-unit id="79c0844aa92a7c85df75b63db88d3ac85acf1947" translate="yes" xml:space="preserve">
          <source>FuncForPC returns a *Func describing the function that contains the given program counter address, or else nil.</source>
          <target state="translated">FuncForPC返回一个*Func,描述包含给定程序计数器地址的函数,否则为nil。</target>
        </trans-unit>
        <trans-unit id="2f873cfa96e723fb817cda8756e298acee836d4d" translate="yes" xml:space="preserve">
          <source>FuncMap is the type of the map defining the mapping from names to functions. Each function must have either a single return value, or two return values of which the second has type error. In that case, if the second (error) argument evaluates to non-nil during execution, execution terminates and Execute returns that error. FuncMap has the same base type as FuncMap in &quot;text/template&quot;, copied here so clients need not import &quot;text/template&quot;.</source>
          <target state="translated">FuncMap是定义从名字到函数的映射类型。每个函数必须有一个返回值,或者有两个返回值,其中第二个返回值的类型为error.在这种情况下,如果第二个参数(error)在执行过程中评估为非nil,则执行终止,Execute返回该错误。在这种情况下,如果第二个(error)参数在执行过程中评估为非nil,则执行终止,Execute返回该错误。FuncMap的基本类型与 &quot;text/template &quot;中的FuncMap相同,复制到这里,所以客户端不需要导入 &quot;text/template&quot;。</target>
        </trans-unit>
        <trans-unit id="c663a8fdf1b0c07a4b3a9bf988b2301d91e56916" translate="yes" xml:space="preserve">
          <source>FuncMap is the type of the map defining the mapping from names to functions. Each function must have either a single return value, or two return values of which the second has type error. In that case, if the second (error) return value evaluates to non-nil during execution, execution terminates and Execute returns that error.</source>
          <target state="translated">FuncMap是定义从名字到函数的映射类型。每个函数必须有一个返回值,或者有两个返回值,其中第二个返回值的类型为错误。在这种情况下,如果第二个(错误)返回值在执行过程中评估为非nil,则执行终止,Execute返回该错误。</target>
        </trans-unit>
        <trans-unit id="e6a6e8cadfebe9c4799e999d069f9213bb24bed9" translate="yes" xml:space="preserve">
          <source>FuncOf</source>
          <target state="translated">FuncOf</target>
        </trans-unit>
        <trans-unit id="727153d867d797c3632d8920f9ed42e20c01b542" translate="yes" xml:space="preserve">
          <source>FuncOf returns a function to be used by JavaScript.</source>
          <target state="translated">FuncOf返回一个将被JavaScript使用的函数。</target>
        </trans-unit>
        <trans-unit id="d863a41e98edea4d63050f4d41d85e38ee53432a" translate="yes" xml:space="preserve">
          <source>FuncOf returns a wrapped function.</source>
          <target state="translated">FuncOf返回一个封装的函数。</target>
        </trans-unit>
        <trans-unit id="93a168211e34460ad795ada01d7598344ab1ff0e" translate="yes" xml:space="preserve">
          <source>FuncOf returns the function type with the given argument and result types. For example if k represents int and e represents string, FuncOf([]Type{k}, []Type{e}, false) represents func(int) string.</source>
          <target state="translated">FuncOf返回给定参数和结果类型的函数类型。例如,如果k代表int,e代表字符串,则FuncOf([]Type{k},[]Type{e},false)代表func(int)字符串。</target>
        </trans-unit>
        <trans-unit id="e545c5b7597389c332937a417c6dbb10d7b9c2b9" translate="yes" xml:space="preserve">
          <source>Funcs adds the elements of the argument map to the template's function map. It must be called before the template is parsed. It panics if a value in the map is not a function with appropriate return type or if the name cannot be used syntactically as a function in a template. It is legal to overwrite elements of the map. The return value is the template, so calls can be chained.</source>
          <target state="translated">Funcs将参数映射的元素添加到模板的函数映射中。它必须在模板被解析之前被调用。如果映射中的一个值不是一个具有适当返回类型的函数,或者如果该名称在模板中不能作为函数的语法使用,它就会恐慌。覆盖地图中的元素是合法的。返回值是模板,所以可以连锁调用。</target>
        </trans-unit>
        <trans-unit id="d356e92562acfcaf97196969d96dd79e05dacf25" translate="yes" xml:space="preserve">
          <source>Funcs adds the elements of the argument map to the template's function map. It must be called before the template is parsed. It panics if a value in the map is not a function with appropriate return type. However, it is legal to overwrite elements of the map. The return value is the template, so calls can be chained.</source>
          <target state="translated">Funcs将参数映射的元素添加到模板的函数映射中。它必须在模板被解析之前被调用。如果映射中的一个值不是具有适当返回类型的函数,它就会恐慌。然而,覆盖地图中的元素是合法的。返回值是模板,所以可以连锁调用。</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="8c10d9660a016948a806bd8cbcad3722d8e6bc88" translate="yes" xml:space="preserve">
          <source>Functions and channels will not be sent in a gob. Attempting to encode such a value at the top level will fail. A struct field of chan or func type is treated exactly like an unexported field and is ignored.</source>
          <target state="translated">功能和通道将不会在gob中发送。试图在顶层对这样的值进行编码会失败。chan或func类型的结构体字段将被视为与未导出的字段完全相同,并被忽略。</target>
        </trans-unit>
        <trans-unit id="515fb65b2b3a55f3a5ea9024aecd183d10145a5b" translate="yes" xml:space="preserve">
          <source>Functions of the form</source>
          <target state="translated">形式的功能</target>
        </trans-unit>
        <trans-unit id="5bde1b79ff9cf2a64313aa293a07d05136a9d65d" translate="yes" xml:space="preserve">
          <source>Functions starting with &quot;Is&quot; can be used to inspect which table of range a rune belongs to. Note that runes may fit into more than one range.</source>
          <target state="translated">以 &quot;Is &quot;开头的函数可以用来检查一个符文属于哪个范围表。请注意,符文可能适合于一个以上的范围。</target>
        </trans-unit>
        <trans-unit id="14038939956e123c4daa0060310ed80bf1b7a49d" translate="yes" xml:space="preserve">
          <source>GC runs a garbage collection and blocks the caller until the garbage collection is complete. It may also block the entire program.</source>
          <target state="translated">GC运行一个垃圾收集,并阻止调用者,直到垃圾收集完成。它也可能阻塞整个程序。</target>
        </trans-unit>
        <trans-unit id="c7f87699bcc973fce315d8d3ae36debdf341faa6" translate="yes" xml:space="preserve">
          <source>GCD sets z to the greatest common divisor of a and b and returns z. If x or y are not nil, GCD sets their value such that z = a*x + b*y.</source>
          <target state="translated">GCD 将 z 设为 a 和 b 的最大公因子,并返回 z。如果 x 或 y 不是零,GCD 设它们的值,使 z=a*x+b*y。</target>
        </trans-unit>
        <trans-unit id="c1dacc63b01c8608c5a77320640ce147950f96e1" translate="yes" xml:space="preserve">
          <source>GCD sets z to the greatest common divisor of a and b, which both must be &amp;gt; 0, and returns z. If x or y are not nil, GCD sets their value such that z = a*x + b*y. If either a or b is &amp;lt;= 0, GCD sets z = x = y = 0.</source>
          <target state="translated">GCD将z设置为a和b的最大公约数（都必须大于0），并返回z。如果x或y不为零，则GCD将其值设置为z = a * x + b * y。如果a或b &amp;lt;= 0，则GCD设置z = x = y = 0。</target>
        </trans-unit>
        <trans-unit id="19dd357da96d7272320f7fadf3fd2965c024dba5" translate="yes" xml:space="preserve">
          <source>GCStats collect information about recent garbage collections.</source>
          <target state="translated">GCStats收集最近的垃圾收集信息。</target>
        </trans-unit>
        <trans-unit id="d010209a0c3d0dee637f5259dfa34515f68772df" translate="yes" xml:space="preserve">
          <source>GIF represents the possibly multiple images stored in a GIF file.</source>
          <target state="translated">GIF代表了存储在GIF文件中的可能的多个图像。</target>
        </trans-unit>
        <trans-unit id="f62024646db1c94f452ef8c25337fad08f62d18e" translate="yes" xml:space="preserve">
          <source>GOARCH is the running program's architecture target: one of 386, amd64, arm, s390x, and so on.</source>
          <target state="translated">GOARCH是运行程序的架构目标:386、amd64、arm、s390x等中的一种。</target>
        </trans-unit>
        <trans-unit id="cb34b31ce447e79881d19460e35c7075fc05a81a" translate="yes" xml:space="preserve">
          <source>GOMAXPROCS sets the maximum number of CPUs that can be executing simultaneously and returns the previous setting. If n &amp;lt; 1, it does not change the current setting. The number of logical CPUs on the local machine can be queried with NumCPU. This call will go away when the scheduler improves.</source>
          <target state="translated">GOMAXPROCS设置可以同时执行的最大CPU数，并返回以前的设置。如果n &amp;lt;1，则不会更改当前设置。可以使用NumCPU查询本地计算机上的逻辑CPU数量。调度程序改进后，此呼叫将消失。</target>
        </trans-unit>
        <trans-unit id="e0edbc08b54ba2717d6e63675d087628cd37bc2a" translate="yes" xml:space="preserve">
          <source>GOMAXPROCS sets the maximum number of CPUs that can be executing simultaneously and returns the previous setting. It defaults to the value of runtime.NumCPU. If n &amp;lt; 1, it does not change the current setting. This call will go away when the scheduler improves.</source>
          <target state="translated">GOMAXPROCS设置可以同时执行的最大CPU数，并返回以前的设置。默认为runtime.NumCPU的值。如果n &amp;lt;1，则不会更改当前设置。调度程序改进后，此呼叫将消失。</target>
        </trans-unit>
        <trans-unit id="ad65293e987b4a4c08430d0e000aecbc1854ac24" translate="yes" xml:space="preserve">
          <source>GOOS is the running program's operating system target: one of darwin, freebsd, linux, and so on. To view possible combinations of GOOS and GOARCH, run &quot;go tool dist list&quot;.</source>
          <target state="translated">GOOS是运行程序的操作系统目标:darwin、freebsd、linux等之一。要查看GOOS和GOARCH的可能组合,运行 &quot;go tool dist list&quot;。</target>
        </trans-unit>
        <trans-unit id="7bb230fcc10199af1bb88085306db7998e9674cd" translate="yes" xml:space="preserve">
          <source>GOROOT returns the root of the Go tree. It uses the GOROOT environment variable, if set at process start, or else the root used during the Go build.</source>
          <target state="translated">GOROOT 返回 Go 树的根。如果在进程启动时设置了GOROOT环境变量,则使用GOROOT环境变量,否则使用Go构建过程中使用的根。</target>
        </trans-unit>
        <trans-unit id="3552a70e477a364f8e82a292dad18f46a2ad988b" translate="yes" xml:space="preserve">
          <source>Gamma returns the Gamma function of x.</source>
          <target state="translated">Gamma 返回 x 的 Gamma 函数。</target>
        </trans-unit>
        <trans-unit id="a2672eb4dac0440844556fb66fa39b9edb2d2041" translate="yes" xml:space="preserve">
          <source>General:</source>
          <target state="translated">General:</target>
        </trans-unit>
        <trans-unit id="453efae49cba4a01a09c987414ab329ee6c4a305" translate="yes" xml:space="preserve">
          <source>Generally Get, Post, or PostForm will be used instead of Do.</source>
          <target state="translated">一般会用Get、Post或PostForm来代替Do。</target>
        </trans-unit>
        <trans-unit id="1c57b54aace051c9a60fd146f5087c013aa2d721" translate="yes" xml:space="preserve">
          <source>GenerateKey generates a public and private key pair.</source>
          <target state="translated">GenerateKey生成一个公钥和私钥对。</target>
        </trans-unit>
        <trans-unit id="db1ff76045ebe9cc510f3c31601ddcbcd7fd57de" translate="yes" xml:space="preserve">
          <source>GenerateKey generates a public&amp;amp;private key pair. The Parameters of the PrivateKey must already be valid (see GenerateParameters).</source>
          <target state="translated">GenerateKey生成一个公共和私有密钥对。私钥的参数必须已经有效（请参见GenerateParameters）。</target>
        </trans-unit>
        <trans-unit id="e650907b55be64a19300b70e59344d22b7245e9b" translate="yes" xml:space="preserve">
          <source>GenerateKey generates a public/private key pair using entropy from rand. If rand is nil, crypto/rand.Reader will be used.</source>
          <target state="translated">GenerateKey使用rand的熵生成一个公钥/私钥对。如果rand为nil,将使用crypto/rand.Reader。</target>
        </trans-unit>
        <trans-unit id="7f11f0f6942fab0ca9f944e5798d7d37395d774c" translate="yes" xml:space="preserve">
          <source>GenerateKey generates an RSA keypair of the given bit size using the random source random (for example, crypto/rand.Reader).</source>
          <target state="translated">GenerateKey使用随机源随机(例如,crypto/rand.Reader)生成给定比特大小的RSA密钥对。</target>
        </trans-unit>
        <trans-unit id="80806cb0e126f8dd45cfba36eccecc7429a61358" translate="yes" xml:space="preserve">
          <source>GenerateKey returns a public/private key pair. The private key is generated using the given reader, which must return random data.</source>
          <target state="translated">GenerateKey返回一个公钥/私钥对。私钥是用给定的读取器生成的,读取器必须返回随机数据。</target>
        </trans-unit>
        <trans-unit id="94cfc2c7f30a1879e413d8411b7005501c966655" translate="yes" xml:space="preserve">
          <source>GenerateMultiPrimeKey generates a multi-prime RSA keypair of the given bit size and the given random source, as suggested in [1]. Although the public keys are compatible (actually, indistinguishable) from the 2-prime case, the private keys are not. Thus it may not be possible to export multi-prime private keys in certain formats or to subsequently import them into other code.</source>
          <target state="translated">GenerateMultiPrimeKey按照[1]中的建议,生成给定比特大小和给定随机源的多主RSA密钥对。虽然公钥与2-prime情况下的公钥是兼容的(实际上是无法区分的),但私钥却不兼容。因此,不可能以某些格式导出多主密钥,也不可能随后将它们导入其他代码中。</target>
        </trans-unit>
        <trans-unit id="51625703089c85c9211c0ab627055dec67c2bfaf" translate="yes" xml:space="preserve">
          <source>GenerateParameters puts a random, valid set of DSA parameters into params. This function can take many seconds, even on fast machines.</source>
          <target state="translated">GenerateParameters 将一组随机的、有效的 DSA 参数放入 params 中。这个函数可能会耗费很多秒,即使在高速机器上也是如此。</target>
        </trans-unit>
        <trans-unit id="4ebb3d9bf07301446af753fd8cfde6a2dbd2f25b" translate="yes" xml:space="preserve">
          <source>Generic file system errors. Errors returned by file systems can be tested against these errors using errors.Is.</source>
          <target state="translated">通用的文件系统错误。文件系统返回的错误可以使用 errors.Is 对这些错误进行测试。</target>
        </trans-unit>
        <trans-unit id="bfffd736cddd08a4eee689949c3399cb61da773b" translate="yes" xml:space="preserve">
          <source>Get</source>
          <target state="translated">Get</target>
        </trans-unit>
        <trans-unit id="2fe964aa376032085805189a0397b3cdcf676226" translate="yes" xml:space="preserve">
          <source>Get gets the first value associated with the given key. If there are no values associated with the key, Get returns &quot;&quot;. It is case insensitive; textproto.CanonicalMIMEHeaderKey is used to canonicalize the provided key. To access multiple values of a key, or to use non-canonical keys, access the map directly.</source>
          <target state="translated">Get获取与给定键相关联的第一个值,如果没有与键相关联的值,Get返回&quot;&quot;。如果没有与key相关联的值,Get返回&quot;&quot;。它不区分大小写;textproto.CanonicalMIMEHeaderKey被用来对所提供的键进行规范化。要访问一个键的多个值,或者使用非规范键,请直接访问映射。</target>
        </trans-unit>
        <trans-unit id="3baa902f39cd83b30a85e419cba3b5af01d1e3ff" translate="yes" xml:space="preserve">
          <source>Get gets the first value associated with the given key. If there are no values associated with the key, Get returns &quot;&quot;. It is case insensitive; textproto.CanonicalMIMEHeaderKey is used to canonicalize the provided key. To use non-canonical keys, access the map directly.</source>
          <target state="translated">Get获取与给定键相关联的第一个值,如果没有与键相关联的值,Get返回&quot;&quot;。如果没有与key相关联的值,Get返回&quot;&quot;。它不区分大小写;textproto.CanonicalMIMEHeaderKey被用来规范化所提供的键。要使用非规范键,请直接访问映射。</target>
        </trans-unit>
        <trans-unit id="5819a3dfa32fe18b54e30756235c5c0b3e71efb0" translate="yes" xml:space="preserve">
          <source>Get gets the first value associated with the given key. If there are no values associated with the key, Get returns the empty string. To access multiple values, use the map directly.</source>
          <target state="translated">Get获取与给定键相关联的第一个值,如果没有与键相关联的值,Get返回空字符串。如果没有与key相关联的值,Get返回空字符串。要访问多个值,直接使用map。</target>
        </trans-unit>
        <trans-unit id="322573da1168297393f519b4b988bc100cbe0b6c" translate="yes" xml:space="preserve">
          <source>Get gets the first value associated with the given key. It is case insensitive; CanonicalMIMEHeaderKey is used to canonicalize the provided key. If there are no values associated with the key, Get returns &quot;&quot;. To access multiple values of a key, or to use non-canonical keys, access the map directly.</source>
          <target state="translated">获取与给定key相关联的第一个值。它对大小写不敏感;CanonicalMIMEHeaderKey被用来规范化所提供的key。如果没有与key相关联的值,Get返回&quot;&quot;。要访问一个键的多个值,或者使用非规范键,直接访问映射。</target>
        </trans-unit>
        <trans-unit id="70b433c8accfde2bcfff0de0db7ea43f32e215fb" translate="yes" xml:space="preserve">
          <source>Get gets the first value associated with the given key. It is case insensitive; CanonicalMIMEHeaderKey is used to canonicalize the provided key. If there are no values associated with the key, Get returns &quot;&quot;. To use non-canonical keys, access the map directly.</source>
          <target state="translated">获取与给定key相关联的第一个值。它对大小写不敏感;CanonicalMIMEHeaderKey被用来规范化所提供的key。如果没有与key相关联的值,Get返回&quot;&quot;。要使用非规范的键,直接访问映射。</target>
        </trans-unit>
        <trans-unit id="ec73d0c593dbece5412fe884185bdca68896527d" translate="yes" xml:space="preserve">
          <source>Get is a wrapper around DefaultClient.Get.</source>
          <target state="translated">Get是DefaultClient.Get的一个封装器。</target>
        </trans-unit>
        <trans-unit id="e51f2ab7d6fbd0e2ffab583f80049b3cfc794ac8" translate="yes" xml:space="preserve">
          <source>Get issues a GET to the specified URL. If the response is one of the following redirect codes, Get follows the redirect after calling the Client's CheckRedirect function:</source>
          <target state="translated">Get向指定的URL发出一个GET。如果响应是下面的重定向代码之一,Get在调用客户端的CheckRedirect函数后,会跟随重定向。</target>
        </trans-unit>
        <trans-unit id="cff58f3ccfaec37f9252515e01360ee67558791b" translate="yes" xml:space="preserve">
          <source>Get issues a GET to the specified URL. If the response is one of the following redirect codes, Get follows the redirect, up to a maximum of 10 redirects:</source>
          <target state="translated">Get向指定的URL发出一个GET。如果响应是下面的重定向代码之一,Get就会跟随重定向,最多重定向10次。</target>
        </trans-unit>
        <trans-unit id="4af41ae2934aaf3ecc571a5a758befaaf5dd46ec" translate="yes" xml:space="preserve">
          <source>Get retrieves a named exported variable. It returns nil if the name has not been registered.</source>
          <target state="translated">Get检索一个命名的导出变量。如果名称没有被注册,则返回nil。</target>
        </trans-unit>
        <trans-unit id="afa92ba06d138d5628558f74ba88a7e263aff277" translate="yes" xml:space="preserve">
          <source>Get returns the JavaScript property p of value v. It panics if v is not a JavaScript object.</source>
          <target state="translated">Get返回值v的JavaScript属性p,如果v不是JavaScript对象,它就会恐慌。</target>
        </trans-unit>
        <trans-unit id="1f152948d80d4df7cedf020669e282541979aaff" translate="yes" xml:space="preserve">
          <source>Get returns the value associated with key in the tag string. If there is no such key in the tag, Get returns the empty string. If the tag does not have the conventional format, the value returned by Get is unspecified. To determine whether a tag is explicitly set to the empty string, use Lookup.</source>
          <target state="translated">Get 返回与标签字符串中的 key 相关联的值,如果标签中没有 key,Get 返回空字符串。如果标签中没有这样的键,Get 返回空字符串。如果标记没有常规格式,则 Get 返回的值是未指定的。要确定一个标记是否被显式地设置为空字符串,请使用 Lookup。</target>
        </trans-unit>
        <trans-unit id="1c95403f4621e18fe8ba30c67d76e285e8214f43" translate="yes" xml:space="preserve">
          <source>Get selects an arbitrary item from the Pool, removes it from the Pool, and returns it to the caller. Get may choose to ignore the pool and treat it as empty. Callers should not assume any relation between values passed to Put and the values returned by Get.</source>
          <target state="translated">Get从Pool中选择一个任意的项目,从Pool中删除它,然后返回给调用者。Get可以选择忽略Pool,并将其视为空。调用者不应该假设传递给Put的值和Get返回的值之间有任何关系。</target>
        </trans-unit>
        <trans-unit id="c21e6716a05006be2a3b33da22f790cc4dacbd14" translate="yes" xml:space="preserve">
          <source>Get, Head, Post, and PostForm make HTTP (or HTTPS) requests:</source>
          <target state="translated">Get、Head、Post和PostForm进行HTTP(或HTTPS)请求。</target>
        </trans-unit>
        <trans-unit id="c5763aa4654b9f9e755a5247c7e85bd6431154eb" translate="yes" xml:space="preserve">
          <source>Getegid returns the numeric effective group id of the caller.</source>
          <target state="translated">Getegid返回调用者的有效数字组ID。</target>
        </trans-unit>
        <trans-unit id="3ce86e952faaa112161293325cc18e1e8b1d1f86" translate="yes" xml:space="preserve">
          <source>Getenv</source>
          <target state="translated">Getenv</target>
        </trans-unit>
        <trans-unit id="83272f1d9be5d707a2abc299316ecf8c20c6572e" translate="yes" xml:space="preserve">
          <source>Getenv retrieves the value of the environment variable named by the key. It returns the value, which will be empty if the variable is not present. To distinguish between an empty value and an unset value, use LookupEnv.</source>
          <target state="translated">Getenv检索由键命名的环境变量的值。它返回该值,如果变量不存在,则该值为空。要区分空值和未设置的值,使用LookupEnv。</target>
        </trans-unit>
        <trans-unit id="fb87cd5bc3aee2814b4736bc86345f331ef466ad" translate="yes" xml:space="preserve">
          <source>Geteuid returns the numeric effective user id of the caller.</source>
          <target state="translated">Geteuid返回调用者的有效数字用户ID。</target>
        </trans-unit>
        <trans-unit id="ba1ccf148fadcaa5a423e416bb3b76de027035d5" translate="yes" xml:space="preserve">
          <source>Getgid returns the numeric group id of the caller.</source>
          <target state="translated">Getgid返回调用者的数字组ID。</target>
        </trans-unit>
        <trans-unit id="1a0d3dfabc3d14d5473d84c935b43760abff4984" translate="yes" xml:space="preserve">
          <source>Getgroups returns a list of the numeric ids of groups that the caller belongs to.</source>
          <target state="translated">Getgroups返回调用者所属的组的数字id列表。</target>
        </trans-unit>
        <trans-unit id="cf37c04d335f6576ae2f027091318c6f433db063" translate="yes" xml:space="preserve">
          <source>Getpagesize returns the underlying system's memory page size.</source>
          <target state="translated">Getpagesize 返回底层系统的内存页面大小。</target>
        </trans-unit>
        <trans-unit id="98c30bd03388e6d00325569f2c09cb7a5c1f7d76" translate="yes" xml:space="preserve">
          <source>Getpid returns the process id of the caller.</source>
          <target state="translated">Getpid返回调用者的进程id。</target>
        </trans-unit>
        <trans-unit id="7d80618e0017c08138a1fb60fea1c4ec0dbcc585" translate="yes" xml:space="preserve">
          <source>Getppid returns the process id of the caller's parent.</source>
          <target state="translated">Getppid返回调用者的父进程ID。</target>
        </trans-unit>
        <trans-unit id="0420495bba5effaa143906967bf722c4ac8e2224" translate="yes" xml:space="preserve">
          <source>Getter is an interface that allows the contents of a Value to be retrieved. It wraps the Value interface, rather than being part of it, because it appeared after Go 1 and its compatibility rules. All Value types provided by this package satisfy the Getter interface, except the type used by Func.</source>
          <target state="translated">Getter是一个允许检索Value内容的接口。它包装了 Value 接口,而不是它的一部分,因为它出现在 Go 1 及其兼容性规则之后。本包提供的所有Value类型都满足Getter接口,除了Func使用的类型。</target>
        </trans-unit>
        <trans-unit id="ed660f2b70ea9d5fc73733f3c8d0fe3252a11e78" translate="yes" xml:space="preserve">
          <source>Getter is an interface that allows the contents of a Value to be retrieved. It wraps the Value interface, rather than being part of it, because it appeared after Go 1 and its compatibility rules. All Value types provided by this package satisfy the Getter interface.</source>
          <target state="translated">Getter是一个允许检索Value内容的接口。它包装了 Value 接口,而不是它的一部分,因为它出现在 Go 1 及其兼容性规则之后。本包提供的所有 Value 类型都满足 Getter 接口。</target>
        </trans-unit>
        <trans-unit id="87c5badfd378b66a2a7ada85f8b7415911742baa" translate="yes" xml:space="preserve">
          <source>Getuid returns the numeric user id of the caller.</source>
          <target state="translated">Getuid返回调用者的数字用户ID。</target>
        </trans-unit>
        <trans-unit id="55e12168bb983e41918aba1691a9e5f495430b36" translate="yes" xml:space="preserve">
          <source>Getwd returns a rooted path name corresponding to the current directory. If the current directory can be reached via multiple paths (due to symbolic links), Getwd may return any one of them.</source>
          <target state="translated">Getwd返回一个与当前目录相对应的根路径名,如果当前目录可以通过多个路径到达(由于符号链接),Getwd可以返回其中任何一个路径。如果当前目录可以通过多个路径到达(由于符号链接),Getwd可以返回其中任何一个路径。</target>
        </trans-unit>
        <trans-unit id="db8c30ea4bb862dc2beac406c90a324c6875e53e" translate="yes" xml:space="preserve">
          <source>Given that input, ReadMIMEHeader returns the map:</source>
          <target state="translated">给定该输入,ReadMIMEHeader返回该地图。</target>
        </trans-unit>
        <trans-unit id="0d7c5c492a7ddeb919966cbf89bf311a727d8ab3" translate="yes" xml:space="preserve">
          <source>Glob ignores file system errors such as I/O errors reading directories. The only possible returned error is ErrBadPattern, when pattern is malformed.</source>
          <target state="translated">Glob 忽略文件系统错误,如 I/O 错误读取目录。唯一可能返回的错误是ErrBadPattern,当pattern是畸形的。</target>
        </trans-unit>
        <trans-unit id="ec233ed9cb1b9df5201fce35a0b5f94ec953239c" translate="yes" xml:space="preserve">
          <source>Glob ignores file system errors such as I/O errors reading directories. The only possible returned error is path.ErrBadPattern, reporting that the pattern is malformed.</source>
          <target state="translated">Glob会忽略文件系统错误,如I/O错误读取目录。唯一可能返回的错误是path.ErrBadPattern,报告该模式是畸形的。</target>
        </trans-unit>
        <trans-unit id="5a57ea57c1f0982972dd2d2f408926f91cf67c45" translate="yes" xml:space="preserve">
          <source>Glob returns the names of all files matching pattern or nil if there is no matching file. The syntax of patterns is the same as in Match. The pattern may describe hierarchical names such as /usr/*/bin/ed (assuming the Separator is '/').</source>
          <target state="translated">Glob 返回与 pattern 匹配的所有文件的名称,如果没有匹配的文件,则返回 nil。pattern的语法与Match中的相同。模式可以描述层次名称,如/usr/*/bin/ed(假设分隔符是'/')。</target>
        </trans-unit>
        <trans-unit id="59177559b687a2613d20fb79582001f540617ebd" translate="yes" xml:space="preserve">
          <source>Glob returns the names of all files matching pattern or nil if there is no matching file. The syntax of patterns is the same as in path.Match. The pattern may describe hierarchical names such as usr/*/bin/ed.</source>
          <target state="translated">Glob返回所有与pattern匹配的文件名,如果没有匹配的文件,则返回nil。pattern的语法与path.Match中的相同。模式可以描述层次名称,如usr/*/bin/ed。</target>
        </trans-unit>
        <trans-unit id="599aa1de3cf0d500e8e5f7d1a178d0ab1cc0a630" translate="yes" xml:space="preserve">
          <source>Global returns the JavaScript global object, usually &quot;window&quot; or &quot;global&quot;.</source>
          <target state="translated">Global返回JavaScript全局对象,通常是 &quot;window &quot;或 &quot;global&quot;。</target>
        </trans-unit>
        <trans-unit id="2e0b45f2a456e8db55f08d7b65e87593a3e9a140" translate="yes" xml:space="preserve">
          <source>Go</source>
          <target state="translated">Go</target>
        </trans-unit>
        <trans-unit id="e2b7859482bcbcd7f30181447cb1227d814aecb3" translate="yes" xml:space="preserve">
          <source>Go Path</source>
          <target state="translated">前往路径</target>
        </trans-unit>
        <trans-unit id="31c51be344c4f61c8aa40bf7e10aeaf5b3b1af91" translate="yes" xml:space="preserve">
          <source>Go Programming Language</source>
          <target state="translated">Go编程语言</target>
        </trans-unit>
        <trans-unit id="2c968e5f87e6cf184e435232ef5dd7937823c72a" translate="yes" xml:space="preserve">
          <source>Go code built with -buildmode=c-archive or -buildmode=c-shared will not install any other signal handlers by default. If there is an existing signal handler, the Go runtime will turn on the SA_ONSTACK flag and otherwise keep the signal handler. If Notify is called for an asynchronous signal, a Go signal handler will be installed for that signal. If, later, Reset is called for that signal, the original handling for that signal will be reinstalled, restoring the non-Go signal handler if any.</source>
          <target state="translated">以-buildmode=c-archive或-buildmode=c-shared构建的Go代码默认不会安装任何其他信号处理程序。如果有一个现有的信号处理程序,Go运行时将开启SA_ONSTACK标志,否则将保留该信号处理程序。如果异步信号调用了Notify,则会为该信号安装Go信号处理程序。如果之后对该信号调用Reset,则将重新安装该信号的原始处理,恢复非Go信号处理程序(如果有的话)。</target>
        </trans-unit>
        <trans-unit id="799dd6ab824dcf093ff420451386c628fa2a9520" translate="yes" xml:space="preserve">
          <source>Go code built without -buildmode=c-archive or -buildmode=c-shared will install a signal handler for the asynchronous signals listed above, and save any existing signal handler. If a signal is delivered to a non-Go thread, it will act as described above, except that if there is an existing non-Go signal handler, that handler will be installed before raising the signal.</source>
          <target state="translated">没有使用 -buildmode=c-archive 或 -buildmode=c-shared 构建的围棋代码将为上述异步信号安装信号处理程序,并保存任何现有的信号处理程序。如果信号被传递给非围棋线程,它将如上所述,但如果有一个现有的非围棋信号处理程序,该处理程序将在引发信号之前被安装。</target>
        </trans-unit>
        <trans-unit id="eb5d4b3ab79b5b09438ad686f6a173b50aeb10bd" translate="yes" xml:space="preserve">
          <source>Go identifiers that appear in the words map are italicized; if the corresponding map value is not the empty string, it is considered a URL and the word is converted into a link.</source>
          <target state="translated">在map这个词中出现的围棋标识符会被斜体化,如果对应的map值不是空字符串,则视为URL,该词会被转换为链接。</target>
        </trans-unit>
        <trans-unit id="ea224aeb731dc78304c02f088e7a39cfe984c1f7" translate="yes" xml:space="preserve">
          <source>Go invokes the function asynchronously. It returns the Call structure representing the invocation. The done channel will signal when the call is complete by returning the same Call object. If done is nil, Go will allocate a new channel. If non-nil, done must be buffered or Go will deliberately crash.</source>
          <target state="translated">Go异步调用函数。它返回代表调用的Call结构。当调用完成时,done通道将通过返回相同的Call对象发出信号。如果 done 为 nil,Go 将分配一个新通道。如果非nil,done必须被缓冲,否则Go会故意崩溃。</target>
        </trans-unit>
        <trans-unit id="a7c304672885987fa9e2bc01caee3388d0b9796b" translate="yes" xml:space="preserve">
          <source>Go programs that use cgo or SWIG</source>
          <target state="translated">使用cgo或SWIG的围棋程序</target>
        </trans-unit>
        <trans-unit id="dd7dcac022db9d7876634d64e370d5b00e950d72" translate="yes" xml:space="preserve">
          <source>Go source files that import &quot;embed&quot; can use the //go:embed directive to initialize a variable of type string, []byte, or FS with the contents of files read from the package directory or subdirectories at compile time.</source>
          <target state="translated">导入 &quot;embed &quot;的Go源文件可以使用//go:embed指令,在编译时用从包目录或子目录中读取的文件内容初始化一个类型为string、[]byte或FS的变量。</target>
        </trans-unit>
        <trans-unit id="f00375ef44991e7032fc680e2e8afc5d4b4ddcac" translate="yes" xml:space="preserve">
          <source>GoStringer</source>
          <target state="translated">GoStringer</target>
        </trans-unit>
        <trans-unit id="776ec360ea626f63aba6d19bf197cc0106f28f0c" translate="yes" xml:space="preserve">
          <source>GoStringer is implemented by any value that has a GoString method, which defines the Go syntax for that value. The GoString method is used to print values passed as an operand to a %#v format.</source>
          <target state="translated">GoStringer由任何有GoString方法的值来实现,它定义了该值的Go语法。GoString方法用于打印作为操作数传递的%#v格式的值。</target>
        </trans-unit>
        <trans-unit id="06664245ef1dbe050dbc75990b043c9e9da34427" translate="yes" xml:space="preserve">
          <source>GoWhitespace is the default value for the Scanner's Whitespace field. Its value selects Go's white space characters.</source>
          <target state="translated">GoWhitespace是扫描仪的Whitespace字段的默认值。它的值可以选择Go的空白字符。</target>
        </trans-unit>
        <trans-unit id="13594eb4e63d05205c24ee0d18474bb09fad234a" translate="yes" xml:space="preserve">
          <source>Gob can decode a value of any type implementing the GobDecoder or encoding.BinaryUnmarshaler interfaces by calling the corresponding method, again in that order of preference.</source>
          <target state="translated">Gob可以通过调用相应的方法对实现GobDecoder或encoding.BinaryUnmarshaler接口的任何类型的值进行解码,同样按照优先级排序。</target>
        </trans-unit>
        <trans-unit id="7274c1618f0661ff86ead432a84f718728e78907" translate="yes" xml:space="preserve">
          <source>Gob can encode a value of any type implementing the GobEncoder or encoding.BinaryMarshaler interfaces by calling the corresponding method, in that order of preference.</source>
          <target state="translated">Gob可以通过调用相应的方法对实现GobEncoder或encoding.BinaryMarshaler接口的任何类型的值进行编码,按优先级排序。</target>
        </trans-unit>
        <trans-unit id="3f0664b183bab943699d699e2b7fa06d50e41b1a" translate="yes" xml:space="preserve">
          <source>GobDecode implements the gob.GobDecoder interface.</source>
          <target state="translated">GobDecode实现了gob.GobDecoder接口。</target>
        </trans-unit>
        <trans-unit id="d350a1211682bc77e1cf31df3df91c75eb68270c" translate="yes" xml:space="preserve">
          <source>GobDecode implements the gob.GobDecoder interface. The result is rounded per the precision and rounding mode of z unless z's precision is 0, in which case z is set exactly to the decoded value.</source>
          <target state="translated">GobDecode实现了gob.GobDecoder接口。其结果根据z的精度和四舍五入模式进行四舍五入,除非z的精度为0,在这种情况下,z被精确地设置为解码值。</target>
        </trans-unit>
        <trans-unit id="dd719ca2cfb03b3cfba4caf011be5a1140872694" translate="yes" xml:space="preserve">
          <source>GobDecoder is the interface describing data that provides its own routine for decoding transmitted values sent by a GobEncoder.</source>
          <target state="translated">GobDecoder是描述数据的接口,它为解码GobEncoder发送的传输值提供了自己的例程。</target>
        </trans-unit>
        <trans-unit id="d5aa87ccb7988a5106efef8e6d2f9cae7932e9c6" translate="yes" xml:space="preserve">
          <source>GobEncode implements the gob.GobEncoder interface.</source>
          <target state="translated">GobEncode实现了gob.GobEncoder接口。</target>
        </trans-unit>
        <trans-unit id="20cb90d239fa73b1f6938fdb92b390d973a1de7f" translate="yes" xml:space="preserve">
          <source>GobEncode implements the gob.GobEncoder interface. The Float value and all its attributes (precision, rounding mode, accuracy) are marshaled.</source>
          <target state="translated">GobEncode实现了gob.GobEncoder接口。Float值和它的所有属性(精度、四舍五入模式、准确度)都会被marshaled,GobEncode实现了gob.GobEncoder接口。</target>
        </trans-unit>
        <trans-unit id="a019b8cdacb9fe6be4bcfe375ae2210cd1a4074d" translate="yes" xml:space="preserve">
          <source>GobEncoder is the interface describing data that provides its own representation for encoding values for transmission to a GobDecoder. A type that implements GobEncoder and GobDecoder has complete control over the representation of its data and may therefore contain things such as private fields, channels, and functions, which are not usually transmissible in gob streams.</source>
          <target state="translated">GobEncoder是描述数据的接口,它提供了自己的表示方式,用于编码传输给GobDecoder的值。实现GobEncoder和GobDecoder的类型可以完全控制其数据的表示方式,因此可以包含诸如私有字段、通道和函数等通常在gob流中不可传输的东西。</target>
        </trans-unit>
        <trans-unit id="3af908c6818caa06d786a8ce4e61618d352da418" translate="yes" xml:space="preserve">
          <source>Goexit terminates the goroutine that calls it. No other goroutine is affected. Goexit runs all deferred calls before terminating the goroutine. Because Goexit is not a panic, any recover calls in those deferred functions will return nil.</source>
          <target state="translated">Goexit 终止调用它的 goroutine。其他goroutine不受影响。Goexit 在终止 goroutine 之前会运行所有的延迟调用。因为 Goexit 不是一个恐慌机制,所以这些递延函数中的任何恢复调用都将返回 nil。</target>
        </trans-unit>
        <trans-unit id="92c1b5045c151c8351b05867329857d4da35385e" translate="yes" xml:space="preserve">
          <source>GoroutineProfile returns n, the number of records in the active goroutine stack profile. If len(p) &amp;gt;= n, GoroutineProfile copies the profile into p and returns n, true. If len(p) &amp;lt; n, GoroutineProfile does not change p and returns n, false.</source>
          <target state="translated">GoroutineProfile返回n，即活动goroutine堆栈配置文件中的记录数。如果len（p）&amp;gt; = n，则GoroutineProfile将配置文件复制到p中并返回n，为true。如果len（p）&amp;lt;n，则GoroutineProfile不会更改p并返回n，否则为false。</target>
        </trans-unit>
        <trans-unit id="62967be4b08298e25e7959a7cdc5602a2a2be72a" translate="yes" xml:space="preserve">
          <source>Gosched yields the processor, allowing other goroutines to run. It does not suspend the current goroutine, so execution resumes automatically.</source>
          <target state="translated">Gosched让出处理器,允许其他goroutine运行。它不会暂停当前的goroutine,所以会自动恢复执行。</target>
        </trans-unit>
        <trans-unit id="1c2aaf1310e2e413d539667c1a3e7771e58933c6" translate="yes" xml:space="preserve">
          <source>GotConnInfo is the argument to the ClientTrace.GotConn function and contains information about the obtained connection.</source>
          <target state="translated">GotConnInfo 是 ClientTrace.GotConn 函数的参数,包含了所获得的连接信息。</target>
        </trans-unit>
        <trans-unit id="8aa6da089a7b549e351002a5e03605264795ad2e" translate="yes" xml:space="preserve">
          <source>GraphicRanges defines the set of graphic characters according to Unicode.</source>
          <target state="translated">GraphicRanges根据Unicode定义了图形字符集。</target>
        </trans-unit>
        <trans-unit id="e7195fa4641b119dd2889d0a417f633c2b3c037d" translate="yes" xml:space="preserve">
          <source>Gray is an in-memory image whose At method returns color.Gray values.</source>
          <target state="translated">Gray是一个内存中的图像,其At方法返回color.Gray值。</target>
        </trans-unit>
        <trans-unit id="8551691479e553fcfd58c230f9f1c7702a08e936" translate="yes" xml:space="preserve">
          <source>Gray represents an 8-bit grayscale color.</source>
          <target state="translated">灰色代表8位灰度颜色。</target>
        </trans-unit>
        <trans-unit id="8be44534e41a9fdc599304347782cb967b0bd62b" translate="yes" xml:space="preserve">
          <source>Gray16 is an in-memory image whose At method returns color.Gray16 values.</source>
          <target state="translated">Gray16是一个内存中的图像,其At方法返回color.Gray16值。</target>
        </trans-unit>
        <trans-unit id="b7ee628ee7a9a7bf06c313fa8d8dc808a58abb8f" translate="yes" xml:space="preserve">
          <source>Gray16 represents a 16-bit grayscale color.</source>
          <target state="translated">Gray16代表16位灰度颜色。</target>
        </trans-unit>
        <trans-unit id="6e09be6a83f7d3163e99081e0c679a65e139fc8d" translate="yes" xml:space="preserve">
          <source>Group represents a grouping of users.</source>
          <target state="translated">组表示用户的分组。</target>
        </trans-unit>
        <trans-unit id="7de1bb0487db53a77d3d5fa786aa26f9027ba7c1" translate="yes" xml:space="preserve">
          <source>GroupIds returns the list of group IDs that the user is a member of.</source>
          <target state="translated">GroupIds 返回用户所属组的ID列表。</target>
        </trans-unit>
        <trans-unit id="d0e679bf3eeb0246c0708b92532613618a2a5627" translate="yes" xml:space="preserve">
          <source>Grouping:</source>
          <target state="translated">Grouping:</target>
        </trans-unit>
        <trans-unit id="a3dd80da68d80e7f0e9f29bcc9f5cb31d2777884" translate="yes" xml:space="preserve">
          <source>Grow grows b's capacity, if necessary, to guarantee space for another n bytes. After Grow(n), at least n bytes can be written to b without another allocation. If n is negative, Grow panics.</source>
          <target state="translated">如果有必要,Grow会增长b的容量,以保证另外n个字节的空间。在Grow(n)之后,至少可以向b写入n个字节,而不需要再分配。如果n为负数,Grow就会恐慌。</target>
        </trans-unit>
        <trans-unit id="ea6ca3eab6713cfdabbbddc578b2358a70e4ccb7" translate="yes" xml:space="preserve">
          <source>Grow grows the buffer's capacity, if necessary, to guarantee space for another n bytes. After Grow(n), at least n bytes can be written to the buffer without another allocation. If n is negative, Grow will panic. If the buffer can't grow it will panic with ErrTooLarge.</source>
          <target state="translated">如果需要的话,Grow会增长缓冲区的容量,以保证另外n个字节的空间。在Grow(n)之后,至少可以向缓冲区写入n个字节,而不需要再分配。如果n为负数,Grow会惊慌失措。如果缓冲区不能增长,它将用ErrTooLarge恐慌。</target>
        </trans-unit>
        <trans-unit id="fcfc665b9c38534864ef4c48c8a42633500c63ee" translate="yes" xml:space="preserve">
          <source>Gzip files store a length and checksum of the uncompressed data. The Reader will return an ErrChecksum when Read reaches the end of the uncompressed data if it does not have the expected length or checksum. Clients should treat data returned by Read as tentative until they receive the io.EOF marking the end of the data.</source>
          <target state="translated">Gzip文件存储了未压缩数据的长度和校验和。当Read到达未压缩数据的末端时,如果它没有预期的长度或校验和,Read将返回一个ErrChecksum。客户端应该将Read返回的数据视为暂定数据,直到收到标记数据结束的io.EOF。</target>
        </trans-unit>
        <trans-unit id="5d71851e777cb11c10615f1403f7831b2abdc279" translate="yes" xml:space="preserve">
          <source>HTML encapsulates a known safe HTML document fragment. It should not be used for HTML from a third-party, or HTML with unclosed tags or comments. The outputs of a sound HTML sanitizer and a template escaped by this package are fine for use with HTML.</source>
          <target state="translated">HTML封装了一个已知的安全的HTML文档片段,它不应该用于来自第三方的HTML,或带有未封闭标签或注释的HTML。它不应该被用于来自第三方的HTML,或者带有未关闭的标签或注释的HTML。健全的HTML消毒器的输出和被本包逃逸的模板都可以用于HTML。</target>
        </trans-unit>
        <trans-unit id="b3eeeba32a88681f357c6658794b2cde0a1ffee1" translate="yes" xml:space="preserve">
          <source>HTML templates treat data values as plain text which should be encoded so they can be safely embedded in an HTML document. The escaping is contextual, so actions can appear within JavaScript, CSS, and URI contexts.</source>
          <target state="translated">HTML模板将数据值视为纯文本,应该对其进行编码,以便它们可以安全地嵌入到HTML文档中。转义是上下文的,所以动作可以出现在JavaScript、CSS和URI上下文中。</target>
        </trans-unit>
        <trans-unit id="9941fc69ceb0b7c4c9cd661ccc1d3296d53a1466" translate="yes" xml:space="preserve">
          <source>HTMLAttr encapsulates an HTML attribute from a trusted source, for example, ` dir=&quot;ltr&quot;`.</source>
          <target state="translated">HTMLAttr封装了一个来自可信源的HTML属性,例如`dir=&quot;ltr&quot;`。</target>
        </trans-unit>
        <trans-unit id="56515df9ce780f70db2a14123d61a78cb0491ced" translate="yes" xml:space="preserve">
          <source>HTMLAutoClose is the set of HTML elements that should be considered to close automatically.</source>
          <target state="translated">HTMLAutoClose是一组应该考虑自动关闭的HTML元素。</target>
        </trans-unit>
        <trans-unit id="e3ae2c19a119f12f6bd7618bea966cc88fb1903b" translate="yes" xml:space="preserve">
          <source>HTMLEntity is an entity map containing translations for the standard HTML entity characters.</source>
          <target state="translated">HTMLEntity是一个包含标准HTML实体字符翻译的实体图。</target>
        </trans-unit>
        <trans-unit id="0502b94bdac42557ec458b2bcfd7d81519bb7f5f" translate="yes" xml:space="preserve">
          <source>HTMLEscape</source>
          <target state="translated">HTMLEscape</target>
        </trans-unit>
        <trans-unit id="108bb0274697ed474af72c0af28941c4694cc443" translate="yes" xml:space="preserve">
          <source>HTMLEscape appends to dst the JSON-encoded src with &amp;lt;, &amp;gt;, &amp;amp;, U+2028 and U+2029 characters inside string literals changed to \u003c, \u003e, \u0026, \u2028, \u2029 so that the JSON will be safe to embed inside HTML &amp;lt;script&amp;gt; tags. For historical reasons, web browsers don't honor standard HTML escaping within &amp;lt;script&amp;gt; tags, so an alternative JSON encoding must be used.</source>
          <target state="translated">HTMLEscape在字符串文字中将&amp;lt;，&amp;gt;，＆，U + 2028和U + 2029字符附加到dst JSON编码的src，这些字符已更改为\ u003c，\ u003e，\ u0026，\ u2028，\ u2029，以便JSON安全嵌入HTML &amp;lt;script&amp;gt;标记中。由于历史原因，Web浏览器不支持&amp;lt;script&amp;gt;标记内的标准HTML转义，因此必须使用替代的JSON编码。</target>
        </trans-unit>
        <trans-unit id="eaa5eff89dbdb13500c068f0e84bf21b7f3be3fb" translate="yes" xml:space="preserve">
          <source>HTMLEscape writes to w the escaped HTML equivalent of the plain text data b.</source>
          <target state="translated">HTMLEscape将纯文本数据b的转义HTML等价物写入w。</target>
        </trans-unit>
        <trans-unit id="eba1f3f7ea429a820bedfa415a707d8da7ce1238" translate="yes" xml:space="preserve">
          <source>HTMLEscapeString returns the escaped HTML equivalent of the plain text data s.</source>
          <target state="translated">HTMLEscapeString 返回纯文本数据 s 的转义 HTML 等价物。</target>
        </trans-unit>
        <trans-unit id="8b2dbe52305b6c07dd244c27d634207753a8523e" translate="yes" xml:space="preserve">
          <source>HTMLEscaper returns the escaped HTML equivalent of the textual representation of its arguments.</source>
          <target state="translated">HTMLEscaper返回其参数的文本表示的转义HTML等价物。</target>
        </trans-unit>
        <trans-unit id="9304c86e0fba62ba5daa5297c254f425c77df161" translate="yes" xml:space="preserve">
          <source>HTTP Trailers are a set of key/value pairs like headers that come after the HTTP response, instead of before.</source>
          <target state="translated">HTTP Trailers是一组key/value对,就像HTTP响应后的头信息,而不是之前的头信息。</target>
        </trans-unit>
        <trans-unit id="0f4dea56c9591992aae081556a866da7a62d7c76" translate="yes" xml:space="preserve">
          <source>HTTP status codes as registered with IANA. See: &lt;a href=&quot;https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml&quot;&gt;https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml&lt;/a&gt;</source>
          <target state="translated">向IANA注册的HTTP状态代码。请参阅：&lt;a href=&quot;https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml&quot;&gt;https&lt;/a&gt;：//www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</target>
        </trans-unit>
        <trans-unit id="ffb0634925a034a37cf81c8bf163966c760740e9" translate="yes" xml:space="preserve">
          <source>HTTP/2 support is only enabled if the Listener returns *tls.Conn connections and they were configured with &quot;h2&quot; in the TLS Config.NextProtos.</source>
          <target state="translated">只有当Listener返回*tls.Conn连接,并且它们在TLS Config.NextProtos中被配置为 &quot;h2 &quot;时,才会启用HTTP/2支持。</target>
        </trans-unit>
        <trans-unit id="5ee0353f20802f9b3b832dc664b1cf16f1dd8c83" translate="yes" xml:space="preserve">
          <source>HalfReader returns a Reader that implements Read by reading half as many requested bytes from r.</source>
          <target state="translated">HalfReader返回一个实现Read的Reader,从r中读取一半的请求字节。</target>
        </trans-unit>
        <trans-unit id="c0392b2b1c472815ba8d1a1e3b20f4a279bf6c50" translate="yes" xml:space="preserve">
          <source>Handle</source>
          <target state="translated">Handle</target>
        </trans-unit>
        <trans-unit id="1f7743a2da5a9b87698980081ed0a9b4a848c67b" translate="yes" xml:space="preserve">
          <source>Handle registers the handler for the given pattern in the DefaultServeMux. The documentation for ServeMux explains how patterns are matched.</source>
          <target state="translated">Handle在DefaultServeMux中注册给定模式的处理程序。ServeMux的文档解释了如何匹配模式。</target>
        </trans-unit>
        <trans-unit id="adfb5ece7bb714f07a8d92f38ecaccd93eb91488" translate="yes" xml:space="preserve">
          <source>Handle registers the handler for the given pattern. If a handler already exists for pattern, Handle panics.</source>
          <target state="translated">Handle注册给定模式的处理程序。如果pattern已经存在一个处理程序,那么Handle就会惊慌失措。</target>
        </trans-unit>
        <trans-unit id="9df709e02c4285ab3a3440b49e05002a1810c202" translate="yes" xml:space="preserve">
          <source>HandleFunc</source>
          <target state="translated">HandleFunc</target>
        </trans-unit>
        <trans-unit id="ba3631b03a8549831c70fb0b756b06eb4ccdf22e" translate="yes" xml:space="preserve">
          <source>HandleFunc registers the handler function for the given pattern in the DefaultServeMux. The documentation for ServeMux explains how patterns are matched.</source>
          <target state="translated">HandleFunc在DefaultServeMux中注册给定模式的处理函数。ServeMux的文档解释了如何匹配模式。</target>
        </trans-unit>
        <trans-unit id="671e02c9111874e0dde4ea20673fb01320ed5a12" translate="yes" xml:space="preserve">
          <source>HandleFunc registers the handler function for the given pattern.</source>
          <target state="translated">HandleFunc为给定模式注册处理函数。</target>
        </trans-unit>
        <trans-unit id="b8bc0ae743c24154bab55e05ddac119f84a83a3e" translate="yes" xml:space="preserve">
          <source>HandleHTTP registers an HTTP handler for RPC messages on rpcPath, and a debugging handler on debugPath. It is still necessary to invoke http.Serve(), typically in a go statement.</source>
          <target state="translated">HandleHTTP 在 rpcPath 上注册了一个 RPC 消息的 HTTP 处理程序,在 debugPath 上注册了一个调试处理程序。仍然需要调用http.Serve(),通常在go语句中调用。</target>
        </trans-unit>
        <trans-unit id="104cf096656ffcb1565dfd1219d7035e43630f88" translate="yes" xml:space="preserve">
          <source>HandleHTTP registers an HTTP handler for RPC messages to DefaultServer on DefaultRPCPath and a debugging handler on DefaultDebugPath. It is still necessary to invoke http.Serve(), typically in a go statement.</source>
          <target state="translated">HandleHTTP在DefaultRPCPath上为DefaultServer注册了一个RPC消息的HTTP处理程序,在DefaultDebugPath上注册了一个调试处理程序。仍然需要调用http.Serve(),通常是在go语句中。</target>
        </trans-unit>
        <trans-unit id="a62b57b0720d266ed6489a123759bbfe855bf88a" translate="yes" xml:space="preserve">
          <source>Handler also returns the registered pattern that matches the request or, in the case of internally-generated redirects, the pattern that will match after following the redirect.</source>
          <target state="translated">处理程序还返回与请求相匹配的注册模式,如果是内部生成的重定向,则返回跟随重定向后将匹配的模式。</target>
        </trans-unit>
        <trans-unit id="0ddb06f6f85fc2ca7a7cc5302dfee4fc45947bee" translate="yes" xml:space="preserve">
          <source>Handler returns an HTTP handler that serves the named profile.</source>
          <target state="translated">处理程序返回一个为命名的配置文件服务的HTTP处理程序。</target>
        </trans-unit>
        <trans-unit id="4065eef104a7b00ebd8ce9a91293334fd4bb0db9" translate="yes" xml:space="preserve">
          <source>Handler returns the expvar HTTP Handler.</source>
          <target state="translated">处理程序返回expvar HTTP处理程序。</target>
        </trans-unit>
        <trans-unit id="e63273beb69f3454c447975682e44a2c5d4a0c1e" translate="yes" xml:space="preserve">
          <source>Handler returns the handler to use for the given request, consulting r.Method, r.Host, and r.URL.Path. It always returns a non-nil handler. If the path is not in its canonical form, the handler will be an internally-generated handler that redirects to the canonical path. If the host contains a port, it is ignored when matching handlers.</source>
          <target state="translated">处理程序通过咨询r.Method、r.Host和r.URL.Path,返回给定请求要使用的处理程序。它总是返回一个非零的处理程序。如果路径不是规范的形式,处理程序将是一个内部生成的处理程序,它将重定向到规范的路径。如果主机包含一个端口,那么在匹配处理程序时,它将被忽略。</target>
        </trans-unit>
        <trans-unit id="a812b2fb8f7451d8a9be630f8c521fc7613cf74d" translate="yes" xml:space="preserve">
          <source>Handler runs an executable in a subprocess with a CGI environment.</source>
          <target state="translated">处理程序在具有CGI环境的子进程中运行一个可执行文件。</target>
        </trans-unit>
        <trans-unit id="612e8566dcf29030b3f86ae45fac3cd161070575" translate="yes" xml:space="preserve">
          <source>Handling of anonymous struct fields is new in Go 1.1. Prior to Go 1.1, anonymous struct fields were ignored. To force ignoring of an anonymous struct field in both current and earlier versions, give the field a JSON tag of &quot;-&quot;.</source>
          <target state="translated">匿名结构体字段的处理是 Go 1.1 中的新内容。在 Go 1.1 之前,匿名结构字段是被忽略的。要在当前和早期版本中强制忽略匿名结构字段,请给字段一个JSON标签&quot;-&quot;。</target>
        </trans-unit>
        <trans-unit id="5bd11c3402a6253a1d760b097dca2d66d778e6dd" translate="yes" xml:space="preserve">
          <source>Handshake runs the client or server handshake protocol if it has not yet been run.</source>
          <target state="translated">如果尚未运行握手协议,则运行客户端或服务器握手协议。</target>
        </trans-unit>
        <trans-unit id="8bd5447a341844b0e1ee2ac00ed949437eac1c43" translate="yes" xml:space="preserve">
          <source>Handshake runs the client or server handshake protocol if it has not yet been run. Most uses of this package need not call Handshake explicitly: the first Read or Write will call it automatically.</source>
          <target state="translated">如果还没有运行Handshake协议,Handshake会运行客户端或服务器的Handshake协议。这个包的大多数用途不需要明确地调用Handshake:第一次读或写会自动调用它。</target>
        </trans-unit>
        <trans-unit id="0bf39eaf505133458b930fe0c34986ca5b577cc9" translate="yes" xml:space="preserve">
          <source>HasExpired reports whether certList should have been updated by now.</source>
          <target state="translated">HasExpired报告certList是否已经更新。</target>
        </trans-unit>
        <trans-unit id="d390517d58b930cb269df7a0b32aa914bfb5311d" translate="yes" xml:space="preserve">
          <source>HasOk reports whether the corresponding expression may be used on the rhs of a comma-ok assignment.</source>
          <target state="translated">HasOk报告是否可以在逗号ok赋值的rhs上使用相应的表达式。</target>
        </trans-unit>
        <trans-unit id="e53848ef4c6fc884ed74c95d3ab525fa42a2bbe7" translate="yes" xml:space="preserve">
          <source>HasPrefix</source>
          <target state="translated">HasPrefix</target>
        </trans-unit>
        <trans-unit id="8d314f541aff1011d7ddb318695b8f61b2af6ec2" translate="yes" xml:space="preserve">
          <source>HasPrefix exists for historical compatibility and should not be used.</source>
          <target state="translated">HasPrefix是为了历史兼容性而存在的,不应该被使用。</target>
        </trans-unit>
        <trans-unit id="2669e9427d4779bbc09f60c5ccfd3fe6d15b6c70" translate="yes" xml:space="preserve">
          <source>HasPrefix tests whether the byte slice s begins with prefix.</source>
          <target state="translated">HasPrefix测试字节片断s是否以前缀开始。</target>
        </trans-unit>
        <trans-unit id="5cd07ae1c7bc3b9ed87eb16cdb61e05184635090" translate="yes" xml:space="preserve">
          <source>HasPrefix tests whether the string s begins with prefix.</source>
          <target state="translated">HasPrefix测试字符串s是否以前缀开始。</target>
        </trans-unit>
        <trans-unit id="117455f286c7643c45e4bb7a574dddee082000d6" translate="yes" xml:space="preserve">
          <source>HasSuffix</source>
          <target state="translated">HasSuffix</target>
        </trans-unit>
        <trans-unit id="0d84ad6d23e5d60c659894725feb80de1e5bc00b" translate="yes" xml:space="preserve">
          <source>HasSuffix tests whether the byte slice s ends with suffix.</source>
          <target state="translated">HasSuffix测试字节片断s是否以后缀结束。</target>
        </trans-unit>
        <trans-unit id="71e6720e740d9f5d90d030cf5d260029a0041a76" translate="yes" xml:space="preserve">
          <source>HasSuffix tests whether the string s ends with suffix.</source>
          <target state="translated">HasSuffix测试字符串s是否以后缀结束。</target>
        </trans-unit>
        <trans-unit id="c07fb815b0dd23f98464b6c96ba0043996f42574" translate="yes" xml:space="preserve">
          <source>Hash identifies a cryptographic hash function that is implemented in another package.</source>
          <target state="translated">哈希标识了一个在另一个包中实现的加密哈希函数。</target>
        </trans-unit>
        <trans-unit id="a8a4a81d7a93ec8ea6de29fca7e817e8b0ccf094" translate="yes" xml:space="preserve">
          <source>Hash implementations in the standard library (e.g. hash/crc32 and crypto/sha256) implement the encoding.BinaryMarshaler and encoding.BinaryUnmarshaler interfaces. Marshaling a hash implementation allows its internal state to be saved and used for additional processing later, without having to re-write the data previously written to the hash. The hash state may contain portions of the input in its original form, which users are expected to handle for any possible security implications.</source>
          <target state="translated">标准库中的哈希实现(如hash/crc32和crypto/sha256)实现了encoding.BinaryMarshaler和encoding.BinaryUnmarshaler接口。对一个哈希实现进行Marshaling,可以保存其内部状态,并用于以后的额外处理,而不必重新编写之前写入哈希的数据。哈希状态可能包含原始形式的输入的部分,用户应该处理任何可能的安全影响。</target>
        </trans-unit>
        <trans-unit id="afa3769866aaa8e9ccd0894bbb12db0f2a42b294" translate="yes" xml:space="preserve">
          <source>Hash is the common interface implemented by all hash functions.</source>
          <target state="translated">Hash是所有哈希函数实现的通用接口。</target>
        </trans-unit>
        <trans-unit id="bbb248d3e1082f71a91f55221f9ef1629bac5c92" translate="yes" xml:space="preserve">
          <source>Hash32 is the common interface implemented by all 32-bit hash functions.</source>
          <target state="translated">Hash32是所有32位哈希函数实现的通用接口。</target>
        </trans-unit>
        <trans-unit id="05bc44af5e367ef4fc60329373f6d1a44dbf5c85" translate="yes" xml:space="preserve">
          <source>Hash64 is the common interface implemented by all 64-bit hash functions.</source>
          <target state="translated">Hash64是所有64位哈希函数实现的通用接口。</target>
        </trans-unit>
        <trans-unit id="4aa2a3cc436464a090fd637734a2095043d7b259" translate="yes" xml:space="preserve">
          <source>HashFunc returns opts.Hash so that PSSOptions implements crypto.SignerOpts.</source>
          <target state="translated">HashFunc返回opts.Hash,使PSSOptions实现crypto.SignerOpts。</target>
        </trans-unit>
        <trans-unit id="3959061e57c74057bbf958321e7f6031a26bba89" translate="yes" xml:space="preserve">
          <source>HashFunc returns pssOpts.Hash so that PSSOptions implements crypto.SignerOpts.</source>
          <target state="translated">HashFunc返回pssOpts.Hash,使PSSOptions实现crypto.SignerOpts。</target>
        </trans-unit>
        <trans-unit id="860155016136afc0d36dbbc3f9fc98412399783e" translate="yes" xml:space="preserve">
          <source>HashFunc simply returns the value of h so that Hash implements SignerOpts.</source>
          <target state="translated">HashFunc只需返回h的值,这样Hash就实现了SignerOpts。</target>
        </trans-unit>
        <trans-unit id="2d042d0360cc7e1f18d91ae4331ed196e499f0e3" translate="yes" xml:space="preserve">
          <source>Hashes are intended to be collision-resistant, even for situations where an adversary controls the byte sequences being hashed.</source>
          <target state="translated">哈希值的目的是为了抗碰撞,即使在对手控制被哈希的字节序列的情况下也是如此。</target>
        </trans-unit>
        <trans-unit id="cd2b2728ea1f997355e4a7e5005a26c5306f470a" translate="yes" xml:space="preserve">
          <source>Head is a wrapper around DefaultClient.Head</source>
          <target state="translated">Head是DefaultClient.Head的封装器。</target>
        </trans-unit>
        <trans-unit id="93e59ac29bb3c357b0f9c42db1f78e97e116c128" translate="yes" xml:space="preserve">
          <source>Head issues a HEAD to the specified URL. If the response is one of the following redirect codes, Head follows the redirect after calling the Client's CheckRedirect function:</source>
          <target state="translated">Head向指定的URL发出一个HEAD。如果响应是下面的重定向代码之一,Head在调用客户端的CheckRedirect函数后,会跟随重定向。</target>
        </trans-unit>
        <trans-unit id="24094406af9408bd066ab26a0a1ef55bdcdead08" translate="yes" xml:space="preserve">
          <source>Head issues a HEAD to the specified URL. If the response is one of the following redirect codes, Head follows the redirect, up to a maximum of 10 redirects:</source>
          <target state="translated">Head向指定的URL发出一个HEAD。如果响应是以下重定向代码之一,Head就会跟随重定向,最多重定向10次。</target>
        </trans-unit>
        <trans-unit id="a50c7cbf99b8cae529cf3d620f5022a1c82e8fca" translate="yes" xml:space="preserve">
          <source>Header implements http.ResponseWriter. It returns the response headers to mutate within a handler. To test the headers that were written after a handler completes, use the Result method and see the returned Response value's Header.</source>
          <target state="translated">Header 实现 http.ResponseWriter。它返回要在处理程序中突变的响应头文件。要测试处理程序完成后写入的头信息,可以使用 Result 方法查看返回的 Response 值的 Header。</target>
        </trans-unit>
        <trans-unit id="2a403ca7fd2ae0865923ded1f911ee30d4fbde83" translate="yes" xml:space="preserve">
          <source>Hello sends a HELO or EHLO to the server as the given host name. Calling this method is only necessary if the client needs control over the host name used. The client will introduce itself as &quot;localhost&quot; automatically otherwise. If Hello is called, it must be called before any of the other methods.</source>
          <target state="translated">Hello作为给定的主机名向服务器发送HELO或EHLO。只有当客户端需要控制使用的主机名时才需要调用这个方法。否则客户端会自动将自己介绍为 &quot;localhost&quot;。如果调用Hello,必须在其他方法之前调用。</target>
        </trans-unit>
        <trans-unit id="0aed41610e50a1818172a103900a5a6fdac5322e" translate="yes" xml:space="preserve">
          <source>Helper marks the calling function as a test helper function. When printing file and line information, that function will be skipped. Helper may be called simultaneously from multiple goroutines.</source>
          <target state="translated">Helper 将调用的函数标记为测试辅助函数。当打印文件和行信息时,该函数将被跳过。Helper可以从多个goroutine中同时调用。</target>
        </trans-unit>
        <trans-unit id="aa0b52b8a6b42d9b0905c653c010a924ae5e874a" translate="yes" xml:space="preserve">
          <source>Here are some example one-line templates demonstrating pipelines and variables. All produce the quoted word &quot;output&quot;:</source>
          <target state="translated">以下是一些演示管道和变量的单行模板示例。所有的模板都会产生引号 &quot;output &quot;这个词。</target>
        </trans-unit>
        <trans-unit id="89620d229387855063bd56a8e6d5a3250086c9f0" translate="yes" xml:space="preserve">
          <source>Here is a simple example, opening a file and reading some of it.</source>
          <target state="translated">下面是一个简单的例子,打开一个文件,读取其中的一些内容。</target>
        </trans-unit>
        <trans-unit id="2824caba6baa2187c9e56d7836920f8ff25bcc71" translate="yes" xml:space="preserve">
          <source>Here is a simple example. A server wishes to export an object of type Arith:</source>
          <target state="translated">下面是一个简单的例子。一个服务器希望导出一个Arith类型的对象。</target>
        </trans-unit>
        <trans-unit id="2c22db98d01fc50d0681541a0b0caf2c4141f0f4" translate="yes" xml:space="preserve">
          <source>Here is a trivial example that prints &quot;17 items are made of wool&quot;.</source>
          <target state="translated">这里有一个微不足道的例子,印有 &quot;17件商品是用羊毛制成的&quot;。</target>
        </trans-unit>
        <trans-unit id="dc0bea3647dd8635722162c3a9c56cc10d70b7ac" translate="yes" xml:space="preserve">
          <source>Here is the list of actions. &quot;Arguments&quot; and &quot;pipelines&quot; are evaluations of data, defined in detail in the corresponding sections that follow.</source>
          <target state="translated">下面是动作列表。&quot;参数 &quot;和 &quot;管道 &quot;是对数据的评价,在后面的相应章节中详细定义。</target>
        </trans-unit>
        <trans-unit id="c3b612d75a40adadd01e188d1e2aba30e8b88d33" translate="yes" xml:space="preserve">
          <source>Here we demonstrate loading a set of templates from a directory.</source>
          <target state="translated">这里我们演示了从目录中加载一组模板。</target>
        </trans-unit>
        <trans-unit id="c18d789286c40d70b27c77faebcb174f22c85dbc" translate="yes" xml:space="preserve">
          <source>Here we demonstrate loading a set of templates from files in different directories</source>
          <target state="translated">在这里,我们演示了从不同目录下的文件加载一组模板的过程</target>
        </trans-unit>
        <trans-unit id="bcef5f73d0a48aab25273d92f8664ff4fb80379d" translate="yes" xml:space="preserve">
          <source>Here's an example directory layout:</source>
          <target state="translated">下面是一个目录布局的例子。</target>
        </trans-unit>
        <trans-unit id="35d5d6962be99793c34862b1061c8b5cacf67fc9" translate="yes" xml:space="preserve">
          <source>HexEncoding is the &amp;ldquo;Extended Hex Alphabet&amp;rdquo; defined in RFC 4648. It is typically used in DNS.</source>
          <target state="translated">HexEncoding是RFC 4648中定义的&amp;ldquo;扩展十六进制字母&amp;rdquo;。通常在DNS中使用。</target>
        </trans-unit>
        <trans-unit id="e23f68e03ccbc9812663415a4a25267a75156114" translate="yes" xml:space="preserve">
          <source>Hijack detaches the ClientConn and returns the underlying connection as well as the read-side bufio which may have some left over data. Hijack may be called before the user or Read have signaled the end of the keep-alive logic. The user should not call Hijack while Read or Write is in progress.</source>
          <target state="translated">Hijack分离ClientConn,并返回底层连接以及可能有一些剩余数据的读端bufio。Hijack可以在用户或Read发出keep-alive逻辑结束的信号之前被调用。当Read或Write正在进行时,用户不应该调用Hijack。</target>
        </trans-unit>
        <trans-unit id="9150896df8944dbbb2d645bc78167fd76df1dc80" translate="yes" xml:space="preserve">
          <source>Hijack detaches the ServerConn and returns the underlying connection as well as the read-side bufio which may have some left over data. Hijack may be called before Read has signaled the end of the keep-alive logic. The user should not call Hijack while Read or Write is in progress.</source>
          <target state="translated">Hijack分离ServerConn,并返回底层连接以及可能有一些剩余数据的读端bufio。Hijack可以在Read发出keep-alive逻辑结束的信号之前被调用。当Read或Write正在进行时,用户不应该调用Hijack。</target>
        </trans-unit>
        <trans-unit id="4a56321e103f0a1a522b694db3cb8d2d733e26fd" translate="yes" xml:space="preserve">
          <source>Hijacker</source>
          <target state="translated">Hijacker</target>
        </trans-unit>
        <trans-unit id="162450ef640a1216b7486b356d2e0daf7f97ce1d" translate="yes" xml:space="preserve">
          <source>Hostname returns the host name reported by the kernel.</source>
          <target state="translated">Hostname 返回内核报告的主机名。</target>
        </trans-unit>
        <trans-unit id="96c776e02774d643d6c9b2543ae4ea531e374ca6" translate="yes" xml:space="preserve">
          <source>Hostname returns u.Host, stripping any valid port number if present.</source>
          <target state="translated">Hostname 返回 u.Host,如果存在,则去除任何有效的端口号。</target>
        </trans-unit>
        <trans-unit id="c10a91f09a43d36b8c063665239759dddfc07545" translate="yes" xml:space="preserve">
          <source>HostnameError results when the set of authorized names doesn't match the requested name.</source>
          <target state="translated">当授权名称集与请求的名称不匹配时,会出现HostnameError。</target>
        </trans-unit>
        <trans-unit id="a732fe7ae23ec635b26f3cda289c15cbca4f3d8c" translate="yes" xml:space="preserve">
          <source>Hour returns the hour within the day specified by t, in the range [0, 23].</source>
          <target state="translated">Hour 返回 t 指定的一天中的小时,范围为 [0,23]。</target>
        </trans-unit>
        <trans-unit id="316afefe22138dc95ee9f3b2f4bc4164e8b8424e" translate="yes" xml:space="preserve">
          <source>Hours returns the duration as a floating point number of hours.</source>
          <target state="translated">小时数 返回浮点小时数的持续时间。</target>
        </trans-unit>
        <trans-unit id="29032d83edd3b2c57e81fe35f7063e01de42a614" translate="yes" xml:space="preserve">
          <source>However, there can be multiple leftmost-longest matches, with different submatch choices, and here this package diverges from POSIX. Among the possible leftmost-longest matches, this package chooses the one that a backtracking search would have found first, while POSIX specifies that the match be chosen to maximize the length of the first subexpression, then the second, and so on from left to right. The POSIX rule is computationally prohibitive and not even well-defined. See &lt;a href=&quot;https://swtch.com/~rsc/regexp/regexp2.html#posix&quot;&gt;https://swtch.com/~rsc/regexp/regexp2.html#posix&lt;/a&gt; for details.</source>
          <target state="translated">但是，可以有多个最左最长的匹配项，具有不同的子匹配项选择，并且此程序包与POSIX不同。在可能的最左最长的匹配项中，此程序包选择一个将首先找到回溯搜索的匹配项，而POSIX指定选择该匹配项以最大化第一个子表达式的长度，然后最大化第二个子表达式的长度，依此类推，从左到右。POSIX规则在计算上是禁止的，甚至定义不明确。有关详细信息，请参见&lt;a href=&quot;https://swtch.com/~rsc/regexp/regexp2.html#posix&quot;&gt;https://swtch.com/~rsc/regexp/regexp2.html#posix&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="40708df18a19eb4cd04fce64de3e8c9f00288cb2" translate="yes" xml:space="preserve">
          <source>However, to aid in formatting template source code, if an action's left delimiter (by default &quot;{{&quot;) is followed immediately by a minus sign and ASCII space character (&quot;{{- &quot;), all trailing white space is trimmed from the immediately preceding text. Similarly, if the right delimiter (&quot;}}&quot;) is preceded by a space and minus sign (&quot; -}}&quot;), all leading white space is trimmed from the immediately following text. In these trim markers, the ASCII space must be present; &quot;{{-3}}&quot; parses as an action containing the number -3.</source>
          <target state="translated">然而,为了帮助模板源代码的格式化,如果一个动作的左定界符(默认为&quot;{&quot;)后面紧跟着一个减号和ASCII空格字符(&quot;{{-&quot;),那么所有尾部的空白都会从紧接着的文本中被修剪掉;同样,如果右定界符(&quot;}}&quot;)前面有一个空格和减号(&quot;-}}&quot;),那么所有前面的空白都会被修剪掉。同样,如果右定界符(&quot;}}&quot;)前有空格和减号(&quot;-}}&quot;),则紧接其后的文本的所有前部空白都会被修剪。在这些修剪标记中,ASCII空格必须存在;&quot;{{-3}}&quot;会被解析为包含数字-3的操作。</target>
        </trans-unit>
        <trans-unit id="865c5231eb19f03389b3d03b11a5fede2d02038c" translate="yes" xml:space="preserve">
          <source>However, to aid in formatting template source code, if an action's left delimiter (by default &quot;{{&quot;) is followed immediately by a minus sign and white space, all trailing white space is trimmed from the immediately preceding text. Similarly, if the right delimiter (&quot;}}&quot;) is preceded by white space and a minus sign, all leading white space is trimmed from the immediately following text. In these trim markers, the white space must be present: &quot;{{- 3}}&quot; is like &quot;{{3}}&quot; but trims the immediately preceding text, while &quot;{{-3}}&quot; parses as an action containing the number -3.</source>
          <target state="translated">但是,为了帮助模板源代码的格式化,如果一个动作的左定界符(默认为&quot;{&quot;)后面紧跟着一个减号和空格,那么所有尾部的空格都会从紧接着的文本中被修剪掉。同样地,如果右定界符(&quot;}}&quot;)前面是空白和减号,那么所有前面的空白都会从紧接着的文本中被修剪掉。在这些修剪标记中,白色空间必须存在。&quot;{{-3}}&quot;与&quot;{{3}}&quot;类似,但修剪了紧接其后的文字,而&quot;{{-3}}&quot;则解析为包含数字-3的操作。</target>
        </trans-unit>
        <trans-unit id="d4e4742177e63cc124605c711f8542e79a9c655e" translate="yes" xml:space="preserve">
          <source>However, when printing a byte slice with a string-like verb (%s %q %x %X), it is treated identically to a string, as a single item.</source>
          <target state="translated">但是,当打印一个带有类似字符串动词的字节片时(%s %q %x %X),它的处理方式与字符串相同,是一个单项。</target>
        </trans-unit>
        <trans-unit id="5c4cbffa6231f3b3c2514644d0fee825e224c80d" translate="yes" xml:space="preserve">
          <source>Hypot returns Sqrt(p*p + q*q), taking care to avoid unnecessary overflow and underflow.</source>
          <target state="translated">Hypot返回Sqrt(p*p+q*q),注意避免不必要的溢出和不足。</target>
        </trans-unit>
        <trans-unit id="576b7847aead683e23b77c003ff6f222a841ef25" translate="yes" xml:space="preserve">
          <source>IEEETable is the table for the IEEE polynomial.</source>
          <target state="translated">IEEETable是IEEE多项式的表。</target>
        </trans-unit>
        <trans-unit id="a220db6c90383cf3092dacd6831c2890463d8ced" translate="yes" xml:space="preserve">
          <source>IMAGE_DIRECTORY_ENTRY constants</source>
          <target state="translated">IMAGE_DIRECTORY_ENTRY 常量。</target>
        </trans-unit>
        <trans-unit id="f585c9fe77a34e4b203ca7586560b165b3fa9e06" translate="yes" xml:space="preserve">
          <source>IP address lengths (bytes).</source>
          <target state="translated">IP地址长度(字节)。</target>
        </trans-unit>
        <trans-unit id="8f3823940310cc4dda7efac459317d31719ee534" translate="yes" xml:space="preserve">
          <source>IP addresses can be optionally enclosed in square brackets and are checked against the IPAddresses field. Other names are checked case insensitively against the DNSNames field. If the names are valid hostnames, the certificate fields can have a wildcard as the left-most label.</source>
          <target state="translated">IP地址可以选择用方括号括起来,并根据IPAddresses字段进行检查。其他名称会根据 DNSNames 字段进行不分大小写的检查。如果这些名字是有效的主机名,证书字段可以用通配符作为最左边的标签。</target>
        </trans-unit>
        <trans-unit id="e746cf97286466a3ee7a6da22134f5658e5d9835" translate="yes" xml:space="preserve">
          <source>IP.DefaultMask</source>
          <target state="translated">IP.DefaultMask</target>
        </trans-unit>
        <trans-unit id="11cb3659b8e0ce7581cbb847a5c82b1c9f0fd371" translate="yes" xml:space="preserve">
          <source>IP.Mask</source>
          <target state="translated">IP.Mask</target>
        </trans-unit>
        <trans-unit id="afa88b5842f11425f491e338d7ab921fd1ba5273" translate="yes" xml:space="preserve">
          <source>IPAddr represents the address of an IP end point.</source>
          <target state="translated">IPAddr表示IP端点的地址。</target>
        </trans-unit>
        <trans-unit id="62bf2467f82c0177288446c3c53fcfe1388fdbf4" translate="yes" xml:space="preserve">
          <source>IPConn is the implementation of the Conn and PacketConn interfaces for IP network connections.</source>
          <target state="translated">IPConn是Conn和PacketConn接口在IP网络连接中的实现。</target>
        </trans-unit>
        <trans-unit id="f8a4e52fe170a6b87d8e8f324c9e46497e3e1a1e" translate="yes" xml:space="preserve">
          <source>IPv4</source>
          <target state="translated">IPv4</target>
        </trans-unit>
        <trans-unit id="01eafbb77fe2e5da4ec4f2fa2166e61bdbf17fda" translate="yes" xml:space="preserve">
          <source>IPv4 returns the IP address (in 16-byte form) of the IPv4 address a.b.c.d.</source>
          <target state="translated">IPv4返回IPv4地址a.b.c.d的IP地址(16字节形式)。</target>
        </trans-unit>
        <trans-unit id="3e2065fb2c469f55091e83e0c17ec6c33b2ade3a" translate="yes" xml:space="preserve">
          <source>IPv4Mask</source>
          <target state="translated">IPv4Mask</target>
        </trans-unit>
        <trans-unit id="d0818e19fd482dbfdc092a8f03eecab69f4f02c6" translate="yes" xml:space="preserve">
          <source>IPv4Mask returns the IP mask (in 4-byte form) of the IPv4 mask a.b.c.d.</source>
          <target state="translated">IPv4Mask 返回 IPv4 掩码 a.b.c.d 的 IP 掩码(4 字节形式)。</target>
        </trans-unit>
        <trans-unit id="84f775d13ea13d9914f862669240b386b5b2ce40" translate="yes" xml:space="preserve">
          <source>ISOWeek returns the ISO 8601 year and week number in which t occurs. Week ranges from 1 to 53. Jan 01 to Jan 03 of year n might belong to week 52 or 53 of year n-1, and Dec 29 to Dec 31 might belong to week 1 of year n+1.</source>
          <target state="translated">ISOWeek返回t发生的ISO 8601年和周号。周的范围从1到53。n年的1月1日到1月3日可能属于n-1年的52或53周,12月29日到12月31日可能属于n+1年的1周。</target>
        </trans-unit>
        <trans-unit id="08d6764cba419802272bb09d455c908144b957aa" translate="yes" xml:space="preserve">
          <source>Id is a wrapper for Id(obj.Pkg(), obj.Name()).</source>
          <target state="translated">Id是Id(obj.Pkg(),obj.Name())的封装器。</target>
        </trans-unit>
        <trans-unit id="1d68ea4276c501cd9a850a1820a4a4d86fcccd10" translate="yes" xml:space="preserve">
          <source>Id returns name if it is exported, otherwise it returns the name qualified with the package path.</source>
          <target state="translated">如果是导出的,则返回名称,否则返回以包路径限定的名称。</target>
        </trans-unit>
        <trans-unit id="fa08cb5f856950ffd31e99879394c8d2ecd78b73" translate="yes" xml:space="preserve">
          <source>Identical reports whether x and y are identical types. Receivers of Signature types are ignored.</source>
          <target state="translated">Identical报告x和y是否是相同的类型。签名类型的接收者会被忽略。</target>
        </trans-unit>
        <trans-unit id="62582ea142e0c589620d5bd10a3675dc62d150bc" translate="yes" xml:space="preserve">
          <source>IdenticalIgnoreTags reports whether x and y are identical types if tags are ignored. Receivers of Signature types are ignored.</source>
          <target state="translated">如果标签被忽略,IdenticalIgnoreTags报告x和y是否是相同类型。签名类型的接收者会被忽略。</target>
        </trans-unit>
        <trans-unit id="1b283807cc15b11d0882e9fd847033d20b983bd2" translate="yes" xml:space="preserve">
          <source>IdentifierNode holds an identifier.</source>
          <target state="translated">IdentifierNode持有一个标识符。</target>
        </trans-unit>
        <trans-unit id="e3f7a148cc891203b5f7d36d2d9e45cad70d628a" translate="yes" xml:space="preserve">
          <source>If 'All' is present, the routine matches successive non-overlapping matches of the entire expression. Empty matches abutting a preceding match are ignored. The return value is a slice containing the successive return values of the corresponding non-'All' routine. These routines take an extra integer argument, n. If n &amp;gt;= 0, the function returns at most n matches/submatches; otherwise, it returns all of them.</source>
          <target state="translated">如果存在&amp;ldquo;全部&amp;rdquo;，则例程将匹配整个表达式的连续非重叠匹配。与之前的比赛相邻的空比赛将被忽略。返回值是一个切片，其中包含相应的非&amp;ldquo; All&amp;rdquo;例程的连续返回值。这些例程使用一个额外的整数参数n。如果n&amp;gt; = 0，则该函数最多返回n个匹配项/子匹配项；否则，将返回所有这些。</target>
        </trans-unit>
        <trans-unit id="4bc5ea7c2a0ba24905139043c1e06d713fc4b624" translate="yes" xml:space="preserve">
          <source>If 'Index' is present, matches and submatches are identified by byte index pairs within the input string: result[2*n:2*n+1] identifies the indexes of the nth submatch. The pair for n==0 identifies the match of the entire expression. If 'Index' is not present, the match is identified by the text of the match/submatch. If an index is negative or text is nil, it means that subexpression did not match any string in the input. For 'String' versions an empty string means either no match or an empty match.</source>
          <target state="translated">如果存在'Index',则匹配和子匹配由输入字符串中的字节索引对识别:result[2*n:2*n+1]识别第n个子匹配的索引。n==0的对子标识整个表达式的匹配。如果'索引'不存在,则通过匹配/子匹配的文本来识别匹配。如果索引为负值或文本为零,则意味着子表达式没有匹配输入中的任何字符串。对于'String'版本,空字符串意味着没有匹配或空匹配。</target>
        </trans-unit>
        <trans-unit id="750f20e67d15d8b15512065e634f8a04cd24649d" translate="yes" xml:space="preserve">
          <source>If 'String' is present, the argument is a string; otherwise it is a slice of bytes; return values are adjusted as appropriate.</source>
          <target state="translated">如果存在'String',则参数是一个字符串,否则是一个字节片,返回值会适当调整。</target>
        </trans-unit>
        <trans-unit id="6b5422b81678b9d8d259a31067e6668262dc0a15" translate="yes" xml:space="preserve">
          <source>If 'Submatch' is present, the return value is a slice identifying the successive submatches of the expression. Submatches are matches of parenthesized subexpressions (also known as capturing groups) within the regular expression, numbered from left to right in order of opening parenthesis. Submatch 0 is the match of the entire expression, submatch 1 the match of the first parenthesized subexpression, and so on.</source>
          <target state="translated">如果存在'Submatch',返回值是一个分片,标识表达式的连续子匹配。子匹配是正则表达式中的大括号子表达式(也称为捕获组)的匹配,按照开括号的顺序从左到右编号。子匹配0是整个表达式的匹配,子匹配1是第一个括号化子表达式的匹配,以此类推。</target>
        </trans-unit>
        <trans-unit id="c8e129ec8b814ed3ea9bfb24aed18824a3379050" translate="yes" xml:space="preserve">
          <source>If Body is present, Content-Length is &amp;lt;= 0 and TransferEncoding hasn't been set to &quot;identity&quot;, Write adds &quot;Transfer-Encoding: chunked&quot; to the header. Body is closed after it is sent.</source>
          <target state="translated">如果存在&amp;ldquo;正文&amp;rdquo;，则Content-Length为&amp;lt;= 0，并且TransferEncoding尚未设置为&amp;ldquo; identity&amp;rdquo;，Write将&amp;ldquo; Transfer-Encoding：chunked&amp;rdquo;添加到标头。发送后将其关闭。</target>
        </trans-unit>
        <trans-unit id="a4c660d2d836ce5011f39f208170601c14fc3f84" translate="yes" xml:space="preserve">
          <source>If CheckNamedValue returns ErrRemoveArgument, the NamedValue will not be included in the final query arguments. This may be used to pass special options to the query itself.</source>
          <target state="translated">如果CheckNamedValue返回ErrRemoveArgument,NamedValue将不会被包含在最终的查询参数中。这可以用来向查询本身传递特殊选项。</target>
        </trans-unit>
        <trans-unit id="16a03bedfc442181d888e7b8ec8eee1e7e8562bb" translate="yes" xml:space="preserve">
          <source>If Conn.Ping returns ErrBadConn, DB.Ping and DB.PingContext will remove the Conn from pool.</source>
          <target state="translated">如果Conn.Ping返回ErrBadConn,DB.Ping和DB.PingContext将从池中移除Conn。</target>
        </trans-unit>
        <trans-unit id="9bf5fb8d1ebbb6dc425efaa4065a072560c9aaa0" translate="yes" xml:space="preserve">
          <source>If DIR is a directory listed in the Go path, a package with source in DIR/src/foo/bar can be imported as &quot;foo/bar&quot; and has its compiled form installed to &quot;DIR/pkg/GOOS_GOARCH/foo/bar.a&quot; (or, for gccgo, &quot;DIR/pkg/gccgo/foo/libbar.a&quot;).</source>
          <target state="translated">如果DIR是Go路径中列出的目录,那么可以将DIR/src/foo/bar中的源码包导入为 &quot;foo/bar&quot;,并将其编译后的形式安装到 &quot;DIR/pkg/GOOS_GOARCH/foo/bar.a&quot;(或者,对于gccgo来说,&quot;DIR/pkg/gccgo/foo/libbar.a&quot;)。</target>
        </trans-unit>
        <trans-unit id="626d82422a444f8260197f6a255b844b957560c9" translate="yes" xml:space="preserve">
          <source>If Dir is SelectDefault, the case represents a default case. Chan and Send must be zero Values.</source>
          <target state="translated">如果Dir为SelectDefault,则代表默认情况。Chan和Send必须是零值。</target>
        </trans-unit>
        <trans-unit id="b64c8a9a4dd6bc23186cb39d29f2d6a941b37467" translate="yes" xml:space="preserve">
          <source>If Dir is SelectRecv, the case represents a receive operation. Normally Chan's underlying value must be a channel and Send must be a zero Value. If Chan is a zero Value, then the case is ignored, but Send must still be a zero Value. When a receive operation is selected, the received Value is returned by Select.</source>
          <target state="translated">如果Dir是SelectRecv,则代表的是接收操作。通常Chan的底层值必须是一个通道,Send必须是一个零Value。如果Chan为零Value,则忽略case,但Send仍必须为零Value。当选择接收操作时,接收的Value由Select返回。</target>
        </trans-unit>
        <trans-unit id="fc3241471000ca543780e2776c12ce2c0f98b518" translate="yes" xml:space="preserve">
          <source>If Dir is SelectSend, the case represents a send operation. Normally Chan's underlying value must be a channel, and Send's underlying value must be assignable to the channel's element type. As a special case, if Chan is a zero Value, then the case is ignored, and the field Send will also be ignored and may be either zero or non-zero.</source>
          <target state="translated">如果Dir是SelectSend,则代表发送操作的情况。通常Chan的底层值必须是一个通道,Send的底层值必须是可以分配给通道的元素类型。作为一种特殊情况,如果Chan是一个零值,那么case会被忽略,而Send这个字段也会被忽略,可以是零也可以是非零。</target>
        </trans-unit>
        <trans-unit id="3e5a9a392b54a0f9dbcf70e078d697829fda46e7" translate="yes" xml:space="preserve">
          <source>If Discard skips fewer than n bytes, it also returns an error. If 0 &amp;lt;= n &amp;lt;= b.Buffered(), Discard is guaranteed to succeed without reading from the underlying io.Reader.</source>
          <target state="translated">如果&amp;ldquo;放弃&amp;rdquo;跳过少于n个字节，则它还会返回错误。如果0 &amp;lt;= n &amp;lt;= b.Buffered（），则确保Discard成功执行，而无需从基础io.Reader中读取。</target>
        </trans-unit>
        <trans-unit id="5388f313bdebc1cd743073994620f637168dfccb" translate="yes" xml:space="preserve">
          <source>If DiscardEmptyColumns is set, empty columns that are terminated entirely by vertical (or &quot;soft&quot;) tabs are discarded. Columns terminated by horizontal (or &quot;hard&quot;) tabs are not affected by this flag.</source>
          <target state="translated">如果设置了DiscardEmptyColumns,则完全由垂直(或 &quot;软&quot;)制表符终止的空列将被丢弃。由水平(或 &quot;硬&quot;)制表符终止的列不受此标志的影响。</target>
        </trans-unit>
        <trans-unit id="c9deb8e1a0cfa1d1825dc49ade2afa7eec850bd3" translate="yes" xml:space="preserve">
          <source>If ErrSkip is returned the column converter error checking path is used for the argument. Drivers may wish to return ErrSkip after they have exhausted their own special cases.</source>
          <target state="translated">如果返回ErrSkip,列转换器错误检查路径将用于参数。驱动程序可能希望在用尽自己的特殊情况后返回ErrSkip。</target>
        </trans-unit>
        <trans-unit id="acb8bfb04c68aa06cf649fa65fe83fd0ec6ad99b" translate="yes" xml:space="preserve">
          <source>If Get would otherwise return nil and p.New is non-nil, Get returns the result of calling p.New.</source>
          <target state="translated">如果Get在其他情况下会返回nil,而p.New是非nil,那么Get会返回调用p.New的结果。</target>
        </trans-unit>
        <trans-unit id="cbb35dd622fd4fc40d747d7fe8a39806c85598b4" translate="yes" xml:space="preserve">
          <source>If MaxIdleConns is greater than 0 and the new MaxOpenConns is less than MaxIdleConns, then MaxIdleConns will be reduced to match the new MaxOpenConns limit.</source>
          <target state="translated">如果MaxIdleConns大于0,并且新的MaxOpenConns小于MaxIdleConns,那么MaxIdleConns将被减少以匹配新的MaxOpenConns限制。</target>
        </trans-unit>
        <trans-unit id="0566ce3b75e32de588395cc9db25a53062d79613" translate="yes" xml:space="preserve">
          <source>If MaxOpenConns is greater than 0 but less than the new MaxIdleConns, then the new MaxIdleConns will be reduced to match the MaxOpenConns limit.</source>
          <target state="translated">如果MaxOpenConns大于0但小于新的MaxIdleConns,那么新的MaxIdleConns将被减少,以匹配MaxOpenConns限制。</target>
        </trans-unit>
        <trans-unit id="ba59fc6bf9458413409db5ff0b9045c64e756bcb" translate="yes" xml:space="preserve">
          <source>If ReadAt is reading from an input source with a seek offset, ReadAt should not affect nor be affected by the underlying seek offset.</source>
          <target state="translated">如果ReadAt从一个有寻道偏移的输入源读取,ReadAt不应该影响也不会受到底层寻道偏移的影响。</target>
        </trans-unit>
        <trans-unit id="cc3d6766541295fe523ec22933263aa9a06c4657" translate="yes" xml:space="preserve">
          <source>If ServeHTTP panics, the server (the caller of ServeHTTP) assumes that the effect of the panic was isolated to the active request. It recovers the panic, logs a stack trace to the server error log, and either closes the network connection or sends an HTTP/2 RST_STREAM, depending on the HTTP protocol. To abort a handler so the client sees an interrupted response but the server doesn't log an error, panic with the value ErrAbortHandler.</source>
          <target state="translated">如果ServeHTTP发生恐慌,服务器(ServeHTTP的调用者)会认为恐慌的影响是孤立于活动请求的。它恢复恐慌,将堆栈跟踪记录到服务器错误日志中,并根据HTTP协议关闭网络连接或发送一个HTTP/2 RST_STREAM。要中止一个处理程序,使客户端看到一个中断的响应,但服务器没有记录错误,用ErrAbortHandler的值来恐慌。</target>
        </trans-unit>
        <trans-unit id="c9df130ceb3ae952587ab322cca16f6a65e29d84" translate="yes" xml:space="preserve">
          <source>If Start returns successfully, the c.Process field will be set.</source>
          <target state="translated">如果Start成功返回,c.Process字段将被设置。</target>
        </trans-unit>
        <trans-unit id="eed6a51dc00d92ad58016afb39e08c5356592608" translate="yes" xml:space="preserve">
          <source>If SubjectKeyId from template is empty and the template is a CA, SubjectKeyId will be generated from the hash of the public key.</source>
          <target state="translated">如果来自模板的SubjectKeyId为空,且模板为CA,SubjectKeyId将由公钥的哈希值生成。</target>
        </trans-unit>
        <trans-unit id="03b743a2bf24014291b619ac4052a90413c15a39" translate="yes" xml:space="preserve">
          <source>If TestFS finds any misbehaviors, it returns an error reporting all of them. The error text spans multiple lines, one per detected misbehavior.</source>
          <target state="translated">如果TestFS发现了任何不当行为,它将返回一个错误,报告所有这些行为。错误文本跨越多行,每一个检测到的错误行为都有一行。</target>
        </trans-unit>
        <trans-unit id="15b3f0511e9fa111d5eb85347847012bfb679dba" translate="yes" xml:space="preserve">
          <source>If TestReader finds any misbehaviors, it returns an error reporting them. The error text may span multiple lines.</source>
          <target state="translated">如果TestReader发现任何错误行为,它将返回一个错误报告。错误文本可能跨越多行。</target>
        </trans-unit>
        <trans-unit id="7c30ed6f837b3e7a9558eb599fa8c56e0e97063b" translate="yes" xml:space="preserve">
          <source>If Times t and u both contain monotonic clock readings, the operations t.After(u), t.Before(u), t.Equal(u), and t.Sub(u) are carried out using the monotonic clock readings alone, ignoring the wall clock readings. If either t or u contains no monotonic clock reading, these operations fall back to using the wall clock readings.</source>
          <target state="translated">如果Times t和u都包含单调时钟读数,那么t.After(u)、t.Before(u)、t.Equal(u)和t.Sub(u)等操作都只使用单调时钟读数而忽略挂钟读数。如果t或u中没有单调时钟读数,这些操作将回到使用挂钟读数。</target>
        </trans-unit>
        <trans-unit id="bc4d8baa4dbb3f1a94db59ec9aa34f357782809d" translate="yes" xml:space="preserve">
          <source>If Unmarshal encounters a field type that implements the Unmarshaler interface, Unmarshal calls its UnmarshalXML method to produce the value from the XML element. Otherwise, if the value implements encoding.TextUnmarshaler, Unmarshal calls that value's UnmarshalText method.</source>
          <target state="translated">如果Unmarshal遇到一个实现了Unmarshaler接口的字段类型,Unmarshal就会调用它的UnmarshalXML方法从XML元素中产生值。否则,如果该值实现了 encoding.TextUnmarshaler,Unmarshal 就会调用该值的 UnmarshalText 方法。</target>
        </trans-unit>
        <trans-unit id="e7b1cef9234b9022f80f99b102d2ffde95658f55" translate="yes" xml:space="preserve">
          <source>If UseCRLF is true, the Writer ends each output line with \r\n instead of \n.</source>
          <target state="translated">如果UseCRLF为真,那么Writer就会在每一行输出结束时使用\r\n而不是\n。</target>
        </trans-unit>
        <trans-unit id="24f02297c63afdceb90dae9a889e378f8f5dc1c7" translate="yes" xml:space="preserve">
          <source>If WriteAt is writing to a destination with a seek offset, WriteAt should not affect nor be affected by the underlying seek offset.</source>
          <target state="translated">如果WriteAt是写到一个有寻道偏移的目的地,WriteAt不应该影响也不会受到基础寻道偏移的影响。</target>
        </trans-unit>
        <trans-unit id="93383c5ea1d8fe26c2febc3914b065857796c533" translate="yes" xml:space="preserve">
          <source>If a != 0 and b == 0, GCD sets z = |a|, x = sign(a) * 1, y = 0.</source>
          <target state="translated">如果a !=0,b ==0,则GCD设z=|a|,x=sign(a)*1,y=0。</target>
        </trans-unit>
        <trans-unit id="01ec25dfc6204eb6897de5935b9779223b3cad13" translate="yes" xml:space="preserve">
          <source>If a &quot;range&quot; action initializes a variable, the variable is set to the successive elements of the iteration. Also, a &quot;range&quot; may declare two variables, separated by a comma:</source>
          <target state="translated">如果一个 &quot;范围 &quot;操作初始化了一个变量,那么这个变量就会被设置为迭代的连续元素。另外,一个 &quot;范围 &quot;可以声明两个变量,用逗号隔开。</target>
        </trans-unit>
        <trans-unit id="630b98d4876b039ef4109d3fcef4537345f5b1cb" translate="yes" xml:space="preserve">
          <source>If a == 0 and b != 0, GCD sets z = |b|, x = 0, y = sign(b) * 1.</source>
          <target state="translated">如果a ==0,b !=0,则GCD设z=|b|,x=0,y=sign(b)*1。</target>
        </trans-unit>
        <trans-unit id="64d609c4002ae17b5c018b505462be8ebae980f7" translate="yes" xml:space="preserve">
          <source>If a == b == 0, GCD sets z = x = y = 0.</source>
          <target state="translated">如果a==b==0,则GCD设z=x=y=0。</target>
        </trans-unit>
        <trans-unit id="58d444ec12c7fa5d6e872ab50772870b5a393d01" translate="yes" xml:space="preserve">
          <source>If a Conn does not implement ExecerContext, the sql package's DB.Exec will fall back to Execer; if the Conn does not implement Execer either, DB.Exec will first prepare a query, execute the statement, and then close the statement.</source>
          <target state="translated">如果Conn没有实现ExecerContext,那么sql包的DB.Exec将回落到Execer;如果Conn也没有实现Execer,DB.Exec将先准备查询,执行语句,然后关闭语句。</target>
        </trans-unit>
        <trans-unit id="44e6dfb38005e87694379cf1c0216f95562e9cfb" translate="yes" xml:space="preserve">
          <source>If a Conn does not implement Pinger, the sql package's DB.Ping and DB.PingContext will check if there is at least one Conn available.</source>
          <target state="translated">如果一个Conn没有实现Pinger,sql包的DB.Ping和DB.PingContext会检查是否至少有一个Conn可用。</target>
        </trans-unit>
        <trans-unit id="21128809a4ab46817c40f8b5969689593dcd6f72" translate="yes" xml:space="preserve">
          <source>If a Conn does not implement QueryerContext, the sql package's DB.Query will fall back to Queryer; if the Conn does not implement Queryer either, DB.Query will first prepare a query, execute the statement, and then close the statement.</source>
          <target state="translated">如果Conn没有实现QueryerContext,则sql包的DB.Query将回落到Queryer;如果Conn也没有实现Queryer,则DB.Query将先准备一个查询,执行语句,然后关闭语句。</target>
        </trans-unit>
        <trans-unit id="45c4be212f44031bede2b5276a4a3589a0dc2b98" translate="yes" xml:space="preserve">
          <source>If a Conn implements neither ExecerContext nor Execer, the sql package's DB.Exec will first prepare a query, execute the statement, and then close the statement.</source>
          <target state="translated">如果一个Conn既没有实现ExecerContext,也没有实现Execer,那么sql包的DB.Exec将首先准备一个查询,执行语句,然后关闭语句。</target>
        </trans-unit>
        <trans-unit id="1cb5d6dd6f4d516d1ae37935040abf369ba105f8" translate="yes" xml:space="preserve">
          <source>If a Conn implements neither QueryerContext nor Queryer, the sql package's DB.Query will first prepare a query, execute the statement, and then close the statement.</source>
          <target state="translated">如果一个Conn既没有实现QueryerContext,也没有实现Queryer,那么sql包的DB.Query会先准备一个查询,执行语句,然后关闭语句。</target>
        </trans-unit>
        <trans-unit id="71c0f29e06c175a2adb537fdf47269746a601d0d" translate="yes" xml:space="preserve">
          <source>If a Driver implements DriverContext, then sql.DB will call OpenConnector to obtain a Connector and then invoke that Connector's Conn method to obtain each needed connection, instead of invoking the Driver's Open method for each connection. The two-step sequence allows drivers to parse the name just once and also provides access to per-Conn contexts.</source>
          <target state="translated">如果一个驱动程序实现了DriverContext,那么sql.DB将调用OpenConnector来获取一个Connector,然后调用该Connector的Conn方法来获取每个需要的连接,而不是为每个连接调用驱动程序的Open方法。这两步序列允许驱动程序只解析一次名称,同时也提供了对每个Conn上下文的访问。</target>
        </trans-unit>
        <trans-unit id="56a7870f9afac036630f51a12d5ce02b7331bec6" translate="yes" xml:space="preserve">
          <source>If a Driver implements DriverContext, then sql.DB will call OpenConnector to obtain a Connector and then invoke that Connector's Connect method to obtain each needed connection, instead of invoking the Driver's Open method for each connection. The two-step sequence allows drivers to parse the name just once and also provides access to per-Conn contexts.</source>
          <target state="translated">如果一个驱动程序实现了DriverContext,那么sql.DB将调用OpenConnector来获取一个Connector,然后调用该Connector的Connect方法来获取每个需要的连接,而不是为每个连接调用驱动程序的Open方法。这两步序列使得驱动程序只需解析一次名称,同时也提供了对每个Conn上下文的访问。</target>
        </trans-unit>
        <trans-unit id="232b341436c8f9f54c10a5dba1cf92c214798814" translate="yes" xml:space="preserve">
          <source>If a JSON value is not appropriate for a given target type, or if a JSON number overflows the target type, Unmarshal skips that field and completes the unmarshaling as best it can. If no more serious errors are encountered, Unmarshal returns an UnmarshalTypeError describing the earliest such error. In any case, it's not guaranteed that all the remaining fields following the problematic one will be unmarshaled into the target object.</source>
          <target state="translated">如果一个JSON值不适合给定的目标类型,或者一个JSON数超出了目标类型,Unmarshal就会跳过该字段,并尽可能地完成解马尔沙尔。如果没有遇到更严重的错误,Unmarshal会返回一个UnmarshalTypeError,描述最早的这种错误。在任何情况下,都不能保证在有问题的字段之后的所有剩余字段都会被解马尔什化到目标对象中。</target>
        </trans-unit>
        <trans-unit id="07bd09bc1ed04a73b33dd796fe781c9034c95572" translate="yes" xml:space="preserve">
          <source>If a Stmt is prepared on a Tx or Conn, it will be bound to a single underlying connection forever. If the Tx or Conn closes, the Stmt will become unusable and all operations will return an error. If a Stmt is prepared on a DB, it will remain usable for the lifetime of the DB. When the Stmt needs to execute on a new underlying connection, it will prepare itself on the new connection automatically.</source>
          <target state="translated">如果在Tx或Conn上准备了一个Stmt,它将永远绑定在一个基础连接上。如果Tx或Conn关闭,Stmt将变得不可用,所有操作都将返回一个错误。如果一个Stmt是在一个DB上准备的,那么它将在DB的生命周期内保持可用。当Stmt需要在新的底层连接上执行时,它将自动在新的连接上进行准备。</target>
        </trans-unit>
        <trans-unit id="3b80dd32b6041fa4ef2f09439544647455bd33ab" translate="yes" xml:space="preserve">
          <source>If a Value has an IsBoolFlag() bool method returning true, the command-line parser makes -name equivalent to -name=true rather than using the next command-line argument.</source>
          <target state="translated">如果一个Value有一个IsBoolFlag()bool方法返回true,命令行解析器会让-name等同于-name=true,而不是使用下一个命令行参数。</target>
        </trans-unit>
        <trans-unit id="1d651c7c470bed2709ac735baaeec98dda753ea4" translate="yes" xml:space="preserve">
          <source>If a Writer is configured to filter HTML, HTML tags and entities are passed through. The widths of tags and entities are assumed to be zero (tags) and one (entities) for formatting purposes.</source>
          <target state="translated">如果将Writer配置为过滤HTML,则HTML标签和实体将被传递。出于格式化的目的,标签和实体的宽度被假定为0(标签)和1(实体)。</target>
        </trans-unit>
        <trans-unit id="52438c4d80c78ea57962cd3af33f715085501ef6" translate="yes" xml:space="preserve">
          <source>If a benchmark needs some expensive setup before running, the timer may be reset:</source>
          <target state="translated">如果一个基准在运行前需要一些昂贵的设置,计时器可能会被重置。</target>
        </trans-unit>
        <trans-unit id="d7727dcc2593fe8b30c299beed7e6a6b86f7e22b" translate="yes" xml:space="preserve">
          <source>If a benchmark needs to test performance in a parallel setting, it may use the RunParallel helper function; such benchmarks are intended to be used with the go test -cpu flag:</source>
          <target state="translated">如果一个基准需要测试并行环境下的性能,它可以使用RunParallel辅助函数;这样的基准应该与go test -cpu标志一起使用。</target>
        </trans-unit>
        <trans-unit id="a54ff063e15dbe9b378b4160c9280c7409b22dcb" translate="yes" xml:space="preserve">
          <source>If a dest argument has type *[]byte, Scan saves in that argument a copy of the corresponding data. The copy is owned by the caller and can be modified and held indefinitely. The copy can be avoided by using an argument of type *RawBytes instead; see the documentation for RawBytes for restrictions on its use.</source>
          <target state="translated">如果一个 dest 参数的类型是 *[]字节,Scan 就会将相应数据的副本保存在该参数中。这个副本是由调用者拥有的,并且可以被无限期地修改和保留。可以通过使用类型为 *RawBytes 的参数来避免拷贝;关于它的使用限制,请参见 RawBytes 的文档。</target>
        </trans-unit>
        <trans-unit id="20186d29e290366ced58a159801092dd58a776e3" translate="yes" xml:space="preserve">
          <source>If a field uses a tag &quot;a&amp;gt;b&amp;gt;c&quot;, then the element c will be nested inside parent elements a and b. Fields that appear next to each other that name the same parent will be enclosed in one XML element.</source>
          <target state="translated">如果字段使用标签&amp;ldquo; a&amp;gt; b&amp;gt; c&amp;rdquo;，则元素c将嵌套在父元素a和b中。彼此相邻且名称相同的父级的字段将包含在一个XML元素中。</target>
        </trans-unit>
        <trans-unit id="9df6c8e2aa87346f45992618c6d030de25253b4a" translate="yes" xml:space="preserve">
          <source>If a file's name, after stripping the extension and a possible _test suffix, matches any of the following patterns:</source>
          <target state="translated">如果一个文件的名字,在去掉扩展名和可能的_test后缀后,符合以下任何一种模式。</target>
        </trans-unit>
        <trans-unit id="d6c46042317668db3b232f00f55a1ab61b108925" translate="yes" xml:space="preserve">
          <source>If a goroutine holds a RWMutex for reading and another goroutine might call Lock, no goroutine should expect to be able to acquire a read lock until the initial read lock is released. In particular, this prohibits recursive read locking. This is to ensure that the lock eventually becomes available; a blocked Lock call excludes new readers from acquiring the lock.</source>
          <target state="translated">如果一个goroutine持有一个RWMutex进行读取,而另一个goroutine可能会调用Lock,那么在初始读取锁被释放之前,任何goroutine都不应该期望能够获得一个读取锁。特别是,这禁止递归读锁。这是为了确保锁最终可以使用;被阻止的Lock调用会排除新的读取器获取锁。</target>
        </trans-unit>
        <trans-unit id="09dcc94416ba2854a88e6fecddf19b900c4d3599" translate="yes" xml:space="preserve">
          <source>If a pattern names a directory, all files in the subtree rooted at that directory are embedded (recursively), except that files with names beginning with &amp;lsquo;.&amp;rsquo; or &amp;lsquo;_&amp;rsquo; are excluded. So the variable in the above example is almost equivalent to:</source>
          <target state="translated">如果模式命名目录，则以该目录为根的子树中的所有文件都将被嵌入（递归），但文件名以&amp;ldquo;。&amp;rdquo;开头的文件除外。或'_'排除在外。因此，以上示例中的变量几乎等同于：</target>
        </trans-unit>
        <trans-unit id="54b696ffb9e87ece68a0d432b267874461da7b0c" translate="yes" xml:space="preserve">
          <source>If a pointer argument must be converted to uintptr for use as an argument, that conversion must appear in the call expression itself:</source>
          <target state="translated">如果一个指针参数必须转换为uintptr作为参数使用,这种转换必须出现在调用表达式本身。</target>
        </trans-unit>
        <trans-unit id="ad57bb6494bba356a620db6dbc5f566b04a58730" translate="yes" xml:space="preserve">
          <source>If a program has already received a value from t.C, the timer is known to have expired and the channel drained, so t.Reset can be used directly. If a program has not yet received a value from t.C, however, the timer must be stopped and&amp;mdash;if Stop reports that the timer expired before being stopped&amp;mdash;the channel explicitly drained:</source>
          <target state="translated">如果程序已经从tC接收到一个值，则说明计时器已到期且通道已耗尽，因此可以直接使用t.Reset。但是，如果程序尚未从tC接收到值，则必须停止计时器，并且-如果&amp;ldquo;停止&amp;rdquo;报告计时器在停止之前已到期，则该通道将被明确耗尽：</target>
        </trans-unit>
        <trans-unit id="a7be185efba59538fbd160cb8d8144506dd7c57d" translate="yes" xml:space="preserve">
          <source>If a subtree has been registered and a request is received naming the subtree root without its trailing slash, ServeMux redirects that request to the subtree root (adding the trailing slash). This behavior can be overridden with a separate registration for the path without the trailing slash. For example, registering &quot;/images/&quot; causes ServeMux to redirect a request for &quot;/images&quot; to &quot;/images/&quot;, unless &quot;/images&quot; has been registered separately.</source>
          <target state="translated">如果已经注册了一个子树,并且收到了一个没有尾部斜线的子树根的请求,ServeMux会将该请求重定向到子树根(添加尾部斜线)。这种行为可以通过单独注册一个没有尾部斜杠的路径来覆盖。例如,注册&quot;/images/&quot;会导致ServeMux将&quot;/images &quot;的请求重定向到&quot;/images/&quot;,除非&quot;/images &quot;被单独注册。</target>
        </trans-unit>
        <trans-unit id="104ed2563a73defc4faea46be899a20063ec818c" translate="yes" xml:space="preserve">
          <source>If a template with the given name already exists, the new HTML template will replace it. The existing template will be reset and disassociated with t.</source>
          <target state="translated">如果给定名称的模板已经存在,新的HTML模板将替换它。现有的模板将被重置并与t脱离关系。</target>
        </trans-unit>
        <trans-unit id="463d47c06a7100464461b73a8101f7660c223839" translate="yes" xml:space="preserve">
          <source>If a value is passed to Encode and the type is not a struct (or pointer to struct, etc.), for simplicity of processing it is represented as a struct of one field. The only visible effect of this is to encode a zero byte after the value, just as after the last field of an encoded struct, so that the decode algorithm knows when the top-level value is complete.</source>
          <target state="translated">如果一个值传递给Encode,且类型不是结构体(或结构体指针等),为了简化处理,将其表示为一个字段的结构体。这样做唯一可见的效果是在值后编码一个零字节,就像在一个编码结构的最后一个字段后编码一样,这样解码算法就知道顶层值何时完成。</target>
        </trans-unit>
        <trans-unit id="d7d467cb048cd5252bcf40b068f20c227a6c5268" translate="yes" xml:space="preserve">
          <source>If an Error or String method triggers a panic when called by a print routine, the fmt package reformats the error message from the panic, decorating it with an indication that it came through the fmt package. For example, if a String method calls panic(&quot;bad&quot;), the resulting formatted message will look like</source>
          <target state="translated">如果一个Error或String方法在被打印例程调用时触发了恐慌,那么fmt包会重新格式化来自恐慌的错误消息,并在其上注明它是通过fmt包发出的。例如,如果一个String方法调用panic(&quot;bad&quot;),则产生的格式化消息看起来会是这样的</target>
        </trans-unit>
        <trans-unit id="cd5fac95dd3eef4d9d21db69e86463f17f12f02f" translate="yes" xml:space="preserve">
          <source>If an X-Forwarded-For header already exists, the client IP is appended to the existing values. As a special case, if the header exists in the Request.Header map but has a nil value (such as when set by the Director func), the X-Forwarded-For header is not modified.</source>
          <target state="translated">如果X-Forwarded-For头已经存在,客户端的IP会被附加到现有的值上。作为一种特殊情况,如果头存在于Request.Header map中,但其值为nil(例如由Director func设置),X-Forwarded-For头不会被修改。</target>
        </trans-unit>
        <trans-unit id="d3278ea50ebebf5ea6289948b73b15f204c549e9" translate="yes" xml:space="preserve">
          <source>If an argument has type *interface{}, Scan copies the value provided by the underlying driver without conversion. When scanning from a source value of type []byte to *interface{}, a copy of the slice is made and the caller owns the result.</source>
          <target state="translated">如果一个参数的类型为*interface{},Scan会复制底层驱动程序提供的值,而不进行转换。当从类型为[]byte的源值扫描到*interface{}时,会对分片进行复制,调用者拥有结果。</target>
        </trans-unit>
        <trans-unit id="4329d9c7e154311e6c7d29f0986dc75dbddb37fd" translate="yes" xml:space="preserve">
          <source>If an attribute has both a namespace and a &quot;data-&quot; prefix, only the namespace will be removed when determining the context. For example</source>
          <target state="translated">如果一个属性同时具有命名空间和 &quot;data-&quot;前缀,那么在确定上下文时,只有命名空间会被删除。例如</target>
        </trans-unit>
        <trans-unit id="6c7525fb96a9e6dded8b4dd1c94198523c01a7a6" translate="yes" xml:space="preserve">
          <source>If an error occurs, Import returns a non-nil error and a non-nil *Package containing partial information.</source>
          <target state="translated">如果发生错误,Import会返回一个非nil的错误和一个非nil的包含部分信息的*Package。</target>
        </trans-unit>
        <trans-unit id="22a8988276a496bd99d453fc14d11bfb8cde90f0" translate="yes" xml:space="preserve">
          <source>If an invalid argument is given for a verb, such as providing a string to %d, the generated string will contain a description of the problem, as in these examples:</source>
          <target state="translated">如果给一个动词提供了无效的参数,比如给%d提供了一个字符串,生成的字符串将包含对问题的描述,如这些例子。</target>
        </trans-unit>
        <trans-unit id="2f5f672edd948d125f1a8e2164d6570e08508e2a" translate="yes" xml:space="preserve">
          <source>If any of c.Stdin, c.Stdout or c.Stderr are not an *os.File, Wait also waits for the respective I/O loop copying to or from the process to complete.</source>
          <target state="translated">如果c.Stdin、c.Stdout或c.Stderr中的任何一个不是*os.File,Wait也会等待各自的I/O循环复制到或从进程中复制完成。</target>
        </trans-unit>
        <trans-unit id="1f5bbd150ddfb48c91c7cfee2c61e666fa277d7d" translate="yes" xml:space="preserve">
          <source>If any of the first arguments implementing Scanner returns an error, that error will be wrapped in the returned error</source>
          <target state="translated">如果第一个实现Scanner的参数中的任何一个返回错误,该错误将被包裹在返回的错误中。</target>
        </trans-unit>
        <trans-unit id="1d9be5ef14b069fbd8a903d2f2a5d631da093ef0" translate="yes" xml:space="preserve">
          <source>If any patterns are invalid or have invalid matches, the build will fail.</source>
          <target state="translated">如果任何模式无效或有无效的匹配,构建将失败。</target>
        </trans-unit>
        <trans-unit id="f2c348eae7d177d9986e66ac0dbb1fa9c1c8eff2" translate="yes" xml:space="preserve">
          <source>If b has invalid headers and cannot be encoded, EncodeToMemory returns nil. If it is important to report details about this error case, use Encode instead.</source>
          <target state="translated">如果b的头部无效,不能被编码,EncodeToMemory返回nil。如果需要报告这种错误情况的细节,请使用Encode代替。</target>
        </trans-unit>
        <trans-unit id="81446ee41b4f44409d6c98445688e2c9dc448484" translate="yes" xml:space="preserve">
          <source>If base == 0, the base is implied by the string's prefix: base 2 for &quot;0b&quot;, base 8 for &quot;0&quot; or &quot;0o&quot;, base 16 for &quot;0x&quot;, and base 10 otherwise. Also, for base == 0 only, underscore characters are permitted per the Go integer literal syntax. If base is below 0, is 1, or is above 36, an error is returned.</source>
          <target state="translated">如果base ==0,则字符串的前缀暗示了基数:&quot;0b &quot;为基数2,&quot;0 &quot;或 &quot;0o &quot;为基数8,&quot;0x &quot;为基数16,否则为基数10。另外,对于base ==0,根据围棋整数文字语法,允许使用下划线字符。如果基数低于0,为1,或高于36,则返回一个错误。</target>
        </trans-unit>
        <trans-unit id="ff7cc9932856849c823dcd514ebeb18a3facfdc3" translate="yes" xml:space="preserve">
          <source>If body is of type *bytes.Buffer, *bytes.Reader, or *strings.Reader, the returned request's ContentLength is set to its exact value (instead of -1), GetBody is populated (so 307 and 308 redirects can replay the body), and Body is set to NoBody if the ContentLength is 0.</source>
          <target state="translated">如果body的类型是*bytes.Buffer、*bytes.Reader或*strings.Reader,那么返回的请求的ContentLength将被设置为它的精确值(而不是-1),GetBody将被填充(所以307和308重定向可以重放body),如果ContentLength为0,Body将被设置为NoBody。</target>
        </trans-unit>
        <trans-unit id="07cc785c40dfb93b351fa360eaf5c11b3a687a2b" translate="yes" xml:space="preserve">
          <source>If body is true, DumpRequest also returns the body. To do so, it consumes req.Body and then replaces it with a new io.ReadCloser that yields the same bytes. If DumpRequest returns an error, the state of req is undefined.</source>
          <target state="translated">如果body为真,DumpRequest也会返回body。为此,它消耗req.Body,然后用一个新的io.ReadCloser替换它,产生相同的字节。如果DumpRequest返回一个错误,则req的状态是未定义的。</target>
        </trans-unit>
        <trans-unit id="f6ca8f7ad0c62b57590e8d1aff231f008b51eef8" translate="yes" xml:space="preserve">
          <source>If d &amp;lt;= 0, connections are not closed due to a connection's age.</source>
          <target state="translated">如果d &amp;lt;= 0，则由于连接的使用期限，连接不会关闭。</target>
        </trans-unit>
        <trans-unit id="a796f4a07dcd83603a859bc99893a18fb6d4d814" translate="yes" xml:space="preserve">
          <source>If d &amp;lt;= 0, connections are not closed due to a connection's idle time.</source>
          <target state="translated">如果d &amp;lt;= 0，则由于连接的空闲时间，连接不会关闭。</target>
        </trans-unit>
        <trans-unit id="e8579022b484933fe4198bbc194c8a61565aa3ef" translate="yes" xml:space="preserve">
          <source>If d &amp;lt;= 0, connections are reused forever.</source>
          <target state="translated">如果d &amp;lt;= 0，则连接将永远重复使用。</target>
        </trans-unit>
        <trans-unit id="11054b794a9e66d49b745938ef3b656c43f6d39e" translate="yes" xml:space="preserve">
          <source>If data is a reflect.Value, the template applies to the concrete value that the reflect.Value holds, as in fmt.Print.</source>
          <target state="translated">如果数据是一个reflect.Value,则模板适用于reflect.Value所持有的具体值,如fmt.Print.Print中的数据。</target>
        </trans-unit>
        <trans-unit id="f83ceb0ced26c1c764536b5ff1b4fa15e74b62ce" translate="yes" xml:space="preserve">
          <source>If dst implements the ReaderFrom interface, the copy is implemented using it.</source>
          <target state="translated">如果dst实现了ReaderFrom接口,则使用它来实现复制。</target>
        </trans-unit>
        <trans-unit id="6833b17cfcf75e1b486e6c702d0520e85f9b86a2" translate="yes" xml:space="preserve">
          <source>If e.Unwrap() returns a non-nil error w, then we say that e wraps w.</source>
          <target state="translated">如果e.Unwrap()返回一个非零的错误w,那么我们说e包装了w。</target>
        </trans-unit>
        <trans-unit id="f550577a407a74d547ca6987c46308a4d94fb754" translate="yes" xml:space="preserve">
          <source>If either src implements WriterTo or dst implements ReaderFrom, buf will not be used to perform the copy.</source>
          <target state="translated">如果src实现了WriterTo或者dst实现了ReaderFrom,buf将不会被用来执行复制。</target>
        </trans-unit>
        <trans-unit id="81786ec59b1db1b26068cac6cb2b8f77c848e02c" translate="yes" xml:space="preserve">
          <source>If enabled (the default), the Reader expects the input to be a sequence of individually gzipped data streams, each with its own header and trailer, ending at EOF. The effect is that the concatenation of a sequence of gzipped files is treated as equivalent to the gzip of the concatenation of the sequence. This is standard behavior for gzip readers.</source>
          <target state="translated">如果启用(默认),阅读器希望输入是一个单独的gzip数据流序列,每个数据流都有自己的头和预告片,并以EOF结束。其效果是,一个gzip文件序列的连接被视为等同于序列的连接的gzip。这是gzip阅读器的标准行为。</target>
        </trans-unit>
        <trans-unit id="eddf53f9cf1fca82486b2bf4ab21846e817aba06" translate="yes" xml:space="preserve">
          <source>If f calls Run, the result will be an estimate of running all its subbenchmarks that don't call Run in sequence in a single benchmark.</source>
          <target state="translated">如果f调用Run,结果将是在一个基准中依次运行其所有未调用Run的子基准的估计值。</target>
        </trans-unit>
        <trans-unit id="24aa535ef0441b2f9dcbe0e4bbff395ed6067287" translate="yes" xml:space="preserve">
          <source>If f depends on testing flags, then Init must be used to register those flags before calling Benchmark and before calling flag.Parse.</source>
          <target state="translated">如果f依赖于测试标志,那么在调用Benchmark和调用flag.Parse之前,必须使用Init来注册这些标志。</target>
        </trans-unit>
        <trans-unit id="08b53793b968ecc1f35e8cac439169b17517c834" translate="yes" xml:space="preserve">
          <source>If f has a symbol version table, the returned Symbols will have initialized Version and Library fields.</source>
          <target state="translated">如果f有一个符号版本表,那么返回的Symbols将有初始化的版本和库字段。</target>
        </trans-unit>
        <trans-unit id="c8478592007a3bacbc2da6cefaa1115496c485ee" translate="yes" xml:space="preserve">
          <source>If f is a directory, the behavior of Seek varies by operating system; you can seek to the beginning of the directory on Unix-like operating systems, but not on Windows.</source>
          <target state="translated">如果f是一个目录,Seek的行为因操作系统而异;在类似Unix的操作系统上,你可以寻找到目录的开头,但在Windows上则不行。</target>
        </trans-unit>
        <trans-unit id="d8c9bcc7ac7c9df2b87a2dbabc8c6ec7964d0a03" translate="yes" xml:space="preserve">
          <source>If f panics, Do considers it to have returned; future calls of Do return without calling f.</source>
          <target state="translated">如果f惊慌失措,Do就认为它已经返回了;未来Do的调用不需要调用f就能返回。</target>
        </trans-unit>
        <trans-unit id="cfdf3a788dfda0a29c8d0cf447a4cec60c0bc739" translate="yes" xml:space="preserve">
          <source>If file was opened with the O_APPEND flag, WriteAt returns an error.</source>
          <target state="translated">如果文件是以O_APPEND标志打开的,WriteAt返回一个错误。</target>
        </trans-unit>
        <trans-unit id="53e78446111b9259010cce70ef1e63ae6396cc68" translate="yes" xml:space="preserve">
          <source>If filter != nil, only the files with fs.FileInfo entries passing through the filter (and ending in &quot;.go&quot;) are considered. The mode bits are passed to ParseFile unchanged. Position information is recorded in fset, which must not be nil.</source>
          <target state="translated">如果filter !=nil,则只考虑带有fs.FileInfo条目的文件,这些文件通过了filter (并且以&quot;.go &quot;结尾)。模式位不变地传递给 ParseFile。位置信息被记录在fset中,它不能为nil。</target>
        </trans-unit>
        <trans-unit id="822b75e4d85498d0d8696aa19251040ab86e6e90" translate="yes" xml:space="preserve">
          <source>If filter != nil, only the files with os.FileInfo entries passing through the filter (and ending in &quot;.go&quot;) are considered. The mode bits are passed to ParseFile unchanged. Position information is recorded in fset, which must not be nil.</source>
          <target state="translated">如果 filter !=nil,则只考虑 os.FileInfo 条目通过过滤器的文件 (并且以&quot;.go &quot;结尾)。模式位不变地传递给 ParseFile。位置信息被记录在 fset 中,它不能为 nil。</target>
        </trans-unit>
        <trans-unit id="78e87476be473e05171bc062a52f2074d7a8ce2f" translate="yes" xml:space="preserve">
          <source>If flush is true, Decode assumes that src represents the end of the input stream and processes it completely rather than wait for the completion of another 32-bit block.</source>
          <target state="translated">如果flush为真,Decode假设src代表输入流的结束,并完全处理它,而不是等待另一个32位块的完成。</target>
        </trans-unit>
        <trans-unit id="abcd3e65f17be630b169b8e4f1f0e366085cdf18" translate="yes" xml:space="preserve">
          <source>If format is a different character, Text returns a &quot;%&quot; followed by the unrecognized format character.</source>
          <target state="translated">如果格式是一个不同的字符,Text会返回一个&quot;%&quot;,后面跟着未识别的格式字符。</target>
        </trans-unit>
        <trans-unit id="15ac9863fd0dd8dccce7934858d51ea1256592ee" translate="yes" xml:space="preserve">
          <source>If fs implements GlobFS, Glob calls fs.Glob. Otherwise, Glob uses ReadDir to traverse the directory tree and look for matches for the pattern.</source>
          <target state="translated">如果fs实现了GlobFS,Glob就调用fs.Glob。否则,Glob使用ReadDir遍历目录树并寻找匹配的模式。</target>
        </trans-unit>
        <trans-unit id="4626bc3890fe37988ea2510caab3c9814ba275ba" translate="yes" xml:space="preserve">
          <source>If fs implements ReadDirFS, ReadDir calls fs.ReadDir. Otherwise ReadDir calls fs.Open and uses ReadDir and Close on the returned file.</source>
          <target state="translated">如果fs实现了ReadDirFS,ReadDir调用fs.ReadDir。否则ReadDir会调用fs.Open,并在返回的文件上使用ReadDir和Close。</target>
        </trans-unit>
        <trans-unit id="31f13441b50b357733713ae237e9ae2397173768" translate="yes" xml:space="preserve">
          <source>If fs implements ReadFileFS, ReadFile calls fs.ReadFile. Otherwise ReadFile calls fs.Open and uses Read and Close on the returned file.</source>
          <target state="translated">如果fs实现了ReadFileFS,ReadFile就会调用fs.ReadFile.否则ReadFile就会调用fs.Open并对返回的文件使用Read和Close。否则ReadFile调用fs.Open,并对返回的文件使用Read和Close。</target>
        </trans-unit>
        <trans-unit id="8ceb2c3429af8803daf0d90e52f7956a596fe7fa" translate="yes" xml:space="preserve">
          <source>If fs implements StatFS, Stat calls fs.Stat. Otherwise, Stat opens the file to stat it.</source>
          <target state="translated">如果fs实现了StatFS,Stat就会调用fs.Stat。否则,Stat会打开文件进行统计。</target>
        </trans-unit>
        <trans-unit id="b3469f576be775bc4ec742d95d1dcbeceeba0ae6" translate="yes" xml:space="preserve">
          <source>If fs implements SubFS, Sub calls returns fsys.Sub(dir). Otherwise, if dir is &quot;.&quot;, Sub returns fsys unchanged. Otherwise, Sub returns a new FS implementation sub that, in effect, implements sub.Open(dir) as fsys.Open(path.Join(dir, name)). The implementation also translates calls to ReadDir, ReadFile, and Glob appropriately.</source>
          <target state="translated">如果fs实现了SubFS,Sub调用返回fsys.Sub(dir)。否则,如果dir是&quot;.&quot;,Sub返回fsys不变。否则,Sub将返回一个新的FS实现sub,实际上,它将sub.Open(dir)实现为fsys.Open(path.Join(dir,name))。该实现还适当地翻译了对ReadDir、ReadFile和Glob的调用。</target>
        </trans-unit>
        <trans-unit id="5da5429fa2e44a95884b22d9fe6c9389416883fa" translate="yes" xml:space="preserve">
          <source>If id is an embedded struct field, ObjectOf returns the field (*Var) it defines, not the type (*TypeName) it uses.</source>
          <target state="translated">如果id是一个嵌入的结构字段,ObjectOf返回它定义的字段(*Var),而不是它使用的类型(*TypeName)。</target>
        </trans-unit>
        <trans-unit id="94590e2c870c388ec6ffdc4a336f130561479132" translate="yes" xml:space="preserve">
          <source>If implemented, drivers may return the underlying error from queries, even if the connection should be discarded by the connection pool.</source>
          <target state="translated">如果实现,驱动程序可能会从查询中返回底层错误,即使连接池应该丢弃连接。</target>
        </trans-unit>
        <trans-unit id="5f15fee8dc8778902e45311fbf0205cb96dcffed" translate="yes" xml:space="preserve">
          <source>If inuseZero is true, the profile includes allocation records where r.AllocBytes &amp;gt; 0 but r.AllocBytes == r.FreeBytes. These are sites where memory was allocated, but it has all been released back to the runtime.</source>
          <target state="translated">如果inuseZero为true，则配置文件将包括分配记录，其中r.AllocBytes&amp;gt; 0，但r.AllocBytes == r.FreeBytes。这些是分配了内存的站点，但所有站点都已释放回运行时。</target>
        </trans-unit>
        <trans-unit id="892475b4c6ec1f9a63d5df678595d2602a01d9d3" translate="yes" xml:space="preserve">
          <source>If laddr is nil, a local address is automatically chosen. If the IP field of raddr is nil or an unspecified IP address, the local system is assumed.</source>
          <target state="translated">如果laddr为nil,则自动选择本地地址,如果raddr的IP字段为nil或未指定IP地址,则假定本地系统。如果raddr的IP字段为nil或未指定的IP地址,则假定为本地系统。</target>
        </trans-unit>
        <trans-unit id="ba24dc1c2b3bf1cedb83b06f2414cb64ac15d1da" translate="yes" xml:space="preserve">
          <source>If laddr is non-nil, it is used as the local address for the connection.</source>
          <target state="translated">如果laddr为非零,它将作为连接的本地地址。</target>
        </trans-unit>
        <trans-unit id="9842a555fc5ba63bad435c92db4ce21af1894ec3" translate="yes" xml:space="preserve">
          <source>If level is in the range [-2, 9] then the error returned will be nil. Otherwise the error returned will be non-nil.</source>
          <target state="translated">如果level在[-2,9]范围内,那么返回的错误将为nil。否则返回的错误将为非零。</target>
        </trans-unit>
        <trans-unit id="550da103e5e342ac2c8eff3e35ca3b010db8375f" translate="yes" xml:space="preserve">
          <source>If modtime is not the zero time or Unix epoch, ServeContent includes it in a Last-Modified header in the response. If the request includes an If-Modified-Since header, ServeContent uses modtime to decide whether the content needs to be sent at all.</source>
          <target state="translated">如果modtime不是零时间或Unix epoch,ServeContent会把它包含在响应的Last-Modified头中。如果请求包含一个If-Modified-Since头,ServeContent使用modtime来决定是否需要发送内容。</target>
        </trans-unit>
        <trans-unit id="df0b7b2149e75e7925ff056e6fc4f402a865000a" translate="yes" xml:space="preserve">
          <source>If multiple result sets are supported, Rows should implement RowsNextResultSet. If the driver knows how to describe the types present in the returned result it should implement the following interfaces: RowsColumnTypeScanType, RowsColumnTypeDatabaseTypeName, RowsColumnTypeLength, RowsColumnTypeNullable, and RowsColumnTypePrecisionScale. A given row value may also return a Rows type, which may represent a database cursor value.</source>
          <target state="translated">如果支持多个结果集,Rows应该实现RowsNextResultSet。如果驱动程序知道如何描述返回结果中存在的类型,它应该实现以下接口。RowsColumnTypeScanType、RowsColumnTypeDatabaseTypeName、RowsColumnTypeLength、RowsColumnTypeNullable和RowsColumnTypePrecisionScale。一个给定的行值也可以返回一个Rows类型,它可以代表一个数据库游标值。</target>
        </trans-unit>
        <trans-unit id="8c6876f56eb90009b843d2c55675ac1e4df7f277" translate="yes" xml:space="preserve">
          <source>If multiple servers are terminating connections for the same host they should all have the same session ticket keys. If the session ticket keys leaks, previously recorded and future TLS connections using those keys might be compromised.</source>
          <target state="translated">如果多台服务器为同一台主机终止连接,它们应该都有相同的会话票据密钥。如果会话票据密钥泄露,那么之前记录的和未来使用这些密钥的TLS连接可能会被破坏。</target>
        </trans-unit>
        <trans-unit id="fb36c7496ab365e2e943be0f9148eadc4805b840" translate="yes" xml:space="preserve">
          <source>If n &amp;gt; 0, ReadDir returns at most n DirEntry records. In this case, if ReadDir returns an empty slice, it will return an error explaining why. At the end of a directory, the error is io.EOF.</source>
          <target state="translated">如果n&amp;gt; 0，则ReadDir最多返回n个DirEntry记录。在这种情况下，如果ReadDir返回一个空片，它将返回一个解释原因的错误。在目录的末尾，错误是io.EOF。</target>
        </trans-unit>
        <trans-unit id="4498ca26095d9f0afc17fc3d124ee10f9b929767" translate="yes" xml:space="preserve">
          <source>If n &amp;gt; 0, Readdir returns at most n FileInfo structures. In this case, if Readdir returns an empty slice, it will return a non-nil error explaining why. At the end of a directory, the error is io.EOF.</source>
          <target state="translated">如果n&amp;gt; 0，则Readdir最多返回n个FileInfo结构。在这种情况下，如果Readdir返回一个空片，它将返回一个非null错误，说明原因。在目录末尾，错误是io.EOF。</target>
        </trans-unit>
        <trans-unit id="fc3b271d5f3a597b07b28cf1083fa8b465cfe35b" translate="yes" xml:space="preserve">
          <source>If n &amp;gt; 0, Readdirnames returns at most n names. In this case, if Readdirnames returns an empty slice, it will return a non-nil error explaining why. At the end of a directory, the error is io.EOF.</source>
          <target state="translated">如果n&amp;gt; 0，则Readdirnames最多返回n个名称。在这种情况下，如果Readdirnames返回一个空片，它将返回一个非null错误，说明原因。在目录末尾，错误是io.EOF。</target>
        </trans-unit>
        <trans-unit id="027dd1e79aacbdc0d0cb972c4a1c88050114f175" translate="yes" xml:space="preserve">
          <source>If n &amp;lt;= 0, ReadDir returns all the DirEntry records remaining in the directory. When it succeeds, it returns a nil error (not io.EOF).</source>
          <target state="translated">如果n &amp;lt;= 0，则ReadDir返回目录中剩余的所有DirEntry记录。成功后，它将返回nil错误（不是io.EOF）。</target>
        </trans-unit>
        <trans-unit id="eac4c3ba5a8c94ad8cb8a4a397c8ee90135cea13" translate="yes" xml:space="preserve">
          <source>If n &amp;lt;= 0, Readdir returns all the FileInfo from the directory in a single slice. In this case, if Readdir succeeds (reads all the way to the end of the directory), it returns the slice and a nil error. If it encounters an error before the end of the directory, Readdir returns the FileInfo read until that point and a non-nil error.</source>
          <target state="translated">如果n &amp;lt;= 0，则Readdir在单个片中返回目录中的所有FileInfo。在这种情况下，如果Readdir成功（一直读取到目录的末尾），它将返回切片和nil错误。如果它在目录末尾之前遇到错误，则Readdir返回读取的FileInfo直到该点为止，并且返回非nil错误。</target>
        </trans-unit>
        <trans-unit id="c3cc55f92ff37a98b5144ea82d578410d2c8c458" translate="yes" xml:space="preserve">
          <source>If n &amp;lt;= 0, Readdirnames returns all the names from the directory in a single slice. In this case, if Readdirnames succeeds (reads all the way to the end of the directory), it returns the slice and a nil error. If it encounters an error before the end of the directory, Readdirnames returns the names read until that point and a non-nil error.</source>
          <target state="translated">如果n &amp;lt;= 0，则Readdirnames在单个片中返回目录中的所有名称。在这种情况下，如果Readdirnames成功（一直读取到目录的末尾），它将返回切片和nil错误。如果在目录末尾遇到错误，Readdirnames将返回读取的名称，直到该点为止，并且返回非nil错误。</target>
        </trans-unit>
        <trans-unit id="2b903f7cf121247bf3e7b3aca6c7022dbb5df0e4" translate="yes" xml:space="preserve">
          <source>If n &amp;lt;= 0, no idle connections are retained.</source>
          <target state="translated">如果n &amp;lt;= 0，则不保留空闲连接。</target>
        </trans-unit>
        <trans-unit id="be61ba0537fe2779cebfab91a18a370978aeba0f" translate="yes" xml:space="preserve">
          <source>If n &amp;lt;= 0, then there is no limit on the number of open connections. The default is 0 (unlimited).</source>
          <target state="translated">如果n &amp;lt;= 0，则打开的连接数没有限制。默认值为0（无限制）。</target>
        </trans-unit>
        <trans-unit id="3ffbdba0310e5330b6e39ba21df32f4ec64c1673" translate="yes" xml:space="preserve">
          <source>If name contains no path separators, Command uses LookPath to resolve name to a complete path if possible. Otherwise it uses name directly as Path.</source>
          <target state="translated">如果name不包含路径分隔符,Command会尽可能使用LookPath将name解析为一个完整的路径。否则它直接使用name作为Path。</target>
        </trans-unit>
        <trans-unit id="bda6ab9657711e238f41fc5c82fabb4f059d8032" translate="yes" xml:space="preserve">
          <source>If named parameters or context are supported, the driver's Conn should implement: ExecerContext, QueryerContext, ConnPrepareContext, and ConnBeginTx.</source>
          <target state="translated">如果支持命名参数或上下文,驱动的Conn应该实现。ExecerContext,QueryerContext,ConnPrepareContext,和 ConnBeginTx.</target>
        </trans-unit>
        <trans-unit id="e919c20774517f309335e67ee8266068c715cb69" translate="yes" xml:space="preserve">
          <source>If no entry is found, a nil object is returned. In this case, the returned index and indirect values have the following meaning:</source>
          <target state="translated">如果没有找到条目,将返回一个nil对象。在这种情况下,返回的索引和间接值具有以下含义。</target>
        </trans-unit>
        <trans-unit id="2a51e78e82aff9bdb39269ef8cd918a49b097d8e" translate="yes" xml:space="preserve">
          <source>If opts.Roots is nil and system roots are unavailable the returned error will be of type SystemRootsError.</source>
          <target state="translated">如果opts.Root为nil,并且系统根不可用,返回的错误类型为SystemRootsError。</target>
        </trans-unit>
        <trans-unit id="6ec80a61e5ca904701ff45ad5637a764d8777e22" translate="yes" xml:space="preserve">
          <source>If opts.Roots is nil, the platform verifier might be used, and verification details might differ from what is described below. If system roots are unavailable the returned error will be of type SystemRootsError.</source>
          <target state="translated">如果opts.Root为nil,可能会使用平台验证器,验证细节可能与下面描述的不同。如果系统根不可用,返回的错误将是SystemRootsError类型。</target>
        </trans-unit>
        <trans-unit id="93b29b6dd544ee070bf7867f11c38d0b30ce0f19" translate="yes" xml:space="preserve">
          <source>If p points into an allocated object, it can be advanced through the object by conversion to uintptr, addition of an offset, and conversion back to Pointer.</source>
          <target state="translated">如果p指向一个已分配的对象,则可以通过转换为uintptr,加上偏移量,再转换回Pointer,来推进这个对象。</target>
        </trans-unit>
        <trans-unit id="9c4a4899af1972effe20bb6d4fb3e2cc68991f24" translate="yes" xml:space="preserve">
          <source>If pc is not covered by any entry in this line table, SeekPC returns ErrUnknownPC. In this case, *entry and the final seek position are unspecified.</source>
          <target state="translated">如果pc没有被该行表的任何条目覆盖,SeekPC返回ErrUnknownPC。在这种情况下,*条目和最终的寻求位置是未指定的。</target>
        </trans-unit>
        <trans-unit id="400c0cdcf2667212ffa50be895764e1b4992a8e1" translate="yes" xml:space="preserve">
          <source>If pc represents multiple functions because of inlining, it returns the *Func describing the innermost function, but with an entry of the outermost function.</source>
          <target state="translated">如果pc因为内联而代表多个函数,则返回描述最内层函数的*Func,但有一个最外层函数的条目。</target>
        </trans-unit>
        <trans-unit id="47b9ebf87a72a4fc29d6e9526a5e472474f83dfe" translate="yes" xml:space="preserve">
          <source>If pc represents multiple functions because of inlining, it returns the a *Func describing the innermost function, but with an entry of the outermost function.</source>
          <target state="translated">如果pc因为内联而代表多个函数,则返回描述最内层函数的a *Func,但有一个最外层函数的条目。</target>
        </trans-unit>
        <trans-unit id="8759c1ffe2421dc4e493bad121916d1c4a784268" translate="yes" xml:space="preserve">
          <source>If pkg == nil, the Universe scope is used and the provided position pos is ignored. If pkg != nil, and pos is invalid, the package scope is used. Otherwise, pos must belong to the package.</source>
          <target state="translated">如果 pkg ==nil,则使用 Universe 作用域,并忽略提供的位置 pos。如果 pkg !=nil,并且 pos 无效,则使用包的作用域。否则,pos必须属于包的范围。</target>
        </trans-unit>
        <trans-unit id="3b501d10f0b3315a0edcb0a3aa0bfa72db3f19b3" translate="yes" xml:space="preserve">
          <source>If pkg was loaded from export data, Imports includes packages that provide package-level objects referenced by pkg. This may be more or less than the set of packages directly imported by pkg's source code.</source>
          <target state="translated">如果 pkg 是从导出数据中加载的,那么 Imports 包括提供 pkg 引用的包级对象的包。这可能比 pkg 的源代码直接导入的包的数量多或少。</target>
        </trans-unit>
        <trans-unit id="a13dac68b11bffa0323115aff464b296dab14f09" translate="yes" xml:space="preserve">
          <source>If r and s point to different rings, linking them creates a single ring with the elements of s inserted after r. The result points to the element following the last element of s after insertion.</source>
          <target state="translated">如果r和s指向不同的环,将它们连接起来就会产生一个单一的环,s的元素插入到r之后,结果指向插入后s的最后一个元素。</target>
        </trans-unit>
        <trans-unit id="b045896c9ac0e612d840b26fdcd16f9492dfd688" translate="yes" xml:space="preserve">
          <source>If r and s point to the same ring, linking them removes the elements between r and s from the ring. The removed elements form a subring and the result is a reference to that subring (if no elements were removed, the result is still the original value for r.Next(), and not nil).</source>
          <target state="translated">如果r和s指向同一个环,那么将它们连接起来,就会从环中删除r和s之间的元素,删除的元素形成一个子环,结果是对该子环的引用(如果没有删除元素,结果仍然是r.Next()的原始值,而不是nil)。删除的元素形成一个子环,结果是对该子环的引用(如果没有删除元素,结果仍然是r.Next()的原始值,而不是nil)。</target>
        </trans-unit>
        <trans-unit id="8848277c3a29719067a054c042f2cd449fd3596a" translate="yes" xml:space="preserve">
          <source>If rand is not nil then RSA blinding will be used to avoid timing side-channel attacks.</source>
          <target state="translated">如果rand不是nil,那么将使用RSA blinding来避免定时侧通道攻击。</target>
        </trans-unit>
        <trans-unit id="a19e63938d7a0894376439e5599ffa43b250a5d4" translate="yes" xml:space="preserve">
          <source>If rt.RoundTrip returns ErrSkipAltProtocol, the Transport will handle the RoundTrip itself for that one request, as if the protocol were not registered.</source>
          <target state="translated">如果rt.RoundTrip返回ErrSkipAltProtocol,Transport将为这一个请求处理RoundTrip本身,就像协议没有注册一样。</target>
        </trans-unit>
        <trans-unit id="54ad40399e089deda52c88ae3ba4659988c86560" translate="yes" xml:space="preserve">
          <source>If s does not contain sep and sep is not empty, Split returns a slice of length 1 whose only element is s.</source>
          <target state="translated">如果s不包含sep,并且sep不是空的,Split返回一个长度为1的分片,其唯一的元素是s。</target>
        </trans-unit>
        <trans-unit id="9daee5dcf8a47681ddd5e5f835fb1dbed1f83aea" translate="yes" xml:space="preserve">
          <source>If s does not contain sep and sep is not empty, SplitAfter returns a slice of length 1 whose only element is s.</source>
          <target state="translated">如果s不包含sep,并且sep不是空的,SplitAfter返回一个长度为1的分片,其唯一的元素是s。</target>
        </trans-unit>
        <trans-unit id="9684a535d56fa8216893011aa4860380b4410933" translate="yes" xml:space="preserve">
          <source>If s is not syntactically well-formed, ParseComplex returns err.Err = ErrSyntax.</source>
          <target state="translated">如果s在语法上不完善,ParseComplex返回err.Err=ErrSyntax。</target>
        </trans-unit>
        <trans-unit id="95759bb8e19ebcbb98672ac7fdd18943d4708775" translate="yes" xml:space="preserve">
          <source>If s is not syntactically well-formed, ParseFloat returns err.Err = ErrSyntax.</source>
          <target state="translated">如果s在语法上不完善,ParseFloat返回err.Err=ErrSyntax。</target>
        </trans-unit>
        <trans-unit id="07f06b052060daddabd04efc8e7cdb5992bfb2f4" translate="yes" xml:space="preserve">
          <source>If s is syntactically well-formed but either component is more than 1/2 ULP away from the largest floating point number of the given component's size, ParseComplex returns err.Err = ErrRange and c = &amp;plusmn;Inf for the respective component.</source>
          <target state="translated">如果s在语法上格式正确，但是任何一个组件距离给定组件大小的最大浮点数均超过1/2 ULP，则ParseComplex返回err.Err = ErrRange，c =&amp;plusmn;Inf。</target>
        </trans-unit>
        <trans-unit id="3e257c93b527ddb828e688937de0ccc11edf5f79" translate="yes" xml:space="preserve">
          <source>If s is syntactically well-formed but is more than 1/2 ULP away from the largest floating point number of the given size, ParseFloat returns f = &amp;plusmn;Inf, err.Err = ErrRange.</source>
          <target state="translated">如果s在语法上格式正确，但与给定大小的最大浮点数相差超过1/2 ULP，则ParseFloat返回f =&amp;plusmn;Inf，err.Err = ErrRange。</target>
        </trans-unit>
        <trans-unit id="2958c3475b5e1c01d3ef1742914960b9002f7a9e" translate="yes" xml:space="preserve">
          <source>If sec &amp;gt; 0, the data is sent in the background as with sec &amp;lt; 0. On some operating systems after sec seconds have elapsed any remaining unsent data may be discarded.</source>
          <target state="translated">如果sec&amp;gt; 0，则与sec &amp;lt;0一样在后台发送数据。在某些操作系统上，经过sec秒后，所有剩余的未发送数据都可能会被丢弃。</target>
        </trans-unit>
        <trans-unit id="f56f69cce6422c40a21ab01c5418cdbd4bf77063" translate="yes" xml:space="preserve">
          <source>If sec &amp;lt; 0 (the default), the operating system finishes sending the data in the background.</source>
          <target state="translated">如果sec &amp;lt;0（默认值），则操作系统将在后台完成数据发送。</target>
        </trans-unit>
        <trans-unit id="d8d3489dffe9a7fe6c9ad9a620bad31395af4507" translate="yes" xml:space="preserve">
          <source>If sec == 0, the operating system discards any unsent or unacknowledged data.</source>
          <target state="translated">如果sec ==0,操作系统会丢弃任何未发送或未确认的数据。</target>
        </trans-unit>
        <trans-unit id="be66aebe1a8866a8f4dc281f1bd57616b1f982bc" translate="yes" xml:space="preserve">
          <source>If sep is empty, Split splits after each UTF-8 sequence. If both s and sep are empty, Split returns an empty slice.</source>
          <target state="translated">如果sep为空,Split在每个UTF-8序列后进行分割。如果s和sep都为空,Split返回一个空分片。</target>
        </trans-unit>
        <trans-unit id="489ca1eca08b1f0a405730583d47d533fb4b076e" translate="yes" xml:space="preserve">
          <source>If sep is empty, SplitAfter splits after each UTF-8 sequence. If both s and sep are empty, SplitAfter returns an empty slice.</source>
          <target state="translated">如果sep为空,SplitAfter会在每个UTF-8序列后进行分割。如果s和sep都是空的,SplitAfter返回一个空的分片。</target>
        </trans-unit>
        <trans-unit id="2a3657d8164caf54f78f733fc8ef2ecda3905624" translate="yes" xml:space="preserve">
          <source>If src != nil, ParseFile parses the source from src and the filename is only used when recording position information. The type of the argument for the src parameter must be string, []byte, or io.Reader. If src == nil, ParseFile parses the file specified by filename.</source>
          <target state="translated">如果 src !=nil,ParseFile 将从 src 解析源文件,并且文件名仅在记录位置信息时使用。src参数的类型必须是string、[]byte或io.Reader。如果 src ==nil,ParseFile 会解析 filename 所指定的文件。</target>
        </trans-unit>
        <trans-unit id="fe8d7fb1ea6082771e2bec41671407fae46d618e" translate="yes" xml:space="preserve">
          <source>If src implements the WriterTo interface, the copy is implemented by calling src.WriteTo(dst). Otherwise, if dst implements the ReaderFrom interface, the copy is implemented by calling dst.ReadFrom(src).</source>
          <target state="translated">如果 src 实现了 WriterTo 接口,则通过调用 src.WriteTo(dst)来实现复制。否则,如果 dst 实现了 ReaderFrom 接口,则通过调用 dst.ReadFrom(src)实现复制。</target>
        </trans-unit>
        <trans-unit id="e40b342e6817ab9c3ac4432d840f11c1f0b22325" translate="yes" xml:space="preserve">
          <source>If src is a partial source file, the leading and trailing space of src is applied to the result (such that it has the same leading and trailing space as src), and the result is indented by the same amount as the first line of src containing code. Imports are not sorted for partial source files.</source>
          <target state="translated">如果 src 是一个部分源文件,src 的前导和尾部空间会应用到结果中(使其具有与 src 相同的前导和尾部空间),并且结果会与包含代码的 src 的第一行缩进相同的数量。对于部分源文件,导入不进行排序。</target>
        </trans-unit>
        <trans-unit id="7c67bad25cffc131c00d1eef36d585ec638c9170" translate="yes" xml:space="preserve">
          <source>If srv.Addr is blank, &quot;:http&quot; is used.</source>
          <target state="translated">如果srv.Addr为空白,则使用&quot;:http&quot;。</target>
        </trans-unit>
        <trans-unit id="f9e50e1a49136013b88aa780931a141882ea6f39" translate="yes" xml:space="preserve">
          <source>If srv.Addr is blank, &quot;:https&quot; is used.</source>
          <target state="translated">如果srv.Addr为空白,则使用&quot;:https&quot;。</target>
        </trans-unit>
        <trans-unit id="ad0892d319e6dc448b8b5b8890782a44c3d82311" translate="yes" xml:space="preserve">
          <source>If successful, tmpl will now be injection-safe. Otherwise, err is an error defined in the docs for ErrorCode.</source>
          <target state="translated">如果成功,tmpl现在将是注入安全的。否则,err就是一个在ErrorCode文档中定义的错误。</target>
        </trans-unit>
        <trans-unit id="451a36f1b0a3d42a37ffc7ced9db73e72d35532d" translate="yes" xml:space="preserve">
          <source>If syntax errors were found, the result is a partial AST (with ast.Bad* nodes representing the fragments of erroneous source code). Multiple errors are returned via a scanner.ErrorList which is sorted by source position.</source>
          <target state="translated">如果发现语法错误,结果是一个部分AST(用 ast.Bad*节点代表错误的源代码片段)。多个错误会通过一个 scanner.ErrorList 返回,该错误列表按源码位置排序。</target>
        </trans-unit>
        <trans-unit id="02f96dee5151e31c5e7cb8d54792d30a40798d8b" translate="yes" xml:space="preserve">
          <source>If that method exists, it returns the memory address which triggered the fault. The results of Addr are best-effort and the veracity of the result may depend on the platform. SetPanicOnFault applies only to the current goroutine. It returns the previous setting.</source>
          <target state="translated">如果该方法存在,它将返回触发故障的内存地址。Addr的结果是最好的结果,结果的真实性可能取决于平台。SetPanicOnFault只适用于当前的goroutine。它返回之前的设置。</target>
        </trans-unit>
        <trans-unit id="178b407eef387370d388c8cfe01edb64789c6b52" translate="yes" xml:space="preserve">
          <source>If the Client's Transport does not have a CloseIdleConnections method then this method does nothing.</source>
          <target state="translated">如果客户端的Transport没有CloseIdleConnections方法,那么这个方法就没有任何作用。</target>
        </trans-unit>
        <trans-unit id="a2836eacebc948128e4aa3ce4d8b1d3fc7d6a477" translate="yes" xml:space="preserve">
          <source>If the Content-Type header has not been set, Redirect sets it to &quot;text/html; charset=utf-8&quot; and writes a small HTML body. Setting the Content-Type header to any value, including nil, disables that behavior.</source>
          <target state="translated">如果没有设置Content-Type头,Redirect将其设置为 &quot;text/html;charset=utf-8&quot;,并写入一个小的HTML正文。将Content-Type头设置为任何值,包括nil,都会禁用该行为。</target>
        </trans-unit>
        <trans-unit id="3ae6135ca1107639811cd5daef71ae7fca79e2f6" translate="yes" xml:space="preserve">
          <source>If the Context field is 0, the context function is being called to record the current traceback context. It should record in the Context field whatever information is needed about the current point of execution to later produce a stack trace, probably the stack pointer and PC. In this case the context function will be called from C code.</source>
          <target state="translated">如果Context字段为0,则调用context函数记录当前的回溯上下文,它应该在Context字段中记录当前执行点的任何信息,以便以后产生堆栈跟踪,可能是堆栈指针和PC。它应该在Context字段中记录关于当前执行点的任何信息,以便以后产生堆栈跟踪,可能是堆栈指针和PC。在这种情况下,上下文函数将从C代码中调用。</target>
        </trans-unit>
        <trans-unit id="42011269501bbfe9917fe4565b51ba6a042b7ead" translate="yes" xml:space="preserve">
          <source>If the Context field is not 0, then it is a value returned by a previous call to the context function. This case is called when the context is no longer needed; that is, when the Go code is returning to its C code caller. This permits the context function to release any associated resources.</source>
          <target state="translated">如果Context字段不是0,那么它就是之前调用上下文函数返回的值。这种情况下,当不再需要上下文时,也就是当Go代码返回到C代码调用者时,就会被调用。这允许上下文函数释放任何相关的资源。</target>
        </trans-unit>
        <trans-unit id="084a8ea923e025ba6d8130824462ac823dad2f19" translate="yes" xml:space="preserve">
          <source>If the Delta field of a CaseRange is UpperLower, it means this CaseRange represents a sequence of the form (say) Upper Lower Upper Lower.</source>
          <target state="translated">如果一个CaseRange的Delta字段是UpperLower,那么就意味着这个CaseRange表示一个形式(比如)Upper Lower Upper Lower的序列。</target>
        </trans-unit>
        <trans-unit id="99155dad735e31c1f83383d55994a89a1d5b0d8e" translate="yes" xml:space="preserve">
          <source>If the Go program is started with a non-empty signal mask, that will generally be honored. However, some signals are explicitly unblocked: the synchronous signals, SIGILL, SIGTRAP, SIGSTKFLT, SIGCHLD, SIGPROF, and, on GNU/Linux, signals 32 (SIGCANCEL) and 33 (SIGSETXID) (SIGCANCEL and SIGSETXID are used internally by glibc). Subprocesses started by os.Exec, or by the os/exec package, will inherit the modified signal mask.</source>
          <target state="translated">如果围棋程序以非空信号掩码启动,通常会被尊重。然而,有些信号是显式地被解除屏蔽的:同步信号SIGILL、SIGTRAP、SIGSTKFLT、SIGCHLD、SIGPROF,以及GNU/Linux上的信号32(SIGCANCEL)和33(SIGSETXID)(SIGCANCEL和SIGSETXID由glibc内部使用)。由 os.Exec 或 os/exec 包启动的子进程将继承修改后的信号掩码。</target>
        </trans-unit>
        <trans-unit id="9a19e7607fdf15201f487fc6adac4a654bb31d6b" translate="yes" xml:space="preserve">
          <source>If the Go program is started with either SIGHUP or SIGINT ignored (signal handler set to SIG_IGN), they will remain ignored.</source>
          <target state="translated">如果围棋程序启动时忽略了SIGHUP或SIGINT(信号处理程序设置为SIG_IGN),它们将保持被忽略状态。</target>
        </trans-unit>
        <trans-unit id="bb2401bc392b8c040ae8577c33db0583e1939491" translate="yes" xml:space="preserve">
          <source>If the Go runtime sees an existing signal handler for the SIGCANCEL or SIGSETXID signals (which are used only on GNU/Linux), it will turn on the SA_ONSTACK flag and otherwise keep the signal handler.</source>
          <target state="translated">如果Go运行时看到SIGCANCEL或SIGSETXID信号(仅在GNU/Linux上使用)的现有信号处理程序,它将打开SA_ONSTACK标志,否则将保留该信号处理程序。</target>
        </trans-unit>
        <trans-unit id="b8c9bbe3199fe348a3ebb3c33bad8f777f2557ca" translate="yes" xml:space="preserve">
          <source>If the Go signal handler is invoked on a non-Go thread not running Go code, the handler generally forwards the signal to the non-Go code, as follows. If the signal is SIGPROF, the Go handler does nothing. Otherwise, the Go handler removes itself, unblocks the signal, and raises it again, to invoke any non-Go handler or default system handler. If the program does not exit, the Go handler then reinstalls itself and continues execution of the program.</source>
          <target state="translated">如果在没有运行围棋代码的非围棋线程上调用围棋信号处理程序,处理程序一般会将信号转发给非围棋代码,具体如下。如果信号是SIGPROF,围棋处理程序不做任何操作。否则,围棋处理程序将自己移走,解锁信号,并再次引发信号,以调用任何非围棋处理程序或默认的系统处理程序。如果程序没有退出,围棋处理程序就会重新安装自己,继续执行程序。</target>
        </trans-unit>
        <trans-unit id="d1450a83e799c9f838308f1831ad2410ca5837bc" translate="yes" xml:space="preserve">
          <source>If the IP field of laddr is nil or an unspecified IP address, ListenIP listens on all available IP addresses of the local system except multicast IP addresses.</source>
          <target state="translated">如果laddr的IP字段为nil或未指定的IP地址,ListenIP会监听本地系统中除组播IP地址以外的所有可用IP地址。</target>
        </trans-unit>
        <trans-unit id="af82767d02391b6e900db2816b87a4fb9f84a234" translate="yes" xml:space="preserve">
          <source>If the IP field of laddr is nil or an unspecified IP address, ListenTCP listens on all available unicast and anycast IP addresses of the local system. If the Port field of laddr is 0, a port number is automatically chosen.</source>
          <target state="translated">如果laddr的IP字段为nil或未指定的IP地址,ListenTCP监听本地系统所有可用的单播和任意播IP地址。如果laddr的Port字段为0,则自动选择一个端口号。</target>
        </trans-unit>
        <trans-unit id="af86e9317bf51d088cb071c3ee8a01bff50d7b6b" translate="yes" xml:space="preserve">
          <source>If the IP field of laddr is nil or an unspecified IP address, ListenUDP listens on all available IP addresses of the local system except multicast IP addresses. If the Port field of laddr is 0, a port number is automatically chosen.</source>
          <target state="translated">如果laddr的IP字段为nil或未指定的IP地址,则ListenUDP监听本地系统中除组播IP地址以外的所有可用IP地址。如果laddr的Port字段为0,则会自动选择一个端口号。</target>
        </trans-unit>
        <trans-unit id="5b648936c52bc2fbcc7b753478ee856cc09da205" translate="yes" xml:space="preserve">
          <source>If the XML name for a struct field is defined by both the field tag and the struct's XMLName field, the names must match.</source>
          <target state="translated">如果一个结构字段的XML名称由字段标签和结构的XMLName字段同时定义,则名称必须匹配。</target>
        </trans-unit>
        <trans-unit id="5d4098baadc84b2ed5afee57ad7e0f2a2a2618b1" translate="yes" xml:space="preserve">
          <source>If the absolute value of x doesn't fit in buf, FillBytes will panic.</source>
          <target state="translated">如果x的绝对值不适合buf,FillBytes会惊慌失措。</target>
        </trans-unit>
        <trans-unit id="3f2bd83aa910968ed65b7f3c442134176bd4b3dd" translate="yes" xml:space="preserve">
          <source>If the base argument is 0, the true base is implied by the string's prefix: 2 for &quot;0b&quot;, 8 for &quot;0&quot; or &quot;0o&quot;, 16 for &quot;0x&quot;, and 10 otherwise. Also, for argument base 0 only, underscore characters are permitted as defined by the Go syntax for integer literals.</source>
          <target state="translated">如果基数参数为0,则真正的基数由字符串的前缀暗示:2代表 &quot;0b&quot;,8代表 &quot;0 &quot;或 &quot;0o&quot;,16代表 &quot;0x&quot;,否则为10。此外,对于参数基数为 0 的情况,允许使用下划线字符,正如围棋整数语法所定义的那样。</target>
        </trans-unit>
        <trans-unit id="3ef1f744f6bc6158c837d3a4a05d2dd7419e3d5c" translate="yes" xml:space="preserve">
          <source>If the caller has set w's ETag header formatted per RFC 7232, section 2.3, ServeContent uses it to handle requests using If-Match, If-None-Match, or If-Range.</source>
          <target state="translated">如果调用者按照RFC 7232的2.3节设置了w的ETag头格式,ServeContent就会使用它来处理使用If-Match、If-None-Match或If-Range的请求。</target>
        </trans-unit>
        <trans-unit id="7fe34f55752121c99936b8403a6063a8914cb06e" translate="yes" xml:space="preserve">
          <source>If the calling goroutine has locked the operating system thread with runtime.LockOSThread and modified any inheritable OS-level thread state (for example, Linux or Plan 9 name spaces), the new process will inherit the caller's thread state.</source>
          <target state="translated">如果调用的goroutine已经用runtime.LockOSThread锁定了操作系统线程,并修改了任何可继承的操作系统级线程状态(例如Linux或Plan 9的名字空间),新进程将继承调用者的线程状态。</target>
        </trans-unit>
        <trans-unit id="259a07efdd482c1e280dc36d61c76b7e373057fb" translate="yes" xml:space="preserve">
          <source>If the command fails to run or doesn't complete successfully, the error is of type *ExitError. Other error types may be returned for I/O problems.</source>
          <target state="translated">如果命令不能运行或不能成功完成,错误类型为*ExitError。对于I/O问题,可能会返回其他错误类型。</target>
        </trans-unit>
        <trans-unit id="b33403be418b27f91a2d42d554ef5c02f7c63947" translate="yes" xml:space="preserve">
          <source>If the command starts but does not complete successfully, the error is of type *ExitError. Other error types may be returned for other situations.</source>
          <target state="translated">如果命令启动但没有成功完成,错误类型为*ExitError。对于其他情况,可能会返回其他错误类型。</target>
        </trans-unit>
        <trans-unit id="5a122d2b8c97a37a880702f2a3fbe016e3749fd3" translate="yes" xml:space="preserve">
          <source>If the current file is sparse, then the regions marked as a hole are read back as NUL-bytes.</source>
          <target state="translated">如果当前文件是稀疏的,那么标记为空洞的区域将被读回为NUL字节。</target>
        </trans-unit>
        <trans-unit id="3b03d20f1b9fd110420a18ed294f7f997d1375b2" translate="yes" xml:space="preserve">
          <source>If the deadline is exceeded a call to Read or Write or to other I/O methods will return an error that wraps ErrDeadlineExceeded. This can be tested using errors.Is(err, os.ErrDeadlineExceeded). That error implements the Timeout method, and calling the Timeout method will return true, but there are other possible errors for which the Timeout will return true even if the deadline has not been exceeded.</source>
          <target state="translated">如果超过了截止日期,对读、写或其他 I/O 方法的调用将返回一个包裹 ErrDeadlineExceeded 的错误。可以使用 errors.Is(err,os.ErrDeadlineExceeded)来测试。该错误实现了超时方法,调用超时方法将返回真,但还有其他可能的错误,即使没有超过最后期限,超时方法也会返回真。</target>
        </trans-unit>
        <trans-unit id="6253658c1bbbfe0517d9a4b3227473cd894d597c" translate="yes" xml:space="preserve">
          <source>If the directory couldn't be read, a nil map and the respective error are returned. If a parse error occurred, a non-nil but incomplete map and the first error encountered are returned.</source>
          <target state="translated">如果目录无法被读取,则返回一个nil map和相应的错误。如果发生了解析错误,则返回一个非零但不完整的映射和遇到的第一个错误。</target>
        </trans-unit>
        <trans-unit id="01b40bd5ac5583f9db3311853c6994966859d236" translate="yes" xml:space="preserve">
          <source>If the driver supports cursors, a returned Value may also implement the Rows interface in this package. This is used, for example, when a user selects a cursor such as &quot;select cursor(select * from my_table) from dual&quot;. If the Rows from the select is closed, the cursor Rows will also be closed.</source>
          <target state="translated">如果驱动程序支持游标,返回的Value也可以实现这个包中的Rows接口。例如,当用户选择一个游标,如 &quot;select cursor(select*from my_table)from dual &quot;时,就会用到这个接口。如果选择的Rows被关闭,游标Rows也将被关闭。</target>
        </trans-unit>
        <trans-unit id="cf50ebb80b297da2b505a620be031cb25dcead76" translate="yes" xml:space="preserve">
          <source>If the format (which is implicitly %v for Println etc.) is valid for a string (%s %q %v %x %X), the following two rules apply:</source>
          <target state="translated">如果格式(对于Println等来说是隐含的%v)对于一个字符串(%s %q %v %x %X)是有效的,那么就适用以下两个规则。</target>
        </trans-unit>
        <trans-unit id="0f42e25dba03dca0e51f87ed12e981c71373e332" translate="yes" xml:space="preserve">
          <source>If the format specifier includes a %w verb with an error operand, the returned error will implement an Unwrap method returning the operand. It is invalid to include more than one %w verb or to supply it with an operand that does not implement the error interface. The %w verb is otherwise a synonym for %v.</source>
          <target state="translated">如果格式指定器包含一个带有错误操作数的%w动词,返回的错误将实现一个返回操作数的Unwrap方法。包含一个以上的%w动词或提供一个没有实现错误接口的操作数是无效的。否则%w动词就是%v的同义词。</target>
        </trans-unit>
        <trans-unit id="b70a519f0eee1914e654572a47f9ae5a7a8a3889" translate="yes" xml:space="preserve">
          <source>If the host in the address parameter is not a literal IP address or the port is not a literal port number, ResolveTCPAddr resolves the address to an address of TCP end point. Otherwise, it parses the address as a pair of literal IP address and port number. The address parameter can use a host name, but this is not recommended, because it will return at most one of the host name's IP addresses.</source>
          <target state="translated">如果地址参数中的主机不是字面的IP地址,或者端口不是字面的端口号,ResolveTCPAddr会将地址解析为TCP端点的地址。否则,它会将地址解析为一对字面的IP地址和端口号。地址参数可以使用主机名,但不建议这样做,因为它最多返回主机名的一个IP地址。</target>
        </trans-unit>
        <trans-unit id="60603d4b10b0e1d0e446fdae0a4a44c25a6c45b7" translate="yes" xml:space="preserve">
          <source>If the host in the address parameter is not a literal IP address or the port is not a literal port number, ResolveUDPAddr resolves the address to an address of UDP end point. Otherwise, it parses the address as a pair of literal IP address and port number. The address parameter can use a host name, but this is not recommended, because it will return at most one of the host name's IP addresses.</source>
          <target state="translated">如果地址参数中的主机不是字面的IP地址,或者端口不是字面的端口号,ResolveUDPAddr就会将地址解析为UDP端点的地址。否则,它会将地址解析为一对字面的IP地址和端口号。地址参数可以使用主机名,但不建议这样做,因为它最多返回主机名的一个IP地址。</target>
        </trans-unit>
        <trans-unit id="cd0fc2990a9a9cf8fad81f64436555d3d6b35355" translate="yes" xml:space="preserve">
          <source>If the host in the address parameter is not a literal IP address, ResolveIPAddr resolves the address to an address of IP end point. Otherwise, it parses the address as a literal IP address. The address parameter can use a host name, but this is not recommended, because it will return at most one of the host name's IP addresses.</source>
          <target state="translated">如果地址参数中的主机不是一个字面的IP地址,ResolveIPAddr会将该地址解析为IP端点的地址。否则,它将把地址解析为一个字面的IP地址。地址参数可以使用主机名,但不建议这样做,因为它最多返回主机名的一个IP地址。</target>
        </trans-unit>
        <trans-unit id="199da3dce7215d4cebc5f4fd0619e8dbc8fd6d9d" translate="yes" xml:space="preserve">
          <source>If the key type is not a valid map key type (that is, if it does not implement Go's == operator), MapOf panics.</source>
          <target state="translated">如果键类型不是有效的映射键类型(也就是说,如果它没有实现Go的==操作符),MapOf就会恐慌。</target>
        </trans-unit>
        <trans-unit id="fdcae4b6d304718d87888a4b14792a984d6db584" translate="yes" xml:space="preserve">
          <source>If the location cannot be determined (for example, $HOME is not defined), then it will return an error.</source>
          <target state="translated">如果不能确定位置(例如,没有定义$HOME),那么它将返回一个错误。</target>
        </trans-unit>
        <trans-unit id="83fc45c3d88185bce6b913b6fba87e76a3564c14" translate="yes" xml:space="preserve">
          <source>If the n = len(p) bytes returned by ReadAt are at the end of the input source, ReadAt may return either err == EOF or err == nil.</source>
          <target state="translated">如果ReadAt返回的n=len(p)字节处于输入源的末端,ReadAt可能返回err ==EOF或err ==nil。</target>
        </trans-unit>
        <trans-unit id="96928e9a3e37cddefc97fd6808cb69e209a645f8" translate="yes" xml:space="preserve">
          <source>If the name is &quot;&quot; or &quot;UTC&quot;, LoadLocation returns UTC. If the name is &quot;Local&quot;, LoadLocation returns Local.</source>
          <target state="translated">如果名称是&quot;&quot;或 &quot;UTC&quot;,LoadLocation 返回 UTC。如果名称是 &quot;Local&quot;,LoadLocation返回Local。</target>
        </trans-unit>
        <trans-unit id="c79b81e2eaa3eeb8ef94f0d473fa6a78b2eff61b" translate="yes" xml:space="preserve">
          <source>If the name of a slice type ends with &quot;SET&quot; then it's treated as if the &quot;set&quot; tag was set on it. This results in interpreting the type as a SET OF x rather than a SEQUENCE OF x. This can be used with nested slices where a struct tag cannot be given.</source>
          <target state="translated">如果切片类型的名称以 &quot;SET &quot;结尾,那么它就会被视为 &quot;set &quot;标签。这将导致该类型被解释为x的SET,而不是x的SEQUENCE。这可以用于不能给出结构标签的嵌套片。</target>
        </trans-unit>
        <trans-unit id="71bd5d676aea790d3104c9356a66a88a54f27219" translate="yes" xml:space="preserve">
          <source>If the non-Go code called by the Go program does not change any signal handlers or masks, then the behavior is the same as for a pure Go program.</source>
          <target state="translated">如果围棋程序调用的非围棋代码不改变任何信号处理程序或掩码,那么行为就和纯围棋程序一样。</target>
        </trans-unit>
        <trans-unit id="7ff28c4dacda2b677d57a006ed06c589035c4906" translate="yes" xml:space="preserve">
          <source>If the non-Go code installs a signal handler for any of the asynchronous signals, it may invoke the Go signal handler or not as it chooses. Naturally, if it does not invoke the Go signal handler, the Go behavior described above will not occur. This can be an issue with the SIGPROF signal in particular.</source>
          <target state="translated">如果非围棋代码为任何异步信号安装了信号处理程序,它可以选择是否调用围棋信号处理程序。当然,如果它不调用围棋信号处理程序,上述的围棋行为就不会发生。尤其是SIGPROF信号,这可能是一个问题。</target>
        </trans-unit>
        <trans-unit id="abd2048f2311a9e6d64b579961e64f72d37d33a6" translate="yes" xml:space="preserve">
          <source>If the non-Go code installs a signal handler for any of the synchronous signals (SIGBUS, SIGFPE, SIGSEGV), then it should record the existing Go signal handler. If those signals occur while executing Go code, it should invoke the Go signal handler (whether the signal occurs while executing Go code can be determined by looking at the PC passed to the signal handler). Otherwise some Go run-time panics will not occur as expected.</source>
          <target state="translated">如果非围棋代码为任何同步信号(SIGBUS、SIGFPE、SIGSEGV)安装了信号处理程序,那么它应该记录现有的围棋信号处理程序。如果这些信号在执行围棋代码时发生,则应该调用围棋信号处理程序(信号是否在执行围棋代码时发生,可以通过查看传递给信号处理程序的PC来判断)。否则一些围棋运行时的慌乱将不会如期发生。</target>
        </trans-unit>
        <trans-unit id="bb19b115a2d359b987ea5bcb60343aca9ae430dd" translate="yes" xml:space="preserve">
          <source>If the non-Go code installs any signal handlers, it must use the SA_ONSTACK flag with sigaction. Failing to do so is likely to cause the program to crash if the signal is received. Go programs routinely run with a limited stack, and therefore set up an alternate signal stack. Also, the Go standard library expects that any signal handlers will use the SA_RESTART flag. Failing to do so may cause some library calls to return &quot;interrupted system call&quot; errors.</source>
          <target state="translated">如果非围棋代码安装了任何信号处理程序,必须使用sigaction的SA_ONSTACK标志。如果没有这样做,很可能导致程序在收到信号时崩溃。Go程序经常在有限的堆栈下运行,因此设置了一个备用的信号堆栈。另外,Go标准库期望任何信号处理程序都会使用SA_RESTART标志。如果没有这样做,可能会导致一些库调用返回 &quot;中断的系统调用 &quot;错误。</target>
        </trans-unit>
        <trans-unit id="7e1d203998def7d0f58007e88176f92e21a64b50" translate="yes" xml:space="preserve">
          <source>If the non-Go code starts a new thread, changes the signal mask, and then invokes a Go function in that thread, the Go runtime will automatically unblock certain signals: the synchronous signals, SIGILL, SIGTRAP, SIGSTKFLT, SIGCHLD, SIGPROF, SIGCANCEL, and SIGSETXID. When the Go function returns, the non-Go signal mask will be restored.</source>
          <target state="translated">如果非围棋代码启动一个新的线程,更改信号掩码,然后在该线程中调用围棋函数,围棋运行时将自动解除某些信号的屏蔽:同步信号SIGILL、SIGTRAP、SIGSTKFLT、SIGCHLD、SIGPROF、SIGCANCEL和SIGSETXID。当围棋函数返回时,非围棋信号掩码将被恢复。</target>
        </trans-unit>
        <trans-unit id="91074ebc7a3334ebd4f37cdfabaa9ca32fd24f74" translate="yes" xml:space="preserve">
          <source>If the open fails, the error string will be self-explanatory, like</source>
          <target state="translated">如果打开失败,错误字符串将是不言自明的,如</target>
        </trans-unit>
        <trans-unit id="54fcc24f407eeb4900b5f210d5d49a96c53bb1c9" translate="yes" xml:space="preserve">
          <source>If the prefix of the status does not match the digits in expectCode, ReadCodeLine returns with err set to &amp;amp;Error{code, message}. For example, if expectCode is 31, an error will be returned if the status is not in the range [310,319].</source>
          <target state="translated">如果状态的前缀与ExpectCode中的数字不匹配，则ReadCodeLine返回，并且err设置为＆Error {code，message}。例如，如果ExpectCode为31，则如果状态不在[310,319]范围内，则将返回错误。</target>
        </trans-unit>
        <trans-unit id="86837437a16860a8105279be00bffc491da5bba2" translate="yes" xml:space="preserve">
          <source>If the prefix of the status does not match the digits in expectCode, ReadResponse returns with err set to &amp;amp;Error{code, message}. For example, if expectCode is 31, an error will be returned if the status is not in the range [310,319].</source>
          <target state="translated">如果状态的前缀与ExpectCode中的数字不匹配，则ReadResponse返回，并且err设置为＆Error {code，message}。例如，如果ExpectCode为31，则如果状态不在[310,319]范围内，则将返回错误。</target>
        </trans-unit>
        <trans-unit id="5ebf5ba32952d52f53e121ccb89f42cb9010f630" translate="yes" xml:space="preserve">
          <source>If the program has called Notify to receive SIGPIPE signals, the file descriptor number does not matter. The SIGPIPE signal will be delivered to the Notify channel, and the write will fail with an EPIPE error.</source>
          <target state="translated">如果程序已经调用Notify来接收SIGPIPE信号,那么文件描述符号并不重要。SIGPIPE信号将被传送到Notify通道,写入将以EPIPE错误失败。</target>
        </trans-unit>
        <trans-unit id="7cf239f9c12fb938b9596c568e4f45900dce20bb" translate="yes" xml:space="preserve">
          <source>If the program has not called Notify to receive SIGPIPE signals, then the behavior depends on the file descriptor number. A write to a broken pipe on file descriptors 1 or 2 (standard output or standard error) will cause the program to exit with a SIGPIPE signal. A write to a broken pipe on some other file descriptor will take no action on the SIGPIPE signal, and the write will fail with an EPIPE error.</source>
          <target state="translated">如果程序没有调用Notify来接收SIGPIPE信号,那么行为取决于文件描述符的编号。向文件描述符1或2(标准输出或标准错误)上的断管写入将导致程序以SIGPIPE信号退出。对其他文件描述符上的断裂管道的写入将不会对SIGPIPE信号采取任何行动,写入将以EPIPE错误而失败。</target>
        </trans-unit>
        <trans-unit id="111ef080bfe5d9de228261353c72d73b391743f0" translate="yes" xml:space="preserve">
          <source>If the program is started with a non-empty signal mask, some signals will be explicitly unblocked as described above. If Notify is called for a blocked signal, it will be unblocked. If, later, Reset is called for that signal, or Stop is called on all channels passed to Notify for that signal, the signal will once again be blocked.</source>
          <target state="translated">如果程序以一个非空的信号掩码启动,一些信号将如上所述被显式解封。如果对一个被屏蔽的信号调用Notify,它就会被解除屏蔽。如果之后对该信号调用Reset,或者对该信号传递给Notify的所有通道调用Stop,该信号将再次被屏蔽。</target>
        </trans-unit>
        <trans-unit id="6b4f665c5cfb9144d49b7e1dcb5bc2df2bfa007a" translate="yes" xml:space="preserve">
          <source>If the program was started with SIGHUP or SIGINT ignored, and Notify is called for either signal, a signal handler will be installed for that signal and it will no longer be ignored. If, later, Reset or Ignore is called for that signal, or Stop is called on all channels passed to Notify for that signal, the signal will once again be ignored. Reset will restore the system default behavior for the signal, while Ignore will cause the system to ignore the signal entirely.</source>
          <target state="translated">如果程序在启动时忽略了SIGHUP或SIGINT,并且对任何一个信号调用了Notify,那么将为该信号安装一个信号处理程序,它将不再被忽略。如果之后对该信号调用Reset或Ignore,或者对该信号传递给Notify的所有通道调用Stop,该信号将再次被忽略。Reset将恢复系统对该信号的默认行为,而Ignore将使系统完全忽略该信号。</target>
        </trans-unit>
        <trans-unit id="a50b71ad5f04ba376647400ad12d829202f07d7f" translate="yes" xml:space="preserve">
          <source>If the provided body is also an io.Closer, the returned Request.Body is set to body and will be closed by the Client methods Do, Post, and PostForm, and Transport.RoundTrip.</source>
          <target state="translated">如果提供的body也是一个io.Closer,那么返回的Request.Body将被设置为body,并将被Client方法Do、Post和PostForm,以及Transport.RoundTrip关闭。</target>
        </trans-unit>
        <trans-unit id="a90f0974cd32b46dcc6c15c91f94c9f93252ae8b" translate="yes" xml:space="preserve">
          <source>If the provided body is an io.Closer, it is closed after the request.</source>
          <target state="translated">如果提供的主体是io.Closer,则在请求后关闭。</target>
        </trans-unit>
        <trans-unit id="76a4a3b11148dd18ae8c95298059edf28df076dc" translate="yes" xml:space="preserve">
          <source>If the provided file or directory name is a relative path, it is interpreted relative to the current directory and may ascend to parent directories. If the provided name is constructed from user input, it should be sanitized before calling ServeFile.</source>
          <target state="translated">如果提供的文件或目录名是一个相对路径,那么它将被解释为相对于当前目录,并可能上升到父目录。如果所提供的文件名是由用户输入的,那么在调用ServeFile之前应该对其进行处理。</target>
        </trans-unit>
        <trans-unit id="4e3cf22a6ffbc844d8cc7293fe5c88e56a31e62d" translate="yes" xml:space="preserve">
          <source>If the provided result precision is 0 (see below), it is set to the precision of the argument with the largest precision value before any rounding takes place, and the rounding mode remains unchanged. Thus, uninitialized Floats provided as result arguments will have their precision set to a reasonable value determined by the operands, and their mode is the zero value for RoundingMode (ToNearestEven).</source>
          <target state="translated">如果提供的结果精度为0(见下文),则在进行任何四舍五入之前,它被设置为具有最大精度值的参数的精度,并且四舍五入模式保持不变。因此,作为结果参数提供的未初始化的Floats将被设置为由操作数决定的合理值,其模式为RoundingMode(ToNearestEven)的零值。</target>
        </trans-unit>
        <trans-unit id="2b88a75837ac44c3ec57492aadd63fbc336940cb" translate="yes" xml:space="preserve">
          <source>If the request Body's size has not already been limited by MaxBytesReader, the size is capped at 10MB.</source>
          <target state="translated">如果请求Body的大小还没有被MaxBytesReader限制,则大小上限为10MB。</target>
        </trans-unit>
        <trans-unit id="202ca334b5c1306191933ea4f4be7458350d5dde" translate="yes" xml:space="preserve">
          <source>If the response is multi-line, ReadCodeLine returns an error.</source>
          <target state="translated">如果响应是多行,ReadCodeLine返回一个错误。</target>
        </trans-unit>
        <trans-unit id="cca7e3754527e1fa0174f20268f5f2115cb686b6" translate="yes" xml:space="preserve">
          <source>If the response's Content-Type header is not set, ServeContent first tries to deduce the type from name's file extension and, if that fails, falls back to reading the first block of the content and passing it to DetectContentType. The name is otherwise unused; in particular it can be empty and is never sent in the response.</source>
          <target state="translated">如果响应的Content-Type头没有设置,ServeContent首先尝试从name的文件扩展名中推断出类型,如果失败了,则回到读取内容的第一个块,并将其传递给DetectContentType。名字在其他情况下是不用的,特别是它可以是空的,并且永远不会在响应中发送。</target>
        </trans-unit>
        <trans-unit id="4adb610dc4446d1c29fb56aaef6e5c8a55dbd30c" translate="yes" xml:space="preserve">
          <source>If the result is enclosed in square brackets, as literal IPv6 addresses are, the square brackets are removed from the result.</source>
          <target state="translated">如果结果包含在方括号中,就像IPv6地址一样,方括号会从结果中删除。</target>
        </trans-unit>
        <trans-unit id="46d8ee162d5e124f43ba34e4b526da01d3ba6f66" translate="yes" xml:space="preserve">
          <source>If the result of this process is an empty string, Clean returns the string &quot;.&quot;.</source>
          <target state="translated">如果这个过程的结果是一个空字符串,Clean会返回字符串&quot;.&quot;。</target>
        </trans-unit>
        <trans-unit id="63039cb93ec1523520a70aa02f8add44a72d2dcc" translate="yes" xml:space="preserve">
          <source>If the resulting type would be larger than the available address space, ArrayOf panics.</source>
          <target state="translated">如果产生的类型将大于可用的地址空间,ArrayOf就会惊慌失措。</target>
        </trans-unit>
        <trans-unit id="49eb9c6b19926a8575c169e52f8df687a6338f21" translate="yes" xml:space="preserve">
          <source>If the returned error is nil, the Response will contain a non-nil Body which the user is expected to close. If the Body is not both read to EOF and closed, the Client's underlying RoundTripper (typically Transport) may not be able to re-use a persistent TCP connection to the server for a subsequent &quot;keep-alive&quot; request.</source>
          <target state="translated">如果返回的错误是nil,Response将包含一个非nil的Body,用户应该关闭它。如果Body既没有读到EOF,也没有关闭,那么Client的底层RoundTripper(通常是Transport)可能无法在后续的 &quot;keep-alive &quot;请求中重新使用到服务器的持久性TCP连接。</target>
        </trans-unit>
        <trans-unit id="2bd3e276f21c33ca258e2835ea6ef2502ea92047" translate="yes" xml:space="preserve">
          <source>If the returned token is a keyword, the literal string is the keyword.</source>
          <target state="translated">如果返回的标记是关键字,字面字符串就是关键字。</target>
        </trans-unit>
        <trans-unit id="d7865630a2cf1e24a8ed7ed472ba9beeb25fa193" translate="yes" xml:space="preserve">
          <source>If the returned token is a literal (token.IDENT, token.INT, token.FLOAT, token.IMAG, token.CHAR, token.STRING) or token.COMMENT, the literal string has the corresponding value.</source>
          <target state="translated">如果返回的token是文字(token.IDENT、token.INT、token.FLOAT、token.IMAG、token.CHAR、token.STRING)或token.COMMENT,文字字符串有对应的值。</target>
        </trans-unit>
        <trans-unit id="7b330824cf4af38e2c2f1237e0044975056d896f" translate="yes" xml:space="preserve">
          <source>If the returned token is token.ILLEGAL, the literal string is the offending character.</source>
          <target state="translated">如果返回的标记是token.ILLEGAL,字面字符串就是违规字符。</target>
        </trans-unit>
        <trans-unit id="f2065d9b79fae019bc66ef4f832603a41d2a079f" translate="yes" xml:space="preserve">
          <source>If the returned token is token.SEMICOLON, the corresponding literal string is &quot;;&quot; if the semicolon was present in the source, and &quot;\n&quot; if the semicolon was inserted because of a newline or at EOF.</source>
          <target state="translated">如果返回的标记是token.SEMICOLON,对应的文字串是&quot;;&quot;,如果分号在源码中存在,则是&quot;;&quot;,如果分号因为换行或在EOF处插入,则是&quot;/n&quot;。</target>
        </trans-unit>
        <trans-unit id="6d82694c27c567dcf0d737897e646720cd59f4a9" translate="yes" xml:space="preserve">
          <source>If the server replies with a redirect, the Client first uses the CheckRedirect function to determine whether the redirect should be followed. If permitted, a 301, 302, or 303 redirect causes subsequent requests to use HTTP method GET (or HEAD if the original request was HEAD), with no body. A 307 or 308 redirect preserves the original HTTP method and body, provided that the Request.GetBody function is defined. The NewRequest function automatically sets GetBody for common standard library body types.</source>
          <target state="translated">如果服务器回复了重定向,客户端首先使用CheckRedirect函数来确定是否应该遵循重定向。如果允许,301、302或303重定向会导致后续请求使用HTTP方法GET(或者HEAD,如果原始请求是HEAD),没有body。如果定义了Request.GetBody函数,307或308重定向会保留原来的HTTP方法和body。NewRequest函数会自动设置常用标准库体类型的GetBody。</target>
        </trans-unit>
        <trans-unit id="8bef3b53d6d7bb99946b130aacd06c58001e65ba" translate="yes" xml:space="preserve">
          <source>If the source couldn't be read, the returned AST is nil and the error indicates the specific failure. If the source was read but syntax errors were found, the result is a partial AST (with ast.Bad* nodes representing the fragments of erroneous source code). Multiple errors are returned via a scanner.ErrorList which is sorted by file position.</source>
          <target state="translated">如果源码无法被读取,返回的AST为nil,错误表示具体的失败。如果源码被读取,但发现语法错误,结果是一个部分AST(用 ast.Bad*节点代表错误的源码片段)。多个错误会通过一个 scanner.ErrorList 返回,该错误是按文件位置排序的。</target>
        </trans-unit>
        <trans-unit id="0ea17fae18048ca3efef70d260f3befe5169300a" translate="yes" xml:space="preserve">
          <source>If the source couldn't be read, the returned AST is nil and the error indicates the specific failure. If the source was read but syntax errors were found, the result is a partial AST (with ast.Bad* nodes representing the fragments of erroneous source code). Multiple errors are returned via a scanner.ErrorList which is sorted by source position.</source>
          <target state="translated">如果源码无法被读取,返回的AST为nil,错误表示具体的失败。如果源码被读取,但发现语法错误,结果是一个部分AST(用 ast.Bad*节点代表错误的源码片段)。多个错误会通过一个 scanner.ErrorList 返回,该错误是按源码位置排序的。</target>
        </trans-unit>
        <trans-unit id="f66a139f57b43b60f302e27759bd0543bc9c0e26" translate="yes" xml:space="preserve">
          <source>If the time has a monotonic clock reading, the returned string includes a final field &quot;m=&amp;plusmn;&amp;lt;value&amp;gt;&quot;, where value is the monotonic clock reading formatted as a decimal number of seconds.</source>
          <target state="translated">如果时间具有单调时钟读数，则返回的字符串包括最后一个字段&amp;ldquo; m =&amp;plusmn;&amp;lt;value&amp;gt;&amp;rdquo;，其中value是格式为十进制秒数的单调时钟读数。</target>
        </trans-unit>
        <trans-unit id="251f36d24e83127f4dd9319d7cdbc49677b94325" translate="yes" xml:space="preserve">
          <source>If the traceback function is called from a signal handler on a Unix system, SigContext will be the signal context argument passed to the signal handler (a C ucontext_t* cast to uintptr_t). This may be used to start tracing at the point where the signal occurred. If the traceback function is not called from a signal handler, SigContext will be zero.</source>
          <target state="translated">如果跟踪函数是由Unix系统的信号处理程序调用的,那么SigContext将是传递给信号处理程序的信号上下文参数(一个C语言的ucontext_t*投向uintptr_t)。这可以用来在信号发生的地方开始追踪。如果跟踪函数不是从信号处理程序中调用的,那么SigContext将为零。</target>
        </trans-unit>
        <trans-unit id="07b1d78b08994662a459431d46bce8768415b25a" translate="yes" xml:space="preserve">
          <source>If the type name of a slice element ends with &quot;SET&quot; then it's treated as if the &quot;set&quot; tag was set on it. This can be used with nested slices where a struct tag cannot be given.</source>
          <target state="translated">如果一个分片元素的类型名以 &quot;SET &quot;结尾,那么它将被视为 &quot;set &quot;标签被设置在它上面。这可以用于不能给出结构标签的嵌套分片。</target>
        </trans-unit>
        <trans-unit id="b1b298da75673ff2dc00ea6d79d2dbf4f6d4ad81" translate="yes" xml:space="preserve">
          <source>If the type of the first field of a structure is RawContent then the raw ASN1 contents of the struct will be stored in it.</source>
          <target state="translated">如果一个结构的第一个字段的类型是RawContent,那么该结构的原始ASN1内容将被存储在其中。</target>
        </trans-unit>
        <trans-unit id="94580cf18c0cdda91d151e0855e03334c0926847" translate="yes" xml:space="preserve">
          <source>If there are nested type ids, the types for all inner type ids must be defined before the top-level type id is used to describe an encoded-v.</source>
          <target state="translated">如果有嵌套的类型id,那么所有内层类型id的类型必须在顶层类型id用于描述一个编码的v之前被定义。</target>
        </trans-unit>
        <trans-unit id="a4b08581fb59710f6d84824026b409a7e3fe2aea" translate="yes" xml:space="preserve">
          <source>If there is an error, it will be of type *PathError.</source>
          <target state="translated">如果有一个错误,它的类型将是*PathError。</target>
        </trans-unit>
        <trans-unit id="d59b10d118f91edc83c197a1ea597908270dd51e" translate="yes" xml:space="preserve">
          <source>If there is no registered handler that applies to the request, Handler returns a &amp;ldquo;page not found&amp;rdquo; handler and an empty pattern.</source>
          <target state="translated">If there is no registered handler that applies to the request, Handler returns a &amp;ldquo;page not found&amp;rdquo; handler and an empty pattern.</target>
        </trans-unit>
        <trans-unit id="1a7ace82b8245bf4439307ba5dfdbd1b825dcfff" translate="yes" xml:space="preserve">
          <source>If there was a problem walking to the file or directory named by path, the incoming error will describe the problem and the function can decide how to handle that error (and Walk will not descend into that directory). In the case of an error, the info argument will be nil. If an error is returned, processing stops. The sole exception is when the function returns the special value SkipDir. If the function returns SkipDir when invoked on a directory, Walk skips the directory's contents entirely. If the function returns SkipDir when invoked on a non-directory file, Walk skips the remaining files in the containing directory.</source>
          <target state="translated">如果走到以路径命名的文件或目录时出现了问题,传入的错误将描述该问题,函数可以决定如何处理该错误(Walk不会下降到该目录)。在出现错误的情况下,info参数将为nil。如果返回错误,则停止处理。唯一的例外是当函数返回特殊值SkipDir时,如果函数在一个目录上调用时返回SkipDir,Walk将完全跳过该目录的内容。如果函数在非目录文件上调用时返回SkipDir,Walk将跳过包含目录中的其余文件。</target>
        </trans-unit>
        <trans-unit id="b1b4c374c9ed31601280332f5174e595585d5e35" translate="yes" xml:space="preserve">
          <source>If this ClientHelloInfo was passed to a GetConfigForClient or GetCertificate callback, this method will take into account the associated Config. Note that if GetConfigForClient returns a different Config, the change can't be accounted for by this method.</source>
          <target state="translated">如果这个ClientHelloInfo被传递给了GetConfigForClient或GetCertificate回调,这个方法将考虑到相关的Config。请注意,如果GetConfigForClient返回的是不同的Config,那么本方法就无法解释这种变化。</target>
        </trans-unit>
        <trans-unit id="9f28f83ac01122a6b8eb17da82fc365cf06db186" translate="yes" xml:space="preserve">
          <source>If this compilation unit has no line table, it returns nil, nil.</source>
          <target state="translated">如果这个编译单元没有行表,则返回nil,nil。</target>
        </trans-unit>
        <trans-unit id="36cfd61621ceef678850032683735978215f2feb" translate="yes" xml:space="preserve">
          <source>If u.Host doesn't contain a valid numeric port, Port returns an empty string.</source>
          <target state="translated">如果u.Host不包含一个有效的数字端口,Port返回一个空字符串。</target>
        </trans-unit>
        <trans-unit id="1f16e20c1b2a3c0d7a413b8fa21221a527ff3a01" translate="yes" xml:space="preserve">
          <source>If u.Opaque is non-empty, String uses the first form; otherwise it uses the second form. Any non-ASCII characters in host are escaped. To obtain the path, String uses u.EscapedPath().</source>
          <target state="translated">如果u.Opaque是非空的,String使用第一种形式,否则使用第二种形式。host中的任何非ASCII字符都会被转义。为了获得路径,String使用u.EscapedPath()。</target>
        </trans-unit>
        <trans-unit id="8013c9355c400aa79a6367baa057f4b9d4888841" translate="yes" xml:space="preserve">
          <source>If used in an unsafe context, then the value might be filtered out:</source>
          <target state="translated">如果在不安全的情况下使用,那么该值可能会被过滤掉。</target>
        </trans-unit>
        <trans-unit id="169176f5802d140421e02d07f71892f55914e587" translate="yes" xml:space="preserve">
          <source>If v's Kind is Func, the returned pointer is an underlying code pointer, but not necessarily enough to identify a single function uniquely. The only guarantee is that the result is zero if and only if v is a nil func Value.</source>
          <target state="translated">如果v的Kind是Func,返回的指针是一个底层代码指针,但不一定足以唯一地识别一个函数。唯一的保证是,如果且仅当v是一个nil func Value时,结果为零。</target>
        </trans-unit>
        <trans-unit id="ee9b69667b384fa6c8c1419304597f7a05f5dda4" translate="yes" xml:space="preserve">
          <source>If v's Kind is Slice, the returned pointer is to the first element of the slice. If the slice is nil the returned value is 0. If the slice is empty but non-nil the return value is non-zero.</source>
          <target state="translated">如果v的Kind是Slice,返回的指针是Slice的第一个元素,如果Slice为nil,返回值为0。如果分片为零,返回值为0,如果分片为空但非零,返回值为非零。</target>
        </trans-unit>
        <trans-unit id="c1a7d75eac6a2596c340ad7b921676eeff0e25d7" translate="yes" xml:space="preserve">
          <source>If v.Kind() != KindFloat64, this method panics.</source>
          <target state="translated">如果v.Kind()!=KindFloat64,这个方法就会惊慌失措。</target>
        </trans-unit>
        <trans-unit id="c84cb549645a9f7d2d471fb47b82da9ad06c732f" translate="yes" xml:space="preserve">
          <source>If v.Kind() != KindFloat64Histogram, this method panics.</source>
          <target state="translated">如果v.Kind()!=KindFloat64Histogram,这个方法就会惊慌失措。</target>
        </trans-unit>
        <trans-unit id="1d38af9266598f3f9c2fc36f0c6cb6b077209017" translate="yes" xml:space="preserve">
          <source>If v.Kind() != KindUint64, this method panics.</source>
          <target state="translated">如果v.Kind()!=KindUint64,这个方法就会慌乱。</target>
        </trans-unit>
        <trans-unit id="ccce50575e90f1da7bb594b206672d76cc0b7fdc" translate="yes" xml:space="preserve">
          <source>If x is prime, ProbablyPrime returns true. If x is chosen randomly and not prime, ProbablyPrime probably returns false. The probability of returning true for a randomly chosen non-prime is at most &amp;frac14;ⁿ.</source>
          <target state="translated">如果x为质数，则ProbablyPrime返回true。如果x是随机选择而不是素数，则ProbablyPrime可能返回false。对于随机选择的非素数返回true的概率最多为1 /4ⁿ。</target>
        </trans-unit>
        <trans-unit id="e8a427ffc0c17926670bab4065e96207d4a28d2f" translate="yes" xml:space="preserve">
          <source>If you are not using DefaultServeMux, you will have to register handlers with the mux you are using.</source>
          <target state="translated">如果你没有使用DefaultServeMux,你将不得不向你正在使用的mux注册处理程序。</target>
        </trans-unit>
        <trans-unit id="bf8bf41d1552e2a2314c86bbee51c546608c7502" translate="yes" xml:space="preserve">
          <source>If you like, you can bind the flag to a variable using the Var() functions.</source>
          <target state="translated">如果你愿意,你可以使用Var()函数将标志绑定到一个变量上。</target>
        </trans-unit>
        <trans-unit id="8a6f437f93f8b5dbc142b89b4316e10878736145" translate="yes" xml:space="preserve">
          <source>If your application is not already running an http server, you need to start one. Add &quot;net/http&quot; and &quot;log&quot; to your imports and the following code to your main function:</source>
          <target state="translated">如果你的应用程序还没有运行http服务器,你需要启动一个。将 &quot;net/http &quot;和 &quot;log &quot;添加到你的导入中,并在你的主函数中添加以下代码。</target>
        </trans-unit>
        <trans-unit id="e08bef57a6d48a73f233b8062ac1ffdd047f7ffe" translate="yes" xml:space="preserve">
          <source>If z's precision is 0, it is changed to x's precision before the operation. Rounding is performed according to z's precision and rounding mode, but z's accuracy is not computed. Specifically, the result of z.Acc() is undefined.</source>
          <target state="translated">如果z的精度为0,则在操作前将其改为x的精度。根据z的精度和四舍五入模式进行四舍五入,但不计算z的精度。具体来说,z.Acc()的结果是未定义的。</target>
        </trans-unit>
        <trans-unit id="e7a7bb87f973e19b80ef2f0c235948e2ab80ca50" translate="yes" xml:space="preserve">
          <source>If z's precision is 0, it is changed to x's precision before the operation. Rounding is performed according to z's precision and rounding mode.</source>
          <target state="translated">如果z的精度为0,则在操作前将其改为x的精度。根据z的精度和四舍五入模式进行四舍五入。</target>
        </trans-unit>
        <trans-unit id="bf3bdba69c06f396d015a2e68cfa8b8e0dc2a553" translate="yes" xml:space="preserve">
          <source>If {{.}} is the innocuous word, `left`, then it can appear more widely,</source>
          <target state="translated">如果{{.}}是无害的词,&quot;左&quot;,那么它可以出现的范围更广。</target>
        </trans-unit>
        <trans-unit id="35dc1b1b93ecc62032ac0000d9cf5065af4bc463" translate="yes" xml:space="preserve">
          <source>IfNode represents an {{if}} action and its commands.</source>
          <target state="translated">IfNode表示一个{{if}}动作及其命令。</target>
        </trans-unit>
        <trans-unit id="a40a74611ce76ddfa9aec134c7c4d57d7e7d1a0b" translate="yes" xml:space="preserve">
          <source>Ignore causes the provided signals to be ignored. If they are received by the program, nothing will happen. Ignore undoes the effect of any prior calls to Notify for the provided signals. If no signals are provided, all incoming signals will be ignored.</source>
          <target state="translated">忽略导致所提供的信号被忽略。如果它们被程序接收,则不会发生任何事情。忽略会撤销之前对所提供信号的任何通知调用的效果。如果没有提供信号,所有传入的信号将被忽略。</target>
        </trans-unit>
        <trans-unit id="98d36857a614a1e009d79e216b4eb0d9115f0404" translate="yes" xml:space="preserve">
          <source>Ignored reports whether sig is currently ignored.</source>
          <target state="translated">Ignored报告sig当前是否被忽略。</target>
        </trans-unit>
        <trans-unit id="4d88a112acad4eaba636cd685d95e848e229a4fb" translate="yes" xml:space="preserve">
          <source>Ilogb returns the binary exponent of x as an integer.</source>
          <target state="translated">Ilogb以整数形式返回x的二进制指数。</target>
        </trans-unit>
        <trans-unit id="44e069a8f4a7e1ac23418ede1f9fbec843a967dd" translate="yes" xml:space="preserve">
          <source>Imag returns the imaginary part of x, which must be a numeric or unknown value. If x is Unknown, the result is Unknown.</source>
          <target state="translated">Imag 返回 x 的虚部,它必须是一个数值或未知值。如果x是未知值,结果是未知值。</target>
        </trans-unit>
        <trans-unit id="30d40b43edb0bdc3eabf2d534c36f9d06f964b6e" translate="yes" xml:space="preserve">
          <source>Image is a finite rectangular grid of color.Color values taken from a color model.</source>
          <target state="translated">图像是一个有限的矩形颜色网格.颜色值取自一个颜色模型。</target>
        </trans-unit>
        <trans-unit id="26d71317c3ede5b3f54e923608b8db6326957a5e" translate="yes" xml:space="preserve">
          <source>Image is an image.Image with a Set method to change a single pixel.</source>
          <target state="translated">Image是一个Image.Image,有一个Set方法来改变单个像素。</target>
        </trans-unit>
        <trans-unit id="b146748a0514484acff9fb056c40176e7e0d62af" translate="yes" xml:space="preserve">
          <source>Implementation restriction: The counting forms x{n,m}, x{n,}, and x{n} reject forms that create a minimum or maximum repetition count above 1000. Unlimited repetitions are not subject to this restriction.</source>
          <target state="translated">实施限制。计数表格x{n,m}、x{n,}和x{n}拒绝接受最小或最大重复数超过1000的表格。无限重复的形式不受此限制。</target>
        </trans-unit>
        <trans-unit id="75c9903908feb1732654db7dd3662c68681cf3c0" translate="yes" xml:space="preserve">
          <source>Implementations must not retain p.</source>
          <target state="translated">执行中不得保留p。</target>
        </trans-unit>
        <trans-unit id="baccfe949bd483e0aa453da0b286a6848971e885" translate="yes" xml:space="preserve">
          <source>Implementations of CookieJar must be safe for concurrent use by multiple goroutines.</source>
          <target state="translated">CookieJar的实现必须保证多个goroutine并发使用的安全。</target>
        </trans-unit>
        <trans-unit id="2496dd56381c55b51499d5f91502dcff20d2b771" translate="yes" xml:space="preserve">
          <source>Implementations of PublicSuffixList must be safe for concurrent use by multiple goroutines.</source>
          <target state="translated">PublicSuffixList的实现必须是安全的,可以被多个goroutine并发使用。</target>
        </trans-unit>
        <trans-unit id="f73bf070b6238c284ef7b4d02061d370d3bb9d34" translate="yes" xml:space="preserve">
          <source>Implementations of Read are discouraged from returning a zero byte count with a nil error, except when len(p) == 0. Callers should treat a return of 0 and nil as indicating that nothing happened; in particular it does not indicate EOF.</source>
          <target state="translated">不鼓励Read的实现以nil错误返回一个零字节数,除非len(p)==0.调用者应该将0和nil的返回视为表示什么都没有发生;特别是它不表示EOF。</target>
        </trans-unit>
        <trans-unit id="9c4eb58019f122cd6fcd79f868e42855509e5b17" translate="yes" xml:space="preserve">
          <source>Implementations of Token are discouraged from returning a nil token with a nil error. Callers should treat a return of nil, nil as indicating that nothing happened; in particular it does not indicate EOF.</source>
          <target state="translated">不鼓励Token的实现以nil错误返回一个nil token。调用者应该把返回nil、nil视为表示什么都没有发生;特别是它不表示EOF。</target>
        </trans-unit>
        <trans-unit id="3b31ef7323ed3ca421b9bab6f7dbaab32c7ce726" translate="yes" xml:space="preserve">
          <source>Implements reports whether type V implements interface T.</source>
          <target state="translated">Implements报告类型V是否实现了接口T。</target>
        </trans-unit>
        <trans-unit id="5ba5f70840c67e6a055ce04e03bb2454bb162d9f" translate="yes" xml:space="preserve">
          <source>Import is shorthand for Default.Import.</source>
          <target state="translated">Import是Default.Import的简写。</target>
        </trans-unit>
        <trans-unit id="6afc9b3e57abb6585be9561d376bdea28ca944ae" translate="yes" xml:space="preserve">
          <source>Import returns details about the Go package named by the import path, interpreting local import paths relative to the srcDir directory. If the path is a local import path naming a package that can be imported using a standard import path, the returned package will set p.ImportPath to that path.</source>
          <target state="translated">Import 返回由导入路径命名的 Go 包的详细信息,解释相对于 srcDir 目录的本地导入路径。如果路径是一个本地导入路径,命名了一个可以使用标准导入路径导入的包,那么返回的包将把p.ImportPath设置为该路径。</target>
        </trans-unit>
        <trans-unit id="93d88a517c9d75699c2e4045b6e3fc932cd88482" translate="yes" xml:space="preserve">
          <source>ImportDir is like Import but processes the Go package found in the named directory.</source>
          <target state="translated">ImportDir和Import一样,但处理的是在命名目录中找到的Go包。</target>
        </trans-unit>
        <trans-unit id="58d6f3af90d9fbc41be2c405bfa8615d93151250" translate="yes" xml:space="preserve">
          <source>ImportDir is shorthand for Default.ImportDir.</source>
          <target state="translated">ImportDir是Default.ImportDir的简写。</target>
        </trans-unit>
        <trans-unit id="2d321830ed77e3baaf4ac8b7f7efc36408c85002" translate="yes" xml:space="preserve">
          <source>ImportMode is reserved for future use.</source>
          <target state="translated">ImportMode是保留给将来使用的。</target>
        </trans-unit>
        <trans-unit id="81d5bfd42309b64b183f9701f930099193a14426" translate="yes" xml:space="preserve">
          <source>Imported returns the package that was imported. It is distinct from Pkg(), which is the package containing the import statement.</source>
          <target state="translated">Imported 返回被导入的包。它与Pkg()不同,Pkg()是包含导入语句的包。</target>
        </trans-unit>
        <trans-unit id="98f8e071166bb5be3aecf52c0312f3d8e38c742a" translate="yes" xml:space="preserve">
          <source>ImportedLibraries returns the names of all libraries referred to by the binary f that are expected to be linked with the binary at dynamic link time.</source>
          <target state="translated">ImportedLibraries返回二进制f所引用的所有库的名称,这些库预计将在动态链接时与二进制链接。</target>
        </trans-unit>
        <trans-unit id="6d0d053d5be94190ae4125e53a45e74c9bfff903" translate="yes" xml:space="preserve">
          <source>ImportedLibraries returns the paths of all libraries referred to by the binary f that are expected to be linked with the binary at dynamic link time.</source>
          <target state="translated">ImportedLibraries返回二进制f所引用的所有库的路径,这些库预计将在动态链接时与二进制链接。</target>
        </trans-unit>
        <trans-unit id="27f49356d80e117cb6ff37f13e3b8dc616e332cb" translate="yes" xml:space="preserve">
          <source>ImportedSymbols returns the names of all symbols referred to by the binary f that are expected to be satisfied by other libraries at dynamic load time.</source>
          <target state="translated">ImportedSymbols返回二进制f所引用的所有符号的名称,这些符号预计在动态加载时将被其他库满足。</target>
        </trans-unit>
        <trans-unit id="80301d15602072b275cf4e9d642684ee556fd2a0" translate="yes" xml:space="preserve">
          <source>ImportedSymbols returns the names of all symbols referred to by the binary f that are expected to be satisfied by other libraries at dynamic load time. It does not return weak symbols.</source>
          <target state="translated">ImportedSymbols返回二进制f所引用的所有符号的名称,这些符号预计在动态加载时将被其他库满足。它不返回弱符号。</target>
        </trans-unit>
        <trans-unit id="a7a177ffbe3a55cdc66a04d44c08bbd35566d366" translate="yes" xml:space="preserve">
          <source>Importing this package will increase the size of a program by about 450 KB.</source>
          <target state="translated">导入这个软件包会使程序的大小增加约450KB。</target>
        </trans-unit>
        <trans-unit id="d5940cf724f4e1c9daed64775970e063932394d8" translate="yes" xml:space="preserve">
          <source>Importing this package will increase the size of a program by about 800 KB.</source>
          <target state="translated">导入这个软件包会使程序的大小增加约800KB。</target>
        </trans-unit>
        <trans-unit id="75eb201c4952cde504ceda9eb34765cbfc018641" translate="yes" xml:space="preserve">
          <source>Imports returns the list of packages directly imported by pkg; the list is in source order.</source>
          <target state="translated">Imports 返回由 pkg 直接导入的软件包列表;该列表按源码顺序排列。</target>
        </trans-unit>
        <trans-unit id="cb7bc76d7380682c92ffb45e3be0edf510619c0c" translate="yes" xml:space="preserve">
          <source>In C syntax, this struct will be</source>
          <target state="translated">在C语言中,这个结构将是</target>
        </trans-unit>
        <trans-unit id="031e67b82062bc206ba16bfbb78969301350778f" translate="yes" xml:space="preserve">
          <source>In Go 1 and Go 1.1, each package produced one Obj for all Go sources and one Obj per C source file.</source>
          <target state="translated">在围棋1和围棋1.1中,每个包为所有围棋源产生一个Obj,每个C源文件产生一个Obj。</target>
        </trans-unit>
        <trans-unit id="f1a4145c4d681021c6b688a748d3fd850af7e56f" translate="yes" xml:space="preserve">
          <source>In Go 1.1 and earlier, each function (represented by a Func) had its own LineTable, and the line number corresponded to a numbering of all source lines in the program, across all files. That absolute line number would then have to be converted separately to a file name and line number within the file.</source>
          <target state="translated">在Go 1.1和更早的版本中,每个函数(用Func表示)都有自己的LineTable,行号对应的是程序中所有文件的所有源行的编号。那绝对的行号就必须分别转换为文件名和文件内的行号。</target>
        </trans-unit>
        <trans-unit id="35c4a15e4a2e0d9709fe9d9d2d8891336f5119ee" translate="yes" xml:space="preserve">
          <source>In Go 1.12 and earlier, it was possible to distribute packages in binary form without including the source code used for compiling the package. The package was distributed with a source file not excluded by build constraints and containing a &quot;//go:binary-only-package&quot; comment. Like a build constraint, this comment appeared at the top of a file, preceded only by blank lines and other line comments and with a blank line following the comment, to separate it from the package documentation. Unlike build constraints, this comment is only recognized in non-test Go source files.</source>
          <target state="translated">在Go 1.12和更早的版本中,可以发布二进制形式的包,而不包括用于编译包的源代码。软件包在发布的时候,有一个不被构建约束排除在外的源文件,并包含一个&quot;//go:binary-only-package &quot;的注释。和构建约束一样,这个注释出现在文件的顶部,前面只有空行和其他行注释,并且在注释后面有一行空行,以将其与软件包文档分开。与构建约束不同,这种注释只在非测试的围棋源文件中被识别。</target>
        </trans-unit>
        <trans-unit id="cc8775c16cc6c9f67e9f67d2c4b9b38bd2343802" translate="yes" xml:space="preserve">
          <source>In Go 1.2, the format of the data changed so that there is a single LineTable for the entire program, shared by all Funcs, and there are no absolute line numbers, just line numbers within specific files.</source>
          <target state="translated">在围棋1.2中,数据的格式发生了变化,整个程序只有一个LineTable,由所有Funcs共享,而且没有绝对的行号,只有特定文件内的行号。</target>
        </trans-unit>
        <trans-unit id="94c3f9b8a2f1195c43f29bc6d1587c741d49bcbe" translate="yes" xml:space="preserve">
          <source>In Go 1.2, there is a single Obj for the entire program.</source>
          <target state="translated">在Go 1.2中,整个程序只有一个Obj。</target>
        </trans-unit>
        <trans-unit id="fc1a1510c05c5e605f2bf42bab100aff6fd4f01e" translate="yes" xml:space="preserve">
          <source>In Printf, Sprintf, and Fprintf, the default behavior is for each formatting verb to format successive arguments passed in the call. However, the notation [n] immediately before the verb indicates that the nth one-indexed argument is to be formatted instead. The same notation before a '*' for a width or precision selects the argument index holding the value. After processing a bracketed expression [n], subsequent verbs will use arguments n+1, n+2, etc. unless otherwise directed.</source>
          <target state="translated">在Printf、Sprintf和Fprintf中,默认的行为是每个格式化动词对调用中传递的连续参数进行格式化。然而,紧靠在动词前的符号[n]表示第n个单索引参数将被格式化。在宽度或精度的'*'前也有同样的记号,表示选择持有该值的参数索引。在处理完括号内的表达式[n]后,除非另有指示,否则后续的动词将使用参数n+1、n+2等。</target>
        </trans-unit>
        <trans-unit id="6f69301b556dc9f571bc4bb3612422a63af49e86" translate="yes" xml:space="preserve">
          <source>In TLS 1.3, this type is called NamedGroup, but at this time this library only supports Elliptic Curve based groups. See RFC 8446, Section 4.2.7.</source>
          <target state="translated">在TLS 1.3中,这个类型被称为NamedGroup,但目前这个库只支持基于椭圆曲线的组。参见RFC 8446,4.2.7节。</target>
        </trans-unit>
        <trans-unit id="93a2aff531fe6a26d094463bdd12d8ce980726db" translate="yes" xml:space="preserve">
          <source>In a Go program that includes non-Go code, typically C/C++ code accessed using cgo or SWIG, Go's startup code normally runs first. It configures the signal handlers as expected by the Go runtime, before the non-Go startup code runs. If the non-Go startup code wishes to install its own signal handlers, it must take certain steps to keep Go working well. This section documents those steps and the overall effect changes to signal handler settings by the non-Go code can have on Go programs. In rare cases, the non-Go code may run before the Go code, in which case the next section also applies.</source>
          <target state="translated">在包含非围棋代码的围棋程序中,通常是使用 cgo 或 SWIG 访问的 C/C++代码,围棋的启动代码通常首先运行。在非 Go 启动代码运行之前,它会按照 Go 运行时的预期配置信号处理程序。如果非 Go 启动代码希望安装自己的信号处理程序,它必须采取一定的步骤来保证 Go 的良好工作。本节记录了这些步骤以及非围棋代码对信号处理程序设置的更改对围棋程序的总体影响。在极少数情况下,非围棋代码可能在围棋代码之前运行,在这种情况下,下一节也适用。</target>
        </trans-unit>
        <trans-unit id="b709a8b5c95be5a899a7612ec04af9fcd8c6fe68" translate="yes" xml:space="preserve">
          <source>In addition to adding the HTTP handler, this package registers the following variables:</source>
          <target state="translated">除了添加HTTP处理程序,这个包还注册了以下变量。</target>
        </trans-unit>
        <trans-unit id="c7232c786e65fae897885a5d1905f0858ffd2ae2" translate="yes" xml:space="preserve">
          <source>In addition to the required &amp;ldquo;wall clock&amp;rdquo; reading, a Time may contain an optional reading of the current process's monotonic clock, to provide additional precision for comparison or subtraction. See the &amp;ldquo;Monotonic Clocks&amp;rdquo; section in the package documentation for details.</source>
          <target state="translated">除了所需的&amp;ldquo;挂钟&amp;rdquo;读数外，&amp;ldquo;时间&amp;rdquo;还可以包含当前过程的单调时钟的可选读数，以提供更高的比较或减法精度。有关详细信息，请参见包装文档中的&amp;ldquo;单声道时钟&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="965439857efd394443e37d36ace60b7ac7d83473" translate="yes" xml:space="preserve">
          <source>In addition to the struct tags recognised by Unmarshal, the following can be used:</source>
          <target state="translated">除了Unmarshal识别的结构体标签外,还可以使用以下标签。</target>
        </trans-unit>
        <trans-unit id="d07fa607208161c419b4aff2675e4f243b41086c" translate="yes" xml:space="preserve">
          <source>In all other cases, Scan returns an empty literal string.</source>
          <target state="translated">在所有其他情况下,Scan都会返回一个空的字符串。</target>
        </trans-unit>
        <trans-unit id="dc451d8d43456b62826bda28dfbc96cdb2eb2524" translate="yes" xml:space="preserve">
          <source>In all the scanning functions, a carriage return followed immediately by a newline is treated as a plain newline (\r\n means the same as \n).</source>
          <target state="translated">在所有的扫描功能中,回车后紧接着的换行被视为普通的换行(/r/n的意思与/n相同)。</target>
        </trans-unit>
        <trans-unit id="fedccbf24f7f68d8101f599e3218a03c5ffaf765" translate="yes" xml:space="preserve">
          <source>In all the scanning functions, if an operand implements method Scan (that is, it implements the Scanner interface) that method will be used to scan the text for that operand. Also, if the number of arguments scanned is less than the number of arguments provided, an error is returned.</source>
          <target state="translated">在所有的扫描函数中,如果一个操作数实现了方法Scan(也就是实现了Scanner接口),那么该方法将被用来扫描该操作数的文本。另外,如果扫描的参数数小于提供的参数数,则返回错误。</target>
        </trans-unit>
        <trans-unit id="a1bf502195aaabff9af8feae702eb1ba2c806b3d" translate="yes" xml:space="preserve">
          <source>In an ErrorList, an error is represented by an *Error. The position Pos, if valid, points to the beginning of the offending token, and the error condition is described by Msg.</source>
          <target state="translated">在ErrorList中,错误由*Error表示。如果位置Pos有效,则指向违规标记的开头,错误条件由Msg描述。</target>
        </trans-unit>
        <trans-unit id="c43ce5959f73c41a703ce648d64371023d38a1e1" translate="yes" xml:space="preserve">
          <source>In early versions of Go each source file became a different Obj.</source>
          <target state="translated">在Go的早期版本中,每个源文件都变成了一个不同的Obj。</target>
        </trans-unit>
        <trans-unit id="42a68547a9dca9735cb7eba8147953340f09b72e" translate="yes" xml:space="preserve">
          <source>In effect, the method must look schematically like</source>
          <target state="translated">实际上,该方法的原理必须是这样的</target>
        </trans-unit>
        <trans-unit id="b72051420981768a1127b1640516d07dc80b1c1a" translate="yes" xml:space="preserve">
          <source>In general DeepEqual is a recursive relaxation of Go's == operator. However, this idea is impossible to implement without some inconsistency. Specifically, it is possible for a value to be unequal to itself, either because it is of func type (uncomparable in general) or because it is a floating-point NaN value (not equal to itself in floating-point comparison), or because it is an array, struct, or interface containing such a value. On the other hand, pointer values are always equal to themselves, even if they point at or contain such problematic values, because they compare equal using Go's == operator, and that is a sufficient condition to be deeply equal, regardless of content. DeepEqual has been defined so that the same short-cut applies to slices and maps: if x and y are the same slice or the same map, they are deeply equal regardless of content.</source>
          <target state="translated">一般来说,DeepEqual是Go的==运算符的递归放松。然而,这个想法不可能在没有一些不一致的情况下实现。具体来说,一个值有可能与自己不相等,要么是因为它是func类型(一般情况下不可比较),要么是因为它是一个浮点NaN值(在浮点比较中不等于自己),要么是因为它是一个包含这种值的数组、结构或接口。另一方面,指针值总是与自己相等,即使它指向或包含这样的问题值,因为它们使用Go的==运算符进行比较相等,这就是深度相等的充分条件,无论内容如何。DeepEqual的定义使得同样的捷径适用于切片和地图:如果x和y是同一个切片或同一个地图,那么无论内容如何,它们都是深度相等的。</target>
        </trans-unit>
        <trans-unit id="07b960c708d879d40875264c73a08a0683383d6b" translate="yes" xml:space="preserve">
          <source>In general, a given attribute's value may take on one of several possible classes defined by DWARF, each of which leads to a slightly different interpretation of the attribute.</source>
          <target state="translated">一般来说,一个给定属性的值可以采用DWARF定义的几种可能的类别之一,每种类别都会导致对属性的解释略有不同。</target>
        </trans-unit>
        <trans-unit id="2e9ecaaf397056078378f799dda9c4e1072c7928" translate="yes" xml:space="preserve">
          <source>In general, a gzip file can be a concatenation of gzip files, each with its own header. Reads from the Reader return the concatenation of the uncompressed data of each. Only the first header is recorded in the Reader fields.</source>
          <target state="translated">一般情况下,一个gzip文件可以是一个gzip文件的连接,每个文件都有自己的头。从Reader中读取的数据会返回每个文件的未压缩数据的连接。Reader字段中只记录第一个头。</target>
        </trans-unit>
        <trans-unit id="b6ffd0a95c8557850de7ace105d0c02e95a18d70" translate="yes" xml:space="preserve">
          <source>In general, if allocation is required, the decoder will allocate memory. If not, it will update the destination variables with values read from the stream. It does not initialize them first, so if the destination is a compound value such as a map, struct, or slice, the decoded values will be merged elementwise into the existing variables.</source>
          <target state="translated">一般来说,如果需要分配,解码器将分配内存。如果不需要,它将用从流中读取的值更新目标变量。它不会先初始化它们,所以如果目标变量是一个复合值,如map、struct或slice,那么解码后的值将被元素式地合并到现有的变量中。</target>
        </trans-unit>
        <trans-unit id="d1a73603a88217147c68ec9c324a3f4cba1ebddc" translate="yes" xml:space="preserve">
          <source>In general, reflect.SliceHeader and reflect.StringHeader should be used only as *reflect.SliceHeader and *reflect.StringHeader pointing at actual slices or strings, never as plain structs. A program should not declare or allocate variables of these struct types.</source>
          <target state="translated">一般来说,reflect.SliceHeader和reflect.StringHeader只能作为*reflect.SliceHeader和*reflect.StringHeader指向实际的切片或字符串,决不能作为普通结构使用。程序不应该声明或分配这些结构类型的变量。</target>
        </trans-unit>
        <trans-unit id="99dc4b6fd44a858b786d20b64de92f5f16319ca0" translate="yes" xml:space="preserve">
          <source>In general, the GHASH operation performed by this implementation of GCM is not constant-time. An exception is when the underlying Block was created by aes.NewCipher on systems with hardware support for AES. See the crypto/aes package documentation for details.</source>
          <target state="translated">一般来说,GCM的这个实现所执行的GHASH操作不是恒时的。一个例外的情况是,在对AES有硬件支持的系统上,底层Block是由aes.NewCipher创建的。详情请参见 crypto/aes 软件包文档。</target>
        </trans-unit>
        <trans-unit id="63a94d50c6e71995bfdddbf6d3b7ddbbd572fca1" translate="yes" xml:space="preserve">
          <source>In most cases, new(Buffer) (or just declaring a Buffer variable) is sufficient to initialize a Buffer.</source>
          <target state="translated">在大多数情况下,new(Buffer)(或者仅仅声明一个Buffer变量)就足以初始化一个Buffer。</target>
        </trans-unit>
        <trans-unit id="ce6abe6e4a1757599621f3d92af6850089e3e51d" translate="yes" xml:space="preserve">
          <source>In non-HTML settings where the escaping interferes with the readability of the output, SetEscapeHTML(false) disables this behavior.</source>
          <target state="translated">在非HTML设置中,如果转义会影响输出的可读性,SetEscapeHTML(false)会禁止这种行为。</target>
        </trans-unit>
        <trans-unit id="7077ca93ebf4ef49120708550f14d220620ccf80" translate="yes" xml:space="preserve">
          <source>In panics if loc is nil.</source>
          <target state="translated">在慌乱中,如果loc为零。</target>
        </trans-unit>
        <trans-unit id="f52d38c87623b45c8b7767cba23884c87bb2c3a8" translate="yes" xml:space="preserve">
          <source>In particular, it implements LZW as used by the GIF and PDF file formats, which means variable-width codes up to 12 bits and the first two non-literal codes are a clear code and an EOF code.</source>
          <target state="translated">特别是,它实现了GIF和PDF文件格式所使用的LZW,也就是可变宽度码,最高可达12位,前两个非文字码是一个清码和一个EOF码。</target>
        </trans-unit>
        <trans-unit id="4026aa85ef00c786dfe0c796e4b667cd2644b68d" translate="yes" xml:space="preserve">
          <source>In performance critical applications, Reset can be used to discard the current compressor or decompressor state and reinitialize them quickly by taking advantage of previously allocated memory.</source>
          <target state="translated">在对性能要求很高的应用中,Reset可以用来丢弃当前的压缩器或解压缩器状态,并利用之前分配的内存快速重新初始化它们。</target>
        </trans-unit>
        <trans-unit id="6db233d0c99db26b8c12c611c05604abfea98d46" translate="yes" xml:space="preserve">
          <source>In reports whether every point in r is in s.</source>
          <target state="translated">在报告r中的每一点是否在s中。</target>
        </trans-unit>
        <trans-unit id="84fe4eae8d319a1913e35010d51f1271fd7ded56" translate="yes" xml:space="preserve">
          <source>In reports whether p is in r.</source>
          <target state="translated">在报告p是否在r。</target>
        </trans-unit>
        <trans-unit id="0fd55e418f00485b3f2efc5b428b0418b6a94be8" translate="yes" xml:space="preserve">
          <source>In reports whether the rune is a member of one of the ranges.</source>
          <target state="translated">在报告该符文是否是其中一个范围的成员。</target>
        </trans-unit>
        <trans-unit id="472b3dea5785c77ec21b439277ea93730e47a2be" translate="yes" xml:space="preserve">
          <source>In returns a copy of t representing the same time instant, but with the copy's location information set to loc for display purposes.</source>
          <target state="translated">In 返回t的副本,代表相同的时间瞬间,但为了显示的目的,副本的位置信息设置为loc。</target>
        </trans-unit>
        <trans-unit id="711d8c9ceb05e3476e4192e2fd5e66ccc3b3ba1b" translate="yes" xml:space="preserve">
          <source>In slices and arrays, as well as maps, all elements, even zero-valued elements, are transmitted, even if all the elements are zero.</source>
          <target state="translated">在切片和数组以及地图中,所有元素,甚至是零值元素,都会被传输,即使所有元素都是零。</target>
        </trans-unit>
        <trans-unit id="9f17f1b7292d381dce79c4e2b9b83d7f1d5da96e" translate="yes" xml:space="preserve">
          <source>In summary, a gob stream looks like</source>
          <target state="translated">总的来说,一个gob流看起来像</target>
        </trans-unit>
        <trans-unit id="2d78ddedbd337c0bea6888e7055a4838325b74f8" translate="yes" xml:space="preserve">
          <source>In the $name form, name is taken to be as long as possible: $1x is equivalent to ${1x}, not ${1}x, and, $10 is equivalent to ${10}, not ${1}0.</source>
          <target state="translated">在$name形式中,name取的时间越长越好:$1x相当于${1x},而不是${1}x,而且,$10相当于${10},而不是${1}0。</target>
        </trans-unit>
        <trans-unit id="37a0ec0d20103e0c83570c4610c7755ff7ac53c0" translate="yes" xml:space="preserve">
          <source>In the absence of a time zone indicator, Parse returns a time in UTC.</source>
          <target state="translated">在没有时区指示的情况下,Parsse返回的是UTC时间。</target>
        </trans-unit>
        <trans-unit id="b029486adc899e6b2e4bce186582f459ceb89a34" translate="yes" xml:space="preserve">
          <source>In the directory containing the package, .go, .c, .h, and .s files are considered part of the package except for:</source>
          <target state="translated">在包含包的目录中,.go、.c、.h和.s文件被认为是包的一部分,除了。</target>
        </trans-unit>
        <trans-unit id="fa1c6c88c18a52fe6d2731df7b2ac739dc65317f" translate="yes" xml:space="preserve">
          <source>In the format string, a verb introduced by the % character consumes and parses input; these verbs are described in more detail below. A character other than %, space, or newline in the format consumes exactly that input character, which must be present. A newline with zero or more spaces before it in the format string consumes zero or more spaces in the input followed by a single newline or the end of the input. A space following a newline in the format string consumes zero or more spaces in the input. Otherwise, any run of one or more spaces in the format string consumes as many spaces as possible in the input. Unless the run of spaces in the format string appears adjacent to a newline, the run must consume at least one space from the input or find the end of the input.</source>
          <target state="translated">在格式字符串中,由%字符引入的动词会消耗和解析输入;这些动词在下面会有更详细的描述。格式中除%、空格或换行以外的字符正好消耗该输入字符,该字符必须存在。格式字符串中换行前有零个或更多的空格,会消耗输入中零个或更多的空格,然后是单个换行或输入的结束。格式字符串中换行后的空格会消耗输入中零个或更多的空格。否则,格式字符串中任何一个或多个空格的运行都会消耗输入中尽可能多的空格。除非格式字符串中的空格与换行相邻,否则必须从输入中至少消耗一个空格或找到输入的结尾。</target>
        </trans-unit>
        <trans-unit id="ed1a2050a365f5d52ef37144115d11517ff42bc2" translate="yes" xml:space="preserve">
          <source>In the most simple case, if the type of the value from the source column is an integer, bool or string type T and dest is of type *T, Scan simply assigns the value through the pointer.</source>
          <target state="translated">在最简单的情况下,如果来自源列的值的类型是整数、布尔或字符串类型T,而dest的类型是*T,Scan就会简单地通过指针赋值。</target>
        </trans-unit>
        <trans-unit id="5c811352496639bcd7be1278e40839e6992f883a" translate="yes" xml:space="preserve">
          <source>In the second form, the following rules apply:</source>
          <target state="translated">在第二种形式中,适用以下规则:</target>
        </trans-unit>
        <trans-unit id="9ca6beb2058ca8ef81c9dbee1705e13b3578af1f" translate="yes" xml:space="preserve">
          <source>In the template, a variable is denoted by a substring of the form $name or ${name}, where name is a non-empty sequence of letters, digits, and underscores. A purely numeric name like $1 refers to the submatch with the corresponding index; other names refer to capturing parentheses named with the (?P&amp;lt;name&amp;gt;...) syntax. A reference to an out of range or unmatched index or a name that is not present in the regular expression is replaced with an empty slice.</source>
          <target state="translated">在模板中，变量由$ name或$ {name}形式的子字符串表示，其中name是字母，数字和下划线的非空序列。像$ 1这样的纯数字名称表示具有相应索引的子匹配；其他名称是指捕获用（？P &amp;lt;name&amp;gt; ...）语法命名的括号。对超出范围或不匹配的索引的引用或在正则表达式中不存在的名称将替换为空切片。</target>
        </trans-unit>
        <trans-unit id="5a1c160af25c73f96bab58b7ac18692fbbe1ffa1" translate="yes" xml:space="preserve">
          <source>In the terminology of the zlib library, Flush is equivalent to Z_SYNC_FLUSH.</source>
          <target state="translated">在zlib库的术语中,Flush相当于Z_SYNC_FLUSH。</target>
        </trans-unit>
        <trans-unit id="2dd7b02fa4aa241d6b5f4aad090e1521eaf7af73" translate="yes" xml:space="preserve">
          <source>In this usage hdr.Data is really an alternate way to refer to the underlying pointer in the string header, not a uintptr variable itself.</source>
          <target state="translated">在这种用法中,hdr.Data实际上是字符串头中引用底层指针的另一种方式,而不是uintptr变量本身。</target>
        </trans-unit>
        <trans-unit id="b66dfbc84a8b6f209be163efb64c95ba40440449" translate="yes" xml:space="preserve">
          <source>InUseBytes returns the number of bytes in use (AllocBytes - FreeBytes).</source>
          <target state="translated">InUseBytes 返回使用中的字节数(AllocBytes-FreeBytes)。</target>
        </trans-unit>
        <trans-unit id="d6ed56286846a6cf59f0baa7c19dd1836590eeba" translate="yes" xml:space="preserve">
          <source>InUseObjects returns the number of objects in use (AllocObjects - FreeObjects).</source>
          <target state="translated">InUseObjects 返回正在使用的对象数量(AllocObjects-FreeObjects)。</target>
        </trans-unit>
        <trans-unit id="dfe141017385b1d5692d01442e77119d4a1ae1e2" translate="yes" xml:space="preserve">
          <source>Incoming requests to a server should create a Context, and outgoing calls to servers should accept a Context. The chain of function calls between them must propagate the Context, optionally replacing it with a derived Context created using WithCancel, WithDeadline, WithTimeout, or WithValue. When a Context is canceled, all Contexts derived from it are also canceled.</source>
          <target state="translated">对服务器的传入请求应该创建一个上下文,对服务器的传出调用应该接受一个上下文。它们之间的函数调用链必须传播Context,可选择用WithCancel、WithDeadline、WithTimeout或WithValue创建的派生Context替换它。当一个上下文被取消时,所有由它派生的上下文也被取消。</target>
        </trans-unit>
        <trans-unit id="f3527c443ffc9a19a79c9a5af60b69f82dd615d1" translate="yes" xml:space="preserve">
          <source>IncorrectPasswordError is returned when an incorrect password is detected.</source>
          <target state="translated">当检测到错误的密码时,将返回IncorrectPasswordError。</target>
        </trans-unit>
        <trans-unit id="aacf42132cce6cf5c1608a5d27f90fcbf93ae851" translate="yes" xml:space="preserve">
          <source>Indent</source>
          <target state="translated">Indent</target>
        </trans-unit>
        <trans-unit id="ffaaf5870213dda02bfcfd6086cb6c73c505917c" translate="yes" xml:space="preserve">
          <source>Indent appends to dst an indented form of the JSON-encoded src. Each element in a JSON object or array begins on a new, indented line beginning with prefix followed by one or more copies of indent according to the indentation nesting. The data appended to dst does not begin with the prefix nor any indentation, to make it easier to embed inside other formatted JSON data. Although leading space characters (space, tab, carriage return, newline) at the beginning of src are dropped, trailing space characters at the end of src are preserved and copied to dst. For example, if src has no trailing spaces, neither will dst; if src ends in a trailing newline, so will dst.</source>
          <target state="translated">缩进将JSON编码的src的缩进形式附加到dst。JSON 对象或数组中的每个元素都从新的缩进行开始,从前缀开始,根据缩进嵌套,后面是一个或多个缩进副本。附加到 dst 的数据不以前缀或任何缩进开始,以便更容易嵌入其他格式化的 JSON 数据中。虽然src开头的前导空格字符(空格、tab、回车、换行)会被删除,但src结尾的尾部空格字符会被保留并复制到dst。例如,如果 src 没有尾部空格,dst 也不会;如果 src 以尾部换行结束,dst 也会保留。</target>
        </trans-unit>
        <trans-unit id="68e20af4dfa7d94d1e8e99b5a45a2168cf2653cc" translate="yes" xml:space="preserve">
          <source>Indent sets the encoder to generate XML in which each element begins on a new indented line that starts with prefix and is followed by one or more copies of indent according to the nesting depth.</source>
          <target state="translated">缩进设置编码器生成XML,其中每个元素都从一个新的缩进行开始,该行以前缀开始,并根据嵌套深度跟随一个或多个缩进副本。</target>
        </trans-unit>
        <trans-unit id="c2df9b932637fe9d32a0f16da1c11873398f873d" translate="yes" xml:space="preserve">
          <source>Index</source>
          <target state="translated">Index</target>
        </trans-unit>
        <trans-unit id="421722312ce68c9bf9eb41def321649c4712dbd6" translate="yes" xml:space="preserve">
          <source>Index describes the path from x to f in x.f. The last index entry is the field or method index of the type declaring f; either:</source>
          <target state="translated">索引描述了x.f中从x到f的路径,最后一个索引条目是声明f的类型的字段或方法索引;无论是。</target>
        </trans-unit>
        <trans-unit id="1d0b49853e61d44f4f8b07282b1903e9f2bc5158" translate="yes" xml:space="preserve">
          <source>Index implements a suffix array for fast substring search.</source>
          <target state="translated">Index实现了一个后缀数组,用于快速的子串搜索。</target>
        </trans-unit>
        <trans-unit id="af573efacc3f6c1539d934e082a33b7c5805e74a" translate="yes" xml:space="preserve">
          <source>Index responds with the pprof-formatted profile named by the request. For example, &quot;/debug/pprof/heap&quot; serves the &quot;heap&quot; profile. Index responds to a request for &quot;/debug/pprof/&quot; with an HTML page listing the available profiles.</source>
          <target state="translated">Index用请求命名的pprof格式的配置文件来响应。例如,&quot;/debug/pprof/heap &quot;提供 &quot;堆 &quot;配置文件。Index用一个列出可用配置文件的HTML页面来响应对&quot;/debug/pprof/&quot;的请求。</target>
        </trans-unit>
        <trans-unit id="fd5b04a55e6c188f04225c052c3a4ebb3eecf806" translate="yes" xml:space="preserve">
          <source>Index returns JavaScript index i of value v. It panics if v is not a JavaScript object.</source>
          <target state="translated">Index返回值v的JavaScript索引i,如果v不是JavaScript对象,它就会恐慌。</target>
        </trans-unit>
        <trans-unit id="41cc91c9bcf3f0a08fb627d21f4a77281aee4bad" translate="yes" xml:space="preserve">
          <source>Index returns the index of the first instance of sep in s, or -1 if sep is not present in s.</source>
          <target state="translated">Index返回s中sep的第一个实例的索引,如果s中没有sep,则返回-1。</target>
        </trans-unit>
        <trans-unit id="1f02d6f4db0fe2bb71d169a720ea48dacd4410f7" translate="yes" xml:space="preserve">
          <source>Index returns the index of the first instance of substr in s, or -1 if substr is not present in s.</source>
          <target state="translated">Index 返回 s 中 substr 的第一个实例的索引,如果 s 中不存在 substr,则返回-1。</target>
        </trans-unit>
        <trans-unit id="6672a7ad3732041777afcc9d59e94790fa08598a" translate="yes" xml:space="preserve">
          <source>Index returns the index of the palette color closest to c in Euclidean R,G,B,A space.</source>
          <target state="translated">Index 返回欧氏R,G,B,A空间中最接近c的调色板颜色的索引。</target>
        </trans-unit>
        <trans-unit id="08cc5090355bf36192f88d52e3809f63b35b1be3" translate="yes" xml:space="preserve">
          <source>Index returns v's i'th element. It panics if v's Kind is not Array, Slice, or String or i is out of range.</source>
          <target state="translated">Index返回v的第i个元素。如果v的Kind不是Array,Slice,或String,或者i超出了范围,它就会惊慌失措。</target>
        </trans-unit>
        <trans-unit id="f604fe204d59450e53c6f0f981bb463a3da262fc" translate="yes" xml:space="preserve">
          <source>Index.Lookup</source>
          <target state="translated">Index.Lookup</target>
        </trans-unit>
        <trans-unit id="693f6afea6d2763baec63c4f683ab836809a8526" translate="yes" xml:space="preserve">
          <source>IndexAny</source>
          <target state="translated">IndexAny</target>
        </trans-unit>
        <trans-unit id="227cd6f0abdfd091813bf35b8fd1dcfbc25cecd9" translate="yes" xml:space="preserve">
          <source>IndexAny interprets s as a sequence of UTF-8-encoded Unicode code points. It returns the byte index of the first occurrence in s of any of the Unicode code points in chars. It returns -1 if chars is empty or if there is no code point in common.</source>
          <target state="translated">IndexAny将s解释为一个UTF-8编码的Unicode码点序列。它返回s中任何一个Unicode码点在chars中首次出现的字节索引。如果chars为空或没有共同的码点,它返回-1。</target>
        </trans-unit>
        <trans-unit id="1adf36d0e196212f2787325e2cb626ccc3228c3b" translate="yes" xml:space="preserve">
          <source>IndexAny returns the index of the first instance of any Unicode code point from chars in s, or -1 if no Unicode code point from chars is present in s.</source>
          <target state="translated">IndexAny返回s中任何来自chars的Unicode码点的第一个实例的索引,如果s中没有来自chars的Unicode码点,则返回-1。</target>
        </trans-unit>
        <trans-unit id="91d007c3332e259ec2e02f981423ecacc90c6ee6" translate="yes" xml:space="preserve">
          <source>IndexByte</source>
          <target state="translated">IndexByte</target>
        </trans-unit>
        <trans-unit id="c4f06e8f47e53dedfca453887d03a95ac035b5de" translate="yes" xml:space="preserve">
          <source>IndexByte returns the index of the first instance of c in b, or -1 if c is not present in b.</source>
          <target state="translated">IndexByte返回b中c的第一个实例的索引,如果b中没有c,则返回-1。</target>
        </trans-unit>
        <trans-unit id="c369952c4d2f42c9a51eabe33a7908d4c8f60ad4" translate="yes" xml:space="preserve">
          <source>IndexByte returns the index of the first instance of c in s, or -1 if c is not present in s.</source>
          <target state="translated">IndexByte返回s中c的第一个实例的索引,如果s中没有c,则返回-1。</target>
        </trans-unit>
        <trans-unit id="4b29f4c46fd4242b96d7f6d96005476262ea25b4" translate="yes" xml:space="preserve">
          <source>IndexFunc</source>
          <target state="translated">IndexFunc</target>
        </trans-unit>
        <trans-unit id="fd5aa7f0734b2b2162a12de708cba7a93a1ba269" translate="yes" xml:space="preserve">
          <source>IndexFunc interprets s as a sequence of UTF-8-encoded code points. It returns the byte index in s of the first Unicode code point satisfying f(c), or -1 if none do.</source>
          <target state="translated">IndexFunc 将 s 解释为一个 UTF-8 编码的码点序列,它返回 s 中第一个满足 f(c)的 Unicode 码点的字节索引,如果没有,则返回 -1。它返回s中第一个满足f(c)的Unicode码点的字节索引,如果没有,则返回-1。</target>
        </trans-unit>
        <trans-unit id="67453fcd073346734a7503bb3d4207a4ffac0a81" translate="yes" xml:space="preserve">
          <source>IndexFunc returns the index into s of the first Unicode code point satisfying f(c), or -1 if none do.</source>
          <target state="translated">IndexFunc返回第一个满足f(c)的Unicode码点在s中的索引,如果没有,则返回-1。</target>
        </trans-unit>
        <trans-unit id="0404886738141ffe45c4d013ff978a64bde2ba63" translate="yes" xml:space="preserve">
          <source>IndexRune</source>
          <target state="translated">IndexRune</target>
        </trans-unit>
        <trans-unit id="f4318ccac75e1dd461aaa7a9c7842e97a421edce" translate="yes" xml:space="preserve">
          <source>IndexRune interprets s as a sequence of UTF-8-encoded code points. It returns the byte index of the first occurrence in s of the given rune. It returns -1 if rune is not present in s. If r is utf8.RuneError, it returns the first instance of any invalid UTF-8 byte sequence.</source>
          <target state="translated">IndexRune将s解释为一个UTF-8编码的代码点序列。它返回s中首次出现的给定符文的字节索引,如果s中没有符文,则返回-1。如果r是utf8.RuneError,它返回任何无效的UTF-8字节序列的第一个实例。</target>
        </trans-unit>
        <trans-unit id="042bb768e6a79fc4f2a8939cb46f8d887178fb46" translate="yes" xml:space="preserve">
          <source>IndexRune returns the index of the first instance of the Unicode code point r, or -1 if rune is not present in s. If r is utf8.RuneError, it returns the first instance of any invalid UTF-8 byte sequence.</source>
          <target state="translated">IndexRune返回Unicode码点r的第一个实例的索引,如果s中没有Rune,则返回-1,如果r是utf8.RuneError,则返回任何无效UTF-8字节序列的第一个实例。</target>
        </trans-unit>
        <trans-unit id="a85d156f8eef16ea6fae8f47130c09e7ab738f38" translate="yes" xml:space="preserve">
          <source>Indexes into the Header.Ident array.</source>
          <target state="translated">索引进入Header.Ident数组。</target>
        </trans-unit>
        <trans-unit id="bee82bdb7da751fd64eea7f5143956992f5aed77" translate="yes" xml:space="preserve">
          <source>Indices into the Delta arrays inside CaseRanges for case mapping.</source>
          <target state="translated">指向CaseRanges内部的Delta数组,用于案例映射。</target>
        </trans-unit>
        <trans-unit id="22023c8031bf3535a364147cd1c4ebacba51eca8" translate="yes" xml:space="preserve">
          <source>Indirect reports whether any pointer indirection was required to get from x to f in x.f.</source>
          <target state="translated">间接报告在x.f中从x到f是否需要任何指针间接。</target>
        </trans-unit>
        <trans-unit id="1dbf2dfd2ac6c93be252e418d12775d2db6f53d8" translate="yes" xml:space="preserve">
          <source>Indirect returns the value that v points to. If v is a nil pointer, Indirect returns a zero Value. If v is not a pointer, Indirect returns v.</source>
          <target state="translated">间接返回v所指向的值,如果v是一个无指针,间接返回一个零值。如果v是一个nil指针,Indirect返回一个零值。如果v不是指针,Indirect返回v。</target>
        </trans-unit>
        <trans-unit id="fe7ad1fbee745b4ca3d08d7729476db7d9fb4fe9" translate="yes" xml:space="preserve">
          <source>Inf returns a complex infinity, complex(+Inf, +Inf).</source>
          <target state="translated">Inf返回一个复数无穷大,complex(+Inf,+Inf)。</target>
        </trans-unit>
        <trans-unit id="0125073a5f3757f1dc62bea262918d4c5b3bae8e" translate="yes" xml:space="preserve">
          <source>Inf returns positive infinity if sign &amp;gt;= 0, negative infinity if sign &amp;lt; 0.</source>
          <target state="translated">如果符号&amp;gt; = 0，则Inf返回正无穷大；如果符号&amp;lt;0，则Inf返回负无穷大。</target>
        </trans-unit>
        <trans-unit id="fd7feb1c61f7423453cbee79d9998496c4df75f3" translate="yes" xml:space="preserve">
          <source>Infinite recursion can also be triggered by self-referential data structures, such as a slice that contains itself as an element, if that type has a String method. Such pathologies are rare, however, and the package does not protect against them.</source>
          <target state="translated">无限递归也可以由自引用的数据结构触发,比如一个包含自己作为元素的分片,如果该类型有一个String方法的话。然而,这种病态是罕见的,而且该包并没有对其进行保护。</target>
        </trans-unit>
        <trans-unit id="4b631f69842530d659306c8f06dbad594a6b1807" translate="yes" xml:space="preserve">
          <source>Info</source>
          <target state="translated">Info</target>
        </trans-unit>
        <trans-unit id="0e2ca261be59b2db86de1819fd95c5c62808d215" translate="yes" xml:space="preserve">
          <source>Info holds result type information for a type-checked package. Only the information for which a map is provided is collected. If the package has type errors, the collected information may be incomplete.</source>
          <target state="translated">Info保存了类型检查包的结果类型信息。只有提供了映射的信息才会被收集。如果包有类型错误,那么收集的信息可能是不完整的。</target>
        </trans-unit>
        <trans-unit id="829a6f4d1b71214eb93db4bdc76fb1b790f4e5d1" translate="yes" xml:space="preserve">
          <source>Info logs a message with severity LOG_INFO, ignoring the severity passed to New.</source>
          <target state="translated">Info会记录一条严重性为LOG_INFO的消息,忽略传递给New的严重性。</target>
        </trans-unit>
        <trans-unit id="d0968061a8aa60c3762f0e765c2376d0827896c3" translate="yes" xml:space="preserve">
          <source>Info returns information about properties of basic type b.</source>
          <target state="translated">Info返回基本类型b的属性信息。</target>
        </trans-unit>
        <trans-unit id="4bebef89f6713b109d9329a6bfe51cba5fd0be4f" translate="yes" xml:space="preserve">
          <source>Init establishes the heap invariants required by the other routines in this package. Init is idempotent with respect to the heap invariants and may be called whenever the heap invariants may have been invalidated. The complexity is O(n) where n = h.Len().</source>
          <target state="translated">Init建立了这个包中其他例程所需要的堆不变量。Init相对于堆不变量来说是幂等的,并且可以在堆不变量失效的时候被调用。其复杂度为O(n),其中n=h.Len()。</target>
        </trans-unit>
        <trans-unit id="e025530212d94f43014839edcd8664101cb1d082" translate="yes" xml:space="preserve">
          <source>Init has no effect if it was already called.</source>
          <target state="translated">如果已经被调用,Init没有任何效果。</target>
        </trans-unit>
        <trans-unit id="ab8a6a690d98493f29c3a7eded17da06a0fe4963" translate="yes" xml:space="preserve">
          <source>Init initializes a Scanner with a new source and returns s. Error is set to nil, ErrorCount is set to 0, Mode is set to GoTokens, and Whitespace is set to GoWhitespace.</source>
          <target state="translated">Init 用新的源初始化 Scanner 并返回 s。Error 设置为 nil,ErrorCount 设置为 0,Mode 设置为 GoTokens,Whitespace 设置为 GoWhitespace。</target>
        </trans-unit>
        <trans-unit id="38f2f0576d19cc2c5fa27415d0b566e72a9f5fcc" translate="yes" xml:space="preserve">
          <source>Init initializes or clears list l.</source>
          <target state="translated">Init初始化或清除列表l。</target>
        </trans-unit>
        <trans-unit id="4828f42508fc3abcabc5d7577bba28e3151a2a20" translate="yes" xml:space="preserve">
          <source>Init prepares the scanner s to tokenize the text src by setting the scanner at the beginning of src. The scanner uses the file set file for position information and it adds line information for each line. It is ok to re-use the same file when re-scanning the same file as line information which is already present is ignored. Init causes a panic if the file size does not match the src size.</source>
          <target state="translated">Init通过在src的开头设置扫描器来准备扫描器s对文本src进行标记。扫描仪使用文件集文件作为位置信息,并为每行添加行信息。当重新扫描同一个文件时,可以重新使用同一个文件,因为已经存在的行信息会被忽略。如果文件大小与 src 大小不匹配,Init 会引起恐慌。</target>
        </trans-unit>
        <trans-unit id="1ff5728fd1958fa03cc23f0615bd53c6b8512d71" translate="yes" xml:space="preserve">
          <source>Init registers testing flags. These flags are automatically registered by the &quot;go test&quot; command before running test functions, so Init is only needed when calling functions such as Benchmark without using &quot;go test&quot;.</source>
          <target state="translated">Init注册了测试标志,这些标志在运行测试函数之前由 &quot;go test &quot;命令自动注册。在运行测试函数之前,这些标志由 &quot;go test &quot;命令自动注册,所以只有在不使用 &quot;go test &quot;而调用Benchmark等函数时才需要Init。</target>
        </trans-unit>
        <trans-unit id="e71fb65b44dd31464c3ab6d5dc9c1b767849af42" translate="yes" xml:space="preserve">
          <source>Init removes all keys from the map.</source>
          <target state="translated">Init从地图中删除所有键。</target>
        </trans-unit>
        <trans-unit id="2f9d5d06290960b800b664c463e2749afea3e374" translate="yes" xml:space="preserve">
          <source>Init sets the name and error handling property for a flag set. By default, the zero FlagSet uses an empty name and the ContinueOnError error handling policy.</source>
          <target state="translated">Init为一个标志集设置名称和错误处理属性,默认情况下,零标志集使用空名称和ContinueOnError错误处理策略。默认情况下,零标志集使用空名和ContinueOnError错误处理策略。</target>
        </trans-unit>
        <trans-unit id="1ff277aa8c5f044965228237465cbaf43a54dec6" translate="yes" xml:space="preserve">
          <source>Initial magic number for ELF files.</source>
          <target state="translated">ELF文件的初始魔数。</target>
        </trans-unit>
        <trans-unit id="7ceb1ca1dad4f40542d5a478441bc59f2f8873ca" translate="yes" xml:space="preserve">
          <source>Innermost returns the innermost (child) scope containing pos. If pos is not within any scope, the result is nil. The result is also nil for the Universe scope. The result is guaranteed to be valid only if the type-checked AST has complete position information.</source>
          <target state="translated">Innermost 返回包含 pos 的最内部(子)作用域。如果 pos 不在任何作用域中,结果是 nil。对于Universe作用域,结果也是nil。只有当经过类型检查的AST有完整的位置信息时,才能保证结果有效。</target>
        </trans-unit>
        <trans-unit id="d3d677ba8b8fb62d3d734397c41c430f5735b25c" translate="yes" xml:space="preserve">
          <source>Input processed by verbs is implicitly space-delimited: the implementation of every verb except %c starts by discarding leading spaces from the remaining input, and the %s verb (and %v reading into a string) stops consuming input at the first space or newline character.</source>
          <target state="translated">由动词处理的输入是隐式空间限制的:除了%c之外,每个动词的实现都是从剩余的输入开始丢弃前导空格,%s动词(和%v读入字符串)在第一个空格或换行符时停止消耗输入。</target>
        </trans-unit>
        <trans-unit id="f2b998d9fdcbc1c4a3ffebeea1625f9214a80db4" translate="yes" xml:space="preserve">
          <source>InputOffset returns the input stream byte offset of the current decoder position. The offset gives the location of the end of the most recently returned token and the beginning of the next token.</source>
          <target state="translated">InputOffset返回当前解码器位置的输入流字节偏移量。偏移量给出最近返回的标记的结束位置和下一个标记的开始位置。</target>
        </trans-unit>
        <trans-unit id="e966ee10eb4ce3215fa8906700a612e44342e126" translate="yes" xml:space="preserve">
          <source>InsecureCipherSuites returns a list of cipher suites currently implemented by this package and which have security issues.</source>
          <target state="translated">InsecureCipherSuites 返回一个当前由这个软件包实现的、有安全问题的密码套件的列表。</target>
        </trans-unit>
        <trans-unit id="c6bdbccac97746d550ea930e761dad7ffa800d06" translate="yes" xml:space="preserve">
          <source>Insert attempts to insert a named object obj into the scope s. If the scope already contains an object alt with the same name, Insert leaves the scope unchanged and returns alt. Otherwise it inserts obj and returns nil.</source>
          <target state="translated">Insert试图将一个命名的对象obj插入到作用域s中,如果作用域中已经包含一个同名的对象alt,Insert将保持作用域不变并返回alt。否则插入obj并返回nil。</target>
        </trans-unit>
        <trans-unit id="3c51f0bca7bc21285dde2f4365d66539c9045fbd" translate="yes" xml:space="preserve">
          <source>Insert attempts to insert an object obj into scope s. If s already contains an alternative object alt with the same name, Insert leaves s unchanged and returns alt. Otherwise it inserts obj, sets the object's parent scope if not already set, and returns nil.</source>
          <target state="translated">Insert试图将对象obj插入到作用域s中,如果s中已经包含了一个同名的替代对象alt,Insert将保持s不变,并返回alt,否则插入obj,如果还没有设置,则设置对象的父作用域,并返回nil。否则插入obj,如果还没有设置,则设置对象的父作用域,并返回nil。</target>
        </trans-unit>
        <trans-unit id="e5d297ca4eb4122848b745777ba08d9e98e99026" translate="yes" xml:space="preserve">
          <source>InsertAfter inserts a new element e with value v immediately after mark and returns e. If mark is not an element of l, the list is not modified. The mark must not be nil.</source>
          <target state="translated">InsertAfter在mark之后插入一个新的元素e,其值为v,并返回e,如果mark不是l的元素,则列表不会被修改。mark不能是nil。</target>
        </trans-unit>
        <trans-unit id="f8690dfd3964564996a8ec4c6a534ffd7d8cce51" translate="yes" xml:space="preserve">
          <source>InsertBefore inserts a new element e with value v immediately before mark and returns e. If mark is not an element of l, the list is not modified. The mark must not be nil.</source>
          <target state="translated">InsertBefore在mark之前插入一个新的元素e,其值为v,并返回e,如果mark不是l的元素,则列表不会被修改。mark不能是nil。</target>
        </trans-unit>
        <trans-unit id="1a44ed1d9fdf3b19a9445ead705835b2d7701bba" translate="yes" xml:space="preserve">
          <source>Inset returns the rectangle r inset by n, which may be negative. If either of r's dimensions is less than 2*n then an empty rectangle near the center of r will be returned.</source>
          <target state="translated">Inset 返回矩形r的内插尺寸n,可以是负数。如果r的任何一个尺寸小于2*n,那么将返回一个靠近r中心的空矩形。</target>
        </trans-unit>
        <trans-unit id="18ca87afec4298d9de864e32b4eeb6a31786e496" translate="yes" xml:space="preserve">
          <source>Inspect</source>
          <target state="translated">Inspect</target>
        </trans-unit>
        <trans-unit id="165da1fa673b9fd9a581f6c1c726cccbffc7e2ca" translate="yes" xml:space="preserve">
          <source>Inspect traverses an AST in depth-first order: It starts by calling f(node); node must not be nil. If f returns true, Inspect invokes f recursively for each of the non-nil children of node, followed by a call of f(nil).</source>
          <target state="translated">Inspect以深度优先的顺序遍历一个AST,它通过调用f(node)开始。它首先调用f(node);node必须不是nil。如果f返回true,Inspector对node的每个非nil子代递归调用f,然后调用f(nil)。</target>
        </trans-unit>
        <trans-unit id="a6a380194dfce8d967bc921f5f0bd2558e839e1f" translate="yes" xml:space="preserve">
          <source>InstanceOf reports whether v is an instance of type t according to JavaScript's instanceof operator.</source>
          <target state="translated">InstanceOf根据JavaScript的instanceof运算符报告v是否是t类型的实例。</target>
        </trans-unit>
        <trans-unit id="ebf808b93582c50b9dee098ffbc7851e8bbd1bc5" translate="yes" xml:space="preserve">
          <source>Int defines an int flag with specified name, default value, and usage string. The return value is the address of an int variable that stores the value of the flag.</source>
          <target state="translated">Int定义了一个int标志,具有指定的名称、默认值和使用字符串。返回值是一个存储标志值的int变量的地址。</target>
        </trans-unit>
        <trans-unit id="4a82193f61167eeb73caee70b7d931807aee1e38" translate="yes" xml:space="preserve">
          <source>Int is a 64-bit integer variable that satisfies the Var interface.</source>
          <target state="translated">Int是一个满足Var接口的64位整数变量。</target>
        </trans-unit>
        <trans-unit id="af260c99fb6b16af9acf30bb7ef7c67bfd7f461c" translate="yes" xml:space="preserve">
          <source>Int returns a non-negative pseudo-random int from the default Source.</source>
          <target state="translated">Int从默认的Source返回一个非负的伪随机int。</target>
        </trans-unit>
        <trans-unit id="381ad8d2cdfa2db4d632061cd5638bdb827c118f" translate="yes" xml:space="preserve">
          <source>Int returns a non-negative pseudo-random int.</source>
          <target state="translated">Int返回一个非负的伪随机int。</target>
        </trans-unit>
        <trans-unit id="78b2c6c511c1ed56b26a62f7cd24e23bebce41b7" translate="yes" xml:space="preserve">
          <source>Int returns a uniform random value in [0, max). It panics if max &amp;lt;= 0.</source>
          <target state="translated">Int以[0，最大值）返回统一的随机值。如果max &amp;lt;= 0，则表示恐慌。</target>
        </trans-unit>
        <trans-unit id="5333a3a7b26511027f14a3034f5b9a08970c91dc" translate="yes" xml:space="preserve">
          <source>Int returns the result of truncating x towards zero; or nil if x is an infinity. The result is Exact if x.IsInt(); otherwise it is Below for x &amp;gt; 0, and Above for x &amp;lt; 0. If a non-nil *Int argument z is provided, Int stores the result in z instead of allocating a new Int.</source>
          <target state="translated">Int返回将x截断为零的结果。如果x是无穷大，则为nil。如果x.IsInt（）;结果为Exact。否则，对于x&amp;gt; 0，它是&amp;ldquo;低于&amp;rdquo;；对于x &amp;lt;0，它是高于。如果提供了非nil * Int参数z，则Int会将结果存储在z中，而不是分配新的Int。</target>
        </trans-unit>
        <trans-unit id="b48fef275365436d3178b531a98b6df9140d4a4e" translate="yes" xml:space="preserve">
          <source>Int returns the value v truncated to an int. It panics if v is not a JavaScript number.</source>
          <target state="translated">Int返回值v截断为一个int。如果v不是JavaScript数字,它就会恐慌。</target>
        </trans-unit>
        <trans-unit id="7aeadc703783366afed8a63b0734b22311f2a7e4" translate="yes" xml:space="preserve">
          <source>Int returns v's underlying value, as an int64. It panics if v's Kind is not Int, Int8, Int16, Int32, or Int64.</source>
          <target state="translated">Int以int64的形式返回v的底层值,如果v的Kind不是Int、Int8、Int16、Int32或Int64,它就会恐慌。如果v的Kind不是Int、Int8、Int16、Int32或Int64,它就会惊慌失措。</target>
        </trans-unit>
        <trans-unit id="53c091a9597bdba1f2ca46d491f5c108342e031f" translate="yes" xml:space="preserve">
          <source>Int.Scan</source>
          <target state="translated">Int.Scan</target>
        </trans-unit>
        <trans-unit id="5de699e08eb78e768e5b08ea65a2d2d995d6cca4" translate="yes" xml:space="preserve">
          <source>Int.SetString</source>
          <target state="translated">Int.SetString</target>
        </trans-unit>
        <trans-unit id="25863d22096f1ba104e899340881b4d53e78900e" translate="yes" xml:space="preserve">
          <source>Int31 returns a non-negative pseudo-random 31-bit integer as an int32 from the default Source.</source>
          <target state="translated">Int31从默认的Source返回一个非负的伪随机31位整数作为int32。</target>
        </trans-unit>
        <trans-unit id="8668fa86efe442ed5c0ddfb6799eac348a1585d9" translate="yes" xml:space="preserve">
          <source>Int31 returns a non-negative pseudo-random 31-bit integer as an int32.</source>
          <target state="translated">Int31以int32的形式返回一个非负的伪随机31位整数。</target>
        </trans-unit>
        <trans-unit id="4ef488a0ec898f126b9413bbb42319fb0eaeff13" translate="yes" xml:space="preserve">
          <source>Int31n returns, as an int32, a non-negative pseudo-random number in [0,n) from the default Source. It panics if n &amp;lt;= 0.</source>
          <target state="translated">Int31n从默认Source返回[0，n）中的非负伪随机数作为int32。如果n &amp;lt;= 0则恐慌。</target>
        </trans-unit>
        <trans-unit id="90d847f9e26c6ab28ce7fd160e1218ad35e875d4" translate="yes" xml:space="preserve">
          <source>Int31n returns, as an int32, a non-negative pseudo-random number in [0,n). It panics if n &amp;lt;= 0.</source>
          <target state="translated">Int31n以int32的形式返回[0，n）中的非负伪随机数。如果n &amp;lt;= 0则恐慌。</target>
        </trans-unit>
        <trans-unit id="848b71a013b8e0169e247e647c756adf54d70a3d" translate="yes" xml:space="preserve">
          <source>Int32 is a ValueConverter that converts input values to int64, respecting the limits of an int32 value.</source>
          <target state="translated">Int32是一个ValueConverter,它将输入值转换为int64,尊重int32值的限制。</target>
        </trans-unit>
        <trans-unit id="40feceb2effc4993d828a64f0bbc7bd4b65472d1" translate="yes" xml:space="preserve">
          <source>Int63 returns a non-negative pseudo-random 63-bit integer as an int64 from the default Source.</source>
          <target state="translated">Int63从默认的Source返回一个非负的伪随机63位整数作为int64。</target>
        </trans-unit>
        <trans-unit id="73b13ad335bd8c446e54125036bbdb60110b8a67" translate="yes" xml:space="preserve">
          <source>Int63 returns a non-negative pseudo-random 63-bit integer as an int64.</source>
          <target state="translated">Int63以int64的形式返回一个非负的伪随机63位整数。</target>
        </trans-unit>
        <trans-unit id="ccf199104b81302e6aa6420d9d53fbe6d1e5e481" translate="yes" xml:space="preserve">
          <source>Int63n returns, as an int64, a non-negative pseudo-random number in [0,n) from the default Source. It panics if n &amp;lt;= 0.</source>
          <target state="translated">Int63n从默认Source返回[0，n）中的非负伪随机数作为int64。如果n &amp;lt;= 0则恐慌。</target>
        </trans-unit>
        <trans-unit id="adc50ec6888e251cb9eb8237744893f852c6674f" translate="yes" xml:space="preserve">
          <source>Int63n returns, as an int64, a non-negative pseudo-random number in [0,n). It panics if n &amp;lt;= 0.</source>
          <target state="translated">Int63n将[0，n）中的非负伪随机数作为int64返回。如果n &amp;lt;= 0则恐慌。</target>
        </trans-unit>
        <trans-unit id="caf7332f4387883214a684cf486e59d1298af5e4" translate="yes" xml:space="preserve">
          <source>Int64 defines an int64 flag with specified name, default value, and usage string. The return value is the address of an int64 variable that stores the value of the flag.</source>
          <target state="translated">Int64定义了一个int64标志,具有指定的名称、默认值和使用字符串。返回值是存储标志值的int64变量的地址。</target>
        </trans-unit>
        <trans-unit id="5ea42bb5a91b0f37c1c104284dddf7aee6dd3d40" translate="yes" xml:space="preserve">
          <source>Int64 returns the int64 representation of x. If x cannot be represented in an int64, the result is undefined.</source>
          <target state="translated">Int64返回x的int64表示法。如果x不能用int64表示,则结果为未定义。</target>
        </trans-unit>
        <trans-unit id="024ee0329e5ac0182a79c3f0f817ea471b5da8f4" translate="yes" xml:space="preserve">
          <source>Int64 returns the integer resulting from truncating x towards zero. If math.MinInt64 &amp;lt;= x &amp;lt;= math.MaxInt64, the result is Exact if x is an integer, and Above (x &amp;lt; 0) or Below (x &amp;gt; 0) otherwise. The result is (math.MinInt64, Above) for x &amp;lt; math.MinInt64, and (math.MaxInt64, Below) for x &amp;gt; math.MaxInt64.</source>
          <target state="translated">Int64返回将x截断为零所得的整数。如果math.MinInt64 &amp;lt;= x &amp;lt;= math.MaxInt64，则如果x为整数，则结果为&amp;ldquo;精确&amp;rdquo;，否则为&amp;ldquo;大于（x &amp;lt;0）或小于（x&amp;gt; 0）&amp;rdquo;。对于x &amp;lt;math.MinInt64，结果为（math.MinInt64，上方）；对于x&amp;gt; math.MaxInt64，结果为（math.MaxInt64，下方）。</target>
        </trans-unit>
        <trans-unit id="a7858f715e5515e9b11682c98c7e956884fa03d3" translate="yes" xml:space="preserve">
          <source>Int64 returns the number as an int64.</source>
          <target state="translated">Int64 返回一个int64的数字。</target>
        </trans-unit>
        <trans-unit id="e87b1cbe8a7626b33b6c26f9454e9b97aa48ff20" translate="yes" xml:space="preserve">
          <source>Int64Val returns the Go int64 value of x and whether the result is exact; x must be an Int or an Unknown. If the result is not exact, its value is undefined. If x is Unknown, the result is (0, false).</source>
          <target state="translated">Int64Val 返回 x 的围棋 int64 值以及结果是否精确;x 必须是 Int 或 Unknown。如果结果不精确,它的值是未定义的。如果x是未知值,结果是(0,false)。</target>
        </trans-unit>
        <trans-unit id="e48ba0f308dabec3542a772cd98df7b4a194464a" translate="yes" xml:space="preserve">
          <source>Int64Var defines an int64 flag with specified name, default value, and usage string. The argument p points to an int64 variable in which to store the value of the flag.</source>
          <target state="translated">Int64Var定义了一个int64标志,它具有指定的名称、默认值和用法字符串,参数p指向一个int64变量,用来存储标志的值。参数p指向一个int64变量,用来存储标志的值。</target>
        </trans-unit>
        <trans-unit id="826fdf675ec889637dd1607e0ecbc7b4617ed6b5" translate="yes" xml:space="preserve">
          <source>IntSize is the size in bits of an int or uint value.</source>
          <target state="translated">IntSize是一个int或uint值的大小,单位是位。</target>
        </trans-unit>
        <trans-unit id="7d0ad3a5fc2c5562d1a3d5edaf660d5681e2e7dd" translate="yes" xml:space="preserve">
          <source>IntSlice attaches the methods of Interface to []int, sorting in increasing order.</source>
          <target state="translated">IntSlice将Interface的方法附加到[]int上,按递增顺序排序。</target>
        </trans-unit>
        <trans-unit id="259cdcc1487407a0effb8761c09ff465d822351b" translate="yes" xml:space="preserve">
          <source>IntVar defines an int flag with specified name, default value, and usage string. The argument p points to an int variable in which to store the value of the flag.</source>
          <target state="translated">IntVar定义了一个int标志,具有指定的名称、默认值和用法字符串。参数p指向一个int变量,用来存储标志的值。</target>
        </trans-unit>
        <trans-unit id="e927198b4dfea79ca477c6ca320b7977e5f907d8" translate="yes" xml:space="preserve">
          <source>Integer flags accept 1234, 0664, 0x1234 and may be negative. Boolean flags may be:</source>
          <target state="translated">整数标志接受1234、0664、0x1234,可以是负数。布尔标志可以是:</target>
        </trans-unit>
        <trans-unit id="d8d2cb0f1ba846253e8f8508e7b268037f761677" translate="yes" xml:space="preserve">
          <source>Integer limit values.</source>
          <target state="translated">整数极限值。</target>
        </trans-unit>
        <trans-unit id="8e6549b1b15bddbc7e4ca51ecb54082a0c50f802" translate="yes" xml:space="preserve">
          <source>Integer:</source>
          <target state="translated">Integer:</target>
        </trans-unit>
        <trans-unit id="8ef45f34654a956038b7d2e46f7b980bceca0a1e" translate="yes" xml:space="preserve">
          <source>IntegerType is here for the purposes of documentation only. It is a stand-in for any integer type: int, uint, int8 etc.</source>
          <target state="translated">IntegerType在这里只是为了文档的目的。它是任何整数类型的替身:int、uint、int8等。</target>
        </trans-unit>
        <trans-unit id="5a289c0331a1e2ae1cddd468bdbd08515a751488" translate="yes" xml:space="preserve">
          <source>Integers are transmitted two ways: arbitrary precision signed integers or arbitrary precision unsigned integers. There is no int8, int16 etc. discrimination in the gob format; there are only signed and unsigned integers. As described below, the transmitter sends the value in a variable-length encoding; the receiver accepts the value and stores it in the destination variable. Floating-point numbers are always sent using IEEE-754 64-bit precision (see below).</source>
          <target state="translated">整数的传输方式有两种:任意精度的有符号整数或任意精度的无符号整数。在gob格式中没有int8、int16等的区分,只有有符号整数和无符号整数。如下所述,发送方以可变长度的编码发送值;接收方接受值并将其存储在目标变量中。浮点数总是使用IEEE-754 64位精度发送(见下文)。</target>
        </trans-unit>
        <trans-unit id="7b4db7ef1fa23cfb5e115a2a2c89d46a6a2ebc4a" translate="yes" xml:space="preserve">
          <source>Interface</source>
          <target state="translated">Interface</target>
        </trans-unit>
        <trans-unit id="8a7e153030b338cdad7a41aa466f441af45e4a11" translate="yes" xml:space="preserve">
          <source>Interface represents a mapping between network interface name and index. It also represents network interface facility information.</source>
          <target state="translated">接口表示网络接口名称和索引之间的映射。它也代表网络接口设施信息。</target>
        </trans-unit>
        <trans-unit id="6da3607f32beaa93e64c1a37a2f36fbed997c327" translate="yes" xml:space="preserve">
          <source>Interface returns v's current value as an interface{}. It is equivalent to:</source>
          <target state="translated">接口以接口{}的形式返回v的当前值。它相当于:</target>
        </trans-unit>
        <trans-unit id="5ea5c3979b46b5a2713cc2d1786a81b1f8ec63c2" translate="yes" xml:space="preserve">
          <source>Interface types are not checked for compatibility; all interface types are treated, for transmission, as members of a single &quot;interface&quot; type, analogous to int or []byte - in effect they're all treated as interface{}. Interface values are transmitted as a string identifying the concrete type being sent (a name that must be pre-defined by calling Register), followed by a byte count of the length of the following data (so the value can be skipped if it cannot be stored), followed by the usual encoding of concrete (dynamic) value stored in the interface value. (A nil interface value is identified by the empty string and transmits no value.) Upon receipt, the decoder verifies that the unpacked concrete item satisfies the interface of the receiving variable.</source>
          <target state="translated">接口类型不进行兼容性检查;在传输时,所有接口类型都被视为单一 &quot;接口 &quot;类型的成员,类似于int或[]byte--实际上它们都被视为接口{}。接口值的传输方式是一个标识被发送的具体类型的字符串(这个名称必须由调用Register预先定义),后面是一个字节数,表示下面数据的长度(所以如果不能存储该值,可以跳过),后面是存储在接口值中的具体(动态)值的通常编码。(nil接口值由空字符串标识,不传输任何值)。收到后,解码器验证解包后的具体项是否满足接收变量的接口。</target>
        </trans-unit>
        <trans-unit id="74b4a1f2cd95d6ac03afcfd27826497cd84b5ae7" translate="yes" xml:space="preserve">
          <source>Interface values are deeply equal if they hold deeply equal concrete values.</source>
          <target state="translated">界面值如果持有深度相等的具体数值,则为深度相等。</target>
        </trans-unit>
        <trans-unit id="09203e8778d59b495323467d890a95f5807f26bf" translate="yes" xml:space="preserve">
          <source>Interface values encode as the value contained in the interface. A nil interface value encodes as the null JSON value.</source>
          <target state="translated">接口值编码为接口中包含的值。无接口值编码为空JSON值。</target>
        </trans-unit>
        <trans-unit id="360b50370b24932254b26c7af3e111445c188db0" translate="yes" xml:space="preserve">
          <source>InterfaceAddrs returns a list of the system's unicast interface addresses.</source>
          <target state="translated">InterfaceAddrs 返回系统的单播接口地址列表。</target>
        </trans-unit>
        <trans-unit id="9ce937dfbe60c7ef5a110a8b5806627105e626f1" translate="yes" xml:space="preserve">
          <source>InterfaceByIndex returns the interface specified by index.</source>
          <target state="translated">InterfaceByIndex 返回由index指定的接口。</target>
        </trans-unit>
        <trans-unit id="4245d4428eaccf8da6182470aec7d558cea28a53" translate="yes" xml:space="preserve">
          <source>InterfaceByName returns the interface specified by name.</source>
          <target state="translated">InterfaceByName返回由名称指定的接口。</target>
        </trans-unit>
        <trans-unit id="a63d53fbc696efd4a28db884d8645a21dcabe121" translate="yes" xml:space="preserve">
          <source>InterfaceData returns the interface v's value as a uintptr pair. It panics if v's Kind is not Interface.</source>
          <target state="translated">InterfaceData以uintptr对的形式返回接口v的值。如果v的Kind不是Interface,它就会恐慌。</target>
        </trans-unit>
        <trans-unit id="470a021de3b9df70021376a7834ee99ab5ab1f2e" translate="yes" xml:space="preserve">
          <source>Interfaces returns a list of the system's network interfaces.</source>
          <target state="translated">Interfaces 返回系统的网络接口列表。</target>
        </trans-unit>
        <trans-unit id="faba134b29aa30840bd61a266830217b82a22fc4" translate="yes" xml:space="preserve">
          <source>InternalBenchmark is an internal type but exported because it is cross-package; it is part of the implementation of the &quot;go test&quot; command.</source>
          <target state="translated">InternalBenchmark是一个内部类型,但因为它是跨包的,所以被导出;它是实现 &quot;go test &quot;命令的一部分。</target>
        </trans-unit>
        <trans-unit id="ce46964418231d76007ec656366d43d02eb959b8" translate="yes" xml:space="preserve">
          <source>InternalTest is an internal type but exported because it is cross-package; it is part of the implementation of the &quot;go test&quot; command.</source>
          <target state="translated">InternalTest是一个内部类型,但因为它是跨包的,所以被导出;它是 &quot;go test &quot;命令实现的一部分。</target>
        </trans-unit>
        <trans-unit id="a60781d644f0c18cd790184e8cc93bbf04ff58fe" translate="yes" xml:space="preserve">
          <source>Intersect returns the largest rectangle contained by both r and s. If the two rectangles do not overlap then the zero rectangle will be returned.</source>
          <target state="translated">交叉返回r和s所包含的最大矩形,如果两个矩形不重合,则返回零矩形。</target>
        </trans-unit>
        <trans-unit id="37b82affb5d88e1d235360ffb5b4876b9c358ef4" translate="yes" xml:space="preserve">
          <source>Intn</source>
          <target state="translated">Intn</target>
        </trans-unit>
        <trans-unit id="54d0c13534e6e00abbb2d04b4cb149c7d0ddea38" translate="yes" xml:space="preserve">
          <source>Intn returns, as an int, a non-negative pseudo-random number in [0,n) from the default Source. It panics if n &amp;lt;= 0.</source>
          <target state="translated">Intn从默认Source返回[0，n）中的非负伪随机数作为int。如果n &amp;lt;= 0则恐慌。</target>
        </trans-unit>
        <trans-unit id="8f26feb5337a07fc6e35ec73e1c6b06a4a8f7c21" translate="yes" xml:space="preserve">
          <source>Intn returns, as an int, a non-negative pseudo-random number in [0,n). It panics if n &amp;lt;= 0.</source>
          <target state="translated">Intn以int形式返回[0，n）中的非负伪随机数。如果n &amp;lt;= 0则恐慌。</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="b7f44e53c873fdc1db7cef7777af521f4a3b60c1" translate="yes" xml:space="preserve">
          <source>Ints</source>
          <target state="translated">Ints</target>
        </trans-unit>
        <trans-unit id="0d62fa520893beed143100d8873cdbc43cfe7428" translate="yes" xml:space="preserve">
          <source>Ints sorts a slice of ints in increasing order.</source>
          <target state="translated">Ints按照递增的顺序对ints的一个片断进行排序。</target>
        </trans-unit>
        <trans-unit id="00382ca46ab71a1b23e2790f3cf0a66b6faa90df" translate="yes" xml:space="preserve">
          <source>IntsAreSorted</source>
          <target state="translated">IntsAreSorted</target>
        </trans-unit>
        <trans-unit id="15003e1b93fee181a87b2536fb555a75f6e8fa12" translate="yes" xml:space="preserve">
          <source>IntsAreSorted reports whether the slice x is sorted in increasing order.</source>
          <target state="translated">IntsAreSorted报告切片x是否按递增顺序排序。</target>
        </trans-unit>
        <trans-unit id="d11bf023986ecfce333bd8a5477d90f31eb1db0a" translate="yes" xml:space="preserve">
          <source>IntsAreSorted tests whether a slice of ints is sorted in increasing order.</source>
          <target state="translated">IntsAreSorted测试一个ints片是否按递增顺序排序。</target>
        </trans-unit>
        <trans-unit id="e6124bd83c6b099c79f4ac3379192d76121e3dfb" translate="yes" xml:space="preserve">
          <source>Inv sets z to 1/x and returns z.</source>
          <target state="translated">Inv设z为1/x,并返回z。</target>
        </trans-unit>
        <trans-unit id="496bc61a17df218d2461a9eddcde86416579b01a" translate="yes" xml:space="preserve">
          <source>Inv sets z to 1/x and returns z. If x == 0, Inv panics.</source>
          <target state="translated">Inv将z设为1/x并返回z,如果x==0,Inv就会惊慌失措。</target>
        </trans-unit>
        <trans-unit id="57f0200085fa1268ae261758bfb7dee5795a5704" translate="yes" xml:space="preserve">
          <source>InvalidByteError values describe errors resulting from an invalid byte in a hex string.</source>
          <target state="translated">InvalidByteError值描述的是十六进制字符串中的无效字节导致的错误。</target>
        </trans-unit>
        <trans-unit id="fc945344ffab3c8e0685a8f6f0b347b0e1b5f04c" translate="yes" xml:space="preserve">
          <source>Invoke does a JavaScript call of the value v with the given arguments. It panics if v is not a JavaScript function. The arguments get mapped to JavaScript values according to the ValueOf function.</source>
          <target state="translated">Invoke使用给定的参数对值v进行JavaScript调用。如果v不是JavaScript函数,它就会惊慌失措。根据ValueOf函数,参数会被映射到JavaScript值。</target>
        </trans-unit>
        <trans-unit id="a8bc24ce97a4c19ceec821a6c13e305d4cc7093a" translate="yes" xml:space="preserve">
          <source>Invoking the JavaScript function will synchronously call the Go function fn with the value of JavaScript's &quot;this&quot; keyword and the arguments of the invocation. The return value of the invocation is the result of the Go function mapped back to JavaScript according to ValueOf.</source>
          <target state="translated">调用JavaScript函数会同步调用Go函数fn,并将JavaScript的 &quot;this &quot;关键字的值和调用的参数。调用的返回值是Go函数根据ValueOf映射回JavaScript的结果。</target>
        </trans-unit>
        <trans-unit id="cf66655914f273806173ce98e001321c956d8544" translate="yes" xml:space="preserve">
          <source>Invoking the wrapped Go function from JavaScript will pause the event loop and spawn a new goroutine. Other wrapped functions which are triggered during a call from Go to JavaScript get executed on the same goroutine.</source>
          <target state="translated">从JavaScript中调用封装的Go函数会暂停事件循环,并生成一个新的goroutine。在从Go到JavaScript的调用过程中被触发的其他封装函数会在同一个goroutine上执行。</target>
        </trans-unit>
        <trans-unit id="079bc3b6a59d995ce86a46665da2718451aea120" translate="yes" xml:space="preserve">
          <source>Is</source>
          <target state="translated">Is</target>
        </trans-unit>
        <trans-unit id="b80342e2833069978eb2ebabac8e59ca1a3fbfc5" translate="yes" xml:space="preserve">
          <source>Is reports whether any error in err's chain matches target.</source>
          <target state="translated">报告err链中是否有与目标匹配的错误。</target>
        </trans-unit>
        <trans-unit id="2dcad3f5fb898f44a28ca9cc90eb869f037180e6" translate="yes" xml:space="preserve">
          <source>Is reports whether the rune is in the specified table of ranges.</source>
          <target state="translated">是报告符文是否在指定的范围表中。</target>
        </trans-unit>
        <trans-unit id="d895a1147fb9e99c093e2c8e3aa2a3a161a62599" translate="yes" xml:space="preserve">
          <source>Is unwraps its first argument sequentially looking for an error that matches the second. It reports whether it finds a match. It should be used in preference to simple equality checks:</source>
          <target state="translated">Is依次展开第一个参数,寻找与第二个参数匹配的错误。它报告是否找到匹配。它应该优先用于简单的平等检查。</target>
        </trans-unit>
        <trans-unit id="4240feb2e7eac03ab7672bf3d52cbd0df60964bf" translate="yes" xml:space="preserve">
          <source>IsAbs</source>
          <target state="translated">IsAbs</target>
        </trans-unit>
        <trans-unit id="6ba3e5deb5d3ce3b158c2019d9e58f42637cf610" translate="yes" xml:space="preserve">
          <source>IsAbs reports whether the URL is absolute. Absolute means that it has a non-empty scheme.</source>
          <target state="translated">IsAbs报告URL是否是绝对的。Absolute意味着它有一个非空的方案。</target>
        </trans-unit>
        <trans-unit id="36a0d5f9413d1e35ae6366ef607edd836694bee0" translate="yes" xml:space="preserve">
          <source>IsAbs reports whether the path is absolute.</source>
          <target state="translated">IsAbs报告路径是否为绝对路径。</target>
        </trans-unit>
        <trans-unit id="e1eaf7841a07f287f076c00cb20e44f9651ff13f" translate="yes" xml:space="preserve">
          <source>IsAlias reports whether obj is an alias name for a type.</source>
          <target state="translated">IsAlias报告obj是否是一个类型的别名。</target>
        </trans-unit>
        <trans-unit id="0e84022f347580b90f81c69d614f481de5c48849" translate="yes" xml:space="preserve">
          <source>IsBuiltin reports whether the corresponding expression denotes a (possibly parenthesized) built-in function.</source>
          <target state="translated">IsBuiltin报告对应的表达式是否表示一个(可能是括号)内置函数。</target>
        </trans-unit>
        <trans-unit id="c915051f076524ecaa2f5d332eb2bb4d2765eefa" translate="yes" xml:space="preserve">
          <source>IsCommand reports whether the package is considered a command to be installed (not just a library). Packages named &quot;main&quot; are treated as commands.</source>
          <target state="translated">IsCommand报告包是否被认为是一个要安装的命令(而不仅仅是一个库)。以 &quot;main &quot;命名的软件包被视为命令。</target>
        </trans-unit>
        <trans-unit id="2cd3abc2f41e5f98828e0ebaee47dfbcd10387ad" translate="yes" xml:space="preserve">
          <source>IsControl reports whether the rune is a control character. The C (Other) Unicode category includes more code points such as surrogates; use Is(C, r) to test for them.</source>
          <target state="translated">IsControl报告该符文是否是控制字符。C(Other)Unicode类别包括更多的代码点,如代字;使用Is(C,r)来测试它们。</target>
        </trans-unit>
        <trans-unit id="c746a0807bba76d32760f9142c884716d0699c51" translate="yes" xml:space="preserve">
          <source>IsDigit reports whether the rune is a decimal digit.</source>
          <target state="translated">IsDigit报告符文是否为十进制数字。</target>
        </trans-unit>
        <trans-unit id="3dc4a185454e26efa4716393eed4775f2e55fe7c" translate="yes" xml:space="preserve">
          <source>IsDir reports whether m describes a directory. That is, it tests for the ModeDir bit being set in m.</source>
          <target state="translated">IsDir报告m是否描述了一个目录。也就是说,它测试m中的ModeDir位是否被设置。</target>
        </trans-unit>
        <trans-unit id="e67a4b242fe3e4d35035e7774ab8072906fab973" translate="yes" xml:space="preserve">
          <source>IsEmptyTree reports whether this tree (node) is empty of everything but space or comments.</source>
          <target state="translated">IsEmptyTree报告这棵树(节点)除了空格或注释之外是否为空。</target>
        </trans-unit>
        <trans-unit id="5fd80e2b1854e3452cd6bfd7234aa8fa8ddcdc63" translate="yes" xml:space="preserve">
          <source>IsEmptyTree reports whether this tree (node) is empty of everything but space.</source>
          <target state="translated">IsEmptyTree报告这棵树(节点)除了空间之外是否为空。</target>
        </trans-unit>
        <trans-unit id="cd43f5281afe605e10c23fa5e5c73089248f9feb" translate="yes" xml:space="preserve">
          <source>IsEnabled reports whether tracing is enabled. The information is advisory only. The tracing status may have changed by the time this function returns.</source>
          <target state="translated">IsEnabled报告是否启用了追踪。该信息仅作参考,在本函数返回时,跟踪状态可能已经改变。在本函数返回时,跟踪状态可能已经改变。</target>
        </trans-unit>
        <trans-unit id="39e18e7e1b9d6fbe4b3f09d74593704f059a0c0a" translate="yes" xml:space="preserve">
          <source>IsEncryptedPEMBlock returns if the PEM block is password encrypted.</source>
          <target state="translated">IsEncryptedPEMBlock返回PEM块是否已被密码加密。</target>
        </trans-unit>
        <trans-unit id="60b1c669bbd4deb841f16ea07aaf99039943a55d" translate="yes" xml:space="preserve">
          <source>IsEncryptedPEMBlock returns whether the PEM block is password encrypted according to RFC 1423.</source>
          <target state="translated">IsEncryptedPEMBlock返回PEM块是否根据RFC 1423进行了密码加密。</target>
        </trans-unit>
        <trans-unit id="bc66205543d841780222acbebc983e058e70415a" translate="yes" xml:space="preserve">
          <source>IsExist returns a boolean indicating whether the error is known to report that a file or directory already exists. It is satisfied by ErrExist as well as some syscall errors.</source>
          <target state="translated">IsExist 返回一个布尔值,表示是否已知错误,报告一个文件或目录已经存在。它由ErrExist以及一些系统调用错误来满足。</target>
        </trans-unit>
        <trans-unit id="fc56fa9983588228bd9fa3b0b5a7931ac3cb75f1" translate="yes" xml:space="preserve">
          <source>IsExported reports whether id starts with an upper-case letter.</source>
          <target state="translated">IsExported报告id是否以大写字母开头。</target>
        </trans-unit>
        <trans-unit id="3c6d4e31e0d52ed1d2823481dfa21ed80c9b776d" translate="yes" xml:space="preserve">
          <source>IsExported reports whether name starts with an upper-case letter.</source>
          <target state="translated">IsExported报告名称是否以大写字母开头。</target>
        </trans-unit>
        <trans-unit id="504274dd55fc2a273ebc2bd501f5695303ffe229" translate="yes" xml:space="preserve">
          <source>IsField reports whether the variable is a struct field.</source>
          <target state="translated">IsField报告变量是否是结构域。</target>
        </trans-unit>
        <trans-unit id="d9bdbeb50a8c37eb5d00e31069315d70d10359d6" translate="yes" xml:space="preserve">
          <source>IsGlobalUnicast reports whether ip is a global unicast address.</source>
          <target state="translated">IsGlobalUnicast报告ip是否为全局单播地址。</target>
        </trans-unit>
        <trans-unit id="81438b4c8eca18603ccf70f1438b5199ee8dc35f" translate="yes" xml:space="preserve">
          <source>IsGoBuild reports whether the line of text is a &amp;ldquo;//go:build&amp;rdquo; constraint. It only checks the prefix of the text, not that the expression itself parses.</source>
          <target state="translated">IsGoBuild报告文本行是否为&amp;ldquo; // go：build&amp;rdquo;约束。它仅检查文本的前缀，而不检查表达式本身进行分析。</target>
        </trans-unit>
        <trans-unit id="d72f8c1ccd0ac092185d981b6c61eacc3c121ef6" translate="yes" xml:space="preserve">
          <source>IsGraphic</source>
          <target state="translated">IsGraphic</target>
        </trans-unit>
        <trans-unit id="56022820abfd812a684373d7b12ff29c87996877" translate="yes" xml:space="preserve">
          <source>IsGraphic reports whether the rune is defined as a Graphic by Unicode. Such characters include letters, marks, numbers, punctuation, symbols, and spaces, from categories L, M, N, P, S, Zs.</source>
          <target state="translated">IsGraphic报告该符文是否被Unicode定义为图形。这些字符包括字母、标记、数字、标点符号、符号和空格,来自L、M、N、P、S、Zs类别。</target>
        </trans-unit>
        <trans-unit id="3bed5baca126f10003a7fc44f4e55808b330feda" translate="yes" xml:space="preserve">
          <source>IsGraphic reports whether the rune is defined as a Graphic by Unicode. Such characters include letters, marks, numbers, punctuation, symbols, and spaces, from categories L, M, N, P, S, and Zs.</source>
          <target state="translated">IsGraphic报告该符文是否被Unicode定义为图形。这些字符包括字母、标记、数字、标点符号、符号和空格,来自L、M、N、P、S和Zs类别。</target>
        </trans-unit>
        <trans-unit id="93d167ded0e381246ad35c4922eb8c26e2a4fc55" translate="yes" xml:space="preserve">
          <source>IsIdentifier reports whether name is a Go identifier, that is, a non-empty string made up of letters, digits, and underscores, where the first character is not a digit. Keywords are not identifiers.</source>
          <target state="translated">IsIdentifier 报告名称是否是围棋标识符,即由字母、数字和下划线组成的非空字符串,其中第一个字符不是数字。关键词不是标识符。</target>
        </trans-unit>
        <trans-unit id="679d30c5187a96f463dfbcdfb594ecc9983403ef" translate="yes" xml:space="preserve">
          <source>IsInf reports whether either real(x) or imag(x) is an infinity.</source>
          <target state="translated">IsInf报告real(x)或 imag(x)是否为无穷大。</target>
        </trans-unit>
        <trans-unit id="13dd75a92325ad267d0a2fa14c6cb50f24a9dd7b" translate="yes" xml:space="preserve">
          <source>IsInf reports whether f is an infinity, according to sign. If sign &amp;gt; 0, IsInf reports whether f is positive infinity. If sign &amp;lt; 0, IsInf reports whether f is negative infinity. If sign == 0, IsInf reports whether f is either infinity.</source>
          <target state="translated">IsInf根据符号报告f是否为无穷大。如果sign&amp;gt; 0，则IsInf报告f是否为正无穷大。如果符号&amp;lt;0，则IsInf报告f是否为负无穷大。如果符号== 0，则IsInf报告f是否为无穷大。</target>
        </trans-unit>
        <trans-unit id="8e1783a22a02fb29f43965c4b4c975183d78e4dd" translate="yes" xml:space="preserve">
          <source>IsInf reports whether x is +Inf or -Inf.</source>
          <target state="translated">IsInf报告x是+Inf还是-Inf。</target>
        </trans-unit>
        <trans-unit id="1b05edd34484393d17b771d708b4b2dd276cb90e" translate="yes" xml:space="preserve">
          <source>IsInt reports whether the denominator of x is 1.</source>
          <target state="translated">IsInt报告x的分母是否为1。</target>
        </trans-unit>
        <trans-unit id="63c80063be9af3740f75431caecb4e56ba22484c" translate="yes" xml:space="preserve">
          <source>IsInt reports whether x is an integer. &amp;plusmn;Inf values are not integers.</source>
          <target state="translated">IsInt报告x是否为整数。&amp;plusmn;Inf值不是整数。</target>
        </trans-unit>
        <trans-unit id="00a1b79e443959417f450c9b16cf5f48a8929d0f" translate="yes" xml:space="preserve">
          <source>IsInt64 reports whether x can be represented as an int64.</source>
          <target state="translated">IsInt64报告x是否可以用int64表示。</target>
        </trans-unit>
        <trans-unit id="ab97d0f94b18fe8f3b28313a45a877858cc4fa50" translate="yes" xml:space="preserve">
          <source>IsInterface reports whether typ is an interface type.</source>
          <target state="translated">IsInterface 报告 typ 是否为接口类型。</target>
        </trans-unit>
        <trans-unit id="c6bdcbe107886851b028b532be31d52568400157" translate="yes" xml:space="preserve">
          <source>IsInterfaceLocalMulticast reports whether ip is an interface-local multicast address.</source>
          <target state="translated">IsInterfaceLocalMulticast报告ip是否为接口本地组播地址。</target>
        </trans-unit>
        <trans-unit id="203bcfa02f0ff2531137c0e97e09e91145ccf765" translate="yes" xml:space="preserve">
          <source>IsKeyword reports whether name is a Go keyword, such as &quot;func&quot; or &quot;return&quot;.</source>
          <target state="translated">IsKeyword报告name是否是Go关键字,如 &quot;func &quot;或 &quot;return&quot;。</target>
        </trans-unit>
        <trans-unit id="b1af467f9e4844b489b1e4d07d7f23c5a24e49f8" translate="yes" xml:space="preserve">
          <source>IsKeyword returns true for tokens corresponding to keywords; it returns false otherwise.</source>
          <target state="translated">对于关键字对应的标记,IsKeyword返回true,否则返回false。</target>
        </trans-unit>
        <trans-unit id="9e659e799b643d193bc338fa878bc56e93c2043d" translate="yes" xml:space="preserve">
          <source>IsLetter reports whether the rune is a letter (category L).</source>
          <target state="translated">IsLetter报告符文是否为字母(L类)。</target>
        </trans-unit>
        <trans-unit id="796f0c2eac4ef075bdac49252f1a8a9437f7cb5a" translate="yes" xml:space="preserve">
          <source>IsLinkLocalMulticast reports whether ip is a link-local multicast address.</source>
          <target state="translated">IsLinkLocalMulticast报告ip是否为链路本地组播地址。</target>
        </trans-unit>
        <trans-unit id="bb398472e4891951632d23a856db9700a4f1260f" translate="yes" xml:space="preserve">
          <source>IsLinkLocalUnicast reports whether ip is a link-local unicast address.</source>
          <target state="translated">IsLinkLocalUnicast会报告ip是否是link-local单播地址。</target>
        </trans-unit>
        <trans-unit id="338823e775821fbbffd934b6dc8f8c7b06cf31f5" translate="yes" xml:space="preserve">
          <source>IsLiteral returns true for tokens corresponding to identifiers and basic type literals; it returns false otherwise.</source>
          <target state="translated">对于标识符和基本类型字元对应的标记,IsLiteral返回true,否则返回false。</target>
        </trans-unit>
        <trans-unit id="a302aa5062a5a2939f950e77a3b1bd2cffbbb134" translate="yes" xml:space="preserve">
          <source>IsLocalImport reports whether the import path is a local import path, like &quot;.&quot;, &quot;..&quot;, &quot;./foo&quot;, or &quot;../foo&quot;.</source>
          <target state="translated">IsLocalImport报告导入路径是否是本地导入路径,如&quot;.&quot;、&quot;.&quot;、&quot;./foo &quot;或&quot;./foo&quot;。</target>
        </trans-unit>
        <trans-unit id="a279a0dd486da312eb888a933fcd3c106d5ddf1b" translate="yes" xml:space="preserve">
          <source>IsLoopback reports whether ip is a loopback address.</source>
          <target state="translated">IsLoopback报告ip是否为环回地址。</target>
        </trans-unit>
        <trans-unit id="4c6115a445a46684f9b4821abab1454dcf00a510" translate="yes" xml:space="preserve">
          <source>IsLower reports whether the rune is a lower case letter.</source>
          <target state="translated">IsLower报告符文是否为小写字母。</target>
        </trans-unit>
        <trans-unit id="e316f3e3a4a4a943e13f969fe03fe3e6888a42f0" translate="yes" xml:space="preserve">
          <source>IsMark reports whether the rune is a mark character (category M).</source>
          <target state="translated">IsMark报告该符文是否为标记字符(类别M)。</target>
        </trans-unit>
        <trans-unit id="e919a8a1e5af711657ece2a09a282e053c84e876" translate="yes" xml:space="preserve">
          <source>IsMulticast reports whether ip is a multicast address.</source>
          <target state="translated">IsMulticast报告ip是否为多播地址。</target>
        </trans-unit>
        <trans-unit id="0d71475a6ac8cde45586a2e1ee4e9f1a73195c46" translate="yes" xml:space="preserve">
          <source>IsNaN reports whether either real(x) or imag(x) is NaN and neither is an infinity.</source>
          <target state="translated">IsNaN报告real(x)或imag(x)是否为NaN,且都不是无穷大。</target>
        </trans-unit>
        <trans-unit id="51cb1fb375010c76e1d272e937551b9aa294ed29" translate="yes" xml:space="preserve">
          <source>IsNaN reports whether f is an IEEE 754 &amp;ldquo;not-a-number&amp;rdquo; value.</source>
          <target state="translated">IsNaN报告f是否为IEEE 754&amp;ldquo;非数字&amp;rdquo;值。</target>
        </trans-unit>
        <trans-unit id="e6682a80abf1bf240c434de0a86adc44d2b4fa9e" translate="yes" xml:space="preserve">
          <source>IsNaN reports whether v is the JavaScript value &quot;NaN&quot;.</source>
          <target state="translated">IsNaN报告v是否为JavaScript值 &quot;NaN&quot;。</target>
        </trans-unit>
        <trans-unit id="8a70a6c8c78f197d95d9931060aaaff0e1ad7ace" translate="yes" xml:space="preserve">
          <source>IsNil reports whether its argument v is nil. The argument must be a chan, func, interface, map, pointer, or slice value; if it is not, IsNil panics. Note that IsNil is not always equivalent to a regular comparison with nil in Go. For example, if v was created by calling ValueOf with an uninitialized interface variable i, i==nil will be true but v.IsNil will panic as v will be the zero Value.</source>
          <target state="translated">IsNil报告它的参数v是否为nil,参数必须是chan、func、接口、map、指针或片值。参数必须是 chan、func、接口、map、指针或 slice 值;如果不是,IsNil 就会慌乱。注意,IsNil并不总是等同于Go中与nil的常规比较。例如,如果v是用一个未初始化的接口变量i调用ValueOf创建的,i==nil将为真,但v.IsNil将恐慌,因为v将是零值。</target>
        </trans-unit>
        <trans-unit id="d1cbf137d274a495776ae13213f6abf32b87d01c" translate="yes" xml:space="preserve">
          <source>IsNil reports whether the corresponding expression denotes the predeclared value nil.</source>
          <target state="translated">IsNil报告对应的表达式是否表示预声明的值为nil。</target>
        </trans-unit>
        <trans-unit id="299ff42ffbb3020ccb3e165c3f47990aa016cf3b" translate="yes" xml:space="preserve">
          <source>IsNotExist</source>
          <target state="translated">IsNotExist</target>
        </trans-unit>
        <trans-unit id="03c20e37da945e513d60a4c872afa073a5099855" translate="yes" xml:space="preserve">
          <source>IsNotExist returns a boolean indicating whether the error is known to report that a file or directory does not exist. It is satisfied by ErrNotExist as well as some syscall errors.</source>
          <target state="translated">IsNotExist 返回一个布尔值,表示是否已知错误,报告一个文件或目录不存在。它被ErrNotExist以及一些系统调用错误所满足。</target>
        </trans-unit>
        <trans-unit id="05e6aafd3bbc506bf83192365d5b5ee27918dfa7" translate="yes" xml:space="preserve">
          <source>IsNull reports whether v is the JavaScript value &quot;null&quot;.</source>
          <target state="translated">IsNull报告v是否为JavaScript值 &quot;null&quot;。</target>
        </trans-unit>
        <trans-unit id="f2c323038256b2a2953181c6a475ccd896ada404" translate="yes" xml:space="preserve">
          <source>IsNumber reports whether the rune is a number (category N).</source>
          <target state="translated">IsNumber报告符文是否为数字(类别N)。</target>
        </trans-unit>
        <trans-unit id="245475f668f23bbed41324e2de1b4948cc531ddc" translate="yes" xml:space="preserve">
          <source>IsOneOf reports whether the rune is a member of one of the ranges. The function &quot;In&quot; provides a nicer signature and should be used in preference to IsOneOf.</source>
          <target state="translated">IsOneOf报告该符文是否是其中一个范围的成员。函数 &quot;In &quot;提供了一个更好的签名,应该优先于IsOneOf使用。</target>
        </trans-unit>
        <trans-unit id="a20bd2f5568b340e7370b04b798bc3f83596bcce" translate="yes" xml:space="preserve">
          <source>IsOperator returns true for tokens corresponding to operators and delimiters; it returns false otherwise.</source>
          <target state="translated">对于与运算符和定界符相对应的标记,IsOperator返回true;否则返回false。</target>
        </trans-unit>
        <trans-unit id="73c5624da9ca6fbf3e420dbf86786a852cc89a14" translate="yes" xml:space="preserve">
          <source>IsPathSeparator reports whether c is a directory separator character.</source>
          <target state="translated">IsPathSeparator报告c是否是目录分隔符。</target>
        </trans-unit>
        <trans-unit id="8bd40ac27999a79bc28cf90f839e43d8f9372279" translate="yes" xml:space="preserve">
          <source>IsPermission returns a boolean indicating whether the error is known to report that permission is denied. It is satisfied by ErrPermission as well as some syscall errors.</source>
          <target state="translated">IsPermission返回一个布尔值,表示是否已知错误,报告权限被拒绝。它由ErrPermission以及一些系统调用错误来满足。</target>
        </trans-unit>
        <trans-unit id="ba016d3b011cf2a354ca328ddbed33673e5c990a" translate="yes" xml:space="preserve">
          <source>IsPlusBuild reports whether the line of text is a &amp;ldquo;// +build&amp;rdquo; constraint. It only checks the prefix of the text, not that the expression itself parses.</source>
          <target state="translated">IsPlusBuild报告文本行是否为&amp;ldquo; // + build&amp;rdquo;约束。它仅检查文本的前缀，而不检查表达式本身进行分析。</target>
        </trans-unit>
        <trans-unit id="e48f3df15b49da83d51099ad5b3eb8bbfd8edc75" translate="yes" xml:space="preserve">
          <source>IsPredeclared reports whether s is a predeclared identifier.</source>
          <target state="translated">IsPredeclared报告s是否是一个预先声明的标识符。</target>
        </trans-unit>
        <trans-unit id="36ebaf4d189aca534d273d48d5ddeec782d7bed9" translate="yes" xml:space="preserve">
          <source>IsPrint</source>
          <target state="translated">IsPrint</target>
        </trans-unit>
        <trans-unit id="9798b863454466bfa901e359486dca8125aebd8e" translate="yes" xml:space="preserve">
          <source>IsPrint reports whether the rune is defined as printable by Go, with the same definition as unicode.IsPrint: letters, numbers, punctuation, symbols and ASCII space.</source>
          <target state="translated">IsPrint报告符文是否被围棋定义为可打印,定义与unicode相同.IsPrint:字母、数字、标点符号、符号和ASCII空间。</target>
        </trans-unit>
        <trans-unit id="98481c27a5fae0a861fa7de3b6778c4d86a82e18" translate="yes" xml:space="preserve">
          <source>IsPrint reports whether the rune is defined as printable by Go. Such characters include letters, marks, numbers, punctuation, symbols, and the ASCII space character, from categories L, M, N, P, S and the ASCII space character. This categorization is the same as IsGraphic except that the only spacing character is ASCII space, U+0020.</source>
          <target state="translated">IsPrint报告该符文是否被围棋定义为可打印字符。这类字符包括字母、标记、数字、标点符号、符号和ASCII空格字符,来自L、M、N、P、S类和ASCII空格字符。这种分类与IsGraphic相同,只是唯一的间隔字符是ASCII空格,U+0020。</target>
        </trans-unit>
        <trans-unit id="8d669f2d873d45ac65ae33ba5fc527f66e56a570" translate="yes" xml:space="preserve">
          <source>IsPunct reports whether the rune is a Unicode punctuation character (category P).</source>
          <target state="translated">IsPunct报告符文是否是Unicode标点符号(类别P)。</target>
        </trans-unit>
        <trans-unit id="09f51db22f739274d216b281ce628857122cde77" translate="yes" xml:space="preserve">
          <source>IsRegular reports whether m describes a regular file. That is, it tests that no mode type bits are set.</source>
          <target state="translated">IsRegular报告m是否描述一个常规文件。也就是说,它测试是否没有设置模式类型位。</target>
        </trans-unit>
        <trans-unit id="7aa02fb0658d675b5c73f5d774f227af20e5eda3" translate="yes" xml:space="preserve">
          <source>IsScanValue is equivalent to IsValue. It exists for compatibility.</source>
          <target state="translated">IsScanValue相当于IsValue。它的存在是为了兼容。</target>
        </trans-unit>
        <trans-unit id="02fd007fd97349a8b2fafa3e48b3fe7f504ea24c" translate="yes" xml:space="preserve">
          <source>IsSorted reports whether data is sorted.</source>
          <target state="translated">IsSorted报告数据是否已排序。</target>
        </trans-unit>
        <trans-unit id="514d21d401add5f58b109e05d3a8a2615962f831" translate="yes" xml:space="preserve">
          <source>IsSpace reports whether the rune is a space character as defined by Unicode's White Space property; in the Latin-1 space this is</source>
          <target state="translated">IsSpace报告符文是否是Unicode白色空间属性所定义的空间字符;在Latin-1空间中,这就是</target>
        </trans-unit>
        <trans-unit id="b8364c32e39bc01deb2db29de008f790b53e0511" translate="yes" xml:space="preserve">
          <source>IsSurrogate reports whether the specified Unicode code point can appear in a surrogate pair.</source>
          <target state="translated">IsSurrogate报告指定的Unicode码点是否可以出现在代理对中。</target>
        </trans-unit>
        <trans-unit id="94ff69a73ee80e68160fc5d14463531f326feb1a" translate="yes" xml:space="preserve">
          <source>IsSymbol reports whether the rune is a symbolic character.</source>
          <target state="translated">IsSymbol报告符文是否是一个符号字符。</target>
        </trans-unit>
        <trans-unit id="80e8a9046c478caac6544a67a67898f6f56d102d" translate="yes" xml:space="preserve">
          <source>IsTimeout returns a boolean indicating whether the error is known to report that a timeout occurred.</source>
          <target state="translated">IsTimeout 返回一个布尔值,表示是否已知错误,报告发生超时。</target>
        </trans-unit>
        <trans-unit id="5dae031aae8f79fce18391198feff6e45790996f" translate="yes" xml:space="preserve">
          <source>IsTitle reports whether the rune is a title case letter.</source>
          <target state="translated">IsTitle报告该符文是否为标题大小写。</target>
        </trans-unit>
        <trans-unit id="47cdd782e568065cbc896003cc3080e6fa343e64" translate="yes" xml:space="preserve">
          <source>IsTrue reports whether the value is 'true', in the sense of not the zero of its type, and whether the value has a meaningful truth value. This is the definition of truth used by if and other such actions.</source>
          <target state="translated">IsTrue报告该值是否为 &quot;真&quot;,即不是其类型的零,以及该值是否有一个有意义的真值。这是if和其他此类操作使用的真值定义。</target>
        </trans-unit>
        <trans-unit id="f386d0c906e9366cb699b0ae4451bc9d70023dc4" translate="yes" xml:space="preserve">
          <source>IsType reports whether the corresponding expression specifies a type.</source>
          <target state="translated">IsType报告对应的表达式是否指定了一个类型。</target>
        </trans-unit>
        <trans-unit id="bd72caa363338547d5699b96c1b4ac80c8cd24c1" translate="yes" xml:space="preserve">
          <source>IsUint64 reports whether x can be represented as a uint64.</source>
          <target state="translated">IsUint64报告x是否可以用uint64表示。</target>
        </trans-unit>
        <trans-unit id="85a3cd11f8d331b3763c1e34e0ce1cfca9c37e79" translate="yes" xml:space="preserve">
          <source>IsUndefined reports whether v is the JavaScript value &quot;undefined&quot;.</source>
          <target state="translated">IsUndefined报告v是否为JavaScript值 &quot;undefined&quot;。</target>
        </trans-unit>
        <trans-unit id="6b3721da2086f5e9441475d80b1c204e06489512" translate="yes" xml:space="preserve">
          <source>IsUnspecified reports whether ip is an unspecified address, either the IPv4 address &quot;0.0.0.0&quot; or the IPv6 address &quot;::&quot;.</source>
          <target state="translated">IsUnspecified报告ip是否是一个未指定的地址,可以是IPv4地址 &quot;0.0.0.0&quot;,也可以是IPv6地址&quot;::&quot;。</target>
        </trans-unit>
        <trans-unit id="b72d29b8198db403c8169f5f00434fb729acb678" translate="yes" xml:space="preserve">
          <source>IsUpper reports whether the rune is an upper case letter.</source>
          <target state="translated">IsUpper报告符文是否是大写字母。</target>
        </trans-unit>
        <trans-unit id="ecc382ac4eeae90631c4ff786a142c8cd4a2a1e3" translate="yes" xml:space="preserve">
          <source>IsValid reports whether the position is valid.</source>
          <target state="translated">IsValid报告该位置是否有效。</target>
        </trans-unit>
        <trans-unit id="fa9386e1dba484fd3efd4626c53284c1fe827e1b" translate="yes" xml:space="preserve">
          <source>IsValid reports whether v represents a value. It returns false if v is the zero Value. If IsValid returns false, all other methods except String panic. Most functions and methods never return an invalid Value. If one does, its documentation states the conditions explicitly.</source>
          <target state="translated">IsValid报告v是否代表一个值。如果v是零值,它返回false。如果IsValid返回false,除了String以外的所有其他方法都会惊慌失措。大多数函数和方法都不会返回无效值。如果有一个方法返回无效值,它的文档会明确说明条件。</target>
        </trans-unit>
        <trans-unit id="6b4d65bab951e443a5b5a6cb70b5527aa329d397" translate="yes" xml:space="preserve">
          <source>IsValid reports whether v represents a value. It returns false if v is the zero Value. If IsValid returns false, all other methods except String panic. Most functions and methods never return an invalid value. If one does, its documentation states the conditions explicitly.</source>
          <target state="translated">IsValid报告v是否代表一个值。如果v是零值,它返回false。如果IsValid返回false,除了String以外的所有其他方法都会惊慌失措。大多数函数和方法从不返回无效值。如果有一个方法返回无效值,它的文档会明确说明条件。</target>
        </trans-unit>
        <trans-unit id="55d30ff7d3d863a32468776759178dbe0451ccce" translate="yes" xml:space="preserve">
          <source>IsValue reports whether the corresponding expression is a value. Builtins are not considered values. Constant values have a non- nil Value.</source>
          <target state="translated">IsValue报告对应的表达式是否是一个值。内置值不被认为是值。常量值的值是非零。</target>
        </trans-unit>
        <trans-unit id="9d7a5d3a7652824e4f9b549a7d5a262a10ef59c5" translate="yes" xml:space="preserve">
          <source>IsValue reports whether v is a valid Value parameter type.</source>
          <target state="translated">IsValue报告v是否是一个有效的Value参数类型。</target>
        </trans-unit>
        <trans-unit id="65e1a871482dad54f08e17dd72762a3fd2f75d74" translate="yes" xml:space="preserve">
          <source>IsVoid reports whether the corresponding expression is a function call without results.</source>
          <target state="translated">IsVoid报告对应的表达式是否是一个没有结果的函数调用。</target>
        </trans-unit>
        <trans-unit id="297c16f9ae029663b610c3b616363007a062b053" translate="yes" xml:space="preserve">
          <source>IsWordChar reports whether r is consider a &amp;ldquo;word character&amp;rdquo; during the evaluation of the \b and \B zero-width assertions. These assertions are ASCII-only: the word characters are [A-Za-z0-9_].</source>
          <target state="translated">IsWordChar报告在评估\ b和\ B零宽度断言期间r是否被视为&amp;ldquo;单词字符&amp;rdquo;。这些断言仅是ASCII：字字符是[A-Za-z0-9_]。</target>
        </trans-unit>
        <trans-unit id="5f0397c5af2b47c485a6cac89d344b49d39148e5" translate="yes" xml:space="preserve">
          <source>IsZero reports whether t represents the zero time instant, January 1, year 1, 00:00:00 UTC.</source>
          <target state="translated">IsZero报告t是否代表零时间瞬间,1年1月1日00:00:00 UTC。</target>
        </trans-unit>
        <trans-unit id="14b29f8979f8b38e486b8c2fc265fcec75315a1b" translate="yes" xml:space="preserve">
          <source>IsZero reports whether v is the zero value for its type. It panics if the argument is invalid.</source>
          <target state="translated">IsZero报告v是否是其类型的零值。如果参数无效,它就会惊慌失措。</target>
        </trans-unit>
        <trans-unit id="2e5ba7b50d53dc66de9ac76f94ae84e19ac42a4e" translate="yes" xml:space="preserve">
          <source>IsolationLevel is the transaction isolation level stored in TxOptions.</source>
          <target state="translated">IsolationLevel是存储在TxOptions中的事务隔离级别。</target>
        </trans-unit>
        <trans-unit id="00b8885e61c34531225b38e32ae41a763eb82a05" translate="yes" xml:space="preserve">
          <source>IsolationLevel is the transaction isolation level used in TxOptions.</source>
          <target state="translated">IsolationLevel是TxOptions中使用的事务隔离级别。</target>
        </trans-unit>
        <trans-unit id="d76fb5eb8c221bc52330dc2413a54b325f8af681" translate="yes" xml:space="preserve">
          <source>It does nothing if the URL's scheme is not HTTP or HTTPS.</source>
          <target state="translated">如果URL的方案不是HTTP或HTTPS,它不会做任何事情。</target>
        </trans-unit>
        <trans-unit id="730fc66fc7c6f8658abbd279912d4debd6897a14" translate="yes" xml:space="preserve">
          <source>It is allowed but not required for the caller to hold c.L during the call.</source>
          <target state="translated">在通话过程中,允许但不要求呼叫者保持c.L。</target>
        </trans-unit>
        <trans-unit id="64b18effbf60d196d9c9972b0f4752ad49d90515" translate="yes" xml:space="preserve">
          <source>It is allowed to call Notify multiple times with different channels and the same signals: each channel receives copies of incoming signals independently.</source>
          <target state="translated">允许用不同的频道和相同的信号多次调用Notify:每个频道独立接收接收信号的副本。</target>
        </trans-unit>
        <trans-unit id="2b72f5a15cc86252895b6a5820ed7c36974cccb2" translate="yes" xml:space="preserve">
          <source>It is allowed to call Notify multiple times with the same channel: each call expands the set of signals sent to that channel. The only way to remove signals from the set is to call Stop.</source>
          <target state="translated">允许用同一个通道多次调用Notify:每次调用都会扩大发送到该通道的信号集。从集合中删除信号的唯一方法是调用Stop。</target>
        </trans-unit>
        <trans-unit id="64b9ab50226fefd57abe4e106fe4fbde6d348569" translate="yes" xml:space="preserve">
          <source>It is defined in RFC 1950:</source>
          <target state="translated">它的定义在RFC 1950中。</target>
        </trans-unit>
        <trans-unit id="3527f9b32341885623b87c38f5f98392bdedd8dc" translate="yes" xml:space="preserve">
          <source>It is equivalent to SplitAfterN with a count of -1.</source>
          <target state="translated">它相当于SplitAfterN的计数为-1。</target>
        </trans-unit>
        <trans-unit id="dbac3455f5dcff27b15907e612c36dc6d6627118" translate="yes" xml:space="preserve">
          <source>It is equivalent to SplitN with a count of -1.</source>
          <target state="translated">它相当于数为-1的SplitN。</target>
        </trans-unit>
        <trans-unit id="9bc89c86db3c02e15ec65887cfcf0cc312b36a24" translate="yes" xml:space="preserve">
          <source>It is not associated with any particular color profile.</source>
          <target state="translated">它不与任何特定的颜色配置文件相关联。</target>
        </trans-unit>
        <trans-unit id="8b9cf269b7a066efe335dc4941105afdd2791a76" translate="yes" xml:space="preserve">
          <source>It is not guaranteed that a finalizer will run for objects allocated in initializers for package-level variables. Such objects may be linker-allocated, not heap-allocated.</source>
          <target state="translated">并不能保证最终确定器会为包级变量的初始化器中分配的对象运行。这些对象可能是链接器分配的,而不是堆分配的。</target>
        </trans-unit>
        <trans-unit id="185afc47d5312f1df75d7c2e1fd8c497c93c1bee" translate="yes" xml:space="preserve">
          <source>It is not guaranteed that a finalizer will run if the size of *obj is zero bytes.</source>
          <target state="translated">如果*obj的大小为零字节,则不能保证最终程序会运行。</target>
        </trans-unit>
        <trans-unit id="e276973efe0e06473fcbf2184470a55ce905f9ea" translate="yes" xml:space="preserve">
          <source>It is rare to Close a DB, as the DB handle is meant to be long-lived and shared between many goroutines.</source>
          <target state="translated">关闭一个DB是很罕见的,因为DB句柄是要长期存在的,并且在许多goroutine之间共享。</target>
        </trans-unit>
        <trans-unit id="9a7d91a6cfdd5d25c7a9aebf66715a0621fd64e1" translate="yes" xml:space="preserve">
          <source>It is safe to call Dialer's methods concurrently.</source>
          <target state="translated">同时调用Dialer的方法是安全的。</target>
        </trans-unit>
        <trans-unit id="13c70c7692f708ab80a79d217ba3b943c3b63874" translate="yes" xml:space="preserve">
          <source>It is safe to call Read and Write in parallel with each other or with Close. Parallel calls to Read and parallel calls to Write are also safe: the individual calls will be gated sequentially.</source>
          <target state="translated">相互之间或与Close并行调用Read和Write是安全的。平行调用Read和平行调用Write也是安全的:各个调用将按顺序进行门控。</target>
        </trans-unit>
        <trans-unit id="fdb69e790ac12df4afc740ea8ac0b288915135a0" translate="yes" xml:space="preserve">
          <source>It is safe to execute multiple Read calls concurrently, but their arguments must share no underlying memory. When in doubt, create a new []Sample from scratch, which is always safe, though may be inefficient.</source>
          <target state="translated">同时执行多个Read调用是安全的,但它们的参数不能共享底层内存。当有疑问时,从头开始创建一个新的[]Sample,这总是安全的,尽管可能效率很低。</target>
        </trans-unit>
        <trans-unit id="8e87bdde62b3a11cc618f6eef7d1ef7e95ea027e" translate="yes" xml:space="preserve">
          <source>It is sometimes necessary for a test program to do extra setup or teardown before or after testing. It is also sometimes necessary for a test to control which code runs on the main thread. To support these and other cases, if a test file contains a function:</source>
          <target state="translated">有时,测试程序需要在测试前或测试后进行额外的设置或拆卸。有时,测试也需要控制哪些代码在主线程上运行。为了支持这些和其他情况,如果一个测试文件包含一个函数。</target>
        </trans-unit>
        <trans-unit id="c4c640b2d1c13408fc0addbe9ca9b3e33c914d4c" translate="yes" xml:space="preserve">
          <source>It is the caller's responsibility to call Close on the Reader when done.</source>
          <target state="translated">呼叫者有责任在完成后呼叫关闭阅读器。</target>
        </trans-unit>
        <trans-unit id="986480998eaebed4b6a54647e1482613d046d84f" translate="yes" xml:space="preserve">
          <source>It is the caller's responsibility to call Close on the Writer when done. Writes may be buffered and not flushed until Close.</source>
          <target state="translated">调用者有责任在完成后对Writer调用Close。写作可能会被缓冲,直到关闭时才会被刷新。</target>
        </trans-unit>
        <trans-unit id="5d5e9d1ff14ea8de0b89e8865f3f584d482a0afe" translate="yes" xml:space="preserve">
          <source>It is useful mainly in compressed network protocols, to ensure that a remote reader has enough data to reconstruct a packet. Flush does not return until the data has been written. If the underlying writer returns an error, Flush returns that error.</source>
          <target state="translated">它主要在压缩网络协议中有用,以确保远程阅读器有足够的数据来重建数据包。在数据被写入之前,Flush不会返回。如果底层写入器返回一个错误,Flush就会返回该错误。</target>
        </trans-unit>
        <trans-unit id="31cc99464ed62136a451655119e840afa7451b83" translate="yes" xml:space="preserve">
          <source>It is valid both to add and to subtract offsets from a pointer in this way. It is also valid to use &amp;amp;^ to round pointers, usually for alignment. In all cases, the result must continue to point into the original allocated object.</source>
          <target state="translated">以这种方式从指针添加和减去偏移量都是有效的。通常使用＆^舍入指针（通常用于对齐）也是有效的。在所有情况下，结果都必须继续指向原始分配的对象。</target>
        </trans-unit>
        <trans-unit id="dd1e16d418b70f8a4bcbc355b1da37369ffe8113" translate="yes" xml:space="preserve">
          <source>It makes one call to data.Len to determine n, O(n*log(n)) calls to data.Less and O(n*log(n)*log(n)) calls to data.Swap.</source>
          <target state="translated">它对data.Len进行一次调用以确定n,对data.Less进行O(n*log(n))调用,对data.Swap进行O(n*log(n)*log(n))调用。</target>
        </trans-unit>
        <trans-unit id="49a3b03dcb3864c71030445c5ba5bfe2611711d2" translate="yes" xml:space="preserve">
          <source>It may also be received into any of these:</source>
          <target state="translated">也可以接收到其中的任何一种。</target>
        </trans-unit>
        <trans-unit id="7b88fc3e61debf0d0f1a1581e71a0996edf539a5" translate="yes" xml:space="preserve">
          <source>It panics if count is negative or if the result of (len(b) * count) overflows.</source>
          <target state="translated">如果count为负值或者(len(b)*count)的结果溢出,它就会恐慌。</target>
        </trans-unit>
        <trans-unit id="8b61a1a4bb411ee036d7d3cc509678ace33cef83" translate="yes" xml:space="preserve">
          <source>It panics if count is negative or if the result of (len(s) * count) overflows.</source>
          <target state="translated">如果count为负值或者(len(s)*count)的结果溢出,它就会恐慌。</target>
        </trans-unit>
        <trans-unit id="652db58383317d0338f369bbd62022ed3ab07600" translate="yes" xml:space="preserve">
          <source>It panics if the Value was obtained by accessing unexported struct fields.</source>
          <target state="translated">如果该值是通过访问未导出的结构体字段获得的,它就会恐慌。</target>
        </trans-unit>
        <trans-unit id="564d342d70ea92defe3199a234b7ca21ece54f95" translate="yes" xml:space="preserve">
          <source>It returns a *rsa.PrivateKey, a *ecdsa.PrivateKey, or a ed25519.PrivateKey. More types might be supported in the future.</source>
          <target state="translated">它返回一个*rsa.PrivateKey,一个*ecdsa.PrivateKey,或一个ed25519.PrivateKey。将来可能会支持更多的类型。</target>
        </trans-unit>
        <trans-unit id="9f11d9cd546ed2abe8e697fa6f8bbdc2a3d2e5ef" translate="yes" xml:space="preserve">
          <source>It returns a *rsa.PublicKey, *dsa.PublicKey, *ecdsa.PublicKey, or ed25519.PublicKey. More types might be supported in the future.</source>
          <target state="translated">它返回一个*rsa.PublicKey、*dsa.PublicKey、*ecdsa.PublicKey或ed25519.PublicKey。未来可能会支持更多类型。</target>
        </trans-unit>
        <trans-unit id="e5010d434ca33dd92d7a44910817533939048059" translate="yes" xml:space="preserve">
          <source>It returns an empty slice if the URL's scheme is not HTTP or HTTPS.</source>
          <target state="translated">如果URL的方案不是HTTP或HTTPS,它返回一个空的分片。</target>
        </trans-unit>
        <trans-unit id="2b565edf53edd5e13295b4a395aad926eda82327" translate="yes" xml:space="preserve">
          <source>It returns an error if t has already been executed.</source>
          <target state="translated">如果t已经被执行,它会返回一个错误。</target>
        </trans-unit>
        <trans-unit id="a56353db7fb203c22e0bfd117b292abd05c5de94" translate="yes" xml:space="preserve">
          <source>It returns an error if t or any associated template has already been executed.</source>
          <target state="translated">如果t或任何相关模板已经被执行,它将返回一个错误。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
