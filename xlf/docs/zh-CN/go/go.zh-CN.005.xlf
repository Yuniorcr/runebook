<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="go">
    <body>
      <group id="go">
        <trans-unit id="e6a6e8cadfebe9c4799e999d069f9213bb24bed9" translate="yes" xml:space="preserve">
          <source>FuncOf</source>
          <target state="translated">FuncOf</target>
        </trans-unit>
        <trans-unit id="d863a41e98edea4d63050f4d41d85e38ee53432a" translate="yes" xml:space="preserve">
          <source>FuncOf returns a wrapped function.</source>
          <target state="translated">FuncOf返回一个封装的函数。</target>
        </trans-unit>
        <trans-unit id="93a168211e34460ad795ada01d7598344ab1ff0e" translate="yes" xml:space="preserve">
          <source>FuncOf returns the function type with the given argument and result types. For example if k represents int and e represents string, FuncOf([]Type{k}, []Type{e}, false) represents func(int) string.</source>
          <target state="translated">FuncOf返回给定参数和结果类型的函数类型。例如,如果k代表int,e代表字符串,则FuncOf([]Type{k},[]Type{e},false)代表func(int)字符串。</target>
        </trans-unit>
        <trans-unit id="e545c5b7597389c332937a417c6dbb10d7b9c2b9" translate="yes" xml:space="preserve">
          <source>Funcs adds the elements of the argument map to the template's function map. It must be called before the template is parsed. It panics if a value in the map is not a function with appropriate return type or if the name cannot be used syntactically as a function in a template. It is legal to overwrite elements of the map. The return value is the template, so calls can be chained.</source>
          <target state="translated">Funcs将参数映射的元素添加到模板的函数映射中。它必须在模板被解析之前被调用。如果映射中的一个值不是一个具有适当返回类型的函数,或者如果该名称在模板中不能作为函数的语法使用,它就会恐慌。覆盖地图中的元素是合法的。返回值是模板,所以可以连锁调用。</target>
        </trans-unit>
        <trans-unit id="d356e92562acfcaf97196969d96dd79e05dacf25" translate="yes" xml:space="preserve">
          <source>Funcs adds the elements of the argument map to the template's function map. It must be called before the template is parsed. It panics if a value in the map is not a function with appropriate return type. However, it is legal to overwrite elements of the map. The return value is the template, so calls can be chained.</source>
          <target state="translated">Funcs将参数映射的元素添加到模板的函数映射中。它必须在模板被解析之前被调用。如果映射中的一个值不是具有适当返回类型的函数,它就会恐慌。然而,覆盖地图中的元素是合法的。返回值是模板,所以可以连锁调用。</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="8c10d9660a016948a806bd8cbcad3722d8e6bc88" translate="yes" xml:space="preserve">
          <source>Functions and channels will not be sent in a gob. Attempting to encode such a value at the top level will fail. A struct field of chan or func type is treated exactly like an unexported field and is ignored.</source>
          <target state="translated">功能和通道将不会在gob中发送。试图在顶层对这样的值进行编码会失败。chan或func类型的结构体字段将被视为与未导出的字段完全相同,并被忽略。</target>
        </trans-unit>
        <trans-unit id="515fb65b2b3a55f3a5ea9024aecd183d10145a5b" translate="yes" xml:space="preserve">
          <source>Functions of the form</source>
          <target state="translated">形式的功能</target>
        </trans-unit>
        <trans-unit id="5bde1b79ff9cf2a64313aa293a07d05136a9d65d" translate="yes" xml:space="preserve">
          <source>Functions starting with &quot;Is&quot; can be used to inspect which table of range a rune belongs to. Note that runes may fit into more than one range.</source>
          <target state="translated">以 &quot;Is &quot;开头的函数可以用来检查一个符文属于哪个范围表。请注意,符文可能适合于一个以上的范围。</target>
        </trans-unit>
        <trans-unit id="14038939956e123c4daa0060310ed80bf1b7a49d" translate="yes" xml:space="preserve">
          <source>GC runs a garbage collection and blocks the caller until the garbage collection is complete. It may also block the entire program.</source>
          <target state="translated">GC运行一个垃圾收集,并阻止调用者,直到垃圾收集完成。它也可能阻塞整个程序。</target>
        </trans-unit>
        <trans-unit id="c1dacc63b01c8608c5a77320640ce147950f96e1" translate="yes" xml:space="preserve">
          <source>GCD sets z to the greatest common divisor of a and b, which both must be &amp;gt; 0, and returns z. If x or y are not nil, GCD sets their value such that z = a*x + b*y. If either a or b is &amp;lt;= 0, GCD sets z = x = y = 0.</source>
          <target state="translated">GCD将z设置为a和b的最大公约数（都必须大于0），并返回z。如果x或y不为零，则GCD将其值设置为z = a * x + b * y。如果a或b &amp;lt;= 0，则GCD设置z = x = y = 0。</target>
        </trans-unit>
        <trans-unit id="19dd357da96d7272320f7fadf3fd2965c024dba5" translate="yes" xml:space="preserve">
          <source>GCStats collect information about recent garbage collections.</source>
          <target state="translated">GCStats收集最近的垃圾收集信息。</target>
        </trans-unit>
        <trans-unit id="d010209a0c3d0dee637f5259dfa34515f68772df" translate="yes" xml:space="preserve">
          <source>GIF represents the possibly multiple images stored in a GIF file.</source>
          <target state="translated">GIF代表了存储在GIF文件中的可能的多个图像。</target>
        </trans-unit>
        <trans-unit id="f62024646db1c94f452ef8c25337fad08f62d18e" translate="yes" xml:space="preserve">
          <source>GOARCH is the running program's architecture target: one of 386, amd64, arm, s390x, and so on.</source>
          <target state="translated">GOARCH是运行程序的架构目标:386、amd64、arm、s390x等中的一种。</target>
        </trans-unit>
        <trans-unit id="cb34b31ce447e79881d19460e35c7075fc05a81a" translate="yes" xml:space="preserve">
          <source>GOMAXPROCS sets the maximum number of CPUs that can be executing simultaneously and returns the previous setting. If n &amp;lt; 1, it does not change the current setting. The number of logical CPUs on the local machine can be queried with NumCPU. This call will go away when the scheduler improves.</source>
          <target state="translated">GOMAXPROCS设置可以同时执行的最大CPU数，并返回以前的设置。如果n &amp;lt;1，则不会更改当前设置。可以使用NumCPU查询本地计算机上的逻辑CPU数量。调度程序改进后，此呼叫将消失。</target>
        </trans-unit>
        <trans-unit id="ad65293e987b4a4c08430d0e000aecbc1854ac24" translate="yes" xml:space="preserve">
          <source>GOOS is the running program's operating system target: one of darwin, freebsd, linux, and so on. To view possible combinations of GOOS and GOARCH, run &quot;go tool dist list&quot;.</source>
          <target state="translated">GOOS是运行程序的操作系统目标:darwin、freebsd、linux等之一。要查看GOOS和GOARCH的可能组合,运行 &quot;go tool dist list&quot;。</target>
        </trans-unit>
        <trans-unit id="7bb230fcc10199af1bb88085306db7998e9674cd" translate="yes" xml:space="preserve">
          <source>GOROOT returns the root of the Go tree. It uses the GOROOT environment variable, if set at process start, or else the root used during the Go build.</source>
          <target state="translated">GOROOT 返回 Go 树的根。如果在进程启动时设置了GOROOT环境变量,则使用GOROOT环境变量,否则使用Go构建过程中使用的根。</target>
        </trans-unit>
        <trans-unit id="3552a70e477a364f8e82a292dad18f46a2ad988b" translate="yes" xml:space="preserve">
          <source>Gamma returns the Gamma function of x.</source>
          <target state="translated">Gamma 返回 x 的 Gamma 函数。</target>
        </trans-unit>
        <trans-unit id="a2672eb4dac0440844556fb66fa39b9edb2d2041" translate="yes" xml:space="preserve">
          <source>General:</source>
          <target state="translated">General:</target>
        </trans-unit>
        <trans-unit id="453efae49cba4a01a09c987414ab329ee6c4a305" translate="yes" xml:space="preserve">
          <source>Generally Get, Post, or PostForm will be used instead of Do.</source>
          <target state="translated">一般会用Get、Post或PostForm来代替Do。</target>
        </trans-unit>
        <trans-unit id="1c57b54aace051c9a60fd146f5087c013aa2d721" translate="yes" xml:space="preserve">
          <source>GenerateKey generates a public and private key pair.</source>
          <target state="translated">GenerateKey生成一个公钥和私钥对。</target>
        </trans-unit>
        <trans-unit id="db1ff76045ebe9cc510f3c31601ddcbcd7fd57de" translate="yes" xml:space="preserve">
          <source>GenerateKey generates a public&amp;amp;private key pair. The Parameters of the PrivateKey must already be valid (see GenerateParameters).</source>
          <target state="translated">GenerateKey生成一个公共和私有密钥对。私钥的参数必须已经有效（请参见GenerateParameters）。</target>
        </trans-unit>
        <trans-unit id="e650907b55be64a19300b70e59344d22b7245e9b" translate="yes" xml:space="preserve">
          <source>GenerateKey generates a public/private key pair using entropy from rand. If rand is nil, crypto/rand.Reader will be used.</source>
          <target state="translated">GenerateKey使用rand的熵生成一个公钥/私钥对。如果rand为nil,将使用crypto/rand.Reader。</target>
        </trans-unit>
        <trans-unit id="7f11f0f6942fab0ca9f944e5798d7d37395d774c" translate="yes" xml:space="preserve">
          <source>GenerateKey generates an RSA keypair of the given bit size using the random source random (for example, crypto/rand.Reader).</source>
          <target state="translated">GenerateKey使用随机源随机(例如,crypto/rand.Reader)生成给定比特大小的RSA密钥对。</target>
        </trans-unit>
        <trans-unit id="80806cb0e126f8dd45cfba36eccecc7429a61358" translate="yes" xml:space="preserve">
          <source>GenerateKey returns a public/private key pair. The private key is generated using the given reader, which must return random data.</source>
          <target state="translated">GenerateKey返回一个公钥/私钥对。私钥是用给定的读取器生成的,读取器必须返回随机数据。</target>
        </trans-unit>
        <trans-unit id="94cfc2c7f30a1879e413d8411b7005501c966655" translate="yes" xml:space="preserve">
          <source>GenerateMultiPrimeKey generates a multi-prime RSA keypair of the given bit size and the given random source, as suggested in [1]. Although the public keys are compatible (actually, indistinguishable) from the 2-prime case, the private keys are not. Thus it may not be possible to export multi-prime private keys in certain formats or to subsequently import them into other code.</source>
          <target state="translated">GenerateMultiPrimeKey按照[1]中的建议,生成给定比特大小和给定随机源的多主RSA密钥对。虽然公钥与2-prime情况下的公钥是兼容的(实际上是无法区分的),但私钥却不兼容。因此,不可能以某些格式导出多主密钥,也不可能随后将它们导入其他代码中。</target>
        </trans-unit>
        <trans-unit id="51625703089c85c9211c0ab627055dec67c2bfaf" translate="yes" xml:space="preserve">
          <source>GenerateParameters puts a random, valid set of DSA parameters into params. This function can take many seconds, even on fast machines.</source>
          <target state="translated">GenerateParameters 将一组随机的、有效的 DSA 参数放入 params 中。这个函数可能会耗费很多秒,即使在高速机器上也是如此。</target>
        </trans-unit>
        <trans-unit id="bfffd736cddd08a4eee689949c3399cb61da773b" translate="yes" xml:space="preserve">
          <source>Get</source>
          <target state="translated">Get</target>
        </trans-unit>
        <trans-unit id="2fe964aa376032085805189a0397b3cdcf676226" translate="yes" xml:space="preserve">
          <source>Get gets the first value associated with the given key. If there are no values associated with the key, Get returns &quot;&quot;. It is case insensitive; textproto.CanonicalMIMEHeaderKey is used to canonicalize the provided key. To access multiple values of a key, or to use non-canonical keys, access the map directly.</source>
          <target state="translated">Get获取与给定键相关联的第一个值,如果没有与键相关联的值,Get返回&quot;&quot;。如果没有与key相关联的值,Get返回&quot;&quot;。它不区分大小写;textproto.CanonicalMIMEHeaderKey被用来对所提供的键进行规范化。要访问一个键的多个值,或者使用非规范键,请直接访问映射。</target>
        </trans-unit>
        <trans-unit id="5819a3dfa32fe18b54e30756235c5c0b3e71efb0" translate="yes" xml:space="preserve">
          <source>Get gets the first value associated with the given key. If there are no values associated with the key, Get returns the empty string. To access multiple values, use the map directly.</source>
          <target state="translated">Get获取与给定键相关联的第一个值,如果没有与键相关联的值,Get返回空字符串。如果没有与key相关联的值,Get返回空字符串。要访问多个值,直接使用map。</target>
        </trans-unit>
        <trans-unit id="322573da1168297393f519b4b988bc100cbe0b6c" translate="yes" xml:space="preserve">
          <source>Get gets the first value associated with the given key. It is case insensitive; CanonicalMIMEHeaderKey is used to canonicalize the provided key. If there are no values associated with the key, Get returns &quot;&quot;. To access multiple values of a key, or to use non-canonical keys, access the map directly.</source>
          <target state="translated">获取与给定key相关联的第一个值。它对大小写不敏感;CanonicalMIMEHeaderKey被用来规范化所提供的key。如果没有与key相关联的值,Get返回&quot;&quot;。要访问一个键的多个值,或者使用非规范键,直接访问映射。</target>
        </trans-unit>
        <trans-unit id="ec73d0c593dbece5412fe884185bdca68896527d" translate="yes" xml:space="preserve">
          <source>Get is a wrapper around DefaultClient.Get.</source>
          <target state="translated">Get是DefaultClient.Get的一个封装器。</target>
        </trans-unit>
        <trans-unit id="e51f2ab7d6fbd0e2ffab583f80049b3cfc794ac8" translate="yes" xml:space="preserve">
          <source>Get issues a GET to the specified URL. If the response is one of the following redirect codes, Get follows the redirect after calling the Client's CheckRedirect function:</source>
          <target state="translated">Get向指定的URL发出一个GET。如果响应是下面的重定向代码之一,Get在调用客户端的CheckRedirect函数后,会跟随重定向。</target>
        </trans-unit>
        <trans-unit id="cff58f3ccfaec37f9252515e01360ee67558791b" translate="yes" xml:space="preserve">
          <source>Get issues a GET to the specified URL. If the response is one of the following redirect codes, Get follows the redirect, up to a maximum of 10 redirects:</source>
          <target state="translated">Get向指定的URL发出一个GET。如果响应是下面的重定向代码之一,Get就会跟随重定向,最多重定向10次。</target>
        </trans-unit>
        <trans-unit id="4af41ae2934aaf3ecc571a5a758befaaf5dd46ec" translate="yes" xml:space="preserve">
          <source>Get retrieves a named exported variable. It returns nil if the name has not been registered.</source>
          <target state="translated">Get检索一个命名的导出变量。如果名称没有被注册,则返回nil。</target>
        </trans-unit>
        <trans-unit id="afa92ba06d138d5628558f74ba88a7e263aff277" translate="yes" xml:space="preserve">
          <source>Get returns the JavaScript property p of value v. It panics if v is not a JavaScript object.</source>
          <target state="translated">Get返回值v的JavaScript属性p,如果v不是JavaScript对象,它就会恐慌。</target>
        </trans-unit>
        <trans-unit id="1f152948d80d4df7cedf020669e282541979aaff" translate="yes" xml:space="preserve">
          <source>Get returns the value associated with key in the tag string. If there is no such key in the tag, Get returns the empty string. If the tag does not have the conventional format, the value returned by Get is unspecified. To determine whether a tag is explicitly set to the empty string, use Lookup.</source>
          <target state="translated">Get 返回与标签字符串中的 key 相关联的值,如果标签中没有 key,Get 返回空字符串。如果标签中没有这样的键,Get 返回空字符串。如果标记没有常规格式,则 Get 返回的值是未指定的。要确定一个标记是否被显式地设置为空字符串,请使用 Lookup。</target>
        </trans-unit>
        <trans-unit id="1c95403f4621e18fe8ba30c67d76e285e8214f43" translate="yes" xml:space="preserve">
          <source>Get selects an arbitrary item from the Pool, removes it from the Pool, and returns it to the caller. Get may choose to ignore the pool and treat it as empty. Callers should not assume any relation between values passed to Put and the values returned by Get.</source>
          <target state="translated">Get从Pool中选择一个任意的项目,从Pool中删除它,然后返回给调用者。Get可以选择忽略Pool,并将其视为空。调用者不应该假设传递给Put的值和Get返回的值之间有任何关系。</target>
        </trans-unit>
        <trans-unit id="c21e6716a05006be2a3b33da22f790cc4dacbd14" translate="yes" xml:space="preserve">
          <source>Get, Head, Post, and PostForm make HTTP (or HTTPS) requests:</source>
          <target state="translated">Get、Head、Post和PostForm进行HTTP(或HTTPS)请求。</target>
        </trans-unit>
        <trans-unit id="c5763aa4654b9f9e755a5247c7e85bd6431154eb" translate="yes" xml:space="preserve">
          <source>Getegid returns the numeric effective group id of the caller.</source>
          <target state="translated">Getegid返回调用者的有效数字组ID。</target>
        </trans-unit>
        <trans-unit id="3ce86e952faaa112161293325cc18e1e8b1d1f86" translate="yes" xml:space="preserve">
          <source>Getenv</source>
          <target state="translated">Getenv</target>
        </trans-unit>
        <trans-unit id="83272f1d9be5d707a2abc299316ecf8c20c6572e" translate="yes" xml:space="preserve">
          <source>Getenv retrieves the value of the environment variable named by the key. It returns the value, which will be empty if the variable is not present. To distinguish between an empty value and an unset value, use LookupEnv.</source>
          <target state="translated">Getenv检索由键命名的环境变量的值。它返回该值,如果变量不存在,则该值为空。要区分空值和未设置的值,使用LookupEnv。</target>
        </trans-unit>
        <trans-unit id="fb87cd5bc3aee2814b4736bc86345f331ef466ad" translate="yes" xml:space="preserve">
          <source>Geteuid returns the numeric effective user id of the caller.</source>
          <target state="translated">Geteuid返回调用者的有效数字用户ID。</target>
        </trans-unit>
        <trans-unit id="ba1ccf148fadcaa5a423e416bb3b76de027035d5" translate="yes" xml:space="preserve">
          <source>Getgid returns the numeric group id of the caller.</source>
          <target state="translated">Getgid返回调用者的数字组ID。</target>
        </trans-unit>
        <trans-unit id="1a0d3dfabc3d14d5473d84c935b43760abff4984" translate="yes" xml:space="preserve">
          <source>Getgroups returns a list of the numeric ids of groups that the caller belongs to.</source>
          <target state="translated">Getgroups返回调用者所属的组的数字id列表。</target>
        </trans-unit>
        <trans-unit id="cf37c04d335f6576ae2f027091318c6f433db063" translate="yes" xml:space="preserve">
          <source>Getpagesize returns the underlying system's memory page size.</source>
          <target state="translated">Getpagesize 返回底层系统的内存页面大小。</target>
        </trans-unit>
        <trans-unit id="98c30bd03388e6d00325569f2c09cb7a5c1f7d76" translate="yes" xml:space="preserve">
          <source>Getpid returns the process id of the caller.</source>
          <target state="translated">Getpid返回调用者的进程id。</target>
        </trans-unit>
        <trans-unit id="7d80618e0017c08138a1fb60fea1c4ec0dbcc585" translate="yes" xml:space="preserve">
          <source>Getppid returns the process id of the caller's parent.</source>
          <target state="translated">Getppid返回调用者的父进程ID。</target>
        </trans-unit>
        <trans-unit id="ed660f2b70ea9d5fc73733f3c8d0fe3252a11e78" translate="yes" xml:space="preserve">
          <source>Getter is an interface that allows the contents of a Value to be retrieved. It wraps the Value interface, rather than being part of it, because it appeared after Go 1 and its compatibility rules. All Value types provided by this package satisfy the Getter interface.</source>
          <target state="translated">Getter是一个允许检索Value内容的接口。它包装了 Value 接口,而不是它的一部分,因为它出现在 Go 1 及其兼容性规则之后。本包提供的所有 Value 类型都满足 Getter 接口。</target>
        </trans-unit>
        <trans-unit id="87c5badfd378b66a2a7ada85f8b7415911742baa" translate="yes" xml:space="preserve">
          <source>Getuid returns the numeric user id of the caller.</source>
          <target state="translated">Getuid返回调用者的数字用户ID。</target>
        </trans-unit>
        <trans-unit id="55e12168bb983e41918aba1691a9e5f495430b36" translate="yes" xml:space="preserve">
          <source>Getwd returns a rooted path name corresponding to the current directory. If the current directory can be reached via multiple paths (due to symbolic links), Getwd may return any one of them.</source>
          <target state="translated">Getwd返回一个与当前目录相对应的根路径名,如果当前目录可以通过多个路径到达(由于符号链接),Getwd可以返回其中任何一个路径。如果当前目录可以通过多个路径到达(由于符号链接),Getwd可以返回其中任何一个路径。</target>
        </trans-unit>
        <trans-unit id="db8c30ea4bb862dc2beac406c90a324c6875e53e" translate="yes" xml:space="preserve">
          <source>Given that input, ReadMIMEHeader returns the map:</source>
          <target state="translated">给定该输入,ReadMIMEHeader返回该地图。</target>
        </trans-unit>
        <trans-unit id="0d7c5c492a7ddeb919966cbf89bf311a727d8ab3" translate="yes" xml:space="preserve">
          <source>Glob ignores file system errors such as I/O errors reading directories. The only possible returned error is ErrBadPattern, when pattern is malformed.</source>
          <target state="translated">Glob 忽略文件系统错误,如 I/O 错误读取目录。唯一可能返回的错误是ErrBadPattern,当pattern是畸形的。</target>
        </trans-unit>
        <trans-unit id="5a57ea57c1f0982972dd2d2f408926f91cf67c45" translate="yes" xml:space="preserve">
          <source>Glob returns the names of all files matching pattern or nil if there is no matching file. The syntax of patterns is the same as in Match. The pattern may describe hierarchical names such as /usr/*/bin/ed (assuming the Separator is '/').</source>
          <target state="translated">Glob 返回与 pattern 匹配的所有文件的名称,如果没有匹配的文件,则返回 nil。pattern的语法与Match中的相同。模式可以描述层次名称,如/usr/*/bin/ed(假设分隔符是'/')。</target>
        </trans-unit>
        <trans-unit id="599aa1de3cf0d500e8e5f7d1a178d0ab1cc0a630" translate="yes" xml:space="preserve">
          <source>Global returns the JavaScript global object, usually &quot;window&quot; or &quot;global&quot;.</source>
          <target state="translated">Global返回JavaScript全局对象,通常是 &quot;window &quot;或 &quot;global&quot;。</target>
        </trans-unit>
        <trans-unit id="2e0b45f2a456e8db55f08d7b65e87593a3e9a140" translate="yes" xml:space="preserve">
          <source>Go</source>
          <target state="translated">Go</target>
        </trans-unit>
        <trans-unit id="e2b7859482bcbcd7f30181447cb1227d814aecb3" translate="yes" xml:space="preserve">
          <source>Go Path</source>
          <target state="translated">前往路径</target>
        </trans-unit>
        <trans-unit id="31c51be344c4f61c8aa40bf7e10aeaf5b3b1af91" translate="yes" xml:space="preserve">
          <source>Go Programming Language</source>
          <target state="translated">Go编程语言</target>
        </trans-unit>
        <trans-unit id="2c968e5f87e6cf184e435232ef5dd7937823c72a" translate="yes" xml:space="preserve">
          <source>Go code built with -buildmode=c-archive or -buildmode=c-shared will not install any other signal handlers by default. If there is an existing signal handler, the Go runtime will turn on the SA_ONSTACK flag and otherwise keep the signal handler. If Notify is called for an asynchronous signal, a Go signal handler will be installed for that signal. If, later, Reset is called for that signal, the original handling for that signal will be reinstalled, restoring the non-Go signal handler if any.</source>
          <target state="translated">以-buildmode=c-archive或-buildmode=c-shared构建的Go代码默认不会安装任何其他信号处理程序。如果有一个现有的信号处理程序,Go运行时将开启SA_ONSTACK标志,否则将保留该信号处理程序。如果异步信号调用了Notify,则会为该信号安装Go信号处理程序。如果之后对该信号调用Reset,则将重新安装该信号的原始处理,恢复非Go信号处理程序(如果有的话)。</target>
        </trans-unit>
        <trans-unit id="799dd6ab824dcf093ff420451386c628fa2a9520" translate="yes" xml:space="preserve">
          <source>Go code built without -buildmode=c-archive or -buildmode=c-shared will install a signal handler for the asynchronous signals listed above, and save any existing signal handler. If a signal is delivered to a non-Go thread, it will act as described above, except that if there is an existing non-Go signal handler, that handler will be installed before raising the signal.</source>
          <target state="translated">没有使用 -buildmode=c-archive 或 -buildmode=c-shared 构建的围棋代码将为上述异步信号安装信号处理程序,并保存任何现有的信号处理程序。如果信号被传递给非围棋线程,它将如上所述,但如果有一个现有的非围棋信号处理程序,该处理程序将在引发信号之前被安装。</target>
        </trans-unit>
        <trans-unit id="eb5d4b3ab79b5b09438ad686f6a173b50aeb10bd" translate="yes" xml:space="preserve">
          <source>Go identifiers that appear in the words map are italicized; if the corresponding map value is not the empty string, it is considered a URL and the word is converted into a link.</source>
          <target state="translated">在map这个词中出现的围棋标识符会被斜体化,如果对应的map值不是空字符串,则视为URL,该词会被转换为链接。</target>
        </trans-unit>
        <trans-unit id="ea224aeb731dc78304c02f088e7a39cfe984c1f7" translate="yes" xml:space="preserve">
          <source>Go invokes the function asynchronously. It returns the Call structure representing the invocation. The done channel will signal when the call is complete by returning the same Call object. If done is nil, Go will allocate a new channel. If non-nil, done must be buffered or Go will deliberately crash.</source>
          <target state="translated">Go异步调用函数。它返回代表调用的Call结构。当调用完成时,done通道将通过返回相同的Call对象发出信号。如果 done 为 nil,Go 将分配一个新通道。如果非nil,done必须被缓冲,否则Go会故意崩溃。</target>
        </trans-unit>
        <trans-unit id="a7c304672885987fa9e2bc01caee3388d0b9796b" translate="yes" xml:space="preserve">
          <source>Go programs that use cgo or SWIG</source>
          <target state="translated">使用cgo或SWIG的围棋程序</target>
        </trans-unit>
        <trans-unit id="f00375ef44991e7032fc680e2e8afc5d4b4ddcac" translate="yes" xml:space="preserve">
          <source>GoStringer</source>
          <target state="translated">GoStringer</target>
        </trans-unit>
        <trans-unit id="776ec360ea626f63aba6d19bf197cc0106f28f0c" translate="yes" xml:space="preserve">
          <source>GoStringer is implemented by any value that has a GoString method, which defines the Go syntax for that value. The GoString method is used to print values passed as an operand to a %#v format.</source>
          <target state="translated">GoStringer由任何有GoString方法的值来实现,它定义了该值的Go语法。GoString方法用于打印作为操作数传递的%#v格式的值。</target>
        </trans-unit>
        <trans-unit id="06664245ef1dbe050dbc75990b043c9e9da34427" translate="yes" xml:space="preserve">
          <source>GoWhitespace is the default value for the Scanner's Whitespace field. Its value selects Go's white space characters.</source>
          <target state="translated">GoWhitespace是扫描仪的Whitespace字段的默认值。它的值可以选择Go的空白字符。</target>
        </trans-unit>
        <trans-unit id="13594eb4e63d05205c24ee0d18474bb09fad234a" translate="yes" xml:space="preserve">
          <source>Gob can decode a value of any type implementing the GobDecoder or encoding.BinaryUnmarshaler interfaces by calling the corresponding method, again in that order of preference.</source>
          <target state="translated">Gob可以通过调用相应的方法对实现GobDecoder或encoding.BinaryUnmarshaler接口的任何类型的值进行解码,同样按照优先级排序。</target>
        </trans-unit>
        <trans-unit id="7274c1618f0661ff86ead432a84f718728e78907" translate="yes" xml:space="preserve">
          <source>Gob can encode a value of any type implementing the GobEncoder or encoding.BinaryMarshaler interfaces by calling the corresponding method, in that order of preference.</source>
          <target state="translated">Gob可以通过调用相应的方法对实现GobEncoder或encoding.BinaryMarshaler接口的任何类型的值进行编码,按优先级排序。</target>
        </trans-unit>
        <trans-unit id="3f0664b183bab943699d699e2b7fa06d50e41b1a" translate="yes" xml:space="preserve">
          <source>GobDecode implements the gob.GobDecoder interface.</source>
          <target state="translated">GobDecode实现了gob.GobDecoder接口。</target>
        </trans-unit>
        <trans-unit id="d350a1211682bc77e1cf31df3df91c75eb68270c" translate="yes" xml:space="preserve">
          <source>GobDecode implements the gob.GobDecoder interface. The result is rounded per the precision and rounding mode of z unless z's precision is 0, in which case z is set exactly to the decoded value.</source>
          <target state="translated">GobDecode实现了gob.GobDecoder接口。其结果根据z的精度和四舍五入模式进行四舍五入,除非z的精度为0,在这种情况下,z被精确地设置为解码值。</target>
        </trans-unit>
        <trans-unit id="dd719ca2cfb03b3cfba4caf011be5a1140872694" translate="yes" xml:space="preserve">
          <source>GobDecoder is the interface describing data that provides its own routine for decoding transmitted values sent by a GobEncoder.</source>
          <target state="translated">GobDecoder是描述数据的接口,它为解码GobEncoder发送的传输值提供了自己的例程。</target>
        </trans-unit>
        <trans-unit id="d5aa87ccb7988a5106efef8e6d2f9cae7932e9c6" translate="yes" xml:space="preserve">
          <source>GobEncode implements the gob.GobEncoder interface.</source>
          <target state="translated">GobEncode实现了gob.GobEncoder接口。</target>
        </trans-unit>
        <trans-unit id="20cb90d239fa73b1f6938fdb92b390d973a1de7f" translate="yes" xml:space="preserve">
          <source>GobEncode implements the gob.GobEncoder interface. The Float value and all its attributes (precision, rounding mode, accuracy) are marshaled.</source>
          <target state="translated">GobEncode实现了gob.GobEncoder接口。Float值和它的所有属性(精度、四舍五入模式、准确度)都会被marshaled,GobEncode实现了gob.GobEncoder接口。</target>
        </trans-unit>
        <trans-unit id="a019b8cdacb9fe6be4bcfe375ae2210cd1a4074d" translate="yes" xml:space="preserve">
          <source>GobEncoder is the interface describing data that provides its own representation for encoding values for transmission to a GobDecoder. A type that implements GobEncoder and GobDecoder has complete control over the representation of its data and may therefore contain things such as private fields, channels, and functions, which are not usually transmissible in gob streams.</source>
          <target state="translated">GobEncoder是描述数据的接口,它提供了自己的表示方式,用于编码传输给GobDecoder的值。实现GobEncoder和GobDecoder的类型可以完全控制其数据的表示方式,因此可以包含诸如私有字段、通道和函数等通常在gob流中不可传输的东西。</target>
        </trans-unit>
        <trans-unit id="3af908c6818caa06d786a8ce4e61618d352da418" translate="yes" xml:space="preserve">
          <source>Goexit terminates the goroutine that calls it. No other goroutine is affected. Goexit runs all deferred calls before terminating the goroutine. Because Goexit is not a panic, any recover calls in those deferred functions will return nil.</source>
          <target state="translated">Goexit 终止调用它的 goroutine。其他goroutine不受影响。Goexit 在终止 goroutine 之前会运行所有的延迟调用。因为 Goexit 不是一个恐慌机制,所以这些递延函数中的任何恢复调用都将返回 nil。</target>
        </trans-unit>
        <trans-unit id="92c1b5045c151c8351b05867329857d4da35385e" translate="yes" xml:space="preserve">
          <source>GoroutineProfile returns n, the number of records in the active goroutine stack profile. If len(p) &amp;gt;= n, GoroutineProfile copies the profile into p and returns n, true. If len(p) &amp;lt; n, GoroutineProfile does not change p and returns n, false.</source>
          <target state="translated">GoroutineProfile返回n，即活动goroutine堆栈配置文件中的记录数。如果len（p）&amp;gt; = n，则GoroutineProfile将配置文件复制到p中并返回n，为true。如果len（p）&amp;lt;n，则GoroutineProfile不会更改p并返回n，否则为false。</target>
        </trans-unit>
        <trans-unit id="62967be4b08298e25e7959a7cdc5602a2a2be72a" translate="yes" xml:space="preserve">
          <source>Gosched yields the processor, allowing other goroutines to run. It does not suspend the current goroutine, so execution resumes automatically.</source>
          <target state="translated">Gosched让出处理器,允许其他goroutine运行。它不会暂停当前的goroutine,所以会自动恢复执行。</target>
        </trans-unit>
        <trans-unit id="1c2aaf1310e2e413d539667c1a3e7771e58933c6" translate="yes" xml:space="preserve">
          <source>GotConnInfo is the argument to the ClientTrace.GotConn function and contains information about the obtained connection.</source>
          <target state="translated">GotConnInfo 是 ClientTrace.GotConn 函数的参数,包含了所获得的连接信息。</target>
        </trans-unit>
        <trans-unit id="8aa6da089a7b549e351002a5e03605264795ad2e" translate="yes" xml:space="preserve">
          <source>GraphicRanges defines the set of graphic characters according to Unicode.</source>
          <target state="translated">GraphicRanges根据Unicode定义了图形字符集。</target>
        </trans-unit>
        <trans-unit id="e7195fa4641b119dd2889d0a417f633c2b3c037d" translate="yes" xml:space="preserve">
          <source>Gray is an in-memory image whose At method returns color.Gray values.</source>
          <target state="translated">Gray是一个内存中的图像,其At方法返回color.Gray值。</target>
        </trans-unit>
        <trans-unit id="8551691479e553fcfd58c230f9f1c7702a08e936" translate="yes" xml:space="preserve">
          <source>Gray represents an 8-bit grayscale color.</source>
          <target state="translated">灰色代表8位灰度颜色。</target>
        </trans-unit>
        <trans-unit id="8be44534e41a9fdc599304347782cb967b0bd62b" translate="yes" xml:space="preserve">
          <source>Gray16 is an in-memory image whose At method returns color.Gray16 values.</source>
          <target state="translated">Gray16是一个内存中的图像,其At方法返回color.Gray16值。</target>
        </trans-unit>
        <trans-unit id="b7ee628ee7a9a7bf06c313fa8d8dc808a58abb8f" translate="yes" xml:space="preserve">
          <source>Gray16 represents a 16-bit grayscale color.</source>
          <target state="translated">Gray16代表16位灰度颜色。</target>
        </trans-unit>
        <trans-unit id="6e09be6a83f7d3163e99081e0c679a65e139fc8d" translate="yes" xml:space="preserve">
          <source>Group represents a grouping of users.</source>
          <target state="translated">组表示用户的分组。</target>
        </trans-unit>
        <trans-unit id="7de1bb0487db53a77d3d5fa786aa26f9027ba7c1" translate="yes" xml:space="preserve">
          <source>GroupIds returns the list of group IDs that the user is a member of.</source>
          <target state="translated">GroupIds 返回用户所属组的ID列表。</target>
        </trans-unit>
        <trans-unit id="d0e679bf3eeb0246c0708b92532613618a2a5627" translate="yes" xml:space="preserve">
          <source>Grouping:</source>
          <target state="translated">Grouping:</target>
        </trans-unit>
        <trans-unit id="a3dd80da68d80e7f0e9f29bcc9f5cb31d2777884" translate="yes" xml:space="preserve">
          <source>Grow grows b's capacity, if necessary, to guarantee space for another n bytes. After Grow(n), at least n bytes can be written to b without another allocation. If n is negative, Grow panics.</source>
          <target state="translated">如果有必要,Grow会增长b的容量,以保证另外n个字节的空间。在Grow(n)之后,至少可以向b写入n个字节,而不需要再分配。如果n为负数,Grow就会恐慌。</target>
        </trans-unit>
        <trans-unit id="ea6ca3eab6713cfdabbbddc578b2358a70e4ccb7" translate="yes" xml:space="preserve">
          <source>Grow grows the buffer's capacity, if necessary, to guarantee space for another n bytes. After Grow(n), at least n bytes can be written to the buffer without another allocation. If n is negative, Grow will panic. If the buffer can't grow it will panic with ErrTooLarge.</source>
          <target state="translated">如果需要的话,Grow会增长缓冲区的容量,以保证另外n个字节的空间。在Grow(n)之后,至少可以向缓冲区写入n个字节,而不需要再分配。如果n为负数,Grow会惊慌失措。如果缓冲区不能增长,它将用ErrTooLarge恐慌。</target>
        </trans-unit>
        <trans-unit id="fcfc665b9c38534864ef4c48c8a42633500c63ee" translate="yes" xml:space="preserve">
          <source>Gzip files store a length and checksum of the uncompressed data. The Reader will return an ErrChecksum when Read reaches the end of the uncompressed data if it does not have the expected length or checksum. Clients should treat data returned by Read as tentative until they receive the io.EOF marking the end of the data.</source>
          <target state="translated">Gzip文件存储了未压缩数据的长度和校验和。当Read到达未压缩数据的末端时,如果它没有预期的长度或校验和,Read将返回一个ErrChecksum。客户端应该将Read返回的数据视为暂定数据,直到收到标记数据结束的io.EOF。</target>
        </trans-unit>
        <trans-unit id="5d71851e777cb11c10615f1403f7831b2abdc279" translate="yes" xml:space="preserve">
          <source>HTML encapsulates a known safe HTML document fragment. It should not be used for HTML from a third-party, or HTML with unclosed tags or comments. The outputs of a sound HTML sanitizer and a template escaped by this package are fine for use with HTML.</source>
          <target state="translated">HTML封装了一个已知的安全的HTML文档片段,它不应该用于来自第三方的HTML,或带有未封闭标签或注释的HTML。它不应该被用于来自第三方的HTML,或者带有未关闭的标签或注释的HTML。健全的HTML消毒器的输出和被本包逃逸的模板都可以用于HTML。</target>
        </trans-unit>
        <trans-unit id="b3eeeba32a88681f357c6658794b2cde0a1ffee1" translate="yes" xml:space="preserve">
          <source>HTML templates treat data values as plain text which should be encoded so they can be safely embedded in an HTML document. The escaping is contextual, so actions can appear within JavaScript, CSS, and URI contexts.</source>
          <target state="translated">HTML模板将数据值视为纯文本,应该对其进行编码,以便它们可以安全地嵌入到HTML文档中。转义是上下文的,所以动作可以出现在JavaScript、CSS和URI上下文中。</target>
        </trans-unit>
        <trans-unit id="9941fc69ceb0b7c4c9cd661ccc1d3296d53a1466" translate="yes" xml:space="preserve">
          <source>HTMLAttr encapsulates an HTML attribute from a trusted source, for example, ` dir=&quot;ltr&quot;`.</source>
          <target state="translated">HTMLAttr封装了一个来自可信源的HTML属性,例如`dir=&quot;ltr&quot;`。</target>
        </trans-unit>
        <trans-unit id="56515df9ce780f70db2a14123d61a78cb0491ced" translate="yes" xml:space="preserve">
          <source>HTMLAutoClose is the set of HTML elements that should be considered to close automatically.</source>
          <target state="translated">HTMLAutoClose是一组应该考虑自动关闭的HTML元素。</target>
        </trans-unit>
        <trans-unit id="e3ae2c19a119f12f6bd7618bea966cc88fb1903b" translate="yes" xml:space="preserve">
          <source>HTMLEntity is an entity map containing translations for the standard HTML entity characters.</source>
          <target state="translated">HTMLEntity是一个包含标准HTML实体字符翻译的实体图。</target>
        </trans-unit>
        <trans-unit id="0502b94bdac42557ec458b2bcfd7d81519bb7f5f" translate="yes" xml:space="preserve">
          <source>HTMLEscape</source>
          <target state="translated">HTMLEscape</target>
        </trans-unit>
        <trans-unit id="108bb0274697ed474af72c0af28941c4694cc443" translate="yes" xml:space="preserve">
          <source>HTMLEscape appends to dst the JSON-encoded src with &amp;lt;, &amp;gt;, &amp;amp;, U+2028 and U+2029 characters inside string literals changed to \u003c, \u003e, \u0026, \u2028, \u2029 so that the JSON will be safe to embed inside HTML &amp;lt;script&amp;gt; tags. For historical reasons, web browsers don't honor standard HTML escaping within &amp;lt;script&amp;gt; tags, so an alternative JSON encoding must be used.</source>
          <target state="translated">HTMLEscape在字符串文字中将&amp;lt;，&amp;gt;，＆，U + 2028和U + 2029字符附加到dst JSON编码的src，这些字符已更改为\ u003c，\ u003e，\ u0026，\ u2028，\ u2029，以便JSON安全嵌入HTML &amp;lt;script&amp;gt;标记中。由于历史原因，Web浏览器不支持&amp;lt;script&amp;gt;标记内的标准HTML转义，因此必须使用替代的JSON编码。</target>
        </trans-unit>
        <trans-unit id="eaa5eff89dbdb13500c068f0e84bf21b7f3be3fb" translate="yes" xml:space="preserve">
          <source>HTMLEscape writes to w the escaped HTML equivalent of the plain text data b.</source>
          <target state="translated">HTMLEscape将纯文本数据b的转义HTML等价物写入w。</target>
        </trans-unit>
        <trans-unit id="eba1f3f7ea429a820bedfa415a707d8da7ce1238" translate="yes" xml:space="preserve">
          <source>HTMLEscapeString returns the escaped HTML equivalent of the plain text data s.</source>
          <target state="translated">HTMLEscapeString 返回纯文本数据 s 的转义 HTML 等价物。</target>
        </trans-unit>
        <trans-unit id="8b2dbe52305b6c07dd244c27d634207753a8523e" translate="yes" xml:space="preserve">
          <source>HTMLEscaper returns the escaped HTML equivalent of the textual representation of its arguments.</source>
          <target state="translated">HTMLEscaper返回其参数的文本表示的转义HTML等价物。</target>
        </trans-unit>
        <trans-unit id="9304c86e0fba62ba5daa5297c254f425c77df161" translate="yes" xml:space="preserve">
          <source>HTTP Trailers are a set of key/value pairs like headers that come after the HTTP response, instead of before.</source>
          <target state="translated">HTTP Trailers是一组key/value对,就像HTTP响应后的头信息,而不是之前的头信息。</target>
        </trans-unit>
        <trans-unit id="0f4dea56c9591992aae081556a866da7a62d7c76" translate="yes" xml:space="preserve">
          <source>HTTP status codes as registered with IANA. See: &lt;a href=&quot;https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml&quot;&gt;https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml&lt;/a&gt;</source>
          <target state="translated">向IANA注册的HTTP状态代码。请参阅：&lt;a href=&quot;https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml&quot;&gt;https&lt;/a&gt;：//www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</target>
        </trans-unit>
        <trans-unit id="ffb0634925a034a37cf81c8bf163966c760740e9" translate="yes" xml:space="preserve">
          <source>HTTP/2 support is only enabled if the Listener returns *tls.Conn connections and they were configured with &quot;h2&quot; in the TLS Config.NextProtos.</source>
          <target state="translated">只有当Listener返回*tls.Conn连接,并且它们在TLS Config.NextProtos中被配置为 &quot;h2 &quot;时,才会启用HTTP/2支持。</target>
        </trans-unit>
        <trans-unit id="5ee0353f20802f9b3b832dc664b1cf16f1dd8c83" translate="yes" xml:space="preserve">
          <source>HalfReader returns a Reader that implements Read by reading half as many requested bytes from r.</source>
          <target state="translated">HalfReader返回一个实现Read的Reader,从r中读取一半的请求字节。</target>
        </trans-unit>
        <trans-unit id="c0392b2b1c472815ba8d1a1e3b20f4a279bf6c50" translate="yes" xml:space="preserve">
          <source>Handle</source>
          <target state="translated">Handle</target>
        </trans-unit>
        <trans-unit id="1f7743a2da5a9b87698980081ed0a9b4a848c67b" translate="yes" xml:space="preserve">
          <source>Handle registers the handler for the given pattern in the DefaultServeMux. The documentation for ServeMux explains how patterns are matched.</source>
          <target state="translated">Handle在DefaultServeMux中注册给定模式的处理程序。ServeMux的文档解释了如何匹配模式。</target>
        </trans-unit>
        <trans-unit id="adfb5ece7bb714f07a8d92f38ecaccd93eb91488" translate="yes" xml:space="preserve">
          <source>Handle registers the handler for the given pattern. If a handler already exists for pattern, Handle panics.</source>
          <target state="translated">Handle注册给定模式的处理程序。如果pattern已经存在一个处理程序,那么Handle就会惊慌失措。</target>
        </trans-unit>
        <trans-unit id="9df709e02c4285ab3a3440b49e05002a1810c202" translate="yes" xml:space="preserve">
          <source>HandleFunc</source>
          <target state="translated">HandleFunc</target>
        </trans-unit>
        <trans-unit id="ba3631b03a8549831c70fb0b756b06eb4ccdf22e" translate="yes" xml:space="preserve">
          <source>HandleFunc registers the handler function for the given pattern in the DefaultServeMux. The documentation for ServeMux explains how patterns are matched.</source>
          <target state="translated">HandleFunc在DefaultServeMux中注册给定模式的处理函数。ServeMux的文档解释了如何匹配模式。</target>
        </trans-unit>
        <trans-unit id="671e02c9111874e0dde4ea20673fb01320ed5a12" translate="yes" xml:space="preserve">
          <source>HandleFunc registers the handler function for the given pattern.</source>
          <target state="translated">HandleFunc为给定模式注册处理函数。</target>
        </trans-unit>
        <trans-unit id="b8bc0ae743c24154bab55e05ddac119f84a83a3e" translate="yes" xml:space="preserve">
          <source>HandleHTTP registers an HTTP handler for RPC messages on rpcPath, and a debugging handler on debugPath. It is still necessary to invoke http.Serve(), typically in a go statement.</source>
          <target state="translated">HandleHTTP 在 rpcPath 上注册了一个 RPC 消息的 HTTP 处理程序,在 debugPath 上注册了一个调试处理程序。仍然需要调用http.Serve(),通常在go语句中调用。</target>
        </trans-unit>
        <trans-unit id="104cf096656ffcb1565dfd1219d7035e43630f88" translate="yes" xml:space="preserve">
          <source>HandleHTTP registers an HTTP handler for RPC messages to DefaultServer on DefaultRPCPath and a debugging handler on DefaultDebugPath. It is still necessary to invoke http.Serve(), typically in a go statement.</source>
          <target state="translated">HandleHTTP在DefaultRPCPath上为DefaultServer注册了一个RPC消息的HTTP处理程序,在DefaultDebugPath上注册了一个调试处理程序。仍然需要调用http.Serve(),通常是在go语句中。</target>
        </trans-unit>
        <trans-unit id="a62b57b0720d266ed6489a123759bbfe855bf88a" translate="yes" xml:space="preserve">
          <source>Handler also returns the registered pattern that matches the request or, in the case of internally-generated redirects, the pattern that will match after following the redirect.</source>
          <target state="translated">处理程序还返回与请求相匹配的注册模式,如果是内部生成的重定向,则返回跟随重定向后将匹配的模式。</target>
        </trans-unit>
        <trans-unit id="0ddb06f6f85fc2ca7a7cc5302dfee4fc45947bee" translate="yes" xml:space="preserve">
          <source>Handler returns an HTTP handler that serves the named profile.</source>
          <target state="translated">处理程序返回一个为命名的配置文件服务的HTTP处理程序。</target>
        </trans-unit>
        <trans-unit id="4065eef104a7b00ebd8ce9a91293334fd4bb0db9" translate="yes" xml:space="preserve">
          <source>Handler returns the expvar HTTP Handler.</source>
          <target state="translated">处理程序返回expvar HTTP处理程序。</target>
        </trans-unit>
        <trans-unit id="e63273beb69f3454c447975682e44a2c5d4a0c1e" translate="yes" xml:space="preserve">
          <source>Handler returns the handler to use for the given request, consulting r.Method, r.Host, and r.URL.Path. It always returns a non-nil handler. If the path is not in its canonical form, the handler will be an internally-generated handler that redirects to the canonical path. If the host contains a port, it is ignored when matching handlers.</source>
          <target state="translated">处理程序通过咨询r.Method、r.Host和r.URL.Path,返回给定请求要使用的处理程序。它总是返回一个非零的处理程序。如果路径不是规范的形式,处理程序将是一个内部生成的处理程序,它将重定向到规范的路径。如果主机包含一个端口,那么在匹配处理程序时,它将被忽略。</target>
        </trans-unit>
        <trans-unit id="a812b2fb8f7451d8a9be630f8c521fc7613cf74d" translate="yes" xml:space="preserve">
          <source>Handler runs an executable in a subprocess with a CGI environment.</source>
          <target state="translated">处理程序在具有CGI环境的子进程中运行一个可执行文件。</target>
        </trans-unit>
        <trans-unit id="612e8566dcf29030b3f86ae45fac3cd161070575" translate="yes" xml:space="preserve">
          <source>Handling of anonymous struct fields is new in Go 1.1. Prior to Go 1.1, anonymous struct fields were ignored. To force ignoring of an anonymous struct field in both current and earlier versions, give the field a JSON tag of &quot;-&quot;.</source>
          <target state="translated">匿名结构体字段的处理是 Go 1.1 中的新内容。在 Go 1.1 之前,匿名结构字段是被忽略的。要在当前和早期版本中强制忽略匿名结构字段,请给字段一个JSON标签&quot;-&quot;。</target>
        </trans-unit>
        <trans-unit id="8bd5447a341844b0e1ee2ac00ed949437eac1c43" translate="yes" xml:space="preserve">
          <source>Handshake runs the client or server handshake protocol if it has not yet been run. Most uses of this package need not call Handshake explicitly: the first Read or Write will call it automatically.</source>
          <target state="translated">如果还没有运行Handshake协议,Handshake会运行客户端或服务器的Handshake协议。这个包的大多数用途不需要明确地调用Handshake:第一次读或写会自动调用它。</target>
        </trans-unit>
        <trans-unit id="0bf39eaf505133458b930fe0c34986ca5b577cc9" translate="yes" xml:space="preserve">
          <source>HasExpired reports whether certList should have been updated by now.</source>
          <target state="translated">HasExpired报告certList是否已经更新。</target>
        </trans-unit>
        <trans-unit id="d390517d58b930cb269df7a0b32aa914bfb5311d" translate="yes" xml:space="preserve">
          <source>HasOk reports whether the corresponding expression may be used on the rhs of a comma-ok assignment.</source>
          <target state="translated">HasOk报告是否可以在逗号ok赋值的rhs上使用相应的表达式。</target>
        </trans-unit>
        <trans-unit id="e53848ef4c6fc884ed74c95d3ab525fa42a2bbe7" translate="yes" xml:space="preserve">
          <source>HasPrefix</source>
          <target state="translated">HasPrefix</target>
        </trans-unit>
        <trans-unit id="8d314f541aff1011d7ddb318695b8f61b2af6ec2" translate="yes" xml:space="preserve">
          <source>HasPrefix exists for historical compatibility and should not be used.</source>
          <target state="translated">HasPrefix是为了历史兼容性而存在的,不应该被使用。</target>
        </trans-unit>
        <trans-unit id="2669e9427d4779bbc09f60c5ccfd3fe6d15b6c70" translate="yes" xml:space="preserve">
          <source>HasPrefix tests whether the byte slice s begins with prefix.</source>
          <target state="translated">HasPrefix测试字节片断s是否以前缀开始。</target>
        </trans-unit>
        <trans-unit id="5cd07ae1c7bc3b9ed87eb16cdb61e05184635090" translate="yes" xml:space="preserve">
          <source>HasPrefix tests whether the string s begins with prefix.</source>
          <target state="translated">HasPrefix测试字符串s是否以前缀开始。</target>
        </trans-unit>
        <trans-unit id="117455f286c7643c45e4bb7a574dddee082000d6" translate="yes" xml:space="preserve">
          <source>HasSuffix</source>
          <target state="translated">HasSuffix</target>
        </trans-unit>
        <trans-unit id="0d84ad6d23e5d60c659894725feb80de1e5bc00b" translate="yes" xml:space="preserve">
          <source>HasSuffix tests whether the byte slice s ends with suffix.</source>
          <target state="translated">HasSuffix测试字节片断s是否以后缀结束。</target>
        </trans-unit>
        <trans-unit id="71e6720e740d9f5d90d030cf5d260029a0041a76" translate="yes" xml:space="preserve">
          <source>HasSuffix tests whether the string s ends with suffix.</source>
          <target state="translated">HasSuffix测试字符串s是否以后缀结束。</target>
        </trans-unit>
        <trans-unit id="c07fb815b0dd23f98464b6c96ba0043996f42574" translate="yes" xml:space="preserve">
          <source>Hash identifies a cryptographic hash function that is implemented in another package.</source>
          <target state="translated">哈希标识了一个在另一个包中实现的加密哈希函数。</target>
        </trans-unit>
        <trans-unit id="a8a4a81d7a93ec8ea6de29fca7e817e8b0ccf094" translate="yes" xml:space="preserve">
          <source>Hash implementations in the standard library (e.g. hash/crc32 and crypto/sha256) implement the encoding.BinaryMarshaler and encoding.BinaryUnmarshaler interfaces. Marshaling a hash implementation allows its internal state to be saved and used for additional processing later, without having to re-write the data previously written to the hash. The hash state may contain portions of the input in its original form, which users are expected to handle for any possible security implications.</source>
          <target state="translated">标准库中的哈希实现(如hash/crc32和crypto/sha256)实现了encoding.BinaryMarshaler和encoding.BinaryUnmarshaler接口。对一个哈希实现进行Marshaling,可以保存其内部状态,并用于以后的额外处理,而不必重新编写之前写入哈希的数据。哈希状态可能包含原始形式的输入的部分,用户应该处理任何可能的安全影响。</target>
        </trans-unit>
        <trans-unit id="afa3769866aaa8e9ccd0894bbb12db0f2a42b294" translate="yes" xml:space="preserve">
          <source>Hash is the common interface implemented by all hash functions.</source>
          <target state="translated">Hash是所有哈希函数实现的通用接口。</target>
        </trans-unit>
        <trans-unit id="bbb248d3e1082f71a91f55221f9ef1629bac5c92" translate="yes" xml:space="preserve">
          <source>Hash32 is the common interface implemented by all 32-bit hash functions.</source>
          <target state="translated">Hash32是所有32位哈希函数实现的通用接口。</target>
        </trans-unit>
        <trans-unit id="05bc44af5e367ef4fc60329373f6d1a44dbf5c85" translate="yes" xml:space="preserve">
          <source>Hash64 is the common interface implemented by all 64-bit hash functions.</source>
          <target state="translated">Hash64是所有64位哈希函数实现的通用接口。</target>
        </trans-unit>
        <trans-unit id="3959061e57c74057bbf958321e7f6031a26bba89" translate="yes" xml:space="preserve">
          <source>HashFunc returns pssOpts.Hash so that PSSOptions implements crypto.SignerOpts.</source>
          <target state="translated">HashFunc返回pssOpts.Hash,使PSSOptions实现crypto.SignerOpts。</target>
        </trans-unit>
        <trans-unit id="860155016136afc0d36dbbc3f9fc98412399783e" translate="yes" xml:space="preserve">
          <source>HashFunc simply returns the value of h so that Hash implements SignerOpts.</source>
          <target state="translated">HashFunc只需返回h的值,这样Hash就实现了SignerOpts。</target>
        </trans-unit>
        <trans-unit id="cd2b2728ea1f997355e4a7e5005a26c5306f470a" translate="yes" xml:space="preserve">
          <source>Head is a wrapper around DefaultClient.Head</source>
          <target state="translated">Head是DefaultClient.Head的封装器。</target>
        </trans-unit>
        <trans-unit id="93e59ac29bb3c357b0f9c42db1f78e97e116c128" translate="yes" xml:space="preserve">
          <source>Head issues a HEAD to the specified URL. If the response is one of the following redirect codes, Head follows the redirect after calling the Client's CheckRedirect function:</source>
          <target state="translated">Head向指定的URL发出一个HEAD。如果响应是下面的重定向代码之一,Head在调用客户端的CheckRedirect函数后,会跟随重定向。</target>
        </trans-unit>
        <trans-unit id="24094406af9408bd066ab26a0a1ef55bdcdead08" translate="yes" xml:space="preserve">
          <source>Head issues a HEAD to the specified URL. If the response is one of the following redirect codes, Head follows the redirect, up to a maximum of 10 redirects:</source>
          <target state="translated">Head向指定的URL发出一个HEAD。如果响应是以下重定向代码之一,Head就会跟随重定向,最多重定向10次。</target>
        </trans-unit>
        <trans-unit id="a50c7cbf99b8cae529cf3d620f5022a1c82e8fca" translate="yes" xml:space="preserve">
          <source>Header implements http.ResponseWriter. It returns the response headers to mutate within a handler. To test the headers that were written after a handler completes, use the Result method and see the returned Response value's Header.</source>
          <target state="translated">Header 实现 http.ResponseWriter。它返回要在处理程序中突变的响应头文件。要测试处理程序完成后写入的头信息,可以使用 Result 方法查看返回的 Response 值的 Header。</target>
        </trans-unit>
        <trans-unit id="2a403ca7fd2ae0865923ded1f911ee30d4fbde83" translate="yes" xml:space="preserve">
          <source>Hello sends a HELO or EHLO to the server as the given host name. Calling this method is only necessary if the client needs control over the host name used. The client will introduce itself as &quot;localhost&quot; automatically otherwise. If Hello is called, it must be called before any of the other methods.</source>
          <target state="translated">Hello作为给定的主机名向服务器发送HELO或EHLO。只有当客户端需要控制使用的主机名时才需要调用这个方法。否则客户端会自动将自己介绍为 &quot;localhost&quot;。如果调用Hello,必须在其他方法之前调用。</target>
        </trans-unit>
        <trans-unit id="0aed41610e50a1818172a103900a5a6fdac5322e" translate="yes" xml:space="preserve">
          <source>Helper marks the calling function as a test helper function. When printing file and line information, that function will be skipped. Helper may be called simultaneously from multiple goroutines.</source>
          <target state="translated">Helper 将调用的函数标记为测试辅助函数。当打印文件和行信息时,该函数将被跳过。Helper可以从多个goroutine中同时调用。</target>
        </trans-unit>
        <trans-unit id="aa0b52b8a6b42d9b0905c653c010a924ae5e874a" translate="yes" xml:space="preserve">
          <source>Here are some example one-line templates demonstrating pipelines and variables. All produce the quoted word &quot;output&quot;:</source>
          <target state="translated">以下是一些演示管道和变量的单行模板示例。所有的模板都会产生引号 &quot;output &quot;这个词。</target>
        </trans-unit>
        <trans-unit id="89620d229387855063bd56a8e6d5a3250086c9f0" translate="yes" xml:space="preserve">
          <source>Here is a simple example, opening a file and reading some of it.</source>
          <target state="translated">下面是一个简单的例子,打开一个文件,读取其中的一些内容。</target>
        </trans-unit>
        <trans-unit id="2824caba6baa2187c9e56d7836920f8ff25bcc71" translate="yes" xml:space="preserve">
          <source>Here is a simple example. A server wishes to export an object of type Arith:</source>
          <target state="translated">下面是一个简单的例子。一个服务器希望导出一个Arith类型的对象。</target>
        </trans-unit>
        <trans-unit id="2c22db98d01fc50d0681541a0b0caf2c4141f0f4" translate="yes" xml:space="preserve">
          <source>Here is a trivial example that prints &quot;17 items are made of wool&quot;.</source>
          <target state="translated">这里有一个微不足道的例子,印有 &quot;17件商品是用羊毛制成的&quot;。</target>
        </trans-unit>
        <trans-unit id="dc0bea3647dd8635722162c3a9c56cc10d70b7ac" translate="yes" xml:space="preserve">
          <source>Here is the list of actions. &quot;Arguments&quot; and &quot;pipelines&quot; are evaluations of data, defined in detail in the corresponding sections that follow.</source>
          <target state="translated">下面是动作列表。&quot;参数 &quot;和 &quot;管道 &quot;是对数据的评价,在后面的相应章节中详细定义。</target>
        </trans-unit>
        <trans-unit id="c3b612d75a40adadd01e188d1e2aba30e8b88d33" translate="yes" xml:space="preserve">
          <source>Here we demonstrate loading a set of templates from a directory.</source>
          <target state="translated">这里我们演示了从目录中加载一组模板。</target>
        </trans-unit>
        <trans-unit id="c18d789286c40d70b27c77faebcb174f22c85dbc" translate="yes" xml:space="preserve">
          <source>Here we demonstrate loading a set of templates from files in different directories</source>
          <target state="translated">在这里,我们演示了从不同目录下的文件加载一组模板的过程</target>
        </trans-unit>
        <trans-unit id="bcef5f73d0a48aab25273d92f8664ff4fb80379d" translate="yes" xml:space="preserve">
          <source>Here's an example directory layout:</source>
          <target state="translated">下面是一个目录布局的例子。</target>
        </trans-unit>
        <trans-unit id="35d5d6962be99793c34862b1061c8b5cacf67fc9" translate="yes" xml:space="preserve">
          <source>HexEncoding is the &amp;ldquo;Extended Hex Alphabet&amp;rdquo; defined in RFC 4648. It is typically used in DNS.</source>
          <target state="translated">HexEncoding是RFC 4648中定义的&amp;ldquo;扩展十六进制字母&amp;rdquo;。通常在DNS中使用。</target>
        </trans-unit>
        <trans-unit id="e23f68e03ccbc9812663415a4a25267a75156114" translate="yes" xml:space="preserve">
          <source>Hijack detaches the ClientConn and returns the underlying connection as well as the read-side bufio which may have some left over data. Hijack may be called before the user or Read have signaled the end of the keep-alive logic. The user should not call Hijack while Read or Write is in progress.</source>
          <target state="translated">Hijack分离ClientConn,并返回底层连接以及可能有一些剩余数据的读端bufio。Hijack可以在用户或Read发出keep-alive逻辑结束的信号之前被调用。当Read或Write正在进行时,用户不应该调用Hijack。</target>
        </trans-unit>
        <trans-unit id="9150896df8944dbbb2d645bc78167fd76df1dc80" translate="yes" xml:space="preserve">
          <source>Hijack detaches the ServerConn and returns the underlying connection as well as the read-side bufio which may have some left over data. Hijack may be called before Read has signaled the end of the keep-alive logic. The user should not call Hijack while Read or Write is in progress.</source>
          <target state="translated">Hijack分离ServerConn,并返回底层连接以及可能有一些剩余数据的读端bufio。Hijack可以在Read发出keep-alive逻辑结束的信号之前被调用。当Read或Write正在进行时,用户不应该调用Hijack。</target>
        </trans-unit>
        <trans-unit id="4a56321e103f0a1a522b694db3cb8d2d733e26fd" translate="yes" xml:space="preserve">
          <source>Hijacker</source>
          <target state="translated">Hijacker</target>
        </trans-unit>
        <trans-unit id="162450ef640a1216b7486b356d2e0daf7f97ce1d" translate="yes" xml:space="preserve">
          <source>Hostname returns the host name reported by the kernel.</source>
          <target state="translated">Hostname 返回内核报告的主机名。</target>
        </trans-unit>
        <trans-unit id="96c776e02774d643d6c9b2543ae4ea531e374ca6" translate="yes" xml:space="preserve">
          <source>Hostname returns u.Host, stripping any valid port number if present.</source>
          <target state="translated">Hostname 返回 u.Host,如果存在,则去除任何有效的端口号。</target>
        </trans-unit>
        <trans-unit id="c10a91f09a43d36b8c063665239759dddfc07545" translate="yes" xml:space="preserve">
          <source>HostnameError results when the set of authorized names doesn't match the requested name.</source>
          <target state="translated">当授权名称集与请求的名称不匹配时,会出现HostnameError。</target>
        </trans-unit>
        <trans-unit id="a732fe7ae23ec635b26f3cda289c15cbca4f3d8c" translate="yes" xml:space="preserve">
          <source>Hour returns the hour within the day specified by t, in the range [0, 23].</source>
          <target state="translated">Hour 返回 t 指定的一天中的小时,范围为 [0,23]。</target>
        </trans-unit>
        <trans-unit id="316afefe22138dc95ee9f3b2f4bc4164e8b8424e" translate="yes" xml:space="preserve">
          <source>Hours returns the duration as a floating point number of hours.</source>
          <target state="translated">小时数 返回浮点小时数的持续时间。</target>
        </trans-unit>
        <trans-unit id="29032d83edd3b2c57e81fe35f7063e01de42a614" translate="yes" xml:space="preserve">
          <source>However, there can be multiple leftmost-longest matches, with different submatch choices, and here this package diverges from POSIX. Among the possible leftmost-longest matches, this package chooses the one that a backtracking search would have found first, while POSIX specifies that the match be chosen to maximize the length of the first subexpression, then the second, and so on from left to right. The POSIX rule is computationally prohibitive and not even well-defined. See &lt;a href=&quot;https://swtch.com/~rsc/regexp/regexp2.html#posix&quot;&gt;https://swtch.com/~rsc/regexp/regexp2.html#posix&lt;/a&gt; for details.</source>
          <target state="translated">但是，可以有多个最左最长的匹配项，具有不同的子匹配项选择，并且此程序包与POSIX不同。在可能的最左最长的匹配项中，此程序包选择一个将首先找到回溯搜索的匹配项，而POSIX指定选择该匹配项以最大化第一个子表达式的长度，然后最大化第二个子表达式的长度，依此类推，从左到右。POSIX规则在计算上是禁止的，甚至定义不明确。有关详细信息，请参见&lt;a href=&quot;https://swtch.com/~rsc/regexp/regexp2.html#posix&quot;&gt;https://swtch.com/~rsc/regexp/regexp2.html#posix&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="40708df18a19eb4cd04fce64de3e8c9f00288cb2" translate="yes" xml:space="preserve">
          <source>However, to aid in formatting template source code, if an action's left delimiter (by default &quot;{{&quot;) is followed immediately by a minus sign and ASCII space character (&quot;{{- &quot;), all trailing white space is trimmed from the immediately preceding text. Similarly, if the right delimiter (&quot;}}&quot;) is preceded by a space and minus sign (&quot; -}}&quot;), all leading white space is trimmed from the immediately following text. In these trim markers, the ASCII space must be present; &quot;{{-3}}&quot; parses as an action containing the number -3.</source>
          <target state="translated">然而,为了帮助模板源代码的格式化,如果一个动作的左定界符(默认为&quot;{&quot;)后面紧跟着一个减号和ASCII空格字符(&quot;{{-&quot;),那么所有尾部的空白都会从紧接着的文本中被修剪掉;同样,如果右定界符(&quot;}}&quot;)前面有一个空格和减号(&quot;-}}&quot;),那么所有前面的空白都会被修剪掉。同样,如果右定界符(&quot;}}&quot;)前有空格和减号(&quot;-}}&quot;),则紧接其后的文本的所有前部空白都会被修剪。在这些修剪标记中,ASCII空格必须存在;&quot;{{-3}}&quot;会被解析为包含数字-3的操作。</target>
        </trans-unit>
        <trans-unit id="d4e4742177e63cc124605c711f8542e79a9c655e" translate="yes" xml:space="preserve">
          <source>However, when printing a byte slice with a string-like verb (%s %q %x %X), it is treated identically to a string, as a single item.</source>
          <target state="translated">但是,当打印一个带有类似字符串动词的字节片时(%s %q %x %X),它的处理方式与字符串相同,是一个单项。</target>
        </trans-unit>
        <trans-unit id="5c4cbffa6231f3b3c2514644d0fee825e224c80d" translate="yes" xml:space="preserve">
          <source>Hypot returns Sqrt(p*p + q*q), taking care to avoid unnecessary overflow and underflow.</source>
          <target state="translated">Hypot返回Sqrt(p*p+q*q),注意避免不必要的溢出和不足。</target>
        </trans-unit>
        <trans-unit id="576b7847aead683e23b77c003ff6f222a841ef25" translate="yes" xml:space="preserve">
          <source>IEEETable is the table for the IEEE polynomial.</source>
          <target state="translated">IEEETable是IEEE多项式的表。</target>
        </trans-unit>
        <trans-unit id="a220db6c90383cf3092dacd6831c2890463d8ced" translate="yes" xml:space="preserve">
          <source>IMAGE_DIRECTORY_ENTRY constants</source>
          <target state="translated">IMAGE_DIRECTORY_ENTRY 常量。</target>
        </trans-unit>
        <trans-unit id="f585c9fe77a34e4b203ca7586560b165b3fa9e06" translate="yes" xml:space="preserve">
          <source>IP address lengths (bytes).</source>
          <target state="translated">IP地址长度(字节)。</target>
        </trans-unit>
        <trans-unit id="e746cf97286466a3ee7a6da22134f5658e5d9835" translate="yes" xml:space="preserve">
          <source>IP.DefaultMask</source>
          <target state="translated">IP.DefaultMask</target>
        </trans-unit>
        <trans-unit id="11cb3659b8e0ce7581cbb847a5c82b1c9f0fd371" translate="yes" xml:space="preserve">
          <source>IP.Mask</source>
          <target state="translated">IP.Mask</target>
        </trans-unit>
        <trans-unit id="afa88b5842f11425f491e338d7ab921fd1ba5273" translate="yes" xml:space="preserve">
          <source>IPAddr represents the address of an IP end point.</source>
          <target state="translated">IPAddr表示IP端点的地址。</target>
        </trans-unit>
        <trans-unit id="62bf2467f82c0177288446c3c53fcfe1388fdbf4" translate="yes" xml:space="preserve">
          <source>IPConn is the implementation of the Conn and PacketConn interfaces for IP network connections.</source>
          <target state="translated">IPConn是Conn和PacketConn接口在IP网络连接中的实现。</target>
        </trans-unit>
        <trans-unit id="f8a4e52fe170a6b87d8e8f324c9e46497e3e1a1e" translate="yes" xml:space="preserve">
          <source>IPv4</source>
          <target state="translated">IPv4</target>
        </trans-unit>
        <trans-unit id="01eafbb77fe2e5da4ec4f2fa2166e61bdbf17fda" translate="yes" xml:space="preserve">
          <source>IPv4 returns the IP address (in 16-byte form) of the IPv4 address a.b.c.d.</source>
          <target state="translated">IPv4返回IPv4地址a.b.c.d的IP地址(16字节形式)。</target>
        </trans-unit>
        <trans-unit id="3e2065fb2c469f55091e83e0c17ec6c33b2ade3a" translate="yes" xml:space="preserve">
          <source>IPv4Mask</source>
          <target state="translated">IPv4Mask</target>
        </trans-unit>
        <trans-unit id="d0818e19fd482dbfdc092a8f03eecab69f4f02c6" translate="yes" xml:space="preserve">
          <source>IPv4Mask returns the IP mask (in 4-byte form) of the IPv4 mask a.b.c.d.</source>
          <target state="translated">IPv4Mask 返回 IPv4 掩码 a.b.c.d 的 IP 掩码(4 字节形式)。</target>
        </trans-unit>
        <trans-unit id="84f775d13ea13d9914f862669240b386b5b2ce40" translate="yes" xml:space="preserve">
          <source>ISOWeek returns the ISO 8601 year and week number in which t occurs. Week ranges from 1 to 53. Jan 01 to Jan 03 of year n might belong to week 52 or 53 of year n-1, and Dec 29 to Dec 31 might belong to week 1 of year n+1.</source>
          <target state="translated">ISOWeek返回t发生的ISO 8601年和周号。周的范围从1到53。n年的1月1日到1月3日可能属于n-1年的52或53周,12月29日到12月31日可能属于n+1年的1周。</target>
        </trans-unit>
        <trans-unit id="08d6764cba419802272bb09d455c908144b957aa" translate="yes" xml:space="preserve">
          <source>Id is a wrapper for Id(obj.Pkg(), obj.Name()).</source>
          <target state="translated">Id是Id(obj.Pkg(),obj.Name())的封装器。</target>
        </trans-unit>
        <trans-unit id="1d68ea4276c501cd9a850a1820a4a4d86fcccd10" translate="yes" xml:space="preserve">
          <source>Id returns name if it is exported, otherwise it returns the name qualified with the package path.</source>
          <target state="translated">如果是导出的,则返回名称,否则返回以包路径限定的名称。</target>
        </trans-unit>
        <trans-unit id="fa08cb5f856950ffd31e99879394c8d2ecd78b73" translate="yes" xml:space="preserve">
          <source>Identical reports whether x and y are identical types. Receivers of Signature types are ignored.</source>
          <target state="translated">Identical报告x和y是否是相同的类型。签名类型的接收者会被忽略。</target>
        </trans-unit>
        <trans-unit id="62582ea142e0c589620d5bd10a3675dc62d150bc" translate="yes" xml:space="preserve">
          <source>IdenticalIgnoreTags reports whether x and y are identical types if tags are ignored. Receivers of Signature types are ignored.</source>
          <target state="translated">如果标签被忽略,IdenticalIgnoreTags报告x和y是否是相同类型。签名类型的接收者会被忽略。</target>
        </trans-unit>
        <trans-unit id="1b283807cc15b11d0882e9fd847033d20b983bd2" translate="yes" xml:space="preserve">
          <source>IdentifierNode holds an identifier.</source>
          <target state="translated">IdentifierNode持有一个标识符。</target>
        </trans-unit>
        <trans-unit id="e3f7a148cc891203b5f7d36d2d9e45cad70d628a" translate="yes" xml:space="preserve">
          <source>If 'All' is present, the routine matches successive non-overlapping matches of the entire expression. Empty matches abutting a preceding match are ignored. The return value is a slice containing the successive return values of the corresponding non-'All' routine. These routines take an extra integer argument, n. If n &amp;gt;= 0, the function returns at most n matches/submatches; otherwise, it returns all of them.</source>
          <target state="translated">如果存在&amp;ldquo;全部&amp;rdquo;，则例程将匹配整个表达式的连续非重叠匹配。与之前的比赛相邻的空比赛将被忽略。返回值是一个切片，其中包含相应的非&amp;ldquo; All&amp;rdquo;例程的连续返回值。这些例程使用一个额外的整数参数n。如果n&amp;gt; = 0，则该函数最多返回n个匹配项/子匹配项；否则，将返回所有这些。</target>
        </trans-unit>
        <trans-unit id="4bc5ea7c2a0ba24905139043c1e06d713fc4b624" translate="yes" xml:space="preserve">
          <source>If 'Index' is present, matches and submatches are identified by byte index pairs within the input string: result[2*n:2*n+1] identifies the indexes of the nth submatch. The pair for n==0 identifies the match of the entire expression. If 'Index' is not present, the match is identified by the text of the match/submatch. If an index is negative or text is nil, it means that subexpression did not match any string in the input. For 'String' versions an empty string means either no match or an empty match.</source>
          <target state="translated">如果存在'Index',则匹配和子匹配由输入字符串中的字节索引对识别:result[2*n:2*n+1]识别第n个子匹配的索引。n==0的对子标识整个表达式的匹配。如果'索引'不存在,则通过匹配/子匹配的文本来识别匹配。如果索引为负值或文本为零,则意味着子表达式没有匹配输入中的任何字符串。对于'String'版本,空字符串意味着没有匹配或空匹配。</target>
        </trans-unit>
        <trans-unit id="750f20e67d15d8b15512065e634f8a04cd24649d" translate="yes" xml:space="preserve">
          <source>If 'String' is present, the argument is a string; otherwise it is a slice of bytes; return values are adjusted as appropriate.</source>
          <target state="translated">如果存在'String',则参数是一个字符串,否则是一个字节片,返回值会适当调整。</target>
        </trans-unit>
        <trans-unit id="6b5422b81678b9d8d259a31067e6668262dc0a15" translate="yes" xml:space="preserve">
          <source>If 'Submatch' is present, the return value is a slice identifying the successive submatches of the expression. Submatches are matches of parenthesized subexpressions (also known as capturing groups) within the regular expression, numbered from left to right in order of opening parenthesis. Submatch 0 is the match of the entire expression, submatch 1 the match of the first parenthesized subexpression, and so on.</source>
          <target state="translated">如果存在'Submatch',返回值是一个分片,标识表达式的连续子匹配。子匹配是正则表达式中的大括号子表达式(也称为捕获组)的匹配,按照开括号的顺序从左到右编号。子匹配0是整个表达式的匹配,子匹配1是第一个括号化子表达式的匹配,以此类推。</target>
        </trans-unit>
        <trans-unit id="c8e129ec8b814ed3ea9bfb24aed18824a3379050" translate="yes" xml:space="preserve">
          <source>If Body is present, Content-Length is &amp;lt;= 0 and TransferEncoding hasn't been set to &quot;identity&quot;, Write adds &quot;Transfer-Encoding: chunked&quot; to the header. Body is closed after it is sent.</source>
          <target state="translated">如果存在&amp;ldquo;正文&amp;rdquo;，则Content-Length为&amp;lt;= 0，并且TransferEncoding尚未设置为&amp;ldquo; identity&amp;rdquo;，Write将&amp;ldquo; Transfer-Encoding：chunked&amp;rdquo;添加到标头。发送后将其关闭。</target>
        </trans-unit>
        <trans-unit id="a4c660d2d836ce5011f39f208170601c14fc3f84" translate="yes" xml:space="preserve">
          <source>If CheckNamedValue returns ErrRemoveArgument, the NamedValue will not be included in the final query arguments. This may be used to pass special options to the query itself.</source>
          <target state="translated">如果CheckNamedValue返回ErrRemoveArgument,NamedValue将不会被包含在最终的查询参数中。这可以用来向查询本身传递特殊选项。</target>
        </trans-unit>
        <trans-unit id="16a03bedfc442181d888e7b8ec8eee1e7e8562bb" translate="yes" xml:space="preserve">
          <source>If Conn.Ping returns ErrBadConn, DB.Ping and DB.PingContext will remove the Conn from pool.</source>
          <target state="translated">如果Conn.Ping返回ErrBadConn,DB.Ping和DB.PingContext将从池中移除Conn。</target>
        </trans-unit>
        <trans-unit id="9bf5fb8d1ebbb6dc425efaa4065a072560c9aaa0" translate="yes" xml:space="preserve">
          <source>If DIR is a directory listed in the Go path, a package with source in DIR/src/foo/bar can be imported as &quot;foo/bar&quot; and has its compiled form installed to &quot;DIR/pkg/GOOS_GOARCH/foo/bar.a&quot; (or, for gccgo, &quot;DIR/pkg/gccgo/foo/libbar.a&quot;).</source>
          <target state="translated">如果DIR是Go路径中列出的目录,那么可以将DIR/src/foo/bar中的源码包导入为 &quot;foo/bar&quot;,并将其编译后的形式安装到 &quot;DIR/pkg/GOOS_GOARCH/foo/bar.a&quot;(或者,对于gccgo来说,&quot;DIR/pkg/gccgo/foo/libbar.a&quot;)。</target>
        </trans-unit>
        <trans-unit id="626d82422a444f8260197f6a255b844b957560c9" translate="yes" xml:space="preserve">
          <source>If Dir is SelectDefault, the case represents a default case. Chan and Send must be zero Values.</source>
          <target state="translated">如果Dir为SelectDefault,则代表默认情况。Chan和Send必须是零值。</target>
        </trans-unit>
        <trans-unit id="b64c8a9a4dd6bc23186cb39d29f2d6a941b37467" translate="yes" xml:space="preserve">
          <source>If Dir is SelectRecv, the case represents a receive operation. Normally Chan's underlying value must be a channel and Send must be a zero Value. If Chan is a zero Value, then the case is ignored, but Send must still be a zero Value. When a receive operation is selected, the received Value is returned by Select.</source>
          <target state="translated">如果Dir是SelectRecv,则代表的是接收操作。通常Chan的底层值必须是一个通道,Send必须是一个零Value。如果Chan为零Value,则忽略case,但Send仍必须为零Value。当选择接收操作时,接收的Value由Select返回。</target>
        </trans-unit>
        <trans-unit id="fc3241471000ca543780e2776c12ce2c0f98b518" translate="yes" xml:space="preserve">
          <source>If Dir is SelectSend, the case represents a send operation. Normally Chan's underlying value must be a channel, and Send's underlying value must be assignable to the channel's element type. As a special case, if Chan is a zero Value, then the case is ignored, and the field Send will also be ignored and may be either zero or non-zero.</source>
          <target state="translated">如果Dir是SelectSend,则代表发送操作的情况。通常Chan的底层值必须是一个通道,Send的底层值必须是可以分配给通道的元素类型。作为一种特殊情况,如果Chan是一个零值,那么case会被忽略,而Send这个字段也会被忽略,可以是零也可以是非零。</target>
        </trans-unit>
        <trans-unit id="3e5a9a392b54a0f9dbcf70e078d697829fda46e7" translate="yes" xml:space="preserve">
          <source>If Discard skips fewer than n bytes, it also returns an error. If 0 &amp;lt;= n &amp;lt;= b.Buffered(), Discard is guaranteed to succeed without reading from the underlying io.Reader.</source>
          <target state="translated">如果&amp;ldquo;放弃&amp;rdquo;跳过少于n个字节，则它还会返回错误。如果0 &amp;lt;= n &amp;lt;= b.Buffered（），则确保Discard成功执行，而无需从基础io.Reader中读取。</target>
        </trans-unit>
        <trans-unit id="5388f313bdebc1cd743073994620f637168dfccb" translate="yes" xml:space="preserve">
          <source>If DiscardEmptyColumns is set, empty columns that are terminated entirely by vertical (or &quot;soft&quot;) tabs are discarded. Columns terminated by horizontal (or &quot;hard&quot;) tabs are not affected by this flag.</source>
          <target state="translated">如果设置了DiscardEmptyColumns,则完全由垂直(或 &quot;软&quot;)制表符终止的空列将被丢弃。由水平(或 &quot;硬&quot;)制表符终止的列不受此标志的影响。</target>
        </trans-unit>
        <trans-unit id="c9deb8e1a0cfa1d1825dc49ade2afa7eec850bd3" translate="yes" xml:space="preserve">
          <source>If ErrSkip is returned the column converter error checking path is used for the argument. Drivers may wish to return ErrSkip after they have exhausted their own special cases.</source>
          <target state="translated">如果返回ErrSkip,列转换器错误检查路径将用于参数。驱动程序可能希望在用尽自己的特殊情况后返回ErrSkip。</target>
        </trans-unit>
        <trans-unit id="acb8bfb04c68aa06cf649fa65fe83fd0ec6ad99b" translate="yes" xml:space="preserve">
          <source>If Get would otherwise return nil and p.New is non-nil, Get returns the result of calling p.New.</source>
          <target state="translated">如果Get在其他情况下会返回nil,而p.New是非nil,那么Get会返回调用p.New的结果。</target>
        </trans-unit>
        <trans-unit id="cbb35dd622fd4fc40d747d7fe8a39806c85598b4" translate="yes" xml:space="preserve">
          <source>If MaxIdleConns is greater than 0 and the new MaxOpenConns is less than MaxIdleConns, then MaxIdleConns will be reduced to match the new MaxOpenConns limit.</source>
          <target state="translated">如果MaxIdleConns大于0,并且新的MaxOpenConns小于MaxIdleConns,那么MaxIdleConns将被减少以匹配新的MaxOpenConns限制。</target>
        </trans-unit>
        <trans-unit id="0566ce3b75e32de588395cc9db25a53062d79613" translate="yes" xml:space="preserve">
          <source>If MaxOpenConns is greater than 0 but less than the new MaxIdleConns, then the new MaxIdleConns will be reduced to match the MaxOpenConns limit.</source>
          <target state="translated">如果MaxOpenConns大于0但小于新的MaxIdleConns,那么新的MaxIdleConns将被减少,以匹配MaxOpenConns限制。</target>
        </trans-unit>
        <trans-unit id="ba59fc6bf9458413409db5ff0b9045c64e756bcb" translate="yes" xml:space="preserve">
          <source>If ReadAt is reading from an input source with a seek offset, ReadAt should not affect nor be affected by the underlying seek offset.</source>
          <target state="translated">如果ReadAt从一个有寻道偏移的输入源读取,ReadAt不应该影响也不会受到底层寻道偏移的影响。</target>
        </trans-unit>
        <trans-unit id="cc3d6766541295fe523ec22933263aa9a06c4657" translate="yes" xml:space="preserve">
          <source>If ServeHTTP panics, the server (the caller of ServeHTTP) assumes that the effect of the panic was isolated to the active request. It recovers the panic, logs a stack trace to the server error log, and either closes the network connection or sends an HTTP/2 RST_STREAM, depending on the HTTP protocol. To abort a handler so the client sees an interrupted response but the server doesn't log an error, panic with the value ErrAbortHandler.</source>
          <target state="translated">如果ServeHTTP发生恐慌,服务器(ServeHTTP的调用者)会认为恐慌的影响是孤立于活动请求的。它恢复恐慌,将堆栈跟踪记录到服务器错误日志中,并根据HTTP协议关闭网络连接或发送一个HTTP/2 RST_STREAM。要中止一个处理程序,使客户端看到一个中断的响应,但服务器没有记录错误,用ErrAbortHandler的值来恐慌。</target>
        </trans-unit>
        <trans-unit id="7c30ed6f837b3e7a9558eb599fa8c56e0e97063b" translate="yes" xml:space="preserve">
          <source>If Times t and u both contain monotonic clock readings, the operations t.After(u), t.Before(u), t.Equal(u), and t.Sub(u) are carried out using the monotonic clock readings alone, ignoring the wall clock readings. If either t or u contains no monotonic clock reading, these operations fall back to using the wall clock readings.</source>
          <target state="translated">如果Times t和u都包含单调时钟读数,那么t.After(u)、t.Before(u)、t.Equal(u)和t.Sub(u)等操作都只使用单调时钟读数而忽略挂钟读数。如果t或u中没有单调时钟读数,这些操作将回到使用挂钟读数。</target>
        </trans-unit>
        <trans-unit id="bc4d8baa4dbb3f1a94db59ec9aa34f357782809d" translate="yes" xml:space="preserve">
          <source>If Unmarshal encounters a field type that implements the Unmarshaler interface, Unmarshal calls its UnmarshalXML method to produce the value from the XML element. Otherwise, if the value implements encoding.TextUnmarshaler, Unmarshal calls that value's UnmarshalText method.</source>
          <target state="translated">如果Unmarshal遇到一个实现了Unmarshaler接口的字段类型,Unmarshal就会调用它的UnmarshalXML方法从XML元素中产生值。否则,如果该值实现了 encoding.TextUnmarshaler,Unmarshal 就会调用该值的 UnmarshalText 方法。</target>
        </trans-unit>
        <trans-unit id="e7b1cef9234b9022f80f99b102d2ffde95658f55" translate="yes" xml:space="preserve">
          <source>If UseCRLF is true, the Writer ends each output line with \r\n instead of \n.</source>
          <target state="translated">如果UseCRLF为真,那么Writer就会在每一行输出结束时使用\r\n而不是\n。</target>
        </trans-unit>
        <trans-unit id="24f02297c63afdceb90dae9a889e378f8f5dc1c7" translate="yes" xml:space="preserve">
          <source>If WriteAt is writing to a destination with a seek offset, WriteAt should not affect nor be affected by the underlying seek offset.</source>
          <target state="translated">如果WriteAt是写到一个有寻道偏移的目的地,WriteAt不应该影响也不会受到基础寻道偏移的影响。</target>
        </trans-unit>
        <trans-unit id="01ec25dfc6204eb6897de5935b9779223b3cad13" translate="yes" xml:space="preserve">
          <source>If a &quot;range&quot; action initializes a variable, the variable is set to the successive elements of the iteration. Also, a &quot;range&quot; may declare two variables, separated by a comma:</source>
          <target state="translated">如果一个 &quot;范围 &quot;操作初始化了一个变量,那么这个变量就会被设置为迭代的连续元素。另外,一个 &quot;范围 &quot;可以声明两个变量,用逗号隔开。</target>
        </trans-unit>
        <trans-unit id="58d444ec12c7fa5d6e872ab50772870b5a393d01" translate="yes" xml:space="preserve">
          <source>If a Conn does not implement ExecerContext, the sql package's DB.Exec will fall back to Execer; if the Conn does not implement Execer either, DB.Exec will first prepare a query, execute the statement, and then close the statement.</source>
          <target state="translated">如果Conn没有实现ExecerContext,那么sql包的DB.Exec将回落到Execer;如果Conn也没有实现Execer,DB.Exec将先准备查询,执行语句,然后关闭语句。</target>
        </trans-unit>
        <trans-unit id="44e6dfb38005e87694379cf1c0216f95562e9cfb" translate="yes" xml:space="preserve">
          <source>If a Conn does not implement Pinger, the sql package's DB.Ping and DB.PingContext will check if there is at least one Conn available.</source>
          <target state="translated">如果一个Conn没有实现Pinger,sql包的DB.Ping和DB.PingContext会检查是否至少有一个Conn可用。</target>
        </trans-unit>
        <trans-unit id="21128809a4ab46817c40f8b5969689593dcd6f72" translate="yes" xml:space="preserve">
          <source>If a Conn does not implement QueryerContext, the sql package's DB.Query will fall back to Queryer; if the Conn does not implement Queryer either, DB.Query will first prepare a query, execute the statement, and then close the statement.</source>
          <target state="translated">如果Conn没有实现QueryerContext,则sql包的DB.Query将回落到Queryer;如果Conn也没有实现Queryer,则DB.Query将先准备一个查询,执行语句,然后关闭语句。</target>
        </trans-unit>
        <trans-unit id="45c4be212f44031bede2b5276a4a3589a0dc2b98" translate="yes" xml:space="preserve">
          <source>If a Conn implements neither ExecerContext nor Execer, the sql package's DB.Exec will first prepare a query, execute the statement, and then close the statement.</source>
          <target state="translated">如果一个Conn既没有实现ExecerContext,也没有实现Execer,那么sql包的DB.Exec将首先准备一个查询,执行语句,然后关闭语句。</target>
        </trans-unit>
        <trans-unit id="1cb5d6dd6f4d516d1ae37935040abf369ba105f8" translate="yes" xml:space="preserve">
          <source>If a Conn implements neither QueryerContext nor Queryer, the sql package's DB.Query will first prepare a query, execute the statement, and then close the statement.</source>
          <target state="translated">如果一个Conn既没有实现QueryerContext,也没有实现Queryer,那么sql包的DB.Query会先准备一个查询,执行语句,然后关闭语句。</target>
        </trans-unit>
        <trans-unit id="71c0f29e06c175a2adb537fdf47269746a601d0d" translate="yes" xml:space="preserve">
          <source>If a Driver implements DriverContext, then sql.DB will call OpenConnector to obtain a Connector and then invoke that Connector's Conn method to obtain each needed connection, instead of invoking the Driver's Open method for each connection. The two-step sequence allows drivers to parse the name just once and also provides access to per-Conn contexts.</source>
          <target state="translated">如果一个驱动程序实现了DriverContext,那么sql.DB将调用OpenConnector来获取一个Connector,然后调用该Connector的Conn方法来获取每个需要的连接,而不是为每个连接调用驱动程序的Open方法。这两步序列允许驱动程序只解析一次名称,同时也提供了对每个Conn上下文的访问。</target>
        </trans-unit>
        <trans-unit id="232b341436c8f9f54c10a5dba1cf92c214798814" translate="yes" xml:space="preserve">
          <source>If a JSON value is not appropriate for a given target type, or if a JSON number overflows the target type, Unmarshal skips that field and completes the unmarshaling as best it can. If no more serious errors are encountered, Unmarshal returns an UnmarshalTypeError describing the earliest such error. In any case, it's not guaranteed that all the remaining fields following the problematic one will be unmarshaled into the target object.</source>
          <target state="translated">如果一个JSON值不适合给定的目标类型,或者一个JSON数超出了目标类型,Unmarshal就会跳过该字段,并尽可能地完成解马尔沙尔。如果没有遇到更严重的错误,Unmarshal会返回一个UnmarshalTypeError,描述最早的这种错误。在任何情况下,都不能保证在有问题的字段之后的所有剩余字段都会被解马尔什化到目标对象中。</target>
        </trans-unit>
        <trans-unit id="07bd09bc1ed04a73b33dd796fe781c9034c95572" translate="yes" xml:space="preserve">
          <source>If a Stmt is prepared on a Tx or Conn, it will be bound to a single underlying connection forever. If the Tx or Conn closes, the Stmt will become unusable and all operations will return an error. If a Stmt is prepared on a DB, it will remain usable for the lifetime of the DB. When the Stmt needs to execute on a new underlying connection, it will prepare itself on the new connection automatically.</source>
          <target state="translated">如果在Tx或Conn上准备了一个Stmt,它将永远绑定在一个基础连接上。如果Tx或Conn关闭,Stmt将变得不可用,所有操作都将返回一个错误。如果一个Stmt是在一个DB上准备的,那么它将在DB的生命周期内保持可用。当Stmt需要在新的底层连接上执行时,它将自动在新的连接上进行准备。</target>
        </trans-unit>
        <trans-unit id="3b80dd32b6041fa4ef2f09439544647455bd33ab" translate="yes" xml:space="preserve">
          <source>If a Value has an IsBoolFlag() bool method returning true, the command-line parser makes -name equivalent to -name=true rather than using the next command-line argument.</source>
          <target state="translated">如果一个Value有一个IsBoolFlag()bool方法返回true,命令行解析器会让-name等同于-name=true,而不是使用下一个命令行参数。</target>
        </trans-unit>
        <trans-unit id="1d651c7c470bed2709ac735baaeec98dda753ea4" translate="yes" xml:space="preserve">
          <source>If a Writer is configured to filter HTML, HTML tags and entities are passed through. The widths of tags and entities are assumed to be zero (tags) and one (entities) for formatting purposes.</source>
          <target state="translated">如果将Writer配置为过滤HTML,则HTML标签和实体将被传递。出于格式化的目的,标签和实体的宽度被假定为0(标签)和1(实体)。</target>
        </trans-unit>
        <trans-unit id="52438c4d80c78ea57962cd3af33f715085501ef6" translate="yes" xml:space="preserve">
          <source>If a benchmark needs some expensive setup before running, the timer may be reset:</source>
          <target state="translated">如果一个基准在运行前需要一些昂贵的设置,计时器可能会被重置。</target>
        </trans-unit>
        <trans-unit id="d7727dcc2593fe8b30c299beed7e6a6b86f7e22b" translate="yes" xml:space="preserve">
          <source>If a benchmark needs to test performance in a parallel setting, it may use the RunParallel helper function; such benchmarks are intended to be used with the go test -cpu flag:</source>
          <target state="translated">如果一个基准需要测试并行环境下的性能,它可以使用RunParallel辅助函数;这样的基准应该与go test -cpu标志一起使用。</target>
        </trans-unit>
        <trans-unit id="a54ff063e15dbe9b378b4160c9280c7409b22dcb" translate="yes" xml:space="preserve">
          <source>If a dest argument has type *[]byte, Scan saves in that argument a copy of the corresponding data. The copy is owned by the caller and can be modified and held indefinitely. The copy can be avoided by using an argument of type *RawBytes instead; see the documentation for RawBytes for restrictions on its use.</source>
          <target state="translated">如果一个 dest 参数的类型是 *[]字节,Scan 就会将相应数据的副本保存在该参数中。这个副本是由调用者拥有的,并且可以被无限期地修改和保留。可以通过使用类型为 *RawBytes 的参数来避免拷贝;关于它的使用限制,请参见 RawBytes 的文档。</target>
        </trans-unit>
        <trans-unit id="20186d29e290366ced58a159801092dd58a776e3" translate="yes" xml:space="preserve">
          <source>If a field uses a tag &quot;a&amp;gt;b&amp;gt;c&quot;, then the element c will be nested inside parent elements a and b. Fields that appear next to each other that name the same parent will be enclosed in one XML element.</source>
          <target state="translated">如果字段使用标签&amp;ldquo; a&amp;gt; b&amp;gt; c&amp;rdquo;，则元素c将嵌套在父元素a和b中。彼此相邻且名称相同的父级的字段将包含在一个XML元素中。</target>
        </trans-unit>
        <trans-unit id="9df6c8e2aa87346f45992618c6d030de25253b4a" translate="yes" xml:space="preserve">
          <source>If a file's name, after stripping the extension and a possible _test suffix, matches any of the following patterns:</source>
          <target state="translated">如果一个文件的名字,在去掉扩展名和可能的_test后缀后,符合以下任何一种模式。</target>
        </trans-unit>
        <trans-unit id="d6c46042317668db3b232f00f55a1ab61b108925" translate="yes" xml:space="preserve">
          <source>If a goroutine holds a RWMutex for reading and another goroutine might call Lock, no goroutine should expect to be able to acquire a read lock until the initial read lock is released. In particular, this prohibits recursive read locking. This is to ensure that the lock eventually becomes available; a blocked Lock call excludes new readers from acquiring the lock.</source>
          <target state="translated">如果一个goroutine持有一个RWMutex进行读取,而另一个goroutine可能会调用Lock,那么在初始读取锁被释放之前,任何goroutine都不应该期望能够获得一个读取锁。特别是,这禁止递归读锁。这是为了确保锁最终可以使用;被阻止的Lock调用会排除新的读取器获取锁。</target>
        </trans-unit>
        <trans-unit id="54b696ffb9e87ece68a0d432b267874461da7b0c" translate="yes" xml:space="preserve">
          <source>If a pointer argument must be converted to uintptr for use as an argument, that conversion must appear in the call expression itself:</source>
          <target state="translated">如果一个指针参数必须转换为uintptr作为参数使用,这种转换必须出现在调用表达式本身。</target>
        </trans-unit>
        <trans-unit id="a7be185efba59538fbd160cb8d8144506dd7c57d" translate="yes" xml:space="preserve">
          <source>If a subtree has been registered and a request is received naming the subtree root without its trailing slash, ServeMux redirects that request to the subtree root (adding the trailing slash). This behavior can be overridden with a separate registration for the path without the trailing slash. For example, registering &quot;/images/&quot; causes ServeMux to redirect a request for &quot;/images&quot; to &quot;/images/&quot;, unless &quot;/images&quot; has been registered separately.</source>
          <target state="translated">如果已经注册了一个子树,并且收到了一个没有尾部斜线的子树根的请求,ServeMux会将该请求重定向到子树根(添加尾部斜线)。这种行为可以通过单独注册一个没有尾部斜杠的路径来覆盖。例如,注册&quot;/images/&quot;会导致ServeMux将&quot;/images &quot;的请求重定向到&quot;/images/&quot;,除非&quot;/images &quot;被单独注册。</target>
        </trans-unit>
        <trans-unit id="104ed2563a73defc4faea46be899a20063ec818c" translate="yes" xml:space="preserve">
          <source>If a template with the given name already exists, the new HTML template will replace it. The existing template will be reset and disassociated with t.</source>
          <target state="translated">如果给定名称的模板已经存在,新的HTML模板将替换它。现有的模板将被重置并与t脱离关系。</target>
        </trans-unit>
        <trans-unit id="463d47c06a7100464461b73a8101f7660c223839" translate="yes" xml:space="preserve">
          <source>If a value is passed to Encode and the type is not a struct (or pointer to struct, etc.), for simplicity of processing it is represented as a struct of one field. The only visible effect of this is to encode a zero byte after the value, just as after the last field of an encoded struct, so that the decode algorithm knows when the top-level value is complete.</source>
          <target state="translated">如果一个值传递给Encode,且类型不是结构体(或结构体指针等),为了简化处理,将其表示为一个字段的结构体。这样做唯一可见的效果是在值后编码一个零字节,就像在一个编码结构的最后一个字段后编码一样,这样解码算法就知道顶层值何时完成。</target>
        </trans-unit>
        <trans-unit id="d7d467cb048cd5252bcf40b068f20c227a6c5268" translate="yes" xml:space="preserve">
          <source>If an Error or String method triggers a panic when called by a print routine, the fmt package reformats the error message from the panic, decorating it with an indication that it came through the fmt package. For example, if a String method calls panic(&quot;bad&quot;), the resulting formatted message will look like</source>
          <target state="translated">如果一个Error或String方法在被打印例程调用时触发了恐慌,那么fmt包会重新格式化来自恐慌的错误消息,并在其上注明它是通过fmt包发出的。例如,如果一个String方法调用panic(&quot;bad&quot;),则产生的格式化消息看起来会是这样的</target>
        </trans-unit>
        <trans-unit id="d3278ea50ebebf5ea6289948b73b15f204c549e9" translate="yes" xml:space="preserve">
          <source>If an argument has type *interface{}, Scan copies the value provided by the underlying driver without conversion. When scanning from a source value of type []byte to *interface{}, a copy of the slice is made and the caller owns the result.</source>
          <target state="translated">如果一个参数的类型为*interface{},Scan会复制底层驱动程序提供的值,而不进行转换。当从类型为[]byte的源值扫描到*interface{}时,会对分片进行复制,调用者拥有结果。</target>
        </trans-unit>
        <trans-unit id="6c7525fb96a9e6dded8b4dd1c94198523c01a7a6" translate="yes" xml:space="preserve">
          <source>If an error occurs, Import returns a non-nil error and a non-nil *Package containing partial information.</source>
          <target state="translated">如果发生错误,Import会返回一个非nil的错误和一个非nil的包含部分信息的*Package。</target>
        </trans-unit>
        <trans-unit id="22a8988276a496bd99d453fc14d11bfb8cde90f0" translate="yes" xml:space="preserve">
          <source>If an invalid argument is given for a verb, such as providing a string to %d, the generated string will contain a description of the problem, as in these examples:</source>
          <target state="translated">如果给一个动词提供了无效的参数,比如给%d提供了一个字符串,生成的字符串将包含对问题的描述,如这些例子。</target>
        </trans-unit>
        <trans-unit id="2f5f672edd948d125f1a8e2164d6570e08508e2a" translate="yes" xml:space="preserve">
          <source>If any of c.Stdin, c.Stdout or c.Stderr are not an *os.File, Wait also waits for the respective I/O loop copying to or from the process to complete.</source>
          <target state="translated">如果c.Stdin、c.Stdout或c.Stderr中的任何一个不是*os.File,Wait也会等待各自的I/O循环复制到或从进程中复制完成。</target>
        </trans-unit>
        <trans-unit id="f2c348eae7d177d9986e66ac0dbb1fa9c1c8eff2" translate="yes" xml:space="preserve">
          <source>If b has invalid headers and cannot be encoded, EncodeToMemory returns nil. If it is important to report details about this error case, use Encode instead.</source>
          <target state="translated">如果b的头部无效,不能被编码,EncodeToMemory返回nil。如果需要报告这种错误情况的细节,请使用Encode代替。</target>
        </trans-unit>
        <trans-unit id="81446ee41b4f44409d6c98445688e2c9dc448484" translate="yes" xml:space="preserve">
          <source>If base == 0, the base is implied by the string's prefix: base 2 for &quot;0b&quot;, base 8 for &quot;0&quot; or &quot;0o&quot;, base 16 for &quot;0x&quot;, and base 10 otherwise. Also, for base == 0 only, underscore characters are permitted per the Go integer literal syntax. If base is below 0, is 1, or is above 36, an error is returned.</source>
          <target state="translated">如果base ==0,则字符串的前缀暗示了基数:&quot;0b &quot;为基数2,&quot;0 &quot;或 &quot;0o &quot;为基数8,&quot;0x &quot;为基数16,否则为基数10。另外,对于base ==0,根据围棋整数文字语法,允许使用下划线字符。如果基数低于0,为1,或高于36,则返回一个错误。</target>
        </trans-unit>
        <trans-unit id="ff7cc9932856849c823dcd514ebeb18a3facfdc3" translate="yes" xml:space="preserve">
          <source>If body is of type *bytes.Buffer, *bytes.Reader, or *strings.Reader, the returned request's ContentLength is set to its exact value (instead of -1), GetBody is populated (so 307 and 308 redirects can replay the body), and Body is set to NoBody if the ContentLength is 0.</source>
          <target state="translated">如果body的类型是*bytes.Buffer、*bytes.Reader或*strings.Reader,那么返回的请求的ContentLength将被设置为它的精确值(而不是-1),GetBody将被填充(所以307和308重定向可以重放body),如果ContentLength为0,Body将被设置为NoBody。</target>
        </trans-unit>
        <trans-unit id="07cc785c40dfb93b351fa360eaf5c11b3a687a2b" translate="yes" xml:space="preserve">
          <source>If body is true, DumpRequest also returns the body. To do so, it consumes req.Body and then replaces it with a new io.ReadCloser that yields the same bytes. If DumpRequest returns an error, the state of req is undefined.</source>
          <target state="translated">如果body为真,DumpRequest也会返回body。为此,它消耗req.Body,然后用一个新的io.ReadCloser替换它,产生相同的字节。如果DumpRequest返回一个错误,则req的状态是未定义的。</target>
        </trans-unit>
        <trans-unit id="e8579022b484933fe4198bbc194c8a61565aa3ef" translate="yes" xml:space="preserve">
          <source>If d &amp;lt;= 0, connections are reused forever.</source>
          <target state="translated">如果d &amp;lt;= 0，则连接将永远重复使用。</target>
        </trans-unit>
        <trans-unit id="11054b794a9e66d49b745938ef3b656c43f6d39e" translate="yes" xml:space="preserve">
          <source>If data is a reflect.Value, the template applies to the concrete value that the reflect.Value holds, as in fmt.Print.</source>
          <target state="translated">如果数据是一个reflect.Value,则模板适用于reflect.Value所持有的具体值,如fmt.Print.Print中的数据。</target>
        </trans-unit>
        <trans-unit id="f83ceb0ced26c1c764536b5ff1b4fa15e74b62ce" translate="yes" xml:space="preserve">
          <source>If dst implements the ReaderFrom interface, the copy is implemented using it.</source>
          <target state="translated">如果dst实现了ReaderFrom接口,则使用它来实现复制。</target>
        </trans-unit>
        <trans-unit id="6833b17cfcf75e1b486e6c702d0520e85f9b86a2" translate="yes" xml:space="preserve">
          <source>If e.Unwrap() returns a non-nil error w, then we say that e wraps w.</source>
          <target state="translated">如果e.Unwrap()返回一个非零的错误w,那么我们说e包装了w。</target>
        </trans-unit>
        <trans-unit id="81786ec59b1db1b26068cac6cb2b8f77c848e02c" translate="yes" xml:space="preserve">
          <source>If enabled (the default), the Reader expects the input to be a sequence of individually gzipped data streams, each with its own header and trailer, ending at EOF. The effect is that the concatenation of a sequence of gzipped files is treated as equivalent to the gzip of the concatenation of the sequence. This is standard behavior for gzip readers.</source>
          <target state="translated">如果启用(默认),阅读器希望输入是一个单独的gzip数据流序列,每个数据流都有自己的头和预告片,并以EOF结束。其效果是,一个gzip文件序列的连接被视为等同于序列的连接的gzip。这是gzip阅读器的标准行为。</target>
        </trans-unit>
        <trans-unit id="eddf53f9cf1fca82486b2bf4ab21846e817aba06" translate="yes" xml:space="preserve">
          <source>If f calls Run, the result will be an estimate of running all its subbenchmarks that don't call Run in sequence in a single benchmark.</source>
          <target state="translated">如果f调用Run,结果将是在一个基准中依次运行其所有未调用Run的子基准的估计值。</target>
        </trans-unit>
        <trans-unit id="24aa535ef0441b2f9dcbe0e4bbff395ed6067287" translate="yes" xml:space="preserve">
          <source>If f depends on testing flags, then Init must be used to register those flags before calling Benchmark and before calling flag.Parse.</source>
          <target state="translated">如果f依赖于测试标志,那么在调用Benchmark和调用flag.Parse之前,必须使用Init来注册这些标志。</target>
        </trans-unit>
        <trans-unit id="08b53793b968ecc1f35e8cac439169b17517c834" translate="yes" xml:space="preserve">
          <source>If f has a symbol version table, the returned Symbols will have initialized Version and Library fields.</source>
          <target state="translated">如果f有一个符号版本表,那么返回的Symbols将有初始化的版本和库字段。</target>
        </trans-unit>
        <trans-unit id="d8c9bcc7ac7c9df2b87a2dbabc8c6ec7964d0a03" translate="yes" xml:space="preserve">
          <source>If f panics, Do considers it to have returned; future calls of Do return without calling f.</source>
          <target state="translated">如果f惊慌失措,Do就认为它已经返回了;未来Do的调用不需要调用f就能返回。</target>
        </trans-unit>
        <trans-unit id="cfdf3a788dfda0a29c8d0cf447a4cec60c0bc739" translate="yes" xml:space="preserve">
          <source>If file was opened with the O_APPEND flag, WriteAt returns an error.</source>
          <target state="translated">如果文件是以O_APPEND标志打开的,WriteAt返回一个错误。</target>
        </trans-unit>
        <trans-unit id="822b75e4d85498d0d8696aa19251040ab86e6e90" translate="yes" xml:space="preserve">
          <source>If filter != nil, only the files with os.FileInfo entries passing through the filter (and ending in &quot;.go&quot;) are considered. The mode bits are passed to ParseFile unchanged. Position information is recorded in fset, which must not be nil.</source>
          <target state="translated">如果 filter !=nil,则只考虑 os.FileInfo 条目通过过滤器的文件 (并且以&quot;.go &quot;结尾)。模式位不变地传递给 ParseFile。位置信息被记录在 fset 中,它不能为 nil。</target>
        </trans-unit>
        <trans-unit id="78e87476be473e05171bc062a52f2074d7a8ce2f" translate="yes" xml:space="preserve">
          <source>If flush is true, Decode assumes that src represents the end of the input stream and processes it completely rather than wait for the completion of another 32-bit block.</source>
          <target state="translated">如果flush为真,Decode假设src代表输入流的结束,并完全处理它,而不是等待另一个32位块的完成。</target>
        </trans-unit>
        <trans-unit id="abcd3e65f17be630b169b8e4f1f0e366085cdf18" translate="yes" xml:space="preserve">
          <source>If format is a different character, Text returns a &quot;%&quot; followed by the unrecognized format character.</source>
          <target state="translated">如果格式是一个不同的字符,Text会返回一个&quot;%&quot;,后面跟着未识别的格式字符。</target>
        </trans-unit>
        <trans-unit id="5da5429fa2e44a95884b22d9fe6c9389416883fa" translate="yes" xml:space="preserve">
          <source>If id is an embedded struct field, ObjectOf returns the field (*Var) it defines, not the type (*TypeName) it uses.</source>
          <target state="translated">如果id是一个嵌入的结构字段,ObjectOf返回它定义的字段(*Var),而不是它使用的类型(*TypeName)。</target>
        </trans-unit>
        <trans-unit id="5f15fee8dc8778902e45311fbf0205cb96dcffed" translate="yes" xml:space="preserve">
          <source>If inuseZero is true, the profile includes allocation records where r.AllocBytes &amp;gt; 0 but r.AllocBytes == r.FreeBytes. These are sites where memory was allocated, but it has all been released back to the runtime.</source>
          <target state="translated">如果inuseZero为true，则配置文件将包括分配记录，其中r.AllocBytes&amp;gt; 0，但r.AllocBytes == r.FreeBytes。这些是分配了内存的站点，但所有站点都已释放回运行时。</target>
        </trans-unit>
        <trans-unit id="892475b4c6ec1f9a63d5df678595d2602a01d9d3" translate="yes" xml:space="preserve">
          <source>If laddr is nil, a local address is automatically chosen. If the IP field of raddr is nil or an unspecified IP address, the local system is assumed.</source>
          <target state="translated">如果laddr为nil,则自动选择本地地址,如果raddr的IP字段为nil或未指定IP地址,则假定本地系统。如果raddr的IP字段为nil或未指定的IP地址,则假定为本地系统。</target>
        </trans-unit>
        <trans-unit id="ba24dc1c2b3bf1cedb83b06f2414cb64ac15d1da" translate="yes" xml:space="preserve">
          <source>If laddr is non-nil, it is used as the local address for the connection.</source>
          <target state="translated">如果laddr为非零,它将作为连接的本地地址。</target>
        </trans-unit>
        <trans-unit id="9842a555fc5ba63bad435c92db4ce21af1894ec3" translate="yes" xml:space="preserve">
          <source>If level is in the range [-2, 9] then the error returned will be nil. Otherwise the error returned will be non-nil.</source>
          <target state="translated">如果level在[-2,9]范围内,那么返回的错误将为nil。否则返回的错误将为非零。</target>
        </trans-unit>
        <trans-unit id="550da103e5e342ac2c8eff3e35ca3b010db8375f" translate="yes" xml:space="preserve">
          <source>If modtime is not the zero time or Unix epoch, ServeContent includes it in a Last-Modified header in the response. If the request includes an If-Modified-Since header, ServeContent uses modtime to decide whether the content needs to be sent at all.</source>
          <target state="translated">如果modtime不是零时间或Unix epoch,ServeContent会把它包含在响应的Last-Modified头中。如果请求包含一个If-Modified-Since头,ServeContent使用modtime来决定是否需要发送内容。</target>
        </trans-unit>
        <trans-unit id="4498ca26095d9f0afc17fc3d124ee10f9b929767" translate="yes" xml:space="preserve">
          <source>If n &amp;gt; 0, Readdir returns at most n FileInfo structures. In this case, if Readdir returns an empty slice, it will return a non-nil error explaining why. At the end of a directory, the error is io.EOF.</source>
          <target state="translated">如果n&amp;gt; 0，则Readdir最多返回n个FileInfo结构。在这种情况下，如果Readdir返回一个空片，它将返回一个非null错误，说明原因。在目录末尾，错误是io.EOF。</target>
        </trans-unit>
        <trans-unit id="fc3b271d5f3a597b07b28cf1083fa8b465cfe35b" translate="yes" xml:space="preserve">
          <source>If n &amp;gt; 0, Readdirnames returns at most n names. In this case, if Readdirnames returns an empty slice, it will return a non-nil error explaining why. At the end of a directory, the error is io.EOF.</source>
          <target state="translated">如果n&amp;gt; 0，则Readdirnames最多返回n个名称。在这种情况下，如果Readdirnames返回一个空片，它将返回一个非null错误，说明原因。在目录末尾，错误是io.EOF。</target>
        </trans-unit>
        <trans-unit id="eac4c3ba5a8c94ad8cb8a4a397c8ee90135cea13" translate="yes" xml:space="preserve">
          <source>If n &amp;lt;= 0, Readdir returns all the FileInfo from the directory in a single slice. In this case, if Readdir succeeds (reads all the way to the end of the directory), it returns the slice and a nil error. If it encounters an error before the end of the directory, Readdir returns the FileInfo read until that point and a non-nil error.</source>
          <target state="translated">如果n &amp;lt;= 0，则Readdir在单个片中返回目录中的所有FileInfo。在这种情况下，如果Readdir成功（一直读取到目录的末尾），它将返回切片和nil错误。如果它在目录末尾之前遇到错误，则Readdir返回读取的FileInfo直到该点为止，并且返回非nil错误。</target>
        </trans-unit>
        <trans-unit id="c3cc55f92ff37a98b5144ea82d578410d2c8c458" translate="yes" xml:space="preserve">
          <source>If n &amp;lt;= 0, Readdirnames returns all the names from the directory in a single slice. In this case, if Readdirnames succeeds (reads all the way to the end of the directory), it returns the slice and a nil error. If it encounters an error before the end of the directory, Readdirnames returns the names read until that point and a non-nil error.</source>
          <target state="translated">如果n &amp;lt;= 0，则Readdirnames在单个片中返回目录中的所有名称。在这种情况下，如果Readdirnames成功（一直读取到目录的末尾），它将返回切片和nil错误。如果在目录末尾遇到错误，Readdirnames将返回读取的名称，直到该点为止，并且返回非nil错误。</target>
        </trans-unit>
        <trans-unit id="2b903f7cf121247bf3e7b3aca6c7022dbb5df0e4" translate="yes" xml:space="preserve">
          <source>If n &amp;lt;= 0, no idle connections are retained.</source>
          <target state="translated">如果n &amp;lt;= 0，则不保留空闲连接。</target>
        </trans-unit>
        <trans-unit id="be61ba0537fe2779cebfab91a18a370978aeba0f" translate="yes" xml:space="preserve">
          <source>If n &amp;lt;= 0, then there is no limit on the number of open connections. The default is 0 (unlimited).</source>
          <target state="translated">如果n &amp;lt;= 0，则打开的连接数没有限制。默认值为0（无限制）。</target>
        </trans-unit>
        <trans-unit id="3ffbdba0310e5330b6e39ba21df32f4ec64c1673" translate="yes" xml:space="preserve">
          <source>If name contains no path separators, Command uses LookPath to resolve name to a complete path if possible. Otherwise it uses name directly as Path.</source>
          <target state="translated">如果name不包含路径分隔符,Command会尽可能使用LookPath将name解析为一个完整的路径。否则它直接使用name作为Path。</target>
        </trans-unit>
        <trans-unit id="e919c20774517f309335e67ee8266068c715cb69" translate="yes" xml:space="preserve">
          <source>If no entry is found, a nil object is returned. In this case, the returned index and indirect values have the following meaning:</source>
          <target state="translated">如果没有找到条目,将返回一个nil对象。在这种情况下,返回的索引和间接值具有以下含义。</target>
        </trans-unit>
        <trans-unit id="2a51e78e82aff9bdb39269ef8cd918a49b097d8e" translate="yes" xml:space="preserve">
          <source>If opts.Roots is nil and system roots are unavailable the returned error will be of type SystemRootsError.</source>
          <target state="translated">如果opts.Root为nil,并且系统根不可用,返回的错误类型为SystemRootsError。</target>
        </trans-unit>
        <trans-unit id="93b29b6dd544ee070bf7867f11c38d0b30ce0f19" translate="yes" xml:space="preserve">
          <source>If p points into an allocated object, it can be advanced through the object by conversion to uintptr, addition of an offset, and conversion back to Pointer.</source>
          <target state="translated">如果p指向一个已分配的对象,则可以通过转换为uintptr,加上偏移量,再转换回Pointer,来推进这个对象。</target>
        </trans-unit>
        <trans-unit id="9c4a4899af1972effe20bb6d4fb3e2cc68991f24" translate="yes" xml:space="preserve">
          <source>If pc is not covered by any entry in this line table, SeekPC returns ErrUnknownPC. In this case, *entry and the final seek position are unspecified.</source>
          <target state="translated">如果pc没有被该行表的任何条目覆盖,SeekPC返回ErrUnknownPC。在这种情况下,*条目和最终的寻求位置是未指定的。</target>
        </trans-unit>
        <trans-unit id="47b9ebf87a72a4fc29d6e9526a5e472474f83dfe" translate="yes" xml:space="preserve">
          <source>If pc represents multiple functions because of inlining, it returns the a *Func describing the innermost function, but with an entry of the outermost function.</source>
          <target state="translated">如果pc因为内联而代表多个函数,则返回描述最内层函数的a *Func,但有一个最外层函数的条目。</target>
        </trans-unit>
        <trans-unit id="8759c1ffe2421dc4e493bad121916d1c4a784268" translate="yes" xml:space="preserve">
          <source>If pkg == nil, the Universe scope is used and the provided position pos is ignored. If pkg != nil, and pos is invalid, the package scope is used. Otherwise, pos must belong to the package.</source>
          <target state="translated">如果 pkg ==nil,则使用 Universe 作用域,并忽略提供的位置 pos。如果 pkg !=nil,并且 pos 无效,则使用包的作用域。否则,pos必须属于包的范围。</target>
        </trans-unit>
        <trans-unit id="3b501d10f0b3315a0edcb0a3aa0bfa72db3f19b3" translate="yes" xml:space="preserve">
          <source>If pkg was loaded from export data, Imports includes packages that provide package-level objects referenced by pkg. This may be more or less than the set of packages directly imported by pkg's source code.</source>
          <target state="translated">如果 pkg 是从导出数据中加载的,那么 Imports 包括提供 pkg 引用的包级对象的包。这可能比 pkg 的源代码直接导入的包的数量多或少。</target>
        </trans-unit>
        <trans-unit id="a13dac68b11bffa0323115aff464b296dab14f09" translate="yes" xml:space="preserve">
          <source>If r and s point to different rings, linking them creates a single ring with the elements of s inserted after r. The result points to the element following the last element of s after insertion.</source>
          <target state="translated">如果r和s指向不同的环,将它们连接起来就会产生一个单一的环,s的元素插入到r之后,结果指向插入后s的最后一个元素。</target>
        </trans-unit>
        <trans-unit id="b045896c9ac0e612d840b26fdcd16f9492dfd688" translate="yes" xml:space="preserve">
          <source>If r and s point to the same ring, linking them removes the elements between r and s from the ring. The removed elements form a subring and the result is a reference to that subring (if no elements were removed, the result is still the original value for r.Next(), and not nil).</source>
          <target state="translated">如果r和s指向同一个环,那么将它们连接起来,就会从环中删除r和s之间的元素,删除的元素形成一个子环,结果是对该子环的引用(如果没有删除元素,结果仍然是r.Next()的原始值,而不是nil)。删除的元素形成一个子环,结果是对该子环的引用(如果没有删除元素,结果仍然是r.Next()的原始值,而不是nil)。</target>
        </trans-unit>
        <trans-unit id="8848277c3a29719067a054c042f2cd449fd3596a" translate="yes" xml:space="preserve">
          <source>If rand is not nil then RSA blinding will be used to avoid timing side-channel attacks.</source>
          <target state="translated">如果rand不是nil,那么将使用RSA blinding来避免定时侧通道攻击。</target>
        </trans-unit>
        <trans-unit id="a19e63938d7a0894376439e5599ffa43b250a5d4" translate="yes" xml:space="preserve">
          <source>If rt.RoundTrip returns ErrSkipAltProtocol, the Transport will handle the RoundTrip itself for that one request, as if the protocol were not registered.</source>
          <target state="translated">如果rt.RoundTrip返回ErrSkipAltProtocol,Transport将为这一个请求处理RoundTrip本身,就像协议没有注册一样。</target>
        </trans-unit>
        <trans-unit id="54ad40399e089deda52c88ae3ba4659988c86560" translate="yes" xml:space="preserve">
          <source>If s does not contain sep and sep is not empty, Split returns a slice of length 1 whose only element is s.</source>
          <target state="translated">如果s不包含sep,并且sep不是空的,Split返回一个长度为1的分片,其唯一的元素是s。</target>
        </trans-unit>
        <trans-unit id="9daee5dcf8a47681ddd5e5f835fb1dbed1f83aea" translate="yes" xml:space="preserve">
          <source>If s does not contain sep and sep is not empty, SplitAfter returns a slice of length 1 whose only element is s.</source>
          <target state="translated">如果s不包含sep,并且sep不是空的,SplitAfter返回一个长度为1的分片,其唯一的元素是s。</target>
        </trans-unit>
        <trans-unit id="95759bb8e19ebcbb98672ac7fdd18943d4708775" translate="yes" xml:space="preserve">
          <source>If s is not syntactically well-formed, ParseFloat returns err.Err = ErrSyntax.</source>
          <target state="translated">如果s在语法上不完善,ParseFloat返回err.Err=ErrSyntax。</target>
        </trans-unit>
        <trans-unit id="3e257c93b527ddb828e688937de0ccc11edf5f79" translate="yes" xml:space="preserve">
          <source>If s is syntactically well-formed but is more than 1/2 ULP away from the largest floating point number of the given size, ParseFloat returns f = &amp;plusmn;Inf, err.Err = ErrRange.</source>
          <target state="translated">如果s在语法上格式正确，但与给定大小的最大浮点数相差超过1/2 ULP，则ParseFloat返回f =&amp;plusmn;Inf，err.Err = ErrRange。</target>
        </trans-unit>
        <trans-unit id="2958c3475b5e1c01d3ef1742914960b9002f7a9e" translate="yes" xml:space="preserve">
          <source>If sec &amp;gt; 0, the data is sent in the background as with sec &amp;lt; 0. On some operating systems after sec seconds have elapsed any remaining unsent data may be discarded.</source>
          <target state="translated">如果sec&amp;gt; 0，则与sec &amp;lt;0一样在后台发送数据。在某些操作系统上，经过sec秒后，所有剩余的未发送数据都可能会被丢弃。</target>
        </trans-unit>
        <trans-unit id="f56f69cce6422c40a21ab01c5418cdbd4bf77063" translate="yes" xml:space="preserve">
          <source>If sec &amp;lt; 0 (the default), the operating system finishes sending the data in the background.</source>
          <target state="translated">如果sec &amp;lt;0（默认值），则操作系统将在后台完成数据发送。</target>
        </trans-unit>
        <trans-unit id="d8d3489dffe9a7fe6c9ad9a620bad31395af4507" translate="yes" xml:space="preserve">
          <source>If sec == 0, the operating system discards any unsent or unacknowledged data.</source>
          <target state="translated">如果sec ==0,操作系统会丢弃任何未发送或未确认的数据。</target>
        </trans-unit>
        <trans-unit id="be66aebe1a8866a8f4dc281f1bd57616b1f982bc" translate="yes" xml:space="preserve">
          <source>If sep is empty, Split splits after each UTF-8 sequence. If both s and sep are empty, Split returns an empty slice.</source>
          <target state="translated">如果sep为空,Split在每个UTF-8序列后进行分割。如果s和sep都为空,Split返回一个空分片。</target>
        </trans-unit>
        <trans-unit id="489ca1eca08b1f0a405730583d47d533fb4b076e" translate="yes" xml:space="preserve">
          <source>If sep is empty, SplitAfter splits after each UTF-8 sequence. If both s and sep are empty, SplitAfter returns an empty slice.</source>
          <target state="translated">如果sep为空,SplitAfter会在每个UTF-8序列后进行分割。如果s和sep都是空的,SplitAfter返回一个空的分片。</target>
        </trans-unit>
        <trans-unit id="2a3657d8164caf54f78f733fc8ef2ecda3905624" translate="yes" xml:space="preserve">
          <source>If src != nil, ParseFile parses the source from src and the filename is only used when recording position information. The type of the argument for the src parameter must be string, []byte, or io.Reader. If src == nil, ParseFile parses the file specified by filename.</source>
          <target state="translated">如果 src !=nil,ParseFile 将从 src 解析源文件,并且文件名仅在记录位置信息时使用。src参数的类型必须是string、[]byte或io.Reader。如果 src ==nil,ParseFile 会解析 filename 所指定的文件。</target>
        </trans-unit>
        <trans-unit id="fe8d7fb1ea6082771e2bec41671407fae46d618e" translate="yes" xml:space="preserve">
          <source>If src implements the WriterTo interface, the copy is implemented by calling src.WriteTo(dst). Otherwise, if dst implements the ReaderFrom interface, the copy is implemented by calling dst.ReadFrom(src).</source>
          <target state="translated">如果 src 实现了 WriterTo 接口,则通过调用 src.WriteTo(dst)来实现复制。否则,如果 dst 实现了 ReaderFrom 接口,则通过调用 dst.ReadFrom(src)实现复制。</target>
        </trans-unit>
        <trans-unit id="e40b342e6817ab9c3ac4432d840f11c1f0b22325" translate="yes" xml:space="preserve">
          <source>If src is a partial source file, the leading and trailing space of src is applied to the result (such that it has the same leading and trailing space as src), and the result is indented by the same amount as the first line of src containing code. Imports are not sorted for partial source files.</source>
          <target state="translated">如果 src 是一个部分源文件,src 的前导和尾部空间会应用到结果中(使其具有与 src 相同的前导和尾部空间),并且结果会与包含代码的 src 的第一行缩进相同的数量。对于部分源文件,导入不进行排序。</target>
        </trans-unit>
        <trans-unit id="7c67bad25cffc131c00d1eef36d585ec638c9170" translate="yes" xml:space="preserve">
          <source>If srv.Addr is blank, &quot;:http&quot; is used.</source>
          <target state="translated">如果srv.Addr为空白,则使用&quot;:http&quot;。</target>
        </trans-unit>
        <trans-unit id="f9e50e1a49136013b88aa780931a141882ea6f39" translate="yes" xml:space="preserve">
          <source>If srv.Addr is blank, &quot;:https&quot; is used.</source>
          <target state="translated">如果srv.Addr为空白,则使用&quot;:https&quot;。</target>
        </trans-unit>
        <trans-unit id="ad0892d319e6dc448b8b5b8890782a44c3d82311" translate="yes" xml:space="preserve">
          <source>If successful, tmpl will now be injection-safe. Otherwise, err is an error defined in the docs for ErrorCode.</source>
          <target state="translated">如果成功,tmpl现在将是注入安全的。否则,err就是一个在ErrorCode文档中定义的错误。</target>
        </trans-unit>
        <trans-unit id="178b407eef387370d388c8cfe01edb64789c6b52" translate="yes" xml:space="preserve">
          <source>If the Client's Transport does not have a CloseIdleConnections method then this method does nothing.</source>
          <target state="translated">如果客户端的Transport没有CloseIdleConnections方法,那么这个方法就没有任何作用。</target>
        </trans-unit>
        <trans-unit id="a2836eacebc948128e4aa3ce4d8b1d3fc7d6a477" translate="yes" xml:space="preserve">
          <source>If the Content-Type header has not been set, Redirect sets it to &quot;text/html; charset=utf-8&quot; and writes a small HTML body. Setting the Content-Type header to any value, including nil, disables that behavior.</source>
          <target state="translated">如果没有设置Content-Type头,Redirect将其设置为 &quot;text/html;charset=utf-8&quot;,并写入一个小的HTML正文。将Content-Type头设置为任何值,包括nil,都会禁用该行为。</target>
        </trans-unit>
        <trans-unit id="3ae6135ca1107639811cd5daef71ae7fca79e2f6" translate="yes" xml:space="preserve">
          <source>If the Context field is 0, the context function is being called to record the current traceback context. It should record in the Context field whatever information is needed about the current point of execution to later produce a stack trace, probably the stack pointer and PC. In this case the context function will be called from C code.</source>
          <target state="translated">如果Context字段为0,则调用context函数记录当前的回溯上下文,它应该在Context字段中记录当前执行点的任何信息,以便以后产生堆栈跟踪,可能是堆栈指针和PC。它应该在Context字段中记录关于当前执行点的任何信息,以便以后产生堆栈跟踪,可能是堆栈指针和PC。在这种情况下,上下文函数将从C代码中调用。</target>
        </trans-unit>
        <trans-unit id="42011269501bbfe9917fe4565b51ba6a042b7ead" translate="yes" xml:space="preserve">
          <source>If the Context field is not 0, then it is a value returned by a previous call to the context function. This case is called when the context is no longer needed; that is, when the Go code is returning to its C code caller. This permits the context function to release any associated resources.</source>
          <target state="translated">如果Context字段不是0,那么它就是之前调用上下文函数返回的值。这种情况下,当不再需要上下文时,也就是当Go代码返回到C代码调用者时,就会被调用。这允许上下文函数释放任何相关的资源。</target>
        </trans-unit>
        <trans-unit id="084a8ea923e025ba6d8130824462ac823dad2f19" translate="yes" xml:space="preserve">
          <source>If the Delta field of a CaseRange is UpperLower, it means this CaseRange represents a sequence of the form (say) Upper Lower Upper Lower.</source>
          <target state="translated">如果一个CaseRange的Delta字段是UpperLower,那么就意味着这个CaseRange表示一个形式(比如)Upper Lower Upper Lower的序列。</target>
        </trans-unit>
        <trans-unit id="99155dad735e31c1f83383d55994a89a1d5b0d8e" translate="yes" xml:space="preserve">
          <source>If the Go program is started with a non-empty signal mask, that will generally be honored. However, some signals are explicitly unblocked: the synchronous signals, SIGILL, SIGTRAP, SIGSTKFLT, SIGCHLD, SIGPROF, and, on GNU/Linux, signals 32 (SIGCANCEL) and 33 (SIGSETXID) (SIGCANCEL and SIGSETXID are used internally by glibc). Subprocesses started by os.Exec, or by the os/exec package, will inherit the modified signal mask.</source>
          <target state="translated">如果围棋程序以非空信号掩码启动,通常会被尊重。然而,有些信号是显式地被解除屏蔽的:同步信号SIGILL、SIGTRAP、SIGSTKFLT、SIGCHLD、SIGPROF,以及GNU/Linux上的信号32(SIGCANCEL)和33(SIGSETXID)(SIGCANCEL和SIGSETXID由glibc内部使用)。由 os.Exec 或 os/exec 包启动的子进程将继承修改后的信号掩码。</target>
        </trans-unit>
        <trans-unit id="9a19e7607fdf15201f487fc6adac4a654bb31d6b" translate="yes" xml:space="preserve">
          <source>If the Go program is started with either SIGHUP or SIGINT ignored (signal handler set to SIG_IGN), they will remain ignored.</source>
          <target state="translated">如果围棋程序启动时忽略了SIGHUP或SIGINT(信号处理程序设置为SIG_IGN),它们将保持被忽略状态。</target>
        </trans-unit>
        <trans-unit id="bb2401bc392b8c040ae8577c33db0583e1939491" translate="yes" xml:space="preserve">
          <source>If the Go runtime sees an existing signal handler for the SIGCANCEL or SIGSETXID signals (which are used only on GNU/Linux), it will turn on the SA_ONSTACK flag and otherwise keep the signal handler.</source>
          <target state="translated">如果Go运行时看到SIGCANCEL或SIGSETXID信号(仅在GNU/Linux上使用)的现有信号处理程序,它将打开SA_ONSTACK标志,否则将保留该信号处理程序。</target>
        </trans-unit>
        <trans-unit id="b8c9bbe3199fe348a3ebb3c33bad8f777f2557ca" translate="yes" xml:space="preserve">
          <source>If the Go signal handler is invoked on a non-Go thread not running Go code, the handler generally forwards the signal to the non-Go code, as follows. If the signal is SIGPROF, the Go handler does nothing. Otherwise, the Go handler removes itself, unblocks the signal, and raises it again, to invoke any non-Go handler or default system handler. If the program does not exit, the Go handler then reinstalls itself and continues execution of the program.</source>
          <target state="translated">如果在没有运行围棋代码的非围棋线程上调用围棋信号处理程序,处理程序一般会将信号转发给非围棋代码,具体如下。如果信号是SIGPROF,围棋处理程序不做任何操作。否则,围棋处理程序将自己移走,解锁信号,并再次引发信号,以调用任何非围棋处理程序或默认的系统处理程序。如果程序没有退出,围棋处理程序就会重新安装自己,继续执行程序。</target>
        </trans-unit>
        <trans-unit id="d1450a83e799c9f838308f1831ad2410ca5837bc" translate="yes" xml:space="preserve">
          <source>If the IP field of laddr is nil or an unspecified IP address, ListenIP listens on all available IP addresses of the local system except multicast IP addresses.</source>
          <target state="translated">如果laddr的IP字段为nil或未指定的IP地址,ListenIP会监听本地系统中除组播IP地址以外的所有可用IP地址。</target>
        </trans-unit>
        <trans-unit id="af82767d02391b6e900db2816b87a4fb9f84a234" translate="yes" xml:space="preserve">
          <source>If the IP field of laddr is nil or an unspecified IP address, ListenTCP listens on all available unicast and anycast IP addresses of the local system. If the Port field of laddr is 0, a port number is automatically chosen.</source>
          <target state="translated">如果laddr的IP字段为nil或未指定的IP地址,ListenTCP监听本地系统所有可用的单播和任意播IP地址。如果laddr的Port字段为0,则自动选择一个端口号。</target>
        </trans-unit>
        <trans-unit id="af86e9317bf51d088cb071c3ee8a01bff50d7b6b" translate="yes" xml:space="preserve">
          <source>If the IP field of laddr is nil or an unspecified IP address, ListenUDP listens on all available IP addresses of the local system except multicast IP addresses. If the Port field of laddr is 0, a port number is automatically chosen.</source>
          <target state="translated">如果laddr的IP字段为nil或未指定的IP地址,则ListenUDP监听本地系统中除组播IP地址以外的所有可用IP地址。如果laddr的Port字段为0,则会自动选择一个端口号。</target>
        </trans-unit>
        <trans-unit id="5b648936c52bc2fbcc7b753478ee856cc09da205" translate="yes" xml:space="preserve">
          <source>If the XML name for a struct field is defined by both the field tag and the struct's XMLName field, the names must match.</source>
          <target state="translated">如果一个结构字段的XML名称由字段标签和结构的XMLName字段同时定义,则名称必须匹配。</target>
        </trans-unit>
        <trans-unit id="3ef1f744f6bc6158c837d3a4a05d2dd7419e3d5c" translate="yes" xml:space="preserve">
          <source>If the caller has set w's ETag header formatted per RFC 7232, section 2.3, ServeContent uses it to handle requests using If-Match, If-None-Match, or If-Range.</source>
          <target state="translated">如果调用者按照RFC 7232的2.3节设置了w的ETag头格式,ServeContent就会使用它来处理使用If-Match、If-None-Match或If-Range的请求。</target>
        </trans-unit>
        <trans-unit id="7fe34f55752121c99936b8403a6063a8914cb06e" translate="yes" xml:space="preserve">
          <source>If the calling goroutine has locked the operating system thread with runtime.LockOSThread and modified any inheritable OS-level thread state (for example, Linux or Plan 9 name spaces), the new process will inherit the caller's thread state.</source>
          <target state="translated">如果调用的goroutine已经用runtime.LockOSThread锁定了操作系统线程,并修改了任何可继承的操作系统级线程状态(例如Linux或Plan 9的名字空间),新进程将继承调用者的线程状态。</target>
        </trans-unit>
        <trans-unit id="259a07efdd482c1e280dc36d61c76b7e373057fb" translate="yes" xml:space="preserve">
          <source>If the command fails to run or doesn't complete successfully, the error is of type *ExitError. Other error types may be returned for I/O problems.</source>
          <target state="translated">如果命令不能运行或不能成功完成,错误类型为*ExitError。对于I/O问题,可能会返回其他错误类型。</target>
        </trans-unit>
        <trans-unit id="b33403be418b27f91a2d42d554ef5c02f7c63947" translate="yes" xml:space="preserve">
          <source>If the command starts but does not complete successfully, the error is of type *ExitError. Other error types may be returned for other situations.</source>
          <target state="translated">如果命令启动但没有成功完成,错误类型为*ExitError。对于其他情况,可能会返回其他错误类型。</target>
        </trans-unit>
        <trans-unit id="5a122d2b8c97a37a880702f2a3fbe016e3749fd3" translate="yes" xml:space="preserve">
          <source>If the current file is sparse, then the regions marked as a hole are read back as NUL-bytes.</source>
          <target state="translated">如果当前文件是稀疏的,那么标记为空洞的区域将被读回为NUL字节。</target>
        </trans-unit>
        <trans-unit id="6253658c1bbbfe0517d9a4b3227473cd894d597c" translate="yes" xml:space="preserve">
          <source>If the directory couldn't be read, a nil map and the respective error are returned. If a parse error occurred, a non-nil but incomplete map and the first error encountered are returned.</source>
          <target state="translated">如果目录无法被读取,则返回一个nil map和相应的错误。如果发生了解析错误,则返回一个非零但不完整的映射和遇到的第一个错误。</target>
        </trans-unit>
        <trans-unit id="01b40bd5ac5583f9db3311853c6994966859d236" translate="yes" xml:space="preserve">
          <source>If the driver supports cursors, a returned Value may also implement the Rows interface in this package. This is used, for example, when a user selects a cursor such as &quot;select cursor(select * from my_table) from dual&quot;. If the Rows from the select is closed, the cursor Rows will also be closed.</source>
          <target state="translated">如果驱动程序支持游标,返回的Value也可以实现这个包中的Rows接口。例如,当用户选择一个游标,如 &quot;select cursor(select*from my_table)from dual &quot;时,就会用到这个接口。如果选择的Rows被关闭,游标Rows也将被关闭。</target>
        </trans-unit>
        <trans-unit id="cf50ebb80b297da2b505a620be031cb25dcead76" translate="yes" xml:space="preserve">
          <source>If the format (which is implicitly %v for Println etc.) is valid for a string (%s %q %v %x %X), the following two rules apply:</source>
          <target state="translated">如果格式(对于Println等来说是隐含的%v)对于一个字符串(%s %q %v %x %X)是有效的,那么就适用以下两个规则。</target>
        </trans-unit>
        <trans-unit id="0f42e25dba03dca0e51f87ed12e981c71373e332" translate="yes" xml:space="preserve">
          <source>If the format specifier includes a %w verb with an error operand, the returned error will implement an Unwrap method returning the operand. It is invalid to include more than one %w verb or to supply it with an operand that does not implement the error interface. The %w verb is otherwise a synonym for %v.</source>
          <target state="translated">如果格式指定器包含一个带有错误操作数的%w动词,返回的错误将实现一个返回操作数的Unwrap方法。包含一个以上的%w动词或提供一个没有实现错误接口的操作数是无效的。否则%w动词就是%v的同义词。</target>
        </trans-unit>
        <trans-unit id="b70a519f0eee1914e654572a47f9ae5a7a8a3889" translate="yes" xml:space="preserve">
          <source>If the host in the address parameter is not a literal IP address or the port is not a literal port number, ResolveTCPAddr resolves the address to an address of TCP end point. Otherwise, it parses the address as a pair of literal IP address and port number. The address parameter can use a host name, but this is not recommended, because it will return at most one of the host name's IP addresses.</source>
          <target state="translated">如果地址参数中的主机不是字面的IP地址,或者端口不是字面的端口号,ResolveTCPAddr会将地址解析为TCP端点的地址。否则,它会将地址解析为一对字面的IP地址和端口号。地址参数可以使用主机名,但不建议这样做,因为它最多返回主机名的一个IP地址。</target>
        </trans-unit>
        <trans-unit id="60603d4b10b0e1d0e446fdae0a4a44c25a6c45b7" translate="yes" xml:space="preserve">
          <source>If the host in the address parameter is not a literal IP address or the port is not a literal port number, ResolveUDPAddr resolves the address to an address of UDP end point. Otherwise, it parses the address as a pair of literal IP address and port number. The address parameter can use a host name, but this is not recommended, because it will return at most one of the host name's IP addresses.</source>
          <target state="translated">如果地址参数中的主机不是字面的IP地址,或者端口不是字面的端口号,ResolveUDPAddr就会将地址解析为UDP端点的地址。否则,它会将地址解析为一对字面的IP地址和端口号。地址参数可以使用主机名,但不建议这样做,因为它最多返回主机名的一个IP地址。</target>
        </trans-unit>
        <trans-unit id="cd0fc2990a9a9cf8fad81f64436555d3d6b35355" translate="yes" xml:space="preserve">
          <source>If the host in the address parameter is not a literal IP address, ResolveIPAddr resolves the address to an address of IP end point. Otherwise, it parses the address as a literal IP address. The address parameter can use a host name, but this is not recommended, because it will return at most one of the host name's IP addresses.</source>
          <target state="translated">如果地址参数中的主机不是一个字面的IP地址,ResolveIPAddr会将该地址解析为IP端点的地址。否则,它将把地址解析为一个字面的IP地址。地址参数可以使用主机名,但不建议这样做,因为它最多返回主机名的一个IP地址。</target>
        </trans-unit>
        <trans-unit id="199da3dce7215d4cebc5f4fd0619e8dbc8fd6d9d" translate="yes" xml:space="preserve">
          <source>If the key type is not a valid map key type (that is, if it does not implement Go's == operator), MapOf panics.</source>
          <target state="translated">如果键类型不是有效的映射键类型(也就是说,如果它没有实现Go的==操作符),MapOf就会恐慌。</target>
        </trans-unit>
        <trans-unit id="fdcae4b6d304718d87888a4b14792a984d6db584" translate="yes" xml:space="preserve">
          <source>If the location cannot be determined (for example, $HOME is not defined), then it will return an error.</source>
          <target state="translated">如果不能确定位置(例如,没有定义$HOME),那么它将返回一个错误。</target>
        </trans-unit>
        <trans-unit id="83fc45c3d88185bce6b913b6fba87e76a3564c14" translate="yes" xml:space="preserve">
          <source>If the n = len(p) bytes returned by ReadAt are at the end of the input source, ReadAt may return either err == EOF or err == nil.</source>
          <target state="translated">如果ReadAt返回的n=len(p)字节处于输入源的末端,ReadAt可能返回err ==EOF或err ==nil。</target>
        </trans-unit>
        <trans-unit id="96928e9a3e37cddefc97fd6808cb69e209a645f8" translate="yes" xml:space="preserve">
          <source>If the name is &quot;&quot; or &quot;UTC&quot;, LoadLocation returns UTC. If the name is &quot;Local&quot;, LoadLocation returns Local.</source>
          <target state="translated">如果名称是&quot;&quot;或 &quot;UTC&quot;,LoadLocation 返回 UTC。如果名称是 &quot;Local&quot;,LoadLocation返回Local。</target>
        </trans-unit>
        <trans-unit id="71bd5d676aea790d3104c9356a66a88a54f27219" translate="yes" xml:space="preserve">
          <source>If the non-Go code called by the Go program does not change any signal handlers or masks, then the behavior is the same as for a pure Go program.</source>
          <target state="translated">如果围棋程序调用的非围棋代码不改变任何信号处理程序或掩码,那么行为就和纯围棋程序一样。</target>
        </trans-unit>
        <trans-unit id="7ff28c4dacda2b677d57a006ed06c589035c4906" translate="yes" xml:space="preserve">
          <source>If the non-Go code installs a signal handler for any of the asynchronous signals, it may invoke the Go signal handler or not as it chooses. Naturally, if it does not invoke the Go signal handler, the Go behavior described above will not occur. This can be an issue with the SIGPROF signal in particular.</source>
          <target state="translated">如果非围棋代码为任何异步信号安装了信号处理程序,它可以选择是否调用围棋信号处理程序。当然,如果它不调用围棋信号处理程序,上述的围棋行为就不会发生。尤其是SIGPROF信号,这可能是一个问题。</target>
        </trans-unit>
        <trans-unit id="abd2048f2311a9e6d64b579961e64f72d37d33a6" translate="yes" xml:space="preserve">
          <source>If the non-Go code installs a signal handler for any of the synchronous signals (SIGBUS, SIGFPE, SIGSEGV), then it should record the existing Go signal handler. If those signals occur while executing Go code, it should invoke the Go signal handler (whether the signal occurs while executing Go code can be determined by looking at the PC passed to the signal handler). Otherwise some Go run-time panics will not occur as expected.</source>
          <target state="translated">如果非围棋代码为任何同步信号(SIGBUS、SIGFPE、SIGSEGV)安装了信号处理程序,那么它应该记录现有的围棋信号处理程序。如果这些信号在执行围棋代码时发生,则应该调用围棋信号处理程序(信号是否在执行围棋代码时发生,可以通过查看传递给信号处理程序的PC来判断)。否则一些围棋运行时的慌乱将不会如期发生。</target>
        </trans-unit>
        <trans-unit id="bb19b115a2d359b987ea5bcb60343aca9ae430dd" translate="yes" xml:space="preserve">
          <source>If the non-Go code installs any signal handlers, it must use the SA_ONSTACK flag with sigaction. Failing to do so is likely to cause the program to crash if the signal is received. Go programs routinely run with a limited stack, and therefore set up an alternate signal stack. Also, the Go standard library expects that any signal handlers will use the SA_RESTART flag. Failing to do so may cause some library calls to return &quot;interrupted system call&quot; errors.</source>
          <target state="translated">如果非围棋代码安装了任何信号处理程序,必须使用sigaction的SA_ONSTACK标志。如果没有这样做,很可能导致程序在收到信号时崩溃。Go程序经常在有限的堆栈下运行,因此设置了一个备用的信号堆栈。另外,Go标准库期望任何信号处理程序都会使用SA_RESTART标志。如果没有这样做,可能会导致一些库调用返回 &quot;中断的系统调用 &quot;错误。</target>
        </trans-unit>
        <trans-unit id="7e1d203998def7d0f58007e88176f92e21a64b50" translate="yes" xml:space="preserve">
          <source>If the non-Go code starts a new thread, changes the signal mask, and then invokes a Go function in that thread, the Go runtime will automatically unblock certain signals: the synchronous signals, SIGILL, SIGTRAP, SIGSTKFLT, SIGCHLD, SIGPROF, SIGCANCEL, and SIGSETXID. When the Go function returns, the non-Go signal mask will be restored.</source>
          <target state="translated">如果非围棋代码启动一个新的线程,更改信号掩码,然后在该线程中调用围棋函数,围棋运行时将自动解除某些信号的屏蔽:同步信号SIGILL、SIGTRAP、SIGSTKFLT、SIGCHLD、SIGPROF、SIGCANCEL和SIGSETXID。当围棋函数返回时,非围棋信号掩码将被恢复。</target>
        </trans-unit>
        <trans-unit id="91074ebc7a3334ebd4f37cdfabaa9ca32fd24f74" translate="yes" xml:space="preserve">
          <source>If the open fails, the error string will be self-explanatory, like</source>
          <target state="translated">如果打开失败,错误字符串将是不言自明的,如</target>
        </trans-unit>
        <trans-unit id="54fcc24f407eeb4900b5f210d5d49a96c53bb1c9" translate="yes" xml:space="preserve">
          <source>If the prefix of the status does not match the digits in expectCode, ReadCodeLine returns with err set to &amp;amp;Error{code, message}. For example, if expectCode is 31, an error will be returned if the status is not in the range [310,319].</source>
          <target state="translated">如果状态的前缀与ExpectCode中的数字不匹配，则ReadCodeLine返回，并且err设置为＆Error {code，message}。例如，如果ExpectCode为31，则如果状态不在[310,319]范围内，则将返回错误。</target>
        </trans-unit>
        <trans-unit id="86837437a16860a8105279be00bffc491da5bba2" translate="yes" xml:space="preserve">
          <source>If the prefix of the status does not match the digits in expectCode, ReadResponse returns with err set to &amp;amp;Error{code, message}. For example, if expectCode is 31, an error will be returned if the status is not in the range [310,319].</source>
          <target state="translated">如果状态的前缀与ExpectCode中的数字不匹配，则ReadResponse返回，并且err设置为＆Error {code，message}。例如，如果ExpectCode为31，则如果状态不在[310,319]范围内，则将返回错误。</target>
        </trans-unit>
        <trans-unit id="5ebf5ba32952d52f53e121ccb89f42cb9010f630" translate="yes" xml:space="preserve">
          <source>If the program has called Notify to receive SIGPIPE signals, the file descriptor number does not matter. The SIGPIPE signal will be delivered to the Notify channel, and the write will fail with an EPIPE error.</source>
          <target state="translated">如果程序已经调用Notify来接收SIGPIPE信号,那么文件描述符号并不重要。SIGPIPE信号将被传送到Notify通道,写入将以EPIPE错误失败。</target>
        </trans-unit>
        <trans-unit id="7cf239f9c12fb938b9596c568e4f45900dce20bb" translate="yes" xml:space="preserve">
          <source>If the program has not called Notify to receive SIGPIPE signals, then the behavior depends on the file descriptor number. A write to a broken pipe on file descriptors 1 or 2 (standard output or standard error) will cause the program to exit with a SIGPIPE signal. A write to a broken pipe on some other file descriptor will take no action on the SIGPIPE signal, and the write will fail with an EPIPE error.</source>
          <target state="translated">如果程序没有调用Notify来接收SIGPIPE信号,那么行为取决于文件描述符的编号。向文件描述符1或2(标准输出或标准错误)上的断管写入将导致程序以SIGPIPE信号退出。对其他文件描述符上的断裂管道的写入将不会对SIGPIPE信号采取任何行动,写入将以EPIPE错误而失败。</target>
        </trans-unit>
        <trans-unit id="111ef080bfe5d9de228261353c72d73b391743f0" translate="yes" xml:space="preserve">
          <source>If the program is started with a non-empty signal mask, some signals will be explicitly unblocked as described above. If Notify is called for a blocked signal, it will be unblocked. If, later, Reset is called for that signal, or Stop is called on all channels passed to Notify for that signal, the signal will once again be blocked.</source>
          <target state="translated">如果程序以一个非空的信号掩码启动,一些信号将如上所述被显式解封。如果对一个被屏蔽的信号调用Notify,它就会被解除屏蔽。如果之后对该信号调用Reset,或者对该信号传递给Notify的所有通道调用Stop,该信号将再次被屏蔽。</target>
        </trans-unit>
        <trans-unit id="6b4f665c5cfb9144d49b7e1dcb5bc2df2bfa007a" translate="yes" xml:space="preserve">
          <source>If the program was started with SIGHUP or SIGINT ignored, and Notify is called for either signal, a signal handler will be installed for that signal and it will no longer be ignored. If, later, Reset or Ignore is called for that signal, or Stop is called on all channels passed to Notify for that signal, the signal will once again be ignored. Reset will restore the system default behavior for the signal, while Ignore will cause the system to ignore the signal entirely.</source>
          <target state="translated">如果程序在启动时忽略了SIGHUP或SIGINT,并且对任何一个信号调用了Notify,那么将为该信号安装一个信号处理程序,它将不再被忽略。如果之后对该信号调用Reset或Ignore,或者对该信号传递给Notify的所有通道调用Stop,该信号将再次被忽略。Reset将恢复系统对该信号的默认行为,而Ignore将使系统完全忽略该信号。</target>
        </trans-unit>
        <trans-unit id="a50b71ad5f04ba376647400ad12d829202f07d7f" translate="yes" xml:space="preserve">
          <source>If the provided body is also an io.Closer, the returned Request.Body is set to body and will be closed by the Client methods Do, Post, and PostForm, and Transport.RoundTrip.</source>
          <target state="translated">如果提供的body也是一个io.Closer,那么返回的Request.Body将被设置为body,并将被Client方法Do、Post和PostForm,以及Transport.RoundTrip关闭。</target>
        </trans-unit>
        <trans-unit id="a90f0974cd32b46dcc6c15c91f94c9f93252ae8b" translate="yes" xml:space="preserve">
          <source>If the provided body is an io.Closer, it is closed after the request.</source>
          <target state="translated">如果提供的主体是io.Closer,则在请求后关闭。</target>
        </trans-unit>
        <trans-unit id="76a4a3b11148dd18ae8c95298059edf28df076dc" translate="yes" xml:space="preserve">
          <source>If the provided file or directory name is a relative path, it is interpreted relative to the current directory and may ascend to parent directories. If the provided name is constructed from user input, it should be sanitized before calling ServeFile.</source>
          <target state="translated">如果提供的文件或目录名是一个相对路径,那么它将被解释为相对于当前目录,并可能上升到父目录。如果所提供的文件名是由用户输入的,那么在调用ServeFile之前应该对其进行处理。</target>
        </trans-unit>
        <trans-unit id="4e3cf22a6ffbc844d8cc7293fe5c88e56a31e62d" translate="yes" xml:space="preserve">
          <source>If the provided result precision is 0 (see below), it is set to the precision of the argument with the largest precision value before any rounding takes place, and the rounding mode remains unchanged. Thus, uninitialized Floats provided as result arguments will have their precision set to a reasonable value determined by the operands, and their mode is the zero value for RoundingMode (ToNearestEven).</source>
          <target state="translated">如果提供的结果精度为0(见下文),则在进行任何四舍五入之前,它被设置为具有最大精度值的参数的精度,并且四舍五入模式保持不变。因此,作为结果参数提供的未初始化的Floats将被设置为由操作数决定的合理值,其模式为RoundingMode(ToNearestEven)的零值。</target>
        </trans-unit>
        <trans-unit id="2b88a75837ac44c3ec57492aadd63fbc336940cb" translate="yes" xml:space="preserve">
          <source>If the request Body's size has not already been limited by MaxBytesReader, the size is capped at 10MB.</source>
          <target state="translated">如果请求Body的大小还没有被MaxBytesReader限制,则大小上限为10MB。</target>
        </trans-unit>
        <trans-unit id="202ca334b5c1306191933ea4f4be7458350d5dde" translate="yes" xml:space="preserve">
          <source>If the response is multi-line, ReadCodeLine returns an error.</source>
          <target state="translated">如果响应是多行,ReadCodeLine返回一个错误。</target>
        </trans-unit>
        <trans-unit id="cca7e3754527e1fa0174f20268f5f2115cb686b6" translate="yes" xml:space="preserve">
          <source>If the response's Content-Type header is not set, ServeContent first tries to deduce the type from name's file extension and, if that fails, falls back to reading the first block of the content and passing it to DetectContentType. The name is otherwise unused; in particular it can be empty and is never sent in the response.</source>
          <target state="translated">如果响应的Content-Type头没有设置,ServeContent首先尝试从name的文件扩展名中推断出类型,如果失败了,则回到读取内容的第一个块,并将其传递给DetectContentType。名字在其他情况下是不用的,特别是它可以是空的,并且永远不会在响应中发送。</target>
        </trans-unit>
        <trans-unit id="4adb610dc4446d1c29fb56aaef6e5c8a55dbd30c" translate="yes" xml:space="preserve">
          <source>If the result is enclosed in square brackets, as literal IPv6 addresses are, the square brackets are removed from the result.</source>
          <target state="translated">如果结果包含在方括号中,就像IPv6地址一样,方括号会从结果中删除。</target>
        </trans-unit>
        <trans-unit id="46d8ee162d5e124f43ba34e4b526da01d3ba6f66" translate="yes" xml:space="preserve">
          <source>If the result of this process is an empty string, Clean returns the string &quot;.&quot;.</source>
          <target state="translated">如果这个过程的结果是一个空字符串,Clean会返回字符串&quot;.&quot;。</target>
        </trans-unit>
        <trans-unit id="63039cb93ec1523520a70aa02f8add44a72d2dcc" translate="yes" xml:space="preserve">
          <source>If the resulting type would be larger than the available address space, ArrayOf panics.</source>
          <target state="translated">如果产生的类型将大于可用的地址空间,ArrayOf就会惊慌失措。</target>
        </trans-unit>
        <trans-unit id="49eb9c6b19926a8575c169e52f8df687a6338f21" translate="yes" xml:space="preserve">
          <source>If the returned error is nil, the Response will contain a non-nil Body which the user is expected to close. If the Body is not both read to EOF and closed, the Client's underlying RoundTripper (typically Transport) may not be able to re-use a persistent TCP connection to the server for a subsequent &quot;keep-alive&quot; request.</source>
          <target state="translated">如果返回的错误是nil,Response将包含一个非nil的Body,用户应该关闭它。如果Body既没有读到EOF,也没有关闭,那么Client的底层RoundTripper(通常是Transport)可能无法在后续的 &quot;keep-alive &quot;请求中重新使用到服务器的持久性TCP连接。</target>
        </trans-unit>
        <trans-unit id="2bd3e276f21c33ca258e2835ea6ef2502ea92047" translate="yes" xml:space="preserve">
          <source>If the returned token is a keyword, the literal string is the keyword.</source>
          <target state="translated">如果返回的标记是关键字,字面字符串就是关键字。</target>
        </trans-unit>
        <trans-unit id="d7865630a2cf1e24a8ed7ed472ba9beeb25fa193" translate="yes" xml:space="preserve">
          <source>If the returned token is a literal (token.IDENT, token.INT, token.FLOAT, token.IMAG, token.CHAR, token.STRING) or token.COMMENT, the literal string has the corresponding value.</source>
          <target state="translated">如果返回的token是文字(token.IDENT、token.INT、token.FLOAT、token.IMAG、token.CHAR、token.STRING)或token.COMMENT,文字字符串有对应的值。</target>
        </trans-unit>
        <trans-unit id="7b330824cf4af38e2c2f1237e0044975056d896f" translate="yes" xml:space="preserve">
          <source>If the returned token is token.ILLEGAL, the literal string is the offending character.</source>
          <target state="translated">如果返回的标记是token.ILLEGAL,字面字符串就是违规字符。</target>
        </trans-unit>
        <trans-unit id="f2065d9b79fae019bc66ef4f832603a41d2a079f" translate="yes" xml:space="preserve">
          <source>If the returned token is token.SEMICOLON, the corresponding literal string is &quot;;&quot; if the semicolon was present in the source, and &quot;\n&quot; if the semicolon was inserted because of a newline or at EOF.</source>
          <target state="translated">如果返回的标记是token.SEMICOLON,对应的文字串是&quot;;&quot;,如果分号在源码中存在,则是&quot;;&quot;,如果分号因为换行或在EOF处插入,则是&quot;/n&quot;。</target>
        </trans-unit>
        <trans-unit id="6d82694c27c567dcf0d737897e646720cd59f4a9" translate="yes" xml:space="preserve">
          <source>If the server replies with a redirect, the Client first uses the CheckRedirect function to determine whether the redirect should be followed. If permitted, a 301, 302, or 303 redirect causes subsequent requests to use HTTP method GET (or HEAD if the original request was HEAD), with no body. A 307 or 308 redirect preserves the original HTTP method and body, provided that the Request.GetBody function is defined. The NewRequest function automatically sets GetBody for common standard library body types.</source>
          <target state="translated">如果服务器回复了重定向,客户端首先使用CheckRedirect函数来确定是否应该遵循重定向。如果允许,301、302或303重定向会导致后续请求使用HTTP方法GET(或者HEAD,如果原始请求是HEAD),没有body。如果定义了Request.GetBody函数,307或308重定向会保留原来的HTTP方法和body。NewRequest函数会自动设置常用标准库体类型的GetBody。</target>
        </trans-unit>
        <trans-unit id="8bef3b53d6d7bb99946b130aacd06c58001e65ba" translate="yes" xml:space="preserve">
          <source>If the source couldn't be read, the returned AST is nil and the error indicates the specific failure. If the source was read but syntax errors were found, the result is a partial AST (with ast.Bad* nodes representing the fragments of erroneous source code). Multiple errors are returned via a scanner.ErrorList which is sorted by file position.</source>
          <target state="translated">如果源码无法被读取,返回的AST为nil,错误表示具体的失败。如果源码被读取,但发现语法错误,结果是一个部分AST(用 ast.Bad*节点代表错误的源码片段)。多个错误会通过一个 scanner.ErrorList 返回,该错误是按文件位置排序的。</target>
        </trans-unit>
        <trans-unit id="f66a139f57b43b60f302e27759bd0543bc9c0e26" translate="yes" xml:space="preserve">
          <source>If the time has a monotonic clock reading, the returned string includes a final field &quot;m=&amp;plusmn;&amp;lt;value&amp;gt;&quot;, where value is the monotonic clock reading formatted as a decimal number of seconds.</source>
          <target state="translated">如果时间具有单调时钟读数，则返回的字符串包括最后一个字段&amp;ldquo; m =&amp;plusmn;&amp;lt;value&amp;gt;&amp;rdquo;，其中value是格式为十进制秒数的单调时钟读数。</target>
        </trans-unit>
        <trans-unit id="251f36d24e83127f4dd9319d7cdbc49677b94325" translate="yes" xml:space="preserve">
          <source>If the traceback function is called from a signal handler on a Unix system, SigContext will be the signal context argument passed to the signal handler (a C ucontext_t* cast to uintptr_t). This may be used to start tracing at the point where the signal occurred. If the traceback function is not called from a signal handler, SigContext will be zero.</source>
          <target state="translated">如果跟踪函数是由Unix系统的信号处理程序调用的,那么SigContext将是传递给信号处理程序的信号上下文参数(一个C语言的ucontext_t*投向uintptr_t)。这可以用来在信号发生的地方开始追踪。如果跟踪函数不是从信号处理程序中调用的,那么SigContext将为零。</target>
        </trans-unit>
        <trans-unit id="07b1d78b08994662a459431d46bce8768415b25a" translate="yes" xml:space="preserve">
          <source>If the type name of a slice element ends with &quot;SET&quot; then it's treated as if the &quot;set&quot; tag was set on it. This can be used with nested slices where a struct tag cannot be given.</source>
          <target state="translated">如果一个分片元素的类型名以 &quot;SET &quot;结尾,那么它将被视为 &quot;set &quot;标签被设置在它上面。这可以用于不能给出结构标签的嵌套分片。</target>
        </trans-unit>
        <trans-unit id="b1b298da75673ff2dc00ea6d79d2dbf4f6d4ad81" translate="yes" xml:space="preserve">
          <source>If the type of the first field of a structure is RawContent then the raw ASN1 contents of the struct will be stored in it.</source>
          <target state="translated">如果一个结构的第一个字段的类型是RawContent,那么该结构的原始ASN1内容将被存储在其中。</target>
        </trans-unit>
        <trans-unit id="94580cf18c0cdda91d151e0855e03334c0926847" translate="yes" xml:space="preserve">
          <source>If there are nested type ids, the types for all inner type ids must be defined before the top-level type id is used to describe an encoded-v.</source>
          <target state="translated">如果有嵌套的类型id,那么所有内层类型id的类型必须在顶层类型id用于描述一个编码的v之前被定义。</target>
        </trans-unit>
        <trans-unit id="a4b08581fb59710f6d84824026b409a7e3fe2aea" translate="yes" xml:space="preserve">
          <source>If there is an error, it will be of type *PathError.</source>
          <target state="translated">如果有一个错误,它的类型将是*PathError。</target>
        </trans-unit>
        <trans-unit id="d59b10d118f91edc83c197a1ea597908270dd51e" translate="yes" xml:space="preserve">
          <source>If there is no registered handler that applies to the request, Handler returns a &amp;ldquo;page not found&amp;rdquo; handler and an empty pattern.</source>
          <target state="translated">If there is no registered handler that applies to the request, Handler returns a &amp;ldquo;page not found&amp;rdquo; handler and an empty pattern.</target>
        </trans-unit>
        <trans-unit id="1a7ace82b8245bf4439307ba5dfdbd1b825dcfff" translate="yes" xml:space="preserve">
          <source>If there was a problem walking to the file or directory named by path, the incoming error will describe the problem and the function can decide how to handle that error (and Walk will not descend into that directory). In the case of an error, the info argument will be nil. If an error is returned, processing stops. The sole exception is when the function returns the special value SkipDir. If the function returns SkipDir when invoked on a directory, Walk skips the directory's contents entirely. If the function returns SkipDir when invoked on a non-directory file, Walk skips the remaining files in the containing directory.</source>
          <target state="translated">如果走到以路径命名的文件或目录时出现了问题,传入的错误将描述该问题,函数可以决定如何处理该错误(Walk不会下降到该目录)。在出现错误的情况下,info参数将为nil。如果返回错误,则停止处理。唯一的例外是当函数返回特殊值SkipDir时,如果函数在一个目录上调用时返回SkipDir,Walk将完全跳过该目录的内容。如果函数在非目录文件上调用时返回SkipDir,Walk将跳过包含目录中的其余文件。</target>
        </trans-unit>
        <trans-unit id="9f28f83ac01122a6b8eb17da82fc365cf06db186" translate="yes" xml:space="preserve">
          <source>If this compilation unit has no line table, it returns nil, nil.</source>
          <target state="translated">如果这个编译单元没有行表,则返回nil,nil。</target>
        </trans-unit>
        <trans-unit id="36cfd61621ceef678850032683735978215f2feb" translate="yes" xml:space="preserve">
          <source>If u.Host doesn't contain a valid numeric port, Port returns an empty string.</source>
          <target state="translated">如果u.Host不包含一个有效的数字端口,Port返回一个空字符串。</target>
        </trans-unit>
        <trans-unit id="1f16e20c1b2a3c0d7a413b8fa21221a527ff3a01" translate="yes" xml:space="preserve">
          <source>If u.Opaque is non-empty, String uses the first form; otherwise it uses the second form. Any non-ASCII characters in host are escaped. To obtain the path, String uses u.EscapedPath().</source>
          <target state="translated">如果u.Opaque是非空的,String使用第一种形式,否则使用第二种形式。host中的任何非ASCII字符都会被转义。为了获得路径,String使用u.EscapedPath()。</target>
        </trans-unit>
        <trans-unit id="8013c9355c400aa79a6367baa057f4b9d4888841" translate="yes" xml:space="preserve">
          <source>If used in an unsafe context, then the value might be filtered out:</source>
          <target state="translated">如果在不安全的情况下使用,那么该值可能会被过滤掉。</target>
        </trans-unit>
        <trans-unit id="169176f5802d140421e02d07f71892f55914e587" translate="yes" xml:space="preserve">
          <source>If v's Kind is Func, the returned pointer is an underlying code pointer, but not necessarily enough to identify a single function uniquely. The only guarantee is that the result is zero if and only if v is a nil func Value.</source>
          <target state="translated">如果v的Kind是Func,返回的指针是一个底层代码指针,但不一定足以唯一地识别一个函数。唯一的保证是,如果且仅当v是一个nil func Value时,结果为零。</target>
        </trans-unit>
        <trans-unit id="ee9b69667b384fa6c8c1419304597f7a05f5dda4" translate="yes" xml:space="preserve">
          <source>If v's Kind is Slice, the returned pointer is to the first element of the slice. If the slice is nil the returned value is 0. If the slice is empty but non-nil the return value is non-zero.</source>
          <target state="translated">如果v的Kind是Slice,返回的指针是Slice的第一个元素,如果Slice为nil,返回值为0。如果分片为零,返回值为0,如果分片为空但非零,返回值为非零。</target>
        </trans-unit>
        <trans-unit id="ccce50575e90f1da7bb594b206672d76cc0b7fdc" translate="yes" xml:space="preserve">
          <source>If x is prime, ProbablyPrime returns true. If x is chosen randomly and not prime, ProbablyPrime probably returns false. The probability of returning true for a randomly chosen non-prime is at most &amp;frac14;ⁿ.</source>
          <target state="translated">如果x为质数，则ProbablyPrime返回true。如果x是随机选择而不是素数，则ProbablyPrime可能返回false。对于随机选择的非素数返回true的概率最多为1 /4ⁿ。</target>
        </trans-unit>
        <trans-unit id="bf8bf41d1552e2a2314c86bbee51c546608c7502" translate="yes" xml:space="preserve">
          <source>If you like, you can bind the flag to a variable using the Var() functions.</source>
          <target state="translated">如果你愿意,你可以使用Var()函数将标志绑定到一个变量上。</target>
        </trans-unit>
        <trans-unit id="8a6f437f93f8b5dbc142b89b4316e10878736145" translate="yes" xml:space="preserve">
          <source>If your application is not already running an http server, you need to start one. Add &quot;net/http&quot; and &quot;log&quot; to your imports and the following code to your main function:</source>
          <target state="translated">如果你的应用程序还没有运行http服务器,你需要启动一个。将 &quot;net/http &quot;和 &quot;log &quot;添加到你的导入中,并在你的主函数中添加以下代码。</target>
        </trans-unit>
        <trans-unit id="e7a7bb87f973e19b80ef2f0c235948e2ab80ca50" translate="yes" xml:space="preserve">
          <source>If z's precision is 0, it is changed to x's precision before the operation. Rounding is performed according to z's precision and rounding mode.</source>
          <target state="translated">如果z的精度为0,则在操作前将其改为x的精度。根据z的精度和四舍五入模式进行四舍五入。</target>
        </trans-unit>
        <trans-unit id="bf3bdba69c06f396d015a2e68cfa8b8e0dc2a553" translate="yes" xml:space="preserve">
          <source>If {{.}} is the innocuous word, `left`, then it can appear more widely,</source>
          <target state="translated">如果{{.}}是无害的词,&quot;左&quot;,那么它可以出现的范围更广。</target>
        </trans-unit>
        <trans-unit id="35dc1b1b93ecc62032ac0000d9cf5065af4bc463" translate="yes" xml:space="preserve">
          <source>IfNode represents an {{if}} action and its commands.</source>
          <target state="translated">IfNode表示一个{{if}}动作及其命令。</target>
        </trans-unit>
        <trans-unit id="a40a74611ce76ddfa9aec134c7c4d57d7e7d1a0b" translate="yes" xml:space="preserve">
          <source>Ignore causes the provided signals to be ignored. If they are received by the program, nothing will happen. Ignore undoes the effect of any prior calls to Notify for the provided signals. If no signals are provided, all incoming signals will be ignored.</source>
          <target state="translated">忽略导致所提供的信号被忽略。如果它们被程序接收,则不会发生任何事情。忽略会撤销之前对所提供信号的任何通知调用的效果。如果没有提供信号,所有传入的信号将被忽略。</target>
        </trans-unit>
        <trans-unit id="98d36857a614a1e009d79e216b4eb0d9115f0404" translate="yes" xml:space="preserve">
          <source>Ignored reports whether sig is currently ignored.</source>
          <target state="translated">Ignored报告sig当前是否被忽略。</target>
        </trans-unit>
        <trans-unit id="4d88a112acad4eaba636cd685d95e848e229a4fb" translate="yes" xml:space="preserve">
          <source>Ilogb returns the binary exponent of x as an integer.</source>
          <target state="translated">Ilogb以整数形式返回x的二进制指数。</target>
        </trans-unit>
        <trans-unit id="44e069a8f4a7e1ac23418ede1f9fbec843a967dd" translate="yes" xml:space="preserve">
          <source>Imag returns the imaginary part of x, which must be a numeric or unknown value. If x is Unknown, the result is Unknown.</source>
          <target state="translated">Imag 返回 x 的虚部,它必须是一个数值或未知值。如果x是未知值,结果是未知值。</target>
        </trans-unit>
        <trans-unit id="30d40b43edb0bdc3eabf2d534c36f9d06f964b6e" translate="yes" xml:space="preserve">
          <source>Image is a finite rectangular grid of color.Color values taken from a color model.</source>
          <target state="translated">图像是一个有限的矩形颜色网格.颜色值取自一个颜色模型。</target>
        </trans-unit>
        <trans-unit id="26d71317c3ede5b3f54e923608b8db6326957a5e" translate="yes" xml:space="preserve">
          <source>Image is an image.Image with a Set method to change a single pixel.</source>
          <target state="translated">Image是一个Image.Image,有一个Set方法来改变单个像素。</target>
        </trans-unit>
        <trans-unit id="b146748a0514484acff9fb056c40176e7e0d62af" translate="yes" xml:space="preserve">
          <source>Implementation restriction: The counting forms x{n,m}, x{n,}, and x{n} reject forms that create a minimum or maximum repetition count above 1000. Unlimited repetitions are not subject to this restriction.</source>
          <target state="translated">实施限制。计数表格x{n,m}、x{n,}和x{n}拒绝接受最小或最大重复数超过1000的表格。无限重复的形式不受此限制。</target>
        </trans-unit>
        <trans-unit id="75c9903908feb1732654db7dd3662c68681cf3c0" translate="yes" xml:space="preserve">
          <source>Implementations must not retain p.</source>
          <target state="translated">执行中不得保留p。</target>
        </trans-unit>
        <trans-unit id="baccfe949bd483e0aa453da0b286a6848971e885" translate="yes" xml:space="preserve">
          <source>Implementations of CookieJar must be safe for concurrent use by multiple goroutines.</source>
          <target state="translated">CookieJar的实现必须保证多个goroutine并发使用的安全。</target>
        </trans-unit>
        <trans-unit id="2496dd56381c55b51499d5f91502dcff20d2b771" translate="yes" xml:space="preserve">
          <source>Implementations of PublicSuffixList must be safe for concurrent use by multiple goroutines.</source>
          <target state="translated">PublicSuffixList的实现必须是安全的,可以被多个goroutine并发使用。</target>
        </trans-unit>
        <trans-unit id="f73bf070b6238c284ef7b4d02061d370d3bb9d34" translate="yes" xml:space="preserve">
          <source>Implementations of Read are discouraged from returning a zero byte count with a nil error, except when len(p) == 0. Callers should treat a return of 0 and nil as indicating that nothing happened; in particular it does not indicate EOF.</source>
          <target state="translated">不鼓励Read的实现以nil错误返回一个零字节数,除非len(p)==0.调用者应该将0和nil的返回视为表示什么都没有发生;特别是它不表示EOF。</target>
        </trans-unit>
        <trans-unit id="9c4eb58019f122cd6fcd79f868e42855509e5b17" translate="yes" xml:space="preserve">
          <source>Implementations of Token are discouraged from returning a nil token with a nil error. Callers should treat a return of nil, nil as indicating that nothing happened; in particular it does not indicate EOF.</source>
          <target state="translated">不鼓励Token的实现以nil错误返回一个nil token。调用者应该把返回nil、nil视为表示什么都没有发生;特别是它不表示EOF。</target>
        </trans-unit>
        <trans-unit id="3b31ef7323ed3ca421b9bab6f7dbaab32c7ce726" translate="yes" xml:space="preserve">
          <source>Implements reports whether type V implements interface T.</source>
          <target state="translated">Implements报告类型V是否实现了接口T。</target>
        </trans-unit>
        <trans-unit id="5ba5f70840c67e6a055ce04e03bb2454bb162d9f" translate="yes" xml:space="preserve">
          <source>Import is shorthand for Default.Import.</source>
          <target state="translated">Import是Default.Import的简写。</target>
        </trans-unit>
        <trans-unit id="6afc9b3e57abb6585be9561d376bdea28ca944ae" translate="yes" xml:space="preserve">
          <source>Import returns details about the Go package named by the import path, interpreting local import paths relative to the srcDir directory. If the path is a local import path naming a package that can be imported using a standard import path, the returned package will set p.ImportPath to that path.</source>
          <target state="translated">Import 返回由导入路径命名的 Go 包的详细信息,解释相对于 srcDir 目录的本地导入路径。如果路径是一个本地导入路径,命名了一个可以使用标准导入路径导入的包,那么返回的包将把p.ImportPath设置为该路径。</target>
        </trans-unit>
        <trans-unit id="93d88a517c9d75699c2e4045b6e3fc932cd88482" translate="yes" xml:space="preserve">
          <source>ImportDir is like Import but processes the Go package found in the named directory.</source>
          <target state="translated">ImportDir和Import一样,但处理的是在命名目录中找到的Go包。</target>
        </trans-unit>
        <trans-unit id="58d6f3af90d9fbc41be2c405bfa8615d93151250" translate="yes" xml:space="preserve">
          <source>ImportDir is shorthand for Default.ImportDir.</source>
          <target state="translated">ImportDir是Default.ImportDir的简写。</target>
        </trans-unit>
        <trans-unit id="2d321830ed77e3baaf4ac8b7f7efc36408c85002" translate="yes" xml:space="preserve">
          <source>ImportMode is reserved for future use.</source>
          <target state="translated">ImportMode是保留给将来使用的。</target>
        </trans-unit>
        <trans-unit id="81d5bfd42309b64b183f9701f930099193a14426" translate="yes" xml:space="preserve">
          <source>Imported returns the package that was imported. It is distinct from Pkg(), which is the package containing the import statement.</source>
          <target state="translated">Imported 返回被导入的包。它与Pkg()不同,Pkg()是包含导入语句的包。</target>
        </trans-unit>
        <trans-unit id="98f8e071166bb5be3aecf52c0312f3d8e38c742a" translate="yes" xml:space="preserve">
          <source>ImportedLibraries returns the names of all libraries referred to by the binary f that are expected to be linked with the binary at dynamic link time.</source>
          <target state="translated">ImportedLibraries返回二进制f所引用的所有库的名称,这些库预计将在动态链接时与二进制链接。</target>
        </trans-unit>
        <trans-unit id="6d0d053d5be94190ae4125e53a45e74c9bfff903" translate="yes" xml:space="preserve">
          <source>ImportedLibraries returns the paths of all libraries referred to by the binary f that are expected to be linked with the binary at dynamic link time.</source>
          <target state="translated">ImportedLibraries返回二进制f所引用的所有库的路径,这些库预计将在动态链接时与二进制链接。</target>
        </trans-unit>
        <trans-unit id="27f49356d80e117cb6ff37f13e3b8dc616e332cb" translate="yes" xml:space="preserve">
          <source>ImportedSymbols returns the names of all symbols referred to by the binary f that are expected to be satisfied by other libraries at dynamic load time.</source>
          <target state="translated">ImportedSymbols返回二进制f所引用的所有符号的名称,这些符号预计在动态加载时将被其他库满足。</target>
        </trans-unit>
        <trans-unit id="80301d15602072b275cf4e9d642684ee556fd2a0" translate="yes" xml:space="preserve">
          <source>ImportedSymbols returns the names of all symbols referred to by the binary f that are expected to be satisfied by other libraries at dynamic load time. It does not return weak symbols.</source>
          <target state="translated">ImportedSymbols返回二进制f所引用的所有符号的名称,这些符号预计在动态加载时将被其他库满足。它不返回弱符号。</target>
        </trans-unit>
        <trans-unit id="75eb201c4952cde504ceda9eb34765cbfc018641" translate="yes" xml:space="preserve">
          <source>Imports returns the list of packages directly imported by pkg; the list is in source order.</source>
          <target state="translated">Imports 返回由 pkg 直接导入的软件包列表;该列表按源码顺序排列。</target>
        </trans-unit>
        <trans-unit id="cb7bc76d7380682c92ffb45e3be0edf510619c0c" translate="yes" xml:space="preserve">
          <source>In C syntax, this struct will be</source>
          <target state="translated">在C语言中,这个结构将是</target>
        </trans-unit>
        <trans-unit id="031e67b82062bc206ba16bfbb78969301350778f" translate="yes" xml:space="preserve">
          <source>In Go 1 and Go 1.1, each package produced one Obj for all Go sources and one Obj per C source file.</source>
          <target state="translated">在围棋1和围棋1.1中,每个包为所有围棋源产生一个Obj,每个C源文件产生一个Obj。</target>
        </trans-unit>
        <trans-unit id="f1a4145c4d681021c6b688a748d3fd850af7e56f" translate="yes" xml:space="preserve">
          <source>In Go 1.1 and earlier, each function (represented by a Func) had its own LineTable, and the line number corresponded to a numbering of all source lines in the program, across all files. That absolute line number would then have to be converted separately to a file name and line number within the file.</source>
          <target state="translated">在Go 1.1和更早的版本中,每个函数(用Func表示)都有自己的LineTable,行号对应的是程序中所有文件的所有源行的编号。那绝对的行号就必须分别转换为文件名和文件内的行号。</target>
        </trans-unit>
        <trans-unit id="35c4a15e4a2e0d9709fe9d9d2d8891336f5119ee" translate="yes" xml:space="preserve">
          <source>In Go 1.12 and earlier, it was possible to distribute packages in binary form without including the source code used for compiling the package. The package was distributed with a source file not excluded by build constraints and containing a &quot;//go:binary-only-package&quot; comment. Like a build constraint, this comment appeared at the top of a file, preceded only by blank lines and other line comments and with a blank line following the comment, to separate it from the package documentation. Unlike build constraints, this comment is only recognized in non-test Go source files.</source>
          <target state="translated">在Go 1.12和更早的版本中,可以发布二进制形式的包,而不包括用于编译包的源代码。软件包在发布的时候,有一个不被构建约束排除在外的源文件,并包含一个&quot;//go:binary-only-package &quot;的注释。和构建约束一样,这个注释出现在文件的顶部,前面只有空行和其他行注释,并且在注释后面有一行空行,以将其与软件包文档分开。与构建约束不同,这种注释只在非测试的围棋源文件中被识别。</target>
        </trans-unit>
        <trans-unit id="cc8775c16cc6c9f67e9f67d2c4b9b38bd2343802" translate="yes" xml:space="preserve">
          <source>In Go 1.2, the format of the data changed so that there is a single LineTable for the entire program, shared by all Funcs, and there are no absolute line numbers, just line numbers within specific files.</source>
          <target state="translated">在围棋1.2中,数据的格式发生了变化,整个程序只有一个LineTable,由所有Funcs共享,而且没有绝对的行号,只有特定文件内的行号。</target>
        </trans-unit>
        <trans-unit id="94c3f9b8a2f1195c43f29bc6d1587c741d49bcbe" translate="yes" xml:space="preserve">
          <source>In Go 1.2, there is a single Obj for the entire program.</source>
          <target state="translated">在Go 1.2中,整个程序只有一个Obj。</target>
        </trans-unit>
        <trans-unit id="fc1a1510c05c5e605f2bf42bab100aff6fd4f01e" translate="yes" xml:space="preserve">
          <source>In Printf, Sprintf, and Fprintf, the default behavior is for each formatting verb to format successive arguments passed in the call. However, the notation [n] immediately before the verb indicates that the nth one-indexed argument is to be formatted instead. The same notation before a '*' for a width or precision selects the argument index holding the value. After processing a bracketed expression [n], subsequent verbs will use arguments n+1, n+2, etc. unless otherwise directed.</source>
          <target state="translated">在Printf、Sprintf和Fprintf中,默认的行为是每个格式化动词对调用中传递的连续参数进行格式化。然而,紧靠在动词前的符号[n]表示第n个单索引参数将被格式化。在宽度或精度的'*'前也有同样的记号,表示选择持有该值的参数索引。在处理完括号内的表达式[n]后,除非另有指示,否则后续的动词将使用参数n+1、n+2等。</target>
        </trans-unit>
        <trans-unit id="6f69301b556dc9f571bc4bb3612422a63af49e86" translate="yes" xml:space="preserve">
          <source>In TLS 1.3, this type is called NamedGroup, but at this time this library only supports Elliptic Curve based groups. See RFC 8446, Section 4.2.7.</source>
          <target state="translated">在TLS 1.3中,这个类型被称为NamedGroup,但目前这个库只支持基于椭圆曲线的组。参见RFC 8446,4.2.7节。</target>
        </trans-unit>
        <trans-unit id="93a2aff531fe6a26d094463bdd12d8ce980726db" translate="yes" xml:space="preserve">
          <source>In a Go program that includes non-Go code, typically C/C++ code accessed using cgo or SWIG, Go's startup code normally runs first. It configures the signal handlers as expected by the Go runtime, before the non-Go startup code runs. If the non-Go startup code wishes to install its own signal handlers, it must take certain steps to keep Go working well. This section documents those steps and the overall effect changes to signal handler settings by the non-Go code can have on Go programs. In rare cases, the non-Go code may run before the Go code, in which case the next section also applies.</source>
          <target state="translated">在包含非围棋代码的围棋程序中,通常是使用 cgo 或 SWIG 访问的 C/C++代码,围棋的启动代码通常首先运行。在非 Go 启动代码运行之前,它会按照 Go 运行时的预期配置信号处理程序。如果非 Go 启动代码希望安装自己的信号处理程序,它必须采取一定的步骤来保证 Go 的良好工作。本节记录了这些步骤以及非围棋代码对信号处理程序设置的更改对围棋程序的总体影响。在极少数情况下,非围棋代码可能在围棋代码之前运行,在这种情况下,下一节也适用。</target>
        </trans-unit>
        <trans-unit id="b709a8b5c95be5a899a7612ec04af9fcd8c6fe68" translate="yes" xml:space="preserve">
          <source>In addition to adding the HTTP handler, this package registers the following variables:</source>
          <target state="translated">除了添加HTTP处理程序,这个包还注册了以下变量。</target>
        </trans-unit>
        <trans-unit id="c7232c786e65fae897885a5d1905f0858ffd2ae2" translate="yes" xml:space="preserve">
          <source>In addition to the required &amp;ldquo;wall clock&amp;rdquo; reading, a Time may contain an optional reading of the current process's monotonic clock, to provide additional precision for comparison or subtraction. See the &amp;ldquo;Monotonic Clocks&amp;rdquo; section in the package documentation for details.</source>
          <target state="translated">除了所需的&amp;ldquo;挂钟&amp;rdquo;读数外，&amp;ldquo;时间&amp;rdquo;还可以包含当前过程的单调时钟的可选读数，以提供更高的比较或减法精度。有关详细信息，请参见包装文档中的&amp;ldquo;单声道时钟&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="965439857efd394443e37d36ace60b7ac7d83473" translate="yes" xml:space="preserve">
          <source>In addition to the struct tags recognised by Unmarshal, the following can be used:</source>
          <target state="translated">除了Unmarshal识别的结构体标签外,还可以使用以下标签。</target>
        </trans-unit>
        <trans-unit id="d07fa607208161c419b4aff2675e4f243b41086c" translate="yes" xml:space="preserve">
          <source>In all other cases, Scan returns an empty literal string.</source>
          <target state="translated">在所有其他情况下,Scan都会返回一个空的字符串。</target>
        </trans-unit>
        <trans-unit id="dc451d8d43456b62826bda28dfbc96cdb2eb2524" translate="yes" xml:space="preserve">
          <source>In all the scanning functions, a carriage return followed immediately by a newline is treated as a plain newline (\r\n means the same as \n).</source>
          <target state="translated">在所有的扫描功能中,回车后紧接着的换行被视为普通的换行(/r/n的意思与/n相同)。</target>
        </trans-unit>
        <trans-unit id="fedccbf24f7f68d8101f599e3218a03c5ffaf765" translate="yes" xml:space="preserve">
          <source>In all the scanning functions, if an operand implements method Scan (that is, it implements the Scanner interface) that method will be used to scan the text for that operand. Also, if the number of arguments scanned is less than the number of arguments provided, an error is returned.</source>
          <target state="translated">在所有的扫描函数中,如果一个操作数实现了方法Scan(也就是实现了Scanner接口),那么该方法将被用来扫描该操作数的文本。另外,如果扫描的参数数小于提供的参数数,则返回错误。</target>
        </trans-unit>
        <trans-unit id="a1bf502195aaabff9af8feae702eb1ba2c806b3d" translate="yes" xml:space="preserve">
          <source>In an ErrorList, an error is represented by an *Error. The position Pos, if valid, points to the beginning of the offending token, and the error condition is described by Msg.</source>
          <target state="translated">在ErrorList中,错误由*Error表示。如果位置Pos有效,则指向违规标记的开头,错误条件由Msg描述。</target>
        </trans-unit>
        <trans-unit id="c43ce5959f73c41a703ce648d64371023d38a1e1" translate="yes" xml:space="preserve">
          <source>In early versions of Go each source file became a different Obj.</source>
          <target state="translated">在Go的早期版本中,每个源文件都变成了一个不同的Obj。</target>
        </trans-unit>
        <trans-unit id="42a68547a9dca9735cb7eba8147953340f09b72e" translate="yes" xml:space="preserve">
          <source>In effect, the method must look schematically like</source>
          <target state="translated">实际上,该方法的原理必须是这样的</target>
        </trans-unit>
        <trans-unit id="b72051420981768a1127b1640516d07dc80b1c1a" translate="yes" xml:space="preserve">
          <source>In general DeepEqual is a recursive relaxation of Go's == operator. However, this idea is impossible to implement without some inconsistency. Specifically, it is possible for a value to be unequal to itself, either because it is of func type (uncomparable in general) or because it is a floating-point NaN value (not equal to itself in floating-point comparison), or because it is an array, struct, or interface containing such a value. On the other hand, pointer values are always equal to themselves, even if they point at or contain such problematic values, because they compare equal using Go's == operator, and that is a sufficient condition to be deeply equal, regardless of content. DeepEqual has been defined so that the same short-cut applies to slices and maps: if x and y are the same slice or the same map, they are deeply equal regardless of content.</source>
          <target state="translated">一般来说,DeepEqual是Go的==运算符的递归放松。然而,这个想法不可能在没有一些不一致的情况下实现。具体来说,一个值有可能与自己不相等,要么是因为它是func类型(一般情况下不可比较),要么是因为它是一个浮点NaN值(在浮点比较中不等于自己),要么是因为它是一个包含这种值的数组、结构或接口。另一方面,指针值总是与自己相等,即使它指向或包含这样的问题值,因为它们使用Go的==运算符进行比较相等,这就是深度相等的充分条件,无论内容如何。DeepEqual的定义使得同样的捷径适用于切片和地图:如果x和y是同一个切片或同一个地图,那么无论内容如何,它们都是深度相等的。</target>
        </trans-unit>
        <trans-unit id="07b960c708d879d40875264c73a08a0683383d6b" translate="yes" xml:space="preserve">
          <source>In general, a given attribute's value may take on one of several possible classes defined by DWARF, each of which leads to a slightly different interpretation of the attribute.</source>
          <target state="translated">一般来说,一个给定属性的值可以采用DWARF定义的几种可能的类别之一,每种类别都会导致对属性的解释略有不同。</target>
        </trans-unit>
        <trans-unit id="2e9ecaaf397056078378f799dda9c4e1072c7928" translate="yes" xml:space="preserve">
          <source>In general, a gzip file can be a concatenation of gzip files, each with its own header. Reads from the Reader return the concatenation of the uncompressed data of each. Only the first header is recorded in the Reader fields.</source>
          <target state="translated">一般情况下,一个gzip文件可以是一个gzip文件的连接,每个文件都有自己的头。从Reader中读取的数据会返回每个文件的未压缩数据的连接。Reader字段中只记录第一个头。</target>
        </trans-unit>
        <trans-unit id="b6ffd0a95c8557850de7ace105d0c02e95a18d70" translate="yes" xml:space="preserve">
          <source>In general, if allocation is required, the decoder will allocate memory. If not, it will update the destination variables with values read from the stream. It does not initialize them first, so if the destination is a compound value such as a map, struct, or slice, the decoded values will be merged elementwise into the existing variables.</source>
          <target state="translated">一般来说,如果需要分配,解码器将分配内存。如果不需要,它将用从流中读取的值更新目标变量。它不会先初始化它们,所以如果目标变量是一个复合值,如map、struct或slice,那么解码后的值将被元素式地合并到现有的变量中。</target>
        </trans-unit>
        <trans-unit id="d1a73603a88217147c68ec9c324a3f4cba1ebddc" translate="yes" xml:space="preserve">
          <source>In general, reflect.SliceHeader and reflect.StringHeader should be used only as *reflect.SliceHeader and *reflect.StringHeader pointing at actual slices or strings, never as plain structs. A program should not declare or allocate variables of these struct types.</source>
          <target state="translated">一般来说,reflect.SliceHeader和reflect.StringHeader只能作为*reflect.SliceHeader和*reflect.StringHeader指向实际的切片或字符串,决不能作为普通结构使用。程序不应该声明或分配这些结构类型的变量。</target>
        </trans-unit>
        <trans-unit id="99dc4b6fd44a858b786d20b64de92f5f16319ca0" translate="yes" xml:space="preserve">
          <source>In general, the GHASH operation performed by this implementation of GCM is not constant-time. An exception is when the underlying Block was created by aes.NewCipher on systems with hardware support for AES. See the crypto/aes package documentation for details.</source>
          <target state="translated">一般来说,GCM的这个实现所执行的GHASH操作不是恒时的。一个例外的情况是,在对AES有硬件支持的系统上,底层Block是由aes.NewCipher创建的。详情请参见 crypto/aes 软件包文档。</target>
        </trans-unit>
        <trans-unit id="63a94d50c6e71995bfdddbf6d3b7ddbbd572fca1" translate="yes" xml:space="preserve">
          <source>In most cases, new(Buffer) (or just declaring a Buffer variable) is sufficient to initialize a Buffer.</source>
          <target state="translated">在大多数情况下,new(Buffer)(或者仅仅声明一个Buffer变量)就足以初始化一个Buffer。</target>
        </trans-unit>
        <trans-unit id="ce6abe6e4a1757599621f3d92af6850089e3e51d" translate="yes" xml:space="preserve">
          <source>In non-HTML settings where the escaping interferes with the readability of the output, SetEscapeHTML(false) disables this behavior.</source>
          <target state="translated">在非HTML设置中,如果转义会影响输出的可读性,SetEscapeHTML(false)会禁止这种行为。</target>
        </trans-unit>
        <trans-unit id="7077ca93ebf4ef49120708550f14d220620ccf80" translate="yes" xml:space="preserve">
          <source>In panics if loc is nil.</source>
          <target state="translated">在慌乱中,如果loc为零。</target>
        </trans-unit>
        <trans-unit id="f52d38c87623b45c8b7767cba23884c87bb2c3a8" translate="yes" xml:space="preserve">
          <source>In particular, it implements LZW as used by the GIF and PDF file formats, which means variable-width codes up to 12 bits and the first two non-literal codes are a clear code and an EOF code.</source>
          <target state="translated">特别是,它实现了GIF和PDF文件格式所使用的LZW,也就是可变宽度码,最高可达12位,前两个非文字码是一个清码和一个EOF码。</target>
        </trans-unit>
        <trans-unit id="4026aa85ef00c786dfe0c796e4b667cd2644b68d" translate="yes" xml:space="preserve">
          <source>In performance critical applications, Reset can be used to discard the current compressor or decompressor state and reinitialize them quickly by taking advantage of previously allocated memory.</source>
          <target state="translated">在对性能要求很高的应用中,Reset可以用来丢弃当前的压缩器或解压缩器状态,并利用之前分配的内存快速重新初始化它们。</target>
        </trans-unit>
        <trans-unit id="6db233d0c99db26b8c12c611c05604abfea98d46" translate="yes" xml:space="preserve">
          <source>In reports whether every point in r is in s.</source>
          <target state="translated">在报告r中的每一点是否在s中。</target>
        </trans-unit>
        <trans-unit id="84fe4eae8d319a1913e35010d51f1271fd7ded56" translate="yes" xml:space="preserve">
          <source>In reports whether p is in r.</source>
          <target state="translated">在报告p是否在r。</target>
        </trans-unit>
        <trans-unit id="0fd55e418f00485b3f2efc5b428b0418b6a94be8" translate="yes" xml:space="preserve">
          <source>In reports whether the rune is a member of one of the ranges.</source>
          <target state="translated">在报告该符文是否是其中一个范围的成员。</target>
        </trans-unit>
        <trans-unit id="472b3dea5785c77ec21b439277ea93730e47a2be" translate="yes" xml:space="preserve">
          <source>In returns a copy of t representing the same time instant, but with the copy's location information set to loc for display purposes.</source>
          <target state="translated">In 返回t的副本,代表相同的时间瞬间,但为了显示的目的,副本的位置信息设置为loc。</target>
        </trans-unit>
        <trans-unit id="711d8c9ceb05e3476e4192e2fd5e66ccc3b3ba1b" translate="yes" xml:space="preserve">
          <source>In slices and arrays, as well as maps, all elements, even zero-valued elements, are transmitted, even if all the elements are zero.</source>
          <target state="translated">在切片和数组以及地图中,所有元素,甚至是零值元素,都会被传输,即使所有元素都是零。</target>
        </trans-unit>
        <trans-unit id="9f17f1b7292d381dce79c4e2b9b83d7f1d5da96e" translate="yes" xml:space="preserve">
          <source>In summary, a gob stream looks like</source>
          <target state="translated">总的来说,一个gob流看起来像</target>
        </trans-unit>
        <trans-unit id="2d78ddedbd337c0bea6888e7055a4838325b74f8" translate="yes" xml:space="preserve">
          <source>In the $name form, name is taken to be as long as possible: $1x is equivalent to ${1x}, not ${1}x, and, $10 is equivalent to ${10}, not ${1}0.</source>
          <target state="translated">在$name形式中,name取的时间越长越好:$1x相当于${1x},而不是${1}x,而且,$10相当于${10},而不是${1}0。</target>
        </trans-unit>
        <trans-unit id="37a0ec0d20103e0c83570c4610c7755ff7ac53c0" translate="yes" xml:space="preserve">
          <source>In the absence of a time zone indicator, Parse returns a time in UTC.</source>
          <target state="translated">在没有时区指示的情况下,Parsse返回的是UTC时间。</target>
        </trans-unit>
        <trans-unit id="b029486adc899e6b2e4bce186582f459ceb89a34" translate="yes" xml:space="preserve">
          <source>In the directory containing the package, .go, .c, .h, and .s files are considered part of the package except for:</source>
          <target state="translated">在包含包的目录中,.go、.c、.h和.s文件被认为是包的一部分,除了。</target>
        </trans-unit>
        <trans-unit id="fa1c6c88c18a52fe6d2731df7b2ac739dc65317f" translate="yes" xml:space="preserve">
          <source>In the format string, a verb introduced by the % character consumes and parses input; these verbs are described in more detail below. A character other than %, space, or newline in the format consumes exactly that input character, which must be present. A newline with zero or more spaces before it in the format string consumes zero or more spaces in the input followed by a single newline or the end of the input. A space following a newline in the format string consumes zero or more spaces in the input. Otherwise, any run of one or more spaces in the format string consumes as many spaces as possible in the input. Unless the run of spaces in the format string appears adjacent to a newline, the run must consume at least one space from the input or find the end of the input.</source>
          <target state="translated">在格式字符串中,由%字符引入的动词会消耗和解析输入;这些动词在下面会有更详细的描述。格式中除%、空格或换行以外的字符正好消耗该输入字符,该字符必须存在。格式字符串中换行前有零个或更多的空格,会消耗输入中零个或更多的空格,然后是单个换行或输入的结束。格式字符串中换行后的空格会消耗输入中零个或更多的空格。否则,格式字符串中任何一个或多个空格的运行都会消耗输入中尽可能多的空格。除非格式字符串中的空格与换行相邻,否则必须从输入中至少消耗一个空格或找到输入的结尾。</target>
        </trans-unit>
        <trans-unit id="ed1a2050a365f5d52ef37144115d11517ff42bc2" translate="yes" xml:space="preserve">
          <source>In the most simple case, if the type of the value from the source column is an integer, bool or string type T and dest is of type *T, Scan simply assigns the value through the pointer.</source>
          <target state="translated">在最简单的情况下,如果来自源列的值的类型是整数、布尔或字符串类型T,而dest的类型是*T,Scan就会简单地通过指针赋值。</target>
        </trans-unit>
        <trans-unit id="5c811352496639bcd7be1278e40839e6992f883a" translate="yes" xml:space="preserve">
          <source>In the second form, the following rules apply:</source>
          <target state="translated">在第二种形式中,适用以下规则:</target>
        </trans-unit>
        <trans-unit id="9ca6beb2058ca8ef81c9dbee1705e13b3578af1f" translate="yes" xml:space="preserve">
          <source>In the template, a variable is denoted by a substring of the form $name or ${name}, where name is a non-empty sequence of letters, digits, and underscores. A purely numeric name like $1 refers to the submatch with the corresponding index; other names refer to capturing parentheses named with the (?P&amp;lt;name&amp;gt;...) syntax. A reference to an out of range or unmatched index or a name that is not present in the regular expression is replaced with an empty slice.</source>
          <target state="translated">在模板中，变量由$ name或$ {name}形式的子字符串表示，其中name是字母，数字和下划线的非空序列。像$ 1这样的纯数字名称表示具有相应索引的子匹配；其他名称是指捕获用（？P &amp;lt;name&amp;gt; ...）语法命名的括号。对超出范围或不匹配的索引的引用或在正则表达式中不存在的名称将替换为空切片。</target>
        </trans-unit>
        <trans-unit id="5a1c160af25c73f96bab58b7ac18692fbbe1ffa1" translate="yes" xml:space="preserve">
          <source>In the terminology of the zlib library, Flush is equivalent to Z_SYNC_FLUSH.</source>
          <target state="translated">在zlib库的术语中,Flush相当于Z_SYNC_FLUSH。</target>
        </trans-unit>
        <trans-unit id="2dd7b02fa4aa241d6b5f4aad090e1521eaf7af73" translate="yes" xml:space="preserve">
          <source>In this usage hdr.Data is really an alternate way to refer to the underlying pointer in the string header, not a uintptr variable itself.</source>
          <target state="translated">在这种用法中,hdr.Data实际上是字符串头中引用底层指针的另一种方式,而不是uintptr变量本身。</target>
        </trans-unit>
        <trans-unit id="b66dfbc84a8b6f209be163efb64c95ba40440449" translate="yes" xml:space="preserve">
          <source>InUseBytes returns the number of bytes in use (AllocBytes - FreeBytes).</source>
          <target state="translated">InUseBytes 返回使用中的字节数(AllocBytes-FreeBytes)。</target>
        </trans-unit>
        <trans-unit id="d6ed56286846a6cf59f0baa7c19dd1836590eeba" translate="yes" xml:space="preserve">
          <source>InUseObjects returns the number of objects in use (AllocObjects - FreeObjects).</source>
          <target state="translated">InUseObjects 返回正在使用的对象数量(AllocObjects-FreeObjects)。</target>
        </trans-unit>
        <trans-unit id="dfe141017385b1d5692d01442e77119d4a1ae1e2" translate="yes" xml:space="preserve">
          <source>Incoming requests to a server should create a Context, and outgoing calls to servers should accept a Context. The chain of function calls between them must propagate the Context, optionally replacing it with a derived Context created using WithCancel, WithDeadline, WithTimeout, or WithValue. When a Context is canceled, all Contexts derived from it are also canceled.</source>
          <target state="translated">对服务器的传入请求应该创建一个上下文,对服务器的传出调用应该接受一个上下文。它们之间的函数调用链必须传播Context,可选择用WithCancel、WithDeadline、WithTimeout或WithValue创建的派生Context替换它。当一个上下文被取消时,所有由它派生的上下文也被取消。</target>
        </trans-unit>
        <trans-unit id="f3527c443ffc9a19a79c9a5af60b69f82dd615d1" translate="yes" xml:space="preserve">
          <source>IncorrectPasswordError is returned when an incorrect password is detected.</source>
          <target state="translated">当检测到错误的密码时,将返回IncorrectPasswordError。</target>
        </trans-unit>
        <trans-unit id="aacf42132cce6cf5c1608a5d27f90fcbf93ae851" translate="yes" xml:space="preserve">
          <source>Indent</source>
          <target state="translated">Indent</target>
        </trans-unit>
        <trans-unit id="ffaaf5870213dda02bfcfd6086cb6c73c505917c" translate="yes" xml:space="preserve">
          <source>Indent appends to dst an indented form of the JSON-encoded src. Each element in a JSON object or array begins on a new, indented line beginning with prefix followed by one or more copies of indent according to the indentation nesting. The data appended to dst does not begin with the prefix nor any indentation, to make it easier to embed inside other formatted JSON data. Although leading space characters (space, tab, carriage return, newline) at the beginning of src are dropped, trailing space characters at the end of src are preserved and copied to dst. For example, if src has no trailing spaces, neither will dst; if src ends in a trailing newline, so will dst.</source>
          <target state="translated">缩进将JSON编码的src的缩进形式附加到dst。JSON 对象或数组中的每个元素都从新的缩进行开始,从前缀开始,根据缩进嵌套,后面是一个或多个缩进副本。附加到 dst 的数据不以前缀或任何缩进开始,以便更容易嵌入其他格式化的 JSON 数据中。虽然src开头的前导空格字符(空格、tab、回车、换行)会被删除,但src结尾的尾部空格字符会被保留并复制到dst。例如,如果 src 没有尾部空格,dst 也不会;如果 src 以尾部换行结束,dst 也会保留。</target>
        </trans-unit>
        <trans-unit id="68e20af4dfa7d94d1e8e99b5a45a2168cf2653cc" translate="yes" xml:space="preserve">
          <source>Indent sets the encoder to generate XML in which each element begins on a new indented line that starts with prefix and is followed by one or more copies of indent according to the nesting depth.</source>
          <target state="translated">缩进设置编码器生成XML,其中每个元素都从一个新的缩进行开始,该行以前缀开始,并根据嵌套深度跟随一个或多个缩进副本。</target>
        </trans-unit>
        <trans-unit id="c2df9b932637fe9d32a0f16da1c11873398f873d" translate="yes" xml:space="preserve">
          <source>Index</source>
          <target state="translated">Index</target>
        </trans-unit>
        <trans-unit id="421722312ce68c9bf9eb41def321649c4712dbd6" translate="yes" xml:space="preserve">
          <source>Index describes the path from x to f in x.f. The last index entry is the field or method index of the type declaring f; either:</source>
          <target state="translated">索引描述了x.f中从x到f的路径,最后一个索引条目是声明f的类型的字段或方法索引;无论是。</target>
        </trans-unit>
        <trans-unit id="1d0b49853e61d44f4f8b07282b1903e9f2bc5158" translate="yes" xml:space="preserve">
          <source>Index implements a suffix array for fast substring search.</source>
          <target state="translated">Index实现了一个后缀数组,用于快速的子串搜索。</target>
        </trans-unit>
        <trans-unit id="af573efacc3f6c1539d934e082a33b7c5805e74a" translate="yes" xml:space="preserve">
          <source>Index responds with the pprof-formatted profile named by the request. For example, &quot;/debug/pprof/heap&quot; serves the &quot;heap&quot; profile. Index responds to a request for &quot;/debug/pprof/&quot; with an HTML page listing the available profiles.</source>
          <target state="translated">Index用请求命名的pprof格式的配置文件来响应。例如,&quot;/debug/pprof/heap &quot;提供 &quot;堆 &quot;配置文件。Index用一个列出可用配置文件的HTML页面来响应对&quot;/debug/pprof/&quot;的请求。</target>
        </trans-unit>
        <trans-unit id="fd5b04a55e6c188f04225c052c3a4ebb3eecf806" translate="yes" xml:space="preserve">
          <source>Index returns JavaScript index i of value v. It panics if v is not a JavaScript object.</source>
          <target state="translated">Index返回值v的JavaScript索引i,如果v不是JavaScript对象,它就会恐慌。</target>
        </trans-unit>
        <trans-unit id="41cc91c9bcf3f0a08fb627d21f4a77281aee4bad" translate="yes" xml:space="preserve">
          <source>Index returns the index of the first instance of sep in s, or -1 if sep is not present in s.</source>
          <target state="translated">Index返回s中sep的第一个实例的索引,如果s中没有sep,则返回-1。</target>
        </trans-unit>
        <trans-unit id="1f02d6f4db0fe2bb71d169a720ea48dacd4410f7" translate="yes" xml:space="preserve">
          <source>Index returns the index of the first instance of substr in s, or -1 if substr is not present in s.</source>
          <target state="translated">Index 返回 s 中 substr 的第一个实例的索引,如果 s 中不存在 substr,则返回-1。</target>
        </trans-unit>
        <trans-unit id="6672a7ad3732041777afcc9d59e94790fa08598a" translate="yes" xml:space="preserve">
          <source>Index returns the index of the palette color closest to c in Euclidean R,G,B,A space.</source>
          <target state="translated">Index 返回欧氏R,G,B,A空间中最接近c的调色板颜色的索引。</target>
        </trans-unit>
        <trans-unit id="08cc5090355bf36192f88d52e3809f63b35b1be3" translate="yes" xml:space="preserve">
          <source>Index returns v's i'th element. It panics if v's Kind is not Array, Slice, or String or i is out of range.</source>
          <target state="translated">Index返回v的第i个元素。如果v的Kind不是Array,Slice,或String,或者i超出了范围,它就会惊慌失措。</target>
        </trans-unit>
        <trans-unit id="f604fe204d59450e53c6f0f981bb463a3da262fc" translate="yes" xml:space="preserve">
          <source>Index.Lookup</source>
          <target state="translated">Index.Lookup</target>
        </trans-unit>
        <trans-unit id="693f6afea6d2763baec63c4f683ab836809a8526" translate="yes" xml:space="preserve">
          <source>IndexAny</source>
          <target state="translated">IndexAny</target>
        </trans-unit>
        <trans-unit id="227cd6f0abdfd091813bf35b8fd1dcfbc25cecd9" translate="yes" xml:space="preserve">
          <source>IndexAny interprets s as a sequence of UTF-8-encoded Unicode code points. It returns the byte index of the first occurrence in s of any of the Unicode code points in chars. It returns -1 if chars is empty or if there is no code point in common.</source>
          <target state="translated">IndexAny将s解释为一个UTF-8编码的Unicode码点序列。它返回s中任何一个Unicode码点在chars中首次出现的字节索引。如果chars为空或没有共同的码点,它返回-1。</target>
        </trans-unit>
        <trans-unit id="1adf36d0e196212f2787325e2cb626ccc3228c3b" translate="yes" xml:space="preserve">
          <source>IndexAny returns the index of the first instance of any Unicode code point from chars in s, or -1 if no Unicode code point from chars is present in s.</source>
          <target state="translated">IndexAny返回s中任何来自chars的Unicode码点的第一个实例的索引,如果s中没有来自chars的Unicode码点,则返回-1。</target>
        </trans-unit>
        <trans-unit id="91d007c3332e259ec2e02f981423ecacc90c6ee6" translate="yes" xml:space="preserve">
          <source>IndexByte</source>
          <target state="translated">IndexByte</target>
        </trans-unit>
        <trans-unit id="c4f06e8f47e53dedfca453887d03a95ac035b5de" translate="yes" xml:space="preserve">
          <source>IndexByte returns the index of the first instance of c in b, or -1 if c is not present in b.</source>
          <target state="translated">IndexByte返回b中c的第一个实例的索引,如果b中没有c,则返回-1。</target>
        </trans-unit>
        <trans-unit id="c369952c4d2f42c9a51eabe33a7908d4c8f60ad4" translate="yes" xml:space="preserve">
          <source>IndexByte returns the index of the first instance of c in s, or -1 if c is not present in s.</source>
          <target state="translated">IndexByte返回s中c的第一个实例的索引,如果s中没有c,则返回-1。</target>
        </trans-unit>
        <trans-unit id="4b29f4c46fd4242b96d7f6d96005476262ea25b4" translate="yes" xml:space="preserve">
          <source>IndexFunc</source>
          <target state="translated">IndexFunc</target>
        </trans-unit>
        <trans-unit id="fd5aa7f0734b2b2162a12de708cba7a93a1ba269" translate="yes" xml:space="preserve">
          <source>IndexFunc interprets s as a sequence of UTF-8-encoded code points. It returns the byte index in s of the first Unicode code point satisfying f(c), or -1 if none do.</source>
          <target state="translated">IndexFunc 将 s 解释为一个 UTF-8 编码的码点序列,它返回 s 中第一个满足 f(c)的 Unicode 码点的字节索引,如果没有,则返回 -1。它返回s中第一个满足f(c)的Unicode码点的字节索引,如果没有,则返回-1。</target>
        </trans-unit>
        <trans-unit id="67453fcd073346734a7503bb3d4207a4ffac0a81" translate="yes" xml:space="preserve">
          <source>IndexFunc returns the index into s of the first Unicode code point satisfying f(c), or -1 if none do.</source>
          <target state="translated">IndexFunc返回第一个满足f(c)的Unicode码点在s中的索引,如果没有,则返回-1。</target>
        </trans-unit>
        <trans-unit id="0404886738141ffe45c4d013ff978a64bde2ba63" translate="yes" xml:space="preserve">
          <source>IndexRune</source>
          <target state="translated">IndexRune</target>
        </trans-unit>
        <trans-unit id="f4318ccac75e1dd461aaa7a9c7842e97a421edce" translate="yes" xml:space="preserve">
          <source>IndexRune interprets s as a sequence of UTF-8-encoded code points. It returns the byte index of the first occurrence in s of the given rune. It returns -1 if rune is not present in s. If r is utf8.RuneError, it returns the first instance of any invalid UTF-8 byte sequence.</source>
          <target state="translated">IndexRune将s解释为一个UTF-8编码的代码点序列。它返回s中首次出现的给定符文的字节索引,如果s中没有符文,则返回-1。如果r是utf8.RuneError,它返回任何无效的UTF-8字节序列的第一个实例。</target>
        </trans-unit>
        <trans-unit id="042bb768e6a79fc4f2a8939cb46f8d887178fb46" translate="yes" xml:space="preserve">
          <source>IndexRune returns the index of the first instance of the Unicode code point r, or -1 if rune is not present in s. If r is utf8.RuneError, it returns the first instance of any invalid UTF-8 byte sequence.</source>
          <target state="translated">IndexRune返回Unicode码点r的第一个实例的索引,如果s中没有Rune,则返回-1,如果r是utf8.RuneError,则返回任何无效UTF-8字节序列的第一个实例。</target>
        </trans-unit>
        <trans-unit id="a85d156f8eef16ea6fae8f47130c09e7ab738f38" translate="yes" xml:space="preserve">
          <source>Indexes into the Header.Ident array.</source>
          <target state="translated">索引进入Header.Ident数组。</target>
        </trans-unit>
        <trans-unit id="bee82bdb7da751fd64eea7f5143956992f5aed77" translate="yes" xml:space="preserve">
          <source>Indices into the Delta arrays inside CaseRanges for case mapping.</source>
          <target state="translated">指向CaseRanges内部的Delta数组,用于案例映射。</target>
        </trans-unit>
        <trans-unit id="22023c8031bf3535a364147cd1c4ebacba51eca8" translate="yes" xml:space="preserve">
          <source>Indirect reports whether any pointer indirection was required to get from x to f in x.f.</source>
          <target state="translated">间接报告在x.f中从x到f是否需要任何指针间接。</target>
        </trans-unit>
        <trans-unit id="1dbf2dfd2ac6c93be252e418d12775d2db6f53d8" translate="yes" xml:space="preserve">
          <source>Indirect returns the value that v points to. If v is a nil pointer, Indirect returns a zero Value. If v is not a pointer, Indirect returns v.</source>
          <target state="translated">间接返回v所指向的值,如果v是一个无指针,间接返回一个零值。如果v是一个nil指针,Indirect返回一个零值。如果v不是指针,Indirect返回v。</target>
        </trans-unit>
        <trans-unit id="fe7ad1fbee745b4ca3d08d7729476db7d9fb4fe9" translate="yes" xml:space="preserve">
          <source>Inf returns a complex infinity, complex(+Inf, +Inf).</source>
          <target state="translated">Inf返回一个复数无穷大,complex(+Inf,+Inf)。</target>
        </trans-unit>
        <trans-unit id="0125073a5f3757f1dc62bea262918d4c5b3bae8e" translate="yes" xml:space="preserve">
          <source>Inf returns positive infinity if sign &amp;gt;= 0, negative infinity if sign &amp;lt; 0.</source>
          <target state="translated">如果符号&amp;gt; = 0，则Inf返回正无穷大；如果符号&amp;lt;0，则Inf返回负无穷大。</target>
        </trans-unit>
        <trans-unit id="fd7feb1c61f7423453cbee79d9998496c4df75f3" translate="yes" xml:space="preserve">
          <source>Infinite recursion can also be triggered by self-referential data structures, such as a slice that contains itself as an element, if that type has a String method. Such pathologies are rare, however, and the package does not protect against them.</source>
          <target state="translated">无限递归也可以由自引用的数据结构触发,比如一个包含自己作为元素的分片,如果该类型有一个String方法的话。然而,这种病态是罕见的,而且该包并没有对其进行保护。</target>
        </trans-unit>
        <trans-unit id="4b631f69842530d659306c8f06dbad594a6b1807" translate="yes" xml:space="preserve">
          <source>Info</source>
          <target state="translated">Info</target>
        </trans-unit>
        <trans-unit id="0e2ca261be59b2db86de1819fd95c5c62808d215" translate="yes" xml:space="preserve">
          <source>Info holds result type information for a type-checked package. Only the information for which a map is provided is collected. If the package has type errors, the collected information may be incomplete.</source>
          <target state="translated">Info保存了类型检查包的结果类型信息。只有提供了映射的信息才会被收集。如果包有类型错误,那么收集的信息可能是不完整的。</target>
        </trans-unit>
        <trans-unit id="829a6f4d1b71214eb93db4bdc76fb1b790f4e5d1" translate="yes" xml:space="preserve">
          <source>Info logs a message with severity LOG_INFO, ignoring the severity passed to New.</source>
          <target state="translated">Info会记录一条严重性为LOG_INFO的消息,忽略传递给New的严重性。</target>
        </trans-unit>
        <trans-unit id="d0968061a8aa60c3762f0e765c2376d0827896c3" translate="yes" xml:space="preserve">
          <source>Info returns information about properties of basic type b.</source>
          <target state="translated">Info返回基本类型b的属性信息。</target>
        </trans-unit>
        <trans-unit id="4bebef89f6713b109d9329a6bfe51cba5fd0be4f" translate="yes" xml:space="preserve">
          <source>Init establishes the heap invariants required by the other routines in this package. Init is idempotent with respect to the heap invariants and may be called whenever the heap invariants may have been invalidated. The complexity is O(n) where n = h.Len().</source>
          <target state="translated">Init建立了这个包中其他例程所需要的堆不变量。Init相对于堆不变量来说是幂等的,并且可以在堆不变量失效的时候被调用。其复杂度为O(n),其中n=h.Len()。</target>
        </trans-unit>
        <trans-unit id="e025530212d94f43014839edcd8664101cb1d082" translate="yes" xml:space="preserve">
          <source>Init has no effect if it was already called.</source>
          <target state="translated">如果已经被调用,Init没有任何效果。</target>
        </trans-unit>
        <trans-unit id="ab8a6a690d98493f29c3a7eded17da06a0fe4963" translate="yes" xml:space="preserve">
          <source>Init initializes a Scanner with a new source and returns s. Error is set to nil, ErrorCount is set to 0, Mode is set to GoTokens, and Whitespace is set to GoWhitespace.</source>
          <target state="translated">Init 用新的源初始化 Scanner 并返回 s。Error 设置为 nil,ErrorCount 设置为 0,Mode 设置为 GoTokens,Whitespace 设置为 GoWhitespace。</target>
        </trans-unit>
        <trans-unit id="38f2f0576d19cc2c5fa27415d0b566e72a9f5fcc" translate="yes" xml:space="preserve">
          <source>Init initializes or clears list l.</source>
          <target state="translated">Init初始化或清除列表l。</target>
        </trans-unit>
        <trans-unit id="4828f42508fc3abcabc5d7577bba28e3151a2a20" translate="yes" xml:space="preserve">
          <source>Init prepares the scanner s to tokenize the text src by setting the scanner at the beginning of src. The scanner uses the file set file for position information and it adds line information for each line. It is ok to re-use the same file when re-scanning the same file as line information which is already present is ignored. Init causes a panic if the file size does not match the src size.</source>
          <target state="translated">Init通过在src的开头设置扫描器来准备扫描器s对文本src进行标记。扫描仪使用文件集文件作为位置信息,并为每行添加行信息。当重新扫描同一个文件时,可以重新使用同一个文件,因为已经存在的行信息会被忽略。如果文件大小与 src 大小不匹配,Init 会引起恐慌。</target>
        </trans-unit>
        <trans-unit id="1ff5728fd1958fa03cc23f0615bd53c6b8512d71" translate="yes" xml:space="preserve">
          <source>Init registers testing flags. These flags are automatically registered by the &quot;go test&quot; command before running test functions, so Init is only needed when calling functions such as Benchmark without using &quot;go test&quot;.</source>
          <target state="translated">Init注册了测试标志,这些标志在运行测试函数之前由 &quot;go test &quot;命令自动注册。在运行测试函数之前,这些标志由 &quot;go test &quot;命令自动注册,所以只有在不使用 &quot;go test &quot;而调用Benchmark等函数时才需要Init。</target>
        </trans-unit>
        <trans-unit id="e71fb65b44dd31464c3ab6d5dc9c1b767849af42" translate="yes" xml:space="preserve">
          <source>Init removes all keys from the map.</source>
          <target state="translated">Init从地图中删除所有键。</target>
        </trans-unit>
        <trans-unit id="2f9d5d06290960b800b664c463e2749afea3e374" translate="yes" xml:space="preserve">
          <source>Init sets the name and error handling property for a flag set. By default, the zero FlagSet uses an empty name and the ContinueOnError error handling policy.</source>
          <target state="translated">Init为一个标志集设置名称和错误处理属性,默认情况下,零标志集使用空名称和ContinueOnError错误处理策略。默认情况下,零标志集使用空名和ContinueOnError错误处理策略。</target>
        </trans-unit>
        <trans-unit id="1ff277aa8c5f044965228237465cbaf43a54dec6" translate="yes" xml:space="preserve">
          <source>Initial magic number for ELF files.</source>
          <target state="translated">ELF文件的初始魔数。</target>
        </trans-unit>
        <trans-unit id="7ceb1ca1dad4f40542d5a478441bc59f2f8873ca" translate="yes" xml:space="preserve">
          <source>Innermost returns the innermost (child) scope containing pos. If pos is not within any scope, the result is nil. The result is also nil for the Universe scope. The result is guaranteed to be valid only if the type-checked AST has complete position information.</source>
          <target state="translated">Innermost 返回包含 pos 的最内部(子)作用域。如果 pos 不在任何作用域中,结果是 nil。对于Universe作用域,结果也是nil。只有当经过类型检查的AST有完整的位置信息时,才能保证结果有效。</target>
        </trans-unit>
        <trans-unit id="d3d677ba8b8fb62d3d734397c41c430f5735b25c" translate="yes" xml:space="preserve">
          <source>Input processed by verbs is implicitly space-delimited: the implementation of every verb except %c starts by discarding leading spaces from the remaining input, and the %s verb (and %v reading into a string) stops consuming input at the first space or newline character.</source>
          <target state="translated">由动词处理的输入是隐式空间限制的:除了%c之外,每个动词的实现都是从剩余的输入开始丢弃前导空格,%s动词(和%v读入字符串)在第一个空格或换行符时停止消耗输入。</target>
        </trans-unit>
        <trans-unit id="f2b998d9fdcbc1c4a3ffebeea1625f9214a80db4" translate="yes" xml:space="preserve">
          <source>InputOffset returns the input stream byte offset of the current decoder position. The offset gives the location of the end of the most recently returned token and the beginning of the next token.</source>
          <target state="translated">InputOffset返回当前解码器位置的输入流字节偏移量。偏移量给出最近返回的标记的结束位置和下一个标记的开始位置。</target>
        </trans-unit>
        <trans-unit id="c6bdbccac97746d550ea930e761dad7ffa800d06" translate="yes" xml:space="preserve">
          <source>Insert attempts to insert a named object obj into the scope s. If the scope already contains an object alt with the same name, Insert leaves the scope unchanged and returns alt. Otherwise it inserts obj and returns nil.</source>
          <target state="translated">Insert试图将一个命名的对象obj插入到作用域s中,如果作用域中已经包含一个同名的对象alt,Insert将保持作用域不变并返回alt。否则插入obj并返回nil。</target>
        </trans-unit>
        <trans-unit id="3c51f0bca7bc21285dde2f4365d66539c9045fbd" translate="yes" xml:space="preserve">
          <source>Insert attempts to insert an object obj into scope s. If s already contains an alternative object alt with the same name, Insert leaves s unchanged and returns alt. Otherwise it inserts obj, sets the object's parent scope if not already set, and returns nil.</source>
          <target state="translated">Insert试图将对象obj插入到作用域s中,如果s中已经包含了一个同名的替代对象alt,Insert将保持s不变,并返回alt,否则插入obj,如果还没有设置,则设置对象的父作用域,并返回nil。否则插入obj,如果还没有设置,则设置对象的父作用域,并返回nil。</target>
        </trans-unit>
        <trans-unit id="e5d297ca4eb4122848b745777ba08d9e98e99026" translate="yes" xml:space="preserve">
          <source>InsertAfter inserts a new element e with value v immediately after mark and returns e. If mark is not an element of l, the list is not modified. The mark must not be nil.</source>
          <target state="translated">InsertAfter在mark之后插入一个新的元素e,其值为v,并返回e,如果mark不是l的元素,则列表不会被修改。mark不能是nil。</target>
        </trans-unit>
        <trans-unit id="f8690dfd3964564996a8ec4c6a534ffd7d8cce51" translate="yes" xml:space="preserve">
          <source>InsertBefore inserts a new element e with value v immediately before mark and returns e. If mark is not an element of l, the list is not modified. The mark must not be nil.</source>
          <target state="translated">InsertBefore在mark之前插入一个新的元素e,其值为v,并返回e,如果mark不是l的元素,则列表不会被修改。mark不能是nil。</target>
        </trans-unit>
        <trans-unit id="1a44ed1d9fdf3b19a9445ead705835b2d7701bba" translate="yes" xml:space="preserve">
          <source>Inset returns the rectangle r inset by n, which may be negative. If either of r's dimensions is less than 2*n then an empty rectangle near the center of r will be returned.</source>
          <target state="translated">Inset 返回矩形r的内插尺寸n,可以是负数。如果r的任何一个尺寸小于2*n,那么将返回一个靠近r中心的空矩形。</target>
        </trans-unit>
        <trans-unit id="18ca87afec4298d9de864e32b4eeb6a31786e496" translate="yes" xml:space="preserve">
          <source>Inspect</source>
          <target state="translated">Inspect</target>
        </trans-unit>
        <trans-unit id="165da1fa673b9fd9a581f6c1c726cccbffc7e2ca" translate="yes" xml:space="preserve">
          <source>Inspect traverses an AST in depth-first order: It starts by calling f(node); node must not be nil. If f returns true, Inspect invokes f recursively for each of the non-nil children of node, followed by a call of f(nil).</source>
          <target state="translated">Inspect以深度优先的顺序遍历一个AST,它通过调用f(node)开始。它首先调用f(node);node必须不是nil。如果f返回true,Inspector对node的每个非nil子代递归调用f,然后调用f(nil)。</target>
        </trans-unit>
        <trans-unit id="a6a380194dfce8d967bc921f5f0bd2558e839e1f" translate="yes" xml:space="preserve">
          <source>InstanceOf reports whether v is an instance of type t according to JavaScript's instanceof operator.</source>
          <target state="translated">InstanceOf根据JavaScript的instanceof运算符报告v是否是t类型的实例。</target>
        </trans-unit>
        <trans-unit id="ebf808b93582c50b9dee098ffbc7851e8bbd1bc5" translate="yes" xml:space="preserve">
          <source>Int defines an int flag with specified name, default value, and usage string. The return value is the address of an int variable that stores the value of the flag.</source>
          <target state="translated">Int定义了一个int标志,具有指定的名称、默认值和使用字符串。返回值是一个存储标志值的int变量的地址。</target>
        </trans-unit>
        <trans-unit id="4a82193f61167eeb73caee70b7d931807aee1e38" translate="yes" xml:space="preserve">
          <source>Int is a 64-bit integer variable that satisfies the Var interface.</source>
          <target state="translated">Int是一个满足Var接口的64位整数变量。</target>
        </trans-unit>
        <trans-unit id="af260c99fb6b16af9acf30bb7ef7c67bfd7f461c" translate="yes" xml:space="preserve">
          <source>Int returns a non-negative pseudo-random int from the default Source.</source>
          <target state="translated">Int从默认的Source返回一个非负的伪随机int。</target>
        </trans-unit>
        <trans-unit id="381ad8d2cdfa2db4d632061cd5638bdb827c118f" translate="yes" xml:space="preserve">
          <source>Int returns a non-negative pseudo-random int.</source>
          <target state="translated">Int返回一个非负的伪随机int。</target>
        </trans-unit>
        <trans-unit id="78b2c6c511c1ed56b26a62f7cd24e23bebce41b7" translate="yes" xml:space="preserve">
          <source>Int returns a uniform random value in [0, max). It panics if max &amp;lt;= 0.</source>
          <target state="translated">Int以[0，最大值）返回统一的随机值。如果max &amp;lt;= 0，则表示恐慌。</target>
        </trans-unit>
        <trans-unit id="5333a3a7b26511027f14a3034f5b9a08970c91dc" translate="yes" xml:space="preserve">
          <source>Int returns the result of truncating x towards zero; or nil if x is an infinity. The result is Exact if x.IsInt(); otherwise it is Below for x &amp;gt; 0, and Above for x &amp;lt; 0. If a non-nil *Int argument z is provided, Int stores the result in z instead of allocating a new Int.</source>
          <target state="translated">Int返回将x截断为零的结果。如果x是无穷大，则为nil。如果x.IsInt（）;结果为Exact。否则，对于x&amp;gt; 0，它是&amp;ldquo;低于&amp;rdquo;；对于x &amp;lt;0，它是高于。如果提供了非nil * Int参数z，则Int会将结果存储在z中，而不是分配新的Int。</target>
        </trans-unit>
        <trans-unit id="b48fef275365436d3178b531a98b6df9140d4a4e" translate="yes" xml:space="preserve">
          <source>Int returns the value v truncated to an int. It panics if v is not a JavaScript number.</source>
          <target state="translated">Int返回值v截断为一个int。如果v不是JavaScript数字,它就会恐慌。</target>
        </trans-unit>
        <trans-unit id="7aeadc703783366afed8a63b0734b22311f2a7e4" translate="yes" xml:space="preserve">
          <source>Int returns v's underlying value, as an int64. It panics if v's Kind is not Int, Int8, Int16, Int32, or Int64.</source>
          <target state="translated">Int以int64的形式返回v的底层值,如果v的Kind不是Int、Int8、Int16、Int32或Int64,它就会恐慌。如果v的Kind不是Int、Int8、Int16、Int32或Int64,它就会惊慌失措。</target>
        </trans-unit>
        <trans-unit id="53c091a9597bdba1f2ca46d491f5c108342e031f" translate="yes" xml:space="preserve">
          <source>Int.Scan</source>
          <target state="translated">Int.Scan</target>
        </trans-unit>
        <trans-unit id="5de699e08eb78e768e5b08ea65a2d2d995d6cca4" translate="yes" xml:space="preserve">
          <source>Int.SetString</source>
          <target state="translated">Int.SetString</target>
        </trans-unit>
        <trans-unit id="25863d22096f1ba104e899340881b4d53e78900e" translate="yes" xml:space="preserve">
          <source>Int31 returns a non-negative pseudo-random 31-bit integer as an int32 from the default Source.</source>
          <target state="translated">Int31从默认的Source返回一个非负的伪随机31位整数作为int32。</target>
        </trans-unit>
        <trans-unit id="8668fa86efe442ed5c0ddfb6799eac348a1585d9" translate="yes" xml:space="preserve">
          <source>Int31 returns a non-negative pseudo-random 31-bit integer as an int32.</source>
          <target state="translated">Int31以int32的形式返回一个非负的伪随机31位整数。</target>
        </trans-unit>
        <trans-unit id="4ef488a0ec898f126b9413bbb42319fb0eaeff13" translate="yes" xml:space="preserve">
          <source>Int31n returns, as an int32, a non-negative pseudo-random number in [0,n) from the default Source. It panics if n &amp;lt;= 0.</source>
          <target state="translated">Int31n从默认Source返回[0，n）中的非负伪随机数作为int32。如果n &amp;lt;= 0则恐慌。</target>
        </trans-unit>
        <trans-unit id="90d847f9e26c6ab28ce7fd160e1218ad35e875d4" translate="yes" xml:space="preserve">
          <source>Int31n returns, as an int32, a non-negative pseudo-random number in [0,n). It panics if n &amp;lt;= 0.</source>
          <target state="translated">Int31n以int32的形式返回[0，n）中的非负伪随机数。如果n &amp;lt;= 0则恐慌。</target>
        </trans-unit>
        <trans-unit id="848b71a013b8e0169e247e647c756adf54d70a3d" translate="yes" xml:space="preserve">
          <source>Int32 is a ValueConverter that converts input values to int64, respecting the limits of an int32 value.</source>
          <target state="translated">Int32是一个ValueConverter,它将输入值转换为int64,尊重int32值的限制。</target>
        </trans-unit>
        <trans-unit id="40feceb2effc4993d828a64f0bbc7bd4b65472d1" translate="yes" xml:space="preserve">
          <source>Int63 returns a non-negative pseudo-random 63-bit integer as an int64 from the default Source.</source>
          <target state="translated">Int63从默认的Source返回一个非负的伪随机63位整数作为int64。</target>
        </trans-unit>
        <trans-unit id="73b13ad335bd8c446e54125036bbdb60110b8a67" translate="yes" xml:space="preserve">
          <source>Int63 returns a non-negative pseudo-random 63-bit integer as an int64.</source>
          <target state="translated">Int63以int64的形式返回一个非负的伪随机63位整数。</target>
        </trans-unit>
        <trans-unit id="ccf199104b81302e6aa6420d9d53fbe6d1e5e481" translate="yes" xml:space="preserve">
          <source>Int63n returns, as an int64, a non-negative pseudo-random number in [0,n) from the default Source. It panics if n &amp;lt;= 0.</source>
          <target state="translated">Int63n从默认Source返回[0，n）中的非负伪随机数作为int64。如果n &amp;lt;= 0则恐慌。</target>
        </trans-unit>
        <trans-unit id="adc50ec6888e251cb9eb8237744893f852c6674f" translate="yes" xml:space="preserve">
          <source>Int63n returns, as an int64, a non-negative pseudo-random number in [0,n). It panics if n &amp;lt;= 0.</source>
          <target state="translated">Int63n将[0，n）中的非负伪随机数作为int64返回。如果n &amp;lt;= 0则恐慌。</target>
        </trans-unit>
        <trans-unit id="caf7332f4387883214a684cf486e59d1298af5e4" translate="yes" xml:space="preserve">
          <source>Int64 defines an int64 flag with specified name, default value, and usage string. The return value is the address of an int64 variable that stores the value of the flag.</source>
          <target state="translated">Int64定义了一个int64标志,具有指定的名称、默认值和使用字符串。返回值是存储标志值的int64变量的地址。</target>
        </trans-unit>
        <trans-unit id="5ea42bb5a91b0f37c1c104284dddf7aee6dd3d40" translate="yes" xml:space="preserve">
          <source>Int64 returns the int64 representation of x. If x cannot be represented in an int64, the result is undefined.</source>
          <target state="translated">Int64返回x的int64表示法。如果x不能用int64表示,则结果为未定义。</target>
        </trans-unit>
        <trans-unit id="024ee0329e5ac0182a79c3f0f817ea471b5da8f4" translate="yes" xml:space="preserve">
          <source>Int64 returns the integer resulting from truncating x towards zero. If math.MinInt64 &amp;lt;= x &amp;lt;= math.MaxInt64, the result is Exact if x is an integer, and Above (x &amp;lt; 0) or Below (x &amp;gt; 0) otherwise. The result is (math.MinInt64, Above) for x &amp;lt; math.MinInt64, and (math.MaxInt64, Below) for x &amp;gt; math.MaxInt64.</source>
          <target state="translated">Int64返回将x截断为零所得的整数。如果math.MinInt64 &amp;lt;= x &amp;lt;= math.MaxInt64，则如果x为整数，则结果为&amp;ldquo;精确&amp;rdquo;，否则为&amp;ldquo;大于（x &amp;lt;0）或小于（x&amp;gt; 0）&amp;rdquo;。对于x &amp;lt;math.MinInt64，结果为（math.MinInt64，上方）；对于x&amp;gt; math.MaxInt64，结果为（math.MaxInt64，下方）。</target>
        </trans-unit>
        <trans-unit id="a7858f715e5515e9b11682c98c7e956884fa03d3" translate="yes" xml:space="preserve">
          <source>Int64 returns the number as an int64.</source>
          <target state="translated">Int64 返回一个int64的数字。</target>
        </trans-unit>
        <trans-unit id="e87b1cbe8a7626b33b6c26f9454e9b97aa48ff20" translate="yes" xml:space="preserve">
          <source>Int64Val returns the Go int64 value of x and whether the result is exact; x must be an Int or an Unknown. If the result is not exact, its value is undefined. If x is Unknown, the result is (0, false).</source>
          <target state="translated">Int64Val 返回 x 的围棋 int64 值以及结果是否精确;x 必须是 Int 或 Unknown。如果结果不精确,它的值是未定义的。如果x是未知值,结果是(0,false)。</target>
        </trans-unit>
        <trans-unit id="e48ba0f308dabec3542a772cd98df7b4a194464a" translate="yes" xml:space="preserve">
          <source>Int64Var defines an int64 flag with specified name, default value, and usage string. The argument p points to an int64 variable in which to store the value of the flag.</source>
          <target state="translated">Int64Var定义了一个int64标志,它具有指定的名称、默认值和用法字符串,参数p指向一个int64变量,用来存储标志的值。参数p指向一个int64变量,用来存储标志的值。</target>
        </trans-unit>
        <trans-unit id="826fdf675ec889637dd1607e0ecbc7b4617ed6b5" translate="yes" xml:space="preserve">
          <source>IntSize is the size in bits of an int or uint value.</source>
          <target state="translated">IntSize是一个int或uint值的大小,单位是位。</target>
        </trans-unit>
        <trans-unit id="7d0ad3a5fc2c5562d1a3d5edaf660d5681e2e7dd" translate="yes" xml:space="preserve">
          <source>IntSlice attaches the methods of Interface to []int, sorting in increasing order.</source>
          <target state="translated">IntSlice将Interface的方法附加到[]int上,按递增顺序排序。</target>
        </trans-unit>
        <trans-unit id="259cdcc1487407a0effb8761c09ff465d822351b" translate="yes" xml:space="preserve">
          <source>IntVar defines an int flag with specified name, default value, and usage string. The argument p points to an int variable in which to store the value of the flag.</source>
          <target state="translated">IntVar定义了一个int标志,具有指定的名称、默认值和用法字符串。参数p指向一个int变量,用来存储标志的值。</target>
        </trans-unit>
        <trans-unit id="e927198b4dfea79ca477c6ca320b7977e5f907d8" translate="yes" xml:space="preserve">
          <source>Integer flags accept 1234, 0664, 0x1234 and may be negative. Boolean flags may be:</source>
          <target state="translated">整数标志接受1234、0664、0x1234,可以是负数。布尔标志可以是:</target>
        </trans-unit>
        <trans-unit id="d8d2cb0f1ba846253e8f8508e7b268037f761677" translate="yes" xml:space="preserve">
          <source>Integer limit values.</source>
          <target state="translated">整数极限值。</target>
        </trans-unit>
        <trans-unit id="8e6549b1b15bddbc7e4ca51ecb54082a0c50f802" translate="yes" xml:space="preserve">
          <source>Integer:</source>
          <target state="translated">Integer:</target>
        </trans-unit>
        <trans-unit id="8ef45f34654a956038b7d2e46f7b980bceca0a1e" translate="yes" xml:space="preserve">
          <source>IntegerType is here for the purposes of documentation only. It is a stand-in for any integer type: int, uint, int8 etc.</source>
          <target state="translated">IntegerType在这里只是为了文档的目的。它是任何整数类型的替身:int、uint、int8等。</target>
        </trans-unit>
        <trans-unit id="5a289c0331a1e2ae1cddd468bdbd08515a751488" translate="yes" xml:space="preserve">
          <source>Integers are transmitted two ways: arbitrary precision signed integers or arbitrary precision unsigned integers. There is no int8, int16 etc. discrimination in the gob format; there are only signed and unsigned integers. As described below, the transmitter sends the value in a variable-length encoding; the receiver accepts the value and stores it in the destination variable. Floating-point numbers are always sent using IEEE-754 64-bit precision (see below).</source>
          <target state="translated">整数的传输方式有两种:任意精度的有符号整数或任意精度的无符号整数。在gob格式中没有int8、int16等的区分,只有有符号整数和无符号整数。如下所述,发送方以可变长度的编码发送值;接收方接受值并将其存储在目标变量中。浮点数总是使用IEEE-754 64位精度发送(见下文)。</target>
        </trans-unit>
        <trans-unit id="8a7e153030b338cdad7a41aa466f441af45e4a11" translate="yes" xml:space="preserve">
          <source>Interface represents a mapping between network interface name and index. It also represents network interface facility information.</source>
          <target state="translated">接口表示网络接口名称和索引之间的映射。它也代表网络接口设施信息。</target>
        </trans-unit>
        <trans-unit id="6da3607f32beaa93e64c1a37a2f36fbed997c327" translate="yes" xml:space="preserve">
          <source>Interface returns v's current value as an interface{}. It is equivalent to:</source>
          <target state="translated">接口以接口{}的形式返回v的当前值。它相当于:</target>
        </trans-unit>
        <trans-unit id="5ea5c3979b46b5a2713cc2d1786a81b1f8ec63c2" translate="yes" xml:space="preserve">
          <source>Interface types are not checked for compatibility; all interface types are treated, for transmission, as members of a single &quot;interface&quot; type, analogous to int or []byte - in effect they're all treated as interface{}. Interface values are transmitted as a string identifying the concrete type being sent (a name that must be pre-defined by calling Register), followed by a byte count of the length of the following data (so the value can be skipped if it cannot be stored), followed by the usual encoding of concrete (dynamic) value stored in the interface value. (A nil interface value is identified by the empty string and transmits no value.) Upon receipt, the decoder verifies that the unpacked concrete item satisfies the interface of the receiving variable.</source>
          <target state="translated">接口类型不进行兼容性检查;在传输时,所有接口类型都被视为单一 &quot;接口 &quot;类型的成员,类似于int或[]byte--实际上它们都被视为接口{}。接口值的传输方式是一个标识被发送的具体类型的字符串(这个名称必须由调用Register预先定义),后面是一个字节数,表示下面数据的长度(所以如果不能存储该值,可以跳过),后面是存储在接口值中的具体(动态)值的通常编码。(nil接口值由空字符串标识,不传输任何值)。收到后,解码器验证解包后的具体项是否满足接收变量的接口。</target>
        </trans-unit>
        <trans-unit id="74b4a1f2cd95d6ac03afcfd27826497cd84b5ae7" translate="yes" xml:space="preserve">
          <source>Interface values are deeply equal if they hold deeply equal concrete values.</source>
          <target state="translated">界面值如果持有深度相等的具体数值,则为深度相等。</target>
        </trans-unit>
        <trans-unit id="09203e8778d59b495323467d890a95f5807f26bf" translate="yes" xml:space="preserve">
          <source>Interface values encode as the value contained in the interface. A nil interface value encodes as the null JSON value.</source>
          <target state="translated">接口值编码为接口中包含的值。无接口值编码为空JSON值。</target>
        </trans-unit>
        <trans-unit id="360b50370b24932254b26c7af3e111445c188db0" translate="yes" xml:space="preserve">
          <source>InterfaceAddrs returns a list of the system's unicast interface addresses.</source>
          <target state="translated">InterfaceAddrs 返回系统的单播接口地址列表。</target>
        </trans-unit>
        <trans-unit id="9ce937dfbe60c7ef5a110a8b5806627105e626f1" translate="yes" xml:space="preserve">
          <source>InterfaceByIndex returns the interface specified by index.</source>
          <target state="translated">InterfaceByIndex 返回由index指定的接口。</target>
        </trans-unit>
        <trans-unit id="4245d4428eaccf8da6182470aec7d558cea28a53" translate="yes" xml:space="preserve">
          <source>InterfaceByName returns the interface specified by name.</source>
          <target state="translated">InterfaceByName返回由名称指定的接口。</target>
        </trans-unit>
        <trans-unit id="a63d53fbc696efd4a28db884d8645a21dcabe121" translate="yes" xml:space="preserve">
          <source>InterfaceData returns the interface v's value as a uintptr pair. It panics if v's Kind is not Interface.</source>
          <target state="translated">InterfaceData以uintptr对的形式返回接口v的值。如果v的Kind不是Interface,它就会恐慌。</target>
        </trans-unit>
        <trans-unit id="470a021de3b9df70021376a7834ee99ab5ab1f2e" translate="yes" xml:space="preserve">
          <source>Interfaces returns a list of the system's network interfaces.</source>
          <target state="translated">Interfaces 返回系统的网络接口列表。</target>
        </trans-unit>
        <trans-unit id="a60781d644f0c18cd790184e8cc93bbf04ff58fe" translate="yes" xml:space="preserve">
          <source>Intersect returns the largest rectangle contained by both r and s. If the two rectangles do not overlap then the zero rectangle will be returned.</source>
          <target state="translated">交叉返回r和s所包含的最大矩形,如果两个矩形不重合,则返回零矩形。</target>
        </trans-unit>
        <trans-unit id="37b82affb5d88e1d235360ffb5b4876b9c358ef4" translate="yes" xml:space="preserve">
          <source>Intn</source>
          <target state="translated">Intn</target>
        </trans-unit>
        <trans-unit id="54d0c13534e6e00abbb2d04b4cb149c7d0ddea38" translate="yes" xml:space="preserve">
          <source>Intn returns, as an int, a non-negative pseudo-random number in [0,n) from the default Source. It panics if n &amp;lt;= 0.</source>
          <target state="translated">Intn从默认Source返回[0，n）中的非负伪随机数作为int。如果n &amp;lt;= 0则恐慌。</target>
        </trans-unit>
        <trans-unit id="8f26feb5337a07fc6e35ec73e1c6b06a4a8f7c21" translate="yes" xml:space="preserve">
          <source>Intn returns, as an int, a non-negative pseudo-random number in [0,n). It panics if n &amp;lt;= 0.</source>
          <target state="translated">Intn以int形式返回[0，n）中的非负伪随机数。如果n &amp;lt;= 0则恐慌。</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="b7f44e53c873fdc1db7cef7777af521f4a3b60c1" translate="yes" xml:space="preserve">
          <source>Ints</source>
          <target state="translated">Ints</target>
        </trans-unit>
        <trans-unit id="0d62fa520893beed143100d8873cdbc43cfe7428" translate="yes" xml:space="preserve">
          <source>Ints sorts a slice of ints in increasing order.</source>
          <target state="translated">Ints按照递增的顺序对ints的一个片断进行排序。</target>
        </trans-unit>
        <trans-unit id="00382ca46ab71a1b23e2790f3cf0a66b6faa90df" translate="yes" xml:space="preserve">
          <source>IntsAreSorted</source>
          <target state="translated">IntsAreSorted</target>
        </trans-unit>
        <trans-unit id="d11bf023986ecfce333bd8a5477d90f31eb1db0a" translate="yes" xml:space="preserve">
          <source>IntsAreSorted tests whether a slice of ints is sorted in increasing order.</source>
          <target state="translated">IntsAreSorted测试一个ints片是否按递增顺序排序。</target>
        </trans-unit>
        <trans-unit id="e6124bd83c6b099c79f4ac3379192d76121e3dfb" translate="yes" xml:space="preserve">
          <source>Inv sets z to 1/x and returns z.</source>
          <target state="translated">Inv设z为1/x,并返回z。</target>
        </trans-unit>
        <trans-unit id="57f0200085fa1268ae261758bfb7dee5795a5704" translate="yes" xml:space="preserve">
          <source>InvalidByteError values describe errors resulting from an invalid byte in a hex string.</source>
          <target state="translated">InvalidByteError值描述的是十六进制字符串中的无效字节导致的错误。</target>
        </trans-unit>
        <trans-unit id="fc945344ffab3c8e0685a8f6f0b347b0e1b5f04c" translate="yes" xml:space="preserve">
          <source>Invoke does a JavaScript call of the value v with the given arguments. It panics if v is not a JavaScript function. The arguments get mapped to JavaScript values according to the ValueOf function.</source>
          <target state="translated">Invoke使用给定的参数对值v进行JavaScript调用。如果v不是JavaScript函数,它就会惊慌失措。根据ValueOf函数,参数会被映射到JavaScript值。</target>
        </trans-unit>
        <trans-unit id="a8bc24ce97a4c19ceec821a6c13e305d4cc7093a" translate="yes" xml:space="preserve">
          <source>Invoking the JavaScript function will synchronously call the Go function fn with the value of JavaScript's &quot;this&quot; keyword and the arguments of the invocation. The return value of the invocation is the result of the Go function mapped back to JavaScript according to ValueOf.</source>
          <target state="translated">调用JavaScript函数会同步调用Go函数fn,并将JavaScript的 &quot;this &quot;关键字的值和调用的参数。调用的返回值是Go函数根据ValueOf映射回JavaScript的结果。</target>
        </trans-unit>
        <trans-unit id="b80342e2833069978eb2ebabac8e59ca1a3fbfc5" translate="yes" xml:space="preserve">
          <source>Is reports whether any error in err's chain matches target.</source>
          <target state="translated">报告err链中是否有与目标匹配的错误。</target>
        </trans-unit>
        <trans-unit id="2dcad3f5fb898f44a28ca9cc90eb869f037180e6" translate="yes" xml:space="preserve">
          <source>Is reports whether the rune is in the specified table of ranges.</source>
          <target state="translated">是报告符文是否在指定的范围表中。</target>
        </trans-unit>
        <trans-unit id="d895a1147fb9e99c093e2c8e3aa2a3a161a62599" translate="yes" xml:space="preserve">
          <source>Is unwraps its first argument sequentially looking for an error that matches the second. It reports whether it finds a match. It should be used in preference to simple equality checks:</source>
          <target state="translated">Is依次展开第一个参数,寻找与第二个参数匹配的错误。它报告是否找到匹配。它应该优先用于简单的平等检查。</target>
        </trans-unit>
        <trans-unit id="4240feb2e7eac03ab7672bf3d52cbd0df60964bf" translate="yes" xml:space="preserve">
          <source>IsAbs</source>
          <target state="translated">IsAbs</target>
        </trans-unit>
        <trans-unit id="6ba3e5deb5d3ce3b158c2019d9e58f42637cf610" translate="yes" xml:space="preserve">
          <source>IsAbs reports whether the URL is absolute. Absolute means that it has a non-empty scheme.</source>
          <target state="translated">IsAbs报告URL是否是绝对的。Absolute意味着它有一个非空的方案。</target>
        </trans-unit>
        <trans-unit id="36a0d5f9413d1e35ae6366ef607edd836694bee0" translate="yes" xml:space="preserve">
          <source>IsAbs reports whether the path is absolute.</source>
          <target state="translated">IsAbs报告路径是否为绝对路径。</target>
        </trans-unit>
        <trans-unit id="e1eaf7841a07f287f076c00cb20e44f9651ff13f" translate="yes" xml:space="preserve">
          <source>IsAlias reports whether obj is an alias name for a type.</source>
          <target state="translated">IsAlias报告obj是否是一个类型的别名。</target>
        </trans-unit>
        <trans-unit id="0e84022f347580b90f81c69d614f481de5c48849" translate="yes" xml:space="preserve">
          <source>IsBuiltin reports whether the corresponding expression denotes a (possibly parenthesized) built-in function.</source>
          <target state="translated">IsBuiltin报告对应的表达式是否表示一个(可能是括号)内置函数。</target>
        </trans-unit>
        <trans-unit id="c915051f076524ecaa2f5d332eb2bb4d2765eefa" translate="yes" xml:space="preserve">
          <source>IsCommand reports whether the package is considered a command to be installed (not just a library). Packages named &quot;main&quot; are treated as commands.</source>
          <target state="translated">IsCommand报告包是否被认为是一个要安装的命令(而不仅仅是一个库)。以 &quot;main &quot;命名的软件包被视为命令。</target>
        </trans-unit>
        <trans-unit id="2cd3abc2f41e5f98828e0ebaee47dfbcd10387ad" translate="yes" xml:space="preserve">
          <source>IsControl reports whether the rune is a control character. The C (Other) Unicode category includes more code points such as surrogates; use Is(C, r) to test for them.</source>
          <target state="translated">IsControl报告该符文是否是控制字符。C(Other)Unicode类别包括更多的代码点,如代字;使用Is(C,r)来测试它们。</target>
        </trans-unit>
        <trans-unit id="c746a0807bba76d32760f9142c884716d0699c51" translate="yes" xml:space="preserve">
          <source>IsDigit reports whether the rune is a decimal digit.</source>
          <target state="translated">IsDigit报告符文是否为十进制数字。</target>
        </trans-unit>
        <trans-unit id="3dc4a185454e26efa4716393eed4775f2e55fe7c" translate="yes" xml:space="preserve">
          <source>IsDir reports whether m describes a directory. That is, it tests for the ModeDir bit being set in m.</source>
          <target state="translated">IsDir报告m是否描述了一个目录。也就是说,它测试m中的ModeDir位是否被设置。</target>
        </trans-unit>
        <trans-unit id="5fd80e2b1854e3452cd6bfd7234aa8fa8ddcdc63" translate="yes" xml:space="preserve">
          <source>IsEmptyTree reports whether this tree (node) is empty of everything but space.</source>
          <target state="translated">IsEmptyTree报告这棵树(节点)除了空间之外是否为空。</target>
        </trans-unit>
        <trans-unit id="cd43f5281afe605e10c23fa5e5c73089248f9feb" translate="yes" xml:space="preserve">
          <source>IsEnabled reports whether tracing is enabled. The information is advisory only. The tracing status may have changed by the time this function returns.</source>
          <target state="translated">IsEnabled报告是否启用了追踪。该信息仅作参考,在本函数返回时,跟踪状态可能已经改变。在本函数返回时,跟踪状态可能已经改变。</target>
        </trans-unit>
        <trans-unit id="39e18e7e1b9d6fbe4b3f09d74593704f059a0c0a" translate="yes" xml:space="preserve">
          <source>IsEncryptedPEMBlock returns if the PEM block is password encrypted.</source>
          <target state="translated">IsEncryptedPEMBlock返回PEM块是否已被密码加密。</target>
        </trans-unit>
        <trans-unit id="bc66205543d841780222acbebc983e058e70415a" translate="yes" xml:space="preserve">
          <source>IsExist returns a boolean indicating whether the error is known to report that a file or directory already exists. It is satisfied by ErrExist as well as some syscall errors.</source>
          <target state="translated">IsExist 返回一个布尔值,表示是否已知错误,报告一个文件或目录已经存在。它由ErrExist以及一些系统调用错误来满足。</target>
        </trans-unit>
        <trans-unit id="fc56fa9983588228bd9fa3b0b5a7931ac3cb75f1" translate="yes" xml:space="preserve">
          <source>IsExported reports whether id starts with an upper-case letter.</source>
          <target state="translated">IsExported报告id是否以大写字母开头。</target>
        </trans-unit>
        <trans-unit id="3c6d4e31e0d52ed1d2823481dfa21ed80c9b776d" translate="yes" xml:space="preserve">
          <source>IsExported reports whether name starts with an upper-case letter.</source>
          <target state="translated">IsExported报告名称是否以大写字母开头。</target>
        </trans-unit>
        <trans-unit id="504274dd55fc2a273ebc2bd501f5695303ffe229" translate="yes" xml:space="preserve">
          <source>IsField reports whether the variable is a struct field.</source>
          <target state="translated">IsField报告变量是否是结构域。</target>
        </trans-unit>
        <trans-unit id="d9bdbeb50a8c37eb5d00e31069315d70d10359d6" translate="yes" xml:space="preserve">
          <source>IsGlobalUnicast reports whether ip is a global unicast address.</source>
          <target state="translated">IsGlobalUnicast报告ip是否为全局单播地址。</target>
        </trans-unit>
        <trans-unit id="d72f8c1ccd0ac092185d981b6c61eacc3c121ef6" translate="yes" xml:space="preserve">
          <source>IsGraphic</source>
          <target state="translated">IsGraphic</target>
        </trans-unit>
        <trans-unit id="56022820abfd812a684373d7b12ff29c87996877" translate="yes" xml:space="preserve">
          <source>IsGraphic reports whether the rune is defined as a Graphic by Unicode. Such characters include letters, marks, numbers, punctuation, symbols, and spaces, from categories L, M, N, P, S, Zs.</source>
          <target state="translated">IsGraphic报告该符文是否被Unicode定义为图形。这些字符包括字母、标记、数字、标点符号、符号和空格,来自L、M、N、P、S、Zs类别。</target>
        </trans-unit>
        <trans-unit id="3bed5baca126f10003a7fc44f4e55808b330feda" translate="yes" xml:space="preserve">
          <source>IsGraphic reports whether the rune is defined as a Graphic by Unicode. Such characters include letters, marks, numbers, punctuation, symbols, and spaces, from categories L, M, N, P, S, and Zs.</source>
          <target state="translated">IsGraphic报告该符文是否被Unicode定义为图形。这些字符包括字母、标记、数字、标点符号、符号和空格,来自L、M、N、P、S和Zs类别。</target>
        </trans-unit>
        <trans-unit id="93d167ded0e381246ad35c4922eb8c26e2a4fc55" translate="yes" xml:space="preserve">
          <source>IsIdentifier reports whether name is a Go identifier, that is, a non-empty string made up of letters, digits, and underscores, where the first character is not a digit. Keywords are not identifiers.</source>
          <target state="translated">IsIdentifier 报告名称是否是围棋标识符,即由字母、数字和下划线组成的非空字符串,其中第一个字符不是数字。关键词不是标识符。</target>
        </trans-unit>
        <trans-unit id="679d30c5187a96f463dfbcdfb594ecc9983403ef" translate="yes" xml:space="preserve">
          <source>IsInf reports whether either real(x) or imag(x) is an infinity.</source>
          <target state="translated">IsInf报告real(x)或 imag(x)是否为无穷大。</target>
        </trans-unit>
        <trans-unit id="13dd75a92325ad267d0a2fa14c6cb50f24a9dd7b" translate="yes" xml:space="preserve">
          <source>IsInf reports whether f is an infinity, according to sign. If sign &amp;gt; 0, IsInf reports whether f is positive infinity. If sign &amp;lt; 0, IsInf reports whether f is negative infinity. If sign == 0, IsInf reports whether f is either infinity.</source>
          <target state="translated">IsInf根据符号报告f是否为无穷大。如果sign&amp;gt; 0，则IsInf报告f是否为正无穷大。如果符号&amp;lt;0，则IsInf报告f是否为负无穷大。如果符号== 0，则IsInf报告f是否为无穷大。</target>
        </trans-unit>
        <trans-unit id="8e1783a22a02fb29f43965c4b4c975183d78e4dd" translate="yes" xml:space="preserve">
          <source>IsInf reports whether x is +Inf or -Inf.</source>
          <target state="translated">IsInf报告x是+Inf还是-Inf。</target>
        </trans-unit>
        <trans-unit id="1b05edd34484393d17b771d708b4b2dd276cb90e" translate="yes" xml:space="preserve">
          <source>IsInt reports whether the denominator of x is 1.</source>
          <target state="translated">IsInt报告x的分母是否为1。</target>
        </trans-unit>
        <trans-unit id="63c80063be9af3740f75431caecb4e56ba22484c" translate="yes" xml:space="preserve">
          <source>IsInt reports whether x is an integer. &amp;plusmn;Inf values are not integers.</source>
          <target state="translated">IsInt报告x是否为整数。&amp;plusmn;Inf值不是整数。</target>
        </trans-unit>
        <trans-unit id="00a1b79e443959417f450c9b16cf5f48a8929d0f" translate="yes" xml:space="preserve">
          <source>IsInt64 reports whether x can be represented as an int64.</source>
          <target state="translated">IsInt64报告x是否可以用int64表示。</target>
        </trans-unit>
        <trans-unit id="ab97d0f94b18fe8f3b28313a45a877858cc4fa50" translate="yes" xml:space="preserve">
          <source>IsInterface reports whether typ is an interface type.</source>
          <target state="translated">IsInterface 报告 typ 是否为接口类型。</target>
        </trans-unit>
        <trans-unit id="c6bdcbe107886851b028b532be31d52568400157" translate="yes" xml:space="preserve">
          <source>IsInterfaceLocalMulticast reports whether ip is an interface-local multicast address.</source>
          <target state="translated">IsInterfaceLocalMulticast报告ip是否为接口本地组播地址。</target>
        </trans-unit>
        <trans-unit id="203bcfa02f0ff2531137c0e97e09e91145ccf765" translate="yes" xml:space="preserve">
          <source>IsKeyword reports whether name is a Go keyword, such as &quot;func&quot; or &quot;return&quot;.</source>
          <target state="translated">IsKeyword报告name是否是Go关键字,如 &quot;func &quot;或 &quot;return&quot;。</target>
        </trans-unit>
        <trans-unit id="b1af467f9e4844b489b1e4d07d7f23c5a24e49f8" translate="yes" xml:space="preserve">
          <source>IsKeyword returns true for tokens corresponding to keywords; it returns false otherwise.</source>
          <target state="translated">对于关键字对应的标记,IsKeyword返回true,否则返回false。</target>
        </trans-unit>
        <trans-unit id="9e659e799b643d193bc338fa878bc56e93c2043d" translate="yes" xml:space="preserve">
          <source>IsLetter reports whether the rune is a letter (category L).</source>
          <target state="translated">IsLetter报告符文是否为字母(L类)。</target>
        </trans-unit>
        <trans-unit id="796f0c2eac4ef075bdac49252f1a8a9437f7cb5a" translate="yes" xml:space="preserve">
          <source>IsLinkLocalMulticast reports whether ip is a link-local multicast address.</source>
          <target state="translated">IsLinkLocalMulticast报告ip是否为链路本地组播地址。</target>
        </trans-unit>
        <trans-unit id="bb398472e4891951632d23a856db9700a4f1260f" translate="yes" xml:space="preserve">
          <source>IsLinkLocalUnicast reports whether ip is a link-local unicast address.</source>
          <target state="translated">IsLinkLocalUnicast会报告ip是否是link-local单播地址。</target>
        </trans-unit>
        <trans-unit id="338823e775821fbbffd934b6dc8f8c7b06cf31f5" translate="yes" xml:space="preserve">
          <source>IsLiteral returns true for tokens corresponding to identifiers and basic type literals; it returns false otherwise.</source>
          <target state="translated">对于标识符和基本类型字元对应的标记,IsLiteral返回true,否则返回false。</target>
        </trans-unit>
        <trans-unit id="a302aa5062a5a2939f950e77a3b1bd2cffbbb134" translate="yes" xml:space="preserve">
          <source>IsLocalImport reports whether the import path is a local import path, like &quot;.&quot;, &quot;..&quot;, &quot;./foo&quot;, or &quot;../foo&quot;.</source>
          <target state="translated">IsLocalImport报告导入路径是否是本地导入路径,如&quot;.&quot;、&quot;.&quot;、&quot;./foo &quot;或&quot;./foo&quot;。</target>
        </trans-unit>
        <trans-unit id="a279a0dd486da312eb888a933fcd3c106d5ddf1b" translate="yes" xml:space="preserve">
          <source>IsLoopback reports whether ip is a loopback address.</source>
          <target state="translated">IsLoopback报告ip是否为环回地址。</target>
        </trans-unit>
        <trans-unit id="4c6115a445a46684f9b4821abab1454dcf00a510" translate="yes" xml:space="preserve">
          <source>IsLower reports whether the rune is a lower case letter.</source>
          <target state="translated">IsLower报告符文是否为小写字母。</target>
        </trans-unit>
        <trans-unit id="e316f3e3a4a4a943e13f969fe03fe3e6888a42f0" translate="yes" xml:space="preserve">
          <source>IsMark reports whether the rune is a mark character (category M).</source>
          <target state="translated">IsMark报告该符文是否为标记字符(类别M)。</target>
        </trans-unit>
        <trans-unit id="e919a8a1e5af711657ece2a09a282e053c84e876" translate="yes" xml:space="preserve">
          <source>IsMulticast reports whether ip is a multicast address.</source>
          <target state="translated">IsMulticast报告ip是否为多播地址。</target>
        </trans-unit>
        <trans-unit id="0d71475a6ac8cde45586a2e1ee4e9f1a73195c46" translate="yes" xml:space="preserve">
          <source>IsNaN reports whether either real(x) or imag(x) is NaN and neither is an infinity.</source>
          <target state="translated">IsNaN报告real(x)或imag(x)是否为NaN,且都不是无穷大。</target>
        </trans-unit>
        <trans-unit id="51cb1fb375010c76e1d272e937551b9aa294ed29" translate="yes" xml:space="preserve">
          <source>IsNaN reports whether f is an IEEE 754 &amp;ldquo;not-a-number&amp;rdquo; value.</source>
          <target state="translated">IsNaN报告f是否为IEEE 754&amp;ldquo;非数字&amp;rdquo;值。</target>
        </trans-unit>
        <trans-unit id="8a70a6c8c78f197d95d9931060aaaff0e1ad7ace" translate="yes" xml:space="preserve">
          <source>IsNil reports whether its argument v is nil. The argument must be a chan, func, interface, map, pointer, or slice value; if it is not, IsNil panics. Note that IsNil is not always equivalent to a regular comparison with nil in Go. For example, if v was created by calling ValueOf with an uninitialized interface variable i, i==nil will be true but v.IsNil will panic as v will be the zero Value.</source>
          <target state="translated">IsNil报告它的参数v是否为nil,参数必须是chan、func、接口、map、指针或片值。参数必须是 chan、func、接口、map、指针或 slice 值;如果不是,IsNil 就会慌乱。注意,IsNil并不总是等同于Go中与nil的常规比较。例如,如果v是用一个未初始化的接口变量i调用ValueOf创建的,i==nil将为真,但v.IsNil将恐慌,因为v将是零值。</target>
        </trans-unit>
        <trans-unit id="d1cbf137d274a495776ae13213f6abf32b87d01c" translate="yes" xml:space="preserve">
          <source>IsNil reports whether the corresponding expression denotes the predeclared value nil.</source>
          <target state="translated">IsNil报告对应的表达式是否表示预声明的值为nil。</target>
        </trans-unit>
        <trans-unit id="299ff42ffbb3020ccb3e165c3f47990aa016cf3b" translate="yes" xml:space="preserve">
          <source>IsNotExist</source>
          <target state="translated">IsNotExist</target>
        </trans-unit>
        <trans-unit id="03c20e37da945e513d60a4c872afa073a5099855" translate="yes" xml:space="preserve">
          <source>IsNotExist returns a boolean indicating whether the error is known to report that a file or directory does not exist. It is satisfied by ErrNotExist as well as some syscall errors.</source>
          <target state="translated">IsNotExist 返回一个布尔值,表示是否已知错误,报告一个文件或目录不存在。它被ErrNotExist以及一些系统调用错误所满足。</target>
        </trans-unit>
        <trans-unit id="f2c323038256b2a2953181c6a475ccd896ada404" translate="yes" xml:space="preserve">
          <source>IsNumber reports whether the rune is a number (category N).</source>
          <target state="translated">IsNumber报告符文是否为数字(类别N)。</target>
        </trans-unit>
        <trans-unit id="245475f668f23bbed41324e2de1b4948cc531ddc" translate="yes" xml:space="preserve">
          <source>IsOneOf reports whether the rune is a member of one of the ranges. The function &quot;In&quot; provides a nicer signature and should be used in preference to IsOneOf.</source>
          <target state="translated">IsOneOf报告该符文是否是其中一个范围的成员。函数 &quot;In &quot;提供了一个更好的签名,应该优先于IsOneOf使用。</target>
        </trans-unit>
        <trans-unit id="a20bd2f5568b340e7370b04b798bc3f83596bcce" translate="yes" xml:space="preserve">
          <source>IsOperator returns true for tokens corresponding to operators and delimiters; it returns false otherwise.</source>
          <target state="translated">对于与运算符和定界符相对应的标记,IsOperator返回true;否则返回false。</target>
        </trans-unit>
        <trans-unit id="73c5624da9ca6fbf3e420dbf86786a852cc89a14" translate="yes" xml:space="preserve">
          <source>IsPathSeparator reports whether c is a directory separator character.</source>
          <target state="translated">IsPathSeparator报告c是否是目录分隔符。</target>
        </trans-unit>
        <trans-unit id="8bd40ac27999a79bc28cf90f839e43d8f9372279" translate="yes" xml:space="preserve">
          <source>IsPermission returns a boolean indicating whether the error is known to report that permission is denied. It is satisfied by ErrPermission as well as some syscall errors.</source>
          <target state="translated">IsPermission返回一个布尔值,表示是否已知错误,报告权限被拒绝。它由ErrPermission以及一些系统调用错误来满足。</target>
        </trans-unit>
        <trans-unit id="e48f3df15b49da83d51099ad5b3eb8bbfd8edc75" translate="yes" xml:space="preserve">
          <source>IsPredeclared reports whether s is a predeclared identifier.</source>
          <target state="translated">IsPredeclared报告s是否是一个预先声明的标识符。</target>
        </trans-unit>
        <trans-unit id="36ebaf4d189aca534d273d48d5ddeec782d7bed9" translate="yes" xml:space="preserve">
          <source>IsPrint</source>
          <target state="translated">IsPrint</target>
        </trans-unit>
        <trans-unit id="9798b863454466bfa901e359486dca8125aebd8e" translate="yes" xml:space="preserve">
          <source>IsPrint reports whether the rune is defined as printable by Go, with the same definition as unicode.IsPrint: letters, numbers, punctuation, symbols and ASCII space.</source>
          <target state="translated">IsPrint报告符文是否被围棋定义为可打印,定义与unicode相同.IsPrint:字母、数字、标点符号、符号和ASCII空间。</target>
        </trans-unit>
        <trans-unit id="98481c27a5fae0a861fa7de3b6778c4d86a82e18" translate="yes" xml:space="preserve">
          <source>IsPrint reports whether the rune is defined as printable by Go. Such characters include letters, marks, numbers, punctuation, symbols, and the ASCII space character, from categories L, M, N, P, S and the ASCII space character. This categorization is the same as IsGraphic except that the only spacing character is ASCII space, U+0020.</source>
          <target state="translated">IsPrint报告该符文是否被围棋定义为可打印字符。这类字符包括字母、标记、数字、标点符号、符号和ASCII空格字符,来自L、M、N、P、S类和ASCII空格字符。这种分类与IsGraphic相同,只是唯一的间隔字符是ASCII空格,U+0020。</target>
        </trans-unit>
        <trans-unit id="8d669f2d873d45ac65ae33ba5fc527f66e56a570" translate="yes" xml:space="preserve">
          <source>IsPunct reports whether the rune is a Unicode punctuation character (category P).</source>
          <target state="translated">IsPunct报告符文是否是Unicode标点符号(类别P)。</target>
        </trans-unit>
        <trans-unit id="09f51db22f739274d216b281ce628857122cde77" translate="yes" xml:space="preserve">
          <source>IsRegular reports whether m describes a regular file. That is, it tests that no mode type bits are set.</source>
          <target state="translated">IsRegular报告m是否描述一个常规文件。也就是说,它测试是否没有设置模式类型位。</target>
        </trans-unit>
        <trans-unit id="7aa02fb0658d675b5c73f5d774f227af20e5eda3" translate="yes" xml:space="preserve">
          <source>IsScanValue is equivalent to IsValue. It exists for compatibility.</source>
          <target state="translated">IsScanValue相当于IsValue。它的存在是为了兼容。</target>
        </trans-unit>
        <trans-unit id="02fd007fd97349a8b2fafa3e48b3fe7f504ea24c" translate="yes" xml:space="preserve">
          <source>IsSorted reports whether data is sorted.</source>
          <target state="translated">IsSorted报告数据是否已排序。</target>
        </trans-unit>
        <trans-unit id="514d21d401add5f58b109e05d3a8a2615962f831" translate="yes" xml:space="preserve">
          <source>IsSpace reports whether the rune is a space character as defined by Unicode's White Space property; in the Latin-1 space this is</source>
          <target state="translated">IsSpace报告符文是否是Unicode白色空间属性所定义的空间字符;在Latin-1空间中,这就是</target>
        </trans-unit>
        <trans-unit id="b8364c32e39bc01deb2db29de008f790b53e0511" translate="yes" xml:space="preserve">
          <source>IsSurrogate reports whether the specified Unicode code point can appear in a surrogate pair.</source>
          <target state="translated">IsSurrogate报告指定的Unicode码点是否可以出现在代理对中。</target>
        </trans-unit>
        <trans-unit id="94ff69a73ee80e68160fc5d14463531f326feb1a" translate="yes" xml:space="preserve">
          <source>IsSymbol reports whether the rune is a symbolic character.</source>
          <target state="translated">IsSymbol报告符文是否是一个符号字符。</target>
        </trans-unit>
        <trans-unit id="80e8a9046c478caac6544a67a67898f6f56d102d" translate="yes" xml:space="preserve">
          <source>IsTimeout returns a boolean indicating whether the error is known to report that a timeout occurred.</source>
          <target state="translated">IsTimeout 返回一个布尔值,表示是否已知错误,报告发生超时。</target>
        </trans-unit>
        <trans-unit id="5dae031aae8f79fce18391198feff6e45790996f" translate="yes" xml:space="preserve">
          <source>IsTitle reports whether the rune is a title case letter.</source>
          <target state="translated">IsTitle报告该符文是否为标题大小写。</target>
        </trans-unit>
        <trans-unit id="47cdd782e568065cbc896003cc3080e6fa343e64" translate="yes" xml:space="preserve">
          <source>IsTrue reports whether the value is 'true', in the sense of not the zero of its type, and whether the value has a meaningful truth value. This is the definition of truth used by if and other such actions.</source>
          <target state="translated">IsTrue报告该值是否为 &quot;真&quot;,即不是其类型的零,以及该值是否有一个有意义的真值。这是if和其他此类操作使用的真值定义。</target>
        </trans-unit>
        <trans-unit id="f386d0c906e9366cb699b0ae4451bc9d70023dc4" translate="yes" xml:space="preserve">
          <source>IsType reports whether the corresponding expression specifies a type.</source>
          <target state="translated">IsType报告对应的表达式是否指定了一个类型。</target>
        </trans-unit>
        <trans-unit id="bd72caa363338547d5699b96c1b4ac80c8cd24c1" translate="yes" xml:space="preserve">
          <source>IsUint64 reports whether x can be represented as a uint64.</source>
          <target state="translated">IsUint64报告x是否可以用uint64表示。</target>
        </trans-unit>
        <trans-unit id="6b3721da2086f5e9441475d80b1c204e06489512" translate="yes" xml:space="preserve">
          <source>IsUnspecified reports whether ip is an unspecified address, either the IPv4 address &quot;0.0.0.0&quot; or the IPv6 address &quot;::&quot;.</source>
          <target state="translated">IsUnspecified报告ip是否是一个未指定的地址,可以是IPv4地址 &quot;0.0.0.0&quot;,也可以是IPv6地址&quot;::&quot;。</target>
        </trans-unit>
        <trans-unit id="b72d29b8198db403c8169f5f00434fb729acb678" translate="yes" xml:space="preserve">
          <source>IsUpper reports whether the rune is an upper case letter.</source>
          <target state="translated">IsUpper报告符文是否是大写字母。</target>
        </trans-unit>
        <trans-unit id="ecc382ac4eeae90631c4ff786a142c8cd4a2a1e3" translate="yes" xml:space="preserve">
          <source>IsValid reports whether the position is valid.</source>
          <target state="translated">IsValid报告该位置是否有效。</target>
        </trans-unit>
        <trans-unit id="6b4d65bab951e443a5b5a6cb70b5527aa329d397" translate="yes" xml:space="preserve">
          <source>IsValid reports whether v represents a value. It returns false if v is the zero Value. If IsValid returns false, all other methods except String panic. Most functions and methods never return an invalid value. If one does, its documentation states the conditions explicitly.</source>
          <target state="translated">IsValid报告v是否代表一个值。如果v是零值,它返回false。如果IsValid返回false,除了String以外的所有其他方法都会惊慌失措。大多数函数和方法从不返回无效值。如果有一个方法返回无效值,它的文档会明确说明条件。</target>
        </trans-unit>
        <trans-unit id="55d30ff7d3d863a32468776759178dbe0451ccce" translate="yes" xml:space="preserve">
          <source>IsValue reports whether the corresponding expression is a value. Builtins are not considered values. Constant values have a non- nil Value.</source>
          <target state="translated">IsValue报告对应的表达式是否是一个值。内置值不被认为是值。常量值的值是非零。</target>
        </trans-unit>
        <trans-unit id="9d7a5d3a7652824e4f9b549a7d5a262a10ef59c5" translate="yes" xml:space="preserve">
          <source>IsValue reports whether v is a valid Value parameter type.</source>
          <target state="translated">IsValue报告v是否是一个有效的Value参数类型。</target>
        </trans-unit>
        <trans-unit id="65e1a871482dad54f08e17dd72762a3fd2f75d74" translate="yes" xml:space="preserve">
          <source>IsVoid reports whether the corresponding expression is a function call without results.</source>
          <target state="translated">IsVoid报告对应的表达式是否是一个没有结果的函数调用。</target>
        </trans-unit>
        <trans-unit id="297c16f9ae029663b610c3b616363007a062b053" translate="yes" xml:space="preserve">
          <source>IsWordChar reports whether r is consider a &amp;ldquo;word character&amp;rdquo; during the evaluation of the \b and \B zero-width assertions. These assertions are ASCII-only: the word characters are [A-Za-z0-9_].</source>
          <target state="translated">IsWordChar报告在评估\ b和\ B零宽度断言期间r是否被视为&amp;ldquo;单词字符&amp;rdquo;。这些断言仅是ASCII：字字符是[A-Za-z0-9_]。</target>
        </trans-unit>
        <trans-unit id="5f0397c5af2b47c485a6cac89d344b49d39148e5" translate="yes" xml:space="preserve">
          <source>IsZero reports whether t represents the zero time instant, January 1, year 1, 00:00:00 UTC.</source>
          <target state="translated">IsZero报告t是否代表零时间瞬间,1年1月1日00:00:00 UTC。</target>
        </trans-unit>
        <trans-unit id="14b29f8979f8b38e486b8c2fc265fcec75315a1b" translate="yes" xml:space="preserve">
          <source>IsZero reports whether v is the zero value for its type. It panics if the argument is invalid.</source>
          <target state="translated">IsZero报告v是否是其类型的零值。如果参数无效,它就会惊慌失措。</target>
        </trans-unit>
        <trans-unit id="2e5ba7b50d53dc66de9ac76f94ae84e19ac42a4e" translate="yes" xml:space="preserve">
          <source>IsolationLevel is the transaction isolation level stored in TxOptions.</source>
          <target state="translated">IsolationLevel是存储在TxOptions中的事务隔离级别。</target>
        </trans-unit>
        <trans-unit id="00b8885e61c34531225b38e32ae41a763eb82a05" translate="yes" xml:space="preserve">
          <source>IsolationLevel is the transaction isolation level used in TxOptions.</source>
          <target state="translated">IsolationLevel是TxOptions中使用的事务隔离级别。</target>
        </trans-unit>
        <trans-unit id="d76fb5eb8c221bc52330dc2413a54b325f8af681" translate="yes" xml:space="preserve">
          <source>It does nothing if the URL's scheme is not HTTP or HTTPS.</source>
          <target state="translated">如果URL的方案不是HTTP或HTTPS,它不会做任何事情。</target>
        </trans-unit>
        <trans-unit id="730fc66fc7c6f8658abbd279912d4debd6897a14" translate="yes" xml:space="preserve">
          <source>It is allowed but not required for the caller to hold c.L during the call.</source>
          <target state="translated">在通话过程中,允许但不要求呼叫者保持c.L。</target>
        </trans-unit>
        <trans-unit id="64b18effbf60d196d9c9972b0f4752ad49d90515" translate="yes" xml:space="preserve">
          <source>It is allowed to call Notify multiple times with different channels and the same signals: each channel receives copies of incoming signals independently.</source>
          <target state="translated">允许用不同的频道和相同的信号多次调用Notify:每个频道独立接收接收信号的副本。</target>
        </trans-unit>
        <trans-unit id="2b72f5a15cc86252895b6a5820ed7c36974cccb2" translate="yes" xml:space="preserve">
          <source>It is allowed to call Notify multiple times with the same channel: each call expands the set of signals sent to that channel. The only way to remove signals from the set is to call Stop.</source>
          <target state="translated">允许用同一个通道多次调用Notify:每次调用都会扩大发送到该通道的信号集。从集合中删除信号的唯一方法是调用Stop。</target>
        </trans-unit>
        <trans-unit id="64b9ab50226fefd57abe4e106fe4fbde6d348569" translate="yes" xml:space="preserve">
          <source>It is defined in RFC 1950:</source>
          <target state="translated">它的定义在RFC 1950中。</target>
        </trans-unit>
        <trans-unit id="3527f9b32341885623b87c38f5f98392bdedd8dc" translate="yes" xml:space="preserve">
          <source>It is equivalent to SplitAfterN with a count of -1.</source>
          <target state="translated">它相当于SplitAfterN的计数为-1。</target>
        </trans-unit>
        <trans-unit id="dbac3455f5dcff27b15907e612c36dc6d6627118" translate="yes" xml:space="preserve">
          <source>It is equivalent to SplitN with a count of -1.</source>
          <target state="translated">它相当于数为-1的SplitN。</target>
        </trans-unit>
        <trans-unit id="9bc89c86db3c02e15ec65887cfcf0cc312b36a24" translate="yes" xml:space="preserve">
          <source>It is not associated with any particular color profile.</source>
          <target state="translated">它不与任何特定的颜色配置文件相关联。</target>
        </trans-unit>
        <trans-unit id="8b9cf269b7a066efe335dc4941105afdd2791a76" translate="yes" xml:space="preserve">
          <source>It is not guaranteed that a finalizer will run for objects allocated in initializers for package-level variables. Such objects may be linker-allocated, not heap-allocated.</source>
          <target state="translated">并不能保证最终确定器会为包级变量的初始化器中分配的对象运行。这些对象可能是链接器分配的,而不是堆分配的。</target>
        </trans-unit>
        <trans-unit id="185afc47d5312f1df75d7c2e1fd8c497c93c1bee" translate="yes" xml:space="preserve">
          <source>It is not guaranteed that a finalizer will run if the size of *obj is zero bytes.</source>
          <target state="translated">如果*obj的大小为零字节,则不能保证最终程序会运行。</target>
        </trans-unit>
        <trans-unit id="e276973efe0e06473fcbf2184470a55ce905f9ea" translate="yes" xml:space="preserve">
          <source>It is rare to Close a DB, as the DB handle is meant to be long-lived and shared between many goroutines.</source>
          <target state="translated">关闭一个DB是很罕见的,因为DB句柄是要长期存在的,并且在许多goroutine之间共享。</target>
        </trans-unit>
        <trans-unit id="13c70c7692f708ab80a79d217ba3b943c3b63874" translate="yes" xml:space="preserve">
          <source>It is safe to call Read and Write in parallel with each other or with Close. Parallel calls to Read and parallel calls to Write are also safe: the individual calls will be gated sequentially.</source>
          <target state="translated">相互之间或与Close并行调用Read和Write是安全的。平行调用Read和平行调用Write也是安全的:各个调用将按顺序进行门控。</target>
        </trans-unit>
        <trans-unit id="8e87bdde62b3a11cc618f6eef7d1ef7e95ea027e" translate="yes" xml:space="preserve">
          <source>It is sometimes necessary for a test program to do extra setup or teardown before or after testing. It is also sometimes necessary for a test to control which code runs on the main thread. To support these and other cases, if a test file contains a function:</source>
          <target state="translated">有时,测试程序需要在测试前或测试后进行额外的设置或拆卸。有时,测试也需要控制哪些代码在主线程上运行。为了支持这些和其他情况,如果一个测试文件包含一个函数。</target>
        </trans-unit>
        <trans-unit id="c4c640b2d1c13408fc0addbe9ca9b3e33c914d4c" translate="yes" xml:space="preserve">
          <source>It is the caller's responsibility to call Close on the Reader when done.</source>
          <target state="translated">呼叫者有责任在完成后呼叫关闭阅读器。</target>
        </trans-unit>
        <trans-unit id="986480998eaebed4b6a54647e1482613d046d84f" translate="yes" xml:space="preserve">
          <source>It is the caller's responsibility to call Close on the Writer when done. Writes may be buffered and not flushed until Close.</source>
          <target state="translated">调用者有责任在完成后对Writer调用Close。写作可能会被缓冲,直到关闭时才会被刷新。</target>
        </trans-unit>
        <trans-unit id="5d5e9d1ff14ea8de0b89e8865f3f584d482a0afe" translate="yes" xml:space="preserve">
          <source>It is useful mainly in compressed network protocols, to ensure that a remote reader has enough data to reconstruct a packet. Flush does not return until the data has been written. If the underlying writer returns an error, Flush returns that error.</source>
          <target state="translated">它主要在压缩网络协议中有用,以确保远程阅读器有足够的数据来重建数据包。在数据被写入之前,Flush不会返回。如果底层写入器返回一个错误,Flush就会返回该错误。</target>
        </trans-unit>
        <trans-unit id="31cc99464ed62136a451655119e840afa7451b83" translate="yes" xml:space="preserve">
          <source>It is valid both to add and to subtract offsets from a pointer in this way. It is also valid to use &amp;amp;^ to round pointers, usually for alignment. In all cases, the result must continue to point into the original allocated object.</source>
          <target state="translated">以这种方式从指针添加和减去偏移量都是有效的。通常使用＆^舍入指针（通常用于对齐）也是有效的。在所有情况下，结果都必须继续指向原始分配的对象。</target>
        </trans-unit>
        <trans-unit id="dd1e16d418b70f8a4bcbc355b1da37369ffe8113" translate="yes" xml:space="preserve">
          <source>It makes one call to data.Len to determine n, O(n*log(n)) calls to data.Less and O(n*log(n)*log(n)) calls to data.Swap.</source>
          <target state="translated">它对data.Len进行一次调用以确定n,对data.Less进行O(n*log(n))调用,对data.Swap进行O(n*log(n)*log(n))调用。</target>
        </trans-unit>
        <trans-unit id="49a3b03dcb3864c71030445c5ba5bfe2611711d2" translate="yes" xml:space="preserve">
          <source>It may also be received into any of these:</source>
          <target state="translated">也可以接收到其中的任何一种。</target>
        </trans-unit>
        <trans-unit id="7b88fc3e61debf0d0f1a1581e71a0996edf539a5" translate="yes" xml:space="preserve">
          <source>It panics if count is negative or if the result of (len(b) * count) overflows.</source>
          <target state="translated">如果count为负值或者(len(b)*count)的结果溢出,它就会恐慌。</target>
        </trans-unit>
        <trans-unit id="8b61a1a4bb411ee036d7d3cc509678ace33cef83" translate="yes" xml:space="preserve">
          <source>It panics if count is negative or if the result of (len(s) * count) overflows.</source>
          <target state="translated">如果count为负值或者(len(s)*count)的结果溢出,它就会恐慌。</target>
        </trans-unit>
        <trans-unit id="652db58383317d0338f369bbd62022ed3ab07600" translate="yes" xml:space="preserve">
          <source>It panics if the Value was obtained by accessing unexported struct fields.</source>
          <target state="translated">如果该值是通过访问未导出的结构体字段获得的,它就会恐慌。</target>
        </trans-unit>
        <trans-unit id="564d342d70ea92defe3199a234b7ca21ece54f95" translate="yes" xml:space="preserve">
          <source>It returns a *rsa.PrivateKey, a *ecdsa.PrivateKey, or a ed25519.PrivateKey. More types might be supported in the future.</source>
          <target state="translated">它返回一个*rsa.PrivateKey,一个*ecdsa.PrivateKey,或一个ed25519.PrivateKey。将来可能会支持更多的类型。</target>
        </trans-unit>
        <trans-unit id="9f11d9cd546ed2abe8e697fa6f8bbdc2a3d2e5ef" translate="yes" xml:space="preserve">
          <source>It returns a *rsa.PublicKey, *dsa.PublicKey, *ecdsa.PublicKey, or ed25519.PublicKey. More types might be supported in the future.</source>
          <target state="translated">它返回一个*rsa.PublicKey、*dsa.PublicKey、*ecdsa.PublicKey或ed25519.PublicKey。未来可能会支持更多类型。</target>
        </trans-unit>
        <trans-unit id="e5010d434ca33dd92d7a44910817533939048059" translate="yes" xml:space="preserve">
          <source>It returns an empty slice if the URL's scheme is not HTTP or HTTPS.</source>
          <target state="translated">如果URL的方案不是HTTP或HTTPS,它返回一个空的分片。</target>
        </trans-unit>
        <trans-unit id="2b565edf53edd5e13295b4a395aad926eda82327" translate="yes" xml:space="preserve">
          <source>It returns an error if t has already been executed.</source>
          <target state="translated">如果t已经被执行,它会返回一个错误。</target>
        </trans-unit>
        <trans-unit id="a56353db7fb203c22e0bfd117b292abd05c5de94" translate="yes" xml:space="preserve">
          <source>It returns an error if t or any associated template has already been executed.</source>
          <target state="translated">如果t或任何相关模板已经被执行,它将返回一个错误。</target>
        </trans-unit>
        <trans-unit id="e63a57b040488970eacecfd2272a9deb62e2be3e" translate="yes" xml:space="preserve">
          <source>It returns an error if the receiver is not an exported type or has no suitable methods. It also logs the error using package log. The client accesses each method using a string of the form &quot;Type.Method&quot;, where Type is the receiver's concrete type.</source>
          <target state="translated">如果接收器不是导出的类型或者没有合适的方法,它将返回一个错误。它还使用包日志记录错误。客户端使用 &quot;Type.Method &quot;形式的字符串访问每个方法,其中Type是接收器的具体类型。</target>
        </trans-unit>
        <trans-unit id="4dde580c3be3f14ce5fe15d368688767eafb64f5" translate="yes" xml:space="preserve">
          <source>It returns the IP address and the network implied by the IP and prefix length. For example, ParseCIDR(&quot;192.0.2.1/24&quot;) returns the IP address 192.0.2.1 and the network 192.0.2.0/24.</source>
          <target state="translated">它返回IP地址和IP及前缀长度所隐含的网络。例如,ParseCIDR(&quot;192.0.2.1/24&quot;)返回IP地址192.0.2.1和网络192.0.2.0/24。</target>
        </trans-unit>
        <trans-unit id="0b053a1afdc2a3fb959c27dc82bd3e04e4d3478f" translate="yes" xml:space="preserve">
          <source>It sets only the Path and Args in the returned structure.</source>
          <target state="translated">它只在返回的结构中设置路径和Args。</target>
        </trans-unit>
        <trans-unit id="810599e9d82ed867f48c9be47863d26eaa5d33f3" translate="yes" xml:space="preserve">
          <source>It sets z to the (possibly rounded) value of the corresponding floating- point value, and returns z, the actual base b, and an error err, if any. The entire string (not just a prefix) must be consumed for success. If z's precision is 0, it is changed to 64 before rounding takes effect. The number must be of the form:</source>
          <target state="translated">它将z设置为相应浮点值的(可能是四舍五入)值,并返回z、实际的基数b和错误err(如果有)。整个字符串(不仅仅是前缀)必须被消耗才能成功。如果z的精度为0,则在四舍五入生效之前将其改为64。数字必须是这样的形式。</target>
        </trans-unit>
        <trans-unit id="4b0e67dd55e6df4a3c7132865324312cab9fb6a8" translate="yes" xml:space="preserve">
          <source>It should not be used for recursive read locking; a blocked Lock call excludes new readers from acquiring the lock. See the documentation on the RWMutex type.</source>
          <target state="translated">它不应被用于递归读取锁定;被阻止的Lock调用排除了新的读者获取锁。参见RWMutex类型的文档。</target>
        </trans-unit>
        <trans-unit id="ff62c59d333b6b7669c7f0b6568819a5dff0f396" translate="yes" xml:space="preserve">
          <source>Iterate calls f for the files in the file set in the order they were added until f returns false.</source>
          <target state="translated">迭代调用f,按照文件集中的文件添加顺序,直到f返回false。</target>
        </trans-unit>
        <trans-unit id="380c384a3bc4560682612879309496ebdde5cfd3" translate="yes" xml:space="preserve">
          <source>Itoa</source>
          <target state="translated">Itoa</target>
        </trans-unit>
        <trans-unit id="aac52064292950f4b3f0337ac6b1ebbc54bd40af" translate="yes" xml:space="preserve">
          <source>Itoa is equivalent to FormatInt(int64(i), 10).</source>
          <target state="translated">Itoa相当于FormatInt(int64(i),10)。</target>
        </trans-unit>
        <trans-unit id="2d1e23b725be8aad6b338015ecefbc3479bf797c" translate="yes" xml:space="preserve">
          <source>J0 returns the order-zero Bessel function of the first kind.</source>
          <target state="translated">J0返回第一种的零阶贝塞尔函数。</target>
        </trans-unit>
        <trans-unit id="9b402d642da0f20c362bc1bcf6bfd3cb9482a1ee" translate="yes" xml:space="preserve">
          <source>J1 returns the order-one Bessel function of the first kind.</source>
          <target state="translated">J1返回第一种类型的阶一贝塞尔函数。</target>
        </trans-unit>
        <trans-unit id="0a183d189787e52c86d1ff01f1f68fc26c61737d" translate="yes" xml:space="preserve">
          <source>JPEG is defined in ITU-T T.81: &lt;a href=&quot;https://www.w3.org/Graphics/JPEG/itu-t81.pdf&quot;&gt;https://www.w3.org/Graphics/JPEG/itu-t81.pdf&lt;/a&gt;.</source>
          <target state="translated">JPEG在ITU-T T.81：&lt;a href=&quot;https://www.w3.org/Graphics/JPEG/itu-t81.pdf&quot;&gt;https&lt;/a&gt;：//www.w3.org/Graphics/JPEG/itu-t81.pdf中定义。</target>
        </trans-unit>
        <trans-unit id="bd49e7822aebcb558798ee4f0f590d63e8da7cc1" translate="yes" xml:space="preserve">
          <source>JPEG, VP8, the MPEG family and other codecs use this color model. Such codecs often use the terms YUV and Y'CbCr interchangeably, but strictly speaking, the term YUV applies only to analog video signals, and Y' (luma) is Y (luminance) after applying gamma correction.</source>
          <target state="translated">JPEG、VP8、MPEG系列和其他编解码器都使用这种颜色模型。这类编解码器经常互换使用YUV和Y'CbCr这两个术语,但严格来说,YUV这个术语只适用于模拟视频信号,而Y'(luma)是应用伽玛校正后的Y(亮度)。</target>
        </trans-unit>
        <trans-unit id="922b9fe605d8db0c621e15bc38a3c570a5ce91fd" translate="yes" xml:space="preserve">
          <source>JS encapsulates a known safe EcmaScript5 Expression, for example, `(x + y * z())`. Template authors are responsible for ensuring that typed expressions do not break the intended precedence and that there is no statement/expression ambiguity as when passing an expression like &quot;{ foo: bar() }\n['foo']()&quot;, which is both a valid Expression and a valid Program with a very different meaning.</source>
          <target state="translated">JS封装了一个已知的安全的EcmaScript5表达式,例如`(x+y*z())`。模板作者有责任确保类型化的表达式不会破坏预期的优先级,也不会出现声明/表达式的歧义,比如传递&quot;{foo:bar()}\n['foo']()&quot;这样的表达式,它既是一个有效的表达式,也是一个有效的程序,但意义却截然不同。</target>
        </trans-unit>
        <trans-unit id="26cbdc0eb97f168871a53f6c7842d5c136b64697" translate="yes" xml:space="preserve">
          <source>JSEscape writes to w the escaped JavaScript equivalent of the plain text data b.</source>
          <target state="translated">JSEscape将明文数据b的转义JavaScript等价物写入w。</target>
        </trans-unit>
        <trans-unit id="bd3faa1039cdd3fc555ce394120927a3ffbfdfd6" translate="yes" xml:space="preserve">
          <source>JSEscapeString returns the escaped JavaScript equivalent of the plain text data s.</source>
          <target state="translated">JSEscapeString返回纯文本数据s的转义JavaScript等价物。</target>
        </trans-unit>
        <trans-unit id="0657ce896f15a5407782a5a0cb9e814dbb9243d9" translate="yes" xml:space="preserve">
          <source>JSEscaper returns the escaped JavaScript equivalent of the textual representation of its arguments.</source>
          <target state="translated">JSEscaper返回其参数的文本表示的转义JavaScript等价物。</target>
        </trans-unit>
        <trans-unit id="3bd554b8109b0533f9a7bb62634a7c4956ea4b3a" translate="yes" xml:space="preserve">
          <source>JSON cannot represent cyclic data structures and Marshal does not handle them. Passing cyclic structures to Marshal will result in an infinite recursion.</source>
          <target state="translated">JSON不能表示循环数据结构,Marshal不能处理它们。将循环结构传递给Marshal会导致无限递归。</target>
        </trans-unit>
        <trans-unit id="16c95a3afe47aa9594cf8938af617a9901298497" translate="yes" xml:space="preserve">
          <source>JSStr encapsulates a sequence of characters meant to be embedded between quotes in a JavaScript expression. The string must match a series of StringCharacters:</source>
          <target state="translated">JSStr封装了一个旨在嵌入到JavaScript表达式中引号之间的字符序列。该字符串必须与一系列StringCharacters匹配。</target>
        </trans-unit>
        <trans-unit id="7ee415a9e606531fbf364133b0de844b1078510a" translate="yes" xml:space="preserve">
          <source>JSValue implements Wrapper interface.</source>
          <target state="translated">JSValue实现了Wrapper接口。</target>
        </trans-unit>
        <trans-unit id="b800dfb6df40a19873f9dc7ec5927a93b2cfe769" translate="yes" xml:space="preserve">
          <source>Jacobi returns the Jacobi symbol (x/y), either +1, -1, or 0. The y argument must be an odd integer.</source>
          <target state="translated">Jacobi返回Jacobi符号(x/y),可以是+1,-1,或0,y参数必须是奇数。</target>
        </trans-unit>
        <trans-unit id="173acb21066734464813cc933e35bf49fb5074d7" translate="yes" xml:space="preserve">
          <source>Jar implements the http.CookieJar interface from the net/http package.</source>
          <target state="translated">Jar实现了net/http包中的http.CookieJar接口。</target>
        </trans-unit>
        <trans-unit id="0a5f33ea0d4d273fa523aad519e0bd5003a1f2a2" translate="yes" xml:space="preserve">
          <source>Jn returns the order-n Bessel function of the first kind.</source>
          <target state="translated">Jn 返回第一种的阶-n Bessel 函数。</target>
        </trans-unit>
        <trans-unit id="e0d73143de80d17e82de2e017ac156ca3b9c4e01" translate="yes" xml:space="preserve">
          <source>Join</source>
          <target state="translated">Join</target>
        </trans-unit>
        <trans-unit id="b160ff3535de402a5c7113020ea1b5b48c93aaa3" translate="yes" xml:space="preserve">
          <source>Join concatenates the elements of a to create a single string. The separator string sep is placed between elements in the resulting string.</source>
          <target state="translated">Join将a中的元素连接起来,创建一个单一的字符串。分隔符sep被放置在字符串中的元素之间。</target>
        </trans-unit>
        <trans-unit id="6badcc1917f6227c17c3b5a3bb3a7ab0dac561dd" translate="yes" xml:space="preserve">
          <source>Join concatenates the elements of s to create a new byte slice. The separator sep is placed between elements in the resulting slice.</source>
          <target state="translated">Join将s的元素连接起来,创建一个新的字节分片。分隔符sep被放置在生成的分片中的元素之间。</target>
        </trans-unit>
        <trans-unit id="aa67e6029ba49c3f992d57c2d0ab202a04ec1080" translate="yes" xml:space="preserve">
          <source>Join joins any number of path elements into a single path, adding a Separator if necessary. Join calls Clean on the result; in particular, all empty strings are ignored. On Windows, the result is a UNC path if and only if the first path element is a UNC path.</source>
          <target state="translated">Join将任意数量的路径元素连接成一个单一的路径,必要时添加一个Separator。Join会对结果进行Clean处理,特别是会忽略所有空字符串。在Windows下,只有当第一个路径元素是UNC路径时,结果才是UNC路径。</target>
        </trans-unit>
        <trans-unit id="945c23e567973c47ce3562fa8cf5ef5f3d5533ea" translate="yes" xml:space="preserve">
          <source>Join joins any number of path elements into a single path, adding a separating slash if necessary. The result is Cleaned; in particular, all empty strings are ignored.</source>
          <target state="translated">Join将任意数量的路径元素连接成一个单一的路径,必要时添加一个分隔线。结果是Cleaned,特别是所有空字符串都会被忽略。</target>
        </trans-unit>
        <trans-unit id="0f25f02ad0ad7ded23a0d09d8ea462e385b6164c" translate="yes" xml:space="preserve">
          <source>JoinHostPort combines host and port into a network address of the form &quot;host:port&quot;. If host contains a colon, as found in literal IPv6 addresses, then JoinHostPort returns &quot;[host]:port&quot;.</source>
          <target state="translated">JoinHostPort 将主机和端口结合成一个 &quot;host:port &quot;形式的网络地址。如果host包含一个冒号,就像在IPv6地址中发现的那样,那么JoinHostPort返回&quot;[host]:port&quot;。</target>
        </trans-unit>
        <trans-unit id="0cf4b24840f4e27435d8326ea5a70f3fed6a3f6e" translate="yes" xml:space="preserve">
          <source>KeepAlive marks its argument as currently reachable. This ensures that the object is not freed, and its finalizer is not run, before the point in the program where KeepAlive is called.</source>
          <target state="translated">KeepAlive把它的参数标记为当前可达。这确保了在程序中调用KeepAlive之前,对象不会被释放,它的终结器也不会被运行。</target>
        </trans-unit>
        <trans-unit id="4901b1829f2829b984a0de81f7472f13edad3727" translate="yes" xml:space="preserve">
          <source>Key returns the key of the iterator's current map entry.</source>
          <target state="translated">Key 返回迭代器当前地图条目的key。</target>
        </trans-unit>
        <trans-unit id="91d7c5c0cb63de8145a0cccf24bc8d2f799ffa8e" translate="yes" xml:space="preserve">
          <source>Key returns the key type of map m.</source>
          <target state="translated">Key返回地图m的键类型。</target>
        </trans-unit>
        <trans-unit id="376426fe335e339ad2d0569150ad1299f858528e" translate="yes" xml:space="preserve">
          <source>KeyUsage represents the set of actions that are valid for a given key. It's a bitmap of the KeyUsage* constants.</source>
          <target state="translated">KeyUsage 表示对给定密钥有效的操作集。它是KeyUsage*常量的位图。</target>
        </trans-unit>
        <trans-unit id="096044ddbad86155a76b804e09110be8b259d0c6" translate="yes" xml:space="preserve">
          <source>KeyValue represents a single entry in a Map.</source>
          <target state="translated">KeyValue代表地图中的一个条目。</target>
        </trans-unit>
        <trans-unit id="054ac770f511da2fe690104026b09ee1f229a5cb" translate="yes" xml:space="preserve">
          <source>Kill causes the Process to exit immediately. Kill does not wait until the Process has actually exited. This only kills the Process itself, not any other processes it may have started.</source>
          <target state="translated">Kill 导致进程立即退出。Kill不会等到进程实际退出。这只杀死进程本身,不杀死它可能已经启动的任何其他进程。</target>
        </trans-unit>
        <trans-unit id="e00ac23f2ac2ff73ad4f3c4b263d6c5bbfb80190" translate="yes" xml:space="preserve">
          <source>Kind</source>
          <target state="translated">Kind</target>
        </trans-unit>
        <trans-unit id="2f96efc28c6a98b35f43fa160b16237570ef8889" translate="yes" xml:space="preserve">
          <source>Kind returns the kind of basic type b.</source>
          <target state="translated">Kind返回基本类型b的种类。</target>
        </trans-unit>
        <trans-unit id="1333bd1a9ccf64ac482cd7154071753a44d2a74b" translate="yes" xml:space="preserve">
          <source>Kind returns the selection kind.</source>
          <target state="translated">Kind返回选择的种类。</target>
        </trans-unit>
        <trans-unit id="1c89bd23580c2ae3925d134637371987fedb05e1" translate="yes" xml:space="preserve">
          <source>Kind returns v's Kind. If v is the zero Value (IsValid returns false), Kind returns Invalid.</source>
          <target state="translated">Kind返回v的Kind。如果v是零值(IsValid返回false),Kind返回Invalid。</target>
        </trans-unit>
        <trans-unit id="069ade3ad94bb7d5e1d27e83fcea3337da44893d" translate="yes" xml:space="preserve">
          <source>Kind specifies the kind of value represented by a Value.</source>
          <target state="translated">Kind指定Value所代表的值的种类。</target>
        </trans-unit>
        <trans-unit id="4774d947be420886f05bc80b8d7b99a878f5521e" translate="yes" xml:space="preserve">
          <source>Known networks are &quot;tcp&quot;, &quot;tcp4&quot; (IPv4-only), &quot;tcp6&quot; (IPv6-only), &quot;udp&quot;, &quot;udp4&quot; (IPv4-only), &quot;udp6&quot; (IPv6-only), &quot;ip&quot;, &quot;ip4&quot; (IPv4-only), &quot;ip6&quot; (IPv6-only), &quot;unix&quot;, &quot;unixgram&quot; and &quot;unixpacket&quot;.</source>
          <target state="translated">已知的网络有 &quot;tcp&quot;、&quot;tcp4&quot;(仅限IPv4)、&quot;tcp6&quot;(仅限IPv6)、&quot;udp&quot;、&quot;udp4&quot;(仅限IPv4)、&quot;udp6&quot;(仅限IPv6)、&quot;ip&quot;、&quot;ip4&quot;(仅限IPv4)、&quot;ip6&quot;(仅限IPv6)、&quot;unix&quot;、&quot;unixgram &quot;和 &quot;unixpacket&quot;。</target>
        </trans-unit>
        <trans-unit id="b8b88dd6dbbf9262e1174af16ab3d22e577d2db5" translate="yes" xml:space="preserve">
          <source>Known options:</source>
          <target state="translated">已知选项:</target>
        </trans-unit>
        <trans-unit id="14eee53dd9c3bca9efa386f9ef53c298322ea056" translate="yes" xml:space="preserve">
          <source>Label returns the value of the label with the given key on ctx, and a boolean indicating whether that label exists.</source>
          <target state="translated">Label 返回ctx上带有给定键的标签的值,以及一个表示该标签是否存在的布尔值。</target>
        </trans-unit>
        <trans-unit id="17f6783a9c705de835debb13cac8a07e2f5a8b94" translate="yes" xml:space="preserve">
          <source>LabelSet is a set of labels.</source>
          <target state="translated">LabelSet是一组标签。</target>
        </trans-unit>
        <trans-unit id="bd752eb91afd54f78c7060bac232ea7dd334932f" translate="yes" xml:space="preserve">
          <source>Labels takes an even number of strings representing key-value pairs and makes a LabelSet containing them. A label overwrites a prior label with the same key. Currently only CPU profile utilizes labels information. See &lt;a href=&quot;https://golang.org/issue/23458&quot;&gt;https://golang.org/issue/23458&lt;/a&gt; for details.</source>
          <target state="translated">标签采用偶数个表示键值对的字符串，并创建一个包含它们的LabelSet。标签会使用相同的密钥覆盖先前的标签。当前，只有CPU配置文件使用标签信息。有关详细信息，请参见&lt;a href=&quot;https://golang.org/issue/23458&quot;&gt;https://golang.org/issue/23458&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c80c2e659a9bc68c02557be9a6c755aeed779cd0" translate="yes" xml:space="preserve">
          <source>LastIndex</source>
          <target state="translated">LastIndex</target>
        </trans-unit>
        <trans-unit id="c2daa604f07bcb24a260e4fea3217009758689c4" translate="yes" xml:space="preserve">
          <source>LastIndex returns the index of the last instance of sep in s, or -1 if sep is not present in s.</source>
          <target state="translated">LastIndex 返回 s 中 sep 的最后一个实例的索引,如果 sep 在 s 中不存在,则返回-1。</target>
        </trans-unit>
        <trans-unit id="b07643ffeaf5942b3f11986d945cbd1ca4dc0db5" translate="yes" xml:space="preserve">
          <source>LastIndex returns the index of the last instance of substr in s, or -1 if substr is not present in s.</source>
          <target state="translated">LastIndex 返回 s 中 substr 的最后一个实例的索引,如果 s 中没有 substr,则返回-1。</target>
        </trans-unit>
        <trans-unit id="a55ae6e0d05b49527c27558955cfb6017a5cb79e" translate="yes" xml:space="preserve">
          <source>LastIndexAny</source>
          <target state="translated">LastIndexAny</target>
        </trans-unit>
        <trans-unit id="c468ec7af80d497e073da5281108fc969df48a62" translate="yes" xml:space="preserve">
          <source>LastIndexAny interprets s as a sequence of UTF-8-encoded Unicode code points. It returns the byte index of the last occurrence in s of any of the Unicode code points in chars. It returns -1 if chars is empty or if there is no code point in common.</source>
          <target state="translated">LastIndexAny将s解释为一个UTF-8编码的Unicode码点序列。它返回在s中最后出现的任何Unicode码点在chars中的字节索引。如果chars为空或者没有共同的码点,它返回-1。</target>
        </trans-unit>
        <trans-unit id="f35ff2cbc15f8519c2de1c522556210dbec6f0d9" translate="yes" xml:space="preserve">
          <source>LastIndexAny returns the index of the last instance of any Unicode code point from chars in s, or -1 if no Unicode code point from chars is present in s.</source>
          <target state="translated">LastIndexAny返回s中任何来自chars的Unicode码点的最后一个实例的索引,如果s中没有来自chars的Unicode码点,则返回-1。</target>
        </trans-unit>
        <trans-unit id="e5af45bb29df606a6ad9f71c5f8ffe801cf806e3" translate="yes" xml:space="preserve">
          <source>LastIndexByte</source>
          <target state="translated">LastIndexByte</target>
        </trans-unit>
        <trans-unit id="715ec7346f22f455ae3b4f77928429d6e6ea2e7d" translate="yes" xml:space="preserve">
          <source>LastIndexByte returns the index of the last instance of c in s, or -1 if c is not present in s.</source>
          <target state="translated">LastIndexByte返回s中c的最后一个实例的索引,如果s中没有c,则返回-1。</target>
        </trans-unit>
        <trans-unit id="0052a6c35642a0a5651d0e514c35ebcc1b001ad3" translate="yes" xml:space="preserve">
          <source>LastIndexFunc</source>
          <target state="translated">LastIndexFunc</target>
        </trans-unit>
        <trans-unit id="e9e6d245d6f60be69d3deb822ef844937727defc" translate="yes" xml:space="preserve">
          <source>LastIndexFunc interprets s as a sequence of UTF-8-encoded code points. It returns the byte index in s of the last Unicode code point satisfying f(c), or -1 if none do.</source>
          <target state="translated">LastIndexFunc 将 s 解释为一个 UTF-8 编码的码点序列。它返回s中最后一个满足f(c)的Unicode码点的字节索引,如果没有,则返回-1。</target>
        </trans-unit>
        <trans-unit id="573828a944fe303002f7c0336cac457a4d45085f" translate="yes" xml:space="preserve">
          <source>LastIndexFunc returns the index into s of the last Unicode code point satisfying f(c), or -1 if none do.</source>
          <target state="translated">LastIndexFunc 返回最后一个满足 f(c)的 Unicode 码点在 s 中的索引,如果没有,则返回 -1。</target>
        </trans-unit>
        <trans-unit id="cdb76fffe46f91856747d3f589e0a3ea42a00f8c" translate="yes" xml:space="preserve">
          <source>Lchown changes the numeric uid and gid of the named file. If the file is a symbolic link, it changes the uid and gid of the link itself. If there is an error, it will be of type *PathError.</source>
          <target state="translated">Lchown 改变了命名文件的数字 uid 和 gid。如果文件是一个符号链接,则改变链接本身的 uid 和 gid。如果有一个错误,它的类型将是*PathError。</target>
        </trans-unit>
        <trans-unit id="9f1275e6821f8a51315e2ca81450b41140587c42" translate="yes" xml:space="preserve">
          <source>Ldexp is the inverse of Frexp. It returns frac &amp;times; 2**exp.</source>
          <target state="translated">Ldexp与Frexp相反。它返回frac&amp;times;2 ** exp。</target>
        </trans-unit>
        <trans-unit id="0bfbea9fa1b1bd75227de20412ea5faba23da169" translate="yes" xml:space="preserve">
          <source>LeadingZeros returns the number of leading zero bits in x; the result is UintSize for x == 0.</source>
          <target state="translated">LeadingZeros 返回 x 中的前导零位数;对于 x ==0,结果是 UintSize。</target>
        </trans-unit>
        <trans-unit id="e3dbef4bbdf5cce299ff063f0c95032879c3da58" translate="yes" xml:space="preserve">
          <source>LeadingZeros16</source>
          <target state="translated">LeadingZeros16</target>
        </trans-unit>
        <trans-unit id="44f8376c5ec759270046aff7d8e5b19117ded5c1" translate="yes" xml:space="preserve">
          <source>LeadingZeros16 returns the number of leading zero bits in x; the result is 16 for x == 0.</source>
          <target state="translated">LeadingZeros16返回x中的前导零位数;对于x==0,结果是16。</target>
        </trans-unit>
        <trans-unit id="e9ed6b4c7187930afe2c50c883fcac4812515684" translate="yes" xml:space="preserve">
          <source>LeadingZeros32</source>
          <target state="translated">LeadingZeros32</target>
        </trans-unit>
        <trans-unit id="d0f408a69a9bfc0c9d5428df849a3e3f9c88b61c" translate="yes" xml:space="preserve">
          <source>LeadingZeros32 returns the number of leading zero bits in x; the result is 32 for x == 0.</source>
          <target state="translated">LeadingZeros32返回x中的前导零位数;对于x==0,结果是32。</target>
        </trans-unit>
        <trans-unit id="f987ddc8abdaac6d127e5eafa8b11404f85e5b1a" translate="yes" xml:space="preserve">
          <source>LeadingZeros64</source>
          <target state="translated">LeadingZeros64</target>
        </trans-unit>
        <trans-unit id="fda83273480c3e8d70a28c2f123cbf299bd51fd9" translate="yes" xml:space="preserve">
          <source>LeadingZeros64 returns the number of leading zero bits in x; the result is 64 for x == 0.</source>
          <target state="translated">LeadingZeros64 返回 x 中的前导零位数;对于 x ==0,结果是 64。</target>
        </trans-unit>
        <trans-unit id="fda98988d92b8709dacc15db674b3e6e61682f64" translate="yes" xml:space="preserve">
          <source>LeadingZeros8</source>
          <target state="translated">LeadingZeros8</target>
        </trans-unit>
        <trans-unit id="d8a16180e08b654e4c4467808de5826069ff567a" translate="yes" xml:space="preserve">
          <source>LeadingZeros8 returns the number of leading zero bits in x; the result is 8 for x == 0.</source>
          <target state="translated">LeadingZeros8返回x中的前导零位数;对于x==0,结果是8。</target>
        </trans-unit>
        <trans-unit id="721bda08d146a886975a86dd204cbec756066f9e" translate="yes" xml:space="preserve">
          <source>Least Surprise Property: &quot;A developer (or code reviewer) familiar with HTML, CSS, and JavaScript, who knows that contextual autoescaping happens should be able to look at a {{.}} and correctly infer what sanitization happens.&quot;</source>
          <target state="translated">最不意外的属性。&quot;一个熟悉HTML、CSS和JavaScript的开发者(或代码审查员),如果知道上下文自动套用的发生,应该能够看到{{.}},并正确推断出发生了什么消毒。&quot;</target>
        </trans-unit>
        <trans-unit id="8d92112ff544a635650fbaf730715150d27bea5c" translate="yes" xml:space="preserve">
          <source>Len computes the number of elements in ring r. It executes in time proportional to the number of elements.</source>
          <target state="translated">Len计算环r中的元素数,它的执行时间与元素数成正比。</target>
        </trans-unit>
        <trans-unit id="1399044ec4cebde1e345bfb6e7bc0665028c448d" translate="yes" xml:space="preserve">
          <source>Len returns the length of array a. A negative result indicates an unknown length.</source>
          <target state="translated">Len返回数组a的长度,负值表示未知长度。</target>
        </trans-unit>
        <trans-unit id="93ef3e242273d75e5bb1dbc766c5fd7830570833" translate="yes" xml:space="preserve">
          <source>Len returns the minimum number of bits required to represent x; the result is 0 for x == 0.</source>
          <target state="translated">Len返回表示x所需的最小位数;对于x==0,结果为0。</target>
        </trans-unit>
        <trans-unit id="ca5afaea7adacd073486db0f70027386a60f94b6" translate="yes" xml:space="preserve">
          <source>Len returns the number of accumulated bytes; b.Len() == len(b.String()).</source>
          <target state="translated">Len返回累计的字节数;b.Len()==len(b.String())。</target>
        </trans-unit>
        <trans-unit id="ee2f279ceb0f8a58afdf88fefe8cee3f9c31fa50" translate="yes" xml:space="preserve">
          <source>Len returns the number of bytes of the unread portion of the buffer; b.Len() == len(b.Bytes()).</source>
          <target state="translated">Len返回缓冲区未读部分的字节数;b.Len()==len(b.Bytes())。</target>
        </trans-unit>
        <trans-unit id="67467f9c2f5df39d1ac34826fd0579c560dedb06" translate="yes" xml:space="preserve">
          <source>Len returns the number of bytes of the unread portion of the slice.</source>
          <target state="translated">Len返回分片中未读部分的字节数。</target>
        </trans-unit>
        <trans-unit id="9a34422a61609509fefc4a297f2f9c07ff69ccf9" translate="yes" xml:space="preserve">
          <source>Len returns the number of bytes of the unread portion of the string.</source>
          <target state="translated">Len返回字符串中未读部分的字节数。</target>
        </trans-unit>
        <trans-unit id="be3ac6245438d5424b518ab2335163e6f1965692" translate="yes" xml:space="preserve">
          <source>Len returns the number of elements of list l. The complexity is O(1).</source>
          <target state="translated">Len返回列表l的元素数,复杂度为O(1)。</target>
        </trans-unit>
        <trans-unit id="a7b0b1334a129ccc7a0e235fc902ddfdb01aa234" translate="yes" xml:space="preserve">
          <source>Len returns the number of methods in s.</source>
          <target state="translated">Len返回s中方法的数量。</target>
        </trans-unit>
        <trans-unit id="9909b01102ccbea5c34e603dc1a8df16cade5eea" translate="yes" xml:space="preserve">
          <source>Len returns the number of scope elements.</source>
          <target state="translated">Len返回范围元素的数量。</target>
        </trans-unit>
        <trans-unit id="8315c44360f57db88aab9b44a76e81307e540e3a" translate="yes" xml:space="preserve">
          <source>Len returns the number variables of tuple t.</source>
          <target state="translated">Len返回元组t的数量变量。</target>
        </trans-unit>
        <trans-unit id="ca8349640e110d5798f69868438b094ed5d5cb6c" translate="yes" xml:space="preserve">
          <source>Len returns v's length. It panics if v's Kind is not Array, Chan, Map, Slice, or String.</source>
          <target state="translated">Len返回v的长度。如果v的Kind不是Array、Chan、Map、Slice或String,它就会恐慌。</target>
        </trans-unit>
        <trans-unit id="b58611e03df383dbaa4dc9ba6fd2e4a6b8e52327" translate="yes" xml:space="preserve">
          <source>Len16</source>
          <target state="translated">Len16</target>
        </trans-unit>
        <trans-unit id="f5e60795826c955dcfd526c1230894564783d120" translate="yes" xml:space="preserve">
          <source>Len16 returns the minimum number of bits required to represent x; the result is 0 for x == 0.</source>
          <target state="translated">Len16返回表示x所需的最小位数,x==0时结果为0。</target>
        </trans-unit>
        <trans-unit id="76efc8ef8d6465f58231c9d295309a299f1d8534" translate="yes" xml:space="preserve">
          <source>Len32</source>
          <target state="translated">Len32</target>
        </trans-unit>
        <trans-unit id="2bdd325b510dd0548fcbb4a4b3c4d52a4f66d711" translate="yes" xml:space="preserve">
          <source>Len32 returns the minimum number of bits required to represent x; the result is 0 for x == 0.</source>
          <target state="translated">Len32返回表示x所需的最小位数,x==0时结果为0。</target>
        </trans-unit>
        <trans-unit id="5bed2d704a16234c65f3795d3067f97369c94923" translate="yes" xml:space="preserve">
          <source>Len64</source>
          <target state="translated">Len64</target>
        </trans-unit>
        <trans-unit id="67dd373d63df43f7c3cfe611f388cdd1def82589" translate="yes" xml:space="preserve">
          <source>Len64 returns the minimum number of bits required to represent x; the result is 0 for x == 0.</source>
          <target state="translated">Len64返回表示x所需的最小位数,x==0时结果为0。</target>
        </trans-unit>
        <trans-unit id="5877dcf480cd63f747b4cd7b2e4473a4fb01962a" translate="yes" xml:space="preserve">
          <source>Len8</source>
          <target state="translated">Len8</target>
        </trans-unit>
        <trans-unit id="ead2ce671d2982c7db8677f2bb62a7b4fdd9a8e8" translate="yes" xml:space="preserve">
          <source>Len8 returns the minimum number of bits required to represent x; the result is 0 for x == 0.</source>
          <target state="translated">Len8返回表示x所需的最小位数,x==0时结果为0。</target>
        </trans-unit>
        <trans-unit id="2981abdd30fd95f0ea0e0799884f920048d0fba8" translate="yes" xml:space="preserve">
          <source>Length returns the JavaScript property &quot;length&quot; of v. It panics if v is not a JavaScript object.</source>
          <target state="translated">Length返回v的JavaScript属性 &quot;length&quot;,如果v不是JavaScript对象,它就会恐慌。</target>
        </trans-unit>
        <trans-unit id="f0f51015552f0c7df8f3dcfecc5c896adfb05b7f" translate="yes" xml:space="preserve">
          <source>Length returns the column type length for variable length column types such as text and binary field types. If the type length is unbounded the value will be math.MaxInt64 (any database limits will still apply). If the column type is not variable length, such as an int, or if not supported by the driver ok is false.</source>
          <target state="translated">Length 返回可变长度列类型(如文本和二进制字段类型)的列类型长度。如果类型长度是无限制的,那么该值将是math.MaxInt64(任何数据库限制仍然适用)。如果列类型不是可变长度的,例如int,或者如果驱动程序不支持,ok为false。</target>
        </trans-unit>
        <trans-unit id="7467b2c9a7e459bce96e4603f4b9c0fecbbea6e6" translate="yes" xml:space="preserve">
          <source>Lgamma returns the natural logarithm and sign (-1 or +1) of Gamma(x).</source>
          <target state="translated">Lgamma返回Gamma(x)的自然对数和符号(-1或+1)。</target>
        </trans-unit>
        <trans-unit id="7db120ff0add5b38c6339cbb76ef30243d16848f" translate="yes" xml:space="preserve">
          <source>Licensed under the Creative Commons Attribution License 3.0.</source>
          <target state="translated">根据知识共享署名协议3.0许可。</target>
        </trans-unit>
        <trans-unit id="7d9d345bfff5b874e03396293193a78237bde2df" translate="yes" xml:space="preserve">
          <source>Like Scanf and Fscanf, Sscanf need not consume its entire input. There is no way to recover how much of the input string Sscanf used.</source>
          <target state="translated">像Scanf和Fscanf一样,Sscanf不需要消耗整个输入。没有办法恢复Sscanf使用了多少输入字符串。</target>
        </trans-unit>
        <trans-unit id="7e1cb140c6b5c5e4e4aa15375a7a581d31852d58" translate="yes" xml:space="preserve">
          <source>Like in tests, benchmark logs are accumulated during execution and dumped to standard error when done. Unlike in tests, benchmark logs are always printed, so as not to hide output whose existence may be affecting benchmark results.</source>
          <target state="translated">与测试中一样,基准日志在执行过程中被累积,并在完成后转储到标准误差。与测试中不同的是,基准日志总是被打印出来,这样就不会隐藏那些可能影响基准结果的输出。</target>
        </trans-unit>
        <trans-unit id="64d7a9c098ae2cc78ad63fdda4f717ce942dd2cc" translate="yes" xml:space="preserve">
          <source>Like the RoundTripper interface, the error types returned by RoundTrip are unspecified.</source>
          <target state="translated">和RoundTripper接口一样,RoundTrip返回的错误类型也是不指定的。</target>
        </trans-unit>
        <trans-unit id="8c3e2cc8bde5ef9c910164a74c49f21b4ecb6bc1" translate="yes" xml:space="preserve">
          <source>LimitReader</source>
          <target state="translated">LimitReader</target>
        </trans-unit>
        <trans-unit id="82f17ce7a899200e83a237fbfff2e0aec18adc46" translate="yes" xml:space="preserve">
          <source>LimitReader returns a Reader that reads from r but stops with EOF after n bytes. The underlying implementation is a *LimitedReader.</source>
          <target state="translated">LimitReader返回一个从r读取但在n个字节后以EOF停止的Reader。底层实现是一个*LimitedReader。</target>
        </trans-unit>
        <trans-unit id="dfc4ccc73713d6d0c21377e9d4eb82cf06cf9ec2" translate="yes" xml:space="preserve">
          <source>Line returns the line number for the given file position p; p must be a Pos value in that file or NoPos.</source>
          <target state="translated">Line返回给定文件位置p的行号;p必须是该文件中的Pos值或NoPos。</target>
        </trans-unit>
        <trans-unit id="c80f69f5d4f28c6e33fd6610f08a1143f38de111" translate="yes" xml:space="preserve">
          <source>LineCount returns the number of lines in file f.</source>
          <target state="translated">LineCount 返回文件 f 中的行数。</target>
        </trans-unit>
        <trans-unit id="8021239ce81a740af9d1126d1dcb955373ee8d6d" translate="yes" xml:space="preserve">
          <source>LineReader returns a new reader for the line table of compilation unit cu, which must be an Entry with tag TagCompileUnit.</source>
          <target state="translated">LineReader 返回一个新的编译单元 cu 的行表阅读器,它必须是一个带有 TagCompileUnit 标签的条目。</target>
        </trans-unit>
        <trans-unit id="d6e6998fd35451f00c85f965d2d22dc96e7bd958" translate="yes" xml:space="preserve">
          <source>LineStart returns the Pos value of the start of the specified line. It ignores any alternative positions set using AddLineColumnInfo. LineStart panics if the 1-based line number is invalid.</source>
          <target state="translated">LineStart 返回指定行的起始位置的 Pos 值。它忽略任何使用AddLineColumnInfo设置的替代位置。如果以1为基准的行号无效,LineStart会感到恐慌。</target>
        </trans-unit>
        <trans-unit id="4776e3cbe12ee14e372370ae9f2a2f5ec9999059" translate="yes" xml:space="preserve">
          <source>LineToPC looks up the first program counter on the given line in the named file. It returns UnknownPathError or UnknownLineError if there is an error looking up this line.</source>
          <target state="translated">LineToPC在给定的文件行中查找第一个程序计数器。如果这一行出现错误,它将返回 UnknownPathError 或 UnknownLineError。</target>
        </trans-unit>
        <trans-unit id="e41c87878f5ec2dd68efcc90f4932d27c2b8d1c2" translate="yes" xml:space="preserve">
          <source>LineToPC returns the program counter for the given line number, considering only program counters before maxpc.</source>
          <target state="translated">LineToPC返回给定行号的程序计数器,只考虑maxpc之前的程序计数器。</target>
        </trans-unit>
        <trans-unit id="d3ece36672b155d5080f24d88b4ef4dc56af15c6" translate="yes" xml:space="preserve">
          <source>Link connects ring r with ring s such that r.Next() becomes s and returns the original value for r.Next(). r must not be empty.</source>
          <target state="translated">Link连接环r和环s,使r.Next()变成s,并返回r.Next()的原始值。r不能为空。</target>
        </trans-unit>
        <trans-unit id="61bc01a247b2210bb40d4dab78269bb633df6036" translate="yes" xml:space="preserve">
          <source>Link creates newname as a hard link to the oldname file. If there is an error, it will be of type *LinkError.</source>
          <target state="translated">Link创建newname作为旧名文件的硬链接。如果出现错误,它的类型将是*LinkError。</target>
        </trans-unit>
        <trans-unit id="8c53bb40a220e2f4f66bfd2012a9dda9a12bc64f" translate="yes" xml:space="preserve">
          <source>LinkError records an error during a link or symlink or rename system call and the paths that caused it.</source>
          <target state="translated">LinkError记录了系统调用链接、symlink或重命名过程中的错误,以及导致该错误的路径。</target>
        </trans-unit>
        <trans-unit id="2ca439921c0481dec50573fdcf5a08b538a5f2a3" translate="yes" xml:space="preserve">
          <source>List represents a doubly linked list. The zero value for List is an empty list ready to use.</source>
          <target state="translated">List代表一个双链路的列表。List的零值是一个准备使用的空列表。</target>
        </trans-unit>
        <trans-unit id="ed96ea56ffbf3b559f9c41465dc17435379898fd" translate="yes" xml:space="preserve">
          <source>ListNode holds a sequence of nodes.</source>
          <target state="translated">ListNode持有一个节点序列。</target>
        </trans-unit>
        <trans-unit id="ca24c0263416d5489002e073f3f7f972b1a2c801" translate="yes" xml:space="preserve">
          <source>Listen announces on the local network address.</source>
          <target state="translated">听听在本地网络地址上宣布。</target>
        </trans-unit>
        <trans-unit id="fbc501a375c74f3f294816964a99702dd99275fe" translate="yes" xml:space="preserve">
          <source>Listen creates a TLS listener accepting connections on the given network address using net.Listen. The configuration config must be non-nil and must include at least one certificate or else set GetCertificate.</source>
          <target state="translated">Listen使用net.Listen创建一个TLS监听器,接受给定网络地址上的连接。配置配置必须为非零,并且必须包含至少一个证书,否则设置GetCertificate。</target>
        </trans-unit>
        <trans-unit id="6c1bd8cd11c9c376470f7f547014d7596b4d2372" translate="yes" xml:space="preserve">
          <source>ListenAndServe</source>
          <target state="translated">ListenAndServe</target>
        </trans-unit>
        <trans-unit id="ca4b599f82e29135dc1efc68105574de3edf6ae1" translate="yes" xml:space="preserve">
          <source>ListenAndServe always returns a non-nil error.</source>
          <target state="translated">ListenAndServe总是返回一个非零的错误。</target>
        </trans-unit>
        <trans-unit id="5dd294a2ba295a8af34a90f46a25099808a8e7bb" translate="yes" xml:space="preserve">
          <source>ListenAndServe always returns a non-nil error. After Shutdown or Close, the returned error is ErrServerClosed.</source>
          <target state="translated">ListenAndServe总是返回一个非零的错误。关机或关闭后,返回的错误是ErrServerClosed。</target>
        </trans-unit>
        <trans-unit id="0e017d6f66fb57e5159203491154acdfd7f3155e" translate="yes" xml:space="preserve">
          <source>ListenAndServe listens on the TCP network address addr and then calls Serve with handler to handle requests on incoming connections. Accepted connections are configured to enable TCP keep-alives.</source>
          <target state="translated">ListenAndServe对TCP网络地址addr进行监听,然后用handler调用Serve来处理传入连接的请求。接受的连接被配置为启用TCP keep-alives。</target>
        </trans-unit>
        <trans-unit id="1eb6871fd885bb71d1764b988ed8e0b1207dbd10" translate="yes" xml:space="preserve">
          <source>ListenAndServe listens on the TCP network address srv.Addr and then calls Serve to handle requests on incoming connections. Accepted connections are configured to enable TCP keep-alives.</source>
          <target state="translated">ListenAndServe监听TCP网络地址srv.Addr,然后调用Serve处理传入连接的请求。已接受的连接被配置为启用TCP keep-alives。</target>
        </trans-unit>
        <trans-unit id="f672409681724db7975a81f059dabf70eb0a6552" translate="yes" xml:space="preserve">
          <source>ListenAndServe starts an HTTP server with a given address and handler. The handler is usually nil, which means to use DefaultServeMux. Handle and HandleFunc add handlers to DefaultServeMux:</source>
          <target state="translated">ListenAndServe用一个给定的地址和处理程序启动一个HTTP服务器,处理程序通常为nil,这意味着使用DefaultServeMux。处理程序通常是nil,这意味着要使用DefaultServeMux。Handle和HandleFunc向DefaultServeMux添加处理程序。</target>
        </trans-unit>
        <trans-unit id="b1444c4d4c91aea2ff2c287b0f4c6b6c33effbc6" translate="yes" xml:space="preserve">
          <source>ListenAndServeTLS</source>
          <target state="translated">ListenAndServeTLS</target>
        </trans-unit>
        <trans-unit id="4b13ffad776ec4c1e6e622baa48939390c7f43be" translate="yes" xml:space="preserve">
          <source>ListenAndServeTLS acts identically to ListenAndServe, except that it expects HTTPS connections. Additionally, files containing a certificate and matching private key for the server must be provided. If the certificate is signed by a certificate authority, the certFile should be the concatenation of the server's certificate, any intermediates, and the CA's certificate.</source>
          <target state="translated">ListenAndServeTLS的作用与ListenAndServe相同,只是它期望HTTPS连接。此外,必须提供包含服务器的证书和匹配的私钥的文件。如果证书是由证书颁发机构签署的,那么certFile应该是服务器的证书、任何中介机构和CA的证书的连接。</target>
        </trans-unit>
        <trans-unit id="e993bc61c7cd05bdd6aa504a7bf534f06ff70ebd" translate="yes" xml:space="preserve">
          <source>ListenAndServeTLS always returns a non-nil error. After Shutdown or Close, the returned error is ErrServerClosed.</source>
          <target state="translated">ListenAndServeTLS总是返回一个非零的错误。关机或关闭后,返回的错误是ErrServerClosed。</target>
        </trans-unit>
        <trans-unit id="4de6956912052ccb175eeb5c4727583b8c87a58f" translate="yes" xml:space="preserve">
          <source>ListenAndServeTLS listens on the TCP network address srv.Addr and then calls ServeTLS to handle requests on incoming TLS connections. Accepted connections are configured to enable TCP keep-alives.</source>
          <target state="translated">ListenAndServeTLS监听TCP网络地址srv.Addr,然后调用ServeTLS来处理传入的TLS连接的请求。接受的连接被配置为启用TCP keep-alives。</target>
        </trans-unit>
        <trans-unit id="2ef32140a96f71533a922e8af1a4a1287b2aa08c" translate="yes" xml:space="preserve">
          <source>ListenConfig contains options for listening to an address.</source>
          <target state="translated">ListenConfig包含监听地址的选项。</target>
        </trans-unit>
        <trans-unit id="56e637fe09ab78156ad9d4b14c696af0fcd5c313" translate="yes" xml:space="preserve">
          <source>ListenIP acts like ListenPacket for IP networks.</source>
          <target state="translated">ListenIP的作用类似于IP网络的ListenPacket。</target>
        </trans-unit>
        <trans-unit id="f21580354d675fc10d1e9ee1c4db6486064ec455" translate="yes" xml:space="preserve">
          <source>ListenMulticastUDP acts like ListenPacket for UDP networks but takes a group address on a specific network interface.</source>
          <target state="translated">ListenMulticastUDP的作用类似于UDP网络的ListenPacket,但在特定的网络接口上取一个组地址。</target>
        </trans-unit>
        <trans-unit id="867f2d87132f64efe5f8f6f86d2c98549b471fdb" translate="yes" xml:space="preserve">
          <source>ListenMulticastUDP is just for convenience of simple, small applications. There are golang.org/x/net/ipv4 and golang.org/x/net/ipv6 packages for general purpose uses.</source>
          <target state="translated">ListenMulticastUDP只是为了方便简单的小型应用。有golang.org/x/net/ipv4和golang.org/x/net/ipv6包供通用。</target>
        </trans-unit>
        <trans-unit id="bd5f6e57a541e39939141511f957be405b380471" translate="yes" xml:space="preserve">
          <source>ListenMulticastUDP listens on all available IP addresses of the local system including the group, multicast IP address. If ifi is nil, ListenMulticastUDP uses the system-assigned multicast interface, although this is not recommended because the assignment depends on platforms and sometimes it might require routing configuration. If the Port field of gaddr is 0, a port number is automatically chosen.</source>
          <target state="translated">ListenMulticastUDP监听本地系统的所有可用IP地址,包括组、组播IP地址。如果i为nil,ListenMulticastUDP使用系统分配的组播接口,不过不建议这样做,因为分配取决于平台,有时可能需要进行路由配置。如果gaddr的Port字段为0,则会自动选择一个端口号。</target>
        </trans-unit>
        <trans-unit id="468da55aa49f2b551af4d2ec242f5d19018b56ca" translate="yes" xml:space="preserve">
          <source>ListenPacket announces on the local network address.</source>
          <target state="translated">ListenPacket在本地网络地址上宣布。</target>
        </trans-unit>
        <trans-unit id="df604088a8b978cdce196e569a7b165e976e6869" translate="yes" xml:space="preserve">
          <source>ListenTCP acts like Listen for TCP networks.</source>
          <target state="translated">ListenTCP的作用类似于TCP网络的Listen。</target>
        </trans-unit>
        <trans-unit id="9851cfe87c5b9ef168f40038c7d75b3a82ee3529" translate="yes" xml:space="preserve">
          <source>ListenUDP acts like ListenPacket for UDP networks.</source>
          <target state="translated">ListenUDP的作用类似于UDP网络的ListenPacket。</target>
        </trans-unit>
        <trans-unit id="5b7757b4611e8ba6d66b663a1f48d50bfcf3ecc4" translate="yes" xml:space="preserve">
          <source>ListenUnix acts like Listen for Unix networks.</source>
          <target state="translated">ListenUnix的作用就像Unix网络的Listen。</target>
        </trans-unit>
        <trans-unit id="df0abb591dbf2fca4d32aeb087ddbb3eb5bf7905" translate="yes" xml:space="preserve">
          <source>ListenUnixgram acts like ListenPacket for Unix networks.</source>
          <target state="translated">ListenUnixgram的作用类似于Unix网络的ListenPacket。</target>
        </trans-unit>
        <trans-unit id="37ea46b5942beaeb21bb4e06a14e4f7232d2a1b0" translate="yes" xml:space="preserve">
          <source>Listener</source>
          <target state="translated">Listener</target>
        </trans-unit>
        <trans-unit id="0391fe0f913571d2818f72cca0ff528d31c4414b" translate="yes" xml:space="preserve">
          <source>LiteralPrefix returns a literal string that must begin any match of the regular expression re. It returns the boolean true if the literal string comprises the entire regular expression.</source>
          <target state="translated">LiteralPrefix 返回一个必须在正则表达式 re 的任何匹配开始的字词串,如果字词串包含整个正则表达式,则返回布尔值 true。</target>
        </trans-unit>
        <trans-unit id="ecdd85ee0de784370070e365d9f936724803e148" translate="yes" xml:space="preserve">
          <source>LittleEndian is the little-endian implementation of ByteOrder.</source>
          <target state="translated">LittleEndian是ByteOrder的little-endian实现。</target>
        </trans-unit>
        <trans-unit id="d5ae70e267716ec3e2a976b68757e30ee0e214a8" translate="yes" xml:space="preserve">
          <source>Load returns the value set by the most recent Store. It returns nil if there has been no call to Store for this Value.</source>
          <target state="translated">Load返回最近一次Store设置的值。如果没有调用过该值的Store,则返回nil。</target>
        </trans-unit>
        <trans-unit id="74c5a2d6710e8b201a98f6c2837198f613eec0fa" translate="yes" xml:space="preserve">
          <source>Load returns the value stored in the map for a key, or nil if no value is present. The ok result indicates whether value was found in the map.</source>
          <target state="translated">Load返回存储在地图中的键值,如果没有键值,则返回nil。ok的结果表示是否在地图中找到了值。</target>
        </trans-unit>
        <trans-unit id="881052b1a20f63445e79814467ecdb5374883ab0" translate="yes" xml:space="preserve">
          <source>LoadInt32 atomically loads *addr.</source>
          <target state="translated">LoadInt32原子地加载*addr.</target>
        </trans-unit>
        <trans-unit id="2ac3794cf69cbb4165a4ee85d8ea313e85610e69" translate="yes" xml:space="preserve">
          <source>LoadInt64 atomically loads *addr.</source>
          <target state="translated">LoadInt64原子地加载*addr.</target>
        </trans-unit>
        <trans-unit id="3cd00c96c1dde37f4e165d9dd83f094e52c09c97" translate="yes" xml:space="preserve">
          <source>LoadLocation</source>
          <target state="translated">LoadLocation</target>
        </trans-unit>
        <trans-unit id="942c4e15f8861257bc29d285e307a9855ad8da88" translate="yes" xml:space="preserve">
          <source>LoadLocation returns the Location with the given name.</source>
          <target state="translated">LoadLocation 返回给定名称的位置。</target>
        </trans-unit>
        <trans-unit id="452c7f6aa0b947a115cd7ebee668ccabc28767f6" translate="yes" xml:space="preserve">
          <source>LoadLocationFromTZData returns a Location with the given name initialized from the IANA Time Zone database-formatted data. The data should be in the format of a standard IANA time zone file (for example, the content of /etc/localtime on Unix systems).</source>
          <target state="translated">LoadLocationFromTZData从IANA时区数据库格式化的数据中返回一个具有给定名称初始化的位置。这些数据应该是标准IANA时区文件的格式(例如,Unix系统中的/etc/localtime的内容)。</target>
        </trans-unit>
        <trans-unit id="730b9fd8d031760ad2f11544687c7f3a4c32ba10" translate="yes" xml:space="preserve">
          <source>LoadOrStore returns the existing value for the key if present. Otherwise, it stores and returns the given value. The loaded result is true if the value was loaded, false if stored.</source>
          <target state="translated">LoadOrStore返回键的现有值(如果存在)。否则,它将存储并返回给定的值。如果值被加载,则加载的结果为true,如果被存储,则返回false。</target>
        </trans-unit>
        <trans-unit id="16e5531718ad0441ff996bffe1bdb2f9013072b8" translate="yes" xml:space="preserve">
          <source>LoadPointer atomically loads *addr.</source>
          <target state="translated">LoadPointer原子地加载*addr.</target>
        </trans-unit>
        <trans-unit id="3a58860dce2950635c9b0aec0356bd0e023fcd4b" translate="yes" xml:space="preserve">
          <source>LoadUint32 atomically loads *addr.</source>
          <target state="translated">LoadUint32原子地加载*addr。</target>
        </trans-unit>
        <trans-unit id="ed4689d0f224e4c5a01ae1b69433a91e9f118b20" translate="yes" xml:space="preserve">
          <source>LoadUint64 atomically loads *addr.</source>
          <target state="translated">LoadUint64原子地加载*addr.</target>
        </trans-unit>
        <trans-unit id="9cfbde985c4614b9808e9de0d65afb5568c9c53d" translate="yes" xml:space="preserve">
          <source>LoadUintptr atomically loads *addr.</source>
          <target state="translated">LoadUintptr原子地加载*addr.</target>
        </trans-unit>
        <trans-unit id="e85b79501e4b543de03554e2a29fd9cbd965ec40" translate="yes" xml:space="preserve">
          <source>LoadX509KeyPair</source>
          <target state="translated">LoadX509KeyPair</target>
        </trans-unit>
        <trans-unit id="45fae6424c26a4b8eb19ae242ef820e6061dab08" translate="yes" xml:space="preserve">
          <source>LoadX509KeyPair reads and parses a public/private key pair from a pair of files. The files must contain PEM encoded data. The certificate file may contain intermediate certificates following the leaf certificate to form a certificate chain. On successful return, Certificate.Leaf will be nil because the parsed form of the certificate is not retained.</source>
          <target state="translated">LoadX509KeyPair从一对文件中读取并解析一对公钥/私钥。文件必须包含PEM编码的数据。证书文件可以包含叶子证书之后的中间证书,以形成一个证书链。当成功返回时,Certificate.Leaf将为零,因为证书的解析形式不会被保留。</target>
        </trans-unit>
        <trans-unit id="1da25ed4d4f6ff8e68f5335ba8ba070399bd7f5f" translate="yes" xml:space="preserve">
          <source>Local represents the system's local time zone.</source>
          <target state="translated">本地代表系统的本地时区。</target>
        </trans-unit>
        <trans-unit id="bd6d294473bbbfce0d1197b903b10c86fb6c3b7b" translate="yes" xml:space="preserve">
          <source>Local returns t with the location set to local time.</source>
          <target state="translated">Local返回t,并将位置设置为当地时间。</target>
        </trans-unit>
        <trans-unit id="4a5ab837cb8b234abbab484d911af5705d613e13" translate="yes" xml:space="preserve">
          <source>LocalAddr returns the local network address.</source>
          <target state="translated">LocalAddr 返回本地网络地址。</target>
        </trans-unit>
        <trans-unit id="c10eb870360e8baad53b9b506e944815aa5896df" translate="yes" xml:space="preserve">
          <source>LocalAddr returns the local network address. The Addr returned is shared by all invocations of LocalAddr, so do not modify it.</source>
          <target state="translated">LocalAddr返回本地网络地址。返回的Addr是所有调用LocalAddr的次数所共享的,所以不要修改它。</target>
        </trans-unit>
        <trans-unit id="238b4cd4fe464f99416bb574ab9c5c6651970ad5" translate="yes" xml:space="preserve">
          <source>LocalhostCert is a PEM-encoded TLS cert with SAN IPs &quot;127.0.0.1&quot; and &quot;[::1]&quot;, expiring at Jan 29 16:00:00 2084 GMT. generated from src/crypto/tls: go run generate_cert.go --rsa-bits 1024 --host 127.0.0.1,::1,example.com --ca --start-date &quot;Jan 1 00:00:00 1970&quot; --duration=1000000h</source>
          <target state="translated">LocalhostCert是一个PEM编码的TLS证书,其SAN IP为 &quot;127.0.0.1 &quot;和&quot;[::1]&quot;,到期时间为1月29日16:00:00 2084 GMT。从src/crypto/tls生成:go run generate_cert.go --rsa-bits 1024 --host 127.0.0.1,::1,example.com --ca --start-date &quot;Jan 1 00:00:00 1970&quot; --duration=1000000h。</target>
        </trans-unit>
        <trans-unit id="2852b827de5091ca5aa6958386fa1405befa6094" translate="yes" xml:space="preserve">
          <source>LocalhostKey is the private key for localhostCert.</source>
          <target state="translated">LocalhostKey是localhostCert的私钥。</target>
        </trans-unit>
        <trans-unit id="d219c68101f532de10add2cf42fb9dbeca73d3be" translate="yes" xml:space="preserve">
          <source>Location</source>
          <target state="translated">Location</target>
        </trans-unit>
        <trans-unit id="c9551a197b6ccbbe733e98e1afb44218648f365d" translate="yes" xml:space="preserve">
          <source>Location returns the URL of the response's &quot;Location&quot; header, if present. Relative redirects are resolved relative to the Response's Request. ErrNoLocation is returned if no Location header is present.</source>
          <target state="translated">Location返回响应的 &quot;Location &quot;头的URL,如果存在的话。相对重定向是相对于Response的Request进行解析的,如果没有Location头,则返回ErrNoLocation。如果没有Location头,则返回ErrNoLocation。</target>
        </trans-unit>
        <trans-unit id="6b99376f9c15a7e92154da5850b5d13b41ab37cc" translate="yes" xml:space="preserve">
          <source>Location returns the time zone information associated with t.</source>
          <target state="translated">Location返回与t相关的时区信息。</target>
        </trans-unit>
        <trans-unit id="f30d8c256e2218530f9f115302f529d73fbbff9d" translate="yes" xml:space="preserve">
          <source>Lock locks m. If the lock is already in use, the calling goroutine blocks until the mutex is available.</source>
          <target state="translated">锁定锁m.如果锁已经在使用中,则调用goroutine阻塞,直到mutex可用。</target>
        </trans-unit>
        <trans-unit id="c3a987424c4290a7edfb3d1d597eb0eadb3ba378" translate="yes" xml:space="preserve">
          <source>Lock locks rw for writing. If the lock is already locked for reading or writing, Lock blocks until the lock is available.</source>
          <target state="translated">锁定锁rw进行写入。如果锁已经被锁住进行读写,则锁锁住,直到锁可用为止。</target>
        </trans-unit>
        <trans-unit id="5e340916752857a7b67a505378d157d115c1dd5a" translate="yes" xml:space="preserve">
          <source>LockOSThread wires the calling goroutine to its current operating system thread. The calling goroutine will always execute in that thread, and no other goroutine will execute in it, until the calling goroutine has made as many calls to UnlockOSThread as to LockOSThread. If the calling goroutine exits without unlocking the thread, the thread will be terminated.</source>
          <target state="translated">LockOSThread将调用的goroutine连接到当前的操作系统线程中。在调用的goroutine调用了与LockOSThread同样多的UnlockOSThread之前,调用的goroutine将始终在该线程中执行,其他goroutine不会在该线程中执行。如果调用的goroutine没有解锁线程就退出,那么该线程将被终止。</target>
        </trans-unit>
        <trans-unit id="8bf95ea372568c7a254ba9fada5f6f1701ebc5b5" translate="yes" xml:space="preserve">
          <source>Log</source>
          <target state="translated">Log</target>
        </trans-unit>
        <trans-unit id="fef609891d98d73a3ae686771d1e86e56fc90748" translate="yes" xml:space="preserve">
          <source>Log emits a one-off event with the given category and message. Category can be empty and the API assumes there are only a handful of unique categories in the system.</source>
          <target state="translated">日志用给定的类别和消息发出一次性的事件,类别可以是空的,API假设系统中只有少数几个独特的类别。类别可以是空的,API假设系统中只有少数几个独特的类别。</target>
        </trans-unit>
        <trans-unit id="2353b4e8ade1606ef5c45cccd26ad3ad6087c78a" translate="yes" xml:space="preserve">
          <source>Log emits a timestamped message to the execution trace along with additional information such as the category of the message and which goroutine called Log. The execution tracer provides UIs to filter and group goroutines using the log category and the message supplied in Log.</source>
          <target state="translated">日志会向执行跟踪器发送一个带有时间戳的消息,同时还会提供额外的信息,比如消息的类别和哪个goroutine调用了日志。执行跟踪器提供了使用日志类别和Log中提供的消息来过滤和分组goroutine的用户界面。</target>
        </trans-unit>
        <trans-unit id="9821e0db1231d181423f2e3b3225f154baa6bcf6" translate="yes" xml:space="preserve">
          <source>Log formats its arguments using default formatting, analogous to Println, and records the text in the error log. For tests, the text will be printed only if the test fails or the -test.v flag is set. For benchmarks, the text is always printed to avoid having performance depend on the value of the -test.v flag.</source>
          <target state="translated">Log使用默认的格式化参数,类似于Println,并将文本记录在错误日志中。对于测试,只有当测试失败或设置了-test.v标志时,才会打印文本,对于基准,总是打印文本,以避免性能取决于-test.v标志的值。对于基准,文本总是被打印出来,以避免性能取决于-test.v标志的值。</target>
        </trans-unit>
        <trans-unit id="ad88d5c498edf7ea21028a5246446ba6a3bf9e4a" translate="yes" xml:space="preserve">
          <source>Log returns the natural logarithm of x.</source>
          <target state="translated">Log返回x的自然对数。</target>
        </trans-unit>
        <trans-unit id="81d615cdf905d64451161a1aa0b68ae0ffb374e3" translate="yes" xml:space="preserve">
          <source>Log10</source>
          <target state="translated">Log10</target>
        </trans-unit>
        <trans-unit id="977a2b5c893e89719e9a7736a4e1f9cc525e8f11" translate="yes" xml:space="preserve">
          <source>Log10 returns the decimal logarithm of x.</source>
          <target state="translated">Log10 返回 x 的小数对数。</target>
        </trans-unit>
        <trans-unit id="8671c0c40d7db0093d8bf62e5f04cba5c99ec3ea" translate="yes" xml:space="preserve">
          <source>Log10 returns the decimal logarithm of x. The special cases are the same as for Log.</source>
          <target state="translated">Log10 返回 x 的小数对数,特殊情况与 Log 相同。</target>
        </trans-unit>
        <trans-unit id="a5b2fd4cb1a8e2bb305b5672e391aef89a37298c" translate="yes" xml:space="preserve">
          <source>Log1p returns the natural logarithm of 1 plus its argument x. It is more accurate than Log(1 + x) when x is near zero.</source>
          <target state="translated">Log1p 返回 1 加上其参数 x 的自然对数。当 x 接近零时,它比 Log(1+x)更准确。</target>
        </trans-unit>
        <trans-unit id="6687db9bf747c384bcc8d36417e42b952196b766" translate="yes" xml:space="preserve">
          <source>Log2</source>
          <target state="translated">Log2</target>
        </trans-unit>
        <trans-unit id="7a0389c8675757d7572efc0a10b125d5c66b151f" translate="yes" xml:space="preserve">
          <source>Log2 returns the binary logarithm of x. The special cases are the same as for Log.</source>
          <target state="translated">Log2 返回 x 的二进制对数,特殊情况与 Log 相同。</target>
        </trans-unit>
        <trans-unit id="5963a7c64c0149e44b174ff76b7f701d23bc3074" translate="yes" xml:space="preserve">
          <source>Logb returns the binary exponent of x.</source>
          <target state="translated">Logb返回x的二进制指数。</target>
        </trans-unit>
        <trans-unit id="ea0c4052b7cdd5aadd9cd6f72174db65e462d77d" translate="yes" xml:space="preserve">
          <source>Logf formats its arguments according to the format, analogous to Printf, and records the text in the error log. A final newline is added if not provided. For tests, the text will be printed only if the test fails or the -test.v flag is set. For benchmarks, the text is always printed to avoid having performance depend on the value of the -test.v flag.</source>
          <target state="translated">Logf按照格式对其参数进行格式化,类似于Printf,并将文本记录在错误日志中。如果没有提供参数,最后会添加一个新行。对于测试,只有在测试失败或设置了 -test.v 标志时才会打印文本。对于基准,文本总是被打印出来,以避免性能取决于-test.v标志的值。</target>
        </trans-unit>
        <trans-unit id="38de20acad3e04f48129d8399f6a41e7517acf40" translate="yes" xml:space="preserve">
          <source>Logf is like Log, but the value is formatted using the specified format spec.</source>
          <target state="translated">Logf和Log一样,但值的格式化使用了指定的格式规范。</target>
        </trans-unit>
        <trans-unit id="8432c24573f3f89fad60802fe8eddf1da6315768" translate="yes" xml:space="preserve">
          <source>Logger</source>
          <target state="translated">Logger</target>
        </trans-unit>
        <trans-unit id="71c466638d24f772f0edc78440c6db3a9b5a9e5d" translate="yes" xml:space="preserve">
          <source>Logger.Output</source>
          <target state="translated">Logger.Output</target>
        </trans-unit>
        <trans-unit id="00aa9c00206cc40c149f1a777f6bcbff0a6df954" translate="yes" xml:space="preserve">
          <source>Longest makes future searches prefer the leftmost-longest match. That is, when matching against text, the regexp returns a match that begins as early as possible in the input (leftmost), and among those it chooses a match that is as long as possible. This method modifies the Regexp and may not be called concurrently with any other methods.</source>
          <target state="translated">最长使未来的搜索更倾向于最左最长的匹配。也就是说,当对文本进行匹配时,regexp会返回一个在输入中尽可能早开始的匹配(最左),并在这些匹配中选择一个尽可能长的匹配。这个方法修改了Regexp,并且不能与其他方法同时调用。</target>
        </trans-unit>
        <trans-unit id="2397e2af778033b693f99aeecb7590b807be4783" translate="yes" xml:space="preserve">
          <source>LookPath</source>
          <target state="translated">LookPath</target>
        </trans-unit>
        <trans-unit id="3feb8389b758c68212533dd8278b352dcce121bf" translate="yes" xml:space="preserve">
          <source>LookPath searches for an executable named file in the directories named by the PATH environment variable. If file contains a slash, it is tried directly and the PATH is not consulted. The result may be an absolute path or a path relative to the current directory.</source>
          <target state="translated">LookPath在PATH环境变量命名的目录中搜索一个名为文件的可执行文件。如果文件中包含斜杠,则直接尝试,不参考PATH。结果可能是绝对路径或相对于当前目录的路径。</target>
        </trans-unit>
        <trans-unit id="31ab9ed47ac6872e6361cf76170e61fbc5a37449" translate="yes" xml:space="preserve">
          <source>Lookup looks up a user by username. If the user cannot be found, the returned error is of type UnknownUserError.</source>
          <target state="translated">Lookup通过用户名查找一个用户。如果找不到该用户,返回的错误类型为UnknownUserError。</target>
        </trans-unit>
        <trans-unit id="2c6f1e000a822d2c47b6a21ebdd8f5f93b104795" translate="yes" xml:space="preserve">
          <source>Lookup maps an identifier to its keyword token or IDENT (if not a keyword).</source>
          <target state="translated">查找将一个标识符映射到它的关键字标记或IDENT(如果不是关键字)。</target>
        </trans-unit>
        <trans-unit id="e9251196227d6115352b68461b921cf61a906b43" translate="yes" xml:space="preserve">
          <source>Lookup returns an unsorted list of at most n indices where the byte string s occurs in the indexed data. If n &amp;lt; 0, all occurrences are returned. The result is nil if s is empty, s is not found, or n == 0. Lookup time is O(log(N)*len(s) + len(result)) where N is the size of the indexed data.</source>
          <target state="translated">查找返回最多n个索引的未排序列表，其中字节串s出现在索引数据中。如果n &amp;lt;0，则返回所有出现的事件。如果s为空，找不到s或n == 0，则结​​果为nil。查找时间为O（log（N）* len（s）+ len（result）），其中N是索引数据的大小。</target>
        </trans-unit>
        <trans-unit id="13380eb03660f02dbd5d025d2b74f6f24450d311" translate="yes" xml:space="preserve">
          <source>Lookup returns the Flag structure of the named command-line flag, returning nil if none exists.</source>
          <target state="translated">Lookup返回命名的命令行标志的Flag结构,如果不存在则返回nil。</target>
        </trans-unit>
        <trans-unit id="7e5483b0c984c3a57ec759db6fb278e7b255ecf8" translate="yes" xml:space="preserve">
          <source>Lookup returns the Flag structure of the named flag, returning nil if none exists.</source>
          <target state="translated">Lookup返回命名标志的Flag结构,如果不存在则返回nil。</target>
        </trans-unit>
        <trans-unit id="5b0f26aebf1133c7a9f5776675b02659900d5a6f" translate="yes" xml:space="preserve">
          <source>Lookup returns the method with matching package and name, or nil if not found.</source>
          <target state="translated">Lookup 返回匹配包和名称的方法,如果没有找到,则返回nil。</target>
        </trans-unit>
        <trans-unit id="903dddeee2a83198e7d326397e76f54d9c716c8e" translate="yes" xml:space="preserve">
          <source>Lookup returns the object in scope s with the given name if such an object exists; otherwise the result is nil.</source>
          <target state="translated">如果存在给定名称的对象,Lookup返回s范围内的对象,否则结果为nil。</target>
        </trans-unit>
        <trans-unit id="103697c251b3570afaab5577775dc041e648c7f1" translate="yes" xml:space="preserve">
          <source>Lookup returns the object with the given name if it is found in scope s, otherwise it returns nil. Outer scopes are ignored.</source>
          <target state="translated">如果在作用域s中找到了给定名称的对象,Lookup返回,否则返回nil。外部作用域会被忽略。</target>
        </trans-unit>
        <trans-unit id="85596012a102f4cba55be912c69d163f2b6f529c" translate="yes" xml:space="preserve">
          <source>Lookup returns the profile with the given name, or nil if no such profile exists.</source>
          <target state="translated">Lookup返回给定名称的配置文件,如果没有这样的配置文件,则返回nil。</target>
        </trans-unit>
        <trans-unit id="38285e372c5ecf7fee79e8f5475a7ad611b07ce7" translate="yes" xml:space="preserve">
          <source>Lookup returns the template with the given name that is associated with t, or nil if there is no such template.</source>
          <target state="translated">Lookup返回与t相关联的给定名称的模板,如果没有这样的模板,则返回nil。</target>
        </trans-unit>
        <trans-unit id="b619549e7b11c0494158ea2b89e4d841aca101b2" translate="yes" xml:space="preserve">
          <source>Lookup returns the template with the given name that is associated with t. It returns nil if there is no such template or the template has no definition.</source>
          <target state="translated">如果没有这样的模板或者模板没有定义,则返回nil。</target>
        </trans-unit>
        <trans-unit id="c7a19da9ed723c89b3a482cb521b80e66fbdef7d" translate="yes" xml:space="preserve">
          <source>Lookup returns the value associated with key in the tag string. If the key is present in the tag the value (which may be empty) is returned. Otherwise the returned value will be the empty string. The ok return value reports whether the value was explicitly set in the tag string. If the tag does not have the conventional format, the value returned by Lookup is unspecified.</source>
          <target state="translated">Lookup 返回与标签字符串中的 key 相关联的值,如果标签中存在 key,则返回值(可能为空)。如果标签中存在键,则返回值(可能为空)。否则返回的值将是空字符串。ok 返回值会报告该值是否在标签字符串中显式设置。如果标签没有常规格式,Lookup 返回的值是未指定的。</target>
        </trans-unit>
        <trans-unit id="b1ca47c6e14b4100767398ad08b18ceba8715515" translate="yes" xml:space="preserve">
          <source>Lookup searches for a symbol named symName in plugin p. A symbol is any exported variable or function. It reports an error if the symbol is not found. It is safe for concurrent use by multiple goroutines.</source>
          <target state="translated">查找在插件p中搜索一个名为symName的符号,符号是任何导出的变量或函数。如果没有找到这个符号,它就会报错。它对多个goroutine的并发使用是安全的。</target>
        </trans-unit>
        <trans-unit id="99f5d988af7e6ab773a1a6146dd567b1c079995f" translate="yes" xml:space="preserve">
          <source>LookupAddr performs a reverse lookup for the given address, returning a list of names mapping to that address.</source>
          <target state="translated">LookupAddr对给定的地址进行反向查找,返回一个映射到该地址的名称列表。</target>
        </trans-unit>
        <trans-unit id="c70e79ec87ca49562ea197d9f2381d9321d8fe1b" translate="yes" xml:space="preserve">
          <source>LookupCNAME returns the canonical name for the given host. Callers that do not care about the canonical name can call LookupHost or LookupIP directly; both take care of resolving the canonical name as part of the lookup.</source>
          <target state="translated">LookupCNAME返回给定主机的规范名。不关心规范名的调用者可以直接调用LookupHost或LookupIP;两者都会将规范名的解析作为查找的一部分。</target>
        </trans-unit>
        <trans-unit id="8f4cf5e540b2d7dc315df0e1c1d62f60bab0e907" translate="yes" xml:space="preserve">
          <source>LookupEnv</source>
          <target state="translated">LookupEnv</target>
        </trans-unit>
        <trans-unit id="1ae2ee5065be9305542647e69dc65b9fd29b64fe" translate="yes" xml:space="preserve">
          <source>LookupEnv retrieves the value of the environment variable named by the key. If the variable is present in the environment the value (which may be empty) is returned and the boolean is true. Otherwise the returned value will be empty and the boolean will be false.</source>
          <target state="translated">LookupEnv检索由键命名的环境变量的值。如果该变量存在于环境中,则返回值(可能为空),布尔值为true。否则返回的值将为空,布尔值为false。</target>
        </trans-unit>
        <trans-unit id="450e346d69b1c045fb4f52550736ebb0d1d8a4f8" translate="yes" xml:space="preserve">
          <source>LookupFieldOrMethod looks up a field or method with given package and name in T and returns the corresponding *Var or *Func, an index sequence, and a bool indicating if there were any pointer indirections on the path to the field or method. If addressable is set, T is the type of an addressable variable (only matters for method lookups).</source>
          <target state="translated">LookupFieldOrMethod在T中查找一个给定包和名称的字段或方法,并返回相应的*Var或*Func,一个索引序列,以及一个表示在通往字段或方法的路径上是否有任何指针指示的bool。如果设置了addressable,那么T就是一个可寻址变量的类型(只对方法的查找重要)。</target>
        </trans-unit>
        <trans-unit id="9411c991fe6ec6318c1ddadaf5239d4c8ddf419e" translate="yes" xml:space="preserve">
          <source>LookupFunc returns the text, data, or bss symbol with the given name, or nil if no such symbol is found.</source>
          <target state="translated">LookupFunc返回给定名称的文本、数据或bss符号,如果没有找到这样的符号,则返回nil。</target>
        </trans-unit>
        <trans-unit id="b92e9ccf5cc37f1e202dab80af7fdd5adb2d4fdf" translate="yes" xml:space="preserve">
          <source>LookupGroup looks up a group by name. If the group cannot be found, the returned error is of type UnknownGroupError.</source>
          <target state="translated">LookupGroup通过名称查找一个组。如果找不到该组,返回的错误类型为UnknownGroupError。</target>
        </trans-unit>
        <trans-unit id="864ecbbe82138c5e60336462e2e26b9cc0321aa1" translate="yes" xml:space="preserve">
          <source>LookupGroupId looks up a group by groupid. If the group cannot be found, the returned error is of type UnknownGroupIdError.</source>
          <target state="translated">LookupGroupId通过groupid查找一个组。如果找不到该组,返回的错误类型是UnknownGroupIdError。</target>
        </trans-unit>
        <trans-unit id="b9002491d44dda33fcc5ee2b368b90bad48de6db" translate="yes" xml:space="preserve">
          <source>LookupHost looks up the given host using the local resolver. It returns a slice of that host's addresses.</source>
          <target state="translated">LookupHost 使用本地解析器查找给定主机。它返回该主机地址的一个片段。</target>
        </trans-unit>
        <trans-unit id="e9702748a7f19b9de210233c47deec534e3b2cf2" translate="yes" xml:space="preserve">
          <source>LookupIP looks up host using the local resolver. It returns a slice of that host's IPv4 and IPv6 addresses.</source>
          <target state="translated">LookupIP 使用本地解析器查找主机。它返回该主机的IPv4和IPv6地址的一部分。</target>
        </trans-unit>
        <trans-unit id="f974c6e0590936cd53144b751f0c8c53e1e56f97" translate="yes" xml:space="preserve">
          <source>LookupIPAddr looks up host using the local resolver. It returns a slice of that host's IPv4 and IPv6 addresses.</source>
          <target state="translated">LookupIPAddr 使用本地解析器查找主机。它返回该主机的IPv4和IPv6地址的一部分。</target>
        </trans-unit>
        <trans-unit id="39cfba6c5476e7337eb21e14ebf7cf0d6e5bedc2" translate="yes" xml:space="preserve">
          <source>LookupId looks up a user by userid. If the user cannot be found, the returned error is of type UnknownUserIdError.</source>
          <target state="translated">LookupId通过userid查找一个用户。如果找不到用户,返回的错误类型是UnknownUserIdError。</target>
        </trans-unit>
        <trans-unit id="fa6df437374a8db7470645bbe9d4e27c81caaaeb" translate="yes" xml:space="preserve">
          <source>LookupMX returns the DNS MX records for the given domain name sorted by preference.</source>
          <target state="translated">LookupMX按照偏好排序,返回指定域名的DNS MX记录。</target>
        </trans-unit>
        <trans-unit id="eb321dee8209258e986d88d75de6022a02c641f4" translate="yes" xml:space="preserve">
          <source>LookupNS returns the DNS NS records for the given domain name.</source>
          <target state="translated">LookupNS返回给定域名的DNS NS记录。</target>
        </trans-unit>
        <trans-unit id="74ae49fce9af1a0aa1c34cc08bb2eaff3e2f9136" translate="yes" xml:space="preserve">
          <source>LookupParent follows the parent chain of scopes starting with s until it finds a scope where Lookup(name) returns a non-nil object, and then returns that scope and object. If a valid position pos is provided, only objects that were declared at or before pos are considered. If no such scope and object exists, the result is (nil, nil).</source>
          <target state="translated">LookupParent 遵循从 s 开始的父作用域链,直到它找到一个 Lookup(name)返回非零对象的作用域,然后返回该作用域和对象。如果提供了一个有效的位置 pos,则只考虑在 pos 或之前声明的对象。如果不存在这样的作用域和对象,结果是(nil,nil)。</target>
        </trans-unit>
        <trans-unit id="0730b69dbfb75d19ecc78b2277aae489ac068a4f" translate="yes" xml:space="preserve">
          <source>LookupPort looks up the port for the given network and service.</source>
          <target state="translated">LookupPort查找指定网络和服务的端口。</target>
        </trans-unit>
        <trans-unit id="f0a5a2c68645491f7f14b8ebf958dd03393284be" translate="yes" xml:space="preserve">
          <source>LookupSRV constructs the DNS name to look up following RFC 2782. That is, it looks up _service._proto.name. To accommodate services publishing SRV records under non-standard names, if both service and proto are empty strings, LookupSRV looks up name directly.</source>
          <target state="translated">LookupSRV按照RFC 2782构建要查询的DNS名称。也就是说,它查找的是_service._proto.name。为了适应以非标准名称发布SRV记录的服务,如果service和proto都是空字符串,LookupSRV会直接查找name。</target>
        </trans-unit>
        <trans-unit id="6b37c6078d739a1c536ea751e03fbdc7bcfb4fd9" translate="yes" xml:space="preserve">
          <source>LookupSRV tries to resolve an SRV query of the given service, protocol, and domain name. The proto is &quot;tcp&quot; or &quot;udp&quot;. The returned records are sorted by priority and randomized by weight within a priority.</source>
          <target state="translated">LookupSRV试图解析给定服务、协议和域名的SRV查询。proto是 &quot;tcp &quot;或 &quot;udp&quot;。返回的记录按优先级排序,并在优先级内按权重随机排列。</target>
        </trans-unit>
        <trans-unit id="53adeca568bb0a57f84e1f9d5ebd3b79ee2295f0" translate="yes" xml:space="preserve">
          <source>LookupSym returns the text, data, or bss symbol with the given name, or nil if no such symbol is found.</source>
          <target state="translated">LookupSym返回给定名称的文本、数据或bss符号,如果没有找到这样的符号,则返回nil。</target>
        </trans-unit>
        <trans-unit id="e3ed61b0b0e3039a19a182ecd64a64ecece699f9" translate="yes" xml:space="preserve">
          <source>LookupTXT returns the DNS TXT records for the given domain name.</source>
          <target state="translated">LookupTXT返回指定域名的DNS TXT记录。</target>
        </trans-unit>
        <trans-unit id="be0fd93650565eb4e261e38483006a0a6e96ae35" translate="yes" xml:space="preserve">
          <source>Lsh sets z = x &amp;lt;&amp;lt; n and returns z.</source>
          <target state="translated">Lsh设置z = x &amp;lt;&amp;lt; n并返回z。</target>
        </trans-unit>
        <trans-unit id="8432c7185b33f226f3a96e2aaaeb0017fbd79a53" translate="yes" xml:space="preserve">
          <source>Lstat returns a FileInfo describing the named file. If the file is a symbolic link, the returned FileInfo describes the symbolic link. Lstat makes no attempt to follow the link. If there is an error, it will be of type *PathError.</source>
          <target state="translated">Lstat 返回一个描述命名文件的 FileInfo。如果文件是一个符号链接,返回的FileInfo会描述这个符号链接。Lstat不试图跟踪该链接。如果有错误,它的类型将是*PathError。</target>
        </trans-unit>
        <trans-unit id="653b7ad5571eb02f2761c383b0762a05ad1e21e9" translate="yes" xml:space="preserve">
          <source>M is a type passed to a TestMain function to run the actual tests.</source>
          <target state="translated">M是传递给TestMain函数的类型,用于运行实际测试。</target>
        </trans-unit>
        <trans-unit id="6c4afe9957321d9f90932c8eebed2802a4ac1436" translate="yes" xml:space="preserve">
          <source>MD5 is cryptographically broken and should not be used for secure applications.</source>
          <target state="translated">MD5在密码学上是有缺陷的,不应该用于安全应用。</target>
        </trans-unit>
        <trans-unit id="2c0f2626fcfbcf6f5cc06f45f9a06123950573c9" translate="yes" xml:space="preserve">
          <source>Machine is found in Header.Machine.</source>
          <target state="translated">在Header.Machine中发现了机器。</target>
        </trans-unit>
        <trans-unit id="abd1aeb6203ae00a3b2e20d1890fa31ee8357446" translate="yes" xml:space="preserve">
          <source>Magic number for the elf trampoline, chosen wisely to be an immediate value.</source>
          <target state="translated">精灵蹦床的魔法数字,明智地选择了一个即时值。</target>
        </trans-unit>
        <trans-unit id="d30cb76631db62a976ef3584c436e5f44c54006c" translate="yes" xml:space="preserve">
          <source>Mail issues a MAIL command to the server using the provided email address. If the server supports the 8BITMIME extension, Mail adds the BODY=8BITMIME parameter. This initiates a mail transaction and is followed by one or more Rcpt calls.</source>
          <target state="translated">Mail使用提供的电子邮件地址向服务器发出MAIL命令,如果服务器支持8BITMIME扩展,Mail会添加BODY=8BITMIME参数。如果服务器支持8BITMIME扩展名,Mail会添加BODY=8BITMIME参数。这就启动了一个邮件事务,并在后面进行一个或多个Rcpt调用。</target>
        </trans-unit>
        <trans-unit id="62bce9422ff2d14f69ab80a154510232fc8a9afd" translate="yes" xml:space="preserve">
          <source>Main</source>
          <target state="translated">Main</target>
        </trans-unit>
        <trans-unit id="0784ed59d6aa6164d650ee5788e4f48c9ab53ccb" translate="yes" xml:space="preserve">
          <source>Main is an internal function, part of the implementation of the &quot;go test&quot; command. It was exported because it is cross-package and predates &quot;internal&quot; packages. It is no longer used by &quot;go test&quot; but preserved, as much as possible, for other systems that simulate &quot;go test&quot; using Main, but Main sometimes cannot be updated as new functionality is added to the testing package. Systems simulating &quot;go test&quot; should be updated to use MainStart.</source>
          <target state="translated">Main 是一个内部函数,是实现 &quot;go test &quot;命令的一部分。它被导出是因为它是跨包的,而且比 &quot;内部 &quot;包更早。它不再被 &quot;go test &quot;使用,而是尽可能地保留下来,供其他使用Main模拟 &quot;go test &quot;的系统使用,但由于测试包中增加了新的功能,Main有时无法更新。模拟 &quot;go test &quot;的系统应该更新为使用MainStart。</target>
        </trans-unit>
        <trans-unit id="b4948070b9137e3c4295247505827d161a1430c0" translate="yes" xml:space="preserve">
          <source>MainStart is meant for use by tests generated by 'go test'. It is not meant to be called directly and is not subject to the Go 1 compatibility document. It may change signature from release to release.</source>
          <target state="translated">MainStart 是为了给'go test'生成的测试使用。它不是用来直接调用的,也不受 Go 1 兼容性文件的限制。它可能会在不同的版本中改变签名。</target>
        </trans-unit>
        <trans-unit id="76f0e763aa0460d3ebdb6819d8a8618bd610502c" translate="yes" xml:space="preserve">
          <source>Make returns the Value for x.</source>
          <target state="translated">使返回x的值。</target>
        </trans-unit>
        <trans-unit id="d212d37a7f555035543edd9847aa0f8944d00dd6" translate="yes" xml:space="preserve">
          <source>MakeBool returns the Bool value for b.</source>
          <target state="translated">MakeBool返回b的Bool值。</target>
        </trans-unit>
        <trans-unit id="1bde4b612786d9c5dc71f0124e7f5aff783bd040" translate="yes" xml:space="preserve">
          <source>MakeChan creates a new channel with the specified type and buffer size.</source>
          <target state="translated">MakeChan用指定的类型和缓冲区大小创建一个新通道。</target>
        </trans-unit>
        <trans-unit id="8499a9ac9172e4fd5f8c155f860005e583c8290f" translate="yes" xml:space="preserve">
          <source>MakeFloat64 returns the Float value for x. If x is not finite, the result is an Unknown.</source>
          <target state="translated">MakeFloat64返回x的Float值,如果x不是有限值,结果是未知值。</target>
        </trans-unit>
        <trans-unit id="080b5a4b73c758656574c66abecfca2800793e12" translate="yes" xml:space="preserve">
          <source>MakeFromBytes returns the Int value given the bytes of its little-endian binary representation. An empty byte slice argument represents 0.</source>
          <target state="translated">MakeFromBytes 返回给定小二进制表示的字节的Int值。一个空的字节片参数代表0。</target>
        </trans-unit>
        <trans-unit id="04110b4029f3d51d7f1b1e32dfd59973aae981d8" translate="yes" xml:space="preserve">
          <source>MakeFromLiteral returns the corresponding integer, floating-point, imaginary, character, or string value for a Go literal string. The tok value must be one of token.INT, token.FLOAT, token.IMAG, token.CHAR, or token.STRING. The final argument must be zero. If the literal string syntax is invalid, the result is an Unknown.</source>
          <target state="translated">MakeFromLiteral 回报 Go 字符串对应的整数、浮点、虚数、字符或字符串值。tok值必须是token.INT、token.FLOAT、token.IMAG、token.CHAR或token.STRING中的一种。最后的参数必须是0。如果文字串语法无效,结果是未知数。</target>
        </trans-unit>
        <trans-unit id="07a7a52634a41aa9116fcfbf959be30745aab340" translate="yes" xml:space="preserve">
          <source>MakeFunc</source>
          <target state="translated">MakeFunc</target>
        </trans-unit>
        <trans-unit id="643c1268f2628745bb74a74c0b6210fc3a37b52e" translate="yes" xml:space="preserve">
          <source>MakeFunc returns a new function of the given Type that wraps the function fn. When called, that new function does the following:</source>
          <target state="translated">MakeFunc返回一个给定类型的新函数,它封装了函数fn。当调用该新函数时,该函数将执行以下操作。</target>
        </trans-unit>
        <trans-unit id="e91507405a52b25c3084428772c7fd9dd85d29bc" translate="yes" xml:space="preserve">
          <source>MakeImag returns the Complex value x*i; x must be Int, Float, or Unknown. If x is Unknown, the result is Unknown.</source>
          <target state="translated">MakeImag 返回 Complex 值 x*i;x 必须是 Int、Float 或 Unknown。如果x是未知值,结果是未知值。</target>
        </trans-unit>
        <trans-unit id="da6ba30b4b9d9da1cda2bb8d92f1cb545785138a" translate="yes" xml:space="preserve">
          <source>MakeInt64 returns the Int value for x.</source>
          <target state="translated">MakeInt64返回x的Int值。</target>
        </trans-unit>
        <trans-unit id="f32c29a01762bfefeedc6eb9373c057117a43683" translate="yes" xml:space="preserve">
          <source>MakeMap creates a new map with the specified type.</source>
          <target state="translated">MakeMap创建一个新的指定类型的地图。</target>
        </trans-unit>
        <trans-unit id="f52a4bb4c4b8bb40c53081e9faafbd87a3b197bc" translate="yes" xml:space="preserve">
          <source>MakeMapWithSize creates a new map with the specified type and initial space for approximately n elements.</source>
          <target state="translated">MakeMapWithSize创建一个具有指定类型和初始空间的新地图,大约有n个元素。</target>
        </trans-unit>
        <trans-unit id="55769617e91451b5769c2caeaf264e53ded13fa6" translate="yes" xml:space="preserve">
          <source>MakeSlice creates a new zero-initialized slice value for the specified slice type, length, and capacity.</source>
          <target state="translated">MakeSlice为指定的片类型、长度和容量创建一个新的零初始化的片值。</target>
        </trans-unit>
        <trans-unit id="fbaf52cf63ee748130cb04d59e9e62d4763220eb" translate="yes" xml:space="preserve">
          <source>MakeString returns the String value for s.</source>
          <target state="translated">MakeString 返回 s 的字符串值。</target>
        </trans-unit>
        <trans-unit id="5e3fa6d0673feb64d51f64ca41937f6da75eff62" translate="yes" xml:space="preserve">
          <source>MakeTable</source>
          <target state="translated">MakeTable</target>
        </trans-unit>
        <trans-unit id="785bab6ccfcc81c98865184a96f5abfea960b9ee" translate="yes" xml:space="preserve">
          <source>MakeTable returns a Table constructed from the specified polynomial. The contents of this Table must not be modified.</source>
          <target state="translated">MakeTable 返回一个由指定多项式构造的表。这个Table的内容不能被修改。</target>
        </trans-unit>
        <trans-unit id="9a7cf77039092ac36f999962d307dd473ba79848" translate="yes" xml:space="preserve">
          <source>MakeUint64 returns the Int value for x.</source>
          <target state="translated">MakeUint64返回x的Int值。</target>
        </trans-unit>
        <trans-unit id="e3694e34668330687dd83b2555828d28784d9456" translate="yes" xml:space="preserve">
          <source>MakeUnknown returns the Unknown value.</source>
          <target state="translated">MakeUnknown返回未知值。</target>
        </trans-unit>
        <trans-unit id="fc2df9e4256f3cab4d6220a72b883983cc586bc1" translate="yes" xml:space="preserve">
          <source>MantExp breaks x into its mantissa and exponent components and returns the exponent. If a non-nil mant argument is provided its value is set to the mantissa of x, with the same precision and rounding mode as x. The components satisfy x == mant &amp;times; 2**exp, with 0.5 &amp;lt;= |mant| &amp;lt; 1.0. Calling MantExp with a nil argument is an efficient way to get the exponent of the receiver.</source>
          <target state="translated">MantExp将x分解为其尾数和指数成分，并返回指数。如果提供了非nil mant参数，则将其值设置为x的尾数，其精度和舍入模式与x相同。分量满足x == mant&amp;times;2 ** exp，其中0.5 &amp;lt;= | mant | &amp;lt;1.0。使用nil参数调用MantExp是获得接收方指数的有效方法。</target>
        </trans-unit>
        <trans-unit id="ab478f3efc840eebab919dff1b9512286f70c10c" translate="yes" xml:space="preserve">
          <source>Map</source>
          <target state="translated">Map</target>
        </trans-unit>
        <trans-unit id="053e42c081459c8a8812cfba3b82d0d77adea8da" translate="yes" xml:space="preserve">
          <source>Map is a string-to-Var map variable that satisfies the Var interface.</source>
          <target state="translated">Map是一个满足Var接口的字符串到Var的映射变量。</target>
        </trans-unit>
        <trans-unit id="f35fa30552bf86b6a97457f5a529f46b1ec4ac90" translate="yes" xml:space="preserve">
          <source>Map is like a Go map[interface{}]interface{} but is safe for concurrent use by multiple goroutines without additional locking or coordination. Loads, stores, and deletes run in amortized constant time.</source>
          <target state="translated">Map就像Go的map[interface{}]interface{}一样,但对于多个goroutine的并发使用是安全的,不需要额外的锁定或协调。加载、存储和删除都是以摊开的恒定时间运行的。</target>
        </trans-unit>
        <trans-unit id="a55357ddaf2509ac1bf72db741f5c0cb32477d6c" translate="yes" xml:space="preserve">
          <source>Map returns a copy of the byte slice s with all its characters modified according to the mapping function. If mapping returns a negative value, the character is dropped from the byte slice with no replacement. The characters in s and the output are interpreted as UTF-8-encoded code points.</source>
          <target state="translated">映射返回字节片s的副本,并根据映射函数修改其所有字符。如果映射返回一个负值,则该字符将从字节片中删除,而不会被替换。s和输出中的字符被解释为UTF-8编码的码点。</target>
        </trans-unit>
        <trans-unit id="0c9f196c46a54d96a050fd1d4b324297d8b6bbfd" translate="yes" xml:space="preserve">
          <source>Map returns a copy of the string s with all its characters modified according to the mapping function. If mapping returns a negative value, the character is dropped from the string with no replacement.</source>
          <target state="translated">Map 返回字符串 s 的副本,并根据映射函数修改其所有字符。如果映射返回负值,则从字符串中删除该字符,不进行替换。</target>
        </trans-unit>
        <trans-unit id="4153ac6503fd2f26b78b101383b87a23ab8757a1" translate="yes" xml:space="preserve">
          <source>Map values are deeply equal when all of the following are true: they are both nil or both non-nil, they have the same length, and either they are the same map object or their corresponding keys (matched using Go equality) map to deeply equal values.</source>
          <target state="translated">当以下所有条件为真时,地图值是深度相等的:它们都是零或都是非零,它们有相同的长度,它们是同一个地图对象,或者它们的对应键(使用围棋平等匹配)映射到深度相等的值。</target>
        </trans-unit>
        <trans-unit id="ff4de2d02636ff0b35d7ac62c39c77c38ada9f83" translate="yes" xml:space="preserve">
          <source>Map values encode as JSON objects. The map's key type must either be a string, an integer type, or implement encoding.TextMarshaler. The map keys are sorted and used as JSON object keys by applying the following rules, subject to the UTF-8 coercion described for string values above:</source>
          <target state="translated">地图值编码为JSON对象。地图的键类型必须是字符串、整数类型或实现 encoding.TextMarshaler。通过应用以下规则对地图键进行排序,并将其作为JSON对象键使用,但须遵守上面为字符串值描述的UTF-8胁迫。</target>
        </trans-unit>
        <trans-unit id="b746be79a80992b182da84fae71887f2ec6be3ae" translate="yes" xml:space="preserve">
          <source>MapIndex returns the value associated with key in the map v. It panics if v's Kind is not Map. It returns the zero Value if key is not found in the map or if v represents a nil map. As in Go, the key's value must be assignable to the map's key type.</source>
          <target state="translated">MapIndex 返回与地图 v 中 key 相关联的值,如果 v 的 Kind 不是 Map,它就会惊慌失措。如果在地图中找不到key,或者v代表一个nil地图,它就返回零值。与Go中一样,key的值必须可以分配给map的key类型。</target>
        </trans-unit>
        <trans-unit id="8a8f96c2a60281e18fdf86af937035c625b23750" translate="yes" xml:space="preserve">
          <source>MapKeys returns a slice containing all the keys present in the map, in unspecified order. It panics if v's Kind is not Map. It returns an empty slice if v represents a nil map.</source>
          <target state="translated">MapKeys 返回一个包含地图中所有键的片断,顺序不详。如果v的Kind不是Map,它就会恐慌。如果v代表一个nil map,则返回一个空片断。</target>
        </trans-unit>
        <trans-unit id="393371509edfbb2648f262a9e6f9034fb677acf3" translate="yes" xml:space="preserve">
          <source>MapOf returns the map type with the given key and element types. For example, if k represents int and e represents string, MapOf(k, e) represents map[int]string.</source>
          <target state="translated">MapOf 返回具有给定键和元素类型的地图类型。例如,如果k代表int,e代表字符串,MapOf(k,e)代表map[int]string。</target>
        </trans-unit>
        <trans-unit id="d868be238acb64c17c8f70f0fad5dbca2528fe1a" translate="yes" xml:space="preserve">
          <source>MapRange returns a range iterator for a map. It panics if v's Kind is not Map.</source>
          <target state="translated">MapRange 返回一个地图的范围迭代器。如果v的Kind不是Map,它就会恐慌。</target>
        </trans-unit>
        <trans-unit id="61f910b08995efdd96acb55eeb3536149a9ef35f" translate="yes" xml:space="preserve">
          <source>Mapping between XML elements and data structures is inherently flawed: an XML element is an order-dependent collection of anonymous values, while a data structure is an order-independent collection of named values. See package json for a textual representation more suitable to data structures.</source>
          <target state="translated">XML 元素和数据结构之间的映射存在固有的缺陷:XML 元素是一个依赖于顺序的匿名值集合,而数据结构是一个依赖于顺序的命名值集合。参见包json,以获得更适合数据结构的文本表示方式。</target>
        </trans-unit>
        <trans-unit id="2b32ea0b0909e5260b55a58bd4f84f53b5d1ee01" translate="yes" xml:space="preserve">
          <source>Maps are sent as an unsigned count followed by that many key, element pairs. Empty but non-nil maps are sent, so if the receiver has not allocated one already, one will always be allocated on receipt unless the transmitted map is nil and not at the top level.</source>
          <target state="translated">地图是以一个无符号数的形式发送的,后面跟着那么多的键、元素对。发送的地图是空的,但不是零,所以如果接收者还没有分配地图,那么在收到地图时总会分配一个,除非传输的地图是零,而且不是最高级别的。</target>
        </trans-unit>
        <trans-unit id="ea8cf739cc820968d208878224615030de7ce782" translate="yes" xml:space="preserve">
          <source>MarkComplete marks a package as complete.</source>
          <target state="translated">MarkComplete 标记一个包是完整的。</target>
        </trans-unit>
        <trans-unit id="9cdfbcba7d735bd862886d7bc92cdad6e808e063" translate="yes" xml:space="preserve">
          <source>Marshal</source>
          <target state="translated">Marshal</target>
        </trans-unit>
        <trans-unit id="eb880bd9042393d95106d6336ca91dc7587c2469" translate="yes" xml:space="preserve">
          <source>Marshal converts a point into the uncompressed form specified in section 4.3.6 of ANSI X9.62.</source>
          <target state="translated">Marshal将一个点转换为ANSI X9.62的4.3.6节中指定的非压缩形式。</target>
        </trans-unit>
        <trans-unit id="9dcb1e980e770758d048cdbf31965108d4392cbe" translate="yes" xml:space="preserve">
          <source>Marshal handles an array or slice by marshaling each of the elements. Marshal handles a pointer by marshaling the value it points at or, if the pointer is nil, by writing nothing. Marshal handles an interface value by marshaling the value it contains or, if the interface value is nil, by writing nothing. Marshal handles all other data by writing one or more XML elements containing the data.</source>
          <target state="translated">Marshal处理一个数组或分片时,会对每个元素进行marshaling。Marshal处理一个指针的方法是对它所指向的值进行marshaling,如果指针为零,则什么也不写。Marshal处理一个接口值的方法是对它所包含的值进行marshaling,如果接口值是nil,则什么也不写。Marshal通过写入一个或多个包含数据的XML元素来处理所有其他数据。</target>
        </trans-unit>
        <trans-unit id="62270c3791161d9e12b821a2dd5a09da76b7d939" translate="yes" xml:space="preserve">
          <source>Marshal returns the ASN.1 encoding of val.</source>
          <target state="translated">Marshal 返回 val 的 ASN.1 编码。</target>
        </trans-unit>
        <trans-unit id="d0688338eb6d31b2244e733d8a38556baae70f6c" translate="yes" xml:space="preserve">
          <source>Marshal returns the JSON encoding of v.</source>
          <target state="translated">Marshal返回v的JSON编码。</target>
        </trans-unit>
        <trans-unit id="fd91d49c812b62dbf02b368713f03ffdd50b3ad6" translate="yes" xml:space="preserve">
          <source>Marshal returns the XML encoding of v.</source>
          <target state="translated">Marshal返回v的XML编码。</target>
        </trans-unit>
        <trans-unit id="0de0f4cea1e586ddc2b14ecaaa41c4020891c164" translate="yes" xml:space="preserve">
          <source>Marshal traverses the value v recursively. If an encountered value implements the Marshaler interface and is not a nil pointer, Marshal calls its MarshalJSON method to produce JSON. If no MarshalJSON method is present but the value implements encoding.TextMarshaler instead, Marshal calls its MarshalText method and encodes the result as a JSON string. The nil pointer exception is not strictly necessary but mimics a similar, necessary exception in the behavior of UnmarshalJSON.</source>
          <target state="translated">Marshal递归地遍历值v。如果遇到的值实现了Marshaler接口并且不是一个nil指针,Marshal就会调用它的MarshalJSON方法来生成JSON。如果没有MarshalJSON方法,但该值实现了encoding.TextMarshaler,Marshal就会调用它的MarshalText方法,并将结果编码为JSON字符串。严格来说,nil指针异常并不是必要的,而是模仿了UnmarshalJSON行为中类似的必要异常。</target>
        </trans-unit>
        <trans-unit id="fafaa1ebf620f3798cc6a8c58b669a7ea73fa6b9" translate="yes" xml:space="preserve">
          <source>Marshal will return an error if asked to marshal a channel, function, or map.</source>
          <target state="translated">如果要求Marshal对一个通道、函数或地图进行marshal,Marshal会返回一个错误。</target>
        </trans-unit>
        <trans-unit id="db453e34c5fbd8220b129af743f7150483dd7932" translate="yes" xml:space="preserve">
          <source>MarshalBinary encodes the receiver into a binary form and returns the result.</source>
          <target state="translated">MarshalBinary将接收器编码成二进制形式并返回结果。</target>
        </trans-unit>
        <trans-unit id="0bedf8f876a84577084ab2b16cacfd3254f063b2" translate="yes" xml:space="preserve">
          <source>MarshalBinary implements the encoding.BinaryMarshaler interface.</source>
          <target state="translated">MarshalBinary实现了encoding.BinaryMarshaler接口。</target>
        </trans-unit>
        <trans-unit id="ee53c721c287cd02dbf9f92c9f5e2a991f1f615d" translate="yes" xml:space="preserve">
          <source>MarshalECPrivateKey converts an EC private key to SEC 1, ASN.1 DER form.</source>
          <target state="translated">MarshalECPrivateKey将EC私钥转换为SEC 1、ASN.1 DER形式。</target>
        </trans-unit>
        <trans-unit id="f9e73b7909d7a048a7d6c9e44a0504b100446e17" translate="yes" xml:space="preserve">
          <source>MarshalIndent</source>
          <target state="translated">MarshalIndent</target>
        </trans-unit>
        <trans-unit id="42cea4e6f776e84fbd92d4a9f5ef1c3b218c54ea" translate="yes" xml:space="preserve">
          <source>MarshalIndent is like Marshal but applies Indent to format the output. Each JSON element in the output will begin on a new line beginning with prefix followed by one or more copies of indent according to the indentation nesting.</source>
          <target state="translated">MarshalIndent与Marshal类似,但应用Indent来格式化输出。输出中的每一个JSON元素都将从一个新行开始,以前缀开始,然后根据缩进嵌套的方式,进行一个或多个缩进副本。</target>
        </trans-unit>
        <trans-unit id="b93c5c2e6a3ce1b1ffab83edfd3027b2f5a958ee" translate="yes" xml:space="preserve">
          <source>MarshalIndent works like Marshal, but each XML element begins on a new indented line that starts with prefix and is followed by one or more copies of indent according to the nesting depth.</source>
          <target state="translated">MarshalIndent的工作原理与Marshal类似,但每个XML元素都从一个新的缩进行开始,该缩进行以前缀开始,并根据嵌套深度跟随一个或多个缩进副本。</target>
        </trans-unit>
        <trans-unit id="1fe8186b542a0c93fd906dfbf1d378366d66b83e" translate="yes" xml:space="preserve">
          <source>MarshalJSON implements the json.Marshaler interface.</source>
          <target state="translated">MarshalJSON实现了json.Marshaler接口。</target>
        </trans-unit>
        <trans-unit id="34cafb57f3bf4f148de8715aea906ddd24ca5b67" translate="yes" xml:space="preserve">
          <source>MarshalJSON implements the json.Marshaler interface. The time is a quoted string in RFC 3339 format, with sub-second precision added if present.</source>
          <target state="translated">MarshalJSON实现了json.Marshaler接口。时间是RFC 3339格式的引号字符串,如果存在,则添加亚秒精度。</target>
        </trans-unit>
        <trans-unit id="79739908efedb1d030bbc1bed7fc419173d502bc" translate="yes" xml:space="preserve">
          <source>MarshalJSON returns m as the JSON encoding of m.</source>
          <target state="translated">MarshalJSON 返回 m 的 JSON 编码。</target>
        </trans-unit>
        <trans-unit id="49c4c53b126d5e728f2103ee05aeb8456df06352" translate="yes" xml:space="preserve">
          <source>MarshalPKCS1PrivateKey converts an RSA private key to PKCS#1, ASN.1 DER form.</source>
          <target state="translated">MarshalPKCS1PrivateKey将RSA私钥转换为PKCS#1,ASN.1 DER形式。</target>
        </trans-unit>
        <trans-unit id="6dbb4afc98d66ecc773730ab53b2d3d25670dae3" translate="yes" xml:space="preserve">
          <source>MarshalPKCS1PublicKey converts an RSA public key to PKCS#1, ASN.1 DER form.</source>
          <target state="translated">MarshalPKCS1PublicKey将RSA公钥转换为PKCS#1,ASN.1 DER形式。</target>
        </trans-unit>
        <trans-unit id="de5c14e75241b3422cb105f3219299fa62dfe8b0" translate="yes" xml:space="preserve">
          <source>MarshalPKCS8PrivateKey converts an RSA private key to PKCS#8, ASN.1 DER form.</source>
          <target state="translated">MarshalPKCS8PrivateKey将RSA私钥转换为PKCS#8,ASN.1 DER形式。</target>
        </trans-unit>
        <trans-unit id="7c79ebdd42b60d7be91053c9a1161ea6d5ebbab9" translate="yes" xml:space="preserve">
          <source>MarshalPKIXPublicKey converts a public key to PKIX, ASN.1 DER form.</source>
          <target state="translated">MarshalPKIXPublicKey将公钥转换为PKIX、ASN.1 DER形式。</target>
        </trans-unit>
        <trans-unit id="def0005fff87679bf808d28ec17c1164d884c779" translate="yes" xml:space="preserve">
          <source>MarshalText encodes the receiver into UTF-8-encoded text and returns the result.</source>
          <target state="translated">MarshalText将接收器编码成UTF-8编码的文本,并返回结果。</target>
        </trans-unit>
        <trans-unit id="0e6ec969b789b52d1c5120ea85c9ad182259f168" translate="yes" xml:space="preserve">
          <source>MarshalText implements the encoding.TextMarshaler interface.</source>
          <target state="translated">MarshalText实现了encoding.TextMarshaler接口。</target>
        </trans-unit>
        <trans-unit id="e9f45c26a4b805caf1ff0c7f133453fe1405ea6f" translate="yes" xml:space="preserve">
          <source>MarshalText implements the encoding.TextMarshaler interface. Only the Float value is marshaled (in full precision), other attributes such as precision or accuracy are ignored.</source>
          <target state="translated">MarshalText实现了encoding.TextMarshaler接口。只有Float值被Marshal(全精度),其他属性如精度或准确度被忽略。</target>
        </trans-unit>
        <trans-unit id="1fbe6f2d906b1d5948fbd9851ef463bba4786bcb" translate="yes" xml:space="preserve">
          <source>MarshalText implements the encoding.TextMarshaler interface. The encoding is the same as returned by String, with one exception: When len(ip) is zero, it returns an empty slice.</source>
          <target state="translated">MarshalText实现了encoding.TextMarshaler接口。编码与String返回的编码相同,但有一个例外。当len(ip)为零时,它返回一个空的片断。</target>
        </trans-unit>
        <trans-unit id="83f43718a3654277944df9768c5af959f91ebe45" translate="yes" xml:space="preserve">
          <source>MarshalText implements the encoding.TextMarshaler interface. The time is formatted in RFC 3339 format, with sub-second precision added if present.</source>
          <target state="translated">MarshalText实现了encoding.TextMarshaler接口。时间的格式为RFC 3339格式,如果存在,则添加亚秒精度。</target>
        </trans-unit>
        <trans-unit id="14fcaccd265e76bda57404dd966d33311a65ffc3" translate="yes" xml:space="preserve">
          <source>MarshalWithParams allows field parameters to be specified for the top-level element. The form of the params is the same as the field tags.</source>
          <target state="translated">MarshalWithParams允许为顶层元素指定字段参数。参数的形式与字段标签相同。</target>
        </trans-unit>
        <trans-unit id="34052c5ea18ea7495e24eea4a4d137cecba4872c" translate="yes" xml:space="preserve">
          <source>MarshalXML encodes the receiver as zero or more XML elements. By convention, arrays or slices are typically encoded as a sequence of elements, one per entry. Using start as the element tag is not required, but doing so will enable Unmarshal to match the XML elements to the correct struct field. One common implementation strategy is to construct a separate value with a layout corresponding to the desired XML and then to encode it using e.EncodeElement. Another common strategy is to use repeated calls to e.EncodeToken to generate the XML output one token at a time. The sequence of encoded tokens must make up zero or more valid XML elements.</source>
          <target state="translated">MarshalXML将接收器编码为零或多个XML元素。按照惯例,数组或切片通常被编码为一个元素序列,每个条目一个。使用start作为元素标签并不是必须的,但这样做可以使Unmarshal将XML元素匹配到正确的结构域。一个常见的实现策略是构造一个单独的值,其布局对应于所需的 XML,然后使用 e.EncodeElement 对其进行编码。另一种常见的策略是使用对e.EncodeToken的重复调用,每次生成一个标记的XML输出。编码后的令牌序列必须由零个或多个有效的XML元素组成。</target>
        </trans-unit>
        <trans-unit id="41210996386655a5e9f720c4f9e735ef866f35cb" translate="yes" xml:space="preserve">
          <source>MarshalXMLAttr returns an XML attribute with the encoded value of the receiver. Using name as the attribute name is not required, but doing so will enable Unmarshal to match the attribute to the correct struct field. If MarshalXMLAttr returns the zero attribute Attr{}, no attribute will be generated in the output. MarshalXMLAttr is used only for struct fields with the &quot;attr&quot; option in the field tag.</source>
          <target state="translated">MarshalXMLAttr返回一个XML属性,其中包含接收器的编码值。使用name作为属性名并不是必须的,但这样做可以使Unmarshal将属性匹配到正确的结构域。如果MarshalXMLAttr返回零属性Attr{},则输出中不会生成任何属性。MarshalXMLAttr仅用于字段标签中带有 &quot;attr &quot;选项的结构体字段。</target>
        </trans-unit>
        <trans-unit id="18fd048394e569d8195a81313b9e64f2eba7ee35" translate="yes" xml:space="preserve">
          <source>Marshaler is the interface implemented by objects that can marshal themselves into valid XML elements.</source>
          <target state="translated">Marshaler是由对象实现的接口,它可以将自己混成有效的XML元素。</target>
        </trans-unit>
        <trans-unit id="47a2664e5f80a08312afe3946a74993c99143c6d" translate="yes" xml:space="preserve">
          <source>Marshaler is the interface implemented by types that can marshal themselves into valid JSON.</source>
          <target state="translated">Marshaler是由类型实现的接口,它可以将自己的类型marshal成有效的JSON。</target>
        </trans-unit>
        <trans-unit id="4a00ca7b38dd0506417989c16c2542f21f4d7c58" translate="yes" xml:space="preserve">
          <source>MarshalerAttr is the interface implemented by objects that can marshal themselves into valid XML attributes.</source>
          <target state="translated">MarshalerAttr是由对象实现的接口,这些对象可以将自己的marshal变成有效的XML属性。</target>
        </trans-unit>
        <trans-unit id="5c61140e5006502f101ce6ee77324538231946bb" translate="yes" xml:space="preserve">
          <source>Mask returns the result of masking the IP address ip with mask.</source>
          <target state="translated">Mask返回用mask屏蔽ip地址的结果。</target>
        </trans-unit>
        <trans-unit id="0335207f5e840d81afa158c6c2bb6e3fa02653b4" translate="yes" xml:space="preserve">
          <source>Match</source>
          <target state="translated">Match</target>
        </trans-unit>
        <trans-unit id="b841b8491dab0dabb8feb21367e059b0624fa3bb" translate="yes" xml:space="preserve">
          <source>Match reports whether name matches the shell file name pattern. The pattern syntax is:</source>
          <target state="translated">Match报告name是否符合shell文件名模式。该模式的语法是:</target>
        </trans-unit>
        <trans-unit id="65238f3fd69244258d0fe7834a55d41fd9fdb4b5" translate="yes" xml:space="preserve">
          <source>Match reports whether name matches the shell pattern. The pattern syntax is:</source>
          <target state="translated">Match报告name是否符合shell模式。该模式的语法是:</target>
        </trans-unit>
        <trans-unit id="5f5677ee8a35a029aa3e90c1d56b65878192d3b4" translate="yes" xml:space="preserve">
          <source>Match reports whether the byte slice b contains any match of the regular expression pattern. More complicated queries need to use Compile and the full Regexp interface.</source>
          <target state="translated">Match报告字节片b是否包含任何匹配的正则表达式模式。更复杂的查询需要使用编译和完整的Regexp接口。</target>
        </trans-unit>
        <trans-unit id="269393d413e09f2ec5ba2e6fbdd662834a23a90b" translate="yes" xml:space="preserve">
          <source>Match reports whether the byte slice b contains any match of the regular expression re.</source>
          <target state="translated">Match报告字节片断b是否包含正则表达式re的任何匹配。</target>
        </trans-unit>
        <trans-unit id="188538220b1d59de0ef20f48b5e9a854e7a08bec" translate="yes" xml:space="preserve">
          <source>Match requires pattern to match all of name, not just a substring. The only possible returned error is ErrBadPattern, when pattern is malformed.</source>
          <target state="translated">Match 要求 pattern 匹配所有的 name,而不仅仅是一个子串。唯一可能返回的错误是ErrBadPattern,当pattern是畸形的。</target>
        </trans-unit>
        <trans-unit id="fb78f24b3584ab26ff8d868ae02c24bc3e7a84f8" translate="yes" xml:space="preserve">
          <source>MatchEmptyWidth reports whether the instruction matches an empty string between the runes before and after. It should only be called when i.Op == InstEmptyWidth.</source>
          <target state="translated">MatchEmptyWidth报告该指令是否匹配前后符文之间的空字符串。只有当i.Op ==InstEmptyWidth时,才应该调用它。</target>
        </trans-unit>
        <trans-unit id="766801810391656eb72b30e1a620adc09dc91643" translate="yes" xml:space="preserve">
          <source>MatchFile considers the name of the file and may use ctxt.OpenFile to read some or all of the file's content.</source>
          <target state="translated">MatchFile考虑了文件的名称,并可能使用ctxt.OpenFile来读取文件的部分或全部内容。</target>
        </trans-unit>
        <trans-unit id="32f23226c3beda09b3f84dfe037d9c9ada013d83" translate="yes" xml:space="preserve">
          <source>MatchFile reports whether the file with the given name in the given directory matches the context and would be included in a Package created by ImportDir of that directory.</source>
          <target state="translated">MatchFile报告给定目录中给定名称的文件是否与上下文相匹配,是否会被包含在该目录的ImportDir创建的包中。</target>
        </trans-unit>
        <trans-unit id="230e93d3f899e27c4d81d89f3ff53b1eca08bb37" translate="yes" xml:space="preserve">
          <source>MatchReader reports whether the text returned by the RuneReader contains any match of the regular expression pattern. More complicated queries need to use Compile and the full Regexp interface.</source>
          <target state="translated">MatchReader报告RuneReader返回的文本是否包含任何匹配的正则表达式模式。更复杂的查询需要使用编译和完整的Regexp接口。</target>
        </trans-unit>
        <trans-unit id="25c8a8e56012833544924619010cf5721432e9ab" translate="yes" xml:space="preserve">
          <source>MatchReader reports whether the text returned by the RuneReader contains any match of the regular expression re.</source>
          <target state="translated">MatchReader报告RuneReader返回的文本是否包含任何匹配的正则表达式re。</target>
        </trans-unit>
        <trans-unit id="da28fa625630bc6b02e3ddab6dad208f72cd40bb" translate="yes" xml:space="preserve">
          <source>MatchRune reports whether the instruction matches (and consumes) r. It should only be called when i.Op == InstRune.</source>
          <target state="translated">MatchRune报告指令是否匹配(并消耗)r,只有当i.Op ==InstRune时,才应该调用它。</target>
        </trans-unit>
        <trans-unit id="c488501e6169e99f4e3f5cf4b601fce5b1d18d9c" translate="yes" xml:space="preserve">
          <source>MatchRunePos checks whether the instruction matches (and consumes) r. If so, MatchRunePos returns the index of the matching rune pair (or, when len(i.Rune) == 1, rune singleton). If not, MatchRunePos returns -1. MatchRunePos should only be called when i.Op == InstRune.</source>
          <target state="translated">MatchRunePos检查指令是否匹配(并消耗)r,如果匹配,MatchRunePos返回匹配符文对的索引(或者,当len(i.Rune)==1时,返回符文单体)。如果没有,MatchRunePos返回-1。MatchRunePos只应在i.Op ==InstRune时调用。</target>
        </trans-unit>
        <trans-unit id="c78293f6444063ae02b61b422c861a74ea5c0992" translate="yes" xml:space="preserve">
          <source>MatchString</source>
          <target state="translated">MatchString</target>
        </trans-unit>
        <trans-unit id="16440a205b6632a6f9ce394e96f4e30da62834e6" translate="yes" xml:space="preserve">
          <source>MatchString reports whether the string s contains any match of the regular expression pattern. More complicated queries need to use Compile and the full Regexp interface.</source>
          <target state="translated">MatchString报告字符串s是否包含任何匹配的正则表达式模式。更复杂的查询需要使用编译和完整的Regexp接口。</target>
        </trans-unit>
        <trans-unit id="0b53f246428ae463a3e54d71ff6883543bf5e6b2" translate="yes" xml:space="preserve">
          <source>MatchString reports whether the string s contains any match of the regular expression re.</source>
          <target state="translated">MatchString报告字符串s是否包含正则表达式re的任何匹配。</target>
        </trans-unit>
        <trans-unit id="386301aac4b9205f957c7e2aded15dd3a3170a4d" translate="yes" xml:space="preserve">
          <source>Mathematical constants.</source>
          <target state="translated">数学常数。</target>
        </trans-unit>
        <trans-unit id="e9339d8c2f10a09643bf33b4b293ddbf19fb634d" translate="yes" xml:space="preserve">
          <source>Mathematical interval notation such as [0, n) is used throughout the documentation for this package.</source>
          <target state="translated">在这个软件包的整个文档中使用了数学区间符号,如[0,n)。</target>
        </trans-unit>
        <trans-unit id="b64028b7ef9651f5e0c9bf08d57c40c964fb143d" translate="yes" xml:space="preserve">
          <source>Max returns the larger of x or y.</source>
          <target state="translated">最大值返回x或y中的较大值。</target>
        </trans-unit>
        <trans-unit id="6c955f951ae2dab8e6f5e54e3a98c7139c879b48" translate="yes" xml:space="preserve">
          <source>MaxBase is the largest number base accepted for string conversions.</source>
          <target state="translated">MaxBase是字符串转换所接受的最大数基。</target>
        </trans-unit>
        <trans-unit id="d9d067026e10599a63c5386be336904174743560" translate="yes" xml:space="preserve">
          <source>MaxBytesReader is similar to io.LimitReader but is intended for limiting the size of incoming request bodies. In contrast to io.LimitReader, MaxBytesReader's result is a ReadCloser, returns a non-EOF error for a Read beyond the limit, and closes the underlying reader when its Close method is called.</source>
          <target state="translated">MaxBytesReader类似于io.LimitReader,但目的是为了限制传入请求体的大小。与io.LimitReader相反,MaxBytesReader的结果是一个ReadCloser,对于超出限制的Read返回一个非EOF错误,并在其Close方法被调用时关闭底层阅读器。</target>
        </trans-unit>
        <trans-unit id="739ec125397a0373ef46f377effdf6be903c6fd8" translate="yes" xml:space="preserve">
          <source>MaxBytesReader prevents clients from accidentally or maliciously sending a large request and wasting server resources.</source>
          <target state="translated">MaxBytesReader可以防止客户端意外或恶意发送大量请求,浪费服务器资源。</target>
        </trans-unit>
        <trans-unit id="61be69d33fec3be907f4ea6e04af100d85f7675e" translate="yes" xml:space="preserve">
          <source>MaxCap walks the regexp to find the maximum capture index.</source>
          <target state="translated">MaxCap走过regexp,找到最大的捕获指数。</target>
        </trans-unit>
        <trans-unit id="df7b72cdcf2650790c955b9e993a0a0c2fbe25b4" translate="yes" xml:space="preserve">
          <source>MaxEncodedLen returns the maximum length of an encoding of n source bytes.</source>
          <target state="translated">MaxEncodedLen 返回 n 个源字节的最大编码长度。</target>
        </trans-unit>
        <trans-unit id="89c65689a7af2cc891fbeafce261f8df625c4303" translate="yes" xml:space="preserve">
          <source>MaxVarintLenN is the maximum length of a varint-encoded N-bit integer.</source>
          <target state="translated">MaxVarintLenN是一个变异编码的N位整数的最大长度。</target>
        </trans-unit>
        <trans-unit id="1157d0585a10f5f650da7952c06f96ac83134419" translate="yes" xml:space="preserve">
          <source>MemProfile returns a profile of memory allocated and freed per allocation site.</source>
          <target state="translated">MemProfile返回每个分配站点分配和释放的内存的配置文件。</target>
        </trans-unit>
        <trans-unit id="d8d6b923c77de71210013c81589eaf2c4fe10654" translate="yes" xml:space="preserve">
          <source>MemProfile returns n, the number of records in the current memory profile. If len(p) &amp;gt;= n, MemProfile copies the profile into p and returns n, true. If len(p) &amp;lt; n, MemProfile does not change p and returns n, false.</source>
          <target state="translated">MemProfile返回n，即当前内存配置文件中的记录数。如果len（p）&amp;gt; = n，则MemProfile将配置文件复制到p中并返回n，true。如果len（p）&amp;lt;n，则MemProfile不会更改p并返回n，否则为false。</target>
        </trans-unit>
        <trans-unit id="c013eb0f98db13dab8418c5c8a82f2ae00733c42" translate="yes" xml:space="preserve">
          <source>MemProfileRate controls the fraction of memory allocations that are recorded and reported in the memory profile. The profiler aims to sample an average of one allocation per MemProfileRate bytes allocated.</source>
          <target state="translated">MemProfileRate控制内存配置文件中记录和报告的内存分配的分数。剖析器的目标是对每分配一个MemProfileRate字节的平均分配进行采样。</target>
        </trans-unit>
        <trans-unit id="e7ca02f761fad2cef95bf22ec3a49a7a10d4d7ec" translate="yes" xml:space="preserve">
          <source>MemString returns r.AllocedBytesPerOp and r.AllocsPerOp in the same format as 'go test'.</source>
          <target state="translated">MemString返回r.AllocedBytesPerOp和r.AllocsPerOp,格式与'go test'相同。</target>
        </trans-unit>
        <trans-unit id="5885c324e2b06a6d3881d7dca39a2a9515c8b84e" translate="yes" xml:space="preserve">
          <source>MergeLine merges a line with the following line. It is akin to replacing the newline character at the end of the line with a space (to not change the remaining offsets). To obtain the line number, consult e.g. Position.Line. MergeLine will panic if given an invalid line number.</source>
          <target state="translated">MergeLine 将一行与下一行合并。它类似于用空格代替行末的换行符(不改变剩余的偏移量)。要获得行号,请参考例如 Position.Line。如果给定一个无效的行号,MergeLine会惊慌失措。</target>
        </trans-unit>
        <trans-unit id="c56ee5f274246d4907a3f8792aa47b70201e2839" translate="yes" xml:space="preserve">
          <source>MergePackageFiles creates a file AST by merging the ASTs of the files belonging to a package. The mode flags control merging behavior.</source>
          <target state="translated">MergePackageFiles通过合并属于一个包的文件的AST来创建一个文件AST。模式标志控制合并行为。</target>
        </trans-unit>
        <trans-unit id="7f6f0438a1b28dd75bfa1675a817c685d6ecf309" translate="yes" xml:space="preserve">
          <source>Method represents a single method.</source>
          <target state="translated">方法代表一个单一的方法。</target>
        </trans-unit>
        <trans-unit id="d5cc6ded0a12c1ea7e555fe80a4dd907a9326b65" translate="yes" xml:space="preserve">
          <source>Method returns a function value corresponding to v's i'th method. The arguments to a Call on the returned function should not include a receiver; the returned function will always use v as the receiver. Method panics if i is out of range or if v is a nil interface value.</source>
          <target state="translated">方法返回一个对应于v的第i'th方法的函数值。在返回函数上的Call的参数不应包括接收者,返回的函数将始终使用v作为接收者。如果i超出范围或者v是一个nil接口值,方法就会恐慌。</target>
        </trans-unit>
        <trans-unit id="8580bc7cf729ccd2e220561b0a2aa0093af75313" translate="yes" xml:space="preserve">
          <source>Method returns the i'th method of interface t for 0 &amp;lt;= i &amp;lt; t.NumMethods(). The methods are ordered by their unique Id.</source>
          <target state="translated">方法为0 &amp;lt;= i &amp;lt;t.NumMethods（）返回接口t的第i个方法。这些方法按其唯一ID排序。</target>
        </trans-unit>
        <trans-unit id="0d5919064169d4fa2dfa670c5cd1d31fe4f5ec77" translate="yes" xml:space="preserve">
          <source>Method returns the i'th method of named type t for 0 &amp;lt;= i &amp;lt; t.NumMethods().</source>
          <target state="translated">方法返回0 &amp;lt;= i &amp;lt;t.NumMethods（）的第i个命名类型为t的方法。</target>
        </trans-unit>
        <trans-unit id="7b406879ef1e276f5ac32d320c19bb15ff9ced44" translate="yes" xml:space="preserve">
          <source>MethodByName returns a function value corresponding to the method of v with the given name. The arguments to a Call on the returned function should not include a receiver; the returned function will always use v as the receiver. It returns the zero Value if no method was found.</source>
          <target state="translated">MethodByName返回一个与给定名称的v的方法相对应的函数值。返回函数的 Call 的参数不应包括接收器;返回的函数将始终使用 v 作为接收器。如果没有找到方法,则返回零值。</target>
        </trans-unit>
        <trans-unit id="1995bb7d8a495c29ba7a59b0b373d66ee1f82142" translate="yes" xml:space="preserve">
          <source>MethodSet</source>
          <target state="translated">MethodSet</target>
        </trans-unit>
        <trans-unit id="c5e9a1bdc9129c6b25b91c69272ee11aa65ae4ac" translate="yes" xml:space="preserve">
          <source>Methods of this form typically return the incoming receiver as well, to enable simple call chaining.</source>
          <target state="translated">这种形式的方法通常也会返回接收方,以实现简单的呼叫链。</target>
        </trans-unit>
        <trans-unit id="68e37169f0406f89039a63dc143d5a05fc9b5510" translate="yes" xml:space="preserve">
          <source>Methods which don't require a result value to be passed in (for instance, Int.Sign), simply return the result. In this case, the receiver is typically the first operand, named x:</source>
          <target state="translated">不需要传递结果值的方法(例如,Int.Sign),只需返回结果即可。在这种情况下,接收者通常是第一个操作数,名为x。</target>
        </trans-unit>
        <trans-unit id="594fd92ee6be7b72c6f8d9451d2a9f9e3bae51ed" translate="yes" xml:space="preserve">
          <source>Microseconds returns the duration as an integer microsecond count.</source>
          <target state="translated">Microseconds 以整数微秒数的形式返回持续时间。</target>
        </trans-unit>
        <trans-unit id="c825c82257bdcbc1a135579145266c6ee484713a" translate="yes" xml:space="preserve">
          <source>Milliseconds returns the duration as an integer millisecond count.</source>
          <target state="translated">Milliseconds 返回整数毫秒的持续时间。</target>
        </trans-unit>
        <trans-unit id="d4a6fe67a8f15c1c894bf05225db6c07db7dc926" translate="yes" xml:space="preserve">
          <source>Min returns the smaller of x or y.</source>
          <target state="translated">Min返回x或y中的较小值。</target>
        </trans-unit>
        <trans-unit id="dacfaba796bce8b807113e726ae0618041c980f0" translate="yes" xml:space="preserve">
          <source>MinPrec returns the minimum precision required to represent x exactly (i.e., the smallest prec before x.SetPrec(prec) would start rounding x). The result is 0 for |x| == 0 and |x| == Inf.</source>
          <target state="translated">MinPrec 返回精确表示 x 所需的最小精度(即 x.SetPrec(prec)开始四舍五入之前的最小prec)。对于|x| ==0和|x| ==Inf,结果为0。</target>
        </trans-unit>
        <trans-unit id="b959e8418a57efc341ef2ea80360e0eee71f265e" translate="yes" xml:space="preserve">
          <source>MinRead is the minimum slice size passed to a Read call by Buffer.ReadFrom. As long as the Buffer has at least MinRead bytes beyond what is required to hold the contents of r, ReadFrom will not grow the underlying buffer.</source>
          <target state="translated">MinRead是Buffer.ReadFrom传递给Read调用的最小分片大小。只要Buffer的MinRead字节数至少超过了容纳r内容所需的字节数,ReadFrom就不会增长底层缓冲区。</target>
        </trans-unit>
        <trans-unit id="ba682b9edf600874d186945b125535bdb2fd2d00" translate="yes" xml:space="preserve">
          <source>Minute returns the minute offset within the hour specified by t, in the range [0, 59].</source>
          <target state="translated">Minute 返回t指定的小时内的分钟偏移量,范围为[0,59]。</target>
        </trans-unit>
        <trans-unit id="f75dd7f0b206dbae82a8f8f0b7023bff54f3a266" translate="yes" xml:space="preserve">
          <source>Minutes returns the duration as a floating point number of minutes.</source>
          <target state="translated">Minutes(分钟)返回浮点数的分钟数。</target>
        </trans-unit>
        <trans-unit id="eb3dbdbaa825e8d8a44607bf8d9e0b1911e69e12" translate="yes" xml:space="preserve">
          <source>MissingMethod returns (nil, false) if V implements T, otherwise it returns a missing method required by T and whether it is missing or just has the wrong type.</source>
          <target state="translated">如果V实现了T,则MissingMethod返回(nil,false),否则返回T所需要的缺失的方法,以及它是否缺失或只是有错误的类型。</target>
        </trans-unit>
        <trans-unit id="37de4657eb0dc5b3413cb095b60f3d8129f6593f" translate="yes" xml:space="preserve">
          <source>Mkdir creates a new directory with the specified name and permission bits (before umask). If there is an error, it will be of type *PathError.</source>
          <target state="translated">Mkdir用指定的名称和权限位(在umask之前)创建一个新目录。如果有一个错误,它的类型将是*PathError。</target>
        </trans-unit>
        <trans-unit id="677ef1c770313b12ac646270f84a792125bb5633" translate="yes" xml:space="preserve">
          <source>MkdirAll creates a directory named path, along with any necessary parents, and returns nil, or else returns an error. The permission bits perm (before umask) are used for all directories that MkdirAll creates. If path is already a directory, MkdirAll does nothing and returns nil.</source>
          <target state="translated">MkdirAll 创建一个名为 path 的目录,以及任何必要的父目录,然后返回 nil,否则返回错误。权限位perm(在umask之前)用于MkdirAll创建的所有目录。如果path已经是一个目录,MkdirAll什么也不做,返回nil。</target>
        </trans-unit>
        <trans-unit id="f388dbfb78ec3e8821ae0844a947cecd488dd5ff" translate="yes" xml:space="preserve">
          <source>Mod</source>
          <target state="translated">Mod</target>
        </trans-unit>
        <trans-unit id="373154d6ec87032b198bd3426fdb98b629297d1b" translate="yes" xml:space="preserve">
          <source>Mod returns the floating-point remainder of x/y. The magnitude of the result is less than y and its sign agrees with that of x.</source>
          <target state="translated">Mod返回x/y的浮点余数。结果的大小小于y,且其符号与x一致。</target>
        </trans-unit>
        <trans-unit id="f2b25579075ef3b96af2a2e04dfbe27a4023e7c3" translate="yes" xml:space="preserve">
          <source>Mod returns the point q in r such that p.X-q.X is a multiple of r's width and p.Y-q.Y is a multiple of r's height.</source>
          <target state="translated">Mod返回r中的点q,使得p.X-q.X是r的宽度的倍数,p.Y-q.Y是r的高度的倍数。</target>
        </trans-unit>
        <trans-unit id="5301dec2851eeeadb9f8edd3bcc14178a7cc1eac" translate="yes" xml:space="preserve">
          <source>Mod sets z to the modulus x%y for y != 0 and returns z. If y == 0, a division-by-zero run-time panic occurs. Mod implements Euclidean modulus (unlike Go); see DivMod for more details.</source>
          <target state="translated">Mod将z设为y !=0的模数x%y,并返回z。如果y ==0,则会发生按零除法的运行时恐慌。Mod 实现了欧氏模数 (与 Go 不同);更多细节请参见 DivMod。</target>
        </trans-unit>
        <trans-unit id="6d74b87ee55add7bade81d22a2a4510010f96ac8" translate="yes" xml:space="preserve">
          <source>ModInverse sets z to the multiplicative inverse of g in the ring ℤ/nℤ and returns z. If g and n are not relatively prime, g has no multiplicative inverse in the ring ℤ/nℤ. In this case, z is unchanged and the return value is nil.</source>
          <target state="translated">ModInverse 将 z 设为 g 在环 ℤ/nℤ 中的乘法逆,并返回 z。如果 g 和 n 不是相对质数,则 g 在环 ℤ/nℤ 中没有乘法逆。在这种情况下,z不变,返回值为nil。</target>
        </trans-unit>
        <trans-unit id="7a4fd0d385cd06f73e61243a029e76aa018a4f23" translate="yes" xml:space="preserve">
          <source>ModSqrt sets z to a square root of x mod p if such a square root exists, and returns z. The modulus p must be an odd prime. If x is not a square mod p, ModSqrt leaves z unchanged and returns nil. This function panics if p is not an odd integer.</source>
          <target state="translated">ModSqrt 设 z 为 x mod p 的平方根,如果存在这样的平方根,则返回 z。模数 p 必须是奇数素数。如果x不是平方模p,ModSqrt将z保持不变并返回nil。如果p不是奇数整数,这个函数就会惊慌失措。</target>
        </trans-unit>
        <trans-unit id="aac634faa69d653814bcee88f0a5dfc61028be1b" translate="yes" xml:space="preserve">
          <source>ModTime returns the modification time in UTC using the legacy ModifiedDate and ModifiedTime fields.</source>
          <target state="translated">ModTime使用传统的ModifiedDate和ModifiedTime字段返回以UTC为单位的修改时间。</target>
        </trans-unit>
        <trans-unit id="aa00a628811be04815f4dd62095833b576cd8722" translate="yes" xml:space="preserve">
          <source>Mode returns the permission and mode bits for the FileHeader.</source>
          <target state="translated">Mode 返回 FileHeader 的权限和模式位。</target>
        </trans-unit>
        <trans-unit id="28a0f960b89726a468e14a8ebdf922a21170bc22" translate="yes" xml:space="preserve">
          <source>Mode returns the rounding mode of x.</source>
          <target state="translated">Mode返回x的取整模式。</target>
        </trans-unit>
        <trans-unit id="8b4ea19087de0202d8e6a728b310de2dbb997d4d" translate="yes" xml:space="preserve">
          <source>Mode values control the operation of New.</source>
          <target state="translated">模式值控制New的操作。</target>
        </trans-unit>
        <trans-unit id="ee5a2d9bea8822761c2af443e30dd8b140094e31" translate="yes" xml:space="preserve">
          <source>Model can convert any Color to one from its own color model. The conversion may be lossy.</source>
          <target state="translated">模型可以将任何颜色转换为自己的颜色模型。转换可能是有损的。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
