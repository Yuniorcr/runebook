<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="go">
    <body>
      <group id="go">
        <trans-unit id="a91bed1365204e8353c0f745ca77893ae1b1305d" translate="yes" xml:space="preserve">
          <source>Source values of type bool may be scanned into types *bool, *interface{}, *string, *[]byte, or *RawBytes.</source>
          <target state="translated">bool类型的源值可以被扫描成*bool、*interface{}、*string、*[]byte或*RawBytes类型。</target>
        </trans-unit>
        <trans-unit id="4cd3cd23d4f7a4635c360a861ee7be174fed76cc" translate="yes" xml:space="preserve">
          <source>Source values of type time.Time may be scanned into values of type *time.Time, *interface{}, *string, or *[]byte. When converting to the latter two, time.RFC3339Nano is used.</source>
          <target state="translated">time.Time类型的源值可以被扫描成*time.Time、*interface{}、*string或*[]byte类型的值。当转换为后两种类型时,使用time.RFC3339Nano。</target>
        </trans-unit>
        <trans-unit id="6bdf6d7926b72078af0c191b3c6238538d7b0cb1" translate="yes" xml:space="preserve">
          <source>Special case is:</source>
          <target state="translated">特殊情况是:</target>
        </trans-unit>
        <trans-unit id="38cf2e1ac5d0bfa814379b9cb5b1a8aad4c71895" translate="yes" xml:space="preserve">
          <source>Special cases are (in order):</source>
          <target state="translated">特殊情况是(依次):</target>
        </trans-unit>
        <trans-unit id="36ff1c61fcf6a6f96273c5129f496e6e2d52bc61" translate="yes" xml:space="preserve">
          <source>Special cases are the same as Exp.</source>
          <target state="translated">特殊情况与博览会相同。</target>
        </trans-unit>
        <trans-unit id="fb4f18f6f604123235431e09b3313991f0bb526d" translate="yes" xml:space="preserve">
          <source>Special cases are:</source>
          <target state="translated">特殊情况是:</target>
        </trans-unit>
        <trans-unit id="46044fc293a1827aa7aed188a242765b1470a9ed" translate="yes" xml:space="preserve">
          <source>Special section indices.</source>
          <target state="translated">特别节指数。</target>
        </trans-unit>
        <trans-unit id="a2fde335dab74ce6562dfce419b45cb58e70ab07" translate="yes" xml:space="preserve">
          <source>SpecialCase</source>
          <target state="translated">SpecialCase</target>
        </trans-unit>
        <trans-unit id="47398a3a12335bdb3df057e3646557b1b5841333" translate="yes" xml:space="preserve">
          <source>SpecialCase represents language-specific case mappings such as Turkish. Methods of SpecialCase customize (by overriding) the standard mappings.</source>
          <target state="translated">SpecialCase表示特定语言的大小写映射,如土耳其语。SpecialCase的方法可以自定义(通过覆盖)标准映射。</target>
        </trans-unit>
        <trans-unit id="fc8230b4119ad4b994db2324d71f4e0ae7ad932c" translate="yes" xml:space="preserve">
          <source>Split</source>
          <target state="translated">Split</target>
        </trans-unit>
        <trans-unit id="23392488f19a5d0be8c39d3cfafde4dd76bd94be" translate="yes" xml:space="preserve">
          <source>Split panics if it is called after scanning has started.</source>
          <target state="translated">如果在扫描开始后被调用,则会出现分裂现象。</target>
        </trans-unit>
        <trans-unit id="96e564d2bf5c731af05562ed176616a9d55a5e64" translate="yes" xml:space="preserve">
          <source>Split sets the split function for the Scanner. The default split function is ScanLines.</source>
          <target state="translated">Split(分割)设置扫描仪的分割功能。默认的分割功能是ScanLines。</target>
        </trans-unit>
        <trans-unit id="eb475bc85cdb49a4c4de00518ab4efe39bcec33e" translate="yes" xml:space="preserve">
          <source>Split slices s into all subslices separated by sep and returns a slice of the subslices between those separators. If sep is empty, Split splits after each UTF-8 sequence. It is equivalent to SplitN with a count of -1.</source>
          <target state="translated">Split 将 s 分割成由 sep 分隔的所有子片段,并返回这些分隔符之间的子片段。如果sep为空,Split会在每个UTF-8序列之后进行分割。它等同于SplitN,计数为-1。</target>
        </trans-unit>
        <trans-unit id="67dbafd6c3b93902b18d8f321af8549a1b6ad6e7" translate="yes" xml:space="preserve">
          <source>Split slices s into all substrings separated by sep and returns a slice of the substrings between those separators.</source>
          <target state="translated">将 s 分割成所有用 sep 分隔的子串,并返回这些分隔符之间的子串的分片。</target>
        </trans-unit>
        <trans-unit id="8a1469b01e576340018d58bd7e3d302e90dee09f" translate="yes" xml:space="preserve">
          <source>Split slices s into substrings separated by the expression and returns a slice of the substrings between those expression matches.</source>
          <target state="translated">将s分割成由表达式分隔的子串,并返回这些表达式匹配之间的子串的分片。</target>
        </trans-unit>
        <trans-unit id="817430fe1883828acde2ae90d1a5b512a8d87c1e" translate="yes" xml:space="preserve">
          <source>Split splits path immediately following the final Separator, separating it into a directory and file name component. If there is no Separator in path, Split returns an empty dir and file set to path. The returned values have the property that path = dir+file.</source>
          <target state="translated">Split将紧跟在最后一个Separator后面的路径进行分割,将其分割成一个目录和文件名的部分,如果路径中没有Separator,Split将返回一个空的dir和文件,设置为path。如果path中没有Separator,Split会返回一个空的dir和设置为path的文件。返回的值具有path=dir+file的属性。</target>
        </trans-unit>
        <trans-unit id="04097266465adc5300d2bc3091a77206398acddf" translate="yes" xml:space="preserve">
          <source>Split splits path immediately following the final slash, separating it into a directory and file name component. If there is no slash in path, Split returns an empty dir and file set to path. The returned values have the property that path = dir+file.</source>
          <target state="translated">Split将路径分割成一个目录和文件名。如果path中没有斜杠,Split会返回一个空的dir和设置为path的文件。返回的值具有path=dir+file的属性。</target>
        </trans-unit>
        <trans-unit id="f645051fa0ea9f5fba674ae30e0eb8228c563bbb" translate="yes" xml:space="preserve">
          <source>SplitAfter</source>
          <target state="translated">SplitAfter</target>
        </trans-unit>
        <trans-unit id="af6f57e26d6655b8a560ff5a1ea503e038967615" translate="yes" xml:space="preserve">
          <source>SplitAfter slices s into all subslices after each instance of sep and returns a slice of those subslices. If sep is empty, SplitAfter splits after each UTF-8 sequence. It is equivalent to SplitAfterN with a count of -1.</source>
          <target state="translated">SplitAfter 将 s 分割成 sep 的每一个实例后的所有子片段,并返回这些子片段的一个片段。如果sep为空,SplitAfter会在每个UTF-8序列之后进行分割。它等同于SplitAfterN,计数为-1。</target>
        </trans-unit>
        <trans-unit id="7b96a1319471e70dc0744f490b304d8e5292e091" translate="yes" xml:space="preserve">
          <source>SplitAfter slices s into all substrings after each instance of sep and returns a slice of those substrings.</source>
          <target state="translated">SplitAfter 在每一个 sep 实例后将 s 切成所有子串,并返回这些子串的一个分片。</target>
        </trans-unit>
        <trans-unit id="183e10127881bddc63e39844aca6fde7b55ad84d" translate="yes" xml:space="preserve">
          <source>SplitAfterN</source>
          <target state="translated">SplitAfterN</target>
        </trans-unit>
        <trans-unit id="71c5d7e2f9fd13201867043dfefbd28be7cef909" translate="yes" xml:space="preserve">
          <source>SplitAfterN slices s into subslices after each instance of sep and returns a slice of those subslices. If sep is empty, SplitAfterN splits after each UTF-8 sequence. The count determines the number of subslices to return:</source>
          <target state="translated">SplitAfterN在每一个sep实例之后将s切成子片,并返回这些子片的一个片断。如果sep为空,SplitAfterN在每个UTF-8序列之后进行分割。计数决定了要返回的子片段的数量。</target>
        </trans-unit>
        <trans-unit id="b953b958d37f7636fa29a91139b9e599462e7d0a" translate="yes" xml:space="preserve">
          <source>SplitAfterN slices s into substrings after each instance of sep and returns a slice of those substrings.</source>
          <target state="translated">SplitAfterN 在每一个 sep 实例之后将 s 切成子串,并返回这些子串的一个分片。</target>
        </trans-unit>
        <trans-unit id="c42d1c66abbb920d11fa3452a55d6b02ca57969f" translate="yes" xml:space="preserve">
          <source>SplitFunc is the signature of the split function used to tokenize the input. The arguments are an initial substring of the remaining unprocessed data and a flag, atEOF, that reports whether the Reader has no more data to give. The return values are the number of bytes to advance the input and the next token to return to the user, if any, plus an error, if any.</source>
          <target state="translated">SplitFunc是用于标记输入的分割函数的签名。参数是一个剩余的未处理数据的初始子串和一个标志,atEOF,用于报告Reader是否没有更多的数据可给。返回值是推进输入的字节数和返回给用户的下一个标记(如果有的话),加上一个错误(如果有的话)。</target>
        </trans-unit>
        <trans-unit id="b4cd81f732cbd3a8923ecb19ba58f0f16cb90789" translate="yes" xml:space="preserve">
          <source>SplitHostPort splits a network address of the form &quot;host:port&quot;, &quot;host%zone:port&quot;, &quot;[host]:port&quot; or &quot;[host%zone]:port&quot; into host or host%zone and port.</source>
          <target state="translated">SplitHostPort将 &quot;host:port&quot;、&quot;host%zone:port&quot;、&quot;[host]:port &quot;或&quot;[host%zone]:port &quot;形式的网络地址分割成host或host%zone和port。</target>
        </trans-unit>
        <trans-unit id="83d28a087df2085b354d9219f029b5d90cf38ec4" translate="yes" xml:space="preserve">
          <source>SplitList</source>
          <target state="translated">SplitList</target>
        </trans-unit>
        <trans-unit id="2810f9f5e2566aed968386693eafb51ff308b597" translate="yes" xml:space="preserve">
          <source>SplitList splits a list of paths joined by the OS-specific ListSeparator, usually found in PATH or GOPATH environment variables. Unlike strings.Split, SplitList returns an empty slice when passed an empty string.</source>
          <target state="translated">SplitList 将一个由操作系统特有的 ListSeparator 连接的路径列表分割开来,通常在 PATH 或 GOPATH 环境变量中找到。与 strings.Split 不同,当传递一个空字符串时,SplitList 会返回一个空分片。</target>
        </trans-unit>
        <trans-unit id="84cfaf9bc325cc024ba8d73b2f03f1f0b940f375" translate="yes" xml:space="preserve">
          <source>SplitN</source>
          <target state="translated">SplitN</target>
        </trans-unit>
        <trans-unit id="36c3c8ea011f7ef62da6893e010962d6852bd07a" translate="yes" xml:space="preserve">
          <source>SplitN slices s into subslices separated by sep and returns a slice of the subslices between those separators. If sep is empty, SplitN splits after each UTF-8 sequence. The count determines the number of subslices to return:</source>
          <target state="translated">SplitN 将 s 切成由 sep 分隔的子片,并返回这些分隔符之间的子片。如果sep为空,SplitN会在每个UTF-8序列之后进行分割。计数决定了要返回的子分片数量。</target>
        </trans-unit>
        <trans-unit id="de01961453e6bcc30ddd7714ed914f746f011fab" translate="yes" xml:space="preserve">
          <source>SplitN slices s into substrings separated by sep and returns a slice of the substrings between those separators.</source>
          <target state="translated">SplitN 将 s 切成由 sep 分隔的子线,并返回这些分隔符之间的子线的切片。</target>
        </trans-unit>
        <trans-unit id="8ca15484a6a50617febf823f3fa1c9e7038688ee" translate="yes" xml:space="preserve">
          <source>Sprint</source>
          <target state="translated">Sprint</target>
        </trans-unit>
        <trans-unit id="d0775164f7f53356c293723cd9c1222468d3a49b" translate="yes" xml:space="preserve">
          <source>Sprint formats using the default formats for its operands and returns the resulting string. Spaces are added between operands when neither is a string.</source>
          <target state="translated">Sprint使用默认格式对操作数进行格式化,并返回结果字符串。当两个操作数都不是字符串时,操作数之间会添加空格。</target>
        </trans-unit>
        <trans-unit id="7d5fe7cc61bbb8158ad630a3820e3c126928a4a6" translate="yes" xml:space="preserve">
          <source>Sprintf</source>
          <target state="translated">Sprintf</target>
        </trans-unit>
        <trans-unit id="5bfb46358289368784772aa4aa5a217258b76236" translate="yes" xml:space="preserve">
          <source>Sprintf formats according to a format specifier and returns the resulting string.</source>
          <target state="translated">Sprintf根据格式指定器格式化并返回结果。</target>
        </trans-unit>
        <trans-unit id="5446f67533b2f88354fccb3b84fed81fd676a9d5" translate="yes" xml:space="preserve">
          <source>Sprintln</source>
          <target state="translated">Sprintln</target>
        </trans-unit>
        <trans-unit id="d0bd83b3300fd81e26aa39c136cc9d6ce11bb5a7" translate="yes" xml:space="preserve">
          <source>Sprintln formats using the default formats for its operands and returns the resulting string. Spaces are always added between operands and a newline is appended.</source>
          <target state="translated">Sprintln使用默认的操作数格式进行格式化,并返回结果。操作数之间总是加空格,并附加一个换行。</target>
        </trans-unit>
        <trans-unit id="6bbb118b36018412cea4de47bc914f00685c9ac5" translate="yes" xml:space="preserve">
          <source>Sqrt</source>
          <target state="translated">Sqrt</target>
        </trans-unit>
        <trans-unit id="1b795ae9b134bc8c4c0b446e88fecc1f3b41d092" translate="yes" xml:space="preserve">
          <source>Sqrt returns the square root of x.</source>
          <target state="translated">Sqrt 返回 x 的平方根。</target>
        </trans-unit>
        <trans-unit id="b85c9b396b0e4464f48aa17058f2b1082008ae70" translate="yes" xml:space="preserve">
          <source>Sqrt returns the square root of x. The result r is chosen so that real(r) &amp;ge; 0 and imag(r) has the same sign as imag(x).</source>
          <target state="translated">Sqrt返回x的平方根。选择结果r，以使real（r）&amp;ge;0且imag（r）具有与imag（x）相同的符号。</target>
        </trans-unit>
        <trans-unit id="41b5f4c2f86ca750aabbdd4d6bdb915be0584893" translate="yes" xml:space="preserve">
          <source>Sqrt sets z to &amp;lfloor;&amp;radic;x&amp;rfloor;, the largest integer such that z&amp;sup2; &amp;le; x, and returns z. It panics if x is negative.</source>
          <target state="translated">Sqrt将z设置为&amp;lfloor;&amp;radic;x&amp;rfloor;，即使得z&amp;sup2;&amp;le;x的最大整数，并返回z。如果x为负，则表示恐慌。</target>
        </trans-unit>
        <trans-unit id="2e519fcfbc6a90ddf75f1394fae55598d7af8898" translate="yes" xml:space="preserve">
          <source>Sqrt sets z to the rounded square root of x, and returns it.</source>
          <target state="translated">Sqrt 将 z 设为 x 的四舍五入平方根,并将其返回。</target>
        </trans-unit>
        <trans-unit id="b183229b8a0007179105ee23f98db0fa35e992ca" translate="yes" xml:space="preserve">
          <source>SrcDirs returns a list of package source root directories. It draws from the current Go root and Go path but omits directories that do not exist.</source>
          <target state="translated">SrcDirs 返回包的源根目录列表。它从当前的Go根目录和Go路径中提取,但省略不存在的目录。</target>
        </trans-unit>
        <trans-unit id="ace37ead62176f4b0fef73d8a4e6eefe6e4e0808" translate="yes" xml:space="preserve">
          <source>Srcset encapsulates a known safe srcset attribute (see &lt;a href=&quot;https://w3c.github.io/html/semantics-embedded-content.html#element-attrdef-img-srcset&quot;&gt;https://w3c.github.io/html/semantics-embedded-content.html#element-attrdef-img-srcset&lt;/a&gt;).</source>
          <target state="translated">Srcset封装了一个已知的安全srcset属性（请参阅&lt;a href=&quot;https://w3c.github.io/html/semantics-embedded-content.html#element-attrdef-img-srcset&quot;&gt;https://w3c.github.io/html/semantics-embedded-content.html#element-attrdef-img-srcset&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="608729966442ded3bea906aefa46d7a131fb981c" translate="yes" xml:space="preserve">
          <source>Sscan scans the argument string, storing successive space-separated values into successive arguments. Newlines count as space. It returns the number of items successfully scanned. If that is less than the number of arguments, err will report why.</source>
          <target state="translated">Sscan扫描参数字符串,将连续的空格分隔的值存储到连续的参数中。换行也算作空格。它返回成功扫描的项目数。如果少于参数数,err将报告原因。</target>
        </trans-unit>
        <trans-unit id="390342df3a9580b3ab53916d8e78ce9a67e05f51" translate="yes" xml:space="preserve">
          <source>Sscanf</source>
          <target state="translated">Sscanf</target>
        </trans-unit>
        <trans-unit id="61a716d2775c775cb5be05f41652e9aaaad32358" translate="yes" xml:space="preserve">
          <source>Sscanf scans the argument string, storing successive space-separated values into successive arguments as determined by the format. It returns the number of items successfully parsed. Newlines in the input must match newlines in the format.</source>
          <target state="translated">Sscanf扫描参数字符串,将连续的空格分隔的值存储到由格式决定的连续参数中。它返回成功解析的项数。输入中的换行必须与格式中的换行相匹配。</target>
        </trans-unit>
        <trans-unit id="af4732932dde6aa0c1e4ad7d04d2e2382ec0a0b6" translate="yes" xml:space="preserve">
          <source>Sscanln is similar to Sscan, but stops scanning at a newline and after the final item there must be a newline or EOF.</source>
          <target state="translated">Sscanln与Sscan类似,但在换行处停止扫描,最后一项后必须有换行或EOF。</target>
        </trans-unit>
        <trans-unit id="6f3e4b56a56750c728e3e2463bad931f8918a9d7" translate="yes" xml:space="preserve">
          <source>Stable sorts data while keeping the original order of equal elements.</source>
          <target state="translated">稳定地对数据进行排序,同时保持原有的等元素顺序。</target>
        </trans-unit>
        <trans-unit id="c9e8e2e8cb17ec7f99a9db77c101e60f6136c3a5" translate="yes" xml:space="preserve">
          <source>Stack formats a stack trace of the calling goroutine into buf and returns the number of bytes written to buf. If all is true, Stack formats stack traces of all other goroutines into buf after the trace for the current goroutine.</source>
          <target state="translated">Stack将调用的goroutine的堆栈跟踪格式化为buf,并返回写入buf的字节数。如果all为true,Stack将所有其他goroutine的堆栈跟踪格式化到当前goroutine跟踪之后的buf中。</target>
        </trans-unit>
        <trans-unit id="1cffafd303a34a6584721e138e5265f842cb505a" translate="yes" xml:space="preserve">
          <source>Stack returns a formatted stack trace of the goroutine that calls it. It calls runtime.Stack with a large enough buffer to capture the entire trace.</source>
          <target state="translated">Stack 返回调用它的 goroutine 的格式化栈跟踪。它调用runtime.Stack,并提供足够大的缓冲区来捕获整个跟踪。</target>
        </trans-unit>
        <trans-unit id="418aa94a169d739e57a35d99f93d9138e0bb4b62" translate="yes" xml:space="preserve">
          <source>Stack returns the stack trace associated with the record, a prefix of r.Stack0.</source>
          <target state="translated">Stack返回与记录相关的堆栈跟踪,是r.Stack0的前缀。</target>
        </trans-unit>
        <trans-unit id="687cb3d7c249eff01be44167736a622ba61578c9" translate="yes" xml:space="preserve">
          <source>Standard colors.</source>
          <target state="translated">标准色。</target>
        </trans-unit>
        <trans-unit id="360c57caedbd1d1ff38dde144677c893d6ad3792" translate="yes" xml:space="preserve">
          <source>Standard library</source>
          <target state="translated">标准库</target>
        </trans-unit>
        <trans-unit id="9fb1a9f741b4439135087b938ed47613619d8e54" translate="yes" xml:space="preserve">
          <source>Start enables tracing for the current program. While tracing, the trace will be buffered and written to w. Start returns an error if tracing is already enabled.</source>
          <target state="translated">Start启用了对当前程序的跟踪,在跟踪过程中,跟踪结果会被缓冲并写入w中。在跟踪过程中,跟踪将被缓冲,并写入w中。</target>
        </trans-unit>
        <trans-unit id="d84f21e1e9935e064f3eccc25d6db5d4fb64a86a" translate="yes" xml:space="preserve">
          <source>Start starts a server from NewUnstartedServer.</source>
          <target state="translated">Start从NewUnstartedServer启动一个服务器。</target>
        </trans-unit>
        <trans-unit id="b61ef15d781bf8c860427db7964980f61966535c" translate="yes" xml:space="preserve">
          <source>Start starts the specified command but does not wait for it to complete.</source>
          <target state="translated">Start启动指定的命令,但不等待其完成。</target>
        </trans-unit>
        <trans-unit id="7f51b09c0923a4603b545c471069b55e22a62f34" translate="yes" xml:space="preserve">
          <source>StartCPUProfile enables CPU profiling for the current process. While profiling, the profile will be buffered and written to w. StartCPUProfile returns an error if profiling is already enabled.</source>
          <target state="translated">StartCPUProfile启用了当前进程的CPU剖析。如果已经启用了CPU剖析,StartCPUProfile会返回一个错误。</target>
        </trans-unit>
        <trans-unit id="f3753321843c42ccf0d93028e612610280e12d5e" translate="yes" xml:space="preserve">
          <source>StartCond returns the leading empty-width conditions that must be true in any match. It returns ^EmptyOp(0) if no matches are possible.</source>
          <target state="translated">StartCond 返回任何匹配中必须为真的前导空宽条件。如果没有匹配,它返回^EmptyOp(0)。</target>
        </trans-unit>
        <trans-unit id="e00bec2778efe9f0a1a92501d76b773c7dc58166" translate="yes" xml:space="preserve">
          <source>StartProcess is a low-level interface. The os/exec package provides higher-level interfaces.</source>
          <target state="translated">StartProcess是一个低级接口。os/exec包提供了更高层次的接口。</target>
        </trans-unit>
        <trans-unit id="4656baf99c52e7677cc8f68ccbc8052e39ef42e9" translate="yes" xml:space="preserve">
          <source>StartProcess starts a new process with the program, arguments and attributes specified by name, argv and attr. The argv slice will become os.Args in the new process, so it normally starts with the program name.</source>
          <target state="translated">StartProcess 用 name、argv 和 attr 指定的程序、参数和属性启动一个新进程。argv 片段在新进程中会变成 os.Args,所以它通常以程序名开始。</target>
        </trans-unit>
        <trans-unit id="d3d2be7776a3d003cee77683d05001ec6ef09966" translate="yes" xml:space="preserve">
          <source>StartProcess wraps ForkExec for package os.</source>
          <target state="translated">StartProcess为包os.StartProcess封装了ForkExec。</target>
        </trans-unit>
        <trans-unit id="4593c93bfc9fb8dacabfc8b4a1731d4454969f64" translate="yes" xml:space="preserve">
          <source>StartRegion starts a region and returns a function for marking the end of the region. The returned Region's End function must be called from the same goroutine where the region was started. Within each goroutine, regions must nest. That is, regions started after this region must be ended before this region can be ended. Recommended usage is</source>
          <target state="translated">StartRegion启动一个区域,并返回一个用于标记区域结束的函数。返回的Region's End函数必须从启动该区域的同一个goroutine中调用。在每个goroutine中,区域必须嵌套。也就是说,在这个区域之后开始的区域必须在这个区域结束之前结束。推荐的用法是</target>
        </trans-unit>
        <trans-unit id="3b719a81fa9e5ddcbfba4cb3fb45c729f487d09e" translate="yes" xml:space="preserve">
          <source>StartRequest blocks until it is time to send (or, if this is a server, receive) the request with the given id.</source>
          <target state="translated">StartRequest阻塞,直到发送(或者,如果这是一个服务器,接收)给定id的请求的时候。</target>
        </trans-unit>
        <trans-unit id="338c8f94474f010aa4669ab2c0ae55a5c3a8c12a" translate="yes" xml:space="preserve">
          <source>StartResponse blocks until it is time to receive (or, if this is a server, send) the request with the given id.</source>
          <target state="translated">StartResponse阻塞,直到接收(或者,如果这是一个服务器,发送)给定id的请求。</target>
        </trans-unit>
        <trans-unit id="7ea714fe33f9c8708b382ac24930c9134895c05e" translate="yes" xml:space="preserve">
          <source>StartTLS sends the STARTTLS command and encrypts all further communication. Only servers that advertise the STARTTLS extension support this function.</source>
          <target state="translated">StartTLS发送STARTTLS命令,并对所有进一步的通信进行加密。只有宣传STARTTLS扩展的服务器才支持这个功能。</target>
        </trans-unit>
        <trans-unit id="d062840c5c4653552407064d11c812b2dfbbac16" translate="yes" xml:space="preserve">
          <source>StartTLS starts TLS on a server from NewUnstartedServer.</source>
          <target state="translated">StartTLS从NewUnstartedServer开始在服务器上启动TLS。</target>
        </trans-unit>
        <trans-unit id="01903002ac73fdbc83cec8f016e70281a8a03041" translate="yes" xml:space="preserve">
          <source>StartTimer starts timing a test. This function is called automatically before a benchmark starts, but it can also be used to resume timing after a call to StopTimer.</source>
          <target state="translated">StartTimer开始为测试计时。这个函数在基准开始前自动调用,但也可以在调用StopTimer后继续计时。</target>
        </trans-unit>
        <trans-unit id="bb33cf53f4e568db572c687d22b2ff2888d74df9" translate="yes" xml:space="preserve">
          <source>StartTrace enables tracing for the current process. While tracing, the data will be buffered and available via ReadTrace. StartTrace returns an error if tracing is already enabled. Most clients should use the runtime/trace package or the testing package's -test.trace flag instead of calling StartTrace directly.</source>
          <target state="translated">StartTrace可以对当前进程进行跟踪。在跟踪过程中,数据将被缓冲并通过ReadTrace提供。如果跟踪已经启用,StartTrace会返回一个错误。大多数客户端应该使用运行时/跟踪包或测试包的-test.trace标志,而不是直接调用StartTrace。</target>
        </trans-unit>
        <trans-unit id="6de552c394748272d237ee2909c17f8a5fd51503" translate="yes" xml:space="preserve">
          <source>Starting with Go 1.6, the http package has transparent support for the HTTP/2 protocol when using HTTPS. Programs that must disable HTTP/2 can do so by setting Transport.TLSNextProto (for clients) or Server.TLSNextProto (for servers) to a non-nil, empty map. Alternatively, the following GODEBUG environment variables are currently supported:</source>
          <target state="translated">从Go 1.6开始,当使用HTTPS时,http包对HTTP/2协议有透明的支持。必须禁用HTTP/2的程序可以通过将Transport.TLSNextProto(客户端)或Server.TLSNextProto(服务器)设置为非零的空映射来实现。另外,目前还支持以下GODEBUG环境变量。</target>
        </trans-unit>
        <trans-unit id="9c555084811f017d34d2693472b49bb062306f30" translate="yes" xml:space="preserve">
          <source>Stat returns a FileInfo describing the named file. If there is an error, it will be of type *PathError.</source>
          <target state="translated">Stat返回一个描述命名文件的FileInfo,如果有错误,它的类型是*PathError。如果有错误,它将是*PathError类型。</target>
        </trans-unit>
        <trans-unit id="e4a95458fc56105197c2a964b9366157865cbb1b" translate="yes" xml:space="preserve">
          <source>Stat returns the FileInfo structure describing file. If there is an error, it will be of type *PathError.</source>
          <target state="translated">Stat返回描述文件的FileInfo结构。如果有错误,它将是*PathError类型。</target>
        </trans-unit>
        <trans-unit id="6ed6c9c2af9ffd2ea1bfb59989c27d85db3a34df" translate="yes" xml:space="preserve">
          <source>State represents the printer state passed to custom formatters. It provides access to the io.Writer interface plus information about the flags and options for the operand's format specifier.</source>
          <target state="translated">State表示传递给自定义格式化器的打印机状态,它提供了对io.Writer接口的访问以及操作数的格式指定器的标志和选项信息。它提供了对io.Writer接口的访问,以及操作数格式指定器的标志和选项信息。</target>
        </trans-unit>
        <trans-unit id="6c898e0bae6ae6e6a509998b0d70b717982994c3" translate="yes" xml:space="preserve">
          <source>Static reports whether this symbol is static (not visible outside its file).</source>
          <target state="translated">静态报告这个符号是否是静态的(在其文件外不可见)。</target>
        </trans-unit>
        <trans-unit id="f107d6fd99e84eaeb4014efe73efa78374b13f61" translate="yes" xml:space="preserve">
          <source>Stats returns database statistics.</source>
          <target state="translated">Stats返回数据库统计数据。</target>
        </trans-unit>
        <trans-unit id="473cf8363b9a9dc6de8f9778203d0b0d99ffe820" translate="yes" xml:space="preserve">
          <source>StatusText returns a text for the HTTP status code. It returns the empty string if the code is unknown.</source>
          <target state="translated">StatusText返回HTTP状态码的文本。如果代码未知,则返回空字符串。</target>
        </trans-unit>
        <trans-unit id="d95efd4b66df751ef4f7e7c0d6a981a761feec31" translate="yes" xml:space="preserve">
          <source>StdEncoding is the standard base32 encoding, as defined in RFC 4648.</source>
          <target state="translated">StdEncoding是RFC 4648中定义的标准base32编码。</target>
        </trans-unit>
        <trans-unit id="a9197d0bbe7d5f346c8fce4d5958e4af36331be4" translate="yes" xml:space="preserve">
          <source>StdEncoding is the standard base64 encoding, as defined in RFC 4648.</source>
          <target state="translated">StdEncoding是RFC 4648中定义的标准base64编码。</target>
        </trans-unit>
        <trans-unit id="c30cba7f2a4c150acfe65c8a3aa36a9ff709ad57" translate="yes" xml:space="preserve">
          <source>StdSizes is a convenience type for creating commonly used Sizes. It makes the following simplifying assumptions:</source>
          <target state="translated">StdSizes是一个方便的类型,用于创建常用的Sizes。它做了以下简化假设。</target>
        </trans-unit>
        <trans-unit id="34f196b4b0f694cd0a2f21247970027005c1305c" translate="yes" xml:space="preserve">
          <source>StderrPipe returns a pipe that will be connected to the command's standard error when the command starts.</source>
          <target state="translated">StderrPipe返回一个管道,当命令启动时,该管道将连接到命令的标准错误。</target>
        </trans-unit>
        <trans-unit id="f9c5224ebb81b29f683fd0f89569f0498e209b24" translate="yes" xml:space="preserve">
          <source>Stdin, Stdout, and Stderr are open Files pointing to the standard input, standard output, and standard error file descriptors.</source>
          <target state="translated">Stdin、Stdout和Stderr是指向标准输入、标准输出和标准错误文件描述符的开放文件。</target>
        </trans-unit>
        <trans-unit id="eaaa7d5358fae0ad4ea6507594efa4e1fe1938f3" translate="yes" xml:space="preserve">
          <source>StdinPipe returns a pipe that will be connected to the command's standard input when the command starts. The pipe will be closed automatically after Wait sees the command exit. A caller need only call Close to force the pipe to close sooner. For example, if the command being run will not exit until standard input is closed, the caller must close the pipe.</source>
          <target state="translated">StdinPipe 返回一个管道,当命令启动时,该管道将连接到命令的标准输入。在Wait看到命令退出后,管道将自动关闭。调用者只需要调用Close就可以强制管道提前关闭。例如,如果正在运行的命令在标准输入关闭之前不会退出,调用者必须关闭管道。</target>
        </trans-unit>
        <trans-unit id="e34e1f63d532ddcb966f6992c5d243530bff512e" translate="yes" xml:space="preserve">
          <source>StdoutPipe returns a pipe that will be connected to the command's standard output when the command starts.</source>
          <target state="translated">StdoutPipe返回一个管道,当命令启动时,该管道将连接到命令的标准输出。</target>
        </trans-unit>
        <trans-unit id="35cb1f2f3090469fddd290f48f6f6f66f6cfbf71" translate="yes" xml:space="preserve">
          <source>Stmt</source>
          <target state="translated">Stmt</target>
        </trans-unit>
        <trans-unit id="e8d756b195575772804ef522d92696943863af82" translate="yes" xml:space="preserve">
          <source>Stmt is a prepared statement. A Stmt is safe for concurrent use by multiple goroutines.</source>
          <target state="translated">Stmt是一个准备好的语句。一个Stmt可以安全地被多个goroutine同时使用。</target>
        </trans-unit>
        <trans-unit id="0bb26a3ab8d8618ecc81beec5115670b66a970d5" translate="yes" xml:space="preserve">
          <source>Stmt is a prepared statement. It is bound to a Conn and not used by multiple goroutines concurrently.</source>
          <target state="translated">Stmt是一个准备好的语句。它与Conn绑定,不能被多个goroutine同时使用。</target>
        </trans-unit>
        <trans-unit id="9e8123e57a051d77d8becac273756b24f947f7c4" translate="yes" xml:space="preserve">
          <source>Stmt returns a transaction-specific prepared statement from an existing statement.</source>
          <target state="translated">Stmt从现有的报表中返回一个特定事务的预备报表。</target>
        </trans-unit>
        <trans-unit id="9e2e6090b163c6036190ffea94ddcfbb24b8b882" translate="yes" xml:space="preserve">
          <source>Stmt.QueryRowContext</source>
          <target state="translated">Stmt.QueryRowContext</target>
        </trans-unit>
        <trans-unit id="70af1d64e33ba2bc94ac6b94c7823d3046a2e685" translate="yes" xml:space="preserve">
          <source>StmtContext returns a transaction-specific prepared statement from an existing statement.</source>
          <target state="translated">StmtContext从现有的语句中返回一个特定事务的准备语句。</target>
        </trans-unit>
        <trans-unit id="a70153fdc2043d42cd12ca46ccb4c33b57b300d4" translate="yes" xml:space="preserve">
          <source>StmtExecContext enhances the Stmt interface by providing Exec with context.</source>
          <target state="translated">StmtExecContext通过为Exec提供上下文来增强Stmt接口。</target>
        </trans-unit>
        <trans-unit id="1004fd52a4b277314a44a4efa023effe4416d3f8" translate="yes" xml:space="preserve">
          <source>StmtQueryContext enhances the Stmt interface by providing Query with context.</source>
          <target state="translated">StmtQueryContext通过提供具有上下文的Query来增强Stmt接口。</target>
        </trans-unit>
        <trans-unit id="4e7e607354865ab06dac634d86cb1266a005b9e3" translate="yes" xml:space="preserve">
          <source>Stop causes package signal to stop relaying incoming signals to c. It undoes the effect of all prior calls to Notify using c. When Stop returns, it is guaranteed that c will receive no more signals.</source>
          <target state="translated">Stop使包信号停止向c中继传入信号,并撤销之前所有使用c调用Notify的效果,当Stop返回时,保证c不再接收信号。</target>
        </trans-unit>
        <trans-unit id="94f72ec5a9e9e46f0269677088e9aed4dc6bf0c7" translate="yes" xml:space="preserve">
          <source>Stop prevents the Timer from firing. It returns true if the call stops the timer, false if the timer has already expired or been stopped. Stop does not close the channel, to prevent a read from the channel succeeding incorrectly.</source>
          <target state="translated">Stop阻止定时器发射。如果调用停止定时器,则返回true,如果定时器已经过期或被停止,则返回false。Stop不关闭通道,以防止从通道中读取的数据不正确地成功。</target>
        </trans-unit>
        <trans-unit id="96e4cceff229f7d0b6242e33e40b44c6e1f954ad" translate="yes" xml:space="preserve">
          <source>Stop stops the current tracing, if any. Stop only returns after all the writes for the trace have completed.</source>
          <target state="translated">停止当前的跟踪,如果有的话。Stop只在所有跟踪的写入完成后才返回。</target>
        </trans-unit>
        <trans-unit id="f869959cdbddc758676d9a0b40b1ccec00a007e0" translate="yes" xml:space="preserve">
          <source>Stop turns off a ticker. After Stop, no more ticks will be sent. Stop does not close the channel, to prevent a concurrent goroutine reading from the channel from seeing an erroneous &quot;tick&quot;.</source>
          <target state="translated">停止关闭一个行情。停止后,将不再发送更多的 &quot;tick&quot;。停止不会关闭通道,以防止同时从通道读取的goroutine看到一个错误的 &quot;tick&quot;。</target>
        </trans-unit>
        <trans-unit id="6c60cc11ce6206ba7285eea9b92d5192efe41d39" translate="yes" xml:space="preserve">
          <source>StopCPUProfile stops the current CPU profile, if any. StopCPUProfile only returns after all the writes for the profile have completed.</source>
          <target state="translated">StopCPUProfile停止当前CPU配置文件(如果有的话)。StopCPUProfile只有在配置文件的所有写入完成后才会返回。</target>
        </trans-unit>
        <trans-unit id="921647073cddc48eae81cacd6f73563cc3719e6f" translate="yes" xml:space="preserve">
          <source>StopTimer stops timing a test. This can be used to pause the timer while performing complex initialization that you don't want to measure.</source>
          <target state="translated">StopTimer停止测试计时。这可以用来在执行复杂的初始化时暂停定时器,而你不想测量。</target>
        </trans-unit>
        <trans-unit id="84dbe4eb021745433f9d6bb9432228e77ba19099" translate="yes" xml:space="preserve">
          <source>StopTrace stops tracing, if it was previously enabled. StopTrace only returns after all the reads for the trace have completed.</source>
          <target state="translated">如果之前启用了StopTrace,则停止跟踪。StopTrace只在所有跟踪的读取完成后才返回。</target>
        </trans-unit>
        <trans-unit id="e64cf11d9830120b60f240aa4b7f7791804376a7" translate="yes" xml:space="preserve">
          <source>Store sets the value for a key.</source>
          <target state="translated">存储设置一个键的值。</target>
        </trans-unit>
        <trans-unit id="0576297e57bdd6afa5e5d4f4c53fb27987cf20cb" translate="yes" xml:space="preserve">
          <source>Store sets the value of the Value to x. All calls to Store for a given Value must use values of the same concrete type. Store of an inconsistent type panics, as does Store(nil).</source>
          <target state="translated">Store 将 Value 的值设置为 x。对给定 Value 的所有 Store 调用必须使用相同具体类型的值。类型不一致的Store会惊慌失措,Store(nil)也是如此。</target>
        </trans-unit>
        <trans-unit id="61fc43e10839248a6ca4c0ad01079c0c4ad0ec37" translate="yes" xml:space="preserve">
          <source>StoreInt32 atomically stores val into *addr.</source>
          <target state="translated">StoreInt32原子地将val存储到*addr中。</target>
        </trans-unit>
        <trans-unit id="7914e40a268c91ed6c78dd3a0c674684e23beca2" translate="yes" xml:space="preserve">
          <source>StoreInt64 atomically stores val into *addr.</source>
          <target state="translated">StoreInt64原子地将val存储到*addr中。</target>
        </trans-unit>
        <trans-unit id="3bd4e783553f00f03c188a415e3661fa8de191b3" translate="yes" xml:space="preserve">
          <source>StorePointer atomically stores val into *addr.</source>
          <target state="translated">StorePointer原子地将val存储到*addr中。</target>
        </trans-unit>
        <trans-unit id="9cc88c9dca1de73040dfd90e6d827a5b531c64fe" translate="yes" xml:space="preserve">
          <source>StoreUint32 atomically stores val into *addr.</source>
          <target state="translated">StoreUint32原子地将val存储到*addr中。</target>
        </trans-unit>
        <trans-unit id="e11c1fe521ea309905b20e2bda18135e66472a1e" translate="yes" xml:space="preserve">
          <source>StoreUint64 atomically stores val into *addr.</source>
          <target state="translated">StoreUint64原子地将val存储到*addr中。</target>
        </trans-unit>
        <trans-unit id="644096d645019d8a2ba6cbc4d305a2699fe9059f" translate="yes" xml:space="preserve">
          <source>StoreUintptr atomically stores val into *addr.</source>
          <target state="translated">StoreUintptr原子地将val存储到*addr中。</target>
        </trans-unit>
        <trans-unit id="cab8594aca23f91dcc0728ca91d9d20dcd26b690" translate="yes" xml:space="preserve">
          <source>StreamReader</source>
          <target state="translated">StreamReader</target>
        </trans-unit>
        <trans-unit id="2a7fc943079fc92f6a989794ba51133e347d57cd" translate="yes" xml:space="preserve">
          <source>StreamReader wraps a Stream into an io.Reader. It calls XORKeyStream to process each slice of data which passes through.</source>
          <target state="translated">StreamReader将一个Stream包装成一个io.Reader。它调用XORKeyStream来处理每个经过的数据片断。</target>
        </trans-unit>
        <trans-unit id="232a89f73446348f72f684c82d07ed788b848a3a" translate="yes" xml:space="preserve">
          <source>StreamWriter</source>
          <target state="translated">StreamWriter</target>
        </trans-unit>
        <trans-unit id="fc13aaf005c735ab0e4aa5176b6af67540be3a8b" translate="yes" xml:space="preserve">
          <source>StreamWriter wraps a Stream into an io.Writer. It calls XORKeyStream to process each slice of data which passes through. If any Write call returns short then the StreamWriter is out of sync and must be discarded. A StreamWriter has no internal buffering; Close does not need to be called to flush write data.</source>
          <target state="translated">StreamWriter将一个Stream包装成一个io.Writer,它调用XORKeyStream来处理每个经过的数据片断。它调用XORKeyStream来处理每个经过的数据片断。如果任何Write调用都返回短路,那么StreamWriter就失去了同步,必须被丢弃。StreamWriter没有内部缓冲;Close不需要被调用来刷新写数据。</target>
        </trans-unit>
        <trans-unit id="61135993a6e29b59a8df3075ca0d3838f94b8d90" translate="yes" xml:space="preserve">
          <source>Strict creates a new encoding identical to enc except with strict decoding enabled. In this mode, the decoder requires that trailing padding bits are zero, as described in RFC 4648 section 3.5.</source>
          <target state="translated">Strict创建一个与enc相同的新编码,除了启用严格的解码。在这种模式下,解码器要求尾部填充位为零,如RFC 4648第3.5节所述。</target>
        </trans-unit>
        <trans-unit id="396b00d6c7e8c1194e27297cd11ae3108cdacd84" translate="yes" xml:space="preserve">
          <source>String Conversions</source>
          <target state="translated">字符串转换</target>
        </trans-unit>
        <trans-unit id="bd47be7c94487cbe10dfe0be4138815d0017463a" translate="yes" xml:space="preserve">
          <source>String and slice of bytes (treated equivalently with these verbs):</source>
          <target state="translated">字节串和字节片(与这些动词等价处理)。</target>
        </trans-unit>
        <trans-unit id="8296a76a0e5d96744b29fe69547a88fb9387440d" translate="yes" xml:space="preserve">
          <source>String defines a string flag with specified name, default value, and usage string. The return value is the address of a string variable that stores the value of the flag.</source>
          <target state="translated">String定义了一个字符串标志,具有指定的名称、默认值和用法字符串。返回值是存储标志值的字符串变量的地址。</target>
        </trans-unit>
        <trans-unit id="9e4dec141cb0219423f92167f6932232e80cdb9e" translate="yes" xml:space="preserve">
          <source>String extracts string from COFF string table st at offset start.</source>
          <target state="translated">字符串从偏移量开始的COFF字符串表st中提取字符串。</target>
        </trans-unit>
        <trans-unit id="dcd688eb0f2fbd5e407777a28042b64595f0fef8" translate="yes" xml:space="preserve">
          <source>String formats the address as a valid RFC 5322 address. If the address's name contains non-ASCII characters the name will be rendered according to RFC 2047.</source>
          <target state="translated">字符串将地址格式化为有效的RFC 5322地址。如果地址名称中包含非ASCII字符,则将根据RFC 2047的规定进行处理。</target>
        </trans-unit>
        <trans-unit id="8d105c469495a5d5f8062e63371ab613869f1e04" translate="yes" xml:space="preserve">
          <source>String formats x like x.Text('g', 10). (String must be called explicitly, Float.Format does not support %s verb.)</source>
          <target state="translated">字符串格式化x,如x.Text('g',10)。(String必须被显式调用,Float.Format不支持%s动词。)</target>
        </trans-unit>
        <trans-unit id="01748cd6407645feded183980c6258bbb0d669e6" translate="yes" xml:space="preserve">
          <source>String implements the Var interface. To get the unquoted string use Value.</source>
          <target state="translated">String实现了Var接口。要获得未引号的字符串,请使用Value.Value接口。</target>
        </trans-unit>
        <trans-unit id="c388848919b90e3a01d2d3408f1ebde77b3f2a74" translate="yes" xml:space="preserve">
          <source>String is a ValueConverter that converts its input to a string. If the value is already a string or []byte, it's unchanged. If the value is of another type, conversion to string is done with fmt.Sprintf(&quot;%v&quot;, v).</source>
          <target state="translated">String是一个ValueConverter,它将其输入转换为一个字符串。如果值已经是一个字符串或[]字节,它就不会改变。如果值是其他类型,则用fmt.Sprintf(&quot;%v&quot;,v)转换为字符串。</target>
        </trans-unit>
        <trans-unit id="014933e8c2aa543fd850622d80731a6a9386778b" translate="yes" xml:space="preserve">
          <source>String is a string variable, and satisfies the Var interface.</source>
          <target state="translated">String是一个字符串变量,并满足Var接口。</target>
        </trans-unit>
        <trans-unit id="83826ec6cada0ae1502e1aff2c5460723f559354" translate="yes" xml:space="preserve">
          <source>String reassembles the URL into a valid URL string. The general form of the result is one of:</source>
          <target state="translated">String将URL重新组合成一个有效的URL字符串。结果的一般形式是:。</target>
        </trans-unit>
        <trans-unit id="1a1a1e5164ab79c22ae49942d67ef810bdba6ad9" translate="yes" xml:space="preserve">
          <source>String returns a descriptive name for the time zone information, corresponding to the name argument to LoadLocation or FixedZone.</source>
          <target state="translated">字符串返回时区信息的描述性名称,对应于LoadLocation或FixedZone的名称参数。</target>
        </trans-unit>
        <trans-unit id="aa4d82115db66e350e92f539c5427c79fdfb58ed" translate="yes" xml:space="preserve">
          <source>String returns a human-readable description of c. It is intended only for debugging. In particular, it is not suitable for use as input to a shell. The output of String may vary across Go releases.</source>
          <target state="translated">String 返回 c 的可读描述,它只用于调试。特别是,它不适合作为shell的输入。String 的输出在不同的 Go 版本中可能会有所不同。</target>
        </trans-unit>
        <trans-unit id="55bb95d4983983ad2bde74eafe604eb90028dc18" translate="yes" xml:space="preserve">
          <source>String returns a string in one of several forms:</source>
          <target state="translated">String以几种形式之一返回一个字符串。</target>
        </trans-unit>
        <trans-unit id="345f70fca28ee043619061f7f87c019dadbba1fa" translate="yes" xml:space="preserve">
          <source>String returns a string representation of p like &quot;(3,4)&quot;.</source>
          <target state="translated">String 返回 p 的字符串表示,如&quot;(3,4)&quot;。</target>
        </trans-unit>
        <trans-unit id="3448960ebb659e656c5021f0b36127dab5b9d619" translate="yes" xml:space="preserve">
          <source>String returns a string representation of r like &quot;(3,4)-(6,5)&quot;.</source>
          <target state="translated">String 返回 r 的字符串表示,如&quot;(3,4)-(6,5)&quot;。</target>
        </trans-unit>
        <trans-unit id="1b35bdca294966810231e9db40a5c473f629af73" translate="yes" xml:space="preserve">
          <source>String returns a string representation of the scope, for debugging.</source>
          <target state="translated">String 返回范围的字符串表示,用于调试。</target>
        </trans-unit>
        <trans-unit id="40800a9640894f3a3149f9e54d890572a4beda8c" translate="yes" xml:space="preserve">
          <source>String returns a string representation of the sequence r, roughly following the RFC 2253 Distinguished Names syntax.</source>
          <target state="translated">String返回序列r的字符串表示,大致遵循RFC 2253区分名语法。</target>
        </trans-unit>
        <trans-unit id="7a196811cde011797851e8bcd4ea585d5971e7d9" translate="yes" xml:space="preserve">
          <source>String returns a string representation of x in the form &quot;a/b&quot; (even if b == 1).</source>
          <target state="translated">String以 &quot;a/b &quot;的形式返回x的字符串表示(即使b ==1)。</target>
        </trans-unit>
        <trans-unit id="7b4474871a59eadc44e6ad3cc370b5d1fd6eabd1" translate="yes" xml:space="preserve">
          <source>String returns a string representing the duration in the form &quot;72h3m0.5s&quot;. Leading zero units are omitted. As a special case, durations less than one second format use a smaller unit (milli-, micro-, or nanoseconds) to ensure that the leading digit is non-zero. The zero duration formats as 0s.</source>
          <target state="translated">String 返回表示持续时间的字符串,格式为 &quot;72h3m0.5s&quot;。前导零单位被省略。作为一种特殊情况,小于一秒的持续时间格式使用较小的单位(毫秒、微秒或纳秒),以确保前导数字是非零。零持续时间格式为0s。</target>
        </trans-unit>
        <trans-unit id="f5e00dac202df16525dc65e74932811ab9752d4e" translate="yes" xml:space="preserve">
          <source>String returns a summary of the benchmark results. It follows the benchmark result line format from &lt;a href=&quot;https://golang.org/design/14313-benchmark-format&quot;&gt;https://golang.org/design/14313-benchmark-format&lt;/a&gt;, not including the benchmark name. Extra metrics override built-in metrics of the same name. String does not include allocs/op or B/op, since those are reported by MemString.</source>
          <target state="translated">String返回基准测试结果的摘要。它遵循&lt;a href=&quot;https://golang.org/design/14313-benchmark-format&quot;&gt;https://golang.org/design/14313-benchmark-format中&lt;/a&gt;的基准结果行格式，不包括基准名称。额外的指标会覆盖同名的内置指标。字符串不包括allocs / op或B / op，因为这些是由MemString报告的。</target>
        </trans-unit>
        <trans-unit id="a1320f96272e68242e45787bdcf443a45a5d4acb" translate="yes" xml:space="preserve">
          <source>String returns the CIDR notation of n like &quot;192.0.2.0/24&quot; or &quot;2001:db8::/48&quot; as defined in RFC 4632 and RFC 4291. If the mask is not in the canonical form, it returns the string which consists of an IP address, followed by a slash character and a mask expressed as hexadecimal form with no punctuation like &quot;198.51.100.0/c000ff00&quot;.</source>
          <target state="translated">String 返回 RFC 4632 和 RFC 4291 中定义的 n 的 CIDR 符号,如 &quot;192.0.2.0/24 &quot;或 &quot;2001:db8::/48&quot;。如果掩码不是规范形式,则返回由IP地址组成的字符串,后面是一个斜杠字符和一个以十六进制形式表示的掩码,没有标点符号,如 &quot;198.51.100.0/c000ff00&quot;。</target>
        </trans-unit>
        <trans-unit id="f55b73801df68c7614969aee1732afd9d5e38010" translate="yes" xml:space="preserve">
          <source>String returns the English name of the day (&quot;Sunday&quot;, &quot;Monday&quot;, ...).</source>
          <target state="translated">字符串返回当天的英文名称(&quot;Sunday&quot;,&quot;Monday&quot;,...)。</target>
        </trans-unit>
        <trans-unit id="ffc4d02cde72706d98e09a395ce956d9d89dd7b5" translate="yes" xml:space="preserve">
          <source>String returns the English name of the month (&quot;January&quot;, &quot;February&quot;, ...).</source>
          <target state="translated">字符串返回月份的英文名称(&quot;January&quot;,&quot;February&quot;,...)。</target>
        </trans-unit>
        <trans-unit id="d35cab9a7681d28fe5cfa98797f716ccf4a8148e" translate="yes" xml:space="preserve">
          <source>String returns the accumulated string.</source>
          <target state="translated">String 返回累积的字符串。</target>
        </trans-unit>
        <trans-unit id="6a561a9c0ca3a5d45a6220d79144ae4e4f68eaba" translate="yes" xml:space="preserve">
          <source>String returns the contents of the unread portion of the buffer as a string. If the Buffer is a nil pointer, it returns &quot;&amp;lt;nil&amp;gt;&quot;.</source>
          <target state="translated">String以字符串形式返回缓冲区未读部分的内容。如果Buffer是nil指针，则返回&amp;ldquo; &amp;lt;nil&amp;gt;&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="20281079c25e7469dba253811f0a64eb9af0ad50" translate="yes" xml:space="preserve">
          <source>String returns the decimal representation of x as generated by x.Text(10).</source>
          <target state="translated">String 返回 x.Text(10)所生成的 x 的十进制表示。</target>
        </trans-unit>
        <trans-unit id="c1f7f34151f59a07d632aef98f6cf3db75ca331f" translate="yes" xml:space="preserve">
          <source>String returns the encoded userinfo information in the standard form of &quot;username[:password]&quot;.</source>
          <target state="translated">字符串返回标准格式为 &quot;username[:password]&quot;的编码用户信息。</target>
        </trans-unit>
        <trans-unit id="c9f4b613c07a2c7f71577fe196567617d0abff90" translate="yes" xml:space="preserve">
          <source>String returns the hexadecimal form of m, with no punctuation.</source>
          <target state="translated">字符串返回m的十六进制形式,不含标点符号。</target>
        </trans-unit>
        <trans-unit id="a803d186b1c90a1c53ad70e26c40836efc312842" translate="yes" xml:space="preserve">
          <source>String returns the literal text of the number.</source>
          <target state="translated">字符串返回数字的文字。</target>
        </trans-unit>
        <trans-unit id="efd718d51f4b6dbacf2db82a320892ae4b63a670" translate="yes" xml:space="preserve">
          <source>String returns the name of k.</source>
          <target state="translated">字符串返回k的名称。</target>
        </trans-unit>
        <trans-unit id="750dd1515ee90a846665f6d5d112993b3669e476" translate="yes" xml:space="preserve">
          <source>String returns the name of the transaction isolation level.</source>
          <target state="translated">字符串返回事务隔离级别的名称。</target>
        </trans-unit>
        <trans-unit id="e794984ac30a476fc607ba49d30074600724b1fd" translate="yes" xml:space="preserve">
          <source>String returns the serialization of the cookie for use in a Cookie header (if only Name and Value are set) or a Set-Cookie response header (if other fields are set). If c is nil or c.Name is invalid, the empty string is returned.</source>
          <target state="translated">String返回Cookie的序列化,用于Cookie头(如果只设置了Name和Value)或Set-Cookie响应头(如果设置了其他字段)。如果c为nil或c.Name无效,将返回空字符串。</target>
        </trans-unit>
        <trans-unit id="fe713a69a5fd2ac5cb84c706517fb895d0d57913" translate="yes" xml:space="preserve">
          <source>String returns the source text used to compile the regular expression.</source>
          <target state="translated">字符串返回用于编译正则表达式的源文本。</target>
        </trans-unit>
        <trans-unit id="34bacca8ec4eef4ee78833a67f79a6eef6da5be0" translate="yes" xml:space="preserve">
          <source>String returns the string corresponding to the token tok. For operators, delimiters, and keywords the string is the actual token character sequence (e.g., for the token ADD, the string is &quot;+&quot;). For all other tokens the string corresponds to the token constant name (e.g. for the token IDENT, the string is &quot;IDENT&quot;).</source>
          <target state="translated">String 返回对应于标记标记的字符串。对于运算符、定界符和关键字,字符串是实际的标记字符序列(例如,对于标记ADD,字符串是 &quot;+&quot;)。对于所有其他标记,该字符串对应于标记常量名称(例如,对于标记IDENT,字符串为 &quot;IDENT&quot;)。</target>
        </trans-unit>
        <trans-unit id="2d88168daac6375a514f336433bd215fb612a6a9" translate="yes" xml:space="preserve">
          <source>String returns the string form of n, roughly following the RFC 2253 Distinguished Names syntax.</source>
          <target state="translated">String 返回 n 的字符串形式,大致遵循 RFC 2253 Distinguished Names 语法。</target>
        </trans-unit>
        <trans-unit id="65a433aa544a0c7b3431068c5cc7f107bc02e8c8" translate="yes" xml:space="preserve">
          <source>String returns the string form of the IP address ip. It returns one of 4 forms:</source>
          <target state="translated">String 返回 IP 地址的字符串形式。它返回4种形式之一。</target>
        </trans-unit>
        <trans-unit id="77e4b34a03bfe1d41ef0627a6a3eef76345118dd" translate="yes" xml:space="preserve">
          <source>String returns the string v's underlying value, as a string. String is a special case because of Go's String method convention. Unlike the other getters, it does not panic if v's Kind is not String. Instead, it returns a string of the form &quot;&amp;lt;T value&amp;gt;&quot; where T is v's type. The fmt package treats Values specially. It does not call their String method implicitly but instead prints the concrete values they hold.</source>
          <target state="translated">String以字符串形式返回字符串v的基础值。由于Go的String方法约定，String是一种特殊情况。与其他吸气剂不同，如果v的Kind不是String，它不会惊慌。而是返回形式为&amp;ldquo; &amp;lt;T value&amp;gt;&amp;rdquo;的字符串，其中T是v的类型。fmt包特别对待Values。它不会隐式调用其String方法，而是打印它们持有的具体值。</target>
        </trans-unit>
        <trans-unit id="da3ada59fed13cf9c42e28f35ce824b152ed6695" translate="yes" xml:space="preserve">
          <source>String returns the time formatted using the format string</source>
          <target state="translated">字符串返回使用字符串格式化的时间。</target>
        </trans-unit>
        <trans-unit id="7582d0695c8835ce2d6fd48b6b11691af0fd874b" translate="yes" xml:space="preserve">
          <source>String returns the value v as a string. String is a special case because of Go's String method convention. Unlike the other getters, it does not panic if v's Type is not TypeString. Instead, it returns a string of the form &quot;&amp;lt;T&amp;gt;&quot; or &quot;&amp;lt;T: V&amp;gt;&quot; where T is v's type and V is a string representation of v's value.</source>
          <target state="translated">字符串返回值v作为字符串。由于Go的String方法约定，String是一种特殊情况。与其他吸气剂不同，如果v的Type不是TypeString，它不会惊慌。而是返回格式为&amp;ldquo; &amp;lt;T&amp;gt;&amp;rdquo;或&amp;ldquo; &amp;lt;T：V&amp;gt;&amp;rdquo;的字符串，其中T是v的类型，V是v的值的字符串表示形式。</target>
        </trans-unit>
        <trans-unit id="b5780fb112a6b774b6985415c1ab7539f30b0d21" translate="yes" xml:space="preserve">
          <source>String values encode as JSON strings coerced to valid UTF-8, replacing invalid bytes with the Unicode replacement rune. So that the JSON will be safe to embed inside HTML &amp;lt;script&amp;gt; tags, the string is encoded using HTMLEscape, which replaces &quot;&amp;lt;&quot;, &quot;&amp;gt;&quot;, &quot;&amp;amp;&quot;, U+2028, and U+2029 are escaped to &quot;\u003c&quot;,&quot;\u003e&quot;, &quot;\u0026&quot;, &quot;\u2028&quot;, and &quot;\u2029&quot;. This replacement can be disabled when using an Encoder, by calling SetEscapeHTML(false).</source>
          <target state="translated">字符串值编码为强制转换为有效UTF-8的JSON字符串，用Unicode替换符文替换无效字节。为了使JSON可以安全地嵌入到HTML &amp;lt;script&amp;gt;标记中，该字符串使用HTMLEscape编码，替换为&amp;ldquo; &amp;lt;&amp;rdquo;，&amp;ldquo;&amp;gt;&amp;rdquo;，&amp;ldquo;＆&amp;rdquo;，U + 2028和U + 2029的HTMLEscape转义为&amp;ldquo; \ u003c&amp;rdquo;，&amp;ldquo; \ u003e&amp;rdquo;，&amp;ldquo; \ u0026&amp;rdquo;，&amp;ldquo; \ u2028&amp;rdquo;和&amp;ldquo; \ u2029&amp;rdquo;。使用编码器时，可以通过调用SetEscapeHTML（false）禁用此替换。</target>
        </trans-unit>
        <trans-unit id="86940bb85d221e97a38bc1e113fc6bce034c8750" translate="yes" xml:space="preserve">
          <source>StringBytePtr returns a pointer to a NUL-terminated array of bytes. If s contains a NUL byte this function panics instead of returning an error.</source>
          <target state="translated">StringBytePtr返回一个指向NUL结束的字节数组的指针。如果s中包含一个NUL字节,这个函数就会惊慌失措,而不是返回一个错误。</target>
        </trans-unit>
        <trans-unit id="c0623ccf68cc35082d287f89796544274ff86c91" translate="yes" xml:space="preserve">
          <source>StringByteSlice converts a string to a NUL-terminated []byte, If s contains a NUL byte this function panics instead of returning an error.</source>
          <target state="translated">StringByteSlice将一个字符串转换为一个NUL结尾的[]字节,如果s包含一个NUL字节,这个函数就会恐慌,而不是返回一个错误。</target>
        </trans-unit>
        <trans-unit id="6bf1e10cb60d4363fb37f7da731443afa2a654e2" translate="yes" xml:space="preserve">
          <source>StringHeader is the runtime representation of a string. It cannot be used safely or portably and its representation may change in a later release. Moreover, the Data field is not sufficient to guarantee the data it references will not be garbage collected, so programs must keep a separate, correctly typed pointer to the underlying data.</source>
          <target state="translated">StringHeader是字符串的运行时表示。它不能被安全地或可移植地使用,它的表示方式可能在以后的版本中发生变化。此外,Data字段不足以保证它所引用的数据不会被垃圾回收,所以程序必须保留一个单独的、正确类型的指针,指向底层数据。</target>
        </trans-unit>
        <trans-unit id="a97933503d7359e70c5bcc6d71f20f23e72ff484" translate="yes" xml:space="preserve">
          <source>StringNode holds a string constant. The value has been &quot;unquoted&quot;.</source>
          <target state="translated">StringNode持有一个字符串常量。该值已被 &quot;未引号&quot;。</target>
        </trans-unit>
        <trans-unit id="4e2dc56d882f4e247f4c8c91d09f7ca7c92151b0" translate="yes" xml:space="preserve">
          <source>StringSlice attaches the methods of Interface to []string, sorting in increasing order.</source>
          <target state="translated">StringSlice将Interface的方法附加到[]string上,按递增顺序排序。</target>
        </trans-unit>
        <trans-unit id="0ccdd69f6b44471ac8719f7a4d5092264f1d1540" translate="yes" xml:space="preserve">
          <source>StringSlicePtr converts a slice of strings to a slice of pointers to NUL-terminated byte arrays. If any string contains a NUL byte this function panics instead of returning an error.</source>
          <target state="translated">StringSlicePtr将一个字符串切片转换为一个指向NUL结尾的字节数组的切片。如果任何字符串包含一个NUL字节,这个函数就会惊慌失措,而不是返回一个错误。</target>
        </trans-unit>
        <trans-unit id="58cd2c4c0c64b3e8b63116e619c1216921aee8f5" translate="yes" xml:space="preserve">
          <source>StringTable is a COFF string table.</source>
          <target state="translated">StringTable是一个COFF字符串表。</target>
        </trans-unit>
        <trans-unit id="cf2c21cf4463c1c95fd9d9c1165bec97a40c80e4" translate="yes" xml:space="preserve">
          <source>StringVal returns the Go string value of x, which must be a String or an Unknown. If x is Unknown, the result is &quot;&quot;.</source>
          <target state="translated">StringVal 返回 x 的 Go 字符串值,它必须是一个字符串或一个 Unknown。如果x是未知值,结果是&quot;&quot;。</target>
        </trans-unit>
        <trans-unit id="d9073eff948f092d1e822cdc4b90545ac7f58c79" translate="yes" xml:space="preserve">
          <source>StringVar defines a string flag with specified name, default value, and usage string. The argument p points to a string variable in which to store the value of the flag.</source>
          <target state="translated">StringVar定义了一个字符串标志,具有指定的名称、默认值和用法字符串。参数p指向一个字符串变量,用来存储标志的值。</target>
        </trans-unit>
        <trans-unit id="8523e16e4f3d17cbbcc1796a5175f67569825d49" translate="yes" xml:space="preserve">
          <source>StringWriter is the interface that wraps the WriteString method.</source>
          <target state="translated">StringWriter是包装WriteString方法的接口。</target>
        </trans-unit>
        <trans-unit id="2968f2bfae46d2fc485efc7b71be92497e030111" translate="yes" xml:space="preserve">
          <source>Stringer</source>
          <target state="translated">Stringer</target>
        </trans-unit>
        <trans-unit id="58829a9ebd1b847fb0ad45cdde0851c334ed441d" translate="yes" xml:space="preserve">
          <source>Stringer is implemented by any value that has a String method, which defines the &amp;ldquo;native&amp;rdquo; format for that value. The String method is used to print values passed as an operand to any format that accepts a string or to an unformatted printer such as Print.</source>
          <target state="translated">Stringer由具有String方法的任何值实现，该方法定义该值的&amp;ldquo;本机&amp;rdquo;格式。String方法用于将作为操作数传递的值打印为接受字符串的任何格式，或打印到未格式化的打印机（如Print）。</target>
        </trans-unit>
        <trans-unit id="3816c4beac471c733eed1d91c213f8c2b6a29262" translate="yes" xml:space="preserve">
          <source>Strings</source>
          <target state="translated">Strings</target>
        </trans-unit>
        <trans-unit id="906a27ee40bd23a1553b39eb16be0c8e8ac3e949" translate="yes" xml:space="preserve">
          <source>Strings and slices of bytes are sent as an unsigned count followed by that many uninterpreted bytes of the value.</source>
          <target state="translated">字符串和字节片以无符号计数的形式发送,后面是该值的许多未解释的字节。</target>
        </trans-unit>
        <trans-unit id="faac2cc38ba743bbc17ba9acb7964aa6cee65d73" translate="yes" xml:space="preserve">
          <source>Strings must be UTF-8 encoded and may only contain Unicode code points U+0001 through U+00FF, due to limitations of the GZIP file format.</source>
          <target state="translated">由于GZIP文件格式的限制,字符串必须是UTF-8编码,并且只能包含U+0001到U+00FF的Unicode码点。</target>
        </trans-unit>
        <trans-unit id="f76921542e09ce2202753a5d0b5a9e24e8b8a263" translate="yes" xml:space="preserve">
          <source>Strings sorts a slice of strings in increasing order.</source>
          <target state="translated">Strings按照递增的顺序对字符串的一个片断进行排序。</target>
        </trans-unit>
        <trans-unit id="3d93c8594f1a8a4b01949156c04f8f3f3ae7fd2a" translate="yes" xml:space="preserve">
          <source>StringsAreSorted tests whether a slice of strings is sorted in increasing order.</source>
          <target state="translated">StringsAreSorted测试字符串片断是否按递增顺序排序。</target>
        </trans-unit>
        <trans-unit id="13ae2dda2de94ac9d40b6ba17fece2797835c04a" translate="yes" xml:space="preserve">
          <source>StripPrefix</source>
          <target state="translated">StripPrefix</target>
        </trans-unit>
        <trans-unit id="e0a5f88c187543f04de90ac6fd0379250c9778df" translate="yes" xml:space="preserve">
          <source>StripPrefix returns a handler that serves HTTP requests by removing the given prefix from the request URL's Path and invoking the handler h. StripPrefix handles a request for a path that doesn't begin with prefix by replying with an HTTP 404 not found error.</source>
          <target state="translated">StripPrefix返回一个处理程序,它通过从请求的URL的Path中删除给定的前缀并调用处理程序h来服务HTTP请求。 StripPrefix通过回复HTTP 404 not found错误来处理一个不是以前缀开始的路径请求。</target>
        </trans-unit>
        <trans-unit id="39170b61b74a11d6a192ff9863dfa73aaecba21c" translate="yes" xml:space="preserve">
          <source>Struct values are deeply equal if their corresponding fields, both exported and unexported, are deeply equal.</source>
          <target state="translated">如果其对应的字段,无论是导出的还是未导出的,结构值都是深度相等的。</target>
        </trans-unit>
        <trans-unit id="fb5bb421400cdac0575f807d47566c64d1f46c0f" translate="yes" xml:space="preserve">
          <source>Struct values encode as JSON objects. Each exported struct field becomes a member of the object, using the field name as the object key, unless the field is omitted for one of the reasons given below.</source>
          <target state="translated">Struct值编码为JSON对象。每个导出的结构体字段都会成为对象的成员,使用字段名作为对象键,除非该字段因下面给出的原因之一被省略。</target>
        </trans-unit>
        <trans-unit id="0b823e55e4d9782e91674576a6c2dba2dbfb679a" translate="yes" xml:space="preserve">
          <source>StructOf</source>
          <target state="translated">StructOf</target>
        </trans-unit>
        <trans-unit id="cbecd3176d1c216f7d05eaf053a4641373b34f6b" translate="yes" xml:space="preserve">
          <source>StructOf currently does not generate wrapper methods for embedded fields and panics if passed unexported StructFields. These limitations may be lifted in a future version.</source>
          <target state="translated">StructOf目前不为嵌入的字段生成封装方法,并且在传递未导出的StructFields时,会出现恐慌。这些限制可能会在未来的版本中被取消。</target>
        </trans-unit>
        <trans-unit id="e272272dfcabba6b0a57032693b1247f7d907d03" translate="yes" xml:space="preserve">
          <source>StructOf returns the struct type containing fields. The Offset and Index fields are ignored and computed as they would be by the compiler.</source>
          <target state="translated">StructOf返回包含字段的结构类型。Offset和Index字段会被忽略,并被编译器计算。</target>
        </trans-unit>
        <trans-unit id="642ea82e69d222e31d0a11979f4762edc849aa8f" translate="yes" xml:space="preserve">
          <source>StructTag</source>
          <target state="translated">StructTag</target>
        </trans-unit>
        <trans-unit id="666cf050832b24dac5a22e670aae0c296886ba23" translate="yes" xml:space="preserve">
          <source>StructTag.Lookup</source>
          <target state="translated">StructTag.Lookup</target>
        </trans-unit>
        <trans-unit id="5f4f3284caaeebe32585ec344848f50378d011bc" translate="yes" xml:space="preserve">
          <source>Structs are sent as a sequence of (field number, field value) pairs. The field value is sent using the standard gob encoding for its type, recursively. If a field has the zero value for its type (except for arrays; see above), it is omitted from the transmission. The field number is defined by the type of the encoded struct: the first field of the encoded type is field 0, the second is field 1, etc. When encoding a value, the field numbers are delta encoded for efficiency and the fields are always sent in order of increasing field number; the deltas are therefore unsigned. The initialization for the delta encoding sets the field number to -1, so an unsigned integer field 0 with value 7 is transmitted as unsigned delta = 1, unsigned value = 7 or (01 07). Finally, after all the fields have been sent a terminating mark denotes the end of the struct. That mark is a delta=0 value, which has representation (00).</source>
          <target state="translated">Structs以(字段号,字段值)对的序列形式发送。字段值使用其类型的标准gob编码递归发送。如果一个字段的类型值为零(数组除外,见上文),那么它将在传输中被省略。字段号由编码结构的类型定义:编码类型的第一个字段是字段0,第二个字段是字段1,等等。当对一个值进行编码时,为了提高效率,字段号进行了三角编码,并且字段总是按照字段号增加的顺序发送,因此三角编码是无符号的。delta编码的初始化将字段号设置为-1,所以一个值为7的无符号整数字段0被传送为unsigned delta=1,unsigned value=7或(01 07)。最后,在所有的字段被发送后,一个终止标记表示结构的结束。这个标记是一个delta=0的值,它的表示方法是(00)。</target>
        </trans-unit>
        <trans-unit id="7dc46671ebabbdf3c46aadccd97f8c490eefc52c" translate="yes" xml:space="preserve">
          <source>Structs, arrays and slices are also supported. Structs encode and decode only exported fields. Strings and arrays of bytes are supported with a special, efficient representation (see below). When a slice is decoded, if the existing slice has capacity the slice will be extended in place; if not, a new array is allocated. Regardless, the length of the resulting slice reports the number of elements decoded.</source>
          <target state="translated">还支持结构、数组和切片。Structs只对导出的字段进行编码和解码。字节组的字符串和数组以一种特殊的、有效的表示方式被支持(见下文)。当一个分片被解码时,如果现有的分片有容量,分片将被原地扩展;如果没有,则分配一个新的数组。无论怎样,产生的分片长度都会报告解码后的元素数。</target>
        </trans-unit>
        <trans-unit id="ad78f09f9c6b3087d8e72e4530ecc70c4956979a" translate="yes" xml:space="preserve">
          <source>Structure Preservation Property: &quot;... when a template author writes an HTML tag in a safe templating language, the browser will interpret the corresponding portion of the output as a tag regardless of the values of untrusted data, and similarly for other structures such as attribute boundaries and JS and CSS string boundaries.&quot;</source>
          <target state="translated">结构保存属性。&quot;.当模板作者用安全的模板语言编写HTML标签时,浏览器将把输出的相应部分解释为标签,而不管不受信任的数据的价值如何,同样,对于其他结构,如属性边界和JS和CSS字符串边界也是如此&quot;。</target>
        </trans-unit>
        <trans-unit id="a3c9ca613cd987d897ef5275ec8d3b6be7186d1f" translate="yes" xml:space="preserve">
          <source>Sub returns the difference of x, y and borrow: diff = x - y - borrow. The borrow input must be 0 or 1; otherwise the behavior is undefined. The borrowOut output is guaranteed to be 0 or 1.</source>
          <target state="translated">Sub 返回 x、y 和 borrow 的差值:diff=x-y-borrow。borrow输入必须为0或1,否则行为未定义。borrowOut输出保证为0或1。</target>
        </trans-unit>
        <trans-unit id="61c41cb657724bf35da0dad82b0d5dee3326e95d" translate="yes" xml:space="preserve">
          <source>Sub returns the duration t-u. If the result exceeds the maximum (or minimum) value that can be stored in a Duration, the maximum (or minimum) duration will be returned. To compute t-d for a duration d, use t.Add(-d).</source>
          <target state="translated">子返回持续时间t-u。如果结果超过了可以存储在Duration中的最大(或最小)值,将返回最大(或最小)持续时间。要计算持续时间d的t-d,使用t.Add(-d)。</target>
        </trans-unit>
        <trans-unit id="9a9cccdf849236c7b5afc32fedeaf0e730cf15fd" translate="yes" xml:space="preserve">
          <source>Sub returns the rectangle r translated by -p.</source>
          <target state="translated">子返回由-p转换的矩形r。</target>
        </trans-unit>
        <trans-unit id="c74b307e6862c7c0fdbabb48e4f241316eca6f53" translate="yes" xml:space="preserve">
          <source>Sub returns the vector p-q.</source>
          <target state="translated">子返回向量p-q。</target>
        </trans-unit>
        <trans-unit id="2660992e01b4593ff7e0d2ea96dbc6a6fcdbbc82" translate="yes" xml:space="preserve">
          <source>Sub sets z to the difference x-y and returns z.</source>
          <target state="translated">子将z设为x-y的差值,并返回z。</target>
        </trans-unit>
        <trans-unit id="07c120e2c4cb601d9bfe9da745d95ee84f5c8f23" translate="yes" xml:space="preserve">
          <source>Sub sets z to the rounded difference x-y and returns z. Precision, rounding, and accuracy reporting are as for Add. Sub panics with ErrNaN if x and y are infinities with equal signs. The value of z is undefined in that case.</source>
          <target state="translated">子将z设为四舍五入的差值x-y并返回z。精度、四舍五入和准确度报告与 Add 相同。如果x和y是等号的无穷大,Sub会用ErrNaN恐慌。在这种情况下,z 的值是未定义的。</target>
        </trans-unit>
        <trans-unit id="821524c66883b61b23da230e1f7ac6f247b61c28" translate="yes" xml:space="preserve">
          <source>Sub-repositories</source>
          <target state="translated">Sub-repositories</target>
        </trans-unit>
        <trans-unit id="027b254161eaa851d3de87e3e3811c330b4b1cfe" translate="yes" xml:space="preserve">
          <source>Sub32 returns the difference of x, y and borrow, diff = x - y - borrow. The borrow input must be 0 or 1; otherwise the behavior is undefined. The borrowOut output is guaranteed to be 0 or 1.</source>
          <target state="translated">Sub32 返回 x、y 和 borrow 的差值,diff=x-y-borrow。borrow输入必须为0或1,否则行为未定义。borrowOut输出保证为0或1。</target>
        </trans-unit>
        <trans-unit id="19abe5243ff65ef214d8cfd1ed7dd0d253eaaf1e" translate="yes" xml:space="preserve">
          <source>Sub64 returns the difference of x, y and borrow: diff = x - y - borrow. The borrow input must be 0 or 1; otherwise the behavior is undefined. The borrowOut output is guaranteed to be 0 or 1.</source>
          <target state="translated">Sub64 返回 x、y 和 borrow 的差值:diff=x-y-borrow。borrow输入必须为0或1,否则行为未定义。borrowOut输出保证为0或1。</target>
        </trans-unit>
        <trans-unit id="3fc6e21e27e1d98c4a46c59e21cbbbe634de9bcb" translate="yes" xml:space="preserve">
          <source>SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image.</source>
          <target state="translated">SubImage返回一个代表图像p通过r可见的部分的图像,返回的值与原始图像共享像素。</target>
        </trans-unit>
        <trans-unit id="19b094dbedb2add32a27c12c5c0b06b9d304fb7c" translate="yes" xml:space="preserve">
          <source>Subdirectories</source>
          <target state="translated">Subdirectories</target>
        </trans-unit>
        <trans-unit id="abb46f6f4b961e90d924a27858c117c84efd6aae" translate="yes" xml:space="preserve">
          <source>SubexpNames returns the names of the parenthesized subexpressions in this Regexp. The name for the first sub-expression is names[1], so that if m is a match slice, the name for m[i] is SubexpNames()[i]. Since the Regexp as a whole cannot be named, names[0] is always the empty string. The slice should not be modified.</source>
          <target state="translated">SubexpNames 返回该 Regexp 中括号内子表达式的名称。第一个子表达式的名称是names[1],因此如果m是一个匹配分片,那么m[i]的名称是SubexpNames()[i]。由于Regexp整体不能被命名,所以names[0]总是空字符串。该分片不应该被修改。</target>
        </trans-unit>
        <trans-unit id="c9c047b864469812cfb4b3b886d30b5376a4d0df" translate="yes" xml:space="preserve">
          <source>Subjects returns a list of the DER-encoded subjects of all of the certificates in the pool.</source>
          <target state="translated">Subjects 返回证书池中所有证书的 DER 编码主题的列表。</target>
        </trans-unit>
        <trans-unit id="91e8bbbf1ff4c8e821148581549206c9787e494e" translate="yes" xml:space="preserve">
          <source>Subtests and Sub-benchmarks</source>
          <target state="translated">小测试和次级基准</target>
        </trans-unit>
        <trans-unit id="05cc8697fcb7ccef149a7858e8bd798cb2cd774f" translate="yes" xml:space="preserve">
          <source>Subtests can also be used to control parallelism. A parent test will only complete once all of its subtests complete. In this example, all tests are run in parallel with each other, and only with each other, regardless of other top-level tests that may be defined:</source>
          <target state="translated">子测试也可以用来控制并行性。一个父测试只有在它的所有子测试完成后才会完成。在这个例子中,所有的测试都是相互并行运行的,而且只允许相互并行运行,而不考虑可能定义的其他顶层测试。</target>
        </trans-unit>
        <trans-unit id="bb672ca35fe1893eef6f12fcd0a8efff47a2478c" translate="yes" xml:space="preserve">
          <source>Success reports whether the program exited successfully, such as with exit status 0 on Unix.</source>
          <target state="translated">成功报告程序是否成功退出,如Unix上的退出状态为0。</target>
        </trans-unit>
        <trans-unit id="07eda2eb03735678c89d2490ea6410dd3ad1a43b" translate="yes" xml:space="preserve">
          <source>Such a file is usually paired with another file implementing the default functionality for other systems, which in this case would carry the constraint:</source>
          <target state="translated">这样的文件通常与另一个实现其他系统默认功能的文件配对,在这种情况下,它将携带约束条件。</target>
        </trans-unit>
        <trans-unit id="fc9ce14b28c6f2c3b72caf056ca604b2b96f7d2b" translate="yes" xml:space="preserve">
          <source>Sum</source>
          <target state="translated">Sum</target>
        </trans-unit>
        <trans-unit id="1037d5e9f233e3f6a6a25104581ccd4bbd6ac1c7" translate="yes" xml:space="preserve">
          <source>Sum returns the MD5 checksum of the data.</source>
          <target state="translated">Sum返回数据的MD5校验和。</target>
        </trans-unit>
        <trans-unit id="d8eeaf2ada0e780d70b60f2e9edbd46ef59d4a13" translate="yes" xml:space="preserve">
          <source>Sum returns the SHA-1 checksum of the data.</source>
          <target state="translated">Sum返回数据的SHA-1校验和。</target>
        </trans-unit>
        <trans-unit id="0dca98b14fcbfeb34897e7396c1a6dfa98d521b4" translate="yes" xml:space="preserve">
          <source>Sum224 returns the SHA224 checksum of the data.</source>
          <target state="translated">Sum224返回数据的SHA224校验和。</target>
        </trans-unit>
        <trans-unit id="ba05916088015c0f1b00b88d9415ebfa726370d8" translate="yes" xml:space="preserve">
          <source>Sum256</source>
          <target state="translated">Sum256</target>
        </trans-unit>
        <trans-unit id="087b1fabd67b489187e993cab88dfd4147ea385d" translate="yes" xml:space="preserve">
          <source>Sum256 returns the SHA256 checksum of the data.</source>
          <target state="translated">Sum256返回数据的SHA256校验和。</target>
        </trans-unit>
        <trans-unit id="6bd95a96de2d8140b4ada3f2d7b194594facee01" translate="yes" xml:space="preserve">
          <source>Sum384 returns the SHA384 checksum of the data.</source>
          <target state="translated">Sum384返回数据的SHA384校验和。</target>
        </trans-unit>
        <trans-unit id="bf1f6e0b5ced478fca66b19297a0e98baeedd390" translate="yes" xml:space="preserve">
          <source>Sum512 returns the SHA512 checksum of the data.</source>
          <target state="translated">Sum512返回数据的SHA512校验和。</target>
        </trans-unit>
        <trans-unit id="3357361c0e72e316aab24916d39ed7d14bdb335d" translate="yes" xml:space="preserve">
          <source>Sum512_224 returns the Sum512/224 checksum of the data.</source>
          <target state="translated">Sum512_224 返回数据的Sum512/224校验和。</target>
        </trans-unit>
        <trans-unit id="ff71eecde6b5c686475ebd821438cf7dd50ffe32" translate="yes" xml:space="preserve">
          <source>Sum512_256 returns the Sum512/256 checksum of the data.</source>
          <target state="translated">Sum512_256 返回数据的Sum512/256校验和。</target>
        </trans-unit>
        <trans-unit id="4442b8443612835fd9bd367eb3496bb5cfec606a" translate="yes" xml:space="preserve">
          <source>Support for tracing tests and benchmarks built with the standard testing package is built into `go test`. For example, the following command runs the test in the current directory and writes the trace file (trace.out).</source>
          <target state="translated">`go test`中内置了对跟踪测试和用标准测试包建立的基准的支持。例如,以下命令在当前目录下运行测试,并写入跟踪文件(trace.out)。</target>
        </trans-unit>
        <trans-unit id="05492c0a57ea2d63ba2b476c7222b6bcdddbb676" translate="yes" xml:space="preserve">
          <source>Supported architectures for compiler &quot;gc&quot;: &quot;386&quot;, &quot;arm&quot;, &quot;arm64&quot;, &quot;amd64&quot;, &quot;amd64p32&quot;, &quot;mips&quot;, &quot;mipsle&quot;, &quot;mips64&quot;, &quot;mips64le&quot;, &quot;ppc64&quot;, &quot;ppc64le&quot;, &quot;riscv64&quot;, &quot;s390x&quot;, &quot;sparc64&quot;, &quot;wasm&quot;.</source>
          <target state="translated">编译器 &quot;gc &quot;所支持的架构:&quot;386&quot;、&quot;arm&quot;、&quot;arm64&quot;、&quot;amd64&quot;、&quot;amd64p32&quot;、&quot;mips&quot;、&quot;mipsle&quot;、&quot;mips64&quot;、&quot;mips64le&quot;。&quot;386&quot;、&quot;arm&quot;、&quot;arm64&quot;、&quot;amd64&quot;、&quot;amd64p32&quot;、&quot;mips&quot;、&quot;mipsle&quot;、&quot;mips64&quot;、&quot;mips64le&quot;、&quot;pc64&quot;、&quot;pc64le&quot;、&quot;riscv64&quot;、&quot;s390x&quot;、&quot;sparc64&quot;、&quot;wasm&quot;。</target>
        </trans-unit>
        <trans-unit id="e8b59b633a995b7dd6a0e84deb15f21ce9bf242a" translate="yes" xml:space="preserve">
          <source>SwapInt32 atomically stores new into *addr and returns the previous *addr value.</source>
          <target state="translated">SwapInt32原子性地将new存储到*addr中,并返回之前的*addr值。</target>
        </trans-unit>
        <trans-unit id="96490065dc4e2e645c8a89627e673eb95f4aaa28" translate="yes" xml:space="preserve">
          <source>SwapInt64 atomically stores new into *addr and returns the previous *addr value.</source>
          <target state="translated">SwapInt64原子性地将new存储到*addr中,并返回之前的*addr值。</target>
        </trans-unit>
        <trans-unit id="da115593d3ae663bb42ff237dd86576dfdedf6ad" translate="yes" xml:space="preserve">
          <source>SwapPointer atomically stores new into *addr and returns the previous *addr value.</source>
          <target state="translated">SwapPointer原子性地将new存储到*addr中,并返回之前的*addr值。</target>
        </trans-unit>
        <trans-unit id="0c0f6214095877962c7da65a2c141bf3b6cbecc8" translate="yes" xml:space="preserve">
          <source>SwapUint32 atomically stores new into *addr and returns the previous *addr value.</source>
          <target state="translated">SwapUint32原子性地将new存储到*addr中,并返回之前的*addr值。</target>
        </trans-unit>
        <trans-unit id="899e9c7e854930b5577e53934a16009339f15457" translate="yes" xml:space="preserve">
          <source>SwapUint64 atomically stores new into *addr and returns the previous *addr value.</source>
          <target state="translated">SwapUint64原子性地将new存储到*addr中,并返回之前的*addr值。</target>
        </trans-unit>
        <trans-unit id="18cdfb91a16523313759a1c794de0eb9712ac2b2" translate="yes" xml:space="preserve">
          <source>SwapUintptr atomically stores new into *addr and returns the previous *addr value.</source>
          <target state="translated">SwapUintptr原子性地将new存储到*addr中,并返回之前的*addr值。</target>
        </trans-unit>
        <trans-unit id="5c2b73e847c3ed8be17c9afe2788c2fedb5bc635" translate="yes" xml:space="preserve">
          <source>Swapper panics if the provided interface is not a slice.</source>
          <target state="translated">如果提供的接口不是切片,Swapper就会恐慌。</target>
        </trans-unit>
        <trans-unit id="0485bba36620f415adb72d21b9eac171cd9aadf1" translate="yes" xml:space="preserve">
          <source>Swapper returns a function that swaps the elements in the provided slice.</source>
          <target state="translated">Swapper返回一个交换所提供的片中元素的函数。</target>
        </trans-unit>
        <trans-unit id="baf85dad7e64d73c6dc3f04eb46803a601b907a7" translate="yes" xml:space="preserve">
          <source>SymByAddr returns the text, data, or bss symbol starting at the given address.</source>
          <target state="translated">SymByAddr返回从给定地址开始的文本、数据或bss符号。</target>
        </trans-unit>
        <trans-unit id="e6a580ed077335806f8a72f4c91bc2108aa36618" translate="yes" xml:space="preserve">
          <source>Symbol Binding - ELFNN_ST_BIND - st_info</source>
          <target state="translated">符号绑定-ELFNN_ST_BIND-st_info</target>
        </trans-unit>
        <trans-unit id="998290f1606e44ec99b08646525255987ca67dd9" translate="yes" xml:space="preserve">
          <source>Symbol is similar to COFFSymbol with Name field replaced by Go string. Symbol also does not have NumberOfAuxSymbols.</source>
          <target state="translated">Symbol类似于COFFSymbol,但Name字段被Go字符串取代。符号也没有NumberOfAuxSymbols。</target>
        </trans-unit>
        <trans-unit id="e746caac18fb8c9ece11fba1c3858dd24402cee1" translate="yes" xml:space="preserve">
          <source>Symbol looks up the program counters listed in the request, responding with a table mapping program counters to function names. The package initialization registers it as /debug/pprof/symbol.</source>
          <target state="translated">Symbol查找请求中列出的程序计数器,用一个程序计数器与函数名的映射表来回应。包的初始化将其注册为/debug/pprof/symbol。</target>
        </trans-unit>
        <trans-unit id="9183912a1c8677ccbfeafe4a95bb81fdaf9d6c67" translate="yes" xml:space="preserve">
          <source>Symbol type - ELFNN_ST_TYPE - st_info</source>
          <target state="translated">符号类型-ELFNN_ST_TYPE-st_info</target>
        </trans-unit>
        <trans-unit id="300ae1bf65f5418188fead7a4f6227a1a8cb17ab" translate="yes" xml:space="preserve">
          <source>Symbol visibility - ELFNN_ST_VISIBILITY - st_other</source>
          <target state="translated">符号可见性-ELFNN_ST_VISIBILITY-st_other</target>
        </trans-unit>
        <trans-unit id="e0dd57ca387a759e2499962eadf5f79f0eaa8ee2" translate="yes" xml:space="preserve">
          <source>Symbols returns the symbol table for f.</source>
          <target state="translated">符号返回f的符号表。</target>
        </trans-unit>
        <trans-unit id="40ab78f946263d95260d4886b240965a4da98f61" translate="yes" xml:space="preserve">
          <source>Symbols returns the symbol table for f. The symbols will be listed in the order they appear in f.</source>
          <target state="translated">符号表 返回f的符号表,符号将按照它们在f中出现的顺序排列。</target>
        </trans-unit>
        <trans-unit id="2377d81c04be24a887c20fd3bd69bc0f09f37db5" translate="yes" xml:space="preserve">
          <source>Symlink creates newname as a symbolic link to oldname. If there is an error, it will be of type *LinkError.</source>
          <target state="translated">Symlink创建newname作为一个符号链接到oldname。如果出现错误,它的类型将是*LinkError。</target>
        </trans-unit>
        <trans-unit id="0aceec11151392e3e912ee288231038c58c328b4" translate="yes" xml:space="preserve">
          <source>Sync commits the current contents of the file to stable storage. Typically, this means flushing the file system's in-memory copy of recently written data to disk.</source>
          <target state="translated">同步将文件的当前内容提交到稳定的存储中。通常情况下,这意味着将文件系统的内存中最近写入的数据副本刷新到磁盘。</target>
        </trans-unit>
        <trans-unit id="e15b4a502540aca9807844244039f56ac0ff96c5" translate="yes" xml:space="preserve">
          <source>Synchronous signals are signals triggered by errors in program execution: SIGBUS, SIGFPE, and SIGSEGV. These are only considered synchronous when caused by program execution, not when sent using os.Process.Kill or the kill program or some similar mechanism. In general, except as discussed below, Go programs will convert a synchronous signal into a run-time panic.</source>
          <target state="translated">同步信号是由程序执行中的错误所触发的信号。SIGBUS、SIGFPE和SIGSEGV。这些信号只有在程序执行引起的时候才会被认为是同步信号,而不是使用os.Process.Kill或杀程序或一些类似的机制发送的信号。一般来说,除了下面的讨论,Go程序会将同步信号转化为运行时的恐慌。</target>
        </trans-unit>
        <trans-unit id="36c0630a340d2960affa1c4d2360b0e2c06793fb" translate="yes" xml:space="preserve">
          <source>Synopsis</source>
          <target state="translated">Synopsis</target>
        </trans-unit>
        <trans-unit id="14251985329004226786245f7238c38c1ab2c9f9" translate="yes" xml:space="preserve">
          <source>Synopsis returns a cleaned version of the first sentence in s. That sentence ends after the first period followed by space and not preceded by exactly one uppercase letter. The result string has no \n, \r, or \t characters and uses only single spaces between words. If s starts with any of the IllegalPrefixes, the result is the empty string.</source>
          <target state="translated">Synopsis返回s中第一句话的清洁版本。该句子在第一个句号后用空格结束,并且前面没有一个大写字母。结果字符串中没有\n,\r,或\t字符,并且只在单词之间使用单个空格。如果s以任何IllegalPrefixes开头,结果就是空字符串。</target>
        </trans-unit>
        <trans-unit id="17c7ba7676ad1ad6dd1c4e6b997adcae910262c9" translate="yes" xml:space="preserve">
          <source>Syntax</source>
          <target state="translated">Syntax</target>
        </trans-unit>
        <trans-unit id="94881bde696c81108db9e992f3357d3d70383bb4" translate="yes" xml:space="preserve">
          <source>Sys returns system-dependent exit information about the process. Convert it to the appropriate underlying type, such as syscall.WaitStatus on Unix, to access its contents.</source>
          <target state="translated">Sys返回与系统相关的进程的退出信息,将其转换为适当的底层类型,如Unix上的syscall.WaitStatus,以访问其内容。将其转换为适当的底层类型,如Unix上的syscall.WaitStatus,以访问其内容。</target>
        </trans-unit>
        <trans-unit id="ce82965024d89928bce7d20275a546fd15078072" translate="yes" xml:space="preserve">
          <source>SysProcIDMap holds Container ID to Host ID mappings used for User Namespaces in Linux. See user_namespaces(7).</source>
          <target state="translated">SysProcIDMap 保存了 Linux 中用于用户命名空间的容器 ID 到主机 ID 的映射。参见 user_namespaces(7)。</target>
        </trans-unit>
        <trans-unit id="8ffbaaa01464f1d0b5846f06e745037abe0d8cb8" translate="yes" xml:space="preserve">
          <source>SysUsage returns system-dependent resource usage information about the exited process. Convert it to the appropriate underlying type, such as *syscall.Rusage on Unix, to access its contents. (On Unix, *syscall.Rusage matches struct rusage as defined in the getrusage(2) manual page.)</source>
          <target state="translated">SysUsage 返回与系统相关的关于退出进程的资源使用信息。将其转换为适当的底层类型,例如 Unix 上的 *syscall.Rusage,以访问其内容。(在 Unix 上,*syscall.Rusage 与 getrusage(2)手册页面中定义的 rusage 结构相匹配。)</target>
        </trans-unit>
        <trans-unit id="e293cc54d1f1c47b6fdb1085033440055e2faa2b" translate="yes" xml:space="preserve">
          <source>SyscallConn returns a raw file. This implements the syscall.Conn interface.</source>
          <target state="translated">SyscallConn返回一个原始文件。这实现了syscall.Conn接口。</target>
        </trans-unit>
        <trans-unit id="93d325a9a596e81112db1a88f6cf17706c8e91ec" translate="yes" xml:space="preserve">
          <source>SyscallConn returns a raw network connection. This implements the syscall.Conn interface.</source>
          <target state="translated">SyscallConn返回一个原始网络连接。这实现了syscall.Conn接口。</target>
        </trans-unit>
        <trans-unit id="aa615b3f3de4dc13fa4173050b52db98916467bd" translate="yes" xml:space="preserve">
          <source>SyscallError records an error from a specific system call.</source>
          <target state="translated">SyscallError记录了一个特定系统调用的错误。</target>
        </trans-unit>
        <trans-unit id="de57d6136b78d4b44c51a17ce5f47f730586e6a6" translate="yes" xml:space="preserve">
          <source>SystemCertPool returns a copy of the system cert pool.</source>
          <target state="translated">SystemCertPool 返回系统证书池的副本。</target>
        </trans-unit>
        <trans-unit id="5bc8f6a9ab808b5aa99fa9f5b51afdf83e241a9c" translate="yes" xml:space="preserve">
          <source>SystemRootsError results when we fail to load the system root certificates.</source>
          <target state="translated">当我们未能加载系统根证书时,会产生SystemRootsError。</target>
        </trans-unit>
        <trans-unit id="326b735dbfcf185462598a45a443d5db5a2c18cd" translate="yes" xml:space="preserve">
          <source>SystemTime returns the system CPU time of the exited process and its children.</source>
          <target state="translated">SystemTime 返回退出的进程及其子进程的系统 CPU 时间。</target>
        </trans-unit>
        <trans-unit id="bd9dc41e485032cb18e9d13d513ba555be1b33c2" translate="yes" xml:space="preserve">
          <source>T is a type passed to Test functions to manage test state and support formatted test logs. Logs are accumulated during execution and dumped to standard output when done.</source>
          <target state="translated">T是传递给测试函数的一个类型,用于管理测试状态,支持格式化的测试日志。在执行过程中积累日志,完成后转储到标准输出。</target>
        </trans-unit>
        <trans-unit id="d71f7f3fa4e9f0ba0065f39db28f69d358c4b941" translate="yes" xml:space="preserve">
          <source>TB is the interface common to T and B.</source>
          <target state="translated">TB是T和B共用的接口。</target>
        </trans-unit>
        <trans-unit id="671a2dd281c27979f8b5f140c5da50e321430a64" translate="yes" xml:space="preserve">
          <source>TBSCertificateList represents the ASN.1 structure of the same name. See RFC 5280, section 5.1.</source>
          <target state="translated">TBSCertificateList表示同名的ASN.1结构。参见RFC 5280,5.1节。</target>
        </trans-unit>
        <trans-unit id="2984ada09d0c49745872575be1763fe615cf3de7" translate="yes" xml:space="preserve">
          <source>TCPAddr represents the address of a TCP end point.</source>
          <target state="translated">TCPAddr表示TCP端点的地址。</target>
        </trans-unit>
        <trans-unit id="623c2c8aa88d77780fe4e0bcba75694b81bcf2ad" translate="yes" xml:space="preserve">
          <source>TCPConn is an implementation of the Conn interface for TCP network connections.</source>
          <target state="translated">TCPConn是Conn接口的一个实现,用于TCP网络连接。</target>
        </trans-unit>
        <trans-unit id="1bbfc48812fe8aa4d93c086976c0d5cdc5424e43" translate="yes" xml:space="preserve">
          <source>TCPListener is a TCP network listener. Clients should typically use variables of type Listener instead of assuming TCP.</source>
          <target state="translated">TCPListener是一个TCP网络监听器。客户端通常应该使用Listener类型的变量,而不是假设TCP。</target>
        </trans-unit>
        <trans-unit id="c0df2a7fffd9d8cf03b29589d0b72452730e5dd3" translate="yes" xml:space="preserve">
          <source>TLS 1.3 is available on an opt-out basis in Go 1.13. To disable it, set the GODEBUG environment variable (comma-separated key=value options) such that it includes &quot;tls13=0&quot;.</source>
          <target state="translated">TLS 1.3在Go 1.13中是可以选择不使用的。要禁用它,可以设置GODEBUG环境变量(以逗号分隔的key=value options),使其包含 &quot;tls13=0&quot;。</target>
        </trans-unit>
        <trans-unit id="daa5896e5821b88d0d9b26d2bc85c2d021b848c8" translate="yes" xml:space="preserve">
          <source>TLSConnectionState returns the client's TLS connection state. The return values are their zero values if StartTLS did not succeed.</source>
          <target state="translated">TLSConnectionState返回客户端的TLS连接状态。如果StartTLS没有成功,则返回值为其零值。</target>
        </trans-unit>
        <trans-unit id="ed012370216d609d48fc2b869f8a011268923cad" translate="yes" xml:space="preserve">
          <source>TODO returns a non-nil, empty Context. Code should use context.TODO when it's unclear which Context to use or it is not yet available (because the surrounding function has not yet been extended to accept a Context parameter).</source>
          <target state="translated">TODO返回一个非零的空Context。当不清楚要使用哪个Context或者它还不可用的时候(因为周围的函数还没有被扩展到接受Context参数),代码应该使用context.TODO。</target>
        </trans-unit>
        <trans-unit id="1f541ebdf888dacb11e44ff51c13846474081ba9" translate="yes" xml:space="preserve">
          <source>Tab-terminated cells in contiguous lines constitute a column. The Writer inserts padding as needed to make all cells in a column have the same width, effectively aligning the columns. It assumes that all characters have the same width, except for tabs for which a tabwidth must be specified. Column cells must be tab-terminated, not tab-separated: non-tab terminated trailing text at the end of a line forms a cell but that cell is not part of an aligned column. For instance, in this example (where | stands for a horizontal tab):</source>
          <target state="translated">以制表符结束的连续行单元格构成一列。Writer根据需要插入padding,使列中的所有单元格具有相同的宽度,有效地对齐列。它假定所有的字符都有相同的宽度,但制表符除外,制表符的宽度必须指定。列单元格必须以制表符结尾,而不是以制表符分隔:行末非制表符结尾的尾部文本形成一个单元格,但该单元格不是对齐列的一部分。例如,在这个例子中(其中|代表水平制表符)。</target>
        </trans-unit>
        <trans-unit id="9baa6d565b56c1e4861e3df81a8fd8df65d699d4" translate="yes" xml:space="preserve">
          <source>Table 1 in [2] suggests maximum numbers of primes for a given size.</source>
          <target state="translated">表1在[2]中提出了给定大小的最大质数。</target>
        </trans-unit>
        <trans-unit id="ba3ee22bd3b233bdb404d63bfe71ba0cb11ae0a4" translate="yes" xml:space="preserve">
          <source>Table is a 256-word table representing the polynomial for efficient processing.</source>
          <target state="translated">表是一个256字的表,表示多项式,以便高效处理。</target>
        </trans-unit>
        <trans-unit id="599b448991ae5ae6d130b6356ce6b00630c5cefb" translate="yes" xml:space="preserve">
          <source>Table represents a Go symbol table. It stores all of the symbols decoded from the program and provides methods to translate between symbols, names, and addresses.</source>
          <target state="translated">表表示一个围棋符号表。它存储了所有从程序中解码的符号,并提供了在符号、名称和地址之间进行翻译的方法。</target>
        </trans-unit>
        <trans-unit id="bfc4ba347929d28c193a400550bae587488f16cd" translate="yes" xml:space="preserve">
          <source>Tag returns the i'th field tag for 0 &amp;lt;= i &amp;lt; NumFields().</source>
          <target state="translated">标签返回第i个字段标签，其值为0 &amp;lt;= i &amp;lt;NumFields（）。</target>
        </trans-unit>
        <trans-unit id="7a39b84c91d8c550355f46b331fdfde2ffca5ba7" translate="yes" xml:space="preserve">
          <source>Tag sizes between 12 and 16 bytes are allowed.</source>
          <target state="translated">标签大小允许在12到16字节之间。</target>
        </trans-unit>
        <trans-unit id="9dda0ce21be12978cbb42d63ed48bd36a71555e8" translate="yes" xml:space="preserve">
          <source>Taken from &lt;a href=&quot;https://www.iana.org/assignments/tls-parameters/tls-parameters.xml&quot;&gt;https://www.iana.org/assignments/tls-parameters/tls-parameters.xml&lt;/a&gt;</source>
          <target state="translated">取自&lt;a href=&quot;https://www.iana.org/assignments/tls-parameters/tls-parameters.xml&quot;&gt;https://www.iana.org/assignments/tls-parameters/tls-parameters.xml&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="133552ebfbcce8310f8920695422699d5256bac9" translate="yes" xml:space="preserve">
          <source>Tan</source>
          <target state="translated">Tan</target>
        </trans-unit>
        <trans-unit id="c442668b04fe0d2fb49d4d83b1b51198b583f812" translate="yes" xml:space="preserve">
          <source>Tan returns the tangent of the radian argument x.</source>
          <target state="translated">Tan 返回弧度参数 x 的正切值。</target>
        </trans-unit>
        <trans-unit id="9f8f5243ed4843c5154158c2ff20cd9a586739e0" translate="yes" xml:space="preserve">
          <source>Tan returns the tangent of x.</source>
          <target state="translated">Tan返回x的切线。</target>
        </trans-unit>
        <trans-unit id="19bff9fbbbadd7b339e0ee0ae1715d62fea9cae0" translate="yes" xml:space="preserve">
          <source>Tanh</source>
          <target state="translated">Tanh</target>
        </trans-unit>
        <trans-unit id="dc8ae90d27ce708b07a5ac10906ccc3ed208c4a5" translate="yes" xml:space="preserve">
          <source>Tanh returns the hyperbolic tangent of x.</source>
          <target state="translated">Tanh返回x的双曲正切。</target>
        </trans-unit>
        <trans-unit id="6f0a22a02d454a68d024fa67fa9340156799d88b" translate="yes" xml:space="preserve">
          <source>Tape archives (tar) are a file format for storing a sequence of files that can be read and written in a streaming manner. This package aims to cover most variations of the format, including those produced by GNU and BSD tar tools.</source>
          <target state="translated">磁带档案(tar)是一种文件格式,用于存储一系列可以以流式方式读写的文件。本软件包旨在涵盖该格式的大多数变化,包括GNU和BSD tar工具产生的那些。</target>
        </trans-unit>
        <trans-unit id="f11f02db734667c97fad6ffb5c8e393a00b87399" translate="yes" xml:space="preserve">
          <source>Task is a data type for tracing a user-defined, logical operation.</source>
          <target state="translated">任务是一种数据类型,用于跟踪用户定义的逻辑操作。</target>
        </trans-unit>
        <trans-unit id="a9e55d223a3d4713691d397b40624caef60d5252" translate="yes" xml:space="preserve">
          <source>TeeReader</source>
          <target state="translated">TeeReader</target>
        </trans-unit>
        <trans-unit id="c3ce03ea658d6ce846ba37ed8673f608fd0ba578" translate="yes" xml:space="preserve">
          <source>TeeReader returns a Reader that writes to w what it reads from r. All reads from r performed through it are matched with corresponding writes to w. There is no internal buffering - the write must complete before the read completes. Any error encountered while writing is reported as a read error.</source>
          <target state="translated">TeeReader返回一个Reader,它将从r中读取的内容写入w中。写入时遇到的任何错误都会被报告为读取错误。</target>
        </trans-unit>
        <trans-unit id="d5aae156b3babace54749a4ff370cbf166528804" translate="yes" xml:space="preserve">
          <source>Tell returns the current position in the line table.</source>
          <target state="translated">Tell返回当前在行表中的位置。</target>
        </trans-unit>
        <trans-unit id="243b371792899304742de51767e5e63dc878faba" translate="yes" xml:space="preserve">
          <source>TempDir</source>
          <target state="translated">TempDir</target>
        </trans-unit>
        <trans-unit id="99e70473aa5b1571f3701ff2584745139273d8ab" translate="yes" xml:space="preserve">
          <source>TempDir creates a new temporary directory in the directory dir with a name beginning with prefix and returns the path of the new directory. If dir is the empty string, TempDir uses the default directory for temporary files (see os.TempDir). Multiple programs calling TempDir simultaneously will not choose the same directory. It is the caller's responsibility to remove the directory when no longer needed.</source>
          <target state="translated">TempDir 在目录 dir 中创建一个新的临时目录,名称以前缀开头,并返回新目录的路径。如果 dir 是空字符串,TempDir 会使用默认的临时文件目录(参见 os.TempDir)。多个程序同时调用 TempDir 不会选择同一个目录。调用者有责任在不再需要时删除该目录。</target>
        </trans-unit>
        <trans-unit id="275584eb4c05e91a05657287b9e5e68b19aedf60" translate="yes" xml:space="preserve">
          <source>TempDir returns the default directory to use for temporary files.</source>
          <target state="translated">TempDir 返回用于临时文件的默认目录。</target>
        </trans-unit>
        <trans-unit id="d7cc1fbb5a71addb97fa8de33ce419d1f28b35a1" translate="yes" xml:space="preserve">
          <source>TempFile</source>
          <target state="translated">TempFile</target>
        </trans-unit>
        <trans-unit id="ba14fe997bc74680fd4532ceead516a44881c27a" translate="yes" xml:space="preserve">
          <source>TempFile (Suffix)</source>
          <target state="translated">临时文件(后缀)</target>
        </trans-unit>
        <trans-unit id="db71768a24bbe351f05252c3b917cc624a9ef1b3" translate="yes" xml:space="preserve">
          <source>TempFile creates a new temporary file in the directory dir, opens the file for reading and writing, and returns the resulting *os.File. The filename is generated by taking pattern and adding a random string to the end. If pattern includes a &quot;*&quot;, the random string replaces the last &quot;*&quot;. If dir is the empty string, TempFile uses the default directory for temporary files (see os.TempDir). Multiple programs calling TempFile simultaneously will not choose the same file. The caller can use f.Name() to find the pathname of the file. It is the caller's responsibility to remove the file when no longer needed.</source>
          <target state="translated">TempFile在目录dir中创建一个新的临时文件,打开该文件进行读写,并返回生成的*os.File。文件名是通过取pattern并在最后添加一个随机字符串来生成的。如果pattern中包含 &quot;*&quot;,则随机字符串替换最后的 &quot;*&quot;。如果 dir 是空字符串,TempFile 会使用默认的临时文件目录 (参见 os.TempDir)。多个程序同时调用 TempFile 将不会选择同一个文件。调用者可以使用 f.Name()来查找文件的路径名。当不再需要该文件时,调用者有责任删除该文件。</target>
        </trans-unit>
        <trans-unit id="3ec1ae061c27325c7ecb543adf91235e22cbc9ed" translate="yes" xml:space="preserve">
          <source>Template</source>
          <target state="translated">Template</target>
        </trans-unit>
        <trans-unit id="52ee9ac00f43714b0b4818dd84d35b8b6557c7c3" translate="yes" xml:space="preserve">
          <source>Template (Block)</source>
          <target state="translated">模板(块)</target>
        </trans-unit>
        <trans-unit id="74122feafa7458ac08ce0eb420614965c6703346" translate="yes" xml:space="preserve">
          <source>Template (Func)</source>
          <target state="translated">模板(FUNC)</target>
        </trans-unit>
        <trans-unit id="2682dd16a44a1aa85841c66918e903265b4a3cd6" translate="yes" xml:space="preserve">
          <source>Template (Glob)</source>
          <target state="translated">模板(Glob)</target>
        </trans-unit>
        <trans-unit id="b329235171f350105da0e424a6e94302aadf509f" translate="yes" xml:space="preserve">
          <source>Template (Helpers)</source>
          <target state="translated">模板(助手)</target>
        </trans-unit>
        <trans-unit id="f6c8b5d715e6b1e91ba606c90a46ade44fbfcfc3" translate="yes" xml:space="preserve">
          <source>Template (Parsefiles)</source>
          <target state="translated">模板 (Parsefiles)</target>
        </trans-unit>
        <trans-unit id="57600593178e53d1b30c9ce35cfc8c0a348f3a2c" translate="yes" xml:space="preserve">
          <source>Template (Share)</source>
          <target state="translated">模板 (分享)</target>
        </trans-unit>
        <trans-unit id="85b91409ae0c75ad6a8c43a15d791cc0c6067ae4" translate="yes" xml:space="preserve">
          <source>Template is a specialized Template from &quot;text/template&quot; that produces a safe HTML document fragment.</source>
          <target state="translated">Template是 &quot;text/template &quot;中的一个专门的Template,它可以生成一个安全的HTML文档片段。</target>
        </trans-unit>
        <trans-unit id="d8a89275d0782e6367eafd96ad18e35d72254fb0" translate="yes" xml:space="preserve">
          <source>Template is the representation of a parsed template. The *parse.Tree field is exported only for use by html/template and should be treated as unexported by all other clients.</source>
          <target state="translated">Template 是已解析模板的表示。*parse.Tree字段仅导出供html/template使用,其他所有客户端应视为未导出。</target>
        </trans-unit>
        <trans-unit id="19cafd4f58542bc1848a2bc09f68f32df89aaeb6" translate="yes" xml:space="preserve">
          <source>Template.Delims</source>
          <target state="translated">Template.Delims</target>
        </trans-unit>
        <trans-unit id="a8aa430f1c13b8e8ba33d56534b8f8c54974c35f" translate="yes" xml:space="preserve">
          <source>TemplateNode represents a {{template}} action.</source>
          <target state="translated">TemplateNode代表一个{{模板}}动作。</target>
        </trans-unit>
        <trans-unit id="6272b08c56a555c9301dfcc377b8ee08eca7de29" translate="yes" xml:space="preserve">
          <source>Templates are executed by applying them to a data structure. Annotations in the template refer to elements of the data structure (typically a field of a struct or a key in a map) to control execution and derive values to be displayed. Execution of the template walks the structure and sets the cursor, represented by a period '.' and called &quot;dot&quot;, to the value at the current location in the structure as execution proceeds.</source>
          <target state="translated">通过将模板应用到数据结构中来执行模板。模板中的注解指的是数据结构中的元素(通常是结构中的一个字段或地图中的一个键),以控制执行并得出要显示的值。模板的执行是在结构中行走,并在执行过程中将光标(用句号'.'表示,称为 &quot;点&quot;)设置为结构中当前位置的值。</target>
        </trans-unit>
        <trans-unit id="d659d268d0b2876b00930d9cefac00e94082414d" translate="yes" xml:space="preserve">
          <source>Templates can be redefined in successive calls to Parse, before the first use of Execute on t or any associated template. A template definition with a body containing only white space and comments is considered empty and will not replace an existing template's body. This allows using Parse to add new named template definitions without overwriting the main template body.</source>
          <target state="translated">在第一次使用Execute on t或任何相关模板之前,可以在连续调用Parse时重新定义模板。一个模板定义的主体只包含空白和注释,被认为是空的,不会替换现有模板的主体。这允许使用Parse添加新的命名模板定义,而不会覆盖主模板体。</target>
        </trans-unit>
        <trans-unit id="b0dad97eb547b69ff6ae16e7728cdc906f69fe6a" translate="yes" xml:space="preserve">
          <source>Templates can be redefined in successive calls to Parse. A template definition with a body containing only white space and comments is considered empty and will not replace an existing template's body. This allows using Parse to add new named template definitions without overwriting the main template body.</source>
          <target state="translated">模板可以在连续调用Parse时重新定义。一个模板定义的主体只包含空白和注释,被认为是空的,不会替换现有模板的主体。这允许使用Parse添加新的命名模板定义,而不覆盖主模板体。</target>
        </trans-unit>
        <trans-unit id="7b101f8846f53e53dd0074ea44ad4ea7b299215d" translate="yes" xml:space="preserve">
          <source>Templates returns a slice of defined templates associated with t.</source>
          <target state="translated">Templates返回与t相关联的定义模板的片断。</target>
        </trans-unit>
        <trans-unit id="ef678e78b264d52108e80621ab16809ee2f68f32" translate="yes" xml:space="preserve">
          <source>Templates returns a slice of the templates associated with t, including t itself.</source>
          <target state="translated">Templates 返回与 t 相关联的 templates 的片断,包括 t 本身。</target>
        </trans-unit>
        <trans-unit id="63499f131caeb094b508fda158f4d32cdfc15875" translate="yes" xml:space="preserve">
          <source>Temporary reports whether the DNS error is known to be temporary. This is not always known; a DNS lookup may fail due to a temporary error and return a DNSError for which Temporary returns false.</source>
          <target state="translated">Temporary 报告 DNS 错误是否为暂时性错误。这并不总是已知的;DNS查找可能由于临时错误而失败,并返回一个DNSError,而Temporary则返回false。</target>
        </trans-unit>
        <trans-unit id="102ab778dfcf2daa890ddca81b62a6c8c57e866c" translate="yes" xml:space="preserve">
          <source>Tests or benchmarks may be skipped at run time with a call to the Skip method of *T or *B:</source>
          <target state="translated">在运行时可以通过调用*T或*B的Skip方法来跳过测试或基准。</target>
        </trans-unit>
        <trans-unit id="4fb2cdb8c84498e97b67876bcf9179f6c6a0681c" translate="yes" xml:space="preserve">
          <source>Text and spaces</source>
          <target state="translated">文本和空格</target>
        </trans-unit>
        <trans-unit id="7c3578369bc9761a19920ddfd71d5074fb77328e" translate="yes" xml:space="preserve">
          <source>Text converts the floating-point number x to a string according to the given format and precision prec. The format is one of:</source>
          <target state="translated">Text根据给定的格式和精度prec将浮点数x转换为字符串。格式为:</target>
        </trans-unit>
        <trans-unit id="9714bb7b9d9dc65203e2f28091e607a38d20869a" translate="yes" xml:space="preserve">
          <source>Text in the format string that is not recognized as part of the reference time is echoed verbatim during Format and expected to appear verbatim in the input to Parse.</source>
          <target state="translated">在格式化过程中,格式字符串中未被识别为参考时间一部分的文本会被逐字呼应,并希望在输入到Parse的过程中逐字出现。</target>
        </trans-unit>
        <trans-unit id="2a87e174a24b19b122c0ab179b85b925e794409f" translate="yes" xml:space="preserve">
          <source>Text returns the most recent token generated by a call to Scan as a newly allocated string holding its bytes.</source>
          <target state="translated">Text返回最近一次调用Scan产生的标记,作为一个新分配的字符串,持有它的字节。</target>
        </trans-unit>
        <trans-unit id="9757ee25c7224af6e75db771ea323fc05ac31e21" translate="yes" xml:space="preserve">
          <source>Text returns the string representation of x in the given base. Base must be between 2 and 62, inclusive. The result uses the lower-case letters 'a' to 'z' for digit values 10 to 35, and the upper-case letters 'A' to 'Z' for digit values 36 to 61. No prefix (such as &quot;0x&quot;) is added to the string. If x is a nil pointer it returns &quot;&amp;lt;nil&amp;gt;&quot;.</source>
          <target state="translated">文本返回给定基数中x的字符串表示形式。底数必须在2到62之间（含2和62）。结果将小写字母&amp;ldquo; a&amp;rdquo;至&amp;ldquo; z&amp;rdquo;用于数字值10至35，将大写字母&amp;ldquo; A&amp;rdquo;至&amp;ldquo; Z&amp;rdquo;用于数字值36至61。无前缀（例如&amp;ldquo; 0x&amp;rdquo; ）添加到字符串中。如果x是nil指针，则返回&amp;ldquo; &amp;lt;nil&amp;gt;&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="42341adeec7d736d3551b283379c31741e77e4f9" translate="yes" xml:space="preserve">
          <source>Text returns the text of the comment. Comment markers (//, /*, and */), the first space of a line comment, and leading and trailing empty lines are removed. Multiple empty lines are reduced to one, and trailing space on lines is trimmed. Unless the result is empty, it is newline-terminated.</source>
          <target state="translated">Text 返回注释的文本。注释标记(//、**和*/)、行注释的第一个空格以及前导和尾部的空行都会被删除。多个空行将被缩减为一个,行的尾部空间将被修剪。除非结果是空的,否则它是以换行结束的。</target>
        </trans-unit>
        <trans-unit id="02af2db9a5ef05bc960487d876c4df951f9ad592" translate="yes" xml:space="preserve">
          <source>Text types have the charset parameter set to &quot;utf-8&quot; by default.</source>
          <target state="translated">文本类型的字符集参数默认设置为 &quot;utf-8&quot;。</target>
        </trans-unit>
        <trans-unit id="b44c08e7f92ae7b5fe535298ff7558bf9d8a0cab" translate="yes" xml:space="preserve">
          <source>TextMarshaler is the interface implemented by an object that can marshal itself into a textual form.</source>
          <target state="translated">TextMarshaler是由一个对象实现的接口,它可以将自己调集成一个文本形式。</target>
        </trans-unit>
        <trans-unit id="ae8b7afc36cfb51ffddc286e90577602c85186e4" translate="yes" xml:space="preserve">
          <source>TextNode holds plain text.</source>
          <target state="translated">TextNode存放纯文本。</target>
        </trans-unit>
        <trans-unit id="48668880c8086b3c4c912b1de227b18b3d9a93e1" translate="yes" xml:space="preserve">
          <source>TextUnmarshaler is the interface implemented by an object that can unmarshal a textual representation of itself.</source>
          <target state="translated">TextUnmarshaler是由一个对象实现的接口,它可以对自己的文本表示进行解扰。</target>
        </trans-unit>
        <trans-unit id="33b69b32d53f67278f1556c03b99ca73467e15b3" translate="yes" xml:space="preserve">
          <source>That is, when matching against text, the regexp returns a match that begins as early as possible in the input (leftmost), and among those it chooses a match that is as long as possible. This so-called leftmost-longest matching is the same semantics that early regular expression implementations used and that POSIX specifies.</source>
          <target state="translated">也就是说,当与文本进行匹配时,regexp会返回一个在输入中尽可能早开始的匹配(最左),并在其中选择一个尽可能长的匹配。这种所谓的最左-最长匹配与早期正则表达式实现所使用的语义相同,也是POSIX所规定的。</target>
        </trans-unit>
        <trans-unit id="1fe9add248f3617655fdc8371d42751cba2e4007" translate="yes" xml:space="preserve">
          <source>The &quot;omitempty&quot; option specifies that the field should be omitted from the encoding if the field has an empty value, defined as false, 0, a nil pointer, a nil interface value, and any empty array, slice, map, or string.</source>
          <target state="translated">omitempty &quot;选项指定,如果字段的值为空,则应从编码中省略,定义为false、0、nil指针、nil接口值,以及任何空数组、片、映射或字符串。</target>
        </trans-unit>
        <trans-unit id="71d19b0f94317203bba62dcd8f10cd68c650f96b" translate="yes" xml:space="preserve">
          <source>The &quot;string&quot; option signals that a field is stored as JSON inside a JSON-encoded string. It applies only to fields of string, floating point, integer, or boolean types. This extra level of encoding is sometimes used when communicating with JavaScript programs:</source>
          <target state="translated">&quot;string &quot;选项标志着一个字段以JSON的形式存储在一个JSON编码的字符串中,它只适用于字符串、浮点、整数或布尔类型的字段。它只适用于字符串、浮点、整数或布尔类型的字段。这种额外的编码级别有时在与JavaScript程序通信时使用。</target>
        </trans-unit>
        <trans-unit id="d1ee29ca2c06802f34981d89493c0bb6f1d6d312" translate="yes" xml:space="preserve">
          <source>The %!s just shows the print verb in use when the failure occurred. If the panic is caused by a nil receiver to an Error or String method, however, the output is the undecorated string, &quot;&amp;lt;nil&amp;gt;&quot;.</source>
          <target state="translated">％！s仅显示发生故障时正在使用的打印动词。但是，如果恐慌是由nil接收者导致Error或String方法引起的，则输出为未经修饰的字符串&amp;ldquo; &amp;lt;nil&amp;gt;&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="743e4c8e9a91e391bfa222546fd5a23a69c683b9" translate="yes" xml:space="preserve">
          <source>The *Basic type for Typ[Byte] will have the name &quot;uint8&quot;. Use Universe.Lookup(&quot;byte&quot;).Type() to obtain the specific alias basic type named &quot;byte&quot; (and analogous for &quot;rune&quot;).</source>
          <target state="translated">Typ[Byte]的*基本类型会有 &quot;uint8 &quot;的名称。使用Universe.Lookup(&quot;byte&quot;).Type()来获取名为 &quot;byte &quot;的特定别名基本类型(类似于 &quot;rune&quot;)。</target>
        </trans-unit>
        <trans-unit id="850dd1df743a69c63fe9886362ac383beaaa22a7" translate="yes" xml:space="preserve">
          <source>The AES block size in bytes.</source>
          <target state="translated">AES块的大小,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="5673ab8326600fbbe495a6285dd8ced305ce9de8" translate="yes" xml:space="preserve">
          <source>The AES operations in this package are not implemented using constant-time algorithms. An exception is when running on systems with enabled hardware support for AES that makes these operations constant-time. Examples include amd64 systems using AES-NI extensions and s390x systems using Message-Security-Assist extensions. On such systems, when the result of NewCipher is passed to cipher.NewGCM, the GHASH operation used by GCM is also constant-time.</source>
          <target state="translated">这个软件包中的AES操作并不是使用恒定时间算法来实现的。一个例外的情况是,当运行在启用了AES硬件支持的系统上,使这些操作成为恒时的。例如使用AES-NI扩展的amd64系统和使用Message-Security-Assist扩展的s390x系统。在这样的系统上,当NewCipher的结果传递给cipher.NewGCM时,GCM使用的GHASH操作也是恒时的。</target>
        </trans-unit>
        <trans-unit id="6adb0b7099e3661b5d507077f904503946e1529a" translate="yes" xml:space="preserve">
          <source>The AuthorityKeyId will be taken from the SubjectKeyId of parent, if any, unless the resulting certificate is self-signed. Otherwise the value from template will be used.</source>
          <target state="translated">AuthorityKeyId将取自父代的SubjectKeyId(如果有的话),除非产生的证书是自签的。否则将使用模板中的值。</target>
        </trans-unit>
        <trans-unit id="ef02c253bf1371acc1a3bc5ebf403abe9da8e69d" translate="yes" xml:space="preserve">
          <source>The CPU profile is not available as a Profile. It has a special API, the StartCPUProfile and StopCPUProfile functions, because it streams output to a writer during profiling.</source>
          <target state="translated">CPU配置文件不能作为Profile使用。它有一个特殊的API,即StartCPUProfile和StopCPUProfile函数,因为它在剖析过程中会将输出流转到一个写入器。</target>
        </trans-unit>
        <trans-unit id="36bb730fcee3dc3ab8099094b237b4e5ff536824" translate="yes" xml:space="preserve">
          <source>The Call method waits for the remote call to complete while the Go method launches the call asynchronously and signals completion using the Call structure's Done channel.</source>
          <target state="translated">Call方法等待远程调用完成,而Go方法异步启动调用,并使用Call结构的Done通道发出完成信号。</target>
        </trans-unit>
        <trans-unit id="fa9c5434f905167654701708a6911e94eaa76597" translate="yes" xml:space="preserve">
          <source>The Client and Transport return Responses from servers once the response headers have been received. The response body is streamed on demand as the Body field is read.</source>
          <target state="translated">一旦收到响应头,客户端和传输就会从服务器返回响应。读取Body字段时,响应主体会按要求进行流式传输。</target>
        </trans-unit>
        <trans-unit id="a06861d55f6598b58fca7ecb30c8e99763835023" translate="yes" xml:space="preserve">
          <source>The Client's Transport typically has internal state (cached TCP connections), so Clients should be reused instead of created as needed. Clients are safe for concurrent use by multiple goroutines.</source>
          <target state="translated">Client的Transport通常具有内部状态(缓存的TCP连接),所以应该在需要时重复使用而不是创建Client。客户端对于多个goroutine的并发使用是安全的。</target>
        </trans-unit>
        <trans-unit id="ceca2d7732940705f6d00b5d32a4fb0ac5b5ffee" translate="yes" xml:space="preserve">
          <source>The CloseNotifier interface is implemented by ResponseWriters which allow detecting when the underlying connection has gone away.</source>
          <target state="translated">CloseNotifier接口是由ResponseWriters实现的,它允许检测底层连接何时消失。</target>
        </trans-unit>
        <trans-unit id="e611d14841eea36df4afcbef6632f0e94c16f389" translate="yes" xml:space="preserve">
          <source>The Comments list contains all comments in the source file in order of appearance, including the comments that are pointed to from other nodes via Doc and Comment fields.</source>
          <target state="translated">评论列表包含了源文件中的所有评论,按出现的顺序排列,包括通过Doc和Comment字段从其他节点指向的评论。</target>
        </trans-unit>
        <trans-unit id="7243291c556ac8dd62df98afdad8c3760dcef423" translate="yes" xml:space="preserve">
          <source>The Content-Type header is set to application/x-www-form-urlencoded. To set other headers, use NewRequest and Client.Do.</source>
          <target state="translated">Content-Type头被设置为application/x-www-form-urlencoded。要设置其他头,使用NewRequest和Client.Do。</target>
        </trans-unit>
        <trans-unit id="4c8514b948c44917ccd4528524ea490c8df7afe9" translate="yes" xml:space="preserve">
          <source>The Content-Type header is set to application/x-www-form-urlencoded. To set other headers, use NewRequest and DefaultClient.Do.</source>
          <target state="translated">Content-Type头被设置为application/x-www-form-urlencoded。要设置其他头,使用NewRequest和DefaultClient.Do。</target>
        </trans-unit>
        <trans-unit id="e64fbf6aec6e290cb2a86c841a198b35f0414494" translate="yes" xml:space="preserve">
          <source>The Context field will be zero to gather a traceback from the current program execution point. In this case, the traceback function will be called from C code.</source>
          <target state="translated">Context字段将为零,以收集当前程序执行点的回溯。在这种情况下,回溯函数将从C代码中调用。</target>
        </trans-unit>
        <trans-unit id="0d4ab0b54e24df8d963181a5b8f48a80c3f0be3b" translate="yes" xml:space="preserve">
          <source>The Copy function uses ReaderFrom if available.</source>
          <target state="translated">复制功能使用ReaderFrom(如果有)。</target>
        </trans-unit>
        <trans-unit id="64b7a752d1105251970c527872a99e908894fe83" translate="yes" xml:space="preserve">
          <source>The Copy function uses WriterTo if available.</source>
          <target state="translated">如果有的话,复制函数使用WriterTo。</target>
        </trans-unit>
        <trans-unit id="4068b76cb1fd1e06d5771c04e2c02b7fd65472c1" translate="yes" xml:space="preserve">
          <source>The DES block size in bytes.</source>
          <target state="translated">DES块大小,单位为字节。</target>
        </trans-unit>
        <trans-unit id="1b8c2351859f5d138662581cb4874dd621eef345" translate="yes" xml:space="preserve">
          <source>The DSA operations in this package are not implemented using constant-time algorithms.</source>
          <target state="translated">本包中的DSA操作没有使用恒时算法来实现。</target>
        </trans-unit>
        <trans-unit id="3d5a6f0be8af4ae349714dde142378b2b0dd32c1" translate="yes" xml:space="preserve">
          <source>The Data fields contains object-specific data:</source>
          <target state="translated">数据字段包含特定对象的数据。</target>
        </trans-unit>
        <trans-unit id="d70280d8e959481aa07b78bca8cd9c9158da0c1f" translate="yes" xml:space="preserve">
          <source>The Decoder does only basic sanity checking on decoded input sizes, and its limits are not configurable. Take caution when decoding gob data from untrusted sources.</source>
          <target state="translated">解码器只对解码后的输入大小进行基本的理智性检查,其限制是不可配置的。在对来自不受信任的来源的gob数据进行解码时,请小心谨慎。</target>
        </trans-unit>
        <trans-unit id="1a3dcfbdb85a6eb02179c9d5c4dd5b3efbbb6016" translate="yes" xml:space="preserve">
          <source>The Dial function connects to a server:</source>
          <target state="translated">拨号功能连接到服务器。</target>
        </trans-unit>
        <trans-unit id="e5af1dd969514f431da9aefdd41666a5f815fd72" translate="yes" xml:space="preserve">
          <source>The Error interface identifies a run time error.</source>
          <target state="translated">错误接口识别运行时的错误。</target>
        </trans-unit>
        <trans-unit id="8e437b0bdb4841542eba2f049276dee573f887b3" translate="yes" xml:space="preserve">
          <source>The Errorf function lets us use formatting features to create descriptive error messages.</source>
          <target state="translated">Errorf功能让我们可以使用格式化功能来创建描述性的错误信息。</target>
        </trans-unit>
        <trans-unit id="4cc7e273196b60c7b327e2a1e7c92da50e59b611" translate="yes" xml:space="preserve">
          <source>The Examples section of the documentation includes an illustration of how to use MakeFunc to build a swap function for different types.</source>
          <target state="translated">文档中的示例部分包含了如何使用MakeFunc为不同类型构建交换函数的说明。</target>
        </trans-unit>
        <trans-unit id="a4103d71ff7738d060819734b8440840f86eb6a7" translate="yes" xml:space="preserve">
          <source>The Flusher interface is implemented by ResponseWriters that allow an HTTP handler to flush buffered data to the client.</source>
          <target state="translated">Flusher接口是由ResponseWriters实现的,它允许HTTP处理程序将缓冲数据刷新到客户端。</target>
        </trans-unit>
        <trans-unit id="8989cf7d3fb3d7f0d686b9d17d09faeb78214543" translate="yes" xml:space="preserve">
          <source>The GIF specification is at &lt;a href=&quot;https://www.w3.org/Graphics/GIF/spec-gif89a.txt&quot;&gt;https://www.w3.org/Graphics/GIF/spec-gif89a.txt&lt;/a&gt;.</source>
          <target state="translated">GIF规范位于&lt;a href=&quot;https://www.w3.org/Graphics/GIF/spec-gif89a.txt&quot;&gt;https://www.w3.org/Graphics/GIF/spec-gif89a.txt&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="413f2e2abeee0cebf1b4d1ac0f711038cf2ef825" translate="yes" xml:space="preserve">
          <source>The GOARCH, GOOS, GOPATH, and GOROOT environment variables complete the set of Go environment variables. They influence the building of Go programs (see &lt;a href=&quot;https://golang.org/cmd/go&quot;&gt;https://golang.org/cmd/go&lt;/a&gt; and &lt;a href=&quot;../go/build/index&quot;&gt;https://golang.org/pkg/go/build&lt;/a&gt;). GOARCH, GOOS, and GOROOT are recorded at compile time and made available by constants or functions in this package, but they do not influence the execution of the run-time system.</source>
          <target state="translated">GOARCH，GOOS，GOPATH和GOROOT环境变量完善了Go环境变量集。它们会影响Go程序的构建（请参阅&lt;a href=&quot;https://golang.org/cmd/go&quot;&gt;https://golang.org/cmd/go&lt;/a&gt;和&lt;a href=&quot;../go/build/index&quot;&gt;https://golang.org/pkg/go/build&lt;/a&gt;）。GOARCH，GOOS和GOROOT会在编译时记录下来，并可以通过此包中的常量或函数使用，但它们不会影响运行时系统的执行。</target>
        </trans-unit>
        <trans-unit id="980859c522964a8cbb3109a2a563d54c04b37667" translate="yes" xml:space="preserve">
          <source>The GODEBUG variable controls debugging variables within the runtime. It is a comma-separated list of name=val pairs setting these named variables:</source>
          <target state="translated">GODEBUG变量控制运行时内的调试变量。它是一个由name=val对组成的逗号分隔的列表,用于设置这些命名的变量。</target>
        </trans-unit>
        <trans-unit id="854b96235a6d258614ac621d5a074c350962980a" translate="yes" xml:space="preserve">
          <source>The GODEBUG variables are not covered by Go's API compatibility promise. Please report any issues before disabling HTTP/2 support: &lt;a href=&quot;https://golang.org/s/http2bug&quot;&gt;https://golang.org/s/http2bug&lt;/a&gt;</source>
          <target state="translated">Go的API兼容性保证不涵盖GODEBUG变量。请先报告所有问题，然后再禁用HTTP / 2支持：&lt;a href=&quot;https://golang.org/s/http2bug&quot;&gt;https&lt;/a&gt;：//golang.org/s/http2bug</target>
        </trans-unit>
        <trans-unit id="07350ebc65d6866cf7470b34fa919f4c89a12e5a" translate="yes" xml:space="preserve">
          <source>The GOGC variable sets the initial garbage collection target percentage. A collection is triggered when the ratio of freshly allocated data to live data remaining after the previous collection reaches this percentage. The default is GOGC=100. Setting GOGC=off disables the garbage collector entirely. The runtime/debug package's SetGCPercent function allows changing this percentage at run time. See &lt;a href=&quot;debug/index#SetGCPercent&quot;&gt;https://golang.org/pkg/runtime/debug/#SetGCPercent&lt;/a&gt;.</source>
          <target state="translated">GOGC变量设置初始垃圾回收目标百分比。当新分配的数据与上一个收集后剩余的实时数据之比达到此百分比时，将触发收集。默认值为GOGC = 100。设置GOGC = off将完全禁用垃圾收集器。运行时/调试包的SetGCPercent函数允许在运行时更改此百分比。参见&lt;a href=&quot;debug/index#SetGCPercent&quot;&gt;https://golang.org/pkg/runtime/debug/#SetGCPercent&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="23644add17b2d4ea82387647518fec703dd62cda" translate="yes" xml:space="preserve">
          <source>The GOMAXPROCS variable limits the number of operating system threads that can execute user-level Go code simultaneously. There is no limit to the number of threads that can be blocked in system calls on behalf of Go code; those do not count against the GOMAXPROCS limit. This package's GOMAXPROCS function queries and changes the limit.</source>
          <target state="translated">GOMAXPROCS变量限制了可以同时执行用户级围棋代码的操作系统线程数量。对于在系统调用中代表围棋代码被阻塞的线程数量没有限制,这些线程不计入GOMAXPROCS限制。本包的GOMAXPROCS函数可以查询并更改该限制。</target>
        </trans-unit>
        <trans-unit id="2dc1829c430b9fe1fcd42a5d7af5182478e7df72" translate="yes" xml:space="preserve">
          <source>The GORACE variable configures the race detector, for programs built using -race. See &lt;a href=&quot;https://golang.org/doc/articles/race_detector.html&quot;&gt;https://golang.org/doc/articles/race_detector.html&lt;/a&gt; for details.</source>
          <target state="translated">GORACE变量为使用-race构建的程序配置了竞争检测器。有关详细信息，请参见&lt;a href=&quot;https://golang.org/doc/articles/race_detector.html&quot;&gt;https://golang.org/doc/articles/race_detector.html&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="895a2c86582e638542cc835d086a523cf9768898" translate="yes" xml:space="preserve">
          <source>The GOTRACEBACK variable controls the amount of output generated when a Go program fails due to an unrecovered panic or an unexpected runtime condition. By default, a failure prints a stack trace for the current goroutine, eliding functions internal to the run-time system, and then exits with exit code 2. The failure prints stack traces for all goroutines if there is no current goroutine or the failure is internal to the run-time. GOTRACEBACK=none omits the goroutine stack traces entirely. GOTRACEBACK=single (the default) behaves as described above. GOTRACEBACK=all adds stack traces for all user-created goroutines. GOTRACEBACK=system is like &amp;ldquo;all&amp;rdquo; but adds stack frames for run-time functions and shows goroutines created internally by the run-time. GOTRACEBACK=crash is like &amp;ldquo;system&amp;rdquo; but crashes in an operating system-specific manner instead of exiting. For example, on Unix systems, the crash raises SIGABRT to trigger a core dump. For historical reasons, the GOTRACEBACK settings 0, 1, and 2 are synonyms for none, all, and system, respectively. The runtime/debug package's SetTraceback function allows increasing the amount of output at run time, but it cannot reduce the amount below that specified by the environment variable. See &lt;a href=&quot;debug/index#SetTraceback&quot;&gt;https://golang.org/pkg/runtime/debug/#SetTraceback&lt;/a&gt;.</source>
          <target state="translated">GOTRACEBACK变量控制在Go程序由于未恢复的紧急情况或意外的运行时条件而失败时生成的输出量。默认情况下，故障将打印当前goroutine的堆栈跟踪，清除运行时系统内部的函数，然后以退出代码2退出。如果没有当前goroutine或故障是失败，则故障将打印所有goroutine的堆栈跟踪。在运行时内部。 GOTRACEBACK = none完全省略goroutine堆栈跟踪。 GOTRACEBACK = single（默认）的行为如上所述。 GOTRACEBACK = all为所有用户创建的goroutine添加堆栈跟踪。 GOTRACEBACK = system类似于&amp;ldquo; all&amp;rdquo;，但为运行时功能添加了堆栈框架，并显示了运行时在内部创建的goroutine。GOTRACEBACK = crash类似于&amp;ldquo; system&amp;rdquo;，但是以特定于操作系统的方式崩溃而不是退出。例如，在Unix系统上，崩溃导致SIGABRT触发核心转储。由于历史原因，GOTRACEBACK设置0、1和2分别是none，all和system的同义词。运行时/调试包的SetTraceback函数允许在运行时增加输出量，但不能将其减少到环境变量指定的量以下。看到但是它不能将数量减少到环境变量指定的数量以下。看到但是它不能将数量减少到环境变量指定的数量以下。看到&lt;a href=&quot;debug/index#SetTraceback&quot;&gt;https://golang.org/pkg/runtime/debug/#SetTraceback&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="201ea9b13c6c1b11811e547f191be7e93f488ebd" translate="yes" xml:space="preserve">
          <source>The Go 1 compatibility guidelines make it impossible for us to change the behavior of these methods; use Read or ReadMsgIP instead.</source>
          <target state="translated">Go 1的兼容性准则使我们无法改变这些方法的行为;请使用Read或ReadMsgIP代替。</target>
        </trans-unit>
        <trans-unit id="c7566eb3c6d36d40991cd457887383d73c8d32f6" translate="yes" xml:space="preserve">
          <source>The Go path is a list of directory trees containing Go source code. It is consulted to resolve imports that cannot be found in the standard Go tree. The default path is the value of the GOPATH environment variable, interpreted as a path list appropriate to the operating system (on Unix, the variable is a colon-separated string; on Windows, a semicolon-separated string; on Plan 9, a list).</source>
          <target state="translated">Go路径是包含Go源代码的目录树列表。它被用来解决在标准Go树中找不到的导入。默认路径是GOPATH环境变量的值,解释为适合操作系统的路径列表(在Unix上,该变量是一个以冒号分隔的字符串;在Windows上,是一个以分号分隔的字符串;在Plan 9上,是一个列表)。</target>
        </trans-unit>
        <trans-unit id="b3cf2d68365e20d0973a301087cdd0150f378764" translate="yes" xml:space="preserve">
          <source>The Go visibility rules for struct fields are amended for JSON when deciding which field to marshal or unmarshal. If there are multiple fields at the same level, and that level is the least nested (and would therefore be the nesting level selected by the usual Go rules), the following extra rules apply:</source>
          <target state="translated">在决定对哪个字段进行整合或取消整合时,对JSON结构字段的围棋可见性规则进行了修正。如果同一层次有多个字段,而且该层次是最小的嵌套层次(因此是通常的Go规则所选择的嵌套层次),则适用以下额外规则。</target>
        </trans-unit>
        <trans-unit id="0fd6453ed937237b824b9a18906363db4d73b2a6" translate="yes" xml:space="preserve">
          <source>The HandlerFunc type is an adapter to allow the use of ordinary functions as HTTP handlers. If f is a function with the appropriate signature, HandlerFunc(f) is a Handler that calls f.</source>
          <target state="translated">HandlerFunc类型是一个适配器,允许使用普通函数作为HTTP处理程序。如果f是一个具有适当签名的函数,HandlerFunc(f)就是一个调用f的处理程序。</target>
        </trans-unit>
        <trans-unit id="dcde06a75814cbd2f82c57451a15f7098bfdc1f6" translate="yes" xml:space="preserve">
          <source>The Hijacker interface is implemented by ResponseWriters that allow an HTTP handler to take over the connection.</source>
          <target state="translated">Hijacker接口是由ResponseWriters实现的,它允许一个HTTP处理程序来接管连接。</target>
        </trans-unit>
        <trans-unit id="3370b385b8e5dd84393ea8ba4a384825a13db61b" translate="yes" xml:space="preserve">
          <source>The Interface type describes the requirements for a type using the routines in this package. Any type that implements it may be used as a min-heap with the following invariants (established after Init has been called or if the data is empty or sorted):</source>
          <target state="translated">接口类型描述了使用本包中的例程对类型的要求。任何实现它的类型都可以作为迷你堆使用,其不变性如下(在Init被调用后或数据为空或排序后建立)。</target>
        </trans-unit>
        <trans-unit id="0aee04eced9ac7c3fac2de601ac7413fde3bf654" translate="yes" xml:space="preserve">
          <source>The JSON null value unmarshals into an interface, map, pointer, or slice by setting that Go value to nil. Because null is often used in JSON to mean &amp;ldquo;not present,&amp;rdquo; unmarshaling a JSON null into any other Go type has no effect on the value and produces no error.</source>
          <target state="translated">通过将该Go值设置为nil，JSON空值可解组到接口，映射，指针或切片中。由于在JSON中通常使用null来表示&amp;ldquo;不存在&amp;rdquo;，因此将JSON null解组到任何其他Go类型中不会影响该值，并且不会产生任何错误。</target>
        </trans-unit>
        <trans-unit id="22f4320ee94c207b6f6c1bf76ec0cc99a4e78e12" translate="yes" xml:space="preserve">
          <source>The Listen function creates servers:</source>
          <target state="translated">Listen功能可以创建服务器。</target>
        </trans-unit>
        <trans-unit id="f1e8051445ee7295f2015e153c91e6e9f468a7b9" translate="yes" xml:space="preserve">
          <source>The Map type is optimized for two common use cases: (1) when the entry for a given key is only ever written once but read many times, as in caches that only grow, or (2) when multiple goroutines read, write, and overwrite entries for disjoint sets of keys. In these two cases, use of a Map may significantly reduce lock contention compared to a Go map paired with a separate Mutex or RWMutex.</source>
          <target state="translated">Map类型针对两种常见的用例进行了优化。(1)当一个给定的键的条目只被写入一次,但却被多次读取,如在只会增长的缓存中,或(2)当多个goroutine读取、写入和覆盖不相干的键集的条目时。在这两种情况下,与Go地图与单独的Mutex或RWMutex搭配使用相比,使用Map可能会显著减少锁的争用。</target>
        </trans-unit>
        <trans-unit id="93c1aea237df8273d73d6b2b1db4e7c127b7fdb2" translate="yes" xml:space="preserve">
          <source>The Map type is specialized. Most code should use a plain Go map instead, with separate locking or coordination, for better type safety and to make it easier to maintain other invariants along with the map content.</source>
          <target state="translated">Map类型是专门的。大多数代码应该使用普通的围棋地图来代替,并有单独的锁定或协调,以便更好地保证类型的安全性,并使其更容易与地图内容一起维护其他不变式。</target>
        </trans-unit>
        <trans-unit id="0006e6725a631489c9423aa1f192586acc3a14d6" translate="yes" xml:space="preserve">
          <source>The MergeMode flags control the behavior of MergePackageFiles.</source>
          <target state="translated">MergeMode标志控制MergePackageFiles的行为。</target>
        </trans-unit>
        <trans-unit id="46419978a96c95f07df701b47af9ce0c381fb8e5" translate="yes" xml:space="preserve">
          <source>The New function creates errors whose only content is a text message.</source>
          <target state="translated">新建函数创建的错误,其唯一的内容是一个文本消息。</target>
        </trans-unit>
        <trans-unit id="ed989955d8475da0903bbb33a13d3c6797487592" translate="yes" xml:space="preserve">
          <source>The PC field will be a value returned by a call to the traceback function.</source>
          <target state="translated">PC字段将是调用回溯函数所返回的值。</target>
        </trans-unit>
        <trans-unit id="886ce6ce1a2e11f65b175c91749f88d574c43226" translate="yes" xml:space="preserve">
          <source>The PNG specification is at &lt;a href=&quot;https://www.w3.org/TR/PNG/&quot;&gt;https://www.w3.org/TR/PNG/&lt;/a&gt;.</source>
          <target state="translated">PNG规范位于&lt;a href=&quot;https://www.w3.org/TR/PNG/&quot;&gt;https://www.w3.org/TR/PNG/&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e01da8fcfe6b3b9e18fc8125aed80da656d99c50" translate="yes" xml:space="preserve">
          <source>The Pos value for a given file is a number in the range [base, base+size], where base and size are specified when adding the file to the file set via AddFile.</source>
          <target state="translated">给定文件的Pos值是一个范围为[base,base+size]的数字,其中base和size是在通过AddFile添加文件到文件集时指定的。</target>
        </trans-unit>
        <trans-unit id="24b49c8f6cf4d6923667f2f4ded23d7140a2b9f0" translate="yes" xml:space="preserve">
          <source>The Priority is a combination of the syslog facility and severity. For example, LOG_ALERT | LOG_FTP sends an alert severity message from the FTP facility. The default severity is LOG_EMERG; the default facility is LOG_KERN.</source>
          <target state="translated">优先级是syslog设施和严重性的组合。例如,LOG_ALERT | LOG_FTP从FTP设施中发送警报严重性消息,默认严重性是LOG_EMERG;默认设施是LOG_KERN。默认的严重性是LOG_EMERG;默认的设施是LOG_KERN。</target>
        </trans-unit>
        <trans-unit id="c56c9b0bbe08c95a239dcc95eda30597b6ca619e" translate="yes" xml:space="preserve">
          <source>The Process it returns can be used to obtain information about the underlying operating system process.</source>
          <target state="translated">它返回的进程可以用来获取底层操作系统进程的信息。</target>
        </trans-unit>
        <trans-unit id="10801c2ff1093f1ce7c760ba00803c382474a94e" translate="yes" xml:space="preserve">
          <source>The RSA operations in this package are not implemented using constant-time algorithms.</source>
          <target state="translated">本包中的RSA操作没有使用恒时算法来实现。</target>
        </trans-unit>
        <trans-unit id="e75efacd08116681c05f3907c86c9cdff60db179" translate="yes" xml:space="preserve">
          <source>The ReadCloser returned by NewReader also implements Resetter.</source>
          <target state="translated">NewReader返回的ReadCloser也实现了Resetter。</target>
        </trans-unit>
        <trans-unit id="3bfc20a3944403086f24f5757939a8cbd9b7c5ac" translate="yes" xml:space="preserve">
          <source>The ReadCloser returned by NewReaderDict also implements Resetter.</source>
          <target state="translated">NewReaderDict返回的ReadCloser也实现了Resetter。</target>
        </trans-unit>
        <trans-unit id="c4f8edaea822742e73d1aca6a1265098af5d579e" translate="yes" xml:space="preserve">
          <source>The Reader converts all \r\n sequences in its input to plain \n, including in multiline field values, so that the returned data does not depend on which line-ending convention an input file uses.</source>
          <target state="translated">读取器将其输入中所有的&quot;/r/n &quot;序列转换为纯&quot;/r/n&quot;,包括在多行字段中的值,因此,返回的数据并不取决于输入文件使用的行尾约定。</target>
        </trans-unit>
        <trans-unit id="41c2e3518894534a6a634c57bbad5ea70224c3de" translate="yes" xml:space="preserve">
          <source>The Reader.Header fields will be valid in the Reader returned.</source>
          <target state="translated">Reader.Header字段将在返回的Reader中有效。</target>
        </trans-unit>
        <trans-unit id="9fd8011df0852a1e27b3907bd2a3f82247ef31e5" translate="yes" xml:space="preserve">
          <source>The Request.Proto is always HTTP/1.1.</source>
          <target state="translated">Request.Proto总是HTTP/1.1。</target>
        </trans-unit>
        <trans-unit id="09c4e81d433af7e0ae48c721f621859a4e5a3317" translate="yes" xml:space="preserve">
          <source>The Response Body is closed after it is sent.</source>
          <target state="translated">响应体发送后即关闭。</target>
        </trans-unit>
        <trans-unit id="041fd8da9679545d4de46a3a12d665330f551006" translate="yes" xml:space="preserve">
          <source>The Response.Body is guaranteed to be non-nil and Body.Read call is guaranteed to not return any error other than io.EOF.</source>
          <target state="translated">保证Response.Body是非nil,保证Body.Read调用不返回任何除io.EOF以外的错误。</target>
        </trans-unit>
        <trans-unit id="bc99bfa959e73d9ff72d10e54ecd5ffaa2259252" translate="yes" xml:space="preserve">
          <source>The Response.Header is a snapshot of the headers at the time of the first write call, or at the time of this call, if the handler never did a write.</source>
          <target state="translated">Response.Header是第一次写入调用时的头的快照,如果处理程序从未进行过写入,则在这次调用时。</target>
        </trans-unit>
        <trans-unit id="18a3ebac1f2c2059df0438aac114025f62ecfbf9" translate="yes" xml:space="preserve">
          <source>The Run methods of T and B allow defining subtests and sub-benchmarks, without having to define separate functions for each. This enables uses like table-driven benchmarks and creating hierarchical tests. It also provides a way to share common setup and tear-down code:</source>
          <target state="translated">T和B的Run方法允许定义子测试和子基准,而不必为每个子基准定义单独的函数。这使得像表格驱动的基准和创建分层测试这样的用途成为可能。它还提供了一种共享通用设置和拆卸代码的方法。</target>
        </trans-unit>
        <trans-unit id="2fdffd1148a25e94f2ea65756e345947d69016d2" translate="yes" xml:space="preserve">
          <source>The SendMail function and the net/smtp package are low-level mechanisms and provide no support for DKIM signing, MIME attachments (see the mime/multipart package), or other mail functionality. Higher-level packages exist outside of the standard library.</source>
          <target state="translated">SendMail函数和net/smtp包都是低级机制,不提供对DKIM签名、MIME附件(参见mime/multipart包)或其他邮件功能的支持。更高级别的包存在于标准库之外。</target>
        </trans-unit>
        <trans-unit id="f9a92bd5980ed21b3a625476d07c987591bfa7d7" translate="yes" xml:space="preserve">
          <source>The Spec type stands for any of *ImportSpec, *ValueSpec, and *TypeSpec.</source>
          <target state="translated">Spec类型代表*ImportSpec、*ValueSpec和*TypeSpec中的任何一种。</target>
        </trans-unit>
        <trans-unit id="4919a225e3add39379ff15a9bce358f52cae5ffb" translate="yes" xml:space="preserve">
          <source>The Syscall functions in package syscall pass their uintptr arguments directly to the operating system, which then may, depending on the details of the call, reinterpret some of them as pointers. That is, the system call implementation is implicitly converting certain arguments back from uintptr to pointer.</source>
          <target state="translated">包syscall中的Syscall函数将其uintptr参数直接传递给操作系统,然后根据调用的细节,系统可能会将其中的一些参数重新解释为指针。也就是说,系统调用的实现是隐性的将某些参数从uintptr转换回指针。</target>
        </trans-unit>
        <trans-unit id="3e332fd0096a988b6619d722b0818e386abfd30a" translate="yes" xml:space="preserve">
          <source>The TIFF file format uses a similar but incompatible version of the LZW algorithm. See the golang.org/x/image/tiff/lzw package for an implementation.</source>
          <target state="translated">TIFF文件格式使用了类似的但不兼容的LZW算法版本,请参见golang.org/x/image/tiff/lzw包的实现。参见golang.org/x/image/tiff/lzw包中的实现。</target>
        </trans-unit>
        <trans-unit id="58336a8c0934089954efcd803d6fca80fefa9eb4" translate="yes" xml:space="preserve">
          <source>The TLS field is set to a non-nil dummy value if target has scheme &quot;https&quot;.</source>
          <target state="translated">如果目标的方案为 &quot;https&quot;,则TLS字段会被设置为一个非零的虚值。</target>
        </trans-unit>
        <trans-unit id="d581afca4a5305392d28788d2eee7630e8dc138a" translate="yes" xml:space="preserve">
          <source>The Time returned by time.Now contains a monotonic clock reading. If Time t has a monotonic clock reading, t.Add adds the same duration to both the wall clock and monotonic clock readings to compute the result. Because t.AddDate(y, m, d), t.Round(d), and t.Truncate(d) are wall time computations, they always strip any monotonic clock reading from their results. Because t.In, t.Local, and t.UTC are used for their effect on the interpretation of the wall time, they also strip any monotonic clock reading from their results. The canonical way to strip a monotonic clock reading is to use t = t.Round(0).</source>
          <target state="translated">time.Now返回的时间包含一个单调时钟读数。如果时间t有一个单调时钟读数,t.Add就会对挂钟和单调时钟读数加上相同的持续时间来计算结果。因为t.AddDate(y,m,d)、t.Round(d)和t.Truncate(d)是挂钟时间的计算,所以它们总是从结果中去掉任何单调时钟读数。因为t.In、t.Local和t.UTC对墙时解释的影响,它们也会从结果中剥离任何单调时钟读数。剥离单调时钟读数的规范方法是使用 t=t.round(0)。</target>
        </trans-unit>
        <trans-unit id="33e81456d15715e940a5919174eaa3f7637dcde7" translate="yes" xml:space="preserve">
          <source>The Timer type represents a single event. When the Timer expires, the current time will be sent on C, unless the Timer was created by AfterFunc. A Timer must be created with NewTimer or AfterFunc.</source>
          <target state="translated">Timer类型代表一个单一事件。当Timer过期时,当前时间将被发送到C上,除非Timer是由AfterFunc创建的。定时器必须用NewTimer或AfterFunc创建。</target>
        </trans-unit>
        <trans-unit id="cf73d1723f31995bde582871be9d0a7a3c49f2e8" translate="yes" xml:space="preserve">
          <source>The Universe scope contains all predeclared objects of Go. It is the outermost scope of any chain of nested scopes.</source>
          <target state="translated">Universe 作用域包含 Go 的所有预定义对象。它是任何嵌套作用域链的最外层作用域。</target>
        </trans-unit>
        <trans-unit id="d2217feb010f2a9e20eb107dc97fbe00b28a97e3" translate="yes" xml:space="preserve">
          <source>The Unsafe package is the package returned by an importer for the import path &quot;unsafe&quot;.</source>
          <target state="translated">Unsafe包是导入路径为 &quot;unsafe &quot;的导入者返回的包。</target>
        </trans-unit>
        <trans-unit id="82e1a6db6a2ce451395a30960fcbaa8d447276c7" translate="yes" xml:space="preserve">
          <source>The Unwrap, Is and As functions work on errors that may wrap other errors. An error wraps another error if its type has the method</source>
          <target state="translated">Unwrap、Is和As函数用于处理可能包装其他错误的错误。如果一个错误的类型具有方法</target>
        </trans-unit>
        <trans-unit id="84a102639d5d98f811fc502808b53b881ef02020" translate="yes" xml:space="preserve">
          <source>The Userinfo type is an immutable encapsulation of username and password details for a URL. An existing Userinfo value is guaranteed to have a username set (potentially empty, as allowed by RFC 2396), and optionally a password.</source>
          <target state="translated">Userinfo类型是对一个URL的用户名和密码细节的不可改变的封装。一个现有的Userinfo值保证有一个用户名设置(可能是空的,RFC 2396允许的),还有一个可选的密码。</target>
        </trans-unit>
        <trans-unit id="fbd19f3117c4f5404c3dc4318c570ed741a162cd" translate="yes" xml:space="preserve">
          <source>The Value.Call method allows the caller to invoke a typed function in terms of Values; in contrast, MakeFunc allows the caller to implement a typed function in terms of Values.</source>
          <target state="translated">Value.Call方法允许调用者用Value调用一个类型化的函数;相反,MakeFunc允许调用者用Value实现一个类型化的函数。</target>
        </trans-unit>
        <trans-unit id="b671f0d2f06db5c55a3ebed77ddd3e1fdacf58bc" translate="yes" xml:space="preserve">
          <source>The Wait method will return the exit code and release associated resources once the command exits.</source>
          <target state="translated">Wait方法将在命令退出后返回退出代码并释放相关资源。</target>
        </trans-unit>
        <trans-unit id="f996448ff14d875bb2a49935e2e1a1c11597d19a" translate="yes" xml:space="preserve">
          <source>The WithCancel, WithDeadline, and WithTimeout functions take a Context (the parent) and return a derived Context (the child) and a CancelFunc. Calling the CancelFunc cancels the child and its children, removes the parent's reference to the child, and stops any associated timers. Failing to call the CancelFunc leaks the child and its children until the parent is canceled or the timer fires. The go vet tool checks that CancelFuncs are used on all control-flow paths.</source>
          <target state="translated">WithCancel、WithDeadline和WithTimeout函数接收一个Context(父函数)并返回一个派生Context(子函数)和一个CancelFunc。调用CancelFunc会取消子函数和它的子函数,删除父函数对子函数的引用,并停止任何相关的计时器。如果未能调用CancelFunc,则会泄露子代和它的子代,直到父代被取消或定时器启动。go vet工具会检查CancelFuncs是否被用于所有控制流路径。</target>
        </trans-unit>
        <trans-unit id="7ad67f6f0923ebfa2c780fb9b0118879fff918f1" translate="yes" xml:space="preserve">
          <source>The Writer assumes that all Unicode code points have the same width; this may not be true in some fonts or if the string contains combining characters.</source>
          <target state="translated">写字机假设所有的Unicode码点都有相同的宽度;在某些字体中,或者如果字符串中包含组合字符,这可能不是真的。</target>
        </trans-unit>
        <trans-unit id="e4b495842c9aa071c7e0475777b24079ec5d06f2" translate="yes" xml:space="preserve">
          <source>The Writer currently provides no support for sparse files.</source>
          <target state="translated">Writer目前不支持稀疏文件。</target>
        </trans-unit>
        <trans-unit id="53af9c2eed3edf32c0f1e34e826ade2723d6ef7e" translate="yes" xml:space="preserve">
          <source>The Writer must buffer input internally, because proper spacing of one line may depend on the cells in future lines. Clients must call Flush when done calling Write.</source>
          <target state="translated">写入器必须在内部缓冲输入,因为一行的正确间距可能取决于未来行的单元格。客户端在调用Write后必须调用Flush。</target>
        </trans-unit>
        <trans-unit id="628a74097036f85303a5350ae981dc164e95f20b" translate="yes" xml:space="preserve">
          <source>The Writer treats incoming bytes as UTF-8-encoded text consisting of cells terminated by horizontal ('\t') or vertical ('\v') tabs, and newline ('\n') or formfeed ('\f') characters; both newline and formfeed act as line breaks.</source>
          <target state="translated">写入器将输入的字节视为UTF-8编码的文本,由水平('/t')或垂直('/v')制表符、换行('/n')或换格式('/f')字符结束的单元格组成;换行和换格式都作为换行符。</target>
        </trans-unit>
        <trans-unit id="ff09099a8f170cf0d12905fa7c7238d645a38332" translate="yes" xml:space="preserve">
          <source>The XML element for a struct contains marshaled elements for each of the exported fields of the struct, with these exceptions:</source>
          <target state="translated">一个结构的XML元素包含该结构的每个导出字段的marshaled元素,但有以下例外。</target>
        </trans-unit>
        <trans-unit id="79336ab4324d9f5dfdaefa0128d6e4be21b88b75" translate="yes" xml:space="preserve">
          <source>The []byte arguments are the data from the corresponding debug section in the object file; for example, for an ELF object, abbrev is the contents of the &quot;.debug_abbrev&quot; section.</source>
          <target state="translated">[]字节参数是对象文件中相应的调试部分的数据,例如,对于ELF对象,abbrev是&quot;.debug_abbrev &quot;部分的内容。</target>
        </trans-unit>
        <trans-unit id="76c0ad8d05ede9a06fba9319e4883b6c3aed9f8a" translate="yes" xml:space="preserve">
          <source>The actual read interface needed by NewReader. If the passed in io.Reader does not also have ReadByte, the NewReader will introduce its own buffering.</source>
          <target state="translated">NewReader实际需要的读取接口。如果传入的io.Reader没有ReadByte,NewReader将引入自己的缓冲。</target>
        </trans-unit>
        <trans-unit id="c853d84a15cfc8c913087ccf677e5edf1ca53e04" translate="yes" xml:space="preserve">
          <source>The add operation, implemented by the AddT functions, is the atomic equivalent of:</source>
          <target state="translated">由AddT函数实现的加法运算,其原子等价物为:。</target>
        </trans-unit>
        <trans-unit id="7b4a22ebac17d94f75fe50addbae480c54b8e412" translate="yes" xml:space="preserve">
          <source>The addresses in the to parameter are the SMTP RCPT addresses.</source>
          <target state="translated">to参数中的地址是SMTP RCPT的地址。</target>
        </trans-unit>
        <trans-unit id="fa78f066db9b3a5524ca42a8affe77f75da9d63e" translate="yes" xml:space="preserve">
          <source>The allocs profile is the same as the heap profile but changes the default pprof display to -alloc_space, the total number of bytes allocated since the program began (including garbage-collected bytes).</source>
          <target state="translated">allocs配置文件与堆配置文件相同,但将默认的pprof显示改为-alloc_space,即程序开始后分配的字节总数(包括垃圾回收的字节)。</target>
        </trans-unit>
        <trans-unit id="7b7e2adce610eba0eb46d47752259233e509b5f5" translate="yes" xml:space="preserve">
          <source>The append built-in function appends elements to the end of a slice. If it has sufficient capacity, the destination is resliced to accommodate the new elements. If it does not, a new underlying array will be allocated. Append returns the updated slice. It is therefore necessary to store the result of append, often in the variable holding the slice itself:</source>
          <target state="translated">append内置函数将元素追加到分片的末尾。如果它有足够的容量,目标会被重新分片以容纳新的元素。如果没有,将分配一个新的底层数组。Append返回更新后的分片。因此,有必要将append的结果存储起来,通常存储在持有分片本身的变量中。</target>
        </trans-unit>
        <trans-unit id="319121c4cf28a1a73f5a5d055a29a23993940f46" translate="yes" xml:space="preserve">
          <source>The argument obj must be a pointer to an object allocated by calling new, by taking the address of a composite literal, or by taking the address of a local variable. The argument finalizer must be a function that takes a single argument to which obj's type can be assigned, and can have arbitrary ignored return values. If either of these is not true, SetFinalizer may abort the program.</source>
          <target state="translated">参数obj必须是一个指针,指向一个通过调用new、取复合文字的地址或取局部变量的地址分配的对象。参数finalizer必须是一个函数,它接受一个单一的参数,obj的类型可以被分配给它,并且可以有任意忽略的返回值。如果其中一个不为真,SetFinalizer可能会中止程序。</target>
        </trans-unit>
        <trans-unit id="cd8b4269726f03ea74d83f3435788f2723fca1f6" translate="yes" xml:space="preserve">
          <source>The argument pos must have been returned by a call to Tell on this line table.</source>
          <target state="translated">参数pos必须是通过调用本行表的Tell返回的。</target>
        </trans-unit>
        <trans-unit id="b92996537add2723dc45807913fd63c71882192d" translate="yes" xml:space="preserve">
          <source>The argument to the -run and -bench command-line flags is an unanchored regular expression that matches the test's name. For tests with multiple slash-separated elements, such as subtests, the argument is itself slash-separated, with expressions matching each name element in turn. Because it is unanchored, an empty expression matches any string. For example, using &quot;matching&quot; to mean &quot;whose name contains&quot;:</source>
          <target state="translated">-run 和 -bench 命令行标志的参数是一个与测试名称相匹配的无锚正则表达式。对于有多个斜线分隔元素的测试,比如子测试,参数本身是斜线分隔的,表达式依次匹配每个名称元素。因为它是无锚的,所以空的表达式可以匹配任何字符串。例如,用 &quot;匹配 &quot;来表示 &quot;其名称包含&quot;。</target>
        </trans-unit>
        <trans-unit id="e79a98521fd13244e0b154d938bb00c75c9b0451" translate="yes" xml:space="preserve">
          <source>The base argument must be 0 or a value between 2 and MaxBase. For base 0, the number prefix determines the actual base: A prefix of &amp;ldquo;0b&amp;rdquo; or &amp;ldquo;0B&amp;rdquo; selects base 2, &amp;ldquo;0&amp;rdquo;, &amp;ldquo;0o&amp;rdquo; or &amp;ldquo;0O&amp;rdquo; selects base 8, and &amp;ldquo;0x&amp;rdquo; or &amp;ldquo;0X&amp;rdquo; selects base 16. Otherwise, the selected base is 10 and no prefix is accepted.</source>
          <target state="translated">基本参数必须为0或2到MaxBase之间的值。对于以0为底的数字，数字前缀确定实际的底数：以&amp;ldquo; 0b&amp;rdquo;或&amp;ldquo; 0B&amp;rdquo;为前缀选择2，以&amp;ldquo; 0&amp;rdquo;，&amp;ldquo; 0o&amp;rdquo;或&amp;ldquo; 0O&amp;rdquo;为前缀选择8，以&amp;ldquo; 0x&amp;rdquo;或&amp;ldquo; 0X&amp;rdquo;为前缀选择base16。否则，所选的base为10，并且不接受前缀。</target>
        </trans-unit>
        <trans-unit id="1f5bc3650196f245f397cccfe0b715471a484024" translate="yes" xml:space="preserve">
          <source>The base argument must be 0, 2, 8, 10, or 16. Providing an invalid base argument will lead to a run-time panic.</source>
          <target state="translated">基本参数必须是0、2、8、10或16。提供一个无效的基本参数会导致运行时的恐慌。</target>
        </trans-unit>
        <trans-unit id="999251e457607fde479613cc188e10bb8aa35ffc" translate="yes" xml:space="preserve">
          <source>The behavior of Close after the first call is undefined. Specific implementations may document their own behavior.</source>
          <target state="translated">第一次调用后Close的行为没有定义。具体的实现可以记录自己的行为。</target>
        </trans-unit>
        <trans-unit id="a5501fbd34c66d8be25df49275f9a5880a90030a" translate="yes" xml:space="preserve">
          <source>The benchmark function must run the target code b.N times. During benchmark execution, b.N is adjusted until the benchmark function lasts long enough to be timed reliably. The output</source>
          <target state="translated">基准函数必须运行目标代码b.N次。在基准执行过程中,b.N会被调整,直到基准函数持续足够长的时间来可靠地计时。输出</target>
        </trans-unit>
        <trans-unit id="5d5239994cd75391745c3ffd216fe5a8cda11e2c" translate="yes" xml:space="preserve">
          <source>The bin/ directory holds compiled commands. Each command is named for its source directory, but only using the final element, not the entire path. That is, the command with source in DIR/src/foo/quux is installed into DIR/bin/quux, not DIR/bin/foo/quux. The foo/ is stripped so that you can add DIR/bin to your PATH to get at the installed commands.</source>
          <target state="translated">bin/目录下存放的是编译后的命令。每条命令都以它的源目录命名,但只使用最后一个元素,而不是整个路径。也就是说,源码在DIR/src/foo/quux中的命令被安装到DIR/bin/quux中,而不是DIR/bin/foo/quux。foo/是被剥离的,所以你可以将DIR/bin添加到你的PATH中以获得安装的命令。</target>
        </trans-unit>
        <trans-unit id="5fb2943938d895315eb0861e562b65ec37e4257a" translate="yes" xml:space="preserve">
          <source>The bitSize argument specifies the integer type that the result must fit into. Bit sizes 0, 8, 16, 32, and 64 correspond to int, int8, int16, int32, and int64. If bitSize is below 0 or above 64, an error is returned.</source>
          <target state="translated">bitSize参数指定了结果必须适合的整数类型。位大小为0、8、16、32和64,分别对应int、int8、int16、int32和int64。如果bitSize低于0或高于64,将返回一个错误。</target>
        </trans-unit>
        <trans-unit id="73a023e42c8f449dd9afceb038f53730f09d0f3a" translate="yes" xml:space="preserve">
          <source>The blocksize of MD5 in bytes.</source>
          <target state="translated">MD5的块大小,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="b15f9638286bf74ad9f05789a97346025af52de4" translate="yes" xml:space="preserve">
          <source>The blocksize of SHA-1 in bytes.</source>
          <target state="translated">SHA-1的块大小,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="a7b36663bea360572efce2e38cb3e1eb26ceecf3" translate="yes" xml:space="preserve">
          <source>The blocksize of SHA256 and SHA224 in bytes.</source>
          <target state="translated">SHA256和SHA224的块大小,单位为字节。</target>
        </trans-unit>
        <trans-unit id="97aa274f72b6214d58f8cac268e6604a5f6faa7b" translate="yes" xml:space="preserve">
          <source>The body function will be run in each goroutine. It should set up any goroutine-local state and then iterate until pb.Next returns false. It should not use the StartTimer, StopTimer, or ResetTimer functions, because they have global effect. It should also not call Run.</source>
          <target state="translated">身体函数将在每个goroutine中运行,它应该设置任何goroutine的局部状态,然后迭代直到pb.Next返回false。它应该设置任何goroutine的局部状态,然后迭代直到pb.Next返回false。它不应该使用StartTimer、StopTimer或ResetTimer函数,因为它们具有全局效应。它也不应该调用Run.Next函数,因为它们具有全局效应。</target>
        </trans-unit>
        <trans-unit id="af7dc8ebb6f00c62864546d31e047f12c2a2774d" translate="yes" xml:space="preserve">
          <source>The boolean functions take any zero value to be false and a non-zero value to be true.</source>
          <target state="translated">布林函数取任何零值为假,非零值为真。</target>
        </trans-unit>
        <trans-unit id="0ca3ec8906bf9075e98bceae22793965b445ac42" translate="yes" xml:space="preserve">
          <source>The boundary is usually obtained from the &quot;boundary&quot; parameter of the message's &quot;Content-Type&quot; header. Use mime.ParseMediaType to parse such headers.</source>
          <target state="translated">边界通常由消息的 &quot;Content-Type &quot;头的 &quot;boundary &quot;参数获得。使用mime.ParseMediaType来解析这种头。</target>
        </trans-unit>
        <trans-unit id="93f9cb3d63de38d1cca4d1f9efd9ca872f4716ce" translate="yes" xml:space="preserve">
          <source>The built-in table is small but on unix it is augmented by the local system's mime.types file(s) if available under one or more of these names:</source>
          <target state="translated">内置的表很小,但在unix上,如果本地系统的mime.types文件有一个或多个这样的名字,它就会被增加。</target>
        </trans-unit>
        <trans-unit id="e3abe768a37a21ebff40b7c9151a7b3edc6c44e0" translate="yes" xml:space="preserve">
          <source>The calendrical calculations always assume a Gregorian calendar, with no leap seconds.</source>
          <target state="translated">历法计算总是假设采用格里高利历,没有闰秒。</target>
        </trans-unit>
        <trans-unit id="dd3a4f20159bb2231f4a88b4a45f4b772e80ba3c" translate="yes" xml:space="preserve">
          <source>The caller should call Close when finished, to shut it down.</source>
          <target state="translated">呼叫者应在完成后呼叫关闭,将其关闭。</target>
        </trans-unit>
        <trans-unit id="257fee20f0af9c58c89645e121bcb859cd7d2ba2" translate="yes" xml:space="preserve">
          <source>The cap built-in function returns the capacity of v, according to its type:</source>
          <target state="translated">cap内置函数根据v的类型,返回v的容量。</target>
        </trans-unit>
        <trans-unit id="e553ed25dbd923acc16eb919df1e53d3eec5c8ba" translate="yes" xml:space="preserve">
          <source>The certificate is signed by parent. If parent is equal to template then the certificate is self-signed. The parameter pub is the public key of the signee and priv is the private key of the signer.</source>
          <target state="translated">证书是由父代签署的,如果父代等于模板,则证书是自签的。如果parent等于模板,则证书为自签。参数 pub 是签名人的公钥,priv 是签名人的私钥。</target>
        </trans-unit>
        <trans-unit id="dc1a26e65aace69e5a0db7ec46a4e897871c5c8e" translate="yes" xml:space="preserve">
          <source>The chain consists of err itself followed by the sequence of errors obtained by repeatedly calling Unwrap.</source>
          <target state="translated">该链由err本身组成,后面是反复调用Unwrap获得的错误序列。</target>
        </trans-unit>
        <trans-unit id="784fcd80e08909ffdec4906c1c0dba2f7d623904" translate="yes" xml:space="preserve">
          <source>The client must close the response body when finished with it:</source>
          <target state="translated">客户端完成响应体后必须关闭响应体。</target>
        </trans-unit>
        <trans-unit id="7b4dd52e8c63aa6987cf8c226672c7d4edb96f82" translate="yes" xml:space="preserve">
          <source>The close built-in function closes a channel, which must be either bidirectional or send-only. It should be executed only by the sender, never the receiver, and has the effect of shutting down the channel after the last sent value is received. After the last value has been received from a closed channel c, any receive from c will succeed without blocking, returning the zero value for the channel element. The form</source>
          <target state="translated">关闭内置函数关闭了一个通道,这个通道必须是双向的或者只发送的。它应该只由发送者执行,而不是由接收者执行,并且在接收到最后一个发送的值后具有关闭通道的效果。当最后一个值从一个关闭的通道c中接收到后,任何从c中接收的值都会成功而不被阻塞,返回通道元素的零值。形式是</target>
        </trans-unit>
        <trans-unit id="0c580a2c87e0f2186896309d301dc63aad975a10" translate="yes" xml:space="preserve">
          <source>The command must have been started by Start.</source>
          <target state="translated">该命令必须由Start启动。</target>
        </trans-unit>
        <trans-unit id="ef8e35ecfe346ef37bdb6a41007c64b491f6581e" translate="yes" xml:space="preserve">
          <source>The comment prefix &quot;Unordered output:&quot; is like &quot;Output:&quot;, but matches any line order:</source>
          <target state="translated">注释前缀 &quot;无序输出:&quot;和 &quot;输出:&quot;一样,但符合任何行序。</target>
        </trans-unit>
        <trans-unit id="af6f6bfe9472d6cd742ab07f4d13576c62ddc94c" translate="yes" xml:space="preserve">
          <source>The compare-and-swap operation, implemented by the CompareAndSwapT functions, is the atomic equivalent of:</source>
          <target state="translated">比较和交换操作,由CompareAndSwapT函数实现,是原子等价物。</target>
        </trans-unit>
        <trans-unit id="53528cbdfa92cb465406c07ac6068163f15d8aff" translate="yes" xml:space="preserve">
          <source>The comparison functions work on basic types only (or named basic types, such as &quot;type Celsius float32&quot;). They implement the Go rules for comparison of values, except that size and exact type are ignored, so any integer value, signed or unsigned, may be compared with any other integer value. (The arithmetic value is compared, not the bit pattern, so all negative integers are less than all unsigned integers.) However, as usual, one may not compare an int with a float32 and so on.</source>
          <target state="translated">比较函数只适用于基本类型(或命名的基本类型,如 &quot;type Celsius float32&quot;)。它们实现了围棋的数值比较规则,除了忽略大小和精确类型之外,所以任何整数值,不管是有符号还是无符号,都可以和任何其他整数值进行比较。(比较的是算术值,而不是位模式,所以所有负整数都小于所有无符号整数)。但一样平常不得将int与float32等进行比较。</target>
        </trans-unit>
        <trans-unit id="3947ad8b82d2733c9797fbc944569005335da23c" translate="yes" xml:space="preserve">
          <source>The compiler handles a Pointer converted to a uintptr in the argument list of a call to a function implemented in assembly by arranging that the referenced allocated object, if any, is retained and not moved until the call completes, even though from the types alone it would appear that the object is no longer needed during the call.</source>
          <target state="translated">编译器处理调用汇编实现的函数的参数列表中的Pointer转换为uintptr时,会安排保留被引用的分配对象(如果有的话),直到调用完成为止,即使单从类型上看,该对象在调用期间似乎不再需要。</target>
        </trans-unit>
        <trans-unit id="fbe6ac33b06dc273e75926ad2490d8b3832a0214" translate="yes" xml:space="preserve">
          <source>The complex built-in function constructs a complex value from two floating-point values. The real and imaginary parts must be of the same size, either float32 or float64 (or assignable to them), and the return value will be the corresponding complex type (complex64 for float32, complex128 for float64).</source>
          <target state="translated">复杂内置函数从两个浮点值中构造一个复杂值。实部和虚部的大小必须相同,要么是float32,要么是float64(或可分配给它们),返回值将是相应的复数类型(float32为complex64,float64为complex128)。</target>
        </trans-unit>
        <trans-unit id="ef38d7c2bab871a13bc3d0543cc12b1189486358" translate="yes" xml:space="preserve">
          <source>The compression level can be DefaultCompression, NoCompression, HuffmanOnly or any integer value between BestSpeed and BestCompression inclusive. The error returned will be nil if the level is valid.</source>
          <target state="translated">压缩级别可以是DefaultCompression、NoCompression、HuffmanOnly或BestSpeed和BestCompression之间的任何整数值。如果压缩级别有效,返回的错误将是nil。</target>
        </trans-unit>
        <trans-unit id="351f67248e4d8a5518193363a02cfe1c83014012" translate="yes" xml:space="preserve">
          <source>The constant UpperLower has an otherwise impossible delta value.</source>
          <target state="translated">常量UpperLower有一个原本不可能的delta值。</target>
        </trans-unit>
        <trans-unit id="8c8706295858fb442cc0b27075b7f68668230e3c" translate="yes" xml:space="preserve">
          <source>The content's Seek method must work: ServeContent uses a seek to the end of the content to determine its size.</source>
          <target state="translated">内容的Seek方法必须工作。ServeContent使用寻求方法来确定内容的大小。</target>
        </trans-unit>
        <trans-unit id="7a49805d773fd718112af263e9a481b6533ee15e" translate="yes" xml:space="preserve">
          <source>The context function will be called with a single argument, a pointer to a struct:</source>
          <target state="translated">调用上下文函数时,只需要一个参数,即指向一个结构的指针。</target>
        </trans-unit>
        <trans-unit id="d756f1871d5d4f318cef847f3f882a9119bd1f8d" translate="yes" xml:space="preserve">
          <source>The conversion rules are:</source>
          <target state="translated">换算规则是:</target>
        </trans-unit>
        <trans-unit id="8b9249f4b562855e188c8c6e04ee31f39d350295" translate="yes" xml:space="preserve">
          <source>The copy built-in function copies elements from a source slice into a destination slice. (As a special case, it also will copy bytes from a string to a slice of bytes.) The source and destination may overlap. Copy returns the number of elements copied, which will be the minimum of len(src) and len(dst).</source>
          <target state="translated">复制内置函数将一个源片断中的元素复制到一个目标片断中。(作为一种特殊情况,它也会将一个字符串中的字节复制到一个字节分片中。)源片和目的片可以重叠。Copy 返回被复制的元素数量,它将是 len(src)和 len(dst)的最小值。</target>
        </trans-unit>
        <trans-unit id="7003f654a24cc0fe7e8417bb3241f59de9fe836b" translate="yes" xml:space="preserve">
          <source>The count determines the number of substrings to return:</source>
          <target state="translated">计数决定了要返回的子串数量。</target>
        </trans-unit>
        <trans-unit id="5dbb8e654b6fb0895661f0c315a08864e55ec239" translate="yes" xml:space="preserve">
          <source>The crypto/tls package only implements some countermeasures against Lucky13 attacks on CBC-mode encryption, and only on SHA1 variants. See &lt;a href=&quot;http://www.isg.rhul.ac.uk/tls/TLStiming.pdf&quot;&gt;http://www.isg.rhul.ac.uk/tls/TLStiming.pdf&lt;/a&gt; and &lt;a href=&quot;https://www.imperialviolet.org/2013/02/04/luckythirteen.html&quot;&gt;https://www.imperialviolet.org/2013/02/04/luckythirteen.html&lt;/a&gt;.</source>
          <target state="translated">crypto / tls软件包仅对CBC模式加密且仅对SHA1变体实施针对Lucky13攻击的一些对策。参见&lt;a href=&quot;http://www.isg.rhul.ac.uk/tls/TLStiming.pdf&quot;&gt;http://www.isg.rhul.ac.uk/tls/TLStiming.pdf&lt;/a&gt;和&lt;a href=&quot;https://www.imperialviolet.org/2013/02/04/luckythirteen.html&quot;&gt;https://www.imperialviolet.org/2013/02/04/luckythirteen.html&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3df95d2be07bff158f354793704b39fa0b17441d" translate="yes" xml:space="preserve">
          <source>The cryptographic operations are implemented using constant-time algorithms.</source>
          <target state="translated">加密运算采用恒时算法实现。</target>
        </trans-unit>
        <trans-unit id="7eab6b01982b7d5d0967ad563265ae830b1ba245" translate="yes" xml:space="preserve">
          <source>The cryptographic operations do not use constant-time algorithms.</source>
          <target state="translated">加密运算不使用恒时算法。</target>
        </trans-unit>
        <trans-unit id="27e1f3bd597aed109fd98be320131ab37e282b69" translate="yes" xml:space="preserve">
          <source>The currently supported key types are *rsa.PublicKey, *ecdsa.PublicKey and ed25519.PublicKey. pub must be a supported key type, and priv must be a crypto.Signer with a supported public key.</source>
          <target state="translated">目前支持的密钥类型有*rsa.PublicKey、*ecdsa.PublicKey和ed25519.PublicKey。 pub必须是支持的密钥类型,priv必须是支持公钥的crypto.Signer。</target>
        </trans-unit>
        <trans-unit id="7a6143ad908fa5d13101f2932405343a9fc3dd21" translate="yes" xml:space="preserve">
          <source>The debug parameter enables additional output. Passing debug=0 prints only the hexadecimal addresses that pprof needs. Passing debug=1 adds comments translating addresses to function names and line numbers, so that a programmer can read the profile without tools.</source>
          <target state="translated">debug参数允许额外的输出。通过debug=0可以只打印pprof需要的十六进制地址。传递 debug=1 会添加注释,将地址翻译成函数名和行号,这样程序员就可以在没有工具的情况下阅读配置文件。</target>
        </trans-unit>
        <trans-unit id="bcfadeab38a63378303009891c62ea08d3a9f648" translate="yes" xml:space="preserve">
          <source>The decision can also be forced while building the Go source tree by setting the netgo or netcgo build tag.</source>
          <target state="translated">在构建Go源代码树时,也可以通过设置netgo或netcgo构建标签来强制决定。</target>
        </trans-unit>
        <trans-unit id="e55a5ed5aee48109c8f556983bc2b6ba47049c1e" translate="yes" xml:space="preserve">
          <source>The decoded form returned by the Reader's Read method rewrites the &quot;\r\n&quot; line endings into the simpler &quot;\n&quot;, removes leading dot escapes if present, and stops with error io.EOF after consuming (and discarding) the end-of-sequence line.</source>
          <target state="translated">由Reader's Read方法返回的解码形式将&quot;\r\n &quot;行结尾重写成更简单的&quot;\n&quot;,如果存在,则删除前导点转义,并在消耗(并丢弃)序列末行后以错误io.EOF停止。</target>
        </trans-unit>
        <trans-unit id="ade9eaf300f62ddbbf2f36e130c2f06e8467d26d" translate="yes" xml:space="preserve">
          <source>The decoder introduces its own buffering and may read data from r beyond the JSON values requested.</source>
          <target state="translated">解码器引入了自己的缓冲,可能会从r中读取超出请求的JSON值的数据。</target>
        </trans-unit>
        <trans-unit id="500a9025cc154f7f8f86d7b577b23c5a4330caf0" translate="yes" xml:space="preserve">
          <source>The default HTTP/1.x and HTTP/2 ResponseWriter implementations support Flusher, but ResponseWriter wrappers may not. Handlers should always test for this ability at runtime.</source>
          <target state="translated">默认的 HTTP/1.x 和 HTTP/2 ResponseWriter 实现支持 Flusher,但 ResponseWriter 包装器可能不支持。处理程序应该总是在运行时测试这个能力。</target>
        </trans-unit>
        <trans-unit id="dbfff1190b706ff9c82ad5d939db53ac5e19b8d5" translate="yes" xml:space="preserve">
          <source>The default ResponseWriter for HTTP/1.x connections supports Hijacker, but HTTP/2 connections intentionally do not. ResponseWriter wrappers may also not support Hijacker. Handlers should always test for this ability at runtime.</source>
          <target state="translated">HTTP/1.x连接的默认ResponseWriter支持Hijacker,但HTTP/2连接故意不支持。ResponseWriter 包装器也可能不支持 Hijacker。处理程序应该总是在运行时测试这种能力。</target>
        </trans-unit>
        <trans-unit id="29a4bf6e98ccc92440a0810fcad76a8019aec7ff" translate="yes" xml:space="preserve">
          <source>The default behavior is to unlink the socket file only when package net created it. That is, when the listener and the underlying socket file were created by a call to Listen or ListenUnix, then by default closing the listener will remove the socket file. but if the listener was created by a call to FileListener to use an already existing socket file, then by default closing the listener will not remove the socket file.</source>
          <target state="translated">默认的行为是只有在包net创建套接字文件时才会解除链接。也就是说,当监听器和底层的套接字文件是通过调用Listen或ListenUnix来创建的,那么默认情况下关闭监听器就会删除套接字文件,但是如果监听器是通过调用FileListener来使用已经存在的套接字文件,那么默认情况下关闭监听器就不会删除套接字文件。</target>
        </trans-unit>
        <trans-unit id="f3bd4ca778e016b570e20fa99bcd057793129198" translate="yes" xml:space="preserve">
          <source>The default format for %v is:</source>
          <target state="translated">%v的默认格式是:</target>
        </trans-unit>
        <trans-unit id="e5fbfa4bdd17cdbfb6f18b5cea533902d960ee26" translate="yes" xml:space="preserve">
          <source>The default max idle connections is currently 2. This may change in a future release.</source>
          <target state="translated">目前默认的最大空闲连接数为2,这可能会在未来的版本中改变。</target>
        </trans-unit>
        <trans-unit id="385f08ab994be40fdde70d56e38ccb63bb65d078" translate="yes" xml:space="preserve">
          <source>The default set of command-line flags is controlled by top-level functions. The FlagSet type allows one to define independent sets of flags, such as to implement subcommands in a command-line interface. The methods of FlagSet are analogous to the top-level functions for the command-line flag set.</source>
          <target state="translated">默认的命令行标志集由顶层函数控制。FlagSet类型允许人们定义独立的标志集,例如在命令行接口中实现子命令。FlagSet的方法类似于命令行标志集的顶层函数。</target>
        </trans-unit>
        <trans-unit id="a05d93e44d2bb1f3518c258e77ecac2e52df5b7c" translate="yes" xml:space="preserve">
          <source>The define action names the template being created by providing a string constant. Here is a simple example:</source>
          <target state="translated">define操作通过提供一个字符串常量来命名正在创建的模板。下面是一个简单的例子。</target>
        </trans-unit>
        <trans-unit id="1752a2a854e41ac9841751567fab2d2b00d5fd9e" translate="yes" xml:space="preserve">
          <source>The defined file mode bits are the most significant bits of the FileMode. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added.</source>
          <target state="translated">定义的文件模式位是FileMode中最重要的位。九个最不重要的位是标准的Unix rwxrwxrwx权限。这些位的值应该被认为是公共API的一部分,可以在线协议或磁盘表示中使用:虽然可能会添加新的位,但它们不能被改变。</target>
        </trans-unit>
        <trans-unit id="5cff7ee8fa31e3f6a6739a2dee232b717a523c6f" translate="yes" xml:space="preserve">
          <source>The delete built-in function deletes the element with the specified key (m[key]) from the map. If m is nil or there is no such element, delete is a no-op.</source>
          <target state="translated">delete 内建函数从地图中删除指定键 (m[key])的元素。如果 m 为 nil 或没有这样的元素,delete 是一个 no-op。</target>
        </trans-unit>
        <trans-unit id="7be6f8c0500d37b62c7237cb3172e8612a1be7ae" translate="yes" xml:space="preserve">
          <source>The dictionary may be nil. If not, its contents should not be modified until the Writer is closed.</source>
          <target state="translated">字典可以是nil。如果不是,在关闭Writer之前,它的内容不应该被修改。</target>
        </trans-unit>
        <trans-unit id="bc9a068b7cdbaff9efc9114bb2316dc6eaf9165d" translate="yes" xml:space="preserve">
          <source>The direction of a channel is indicated by one of these constants.</source>
          <target state="translated">通道的方向由这些常数之一表示。</target>
        </trans-unit>
        <trans-unit id="46b217ce09d8bd67e6158257fb40490e88a671dd" translate="yes" xml:space="preserve">
          <source>The direction of a channel type is indicated by a bit mask including one or both of the following constants.</source>
          <target state="translated">通道类型的方向由包括以下一个或两个常数的位掩码表示:</target>
        </trans-unit>
        <trans-unit id="7dfb11306d6f3241074422bcaa067904172344cc" translate="yes" xml:space="preserve">
          <source>The directory is neither guaranteed to exist nor have accessible permissions.</source>
          <target state="translated">该目录既不保证存在,也没有访问权限。</target>
        </trans-unit>
        <trans-unit id="565d684eeda7e9edb8f7bb0c103897df1854d973" translate="yes" xml:space="preserve">
          <source>The documentation for http.Request.Write details which fields of req are included in the dump.</source>
          <target state="translated">http.Request.Write的文档详细说明了转储中包含了req的哪些字段。</target>
        </trans-unit>
        <trans-unit id="07211f6185f4e6de4337f341c2cdb69d4cc499c7" translate="yes" xml:space="preserve">
          <source>The documentation here focuses on the security features of the package. For information about how to program the templates themselves, see the documentation for text/template.</source>
          <target state="translated">这里的文档主要是关于软件包的安全功能。关于如何对模板本身进行编程的信息,请参阅text/template的文档。</target>
        </trans-unit>
        <trans-unit id="d608ae58f506a273826ac24fbe8a6e832c7cfa18" translate="yes" xml:space="preserve">
          <source>The earlier index entries are the indices of the embedded fields implicitly traversed to get from (the type of) x to f, starting at embedding depth 0.</source>
          <target state="translated">前面的索引项是隐式遍历从(类型)x到f的嵌入字段的索引,从嵌入深度0开始。</target>
        </trans-unit>
        <trans-unit id="9969cd1fd12276c81b2d25b52e841cee1f38a6af" translate="yes" xml:space="preserve">
          <source>The earlier index entries are the indices of the embedded struct fields traversed to get to the found entry, starting at depth 0.</source>
          <target state="translated">前面的索引条目是为了得到找到的条目而遍历的嵌入结构域的索引,从深度0开始。</target>
        </trans-unit>
        <trans-unit id="55f7215f8e7a1256ecd44a2e72424fdc36866f77" translate="yes" xml:space="preserve">
          <source>The encoded form is:</source>
          <target state="translated">编码形式为:</target>
        </trans-unit>
        <trans-unit id="58738aa6dbb46f39a2d83f07741091a7022a1024" translate="yes" xml:space="preserve">
          <source>The encoding handles 4-byte chunks, using a special encoding for the last fragment, so Encode is not appropriate for use on individual blocks of a large data stream. Use NewEncoder() instead.</source>
          <target state="translated">编码处理4字节的块,对最后一个片段使用特殊的编码,所以Encode不适合用于大型数据流的单个块。使用NewEncoder()代替。</target>
        </trans-unit>
        <trans-unit id="352cf3ce7f63c6b9e4ef698575b243f2f7eab5f4" translate="yes" xml:space="preserve">
          <source>The encoding of each struct field can be customized by the format string stored under the &quot;json&quot; key in the struct field's tag. The format string gives the name of the field, possibly followed by a comma-separated list of options. The name may be empty in order to specify options without overriding the default field name.</source>
          <target state="translated">每个结构体字段的编码可以通过存储在结构体字段标签中 &quot;json &quot;键下的格式字符串来定制。格式字符串给出了字段的名称,后面可能是一个以逗号分隔的选项列表。为了在不覆盖默认字段名的情况下指定选项,名称可以为空。</target>
        </trans-unit>
        <trans-unit id="17b6791f4c87db95fbf5fcc1580f710e0b98bcc7" translate="yes" xml:space="preserve">
          <source>The encoding pads the output to a multiple of 4 bytes, so Encode is not appropriate for use on individual blocks of a large data stream. Use NewEncoder() instead.</source>
          <target state="translated">编码将输出填充到4字节的倍数,因此Encode不适合用于大型数据流的单个块。使用NewEncoder()代替。</target>
        </trans-unit>
        <trans-unit id="f9b92d6b313993a8570c418851ae0a82ee1d08b2" translate="yes" xml:space="preserve">
          <source>The encoding pads the output to a multiple of 8 bytes, so Encode is not appropriate for use on individual blocks of a large data stream. Use NewEncoder() instead.</source>
          <target state="translated">编码将输出填充到8字节的倍数,因此Encode不适合用于大型数据流的单个块。使用NewEncoder()代替。</target>
        </trans-unit>
        <trans-unit id="f21e6b7ab20b84c2608ae859489552989b9c9ded" translate="yes" xml:space="preserve">
          <source>The entire test file is presented as the example when it contains a single example function, at least one other function, type, variable, or constant declaration, and no test or benchmark functions.</source>
          <target state="translated">当整个测试文件包含一个示例函数、至少一个其他函数、类型、变量或常量声明,并且没有测试或基准函数时,整个测试文件将作为示例呈现。</target>
        </trans-unit>
        <trans-unit id="8a5b41cf040dd894c5f5818385e864bb8f5f4256" translate="yes" xml:space="preserve">
          <source>The environment values may be either a complete URL or a &quot;host[:port]&quot;, in which case the &quot;http&quot; scheme is assumed. An error is returned if the value is a different form.</source>
          <target state="translated">环境值可以是一个完整的URL,也可以是 &quot;host[:port]&quot;,在这种情况下,假定使用 &quot;http &quot;方案。如果值是不同的形式,将返回一个错误。</target>
        </trans-unit>
        <trans-unit id="63d88a909a5214b04c717d2600360e2bf8c34633" translate="yes" xml:space="preserve">
          <source>The error built-in interface type is the conventional interface for representing an error condition, with the nil value representing no error.</source>
          <target state="translated">错误内置接口类型是表示错误条件的常规接口,nil值代表没有错误。</target>
        </trans-unit>
        <trans-unit id="057113f0f11fb7ab423f9c5529d153f0951fafc6" translate="yes" xml:space="preserve">
          <source>The error is EOF only if no bytes were read. If an EOF happens after reading some but not all the bytes, Read returns ErrUnexpectedEOF.</source>
          <target state="translated">只有在没有读到字节的情况下,才会发生EOF错误。如果在读取部分但不是全部字节后发生EOF,Read返回ErrUnexpectedEOF。</target>
        </trans-unit>
        <trans-unit id="e19a9195a1344f79f24fd7f396a97d73332aa946" translate="yes" xml:space="preserve">
          <source>The errors that ParseFloat returns have concrete type *NumError and include err.Num = s.</source>
          <target state="translated">ParseFloat返回的错误有具体的类型*NumError,包括err.Num=s。</target>
        </trans-unit>
        <trans-unit id="235cee0ee469905c73061c3ebbf12b0afd87e749" translate="yes" xml:space="preserve">
          <source>The errors that ParseInt returns have concrete type *NumError and include err.Num = s. If s is empty or contains invalid digits, err.Err = ErrSyntax and the returned value is 0; if the value corresponding to s cannot be represented by a signed integer of the given size, err.Err = ErrRange and the returned value is the maximum magnitude integer of the appropriate bitSize and sign.</source>
          <target state="translated">ParseInt返回的错误有具体的类型*NumError,包括err.Num=s,如果s为空或包含无效数字,err.Err=ErrSyntax,返回值为0;如果s对应的值不能用给定大小的有符号整数表示,err.Err=ErrRange,返回值为相应位数大小和符号的最大幅度整数。</target>
        </trans-unit>
        <trans-unit id="1079b4c215daaeaddfd42a5c24ae40421a24ca31" translate="yes" xml:space="preserve">
          <source>The exact method of division of a binary into separate Objs is an internal detail of the symbol table format.</source>
          <target state="translated">将二进制划分为独立的Objs的具体方法是符号表格式的内部细节。</target>
        </trans-unit>
        <trans-unit id="704442846624164254cefb0621f909b9f8e7b255" translate="yes" xml:space="preserve">
          <source>The executable example for Time.Format demonstrates the working of the layout string in detail and is a good reference.</source>
          <target state="translated">Time.Format的可执行示例详细演示了布局字符串的工作原理,是一个很好的参考。</target>
        </trans-unit>
        <trans-unit id="d1e6774ae13e892b5b495469c8177e657ea29b91" translate="yes" xml:space="preserve">
          <source>The execution trace captures a wide range of execution events such as goroutine creation/blocking/unblocking, syscall enter/exit/block, GC-related events, changes of heap size, processor start/stop, etc. A precise nanosecond-precision timestamp and a stack trace is captured for most events. The generated trace can be interpreted using `go tool trace`.</source>
          <target state="translated">执行跟踪可以捕获广泛的执行事件,如goroutine的创建/阻塞/取消阻塞,系统调用进入/退出/阻塞,GC相关事件,堆大小的变化,处理器的启动/停止等。大多数事件都会被捕获一个精确的纳秒级时间戳和一个堆栈跟踪。生成的跟踪可以用 &quot;go tool trace &quot;来解释。</target>
        </trans-unit>
        <trans-unit id="0bb8da556b82de3d2273cd84d139d0610336a88a" translate="yes" xml:space="preserve">
          <source>The familiar base-setting prefixes 0b (binary), 0o and 0 (octal), and 0x (hexadecimal) are accepted when scanning integers without a format or with the %v verb, as are digit-separating underscores.</source>
          <target state="translated">当扫描没有格式的整数或使用%v动词时,可以接受熟悉的定基前缀0b(二进制)、0o和0(八进制)以及0x(十六进制),也可以接受以数字分隔的下划线。</target>
        </trans-unit>
        <trans-unit id="f9ffee1670410a5e7cd11d5f1bee248ae5a136bc" translate="yes" xml:space="preserve">
          <source>The field semantics differ slightly between client and server usage. In addition to the notes on the fields below, see the documentation for Request.Write and RoundTripper.</source>
          <target state="translated">字段的语义在客户端和服务器的用法上略有不同。除了下面关于字段的说明外,请看Request.Write和RoundTripper的文档。</target>
        </trans-unit>
        <trans-unit id="bc18f2dd0c8c98e57212ed20f1a2ef2dc2747c6d" translate="yes" xml:space="preserve">
          <source>The file's data can then be read into a slice of bytes. Read and Write take their byte counts from the length of the argument slice.</source>
          <target state="translated">然后文件的数据可以被读入一个字节片。读和写从参数片的长度中提取字节数。</target>
        </trans-unit>
        <trans-unit id="bf3df07f08dd9391973ec022887d04b86f02f1b9" translate="yes" xml:space="preserve">
          <source>The filepath package uses either forward slashes or backslashes, depending on the operating system. To process paths such as URLs that always use forward slashes regardless of the operating system, see the path package.</source>
          <target state="translated">文件路径包根据操作系统的不同,使用正斜线或反斜线。要处理诸如URL等无论操作系统如何都使用正斜线的路径,请参阅路径包。</target>
        </trans-unit>
        <trans-unit id="e2a5de21556a23ce2ab6268f51afe1d5e198e5ff" translate="yes" xml:space="preserve">
          <source>The finalizer is scheduled to run at some arbitrary time after the program can no longer reach the object to which obj points. There is no guarantee that finalizers will run before a program exits, so typically they are useful only for releasing non-memory resources associated with an object during a long-running program. For example, an os.File object could use a finalizer to close the associated operating system file descriptor when a program discards an os.File without calling Close, but it would be a mistake to depend on a finalizer to flush an in-memory I/O buffer such as a bufio.Writer, because the buffer would not be flushed at program exit.</source>
          <target state="translated">定盘器被安排在程序无法再到达obj指向的对象后的某个任意时间运行。不能保证最终确定器会在程序退出之前运行,所以通常它们只在长期运行的程序中释放与对象相关的非内存资源时有用。例如,一个 os.File 对象可以在程序丢弃 os.File 而不调用 Close 时,使用定标器来关闭相关的操作系统文件描述符,但是依靠定标器来刷新内存中的 I/O 缓冲区(如 bufio.Writer)是错误的,因为缓冲区不会在程序退出时被刷新。</target>
        </trans-unit>
        <trans-unit id="b1e301ef4e8e6bbc26fb8b640366f5d912e010bd" translate="yes" xml:space="preserve">
          <source>The first call to ReadContinuedLine will return &quot;Line 1 continued...&quot; and the second will return &quot;Line 2&quot;.</source>
          <target state="translated">第一次调用ReadContinuedLine将返回 &quot;Line 1 continued...&quot;,第二次将返回 &quot;Line 2&quot;。</target>
        </trans-unit>
        <trans-unit id="aa248e4cf567dddf42fcb3d7320a5fbdd025b032" translate="yes" xml:space="preserve">
          <source>The first call will cache the current user information. Subsequent calls will return the cached value and will not reflect changes to the current user.</source>
          <target state="translated">第一次调用将缓存当前用户信息。随后的调用将返回缓存的值,不会反映当前用户的变化。</target>
        </trans-unit>
        <trans-unit id="f9bea105d5515e425130c674b9a6d60024d04428" translate="yes" xml:space="preserve">
          <source>The first step to profiling a Go program is to enable profiling. Support for profiling benchmarks built with the standard testing package is built into go test. For example, the following command runs benchmarks in the current directory and writes the CPU and memory profiles to cpu.prof and mem.prof:</source>
          <target state="translated">对Go程序进行剖析的第一步是启用剖析。go test中内置了对标准测试包所构建的基准的剖析支持。例如,以下命令在当前目录下运行基准,并将CPU和内存配置文件写入cpu.prof和mem.prof中。</target>
        </trans-unit>
        <trans-unit id="436dd80ca68673a729fce026c246571c6f61d421" translate="yes" xml:space="preserve">
          <source>The first time the function is called for a particular traceback, all the fields except PC will be 0. The function should fill in the other fields if possible, setting them to 0/nil if the information is not available. The Data field may be used to store any useful information across calls. The More field should be set to non-zero if there is more information for this PC, zero otherwise. If More is set non-zero, the function will be called again with the same PC, and may return different information (this is intended for use with inlined functions). If More is zero, the function will be called with the next PC value in the traceback. When the traceback is complete, the function will be called once more with PC set to zero; this may be used to free any information. Each call will leave the fields of the struct set to the same values they had upon return, except for the PC field when the More field is zero. The function must not keep a copy of the struct pointer between calls.</source>
          <target state="translated">第一次调用该函数时,除了PC外,所有字段都为0,如果可能的话,该函数应该填写其他字段,如果信息不可用,则将其设置为0/nil。数据字段可用于存储跨调用的任何有用信息。如果该PC有更多信息,则More字段应设置为非零,否则为零。如果More字段被设置为非零,函数将对同一台PC再次调用,并可能返回不同的信息(这是为了与内联函数一起使用)。如果More为零,函数将用回溯中的下一个PC值进行调用。当回溯完成后,函数将被再次调用,PC设置为0;这可以用来释放任何信息。每次调用都会使结构体的字段设置为返回时的相同值,但当More字段为零时,PC字段除外。该函数在两次调用之间不得保留结构体指针的副本。</target>
        </trans-unit>
        <trans-unit id="1c12332b1a7f816e653faac5972323a1a86f4075" translate="yes" xml:space="preserve">
          <source>The fmt package's Errorf function lets us use the package's formatting features to create descriptive error messages.</source>
          <target state="translated">fmt软件包的Errorf功能让我们可以使用软件包的格式化功能来创建描述性的错误信息。</target>
        </trans-unit>
        <trans-unit id="daed29ba07a438b86a35f4ffceadf0ee0b2962c4" translate="yes" xml:space="preserve">
          <source>The following environment variables ($name or %name%, depending on the host operating system) control the run-time behavior of Go programs. The meanings and use may change from release to release.</source>
          <target state="translated">以下环境变量($name 或 %name%,取决于主机操作系统)控制围棋程序的运行时行为。这些变量的含义和用途可能会随着版本的不同而改变。</target>
        </trans-unit>
        <trans-unit id="d76a76a5baf9188ebac1a65a2793d054e97d3403" translate="yes" xml:space="preserve">
          <source>The following example shows how to maintain a scalable frequently read, but infrequently updated data structure using copy-on-write idiom.</source>
          <target state="translated">下面的例子展示了如何使用copy-on-write成语来维护一个可扩展的经常读取,但不经常更新的数据结构。</target>
        </trans-unit>
        <trans-unit id="3f0a6fe70878d3ed973c5f4c4f9e11a4b37e3d2a" translate="yes" xml:space="preserve">
          <source>The following example shows how to use Value for periodic program config updates and propagation of the changes to worker goroutines.</source>
          <target state="translated">下面的例子显示了如何使用Value进行周期性的程序配置更新,并将变化传播给worker goroutine。</target>
        </trans-unit>
        <trans-unit id="2cccb14470014df050daea92c16a16fd189e8367" translate="yes" xml:space="preserve">
          <source>The following forms are permitted:</source>
          <target state="translated">允许采用以下形式:</target>
        </trans-unit>
        <trans-unit id="f535af253987553534ec7b604b13bea0bafaf89a" translate="yes" xml:space="preserve">
          <source>The following key types are currently supported: *rsa.PrivateKey, *ecdsa.PrivateKey and ed25519.PrivateKey. Unsupported key types result in an error.</source>
          <target state="translated">目前支持以下密钥类型。*rsa.PrivateKey、*ecdsa.PrivateKey和ed25519.PrivateKey。不支持的密钥类型会导致错误。</target>
        </trans-unit>
        <trans-unit id="db7a430d5590cf9adf90b727249460131ab84e28" translate="yes" xml:space="preserve">
          <source>The following key types are currently supported: *rsa.PublicKey, *ecdsa.PublicKey and ed25519.PublicKey. Unsupported key types result in an error.</source>
          <target state="translated">目前支持以下密钥类型。*rsa.PublicKey、*ecdsa.PublicKey和ed25519.PublicKey。不支持的密钥类型会导致一个错误。</target>
        </trans-unit>
        <trans-unit id="575dc13df3822635a20233f0d934b2828c4cbcc1" translate="yes" xml:space="preserve">
          <source>The following patterns involving Pointer are valid. Code not using these patterns is likely to be invalid today or to become invalid in the future. Even the valid patterns below come with important caveats.</source>
          <target state="translated">以下涉及Pointer的模式是有效的。没有使用这些模式的代码很可能在今天是无效的,或者在将来也是无效的。即使是下面的有效模式也有重要的注意事项。</target>
        </trans-unit>
        <trans-unit id="ea1b5d42ec809a44272262968add764fd0382aa5" translate="yes" xml:space="preserve">
          <source>The following table captures the capabilities of each format:</source>
          <target state="translated">下表列出了每种格式的能力。</target>
        </trans-unit>
        <trans-unit id="00ec28c9d7b575a36a11e5441e71a7350e3c8790" translate="yes" xml:space="preserve">
          <source>The following tags on struct fields have special meaning to Unmarshal:</source>
          <target state="translated">以下结构字段的标签对Unmarshal有特殊意义。</target>
        </trans-unit>
        <trans-unit id="89924ba6250a79536c8a80bb6ca7f28f4193a60a" translate="yes" xml:space="preserve">
          <source>The format fmt is one of 'b' (-ddddp&amp;plusmn;ddd, a binary exponent), 'e' (-d.dddde&amp;plusmn;dd, a decimal exponent), 'E' (-d.ddddE&amp;plusmn;dd, a decimal exponent), 'f' (-ddd.dddd, no exponent), 'g' ('e' for large exponents, 'f' otherwise), 'G' ('E' for large exponents, 'f' otherwise), 'x' (-0xd.ddddp&amp;plusmn;ddd, a hexadecimal fraction and binary exponent), or 'X' (-0Xd.ddddP&amp;plusmn;ddd, a hexadecimal fraction and binary exponent).</source>
          <target state="translated">格式fmt是'b'（-ddddp&amp;plusmn;ddd，二进制指数），'e'（-d.dddde&amp;plusmn;dd，十进制指数），'E'（-d.ddddE&amp;plusmn;dd，十进制指数）之一），&amp;ldquo; f&amp;rdquo;（-ddd.dddd，无指数），&amp;ldquo; g&amp;rdquo;（&amp;ldquo; e&amp;rdquo;代表大指数，否则为&amp;ldquo; f&amp;rdquo;），&amp;ldquo; G&amp;rdquo;（&amp;ldquo; E&amp;rdquo;代表大指数，否则为&amp;ldquo; f&amp;rdquo;），&amp;ldquo; x'（-0xd.ddddp&amp;plusmn;ddd，十六进制分数和二进制指数）或'X'（-0Xd.ddddP&amp;plusmn;ddd，十六进制分数和二进制指数）。</target>
        </trans-unit>
        <trans-unit id="f76288ef40c91d2e63963863e41869428543cdec" translate="yes" xml:space="preserve">
          <source>The formats 2, _2, and 02 are unpadded, space-padded, and zero-padded day of month. The formats __2 and 002 are space-padded and zero-padded three-character day of year; there is no unpadded day of year format.</source>
          <target state="translated">格式2、_2、02为无垫、有空格、零垫的月日。格式 __2 和 002 是空格填充和零填充的三字符年月日,没有无填充的年月日格式。</target>
        </trans-unit>
        <trans-unit id="1f639fab95b9f7e1b599aa2a265c8aee60d79d31" translate="yes" xml:space="preserve">
          <source>The formfeed character acts like a newline but it also terminates all columns in the current line (effectively calling Flush). Tab- terminated cells in the next line start new columns. Unless found inside an HTML tag or inside an escaped text segment, formfeed characters appear as newlines in the output.</source>
          <target state="translated">formfeed字符的作用类似于换行,但它也终止了当前行中的所有列(有效地调用Flush)。下一行中Tab终止的单元格开始新的列。除非在HTML标签内或转义文本段内发现,否则formfeed字符在输出中会作为换行符出现。</target>
        </trans-unit>
        <trans-unit id="6c966e528430f5e8f847d49a893afb0bf98faff4" translate="yes" xml:space="preserve">
          <source>The function is never called with an empty data slice unless atEOF is true. If atEOF is true, however, data may be non-empty and, as always, holds unprocessed text.</source>
          <target state="translated">除非 atEOF 为真,否则该函数不会在数据片为空的情况下被调用。但是,如果atEOF为真,数据可能是非空的,并且一如既往地保存未处理的文本。</target>
        </trans-unit>
        <trans-unit id="bb0e0b68d3018d9e09f97b972052414d315bce69" translate="yes" xml:space="preserve">
          <source>The function may return early (before the entire result is written) and return a formatting error, for instance due to an incorrect AST.</source>
          <target state="translated">该函数可能会提前返回(在整个结果写入之前),并返回一个格式化错误,例如由于一个错误的AST。</target>
        </trans-unit>
        <trans-unit id="f82da77fd5615642bd9b732fd9350b4315a5dea8" translate="yes" xml:space="preserve">
          <source>The function panics if the provided interface is not a slice.</source>
          <target state="translated">如果所提供的接口不是分片,该函数就会恐慌。</target>
        </trans-unit>
        <trans-unit id="4a5f1ee976b1b1f94f517d27ee9603ea7e455c85" translate="yes" xml:space="preserve">
          <source>The function panics if z &amp;lt; 0. The value of z is undefined in that case.</source>
          <target state="translated">如果z &amp;lt;0，函数将出现紧急情况。在这种情况下，z的值不确定。</target>
        </trans-unit>
        <trans-unit id="d83c73a08df2f74bc57a61017e163cb8c0547bd2" translate="yes" xml:space="preserve">
          <source>The functions in this package allow a program to change the way Go programs handle signals.</source>
          <target state="translated">本包中的函数允许程序改变围棋程序处理信号的方式。</target>
        </trans-unit>
        <trans-unit id="c621ec21270aea7b19125c0f31ddb234d896d492" translate="yes" xml:space="preserve">
          <source>The fundamental interface is called Image. An Image contains colors, which are described in the image/color package.</source>
          <target state="translated">基本的接口叫做Image。一个Image包含颜色,这些颜色在image/color包中有描述。</target>
        </trans-unit>
        <trans-unit id="3e95d4d070ede79d500e36cf5c238c24c3001c9d" translate="yes" xml:space="preserve">
          <source>The gc runtime imposes a limit of 64 kB on channel element types. If t's size is equal to or exceeds this limit, ChanOf panics.</source>
          <target state="translated">gc运行时对通道元素类型施加了64 kB的限制,如果t的大小等于或超过这个限制,ChanOf就会惊慌失措。如果t的大小等于或超过这个限制,ChanOf就会崩溃。</target>
        </trans-unit>
        <trans-unit id="0b2d97be3dbe373d310641088f98b283534b1dcf" translate="yes" xml:space="preserve">
          <source>The general form represented is:</source>
          <target state="translated">代表的一般形式是:</target>
        </trans-unit>
        <trans-unit id="e818a1eefc582415dc190e3c644893b44536faa0" translate="yes" xml:space="preserve">
          <source>The gzip file stores a header giving metadata about the compressed file. That header is exposed as the fields of the Writer and Reader structs.</source>
          <target state="translated">gzip文件存储了一个头,给出了压缩文件的元数据。这个头以Writer和Reader结构的字段形式出现。</target>
        </trans-unit>
        <trans-unit id="d55115d1e7ac93246c076c18ab9827900516047e" translate="yes" xml:space="preserve">
          <source>The handler is typically nil, in which case the DefaultServeMux is used.</source>
          <target state="translated">该处理程序通常为nil,在这种情况下,使用DefaultServeMux。</target>
        </trans-unit>
        <trans-unit id="19708f111db26407005495f3eafb1c4b25430791" translate="yes" xml:space="preserve">
          <source>The handling of spaces and newlines differs from that of C's scanf family: in C, newlines are treated as any other space, and it is never an error when a run of spaces in the format string finds no spaces to consume in the input.</source>
          <target state="translated">对空格和换行的处理与C语言的scanf系列不同:在C语言中,换行与其他空格一样,当格式字符串中的空格运行时,发现输入中没有空格消耗时,绝不会出错。</target>
        </trans-unit>
        <trans-unit id="e507edab6e88a1637c49a21b0db27e0ccae398e0" translate="yes" xml:space="preserve">
          <source>The heap dump format is defined at &lt;a href=&quot;https://golang.org/s/go15heapdump&quot;&gt;https://golang.org/s/go15heapdump&lt;/a&gt;.</source>
          <target state="translated">堆转储格式在&lt;a href=&quot;https://golang.org/s/go15heapdump&quot;&gt;https://golang.org/s/go15heapdump&lt;/a&gt;上定义。</target>
        </trans-unit>
        <trans-unit id="8b009325b4464d415a87b0e6547346de038d0c47" translate="yes" xml:space="preserve">
          <source>The heap profile reports statistics as of the most recently completed garbage collection; it elides more recent allocation to avoid skewing the profile away from live data and toward garbage. If there has been no garbage collection at all, the heap profile reports all known allocations. This exception helps mainly in programs running without garbage collection enabled, usually for debugging purposes.</source>
          <target state="translated">堆配置文件报告了最近完成的垃圾收集的统计数据;它省略了最近的分配,以避免使配置文件偏离实时数据而偏向垃圾。如果根本没有进行过垃圾收集,堆配置文件会报告所有已知的分配情况。这种例外情况主要是在没有启用垃圾收集的情况下运行的程序中起帮助作用,通常是为了调试的目的。</target>
        </trans-unit>
        <trans-unit id="421272feeab82226233835220df71bd5575dfeaf" translate="yes" xml:space="preserve">
          <source>The heap profile tracks both the allocation sites for all live objects in the application memory and for all objects allocated since the program start. Pprof's -inuse_space, -inuse_objects, -alloc_space, and -alloc_objects flags select which to display, defaulting to -inuse_space (live objects, scaled by size).</source>
          <target state="translated">Pprof的-inuse_space,-inuse_objects,-alloc_space,和 -alloc_objects标志可以选择显示哪个标志,默认为-inuse_space(实时对象)和-alloc_objects。Pprof的-inuse_space、-inuse_objects、-alloc_space和-alloc_objects标志选择显示哪一个,默认为-inuse_space(实时对象,按大小缩放)。</target>
        </trans-unit>
        <trans-unit id="9054b52054ed118bba62807238e18c27e8900f1e" translate="yes" xml:space="preserve">
          <source>The http package's Transport and Server both automatically enable HTTP/2 support for simple configurations. To enable HTTP/2 for more complex configurations, to use lower-level HTTP/2 features, or to use a newer version of Go's http2 package, import &quot;golang.org/x/net/http2&quot; directly and use its ConfigureTransport and/or ConfigureServer functions. Manually configuring HTTP/2 via the golang.org/x/net/http2 package takes precedence over the net/http package's built-in HTTP/2 support.</source>
          <target state="translated">http包的Transport和Server都会自动为简单配置启用HTTP/2支持。如果要为更复杂的配置启用 HTTP/2,使用较低级别的 HTTP/2 功能,或者使用较新版本的 Go 的 http2 包,可以直接导入 &quot;golang.org/x/net/http2&quot; 并使用它的 ConfigureTransport 和/或 ConfigureServer 函数。通过 golang.org/x/net/http2 软件包手动配置 HTTP/2,优先于 net/http 软件包内置的 HTTP/2 支持。</target>
        </trans-unit>
        <trans-unit id="7901eb39a7a77a33e17eff2e48d2aac1d7c0d97c" translate="yes" xml:space="preserve">
          <source>The identification of global unicast addresses uses address type identification as defined in RFC 1122, RFC 4632 and RFC 4291 with the exception of IPv4 directed broadcast addresses. It returns true even if ip is in IPv4 private address space or local IPv6 unicast address space.</source>
          <target state="translated">全局单播地址的识别使用RFC 1122、RFC 4632和RFC 4291中定义的地址类型识别,IPv4定向广播地址除外。即使ip处于IPv4私有地址空间或本地IPv6单播地址空间,它也会返回true。</target>
        </trans-unit>
        <trans-unit id="b257c667cd0c9ffb7ee1c476e193cf63abc04956" translate="yes" xml:space="preserve">
          <source>The imag built-in function returns the imaginary part of the complex number c. The return value will be floating point type corresponding to the type of c.</source>
          <target state="translated">imag内置函数返回复数c的虚部,返回值将是c类型对应的浮点类型。</target>
        </trans-unit>
        <trans-unit id="bba6c5ec151d11520ba69091805c64672051a283" translate="yes" xml:space="preserve">
          <source>The implementation compiles a custom codec for each data type in the stream and is most efficient when a single Encoder is used to transmit a stream of values, amortizing the cost of compilation.</source>
          <target state="translated">该实现为流中的每一种数据类型编译一个自定义的编解码器,当使用一个Encoder来传输值流时,效率最高,可以摊销编译的成本。</target>
        </trans-unit>
        <trans-unit id="cc59eb7da6cf17b91e5a422524763e1124d23ad5" translate="yes" xml:space="preserve">
          <source>The implementation fn can assume that the argument Value slice has the number and type of arguments given by typ. If typ describes a variadic function, the final Value is itself a slice representing the variadic arguments, as in the body of a variadic function. The result Value slice returned by fn must have the number and type of results given by typ.</source>
          <target state="translated">实现 fn 可以假设参数 Value 分片具有 typ 给出的参数数量和类型。如果ty描述的是一个变量函数,那么最后的Value本身就是一个代表变量参数的分片,就像变量函数的主体一样。fn 返回的结果 Value 分片必须具有 typ 给出的结果数量和类型。</target>
        </trans-unit>
        <trans-unit id="a41481e84f45a7e3719a2630303073b44edd9b5b" translate="yes" xml:space="preserve">
          <source>The implementation is sufficient for HTTP (RFC 2388) and the multipart bodies generated by popular browsers.</source>
          <target state="translated">该实现足以满足HTTP(RFC 2388)和流行的浏览器生成的多部分体。</target>
        </trans-unit>
        <trans-unit id="bd36b82add2ec8e45a6f77ef7cf720308cbe3f24" translate="yes" xml:space="preserve">
          <source>The implementation provides filters that uncompress during reading and compress during writing. For example, to write compressed data to a buffer:</source>
          <target state="translated">该实现提供了在读取时解压和在写入时压缩的过滤器。例如,将压缩数据写入缓冲区。</target>
        </trans-unit>
        <trans-unit id="4c05b349b9c7f15622f23c1c3f50e289a6f9207b" translate="yes" xml:space="preserve">
          <source>The input stream consists of basic JSON values&amp;mdash;bool, string, number, and null&amp;mdash;along with delimiters [ ] { } of type Delim to mark the start and end of arrays and objects. Commas and colons are elided.</source>
          <target state="translated">输入流由基本JSON值（布尔，字符串，数字和null）以及Delim类型的定界符[] {}组成，以标记数组和对象的开始和结束。逗号和冒号被删除。</target>
        </trans-unit>
        <trans-unit id="12da2b29ce7b4618ed043885dc9bb14fc4b7647d" translate="yes" xml:space="preserve">
          <source>The input text for a template is UTF-8-encoded text in any format. &quot;Actions&quot;--data evaluations or control structures--are delimited by &quot;{{&quot; and &quot;}}&quot;; all text outside actions is copied to the output unchanged. Except for raw strings, actions may not span newlines, although comments can.</source>
          <target state="translated">模板的输入文本是任何格式的UTF-8编码文本。&quot;动作&quot;--数据评估或控制结构--以&quot;{{&quot;和&quot;}}&quot;为界;动作之外的所有文本都会被复制到输出中,不会有任何变化。除了原始字符串外,动作不能跨行,但注释可以。</target>
        </trans-unit>
        <trans-unit id="0fe0f673e6c94e25d76ca7000237cacb398b340e" translate="yes" xml:space="preserve">
          <source>The key name will be used if it's a non-empty string consisting of only Unicode letters, digits, and ASCII punctuation except quotation marks, backslash, and comma.</source>
          <target state="translated">如果键名是一个非空字符串,除了引号、反斜杠和逗号之外,只包含Unicode字母、数字和ASCII标点符号,那么就会被使用。</target>
        </trans-unit>
        <trans-unit id="56c8d36b799fc9e0b2026b0edca00b49c8b68568" translate="yes" xml:space="preserve">
          <source>The keys should be in canonical form, as returned by CanonicalHeaderKey.</source>
          <target state="translated">键值应该是规范的形式,由CanonicalHeaderKey返回。</target>
        </trans-unit>
        <trans-unit id="aafd41e452c62afe966c7e13f3df11b54dbc58d9" translate="yes" xml:space="preserve">
          <source>The label parameter may contain arbitrary data that will not be encrypted, but which gives important context to the message. For example, if a given public key is used to decrypt two types of messages then distinct label values could be used to ensure that a ciphertext for one purpose cannot be used for another by an attacker. If not required it can be empty.</source>
          <target state="translated">标签参数可以包含任意的数据,这些数据不会被加密,但可以为消息提供重要的背景。例如,如果一个给定的公钥被用来解密两种类型的消息,那么不同的标签值可以用来确保一个用于一个目的的密文不能被攻击者用于另一个目的。如果不需要,它可以是空的。</target>
        </trans-unit>
        <trans-unit id="8cac55c132cd1a101696d231efd1dd2e57c66e06" translate="yes" xml:space="preserve">
          <source>The label parameter must match the value given when encrypting. See EncryptOAEP for details.</source>
          <target state="translated">标签参数必须与加密时给出的值相匹配。详情请参见EncryptOAEP。</target>
        </trans-unit>
        <trans-unit id="1f23b14d8824650d5d93ee806d28aa66402f402a" translate="yes" xml:space="preserve">
          <source>The last index entry is the field or method index in the (possibly embedded) type where the entry was found, either:</source>
          <target state="translated">最后一个索引条目是找到该条目的(可能是嵌入的)类型中的字段或方法索引,要么。</target>
        </trans-unit>
        <trans-unit id="feec6e46b5f96d5f768a208b14b5f1c441e6736a" translate="yes" xml:space="preserve">
          <source>The len built-in function returns the length of v, according to its type:</source>
          <target state="translated">len内置函数根据v的类型,返回v的长度。</target>
        </trans-unit>
        <trans-unit id="67e3ff53cc19034aa94ce5014984a3863b3ceaa2" translate="yes" xml:space="preserve">
          <source>The limit controls the number of operating system threads, not the number of goroutines. A Go program creates a new thread only when a goroutine is ready to run but all the existing threads are blocked in system calls, cgo calls, or are locked to other goroutines due to use of runtime.LockOSThread.</source>
          <target state="translated">该限制控制的是操作系统线程的数量,而不是goroutine的数量。一个围棋程序只有在一个goroutine准备运行时才会创建一个新的线程,但所有现有的线程都在系统调用、cgo调用中被阻塞,或者由于使用runtime.LockOSThread而被锁定在其他goroutine上。</target>
        </trans-unit>
        <trans-unit id="61b31a135931a0a96f45c468dd4c1356b142f056" translate="yes" xml:space="preserve">
          <source>The list of possible Object kinds.</source>
          <target state="translated">可能的对象种类列表。</target>
        </trans-unit>
        <trans-unit id="f82cdeb26140d2ac8d4f27048ef361e35bc34e51" translate="yes" xml:space="preserve">
          <source>The list of tokens.</source>
          <target state="translated">代币清单。</target>
        </trans-unit>
        <trans-unit id="744b107073d50b7c5d979152623baf7c98836ce1" translate="yes" xml:space="preserve">
          <source>The load and store operations, implemented by the LoadT and StoreT functions, are the atomic equivalents of &quot;return *addr&quot; and &quot;*addr = val&quot;.</source>
          <target state="translated">LoadT和StoreT函数实现的加载和存储操作,是 &quot;返回*addr &quot;和 &quot;*addr=val &quot;的原子等价物。</target>
        </trans-unit>
        <trans-unit id="d80346c4a6d83f0a2408ae318740b75196640a27" translate="yes" xml:space="preserve">
          <source>The lookup function is called each time the resulting importer needs to resolve an import path. In this mode the importer can only be invoked with canonical import paths (not relative or absolute ones); it is assumed that the translation to canonical import paths is being done by the client of the importer.</source>
          <target state="translated">每次当生成的导入器需要解析导入路径时,都会调用查找函数。在这种模式下,进口商只能使用规范的进口路径(不是相对或绝对路径)来调用;假定进口商的客户端正在进行向规范进口路径的转换。</target>
        </trans-unit>
        <trans-unit id="d42ee39ba69d607990bf6285f526cdb4d05cd8c5" translate="yes" xml:space="preserve">
          <source>The low bit is therefore analogous to a sign bit, but making it the complement bit instead guarantees that the largest negative integer is not a special case. For example, -129=^128=(^256&amp;gt;&amp;gt;1) encodes as (FE 01 01).</source>
          <target state="translated">因此，低位类似于符号位，但是将其设为补码位可确保最大的负整数不是特殊情况。例如，-129 = ^ 128 =（^ 256 &amp;gt;&amp;gt; 1）编码为（FE 01 01）。</target>
        </trans-unit>
        <trans-unit id="e23983031d30e849dd601f8a9a147a11b178b7e1" translate="yes" xml:space="preserve">
          <source>The main use case is finding resources located relative to an executable.</source>
          <target state="translated">主要的用例是寻找相对于可执行文件的资源。</target>
        </trans-unit>
        <trans-unit id="ae651dd57d8aac89d2244b121832135b42a78e22" translate="yes" xml:space="preserve">
          <source>The make built-in function allocates and initializes an object of type slice, map, or chan (only). Like new, the first argument is a type, not a value. Unlike new, make's return type is the same as the type of its argument, not a pointer to it. The specification of the result depends on the type:</source>
          <target state="translated">make内置函数分配并初始化一个类型为slice、map或chan(仅)的对象。和new一样,第一个参数是一个类型,而不是一个值。与new不同,make的返回类型与它的参数类型相同,而不是指向它的指针。结果的规格取决于类型。</target>
        </trans-unit>
        <trans-unit id="ad15554627caa64494fe09878e570067f5641170" translate="yes" xml:space="preserve">
          <source>The meaning of the parameters fset, pkg, and pos is the same as in CheckExpr. An error is returned if expr cannot be parsed successfully, or the resulting expr AST cannot be type-checked.</source>
          <target state="translated">参数fset、pkg和pos的含义与CheckExpr相同。如果expr不能被成功解析,或者产生的expr AST不能进行类型检查,则返回一个错误。</target>
        </trans-unit>
        <trans-unit id="76f7a0e267f75e03932754601186fb88901bc244" translate="yes" xml:space="preserve">
          <source>The message must be no longer than the length of the public modulus minus twice the hash length, minus a further 2.</source>
          <target state="translated">该消息必须不长于公共模数的长度减去哈希长度的两倍,再减去2。</target>
        </trans-unit>
        <trans-unit id="f50438ca0e284cc49442d4b96ed8422098542b37" translate="yes" xml:space="preserve">
          <source>The method for resolving domain names, whether indirectly with functions like Dial or directly with functions like LookupHost and LookupAddr, varies by operating system.</source>
          <target state="translated">解析域名的方法,无论是间接使用Dial等函数,还是直接使用LookupHost和LookupAddr等函数,都因操作系统而异。</target>
        </trans-unit>
        <trans-unit id="fd8e3459dc1d93b8b2959d9f7ce9e888fe72a14d" translate="yes" xml:space="preserve">
          <source>The method's first argument represents the arguments provided by the caller; the second argument represents the result parameters to be returned to the caller. The method's return value, if non-nil, is passed back as a string that the client sees as if created by errors.New. If an error is returned, the reply parameter will not be sent back to the client.</source>
          <target state="translated">该方法的第一个参数代表调用者提供的参数;第二个参数代表要返回给调用者的结果参数。该方法的返回值如果是非nil,则会以字符串的形式传回,客户端看到的字符串就像由错误.New创建的一样。如果返回错误,则不会将回复参数发回给客户端。</target>
        </trans-unit>
        <trans-unit id="eebd4cc8d1b396bccc721d19c4bd56800d60e192" translate="yes" xml:space="preserve">
          <source>The methods should behave the same as those on an *os.File.</source>
          <target state="translated">这些方法的行为应该与*os.File.Methods上的方法相同。</target>
        </trans-unit>
        <trans-unit id="3351c33da5b9bc73dd81d983421271485dd91e09" translate="yes" xml:space="preserve">
          <source>The minimal source code for a binary-only package was therefore:</source>
          <target state="translated">因此,二进制包的最小源代码是。</target>
        </trans-unit>
        <trans-unit id="ba0d7c85cb07c29f22bceee0e488a79cf0a2c300" translate="yes" xml:space="preserve">
          <source>The minimum element in the tree is the root, at index 0.</source>
          <target state="translated">树中最小的元素是根,索引为0。</target>
        </trans-unit>
        <trans-unit id="6cf2c8c68bd743b1d5a4e29ae7301dad5d49bcb2" translate="yes" xml:space="preserve">
          <source>The mode parameter controls the amount of source text parsed and other optional parser functionality. Position information is recorded in the file set fset, which must not be nil.</source>
          <target state="translated">模式参数控制源文本的解析量和其他可选的解析器功能。位置信息记录在文件集fset中,fset不能为零。</target>
        </trans-unit>
        <trans-unit id="7d1773f39818c5825c59e48b1236b92119b0b32e" translate="yes" xml:space="preserve">
          <source>The month, day, hour, min, sec, and nsec values may be outside their usual ranges and will be normalized during the conversion. For example, October 32 converts to November 1.</source>
          <target state="translated">月、日、时、分、秒和nsec的值可能超出了它们的通常范围,并将在转换过程中被标准化。例如,10月32日转换为11月1日。</target>
        </trans-unit>
        <trans-unit id="a5541e290e27715c3d35b2115cad871f3ab99ccb" translate="yes" xml:space="preserve">
          <source>The most common numeric conversions are Atoi (string to int) and Itoa (int to string).</source>
          <target state="translated">最常见的数字转换是Atoi(字符串到int)和Itoa(int到字符串)。</target>
        </trans-unit>
        <trans-unit id="4bbbacdbad6d2c99ac68260aad07ecb869838903" translate="yes" xml:space="preserve">
          <source>The most common use of this pattern is to access fields in a struct or elements of an array:</source>
          <target state="translated">该模式最常见的用法是访问结构中的字段或数组中的元素。</target>
        </trans-unit>
        <trans-unit id="ac8cc81db3fc49af2479176c9231b929d55cdbd8" translate="yes" xml:space="preserve">
          <source>The msg parameter should be an RFC 822-style email with headers first, a blank line, and then the message body. The lines of msg should be CRLF terminated. The msg headers should usually include fields such as &quot;From&quot;, &quot;To&quot;, &quot;Subject&quot;, and &quot;Cc&quot;. Sending &quot;Bcc&quot; messages is accomplished by including an email address in the to parameter but not including it in the msg headers.</source>
          <target state="translated">msg 参数应该是 RFC 822 风格的电子邮件,先是标题,再是空行,然后是邮件正文。msg 的行应该以 CRLF 结尾。msg 头部通常应该包括诸如 &quot;发件人&quot;、&quot;收件人&quot;、&quot;主题 &quot;和 &quot;抄送 &quot;等字段。发送 &quot;Bcc &quot;信息的方法是在 to 参数中包含一个电子邮件地址,但不包含在 msg 头部。</target>
        </trans-unit>
        <trans-unit id="410aa7b0a0304575a8915750342dc577b832f74c" translate="yes" xml:space="preserve">
          <source>The name for the XML elements is taken from, in order of preference:</source>
          <target state="translated">XML元素的名称依次取自。</target>
        </trans-unit>
        <trans-unit id="57b088fc8d39478c2345773281e5eb271805f7ea" translate="yes" xml:space="preserve">
          <source>The naming convention to declare examples for the package, a function F, a type T and method M on type T are:</source>
          <target state="translated">为包、函数F、类型T和类型T上的方法M声明例子的命名惯例是:</target>
        </trans-unit>
        <trans-unit id="7b9b492a2e0fbf406f8b8d17e034f78a30b6eb8c" translate="yes" xml:space="preserve">
          <source>The net, net/http, and crypto/tls packages also refer to debugging variables in GODEBUG. See the documentation for those packages for details.</source>
          <target state="translated">net、net/http和crypto/tls包也引用了GODEBUG中的调试变量。详情请参见这些包的文档。</target>
        </trans-unit>
        <trans-unit id="69954652d3ee14598bd31e60017ff5be6ec75582" translate="yes" xml:space="preserve">
          <source>The net/http/cookiejar package provides a CookieJar implementation.</source>
          <target state="translated">net/http/cookiejar包提供了一个CookieJar的实现。</target>
        </trans-unit>
        <trans-unit id="7815d9693c2e8fba3de7740f99dda917ebde80d7" translate="yes" xml:space="preserve">
          <source>The net/rpc package is frozen and is not accepting new features.</source>
          <target state="translated">net/rpc包被冻结,不接受新功能。</target>
        </trans-unit>
        <trans-unit id="b67ec9dd23234843cefc446704be9276e0333344" translate="yes" xml:space="preserve">
          <source>The network must be &quot;tcp&quot;, &quot;tcp4&quot;, &quot;tcp6&quot;, &quot;unix&quot; or &quot;unixpacket&quot;.</source>
          <target state="translated">网络必须是 &quot;tcp&quot;、&quot;tcp4&quot;、&quot;tcp6&quot;、&quot;unix &quot;或 &quot;unixpacket&quot;。</target>
        </trans-unit>
        <trans-unit id="f78c2675c0a1b78facf549c913ce29c8786aed4f" translate="yes" xml:space="preserve">
          <source>The network must be &quot;udp&quot;, &quot;udp4&quot;, &quot;udp6&quot;, &quot;unixgram&quot;, or an IP transport. The IP transports are &quot;ip&quot;, &quot;ip4&quot;, or &quot;ip6&quot; followed by a colon and a literal protocol number or a protocol name, as in &quot;ip:1&quot; or &quot;ip:icmp&quot;.</source>
          <target state="translated">网络必须是 &quot;udp&quot;、&quot;udp4&quot;、&quot;udp6&quot;、&quot;unixgram &quot;或IP传输。IP传输是 &quot;ip&quot;、&quot;ip4 &quot;或 &quot;ip6&quot;,后面跟着一个冒号和一个协议号或协议名,如 &quot;ip:1 &quot;或 &quot;ip:icmp&quot;。</target>
        </trans-unit>
        <trans-unit id="f62f0c6bf3637b6bd91fbed73590e0c5ec059d67" translate="yes" xml:space="preserve">
          <source>The network must be &quot;unix&quot; or &quot;unixpacket&quot;.</source>
          <target state="translated">网络必须是 &quot;unix &quot;或 &quot;unixpacket&quot;。</target>
        </trans-unit>
        <trans-unit id="961ea2a9664370be05fda243ace29bf62f0b8b14" translate="yes" xml:space="preserve">
          <source>The network must be &quot;unixgram&quot;.</source>
          <target state="translated">网络必须是 &quot;unixgram&quot;。</target>
        </trans-unit>
        <trans-unit id="143c1ec61594ea23a84fdfc668726a693ff1d059" translate="yes" xml:space="preserve">
          <source>The network must be a TCP network name.</source>
          <target state="translated">网络必须是TCP网络名。</target>
        </trans-unit>
        <trans-unit id="54bb9136f9b37f7468411dbae5b647c63059a3a1" translate="yes" xml:space="preserve">
          <source>The network must be a TCP network name; see func Dial for details.</source>
          <target state="translated">网络必须是一个TCP网络名,详情请看func Dial。</target>
        </trans-unit>
        <trans-unit id="a35132d711d8945bdb8b272ee67848e4c94a5a16" translate="yes" xml:space="preserve">
          <source>The network must be a UDP network name.</source>
          <target state="translated">网络必须是UDP网络名。</target>
        </trans-unit>
        <trans-unit id="89ed96066a0fbc9b6b82696daa8ba7effb94e0a8" translate="yes" xml:space="preserve">
          <source>The network must be a UDP network name; see func Dial for details.</source>
          <target state="translated">网络必须是UDP网络名,详情请看func Dial。</target>
        </trans-unit>
        <trans-unit id="199d17e2fe63f354db9a6b916c396629d6b88dda" translate="yes" xml:space="preserve">
          <source>The network must be a Unix network name.</source>
          <target state="translated">网络必须是Unix网络名。</target>
        </trans-unit>
        <trans-unit id="b6cf9d29e750ed948316e5ba40edb44e452845b1" translate="yes" xml:space="preserve">
          <source>The network must be a Unix network name; see func Dial for details.</source>
          <target state="translated">网络必须是Unix网络名,详情请看func Dial。</target>
        </trans-unit>
        <trans-unit id="61f5a2270318ecc8414142178aaa1a53165f97e7" translate="yes" xml:space="preserve">
          <source>The network must be an IP network name.</source>
          <target state="translated">网络必须是IP网络名。</target>
        </trans-unit>
        <trans-unit id="b881d6aafa14d5f635aad510160f9473031ecf6f" translate="yes" xml:space="preserve">
          <source>The network must be an IP network name; see func Dial for details.</source>
          <target state="translated">网络必须是一个IP网络名,详情请看func Dial。</target>
        </trans-unit>
        <trans-unit id="882441c96cbf8f9716ac8a79d3a5eb4e3af0bcfd" translate="yes" xml:space="preserve">
          <source>The new Handler calls h.ServeHTTP to handle each request, but if a call runs for longer than its time limit, the handler responds with a 503 Service Unavailable error and the given message in its body. (If msg is empty, a suitable default message will be sent.) After such a timeout, writes by h to its ResponseWriter will return ErrHandlerTimeout.</source>
          <target state="translated">新的处理程序调用h.ServeHTTP来处理每个请求,但是如果一个调用运行的时间超过了它的时间限制,处理程序就会以503服务不可用的错误和在它的正文中给出的消息来响应。 (如果msg是空的,就会发送合适的默认消息。)在这样的超时之后,h向它的ResponseWriter写的东西会返回ErrHandlerTimeout。(如果msg为空,则会发送一个合适的默认消息。)在这样的超时之后,h对其ResponseWriter的写入将返回ErrHandlerTimeout。</target>
        </trans-unit>
        <trans-unit id="3cf0c81686ac1acb508bf9e67780a55cee7159d9" translate="yes" xml:space="preserve">
          <source>The new built-in function allocates memory. The first argument is a type, not a value, and the value returned is a pointer to a newly allocated zero value of that type.</source>
          <target state="translated">新的内置函数分配内存。第一个参数是一个类型,而不是一个值,返回的值是一个指向该类型新分配的零值的指针。</target>
        </trans-unit>
        <trans-unit id="902360dabebdea5b3a521c7b72fed85e30d4437d" translate="yes" xml:space="preserve">
          <source>The node type must be *ast.File, *printer.CommentedNode, []ast.Decl, []ast.Stmt, or assignment-compatible to ast.Expr, ast.Decl, ast.Spec, or ast.Stmt. Node does not modify node. Imports are not sorted for nodes representing partial source files (for instance, if the node is not an *ast.File or a *printer.CommentedNode not wrapping an *ast.File).</source>
          <target state="translated">节点类型必须是*ast.File、*printer.CommentedNode、[]ast.Decl、[]ast.Stmt,或与 ast.Expr、 ast.Decl、 ast.Spec 或 ast.Stmt 兼容的赋值。节点不修改节点。对于代表部分源文件的节点,导入不排序(例如,如果节点不是*ast.File或*printer.CommentedNode没有包装*ast.File)。</target>
        </trans-unit>
        <trans-unit id="56cff2c7a026fcff6621abd1c298d8e39f80b3ef" translate="yes" xml:space="preserve">
          <source>The non-Go code should not change the signal mask on any threads created by the Go runtime. If the non-Go code starts new threads of its own, it may set the signal mask as it pleases.</source>
          <target state="translated">非围棋代码不应改变围棋运行时创建的任何线程的信号掩码。如果非围棋代码自己启动新的线程,它可以随意设置信号掩码。</target>
        </trans-unit>
        <trans-unit id="b32a27700c08984e10653750973205a0166116d3" translate="yes" xml:space="preserve">
          <source>The only signal values guaranteed to be present in the os package on all systems are os.Interrupt (send the process an interrupt) and os.Kill (force the process to exit). On Windows, sending os.Interrupt to a process with os.Process.Signal is not implemented; it will return an error instead of sending a signal.</source>
          <target state="translated">在所有系统的os包中保证存在的信号值只有os.Interrupt(向进程发送一个中断)和os.Kill(强制进程退出)。在 Windows 上,用 os.Process.Signal 向进程发送 os.Interrupt 是无法实现的;它将返回一个错误而不是发送一个信号。</target>
        </trans-unit>
        <trans-unit id="8c37b0a4e6fab650a215cbd5edb17eee82ff53db" translate="yes" xml:space="preserve">
          <source>The original specification for encryption and signatures with RSA is PKCS#1 and the terms &quot;RSA encryption&quot; and &quot;RSA signatures&quot; by default refer to PKCS#1 version 1.5. However, that specification has flaws and new designs should use version two, usually called by just OAEP and PSS, where possible.</source>
          <target state="translated">用RSA进行加密和签名的原始规范是PKCS#1,&quot;RSA加密 &quot;和 &quot;RSA签名 &quot;这两个术语默认指的是PKCS#1 1.5版本。但是,该规范存在缺陷,新的设计应尽可能使用第二版本,通常只用OAEP和PSS来称呼。</target>
        </trans-unit>
        <trans-unit id="540d9d25cf4179e22c8285de7096ab16e1c12b86" translate="yes" xml:space="preserve">
          <source>The original tar format was introduced in Unix V7. Since then, there have been multiple competing formats attempting to standardize or extend the V7 format to overcome its limitations. The most common formats are the USTAR, PAX, and GNU formats, each with their own advantages and limitations.</source>
          <target state="translated">最初的焦油格式是在Unix V7中引入的。从那时起,就有多种竞争性格式试图标准化或扩展 V7 格式以克服其局限性。最常见的格式是UTAR、PAX和GNU格式,每种格式都有自己的优势和局限性。</target>
        </trans-unit>
        <trans-unit id="447ae61382377495d9bb3dcbc7167cc095d3d833" translate="yes" xml:space="preserve">
          <source>The os interface is intended to be uniform across all operating systems. Features not generally available appear in the system-specific package syscall.</source>
          <target state="translated">os接口的目的是为了在所有操作系统中统一。一般不可用的功能会出现在系统专用的软件包syscall中。</target>
        </trans-unit>
        <trans-unit id="826c8f633f039e53ad0aac6dce5e00961c47baef" translate="yes" xml:space="preserve">
          <source>The other reporting methods, such as the variations of Log and Error, may be called simultaneously from multiple goroutines.</source>
          <target state="translated">其他报告方法,如日志和错误的变化,可以从多个goroutine中同时调用。</target>
        </trans-unit>
        <trans-unit id="314818cec484a0a4f79c6a3bd12ea1e65d6a5497" translate="yes" xml:space="preserve">
          <source>The output of a command will be either one value or two values, the second of which has type error. If that second value is present and evaluates to non-nil, execution terminates and the error is returned to the caller of Execute.</source>
          <target state="translated">命令的输出将是一个值或两个值,其中第二个值的类型为错误。如果第二个值存在,并且值为非nil,则执行终止,错误返回给Execute的调用者。</target>
        </trans-unit>
        <trans-unit id="01b79b49ed9f5aef9d64418cf5de61a045616033" translate="yes" xml:space="preserve">
          <source>The package also runs and verifies example code. Example functions may include a concluding line comment that begins with &quot;Output:&quot; and is compared with the standard output of the function when the tests are run. (The comparison ignores leading and trailing space.) These are examples of an example:</source>
          <target state="translated">该软件包还可以运行和验证示例代码。示例函数可能包含一个以 &quot;Output:&quot;开头的结尾行注释,并在测试运行时与函数的标准输出进行比较。(比较会忽略前导空格和后导空格。)这些都是例子的例子。</target>
        </trans-unit>
        <trans-unit id="a842fba56dd27e8e683543ed1da0bb8ec8237f57" translate="yes" xml:space="preserve">
          <source>The package is marked as complete if no errors occurred, otherwise it is incomplete. See Config.Error for controlling behavior in the presence of errors.</source>
          <target state="translated">如果没有发生错误,则该包被标记为完整,否则就是不完整。参见Config.Error,了解如何在出现错误时控制行为。</target>
        </trans-unit>
        <trans-unit id="084533be70387d373858b81e63ee3fdbb938556c" translate="yes" xml:space="preserve">
          <source>The package is sometimes only imported for the side effect of registering its HTTP handler and the above variables. To use it this way, link this package into your program:</source>
          <target state="translated">这个包有时只是为了注册它的HTTP处理程序和上述变量的副作用而导入的。如果要这样使用,请将这个包链接到你的程序中。</target>
        </trans-unit>
        <trans-unit id="a76fef8dda549c1a3db0f0948e9255bd119d522e" translate="yes" xml:space="preserve">
          <source>The package is specified by a list of *ast.Files and corresponding file set, and the package path the package is identified with. The clean path must not be empty or dot (&quot;.&quot;).</source>
          <target state="translated">包是由*ast.Files和对应的文件集的列表,以及包所标识的包路径来指定的。清理路径不得为空或点(&quot;.&quot;)。</target>
        </trans-unit>
        <trans-unit id="399fd3ad30378409e2dc4bdf013d129681dab5d4" translate="yes" xml:space="preserve">
          <source>The package is typically only imported for the side effect of registering its HTTP handlers. The handled paths all begin with /debug/pprof/.</source>
          <target state="translated">这个包通常只是为了注册它的HTTP处理程序而导入的。处理的路径都是以/debug/pprof/开头的。</target>
        </trans-unit>
        <trans-unit id="1435a203fd8b96db3ad7b17b180e6f206d92f47b" translate="yes" xml:space="preserve">
          <source>The package is using the Elastic Tabstops algorithm described at &lt;a href=&quot;http://nickgravgaard.com/elastictabstops/index.html&quot;&gt;http://nickgravgaard.com/elastictabstops/index.html&lt;/a&gt;.</source>
          <target state="translated">该程序包使用&lt;a href=&quot;http://nickgravgaard.com/elastictabstops/index.html&quot;&gt;http://nickgravgaard.com/elastictabstops/index.html中&lt;/a&gt;描述的Elastic Tabstops算法。</target>
        </trans-unit>
        <trans-unit id="2d8c628767f33f2351dada491bfefd34f51b3140" translate="yes" xml:space="preserve">
          <source>The package provides:</source>
          <target state="translated">该方案提供:</target>
        </trans-unit>
        <trans-unit id="fdd304cc0ffa560e98ef7d6ccf98bb51070237a4" translate="yes" xml:space="preserve">
          <source>The packages golang.org/x/net/ipv4 and golang.org/x/net/ipv6 can be used to manipulate IP-level socket options in oob.</source>
          <target state="translated">golang.org/x/net/ipv4和golang.org/x/net/ipv6这两个包可以用来操作oob中的IP级socket选项。</target>
        </trans-unit>
        <trans-unit id="e31e979e3edc39254b9a5c52d82e5a30deadc675" translate="yes" xml:space="preserve">
          <source>The panic built-in function stops normal execution of the current goroutine. When a function F calls panic, normal execution of F stops immediately. Any functions whose execution was deferred by F are run in the usual way, and then F returns to its caller. To the caller G, the invocation of F then behaves like a call to panic, terminating G's execution and running any deferred functions. This continues until all functions in the executing goroutine have stopped, in reverse order. At that point, the program is terminated with a non-zero exit code. This termination sequence is called panicking and can be controlled by the built-in function recover.</source>
          <target state="translated">panic内置函数停止当前goroutine的正常执行。当函数F调用panic时,F的正常执行立即停止。任何被F推迟执行的函数都会以通常的方式运行,然后F返回给它的调用者。对调用者G来说,F的调用就像对panic的调用一样,终止G的执行,并运行任何推迟执行的函数。这种情况一直持续到正在执行的goroutine中的所有函数都停止,顺序相反。这时,程序以一个非零的退出代码终止。这个终止序列称为panicking,可以通过内置函数recover来控制。</target>
        </trans-unit>
        <trans-unit id="af4f035528815b22e373ca233969d1eeb80da9ab" translate="yes" xml:space="preserve">
          <source>The parse functions return the widest type (float64, int64, and uint64), but if the size argument specifies a narrower width the result can be converted to that narrower type without data loss:</source>
          <target state="translated">解析函数返回最宽的类型(float64、int64和uint64),但如果size参数指定了一个较窄的宽度,结果可以转换为该较窄的类型,而不会丢失数据。</target>
        </trans-unit>
        <trans-unit id="a18efb4bf749b7c5acc3a4bfaddc4a2e6898762f" translate="yes" xml:space="preserve">
          <source>The parser accepts a larger language than is syntactically permitted by the Go spec, for simplicity, and for improved robustness in the presence of syntax errors. For instance, in method declarations, the receiver is treated like an ordinary parameter list and thus may contain multiple entries where the spec permits exactly one. Consequently, the corresponding field in the AST (ast.FuncDecl.Recv) field is not restricted to one entry.</source>
          <target state="translated">为了简单起见,也为了提高语法错误时的鲁棒性,解析器接受的语言比Go规范所允许的语法更大。例如,在方法声明中,接受者被当作普通的参数列表,因此可能包含多个条目,而规范只允许一个。因此,AST(ast.FuncDecl.Recv)字段中相应的字段不限于一个条目。</target>
        </trans-unit>
        <trans-unit id="f1b15ae7c535ec21c3b3214f780b2381f7617014" translate="yes" xml:space="preserve">
          <source>The path and host are used unchanged for CONNECT requests.</source>
          <target state="translated">在CONNECT请求中,路径和主机是不变的。</target>
        </trans-unit>
        <trans-unit id="185477acd3fd456d75fb7c4fc53e2fc58b8c4aaf" translate="yes" xml:space="preserve">
          <source>The path package should only be used for paths separated by forward slashes, such as the paths in URLs. This package does not deal with Windows paths with drive letters or backslashes; to manipulate operating system paths, use the path/filepath package.</source>
          <target state="translated">path包只能用于处理用斜线分隔的路径,比如URL中的路径。这个包并不处理Windows系统中带有驱动器字母或反斜杠的路径;如果要操作操作系统的路径,请使用path/filepath包。</target>
        </trans-unit>
        <trans-unit id="26954c9ca56cc48a56a0453ce2488e2f260ed60b" translate="yes" xml:space="preserve">
          <source>The pkg/ directory holds installed package objects. As in the Go tree, each target operating system and architecture pair has its own subdirectory of pkg (pkg/GOOS_GOARCH).</source>
          <target state="translated">pkg/目录下存放着已安装的包对象。和围棋树一样,每个目标操作系统和架构对都有自己的 pkg 子目录 (pkg/GOOS_GOARCH)。</target>
        </trans-unit>
        <trans-unit id="5a87eb4ca6fbc546df6339993053151079409112" translate="yes" xml:space="preserve">
          <source>The precision prec controls the number of digits (excluding the exponent) printed by the 'e', 'E', 'f', 'g', 'G', 'x', and 'X' formats. For 'e', 'E', 'f', 'x', and 'X', it is the number of digits after the decimal point. For 'g' and 'G' it is the maximum number of significant digits (trailing zeros are removed). The special precision -1 uses the smallest number of digits necessary such that ParseFloat will return f exactly.</source>
          <target state="translated">精度prec控制'e'、'E'、'f'、'g'、'G'、'x'和'X'格式打印的位数(不包括指数)。对于'e'、'E'、'f'、'x'和'X',它是小数点后的数字。对于'g'和'G',它是最大的有意义的数字(去掉了尾部的零)。特殊精度-1使用的是必要的最小数字,这样ParseFloat将准确地返回f。</target>
        </trans-unit>
        <trans-unit id="69078c80b7be9ecb1f89b1ab519c7b7264b1d687" translate="yes" xml:space="preserve">
          <source>The precision prec controls the number of digits (excluding the exponent) printed by the 'e', 'E', 'f', 'g', 'G', and 'x' formats. For 'e', 'E', 'f', and 'x', it is the number of digits after the decimal point. For 'g' and 'G' it is the total number of digits. A negative precision selects the smallest number of decimal digits necessary to identify the value x uniquely using x.Prec() mantissa bits. The prec value is ignored for the 'b' and 'p' formats.</source>
          <target state="translated">精度prec控制'e'、'E'、'f'、'g'、'G'和'x'格式打印的位数(不包括指数)。对于'e'、'E'、'f'和'x',它是小数点后的数字。对于'g'和'G',它是数字的总数。负精度选择了使用x.Prec()mantissa位来唯一识别值x所需的最小的十进制位数。对于'b'和'p'格式,prec值被忽略。</target>
        </trans-unit>
        <trans-unit id="456c4a02a800a4453e3d726e233dc51ff74f0fc9" translate="yes" xml:space="preserve">
          <source>The predefined profiles may assign meaning to other debug values; for example, when printing the &quot;goroutine&quot; profile, debug=2 means to print the goroutine stacks in the same form that a Go program uses when dying due to an unrecovered panic.</source>
          <target state="translated">预定义的配置文件可以给其他调试值赋予意义;例如,当打印 &quot;goroutine &quot;配置文件时,debug=2意味着以与围棋程序因未恢复的恐慌而死亡时相同的形式打印goroutine堆栈。</target>
        </trans-unit>
        <trans-unit id="58481973143a6de618e8538c648e764b31b42f2b" translate="yes" xml:space="preserve">
          <source>The print built-in function formats its arguments in an implementation-specific way and writes the result to standard error. Print is useful for bootstrapping and debugging; it is not guaranteed to stay in the language.</source>
          <target state="translated">print内置函数以特定于实现的方式格式化其参数,并将结果写入标准错误。print对于引导和调试是有用的,它不保证会留在语言中。</target>
        </trans-unit>
        <trans-unit id="91f04de49b9af203098665c6f8b752b5392b78a0" translate="yes" xml:space="preserve">
          <source>The println built-in function formats its arguments in an implementation-specific way and writes the result to standard error. Spaces are always added between arguments and a newline is appended. Println is useful for bootstrapping and debugging; it is not guaranteed to stay in the language.</source>
          <target state="translated">println内置函数以特定于实现的方式格式化其参数,并将结果写入标准错误。参数之间总是添加空格,并附加一个换行。Println对引导和调试很有用;它并不保证会留在语言中。</target>
        </trans-unit>
        <trans-unit id="151eef92ef01a650c4a9036a013718d694ffc693" translate="yes" xml:space="preserve">
          <source>The provided Context must be non-nil. If the context expires before the connection is complete, an error is returned. Once successfully connected, any expiration of the context will not affect the connection.</source>
          <target state="translated">提供的Context必须为非零。如果上下文在连接完成前过期,将返回一个错误。一旦连接成功,任何过期的上下文将不会影响连接。</target>
        </trans-unit>
        <trans-unit id="0e411a42789a39be423654b810b14a1d819d3f7a" translate="yes" xml:space="preserve">
          <source>The provided TxOptions is optional and may be nil if defaults should be used. If a non-default isolation level is used that the driver doesn't support, an error will be returned.</source>
          <target state="translated">提供的TxOptions是可选的,如果应该使用默认值,则可能为零。如果使用了驱动不支持的非默认隔离级别,将返回一个错误。</target>
        </trans-unit>
        <trans-unit id="decd2b405e8241c6f8e12f33bd5a3bb2cc5dc04e" translate="yes" xml:space="preserve">
          <source>The provided body may be nil. If the body is of type *bytes.Reader, *strings.Reader, or *bytes.Buffer, the Request.ContentLength is set.</source>
          <target state="translated">所提供的body可以是nil.如果body的类型是*bytes.Reader、*strings.Reader或*bytes.Buffer,则设置Request.ContentLength。如果body的类型是*bytes.Reader、*strings.Reader或*bytes.Buffer,则设置Request.ContentLength。</target>
        </trans-unit>
        <trans-unit id="58ddb87ccdb3a3bbf17dded9af2e6f690f9fa593" translate="yes" xml:space="preserve">
          <source>The provided code should be in the 3xx range and is usually StatusMovedPermanently, StatusFound or StatusSeeOther.</source>
          <target state="translated">提供的代码应该在3xx范围内,通常是StatusMovedPermanently、StatusFound或StatusSeeOther。</target>
        </trans-unit>
        <trans-unit id="86be20106cb95d195cb582ade394435819f24514" translate="yes" xml:space="preserve">
          <source>The provided context is used for the preparation of the statement, not for the execution of the statement.</source>
          <target state="translated">所提供的上下文用于编制语句,而不是执行语句。</target>
        </trans-unit>
        <trans-unit id="dd14eed153c5e1b07e7490871396f032fee4f925" translate="yes" xml:space="preserve">
          <source>The provided context is used to kill the process (by calling os.Process.Kill) if the context becomes done before the command completes on its own.</source>
          <target state="translated">如果上下文在命令完成之前就已经完成了,那么所提供的上下文将被用来杀死进程(通过调用os.Process.Kill)。</target>
        </trans-unit>
        <trans-unit id="a4964ee167f777b88ff9017caa2a6e7f575494e2" translate="yes" xml:space="preserve">
          <source>The provided context is used until the transaction is committed or rolled back. If the context is canceled, the sql package will roll back the transaction. Tx.Commit will return an error if the context provided to BeginTx is canceled.</source>
          <target state="translated">所提供的上下文被使用,直到事务被提交或回滚。如果上下文被取消,sql包将回滚事务。如果提供给BeginTx的上下文被取消,Tx.Commit将返回一个错误。</target>
        </trans-unit>
        <trans-unit id="08a11fcf0761deb535b1afddd2450e0cb1b073dd" translate="yes" xml:space="preserve">
          <source>The provided context will be used for the preparation of the context, not for the execution of the returned statement. The returned statement will run in the transaction context.</source>
          <target state="translated">所提供的上下文将用于上下文的准备,而不是用于执行返回的语句。返回的语句将在事务上下文中运行。</target>
        </trans-unit>
        <trans-unit id="36087efe71a5f2727d53bfdfa94ece516eb41424" translate="yes" xml:space="preserve">
          <source>The provided key must be comparable and should not be of type string or any other built-in type to avoid collisions between packages using context. Users of WithValue should define their own types for keys. To avoid allocating when assigning to an interface{}, context keys often have concrete type struct{}. Alternatively, exported context key variables' static type should be a pointer or interface.</source>
          <target state="translated">所提供的键必须是可比较的,并且不应该是字符串或任何其他内置类型,以避免使用上下文的包之间发生碰撞。WithValue的用户应该自己定义键的类型。为了避免分配到接口{}时的分配,上下文键通常具有具体的类型struct{}。另外,导出的上下文键变量的静态类型应该是指针或接口。</target>
        </trans-unit>
        <trans-unit id="85ad36caa7041b29ad99437d10d43da203313ed0" translate="yes" xml:space="preserve">
          <source>The race detector kills the program if it exceeds 8192 concurrent goroutines, so use care when running parallel tests with the -race flag set.</source>
          <target state="translated">赛跑检测器会在超过8192个并发goroutines的情况下杀死程序,所以在设置-race标志的情况下运行并行测试时要小心。</target>
        </trans-unit>
        <trans-unit id="8b5744dbc3f5965d88d3d9f6581899823cd536e1" translate="yes" xml:space="preserve">
          <source>The rand parameter is used as a source of entropy to ensure that encrypting the same message twice doesn't result in the same ciphertext.</source>
          <target state="translated">rand参数作为熵的来源,以确保对同一消息加密两次不会产生相同的密文。</target>
        </trans-unit>
        <trans-unit id="9b3902f0d9da9da0e87784ba5652f4c8601d4919" translate="yes" xml:space="preserve">
          <source>The random parameter is used as a source of entropy to ensure that encrypting the same message twice doesn't result in the same ciphertext.</source>
          <target state="translated">随机参数作为熵的来源,以确保对同一消息加密两次不会产生相同的密文。</target>
        </trans-unit>
        <trans-unit id="cf169dddc14ea8341fcb30899e22a5fa61df4712" translate="yes" xml:space="preserve">
          <source>The random parameter, if not nil, is used to blind the private-key operation and avoid timing side-channel attacks. Blinding is purely internal to this function &amp;ndash; the random data need not match that used when encrypting.</source>
          <target state="translated">随机参数（如果不为nil）用于使私钥操作失效，并避免定时进行边信道攻击。盲处理纯粹是此功能的内部功能&amp;ndash;随机数据不必与加密时使用的数据匹配。</target>
        </trans-unit>
        <trans-unit id="2314ea9b04c810fb371325317bf102a02d2d59d0" translate="yes" xml:space="preserve">
          <source>The rawurl may be relative (a path, without a host) or absolute (starting with a scheme). Trying to parse a hostname and path without a scheme is invalid but may not necessarily return an error, due to parsing ambiguities.</source>
          <target state="translated">rawurl可以是相对的(一个路径,没有主机)或绝对的(以scheme开始)。试图解析一个没有方案的主机名和路径是无效的,但由于解析的模糊性,不一定会返回错误。</target>
        </trans-unit>
        <trans-unit id="239176c955d354cb84e342df1da6a160a09d1822" translate="yes" xml:space="preserve">
          <source>The read and write halves of the connection are serialized independently, so no interlocking is required. However each half may be accessed concurrently so the implementation of conn should protect against concurrent reads or concurrent writes.</source>
          <target state="translated">连接的读写两半是独立序列化的,所以不需要互锁。然而每一半都可能被并发访问,所以conn的实现应该防止并发读或并发写。</target>
        </trans-unit>
        <trans-unit id="b43ec28ed349612adbaa799bb6c92934c3b075dc" translate="yes" xml:space="preserve">
          <source>The real built-in function returns the real part of the complex number c. The return value will be floating point type corresponding to the type of c.</source>
          <target state="translated">实数内置函数返回复数c的实数部分,返回值将是c类型对应的浮点类型。</target>
        </trans-unit>
        <trans-unit id="9bb09164885f351e6fb900da553f1e63b375bfa9" translate="yes" xml:space="preserve">
          <source>The recognized day of week formats are &quot;Mon&quot; and &quot;Monday&quot;. The recognized month formats are &quot;Jan&quot; and &quot;January&quot;.</source>
          <target state="translated">公认的星期格式是 &quot;Mon &quot;和 &quot;Monday&quot;。公认的月份格式是 &quot;Jan &quot;和 &quot;January&quot;。</target>
        </trans-unit>
        <trans-unit id="2c571daa54e2fb7d0c128741daf715a11d1e44fe" translate="yes" xml:space="preserve">
          <source>The recover built-in function allows a program to manage behavior of a panicking goroutine. Executing a call to recover inside a deferred function (but not any function called by it) stops the panicking sequence by restoring normal execution and retrieves the error value passed to the call of panic. If recover is called outside the deferred function it will not stop a panicking sequence. In this case, or when the goroutine is not panicking, or if the argument supplied to panic was nil, recover returns nil. Thus the return value from recover reports whether the goroutine is panicking.</source>
          <target state="translated">内建的recover函数允许程序管理一个恐慌性程序的行为。在递延函数(但不包括被它调用的任何函数)中执行对recover的调用,通过恢复正常执行来停止恐慌序列,并检索传递给panic调用的错误值。如果在递延函数之外调用recover,则不会停止恐慌序列。在这种情况下,或者当goroutine没有恐慌时,或者如果提供给panic的参数是nil,recover就会返回nil。因此,recover的返回值会报告goroutine是否正在恐慌。</target>
        </trans-unit>
        <trans-unit id="ff14ed6c9720c452a0294998e96d92039ec86474" translate="yes" xml:space="preserve">
          <source>The regexp implementation provided by this package is guaranteed to run in time linear in the size of the input. (This is a property not guaranteed by most open source implementations of regular expressions.) For more information about this property, see</source>
          <target state="translated">本包提供的regexp实现保证在时间上以输入的大小线性运行。(这是大多数正则表达式的开源实现所不能保证的属性。)关于这个属性的更多信息,请参见</target>
        </trans-unit>
        <trans-unit id="e4c94cab05a4e2263ef4f912bc17e254d9de85c1" translate="yes" xml:space="preserve">
          <source>The regionType is used to classify regions, so there should be only a handful of unique region types.</source>
          <target state="translated">regionType用于对区域进行分类,所以应该只有少数独特的区域类型。</target>
        </trans-unit>
        <trans-unit id="613161bf225c19a5f2c8859dc32ad7cbf64fe341" translate="yes" xml:space="preserve">
          <source>The regular expression syntax understood by this package when parsing with the Perl flag is as follows. Parts of the syntax can be disabled by passing alternate flags to Parse.</source>
          <target state="translated">当使用Perl标志进行解析时,本包所理解的正则表达式语法如下。可以通过向 Parse 传递备用标志来禁用部分语法。</target>
        </trans-unit>
        <trans-unit id="414d3f9a62c65f403de754cbbecda8b294ef6a05" translate="yes" xml:space="preserve">
          <source>The remaining patterns enumerate the only valid conversions from uintptr to Pointer.</source>
          <target state="translated">剩下的模式列举了唯一有效的从uintptr到Pointer的转换。</target>
        </trans-unit>
        <trans-unit id="f01d454f6a8093b81d93ec48391c3d15861fea72" translate="yes" xml:space="preserve">
          <source>The remaining signals are asynchronous signals. They are not triggered by program errors, but are instead sent from the kernel or from some other program.</source>
          <target state="translated">其余的信号是异步信号,它们不是由程序错误触发的,而是由内核或其他程序发送的。它们不是由程序错误触发的,而是由内核或其他程序发送的。</target>
        </trans-unit>
        <trans-unit id="b6f243f72fd3fe537acd4a5fca41b95e81ce45b9" translate="yes" xml:space="preserve">
          <source>The representation of types is described below. When a type is defined on a given connection between an Encoder and Decoder, it is assigned a signed integer type id. When Encoder.Encode(v) is called, it makes sure there is an id assigned for the type of v and all its elements and then it sends the pair (typeid, encoded-v) where typeid is the type id of the encoded type of v and encoded-v is the gob encoding of the value v.</source>
          <target state="translated">类型的表示方法如下所述。当一个类型被定义在给定的编码器和解码器之间的连接上时,它会被分配一个有符号的整数类型id。当Encoder.Encode(v)被调用时,它确保为v的类型和它的所有元素分配了一个id,然后它发送一对(typeid,encoded-v),其中typeid是v的编码类型的类型id,encoded-v是值v的gob编码。</target>
        </trans-unit>
        <trans-unit id="cd667628565a5086d3e9895b56322424dc5621cd" translate="yes" xml:space="preserve">
          <source>The request Body, if non-nil, will be closed by the underlying Transport, even on errors.</source>
          <target state="translated">如果请求主体为非零,则会被底层传输关闭,即使出现错误。</target>
        </trans-unit>
        <trans-unit id="d4e026c3f59ca2f49146d499574e033e155a3b79" translate="yes" xml:space="preserve">
          <source>The resolver decision can be overridden by setting the netdns value of the GODEBUG environment variable (see package runtime) to go or cgo, as in:</source>
          <target state="translated">可以通过将GODEBUG环境变量(见包运行时)的netdns值设置为go或cgo来覆盖解析器的决定,如。</target>
        </trans-unit>
        <trans-unit id="85ba008f9a41b800d285074394b704f73cc09894" translate="yes" xml:space="preserve">
          <source>The rest of this package comment may be skipped on first reading; it includes details necessary to understand escaping contexts and error messages. Most users will not need to understand these details.</source>
          <target state="translated">这个包评论的其余部分可以在第一次阅读时跳过;它包含了理解转义上下文和错误信息所必需的细节。大多数用户不需要了解这些细节。</target>
        </trans-unit>
        <trans-unit id="5f29380aa9a229b911cfb4cbcef02c25951562ac" translate="yes" xml:space="preserve">
          <source>The rest of this section gives the precise details of how operations use monotonic clocks, but understanding those details is not required to use this package.</source>
          <target state="translated">本节其余部分给出了操作如何使用单调时钟的精确细节,但了解这些细节并不是使用这个包的必要条件。</target>
        </trans-unit>
        <trans-unit id="b7f11101676a7b7c4f383ade5d8d3f82131c1b53" translate="yes" xml:space="preserve">
          <source>The result of Scan is one of these tokens or a Unicode character.</source>
          <target state="translated">扫描的结果是这些标记中的一个或一个Unicode字符。</target>
        </trans-unit>
        <trans-unit id="4646462be207e1c8f655d521c7883b8db5be5339" translate="yes" xml:space="preserve">
          <source>The results of a benchmark run.</source>
          <target state="translated">基准运行的结果。</target>
        </trans-unit>
        <trans-unit id="6be7e87ff9924a05b7bc2a7006d807f1fab39e3d" translate="yes" xml:space="preserve">
          <source>The returned *Float f is nil and the value of z is valid but not defined if an error is reported.</source>
          <target state="translated">返回的*Float f为nil,z的值是有效的,但如果报错,则没有定义。</target>
        </trans-unit>
        <trans-unit id="bac86830681be1d31b72f9f7791b1c44ac2452e7" translate="yes" xml:space="preserve">
          <source>The returned Cmd's Args field is constructed from the command name followed by the elements of arg, so arg should not include the command name itself. For example, Command(&quot;echo&quot;, &quot;hello&quot;). Args[0] is always name, not the possibly resolved Path.</source>
          <target state="translated">返回的Cmd的Args字段是由命令名后面的arg元素构造的,所以arg不应该包括命令名本身。例如,Command(&quot;echo&quot;,&quot;hello&quot;)。Args[0]总是name,而不是可能解析的Path。</target>
        </trans-unit>
        <trans-unit id="3bc6a14f8ce0d88107543f9f02901b96c67b460c" translate="yes" xml:space="preserve">
          <source>The returned DB is safe for concurrent use by multiple goroutines and maintains its own pool of idle connections. Thus, the Open function should be called just once. It is rarely necessary to close a DB.</source>
          <target state="translated">返回的DB可以安全地被多个goroutine并发使用,并维护自己的空闲连接池。因此,Open函数应该只被调用一次。很少需要关闭一个DB。</target>
        </trans-unit>
        <trans-unit id="c94572c3b7d816968d78d57402944f7efb4246e7" translate="yes" xml:space="preserve">
          <source>The returned DB is safe for concurrent use by multiple goroutines and maintains its own pool of idle connections. Thus, the OpenDB function should be called just once. It is rarely necessary to close a DB.</source>
          <target state="translated">返回的DB对于多个goroutine并发使用是安全的,并且维护自己的空闲连接池。因此,OpenDB函数应该只被调用一次。很少需要关闭一个DB。</target>
        </trans-unit>
        <trans-unit id="33f1666e076b57e7a3379acacb81a7ec24e7d31d" translate="yes" xml:space="preserve">
          <source>The returned RawConn only supports calling Control. Read and Write return an error.</source>
          <target state="translated">返回的RawConn只支持调用Control。读和写都会返回一个错误。</target>
        </trans-unit>
        <trans-unit id="00382818b7b561dcf8c2e41afc3acbf78809ee7a" translate="yes" xml:space="preserve">
          <source>The returned Response will have at least its StatusCode, Header, Body, and optionally Trailer populated. More fields may be populated in the future, so callers should not DeepEqual the result in tests.</source>
          <target state="translated">返回的Response将至少填充其StatusCode、Header、Body和可选的Trailer。未来可能会有更多的字段被填充,所以调用者不应该在测试中对结果进行DeepEqual。</target>
        </trans-unit>
        <trans-unit id="f4f37717fc57244b8b099472fa87f281f196d58d" translate="yes" xml:space="preserve">
          <source>The returned context is always non-nil; it defaults to the background context.</source>
          <target state="translated">返回的上下文总是非零,它默认为背景上下文。</target>
        </trans-unit>
        <trans-unit id="9cbe06fbabaade2695a345469e46bbf5011eaae5" translate="yes" xml:space="preserve">
          <source>The returned end function is used to mark the task's end. The trace tool measures task latency as the time between task creation and when the end function is called, and provides the latency distribution per task type. If the end function is called multiple times, only the first call is used in the latency measurement.</source>
          <target state="translated">返回的结束函数用于标记任务的结束。跟踪工具将任务延迟测量为从任务创建到调用结束函数之间的时间,并提供每个任务类型的延迟分布。如果结束函数被多次调用,则延迟测量中只使用第一次调用。</target>
        </trans-unit>
        <trans-unit id="f0a8feeaa4dbaf36e773a52f49c0b0ac6bb7e74a" translate="yes" xml:space="preserve">
          <source>The returned error is nil if the command runs, has no problems copying stdin, stdout, and stderr, and exits with a zero exit status.</source>
          <target state="translated">如果命令运行,复制stdin、stdout和stderr没有问题,并且退出状态为零,则返回的错误为nil。</target>
        </trans-unit>
        <trans-unit id="4d6b3f09dc97620be2a232fb3dc17468c15d1426" translate="yes" xml:space="preserve">
          <source>The returned list does not identify the associated interface; use Interfaces and Interface.Addrs for more detail.</source>
          <target state="translated">返回的列表并不能识别相关的接口;使用Interfaces和Interface.Addrs了解更多细节。</target>
        </trans-unit>
        <trans-unit id="c6a6b1723d6bc4ac24e64af0ce75d94122db9245" translate="yes" xml:space="preserve">
          <source>The returned memory allocator statistics are up to date as of the call to ReadMemStats. This is in contrast with a heap profile, which is a snapshot as of the most recently completed garbage collection cycle.</source>
          <target state="translated">返回的内存分配器统计数据在调用ReadMemStats时是最新的。这与堆配置文件不同,堆配置文件是最近完成的垃圾收集周期的快照。</target>
        </trans-unit>
        <trans-unit id="a6ee6f83dacc73003b6dade23a5eca55ab60b66f" translate="yes" xml:space="preserve">
          <source>The returned os.File's file descriptor is different from the connection's. Attempting to change properties of the original using this duplicate may or may not have the desired effect.</source>
          <target state="translated">返回的 os.File 的文件描述符与连接的不同。试图使用这个副本来改变原始文件的属性,可能会或可能不会达到预期的效果。</target>
        </trans-unit>
        <trans-unit id="5927f2050b65cd29032e207117c8b2d6ca472e54" translate="yes" xml:space="preserve">
          <source>The returned path ends in a slash only if it is the root &quot;/&quot;.</source>
          <target state="translated">只有当路径是根目录&quot;/&quot;时,返回的路径才以斜线结束。</target>
        </trans-unit>
        <trans-unit id="004ac519a1c16ea761d189382ea9cc0c1b68b7d1" translate="yes" xml:space="preserve">
          <source>The returned path ends in a slash only if it represents a root directory, such as &quot;/&quot; on Unix or `C:\` on Windows.</source>
          <target state="translated">返回的路径只有在代表根目录的情况下才以斜线结尾,比如Unix上的&quot;/&quot;或Windows上的`C:\`。</target>
        </trans-unit>
        <trans-unit id="709611ccac6cb61ed7ee0c2fc8499ed7e268fed4" translate="yes" xml:space="preserve">
          <source>The returned profile may be up to two garbage collection cycles old. This is to avoid skewing the profile toward allocations; because allocations happen in real time but frees are delayed until the garbage collector performs sweeping, the profile only accounts for allocations that have had a chance to be freed by the garbage collector.</source>
          <target state="translated">返回的配置文件可能是两个垃圾收集周期前的。这是为了避免配置文件偏向于分配;因为分配是实时发生的,但释放是延迟的,直到垃圾收集器执行扫除,所以配置文件只记录有机会被垃圾收集器释放的分配。</target>
        </trans-unit>
        <trans-unit id="2fcbc7cecfbd88a968cff813905d726fdf40b131" translate="yes" xml:space="preserve">
          <source>The returned slice is the certificate in DER encoding.</source>
          <target state="translated">返回的分片是DER编码的证书。</target>
        </trans-unit>
        <trans-unit id="01c758564c188da314abf0218bd7cfbe2c752f80" translate="yes" xml:space="preserve">
          <source>The returned slice is the certificate request in DER encoding.</source>
          <target state="translated">返回的分片是DER编码的证书请求。</target>
        </trans-unit>
        <trans-unit id="56ef9da288a159e17f780d686422f0dfcfa221a7" translate="yes" xml:space="preserve">
          <source>The returned statement operates within the transaction and can no longer be used once the transaction has been committed or rolled back.</source>
          <target state="translated">返回的语句在事务中操作,一旦事务被提交或回滚,就不能再使用。</target>
        </trans-unit>
        <trans-unit id="eaef2ac25b5ec95632c077f9297b6bf55f5dd3f6" translate="yes" xml:space="preserve">
          <source>The returned statement operates within the transaction and will be closed when the transaction has been committed or rolled back.</source>
          <target state="translated">被退回的报表在交易内操作,当交易被承诺或回滚时,将被关闭。</target>
        </trans-unit>
        <trans-unit id="10df7eea472cec1ead17a66cb1fdaefe2e6578cc" translate="yes" xml:space="preserve">
          <source>The returned string is meant for debugging; for a stable serialized representation, use t.MarshalText, t.MarshalBinary, or t.Format with an explicit format string.</source>
          <target state="translated">返回的字符串是用来调试的;要想获得稳定的序列化表示,请使用t.MarshalText、t.MarshalBinary或t.Format,并使用明确的格式字符串。</target>
        </trans-unit>
        <trans-unit id="48866f9aa69c2bb04dcb85d20c5a3c1d2d405ca8" translate="yes" xml:space="preserve">
          <source>The rule Title uses for word boundaries does not handle Unicode punctuation properly.</source>
          <target state="translated">Title使用的单词边界规则不能正确处理Unicode标点符号。</target>
        </trans-unit>
        <trans-unit id="f80f01b0edf7103d5ecb8ca06eb4e22919710f70" translate="yes" xml:space="preserve">
          <source>The same Context may be passed to functions running in different goroutines; Contexts are safe for simultaneous use by multiple goroutines.</source>
          <target state="translated">同一上下文可以传递给在不同的goroutine中运行的函数;上下文对于多个goroutine同时使用是安全的。</target>
        </trans-unit>
        <trans-unit id="a401c4efb67cc0055f52caa84dcf2de0d8f63cd7" translate="yes" xml:space="preserve">
          <source>The second argument, quote, specifies the type of literal being parsed and therefore which escaped quote character is permitted. If set to a single quote, it permits the sequence \' and disallows unescaped '. If set to a double quote, it permits \&quot; and disallows unescaped &quot;. If set to zero, it does not permit either escape and allows both quote characters to appear unescaped.</source>
          <target state="translated">第二个参数quote指定了被解析的文字类型,因此允许使用哪种转义引号字符。如果设置为单引号,它允许使用序列&quot;/&quot;,而不允许使用未转义的&quot;&quot;。如果设置为双引号,则允许使用&quot;/&quot;,不允许使用未封顶的&quot;&quot;。如果设置为零,则不允许任何一个转义字符,允许两个引号字符都不封顶。</target>
        </trans-unit>
        <trans-unit id="40a1d3ecbed0bf217ec97ece1c42e914315bd313" translate="yes" xml:space="preserve">
          <source>The security model used by this package assumes that template authors are trusted, while Execute's data parameter is not. More details are provided below.</source>
          <target state="translated">本包使用的安全模型假设模板作者是可信的,而Execute的数据参数是不可信的。下面提供更多细节。</target>
        </trans-unit>
        <trans-unit id="a70cb84ae80d93013971dc3c09e0dd11fbe3a660" translate="yes" xml:space="preserve">
          <source>The server calls (for HTTP service):</source>
          <target state="translated">服务器调用(用于HTTP服务)。</target>
        </trans-unit>
        <trans-unit id="4694acea63f5ebf8b8be35e4e84982505cd7d21a" translate="yes" xml:space="preserve">
          <source>The server may handle requests on a single connection by calling ServeConn. More typically it will create a network listener and call Accept or, for an HTTP listener, HandleHTTP and http.Serve.</source>
          <target state="translated">服务器可以通过调用ServeConn来处理单个连接上的请求,更典型的是它会创建网络监听器并调用Accept,或者对于HTTP监听器,调用HandleHTTP和http.Serve。更典型的是,它将创建一个网络监听器并调用Accept,或者对于一个HTTP监听器,调用HandleHTTP和http.Serve。</target>
        </trans-unit>
        <trans-unit id="901fd3527b931189389dc8b05aa80a401b308de0" translate="yes" xml:space="preserve">
          <source>The set of available CPUs is checked by querying the operating system at process startup. Changes to operating system CPU allocation after process startup are not reflected.</source>
          <target state="translated">在进程启动时通过查询操作系统来检查可用CPU的集合。进程启动后操作系统CPU分配的变化不会被反映出来。</target>
        </trans-unit>
        <trans-unit id="10e3cd17c3685da24fcde871ef4da00a080771a9" translate="yes" xml:space="preserve">
          <source>The signals SIGKILL and SIGSTOP may not be caught by a program, and therefore cannot be affected by this package.</source>
          <target state="translated">信号SIGKILL和SIGSTOP可能不会被程序捕获,因此不会受到这个软件包的影响。</target>
        </trans-unit>
        <trans-unit id="7621705ac03f21ac222836c967959708135562eb" translate="yes" xml:space="preserve">
          <source>The simplest use of a Scanner, to read standard input as a set of lines.</source>
          <target state="translated">扫描仪最简单的用法,就是将标准输入作为一组行来读取。</target>
        </trans-unit>
        <trans-unit id="9c0657904725889b0c9ba75534abc4f635bc0b2b" translate="yes" xml:space="preserve">
          <source>The size of a CRC-32 checksum in bytes.</source>
          <target state="translated">CRC-32校验和的大小,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="3ff608e7233df0580119a8a262ba634622895d8a" translate="yes" xml:space="preserve">
          <source>The size of a CRC-64 checksum in bytes.</source>
          <target state="translated">CRC-64校验和的大小,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="caae8e5aad6dbb0160181390b9818b080d122c80" translate="yes" xml:space="preserve">
          <source>The size of a SHA-1 checksum in bytes.</source>
          <target state="translated">SHA-1校验和的大小,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="cea16f97cc88534275f0e03f305d57951a36e34b" translate="yes" xml:space="preserve">
          <source>The size of a SHA224 checksum in bytes.</source>
          <target state="translated">SHA224校验和的大小,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="3a1556147bf25a0038243a962f16bc9d44b98e20" translate="yes" xml:space="preserve">
          <source>The size of a SHA256 checksum in bytes.</source>
          <target state="translated">SHA256校验和的大小,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="fb49c909a50ec86545c33e34c0f3d64148914e03" translate="yes" xml:space="preserve">
          <source>The size of an Adler-32 checksum in bytes.</source>
          <target state="translated">以字节为单位的Adler-32校验和的大小。</target>
        </trans-unit>
        <trans-unit id="edf1ef16cc66ffa121682ca1207ef5467651c4f4" translate="yes" xml:space="preserve">
          <source>The size of an MD5 checksum in bytes.</source>
          <target state="translated">MD5校验和的大小,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="248e03e24b52c36053fea2b5fabdbb42fe255abb" translate="yes" xml:space="preserve">
          <source>The skip parameter has the same meaning as runtime.Caller's skip and controls where the stack trace begins. Passing skip=0 begins the trace in the function calling Add. For example, given this execution stack:</source>
          <target state="translated">skip参数与runtime.Caller的skip意义相同,控制堆栈跟踪的开始位置。传递 skip=0,则在调用 Add 的函数中开始跟踪。例如,给定这个执行栈。</target>
        </trans-unit>
        <trans-unit id="b675e8a3e2a529e23f6f667c1adf36c39ed93efb" translate="yes" xml:space="preserve">
          <source>The slice returned by this method consists of all the substrings of s not contained in the slice returned by FindAllString. When called on an expression that contains no metacharacters, it is equivalent to strings.SplitN.</source>
          <target state="translated">本方法返回的分片由FindAllString返回的分片中未包含的s的所有子串组成。当调用一个不包含元字符的表达式时,它相当于strings.SplitN。</target>
        </trans-unit>
        <trans-unit id="37fc7946d5ac5fa1638ca298818fb97686f9142e" translate="yes" xml:space="preserve">
          <source>The smtp package is frozen and is not accepting new features. Some external packages provide more functionality. See:</source>
          <target state="translated">smtp包被冻结,不接受新功能。一些外部软件包提供了更多的功能。请看:</target>
        </trans-unit>
        <trans-unit id="37671db71f74ceff10a366ff8f17e7a0a28fae66" translate="yes" xml:space="preserve">
          <source>The sort is not guaranteed to be stable. For a stable sort, use SliceStable.</source>
          <target state="translated">不保证排序的稳定性。对于稳定的排序,请使用 SliceStable。</target>
        </trans-unit>
        <trans-unit id="17c5e77086e67a3f2c51a48bac9596dffc360456" translate="yes" xml:space="preserve">
          <source>The source and destination values/types need not correspond exactly. For structs, fields (identified by name) that are in the source but absent from the receiving variable will be ignored. Fields that are in the receiving variable but missing from the transmitted type or value will be ignored in the destination. If a field with the same name is present in both, their types must be compatible. Both the receiver and transmitter will do all necessary indirection and dereferencing to convert between gobs and actual Go values. For instance, a gob type that is schematically,</source>
          <target state="translated">源和目标值/类型不需要完全对应。对于结构,源变量中的字段(用名称标识),但接收变量中没有的字段将被忽略。对于结构体来说,源变量中的字段(用名字标识)在接收变量中,但在接收变量中不存在的字段将被忽略;在目标变量中,在接收变量中但在传输的类型或值中缺失的字段将被忽略。如果一个名字相同的字段出现在两个变量中,它们的类型必须是兼容的。接收器和发送器都会做所有必要的内推和去引用,以便在gob和实际的围棋值之间进行转换。例如,一个gob类型在原理上是:</target>
        </trans-unit>
        <trans-unit id="0268779129500cf4856c5f56fd67106abaf097eb" translate="yes" xml:space="preserve">
          <source>The source code could include additional Go code. That code was never compiled but would be processed by tools like godoc and might be useful as end-user documentation.</source>
          <target state="translated">源代码可以包括额外的Go代码。这些代码从未被编译过,但会被像godoc这样的工具处理,并可能作为终端用户的文档。</target>
        </trans-unit>
        <trans-unit id="535d0edaef1db8d5c1dc136b1a303868255bb996" translate="yes" xml:space="preserve">
          <source>The source:</source>
          <target state="translated">来源:</target>
        </trans-unit>
        <trans-unit id="e645e5bfb164f126d92a3414aa1a585176c8e465" translate="yes" xml:space="preserve">
          <source>The sql package checks for value checkers in the following order, stopping at the first found match: Stmt.NamedValueChecker, Conn.NamedValueChecker, Stmt.ColumnConverter, DefaultParameterConverter.</source>
          <target state="translated">sql包按照以下顺序检查值检查器,在第一个发现的匹配处停止。Stmt.NamedValueChecker,Conn.NamedValueChecker,Stmt.ColumnConverter,DefaultParameterConverter.</target>
        </trans-unit>
        <trans-unit id="bf35db5d84a5c59679d57c2063978bf2973a302c" translate="yes" xml:space="preserve">
          <source>The sql package creates and frees connections automatically; it also maintains a free pool of idle connections. If the database has a concept of per-connection state, such state can be reliably observed within a transaction (Tx) or connection (Conn). Once DB.Begin is called, the returned Tx is bound to a single connection. Once Commit or Rollback is called on the transaction, that transaction's connection is returned to DB's idle connection pool. The pool size can be controlled with SetMaxIdleConns.</source>
          <target state="translated">sql包会自动创建和释放连接;它还会维护一个空闲的连接池。如果数据库有每个连接状态的概念,那么这种状态可以在一个事务(Tx)或连接(Conn)中可靠地观察到。一旦DB.Begin被调用,返回的Tx就会被绑定到单个连接上。一旦在事务上调用Commit或Rollback,该事务的连接就会返回到DB的空闲连接池中。池的大小可以通过SetMaxIdleConns来控制。</target>
        </trans-unit>
        <trans-unit id="14c50009f306ef9ba308a3f9f45cb12ceab6e041" translate="yes" xml:space="preserve">
          <source>The sql package must be used in conjunction with a database driver. See &lt;a href=&quot;https://golang.org/s/sqldrivers&quot;&gt;https://golang.org/s/sqldrivers&lt;/a&gt; for a list of drivers.</source>
          <target state="translated">sql程序包必须与数据库驱动程序一起使用。有关驱动程序列表，请参见&lt;a href=&quot;https://golang.org/s/sqldrivers&quot;&gt;https://golang.org/s/sqldrivers&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ff11c76849e5520b5d3c1908876a0a08249bbd90" translate="yes" xml:space="preserve">
          <source>The src/ directory holds source code. The path below 'src' determines the import path or executable name.</source>
          <target state="translated">src/目录下存放的是源代码。src &quot;下面的路径决定了导入路径或可执行文件的名称。</target>
        </trans-unit>
        <trans-unit id="51fce287253a04b9aa4e50fe0cda26970eb0eeca" translate="yes" xml:space="preserve">
          <source>The statements prepared for a transaction by calling the transaction's Prepare or Stmt methods are closed by the call to Commit or Rollback.</source>
          <target state="translated">通过调用事务的Prepare或Stmt方法为事务准备的语句,通过调用Commit或Rollback关闭。</target>
        </trans-unit>
        <trans-unit id="266ee83c3a485624a9ce3be711986c42904d65df" translate="yes" xml:space="preserve">
          <source>The swap operation, implemented by the SwapT functions, is the atomic equivalent of:</source>
          <target state="translated">由SwapT函数实现的交换操作,其原子等价物为:。</target>
        </trans-unit>
        <trans-unit id="78109ee602f829fc62630aa0958e0668bde1d9d0" translate="yes" xml:space="preserve">
          <source>The symbolizer function may be nil, in which case the results of the traceback function will be displayed as numbers. If the traceback function is nil, the symbolizer function will never be called. The context function may be nil, in which case the traceback function will only be called with the context field set to zero. If the context function is nil, then calls from Go to C to Go will not show a traceback for the C portion of the call stack.</source>
          <target state="translated">符号化函数可能为零,在这种情况下,回溯函数的结果将显示为数字。如果回溯函数为零,符号函数将永远不会被调用。上下文函数可能为零,在这种情况下,只有当上下文字段设置为零时,才会调用回溯函数。如果上下文函数为nil,那么从Go到C到Go的调用将不会显示调用栈中C部分的回溯。</target>
        </trans-unit>
        <trans-unit id="7f3f65f4777096791e56d64b25eeec76abb44bfa" translate="yes" xml:space="preserve">
          <source>The symbolizer function will be called with a single argument, a pointer to a struct:</source>
          <target state="translated">符号化函数将被调用,只有一个参数,即一个指向结构体的指针。</target>
        </trans-unit>
        <trans-unit id="826b161e82b6e953fc66964167887f9fb128e89d" translate="yes" xml:space="preserve">
          <source>The syntax of such definitions is to surround each template declaration with a &quot;define&quot; and &quot;end&quot; action.</source>
          <target state="translated">这种定义的语法是在每个模板声明的周围加上一个 &quot;定义 &quot;和 &quot;结束 &quot;的动作。</target>
        </trans-unit>
        <trans-unit id="a896d242a72cd56df044b310d3d7e48636436044" translate="yes" xml:space="preserve">
          <source>The syntax of the regular expressions accepted is the same general syntax used by Perl, Python, and other languages. More precisely, it is the syntax accepted by RE2 and described at &lt;a href=&quot;https://golang.org/s/re2syntax&quot;&gt;https://golang.org/s/re2syntax&lt;/a&gt;, except for \C. For an overview of the syntax, run</source>
          <target state="translated">接受的正则表达式的语法与Perl，Python和其他语言使用的常规语法相同。更准确地说，它是RE2接受的语法，并在&lt;a href=&quot;https://golang.org/s/re2syntax&quot;&gt;https://golang.org/s/re2syntax中进行了&lt;/a&gt;描述，除了\ C。有关语法的概述，请运行</target>
        </trans-unit>
        <trans-unit id="ba2393e2ef8002ea106da87efa718a59742fc7ac" translate="yes" xml:space="preserve">
          <source>The syslog package is frozen and is not accepting new features. Some external packages provide more functionality. See:</source>
          <target state="translated">syslog包被冻结,不接受新功能。一些外部软件包提供了更多的功能。请看:</target>
        </trans-unit>
        <trans-unit id="99e701177eab165c110f7e05395c5e3f3462fc8b" translate="yes" xml:space="preserve">
          <source>The table's lower portion shows specialized features of each format, such as supported string encodings, support for sub-second timestamps, or support for sparse files.</source>
          <target state="translated">该表的下半部分显示了每种格式的特殊功能,如支持的字符串编码、对亚秒级时间戳的支持或对稀疏文件的支持。</target>
        </trans-unit>
        <trans-unit id="e6cfcc2895da4e068fb4279dd7ba0aaf57b5ca4f" translate="yes" xml:space="preserve">
          <source>The table's upper portion shows the Header fields, where each format reports the maximum number of bytes allowed for each string field and the integer type used to store each numeric field (where timestamps are stored as the number of seconds since the Unix epoch).</source>
          <target state="translated">该表的上半部分显示了Header字段,其中每种格式都报告了每个字符串字段允许的最大字节数,以及用于存储每个数字字段的整数类型(其中时间戳被存储为Unix纪元以来的秒数)。</target>
        </trans-unit>
        <trans-unit id="b0a984b621ec68366c5b1261f609a8ab7bb45ea3" translate="yes" xml:space="preserve">
          <source>The tag must be one that takes string values: DT_NEEDED, DT_SONAME, DT_RPATH, or DT_RUNPATH.</source>
          <target state="translated">该标签必须是接受字符串值的标签。DT_NEEDED、DT_SONAME、DT_RPATH或DT_RUNPATH。</target>
        </trans-unit>
        <trans-unit id="cbe588a5ff1a44ccc9c3b05cfac0b378253441ae" translate="yes" xml:space="preserve">
          <source>The target is the RFC 7230 &quot;request-target&quot;: it may be either a path or an absolute URL. If target is an absolute URL, the host name from the URL is used. Otherwise, &quot;example.com&quot; is used.</source>
          <target state="translated">target是RFC 7230 &quot;request-target&quot;:它可以是一个路径,也可以是一个绝对URL。如果目标是绝对URL,则使用URL中的主机名。否则,使用 &quot;example.com&quot;。</target>
        </trans-unit>
        <trans-unit id="a6f845f916ddb97993362899697ada283b05c4e3" translate="yes" xml:space="preserve">
          <source>The taskType is used to classify task instances. Analysis tools like the Go execution tracer may assume there are only a bounded number of unique task types in the system.</source>
          <target state="translated">taskType用于对任务实例进行分类。像围棋执行跟踪器这样的分析工具可能会假设系统中只有一定数量的唯一任务类型。</target>
        </trans-unit>
        <trans-unit id="87c98cdec407269913a37379692f0119d00836f4" translate="yes" xml:space="preserve">
          <source>The template</source>
          <target state="translated">模板</target>
        </trans-unit>
        <trans-unit id="8dbf1659d9b474dfc6de39448622e749ace9eba6" translate="yes" xml:space="preserve">
          <source>The testing/quick package is frozen and is not accepting new features.</source>
          <target state="translated">测试/快速包被冻结,不接受新功能。</target>
        </trans-unit>
        <trans-unit id="450bac070fc3c1d570ed998a1290dd681976d259" translate="yes" xml:space="preserve">
          <source>The text returned from ReadLine does not include the line end (&quot;\r\n&quot; or &quot;\n&quot;). No indication or error is given if the input ends without a final line end. Calling UnreadByte after ReadLine will always unread the last byte read (possibly a character belonging to the line end) even if that byte is not part of the line returned by ReadLine.</source>
          <target state="translated">ReadLine返回的文本不包括行尾(&quot;\r\n &quot;或&quot;\n&quot;)。如果输入结束时没有最后的行结束符,则不会给出任何指示或错误。在ReadLine之后调用UnreadByte将总是取消读取最后一个字节(可能是属于行尾的字符),即使该字节不是ReadLine返回的行的一部分。</target>
        </trans-unit>
        <trans-unit id="e19ad8a62ebb2f930cd2d412533e63ab163f9e7f" translate="yes" xml:space="preserve">
          <source>The text/tabwriter package is frozen and is not accepting new features.</source>
          <target state="translated">text/tabwriter包被冻结,不接受新功能。</target>
        </trans-unit>
        <trans-unit id="b8b4c6c4010154e59471f9dc5acececde45e4c79" translate="yes" xml:space="preserve">
          <source>The time zone database needed by LoadLocation may not be present on all systems, especially non-Unix systems. LoadLocation looks in the directory or uncompressed zip file named by the ZONEINFO environment variable, if any, then looks in known installation locations on Unix systems, and finally looks in $GOROOT/lib/time/zoneinfo.zip.</source>
          <target state="translated">LoadLocation 所需的时区数据库可能并不是在所有系统上都存在,尤其是非 Unix 系统。LoadLocation会在ZONEINFO环境变量命名的目录或未压缩的zip文件中查找(如果有的话),然后在Unix系统中查找已知的安装位置,最后在$GOROOT/lib/time/zoneinfo.zip中查找。</target>
        </trans-unit>
        <trans-unit id="d9d95ea8fa35077316d58a8c096d78c878d9e8de" translate="yes" xml:space="preserve">
          <source>The timeout includes name resolution, if required. When using TCP, and the host in the address parameter resolves to multiple IP addresses, the timeout is spread over each consecutive dial, such that each is given an appropriate fraction of the time to connect.</source>
          <target state="translated">如果需要,超时时间包括名称解析。当使用TCP,并且地址参数中的主机解析到多个IP地址时,超时时间将分摊到每一个连续的拨号中,这样每个拨号都有适当的部分时间来连接。</target>
        </trans-unit>
        <trans-unit id="1be65b230e905dbffd21fbadb56320938e08062d" translate="yes" xml:space="preserve">
          <source>The tools that process the memory profiles assume that the profile rate is constant across the lifetime of the program and equal to the current value. Programs that change the memory profiling rate should do so just once, as early as possible in the execution of the program (for example, at the beginning of main).</source>
          <target state="translated">处理内存剖面的工具假设剖面率在程序的整个生命周期内是恒定的,并且等于当前的值。程序如果要改变内存剖面率,应该只改变一次,在程序执行的早期(例如,在main开始时)。</target>
        </trans-unit>
        <trans-unit id="1a177d1df849e44bddcb9ba4d4be3d9812f21f16" translate="yes" xml:space="preserve">
          <source>The trace tool computes the latency of a task by measuring the time between the task creation and the task end and provides latency distributions for each task type found in the trace.</source>
          <target state="translated">跟踪工具通过测量任务创建和任务结束之间的时间来计算任务的延迟,并为跟踪中发现的每种任务类型提供延迟分布。</target>
        </trans-unit>
        <trans-unit id="62d0bac03a171fb89c5dd19570b301f5442565f7" translate="yes" xml:space="preserve">
          <source>The traceback and context functions may be called from a signal handler, and must therefore use only async-signal safe functions. The symbolizer function may be called while the program is crashing, and so must be cautious about using memory. None of the functions may call back into Go.</source>
          <target state="translated">追溯函数和上下文函数可能会被信号处理程序调用,因此必须只使用异步信号安全函数。符号化函数可能在程序崩溃时被调用,因此必须谨慎使用内存。这些函数都不可以调用回Go。</target>
        </trans-unit>
        <trans-unit id="64b5d618701b94606e91495371f70fb5b100120e" translate="yes" xml:space="preserve">
          <source>The traceback function will be called with a single argument, a pointer to a struct:</source>
          <target state="translated">回溯函数将被调用,只有一个参数,即指向结构体的指针。</target>
        </trans-unit>
        <trans-unit id="fbcd1af40286bdefbe9605ee1269e5d70a141d29" translate="yes" xml:space="preserve">
          <source>The two methods Network and String conventionally return strings that can be passed as the arguments to Dial, but the exact form and meaning of the strings is up to the implementation.</source>
          <target state="translated">Network和String这两个方法约定俗成地返回可以作为参数传递给Dial的字符串,但字符串的具体形式和含义由实现者决定。</target>
        </trans-unit>
        <trans-unit id="ee1fff48d57b4264c60df5732fa6d287858ca513" translate="yes" xml:space="preserve">
          <source>The typ argument may be a defined (Named) type or an alias type. It may also be nil such that the returned TypeName can be used as argument for NewNamed, which will set the TypeName's type as a side- effect.</source>
          <target state="translated">typ参数可以是一个定义的(Named)类型或一个别名类型。它也可以是nil,这样返回的TypeName可以作为NewNamed的参数,NewNamed将设置TypeName的类型作为副作用。</target>
        </trans-unit>
        <trans-unit id="761242af94989502320341408ab25169d28b2151" translate="yes" xml:space="preserve">
          <source>The typical use case for NewFileTransport is to register the &quot;file&quot; protocol with a Transport, as in:</source>
          <target state="translated">NewFileTransport的典型用例是将 &quot;文件 &quot;协议注册到一个Transport中,如。</target>
        </trans-unit>
        <trans-unit id="c9dec8fd9ff2613dd03956d5301652519fcaec0c" translate="yes" xml:space="preserve">
          <source>The underlying filesystem may truncate or round the values to a less precise time unit. If there is an error, it will be of type *PathError.</source>
          <target state="translated">底层文件系统可能会截断或四舍五入这些值,使其成为一个不太精确的时间单位。如果有错误,它的类型将是*PathError。</target>
        </trans-unit>
        <trans-unit id="bc08db1aae610f1545a452a1bb5a7582597ab3b7" translate="yes" xml:space="preserve">
          <source>The usage message will appear on a separate line for anything but a bool flag with a one-byte name. For bool flags, the type is omitted and if the flag name is one byte the usage message appears on the same line. The parenthetical default is omitted if the default is the zero value for the type. The listed type, here int, can be changed by placing a back-quoted name in the flag's usage string; the first such item in the message is taken to be a parameter name to show in the message and the back quotes are stripped from the message when displayed. For instance, given</source>
          <target state="translated">除了一个名字为一个字节的布尔标志外,其他任何标志的使用信息都会出现在单独的一行上,对于布尔标志,类型会被省略,如果标志的名字是一个字节,则使用信息会出现在同一行上。对于bool标志,类型会被省略,如果标志名是一个字节,使用信息会出现在同一行。如果默认是类型的零值,则省略括号中的默认值。列举的类型,这里是int,可以通过在标志的用法字符串中放置一个反引号的名称来改变,消息中的第一个这样的项目被当作参数名称显示在消息中,显示时,反引号会从消息中剥离。例如,给定</target>
        </trans-unit>
        <trans-unit id="7175f6a7da0429173b6be919d1c9513e0498e3e7" translate="yes" xml:space="preserve">
          <source>The value 0xff was chosen because it cannot appear in a valid UTF-8 sequence.</source>
          <target state="translated">选择0xff是因为它不能出现在有效的UTF-8序列中。</target>
        </trans-unit>
        <trans-unit id="e4328a7e24cd2970818970fe425c0b1b3c86f9d7" translate="yes" xml:space="preserve">
          <source>The variadic argument controls whether the function is variadic. FuncOf panics if the in[len(in)-1] does not represent a slice and variadic is true.</source>
          <target state="translated">variadic参数控制函数是否为变量。如果in[len(in)-1]不代表一个片,并且variadic为真,FuncOf会恐慌。</target>
        </trans-unit>
        <trans-unit id="1e72c26ccaadcb98e76249dcd1c8f3cdb175e9de" translate="yes" xml:space="preserve">
          <source>The varint functions encode and decode single integer values using a variable-length encoding; smaller values require fewer bytes. For a specification, see &lt;a href=&quot;https://developers.google.com/protocol-buffers/docs/encoding&quot;&gt;https://developers.google.com/protocol-buffers/docs/encoding&lt;/a&gt;.</source>
          <target state="translated">varint函数使用可变长度编码对单个整数值进行编码和解码；较小的值需要较少的字节。有关规范，请参见&lt;a href=&quot;https://developers.google.com/protocol-buffers/docs/encoding&quot;&gt;https://developers.google.com/protocol-buffers/docs/encoding&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5cdb175715a8f3e26508e589b1b8622549f73fd8" translate="yes" xml:space="preserve">
          <source>The verbs behave analogously to those of Printf. For example, %x will scan an integer as a hexadecimal number, and %v will scan the default representation format for the value. The Printf verbs %p and %T and the flags # and + are not implemented. For floating-point and complex values, all valid formatting verbs (%b %e %E %f %F %g %G %x %X and %v) are equivalent and accept both decimal and hexadecimal notation (for example: &quot;2.3e+7&quot;, &quot;0x4.5p-8&quot;) and digit-separating underscores (for example: &quot;3.14159_26535_89793&quot;).</source>
          <target state="translated">这些动词的行为类似于Printf的行为。例如,%x将扫描一个整数作为十六进制数,而%v将扫描该值的默认表示格式。Printf动词%p和%T以及标志#和+没有实现。对于浮点和复数,所有有效的格式动词(%b %e %E %f %F %g %G %x %X和%v)都是等价的,并且接受十进制和十六进制符号(例如:&quot;2.3e+7&quot;,&quot;0x4.5p-8&quot;)和数字分隔的下划线(例如:&quot;3.14159_26535_89793&quot;)。</target>
        </trans-unit>
        <trans-unit id="a6ebe1343c13ca95e202e147b7f816ef1bc435a4" translate="yes" xml:space="preserve">
          <source>The verbs:</source>
          <target state="translated">的动词。</target>
        </trans-unit>
        <trans-unit id="3ce9ac6782ffe3c2b00e6a4b78b2ec7b810f1491" translate="yes" xml:space="preserve">
          <source>The writes of individual records are buffered. After all data has been written, the client should call the Flush method to guarantee all data has been forwarded to the underlying io.Writer. Any errors that occurred should be checked by calling the Error method.</source>
          <target state="translated">单个记录的写入是有缓冲的。在所有数据被写入后,客户端应该调用Flush方法,以保证所有数据都被转发到底层的io.Writer。发生的任何错误都应该通过调用Error方法进行检查。</target>
        </trans-unit>
        <trans-unit id="c7efdce3a929526f7cd0a0a9c837645401afe311" translate="yes" xml:space="preserve">
          <source>The zero (uninitialized) value for a Float is ready to use and represents the number +0.0 exactly, with precision 0 and rounding mode ToNearestEven.</source>
          <target state="translated">Float的零值(未初始化)可以使用了,准确表示数字+0.0,精度为0,取整模式为ToNearestEven。</target>
        </trans-unit>
        <trans-unit id="232f8c7f5eea097cc9451d2d90b51db6b069254d" translate="yes" xml:space="preserve">
          <source>The zero Map is empty and ready for use. A Map must not be copied after first use.</source>
          <target state="translated">零地图是空的,可以使用。一个地图在第一次使用后不得复制。</target>
        </trans-unit>
        <trans-unit id="ba5155e1e3916eee99a712d5244dcde8e9982094" translate="yes" xml:space="preserve">
          <source>The zero Value represents no value. Its IsValid method returns false, its Kind method returns Invalid, its String method returns &quot;&amp;lt;invalid Value&amp;gt;&quot;, and all other methods panic. Most functions and methods never return an invalid value. If one does, its documentation states the conditions explicitly.</source>
          <target state="translated">零值表示无值。它的IsValid方法返回false，其Kind方法返回Invalid，其String方法返回&amp;ldquo; &amp;lt;invalid Value&amp;gt;&amp;rdquo;，所有其他方法都出现紧急情况。大多数函数和方法从不返回无效值。如果是这样，则其文档会明确说明条件。</target>
        </trans-unit>
        <trans-unit id="384c750c13afaffcbd5ebf58e8afec2b8768e946" translate="yes" xml:space="preserve">
          <source>The zero value for Pos is NoPos; there is no file and line information associated with it, and NoPos.IsValid() is false. NoPos is always smaller than any other Pos value. The corresponding Position value for NoPos is the zero value for Position.</source>
          <target state="translated">Pos的零值是NoPos;没有与之相关的文件和行信息,NoPos.IsValid()是false。NoPos总是小于其他任何Pos值。NoPos对应的Position值就是Position的零值。</target>
        </trans-unit>
        <trans-unit id="3f5973e68195ed6a7dd12c4c7dc485f8bde0523d" translate="yes" xml:space="preserve">
          <source>The zero value for an Int, Rat, or Float correspond to 0. Thus, new values can be declared in the usual ways and denote 0 without further initialization:</source>
          <target state="translated">Int、Rat或Float的零值对应于0,因此,新的值可以用通常的方式声明,并表示0,而无需进一步初始化。</target>
        </trans-unit>
        <trans-unit id="5d5aa4f538fd1571e15874ad0969ae7c0fda3040" translate="yes" xml:space="preserve">
          <source>The zero value for each field is equivalent to dialing without that option. Dialing with the zero value of Dialer is therefore equivalent to just calling the Dial function.</source>
          <target state="translated">每个字段的零值相当于没有该选项的拨号。因此,用Dialer的零值拨号相当于只调用Dial函数。</target>
        </trans-unit>
        <trans-unit id="beb5a289f20083f1018df67115c647d61b968230" translate="yes" xml:space="preserve">
          <source>The zero value of type Time is January 1, year 1, 00:00:00.000000000 UTC. As this time is unlikely to come up in practice, the IsZero method gives a simple way of detecting a time that has not been initialized explicitly.</source>
          <target state="translated">Time类型的零值是1年1月1日,00:00:00.000000000 UTC。由于这个时间在实际中不太可能出现,IsZero方法给出了一个简单的方法来检测没有被显式初始化的时间。</target>
        </trans-unit>
        <trans-unit id="4752552a303f0f1e8a6bd4b3555705dcb31c63a8" translate="yes" xml:space="preserve">
          <source>Then it can make a remote call:</source>
          <target state="translated">然后就可以进行远程通话了。</target>
        </trans-unit>
        <trans-unit id="c5d500f53dcbe43654b22f15924d609c47bcfc3c" translate="yes" xml:space="preserve">
          <source>Then use the pprof tool to look at the heap profile:</source>
          <target state="translated">然后使用pprof工具查看堆配置文件。</target>
        </trans-unit>
        <trans-unit id="d249cadab1a19289ed9fd8f524a7048ff9efb13f" translate="yes" xml:space="preserve">
          <source>There are 16 methods of Regexp that match a regular expression and identify the matched text. Their names are matched by this regular expression:</source>
          <target state="translated">Regexp有16种方法可以匹配正则表达式并识别匹配的文本。它们的名称与这个正则表达式相匹配。</target>
        </trans-unit>
        <trans-unit id="089af1af9f031a6d4cb36f253f88e22a554b4d75" translate="yes" xml:space="preserve">
          <source>There are many commands available from the pprof command line. Commonly used commands include &quot;top&quot;, which prints a summary of the top program hot-spots, and &quot;web&quot;, which opens an interactive graph of hot-spots and their call graphs. Use &quot;help&quot; for information on all pprof commands.</source>
          <target state="translated">在pprof命令行中有很多命令可以使用,常用的命令有 &quot;top&quot;,它可以打印出最热门的程序热点汇总,&quot;web &quot;可以打开热点及其调用图的交互图。常用的命令包括 &quot;top&quot;,它可以打印顶级程序热点的摘要,以及 &quot;web&quot;,它可以打开热点的交互式图表和它们的调用图表。使用 &quot;help &quot;可以获得所有pprof命令的信息。</target>
        </trans-unit>
        <trans-unit id="6fa5b171535b7941feffabcf1c5f915fe3f02940" translate="yes" xml:space="preserve">
          <source>There are no build tags for beta or minor releases.</source>
          <target state="translated">测试版或次要版本没有构建标签。</target>
        </trans-unit>
        <trans-unit id="f4ebe0322e94e23eec9f295ca340080dec64dffd" translate="yes" xml:space="preserve">
          <source>There are three types of user annotations: log messages, regions, and tasks.</source>
          <target state="translated">用户注释有三种类型:日志消息、区域和任务。</target>
        </trans-unit>
        <trans-unit id="311b843be371a8c7fc9f6f81df2189e5f92e44e5" translate="yes" xml:space="preserve">
          <source>There is also a set of binary comparison operators defined as functions:</source>
          <target state="translated">还有一组定义为函数的二进制比较运算符。</target>
        </trans-unit>
        <trans-unit id="5f5077a9bb275171893d0be52e74cbffe4b19888" translate="yes" xml:space="preserve">
          <source>There is also a standard HTTP interface to profiling data. Adding the following line will install handlers under the /debug/pprof/ URL to download live profiles:</source>
          <target state="translated">还有一个标准的HTTP接口来剖析数据。添加以下一行将在/debug/pprof/URL下安装处理程序来下载实时配置文件。</target>
        </trans-unit>
        <trans-unit id="f5962f465f0b5c003c4585058fcce10ec6a63c36" translate="yes" xml:space="preserve">
          <source>There is also a standard HTTP interface to trace data. Adding the following line will install a handler under the /debug/pprof/trace URL to download a live trace:</source>
          <target state="translated">还有一个标准的HTTP接口来跟踪数据。添加以下一行将在/debug/pprof/trace URL下安装一个处理程序来下载实时跟踪数据。</target>
        </trans-unit>
        <trans-unit id="669c09ef6ba443f4e07a76e5e520b09339b0d7ba" translate="yes" xml:space="preserve">
          <source>There is also a subset of the methods that can be applied to text read from a RuneReader:</source>
          <target state="translated">还有一个方法的子集,可以应用于从RuneReader读取的文本。</target>
        </trans-unit>
        <trans-unit id="e5e187581cfc7675624afa1252d945d3159b9872" translate="yes" xml:space="preserve">
          <source>There is no mechanism for full case folding, that is, for characters that involve multiple runes in the input or output.</source>
          <target state="translated">对于输入或输出中涉及多个符文的字符,没有全宗折叠的机制。</target>
        </trans-unit>
        <trans-unit id="4e416754d4e74f38af1b48194c67cf3710f22527" translate="yes" xml:space="preserve">
          <source>These are predefined layouts for use in Time.Format and time.Parse. The reference time used in the layouts is the specific time:</source>
          <target state="translated">这些是预定义的布局,用于Time.Format和time.Parse。布局中使用的参考时间是具体时间。</target>
        </trans-unit>
        <trans-unit id="622b937b45492ef40cc6c554bb302fd36d24a9dd" translate="yes" xml:space="preserve">
          <source>These are the errors that can be returned in ParseError.Err.</source>
          <target state="translated">这些是可以在ParseError.Err中返回的错误。</target>
        </trans-unit>
        <trans-unit id="df2271a2f22e4450d78c23577801038a703976de" translate="yes" xml:space="preserve">
          <source>These assume decimal and the Go int type.</source>
          <target state="translated">这些假设是十进制和Go int类型。</target>
        </trans-unit>
        <trans-unit id="e44cf0ddaa746164e3256589314495380a8d22a3" translate="yes" xml:space="preserve">
          <source>These constants are copied from the flate package, so that code that imports &quot;compress/gzip&quot; does not also have to import &quot;compress/flate&quot;.</source>
          <target state="translated">这些常量是从 flate 包中复制过来的,所以导入 &quot;compress/gzip&quot; 的代码不必同时导入 &quot;compress/flate&quot;。</target>
        </trans-unit>
        <trans-unit id="9b53ffb7fd51347180d120a25b5986ecdfdf8a40" translate="yes" xml:space="preserve">
          <source>These constants are copied from the flate package, so that code that imports &quot;compress/zlib&quot; does not also have to import &quot;compress/flate&quot;.</source>
          <target state="translated">这些常量是从flate包中复制过来的,所以导入 &quot;compress/zlib &quot;的代码不必同时导入 &quot;compress/flate&quot;。</target>
        </trans-unit>
        <trans-unit id="a6caaf07cd62c3bce0c1d44802c32e939959f7c6" translate="yes" xml:space="preserve">
          <source>These constants cause FlagSet.Parse to behave as described if the parse fails.</source>
          <target state="translated">这些常量导致FlagSet.Parse在解析失败时的行为与描述的一样。</target>
        </trans-unit>
        <trans-unit id="c3e135e518f3071cd6e6de5ee8eb8509897ca8e4" translate="yes" xml:space="preserve">
          <source>These constants define supported rounding modes.</source>
          <target state="translated">这些常数定义了支持的四舍五入模式。</target>
        </trans-unit>
        <trans-unit id="e9b81d06567b4f6ea4a134b77b7d8d68b11092d0" translate="yes" xml:space="preserve">
          <source>These examples demonstrate the basics of printing using a format string. Printf, Sprintf, and Fprintf all take a format string that specifies how to format the subsequent arguments. For example, %d (we call that a 'verb') says to print the corresponding argument, which must be an integer (or something containing an integer, such as a slice of ints) in decimal. The verb %v ('v' for 'value') always formats the argument in its default form, just how Print or Println would show it. The special verb %T ('T' for 'Type') prints the type of the argument rather than its value. The examples are not exhaustive; see the package comment for all the details.</source>
          <target state="translated">这些例子演示了使用格式字符串进行打印的基础知识。Printf、Sprintf和Fprintf都取一个格式字符串,指定如何格式化后面的参数。例如,%d(我们称之为 &quot;动词&quot;)说要打印相应的参数,它必须是一个整数(或包含一个整数的东西,如ints的一个片断),用十进制表示。动词%v('v'表示'value')总是以默认的形式格式化参数,就像Print或Println会显示的那样。特殊的动词%T('T'代表'Type')打印参数的类型,而不是它的值。这些例子并不详尽,所有细节请参见软件包注释。</target>
        </trans-unit>
        <trans-unit id="1b31c3c54ac0eb3ff04d00595a12fb566e8fcf7e" translate="yes" xml:space="preserve">
          <source>These flags define which text to prefix to each log entry generated by the Logger. Bits are or'ed together to control what's printed. There is no control over the order they appear (the order listed here) or the format they present (as described in the comments). The prefix is followed by a colon only when Llongfile or Lshortfile is specified. For example, flags Ldate | Ltime (or LstdFlags) produce,</source>
          <target state="translated">这些标志定义了记录仪生成的每个日志条目的前缀文本。位是或'ed一起控制打印的内容。无法控制它们出现的顺序(这里列出的顺序)或它们呈现的格式(如注释中所述)。只有当指定了Llongfile或Lshortfile时,前缀后面才会有一个冒号。例如,标志Ldate | Ltime(或LstdFlags)会产生。</target>
        </trans-unit>
        <trans-unit id="fc9914d5780e96c178ba8969a057705144577da8" translate="yes" xml:space="preserve">
          <source>These functions are also compatible with the &amp;ldquo;Ed25519&amp;rdquo; function defined in RFC 8032. However, unlike RFC 8032's formulation, this package's private key representation includes a public key suffix to make multiple signing operations with the same key more efficient. This package refers to the RFC 8032 private key as the &amp;ldquo;seed&amp;rdquo;.</source>
          <target state="translated">这些功能还与RFC 8032中定义的&amp;ldquo; Ed25519&amp;rdquo;功能兼容。但是，与RFC 8032的表述不同，此程序包的私钥表示形式包含一个公钥后缀，以使使用同一密钥的多个签名操作更加有效。该软件包将RFC 8032私钥称为&amp;ldquo;种子&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="2034a99a91b57c3247261a1a8004621e6e0c4e1f" translate="yes" xml:space="preserve">
          <source>These functions require great care to be used correctly. Except for special, low-level applications, synchronization is better done with channels or the facilities of the sync package. Share memory by communicating; don't communicate by sharing memory.</source>
          <target state="translated">这些功能需要非常小心才能正确使用。除了特殊的低级应用外,同步最好用通道或同步包的设施来完成。通过通信来共享内存,不要通过共享内存来通信。</target>
        </trans-unit>
        <trans-unit id="54aa9a67852a83f3350017dd1b9500c555360772" translate="yes" xml:space="preserve">
          <source>These packages are part of the Go Project but outside the main Go tree. They are developed under looser &lt;a href=&quot;https://golang.org/doc/go1compat&quot;&gt;compatibility requirements&lt;/a&gt; than the Go core. Install them with &quot;&lt;a href=&quot;https://golang.org/cmd/go/#hdr-Download_and_install_packages_and_dependencies&quot;&gt;go get&lt;/a&gt;&quot;.</source>
          <target state="translated">这些软件包是Go项目的一部分，但在主Go树之外。它们是在比Go内核更&lt;a href=&quot;https://golang.org/doc/go1compat&quot;&gt;严格&lt;/a&gt;的兼容性要求下开发的。用&amp;ldquo; &lt;a href=&quot;https://golang.org/cmd/go/#hdr-Download_and_install_packages_and_dependencies&quot;&gt;go get&lt;/a&gt; &amp;rdquo; 安装它们。</target>
        </trans-unit>
        <trans-unit id="07168c583c59c9cae9d4bb3facc94a52fb2a21e9" translate="yes" xml:space="preserve">
          <source>These predefined profiles maintain themselves and panic on an explicit Add or Remove method call.</source>
          <target state="translated">这些预定义的配置文件会自我维护,并在明确的添加或删除方法调用时发生恐慌。</target>
        </trans-unit>
        <trans-unit id="8dc4875980e26530686b9e8a46a4183aeaf7943d" translate="yes" xml:space="preserve">
          <source>These services can help you find Open Source packages provided by the community.</source>
          <target state="translated">这些服务可以帮助你找到社区提供的开源包。</target>
        </trans-unit>
        <trans-unit id="6ba17173fd7e73d9151d0d7cdef890f5dd3a0a3f" translate="yes" xml:space="preserve">
          <source>These three formatting routines call the Qualifier for each package-level object O, and if the Qualifier returns a non-empty string p, the object is printed in the form p.O. If it returns an empty string, only the object name O is printed.</source>
          <target state="translated">这三个格式化例程对每个包级对象O调用限定符,如果限定符返回非空字符串p,则以p.O的形式打印对象,如果返回空字符串,则只打印对象名称O。</target>
        </trans-unit>
        <trans-unit id="2207cae6c61d669eed106af825a6dce66aef87d1" translate="yes" xml:space="preserve">
          <source>These variables have type *RangeTable.</source>
          <target state="translated">这些变量的类型为*RangeTable。</target>
        </trans-unit>
        <trans-unit id="1166cbd43d7ca0f544abde3cc256ae8afc9cd0b1" translate="yes" xml:space="preserve">
          <source>This cannot be done concurrent to other receives from the Timer's channel.</source>
          <target state="translated">这不能与定时器通道的其他接收同时进行。</target>
        </trans-unit>
        <trans-unit id="b00ff4b1fd4c120a5db60ce99d175dd291630987" translate="yes" xml:space="preserve">
          <source>This declares an integer flag, -flagname, stored in the pointer ip, with type *int.</source>
          <target state="translated">这声明了一个整数标志,-flagname,存储在指针ip中,类型为*int。</target>
        </trans-unit>
        <trans-unit id="631f1841cf17bb7db8a22b0767e5099ebe5b8b09" translate="yes" xml:space="preserve">
          <source>This defines two templates, T1 and T2, and a third T3 that invokes the other two when it is executed. Finally it invokes T3. If executed this template will produce the text</source>
          <target state="translated">这就定义了两个模板,T1和T2,还有第三个T3,当它被执行时,会调用其他两个模板。最后它调用T3。如果执行这个模板,将产生文本</target>
        </trans-unit>
        <trans-unit id="07be652fe77b2bc1e633b76695cc662deba999dd" translate="yes" xml:space="preserve">
          <source>This example creates a PriorityQueue with some items, adds and manipulates an item, and then removes the items in priority order.</source>
          <target state="translated">这个例子用一些项目创建了一个PriorityQueue,添加并操作一个项目,然后按照优先级顺序删除项目。</target>
        </trans-unit>
        <trans-unit id="11e8e47e8373159f24438e9584e5f85d6b5441f2" translate="yes" xml:space="preserve">
          <source>This example demonstrates a custom function to process template text. It installs the strings.Title function and uses it to Make Title Text Look Good In Our Template's Output.</source>
          <target state="translated">这个例子演示了一个自定义函数来处理模板文本。它安装了strings.Title函数,并使用它来使标题文本在我们的模板输出中看起来不错。</target>
        </trans-unit>
        <trans-unit id="dfa54d108334a66ba7ab5757d71b4364db5ae271" translate="yes" xml:space="preserve">
          <source>This example demonstrates how a value can be passed to the context and also how to retrieve it if it exists.</source>
          <target state="translated">这个例子演示了如何将一个值传递给上下文,以及如何在它存在时检索它。</target>
        </trans-unit>
        <trans-unit id="cbed8edb3aa3c802bdc2c523c3a0a851457324e3" translate="yes" xml:space="preserve">
          <source>This example demonstrates how to inspect the AST of a Go program.</source>
          <target state="translated">这个例子演示了如何检查一个Go程序的AST。</target>
        </trans-unit>
        <trans-unit id="165d3019bf668cef6d1995c8165503ac097763bd" translate="yes" xml:space="preserve">
          <source>This example demonstrates how to use big.Int to compute the smallest Fibonacci number with 100 decimal digits and to test whether it is prime.</source>
          <target state="translated">这个例子演示了如何使用big.Int来计算100位小数的最小斐波那契数,并测试它是否是质数。</target>
        </trans-unit>
        <trans-unit id="0059484fefd6cd0e894a9be3837a0c3c538eda17" translate="yes" xml:space="preserve">
          <source>This example demonstrates how to use big.Rat to compute the first 15 terms in the sequence of rational convergents for the constant e (base of natural logarithm).</source>
          <target state="translated">这个例子演示了如何使用big.Rat计算常数e(自然对数的基数)的有理收敛序列的前15项。</target>
        </trans-unit>
        <trans-unit id="b29080504869eb07c938bd169b02dbf661e6a627" translate="yes" xml:space="preserve">
          <source>This example demonstrates how to use one group of driver templates with distinct sets of helper templates.</source>
          <target state="translated">这个例子演示了如何使用一组驱动模板与不同的辅助模板集。</target>
        </trans-unit>
        <trans-unit id="ba0650f40679135f634bca363681740adeafe34a" translate="yes" xml:space="preserve">
          <source>This example demonstrates one way to share some templates and use them in different contexts. In this variant we add multiple driver templates by hand to an existing bundle of templates.</source>
          <target state="translated">这个例子演示了一种共享一些模板并在不同环境下使用它们的方法。在这个变体中,我们通过手工将多个驱动程序模板添加到现有的模板捆绑中。</target>
        </trans-unit>
        <trans-unit id="0ba078883e861f3b147ecf053f6c06d8a3174cd3" translate="yes" xml:space="preserve">
          <source>This example demonstrates searching a list sorted in ascending order.</source>
          <target state="translated">这个例子演示了如何搜索一个按升序排列的列表。</target>
        </trans-unit>
        <trans-unit id="7888c65ff5bdcbe2c823d7d7283ee2975bf6366b" translate="yes" xml:space="preserve">
          <source>This example demonstrates searching a list sorted in descending order. The approach is the same as searching a list in ascending order, but with the condition inverted.</source>
          <target state="translated">这个例子演示了如何搜索一个按降序排序的列表。其方法与按升序搜索列表相同,但条件倒置。</target>
        </trans-unit>
        <trans-unit id="2db6a343e7f8129baf91fac5d3ebedf3e8666279" translate="yes" xml:space="preserve">
          <source>This example demonstrates the use of a cancelable context to prevent a goroutine leak. By the end of the example function, the goroutine started by gen will return without leaking.</source>
          <target state="translated">这个例子演示了使用可取消上下文来防止goroutine泄漏。在本例函数结束时,由gen启动的goroutine将无泄漏地返回。</target>
        </trans-unit>
        <trans-unit id="f5ede30ffc3c68340a6fb2445f68975fd1d677b3" translate="yes" xml:space="preserve">
          <source>This example demonstrates unmarshaling an XML excerpt into a value with some preset fields. Note that the Phone field isn't modified and that the XML &amp;lt;Company&amp;gt; element is ignored. Also, the Groups field is assigned considering the element path provided in its tag.</source>
          <target state="translated">此示例演示了如何将XML摘录编组为具有某些预设字段的值。请注意，&amp;ldquo;电话&amp;rdquo;字段未修改，并且XML &amp;lt;Company&amp;gt;元素被忽略。同样，考虑到其标签中提供的元素路径来分配&amp;ldquo;组&amp;rdquo;字段。</target>
        </trans-unit>
        <trans-unit id="363362d5c2e9f91c6b9857ffd69fe714bafa9ced" translate="yes" xml:space="preserve">
          <source>This example fetches several URLs concurrently, using a WaitGroup to block until all the fetches are complete.</source>
          <target state="translated">这个例子同时获取多个URL,使用WaitGroup阻塞,直到所有的获取完成。</target>
        </trans-unit>
        <trans-unit id="06701ebad78061b44ebf3ff359db4a889929ed4c" translate="yes" xml:space="preserve">
          <source>This example illustrates how to remove a variable declaration in a Go program while maintaining correct comment association using an ast.CommentMap.</source>
          <target state="translated">这个例子说明了如何使用 ast.CommentMap 来删除 Go 程序中的变量声明,同时保持正确的注释关联。</target>
        </trans-unit>
        <trans-unit id="a88fa5b5d7ed0c65b753c3fe2d8b6cdc87e0d250" translate="yes" xml:space="preserve">
          <source>This example inserts several ints into an IntHeap, checks the minimum, and removes them in order of priority.</source>
          <target state="translated">这个例子将几个ints插入到IntHeap中,检查最小值,并按优先级顺序删除它们。</target>
        </trans-unit>
        <trans-unit id="e36be68d73234a9e2fb853054688b98fefd0444d" translate="yes" xml:space="preserve">
          <source>This example passes a context with a timeout to tell a blocking function that it should abandon its work after the timeout elapses.</source>
          <target state="translated">这个例子通过一个带有超时的上下文来告诉阻塞函数在超时后应该放弃它的工作。</target>
        </trans-unit>
        <trans-unit id="eac2b4a123d3756695f2f19424362998d49962a1" translate="yes" xml:space="preserve">
          <source>This example passes a context with an arbitrary deadline to tell a blocking function that it should abandon its work as soon as it gets to it.</source>
          <target state="translated">这个例子通过一个带有任意deadline的上下文来告诉阻塞函数,它应该在到达阻塞函数后立即放弃它的工作。</target>
        </trans-unit>
        <trans-unit id="df7ace59807aa52b6b44602449d158b9635a420e" translate="yes" xml:space="preserve">
          <source>This example reads 10 cryptographically secure pseudorandom numbers from rand.Reader and writes them to a byte slice.</source>
          <target state="translated">这个例子从rand.Reader中读取10个加密安全的伪随机数,并将它们写入一个字节片断。</target>
        </trans-unit>
        <trans-unit id="d0f63cae6959df0e63ff45ed07152e8d354e9432" translate="yes" xml:space="preserve">
          <source>This example shows how csv.Reader can be configured to handle other types of CSV files.</source>
          <target state="translated">这个例子展示了如何配置csv.Reader来处理其他类型的CSV文件。</target>
        </trans-unit>
        <trans-unit id="1cca172f7759e3ba0050255d1746af87f660b76a" translate="yes" xml:space="preserve">
          <source>This example shows how to encode an interface value. The key distinction from regular types is to register the concrete type that implements the interface.</source>
          <target state="translated">这个例子展示了如何对一个接口值进行编码。与常规类型的关键区别在于注册实现接口的具体类型。</target>
        </trans-unit>
        <trans-unit id="a3357a230dfc48b693b3b94d9c6611698fcf1171" translate="yes" xml:space="preserve">
          <source>This example shows how to use big.Float to compute the square root of 2 with a precision of 200 bits, and how to print the result as a decimal number.</source>
          <target state="translated">这个例子展示了如何使用big.Float计算精度为200位的2的平方根,以及如何将结果打印为十进制数。</target>
        </trans-unit>
        <trans-unit id="efe429413e771069e2a76db974f921ef42dbdd60" translate="yes" xml:space="preserve">
          <source>This example shows the basic usage of the package: Create an encoder, transmit some values, receive them with a decoder.</source>
          <target state="translated">这个例子展示了这个包的基本用法。创建一个编码器,传输一些值,用解码器接收它们。</target>
        </trans-unit>
        <trans-unit id="4e20892924831ca17c2f745e5365e20b64d74b0e" translate="yes" xml:space="preserve">
          <source>This example shows the use of each of the methods on a *Rand. The use of the global functions is the same, without the receiver.</source>
          <target state="translated">这个例子显示了每个方法在*Rand上的使用。全局函数的使用是一样的,没有接收器。</target>
        </trans-unit>
        <trans-unit id="9dae51dea551843f94a869c5f0aec8bf68e765cc" translate="yes" xml:space="preserve">
          <source>This example shows what an AST looks like when printed for debugging.</source>
          <target state="translated">这个例子显示了AST在打印调试时的样子。</target>
        </trans-unit>
        <trans-unit id="3d4d87b6b74c64cd8a077a3429d1b650786c492b" translate="yes" xml:space="preserve">
          <source>This example transmits a value that implements the custom encoding and decoding methods.</source>
          <target state="translated">这个例子传送了一个实现自定义编码和解码方法的值。</target>
        </trans-unit>
        <trans-unit id="5ad4aea6278dc849132cadb70003c4716078bb1f" translate="yes" xml:space="preserve">
          <source>This example uses RawMessage to delay parsing part of a JSON message.</source>
          <target state="translated">这个例子使用RawMessage来延迟解析JSON消息的一部分。</target>
        </trans-unit>
        <trans-unit id="f3c7cd2790bc702e1c4e8248c880538aa9480232" translate="yes" xml:space="preserve">
          <source>This example uses RawMessage to use a precomputed JSON during marshal.</source>
          <target state="translated">这个例子在marshal过程中使用RawMessage来使用预计算的JSON。</target>
        </trans-unit>
        <trans-unit id="0980067335654187fe3f7c133925d1affa51d747" translate="yes" xml:space="preserve">
          <source>This example uses a Decoder to decode a stream of distinct JSON values.</source>
          <target state="translated">这个例子使用解码器来解码不同的JSON值流。</target>
        </trans-unit>
        <trans-unit id="03fbac2b83cd3991555ff62920bdc91549cc27eb" translate="yes" xml:space="preserve">
          <source>This example uses a Decoder to decode a streaming array of JSON objects.</source>
          <target state="translated">这个例子使用解码器来解码JSON对象的流式数组。</target>
        </trans-unit>
        <trans-unit id="f5365f6fa06883e90b95f7b5b17bc92e07aa1a04" translate="yes" xml:space="preserve">
          <source>This function is deterministic. Thus, if the set of possible messages is small, an attacker may be able to build a map from messages to signatures and identify the signed messages. As ever, signatures provide authenticity, not confidentiality.</source>
          <target state="translated">这个函数是确定性的。因此,如果可能的消息集很小,攻击者可能能够从消息到签名建立一个映射,并识别签名的消息。与以往一样,签名提供的是真实性,而不是保密性。</target>
        </trans-unit>
        <trans-unit id="21dc4eae53c9012a7d2a049dd7f00db6a6938f5b" translate="yes" xml:space="preserve">
          <source>This function's execution time does not depend on the inputs.</source>
          <target state="translated">这个函数的执行时间不取决于输入。</target>
        </trans-unit>
        <trans-unit id="87202fef0c6c5ae187b02620dfd26b630d0392d4" translate="yes" xml:space="preserve">
          <source>This functionality should only be used with legacy web sites. RFC 2396 warns that interpreting Userinfo this way &amp;ldquo;is NOT RECOMMENDED, because the passing of authentication information in clear text (such as URI) has proven to be a security risk in almost every case where it has been used.&amp;rdquo;</source>
          <target state="translated">此功能只能与旧版网站一起使用。RFC 2396警告说，&amp;ldquo;以这种方式解释Userinfo是不推荐的，因为在几乎所有已使用身份验证信息的情况下，都已证明以明文（例如URI）传递身份验证信息存在安全风险。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="898688304c78e7f2468d53e47407efc6f38af32f" translate="yes" xml:space="preserve">
          <source>This implementation derives the nonce from an AES-CTR CSPRNG keyed by ChopMD(256, SHA2-512(priv.D || entropy || hash)). The CSPRNG key is IRO by a result of Coron; the AES-CTR stream is IRO under standard assumptions.</source>
          <target state="translated">本实施例从AES-CTR CSPRNG中导出非ce,其密钥由ChopMD(256,SHA2-512(priv.D || entropy || hash))获得。CSPRNG的密钥根据Coron的结果是IRO的;AES-CTR流在标准假设下是IRO的。</target>
        </trans-unit>
        <trans-unit id="d2d5c7329f986ca3d31bfdba2057014f5f44ad7d" translate="yes" xml:space="preserve">
          <source>This is only needed to install the handler in a non-standard location.</source>
          <target state="translated">这只需要在非标准位置安装处理程序。</target>
        </trans-unit>
        <trans-unit id="4726b7b6e93eb25607ca12b6c92e41d048948273" translate="yes" xml:space="preserve">
          <source>This is unnecessary as the next call to WriteHeader or Close will implicitly flush out the file's padding.</source>
          <target state="translated">这是不需要的,因为下一次调用WriteHeader或Close会隐含地冲掉文件的padding。</target>
        </trans-unit>
        <trans-unit id="eb1b3ed68f800415903edd6e38e6c00b58c4b66a" translate="yes" xml:space="preserve">
          <source>This kind of key is commonly encoded in PEM blocks of type &quot;EC PRIVATE KEY&quot;. For a more flexible key format which is not EC specific, use MarshalPKCS8PrivateKey.</source>
          <target state="translated">这种密钥通常用 &quot;EC PRIVATE KEY &quot;类型的PEM块进行编码。如果想获得更灵活的密钥格式,而且不是EC专用的,可以使用MarshalPKCS8PrivateKey。</target>
        </trans-unit>
        <trans-unit id="56bef0ed59f36389d7550a0e4c48802187b81f7d" translate="yes" xml:space="preserve">
          <source>This kind of key is commonly encoded in PEM blocks of type &quot;EC PUBLIC KEY&quot;.</source>
          <target state="translated">这种密钥通常用 &quot;EC公共密钥 &quot;类型的PEM块进行编码。</target>
        </trans-unit>
        <trans-unit id="dfe352de6a0131091f458f18e937a358eab3152e" translate="yes" xml:space="preserve">
          <source>This kind of key is commonly encoded in PEM blocks of type &quot;PRIVATE KEY&quot;.</source>
          <target state="translated">这种密钥通常用 &quot;PRIVATE KEY &quot;类型的PEM块进行编码。</target>
        </trans-unit>
        <trans-unit id="42db7a056c64d4d64e474ea59fd1650377d9bc54" translate="yes" xml:space="preserve">
          <source>This kind of key is commonly encoded in PEM blocks of type &quot;PUBLIC KEY&quot;.</source>
          <target state="translated">这种密钥通常用 &quot;PUBLIC KEY &quot;类型的PEM块进行编码。</target>
        </trans-unit>
        <trans-unit id="64ab07dfb34f7d2feff364506aca7067a4453b39" translate="yes" xml:space="preserve">
          <source>This kind of key is commonly encoded in PEM blocks of type &quot;RSA PRIVATE KEY&quot;.</source>
          <target state="translated">这种密钥通常用 &quot;RSA PRIVATE KEY &quot;类型的PEM块进行编码。</target>
        </trans-unit>
        <trans-unit id="98a803d28f3224bf7891d32a0db324db326e4afd" translate="yes" xml:space="preserve">
          <source>This kind of key is commonly encoded in PEM blocks of type &quot;RSA PRIVATE KEY&quot;. For a more flexible key format which is not RSA specific, use MarshalPKCS8PrivateKey.</source>
          <target state="translated">这种密钥通常用 &quot;RSA PRIVATE KEY &quot;类型的PEM块进行编码。如果想获得更灵活的密钥格式,而且不是RSA专用的,可以使用MarshalPKCS8PrivateKey。</target>
        </trans-unit>
        <trans-unit id="5d8222cc13301829f5dbdc649eec16abab7d33d6" translate="yes" xml:space="preserve">
          <source>This kind of key is commonly encoded in PEM blocks of type &quot;RSA PUBLIC KEY&quot;.</source>
          <target state="translated">这种密钥通常用 &quot;RSA公共密钥 &quot;类型的PEM块进行编码。</target>
        </trans-unit>
        <trans-unit id="67c7b63689264a63777784c1588c7be8f2ebeb83" translate="yes" xml:space="preserve">
          <source>This means that, by default, command line programs will behave like typical Unix command line programs, while other programs will not crash with SIGPIPE when writing to a closed network connection.</source>
          <target state="translated">这意味着,在默认情况下,命令行程序会像典型的Unix命令行程序一样,而其他程序在写入封闭的网络连接时,不会用SIGPIPE崩溃。</target>
        </trans-unit>
        <trans-unit id="53c41745078961e0cbeedf1ad29b01ea99fe7434" translate="yes" xml:space="preserve">
          <source>This mechanism can be used to cancel long operations on the server if the client has disconnected before the response is ready.</source>
          <target state="translated">如果客户端在响应准备好之前断开了连接,这个机制可以用来取消对服务器的长时间操作。</target>
        </trans-unit>
        <trans-unit id="d3191056acdbdc6fd1ca936f76914f75eb4f8098" translate="yes" xml:space="preserve">
          <source>This mechanism is intended only for trailers that are not known prior to the headers being written. If the set of trailers is fixed or known before the header is written, the normal Go trailers mechanism is preferred:</source>
          <target state="translated">这种机制只适用于在写头之前不知道的线索。如果在写入头之前,跟踪器的集合是固定的或已知的,则首选正常的Go跟踪器机制。</target>
        </trans-unit>
        <trans-unit id="34dfd520d192c4e8193a79a528c0369751354149" translate="yes" xml:space="preserve">
          <source>This method consults the following fields of the response r:</source>
          <target state="translated">本方法会查询响应r的以下字段。</target>
        </trans-unit>
        <trans-unit id="6857cb2d00e6efa4c19dc849fe5f85bb657fb149" translate="yes" xml:space="preserve">
          <source>This method implements crypto.Signer, which is an interface to support keys where the private part is kept in, for example, a hardware module. Common uses should use the Sign function in this package directly.</source>
          <target state="translated">这个方法实现了crypto.Signer,它是一个接口,支持私密部分保存在硬件模块等地方的密钥。普通用途应该直接使用这个包中的Sign函数。</target>
        </trans-unit>
        <trans-unit id="dca73678d958fc56a6644aad153e6b5ae346adb8" translate="yes" xml:space="preserve">
          <source>This method implements crypto.Signer, which is an interface to support keys where the private part is kept in, for example, a hardware module. Common uses should use the Sign* functions in this package directly.</source>
          <target state="translated">这个方法实现了crypto.Signer,它是一个接口,支持私密部分保存在硬件模块等地方的密钥。普通用途应该直接使用这个包中的Sign*函数。</target>
        </trans-unit>
        <trans-unit id="6162e9fff452fe7b81839fc43d5a9b956682d1db" translate="yes" xml:space="preserve">
          <source>This package assumes that template authors are trusted, that Execute's data parameter is not, and seeks to preserve the properties below in the face of untrusted data:</source>
          <target state="translated">本包假设模板作者是受信任的,Execute的数据参数是不受信任的,在面对不受信任的数据时,力求保留以下属性。</target>
        </trans-unit>
        <trans-unit id="646741784bedcfbc50f393efbc21b4c2b803f33a" translate="yes" xml:space="preserve">
          <source>This package does not guarantee bit-identical results across architectures.</source>
          <target state="translated">这个软件包不保证不同架构的位相同结果。</target>
        </trans-unit>
        <trans-unit id="25b183f3fa47240bd162a6084ce81041d00db47f" translate="yes" xml:space="preserve">
          <source>This package does not support disk spanning.</source>
          <target state="translated">这个软件包不支持磁盘跨度。</target>
        </trans-unit>
        <trans-unit id="917226455af3a3e84812552f61aaf5f000d19a66" translate="yes" xml:space="preserve">
          <source>This package favors simplicity over efficiency. Clients that require high-performance serialization, especially for large data structures, should look at more advanced solutions such as the encoding/gob package or protocol buffers.</source>
          <target state="translated">这个包偏重于简单而非效率。需要高性能序列化的客户,特别是对于大型数据结构,应该考虑更高级的解决方案,如编码/gob包或协议缓冲器。</target>
        </trans-unit>
        <trans-unit id="91400ec0be490a039f54a2e8ea4991f07061b72f" translate="yes" xml:space="preserve">
          <source>This package is EXPERIMENTAL. Its current scope is only to allow tests to run, but not yet to provide a comprehensive API for users. It is exempt from the Go compatibility promise.</source>
          <target state="translated">这个包是实验性的。它目前的范围只是允许测试运行,但还没有为用户提供一个全面的API。它免于Go的兼容性承诺。</target>
        </trans-unit>
        <trans-unit id="f172ad46509f2996426e887fe6f7f5b737ccb0ba" translate="yes" xml:space="preserve">
          <source>This package is not implemented on NaCl (Native Client).</source>
          <target state="translated">这个包在NaCl(Native Client)上没有实现。</target>
        </trans-unit>
        <trans-unit id="70b7c3d76332df2a567dd4571a1dd43d36bb3d95" translate="yes" xml:space="preserve">
          <source>This package is not implemented on Plan 9.</source>
          <target state="translated">本套方案在计划9上没有实施。</target>
        </trans-unit>
        <trans-unit id="089323f3519ab53b437d7cbe9878efc86f18d94a" translate="yes" xml:space="preserve">
          <source>This package is not implemented on Windows. As the syslog package is frozen, Windows users are encouraged to use a package outside of the standard library. For background, see &lt;a href=&quot;https://golang.org/issue/1108&quot;&gt;https://golang.org/issue/1108&lt;/a&gt;.</source>
          <target state="translated">Windows上未实现此程序包。由于syslog程序包被冻结，因此鼓励Windows用户使用标准库之外的程序包。有关背景，请参见&lt;a href=&quot;https://golang.org/issue/1108&quot;&gt;https://golang.org/issue/1108&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4c28db944fb8406ea70640148283b4f2b07cfe75" translate="yes" xml:space="preserve">
          <source>This package understands HTML, CSS, JavaScript, and URIs. It adds sanitizing functions to each simple action pipeline, so given the excerpt</source>
          <target state="translated">这个包了解HTML、CSS、JavaScript和URI。它为每个简单的动作流水线添加了消毒功能,所以给定的摘录是</target>
        </trans-unit>
        <trans-unit id="63f9c654258649e0fec61304d0149ff6b7e1fac2" translate="yes" xml:space="preserve">
          <source>This package wraps package text/template so you can share its template API to parse and execute HTML templates safely.</source>
          <target state="translated">这个包封装了package text/template,这样你就可以分享它的模板API来安全地解析和执行HTML模板。</target>
        </trans-unit>
        <trans-unit id="12b81feb5020b97e164b3bd1ab6605720164a33f" translate="yes" xml:space="preserve">
          <source>This palette was used in the Plan 9 Operating System, described at &lt;a href=&quot;https://9p.io/magic/man2html/6/color&quot;&gt;https://9p.io/magic/man2html/6/color&lt;/a&gt;</source>
          <target state="translated">此选板用于&lt;a href=&quot;https://9p.io/magic/man2html/6/color&quot;&gt;https://9p.io/magic/man2html/6/color&lt;/a&gt;中的Plan 9操作系统。</target>
        </trans-unit>
        <trans-unit id="53f264e60d97dda7c8e598fd892c840f64c77bcb" translate="yes" xml:space="preserve">
          <source>This returns a Writer to which the file contents should be written. The file's contents must be written to the io.Writer before the next call to Create, CreateHeader, or Close.</source>
          <target state="translated">这将返回一个写入文件内容的Writer。在下一次调用Create、CreateHeader或Close之前,文件的内容必须被写入io.Writer。</target>
        </trans-unit>
        <trans-unit id="3636f2d8cb7dce3b52ad380d63ea631656bb70da" translate="yes" xml:space="preserve">
          <source>This runtime/trace package provides APIs to add equivalent tracing support to a standalone program. See the Example that demonstrates how to use this API to enable tracing.</source>
          <target state="translated">这个运行时/跟踪包提供了API,可以为独立的程序添加同等的跟踪支持。请参阅示例,演示如何使用该API来启用跟踪。</target>
        </trans-unit>
        <trans-unit id="eb3d7236d288f19d5e07330ec9b641abb7a1c736" translate="yes" xml:space="preserve">
          <source>This section documents the encoding, details that are not important for most users. Details are presented bottom-up.</source>
          <target state="translated">本节记录了编码、细节,这些细节对大多数用户来说并不重要。细节是自下而上的介绍。</target>
        </trans-unit>
        <trans-unit id="8d97dde3cffa35e96f0901463ccd21bc2b7e33d2" translate="yes" xml:space="preserve">
          <source>This set may grow. Note that regular expression matches may need to examine text beyond the text returned by a match, so the methods that match text from a RuneReader may read arbitrarily far into the input before returning.</source>
          <target state="translated">这个集合可能会增加。请注意,正则表达式匹配可能需要检查匹配返回的文本之外的文本,因此匹配来自RuneReader的文本的方法可能会在返回之前任意读取输入的内容。</target>
        </trans-unit>
        <trans-unit id="13155ea54999e3f67a0c6d8a556ef2fb922860ce" translate="yes" xml:space="preserve">
          <source>This should not be done concurrent to other receives from the Timer's channel.</source>
          <target state="translated">这不应该与定时器通道的其他接收同时进行。</target>
        </trans-unit>
        <trans-unit id="0da770375be11542fa319ca413fcc3ece2b576a4" translate="yes" xml:space="preserve">
          <source>This type should be considered identical to sql.IsolationLevel along with any values defined on it.</source>
          <target state="translated">这个类型应该和 sql.IsolationLevel 以及在它上面定义的任何值被认为是相同的。</target>
        </trans-unit>
        <trans-unit id="5cefc7416c362c1afcf6c674cc1720ba6d02139f" translate="yes" xml:space="preserve">
          <source>This type should be considered identical to sql.TxOptions.</source>
          <target state="translated">这个类型应该被认为与 sql.TxOptions 相同。</target>
        </trans-unit>
        <trans-unit id="23bb56893bd9c167f4933bba0f06ea209969209a" translate="yes" xml:space="preserve">
          <source>ThreadCreateProfile returns n, the number of records in the thread creation profile. If len(p) &amp;gt;= n, ThreadCreateProfile copies the profile into p and returns n, true. If len(p) &amp;lt; n, ThreadCreateProfile does not change p and returns n, false.</source>
          <target state="translated">ThreadCreateProfile返回n，即线程创建配置文件中的记录数。如果len（p）&amp;gt; = n，则ThreadCreateProfile将配置文件复制到p中并返回n，为true。如果len（p）&amp;lt;n，则ThreadCreateProfile不会更改p并返回n，否则为false。</target>
        </trans-unit>
        <trans-unit id="aeddfe22a01fc0ff5fb0fe691b08db0b2e2a26c7" translate="yes" xml:space="preserve">
          <source>Tick</source>
          <target state="translated">Tick</target>
        </trans-unit>
        <trans-unit id="26c9fc157a3f52de1aca92922ccb9a288e5fa386" translate="yes" xml:space="preserve">
          <source>Tick is a convenience wrapper for NewTicker providing access to the ticking channel only. While Tick is useful for clients that have no need to shut down the Ticker, be aware that without a way to shut it down the underlying Ticker cannot be recovered by the garbage collector; it &quot;leaks&quot;. Unlike NewTicker, Tick will return nil if d &amp;lt;= 0.</source>
          <target state="translated">Tick是NewTicker的便捷包装，仅提供对滴答通道的访问。虽然Tick对于不需要关闭Ticker的客户端很有用，但是请注意，如果没有关闭Ticker的方法，则垃圾收集器无法恢复基础Ticker；它&amp;ldquo;泄漏&amp;rdquo;。与NewTicker不同，如果d &amp;lt;= 0，则Tick将返回nil。</target>
        </trans-unit>
        <trans-unit id="464b9c4863cbad4e03c3166e6a41a020f20219b8" translate="yes" xml:space="preserve">
          <source>Time instants can be compared using the Before, After, and Equal methods. The Sub method subtracts two instants, producing a Duration. The Add method adds a Time and a Duration, producing a Time.</source>
          <target state="translated">可以使用 &quot;之前&quot;、&quot;之后 &quot;和 &quot;等值 &quot;方法比较时间瞬时。Sub方法减去两个实例,产生一个Duration。添加方法添加一个时间和一个持续时间,产生一个时间。</target>
        </trans-unit>
        <trans-unit id="7e0d5fdb48c2796b9cc511f84f1969b59a9bd1cf" translate="yes" xml:space="preserve">
          <source>Time.Add</source>
          <target state="translated">Time.Add</target>
        </trans-unit>
        <trans-unit id="5c2e779ba4c8677013ab3eb4de9c1e6bf9c9924b" translate="yes" xml:space="preserve">
          <source>Time.AddDate</source>
          <target state="translated">Time.AddDate</target>
        </trans-unit>
        <trans-unit id="730b4aa03b8316a2a6c19e05b72ec5d4eb05e78c" translate="yes" xml:space="preserve">
          <source>Time.After</source>
          <target state="translated">Time.After</target>
        </trans-unit>
        <trans-unit id="d5e86b615c46a18260de62e172d7e06cc20f7083" translate="yes" xml:space="preserve">
          <source>Time.AppendFormat</source>
          <target state="translated">Time.AppendFormat</target>
        </trans-unit>
        <trans-unit id="88be4309d5e0539eff6218d7e8c02ecf0c7b2e65" translate="yes" xml:space="preserve">
          <source>Time.Before</source>
          <target state="translated">Time.Before</target>
        </trans-unit>
        <trans-unit id="480d1c53462d365532b2348e82a3f0dcb963c99e" translate="yes" xml:space="preserve">
          <source>Time.Date</source>
          <target state="translated">Time.Date</target>
        </trans-unit>
        <trans-unit id="ae2638b80e7bdac6e6725adc567cf7badedc6abe" translate="yes" xml:space="preserve">
          <source>Time.Day</source>
          <target state="translated">Time.Day</target>
        </trans-unit>
        <trans-unit id="d4766b7b3328342b5ba1a667334b95afb4c840fd" translate="yes" xml:space="preserve">
          <source>Time.Equal</source>
          <target state="translated">Time.Equal</target>
        </trans-unit>
        <trans-unit id="092fc9098aafde18e6cec288675831ee7d77f8a8" translate="yes" xml:space="preserve">
          <source>Time.Format</source>
          <target state="translated">Time.Format</target>
        </trans-unit>
        <trans-unit id="3768befc26b5bc40a2c6b38ecc6f26a0656a5d40" translate="yes" xml:space="preserve">
          <source>Time.Round</source>
          <target state="translated">Time.Round</target>
        </trans-unit>
        <trans-unit id="5b138a17083c1c36c8bab2fd64e7493a32a70b68" translate="yes" xml:space="preserve">
          <source>Time.String</source>
          <target state="translated">Time.String</target>
        </trans-unit>
        <trans-unit id="e126e45961c85339227ad3c92517287507ec5152" translate="yes" xml:space="preserve">
          <source>Time.Sub</source>
          <target state="translated">Time.Sub</target>
        </trans-unit>
        <trans-unit id="d3f1777c34673ecabb71603383f8d1fd8d6be9c4" translate="yes" xml:space="preserve">
          <source>Time.Truncate</source>
          <target state="translated">Time.Truncate</target>
        </trans-unit>
        <trans-unit id="c4ee117595e7091017dcf807233ec5e3324552ac" translate="yes" xml:space="preserve">
          <source>Time.Unix</source>
          <target state="translated">Time.Unix</target>
        </trans-unit>
        <trans-unit id="f8fc7e6bb582b1829de5a848ff872dea68eff61d" translate="yes" xml:space="preserve">
          <source>TimeFormat is the time format to use when generating times in HTTP headers. It is like time.RFC1123 but hard-codes GMT as the time zone. The time being formatted must be in UTC for Format to generate the correct format.</source>
          <target state="translated">TimeFormat是在HTTP头文件中生成时间时使用的时间格式。它类似于time.RFC1123,但硬编码为GMT作为时区。被格式化的时间必须是UTC,这样Format才能生成正确的格式。</target>
        </trans-unit>
        <trans-unit id="9827d1afd02311b970b1c9ab5d2482ee7f917a5d" translate="yes" xml:space="preserve">
          <source>Timeout reports whether the DNS lookup is known to have timed out. This is not always known; a DNS lookup may fail due to a timeout and return a DNSError for which Timeout returns false.</source>
          <target state="translated">超时报告是否已知DNS查找已经超时。这并不总是已知的;DNS查找可能会因为超时而失败,并返回一个DNSError,Timeout返回false。</target>
        </trans-unit>
        <trans-unit id="927810e8434679578bc9bf07a4312dbfd80340d4" translate="yes" xml:space="preserve">
          <source>Timeout reports whether this error represents a timeout.</source>
          <target state="translated">超时报告该错误是否代表超时。</target>
        </trans-unit>
        <trans-unit id="e7860bff1be7d01a8121a71b30616b2279f825c3" translate="yes" xml:space="preserve">
          <source>TimeoutHandler returns a Handler that runs h with the given time limit.</source>
          <target state="translated">TimeoutHandler返回一个以给定时间限制运行h的处理程序。</target>
        </trans-unit>
        <trans-unit id="41f375b226e7f8e10a9acde2441f73751822f0d4" translate="yes" xml:space="preserve">
          <source>TimeoutHandler supports the Flusher and Pusher interfaces but does not support the Hijacker interface.</source>
          <target state="translated">TimeoutHandler支持Flusher和Pusher接口,但不支持Hijacker接口。</target>
        </trans-unit>
        <trans-unit id="b94b20b16ca4b5f916aaa1eb8d24553f8d4b92c2" translate="yes" xml:space="preserve">
          <source>TimeoutReader returns ErrTimeout on the second read with no data. Subsequent calls to read succeed.</source>
          <target state="translated">TimeoutReader在第二次读取时返回ErrTimeout,没有数据。随后的读取调用成功。</target>
        </trans-unit>
        <trans-unit id="8bdae2bbf616fbfd5c5eefd29c8a537bd886144c" translate="yes" xml:space="preserve">
          <source>TimespecToNsec converts a Timespec value into a number of nanoseconds since the Unix epoch.</source>
          <target state="translated">TimespecToNsec将Timespec值转换为Unix纪元后的纳秒数。</target>
        </trans-unit>
        <trans-unit id="71641b558817e2a09b865dac9868550ced5db039" translate="yes" xml:space="preserve">
          <source>TimevalToNsec converts a Timeval value into a number of nanoseconds since the Unix epoch.</source>
          <target state="translated">TimevalToNsec将Timeval值转换为Unix纪元后的纳秒数。</target>
        </trans-unit>
        <trans-unit id="768e0c1c69573fb588f61f1308a015c11468e05f" translate="yes" xml:space="preserve">
          <source>Title</source>
          <target state="translated">Title</target>
        </trans-unit>
        <trans-unit id="ee048df59e1fe3a78061c7c9271c635869379b9b" translate="yes" xml:space="preserve">
          <source>Title returns a copy of the string s with all Unicode letters that begin words mapped to their Unicode title case.</source>
          <target state="translated">Title返回字符串s的副本,其中包含所有单词开头的Unicode字母,并映射到Unicode标题大小写。</target>
        </trans-unit>
        <trans-unit id="173f12648645a6edd8fcbab7c7ed0369c007806c" translate="yes" xml:space="preserve">
          <source>Title treats s as UTF-8-encoded bytes and returns a copy with all Unicode letters that begin words mapped to their title case.</source>
          <target state="translated">Title将s视为UTF-8编码的字节,并返回一个包含所有Unicode字母的副本,这些Unicode字母开始的单词都映射到它们的标题大小写。</target>
        </trans-unit>
        <trans-unit id="ae79ea1e9c6391a9ed83a2e18a031b835feec0c9" translate="yes" xml:space="preserve">
          <source>To</source>
          <target state="translated">To</target>
        </trans-unit>
        <trans-unit id="616d61f65a9f91c650c28db92d9cb8984a1f52bd" translate="yes" xml:space="preserve">
          <source>To add equivalent profiling support to a standalone program, add code like the following to your main function:</source>
          <target state="translated">要在独立的程序中添加等效的剖析支持,在你的主函数中添加类似下面的代码。</target>
        </trans-unit>
        <trans-unit id="f6f5822190a6e77b3f6e2423fce4abac430f1e8d" translate="yes" xml:space="preserve">
          <source>To avoid denial of service attacks, the provided bufio.Reader should be reading from an io.LimitReader or similar Reader to bound the size of responses.</source>
          <target state="translated">为了避免拒绝服务攻击,提供的bufio.Reader应该从io.LimitReader或类似的Reader中读取,以约束响应的大小。</target>
        </trans-unit>
        <trans-unit id="87386ad5a06e96430212748899697cda9d7a3724" translate="yes" xml:space="preserve">
          <source>To avoid recursion in cases such as</source>
          <target state="translated">为了避免递归的情况,如</target>
        </trans-unit>
        <trans-unit id="a87f0fb7c131221874ae3b0c17104f44ee1c34bc" translate="yes" xml:space="preserve">
          <source>To be backwards compatible the FileHeader has both 32 and 64 bit Size fields. The 64 bit fields will always contain the correct value and for normal archives both fields will be the same. For files requiring the ZIP64 format the 32 bit fields will be 0xffffffff and the 64 bit fields must be used instead.</source>
          <target state="translated">为了向后兼容,FileHeader有32位和64位大小字段。64位的字段将始终包含正确的值,对于普通的存档,两个字段将是相同的。对于需要ZIP64格式的文件,32位字段为0xffffffffff,必须使用64位字段。</target>
        </trans-unit>
        <trans-unit id="f0c9c2ba0d3b42114f628f0336b7d63f8138a666" translate="yes" xml:space="preserve">
          <source>To build a file only when using cgo, and only on Linux and OS X:</source>
          <target state="translated">只有在使用cgo时才能建立文件,而且只能在Linux和OS X上建立。</target>
        </trans-unit>
        <trans-unit id="b59fa373960766ba2850aeb1bfd6ebb3acccc2d0" translate="yes" xml:space="preserve">
          <source>To build strings more efficiently, see the strings.Builder type.</source>
          <target state="translated">为了更有效地构建字符串,请参见strings.Builder类型。</target>
        </trans-unit>
        <trans-unit id="65822ab438826bd3303521dc362fbdb7385f9c68" translate="yes" xml:space="preserve">
          <source>To change the destination for flag messages, call CommandLine.SetOutput.</source>
          <target state="translated">要改变标志信息的目的地,请调用CommandLine.SetOutput。</target>
        </trans-unit>
        <trans-unit id="697c0150c9b1eec40f18c8aa7919a2878d3bf00a" translate="yes" xml:space="preserve">
          <source>To compare two Values, compare the results of the Interface method. Using == on two Values does not compare the underlying values they represent.</source>
          <target state="translated">要比较两个值,比较接口方法的结果。在两个值上使用==不会比较它们所代表的基本值。</target>
        </trans-unit>
        <trans-unit id="26bcf90200ee4c383ef61356b62c1cde915663a4" translate="yes" xml:space="preserve">
          <source>To complete the example above, the following code tries to find the value x in an integer slice data sorted in ascending order:</source>
          <target state="translated">为了完成上面的例子,下面的代码试图在一个升序排序的整数片数据中找到值x。</target>
        </trans-unit>
        <trans-unit id="48862e3dd334f932c3f29aca76cb78295d40632d" translate="yes" xml:space="preserve">
          <source>To compute the number of allocations, the function will first be run once as a warm-up. The average number of allocations over the specified number of runs will then be measured and returned.</source>
          <target state="translated">要计算分配数量,首先要运行一次函数作为热身。然后测量并返回指定运行次数的平均分配数量。</target>
        </trans-unit>
        <trans-unit id="a1b4d9690ab97f466c6d326d8c742f5be1f15108" translate="yes" xml:space="preserve">
          <source>To convert an integer number of units to a Duration, multiply:</source>
          <target state="translated">要将整数单位转换为持续时间,请乘以。</target>
        </trans-unit>
        <trans-unit id="c70ea98cf5f708e17c34d681b2e9583414cbfaae" translate="yes" xml:space="preserve">
          <source>To count the number of units in a Duration, divide:</source>
          <target state="translated">要计算一个Duration中的单位数,除以。</target>
        </trans-unit>
        <trans-unit id="a8a481566ee5c9f4011b251f076b7cff25d2b336" translate="yes" xml:space="preserve">
          <source>To create a new request with a context, use NewRequestWithContext. To change the context of a request (such as an incoming) you then also want to modify to send back out, use Request.Clone. Between those two uses, it's rare to need WithContext.</source>
          <target state="translated">要创建一个带有上下文的新请求,使用NewRequestWithContext。要改变一个请求的上下文(比如一个传入的请求),然后你也想修改后再发送出去,使用Request.Clone.WithContext。在这两种用法之间,很少需要WithContext。</target>
        </trans-unit>
        <trans-unit id="d1ce4e028f3adf6fe5e3e3ea8b7a3ce1d7c4cce0" translate="yes" xml:space="preserve">
          <source>To create the Pos value for a specific source offset (measured in bytes), first add the respective file to the current file set using FileSet.AddFile and then call File.Pos(offset) for that file. Given a Pos value p for a specific file set fset, the corresponding Position value is obtained by calling fset.Position(p).</source>
          <target state="translated">要为特定的源偏移量(以字节为单位)创建Pos值,首先使用FileSet.AddFile将相应的文件添加到当前的文件集中,然后为该文件调用File.Pos(offset)。给定一个特定文件集fset的Pos值p,通过调用fset.Position(p)获得相应的Position值。</target>
        </trans-unit>
        <trans-unit id="ffa6362a850b5571ec14ab520e75aaa3f0b772a0" translate="yes" xml:space="preserve">
          <source>To define a type, the encoder chooses an unused, positive type id and sends the pair (-type id, encoded-type) where encoded-type is the gob encoding of a wireType description, constructed from these types:</source>
          <target state="translated">为了定义一个类型,编码器选择一个未使用的正类型id,并发送一对(-type id,encoded-type),其中encoded-type是wireType描述的gob编码,由这些类型构造而成。</target>
        </trans-unit>
        <trans-unit id="da43583df08c2ff7e4692ba80d3b2cf801b80a61" translate="yes" xml:space="preserve">
          <source>To define your own format, write down what the reference time would look like formatted your way; see the values of constants like ANSIC, StampMicro or Kitchen for examples. The model is to demonstrate what the reference time looks like so that the Format and Parse methods can apply the same transformation to a general time value.</source>
          <target state="translated">要定义你自己的格式,请写下参考时间按你的方式格式化后的样子;参见ANSIC、StampMicro或Kitchen等常量的值来举例。这个模型是为了演示参考时间是什么样子的,这样Format和Parse方法就可以对一般的时间值进行同样的转换。</target>
        </trans-unit>
        <trans-unit id="79806cf1eaac70011a5e985d3751306c16fa37ee" translate="yes" xml:space="preserve">
          <source>To distinguish build constraints from package documentation, a series of build constraints must be followed by a blank line.</source>
          <target state="translated">为了将构建约束与包文档区分开来,一系列的构建约束后面必须有一个空行。</target>
        </trans-unit>
        <trans-unit id="a50607887789cbea54ccb0db0c455e312a84417e" translate="yes" xml:space="preserve">
          <source>To ensure the channel is empty after a call to Stop, check the return value and drain the channel. For example, assuming the program has not received from t.C already:</source>
          <target state="translated">为了确保在调用Stop后通道是空的,检查返回值并排出通道。例如,假设程序还没有从t.C接收到。</target>
        </trans-unit>
        <trans-unit id="dc7659d0594b1222a7c79baf65726fd2fc8fc92f" translate="yes" xml:space="preserve">
          <source>To escape a text segment, bracket it with Escape characters. For instance, the tab in this string &quot;Ignore this tab: \xff\t\xff&quot; does not terminate a cell and constitutes a single character of width one for formatting purposes.</source>
          <target state="translated">要转义一个文本段,请用Escape字符将其括起来。例如,这个字符串中的制表符 &quot;忽略这个制表符。\xffff/t/xff &quot;并没有结束一个单元格,而是构成一个宽度为1的单字符,用于格式化。</target>
        </trans-unit>
        <trans-unit id="a3866d2c65d6d17db1dce0e7ab464336a1186960" translate="yes" xml:space="preserve">
          <source>To force integer division of Int operands, use op == token.QUO_ASSIGN instead of token.QUO; the result is guaranteed to be Int in this case. Division by zero leads to a run-time panic.</source>
          <target state="translated">要强制Int操作数的整数除法,使用op ==token.QUO_ASSIGN取代token.QUO;在这种情况下,保证结果是Int。除以零会导致运行时的恐慌。</target>
        </trans-unit>
        <trans-unit id="93f96dd1110bc83e45c261305087ab59ccdab5c6" translate="yes" xml:space="preserve">
          <source>To generate HTML output, see package html/template, which has the same interface as this package but automatically secures HTML output against certain attacks.</source>
          <target state="translated">要生成HTML输出,请参见包html/template,它的界面与本包相同,但能自动保证HTML输出不受某些攻击。</target>
        </trans-unit>
        <trans-unit id="0f37e1016d8b746740d606c5f03bd61a370f62be" translate="yes" xml:space="preserve">
          <source>To generate a client HTTP request instead of a server request, see the NewRequest function in the net/http package.</source>
          <target state="translated">要生成一个客户端的HTTP请求而不是服务器请求,请参见net/http包中的NewRequest函数。</target>
        </trans-unit>
        <trans-unit id="06a96f64d7d0f413489f0372ff0c9c5459591c5b" translate="yes" xml:space="preserve">
          <source>To include every allocated block in the profile, set MemProfileRate to 1. To turn off profiling entirely, set MemProfileRate to 0.</source>
          <target state="translated">要将每个分配的块都包含在配置文件中,将MemProfileRate设置为1。 要完全关闭配置文件,将MemProfileRate设置为0。</target>
        </trans-unit>
        <trans-unit id="1cf82e7adf1a06dc5b4204dd8949c669c22a6ce1" translate="yes" xml:space="preserve">
          <source>To include every blocking event in the profile, pass rate = 1. To turn off profiling entirely, pass rate &amp;lt;= 0.</source>
          <target state="translated">要将每个阻止事件包括在配置文件中，合格率=1。要完全关闭分析，合格率&amp;lt;= 0。</target>
        </trans-unit>
        <trans-unit id="5634feb2ac7b66d9d403fa3ba44d3dd35de4aafa" translate="yes" xml:space="preserve">
          <source>To insert a literal $ in the output, use $$ in the template.</source>
          <target state="translated">要在输出中插入一个字面的$,请在模板中使用$。</target>
        </trans-unit>
        <trans-unit id="fc7c25c25b23cfac629203b1f680a734ada8bcd7" translate="yes" xml:space="preserve">
          <source>To iterate over a list (where l is a *List):</source>
          <target state="translated">遍历一个列表(其中l是一个*List)。</target>
        </trans-unit>
        <trans-unit id="04464b93c140cce60515e90ab741d559641a3b86" translate="yes" xml:space="preserve">
          <source>To keep a file from being considered for the build:</source>
          <target state="translated">为了防止一个文件被认为是构建。</target>
        </trans-unit>
        <trans-unit id="b8dd565d2e14c4949f658d07fd948bd6982afd99" translate="yes" xml:space="preserve">
          <source>To make a request with custom headers, use NewRequest and Client.Do.</source>
          <target state="translated">要使用自定义头信息进行请求,请使用NewRequest和Client.Do。</target>
        </trans-unit>
        <trans-unit id="5032a2d57ff9e66d730ea600879b156b0a5e02a1" translate="yes" xml:space="preserve">
          <source>To make a request with custom headers, use NewRequest and DefaultClient.Do.</source>
          <target state="translated">要使用自定义头信息进行请求,请使用NewRequest和DefaultClient.Do。</target>
        </trans-unit>
        <trans-unit id="706ee8ff1d514d4082de19c46038d881341df0b9" translate="yes" xml:space="preserve">
          <source>To maps the rune to the specified case: UpperCase, LowerCase, or TitleCase.</source>
          <target state="translated">要将符文映射到指定的大小写。大写,小写,或标题大小写。</target>
        </trans-unit>
        <trans-unit id="16db8fa630b8ed6e5e098c9ecc986852e23449ff" translate="yes" xml:space="preserve">
          <source>To prevent duplicate operations, ErrBadConn should NOT be returned if there's a possibility that the database server might have performed the operation. Even if the server sends back an error, you shouldn't return ErrBadConn.</source>
          <target state="translated">为了防止重复操作,如果数据库服务器有可能执行了操作,就不应该返回ErrBadConn。即使服务器发回一个错误,也不应该返回ErrBadConn。</target>
        </trans-unit>
        <trans-unit id="367a95ef6b89677c6010e99bfe83911bb6aa0ff5" translate="yes" xml:space="preserve">
          <source>To remove a prefix, use TrimPrefix instead.</source>
          <target state="translated">要删除前缀,请使用 TrimPrefix。</target>
        </trans-unit>
        <trans-unit id="651b4bc851ab5004fd129e9e0ff7675d7d666cef" translate="yes" xml:space="preserve">
          <source>To remove a suffix, use TrimSuffix instead.</source>
          <target state="translated">要删除后缀,请使用 TrimSuffix。</target>
        </trans-unit>
        <trans-unit id="c83bbc4183fb8f4e0540869ebe8099226ccd8816" translate="yes" xml:space="preserve">
          <source>To set custom headers, use NewRequest and Client.Do.</source>
          <target state="translated">要设置自定义的头,使用NewRequest和Client.Do。</target>
        </trans-unit>
        <trans-unit id="71135b9f4481c76b2f670b0d39a1f656b3961a0f" translate="yes" xml:space="preserve">
          <source>To set custom headers, use NewRequest and DefaultClient.Do.</source>
          <target state="translated">要设置自定义的头,使用NewRequest和DefaultClient.Do。</target>
        </trans-unit>
        <trans-unit id="83002d8cdc0fe4d874cff59ee6e149e3669f91df" translate="yes" xml:space="preserve">
          <source>To translate these PCs into symbolic information such as function names and line numbers, use CallersFrames. CallersFrames accounts for inlined functions and adjusts the return program counters into call program counters. Iterating over the returned slice of PCs directly is discouraged, as is using FuncForPC on any of the returned PCs, since these cannot account for inlining or return program counter adjustment. go:noinline</source>
          <target state="translated">要将这些PC转化为函数名和行号等符号信息,可以使用CallersFrames。CallersFrames对内联函数进行核算,并将返回的程序计数器调整为调用程序计数器。不鼓励直接在返回的PC片上进行迭代,也不鼓励在任何返回的PC上使用FuncForPC,因为这些不能说明内联或返回程序计数器的调整。 go:noinline</target>
        </trans-unit>
        <trans-unit id="3b553336a2ed0371927e0210cc490999d6f454c6" translate="yes" xml:space="preserve">
          <source>To turn off profiling entirely, pass rate 0. To just read the current rate, pass rate &amp;lt; 0. (For n&amp;gt;1 the details of sampling may change.)</source>
          <target state="translated">要完全关闭性能分析，请通过率0。要仅读取当前速率，请通过率&amp;lt;0。（对于n&amp;gt; 1，采样的详细信息可能会更改。）</target>
        </trans-unit>
        <trans-unit id="ec0c40fcb609291204c17f8d3e9e4a0cf0fb716d" translate="yes" xml:space="preserve">
          <source>To unmarshal JSON into a pointer, Unmarshal first handles the case of the JSON being the JSON literal null. In that case, Unmarshal sets the pointer to nil. Otherwise, Unmarshal unmarshals the JSON into the value pointed at by the pointer. If the pointer is nil, Unmarshal allocates a new value for it to point to.</source>
          <target state="translated">要将JSON解压缩成一个指针,Unmarshal首先要处理JSON是JSON文字空的情况。在这种情况下,Unmarshal会将指针设置为nil。否则,Unmarshal会将JSON解马尔什化为指针指向的值。如果指针为nil,Unmarshal为其分配一个新的值。</target>
        </trans-unit>
        <trans-unit id="9ec7dbd6621b41728144a0cd3fc2c36f64948e68" translate="yes" xml:space="preserve">
          <source>To unmarshal JSON into a struct, Unmarshal matches incoming object keys to the keys used by Marshal (either the struct field name or its tag), preferring an exact match but also accepting a case-insensitive match. By default, object keys which don't have a corresponding struct field are ignored (see Decoder.DisallowUnknownFields for an alternative).</source>
          <target state="translated">为了将JSON解压缩成结构体,Unmarshal将传入的对象键与Marshal使用的键(结构体字段名或它的标签)进行匹配,喜欢完全匹配,但也接受不区分大小写的匹配。默认情况下,没有对应的结构体字段的对象键会被忽略(参见Decoder.DisallowUnknownFields获取替代方案)。</target>
        </trans-unit>
        <trans-unit id="a6bdbb20d4135a3bc4596a68aa8c2c34912d504d" translate="yes" xml:space="preserve">
          <source>To unmarshal JSON into a value implementing the Unmarshaler interface, Unmarshal calls that value's UnmarshalJSON method, including when the input is a JSON null. Otherwise, if the value implements encoding.TextUnmarshaler and the input is a JSON quoted string, Unmarshal calls that value's UnmarshalText method with the unquoted form of the string.</source>
          <target state="translated">要将JSON解马尔什到一个实现Unmarshaler接口的值中,Unmarshal调用该值的UnmarshalJSON方法,包括当输入是JSON null时。否则,如果值实现了encoding.TextUnmarshaler,并且输入是JSON引号的字符串,Unmarshal就用字符串的未引号形式调用该值的UnmarshalText方法。</target>
        </trans-unit>
        <trans-unit id="c66b5ce0cf55557d8e9fd777ec15355bade4e117" translate="yes" xml:space="preserve">
          <source>To unmarshal JSON into an interface value, Unmarshal stores one of these in the interface value:</source>
          <target state="translated">要将JSON解读成一个接口值,Unmarshal会在接口值中存储其中一个。</target>
        </trans-unit>
        <trans-unit id="94c1b420cdca6fe4940f209d9a41f19875bfb4e7" translate="yes" xml:space="preserve">
          <source>To unmarshal a JSON array into a Go array, Unmarshal decodes JSON array elements into corresponding Go array elements. If the Go array is smaller than the JSON array, the additional JSON array elements are discarded. If the JSON array is smaller than the Go array, the additional Go array elements are set to zero values.</source>
          <target state="translated">要将JSON数组拆解为Go数组,Unmarshal将JSON数组元素解码为相应的Go数组元素。如果Go数组小于JSON数组,那么额外的JSON数组元素将被丢弃。如果JSON数组小于Go数组,则额外的Go数组元素被设置为零值。</target>
        </trans-unit>
        <trans-unit id="ed4bdd964a47161b70a00bdaa7dc00eb114dff57" translate="yes" xml:space="preserve">
          <source>To unmarshal a JSON array into a slice, Unmarshal resets the slice length to zero and then appends each element to the slice. As a special case, to unmarshal an empty JSON array into a slice, Unmarshal replaces the slice with a new empty slice.</source>
          <target state="translated">要将一个JSON数组解马尔什化为一个分片,Unmarshal将分片长度重置为零,然后将每个元素追加到分片中。作为一种特殊情况,如果要将一个空的JSON数组解马尔什化为一个分片,Unmarshal会用一个新的空分片来替换这个分片。</target>
        </trans-unit>
        <trans-unit id="007b32960f68d5d51b318bb76ca9ea0286f4126d" translate="yes" xml:space="preserve">
          <source>To unmarshal a JSON object into a map, Unmarshal first establishes a map to use. If the map is nil, Unmarshal allocates a new map. Otherwise Unmarshal reuses the existing map, keeping existing entries. Unmarshal then stores key-value pairs from the JSON object into the map. The map's key type must either be a string, an integer, or implement encoding.TextUnmarshaler.</source>
          <target state="translated">要将一个JSON对象拆解成地图,Unmarshal首先要建立一个要使用的地图。如果地图是nil,Unmarshal会分配一个新的地图。否则,Unmarshal会重新使用现有的地图,保留现有的条目。然后Unmarshal将JSON对象中的键值对存储到map中。地图的键类型必须是字符串、整数或实现 encoding.TextUnmarshaler。</target>
        </trans-unit>
        <trans-unit id="b87bf4d25ca4624c96c72d4062afc898f384fa73" translate="yes" xml:space="preserve">
          <source>To use a Pipeline p to manage multiple clients on a connection, each client should run:</source>
          <target state="translated">要使用Pipeline p来管理一个连接上的多个客户端,每个客户端都应该运行。</target>
        </trans-unit>
        <trans-unit id="800eefdd201759f89cf9257524a524d86be67a56" translate="yes" xml:space="preserve">
          <source>To use an existing prepared statement on this transaction, see Tx.Stmt.</source>
          <target state="translated">若要使用现有的已编制的报表进行交易,请参见Tx.Stmt.</target>
        </trans-unit>
        <trans-unit id="0c3bf1a32c9b769f727db4118e0b83ca4bb4efa4" translate="yes" xml:space="preserve">
          <source>To use gobs, create an Encoder and present it with a series of data items as values or addresses that can be dereferenced to values. The Encoder makes sure all type information is sent before it is needed. At the receive side, a Decoder retrieves values from the encoded stream and unpacks them into local variables.</source>
          <target state="translated">要使用gobs,请创建一个Encoder,并将一系列数据项以值或地址的形式呈现给它,这些值或地址可以被导出引用到值。Encoder确保所有的类型信息在需要之前被发送。在接收端,解码器从编码流中检索值,并将它们解包到本地变量中。</target>
        </trans-unit>
        <trans-unit id="8212c55a0bf9e12d2e296b39237ee5f72cae9d11" translate="yes" xml:space="preserve">
          <source>To use pprof, link this package into your program:</source>
          <target state="translated">要使用pprof,请将这个软件包链接到你的程序中。</target>
        </trans-unit>
        <trans-unit id="5c29e8288fd1ed9e073fe203fb55fbea12d062de" translate="yes" xml:space="preserve">
          <source>To use the operating system's file system implementation, use http.Dir:</source>
          <target state="translated">要使用操作系统的文件系统实现,使用http.Dir。</target>
        </trans-unit>
        <trans-unit id="467272919dc8f37262b26b52d65afd618589f7ff" translate="yes" xml:space="preserve">
          <source>To view all available profiles, open &lt;a href=&quot;http://localhost:6060/debug/pprof/&quot;&gt;http://localhost:6060/debug/pprof/&lt;/a&gt; in your browser.</source>
          <target state="translated">要查看所有可用的配置文件，请在浏览器中打开&lt;a href=&quot;http://localhost:6060/debug/pprof/&quot;&gt;http：// localhost：6060 / debug / pprof /&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f1229c7d06cb687b015bf9729398a1b9b76a455a" translate="yes" xml:space="preserve">
          <source>To write a new test suite, create a file whose name ends _test.go that contains the TestXxx functions as described here. Put the file in the same package as the one being tested. The file will be excluded from regular package builds but will be included when the &amp;ldquo;go test&amp;rdquo; command is run. For more detail, run &amp;ldquo;go help test&amp;rdquo; and &amp;ldquo;go help testflag&amp;rdquo;.</source>
          <target state="translated">要编写新的测试套件，请创建一个名称以_test.go结尾的文件，其中包含TestXxx函数，如此处所述。将文件与要测试的文件放在同一软件包中。该文件将从常规软件包生成中排除，但在运行&amp;ldquo; go test&amp;rdquo;命令时将包括在内。有关更多详细信息，请运行&amp;ldquo; go help test&amp;rdquo;和&amp;ldquo; go help testflag&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="2392dbedc5657df0a5a8c5b158593f759c811858" translate="yes" xml:space="preserve">
          <source>To16 converts the IP address ip to a 16-byte representation. If ip is not an IP address (it is the wrong length), To16 returns nil.</source>
          <target state="translated">To16 将 IP 地址 ip 转换为 16 字节的表示形式。如果ip不是一个IP地址(长度不对),To16返回nil。</target>
        </trans-unit>
        <trans-unit id="4294dda7ebb07f9702b0ce5cc1cb8bbf6e004822" translate="yes" xml:space="preserve">
          <source>To4 converts the IPv4 address ip to a 4-byte representation. If ip is not an IPv4 address, To4 returns nil.</source>
          <target state="translated">To4 将 IPv4 地址 ip 转换为一个 4 字节的表示形式,如果 ip 不是 IPv4 地址,To4 返回 nil。如果ip不是IPv4地址,To4返回nil。</target>
        </trans-unit>
        <trans-unit id="7deadbf704990f79d3e4df9686f8846e15431131" translate="yes" xml:space="preserve">
          <source>ToComplex converts x to a Complex value if x is representable as a Complex. Otherwise it returns an Unknown.</source>
          <target state="translated">如果x可以表示为复数,ToComplex将x转换为一个复数值,否则返回一个未知值。否则返回一个未知值。</target>
        </trans-unit>
        <trans-unit id="95e3b1fabb27004c6322f401e410b77c8beecafb" translate="yes" xml:space="preserve">
          <source>ToFloat converts x to a Float value if x is representable as a Float. Otherwise it returns an Unknown.</source>
          <target state="translated">如果x可表示为Float,ToFloat将x转换为Float值。否则它返回一个未知值。</target>
        </trans-unit>
        <trans-unit id="f5e30e0ab3c38971ff0a23a0823ee7ab2da27587" translate="yes" xml:space="preserve">
          <source>ToHTML converts comment text to formatted HTML. The comment was prepared by DocReader, so it is known not to have leading, trailing blank lines nor to have trailing spaces at the end of lines. The comment markers have already been removed.</source>
          <target state="translated">ToHTML将注释文本转换为格式化的HTML。该注释是由DocReader编写的,所以已知它没有前导、尾部的空行,也没有行末的尾部空格。注释标记已经被删除。</target>
        </trans-unit>
        <trans-unit id="2f4af6e587a0b093dcea21d741f457946dac2539" translate="yes" xml:space="preserve">
          <source>ToInt converts x to an Int value if x is representable as an Int. Otherwise it returns an Unknown.</source>
          <target state="translated">如果x可以表示为Int,则ToInt将x转换为Int值。否则返回一个未知值。</target>
        </trans-unit>
        <trans-unit id="2458b21542ecbc0f90f413b7ee46521686d711b0" translate="yes" xml:space="preserve">
          <source>ToLower</source>
          <target state="translated">ToLower</target>
        </trans-unit>
        <trans-unit id="6fec192e916332e15759b9ef1699226d11bdd209" translate="yes" xml:space="preserve">
          <source>ToLower maps the rune to lower case giving priority to the special mapping.</source>
          <target state="translated">ToLower将符文映射为小写,优先考虑特殊映射。</target>
        </trans-unit>
        <trans-unit id="0d0c9cd1331838718de8a67a4fe3f8edaf0bf598" translate="yes" xml:space="preserve">
          <source>ToLower maps the rune to lower case.</source>
          <target state="translated">ToLower将符文映射为小写。</target>
        </trans-unit>
        <trans-unit id="0ad2eff81c68ba7feeec4169aa737e669765ecb3" translate="yes" xml:space="preserve">
          <source>ToLower returns a copy of the byte slice s with all Unicode letters mapped to their lower case.</source>
          <target state="translated">ToLower 返回所有 Unicode 字母映射为小写的字节片断 s 的副本。</target>
        </trans-unit>
        <trans-unit id="9ce8fb31583c9a3f9db4dda94a7dc14fcb01df77" translate="yes" xml:space="preserve">
          <source>ToLower returns s with all Unicode letters mapped to their lower case.</source>
          <target state="translated">ToLower 返回所有 Unicode 字母映射为小写的 s。</target>
        </trans-unit>
        <trans-unit id="7c6c5994143b17fa29690098b9cf21d8ab0c9626" translate="yes" xml:space="preserve">
          <source>ToLowerSpecial</source>
          <target state="translated">ToLowerSpecial</target>
        </trans-unit>
        <trans-unit id="a0c9710a46fb772958369a0897c7471714aeeeb8" translate="yes" xml:space="preserve">
          <source>ToLowerSpecial returns a copy of the string s with all Unicode letters mapped to their lower case using the case mapping specified by c.</source>
          <target state="translated">ToLowerSpecial返回字符串s的副本,并使用c指定的大小写映射将所有Unicode字母映射为小写。</target>
        </trans-unit>
        <trans-unit id="cb046f134facad4d83f3df18153937dc0992ea81" translate="yes" xml:space="preserve">
          <source>ToLowerSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their lower case, giving priority to the special casing rules.</source>
          <target state="translated">ToLowerSpecial将s视为UTF-8编码的字节,并返回一个包含所有Unicode字母映射为小写字母的副本,优先考虑特殊的编码规则。</target>
        </trans-unit>
        <trans-unit id="2915308ca78a335773afea42473f5f868e85f100" translate="yes" xml:space="preserve">
          <source>ToSlash returns the result of replacing each separator character in path with a slash ('/') character. Multiple separators are replaced by multiple slashes.</source>
          <target state="translated">ToSlash 返回用斜线('/')替换路径中每个分隔符的结果。多个分隔符会被多个斜线代替。</target>
        </trans-unit>
        <trans-unit id="ce9610dd835f1269c70383a5f4c28b5a0b063015" translate="yes" xml:space="preserve">
          <source>ToText prepares comment text for presentation in textual output. It wraps paragraphs of text to width or fewer Unicode code points and then prefixes each line with the indent. In preformatted sections (such as program text), it prefixes each non-blank line with preIndent.</source>
          <target state="translated">ToText 为文本输出中的注释文本做准备。它将文本段落包装成宽度或更少的Unicode码点,然后在每行前加上缩进。在预格式化的部分(如程序文本)中,它将每一行非空白行前缀为preIndent。</target>
        </trans-unit>
        <trans-unit id="687882b6dd58f630b4dc72d2b748bc2e5e517506" translate="yes" xml:space="preserve">
          <source>ToTitle</source>
          <target state="translated">ToTitle</target>
        </trans-unit>
        <trans-unit id="16626ca02836f3e96b71ac083f67d856672bee6a" translate="yes" xml:space="preserve">
          <source>ToTitle maps the rune to title case giving priority to the special mapping.</source>
          <target state="translated">ToTitle将符文映射到标题案,优先考虑特殊映射。</target>
        </trans-unit>
        <trans-unit id="82652cb33ebff96d0745bbb70b7b14b2b4f648b7" translate="yes" xml:space="preserve">
          <source>ToTitle maps the rune to title case.</source>
          <target state="translated">ToTitle将符文映射到标题案。</target>
        </trans-unit>
        <trans-unit id="b6339ce57388ab9579ed7dea7397386892cd79b3" translate="yes" xml:space="preserve">
          <source>ToTitle returns a copy of the string s with all Unicode letters mapped to their Unicode title case.</source>
          <target state="translated">ToTitle返回字符串s的副本,所有Unicode字母都映射到Unicode标题大小写。</target>
        </trans-unit>
        <trans-unit id="7c8bdbfdcd905744bd6bd92b5f2c2fe7b0b2a605" translate="yes" xml:space="preserve">
          <source>ToTitle treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their title case.</source>
          <target state="translated">ToTitle将s视为UTF-8编码的字节,并返回一个包含所有Unicode字母映射到标题大小写的副本。</target>
        </trans-unit>
        <trans-unit id="a7e031c3da9f939af57fa1eda658027190b07385" translate="yes" xml:space="preserve">
          <source>ToTitleSpecial</source>
          <target state="translated">ToTitleSpecial</target>
        </trans-unit>
        <trans-unit id="6c2252d5e081e10993ad66199a6ce0f9c88000da" translate="yes" xml:space="preserve">
          <source>ToTitleSpecial returns a copy of the string s with all Unicode letters mapped to their Unicode title case, giving priority to the special casing rules.</source>
          <target state="translated">ToTitleSpecial返回字符串s的副本,其中所有Unicode字母都被映射到Unicode标题大小写中,优先考虑特殊的编码规则。</target>
        </trans-unit>
        <trans-unit id="03ad764cc2cf6e71773b140dd2607d85f903d19e" translate="yes" xml:space="preserve">
          <source>ToTitleSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their title case, giving priority to the special casing rules.</source>
          <target state="translated">ToTitleSpecial将s视为UTF-8编码的字节,并返回一个包含所有Unicode字母映射到其标题大小写的副本,优先考虑特殊的编码规则。</target>
        </trans-unit>
        <trans-unit id="0c72db5394ee29e5b12a191ab1a0f08579c43c0b" translate="yes" xml:space="preserve">
          <source>ToUpper</source>
          <target state="translated">ToUpper</target>
        </trans-unit>
        <trans-unit id="8830c3933f2751182fd45204e5ac41041c190ab0" translate="yes" xml:space="preserve">
          <source>ToUpper maps the rune to upper case giving priority to the special mapping.</source>
          <target state="translated">ToUpper将符文映射为大写,优先考虑特殊映射。</target>
        </trans-unit>
        <trans-unit id="9762b6a1a0f8f68d12efc0853373d81b1198caf9" translate="yes" xml:space="preserve">
          <source>ToUpper maps the rune to upper case.</source>
          <target state="translated">ToUpper将符文映射为大写。</target>
        </trans-unit>
        <trans-unit id="587e23bede12f256b7a2b187d202dc77575c043c" translate="yes" xml:space="preserve">
          <source>ToUpper returns a copy of the byte slice s with all Unicode letters mapped to their upper case.</source>
          <target state="translated">ToUpper 返回所有 Unicode 字母映射为大写的字节片断 s 的副本。</target>
        </trans-unit>
        <trans-unit id="1567cbaa93e2803c0387b5e052b94febf77b0dce" translate="yes" xml:space="preserve">
          <source>ToUpper returns s with all Unicode letters mapped to their upper case.</source>
          <target state="translated">ToUpper 返回所有 Unicode 字母映射为大写的 s。</target>
        </trans-unit>
        <trans-unit id="e8e18cf71c085c852139f777c3a777629eaba1d4" translate="yes" xml:space="preserve">
          <source>ToUpperSpecial</source>
          <target state="translated">ToUpperSpecial</target>
        </trans-unit>
        <trans-unit id="ca298ca7f1f797ffc04335283b821c4509371407" translate="yes" xml:space="preserve">
          <source>ToUpperSpecial returns a copy of the string s with all Unicode letters mapped to their upper case using the case mapping specified by c.</source>
          <target state="translated">ToUpperSpecial返回字符串s的副本,并使用c指定的大小写映射将所有Unicode字母映射为大写。</target>
        </trans-unit>
        <trans-unit id="e092426a213e149b750e5c739fd48245f35d6f1d" translate="yes" xml:space="preserve">
          <source>ToUpperSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their upper case, giving priority to the special casing rules.</source>
          <target state="translated">ToUpperSpecial将s视为UTF-8编码的字节,并返回一个包含所有Unicode字母映射为大写字母的副本,优先考虑特殊的编码规则。</target>
        </trans-unit>
        <trans-unit id="2918f3c11590ab69ac359dd26f3078e378d4433f" translate="yes" xml:space="preserve">
          <source>ToValidUTF8 returns a copy of the string s with each run of invalid UTF-8 byte sequences replaced by the replacement string, which may be empty.</source>
          <target state="translated">ToValidUTF8返回字符串s的副本,每运行一次无效的UTF-8字节序列就被替换字符串所取代,该字符串可能是空的。</target>
        </trans-unit>
        <trans-unit id="8ddb5599f330dcf8a14e657f65440d11567b1275" translate="yes" xml:space="preserve">
          <source>ToValidUTF8 treats s as UTF-8-encoded bytes and returns a copy with each run of bytes representing invalid UTF-8 replaced with the bytes in replacement, which may be empty.</source>
          <target state="translated">ToValidUTF8将s视为UTF-8编码的字节,并返回一个副本,每运行一次代表无效UTF-8的字节就替换成替换中的字节,替换中的字节可能是空的。</target>
        </trans-unit>
        <trans-unit id="0e6e43d719b59d2f4b6d64b0d7506414e902ac66" translate="yes" xml:space="preserve">
          <source>Token expands self-closing elements such as &amp;lt;br/&amp;gt; into separate start and end elements returned by successive calls.</source>
          <target state="translated">令牌将诸如&amp;lt;br/&amp;gt;之类的自闭合元素扩展为由连续调用返回的单独的开始和结束元素。</target>
        </trans-unit>
        <trans-unit id="76c580b187cf47d391aca0669ed50d6bdc842bd1" translate="yes" xml:space="preserve">
          <source>Token guarantees that the StartElement and EndElement tokens it returns are properly nested and matched: if Token encounters an unexpected end element or EOF before all expected end elements, it will return an error.</source>
          <target state="translated">Token保证它返回的StartElement和EndElement标记是正确嵌套和匹配的:如果Token遇到一个意外的结束元素或在所有预期的结束元素之前的EOF,它将返回一个错误。</target>
        </trans-unit>
        <trans-unit id="20226a10555b22d829b042743665e60ca5ccfcef" translate="yes" xml:space="preserve">
          <source>Token guarantees that the delimiters [ ] { } it returns are properly nested and matched: if Token encounters an unexpected delimiter in the input, it will return an error.</source>
          <target state="translated">Token 保证它返回的定界符[]{}是正确嵌套和匹配的:如果 Token 在输入中遇到一个意外的定界符,它将返回一个错误。</target>
        </trans-unit>
        <trans-unit id="d280a9431f5d23758a555c6128dd19caf82e90f5" translate="yes" xml:space="preserve">
          <source>Token implements XML name spaces as described by &lt;a href=&quot;https://www.w3.org/TR/REC-xml-names/&quot;&gt;https://www.w3.org/TR/REC-xml-names/&lt;/a&gt;. Each of the Name structures contained in the Token has the Space set to the URL identifying its name space when known. If Token encounters an unrecognized name space prefix, it uses the prefix as the Space rather than report an error.</source>
          <target state="translated">令牌实现了&lt;a href=&quot;https://www.w3.org/TR/REC-xml-names/&quot;&gt;https://www.w3.org/TR/REC-xml-names/中&lt;/a&gt;描述的XML名称空间。令牌中包含的每个名称结构都有一个设置为URL的空格，以便在知道时标识其名称空间。如果令牌遇到无法识别的名称空间前缀，它将使用该前缀作为空格，而不是报告错误。</target>
        </trans-unit>
        <trans-unit id="3daac00da8a20a3986aa0fc3ba367725df5511ad" translate="yes" xml:space="preserve">
          <source>Token is the set of lexical tokens of the Go programming language.</source>
          <target state="translated">Token是围棋编程语言的词性标记集。</target>
        </trans-unit>
        <trans-unit id="347b518b7ad14bbb5cbe2525a0e1cce83a18759e" translate="yes" xml:space="preserve">
          <source>Token returns the next JSON token in the input stream. At the end of the input stream, Token returns nil, io.EOF.</source>
          <target state="translated">Token返回输入流中的下一个JSON token,在输入流结束时,Token返回nil,io.EOF。在输入流结束时,Token返回nil,io.EOF。</target>
        </trans-unit>
        <trans-unit id="fb460c5b7cbda3e107ef11644b412428d80a074a" translate="yes" xml:space="preserve">
          <source>Token returns the next XML token in the input stream. At the end of the input stream, Token returns nil, io.EOF.</source>
          <target state="translated">Token返回输入流中的下一个XML token,在输入流结束时,Token返回nil,io.EOF。在输入流结束时,Token返回nil,io.EOF。</target>
        </trans-unit>
        <trans-unit id="1f5c5f661288844b6f2ecd574998016319ee9039" translate="yes" xml:space="preserve">
          <source>TokenString returns a printable string for a token or Unicode character.</source>
          <target state="translated">TokenString 返回一个可打印的标记或Unicode字符的字符串。</target>
        </trans-unit>
        <trans-unit id="1a94c716310bd537564c947b302962f8f4ba3d71" translate="yes" xml:space="preserve">
          <source>TokenText returns the string corresponding to the most recently scanned token. Valid after calling Scan and in calls of Scanner.Error.</source>
          <target state="translated">TokenText 返回最近扫描的标记对应的字符串。在调用Scan后和调用Scanner.Error.TokenText时有效。</target>
        </trans-unit>
        <trans-unit id="a7a728d87ab600f19a872de7d10dd426fc51a410" translate="yes" xml:space="preserve">
          <source>ToolDir is the directory containing build tools.</source>
          <target state="translated">ToolDir是包含构建工具的目录。</target>
        </trans-unit>
        <trans-unit id="84f632ebde53766b4762c1e662046a0bdb1f9bee" translate="yes" xml:space="preserve">
          <source>Trace responds with the execution trace in binary form. Tracing lasts for duration specified in seconds GET parameter, or for 1 second if not specified. The package initialization registers it as /debug/pprof/trace.</source>
          <target state="translated">跟踪以二进制形式响应执行跟踪。追踪的持续时间用GET参数second指定,如果没有指定则为1秒。软件包初始化时将其注册为/debug/pprof/trace。</target>
        </trans-unit>
        <trans-unit id="37fcf61c233a1ae946b84a69b2de57281c31900c" translate="yes" xml:space="preserve">
          <source>Tracing runtime activities</source>
          <target state="translated">追踪运行时活动</target>
        </trans-unit>
        <trans-unit id="bf930f74e883c038922957814259a08b1e5e21b8" translate="yes" xml:space="preserve">
          <source>TrailerPrefix is a magic prefix for ResponseWriter.Header map keys that, if present, signals that the map entry is actually for the response trailers, and not the response headers. The prefix is stripped after the ServeHTTP call finishes and the values are sent in the trailers.</source>
          <target state="translated">TrailerPrefix是ResponseWriter.Header映射键的一个神奇的前缀,如果存在,则表明该映射条目实际上是针对响应拖车的,而不是响应头。这个前缀会在ServeHTTP调用完成后被剥离,并在拖车中发送值。</target>
        </trans-unit>
        <trans-unit id="d08af63de6fd07c70bf3724749899391ccd80f36" translate="yes" xml:space="preserve">
          <source>TrailingZeroBits returns the number of consecutive least significant zero bits of |x|.</source>
          <target state="translated">TrailingZeroBits 返回 |x| 的连续最小有效零位数。</target>
        </trans-unit>
        <trans-unit id="173da913d8c53620762557efaa7f685234fe0888" translate="yes" xml:space="preserve">
          <source>TrailingZeros returns the number of trailing zero bits in x; the result is UintSize for x == 0.</source>
          <target state="translated">TrailingZeros 返回 x 中的尾部零位数;对于 x ==0,结果是 UintSize。</target>
        </trans-unit>
        <trans-unit id="3880be13b458ed7d8fd6226152f09a84df60affe" translate="yes" xml:space="preserve">
          <source>TrailingZeros16</source>
          <target state="translated">TrailingZeros16</target>
        </trans-unit>
        <trans-unit id="ac0e8b17c92ec54246a916c7c60a5898e47d2440" translate="yes" xml:space="preserve">
          <source>TrailingZeros16 returns the number of trailing zero bits in x; the result is 16 for x == 0.</source>
          <target state="translated">TrailingZeros16 返回x中的尾部零位数;对于x ==0,结果是16。</target>
        </trans-unit>
        <trans-unit id="9ccb48d1009c49f2458e70054ffb06de2c2e52b1" translate="yes" xml:space="preserve">
          <source>TrailingZeros32</source>
          <target state="translated">TrailingZeros32</target>
        </trans-unit>
        <trans-unit id="ef12b2bd72258ab1ea24487faaf1b36b6624d53b" translate="yes" xml:space="preserve">
          <source>TrailingZeros32 returns the number of trailing zero bits in x; the result is 32 for x == 0.</source>
          <target state="translated">TrailingZeros32 返回x中的尾部零位数;对于x ==0,结果是32。</target>
        </trans-unit>
        <trans-unit id="8645dda5fc4ccfbadfe816f019759dd903a6b384" translate="yes" xml:space="preserve">
          <source>TrailingZeros64</source>
          <target state="translated">TrailingZeros64</target>
        </trans-unit>
        <trans-unit id="9c1806ac56295eeda1305a5c016e361813241700" translate="yes" xml:space="preserve">
          <source>TrailingZeros64 returns the number of trailing zero bits in x; the result is 64 for x == 0.</source>
          <target state="translated">TrailingZeros64 返回x中的尾部零位数;对于x ==0,结果是64。</target>
        </trans-unit>
        <trans-unit id="56b19e298a41e007826d31fb347a4fad087efb44" translate="yes" xml:space="preserve">
          <source>TrailingZeros8</source>
          <target state="translated">TrailingZeros8</target>
        </trans-unit>
        <trans-unit id="a51f3a70d56ba40f5381588670a32ee940f76014" translate="yes" xml:space="preserve">
          <source>TrailingZeros8 returns the number of trailing zero bits in x; the result is 8 for x == 0.</source>
          <target state="translated">TrailingZeros8返回x中的尾部零位数;对于x==0,结果是8。</target>
        </trans-unit>
        <trans-unit id="c46e526f87b0902843d5c82001fbd44e74d2f2d7" translate="yes" xml:space="preserve">
          <source>Transport is an implementation of RoundTripper that supports HTTP, HTTPS, and HTTP proxies (for either HTTP or HTTPS with CONNECT).</source>
          <target state="translated">Transport是RoundTripper的一个实现,支持HTTP、HTTPS和HTTP代理(对于HTTP或HTTPS与CONNECT)。</target>
        </trans-unit>
        <trans-unit id="3a7dd5c9993ccdafc8353b9b9fef9d118c35957f" translate="yes" xml:space="preserve">
          <source>Transport only retries a request upon encountering a network error if the request is idempotent and either has no body or has its Request.GetBody defined. HTTP requests are considered idempotent if they have HTTP methods GET, HEAD, OPTIONS, or TRACE; or if their Header map contains an &quot;Idempotency-Key&quot; or &quot;X-Idempotency-Key&quot; entry. If the idempotency key value is an zero-length slice, the request is treated as idempotent but the header is not sent on the wire.</source>
          <target state="translated">如果请求是idempotent的,并且没有body或者定义了Request.GetBody,那么Transport只会在遇到网络错误时重试请求。如果HTTP请求有HTTP方法GET、HEAD、OPTIONS或TRACE,或者它们的Header映射包含 &quot;Idempotency-Key &quot;或 &quot;X-Idempotency-Key &quot;条目,则被认为是幂等的。如果idempotency key的值是一个零长度的分片,那么该请求将被视为idempotent,但线上不会发送头。</target>
        </trans-unit>
        <trans-unit id="a83654a5778fc158c90c291f8461263d34090fc9" translate="yes" xml:space="preserve">
          <source>Transport uses HTTP/1.1 for HTTP URLs and either HTTP/1.1 or HTTP/2 for HTTPS URLs, depending on whether the server supports HTTP/2, and how the Transport is configured. The DefaultTransport supports HTTP/2. To explicitly enable HTTP/2 on a transport, use golang.org/x/net/http2 and call ConfigureTransport. See the package docs for more about HTTP/2.</source>
          <target state="translated">Transport对HTTP URL使用HTTP/1.1,对HTTPS URL使用HTTP/1.1或HTTP/2,这取决于服务器是否支持HTTP/2,以及Transport的配置方式。DefaultTransport支持HTTP/2。要在传输中明确启用 HTTP/2,请使用 golang.org/x/net/http2 并调用 ConfigureTransport。有关HTTP/2的更多信息,请参见软件包文档。</target>
        </trans-unit>
        <trans-unit id="5cba3ebebe9967d6b406fbd61cc05ffea9ddcf56" translate="yes" xml:space="preserve">
          <source>Transports should be reused instead of created as needed. Transports are safe for concurrent use by multiple goroutines.</source>
          <target state="translated">移植应该被重复使用,而不是根据需要创建。移植是安全的,可以被多个goroutine同时使用。</target>
        </trans-unit>
        <trans-unit id="cf5547182a53dd7a581affea62258ee59e262b85" translate="yes" xml:space="preserve">
          <source>Tree is the representation of a single parsed template.</source>
          <target state="translated">树是单个解析模板的表示。</target>
        </trans-unit>
        <trans-unit id="0266abd25371ad4670b041dda4dc487ed199d641" translate="yes" xml:space="preserve">
          <source>Trim</source>
          <target state="translated">Trim</target>
        </trans-unit>
        <trans-unit id="abb910d5bd0bd319cf1d5ef7ad6a5112dc6c0823" translate="yes" xml:space="preserve">
          <source>Trim returns a slice of the string s with all leading and trailing Unicode code points contained in cutset removed.</source>
          <target state="translated">Trim返回字符串s的一个片断,其中包含在cutet中的所有前导和后导Unicode码点。</target>
        </trans-unit>
        <trans-unit id="4f07669cc579ec14df811b3ca5fc72fde4f78f58" translate="yes" xml:space="preserve">
          <source>Trim returns a subslice of s by slicing off all leading and trailing UTF-8-encoded code points contained in cutset.</source>
          <target state="translated">Trim通过切断cutet中包含的所有前导和尾部UTF-8编码的代码点来返回s的子片。</target>
        </trans-unit>
        <trans-unit id="ba1962dfeb4e006658709dd72ff841213f7d1db0" translate="yes" xml:space="preserve">
          <source>TrimBytes returns b without leading and trailing ASCII space.</source>
          <target state="translated">TrimBytes 返回 b,不含前导和尾部 ASCII 空间。</target>
        </trans-unit>
        <trans-unit id="a48987784fdcef3e797c48099ede26a7260db2de" translate="yes" xml:space="preserve">
          <source>TrimFunc</source>
          <target state="translated">TrimFunc</target>
        </trans-unit>
        <trans-unit id="03343404f4f9dd2a23fda87bf2a4805f3806059d" translate="yes" xml:space="preserve">
          <source>TrimFunc returns a slice of the string s with all leading and trailing Unicode code points c satisfying f(c) removed.</source>
          <target state="translated">TrimFunc 返回字符串 s 的一个片断,其中包含所有满足 f(c)的前导和尾部 Unicode 码点。</target>
        </trans-unit>
        <trans-unit id="625b4a484772db3f9992725f710f3d189c47d0db" translate="yes" xml:space="preserve">
          <source>TrimFunc returns a subslice of s by slicing off all leading and trailing UTF-8-encoded code points c that satisfy f(c).</source>
          <target state="translated">TrimFunc通过切掉所有满足f(c)的前导和尾部UTF-8编码的码点c来返回s的子片。</target>
        </trans-unit>
        <trans-unit id="b796ff265d1cc90c9b78c76a3f12dd8cbff027a6" translate="yes" xml:space="preserve">
          <source>TrimLeft</source>
          <target state="translated">TrimLeft</target>
        </trans-unit>
        <trans-unit id="3406f99b35b8781b2e30c5d4f1fb92b18ccfb0a0" translate="yes" xml:space="preserve">
          <source>TrimLeft returns a slice of the string s with all leading Unicode code points contained in cutset removed.</source>
          <target state="translated">TrimLeft 返回字符串 s 的一个片断,其中包含在 cutet 中的所有前导 Unicode 码点。</target>
        </trans-unit>
        <trans-unit id="b52b880dc01fa22cd46ff385a39b5609f426247b" translate="yes" xml:space="preserve">
          <source>TrimLeft returns a subslice of s by slicing off all leading UTF-8-encoded code points contained in cutset.</source>
          <target state="translated">TrimLeft通过切断cutet中包含的所有前导UTF-8编码的码点来返回s的子片。</target>
        </trans-unit>
        <trans-unit id="0dda8e3188c1b3df6f3a5c77e5010dd280c96425" translate="yes" xml:space="preserve">
          <source>TrimLeftFunc</source>
          <target state="translated">TrimLeftFunc</target>
        </trans-unit>
        <trans-unit id="2a771ac81b0579d70a2a4390b741d5fed266d711" translate="yes" xml:space="preserve">
          <source>TrimLeftFunc returns a slice of the string s with all leading Unicode code points c satisfying f(c) removed.</source>
          <target state="translated">TrimLeftFunc返回字符串s的一个片断,并删除所有满足f(c)的Unicode前导码点c。</target>
        </trans-unit>
        <trans-unit id="49c15e330f226f8800b406f97802237df2f3f947" translate="yes" xml:space="preserve">
          <source>TrimLeftFunc treats s as UTF-8-encoded bytes and returns a subslice of s by slicing off all leading UTF-8-encoded code points c that satisfy f(c).</source>
          <target state="translated">TrimLeftFunc将s视为UTF-8编码的字节,并通过切掉所有满足f(c)的前导UTF-8编码码点c来返回s的子片。</target>
        </trans-unit>
        <trans-unit id="f6781400f56acf5b8bc035e02b3cdac08b09ae64" translate="yes" xml:space="preserve">
          <source>TrimPrefix</source>
          <target state="translated">TrimPrefix</target>
        </trans-unit>
        <trans-unit id="0cdb8742fe0e8f96e729ab0932195bcd75f8a8b2" translate="yes" xml:space="preserve">
          <source>TrimPrefix returns s without the provided leading prefix string. If s doesn't start with prefix, s is returned unchanged.</source>
          <target state="translated">TrimPrefix返回s,不包含提供的前缀字符串。如果s不以前缀开始,则返回s不变。</target>
        </trans-unit>
        <trans-unit id="3a3dc250671844d052f305fc24e91daa5dfaf78b" translate="yes" xml:space="preserve">
          <source>TrimRight</source>
          <target state="translated">TrimRight</target>
        </trans-unit>
        <trans-unit id="f36ec5b5c4656d60b56116c5bdb688d629f84c86" translate="yes" xml:space="preserve">
          <source>TrimRight returns a slice of the string s, with all trailing Unicode code points contained in cutset removed.</source>
          <target state="translated">TrimRight返回字符串s的一个片断,并删除所有包含在cuteset中的尾部Unicode码点。</target>
        </trans-unit>
        <trans-unit id="3ca08db3862d11ac280fa859c98a5062cca7758f" translate="yes" xml:space="preserve">
          <source>TrimRight returns a subslice of s by slicing off all trailing UTF-8-encoded code points that are contained in cutset.</source>
          <target state="translated">TrimRight通过切掉所有包含在cutset中的尾部UTF-8编码的码点来返回s的子片。</target>
        </trans-unit>
        <trans-unit id="2face4904f1360f377438b017515ff3c2359f581" translate="yes" xml:space="preserve">
          <source>TrimRightFunc</source>
          <target state="translated">TrimRightFunc</target>
        </trans-unit>
        <trans-unit id="91f9e348fa7e18e840cf0ac3e8dc3a6295b78762" translate="yes" xml:space="preserve">
          <source>TrimRightFunc returns a slice of the string s with all trailing Unicode code points c satisfying f(c) removed.</source>
          <target state="translated">TrimRightFunc 返回字符串 s 的一个片断,并删除所有满足 f(c)的 Unicode 码点。</target>
        </trans-unit>
        <trans-unit id="af58ad241c06498d7e5d96dabf6a334e19cb450d" translate="yes" xml:space="preserve">
          <source>TrimRightFunc returns a subslice of s by slicing off all trailing UTF-8-encoded code points c that satisfy f(c).</source>
          <target state="translated">TrimRightFunc通过切掉所有满足f(c)的UTF-8编码的尾部码点c来返回s的子片。</target>
        </trans-unit>
        <trans-unit id="3b9759ef917cd034e3fff66af6781ac1144ddf76" translate="yes" xml:space="preserve">
          <source>TrimSpace</source>
          <target state="translated">TrimSpace</target>
        </trans-unit>
        <trans-unit id="fb7131e90264c0cc3ce43bd31575b4282b5313c8" translate="yes" xml:space="preserve">
          <source>TrimSpace returns a slice of the string s, with all leading and trailing white space removed, as defined by Unicode.</source>
          <target state="translated">TrimSpace返回字符串s的一个片断,其中所有的前导和尾部的空白空间都被删除,如Unicode所定义。</target>
        </trans-unit>
        <trans-unit id="a187e5cf0dba2afc1b0487c662e640873854f7ec" translate="yes" xml:space="preserve">
          <source>TrimSpace returns a subslice of s by slicing off all leading and trailing white space, as defined by Unicode.</source>
          <target state="translated">TrimSpace通过切去Unicode定义的所有前导和尾部的空白空间来返回s的子片段。</target>
        </trans-unit>
        <trans-unit id="b11fe2b91f56619862961192ca92d40d14d67c9d" translate="yes" xml:space="preserve">
          <source>TrimString returns s without leading and trailing ASCII space.</source>
          <target state="translated">TrimString返回不含前导和尾部ASCII空格的s。</target>
        </trans-unit>
        <trans-unit id="31564f1b1fc10c6dcf98b0ba8f0d174cf833e697" translate="yes" xml:space="preserve">
          <source>TrimSuffix</source>
          <target state="translated">TrimSuffix</target>
        </trans-unit>
        <trans-unit id="92a8263afbc0fa4c5341e4098b039907219bbb45" translate="yes" xml:space="preserve">
          <source>TrimSuffix returns s without the provided trailing suffix string. If s doesn't end with suffix, s is returned unchanged.</source>
          <target state="translated">TrimSuffix返回s,不包含提供的后缀字符串。如果s不以后缀结尾,则返回s不变。</target>
        </trans-unit>
        <trans-unit id="4ac265259166695b742658a267b27c17c43d2d87" translate="yes" xml:space="preserve">
          <source>Trunc returns the integer value of x.</source>
          <target state="translated">Trunc返回x的整数值。</target>
        </trans-unit>
        <trans-unit id="a6f2f1d850d6a1bef2ab8b526d322b73779287f1" translate="yes" xml:space="preserve">
          <source>Truncate changes the size of the file. It does not change the I/O offset. If there is an error, it will be of type *PathError.</source>
          <target state="translated">Truncate会改变文件的大小。它不改变I/O偏移量。如果有错误,它的类型是*PathError。</target>
        </trans-unit>
        <trans-unit id="062334176014417d736c93d4f00898bc3b617151" translate="yes" xml:space="preserve">
          <source>Truncate changes the size of the named file. If the file is a symbolic link, it changes the size of the link's target. If there is an error, it will be of type *PathError.</source>
          <target state="translated">Truncate改变命名文件的大小。如果文件是一个符号链接,它将改变链接目标的大小。如果有一个错误,它的类型是*PathError。</target>
        </trans-unit>
        <trans-unit id="e8c4ef35e7ba4d40ba29121e1bd589ff3e80bcb3" translate="yes" xml:space="preserve">
          <source>Truncate discards all but the first n unread bytes from the buffer but continues to use the same allocated storage. It panics if n is negative or greater than the length of the buffer.</source>
          <target state="translated">Truncate丢弃缓冲区中除前n个未读字节外的所有字节,但继续使用相同的分配存储空间。如果n为负数或大于缓冲区的长度,它会惊慌失措。</target>
        </trans-unit>
        <trans-unit id="32beb0b08a1549453f279d1334d844a2afaea49a" translate="yes" xml:space="preserve">
          <source>Truncate operates on the time as an absolute duration since the zero time; it does not operate on the presentation form of the time. Thus, Truncate(Hour) may return a time with a non-zero minute, depending on the time's Location.</source>
          <target state="translated">Truncate 对时间的操作是指从零点开始的绝对持续时间;它不对时间的表现形式进行操作。因此,Truncate(Hour)可能会返回一个非零分钟的时间,这取决于时间的位置。</target>
        </trans-unit>
        <trans-unit id="71998d5a06a6fc24a70aad616e3e9f7ea3e57939" translate="yes" xml:space="preserve">
          <source>Truncate returns the result of rounding d toward zero to a multiple of m. If m &amp;lt;= 0, Truncate returns d unchanged.</source>
          <target state="translated">截断返回将d朝零舍入到m的倍数的结果。如果m &amp;lt;= 0，则Truncate不变地返回d。</target>
        </trans-unit>
        <trans-unit id="498fecdf2960f4ea8c81a3634a3c6208f18d44bd" translate="yes" xml:space="preserve">
          <source>Truncate returns the result of rounding t down to a multiple of d (since the zero time). If d &amp;lt;= 0, Truncate returns t stripped of any monotonic clock reading but otherwise unchanged.</source>
          <target state="translated">Truncate返回将t向下舍入为d的倍数的结果（因为零时间）。如果d &amp;lt;= 0，则Truncate返回t，去除了任何单调时钟读数，但未更改。</target>
        </trans-unit>
        <trans-unit id="7a922bb8e2913cab6dcad5ba9140345fb42fa502" translate="yes" xml:space="preserve">
          <source>TruncateWriter returns a Writer that writes to w but stops silently after n bytes.</source>
          <target state="translated">TruncateWriter 返回一个向 w 写入但在 n 个字节后默默停止的 Writer。</target>
        </trans-unit>
        <trans-unit id="66617c3163f43664fa6ddb9c95a7d88a932b782b" translate="yes" xml:space="preserve">
          <source>Truthy returns the JavaScript &quot;truthiness&quot; of the value v. In JavaScript, false, 0, &quot;&quot;, null, undefined, and NaN are &quot;falsy&quot;, and everything else is &quot;truthy&quot;. See &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Truthy&quot;&gt;https://developer.mozilla.org/en-US/docs/Glossary/Truthy&lt;/a&gt;.</source>
          <target state="translated">Truthy返回值v的JavaScript&amp;ldquo;真实性&amp;rdquo;。在JavaScript中，false，0，&amp;ldquo;&amp;rdquo;，null，undefined和NaN为&amp;ldquo; falsy&amp;rdquo;，其他所有内容均为&amp;ldquo; truthy&amp;rdquo;。请参阅&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Truthy&quot;&gt;https://developer.mozilla.org/en-US/docs/Glossary/Truthy&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c26728b3acc2b9a34150900b5536db30082f4043" translate="yes" xml:space="preserve">
          <source>TryRecv attempts to receive a value from the channel v but will not block. It panics if v's Kind is not Chan. If the receive delivers a value, x is the transferred value and ok is true. If the receive cannot finish without blocking, x is the zero Value and ok is false. If the channel is closed, x is the zero value for the channel's element type and ok is false.</source>
          <target state="translated">TryRecv 试图从通道 v 中接收一个值,但不会阻塞。如果v的Kind不是Chan,它就会恐慌。如果接收到一个值,x是传输的值,ok为true。如果receive不能在不阻塞的情况下完成,x为零值,ok为假。如果通道被关闭,x是通道的元素类型的零值,ok为假。</target>
        </trans-unit>
        <trans-unit id="febc1b0170a31256a4ba31c38646abd1c14c7afb" translate="yes" xml:space="preserve">
          <source>TrySend attempts to send x on the channel v but will not block. It panics if v's Kind is not Chan. It reports whether the value was sent. As in Go, x's value must be assignable to the channel's element type.</source>
          <target state="translated">TrySend试图在v通道上发送x,但不会被阻止。如果v的Kind不是Chan,它就会恐慌。它报告值是否被发送。在围棋中,x的值必须可以分配给通道的元素类型。</target>
        </trans-unit>
        <trans-unit id="042f2d498c44806f60201f1f05491910d5c73fe8" translate="yes" xml:space="preserve">
          <source>Two sets of interfaces are included in this package. When a more abstract interface isn't necessary, there are functions for encrypting/decrypting with v1.5/OAEP and signing/verifying with v1.5/PSS. If one needs to abstract over the public-key primitive, the PrivateKey struct implements the Decrypter and Signer interfaces from the crypto package.</source>
          <target state="translated">本包中包含两套接口。当不需要更抽象的接口时,有一些函数用于用v1.5/OAEP加密/解密和用v1.5/PSS签名/验证。如果需要对公钥基元进行抽象,那么PrivateKey结构实现了crypto包中的Decrypter和Signer接口。</target>
        </trans-unit>
        <trans-unit id="021677bbd9ee4b61e5a1312cf21d452a27661c48" translate="yes" xml:space="preserve">
          <source>Tx is a transaction.</source>
          <target state="translated">Tx是一种交易。</target>
        </trans-unit>
        <trans-unit id="02cdcf0d841ea4d5e8abf2653c842d138120149a" translate="yes" xml:space="preserve">
          <source>Tx is an in-progress database transaction.</source>
          <target state="translated">Tx是一个进行中的数据库事务。</target>
        </trans-unit>
        <trans-unit id="41b6053676814b4fe97b2c9be9a306ee614bfa3d" translate="yes" xml:space="preserve">
          <source>Tx.ExecContext</source>
          <target state="translated">Tx.ExecContext</target>
        </trans-unit>
        <trans-unit id="2825856698e10e430365413d889b83a20654a02a" translate="yes" xml:space="preserve">
          <source>Tx.Prepare</source>
          <target state="translated">Tx.Prepare</target>
        </trans-unit>
        <trans-unit id="ef76ba4edb63dbd2cd7bf54f9037e276e1229e5a" translate="yes" xml:space="preserve">
          <source>Tx.Rollback</source>
          <target state="translated">Tx.Rollback</target>
        </trans-unit>
        <trans-unit id="a83fe983647bcf7e1590d7bef39b1b437680667a" translate="yes" xml:space="preserve">
          <source>TxOptions holds the transaction options to be used in DB.BeginTx.</source>
          <target state="translated">TxOptions持有DB.BeginTx中要使用的事务选项。</target>
        </trans-unit>
        <trans-unit id="46eaf072cf758f74571ec8685b65883630652645" translate="yes" xml:space="preserve">
          <source>TxOptions holds the transaction options.</source>
          <target state="translated">TxOptions持有交易选项。</target>
        </trans-unit>
        <trans-unit id="68e7b01d33d203d9281e2f2dd8f3398104376276" translate="yes" xml:space="preserve">
          <source>Typ contains the predeclared *Basic types indexed by their corresponding BasicKind.</source>
          <target state="translated">Typ包含由其对应的BasicKind索引的预先声明的*Basic类型。</target>
        </trans-unit>
        <trans-unit id="64f24b17ea9baa36a77dc3d1afdc32b1a420fb9e" translate="yes" xml:space="preserve">
          <source>Type flags for Header.Typeflag.</source>
          <target state="translated">Header.Typeflag的类型标志。</target>
        </trans-unit>
        <trans-unit id="04ccb52737e3e40430c97b234b8f24e390173f8b" translate="yes" xml:space="preserve">
          <source>Type inference computes the type (Type) of every expression (ast.Expr) and checks for compliance with the language specification. Use Info.Types[expr].Type for the results of type inference.</source>
          <target state="translated">类型推理计算每个表达式(ast.Expr)的类型(Type),并检查是否符合语言规范。使用Info.Types[expr].Type来获取类型推理的结果。</target>
        </trans-unit>
        <trans-unit id="8035b14525c84dd4e5349419c0ff657e153c1c32" translate="yes" xml:space="preserve">
          <source>Type is found in Header.Type.</source>
          <target state="translated">Type在Header.Type中找到。</target>
        </trans-unit>
        <trans-unit id="ec7bc4958b2c43e87f98f2ef7e1adb5d065d5c5e" translate="yes" xml:space="preserve">
          <source>Type is here for the purposes of documentation only. It is a stand-in for any Go type, but represents the same type for any given function invocation.</source>
          <target state="translated">类型在这里只是为了文档的目的。它是任何Go类型的替身,但对于任何给定的函数调用来说,它代表的是相同的类型。</target>
        </trans-unit>
        <trans-unit id="233ac19906546712346f536e7ee3880b82162310" translate="yes" xml:space="preserve">
          <source>Type is the documentation for a type declaration.</source>
          <target state="translated">类型是类型声明的文档。</target>
        </trans-unit>
        <trans-unit id="d3c0b263d515209e36ac606a05719bce899addba" translate="yes" xml:space="preserve">
          <source>Type is the representation of a Go type.</source>
          <target state="translated">类型是围棋类型的表示。</target>
        </trans-unit>
        <trans-unit id="c3bca7d619ddc3b0ec61fb8f295216cb63f22eb4" translate="yes" xml:space="preserve">
          <source>Type reads the type at off in the DWARF &amp;ldquo;info&amp;rdquo; section.</source>
          <target state="translated">Type在DWARF&amp;ldquo;信息&amp;rdquo;部分中关闭时读取类型。</target>
        </trans-unit>
        <trans-unit id="1fce0b09390d2c3838db788c0cf76f63a5bf80a9" translate="yes" xml:space="preserve">
          <source>Type represents the JavaScript type of a Value.</source>
          <target state="translated">Type表示Value的JavaScript类型。</target>
        </trans-unit>
        <trans-unit id="e06c5701673348f2eed499aa753a2ba395d1a12d" translate="yes" xml:space="preserve">
          <source>Type returns itself and provides an easy default implementation for embedding in a Node. Embedded in all non-trivial Nodes.</source>
          <target state="translated">类型返回自身,并为嵌入Node提供了一个简单的默认实现。嵌入到所有非平凡的Node中。</target>
        </trans-unit>
        <trans-unit id="4726645469f41dd7bcb1d47132c78e582530c7e1" translate="yes" xml:space="preserve">
          <source>Type returns the JavaScript type of the value v. It is similar to JavaScript's typeof operator, except that it returns TypeNull instead of TypeObject for null.</source>
          <target state="translated">Type返回值v的JavaScript类型,它类似于JavaScript的typeof操作符,除了它返回TypeNull而不是TypeObject的null。</target>
        </trans-unit>
        <trans-unit id="2fa9db8cb436bbb192eec5d03d6240277e6eeffd" translate="yes" xml:space="preserve">
          <source>Type returns the object's type.</source>
          <target state="translated">Type 返回对象的类型。</target>
        </trans-unit>
        <trans-unit id="d1407fc8c8322906d1372dd8a45dc51e6205559f" translate="yes" xml:space="preserve">
          <source>Type returns the type of x.f, which may be different from the type of f. See Selection for more information.</source>
          <target state="translated">Type 返回 x.f 的类型,它可能与 f 的类型不同。更多信息请参见 Selection。</target>
        </trans-unit>
        <trans-unit id="372fc3db84eb7f93272dcba175262aaab1565f30" translate="yes" xml:space="preserve">
          <source>Type returns v's type.</source>
          <target state="translated">Type返回v的类型。</target>
        </trans-unit>
        <trans-unit id="55dbc1b43ee6cb3b1548172b193bc2a7d3e5eca5" translate="yes" xml:space="preserve">
          <source>Type values are comparable, such as with the == operator, so they can be used as map keys. Two Type values are equal if they represent identical types.</source>
          <target state="translated">类型值是可以比较的,比如用==运算符,所以它们可以作为映射键使用。如果两个类型值代表相同的类型,则它们是相等的。</target>
        </trans-unit>
        <trans-unit id="7bdac7349f75285c99f4a03ea2e2de6365f45c2a" translate="yes" xml:space="preserve">
          <source>Type-checking consists of several interdependent phases:</source>
          <target state="translated">类型检查包括几个相互依赖的阶段。</target>
        </trans-unit>
        <trans-unit id="26984be5e6e3b06475f717ab4d76ce6f4ff88c54" translate="yes" xml:space="preserve">
          <source>Type1 is here for the purposes of documentation only. It is a stand-in for any Go type, but represents the same type for any given function invocation.</source>
          <target state="translated">Type1在这里只是为了文档的目的。它是任何围棋类型的替身,但对于任何给定的函数调用来说,它代表的是同一类型。</target>
        </trans-unit>
        <trans-unit id="7ace60c9c3dbd05ce39ba29e759c6ad4a52088eb" translate="yes" xml:space="preserve">
          <source>TypeAndValue reports the type and value (for constants) of the corresponding expression.</source>
          <target state="translated">TypeAndValue报告相应表达式的类型和值(对于常量)。</target>
        </trans-unit>
        <trans-unit id="2bc75a2b4beae4c84f906bb525769e97f38f0823" translate="yes" xml:space="preserve">
          <source>TypeByExtension returns the MIME type associated with the file extension ext. The extension ext should begin with a leading dot, as in &quot;.html&quot;. When ext has no associated type, TypeByExtension returns &quot;&quot;.</source>
          <target state="translated">TypeByExtension 返回与文件扩展名 ext 相关联的 MIME 类型。扩展名 ext 应该以前导点开始,如&quot;.html&quot;。当ext没有关联类型时,TypeByExtension返回&quot;&quot;。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
