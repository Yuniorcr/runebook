<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="go">
    <body>
      <group id="go">
        <trans-unit id="f55bd52960d8a9b74f8c169b63b303f83068df0d" translate="yes" xml:space="preserve">
          <source>See func Dial for a description of the network and address parameters.</source>
          <target state="translated">有关网络和地址参数的描述,请参见 func Dial。</target>
        </trans-unit>
        <trans-unit id="27af5de3a2347f6faceaa84c4b1f14ae1dbd0c9d" translate="yes" xml:space="preserve">
          <source>See func Listen for a description of the network and address parameters.</source>
          <target state="translated">有关网络和地址参数的描述,请参见 func Listen。</target>
        </trans-unit>
        <trans-unit id="6b6b3dee4908b79bcc47570b27eb5ceec2a78402" translate="yes" xml:space="preserve">
          <source>See func ListenPacket for a description of the network and address parameters.</source>
          <target state="translated">有关网络和地址参数的描述,请参见func ListenPacket。</target>
        </trans-unit>
        <trans-unit id="ad4f4bb8708490d77806cbbb7379b205b4ed91be" translate="yes" xml:space="preserve">
          <source>See package json to understand how non-string content is marshaled for embedding in JavaScript contexts.</source>
          <target state="translated">请参阅包json,了解非字符串内容是如何在JavaScript上下文中嵌入的。</target>
        </trans-unit>
        <trans-unit id="6e66c2f2a3fcd4dca444d07ce7d1a4b916782623" translate="yes" xml:space="preserve">
          <source>See page 36 of RFC 959 (&lt;a href=&quot;https://www.ietf.org/rfc/rfc959.txt&quot;&gt;https://www.ietf.org/rfc/rfc959.txt&lt;/a&gt;) for details of another form of response accepted:</source>
          <target state="translated">有关接受的另一种形式的响应，请参阅RFC 959（&lt;a href=&quot;https://www.ietf.org/rfc/rfc959.txt&quot;&gt;https://www.ietf.org/rfc/rfc959.txt&lt;/a&gt;）的第36页：</target>
        </trans-unit>
        <trans-unit id="89753a3f5bb64713c93e9dd202de0a7448a21cee" translate="yes" xml:space="preserve">
          <source>See the Client.Do method documentation for details on how redirects are handled.</source>
          <target state="translated">关于如何处理重定向,请参见Client.Do方法文档。</target>
        </trans-unit>
        <trans-unit id="ca6b0bd4889c5a06e76626f48ec79733e1fde8b5" translate="yes" xml:space="preserve">
          <source>See the Decoder.Strict and Decoder.Entity fields' documentation.</source>
          <target state="translated">参见Decoder.Strict和Decoder.Entity字段的文档。</target>
        </trans-unit>
        <trans-unit id="69633a7324ac73d11db8887864a0a74fd2f5588f" translate="yes" xml:space="preserve">
          <source>See the documentation for Marshal for details about the conversion of Go values to JSON.</source>
          <target state="translated">关于将Go值转换为JSON的细节,请参见Marshal的文档。</target>
        </trans-unit>
        <trans-unit id="45c89cab840adb83eec8d88d66bfe51744007d64" translate="yes" xml:space="preserve">
          <source>See the documentation for Marshal for details about the conversion of Go values to XML.</source>
          <target state="translated">关于将Go值转换为XML的细节,请参见Marshal的文档。</target>
        </trans-unit>
        <trans-unit id="f6ad8d64ce7abf48e48759b114cf5bbde1ec1217" translate="yes" xml:space="preserve">
          <source>See the documentation for Reader's DotReader method for details about dot-encoding.</source>
          <target state="translated">请参阅Reader的DotReader方法的文档,了解点阵编码的细节。</target>
        </trans-unit>
        <trans-unit id="07bb2782143cae54efbc20f97e601c6258fdfa3a" translate="yes" xml:space="preserve">
          <source>See the documentation for Unmarshal for details about the conversion of JSON into a Go value.</source>
          <target state="translated">关于将JSON转换为Go值的细节,请参见Unmarshal的文档。</target>
        </trans-unit>
        <trans-unit id="5b7d9e398b9767ef1472ee8144b5fcbf7154f428" translate="yes" xml:space="preserve">
          <source>See the documentation for the DotReader method for details about dot-encoding.</source>
          <target state="translated">请参阅DotReader方法的文档,了解关于点阵编码的详细信息。</target>
        </trans-unit>
        <trans-unit id="20a56feb05a514c49115ca9854f4e8b6ab081007" translate="yes" xml:space="preserve">
          <source>See the documentation of ErrorCode for details.</source>
          <target state="translated">详见ErrorCode的文档。</target>
        </trans-unit>
        <trans-unit id="130b144345eef54088939126445f2041356e9967" translate="yes" xml:space="preserve">
          <source>See the net/http/pprof package for more details about all of the debug endpoints installed by this import.</source>
          <target state="translated">参见net/http/pprof包,以了解更多关于此导入安装的所有调试端点的细节。</target>
        </trans-unit>
        <trans-unit id="8ea13af2c476fd8c34b53410467a8c4eec967244" translate="yes" xml:space="preserve">
          <source>See the net/http/pprof package for more details.</source>
          <target state="translated">详见net/http/pprof包。</target>
        </trans-unit>
        <trans-unit id="7129eb47abb47be846a8de8beba3573c278ce39c" translate="yes" xml:space="preserve">
          <source>See type IPNet and func ParseCIDR for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d95f74a97d247876324f75dbbfb30fd3fdf53de6" translate="yes" xml:space="preserve">
          <source>See: &lt;a href=&quot;https://www.pkware.com/appnote&quot;&gt;https://www.pkware.com/appnote&lt;/a&gt;</source>
          <target state="translated">请参阅：&lt;a href=&quot;https://www.pkware.com/appnote&quot;&gt;https&lt;/a&gt;：//www.pkware.com/appnote</target>
        </trans-unit>
        <trans-unit id="421cab07939e4ef921a875d22fec2c50b6b26cc4" translate="yes" xml:space="preserve">
          <source>Seed returns the private key seed corresponding to priv. It is provided for interoperability with RFC 8032. RFC 8032's private keys correspond to seeds in this package.</source>
          <target state="translated">Seed返回对应于priv.Seed的私钥种子,它与RFC 8032提供了互操作性。它是为了与RFC 8032的互操作性而提供的。RFC 8032的私钥对应于这个包中的种子。</target>
        </trans-unit>
        <trans-unit id="b24f14f5efbc89ced2f3c041e71ddf2e16d01a87" translate="yes" xml:space="preserve">
          <source>Seed uses the provided seed value to initialize the default Source to a deterministic state. If Seed is not called, the generator behaves as if seeded by Seed(1). Seed values that have the same remainder when divided by 2&amp;sup3;&amp;sup1;-1 generate the same pseudo-random sequence. Seed, unlike the Rand.Seed method, is safe for concurrent use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2daea0c21550e6b91614c2942780e2e38582d89" translate="yes" xml:space="preserve">
          <source>Seed uses the provided seed value to initialize the default Source to a deterministic state. If Seed is not called, the generator behaves as if seeded by Seed(1). Seed values that have the same remainder when divided by 2^31-1 generate the same pseudo-random sequence. Seed, unlike the Rand.Seed method, is safe for concurrent use.</source>
          <target state="translated">Seed 使用提供的种子值将默认的 Source 初始化为确定性状态。如果不调用Seed,则生成器的行为与Seed(1)的种子值相同。当种子值除以2^31-1时具有相同余数的种子值会产生相同的伪随机序列。与Rand.Seed方法不同,Seed对于并发使用是安全的。</target>
        </trans-unit>
        <trans-unit id="06599ffd87d9ecfcc5955a8a8f6f2e80af71b779" translate="yes" xml:space="preserve">
          <source>Seed uses the provided seed value to initialize the generator to a deterministic state. Seed should not be called concurrently with any other Rand method.</source>
          <target state="translated">Seed 使用提供的种子值将生成器初始化为确定性状态。Seed不应该与其他任何Rand方法同时调用。</target>
        </trans-unit>
        <trans-unit id="63eada0c1ee90c191cced8ff6a478d23ec01c7bb" translate="yes" xml:space="preserve">
          <source>Seek implements the io.Seeker interface.</source>
          <target state="translated">Seek实现了io.Seeker接口。</target>
        </trans-unit>
        <trans-unit id="410f9d629b5b2020b5303452364dec83676d0a30" translate="yes" xml:space="preserve">
          <source>Seek positions the Reader at offset off in the encoded entry stream. Offset 0 can be used to denote the first entry.</source>
          <target state="translated">Seek将读卡器定位在编码输入流中的偏移量上,偏移量0可以用来表示第一个输入。偏移量0可以用来表示第一个条目。</target>
        </trans-unit>
        <trans-unit id="73550a62d2076f2c392030c22ea826a5948745a2" translate="yes" xml:space="preserve">
          <source>Seek restores the line table reader to a position returned by Tell.</source>
          <target state="translated">Seek将行表阅读器恢复到Tell返回的位置。</target>
        </trans-unit>
        <trans-unit id="6d637ad9eaafe14fbed4d5e3bc3eb33df03f11cb" translate="yes" xml:space="preserve">
          <source>Seek sets the offset for the next Read or Write on file to offset, interpreted according to whence: 0 means relative to the origin of the file, 1 means relative to the current offset, and 2 means relative to the end. It returns the new offset and an error, if any. The behavior of Seek on a file opened with O_APPEND is not specified.</source>
          <target state="translated">Seek设置下一次对文件的读或写的偏移量为offset,根据whence解释。0表示相对于文件的原点,1表示相对于当前的偏移量,2表示相对于文件的终点.如果有的话,它返回新的偏移量和一个错误。对于用O_APPEND打开的文件,没有指定Seek的行为。</target>
        </trans-unit>
        <trans-unit id="e00a273e91af976fc6df810663ccae8e6326bc28" translate="yes" xml:space="preserve">
          <source>Seek sets the offset for the next Read or Write to offset, interpreted according to whence: SeekStart means relative to the start of the file, SeekCurrent means relative to the current offset, and SeekEnd means relative to the end. Seek returns the new offset relative to the start of the file and an error, if any.</source>
          <target state="translated">Seek设置下一次读或写的偏移量,根据whence解释。SeekStart表示相对于文件的开始,SeekCurrent表示相对于当前的偏移量,SeekEnd表示相对于文件的结束.Seek返回相对于文件开始的新偏移量,如果有错误,则返回一个错误。</target>
        </trans-unit>
        <trans-unit id="f2691430f4c04cd93d687e7abb0ccf591170c83f" translate="yes" xml:space="preserve">
          <source>Seek whence values.</source>
          <target state="translated">寻求当值。</target>
        </trans-unit>
        <trans-unit id="69cfaf772b14f0b576e9cb0bbd8f02155636d19d" translate="yes" xml:space="preserve">
          <source>SeekPC returns the Entry for the compilation unit that includes pc, and positions the reader to read the children of that unit. If pc is not covered by any unit, SeekPC returns ErrUnknownPC and the position of the reader is undefined.</source>
          <target state="translated">SeekPC返回包括pc在内的编译单元的条目,并定位读取器以读取该单元的子单元。如果pc没有被任何单元覆盖,SeekPC返回ErrUnknownPC,并且读取器的位置是未定义的。</target>
        </trans-unit>
        <trans-unit id="ce674d68613294249c458dda3fd950d087fbda52" translate="yes" xml:space="preserve">
          <source>SeekPC sets *entry to the LineEntry that includes pc and positions the reader on the next entry in the line table. If necessary, this will seek backwards to find pc.</source>
          <target state="translated">SeekPC将*entry设置为包含pc的LineEntry,并将读取器定位在行表的下一个条目上。如果有必要,这将向后寻找pc。</target>
        </trans-unit>
        <trans-unit id="9d91685eee68f0702fc5f565a2ad58bdb01cbd6c" translate="yes" xml:space="preserve">
          <source>Seeker is the interface that wraps the basic Seek method.</source>
          <target state="translated">Seeker是包装基本Seek方法的接口。</target>
        </trans-unit>
        <trans-unit id="c221b3bf48536c91e36f1aa582e0e6ad14671a86" translate="yes" xml:space="preserve">
          <source>Seeking to an offset before the start of the file is an error. Seeking to any positive offset is legal, but the behavior of subsequent I/O operations on the underlying object is implementation-dependent.</source>
          <target state="translated">在文件开始前寻找偏移量是错误的。对任何正偏移量的查找都是合法的,但是对底层对象的后续I/O操作的行为是依赖于实现的。</target>
        </trans-unit>
        <trans-unit id="d283b12149f88184eedb3514ba9c006d88d9d635" translate="yes" xml:space="preserve">
          <source>Segment returns the first Segment with the given name, or nil if no such segment exists.</source>
          <target state="translated">Segment返回第一个给定名称的Segment,如果不存在,则返回nil。</target>
        </trans-unit>
        <trans-unit id="4ee9c170709717ea62d8ec2ac63808bf3b81d532" translate="yes" xml:space="preserve">
          <source>Select executes a select operation described by the list of cases. Like the Go select statement, it blocks until at least one of the cases can proceed, makes a uniform pseudo-random choice, and then executes that case. It returns the index of the chosen case and, if that case was a receive operation, the value received and a boolean indicating whether the value corresponds to a send on the channel (as opposed to a zero value received because the channel is closed).</source>
          <target state="translated">Select执行一个由case列表描述的选择操作。和Go选择语句一样,它阻塞到至少有一个case可以进行,进行统一的伪随机选择,然后执行该case。它返回所选情况的索引,如果该情况是接收操作,则返回接收到的值和一个布尔值,表示该值是否对应于通道上的发送(而不是因为通道关闭而接收到的零值)。</target>
        </trans-unit>
        <trans-unit id="9f23aae7e3512dd0773f6a470359d03ccb841782" translate="yes" xml:space="preserve">
          <source>Select executes a select operation described by the list of cases. Like the Go select statement, it blocks until at least one of the cases can proceed, makes a uniform pseudo-random choice, and then executes that case. It returns the index of the chosen case and, if that case was a receive operation, the value received and a boolean indicating whether the value corresponds to a send on the channel (as opposed to a zero value received because the channel is closed). Select supports a maximum of 65536 cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7716a94c0a405511b91cc23c646dfce03e542371" translate="yes" xml:space="preserve">
          <source>SelectionKind describes the kind of a selector expression x.f (excluding qualified identifiers).</source>
          <target state="translated">SelectionKind描述了选择器表达式x.f的种类(不包括限定标识符)。</target>
        </trans-unit>
        <trans-unit id="656dfc577aeb6e9f277a9a8820fcfc6e5db75f21" translate="yes" xml:space="preserve">
          <source>SelectionString returns the string form of s. The Qualifier controls the printing of package-level objects, and may be nil.</source>
          <target state="translated">SelectionString 返回 s 的字符串形式,限定符控制包级对象的打印,可以为零。</target>
        </trans-unit>
        <trans-unit id="edad40365c9764afdd964f9245649f6856af2d11" translate="yes" xml:space="preserve">
          <source>Send sends x on the channel v. It panics if v's kind is not Chan or if x's type is not the same type as v's element type. As in Go, x's value must be assignable to the channel's element type.</source>
          <target state="translated">如果v的种类不是Chan或者x的类型与v的元素类型不一样,它就会惊慌失措。在围棋中,x的值必须可以分配给通道的元素类型。</target>
        </trans-unit>
        <trans-unit id="2750b0f06411195ed08fefe45f59d520ab6f8353" translate="yes" xml:space="preserve">
          <source>SendMail</source>
          <target state="translated">SendMail</target>
        </trans-unit>
        <trans-unit id="1a5bbac84e0744da338847af3ed794816ef236ce" translate="yes" xml:space="preserve">
          <source>SendMail connects to the server at addr, switches to TLS if possible, authenticates with the optional mechanism a if possible, and then sends an email from address from, to addresses to, with message msg. The addr must include a port, as in &quot;mail.example.com:smtp&quot;.</source>
          <target state="translated">SendMail 在addr处连接到服务器,如果可能的话切换到TLS,如果可能的话使用可选的机制a进行验证,然后从addr地址向addr地址发送邮件,并发送msg。addr必须包含一个端口,如 &quot;mail.example.com:smtp&quot;。</target>
        </trans-unit>
        <trans-unit id="9866b4faed06fd643cf801f0e203a46a3fe6c756" translate="yes" xml:space="preserve">
          <source>Serve accepts incoming FastCGI connections on the listener l, creating a new goroutine for each. The goroutine reads requests and then calls handler to reply to them. If l is nil, Serve accepts connections from os.Stdin. If handler is nil, http.DefaultServeMux is used.</source>
          <target state="translated">Serve在监听器l上接受传入的FastCGI连接,为每个连接创建一个新的goroutine。goroutine 读取请求,然后调用 handler 来回复它们。如果 l 为 nil,Serve 接受来自 os.Stdin 的连接。如果 handler 为 nil,则使用 http.DefaultServeMux。</target>
        </trans-unit>
        <trans-unit id="d8de44e0fb5292324dadb958bb0ec67283e1e920" translate="yes" xml:space="preserve">
          <source>Serve accepts incoming HTTP connections on the listener l, creating a new service goroutine for each. The service goroutines read requests and then call handler to reply to them.</source>
          <target state="translated">Serve在监听器l上接受传入的HTTP连接,为每个连接创建一个新的服务goroutine。服务goroutine读取请求,然后调用handler来回复请求。</target>
        </trans-unit>
        <trans-unit id="fb2fbb4a3d173feafc83e986b5d91f4c043b98cd" translate="yes" xml:space="preserve">
          <source>Serve accepts incoming connections on the Listener l, creating a new service goroutine for each. The service goroutines read requests and then call srv.Handler to reply to them.</source>
          <target state="translated">Serve在Listener l上接受传入的连接,为每个连接创建一个新的服务goroutine。服务goroutine读取请求,然后调用srv.Handler来回复请求。</target>
        </trans-unit>
        <trans-unit id="f65496b12ef6ef062ca261d02fdcc1afec4ce5ea" translate="yes" xml:space="preserve">
          <source>Serve always returns a non-nil error and closes l. After Shutdown or Close, the returned error is ErrServerClosed.</source>
          <target state="translated">Serve总是返回一个非零的错误并关闭l,关机或关闭后,返回的错误是ErrServerClosed。</target>
        </trans-unit>
        <trans-unit id="4671511496e9d853a658f8c526e4dbf184a2c34c" translate="yes" xml:space="preserve">
          <source>Serve always returns a non-nil error.</source>
          <target state="translated">Serve总是返回一个非零的错误。</target>
        </trans-unit>
        <trans-unit id="497078ba977bfc095dad2477b3172dcb26f1c0ab" translate="yes" xml:space="preserve">
          <source>Serve executes the provided Handler on the currently active CGI request, if any. If there's no current CGI environment an error is returned. The provided handler may be nil to use http.DefaultServeMux.</source>
          <target state="translated">Serve在当前活动的CGI请求上执行所提供的处理程序(如果有的话)。如果当前没有CGI环境,将返回一个错误。所提供的处理程序可能是nil,以使用http.DefaultServeMux。</target>
        </trans-unit>
        <trans-unit id="dbfb7d2b5b789e7fe76f3c2462b4817839783a1b" translate="yes" xml:space="preserve">
          <source>ServeCodec is like ServeConn but uses the specified codec to decode requests and encode responses.</source>
          <target state="translated">ServeCodec和ServeConn一样,但使用指定的编解码器来解码请求和编码响应。</target>
        </trans-unit>
        <trans-unit id="09ac76223546ffdd3d100d24b6bc49c0b7956df0" translate="yes" xml:space="preserve">
          <source>ServeConn runs the DefaultServer on a single connection. ServeConn blocks, serving the connection until the client hangs up. The caller typically invokes ServeConn in a go statement. ServeConn uses the gob wire format (see package gob) on the connection. To use an alternate codec, use ServeCodec. See NewClient's comment for information about concurrent access.</source>
          <target state="translated">ServeConn在单个连接上运行DefaultServer。ServeConn阻塞,为连接服务,直到客户端挂断。调用者通常在go语句中调用ServeConn。ServeConn在连接上使用gob线格式(参见包gob)。要使用其他的编解码器,请使用ServeCodec。关于并发访问的信息,请参见NewClient的注释。</target>
        </trans-unit>
        <trans-unit id="d136d0992046f83551cea5f2576de13dc7e39384" translate="yes" xml:space="preserve">
          <source>ServeConn runs the JSON-RPC server on a single connection. ServeConn blocks, serving the connection until the client hangs up. The caller typically invokes ServeConn in a go statement.</source>
          <target state="translated">ServeConn在单个连接上运行JSON-RPC服务器。ServeConn阻塞,为连接服务,直到客户端挂断。调用者通常在go语句中调用ServeConn。</target>
        </trans-unit>
        <trans-unit id="2f01374418f76760c6cb616cbabd675e38909787" translate="yes" xml:space="preserve">
          <source>ServeConn runs the server on a single connection. ServeConn blocks, serving the connection until the client hangs up. The caller typically invokes ServeConn in a go statement. ServeConn uses the gob wire format (see package gob) on the connection. To use an alternate codec, use ServeCodec. See NewClient's comment for information about concurrent access.</source>
          <target state="translated">ServeConn在单个连接上运行服务器。ServeConn阻塞,为连接服务,直到客户端挂断。调用者通常在go语句中调用ServeConn。ServeConn在连接上使用gob线格式(参见包gob)。要使用其他的编解码器,请使用ServeCodec。关于并发访问的信息,请参见NewClient的注释。</target>
        </trans-unit>
        <trans-unit id="ef53643ab98faf2b116983a1f327c585aaa8a435" translate="yes" xml:space="preserve">
          <source>ServeContent replies to the request using the content in the provided ReadSeeker. The main benefit of ServeContent over io.Copy is that it handles Range requests properly, sets the MIME type, and handles If-Match, If-Unmodified-Since, If-None-Match, If-Modified-Since, and If-Range requests.</source>
          <target state="translated">ServeContent使用提供的ReadSeeker中的内容来回复请求。与io.Copy相比,ServeContent的主要好处是它能正确处理Range请求,设置MIME类型,并处理If-Match、If-Unmodified-Since、If-None-Match、If-Modified-Since和If-Range请求。</target>
        </trans-unit>
        <trans-unit id="cfd658fe667ad1d964897018a5c4cf11bec05335" translate="yes" xml:space="preserve">
          <source>ServeFile replies to the request with the contents of the named file or directory.</source>
          <target state="translated">ServeFile用命名的文件或目录的内容来回复请求。</target>
        </trans-unit>
        <trans-unit id="049197d23952867737fe7bc77daa12a248c70057" translate="yes" xml:space="preserve">
          <source>ServeHTTP calls f(w, r).</source>
          <target state="translated">ServeHTTP调用f(w,r)。</target>
        </trans-unit>
        <trans-unit id="4c4916bc850460672f4222f24dda17f824b214d6" translate="yes" xml:space="preserve">
          <source>ServeHTTP dispatches the request to the handler whose pattern most closely matches the request URL.</source>
          <target state="translated">ServeHTTP将请求发送到与请求URL最匹配的模式的处理程序。</target>
        </trans-unit>
        <trans-unit id="21deb32922a44f4fb534ed8afc10e377cb3ed92e" translate="yes" xml:space="preserve">
          <source>ServeHTTP implements an http.Handler that answers RPC requests.</source>
          <target state="translated">ServeHTTP实现了一个http.Handler,用于响应RPC请求。</target>
        </trans-unit>
        <trans-unit id="6b5f212880feffc9d4b20ece24bb964f1dfe9a0e" translate="yes" xml:space="preserve">
          <source>ServeHTTP should write reply headers and data to the ResponseWriter and then return. Returning signals that the request is finished; it is not valid to use the ResponseWriter or read from the Request.Body after or concurrently with the completion of the ServeHTTP call.</source>
          <target state="translated">ServeHTTP应该向ResponseWriter写入回复头和数据,然后返回。返回标志着请求已完成;在ServeHTTP调用完成后或与之同时使用ResponseWriter或从Request.Body读取数据是无效的。</target>
        </trans-unit>
        <trans-unit id="643b76d4394a8e8ca4ec7165cbad824736ed0dab" translate="yes" xml:space="preserve">
          <source>ServeMux also takes care of sanitizing the URL request path and the Host header, stripping the port number and redirecting any request containing . or .. elements or repeated slashes to an equivalent, cleaner URL.</source>
          <target state="translated">ServeMux还负责净化URL请求路径和Host头,去除端口号,并将任何包含.或.元素或重复斜杠的请求重定向到一个等价的、更干净的URL。</target>
        </trans-unit>
        <trans-unit id="c2c623da8699103087cc62f3c47b54b0c6fbdef4" translate="yes" xml:space="preserve">
          <source>ServeMux is an HTTP request multiplexer. It matches the URL of each incoming request against a list of registered patterns and calls the handler for the pattern that most closely matches the URL.</source>
          <target state="translated">ServeMux是一个HTTP请求复用器。它将每个传入请求的URL与注册模式列表进行匹配,并调用与URL最匹配的模式的处理程序。</target>
        </trans-unit>
        <trans-unit id="d57d6d29bc00d69dcb5016e00c29678f29b25c20" translate="yes" xml:space="preserve">
          <source>ServeMux.Handle</source>
          <target state="translated">ServeMux.Handle</target>
        </trans-unit>
        <trans-unit id="a2ccb85e8b555a7018f6848932b3cf1638f89e04" translate="yes" xml:space="preserve">
          <source>ServeRequest is like ServeCodec but synchronously serves a single request. It does not close the codec upon completion.</source>
          <target state="translated">ServeRequest与ServeCodec类似,但同步服务于单个请求。它不会在完成后关闭编解码器。</target>
        </trans-unit>
        <trans-unit id="914b527f3acbaa5705eeffe44b971ef90f12446b" translate="yes" xml:space="preserve">
          <source>ServeTLS accepts incoming HTTPS connections on the listener l, creating a new service goroutine for each. The service goroutines read requests and then call handler to reply to them.</source>
          <target state="translated">ServeTLS在监听器l上接受传入的HTTPS连接,为每个连接创建一个新的服务goroutine。服务goroutine读取请求,然后调用handler来回复请求。</target>
        </trans-unit>
        <trans-unit id="0a96e454a3074cfb2a672bba732fc55cf3ace063" translate="yes" xml:space="preserve">
          <source>ServeTLS accepts incoming connections on the Listener l, creating a new service goroutine for each. The service goroutines perform TLS setup and then read requests, calling srv.Handler to reply to them.</source>
          <target state="translated">ServeTLS接受监听器l上的传入连接,为每个连接创建一个新的服务goroutine。服务goroutine执行TLS设置,然后读取请求,调用srv.Handler来回复请求。</target>
        </trans-unit>
        <trans-unit id="5d05c42df2acb99153f40488ff8b30bf621e7c31" translate="yes" xml:space="preserve">
          <source>ServeTLS always returns a non-nil error.</source>
          <target state="translated">ServeTLS总是返回一个非零的错误。</target>
        </trans-unit>
        <trans-unit id="49b6a1abd7e8e016f95152133848467bef1659cf" translate="yes" xml:space="preserve">
          <source>ServeTLS always returns a non-nil error. After Shutdown or Close, the returned error is ErrServerClosed.</source>
          <target state="translated">ServeTLS总是返回一个非零的错误。关机或关闭后,返回的错误是ErrServerClosed。</target>
        </trans-unit>
        <trans-unit id="cb0cb170d106f8e8d5af1e05bbdbd3a96a7de197" translate="yes" xml:space="preserve">
          <source>Server</source>
          <target state="translated">Server</target>
        </trans-unit>
        <trans-unit id="fd27359b7f3750869c6d376d504d1fa87f6d2a64" translate="yes" xml:space="preserve">
          <source>Server (HTTP2)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ddf4403b77024142dd6473786b6571dc8b196f9" translate="yes" xml:space="preserve">
          <source>Server represents an RPC Server.</source>
          <target state="translated">服务器代表一个RPC服务器。</target>
        </trans-unit>
        <trans-unit id="313ac33490fd78320856fae075839a276bcab472" translate="yes" xml:space="preserve">
          <source>Server returns a new TLS server side connection using conn as the underlying transport. The configuration config must be non-nil and must include at least one certificate or else set GetCertificate.</source>
          <target state="translated">服务器返回一个新的TLS服务器端连接,使用conn作为底层传输。配置config必须为非零,并且必须包含至少一个证书,否则设置GetCertificate。</target>
        </trans-unit>
        <trans-unit id="e0b4e659e40eb8a8a1e289fa3271bf98ef6e2706" translate="yes" xml:space="preserve">
          <source>Server.Shutdown</source>
          <target state="translated">Server.Shutdown</target>
        </trans-unit>
        <trans-unit id="e8983457da1ab21a6c85c2a9507e94af92a8934d" translate="yes" xml:space="preserve">
          <source>ServerConn is an artifact of Go's early HTTP implementation. It is low-level, old, and unused by Go's current HTTP stack. We should have deleted it before Go 1.</source>
          <target state="translated">ServerConn是Go早期HTTP实现的产物。它是低级的、旧的,而且没有被Go当前的HTTP栈使用。我们应该在Go 1之前删除它。</target>
        </trans-unit>
        <trans-unit id="e48e77ca43f54c7c217d619efb9bd95f1a1f8aba" translate="yes" xml:space="preserve">
          <source>ServerError represents an error that has been returned from the remote side of the RPC connection.</source>
          <target state="translated">ServerError表示从RPC连接的远程端返回的错误。</target>
        </trans-unit>
        <trans-unit id="547b92e886182f3f71367607ff47558fb0fe8029" translate="yes" xml:space="preserve">
          <source>ServerInfo records information about an SMTP server.</source>
          <target state="translated">ServerInfo 记录了一个 SMTP 服务器的信息。</target>
        </trans-unit>
        <trans-unit id="870594a7b5d015bba7a8d2c0875c56f2fce85f71" translate="yes" xml:space="preserve">
          <source>SessionResetter may be implemented by Conn to allow drivers to reset the session state associated with the connection and to signal a bad connection.</source>
          <target state="translated">SessionResetter可以由Conn实现,以允许驱动程序重置与连接相关联的会话状态,并发出坏连接的信号。</target>
        </trans-unit>
        <trans-unit id="aab8e5c4d0aeae85893fd621bc37db1b1a73696a" translate="yes" xml:space="preserve">
          <source>Set assigns x to the value v. It panics if CanSet returns false. As in Go, x's value must be assignable to v's type.</source>
          <target state="translated">Set将x赋值给值v,如果CanSet返回false,它就会恐慌。和围棋中一样,x的值必须可以分配给v的类型。</target>
        </trans-unit>
        <trans-unit id="1d2a8709f5b7f411cc9ba583a652581b21b6d185" translate="yes" xml:space="preserve">
          <source>Set is called once, in command line order, for each flag present. The flag package may call the String method with a zero-valued receiver, such as a nil pointer.</source>
          <target state="translated">Set按照命令行顺序,对每个存在的标志调用一次。标志包可以用一个零值的接收器,比如一个nil指针来调用String方法。</target>
        </trans-unit>
        <trans-unit id="e8fb40cfeae3d73e6b30e01495ac2c9fe7ff8cc2" translate="yes" xml:space="preserve">
          <source>Set sets the JavaScript property p of value v to ValueOf(x). It panics if v is not a JavaScript object.</source>
          <target state="translated">Set将值v的JavaScript属性p设置为ValueOf(x)。如果v不是JavaScript对象,它就会恐慌。</target>
        </trans-unit>
        <trans-unit id="87f6096d8457ac4b04a70faa68ba0c62c9f61ecc" translate="yes" xml:space="preserve">
          <source>Set sets the header entries associated with key to the single element value. It replaces any existing values associated with key.</source>
          <target state="translated">设置将与key相关联的头条目设置为单元素值。它替换任何与key相关联的现有值。</target>
        </trans-unit>
        <trans-unit id="82fcf24728ab76cc9481c998a3f5414cead1eb36" translate="yes" xml:space="preserve">
          <source>Set sets the header entries associated with key to the single element value. It replaces any existing values associated with key. The key is case insensitive; it is canonicalized by textproto.CanonicalMIMEHeaderKey. To use non-canonical keys, assign to the map directly.</source>
          <target state="translated">设置将与key相关联的头条目设置为单元素值。它替换任何与key相关联的现有值。key不区分大小写;它由textproto.CanonicalMIMEHeaderKey规范化。要使用非规范的键,请直接分配给地图。</target>
        </trans-unit>
        <trans-unit id="ac88d8d813ac589b26e82c68ebe23a65cc8513a6" translate="yes" xml:space="preserve">
          <source>Set sets the key to value. It replaces any existing values.</source>
          <target state="translated">Set将键值设置为值。它替换任何现有的值。</target>
        </trans-unit>
        <trans-unit id="03d2da815b81b3b89a818437487ee57f67fe7d66" translate="yes" xml:space="preserve">
          <source>Set sets the value of the named command-line flag.</source>
          <target state="translated">设置设置命名的命令行标志的值。</target>
        </trans-unit>
        <trans-unit id="f73f9638b07619a017d2f6dac015fd0d243d8333" translate="yes" xml:space="preserve">
          <source>Set sets the value of the named flag.</source>
          <target state="translated">设置设置命名标志的值。</target>
        </trans-unit>
        <trans-unit id="2c301753363dd5c13e85e87be14b65f72e0bdbb9" translate="yes" xml:space="preserve">
          <source>Set sets v to value.</source>
          <target state="translated">设将v设为值。</target>
        </trans-unit>
        <trans-unit id="0e0649c67f5fc5e092366b50d2ec623dd85834a8" translate="yes" xml:space="preserve">
          <source>Set sets z to the (possibly rounded) value of x and returns z. If z's precision is 0, it is changed to the precision of x before setting z (and rounding will have no effect). Rounding is performed according to z's precision and rounding mode; and z's accuracy reports the result error relative to the exact (not rounded) result.</source>
          <target state="translated">设置z为x的(可能是四舍五入)值,并返回z。如果z的精度为0,则在设置z之前将其改为x的精度(四舍五入没有影响)。四舍五入是根据z的精度和四舍五入模式进行的;z的精度报告了相对于精确(未四舍五入)结果的误差。</target>
        </trans-unit>
        <trans-unit id="74c097d8a8db6198a9f30d1da9cc40810faf97ea" translate="yes" xml:space="preserve">
          <source>Set sets z to x (by making a copy of x) and returns z.</source>
          <target state="translated">设置z为x(通过复制x)并返回z。</target>
        </trans-unit>
        <trans-unit id="2de2c16a0340db2bee0118ccf9d1587fd704cd50" translate="yes" xml:space="preserve">
          <source>Set sets z to x and returns z.</source>
          <target state="translated">设z为x,并返回z。</target>
        </trans-unit>
        <trans-unit id="fd19264e05439f601808981687979a9cbd55329f" translate="yes" xml:space="preserve">
          <source>SetBasicAuth sets the request's Authorization header to use HTTP Basic Authentication with the provided username and password.</source>
          <target state="translated">SetBasicAuth设置请求的授权头使用提供的用户名和密码进行HTTP基本认证。</target>
        </trans-unit>
        <trans-unit id="22bdae472d3db85cab5c57989c6be910d803a01e" translate="yes" xml:space="preserve">
          <source>SetBit sets z to x, with x's i'th bit set to b (0 or 1). That is, if b is 1 SetBit sets z = x | (1 &amp;lt;&amp;lt; i); if b is 0 SetBit sets z = x &amp;amp;^ (1 &amp;lt;&amp;lt; i). If b is not 0 or 1, SetBit will panic.</source>
          <target state="translated">SetBit将z设置为x，将x的第i位设置为b（0或1）。即，如果b为1，则SetBit设置z = x | | | | |。（1 &amp;lt;&amp;lt;我）; 如果b为0 SetBit设置z = x＆^（1 &amp;lt;&amp;lt; i）。如果b不为0或1，则SetBit将发生恐慌。</target>
        </trans-unit>
        <trans-unit id="feba31f1e1635889b9235c6993fbb340077ba325" translate="yes" xml:space="preserve">
          <source>SetBits provides raw (unchecked but fast) access to z by setting its value to abs, interpreted as a little-endian Word slice, and returning z. The result and abs share the same underlying array. SetBits is intended to support implementation of missing low-level Int functionality outside this package; it should be avoided otherwise.</source>
          <target state="translated">SetBits通过将z的值设置为abs来提供对z的原始访问(未被选中但速度很快),将其解释为一个小二进制的Word片断,然后返回z。结果和abs共享同一个底层数组。SetBits的目的是为了支持在本包之外实现缺失的低级Int功能;否则应该避免使用它。</target>
        </trans-unit>
        <trans-unit id="f0a90ede61cca8ba0e26af9fe2c3c6480079bf80" translate="yes" xml:space="preserve">
          <source>SetBlockProfileRate controls the fraction of goroutine blocking events that are reported in the blocking profile. The profiler aims to sample an average of one blocking event per rate nanoseconds spent blocked.</source>
          <target state="translated">SetBlockProfileRate控制在阻塞配置文件中报告的goroutine阻塞事件的分数。剖析器的目标是平均每花一个速率纳秒阻塞事件的样本。</target>
        </trans-unit>
        <trans-unit id="459d3a69d65d385fb3b3fbe398bb9c85138ddcc2" translate="yes" xml:space="preserve">
          <source>SetBool sets v's underlying value. It panics if v's Kind is not Bool or if CanSet() is false.</source>
          <target state="translated">SetBool设置v的底层值,如果v的Kind不是Bool或者CanSet()是false,它就会恐慌。如果v的Kind不是Bool或者CanSet()是false,它就会恐慌。</target>
        </trans-unit>
        <trans-unit id="7e2455227631da0419c37dea6613f51644e9e03d" translate="yes" xml:space="preserve">
          <source>SetBoundary must be called before any parts are created, may only contain certain ASCII characters, and must be non-empty and at most 70 bytes long.</source>
          <target state="translated">SetBoundary必须在创建任何部件之前被调用,只能包含某些ASCII字符,并且必须是非空的,最多只能有70字节长。</target>
        </trans-unit>
        <trans-unit id="b06cf4ca1fda2091c2541de19f0b4a515ade4ba9" translate="yes" xml:space="preserve">
          <source>SetBoundary overrides the Writer's default randomly-generated boundary separator with an explicit value.</source>
          <target state="translated">SetBoundary用一个明确的值覆盖了Writer的默认随机生成的边界分隔符。</target>
        </trans-unit>
        <trans-unit id="6106f2ae31464af3b2e7f9b63e64b76356750152" translate="yes" xml:space="preserve">
          <source>SetBytes interprets buf as the bytes of a big-endian unsigned integer, sets z to that value, and returns z.</source>
          <target state="translated">SetBytes 将 buf 解释为一个大段无符号整数的字节,将 z 设置为该值,并返回 z。</target>
        </trans-unit>
        <trans-unit id="7a0583b12bc86b9434e36c34c4ce6e8b5c26ba75" translate="yes" xml:space="preserve">
          <source>SetBytes records the number of bytes processed in a single operation. If this is called, the benchmark will report ns/op and MB/s.</source>
          <target state="translated">SetBytes记录单次操作中处理的字节数。如果调用此功能,基准将报告ns/op和MB/s。</target>
        </trans-unit>
        <trans-unit id="bba92654aa999e9512f4dfa6313cb2838144dfe3" translate="yes" xml:space="preserve">
          <source>SetBytes sets v's underlying value. It panics if v's underlying value is not a slice of bytes.</source>
          <target state="translated">SetBytes设置v的底层值。如果v的底层值不是一个字节的片断,它就会惊慌失措。</target>
        </trans-unit>
        <trans-unit id="344d8ddf2a696d0cf0cc16a1825af1241c772a89" translate="yes" xml:space="preserve">
          <source>SetCPUProfileRate sets the CPU profiling rate to hz samples per second. If hz &amp;lt;= 0, SetCPUProfileRate turns off profiling. If the profiler is on, the rate cannot be changed without first turning it off.</source>
          <target state="translated">SetCPUProfileRate将CPU分析速率设置为每秒hz个样本。如果hz &amp;lt;= 0，则SetCPUProfileRate关闭分析。如果探查器已打开，则必须先将其关闭才能更改速率。</target>
        </trans-unit>
        <trans-unit id="1afcde63337e23e05a9b84c1c7b85f57c0092cd7" translate="yes" xml:space="preserve">
          <source>SetCap sets v's capacity to n. It panics if v's Kind is not Slice or if n is smaller than the length or greater than the capacity of the slice.</source>
          <target state="translated">SetCap将v的容量设置为n。如果v的Kind不是Slice,或者n小于长度或大于分片的容量,它就会恐慌。</target>
        </trans-unit>
        <trans-unit id="44731bc16b3d80516224c7c852f64732d07d62c1" translate="yes" xml:space="preserve">
          <source>SetCgoTraceback records three C functions to use to gather traceback information from C code and to convert that traceback information into symbolic information. These are used when printing stack traces for a program that uses cgo.</source>
          <target state="translated">SetCgoTraceback记录了三个C函数,用于从C代码中收集回溯信息,并将回溯信息转换为符号信息。这些函数在打印使用cgo的程序的堆栈跟踪信息时使用。</target>
        </trans-unit>
        <trans-unit id="348727b9cf484ab1b9762cea6ba0daa8dde8a933" translate="yes" xml:space="preserve">
          <source>SetCgoTraceback should be called only once, ideally from an init function.</source>
          <target state="translated">SetCgoTraceback应该只被调用一次,最好是在一个init函数中调用。</target>
        </trans-unit>
        <trans-unit id="67fdfbbba9d56846727e0eb32ef8332c0bf20f53" translate="yes" xml:space="preserve">
          <source>SetComment sets the end-of-central-directory comment field. It can only be called before Close.</source>
          <target state="translated">SetComment 设置中心目录结束时的注释字段。它只能在关闭之前被调用。</target>
        </trans-unit>
        <trans-unit id="64f03250bccb0b87aeb45d79cb945d1dd0319cb9" translate="yes" xml:space="preserve">
          <source>SetComplex sets v's underlying value to x. It panics if v's Kind is not Complex64 or Complex128, or if CanSet() is false.</source>
          <target state="translated">如果v的Kind不是Complex64或Complex128,或者CanSet()为false,它就会恐慌。</target>
        </trans-unit>
        <trans-unit id="b69ac591abf21b23b441af754a7112fe6fa046f7" translate="yes" xml:space="preserve">
          <source>SetConnMaxIdleTime sets the maximum amount of time a connection may be idle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac6f79734771b4e3adca460b8931ae634206e20f" translate="yes" xml:space="preserve">
          <source>SetConnMaxLifetime sets the maximum amount of time a connection may be reused.</source>
          <target state="translated">SetConnMaxLifetime设置一个连接可以重复使用的最大时间。</target>
        </trans-unit>
        <trans-unit id="cdfc398e60b71e846a0a56ba3b1860f275a8c713" translate="yes" xml:space="preserve">
          <source>SetCookie adds a Set-Cookie header to the provided ResponseWriter's headers. The provided cookie must have a valid Name. Invalid cookies may be silently dropped.</source>
          <target state="translated">SetCookie 会在所提供的 ResponseWriter 的头文件中添加一个 Set-Cookie 头文件。提供的 cookie 必须有一个有效的 Name。无效的cookie可能会被静静地放弃。</target>
        </trans-unit>
        <trans-unit id="b1b53737e17baa71a51a0e5ede6a121ccba30720" translate="yes" xml:space="preserve">
          <source>SetCookies implements the SetCookies method of the http.CookieJar interface.</source>
          <target state="translated">SetCookies实现了http.CookieJar接口的SetCookies方法。</target>
        </trans-unit>
        <trans-unit id="d3cec8d8761e8a9c75efaa51883455428c208775" translate="yes" xml:space="preserve">
          <source>SetDeadline implements the Conn SetDeadline method.</source>
          <target state="translated">SetDeadline实现Conn SetDeadline方法。</target>
        </trans-unit>
        <trans-unit id="c0b50695667af085ed75f6ae0d7d496b50008cd3" translate="yes" xml:space="preserve">
          <source>SetDeadline sets the deadline associated with the listener. A zero time value disables the deadline.</source>
          <target state="translated">SetDeadline设置与监听器相关联的截止时间。时间值为零则禁用截止时间。</target>
        </trans-unit>
        <trans-unit id="a7b4723a8859169359d85b5290587d68a0fc3307" translate="yes" xml:space="preserve">
          <source>SetDeadline sets the read and write deadlines associated with the connection. A zero value for t means Read and Write will not time out. After a Write has timed out, the TLS state is corrupt and all future writes will return the same error.</source>
          <target state="translated">SetDeadline设置与连接相关的读写截止时间。t的值为零意味着读和写不会超时。写入超时后,TLS状态就会损坏,以后所有的写入都会返回同样的错误。</target>
        </trans-unit>
        <trans-unit id="883b1167470e9a9bc17df175940ef7113ec71b15" translate="yes" xml:space="preserve">
          <source>SetDeadline sets the read and write deadlines for a File. It is equivalent to calling both SetReadDeadline and SetWriteDeadline.</source>
          <target state="translated">SetDeadline设置文件的读和写截止时间。它相当于同时调用SetReadDeadline和SetWriteDeadline。</target>
        </trans-unit>
        <trans-unit id="7aad8c47d1ea7eb52b60d62c5b63c9894a7f6a08" translate="yes" xml:space="preserve">
          <source>SetEscapeHTML specifies whether problematic HTML characters should be escaped inside JSON quoted strings. The default behavior is to escape &amp;amp;, &amp;lt;, and &amp;gt; to \u0026, \u003c, and \u003e to avoid certain safety problems that can arise when embedding JSON in HTML.</source>
          <target state="translated">SetEscapeHTML指定是否应在JSON引用的字符串内转义有问题的HTML字符。缺省行为是将＆，&amp;lt;和&amp;gt;转义为\ u0026，\ u003c和\ u003e，以避免在将JSON嵌入HTML时可能出现的某些安全问题。</target>
        </trans-unit>
        <trans-unit id="dd27241a174aea4c1fb70802e55de9c35c7e1aca" translate="yes" xml:space="preserve">
          <source>SetFinalizer sets the finalizer associated with obj to the provided finalizer function. When the garbage collector finds an unreachable block with an associated finalizer, it clears the association and runs finalizer(obj) in a separate goroutine. This makes obj reachable again, but now without an associated finalizer. Assuming that SetFinalizer is not called again, the next time the garbage collector sees that obj is unreachable, it will free obj.</source>
          <target state="translated">SetFinalizer将与obj关联的finalizer设置为提供的finalizer函数。当垃圾回收器发现一个不可到达的块,并有一个关联的finalizer时,它会清除关联,并在一个单独的goroutine中运行finalizer(obj)。这使得obj再次可达,但现在没有关联的终结器。假设SetFinalizer没有被再次调用,下次垃圾回收器看到obj不可到达时,它将释放obj。</target>
        </trans-unit>
        <trans-unit id="516de8a9b6e7300def0c0d80a14119cce09c9af1" translate="yes" xml:space="preserve">
          <source>SetFinalizer(obj, nil) clears any finalizer associated with obj.</source>
          <target state="translated">SetFinalizer(obj,nil)清除任何与obj相关联的定标器。</target>
        </trans-unit>
        <trans-unit id="fce6aef209330cc8b12176816b79927fb4cacd60" translate="yes" xml:space="preserve">
          <source>SetFlags sets the output flags for the logger.</source>
          <target state="translated">SetFlags 设置记录仪的输出标志。</target>
        </trans-unit>
        <trans-unit id="2389acee4b107177db39a04d2a50d69a80e07539" translate="yes" xml:space="preserve">
          <source>SetFlags sets the output flags for the logger. The flag bits are Ldate, Ltime, and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd0ec7930cc082a2a1ef8ed98443be56c5746d85" translate="yes" xml:space="preserve">
          <source>SetFlags sets the output flags for the standard logger.</source>
          <target state="translated">SetFlags 设置标准记录器的输出标志。</target>
        </trans-unit>
        <trans-unit id="e112d20317b511d78e95cf42b818e10d239d1b7a" translate="yes" xml:space="preserve">
          <source>SetFlags sets the output flags for the standard logger. The flag bits are Ldate, Ltime, and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a44e49f661219c769f20780167a6964483f17f7a" translate="yes" xml:space="preserve">
          <source>SetFloat sets v's underlying value to x. It panics if v's Kind is not Float32 or Float64, or if CanSet() is false.</source>
          <target state="translated">如果v的种类不是Float32或Float64,或者CanSet()为false,它就会恐慌。</target>
        </trans-unit>
        <trans-unit id="8e47d96a49d3af2841a8dc184d5134cb1a32de48" translate="yes" xml:space="preserve">
          <source>SetFloat64 sets z to exactly f and returns z. If f is not finite, SetFloat returns nil.</source>
          <target state="translated">SetFloat64将z精确地设置为f并返回z。如果f不是有限的,SetFloat返回nil。</target>
        </trans-unit>
        <trans-unit id="7d8e2534e02690c3fed1859413bf2f8f63c436f1" translate="yes" xml:space="preserve">
          <source>SetFloat64 sets z to the (possibly rounded) value of x and returns z. If z's precision is 0, it is changed to 53 (and rounding will have no effect). SetFloat64 panics with ErrNaN if x is a NaN.</source>
          <target state="translated">SetFloat64将z设置为x的(可能是四舍五入)值,并返回z。如果z的精度为0,则改为53(四舍五入没有影响)。如果x是NaN,SetFloat64会用ErrNaN恐慌。</target>
        </trans-unit>
        <trans-unit id="7b801568b0fa82e3d000c6cfdb98f7b328836a9b" translate="yes" xml:space="preserve">
          <source>SetFrac sets z to a/b and returns z.</source>
          <target state="translated">SetFrac将z设置为a/b,并返回z。</target>
        </trans-unit>
        <trans-unit id="a9ac4380aa91d01b1e1308169f05c3eff9861e31" translate="yes" xml:space="preserve">
          <source>SetFrac sets z to a/b and returns z. If b == 0, SetFrac panics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45fde5eac415722d6b8394ea7547d400d1373021" translate="yes" xml:space="preserve">
          <source>SetFrac64 sets z to a/b and returns z.</source>
          <target state="translated">SetFrac64将z设置为a/b并返回z。</target>
        </trans-unit>
        <trans-unit id="5993df56e43367a1c47f44460a83d56bdcf65739" translate="yes" xml:space="preserve">
          <source>SetFrac64 sets z to a/b and returns z. If b == 0, SetFrac64 panics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="805636f93a7dd0b6aa2183e35b0d00ca6d7104e9" translate="yes" xml:space="preserve">
          <source>SetGCPercent sets the garbage collection target percentage: a collection is triggered when the ratio of freshly allocated data to live data remaining after the previous collection reaches this percentage. SetGCPercent returns the previous setting. The initial setting is the value of the GOGC environment variable at startup, or 100 if the variable is not set. A negative percentage disables garbage collection.</source>
          <target state="translated">SetGCPercent设置垃圾收集目标百分比:当上一次收集后新分配的数据与剩余的活数据的比例达到这个百分比时,就会触发一次收集。SetGCPercent返回之前的设置。初始设置是启动时GOGC环境变量的值,如果没有设置该变量,则为100。负的百分比会禁用垃圾收集。</target>
        </trans-unit>
        <trans-unit id="906978195b1fb386902e36080f453c88d02f6211" translate="yes" xml:space="preserve">
          <source>SetGoroutineLabels sets the current goroutine's labels to match ctx. A new goroutine inherits the labels of the goroutine that created it. This is a lower-level API than Do, which should be used instead when possible.</source>
          <target state="translated">SetGoroutineLabels 设置当前goroutine的标签以匹配ctx。新的goroutine会继承创建它的goroutine的标签。这是一个比Do更低级的API,在可能的情况下应该使用Do。</target>
        </trans-unit>
        <trans-unit id="7c95fdd46823686f50f0d15060d185e4b4e5d563" translate="yes" xml:space="preserve">
          <source>SetImports sets the list of explicitly imported packages to list. It is the caller's responsibility to make sure list elements are unique.</source>
          <target state="translated">SetImports 将显式导入的软件包列表设置为 list。调用者有责任确保列表元素是唯一的。</target>
        </trans-unit>
        <trans-unit id="e7fb2cb55e4274d490452e6757d30cb84eb70855" translate="yes" xml:space="preserve">
          <source>SetIndent instructs the encoder to format each subsequent encoded value as if indented by the package-level function Indent(dst, src, prefix, indent). Calling SetIndent(&quot;&quot;, &quot;&quot;) disables indentation.</source>
          <target state="translated">SetIndent 指示编码器将随后的每个编码值格式化,就像包级函数 Indent(dst,src,prefix,indent)一样缩进。调用SetIndent(&quot;&quot;,&quot;&quot;)会禁用缩进。</target>
        </trans-unit>
        <trans-unit id="17d73d2c7105e3ec880ec1de340daf4f290af178" translate="yes" xml:space="preserve">
          <source>SetIndex sets the JavaScript index i of value v to ValueOf(x). It panics if v is not a JavaScript object.</source>
          <target state="translated">SetIndex将值v的JavaScript索引i设置为ValueOf(x)。如果v不是JavaScript对象,它就会惊慌失措。</target>
        </trans-unit>
        <trans-unit id="cea11721fc2a69428fc01f2bd7212d126248c97a" translate="yes" xml:space="preserve">
          <source>SetInf sets z to the infinite Float -Inf if signbit is set, or +Inf if signbit is not set, and returns z. The precision of z is unchanged and the result is always Exact.</source>
          <target state="translated">SetInf如果设置了signbit,则将z设置为无穷大的Float -Inf,如果没有设置signbit,则设置为+Inf,并返回z,z的精度不变,结果始终为Exact。</target>
        </trans-unit>
        <trans-unit id="7fbe79d67709b54bb947c5fb56d1678d22a06e68" translate="yes" xml:space="preserve">
          <source>SetInt sets v's underlying value to x. It panics if v's Kind is not Int, Int8, Int16, Int32, or Int64, or if CanSet() is false.</source>
          <target state="translated">如果v的Kind不是Int、Int8、Int16、Int32或Int64,或者CanSet()为false,它就会恐慌。</target>
        </trans-unit>
        <trans-unit id="e9791f172aed7c20562244430ee2933689079ec7" translate="yes" xml:space="preserve">
          <source>SetInt sets z to the (possibly rounded) value of x and returns z. If z's precision is 0, it is changed to the larger of x.BitLen() or 64 (and rounding will have no effect).</source>
          <target state="translated">SetInt将z设置为x的(可能是四舍五入)值,并返回z。如果z的精度为0,则改为x.BitLen()或64中较大的一个(四舍五入没有影响)。</target>
        </trans-unit>
        <trans-unit id="512491a3910b089e941ff0967a1c4600d38512e1" translate="yes" xml:space="preserve">
          <source>SetInt sets z to x (by making a copy of x) and returns z.</source>
          <target state="translated">SetInt将z设置为x(通过复制x)并返回z。</target>
        </trans-unit>
        <trans-unit id="e98bca88644a6b411de0d879f43c3dc3a73ef347" translate="yes" xml:space="preserve">
          <source>SetInt64 sets z to the (possibly rounded) value of x and returns z. If z's precision is 0, it is changed to 64 (and rounding will have no effect).</source>
          <target state="translated">SetInt64将z设置为x的(可能是四舍五入)值,并返回z。如果z的精度为0,则改为64(四舍五入没有影响)。</target>
        </trans-unit>
        <trans-unit id="b8bc149266ba57391034d803e65399926af1a382" translate="yes" xml:space="preserve">
          <source>SetInt64 sets z to x and returns z.</source>
          <target state="translated">SetInt64将z设置为x并返回z。</target>
        </trans-unit>
        <trans-unit id="d8ce7465b1093a7258c6cd344217beee671aa978" translate="yes" xml:space="preserve">
          <source>SetKeepAlive sets whether the operating system should send keep-alive messages on the connection.</source>
          <target state="translated">SetKeepAlive设置操作系统是否应该在连接上发送保持活力的消息。</target>
        </trans-unit>
        <trans-unit id="89bf3d4dd275ff44ab7379e669050fce6f5a7eee" translate="yes" xml:space="preserve">
          <source>SetKeepAlivePeriod sets period between keep-alives.</source>
          <target state="translated">SetKeepAlivePeriod设置保持生命的周期。</target>
        </trans-unit>
        <trans-unit id="582102a7fa3d8dd186ee22dfa213a701e54c1846" translate="yes" xml:space="preserve">
          <source>SetKeepAlivesEnabled controls whether HTTP keep-alives are enabled. By default, keep-alives are always enabled. Only very resource-constrained environments or servers in the process of shutting down should disable them.</source>
          <target state="translated">SetKeepAlivesEnabled控制HTTP keep-alives是否被启用。默认情况下,keep-alives总是被启用。只有资源非常有限的环境或正在关闭的服务器才应该禁用它们。</target>
        </trans-unit>
        <trans-unit id="26dfe6afebdd675610dd8f1d4858b29cc7ee92db" translate="yes" xml:space="preserve">
          <source>SetLen sets v's length to n. It panics if v's Kind is not Slice or if n is negative or greater than the capacity of the slice.</source>
          <target state="translated">SetLen 将 v 的长度设置为 n。如果 v 的 Kind 不是 Slice,或者 n 为负值或大于 slice 的容量,它就会恐慌。</target>
        </trans-unit>
        <trans-unit id="549c2b676df9b698394503e0fb62c18e8fa20e0b" translate="yes" xml:space="preserve">
          <source>SetLines sets the line offsets for a file and reports whether it succeeded. The line offsets are the offsets of the first character of each line; for instance for the content &quot;ab\nc\n&quot; the line offsets are {0, 3}. An empty file has an empty line offset table. Each line offset must be larger than the offset for the previous line and smaller than the file size; otherwise SetLines fails and returns false. Callers must not mutate the provided slice after SetLines returns.</source>
          <target state="translated">SetLines设置文件的行偏移量并报告是否成功。行偏移量是每行第一个字符的偏移量;例如对于内容 &quot;ab\nc\n&quot;,行偏移量是{0,3}。一个空文件的行偏移表是空的。每一行的偏移量必须大于前一行的偏移量,并且小于文件大小;否则SetLines会失败并返回false。调用者在SetLines返回后不得突变提供的分片。</target>
        </trans-unit>
        <trans-unit id="d21966bc8423cbdfca9062e709a1e1bfe2b23f9c" translate="yes" xml:space="preserve">
          <source>SetLinesForContent sets the line offsets for the given file content. It ignores position-altering //line comments.</source>
          <target state="translated">SetLinesForContent 设置给定文件内容的行偏移量。它忽略了位置改变的//行注释。</target>
        </trans-unit>
        <trans-unit id="7ead5ff3e458c012090db0e3e46dd956293c59f9" translate="yes" xml:space="preserve">
          <source>SetLinger sets the behavior of Close on a connection which still has data waiting to be sent or to be acknowledged.</source>
          <target state="translated">SetLinger设置关闭连接的行为,如果连接上还有数据等待发送或确认。</target>
        </trans-unit>
        <trans-unit id="be9cec1a054bdf6dae13515b712cb92bca8f03d8" translate="yes" xml:space="preserve">
          <source>SetMantExp sets z to mant &amp;times; 2**exp and returns z. The result z has the same precision and rounding mode as mant. SetMantExp is an inverse of MantExp but does not require 0.5 &amp;lt;= |mant| &amp;lt; 1.0. Specifically:</source>
          <target state="translated">SetMantExp将z设置为mant&amp;times;2 ** exp并返回z。结果z具有与mant相同的精度和舍入模式。SetMantExp是MantExp的倒数，但不需要0.5 &amp;lt;= | mant | &amp;lt;1.0。特别：</target>
        </trans-unit>
        <trans-unit id="e756f252cafbddbad755f1c06583ad4489564d92" translate="yes" xml:space="preserve">
          <source>SetMapIndex sets the element associated with key in the map v to elem. It panics if v's Kind is not Map. If elem is the zero Value, SetMapIndex deletes the key from the map. Otherwise if v holds a nil map, SetMapIndex will panic. As in Go, key's elem must be assignable to the map's key type, and elem's value must be assignable to the map's elem type.</source>
          <target state="translated">SetMapIndex将地图v中与key关联的元素设置为elem。如果v的Kind不是Map,SetMapIndex就会惊慌失措。如果elem是零值,SetMapIndex会从地图中删除key。否则,如果v持有一个nil的地图,SetMapIndex就会惊慌失措。在Go中,key的elem必须可以分配给map的key类型,elem的value必须可以分配给map的elem类型。</target>
        </trans-unit>
        <trans-unit id="b83dfa89acb5e3c977158b5fc2760de63b71e48b" translate="yes" xml:space="preserve">
          <source>SetMaxIdleConns sets the maximum number of connections in the idle connection pool.</source>
          <target state="translated">SetMaxIdleConns设置空闲连接池中的最大连接数。</target>
        </trans-unit>
        <trans-unit id="aa3863aa142a9c48791c290f00a7c4c3d76f3b6e" translate="yes" xml:space="preserve">
          <source>SetMaxOpenConns sets the maximum number of open connections to the database.</source>
          <target state="translated">SetMaxOpenConns设置数据库的最大开放连接数。</target>
        </trans-unit>
        <trans-unit id="f71d21e95f096f232e72fff30f80b920b1e3f9f5" translate="yes" xml:space="preserve">
          <source>SetMaxStack is useful mainly for limiting the damage done by goroutines that enter an infinite recursion. It only limits future stack growth.</source>
          <target state="translated">SetMaxStack的作用主要是限制进入无限递归的goroutine所造成的伤害。它只限制未来的堆栈增长。</target>
        </trans-unit>
        <trans-unit id="eeacbe78a8fd0d4396f1b6456e34f5857612c565" translate="yes" xml:space="preserve">
          <source>SetMaxStack sets the maximum amount of memory that can be used by a single goroutine stack. If any goroutine exceeds this limit while growing its stack, the program crashes. SetMaxStack returns the previous setting. The initial setting is 1 GB on 64-bit systems, 250 MB on 32-bit systems.</source>
          <target state="translated">SetMaxStack设置单个goroutine栈可以使用的最大内存量。如果任何goroutine在增长其堆栈时超过了这个限制,程序就会崩溃。SetMaxStack返回之前的设置。64位系统的初始设置为1GB,32位系统为250MB。</target>
        </trans-unit>
        <trans-unit id="67aff5f59d34d3ecd519adad914c8c6423eaf752" translate="yes" xml:space="preserve">
          <source>SetMaxThreads is useful mainly for limiting the damage done by programs that create an unbounded number of threads. The idea is to take down the program before it takes down the operating system.</source>
          <target state="translated">SetMaxThreads的作用主要是限制那些创建无限制线程数量的程序所造成的损害。这个想法是在程序击垮操作系统之前就将其击垮。</target>
        </trans-unit>
        <trans-unit id="c6d8bc8cae003fe5d78cf6cda31fbae67e36c482" translate="yes" xml:space="preserve">
          <source>SetMaxThreads sets the maximum number of operating system threads that the Go program can use. If it attempts to use more than this many, the program crashes. SetMaxThreads returns the previous setting. The initial setting is 10,000 threads.</source>
          <target state="translated">SetMaxThreads设置了Go程序可以使用的最大操作系统线程数。如果它试图使用超过这个数量的线程,程序就会崩溃。SetMaxThreads 会返回之前的设置。初始设置为10,000个线程。</target>
        </trans-unit>
        <trans-unit id="806ff185f3a93cc6a21f24b12259c49de358388c" translate="yes" xml:space="preserve">
          <source>SetModTime sets the Modified, ModifiedTime, and ModifiedDate fields to the given time in UTC.</source>
          <target state="translated">SetModTime将Modified、ModifiedTime和ModifiedDate字段设置为给定的UTC时间。</target>
        </trans-unit>
        <trans-unit id="e9c592771061ffaaa3d588fb3aae3da84d0635b8" translate="yes" xml:space="preserve">
          <source>SetMode changes the permission and mode bits for the FileHeader.</source>
          <target state="translated">SetMode改变FileHeader的权限和模式位。</target>
        </trans-unit>
        <trans-unit id="de45da11e316c622a3816956315a15e8817585f9" translate="yes" xml:space="preserve">
          <source>SetMode sets z's rounding mode to mode and returns an exact z. z remains unchanged otherwise. z.SetMode(z.Mode()) is a cheap way to set z's accuracy to Exact.</source>
          <target state="translated">z.SetMode将z的四舍五入模式设置为模式,并返回一个精确的z,否则z将保持不变。z.SetMode(z.Mode())是将z的精度设置为精确的廉价方法。</target>
        </trans-unit>
        <trans-unit id="b01a08220867d2b1a3c66f3bf6f8b7ca7ea5c1ae" translate="yes" xml:space="preserve">
          <source>SetMutexProfileFraction controls the fraction of mutex contention events that are reported in the mutex profile. On average 1/rate events are reported. The previous rate is returned.</source>
          <target state="translated">SetMutexProfileFraction控制在mutex profile中报告的mutex争夺事件的分数。平均报告1/率事件。返回之前的速率。</target>
        </trans-unit>
        <trans-unit id="8c38b4a404d96b417f171861cd9ebaba18b51eaf" translate="yes" xml:space="preserve">
          <source>SetName sets the package name.</source>
          <target state="translated">SetName设置软件包的名称。</target>
        </trans-unit>
        <trans-unit id="d31306f3f7eb161aa0c0b28fdb6eed5363c589c3" translate="yes" xml:space="preserve">
          <source>SetNoDelay controls whether the operating system should delay packet transmission in hopes of sending fewer packets (Nagle's algorithm). The default is true (no delay), meaning that data is sent as soon as possible after a Write.</source>
          <target state="translated">SetNoDelay控制操作系统是否应该延迟数据包传输,以希望发送更少的数据包(Nagle算法)。默认值为true(无延迟),即在写入后尽快发送数据。</target>
        </trans-unit>
        <trans-unit id="27a3c03ba54fb2a44f36a6c425cfa58520c56752" translate="yes" xml:space="preserve">
          <source>SetOffset sets the offset of the beginning of the zip data within the underlying writer. It should be used when the zip data is appended to an existing file, such as a binary executable. It must be called before any data is written.</source>
          <target state="translated">SetOffset 设置 zip 数据在底层写入器中开始的偏移量。当zip数据被附加到一个现有的文件,如二进制可执行文件时,它应该被使用。它必须在任何数据被写入之前被调用。</target>
        </trans-unit>
        <trans-unit id="004613f6cff6f004aabdb462fd19757cc3df0edb" translate="yes" xml:space="preserve">
          <source>SetOutput sets the destination for usage and error messages. If output is nil, os.Stderr is used.</source>
          <target state="translated">SetOutput 设置使用情况和错误信息的目的地,如果输出为nil,则使用os.Stderr。如果输出为nil,则使用os.Stderr。</target>
        </trans-unit>
        <trans-unit id="36faf63cafa162e1ef49476325f422ab20f856dd" translate="yes" xml:space="preserve">
          <source>SetOutput sets the output destination for the logger.</source>
          <target state="translated">SetOutput 设置记录仪的输出目的地。</target>
        </trans-unit>
        <trans-unit id="76988d10d7783ed1525981a82207c054e24adba8" translate="yes" xml:space="preserve">
          <source>SetOutput sets the output destination for the standard logger.</source>
          <target state="translated">SetOutput 设置标准记录仪的输出目的地。</target>
        </trans-unit>
        <trans-unit id="2547ce0f12468d65a113d53c2cfbf0ddbb6dc9bb" translate="yes" xml:space="preserve">
          <source>SetPanicOnFault controls the runtime's behavior when a program faults at an unexpected (non-nil) address. Such faults are typically caused by bugs such as runtime memory corruption, so the default response is to crash the program. Programs working with memory-mapped files or unsafe manipulation of memory may cause faults at non-nil addresses in less dramatic situations; SetPanicOnFault allows such programs to request that the runtime trigger only a panic, not a crash. SetPanicOnFault applies only to the current goroutine. It returns the previous setting.</source>
          <target state="translated">SetPanicOnFault控制运行时的行为,当程序在一个意外(非零)的地址发生故障时。这种故障通常是由运行时内存损坏等错误引起的,所以默认的响应是使程序崩溃。使用内存映射文件或不安全的内存操作的程序可能会在不太引人注目的情况下引起非零地址的故障;SetPanicOnFault允许这类程序要求运行时只触发恐慌,而不是崩溃。SetPanicOnFault只适用于当前的goroutine。它返回之前的设置。</target>
        </trans-unit>
        <trans-unit id="72fac8e6222bd170971f1f697af6f11d0715e763" translate="yes" xml:space="preserve">
          <source>SetParallelism sets the number of goroutines used by RunParallel to p*GOMAXPROCS. There is usually no need to call SetParallelism for CPU-bound benchmarks. If p is less than 1, this call will have no effect.</source>
          <target state="translated">SetParallelism将RunParallel使用的goroutine数量设置为p*GOMAXPROCS。对于CPU绑定的基准,通常不需要调用SetParallelism。如果p小于1,这个调用将没有任何效果。</target>
        </trans-unit>
        <trans-unit id="8bcdfe56d7b7abb5a2feda191bae07f8cec5d4b8" translate="yes" xml:space="preserve">
          <source>SetPointer sets the unsafe.Pointer value v to x. It panics if v's Kind is not UnsafePointer.</source>
          <target state="translated">SetPointer将unsafe.Pointer值v设置为x,如果v的Kind不是UnsafePointer,它就会恐慌。</target>
        </trans-unit>
        <trans-unit id="59bd457f6414829faae9decbaede734f70a9845c" translate="yes" xml:space="preserve">
          <source>SetPos sets the position. NewIdentifier is a public method so we can't modify its signature. Chained for convenience. TODO: fix one day?</source>
          <target state="translated">SetPos设置位置。NewIdentifier是一个公共方法,所以我们不能修改它的签名。为了方便起见,链式。TODO:某天修复?</target>
        </trans-unit>
        <trans-unit id="d6d5511f09814008767ff9cfe0f77abca174ef5c" translate="yes" xml:space="preserve">
          <source>SetPrec sets z's precision to prec and returns the (possibly) rounded value of z. Rounding occurs according to z's rounding mode if the mantissa cannot be represented in prec bits without loss of precision. SetPrec(0) maps all finite values to &amp;plusmn;0; infinite values remain unchanged. If prec &amp;gt; MaxPrec, it is set to MaxPrec.</source>
          <target state="translated">SetPrec将z的精度设置为prec并返回z（可能）的舍入值。如果尾数不能以精度位表示的精确尾数，则根据z的舍入模式进行舍入。SetPrec（0）将所有有限值映射为&amp;plusmn;0；无限值保持不变。如果prec&amp;gt; MaxPrec，则将其设置为MaxPrec。</target>
        </trans-unit>
        <trans-unit id="d2d0c71771db3b5022796766d08921a2f8600461" translate="yes" xml:space="preserve">
          <source>SetPrefix sets the output prefix for the logger.</source>
          <target state="translated">SetPrefix 设置记录仪的输出前缀。</target>
        </trans-unit>
        <trans-unit id="6bbad9fae1ec236892af0fd5032d525acd1599d4" translate="yes" xml:space="preserve">
          <source>SetPrefix sets the output prefix for the standard logger.</source>
          <target state="translated">SetPrefix 设置标准记录仪的输出前缀。</target>
        </trans-unit>
        <trans-unit id="ad88a7e02a294ade703b1e817a40a72d93a7117f" translate="yes" xml:space="preserve">
          <source>SetRat sets z to the (possibly rounded) value of x and returns z. If z's precision is 0, it is changed to the largest of a.BitLen(), b.BitLen(), or 64; with x = a/b.</source>
          <target state="translated">SetRat将z设置为x的(可能是四舍五入)值,并返回z。如果z的精度为0,则改为a.BitLen()、b.BitLen()或64中最大的一个;x=a/b。</target>
        </trans-unit>
        <trans-unit id="6d4064f9d933c367ae2ed00ed675edff7a545a0e" translate="yes" xml:space="preserve">
          <source>SetReadBuffer sets the size of the operating system's receive buffer associated with the connection.</source>
          <target state="translated">SetReadBuffer设置操作系统与连接相关的接收缓冲区的大小。</target>
        </trans-unit>
        <trans-unit id="ccd6113cf88478a21eac0a31572f18b8edd4bad3" translate="yes" xml:space="preserve">
          <source>SetReadDeadline implements the Conn SetReadDeadline method.</source>
          <target state="translated">SetReadDeadline实现Conn SetReadDeadline方法。</target>
        </trans-unit>
        <trans-unit id="73112eb9e955bd18073b2a5d03cd0dc0569c7e77" translate="yes" xml:space="preserve">
          <source>SetReadDeadline sets the deadline for future Read calls and any currently-blocked Read call. A zero value for t means Read will not time out. Not all files support setting deadlines; see SetDeadline.</source>
          <target state="translated">SetReadDeadline 设置未来的 Read 调用和任何当前阻塞的 Read 调用的截止时间。t的值为零意味着Read不会超时。并非所有文件都支持设置截止时间,请参见SetDeadline。</target>
        </trans-unit>
        <trans-unit id="fed46b093271b3a5ec6430ef1d4235557caf69e8" translate="yes" xml:space="preserve">
          <source>SetReadDeadline sets the read deadline on the underlying connection. A zero value for t means Read will not time out.</source>
          <target state="translated">SetReadDeadline设置底层连接的读取截止时间。t的值为零意味着读取不会超时。</target>
        </trans-unit>
        <trans-unit id="9e522bee4b13d693f1283de4766e87f7104cee24" translate="yes" xml:space="preserve">
          <source>SetSessionTicketKeys updates the session ticket keys for a server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c85e891cbcac943a2a1c3092ec5cc6bdcd4ebc48" translate="yes" xml:space="preserve">
          <source>SetSessionTicketKeys updates the session ticket keys for a server. The first key will be used when creating new tickets, while all keys can be used for decrypting tickets. It is safe to call this function while the server is running in order to rotate the session ticket keys. The function will panic if keys is empty.</source>
          <target state="translated">SetSessionTicketKeys更新服务器的会话票据密钥。第一个密钥将在创建新票据时使用,而所有密钥都可以用于解密票据。在服务器运行时调用这个函数是安全的,以便轮换会话票据密钥。如果keys为空,该函数会发出警报。</target>
        </trans-unit>
        <trans-unit id="8a945e442cacd2fa72eff38e8c9f6290d8ddbda2" translate="yes" xml:space="preserve">
          <source>SetString sets v's underlying value to x. It panics if v's Kind is not String or if CanSet() is false.</source>
          <target state="translated">如果v的Kind不是String或者CanSet()为false,它就会恐慌。</target>
        </trans-unit>
        <trans-unit id="e889ea521a067b34dab32ac1ec6528fffbf097cc" translate="yes" xml:space="preserve">
          <source>SetString sets z to the value of s and returns z and a boolean indicating success. s can be given as a (possibly signed) fraction &quot;a/b&quot;, or as a floating-point number optionally followed by an exponent. If a fraction is provided, both the dividend and the divisor may be a decimal integer or independently use a prefix of &amp;ldquo;0b&amp;rdquo;, &amp;ldquo;0&amp;rdquo; or &amp;ldquo;0o&amp;rdquo;, or &amp;ldquo;0x&amp;rdquo; (or their upper-case variants) to denote a binary, octal, or hexadecimal integer, respectively. The divisor may not be signed. If a floating-point number is provided, it may be in decimal form or use any of the same prefixes as above but for &amp;ldquo;0&amp;rdquo; to denote a non-decimal mantissa. A leading &amp;ldquo;0&amp;rdquo; is considered a decimal leading 0; it does not indicate octal representation in this case. An optional base-10 &amp;ldquo;e&amp;rdquo; or base-2 &amp;ldquo;p&amp;rdquo; (or their upper-case variants) exponent may be provided as well, except for hexadecimal floats which only accept an (optional) &amp;ldquo;p&amp;rdquo; exponent (because an &amp;ldquo;e&amp;rdquo; or &amp;ldquo;E&amp;rdquo; cannot be distinguished from a mantissa digit). The entire string, not just a prefix, must be valid for success. If the operation failed, the value of z is undefined but the returned value is nil.</source>
          <target state="translated">SetString将z设置为s的值，并返回z和一个指示成功的布尔值。 s可以作为（可能是带符号的）分数&amp;ldquo; a / b&amp;rdquo;给出，也可以作为浮点数（可选地后面跟一个指数）给出。如果提供分数，则除数和除数都可以是十进制整数，或者可以单独使用前缀&amp;ldquo; 0b&amp;rdquo;，&amp;ldquo; 0&amp;rdquo;或&amp;ldquo; 0o&amp;rdquo;或&amp;ldquo; 0x&amp;rdquo;（或它们的大写变体）来表示a二进制，八进制或十六进制整数。除数可能未签名。如果提供了浮点数，则它可以采用十进制形式，也可以使用与上述相同的任何前缀，但&amp;ldquo; 0&amp;rdquo;表示非十进制尾数。前导&amp;ldquo; 0&amp;rdquo;被认为是十进制前导0；在这种情况下，它不表示八进制表示形式。还可以提供可选的base-10&amp;ldquo; e&amp;rdquo;或base-2&amp;ldquo; p​​&amp;rdquo;（或其大写变体）指数，十六进制浮点数除外，该十六进制浮点数仅接受（可选）&amp;ldquo; p&amp;rdquo;指数（因为无法将&amp;ldquo; e&amp;rdquo;或&amp;ldquo; E&amp;rdquo;与尾数位区分开）。整个字符串（不仅仅是前缀）必须有效才能成功。如果操作失败，则z的值不确定，但返回的值为nil。</target>
        </trans-unit>
        <trans-unit id="efbb232582df792d37509713c9b27b267d546a58" translate="yes" xml:space="preserve">
          <source>SetString sets z to the value of s and returns z and a boolean indicating success. s must be a floating-point number of the same format as accepted by Parse, with base argument 0. The entire string (not just a prefix) must be valid for success. If the operation failed, the value of z is undefined but the returned value is nil.</source>
          <target state="translated">SetString将z设置为s的值,并返回z和一个表示成功的布尔值。s必须是一个浮点数,格式与Parse接受的格式相同,基数为0。如果操作失败,z的值是未定义的,但返回的值是nil。</target>
        </trans-unit>
        <trans-unit id="63e18202e9d9aea4fa241b783984e3dc354de835" translate="yes" xml:space="preserve">
          <source>SetString sets z to the value of s, interpreted in the given base, and returns z and a boolean indicating success. The entire string (not just a prefix) must be valid for success. If SetString fails, the value of z is undefined but the returned value is nil.</source>
          <target state="translated">SetString将z设置为s的值,用给定的基数解释,并返回z和一个表示成功的布尔值。整个字符串(不仅仅是前缀)必须是有效的才能成功。如果SetString失败,z的值是未定义的,但返回的值是nil。</target>
        </trans-unit>
        <trans-unit id="38dbbaefe7e4a783f76cb46c7ca92c9417de8b66" translate="yes" xml:space="preserve">
          <source>SetTraceback sets the amount of detail printed by the runtime in the traceback it prints before exiting due to an unrecovered panic or an internal runtime error. The level argument takes the same values as the GOTRACEBACK environment variable. For example, SetTraceback(&quot;all&quot;) ensure that the program prints all goroutines when it crashes. See the package runtime documentation for details. If SetTraceback is called with a level lower than that of the environment variable, the call is ignored.</source>
          <target state="translated">SetTraceback设置运行时在因未恢复的恐慌或内部运行时错误而退出前打印的traceback中的细节量。level参数的取值与GOTRACEBACK环境变量相同。例如,SetTraceback(&quot;all&quot;)确保程序在崩溃时打印所有的goroutine。详情请参见包运行时文档。如果调用SetTraceback的级别低于环境变量的级别,则会被忽略。</target>
        </trans-unit>
        <trans-unit id="2fefbf475ce2643229d0cfdbfe83dace76ec0745" translate="yes" xml:space="preserve">
          <source>SetTree sets the parent tree for the node. NewIdentifier is a public method so we can't modify its signature. Chained for convenience. TODO: fix one day?</source>
          <target state="translated">SetTree设置节点的父树。NewIdentifier是一个公共方法,所以我们不能修改它的签名。为方便起见,采用链式。TODO:某天修复?</target>
        </trans-unit>
        <trans-unit id="c67115f13df235c71277ca4e4cc4cdf9edef929f" translate="yes" xml:space="preserve">
          <source>SetUint sets v's underlying value to x. It panics if v's Kind is not Uint, Uintptr, Uint8, Uint16, Uint32, or Uint64, or if CanSet() is false.</source>
          <target state="translated">如果v的Kind不是Uint、Uintptr、Uint8、Uint16、Uint32或Uint64,或者CanSet()为false,它就会恐慌。</target>
        </trans-unit>
        <trans-unit id="a0d44c574be3e0563cede63a8860a8c3c9c0ea08" translate="yes" xml:space="preserve">
          <source>SetUint64 sets z to the (possibly rounded) value of x and returns z. If z's precision is 0, it is changed to 64 (and rounding will have no effect).</source>
          <target state="translated">SetUint64将z设置为x的(可能是四舍五入)值,并返回z。如果z的精度为0,则改为64(四舍五入没有影响)。</target>
        </trans-unit>
        <trans-unit id="0241edc0d224ec2868d9f80a9b9550102e93ffe8" translate="yes" xml:space="preserve">
          <source>SetUint64 sets z to x and returns z.</source>
          <target state="translated">SetUint64将z设置为x并返回z。</target>
        </trans-unit>
        <trans-unit id="d938745882d5a8df95a9972a3a9bbbee174d3301" translate="yes" xml:space="preserve">
          <source>SetUnderlying sets the underlying type and marks t as complete.</source>
          <target state="translated">SetUnderlying设置底层类型并将t标记为完成。</target>
        </trans-unit>
        <trans-unit id="6743e47079d741cfccfdce2738e02e6efcdc6dc1" translate="yes" xml:space="preserve">
          <source>SetUnlinkOnClose sets whether the underlying socket file should be removed from the file system when the listener is closed.</source>
          <target state="translated">SetUnlinkOnClose设置当监听器关闭时是否应该从文件系统中删除底层套接字文件。</target>
        </trans-unit>
        <trans-unit id="3a7d70c082a7c060c7f1583bead1a8cb995d2129" translate="yes" xml:space="preserve">
          <source>SetWriteBuffer sets the size of the operating system's transmit buffer associated with the connection.</source>
          <target state="translated">SetWriteBuffer设置操作系统与连接相关联的传输缓冲区的大小。</target>
        </trans-unit>
        <trans-unit id="ce72366b97c1e87523bdc3b4986d2a5ed5efea78" translate="yes" xml:space="preserve">
          <source>SetWriteDeadline implements the Conn SetWriteDeadline method.</source>
          <target state="translated">SetWriteDeadline实现Conn SetWriteDeadline方法。</target>
        </trans-unit>
        <trans-unit id="94da0323d7e4b44c2641176fd8ed70132d7e560c" translate="yes" xml:space="preserve">
          <source>SetWriteDeadline sets the deadline for any future Write calls and any currently-blocked Write call. Even if Write times out, it may return n &amp;gt; 0, indicating that some of the data was successfully written. A zero value for t means Write will not time out. Not all files support setting deadlines; see SetDeadline.</source>
          <target state="translated">SetWriteDeadline设置任何将来的Write调用和任何当前阻止的Write调用的截止日期。即使Write超时，它也可能返回n&amp;gt; 0，这表示某些数据已成功写入。t的值为零表示写入不会超时。并非所有文件都支持设置期限。请参阅SetDeadline。</target>
        </trans-unit>
        <trans-unit id="e383d386b9651b389cbae33232566bb47ae2af13" translate="yes" xml:space="preserve">
          <source>SetWriteDeadline sets the write deadline on the underlying connection. A zero value for t means Write will not time out. After a Write has timed out, the TLS state is corrupt and all future writes will return the same error.</source>
          <target state="translated">SetWriteDeadline设置底层连接的写入截止时间。t的值为零意味着Write不会超时。写入超时后,TLS状态就会损坏,以后所有的写入都会返回同样的错误。</target>
        </trans-unit>
        <trans-unit id="308be1977132bdbc81c0f89a2767dd32da76c702" translate="yes" xml:space="preserve">
          <source>Setenv sets the value of the environment variable named by the key. It returns an error, if any.</source>
          <target state="translated">Setenv设置键命名的环境变量的值。如果有错误,它会返回一个错误。</target>
        </trans-unit>
        <trans-unit id="509f2c6d0467d5d83c9526f638c505af46797567" translate="yes" xml:space="preserve">
          <source>Setters, numeric operations and predicates are represented as methods of the form:</source>
          <target state="translated">设置器、数值运算和谓词都以方法的形式表示。</target>
        </trans-unit>
        <trans-unit id="8b84f9f04ca185b4b399c76c8fc7c01ef4f564e3" translate="yes" xml:space="preserve">
          <source>Shift returns the result of the shift expression x op s with op == token.SHL or token.SHR (&amp;lt;&amp;lt; or &amp;gt;&amp;gt;). x must be an Int or an Unknown. If x is Unknown, the result is x.</source>
          <target state="translated">Shift返回带有op == token.SHL或token.SHR（&amp;lt;&amp;lt;或&amp;gt;&amp;gt;）的移位表达式x op s的结果。x必须是Int或Unknown。如果x为未知，则结果为x。</target>
        </trans-unit>
        <trans-unit id="fde43f2305da307b56958af17198c21e47808653" translate="yes" xml:space="preserve">
          <source>Short reports whether the -test.short flag is set.</source>
          <target state="translated">Short报告是否设置了-test.short标志。</target>
        </trans-unit>
        <trans-unit id="5b772b7bfd0a43273fb7c5f49a6c16d837261f35" translate="yes" xml:space="preserve">
          <source>Shuffle</source>
          <target state="translated">Shuffle</target>
        </trans-unit>
        <trans-unit id="79a2c163367d393e517ed372229f5d310534a9d9" translate="yes" xml:space="preserve">
          <source>Shuffle (SlicesInUnison)</source>
          <target state="translated">Shuffle (SlicesInUnison)</target>
        </trans-unit>
        <trans-unit id="732d9d1b7fa9ce160a254c0eec34ec29c54e1b79" translate="yes" xml:space="preserve">
          <source>Shuffle pseudo-randomizes the order of elements using the default Source. n is the number of elements. Shuffle panics if n &amp;lt; 0. swap swaps the elements with indexes i and j.</source>
          <target state="translated">使用默认Source随机伪随机化元素的顺序。n是元素数。如果n &amp;lt;0，则洗礼恐慌。swap交换索引为i和j的元素。</target>
        </trans-unit>
        <trans-unit id="6d3cd15e0fd6a7a5b1756b9af5c51872006c475b" translate="yes" xml:space="preserve">
          <source>Shuffle pseudo-randomizes the order of elements. n is the number of elements. Shuffle panics if n &amp;lt; 0. swap swaps the elements with indexes i and j.</source>
          <target state="translated">随机伪随机化元素的顺序。n是元素数。如果n &amp;lt;0，则洗礼恐慌。swap交换索引为i和j的元素。</target>
        </trans-unit>
        <trans-unit id="8e0c7b7cdf248102d52e5f44dcd474d4d82c359e" translate="yes" xml:space="preserve">
          <source>Shutdown does not attempt to close nor wait for hijacked connections such as WebSockets. The caller of Shutdown should separately notify such long-lived connections of shutdown and wait for them to close, if desired. See RegisterOnShutdown for a way to register shutdown notification functions.</source>
          <target state="translated">Shutdown不会试图关闭也不会等待被劫持的连接,比如WebSockets。如果需要的话,Shutdown的调用者应该单独通知这些长期存在的连接关闭并等待它们关闭。参见RegisterOnShutdown,了解注册关机通知函数的方法。</target>
        </trans-unit>
        <trans-unit id="38dcf86ad76a9ad474561d4239201b3f812c81b9" translate="yes" xml:space="preserve">
          <source>Shutdown gracefully shuts down the server without interrupting any active connections. Shutdown works by first closing all open listeners, then closing all idle connections, and then waiting indefinitely for connections to return to idle and then shut down. If the provided context expires before the shutdown is complete, Shutdown returns the context's error, otherwise it returns any error returned from closing the Server's underlying Listener(s).</source>
          <target state="translated">Shutdown可以在不中断任何活动连接的情况下优雅地关闭服务器。Shutdown的工作方式是首先关闭所有打开的监听器,然后关闭所有空闲的连接,然后无限期地等待连接恢复到空闲状态,然后关闭。如果所提供的上下文在关闭完成之前过期,Shutdown 将返回上下文的错误,否则它将返回关闭服务器的底层监听器所返回的任何错误。</target>
        </trans-unit>
        <trans-unit id="8b3d8d665a765918b70a3f5f0378d51df00b92dd" translate="yes" xml:space="preserve">
          <source>Sign</source>
          <target state="translated">Sign</target>
        </trans-unit>
        <trans-unit id="4dc2181e93ae969f803429357fe579abd176b4b4" translate="yes" xml:space="preserve">
          <source>Sign returns -1, 0, or 1 depending on whether x &amp;lt; 0, x == 0, or x &amp;gt; 0; x must be numeric or Unknown. For complex values x, the sign is 0 if x == 0, otherwise it is != 0. If x is Unknown, the result is 1.</source>
          <target state="translated">根据x &amp;lt;0，x == 0或x&amp;gt; 0，符号返回-1、0或1。x必须为数字或未知。对于复数值x，如果x == 0，则符号为0，否则为！=0。如果x为Unknown，则结果为1。</target>
        </trans-unit>
        <trans-unit id="b52aac6f1207124113d4a678eb49a1b5cf712f7a" translate="yes" xml:space="preserve">
          <source>Sign returns:</source>
          <target state="translated">签回。</target>
        </trans-unit>
        <trans-unit id="6589591f2f20ffb39adee81e8ba10edbe7dacc2e" translate="yes" xml:space="preserve">
          <source>Sign signs a hash (which should be the result of hashing a larger message) using the private key, priv. If the hash is longer than the bit-length of the private key's curve order, the hash will be truncated to that length. It returns the signature as a pair of integers. The security of the private key depends on the entropy of rand.</source>
          <target state="translated">Sign使用私钥priv签署一个哈希值(应该是对一个较大的消息进行哈希的结果)。如果散列的长度超过了私钥的曲线顺序的位长,那么散列将被截断到这个长度。它以一对整数的形式返回签名。私钥的安全性取决于rand的熵。</target>
        </trans-unit>
        <trans-unit id="311212195f2e7e53bfbdc1974b3a767400f6e3ff" translate="yes" xml:space="preserve">
          <source>Sign signs an arbitrary length hash (which should be the result of hashing a larger message) using the private key, priv. It returns the signature as a pair of integers. The security of the private key depends on the entropy of rand.</source>
          <target state="translated">Sign使用私钥priv签署一个任意长度的散列(应该是对一个较大的消息进行散列的结果)。它以一对整数的形式返回签名。私钥的安全性取决于 rand 的熵。</target>
        </trans-unit>
        <trans-unit id="c12807935684d6d5a767b5418d3f2f1d36802c6e" translate="yes" xml:space="preserve">
          <source>Sign signs digest with priv, reading randomness from rand. If opts is a *PSSOptions then the PSS algorithm will be used, otherwise PKCS #1 v1.5 will be used. digest must be the result of hashing the input message using opts.HashFunc().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd714756dfd32673e7a5fdf4e7a7d3f4c1f0476c" translate="yes" xml:space="preserve">
          <source>Sign signs digest with priv, reading randomness from rand. If opts is a *PSSOptions then the PSS algorithm will be used, otherwise PKCS#1 v1.5 will be used.</source>
          <target state="translated">用priv进行标志数字化,从rand中读取随机性。如果opts是一个*PSSOptions,那么将使用PSS算法,否则将使用PKCS#1 v1.5。</target>
        </trans-unit>
        <trans-unit id="725a324c83bff5484063c9fb79ed06b1a642a7c9" translate="yes" xml:space="preserve">
          <source>Sign signs digest with priv, reading randomness from rand. The opts argument is not currently used but, in keeping with the crypto.Signer interface, should be the hash function used to digest the message.</source>
          <target state="translated">Sign用priv签署摘要,从rand读取随机性。opts 参数目前还没有使用,但为了与 crypto.Signer 接口保持一致,应该是用来消化消息的哈希函数。</target>
        </trans-unit>
        <trans-unit id="cb5cc6baa9959aae2928064eeabac37026d1fdd3" translate="yes" xml:space="preserve">
          <source>Sign signs the given message with priv. Ed25519 performs two passes over messages to be signed and therefore cannot handle pre-hashed messages. Thus opts.HashFunc() must return zero to indicate the message hasn't been hashed. This can be achieved by passing crypto.Hash(0) as the value for opts.</source>
          <target state="translated">Sign 用 priv.Sign 对给定的消息进行签名。Ed25519 会对要签名的消息进行两次传递,因此不能处理预哈希的消息。因此 opts.HashFunc()必须返回 0 来表示消息还没有被哈希。这可以通过传递 crypto.Hash(0)作为 opts.HashFunc()的值来实现。</target>
        </trans-unit>
        <trans-unit id="8d9bc9097d624689f3abd051873c0827e390ddd8" translate="yes" xml:space="preserve">
          <source>Sign signs the message with privateKey and returns a signature. It will panic if len(privateKey) is not PrivateKeySize.</source>
          <target state="translated">Sign用privateKey签署消息并返回签名。如果len(privateKey)不是PrivateKeySize,它将会恐慌。</target>
        </trans-unit>
        <trans-unit id="374ef04419fa455579e2922ef305611877eeff57" translate="yes" xml:space="preserve">
          <source>SignASN1 signs a hash (which should be the result of hashing a larger message) using the private key, priv. If the hash is longer than the bit-length of the private key's curve order, the hash will be truncated to that length. It returns the ASN.1 encoded signature. The security of the private key depends on the entropy of rand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73058d5661f51255d2d044bad5e22d1dbeb1615f" translate="yes" xml:space="preserve">
          <source>SignPKCS1v15</source>
          <target state="translated">SignPKCS1v15</target>
        </trans-unit>
        <trans-unit id="c0fa762cfc4f83cc1ae6eb824e2e7d2490239baf" translate="yes" xml:space="preserve">
          <source>SignPKCS1v15 calculates the signature of hashed using RSASSA-PKCS1-V1_5-SIGN from RSA PKCS #1 v1.5. Note that hashed must be the result of hashing the input message using the given hash function. If hash is zero, hashed is signed directly. This isn't advisable except for interoperability.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76a7f1a903c9bd79d05146e331e0afbf510916e4" translate="yes" xml:space="preserve">
          <source>SignPKCS1v15 calculates the signature of hashed using RSASSA-PKCS1-V1_5-SIGN from RSA PKCS#1 v1.5. Note that hashed must be the result of hashing the input message using the given hash function. If hash is zero, hashed is signed directly. This isn't advisable except for interoperability.</source>
          <target state="translated">SignPKCS1v15使用RSASSA-PKCS1-V1_5-SIGN从RSA PKCS#1 v1.5计算哈希的签名。注意,哈希必须是使用给定的哈希函数对输入信息进行哈希处理的结果。如果哈希值为零,则直接对哈希值进行签名。除了为了互操作性,这并不可取。</target>
        </trans-unit>
        <trans-unit id="a8dc8c6fdf07694c004d0ad09c1805b1db05045f" translate="yes" xml:space="preserve">
          <source>SignPSS calculates the signature of digest using PSS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dc02ffb85c827150cad191cf75b74252c850c11" translate="yes" xml:space="preserve">
          <source>SignPSS calculates the signature of hashed using RSASSA-PSS [1]. Note that hashed must be the result of hashing the input message using the given hash function. The opts argument may be nil, in which case sensible defaults are used.</source>
          <target state="translated">SignPSS使用RSASSA-PSS[1]计算哈希的签名。注意哈希必须是使用给定的哈希函数对输入信息进行哈希处理的结果。opts参数可能为零,在这种情况下,会使用合理的默认值。</target>
        </trans-unit>
        <trans-unit id="456ecb37c3fc5855213ab977448f009637d487e9" translate="yes" xml:space="preserve">
          <source>Signal sends a signal to the Process. Sending Interrupt on Windows is not implemented.</source>
          <target state="translated">信号向进程发送信号。在Windows上没有实现发送中断。</target>
        </trans-unit>
        <trans-unit id="113054b65e3d478c55ce8ee9e7136eef91adbb6a" translate="yes" xml:space="preserve">
          <source>Signal wakes one goroutine waiting on c, if there is any.</source>
          <target state="translated">如果有的话,信号会唤醒一个等待c的goroutine。</target>
        </trans-unit>
        <trans-unit id="2346a18ea3002ff04eca3a130c7f40e65c56f0c9" translate="yes" xml:space="preserve">
          <source>Signals</source>
          <target state="translated">Signals</target>
        </trans-unit>
        <trans-unit id="9a761dffcc7f2df5b531ae01c6e9c1d10354c3aa" translate="yes" xml:space="preserve">
          <source>Signals are primarily used on Unix-like systems. For the use of this package on Windows and Plan 9, see below.</source>
          <target state="translated">信号主要用于类Unix系统上。关于在Windows和Plan 9上使用该软件包,请参见下文。</target>
        </trans-unit>
        <trans-unit id="be08fe4d5181cd9a339446858cf8e98d5d370ad9" translate="yes" xml:space="preserve">
          <source>SignatureScheme identifies a signature algorithm supported by TLS. See RFC 8446, Section 4.2.3.</source>
          <target state="translated">SignatureScheme标识TLS支持的签名算法。参见RFC 8446,4.2.3节。</target>
        </trans-unit>
        <trans-unit id="72364e765319ca6184606bdfcbeaf4bae3efe083" translate="yes" xml:space="preserve">
          <source>Signbit reports whether x is negative or negative zero.</source>
          <target state="translated">Signbit报告x是负数还是负零。</target>
        </trans-unit>
        <trans-unit id="06f0622cc55ee3b1ba8ef5291dd67f388a633bbf" translate="yes" xml:space="preserve">
          <source>Signed integers may be received into any signed integer variable: int, int16, etc.; unsigned integers may be received into any unsigned integer variable; and floating point values may be received into any floating point variable. However, the destination variable must be able to represent the value or the decode operation will fail.</source>
          <target state="translated">有符号整数可以接收到任何有符号整数变量:int、int16等;无符号整数可以接收到任何无符号整数变量;浮点值可以接收到任何浮点变量。但是,目的变量必须能够表示该值,否则解码操作将失败。</target>
        </trans-unit>
        <trans-unit id="ae900b849a1bf306b492bb9034be4bb3bc19b163" translate="yes" xml:space="preserve">
          <source>Signer is an interface for an opaque private key that can be used for signing operations. For example, an RSA key kept in a hardware module.</source>
          <target state="translated">Signer是一个不透明的私钥的接口,可以用来进行签名操作。例如,保存在硬件模块中的RSA密钥。</target>
        </trans-unit>
        <trans-unit id="38f4531ed194c331b7b23a6d3502ef6906c2f74a" translate="yes" xml:space="preserve">
          <source>SignerOpts contains options for signing with a Signer.</source>
          <target state="translated">SignerOpts包含了与签名者签名的选项。</target>
        </trans-unit>
        <trans-unit id="8332f3ce4c218d0bde5211f46f41f270a3be8e0c" translate="yes" xml:space="preserve">
          <source>Similarly to attributes with namespaces, attributes with a &quot;data-&quot; prefix are treated as if they had no &quot;data-&quot; prefix. So given</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="966d50452c96c3fa11f316a011f44cf776d22a17" translate="yes" xml:space="preserve">
          <source>SimpleFold</source>
          <target state="translated">SimpleFold</target>
        </trans-unit>
        <trans-unit id="8bf97e6e8efa121264307227008493331dea504d" translate="yes" xml:space="preserve">
          <source>SimpleFold iterates over Unicode code points equivalent under the Unicode-defined simple case folding. Among the code points equivalent to rune (including rune itself), SimpleFold returns the smallest rune &amp;gt; r if one exists, or else the smallest rune &amp;gt;= 0. If r is not a valid Unicode code point, SimpleFold(r) returns r.</source>
          <target state="translated">SimpleFold遍历Unicode定义的简单大小写折叠下的等效Unicode代码点。在相当于符文的代码点（包括符文本身）中，如果存在，则SimpleFold返回最小的符文&amp;gt; r，否则，返回最小的符文&amp;gt; =0。如果r不是有效的Unicode代码点，则Si​​mpleFold（r）返回r。</target>
        </trans-unit>
        <trans-unit id="b27adf68197f928a987f44243ba3dcfcda229444" translate="yes" xml:space="preserve">
          <source>Simplify returns a regexp equivalent to re but without counted repetitions and with various other simplifications, such as rewriting /(?:a+)+/ to /a+/. The resulting regexp will execute correctly but its string representation will not produce the same parse tree, because capturing parentheses may have been duplicated or removed. For example, the simplified form for /(x){1,2}/ is /(x)(x)?/ but both parentheses capture as $1. The returned regexp may share structure with or be the original.</source>
          <target state="translated">Simplify 返回一个与 re 相当的 regexp,但没有计数重复,并进行了各种其他简化,例如将 /(?:a+)+/重写为 /a+/。由此产生的regexp将正确执行,但它的字符串表示方式将不会产生相同的解析树,因为捕获括号可能被重复或删除。例如,/(x){1,2}/的简化形式是/(x)(x)?/,但两个小括号都被捕获为$1.返回的regexp可能与原始的regexp共享结构,也可能是原始的regexp。</target>
        </trans-unit>
        <trans-unit id="1baaf4288309b641acaf8ca1164546c4028a35a7" translate="yes" xml:space="preserve">
          <source>Sin</source>
          <target state="translated">Sin</target>
        </trans-unit>
        <trans-unit id="60fef841296be9ebf7de4bce978c61ea99668ac2" translate="yes" xml:space="preserve">
          <source>Sin returns the sine of the radian argument x.</source>
          <target state="translated">Sin 返回弧度参数x的正弦值。</target>
        </trans-unit>
        <trans-unit id="2d7deeeba21d579c050c2a33e2db608612f16ced" translate="yes" xml:space="preserve">
          <source>Sin returns the sine of x.</source>
          <target state="translated">Sin 返回 x 的正弦值。</target>
        </trans-unit>
        <trans-unit id="032d0e9143af25fee0463a47b08e83403e61fbe1" translate="yes" xml:space="preserve">
          <source>Since os.FileInfo's Name method only returns the base name of the file it describes, it may be necessary to modify Header.Name to provide the full path name of the file.</source>
          <target state="translated">由于 os.FileInfo 的 Name 方法只返回它所描述的文件的基本名称,因此可能需要修改 Header.Name 来提供文件的完整路径名。</target>
        </trans-unit>
        <trans-unit id="b67e676cda98cae04b5ce1604ab8e9db4fbb0636" translate="yes" xml:space="preserve">
          <source>Since returns the time elapsed since t. It is shorthand for time.Now().Sub(t).</source>
          <target state="translated">它是time.Now().Sub(t)的速记。</target>
        </trans-unit>
        <trans-unit id="4aada6d4483746dcd60dcf298d86136630d9cd91" translate="yes" xml:space="preserve">
          <source>Sincos</source>
          <target state="translated">Sincos</target>
        </trans-unit>
        <trans-unit id="602eea7f1523e01bb1b745122d12becc2cb4a99c" translate="yes" xml:space="preserve">
          <source>Sincos returns Sin(x), Cos(x).</source>
          <target state="translated">Sincos 返回 Sin(x),Cos(x)。</target>
        </trans-unit>
        <trans-unit id="bc9965f20c0e26db0501d3424c1430869ed3389f" translate="yes" xml:space="preserve">
          <source>Single characters:</source>
          <target state="translated">单字。</target>
        </trans-unit>
        <trans-unit id="e5d65368cdcef8d43d81f8b1167171bcc9e4d453" translate="yes" xml:space="preserve">
          <source>Sinh</source>
          <target state="translated">Sinh</target>
        </trans-unit>
        <trans-unit id="f35b8f7d99b41bcac88dc066f89ded4a25031767" translate="yes" xml:space="preserve">
          <source>Sinh returns the hyperbolic sine of x.</source>
          <target state="translated">Sinh返回x的双曲正弦。</target>
        </trans-unit>
        <trans-unit id="9d9b9bb8ffbb101e667ceeb0c6df4b2d00eca63e" translate="yes" xml:space="preserve">
          <source>Size returns how many bytes Write would generate to encode the value v, which must be a fixed-size value or a slice of fixed-size values, or a pointer to such data. If v is neither of these, Size returns -1.</source>
          <target state="translated">Size 返回 Write 将产生多少字节来编码 v 值,它必须是一个固定大小的值或固定大小值的片断,或者是一个指向此类数据的指针。如果v不是这两种,Size返回-1。</target>
        </trans-unit>
        <trans-unit id="07f99b9766acbd34a40dce6ae52199b1df82e565" translate="yes" xml:space="preserve">
          <source>Size returns r's width and height.</source>
          <target state="translated">Size 返回 r 的宽度和高度。</target>
        </trans-unit>
        <trans-unit id="08603885cb8f4581e6caff80c9587384030d6fb2" translate="yes" xml:space="preserve">
          <source>Size returns the length, in bytes, of a digest resulting from the given hash function. It doesn't require that the hash function in question be linked into the program.</source>
          <target state="translated">Size 返回由给定哈希函数产生的摘要的长度,以字节为单位。它并不要求相关的哈希函数被链接到程序中。</target>
        </trans-unit>
        <trans-unit id="e25ab5f340eca2d7c5b223c77e15ee75cde585ef" translate="yes" xml:space="preserve">
          <source>Size returns the modulus size in bytes. Raw signatures and ciphertexts for or by this public key will have the same size.</source>
          <target state="translated">Size 返回以字节为单位的模数大小。原始签名和这个公钥的加密文本的大小是一样的。</target>
        </trans-unit>
        <trans-unit id="e670e1a5854b86fb3e790eec7802ceb4072867ce" translate="yes" xml:space="preserve">
          <source>Size returns the number of leading ones and total bits in the mask. If the mask is not in the canonical form--ones followed by zeros--then Size returns 0, 0.</source>
          <target state="translated">Size 返回掩码中的前导一和总位数。</target>
        </trans-unit>
        <trans-unit id="e50e49a71b6948817b0c75a5802d436dcfbbd3d4" translate="yes" xml:space="preserve">
          <source>Size returns the original length of the underlying byte slice. Size is the number of bytes available for reading via ReadAt. The returned value is always the same and is not affected by calls to any other method.</source>
          <target state="translated">Size 返回底层字节分片的原始长度。Size是通过ReadAt读取的可用字节数。返回的值总是相同的,并且不受任何其他方法调用的影响。</target>
        </trans-unit>
        <trans-unit id="20090954ae229cf40fcf85ad90018bc0a50c14a6" translate="yes" xml:space="preserve">
          <source>Size returns the original length of the underlying string. Size is the number of bytes available for reading via ReadAt. The returned value is always the same and is not affected by calls to any other method.</source>
          <target state="translated">Size 返回底层字符串的原始长度。Size是通过ReadAt读取的可用字节数。返回的值总是相同的,并且不受任何其他方法调用的影响。</target>
        </trans-unit>
        <trans-unit id="5a0d609fe825a666e200f379bb9b290e727375b4" translate="yes" xml:space="preserve">
          <source>Size returns the size of file f as registered with AddFile.</source>
          <target state="translated">Size 返回用 AddFile 注册的文件 f 的大小。</target>
        </trans-unit>
        <trans-unit id="5716d3e163196d9c451e87a39bff7287017defa9" translate="yes" xml:space="preserve">
          <source>Size returns the size of the section in bytes.</source>
          <target state="translated">Size 以字节为单位返回该部分的大小。</target>
        </trans-unit>
        <trans-unit id="33687cc2c12d65398be28bdfb49be5c9af20dea4" translate="yes" xml:space="preserve">
          <source>Size returns the size of the underlying buffer in bytes.</source>
          <target state="translated">Size以字节为单位返回底层缓冲区的大小。</target>
        </trans-unit>
        <trans-unit id="ad326c620cb25aa3f6f88fe50584af3756cb7137" translate="yes" xml:space="preserve">
          <source>Sizeof takes an expression x of any type and returns the size in bytes of a hypothetical variable v as if v was declared via var v = x. The size does not include any memory possibly referenced by x. For instance, if x is a slice, Sizeof returns the size of the slice descriptor, not the size of the memory referenced by the slice. The return value of Sizeof is a Go constant.</source>
          <target state="translated">Sizeof接受一个任意类型的表达式x,并以字节为单位返回一个假设变量v的大小,就像v是通过var v=x声明的一样。例如,如果x是一个分片,Sizeof返回分片描述符的大小,而不是分片所引用的内存的大小。Sizeof 的返回值是一个 Go 常量。</target>
        </trans-unit>
        <trans-unit id="b19905df7d36355c364fc4d465be7029063705c6" translate="yes" xml:space="preserve">
          <source>Sizes defines the sizing functions for package unsafe.</source>
          <target state="translated">Sizes定义了包不安全的大小函数。</target>
        </trans-unit>
        <trans-unit id="58588dd4d69fcc2bebbb32cb3311a65197ef6d80" translate="yes" xml:space="preserve">
          <source>SizesFor returns the Sizes used by a compiler for an architecture. The result is nil if a compiler/architecture pair is not known.</source>
          <target state="translated">SizesFor 返回一个编译器对一个架构使用的 Sizes。如果不知道编译器/架构对,结果为零。</target>
        </trans-unit>
        <trans-unit id="f2bf90f6b1f23cb7aca2de8f99806d297f79d8f6" translate="yes" xml:space="preserve">
          <source>Skip is equivalent to Log followed by SkipNow.</source>
          <target state="translated">跳过相当于Log,后面是SkipNow。</target>
        </trans-unit>
        <trans-unit id="16403f951a4dfc8a1c243a0f8eb301e145aaacf2" translate="yes" xml:space="preserve">
          <source>Skip reads tokens until it has consumed the end element matching the most recent start element already consumed. It recurs if it encounters a start element, so it can be used to skip nested structures. It returns nil if it finds an end element matching the start element; otherwise it returns an error describing the problem.</source>
          <target state="translated">跳过读取标记,直到消耗完与最近消耗的起始元素相匹配的结束元素。如果遇到起始元素,它就会递归,所以它可以用来跳过嵌套结构。如果它发现了一个与起始元素相匹配的结束元素,它就返回nil;否则它就返回一个描述问题的错误。</target>
        </trans-unit>
        <trans-unit id="70514769bf0cf43aa1fd9a8170e861cfc268114d" translate="yes" xml:space="preserve">
          <source>SkipChildren skips over the child entries associated with the last Entry returned by Next. If that Entry did not have children or Next has not been called, SkipChildren is a no-op.</source>
          <target state="translated">SkipChildren 跳过与 Next 返回的最后一个条目相关联的子条目。如果该条目没有子条目,或者Next没有被调用,SkipChildren是一个no-op。</target>
        </trans-unit>
        <trans-unit id="306f2cf9cd44bb1158534a5fe5beb03317afa4af" translate="yes" xml:space="preserve">
          <source>SkipDir is used as a return value from WalkFuncs to indicate that the directory named in the call is to be skipped. It is not returned as an error by any function.</source>
          <target state="translated">SkipDir是WalkFuncs的一个返回值,用于指示调用中命名的目录要被跳过。任何函数都不会将其作为错误返回。</target>
        </trans-unit>
        <trans-unit id="a9f977172633094ba7da3e08af3ab05c0c517aa4" translate="yes" xml:space="preserve">
          <source>SkipNow marks the test as having been skipped and stops its execution by calling runtime.Goexit. If a test fails (see Error, Errorf, Fail) and is then skipped, it is still considered to have failed. Execution will continue at the next test or benchmark. See also FailNow. SkipNow must be called from the goroutine running the test, not from other goroutines created during the test. Calling SkipNow does not stop those other goroutines.</source>
          <target state="translated">SkipNow 将测试标记为已被跳过,并通过调用 runtime.Goexit 停止其执行。如果一个测试失败了(见Error,Errorf,Fail),然后被跳过,它仍然被认为是失败的。执行将在下一个测试或基准继续。也请参见FailNow。SkipNow必须从运行测试的goroutine中调用,而不是从测试期间创建的其他goroutine中调用。调用SkipNow并不会使这些其他goroutine停止。</target>
        </trans-unit>
        <trans-unit id="332b0733aeb219d3842af5da1737b4332e8bb58a" translate="yes" xml:space="preserve">
          <source>Skipf is equivalent to Logf followed by SkipNow.</source>
          <target state="translated">Skipf相当于Logf,其次是SkipNow。</target>
        </trans-unit>
        <trans-unit id="416b07f26916aed7cb9e2ecd9aa8ab976885e47e" translate="yes" xml:space="preserve">
          <source>Skipped reports whether the test was skipped.</source>
          <target state="translated">Skipped(跳过)报告是否跳过测试。</target>
        </trans-unit>
        <trans-unit id="22c22c92516b167e48a8850862fd9d43b049ad6a" translate="yes" xml:space="preserve">
          <source>Skipping</source>
          <target state="translated">Skipping</target>
        </trans-unit>
        <trans-unit id="3cac34e674464c2b62286054cd9a2d2c81149efc" translate="yes" xml:space="preserve">
          <source>Sleep</source>
          <target state="translated">Sleep</target>
        </trans-unit>
        <trans-unit id="53bb6e499b626b0d907f8d7f80059af55f685b40" translate="yes" xml:space="preserve">
          <source>Sleep pauses the current goroutine for at least the duration d. A negative or zero duration causes Sleep to return immediately.</source>
          <target state="translated">睡眠暂停当前goroutine至少持续时间d,负值或零持续时间会使睡眠立即返回。</target>
        </trans-unit>
        <trans-unit id="0c8525a31f225d6db84222cdc68f43cb8c6c18bf" translate="yes" xml:space="preserve">
          <source>Slice</source>
          <target state="translated">Slice</target>
        </trans-unit>
        <trans-unit id="4972372ab292852581dde17e7410c1a0a34536d2" translate="yes" xml:space="preserve">
          <source>Slice returns v[i:j]. It panics if v's Kind is not Array, Slice or String, or if v is an unaddressable array, or if the indexes are out of bounds.</source>
          <target state="translated">Slice 返回 v[i:j]。如果v的类型不是Array、Slice或String,或者v是一个不可寻址的数组,或者索引超出了边界,它就会恐慌。</target>
        </trans-unit>
        <trans-unit id="f664f65e07ee83c0603b67c75f98aa98e653bee6" translate="yes" xml:space="preserve">
          <source>Slice sorts the provided slice given the provided less function.</source>
          <target state="translated">Slice对所提供的slice进行排序,给定了所提供的less函数。</target>
        </trans-unit>
        <trans-unit id="c9c2b1fb38f90f114fb07f736146472316c1fd01" translate="yes" xml:space="preserve">
          <source>Slice values are deeply equal when all of the following are true: they are both nil or both non-nil, they have the same length, and either they point to the same initial entry of the same underlying array (that is, &amp;amp;x[0] == &amp;amp;y[0]) or their corresponding elements (up to length) are deeply equal. Note that a non-nil empty slice and a nil slice (for example, []byte{} and []byte(nil)) are not deeply equal.</source>
          <target state="translated">当满足以下所有条件时，切片值将完全相等：它们均为nil或均为非nil，它们具有相同的长度，并且它们指向同一基础数组的相同初始条目（即＆x [0 ] ==＆y [0]）或它们相应的元素（最大长度）相等。请注意，非nil空片和nil片（例如[] byte {}和[] byte（nil））并不完全相等。</target>
        </trans-unit>
        <trans-unit id="187ce922ba02cf6f5feb1dc1495c357805a44a28" translate="yes" xml:space="preserve">
          <source>Slice3 is the 3-index form of the slice operation: it returns v[i:j:k]. It panics if v's Kind is not Array or Slice, or if v is an unaddressable array, or if the indexes are out of bounds.</source>
          <target state="translated">Slice3 是分片操作的 3 个索引形式:它返回 v[i:j:k]。如果v的Kind不是Array或Slice,或者v是一个不可寻址的数组,或者索引出界,它就会恐慌。</target>
        </trans-unit>
        <trans-unit id="036571bfad79ab866cb35b30d706649dfea91e3e" translate="yes" xml:space="preserve">
          <source>Slice:</source>
          <target state="translated">Slice:</target>
        </trans-unit>
        <trans-unit id="0294a1ce63eca0958f1a3380376dd5b3772daeaa" translate="yes" xml:space="preserve">
          <source>SliceHeader is the runtime representation of a slice. It cannot be used safely or portably and its representation may change in a later release. Moreover, the Data field is not sufficient to guarantee the data it references will not be garbage collected, so programs must keep a separate, correctly typed pointer to the underlying data.</source>
          <target state="translated">SliceHeader 是切片的运行时表示。它不能安全地或可移植地使用,它的表示方式可能会在以后的版本中改变。此外,Data字段不足以保证它所引用的数据不会被垃圾回收,所以程序必须保留一个单独的、正确类型的指针,指向底层数据。</target>
        </trans-unit>
        <trans-unit id="c22ee253fc38582e76e1a487b795c3ec911e294a" translate="yes" xml:space="preserve">
          <source>SliceIsSorted tests whether a slice is sorted.</source>
          <target state="translated">SliceIsSorted 测试一个切片是否被排序。</target>
        </trans-unit>
        <trans-unit id="45eaaaf070f6c38ebb684650d2e76ac52a7e3905" translate="yes" xml:space="preserve">
          <source>SliceOf returns the slice type with element type t. For example, if t represents int, SliceOf(t) represents []int.</source>
          <target state="translated">例如,如果t代表int,那么SliceOf(t)代表[]int。</target>
        </trans-unit>
        <trans-unit id="d3f5d8267a68290ad1478266ac0100b64a9ec9d9" translate="yes" xml:space="preserve">
          <source>SlicePtrFromStrings converts a slice of strings to a slice of pointers to NUL-terminated byte arrays. If any string contains a NUL byte, it returns (nil, EINVAL).</source>
          <target state="translated">SlicePtrFromStrings将字符串的片断转换为指向NUL结尾的字节数组的片断。如果任何字符串包含一个NUL字节,它将返回(nil,EINVAL)。</target>
        </trans-unit>
        <trans-unit id="1c864d92c212ef8abfd9b5a7229b7d9cb38de7a2" translate="yes" xml:space="preserve">
          <source>SliceStable</source>
          <target state="translated">SliceStable</target>
        </trans-unit>
        <trans-unit id="291aafdf1861d62c9bc50f1c83d1800a3cb0913c" translate="yes" xml:space="preserve">
          <source>SliceStable sorts the provided slice given the provided less function while keeping the original order of equal elements.</source>
          <target state="translated">SliceStable对所提供的分片进行排序,同时保持原有的等元素顺序。</target>
        </trans-unit>
        <trans-unit id="24220363f4bcd3c6462dbe1e7e4afff4012817f0" translate="yes" xml:space="preserve">
          <source>Slices of bytes in the returned token data refer to the parser's internal buffer and remain valid only until the next call to Token. To acquire a copy of the bytes, call CopyToken or the token's Copy method.</source>
          <target state="translated">返回的token数据中的字节片段是指解析器的内部缓冲区,并且只在下次调用Token之前有效。要获取字节的副本,请调用CopyToken或token的Copy方法。</target>
        </trans-unit>
        <trans-unit id="fc7f681747838baecdc0ee29795205530bc0b270" translate="yes" xml:space="preserve">
          <source>SocketControlMessage represents a socket control message.</source>
          <target state="translated">SocketControlMessage表示一个套接字控制消息。</target>
        </trans-unit>
        <trans-unit id="4457c2edf950c3c3e9063b3a5f5427cad62d71ba" translate="yes" xml:space="preserve">
          <source>Some protocols may impose additional requirements on pre-escaping the username and password. For instance, when used with OAuth2, both arguments must be URL encoded first with url.QueryEscape.</source>
          <target state="translated">有些协议可能会对用户名和密码的预封装提出额外的要求,例如,当使用OAuth2时,两个参数必须先用url.QueryEscape进行URL编码。例如,当使用OAuth2时,两个参数都必须先用url.QueryEscape进行URL编码。</target>
        </trans-unit>
        <trans-unit id="0b8c5ca797beb6df3a3a7d32f3dea277a5bafd3c" translate="yes" xml:space="preserve">
          <source>Some valid layouts are invalid time values for time.Parse, due to formats such as _ for space padding and Z for zone information.</source>
          <target state="translated">一些有效的布局对time.Parse来说是无效的时间值,这是由于格式,如_表示空格填充,Z表示区域信息。</target>
        </trans-unit>
        <trans-unit id="89fbdcfdf1cfcd667a49cfe3f7c3c0bdc4ce5124" translate="yes" xml:space="preserve">
          <source>Sort is a convenience method.</source>
          <target state="translated">排序是一种方便的方法。</target>
        </trans-unit>
        <trans-unit id="f520ad1ca9ea89523277ded79bfeb4e271e735a8" translate="yes" xml:space="preserve">
          <source>Sort sorts an ErrorList. *Error entries are sorted by position, other errors are sorted by error message, and before any *Error entry.</source>
          <target state="translated">Sort对ErrorList进行排序。*错误条目按位置排序,其他错误按错误信息排序,并在任何*错误条目之前排序。</target>
        </trans-unit>
        <trans-unit id="f8bf7dfcfaee16c58648d64101d25f3215cc22e2" translate="yes" xml:space="preserve">
          <source>Sort sorts data. It makes one call to data.Len to determine n, and O(n*log(n)) calls to data.Less and data.Swap. The sort is not guaranteed to be stable.</source>
          <target state="translated">Sort对数据进行排序。它对data.Len进行一次调用以确定n,对data.Less和data.Swap进行O(n*log(n))次调用。排序不保证稳定。</target>
        </trans-unit>
        <trans-unit id="decd49ac7a46241d55346a11f6d2fb74335dc7a9" translate="yes" xml:space="preserve">
          <source>SortImports sorts runs of consecutive import lines in import blocks in f. It also removes duplicate imports when it is possible to do so without data loss.</source>
          <target state="translated">SortImports对f中的导入块中的连续导入行进行排序,当可以做到不丢失数据时,它还可以删除重复的导入。</target>
        </trans-unit>
        <trans-unit id="6e2693fb2fa2b916dd95d972bbcb32b0b6b566ec" translate="yes" xml:space="preserve">
          <source>Source formats src in canonical gofmt style and returns the result or an (I/O or syntax) error. src is expected to be a syntactically correct Go source file, or a list of Go declarations or statements.</source>
          <target state="translated">源文件以规范的gofmt风格格式化src,并返回结果或(I/O或语法)错误。src应该是一个语法正确的Go源文件,或Go声明或语句的列表。</target>
        </trans-unit>
        <trans-unit id="a91bed1365204e8353c0f745ca77893ae1b1305d" translate="yes" xml:space="preserve">
          <source>Source values of type bool may be scanned into types *bool, *interface{}, *string, *[]byte, or *RawBytes.</source>
          <target state="translated">bool类型的源值可以被扫描成*bool、*interface{}、*string、*[]byte或*RawBytes类型。</target>
        </trans-unit>
        <trans-unit id="4cd3cd23d4f7a4635c360a861ee7be174fed76cc" translate="yes" xml:space="preserve">
          <source>Source values of type time.Time may be scanned into values of type *time.Time, *interface{}, *string, or *[]byte. When converting to the latter two, time.RFC3339Nano is used.</source>
          <target state="translated">time.Time类型的源值可以被扫描成*time.Time、*interface{}、*string或*[]byte类型的值。当转换为后两种类型时,使用time.RFC3339Nano。</target>
        </trans-unit>
        <trans-unit id="6bdf6d7926b72078af0c191b3c6238538d7b0cb1" translate="yes" xml:space="preserve">
          <source>Special case is:</source>
          <target state="translated">特殊情况是:</target>
        </trans-unit>
        <trans-unit id="38cf2e1ac5d0bfa814379b9cb5b1a8aad4c71895" translate="yes" xml:space="preserve">
          <source>Special cases are (in order):</source>
          <target state="translated">特殊情况是(依次):</target>
        </trans-unit>
        <trans-unit id="36ff1c61fcf6a6f96273c5129f496e6e2d52bc61" translate="yes" xml:space="preserve">
          <source>Special cases are the same as Exp.</source>
          <target state="translated">特殊情况与博览会相同。</target>
        </trans-unit>
        <trans-unit id="fb4f18f6f604123235431e09b3313991f0bb526d" translate="yes" xml:space="preserve">
          <source>Special cases are:</source>
          <target state="translated">特殊情况是:</target>
        </trans-unit>
        <trans-unit id="46044fc293a1827aa7aed188a242765b1470a9ed" translate="yes" xml:space="preserve">
          <source>Special section indices.</source>
          <target state="translated">特别节指数。</target>
        </trans-unit>
        <trans-unit id="a2fde335dab74ce6562dfce419b45cb58e70ab07" translate="yes" xml:space="preserve">
          <source>SpecialCase</source>
          <target state="translated">SpecialCase</target>
        </trans-unit>
        <trans-unit id="47398a3a12335bdb3df057e3646557b1b5841333" translate="yes" xml:space="preserve">
          <source>SpecialCase represents language-specific case mappings such as Turkish. Methods of SpecialCase customize (by overriding) the standard mappings.</source>
          <target state="translated">SpecialCase表示特定语言的大小写映射,如土耳其语。SpecialCase的方法可以自定义(通过覆盖)标准映射。</target>
        </trans-unit>
        <trans-unit id="fc8230b4119ad4b994db2324d71f4e0ae7ad932c" translate="yes" xml:space="preserve">
          <source>Split</source>
          <target state="translated">Split</target>
        </trans-unit>
        <trans-unit id="23392488f19a5d0be8c39d3cfafde4dd76bd94be" translate="yes" xml:space="preserve">
          <source>Split panics if it is called after scanning has started.</source>
          <target state="translated">如果在扫描开始后被调用,则会出现分裂现象。</target>
        </trans-unit>
        <trans-unit id="96e564d2bf5c731af05562ed176616a9d55a5e64" translate="yes" xml:space="preserve">
          <source>Split sets the split function for the Scanner. The default split function is ScanLines.</source>
          <target state="translated">Split(分割)设置扫描仪的分割功能。默认的分割功能是ScanLines。</target>
        </trans-unit>
        <trans-unit id="eb475bc85cdb49a4c4de00518ab4efe39bcec33e" translate="yes" xml:space="preserve">
          <source>Split slices s into all subslices separated by sep and returns a slice of the subslices between those separators. If sep is empty, Split splits after each UTF-8 sequence. It is equivalent to SplitN with a count of -1.</source>
          <target state="translated">Split 将 s 分割成由 sep 分隔的所有子片段,并返回这些分隔符之间的子片段。如果sep为空,Split会在每个UTF-8序列之后进行分割。它等同于SplitN,计数为-1。</target>
        </trans-unit>
        <trans-unit id="67dbafd6c3b93902b18d8f321af8549a1b6ad6e7" translate="yes" xml:space="preserve">
          <source>Split slices s into all substrings separated by sep and returns a slice of the substrings between those separators.</source>
          <target state="translated">将 s 分割成所有用 sep 分隔的子串,并返回这些分隔符之间的子串的分片。</target>
        </trans-unit>
        <trans-unit id="8a1469b01e576340018d58bd7e3d302e90dee09f" translate="yes" xml:space="preserve">
          <source>Split slices s into substrings separated by the expression and returns a slice of the substrings between those expression matches.</source>
          <target state="translated">将s分割成由表达式分隔的子串,并返回这些表达式匹配之间的子串的分片。</target>
        </trans-unit>
        <trans-unit id="817430fe1883828acde2ae90d1a5b512a8d87c1e" translate="yes" xml:space="preserve">
          <source>Split splits path immediately following the final Separator, separating it into a directory and file name component. If there is no Separator in path, Split returns an empty dir and file set to path. The returned values have the property that path = dir+file.</source>
          <target state="translated">Split将紧跟在最后一个Separator后面的路径进行分割,将其分割成一个目录和文件名的部分,如果路径中没有Separator,Split将返回一个空的dir和文件,设置为path。如果path中没有Separator,Split会返回一个空的dir和设置为path的文件。返回的值具有path=dir+file的属性。</target>
        </trans-unit>
        <trans-unit id="04097266465adc5300d2bc3091a77206398acddf" translate="yes" xml:space="preserve">
          <source>Split splits path immediately following the final slash, separating it into a directory and file name component. If there is no slash in path, Split returns an empty dir and file set to path. The returned values have the property that path = dir+file.</source>
          <target state="translated">Split将路径分割成一个目录和文件名。如果path中没有斜杠,Split会返回一个空的dir和设置为path的文件。返回的值具有path=dir+file的属性。</target>
        </trans-unit>
        <trans-unit id="f645051fa0ea9f5fba674ae30e0eb8228c563bbb" translate="yes" xml:space="preserve">
          <source>SplitAfter</source>
          <target state="translated">SplitAfter</target>
        </trans-unit>
        <trans-unit id="af6f57e26d6655b8a560ff5a1ea503e038967615" translate="yes" xml:space="preserve">
          <source>SplitAfter slices s into all subslices after each instance of sep and returns a slice of those subslices. If sep is empty, SplitAfter splits after each UTF-8 sequence. It is equivalent to SplitAfterN with a count of -1.</source>
          <target state="translated">SplitAfter 将 s 分割成 sep 的每一个实例后的所有子片段,并返回这些子片段的一个片段。如果sep为空,SplitAfter会在每个UTF-8序列之后进行分割。它等同于SplitAfterN,计数为-1。</target>
        </trans-unit>
        <trans-unit id="7b96a1319471e70dc0744f490b304d8e5292e091" translate="yes" xml:space="preserve">
          <source>SplitAfter slices s into all substrings after each instance of sep and returns a slice of those substrings.</source>
          <target state="translated">SplitAfter 在每一个 sep 实例后将 s 切成所有子串,并返回这些子串的一个分片。</target>
        </trans-unit>
        <trans-unit id="183e10127881bddc63e39844aca6fde7b55ad84d" translate="yes" xml:space="preserve">
          <source>SplitAfterN</source>
          <target state="translated">SplitAfterN</target>
        </trans-unit>
        <trans-unit id="71c5d7e2f9fd13201867043dfefbd28be7cef909" translate="yes" xml:space="preserve">
          <source>SplitAfterN slices s into subslices after each instance of sep and returns a slice of those subslices. If sep is empty, SplitAfterN splits after each UTF-8 sequence. The count determines the number of subslices to return:</source>
          <target state="translated">SplitAfterN在每一个sep实例之后将s切成子片,并返回这些子片的一个片断。如果sep为空,SplitAfterN在每个UTF-8序列之后进行分割。计数决定了要返回的子片段的数量。</target>
        </trans-unit>
        <trans-unit id="b953b958d37f7636fa29a91139b9e599462e7d0a" translate="yes" xml:space="preserve">
          <source>SplitAfterN slices s into substrings after each instance of sep and returns a slice of those substrings.</source>
          <target state="translated">SplitAfterN 在每一个 sep 实例之后将 s 切成子串,并返回这些子串的一个分片。</target>
        </trans-unit>
        <trans-unit id="c42d1c66abbb920d11fa3452a55d6b02ca57969f" translate="yes" xml:space="preserve">
          <source>SplitFunc is the signature of the split function used to tokenize the input. The arguments are an initial substring of the remaining unprocessed data and a flag, atEOF, that reports whether the Reader has no more data to give. The return values are the number of bytes to advance the input and the next token to return to the user, if any, plus an error, if any.</source>
          <target state="translated">SplitFunc是用于标记输入的分割函数的签名。参数是一个剩余的未处理数据的初始子串和一个标志,atEOF,用于报告Reader是否没有更多的数据可给。返回值是推进输入的字节数和返回给用户的下一个标记(如果有的话),加上一个错误(如果有的话)。</target>
        </trans-unit>
        <trans-unit id="b4cd81f732cbd3a8923ecb19ba58f0f16cb90789" translate="yes" xml:space="preserve">
          <source>SplitHostPort splits a network address of the form &quot;host:port&quot;, &quot;host%zone:port&quot;, &quot;[host]:port&quot; or &quot;[host%zone]:port&quot; into host or host%zone and port.</source>
          <target state="translated">SplitHostPort将 &quot;host:port&quot;、&quot;host%zone:port&quot;、&quot;[host]:port &quot;或&quot;[host%zone]:port &quot;形式的网络地址分割成host或host%zone和port。</target>
        </trans-unit>
        <trans-unit id="83d28a087df2085b354d9219f029b5d90cf38ec4" translate="yes" xml:space="preserve">
          <source>SplitList</source>
          <target state="translated">SplitList</target>
        </trans-unit>
        <trans-unit id="2810f9f5e2566aed968386693eafb51ff308b597" translate="yes" xml:space="preserve">
          <source>SplitList splits a list of paths joined by the OS-specific ListSeparator, usually found in PATH or GOPATH environment variables. Unlike strings.Split, SplitList returns an empty slice when passed an empty string.</source>
          <target state="translated">SplitList 将一个由操作系统特有的 ListSeparator 连接的路径列表分割开来,通常在 PATH 或 GOPATH 环境变量中找到。与 strings.Split 不同,当传递一个空字符串时,SplitList 会返回一个空分片。</target>
        </trans-unit>
        <trans-unit id="84cfaf9bc325cc024ba8d73b2f03f1f0b940f375" translate="yes" xml:space="preserve">
          <source>SplitN</source>
          <target state="translated">SplitN</target>
        </trans-unit>
        <trans-unit id="36c3c8ea011f7ef62da6893e010962d6852bd07a" translate="yes" xml:space="preserve">
          <source>SplitN slices s into subslices separated by sep and returns a slice of the subslices between those separators. If sep is empty, SplitN splits after each UTF-8 sequence. The count determines the number of subslices to return:</source>
          <target state="translated">SplitN 将 s 切成由 sep 分隔的子片,并返回这些分隔符之间的子片。如果sep为空,SplitN会在每个UTF-8序列之后进行分割。计数决定了要返回的子分片数量。</target>
        </trans-unit>
        <trans-unit id="de01961453e6bcc30ddd7714ed914f746f011fab" translate="yes" xml:space="preserve">
          <source>SplitN slices s into substrings separated by sep and returns a slice of the substrings between those separators.</source>
          <target state="translated">SplitN 将 s 切成由 sep 分隔的子线,并返回这些分隔符之间的子线的切片。</target>
        </trans-unit>
        <trans-unit id="8ca15484a6a50617febf823f3fa1c9e7038688ee" translate="yes" xml:space="preserve">
          <source>Sprint</source>
          <target state="translated">Sprint</target>
        </trans-unit>
        <trans-unit id="d0775164f7f53356c293723cd9c1222468d3a49b" translate="yes" xml:space="preserve">
          <source>Sprint formats using the default formats for its operands and returns the resulting string. Spaces are added between operands when neither is a string.</source>
          <target state="translated">Sprint使用默认格式对操作数进行格式化,并返回结果字符串。当两个操作数都不是字符串时,操作数之间会添加空格。</target>
        </trans-unit>
        <trans-unit id="7d5fe7cc61bbb8158ad630a3820e3c126928a4a6" translate="yes" xml:space="preserve">
          <source>Sprintf</source>
          <target state="translated">Sprintf</target>
        </trans-unit>
        <trans-unit id="5bfb46358289368784772aa4aa5a217258b76236" translate="yes" xml:space="preserve">
          <source>Sprintf formats according to a format specifier and returns the resulting string.</source>
          <target state="translated">Sprintf根据格式指定器格式化并返回结果。</target>
        </trans-unit>
        <trans-unit id="5446f67533b2f88354fccb3b84fed81fd676a9d5" translate="yes" xml:space="preserve">
          <source>Sprintln</source>
          <target state="translated">Sprintln</target>
        </trans-unit>
        <trans-unit id="d0bd83b3300fd81e26aa39c136cc9d6ce11bb5a7" translate="yes" xml:space="preserve">
          <source>Sprintln formats using the default formats for its operands and returns the resulting string. Spaces are always added between operands and a newline is appended.</source>
          <target state="translated">Sprintln使用默认的操作数格式进行格式化,并返回结果。操作数之间总是加空格,并附加一个换行。</target>
        </trans-unit>
        <trans-unit id="6bbb118b36018412cea4de47bc914f00685c9ac5" translate="yes" xml:space="preserve">
          <source>Sqrt</source>
          <target state="translated">Sqrt</target>
        </trans-unit>
        <trans-unit id="1b795ae9b134bc8c4c0b446e88fecc1f3b41d092" translate="yes" xml:space="preserve">
          <source>Sqrt returns the square root of x.</source>
          <target state="translated">Sqrt 返回 x 的平方根。</target>
        </trans-unit>
        <trans-unit id="b85c9b396b0e4464f48aa17058f2b1082008ae70" translate="yes" xml:space="preserve">
          <source>Sqrt returns the square root of x. The result r is chosen so that real(r) &amp;ge; 0 and imag(r) has the same sign as imag(x).</source>
          <target state="translated">Sqrt返回x的平方根。选择结果r，以使real（r）&amp;ge;0且imag（r）具有与imag（x）相同的符号。</target>
        </trans-unit>
        <trans-unit id="41b5f4c2f86ca750aabbdd4d6bdb915be0584893" translate="yes" xml:space="preserve">
          <source>Sqrt sets z to &amp;lfloor;&amp;radic;x&amp;rfloor;, the largest integer such that z&amp;sup2; &amp;le; x, and returns z. It panics if x is negative.</source>
          <target state="translated">Sqrt将z设置为&amp;lfloor;&amp;radic;x&amp;rfloor;，即使得z&amp;sup2;&amp;le;x的最大整数，并返回z。如果x为负，则表示恐慌。</target>
        </trans-unit>
        <trans-unit id="2e519fcfbc6a90ddf75f1394fae55598d7af8898" translate="yes" xml:space="preserve">
          <source>Sqrt sets z to the rounded square root of x, and returns it.</source>
          <target state="translated">Sqrt 将 z 设为 x 的四舍五入平方根,并将其返回。</target>
        </trans-unit>
        <trans-unit id="b183229b8a0007179105ee23f98db0fa35e992ca" translate="yes" xml:space="preserve">
          <source>SrcDirs returns a list of package source root directories. It draws from the current Go root and Go path but omits directories that do not exist.</source>
          <target state="translated">SrcDirs 返回包的源根目录列表。它从当前的Go根目录和Go路径中提取,但省略不存在的目录。</target>
        </trans-unit>
        <trans-unit id="ace37ead62176f4b0fef73d8a4e6eefe6e4e0808" translate="yes" xml:space="preserve">
          <source>Srcset encapsulates a known safe srcset attribute (see &lt;a href=&quot;https://w3c.github.io/html/semantics-embedded-content.html#element-attrdef-img-srcset&quot;&gt;https://w3c.github.io/html/semantics-embedded-content.html#element-attrdef-img-srcset&lt;/a&gt;).</source>
          <target state="translated">Srcset封装了一个已知的安全srcset属性（请参阅&lt;a href=&quot;https://w3c.github.io/html/semantics-embedded-content.html#element-attrdef-img-srcset&quot;&gt;https://w3c.github.io/html/semantics-embedded-content.html#element-attrdef-img-srcset&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="608729966442ded3bea906aefa46d7a131fb981c" translate="yes" xml:space="preserve">
          <source>Sscan scans the argument string, storing successive space-separated values into successive arguments. Newlines count as space. It returns the number of items successfully scanned. If that is less than the number of arguments, err will report why.</source>
          <target state="translated">Sscan扫描参数字符串,将连续的空格分隔的值存储到连续的参数中。换行也算作空格。它返回成功扫描的项目数。如果少于参数数,err将报告原因。</target>
        </trans-unit>
        <trans-unit id="390342df3a9580b3ab53916d8e78ce9a67e05f51" translate="yes" xml:space="preserve">
          <source>Sscanf</source>
          <target state="translated">Sscanf</target>
        </trans-unit>
        <trans-unit id="61a716d2775c775cb5be05f41652e9aaaad32358" translate="yes" xml:space="preserve">
          <source>Sscanf scans the argument string, storing successive space-separated values into successive arguments as determined by the format. It returns the number of items successfully parsed. Newlines in the input must match newlines in the format.</source>
          <target state="translated">Sscanf扫描参数字符串,将连续的空格分隔的值存储到由格式决定的连续参数中。它返回成功解析的项数。输入中的换行必须与格式中的换行相匹配。</target>
        </trans-unit>
        <trans-unit id="af4732932dde6aa0c1e4ad7d04d2e2382ec0a0b6" translate="yes" xml:space="preserve">
          <source>Sscanln is similar to Sscan, but stops scanning at a newline and after the final item there must be a newline or EOF.</source>
          <target state="translated">Sscanln与Sscan类似,但在换行处停止扫描,最后一项后必须有换行或EOF。</target>
        </trans-unit>
        <trans-unit id="6f3e4b56a56750c728e3e2463bad931f8918a9d7" translate="yes" xml:space="preserve">
          <source>Stable sorts data while keeping the original order of equal elements.</source>
          <target state="translated">稳定地对数据进行排序,同时保持原有的等元素顺序。</target>
        </trans-unit>
        <trans-unit id="c9e8e2e8cb17ec7f99a9db77c101e60f6136c3a5" translate="yes" xml:space="preserve">
          <source>Stack formats a stack trace of the calling goroutine into buf and returns the number of bytes written to buf. If all is true, Stack formats stack traces of all other goroutines into buf after the trace for the current goroutine.</source>
          <target state="translated">Stack将调用的goroutine的堆栈跟踪格式化为buf,并返回写入buf的字节数。如果all为true,Stack将所有其他goroutine的堆栈跟踪格式化到当前goroutine跟踪之后的buf中。</target>
        </trans-unit>
        <trans-unit id="1cffafd303a34a6584721e138e5265f842cb505a" translate="yes" xml:space="preserve">
          <source>Stack returns a formatted stack trace of the goroutine that calls it. It calls runtime.Stack with a large enough buffer to capture the entire trace.</source>
          <target state="translated">Stack 返回调用它的 goroutine 的格式化栈跟踪。它调用runtime.Stack,并提供足够大的缓冲区来捕获整个跟踪。</target>
        </trans-unit>
        <trans-unit id="418aa94a169d739e57a35d99f93d9138e0bb4b62" translate="yes" xml:space="preserve">
          <source>Stack returns the stack trace associated with the record, a prefix of r.Stack0.</source>
          <target state="translated">Stack返回与记录相关的堆栈跟踪,是r.Stack0的前缀。</target>
        </trans-unit>
        <trans-unit id="687cb3d7c249eff01be44167736a622ba61578c9" translate="yes" xml:space="preserve">
          <source>Standard colors.</source>
          <target state="translated">标准色。</target>
        </trans-unit>
        <trans-unit id="360c57caedbd1d1ff38dde144677c893d6ad3792" translate="yes" xml:space="preserve">
          <source>Standard library</source>
          <target state="translated">标准库</target>
        </trans-unit>
        <trans-unit id="9fb1a9f741b4439135087b938ed47613619d8e54" translate="yes" xml:space="preserve">
          <source>Start enables tracing for the current program. While tracing, the trace will be buffered and written to w. Start returns an error if tracing is already enabled.</source>
          <target state="translated">Start启用了对当前程序的跟踪,在跟踪过程中,跟踪结果会被缓冲并写入w中。在跟踪过程中,跟踪将被缓冲,并写入w中。</target>
        </trans-unit>
        <trans-unit id="d84f21e1e9935e064f3eccc25d6db5d4fb64a86a" translate="yes" xml:space="preserve">
          <source>Start starts a server from NewUnstartedServer.</source>
          <target state="translated">Start从NewUnstartedServer启动一个服务器。</target>
        </trans-unit>
        <trans-unit id="b61ef15d781bf8c860427db7964980f61966535c" translate="yes" xml:space="preserve">
          <source>Start starts the specified command but does not wait for it to complete.</source>
          <target state="translated">Start启动指定的命令,但不等待其完成。</target>
        </trans-unit>
        <trans-unit id="7f51b09c0923a4603b545c471069b55e22a62f34" translate="yes" xml:space="preserve">
          <source>StartCPUProfile enables CPU profiling for the current process. While profiling, the profile will be buffered and written to w. StartCPUProfile returns an error if profiling is already enabled.</source>
          <target state="translated">StartCPUProfile启用了当前进程的CPU剖析。如果已经启用了CPU剖析,StartCPUProfile会返回一个错误。</target>
        </trans-unit>
        <trans-unit id="f3753321843c42ccf0d93028e612610280e12d5e" translate="yes" xml:space="preserve">
          <source>StartCond returns the leading empty-width conditions that must be true in any match. It returns ^EmptyOp(0) if no matches are possible.</source>
          <target state="translated">StartCond 返回任何匹配中必须为真的前导空宽条件。如果没有匹配,它返回^EmptyOp(0)。</target>
        </trans-unit>
        <trans-unit id="e00bec2778efe9f0a1a92501d76b773c7dc58166" translate="yes" xml:space="preserve">
          <source>StartProcess is a low-level interface. The os/exec package provides higher-level interfaces.</source>
          <target state="translated">StartProcess是一个低级接口。os/exec包提供了更高层次的接口。</target>
        </trans-unit>
        <trans-unit id="4656baf99c52e7677cc8f68ccbc8052e39ef42e9" translate="yes" xml:space="preserve">
          <source>StartProcess starts a new process with the program, arguments and attributes specified by name, argv and attr. The argv slice will become os.Args in the new process, so it normally starts with the program name.</source>
          <target state="translated">StartProcess 用 name、argv 和 attr 指定的程序、参数和属性启动一个新进程。argv 片段在新进程中会变成 os.Args,所以它通常以程序名开始。</target>
        </trans-unit>
        <trans-unit id="d3d2be7776a3d003cee77683d05001ec6ef09966" translate="yes" xml:space="preserve">
          <source>StartProcess wraps ForkExec for package os.</source>
          <target state="translated">StartProcess为包os.StartProcess封装了ForkExec。</target>
        </trans-unit>
        <trans-unit id="4593c93bfc9fb8dacabfc8b4a1731d4454969f64" translate="yes" xml:space="preserve">
          <source>StartRegion starts a region and returns a function for marking the end of the region. The returned Region's End function must be called from the same goroutine where the region was started. Within each goroutine, regions must nest. That is, regions started after this region must be ended before this region can be ended. Recommended usage is</source>
          <target state="translated">StartRegion启动一个区域,并返回一个用于标记区域结束的函数。返回的Region's End函数必须从启动该区域的同一个goroutine中调用。在每个goroutine中,区域必须嵌套。也就是说,在这个区域之后开始的区域必须在这个区域结束之前结束。推荐的用法是</target>
        </trans-unit>
        <trans-unit id="3b719a81fa9e5ddcbfba4cb3fb45c729f487d09e" translate="yes" xml:space="preserve">
          <source>StartRequest blocks until it is time to send (or, if this is a server, receive) the request with the given id.</source>
          <target state="translated">StartRequest阻塞,直到发送(或者,如果这是一个服务器,接收)给定id的请求的时候。</target>
        </trans-unit>
        <trans-unit id="338c8f94474f010aa4669ab2c0ae55a5c3a8c12a" translate="yes" xml:space="preserve">
          <source>StartResponse blocks until it is time to receive (or, if this is a server, send) the request with the given id.</source>
          <target state="translated">StartResponse阻塞,直到接收(或者,如果这是一个服务器,发送)给定id的请求。</target>
        </trans-unit>
        <trans-unit id="7ea714fe33f9c8708b382ac24930c9134895c05e" translate="yes" xml:space="preserve">
          <source>StartTLS sends the STARTTLS command and encrypts all further communication. Only servers that advertise the STARTTLS extension support this function.</source>
          <target state="translated">StartTLS发送STARTTLS命令,并对所有进一步的通信进行加密。只有宣传STARTTLS扩展的服务器才支持这个功能。</target>
        </trans-unit>
        <trans-unit id="d062840c5c4653552407064d11c812b2dfbbac16" translate="yes" xml:space="preserve">
          <source>StartTLS starts TLS on a server from NewUnstartedServer.</source>
          <target state="translated">StartTLS从NewUnstartedServer开始在服务器上启动TLS。</target>
        </trans-unit>
        <trans-unit id="01903002ac73fdbc83cec8f016e70281a8a03041" translate="yes" xml:space="preserve">
          <source>StartTimer starts timing a test. This function is called automatically before a benchmark starts, but it can also be used to resume timing after a call to StopTimer.</source>
          <target state="translated">StartTimer开始为测试计时。这个函数在基准开始前自动调用,但也可以在调用StopTimer后继续计时。</target>
        </trans-unit>
        <trans-unit id="bb33cf53f4e568db572c687d22b2ff2888d74df9" translate="yes" xml:space="preserve">
          <source>StartTrace enables tracing for the current process. While tracing, the data will be buffered and available via ReadTrace. StartTrace returns an error if tracing is already enabled. Most clients should use the runtime/trace package or the testing package's -test.trace flag instead of calling StartTrace directly.</source>
          <target state="translated">StartTrace可以对当前进程进行跟踪。在跟踪过程中,数据将被缓冲并通过ReadTrace提供。如果跟踪已经启用,StartTrace会返回一个错误。大多数客户端应该使用运行时/跟踪包或测试包的-test.trace标志,而不是直接调用StartTrace。</target>
        </trans-unit>
        <trans-unit id="6de552c394748272d237ee2909c17f8a5fd51503" translate="yes" xml:space="preserve">
          <source>Starting with Go 1.6, the http package has transparent support for the HTTP/2 protocol when using HTTPS. Programs that must disable HTTP/2 can do so by setting Transport.TLSNextProto (for clients) or Server.TLSNextProto (for servers) to a non-nil, empty map. Alternatively, the following GODEBUG environment variables are currently supported:</source>
          <target state="translated">从Go 1.6开始,当使用HTTPS时,http包对HTTP/2协议有透明的支持。必须禁用HTTP/2的程序可以通过将Transport.TLSNextProto(客户端)或Server.TLSNextProto(服务器)设置为非零的空映射来实现。另外,目前还支持以下GODEBUG环境变量。</target>
        </trans-unit>
        <trans-unit id="9c555084811f017d34d2693472b49bb062306f30" translate="yes" xml:space="preserve">
          <source>Stat returns a FileInfo describing the named file. If there is an error, it will be of type *PathError.</source>
          <target state="translated">Stat返回一个描述命名文件的FileInfo,如果有错误,它的类型是*PathError。如果有错误,它将是*PathError类型。</target>
        </trans-unit>
        <trans-unit id="e4a95458fc56105197c2a964b9366157865cbb1b" translate="yes" xml:space="preserve">
          <source>Stat returns the FileInfo structure describing file. If there is an error, it will be of type *PathError.</source>
          <target state="translated">Stat返回描述文件的FileInfo结构。如果有错误,它将是*PathError类型。</target>
        </trans-unit>
        <trans-unit id="6ed6c9c2af9ffd2ea1bfb59989c27d85db3a34df" translate="yes" xml:space="preserve">
          <source>State represents the printer state passed to custom formatters. It provides access to the io.Writer interface plus information about the flags and options for the operand's format specifier.</source>
          <target state="translated">State表示传递给自定义格式化器的打印机状态,它提供了对io.Writer接口的访问以及操作数的格式指定器的标志和选项信息。它提供了对io.Writer接口的访问,以及操作数格式指定器的标志和选项信息。</target>
        </trans-unit>
        <trans-unit id="6c898e0bae6ae6e6a509998b0d70b717982994c3" translate="yes" xml:space="preserve">
          <source>Static reports whether this symbol is static (not visible outside its file).</source>
          <target state="translated">静态报告这个符号是否是静态的(在其文件外不可见)。</target>
        </trans-unit>
        <trans-unit id="f107d6fd99e84eaeb4014efe73efa78374b13f61" translate="yes" xml:space="preserve">
          <source>Stats returns database statistics.</source>
          <target state="translated">Stats返回数据库统计数据。</target>
        </trans-unit>
        <trans-unit id="473cf8363b9a9dc6de8f9778203d0b0d99ffe820" translate="yes" xml:space="preserve">
          <source>StatusText returns a text for the HTTP status code. It returns the empty string if the code is unknown.</source>
          <target state="translated">StatusText返回HTTP状态码的文本。如果代码未知,则返回空字符串。</target>
        </trans-unit>
        <trans-unit id="d95efd4b66df751ef4f7e7c0d6a981a761feec31" translate="yes" xml:space="preserve">
          <source>StdEncoding is the standard base32 encoding, as defined in RFC 4648.</source>
          <target state="translated">StdEncoding是RFC 4648中定义的标准base32编码。</target>
        </trans-unit>
        <trans-unit id="a9197d0bbe7d5f346c8fce4d5958e4af36331be4" translate="yes" xml:space="preserve">
          <source>StdEncoding is the standard base64 encoding, as defined in RFC 4648.</source>
          <target state="translated">StdEncoding是RFC 4648中定义的标准base64编码。</target>
        </trans-unit>
        <trans-unit id="c30cba7f2a4c150acfe65c8a3aa36a9ff709ad57" translate="yes" xml:space="preserve">
          <source>StdSizes is a convenience type for creating commonly used Sizes. It makes the following simplifying assumptions:</source>
          <target state="translated">StdSizes是一个方便的类型,用于创建常用的Sizes。它做了以下简化假设。</target>
        </trans-unit>
        <trans-unit id="34f196b4b0f694cd0a2f21247970027005c1305c" translate="yes" xml:space="preserve">
          <source>StderrPipe returns a pipe that will be connected to the command's standard error when the command starts.</source>
          <target state="translated">StderrPipe返回一个管道,当命令启动时,该管道将连接到命令的标准错误。</target>
        </trans-unit>
        <trans-unit id="f9c5224ebb81b29f683fd0f89569f0498e209b24" translate="yes" xml:space="preserve">
          <source>Stdin, Stdout, and Stderr are open Files pointing to the standard input, standard output, and standard error file descriptors.</source>
          <target state="translated">Stdin、Stdout和Stderr是指向标准输入、标准输出和标准错误文件描述符的开放文件。</target>
        </trans-unit>
        <trans-unit id="eaaa7d5358fae0ad4ea6507594efa4e1fe1938f3" translate="yes" xml:space="preserve">
          <source>StdinPipe returns a pipe that will be connected to the command's standard input when the command starts. The pipe will be closed automatically after Wait sees the command exit. A caller need only call Close to force the pipe to close sooner. For example, if the command being run will not exit until standard input is closed, the caller must close the pipe.</source>
          <target state="translated">StdinPipe 返回一个管道,当命令启动时,该管道将连接到命令的标准输入。在Wait看到命令退出后,管道将自动关闭。调用者只需要调用Close就可以强制管道提前关闭。例如,如果正在运行的命令在标准输入关闭之前不会退出,调用者必须关闭管道。</target>
        </trans-unit>
        <trans-unit id="e34e1f63d532ddcb966f6992c5d243530bff512e" translate="yes" xml:space="preserve">
          <source>StdoutPipe returns a pipe that will be connected to the command's standard output when the command starts.</source>
          <target state="translated">StdoutPipe返回一个管道,当命令启动时,该管道将连接到命令的标准输出。</target>
        </trans-unit>
        <trans-unit id="35cb1f2f3090469fddd290f48f6f6f66f6cfbf71" translate="yes" xml:space="preserve">
          <source>Stmt</source>
          <target state="translated">Stmt</target>
        </trans-unit>
        <trans-unit id="e8d756b195575772804ef522d92696943863af82" translate="yes" xml:space="preserve">
          <source>Stmt is a prepared statement. A Stmt is safe for concurrent use by multiple goroutines.</source>
          <target state="translated">Stmt是一个准备好的语句。一个Stmt可以安全地被多个goroutine同时使用。</target>
        </trans-unit>
        <trans-unit id="0bb26a3ab8d8618ecc81beec5115670b66a970d5" translate="yes" xml:space="preserve">
          <source>Stmt is a prepared statement. It is bound to a Conn and not used by multiple goroutines concurrently.</source>
          <target state="translated">Stmt是一个准备好的语句。它与Conn绑定,不能被多个goroutine同时使用。</target>
        </trans-unit>
        <trans-unit id="9e8123e57a051d77d8becac273756b24f947f7c4" translate="yes" xml:space="preserve">
          <source>Stmt returns a transaction-specific prepared statement from an existing statement.</source>
          <target state="translated">Stmt从现有的报表中返回一个特定事务的预备报表。</target>
        </trans-unit>
        <trans-unit id="9e2e6090b163c6036190ffea94ddcfbb24b8b882" translate="yes" xml:space="preserve">
          <source>Stmt.QueryRowContext</source>
          <target state="translated">Stmt.QueryRowContext</target>
        </trans-unit>
        <trans-unit id="70af1d64e33ba2bc94ac6b94c7823d3046a2e685" translate="yes" xml:space="preserve">
          <source>StmtContext returns a transaction-specific prepared statement from an existing statement.</source>
          <target state="translated">StmtContext从现有的语句中返回一个特定事务的准备语句。</target>
        </trans-unit>
        <trans-unit id="a70153fdc2043d42cd12ca46ccb4c33b57b300d4" translate="yes" xml:space="preserve">
          <source>StmtExecContext enhances the Stmt interface by providing Exec with context.</source>
          <target state="translated">StmtExecContext通过为Exec提供上下文来增强Stmt接口。</target>
        </trans-unit>
        <trans-unit id="1004fd52a4b277314a44a4efa023effe4416d3f8" translate="yes" xml:space="preserve">
          <source>StmtQueryContext enhances the Stmt interface by providing Query with context.</source>
          <target state="translated">StmtQueryContext通过提供具有上下文的Query来增强Stmt接口。</target>
        </trans-unit>
        <trans-unit id="4e7e607354865ab06dac634d86cb1266a005b9e3" translate="yes" xml:space="preserve">
          <source>Stop causes package signal to stop relaying incoming signals to c. It undoes the effect of all prior calls to Notify using c. When Stop returns, it is guaranteed that c will receive no more signals.</source>
          <target state="translated">Stop使包信号停止向c中继传入信号,并撤销之前所有使用c调用Notify的效果,当Stop返回时,保证c不再接收信号。</target>
        </trans-unit>
        <trans-unit id="94f72ec5a9e9e46f0269677088e9aed4dc6bf0c7" translate="yes" xml:space="preserve">
          <source>Stop prevents the Timer from firing. It returns true if the call stops the timer, false if the timer has already expired or been stopped. Stop does not close the channel, to prevent a read from the channel succeeding incorrectly.</source>
          <target state="translated">Stop阻止定时器发射。如果调用停止定时器,则返回true,如果定时器已经过期或被停止,则返回false。Stop不关闭通道,以防止从通道中读取的数据不正确地成功。</target>
        </trans-unit>
        <trans-unit id="96e4cceff229f7d0b6242e33e40b44c6e1f954ad" translate="yes" xml:space="preserve">
          <source>Stop stops the current tracing, if any. Stop only returns after all the writes for the trace have completed.</source>
          <target state="translated">停止当前的跟踪,如果有的话。Stop只在所有跟踪的写入完成后才返回。</target>
        </trans-unit>
        <trans-unit id="f869959cdbddc758676d9a0b40b1ccec00a007e0" translate="yes" xml:space="preserve">
          <source>Stop turns off a ticker. After Stop, no more ticks will be sent. Stop does not close the channel, to prevent a concurrent goroutine reading from the channel from seeing an erroneous &quot;tick&quot;.</source>
          <target state="translated">停止关闭一个行情。停止后,将不再发送更多的 &quot;tick&quot;。停止不会关闭通道,以防止同时从通道读取的goroutine看到一个错误的 &quot;tick&quot;。</target>
        </trans-unit>
        <trans-unit id="6c60cc11ce6206ba7285eea9b92d5192efe41d39" translate="yes" xml:space="preserve">
          <source>StopCPUProfile stops the current CPU profile, if any. StopCPUProfile only returns after all the writes for the profile have completed.</source>
          <target state="translated">StopCPUProfile停止当前CPU配置文件(如果有的话)。StopCPUProfile只有在配置文件的所有写入完成后才会返回。</target>
        </trans-unit>
        <trans-unit id="921647073cddc48eae81cacd6f73563cc3719e6f" translate="yes" xml:space="preserve">
          <source>StopTimer stops timing a test. This can be used to pause the timer while performing complex initialization that you don't want to measure.</source>
          <target state="translated">StopTimer停止测试计时。这可以用来在执行复杂的初始化时暂停定时器,而你不想测量。</target>
        </trans-unit>
        <trans-unit id="84dbe4eb021745433f9d6bb9432228e77ba19099" translate="yes" xml:space="preserve">
          <source>StopTrace stops tracing, if it was previously enabled. StopTrace only returns after all the reads for the trace have completed.</source>
          <target state="translated">如果之前启用了StopTrace,则停止跟踪。StopTrace只在所有跟踪的读取完成后才返回。</target>
        </trans-unit>
        <trans-unit id="e64cf11d9830120b60f240aa4b7f7791804376a7" translate="yes" xml:space="preserve">
          <source>Store sets the value for a key.</source>
          <target state="translated">存储设置一个键的值。</target>
        </trans-unit>
        <trans-unit id="0576297e57bdd6afa5e5d4f4c53fb27987cf20cb" translate="yes" xml:space="preserve">
          <source>Store sets the value of the Value to x. All calls to Store for a given Value must use values of the same concrete type. Store of an inconsistent type panics, as does Store(nil).</source>
          <target state="translated">Store 将 Value 的值设置为 x。对给定 Value 的所有 Store 调用必须使用相同具体类型的值。类型不一致的Store会惊慌失措,Store(nil)也是如此。</target>
        </trans-unit>
        <trans-unit id="61fc43e10839248a6ca4c0ad01079c0c4ad0ec37" translate="yes" xml:space="preserve">
          <source>StoreInt32 atomically stores val into *addr.</source>
          <target state="translated">StoreInt32原子地将val存储到*addr中。</target>
        </trans-unit>
        <trans-unit id="7914e40a268c91ed6c78dd3a0c674684e23beca2" translate="yes" xml:space="preserve">
          <source>StoreInt64 atomically stores val into *addr.</source>
          <target state="translated">StoreInt64原子地将val存储到*addr中。</target>
        </trans-unit>
        <trans-unit id="3bd4e783553f00f03c188a415e3661fa8de191b3" translate="yes" xml:space="preserve">
          <source>StorePointer atomically stores val into *addr.</source>
          <target state="translated">StorePointer原子地将val存储到*addr中。</target>
        </trans-unit>
        <trans-unit id="9cc88c9dca1de73040dfd90e6d827a5b531c64fe" translate="yes" xml:space="preserve">
          <source>StoreUint32 atomically stores val into *addr.</source>
          <target state="translated">StoreUint32原子地将val存储到*addr中。</target>
        </trans-unit>
        <trans-unit id="e11c1fe521ea309905b20e2bda18135e66472a1e" translate="yes" xml:space="preserve">
          <source>StoreUint64 atomically stores val into *addr.</source>
          <target state="translated">StoreUint64原子地将val存储到*addr中。</target>
        </trans-unit>
        <trans-unit id="644096d645019d8a2ba6cbc4d305a2699fe9059f" translate="yes" xml:space="preserve">
          <source>StoreUintptr atomically stores val into *addr.</source>
          <target state="translated">StoreUintptr原子地将val存储到*addr中。</target>
        </trans-unit>
        <trans-unit id="cab8594aca23f91dcc0728ca91d9d20dcd26b690" translate="yes" xml:space="preserve">
          <source>StreamReader</source>
          <target state="translated">StreamReader</target>
        </trans-unit>
        <trans-unit id="2a7fc943079fc92f6a989794ba51133e347d57cd" translate="yes" xml:space="preserve">
          <source>StreamReader wraps a Stream into an io.Reader. It calls XORKeyStream to process each slice of data which passes through.</source>
          <target state="translated">StreamReader将一个Stream包装成一个io.Reader。它调用XORKeyStream来处理每个经过的数据片断。</target>
        </trans-unit>
        <trans-unit id="232a89f73446348f72f684c82d07ed788b848a3a" translate="yes" xml:space="preserve">
          <source>StreamWriter</source>
          <target state="translated">StreamWriter</target>
        </trans-unit>
        <trans-unit id="fc13aaf005c735ab0e4aa5176b6af67540be3a8b" translate="yes" xml:space="preserve">
          <source>StreamWriter wraps a Stream into an io.Writer. It calls XORKeyStream to process each slice of data which passes through. If any Write call returns short then the StreamWriter is out of sync and must be discarded. A StreamWriter has no internal buffering; Close does not need to be called to flush write data.</source>
          <target state="translated">StreamWriter将一个Stream包装成一个io.Writer,它调用XORKeyStream来处理每个经过的数据片断。它调用XORKeyStream来处理每个经过的数据片断。如果任何Write调用都返回短路,那么StreamWriter就失去了同步,必须被丢弃。StreamWriter没有内部缓冲;Close不需要被调用来刷新写数据。</target>
        </trans-unit>
        <trans-unit id="61135993a6e29b59a8df3075ca0d3838f94b8d90" translate="yes" xml:space="preserve">
          <source>Strict creates a new encoding identical to enc except with strict decoding enabled. In this mode, the decoder requires that trailing padding bits are zero, as described in RFC 4648 section 3.5.</source>
          <target state="translated">Strict创建一个与enc相同的新编码,除了启用严格的解码。在这种模式下,解码器要求尾部填充位为零,如RFC 4648第3.5节所述。</target>
        </trans-unit>
        <trans-unit id="396b00d6c7e8c1194e27297cd11ae3108cdacd84" translate="yes" xml:space="preserve">
          <source>String Conversions</source>
          <target state="translated">字符串转换</target>
        </trans-unit>
        <trans-unit id="bd47be7c94487cbe10dfe0be4138815d0017463a" translate="yes" xml:space="preserve">
          <source>String and slice of bytes (treated equivalently with these verbs):</source>
          <target state="translated">字节串和字节片(与这些动词等价处理)。</target>
        </trans-unit>
        <trans-unit id="8296a76a0e5d96744b29fe69547a88fb9387440d" translate="yes" xml:space="preserve">
          <source>String defines a string flag with specified name, default value, and usage string. The return value is the address of a string variable that stores the value of the flag.</source>
          <target state="translated">String定义了一个字符串标志,具有指定的名称、默认值和用法字符串。返回值是存储标志值的字符串变量的地址。</target>
        </trans-unit>
        <trans-unit id="9e4dec141cb0219423f92167f6932232e80cdb9e" translate="yes" xml:space="preserve">
          <source>String extracts string from COFF string table st at offset start.</source>
          <target state="translated">字符串从偏移量开始的COFF字符串表st中提取字符串。</target>
        </trans-unit>
        <trans-unit id="dcd688eb0f2fbd5e407777a28042b64595f0fef8" translate="yes" xml:space="preserve">
          <source>String formats the address as a valid RFC 5322 address. If the address's name contains non-ASCII characters the name will be rendered according to RFC 2047.</source>
          <target state="translated">字符串将地址格式化为有效的RFC 5322地址。如果地址名称中包含非ASCII字符,则将根据RFC 2047的规定进行处理。</target>
        </trans-unit>
        <trans-unit id="8d105c469495a5d5f8062e63371ab613869f1e04" translate="yes" xml:space="preserve">
          <source>String formats x like x.Text('g', 10). (String must be called explicitly, Float.Format does not support %s verb.)</source>
          <target state="translated">字符串格式化x,如x.Text('g',10)。(String必须被显式调用,Float.Format不支持%s动词。)</target>
        </trans-unit>
        <trans-unit id="01748cd6407645feded183980c6258bbb0d669e6" translate="yes" xml:space="preserve">
          <source>String implements the Var interface. To get the unquoted string use Value.</source>
          <target state="translated">String实现了Var接口。要获得未引号的字符串,请使用Value.Value接口。</target>
        </trans-unit>
        <trans-unit id="c388848919b90e3a01d2d3408f1ebde77b3f2a74" translate="yes" xml:space="preserve">
          <source>String is a ValueConverter that converts its input to a string. If the value is already a string or []byte, it's unchanged. If the value is of another type, conversion to string is done with fmt.Sprintf(&quot;%v&quot;, v).</source>
          <target state="translated">String是一个ValueConverter,它将其输入转换为一个字符串。如果值已经是一个字符串或[]字节,它就不会改变。如果值是其他类型,则用fmt.Sprintf(&quot;%v&quot;,v)转换为字符串。</target>
        </trans-unit>
        <trans-unit id="014933e8c2aa543fd850622d80731a6a9386778b" translate="yes" xml:space="preserve">
          <source>String is a string variable, and satisfies the Var interface.</source>
          <target state="translated">String是一个字符串变量,并满足Var接口。</target>
        </trans-unit>
        <trans-unit id="83826ec6cada0ae1502e1aff2c5460723f559354" translate="yes" xml:space="preserve">
          <source>String reassembles the URL into a valid URL string. The general form of the result is one of:</source>
          <target state="translated">String将URL重新组合成一个有效的URL字符串。结果的一般形式是:。</target>
        </trans-unit>
        <trans-unit id="1a1a1e5164ab79c22ae49942d67ef810bdba6ad9" translate="yes" xml:space="preserve">
          <source>String returns a descriptive name for the time zone information, corresponding to the name argument to LoadLocation or FixedZone.</source>
          <target state="translated">字符串返回时区信息的描述性名称,对应于LoadLocation或FixedZone的名称参数。</target>
        </trans-unit>
        <trans-unit id="aa4d82115db66e350e92f539c5427c79fdfb58ed" translate="yes" xml:space="preserve">
          <source>String returns a human-readable description of c. It is intended only for debugging. In particular, it is not suitable for use as input to a shell. The output of String may vary across Go releases.</source>
          <target state="translated">String 返回 c 的可读描述,它只用于调试。特别是,它不适合作为shell的输入。String 的输出在不同的 Go 版本中可能会有所不同。</target>
        </trans-unit>
        <trans-unit id="55bb95d4983983ad2bde74eafe604eb90028dc18" translate="yes" xml:space="preserve">
          <source>String returns a string in one of several forms:</source>
          <target state="translated">String以几种形式之一返回一个字符串。</target>
        </trans-unit>
        <trans-unit id="345f70fca28ee043619061f7f87c019dadbba1fa" translate="yes" xml:space="preserve">
          <source>String returns a string representation of p like &quot;(3,4)&quot;.</source>
          <target state="translated">String 返回 p 的字符串表示,如&quot;(3,4)&quot;。</target>
        </trans-unit>
        <trans-unit id="3448960ebb659e656c5021f0b36127dab5b9d619" translate="yes" xml:space="preserve">
          <source>String returns a string representation of r like &quot;(3,4)-(6,5)&quot;.</source>
          <target state="translated">String 返回 r 的字符串表示,如&quot;(3,4)-(6,5)&quot;。</target>
        </trans-unit>
        <trans-unit id="1b35bdca294966810231e9db40a5c473f629af73" translate="yes" xml:space="preserve">
          <source>String returns a string representation of the scope, for debugging.</source>
          <target state="translated">String 返回范围的字符串表示,用于调试。</target>
        </trans-unit>
        <trans-unit id="40800a9640894f3a3149f9e54d890572a4beda8c" translate="yes" xml:space="preserve">
          <source>String returns a string representation of the sequence r, roughly following the RFC 2253 Distinguished Names syntax.</source>
          <target state="translated">String返回序列r的字符串表示,大致遵循RFC 2253区分名语法。</target>
        </trans-unit>
        <trans-unit id="7a196811cde011797851e8bcd4ea585d5971e7d9" translate="yes" xml:space="preserve">
          <source>String returns a string representation of x in the form &quot;a/b&quot; (even if b == 1).</source>
          <target state="translated">String以 &quot;a/b &quot;的形式返回x的字符串表示(即使b ==1)。</target>
        </trans-unit>
        <trans-unit id="7b4474871a59eadc44e6ad3cc370b5d1fd6eabd1" translate="yes" xml:space="preserve">
          <source>String returns a string representing the duration in the form &quot;72h3m0.5s&quot;. Leading zero units are omitted. As a special case, durations less than one second format use a smaller unit (milli-, micro-, or nanoseconds) to ensure that the leading digit is non-zero. The zero duration formats as 0s.</source>
          <target state="translated">String 返回表示持续时间的字符串,格式为 &quot;72h3m0.5s&quot;。前导零单位被省略。作为一种特殊情况,小于一秒的持续时间格式使用较小的单位(毫秒、微秒或纳秒),以确保前导数字是非零。零持续时间格式为0s。</target>
        </trans-unit>
        <trans-unit id="f5e00dac202df16525dc65e74932811ab9752d4e" translate="yes" xml:space="preserve">
          <source>String returns a summary of the benchmark results. It follows the benchmark result line format from &lt;a href=&quot;https://golang.org/design/14313-benchmark-format&quot;&gt;https://golang.org/design/14313-benchmark-format&lt;/a&gt;, not including the benchmark name. Extra metrics override built-in metrics of the same name. String does not include allocs/op or B/op, since those are reported by MemString.</source>
          <target state="translated">String返回基准测试结果的摘要。它遵循&lt;a href=&quot;https://golang.org/design/14313-benchmark-format&quot;&gt;https://golang.org/design/14313-benchmark-format中&lt;/a&gt;的基准结果行格式，不包括基准名称。额外的指标会覆盖同名的内置指标。字符串不包括allocs / op或B / op，因为这些是由MemString报告的。</target>
        </trans-unit>
        <trans-unit id="a1320f96272e68242e45787bdcf443a45a5d4acb" translate="yes" xml:space="preserve">
          <source>String returns the CIDR notation of n like &quot;192.0.2.0/24&quot; or &quot;2001:db8::/48&quot; as defined in RFC 4632 and RFC 4291. If the mask is not in the canonical form, it returns the string which consists of an IP address, followed by a slash character and a mask expressed as hexadecimal form with no punctuation like &quot;198.51.100.0/c000ff00&quot;.</source>
          <target state="translated">String 返回 RFC 4632 和 RFC 4291 中定义的 n 的 CIDR 符号,如 &quot;192.0.2.0/24 &quot;或 &quot;2001:db8::/48&quot;。如果掩码不是规范形式,则返回由IP地址组成的字符串,后面是一个斜杠字符和一个以十六进制形式表示的掩码,没有标点符号,如 &quot;198.51.100.0/c000ff00&quot;。</target>
        </trans-unit>
        <trans-unit id="f55b73801df68c7614969aee1732afd9d5e38010" translate="yes" xml:space="preserve">
          <source>String returns the English name of the day (&quot;Sunday&quot;, &quot;Monday&quot;, ...).</source>
          <target state="translated">字符串返回当天的英文名称(&quot;Sunday&quot;,&quot;Monday&quot;,...)。</target>
        </trans-unit>
        <trans-unit id="ffc4d02cde72706d98e09a395ce956d9d89dd7b5" translate="yes" xml:space="preserve">
          <source>String returns the English name of the month (&quot;January&quot;, &quot;February&quot;, ...).</source>
          <target state="translated">字符串返回月份的英文名称(&quot;January&quot;,&quot;February&quot;,...)。</target>
        </trans-unit>
        <trans-unit id="d35cab9a7681d28fe5cfa98797f716ccf4a8148e" translate="yes" xml:space="preserve">
          <source>String returns the accumulated string.</source>
          <target state="translated">String 返回累积的字符串。</target>
        </trans-unit>
        <trans-unit id="6a561a9c0ca3a5d45a6220d79144ae4e4f68eaba" translate="yes" xml:space="preserve">
          <source>String returns the contents of the unread portion of the buffer as a string. If the Buffer is a nil pointer, it returns &quot;&amp;lt;nil&amp;gt;&quot;.</source>
          <target state="translated">String以字符串形式返回缓冲区未读部分的内容。如果Buffer是nil指针，则返回&amp;ldquo; &amp;lt;nil&amp;gt;&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="20281079c25e7469dba253811f0a64eb9af0ad50" translate="yes" xml:space="preserve">
          <source>String returns the decimal representation of x as generated by x.Text(10).</source>
          <target state="translated">String 返回 x.Text(10)所生成的 x 的十进制表示。</target>
        </trans-unit>
        <trans-unit id="c1f7f34151f59a07d632aef98f6cf3db75ca331f" translate="yes" xml:space="preserve">
          <source>String returns the encoded userinfo information in the standard form of &quot;username[:password]&quot;.</source>
          <target state="translated">字符串返回标准格式为 &quot;username[:password]&quot;的编码用户信息。</target>
        </trans-unit>
        <trans-unit id="c9f4b613c07a2c7f71577fe196567617d0abff90" translate="yes" xml:space="preserve">
          <source>String returns the hexadecimal form of m, with no punctuation.</source>
          <target state="translated">字符串返回m的十六进制形式,不含标点符号。</target>
        </trans-unit>
        <trans-unit id="a803d186b1c90a1c53ad70e26c40836efc312842" translate="yes" xml:space="preserve">
          <source>String returns the literal text of the number.</source>
          <target state="translated">字符串返回数字的文字。</target>
        </trans-unit>
        <trans-unit id="efd718d51f4b6dbacf2db82a320892ae4b63a670" translate="yes" xml:space="preserve">
          <source>String returns the name of k.</source>
          <target state="translated">字符串返回k的名称。</target>
        </trans-unit>
        <trans-unit id="750dd1515ee90a846665f6d5d112993b3669e476" translate="yes" xml:space="preserve">
          <source>String returns the name of the transaction isolation level.</source>
          <target state="translated">字符串返回事务隔离级别的名称。</target>
        </trans-unit>
        <trans-unit id="e794984ac30a476fc607ba49d30074600724b1fd" translate="yes" xml:space="preserve">
          <source>String returns the serialization of the cookie for use in a Cookie header (if only Name and Value are set) or a Set-Cookie response header (if other fields are set). If c is nil or c.Name is invalid, the empty string is returned.</source>
          <target state="translated">String返回Cookie的序列化,用于Cookie头(如果只设置了Name和Value)或Set-Cookie响应头(如果设置了其他字段)。如果c为nil或c.Name无效,将返回空字符串。</target>
        </trans-unit>
        <trans-unit id="fe713a69a5fd2ac5cb84c706517fb895d0d57913" translate="yes" xml:space="preserve">
          <source>String returns the source text used to compile the regular expression.</source>
          <target state="translated">字符串返回用于编译正则表达式的源文本。</target>
        </trans-unit>
        <trans-unit id="34bacca8ec4eef4ee78833a67f79a6eef6da5be0" translate="yes" xml:space="preserve">
          <source>String returns the string corresponding to the token tok. For operators, delimiters, and keywords the string is the actual token character sequence (e.g., for the token ADD, the string is &quot;+&quot;). For all other tokens the string corresponds to the token constant name (e.g. for the token IDENT, the string is &quot;IDENT&quot;).</source>
          <target state="translated">String 返回对应于标记标记的字符串。对于运算符、定界符和关键字,字符串是实际的标记字符序列(例如,对于标记ADD,字符串是 &quot;+&quot;)。对于所有其他标记,该字符串对应于标记常量名称(例如,对于标记IDENT,字符串为 &quot;IDENT&quot;)。</target>
        </trans-unit>
        <trans-unit id="2d88168daac6375a514f336433bd215fb612a6a9" translate="yes" xml:space="preserve">
          <source>String returns the string form of n, roughly following the RFC 2253 Distinguished Names syntax.</source>
          <target state="translated">String 返回 n 的字符串形式,大致遵循 RFC 2253 Distinguished Names 语法。</target>
        </trans-unit>
        <trans-unit id="65a433aa544a0c7b3431068c5cc7f107bc02e8c8" translate="yes" xml:space="preserve">
          <source>String returns the string form of the IP address ip. It returns one of 4 forms:</source>
          <target state="translated">String 返回 IP 地址的字符串形式。它返回4种形式之一。</target>
        </trans-unit>
        <trans-unit id="77e4b34a03bfe1d41ef0627a6a3eef76345118dd" translate="yes" xml:space="preserve">
          <source>String returns the string v's underlying value, as a string. String is a special case because of Go's String method convention. Unlike the other getters, it does not panic if v's Kind is not String. Instead, it returns a string of the form &quot;&amp;lt;T value&amp;gt;&quot; where T is v's type. The fmt package treats Values specially. It does not call their String method implicitly but instead prints the concrete values they hold.</source>
          <target state="translated">String以字符串形式返回字符串v的基础值。由于Go的String方法约定，String是一种特殊情况。与其他吸气剂不同，如果v的Kind不是String，它不会惊慌。而是返回形式为&amp;ldquo; &amp;lt;T value&amp;gt;&amp;rdquo;的字符串，其中T是v的类型。fmt包特别对待Values。它不会隐式调用其String方法，而是打印它们持有的具体值。</target>
        </trans-unit>
        <trans-unit id="da3ada59fed13cf9c42e28f35ce824b152ed6695" translate="yes" xml:space="preserve">
          <source>String returns the time formatted using the format string</source>
          <target state="translated">字符串返回使用字符串格式化的时间。</target>
        </trans-unit>
        <trans-unit id="7582d0695c8835ce2d6fd48b6b11691af0fd874b" translate="yes" xml:space="preserve">
          <source>String returns the value v as a string. String is a special case because of Go's String method convention. Unlike the other getters, it does not panic if v's Type is not TypeString. Instead, it returns a string of the form &quot;&amp;lt;T&amp;gt;&quot; or &quot;&amp;lt;T: V&amp;gt;&quot; where T is v's type and V is a string representation of v's value.</source>
          <target state="translated">字符串返回值v作为字符串。由于Go的String方法约定，String是一种特殊情况。与其他吸气剂不同，如果v的Type不是TypeString，它不会惊慌。而是返回格式为&amp;ldquo; &amp;lt;T&amp;gt;&amp;rdquo;或&amp;ldquo; &amp;lt;T：V&amp;gt;&amp;rdquo;的字符串，其中T是v的类型，V是v的值的字符串表示形式。</target>
        </trans-unit>
        <trans-unit id="b5780fb112a6b774b6985415c1ab7539f30b0d21" translate="yes" xml:space="preserve">
          <source>String values encode as JSON strings coerced to valid UTF-8, replacing invalid bytes with the Unicode replacement rune. So that the JSON will be safe to embed inside HTML &amp;lt;script&amp;gt; tags, the string is encoded using HTMLEscape, which replaces &quot;&amp;lt;&quot;, &quot;&amp;gt;&quot;, &quot;&amp;amp;&quot;, U+2028, and U+2029 are escaped to &quot;\u003c&quot;,&quot;\u003e&quot;, &quot;\u0026&quot;, &quot;\u2028&quot;, and &quot;\u2029&quot;. This replacement can be disabled when using an Encoder, by calling SetEscapeHTML(false).</source>
          <target state="translated">字符串值编码为强制转换为有效UTF-8的JSON字符串，用Unicode替换符文替换无效字节。为了使JSON可以安全地嵌入到HTML &amp;lt;script&amp;gt;标记中，该字符串使用HTMLEscape编码，替换为&amp;ldquo; &amp;lt;&amp;rdquo;，&amp;ldquo;&amp;gt;&amp;rdquo;，&amp;ldquo;＆&amp;rdquo;，U + 2028和U + 2029的HTMLEscape转义为&amp;ldquo; \ u003c&amp;rdquo;，&amp;ldquo; \ u003e&amp;rdquo;，&amp;ldquo; \ u0026&amp;rdquo;，&amp;ldquo; \ u2028&amp;rdquo;和&amp;ldquo; \ u2029&amp;rdquo;。使用编码器时，可以通过调用SetEscapeHTML（false）禁用此替换。</target>
        </trans-unit>
        <trans-unit id="86940bb85d221e97a38bc1e113fc6bce034c8750" translate="yes" xml:space="preserve">
          <source>StringBytePtr returns a pointer to a NUL-terminated array of bytes. If s contains a NUL byte this function panics instead of returning an error.</source>
          <target state="translated">StringBytePtr返回一个指向NUL结束的字节数组的指针。如果s中包含一个NUL字节,这个函数就会惊慌失措,而不是返回一个错误。</target>
        </trans-unit>
        <trans-unit id="c0623ccf68cc35082d287f89796544274ff86c91" translate="yes" xml:space="preserve">
          <source>StringByteSlice converts a string to a NUL-terminated []byte, If s contains a NUL byte this function panics instead of returning an error.</source>
          <target state="translated">StringByteSlice将一个字符串转换为一个NUL结尾的[]字节,如果s包含一个NUL字节,这个函数就会恐慌,而不是返回一个错误。</target>
        </trans-unit>
        <trans-unit id="6bf1e10cb60d4363fb37f7da731443afa2a654e2" translate="yes" xml:space="preserve">
          <source>StringHeader is the runtime representation of a string. It cannot be used safely or portably and its representation may change in a later release. Moreover, the Data field is not sufficient to guarantee the data it references will not be garbage collected, so programs must keep a separate, correctly typed pointer to the underlying data.</source>
          <target state="translated">StringHeader是字符串的运行时表示。它不能被安全地或可移植地使用,它的表示方式可能在以后的版本中发生变化。此外,Data字段不足以保证它所引用的数据不会被垃圾回收,所以程序必须保留一个单独的、正确类型的指针,指向底层数据。</target>
        </trans-unit>
        <trans-unit id="a97933503d7359e70c5bcc6d71f20f23e72ff484" translate="yes" xml:space="preserve">
          <source>StringNode holds a string constant. The value has been &quot;unquoted&quot;.</source>
          <target state="translated">StringNode持有一个字符串常量。该值已被 &quot;未引号&quot;。</target>
        </trans-unit>
        <trans-unit id="4e2dc56d882f4e247f4c8c91d09f7ca7c92151b0" translate="yes" xml:space="preserve">
          <source>StringSlice attaches the methods of Interface to []string, sorting in increasing order.</source>
          <target state="translated">StringSlice将Interface的方法附加到[]string上,按递增顺序排序。</target>
        </trans-unit>
        <trans-unit id="0ccdd69f6b44471ac8719f7a4d5092264f1d1540" translate="yes" xml:space="preserve">
          <source>StringSlicePtr converts a slice of strings to a slice of pointers to NUL-terminated byte arrays. If any string contains a NUL byte this function panics instead of returning an error.</source>
          <target state="translated">StringSlicePtr将一个字符串切片转换为一个指向NUL结尾的字节数组的切片。如果任何字符串包含一个NUL字节,这个函数就会惊慌失措,而不是返回一个错误。</target>
        </trans-unit>
        <trans-unit id="58cd2c4c0c64b3e8b63116e619c1216921aee8f5" translate="yes" xml:space="preserve">
          <source>StringTable is a COFF string table.</source>
          <target state="translated">StringTable是一个COFF字符串表。</target>
        </trans-unit>
        <trans-unit id="cf2c21cf4463c1c95fd9d9c1165bec97a40c80e4" translate="yes" xml:space="preserve">
          <source>StringVal returns the Go string value of x, which must be a String or an Unknown. If x is Unknown, the result is &quot;&quot;.</source>
          <target state="translated">StringVal 返回 x 的 Go 字符串值,它必须是一个字符串或一个 Unknown。如果x是未知值,结果是&quot;&quot;。</target>
        </trans-unit>
        <trans-unit id="d9073eff948f092d1e822cdc4b90545ac7f58c79" translate="yes" xml:space="preserve">
          <source>StringVar defines a string flag with specified name, default value, and usage string. The argument p points to a string variable in which to store the value of the flag.</source>
          <target state="translated">StringVar定义了一个字符串标志,具有指定的名称、默认值和用法字符串。参数p指向一个字符串变量,用来存储标志的值。</target>
        </trans-unit>
        <trans-unit id="8523e16e4f3d17cbbcc1796a5175f67569825d49" translate="yes" xml:space="preserve">
          <source>StringWriter is the interface that wraps the WriteString method.</source>
          <target state="translated">StringWriter是包装WriteString方法的接口。</target>
        </trans-unit>
        <trans-unit id="2968f2bfae46d2fc485efc7b71be92497e030111" translate="yes" xml:space="preserve">
          <source>Stringer</source>
          <target state="translated">Stringer</target>
        </trans-unit>
        <trans-unit id="58829a9ebd1b847fb0ad45cdde0851c334ed441d" translate="yes" xml:space="preserve">
          <source>Stringer is implemented by any value that has a String method, which defines the &amp;ldquo;native&amp;rdquo; format for that value. The String method is used to print values passed as an operand to any format that accepts a string or to an unformatted printer such as Print.</source>
          <target state="translated">Stringer由具有String方法的任何值实现，该方法定义该值的&amp;ldquo;本机&amp;rdquo;格式。String方法用于将作为操作数传递的值打印为接受字符串的任何格式，或打印到未格式化的打印机（如Print）。</target>
        </trans-unit>
        <trans-unit id="3816c4beac471c733eed1d91c213f8c2b6a29262" translate="yes" xml:space="preserve">
          <source>Strings</source>
          <target state="translated">Strings</target>
        </trans-unit>
        <trans-unit id="906a27ee40bd23a1553b39eb16be0c8e8ac3e949" translate="yes" xml:space="preserve">
          <source>Strings and slices of bytes are sent as an unsigned count followed by that many uninterpreted bytes of the value.</source>
          <target state="translated">字符串和字节片以无符号计数的形式发送,后面是该值的许多未解释的字节。</target>
        </trans-unit>
        <trans-unit id="faac2cc38ba743bbc17ba9acb7964aa6cee65d73" translate="yes" xml:space="preserve">
          <source>Strings must be UTF-8 encoded and may only contain Unicode code points U+0001 through U+00FF, due to limitations of the GZIP file format.</source>
          <target state="translated">由于GZIP文件格式的限制,字符串必须是UTF-8编码,并且只能包含U+0001到U+00FF的Unicode码点。</target>
        </trans-unit>
        <trans-unit id="f76921542e09ce2202753a5d0b5a9e24e8b8a263" translate="yes" xml:space="preserve">
          <source>Strings sorts a slice of strings in increasing order.</source>
          <target state="translated">Strings按照递增的顺序对字符串的一个片断进行排序。</target>
        </trans-unit>
        <trans-unit id="3d93c8594f1a8a4b01949156c04f8f3f3ae7fd2a" translate="yes" xml:space="preserve">
          <source>StringsAreSorted tests whether a slice of strings is sorted in increasing order.</source>
          <target state="translated">StringsAreSorted测试字符串片断是否按递增顺序排序。</target>
        </trans-unit>
        <trans-unit id="13ae2dda2de94ac9d40b6ba17fece2797835c04a" translate="yes" xml:space="preserve">
          <source>StripPrefix</source>
          <target state="translated">StripPrefix</target>
        </trans-unit>
        <trans-unit id="e0a5f88c187543f04de90ac6fd0379250c9778df" translate="yes" xml:space="preserve">
          <source>StripPrefix returns a handler that serves HTTP requests by removing the given prefix from the request URL's Path and invoking the handler h. StripPrefix handles a request for a path that doesn't begin with prefix by replying with an HTTP 404 not found error.</source>
          <target state="translated">StripPrefix返回一个处理程序,它通过从请求的URL的Path中删除给定的前缀并调用处理程序h来服务HTTP请求。 StripPrefix通过回复HTTP 404 not found错误来处理一个不是以前缀开始的路径请求。</target>
        </trans-unit>
        <trans-unit id="39170b61b74a11d6a192ff9863dfa73aaecba21c" translate="yes" xml:space="preserve">
          <source>Struct values are deeply equal if their corresponding fields, both exported and unexported, are deeply equal.</source>
          <target state="translated">如果其对应的字段,无论是导出的还是未导出的,结构值都是深度相等的。</target>
        </trans-unit>
        <trans-unit id="fb5bb421400cdac0575f807d47566c64d1f46c0f" translate="yes" xml:space="preserve">
          <source>Struct values encode as JSON objects. Each exported struct field becomes a member of the object, using the field name as the object key, unless the field is omitted for one of the reasons given below.</source>
          <target state="translated">Struct值编码为JSON对象。每个导出的结构体字段都会成为对象的成员,使用字段名作为对象键,除非该字段因下面给出的原因之一被省略。</target>
        </trans-unit>
        <trans-unit id="0b823e55e4d9782e91674576a6c2dba2dbfb679a" translate="yes" xml:space="preserve">
          <source>StructOf</source>
          <target state="translated">StructOf</target>
        </trans-unit>
        <trans-unit id="cbecd3176d1c216f7d05eaf053a4641373b34f6b" translate="yes" xml:space="preserve">
          <source>StructOf currently does not generate wrapper methods for embedded fields and panics if passed unexported StructFields. These limitations may be lifted in a future version.</source>
          <target state="translated">StructOf目前不为嵌入的字段生成封装方法,并且在传递未导出的StructFields时,会出现恐慌。这些限制可能会在未来的版本中被取消。</target>
        </trans-unit>
        <trans-unit id="e272272dfcabba6b0a57032693b1247f7d907d03" translate="yes" xml:space="preserve">
          <source>StructOf returns the struct type containing fields. The Offset and Index fields are ignored and computed as they would be by the compiler.</source>
          <target state="translated">StructOf返回包含字段的结构类型。Offset和Index字段会被忽略,并被编译器计算。</target>
        </trans-unit>
        <trans-unit id="642ea82e69d222e31d0a11979f4762edc849aa8f" translate="yes" xml:space="preserve">
          <source>StructTag</source>
          <target state="translated">StructTag</target>
        </trans-unit>
        <trans-unit id="666cf050832b24dac5a22e670aae0c296886ba23" translate="yes" xml:space="preserve">
          <source>StructTag.Lookup</source>
          <target state="translated">StructTag.Lookup</target>
        </trans-unit>
        <trans-unit id="5f4f3284caaeebe32585ec344848f50378d011bc" translate="yes" xml:space="preserve">
          <source>Structs are sent as a sequence of (field number, field value) pairs. The field value is sent using the standard gob encoding for its type, recursively. If a field has the zero value for its type (except for arrays; see above), it is omitted from the transmission. The field number is defined by the type of the encoded struct: the first field of the encoded type is field 0, the second is field 1, etc. When encoding a value, the field numbers are delta encoded for efficiency and the fields are always sent in order of increasing field number; the deltas are therefore unsigned. The initialization for the delta encoding sets the field number to -1, so an unsigned integer field 0 with value 7 is transmitted as unsigned delta = 1, unsigned value = 7 or (01 07). Finally, after all the fields have been sent a terminating mark denotes the end of the struct. That mark is a delta=0 value, which has representation (00).</source>
          <target state="translated">Structs以(字段号,字段值)对的序列形式发送。字段值使用其类型的标准gob编码递归发送。如果一个字段的类型值为零(数组除外,见上文),那么它将在传输中被省略。字段号由编码结构的类型定义:编码类型的第一个字段是字段0,第二个字段是字段1,等等。当对一个值进行编码时,为了提高效率,字段号进行了三角编码,并且字段总是按照字段号增加的顺序发送,因此三角编码是无符号的。delta编码的初始化将字段号设置为-1,所以一个值为7的无符号整数字段0被传送为unsigned delta=1,unsigned value=7或(01 07)。最后,在所有的字段被发送后,一个终止标记表示结构的结束。这个标记是一个delta=0的值,它的表示方法是(00)。</target>
        </trans-unit>
        <trans-unit id="7dc46671ebabbdf3c46aadccd97f8c490eefc52c" translate="yes" xml:space="preserve">
          <source>Structs, arrays and slices are also supported. Structs encode and decode only exported fields. Strings and arrays of bytes are supported with a special, efficient representation (see below). When a slice is decoded, if the existing slice has capacity the slice will be extended in place; if not, a new array is allocated. Regardless, the length of the resulting slice reports the number of elements decoded.</source>
          <target state="translated">还支持结构、数组和切片。Structs只对导出的字段进行编码和解码。字节组的字符串和数组以一种特殊的、有效的表示方式被支持(见下文)。当一个分片被解码时,如果现有的分片有容量,分片将被原地扩展;如果没有,则分配一个新的数组。无论怎样,产生的分片长度都会报告解码后的元素数。</target>
        </trans-unit>
        <trans-unit id="ad78f09f9c6b3087d8e72e4530ecc70c4956979a" translate="yes" xml:space="preserve">
          <source>Structure Preservation Property: &quot;... when a template author writes an HTML tag in a safe templating language, the browser will interpret the corresponding portion of the output as a tag regardless of the values of untrusted data, and similarly for other structures such as attribute boundaries and JS and CSS string boundaries.&quot;</source>
          <target state="translated">结构保存属性。&quot;.当模板作者用安全的模板语言编写HTML标签时,浏览器将把输出的相应部分解释为标签,而不管不受信任的数据的价值如何,同样,对于其他结构,如属性边界和JS和CSS字符串边界也是如此&quot;。</target>
        </trans-unit>
        <trans-unit id="a3c9ca613cd987d897ef5275ec8d3b6be7186d1f" translate="yes" xml:space="preserve">
          <source>Sub returns the difference of x, y and borrow: diff = x - y - borrow. The borrow input must be 0 or 1; otherwise the behavior is undefined. The borrowOut output is guaranteed to be 0 or 1.</source>
          <target state="translated">Sub 返回 x、y 和 borrow 的差值:diff=x-y-borrow。borrow输入必须为0或1,否则行为未定义。borrowOut输出保证为0或1。</target>
        </trans-unit>
        <trans-unit id="61c41cb657724bf35da0dad82b0d5dee3326e95d" translate="yes" xml:space="preserve">
          <source>Sub returns the duration t-u. If the result exceeds the maximum (or minimum) value that can be stored in a Duration, the maximum (or minimum) duration will be returned. To compute t-d for a duration d, use t.Add(-d).</source>
          <target state="translated">子返回持续时间t-u。如果结果超过了可以存储在Duration中的最大(或最小)值,将返回最大(或最小)持续时间。要计算持续时间d的t-d,使用t.Add(-d)。</target>
        </trans-unit>
        <trans-unit id="9a9cccdf849236c7b5afc32fedeaf0e730cf15fd" translate="yes" xml:space="preserve">
          <source>Sub returns the rectangle r translated by -p.</source>
          <target state="translated">子返回由-p转换的矩形r。</target>
        </trans-unit>
        <trans-unit id="c74b307e6862c7c0fdbabb48e4f241316eca6f53" translate="yes" xml:space="preserve">
          <source>Sub returns the vector p-q.</source>
          <target state="translated">子返回向量p-q。</target>
        </trans-unit>
        <trans-unit id="2660992e01b4593ff7e0d2ea96dbc6a6fcdbbc82" translate="yes" xml:space="preserve">
          <source>Sub sets z to the difference x-y and returns z.</source>
          <target state="translated">子将z设为x-y的差值,并返回z。</target>
        </trans-unit>
        <trans-unit id="07c120e2c4cb601d9bfe9da745d95ee84f5c8f23" translate="yes" xml:space="preserve">
          <source>Sub sets z to the rounded difference x-y and returns z. Precision, rounding, and accuracy reporting are as for Add. Sub panics with ErrNaN if x and y are infinities with equal signs. The value of z is undefined in that case.</source>
          <target state="translated">子将z设为四舍五入的差值x-y并返回z。精度、四舍五入和准确度报告与 Add 相同。如果x和y是等号的无穷大,Sub会用ErrNaN恐慌。在这种情况下,z 的值是未定义的。</target>
        </trans-unit>
        <trans-unit id="821524c66883b61b23da230e1f7ac6f247b61c28" translate="yes" xml:space="preserve">
          <source>Sub-repositories</source>
          <target state="translated">Sub-repositories</target>
        </trans-unit>
        <trans-unit id="027b254161eaa851d3de87e3e3811c330b4b1cfe" translate="yes" xml:space="preserve">
          <source>Sub32 returns the difference of x, y and borrow, diff = x - y - borrow. The borrow input must be 0 or 1; otherwise the behavior is undefined. The borrowOut output is guaranteed to be 0 or 1.</source>
          <target state="translated">Sub32 返回 x、y 和 borrow 的差值,diff=x-y-borrow。borrow输入必须为0或1,否则行为未定义。borrowOut输出保证为0或1。</target>
        </trans-unit>
        <trans-unit id="19abe5243ff65ef214d8cfd1ed7dd0d253eaaf1e" translate="yes" xml:space="preserve">
          <source>Sub64 returns the difference of x, y and borrow: diff = x - y - borrow. The borrow input must be 0 or 1; otherwise the behavior is undefined. The borrowOut output is guaranteed to be 0 or 1.</source>
          <target state="translated">Sub64 返回 x、y 和 borrow 的差值:diff=x-y-borrow。borrow输入必须为0或1,否则行为未定义。borrowOut输出保证为0或1。</target>
        </trans-unit>
        <trans-unit id="3fc6e21e27e1d98c4a46c59e21cbbbe634de9bcb" translate="yes" xml:space="preserve">
          <source>SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image.</source>
          <target state="translated">SubImage返回一个代表图像p通过r可见的部分的图像,返回的值与原始图像共享像素。</target>
        </trans-unit>
        <trans-unit id="19b094dbedb2add32a27c12c5c0b06b9d304fb7c" translate="yes" xml:space="preserve">
          <source>Subdirectories</source>
          <target state="translated">Subdirectories</target>
        </trans-unit>
        <trans-unit id="73a30231d9aabf0592839371dc3542545b7db703" translate="yes" xml:space="preserve">
          <source>SubexpIndex returns the index of the first subexpression with the given name, or -1 if there is no subexpression with that name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abb46f6f4b961e90d924a27858c117c84efd6aae" translate="yes" xml:space="preserve">
          <source>SubexpNames returns the names of the parenthesized subexpressions in this Regexp. The name for the first sub-expression is names[1], so that if m is a match slice, the name for m[i] is SubexpNames()[i]. Since the Regexp as a whole cannot be named, names[0] is always the empty string. The slice should not be modified.</source>
          <target state="translated">SubexpNames 返回该 Regexp 中括号内子表达式的名称。第一个子表达式的名称是names[1],因此如果m是一个匹配分片,那么m[i]的名称是SubexpNames()[i]。由于Regexp整体不能被命名,所以names[0]总是空字符串。该分片不应该被修改。</target>
        </trans-unit>
        <trans-unit id="c9c047b864469812cfb4b3b886d30b5376a4d0df" translate="yes" xml:space="preserve">
          <source>Subjects returns a list of the DER-encoded subjects of all of the certificates in the pool.</source>
          <target state="translated">Subjects 返回证书池中所有证书的 DER 编码主题的列表。</target>
        </trans-unit>
        <trans-unit id="91e8bbbf1ff4c8e821148581549206c9787e494e" translate="yes" xml:space="preserve">
          <source>Subtests and Sub-benchmarks</source>
          <target state="translated">小测试和次级基准</target>
        </trans-unit>
        <trans-unit id="05cc8697fcb7ccef149a7858e8bd798cb2cd774f" translate="yes" xml:space="preserve">
          <source>Subtests can also be used to control parallelism. A parent test will only complete once all of its subtests complete. In this example, all tests are run in parallel with each other, and only with each other, regardless of other top-level tests that may be defined:</source>
          <target state="translated">子测试也可以用来控制并行性。一个父测试只有在它的所有子测试完成后才会完成。在这个例子中,所有的测试都是相互并行运行的,而且只允许相互并行运行,而不考虑可能定义的其他顶层测试。</target>
        </trans-unit>
        <trans-unit id="bb672ca35fe1893eef6f12fcd0a8efff47a2478c" translate="yes" xml:space="preserve">
          <source>Success reports whether the program exited successfully, such as with exit status 0 on Unix.</source>
          <target state="translated">成功报告程序是否成功退出,如Unix上的退出状态为0。</target>
        </trans-unit>
        <trans-unit id="07eda2eb03735678c89d2490ea6410dd3ad1a43b" translate="yes" xml:space="preserve">
          <source>Such a file is usually paired with another file implementing the default functionality for other systems, which in this case would carry the constraint:</source>
          <target state="translated">这样的文件通常与另一个实现其他系统默认功能的文件配对,在这种情况下,它将携带约束条件。</target>
        </trans-unit>
        <trans-unit id="fc9ce14b28c6f2c3b72caf056ca604b2b96f7d2b" translate="yes" xml:space="preserve">
          <source>Sum</source>
          <target state="translated">Sum</target>
        </trans-unit>
        <trans-unit id="1037d5e9f233e3f6a6a25104581ccd4bbd6ac1c7" translate="yes" xml:space="preserve">
          <source>Sum returns the MD5 checksum of the data.</source>
          <target state="translated">Sum返回数据的MD5校验和。</target>
        </trans-unit>
        <trans-unit id="d8eeaf2ada0e780d70b60f2e9edbd46ef59d4a13" translate="yes" xml:space="preserve">
          <source>Sum returns the SHA-1 checksum of the data.</source>
          <target state="translated">Sum返回数据的SHA-1校验和。</target>
        </trans-unit>
        <trans-unit id="0dca98b14fcbfeb34897e7396c1a6dfa98d521b4" translate="yes" xml:space="preserve">
          <source>Sum224 returns the SHA224 checksum of the data.</source>
          <target state="translated">Sum224返回数据的SHA224校验和。</target>
        </trans-unit>
        <trans-unit id="ba05916088015c0f1b00b88d9415ebfa726370d8" translate="yes" xml:space="preserve">
          <source>Sum256</source>
          <target state="translated">Sum256</target>
        </trans-unit>
        <trans-unit id="087b1fabd67b489187e993cab88dfd4147ea385d" translate="yes" xml:space="preserve">
          <source>Sum256 returns the SHA256 checksum of the data.</source>
          <target state="translated">Sum256返回数据的SHA256校验和。</target>
        </trans-unit>
        <trans-unit id="6bd95a96de2d8140b4ada3f2d7b194594facee01" translate="yes" xml:space="preserve">
          <source>Sum384 returns the SHA384 checksum of the data.</source>
          <target state="translated">Sum384返回数据的SHA384校验和。</target>
        </trans-unit>
        <trans-unit id="bf1f6e0b5ced478fca66b19297a0e98baeedd390" translate="yes" xml:space="preserve">
          <source>Sum512 returns the SHA512 checksum of the data.</source>
          <target state="translated">Sum512返回数据的SHA512校验和。</target>
        </trans-unit>
        <trans-unit id="3357361c0e72e316aab24916d39ed7d14bdb335d" translate="yes" xml:space="preserve">
          <source>Sum512_224 returns the Sum512/224 checksum of the data.</source>
          <target state="translated">Sum512_224 返回数据的Sum512/224校验和。</target>
        </trans-unit>
        <trans-unit id="ff71eecde6b5c686475ebd821438cf7dd50ffe32" translate="yes" xml:space="preserve">
          <source>Sum512_256 returns the Sum512/256 checksum of the data.</source>
          <target state="translated">Sum512_256 返回数据的Sum512/256校验和。</target>
        </trans-unit>
        <trans-unit id="4442b8443612835fd9bd367eb3496bb5cfec606a" translate="yes" xml:space="preserve">
          <source>Support for tracing tests and benchmarks built with the standard testing package is built into `go test`. For example, the following command runs the test in the current directory and writes the trace file (trace.out).</source>
          <target state="translated">`go test`中内置了对跟踪测试和用标准测试包建立的基准的支持。例如,以下命令在当前目录下运行测试,并写入跟踪文件(trace.out)。</target>
        </trans-unit>
        <trans-unit id="05492c0a57ea2d63ba2b476c7222b6bcdddbb676" translate="yes" xml:space="preserve">
          <source>Supported architectures for compiler &quot;gc&quot;: &quot;386&quot;, &quot;arm&quot;, &quot;arm64&quot;, &quot;amd64&quot;, &quot;amd64p32&quot;, &quot;mips&quot;, &quot;mipsle&quot;, &quot;mips64&quot;, &quot;mips64le&quot;, &quot;ppc64&quot;, &quot;ppc64le&quot;, &quot;riscv64&quot;, &quot;s390x&quot;, &quot;sparc64&quot;, &quot;wasm&quot;.</source>
          <target state="translated">编译器 &quot;gc &quot;所支持的架构:&quot;386&quot;、&quot;arm&quot;、&quot;arm64&quot;、&quot;amd64&quot;、&quot;amd64p32&quot;、&quot;mips&quot;、&quot;mipsle&quot;、&quot;mips64&quot;、&quot;mips64le&quot;。&quot;386&quot;、&quot;arm&quot;、&quot;arm64&quot;、&quot;amd64&quot;、&quot;amd64p32&quot;、&quot;mips&quot;、&quot;mipsle&quot;、&quot;mips64&quot;、&quot;mips64le&quot;、&quot;pc64&quot;、&quot;pc64le&quot;、&quot;riscv64&quot;、&quot;s390x&quot;、&quot;sparc64&quot;、&quot;wasm&quot;。</target>
        </trans-unit>
        <trans-unit id="2bd4d45ed11fa0b050a34198a5d7a561630a107e" translate="yes" xml:space="preserve">
          <source>SupportsCertificate returns nil if the provided certificate is supported by the client that sent the ClientHello. Otherwise, it returns an error describing the reason for the incompatibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91f216722ea67774c646ac48a3a778f2005845b0" translate="yes" xml:space="preserve">
          <source>SupportsCertificate returns nil if the provided certificate is supported by the server that sent the CertificateRequest. Otherwise, it returns an error describing the reason for the incompatibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8b59b633a995b7dd6a0e84deb15f21ce9bf242a" translate="yes" xml:space="preserve">
          <source>SwapInt32 atomically stores new into *addr and returns the previous *addr value.</source>
          <target state="translated">SwapInt32原子性地将new存储到*addr中,并返回之前的*addr值。</target>
        </trans-unit>
        <trans-unit id="96490065dc4e2e645c8a89627e673eb95f4aaa28" translate="yes" xml:space="preserve">
          <source>SwapInt64 atomically stores new into *addr and returns the previous *addr value.</source>
          <target state="translated">SwapInt64原子性地将new存储到*addr中,并返回之前的*addr值。</target>
        </trans-unit>
        <trans-unit id="da115593d3ae663bb42ff237dd86576dfdedf6ad" translate="yes" xml:space="preserve">
          <source>SwapPointer atomically stores new into *addr and returns the previous *addr value.</source>
          <target state="translated">SwapPointer原子性地将new存储到*addr中,并返回之前的*addr值。</target>
        </trans-unit>
        <trans-unit id="0c0f6214095877962c7da65a2c141bf3b6cbecc8" translate="yes" xml:space="preserve">
          <source>SwapUint32 atomically stores new into *addr and returns the previous *addr value.</source>
          <target state="translated">SwapUint32原子性地将new存储到*addr中,并返回之前的*addr值。</target>
        </trans-unit>
        <trans-unit id="899e9c7e854930b5577e53934a16009339f15457" translate="yes" xml:space="preserve">
          <source>SwapUint64 atomically stores new into *addr and returns the previous *addr value.</source>
          <target state="translated">SwapUint64原子性地将new存储到*addr中,并返回之前的*addr值。</target>
        </trans-unit>
        <trans-unit id="18cdfb91a16523313759a1c794de0eb9712ac2b2" translate="yes" xml:space="preserve">
          <source>SwapUintptr atomically stores new into *addr and returns the previous *addr value.</source>
          <target state="translated">SwapUintptr原子性地将new存储到*addr中,并返回之前的*addr值。</target>
        </trans-unit>
        <trans-unit id="5c2b73e847c3ed8be17c9afe2788c2fedb5bc635" translate="yes" xml:space="preserve">
          <source>Swapper panics if the provided interface is not a slice.</source>
          <target state="translated">如果提供的接口不是切片,Swapper就会恐慌。</target>
        </trans-unit>
        <trans-unit id="0485bba36620f415adb72d21b9eac171cd9aadf1" translate="yes" xml:space="preserve">
          <source>Swapper returns a function that swaps the elements in the provided slice.</source>
          <target state="translated">Swapper返回一个交换所提供的片中元素的函数。</target>
        </trans-unit>
        <trans-unit id="baf85dad7e64d73c6dc3f04eb46803a601b907a7" translate="yes" xml:space="preserve">
          <source>SymByAddr returns the text, data, or bss symbol starting at the given address.</source>
          <target state="translated">SymByAddr返回从给定地址开始的文本、数据或bss符号。</target>
        </trans-unit>
        <trans-unit id="e6a580ed077335806f8a72f4c91bc2108aa36618" translate="yes" xml:space="preserve">
          <source>Symbol Binding - ELFNN_ST_BIND - st_info</source>
          <target state="translated">符号绑定-ELFNN_ST_BIND-st_info</target>
        </trans-unit>
        <trans-unit id="998290f1606e44ec99b08646525255987ca67dd9" translate="yes" xml:space="preserve">
          <source>Symbol is similar to COFFSymbol with Name field replaced by Go string. Symbol also does not have NumberOfAuxSymbols.</source>
          <target state="translated">Symbol类似于COFFSymbol,但Name字段被Go字符串取代。符号也没有NumberOfAuxSymbols。</target>
        </trans-unit>
        <trans-unit id="e746caac18fb8c9ece11fba1c3858dd24402cee1" translate="yes" xml:space="preserve">
          <source>Symbol looks up the program counters listed in the request, responding with a table mapping program counters to function names. The package initialization registers it as /debug/pprof/symbol.</source>
          <target state="translated">Symbol查找请求中列出的程序计数器,用一个程序计数器与函数名的映射表来回应。包的初始化将其注册为/debug/pprof/symbol。</target>
        </trans-unit>
        <trans-unit id="9183912a1c8677ccbfeafe4a95bb81fdaf9d6c67" translate="yes" xml:space="preserve">
          <source>Symbol type - ELFNN_ST_TYPE - st_info</source>
          <target state="translated">符号类型-ELFNN_ST_TYPE-st_info</target>
        </trans-unit>
        <trans-unit id="300ae1bf65f5418188fead7a4f6227a1a8cb17ab" translate="yes" xml:space="preserve">
          <source>Symbol visibility - ELFNN_ST_VISIBILITY - st_other</source>
          <target state="translated">符号可见性-ELFNN_ST_VISIBILITY-st_other</target>
        </trans-unit>
        <trans-unit id="e0dd57ca387a759e2499962eadf5f79f0eaa8ee2" translate="yes" xml:space="preserve">
          <source>Symbols returns the symbol table for f.</source>
          <target state="translated">符号返回f的符号表。</target>
        </trans-unit>
        <trans-unit id="40ab78f946263d95260d4886b240965a4da98f61" translate="yes" xml:space="preserve">
          <source>Symbols returns the symbol table for f. The symbols will be listed in the order they appear in f.</source>
          <target state="translated">符号表 返回f的符号表,符号将按照它们在f中出现的顺序排列。</target>
        </trans-unit>
        <trans-unit id="2377d81c04be24a887c20fd3bd69bc0f09f37db5" translate="yes" xml:space="preserve">
          <source>Symlink creates newname as a symbolic link to oldname. If there is an error, it will be of type *LinkError.</source>
          <target state="translated">Symlink创建newname作为一个符号链接到oldname。如果出现错误,它的类型将是*LinkError。</target>
        </trans-unit>
        <trans-unit id="0aceec11151392e3e912ee288231038c58c328b4" translate="yes" xml:space="preserve">
          <source>Sync commits the current contents of the file to stable storage. Typically, this means flushing the file system's in-memory copy of recently written data to disk.</source>
          <target state="translated">同步将文件的当前内容提交到稳定的存储中。通常情况下,这意味着将文件系统的内存中最近写入的数据副本刷新到磁盘。</target>
        </trans-unit>
        <trans-unit id="e15b4a502540aca9807844244039f56ac0ff96c5" translate="yes" xml:space="preserve">
          <source>Synchronous signals are signals triggered by errors in program execution: SIGBUS, SIGFPE, and SIGSEGV. These are only considered synchronous when caused by program execution, not when sent using os.Process.Kill or the kill program or some similar mechanism. In general, except as discussed below, Go programs will convert a synchronous signal into a run-time panic.</source>
          <target state="translated">同步信号是由程序执行中的错误所触发的信号。SIGBUS、SIGFPE和SIGSEGV。这些信号只有在程序执行引起的时候才会被认为是同步信号,而不是使用os.Process.Kill或杀程序或一些类似的机制发送的信号。一般来说,除了下面的讨论,Go程序会将同步信号转化为运行时的恐慌。</target>
        </trans-unit>
        <trans-unit id="36c0630a340d2960affa1c4d2360b0e2c06793fb" translate="yes" xml:space="preserve">
          <source>Synopsis</source>
          <target state="translated">Synopsis</target>
        </trans-unit>
        <trans-unit id="14251985329004226786245f7238c38c1ab2c9f9" translate="yes" xml:space="preserve">
          <source>Synopsis returns a cleaned version of the first sentence in s. That sentence ends after the first period followed by space and not preceded by exactly one uppercase letter. The result string has no \n, \r, or \t characters and uses only single spaces between words. If s starts with any of the IllegalPrefixes, the result is the empty string.</source>
          <target state="translated">Synopsis返回s中第一句话的清洁版本。该句子在第一个句号后用空格结束,并且前面没有一个大写字母。结果字符串中没有\n,\r,或\t字符,并且只在单词之间使用单个空格。如果s以任何IllegalPrefixes开头,结果就是空字符串。</target>
        </trans-unit>
        <trans-unit id="17c7ba7676ad1ad6dd1c4e6b997adcae910262c9" translate="yes" xml:space="preserve">
          <source>Syntax</source>
          <target state="translated">Syntax</target>
        </trans-unit>
        <trans-unit id="94881bde696c81108db9e992f3357d3d70383bb4" translate="yes" xml:space="preserve">
          <source>Sys returns system-dependent exit information about the process. Convert it to the appropriate underlying type, such as syscall.WaitStatus on Unix, to access its contents.</source>
          <target state="translated">Sys返回与系统相关的进程的退出信息,将其转换为适当的底层类型,如Unix上的syscall.WaitStatus,以访问其内容。将其转换为适当的底层类型,如Unix上的syscall.WaitStatus,以访问其内容。</target>
        </trans-unit>
        <trans-unit id="ce82965024d89928bce7d20275a546fd15078072" translate="yes" xml:space="preserve">
          <source>SysProcIDMap holds Container ID to Host ID mappings used for User Namespaces in Linux. See user_namespaces(7).</source>
          <target state="translated">SysProcIDMap 保存了 Linux 中用于用户命名空间的容器 ID 到主机 ID 的映射。参见 user_namespaces(7)。</target>
        </trans-unit>
        <trans-unit id="8ffbaaa01464f1d0b5846f06e745037abe0d8cb8" translate="yes" xml:space="preserve">
          <source>SysUsage returns system-dependent resource usage information about the exited process. Convert it to the appropriate underlying type, such as *syscall.Rusage on Unix, to access its contents. (On Unix, *syscall.Rusage matches struct rusage as defined in the getrusage(2) manual page.)</source>
          <target state="translated">SysUsage 返回与系统相关的关于退出进程的资源使用信息。将其转换为适当的底层类型,例如 Unix 上的 *syscall.Rusage,以访问其内容。(在 Unix 上,*syscall.Rusage 与 getrusage(2)手册页面中定义的 rusage 结构相匹配。)</target>
        </trans-unit>
        <trans-unit id="e293cc54d1f1c47b6fdb1085033440055e2faa2b" translate="yes" xml:space="preserve">
          <source>SyscallConn returns a raw file. This implements the syscall.Conn interface.</source>
          <target state="translated">SyscallConn返回一个原始文件。这实现了syscall.Conn接口。</target>
        </trans-unit>
        <trans-unit id="93d325a9a596e81112db1a88f6cf17706c8e91ec" translate="yes" xml:space="preserve">
          <source>SyscallConn returns a raw network connection. This implements the syscall.Conn interface.</source>
          <target state="translated">SyscallConn返回一个原始网络连接。这实现了syscall.Conn接口。</target>
        </trans-unit>
        <trans-unit id="aa615b3f3de4dc13fa4173050b52db98916467bd" translate="yes" xml:space="preserve">
          <source>SyscallError records an error from a specific system call.</source>
          <target state="translated">SyscallError记录了一个特定系统调用的错误。</target>
        </trans-unit>
        <trans-unit id="de57d6136b78d4b44c51a17ce5f47f730586e6a6" translate="yes" xml:space="preserve">
          <source>SystemCertPool returns a copy of the system cert pool.</source>
          <target state="translated">SystemCertPool 返回系统证书池的副本。</target>
        </trans-unit>
        <trans-unit id="5bc8f6a9ab808b5aa99fa9f5b51afdf83e241a9c" translate="yes" xml:space="preserve">
          <source>SystemRootsError results when we fail to load the system root certificates.</source>
          <target state="translated">当我们未能加载系统根证书时,会产生SystemRootsError。</target>
        </trans-unit>
        <trans-unit id="326b735dbfcf185462598a45a443d5db5a2c18cd" translate="yes" xml:space="preserve">
          <source>SystemTime returns the system CPU time of the exited process and its children.</source>
          <target state="translated">SystemTime 返回退出的进程及其子进程的系统 CPU 时间。</target>
        </trans-unit>
        <trans-unit id="45c7796c7458dc5d46d3bad14455a8811762231d" translate="yes" xml:space="preserve">
          <source>T is a type passed to Test functions to manage test state and support formatted test logs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd9dc41e485032cb18e9d13d513ba555be1b33c2" translate="yes" xml:space="preserve">
          <source>T is a type passed to Test functions to manage test state and support formatted test logs. Logs are accumulated during execution and dumped to standard output when done.</source>
          <target state="translated">T是传递给测试函数的一个类型,用于管理测试状态,支持格式化的测试日志。在执行过程中积累日志,完成后转储到标准输出。</target>
        </trans-unit>
        <trans-unit id="d71f7f3fa4e9f0ba0065f39db28f69d358c4b941" translate="yes" xml:space="preserve">
          <source>TB is the interface common to T and B.</source>
          <target state="translated">TB是T和B共用的接口。</target>
        </trans-unit>
        <trans-unit id="671a2dd281c27979f8b5f140c5da50e321430a64" translate="yes" xml:space="preserve">
          <source>TBSCertificateList represents the ASN.1 structure of the same name. See RFC 5280, section 5.1.</source>
          <target state="translated">TBSCertificateList表示同名的ASN.1结构。参见RFC 5280,5.1节。</target>
        </trans-unit>
        <trans-unit id="2984ada09d0c49745872575be1763fe615cf3de7" translate="yes" xml:space="preserve">
          <source>TCPAddr represents the address of a TCP end point.</source>
          <target state="translated">TCPAddr表示TCP端点的地址。</target>
        </trans-unit>
        <trans-unit id="623c2c8aa88d77780fe4e0bcba75694b81bcf2ad" translate="yes" xml:space="preserve">
          <source>TCPConn is an implementation of the Conn interface for TCP network connections.</source>
          <target state="translated">TCPConn是Conn接口的一个实现,用于TCP网络连接。</target>
        </trans-unit>
        <trans-unit id="1bbfc48812fe8aa4d93c086976c0d5cdc5424e43" translate="yes" xml:space="preserve">
          <source>TCPListener is a TCP network listener. Clients should typically use variables of type Listener instead of assuming TCP.</source>
          <target state="translated">TCPListener是一个TCP网络监听器。客户端通常应该使用Listener类型的变量,而不是假设TCP。</target>
        </trans-unit>
        <trans-unit id="c0df2a7fffd9d8cf03b29589d0b72452730e5dd3" translate="yes" xml:space="preserve">
          <source>TLS 1.3 is available on an opt-out basis in Go 1.13. To disable it, set the GODEBUG environment variable (comma-separated key=value options) such that it includes &quot;tls13=0&quot;.</source>
          <target state="translated">TLS 1.3在Go 1.13中是可以选择不使用的。要禁用它,可以设置GODEBUG环境变量(以逗号分隔的key=value options),使其包含 &quot;tls13=0&quot;。</target>
        </trans-unit>
        <trans-unit id="daa5896e5821b88d0d9b26d2bc85c2d021b848c8" translate="yes" xml:space="preserve">
          <source>TLSConnectionState returns the client's TLS connection state. The return values are their zero values if StartTLS did not succeed.</source>
          <target state="translated">TLSConnectionState返回客户端的TLS连接状态。如果StartTLS没有成功,则返回值为其零值。</target>
        </trans-unit>
        <trans-unit id="ed012370216d609d48fc2b869f8a011268923cad" translate="yes" xml:space="preserve">
          <source>TODO returns a non-nil, empty Context. Code should use context.TODO when it's unclear which Context to use or it is not yet available (because the surrounding function has not yet been extended to accept a Context parameter).</source>
          <target state="translated">TODO返回一个非零的空Context。当不清楚要使用哪个Context或者它还不可用的时候(因为周围的函数还没有被扩展到接受Context参数),代码应该使用context.TODO。</target>
        </trans-unit>
        <trans-unit id="1f541ebdf888dacb11e44ff51c13846474081ba9" translate="yes" xml:space="preserve">
          <source>Tab-terminated cells in contiguous lines constitute a column. The Writer inserts padding as needed to make all cells in a column have the same width, effectively aligning the columns. It assumes that all characters have the same width, except for tabs for which a tabwidth must be specified. Column cells must be tab-terminated, not tab-separated: non-tab terminated trailing text at the end of a line forms a cell but that cell is not part of an aligned column. For instance, in this example (where | stands for a horizontal tab):</source>
          <target state="translated">以制表符结束的连续行单元格构成一列。Writer根据需要插入padding,使列中的所有单元格具有相同的宽度,有效地对齐列。它假定所有的字符都有相同的宽度,但制表符除外,制表符的宽度必须指定。列单元格必须以制表符结尾,而不是以制表符分隔:行末非制表符结尾的尾部文本形成一个单元格,但该单元格不是对齐列的一部分。例如,在这个例子中(其中|代表水平制表符)。</target>
        </trans-unit>
        <trans-unit id="9baa6d565b56c1e4861e3df81a8fd8df65d699d4" translate="yes" xml:space="preserve">
          <source>Table 1 in [2] suggests maximum numbers of primes for a given size.</source>
          <target state="translated">表1在[2]中提出了给定大小的最大质数。</target>
        </trans-unit>
        <trans-unit id="ba3ee22bd3b233bdb404d63bfe71ba0cb11ae0a4" translate="yes" xml:space="preserve">
          <source>Table is a 256-word table representing the polynomial for efficient processing.</source>
          <target state="translated">表是一个256字的表,表示多项式,以便高效处理。</target>
        </trans-unit>
        <trans-unit id="599b448991ae5ae6d130b6356ce6b00630c5cefb" translate="yes" xml:space="preserve">
          <source>Table represents a Go symbol table. It stores all of the symbols decoded from the program and provides methods to translate between symbols, names, and addresses.</source>
          <target state="translated">表表示一个围棋符号表。它存储了所有从程序中解码的符号,并提供了在符号、名称和地址之间进行翻译的方法。</target>
        </trans-unit>
        <trans-unit id="bfc4ba347929d28c193a400550bae587488f16cd" translate="yes" xml:space="preserve">
          <source>Tag returns the i'th field tag for 0 &amp;lt;= i &amp;lt; NumFields().</source>
          <target state="translated">标签返回第i个字段标签，其值为0 &amp;lt;= i &amp;lt;NumFields（）。</target>
        </trans-unit>
        <trans-unit id="7a39b84c91d8c550355f46b331fdfde2ffca5ba7" translate="yes" xml:space="preserve">
          <source>Tag sizes between 12 and 16 bytes are allowed.</source>
          <target state="translated">标签大小允许在12到16字节之间。</target>
        </trans-unit>
        <trans-unit id="9dda0ce21be12978cbb42d63ed48bd36a71555e8" translate="yes" xml:space="preserve">
          <source>Taken from &lt;a href=&quot;https://www.iana.org/assignments/tls-parameters/tls-parameters.xml&quot;&gt;https://www.iana.org/assignments/tls-parameters/tls-parameters.xml&lt;/a&gt;</source>
          <target state="translated">取自&lt;a href=&quot;https://www.iana.org/assignments/tls-parameters/tls-parameters.xml&quot;&gt;https://www.iana.org/assignments/tls-parameters/tls-parameters.xml&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="133552ebfbcce8310f8920695422699d5256bac9" translate="yes" xml:space="preserve">
          <source>Tan</source>
          <target state="translated">Tan</target>
        </trans-unit>
        <trans-unit id="c442668b04fe0d2fb49d4d83b1b51198b583f812" translate="yes" xml:space="preserve">
          <source>Tan returns the tangent of the radian argument x.</source>
          <target state="translated">Tan 返回弧度参数 x 的正切值。</target>
        </trans-unit>
        <trans-unit id="9f8f5243ed4843c5154158c2ff20cd9a586739e0" translate="yes" xml:space="preserve">
          <source>Tan returns the tangent of x.</source>
          <target state="translated">Tan返回x的切线。</target>
        </trans-unit>
        <trans-unit id="19bff9fbbbadd7b339e0ee0ae1715d62fea9cae0" translate="yes" xml:space="preserve">
          <source>Tanh</source>
          <target state="translated">Tanh</target>
        </trans-unit>
        <trans-unit id="dc8ae90d27ce708b07a5ac10906ccc3ed208c4a5" translate="yes" xml:space="preserve">
          <source>Tanh returns the hyperbolic tangent of x.</source>
          <target state="translated">Tanh返回x的双曲正切。</target>
        </trans-unit>
        <trans-unit id="6f0a22a02d454a68d024fa67fa9340156799d88b" translate="yes" xml:space="preserve">
          <source>Tape archives (tar) are a file format for storing a sequence of files that can be read and written in a streaming manner. This package aims to cover most variations of the format, including those produced by GNU and BSD tar tools.</source>
          <target state="translated">磁带档案(tar)是一种文件格式,用于存储一系列可以以流式方式读写的文件。本软件包旨在涵盖该格式的大多数变化,包括GNU和BSD tar工具产生的那些。</target>
        </trans-unit>
        <trans-unit id="f11f02db734667c97fad6ffb5c8e393a00b87399" translate="yes" xml:space="preserve">
          <source>Task is a data type for tracing a user-defined, logical operation.</source>
          <target state="translated">任务是一种数据类型,用于跟踪用户定义的逻辑操作。</target>
        </trans-unit>
        <trans-unit id="a9e55d223a3d4713691d397b40624caef60d5252" translate="yes" xml:space="preserve">
          <source>TeeReader</source>
          <target state="translated">TeeReader</target>
        </trans-unit>
        <trans-unit id="c3ce03ea658d6ce846ba37ed8673f608fd0ba578" translate="yes" xml:space="preserve">
          <source>TeeReader returns a Reader that writes to w what it reads from r. All reads from r performed through it are matched with corresponding writes to w. There is no internal buffering - the write must complete before the read completes. Any error encountered while writing is reported as a read error.</source>
          <target state="translated">TeeReader返回一个Reader,它将从r中读取的内容写入w中。写入时遇到的任何错误都会被报告为读取错误。</target>
        </trans-unit>
        <trans-unit id="d5aae156b3babace54749a4ff370cbf166528804" translate="yes" xml:space="preserve">
          <source>Tell returns the current position in the line table.</source>
          <target state="translated">Tell返回当前在行表中的位置。</target>
        </trans-unit>
        <trans-unit id="243b371792899304742de51767e5e63dc878faba" translate="yes" xml:space="preserve">
          <source>TempDir</source>
          <target state="translated">TempDir</target>
        </trans-unit>
        <trans-unit id="4e9f8298798f58791af33409f9e40b224764dd8a" translate="yes" xml:space="preserve">
          <source>TempDir (Suffix)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99e70473aa5b1571f3701ff2584745139273d8ab" translate="yes" xml:space="preserve">
          <source>TempDir creates a new temporary directory in the directory dir with a name beginning with prefix and returns the path of the new directory. If dir is the empty string, TempDir uses the default directory for temporary files (see os.TempDir). Multiple programs calling TempDir simultaneously will not choose the same directory. It is the caller's responsibility to remove the directory when no longer needed.</source>
          <target state="translated">TempDir 在目录 dir 中创建一个新的临时目录,名称以前缀开头,并返回新目录的路径。如果 dir 是空字符串,TempDir 会使用默认的临时文件目录(参见 os.TempDir)。多个程序同时调用 TempDir 不会选择同一个目录。调用者有责任在不再需要时删除该目录。</target>
        </trans-unit>
        <trans-unit id="cc071fc9ff710ae41b76bf6f9ab98edd65deeafe" translate="yes" xml:space="preserve">
          <source>TempDir creates a new temporary directory in the directory dir. The directory name is generated by taking pattern and applying a random string to the end. If pattern includes a &quot;*&quot;, the random string replaces the last &quot;*&quot;. TempDir returns the name of the new directory. If dir is the empty string, TempDir uses the default directory for temporary files (see os.TempDir). Multiple programs calling TempDir simultaneously will not choose the same directory. It is the caller's responsibility to remove the directory when no longer needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b913aacfee5a65e416908a68d2ac6cb82c0ef71c" translate="yes" xml:space="preserve">
          <source>TempDir returns a temporary directory for the test to use. The directory is automatically removed by Cleanup when the test and all its subtests complete. Each subsequent call to t.TempDir returns a unique directory; if the directory creation fails, TempDir terminates the test by calling Fatal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="275584eb4c05e91a05657287b9e5e68b19aedf60" translate="yes" xml:space="preserve">
          <source>TempDir returns the default directory to use for temporary files.</source>
          <target state="translated">TempDir 返回用于临时文件的默认目录。</target>
        </trans-unit>
        <trans-unit id="d7cc1fbb5a71addb97fa8de33ce419d1f28b35a1" translate="yes" xml:space="preserve">
          <source>TempFile</source>
          <target state="translated">TempFile</target>
        </trans-unit>
        <trans-unit id="ba14fe997bc74680fd4532ceead516a44881c27a" translate="yes" xml:space="preserve">
          <source>TempFile (Suffix)</source>
          <target state="translated">临时文件(后缀)</target>
        </trans-unit>
        <trans-unit id="db71768a24bbe351f05252c3b917cc624a9ef1b3" translate="yes" xml:space="preserve">
          <source>TempFile creates a new temporary file in the directory dir, opens the file for reading and writing, and returns the resulting *os.File. The filename is generated by taking pattern and adding a random string to the end. If pattern includes a &quot;*&quot;, the random string replaces the last &quot;*&quot;. If dir is the empty string, TempFile uses the default directory for temporary files (see os.TempDir). Multiple programs calling TempFile simultaneously will not choose the same file. The caller can use f.Name() to find the pathname of the file. It is the caller's responsibility to remove the file when no longer needed.</source>
          <target state="translated">TempFile在目录dir中创建一个新的临时文件,打开该文件进行读写,并返回生成的*os.File。文件名是通过取pattern并在最后添加一个随机字符串来生成的。如果pattern中包含 &quot;*&quot;,则随机字符串替换最后的 &quot;*&quot;。如果 dir 是空字符串,TempFile 会使用默认的临时文件目录 (参见 os.TempDir)。多个程序同时调用 TempFile 将不会选择同一个文件。调用者可以使用 f.Name()来查找文件的路径名。当不再需要该文件时,调用者有责任删除该文件。</target>
        </trans-unit>
        <trans-unit id="3ec1ae061c27325c7ecb543adf91235e22cbc9ed" translate="yes" xml:space="preserve">
          <source>Template</source>
          <target state="translated">Template</target>
        </trans-unit>
        <trans-unit id="52ee9ac00f43714b0b4818dd84d35b8b6557c7c3" translate="yes" xml:space="preserve">
          <source>Template (Block)</source>
          <target state="translated">模板(块)</target>
        </trans-unit>
        <trans-unit id="74122feafa7458ac08ce0eb420614965c6703346" translate="yes" xml:space="preserve">
          <source>Template (Func)</source>
          <target state="translated">模板(FUNC)</target>
        </trans-unit>
        <trans-unit id="2682dd16a44a1aa85841c66918e903265b4a3cd6" translate="yes" xml:space="preserve">
          <source>Template (Glob)</source>
          <target state="translated">模板(Glob)</target>
        </trans-unit>
        <trans-unit id="b329235171f350105da0e424a6e94302aadf509f" translate="yes" xml:space="preserve">
          <source>Template (Helpers)</source>
          <target state="translated">模板(助手)</target>
        </trans-unit>
        <trans-unit id="f6c8b5d715e6b1e91ba606c90a46ade44fbfcfc3" translate="yes" xml:space="preserve">
          <source>Template (Parsefiles)</source>
          <target state="translated">模板 (Parsefiles)</target>
        </trans-unit>
        <trans-unit id="57600593178e53d1b30c9ce35cfc8c0a348f3a2c" translate="yes" xml:space="preserve">
          <source>Template (Share)</source>
          <target state="translated">模板 (分享)</target>
        </trans-unit>
        <trans-unit id="85b91409ae0c75ad6a8c43a15d791cc0c6067ae4" translate="yes" xml:space="preserve">
          <source>Template is a specialized Template from &quot;text/template&quot; that produces a safe HTML document fragment.</source>
          <target state="translated">Template是 &quot;text/template &quot;中的一个专门的Template,它可以生成一个安全的HTML文档片段。</target>
        </trans-unit>
        <trans-unit id="d8a89275d0782e6367eafd96ad18e35d72254fb0" translate="yes" xml:space="preserve">
          <source>Template is the representation of a parsed template. The *parse.Tree field is exported only for use by html/template and should be treated as unexported by all other clients.</source>
          <target state="translated">Template 是已解析模板的表示。*parse.Tree字段仅导出供html/template使用,其他所有客户端应视为未导出。</target>
        </trans-unit>
        <trans-unit id="19cafd4f58542bc1848a2bc09f68f32df89aaeb6" translate="yes" xml:space="preserve">
          <source>Template.Delims</source>
          <target state="translated">Template.Delims</target>
        </trans-unit>
        <trans-unit id="a8aa430f1c13b8e8ba33d56534b8f8c54974c35f" translate="yes" xml:space="preserve">
          <source>TemplateNode represents a {{template}} action.</source>
          <target state="translated">TemplateNode代表一个{{模板}}动作。</target>
        </trans-unit>
        <trans-unit id="6272b08c56a555c9301dfcc377b8ee08eca7de29" translate="yes" xml:space="preserve">
          <source>Templates are executed by applying them to a data structure. Annotations in the template refer to elements of the data structure (typically a field of a struct or a key in a map) to control execution and derive values to be displayed. Execution of the template walks the structure and sets the cursor, represented by a period '.' and called &quot;dot&quot;, to the value at the current location in the structure as execution proceeds.</source>
          <target state="translated">通过将模板应用到数据结构中来执行模板。模板中的注解指的是数据结构中的元素(通常是结构中的一个字段或地图中的一个键),以控制执行并得出要显示的值。模板的执行是在结构中行走,并在执行过程中将光标(用句号'.'表示,称为 &quot;点&quot;)设置为结构中当前位置的值。</target>
        </trans-unit>
        <trans-unit id="d659d268d0b2876b00930d9cefac00e94082414d" translate="yes" xml:space="preserve">
          <source>Templates can be redefined in successive calls to Parse, before the first use of Execute on t or any associated template. A template definition with a body containing only white space and comments is considered empty and will not replace an existing template's body. This allows using Parse to add new named template definitions without overwriting the main template body.</source>
          <target state="translated">在第一次使用Execute on t或任何相关模板之前,可以在连续调用Parse时重新定义模板。一个模板定义的主体只包含空白和注释,被认为是空的,不会替换现有模板的主体。这允许使用Parse添加新的命名模板定义,而不会覆盖主模板体。</target>
        </trans-unit>
        <trans-unit id="b0dad97eb547b69ff6ae16e7728cdc906f69fe6a" translate="yes" xml:space="preserve">
          <source>Templates can be redefined in successive calls to Parse. A template definition with a body containing only white space and comments is considered empty and will not replace an existing template's body. This allows using Parse to add new named template definitions without overwriting the main template body.</source>
          <target state="translated">模板可以在连续调用Parse时重新定义。一个模板定义的主体只包含空白和注释,被认为是空的,不会替换现有模板的主体。这允许使用Parse添加新的命名模板定义,而不覆盖主模板体。</target>
        </trans-unit>
        <trans-unit id="7b101f8846f53e53dd0074ea44ad4ea7b299215d" translate="yes" xml:space="preserve">
          <source>Templates returns a slice of defined templates associated with t.</source>
          <target state="translated">Templates返回与t相关联的定义模板的片断。</target>
        </trans-unit>
        <trans-unit id="ef678e78b264d52108e80621ab16809ee2f68f32" translate="yes" xml:space="preserve">
          <source>Templates returns a slice of the templates associated with t, including t itself.</source>
          <target state="translated">Templates 返回与 t 相关联的 templates 的片断,包括 t 本身。</target>
        </trans-unit>
        <trans-unit id="63499f131caeb094b508fda158f4d32cdfc15875" translate="yes" xml:space="preserve">
          <source>Temporary reports whether the DNS error is known to be temporary. This is not always known; a DNS lookup may fail due to a temporary error and return a DNSError for which Temporary returns false.</source>
          <target state="translated">Temporary 报告 DNS 错误是否为暂时性错误。这并不总是已知的;DNS查找可能由于临时错误而失败,并返回一个DNSError,而Temporary则返回false。</target>
        </trans-unit>
        <trans-unit id="102ab778dfcf2daa890ddca81b62a6c8c57e866c" translate="yes" xml:space="preserve">
          <source>Tests or benchmarks may be skipped at run time with a call to the Skip method of *T or *B:</source>
          <target state="translated">在运行时可以通过调用*T或*B的Skip方法来跳过测试或基准。</target>
        </trans-unit>
        <trans-unit id="4fb2cdb8c84498e97b67876bcf9179f6c6a0681c" translate="yes" xml:space="preserve">
          <source>Text and spaces</source>
          <target state="translated">文本和空格</target>
        </trans-unit>
        <trans-unit id="7c3578369bc9761a19920ddfd71d5074fb77328e" translate="yes" xml:space="preserve">
          <source>Text converts the floating-point number x to a string according to the given format and precision prec. The format is one of:</source>
          <target state="translated">Text根据给定的格式和精度prec将浮点数x转换为字符串。格式为:</target>
        </trans-unit>
        <trans-unit id="9714bb7b9d9dc65203e2f28091e607a38d20869a" translate="yes" xml:space="preserve">
          <source>Text in the format string that is not recognized as part of the reference time is echoed verbatim during Format and expected to appear verbatim in the input to Parse.</source>
          <target state="translated">在格式化过程中,格式字符串中未被识别为参考时间一部分的文本会被逐字呼应,并希望在输入到Parse的过程中逐字出现。</target>
        </trans-unit>
        <trans-unit id="2a87e174a24b19b122c0ab179b85b925e794409f" translate="yes" xml:space="preserve">
          <source>Text returns the most recent token generated by a call to Scan as a newly allocated string holding its bytes.</source>
          <target state="translated">Text返回最近一次调用Scan产生的标记,作为一个新分配的字符串,持有它的字节。</target>
        </trans-unit>
        <trans-unit id="9757ee25c7224af6e75db771ea323fc05ac31e21" translate="yes" xml:space="preserve">
          <source>Text returns the string representation of x in the given base. Base must be between 2 and 62, inclusive. The result uses the lower-case letters 'a' to 'z' for digit values 10 to 35, and the upper-case letters 'A' to 'Z' for digit values 36 to 61. No prefix (such as &quot;0x&quot;) is added to the string. If x is a nil pointer it returns &quot;&amp;lt;nil&amp;gt;&quot;.</source>
          <target state="translated">文本返回给定基数中x的字符串表示形式。底数必须在2到62之间（含2和62）。结果将小写字母&amp;ldquo; a&amp;rdquo;至&amp;ldquo; z&amp;rdquo;用于数字值10至35，将大写字母&amp;ldquo; A&amp;rdquo;至&amp;ldquo; Z&amp;rdquo;用于数字值36至61。无前缀（例如&amp;ldquo; 0x&amp;rdquo; ）添加到字符串中。如果x是nil指针，则返回&amp;ldquo; &amp;lt;nil&amp;gt;&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="544da0b6d8a9e887a60db43ce4a26fd95b56a5d4" translate="yes" xml:space="preserve">
          <source>Text returns the text of the comment. Comment markers (//, /*, and */), the first space of a line comment, and leading and trailing empty lines are removed. Comment directives like &quot;//line&quot; and &quot;//go:noinline&quot; are also removed. Multiple empty lines are reduced to one, and trailing space on lines is trimmed. Unless the result is empty, it is newline-terminated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42341adeec7d736d3551b283379c31741e77e4f9" translate="yes" xml:space="preserve">
          <source>Text returns the text of the comment. Comment markers (//, /*, and */), the first space of a line comment, and leading and trailing empty lines are removed. Multiple empty lines are reduced to one, and trailing space on lines is trimmed. Unless the result is empty, it is newline-terminated.</source>
          <target state="translated">Text 返回注释的文本。注释标记(//、**和*/)、行注释的第一个空格以及前导和尾部的空行都会被删除。多个空行将被缩减为一个,行的尾部空间将被修剪。除非结果是空的,否则它是以换行结束的。</target>
        </trans-unit>
        <trans-unit id="02af2db9a5ef05bc960487d876c4df951f9ad592" translate="yes" xml:space="preserve">
          <source>Text types have the charset parameter set to &quot;utf-8&quot; by default.</source>
          <target state="translated">文本类型的字符集参数默认设置为 &quot;utf-8&quot;。</target>
        </trans-unit>
        <trans-unit id="b44c08e7f92ae7b5fe535298ff7558bf9d8a0cab" translate="yes" xml:space="preserve">
          <source>TextMarshaler is the interface implemented by an object that can marshal itself into a textual form.</source>
          <target state="translated">TextMarshaler是由一个对象实现的接口,它可以将自己调集成一个文本形式。</target>
        </trans-unit>
        <trans-unit id="ae8b7afc36cfb51ffddc286e90577602c85186e4" translate="yes" xml:space="preserve">
          <source>TextNode holds plain text.</source>
          <target state="translated">TextNode存放纯文本。</target>
        </trans-unit>
        <trans-unit id="48668880c8086b3c4c912b1de227b18b3d9a93e1" translate="yes" xml:space="preserve">
          <source>TextUnmarshaler is the interface implemented by an object that can unmarshal a textual representation of itself.</source>
          <target state="translated">TextUnmarshaler是由一个对象实现的接口,它可以对自己的文本表示进行解扰。</target>
        </trans-unit>
        <trans-unit id="33b69b32d53f67278f1556c03b99ca73467e15b3" translate="yes" xml:space="preserve">
          <source>That is, when matching against text, the regexp returns a match that begins as early as possible in the input (leftmost), and among those it chooses a match that is as long as possible. This so-called leftmost-longest matching is the same semantics that early regular expression implementations used and that POSIX specifies.</source>
          <target state="translated">也就是说,当与文本进行匹配时,regexp会返回一个在输入中尽可能早开始的匹配(最左),并在其中选择一个尽可能长的匹配。这种所谓的最左-最长匹配与早期正则表达式实现所使用的语义相同,也是POSIX所规定的。</target>
        </trans-unit>
        <trans-unit id="1fe9add248f3617655fdc8371d42751cba2e4007" translate="yes" xml:space="preserve">
          <source>The &quot;omitempty&quot; option specifies that the field should be omitted from the encoding if the field has an empty value, defined as false, 0, a nil pointer, a nil interface value, and any empty array, slice, map, or string.</source>
          <target state="translated">omitempty &quot;选项指定,如果字段的值为空,则应从编码中省略,定义为false、0、nil指针、nil接口值,以及任何空数组、片、映射或字符串。</target>
        </trans-unit>
        <trans-unit id="71d19b0f94317203bba62dcd8f10cd68c650f96b" translate="yes" xml:space="preserve">
          <source>The &quot;string&quot; option signals that a field is stored as JSON inside a JSON-encoded string. It applies only to fields of string, floating point, integer, or boolean types. This extra level of encoding is sometimes used when communicating with JavaScript programs:</source>
          <target state="translated">&quot;string &quot;选项标志着一个字段以JSON的形式存储在一个JSON编码的字符串中,它只适用于字符串、浮点、整数或布尔类型的字段。它只适用于字符串、浮点、整数或布尔类型的字段。这种额外的编码级别有时在与JavaScript程序通信时使用。</target>
        </trans-unit>
        <trans-unit id="d1ee29ca2c06802f34981d89493c0bb6f1d6d312" translate="yes" xml:space="preserve">
          <source>The %!s just shows the print verb in use when the failure occurred. If the panic is caused by a nil receiver to an Error or String method, however, the output is the undecorated string, &quot;&amp;lt;nil&amp;gt;&quot;.</source>
          <target state="translated">％！s仅显示发生故障时正在使用的打印动词。但是，如果恐慌是由nil接收者导致Error或String方法引起的，则输出为未经修饰的字符串&amp;ldquo; &amp;lt;nil&amp;gt;&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="743e4c8e9a91e391bfa222546fd5a23a69c683b9" translate="yes" xml:space="preserve">
          <source>The *Basic type for Typ[Byte] will have the name &quot;uint8&quot;. Use Universe.Lookup(&quot;byte&quot;).Type() to obtain the specific alias basic type named &quot;byte&quot; (and analogous for &quot;rune&quot;).</source>
          <target state="translated">Typ[Byte]的*基本类型会有 &quot;uint8 &quot;的名称。使用Universe.Lookup(&quot;byte&quot;).Type()来获取名为 &quot;byte &quot;的特定别名基本类型(类似于 &quot;rune&quot;)。</target>
        </trans-unit>
        <trans-unit id="850dd1df743a69c63fe9886362ac383beaaa22a7" translate="yes" xml:space="preserve">
          <source>The AES block size in bytes.</source>
          <target state="translated">AES块的大小,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="5673ab8326600fbbe495a6285dd8ced305ce9de8" translate="yes" xml:space="preserve">
          <source>The AES operations in this package are not implemented using constant-time algorithms. An exception is when running on systems with enabled hardware support for AES that makes these operations constant-time. Examples include amd64 systems using AES-NI extensions and s390x systems using Message-Security-Assist extensions. On such systems, when the result of NewCipher is passed to cipher.NewGCM, the GHASH operation used by GCM is also constant-time.</source>
          <target state="translated">这个软件包中的AES操作并不是使用恒定时间算法来实现的。一个例外的情况是,当运行在启用了AES硬件支持的系统上,使这些操作成为恒时的。例如使用AES-NI扩展的amd64系统和使用Message-Security-Assist扩展的s390x系统。在这样的系统上,当NewCipher的结果传递给cipher.NewGCM时,GCM使用的GHASH操作也是恒时的。</target>
        </trans-unit>
        <trans-unit id="6adb0b7099e3661b5d507077f904503946e1529a" translate="yes" xml:space="preserve">
          <source>The AuthorityKeyId will be taken from the SubjectKeyId of parent, if any, unless the resulting certificate is self-signed. Otherwise the value from template will be used.</source>
          <target state="translated">AuthorityKeyId将取自父代的SubjectKeyId(如果有的话),除非产生的证书是自签的。否则将使用模板中的值。</target>
        </trans-unit>
        <trans-unit id="ef02c253bf1371acc1a3bc5ebf403abe9da8e69d" translate="yes" xml:space="preserve">
          <source>The CPU profile is not available as a Profile. It has a special API, the StartCPUProfile and StopCPUProfile functions, because it streams output to a writer during profiling.</source>
          <target state="translated">CPU配置文件不能作为Profile使用。它有一个特殊的API,即StartCPUProfile和StopCPUProfile函数,因为它在剖析过程中会将输出流转到一个写入器。</target>
        </trans-unit>
        <trans-unit id="7bedc851c290436a17de2ea56c0e80eced3a4ba0" translate="yes" xml:space="preserve">
          <source>The CRL is signed by priv which should be the private key associated with the public key in the issuer certificate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ff86b138d4478667bb91009d716fd7665b76152" translate="yes" xml:space="preserve">
          <source>The CSPRNG key is indifferentiable from a random oracle as shown in [Coron], the AES-CTR stream is indifferentiable from a random oracle under standard cryptographic assumptions (see [Larsson] for examples).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36bb730fcee3dc3ab8099094b237b4e5ff536824" translate="yes" xml:space="preserve">
          <source>The Call method waits for the remote call to complete while the Go method launches the call asynchronously and signals completion using the Call structure's Done channel.</source>
          <target state="translated">Call方法等待远程调用完成,而Go方法异步启动调用,并使用Call结构的Done通道发出完成信号。</target>
        </trans-unit>
        <trans-unit id="fa9c5434f905167654701708a6911e94eaa76597" translate="yes" xml:space="preserve">
          <source>The Client and Transport return Responses from servers once the response headers have been received. The response body is streamed on demand as the Body field is read.</source>
          <target state="translated">一旦收到响应头,客户端和传输就会从服务器返回响应。读取Body字段时,响应主体会按要求进行流式传输。</target>
        </trans-unit>
        <trans-unit id="a06861d55f6598b58fca7ecb30c8e99763835023" translate="yes" xml:space="preserve">
          <source>The Client's Transport typically has internal state (cached TCP connections), so Clients should be reused instead of created as needed. Clients are safe for concurrent use by multiple goroutines.</source>
          <target state="translated">Client的Transport通常具有内部状态(缓存的TCP连接),所以应该在需要时重复使用而不是创建Client。客户端对于多个goroutine的并发使用是安全的。</target>
        </trans-unit>
        <trans-unit id="ceca2d7732940705f6d00b5d32a4fb0ac5b5ffee" translate="yes" xml:space="preserve">
          <source>The CloseNotifier interface is implemented by ResponseWriters which allow detecting when the underlying connection has gone away.</source>
          <target state="translated">CloseNotifier接口是由ResponseWriters实现的,它允许检测底层连接何时消失。</target>
        </trans-unit>
        <trans-unit id="e611d14841eea36df4afcbef6632f0e94c16f389" translate="yes" xml:space="preserve">
          <source>The Comments list contains all comments in the source file in order of appearance, including the comments that are pointed to from other nodes via Doc and Comment fields.</source>
          <target state="translated">评论列表包含了源文件中的所有评论,按出现的顺序排列,包括通过Doc和Comment字段从其他节点指向的评论。</target>
        </trans-unit>
        <trans-unit id="7243291c556ac8dd62df98afdad8c3760dcef423" translate="yes" xml:space="preserve">
          <source>The Content-Type header is set to application/x-www-form-urlencoded. To set other headers, use NewRequest and Client.Do.</source>
          <target state="translated">Content-Type头被设置为application/x-www-form-urlencoded。要设置其他头,使用NewRequest和Client.Do。</target>
        </trans-unit>
        <trans-unit id="4c8514b948c44917ccd4528524ea490c8df7afe9" translate="yes" xml:space="preserve">
          <source>The Content-Type header is set to application/x-www-form-urlencoded. To set other headers, use NewRequest and DefaultClient.Do.</source>
          <target state="translated">Content-Type头被设置为application/x-www-form-urlencoded。要设置其他头,使用NewRequest和DefaultClient.Do。</target>
        </trans-unit>
        <trans-unit id="e64fbf6aec6e290cb2a86c841a198b35f0414494" translate="yes" xml:space="preserve">
          <source>The Context field will be zero to gather a traceback from the current program execution point. In this case, the traceback function will be called from C code.</source>
          <target state="translated">Context字段将为零,以收集当前程序执行点的回溯。在这种情况下,回溯函数将从C代码中调用。</target>
        </trans-unit>
        <trans-unit id="0d4ab0b54e24df8d963181a5b8f48a80c3f0be3b" translate="yes" xml:space="preserve">
          <source>The Copy function uses ReaderFrom if available.</source>
          <target state="translated">复制功能使用ReaderFrom(如果有)。</target>
        </trans-unit>
        <trans-unit id="64b7a752d1105251970c527872a99e908894fe83" translate="yes" xml:space="preserve">
          <source>The Copy function uses WriterTo if available.</source>
          <target state="translated">如果有的话,复制函数使用WriterTo。</target>
        </trans-unit>
        <trans-unit id="4068b76cb1fd1e06d5771c04e2c02b7fd65472c1" translate="yes" xml:space="preserve">
          <source>The DES block size in bytes.</source>
          <target state="translated">DES块大小,单位为字节。</target>
        </trans-unit>
        <trans-unit id="1b8c2351859f5d138662581cb4874dd621eef345" translate="yes" xml:space="preserve">
          <source>The DSA operations in this package are not implemented using constant-time algorithms.</source>
          <target state="translated">本包中的DSA操作没有使用恒时算法来实现。</target>
        </trans-unit>
        <trans-unit id="3d5a6f0be8af4ae349714dde142378b2b0dd32c1" translate="yes" xml:space="preserve">
          <source>The Data fields contains object-specific data:</source>
          <target state="translated">数据字段包含特定对象的数据。</target>
        </trans-unit>
        <trans-unit id="d70280d8e959481aa07b78bca8cd9c9158da0c1f" translate="yes" xml:space="preserve">
          <source>The Decoder does only basic sanity checking on decoded input sizes, and its limits are not configurable. Take caution when decoding gob data from untrusted sources.</source>
          <target state="translated">解码器只对解码后的输入大小进行基本的理智性检查,其限制是不可配置的。在对来自不受信任的来源的gob数据进行解码时,请小心谨慎。</target>
        </trans-unit>
        <trans-unit id="1a3dcfbdb85a6eb02179c9d5c4dd5b3efbbb6016" translate="yes" xml:space="preserve">
          <source>The Dial function connects to a server:</source>
          <target state="translated">拨号功能连接到服务器。</target>
        </trans-unit>
        <trans-unit id="e5af1dd969514f431da9aefdd41666a5f815fd72" translate="yes" xml:space="preserve">
          <source>The Error interface identifies a run time error.</source>
          <target state="translated">错误接口识别运行时的错误。</target>
        </trans-unit>
        <trans-unit id="8e437b0bdb4841542eba2f049276dee573f887b3" translate="yes" xml:space="preserve">
          <source>The Errorf function lets us use formatting features to create descriptive error messages.</source>
          <target state="translated">Errorf功能让我们可以使用格式化功能来创建描述性的错误信息。</target>
        </trans-unit>
        <trans-unit id="4cc7e273196b60c7b327e2a1e7c92da50e59b611" translate="yes" xml:space="preserve">
          <source>The Examples section of the documentation includes an illustration of how to use MakeFunc to build a swap function for different types.</source>
          <target state="translated">文档中的示例部分包含了如何使用MakeFunc为不同类型构建交换函数的说明。</target>
        </trans-unit>
        <trans-unit id="a4103d71ff7738d060819734b8440840f86eb6a7" translate="yes" xml:space="preserve">
          <source>The Flusher interface is implemented by ResponseWriters that allow an HTTP handler to flush buffered data to the client.</source>
          <target state="translated">Flusher接口是由ResponseWriters实现的,它允许HTTP处理程序将缓冲数据刷新到客户端。</target>
        </trans-unit>
        <trans-unit id="8989cf7d3fb3d7f0d686b9d17d09faeb78214543" translate="yes" xml:space="preserve">
          <source>The GIF specification is at &lt;a href=&quot;https://www.w3.org/Graphics/GIF/spec-gif89a.txt&quot;&gt;https://www.w3.org/Graphics/GIF/spec-gif89a.txt&lt;/a&gt;.</source>
          <target state="translated">GIF规范位于&lt;a href=&quot;https://www.w3.org/Graphics/GIF/spec-gif89a.txt&quot;&gt;https://www.w3.org/Graphics/GIF/spec-gif89a.txt&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="413f2e2abeee0cebf1b4d1ac0f711038cf2ef825" translate="yes" xml:space="preserve">
          <source>The GOARCH, GOOS, GOPATH, and GOROOT environment variables complete the set of Go environment variables. They influence the building of Go programs (see &lt;a href=&quot;https://golang.org/cmd/go&quot;&gt;https://golang.org/cmd/go&lt;/a&gt; and &lt;a href=&quot;../go/build/index&quot;&gt;https://golang.org/pkg/go/build&lt;/a&gt;). GOARCH, GOOS, and GOROOT are recorded at compile time and made available by constants or functions in this package, but they do not influence the execution of the run-time system.</source>
          <target state="translated">GOARCH，GOOS，GOPATH和GOROOT环境变量完善了Go环境变量集。它们会影响Go程序的构建（请参阅&lt;a href=&quot;https://golang.org/cmd/go&quot;&gt;https://golang.org/cmd/go&lt;/a&gt;和&lt;a href=&quot;../go/build/index&quot;&gt;https://golang.org/pkg/go/build&lt;/a&gt;）。GOARCH，GOOS和GOROOT会在编译时记录下来，并可以通过此包中的常量或函数使用，但它们不会影响运行时系统的执行。</target>
        </trans-unit>
        <trans-unit id="980859c522964a8cbb3109a2a563d54c04b37667" translate="yes" xml:space="preserve">
          <source>The GODEBUG variable controls debugging variables within the runtime. It is a comma-separated list of name=val pairs setting these named variables:</source>
          <target state="translated">GODEBUG变量控制运行时内的调试变量。它是一个由name=val对组成的逗号分隔的列表,用于设置这些命名的变量。</target>
        </trans-unit>
        <trans-unit id="854b96235a6d258614ac621d5a074c350962980a" translate="yes" xml:space="preserve">
          <source>The GODEBUG variables are not covered by Go's API compatibility promise. Please report any issues before disabling HTTP/2 support: &lt;a href=&quot;https://golang.org/s/http2bug&quot;&gt;https://golang.org/s/http2bug&lt;/a&gt;</source>
          <target state="translated">Go的API兼容性保证不涵盖GODEBUG变量。请先报告所有问题，然后再禁用HTTP / 2支持：&lt;a href=&quot;https://golang.org/s/http2bug&quot;&gt;https&lt;/a&gt;：//golang.org/s/http2bug</target>
        </trans-unit>
        <trans-unit id="07350ebc65d6866cf7470b34fa919f4c89a12e5a" translate="yes" xml:space="preserve">
          <source>The GOGC variable sets the initial garbage collection target percentage. A collection is triggered when the ratio of freshly allocated data to live data remaining after the previous collection reaches this percentage. The default is GOGC=100. Setting GOGC=off disables the garbage collector entirely. The runtime/debug package's SetGCPercent function allows changing this percentage at run time. See &lt;a href=&quot;debug/index#SetGCPercent&quot;&gt;https://golang.org/pkg/runtime/debug/#SetGCPercent&lt;/a&gt;.</source>
          <target state="translated">GOGC变量设置初始垃圾回收目标百分比。当新分配的数据与上一个收集后剩余的实时数据之比达到此百分比时，将触发收集。默认值为GOGC = 100。设置GOGC = off将完全禁用垃圾收集器。运行时/调试包的SetGCPercent函数允许在运行时更改此百分比。参见&lt;a href=&quot;debug/index#SetGCPercent&quot;&gt;https://golang.org/pkg/runtime/debug/#SetGCPercent&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="23644add17b2d4ea82387647518fec703dd62cda" translate="yes" xml:space="preserve">
          <source>The GOMAXPROCS variable limits the number of operating system threads that can execute user-level Go code simultaneously. There is no limit to the number of threads that can be blocked in system calls on behalf of Go code; those do not count against the GOMAXPROCS limit. This package's GOMAXPROCS function queries and changes the limit.</source>
          <target state="translated">GOMAXPROCS变量限制了可以同时执行用户级围棋代码的操作系统线程数量。对于在系统调用中代表围棋代码被阻塞的线程数量没有限制,这些线程不计入GOMAXPROCS限制。本包的GOMAXPROCS函数可以查询并更改该限制。</target>
        </trans-unit>
        <trans-unit id="2dc1829c430b9fe1fcd42a5d7af5182478e7df72" translate="yes" xml:space="preserve">
          <source>The GORACE variable configures the race detector, for programs built using -race. See &lt;a href=&quot;https://golang.org/doc/articles/race_detector.html&quot;&gt;https://golang.org/doc/articles/race_detector.html&lt;/a&gt; for details.</source>
          <target state="translated">GORACE变量为使用-race构建的程序配置了竞争检测器。有关详细信息，请参见&lt;a href=&quot;https://golang.org/doc/articles/race_detector.html&quot;&gt;https://golang.org/doc/articles/race_detector.html&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="895a2c86582e638542cc835d086a523cf9768898" translate="yes" xml:space="preserve">
          <source>The GOTRACEBACK variable controls the amount of output generated when a Go program fails due to an unrecovered panic or an unexpected runtime condition. By default, a failure prints a stack trace for the current goroutine, eliding functions internal to the run-time system, and then exits with exit code 2. The failure prints stack traces for all goroutines if there is no current goroutine or the failure is internal to the run-time. GOTRACEBACK=none omits the goroutine stack traces entirely. GOTRACEBACK=single (the default) behaves as described above. GOTRACEBACK=all adds stack traces for all user-created goroutines. GOTRACEBACK=system is like &amp;ldquo;all&amp;rdquo; but adds stack frames for run-time functions and shows goroutines created internally by the run-time. GOTRACEBACK=crash is like &amp;ldquo;system&amp;rdquo; but crashes in an operating system-specific manner instead of exiting. For example, on Unix systems, the crash raises SIGABRT to trigger a core dump. For historical reasons, the GOTRACEBACK settings 0, 1, and 2 are synonyms for none, all, and system, respectively. The runtime/debug package's SetTraceback function allows increasing the amount of output at run time, but it cannot reduce the amount below that specified by the environment variable. See &lt;a href=&quot;debug/index#SetTraceback&quot;&gt;https://golang.org/pkg/runtime/debug/#SetTraceback&lt;/a&gt;.</source>
          <target state="translated">GOTRACEBACK变量控制在Go程序由于未恢复的紧急情况或意外的运行时条件而失败时生成的输出量。默认情况下，故障将打印当前goroutine的堆栈跟踪，清除运行时系统内部的函数，然后以退出代码2退出。如果没有当前goroutine或故障是失败，则故障将打印所有goroutine的堆栈跟踪。在运行时内部。 GOTRACEBACK = none完全省略goroutine堆栈跟踪。 GOTRACEBACK = single（默认）的行为如上所述。 GOTRACEBACK = all为所有用户创建的goroutine添加堆栈跟踪。 GOTRACEBACK = system类似于&amp;ldquo; all&amp;rdquo;，但为运行时功能添加了堆栈框架，并显示了运行时在内部创建的goroutine。GOTRACEBACK = crash类似于&amp;ldquo; system&amp;rdquo;，但是以特定于操作系统的方式崩溃而不是退出。例如，在Unix系统上，崩溃导致SIGABRT触发核心转储。由于历史原因，GOTRACEBACK设置0、1和2分别是none，all和system的同义词。运行时/调试包的SetTraceback函数允许在运行时增加输出量，但不能将其减少到环境变量指定的量以下。看到但是它不能将数量减少到环境变量指定的数量以下。看到但是它不能将数量减少到环境变量指定的数量以下。看到&lt;a href=&quot;debug/index#SetTraceback&quot;&gt;https://golang.org/pkg/runtime/debug/#SetTraceback&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="201ea9b13c6c1b11811e547f191be7e93f488ebd" translate="yes" xml:space="preserve">
          <source>The Go 1 compatibility guidelines make it impossible for us to change the behavior of these methods; use Read or ReadMsgIP instead.</source>
          <target state="translated">Go 1的兼容性准则使我们无法改变这些方法的行为;请使用Read或ReadMsgIP代替。</target>
        </trans-unit>
        <trans-unit id="bbb7c186e3ae50bd364f0be3171da7e4e4fa74f9" translate="yes" xml:space="preserve">
          <source>The Go function fn is called with the value of JavaScript's &quot;this&quot; keyword and the arguments of the invocation. The return value of the invocation is the result of the Go function mapped back to JavaScript according to ValueOf.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7566eb3c6d36d40991cd457887383d73c8d32f6" translate="yes" xml:space="preserve">
          <source>The Go path is a list of directory trees containing Go source code. It is consulted to resolve imports that cannot be found in the standard Go tree. The default path is the value of the GOPATH environment variable, interpreted as a path list appropriate to the operating system (on Unix, the variable is a colon-separated string; on Windows, a semicolon-separated string; on Plan 9, a list).</source>
          <target state="translated">Go路径是包含Go源代码的目录树列表。它被用来解决在标准Go树中找不到的导入。默认路径是GOPATH环境变量的值,解释为适合操作系统的路径列表(在Unix上,该变量是一个以冒号分隔的字符串;在Windows上,是一个以分号分隔的字符串;在Plan 9上,是一个列表)。</target>
        </trans-unit>
        <trans-unit id="b3cf2d68365e20d0973a301087cdd0150f378764" translate="yes" xml:space="preserve">
          <source>The Go visibility rules for struct fields are amended for JSON when deciding which field to marshal or unmarshal. If there are multiple fields at the same level, and that level is the least nested (and would therefore be the nesting level selected by the usual Go rules), the following extra rules apply:</source>
          <target state="translated">在决定对哪个字段进行整合或取消整合时,对JSON结构字段的围棋可见性规则进行了修正。如果同一层次有多个字段,而且该层次是最小的嵌套层次(因此是通常的Go规则所选择的嵌套层次),则适用以下额外规则。</target>
        </trans-unit>
        <trans-unit id="0fd6453ed937237b824b9a18906363db4d73b2a6" translate="yes" xml:space="preserve">
          <source>The HandlerFunc type is an adapter to allow the use of ordinary functions as HTTP handlers. If f is a function with the appropriate signature, HandlerFunc(f) is a Handler that calls f.</source>
          <target state="translated">HandlerFunc类型是一个适配器,允许使用普通函数作为HTTP处理程序。如果f是一个具有适当签名的函数,HandlerFunc(f)就是一个调用f的处理程序。</target>
        </trans-unit>
        <trans-unit id="dcde06a75814cbd2f82c57451a15f7098bfdc1f6" translate="yes" xml:space="preserve">
          <source>The Hijacker interface is implemented by ResponseWriters that allow an HTTP handler to take over the connection.</source>
          <target state="translated">Hijacker接口是由ResponseWriters实现的,它允许一个HTTP处理程序来接管连接。</target>
        </trans-unit>
        <trans-unit id="3370b385b8e5dd84393ea8ba4a384825a13db61b" translate="yes" xml:space="preserve">
          <source>The Interface type describes the requirements for a type using the routines in this package. Any type that implements it may be used as a min-heap with the following invariants (established after Init has been called or if the data is empty or sorted):</source>
          <target state="translated">接口类型描述了使用本包中的例程对类型的要求。任何实现它的类型都可以作为迷你堆使用,其不变性如下(在Init被调用后或数据为空或排序后建立)。</target>
        </trans-unit>
        <trans-unit id="0aee04eced9ac7c3fac2de601ac7413fde3bf654" translate="yes" xml:space="preserve">
          <source>The JSON null value unmarshals into an interface, map, pointer, or slice by setting that Go value to nil. Because null is often used in JSON to mean &amp;ldquo;not present,&amp;rdquo; unmarshaling a JSON null into any other Go type has no effect on the value and produces no error.</source>
          <target state="translated">通过将该Go值设置为nil，JSON空值可解组到接口，映射，指针或切片中。由于在JSON中通常使用null来表示&amp;ldquo;不存在&amp;rdquo;，因此将JSON null解组到任何其他Go类型中不会影响该值，并且不会产生任何错误。</target>
        </trans-unit>
        <trans-unit id="22f4320ee94c207b6f6c1bf76ec0cc99a4e78e12" translate="yes" xml:space="preserve">
          <source>The Listen function creates servers:</source>
          <target state="translated">Listen功能可以创建服务器。</target>
        </trans-unit>
        <trans-unit id="f1e8051445ee7295f2015e153c91e6e9f468a7b9" translate="yes" xml:space="preserve">
          <source>The Map type is optimized for two common use cases: (1) when the entry for a given key is only ever written once but read many times, as in caches that only grow, or (2) when multiple goroutines read, write, and overwrite entries for disjoint sets of keys. In these two cases, use of a Map may significantly reduce lock contention compared to a Go map paired with a separate Mutex or RWMutex.</source>
          <target state="translated">Map类型针对两种常见的用例进行了优化。(1)当一个给定的键的条目只被写入一次,但却被多次读取,如在只会增长的缓存中,或(2)当多个goroutine读取、写入和覆盖不相干的键集的条目时。在这两种情况下,与Go地图与单独的Mutex或RWMutex搭配使用相比,使用Map可能会显著减少锁的争用。</target>
        </trans-unit>
        <trans-unit id="93c1aea237df8273d73d6b2b1db4e7c127b7fdb2" translate="yes" xml:space="preserve">
          <source>The Map type is specialized. Most code should use a plain Go map instead, with separate locking or coordination, for better type safety and to make it easier to maintain other invariants along with the map content.</source>
          <target state="translated">Map类型是专门的。大多数代码应该使用普通的围棋地图来代替,并有单独的锁定或协调,以便更好地保证类型的安全性,并使其更容易与地图内容一起维护其他不变式。</target>
        </trans-unit>
        <trans-unit id="0006e6725a631489c9423aa1f192586acc3a14d6" translate="yes" xml:space="preserve">
          <source>The MergeMode flags control the behavior of MergePackageFiles.</source>
          <target state="translated">MergeMode标志控制MergePackageFiles的行为。</target>
        </trans-unit>
        <trans-unit id="46419978a96c95f07df701b47af9ce0c381fb8e5" translate="yes" xml:space="preserve">
          <source>The New function creates errors whose only content is a text message.</source>
          <target state="translated">新建函数创建的错误,其唯一的内容是一个文本消息。</target>
        </trans-unit>
        <trans-unit id="ed989955d8475da0903bbb33a13d3c6797487592" translate="yes" xml:space="preserve">
          <source>The PC field will be a value returned by a call to the traceback function.</source>
          <target state="translated">PC字段将是调用回溯函数所返回的值。</target>
        </trans-unit>
        <trans-unit id="886ce6ce1a2e11f65b175c91749f88d574c43226" translate="yes" xml:space="preserve">
          <source>The PNG specification is at &lt;a href=&quot;https://www.w3.org/TR/PNG/&quot;&gt;https://www.w3.org/TR/PNG/&lt;/a&gt;.</source>
          <target state="translated">PNG规范位于&lt;a href=&quot;https://www.w3.org/TR/PNG/&quot;&gt;https://www.w3.org/TR/PNG/&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c904da70bc4311012997fe9bbd4ccc021eaf72a0" translate="yes" xml:space="preserve">
          <source>The Pos value for a given file is a number in the range [base, base+size], where base and size are specified when a file is added to the file set. The difference between a Pos value and the corresponding file base corresponds to the byte offset of that position (represented by the Pos value) from the beginning of the file. Thus, the file base offset is the Pos value representing the first byte in the file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e01da8fcfe6b3b9e18fc8125aed80da656d99c50" translate="yes" xml:space="preserve">
          <source>The Pos value for a given file is a number in the range [base, base+size], where base and size are specified when adding the file to the file set via AddFile.</source>
          <target state="translated">给定文件的Pos值是一个范围为[base,base+size]的数字,其中base和size是在通过AddFile添加文件到文件集时指定的。</target>
        </trans-unit>
        <trans-unit id="24b49c8f6cf4d6923667f2f4ded23d7140a2b9f0" translate="yes" xml:space="preserve">
          <source>The Priority is a combination of the syslog facility and severity. For example, LOG_ALERT | LOG_FTP sends an alert severity message from the FTP facility. The default severity is LOG_EMERG; the default facility is LOG_KERN.</source>
          <target state="translated">优先级是syslog设施和严重性的组合。例如,LOG_ALERT | LOG_FTP从FTP设施中发送警报严重性消息,默认严重性是LOG_EMERG;默认设施是LOG_KERN。默认的严重性是LOG_EMERG;默认的设施是LOG_KERN。</target>
        </trans-unit>
        <trans-unit id="c56c9b0bbe08c95a239dcc95eda30597b6ca619e" translate="yes" xml:space="preserve">
          <source>The Process it returns can be used to obtain information about the underlying operating system process.</source>
          <target state="translated">它返回的进程可以用来获取底层操作系统进程的信息。</target>
        </trans-unit>
        <trans-unit id="10801c2ff1093f1ce7c760ba00803c382474a94e" translate="yes" xml:space="preserve">
          <source>The RSA operations in this package are not implemented using constant-time algorithms.</source>
          <target state="translated">本包中的RSA操作没有使用恒时算法来实现。</target>
        </trans-unit>
        <trans-unit id="e75efacd08116681c05f3907c86c9cdff60db179" translate="yes" xml:space="preserve">
          <source>The ReadCloser returned by NewReader also implements Resetter.</source>
          <target state="translated">NewReader返回的ReadCloser也实现了Resetter。</target>
        </trans-unit>
        <trans-unit id="3bfc20a3944403086f24f5757939a8cbd9b7c5ac" translate="yes" xml:space="preserve">
          <source>The ReadCloser returned by NewReaderDict also implements Resetter.</source>
          <target state="translated">NewReaderDict返回的ReadCloser也实现了Resetter。</target>
        </trans-unit>
        <trans-unit id="c4f8edaea822742e73d1aca6a1265098af5d579e" translate="yes" xml:space="preserve">
          <source>The Reader converts all \r\n sequences in its input to plain \n, including in multiline field values, so that the returned data does not depend on which line-ending convention an input file uses.</source>
          <target state="translated">读取器将其输入中所有的&quot;/r/n &quot;序列转换为纯&quot;/r/n&quot;,包括在多行字段中的值,因此,返回的数据并不取决于输入文件使用的行尾约定。</target>
        </trans-unit>
        <trans-unit id="41c2e3518894534a6a634c57bbad5ea70224c3de" translate="yes" xml:space="preserve">
          <source>The Reader.Header fields will be valid in the Reader returned.</source>
          <target state="translated">Reader.Header字段将在返回的Reader中有效。</target>
        </trans-unit>
        <trans-unit id="9fd8011df0852a1e27b3907bd2a3f82247ef31e5" translate="yes" xml:space="preserve">
          <source>The Request.Proto is always HTTP/1.1.</source>
          <target state="translated">Request.Proto总是HTTP/1.1。</target>
        </trans-unit>
        <trans-unit id="09c4e81d433af7e0ae48c721f621859a4e5a3317" translate="yes" xml:space="preserve">
          <source>The Response Body is closed after it is sent.</source>
          <target state="translated">响应体发送后即关闭。</target>
        </trans-unit>
        <trans-unit id="041fd8da9679545d4de46a3a12d665330f551006" translate="yes" xml:space="preserve">
          <source>The Response.Body is guaranteed to be non-nil and Body.Read call is guaranteed to not return any error other than io.EOF.</source>
          <target state="translated">保证Response.Body是非nil,保证Body.Read调用不返回任何除io.EOF以外的错误。</target>
        </trans-unit>
        <trans-unit id="bc99bfa959e73d9ff72d10e54ecd5ffaa2259252" translate="yes" xml:space="preserve">
          <source>The Response.Header is a snapshot of the headers at the time of the first write call, or at the time of this call, if the handler never did a write.</source>
          <target state="translated">Response.Header是第一次写入调用时的头的快照,如果处理程序从未进行过写入,则在这次调用时。</target>
        </trans-unit>
        <trans-unit id="18a3ebac1f2c2059df0438aac114025f62ecfbf9" translate="yes" xml:space="preserve">
          <source>The Run methods of T and B allow defining subtests and sub-benchmarks, without having to define separate functions for each. This enables uses like table-driven benchmarks and creating hierarchical tests. It also provides a way to share common setup and tear-down code:</source>
          <target state="translated">T和B的Run方法允许定义子测试和子基准,而不必为每个子基准定义单独的函数。这使得像表格驱动的基准和创建分层测试这样的用途成为可能。它还提供了一种共享通用设置和拆卸代码的方法。</target>
        </trans-unit>
        <trans-unit id="2fdffd1148a25e94f2ea65756e345947d69016d2" translate="yes" xml:space="preserve">
          <source>The SendMail function and the net/smtp package are low-level mechanisms and provide no support for DKIM signing, MIME attachments (see the mime/multipart package), or other mail functionality. Higher-level packages exist outside of the standard library.</source>
          <target state="translated">SendMail函数和net/smtp包都是低级机制,不提供对DKIM签名、MIME附件(参见mime/multipart包)或其他邮件功能的支持。更高级别的包存在于标准库之外。</target>
        </trans-unit>
        <trans-unit id="f9a92bd5980ed21b3a625476d07c987591bfa7d7" translate="yes" xml:space="preserve">
          <source>The Spec type stands for any of *ImportSpec, *ValueSpec, and *TypeSpec.</source>
          <target state="translated">Spec类型代表*ImportSpec、*ValueSpec和*TypeSpec中的任何一种。</target>
        </trans-unit>
        <trans-unit id="4919a225e3add39379ff15a9bce358f52cae5ffb" translate="yes" xml:space="preserve">
          <source>The Syscall functions in package syscall pass their uintptr arguments directly to the operating system, which then may, depending on the details of the call, reinterpret some of them as pointers. That is, the system call implementation is implicitly converting certain arguments back from uintptr to pointer.</source>
          <target state="translated">包syscall中的Syscall函数将其uintptr参数直接传递给操作系统,然后根据调用的细节,系统可能会将其中的一些参数重新解释为指针。也就是说,系统调用的实现是隐性的将某些参数从uintptr转换回指针。</target>
        </trans-unit>
        <trans-unit id="3e332fd0096a988b6619d722b0818e386abfd30a" translate="yes" xml:space="preserve">
          <source>The TIFF file format uses a similar but incompatible version of the LZW algorithm. See the golang.org/x/image/tiff/lzw package for an implementation.</source>
          <target state="translated">TIFF文件格式使用了类似的但不兼容的LZW算法版本,请参见golang.org/x/image/tiff/lzw包的实现。参见golang.org/x/image/tiff/lzw包中的实现。</target>
        </trans-unit>
        <trans-unit id="58336a8c0934089954efcd803d6fca80fefa9eb4" translate="yes" xml:space="preserve">
          <source>The TLS field is set to a non-nil dummy value if target has scheme &quot;https&quot;.</source>
          <target state="translated">如果目标的方案为 &quot;https&quot;,则TLS字段会被设置为一个非零的虚值。</target>
        </trans-unit>
        <trans-unit id="d581afca4a5305392d28788d2eee7630e8dc138a" translate="yes" xml:space="preserve">
          <source>The Time returned by time.Now contains a monotonic clock reading. If Time t has a monotonic clock reading, t.Add adds the same duration to both the wall clock and monotonic clock readings to compute the result. Because t.AddDate(y, m, d), t.Round(d), and t.Truncate(d) are wall time computations, they always strip any monotonic clock reading from their results. Because t.In, t.Local, and t.UTC are used for their effect on the interpretation of the wall time, they also strip any monotonic clock reading from their results. The canonical way to strip a monotonic clock reading is to use t = t.Round(0).</source>
          <target state="translated">time.Now返回的时间包含一个单调时钟读数。如果时间t有一个单调时钟读数,t.Add就会对挂钟和单调时钟读数加上相同的持续时间来计算结果。因为t.AddDate(y,m,d)、t.Round(d)和t.Truncate(d)是挂钟时间的计算,所以它们总是从结果中去掉任何单调时钟读数。因为t.In、t.Local和t.UTC对墙时解释的影响,它们也会从结果中剥离任何单调时钟读数。剥离单调时钟读数的规范方法是使用 t=t.round(0)。</target>
        </trans-unit>
        <trans-unit id="33e81456d15715e940a5919174eaa3f7637dcde7" translate="yes" xml:space="preserve">
          <source>The Timer type represents a single event. When the Timer expires, the current time will be sent on C, unless the Timer was created by AfterFunc. A Timer must be created with NewTimer or AfterFunc.</source>
          <target state="translated">Timer类型代表一个单一事件。当Timer过期时,当前时间将被发送到C上,除非Timer是由AfterFunc创建的。定时器必须用NewTimer或AfterFunc创建。</target>
        </trans-unit>
        <trans-unit id="cf73d1723f31995bde582871be9d0a7a3c49f2e8" translate="yes" xml:space="preserve">
          <source>The Universe scope contains all predeclared objects of Go. It is the outermost scope of any chain of nested scopes.</source>
          <target state="translated">Universe 作用域包含 Go 的所有预定义对象。它是任何嵌套作用域链的最外层作用域。</target>
        </trans-unit>
        <trans-unit id="d2217feb010f2a9e20eb107dc97fbe00b28a97e3" translate="yes" xml:space="preserve">
          <source>The Unsafe package is the package returned by an importer for the import path &quot;unsafe&quot;.</source>
          <target state="translated">Unsafe包是导入路径为 &quot;unsafe &quot;的导入者返回的包。</target>
        </trans-unit>
        <trans-unit id="82e1a6db6a2ce451395a30960fcbaa8d447276c7" translate="yes" xml:space="preserve">
          <source>The Unwrap, Is and As functions work on errors that may wrap other errors. An error wraps another error if its type has the method</source>
          <target state="translated">Unwrap、Is和As函数用于处理可能包装其他错误的错误。如果一个错误的类型具有方法</target>
        </trans-unit>
        <trans-unit id="84a102639d5d98f811fc502808b53b881ef02020" translate="yes" xml:space="preserve">
          <source>The Userinfo type is an immutable encapsulation of username and password details for a URL. An existing Userinfo value is guaranteed to have a username set (potentially empty, as allowed by RFC 2396), and optionally a password.</source>
          <target state="translated">Userinfo类型是对一个URL的用户名和密码细节的不可改变的封装。一个现有的Userinfo值保证有一个用户名设置(可能是空的,RFC 2396允许的),还有一个可选的密码。</target>
        </trans-unit>
        <trans-unit id="fbd19f3117c4f5404c3dc4318c570ed741a162cd" translate="yes" xml:space="preserve">
          <source>The Value.Call method allows the caller to invoke a typed function in terms of Values; in contrast, MakeFunc allows the caller to implement a typed function in terms of Values.</source>
          <target state="translated">Value.Call方法允许调用者用Value调用一个类型化的函数;相反,MakeFunc允许调用者用Value实现一个类型化的函数。</target>
        </trans-unit>
        <trans-unit id="b671f0d2f06db5c55a3ebed77ddd3e1fdacf58bc" translate="yes" xml:space="preserve">
          <source>The Wait method will return the exit code and release associated resources once the command exits.</source>
          <target state="translated">Wait方法将在命令退出后返回退出代码并释放相关资源。</target>
        </trans-unit>
        <trans-unit id="f996448ff14d875bb2a49935e2e1a1c11597d19a" translate="yes" xml:space="preserve">
          <source>The WithCancel, WithDeadline, and WithTimeout functions take a Context (the parent) and return a derived Context (the child) and a CancelFunc. Calling the CancelFunc cancels the child and its children, removes the parent's reference to the child, and stops any associated timers. Failing to call the CancelFunc leaks the child and its children until the parent is canceled or the timer fires. The go vet tool checks that CancelFuncs are used on all control-flow paths.</source>
          <target state="translated">WithCancel、WithDeadline和WithTimeout函数接收一个Context(父函数)并返回一个派生Context(子函数)和一个CancelFunc。调用CancelFunc会取消子函数和它的子函数,删除父函数对子函数的引用,并停止任何相关的计时器。如果未能调用CancelFunc,则会泄露子代和它的子代,直到父代被取消或定时器启动。go vet工具会检查CancelFuncs是否被用于所有控制流路径。</target>
        </trans-unit>
        <trans-unit id="7ad67f6f0923ebfa2c780fb9b0118879fff918f1" translate="yes" xml:space="preserve">
          <source>The Writer assumes that all Unicode code points have the same width; this may not be true in some fonts or if the string contains combining characters.</source>
          <target state="translated">写字机假设所有的Unicode码点都有相同的宽度;在某些字体中,或者如果字符串中包含组合字符,这可能不是真的。</target>
        </trans-unit>
        <trans-unit id="e4b495842c9aa071c7e0475777b24079ec5d06f2" translate="yes" xml:space="preserve">
          <source>The Writer currently provides no support for sparse files.</source>
          <target state="translated">Writer目前不支持稀疏文件。</target>
        </trans-unit>
        <trans-unit id="53af9c2eed3edf32c0f1e34e826ade2723d6ef7e" translate="yes" xml:space="preserve">
          <source>The Writer must buffer input internally, because proper spacing of one line may depend on the cells in future lines. Clients must call Flush when done calling Write.</source>
          <target state="translated">写入器必须在内部缓冲输入,因为一行的正确间距可能取决于未来行的单元格。客户端在调用Write后必须调用Flush。</target>
        </trans-unit>
        <trans-unit id="628a74097036f85303a5350ae981dc164e95f20b" translate="yes" xml:space="preserve">
          <source>The Writer treats incoming bytes as UTF-8-encoded text consisting of cells terminated by horizontal ('\t') or vertical ('\v') tabs, and newline ('\n') or formfeed ('\f') characters; both newline and formfeed act as line breaks.</source>
          <target state="translated">写入器将输入的字节视为UTF-8编码的文本,由水平('/t')或垂直('/v')制表符、换行('/n')或换格式('/f')字符结束的单元格组成;换行和换格式都作为换行符。</target>
        </trans-unit>
        <trans-unit id="ff09099a8f170cf0d12905fa7c7238d645a38332" translate="yes" xml:space="preserve">
          <source>The XML element for a struct contains marshaled elements for each of the exported fields of the struct, with these exceptions:</source>
          <target state="translated">一个结构的XML元素包含该结构的每个导出字段的marshaled元素,但有以下例外。</target>
        </trans-unit>
        <trans-unit id="79336ab4324d9f5dfdaefa0128d6e4be21b88b75" translate="yes" xml:space="preserve">
          <source>The []byte arguments are the data from the corresponding debug section in the object file; for example, for an ELF object, abbrev is the contents of the &quot;.debug_abbrev&quot; section.</source>
          <target state="translated">[]字节参数是对象文件中相应的调试部分的数据,例如,对于ELF对象,abbrev是&quot;.debug_abbrev &quot;部分的内容。</target>
        </trans-unit>
        <trans-unit id="76c0ad8d05ede9a06fba9319e4883b6c3aed9f8a" translate="yes" xml:space="preserve">
          <source>The actual read interface needed by NewReader. If the passed in io.Reader does not also have ReadByte, the NewReader will introduce its own buffering.</source>
          <target state="translated">NewReader实际需要的读取接口。如果传入的io.Reader没有ReadByte,NewReader将引入自己的缓冲。</target>
        </trans-unit>
        <trans-unit id="c853d84a15cfc8c913087ccf677e5edf1ca53e04" translate="yes" xml:space="preserve">
          <source>The add operation, implemented by the AddT functions, is the atomic equivalent of:</source>
          <target state="translated">由AddT函数实现的加法运算,其原子等价物为:。</target>
        </trans-unit>
        <trans-unit id="7b4a22ebac17d94f75fe50addbae480c54b8e412" translate="yes" xml:space="preserve">
          <source>The addresses in the to parameter are the SMTP RCPT addresses.</source>
          <target state="translated">to参数中的地址是SMTP RCPT的地址。</target>
        </trans-unit>
        <trans-unit id="fa78f066db9b3a5524ca42a8affe77f75da9d63e" translate="yes" xml:space="preserve">
          <source>The allocs profile is the same as the heap profile but changes the default pprof display to -alloc_space, the total number of bytes allocated since the program began (including garbage-collected bytes).</source>
          <target state="translated">allocs配置文件与堆配置文件相同,但将默认的pprof显示改为-alloc_space,即程序开始后分配的字节总数(包括垃圾回收的字节)。</target>
        </trans-unit>
        <trans-unit id="7b7e2adce610eba0eb46d47752259233e509b5f5" translate="yes" xml:space="preserve">
          <source>The append built-in function appends elements to the end of a slice. If it has sufficient capacity, the destination is resliced to accommodate the new elements. If it does not, a new underlying array will be allocated. Append returns the updated slice. It is therefore necessary to store the result of append, often in the variable holding the slice itself:</source>
          <target state="translated">append内置函数将元素追加到分片的末尾。如果它有足够的容量,目标会被重新分片以容纳新的元素。如果没有,将分配一个新的底层数组。Append返回更新后的分片。因此,有必要将append的结果存储起来,通常存储在持有分片本身的变量中。</target>
        </trans-unit>
        <trans-unit id="319121c4cf28a1a73f5a5d055a29a23993940f46" translate="yes" xml:space="preserve">
          <source>The argument obj must be a pointer to an object allocated by calling new, by taking the address of a composite literal, or by taking the address of a local variable. The argument finalizer must be a function that takes a single argument to which obj's type can be assigned, and can have arbitrary ignored return values. If either of these is not true, SetFinalizer may abort the program.</source>
          <target state="translated">参数obj必须是一个指针,指向一个通过调用new、取复合文字的地址或取局部变量的地址分配的对象。参数finalizer必须是一个函数,它接受一个单一的参数,obj的类型可以被分配给它,并且可以有任意忽略的返回值。如果其中一个不为真,SetFinalizer可能会中止程序。</target>
        </trans-unit>
        <trans-unit id="cd8b4269726f03ea74d83f3435788f2723fca1f6" translate="yes" xml:space="preserve">
          <source>The argument pos must have been returned by a call to Tell on this line table.</source>
          <target state="translated">参数pos必须是通过调用本行表的Tell返回的。</target>
        </trans-unit>
        <trans-unit id="b92996537add2723dc45807913fd63c71882192d" translate="yes" xml:space="preserve">
          <source>The argument to the -run and -bench command-line flags is an unanchored regular expression that matches the test's name. For tests with multiple slash-separated elements, such as subtests, the argument is itself slash-separated, with expressions matching each name element in turn. Because it is unanchored, an empty expression matches any string. For example, using &quot;matching&quot; to mean &quot;whose name contains&quot;:</source>
          <target state="translated">-run 和 -bench 命令行标志的参数是一个与测试名称相匹配的无锚正则表达式。对于有多个斜线分隔元素的测试,比如子测试,参数本身是斜线分隔的,表达式依次匹配每个名称元素。因为它是无锚的,所以空的表达式可以匹配任何字符串。例如,用 &quot;匹配 &quot;来表示 &quot;其名称包含&quot;。</target>
        </trans-unit>
        <trans-unit id="e79a98521fd13244e0b154d938bb00c75c9b0451" translate="yes" xml:space="preserve">
          <source>The base argument must be 0 or a value between 2 and MaxBase. For base 0, the number prefix determines the actual base: A prefix of &amp;ldquo;0b&amp;rdquo; or &amp;ldquo;0B&amp;rdquo; selects base 2, &amp;ldquo;0&amp;rdquo;, &amp;ldquo;0o&amp;rdquo; or &amp;ldquo;0O&amp;rdquo; selects base 8, and &amp;ldquo;0x&amp;rdquo; or &amp;ldquo;0X&amp;rdquo; selects base 16. Otherwise, the selected base is 10 and no prefix is accepted.</source>
          <target state="translated">基本参数必须为0或2到MaxBase之间的值。对于以0为底的数字，数字前缀确定实际的底数：以&amp;ldquo; 0b&amp;rdquo;或&amp;ldquo; 0B&amp;rdquo;为前缀选择2，以&amp;ldquo; 0&amp;rdquo;，&amp;ldquo; 0o&amp;rdquo;或&amp;ldquo; 0O&amp;rdquo;为前缀选择8，以&amp;ldquo; 0x&amp;rdquo;或&amp;ldquo; 0X&amp;rdquo;为前缀选择base16。否则，所选的base为10，并且不接受前缀。</target>
        </trans-unit>
        <trans-unit id="1f5bc3650196f245f397cccfe0b715471a484024" translate="yes" xml:space="preserve">
          <source>The base argument must be 0, 2, 8, 10, or 16. Providing an invalid base argument will lead to a run-time panic.</source>
          <target state="translated">基本参数必须是0、2、8、10或16。提供一个无效的基本参数会导致运行时的恐慌。</target>
        </trans-unit>
        <trans-unit id="999251e457607fde479613cc188e10bb8aa35ffc" translate="yes" xml:space="preserve">
          <source>The behavior of Close after the first call is undefined. Specific implementations may document their own behavior.</source>
          <target state="translated">第一次调用后Close的行为没有定义。具体的实现可以记录自己的行为。</target>
        </trans-unit>
        <trans-unit id="a5501fbd34c66d8be25df49275f9a5880a90030a" translate="yes" xml:space="preserve">
          <source>The benchmark function must run the target code b.N times. During benchmark execution, b.N is adjusted until the benchmark function lasts long enough to be timed reliably. The output</source>
          <target state="translated">基准函数必须运行目标代码b.N次。在基准执行过程中,b.N会被调整,直到基准函数持续足够长的时间来可靠地计时。输出</target>
        </trans-unit>
        <trans-unit id="5d5239994cd75391745c3ffd216fe5a8cda11e2c" translate="yes" xml:space="preserve">
          <source>The bin/ directory holds compiled commands. Each command is named for its source directory, but only using the final element, not the entire path. That is, the command with source in DIR/src/foo/quux is installed into DIR/bin/quux, not DIR/bin/foo/quux. The foo/ is stripped so that you can add DIR/bin to your PATH to get at the installed commands.</source>
          <target state="translated">bin/目录下存放的是编译后的命令。每条命令都以它的源目录命名,但只使用最后一个元素,而不是整个路径。也就是说,源码在DIR/src/foo/quux中的命令被安装到DIR/bin/quux中,而不是DIR/bin/foo/quux。foo/是被剥离的,所以你可以将DIR/bin添加到你的PATH中以获得安装的命令。</target>
        </trans-unit>
        <trans-unit id="5fb2943938d895315eb0861e562b65ec37e4257a" translate="yes" xml:space="preserve">
          <source>The bitSize argument specifies the integer type that the result must fit into. Bit sizes 0, 8, 16, 32, and 64 correspond to int, int8, int16, int32, and int64. If bitSize is below 0 or above 64, an error is returned.</source>
          <target state="translated">bitSize参数指定了结果必须适合的整数类型。位大小为0、8、16、32和64,分别对应int、int8、int16、int32和int64。如果bitSize低于0或高于64,将返回一个错误。</target>
        </trans-unit>
        <trans-unit id="73a023e42c8f449dd9afceb038f53730f09d0f3a" translate="yes" xml:space="preserve">
          <source>The blocksize of MD5 in bytes.</source>
          <target state="translated">MD5的块大小,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="b15f9638286bf74ad9f05789a97346025af52de4" translate="yes" xml:space="preserve">
          <source>The blocksize of SHA-1 in bytes.</source>
          <target state="translated">SHA-1的块大小,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="a7b36663bea360572efce2e38cb3e1eb26ceecf3" translate="yes" xml:space="preserve">
          <source>The blocksize of SHA256 and SHA224 in bytes.</source>
          <target state="translated">SHA256和SHA224的块大小,单位为字节。</target>
        </trans-unit>
        <trans-unit id="97aa274f72b6214d58f8cac268e6604a5f6faa7b" translate="yes" xml:space="preserve">
          <source>The body function will be run in each goroutine. It should set up any goroutine-local state and then iterate until pb.Next returns false. It should not use the StartTimer, StopTimer, or ResetTimer functions, because they have global effect. It should also not call Run.</source>
          <target state="translated">身体函数将在每个goroutine中运行,它应该设置任何goroutine的局部状态,然后迭代直到pb.Next返回false。它应该设置任何goroutine的局部状态,然后迭代直到pb.Next返回false。它不应该使用StartTimer、StopTimer或ResetTimer函数,因为它们具有全局效应。它也不应该调用Run.Next函数,因为它们具有全局效应。</target>
        </trans-unit>
        <trans-unit id="af7dc8ebb6f00c62864546d31e047f12c2a2774d" translate="yes" xml:space="preserve">
          <source>The boolean functions take any zero value to be false and a non-zero value to be true.</source>
          <target state="translated">布林函数取任何零值为假,非零值为真。</target>
        </trans-unit>
        <trans-unit id="0ca3ec8906bf9075e98bceae22793965b445ac42" translate="yes" xml:space="preserve">
          <source>The boundary is usually obtained from the &quot;boundary&quot; parameter of the message's &quot;Content-Type&quot; header. Use mime.ParseMediaType to parse such headers.</source>
          <target state="translated">边界通常由消息的 &quot;Content-Type &quot;头的 &quot;boundary &quot;参数获得。使用mime.ParseMediaType来解析这种头。</target>
        </trans-unit>
        <trans-unit id="93f9cb3d63de38d1cca4d1f9efd9ca872f4716ce" translate="yes" xml:space="preserve">
          <source>The built-in table is small but on unix it is augmented by the local system's mime.types file(s) if available under one or more of these names:</source>
          <target state="translated">内置的表很小,但在unix上,如果本地系统的mime.types文件有一个或多个这样的名字,它就会被增加。</target>
        </trans-unit>
        <trans-unit id="d093a31770ef0176a6cc811f5e90de0295df923b" translate="yes" xml:space="preserve">
          <source>The byte offsets for each file in a file set are mapped into distinct (integer) intervals, one interval [base, base+size] per file. Base represents the first byte in the file, and size is the corresponding file size. A Pos value is a value in such an interval. By determining the interval a Pos value belongs to, the file, its file base, and thus the byte offset (position) the Pos value is representing can be computed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3abe768a37a21ebff40b7c9151a7b3edc6c44e0" translate="yes" xml:space="preserve">
          <source>The calendrical calculations always assume a Gregorian calendar, with no leap seconds.</source>
          <target state="translated">历法计算总是假设采用格里高利历,没有闰秒。</target>
        </trans-unit>
        <trans-unit id="dd3a4f20159bb2231f4a88b4a45f4b772e80ba3c" translate="yes" xml:space="preserve">
          <source>The caller should call Close when finished, to shut it down.</source>
          <target state="translated">呼叫者应在完成后呼叫关闭,将其关闭。</target>
        </trans-unit>
        <trans-unit id="257fee20f0af9c58c89645e121bcb859cd7d2ba2" translate="yes" xml:space="preserve">
          <source>The cap built-in function returns the capacity of v, according to its type:</source>
          <target state="translated">cap内置函数根据v的类型,返回v的容量。</target>
        </trans-unit>
        <trans-unit id="e553ed25dbd923acc16eb919df1e53d3eec5c8ba" translate="yes" xml:space="preserve">
          <source>The certificate is signed by parent. If parent is equal to template then the certificate is self-signed. The parameter pub is the public key of the signee and priv is the private key of the signer.</source>
          <target state="translated">证书是由父代签署的,如果父代等于模板,则证书是自签的。如果parent等于模板,则证书为自签。参数 pub 是签名人的公钥,priv 是签名人的私钥。</target>
        </trans-unit>
        <trans-unit id="dc1a26e65aace69e5a0db7ec46a4e897871c5c8e" translate="yes" xml:space="preserve">
          <source>The chain consists of err itself followed by the sequence of errors obtained by repeatedly calling Unwrap.</source>
          <target state="translated">该链由err本身组成,后面是反复调用Unwrap获得的错误序列。</target>
        </trans-unit>
        <trans-unit id="784fcd80e08909ffdec4906c1c0dba2f7d623904" translate="yes" xml:space="preserve">
          <source>The client must close the response body when finished with it:</source>
          <target state="translated">客户端完成响应体后必须关闭响应体。</target>
        </trans-unit>
        <trans-unit id="7b4dd52e8c63aa6987cf8c226672c7d4edb96f82" translate="yes" xml:space="preserve">
          <source>The close built-in function closes a channel, which must be either bidirectional or send-only. It should be executed only by the sender, never the receiver, and has the effect of shutting down the channel after the last sent value is received. After the last value has been received from a closed channel c, any receive from c will succeed without blocking, returning the zero value for the channel element. The form</source>
          <target state="translated">关闭内置函数关闭了一个通道,这个通道必须是双向的或者只发送的。它应该只由发送者执行,而不是由接收者执行,并且在接收到最后一个发送的值后具有关闭通道的效果。当最后一个值从一个关闭的通道c中接收到后,任何从c中接收的值都会成功而不被阻塞,返回通道元素的零值。形式是</target>
        </trans-unit>
        <trans-unit id="0c580a2c87e0f2186896309d301dc63aad975a10" translate="yes" xml:space="preserve">
          <source>The command must have been started by Start.</source>
          <target state="translated">该命令必须由Start启动。</target>
        </trans-unit>
        <trans-unit id="ef8e35ecfe346ef37bdb6a41007c64b491f6581e" translate="yes" xml:space="preserve">
          <source>The comment prefix &quot;Unordered output:&quot; is like &quot;Output:&quot;, but matches any line order:</source>
          <target state="translated">注释前缀 &quot;无序输出:&quot;和 &quot;输出:&quot;一样,但符合任何行序。</target>
        </trans-unit>
        <trans-unit id="af6f6bfe9472d6cd742ab07f4d13576c62ddc94c" translate="yes" xml:space="preserve">
          <source>The compare-and-swap operation, implemented by the CompareAndSwapT functions, is the atomic equivalent of:</source>
          <target state="translated">比较和交换操作,由CompareAndSwapT函数实现,是原子等价物。</target>
        </trans-unit>
        <trans-unit id="043f79dd25246a384c5fa68242e8b0950e54d69e" translate="yes" xml:space="preserve">
          <source>The comparison functions work on any values whose type Go defines as comparable. For basic types such as integers, the rules are relaxed: size and exact type are ignored, so any integer value, signed or unsigned, may be compared with any other integer value. (The arithmetic value is compared, not the bit pattern, so all negative integers are less than all unsigned integers.) However, as usual, one may not compare an int with a float32 and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53528cbdfa92cb465406c07ac6068163f15d8aff" translate="yes" xml:space="preserve">
          <source>The comparison functions work on basic types only (or named basic types, such as &quot;type Celsius float32&quot;). They implement the Go rules for comparison of values, except that size and exact type are ignored, so any integer value, signed or unsigned, may be compared with any other integer value. (The arithmetic value is compared, not the bit pattern, so all negative integers are less than all unsigned integers.) However, as usual, one may not compare an int with a float32 and so on.</source>
          <target state="translated">比较函数只适用于基本类型(或命名的基本类型,如 &quot;type Celsius float32&quot;)。它们实现了围棋的数值比较规则,除了忽略大小和精确类型之外,所以任何整数值,不管是有符号还是无符号,都可以和任何其他整数值进行比较。(比较的是算术值,而不是位模式,所以所有负整数都小于所有无符号整数)。但一样平常不得将int与float32等进行比较。</target>
        </trans-unit>
        <trans-unit id="3947ad8b82d2733c9797fbc944569005335da23c" translate="yes" xml:space="preserve">
          <source>The compiler handles a Pointer converted to a uintptr in the argument list of a call to a function implemented in assembly by arranging that the referenced allocated object, if any, is retained and not moved until the call completes, even though from the types alone it would appear that the object is no longer needed during the call.</source>
          <target state="translated">编译器处理调用汇编实现的函数的参数列表中的Pointer转换为uintptr时,会安排保留被引用的分配对象(如果有的话),直到调用完成为止,即使单从类型上看,该对象在调用期间似乎不再需要。</target>
        </trans-unit>
        <trans-unit id="fbe6ac33b06dc273e75926ad2490d8b3832a0214" translate="yes" xml:space="preserve">
          <source>The complex built-in function constructs a complex value from two floating-point values. The real and imaginary parts must be of the same size, either float32 or float64 (or assignable to them), and the return value will be the corresponding complex type (complex64 for float32, complex128 for float64).</source>
          <target state="translated">复杂内置函数从两个浮点值中构造一个复杂值。实部和虚部的大小必须相同,要么是float32,要么是float64(或可分配给它们),返回值将是相应的复数类型(float32为complex64,float64为complex128)。</target>
        </trans-unit>
        <trans-unit id="ef38d7c2bab871a13bc3d0543cc12b1189486358" translate="yes" xml:space="preserve">
          <source>The compression level can be DefaultCompression, NoCompression, HuffmanOnly or any integer value between BestSpeed and BestCompression inclusive. The error returned will be nil if the level is valid.</source>
          <target state="translated">压缩级别可以是DefaultCompression、NoCompression、HuffmanOnly或BestSpeed和BestCompression之间的任何整数值。如果压缩级别有效,返回的错误将是nil。</target>
        </trans-unit>
        <trans-unit id="351f67248e4d8a5518193363a02cfe1c83014012" translate="yes" xml:space="preserve">
          <source>The constant UpperLower has an otherwise impossible delta value.</source>
          <target state="translated">常量UpperLower有一个原本不可能的delta值。</target>
        </trans-unit>
        <trans-unit id="8c8706295858fb442cc0b27075b7f68668230e3c" translate="yes" xml:space="preserve">
          <source>The content's Seek method must work: ServeContent uses a seek to the end of the content to determine its size.</source>
          <target state="translated">内容的Seek方法必须工作。ServeContent使用寻求方法来确定内容的大小。</target>
        </trans-unit>
        <trans-unit id="7a49805d773fd718112af263e9a481b6533ee15e" translate="yes" xml:space="preserve">
          <source>The context function will be called with a single argument, a pointer to a struct:</source>
          <target state="translated">调用上下文函数时,只需要一个参数,即指向一个结构的指针。</target>
        </trans-unit>
        <trans-unit id="d756f1871d5d4f318cef847f3f882a9119bd1f8d" translate="yes" xml:space="preserve">
          <source>The conversion rules are:</source>
          <target state="translated">换算规则是:</target>
        </trans-unit>
        <trans-unit id="8b9249f4b562855e188c8c6e04ee31f39d350295" translate="yes" xml:space="preserve">
          <source>The copy built-in function copies elements from a source slice into a destination slice. (As a special case, it also will copy bytes from a string to a slice of bytes.) The source and destination may overlap. Copy returns the number of elements copied, which will be the minimum of len(src) and len(dst).</source>
          <target state="translated">复制内置函数将一个源片断中的元素复制到一个目标片断中。(作为一种特殊情况,它也会将一个字符串中的字节复制到一个字节分片中。)源片和目的片可以重叠。Copy 返回被复制的元素数量,它将是 len(src)和 len(dst)的最小值。</target>
        </trans-unit>
        <trans-unit id="7003f654a24cc0fe7e8417bb3241f59de9fe836b" translate="yes" xml:space="preserve">
          <source>The count determines the number of substrings to return:</source>
          <target state="translated">计数决定了要返回的子串数量。</target>
        </trans-unit>
        <trans-unit id="5dbb8e654b6fb0895661f0c315a08864e55ec239" translate="yes" xml:space="preserve">
          <source>The crypto/tls package only implements some countermeasures against Lucky13 attacks on CBC-mode encryption, and only on SHA1 variants. See &lt;a href=&quot;http://www.isg.rhul.ac.uk/tls/TLStiming.pdf&quot;&gt;http://www.isg.rhul.ac.uk/tls/TLStiming.pdf&lt;/a&gt; and &lt;a href=&quot;https://www.imperialviolet.org/2013/02/04/luckythirteen.html&quot;&gt;https://www.imperialviolet.org/2013/02/04/luckythirteen.html&lt;/a&gt;.</source>
          <target state="translated">crypto / tls软件包仅对CBC模式加密且仅对SHA1变体实施针对Lucky13攻击的一些对策。参见&lt;a href=&quot;http://www.isg.rhul.ac.uk/tls/TLStiming.pdf&quot;&gt;http://www.isg.rhul.ac.uk/tls/TLStiming.pdf&lt;/a&gt;和&lt;a href=&quot;https://www.imperialviolet.org/2013/02/04/luckythirteen.html&quot;&gt;https://www.imperialviolet.org/2013/02/04/luckythirteen.html&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3df95d2be07bff158f354793704b39fa0b17441d" translate="yes" xml:space="preserve">
          <source>The cryptographic operations are implemented using constant-time algorithms.</source>
          <target state="translated">加密运算采用恒时算法实现。</target>
        </trans-unit>
        <trans-unit id="7eab6b01982b7d5d0967ad563265ae830b1ba245" translate="yes" xml:space="preserve">
          <source>The cryptographic operations do not use constant-time algorithms.</source>
          <target state="translated">加密运算不使用恒时算法。</target>
        </trans-unit>
        <trans-unit id="27e1f3bd597aed109fd98be320131ab37e282b69" translate="yes" xml:space="preserve">
          <source>The currently supported key types are *rsa.PublicKey, *ecdsa.PublicKey and ed25519.PublicKey. pub must be a supported key type, and priv must be a crypto.Signer with a supported public key.</source>
          <target state="translated">目前支持的密钥类型有*rsa.PublicKey、*ecdsa.PublicKey和ed25519.PublicKey。 pub必须是支持的密钥类型,priv必须是支持公钥的crypto.Signer。</target>
        </trans-unit>
        <trans-unit id="7a6143ad908fa5d13101f2932405343a9fc3dd21" translate="yes" xml:space="preserve">
          <source>The debug parameter enables additional output. Passing debug=0 prints only the hexadecimal addresses that pprof needs. Passing debug=1 adds comments translating addresses to function names and line numbers, so that a programmer can read the profile without tools.</source>
          <target state="translated">debug参数允许额外的输出。通过debug=0可以只打印pprof需要的十六进制地址。传递 debug=1 会添加注释,将地址翻译成函数名和行号,这样程序员就可以在没有工具的情况下阅读配置文件。</target>
        </trans-unit>
        <trans-unit id="0fb33327b278ec03a78f307167cc6e36a7617010" translate="yes" xml:space="preserve">
          <source>The debug parameter enables additional output. Passing debug=0 writes the gzip-compressed protocol buffer described in &lt;a href=&quot;https://github.com/google/pprof/tree/master/proto#overview&quot;&gt;https://github.com/google/pprof/tree/master/proto#overview&lt;/a&gt;. Passing debug=1 writes the legacy text format with comments translating addresses to function names and line numbers, so that a programmer can read the profile without tools.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcfadeab38a63378303009891c62ea08d3a9f648" translate="yes" xml:space="preserve">
          <source>The decision can also be forced while building the Go source tree by setting the netgo or netcgo build tag.</source>
          <target state="translated">在构建Go源代码树时,也可以通过设置netgo或netcgo构建标签来强制决定。</target>
        </trans-unit>
        <trans-unit id="e55a5ed5aee48109c8f556983bc2b6ba47049c1e" translate="yes" xml:space="preserve">
          <source>The decoded form returned by the Reader's Read method rewrites the &quot;\r\n&quot; line endings into the simpler &quot;\n&quot;, removes leading dot escapes if present, and stops with error io.EOF after consuming (and discarding) the end-of-sequence line.</source>
          <target state="translated">由Reader's Read方法返回的解码形式将&quot;\r\n &quot;行结尾重写成更简单的&quot;\n&quot;,如果存在,则删除前导点转义,并在消耗(并丢弃)序列末行后以错误io.EOF停止。</target>
        </trans-unit>
        <trans-unit id="ade9eaf300f62ddbbf2f36e130c2f06e8467d26d" translate="yes" xml:space="preserve">
          <source>The decoder introduces its own buffering and may read data from r beyond the JSON values requested.</source>
          <target state="translated">解码器引入了自己的缓冲,可能会从r中读取超出请求的JSON值的数据。</target>
        </trans-unit>
        <trans-unit id="500a9025cc154f7f8f86d7b577b23c5a4330caf0" translate="yes" xml:space="preserve">
          <source>The default HTTP/1.x and HTTP/2 ResponseWriter implementations support Flusher, but ResponseWriter wrappers may not. Handlers should always test for this ability at runtime.</source>
          <target state="translated">默认的 HTTP/1.x 和 HTTP/2 ResponseWriter 实现支持 Flusher,但 ResponseWriter 包装器可能不支持。处理程序应该总是在运行时测试这个能力。</target>
        </trans-unit>
        <trans-unit id="dbfff1190b706ff9c82ad5d939db53ac5e19b8d5" translate="yes" xml:space="preserve">
          <source>The default ResponseWriter for HTTP/1.x connections supports Hijacker, but HTTP/2 connections intentionally do not. ResponseWriter wrappers may also not support Hijacker. Handlers should always test for this ability at runtime.</source>
          <target state="translated">HTTP/1.x连接的默认ResponseWriter支持Hijacker,但HTTP/2连接故意不支持。ResponseWriter 包装器也可能不支持 Hijacker。处理程序应该总是在运行时测试这种能力。</target>
        </trans-unit>
        <trans-unit id="29a4bf6e98ccc92440a0810fcad76a8019aec7ff" translate="yes" xml:space="preserve">
          <source>The default behavior is to unlink the socket file only when package net created it. That is, when the listener and the underlying socket file were created by a call to Listen or ListenUnix, then by default closing the listener will remove the socket file. but if the listener was created by a call to FileListener to use an already existing socket file, then by default closing the listener will not remove the socket file.</source>
          <target state="translated">默认的行为是只有在包net创建套接字文件时才会解除链接。也就是说,当监听器和底层的套接字文件是通过调用Listen或ListenUnix来创建的,那么默认情况下关闭监听器就会删除套接字文件,但是如果监听器是通过调用FileListener来使用已经存在的套接字文件,那么默认情况下关闭监听器就不会删除套接字文件。</target>
        </trans-unit>
        <trans-unit id="f3bd4ca778e016b570e20fa99bcd057793129198" translate="yes" xml:space="preserve">
          <source>The default format for %v is:</source>
          <target state="translated">%v的默认格式是:</target>
        </trans-unit>
        <trans-unit id="e5fbfa4bdd17cdbfb6f18b5cea533902d960ee26" translate="yes" xml:space="preserve">
          <source>The default max idle connections is currently 2. This may change in a future release.</source>
          <target state="translated">目前默认的最大空闲连接数为2,这可能会在未来的版本中改变。</target>
        </trans-unit>
        <trans-unit id="385f08ab994be40fdde70d56e38ccb63bb65d078" translate="yes" xml:space="preserve">
          <source>The default set of command-line flags is controlled by top-level functions. The FlagSet type allows one to define independent sets of flags, such as to implement subcommands in a command-line interface. The methods of FlagSet are analogous to the top-level functions for the command-line flag set.</source>
          <target state="translated">默认的命令行标志集由顶层函数控制。FlagSet类型允许人们定义独立的标志集,例如在命令行接口中实现子命令。FlagSet的方法类似于命令行标志集的顶层函数。</target>
        </trans-unit>
        <trans-unit id="a05d93e44d2bb1f3518c258e77ecac2e52df5b7c" translate="yes" xml:space="preserve">
          <source>The define action names the template being created by providing a string constant. Here is a simple example:</source>
          <target state="translated">define操作通过提供一个字符串常量来命名正在创建的模板。下面是一个简单的例子。</target>
        </trans-unit>
        <trans-unit id="1752a2a854e41ac9841751567fab2d2b00d5fd9e" translate="yes" xml:space="preserve">
          <source>The defined file mode bits are the most significant bits of the FileMode. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added.</source>
          <target state="translated">定义的文件模式位是FileMode中最重要的位。九个最不重要的位是标准的Unix rwxrwxrwx权限。这些位的值应该被认为是公共API的一部分,可以在线协议或磁盘表示中使用:虽然可能会添加新的位,但它们不能被改变。</target>
        </trans-unit>
        <trans-unit id="5cff7ee8fa31e3f6a6739a2dee232b717a523c6f" translate="yes" xml:space="preserve">
          <source>The delete built-in function deletes the element with the specified key (m[key]) from the map. If m is nil or there is no such element, delete is a no-op.</source>
          <target state="translated">delete 内建函数从地图中删除指定键 (m[key])的元素。如果 m 为 nil 或没有这样的元素,delete 是一个 no-op。</target>
        </trans-unit>
        <trans-unit id="7be6f8c0500d37b62c7237cb3172e8612a1be7ae" translate="yes" xml:space="preserve">
          <source>The dictionary may be nil. If not, its contents should not be modified until the Writer is closed.</source>
          <target state="translated">字典可以是nil。如果不是,在关闭Writer之前,它的内容不应该被修改。</target>
        </trans-unit>
        <trans-unit id="bc9a068b7cdbaff9efc9114bb2316dc6eaf9165d" translate="yes" xml:space="preserve">
          <source>The direction of a channel is indicated by one of these constants.</source>
          <target state="translated">通道的方向由这些常数之一表示。</target>
        </trans-unit>
        <trans-unit id="46b217ce09d8bd67e6158257fb40490e88a671dd" translate="yes" xml:space="preserve">
          <source>The direction of a channel type is indicated by a bit mask including one or both of the following constants.</source>
          <target state="translated">通道类型的方向由包括以下一个或两个常数的位掩码表示:</target>
        </trans-unit>
        <trans-unit id="7dfb11306d6f3241074422bcaa067904172344cc" translate="yes" xml:space="preserve">
          <source>The directory is neither guaranteed to exist nor have accessible permissions.</source>
          <target state="translated">该目录既不保证存在,也没有访问权限。</target>
        </trans-unit>
        <trans-unit id="565d684eeda7e9edb8f7bb0c103897df1854d973" translate="yes" xml:space="preserve">
          <source>The documentation for http.Request.Write details which fields of req are included in the dump.</source>
          <target state="translated">http.Request.Write的文档详细说明了转储中包含了req的哪些字段。</target>
        </trans-unit>
        <trans-unit id="07211f6185f4e6de4337f341c2cdb69d4cc499c7" translate="yes" xml:space="preserve">
          <source>The documentation here focuses on the security features of the package. For information about how to program the templates themselves, see the documentation for text/template.</source>
          <target state="translated">这里的文档主要是关于软件包的安全功能。关于如何对模板本身进行编程的信息,请参阅text/template的文档。</target>
        </trans-unit>
        <trans-unit id="155a6f0a50ad424a0f77dec85fedb05aad3e6814" translate="yes" xml:space="preserve">
          <source>The driver interface has evolved over time. Drivers should implement Connector and DriverContext interfaces. The Connector.Connect and Driver.Open methods should never return ErrBadConn. ErrBadConn should only be returned from Validator, SessionResetter, or a query method if the connection is already in an invalid (e.g. closed) state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d608ae58f506a273826ac24fbe8a6e832c7cfa18" translate="yes" xml:space="preserve">
          <source>The earlier index entries are the indices of the embedded fields implicitly traversed to get from (the type of) x to f, starting at embedding depth 0.</source>
          <target state="translated">前面的索引项是隐式遍历从(类型)x到f的嵌入字段的索引,从嵌入深度0开始。</target>
        </trans-unit>
        <trans-unit id="9969cd1fd12276c81b2d25b52e841cee1f38a6af" translate="yes" xml:space="preserve">
          <source>The earlier index entries are the indices of the embedded struct fields traversed to get to the found entry, starting at depth 0.</source>
          <target state="translated">前面的索引条目是为了得到找到的条目而遍历的嵌入结构域的索引,从深度0开始。</target>
        </trans-unit>
        <trans-unit id="55f7215f8e7a1256ecd44a2e72424fdc36866f77" translate="yes" xml:space="preserve">
          <source>The encoded form is:</source>
          <target state="translated">编码形式为:</target>
        </trans-unit>
        <trans-unit id="58738aa6dbb46f39a2d83f07741091a7022a1024" translate="yes" xml:space="preserve">
          <source>The encoding handles 4-byte chunks, using a special encoding for the last fragment, so Encode is not appropriate for use on individual blocks of a large data stream. Use NewEncoder() instead.</source>
          <target state="translated">编码处理4字节的块,对最后一个片段使用特殊的编码,所以Encode不适合用于大型数据流的单个块。使用NewEncoder()代替。</target>
        </trans-unit>
        <trans-unit id="352cf3ce7f63c6b9e4ef698575b243f2f7eab5f4" translate="yes" xml:space="preserve">
          <source>The encoding of each struct field can be customized by the format string stored under the &quot;json&quot; key in the struct field's tag. The format string gives the name of the field, possibly followed by a comma-separated list of options. The name may be empty in order to specify options without overriding the default field name.</source>
          <target state="translated">每个结构体字段的编码可以通过存储在结构体字段标签中 &quot;json &quot;键下的格式字符串来定制。格式字符串给出了字段的名称,后面可能是一个以逗号分隔的选项列表。为了在不覆盖默认字段名的情况下指定选项,名称可以为空。</target>
        </trans-unit>
        <trans-unit id="17b6791f4c87db95fbf5fcc1580f710e0b98bcc7" translate="yes" xml:space="preserve">
          <source>The encoding pads the output to a multiple of 4 bytes, so Encode is not appropriate for use on individual blocks of a large data stream. Use NewEncoder() instead.</source>
          <target state="translated">编码将输出填充到4字节的倍数,因此Encode不适合用于大型数据流的单个块。使用NewEncoder()代替。</target>
        </trans-unit>
        <trans-unit id="f9b92d6b313993a8570c418851ae0a82ee1d08b2" translate="yes" xml:space="preserve">
          <source>The encoding pads the output to a multiple of 8 bytes, so Encode is not appropriate for use on individual blocks of a large data stream. Use NewEncoder() instead.</source>
          <target state="translated">编码将输出填充到8字节的倍数,因此Encode不适合用于大型数据流的单个块。使用NewEncoder()代替。</target>
        </trans-unit>
        <trans-unit id="f21e6b7ab20b84c2608ae859489552989b9c9ded" translate="yes" xml:space="preserve">
          <source>The entire test file is presented as the example when it contains a single example function, at least one other function, type, variable, or constant declaration, and no test or benchmark functions.</source>
          <target state="translated">当整个测试文件包含一个示例函数、至少一个其他函数、类型、变量或常量声明,并且没有测试或基准函数时,整个测试文件将作为示例呈现。</target>
        </trans-unit>
        <trans-unit id="8a5b41cf040dd894c5f5818385e864bb8f5f4256" translate="yes" xml:space="preserve">
          <source>The environment values may be either a complete URL or a &quot;host[:port]&quot;, in which case the &quot;http&quot; scheme is assumed. An error is returned if the value is a different form.</source>
          <target state="translated">环境值可以是一个完整的URL,也可以是 &quot;host[:port]&quot;,在这种情况下,假定使用 &quot;http &quot;方案。如果值是不同的形式,将返回一个错误。</target>
        </trans-unit>
        <trans-unit id="63d88a909a5214b04c717d2600360e2bf8c34633" translate="yes" xml:space="preserve">
          <source>The error built-in interface type is the conventional interface for representing an error condition, with the nil value representing no error.</source>
          <target state="translated">错误内置接口类型是表示错误条件的常规接口,nil值代表没有错误。</target>
        </trans-unit>
        <trans-unit id="057113f0f11fb7ab423f9c5529d153f0951fafc6" translate="yes" xml:space="preserve">
          <source>The error is EOF only if no bytes were read. If an EOF happens after reading some but not all the bytes, Read returns ErrUnexpectedEOF.</source>
          <target state="translated">只有在没有读到字节的情况下,才会发生EOF错误。如果在读取部分但不是全部字节后发生EOF,Read返回ErrUnexpectedEOF。</target>
        </trans-unit>
        <trans-unit id="53b8936240ed1387970343e072546b9e5c4ce38c" translate="yes" xml:space="preserve">
          <source>The errors that ParseComplex returns have concrete type *NumError and include err.Num = s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e19a9195a1344f79f24fd7f396a97d73332aa946" translate="yes" xml:space="preserve">
          <source>The errors that ParseFloat returns have concrete type *NumError and include err.Num = s.</source>
          <target state="translated">ParseFloat返回的错误有具体的类型*NumError,包括err.Num=s。</target>
        </trans-unit>
        <trans-unit id="235cee0ee469905c73061c3ebbf12b0afd87e749" translate="yes" xml:space="preserve">
          <source>The errors that ParseInt returns have concrete type *NumError and include err.Num = s. If s is empty or contains invalid digits, err.Err = ErrSyntax and the returned value is 0; if the value corresponding to s cannot be represented by a signed integer of the given size, err.Err = ErrRange and the returned value is the maximum magnitude integer of the appropriate bitSize and sign.</source>
          <target state="translated">ParseInt返回的错误有具体的类型*NumError,包括err.Num=s,如果s为空或包含无效数字,err.Err=ErrSyntax,返回值为0;如果s对应的值不能用给定大小的有符号整数表示,err.Err=ErrRange,返回值为相应位数大小和符号的最大幅度整数。</target>
        </trans-unit>
        <trans-unit id="1079b4c215daaeaddfd42a5c24ae40421a24ca31" translate="yes" xml:space="preserve">
          <source>The exact method of division of a binary into separate Objs is an internal detail of the symbol table format.</source>
          <target state="translated">将二进制划分为独立的Objs的具体方法是符号表格式的内部细节。</target>
        </trans-unit>
        <trans-unit id="704442846624164254cefb0621f909b9f8e7b255" translate="yes" xml:space="preserve">
          <source>The executable example for Time.Format demonstrates the working of the layout string in detail and is a good reference.</source>
          <target state="translated">Time.Format的可执行示例详细演示了布局字符串的工作原理,是一个很好的参考。</target>
        </trans-unit>
        <trans-unit id="d1e6774ae13e892b5b495469c8177e657ea29b91" translate="yes" xml:space="preserve">
          <source>The execution trace captures a wide range of execution events such as goroutine creation/blocking/unblocking, syscall enter/exit/block, GC-related events, changes of heap size, processor start/stop, etc. A precise nanosecond-precision timestamp and a stack trace is captured for most events. The generated trace can be interpreted using `go tool trace`.</source>
          <target state="translated">执行跟踪可以捕获广泛的执行事件,如goroutine的创建/阻塞/取消阻塞,系统调用进入/退出/阻塞,GC相关事件,堆大小的变化,处理器的启动/停止等。大多数事件都会被捕获一个精确的纳秒级时间戳和一个堆栈跟踪。生成的跟踪可以用 &quot;go tool trace &quot;来解释。</target>
        </trans-unit>
        <trans-unit id="0bb8da556b82de3d2273cd84d139d0610336a88a" translate="yes" xml:space="preserve">
          <source>The familiar base-setting prefixes 0b (binary), 0o and 0 (octal), and 0x (hexadecimal) are accepted when scanning integers without a format or with the %v verb, as are digit-separating underscores.</source>
          <target state="translated">当扫描没有格式的整数或使用%v动词时,可以接受熟悉的定基前缀0b(二进制)、0o和0(八进制)以及0x(十六进制),也可以接受以数字分隔的下划线。</target>
        </trans-unit>
        <trans-unit id="f9ffee1670410a5e7cd11d5f1bee248ae5a136bc" translate="yes" xml:space="preserve">
          <source>The field semantics differ slightly between client and server usage. In addition to the notes on the fields below, see the documentation for Request.Write and RoundTripper.</source>
          <target state="translated">字段的语义在客户端和服务器的用法上略有不同。除了下面关于字段的说明外,请看Request.Write和RoundTripper的文档。</target>
        </trans-unit>
        <trans-unit id="055e51145f588ea85435a4c1863b09a1b1141496" translate="yes" xml:space="preserve">
          <source>The file name table of a compilation unit is not fixed. Files returns the file table as of the current position in the line table. This may contain more entries than the file table at an earlier position in the line table, though existing entries never change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc18f2dd0c8c98e57212ed20f1a2ef2dc2747c6d" translate="yes" xml:space="preserve">
          <source>The file's data can then be read into a slice of bytes. Read and Write take their byte counts from the length of the argument slice.</source>
          <target state="translated">然后文件的数据可以被读入一个字节片。读和写从参数片的长度中提取字节数。</target>
        </trans-unit>
        <trans-unit id="bf3df07f08dd9391973ec022887d04b86f02f1b9" translate="yes" xml:space="preserve">
          <source>The filepath package uses either forward slashes or backslashes, depending on the operating system. To process paths such as URLs that always use forward slashes regardless of the operating system, see the path package.</source>
          <target state="translated">文件路径包根据操作系统的不同,使用正斜线或反斜线。要处理诸如URL等无论操作系统如何都使用正斜线的路径,请参阅路径包。</target>
        </trans-unit>
        <trans-unit id="e2a5de21556a23ce2ab6268f51afe1d5e198e5ff" translate="yes" xml:space="preserve">
          <source>The finalizer is scheduled to run at some arbitrary time after the program can no longer reach the object to which obj points. There is no guarantee that finalizers will run before a program exits, so typically they are useful only for releasing non-memory resources associated with an object during a long-running program. For example, an os.File object could use a finalizer to close the associated operating system file descriptor when a program discards an os.File without calling Close, but it would be a mistake to depend on a finalizer to flush an in-memory I/O buffer such as a bufio.Writer, because the buffer would not be flushed at program exit.</source>
          <target state="translated">定盘器被安排在程序无法再到达obj指向的对象后的某个任意时间运行。不能保证最终确定器会在程序退出之前运行,所以通常它们只在长期运行的程序中释放与对象相关的非内存资源时有用。例如,一个 os.File 对象可以在程序丢弃 os.File 而不调用 Close 时,使用定标器来关闭相关的操作系统文件描述符,但是依靠定标器来刷新内存中的 I/O 缓冲区(如 bufio.Writer)是错误的,因为缓冲区不会在程序退出时被刷新。</target>
        </trans-unit>
        <trans-unit id="b1e301ef4e8e6bbc26fb8b640366f5d912e010bd" translate="yes" xml:space="preserve">
          <source>The first call to ReadContinuedLine will return &quot;Line 1 continued...&quot; and the second will return &quot;Line 2&quot;.</source>
          <target state="translated">第一次调用ReadContinuedLine将返回 &quot;Line 1 continued...&quot;,第二次将返回 &quot;Line 2&quot;。</target>
        </trans-unit>
        <trans-unit id="aa248e4cf567dddf42fcb3d7320a5fbdd025b032" translate="yes" xml:space="preserve">
          <source>The first call will cache the current user information. Subsequent calls will return the cached value and will not reflect changes to the current user.</source>
          <target state="translated">第一次调用将缓存当前用户信息。随后的调用将返回缓存的值,不会反映当前用户的变化。</target>
        </trans-unit>
        <trans-unit id="da786a1e6a510514415594e5971ba9d3b0ef0c66" translate="yes" xml:space="preserve">
          <source>The first key will be used when creating new tickets, while all keys can be used for decrypting tickets. It is safe to call this function while the server is running in order to rotate the session ticket keys. The function will panic if keys is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9bea105d5515e425130c674b9a6d60024d04428" translate="yes" xml:space="preserve">
          <source>The first step to profiling a Go program is to enable profiling. Support for profiling benchmarks built with the standard testing package is built into go test. For example, the following command runs benchmarks in the current directory and writes the CPU and memory profiles to cpu.prof and mem.prof:</source>
          <target state="translated">对Go程序进行剖析的第一步是启用剖析。go test中内置了对标准测试包所构建的基准的剖析支持。例如,以下命令在当前目录下运行基准,并将CPU和内存配置文件写入cpu.prof和mem.prof中。</target>
        </trans-unit>
        <trans-unit id="436dd80ca68673a729fce026c246571c6f61d421" translate="yes" xml:space="preserve">
          <source>The first time the function is called for a particular traceback, all the fields except PC will be 0. The function should fill in the other fields if possible, setting them to 0/nil if the information is not available. The Data field may be used to store any useful information across calls. The More field should be set to non-zero if there is more information for this PC, zero otherwise. If More is set non-zero, the function will be called again with the same PC, and may return different information (this is intended for use with inlined functions). If More is zero, the function will be called with the next PC value in the traceback. When the traceback is complete, the function will be called once more with PC set to zero; this may be used to free any information. Each call will leave the fields of the struct set to the same values they had upon return, except for the PC field when the More field is zero. The function must not keep a copy of the struct pointer between calls.</source>
          <target state="translated">第一次调用该函数时,除了PC外,所有字段都为0,如果可能的话,该函数应该填写其他字段,如果信息不可用,则将其设置为0/nil。数据字段可用于存储跨调用的任何有用信息。如果该PC有更多信息,则More字段应设置为非零,否则为零。如果More字段被设置为非零,函数将对同一台PC再次调用,并可能返回不同的信息(这是为了与内联函数一起使用)。如果More为零,函数将用回溯中的下一个PC值进行调用。当回溯完成后,函数将被再次调用,PC设置为0;这可以用来释放任何信息。每次调用都会使结构体的字段设置为返回时的相同值,但当More字段为零时,PC字段除外。该函数在两次调用之间不得保留结构体指针的副本。</target>
        </trans-unit>
        <trans-unit id="1c12332b1a7f816e653faac5972323a1a86f4075" translate="yes" xml:space="preserve">
          <source>The fmt package's Errorf function lets us use the package's formatting features to create descriptive error messages.</source>
          <target state="translated">fmt软件包的Errorf功能让我们可以使用软件包的格式化功能来创建描述性的错误信息。</target>
        </trans-unit>
        <trans-unit id="daed29ba07a438b86a35f4ffceadf0ee0b2962c4" translate="yes" xml:space="preserve">
          <source>The following environment variables ($name or %name%, depending on the host operating system) control the run-time behavior of Go programs. The meanings and use may change from release to release.</source>
          <target state="translated">以下环境变量($name 或 %name%,取决于主机操作系统)控制围棋程序的运行时行为。这些变量的含义和用途可能会随着版本的不同而改变。</target>
        </trans-unit>
        <trans-unit id="d76a76a5baf9188ebac1a65a2793d054e97d3403" translate="yes" xml:space="preserve">
          <source>The following example shows how to maintain a scalable frequently read, but infrequently updated data structure using copy-on-write idiom.</source>
          <target state="translated">下面的例子展示了如何使用copy-on-write成语来维护一个可扩展的经常读取,但不经常更新的数据结构。</target>
        </trans-unit>
        <trans-unit id="3f0a6fe70878d3ed973c5f4c4f9e11a4b37e3d2a" translate="yes" xml:space="preserve">
          <source>The following example shows how to use Value for periodic program config updates and propagation of the changes to worker goroutines.</source>
          <target state="translated">下面的例子显示了如何使用Value进行周期性的程序配置更新,并将变化传播给worker goroutine。</target>
        </trans-unit>
        <trans-unit id="2cccb14470014df050daea92c16a16fd189e8367" translate="yes" xml:space="preserve">
          <source>The following forms are permitted:</source>
          <target state="translated">允许采用以下形式:</target>
        </trans-unit>
        <trans-unit id="f535af253987553534ec7b604b13bea0bafaf89a" translate="yes" xml:space="preserve">
          <source>The following key types are currently supported: *rsa.PrivateKey, *ecdsa.PrivateKey and ed25519.PrivateKey. Unsupported key types result in an error.</source>
          <target state="translated">目前支持以下密钥类型。*rsa.PrivateKey、*ecdsa.PrivateKey和ed25519.PrivateKey。不支持的密钥类型会导致错误。</target>
        </trans-unit>
        <trans-unit id="db7a430d5590cf9adf90b727249460131ab84e28" translate="yes" xml:space="preserve">
          <source>The following key types are currently supported: *rsa.PublicKey, *ecdsa.PublicKey and ed25519.PublicKey. Unsupported key types result in an error.</source>
          <target state="translated">目前支持以下密钥类型。*rsa.PublicKey、*ecdsa.PublicKey和ed25519.PublicKey。不支持的密钥类型会导致一个错误。</target>
        </trans-unit>
        <trans-unit id="575dc13df3822635a20233f0d934b2828c4cbcc1" translate="yes" xml:space="preserve">
          <source>The following patterns involving Pointer are valid. Code not using these patterns is likely to be invalid today or to become invalid in the future. Even the valid patterns below come with important caveats.</source>
          <target state="translated">以下涉及Pointer的模式是有效的。没有使用这些模式的代码很可能在今天是无效的,或者在将来也是无效的。即使是下面的有效模式也有重要的注意事项。</target>
        </trans-unit>
        <trans-unit id="ea1b5d42ec809a44272262968add764fd0382aa5" translate="yes" xml:space="preserve">
          <source>The following table captures the capabilities of each format:</source>
          <target state="translated">下表列出了每种格式的能力。</target>
        </trans-unit>
        <trans-unit id="00ec28c9d7b575a36a11e5441e71a7350e3c8790" translate="yes" xml:space="preserve">
          <source>The following tags on struct fields have special meaning to Unmarshal:</source>
          <target state="translated">以下结构字段的标签对Unmarshal有特殊意义。</target>
        </trans-unit>
        <trans-unit id="b74a12e0ee03ebdd96a1e5698ef65e80645b4c11" translate="yes" xml:space="preserve">
          <source>The format fmt and precision prec have the same meaning as in FormatFloat. It rounds the result assuming that the original was obtained from a complex value of bitSize bits, which must be 64 for complex64 and 128 for complex128.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89924ba6250a79536c8a80bb6ca7f28f4193a60a" translate="yes" xml:space="preserve">
          <source>The format fmt is one of 'b' (-ddddp&amp;plusmn;ddd, a binary exponent), 'e' (-d.dddde&amp;plusmn;dd, a decimal exponent), 'E' (-d.ddddE&amp;plusmn;dd, a decimal exponent), 'f' (-ddd.dddd, no exponent), 'g' ('e' for large exponents, 'f' otherwise), 'G' ('E' for large exponents, 'f' otherwise), 'x' (-0xd.ddddp&amp;plusmn;ddd, a hexadecimal fraction and binary exponent), or 'X' (-0Xd.ddddP&amp;plusmn;ddd, a hexadecimal fraction and binary exponent).</source>
          <target state="translated">格式fmt是'b'（-ddddp&amp;plusmn;ddd，二进制指数），'e'（-d.dddde&amp;plusmn;dd，十进制指数），'E'（-d.ddddE&amp;plusmn;dd，十进制指数）之一），&amp;ldquo; f&amp;rdquo;（-ddd.dddd，无指数），&amp;ldquo; g&amp;rdquo;（&amp;ldquo; e&amp;rdquo;代表大指数，否则为&amp;ldquo; f&amp;rdquo;），&amp;ldquo; G&amp;rdquo;（&amp;ldquo; E&amp;rdquo;代表大指数，否则为&amp;ldquo; f&amp;rdquo;），&amp;ldquo; x'（-0xd.ddddp&amp;plusmn;ddd，十六进制分数和二进制指数）或'X'（-0Xd.ddddP&amp;plusmn;ddd，十六进制分数和二进制指数）。</target>
        </trans-unit>
        <trans-unit id="f76288ef40c91d2e63963863e41869428543cdec" translate="yes" xml:space="preserve">
          <source>The formats 2, _2, and 02 are unpadded, space-padded, and zero-padded day of month. The formats __2 and 002 are space-padded and zero-padded three-character day of year; there is no unpadded day of year format.</source>
          <target state="translated">格式2、_2、02为无垫、有空格、零垫的月日。格式 __2 和 002 是空格填充和零填充的三字符年月日,没有无填充的年月日格式。</target>
        </trans-unit>
        <trans-unit id="1f639fab95b9f7e1b599aa2a265c8aee60d79d31" translate="yes" xml:space="preserve">
          <source>The formfeed character acts like a newline but it also terminates all columns in the current line (effectively calling Flush). Tab- terminated cells in the next line start new columns. Unless found inside an HTML tag or inside an escaped text segment, formfeed characters appear as newlines in the output.</source>
          <target state="translated">formfeed字符的作用类似于换行,但它也终止了当前行中的所有列(有效地调用Flush)。下一行中Tab终止的单元格开始新的列。除非在HTML标签内或转义文本段内发现,否则formfeed字符在输出中会作为换行符出现。</target>
        </trans-unit>
        <trans-unit id="6c966e528430f5e8f847d49a893afb0bf98faff4" translate="yes" xml:space="preserve">
          <source>The function is never called with an empty data slice unless atEOF is true. If atEOF is true, however, data may be non-empty and, as always, holds unprocessed text.</source>
          <target state="translated">除非 atEOF 为真,否则该函数不会在数据片为空的情况下被调用。但是,如果atEOF为真,数据可能是非空的,并且一如既往地保存未处理的文本。</target>
        </trans-unit>
        <trans-unit id="bb0e0b68d3018d9e09f97b972052414d315bce69" translate="yes" xml:space="preserve">
          <source>The function may return early (before the entire result is written) and return a formatting error, for instance due to an incorrect AST.</source>
          <target state="translated">该函数可能会提前返回(在整个结果写入之前),并返回一个格式化错误,例如由于一个错误的AST。</target>
        </trans-unit>
        <trans-unit id="f82da77fd5615642bd9b732fd9350b4315a5dea8" translate="yes" xml:space="preserve">
          <source>The function panics if the provided interface is not a slice.</source>
          <target state="translated">如果所提供的接口不是分片,该函数就会恐慌。</target>
        </trans-unit>
        <trans-unit id="4a5f1ee976b1b1f94f517d27ee9603ea7e455c85" translate="yes" xml:space="preserve">
          <source>The function panics if z &amp;lt; 0. The value of z is undefined in that case.</source>
          <target state="translated">如果z &amp;lt;0，函数将出现紧急情况。在这种情况下，z的值不确定。</target>
        </trans-unit>
        <trans-unit id="d83c73a08df2f74bc57a61017e163cb8c0547bd2" translate="yes" xml:space="preserve">
          <source>The functions in this package allow a program to change the way Go programs handle signals.</source>
          <target state="translated">本包中的函数允许程序改变围棋程序处理信号的方式。</target>
        </trans-unit>
        <trans-unit id="c621ec21270aea7b19125c0f31ddb234d896d492" translate="yes" xml:space="preserve">
          <source>The fundamental interface is called Image. An Image contains colors, which are described in the image/color package.</source>
          <target state="translated">基本的接口叫做Image。一个Image包含颜色,这些颜色在image/color包中有描述。</target>
        </trans-unit>
        <trans-unit id="3e95d4d070ede79d500e36cf5c238c24c3001c9d" translate="yes" xml:space="preserve">
          <source>The gc runtime imposes a limit of 64 kB on channel element types. If t's size is equal to or exceeds this limit, ChanOf panics.</source>
          <target state="translated">gc运行时对通道元素类型施加了64 kB的限制,如果t的大小等于或超过这个限制,ChanOf就会惊慌失措。如果t的大小等于或超过这个限制,ChanOf就会崩溃。</target>
        </trans-unit>
        <trans-unit id="0b2d97be3dbe373d310641088f98b283534b1dcf" translate="yes" xml:space="preserve">
          <source>The general form represented is:</source>
          <target state="translated">代表的一般形式是:</target>
        </trans-unit>
        <trans-unit id="e818a1eefc582415dc190e3c644893b44536faa0" translate="yes" xml:space="preserve">
          <source>The gzip file stores a header giving metadata about the compressed file. That header is exposed as the fields of the Writer and Reader structs.</source>
          <target state="translated">gzip文件存储了一个头,给出了压缩文件的元数据。这个头以Writer和Reader结构的字段形式出现。</target>
        </trans-unit>
        <trans-unit id="d55115d1e7ac93246c076c18ab9827900516047e" translate="yes" xml:space="preserve">
          <source>The handler is typically nil, in which case the DefaultServeMux is used.</source>
          <target state="translated">该处理程序通常为nil,在这种情况下,使用DefaultServeMux。</target>
        </trans-unit>
        <trans-unit id="19708f111db26407005495f3eafb1c4b25430791" translate="yes" xml:space="preserve">
          <source>The handling of spaces and newlines differs from that of C's scanf family: in C, newlines are treated as any other space, and it is never an error when a run of spaces in the format string finds no spaces to consume in the input.</source>
          <target state="translated">对空格和换行的处理与C语言的scanf系列不同:在C语言中,换行与其他空格一样,当格式字符串中的空格运行时,发现输入中没有空格消耗时,绝不会出错。</target>
        </trans-unit>
        <trans-unit id="e507edab6e88a1637c49a21b0db27e0ccae398e0" translate="yes" xml:space="preserve">
          <source>The heap dump format is defined at &lt;a href=&quot;https://golang.org/s/go15heapdump&quot;&gt;https://golang.org/s/go15heapdump&lt;/a&gt;.</source>
          <target state="translated">堆转储格式在&lt;a href=&quot;https://golang.org/s/go15heapdump&quot;&gt;https://golang.org/s/go15heapdump&lt;/a&gt;上定义。</target>
        </trans-unit>
        <trans-unit id="8b009325b4464d415a87b0e6547346de038d0c47" translate="yes" xml:space="preserve">
          <source>The heap profile reports statistics as of the most recently completed garbage collection; it elides more recent allocation to avoid skewing the profile away from live data and toward garbage. If there has been no garbage collection at all, the heap profile reports all known allocations. This exception helps mainly in programs running without garbage collection enabled, usually for debugging purposes.</source>
          <target state="translated">堆配置文件报告了最近完成的垃圾收集的统计数据;它省略了最近的分配,以避免使配置文件偏离实时数据而偏向垃圾。如果根本没有进行过垃圾收集,堆配置文件会报告所有已知的分配情况。这种例外情况主要是在没有启用垃圾收集的情况下运行的程序中起帮助作用,通常是为了调试的目的。</target>
        </trans-unit>
        <trans-unit id="421272feeab82226233835220df71bd5575dfeaf" translate="yes" xml:space="preserve">
          <source>The heap profile tracks both the allocation sites for all live objects in the application memory and for all objects allocated since the program start. Pprof's -inuse_space, -inuse_objects, -alloc_space, and -alloc_objects flags select which to display, defaulting to -inuse_space (live objects, scaled by size).</source>
          <target state="translated">Pprof的-inuse_space,-inuse_objects,-alloc_space,和 -alloc_objects标志可以选择显示哪个标志,默认为-inuse_space(实时对象)和-alloc_objects。Pprof的-inuse_space、-inuse_objects、-alloc_space和-alloc_objects标志选择显示哪一个,默认为-inuse_space(实时对象,按大小缩放)。</target>
        </trans-unit>
        <trans-unit id="9054b52054ed118bba62807238e18c27e8900f1e" translate="yes" xml:space="preserve">
          <source>The http package's Transport and Server both automatically enable HTTP/2 support for simple configurations. To enable HTTP/2 for more complex configurations, to use lower-level HTTP/2 features, or to use a newer version of Go's http2 package, import &quot;golang.org/x/net/http2&quot; directly and use its ConfigureTransport and/or ConfigureServer functions. Manually configuring HTTP/2 via the golang.org/x/net/http2 package takes precedence over the net/http package's built-in HTTP/2 support.</source>
          <target state="translated">http包的Transport和Server都会自动为简单配置启用HTTP/2支持。如果要为更复杂的配置启用 HTTP/2,使用较低级别的 HTTP/2 功能,或者使用较新版本的 Go 的 http2 包,可以直接导入 &quot;golang.org/x/net/http2&quot; 并使用它的 ConfigureTransport 和/或 ConfigureServer 函数。通过 golang.org/x/net/http2 软件包手动配置 HTTP/2,优先于 net/http 软件包内置的 HTTP/2 支持。</target>
        </trans-unit>
        <trans-unit id="7901eb39a7a77a33e17eff2e48d2aac1d7c0d97c" translate="yes" xml:space="preserve">
          <source>The identification of global unicast addresses uses address type identification as defined in RFC 1122, RFC 4632 and RFC 4291 with the exception of IPv4 directed broadcast addresses. It returns true even if ip is in IPv4 private address space or local IPv6 unicast address space.</source>
          <target state="translated">全局单播地址的识别使用RFC 1122、RFC 4632和RFC 4291中定义的地址类型识别,IPv4定向广播地址除外。即使ip处于IPv4私有地址空间或本地IPv6单播地址空间,它也会返回true。</target>
        </trans-unit>
        <trans-unit id="b257c667cd0c9ffb7ee1c476e193cf63abc04956" translate="yes" xml:space="preserve">
          <source>The imag built-in function returns the imaginary part of the complex number c. The return value will be floating point type corresponding to the type of c.</source>
          <target state="translated">imag内置函数返回复数c的虚部,返回值将是c类型对应的浮点类型。</target>
        </trans-unit>
        <trans-unit id="bba6c5ec151d11520ba69091805c64672051a283" translate="yes" xml:space="preserve">
          <source>The implementation compiles a custom codec for each data type in the stream and is most efficient when a single Encoder is used to transmit a stream of values, amortizing the cost of compilation.</source>
          <target state="translated">该实现为流中的每一种数据类型编译一个自定义的编解码器,当使用一个Encoder来传输值流时,效率最高,可以摊销编译的成本。</target>
        </trans-unit>
        <trans-unit id="cc59eb7da6cf17b91e5a422524763e1124d23ad5" translate="yes" xml:space="preserve">
          <source>The implementation fn can assume that the argument Value slice has the number and type of arguments given by typ. If typ describes a variadic function, the final Value is itself a slice representing the variadic arguments, as in the body of a variadic function. The result Value slice returned by fn must have the number and type of results given by typ.</source>
          <target state="translated">实现 fn 可以假设参数 Value 分片具有 typ 给出的参数数量和类型。如果ty描述的是一个变量函数,那么最后的Value本身就是一个代表变量参数的分片,就像变量函数的主体一样。fn 返回的结果 Value 分片必须具有 typ 给出的结果数量和类型。</target>
        </trans-unit>
        <trans-unit id="a41481e84f45a7e3719a2630303073b44edd9b5b" translate="yes" xml:space="preserve">
          <source>The implementation is sufficient for HTTP (RFC 2388) and the multipart bodies generated by popular browsers.</source>
          <target state="translated">该实现足以满足HTTP(RFC 2388)和流行的浏览器生成的多部分体。</target>
        </trans-unit>
        <trans-unit id="bd36b82add2ec8e45a6f77ef7cf720308cbe3f24" translate="yes" xml:space="preserve">
          <source>The implementation provides filters that uncompress during reading and compress during writing. For example, to write compressed data to a buffer:</source>
          <target state="translated">该实现提供了在读取时解压和在写入时压缩的过滤器。例如,将压缩数据写入缓冲区。</target>
        </trans-unit>
        <trans-unit id="4c05b349b9c7f15622f23c1c3f50e289a6f9207b" translate="yes" xml:space="preserve">
          <source>The input stream consists of basic JSON values&amp;mdash;bool, string, number, and null&amp;mdash;along with delimiters [ ] { } of type Delim to mark the start and end of arrays and objects. Commas and colons are elided.</source>
          <target state="translated">输入流由基本JSON值（布尔，字符串，数字和null）以及Delim类型的定界符[] {}组成，以标记数组和对象的开始和结束。逗号和冒号被删除。</target>
        </trans-unit>
        <trans-unit id="12da2b29ce7b4618ed043885dc9bb14fc4b7647d" translate="yes" xml:space="preserve">
          <source>The input text for a template is UTF-8-encoded text in any format. &quot;Actions&quot;--data evaluations or control structures--are delimited by &quot;{{&quot; and &quot;}}&quot;; all text outside actions is copied to the output unchanged. Except for raw strings, actions may not span newlines, although comments can.</source>
          <target state="translated">模板的输入文本是任何格式的UTF-8编码文本。&quot;动作&quot;--数据评估或控制结构--以&quot;{{&quot;和&quot;}}&quot;为界;动作之外的所有文本都会被复制到输出中,不会有任何变化。除了原始字符串外,动作不能跨行,但注释可以。</target>
        </trans-unit>
        <trans-unit id="4540c375047525b02ad242a07ddc447e593cb543" translate="yes" xml:space="preserve">
          <source>The issuer distinguished name CRL field and authority key identifier extension are populated using the issuer certificate. issuer must have SubjectKeyId set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ba307a7ab47ab6e6c8f50d8bbcb53f28f406fab" translate="yes" xml:space="preserve">
          <source>The issuer may not be nil, and the crlSign bit must be set in KeyUsage in order to use it as a CRL issuer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fe0f673e6c94e25d76ca7000237cacb398b340e" translate="yes" xml:space="preserve">
          <source>The key name will be used if it's a non-empty string consisting of only Unicode letters, digits, and ASCII punctuation except quotation marks, backslash, and comma.</source>
          <target state="translated">如果键名是一个非空字符串,除了引号、反斜杠和逗号之外,只包含Unicode字母、数字和ASCII标点符号,那么就会被使用。</target>
        </trans-unit>
        <trans-unit id="56c8d36b799fc9e0b2026b0edca00b49c8b68568" translate="yes" xml:space="preserve">
          <source>The keys should be in canonical form, as returned by CanonicalHeaderKey.</source>
          <target state="translated">键值应该是规范的形式,由CanonicalHeaderKey返回。</target>
        </trans-unit>
        <trans-unit id="aafd41e452c62afe966c7e13f3df11b54dbc58d9" translate="yes" xml:space="preserve">
          <source>The label parameter may contain arbitrary data that will not be encrypted, but which gives important context to the message. For example, if a given public key is used to decrypt two types of messages then distinct label values could be used to ensure that a ciphertext for one purpose cannot be used for another by an attacker. If not required it can be empty.</source>
          <target state="translated">标签参数可以包含任意的数据,这些数据不会被加密,但可以为消息提供重要的背景。例如,如果一个给定的公钥被用来解密两种类型的消息,那么不同的标签值可以用来确保一个用于一个目的的密文不能被攻击者用于另一个目的。如果不需要,它可以是空的。</target>
        </trans-unit>
        <trans-unit id="8cac55c132cd1a101696d231efd1dd2e57c66e06" translate="yes" xml:space="preserve">
          <source>The label parameter must match the value given when encrypting. See EncryptOAEP for details.</source>
          <target state="translated">标签参数必须与加密时给出的值相匹配。详情请参见EncryptOAEP。</target>
        </trans-unit>
        <trans-unit id="1f23b14d8824650d5d93ee806d28aa66402f402a" translate="yes" xml:space="preserve">
          <source>The last index entry is the field or method index in the (possibly embedded) type where the entry was found, either:</source>
          <target state="translated">最后一个索引条目是找到该条目的(可能是嵌入的)类型中的字段或方法索引,要么。</target>
        </trans-unit>
        <trans-unit id="4b9b3d3444da612bde04769b5c20561ed18e861d" translate="yes" xml:space="preserve">
          <source>The legacy Common Name field is ignored unless it's a valid hostname, the certificate doesn't have any Subject Alternative Names, and the GODEBUG environment variable is set to &quot;x509ignoreCN=0&quot;. Support for Common Name is deprecated will be entirely removed in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="feec6e46b5f96d5f768a208b14b5f1c441e6736a" translate="yes" xml:space="preserve">
          <source>The len built-in function returns the length of v, according to its type:</source>
          <target state="translated">len内置函数根据v的类型,返回v的长度。</target>
        </trans-unit>
        <trans-unit id="67e3ff53cc19034aa94ce5014984a3863b3ceaa2" translate="yes" xml:space="preserve">
          <source>The limit controls the number of operating system threads, not the number of goroutines. A Go program creates a new thread only when a goroutine is ready to run but all the existing threads are blocked in system calls, cgo calls, or are locked to other goroutines due to use of runtime.LockOSThread.</source>
          <target state="translated">该限制控制的是操作系统线程的数量,而不是goroutine的数量。一个围棋程序只有在一个goroutine准备运行时才会创建一个新的线程,但所有现有的线程都在系统调用、cgo调用中被阻塞,或者由于使用runtime.LockOSThread而被锁定在其他goroutine上。</target>
        </trans-unit>
        <trans-unit id="b7d62826dea7a7db650a9558cf682cb6d6d5b0e1" translate="yes" xml:space="preserve">
          <source>The list is sorted by ID. Note that the default cipher suites selected by this package might depend on logic that can't be captured by a static list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61b31a135931a0a96f45c468dd4c1356b142f056" translate="yes" xml:space="preserve">
          <source>The list of possible Object kinds.</source>
          <target state="translated">可能的对象种类列表。</target>
        </trans-unit>
        <trans-unit id="f82cdeb26140d2ac8d4f27048ef361e35bc34e51" translate="yes" xml:space="preserve">
          <source>The list of tokens.</source>
          <target state="translated">代币清单。</target>
        </trans-unit>
        <trans-unit id="744b107073d50b7c5d979152623baf7c98836ce1" translate="yes" xml:space="preserve">
          <source>The load and store operations, implemented by the LoadT and StoreT functions, are the atomic equivalents of &quot;return *addr&quot; and &quot;*addr = val&quot;.</source>
          <target state="translated">LoadT和StoreT函数实现的加载和存储操作,是 &quot;返回*addr &quot;和 &quot;*addr=val &quot;的原子等价物。</target>
        </trans-unit>
        <trans-unit id="d80346c4a6d83f0a2408ae318740b75196640a27" translate="yes" xml:space="preserve">
          <source>The lookup function is called each time the resulting importer needs to resolve an import path. In this mode the importer can only be invoked with canonical import paths (not relative or absolute ones); it is assumed that the translation to canonical import paths is being done by the client of the importer.</source>
          <target state="translated">每次当生成的导入器需要解析导入路径时,都会调用查找函数。在这种模式下,进口商只能使用规范的进口路径(不是相对或绝对路径)来调用;假定进口商的客户端正在进行向规范进口路径的转换。</target>
        </trans-unit>
        <trans-unit id="d42ee39ba69d607990bf6285f526cdb4d05cd8c5" translate="yes" xml:space="preserve">
          <source>The low bit is therefore analogous to a sign bit, but making it the complement bit instead guarantees that the largest negative integer is not a special case. For example, -129=^128=(^256&amp;gt;&amp;gt;1) encodes as (FE 01 01).</source>
          <target state="translated">因此，低位类似于符号位，但是将其设为补码位可确保最大的负整数不是特殊情况。例如，-129 = ^ 128 =（^ 256 &amp;gt;&amp;gt; 1）编码为（FE 01 01）。</target>
        </trans-unit>
        <trans-unit id="e23983031d30e849dd601f8a9a147a11b178b7e1" translate="yes" xml:space="preserve">
          <source>The main use case is finding resources located relative to an executable.</source>
          <target state="translated">主要的用例是寻找相对于可执行文件的资源。</target>
        </trans-unit>
        <trans-unit id="ae651dd57d8aac89d2244b121832135b42a78e22" translate="yes" xml:space="preserve">
          <source>The make built-in function allocates and initializes an object of type slice, map, or chan (only). Like new, the first argument is a type, not a value. Unlike new, make's return type is the same as the type of its argument, not a pointer to it. The specification of the result depends on the type:</source>
          <target state="translated">make内置函数分配并初始化一个类型为slice、map或chan(仅)的对象。和new一样,第一个参数是一个类型,而不是一个值。与new不同,make的返回类型与它的参数类型相同,而不是指向它的指针。结果的规格取决于类型。</target>
        </trans-unit>
        <trans-unit id="ad15554627caa64494fe09878e570067f5641170" translate="yes" xml:space="preserve">
          <source>The meaning of the parameters fset, pkg, and pos is the same as in CheckExpr. An error is returned if expr cannot be parsed successfully, or the resulting expr AST cannot be type-checked.</source>
          <target state="translated">参数fset、pkg和pos的含义与CheckExpr相同。如果expr不能被成功解析,或者产生的expr AST不能进行类型检查,则返回一个错误。</target>
        </trans-unit>
        <trans-unit id="76f7a0e267f75e03932754601186fb88901bc244" translate="yes" xml:space="preserve">
          <source>The message must be no longer than the length of the public modulus minus twice the hash length, minus a further 2.</source>
          <target state="translated">该消息必须不长于公共模数的长度减去哈希长度的两倍,再减去2。</target>
        </trans-unit>
        <trans-unit id="f50438ca0e284cc49442d4b96ed8422098542b37" translate="yes" xml:space="preserve">
          <source>The method for resolving domain names, whether indirectly with functions like Dial or directly with functions like LookupHost and LookupAddr, varies by operating system.</source>
          <target state="translated">解析域名的方法,无论是间接使用Dial等函数,还是直接使用LookupHost和LookupAddr等函数,都因操作系统而异。</target>
        </trans-unit>
        <trans-unit id="fd8e3459dc1d93b8b2959d9f7ce9e888fe72a14d" translate="yes" xml:space="preserve">
          <source>The method's first argument represents the arguments provided by the caller; the second argument represents the result parameters to be returned to the caller. The method's return value, if non-nil, is passed back as a string that the client sees as if created by errors.New. If an error is returned, the reply parameter will not be sent back to the client.</source>
          <target state="translated">该方法的第一个参数代表调用者提供的参数;第二个参数代表要返回给调用者的结果参数。该方法的返回值如果是非nil,则会以字符串的形式传回,客户端看到的字符串就像由错误.New创建的一样。如果返回错误,则不会将回复参数发回给客户端。</target>
        </trans-unit>
        <trans-unit id="eebd4cc8d1b396bccc721d19c4bd56800d60e192" translate="yes" xml:space="preserve">
          <source>The methods should behave the same as those on an *os.File.</source>
          <target state="translated">这些方法的行为应该与*os.File.Methods上的方法相同。</target>
        </trans-unit>
        <trans-unit id="3351c33da5b9bc73dd81d983421271485dd91e09" translate="yes" xml:space="preserve">
          <source>The minimal source code for a binary-only package was therefore:</source>
          <target state="translated">因此,二进制包的最小源代码是。</target>
        </trans-unit>
        <trans-unit id="ba0d7c85cb07c29f22bceee0e488a79cf0a2c300" translate="yes" xml:space="preserve">
          <source>The minimum element in the tree is the root, at index 0.</source>
          <target state="translated">树中最小的元素是根,索引为0。</target>
        </trans-unit>
        <trans-unit id="6cf2c8c68bd743b1d5a4e29ae7301dad5d49bcb2" translate="yes" xml:space="preserve">
          <source>The mode parameter controls the amount of source text parsed and other optional parser functionality. Position information is recorded in the file set fset, which must not be nil.</source>
          <target state="translated">模式参数控制源文本的解析量和其他可选的解析器功能。位置信息记录在文件集fset中,fset不能为零。</target>
        </trans-unit>
        <trans-unit id="7d1773f39818c5825c59e48b1236b92119b0b32e" translate="yes" xml:space="preserve">
          <source>The month, day, hour, min, sec, and nsec values may be outside their usual ranges and will be normalized during the conversion. For example, October 32 converts to November 1.</source>
          <target state="translated">月、日、时、分、秒和nsec的值可能超出了它们的通常范围,并将在转换过程中被标准化。例如,10月32日转换为11月1日。</target>
        </trans-unit>
        <trans-unit id="a5541e290e27715c3d35b2115cad871f3ab99ccb" translate="yes" xml:space="preserve">
          <source>The most common numeric conversions are Atoi (string to int) and Itoa (int to string).</source>
          <target state="translated">最常见的数字转换是Atoi(字符串到int)和Itoa(int到字符串)。</target>
        </trans-unit>
        <trans-unit id="4bbbacdbad6d2c99ac68260aad07ecb869838903" translate="yes" xml:space="preserve">
          <source>The most common use of this pattern is to access fields in a struct or elements of an array:</source>
          <target state="translated">该模式最常见的用法是访问结构中的字段或数组中的元素。</target>
        </trans-unit>
        <trans-unit id="ac8cc81db3fc49af2479176c9231b929d55cdbd8" translate="yes" xml:space="preserve">
          <source>The msg parameter should be an RFC 822-style email with headers first, a blank line, and then the message body. The lines of msg should be CRLF terminated. The msg headers should usually include fields such as &quot;From&quot;, &quot;To&quot;, &quot;Subject&quot;, and &quot;Cc&quot;. Sending &quot;Bcc&quot; messages is accomplished by including an email address in the to parameter but not including it in the msg headers.</source>
          <target state="translated">msg 参数应该是 RFC 822 风格的电子邮件,先是标题,再是空行,然后是邮件正文。msg 的行应该以 CRLF 结尾。msg 头部通常应该包括诸如 &quot;发件人&quot;、&quot;收件人&quot;、&quot;主题 &quot;和 &quot;抄送 &quot;等字段。发送 &quot;Bcc &quot;信息的方法是在 to 参数中包含一个电子邮件地址,但不包含在 msg 头部。</target>
        </trans-unit>
        <trans-unit id="410aa7b0a0304575a8915750342dc577b832f74c" translate="yes" xml:space="preserve">
          <source>The name for the XML elements is taken from, in order of preference:</source>
          <target state="translated">XML元素的名称依次取自。</target>
        </trans-unit>
        <trans-unit id="57b088fc8d39478c2345773281e5eb271805f7ea" translate="yes" xml:space="preserve">
          <source>The naming convention to declare examples for the package, a function F, a type T and method M on type T are:</source>
          <target state="translated">为包、函数F、类型T和类型T上的方法M声明例子的命名惯例是:</target>
        </trans-unit>
        <trans-unit id="7b9b492a2e0fbf406f8b8d17e034f78a30b6eb8c" translate="yes" xml:space="preserve">
          <source>The net, net/http, and crypto/tls packages also refer to debugging variables in GODEBUG. See the documentation for those packages for details.</source>
          <target state="translated">net、net/http和crypto/tls包也引用了GODEBUG中的调试变量。详情请参见这些包的文档。</target>
        </trans-unit>
        <trans-unit id="69954652d3ee14598bd31e60017ff5be6ec75582" translate="yes" xml:space="preserve">
          <source>The net/http/cookiejar package provides a CookieJar implementation.</source>
          <target state="translated">net/http/cookiejar包提供了一个CookieJar的实现。</target>
        </trans-unit>
        <trans-unit id="7815d9693c2e8fba3de7740f99dda917ebde80d7" translate="yes" xml:space="preserve">
          <source>The net/rpc package is frozen and is not accepting new features.</source>
          <target state="translated">net/rpc包被冻结,不接受新功能。</target>
        </trans-unit>
        <trans-unit id="b67ec9dd23234843cefc446704be9276e0333344" translate="yes" xml:space="preserve">
          <source>The network must be &quot;tcp&quot;, &quot;tcp4&quot;, &quot;tcp6&quot;, &quot;unix&quot; or &quot;unixpacket&quot;.</source>
          <target state="translated">网络必须是 &quot;tcp&quot;、&quot;tcp4&quot;、&quot;tcp6&quot;、&quot;unix &quot;或 &quot;unixpacket&quot;。</target>
        </trans-unit>
        <trans-unit id="f78c2675c0a1b78facf549c913ce29c8786aed4f" translate="yes" xml:space="preserve">
          <source>The network must be &quot;udp&quot;, &quot;udp4&quot;, &quot;udp6&quot;, &quot;unixgram&quot;, or an IP transport. The IP transports are &quot;ip&quot;, &quot;ip4&quot;, or &quot;ip6&quot; followed by a colon and a literal protocol number or a protocol name, as in &quot;ip:1&quot; or &quot;ip:icmp&quot;.</source>
          <target state="translated">网络必须是 &quot;udp&quot;、&quot;udp4&quot;、&quot;udp6&quot;、&quot;unixgram &quot;或IP传输。IP传输是 &quot;ip&quot;、&quot;ip4 &quot;或 &quot;ip6&quot;,后面跟着一个冒号和一个协议号或协议名,如 &quot;ip:1 &quot;或 &quot;ip:icmp&quot;。</target>
        </trans-unit>
        <trans-unit id="f62f0c6bf3637b6bd91fbed73590e0c5ec059d67" translate="yes" xml:space="preserve">
          <source>The network must be &quot;unix&quot; or &quot;unixpacket&quot;.</source>
          <target state="translated">网络必须是 &quot;unix &quot;或 &quot;unixpacket&quot;。</target>
        </trans-unit>
        <trans-unit id="961ea2a9664370be05fda243ace29bf62f0b8b14" translate="yes" xml:space="preserve">
          <source>The network must be &quot;unixgram&quot;.</source>
          <target state="translated">网络必须是 &quot;unixgram&quot;。</target>
        </trans-unit>
        <trans-unit id="143c1ec61594ea23a84fdfc668726a693ff1d059" translate="yes" xml:space="preserve">
          <source>The network must be a TCP network name.</source>
          <target state="translated">网络必须是TCP网络名。</target>
        </trans-unit>
        <trans-unit id="54bb9136f9b37f7468411dbae5b647c63059a3a1" translate="yes" xml:space="preserve">
          <source>The network must be a TCP network name; see func Dial for details.</source>
          <target state="translated">网络必须是一个TCP网络名,详情请看func Dial。</target>
        </trans-unit>
        <trans-unit id="a35132d711d8945bdb8b272ee67848e4c94a5a16" translate="yes" xml:space="preserve">
          <source>The network must be a UDP network name.</source>
          <target state="translated">网络必须是UDP网络名。</target>
        </trans-unit>
        <trans-unit id="89ed96066a0fbc9b6b82696daa8ba7effb94e0a8" translate="yes" xml:space="preserve">
          <source>The network must be a UDP network name; see func Dial for details.</source>
          <target state="translated">网络必须是UDP网络名,详情请看func Dial。</target>
        </trans-unit>
        <trans-unit id="199d17e2fe63f354db9a6b916c396629d6b88dda" translate="yes" xml:space="preserve">
          <source>The network must be a Unix network name.</source>
          <target state="translated">网络必须是Unix网络名。</target>
        </trans-unit>
        <trans-unit id="b6cf9d29e750ed948316e5ba40edb44e452845b1" translate="yes" xml:space="preserve">
          <source>The network must be a Unix network name; see func Dial for details.</source>
          <target state="translated">网络必须是Unix网络名,详情请看func Dial。</target>
        </trans-unit>
        <trans-unit id="61f5a2270318ecc8414142178aaa1a53165f97e7" translate="yes" xml:space="preserve">
          <source>The network must be an IP network name.</source>
          <target state="translated">网络必须是IP网络名。</target>
        </trans-unit>
        <trans-unit id="b881d6aafa14d5f635aad510160f9473031ecf6f" translate="yes" xml:space="preserve">
          <source>The network must be an IP network name; see func Dial for details.</source>
          <target state="translated">网络必须是一个IP网络名,详情请看func Dial。</target>
        </trans-unit>
        <trans-unit id="882441c96cbf8f9716ac8a79d3a5eb4e3af0bcfd" translate="yes" xml:space="preserve">
          <source>The new Handler calls h.ServeHTTP to handle each request, but if a call runs for longer than its time limit, the handler responds with a 503 Service Unavailable error and the given message in its body. (If msg is empty, a suitable default message will be sent.) After such a timeout, writes by h to its ResponseWriter will return ErrHandlerTimeout.</source>
          <target state="translated">新的处理程序调用h.ServeHTTP来处理每个请求,但是如果一个调用运行的时间超过了它的时间限制,处理程序就会以503服务不可用的错误和在它的正文中给出的消息来响应。 (如果msg是空的,就会发送合适的默认消息。)在这样的超时之后,h向它的ResponseWriter写的东西会返回ErrHandlerTimeout。(如果msg为空,则会发送一个合适的默认消息。)在这样的超时之后,h对其ResponseWriter的写入将返回ErrHandlerTimeout。</target>
        </trans-unit>
        <trans-unit id="3cf0c81686ac1acb508bf9e67780a55cee7159d9" translate="yes" xml:space="preserve">
          <source>The new built-in function allocates memory. The first argument is a type, not a value, and the value returned is a pointer to a newly allocated zero value of that type.</source>
          <target state="translated">新的内置函数分配内存。第一个参数是一个类型,而不是一个值,返回的值是一个指向该类型新分配的零值的指针。</target>
        </trans-unit>
        <trans-unit id="902360dabebdea5b3a521c7b72fed85e30d4437d" translate="yes" xml:space="preserve">
          <source>The node type must be *ast.File, *printer.CommentedNode, []ast.Decl, []ast.Stmt, or assignment-compatible to ast.Expr, ast.Decl, ast.Spec, or ast.Stmt. Node does not modify node. Imports are not sorted for nodes representing partial source files (for instance, if the node is not an *ast.File or a *printer.CommentedNode not wrapping an *ast.File).</source>
          <target state="translated">节点类型必须是*ast.File、*printer.CommentedNode、[]ast.Decl、[]ast.Stmt,或与 ast.Expr、 ast.Decl、 ast.Spec 或 ast.Stmt 兼容的赋值。节点不修改节点。对于代表部分源文件的节点,导入不排序(例如,如果节点不是*ast.File或*printer.CommentedNode没有包装*ast.File)。</target>
        </trans-unit>
        <trans-unit id="56cff2c7a026fcff6621abd1c298d8e39f80b3ef" translate="yes" xml:space="preserve">
          <source>The non-Go code should not change the signal mask on any threads created by the Go runtime. If the non-Go code starts new threads of its own, it may set the signal mask as it pleases.</source>
          <target state="translated">非围棋代码不应改变围棋运行时创建的任何线程的信号掩码。如果非围棋代码自己启动新的线程,它可以随意设置信号掩码。</target>
        </trans-unit>
        <trans-unit id="67289d2a1e8eb416b3a82eb9f3e75a285c0158f6" translate="yes" xml:space="preserve">
          <source>The number represented by s must be of the form N, Ni, or N&amp;plusmn;Ni, where N stands for a floating-point number as recognized by ParseFloat, and i is the imaginary component. If the second N is unsigned, a + sign is required between the two components as indicated by the &amp;plusmn;. If the second N is NaN, only a + sign is accepted. The form may be parenthesized and cannot contain any spaces. The resulting complex number consists of the two components converted by ParseFloat.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ca31cdbe931eb86d33c507cac75f440d062f995" translate="yes" xml:space="preserve">
          <source>The ok result is false if the -timeout flag indicates &amp;ldquo;no timeout&amp;rdquo; (0).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b32a27700c08984e10653750973205a0166116d3" translate="yes" xml:space="preserve">
          <source>The only signal values guaranteed to be present in the os package on all systems are os.Interrupt (send the process an interrupt) and os.Kill (force the process to exit). On Windows, sending os.Interrupt to a process with os.Process.Signal is not implemented; it will return an error instead of sending a signal.</source>
          <target state="translated">在所有系统的os包中保证存在的信号值只有os.Interrupt(向进程发送一个中断)和os.Kill(强制进程退出)。在 Windows 上,用 os.Process.Signal 向进程发送 os.Interrupt 是无法实现的;它将返回一个错误而不是发送一个信号。</target>
        </trans-unit>
        <trans-unit id="ff422009eedfd53fa7602cbdd94de8292f5f25ce" translate="yes" xml:space="preserve">
          <source>The original specification for encryption and signatures with RSA is PKCS #1 and the terms &quot;RSA encryption&quot; and &quot;RSA signatures&quot; by default refer to PKCS #1 version 1.5. However, that specification has flaws and new designs should use version 2, usually called by just OAEP and PSS, where possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c37b0a4e6fab650a215cbd5edb17eee82ff53db" translate="yes" xml:space="preserve">
          <source>The original specification for encryption and signatures with RSA is PKCS#1 and the terms &quot;RSA encryption&quot; and &quot;RSA signatures&quot; by default refer to PKCS#1 version 1.5. However, that specification has flaws and new designs should use version two, usually called by just OAEP and PSS, where possible.</source>
          <target state="translated">用RSA进行加密和签名的原始规范是PKCS#1,&quot;RSA加密 &quot;和 &quot;RSA签名 &quot;这两个术语默认指的是PKCS#1 1.5版本。但是,该规范存在缺陷,新的设计应尽可能使用第二版本,通常只用OAEP和PSS来称呼。</target>
        </trans-unit>
        <trans-unit id="540d9d25cf4179e22c8285de7096ab16e1c12b86" translate="yes" xml:space="preserve">
          <source>The original tar format was introduced in Unix V7. Since then, there have been multiple competing formats attempting to standardize or extend the V7 format to overcome its limitations. The most common formats are the USTAR, PAX, and GNU formats, each with their own advantages and limitations.</source>
          <target state="translated">最初的焦油格式是在Unix V7中引入的。从那时起,就有多种竞争性格式试图标准化或扩展 V7 格式以克服其局限性。最常见的格式是UTAR、PAX和GNU格式,每种格式都有自己的优势和局限性。</target>
        </trans-unit>
        <trans-unit id="447ae61382377495d9bb3dcbc7167cc095d3d833" translate="yes" xml:space="preserve">
          <source>The os interface is intended to be uniform across all operating systems. Features not generally available appear in the system-specific package syscall.</source>
          <target state="translated">os接口的目的是为了在所有操作系统中统一。一般不可用的功能会出现在系统专用的软件包syscall中。</target>
        </trans-unit>
        <trans-unit id="826c8f633f039e53ad0aac6dce5e00961c47baef" translate="yes" xml:space="preserve">
          <source>The other reporting methods, such as the variations of Log and Error, may be called simultaneously from multiple goroutines.</source>
          <target state="translated">其他报告方法,如日志和错误的变化,可以从多个goroutine中同时调用。</target>
        </trans-unit>
        <trans-unit id="314818cec484a0a4f79c6a3bd12ea1e65d6a5497" translate="yes" xml:space="preserve">
          <source>The output of a command will be either one value or two values, the second of which has type error. If that second value is present and evaluates to non-nil, execution terminates and the error is returned to the caller of Execute.</source>
          <target state="translated">命令的输出将是一个值或两个值,其中第二个值的类型为错误。如果第二个值存在,并且值为非nil,则执行终止,错误返回给Execute的调用者。</target>
        </trans-unit>
        <trans-unit id="8552b51b4b43726af9d21d2953952aab9f9eccb4" translate="yes" xml:space="preserve">
          <source>The package also exports a handler that serves execution trace data for the &quot;go tool trace&quot; command. To collect a 5-second execution trace:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01b79b49ed9f5aef9d64418cf5de61a045616033" translate="yes" xml:space="preserve">
          <source>The package also runs and verifies example code. Example functions may include a concluding line comment that begins with &quot;Output:&quot; and is compared with the standard output of the function when the tests are run. (The comparison ignores leading and trailing space.) These are examples of an example:</source>
          <target state="translated">该软件包还可以运行和验证示例代码。示例函数可能包含一个以 &quot;Output:&quot;开头的结尾行注释,并在测试运行时与函数的标准输出进行比较。(比较会忽略前导空格和后导空格。)这些都是例子的例子。</target>
        </trans-unit>
        <trans-unit id="a842fba56dd27e8e683543ed1da0bb8ec8237f57" translate="yes" xml:space="preserve">
          <source>The package is marked as complete if no errors occurred, otherwise it is incomplete. See Config.Error for controlling behavior in the presence of errors.</source>
          <target state="translated">如果没有发生错误,则该包被标记为完整,否则就是不完整。参见Config.Error,了解如何在出现错误时控制行为。</target>
        </trans-unit>
        <trans-unit id="084533be70387d373858b81e63ee3fdbb938556c" translate="yes" xml:space="preserve">
          <source>The package is sometimes only imported for the side effect of registering its HTTP handler and the above variables. To use it this way, link this package into your program:</source>
          <target state="translated">这个包有时只是为了注册它的HTTP处理程序和上述变量的副作用而导入的。如果要这样使用,请将这个包链接到你的程序中。</target>
        </trans-unit>
        <trans-unit id="a76fef8dda549c1a3db0f0948e9255bd119d522e" translate="yes" xml:space="preserve">
          <source>The package is specified by a list of *ast.Files and corresponding file set, and the package path the package is identified with. The clean path must not be empty or dot (&quot;.&quot;).</source>
          <target state="translated">包是由*ast.Files和对应的文件集的列表,以及包所标识的包路径来指定的。清理路径不得为空或点(&quot;.&quot;)。</target>
        </trans-unit>
        <trans-unit id="385716c34a6382063c2f2e6bebfaff89eee0a50e" translate="yes" xml:space="preserve">
          <source>The package is specified by a list of *ast.Files and corresponding file set, which must not be nil. NewFromFiles uses all provided files when computing documentation, so it is the caller's responsibility to provide only the files that match the desired build context. &quot;go/build&quot;.Context.MatchFile can be used for determining whether a file matches a build context with the desired GOOS and GOARCH values, and other build constraints. The import path of the package is specified by importPath.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="399fd3ad30378409e2dc4bdf013d129681dab5d4" translate="yes" xml:space="preserve">
          <source>The package is typically only imported for the side effect of registering its HTTP handlers. The handled paths all begin with /debug/pprof/.</source>
          <target state="translated">这个包通常只是为了注册它的HTTP处理程序而导入的。处理的路径都是以/debug/pprof/开头的。</target>
        </trans-unit>
        <trans-unit id="1435a203fd8b96db3ad7b17b180e6f206d92f47b" translate="yes" xml:space="preserve">
          <source>The package is using the Elastic Tabstops algorithm described at &lt;a href=&quot;http://nickgravgaard.com/elastictabstops/index.html&quot;&gt;http://nickgravgaard.com/elastictabstops/index.html&lt;/a&gt;.</source>
          <target state="translated">该程序包使用&lt;a href=&quot;http://nickgravgaard.com/elastictabstops/index.html&quot;&gt;http://nickgravgaard.com/elastictabstops/index.html中&lt;/a&gt;描述的Elastic Tabstops算法。</target>
        </trans-unit>
        <trans-unit id="2d8c628767f33f2351dada491bfefd34f51b3140" translate="yes" xml:space="preserve">
          <source>The package provides:</source>
          <target state="translated">该方案提供:</target>
        </trans-unit>
        <trans-unit id="fdd304cc0ffa560e98ef7d6ccf98bb51070237a4" translate="yes" xml:space="preserve">
          <source>The packages golang.org/x/net/ipv4 and golang.org/x/net/ipv6 can be used to manipulate IP-level socket options in oob.</source>
          <target state="translated">golang.org/x/net/ipv4和golang.org/x/net/ipv6这两个包可以用来操作oob中的IP级socket选项。</target>
        </trans-unit>
        <trans-unit id="e31e979e3edc39254b9a5c52d82e5a30deadc675" translate="yes" xml:space="preserve">
          <source>The panic built-in function stops normal execution of the current goroutine. When a function F calls panic, normal execution of F stops immediately. Any functions whose execution was deferred by F are run in the usual way, and then F returns to its caller. To the caller G, the invocation of F then behaves like a call to panic, terminating G's execution and running any deferred functions. This continues until all functions in the executing goroutine have stopped, in reverse order. At that point, the program is terminated with a non-zero exit code. This termination sequence is called panicking and can be controlled by the built-in function recover.</source>
          <target state="translated">panic内置函数停止当前goroutine的正常执行。当函数F调用panic时,F的正常执行立即停止。任何被F推迟执行的函数都会以通常的方式运行,然后F返回给它的调用者。对调用者G来说,F的调用就像对panic的调用一样,终止G的执行,并运行任何推迟执行的函数。这种情况一直持续到正在执行的goroutine中的所有函数都停止,顺序相反。这时,程序以一个非零的退出代码终止。这个终止序列称为panicking,可以通过内置函数recover来控制。</target>
        </trans-unit>
        <trans-unit id="af4f035528815b22e373ca233969d1eeb80da9ab" translate="yes" xml:space="preserve">
          <source>The parse functions return the widest type (float64, int64, and uint64), but if the size argument specifies a narrower width the result can be converted to that narrower type without data loss:</source>
          <target state="translated">解析函数返回最宽的类型(float64、int64和uint64),但如果size参数指定了一个较窄的宽度,结果可以转换为该较窄的类型,而不会丢失数据。</target>
        </trans-unit>
        <trans-unit id="a18efb4bf749b7c5acc3a4bfaddc4a2e6898762f" translate="yes" xml:space="preserve">
          <source>The parser accepts a larger language than is syntactically permitted by the Go spec, for simplicity, and for improved robustness in the presence of syntax errors. For instance, in method declarations, the receiver is treated like an ordinary parameter list and thus may contain multiple entries where the spec permits exactly one. Consequently, the corresponding field in the AST (ast.FuncDecl.Recv) field is not restricted to one entry.</source>
          <target state="translated">为了简单起见,也为了提高语法错误时的鲁棒性,解析器接受的语言比Go规范所允许的语法更大。例如,在方法声明中,接受者被当作普通的参数列表,因此可能包含多个条目,而规范只允许一个。因此,AST(ast.FuncDecl.Recv)字段中相应的字段不限于一个条目。</target>
        </trans-unit>
        <trans-unit id="f1b15ae7c535ec21c3b3214f780b2381f7617014" translate="yes" xml:space="preserve">
          <source>The path and host are used unchanged for CONNECT requests.</source>
          <target state="translated">在CONNECT请求中,路径和主机是不变的。</target>
        </trans-unit>
        <trans-unit id="185477acd3fd456d75fb7c4fc53e2fc58b8c4aaf" translate="yes" xml:space="preserve">
          <source>The path package should only be used for paths separated by forward slashes, such as the paths in URLs. This package does not deal with Windows paths with drive letters or backslashes; to manipulate operating system paths, use the path/filepath package.</source>
          <target state="translated">path包只能用于处理用斜线分隔的路径,比如URL中的路径。这个包并不处理Windows系统中带有驱动器字母或反斜杠的路径;如果要操作操作系统的路径,请使用path/filepath包。</target>
        </trans-unit>
        <trans-unit id="26954c9ca56cc48a56a0453ce2488e2f260ed60b" translate="yes" xml:space="preserve">
          <source>The pkg/ directory holds installed package objects. As in the Go tree, each target operating system and architecture pair has its own subdirectory of pkg (pkg/GOOS_GOARCH).</source>
          <target state="translated">pkg/目录下存放着已安装的包对象。和围棋树一样,每个目标操作系统和架构对都有自己的 pkg 子目录 (pkg/GOOS_GOARCH)。</target>
        </trans-unit>
        <trans-unit id="5a87eb4ca6fbc546df6339993053151079409112" translate="yes" xml:space="preserve">
          <source>The precision prec controls the number of digits (excluding the exponent) printed by the 'e', 'E', 'f', 'g', 'G', 'x', and 'X' formats. For 'e', 'E', 'f', 'x', and 'X', it is the number of digits after the decimal point. For 'g' and 'G' it is the maximum number of significant digits (trailing zeros are removed). The special precision -1 uses the smallest number of digits necessary such that ParseFloat will return f exactly.</source>
          <target state="translated">精度prec控制'e'、'E'、'f'、'g'、'G'、'x'和'X'格式打印的位数(不包括指数)。对于'e'、'E'、'f'、'x'和'X',它是小数点后的数字。对于'g'和'G',它是最大的有意义的数字(去掉了尾部的零)。特殊精度-1使用的是必要的最小数字,这样ParseFloat将准确地返回f。</target>
        </trans-unit>
        <trans-unit id="69078c80b7be9ecb1f89b1ab519c7b7264b1d687" translate="yes" xml:space="preserve">
          <source>The precision prec controls the number of digits (excluding the exponent) printed by the 'e', 'E', 'f', 'g', 'G', and 'x' formats. For 'e', 'E', 'f', and 'x', it is the number of digits after the decimal point. For 'g' and 'G' it is the total number of digits. A negative precision selects the smallest number of decimal digits necessary to identify the value x uniquely using x.Prec() mantissa bits. The prec value is ignored for the 'b' and 'p' formats.</source>
          <target state="translated">精度prec控制'e'、'E'、'f'、'g'、'G'和'x'格式打印的位数(不包括指数)。对于'e'、'E'、'f'和'x',它是小数点后的数字。对于'g'和'G',它是数字的总数。负精度选择了使用x.Prec()mantissa位来唯一识别值x所需的最小的十进制位数。对于'b'和'p'格式,prec值被忽略。</target>
        </trans-unit>
        <trans-unit id="456c4a02a800a4453e3d726e233dc51ff74f0fc9" translate="yes" xml:space="preserve">
          <source>The predefined profiles may assign meaning to other debug values; for example, when printing the &quot;goroutine&quot; profile, debug=2 means to print the goroutine stacks in the same form that a Go program uses when dying due to an unrecovered panic.</source>
          <target state="translated">预定义的配置文件可以给其他调试值赋予意义;例如,当打印 &quot;goroutine &quot;配置文件时,debug=2意味着以与围棋程序因未恢复的恐慌而死亡时相同的形式打印goroutine堆栈。</target>
        </trans-unit>
        <trans-unit id="58481973143a6de618e8538c648e764b31b42f2b" translate="yes" xml:space="preserve">
          <source>The print built-in function formats its arguments in an implementation-specific way and writes the result to standard error. Print is useful for bootstrapping and debugging; it is not guaranteed to stay in the language.</source>
          <target state="translated">print内置函数以特定于实现的方式格式化其参数,并将结果写入标准错误。print对于引导和调试是有用的,它不保证会留在语言中。</target>
        </trans-unit>
        <trans-unit id="91f04de49b9af203098665c6f8b752b5392b78a0" translate="yes" xml:space="preserve">
          <source>The println built-in function formats its arguments in an implementation-specific way and writes the result to standard error. Spaces are always added between arguments and a newline is appended. Println is useful for bootstrapping and debugging; it is not guaranteed to stay in the language.</source>
          <target state="translated">println内置函数以特定于实现的方式格式化其参数,并将结果写入标准错误。参数之间总是添加空格,并附加一个换行。Println对引导和调试很有用;它并不保证会留在语言中。</target>
        </trans-unit>
        <trans-unit id="151eef92ef01a650c4a9036a013718d694ffc693" translate="yes" xml:space="preserve">
          <source>The provided Context must be non-nil. If the context expires before the connection is complete, an error is returned. Once successfully connected, any expiration of the context will not affect the connection.</source>
          <target state="translated">提供的Context必须为非零。如果上下文在连接完成前过期,将返回一个错误。一旦连接成功,任何过期的上下文将不会影响连接。</target>
        </trans-unit>
        <trans-unit id="0e411a42789a39be423654b810b14a1d819d3f7a" translate="yes" xml:space="preserve">
          <source>The provided TxOptions is optional and may be nil if defaults should be used. If a non-default isolation level is used that the driver doesn't support, an error will be returned.</source>
          <target state="translated">提供的TxOptions是可选的,如果应该使用默认值,则可能为零。如果使用了驱动不支持的非默认隔离级别,将返回一个错误。</target>
        </trans-unit>
        <trans-unit id="decd2b405e8241c6f8e12f33bd5a3bb2cc5dc04e" translate="yes" xml:space="preserve">
          <source>The provided body may be nil. If the body is of type *bytes.Reader, *strings.Reader, or *bytes.Buffer, the Request.ContentLength is set.</source>
          <target state="translated">所提供的body可以是nil.如果body的类型是*bytes.Reader、*strings.Reader或*bytes.Buffer,则设置Request.ContentLength。如果body的类型是*bytes.Reader、*strings.Reader或*bytes.Buffer,则设置Request.ContentLength。</target>
        </trans-unit>
        <trans-unit id="58ddb87ccdb3a3bbf17dded9af2e6f690f9fa593" translate="yes" xml:space="preserve">
          <source>The provided code should be in the 3xx range and is usually StatusMovedPermanently, StatusFound or StatusSeeOther.</source>
          <target state="translated">提供的代码应该在3xx范围内,通常是StatusMovedPermanently、StatusFound或StatusSeeOther。</target>
        </trans-unit>
        <trans-unit id="86be20106cb95d195cb582ade394435819f24514" translate="yes" xml:space="preserve">
          <source>The provided context is used for the preparation of the statement, not for the execution of the statement.</source>
          <target state="translated">所提供的上下文用于编制语句,而不是执行语句。</target>
        </trans-unit>
        <trans-unit id="dd14eed153c5e1b07e7490871396f032fee4f925" translate="yes" xml:space="preserve">
          <source>The provided context is used to kill the process (by calling os.Process.Kill) if the context becomes done before the command completes on its own.</source>
          <target state="translated">如果上下文在命令完成之前就已经完成了,那么所提供的上下文将被用来杀死进程(通过调用os.Process.Kill)。</target>
        </trans-unit>
        <trans-unit id="a4964ee167f777b88ff9017caa2a6e7f575494e2" translate="yes" xml:space="preserve">
          <source>The provided context is used until the transaction is committed or rolled back. If the context is canceled, the sql package will roll back the transaction. Tx.Commit will return an error if the context provided to BeginTx is canceled.</source>
          <target state="translated">所提供的上下文被使用,直到事务被提交或回滚。如果上下文被取消,sql包将回滚事务。如果提供给BeginTx的上下文被取消,Tx.Commit将返回一个错误。</target>
        </trans-unit>
        <trans-unit id="08a11fcf0761deb535b1afddd2450e0cb1b073dd" translate="yes" xml:space="preserve">
          <source>The provided context will be used for the preparation of the context, not for the execution of the returned statement. The returned statement will run in the transaction context.</source>
          <target state="translated">所提供的上下文将用于上下文的准备,而不是用于执行返回的语句。返回的语句将在事务上下文中运行。</target>
        </trans-unit>
        <trans-unit id="36087efe71a5f2727d53bfdfa94ece516eb41424" translate="yes" xml:space="preserve">
          <source>The provided key must be comparable and should not be of type string or any other built-in type to avoid collisions between packages using context. Users of WithValue should define their own types for keys. To avoid allocating when assigning to an interface{}, context keys often have concrete type struct{}. Alternatively, exported context key variables' static type should be a pointer or interface.</source>
          <target state="translated">所提供的键必须是可比较的,并且不应该是字符串或任何其他内置类型,以避免使用上下文的包之间发生碰撞。WithValue的用户应该自己定义键的类型。为了避免分配到接口{}时的分配,上下文键通常具有具体的类型struct{}。另外,导出的上下文键变量的静态类型应该是指针或接口。</target>
        </trans-unit>
        <trans-unit id="85ad36caa7041b29ad99437d10d43da203313ed0" translate="yes" xml:space="preserve">
          <source>The race detector kills the program if it exceeds 8192 concurrent goroutines, so use care when running parallel tests with the -race flag set.</source>
          <target state="translated">赛跑检测器会在超过8192个并发goroutines的情况下杀死程序,所以在设置-race标志的情况下运行并行测试时要小心。</target>
        </trans-unit>
        <trans-unit id="8b5744dbc3f5965d88d3d9f6581899823cd536e1" translate="yes" xml:space="preserve">
          <source>The rand parameter is used as a source of entropy to ensure that encrypting the same message twice doesn't result in the same ciphertext.</source>
          <target state="translated">rand参数作为熵的来源,以确保对同一消息加密两次不会产生相同的密文。</target>
        </trans-unit>
        <trans-unit id="9b3902f0d9da9da0e87784ba5652f4c8601d4919" translate="yes" xml:space="preserve">
          <source>The random parameter is used as a source of entropy to ensure that encrypting the same message twice doesn't result in the same ciphertext.</source>
          <target state="translated">随机参数作为熵的来源,以确保对同一消息加密两次不会产生相同的密文。</target>
        </trans-unit>
        <trans-unit id="cf169dddc14ea8341fcb30899e22a5fa61df4712" translate="yes" xml:space="preserve">
          <source>The random parameter, if not nil, is used to blind the private-key operation and avoid timing side-channel attacks. Blinding is purely internal to this function &amp;ndash; the random data need not match that used when encrypting.</source>
          <target state="translated">随机参数（如果不为nil）用于使私钥操作失效，并避免定时进行边信道攻击。盲处理纯粹是此功能的内部功能&amp;ndash;随机数据不必与加密时使用的数据匹配。</target>
        </trans-unit>
        <trans-unit id="2314ea9b04c810fb371325317bf102a02d2d59d0" translate="yes" xml:space="preserve">
          <source>The rawurl may be relative (a path, without a host) or absolute (starting with a scheme). Trying to parse a hostname and path without a scheme is invalid but may not necessarily return an error, due to parsing ambiguities.</source>
          <target state="translated">rawurl可以是相对的(一个路径,没有主机)或绝对的(以scheme开始)。试图解析一个没有方案的主机名和路径是无效的,但由于解析的模糊性,不一定会返回错误。</target>
        </trans-unit>
        <trans-unit id="239176c955d354cb84e342df1da6a160a09d1822" translate="yes" xml:space="preserve">
          <source>The read and write halves of the connection are serialized independently, so no interlocking is required. However each half may be accessed concurrently so the implementation of conn should protect against concurrent reads or concurrent writes.</source>
          <target state="translated">连接的读写两半是独立序列化的,所以不需要互锁。然而每一半都可能被并发访问,所以conn的实现应该防止并发读或并发写。</target>
        </trans-unit>
        <trans-unit id="b43ec28ed349612adbaa799bb6c92934c3b075dc" translate="yes" xml:space="preserve">
          <source>The real built-in function returns the real part of the complex number c. The return value will be floating point type corresponding to the type of c.</source>
          <target state="translated">实数内置函数返回复数c的实数部分,返回值将是c类型对应的浮点类型。</target>
        </trans-unit>
        <trans-unit id="9bb09164885f351e6fb900da553f1e63b375bfa9" translate="yes" xml:space="preserve">
          <source>The recognized day of week formats are &quot;Mon&quot; and &quot;Monday&quot;. The recognized month formats are &quot;Jan&quot; and &quot;January&quot;.</source>
          <target state="translated">公认的星期格式是 &quot;Mon &quot;和 &quot;Monday&quot;。公认的月份格式是 &quot;Jan &quot;和 &quot;January&quot;。</target>
        </trans-unit>
        <trans-unit id="2c571daa54e2fb7d0c128741daf715a11d1e44fe" translate="yes" xml:space="preserve">
          <source>The recover built-in function allows a program to manage behavior of a panicking goroutine. Executing a call to recover inside a deferred function (but not any function called by it) stops the panicking sequence by restoring normal execution and retrieves the error value passed to the call of panic. If recover is called outside the deferred function it will not stop a panicking sequence. In this case, or when the goroutine is not panicking, or if the argument supplied to panic was nil, recover returns nil. Thus the return value from recover reports whether the goroutine is panicking.</source>
          <target state="translated">内建的recover函数允许程序管理一个恐慌性程序的行为。在递延函数(但不包括被它调用的任何函数)中执行对recover的调用,通过恢复正常执行来停止恐慌序列,并检索传递给panic调用的错误值。如果在递延函数之外调用recover,则不会停止恐慌序列。在这种情况下,或者当goroutine没有恐慌时,或者如果提供给panic的参数是nil,recover就会返回nil。因此,recover的返回值会报告goroutine是否正在恐慌。</target>
        </trans-unit>
        <trans-unit id="ff14ed6c9720c452a0294998e96d92039ec86474" translate="yes" xml:space="preserve">
          <source>The regexp implementation provided by this package is guaranteed to run in time linear in the size of the input. (This is a property not guaranteed by most open source implementations of regular expressions.) For more information about this property, see</source>
          <target state="translated">本包提供的regexp实现保证在时间上以输入的大小线性运行。(这是大多数正则表达式的开源实现所不能保证的属性。)关于这个属性的更多信息,请参见</target>
        </trans-unit>
        <trans-unit id="e4c94cab05a4e2263ef4f912bc17e254d9de85c1" translate="yes" xml:space="preserve">
          <source>The regionType is used to classify regions, so there should be only a handful of unique region types.</source>
          <target state="translated">regionType用于对区域进行分类,所以应该只有少数独特的区域类型。</target>
        </trans-unit>
        <trans-unit id="613161bf225c19a5f2c8859dc32ad7cbf64fe341" translate="yes" xml:space="preserve">
          <source>The regular expression syntax understood by this package when parsing with the Perl flag is as follows. Parts of the syntax can be disabled by passing alternate flags to Parse.</source>
          <target state="translated">当使用Perl标志进行解析时,本包所理解的正则表达式语法如下。可以通过向 Parse 传递备用标志来禁用部分语法。</target>
        </trans-unit>
        <trans-unit id="414d3f9a62c65f403de754cbbecda8b294ef6a05" translate="yes" xml:space="preserve">
          <source>The remaining patterns enumerate the only valid conversions from uintptr to Pointer.</source>
          <target state="translated">剩下的模式列举了唯一有效的从uintptr到Pointer的转换。</target>
        </trans-unit>
        <trans-unit id="f01d454f6a8093b81d93ec48391c3d15861fea72" translate="yes" xml:space="preserve">
          <source>The remaining signals are asynchronous signals. They are not triggered by program errors, but are instead sent from the kernel or from some other program.</source>
          <target state="translated">其余的信号是异步信号,它们不是由程序错误触发的,而是由内核或其他程序发送的。它们不是由程序错误触发的,而是由内核或其他程序发送的。</target>
        </trans-unit>
        <trans-unit id="b6f243f72fd3fe537acd4a5fca41b95e81ce45b9" translate="yes" xml:space="preserve">
          <source>The representation of types is described below. When a type is defined on a given connection between an Encoder and Decoder, it is assigned a signed integer type id. When Encoder.Encode(v) is called, it makes sure there is an id assigned for the type of v and all its elements and then it sends the pair (typeid, encoded-v) where typeid is the type id of the encoded type of v and encoded-v is the gob encoding of the value v.</source>
          <target state="translated">类型的表示方法如下所述。当一个类型被定义在给定的编码器和解码器之间的连接上时,它会被分配一个有符号的整数类型id。当Encoder.Encode(v)被调用时,它确保为v的类型和它的所有元素分配了一个id,然后它发送一对(typeid,encoded-v),其中typeid是v的编码类型的类型id,encoded-v是值v的gob编码。</target>
        </trans-unit>
        <trans-unit id="cd667628565a5086d3e9895b56322424dc5621cd" translate="yes" xml:space="preserve">
          <source>The request Body, if non-nil, will be closed by the underlying Transport, even on errors.</source>
          <target state="translated">如果请求主体为非零,则会被底层传输关闭,即使出现错误。</target>
        </trans-unit>
        <trans-unit id="d4e026c3f59ca2f49146d499574e033e155a3b79" translate="yes" xml:space="preserve">
          <source>The resolver decision can be overridden by setting the netdns value of the GODEBUG environment variable (see package runtime) to go or cgo, as in:</source>
          <target state="translated">可以通过将GODEBUG环境变量(见包运行时)的netdns值设置为go或cgo来覆盖解析器的决定,如。</target>
        </trans-unit>
        <trans-unit id="85ba008f9a41b800d285074394b704f73cc09894" translate="yes" xml:space="preserve">
          <source>The rest of this package comment may be skipped on first reading; it includes details necessary to understand escaping contexts and error messages. Most users will not need to understand these details.</source>
          <target state="translated">这个包评论的其余部分可以在第一次阅读时跳过;它包含了理解转义上下文和错误信息所必需的细节。大多数用户不需要了解这些细节。</target>
        </trans-unit>
        <trans-unit id="5f29380aa9a229b911cfb4cbcef02c25951562ac" translate="yes" xml:space="preserve">
          <source>The rest of this section gives the precise details of how operations use monotonic clocks, but understanding those details is not required to use this package.</source>
          <target state="translated">本节其余部分给出了操作如何使用单调时钟的精确细节,但了解这些细节并不是使用这个包的必要条件。</target>
        </trans-unit>
        <trans-unit id="b7f11101676a7b7c4f383ade5d8d3f82131c1b53" translate="yes" xml:space="preserve">
          <source>The result of Scan is one of these tokens or a Unicode character.</source>
          <target state="translated">扫描的结果是这些标记中的一个或一个Unicode字符。</target>
        </trans-unit>
        <trans-unit id="4646462be207e1c8f655d521c7883b8db5be5339" translate="yes" xml:space="preserve">
          <source>The results of a benchmark run.</source>
          <target state="translated">基准运行的结果。</target>
        </trans-unit>
        <trans-unit id="6be7e87ff9924a05b7bc2a7006d807f1fab39e3d" translate="yes" xml:space="preserve">
          <source>The returned *Float f is nil and the value of z is valid but not defined if an error is reported.</source>
          <target state="translated">返回的*Float f为nil,z的值是有效的,但如果报错,则没有定义。</target>
        </trans-unit>
        <trans-unit id="bac86830681be1d31b72f9f7791b1c44ac2452e7" translate="yes" xml:space="preserve">
          <source>The returned Cmd's Args field is constructed from the command name followed by the elements of arg, so arg should not include the command name itself. For example, Command(&quot;echo&quot;, &quot;hello&quot;). Args[0] is always name, not the possibly resolved Path.</source>
          <target state="translated">返回的Cmd的Args字段是由命令名后面的arg元素构造的,所以arg不应该包括命令名本身。例如,Command(&quot;echo&quot;,&quot;hello&quot;)。Args[0]总是name,而不是可能解析的Path。</target>
        </trans-unit>
        <trans-unit id="fe921f2e96cf2be56c2bf49f4740170d8dd45071" translate="yes" xml:space="preserve">
          <source>The returned Conn, if any, will always be of type *Conn.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bc6a14f8ce0d88107543f9f02901b96c67b460c" translate="yes" xml:space="preserve">
          <source>The returned DB is safe for concurrent use by multiple goroutines and maintains its own pool of idle connections. Thus, the Open function should be called just once. It is rarely necessary to close a DB.</source>
          <target state="translated">返回的DB可以安全地被多个goroutine并发使用,并维护自己的空闲连接池。因此,Open函数应该只被调用一次。很少需要关闭一个DB。</target>
        </trans-unit>
        <trans-unit id="c94572c3b7d816968d78d57402944f7efb4246e7" translate="yes" xml:space="preserve">
          <source>The returned DB is safe for concurrent use by multiple goroutines and maintains its own pool of idle connections. Thus, the OpenDB function should be called just once. It is rarely necessary to close a DB.</source>
          <target state="translated">返回的DB对于多个goroutine并发使用是安全的,并且维护自己的空闲连接池。因此,OpenDB函数应该只被调用一次。很少需要关闭一个DB。</target>
        </trans-unit>
        <trans-unit id="33f1666e076b57e7a3379acacb81a7ec24e7d31d" translate="yes" xml:space="preserve">
          <source>The returned RawConn only supports calling Control. Read and Write return an error.</source>
          <target state="translated">返回的RawConn只支持调用Control。读和写都会返回一个错误。</target>
        </trans-unit>
        <trans-unit id="00382818b7b561dcf8c2e41afc3acbf78809ee7a" translate="yes" xml:space="preserve">
          <source>The returned Response will have at least its StatusCode, Header, Body, and optionally Trailer populated. More fields may be populated in the future, so callers should not DeepEqual the result in tests.</source>
          <target state="translated">返回的Response将至少填充其StatusCode、Header、Body和可选的Trailer。未来可能会有更多的字段被填充,所以调用者不应该在测试中对结果进行DeepEqual。</target>
        </trans-unit>
        <trans-unit id="f4f37717fc57244b8b099472fa87f281f196d58d" translate="yes" xml:space="preserve">
          <source>The returned context is always non-nil; it defaults to the background context.</source>
          <target state="translated">返回的上下文总是非零,它默认为背景上下文。</target>
        </trans-unit>
        <trans-unit id="9cbe06fbabaade2695a345469e46bbf5011eaae5" translate="yes" xml:space="preserve">
          <source>The returned end function is used to mark the task's end. The trace tool measures task latency as the time between task creation and when the end function is called, and provides the latency distribution per task type. If the end function is called multiple times, only the first call is used in the latency measurement.</source>
          <target state="translated">返回的结束函数用于标记任务的结束。跟踪工具将任务延迟测量为从任务创建到调用结束函数之间的时间,并提供每个任务类型的延迟分布。如果结束函数被多次调用,则延迟测量中只使用第一次调用。</target>
        </trans-unit>
        <trans-unit id="f0a8feeaa4dbaf36e773a52f49c0b0ac6bb7e74a" translate="yes" xml:space="preserve">
          <source>The returned error is nil if the command runs, has no problems copying stdin, stdout, and stderr, and exits with a zero exit status.</source>
          <target state="translated">如果命令运行,复制stdin、stdout和stderr没有问题,并且退出状态为零,则返回的错误为nil。</target>
        </trans-unit>
        <trans-unit id="4d6b3f09dc97620be2a232fb3dc17468c15d1426" translate="yes" xml:space="preserve">
          <source>The returned list does not identify the associated interface; use Interfaces and Interface.Addrs for more detail.</source>
          <target state="translated">返回的列表并不能识别相关的接口;使用Interfaces和Interface.Addrs了解更多细节。</target>
        </trans-unit>
        <trans-unit id="c6a6b1723d6bc4ac24e64af0ce75d94122db9245" translate="yes" xml:space="preserve">
          <source>The returned memory allocator statistics are up to date as of the call to ReadMemStats. This is in contrast with a heap profile, which is a snapshot as of the most recently completed garbage collection cycle.</source>
          <target state="translated">返回的内存分配器统计数据在调用ReadMemStats时是最新的。这与堆配置文件不同,堆配置文件是最近完成的垃圾收集周期的快照。</target>
        </trans-unit>
        <trans-unit id="a6ee6f83dacc73003b6dade23a5eca55ab60b66f" translate="yes" xml:space="preserve">
          <source>The returned os.File's file descriptor is different from the connection's. Attempting to change properties of the original using this duplicate may or may not have the desired effect.</source>
          <target state="translated">返回的 os.File 的文件描述符与连接的不同。试图使用这个副本来改变原始文件的属性,可能会或可能不会达到预期的效果。</target>
        </trans-unit>
        <trans-unit id="5927f2050b65cd29032e207117c8b2d6ca472e54" translate="yes" xml:space="preserve">
          <source>The returned path ends in a slash only if it is the root &quot;/&quot;.</source>
          <target state="translated">只有当路径是根目录&quot;/&quot;时,返回的路径才以斜线结束。</target>
        </trans-unit>
        <trans-unit id="004ac519a1c16ea761d189382ea9cc0c1b68b7d1" translate="yes" xml:space="preserve">
          <source>The returned path ends in a slash only if it represents a root directory, such as &quot;/&quot; on Unix or `C:\` on Windows.</source>
          <target state="translated">返回的路径只有在代表根目录的情况下才以斜线结尾,比如Unix上的&quot;/&quot;或Windows上的`C:\`。</target>
        </trans-unit>
        <trans-unit id="709611ccac6cb61ed7ee0c2fc8499ed7e268fed4" translate="yes" xml:space="preserve">
          <source>The returned profile may be up to two garbage collection cycles old. This is to avoid skewing the profile toward allocations; because allocations happen in real time but frees are delayed until the garbage collector performs sweeping, the profile only accounts for allocations that have had a chance to be freed by the garbage collector.</source>
          <target state="translated">返回的配置文件可能是两个垃圾收集周期前的。这是为了避免配置文件偏向于分配;因为分配是实时发生的,但释放是延迟的,直到垃圾收集器执行扫除,所以配置文件只记录有机会被垃圾收集器释放的分配。</target>
        </trans-unit>
        <trans-unit id="2fcbc7cecfbd88a968cff813905d726fdf40b131" translate="yes" xml:space="preserve">
          <source>The returned slice is the certificate in DER encoding.</source>
          <target state="translated">返回的分片是DER编码的证书。</target>
        </trans-unit>
        <trans-unit id="01c758564c188da314abf0218bd7cfbe2c752f80" translate="yes" xml:space="preserve">
          <source>The returned slice is the certificate request in DER encoding.</source>
          <target state="translated">返回的分片是DER编码的证书请求。</target>
        </trans-unit>
        <trans-unit id="56ef9da288a159e17f780d686422f0dfcfa221a7" translate="yes" xml:space="preserve">
          <source>The returned statement operates within the transaction and can no longer be used once the transaction has been committed or rolled back.</source>
          <target state="translated">返回的语句在事务中操作,一旦事务被提交或回滚,就不能再使用。</target>
        </trans-unit>
        <trans-unit id="eaef2ac25b5ec95632c077f9297b6bf55f5dd3f6" translate="yes" xml:space="preserve">
          <source>The returned statement operates within the transaction and will be closed when the transaction has been committed or rolled back.</source>
          <target state="translated">被退回的报表在交易内操作,当交易被承诺或回滚时,将被关闭。</target>
        </trans-unit>
        <trans-unit id="10df7eea472cec1ead17a66cb1fdaefe2e6578cc" translate="yes" xml:space="preserve">
          <source>The returned string is meant for debugging; for a stable serialized representation, use t.MarshalText, t.MarshalBinary, or t.Format with an explicit format string.</source>
          <target state="translated">返回的字符串是用来调试的;要想获得稳定的序列化表示,请使用t.MarshalText、t.MarshalBinary或t.Format,并使用明确的格式字符串。</target>
        </trans-unit>
        <trans-unit id="48866f9aa69c2bb04dcb85d20c5a3c1d2d405ca8" translate="yes" xml:space="preserve">
          <source>The rule Title uses for word boundaries does not handle Unicode punctuation properly.</source>
          <target state="translated">Title使用的单词边界规则不能正确处理Unicode标点符号。</target>
        </trans-unit>
        <trans-unit id="f80f01b0edf7103d5ecb8ca06eb4e22919710f70" translate="yes" xml:space="preserve">
          <source>The same Context may be passed to functions running in different goroutines; Contexts are safe for simultaneous use by multiple goroutines.</source>
          <target state="translated">同一上下文可以传递给在不同的goroutine中运行的函数;上下文对于多个goroutine同时使用是安全的。</target>
        </trans-unit>
        <trans-unit id="a401c4efb67cc0055f52caa84dcf2de0d8f63cd7" translate="yes" xml:space="preserve">
          <source>The second argument, quote, specifies the type of literal being parsed and therefore which escaped quote character is permitted. If set to a single quote, it permits the sequence \' and disallows unescaped '. If set to a double quote, it permits \&quot; and disallows unescaped &quot;. If set to zero, it does not permit either escape and allows both quote characters to appear unescaped.</source>
          <target state="translated">第二个参数quote指定了被解析的文字类型,因此允许使用哪种转义引号字符。如果设置为单引号,它允许使用序列&quot;/&quot;,而不允许使用未转义的&quot;&quot;。如果设置为双引号,则允许使用&quot;/&quot;,不允许使用未封顶的&quot;&quot;。如果设置为零,则不允许任何一个转义字符,允许两个引号字符都不封顶。</target>
        </trans-unit>
        <trans-unit id="40a1d3ecbed0bf217ec97ece1c42e914315bd313" translate="yes" xml:space="preserve">
          <source>The security model used by this package assumes that template authors are trusted, while Execute's data parameter is not. More details are provided below.</source>
          <target state="translated">本包使用的安全模型假设模板作者是可信的,而Execute的数据参数是不可信的。下面提供更多细节。</target>
        </trans-unit>
        <trans-unit id="a70cb84ae80d93013971dc3c09e0dd11fbe3a660" translate="yes" xml:space="preserve">
          <source>The server calls (for HTTP service):</source>
          <target state="translated">服务器调用(用于HTTP服务)。</target>
        </trans-unit>
        <trans-unit id="4694acea63f5ebf8b8be35e4e84982505cd7d21a" translate="yes" xml:space="preserve">
          <source>The server may handle requests on a single connection by calling ServeConn. More typically it will create a network listener and call Accept or, for an HTTP listener, HandleHTTP and http.Serve.</source>
          <target state="translated">服务器可以通过调用ServeConn来处理单个连接上的请求,更典型的是它会创建网络监听器并调用Accept,或者对于HTTP监听器,调用HandleHTTP和http.Serve。更典型的是,它将创建一个网络监听器并调用Accept,或者对于一个HTTP监听器,调用HandleHTTP和http.Serve。</target>
        </trans-unit>
        <trans-unit id="901fd3527b931189389dc8b05aa80a401b308de0" translate="yes" xml:space="preserve">
          <source>The set of available CPUs is checked by querying the operating system at process startup. Changes to operating system CPU allocation after process startup are not reflected.</source>
          <target state="translated">在进程启动时通过查询操作系统来检查可用CPU的集合。进程启动后操作系统CPU分配的变化不会被反映出来。</target>
        </trans-unit>
        <trans-unit id="10e3cd17c3685da24fcde871ef4da00a080771a9" translate="yes" xml:space="preserve">
          <source>The signals SIGKILL and SIGSTOP may not be caught by a program, and therefore cannot be affected by this package.</source>
          <target state="translated">信号SIGKILL和SIGSTOP可能不会被程序捕获,因此不会受到这个软件包的影响。</target>
        </trans-unit>
        <trans-unit id="7621705ac03f21ac222836c967959708135562eb" translate="yes" xml:space="preserve">
          <source>The simplest use of a Scanner, to read standard input as a set of lines.</source>
          <target state="translated">扫描仪最简单的用法,就是将标准输入作为一组行来读取。</target>
        </trans-unit>
        <trans-unit id="9c0657904725889b0c9ba75534abc4f635bc0b2b" translate="yes" xml:space="preserve">
          <source>The size of a CRC-32 checksum in bytes.</source>
          <target state="translated">CRC-32校验和的大小,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="3ff608e7233df0580119a8a262ba634622895d8a" translate="yes" xml:space="preserve">
          <source>The size of a CRC-64 checksum in bytes.</source>
          <target state="translated">CRC-64校验和的大小,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="caae8e5aad6dbb0160181390b9818b080d122c80" translate="yes" xml:space="preserve">
          <source>The size of a SHA-1 checksum in bytes.</source>
          <target state="translated">SHA-1校验和的大小,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="cea16f97cc88534275f0e03f305d57951a36e34b" translate="yes" xml:space="preserve">
          <source>The size of a SHA224 checksum in bytes.</source>
          <target state="translated">SHA224校验和的大小,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="3a1556147bf25a0038243a962f16bc9d44b98e20" translate="yes" xml:space="preserve">
          <source>The size of a SHA256 checksum in bytes.</source>
          <target state="translated">SHA256校验和的大小,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="fb49c909a50ec86545c33e34c0f3d64148914e03" translate="yes" xml:space="preserve">
          <source>The size of an Adler-32 checksum in bytes.</source>
          <target state="translated">以字节为单位的Adler-32校验和的大小。</target>
        </trans-unit>
        <trans-unit id="edf1ef16cc66ffa121682ca1207ef5467651c4f4" translate="yes" xml:space="preserve">
          <source>The size of an MD5 checksum in bytes.</source>
          <target state="translated">MD5校验和的大小,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="248e03e24b52c36053fea2b5fabdbb42fe255abb" translate="yes" xml:space="preserve">
          <source>The skip parameter has the same meaning as runtime.Caller's skip and controls where the stack trace begins. Passing skip=0 begins the trace in the function calling Add. For example, given this execution stack:</source>
          <target state="translated">skip参数与runtime.Caller的skip意义相同,控制堆栈跟踪的开始位置。传递 skip=0,则在调用 Add 的函数中开始跟踪。例如,给定这个执行栈。</target>
        </trans-unit>
        <trans-unit id="b675e8a3e2a529e23f6f667c1adf36c39ed93efb" translate="yes" xml:space="preserve">
          <source>The slice returned by this method consists of all the substrings of s not contained in the slice returned by FindAllString. When called on an expression that contains no metacharacters, it is equivalent to strings.SplitN.</source>
          <target state="translated">本方法返回的分片由FindAllString返回的分片中未包含的s的所有子串组成。当调用一个不包含元字符的表达式时,它相当于strings.SplitN。</target>
        </trans-unit>
        <trans-unit id="37fc7946d5ac5fa1638ca298818fb97686f9142e" translate="yes" xml:space="preserve">
          <source>The smtp package is frozen and is not accepting new features. Some external packages provide more functionality. See:</source>
          <target state="translated">smtp包被冻结,不接受新功能。一些外部软件包提供了更多的功能。请看:</target>
        </trans-unit>
        <trans-unit id="37671db71f74ceff10a366ff8f17e7a0a28fae66" translate="yes" xml:space="preserve">
          <source>The sort is not guaranteed to be stable. For a stable sort, use SliceStable.</source>
          <target state="translated">不保证排序的稳定性。对于稳定的排序,请使用 SliceStable。</target>
        </trans-unit>
        <trans-unit id="17c5e77086e67a3f2c51a48bac9596dffc360456" translate="yes" xml:space="preserve">
          <source>The source and destination values/types need not correspond exactly. For structs, fields (identified by name) that are in the source but absent from the receiving variable will be ignored. Fields that are in the receiving variable but missing from the transmitted type or value will be ignored in the destination. If a field with the same name is present in both, their types must be compatible. Both the receiver and transmitter will do all necessary indirection and dereferencing to convert between gobs and actual Go values. For instance, a gob type that is schematically,</source>
          <target state="translated">源和目标值/类型不需要完全对应。对于结构,源变量中的字段(用名称标识),但接收变量中没有的字段将被忽略。对于结构体来说,源变量中的字段(用名字标识)在接收变量中,但在接收变量中不存在的字段将被忽略;在目标变量中,在接收变量中但在传输的类型或值中缺失的字段将被忽略。如果一个名字相同的字段出现在两个变量中,它们的类型必须是兼容的。接收器和发送器都会做所有必要的内推和去引用,以便在gob和实际的围棋值之间进行转换。例如,一个gob类型在原理上是:</target>
        </trans-unit>
        <trans-unit id="0268779129500cf4856c5f56fd67106abaf097eb" translate="yes" xml:space="preserve">
          <source>The source code could include additional Go code. That code was never compiled but would be processed by tools like godoc and might be useful as end-user documentation.</source>
          <target state="translated">源代码可以包括额外的Go代码。这些代码从未被编译过,但会被像godoc这样的工具处理,并可能作为终端用户的文档。</target>
        </trans-unit>
        <trans-unit id="535d0edaef1db8d5c1dc136b1a303868255bb996" translate="yes" xml:space="preserve">
          <source>The source:</source>
          <target state="translated">来源:</target>
        </trans-unit>
        <trans-unit id="e645e5bfb164f126d92a3414aa1a585176c8e465" translate="yes" xml:space="preserve">
          <source>The sql package checks for value checkers in the following order, stopping at the first found match: Stmt.NamedValueChecker, Conn.NamedValueChecker, Stmt.ColumnConverter, DefaultParameterConverter.</source>
          <target state="translated">sql包按照以下顺序检查值检查器,在第一个发现的匹配处停止。Stmt.NamedValueChecker,Conn.NamedValueChecker,Stmt.ColumnConverter,DefaultParameterConverter.</target>
        </trans-unit>
        <trans-unit id="bf35db5d84a5c59679d57c2063978bf2973a302c" translate="yes" xml:space="preserve">
          <source>The sql package creates and frees connections automatically; it also maintains a free pool of idle connections. If the database has a concept of per-connection state, such state can be reliably observed within a transaction (Tx) or connection (Conn). Once DB.Begin is called, the returned Tx is bound to a single connection. Once Commit or Rollback is called on the transaction, that transaction's connection is returned to DB's idle connection pool. The pool size can be controlled with SetMaxIdleConns.</source>
          <target state="translated">sql包会自动创建和释放连接;它还会维护一个空闲的连接池。如果数据库有每个连接状态的概念,那么这种状态可以在一个事务(Tx)或连接(Conn)中可靠地观察到。一旦DB.Begin被调用,返回的Tx就会被绑定到单个连接上。一旦在事务上调用Commit或Rollback,该事务的连接就会返回到DB的空闲连接池中。池的大小可以通过SetMaxIdleConns来控制。</target>
        </trans-unit>
        <trans-unit id="14c50009f306ef9ba308a3f9f45cb12ceab6e041" translate="yes" xml:space="preserve">
          <source>The sql package must be used in conjunction with a database driver. See &lt;a href=&quot;https://golang.org/s/sqldrivers&quot;&gt;https://golang.org/s/sqldrivers&lt;/a&gt; for a list of drivers.</source>
          <target state="translated">sql程序包必须与数据库驱动程序一起使用。有关驱动程序列表，请参见&lt;a href=&quot;https://golang.org/s/sqldrivers&quot;&gt;https://golang.org/s/sqldrivers&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ff11c76849e5520b5d3c1908876a0a08249bbd90" translate="yes" xml:space="preserve">
          <source>The src/ directory holds source code. The path below 'src' determines the import path or executable name.</source>
          <target state="translated">src/目录下存放的是源代码。src &quot;下面的路径决定了导入路径或可执行文件的名称。</target>
        </trans-unit>
        <trans-unit id="51fce287253a04b9aa4e50fe0cda26970eb0eeca" translate="yes" xml:space="preserve">
          <source>The statements prepared for a transaction by calling the transaction's Prepare or Stmt methods are closed by the call to Commit or Rollback.</source>
          <target state="translated">通过调用事务的Prepare或Stmt方法为事务准备的语句,通过调用Commit或Rollback关闭。</target>
        </trans-unit>
        <trans-unit id="266ee83c3a485624a9ce3be711986c42904d65df" translate="yes" xml:space="preserve">
          <source>The swap operation, implemented by the SwapT functions, is the atomic equivalent of:</source>
          <target state="translated">由SwapT函数实现的交换操作,其原子等价物为:。</target>
        </trans-unit>
        <trans-unit id="78109ee602f829fc62630aa0958e0668bde1d9d0" translate="yes" xml:space="preserve">
          <source>The symbolizer function may be nil, in which case the results of the traceback function will be displayed as numbers. If the traceback function is nil, the symbolizer function will never be called. The context function may be nil, in which case the traceback function will only be called with the context field set to zero. If the context function is nil, then calls from Go to C to Go will not show a traceback for the C portion of the call stack.</source>
          <target state="translated">符号化函数可能为零,在这种情况下,回溯函数的结果将显示为数字。如果回溯函数为零,符号函数将永远不会被调用。上下文函数可能为零,在这种情况下,只有当上下文字段设置为零时,才会调用回溯函数。如果上下文函数为nil,那么从Go到C到Go的调用将不会显示调用栈中C部分的回溯。</target>
        </trans-unit>
        <trans-unit id="7f3f65f4777096791e56d64b25eeec76abb44bfa" translate="yes" xml:space="preserve">
          <source>The symbolizer function will be called with a single argument, a pointer to a struct:</source>
          <target state="translated">符号化函数将被调用,只有一个参数,即一个指向结构体的指针。</target>
        </trans-unit>
        <trans-unit id="826b161e82b6e953fc66964167887f9fb128e89d" translate="yes" xml:space="preserve">
          <source>The syntax of such definitions is to surround each template declaration with a &quot;define&quot; and &quot;end&quot; action.</source>
          <target state="translated">这种定义的语法是在每个模板声明的周围加上一个 &quot;定义 &quot;和 &quot;结束 &quot;的动作。</target>
        </trans-unit>
        <trans-unit id="a896d242a72cd56df044b310d3d7e48636436044" translate="yes" xml:space="preserve">
          <source>The syntax of the regular expressions accepted is the same general syntax used by Perl, Python, and other languages. More precisely, it is the syntax accepted by RE2 and described at &lt;a href=&quot;https://golang.org/s/re2syntax&quot;&gt;https://golang.org/s/re2syntax&lt;/a&gt;, except for \C. For an overview of the syntax, run</source>
          <target state="translated">接受的正则表达式的语法与Perl，Python和其他语言使用的常规语法相同。更准确地说，它是RE2接受的语法，并在&lt;a href=&quot;https://golang.org/s/re2syntax&quot;&gt;https://golang.org/s/re2syntax中进行了&lt;/a&gt;描述，除了\ C。有关语法的概述，请运行</target>
        </trans-unit>
        <trans-unit id="ba2393e2ef8002ea106da87efa718a59742fc7ac" translate="yes" xml:space="preserve">
          <source>The syslog package is frozen and is not accepting new features. Some external packages provide more functionality. See:</source>
          <target state="translated">syslog包被冻结,不接受新功能。一些外部软件包提供了更多的功能。请看:</target>
        </trans-unit>
        <trans-unit id="99e701177eab165c110f7e05395c5e3f3462fc8b" translate="yes" xml:space="preserve">
          <source>The table's lower portion shows specialized features of each format, such as supported string encodings, support for sub-second timestamps, or support for sparse files.</source>
          <target state="translated">该表的下半部分显示了每种格式的特殊功能,如支持的字符串编码、对亚秒级时间戳的支持或对稀疏文件的支持。</target>
        </trans-unit>
        <trans-unit id="e6cfcc2895da4e068fb4279dd7ba0aaf57b5ca4f" translate="yes" xml:space="preserve">
          <source>The table's upper portion shows the Header fields, where each format reports the maximum number of bytes allowed for each string field and the integer type used to store each numeric field (where timestamps are stored as the number of seconds since the Unix epoch).</source>
          <target state="translated">该表的上半部分显示了Header字段,其中每种格式都报告了每个字符串字段允许的最大字节数,以及用于存储每个数字字段的整数类型(其中时间戳被存储为Unix纪元以来的秒数)。</target>
        </trans-unit>
        <trans-unit id="b0a984b621ec68366c5b1261f609a8ab7bb45ea3" translate="yes" xml:space="preserve">
          <source>The tag must be one that takes string values: DT_NEEDED, DT_SONAME, DT_RPATH, or DT_RUNPATH.</source>
          <target state="translated">该标签必须是接受字符串值的标签。DT_NEEDED、DT_SONAME、DT_RPATH或DT_RUNPATH。</target>
        </trans-unit>
        <trans-unit id="cbe588a5ff1a44ccc9c3b05cfac0b378253441ae" translate="yes" xml:space="preserve">
          <source>The target is the RFC 7230 &quot;request-target&quot;: it may be either a path or an absolute URL. If target is an absolute URL, the host name from the URL is used. Otherwise, &quot;example.com&quot; is used.</source>
          <target state="translated">target是RFC 7230 &quot;request-target&quot;:它可以是一个路径,也可以是一个绝对URL。如果目标是绝对URL,则使用URL中的主机名。否则,使用 &quot;example.com&quot;。</target>
        </trans-unit>
        <trans-unit id="a6f845f916ddb97993362899697ada283b05c4e3" translate="yes" xml:space="preserve">
          <source>The taskType is used to classify task instances. Analysis tools like the Go execution tracer may assume there are only a bounded number of unique task types in the system.</source>
          <target state="translated">taskType用于对任务实例进行分类。像围棋执行跟踪器这样的分析工具可能会假设系统中只有一定数量的唯一任务类型。</target>
        </trans-unit>
        <trans-unit id="87c98cdec407269913a37379692f0119d00836f4" translate="yes" xml:space="preserve">
          <source>The template</source>
          <target state="translated">模板</target>
        </trans-unit>
        <trans-unit id="8dbf1659d9b474dfc6de39448622e749ace9eba6" translate="yes" xml:space="preserve">
          <source>The testing/quick package is frozen and is not accepting new features.</source>
          <target state="translated">测试/快速包被冻结,不接受新功能。</target>
        </trans-unit>
        <trans-unit id="450bac070fc3c1d570ed998a1290dd681976d259" translate="yes" xml:space="preserve">
          <source>The text returned from ReadLine does not include the line end (&quot;\r\n&quot; or &quot;\n&quot;). No indication or error is given if the input ends without a final line end. Calling UnreadByte after ReadLine will always unread the last byte read (possibly a character belonging to the line end) even if that byte is not part of the line returned by ReadLine.</source>
          <target state="translated">ReadLine返回的文本不包括行尾(&quot;\r\n &quot;或&quot;\n&quot;)。如果输入结束时没有最后的行结束符,则不会给出任何指示或错误。在ReadLine之后调用UnreadByte将总是取消读取最后一个字节(可能是属于行尾的字符),即使该字节不是ReadLine返回的行的一部分。</target>
        </trans-unit>
        <trans-unit id="e19ad8a62ebb2f930cd2d412533e63ab163f9e7f" translate="yes" xml:space="preserve">
          <source>The text/tabwriter package is frozen and is not accepting new features.</source>
          <target state="translated">text/tabwriter包被冻结,不接受新功能。</target>
        </trans-unit>
        <trans-unit id="b8b4c6c4010154e59471f9dc5acececde45e4c79" translate="yes" xml:space="preserve">
          <source>The time zone database needed by LoadLocation may not be present on all systems, especially non-Unix systems. LoadLocation looks in the directory or uncompressed zip file named by the ZONEINFO environment variable, if any, then looks in known installation locations on Unix systems, and finally looks in $GOROOT/lib/time/zoneinfo.zip.</source>
          <target state="translated">LoadLocation 所需的时区数据库可能并不是在所有系统上都存在,尤其是非 Unix 系统。LoadLocation会在ZONEINFO环境变量命名的目录或未压缩的zip文件中查找(如果有的话),然后在Unix系统中查找已知的安装位置,最后在$GOROOT/lib/time/zoneinfo.zip中查找。</target>
        </trans-unit>
        <trans-unit id="d9d95ea8fa35077316d58a8c096d78c878d9e8de" translate="yes" xml:space="preserve">
          <source>The timeout includes name resolution, if required. When using TCP, and the host in the address parameter resolves to multiple IP addresses, the timeout is spread over each consecutive dial, such that each is given an appropriate fraction of the time to connect.</source>
          <target state="translated">如果需要,超时时间包括名称解析。当使用TCP,并且地址参数中的主机解析到多个IP地址时,超时时间将分摊到每一个连续的拨号中,这样每个拨号都有适当的部分时间来连接。</target>
        </trans-unit>
        <trans-unit id="1be65b230e905dbffd21fbadb56320938e08062d" translate="yes" xml:space="preserve">
          <source>The tools that process the memory profiles assume that the profile rate is constant across the lifetime of the program and equal to the current value. Programs that change the memory profiling rate should do so just once, as early as possible in the execution of the program (for example, at the beginning of main).</source>
          <target state="translated">处理内存剖面的工具假设剖面率在程序的整个生命周期内是恒定的,并且等于当前的值。程序如果要改变内存剖面率,应该只改变一次,在程序执行的早期(例如,在main开始时)。</target>
        </trans-unit>
        <trans-unit id="1a177d1df849e44bddcb9ba4d4be3d9812f21f16" translate="yes" xml:space="preserve">
          <source>The trace tool computes the latency of a task by measuring the time between the task creation and the task end and provides latency distributions for each task type found in the trace.</source>
          <target state="translated">跟踪工具通过测量任务创建和任务结束之间的时间来计算任务的延迟,并为跟踪中发现的每种任务类型提供延迟分布。</target>
        </trans-unit>
        <trans-unit id="62d0bac03a171fb89c5dd19570b301f5442565f7" translate="yes" xml:space="preserve">
          <source>The traceback and context functions may be called from a signal handler, and must therefore use only async-signal safe functions. The symbolizer function may be called while the program is crashing, and so must be cautious about using memory. None of the functions may call back into Go.</source>
          <target state="translated">追溯函数和上下文函数可能会被信号处理程序调用,因此必须只使用异步信号安全函数。符号化函数可能在程序崩溃时被调用,因此必须谨慎使用内存。这些函数都不可以调用回Go。</target>
        </trans-unit>
        <trans-unit id="64b5d618701b94606e91495371f70fb5b100120e" translate="yes" xml:space="preserve">
          <source>The traceback function will be called with a single argument, a pointer to a struct:</source>
          <target state="translated">回溯函数将被调用,只有一个参数,即指向结构体的指针。</target>
        </trans-unit>
        <trans-unit id="fbcd1af40286bdefbe9605ee1269e5d70a141d29" translate="yes" xml:space="preserve">
          <source>The two methods Network and String conventionally return strings that can be passed as the arguments to Dial, but the exact form and meaning of the strings is up to the implementation.</source>
          <target state="translated">Network和String这两个方法约定俗成地返回可以作为参数传递给Dial的字符串,但字符串的具体形式和含义由实现者决定。</target>
        </trans-unit>
        <trans-unit id="ee1fff48d57b4264c60df5732fa6d287858ca513" translate="yes" xml:space="preserve">
          <source>The typ argument may be a defined (Named) type or an alias type. It may also be nil such that the returned TypeName can be used as argument for NewNamed, which will set the TypeName's type as a side- effect.</source>
          <target state="translated">typ参数可以是一个定义的(Named)类型或一个别名类型。它也可以是nil,这样返回的TypeName可以作为NewNamed的参数,NewNamed将设置TypeName的类型作为副作用。</target>
        </trans-unit>
        <trans-unit id="761242af94989502320341408ab25169d28b2151" translate="yes" xml:space="preserve">
          <source>The typical use case for NewFileTransport is to register the &quot;file&quot; protocol with a Transport, as in:</source>
          <target state="translated">NewFileTransport的典型用例是将 &quot;文件 &quot;协议注册到一个Transport中,如。</target>
        </trans-unit>
        <trans-unit id="c9dec8fd9ff2613dd03956d5301652519fcaec0c" translate="yes" xml:space="preserve">
          <source>The underlying filesystem may truncate or round the values to a less precise time unit. If there is an error, it will be of type *PathError.</source>
          <target state="translated">底层文件系统可能会截断或四舍五入这些值,使其成为一个不太精确的时间单位。如果有错误,它的类型将是*PathError。</target>
        </trans-unit>
        <trans-unit id="bc08db1aae610f1545a452a1bb5a7582597ab3b7" translate="yes" xml:space="preserve">
          <source>The usage message will appear on a separate line for anything but a bool flag with a one-byte name. For bool flags, the type is omitted and if the flag name is one byte the usage message appears on the same line. The parenthetical default is omitted if the default is the zero value for the type. The listed type, here int, can be changed by placing a back-quoted name in the flag's usage string; the first such item in the message is taken to be a parameter name to show in the message and the back quotes are stripped from the message when displayed. For instance, given</source>
          <target state="translated">除了一个名字为一个字节的布尔标志外,其他任何标志的使用信息都会出现在单独的一行上,对于布尔标志,类型会被省略,如果标志的名字是一个字节,则使用信息会出现在同一行上。对于bool标志,类型会被省略,如果标志名是一个字节,使用信息会出现在同一行。如果默认是类型的零值,则省略括号中的默认值。列举的类型,这里是int,可以通过在标志的用法字符串中放置一个反引号的名称来改变,消息中的第一个这样的项目被当作参数名称显示在消息中,显示时,反引号会从消息中剥离。例如,给定</target>
        </trans-unit>
        <trans-unit id="7175f6a7da0429173b6be919d1c9513e0498e3e7" translate="yes" xml:space="preserve">
          <source>The value 0xff was chosen because it cannot appear in a valid UTF-8 sequence.</source>
          <target state="translated">选择0xff是因为它不能出现在有效的UTF-8序列中。</target>
        </trans-unit>
        <trans-unit id="e4328a7e24cd2970818970fe425c0b1b3c86f9d7" translate="yes" xml:space="preserve">
          <source>The variadic argument controls whether the function is variadic. FuncOf panics if the in[len(in)-1] does not represent a slice and variadic is true.</source>
          <target state="translated">variadic参数控制函数是否为变量。如果in[len(in)-1]不代表一个片,并且variadic为真,FuncOf会恐慌。</target>
        </trans-unit>
        <trans-unit id="1e72c26ccaadcb98e76249dcd1c8f3cdb175e9de" translate="yes" xml:space="preserve">
          <source>The varint functions encode and decode single integer values using a variable-length encoding; smaller values require fewer bytes. For a specification, see &lt;a href=&quot;https://developers.google.com/protocol-buffers/docs/encoding&quot;&gt;https://developers.google.com/protocol-buffers/docs/encoding&lt;/a&gt;.</source>
          <target state="translated">varint函数使用可变长度编码对单个整数值进行编码和解码；较小的值需要较少的字节。有关规范，请参见&lt;a href=&quot;https://developers.google.com/protocol-buffers/docs/encoding&quot;&gt;https://developers.google.com/protocol-buffers/docs/encoding&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5cdb175715a8f3e26508e589b1b8622549f73fd8" translate="yes" xml:space="preserve">
          <source>The verbs behave analogously to those of Printf. For example, %x will scan an integer as a hexadecimal number, and %v will scan the default representation format for the value. The Printf verbs %p and %T and the flags # and + are not implemented. For floating-point and complex values, all valid formatting verbs (%b %e %E %f %F %g %G %x %X and %v) are equivalent and accept both decimal and hexadecimal notation (for example: &quot;2.3e+7&quot;, &quot;0x4.5p-8&quot;) and digit-separating underscores (for example: &quot;3.14159_26535_89793&quot;).</source>
          <target state="translated">这些动词的行为类似于Printf的行为。例如,%x将扫描一个整数作为十六进制数,而%v将扫描该值的默认表示格式。Printf动词%p和%T以及标志#和+没有实现。对于浮点和复数,所有有效的格式动词(%b %e %E %f %F %g %G %x %X和%v)都是等价的,并且接受十进制和十六进制符号(例如:&quot;2.3e+7&quot;,&quot;0x4.5p-8&quot;)和数字分隔的下划线(例如:&quot;3.14159_26535_89793&quot;)。</target>
        </trans-unit>
        <trans-unit id="a6ebe1343c13ca95e202e147b7f816ef1bc435a4" translate="yes" xml:space="preserve">
          <source>The verbs:</source>
          <target state="translated">的动词。</target>
        </trans-unit>
        <trans-unit id="3ce9ac6782ffe3c2b00e6a4b78b2ec7b810f1491" translate="yes" xml:space="preserve">
          <source>The writes of individual records are buffered. After all data has been written, the client should call the Flush method to guarantee all data has been forwarded to the underlying io.Writer. Any errors that occurred should be checked by calling the Error method.</source>
          <target state="translated">单个记录的写入是有缓冲的。在所有数据被写入后,客户端应该调用Flush方法,以保证所有数据都被转发到底层的io.Writer。发生的任何错误都应该通过调用Error方法进行检查。</target>
        </trans-unit>
        <trans-unit id="c7efdce3a929526f7cd0a0a9c837645401afe311" translate="yes" xml:space="preserve">
          <source>The zero (uninitialized) value for a Float is ready to use and represents the number +0.0 exactly, with precision 0 and rounding mode ToNearestEven.</source>
          <target state="translated">Float的零值(未初始化)可以使用了,准确表示数字+0.0,精度为0,取整模式为ToNearestEven。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
