<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="requirejs">
    <body>
      <group id="requirejs">
        <trans-unit id="814fdfdfe0abc73fb5e44e5bb62fa796ea1bc9e0" translate="yes" xml:space="preserve">
          <source>&amp;copy; jQuery Foundation and other contributors</source>
          <target state="translated">&amp;copy;jQuery Foundation和其他贡献者</target>
        </trans-unit>
        <trans-unit id="116e2c1fd2ece058c5a0364364bae279336cc7e2" translate="yes" xml:space="preserve">
          <source>(If you are familiar with or are using CommonJS modules, then please also see &lt;a href=&quot;commonjs&quot;&gt;CommonJS Notes&lt;/a&gt; for information on how the RequireJS module format maps to CommonJS modules).</source>
          <target state="translated">（如果您熟悉或正在使用CommonJS模块，那么也请参阅&lt;a href=&quot;commonjs&quot;&gt;CommonJS Notes&lt;/a&gt;以获取有关RequireJS模块格式如何映射到CommonJS模块的信息）。</target>
        </trans-unit>
        <trans-unit id="82a7890eefbb42f66ffb0b96e79f6fd89b2c9340" translate="yes" xml:space="preserve">
          <source>1) You can download the tool on &lt;a href=&quot;http://requirejs.org/docs/download.html#rjs&quot;&gt;the download page&lt;/a&gt;.</source>
          <target state="translated">1）您可以&lt;a href=&quot;http://requirejs.org/docs/download.html#rjs&quot;&gt;在下载页面&lt;/a&gt;上下载该工具。</target>
        </trans-unit>
        <trans-unit id="4f1eb492f8580ac62cf180d901b6d8d9ab286301" translate="yes" xml:space="preserve">
          <source>2) If you are using Node with NPM, you can install r.js globally as part of the &quot;requirejs&quot; package in NPM:</source>
          <target state="translated">2)如果你使用Node与NPM,你可以将r.js作为NPM中 &quot;requirejs &quot;包的一部分进行全局安装。</target>
        </trans-unit>
        <trans-unit id="223001ca9c5d92a15b5242e49eab360fc3a6ab3d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://dojotoolkit.org/&quot;&gt;Dojo&lt;/a&gt; 1.7</source>
          <target state="translated">&lt;a href=&quot;http://dojotoolkit.org/&quot;&gt;道场&lt;/a&gt; 1.7</target>
        </trans-unit>
        <trans-unit id="185e9a68b4bd25da9cafad697c5012278e9b03b8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://dojotoolkit.org/&quot;&gt;Dojo&lt;/a&gt; 1.7+</source>
          <target state="translated">&lt;a href=&quot;http://dojotoolkit.org/&quot;&gt;道场&lt;/a&gt; 1.7+</target>
        </trans-unit>
        <trans-unit id="29b5095018a8842d228b2cf94f9f94d1950bd084" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/JSON#JSONP&quot;&gt;JSONP&lt;/a&gt; is a way of calling some services in JavaScript. It works across domains and it is an established approach to calling services that just require an HTTP GET via a script tag.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/JSON#JSONP&quot;&gt;JSONP&lt;/a&gt;是使用JavaScript调用某些服务的一种方式。它跨域工作，并且是一种仅通过脚本标签仅需要HTTP GET即可调用服务的既定方法。</target>
        </trans-unit>
        <trans-unit id="7bed7dfdba5bcd46587bab55a31fdd8625cb4cb7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://enderjs.com/&quot;&gt;Ender&lt;/a&gt;-associated modules like &lt;a href=&quot;https://github.com/ded/bonzo&quot;&gt;bonzo&lt;/a&gt;, &lt;a href=&quot;https://github.com/ded/qwery&quot;&gt;qwery&lt;/a&gt;, &lt;a href=&quot;https://github.com/fat/bean&quot;&gt;bean&lt;/a&gt; and &lt;a href=&quot;https://github.com/ded/domready&quot;&gt;domready&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://enderjs.com/&quot;&gt;与Ender&lt;/a&gt;相关的模块，例如&lt;a href=&quot;https://github.com/ded/bonzo&quot;&gt;bonzo&lt;/a&gt;，&lt;a href=&quot;https://github.com/ded/qwery&quot;&gt;qwery&lt;/a&gt;，&lt;a href=&quot;https://github.com/fat/bean&quot;&gt;bean&lt;/a&gt;和&lt;a href=&quot;https://github.com/ded/domready&quot;&gt;domready&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="df0d4377cf36918105d53b70e20a99e1ebeb6fa6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://jquery.com/&quot;&gt;jQuery&lt;/a&gt; 1.7</source>
          <target state="translated">&lt;a href=&quot;http://jquery.com/&quot;&gt;jQuery&lt;/a&gt; 1.7</target>
        </trans-unit>
        <trans-unit id="d6339a4aaa1eb888ae1c20dc485879c790507768" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.commonjs.org/&quot;&gt;CommonJS&lt;/a&gt; defines &lt;a href=&quot;http://wiki.commonjs.org/wiki/Modules/1.1.1&quot;&gt;a module format&lt;/a&gt;. Unfortunately, it was defined without giving browsers equal footing to other JavaScript environments. Because of that, there are CommonJS spec proposals for &lt;a href=&quot;http://wiki.commonjs.org/wiki/Modules/Transport&quot;&gt;Transport formats&lt;/a&gt; and an &lt;a href=&quot;http://wiki.commonjs.org/wiki/Modules/Async/A&quot;&gt;asynchronous require&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.commonjs.org/&quot;&gt;CommonJS&lt;/a&gt;定义&lt;a href=&quot;http://wiki.commonjs.org/wiki/Modules/1.1.1&quot;&gt;了模块格式&lt;/a&gt;。不幸的是，它在定义时并未赋予浏览器与其他JavaScript环境同等的地位。因此，存在有关&lt;a href=&quot;http://wiki.commonjs.org/wiki/Modules/Transport&quot;&gt;传输格式&lt;/a&gt;和&lt;a href=&quot;http://wiki.commonjs.org/wiki/Modules/Async/A&quot;&gt;异步require的&lt;/a&gt; CommonJS规范建议。</target>
        </trans-unit>
        <trans-unit id="2374aadda0e5d5c377cdbfce99e8a569d63134ab" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/phiggins42/has.js&quot;&gt;has.js&lt;/a&gt; is a great tool to that adds easy feature detection for your project. There is some optimizer support for optimizing code paths for has.js tests.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/phiggins42/has.js&quot;&gt;has.js&lt;/a&gt;是一个很棒的工具，可以为您的项目添加简单的功能检测。有一些优化器支持可优化has.js测试的代码路径。</target>
        </trans-unit>
        <trans-unit id="8a3b8ef35a670bbe9cdf3e050dd3299ce78d4cba" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/requirejs/example-multipage&quot;&gt;requirejs/example-multipage&lt;/a&gt; is an example of a project that has multiple pages, but shares a common configuration and a common optimized build layer.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/requirejs/example-multipage&quot;&gt;requirejs / example-multipage&lt;/a&gt;是一个项目的示例，该项目具有多个页面，但是共享一个通用配置和一个通用优化构建层。</target>
        </trans-unit>
        <trans-unit id="197f40cae363a637d221e795d930e25e35b4402d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;Optionally call define()&lt;/a&gt; if it is available. The nice thing is you can still code your library without relying on AMD, just participate if it is available. This allows consumers of your modules to:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;（可选）调用define（）（&lt;/a&gt;如果可用）。令人高兴的是，您仍然可以在不依赖AMD的情况下对您的库进行编码，只要可用就可以参与。这使模块的使用者可以：</target>
        </trans-unit>
        <trans-unit id="b03d6178a0b3f875875c504ed71a5ca8ab1663e0" translate="yes" xml:space="preserve">
          <source>&lt;b id=&quot;loadBuildInfo&quot;&gt;Build considerations&lt;/b&gt;: The optimizer traces dependencies &lt;b&gt;synchronously&lt;/b&gt; to simplify the optimization logic. This is different from how require.js in the browser works, and it means that only plugins that can satisfy their dependencies synchronously should participate in the optimization steps that allow inlining of loader plugin values. Otherwise, the plugin should just call load() immediately if &lt;code&gt;config.isBuild&lt;/code&gt; is true:</source>
          <target state="translated">&lt;b id=&quot;loadBuildInfo&quot;&gt;构建注意事项&lt;/b&gt;：优化器&lt;b&gt;同步&lt;/b&gt;跟踪依赖关系以简化优化逻辑。这与浏览器中require.js的工作方式不同，这意味着只有可以同步满足其依赖性的插件才应参与允许内联加载程序插件值的优化步骤。否则，如果 &lt;code&gt;config.isBuild&lt;/code&gt; 为true ，则插件应立即调用load（）：</target>
        </trans-unit>
        <trans-unit id="506bd15924c41f4004b36be9eb39edff02ffe729" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;#apiload&quot;&gt;load&lt;/a&gt;&lt;/b&gt;: A function that is called to load a resource. This is the only mandatory API method that needs to be implemented for the plugin to be useful.</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;#apiload&quot;&gt;load&lt;/a&gt;&lt;/b&gt;：调用此函数以加载资源。这是唯一需要实施的强制API方法，插件才能使用。</target>
        </trans-unit>
        <trans-unit id="5c05204e40494673270518722d3577d844352a0f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;#apinormalize&quot;&gt;normalize&lt;/a&gt;&lt;/b&gt;: A function to normalize the resource name. This is useful in providing optimal caching and optimization, but only needed if the resource name is not a module name.</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;#apinormalize&quot;&gt;normalize&lt;/a&gt;&lt;/b&gt;：标准化资源名称的功能。这在提供最佳缓存和优化时很有用，但仅在资源名称不是模块名称时才需要。</target>
        </trans-unit>
        <trans-unit id="67620f32dc794387af4268db0a195d2c0bec7533" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;#apipluginbuilder&quot;&gt;pluginBuilder&lt;/a&gt;&lt;/b&gt;: A module name string for a module that should be used in the optimizer to do optimization work. That module is used instead of the plugin module when the optimizer runs.</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;#apipluginbuilder&quot;&gt;pluginBuilder&lt;/a&gt;&lt;/b&gt;：在优化器中用于完成优化工作的模块的模块名称字符串。优化程序运行时，将使用该模块而不是插件模块。</target>
        </trans-unit>
        <trans-unit id="05c890f5aa6072a9d2a6646bd5b851f257e269fd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;#apiwrite&quot;&gt;write&lt;/a&gt;&lt;/b&gt;: used by the optimizer to indicate when the plugin should write out a representation of the resource in the optimized file.</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;#apiwrite&quot;&gt;write&lt;/a&gt;&lt;/b&gt;：由优化程序用来指示插件何时应在优化文件中写出资源的表示形式。</target>
        </trans-unit>
        <trans-unit id="a2110dc4f9c4fa811fea913d44cc4b46b8d448f4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;However&lt;/b&gt;, it will not remove the module from other modules that are already defined and got a handle on that module as a dependency when they executed. So it is really only useful to use in error situations when no other modules have gotten a handle on a module value, or as part of any future module loading that may use that module. See the &lt;a href=&quot;#errbacks&quot;&gt;errback section&lt;/a&gt; for an example.</source>
          <target state="translated">&lt;b&gt;但是&lt;/b&gt;，它将不会从其他已定义的模块中删除该模块，并且在执行时会将该模块作为依赖项获得该模块的句柄。因此，只有在没有其他模块都无法处理该模块值的错误情况下使用它，或者作为将来可能使用该模块的模块加载的一部分，它才真正有用。有关示例，请参见&lt;a href=&quot;#errbacks&quot;&gt;errback部分&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cd0efe11af170b5b34fae3a5768842f92021a2f3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Important notes for &quot;shim&quot; config:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&amp;ldquo; shim&amp;rdquo;配置的重要说明：&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0e6d7e23c20b9c92a38f7ebaf9c629b50c1c46ea" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Important optimizer notes for &quot;shim&quot; config&lt;/b&gt;:</source>
          <target state="translated">&lt;b&gt;&amp;ldquo; shim&amp;rdquo;配置的重要优化器说明&lt;/b&gt;：</target>
        </trans-unit>
        <trans-unit id="5452f95ab3f5431d3e0d9ea5bc5eb65ed9d54dbb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;NOTE&lt;/b&gt;: If you do set enforceDefine: true, and you use data-main=&quot;&quot; to load your main JS module, then that main JS module &lt;b&gt;must call define()&lt;/b&gt; instead of require() to load the code it needs. The main JS module can still call require/requirejs to set config values, but for loading modules it should use define().</source>
          <target state="translated">&lt;b&gt;注意&lt;/b&gt;：如果您确实设置了forceDefine：true，并且使用data-main =&amp;ldquo;&amp;rdquo;来加载主JS模块，则该主JS模块&lt;b&gt;必须调用define（）&lt;/b&gt;而不是require（）来加载所需的代码。JS主模块仍然可以调用require / requirejs来设置配置值，但是对于加载模块，它应该使用define（）。</target>
        </trans-unit>
        <trans-unit id="5013e4ed689d2a3ffaaa1dc5f688b4fa1c3b1c08" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Note:&lt;/b&gt; If the document takes a while to load (maybe it is a very large document, or has HTML script tags loading large JS files that block DOM completion until they are done), using domReady as a loader plugin may result in a RequireJS &quot;timeout&quot; error. If this is a problem either increase the &lt;a href=&quot;#config-waitSeconds&quot;&gt;waitSeconds&lt;/a&gt; configuration, or just use domReady as a module and call domReady() inside the require() callback.</source>
          <target state="translated">&lt;b&gt;注意：&lt;/b&gt;如果文档加载时间较长（可能是非常大的文档，或者HTML脚本标签加载了大型JS文件，这些文件会阻止DOM完成直到完成），那么使用domReady作为加载程序插件可能会导致RequireJS&amp;ldquo;超时&amp;rdquo;错误。如果这是一个问题，请增加&lt;a href=&quot;#config-waitSeconds&quot;&gt;waitSeconds&lt;/a&gt;配置，或者仅使用domReady作为模块并在require（）回调内调用domReady（）。</target>
        </trans-unit>
        <trans-unit id="df71ff1e089733f190c702e16b09f3771f6c4081" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Note:&lt;/b&gt; It is best to use &lt;code&gt;var require = {}&lt;/code&gt; and do not use &lt;code&gt;window.require = {}&lt;/code&gt;, it will not behave correctly in IE.</source>
          <target state="translated">&lt;b&gt;注意：&lt;/b&gt;最好使用 &lt;code&gt;var require = {}&lt;/code&gt; 并且不要使用 &lt;code&gt;window.require = {}&lt;/code&gt; ，它将在IE中无法正确运行。</target>
        </trans-unit>
        <trans-unit id="4470cd3f81024ca53c77a075e808184e3d5f48ca" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Note&lt;/b&gt;: errbacks only work with callback-style require calls, not define() calls. define() is only for declaring modules.</source>
          <target state="translated">&lt;b&gt;注意&lt;/b&gt;：errbacks仅适用于回调样式的require调用，而不适用define（）调用。define（）仅用于声明模块。</target>
        </trans-unit>
        <trans-unit id="1658d751a5e1864b6645a9132816926270ff006e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Note&lt;/b&gt;: paths fallbacks only work for exact module ID matches. This is different from normal paths config which can apply to any part of a module ID prefix segment. Fallbacks are targeted more for unusual error recovery, not a generic path search path solution, since those are inefficient in the browser.</source>
          <target state="translated">&lt;b&gt;注意&lt;/b&gt;：路径回退仅适用于确切的模块ID匹配。这与可应用于模块ID前缀段的任何部分的普通路径配置不同。后备的目标更多是针对异常错误的恢复，而不是通用的路径搜索路径解决方案，因为它们在浏览器中效率低下。</target>
        </trans-unit>
        <trans-unit id="2213308d4ce3eb444b284f69d04a49e1e39fe908" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Note&lt;/b&gt;: the plugin and its dependencies should be able to run in non-browser environments like Node and Nashorn. If they cannot, you should use an alternate &lt;a href=&quot;#apipluginbuilder&quot;&gt;plugin builder&lt;/a&gt; module that can run in those environments so that they can participate in optimization builds.</source>
          <target state="translated">&lt;b&gt;注意&lt;/b&gt;：该插件及其依赖项应能够在非浏览器环境（如Node和Nashorn）中运行。如果不能，则应使用可以在这些环境中运行的备用&lt;a href=&quot;#apipluginbuilder&quot;&gt;插件构建器&lt;/a&gt;模块，以便他们可以参与优化构建。</target>
        </trans-unit>
        <trans-unit id="d1562ca8e4b27fe43c636be687ba000c82b1a7e5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;config&lt;/b&gt;: Object. A configuration object. This is a way for the optimizer and the web app to pass configuration information to the plugin. The i18n! plugin uses this to get the current locale, if the web app wants to force a specific locale. The optimizer will set an &lt;b&gt;isBuild&lt;/b&gt; property in the config to true if this plugin (or pluginBuilder) is being called as part of an optimizer build.</source>
          <target state="translated">&lt;b&gt;config&lt;/b&gt;：对象。配置对象。这是优化程序和Web应用程序将配置信息传递给插件的一种方式。i18n！如果网络应用要强制使用特定的语言环境，则插件会使用它来获取当前的语言环境。如果此插件（或pluginBuilder）作为优化器构建的一部分被调用，则优化器会将配置中的&lt;b&gt;isBuild&lt;/b&gt;属性设置为true。</target>
        </trans-unit>
        <trans-unit id="0633fd52ca339aa36fe803e1e7c1e235a965582c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;data&lt;/b&gt;: Object. Information about the layer. Only has two properties:</source>
          <target state="translated">&lt;b&gt;数据&lt;/b&gt;：对象。有关图层的信息。只有两个属性：</target>
        </trans-unit>
        <trans-unit id="d4ae9f09e83410324efa2c5c493968846e5a710b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;fileName&lt;/b&gt;: String. The name of the file to write. You can use parentRequire.toUrl() with a relative path to generate a file name that will be inside the build output directory.</source>
          <target state="translated">&lt;b&gt;fileName&lt;/b&gt;：字符串。要写入的文件名。您可以将parentRequire.toUrl（）与相对路径一起使用，以生成将在构建输出目录内的文件名。</target>
        </trans-unit>
        <trans-unit id="7d42af54c2cce4f8e3c824aa7095ba8adac48e63" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;moduleName&lt;/b&gt;: String. The &lt;b&gt;normalized&lt;/b&gt; resource name.</source>
          <target state="translated">&lt;b&gt;moduleName&lt;/b&gt;：字符串。该&lt;b&gt;归一化&lt;/b&gt;的资源名称。</target>
        </trans-unit>
        <trans-unit id="f4fa4b373e19cffd64c341b383157951022e7fb0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;name&lt;/b&gt;: String. The &lt;b&gt;normalized&lt;/b&gt; resource name.</source>
          <target state="translated">&lt;b&gt;名称&lt;/b&gt;：字符串。该&lt;b&gt;归一化&lt;/b&gt;的资源名称。</target>
        </trans-unit>
        <trans-unit id="c9b575c2614edbef93cb7cf9187a273ac90b40ac" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;name&lt;/b&gt;: String. The name of the resource to load. This is the part after the ! separator in the name. So, if a module asks for 'foo!something/for/foo', the foo module's load function will receive 'something/for/foo' as the name.</source>
          <target state="translated">&lt;b&gt;名称&lt;/b&gt;：字符串。要加载的资源的名称。这是之后的部分！名称中的分隔符。因此，如果模块要求输入&amp;ldquo; foo！something / for / foo&amp;rdquo;，则foo模块的load函数将接收&amp;ldquo; something / for / foo&amp;rdquo;作为名称。</target>
        </trans-unit>
        <trans-unit id="a7e430f692ddd0f1696c7bf9d5e7600c2702e144" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;name&lt;/b&gt;: String. The resource name to normalize.</source>
          <target state="translated">&lt;b&gt;名称&lt;/b&gt;：字符串。要规范化的资源名称。</target>
        </trans-unit>
        <trans-unit id="1de1ad4fff586a6f009688331bf3dac19f43a9e3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;name&lt;/b&gt;: the module name of the layer. May be undefined.</source>
          <target state="translated">&lt;b&gt;name&lt;/b&gt;：图层的模块名称。可能是不确定的。</target>
        </trans-unit>
        <trans-unit id="e8637b053ea38a61892113ae66f0bdad8cc69085" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;normalize&lt;/b&gt; is called to normalize the name used to identify a resource. Some resources could use relative paths, and need to be normalized to the full path. normalize is called with the following arguments:</source>
          <target state="translated">&lt;b&gt;正规化&lt;/b&gt;被称为正常化用于识别资源的名称。一些资源可以使用相对路径，并且需要规范化为完整路径。使用以下参数调用normalize：</target>
        </trans-unit>
        <trans-unit id="9c155f866c3dfbd6ddcaf1a21d533bc69c8f253f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;normalize&lt;/b&gt;: Function. A function that can be called to normalize a regular module name.</source>
          <target state="translated">&lt;b&gt;标准化&lt;/b&gt;：功能。可以调用以标准化常规模块名称的函数。</target>
        </trans-unit>
        <trans-unit id="518ae45a2c4e092a30ef6d374445ebbbc375d6cb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;onLayerEnd&lt;/b&gt; is only used by the optimizer, and is only supported in 2.1.0 or later of the optimizer. It is called after the modules for the layer have been written to the layer. It is useful to use if you need some code that should go at the end of the layer, or if the plugin needs to reset some internal state.</source>
          <target state="translated">&lt;b&gt;onLayerEnd&lt;/b&gt;仅由优化器使用，并且仅在2.1.0或更高版本的优化器中受支持。在将用于该层的模块写入该层之后，将调用该方法。如果您需要一些应放在层末尾的代码，或者插件需要重置某些内部状态，则使用此命令很有用。</target>
        </trans-unit>
        <trans-unit id="624c08fd16b69bcc3349bb27e754504d9e657892" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;onload&lt;/b&gt;: Function. A function to call with the value for name. This tells the loader that the plugin is done loading the resource. &lt;b&gt;onload.error()&lt;/b&gt; can be called, passing an error object to it, if the plugin detects an error condition that means the resource will fail to load correctly.</source>
          <target state="translated">&lt;b&gt;onload&lt;/b&gt;：功能。用名称值调用的函数。这告诉加载程序插件已完成加载资源。如果插件检测到错误情况，意味着资源将无法正确加载，则可以调用&lt;b&gt;onload.error（）&lt;/b&gt;并将错误对象传递给它。</target>
        </trans-unit>
        <trans-unit id="c2f84b038f0ab819e5b8274b7f2ce93bdce6a23e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;parentRequire.defined(moduleName)&lt;/b&gt;: Returns true if the module has already been loaded and defined. Used to be called require.isDefined before RequireJS 0.25.0.</source>
          <target state="translated">&lt;b&gt;parentRequire.defined（moduleName）&lt;/b&gt;：如果已经加载并定义了模块，则返回true。在RequireJS 0.25.0之前定义为require.isDefined。</target>
        </trans-unit>
        <trans-unit id="015e07ffad07b4f74fe69ffc5fd5e560ba778a7c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;parentRequire.specified(moduleName)&lt;/b&gt;: Returns true if the module has already been requested or is in the process of loading and should be available at some point.</source>
          <target state="translated">&lt;b&gt;parentRequire.specified（moduleName）&lt;/b&gt;：如果已经请求模块或正在加载模块，并且应该在某个时候可用，则返回true。</target>
        </trans-unit>
        <trans-unit id="ba9bfc72098ec06b30b3641b2ed5add4ee4d4b6e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;parentRequire.toUrl(moduleResource)&lt;/b&gt;:where moduleResource is a module name plus an extension. For instance &quot;view/templates/main.html&quot;. It will return a full path to the resource, obeying any RequireJS configuration.</source>
          <target state="translated">&lt;b&gt;parentRequire.toUrl（moduleResource）&lt;/b&gt;：其中&lt;b&gt;moduleResource&lt;/b&gt;是模块名称加上扩展名。例如&amp;ldquo; view / templates / main.html&amp;rdquo;。它将遵循任何RequireJS配置返回资源的完整路径。</target>
        </trans-unit>
        <trans-unit id="622d5743c01e802124c82780fd2ca472a7445f78" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;parentRequire&lt;/b&gt;: Function. A local &quot;require&quot; function to use to load other modules. This function will resolve relative module names relative to the module name that asked for this plugin resource. If the loader plugin wants to &lt;code&gt;require()&lt;/code&gt; something relative to its own ID, it can ask for a &lt;code&gt;require&lt;/code&gt; in its own &lt;code&gt;define&lt;/code&gt; call. This require function has some utilities on it:</source>
          <target state="translated">&lt;b&gt;parentRequire&lt;/b&gt;：功能。用于加载其他模块的本地&amp;ldquo;要求&amp;rdquo;功能。此函数将解析相对于请求此插件资源的模块名称的相对模块名称。如果加载程序插件想要 &lt;code&gt;require()&lt;/code&gt; 与其自己的ID相关的东西，则可以在自己的 &lt;code&gt;define&lt;/code&gt; 调用中请求 &lt;code&gt;require&lt;/code&gt; 。此require函数具有一些实用程序：</target>
        </trans-unit>
        <trans-unit id="1d2aac6b06f25bcc6a08613d6ff429b73be408fd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;parentRequire&lt;/b&gt;: Function. A local &quot;require&quot; function. The main use of this in writeFile is for calling parentRequire.toUrl() to generate file paths that are inside the build directory.</source>
          <target state="translated">&lt;b&gt;parentRequire&lt;/b&gt;：功能。本地&amp;ldquo;要求&amp;rdquo;功能。在writeFile中，此方法的主要用途是调用parentRequire.toUrl（）以生成构建目录中的文件路径。</target>
        </trans-unit>
        <trans-unit id="e0134a16548c6c6645647a4752ed2ea5efb6a857" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;path&lt;/b&gt;: the file path of the layer. May be undefined, particularly if the output is just to a string that is consumed by another script.</source>
          <target state="translated">&lt;b&gt;path&lt;/b&gt;：图层的文件路径。可能是不确定的，特别是如果输出仅是另一个脚本使用的字符串时。</target>
        </trans-unit>
        <trans-unit id="a02d39c2198b5eb062ebbbd692afeb0af5f4b077" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;pluginBuilder&lt;/b&gt; can be a string that points to another module to use instead of the current plugin when the plugin is used as part of an optimizer build.</source>
          <target state="translated">&lt;b&gt;&lt;/b&gt;当插件用作优化器构建的一部分时，&lt;b&gt;pluginBuilder&lt;/b&gt;可以是指向要使用的另一个模块的字符串，而不是当前插件。</target>
        </trans-unit>
        <trans-unit id="7bccfaebe5d20d93dbb92eac6c4e4c2755184488" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;pluginName&lt;/b&gt;: String. The &lt;b&gt;normalized&lt;/b&gt; name for the plugin. Most plugins will not be authored with a name (they will be anonymous plugins) so it is useful to know the normalized name for the plugin module for use in the optimized file.</source>
          <target state="translated">&lt;b&gt;pluginName&lt;/b&gt;：字符串。插件的&lt;b&gt;标准化&lt;/b&gt;名称。大多数插件都不会使用名称进行创作（它们将是匿名插件），因此了解用于优化文件中的插件模块的标准化名称很有用。</target>
        </trans-unit>
        <trans-unit id="806f2c5413bd1f88dda933d6d9bf4ca71182ed30" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;text&lt;/b&gt;: String. The contents of the file. Must be UTF-8 encoded.</source>
          <target state="translated">&lt;b&gt;text&lt;/b&gt;：字符串。文件的内容。必须为UTF-8编码。</target>
        </trans-unit>
        <trans-unit id="2b37b8befddf87d1488ad007823a5c1cb02a63b0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;text&lt;/b&gt;: String. The string of JavaScript to evaluate.</source>
          <target state="translated">&lt;b&gt;text&lt;/b&gt;：字符串。要评估的JavaScript字符串。</target>
        </trans-unit>
        <trans-unit id="2cb55635b083fecb23646b281888e2d3a8e8e1af" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;write&lt;/b&gt; is only used by the optimizer, and it only needs to be implemented if the plugin can output something that would belong in an optimized layer. It is called with the following arguments:</source>
          <target state="translated">&lt;b&gt;write&lt;/b&gt;仅由优化器使用，并且仅在插件可以输出属于优化层的内容时才需要实现。使用以下参数调用它：</target>
        </trans-unit>
        <trans-unit id="5685d5466354ace13f25dd4ff5fa42d06b2d956d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;write&lt;/b&gt;: Function. A function to be called with a string of output to write to the optimized file. This function also contains a property function, &lt;b&gt;write.asModule(moduleName, text)&lt;/b&gt;. asModule can be used to write out a module that may have an anonymous define call in there that needs name insertion or/and contains implicit require(&quot;&quot;) dependencies that need to be pulled out for the optimized file. asModule is useful for text transform plugins, like a CoffeeScript plugin.</source>
          <target state="translated">&lt;b&gt;写&lt;/b&gt;：功能。带有输出字符串的调用函数，以写入优化文件。此函数还包含属性函数&lt;b&gt;write.asModule（moduleName，text）&lt;/b&gt;。 asModule可用于写出一个模块，该模块中可能需要名称插入或/和包含隐式require（&amp;ldquo;&amp;rdquo;）依赖关系的模块可能需要在其中进行匿名定义调用，而该依赖关系需要针对优化文件进行提取。 asModule对于文本转换插件（例如CoffeeScript插件）很有用。</target>
        </trans-unit>
        <trans-unit id="cddc0bc3ed4ecb0a91508e3c705f0c73d4bc5f66" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;write&lt;/b&gt;: Function. A function to be called with a string of output to write to the optimized layer. &lt;b&gt;Modules should not be written out&lt;/b&gt; in this call. They will not be normalized correctly for coexistence with other define() calls already in the file. It is useful only for writing out non-define() code.</source>
          <target state="translated">&lt;b&gt;写&lt;/b&gt;：功能。带有输出字符串的调用函数，以写入优化层。&lt;b&gt;不应&lt;/b&gt;在此调用中&lt;b&gt;写出模块&lt;/b&gt;。为了与文件中已有的其他define（）调用共存，将无法正确规范化它们。仅在写出非define（）代码时有用。</target>
        </trans-unit>
        <trans-unit id="21d71fbeac0c9a9225a98971c14d9b7642d2ce1e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;write&lt;/b&gt;: Function. A function to be called with two arguments:</source>
          <target state="translated">&lt;b&gt;写&lt;/b&gt;：功能。一个带有两个参数的函数：</target>
        </trans-unit>
        <trans-unit id="e1d47299b04571e05be6b9f2db9c64d7f599202c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;writeFile&lt;/b&gt; is only used by the optimizer, and it only needs to be implemented if the plugin needs to write out an alternate version of a dependency that is handled by the plugin. It is a bit expensive to scan all modules in a project to look for all plugin dependencies, so this writeFile method will only be called if &lt;b&gt;optimizeAllPluginResources: true&lt;/b&gt; is in the build profile for the RequireJS optimizer. writeFile is called with the following arguments:</source>
          <target state="translated">&lt;b&gt;writeFile&lt;/b&gt;仅由优化器使用，并且仅在插件需要写出由插件处理的依赖项的替代版本时才需要实现。扫描项目中的所有模块以查找所有插件依赖项的开销有点贵，因此仅当requireAllPluginResources &lt;b&gt;：true&lt;/b&gt;在RequireJS优化器的构建配置文件中时，才会调用此writeFile方法。使用以下参数调用writeFile：</target>
        </trans-unit>
        <trans-unit id="7a9de7b1060504a09fced2340f4cefe3979e7d78" translate="yes" xml:space="preserve">
          <source>&lt;strong id=&quot;commandargs&quot;&gt;Command line arguments are interchangeable with a build profile properties&lt;/strong&gt;</source>
          <target state="translated">&lt;strong id=&quot;commandargs&quot;&gt;命令行参数可与构建配置文件属性互换&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="63567fbc5013d2bad98217cd761076a9914f3555" translate="yes" xml:space="preserve">
          <source>&lt;strong id=&quot;mainConfigFile&quot;&gt;Config settings in your main JS module that is loaded in the browser at runtime &lt;strong&gt;are not read by default&lt;/strong&gt; by the optimizer&lt;/strong&gt;</source>
          <target state="translated">&lt;strong id=&quot;mainConfigFile&quot;&gt;优化器&lt;strong&gt;默认不会读取&lt;/strong&gt;运行时在浏览器中加载的主JS模块中的配置设置&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fd6a6e70e53ade44e72789a459c1f511a24523b4" translate="yes" xml:space="preserve">
          <source>&lt;strong id=&quot;optionpaths&quot;&gt;Relative path resolution rules:&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong id=&quot;optionpaths&quot;&gt;相对路径解析规则&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="688e93c7f23b0016b30ae1c02fe374c99ad602c3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;#config-baseUrl&quot;&gt;baseUrl&lt;/a&gt;&lt;/strong&gt;: the root path to use for all module lookups. So in the above example, &quot;my/module&quot;'s script tag will have a src=&quot;/another/path/my/module.js&quot;. baseUrl is &lt;strong&gt;not&lt;/strong&gt; used when loading plain .js files (indicated by a dependency string &lt;a href=&quot;#jsfiles&quot;&gt;starting with a slash, has a protocol, or ends in .js&lt;/a&gt;), those strings are used as-is, so a.js and b.js will be loaded from the same directory as the HTML page that contains the above snippet.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;#config-baseUrl&quot;&gt;baseUrl&lt;/a&gt;&lt;/strong&gt;：用于所有模块查找的根路径。因此，在上面的示例中，&amp;ldquo; my / module&amp;rdquo;的脚本标签将具有src =&amp;ldquo; / another / path / my / module.js&amp;rdquo;。是的baseUrl&lt;strong&gt;不&lt;/strong&gt;装入普通.js文件时使用的（由一个依赖字符串指示&lt;a href=&quot;#jsfiles&quot;&gt;开始以斜线，具有协议，或在端部的.js&lt;/a&gt;），这些字符串被原样使用，所以a.js和b.js将从与包含上述代码段的HTML页面相同的目录中加载。</target>
        </trans-unit>
        <trans-unit id="1acd662f148a50d547ed8ad4f98e479065a4f997" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;#config-bundles&quot;&gt;bundles&lt;/a&gt;&lt;/strong&gt;: Introduced in RequireJS 2.1.10: allows configuring multiple module IDs to be found in another script. Example:</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;#config-bundles&quot;&gt;bundles&lt;/a&gt;&lt;/strong&gt;：在RequireJS 2.1.10中引入：允许配置多个模块ID，这些ID在另一个脚本中找到。例：</target>
        </trans-unit>
        <trans-unit id="085af28d539841cfe94239340a377b5e8edb553b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;#config-callback&quot;&gt;callback&lt;/a&gt;&lt;/strong&gt;: A function to execute after &lt;strong&gt;deps&lt;/strong&gt; have been loaded. Useful when require is defined as a config object before require.js is loaded, and you want to specify a function to require after the configuration's &lt;strong&gt;deps&lt;/strong&gt; array has been loaded.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;#config-callback&quot;&gt;callback&lt;/a&gt;&lt;/strong&gt;：加载&lt;strong&gt; deps&lt;/strong&gt;后执行的函数。在将require.js加载之前，将require定义为配置对象，并且您希望在加载配置的&lt;strong&gt; deps&lt;/strong&gt;数组之后指定要使用的函数时，此选项很有用。</target>
        </trans-unit>
        <trans-unit id="326db44e3cbe2964c4c00e3827eaeb99ed4c2e9b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;#config-context&quot;&gt;context&lt;/a&gt;&lt;/strong&gt;: A name to give to a loading context. This allows require.js to load multiple versions of modules in a page, as long as each top-level require call specifies a unique context string. To use it correctly, see the &lt;a href=&quot;#multiversion&quot;&gt;Multiversion Support&lt;/a&gt; section.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;#config-context&quot;&gt;context&lt;/a&gt;&lt;/strong&gt;：给加载上下文的名称。只要每个顶级require调用指定一个唯一的上下文字符串，这都允许require.js在页面中加载模块的多个版本。要正确使用它，请参阅&amp;ldquo;&lt;a href=&quot;#multiversion&quot;&gt; Multiversion支持&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="ca0d7afdccb360dffa934a77db230250e50afaf4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;#config-deps&quot;&gt;deps&lt;/a&gt;&lt;/strong&gt;: An array of dependencies to load. Useful when require is defined as a config object before require.js is loaded, and you want to specify dependencies to load as soon as require() is defined. Using deps is just like doing a &lt;code&gt;require([])&lt;/code&gt; call, but done as soon as the loader has processed the configuration. &lt;strong&gt;It does not block&lt;/strong&gt; any other require() calls from starting their requests for modules, it is just a way to specify some modules to load asynchronously as part of a config block.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;#config-deps&quot;&gt;deps&lt;/a&gt;&lt;/strong&gt;：要加载的依赖项数组。当在require.js加载之前将require定义为配置对象，并且您想要指定要在require（）定义后立即加载的依赖项时，此选项很有用。使用deps就像执行 &lt;code&gt;require([])&lt;/code&gt; 调用一样，但是在加载程序处理完配置后立即执行。&lt;strong&gt;它不会阻止&lt;/strong&gt;其他任何require（）调用启动对模块的请求，它只是指定某些模块作为config块的一部分异步加载的一种方式。</target>
        </trans-unit>
        <trans-unit id="0d247940698d8e6f686c0bb77049d6c8da63c7da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;#config-enforceDefine&quot;&gt;enforceDefine&lt;/a&gt;&lt;/strong&gt;: If set to true, an error will be thrown if a script loads that does not call define() or have a shim exports string value that can be checked. See &lt;a href=&quot;#ieloadfail&quot;&gt;Catching load failures in IE&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;#config-enforceDefine&quot;&gt;标&lt;/a&gt;&lt;/strong&gt;：设置为true时，如果加载的脚本未调用define（）或具有可检查的填充程序导出字符串值，则将引发错误。有关更多信息，请参见&lt;a href=&quot;#ieloadfail&quot;&gt;在IE中捕获负载故障&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c6138f55b500825f984e6dbb333dcd329837caa4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;#config-map&quot;&gt;map&lt;/a&gt;&lt;/strong&gt;: For the given module prefix, instead of loading the module with the given ID, substitute a different module ID.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;#config-map&quot;&gt;map&lt;/a&gt;&lt;/strong&gt;：对于给定的模块前缀，而不是使用给定的ID加载模块，而是使用其他模块ID。</target>
        </trans-unit>
        <trans-unit id="95681aafd1c488d7f8f14732850e7d8b209998c8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;#config-moduleconfig&quot;&gt;config&lt;/a&gt;&lt;/strong&gt;: There is a common need to pass configuration info to a module. That configuration info is usually known as part of the application, and there needs to be a way to pass that down to a module. In RequireJS, that is done with the &lt;b&gt;config&lt;/b&gt; option for requirejs.config(). Modules can then read that info by asking for the special dependency &quot;module&quot; and calling &lt;b&gt;module.config()&lt;/b&gt;. Example:</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;#config-moduleconfig&quot;&gt;config&lt;/a&gt;&lt;/strong&gt;：通常需要将配置信息传递给模块。该配置信息通常被称为应用程序的一部分，并且需要一种将其传递给模块的方法。在RequireJS中，这是通过requirejs.config（）的&lt;b&gt; config&lt;/b&gt;选项完成的。然后，模块可以通过请求特殊的依赖项&amp;ldquo;模块&amp;rdquo;并调用&lt;b&gt; module.config（）&lt;/b&gt;来读取该信息。例：</target>
        </trans-unit>
        <trans-unit id="ac39bdc204ad820f4dd2e31dd8517ff27d56c927" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;#config-nodeIdCompat&quot;&gt;nodeIdCompat&lt;/a&gt;&lt;/strong&gt;: Node treats module ID &lt;code&gt;example.js&lt;/code&gt; and &lt;code&gt;example&lt;/code&gt; the same. By default these are two different IDs in RequireJS. If you end up using modules installed from npm, then you may need to set this config value to &lt;code&gt;true&lt;/code&gt; to avoid resolution issues. This option only applies to treating the &quot;.js&quot; suffix differently, it does not do any other node resolution and evaluation matching such as .json file handling (JSON handling needs a 'json!' loader plugin anyway). Available in 2.1.10 and greater.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;#config-nodeIdCompat&quot;&gt;nodeIdCompat&lt;/a&gt;&lt;/strong&gt;：Node将模块ID &lt;code&gt;example.js&lt;/code&gt; 和 &lt;code&gt;example&lt;/code&gt; 视为相同。默认情况下，这是RequireJS中的两个不同ID。如果最终使用的是从npm安装的模块，则可能需要将此配置值设置为 &lt;code&gt;true&lt;/code&gt; 以避免解析问题。此选项仅适用于以不同方式处理&amp;ldquo; .js&amp;rdquo;后缀，它不执行任何其他节点解析和评估匹配，例如.json文件处理（JSON处理仍然需要&amp;ldquo; json！&amp;rdquo;加载程序插件）。在2.1.10及更高版本中可用。</target>
        </trans-unit>
        <trans-unit id="99510d1860c925d6763db57dff66af25efccbf3a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;#config-packages&quot;&gt;packages&lt;/a&gt;&lt;/strong&gt;: configures loading modules from CommonJS packages. See the &lt;a href=&quot;#packages&quot;&gt;packages topic&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;#config-packages&quot;&gt;包&lt;/a&gt;&lt;/strong&gt;：配置来自CommonJS包的加载模块。有关更多信息，请参见&lt;a href=&quot;#packages&quot;&gt;软件包主题&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="06ed9a797e36865b0f29ed4687132d5027a3f359" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;#config-paths&quot;&gt;paths&lt;/a&gt;&lt;/strong&gt;: path mappings for module names not found directly under baseUrl. The path settings are assumed to be relative to baseUrl, unless the paths setting starts with a &quot;/&quot; or has a URL protocol in it (&quot;like http:&quot;). Using the above sample config, &quot;some/module&quot;'s script tag will be src=&quot;/another/path/some/v1.0/module.js&quot;.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;#config-paths&quot;&gt;path&lt;/a&gt;&lt;/strong&gt;：在baseUrl的正下方找不到模块名称的路径映射。除非路径设置以&amp;ldquo; /&amp;rdquo;开头或其中包含URL协议（例如&amp;ldquo; http：&amp;rdquo;），否则假定该路径设置相对于baseUrl。使用上面的示例配置，&amp;ldquo; some / module&amp;rdquo;的脚本标签将为src =&amp;ldquo; / another / path / some / v1.0 / module.js&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="cc259753f530f4d5d7cbdb6355d3a8dab3314d7d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;#config-scriptType&quot;&gt;scriptType&lt;/a&gt;&lt;/strong&gt;: Specify the value for the type=&quot;&quot; attribute used for script tags inserted into the document by RequireJS. Default is &quot;text/javascript&quot;. To use Firefox's JavaScript 1.8 features, use &quot;text/javascript;version=1.8&quot;.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;#config-scriptType&quot;&gt;scriptType&lt;/a&gt;&lt;/strong&gt;：指定type =&amp;ldquo;&amp;rdquo;属性的值，该属性用于RequireJS插入文档中的脚本标签。默认值为&amp;ldquo;文本/ javascript&amp;rdquo;。要使用Firefox的JavaScript 1.8功能，请使用&amp;ldquo; text / javascript; version = 1.8&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="371b64def2675a68c091d43c2a65d306af3cb9b8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;#config-shim&quot;&gt;shim&lt;/a&gt;&lt;/strong&gt;: Configure the dependencies, exports, and custom initialization for older, traditional &quot;browser globals&quot; scripts that do not use define() to declare the dependencies and set a module value.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;#config-shim&quot;&gt;shim&lt;/a&gt;&lt;/strong&gt;：为不使用define（）声明依赖关系和设置模块值的较旧的传统&amp;ldquo;浏览器全局变量&amp;rdquo;脚本配置依赖关系，导出和自定义初始化。</target>
        </trans-unit>
        <trans-unit id="5ae95b324cd867a143c0b42db1f26232e9890ce4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;#config-skipDataMain&quot;&gt;skipDataMain&lt;/a&gt;&lt;/strong&gt;: Introduced in RequireJS 2.1.9: If set to &lt;code&gt;true&lt;/code&gt;, skips the &lt;a href=&quot;#data-main&quot;&gt;data-main attribute scanning&lt;/a&gt; done to start module loading. Useful if RequireJS is embedded in a utility library that may interact with other RequireJS library on the page, and the embedded version should not do data-main loading.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;#config-skipDataMain&quot;&gt;skipDataMain&lt;/a&gt;&lt;/strong&gt;：在RequireJS 2.1.9中引入：如果设置为 &lt;code&gt;true&lt;/code&gt; ，则跳过完成的&lt;a href=&quot;#data-main&quot;&gt;数据主属性扫描&lt;/a&gt;以开始模块加载。如果RequireJS嵌入在可能与页面上的其他RequireJS库进行交互的实用程序库中，并且嵌入的版本不应进行数据主加载，则很有用。</target>
        </trans-unit>
        <trans-unit id="ca72d7e0434fdb9fead21c9434f101648dcbd013" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;#config-urlArgs&quot;&gt;urlArgs&lt;/a&gt;&lt;/strong&gt;: Extra query string arguments appended to URLs that RequireJS uses to fetch resources. Most useful to cache bust when the browser or server is not configured correctly. Example cache bust setting for urlArgs:</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;#config-urlArgs&quot;&gt;urlArgs&lt;/a&gt;&lt;/strong&gt;：附加到RequireJS用于获取资源的URL的额外查询字符串参数。当浏览器或服务器配置不正确时，最有用的方法是缓存崩溃。urlArgs的高速缓存半身设置示例：</target>
        </trans-unit>
        <trans-unit id="8edef7869b3aeadbaede9416bcfe954daf6b604d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;#config-waitSeconds&quot;&gt;waitSeconds&lt;/a&gt;&lt;/strong&gt;: The number of seconds to wait before giving up on loading a script. Setting it to 0 disables the timeout. The default is 7 seconds.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;#config-waitSeconds&quot;&gt;waitSeconds&lt;/a&gt;&lt;/strong&gt;：放弃放弃加载脚本之前要等待的秒数。将其设置为0将禁用超时。默认值为7秒。</target>
        </trans-unit>
        <trans-unit id="b9f67b72412ffa73c5ba387b645c9c5325fe18bd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;#config-xhtml&quot;&gt;xhtml&lt;/a&gt;&lt;/strong&gt;: If set to true, document.createElementNS() will be used to create script elements.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;#config-xhtml&quot;&gt;xhtml&lt;/a&gt;&lt;/strong&gt;：如果设置为true，则document.createElementNS（）将用于创建脚本元素。</target>
        </trans-unit>
        <trans-unit id="31f7abf9c4912797d9daf10910ecf7f88272e44b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;plugins&quot;&gt;Loader plugins&lt;/a&gt;&lt;/strong&gt; are incredibly useful. It helps avoid the nested brace indenting common in callback-based programming.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;plugins&quot;&gt;加载程序插件&lt;/a&gt;&lt;/strong&gt;非常有用。它有助于避免在基于回调的编程中常见的嵌套括号缩进。</target>
        </trans-unit>
        <trans-unit id="ed6dad16503b3126795253aa8af8de2838d36717" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Avoid optimization names that are outside the baseUrl&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;避免使用baseUrl之外的优化名称&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ab1ba893f507bf37759ad63a03f08e7621aa0f0c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Best practice&lt;/strong&gt;: Use npm to install Node-only packages/modules into the projects &lt;strong&gt;node_modules&lt;/strong&gt; directory, but do not configure RequireJS to look inside the node_modules directory. Also avoid using relative module IDs to reference modules that are Node-only modules. So, &lt;strong&gt;do not&lt;/strong&gt; do something like &lt;strong&gt;require(&quot;./node_modules/foo/foo&quot;)&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;最佳实践&lt;/strong&gt;：使用npm将仅节点的软件包/模块安装到项目的&lt;strong&gt;node_modules&lt;/strong&gt;目录中，但不要将RequireJS配置为在node_modules目录中查找。还要避免使用相对模块ID来引用仅作为节点的模块。因此，&lt;strong&gt;请勿&lt;/strong&gt;执行&lt;strong&gt;require（&amp;ldquo; ./ node_modules / foo / foo&amp;rdquo;）之类的操作&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="be29faed16f9fe8a4c388fa7277c7a67d769cd29" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Browser:&lt;/strong&gt; as of 2.1.2, the optimizer can run in a web browser that has &lt;a href=&quot;http://dev.opera.com/articles/view/javascript-array-extras-in-detail/&quot;&gt;array extras&lt;/a&gt;. While the optimizer options are the same as shown below, it is called via JavaScript instead of command line options. It is also only good for generating optimized single files, not a directory optimization. See &lt;a href=&quot;https://github.com/requirejs/r.js/blob/master/tests/browser/r.html&quot;&gt;the browser example&lt;/a&gt;. This option is really only useful for providing web-based custom builds of your library.</source>
          <target state="translated">&lt;strong&gt;浏览器：&lt;/strong&gt;从2.1.2开始，优化器可以在具有&lt;a href=&quot;http://dev.opera.com/articles/view/javascript-array-extras-in-detail/&quot;&gt;extras数组&lt;/a&gt;的Web浏览器中运行。尽管优化程序选项与以下所示相同，但​​它是通过JavaScript而不是命令行选项调用的。它也仅适用于生成优化的单个文件，而不是目录优化。请参阅&lt;a href=&quot;https://github.com/requirejs/r.js/blob/master/tests/browser/r.html&quot;&gt;浏览器示例&lt;/a&gt;。此选项实际上仅对提供库的基于Web的自定义版本有用。</target>
        </trans-unit>
        <trans-unit id="53f5e7e58829260a983728d562bc82651be3abf0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Console debugging&lt;/strong&gt;: If you need to work with a module you already loaded via a &lt;code&gt;require([&quot;module/name&quot;], function(){})&lt;/code&gt; call in the JavaScript console, then you can use the require() form that just uses the string name of the module to fetch it:</source>
          <target state="translated">&lt;strong&gt;控制台调试&lt;/strong&gt;：如果您需要使用已通过JavaScript控制台中的 &lt;code&gt;require([&quot;module/name&quot;], function(){})&lt;/code&gt; 调用加载的模块，则可以使用仅使用的require（）形式要获取的模块的字符串名称：</target>
        </trans-unit>
        <trans-unit id="8df639b0d629d79075271634c2a5642b4af733b4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Definition&lt;/strong&gt;: how to encapsulate a piece of code into a useful unit, and how to register its capability/export a value for the module.</source>
          <target state="translated">&lt;strong&gt;定义&lt;/strong&gt;：如何将一段代码封装到一个有用的单元中，以及如何注册其功能/为模块导出值。</target>
        </trans-unit>
        <trans-unit id="e52f813a7533d3a816bf2bc5cc17f40154357c7f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Dependency References&lt;/strong&gt;: how to refer to other units of code.</source>
          <target state="translated">&lt;strong&gt;依赖引用&lt;/strong&gt;：如何引用其他代码单元。</target>
        </trans-unit>
        <trans-unit id="76f910f2e7544ed69b4f3f77df13ab34a0a941a1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Do not specify the output directory to within the source area for your JavaScript&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;不要将输出目录指定为JavaScript的源区域内&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="15219d6fbf857eb4de9f2b5152e2cabd11fe6c3c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Dynamic code loading&lt;/strong&gt; (done in AMD systems via &lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/require&quot;&gt;require([], function (){})&lt;/a&gt;) is a basic requirement. CJS talked about it, had some proposals, but it was not fully embraced. Node does not have any support for this need, instead relying on the synchronous behavior of require(''), which is not portable to the web.</source>
          <target state="translated">&lt;strong&gt;动态代码加载&lt;/strong&gt;（在AMD系统中通过&lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/require&quot;&gt;require（[]，function（）{}）完成&lt;/a&gt;）是一项基本要求。CJS对此进行了讨论，提出了一些建议，但并未完全接受它。Node没有对此需求的任何支持，而是依赖于require（''）的同步行为，而该行为不能在Web上移植。</target>
        </trans-unit>
        <trans-unit id="ccfc6e9f2a4e66e6e924a9d6243c5590996ab0ad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Generate URLs relative to module&lt;/strong&gt;: You may need to generate an URL that is relative to a module. To do so, ask for &quot;require&quot; as a dependency and then use require.toUrl() to generate the URL:</source>
          <target state="translated">&lt;strong&gt;生成相对于模块的URL&lt;/strong&gt;：您可能需要&lt;strong&gt;生成相对于模块&lt;/strong&gt;的URL。为此，要求&amp;ldquo; require&amp;rdquo;作为依赖项，然后使用require.toUrl（）生成URL：</target>
        </trans-unit>
        <trans-unit id="ce7c6f510ef7b7a0a096cba1750438eff21c1680" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;IMPORTANT NOTES&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;重要笔记&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="20972c6512a123816c889472eeaa7736b05ba276" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;IMPORTANT&lt;/strong&gt;: The function arguments should always be listed as &lt;strong&gt;require, exports, module&lt;/strong&gt;, with those exact names and in that exact order, otherwise chaos will ensue. You can leave off exports and module from the list, but if they are needed, they need to be specified in the exact order illustrated here.</source>
          <target state="translated">&lt;strong&gt;重要提示&lt;/strong&gt;：函数参数应始终按&lt;strong&gt;要求，出口，模块的&lt;/strong&gt;顺序列出，并具有确切的名称和正确的顺序，否则会造成混乱。您可以从列表中省略导出和模块，但是如果需要它们，则需要按照此处说明的确切顺序进行指定。</target>
        </trans-unit>
        <trans-unit id="6252e4d16b5ac8019cf35465c36d0d40ca17d8f0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you are a script/library author&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;如果您是脚本/库作者&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="4bc23c4166c7b23082f0e2749ca3e82ba7a59bbe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you write applications:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;如果编写应用程序：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5c2bf07821d29e12c974210b6ab52ee6b3ae192f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you write code loaders/engines/environments for JavaScript:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;如果您为JavaScript编写代码加载器/引擎/环境：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="356892b8284923e6d2f5cc7f4d0a01e0ba3bdede" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In the RequreJS 1.0.x releases&lt;/strong&gt;, there &lt;a href=&quot;https://github.com/requirejs/requirejs/issues/265&quot;&gt;is a bug&lt;/a&gt; with having a space between the require and parens in WebKit browsers when using the simplified CommonJS wrapping (no dependency array):</source>
          <target state="translated">&lt;strong&gt;在RequreJS 1.0.x发行版中&lt;/strong&gt;，存在&lt;a href=&quot;https://github.com/requirejs/requirejs/issues/265&quot;&gt;一个错误&lt;/a&gt;，即在使用简化的CommonJS包装（无依赖项数组）时，WebKit浏览器中的require和parens之间有空格：</target>
        </trans-unit>
        <trans-unit id="e1ca9b023143e72afa4253fd458b6c0e03df2271" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Java:&lt;/strong&gt;&lt;a href=&quot;http://java.com/&quot;&gt;Java 1.6&lt;/a&gt; or later.</source>
          <target state="translated">&lt;strong&gt;Java：&lt;/strong&gt;&lt;a href=&quot;http://java.com/&quot;&gt;Java 1.6&lt;/a&gt;或更高版本。</target>
        </trans-unit>
        <trans-unit id="19035fd62e2796fc9e71500430ed2729bd25794b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Node:&lt;/strong&gt; (preferred) &lt;a href=&quot;http://nodejs.org&quot;&gt;Node&lt;/a&gt; 0.4.0 or later.</source>
          <target state="translated">&lt;strong&gt;节点：（&lt;/strong&gt;首选）&lt;a href=&quot;http://nodejs.org&quot;&gt;节点&lt;/a&gt; 0.4.0或更高版本。</target>
        </trans-unit>
        <trans-unit id="d0731eb1335fb5dce4ac6b95537018a342d2bb8d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note the build limitations of shim config.&lt;/strong&gt; In particular, you cannot load dependencies for shimmed libraries from a CDN. See the &lt;a href=&quot;api#config-shim&quot;&gt;shim config section&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;strong&gt;请注意垫片配置的构建限制。&lt;/strong&gt;特别是，您不能从CDN加载填充程序库的依赖项。有关更多信息，请参见&lt;a href=&quot;api#config-shim&quot;&gt;垫片配置部分&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="333ae88975c3caac92e92e986a1a903f145fdd9f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; when doing builds with map config, the map config needs to be fed to the optimizer, and the build output must still contain a requirejs config call that sets up the map config. The optimizer does not do ID renaming during the build, because some dependency references in a project could depend on runtime variable state. So the optimizer does not invalidate the need for a map config after the build.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;使用map config进行构建时，需要将map config馈送到优化器，并且build输出必须仍然包含requirejs config调用来设置map config。优化器在构建期间不会进行ID重命名，因为项目中的某些依赖项引用可能取决于运行时变量状态。因此，优化器不会在构建后使对映射配置的需求无效。</target>
        </trans-unit>
        <trans-unit id="ab9355b9cfcc01a8de70426e43051f8e16d1ea97" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt;&lt;code&gt;requirejs([], function() {})&lt;/code&gt; will call the function callback asynchronously in RequireJS 2.1+ (for earlier versions it was synchronously called). However, when running in Node, module loading will be loaded using sync IO calls, and loader plugins should resolve calls to their load method synchronously. This allows sync uses of the requirejs module in node to work via requirejs('stringValue') calls:</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt; &lt;code&gt;requirejs([], function() {})&lt;/code&gt; 将在RequireJS 2.1+中异步调用函数回调（对于早期版本，它是同步调用的）。但是，在Node中运行时，将使用同步IO调用来加载模块加载，并且加载器插件应同步解析对其加载方法的调用。这允许节点中对requirejs模块的同步使用通过requirejs（'stringValue'）调用来工作：</target>
        </trans-unit>
        <trans-unit id="f4d9ab191ead6e7068952ee09f25ad5ec231469d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt; that RequireJS will always use a lowercase version of the locale, to avoid case issues, so all of the directories and files on disk for i18n bundles should use lowercase locales.</source>
          <target state="translated">&lt;strong&gt;请注意&lt;/strong&gt;，RequireJS将始终使用小写版本的语言环境，以避免出现大小写问题，因此，i18n软件包的磁盘上的所有目录和文件都应使用小写语言环境。</target>
        </trans-unit>
        <trans-unit id="0ccc1238154db0c7afccdfc9988192b6769a2544" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;One module per file.&lt;/strong&gt;: Only one module should be defined per JavaScript file, given the nature of the module name-to-file-path lookup algorithm. You shoud only use the &lt;a href=&quot;optimization&quot;&gt;optimization tool&lt;/a&gt; to group multiple modules into optimized files.</source>
          <target state="translated">&lt;strong&gt;每个文件一个模块。&lt;/strong&gt;注意：鉴于模块名称到文件路径查找算法的性质，每个JavaScript文件只能定义一个模块。您仅应使用&lt;a href=&quot;optimization&quot;&gt;优化工具&lt;/a&gt;将多个模块分组为优化文件。</target>
        </trans-unit>
        <trans-unit id="d956212a5ca554b5c7226464fd11b8fe3d92afc3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Only JSONP return values that are JSON objects are supported&lt;/strong&gt;. A JSONP response that is an array, a string or a number will not work.</source>
          <target state="translated">&lt;strong&gt;仅支持作为JSON对象的JSONP返回值&lt;/strong&gt;。数组，字符串或数字的JSONP响应将不起作用。</target>
        </trans-unit>
        <trans-unit id="49a7d502c051d7f90a9322365968054abdce7daa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relative module names are relative to other names, not paths&lt;/strong&gt;: The loader stores modules by their name and not by their path internally. So for relative name references, those are resolved relative to the module name making the reference, then that module name, or ID, is converted to a path if needs to be loaded. Example code for a 'compute' package that has a 'main' and 'extras' modules in it:</source>
          <target state="translated">&lt;strong&gt;相对模块名称相对于其他名称，而不是路径&lt;/strong&gt;：加载程序按模块名称而不是内部路径存储模块。因此，对于相对名称引用，将相对于引用的模块名称进行解析，然后，如果需要加载，则将该模块名称或ID转换为路径。其中具有&amp;ldquo; main&amp;rdquo;和&amp;ldquo; extras&amp;rdquo;模块的&amp;ldquo; compute&amp;rdquo;包的示例代码：</target>
        </trans-unit>
        <trans-unit id="11a170cfd674f6e39dc87345715cd0fbe306ab78" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relative module names inside define()&lt;/strong&gt;: For require(&quot;./relative/name&quot;) calls that can happen inside a define() function call, be sure to ask for &quot;require&quot; as a dependency, so that the relative name is resolved correctly:</source>
          <target state="translated">&lt;strong&gt;define（）中的相对模块名称&lt;/strong&gt;：对于在define（）函数调用中可能发生的require（&amp;ldquo; ./ relative / name&amp;rdquo;）调用，请务必要求&amp;ldquo; require&amp;rdquo;作为依赖项，以便解析相对名称正确地：</target>
        </trans-unit>
        <trans-unit id="2ba09f23bfed021b25b590445886e93396c6841a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Returning a function as the module value&lt;/strong&gt;, particularly a constructor function, leads to better API design. Node has module.exports to allow this, but being able to use &quot;return function (){}&quot; is much cleaner. It means not having to get a handle on &quot;module&quot; to do module.exports, and it is a clearer code expression.</source>
          <target state="translated">&lt;strong&gt;返回函数作为模块值&lt;/strong&gt;，尤其是构造函数，可以改善API设计。节点具有module.exports来允许这样做，但是能够使用&amp;ldquo;返回函数（）{}&amp;rdquo;更加简洁。这意味着不必在&amp;ldquo; module&amp;rdquo;上进行处理即可执行module.exports，这是一个更清晰的代码表达式。</target>
        </trans-unit>
        <trans-unit id="d7f39288e5c973499ca8c5f2d0687e7cd917ff92" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Selectively mapping one module&lt;/strong&gt; to load from another location makes it easy to provide mock objects for testing.</source>
          <target state="translated">&lt;strong&gt;选择性地映射一个模块&lt;/strong&gt;以从另一位置加载，可以轻松提供模拟对象进行测试。</target>
        </trans-unit>
        <trans-unit id="e61d06563cca67b22b9eb8c2024e68101de86ae3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;location&lt;/strong&gt;: The location on disk. Locations are relative to the baseUrl configuration value, unless they contain a protocol or start with a front slash (/).</source>
          <target state="translated">&lt;strong&gt;location&lt;/strong&gt;：磁盘上的位置。位置相对于baseUrl配置值，除非它们包含协议或以反斜杠（/）开头。</target>
        </trans-unit>
        <trans-unit id="d76ab03895b36d6cde2b56b5d8e63691bc784ca7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;main&lt;/strong&gt;: The name of the module inside the package that should be used when someone does a require for &quot;packageName&quot;. The default value is &quot;main&quot;, so only specify it if it differs from the default. The value is relative to the package folder.</source>
          <target state="translated">&lt;strong&gt;main&lt;/strong&gt;：某人对&amp;ldquo; packageName&amp;rdquo;的要求时应使用的包内模块的名称。默认值为&amp;ldquo; main&amp;rdquo;，因此仅当它与默认值不同时才指定它。该值相对于包文件夹。</target>
        </trans-unit>
        <trans-unit id="e9a96de3b237de28b3418486a2dfc515daa753cb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;name&lt;/strong&gt;: The name of the package (used for the module name/prefix mapping)</source>
          <target state="translated">&lt;strong&gt;name&lt;/strong&gt;：程序包的名称（用于模块名称/前缀映射）</target>
        </trans-unit>
        <trans-unit id="e6c02a1abf8f5e3c3ca5c9b099c109ed745a20bf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;project.html&lt;/strong&gt; will have a script tag like this:</source>
          <target state="translated">&lt;strong&gt;project.html&lt;/strong&gt;将具有如下脚本标记：</target>
        </trans-unit>
        <trans-unit id="95c789276d7d4257fd905839da9ee26e33460a9d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;requireModules&lt;/strong&gt;: an array of module names/URLs that timed out.</source>
          <target state="translated">&lt;strong&gt;requireModules&lt;/strong&gt;：超时的模块名称/ URL的数组。</target>
        </trans-unit>
        <trans-unit id="b3a393e55d1a8e898134ecc9aee2b2dd26cb033b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;requireType&lt;/strong&gt;: A string value with a general classification, like &quot;timeout&quot;, &quot;nodefine&quot;, &quot;scripterror&quot;.</source>
          <target state="translated">&lt;strong&gt;requireType&lt;/strong&gt;：具有一般分类的字符串值，例如&amp;ldquo; timeout&amp;rdquo;，&amp;ldquo; nodefine&amp;rdquo;，&amp;ldquo; scripterror&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="f81c83895ae3b9f711da071c21815fc034381a2b" translate="yes" xml:space="preserve">
          <source>A common use case for this is to use a CDN-hosted version of a library, but if that fails, switch to loading the file locally:</source>
          <target state="translated">一个常见的用例是使用CDN托管的库的版本,但如果失败了,就切换到本地加载文件。</target>
        </trans-unit>
        <trans-unit id="aecc92efc37038c626a9898853eacec5623d807b" translate="yes" xml:space="preserve">
          <source>A module is different from a traditional script file in that it defines a well-scoped object that avoids polluting the global namespace. It can explicitly list its dependencies and get a handle on those dependencies without needing to refer to global objects, but instead receive the dependencies as arguments to the function that defines the module. Modules in RequireJS are an extension of the &lt;a href=&quot;http://www.adequatelygood.com/2010/3/JavaScript-Module-Pattern-In-Depth&quot;&gt;Module Pattern&lt;/a&gt;, with the benefit of not needing globals to refer to other modules.</source>
          <target state="translated">模块与传统脚本文件的不同之处在于，它定义了一个范围广泛的对象，可避免污染全局名称空间。它可以显式列出其依赖关系，并在不需要引用全局对象的情况下获取这些依赖关系的句柄，而是将依赖关系作为定义模块的函数的参数来接收。 RequireJS中的&lt;a href=&quot;http://www.adequatelygood.com/2010/3/JavaScript-Module-Pattern-In-Depth&quot;&gt;模块&lt;/a&gt;是Module Pattern的扩展，其优点是不需要全局变量来引用其他模块。</target>
        </trans-unit>
        <trans-unit id="4c775660143554c4a49c1424ff91639fea08f923" translate="yes" xml:space="preserve">
          <source>A package can be associated with a module name/prefix.</source>
          <target state="translated">一个包可以与一个模块名称/前缀相关联。</target>
        </trans-unit>
        <trans-unit id="afcd892649c51aa04e79a2542db76913e80781c9" translate="yes" xml:space="preserve">
          <source>A plugin could have very specific logic that depends on a certain environment, like the browser. However, when run inside the optimizer, the environment is very different, and the plugin may have a &lt;b&gt;write&lt;/b&gt; plugin API implementation that it does not want to deliver as part of the normal plugin that is loaded in the browser. In those cases, specifying a pluginBuilder is useful.</source>
          <target state="translated">插件可能具有非常特定的逻辑，该逻辑取决于特定的环境，例如浏览器。但是，当在优化器中运行时，环境非常不同，该插件可能具有&lt;b&gt;写&lt;/b&gt;插件API实现，因此它不希望作为浏览器中加载的普通插件的一部分提供。在这些情况下，指定pluginBuilder很有用。</target>
        </trans-unit>
        <trans-unit id="4755581e13a8cfa7fccfd118cd85844167f076f6" translate="yes" xml:space="preserve">
          <source>A require of &quot;cart&quot; means that it will be loaded from &lt;strong&gt;scripts/cart/main.js&lt;/strong&gt;, since &quot;main&quot; is the default main module setting supported by RequireJS. A require of &quot;store/util&quot; will be loaded from &lt;strong&gt;scripts/store/util.js&lt;/strong&gt;.</source>
          <target state="translated">&amp;ldquo; cart&amp;rdquo;的需求意味着它将从&lt;strong&gt;scripts / cart / main.js加载&lt;/strong&gt;，因为&amp;ldquo; main&amp;rdquo;是RequireJS支持的默认主模块设置。将从&lt;strong&gt;scripts / store / util.js&lt;/strong&gt;加载&amp;ldquo; store / util&amp;rdquo;的需求。</target>
        </trans-unit>
        <trans-unit id="dc1b9b4bb07d1464277843f034100c63208665b6" translate="yes" xml:space="preserve">
          <source>AMD</source>
          <target state="translated">AMD</target>
        </trans-unit>
        <trans-unit id="cd5cf5473243e1d45d7719af8f41414a0e858e3d" translate="yes" xml:space="preserve">
          <source>AMD Used Today</source>
          <target state="translated">今天使用的AMD</target>
        </trans-unit>
        <trans-unit id="7756663774fb63eb9c802ee39b2964fe49d1000d" translate="yes" xml:space="preserve">
          <source>AMD addresses these issues by:</source>
          <target state="translated">AMD通过以下方式解决这些问题:</target>
        </trans-unit>
        <trans-unit id="2fbb6d8aa7490cd0fb9b3c2680eaeeb53140cf79" translate="yes" xml:space="preserve">
          <source>AMD and its related APIs, have helped show the following for any future JS module system:</source>
          <target state="translated">AMD及其相关的API,已经帮助未来任何JS模块系统展示了以下内容。</target>
        </trans-unit>
        <trans-unit id="ad652546dd574e8e72a3108f5d47d4b2288b681a" translate="yes" xml:space="preserve">
          <source>AMD modules require less tooling, there are fewer edge case issues, and better debugging support.</source>
          <target state="translated">AMD模块需要的工具较少,边缘情况问题较少,调试支持较好。</target>
        </trans-unit>
        <trans-unit id="d93d10ff0fbef1b4aa0ddc24e10e907746d3c85a" translate="yes" xml:space="preserve">
          <source>API</source>
          <target state="translated">API</target>
        </trans-unit>
        <trans-unit id="1461f8efdc9427af7da00c09555d68f10f4a74dd" translate="yes" xml:space="preserve">
          <source>Ability to load nested dependencies</source>
          <target state="translated">能够加载嵌套的依赖关系</target>
        </trans-unit>
        <trans-unit id="ec9c1eee60a6c8d412e86494c4538774b81ce815" translate="yes" xml:space="preserve">
          <source>Advanced Usage</source>
          <target state="translated">高级使用方法</target>
        </trans-unit>
        <trans-unit id="c858288df721516bc4030ba55bfa6335a7f04d3c" translate="yes" xml:space="preserve">
          <source>All configuration options</source>
          <target state="translated">所有配置选项</target>
        </trans-unit>
        <trans-unit id="9f40cf04b3528dd358ff4509828b611ee71bca1f" translate="yes" xml:space="preserve">
          <source>All of them map to loading some/path/some/module.js. Ideally we could choose the CommonJS syntax, since it is likely to get more common over time, and we want to reuse code.</source>
          <target state="translated">所有这些都映射到加载some/path/some/module.js。理想情况下,我们可以选择CommonJS语法,因为随着时间的推移,它可能会变得更加普遍,而且我们希望重用代码。</target>
        </trans-unit>
        <trans-unit id="d76cac34f72024eab757bb7877d36d4a84783e5f" translate="yes" xml:space="preserve">
          <source>All the example commands in this page assume Node usage, and running on a Linux/OS X command line. See the &lt;a href=&quot;https://github.com/requirejs/r.js&quot;&gt;r.js README&lt;/a&gt; for how to run it in Java.</source>
          <target state="translated">此页面中的所有示例命令均假定使用Node，并且在Linux / OS X命令行上运行。有关如何在Java中运行它，请参阅&lt;a href=&quot;https://github.com/requirejs/r.js&quot;&gt;r.js自述文件&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e7add3732819f23846380c080edcf146c4d1b13a" translate="yes" xml:space="preserve">
          <source>Allows setting a function as the return value. This is really useful for constructor functions. In CommonJS this is more awkward, always having to set a property on the exports object. Node supports module.exports = function () {}, but that is not part of a CommonJS spec.</source>
          <target state="translated">允许设置函数的返回值。这对构造函数非常有用。在CommonJS中,这比较尴尬,总是要在export对象上设置一个属性。Node支持module.exports=function (){},但这不是CommonJS规范的一部分。</target>
        </trans-unit>
        <trans-unit id="5c0b4dca99dd221c07f2823dbfc63078e8a6ae51" translate="yes" xml:space="preserve">
          <source>Also support &lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/require&quot;&gt;callback-require&lt;/a&gt; and &lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/Loader-Plugins&quot;&gt;loader plugins&lt;/a&gt;. Loader plugins are a great way to reduce the nested callback syndrome that can be common in callback/async-style code.</source>
          <target state="translated">还支持&lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/require&quot;&gt;callback-require&lt;/a&gt;和&lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/Loader-Plugins&quot;&gt;loader插件&lt;/a&gt;。加载程序插件是减少嵌套回调综合症的好方法，该综合症在回调/异步样式代码中很常见。</target>
        </trans-unit>
        <trans-unit id="e2430ebce59431b0f6de636d393909781098343b" translate="yes" xml:space="preserve">
          <source>Also, document.write() does not work after page load. A great way to get perceived performance for your site is loading code on demand, as the user needs it for their next action.</source>
          <target state="translated">此外,document.write()在页面加载后也无法工作。获得网站感知性能的一个好方法是按需加载代码,因为用户需要它进行下一步操作。</target>
        </trans-unit>
        <trans-unit id="a15f74e2813a0e5e3d61a221d689634817920be6" translate="yes" xml:space="preserve">
          <source>Also, you can define the config object as the global variable &lt;code&gt;require&lt;/code&gt;&lt;strong&gt;before&lt;/strong&gt; require.js is loaded, and have the values applied automatically. This example specifies some dependencies to load as soon as require.js defines require():</source>
          <target state="translated">另外，您可以&lt;strong&gt;在&lt;/strong&gt;加载require.js &lt;strong&gt;之前&lt;/strong&gt;将config对象定义为全局变量 &lt;code&gt;require&lt;/code&gt; ，并自动应用值。此示例指定了一些要在require.js定义require（）后立即加载的依赖项：&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5180f71902ee087330414f177079b5a4dd04dc5e" translate="yes" xml:space="preserve">
          <source>Alternative Syntax</source>
          <target state="translated">替代语法</target>
        </trans-unit>
        <trans-unit id="e8b3e3a9af7aa6f439fd569409a7504a25bbf037" translate="yes" xml:space="preserve">
          <source>An error occured when the define() function was called for the module given in the error message. It is an error with the code logic inside the define function. The error could happen inside a require callback.</source>
          <target state="translated">当对错误信息中给出的模块调用define()函数时,发生了一个错误。这是define函数内部的代码逻辑错误。该错误可能发生在require回调中。</target>
        </trans-unit>
        <trans-unit id="98ed11116a42389468f7dc53908918bc380fc101" translate="yes" xml:space="preserve">
          <source>An example plugin that does not do anything interesting, just does a normal require to load a JS module:</source>
          <target state="translated">一个例子插件,它没有做任何有趣的事情,只是做了一个普通的request来加载一个JS模块。</target>
        </trans-unit>
        <trans-unit id="0538812e80ae1405069dd76f452c8a132050945b" translate="yes" xml:space="preserve">
          <source>An example plugin's load function that uses onload.fromText():</source>
          <target state="translated">一个使用onload.fromText()的插件加载函数示例。</target>
        </trans-unit>
        <trans-unit id="b4a866eb59039f47e37643f1a1f3ce8fc67b0a81" translate="yes" xml:space="preserve">
          <source>An example: suppose there is an &lt;b&gt;index!&lt;/b&gt; plugin that will load a module name given an index. This is a contrived example, just to illustrate the concept. A module may reference an index! resource like so:</source>
          <target state="translated">一个例子：假设有一个&lt;b&gt;索引！&lt;/b&gt;插件将加载给定索引的模块名称。这是一个人为的示例，仅用于说明概念。模块可以引用索引！像这样的资源：</target>
        </trans-unit>
        <trans-unit id="207a2adf208957c6bc485c22ac086554f8dec108" translate="yes" xml:space="preserve">
          <source>An object literal with a property of &quot;root&quot; defines this module. That is all you have to do to set the stage for later localization work.</source>
          <target state="translated">一个属性为 &quot;root &quot;的对象文字定义了这个模块。这就是你所要做的一切,为以后的本地化工作打下基础。</target>
        </trans-unit>
        <trans-unit id="099426cf6ef74281640e7d0c78dc622640eee3d9" translate="yes" xml:space="preserve">
          <source>And a &lt;code&gt;require(['compute'])&lt;/code&gt; is done, then lib/compute/main.js will have the module name of 'compute'. When it asks for './extras', that is resolved relative to 'compute', so 'compute/./extras', which normalizes to just 'extras'. Since there is no paths config for that module name, the path generated will be for 'lib/extras.js', which is incorrect.</source>
          <target state="translated">完成 &lt;code&gt;require(['compute'])&lt;/code&gt; ，然后lib / compute / main.js的模块名称为'compute'。当它要求&amp;ldquo; ./extras&amp;rdquo;时，相对于&amp;ldquo; compute&amp;rdquo;可以解决，因此&amp;ldquo; compute /./ extras&amp;rdquo;将其标准化为&amp;ldquo; extras&amp;rdquo;。由于没有用于该模块名称的路径配置，因此生成的路径将是针对&amp;ldquo; lib / extras.js&amp;rdquo;的，这是不正确的。</target>
        </trans-unit>
        <trans-unit id="70ae90af3ca9f9d0ea4a9db7f8c6a12852cd8aed" translate="yes" xml:space="preserve">
          <source>And this is the syntax used by RequireJS. There is also a simplified syntax if you just want to load some plain JavaScript files that do not define modules:</source>
          <target state="translated">而这是RequireJS使用的语法。如果你只是想加载一些不定义模块的普通JavaScript文件,还有一种简化的语法。</target>
        </trans-unit>
        <trans-unit id="4449f0268ad6ee8479ff9c7c4e2df6c1f1b9859d" translate="yes" xml:space="preserve">
          <source>Another option is to construct a module at lib/compute.js that is just &lt;code&gt;define(['./compute/main'], function(m) { return m; });&lt;/code&gt;, then there is no need for paths or packages config.</source>
          <target state="translated">另一个选择是在lib / compute.js上构造一个模块，该模块仅是 &lt;code&gt;define(['./compute/main'], function(m) { return m; });&lt;/code&gt; ，则无需进行路径或程序包配置。</target>
        </trans-unit>
        <trans-unit id="fee85b56ae8d4b331dadd0c023881690c91edd87" translate="yes" xml:space="preserve">
          <source>Arguments for onload.fromText() (RequireJS 2.1.0 and later):</source>
          <target state="translated">onload.fromText()的参数 (RequireJS 2.1.0 及更新版本):</target>
        </trans-unit>
        <trans-unit id="5f9783b9a3d349980bcc48b99c893615afc66388" translate="yes" xml:space="preserve">
          <source>As mentioned in &lt;a href=&quot;#config&quot;&gt;Configuration Options&lt;/a&gt;, multiple versions of a module can be loaded in a page by using different &quot;context&quot; configuration options. require.config() returns a require function that will use the context configuration. Here is an example that loads two different versions of the alpha and beta modules (this example is taken from one of the test files):</source>
          <target state="translated">如&lt;a href=&quot;#config&quot;&gt;配置选项中所述&lt;/a&gt;，可以使用不同的&amp;ldquo;上下文&amp;rdquo;配置选项将模块的多个版本加载到页面中。require.config（）返回将使用上下文配置的require函数。这是加载两个不同版本的alpha和beta模块的示例（此示例摘自一个测试文件）：</target>
        </trans-unit>
        <trans-unit id="ea7f9bd561b8a7ce517ee1f3cd30f4270f35e445" translate="yes" xml:space="preserve">
          <source>As of Dojo 1.8, Dojo has converted their modules to AMD modules. However, Dojo uses some loader plugins, and the loader plugin APIs are still in draft mode for AMD. So while some modules from Dojo can be used with RequireJS, it will be difficult to use all of Dojo. It is best to use Dojo's AMD loader until &lt;a href=&quot;http://bugs.dojotoolkit.org/ticket/15616&quot;&gt;ticket 15616&lt;/a&gt; has been resolved.</source>
          <target state="translated">从Dojo 1.8开始，Dojo已将其模块转换为AMD模块。但是，Dojo使用了一些加载程序插件，并且对于AMD来说，加载程序插件API仍处于草稿模式。因此，尽管Dojo中的某些模块可以与RequireJS一起使用，但是很难使用所有Dojo。最好使用Dojo的AMD装载机，直到解决&lt;a href=&quot;http://bugs.dojotoolkit.org/ticket/15616&quot;&gt;故障单15616&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2f956f6f4e007b657480bf449c13457e00bbb46a" translate="yes" xml:space="preserve">
          <source>As of RequireJS 2.1.16, RequireJS can be used in &lt;a href=&quot;http://www.oracle.com/technetwork/articles/java/jf14-nashorn-2126515.html&quot;&gt;Nashorn&lt;/a&gt;, Java 8+'s JavaScript engine, via the &lt;a href=&quot;http://requirejs.org/docs/download.html#rjs&quot;&gt;r.js adapter&lt;/a&gt;. See &lt;a href=&quot;https://github.com/requirejs/r.js/blob/master/README.html&quot;&gt;the r.js README&lt;/a&gt; for more information.</source>
          <target state="translated">从RequireJS 2.1.16开始，RequireJS可以通过&lt;a href=&quot;http://requirejs.org/docs/download.html#rjs&quot;&gt;r.js适配器&lt;/a&gt;在Java 8+的JavaScript引擎&lt;a href=&quot;http://www.oracle.com/technetwork/articles/java/jf14-nashorn-2126515.html&quot;&gt;Nashorn中&lt;/a&gt;使用。有关更多信息，请参见&lt;a href=&quot;https://github.com/requirejs/r.js/blob/master/README.html&quot;&gt;r.js自述文件&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="60c4529d32d26fca43bdc4a391d37434329a4c47" translate="yes" xml:space="preserve">
          <source>As of RequireJS 2.2.0, the optimizer can generate the bundles config and insert it into the top level requirejs.config() call. See the &lt;a href=&quot;https://github.com/requirejs/r.js/blob/98a9949480d68a781c8d6fc4ce0a07c16a2c8a2a/build/example.build.js#L641&quot;&gt;bundlesConfigOutFile&lt;/a&gt; build config option for more details.</source>
          <target state="translated">从RequireJS 2.2.0开始，优化器可以生成bundle config，并将其插入到顶层requirejs.config（）调用中。有关更多详细信息，请参见&lt;a href=&quot;https://github.com/requirejs/r.js/blob/98a9949480d68a781c8d6fc4ce0a07c16a2c8a2a/build/example.build.js#L641&quot;&gt;bundlesConfigOutFile&lt;/a&gt;构建配置选项。</target>
        </trans-unit>
        <trans-unit id="1ac12d0c37c15f175b2b09c1a99a6ea4b0d1db20" translate="yes" xml:space="preserve">
          <source>As of RequireJS 2.2.0, urlArgs can be a function. If a function, it will receive the module ID and the URL as parameters, and it should return a string that will be added to the end of the URL. Return an empty string if no args. Be sure to take care of adding the '?' or '&amp;amp;' depending on the existing state of the URL. Example:</source>
          <target state="translated">从RequireJS 2.2.0开始，urlArgs可以是一个函数。如果是函数，它将接收模块ID和URL作为参数，并且应返回将添加到URL末尾的字符串。如果没有参数，则返回一个空字符串。请务必注意添加&amp;ldquo;？&amp;rdquo;或&amp;ldquo;＆&amp;rdquo;（取决于URL的现有状态）。例：</target>
        </trans-unit>
        <trans-unit id="e7485868f6989d6066fcc487315af6201517447b" translate="yes" xml:space="preserve">
          <source>As of mid-October 2011, AMD already has good adoption on the web:</source>
          <target state="translated">截至2011年10月中旬,AMD在网络上已经有了很好的应用。</target>
        </trans-unit>
        <trans-unit id="80555381aeb072f79005f4cc1445ebb0289e5ba6" translate="yes" xml:space="preserve">
          <source>As of release 0.12, RequireJS can be run inside a Web Worker. Just use importScripts() inside a web worker to load require.js (or the JS file that contains the require() definition), then call require.</source>
          <target state="translated">从0.12版本开始,RequireJS可以在Web Worker中运行。只要在Web Worker中使用importScripts()加载require.js(或包含require()定义的JS文件),然后调用require。</target>
        </trans-unit>
        <trans-unit id="29459a7e5ab1b732a2e1cc31627dce05f38a47fa" translate="yes" xml:space="preserve">
          <source>As of version 2.1.2, there are some speed shortcuts the optimizer will take by default if &lt;strong&gt;optimize&lt;/strong&gt; is set to &lt;code&gt;&quot;none&quot;&lt;/code&gt;. However, if you are using &lt;code&gt;&quot;none&quot;&lt;/code&gt; for &lt;strong&gt;optimize&lt;/strong&gt; and you are planning to minify the built files after the optimizer runs, then you should turn set &lt;strong&gt;normalizeDirDefines&lt;/strong&gt; to &lt;code&gt;&quot;all&quot;&lt;/code&gt; so that define() calls are normalized correctly to withstand minification. If you are doing minification via the &lt;strong&gt;optimize&lt;/strong&gt; option, then you do not need to worry about setting this option.</source>
          <target state="translated">从2.1.2版开始，如果将&lt;strong&gt;optimize&lt;/strong&gt;设置为 &lt;code&gt;&quot;none&quot;&lt;/code&gt; 则&lt;strong&gt;优化器&lt;/strong&gt;默认会采用一些速度快捷方式。但是，如果您使用 &lt;code&gt;&quot;none&quot;&lt;/code&gt; 进行&lt;strong&gt;优化&lt;/strong&gt;，并且计划在优化器运行后缩小生成的文件，则应将&lt;strong&gt;normalizeDirDefines&lt;/strong&gt;设置为 &lt;code&gt;&quot;all&quot;&lt;/code&gt; 以便正确地对define（）调用进行标准化以承受缩小。如果您通过&lt;strong&gt;优化&lt;/strong&gt;选项进行缩小，则无需担心设置此选项。</target>
        </trans-unit>
        <trans-unit id="9145a4861db481e2d9d34b18ece0513ecc45236b" translate="yes" xml:space="preserve">
          <source>As the comment indicates above, if require() is async, this code will not work. However, loading scripts synchronously in the browser kills performance. So, what to do?</source>
          <target state="translated">正如上面的评论所示,如果require()是async,这段代码将无法工作。然而,在浏览器中同步加载脚本会扼杀性能。那么,该怎么做呢?</target>
        </trans-unit>
        <trans-unit id="71cb8a746a0b21f126d1b3dc8bf16feb9f665d4a" translate="yes" xml:space="preserve">
          <source>Assembly gets harder</source>
          <target state="translated">大会越来越难</target>
        </trans-unit>
        <trans-unit id="03af7d03d9d2928a8a7513419105d33c5a27b3b5" translate="yes" xml:space="preserve">
          <source>Async vs Sync</source>
          <target state="translated">异步与同步</target>
        </trans-unit>
        <trans-unit id="ee31840f6d717751adeb5c5c527bd4f26f71567c" translate="yes" xml:space="preserve">
          <source>Asynchronously loading dependencies should use an array to list the dependencies:</source>
          <target state="translated">异步加载依赖关系应该使用一个数组来列出依赖关系。</target>
        </trans-unit>
        <trans-unit id="5fcebeefad3cdbbf8733aa928160dec7dc90c1a1" translate="yes" xml:space="preserve">
          <source>Basics</source>
          <target state="translated">Basics</target>
        </trans-unit>
        <trans-unit id="cae1fefc0fed8a8035298bfca8fc8834c8f0ea50" translate="yes" xml:space="preserve">
          <source>Be sure that &lt;strong&gt;require('name')&lt;/strong&gt; only occurs inside a define() definition function or a require() callback function, never in the global space by its own.</source>
          <target state="translated">确保&lt;strong&gt;require（'name'）&lt;/strong&gt;仅出现在define（）定义函数或require（）回调函数内部，而不会出现在全局空间内。</target>
        </trans-unit>
        <trans-unit id="061f3af77c543d3a0a6689e17f716e283cf79710" translate="yes" xml:space="preserve">
          <source>Be sure to load all scripts that call define() via the RequireJS API. Do not manually code script tags in HTML to load scripts that have define() calls in them.</source>
          <target state="translated">请确保通过RequireJS API加载所有调用define()的脚本。不要在HTML中手动编写脚本标签来加载有define()调用的脚本。</target>
        </trans-unit>
        <trans-unit id="647ec165a4f826f7e261c899585db87edb8c388d" translate="yes" xml:space="preserve">
          <source>Be sure to read the &lt;a href=&quot;#2&quot;&gt;notes in section 2&lt;/a&gt; about configuring RequireJS so that it can load node-only modules installed via npm.</source>
          <target state="translated">确保阅读&lt;a href=&quot;#2&quot;&gt;第2节中&lt;/a&gt;有关配置RequireJS 的注释，以便它可以加载通过npm安装的仅节点模块。</target>
        </trans-unit>
        <trans-unit id="7083451a53803294578ca8c94dc5e67867059b3f" translate="yes" xml:space="preserve">
          <source>Before RequireJS 2.1.0, onload.fromText accepted a moduleName as the first argument: &lt;code&gt;onload.fromText(moduleName, text)&lt;/code&gt;, and the loader plugin had to manually call &lt;code&gt;require([moduleName], onload)&lt;/code&gt; after the onload.fromText() call.</source>
          <target state="translated">在RequireJS 2.1.0之前，onload.fromText接受moduleName作为第一个参数： &lt;code&gt;onload.fromText(moduleName, text)&lt;/code&gt; ，并且加载程序插件必须在onload.fromText（）调用之后手动调用 &lt;code&gt;require([moduleName], onload)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d802c768c50f9cd38311161cb5506d85c95396c8" translate="yes" xml:space="preserve">
          <source>Building node modules with AMD or RequireJS</source>
          <target state="translated">使用AMD或RequireJS构建节点模块</target>
        </trans-unit>
        <trans-unit id="f4bb57495a42320cd55e2ef64aa962be5895b225" translate="yes" xml:space="preserve">
          <source>But here is the plain truth: the perceived extra typing and a level of indent to use AMD does not matter. Here is where your time goes when coding:</source>
          <target state="translated">但这里有一个朴素的事实:使用AMD所认为的额外打字和缩进程度并不重要。这里是你编码时的时间去向。</target>
        </trans-unit>
        <trans-unit id="d224d8e44c2e917cdc11b554285947074959608b" translate="yes" xml:space="preserve">
          <source>By properly normalizing the resource name, it allows the loader to cache the value effectively, and to properly build an optimized build layer in the optimizer.</source>
          <target state="translated">通过对资源名的适当规范化,可以让加载器有效地缓存该值,并在优化器中适当地构建优化构建层。</target>
        </trans-unit>
        <trans-unit id="5c5266679c4a1ae30bcf0a715ea74c102a8f5466" translate="yes" xml:space="preserve">
          <source>Can I use Node modules already written in the CommonJS module format?</source>
          <target state="translated">我可以使用已经用CommonJS模块格式编写的Node模块吗?</target>
        </trans-unit>
        <trans-unit id="603116a7697334dd761fc1e602d5cc446c9c6c52" translate="yes" xml:space="preserve">
          <source>Can I use server modules written in the CommonJS module format?</source>
          <target state="translated">可以使用以CommonJS模块格式编写的服务器模块吗?</target>
        </trans-unit>
        <trans-unit id="443e9bde1a2ba8d69a35fe518f443310bf6d3b9c" translate="yes" xml:space="preserve">
          <source>Cannot use preserveLicenseComments and generateSourceMaps together</source>
          <target state="translated">不能同时使用preservationLicenseComments和generateSourceMaps。</target>
        </trans-unit>
        <trans-unit id="f4bce411019d5b31d73bb53b5b67559d1a3f5d72" translate="yes" xml:space="preserve">
          <source>Catching load failures in IE</source>
          <target state="translated">捕捉IE中的负载故障</target>
        </trans-unit>
        <trans-unit id="f0d0a5b7548043f512ca9ac123eb4d0049ee5dbc" translate="yes" xml:space="preserve">
          <source>Circular Dependencies</source>
          <target state="translated">循环依赖性</target>
        </trans-unit>
        <trans-unit id="1e8e388c38825d78c8b73b0376db04a076ce7646" translate="yes" xml:space="preserve">
          <source>Clear path to defining the module value. Either use &quot;return value;&quot; or the CommonJS &quot;exports&quot; idiom, which can be useful for circular dependencies.</source>
          <target state="translated">明确定义模块值的路径。可以使用 &quot;return value;&quot;,也可以使用CommonJS的 &quot;exports &quot;成语,这对循环依赖很有用。</target>
        </trans-unit>
        <trans-unit id="680c117376f566afefa1f4b5c4233938c1c4a484" translate="yes" xml:space="preserve">
          <source>Code complexity grows as the site gets bigger</source>
          <target state="translated">随着网站规模的扩大,代码的复杂性也在增加</target>
        </trans-unit>
        <trans-unit id="d6d2ed617694b98c5bd0285a5f46f86c25d55847" translate="yes" xml:space="preserve">
          <source>Combines related scripts together into build layers and minifies them via &lt;a href=&quot;https://github.com/mishoo/UglifyJS&quot;&gt;UglifyJS&lt;/a&gt; (the default) or &lt;a href=&quot;https://developers.google.com/closure/compiler/&quot;&gt;Closure Compiler&lt;/a&gt; (an option when using Java).</source>
          <target state="translated">将相关脚本组合到构建层中，并通过&lt;a href=&quot;https://github.com/mishoo/UglifyJS&quot;&gt;UglifyJS&lt;/a&gt;（默认值）或&lt;a href=&quot;https://developers.google.com/closure/compiler/&quot;&gt;Closure Compiler&lt;/a&gt;（使用Java时的选项）将它们最小化。</target>
        </trans-unit>
        <trans-unit id="07d154b3af13e40e6878df72ed9863bab9fe1fcc" translate="yes" xml:space="preserve">
          <source>Command line arguments take precedence over build profile settings, and you can mix them together:</source>
          <target state="translated">命令行参数优先于构建配置文件设置,您可以将它们混合在一起。</target>
        </trans-unit>
        <trans-unit id="fbaca3e324c7fb124fc3c0ca9ea74430023f8397" translate="yes" xml:space="preserve">
          <source>Common Errors</source>
          <target state="translated">常见错误</target>
        </trans-unit>
        <trans-unit id="3598d7d42bce6e5debb8491d044313a6d4391ec5" translate="yes" xml:space="preserve">
          <source>Common pitfalls</source>
          <target state="translated">常见的陷阱</target>
        </trans-unit>
        <trans-unit id="377dd01e05316c6519d98a0022d6976f8e76be87" translate="yes" xml:space="preserve">
          <source>CommonJS</source>
          <target state="translated">CommonJS</target>
        </trans-unit>
        <trans-unit id="3dbc94c2a704e3fb93f6eb447d7eed414ca23e94" translate="yes" xml:space="preserve">
          <source>CommonJS Compatibility</source>
          <target state="translated">CommonJS兼容性</target>
        </trans-unit>
        <trans-unit id="f20da1f3f4e4045b9fc11b097d1c1c9323eec094" translate="yes" xml:space="preserve">
          <source>CommonJS Notes</source>
          <target state="translated">CommonJS笔记</target>
        </trans-unit>
        <trans-unit id="608fa7dcad5c38dcc088238a4da1277a62a4b39a" translate="yes" xml:space="preserve">
          <source>CommonJS: require(&quot;some/module&quot;)</source>
          <target state="translated">CommonJS:require(&quot;some/module&quot;)</target>
        </trans-unit>
        <trans-unit id="b8577c99aaca7f628cb921ee68fce4bf962909c4" translate="yes" xml:space="preserve">
          <source>Configuration Options</source>
          <target state="translated">配置选项</target>
        </trans-unit>
        <trans-unit id="da75073ccf64da23fa438255a3fdd6e84daac437" translate="yes" xml:space="preserve">
          <source>Contains an URL protocol, like &quot;http:&quot; or &quot;https:&quot;.</source>
          <target state="translated">包含一个URL协议,如 &quot;http:&quot;或 &quot;https:&quot;。</target>
        </trans-unit>
        <trans-unit id="3167f245cbc8d215c6976960c2754d80546e1bdf" translate="yes" xml:space="preserve">
          <source>Conversion Tool</source>
          <target state="translated">转换工具</target>
        </trans-unit>
        <trans-unit id="cd66685d9cd6b2b42c2db11d0eba3d65d5d8a791" translate="yes" xml:space="preserve">
          <source>Create a build profile, call it app.build.js, and put it in the &lt;strong&gt;scripts&lt;/strong&gt; directory. The app.build.js file can live anywhere, but just be sure to adjust the paths accordingly in the example below -- all paths will be relative to where the app.build.js is located. Example app.build.js:</source>
          <target state="translated">创建一个构建配置文件，将其命名为app.build.js，并将其放入&lt;strong&gt;脚本&lt;/strong&gt;目录中。app.build.js文件可以存放在任何地方，但是请确保在下面的示例中相应地调整路径-所有路径都将相对于app.build.js所在的位置。示例app.build.js：</target>
        </trans-unit>
        <trans-unit id="1a476a67e498299f27aae69b16e1128f1d91db0d" translate="yes" xml:space="preserve">
          <source>Define a Module</source>
          <target state="translated">定义一个模块</target>
        </trans-unit>
        <trans-unit id="189f4dfcede6fb3e70a016718942f39142659677" translate="yes" xml:space="preserve">
          <source>Define a Module as a Function</source>
          <target state="translated">将一个模块定义为一个函数</target>
        </trans-unit>
        <trans-unit id="66ccb9e013158fbc3a0890cc84a9136c73c36e93" translate="yes" xml:space="preserve">
          <source>Define a Module with Simplified CommonJS Wrapper</source>
          <target state="translated">使用简化的CommonJS Wrapper定义一个模块。</target>
        </trans-unit>
        <trans-unit id="78e56a3b87783e09008d96bc99a9b226632119a4" translate="yes" xml:space="preserve">
          <source>Define a Module with a Name</source>
          <target state="translated">用一个名称定义一个模块</target>
        </trans-unit>
        <trans-unit id="c64294aaf8b834dea9d34fbaf4321fc3a5b4f013" translate="yes" xml:space="preserve">
          <source>Define a Module with a name</source>
          <target state="translated">定义一个名称为 &quot;模块 &quot;的模块</target>
        </trans-unit>
        <trans-unit id="8c8625f86972268a058a221c6d37f22a9e520f5b" translate="yes" xml:space="preserve">
          <source>Define an I18N Bundle</source>
          <target state="translated">定义一个I18N包</target>
        </trans-unit>
        <trans-unit id="fa75a5475ca40562532f5ffdf64a6ce1181c51de" translate="yes" xml:space="preserve">
          <source>Defined via an immediately executed factory function.</source>
          <target state="translated">通过一个立即执行的工厂函数来定义。</target>
        </trans-unit>
        <trans-unit id="42997a499151458874dda0ecc25c9a1fcfa504a6" translate="yes" xml:space="preserve">
          <source>Defines a way to include multiple modules in one file. In CommonJS terms, the term for this is a &quot;transport format&quot;, and that group has not agreed on a transport format.</source>
          <target state="translated">定义了一种在一个文件中包含多个模块的方式。在CommonJS的术语中,这个术语是 &quot;传输格式&quot;,该组还没有就传输格式达成一致。</target>
        </trans-unit>
        <trans-unit id="fdf3ec7d85deb7255fa2bef9b00a822a98bb25f3" translate="yes" xml:space="preserve">
          <source>Definition Functions</source>
          <target state="translated">定义功能</target>
        </trans-unit>
        <trans-unit id="faf01da1eac83429ecc9c72c9146d7e09eb9a2f9" translate="yes" xml:space="preserve">
          <source>Definition Functions with Dependencies</source>
          <target state="translated">具有依赖性的定义函数</target>
        </trans-unit>
        <trans-unit id="d8d24b4df469c65b7393a388ec6cf5108cf5cc1b" translate="yes" xml:space="preserve">
          <source>Deployment techniques</source>
          <target state="translated">部署技术</target>
        </trans-unit>
        <trans-unit id="e73a7a403dde32f64dd64c0324b5e45fd6828b65" translate="yes" xml:space="preserve">
          <source>Deployment wants optimized code in just one or a few HTTP calls</source>
          <target state="translated">部署想要优化代码,只需一个或几个HTTP调用即可。</target>
        </trans-unit>
        <trans-unit id="f146bd1e1b38bcbf234c5237e3addabe504d35c6" translate="yes" xml:space="preserve">
          <source>Developer wants discrete JS files/modules</source>
          <target state="translated">开发者希望有独立的JS文件/模块</target>
        </trans-unit>
        <trans-unit id="a481992d7ccb15bb38685fcea241700faca3a3bf" translate="yes" xml:space="preserve">
          <source>Developers have been taught that eval() is bad.</source>
          <target state="translated">开发人员一直被教导说eval()是不好的。</target>
        </trans-unit>
        <trans-unit id="219a0f230ec1049125aed42d415e5e8b978de144" translate="yes" xml:space="preserve">
          <source>Did not call define() to declare a module.</source>
          <target state="translated">没有调用define()来声明一个模块。</target>
        </trans-unit>
        <trans-unit id="328d3aebd3a0aa42c86f5ab59c01d68aa18233bf" translate="yes" xml:space="preserve">
          <source>Do not mix CDN loading with shim config in a build. Example scenario: you load jQuery from the CDN but use the shim config to load something like the stock version of Backbone that depends on jQuery. When you do the build, be sure to inline jQuery in the built file and do not load it from the CDN. Otherwise, Backbone will be inlined in the built file and it will execute before the CDN-loaded jQuery will load. This is because the shim config just delays loading of the files until dependencies are loaded, but does not do any auto-wrapping of define. After a build, the dependencies are already inlined, the shim config cannot delay execution of the non-define()'d code until later. define()'d modules do work with CDN loaded code after a build because they properly wrap their source in define factory function that will not execute until dependencies are loaded. So the lesson: shim config is a stop-gap measure for non-modular code, legacy code. define()'d modules are better.</source>
          <target state="translated">不要把CDN加载和shim配置混在一起。例子:你从CDN加载jQuery,但使用shim配置来加载像Backbone的股票版本这样依赖jQuery的东西。当你进行构建时,请确保在构建文件中内联jQuery,而不要从CDN加载它。否则,Backbone会在构建文件中内嵌jQuery,并且会在CDN加载的jQuery加载之前执行。这是因为shim配置只是延迟加载文件,直到加载依赖关系,但没有对define进行任何自动包装。define()'d模块确实可以在构建后与CDN加载的代码一起工作,因为它们正确地将其源码包装在define工厂函数中,在加载依赖关系之前不会执行。所以教训是:shim config是对非模块代码、遗留代码的权宜之计,define()'d模块更好。</target>
        </trans-unit>
        <trans-unit id="96b6222e1ddbeef44870965e7ae83e15408dd547" translate="yes" xml:space="preserve">
          <source>Do not use named modules for the plugin or the pluginBuilder. The pluginBuilder text contents are used instead of the contents of the plugin file, but that will only work if the files do not call define() with a name.</source>
          <target state="translated">不要为插件或pluginBuilder使用命名模块。插件Builder的文本内容被用来代替插件文件的内容,但这只有在文件没有调用带有名称的define()的情况下才有效。</target>
        </trans-unit>
        <trans-unit id="939aac5818debe88f05652cab470ae8b364ea867" translate="yes" xml:space="preserve">
          <source>Doesn't Node already have a module loader?</source>
          <target state="translated">Node不是已经有了一个模块加载器吗?</target>
        </trans-unit>
        <trans-unit id="5461862cf2987931cc425d89eae23192e1a26a75" translate="yes" xml:space="preserve">
          <source>Dojo has used an XHR-based loader with eval() and, while it works, it has been a source of frustration for developers. Dojo has an xdomain loader but it requires the modules to be modified via a build step to use a function wrapper, so that script src=&quot;&quot; tags can be used to load the modules. There are many edge cases and moving parts that create a tax on the developer.</source>
          <target state="translated">Dojo使用了一个基于XHR的加载器与eval(),虽然它可以工作,但它一直是开发人员的挫败感来源。Dojo有一个xdomain加载器,但它要求通过构建步骤修改模块,使用函数包装器,这样脚本src=&quot;&quot;标签就可以用来加载模块。有许多边缘情况和移动部件,给开发者造成了税收。</target>
        </trans-unit>
        <trans-unit id="8c37874e83716706a25248b1cc2caab10d065981" translate="yes" xml:space="preserve">
          <source>Dojo: dojo.require(&quot;some.module&quot;)</source>
          <target state="translated">Dojo:dojo.require(&quot;some.module&quot;)</target>
        </trans-unit>
        <trans-unit id="a479c9c34e878d07b4d67a73a48f432ad7dc53c8" translate="yes" xml:space="preserve">
          <source>Download</source>
          <target state="translated">Download</target>
        </trans-unit>
        <trans-unit id="7f08ea8e56c0fdd9a56781f715142185194a5510" translate="yes" xml:space="preserve">
          <source>Download r.js</source>
          <target state="translated">下载r.js</target>
        </trans-unit>
        <trans-unit id="772e282a4cefb734bdd20a55250e8c92a14780f7" translate="yes" xml:space="preserve">
          <source>Download r.js from the &lt;a href=&quot;http://requirejs.org/docs/download.html#rjs&quot;&gt;the download page&lt;/a&gt; and place it in your project.</source>
          <target state="translated">从&lt;a href=&quot;http://requirejs.org/docs/download.html#rjs&quot;&gt;下载页面&lt;/a&gt;下载r.js 并将其放在您的项目中。</target>
        </trans-unit>
        <trans-unit id="1e2c8e900ec69791d402b60b6aaf717dc5250f0a" translate="yes" xml:space="preserve">
          <source>During development it can be useful to use this, however &lt;strong&gt;be sure&lt;/strong&gt; to remove it before deploying your code.</source>
          <target state="translated">在开发过程中，使用它可能很有用，但是请&lt;strong&gt;确保&lt;/strong&gt;在部署代码之前将其删除。</target>
        </trans-unit>
        <trans-unit id="cfc0ea631ae7a283acdcc5aaa876bb753365d31e" translate="yes" xml:space="preserve">
          <source>Ease of use for developer but then backed by an optimization tool that helps deployment</source>
          <target state="translated">开发者使用方便,但又有优化工具的支持,有助于部署。</target>
        </trans-unit>
        <trans-unit id="63b393cc9a4a0d5bf2d8a0ec0b4da8eff38350f3" translate="yes" xml:space="preserve">
          <source>Either use a server to translate CJS modules to something usable in the browser.</source>
          <target state="translated">要么使用服务器将CJS模块翻译成浏览器中可用的东西。</target>
        </trans-unit>
        <trans-unit id="84e9b67a6f981cdb4872ac5dac561f7cf07cccd4" translate="yes" xml:space="preserve">
          <source>EmbedJS</source>
          <target state="translated">EmbedJS</target>
        </trans-unit>
        <trans-unit id="f1f761ede057b4e84e4906c723905d89eef44ed3" translate="yes" xml:space="preserve">
          <source>Encapsulates the module definition. Gives you the tools to avoid polluting the global namespace.</source>
          <target state="translated">封装模块定义。为您提供避免污染全局命名空间的工具。</target>
        </trans-unit>
        <trans-unit id="cf740dd5d26c6fca83cd6c9187c2c8eab6ba10d1" translate="yes" xml:space="preserve">
          <source>Ends in &quot;.js&quot;.</source>
          <target state="translated">以&quot;.js &quot;结尾。</target>
        </trans-unit>
        <trans-unit id="ed11fe043f6b0340e5d82d2606fa460b6babef5a" translate="yes" xml:space="preserve">
          <source>Errbacks, when used with &lt;a href=&quot;#undef&quot;&gt;requirejs.undef()&lt;/a&gt;, will allow you to detect if a module fails to load, undefine that module, reset the config to a another location, then try again.</source>
          <target state="translated">当与&lt;a href=&quot;#undef&quot;&gt;requirejs.undef（）&lt;/a&gt;一起使用时，Errbacks 将允许您检测模块是否无法加载，取消定义该模块，将配置重置到另一个位置，然后重试。</target>
        </trans-unit>
        <trans-unit id="7eaff2b36bd5390e86b360d0c7b6f28ed86dd972" translate="yes" xml:space="preserve">
          <source>Error evaluating module ...</source>
          <target state="translated">错误评估模块...</target>
        </trans-unit>
        <trans-unit id="70578c9a1e198f18d274db253ee3cafd1becb013" translate="yes" xml:space="preserve">
          <source>Errors in loading a JSONP service are normally surfaced via timeouts for the service, since script tag loading does not give much detail into network problems. To detect errors, you can override requirejs.onError() to get errors. There is more information in the &lt;a href=&quot;#errors&quot;&gt;Handling Errors&lt;/a&gt; section.</source>
          <target state="translated">加载JSONP服务时，错误通常会通过服务超时而出现，因为脚本标记加载不会为网络问题提供太多详细信息。要检测错误，可以重写requirejs.onError（）以获取错误。在&amp;ldquo; &lt;a href=&quot;#errors&quot;&gt;处理错误&amp;rdquo;&lt;/a&gt;部分中有更多信息。</target>
        </trans-unit>
        <trans-unit id="68e28ee55464a1d1e034b9c2cdd48aa0465e3768" translate="yes" xml:space="preserve">
          <source>Even though this sugared form is referred to as the &quot;simplified CommonJS wrapping&quot;, it is not 100% compatible with CommonJS modules. However, the cases that are not supported would likely break in the browser anyway, since they generally assume synchronous loading of dependencies.</source>
          <target state="translated">尽管这种sugared形式被称为 &quot;简化的CommonJS包装&quot;,但它并不是100%兼容CommonJS模块。然而,不支持的情况很可能在浏览器中无论如何都会崩溃,因为它们一般都假设了依赖关系的同步加载。</target>
        </trans-unit>
        <trans-unit id="8bdd3805ee03a8fc687719101da0553ac851e064" translate="yes" xml:space="preserve">
          <source>Example loading jquery from a CDN</source>
          <target state="translated">从CDN加载jquery的例子</target>
        </trans-unit>
        <trans-unit id="3efec32df92355a1ca633f6661b69247faea26e1" translate="yes" xml:space="preserve">
          <source>Example setup</source>
          <target state="translated">设置示例</target>
        </trans-unit>
        <trans-unit id="dc00f9209ed5fc486b962c6c879b21f1625ebcab" translate="yes" xml:space="preserve">
          <source>Example setup:</source>
          <target state="translated">示例设置:</target>
        </trans-unit>
        <trans-unit id="224b367055058734b170711429534306a8ffc7a6" translate="yes" xml:space="preserve">
          <source>Example using jQuery from a CDN</source>
          <target state="translated">使用CDN的jQuery的例子</target>
        </trans-unit>
        <trans-unit id="f4a368325467204d6eea61a556b25125bc35ae17" translate="yes" xml:space="preserve">
          <source>Example using jQuery with shim config</source>
          <target state="translated">使用jQuery和shim配置的例子</target>
        </trans-unit>
        <trans-unit id="6d4eadd1631e4c221838a04cf62b524bceedd734" translate="yes" xml:space="preserve">
          <source>Example using shim config</source>
          <target state="translated">使用shim配置的例子</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="23b239cd6f051075d94afab2b814784cfd6d8712" translate="yes" xml:space="preserve">
          <source>Examples of existing loader plugins are the &lt;a href=&quot;api#text&quot;&gt;text!&lt;/a&gt; and &lt;a href=&quot;api#i18n&quot;&gt;i18n!&lt;/a&gt; plugins. The text! plugin handles loading text, and the i18n plugin handles loading a JavaScript object that is made up from objects from a few different modules. The object contains localized strings.</source>
          <target state="translated">&lt;a href=&quot;api#text&quot;&gt;文本&lt;/a&gt;是现有加载程序插件的示例！和&lt;a href=&quot;api#i18n&quot;&gt;i18n！&lt;/a&gt;插件。文本！插件处理加载文本，而i18n插件处理加载JavaScript对象，该JavaScript对象由来自几个不同模块的对象组成。该对象包含本地化的字符串。</target>
        </trans-unit>
        <trans-unit id="c8d7677e19495f21da984fe4e2829b7ca91b27c7" translate="yes" xml:space="preserve">
          <source>Feedback</source>
          <target state="translated">Feedback</target>
        </trans-unit>
        <trans-unit id="998f21f8963945821d88b707dca0b2a0f29fdd6f" translate="yes" xml:space="preserve">
          <source>Finally, scripts loaded via document.write() will block page rendering. When looking at reaching the very best performance for your site, this is undesirable.</source>
          <target state="translated">最后,通过document.write()加载的脚本将阻止页面渲染。当你希望达到网站的最佳性能时,这是不可取的。</target>
        </trans-unit>
        <trans-unit id="175c805bfb026f6dd1ae25e3a67e08f4c3661d04" translate="yes" xml:space="preserve">
          <source>First thing to sort out is a script loading API. Here are some candidates:</source>
          <target state="translated">首先要理清的是一个脚本加载API。下面是一些候选方案。</target>
        </trans-unit>
        <trans-unit id="a90b34ff72906618ca01c653f046b57a18681b11" translate="yes" xml:space="preserve">
          <source>For &quot;modules&quot; that are just jQuery or Backbone plugins that do not need to export any module value, the shim config can just be an array of dependencies:</source>
          <target state="translated">对于只是jQuery或Backbone插件的 &quot;模块&quot;,不需要导出任何模块值,shim配置可以只是一个依赖关系的数组。</target>
        </trans-unit>
        <trans-unit id="75ad7374cf0e0eba66583a00969ccff593147427" translate="yes" xml:space="preserve">
          <source>For &lt;strong&gt;baseUrl&lt;/strong&gt;, it is relative to &lt;strong&gt;appDir&lt;/strong&gt;. If no appDir, then baseUrl is relative to the build.js file, or if just using command line arguments, the current working directory.</source>
          <target state="translated">对于&lt;strong&gt;的baseUrl&lt;/strong&gt;，它是相对于&lt;strong&gt;APPDIR&lt;/strong&gt;。如果没有appDir，则baseUrl相对于build.js文件，或者如果仅使用命令行参数，则相对于当前工作目录。</target>
        </trans-unit>
        <trans-unit id="90082fa061b7ff8b7cd0a448136b2609a1f99a73" translate="yes" xml:space="preserve">
          <source>For &lt;strong&gt;paths&lt;/strong&gt; and &lt;strong&gt;packages&lt;/strong&gt;, they are relative to &lt;strong&gt;baseUrl&lt;/strong&gt;, just as they are for require.js.</source>
          <target state="translated">对于&lt;strong&gt;路径&lt;/strong&gt;和&lt;strong&gt;包&lt;/strong&gt;，它们是相对&lt;strong&gt;的baseUrl&lt;/strong&gt;，只是因为他们是require.js。</target>
        </trans-unit>
        <trans-unit id="b4888adc510c14f09052a4ead7056d06ab63e997" translate="yes" xml:space="preserve">
          <source>For a list of all options, see &lt;a href=&quot;#options&quot;&gt;all configuration options&lt;/a&gt;.</source>
          <target state="translated">有关所有选项的列表，请参阅&lt;a href=&quot;#options&quot;&gt;所有配置选项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="41fba1fa8ce86f1c3d45cbe5777638d9c6ca8bd4" translate="yes" xml:space="preserve">
          <source>For command line use, Node is the preferred execution environment. The optimizer runs &lt;strong&gt;much faster&lt;/strong&gt; with Node.</source>
          <target state="translated">对于命令行使用，Node是首选的执行环境。优化器通过Node 运行&lt;strong&gt;得更快&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="46d18226ef9def86d3f91dfb4e33301be9de7112" translate="yes" xml:space="preserve">
          <source>For example, this arrangement will fail randomly when the require.config path for the 'foo' module has not been set prior to it being require()'d later:</source>
          <target state="translated">例如,当'foo'模块的require.config路径在之后被require()'d之前没有被设置时,这种安排会随机失败。</target>
        </trans-unit>
        <trans-unit id="5a202a8b0743195728976863adc4266d26ad81f6" translate="yes" xml:space="preserve">
          <source>For instance, if your baseUrl is 'js' and your build output goes into 'js/build', there will likely be problems with extra, nested files generated on each optimization run. This guidance is only for optimizations that are not single file optimizations.</source>
          <target state="translated">例如,如果你的baseUrl是'js',而你的构建输出进入'js/build',很可能会出现每次优化运行时产生额外的、嵌套的文件的问题。本指导意见仅适用于非单文件优化的优化。</target>
        </trans-unit>
        <trans-unit id="15a25512db354fba2b1c0f67a759cb1835854dc0" translate="yes" xml:space="preserve">
          <source>For instance, if your baseUrl is 'js', and your optimization targets:</source>
          <target state="translated">例如,如果你的baseUrl是'js',而你的优化目标。</target>
        </trans-unit>
        <trans-unit id="ad7ee220a39b0c9430dff0ce64564e3baf2c7f3a" translate="yes" xml:space="preserve">
          <source>For local, multi-file builds, the above CDN advice also applies. For any shimmed script, its dependencies &lt;strong&gt;must&lt;/strong&gt; be loaded before the shimmed script executes. This means either building its dependencies directly in the buid layer that includes the shimmed script, or loading its dependencies with a &lt;code&gt;require([], function (){})&lt;/code&gt; call, then doing a nested &lt;code&gt;require([])&lt;/code&gt; call for the build layer that has the shimmed script.</source>
          <target state="translated">对于本地的多文件构建，上述CDN建议也适用。对于任何填充的脚本，&lt;strong&gt;必须&lt;/strong&gt;在执行填充的脚本之前加载其依赖项。这意味着要么直接在包含填充脚本的buid层中构建其依赖项，要么使用 &lt;code&gt;require([], function (){})&lt;/code&gt; 调用加载其依赖项，然后对构建层进行嵌套的 &lt;code&gt;require([])&lt;/code&gt; 调用具有填充脚本的脚本。</target>
        </trans-unit>
        <trans-unit id="bf3894d920edb907a5af18ac327dfff2aab56c1c" translate="yes" xml:space="preserve">
          <source>For passing config to a &lt;a href=&quot;#packages&quot;&gt;package&lt;/a&gt;, target the main module in the package, not the package ID:</source>
          <target state="translated">要将config传递给&lt;a href=&quot;#packages&quot;&gt;包&lt;/a&gt;，请以包中的主模块为目标，而不是包ID为目标：</target>
        </trans-unit>
        <trans-unit id="63a67215832883c72eac42d92074a84ae8301eb1" translate="yes" xml:space="preserve">
          <source>For properties that are module IDs, they should be module IDs, and not file paths. Examples are &lt;strong&gt;name&lt;/strong&gt;, &lt;strong&gt;include&lt;/strong&gt;, &lt;strong&gt;exclude&lt;/strong&gt;, &lt;strong&gt;excludeShallow&lt;/strong&gt;, &lt;strong&gt;deps&lt;/strong&gt;.</source>
          <target state="translated">对于作为模块ID的属性，它们应该是模块ID，而不是文件路径。示例包括&lt;strong&gt;name&lt;/strong&gt;，&lt;strong&gt;include&lt;/strong&gt;，&lt;strong&gt;exclude&lt;/strong&gt;，&lt;strong&gt;excludeShallow&lt;/strong&gt;，&lt;strong&gt;deps&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="da2e5f2fc604cad6e80ee143dc25482cb3f5fb40" translate="yes" xml:space="preserve">
          <source>For this case, &lt;a href=&quot;#packages&quot;&gt;packages config&lt;/a&gt; is a better option, since it allows setting the main module up as 'compute', but internally the loader will store the module with the ID of 'compute/main' so that the relative reference for './extras' works.</source>
          <target state="translated">在这种情况下，&lt;a href=&quot;#packages&quot;&gt;packages config&lt;/a&gt;是一个更好的选择，因为它允许将主模块设置为&amp;ldquo;计算&amp;rdquo;，但是在内部，加载程序将存储ID为&amp;ldquo; compute / main&amp;rdquo;的模块，以便相对地引用&amp;ldquo; ./&amp;rdquo;。演员的作品。</target>
        </trans-unit>
        <trans-unit id="daf2b5474bd3235184beeccc554c1df2bdeea4c4" translate="yes" xml:space="preserve">
          <source>Front-end developers need a solution with:</source>
          <target state="translated">前端开发人员需要一个解决方案与。</target>
        </trans-unit>
        <trans-unit id="21caff7b3dd07a030f4af9d90202d8819054ac0e" translate="yes" xml:space="preserve">
          <source>Function Wrapping</source>
          <target state="translated">功能包装</target>
        </trans-unit>
        <trans-unit id="9e47c58fdafb0242e1dee3bfbbe05dddb269aeb3" translate="yes" xml:space="preserve">
          <source>Function wrapping</source>
          <target state="translated">功能包装</target>
        </trans-unit>
        <trans-unit id="f3a72ad6704d234f02a07df5cc8686bbb29dc1eb" translate="yes" xml:space="preserve">
          <source>Get the source from the &lt;a href=&quot;https://github.com/requirejs/r.js&quot;&gt;r.js repo&lt;/a&gt; and either generate the r.js via &quot;node dist.js&quot;, or grab a snapshot from the &lt;strong&gt;dist&lt;/strong&gt; directory.</source>
          <target state="translated">从&lt;a href=&quot;https://github.com/requirejs/r.js&quot;&gt;r.js存储库中&lt;/a&gt;获取源代码，或者通过&amp;ldquo; node dist.js&amp;rdquo;生成r.js，或者从&lt;strong&gt;dist&lt;/strong&gt;目录中获取快照。</target>
        </trans-unit>
        <trans-unit id="74e2a80eaf85ea086577d0cfa162676f02820f46" translate="yes" xml:space="preserve">
          <source>Give an AMD loader a try. You have some choices:</source>
          <target state="translated">试试AMD的加载器吧。你有一些选择。</target>
        </trans-unit>
        <trans-unit id="ae4f56ae4da16df74b3d2aeca8b4352281e7be45" translate="yes" xml:space="preserve">
          <source>Global Functions</source>
          <target state="translated">全局功能</target>
        </trans-unit>
        <trans-unit id="ce96da2fcb6160b73a5d26f7189c13b3152539b9" translate="yes" xml:space="preserve">
          <source>Global requirejs.onError function</source>
          <target state="translated">全局 requirejs.onError 函数</target>
        </trans-unit>
        <trans-unit id="929a28d261428029e61c0f81c6161fd71ba0b2fe" translate="yes" xml:space="preserve">
          <source>Guides</source>
          <target state="translated">Guides</target>
        </trans-unit>
        <trans-unit id="0d2d67fd740d7ec7df3d8674c33679652ab92712" translate="yes" xml:space="preserve">
          <source>Handling Errors</source>
          <target state="translated">处理错误</target>
        </trans-unit>
        <trans-unit id="8997ec42b86be4e01e18491b00b453fd2e899587" translate="yes" xml:space="preserve">
          <source>Having a working, easy to debug module system that works in today's browsers means getting real world experience in making the best module system for JavaScript in the future.</source>
          <target state="translated">拥有一个能在今天的浏览器中工作的、易于调试的模块系统,意味着在未来为JavaScript制作最好的模块系统时,可以获得实际经验。</target>
        </trans-unit>
        <trans-unit id="06408e9afad9005f462f690d3c05a26d7179cd63" translate="yes" xml:space="preserve">
          <source>Here is an example that calls a JSONP API endpoint. In this example, the JSONP callback parameter is called &quot;callback&quot;, so &quot;callback=define&quot; tells the API to wrap the JSON response in a &quot;define()&quot; wrapper:</source>
          <target state="translated">下面是一个调用JSONP API端点的例子。在这个例子中,JSONP回调参数被称为 &quot;callback&quot;,所以 &quot;callback=define &quot;告诉API用 &quot;define()&quot;包装器包装JSON响应。</target>
        </trans-unit>
        <trans-unit id="9e0c75f4aeccdb862eae83bcee4b7bc79aafb9f8" translate="yes" xml:space="preserve">
          <source>Here is an example. It requires RequireJS 2.1.0+, and assumes backbone.js, underscore.js and jquery.js have been installed in the baseUrl directory. If not, then you may need to set a paths config for them:</source>
          <target state="translated">下面是一个例子,它需要RequireJS 2.1.0+,并假设baseUrl目录下已经安装了backbone.js、 underscore.js和jquery.js。它需要RequireJS 2.1.0+,并假设backbone.js、undererscore.js和jquery.js已经安装在baseUrl目录下。如果没有,那么你可能需要为它们设置一个路径配置。</target>
        </trans-unit>
        <trans-unit id="d4a46fea6d88fd1965dfa2a0c927c5aaa89170d7" translate="yes" xml:space="preserve">
          <source>Here is how the example directory layout looks with two packages, &lt;strong&gt;cart&lt;/strong&gt; and &lt;strong&gt;store&lt;/strong&gt;:</source>
          <target state="translated">这是带有两个包&lt;strong&gt;cart&lt;/strong&gt;和&lt;strong&gt;store&lt;/strong&gt;的示例目录布局的外观：</target>
        </trans-unit>
        <trans-unit id="3a88db88697c21ef8d1cb42f13b3c0fb0771f81f" translate="yes" xml:space="preserve">
          <source>How are pieces of JavaScript code defined today?</source>
          <target state="translated">今天如何定义JavaScript代码片段?</target>
        </trans-unit>
        <trans-unit id="b05b322d83bfb47db730d9d1707bae561b692314" translate="yes" xml:space="preserve">
          <source>How do I use it?</source>
          <target state="translated">如何使用它?</target>
        </trans-unit>
        <trans-unit id="736cbdabaf11b32da124d26c68a2525dfc0b63bc" translate="yes" xml:space="preserve">
          <source>How to use RequireJS with Dojo</source>
          <target state="translated">如何使用Dojo的RequireJS</target>
        </trans-unit>
        <trans-unit id="99584e4621acdc9224936d99361a8939fa2c7f71" translate="yes" xml:space="preserve">
          <source>How to use RequireJS with jQuery</source>
          <target state="translated">如何在jQuery中使用RequireJS</target>
        </trans-unit>
        <trans-unit id="baa492ec7a0eb06bdf669c1f811a659737516a9d" translate="yes" xml:space="preserve">
          <source>However, for the minifier to accurately construct a source map, the minified source cannot be modified in any way, so &lt;strong&gt;preserveLicenseComments&lt;/strong&gt; is incompatible with &lt;strong&gt;generateSourceMaps&lt;/strong&gt;. generateSourceMaps was introduced in version 2.1.2 of the optimizer.</source>
          <target state="translated">但是，为了使缩小器能够准确地构造源映射，无法以任何方式修改缩小的源，因此，&lt;strong&gt;preserveLicenseComments&lt;/strong&gt;与&lt;strong&gt;generateSourceMaps&lt;/strong&gt;不兼容。在优化器的2.1.2版本中引入了generateSourceMaps。</target>
        </trans-unit>
        <trans-unit id="06764a60d7302cd5011c01b08065e6465af17bde" translate="yes" xml:space="preserve">
          <source>However, if you are in a project that you know uses define() to declare all of its modules, or it uses the &lt;a href=&quot;#config-shim&quot;&gt;shim&lt;/a&gt; config to specify string exports for anything that does not use define(), then if you set the &lt;a href=&quot;#config-enforceDefine&quot;&gt;enforceDefine&lt;/a&gt; config value to true, the loader can confirm if a script load by checking for the define() call or the existence of the shim's exports global value.</source>
          <target state="translated">但是，如果您知道一个项目中使用define（）声明其所有模块，或者它使用&lt;a href=&quot;#config-shim&quot;&gt;shim&lt;/a&gt; config为不使用define（）的任何内容指定字符串导出，那么如果您设置了&lt;a href=&quot;#config-enforceDefine&quot;&gt;defineDefine&lt;/a&gt;配置值确实，加载器可以通过检查define（）调用或填充程序的导出全局值的存在来确认脚本是否已加载。</target>
        </trans-unit>
        <trans-unit id="dec98a5a8a1a825635cf9d8999487f368e4da493" translate="yes" xml:space="preserve">
          <source>However, in the &lt;a href=&quot;#4&quot;&gt;Async vs Sync example&lt;/a&gt; we cannot just execute that script directly. Ideally we could know the require() dependencies before we execute the script, and make sure those dependencies are loaded first. But we do not have access to the script before it is executed.</source>
          <target state="translated">但是，在&lt;a href=&quot;#4&quot;&gt;异步与同步示例中，&lt;/a&gt;我们不能仅直接执行该脚本。理想情况下，在执行脚本之前我们可以知道require（）依赖项，并确保首先加载那些依赖项。但是在执行脚本之前，我们无权访问该脚本。</target>
        </trans-unit>
        <trans-unit id="dfbdab0a1069903e763d697a837c846906f023f0" translate="yes" xml:space="preserve">
          <source>However, it is more likely that you do not want to include that resource in the build. If the script does not have any dependencies, or you do not want to include its dependencies or will be including them in another way, then you can use the special &lt;strong&gt;'empty:' scheme&lt;/strong&gt; in the paths config to just skip the file when doing an optimization.</source>
          <target state="translated">但是，您很可能不想在构建中包括该资源。如果脚本没有任何依赖关系，或者您不想包含其依赖关系或将以其他方式包含它们，则可以在路径配置中使用特殊的&lt;strong&gt;&amp;ldquo; empty：&amp;rdquo;方案&lt;/strong&gt;在执行优化。</target>
        </trans-unit>
        <trans-unit id="d180421a35263e9cbc4e5f01cb5316f24e8911c5" translate="yes" xml:space="preserve">
          <source>However, it still has the &lt;a href=&quot;#4&quot;&gt;Async vs Sync example&lt;/a&gt; problem: ideally we could know the require() dependencies before we execute the script, and make sure those dependencies are loaded first.</source>
          <target state="translated">但是，它仍然存在&lt;a href=&quot;#4&quot;&gt;Async vs Sync示例&lt;/a&gt;问题：理想情况下，在执行脚本之前，我们可以知道require（）依赖项，并确保首先加载这些依赖项。</target>
        </trans-unit>
        <trans-unit id="37ed8422dc4b848a82f406f48365216fdc2513aa" translate="yes" xml:space="preserve">
          <source>However, not all browsers in use support DOMContentLoaded. The domReady module implements a cross-browser method to determine when the DOM is ready. &lt;a href=&quot;http://requirejs.org/docs/download.html#domReady&quot;&gt;Download the module&lt;/a&gt; and use it in your project like so:</source>
          <target state="translated">但是，并非所有使用的浏览器都支持DOMContentLoaded。domReady模块实现了跨浏览器方法来确定DOM准备就绪的时间。&lt;a href=&quot;http://requirejs.org/docs/download.html#domReady&quot;&gt;下载模块&lt;/a&gt;，并在您的项目中使用它，如下所示：</target>
        </trans-unit>
        <trans-unit id="0251cde2be08202fcc02450703af91a17d8975c1" translate="yes" xml:space="preserve">
          <source>However, tools that combine multiple modules together for performance need a way to give names to each module in the optimized file. For that, AMD allows a string as the first argument to define():</source>
          <target state="translated">然而,为了提高性能而将多个模块组合在一起的工具需要一种方法来给优化文件中的每个模块命名。为此,AMD允许用一个字符串作为定义()的第一个参数。</target>
        </trans-unit>
        <trans-unit id="487b1f01c66606179dbf2f41be406387d07ea6c5" translate="yes" xml:space="preserve">
          <source>However, we need something that works well in the browser. The CommonJS require() is a synchronous call, it is expected to return the module immediately. This does not work well in the browser.</source>
          <target state="translated">然而,我们需要一些在浏览器中能很好地工作的东西。CommonJS require()是一个同步调用,它被期望立即返回模块。这在浏览器中不能很好地工作。</target>
        </trans-unit>
        <trans-unit id="6d820ffdc00059491579804e4bd96d555e261655" translate="yes" xml:space="preserve">
          <source>I believe it is important to not force the use of a runtime server process to transform code:</source>
          <target state="translated">我认为不要强行使用运行时服务器进程来转换代码,这一点很重要。</target>
        </trans-unit>
        <trans-unit id="ff857cf4b37b9b4eaa5dda5da862a37bf0231191" translate="yes" xml:space="preserve">
          <source>IDs can be mapped to different paths. This allows swapping out implementation. This is great for creating mocks for unit testing. For the above code sample, the code just expects something that implements the jQuery API and behavior. It does not have to be jQuery.</source>
          <target state="translated">ID可以映射到不同的路径。这允许交换实现。这对于创建单元测试的mock是非常好的。对于上面的代码示例,代码只是期望实现jQuery API和行为的东西。它不一定是jQuery。</target>
        </trans-unit>
        <trans-unit id="ccf772d613332cb26f229f7f1c3711365b71cd6c" translate="yes" xml:space="preserve">
          <source>Ideally the scripts you load will be modules that are defined by calling &lt;a href=&quot;#define&quot;&gt;define()&lt;/a&gt;. However, you may need to use some traditional/legacy &quot;browser globals&quot; scripts that do not express their dependencies via define(). For those, you can use the &lt;a href=&quot;#config-shim&quot;&gt;shim config&lt;/a&gt;. To properly express their dependencies.</source>
          <target state="translated">理想情况下，您加载的脚本将是通过调用&lt;a href=&quot;#define&quot;&gt;define（）&lt;/a&gt;定义的模块。但是，您可能需要使用某些传统/旧版的&amp;ldquo;浏览器全局变量&amp;rdquo;脚本，这些脚本无法通过define（）表达它们的依赖性。对于那些，您可以使用&lt;a href=&quot;#config-shim&quot;&gt;shim config&lt;/a&gt;。正确表达其依赖性。</target>
        </trans-unit>
        <trans-unit id="8bc66eb67c7dbf88c0c91113e3a440efe63a9356" translate="yes" xml:space="preserve">
          <source>If &lt;strong&gt;all of your modules&lt;/strong&gt; (including any third party jQuery plugins or library code that depend on jQuery) are AMD compatible and you want to avoid having $ or jQuery in the global namespace when they call &lt;code&gt;requirejs(['jquery'])&lt;/code&gt;, you can use the &lt;a href=&quot;api#config-map&quot;&gt;map config&lt;/a&gt; to map the use of jQuery to a module that calls noConflict and returns that value of jQuery for the 'jquery' module ID.</source>
          <target state="translated">如果&lt;strong&gt;您所有模块&lt;/strong&gt;（包括依赖于jQuery的任何第三方jQuery插件或库代码）都与AMD兼容，并且您希望避免在它们调用 &lt;code&gt;requirejs(['jquery'])&lt;/code&gt; 时在全局命名空间中使用$或jQuery，则可以使用&lt;a href=&quot;api#config-map&quot;&gt;map config&lt;/a&gt;将jQuery的使用映射到一个调用noConflict并返回jQuery值的'jquery'模块ID的模块。</target>
        </trans-unit>
        <trans-unit id="0d09b91ed8f5ecda7ebb9c933cb5789a594eb6c1" translate="yes" xml:space="preserve">
          <source>If a JS module system cannot deliver on the above features, it is at a significant disadvantage when compared to AMD and its related APIs around &lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/require&quot;&gt;callback-require&lt;/a&gt;, &lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/Loader-Plugins&quot;&gt;loader plugins&lt;/a&gt;, and paths-based module IDs.</source>
          <target state="translated">如果JS模块系统无法提供上述功能，则与AMD及其相关的关于&lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/require&quot;&gt;callback-require&lt;/a&gt;，&lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/Loader-Plugins&quot;&gt;loader插件&lt;/a&gt;和基于路径的模块ID的API相比，它具有明显的劣势。</target>
        </trans-unit>
        <trans-unit id="923ff2f6c2d2940aa6cfdc5a2817aaecc5e810e7" translate="yes" xml:space="preserve">
          <source>If a plugin does not implement normalize, then the loader will try to normalize the resource name using the normal module name rules.</source>
          <target state="translated">如果一个插件没有实现规范化,那么加载器将尝试使用正常的模块名称规则对资源名称进行规范化。</target>
        </trans-unit>
        <trans-unit id="e73a84c56940c8d1218f3e2d895a4872504fde03" translate="yes" xml:space="preserve">
          <source>If doing a whole project optimization, but only want to minify the build layers specified in &lt;strong&gt;modules&lt;/strong&gt; options and not the rest of the JS files in the build output directory, you can set &lt;strong&gt;skipDirOptimize&lt;/strong&gt; to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果要进行整个项目的优化，而只想最小化&lt;strong&gt;模块&lt;/strong&gt;选项中指定的构建层，而不是最小化构建输出目录中的其余JS文件，则可以将&lt;strong&gt;skipDirOptimize&lt;/strong&gt;设置为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="70533f68a7c93619cec8126932c9830808b8e124" translate="yes" xml:space="preserve">
          <source>If in IE, check for an HTTP 404 error or a JavaScript sytnax error by using a script debugger.</source>
          <target state="translated">如果在IE中,使用脚本调试器检查HTTP 404错误或JavaScript sytnax错误。</target>
        </trans-unit>
        <trans-unit id="d06fb6574033aac10ae536e27b312a12a1437aa4" translate="yes" xml:space="preserve">
          <source>If it is not possible to upgrade the shimmed code to use AMD define() calls, as of RequireJS 2.1.11, the optimizer has a &lt;a href=&quot;https://github.com/requirejs/r.js/blob/b8a6982d2923ae8389355edaa50d2b7f8065a01a/build/example.build.js#L68&quot;&gt;wrapShim build option&lt;/a&gt; that will try to automatically wrap the shimmed code in a define() for a build. This changes the scope of shimmed dependencies, so it is not guaranteed to always work, but, for example, for shimmed dependencies that depend on an AMD version of Backbone, it can be helpful.</source>
          <target state="translated">从RequireJS 2.1.11开始，如果无法升级填充代码以使用AMD define（）调用，则优化器具有&lt;a href=&quot;https://github.com/requirejs/r.js/blob/b8a6982d2923ae8389355edaa50d2b7f8065a01a/build/example.build.js#L68&quot;&gt;wrapShim构建选项&lt;/a&gt;，该选项将尝试自动将填充代码包装在define（）中以进行构建。这改变了匀场依赖性的范围，因此不能保证始终有效，但是，例如，对于依赖于Backbone的AMD版本的匀场依赖性，它可能会有所帮助。</target>
        </trans-unit>
        <trans-unit id="cbcb9f444492d4850b289deb7e4380b5fd3bb621" translate="yes" xml:space="preserve">
          <source>If no baseUrl is explicitly set in the configuration, the default value will be the location of the HTML page that loads require.js. If a &lt;strong&gt;data-main&lt;/strong&gt; attribute is used, that path will become the baseUrl.</source>
          <target state="translated">如果未在配置中显式设置baseUrl，则默认值将是加载require.js的HTML页面的位置。如果使用&lt;strong&gt;data-main&lt;/strong&gt;属性，则该路径将成为baseUrl。</target>
        </trans-unit>
        <trans-unit id="6404b1494958d7d6e06d6a9ab163934604e724f9" translate="yes" xml:space="preserve">
          <source>If on Windows, you may need to type &lt;code&gt;r.js.cmd&lt;/code&gt; instead of &lt;code&gt;r.js&lt;/code&gt;. Or, you can use &lt;a href=&quot;http://www.microsoft.com/resources/documentation/windows/xp/all/proddocs/en-us/doskey.mspx?mfr=true&quot;&gt;DOSKEY&lt;/a&gt;:</source>
          <target state="translated">如果在Windows上，您可能需要键入 &lt;code&gt;r.js.cmd&lt;/code&gt; 而不是 &lt;code&gt;r.js&lt;/code&gt; 。或者，您可以使用&lt;a href=&quot;http://www.microsoft.com/resources/documentation/windows/xp/all/proddocs/en-us/doskey.mspx?mfr=true&quot;&gt;DOSKEY&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="4f6e5ec8125377aee196b4157ae031deb5846f14" translate="yes" xml:space="preserve">
          <source>If part of a require() callback, all the dependencies need to be listed in the array:</source>
          <target state="translated">如果是require()回调的一部分,则需要在数组中列出所有的依赖关系。</target>
        </trans-unit>
        <trans-unit id="5e11c69c8bd44c98ec1a92bd548444b902083a8f" translate="yes" xml:space="preserve">
          <source>If part of a shim config, make sure the shim config's exports check is correct.</source>
          <target state="translated">如果是shim配置的一部分,请确保shim配置的导出检查是正确的。</target>
        </trans-unit>
        <trans-unit id="0771fa68bc68f46c7cad59553f87fbed3015f4e1" translate="yes" xml:space="preserve">
          <source>If the &quot;store&quot; package did not follow the &quot;main.js&quot; convention, and looked more like this:</source>
          <target state="translated">如果 &quot;商店 &quot;包没有遵循 &quot;main.js &quot;的惯例,看起来更像这样。</target>
        </trans-unit>
        <trans-unit id="726b8059a1d692c8212c0606dec6c706d075cc32" translate="yes" xml:space="preserve">
          <source>If the error message includes &lt;strong&gt;Use require([])&lt;/strong&gt;, then it was a top-level require call (not a require call inside a define() call) that should be using the async, callback version of require to load the code:</source>
          <target state="translated">如果错误消息包括&lt;strong&gt;Use require（[]）&lt;/strong&gt;，则它是应使用异步，回调版require加载代码的顶级require调用（而不是define（）调用内的require调用）：</target>
        </trans-unit>
        <trans-unit id="3da1558eec7d161ec9aeacf63f1947075ff1b3c4" translate="yes" xml:space="preserve">
          <source>If the module calls define(), make sure the define call was reached by debugging in a script debugger.</source>
          <target state="translated">如果模块调用define(),请确认define调用是通过在脚本调试器中调试达到的。</target>
        </trans-unit>
        <trans-unit id="d640768407ba7527782d61745268bcd8becf18d3" translate="yes" xml:space="preserve">
          <source>If the module does not have any dependencies, and it is just a collection of name/value pairs, then just pass an object literal to define():</source>
          <target state="translated">如果该模块没有任何依赖关系,它只是一个名称/值对的集合,那么只需向 define()传递一个对象文字。</target>
        </trans-unit>
        <trans-unit id="c4bc89c20098e3d217c9feeee11e6aefa259ab00" translate="yes" xml:space="preserve">
          <source>If the module does not have dependencies, but needs to use a function to do some setup work, then define itself, pass a function to define():</source>
          <target state="translated">如果模块没有依赖关系,但需要用函数来做一些设置工作,那就自己定义,传一个函数给define()。</target>
        </trans-unit>
        <trans-unit id="dd2976ac338c8b322312501c44533eea743a2006" translate="yes" xml:space="preserve">
          <source>If the module has dependencies, the first argument should be an array of dependency names, and the second argument should be a definition function. The function will be called to define the module once all dependencies have loaded. The function should return an object that defines the module. The dependencies will be passed to the definition function as function arguments, listed in the same order as the order in the dependency array:</source>
          <target state="translated">如果模块有依赖关系,第一个参数应该是一个依赖关系名称的数组,第二个参数应该是一个定义函数。一旦所有的依赖项都加载完毕,就会调用这个函数来定义模块。这个函数应该返回一个定义模块的对象。依赖关系将作为函数参数传递给定义函数,其顺序与依赖关系数组中的顺序相同。</target>
        </trans-unit>
        <trans-unit id="268886bdf3247e5fb6d83a42bdc3c1afdd1fc395" translate="yes" xml:space="preserve">
          <source>If the modules are laid out on disk like this:</source>
          <target state="translated">如果模块在磁盘上的布局是这样的。</target>
        </trans-unit>
        <trans-unit id="3c3a7a2d48579a3fd24b6373c3334acc93d4649e" translate="yes" xml:space="preserve">
          <source>If the problem is the &lt;code&gt;var define&lt;/code&gt; lint approach, use &lt;code&gt;/*global define */&lt;/code&gt; (no space before &quot;global&quot;) comment style instead.</source>
          <target state="translated">如果问题是 &lt;code&gt;var define&lt;/code&gt; lint方法，请改用 &lt;code&gt;/*global define */&lt;/code&gt; （&amp;ldquo; global&amp;rdquo;之前没有空格）注释样式。</target>
        </trans-unit>
        <trans-unit id="fe055917e1738e441340d4fd7a9ee5b263683ac9" translate="yes" xml:space="preserve">
          <source>If the problem is the use of loader plugins or anonymous modules but the RequireJS optimizer is not used for file bundling, use the RequireJS optimizer.</source>
          <target state="translated">如果问题是使用了加载器插件或匿名模块,但没有使用RequireJS优化器进行文件捆绑,请使用RequireJS优化器。</target>
        </trans-unit>
        <trans-unit id="6afec34eee1181c090fdd3435b03454d82f91ced" translate="yes" xml:space="preserve">
          <source>If this was the paths config:</source>
          <target state="translated">如果这是路径配置。</target>
        </trans-unit>
        <trans-unit id="3fe2042d352255fab2f771b63873d6c1d5d861d6" translate="yes" xml:space="preserve">
          <source>If we are creating a new script loader, we can do better.</source>
          <target state="translated">如果我们正在创建一个新的脚本加载器,我们可以做得更好。</target>
        </trans-unit>
        <trans-unit id="c2471cbb8f701f4612ea9f0ec89dbe001ba98766" translate="yes" xml:space="preserve">
          <source>If you are familiar with CommonJS modules, you could instead use &lt;strong&gt;exports&lt;/strong&gt; to create an empty object for the module that is available immediately for reference by other modules. By doing this on both sides of a circular dependency, you can then safely hold on to the the other module. This only works if each module is exporting an object for the module value, not a function:</source>
          <target state="translated">如果您熟悉CommonJS模块，则可以使用&lt;strong&gt;导出&lt;/strong&gt;为该模块创建一个空对象，该空对象可立即供其他模块引用。通过在循环依赖关系的两侧执行此操作，然后可以安全地保留另一个模块。仅当每个模块都为模块值而不是函数导出对象时，此方法才有效：</target>
        </trans-unit>
        <trans-unit id="e8ab978d23a4c5d930f4a73ffb4cdaedcb9db803" translate="yes" xml:space="preserve">
          <source>If you are having trouble with the examples below, here are some common pitfalls that might be the source of the problem:</source>
          <target state="translated">如果你在下面的例子中遇到问题,这里有一些常见的陷阱,可能是问题的根源。</target>
        </trans-unit>
        <trans-unit id="ba0cad9bd089cab72f65d9b6da275ca2f8067cc2" translate="yes" xml:space="preserve">
          <source>If you are listing dependencies in the dependency array, make sure that &lt;strong&gt;require&lt;/strong&gt; and &lt;strong&gt;name&lt;/strong&gt; are in the dependency array:</source>
          <target state="translated">如果要在依赖项数组中列出依赖项，请确保&lt;strong&gt;require&lt;/strong&gt;和&lt;strong&gt;name&lt;/strong&gt;在依赖项数组中：</target>
        </trans-unit>
        <trans-unit id="ad022743a7df2ffdcd0557108ff5b38fd748951d" translate="yes" xml:space="preserve">
          <source>If you are using the simplified define wrapper, make sure you have &lt;strong&gt;require&lt;/strong&gt; as the first argument to the definition function:</source>
          <target state="translated">如果使用简化的定义包装器，请确保将&lt;strong&gt;require&lt;/strong&gt;作为定义函数的第一个参数：</target>
        </trans-unit>
        <trans-unit id="4e0ee4abad95938db6b89b46529ee3dc2e95d105" translate="yes" xml:space="preserve">
          <source>If you are using uglifyjs to minify the code, &lt;strong&gt;do not&lt;/strong&gt; set the uglify option &lt;code&gt;toplevel&lt;/code&gt; to true, or if using the command line &lt;strong&gt;do not&lt;/strong&gt; pass &lt;code&gt;-mt&lt;/code&gt;. That option mangles the global names that shim uses to find exports.</source>
          <target state="translated">如果您使用uglifyjs缩小代码，&lt;strong&gt;请不要&lt;/strong&gt;将uglify选项 &lt;code&gt;toplevel&lt;/code&gt; 设置为true，或者如果使用命令行&lt;strong&gt;不&lt;/strong&gt;传递 &lt;code&gt;-mt&lt;/code&gt; 。该选项会破坏shim用于查找出口的全局名称。</target>
        </trans-unit>
        <trans-unit id="31e99de161473edbb5082258b810e3d2c3da191c" translate="yes" xml:space="preserve">
          <source>If you define a circular dependency (&quot;a&quot; needs &quot;b&quot; and &quot;b&quot; needs &quot;a&quot;), then in this case when &quot;b&quot;'s module function is called, it will get an undefined value for &quot;a&quot;. &quot;b&quot; can fetch &quot;a&quot; later after modules have been defined by using the require() method (be sure to specify require as a dependency so the right context is used to look up &quot;a&quot;):</source>
          <target state="translated">如果你定义了一个循环依赖(&quot;a &quot;需要 &quot;b&quot;,&quot;b &quot;需要 &quot;a&quot;),那么在这种情况下,当 &quot;b &quot;的模块函数被调用时,它将为 &quot;a &quot;获取一个未定义的值。&quot;b &quot;可以在以后通过使用require()方法定义模块后再取 &quot;a&quot;(一定要指定require为依赖关系,这样就可以使用正确的上下文来查找 &quot;a&quot;)。</target>
        </trans-unit>
        <trans-unit id="c60a6779241f198cb0b63a3cd7149ce07e1aae79" translate="yes" xml:space="preserve">
          <source>If you do not express the dependencies, you will likely get loading errors since RequireJS loads scripts asynchronously and out of order for speed.</source>
          <target state="translated">如果你不表达依赖关系,你很可能会得到加载错误,因为RequireJS是异步加载脚本的,而且为了速度而不按顺序加载。</target>
        </trans-unit>
        <trans-unit id="9663e162bea6d2fd2a76323abdb98db33154de78" translate="yes" xml:space="preserve">
          <source>If you do not want the main-build.js file minified, pass &lt;strong&gt;optimize=none&lt;/strong&gt; in the command above.</source>
          <target state="translated">如果您不想缩小main-build.js文件，请在上面的命令中传递&lt;strong&gt;optimize = none&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="001e6439bbf6aa885f14abd4880ee619763d737a" translate="yes" xml:space="preserve">
          <source>If you find you have a problem, and want to report it, use the &lt;a href=&quot;http://github.com/requirejs/r.js/issues&quot;&gt;r.js GitHub Issues page&lt;/a&gt;.</source>
          <target state="translated">如果发现问题并想报告，请使用&lt;a href=&quot;http://github.com/requirejs/r.js/issues&quot;&gt;r.js GitHub Issues页面&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c63d9b75d9f443bf6b7818c6648924354e9520f7" translate="yes" xml:space="preserve">
          <source>If you get an error with a requireModules, it probably means other modules that depend on the modules in that requireModules array are not defined.</source>
          <target state="translated">如果你的requireModules出错,可能意味着其他依赖该requireModules数组中模块的模块没有被定义。</target>
        </trans-unit>
        <trans-unit id="6de57f65ff4fa1cadce3b83f694a69d1b4133325" translate="yes" xml:space="preserve">
          <source>If you have many modules to convert, the &lt;a href=&quot;https://github.com/requirejs/r.js&quot;&gt;r.js project&lt;/a&gt; has a converter tool built into the r.js file. Give it the path to the directory you want to convert and an output directory:</source>
          <target state="translated">如果要转换的模块很多，则&lt;a href=&quot;https://github.com/requirejs/r.js&quot;&gt;r.js项目&lt;/a&gt;在r.js文件中内置了一个转换工具。为其提供要转换的目录的路径和输出目录：</target>
        </trans-unit>
        <trans-unit id="9620284a6bc32590c3169f3f4b48d289a07d4f27" translate="yes" xml:space="preserve">
          <source>If you have modules that are in the traditional CommonJS module format, then you can easily convert them to work with RequireJS. Not all modules will convert cleanly to the new format. Types of modules that may not convert well:</source>
          <target state="translated">如果你有传统的CommonJS模块格式的模块,那么你可以很容易地将它们转换为与RequireJS一起工作。并非所有的模块都能干净利落地转换到新格式。可能无法很好转换的模块类型。</target>
        </trans-unit>
        <trans-unit id="5a0f889c91ca5d1dd6ba34bf9e33e0c53924951a" translate="yes" xml:space="preserve">
          <source>If you just have a few modules to convert, then all you need to do is wrap the module in this code:</source>
          <target state="translated">如果你只是有几个模块要转换,那么你需要做的就是用这段代码来包装模块。</target>
        </trans-unit>
        <trans-unit id="290bb6c87f9786e352e57820066a0d3e3282fb87" translate="yes" xml:space="preserve">
          <source>If you manually code a script tag in HTML to load a script that has a few named modules, but then try to load an anonymous module that ends up having the same name as one of the named modules in the script loaded by the manually coded script tag.</source>
          <target state="translated">如果你在HTML中手动编码一个脚本标签来加载一个有几个命名模块的脚本,然后尝试加载一个匿名模块,结果这个匿名模块与手动编码的脚本标签加载的脚本中的一个命名模块名称相同。</target>
        </trans-unit>
        <trans-unit id="c79c7768de0828796b0344821b72ca7c31441ddb" translate="yes" xml:space="preserve">
          <source>If you manually code a script tag in HTML to load a script with an anonymous define() call, this error can occur.</source>
          <target state="translated">如果你在HTML中手动编码一个脚本标签,用匿名的define()调用来加载一个脚本,就会出现这个错误。</target>
        </trans-unit>
        <trans-unit id="e07cad218dbc58c61e09b42087ab5dc1921031f1" translate="yes" xml:space="preserve">
          <source>If you manually code an HTML script tag, be sure it only includes named modules, and that an anonymous module that will have the same name as one of the modules in that file is not loaded.</source>
          <target state="translated">如果您手动编写HTML脚本标签,请确保它只包含命名的模块,并且不会加载一个与该文件中的某个模块同名的匿名模块。</target>
        </trans-unit>
        <trans-unit id="eec9ccbb226e68d2a8826329d0764fb9286f03a7" translate="yes" xml:space="preserve">
          <source>If you need to set a path like the &quot;core/jquery.tabs&quot; one, use a build.js file with the build options specified as a JavaScript object instead of using command line arguments.</source>
          <target state="translated">如果你需要设置像 &quot;core/jquery.tabs &quot;这样的路径,请使用build.js文件,将构建选项指定为JavaScript对象,而不是使用命令行参数。</target>
        </trans-unit>
        <trans-unit id="9fe94189273fa0c665402c6a532f8ae2540a649a" translate="yes" xml:space="preserve">
          <source>If you prefer to not include the root bundle in the top level module, you can define it like a normal locale bundle. In that case, the top level module would look like:</source>
          <target state="translated">如果你不希望在顶层模块中包含root bundle,你可以像定义普通的locale bundle一样定义它。在这种情况下,顶层模块会像这样。</target>
        </trans-unit>
        <trans-unit id="ea4e68f347851dad8c4c00882d4e80a08c8f8134" translate="yes" xml:space="preserve">
          <source>If you prefer to not use npm, you can get r.js directly:</source>
          <target state="translated">如果你喜欢不使用npm,你可以直接得到r.js。</target>
        </trans-unit>
        <trans-unit id="7f9d6c4000e170c67495235bbeaafa76bd8b494d" translate="yes" xml:space="preserve">
          <source>If you then also use &lt;a href=&quot;https://github.com/requirejs/almond&quot;&gt;almond&lt;/a&gt; to build your code without require.js, be sure to use the &lt;a href=&quot;https://github.com/requirejs/r.js/blob/master/build/example.build.js#L413&quot;&gt;insertRequire&lt;/a&gt; build setting to insert a require call for the main module -- that serves the same purpose of the initial require() call that data-main does.</source>
          <target state="translated">如果然后您还使用&lt;a href=&quot;https://github.com/requirejs/almond&quot;&gt;杏仁&lt;/a&gt;来构建没有require.js的代码，请确保使用&lt;a href=&quot;https://github.com/requirejs/r.js/blob/master/build/example.build.js#L413&quot;&gt;insertRequire&lt;/a&gt;构建设置为主模块插入一个require调用-该功能与最初的require（）调用的目的相同，即data-main做。</target>
        </trans-unit>
        <trans-unit id="6d11834f478a454e47eae0e058c9489d1bdeb1ac" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;var define;&lt;/code&gt; at the top of your file for jshint/jslint purposes, this will cause a problem for the optimizer because it avoids parsing files that declare a &lt;code&gt;define&lt;/code&gt; variable, since that may indicate a script that was created by a concatenation of some scripts that use a local define.</source>
          <target state="translated">如果使用 &lt;code&gt;var define;&lt;/code&gt; 出于jshint / jslint的目的，在文件顶部，这将导致优化器出现问题，因为它避免了解析声明了 &lt;code&gt;define&lt;/code&gt; 变量的文件，因为这可能表明该脚本是由某些使用本地脚本的脚本串联而成的定义。</target>
        </trans-unit>
        <trans-unit id="ca847ebc0250cd99dec110fb3a5f58289151f4c3" translate="yes" xml:space="preserve">
          <source>If you use a similar project layout as specified in the &lt;a href=&quot;http://requirejs.org/docs/start.html&quot;&gt;Start Guide&lt;/a&gt;, the start of your web project would look something like this (Node/Rhino-based projects are similar, just use the contents of the &lt;strong&gt;scripts&lt;/strong&gt; directory as the top-level project directory):</source>
          <target state="translated">如果您使用《&lt;a href=&quot;http://requirejs.org/docs/start.html&quot;&gt;入门指南》中&lt;/a&gt;指定的类似项目布局，则Web项目的开始将类似于以下内容（基于Node / Rhino的项目相似，只需使用&lt;strong&gt;scripts&lt;/strong&gt;目录的内容作为顶级项目目录）：</target>
        </trans-unit>
        <trans-unit id="4c692604f116595f04f5b8bd5d70ca44b5c8af4b" translate="yes" xml:space="preserve">
          <source>If you use the loader plugins or anonymous modules (modules that call define() with no string ID) but do not use the RequireJS optimizer to combine files together, this error can occur. The optimizer knows how to name anonymous modules correctly so that they can be combined with other modules in an optimized file.</source>
          <target state="translated">如果您使用加载器插件或匿名模块(调用define()的模块,没有字符串ID),但没有使用RequireJS优化器将文件组合在一起,可能会出现这个错误。优化器知道如何正确地命名匿名模块,以便它们可以在优化后的文件中与其他模块组合在一起。</target>
        </trans-unit>
        <trans-unit id="feb5637a3fb0c000cd062fa3f3d6df8b64fe1e07" translate="yes" xml:space="preserve">
          <source>If you want to &lt;b&gt;exclude&lt;/b&gt; that file from being included, and just need to map &quot;dependency&quot; for the build (otherwise it will not build), then use the special &quot;empty:&quot; paths config:</source>
          <target state="translated">如果要从该文件中&lt;b&gt;排除&lt;/b&gt;该文件，而只需要为构建映射&amp;ldquo;依赖关系&amp;rdquo;（否则它将无法构建），请使用特殊的&amp;ldquo; empty：&amp;rdquo;路径配置：</target>
        </trans-unit>
        <trans-unit id="c4d84ae38cccd676fef602cccfe8d51ad757c1ac" translate="yes" xml:space="preserve">
          <source>If you want to code a module so that it works with RequireJS and in Node, without requiring users of your library in Node to use RequireJS, then you can use the &lt;a href=&quot;https://github.com/jrburke/amdefine&quot;&gt;amdefine&lt;/a&gt; package to do this:</source>
          <target state="translated">如果要对模块进行编码以使其能够与RequireJS以及在Node中一起使用，而又不要求Node中的库用户使用RequireJS，则可以使用&lt;a href=&quot;https://github.com/jrburke/amdefine&quot;&gt;amdefine&lt;/a&gt;包来执行此操作：</target>
        </trans-unit>
        <trans-unit id="af5b2645f618b5644bc791db1e0847039d902272" translate="yes" xml:space="preserve">
          <source>If you want to do &lt;code&gt;require()&lt;/code&gt; calls in the HTML page, then it is best to not use data-main. data-main is only intended for use when the page just has one main entry point, the data-main script. For pages that want to do inline &lt;code&gt;require()&lt;/code&gt; calls, it is best to nest those inside a &lt;code&gt;require()&lt;/code&gt; call for the configuration:</source>
          <target state="translated">如果要在HTML页面中进行 &lt;code&gt;require()&lt;/code&gt; 调用，则最好不要使用data-main。data-main仅在页面只有一个主要入口点即data-main脚本时使用。对于要进行内联 &lt;code&gt;require()&lt;/code&gt; 调用的页面，最好将那些页面嵌套在 &lt;code&gt;require()&lt;/code&gt; 调用中以进行配置：</target>
        </trans-unit>
        <trans-unit id="e7664b7c0117630563d8b0ce1cf3190fcf1304bd" translate="yes" xml:space="preserve">
          <source>If you want to do more sophisticated dependency graph analysis for undefining work, the semi-private &lt;a href=&quot;https://github.com/requirejs/requirejs/wiki/Internal-API:-onResourceLoad&quot;&gt;onResourceLoad API&lt;/a&gt; may be helpful.</source>
          <target state="translated">如果要进行更复杂的依赖关系图分析以进行未定义的工作，则半私有的&lt;a href=&quot;https://github.com/requirejs/requirejs/wiki/Internal-API:-onResourceLoad&quot;&gt;onResourceLoad API&lt;/a&gt;可能会有所帮助。</target>
        </trans-unit>
        <trans-unit id="296789b3d29436db474fc5e4c49a54f6bfbe4190" translate="yes" xml:space="preserve">
          <source>If you want to include require.js with the main.js source, you can use this kind of command:</source>
          <target state="translated">如果你想在main.js源码中包含require.js,你可以使用这种命令。</target>
        </trans-unit>
        <trans-unit id="46ae1d084e30675108b6b0a3e880efee8585a650" translate="yes" xml:space="preserve">
          <source>If you want to include this dependency in the built/optimized file, download the JS file and in the build profile for the optimizer, put in a paths config that points to that local file.</source>
          <target state="translated">如果你想在构建/优化文件中包含这个依赖关系,下载JS文件,并在优化器的构建配置文件中,放入指向该本地文件的路径配置。</target>
        </trans-unit>
        <trans-unit id="3a65a8e36754343f29f91691e06b17764aa16a5d" translate="yes" xml:space="preserve">
          <source>If you want to install requirejs locally in a project as an npm package, instead of globally:</source>
          <target state="translated">如果你想在项目中以npm包的形式在本地安装requirejs,而不是全局安装。</target>
        </trans-unit>
        <trans-unit id="164b3d635a3f7c3d266ffda4373f5819b2582504" translate="yes" xml:space="preserve">
          <source>If you want to use AMD but still use the &lt;strong&gt;load one script at the bottom of the HTML page&lt;/strong&gt; approach:</source>
          <target state="translated">如果要使用AMD但仍使用&lt;strong&gt;HTML页面&lt;/strong&gt;方法&lt;strong&gt;底部&lt;/strong&gt;的&lt;strong&gt;加载一个脚本&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="977e480d5d183fc7ba40346f208e1b484206ed16" translate="yes" xml:space="preserve">
          <source>If you want to use RequireJS directly to code your module, and then export a module value to node so that it can be used in other Node programs without requiring that app to use RequireJS, you can use the approach listed in the next example.</source>
          <target state="translated">如果你想直接使用RequireJS对你的模块进行编码,然后将模块值导出到node,这样就可以在其他Node程序中使用,而不需要该程序使用RequireJS,你可以使用下一个例子中列出的方法。</target>
        </trans-unit>
        <trans-unit id="6f7cb349eb5ac9e5b57bf37db65dc198540d53a6" translate="yes" xml:space="preserve">
          <source>If you want to use define() for your modules but still run them in Node without needing to run RequireJS on the server, see &lt;a href=&quot;#nodeModules&quot;&gt;the section below&lt;/a&gt; about using &lt;a href=&quot;https://github.com/jrburke/amdefine&quot;&gt;amdefine&lt;/a&gt;.</source>
          <target state="translated">如果您想对模块使用define（），但仍需要在Node中运行它们而不需要在服务器上运行RequireJS，请参阅&lt;a href=&quot;#nodeModules&quot;&gt;以下&lt;/a&gt;有关使用&lt;a href=&quot;https://github.com/jrburke/amdefine&quot;&gt;amdefine &lt;/a&gt;的部分。</target>
        </trans-unit>
        <trans-unit id="cedb40532461d188e89d12caa7374f46648787e1" translate="yes" xml:space="preserve">
          <source>If you want to wrap your built file so it can be used in pages that do not have an AMD loader like RequireJS, see the &lt;a href=&quot;http://requirejs.org/docs/faq-optimization.html&quot;&gt;Optimization FAQ&lt;/a&gt;.</source>
          <target state="translated">如果您想打包生成的文件，以便可以在没有AMD加载器的页面（如RequireJS）中使用它，请参阅&amp;ldquo; &lt;a href=&quot;http://requirejs.org/docs/faq-optimization.html&quot;&gt;优化常见问题解答&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f758dc21534ccb9894490766f0bb0a3354e675a0" translate="yes" xml:space="preserve">
          <source>If you wish to reuse some code that was written in the traditional &lt;a href=&quot;http://wiki.commonjs.org/wiki/Modules/1.1.1&quot;&gt;CommonJS module format&lt;/a&gt; it may be difficult to re-work to the array of dependencies used above, and you may prefer to have direct alignment of dependency name to the local variable used for that dependency. You can use the &lt;a href=&quot;commonjs&quot;&gt;simplified CommonJS wrapper&lt;/a&gt; for those cases:</source>
          <target state="translated">如果您希望重用以传统&lt;a href=&quot;http://wiki.commonjs.org/wiki/Modules/1.1.1&quot;&gt;CommonJS模块格式&lt;/a&gt;编写的某些代码，则可能难以对上面使用的依赖项数组进行重新处理，并且您可能更希望将依赖项名称直接与用于此的本地变量对齐依赖性。在以下情况下，可以使用&lt;a href=&quot;commonjs&quot;&gt;简化的CommonJS包装器&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="1bbc88d8b7d0dba0bef2316c81d3257b395c963e" translate="yes" xml:space="preserve">
          <source>If your build profile looked like so:</source>
          <target state="translated">如果你的建造档案是这样的。</target>
        </trans-unit>
        <trans-unit id="fa7030a64e81de81778033ae09c733651717e7a7" translate="yes" xml:space="preserve">
          <source>If your code uses tests like the following:</source>
          <target state="translated">如果你的代码使用了下面这样的测试。</target>
        </trans-unit>
        <trans-unit id="33134584d1a1bacbf328e47b02d9ac4ab14c6c31" translate="yes" xml:space="preserve">
          <source>Implement &lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/AMD&quot;&gt;the AMD API&lt;/a&gt;. There is &lt;a href=&quot;https://groups.google.com/group/amd-implement&quot;&gt;a discussion list&lt;/a&gt; and &lt;a href=&quot;https://github.com/amdjs/amdjs-tests&quot;&gt;compatibility tests&lt;/a&gt;. By implementing AMD, you will reduce multi-module system boilerplate and help prove out a workable JavaScript module system on the web. This can be fed back into the ECMAScript process to build better native module support.</source>
          <target state="translated">实施&lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/AMD&quot;&gt;AMD API&lt;/a&gt;。有&lt;a href=&quot;https://groups.google.com/group/amd-implement&quot;&gt;一个讨论列表&lt;/a&gt;和&lt;a href=&quot;https://github.com/amdjs/amdjs-tests&quot;&gt;兼容性测试&lt;/a&gt;。通过实施AMD，您将减少多模块系统的样板，并帮助在网络上证明可行的JavaScript模块系统。这可以反馈到ECMAScript流程中，以建立更好的本机模块支持。</target>
        </trans-unit>
        <trans-unit id="702c01eb821162396b5526b3e65d64751b303b3b" translate="yes" xml:space="preserve">
          <source>In Firefox and WebKit browsers, a line number and file name will be indicated in the error. It can be used to locate the source of the problem. Better isolation of the error can be done by using a debugger to place a breakpoint in the file that contains the error.</source>
          <target state="translated">在Firefox和WebKit浏览器中,错误中会显示行号和文件名。它可以用来定位问题的来源。通过使用调试器在包含错误的文件中放置一个断点,可以更好地隔离错误。</target>
        </trans-unit>
        <trans-unit id="ff0f55e14256af8eb245096429abdcc074495ed5" translate="yes" xml:space="preserve">
          <source>In RequireJS 2.0.*, the &quot;exports&quot; property in the shim config could have been a function instead of a string. In that case, it functioned the same as the &quot;init&quot; property as shown above. The &quot;init&quot; pattern is used in RequireJS 2.1.0+ so a string value for &lt;code&gt;exports&lt;/code&gt; can be used for &lt;a href=&quot;#config-enforceDefine&quot;&gt;enforceDefine&lt;/a&gt;, but then allow functional work once the library is known to have loaded.</source>
          <target state="translated">在RequireJS 2.0。*中，shim配置中的&amp;ldquo; exports&amp;rdquo;属性可能是函数而不是字符串。在这种情况下，它的功能与上述&amp;ldquo; init&amp;rdquo;属性相同。&amp;ldquo; init&amp;rdquo;模式在RequireJS 2.1.0+中使用，因此可以将用于 &lt;code&gt;exports&lt;/code&gt; 的字符串值用于&lt;a href=&quot;#config-enforceDefine&quot;&gt;forceDefine&lt;/a&gt;，但是一旦已知已加载库，就可以进行功能工作。</target>
        </trans-unit>
        <trans-unit id="ecc029984d4c8bb1667c1c77461dda09354dda68" translate="yes" xml:space="preserve">
          <source>In general though, it is best to use the baseUrl and &quot;paths&quot; config to set paths for module IDs. By doing so, it gives you more flexibility in renaming and configuring the paths to different locations for optimization builds.</source>
          <target state="translated">不过一般来说,最好使用baseUrl和 &quot;paths &quot;配置来设置模块ID的路径。这样做,可以让你更灵活地重命名和配置路径到不同的位置进行优化构建。</target>
        </trans-unit>
        <trans-unit id="9a0fe9ee95c542b2027e2cf755a45d2afa25ff6e" translate="yes" xml:space="preserve">
          <source>In general, if it is a path, it is relative to the build.js file used to hold the build options, or if just using command line arguments, relative to the current working directory. Example of properties that are file paths: &lt;strong&gt;appDir&lt;/strong&gt;, &lt;strong&gt;dir&lt;/strong&gt;, &lt;strong&gt;mainConfigFile&lt;/strong&gt;, &lt;strong&gt;out&lt;/strong&gt;, &lt;strong&gt;wrap.startFile&lt;/strong&gt;, &lt;strong&gt;wrap.endFile&lt;/strong&gt;.</source>
          <target state="translated">通常，如果它是路径，则相对于用于保存构建选项的build.js文件，或者仅相对于当前工作目录而言，如果仅使用命令行参数。文件路径属性的示例：&lt;strong&gt;appDir&lt;/strong&gt;，&lt;strong&gt;dir&lt;/strong&gt;，&lt;strong&gt;mainConfigFile&lt;/strong&gt;，&lt;strong&gt;out&lt;/strong&gt;，&lt;strong&gt;wrap.startFile&lt;/strong&gt;，&lt;strong&gt;wrap.endFile&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="1fe96d7fff0f912ef23ce1a903bec59c1e061054" translate="yes" xml:space="preserve">
          <source>In particular, &lt;strong&gt;the following will not work&lt;/strong&gt;:</source>
          <target state="translated">特别&lt;strong&gt;是以下情况将不起作用&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="f35ef7f938973ce790f5493a620318e22603f51d" translate="yes" xml:space="preserve">
          <source>In the &lt;strong&gt;modules&lt;/strong&gt; array, specify the module names that you want to optimize, in the example, &quot;main&quot;. &quot;main&quot; will be mapped to &lt;strong&gt;appdirectory/scripts/main.js&lt;/strong&gt; in your project. The build system will then trace the dependencies for main.js and inject them into the &lt;strong&gt;appdirectory-build/scripts/main.js&lt;/strong&gt; file.</source>
          <target state="translated">在&lt;strong&gt;模块&lt;/strong&gt;数组中，指定要优化的模块名称，例如&amp;ldquo; main&amp;rdquo;。&amp;ldquo; main&amp;rdquo;将映射到您项目中的&lt;strong&gt;appdirectory / scripts / main.js。&lt;/strong&gt;然后，构建系统将跟踪main.js的依赖项，并将其注入到&lt;strong&gt;appdirectory-build / scripts / main.js&lt;/strong&gt;文件中。</target>
        </trans-unit>
        <trans-unit id="104b91c1bd0b54f7e9b0f9f56f1480a81283afad" translate="yes" xml:space="preserve">
          <source>In the future, this code may be pulled into the require/ directory as an optional module that you can load in your env to get the right load behavior based on the host environment.</source>
          <target state="translated">未来,这段代码可能会被拉到require/目录下,作为一个可选的模块,你可以在你的env中加载,以获得基于主机环境的正确加载行为。</target>
        </trans-unit>
        <trans-unit id="ff2906dc76505cca03806c98590fb6c7fb3e8b67" translate="yes" xml:space="preserve">
          <source>In the r.js optimizer, &lt;strong&gt;preserveLicenseComments&lt;/strong&gt; works as a pre- and post-processing step on a JS file. Various kinds of license comments are found, pulled out of the JS source, then that modified source is passed to the minifier. When the minifier is done, the comments are added to the top of the file by the r.js optimizer.</source>
          <target state="translated">在r.js优化器中，&lt;strong&gt;preserveLicenseComments&lt;/strong&gt;充当JS文件的预处理和后处理步骤。找到各种许可证注释，将其从JS源中拉出，然后将修改后的源传递给压缩程序。完成压缩程序后，r.js优化器会将注释添加到文件顶部。</target>
        </trans-unit>
        <trans-unit id="bd30abf3900baa5cd5ba9bf23def7c8f59c6f6c1" translate="yes" xml:space="preserve">
          <source>In this case, the normalized names the './a', './b', and './c' will be determined relative to the module asking for this resource. Since RequireJS does not know how to inspect the 'index!2?./a:./b:./c' to normalize the names for './a', './b', and './c', it needs to ask the plugin. This is the purpose of the normalize call.</source>
          <target state="translated">在这种情况下,'./a'、'./b'和'./c'的规范化名称将相对于请求该资源的模块来确定。由于RequireJS不知道如何检查'index!2?./a:./b:./c'来归一化'./a'、'./b'和'./c'的名称,它需要询问插件。这就是规范化调用的目的。</target>
        </trans-unit>
        <trans-unit id="af3920b5a279ff0e144ef6675ba1d61fbdb25e91" translate="yes" xml:space="preserve">
          <source>In this example, a my/shirt module is created. It depends on my/cart and my/inventory. On disk, the files are structured like this:</source>
          <target state="translated">在这个例子中,创建了一个my/shirt模块,它依赖于my/cart和my/inventory。它依赖于my/cart和my/inventory。在磁盘上,文件的结构是这样的。</target>
        </trans-unit>
        <trans-unit id="55e27a4c9226afbe32b577671abb7f2cbde38000" translate="yes" xml:space="preserve">
          <source>In version 1.0.5+ of the optimizer, the &lt;strong&gt;&lt;a href=&quot;https://github.com/requirejs/r.js/blob/master/build/example.build.js#L27&quot;&gt;mainConfigFile&lt;/a&gt;&lt;/strong&gt; option can be used to specify the location of the runtime config. If specified with the path to your main JS file, the first &lt;code&gt;requirejs({}), requirejs.config({}), require({}), or require.config({})&lt;/code&gt; found in that file will be parsed out and used as part of the configuration options passed to the optimizer:</source>
          <target state="translated">在优化程序的&lt;strong&gt;&lt;a href=&quot;https://github.com/requirejs/r.js/blob/master/build/example.build.js#L27&quot;&gt;1.0.5+&lt;/a&gt;&lt;/strong&gt;版本中，&lt;strong&gt;mainConfigFile&lt;/strong&gt;选项可用于指定运行时配置的位置。如果使用主JS文件的路径指定，则将解析出该文件中找到的第一个 &lt;code&gt;requirejs({}), requirejs.config({}), require({}), or require.config({})&lt;/code&gt; 并用作传递给优化器的配置选项的一部分：</target>
        </trans-unit>
        <trans-unit id="677c97dead3af89beaae180f2b05fb0885038810" translate="yes" xml:space="preserve">
          <source>In your main.js file, create a paths config that gives the script a module name. This can be done even if the script does not define a module via a call to define(). paths config are just used to map short module/script IDs to an URL. This allows you to use a different paths config for the optimization. In main.js:</source>
          <target state="translated">在你的main.js文件中,创建一个paths config,给脚本一个模块名。即使脚本没有通过调用define()来定义模块,也可以这样做。paths config只是用来将短的模块/脚本ID映射到一个URL。这允许你使用不同的路径配置进行优化。在main.js中。</target>
        </trans-unit>
        <trans-unit id="a4f447bcdd3ea14912a0ab5851ae0c9a896b9bc5" translate="yes" xml:space="preserve">
          <source>Instead of using require() to get dependencies inside the function passed to define(), you can also specify them via a dependency array argument to define(). The order of the names in the dependency array match the order of arguments passed to the definition function passed to define(). So the above example that uses the module &lt;strong&gt;foo&lt;/strong&gt;:</source>
          <target state="translated">除了使用require（）获取传递给define（）的函数内部的依赖关系之外，您还可以通过define（）的依赖关系数组参数来指定它们。依赖关系数组中名称的顺序与传递给传递给define（）的定义函数的参数顺序相匹配。因此，上面的示例使用模块&lt;strong&gt;foo&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="7fcc07e4da729e4b4e9fcc19ccbda6fd0e667335" translate="yes" xml:space="preserve">
          <source>Integration with has.js</source>
          <target state="translated">与has.js集成</target>
        </trans-unit>
        <trans-unit id="1f8eb79c06f41e4c3eb114f2a67df248c0294380" translate="yes" xml:space="preserve">
          <source>Internet Explorer has a set of problems that make it difficult to detect load failures for errbacks/paths fallbacks:</source>
          <target state="translated">Internet Explorer有一系列的问题,使得它很难检测到errbacks/paths fallbacks的加载失败。</target>
        </trans-unit>
        <trans-unit id="b4e6a310890f62289340d7802703b8c2586c6d86" translate="yes" xml:space="preserve">
          <source>Intro</source>
          <target state="translated">Intro</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="4ab560f11406cd0e8a158f69d8a4cedb4f432af2" translate="yes" xml:space="preserve">
          <source>Invalid require call</source>
          <target state="translated">无效的需求调用</target>
        </trans-unit>
        <trans-unit id="37b0ca0680cdcc950b168ac80a44a59f649d995a" translate="yes" xml:space="preserve">
          <source>It also meant they placed more of a burden on web developers to implement the format, and the stop-gap measures meant debugging was worse. eval-based debugging or debugging multiple files that are concatenated into one file have practical weaknesses. Those weaknesses may be addressed in browser tooling at some point in the future, but the end result: using CommonJS modules in the most common of JS environments, the browser, is non-optimal today.</source>
          <target state="translated">这也意味着他们给Web开发者带来了更多的负担来实现这种格式,而止损措施意味着调试工作更糟糕了。基于评价的调试或调试多个连成一个文件的文件都有实际的弱点。这些弱点可能会在未来的某个时候在浏览器工具中得到解决,但最终的结果是:在最常见的JS环境--浏览器中使用CommonJS模块,如今是非最佳的。</target>
        </trans-unit>
        <trans-unit id="06871a3ab0f9615b1d6fab6eac51a26791195668" translate="yes" xml:space="preserve">
          <source>It differs from the normal CommonJS syntax out of necessity to work well in the browser. There have been suggestions that the normal CommonJS syntax could be used with head.appendChild(script) type of loading if a server process transforms the modules to a transport format that has a function wrapper.</source>
          <target state="translated">它与普通CommonJS语法不同,是出于在浏览器中良好运行的需要。有人建议,如果服务器进程将模块转换为具有函数封装器的传输格式,那么正常的CommonJS语法可以与head.appendChild(script)类型的加载一起使用。</target>
        </trans-unit>
        <trans-unit id="5ffe27ee87a8206f32325462d1728096ff92ef70" translate="yes" xml:space="preserve">
          <source>It does not have strong cross browser support</source>
          <target state="translated">它没有强大的跨浏览器支持</target>
        </trans-unit>
        <trans-unit id="74a4bb6d4f0f076d77e09d55731eb64159c9e44d" translate="yes" xml:space="preserve">
          <source>It is a message-passing API, and the scripts likely want to interact with the DOM, so it means just using the worker to fetch the script text, but pass the text back to the main window then use eval/script with text body to execute the script. This has all of the problems as XHR mentioned above.</source>
          <target state="translated">这是一个消息传递的API,而脚本很可能要与DOM交互,所以这意味着只需要使用worker来获取脚本文本,但将文本传回主窗口,然后使用带有文本体的eval/script来执行脚本。这样就有了上面XHR提到的所有问题。</target>
        </trans-unit>
        <trans-unit id="933995d016ad7a4c199042da83eaec5d3cd9dac5" translate="yes" xml:space="preserve">
          <source>It is an improvement over CommonJS modules because:</source>
          <target state="translated">它比CommonJS模块有进步,因为。</target>
        </trans-unit>
        <trans-unit id="730c4225b2d0d3fb0671ef8fe3e3739ed1d33110" translate="yes" xml:space="preserve">
          <source>It is an improvement over the web's current &quot;globals and script tags&quot; because:</source>
          <target state="translated">它比网络目前的 &quot;globals和脚本标签 &quot;有所改进,因为。</target>
        </trans-unit>
        <trans-unit id="e91de952b822a7b9e601878fa68d2f21c35e3658" translate="yes" xml:space="preserve">
          <source>It is best if there is an &lt;strong&gt;&quot;opt-in&quot; call&lt;/strong&gt; that can be done so that older JS code can participate in the new system.</source>
          <target state="translated">最好是可以进行&lt;strong&gt;&amp;ldquo;选择加入&amp;rdquo;调用&lt;/strong&gt;，以便较早的JS代码可以参与新系统。</target>
        </trans-unit>
        <trans-unit id="5366afdcae21e6c4f1d44ccd61b7c663f948c522" translate="yes" xml:space="preserve">
          <source>It is best to set the baseUrl specifically to the directory containing the module, so that it works properly when nested inside a node_modules heirarchy. Use the synchronous &lt;code&gt;requirejs('moduleId')&lt;/code&gt; to fetch the module using the config and rules in requirejs, then use Node's module.exports to export your module value:</source>
          <target state="translated">最好将baseUrl专门设置为包含模块的目录，以便嵌套在node_modules层次结构中时可以正常工作。使用 &lt;code&gt;requirejs('moduleId')&lt;/code&gt; 通过requirejs中的配置和规则获取模块，然后使用Node的module.exports导出模块值：</target>
        </trans-unit>
        <trans-unit id="36bb237f110735ba5fbb00d5eb1f96f64c6d37d5" translate="yes" xml:space="preserve">
          <source>It is harder to debug. Firebug and WebKit's inspector have an //@ sourceURL= convention, which helps give a name to evaled text, but this support is not universal across browsers.</source>
          <target state="translated">这就更难调试了。Firebug和WebKit的检查器有一个//@ sourceURL=的约定,这有助于给评估过的文本命名,但这种支持在各浏览器中并不通用。</target>
        </trans-unit>
        <trans-unit id="9c87d9d9b05b11c9ab9a66ebf5b60f1a510690bd" translate="yes" xml:space="preserve">
          <source>It is nice to build HTML using regular HTML tags, instead of building up DOM structures in script. However, there is no good way to embed HTML in a JavaScript file. The best that can be done is using a string of HTML, but that can be hard to manage, particularly for multi-line HTML.</source>
          <target state="translated">使用常规的HTML标签来构建HTML,而不是在脚本中构建DOM结构是很好的。然而,没有一个好的方法可以将HTML嵌入到JavaScript文件中。最好的办法是使用一串HTML,但这可能很难管理,特别是对于多行HTML。</target>
        </trans-unit>
        <trans-unit id="d949986f91111b463d2e6c0b5b7a550aa5302d7b" translate="yes" xml:space="preserve">
          <source>It is possible when using RequireJS to load scripts quickly enough that they complete before the DOM is ready. Any work that tries to interact with the DOM should wait for the DOM to be ready. For modern browsers, this is done by waiting for the DOMContentLoaded event.</source>
          <target state="translated">在使用RequireJS时,可以快速加载脚本,使其在DOM准备好之前完成。任何试图与DOM交互的工作都应该等待DOM准备好。对于现代浏览器来说,这是通过等待DOMContentLoaded事件来完成的。</target>
        </trans-unit>
        <trans-unit id="539c0da90c417fc4465e8833119b2d4679e2ab07" translate="yes" xml:space="preserve">
          <source>It is tempting to use XMLHttpRequest (XHR) to load the scripts. If XHR is used, then we can massage the text above -- we can do a regexp to find require() calls, make sure we load those scripts, then use eval() or script elements that have their body text set to the text of the script loaded via XHR.</source>
          <target state="translated">很想使用XMLHttpRequest(XHR)来加载脚本。如果使用XHR,那么我们可以对上面的文本进行按摩--我们可以做一个regexp来找到require()调用,确保我们加载了这些脚本,然后使用eval()或脚本元素,将它们的主体文本设置为通过XHR加载的脚本文本。</target>
        </trans-unit>
        <trans-unit id="a5b8151a598bcb30cf8bfca9d33d4425d2cd203c" translate="yes" xml:space="preserve">
          <source>It makes debugging weird, line numbers will be off vs. the source file since the server is injecting a function wrapper.</source>
          <target state="translated">这让调试变得很奇怪,由于服务器注入了一个函数封装器,所以行号与源文件会有偏差。</target>
        </trans-unit>
        <trans-unit id="6d0cde0ae490de0408250a7f5a89a70bf23c8332" translate="yes" xml:space="preserve">
          <source>It requires extra tooling to substitute a set of script tags into one tag for optimized deployment.</source>
          <target state="translated">它需要额外的工具来将一组脚本标签替换成一个标签以优化部署。</target>
        </trans-unit>
        <trans-unit id="aaa2ddf75cd4a6f214f39c8e40c3d4e378c489b4" translate="yes" xml:space="preserve">
          <source>It requires more gear. Front-end development should be possible with static files.</source>
          <target state="translated">这需要更多的装备。前端开发应该可以用静态文件。</target>
        </trans-unit>
        <trans-unit id="b532c07e09af6445d4a57ec51df56d53e00a8d20" translate="yes" xml:space="preserve">
          <source>It will also optimize any CSS files it finds inside &lt;strong&gt;appdirectory-build&lt;/strong&gt;.</source>
          <target state="translated">它还会优化在&lt;strong&gt;appdirectory-build中&lt;/strong&gt;找到的所有CSS文件。</target>
        </trans-unit>
        <trans-unit id="1450cad84f11fb851a995a9dbe7cbd1a83b48017" translate="yes" xml:space="preserve">
          <source>It will not work, since jQuery registers itself with the name of 'jquery' and not 'lib/jquery'. In general, explicitly naming modules in the define() call are discouraged, but &lt;a href=&quot;https://github.com/requirejs/requirejs/wiki/Updating-existing-libraries#anon&quot;&gt;jQuery has some special constraints&lt;/a&gt;.</source>
          <target state="translated">由于jQuery使用'jquery'而不是'lib / jquery'的名称进行注册，因此无法使用。通常，不建议在define（）调用中显式命名模块，但是&lt;a href=&quot;https://github.com/requirejs/requirejs/wiki/Updating-existing-libraries#anon&quot;&gt;jQuery有一些特殊的约束&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8f07795f631a52c810ff74f35c0a35b8c0ee082f" translate="yes" xml:space="preserve">
          <source>It works better in the browser, it has the least amount of gotchas. Other approaches have problems with debugging, cross-domain/CDN usage, file:// usage and the need for server-specific tooling.</source>
          <target state="translated">它在浏览器中的效果更好,它的问题最少。其他方法存在调试、跨域/CDN使用、file://使用和需要服务器专用工具等问题。</target>
        </trans-unit>
        <trans-unit id="8f95e6bcde84bb0ea04bd5f126835d355217e942" translate="yes" xml:space="preserve">
          <source>LABjs: $LAB.script(&quot;some/module.js&quot;)</source>
          <target state="translated">LABjs:$LAB.script(&quot;some/module.js&quot;)</target>
        </trans-unit>
        <trans-unit id="ae0daafd2a22a2600ed4ab6dde4b770824eeb963" translate="yes" xml:space="preserve">
          <source>Later, when you want to add a specific translation to a file, say for the fr-fr locale, change my/nls/colors to look like so:</source>
          <target state="translated">之后,当你想在文件中添加一个特定的翻译时,比如说对于fr-fr语言,把my/nls/colors改成这样。</target>
        </trans-unit>
        <trans-unit id="a52b393d001eaf90fba4046093ec0e36ce9f892a" translate="yes" xml:space="preserve">
          <source>Latest Release: &lt;a href=&quot;http://requirejs.org/docs/download.html&quot;&gt;2.3.5&lt;/a&gt;Open source: &lt;a href=&quot;https://github.com/requirejs/requirejs/blob/master/LICENSE&quot;&gt;new BSD or MIT licensed&lt;/a&gt;web design by &lt;a href=&quot;http://andychung.me/&quot;&gt;Andy Chung&lt;/a&gt; &amp;copy; 2011-2017</source>
          <target state="translated">最新版本：&lt;a href=&quot;http://requirejs.org/docs/download.html&quot;&gt;2.3.5&lt;/a&gt;开源：&lt;a href=&quot;http://andychung.me/&quot;&gt;Andy Chung提供的&lt;/a&gt;&lt;a href=&quot;https://github.com/requirejs/requirejs/blob/master/LICENSE&quot;&gt;新的BSD或MIT许可的&lt;/a&gt;网页设计&amp;copy;2011-2017</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">根据麻省理工学院许可证授权。</target>
        </trans-unit>
        <trans-unit id="00849ea91859e8877efb5045590add6b11f850ad" translate="yes" xml:space="preserve">
          <source>Likely causes and fixes:</source>
          <target state="translated">可能的原因和解决方法。</target>
        </trans-unit>
        <trans-unit id="f3c97333b24770acd81169479f77c402aa695485" translate="yes" xml:space="preserve">
          <source>Load JavaScript Files</source>
          <target state="translated">加载JavaScript文件</target>
        </trans-unit>
        <trans-unit id="847b5a6fad771caed85029fc26f6dc8da0260706" translate="yes" xml:space="preserve">
          <source>Load timeout for modules: ...</source>
          <target state="translated">模块的加载超时:...</target>
        </trans-unit>
        <trans-unit id="f4ff6c36d65b86d4c62b59ce106dc00b3d1a41cb" translate="yes" xml:space="preserve">
          <source>Loader Plugins</source>
          <target state="translated">装载机插件</target>
        </trans-unit>
        <trans-unit id="b59783ddfeed5ace1aad0bc81fef1a12a200e068" translate="yes" xml:space="preserve">
          <source>Loader plugins are just another module, but they implement a specific API. Loader plugins can also participate in the optimizer optimizations, allowing the resources they load to be inlined in an optimized build.</source>
          <target state="translated">加载插件只是另一个模块,但它们实现了一个特定的API。加载器插件也可以参与优化器的优化,允许它们加载的资源在优化的构建中被内嵌。</target>
        </trans-unit>
        <trans-unit id="eb74610ba82fc6a40764893dfb647bab016b939f" translate="yes" xml:space="preserve">
          <source>Loading Code After Page Load</source>
          <target state="translated">在页面加载后加载代码</target>
        </trans-unit>
        <trans-unit id="97455076de06f78a61344dec31b7d67a23e3d804" translate="yes" xml:space="preserve">
          <source>Loading Modules from CommonJS Packages</source>
          <target state="translated">从CommonJS包中加载模块</target>
        </trans-unit>
        <trans-unit id="41818361eaa130c5f3db544fd1f348f224b034fa" translate="yes" xml:space="preserve">
          <source>Loading Modules from Packages</source>
          <target state="translated">从包中加载模块</target>
        </trans-unit>
        <trans-unit id="cae51c36493d810a681b4c1e453b557e06e4c4c2" translate="yes" xml:space="preserve">
          <source>Make sure you reference the network dependency as a module name, not as a full URL, so that it can be mapped to a different during the build:</source>
          <target state="translated">确保你将网络依赖关系引用为模块名称,而不是完整的 URL,这样它就可以在构建过程中被映射到不同的模块。</target>
        </trans-unit>
        <trans-unit id="72fdd266ec722bc44dd8a620ed1d7614b77d8c0f" translate="yes" xml:space="preserve">
          <source>Manual Conversion</source>
          <target state="translated">手动转换</target>
        </trans-unit>
        <trans-unit id="fc64c3825f362079a2271f22c7bab206e4b4ae90" translate="yes" xml:space="preserve">
          <source>Mapping Modules to use noConflict</source>
          <target state="translated">映射模块使用noConflict</target>
        </trans-unit>
        <trans-unit id="dc8cade7e5207678dc6256df2ecc9deb710e940d" translate="yes" xml:space="preserve">
          <source>Means that for any module except &quot;some/oldmodule&quot;, when &quot;foo&quot; is wanted, use &quot;foo1.2&quot; instead. For &quot;some/oldmodule&quot; only, use &quot;foo1.0&quot; when it asks for &quot;foo&quot;.</source>
          <target state="translated">意味着除了 &quot;some/oldmodule &quot;之外的任何模块,当需要 &quot;foo &quot;时,使用 &quot;foo1.2 &quot;代替。对于 &quot;some/oldmodule&quot;,当它要求输入 &quot;foo &quot;时,使用 &quot;foo1.0&quot;。</target>
        </trans-unit>
        <trans-unit id="d4a20ddcf46cb8976dc06ca7169ae206a255437c" translate="yes" xml:space="preserve">
          <source>Mechanics</source>
          <target state="translated">Mechanics</target>
        </trans-unit>
        <trans-unit id="01de199a77285acc2ed16e687ed574c8aaa94327" translate="yes" xml:space="preserve">
          <source>Mismatched anonymous define() modules ...</source>
          <target state="translated">不匹配的匿名定义()模块...。</target>
        </trans-unit>
        <trans-unit id="5d61c868611adf27496376e30ad6452373f98872" translate="yes" xml:space="preserve">
          <source>Module Definition</source>
          <target state="translated">模块定义</target>
        </trans-unit>
        <trans-unit id="4228b7603e50200006c8e380e2c2979ffdb82200" translate="yes" xml:space="preserve">
          <source>Module Name</source>
          <target state="translated">模块名称</target>
        </trans-unit>
        <trans-unit id="b73dbb3306e34de2871a62a55e786bcc07ac414a" translate="yes" xml:space="preserve">
          <source>Module Purposes</source>
          <target state="translated">模块目的</target>
        </trans-unit>
        <trans-unit id="f809bcc9566a363f7ba0c49a6077c47d41c5354c" translate="yes" xml:space="preserve">
          <source>Module name ... has not been loaded yet for context: ...</source>
          <target state="translated">模块名称...尚未加载上下文:...。</target>
        </trans-unit>
        <trans-unit id="1fceef3854242773f4046d420328f2e959bc28e6" translate="yes" xml:space="preserve">
          <source>Modules do not have to return objects. Any valid return value from a function is allowed. Here is a module that returns a function as its module definition:</source>
          <target state="translated">模块不一定要返回对象。允许使用任何有效的函数返回值。这里有一个模块,它的模块定义是返回一个函数。</target>
        </trans-unit>
        <trans-unit id="d57cb3f463693d791c21a168e01d847f563c16b7" translate="yes" xml:space="preserve">
          <source>Modules in CommonJS packages can be loaded by RequireJS by setting up the RequireJS configuration to know about the location and package attributes. See the &lt;a href=&quot;api#packages&quot;&gt;packages API section&lt;/a&gt; for more information.</source>
          <target state="translated">可以通过设置RequireJS配置以了解位置和包属性来由RequireJS加载CommonJS包中的模块。有关更多信息，请参见&lt;a href=&quot;api#packages&quot;&gt;包API部分&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="320708dab0d8587885e54e25dc4ae497a36bacab" translate="yes" xml:space="preserve">
          <source>Modules that define globals are explicitly discouraged, so that multiple versions of a module can exist in a page at a time (see &lt;strong&gt;Advanced Usage&lt;/strong&gt;). Also, the order of the function arguments should match the order of the dependencies.</source>
          <target state="translated">明确建议不要使用定义全局变量的模块，以便一次在一个页面中可以存在一个模块的多个版本（请参阅&lt;strong&gt;高级用法&lt;/strong&gt;）。同样，函数参数的顺序应与依赖项的顺序匹配。</target>
        </trans-unit>
        <trans-unit id="572cadc3a302f83a4dbd3c2a7cb42701a0b31b23" translate="yes" xml:space="preserve">
          <source>Modules that use conditional code to do a require call, like if(someCondition) require('a1') else require('a2');</source>
          <target state="translated">使用条件代码做require调用的模块,比如if(someCondition)require('a1')else require('a2')。</target>
        </trans-unit>
        <trans-unit id="e4fcd558836fffcd1fc66bb98d7e86b496b5b825" translate="yes" xml:space="preserve">
          <source>More details on the design forces and use cases for this function wrapping format, called Asynchronous Module Definition (AMD), can be found on the &lt;a href=&quot;whyamd&quot;&gt;Why AMD?&lt;/a&gt; page.</source>
          <target state="translated">&lt;a href=&quot;whyamd&quot;&gt;为何使用AMD？&lt;/a&gt;有关此功能包装格式的设计力量和用例的更多详细信息，称为异步模块定义（AMD），请参见。页。</target>
        </trans-unit>
        <trans-unit id="c0d889e70d00bbeffd76cf22134b56f52ddb2126" translate="yes" xml:space="preserve">
          <source>More information is available on the &lt;a href=&quot;commonjs&quot;&gt;CommonJS page&lt;/a&gt;, and in the &lt;a href=&quot;whyamd#sugar&quot;&gt;&quot;Sugar&quot; section in the Why AMD page&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;commonjs&quot;&gt;CommonJS页面&lt;/a&gt;，以及&lt;a href=&quot;whyamd#sugar&quot;&gt;&amp;ldquo;为什么选择AMD&amp;rdquo;页面&lt;/a&gt;的&amp;ldquo;糖&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="db89c3e1579783898093f507ce3545538718b599" translate="yes" xml:space="preserve">
          <source>Most CJS modules, around 95% based on my (thoroughly unscientific) personal experience, are perfectly compatible with the simplified CommonJS wrapping.</source>
          <target state="translated">大多数CJS模块,根据我的个人经验(彻底不科学),大约95%的模块都能完美兼容简化的CommonJS包装。</target>
        </trans-unit>
        <trans-unit id="e2aa6e69266afb5745d704808b26d494d039aaad" translate="yes" xml:space="preserve">
          <source>Most web developers use a function wrapper anyway, to avoid polluting the page with globals. Seeing a function wrapped around functionality is a very common sight and does not add to the reading cost of a module.</source>
          <target state="translated">反正大多数Web开发者都会使用函数封装器,避免用globals污染页面。看到一个函数包装的功能是很常见的景象,而且不会增加模块的阅读成本。</target>
        </trans-unit>
        <trans-unit id="90065a157b088d30c73a343e6ee438e960ff65f0" translate="yes" xml:space="preserve">
          <source>Multiversion Support</source>
          <target state="translated">多版本支持</target>
        </trans-unit>
        <trans-unit id="7ad300de5360e2dba7612bcbbdd15e356bb1266b" translate="yes" xml:space="preserve">
          <source>Named Modules</source>
          <target state="translated">已命名的模块</target>
        </trans-unit>
        <trans-unit id="41ec1d4b4042c78b4e5c776ec46fb5f1495c5fe4" translate="yes" xml:space="preserve">
          <source>Nashorn Support</source>
          <target state="translated">Nashorn支持</target>
        </trans-unit>
        <trans-unit id="865bc8f0637781f438fc8b01e57a8e62d66abea7" translate="yes" xml:space="preserve">
          <source>No define call for ...</source>
          <target state="translated">没有定义调用...</target>
        </trans-unit>
        <trans-unit id="e5a7a586589f9cf9aff0c28e1e027268d23cbfd9" translate="yes" xml:space="preserve">
          <source>No matching script interactive for ...</source>
          <target state="translated">没有匹配的脚本互动...</target>
        </trans-unit>
        <trans-unit id="e4c78dc7ccbc3875ab2f45f7d9dc57629a5b721b" translate="yes" xml:space="preserve">
          <source>Normally each run of a whole project optimization will delete the output build directory specified by &lt;strong&gt;dir&lt;/strong&gt; for cleanliness. Some build options, like &lt;strong&gt;onBuildWrite&lt;/strong&gt;, will modify the output directory in a way that is hazardous to do twice over the same files. However, if you are doing simple builds with no extra file transforms besides build layer minification, then you can set &lt;strong&gt;keepBuildDir&lt;/strong&gt; to &lt;code&gt;true&lt;/code&gt; to keep the build directory between runs. Then, only files that have changed between build runs will be copied.</source>
          <target state="translated">通常，整个项目优化的每次运行都会删除&lt;strong&gt;dir&lt;/strong&gt;指定的输出构建目录，以保持整洁。某些构建选项（例如&lt;strong&gt;onBuildWrite&lt;/strong&gt;）将以危险的方式修改输出目录，从而对同一文件执行两次。但是，如果您执行的是简单构建，并且除了&lt;strong&gt;最小化&lt;/strong&gt;构建层之外，没有其他文件转换，则可以将&lt;strong&gt;keepBuildDir&lt;/strong&gt;设置为 &lt;code&gt;true&lt;/code&gt; ,以在两次运行之间保留构建目录。然后，仅复制在两次构建运行之间已更改的文件。</target>
        </trans-unit>
        <trans-unit id="63637860d1b09a9a35884674fd6b92b4169d387b" translate="yes" xml:space="preserve">
          <source>Normally you should &lt;strong&gt;not&lt;/strong&gt; save optimized files with your pristine project source. Normally you would save them to a copy of your project, but to make this example easier it is saved with the source. Change the &lt;strong&gt;out=&lt;/strong&gt; option to any directory you like, that has a copy of your source. Then, you can change the main-built.js file name to just main.js so the HTML page will load the optimized version of the file.</source>
          <target state="translated">通常你应该&lt;strong&gt;不&lt;/strong&gt;保存优化后的文件与原始的项目源。通常，您会将它们保存到项目的副本中，但是为了使此示例更容易，它与源一起保存。将&lt;strong&gt;out =&lt;/strong&gt;选项更改为您喜欢的任何包含源副本的目录。然后，您可以将main-built.js文件名更改为main.js，以便HTML页面将加载文件的优化版本。</target>
        </trans-unit>
        <trans-unit id="5cd37647a9ff32456856beeb4b5a868e634c28ed" translate="yes" xml:space="preserve">
          <source>Normally you should not need to use require() to fetch a module, but instead rely on the module being passed in to the function as an argument. Circular dependencies are rare, and usually a sign that you might want to rethink the design. However, sometimes they are needed, and in that case, use require() as specified above.</source>
          <target state="translated">通常情况下,你不应该使用require()来获取一个模块,而是依靠模块作为参数被传递到函数中。循环依赖是很少见的,通常是一个信号,表明你可能需要重新思考设计。然而,有时它们是需要的,在这种情况下,使用上面指定的require()。</target>
        </trans-unit>
        <trans-unit id="55774be7c2eb30133e188a1e6f7e775499e3be75" translate="yes" xml:space="preserve">
          <source>Not all browsers give a usable Function.prototype.toString() results. As of October 2011, the PS 3 and older Opera Mobile browsers do not. Those browsers are more likely to need an optimized build of the modules for network/device limitations, so just do a build with an optimizer that knows how to convert these files to the normalized dependency array form, like the &lt;a href=&quot;optimization&quot;&gt;RequireJS optimizer&lt;/a&gt;.</source>
          <target state="translated">并非所有浏览器都提供可用的Function.prototype.toString（）结果。自2011年10月起，PS 3和较旧的Opera Mobile浏览器不再支持。那些浏览器更可能需要针对网络/设备限制进行模块优化的构建，因此只需使用知道如何将这些文件转换为标准化的依赖项数组形式的&lt;a href=&quot;optimization&quot;&gt;优化器&lt;/a&gt;（如RequireJS优化器）进行构建即可。</target>
        </trans-unit>
        <trans-unit id="00fcbd7ebdfa5c953e00172733331cfbb354ef3c" translate="yes" xml:space="preserve">
          <source>Note however if you want to get 404 load detection in IE so that you can use paths fallbacks or errbacks, then a string exports value should be given so the loader can check if the scripts actually loaded (a return from init is &lt;strong&gt;not&lt;/strong&gt; used for &lt;code&gt;enforceDefine&lt;/code&gt; checking):</source>
          <target state="translated">但是请注意，如果要在IE中进行404负载检测，以便可以使用路径后备或错误，则应提供字符串导出值，以便加载器可以检查脚本是否实际加载（init的返回&lt;strong&gt;不&lt;/strong&gt;用于 &lt;code&gt;enforceDefine&lt;/code&gt; 检查）：</target>
        </trans-unit>
        <trans-unit id="789188496a0ed139c37a18268d1d7e75613d29f9" translate="yes" xml:space="preserve">
          <source>Note that &quot;require&quot; is specified as a dependency for the module. This allows the require() function that is passed to the function callback to use the right context to load the modules correctly for multiversion support. If &quot;require&quot; is not specified as a dependency, then there will likely be an error.</source>
          <target state="translated">请注意,&quot;require &quot;被指定为模块的依赖关系,这使得传递给函数回调的require()函数能够使用正确的上下文来正确加载模块以支持多版本。这使得传递给函数回调的require()函数能够使用正确的上下文来正确加载模块以支持多版本。如果没有指定 &quot;require &quot;作为依赖关系,那么很可能会出现错误。</target>
        </trans-unit>
        <trans-unit id="a031cfd930d814fbea9159a6976e73d89cfd0031" translate="yes" xml:space="preserve">
          <source>Note this only works if &quot;module/name&quot; was previously loaded via the async version of require: &lt;code&gt;require([&quot;module/name&quot;])&lt;/code&gt;. If using a relative path, like './module/name', those only work inside define</source>
          <target state="translated">请注意，仅当先前通过require： &lt;code&gt;require([&quot;module/name&quot;])&lt;/code&gt; 的异步版本加载了&amp;ldquo; module / name&amp;rdquo;时，此方法才有效。如果使用相对路径，例如&amp;ldquo; ./module/name&amp;rdquo;，则这些仅在内部定义</target>
        </trans-unit>
        <trans-unit id="73d8d234ee45af790eb832ba8c7d6006b1416af0" translate="yes" xml:space="preserve">
          <source>Note: The url() path fixing will always fix the paths relative to the &lt;strong&gt;cssIn&lt;/strong&gt; build option path, not the &lt;strong&gt;out&lt;/strong&gt; build option.</source>
          <target state="translated">注意：url（）路径固定将始终固定相对于&lt;strong&gt;cssIn&lt;/strong&gt;构建选项路径的路径，而不是&lt;strong&gt;out&lt;/strong&gt;构建选项的路径。</target>
        </trans-unit>
        <trans-unit id="0c5badabbf2d099d71c93a7c71166c9738138220" translate="yes" xml:space="preserve">
          <source>Notice as part of that example, vendor libraries like jQuery did not have their version numbers in their file names. It is recommended to store that version info in a separate text file if you want to track it, or if you use a tool like &lt;a href=&quot;https://github.com/volojs/volo&quot;&gt;volo&lt;/a&gt;, it will stamp the package.json with the version information but keep the file on disk as &quot;jquery.js&quot;. This allows you to have the very minimal configuration instead of having to put an entry in the &quot;paths&quot; config for each library. For instance, configure &quot;jquery&quot; to be &quot;jquery-1.7.2&quot;.</source>
          <target state="translated">请注意，作为该示例的一部分，像jQuery这样的供应商库在文件名中没有其版本号。如果要跟踪版本信息，建议将其存储在单独的文本文件中，或者如果使用诸如&lt;a href=&quot;https://github.com/volojs/volo&quot;&gt;volo之&lt;/a&gt;类的工具，它将在package.json中标记版本信息，但将文件保留在磁盘上为&amp;ldquo; jquery&amp;rdquo;。 js&amp;rdquo;。这使您可以进行非常小的配置，而不必在每个库的&amp;ldquo;路径&amp;rdquo;配置中放置一个条目。例如，将&amp;ldquo; jquery&amp;rdquo;配置为&amp;ldquo; jquery-1.7.2&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="996ee768862a8be02370220efbb2ff9a6f2f8b5b" translate="yes" xml:space="preserve">
          <source>Notice that the above module does not declare a name for itself. This is what makes the module very portable. It allows a developer to place the module in a different path to give it a different ID/name. The AMD loader will give the module an ID based on how it is referenced by other scripts.</source>
          <target state="translated">请注意,上面的模块并没有为自己声明一个名字。这就是该模块非常可移植的原因。它允许开发者将模块放在不同的路径中,给它一个不同的ID/名称。AMD加载器会根据其他脚本对该模块的引用情况给它一个ID。</target>
        </trans-unit>
        <trans-unit id="993f59cc8fa52c4ddad7b03ed5bbcf3714d49d77" translate="yes" xml:space="preserve">
          <source>Now, when this page is loaded, the require() for &quot;main&quot; will load the main-built.js file. Since excludeShallow told it just to exclude two.js, two.js will still be loaded as a separate file, allowing you to see it as a separate file in the browser's debugger, so you can set breakpoints and better track its individual changes.</source>
          <target state="translated">现在,当加载这个页面时,&quot;main &quot;的require()会加载main-built.js文件。由于excludeShallow告诉它只是为了排除two.js,所以two.js仍然会被作为一个单独的文件加载,让你在浏览器的调试器中看到它作为一个单独的文件,这样你就可以设置断点,更好地跟踪它的各个变化。</target>
        </trans-unit>
        <trans-unit id="9a357ac26fa398f234d0d159a9d93322c7b4cb85" translate="yes" xml:space="preserve">
          <source>Once that optimization is done, you can change the script tag to reference &quot;main-built.js&quot; instead of &quot;require.js&quot;, and your optimized project will only need to make one script request.</source>
          <target state="translated">一旦优化完成,你可以更改脚本标签,引用 &quot;main-built.js &quot;而不是 &quot;require.js&quot;,你的优化项目只需要进行一次脚本请求。</target>
        </trans-unit>
        <trans-unit id="ef2b0cafc31915283c6f140afefded86a6a94d85" translate="yes" xml:space="preserve">
          <source>Once the build is done, you can use &lt;strong&gt;appdirectory-build&lt;/strong&gt; as your optimized project, ready for deployment.</source>
          <target state="translated">构建完成后，您可以将&lt;strong&gt;appdirectory-build&lt;/strong&gt;用作优化的项目，准备进行部署。</target>
        </trans-unit>
        <trans-unit id="687a77b17737ebb7701c40d0de5ac221cc75854d" translate="yes" xml:space="preserve">
          <source>Once your web app gets to a certain size and popularity, localizing the strings in the interface and providing other locale-specific information becomes more useful. However, it can be cumbersome to work out a scheme that scales well for supporting multiple locales.</source>
          <target state="translated">一旦你的网络应用达到一定的规模和知名度,在界面中对字符串进行本地化并提供其他特定于本地的信息就变得更加有用。然而,要制定一个能够很好地扩展支持多种语言的方案可能会很麻烦。</target>
        </trans-unit>
        <trans-unit id="6f5e918f3dd72c7755fe673e8aeaf5ae2e4034a2" translate="yes" xml:space="preserve">
          <source>One example: a plugin that needs to write out some utility functions at the beginning of a layer, as part of the first &lt;a href=&quot;#apiwrite&quot;&gt;write&lt;/a&gt; call, and the plugin needs to know when to reset the internal state to know when to write out the utilities for the next layer. If the plugin implements onLayerEnd, it can get notified when to reset its internal state.</source>
          <target state="translated">一个示例：作为第一个&lt;a href=&quot;#apiwrite&quot;&gt;write&lt;/a&gt;调用的一部分，一个插件需要在层的开头写出一些实用程序功能，并且该插件需要知道何时重置内部状态，才能知道何时为该实用程序写出实用程序。下一层。如果插件实现onLayerEnd，则可以在何时重置其内部状态时得到通知。</target>
        </trans-unit>
        <trans-unit id="136a30d6a64759ec55feda3ab1525a1a3b34d9e6" translate="yes" xml:space="preserve">
          <source>One of the criticisms of AMD, at least compared to CJS modules, is that it requires a level of indent and a function wrapping.</source>
          <target state="translated">至少与CJS模块相比,AMD的诟病之一是它需要一定程度的缩进和函数封装。</target>
        </trans-unit>
        <trans-unit id="425ce3199a0f68e5f26534c0cd5b7ecada23b956" translate="yes" xml:space="preserve">
          <source>Only execute the factory function once all the dependencies have been loaded and executed.</source>
          <target state="translated">只有当所有的依赖关系被加载并执行后,才能执行工厂函数。</target>
        </trans-unit>
        <trans-unit id="f5b213795860798e7ca26c8b8fd156f9d8034004" translate="yes" xml:space="preserve">
          <source>Only one version of a package can be used in a project context at a time. You can use RequireJS &lt;a href=&quot;#multiversion&quot;&gt;multiversion support&lt;/a&gt; to load two different module contexts, but if you want to use Package A and B in one context and they depend on different versions of Package C, then that will be a problem. This may change in the future.</source>
          <target state="translated">一次只能在项目上下文中使用软件包的一个版本。您可以使用RequireJS &lt;a href=&quot;#multiversion&quot;&gt;多版本支持&lt;/a&gt;来加载两个不同的模块上下文，但是如果要在一个上下文中使用程序包A和B，并且它们依赖于程序包C的不同版本，那么这将是一个问题。将来可能会改变。</target>
        </trans-unit>
        <trans-unit id="d03cab42295a0ef773cb4c58414926ae22c7f099" translate="yes" xml:space="preserve">
          <source>Only use other &quot;shim&quot; modules as dependencies for shimmed scripts, or AMD libraries that have no dependencies and call define() after they also create a global (like jQuery or lodash). Otherwise, if you use an AMD module as a dependency for a shim config module, after a build, that AMD module may not be evaluated until after the shimmed code in the build executes, and an error will occur. The ultimate fix is to upgrade all the shimmed code to have optional AMD define() calls.</source>
          <target state="translated">只有使用其他 &quot;shim &quot;模块作为shim化脚本的依赖,或者使用没有依赖的AMD库,并且在它们也创建了一个全局后调用define()(比如jQuery或lodash)。否则,如果你使用一个AMD模块作为shim配置模块的依赖,在构建之后,该AMD模块可能在构建中的shimmed代码执行之后才会被评估,并发生错误。最终的解决方法是将所有shimmed代码升级为具有可选的AMD define()调用。</target>
        </trans-unit>
        <trans-unit id="e52f63056d18f367435ae7f42b9e0e1b5ba47c94" translate="yes" xml:space="preserve">
          <source>Optimization Tool</source>
          <target state="translated">优化工具</target>
        </trans-unit>
        <trans-unit id="e1bf3840bdf455e89a6ccb39ca4b5ef36c34af9a" translate="yes" xml:space="preserve">
          <source>Optimizes CSS by inlining CSS files referenced by @import and removing comments.</source>
          <target state="translated">通过内联@import引用的CSS文件并删除注释来优化CSS。</target>
        </trans-unit>
        <trans-unit id="645afdfe1831be73caed431c4985960a8ed23da8" translate="yes" xml:space="preserve">
          <source>Optimizing a multi-page project</source>
          <target state="translated">优化多页项目</target>
        </trans-unit>
        <trans-unit id="94406643fcbc9130f67c3a7df6529a75a5308c56" translate="yes" xml:space="preserve">
          <source>Optimizing a whole project</source>
          <target state="translated">优化整个项目</target>
        </trans-unit>
        <trans-unit id="1b97e68f7e906d321f51c531c8135373f8051ae6" translate="yes" xml:space="preserve">
          <source>Optimizing one CSS file</source>
          <target state="translated">优化一个CSS文件</target>
        </trans-unit>
        <trans-unit id="2020d5670f6972dff09b1dce4b6069fedaf819dd" translate="yes" xml:space="preserve">
          <source>Optimizing one JavaScript file</source>
          <target state="translated">优化一个JavaScript文件</target>
        </trans-unit>
        <trans-unit id="a83a52c3fb590de0dc3104c9c47bccb368ae4538" translate="yes" xml:space="preserve">
          <source>Or better yet, use the shortened syntax that is available for use with &lt;a href=&quot;commonjs&quot;&gt;translating CommonJS&lt;/a&gt; modules:</source>
          <target state="translated">或&lt;a href=&quot;commonjs&quot;&gt;更妙的&lt;/a&gt;是，使用可用于翻译CommonJS模块的缩短的语法：</target>
        </trans-unit>
        <trans-unit id="439567bdbbd0efa69af61a769a5cca0a13682f69" translate="yes" xml:space="preserve">
          <source>Or there was a 404 error in IE where the script failed to load.</source>
          <target state="translated">或者是IE中出现404错误,脚本无法加载。</target>
        </trans-unit>
        <trans-unit id="902a0c43077fddb8868418fb133f6ea532f9cf74" translate="yes" xml:space="preserve">
          <source>Or use XMLHttpRequest (XHR) to load the text of modules and do text transforms/parsing in browser.</source>
          <target state="translated">或者使用XMLHttpRequest(XHR)来加载模块的文本,并在浏览器中进行文本转换/解析。</target>
        </trans-unit>
        <trans-unit id="0a8b90507f83c83d06c60ecc35f83f8e249ecaaf" translate="yes" xml:space="preserve">
          <source>Or was part of a &lt;a href=&quot;api#config-shim&quot;&gt;shim config&lt;/a&gt; that did not set a string value for the &lt;code&gt;exports&lt;/code&gt; config option.</source>
          <target state="translated">或者是未为 &lt;code&gt;exports&lt;/code&gt; config选项设置字符串值的&lt;a href=&quot;api#config-shim&quot;&gt;填充程序配置的&lt;/a&gt;一部分。</target>
        </trans-unit>
        <trans-unit id="49b8afea31aaecf8ff90dc1b9c1a2348f0ea7f7f" translate="yes" xml:space="preserve">
          <source>Or was part of a &lt;a href=&quot;api#config-shim&quot;&gt;shim config&lt;/a&gt; that specified a string &lt;code&gt;exports&lt;/code&gt; property that can be checked to verify loading, and that check failed.</source>
          <target state="translated">或者是&lt;a href=&quot;api#config-shim&quot;&gt;垫片配置的&lt;/a&gt;一部分，该垫片配置指定了可以检查以验证加载的字符串 &lt;code&gt;exports&lt;/code&gt; 属性，并且该检查失败。</target>
        </trans-unit>
        <trans-unit id="a720b152f92f2ac4f80f1d33c29f053ea00d9d62" translate="yes" xml:space="preserve">
          <source>Or, baseUrl can be set manually via the &lt;a href=&quot;#config&quot;&gt;RequireJS config&lt;/a&gt;. If there is no explicit config and data-main is not used, then the default baseUrl is the directory that contains the HTML page running RequireJS.</source>
          <target state="translated">或者，可以通过&lt;a href=&quot;#config&quot;&gt;RequireJS config&lt;/a&gt;手动设置baseUrl。如果没有显式配置且未使用data-main，则默认的baseUrl是包含运行RequireJS的HTML页面的目录。</target>
        </trans-unit>
        <trans-unit id="5e6e5c0ac606b77ee930fbf12aa3eaf2fba80c55" translate="yes" xml:space="preserve">
          <source>Or, do not set that paths or packages config and do the top level require call as &lt;code&gt;require(['compute/main'])&lt;/code&gt;.</source>
          <target state="translated">或者，不要设置路径或程序包配置，并且不要按 &lt;code&gt;require(['compute/main'])&lt;/code&gt; 的要求进行顶层调用。</target>
        </trans-unit>
        <trans-unit id="88494ce1c87ce2ac5b556e14476243360620b7de" translate="yes" xml:space="preserve">
          <source>Or, if it was inside a package or directory, say bar/foo.js:</source>
          <target state="translated">或者,如果它在一个包或目录里面,比如说bar/foo.js。</target>
        </trans-unit>
        <trans-unit id="c8545835771037daaa58fff1b8277d3939e13f00" translate="yes" xml:space="preserve">
          <source>Or, if the error shows up only in IE and not in other browsers (which may generate a &lt;a href=&quot;#scripterror&quot;&gt;Script error&lt;/a&gt;, the script probably:</source>
          <target state="translated">或者，如果错误仅在IE中显示，而不在其他浏览器中显示（这可能会产生&lt;a href=&quot;#scripterror&quot;&gt;Script错误&lt;/a&gt;，则该脚本可能是：</target>
        </trans-unit>
        <trans-unit id="29f29e827b24a3ffb1ab93d7db5bce55a6c4f1ce" translate="yes" xml:space="preserve">
          <source>Or, if you are using the dependency array approach, ask for the special &lt;a href=&quot;https://github.com/requirejs/requirejs/wiki/Differences-between-the-simplified-CommonJS-wrapper-and-standard-AMD-define#wiki-magic&quot;&gt;'exports' dependency:&lt;/a&gt;</source>
          <target state="translated">或者，如果您使用依赖项数组方法，则要求特殊的&lt;a href=&quot;https://github.com/requirejs/requirejs/wiki/Differences-between-the-simplified-CommonJS-wrapper-and-standard-AMD-define#wiki-magic&quot;&gt;&amp;ldquo;导出&amp;rdquo;依赖项：&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d44801d0d5cf3036fef8c533c5129460949cb61c" translate="yes" xml:space="preserve">
          <source>Or, in a &lt;a href=&quot;#wholeproject&quot;&gt;build profile&lt;/a&gt;:</source>
          <target state="translated">或者，在&lt;a href=&quot;#wholeproject&quot;&gt;构建配置文件中&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="dc0e1588bad559c25e336f4ce491e9bf9a9a02a1" translate="yes" xml:space="preserve">
          <source>Other Module Notes</source>
          <target state="translated">其他模块说明</target>
        </trans-unit>
        <trans-unit id="827ce3954d41bf64bd605c6e720e058b609bd8b9" translate="yes" xml:space="preserve">
          <source>Other notes:</source>
          <target state="translated">其他说明:</target>
        </trans-unit>
        <trans-unit id="66dbf063bcea03a792a7891f658c840f4e2eb8a5" translate="yes" xml:space="preserve">
          <source>Page Load Event Support/DOM Ready</source>
          <target state="translated">页面加载事件支持/DOM就绪</target>
        </trans-unit>
        <trans-unit id="9346ea1a2567e24e1999e03d291dbda3abc51506" translate="yes" xml:space="preserve">
          <source>Pass dependencies as an array of string values, do not grab globals.</source>
          <target state="translated">以字符串值数组的形式传递依赖关系,不要抓取 globals。</target>
        </trans-unit>
        <trans-unit id="0172d30c7aa6ed692ec90cac0a23592350107890" translate="yes" xml:space="preserve">
          <source>Pass the dependent modules as arguments to the factory function.</source>
          <target state="translated">将依赖的模块作为参数传递给工厂函数。</target>
        </trans-unit>
        <trans-unit id="0c6289bda156d08308bc76ef1a76402bbe7a9d41" translate="yes" xml:space="preserve">
          <source>Pass the main js file's &quot;require&quot; function in the configuration to requirejs.</source>
          <target state="translated">将配置中主js文件的 &quot;require &quot;函数传递给requirejs。</target>
        </trans-unit>
        <trans-unit id="98e5d7b826f13bc081a5c843c115d8bf9fcada6d" translate="yes" xml:space="preserve">
          <source>Path is not supported: ...</source>
          <target state="translated">不支持路径。...</target>
        </trans-unit>
        <trans-unit id="5fcfa1bf3e6a3af7d674727ac67b76e351e748ac" translate="yes" xml:space="preserve">
          <source>Plugin Names</source>
          <target state="translated">插件名称</target>
        </trans-unit>
        <trans-unit id="ab2e26dd8b8868a3969cb3321e0c983c0d9d67d4" translate="yes" xml:space="preserve">
          <source>Plugins</source>
          <target state="translated">Plugins</target>
        </trans-unit>
        <trans-unit id="76bd11a64888afb8cf5d2330679e774342f2f928" translate="yes" xml:space="preserve">
          <source>Plugins and pluginBuilders that run as part of the build process have a very limited environment. The optimizer runs in a few different JS environments. Be careful of the environment assumptions if you want the plugin to run as part of the optimizer.</source>
          <target state="translated">作为构建过程的一部分运行的插件和pluginBuilders的环境非常有限。优化器在一些不同的JS环境中运行。如果你想让插件作为优化器的一部分运行,请小心环境假设。</target>
        </trans-unit>
        <trans-unit id="a625e49b8ad0187e7c76b41bda6719cbf35d7410" translate="yes" xml:space="preserve">
          <source>Previously, we've been pointing to an example using a special require-jquery file, which consisted of require.js and jQuery concatenated. This is no longer the recommended way to use jQuery with require.js, but if you're looking for the (no longer maintained) example, &lt;a href=&quot;https://github.com/requirejs/require-jquery&quot;&gt;you can find require-jquery here&lt;/a&gt;.</source>
          <target state="translated">之前，我们一直在使用一个特殊的require-jquery文件指向一个示例，该文件由require.js和jQuery串联而成。这不再是将jQuery与require.js一起使用的推荐方法，但是如果您正在寻找（不再维护）示例，则&lt;a href=&quot;https://github.com/requirejs/require-jquery&quot;&gt;可以在此处找到require-jquery&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3ad33aa36988abe76a127defcbb28205f85bbb59" translate="yes" xml:space="preserve">
          <source>Reading code.</source>
          <target state="translated">阅读代码:</target>
        </trans-unit>
        <trans-unit id="8b982016d5900e602617c0bc1c12154c4598f912" translate="yes" xml:space="preserve">
          <source>References to dependencies are done via global variable names that were loaded via an HTML script tag.</source>
          <target state="translated">对依赖关系的引用是通过全局变量名完成的,这些变量名是通过HTML脚本标签加载的。</target>
        </trans-unit>
        <trans-unit id="7bcd6090618479458d2c3f424394bc8a8a5e7003" translate="yes" xml:space="preserve">
          <source>Register the factory function by calling define(), instead of immediately executing it.</source>
          <target state="translated">通过调用define()注册工厂函数,而不是立即执行它。</target>
        </trans-unit>
        <trans-unit id="0c284da9459af724aa990a40f8450015eebf6856" translate="yes" xml:space="preserve">
          <source>Relative paths are really useful if you are creating a few modules inside a directory, so that you can share the directory with other people or other projects, and you want to be able to get a handle on the sibling modules in that directory without having to know the directory's name.</source>
          <target state="translated">如果你在一个目录里面创建了几个模块,那么相对路径真的很有用,这样你就可以和其他人或者其他项目共享这个目录,而且你希望能够掌握这个目录中的兄弟模块,而不必知道这个目录的名字。</target>
        </trans-unit>
        <trans-unit id="94cf16b1d96cb308c10ddb10fa3d66e5787888fd" translate="yes" xml:space="preserve">
          <source>RequireJS</source>
          <target state="translated">RequireJS</target>
        </trans-unit>
        <trans-unit id="47ca39fabb6dc307dd72900d813b8a172134c35a" translate="yes" xml:space="preserve">
          <source>RequireJS API</source>
          <target state="translated">RequireJS API</target>
        </trans-unit>
        <trans-unit id="3aaf7cdebbaed3982494204c265ab9fb4280eca0" translate="yes" xml:space="preserve">
          <source>RequireJS Optimizer</source>
          <target state="translated">要求JS优化器</target>
        </trans-unit>
        <trans-unit id="a00ba25e980ea1a174cd4c549d1dbf710ce875d4" translate="yes" xml:space="preserve">
          <source>RequireJS allows you to set up a basic module that has localized information without forcing you to provide all locale-specific information up front. It can be added over time, and only strings/values that change between locales can be defined in the locale-specific file.</source>
          <target state="translated">RequireJS允许你设置一个具有本地化信息的基本模块,而不强迫你在前面提供所有特定于本地的信息。它可以随着时间的推移而添加,并且只有在不同语言之间变化的字符串/值可以在特定于本地的文件中定义。</target>
        </trans-unit>
        <trans-unit id="2d3408430dbcb8ac254a29b55d04664b14b6f1c6" translate="yes" xml:space="preserve">
          <source>RequireJS allows you to write loader plugins that can load different types of resources as dependencies, and even include the dependencies in optimized builds.</source>
          <target state="translated">RequireJS允许你编写加载器插件,可以加载不同类型的资源作为依赖,甚至在优化构建中包含依赖。</target>
        </trans-unit>
        <trans-unit id="42a94b06ecd72ce8db95c0857bd11078a76ac052" translate="yes" xml:space="preserve">
          <source>RequireJS also assumes by default that all dependencies are scripts, so it does not expect to see a trailing &quot;.js&quot; suffix on module IDs. RequireJS will automatically add it when translating the module ID to a path. With the &lt;a href=&quot;#config-paths&quot;&gt;paths config&lt;/a&gt;, you can set up locations of a group of scripts. All of these capabilities allow you to use smaller strings for scripts as compared to traditional &amp;lt;script&amp;gt; tags.</source>
          <target state="translated">默认情况下，RequireJS还假定所有依赖项均为脚本，因此，它不会在模块ID上看到尾随的&amp;ldquo; .js&amp;rdquo;后缀。在将模块ID转换为路径时，RequireJS将自动添加它。使用&lt;a href=&quot;#config-paths&quot;&gt;path config&lt;/a&gt;，您可以设置一组脚本的位置。与传统的&amp;lt;script&amp;gt;标记相比，所有这些功能都允许您为脚本使用较小的字符串。</target>
        </trans-unit>
        <trans-unit id="55e10b7ae48550ca2e079e5fb7385a105125bd42" translate="yes" xml:space="preserve">
          <source>RequireJS also combines bundles together, so for instance, if the french bundle was defined like so (omitting a value for red):</source>
          <target state="translated">RequireJS还可以将bundles组合在一起,例如,如果法语bundle是这样定义的(省略红色的值)。</target>
        </trans-unit>
        <trans-unit id="fccadba92d8e64d1c63a0ead823d420a25b4223b" translate="yes" xml:space="preserve">
          <source>RequireJS can be used in Rhino via the &lt;a href=&quot;http://requirejs.org/docs/download.html#rjs&quot;&gt;r.js adapter&lt;/a&gt;. See &lt;a href=&quot;https://github.com/requirejs/r.js/blob/master/README.html&quot;&gt;the r.js README&lt;/a&gt; for more information.</source>
          <target state="translated">RequireJS可以通过&lt;a href=&quot;http://requirejs.org/docs/download.html#rjs&quot;&gt;r.js适配器&lt;/a&gt;在Rhino中使用。有关更多信息，请参见&lt;a href=&quot;https://github.com/requirejs/r.js/blob/master/README.html&quot;&gt;r.js自述文件&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d54491027136cdb42cd2346edd319e96067f8363" translate="yes" xml:space="preserve">
          <source>RequireJS config options like map, packages, paths are only applied if RequireJS loads the module. If RequireJS needs to ask the node module system, the original ID is passed to Node. If you need a node module to work with a map config, inline define() calls work, as shown in &lt;a href=&quot;https://groups.google.com/forum/#!msg/requirejs/ur_UQLr04rc/sSpM8y87VNMJ&quot;&gt;this email list thread.&lt;/a&gt;</source>
          <target state="translated">仅当RequireJS加载模块时，才会应用诸如地图，程序包，路径之类的RequireJS配置选项。如果RequireJS需要询问节点模块系统，则将原始ID传递给Node。如果需要节点模块来处理地图配置，则内联define（）调用可以正常工作，如&lt;a href=&quot;https://groups.google.com/forum/#!msg/requirejs/ur_UQLr04rc/sSpM8y87VNMJ&quot;&gt;该电子邮件列表线程中所示。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a431a4070e33492518f70bd423f5abfd334b6755" translate="yes" xml:space="preserve">
          <source>RequireJS has a plugin, text.js, that can help with this issue. It will automatically be loaded if the text! prefix is used for a dependency. See the &lt;a href=&quot;https://github.com/requirejs/text&quot;&gt;text.js README&lt;/a&gt; for more information.</source>
          <target state="translated">RequireJS有一个插件text.js，可以帮助解决此问题。如果文本将自动加载！前缀用于依赖项。有关更多信息，请参见&lt;a href=&quot;https://github.com/requirejs/text&quot;&gt;text.js自述文件&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5677da00d1c14ead1e4adea4966177511c24f3dc" translate="yes" xml:space="preserve">
          <source>RequireJS has an optimization tool that can combine module definitions together into optimized bundles for browser delivery. It works as a command-line tool that you use as part of code deployment. See the &lt;a href=&quot;optimization&quot;&gt;optimization docs&lt;/a&gt; for more information.</source>
          <target state="translated">RequireJS有一个优化工具，可以将模块定义组合到优化的包中，以供浏览器交付。它充当命令行工具，您可以在代码部署中使用它。有关更多信息，请参见&lt;a href=&quot;optimization&quot;&gt;优化文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5ebed6cc24d0f8ed2a4a2bbd37a3e3109937f099" translate="yes" xml:space="preserve">
          <source>RequireJS has an optimization tool that does the following</source>
          <target state="translated">RequireJS有一个优化工具,它可以做到以下几点</target>
        </trans-unit>
        <trans-unit id="d2ae7c9c68ca1f789539282f1e0c6013fe1a4cab" translate="yes" xml:space="preserve">
          <source>RequireJS in Node</source>
          <target state="translated">Node中的RequireJS</target>
        </trans-unit>
        <trans-unit id="6c58998b40f6be8aaeb533c77012203955ebca3a" translate="yes" xml:space="preserve">
          <source>RequireJS in Node can only load modules that are on the local disk -- fetching modules across http, for instance, is not supported at this time.</source>
          <target state="translated">Node中的RequireJS只能加载本地磁盘上的模块--比如说跨http获取模块,目前还不支持。</target>
        </trans-unit>
        <trans-unit id="8789cfb66c2cb6baae8304b15d155ce3e4262022" translate="yes" xml:space="preserve">
          <source>RequireJS is also smart enough to pick the right locale bundle, the one that most closely matches the ones provided by my/nls/colors. For instance, if the locale is &quot;en-us&quot;, then the &quot;root&quot; bundle will be used. If the locale is &quot;fr-fr-paris&quot; then the &quot;fr-fr&quot; bundle will be used.</source>
          <target state="translated">RequireJS也很聪明,它可以选择正确的locale bundle,也就是与my/nls/colors提供的locale bundle最匹配的那个。例如,如果locale是 &quot;en-us&quot;,那么将使用 &quot;root &quot;捆绑包。如果locale是 &quot;fr-fr-paris&quot;,那么将使用 &quot;fr-fr &quot;捆绑包。</target>
        </trans-unit>
        <trans-unit id="2fb4604a5e20f298faa5c59ab7ab5a36c146a3d9" translate="yes" xml:space="preserve">
          <source>RequireJS loads all code relative to a &lt;a href=&quot;#config-baseUrl&quot;&gt;baseUrl&lt;/a&gt;. The baseUrl is normally set to the same directory as the script used in a data-main attribute for the top level script to load for a page. The &lt;a href=&quot;#data-main&quot;&gt;data-main attribute&lt;/a&gt; is a special attribute that require.js will check to start script loading. This example will end up with a baseUrl of &lt;strong&gt;scripts&lt;/strong&gt;:</source>
          <target state="translated">RequireJS加载相对于&lt;a href=&quot;#config-baseUrl&quot;&gt;baseUrl的&lt;/a&gt;所有代码。通常，将baseUrl设置为与data-main属性中使用的脚本相同的目录，以使顶级脚本加载页面。该&lt;a href=&quot;#data-main&quot;&gt;数据主要属性&lt;/a&gt;是一个特殊的属性，require.js将检查启动脚本加载。本示例将以&lt;strong&gt;脚本&lt;/strong&gt;的baseUrl结尾：</target>
        </trans-unit>
        <trans-unit id="e9589541f36d742283d0c596376a86ca39ac9ec7" translate="yes" xml:space="preserve">
          <source>RequireJS loads each dependency as a script tag, using head.appendChild().</source>
          <target state="translated">RequireJS使用head.appendChild()将每个依赖项作为脚本标签加载。</target>
        </trans-unit>
        <trans-unit id="673463710a9bd2155fd9748361e294a2190a5632" translate="yes" xml:space="preserve">
          <source>RequireJS supports &lt;a href=&quot;plugins&quot;&gt;loader plugins&lt;/a&gt;. This is a way to support dependencies that are not plain JS files, but are still important for a script to have loaded before it can do its work. The RequireJS wiki has &lt;a href=&quot;https://github.com/requirejs/requirejs/wiki/Plugins&quot;&gt;a list of plugins&lt;/a&gt;. This section talks about some specific plugins that are maintained alongside RequireJS:</source>
          <target state="translated">RequireJS支持&lt;a href=&quot;plugins&quot;&gt;加载程序插件&lt;/a&gt;。这是一种支持依赖关系的方法，该依赖关系不是普通的JS文件，但对于脚本在执行工作之前已加载仍然很重要。RequireJS Wiki有&lt;a href=&quot;https://github.com/requirejs/requirejs/wiki/Plugins&quot;&gt;一个插件列表&lt;/a&gt;。本节讨论与RequireJS一起维护的一些特定插件：</target>
        </trans-unit>
        <trans-unit id="6d58ff33f7bd1e7a83c19b7daf98cfdcff0a35f8" translate="yes" xml:space="preserve">
          <source>RequireJS supports loading modules that are in a &lt;a href=&quot;http://wiki.commonjs.org/wiki/Packages/1.1&quot;&gt;CommonJS Packages&lt;/a&gt; directory structure, but some additional configuration needs to be specified for it to work. Specifically, there is support for the following CommonJS Packages features:</source>
          <target state="translated">RequireJS支持加载&lt;a href=&quot;http://wiki.commonjs.org/wiki/Packages/1.1&quot;&gt;CommonJS Packages&lt;/a&gt;目录结构中的模块，但是需要指定一些其他配置才能使其正常工作。具体来说，它支持以下CommonJS Packages功能：</target>
        </trans-unit>
        <trans-unit id="b55dd4ac98c8bbc119acc87f176e4390a8c0ff91" translate="yes" xml:space="preserve">
          <source>RequireJS takes a different approach to script loading than traditional &amp;lt;script&amp;gt; tags. While it can also run fast and optimize well, the primary goal is to encourage modular code. As part of that, it encourages using &lt;strong&gt;module IDs&lt;/strong&gt; instead of URLs for script tags.</source>
          <target state="translated">与传统的&amp;lt;script&amp;gt;标记相比，RequireJS采用了不同的方法来加载脚本。尽管它还可以快速运行并优化得很好，但主要目标是鼓励使用模块化代码。作为其一部分，它鼓励使用&lt;strong&gt;模块ID&lt;/strong&gt;代替脚本标签的URL。</target>
        </trans-unit>
        <trans-unit id="6436c4e607871db5db8f8455a8e83d61e8df8f6a" translate="yes" xml:space="preserve">
          <source>RequireJS tries to keep with the spirit of CommonJS, with using string names to refer to dependencies, and to avoid modules defining global objects, but still allow coding a module format that works well natively in the browser. RequireJS implements the &lt;a href=&quot;http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition&quot;&gt;Asynchronous Module Definition&lt;/a&gt; (formerly Transport/C) proposal.</source>
          <target state="translated">RequireJS试图保持CommonJS的精神，使用字符串名称来引用依赖项，并避免模块定义全局对象，但仍允许编码在浏览器中本机运行良好的模块格式。RequireJS实现&lt;a href=&quot;http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition&quot;&gt;异步模块定义&lt;/a&gt;（以前称为Transport / C）建议。</target>
        </trans-unit>
        <trans-unit id="8f29b8502f5345425b66e5f08837d689a07333d6" translate="yes" xml:space="preserve">
          <source>RequireJS waits for all dependencies to load, figures out the right order in which to call the functions that define the modules, then calls the module definition functions once the dependencies for those functions have been called. Note that the dependencies for a given module definition function could be called in any order, due to their sub-dependency relationships and network load order.</source>
          <target state="translated">RequireJS等待所有的依赖关系加载完毕,计算出调用定义模块的函数的正确顺序,然后在调用了这些函数的依赖关系后调用模块定义函数。需要注意的是,由于子依赖关系和网络加载顺序的关系,某个模块定义函数的依赖关系可以以任何顺序被调用。</target>
        </trans-unit>
        <trans-unit id="8f0dfe99c16d5f457a6040729f397e4386f8b570" translate="yes" xml:space="preserve">
          <source>RequireJS will load the plugin module first, then pass the rest of the dependency name to a load() method on the plugin. There are also some methods to help with module name normalization and for making use of the plugin as part of the &lt;a href=&quot;optimization&quot;&gt;optimizer&lt;/a&gt;.</source>
          <target state="translated">RequireJS将首先加载插件模块，然后将其余依赖项名称传递给插件上的load（）方法。还有一些方法可以帮助模块名称标准化和将插件用作&lt;a href=&quot;optimization&quot;&gt;优化器的&lt;/a&gt;一部分。</target>
        </trans-unit>
        <trans-unit id="0a29bbde38e6f3231cde9d0379103efa2d21c69b" translate="yes" xml:space="preserve">
          <source>RequireJS will use &lt;strong&gt;baseUrl&lt;/strong&gt; to resolve the paths for any module names. The &lt;strong&gt;baseUrl&lt;/strong&gt; should be relative to &lt;strong&gt;appDir&lt;/strong&gt;.</source>
          <target state="translated">RequireJS将使用&lt;strong&gt;baseUrl&lt;/strong&gt;解析任何模块名称的路径。该&lt;strong&gt;的baseUrl&lt;/strong&gt;应该是相对于&lt;strong&gt;APPDIR&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="688bb14e2599e744cb6ca3a0873b76582ff0f536" translate="yes" xml:space="preserve">
          <source>RequireJS will use its &lt;a href=&quot;api#config&quot;&gt;Configuration Options&lt;/a&gt; first to find modules. If RequireJS cannot find the module with its configuration, it is assumed to be a module that uses Node's type of modules and configuration. So, only configure module locations with RequireJS if they use the RequireJS API. For modules that expect Node's APIs and configuration/paths, just install them with a Node package manager, like &lt;a href=&quot;http://npmjs.org/&quot;&gt;npm&lt;/a&gt;, and do not configure their locations with RequireJS.</source>
          <target state="translated">RequireJS将首先使用其&lt;a href=&quot;api#config&quot;&gt;配置选项&lt;/a&gt;来查找模块。如果RequireJS找不到具有其配置的模块，则假定该模块为使用Node的模块类型和配置的模块。因此，如果模块位置使用RequireJS API，则仅使用RequireJS配置模块位置。对于需要Node API和配置/路径的模块，只需使用Node软件包管理器（如&lt;a href=&quot;http://npmjs.org/&quot;&gt;npm）&lt;/a&gt;安装它们，而不用RequireJS配置它们的位置。</target>
        </trans-unit>
        <trans-unit id="7c839298d9c9623cb8e392c4497e969c4790ef6e" translate="yes" xml:space="preserve">
          <source>RequireJS will use the browser's navigator.languages, navigator.language or navigator.userLanguage property to determine what locale values to use for my/nls/colors, so your app does not have to change. If you prefer to set the locale, you can use the &lt;a href=&quot;#config-moduleconfig&quot;&gt;module config&lt;/a&gt; to pass the locale to the plugin:</source>
          <target state="translated">RequireJS将使用浏览器的navigator.languages，navigator.language或navigator.userLanguage属性来确定要用于my / nls / colors的语言环境值，因此您的应用程序不必更改。如果您希望设置语言环境，则可以使用&lt;a href=&quot;#config-moduleconfig&quot;&gt;模块配置&lt;/a&gt;将语言环境传递给插件：</target>
        </trans-unit>
        <trans-unit id="09a428f93ec07a73d726f8bd037ecacfaaf8b044" translate="yes" xml:space="preserve">
          <source>Requirements</source>
          <target state="translated">Requirements</target>
        </trans-unit>
        <trans-unit id="3f10ab66132d869b60a146832a0c5b877741a373" translate="yes" xml:space="preserve">
          <source>Rhino Support</source>
          <target state="translated">犀牛支持</target>
        </trans-unit>
        <trans-unit id="5cdeacc3fcee5a3d0cc852f72b086b0c1d3b1b46" translate="yes" xml:space="preserve">
          <source>Script Loading APIs</source>
          <target state="translated">脚本加载API</target>
        </trans-unit>
        <trans-unit id="dd7fe2e96e7ebbf0541153c92fa3cd3835838976" translate="yes" xml:space="preserve">
          <source>Script Loading: Web Workers</source>
          <target state="translated">脚本加载。网络工作者</target>
        </trans-unit>
        <trans-unit id="28c6a0f178110b7c5ee9c71b12d4ecc6644a0cba" translate="yes" xml:space="preserve">
          <source>Script Loading: XHR</source>
          <target state="translated">脚本加载。XHR</target>
        </trans-unit>
        <trans-unit id="806dde701e4839cc61a55b54f617f0476f1d3ee0" translate="yes" xml:space="preserve">
          <source>Script Loading: document.write()</source>
          <target state="translated">脚本加载:document.write()</target>
        </trans-unit>
        <trans-unit id="60346569fcbd6bf8b72d2ad70cffec0d959f65b5" translate="yes" xml:space="preserve">
          <source>Script Loading: head.appendChild(script)</source>
          <target state="translated">脚本加载:head.appendChild(script)</target>
        </trans-unit>
        <trans-unit id="db54505af4dab7b72398b3e7754b587c923bd562" translate="yes" xml:space="preserve">
          <source>Script error</source>
          <target state="translated">脚本错误</target>
        </trans-unit>
        <trans-unit id="6875cba1ccf3cfd56f772e1129de1d0c7afb8560" translate="yes" xml:space="preserve">
          <source>Script loading APIs</source>
          <target state="translated">脚本加载API</target>
        </trans-unit>
        <trans-unit id="31f0eeca69d93e11dcc7ab2a4e310b48538b63b1" translate="yes" xml:space="preserve">
          <source>Script loading: Web Workers</source>
          <target state="translated">脚本加载。网络工作者</target>
        </trans-unit>
        <trans-unit id="e9d88717ea3152125e41b249b9019556f13f241f" translate="yes" xml:space="preserve">
          <source>Script loading: XHR</source>
          <target state="translated">脚本加载。XHR</target>
        </trans-unit>
        <trans-unit id="59f54191b9255eb86b70dd4cc8c5871f655716d3" translate="yes" xml:space="preserve">
          <source>Script loading: document.write()</source>
          <target state="translated">脚本加载:document.write()</target>
        </trans-unit>
        <trans-unit id="22646269707ddc713b377c7499e8bd2b5f3d4a7b" translate="yes" xml:space="preserve">
          <source>Script loading: head.appendchild(script)</source>
          <target state="translated">脚本加载:head.appendchild(script)</target>
        </trans-unit>
        <trans-unit id="61c2152b82f1ea69ef3fd9c78b7ef62b9bc77399" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;https://github.com/requirejs/text&quot;&gt;text! plugin&lt;/a&gt; for an example of writeFile.</source>
          <target state="translated">看到&lt;a href=&quot;https://github.com/requirejs/text&quot;&gt;文字！&lt;/a&gt;用于writeFile示例的插件。</target>
        </trans-unit>
        <trans-unit id="40d3cc95499cba07de8b5028ea38fbb5a6869a5b" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;index&quot;&gt;API docs&lt;/a&gt; for more information on that syntax.</source>
          <target state="translated">有关该语法的更多信息，请参见&lt;a href=&quot;index&quot;&gt;API文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1e200d0bc7ac72dc2a3ed047bd78b5d5acaa6d8d" translate="yes" xml:space="preserve">
          <source>See the notes for the &lt;a href=&quot;#onejs&quot;&gt;Optimizing one JavaScript file&lt;/a&gt; about avoiding saving optimized files in your pristine source tree. It is only done here to make the example simpler.</source>
          <target state="translated">请参阅&amp;ldquo; &lt;a href=&quot;#onejs&quot;&gt;优化一个JavaScript文件&amp;rdquo;&lt;/a&gt;的注释，以避免在原始源代码树中保存优化文件。仅在此处进行操作以简化示例。</target>
        </trans-unit>
        <trans-unit id="c74306bac8e3a4dc448afdd8cae317b6caccd986" translate="yes" xml:space="preserve">
          <source>Setting Exported Value</source>
          <target state="translated">设置导出值</target>
        </trans-unit>
        <trans-unit id="e65edca48b8f7a17979616fa3db4cf39e464286e" translate="yes" xml:space="preserve">
          <source>Shallow exclusions for fast development</source>
          <target state="translated">快速发展的浅层次排除</target>
        </trans-unit>
        <trans-unit id="670595ae52d642feb7afce4692abba1e144a6acb" translate="yes" xml:space="preserve">
          <source>Shim config is not supported when running AMD modules in node via RequireJS (it works for optimizer use though). Depending on the module being shimmed, it may fail in Node because Node does not have the same global environment as browsers. As of RequireJS 2.1.7, it will warn you in the console that shim config is not supported, and it may or may not work. If you wish to suppress that message, you can pass &lt;code&gt;requirejs.config({ suppress: { nodeShim: true }});&lt;/code&gt;.</source>
          <target state="translated">通过RequireJS在节点中运行AMD模块时，不支持Shim config（尽管可用于优化程序）。根据所填充的模块，它可能在Node中失败，因为Node与浏览器没有相同的全局环境。从RequireJS 2.1.7开始，它将在控制台中警告您不支持shim config，并且它可能会或可能不会起作用。如果您希望 &lt;code&gt;requirejs.config({ suppress: { nodeShim: true }});&lt;/code&gt; 该消息，则可以传递requirejs.config（{reject：{nodeShim：true}}）;。</target>
        </trans-unit>
        <trans-unit id="e449b95be2fea702382b47ae55a5f9733158675f" translate="yes" xml:space="preserve">
          <source>Similarly, to avoid a bunch of configuration, it is best to avoid deep folder hierarchies for scripts, and instead either keep all the scripts in baseUrl, or if you want to separate your library/vendor-supplied code from your app code, use a directory layout like this:</source>
          <target state="translated">同样的,为了避免一堆配置,最好避免对脚本进行深层的文件夹分层,而是把所有的脚本都放在baseUrl中,如果你想把你的库/厂商提供的代码和你的应用代码分开,可以使用这样的目录布局。</target>
        </trans-unit>
        <trans-unit id="0632c0bc11dc47cc43ee33aff39b70f96ab057b5" translate="yes" xml:space="preserve">
          <source>Simple Name/Value Pairs</source>
          <target state="translated">简单的名称/数值对</target>
        </trans-unit>
        <trans-unit id="c430387334d60a570098cede5519da79215c2b16" translate="yes" xml:space="preserve">
          <source>Since &quot;require&quot; is a reserved dependency name, you create a &quot;requireLib&quot; dependency and map it to the require.js file.</source>
          <target state="translated">由于 &quot;require &quot;是一个保留的依赖名称,你可以创建一个 &quot;requireLib &quot;依赖并将其映射到require.js文件中。</target>
        </trans-unit>
        <trans-unit id="dc83d3c0ed853600c8e42ef6d4d34068151435ec" translate="yes" xml:space="preserve">
          <source>Since DOM ready is a common application need, ideally the nested functions in the API above could be avoided. The domReady module also implements the &lt;a href=&quot;plugins&quot;&gt;Loader Plugin API&lt;/a&gt;, so you can use the loader plugin syntax (notice the &lt;b&gt;!&lt;/b&gt; in the domReady dependency) to force the require() callback function to wait for the DOM to be ready before executing.</source>
          <target state="translated">由于DOM ready是常见的应用程序需求，因此理想情况下可以避免上面API中的嵌套函数。domReady模块还实现了&lt;a href=&quot;plugins&quot;&gt;Loader Plugin API&lt;/a&gt;，因此您可以使用loader插件语法（注意domReady依赖项中的&lt;b&gt;！&lt;/b&gt;）来强制require（）回调函数在执行之前等待DOM准备就绪。</target>
        </trans-unit>
        <trans-unit id="d0c10d513247ddb5f7d6111dfbb3f09b80b710d8" translate="yes" xml:space="preserve">
          <source>Since the number of browsers that cannot support this toString() scanning is very small, it is safe to use this sugared form for all your modules, particularly if you like to line up the dependency names with the variables that will hold their module values.</source>
          <target state="translated">由于不能支持这种toString()扫描的浏览器数量非常少,所以对你的所有模块使用这种sugared形式是安全的,特别是当你喜欢将依赖名称与持有其模块值的变量对齐时。</target>
        </trans-unit>
        <trans-unit id="52b854694bd5e5771964d6aeb56b3122adca21f7" translate="yes" xml:space="preserve">
          <source>So if you want to support Internet Explorer, catch load errors, and have modular code either through direct define() calls or shim config, always set &lt;b&gt;enforceDefine&lt;/b&gt; to be true. See the next section for an example.</source>
          <target state="translated">因此，如果要支持Internet Explorer，捕获负载错误并通过直接define（）调用或shim config获得模块化代码，请始终将&lt;b&gt;forcedDefine&lt;/b&gt;设置为true。有关示例，请参见下一部分。</target>
        </trans-unit>
        <trans-unit id="adb1e49d3b56382dbb3da8e1388589dbfdb6edd8" translate="yes" xml:space="preserve">
          <source>So it is very difficult with IE to allow both anonymous AMD modules, which are a core benefit of AMD modules, and reliable detect errors.</source>
          <target state="translated">所以在IE下,既要允许匿名AMD模块,这是AMD模块的核心优势,又要允许可靠的检测错误,这是非常困难的。</target>
        </trans-unit>
        <trans-unit id="ed198cdf72a10321f902977a45fe3402f281e373" translate="yes" xml:space="preserve">
          <source>So to reiterate, you will likely get an error if you refer to jQuery with another module name, like &lt;code&gt;'lib/jquery'&lt;/code&gt;. &lt;strong&gt;This example will not work&lt;/strong&gt;:</source>
          <target state="translated">因此，重申一下，如果使用其他模块名称（例如 &lt;code&gt;'lib/jquery'&lt;/code&gt; )引用jQuery，则可能会出现错误。&lt;strong&gt;这个例子不起作用&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="7584d5a05b7d1c094e8b77096a5d326613084abd" translate="yes" xml:space="preserve">
          <source>So we need to know the dependencies and make sure we load them before executing our script. The best way to do that is construct our module loading API with function wrappers. Like so:</source>
          <target state="translated">所以我们需要知道依赖关系,并确保在执行脚本之前加载它们。最好的方法是用函数包装器构建我们的模块加载API。像这样。</target>
        </trans-unit>
        <trans-unit id="ca7eb5272fcc04433bcc053cb2963d977963db96" translate="yes" xml:space="preserve">
          <source>So, the plugin's module name comes before the ! separator. The part after the ! separator is called the &lt;b&gt;resource name&lt;/b&gt;. The resource name may look like a normal module name. The plugin's module name can be any valid module name, so for instance, you could use a relative indicator:</source>
          <target state="translated">因此，插件的模块名称位于！之前。分隔器。之后的部分！分隔符称为&lt;b&gt;资源名称&lt;/b&gt;。资源名称可能看起来像普通的模块名称。插件的模块名称可以是任何有效的模块名称，因此，例如，您可以使用相对指示符：</target>
        </trans-unit>
        <trans-unit id="b4f91bdb0e1b0e40fff4debcd0fea22f1999f491" translate="yes" xml:space="preserve">
          <source>Solution</source>
          <target state="translated">Solution</target>
        </trans-unit>
        <trans-unit id="5b1c2f328244970b14a382cc8a349babf5b6d91c" translate="yes" xml:space="preserve">
          <source>Some environments do not allow eval().</source>
          <target state="translated">有些环境不允许使用eval()。</target>
        </trans-unit>
        <trans-unit id="07007bf416c3f4f988e538292cbda2590016887c" translate="yes" xml:space="preserve">
          <source>Some notes about using a pluginBuilder:</source>
          <target state="translated">关于使用pluginBuilder的一些注意事项。</target>
        </trans-unit>
        <trans-unit id="eec270a80e28815db46c4a348f8a91f7a7d65008" translate="yes" xml:space="preserve">
          <source>Some plugins may do an async operation in the browser, but opt to complete the resource load synchronously when run in Node/Nashorn. This is what the text plugin does. If you just want to run AMD modules and load plugin dependencies using &lt;a href=&quot;http://github.com/jrburke/amdefine&quot;&gt;amdefine&lt;/a&gt; in Node, those also need to complete synchronously to match Node's synchronous module system.</source>
          <target state="translated">某些插件可能在浏览器中执行异步操作，但是在Node / Nashorn中运行时选择同步完成资源加载。这就是文本插件的作用。如果您只想运行AMD模块并在Node中使用&lt;a href=&quot;http://github.com/jrburke/amdefine&quot;&gt;amdefine&lt;/a&gt;加载插件依赖性，则还需要同步完成以匹配Node的同步模块系统。</target>
        </trans-unit>
        <trans-unit id="f98e0c339cb5123126f2c87c4e5f5e975fbf4182" translate="yes" xml:space="preserve">
          <source>Some plugins may need to evaluate some JavaScript that was retrieved as text, and use that evaluated JavaScript as the value for the resource. There is a function off the onload() argument, &lt;strong&gt;onload.fromText()&lt;/strong&gt;, that can be used to evaluate the JavaScript. eval() is used by RequireJS to evaluate that JavaScript, and RequireJS will do the right work for any anonymous define() call in the evaluated text, and use that define() module as the value for the resource.</source>
          <target state="translated">一些插件可能需要评估一些以文本形式检索的JavaScript，并使用评估后的JavaScript作为资源的值。onload（）参数存在一个函数&lt;strong&gt;onload.fromText（）&lt;/strong&gt;，该函数可用于评估JavaScript。RequireJS使用eval（）评估该JavaScript，并且RequireJS将对评估文本中的任何匿名define（）调用进行正确的工作，并将define（）模块用作资源值。</target>
        </trans-unit>
        <trans-unit id="a77096861b93dda4c39daec387e1adc8966cb7b0" translate="yes" xml:space="preserve">
          <source>Some sort of #include/import/require</source>
          <target state="translated">某种 #include/import/require</target>
        </trans-unit>
        <trans-unit id="bd025dec7c9eed165679f96d5db69313b876152d" translate="yes" xml:space="preserve">
          <source>Some types of circular dependencies.</source>
          <target state="translated">循环依赖的一些类型。</target>
        </trans-unit>
        <trans-unit id="d937f64e544eafc99471358c2faba19abd5ae90a" translate="yes" xml:space="preserve">
          <source>Something similar is possible with paths config, but it is much wordier, and the paths config route does not allow loader plugin resource IDs in its configuration, since the paths config values are path segments, not IDs.</source>
          <target state="translated">类似的事情在路径配置中也可以实现,但要麻烦得多,路径配置路径不允许在配置中使用装载机插件资源ID,因为路径配置值是路径段,而不是ID。</target>
        </trans-unit>
        <trans-unit id="30e86ffbe954826823e73c12cfc55bea76005dff" translate="yes" xml:space="preserve">
          <source>Source maps</source>
          <target state="translated">源地图</target>
        </trans-unit>
        <trans-unit id="821968db542d3c05ea3a4f2fcda630b7acc0474b" translate="yes" xml:space="preserve">
          <source>Specify a JSONP Service Dependency</source>
          <target state="translated">指定JSONP服务的依赖性。</target>
        </trans-unit>
        <trans-unit id="578a43d52c70e40530d94cddc8363ce456449172" translate="yes" xml:space="preserve">
          <source>Specify a Text File Dependency</source>
          <target state="translated">指定文本文件的依赖性</target>
        </trans-unit>
        <trans-unit id="d76e7ed422b0495466015a46e070fb6f00448162" translate="yes" xml:space="preserve">
          <source>Starts with a &quot;/&quot;.</source>
          <target state="translated">以&quot;/&quot;开头。</target>
        </trans-unit>
        <trans-unit id="7e371c122fa82685d7671b68016968141187d2ec" translate="yes" xml:space="preserve">
          <source>Sugar</source>
          <target state="translated">Sugar</target>
        </trans-unit>
        <trans-unit id="8f97776b7c626d7c787bc588e92f2b2b737f5f55" translate="yes" xml:space="preserve">
          <source>Supported configuration options:</source>
          <target state="translated">支持的配置选项。</target>
        </trans-unit>
        <trans-unit id="1d3251f0fb778fe3a355e2f1674b59fed9ce6f5e" translate="yes" xml:space="preserve">
          <source>That config states: modules 'main', 'util', 'text' and 'text!template.html' will be found by loading module ID 'primary'. Module 'text!secondary.html' can be found by loading module ID 'secondary'.</source>
          <target state="translated">该配置说明:模块'main'、'util'、'text'和'text!template.html'可以通过加载模块ID'primary'找到。模块'text!secondary.html'可以通过加载模块ID'secondary'找到。</target>
        </trans-unit>
        <trans-unit id="66f7f17f0623e2b899f65569369b3f96996b2778" translate="yes" xml:space="preserve">
          <source>That type of module relies on attaching properties to the global object to export the module value, and it is difficult to declare dependencies with this model. The dependencies are assumed to be immediately available when this function executes. This limits the loading strategies for the dependencies.</source>
          <target state="translated">这种类型的模块依靠将属性附加到全局对象上来输出模块值,用这种模式很难声明依赖关系。假设当这个函数执行时,依赖关系是立即可用的。这就限制了依赖关系的加载策略。</target>
        </trans-unit>
        <trans-unit id="4b5f14ad5e1dddfd4e78fad824cde3595b71d76f" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;index!&lt;/b&gt; plugin could be written like so:</source>
          <target state="translated">该&lt;b&gt;指数！&lt;/b&gt;插件可以这样写：</target>
        </trans-unit>
        <trans-unit id="9079b459ee168c30bd095d64a00af0fccaf64255" translate="yes" xml:space="preserve">
          <source>The AMD execution model is better aligned with how ECMAScript Harmony modules are being specified. The CommonJS modules that would not work in an AMD wrapper will also not work as a Harmony module. AMD's code execution behavior is more future compatible.</source>
          <target state="translated">AMD执行模型与ECMAScript Harmony模块的指定方式更加一致。不能在AMD包装器中工作的CommonJS模块也将不能作为Harmony模块工作。AMD的代码执行行为更符合未来的要求。</target>
        </trans-unit>
        <trans-unit id="0ea1b57a9458b65d966c291b92a6e5f40f3e9499" translate="yes" xml:space="preserve">
          <source>The AMD format comes from wanting a module format that was better than today's &quot;write a bunch of script tags with implicit dependencies that you have to manually order&quot; and something that was easy to use directly in the browser. Something with good debugging characteristics that did not require server-specific tooling to get started. It grew out of Dojo's real world experience with using XHR+eval and wanting to avoid its weaknesses for the future.</source>
          <target state="translated">AMD的格式来自于希望有一种模块格式,它比今天的 &quot;写一堆带有隐式依赖关系的脚本标签,你必须手动排序 &quot;要好,而且是一种容易在浏览器中直接使用的东西。一些具有良好调试特性的东西,不需要服务器特定的工具就可以开始使用。它是在Dojo使用XHR+eval的实际经验中成长起来的,并希望在未来避免其弱点。</target>
        </trans-unit>
        <trans-unit id="c808a506a2b1a1d3a8441fd50fe8872a13558f0e" translate="yes" xml:space="preserve">
          <source>The AMD loader will parse out the require('') calls by using Function.prototype.toString(), then internally convert the above define call into this:</source>
          <target state="translated">AMD加载器将使用Function.prototype.toString()解析出require('')调用,然后在内部将上面的定义调用转换为这个。</target>
        </trans-unit>
        <trans-unit id="11a4dc84c9d70c7ea727b71031d89d8fdc9c59e5" translate="yes" xml:space="preserve">
          <source>The CJS module format only allowed one module per file, so a &quot;transport format&quot; would be used for bundling more than one module in a file for optimization/bundling purposes.</source>
          <target state="translated">CJS模块格式每个文件只允许一个模块,所以为了优化/捆绑的目的,会使用 &quot;传输格式 &quot;将多个模块捆绑在一个文件中。</target>
        </trans-unit>
        <trans-unit id="355c15d3884285cbe9de6e8c0623457a61fdc6ca" translate="yes" xml:space="preserve">
          <source>The Problem</source>
          <target state="translated">问题</target>
        </trans-unit>
        <trans-unit id="a39ad20def9de6ddadb36d4488aeb74ca38ea578" translate="yes" xml:space="preserve">
          <source>The RequireJS optimizer, as of version 1.0.3, will strip out the use of 'amdefine' above, so it is safe to use this module for your web-based projects too. Just be sure to use &lt;strong&gt;the exact 'amdefine' if() test and contents as shown above&lt;/strong&gt;. Differences in spaces/line breaks are allowed. See the &lt;a href=&quot;https://github.com/jrburke/amdefine&quot;&gt;amdefine project&lt;/a&gt; for more information.</source>
          <target state="translated">从1.0.3版开始，RequireJS优化器将取消上面的&amp;ldquo; amdefine&amp;rdquo;的使用，因此也可以将该模块用于基于Web的项目。只需确保使用&lt;strong&gt;完全如上所示的'amdefine'if（）测试和内容即可&lt;/strong&gt;。空格/换行符之间的差异是允许的。有关更多信息，请参见&lt;a href=&quot;https://github.com/jrburke/amdefine&quot;&gt;amdefine项目&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b330aa0f4d280892b5122f26adc82cf344b78ceb" translate="yes" xml:space="preserve">
          <source>The RequireJS syntax for modules allows them to be loaded as fast as possible, even out of order, but evaluated in the correct dependency order, and since global variables are not created, it makes it possible to &lt;a href=&quot;#multiversion&quot;&gt;load multiple versions of a module in a page&lt;/a&gt;.</source>
          <target state="translated">模块的RequireJS语法允许它们以尽可能快的速度加载，即使顺序混乱也可以，但是以正确的依赖关系顺序进行评估，并且由于未创建全局变量，因此可以&lt;a href=&quot;#multiversion&quot;&gt;在页面中加载模块的多个版本&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6ef05a888778e04dcbd6355136af94fe3f21ee10" translate="yes" xml:space="preserve">
          <source>The RequireJS wiki has a longer &lt;a href=&quot;https://github.com/requirejs/requirejs/wiki/Plugins&quot;&gt;list of plugins&lt;/a&gt;.</source>
          <target state="translated">RequireJS Wiki &lt;a href=&quot;https://github.com/requirejs/requirejs/wiki/Plugins&quot;&gt;的插件列表&lt;/a&gt;更长。</target>
        </trans-unit>
        <trans-unit id="10037c39cb0572d4517b7b19be7e3b6e476d3924" translate="yes" xml:space="preserve">
          <source>The Web Today</source>
          <target state="translated">今天的网络</target>
        </trans-unit>
        <trans-unit id="d6f95b126d877e46f4ca85d50dfc9f3c59e1b78b" translate="yes" xml:space="preserve">
          <source>The above AMD example works in all browsers. However, there is a risk of mismatched dependency names with named function arguments, and it can start to look a bit strange if your module has many dependencies:</source>
          <target state="translated">上述AMD的例子在所有浏览器中都能使用。然而,存在着依赖名称与命名的函数参数不匹配的风险,如果你的模块有很多依赖,它可能会看起来有点奇怪。</target>
        </trans-unit>
        <trans-unit id="ea71ad89663a3826e96822644f48226e30ddba03" translate="yes" xml:space="preserve">
          <source>The above pattern for detecting a load failure, undef()ing a module, modifying paths and reloading is a common enough request that there is also a shorthand for it. The paths config allows array values:</source>
          <target state="translated">上面的检测加载失败、undef()ing模块、修改路径和重载的模式是一个很常见的请求,所以也有一个简写。路径配置允许使用数组值。</target>
        </trans-unit>
        <trans-unit id="86f2b9664fdda056e416ecb6be7e43754e30ec9f" translate="yes" xml:space="preserve">
          <source>The baseUrl can be a URL on a different domain as the page that will load require.js. RequireJS script loading works across domains. The only restriction is on text content loaded by text! plugins: those paths should be on the same domain as the page, at least during development. The optimization tool will inline text! plugin resources so after using the optimization tool, you can use resources that reference text! plugin resources from another domain.</source>
          <target state="translated">baseUrl可以是与加载require.js的页面不同域的URL。RequireJS脚本加载可以跨域工作。唯一的限制是对text!插件加载的文本内容:这些路径应该和页面在同一个域上,至少在开发过程中是这样。优化工具会内嵌文本!插件资源,所以在使用优化工具后,你可以使用引用其他域的文本!插件资源。</target>
        </trans-unit>
        <trans-unit id="188d96d93a522f85db45464063c57eeed54c2581" translate="yes" xml:space="preserve">
          <source>The biggest time drain is minification. If you are just doing builds as part of a dev workflow, then set &lt;strong&gt;optimize&lt;/strong&gt; to &lt;code&gt;&quot;none&quot;&lt;/code&gt;.</source>
          <target state="translated">最大的时间流失是缩小。如果您只是在作为开发工作流程的一部分进行构建，则将&lt;strong&gt;optimize&lt;/strong&gt;设置为 &lt;code&gt;&quot;none&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="833cfb3d9133e355fe39d334558fdb889f46740f" translate="yes" xml:space="preserve">
          <source>The complete Plugin API:</source>
          <target state="translated">完整的插件API。</target>
        </trans-unit>
        <trans-unit id="fbf24dab70c96ad5b4a4111826b377d63c4b7d93" translate="yes" xml:space="preserve">
          <source>The contents of that file should look like so:</source>
          <target state="translated">该文件的内容应该是这样的。</target>
        </trans-unit>
        <trans-unit id="57689d439b992bc5af51a359d8f6310514b900ad" translate="yes" xml:space="preserve">
          <source>The data-main attribute is a special attribute that require.js will check to start script loading:</source>
          <target state="translated">data-main属性是一个特殊的属性,require.js将检查开始加载脚本。</target>
        </trans-unit>
        <trans-unit id="7f1d6700235d757014c048a09c5572615308e47e" translate="yes" xml:space="preserve">
          <source>The default for the optimizer is for &lt;strong&gt;preserveLicenseComments&lt;/strong&gt; to be true. So if using &lt;strong&gt;generateSourceMaps&lt;/strong&gt;, then explicitly set &lt;strong&gt;preserveLicenseComments&lt;/strong&gt; to false. If you want to preserve some license comments, you can manually modify the license comments in the JS source to use the JSDoc-style &lt;code&gt;@license&lt;/code&gt; comment. See &quot;&lt;a href=&quot;https://developers.google.com/closure/compiler/docs/js-for-compiler#tag-license&quot;&gt;Annotating JavaScript for the Closure Compiler&lt;/a&gt;&quot; for more information. That same format works for UglifyJS2.</source>
          <target state="translated">优化程序的默认值是&lt;strong&gt;keepLicenseComments&lt;/strong&gt;为true。因此，如果使用&lt;strong&gt;generateSourceMaps&lt;/strong&gt;，则将显式地将&lt;strong&gt;preserveLicenseComments&lt;/strong&gt;设置为false。如果要保留一些许可证注释，则可以在JS源代码中手动修改许可证注释以使用JSDoc样式的 &lt;code&gt;@license&lt;/code&gt; 注释。有关更多信息，请参见&amp;ldquo; &lt;a href=&quot;https://developers.google.com/closure/compiler/docs/js-for-compiler#tag-license&quot;&gt;为闭包编译器添加JavaScript注释&lt;/a&gt; &amp;rdquo;。相同的格式适用于UglifyJS2。</target>
        </trans-unit>
        <trans-unit id="ed208f1f847352477d5ff2c440d221d28e46603f" translate="yes" xml:space="preserve">
          <source>The default for the optimizer is to do the safest, most robust set of actions that avoid surprises after a build. However, depending on your project setup, you may want to turn off some of these features to get faster builds:</source>
          <target state="translated">优化器的默认值是做最安全、最稳健的一组动作,以避免在构建后出现意外。然而,根据您的项目设置,您可能希望关闭其中的一些功能,以获得更快的构建。</target>
        </trans-unit>
        <trans-unit id="7240c5ed21fca9b8654b10aeae53d76526350c3d" translate="yes" xml:space="preserve">
          <source>The dependencies are very weakly stated: the developer needs to know the right dependency order. For instance, The file containing Backbone cannot come before the jQuery tag.</source>
          <target state="translated">依赖关系的说明非常弱:开发者需要知道正确的依赖顺序。例如,包含Backbone的文件不能放在jQuery标签之前。</target>
        </trans-unit>
        <trans-unit id="61bd565a453f9fd7f3247103a42eaddea165cea4" translate="yes" xml:space="preserve">
          <source>The error object passed to errbacks and the global requirejs.onError function will usually contain two custom properties:</source>
          <target state="translated">传递给errbacks和全局requirejs.onError函数的错误对象通常会包含两个自定义属性。</target>
        </trans-unit>
        <trans-unit id="316bf166ecc014ef8bc6882e464ddfb3c066d80a" translate="yes" xml:space="preserve">
          <source>The example above in the &lt;strong&gt;Multiversion Support&lt;/strong&gt; section shows how code can later be loaded by nested require() calls.</source>
          <target state="translated">上面&amp;ldquo; &lt;strong&gt;Multiversion支持&amp;rdquo;&lt;/strong&gt;部分中的示例显示了以后如何通过嵌套的require（）调用来加载代码。</target>
        </trans-unit>
        <trans-unit id="2f906ca6df78eb04d4f2471e8af7277fa535310f" translate="yes" xml:space="preserve">
          <source>The examples in this page will assume you downloaded and saved r.js in a directory that is a sibling to your project directory. The optimizer that is part of r.js can live anywhere you want, but you will likely need to adjust the paths accordingly in these examples.</source>
          <target state="translated">本页中的例子将假设你下载并保存r.js在一个与你的项目目录同级的目录中。作为r.js一部分的优化器可以存在任何你想要的地方,但你可能需要在这些例子中相应地调整路径。</target>
        </trans-unit>
        <trans-unit id="63f1352f2a22f29f7eba80a7f07fe3640f7c41b3" translate="yes" xml:space="preserve">
          <source>The function call above specifies two arguments, &quot;cart&quot; and &quot;inventory&quot;. These are the modules represented by the &quot;./cart&quot; and &quot;./inventory&quot; module names.</source>
          <target state="translated">上面的函数调用指定了两个参数,&quot;cart &quot;和 &quot;inventory&quot;。这两个参数是由&quot;./cart &quot;和&quot;./inventory &quot;模块名代表的模块。</target>
        </trans-unit>
        <trans-unit id="ba297d0cdf6db0dcddbde4f96f4e5f762f3c8d6b" translate="yes" xml:space="preserve">
          <source>The function is not called until the my/cart and my/inventory modules have been loaded, and the function receives the modules as the &quot;cart&quot; and &quot;inventory&quot; arguments.</source>
          <target state="translated">在my/cart和my/inventory模块被加载之前,函数不会被调用,函数接收模块作为 &quot;cart &quot;和 &quot;inventory &quot;的参数。</target>
        </trans-unit>
        <trans-unit id="646d4a9744ff05859b5314213bf0fc732c97dc58" translate="yes" xml:space="preserve">
          <source>The general class of errors are 404s for scripts (not found), network timeouts or errors in the scripts that are loaded. RequireJS has a few tools to deal with them: require-specific errbacks, a &quot;paths&quot; array config, and a global requirejs.onError.</source>
          <target state="translated">一般一类错误是脚本的404s(未找到),网络超时或加载的脚本中的错误。RequireJS有一些工具来处理它们:require特定的errbacks,一个 &quot;paths &quot;数组配置,以及一个全局的requirejs.onError。</target>
        </trans-unit>
        <trans-unit id="e63c31bbc3167bcd297e7f2c00dc5d691b57b43a" translate="yes" xml:space="preserve">
          <source>The init function will &lt;strong&gt;not&lt;/strong&gt; be called for AMD modules. For example, you cannot use a shim init function to call jQuery's noConflict. See &lt;a href=&quot;jquery#noconflictmap&quot;&gt;Mapping Modules to use noConflict&lt;/a&gt; for an alternate approach to jQuery.</source>
          <target state="translated">对于AMD模块，&lt;strong&gt;不会&lt;/strong&gt;调用init函数。例如，您不能使用shim init函数来调用jQuery的noConflict。请参阅&lt;a href=&quot;jquery#noconflictmap&quot;&gt;映射模块以将noConflict&lt;/a&gt;用于jQuery的替代方法。</target>
        </trans-unit>
        <trans-unit id="79cd9e532bfc3f909ce1a7cd0b33b3a46f14bfc7" translate="yes" xml:space="preserve">
          <source>The modules that break are ones that do a dynamic calculation of a dependency, anything that does not use a string literal for the require() call, and anything that does not look like a declarative require() call. So things like this fail:</source>
          <target state="translated">破坏的模块是那些对依赖关系进行动态计算的模块,任何不使用字符串文字的 require()调用的模块,以及任何看起来不像声明式 require()调用的模块。所以像这样的事情都会失败。</target>
        </trans-unit>
        <trans-unit id="3015edf1d8929053306c224b7504d1c821a6e9f9" translate="yes" xml:space="preserve">
          <source>The my/lamps module has one property called &quot;testMessage&quot; that uses colors.red to show the localized value for the color red.</source>
          <target state="translated">my/lamps模块有一个名为 &quot;testMessage &quot;的属性,使用 colors.red来显示颜色红色的局部值。</target>
        </trans-unit>
        <trans-unit id="f2c2c7d55feef0ee5662cbb414805068c6cae379" translate="yes" xml:space="preserve">
          <source>The node module also exposes the RequireJS Optimizer as an &lt;strong&gt;optimize&lt;/strong&gt; method for using the &lt;a href=&quot;optimization&quot;&gt;RequireJS optimizer&lt;/a&gt; via a function call instead of a command line tool:</source>
          <target state="translated">节点模块还将RequireJS Optimizer作为&lt;strong&gt;优化&lt;/strong&gt;方法公开，以通过函数调用而不是命令行工具使用&lt;a href=&quot;optimization&quot;&gt;RequireJS优化器&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="6350be35e53443e7abedf9e1bacdc3773be517cd" translate="yes" xml:space="preserve">
          <source>The optimizer can be run using Node, Java with Rhino or Nashorn, or in the browser. The requirements for each option:</source>
          <target state="translated">该优化器可以使用Node、Java与Rhino或Nashorn,或在浏览器中运行。每个选项的要求。</target>
        </trans-unit>
        <trans-unit id="4d2c07d263378d0346f09b22f277d0d3e406cae7" translate="yes" xml:space="preserve">
          <source>The optimizer can take care of optimizing all the CSS and JS files in your project by using a build profile.</source>
          <target state="translated">优化器可以通过使用构建配置文件来处理优化项目中的所有CSS和JS文件。</target>
        </trans-unit>
        <trans-unit id="e9597937557a9085898a43c6059a1eebe7339fa9" translate="yes" xml:space="preserve">
          <source>The optimizer cannot load network resources, so if you want it included in the build, be sure to create a &lt;a href=&quot;api#config-paths&quot;&gt;paths config&lt;/a&gt; to map the file to a module name. Then, for running the optimizer, download the CDN script and pass a paths config to the optimizer that maps the module name to the local file path.</source>
          <target state="translated">优化器无法加载网络资源，因此，如果您希望将其包含在构建中，请确保创建&lt;a href=&quot;api#config-paths&quot;&gt;路径配置&lt;/a&gt;以将文件映射到模块名称。然后，要运行优化器，请下载CDN脚本，然后将路径配置传递给优化器，以将模块名称映射到本地文件路径。</target>
        </trans-unit>
        <trans-unit id="24dc87afb98a25d8ecbaf32f04ae2ac2d6d3a749" translate="yes" xml:space="preserve">
          <source>The optimizer has supported &lt;a href=&quot;https://blog.getfirebug.com/2009/08/11/give-your-eval-a-name-with-sourceurl/&quot;&gt;sourceURL&lt;/a&gt; (by setting &lt;strong&gt;useSourceUrl&lt;/strong&gt; to &lt;code&gt;true&lt;/code&gt;), for debugging combined modules as individual files. However, that only works with non-minified code. Source maps translate a minified file to a non-minified version. It does not make sense to use useSourceUrl with generateSourceMaps since useSourceUrl needs the source values as strings, which prohibits the useful minification done in combination with generateSourceMaps.</source>
          <target state="translated">优化器支持&lt;a href=&quot;https://blog.getfirebug.com/2009/08/11/give-your-eval-a-name-with-sourceurl/&quot;&gt;sourceURL&lt;/a&gt;（通过将&lt;strong&gt;useSourceUrl&lt;/strong&gt;设置为 &lt;code&gt;true&lt;/code&gt; ），用于将组合模块作为单个文件进行调试。但是，这仅适用于未缩小的代码。源映射将缩小的文件转换为非缩小的版本。将useSourceUrl与generateSourceMaps一起使用是没有意义的，因为useSourceUrl需要将源值作为字符串使用，这禁止了与generateSourceMaps一起进行的有用缩小。</target>
        </trans-unit>
        <trans-unit id="97adcb3e43739938bb0b24c540239f8776fdf70e" translate="yes" xml:space="preserve">
          <source>The optimizer is part of the &lt;a href=&quot;https://github.com/requirejs/r.js&quot;&gt;r.js adapter for Node and Nashorn&lt;/a&gt;, and it is designed to be run as part of a build or packaging step after you are done with development and are ready to deploy the code for your users.</source>
          <target state="translated">优化程序是&lt;a href=&quot;https://github.com/requirejs/r.js&quot;&gt;用于Node和Nashorn&lt;/a&gt;的r.js适配器的一部分，设计用于在完成开发并准备为用户部署代码后，将其作为构建或打包步骤的一部分运行。</target>
        </trans-unit>
        <trans-unit id="4dd7b81667d35089632d3cb2dbefac91d4924a99" translate="yes" xml:space="preserve">
          <source>The optimizer will only combine modules that are specified in arrays of string literals that are passed to top-level require and define calls, or the require('name') string literal calls in a &lt;a href=&quot;whyamd#sugar&quot;&gt;simplified CommonJS wrapping&lt;/a&gt;. So, it will not find modules that are loaded via a variable name:</source>
          <target state="translated">优化器将仅组合在传递给顶级require和define调用的字符串常量数组中指定的模块，或者使用&lt;a href=&quot;whyamd#sugar&quot;&gt;简化的CommonJS包装中&lt;/a&gt;的require（'name'）字符串常量调用。因此，它将找不到通过变量名称加载的模块：</target>
        </trans-unit>
        <trans-unit id="e736ee2d0486212242109d874b9057adc10b369e" translate="yes" xml:space="preserve">
          <source>The original &lt;a href=&quot;http://groups.google.com/group/commonjs&quot;&gt;CommonJS (CJS) list&lt;/a&gt; participants decided to work out a module format that worked with today's JavaScript language, but was not necessarily bound to the limitations of the browser JS environment. The hope was to use some stop-gap measures in the browser and hopefully influence the browser makers to build solutions that would enable their module format to work better natively. The stop-gap measures:</source>
          <target state="translated">最初的&lt;a href=&quot;http://groups.google.com/group/commonjs&quot;&gt;CommonJS（CJS）列表&lt;/a&gt;参与者决定制定一种可与当今的JavaScript语言一起使用的模块格式，但不一定受浏览器JS环境的限制。希望是在浏览器中使用一些权宜之计，并希望影响浏览器制造商构建解决方案，以使其模块格式在本机中更好地工作。权宜之计：</target>
        </trans-unit>
        <trans-unit id="23ffd664aad13e13f0e39499785339e02cc90784" translate="yes" xml:space="preserve">
          <source>The other (recommended) solution is to just name the file 'jquery.js' and place it in the baseUrl directory. Then the above paths entry is not needed.</source>
          <target state="translated">另一种(推荐)解决方案是将文件命名为'jquery.js'并将其放置在baseUrl目录下。这样就不需要上面的路径条目了。</target>
        </trans-unit>
        <trans-unit id="e8db7c7e84d06e02e54baf98a25cf84663fe34ff" translate="yes" xml:space="preserve">
          <source>The package config can specify the following properties for a specific package:</source>
          <target state="translated">包配置可以为特定的包指定以下属性。</target>
        </trans-unit>
        <trans-unit id="f7d157456a6adc4bf429c0462916d2f169f00d2d" translate="yes" xml:space="preserve">
          <source>The path configuration for a module is incorrect. Check the &quot;Net&quot; or &quot;Network&quot; tab in the browser's developer tools to see if there was a 404 for an URL that would map to the module name. Make sure the script file is in the right place. In some cases you may need to use the &lt;a href=&quot;api#config&quot;&gt;paths configuration&lt;/a&gt; to fix the URL resolution for the script.</source>
          <target state="translated">模块的路径配置不正确。检查浏览器开发人员工具中的&amp;ldquo;网络&amp;rdquo;或&amp;ldquo;网络&amp;rdquo;选项卡，以查看是否存在404映射到模块名称的URL。确保脚本文件在正确的位置。在某些情况下，您可能需要使用&lt;a href=&quot;api#config&quot;&gt;路径配置&lt;/a&gt;来修复脚本的URL解析。</target>
        </trans-unit>
        <trans-unit id="d86259d6a0a722e27d583979961ce1e8aa9945a9" translate="yes" xml:space="preserve">
          <source>The path that is used for a module name should &lt;strong&gt;not&lt;/strong&gt; include an extension, since the path mapping could be for a directory. The path mapping code will automatically add the .js extension when mapping the module name to a path. If &lt;a href=&quot;#modulenotes-urls&quot;&gt;require.toUrl()&lt;/a&gt; is used, it will add the appropriate extension, if it is for something like a text template.</source>
          <target state="translated">被用于模块名称应该路径&lt;strong&gt;不&lt;/strong&gt;包括扩展名，因为路径映射可能是一个目录。当将模块名称映射到路径时，路径映射代码将自动添加.js扩展名。如果使用了&lt;a href=&quot;#modulenotes-urls&quot;&gt;require.toUrl（）&lt;/a&gt;，它将添加适当的扩展名（如果用于文本模板）。</target>
        </trans-unit>
        <trans-unit id="4e91b10b7f7d53ba941c2c7e0e1bb6a153f797cb" translate="yes" xml:space="preserve">
          <source>The paths config was used to set two module IDs to the same file, and that file only has one anonymous module in it. If module IDs &quot;something&quot; and &quot;lib/something&quot; are both configured to point to the same &quot;scripts/libs/something.js&quot; file, and something.js only has one anonymous module in it, this kind of timeout error can occur. The fix is to make sure all module ID references use the same ID (either choose &quot;something&quot; or &quot;lib/something&quot; for all references), or use &lt;a href=&quot;api#config-map&quot;&gt;map config&lt;/a&gt;.</source>
          <target state="translated">路径配置用于将两个模块ID设置为同一文件，并且该文件中仅包含一个匿名模块。如果模块ID&amp;ldquo; something&amp;rdquo;和&amp;ldquo; lib / something&amp;rdquo;都配置为指向相同的&amp;ldquo; scripts / libs / something.js&amp;rdquo;文件，并且something.js中仅包含一个匿名模块，则可能会发生这种超时错误。解决方法是确保所有模块ID引用都使用相同的ID（为所有引用选择&amp;ldquo; something&amp;rdquo;或&amp;ldquo; lib / something&amp;rdquo;），或使用&lt;a href=&quot;api#config-map&quot;&gt;map config&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c0c55e2f25518ff91b12e2171a0f0a388d17bb4d" translate="yes" xml:space="preserve">
          <source>The precedence for config: command line, build profile, mainConfigFile. In other words, the mainConfigFile configuration has the lowest priority.</source>
          <target state="translated">配置的优先级:命令行、构建配置文件、mainConfigFile。换句话说,mainConfigFile配置的优先级最低。</target>
        </trans-unit>
        <trans-unit id="1242359748292937312acf98b1a6eb87d8a3b11f" translate="yes" xml:space="preserve">
          <source>The previous example with a concatenated require-jquery file</source>
          <target state="translated">前面的例子有一个连贯的require-jquery文件。</target>
        </trans-unit>
        <trans-unit id="192ab3acce5094758f21a50e14a8da17d6acde2e" translate="yes" xml:space="preserve">
          <source>The r.js optimizer is designed to offer some primitives that can be used for different deployment scenarios by adding other code on top of it. See the &lt;a href=&quot;https://github.com/requirejs/r.js/wiki/Deployment-Techniques&quot;&gt;deployment techniques wiki page&lt;/a&gt; for ideas on how to use the optimizer in that fashion.</source>
          <target state="translated">r.js优化器旨在通过在其之上添加其他代码来提供一些可用于不同部署方案的原语。有关如何以这种方式使用优化器的想法，请参阅&lt;a href=&quot;https://github.com/requirejs/r.js/wiki/Deployment-Techniques&quot;&gt;部署技术Wiki页面&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e2ee0d524bcd6704760b685962eeb8cfaff57213" translate="yes" xml:space="preserve">
          <source>The rest of this page assumes that r.js is just downloaded manually from the download page. It is normally the clearest, most portable way to use the optimizer.</source>
          <target state="translated">本页面其余部分假设为r.js,从下载页面手动下载即可。这通常是使用优化器最清晰、最便携的方式。</target>
        </trans-unit>
        <trans-unit id="ecf160a12aa61fb012a8b2424316d88aa0e4fd22" translate="yes" xml:space="preserve">
          <source>The return object from the function call defines the &quot;my/shirt&quot; module. By defining modules in this way, &quot;my/shirt&quot; does not exist as a global object.</source>
          <target state="translated">函数调用的返回对象定义了 &quot;my/shirt &quot;模块。通过这种方式定义模块,&quot;my/shirt &quot;不作为全局对象存在。</target>
        </trans-unit>
        <trans-unit id="0c88e63a484581ec383ad067c9875d460057af30" translate="yes" xml:space="preserve">
          <source>The shim config only sets up code relationships. To load modules that are part of or use shim config, a normal require/define call is needed. Setting shim by itself does not trigger code to load.</source>
          <target state="translated">shim config只设置了代码关系。如果要加载属于shim config的一部分或使用shim config的模块,需要进行正常的require/define调用。单独设置shim不会触发代码加载。</target>
        </trans-unit>
        <trans-unit id="5be64048efe7324abe49142f72faeeaaa7e1ca4a" translate="yes" xml:space="preserve">
          <source>The simplified CommonJS wrapper can be used in &lt;a href=&quot;https://addons.mozilla.org/en-US/developers/docs/sdk/1.1/&quot;&gt;Jetpack/Add-on SDK&lt;/a&gt; for Firefox</source>
          <target state="translated">简化的CommonJS包装器可以在Firefox的&lt;a href=&quot;https://addons.mozilla.org/en-US/developers/docs/sdk/1.1/&quot;&gt;Jetpack /附加SDK中&lt;/a&gt;使用</target>
        </trans-unit>
        <trans-unit id="286eeb9d4dd615a5ee96545dccd9adba277a55b2" translate="yes" xml:space="preserve">
          <source>The text! plugin implements write, to write out a string value for the text file that it loaded. A snippet from that file:</source>
          <target state="translated">text!插件实现了write,为它加载的文本文件写出一个字符串值。该文件的一个片段。</target>
        </trans-unit>
        <trans-unit id="c439d72b6a34f9f0ba042a5650c9c5ee79e4df55" translate="yes" xml:space="preserve">
          <source>The workaround is to just remove the space. This is fixed in the 2.0 code, and may be backported to the 1.0.x series if a 1.0.9 release is done.</source>
          <target state="translated">变通的办法是直接去掉空格。这在2.0的代码中已经修复,如果做1.0.9版本,可能会回传到1.0.x系列。</target>
        </trans-unit>
        <trans-unit id="9ec19343751911c72325582b0361861caae8236f" translate="yes" xml:space="preserve">
          <source>Then configure the HTML page to load the main-built.js file instead of main.js by configuring the path used for &quot;main&quot; to be &quot;main-built&quot;:</source>
          <target state="translated">然后配置HTML页面加载main-built.js文件,而不是main.js,将 &quot;main &quot;使用的路径配置为 &quot;main-built&quot;。</target>
        </trans-unit>
        <trans-unit id="259d26828f417e2f8c13bd0c6028af122d81b719" translate="yes" xml:space="preserve">
          <source>Then define a file at my/nls/fr-fr/colors.js that has the following contents:</source>
          <target state="translated">然后在my/nls/fr-fr/colors.js处定义一个文件,内容如下。</target>
        </trans-unit>
        <trans-unit id="be36ae0eb8667335a927273da0e6ab92b4edcb64" translate="yes" xml:space="preserve">
          <source>Then the RequireJS configuration would look like so:</source>
          <target state="translated">那么RequireJS的配置就会是这样的。</target>
        </trans-unit>
        <trans-unit id="a910327d077ce4eca13382ba87c8e201b1acd698" translate="yes" xml:space="preserve">
          <source>Then the optimizer will transform the above code sample to:</source>
          <target state="translated">然后,优化器会将上面的代码示例转化为。</target>
        </trans-unit>
        <trans-unit id="62170f7da0384f803f3a8eb7d89b68cf954fd553" translate="yes" xml:space="preserve">
          <source>Then the value for red in &quot;root&quot; will be used. This works for all locale pieces. If all the bundles listed below were defined, then RequireJS will use the values in the following priority order (the one at the top takes the most precedence):</source>
          <target state="translated">然后将使用 &quot;root &quot;中的红色值。这适用于所有的locale件。如果定义了下面列出的所有捆绑包,那么RequireJS将按照以下优先级顺序使用这些值(最上面的那个最优先)。</target>
        </trans-unit>
        <trans-unit id="f6cde8d9e24c8b9374a3bdc6f65bb6e76f868f68" translate="yes" xml:space="preserve">
          <source>Then, if you use the default optimize setting of &quot;uglify&quot; in r.js 0.26.0 or later, or if the &lt;b&gt;optimize&lt;/b&gt; setting is set to &quot;closure&quot; (when &lt;a href=&quot;https://github.com/requirejs/r.js&quot;&gt;run under Java&lt;/a&gt;), the minifier will optimize out the dead code branch! So you can do custom builds of your code that are optimized for a set of has() tests.</source>
          <target state="translated">然后，如果在r.js 0.26.0或更高版本中使用默认的优化设置&amp;ldquo; uglify&amp;rdquo;，或者如果将&lt;b&gt;优化&lt;/b&gt;设置设置为&amp;ldquo; closure&amp;rdquo;（&lt;a href=&quot;https://github.com/requirejs/r.js&quot;&gt;在Java下运行&lt;/a&gt;），则压缩程序将优化无效代码分支！因此，您可以为一系列has（）测试进行优化的自定义代码构建。</target>
        </trans-unit>
        <trans-unit id="1f0e546fbe705942eca29d67bf81ee3c8a7db75d" translate="yes" xml:space="preserve">
          <source>Then, when running the optimizer, use 'empty:' for the paths config:</source>
          <target state="translated">然后,在运行优化器时,使用'空:'来配置路径。</target>
        </trans-unit>
        <trans-unit id="00b6895c862979cc2eba13bb2a4e9203df3d2928" translate="yes" xml:space="preserve">
          <source>There are &lt;a href=&quot;https://github.com/requirejs/requirejs/wiki/Patterns-for-separating-config-from-the-main-module&quot;&gt;some patterns for separating the config from main module loading&lt;/a&gt;.</source>
          <target state="translated">有&lt;a href=&quot;https://github.com/requirejs/requirejs/wiki/Patterns-for-separating-config-from-the-main-module&quot;&gt;一些模式可以将配置与主模块加载分开&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c914c8913f0c704632585755ad2fd92421214c70" translate="yes" xml:space="preserve">
          <source>There are a small number of CommonJS modules do not work well as define()-wrapped modules. See the &lt;a href=&quot;https://github.com/requirejs/r.js&quot;&gt;r.js README&lt;/a&gt;</source>
          <target state="translated">少数CommonJS模块不能像define（）包裹的模块那样运行良好。请参阅&lt;a href=&quot;https://github.com/requirejs/r.js&quot;&gt;r.js自述文件&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="79d96503df59aae56b5b8ba278910ed073296911" translate="yes" xml:space="preserve">
          <source>There are also hidden costs with the CommonJS format:</source>
          <target state="translated">CommonJS格式也有隐性成本。</target>
        </trans-unit>
        <trans-unit id="b8e5d4466510ba561a8c62882157f7d3f3f8d4f6" translate="yes" xml:space="preserve">
          <source>There are some CommonJS systems, mainly Node, that allow setting the exported value by assigning the exported value as module.exports. That idiom is supported by RequireJS, but there is another, easier way -- just return the value from the function passed to &lt;strong&gt;define&lt;/strong&gt;:</source>
          <target state="translated">有一些CommonJS系统（主要是Node）允许通过将导出的值分配为module.exports来设置导出的值。RequireJS支持该习惯用法，但是还有另一种更简单的方法-只需从传递给&lt;strong&gt;define&lt;/strong&gt;的函数中返回值即可：</target>
        </trans-unit>
        <trans-unit id="db7bc183023059aacc1b28ac85497f6757932ed2" translate="yes" xml:space="preserve">
          <source>There are two ways to get the Node adapter:</source>
          <target state="translated">有两种方法可以获得Node适配器。</target>
        </trans-unit>
        <trans-unit id="f82b7a30d627e088df9f0dc5d7ebd9889f9e8c88" translate="yes" xml:space="preserve">
          <source>There is a &lt;strong&gt;limitation&lt;/strong&gt; on the command line argument syntax. Dots are viewed as object property separators, to allow something like &lt;code&gt;paths.jquery=lib/jquery&lt;/code&gt; to be transformed to the following in the optimizer:</source>
          <target state="translated">命令行参数语法有&lt;strong&gt;限制&lt;/strong&gt;。点被视为对象属性分隔符，以允许将 &lt;code&gt;paths.jquery=lib/jquery&lt;/code&gt; 之类的内容转换为优化器中的以下内容：</target>
        </trans-unit>
        <trans-unit id="49ed2d13d62753769d4a3e4b16bbff6caf763443" translate="yes" xml:space="preserve">
          <source>There is a bit more involved than just the above snippet, but that is the basic idea. This approach has the advantage over document.write in that it will not block page rendering and it works after page load.</source>
          <target state="translated">这里面涉及到的东西比上面的片段要多一些,但这是基本的想法。这种方法比document.write的优势在于它不会阻止页面渲染,而且在页面加载后也能工作。</target>
        </trans-unit>
        <trans-unit id="1195ff6977b15b525b4fb9026d68e10938839170" translate="yes" xml:space="preserve">
          <source>There is a global function, &lt;b&gt;requirejs.undef()&lt;/b&gt;, that allows undefining a module. It will reset the loader's internal state to forget about the previous definition of the module.</source>
          <target state="translated">有一个全局函数&lt;b&gt;requirejs.undef（）&lt;/b&gt;，它允许取消定义模块。它将重置加载程序的内部状态，以忽略模块的先前定义。</target>
        </trans-unit>
        <trans-unit id="19b7fe5cd5ae02fb158a358fbe1b88a6534c1ae6" translate="yes" xml:space="preserve">
          <source>There is also support for a &quot;*&quot; map value which means &quot;for all modules loaded, use this map config&quot;. If there is a more specific map config, that one will take precedence over the star config. Example:</source>
          <target state="translated">此外,还支持 &quot;*&quot;地图值,意思是 &quot;对于所有加载的模块,使用这个地图配置&quot;。如果有更特殊的地图配置,那将优先于星级配置。比如说:&quot;*&quot;map值是指 &quot;对于所有加载的模块,使用此map配置&quot;。</target>
        </trans-unit>
        <trans-unit id="cf8ab1380352baedf713333d3304b748679a3eaa" translate="yes" xml:space="preserve">
          <source>There is an &lt;a href=&quot;https://github.com/requirejs/r.js/blob/master/build/example.build.js&quot;&gt;example.build.js&lt;/a&gt; file in the requirejs/build directory that details all of the allowed optimizer configuration options.</source>
          <target state="translated">requirejs / build目录中有一个&lt;a href=&quot;https://github.com/requirejs/r.js/blob/master/build/example.build.js&quot;&gt;example.build.js&lt;/a&gt;文件，其中详述了所有允许的优化器配置选项。</target>
        </trans-unit>
        <trans-unit id="13a8e51faef4350fa51a39f9fddc9216e1cdff43" translate="yes" xml:space="preserve">
          <source>There may be times when you do want to reference a script directly and not conform to the &quot;baseUrl + paths&quot; rules for finding it. If a module ID has one of the following characteristics, the ID will not be passed through the &quot;baseUrl + paths&quot; configuration, and just be treated like a regular URL that is relative to the document:</source>
          <target state="translated">有些时候,你可能确实想直接引用一个脚本,而不符合 &quot;baseUrl+路径 &quot;的查找规则。如果一个模块ID具有以下特征之一,那么这个ID将不会通过 &quot;baseUrl+路径 &quot;的配置,而只是被当作一个相对于文档的普通URL。</target>
        </trans-unit>
        <trans-unit id="15a0d6c1171150ff1ab728d8563c6ef03f5aeb87" translate="yes" xml:space="preserve">
          <source>There should only be &lt;strong&gt;one&lt;/strong&gt; module definition per file on disk. The modules can be grouped into optimized bundles by the &lt;a href=&quot;optimization&quot;&gt;optimization tool&lt;/a&gt;.</source>
          <target state="translated">磁盘上每个文件应该只有&lt;strong&gt;一个&lt;/strong&gt;模块定义。可以使用&lt;a href=&quot;optimization&quot;&gt;优化工具&lt;/a&gt;将模块分组为优化的包。</target>
        </trans-unit>
        <trans-unit id="9aafa4f6a11dfb424aaf808dc827232de9516114" translate="yes" xml:space="preserve">
          <source>There should only be at most &lt;strong&gt;one IO action for each module&lt;/strong&gt;, and it should be straightforward. Web browsers are not tolerant of multiple IO lookups to find a module. This argues against the multiple path lookups that Node does now, and avoiding the use of a package.json &quot;main&quot; property. Just use module names that map easily to one location based on the project's location, using a reasonable default convention that does not require verbose configuration, but allow for simple configuration when needed.</source>
          <target state="translated">&lt;strong&gt;每个模块&lt;/strong&gt;最多只能有&lt;strong&gt;一个IO操作&lt;/strong&gt;，并且应该很简单。 Web浏览器不能忍受多个IO查找来查找模块。这与Node现在执行的多路径查找相抵触，并且避免了使用package.json&amp;ldquo; main&amp;rdquo;属性。只需使用一个合理的默认约定即可轻松地根据项目的位置映射到一个位置的模块名称，该约定不需要冗长的配置，但在需要时可以进行简单的配置。</target>
        </trans-unit>
        <trans-unit id="cdfa1e7131c14d32efb9df0bc08c01be59e54bd9" translate="yes" xml:space="preserve">
          <source>There was a script error in one of the listed modules. If there is no script error in the browser's error console, and if you are using Firebug, try loading the page in another browser like Chrome or Safari. Sometimes script errors do not show up in Firebug.</source>
          <target state="translated">在所列模块中,有一个脚本错误。如果在浏览器的错误控制台中没有脚本错误,而且你使用的是Firebug,请尝试在另一个浏览器(如Chrome或Safari)中加载页面。有时脚本错误不会在Firebug中显示出来。</target>
        </trans-unit>
        <trans-unit id="468caacfedf05ebd845bad705ed5482dfe20bd36" translate="yes" xml:space="preserve">
          <source>These are normally generated by the &lt;a href=&quot;optimization&quot;&gt;optimization tool&lt;/a&gt;. You can explicitly name modules yourself, but it makes the modules less portable -- if you move the file to another directory you will need to change the name. It is normally best to avoid coding in a name for the module and just let the optimization tool burn in the module names. The optimization tool needs to add the names so that more than one module can be bundled in a file, to allow for faster loading in the browser.</source>
          <target state="translated">这些通常是由&lt;a href=&quot;optimization&quot;&gt;优化工具&lt;/a&gt;生成的。您可以自己显式命名模块，但这会使模块的可移植性降低-如果将文件移动到另一个目录，则需要更改名称。通常最好避免为模块的名称编码，而让优化工具以模块名称进行刻录。优化工具需要添加名称，以便一个文件中可以捆绑多个模块，以允许在浏览器中更快地加载。</target>
        </trans-unit>
        <trans-unit id="98b4938725e5a5341b6305461362cc0477d874b0" translate="yes" xml:space="preserve">
          <source>These cases are handled by the &lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/require&quot;&gt;callback-require&lt;/a&gt;, &lt;code&gt;require([moduleName], function (){})&lt;/code&gt; normally present in AMD loaders.</source>
          <target state="translated">这些情况由AMD加载程序中通常存在的&lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/require&quot;&gt;callback-require&lt;/a&gt;， &lt;code&gt;require([moduleName], function (){})&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a79accd25478216f5822c8a4c6bf603479d9922e" translate="yes" xml:space="preserve">
          <source>These instructions assume an npm installation of 'requirejs'. If you are using the r.js file directly, replace require('requirejs') with require('./path/to/r.js'). Basic usage is:</source>
          <target state="translated">这些说明假设npm安装了'requirejs'。如果你直接使用r.js文件,用require('./path/to/r.js')代替require('requirejs')。基本用法是。</target>
        </trans-unit>
        <trans-unit id="16b53404d787cd045723983e31d60ff96d23db07" translate="yes" xml:space="preserve">
          <source>Thinking about the problem.</source>
          <target state="translated">思考问题。</target>
        </trans-unit>
        <trans-unit id="380032a22f9c26e6024b670111955c2798e616e2" translate="yes" xml:space="preserve">
          <source>This above code will try the CDN location, but if that fails, fall back to the local lib/jquery.js location.</source>
          <target state="translated">上面这段代码会尝试CDN的位置,但如果失败了,就退回到本地lib/jquery.js位置。</target>
        </trans-unit>
        <trans-unit id="49752fc8bf27c03316c7e59051f18837913b9909" translate="yes" xml:space="preserve">
          <source>This allows the loader to load dependency1 and dependency2 asynchronously, execute those dependencies, then execute this function.</source>
          <target state="translated">这使得加载器可以异步加载dependency1和dependency2,执行这些依赖关系,然后执行这个函数。</target>
        </trans-unit>
        <trans-unit id="9ddedef1b43d7b8525f6b0973e7a8d964d29e5e0" translate="yes" xml:space="preserve">
          <source>This allows you to build other optimization workflows, like &lt;a href=&quot;https://github.com/requirejs/r.js/tree/master/build/tests/http&quot;&gt;a web builder&lt;/a&gt; that can be used if you prefer to always develop with the &quot;one script file included before the &amp;lt;/body&amp;gt; tag&quot; approach. The optimizer running in Node is fairly fast, but for larger projects that do not want to regenerate the build for every browser request, but just if you modify a script that is part of the build. You could use Node's fs.watchFile() to watch files and then trigger the build when a file changes.</source>
          <target state="translated">这样，您就可以构建其他优化工作流，例如&lt;a href=&quot;https://github.com/requirejs/r.js/tree/master/build/tests/http&quot;&gt;Web构建器&lt;/a&gt;，如果您希望始终使用&amp;ldquo; &amp;lt;/ body&amp;gt;标记之前包含一个脚本文件&amp;rdquo;的方法进行开发，则可以使用该构建器。在Node中运行的优化器运行速度相当快，但是对于那些不想为每个浏览器请求重新生成构建文件的大型项目，只是您修改了构建脚本的一部分而已。您可以使用Node的fs.watchFile（）来监视文件，然后在文件更改时触发构建。</target>
        </trans-unit>
        <trans-unit id="3b65d4f771bf52e95454a2cd0ee5bb01541e3c07" translate="yes" xml:space="preserve">
          <source>This behavior allows dynamic loading of modules even after optimization. You can always explicitly add modules that are not found via the optimizer's static analysis by using the &lt;strong&gt;include&lt;/strong&gt; option.</source>
          <target state="translated">此行为允许动态加载模块，即使在优化之后也是如此。您始终可以使用&lt;strong&gt;include&lt;/strong&gt;选项来显式添加通过优化器的静态分析找不到的模块。</target>
        </trans-unit>
        <trans-unit id="7c2186e1d7918e19fbd7e4fbea3be0565cf286b9" translate="yes" xml:space="preserve">
          <source>This build profile tells RequireJS to copy all of &lt;strong&gt;appdirectory&lt;/strong&gt; to a sibling directory called &lt;strong&gt;appdirectory-build&lt;/strong&gt; and apply all the optimizations in the &lt;strong&gt;appdirectory-build&lt;/strong&gt; directory. It is strongly suggested you use a different output directory than the source directory -- otherwise bad things will likely happen as the optimizer overwrites your source.</source>
          <target state="translated">此构建配置文件告诉RequireJS将所有&lt;strong&gt;appdirectory&lt;/strong&gt;复制到一个名为&lt;strong&gt;appdirectory-build&lt;/strong&gt;的兄弟目录中，并在&lt;strong&gt;appdirectory-build&lt;/strong&gt;目录中应用所有优化。强烈建议您使用与源目录不同的输出目录-否则，当优化程序覆盖源时，可能会发生不良情况。</target>
        </trans-unit>
        <trans-unit id="75e9d0c26ff83452cfff825256989fd861112776" translate="yes" xml:space="preserve">
          <source>This can be difficult to manage on large projects, particularly as scripts start to have many dependencies in a way that may overlap and nest. Hand-writing script tags is not very scalable, and it leaves out the capability to load scripts on demand.</source>
          <target state="translated">这在大型项目中很难管理,特别是当脚本开始有很多依赖关系,可能会重叠和嵌套。手写脚本标签的可扩展性不强,而且它不具备按需加载脚本的能力。</target>
        </trans-unit>
        <trans-unit id="2f1d8dae4f31129d18ce4fad1393977e24dba9d8" translate="yes" xml:space="preserve">
          <source>This error may not show up in IE, just other browsers, and instead, in IE you may see the &lt;a href=&quot;#nodefine&quot;&gt;No define call for ...&lt;/a&gt; error when you see &quot;Script error&quot;. This is due to &lt;a href=&quot;api#ieloadfail&quot;&gt;IE's quirks in detecting script errors&lt;/a&gt;.</source>
          <target state="translated">该错误可能不会在IE中显示，而只会在其他浏览器中显示，相反，在IE中，当您看到&amp;ldquo;脚本错误&amp;rdquo;时，可能会看到&lt;a href=&quot;#nodefine&quot;&gt;No define call for ...&lt;/a&gt;错误。这是由于&lt;a href=&quot;api#ieloadfail&quot;&gt;IE在检测脚本错误方面的怪癖&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ea2ee18c32fb715b5f3e2c96e54faac7bfe81e43" translate="yes" xml:space="preserve">
          <source>This error occurs when the optimizer encounters a path to a module or script which is a network path. The optimizer only allows building with local resources. To fix it:</source>
          <target state="translated">当优化器遇到一个模块或脚本的路径是网络路径时,就会发生这个错误。优化器只允许使用本地资源进行构建。要修复它。</target>
        </trans-unit>
        <trans-unit id="108ce34bf7d5c20a79f2d5aa7de03e6a1873c06c" translate="yes" xml:space="preserve">
          <source>This error only shows up in some IE browsers. Most likely caused by loading a script that calls define() but was loaded in a plain script tag or via some other call, like an eval() of a JavaScript string.</source>
          <target state="translated">这个错误只出现在一些IE浏览器中。很可能是由于加载一个调用define()的脚本,但它是在一个普通的脚本标签中加载的,或者是通过其他调用,比如一个JavaScript字符串的eval()。</target>
        </trans-unit>
        <trans-unit id="de7406078370325ab6a57dde8efdcf94e3a45238" translate="yes" xml:space="preserve">
          <source>This example should illustrate the basic problem for the browser. Suppose we have an Employee object and we want a Manager object to derive from the Employee object. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Details_of_the_Object_Model#Creating_the_hierarchy&quot;&gt;Taking this example&lt;/a&gt;, we might code it up like this using our script loading API:</source>
          <target state="translated">此示例应说明浏览器的基本问题。假设我们有一个Employee对象，并且我们想从该Employee对象派生一个Manager对象。&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Details_of_the_Object_Model#Creating_the_hierarchy&quot;&gt;以这个示例为例&lt;/a&gt;，我们可以使用脚本加载API这样编写代码：</target>
        </trans-unit>
        <trans-unit id="8bfc2a8f38484617acf67685853c4317495387bb" translate="yes" xml:space="preserve">
          <source>This example shows how to use the &lt;a href=&quot;api#config-shim&quot;&gt;shim config&lt;/a&gt; to specify dependencies for jQuery plugins that do not call &lt;a href=&quot;api#define&quot;&gt;define()&lt;/a&gt;. This example is useful if you have an existing jQuery project you want to convert and do not want to modify the sources of the jQuery plugins to call define().</source>
          <target state="translated">此示例显示如何使用&lt;a href=&quot;api#config-shim&quot;&gt;shim配置&lt;/a&gt;为不调用&lt;a href=&quot;api#define&quot;&gt;define（）的&lt;/a&gt; jQuery插件指定依赖项。如果您有一个现有的jQuery项目要转换并且不想修改jQuery插件的源以调用define（），则此示例很有用。</target>
        </trans-unit>
        <trans-unit id="961683c2e345f519a690d1fef03102383240f8dc" translate="yes" xml:space="preserve">
          <source>This fails because requirejs needs to be sure to load and execute all dependencies before calling the factory function above. If a dependency array is given to define(), then requirejs assumes that all dependencies are listed in that array, and it will not scan the factory function for other dependencies. So, either do not pass in the dependency array, or if using the dependency array, list all the dependencies in it.</source>
          <target state="translated">这样做是失败的,因为 requirejs 需要确保在调用上面的工厂函数之前加载并执行所有的依赖关系。如果给define()提供了一个依赖关系数组,那么requirejs就会认为所有的依赖关系都列在这个数组中,它不会扫描工厂函数中的其他依赖关系。所以,要么不传入依赖数组,要么如果使用依赖数组,则列出其中所有的依赖。</target>
        </trans-unit>
        <trans-unit id="023d496162ffcb10b7cee76e6630652af2251947" translate="yes" xml:space="preserve">
          <source>This feature only works well for scripts that are real AMD modules that call define() and register as anonymous modules. Also, &lt;strong&gt;only use absolute module IDs&lt;/strong&gt; for map config. Relative IDs (like &lt;code&gt;'../some/thing'&lt;/code&gt;) do not work.</source>
          <target state="translated">此功能仅适用于是真正的AMD模块的脚本，这些脚本调用define（）并注册为匿名模块。另外，&lt;strong&gt;仅对&lt;/strong&gt;映射配置&lt;strong&gt;使用绝对模块ID&lt;/strong&gt;。相对ID（例如 &lt;code&gt;'../some/thing'&lt;/code&gt; ）不起作用。</target>
        </trans-unit>
        <trans-unit id="59e2e5874b3bfece421a8bffb9d4f0bc76a33cd1" translate="yes" xml:space="preserve">
          <source>This form will use Function.prototype.toString() to find the require() calls, and add them to the dependency array, along with &quot;require&quot;, so the code will work correctly with relative paths.</source>
          <target state="translated">这个表单将使用Function.prototype.toString()找到require()调用,并将它们和 &quot;require &quot;一起添加到依赖关系数组中,这样代码就能正确地使用相对路径。</target>
        </trans-unit>
        <trans-unit id="e8ed70de90f1dd1e9ab06535ec8d2f6b33f8586d" translate="yes" xml:space="preserve">
          <source>This function also contains a property function, &lt;b&gt;write.asModule(moduleName, fileName, text)&lt;/b&gt;. asModule can be used to write out a module that may have an anonymous define call in there that needs name insertion or/and contains implicit require(&quot;&quot;) dependencies that need to be pulled out for the optimized file.</source>
          <target state="translated">此函数还包含属性函数&lt;b&gt;write.asModule（moduleName，fileName，text）&lt;/b&gt;。asModule可用于写出一个模块，该模块中可能需要名称插入或/和包含隐式的require（&amp;ldquo;&amp;rdquo;）依赖关系的匿名定义调用，该依赖关系需要针对优化文件进行提取。</target>
        </trans-unit>
        <trans-unit id="07d2cf725c69b1eebada5d75140b90dfb091161d" translate="yes" xml:space="preserve">
          <source>This functionality should not be used for long-polling JSONP connections -- APIs that deal with real time streaming. Those kinds of APIs should do more script cleanup after receiving each response, and RequireJS will only fetch a JSONP URL once -- subsequent uses of the same URL as a dependency in a require() or define() call will get a cached value.</source>
          <target state="translated">这个功能不应该被用于长时间的JSONP连接--处理实时流的API。这些类型的API应该在接收到每个响应后做更多的脚本清理,而RequireJS只会获取一次JSONP URL --随后在require()或define()调用中使用相同的URL作为依赖,将得到一个缓存值。</target>
        </trans-unit>
        <trans-unit id="e89c5e06d3af4319ae091f80dd3551a4bc45ff27" translate="yes" xml:space="preserve">
          <source>This is an example on how to load an optimize your code while loading jQuery from a &lt;a href=&quot;http://en.wikipedia.org/wiki/Content_delivery_network&quot;&gt;Content Delivery Network&lt;/a&gt; (CDN). This example requires all your jQuery plugins to call &lt;a href=&quot;api#define&quot;&gt;define()&lt;/a&gt; to properly express their dependencies. &lt;a href=&quot;api#config-shim&quot;&gt;Shim config&lt;/a&gt; does not work after optimization builds with CDN resources.</source>
          <target state="translated">这是一个有关如何在从&lt;a href=&quot;http://en.wikipedia.org/wiki/Content_delivery_network&quot;&gt;Content Delivery Network&lt;/a&gt;（CDN）加载jQuery时加载优化代码的示例。这个例子要求您所有的jQuery插件都调用&lt;a href=&quot;api#define&quot;&gt;define（）&lt;/a&gt;来正确表达其依赖性。使用CDN资源进行优化构建后，&lt;a href=&quot;api#config-shim&quot;&gt;Shim配置&lt;/a&gt;不起作用。</target>
        </trans-unit>
        <trans-unit id="b4ccd67f04bf3d8be2fc0d6f03574cd28eb692e8" translate="yes" xml:space="preserve">
          <source>This is because the config settings for a build can be very different, with multiple optimization targets. So a separate set of config options need to be specified for the optimizer.</source>
          <target state="translated">这是因为一个build的config设置可能非常不同,有多个优化目标。所以需要为优化器单独指定一组配置选项。</target>
        </trans-unit>
        <trans-unit id="c08ad2236b0738d01b1e87a814f05cd47dfb7993" translate="yes" xml:space="preserve">
          <source>This is not possible with the &lt;a href=&quot;#multiversion&quot;&gt;context-backed multiversion support&lt;/a&gt;. In addition, the &lt;a href=&quot;#config-paths&quot;&gt;paths config&lt;/a&gt; is only for setting up root paths for module IDs, not for mapping one module ID to another one.</source>
          <target state="translated">使用&lt;a href=&quot;#multiversion&quot;&gt;上下文支持的多版本支持&lt;/a&gt;是不可能的。另外，&lt;a href=&quot;#config-paths&quot;&gt;路径配置&lt;/a&gt;仅用于设置模块ID的根路径，而不用于将一个模块ID映射到另一个模块。</target>
        </trans-unit>
        <trans-unit id="dbd4ac4ce622f942627879025300deca09f57bd3" translate="yes" xml:space="preserve">
          <source>This means that any module which uses jQuery will need to use the AMD return value rather than depending on the global $:</source>
          <target state="translated">这意味着,任何使用jQuery的模块都需要使用AMD的返回值,而不是依赖全局的$。</target>
        </trans-unit>
        <trans-unit id="660aa1bff65fdcc611a8965c59f57a351f6f7cd7" translate="yes" xml:space="preserve">
          <source>This occurs when enforceDefine is set to true, and a script that is loaded either:</source>
          <target state="translated">当 enforceDefine 被设置为 true 时,就会发生这种情况,而且加载的脚本要么。</target>
        </trans-unit>
        <trans-unit id="f289c4df7b00d5edd870e53e404ebd6b7af70cdb" translate="yes" xml:space="preserve">
          <source>This occurs when the script.onerror function is triggered in a browser. This usually means there is a JavaScript syntax error or other execution problem running the script. To fix it, examine the script that generated the error in a script debugger.</source>
          <target state="translated">这发生在浏览器中的script.onerror函数被触发时。这通常意味着运行脚本时出现了JavaScript语法错误或其他执行问题。要修复它,请在脚本调试器中检查产生错误的脚本。</target>
        </trans-unit>
        <trans-unit id="6aada266dc2b34a31cd1025b898441e43473ae95" translate="yes" xml:space="preserve">
          <source>This occurs when there is a call like:</source>
          <target state="translated">当有类似呼叫时,就会出现这种情况。</target>
        </trans-unit>
        <trans-unit id="928706501045c1df1973346d9b52dc67e9760f4b" translate="yes" xml:space="preserve">
          <source>This occurs when there is a require('name') call, but the 'name' module has not been loaded yet.</source>
          <target state="translated">这种情况发生在require('name')调用时,但'name'模块还没有被加载。</target>
        </trans-unit>
        <trans-unit id="d5a19ba0ac3512b99642760d7832ca4bbfdbf103" translate="yes" xml:space="preserve">
          <source>This only sets up where to find a module inside a script that has multiple define()'d modules in it. It does not automatically bind those modules to the bundle's module ID. The bundle's module ID is just used for locating the set of modules.</source>
          <target state="translated">这只是设置了在一个有多个 define()'d 模块的脚本中找到模块的位置。它不会自动将这些模块与 bundle 的模块 ID 绑定。bundle的模块ID只是用来定位模块的集合。</target>
        </trans-unit>
        <trans-unit id="5ff463f5c13219de083a5b986d24729b282c0b63" translate="yes" xml:space="preserve">
          <source>This option will install the latest release.</source>
          <target state="translated">此选项将安装最新版本。</target>
        </trans-unit>
        <trans-unit id="3080e3b4e7305b7a390be280a008f2efaa8b0dce" translate="yes" xml:space="preserve">
          <source>This page discusses why modules on the web are useful and the mechanisms that can be used on the web today to enable them. There is a separate page that talks about &lt;a href=&quot;whyamd&quot;&gt;the design forces&lt;/a&gt; for the particular function wrapped format used by RequireJS.</source>
          <target state="translated">此页面讨论了为什么Web上的模块有用的原因以及今天可以在Web上使用以启用它们的机制。在单独的页面上讨论了RequireJS使用的特定函数包装格式&lt;a href=&quot;whyamd&quot;&gt;的设计力&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5c32b7767b663c9b112dbfb1a72ec9435610f40c" translate="yes" xml:space="preserve">
          <source>This page lists errors that are generated by RequireJS. If the following information does not fix the problem, you can ask on the &lt;a href=&quot;https://groups.google.com/group/requirejs&quot;&gt;RequireJS list&lt;/a&gt; or &lt;a href=&quot;https://github.com/requirejs/requirejs/issues&quot;&gt;open an issue&lt;/a&gt;. In either case it is best to have an example or detailed explanation of the problem, hopefully with steps to reproduce.</source>
          <target state="translated">此页面列出了RequireJS生成的错误。如果以下信息不能解决问题，则可以在&lt;a href=&quot;https://groups.google.com/group/requirejs&quot;&gt;RequireJS列表&lt;/a&gt;上询问或&lt;a href=&quot;https://github.com/requirejs/requirejs/issues&quot;&gt;打开问题&lt;/a&gt;。无论哪种情况，最好都有一个示例或对该问题的详细解释，希望有重现步骤。</target>
        </trans-unit>
        <trans-unit id="d329b7fabff8549e3864ca1c943467a2e9c50ff6" translate="yes" xml:space="preserve">
          <source>This page talks about the design forces and use of the &lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/AMD&quot;&gt;Asynchronous Module Definition (AMD) API&lt;/a&gt; for JavaScript modules, the module API supported by RequireJS. There is a different page that talks about &lt;a href=&quot;why&quot;&gt;general approach to modules on the web&lt;/a&gt;.</source>
          <target state="translated">本页讨论了JavaScript模块（RequireJS支持的模块API &lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/AMD&quot;&gt;）&lt;/a&gt;的异步模块定义（AMD）API的设计力量和用法。在另一个页面上讨论&lt;a href=&quot;why&quot;&gt;了Web模块的一般方法&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a7547edb3cbad1a453ea3d817f5a0c1d8a4736ba" translate="yes" xml:space="preserve">
          <source>This sort of capability is really important for larger projects which may have two sets of modules that need to use two different versions of 'foo', but they still need to cooperate with each other.</source>
          <target state="translated">这种能力对于大型项目来说真的很重要,因为这些项目可能有两套模块,需要使用两个不同版本的'foo',但它们仍然需要相互合作。</target>
        </trans-unit>
        <trans-unit id="0667b0a681c9b05158e69aa153c3649764124d9b" translate="yes" xml:space="preserve">
          <source>This type of syntax was chosen because it is terse and allows the loader to use head.appendChild(script) type of loading.</source>
          <target state="translated">之所以选择这种类型的语法,是因为它很简洁,允许加载器使用head.appendChild(script)类型的加载。</target>
        </trans-unit>
        <trans-unit id="7fbbc6fb221c91b49f8258b96647211b9f95e5f7" translate="yes" xml:space="preserve">
          <source>This use of JSONP should be limited to JSONP services for initial application setup. If the JSONP service times out, it means other modules you define via define() may not get executed, so the error handling is not robust.</source>
          <target state="translated">JSONP的这种使用应该仅限于初始应用程序设置的JSONP服务。如果JSONP服务超时,意味着你通过define()定义的其他模块可能不会被执行,所以错误处理并不健壮。</target>
        </trans-unit>
        <trans-unit id="3c1fda79acd078a4d1f652fe39b9fd5add1ef63f" translate="yes" xml:space="preserve">
          <source>This will create a file called &lt;strong&gt;appdirectory/css/main-build.css&lt;/strong&gt; that will include the contents of main.css, have the url() paths properly adjusted, and have comments removed.</source>
          <target state="translated">这将创建一个名为&lt;strong&gt;appdirectory / css / main-build.css&lt;/strong&gt;的文件，该文件将包含main.css的内容，已正确调整url（）路径，并删除了注释。</target>
        </trans-unit>
        <trans-unit id="ef9cf9d96109395280b1d0122aae6bddc9d67c04" translate="yes" xml:space="preserve">
          <source>This will create a file called &lt;strong&gt;appdirectory/scripts/main-built.js&lt;/strong&gt; that will include the contents of main.js, one.js, two.js and three.js.</source>
          <target state="translated">这将创建一个名为&lt;strong&gt;appdirectory / scripts / main-built.js的文件&lt;/strong&gt;，其中将包含main.js，one.js，two.js和three.js的内容。</target>
        </trans-unit>
        <trans-unit id="a1edb6163d3cb5d334a5064291a25cbd6b030b50" translate="yes" xml:space="preserve">
          <source>This will instruct require.js to load scripts/main.js. &lt;strong&gt;main.js&lt;/strong&gt; uses the &quot;packages&quot; config to set up packages that are relative to require.js, which in this case are the source packages &quot;cart&quot; and &quot;store&quot;:</source>
          <target state="translated">这将指示require.js加载脚本/main.js。&lt;strong&gt;main.js&lt;/strong&gt;使用&amp;ldquo; packages&amp;rdquo;配置来设置相对于require.js的软件包，在这种情况下，它们是源软件包&amp;ldquo; cart&amp;rdquo;和&amp;ldquo; store&amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="6c5b1c3af64e803c47342d3ad7896c9f28af8c07" translate="yes" xml:space="preserve">
          <source>This wrapper relies on Function.prototype.toString() to give a useful string value of the function contents. This does not work on some devices like the PS3 and some older Opera mobile browsers. Use the &lt;a href=&quot;optimization&quot;&gt;optimizer&lt;/a&gt; to pull out the dependencies in the array format for use on those devices.</source>
          <target state="translated">该包装器依赖于Function.prototype.toString（）给出函数内容的有用字符串值。在某些设备（例如PS3和某些较旧的Opera移动浏览器）上，此功能不起作用。使用&lt;a href=&quot;optimization&quot;&gt;优化器&lt;/a&gt;以数组格式提取依赖项，以在这些设备上使用。</target>
        </trans-unit>
        <trans-unit id="4ea26143e34ae9633403f4fd5a98ac5694f88e74" translate="yes" xml:space="preserve">
          <source>Those IE behaviors result in &lt;a href=&quot;api#ieloadfail&quot;&gt;IE's quirks in detecting script errors&lt;/a&gt;.</source>
          <target state="translated">这些IE行为导致&lt;a href=&quot;api#ieloadfail&quot;&gt;IE检测脚本错误的怪癖&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ac488f97d42aa2e61a9ce4a064fafcf5bd478c2a" translate="yes" xml:space="preserve">
          <source>Threw a JavaScript syntax/evaluation error.</source>
          <target state="translated">抛出一个JavaScript语法/评价错误。</target>
        </trans-unit>
        <trans-unit id="96453b3268c65bdfaf0b098f61bbc13d247c2512" translate="yes" xml:space="preserve">
          <source>To avoid the error, be sure to load all scripts that call define via the RequireJS API.</source>
          <target state="translated">为了避免该错误,请确保加载所有通过RequireJS API调用define的脚本。</target>
        </trans-unit>
        <trans-unit id="45ed3d91f7409c8fcc6de93c3d7c8e6c0d28c524" translate="yes" xml:space="preserve">
          <source>To avoid the error:</source>
          <target state="translated">为了避免错误。</target>
        </trans-unit>
        <trans-unit id="b81ae61caebc13a78c16e37ec4312cbb3981bf52" translate="yes" xml:space="preserve">
          <source>To avoid verbosity, it is strongly suggested to always use packages that use &quot;main&quot; convention in their structure.</source>
          <target state="translated">为了避免啰嗦,强烈建议始终使用在结构上使用 &quot;main &quot;约定的软件包。</target>
        </trans-unit>
        <trans-unit id="530150d7bd05dc2c544154697dc2d2ab00652849" translate="yes" xml:space="preserve">
          <source>To define a bundle, put it in a directory called &quot;nls&quot; -- the i18n! plugin assumes a module name with &quot;nls&quot; in it indicates an i18n bundle. The &quot;nls&quot; marker in the name tells the i18n plugin where to expect the locale directories (they should be immediate children of the nls directory). If you wanted to provide a bundle of color names in your &quot;my&quot; set of modules, create the directory structure like so:</source>
          <target state="translated">要定义一个bundle,把它放在一个叫 &quot;nls &quot;的目录下--i18n!插件认为模块名中带 &quot;nls &quot;就表示一个i18n bundle。名称中的 &quot;nls &quot;标记会告诉i18n插件在哪里需要locale目录(它们应该是nls目录的直接子目录)。如果你想在你的 &quot;my &quot;模块集中提供一个颜色名称的捆绑,可以这样创建目录结构。</target>
        </trans-unit>
        <trans-unit id="5e288589ea56ef3a80663c84121f07a74a5ac771" translate="yes" xml:space="preserve">
          <source>To detect errors that are not caught by local errbacks, you can override requirejs.onError():</source>
          <target state="translated">要检测本地errbacks没有捕捉到的错误,你可以覆盖 requirejs.onError()。</target>
        </trans-unit>
        <trans-unit id="73a7dcc27c7d6f6895600c807abaff1dd3a1a4f4" translate="yes" xml:space="preserve">
          <source>To enable the source map generation, set &lt;strong&gt;generateSourceMaps&lt;/strong&gt; to &lt;code&gt;true&lt;/code&gt;. Since the minifier needs to have full control over the minified file to generate the source map, the &lt;strong&gt;preserveLicenseComments&lt;/strong&gt; should be explicitly set to &lt;code&gt;false&lt;/code&gt;. &lt;a href=&quot;errors#sourcemapcomments&quot;&gt;There is is a way to get some license comments in the minified source though&lt;/a&gt;.</source>
          <target state="translated">要启用源地图生成，请将&lt;strong&gt;generateSourceMaps&lt;/strong&gt;设置为 &lt;code&gt;true&lt;/code&gt; 。由于minifier需要有在缩小的文件完全控制生成源图，&lt;strong&gt;preserveLicenseComments&lt;/strong&gt;应明确设置为 &lt;code&gt;false&lt;/code&gt; 。&lt;a href=&quot;errors#sourcemapcomments&quot;&gt;不过，有一种方法可以在缩小的源代码中获得一些许可证注释&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6e7715057c88fc3ede1f6116ac0416e2c729170f" translate="yes" xml:space="preserve">
          <source>To fix it:</source>
          <target state="translated">为了解决它。</target>
        </trans-unit>
        <trans-unit id="a6b6d7bba93f6e1e868d22c4ce5e8fd401f399ba" translate="yes" xml:space="preserve">
          <source>To make this easier, and to make it easy to do a simple wrapping around CommonJS modules, this form of define is supported, sometimes referred to as &quot;simplified CommonJS wrapping&quot;:</source>
          <target state="translated">为了方便,也为了让CommonJS模块做一个简单的封装,支持这种形式的定义,有时也被称为 &quot;简化CommonJS封装&quot;。</target>
        </trans-unit>
        <trans-unit id="82e845da0003462942d83d91b7eadeddf354717e" translate="yes" xml:space="preserve">
          <source>To run the build, run this command from inside the &lt;strong&gt;appdirectory/scripts&lt;/strong&gt; directory:</source>
          <target state="translated">要运行构建，请从&lt;strong&gt;appdirectory / scripts&lt;/strong&gt;目录内部运行以下命令：</target>
        </trans-unit>
        <trans-unit id="b966b017967eef9b2e7721cf76e9ae536670e6c7" translate="yes" xml:space="preserve">
          <source>To see a more complete example that loads a module via RequireJS but uses Node-native modules for other things, see the &lt;a href=&quot;https://github.com/requirejs/r.js/tree/master/tests/node/embedded&quot;&gt;embedded test&lt;/a&gt; in the r.js repo.</source>
          <target state="translated">要查看通过RequireJS加载模块但将Node-native模块用于其他用途的更完整的示例，请参见r.js存储库中的&lt;a href=&quot;https://github.com/requirejs/r.js/tree/master/tests/node/embedded&quot;&gt;嵌入式测试&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bd4ac4ae170da9b146e596ddd3711697926708ca" translate="yes" xml:space="preserve">
          <source>To use a JSONP service in RequireJS, specify &quot;define&quot; as the callback parameter's value. This means you can get the value of a JSONP URL as if it was a module definition.</source>
          <target state="translated">要在RequireJS中使用JSONP服务,请指定 &quot;define &quot;作为回调参数的值。这意味着你可以像获取一个模块定义一样获取JSONP URL的值。</target>
        </trans-unit>
        <trans-unit id="6e6b87677764cd023d6559e51135d23b8537fde7" translate="yes" xml:space="preserve">
          <source>Turbo options</source>
          <target state="translated">涡轮增压选项</target>
        </trans-unit>
        <trans-unit id="55dd7970fca07c8a75f9aec4ee294f40a4e2c493" translate="yes" xml:space="preserve">
          <source>Undefining a Module</source>
          <target state="translated">解除对模块的定义</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="4997c3bd4bc74709bc6843fcd14f2bdb1f7ad512" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;http://npmjs.org&quot;&gt;npm&lt;/a&gt; to install it:</source>
          <target state="translated">使用&lt;a href=&quot;http://npmjs.org&quot;&gt;npm&lt;/a&gt;进行安装：</target>
        </trans-unit>
        <trans-unit id="30513a9146bbc0ebb732f04c610e5cdcb9629b08" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;optimization&quot;&gt;RequireJS optimizer&lt;/a&gt; either in command line mode or as an &lt;a href=&quot;https://github.com/requirejs/r.js/blob/master/build/tests/http/httpBuild.js&quot;&gt;HTTP service&lt;/a&gt; with the &lt;a href=&quot;https://github.com/requirejs/almond&quot;&gt;almond AMD shim&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;optimization&quot;&gt;RequireJS优化&lt;/a&gt;或者在命令行模式，或作为&lt;a href=&quot;https://github.com/requirejs/r.js/blob/master/build/tests/http/httpBuild.js&quot;&gt;HTTP服务&lt;/a&gt;与&lt;a href=&quot;https://github.com/requirejs/almond&quot;&gt;杏仁AMD垫片&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c904f7d34df4986bde9381d86c2179b0ac9fd6ef" translate="yes" xml:space="preserve">
          <source>Use the above example setup, if you just wanted to optimize main.css, you could use this command, from inside the &lt;strong&gt;appdirectory/css&lt;/strong&gt; directory:</source>
          <target state="translated">使用上面的示例设置，如果您只想优化main.css，则可以在&lt;strong&gt;appdirectory / css&lt;/strong&gt;目录中使用以下命令：</target>
        </trans-unit>
        <trans-unit id="67649effa4ce87323ef0aebd844fbda30158f942" translate="yes" xml:space="preserve">
          <source>Use the above example setup, if you just wanted to optimize main.js, you could use this command, from inside the &lt;strong&gt;appdirectory/scripts&lt;/strong&gt; directory:</source>
          <target state="translated">使用上面的示例设置，如果您只想优化main.js，则可以在&lt;strong&gt;appdirectory / scripts&lt;/strong&gt;目录中使用以下命令：</target>
        </trans-unit>
        <trans-unit id="c4a7a353170f8234a34024bafeaef356b8a52975" translate="yes" xml:space="preserve">
          <source>Used by &lt;a href=&quot;http://getfirebug.com/&quot;&gt;Firebug&lt;/a&gt; 1.8+</source>
          <target state="translated">由&lt;a href=&quot;http://getfirebug.com/&quot;&gt;Firebug&lt;/a&gt; 1.8+使用</target>
        </trans-unit>
        <trans-unit id="d4a847f63dd57eec0beb9d1e9525a841568bcd78" translate="yes" xml:space="preserve">
          <source>Used for parts of sites on &lt;a href=&quot;http://www.bbc.co.uk/&quot;&gt;the BBC&lt;/a&gt; (observed by looking at the source, not an official recommendation of AMD/RequireJS)</source>
          <target state="translated">用于&lt;a href=&quot;http://www.bbc.co.uk/&quot;&gt;BBC&lt;/a&gt;上的部分网站（通过查看来源进行观察，而不是AMD / RequireJS的官方推荐）</target>
        </trans-unit>
        <trans-unit id="1d41fd422f48e9ed0d3aae94c29bc124059cf2fe" translate="yes" xml:space="preserve">
          <source>Uses the CommonJS practice of string IDs for dependencies. Clear declaration of dependencies and avoids the use of globals.</source>
          <target state="translated">使用CommonJS的做法,用字符串ID来表示依赖关系。清晰地声明依赖关系,避免使用 globals。</target>
        </trans-unit>
        <trans-unit id="cfa856e44663f218032ac9363f5587a815abdfb8" translate="yes" xml:space="preserve">
          <source>Using JavaScript functions for encapsulation has been documented as the &lt;a href=&quot;http://www.adequatelygood.com/2010/3/JavaScript-Module-Pattern-In-Depth&quot;&gt;module pattern&lt;/a&gt;:</source>
          <target state="translated">使用JavaScript函数进行封装已记录为&lt;a href=&quot;http://www.adequatelygood.com/2010/3/JavaScript-Module-Pattern-In-Depth&quot;&gt;模块模式&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="a13efaa4a436994146b35afa81f0dbfea7e1c8c8" translate="yes" xml:space="preserve">
          <source>Using RequireJS in a server-side JavaScript environment that has synchronous loading should be as easy as redefining require.load(). The build system does this, the require.load method for that environment can be found in build/jslib/requirePatch.js.</source>
          <target state="translated">在有同步加载的服务器端JavaScript环境中使用RequireJS应该是很简单的,就像重新定义require.load()一样。构建系统就是这样做的,该环境的require.load方法可以在build/jslib/requirePatch.js中找到。</target>
        </trans-unit>
        <trans-unit id="289a74aa4c0456df8650ad33e2452d68f57e8d5d" translate="yes" xml:space="preserve">
          <source>Using eval() to evaluate the modules is bad:</source>
          <target state="translated">使用eval()来评估模块是不好的。</target>
        </trans-unit>
        <trans-unit id="c78edb579e3dbb222f2d259b6740f11757398aac" translate="yes" xml:space="preserve">
          <source>Using script tags with body text set to file text is bad:</source>
          <target state="translated">使用脚本标签,将正文文本设置为文件文本是不好的。</target>
        </trans-unit>
        <trans-unit id="228d83b80eb38ba23af9f37e0663410934e378f7" translate="yes" xml:space="preserve">
          <source>Using the optimizer as a node module</source>
          <target state="translated">将优化器作为节点模块使用</target>
        </trans-unit>
        <trans-unit id="c3fd77222b2e71662b263477d33da9477f3ede5c" translate="yes" xml:space="preserve">
          <source>Verbosity vs. Usefulness</source>
          <target state="translated">啰嗦与有用</target>
        </trans-unit>
        <trans-unit id="508686787ae997d3c41509077c7ba378e743f470" translate="yes" xml:space="preserve">
          <source>Version 2.1.6 and higher have experimental support for &lt;a href=&quot;http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/&quot;&gt;source maps&lt;/a&gt;. It works for mapping minified, bundled code to unminified, separate modules and only when &lt;strong&gt;optimize&lt;/strong&gt; is set to &lt;code&gt;&quot;uglify2&quot;&lt;/code&gt;. optimize set to &lt;code&gt;&quot;closure&quot;&lt;/code&gt; allows only mapping minified, bundled code to unminified bundled code (closure only available when running under Java with Rhino). The unminified files will show up in the developer tools with a &quot;.src.js&quot; file extension.</source>
          <target state="translated">2.1.6及更高版本具有对&lt;a href=&quot;http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/&quot;&gt;源映射的&lt;/a&gt;实验性支持。它仅在将&lt;strong&gt;optimize&lt;/strong&gt;设置为 &lt;code&gt;&quot;uglify2&quot;&lt;/code&gt; 时，才能将缩小的捆绑代码映射到未缩小的单独模块。将optimize设置为 &lt;code&gt;&quot;closure&quot;&lt;/code&gt; 仅允许将缩小的捆绑代码映射到未缩小的捆绑代码（仅当在具有Rhino的Java下运行时，closure才可用）。未缩小的文件将以&amp;ldquo; .src.js&amp;rdquo;文件扩展名显示在开发人员工具中。</target>
        </trans-unit>
        <trans-unit id="27ca0f4365b0300cd8d135ed858b5f4630b5f824" translate="yes" xml:space="preserve">
          <source>We also want some sort of syntax that will allow loading plain JavaScript files that exist today -- a developer should not have to rewrite all of their JavaScript to get the benefits of script loading.</source>
          <target state="translated">我们还希望能有某种语法,允许加载目前存在的纯JavaScript文件--开发者不应该为了获得脚本加载的好处而重写所有的JavaScript。</target>
        </trans-unit>
        <trans-unit id="289b86ce1649fa4f7108b9c4b6021d64ea08c079" translate="yes" xml:space="preserve">
          <source>We can create scripts on demand and add them to the head:</source>
          <target state="translated">我们可以根据需求创建脚本并添加到头部。</target>
        </trans-unit>
        <trans-unit id="a1ec9bf7282d39f1ec2d480df5541aa3df59aee1" translate="yes" xml:space="preserve">
          <source>Web Worker Support</source>
          <target state="translated">网络工作者支持</target>
        </trans-unit>
        <trans-unit id="2e99e1a486438cbb3065bc99ce45e9c7f8d976a6" translate="yes" xml:space="preserve">
          <source>Web Workers might be another way to load scripts, but:</source>
          <target state="translated">Web Workers可能是另一种加载脚本的方式,但。</target>
        </trans-unit>
        <trans-unit id="7dc2b7a514c40d738fcb40c24966fdd35b7ab44e" translate="yes" xml:space="preserve">
          <source>Web sites are turning into Web apps</source>
          <target state="translated">网站正在变成网络应用</target>
        </trans-unit>
        <trans-unit id="c41e81975a805013a596d74998d05b0991be3b34" translate="yes" xml:space="preserve">
          <source>What You Can Do</source>
          <target state="translated">您可以做什么</target>
        </trans-unit>
        <trans-unit id="d2b9d5645e3e29755ed6d5e5bd23b5476467de76" translate="yes" xml:space="preserve">
          <source>What are JavaScript modules? What is their purpose?</source>
          <target state="translated">什么是JavaScript模块?它们的作用是什么?</target>
        </trans-unit>
        <trans-unit id="9ba322e4d451d61aa1aa925a8fc046c545b21e05" translate="yes" xml:space="preserve">
          <source>What is important: being able to actually share code with others. AMD is the lowest energy pathway to that goal.</source>
          <target state="translated">重要的是:能够真正与他人分享代码。AMD是实现这一目标的最低能耗途径。</target>
        </trans-unit>
        <trans-unit id="3069c65b9df09bdc25a6487669983185f31b7699" translate="yes" xml:space="preserve">
          <source>When 'some/newmodule' does `require('foo')` it will get the foo1.2.js file, and when 'some/oldmodule' does `require('foo')` it will get the foo1.0.js file.</source>
          <target state="translated">当'some/newmodule'执行`require('foo')`时,会得到foo1.2.js文件,当'some/oldmodule'执行`require('foo')`时,会得到foo1.0.js文件。</target>
        </trans-unit>
        <trans-unit id="13a587a5f71c45fb2a2ee5c7ebede909a0a90ccd" translate="yes" xml:space="preserve">
          <source>When RequireJS is used in a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/DOM/Using_web_workers&quot;&gt;Web Worker&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/DOM/Using_web_workers#Importing_scripts_and_libraries&quot;&gt;importScripts&lt;/a&gt; is used to load modules. If that call failed for some reason, this error is generated.</source>
          <target state="translated">当RequireJS在使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/DOM/Using_web_workers&quot;&gt;Web工作&lt;/a&gt;，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/DOM/Using_web_workers#Importing_scripts_and_libraries&quot;&gt;importScripts&lt;/a&gt;用于加载模块。如果该呼叫由于某种原因失败，则会生成此错误。</target>
        </trans-unit>
        <trans-unit id="7fa66298280c020819d91748b0ae9d2ec88742bb" translate="yes" xml:space="preserve">
          <source>When run in a browser, &lt;a href=&quot;#pathsfallbacks&quot;&gt;paths fallbacks&lt;/a&gt; can be specified, to allow trying a load from a CDN location, but falling back to a local location if the CDN location fails to load.</source>
          <target state="translated">在浏览器中运行时，可以指定&lt;a href=&quot;#pathsfallbacks&quot;&gt;路径回退&lt;/a&gt;，以允许尝试从CDN位置进行加载，但是如果CDN位置无法加载，则回退到本地位置。</target>
        </trans-unit>
        <trans-unit id="d45a6bc83259e410831e5ab4ac9eae06192f6fba" translate="yes" xml:space="preserve">
          <source>When using require() in the top-level HTML page (or top-level script file that does not define a module), a configuration object can be passed as the first option:</source>
          <target state="translated">当在顶层HTML页面(或没有定义模块的顶层脚本文件)中使用require()时,可以传递一个配置对象作为第一个选项。</target>
        </trans-unit>
        <trans-unit id="7d8a8cb4134eda8c65a86351c434df5553a6ead3" translate="yes" xml:space="preserve">
          <source>While RequireJS loads jQuery just like any other dependency, jQuery's wide use and extensive plugin ecosystem mean you'll likely have other scripts in your project that also depend on jQuery. You might approach your jQuery RequireJS configuration differently depending on whether you are starting a new project or whether you are adapting existing code.</source>
          <target state="translated">虽然RequireJS加载jQuery就像其他依赖关系一样,jQuery的广泛使用和广泛的插件生态系统意味着你很可能在你的项目中还有其他脚本也依赖于jQuery。你可能会对jQuery RequireJS的配置采取不同的方式,这取决于你是在开始一个新的项目还是在改编现有的代码。</target>
        </trans-unit>
        <trans-unit id="8a365eae40482509c1f0aa1f29bc4a4bfcd1a236" translate="yes" xml:space="preserve">
          <source>While debugging, the line number you get for an error does not map to the original source file.</source>
          <target state="translated">调试时,得到的错误行号并不能映射到原始的源文件中。</target>
        </trans-unit>
        <trans-unit id="60d30561ad47c3e2e8a86b25641c43eb2c815a72" translate="yes" xml:space="preserve">
          <source>While the packages can have the CommonJS directory layout, the modules themselves should be in a module format that RequireJS can understand. Exception to the rule: if you are using the r.js Node adapter, the modules can be in the traditional CommonJS module format. You can use the &lt;a href=&quot;commonjs#autoconversion&quot;&gt;CommonJS converter tool&lt;/a&gt; if you need to convert traditional CommonJS modules into the async module format that RequireJS uses.</source>
          <target state="translated">尽管程序包可以具有CommonJS目录布局，但模块本身应采用RequireJS可以理解的模块格式。规则的例外：如果使用r.js节点适配器，则模块可以采用传统的CommonJS模块格式。如果需要将传统的CommonJS模块转换为RequireJS使用的异步模块格式，则可以使用&lt;a href=&quot;commonjs#autoconversion&quot;&gt;CommonJS转换工具&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8c7f642c080d5fc3b4f51344f0cf442a310298a7" translate="yes" xml:space="preserve">
          <source>Why AMD?</source>
          <target state="translated">为什么是AMD?</target>
        </trans-unit>
        <trans-unit id="71369dce19ad499c48f1624383e9218e3dd40601" translate="yes" xml:space="preserve">
          <source>Why Web Modules?</source>
          <target state="translated">为什么是网络模块?</target>
        </trans-unit>
        <trans-unit id="c5f8918743f6d7a09acef8b6e47dcd1fabab011d" translate="yes" xml:space="preserve">
          <source>With `requirejs.undef()`, if you later set up a different config and try to load the same module, the loader will still remember which modules needed that dependency and finish loading them when the newly configured module loads.</source>
          <target state="translated">使用`requirejs.undef()`,如果你以后设置了不同的配置,并尝试加载同一个模块,加载器仍然会记住哪些模块需要该依赖,并在新配置的模块加载时完成加载。</target>
        </trans-unit>
        <trans-unit id="cd9fb2c8cfbcd1191658318a7ea78f5b12fe941e" translate="yes" xml:space="preserve">
          <source>With the local install, you can also &lt;a href=&quot;node#optimizer&quot;&gt;use the optimizer via a function call&lt;/a&gt; inside a node program.</source>
          <target state="translated">在本地安装中，您还&lt;a href=&quot;node#optimizer&quot;&gt;可以通过&lt;/a&gt;节点程序内部的函数调用来使用优化器。</target>
        </trans-unit>
        <trans-unit id="f8debcd1d8b575c073e319ccbee375c82809a4e3" translate="yes" xml:space="preserve">
          <source>With this approach, the CommonJS group was able to work out dependency references and how to deal with circular dependencies, and how to get some properties about the current module. However, they did not fully embrace some things in the browser environment that cannot change but still affect module design:</source>
          <target state="translated">通过这种方法,CommonJS小组能够解决依赖引用和如何处理循环依赖,以及如何获得一些关于当前模块的属性。但是,他们并没有完全接受浏览器环境中一些不能改变但仍然影响模块设计的东西。</target>
        </trans-unit>
        <trans-unit id="6a22952292ff7c2d65a8ad8ea0b53628bf602df7" translate="yes" xml:space="preserve">
          <source>With this approach, then you normally do not need the exports and module function arguments, so you can leave them off the module definition.</source>
          <target state="translated">采用这种方法,那么你通常不需要导出和模块函数参数,所以你可以不在模块定义中使用它们。</target>
        </trans-unit>
        <trans-unit id="6d2f2f7f294f064bba8074a81bae1e972660489d" translate="yes" xml:space="preserve">
          <source>With this local install, you can run the optimizer by running the &lt;code&gt;r.js&lt;/code&gt; or &lt;code&gt;r.js.cmd&lt;/code&gt; file found in the project's &lt;code&gt;node_modules/.bin&lt;/code&gt; directory.</source>
          <target state="translated">通过此本地安装，您可以通过运行项目的 &lt;code&gt;node_modules/.bin&lt;/code&gt; 目录中的 &lt;code&gt;r.js&lt;/code&gt; 或 &lt;code&gt;r.js.cmd&lt;/code&gt; 文件来运行优化器。</target>
        </trans-unit>
        <trans-unit id="cfe5ad7fe6d1924fe8f5873b574afb12bdfa0c42" translate="yes" xml:space="preserve">
          <source>XHR also has issues with cross-domain requests. Some browsers now have cross-domain XHR support, but it is not universal, and IE decided to create a different API object for cross-domain calls, XDomainRequest. More moving parts and more things to get wrong. In particular, you need to be sure to not send any non-standard HTTP headers or there may be another &quot;preflight&quot; request done to make sure the cross-domain access is allowed.</source>
          <target state="translated">XHR还存在跨域请求的问题。现在一些浏览器已经支持跨域XHR,但并不通用,IE决定为跨域调用创建一个不同的API对象,XDomainRequest。更多的移动部件和更多的事情会出错。特别是,你需要确保不要发送任何非标准的HTTP头,否则可能会有另一个 &quot;预飞 &quot;请求做,以确保跨域访问被允许。</target>
        </trans-unit>
        <trans-unit id="31c2c59b547d0a7ab95d805593077bc3374fcdb4" translate="yes" xml:space="preserve">
          <source>Yes &lt;a href=&quot;http://nodejs.org&quot;&gt;Node&lt;/a&gt; does. That loader uses the CommonJS module format. The CommonJS module format is &lt;a href=&quot;why&quot;&gt;non-optimal for the browser&lt;/a&gt;, and I do not agree with &lt;a href=&quot;http://tagneto.blogspot.com/2010/03/commonjs-module-trade-offs.html&quot;&gt;some of the trade-offs made in the CommonJS module format&lt;/a&gt;. By using RequireJS on the server, you can use one format for all your modules, whether they are running server side or in the browser. That way you can preserve the speed benefits and easy debugging you get with RequireJS in the browser, and not have to worry about extra translation costs for moving between two formats.</source>
          <target state="translated">是&lt;a href=&quot;http://nodejs.org&quot;&gt;节点&lt;/a&gt;可以。该加载器使用CommonJS模块格式。&lt;a href=&quot;why&quot;&gt;对于浏览器来说&lt;/a&gt;，CommonJS模块格式不是最佳的，我不同意使用&lt;a href=&quot;http://tagneto.blogspot.com/2010/03/commonjs-module-trade-offs.html&quot;&gt;CommonJS模块格式&lt;/a&gt;进行的一些折衷。通过在服务器上使用RequireJS，可以对所有模块使用一种格式，无论它们是在服务器端还是在浏览器中运行。这样，您可以保留在浏览器中使用RequireJS所获得的速度优势和简便的调试功能，而不必担心在两种格式之间移动会产生额外的翻译成本。</target>
        </trans-unit>
        <trans-unit id="e8663ce779c85954c38a5af8306faf37b7880023" translate="yes" xml:space="preserve">
          <source>Yes! The Node adapter for RequireJS, called r.js, will use Node's implementation of require and Node's search paths if the module is not found with the configuration used by RequireJS, so you can continue to use your existing Node-based modules without having to do changes to them.</source>
          <target state="translated">是的! RequireJS的Node适配器,称为r.js,如果在RequireJS使用的配置中找不到模块,它将使用Node的require和Node的搜索路径实现,所以你可以继续使用你现有的基于Node的模块,而无需对它们进行修改。</target>
        </trans-unit>
        <trans-unit id="ee8947dc57d182a3011ce395532368374e65caa2" translate="yes" xml:space="preserve">
          <source>You can avoid lots of configuration lines by placing the files according to the default ID-to-path convention of &lt;code&gt;baseUrl + moduleID + '.js'&lt;/code&gt;. The examples below show how to set baseUrl to be the directory for third-party, library code, and use one extra paths config for your app code.</source>
          <target state="translated">通过根据 &lt;code&gt;baseUrl + moduleID + '.js'&lt;/code&gt; 的默认ID到路径约定放置文件，可以避免大量配置行。以下示例显示了如何将baseUrl设置为第三方库代码的目录，以及如何为您的应用程序代码使用一个额外的路径配置。</target>
        </trans-unit>
        <trans-unit id="934837e40083f6a48dd3d019d739d3bb3bd6f17f" translate="yes" xml:space="preserve">
          <source>You can define a &lt;b&gt;has&lt;/b&gt; object in the build config with true or false values for some has() tests, and the optimizer will replace the has() test with the true or false value.</source>
          <target state="translated">您可以在构建配置中为某些has（）测试使用true或false值定义一个&lt;b&gt;has&lt;/b&gt;对象，并且优化程序将用true或false值替换has（）测试。</target>
        </trans-unit>
        <trans-unit id="0d9092704d3269e06cf75c7384f32aa09d5f3586" translate="yes" xml:space="preserve">
          <source>You can do this by using the &lt;strong&gt;excludeShallow&lt;/strong&gt; option. Using the &lt;a href=&quot;#example&quot;&gt;example setup&lt;/a&gt; above, assume you are currently building out or debugging two.js. You could use this optimization command:</source>
          <target state="translated">您可以使用&lt;strong&gt;excludeShallow&lt;/strong&gt;选项来执行此操作。使用上面的&lt;a href=&quot;#example&quot;&gt;示例设置&lt;/a&gt;，假设您当前正在构建或调试two.js。您可以使用以下优化命令：</target>
        </trans-unit>
        <trans-unit id="ca244dd9b6be738c5452010e67be2b0c37758fa8" translate="yes" xml:space="preserve">
          <source>You can either specify options on the command line:</source>
          <target state="translated">你可以在命令行中指定选项。</target>
        </trans-unit>
        <trans-unit id="e52217d43c25ef584de1ffe0ee00d4d33eea6385" translate="yes" xml:space="preserve">
          <source>You can reference your plugin by putting its module name before a ! in the dependency. For instance, if you create a plugin with the name &quot;foo.js&quot;, you would use it like so:</source>
          <target state="translated">你可以通过在依赖关系中的 !&quot;前面加上模块名来引用你的插件。例如,如果你创建了一个名为 &quot;foo.js &quot;的插件,你可以这样使用它。</target>
        </trans-unit>
        <trans-unit id="94af4f0eaff062d0b3e49c77a862fe434306c96d" translate="yes" xml:space="preserve">
          <source>You can see an example of its use by looking at one of the files used in &lt;a href=&quot;http://github.com/requirejs/requirejs/blob/master/tests/workers.js&quot;&gt;the unit test&lt;/a&gt;.</source>
          <target state="translated">通过查看&lt;a href=&quot;http://github.com/requirejs/requirejs/blob/master/tests/workers.js&quot;&gt;单元测试中&lt;/a&gt;使用的文件之一，可以看到其用法示例。</target>
        </trans-unit>
        <trans-unit id="34f18da7863e56fdfa33c97e023770bcb1c79817" translate="yes" xml:space="preserve">
          <source>You can then use the above module in another module, say, in a my/lamps.js file:</source>
          <target state="translated">然后,你可以在另一个模块中使用上述模块,比如,在my/lamps.js文件中。</target>
        </trans-unit>
        <trans-unit id="6d408cedf635435c4559ea8c022ad45cd120dee1" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;#onejs&quot;&gt;one JavaScript file optimization&lt;/a&gt; approach to make your development experience faster. By optimizing all the modules in your project into one file, except the one you are currently developing, you can reload your project quickly in the browser, but still give you the option of fine grained debugging in a module.</source>
          <target state="translated">您可以使用&lt;a href=&quot;#onejs&quot;&gt;一种JavaScript文件优化&lt;/a&gt;方法来提高开发速度。通过将项目中的所有模块优化为一个文件（当前正在开发的文件除外），可以在浏览器中快速重新加载项目，但仍可以选择在模块中进行精细调试。</target>
        </trans-unit>
        <trans-unit id="e85f93e17713bad14a95d8cd370414470f034be1" translate="yes" xml:space="preserve">
          <source>You can use this example with the CDN example above -- the shim example will not work since shimmed libraries need a global jQuery.</source>
          <target state="translated">你可以将这个例子和上面的CDN例子一起使用--shim的例子将无法使用,因为shimmed库需要一个全局jQuery。</target>
        </trans-unit>
        <trans-unit id="35637298babea9951136fe42e40ee8a2641302e6" translate="yes" xml:space="preserve">
          <source>You do not need to implement normalize if the resource name is just a regular module name. For instance, the text! plugin does not implement normalize because the dependency names look like 'text!./some/path.html'.</source>
          <target state="translated">如果资源名只是一个普通的模块名,你不需要实现normalize。例如,text!插件没有实现normalize,因为依赖名称看起来像'text!./some/path.html'。</target>
        </trans-unit>
        <trans-unit id="268347d9cc7d9cf7908d577ac75d750a3ec06657" translate="yes" xml:space="preserve">
          <source>You may also call require.config from your &lt;a href=&quot;api#data-main&quot;&gt;data-main Entry Point&lt;/a&gt;, but be aware that the data-main script is loaded asynchronously. Avoid other entry point scripts which wrongly assume that data-main and its require.config will always execute prior to their script loading.</source>
          <target state="translated">您也可以从&lt;a href=&quot;api#data-main&quot;&gt;数据主入口点&lt;/a&gt;调用require.config ，但是请注意，数据主脚本是异步加载的。避免使用其他入口点脚本，这些脚本错误地假定data-main及其require.config将始终在脚本加载之前执行。</target>
        </trans-unit>
        <trans-unit id="c90399d9bc6d39e4e0323a4f654f5ad35f0761ea" translate="yes" xml:space="preserve">
          <source>You may encounter some define() calls that include a name for the module as the first argument to define():</source>
          <target state="translated">您可能会遇到一些 define()调用,其中包括一个模块的名称作为 define()的第一个参数。</target>
        </trans-unit>
        <trans-unit id="85ff5b58fd6ef6fa6b20479d3b624ce5c45a8836" translate="yes" xml:space="preserve">
          <source>You may have a script you want to load from a &lt;a href=&quot;http://en.wikipedia.org/wiki/Content_delivery_network&quot;&gt;Content Delivery Network (CDN)&lt;/a&gt; or any other server on a different domain.</source>
          <target state="translated">您可能具有要从&lt;a href=&quot;http://en.wikipedia.org/wiki/Content_delivery_network&quot;&gt;Content Delivery Network（CDN）&lt;/a&gt;或其他域上的任何其他服务器加载的脚本。</target>
        </trans-unit>
        <trans-unit id="b9cb0c91120fb108d906ccb84178ac86146de663" translate="yes" xml:space="preserve">
          <source>You should avoid naming modules yourself, and only place one module in a file while developing. However, for tooling and performance, a module solution needs a way to identify modules in built resources.</source>
          <target state="translated">应该避免自己给模块命名,在开发的时候只在一个文件中放置一个模块。但是,为了工具和性能,模块方案需要有一种方法来识别内置资源中的模块。</target>
        </trans-unit>
        <trans-unit id="020d90c4a950b7c671e463b43e9d47537f9c25b6" translate="yes" xml:space="preserve">
          <source>You should use the &lt;a href=&quot;optimization#mainConfigFile&quot;&gt;mainConfigFile build option&lt;/a&gt; to specify the file where to find the shim config. Otherwise the optimizer will not know of the shim config. The other option is to duplicate the shim config in the build profile.</source>
          <target state="translated">您应使用&lt;a href=&quot;optimization#mainConfigFile&quot;&gt;mainConfigFile构建选项&lt;/a&gt;来指定可在其中找到垫片配置的文件。否则，优化程序将不了解填充程序配置。另一个选项是在构建配置文件中复制填充程序配置。</target>
        </trans-unit>
        <trans-unit id="97681be93dfef60f3fb4d09b005e73fd388aec7f" translate="yes" xml:space="preserve">
          <source>You will likely need to set the &lt;strong&gt;baseUrl&lt;/strong&gt;&lt;a href=&quot;#config&quot;&gt;configuration option&lt;/a&gt; to make sure require() can find the scripts to load.</source>
          <target state="translated">您可能需要设置&lt;strong&gt;baseUrl &lt;/strong&gt;&lt;a href=&quot;#config&quot;&gt;配置选项&lt;/a&gt;，以确保require（）可以找到要加载的脚本。</target>
        </trans-unit>
        <trans-unit id="6dba9d538cc7725fb3a6aa1bf1b4ce6a48e9f9b4" translate="yes" xml:space="preserve">
          <source>You will typically use a data-main script to &lt;a href=&quot;#config&quot;&gt;set configuration options&lt;/a&gt; and then load the first application module. Note: the script tag require.js generates for your data-main module includes the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script#attr-async&quot;&gt;async attribute&lt;/a&gt;. This means that &lt;strong&gt;you cannot assume that the load and execution of your data-main script will finish prior to other scripts referenced later in the same page.&lt;/strong&gt;</source>
          <target state="translated">通常，您将使用数据主脚本来&lt;a href=&quot;#config&quot;&gt;设置配置选项&lt;/a&gt;，然后加载第一个应用程序模块。注意：为您的数据主模块生成的脚本标记require.js包含&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script#attr-async&quot;&gt;async属性&lt;/a&gt;。这意味着&lt;strong&gt;您不能假定数据主脚本的加载和执行将在同一页面稍后引用的其他脚本之前完成。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="369dac7c679f0128f82fcbd8ee8a70df45995f85" translate="yes" xml:space="preserve">
          <source>Your time coding is mostly spent thinking, not typing. While fewer words are generally preferable, there is a limit to that approach paying off, and the extra typing in AMD is not that much more.</source>
          <target state="translated">你编码的时间主要是用来思考,而不是打字。虽然一般来说字数少一些比较好,但这种方法付出的代价是有限的,在AMD中多出来的打字时间并不多。</target>
        </trans-unit>
        <trans-unit id="fa5e2f93089b6ba91d69ad2df5ffb1b8e3b30434" translate="yes" xml:space="preserve">
          <source>and in app.js:</source>
          <target state="translated">而在app.js中。</target>
        </trans-unit>
        <trans-unit id="30d099754f286078db100db738bf8973842acc61" translate="yes" xml:space="preserve">
          <source>and the root bundle would look like:</source>
          <target state="translated">和根捆绑会像。</target>
        </trans-unit>
        <trans-unit id="4a68969ef8e858229267b842dedf42ab5dde4d50" translate="yes" xml:space="preserve">
          <source>app.js</source>
          <target state="translated">app.js</target>
        </trans-unit>
        <trans-unit id="68620029c15ee91081f25087c97731ddec131ed1" translate="yes" xml:space="preserve">
          <source>app/</source>
          <target state="translated">app/</target>
        </trans-unit>
        <trans-unit id="182b400a51ca1ed7d5e68cd0c9e35beb52b7043d" translate="yes" xml:space="preserve">
          <source>appdirectory</source>
          <target state="translated">appdirectory</target>
        </trans-unit>
        <trans-unit id="a6e2217113e1101cebbd54678d99479155ebe930" translate="yes" xml:space="preserve">
          <source>avoid dumping global variables in the page</source>
          <target state="translated">避免在页面中倾倒全局变量</target>
        </trans-unit>
        <trans-unit id="d8b586bf1b6b8514e418f30ddc1550845968e12d" translate="yes" xml:space="preserve">
          <source>baseUrl</source>
          <target state="translated">baseUrl</target>
        </trans-unit>
        <trans-unit id="35e8277cc95cf8aaf1e8e9ffcb5ea39e6502bbd0" translate="yes" xml:space="preserve">
          <source>bundles</source>
          <target state="translated">bundles</target>
        </trans-unit>
        <trans-unit id="1d87cf050f073de171743e1289b27e42077e9332" translate="yes" xml:space="preserve">
          <source>bundles config is useful if doing a build and that build target was not an existing module ID, or if you have loader plugin resources in built JS files that should not be loaded by the loader plugin. &lt;strong&gt;Note that the keys and values are module IDs&lt;/strong&gt;, not path segments. They are absolute module IDs, not a module ID prefix like &lt;a href=&quot;#config-paths&quot;&gt;paths config&lt;/a&gt; or &lt;a href=&quot;#config-map&quot;&gt;map config&lt;/a&gt;. Also, bundle config is different from map config in that map config is a one-to-one module ID relationship, where bundle config is for pointing multiple module IDs to a bundle's module ID.</source>
          <target state="translated">如果执行构建并且该构建目标不是现有的模块ID，或者如果已构建的JS文件中包含不应由加载程序插件加载的加载程序插件资源，则bundles config很有用。&lt;strong&gt;请注意，键和值是模块ID&lt;/strong&gt;，而不是路径段。它们是绝对的模块ID，而不是像&lt;a href=&quot;#config-paths&quot;&gt;path config&lt;/a&gt;或&lt;a href=&quot;#config-map&quot;&gt;map config&lt;/a&gt;这样的模块ID前缀。此外，bundle config与map config的不同之处在于map config是一对一的模块ID关系，其中bundle config用于将多个模块ID指向bundle的模块ID。</target>
        </trans-unit>
        <trans-unit id="579c9417979d7785e6b71b4f343a3a25028e0208" translate="yes" xml:space="preserve">
          <source>but 'a' and 'b' will be included if specified like so:</source>
          <target state="translated">但'a'和'b'会被包括在内,如果这样指定。</target>
        </trans-unit>
        <trans-unit id="5651c3e30152897bed64070f9ea7509fbb7eaf58" translate="yes" xml:space="preserve">
          <source>but this means you cannot set the value for a paths property of &quot;core/jquery.tabs&quot; to a value. This would not work: &lt;code&gt;paths.core/jquery.tabs=empty:&lt;/code&gt;, since it would result in this incorrect structure:</source>
          <target state="translated">但这意味着您无法将&amp;ldquo; core / jquery.tabs&amp;rdquo;的paths属性的值设置为一个值。这将不起作用： &lt;code&gt;paths.core/jquery.tabs=empty:&lt;/code&gt; 因为它会导致以下错误结构：</target>
        </trans-unit>
        <trans-unit id="b4d5b37bf7a986c138ede89e0806f366b5cb1830" translate="yes" xml:space="preserve">
          <source>callback</source>
          <target state="translated">callback</target>
        </trans-unit>
        <trans-unit id="9031234d18c313213c6fa8578b1a6efffa132f47" translate="yes" xml:space="preserve">
          <source>canvas.js</source>
          <target state="translated">canvas.js</target>
        </trans-unit>
        <trans-unit id="0ba1b6d81cde508d26591e899916a6b092ccc039" translate="yes" xml:space="preserve">
          <source>cart/</source>
          <target state="translated">cart/</target>
        </trans-unit>
        <trans-unit id="5db796b338afba355ef805d024ec3e62501d72e9" translate="yes" xml:space="preserve">
          <source>common.css</source>
          <target state="translated">common.css</target>
        </trans-unit>
        <trans-unit id="dfba7aade0868074c2861c98e2a9a92f3178a51b" translate="yes" xml:space="preserve">
          <source>config</source>
          <target state="translated">config</target>
        </trans-unit>
        <trans-unit id="ec2727b3b71f07635f726026bef44352ec89e452" translate="yes" xml:space="preserve">
          <source>context</source>
          <target state="translated">context</target>
        </trans-unit>
        <trans-unit id="2f84417a9e73cead4d5c99e05daff2a534b30132" translate="yes" xml:space="preserve">
          <source>css</source>
          <target state="translated">css</target>
        </trans-unit>
        <trans-unit id="5300d17a1d695bd411e4cdf96f9548c23ced6175" translate="yes" xml:space="preserve">
          <source>curl</source>
          <target state="translated">curl</target>
        </trans-unit>
        <trans-unit id="b549cb140e511f5ac2733025ff6d8eda8a8b7fc8" translate="yes" xml:space="preserve">
          <source>data-main Entry Point</source>
          <target state="translated">数据主入口点</target>
        </trans-unit>
        <trans-unit id="9f2696583122964a7d696a2d47ac4a3db6ad1bcb" translate="yes" xml:space="preserve">
          <source>deps</source>
          <target state="translated">deps</target>
        </trans-unit>
        <trans-unit id="4bad62c293c46433ccc5a55eff2c143661293c1a" translate="yes" xml:space="preserve">
          <source>document.write() can be used to load scripts -- it can load scripts from other domains and it maps to how browsers normally consume scripts, so it allows for easy debugging.</source>
          <target state="translated">document.write()可以用来加载脚本--它可以加载来自其他域的脚本,并且它映射到浏览器通常消费脚本的方式,所以它允许轻松调试。</target>
        </trans-unit>
        <trans-unit id="5958b76387ccd458d5f527ca464f090598df6741" translate="yes" xml:space="preserve">
          <source>edge cases that break in browsers, like cross-domain access</source>
          <target state="translated">浏览器中出现的边缘情况,如跨域访问。</target>
        </trans-unit>
        <trans-unit id="ff8af39bb078e2360da7fdc28417e6c1c52d5174" translate="yes" xml:space="preserve">
          <source>empty: paths for network/CDN resources</source>
          <target state="translated">空:网络/CDN资源的路径。</target>
        </trans-unit>
        <trans-unit id="4b572a52b55bf1889556c6ce1e404be0d7ce946c" translate="yes" xml:space="preserve">
          <source>enforceDefine</source>
          <target state="translated">enforceDefine</target>
        </trans-unit>
        <trans-unit id="d90d8771241a7a05d34eed9205b8b446fb5b5f3a" translate="yes" xml:space="preserve">
          <source>eval context is different across browsers. You might be able to use execScript in IE to help this, but it means more moving parts.</source>
          <target state="translated">eval上下文在不同的浏览器中是不同的。你也许可以在IE中使用execScript来帮助解决这个问题,但这意味着更多的移动部件。</target>
        </trans-unit>
        <trans-unit id="43cca01843358114d77138bdf4c270875286cec3" translate="yes" xml:space="preserve">
          <source>foo1.0.js</source>
          <target state="translated">foo1.0.js</target>
        </trans-unit>
        <trans-unit id="42bf6d0b49db5b2166474ae85e2cf958a05393cb" translate="yes" xml:space="preserve">
          <source>foo1.2.js</source>
          <target state="translated">foo1.2.js</target>
        </trans-unit>
        <trans-unit id="b0cf8d3b30f6f61f1cfb2f257448bf0165378abc" translate="yes" xml:space="preserve">
          <source>for more information.</source>
          <target state="translated">更多信息。</target>
        </trans-unit>
        <trans-unit id="0032176e806dc0ce8286589b0e98559a66027030" translate="yes" xml:space="preserve">
          <source>for the optimization target.</source>
          <target state="translated">为优化目标。</target>
        </trans-unit>
        <trans-unit id="ead9f7e89bbc436a96977295af1dc1bc42e42683" translate="yes" xml:space="preserve">
          <source>i18n bundle support is provided by the i18n.js plugin. It is automatically loaded when a module or dependency specifies the i18n! prefix (more info below). &lt;a href=&quot;http://requirejs.org/docs/download.html#i18n&quot;&gt;Download the plugin&lt;/a&gt; and put it in the same directory as your app's main JS file.</source>
          <target state="translated">i18n.js插件提供了对i18n包的支持。当模块或依赖项指定i18n时，它将自动加载！前缀（下面有更多信息）。&lt;a href=&quot;http://requirejs.org/docs/download.html#i18n&quot;&gt;下载插件&lt;/a&gt;，并将其放在应用程序的主JS文件所在的目录中。</target>
        </trans-unit>
        <trans-unit id="dc5f7718fd7e5c233be9044ede6ef58c83b5d6d2" translate="yes" xml:space="preserve">
          <source>importScripts failed for ...</source>
          <target state="translated">importScripts失败...</target>
        </trans-unit>
        <trans-unit id="2c1a36cd8bde417114cd4f15a9d7802a1c5bf634" translate="yes" xml:space="preserve">
          <source>in index.html:</source>
          <target state="translated">在index.html中。</target>
        </trans-unit>
        <trans-unit id="f6013a00b362253c64368d6eebc50ea2131754e2" translate="yes" xml:space="preserve">
          <source>index.html</source>
          <target state="translated">index.html</target>
        </trans-unit>
        <trans-unit id="33249b1929c8b83eb4a72adebb385c134300aa14" translate="yes" xml:space="preserve">
          <source>inherent asynchronicity</source>
          <target state="translated">固有异步性</target>
        </trans-unit>
        <trans-unit id="3f33a365d57118fb6c072149b026bf3898687f01" translate="yes" xml:space="preserve">
          <source>jQuery defines &lt;a href=&quot;api#modulename&quot;&gt;named AMD module&lt;/a&gt; 'jquery' (all lower case) when it detects AMD/RequireJS. To reduce confusion, we recommend using 'jquery' as the module name in your requirejs.config.</source>
          <target state="translated">jQuery 在检测到AMD / RequireJS时定义了&lt;a href=&quot;api#modulename&quot;&gt;名为AMD的模块&lt;/a&gt; &amp;ldquo; jquery&amp;rdquo;（全部小写）。为了减少混乱，我们建议在您的requirejs.config中使用&amp;ldquo; jquery&amp;rdquo;作为模块名称。</target>
        </trans-unit>
        <trans-unit id="9138a4fadeb7b3d7df1c442e211cb8d36112cba1" translate="yes" xml:space="preserve">
          <source>jQuery registers itself as the global variables &quot;$&quot; and &quot;jQuery&quot;, even when it detects AMD/RequireJS. The AMD approach advises against the use of global functions, but the decision to turn off these jQuery globals hinges on whether you have non-AMD code that depends on them. jQuery has a &lt;a href=&quot;http://api.jquery.com/jQuery.noConflict/&quot;&gt;noConflict function&lt;/a&gt; that supports releasing control of the global variables and this can be automated in your requirejs.config, as we will see &lt;a href=&quot;#noconflictmap&quot;&gt;later&lt;/a&gt;.</source>
          <target state="translated">jQuery将自己注册为全局变量&amp;ldquo; $&amp;rdquo;和&amp;ldquo; jQuery&amp;rdquo;，即使它检测到AMD / RequireJS。AMD方法建议不要使用全局功能，但是关闭这些jQuery全局功能的决定取决于您是否拥有依赖于它们的非AMD代码。jQuery具有一个&lt;a href=&quot;http://api.jquery.com/jQuery.noConflict/&quot;&gt;noConflict函数&lt;/a&gt;，该函数支持释放对全局变量的控制，这可以在您的requirejs.config中自动实现，我们将在&lt;a href=&quot;#noconflictmap&quot;&gt;后面介绍&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7a0d2a18212b79b67dee0e91e19cf1b654062c92" translate="yes" xml:space="preserve">
          <source>jquery.js</source>
          <target state="translated">jquery.js</target>
        </trans-unit>
        <trans-unit id="9ed0b2469c22926565156df53ef6562350753750" translate="yes" xml:space="preserve">
          <source>js/</source>
          <target state="translated">js/</target>
        </trans-unit>
        <trans-unit id="70070d20d4c6e863f10cb8b6749cc4b4efaf6027" translate="yes" xml:space="preserve">
          <source>lib/</source>
          <target state="translated">lib/</target>
        </trans-unit>
        <trans-unit id="5dbc716c4600097b85b9e51d6aeb77a4363b03ed" translate="yes" xml:space="preserve">
          <source>load</source>
          <target state="translated">load</target>
        </trans-unit>
        <trans-unit id="ec030ee0a72bb1bad48e285b9d1e42ab5b8170ee" translate="yes" xml:space="preserve">
          <source>load is a function, and it will be called with the following arguments:</source>
          <target state="translated">load是一个函数,它将被调用,参数如下。</target>
        </trans-unit>
        <trans-unit id="6dff233c807097ef10ae79c568dc973d30c3cf68" translate="yes" xml:space="preserve">
          <source>load: function (name, parentRequire, onload, config)</source>
          <target state="translated">加载:函数(name,parentRequire,onload,config)</target>
        </trans-unit>
        <trans-unit id="0b6d8e9672e5ffa1f585413a4ff5521b40332f97" translate="yes" xml:space="preserve">
          <source>lsjs</source>
          <target state="translated">lsjs</target>
        </trans-unit>
        <trans-unit id="33e0a7d96f2f283eb6f94bbfd4ce882c6816f77d" translate="yes" xml:space="preserve">
          <source>main.css</source>
          <target state="translated">main.css</target>
        </trans-unit>
        <trans-unit id="7b6b9d0efba95dec0a83ec36edc8acd84043be9d" translate="yes" xml:space="preserve">
          <source>main.css has content like the following:</source>
          <target state="translated">main.css的内容如下。</target>
        </trans-unit>
        <trans-unit id="2d6427cfcffb5ef37b2d32bd7aac8a9b7450a987" translate="yes" xml:space="preserve">
          <source>main.html</source>
          <target state="translated">main.html</target>
        </trans-unit>
        <trans-unit id="f1df1c5603aa500b9411213f4ea48cf4e5d422e0" translate="yes" xml:space="preserve">
          <source>main.html has script tags for require.js and loads main.js via a require call, like so:</source>
          <target state="translated">main.html有require.js的脚本标签,并通过require调用加载main.js,像这样。</target>
        </trans-unit>
        <trans-unit id="c4a4248f7568c9e41265502c39b0daeb8b635431" translate="yes" xml:space="preserve">
          <source>main.js</source>
          <target state="translated">main.js</target>
        </trans-unit>
        <trans-unit id="5bde0c1eb87162d48261ef607a5f7367edd8af16" translate="yes" xml:space="preserve">
          <source>main.js loads one.js, two.js and three.js via a require call:</source>
          <target state="translated">main.js通过require调用加载one.js、two.js和three.js。</target>
        </trans-unit>
        <trans-unit id="37745ed7a0f005fb14522c5cc7c1ba3d9e0df579" translate="yes" xml:space="preserve">
          <source>map</source>
          <target state="translated">map</target>
        </trans-unit>
        <trans-unit id="839a384082f672d5b0e4ed1c48403f66bc62c7e5" translate="yes" xml:space="preserve">
          <source>map example:</source>
          <target state="translated">地图的例子。</target>
        </trans-unit>
        <trans-unit id="3c439d3b6842ae589d848604d613de606883e341" translate="yes" xml:space="preserve">
          <source>my/cart.js</source>
          <target state="translated">my/cart.js</target>
        </trans-unit>
        <trans-unit id="6ff94085a8329ba4ee05cefa0a0b5b1b179b3db7" translate="yes" xml:space="preserve">
          <source>my/inventory.js</source>
          <target state="translated">my/inventory.js</target>
        </trans-unit>
        <trans-unit id="23b2f9933585fb1b37de87310c51e3eb51c83b97" translate="yes" xml:space="preserve">
          <source>my/nls/colors.js</source>
          <target state="translated">my/nls/colors.js</target>
        </trans-unit>
        <trans-unit id="c3e4ffdb238e5c58edbed616f0dfed31ef1359ff" translate="yes" xml:space="preserve">
          <source>my/nls/fr-fr-paris/colors.js</source>
          <target state="translated">my/nls/fr-fr-paris/colors.js</target>
        </trans-unit>
        <trans-unit id="6d560f42236d5cf1594fcea61de2e335709a6b4e" translate="yes" xml:space="preserve">
          <source>my/nls/fr-fr/colors.js</source>
          <target state="translated">my/nls/fr-fr/colors.js</target>
        </trans-unit>
        <trans-unit id="5a03cbc43369adc59a77432f3dbe892648c90d2f" translate="yes" xml:space="preserve">
          <source>my/nls/fr/colors.js</source>
          <target state="translated">my/nls/fr/colors.js</target>
        </trans-unit>
        <trans-unit id="68644578c0e8f200b5d33adf2401413115a74114" translate="yes" xml:space="preserve">
          <source>my/shirt.js</source>
          <target state="translated">my/shirt.js</target>
        </trans-unit>
        <trans-unit id="a412083cb1fc91a30f7e8b0861829a50827f0b6c" translate="yes" xml:space="preserve">
          <source>network loading</source>
          <target state="translated">网络负荷</target>
        </trans-unit>
        <trans-unit id="2fad3300f3300cc8d668154fa62ddaae9e5376d5" translate="yes" xml:space="preserve">
          <source>newmodule.js</source>
          <target state="translated">newmodule.js</target>
        </trans-unit>
        <trans-unit id="71878dcf848606242ed856e0c6a0c24d1d32a939" translate="yes" xml:space="preserve">
          <source>nodeIdCompat</source>
          <target state="translated">nodeIdCompat</target>
        </trans-unit>
        <trans-unit id="514d9f2e0acc04d77fc45ca16b43c69b19977218" translate="yes" xml:space="preserve">
          <source>normalize</source>
          <target state="translated">normalize</target>
        </trans-unit>
        <trans-unit id="2a281ad421bb92791152f62669135fa7021cb816" translate="yes" xml:space="preserve">
          <source>normalize: function (name, normalize)</source>
          <target state="translated">归一化:函数(name,normalize)</target>
        </trans-unit>
        <trans-unit id="660051d15ac64cec704cfacca2c2eab008f657e8" translate="yes" xml:space="preserve">
          <source>npm</source>
          <target state="translated">npm</target>
        </trans-unit>
        <trans-unit id="d8631383a6178b11a2917aa845f41707e9185dc0" translate="yes" xml:space="preserve">
          <source>oldmodule.js</source>
          <target state="translated">oldmodule.js</target>
        </trans-unit>
        <trans-unit id="7a39e1d29475a2a77167507df7366126892c9900" translate="yes" xml:space="preserve">
          <source>onLayerEnd</source>
          <target state="translated">onLayerEnd</target>
        </trans-unit>
        <trans-unit id="6010d31025036ae4e749a8b5c4d5bc7058a8c6f4" translate="yes" xml:space="preserve">
          <source>onLayerEnd is called with the following arguments:</source>
          <target state="translated">onLayerEnd调用的参数如下。</target>
        </trans-unit>
        <trans-unit id="b01854b4ccf9ea6577756f43de48539c45cd34d9" translate="yes" xml:space="preserve">
          <source>onLayerEnd: function (write, data)</source>
          <target state="translated">onLayerEnd:函数 (write,data)</target>
        </trans-unit>
        <trans-unit id="4ec3dc925c02508cf421d1fa6fa05251616d92d3" translate="yes" xml:space="preserve">
          <source>one.js</source>
          <target state="translated">one.js</target>
        </trans-unit>
        <trans-unit id="da3a307e7a7ab71834fdcca6a6af66dcf9eeebce" translate="yes" xml:space="preserve">
          <source>or in a build profile. In a &lt;strong&gt;build.js&lt;/strong&gt;, the same command line arguments can be specified like so:</source>
          <target state="translated">或在构建配置文件中。在&lt;strong&gt;build.js中&lt;/strong&gt;，可以像下面这样指定相同的命令行参数：</target>
        </trans-unit>
        <trans-unit id="1d9ad0addee82809659247e9008e6f9e82aa9000" translate="yes" xml:space="preserve">
          <source>or:</source>
          <target state="translated">or:</target>
        </trans-unit>
        <trans-unit id="7030d0b2f71b999ff89a343de08c414af32fc93a" translate="yes" xml:space="preserve">
          <source>package.json</source>
          <target state="translated">package.json</target>
        </trans-unit>
        <trans-unit id="d8ae088aee969371bf4ed994e9106b5d3e799c35" translate="yes" xml:space="preserve">
          <source>packages</source>
          <target state="translated">packages</target>
        </trans-unit>
        <trans-unit id="1910200239e6caafdd7288bf98705c63894fa1e7" translate="yes" xml:space="preserve">
          <source>participate in a workable module system for JS in the browser today.</source>
          <target state="translated">参与今天浏览器中JS的可行模块系统。</target>
        </trans-unit>
        <trans-unit id="0c6eeceb6e5744cc0a0a7d55d06e7292f43c9f8c" translate="yes" xml:space="preserve">
          <source>paths</source>
          <target state="translated">paths</target>
        </trans-unit>
        <trans-unit id="55431d04ee22f086c0e4730ad2d0ad6ba1df9215" translate="yes" xml:space="preserve">
          <source>paths config fallbacks</source>
          <target state="translated">路径配置回退</target>
        </trans-unit>
        <trans-unit id="3247077e9f813f61c28294ebf0b04fa7b7e763f6" translate="yes" xml:space="preserve">
          <source>pluginBuilder</source>
          <target state="translated">pluginBuilder</target>
        </trans-unit>
        <trans-unit id="d37b10be4b23b3a5407225d5efaed1c9d5e4e805" translate="yes" xml:space="preserve">
          <source>project-directory/</source>
          <target state="translated">project-directory/</target>
        </trans-unit>
        <trans-unit id="055c5bd0721336c320466362c116cc9e22059fd0" translate="yes" xml:space="preserve">
          <source>project.html</source>
          <target state="translated">project.html</target>
        </trans-unit>
        <trans-unit id="e6c30fb20717a4f9320c2216f6eb104985e6e25d" translate="yes" xml:space="preserve">
          <source>r.js (The r.js optimizer from &lt;a href=&quot;http://requirejs.org/docs/download.html#rjs&quot;&gt;download page&lt;/a&gt;)</source>
          <target state="translated">r.js（&lt;a href=&quot;http://requirejs.org/docs/download.html#rjs&quot;&gt;下载页面上&lt;/a&gt;的r.js优化器）</target>
        </trans-unit>
        <trans-unit id="d167818bd51e72c059598e330a28144029cd8fc5" translate="yes" xml:space="preserve">
          <source>require('requirejs')</source>
          <target state="translated">require('requirejs')</target>
        </trans-unit>
        <trans-unit id="3558129c06c8b15607f833dd7dfd9f07eeda7dfe" translate="yes" xml:space="preserve">
          <source>require([]) errbacks</source>
          <target state="translated">要求([])errbacks</target>
        </trans-unit>
        <trans-unit id="3eddd1f1e5f1762adabfa0582463ae368a1590f8" translate="yes" xml:space="preserve">
          <source>require.js</source>
          <target state="translated">require.js</target>
        </trans-unit>
        <trans-unit id="52b4004b2a5f9427f8ae9be275de601264335e33" translate="yes" xml:space="preserve">
          <source>script.onerror does not work in IE 6-8. There is no way to know if loading a script generates a 404, worse, it triggers the onreadystatechange with a complete state even in a 404 case.</source>
          <target state="translated">script.onerror在IE6-8中不起作用。没有办法知道加载脚本是否会产生404,更糟糕的是,即使在404的情况下,它也会以一个完整的状态触发onreadystatechange。</target>
        </trans-unit>
        <trans-unit id="1da4f66f62a84398d6a63d2bdcbb0c6bbfb2ae9f" translate="yes" xml:space="preserve">
          <source>script.onerror does work in IE 9+, but it has a bug where it does not fire script.onload event handlers right after execution of script, so it cannot support the standard method of allowing anonymous AMD modules. So script.onreadystatechange is still used. However, onreadystatechange fires with a complete state before the script.onerror function fires.</source>
          <target state="translated">script.onerror在IE 9+中确实可以使用,但它有一个bug,即在执行脚本后不能立即启动script.onload事件处理程序,所以它不能支持允许匿名AMD模块的标准方法。所以仍然使用script.onreadystatechange。但是,onreadystatechange在script.onerror函数发射之前,会以完整的状态发射。</target>
        </trans-unit>
        <trans-unit id="7818b054440ca239beb44d0b0991165ee0ad46f4" translate="yes" xml:space="preserve">
          <source>scriptType</source>
          <target state="translated">scriptType</target>
        </trans-unit>
        <trans-unit id="16728d18790deb58b3b8c1df74f06e536b532695" translate="yes" xml:space="preserve">
          <source>scripts</source>
          <target state="translated">scripts</target>
        </trans-unit>
        <trans-unit id="0cec61d8fab53349479d2fc0899c8c9fdc57a2c5" translate="yes" xml:space="preserve">
          <source>scripts/</source>
          <target state="translated">scripts/</target>
        </trans-unit>
        <trans-unit id="089017cedf29ba7955e32e88c25d3948b4f3fdea" translate="yes" xml:space="preserve">
          <source>shim</source>
          <target state="translated">shim</target>
        </trans-unit>
        <trans-unit id="357d6240a2159a33c8d69670dbeaf60f751f6066" translate="yes" xml:space="preserve">
          <source>skipDataMain</source>
          <target state="translated">skipDataMain</target>
        </trans-unit>
        <trans-unit id="94a86d6fcf88d9b98c51727a4b90aa8812e2c49e" translate="yes" xml:space="preserve">
          <source>some/</source>
          <target state="translated">some/</target>
        </trans-unit>
        <trans-unit id="94af276c25727779efc4cfa45d83a3c73f4be23c" translate="yes" xml:space="preserve">
          <source>store.js</source>
          <target state="translated">store.js</target>
        </trans-unit>
        <trans-unit id="8ca15b529f630f7ce97e77cae45b2785290b1404" translate="yes" xml:space="preserve">
          <source>store/</source>
          <target state="translated">store/</target>
        </trans-unit>
        <trans-unit id="a41e737bdcb57316f3b931ebc708a240ae2684de" translate="yes" xml:space="preserve">
          <source>sub.js</source>
          <target state="translated">sub.js</target>
        </trans-unit>
        <trans-unit id="a18864cfdb7cf1305a2ae73d6709348bf2a1be5a" translate="yes" xml:space="preserve">
          <source>the optimization could overwrite or place files outside the output directory. For those cases, create a &lt;strong&gt;paths&lt;/strong&gt; config to map that file to a local name, like:</source>
          <target state="translated">优化可能会覆盖文件或将文件放置在输出目录之外。对于这些情况，请创建&lt;strong&gt;路径&lt;/strong&gt;配置以将该文件映射到本地名称，例如：</target>
        </trans-unit>
        <trans-unit id="e76fa894c07e30c55a48e7c792952c4491d0cd8d" translate="yes" xml:space="preserve">
          <source>the tooling dependency cost</source>
          <target state="translated">模具依赖性成本</target>
        </trans-unit>
        <trans-unit id="2750d4c188b4b1a71febebc268725da0cb849812" translate="yes" xml:space="preserve">
          <source>then just pass the build profile's file name to the optimizer:</source>
          <target state="translated">然后将构建配置文件的文件名传给优化器即可。</target>
        </trans-unit>
        <trans-unit id="bf8b5529b79e43921112789bda96246277ea7d0f" translate="yes" xml:space="preserve">
          <source>then use name:</source>
          <target state="translated">然后用名字。</target>
        </trans-unit>
        <trans-unit id="c441435c0602c49b97cc1e421949a1f5095cd1fb" translate="yes" xml:space="preserve">
          <source>three.js</source>
          <target state="translated">three.js</target>
        </trans-unit>
        <trans-unit id="4ddfb1710fe5f5980cb00ef5dd17923d67356df7" translate="yes" xml:space="preserve">
          <source>two.js</source>
          <target state="translated">two.js</target>
        </trans-unit>
        <trans-unit id="cf67f0d1ebbbec2dd994c75b048536c4cd0b757e" translate="yes" xml:space="preserve">
          <source>urlArgs</source>
          <target state="translated">urlArgs</target>
        </trans-unit>
        <trans-unit id="e0971e2c6fc32a880b2a4273d8cd19d12b256a30" translate="yes" xml:space="preserve">
          <source>use existing AMD tooling to optimize their project</source>
          <target state="translated">使用现有的AMD工具来优化他们的项目</target>
        </trans-unit>
        <trans-unit id="44317b82ece1d6cd2d98c56b0e42b6ace033067f" translate="yes" xml:space="preserve">
          <source>use more options for code loading, delayed loading</source>
          <target state="translated">使用更多的代码加载选项,延迟加载。</target>
        </trans-unit>
        <trans-unit id="d3b2ef2f2fe3412d2bdf5d97d5d41fe37cf0e715" translate="yes" xml:space="preserve">
          <source>util.js</source>
          <target state="translated">util.js</target>
        </trans-unit>
        <trans-unit id="8f91e15d036639328135c4f04e40da6bdfdf31aa" translate="yes" xml:space="preserve">
          <source>waitSeconds</source>
          <target state="translated">waitSeconds</target>
        </trans-unit>
        <trans-unit id="bdb53d29bbbbaa4071ae3637cca5a02d7bba4c4e" translate="yes" xml:space="preserve">
          <source>where the main.js module looks like this:</source>
          <target state="translated">其中main.js模块看起来像这样。</target>
        </trans-unit>
        <trans-unit id="535e4e9b361a4e62b7649966552382e07ec58337" translate="yes" xml:space="preserve">
          <source>will return the current document when used as a loader plugin:</source>
          <target state="translated">当作为加载器插件使用时,将返回当前文档。</target>
        </trans-unit>
        <trans-unit id="0adb626f023cbc31f0be36d86bd7e915c1af3143" translate="yes" xml:space="preserve">
          <source>worse debugging, a cost that continues to add up over time</source>
          <target state="translated">更差的调试,随着时间的推移,成本不断增加。</target>
        </trans-unit>
        <trans-unit id="e1d0c6c1c29e6ad5164072a5b21340dca7fcb052" translate="yes" xml:space="preserve">
          <source>write</source>
          <target state="translated">write</target>
        </trans-unit>
        <trans-unit id="5ae459e45b554a20a34db9cf6e8545cfa6f52ddd" translate="yes" xml:space="preserve">
          <source>write: function (pluginName, moduleName, write)</source>
          <target state="translated">写:函数(插件名,模块名,写)</target>
        </trans-unit>
        <trans-unit id="6b8257fc78666892f1dfe434d6373f1c5b7bdfaf" translate="yes" xml:space="preserve">
          <source>writeFile</source>
          <target state="translated">writeFile</target>
        </trans-unit>
        <trans-unit id="ee09b7c80317309eef991c850400f0f5da599fcd" translate="yes" xml:space="preserve">
          <source>writeFile: function (pluginName, name, parentRequire, write)</source>
          <target state="translated">writeFile:函数 (pluginName,name,parentRequire,write)</target>
        </trans-unit>
        <trans-unit id="0e547e2244cf8baca179b01e93513122cc2fdef1" translate="yes" xml:space="preserve">
          <source>www/</source>
          <target state="translated">www/</target>
        </trans-unit>
        <trans-unit id="152de8eee480369bd7bffe90947136dd08b6baa2" translate="yes" xml:space="preserve">
          <source>xhtml</source>
          <target state="translated">xhtml</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
