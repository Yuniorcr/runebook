<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="qt">
    <body>
      <group id="qt">
        <trans-unit id="e61d9471b625721deef3aadb0f7d0788f0c1609f" translate="yes" xml:space="preserve">
          <source>WebSocket.Closed</source>
          <target state="translated">WebSocket.Closed</target>
        </trans-unit>
        <trans-unit id="8060dacca324ea6834f12add4e6ad4b5a5d8c5fb" translate="yes" xml:space="preserve">
          <source>WebSocket.Closing</source>
          <target state="translated">WebSocket.Closing</target>
        </trans-unit>
        <trans-unit id="d89bb864dd8411352adc93f162846c1e76f98167" translate="yes" xml:space="preserve">
          <source>WebSocket.Connecting</source>
          <target state="translated">WebSocket.Connecting</target>
        </trans-unit>
        <trans-unit id="8d33f5112eb8775758c6b56599ad961f90b59d76" translate="yes" xml:space="preserve">
          <source>WebSocket.Error</source>
          <target state="translated">WebSocket.Error</target>
        </trans-unit>
        <trans-unit id="0e5c5102b7d8a33607bf1e420c4cc5204e27f78b" translate="yes" xml:space="preserve">
          <source>WebSocket.Open</source>
          <target state="translated">WebSocket.Open</target>
        </trans-unit>
        <trans-unit id="db6f59a2cd8416b06e33169678e26c5820213d03" translate="yes" xml:space="preserve">
          <source>WebSocket.active</source>
          <target state="translated">WebSocket.active</target>
        </trans-unit>
        <trans-unit id="56c5cc2e30c870b6ef0f3383441976f3e7d57f04" translate="yes" xml:space="preserve">
          <source>WebSocket.binaryMessageReceived()</source>
          <target state="translated">WebSocket.binaryMessageReceived()</target>
        </trans-unit>
        <trans-unit id="5763fe824ff6d3a08edfc10753f2027a2d6a1f90" translate="yes" xml:space="preserve">
          <source>WebSocket.errorString</source>
          <target state="translated">WebSocket.errorString</target>
        </trans-unit>
        <trans-unit id="310eeece1712c29e5bc5487bd1d4b1640253b6c2" translate="yes" xml:space="preserve">
          <source>WebSocket.sendBinaryMessage()</source>
          <target state="translated">WebSocket.sendBinaryMessage()</target>
        </trans-unit>
        <trans-unit id="8dbaff249c36d4481ae2fec17762fdd9c3b87ffc" translate="yes" xml:space="preserve">
          <source>WebSocket.sendTextMessage()</source>
          <target state="translated">WebSocket.sendTextMessage()</target>
        </trans-unit>
        <trans-unit id="37364bf0ebcb82b04781aebf4c68037887d9d6f3" translate="yes" xml:space="preserve">
          <source>WebSocket.status</source>
          <target state="translated">WebSocket.status</target>
        </trans-unit>
        <trans-unit id="3cc530c3bc22ae3bc0c43697c081c73ad94ba0e4" translate="yes" xml:space="preserve">
          <source>WebSocket.statusChanged()</source>
          <target state="translated">WebSocket.statusChanged()</target>
        </trans-unit>
        <trans-unit id="f277032aed27e61917fc53c0484a1faca9baeb36" translate="yes" xml:space="preserve">
          <source>WebSocket.textMessageReceived()</source>
          <target state="translated">WebSocket.textMessageReceived()</target>
        </trans-unit>
        <trans-unit id="da6cc56cf140f2ed0d8b14abefcba008bbbbac16" translate="yes" xml:space="preserve">
          <source>WebSocket.url</source>
          <target state="translated">WebSocket.url</target>
        </trans-unit>
        <trans-unit id="cbcc02f604b303085a9eb27ce020efca2fe6fb16" translate="yes" xml:space="preserve">
          <source>WebSocketServer (QML type)</source>
          <target state="translated">WebSocketServer(QML类型</target>
        </trans-unit>
        <trans-unit id="59eb48fb5e578c992c80eb5d1735a548c3485a2f" translate="yes" xml:space="preserve">
          <source>WebSocketServer QML Type</source>
          <target state="translated">WebSocketServer QML类型</target>
        </trans-unit>
        <trans-unit id="f0984c31280831a4b32bfd8d165a82be068d5685" translate="yes" xml:space="preserve">
          <source>WebSocketServer.accept</source>
          <target state="translated">WebSocketServer.accept</target>
        </trans-unit>
        <trans-unit id="359c97d289adebae04f76520ed53c912c60c9fd4" translate="yes" xml:space="preserve">
          <source>WebSocketServer.clientConnected()</source>
          <target state="translated">WebSocketServer.clientConnected()</target>
        </trans-unit>
        <trans-unit id="aaa9d4c78cf42b8b05a18ca01b59d05e30d14641" translate="yes" xml:space="preserve">
          <source>WebSocketServer.errorString</source>
          <target state="translated">WebSocketServer.errorString</target>
        </trans-unit>
        <trans-unit id="535675aa78403b22a6a51f65e564e3090f275e92" translate="yes" xml:space="preserve">
          <source>WebSocketServer.host</source>
          <target state="translated">WebSocketServer.host</target>
        </trans-unit>
        <trans-unit id="157bacbaaf16348d61b09b426cc9c21914e9e5c3" translate="yes" xml:space="preserve">
          <source>WebSocketServer.listen</source>
          <target state="translated">WebSocketServer.listen</target>
        </trans-unit>
        <trans-unit id="9be1ccf63936479971942fee2b07172abfec1f86" translate="yes" xml:space="preserve">
          <source>WebSocketServer.name</source>
          <target state="translated">WebSocketServer.name</target>
        </trans-unit>
        <trans-unit id="9cd8d098ee821f71e181e344387870a4eaf2643c" translate="yes" xml:space="preserve">
          <source>WebSocketServer.port</source>
          <target state="translated">WebSocketServer.port</target>
        </trans-unit>
        <trans-unit id="865df754f1ce58a620fe7b77813a7c5705f8c766" translate="yes" xml:space="preserve">
          <source>WebSocketServer.url</source>
          <target state="translated">WebSocketServer.url</target>
        </trans-unit>
        <trans-unit id="92682047ba3e7591bb24088901125f72478cfdc1" translate="yes" xml:space="preserve">
          <source>WebSockets is a web technology providing full-duplex communications channels over a single TCP connection. The WebSocket protocol was standardized by the IETF as &lt;a href=&quot;http://tools.ietf.org/html/rfc6455&quot;&gt;RFC 6455&lt;/a&gt; in 2011.</source>
          <target state="translated">WebSockets是一种Web技术，可通过单个TCP连接提供全双工通信通道。&lt;a href=&quot;http://tools.ietf.org/html/rfc6455&quot;&gt;ISocket&lt;/a&gt;在2011年将WebSocket协议标准化为RFC 6455。</target>
        </trans-unit>
        <trans-unit id="5bbf95174bc33ee859e5b9ceeecf5168f4ac0bb8" translate="yes" xml:space="preserve">
          <source>WebSockets is a web technology providing full-duplex communications channels over a single TCP connection. The WebSocket protocol was standardized by the IETF as &lt;a href=&quot;http://tools.ietf.org/html/rfc6455&quot;&gt;RFC 6455&lt;/a&gt; in 2011. QWebSocket can both be used in a client application and server application.</source>
          <target state="translated">WebSockets是一种Web技术，可通过单个TCP连接提供全双工通信通道。WebSocket协议由IETF标准化的&lt;a href=&quot;http://tools.ietf.org/html/rfc6455&quot;&gt;RFC 6455&lt;/a&gt;，2011年QWebSocket既可以在客户端应用程序和服务器应用程序中使用。</target>
        </trans-unit>
        <trans-unit id="5fd8957203d02449a377e9d4b44ec5f9d48ec525" translate="yes" xml:space="preserve">
          <source>WebSockets is a web technology providing full-duplex communications channels over a single TCP connection. The WebSocket protocol was standardized by the IETF as &lt;a href=&quot;http://tools.ietf.org/html/rfc6455#&quot;&gt;RFC 6455&lt;/a&gt; in 2011.</source>
          <target state="translated">WebSockets是一种Web技术，可通过单个TCP连接提供全双工通信通道。&lt;a href=&quot;http://tools.ietf.org/html/rfc6455#&quot;&gt;ISocket&lt;/a&gt;在2011年将WebSocket协议标准化为RFC 6455。</target>
        </trans-unit>
        <trans-unit id="b1e215712971ac4baed9570ad13a61bb4aa3b781" translate="yes" xml:space="preserve">
          <source>WebSockets is a web technology providing full-duplex communications channels over a single TCP connection. The WebSocket protocol was standardized by the IETF as &lt;a href=&quot;http://tools.ietf.org/html/rfc6455#&quot;&gt;RFC 6455&lt;/a&gt; in 2011. &lt;a href=&quot;qwebsocket&quot;&gt;QWebSocket&lt;/a&gt; can both be used in a client application and server application.</source>
          <target state="translated">WebSockets是一种Web技术，可通过单个TCP连接提供全双工通信通道。WebSocket协议由IETF标准化的&lt;a href=&quot;http://tools.ietf.org/html/rfc6455#&quot;&gt;RFC 6455&lt;/a&gt;，2011年&lt;a href=&quot;qwebsocket&quot;&gt;QWebSocket&lt;/a&gt;既可以在客户端应用程序和服务器应用程序中使用。</target>
        </trans-unit>
        <trans-unit id="885c489c2f8a6b92120e69b5de2b45883f6775d7" translate="yes" xml:space="preserve">
          <source>WebView (QML type)</source>
          <target state="translated">WebView(QML类型)</target>
        </trans-unit>
        <trans-unit id="827b614033071efc2c63d65d4d993276c73e78d9" translate="yes" xml:space="preserve">
          <source>WebView QML Type</source>
          <target state="translated">WebView QML类型</target>
        </trans-unit>
        <trans-unit id="60ad3113ffbc0e282758fe58145cf1d87e572865" translate="yes" xml:space="preserve">
          <source>WebView is a component for displaying web content which is implemented using native APIs on the platforms where this is available, thus it does not necessarily require including a full web browser stack as part of the application.</source>
          <target state="translated">WebView是一个用于显示Web内容的组件,它是在可用的平台上使用本地API实现的,因此它不一定需要包括一个完整的Web浏览器栈作为应用程序的一部分。</target>
        </trans-unit>
        <trans-unit id="eb851872c2b19c6866cc3cc03a0b186c029b54c7" translate="yes" xml:space="preserve">
          <source>WebView.canGoBack</source>
          <target state="translated">WebView.canGoBack</target>
        </trans-unit>
        <trans-unit id="556e772d7de6288fda4aa834440fd82a3e3a10d8" translate="yes" xml:space="preserve">
          <source>WebView.canGoForward</source>
          <target state="translated">WebView.canGoForward</target>
        </trans-unit>
        <trans-unit id="01d6d30ec35ee9c1968486d53a2fb2f158b32936" translate="yes" xml:space="preserve">
          <source>WebView.goBack()</source>
          <target state="translated">WebView.goBack()</target>
        </trans-unit>
        <trans-unit id="c77dd030343e8691f50153905d45045b9a035094" translate="yes" xml:space="preserve">
          <source>WebView.goForward()</source>
          <target state="translated">WebView.goForward()</target>
        </trans-unit>
        <trans-unit id="9dde0190ed7f65f72974fc0e3c6608c032e653d6" translate="yes" xml:space="preserve">
          <source>WebView.httpUserAgent</source>
          <target state="translated">WebView.httpUserAgent</target>
        </trans-unit>
        <trans-unit id="eeb64200760896a269ab89b4d9c2bfef845ddc95" translate="yes" xml:space="preserve">
          <source>WebView.loadHtml()</source>
          <target state="translated">WebView.loadHtml()</target>
        </trans-unit>
        <trans-unit id="5aea0e54040c329364fb04bd8dd6d978cd0e8865" translate="yes" xml:space="preserve">
          <source>WebView.loadProgress</source>
          <target state="translated">WebView.loadProgress</target>
        </trans-unit>
        <trans-unit id="4dde43a37f9096ec81c9e6e13d4a24d10fa86aa5" translate="yes" xml:space="preserve">
          <source>WebView.loading</source>
          <target state="translated">WebView.loading</target>
        </trans-unit>
        <trans-unit id="cc3580281e13aa2c2728e82f2e47cca9b4ac1105" translate="yes" xml:space="preserve">
          <source>WebView.loadingChanged()</source>
          <target state="translated">WebView.loadingChanged()</target>
        </trans-unit>
        <trans-unit id="4250949ce6ab33ee1d1b397b0eafd9d9191265eb" translate="yes" xml:space="preserve">
          <source>WebView.reload()</source>
          <target state="translated">WebView.reload()</target>
        </trans-unit>
        <trans-unit id="bb7c173227b6fe376635f6a86dc62a11e8c81f96" translate="yes" xml:space="preserve">
          <source>WebView.runJavaScript()</source>
          <target state="translated">WebView.runJavaScript()</target>
        </trans-unit>
        <trans-unit id="ad4f865b54e60ed0553766b4d83085e8c9f739b4" translate="yes" xml:space="preserve">
          <source>WebView.stop()</source>
          <target state="translated">WebView.stop()</target>
        </trans-unit>
        <trans-unit id="51058de9d4c17d3a06dad9e94c9dd019a6af2192" translate="yes" xml:space="preserve">
          <source>WebView.title</source>
          <target state="translated">WebView.title</target>
        </trans-unit>
        <trans-unit id="55d62d15c787df0ade5a06967d4bee9479e57217" translate="yes" xml:space="preserve">
          <source>WebView.url</source>
          <target state="translated">WebView.url</target>
        </trans-unit>
        <trans-unit id="b7dd5e35810f2f266ea2c30c1406f512aff95c79" translate="yes" xml:space="preserve">
          <source>WebViewLoadRequest (QML type)</source>
          <target state="translated">WebViewLoadRequest(QML类型)</target>
        </trans-unit>
        <trans-unit id="671970c5ad73340915882761c18aeed9b56dfd20" translate="yes" xml:space="preserve">
          <source>WebViewLoadRequest QML Type</source>
          <target state="translated">WebViewLoadRequest QML类型</target>
        </trans-unit>
        <trans-unit id="6d4810263b5877644513482ef317753320da38d1" translate="yes" xml:space="preserve">
          <source>WebViewLoadRequest.errorString</source>
          <target state="translated">WebViewLoadRequest.errorString</target>
        </trans-unit>
        <trans-unit id="da974673bad7a25a2af8556daff61f7ac1806de3" translate="yes" xml:space="preserve">
          <source>WebViewLoadRequest.status</source>
          <target state="translated">WebViewLoadRequest.status</target>
        </trans-unit>
        <trans-unit id="67d567b06712313ae43fbbdf0081d93f362b5a30" translate="yes" xml:space="preserve">
          <source>WebViewLoadRequest.url</source>
          <target state="translated">WebViewLoadRequest.url</target>
        </trans-unit>
        <trans-unit id="b3e03ae44af4edfd2f0f6785a95b2d981795aff6" translate="yes" xml:space="preserve">
          <source>Websockify v0.8.0 can be used to tunnel TCP connections with QT5.12 but it is MANDATORY to specify the base64 or binary subprotocols before calling &lt;a href=&quot;qwebsocket#open&quot;&gt;QWebSocket::open&lt;/a&gt;().</source>
          <target state="translated">Websockify v0.8.0可用于通过QT5.12建立TCP连接，但是在调用&lt;a href=&quot;qwebsocket#open&quot;&gt;QWebSocket :: open&lt;/a&gt;（）之前必须指定base64或二进制子协议。</target>
        </trans-unit>
        <trans-unit id="892b2561ad6ab98eb62ee45038da884a629b1645" translate="yes" xml:space="preserve">
          <source>Week numbers can be displayed by setting the &lt;a href=&quot;qml-qtquick-controls-calendar#weekNumbersVisible-prop&quot;&gt;weekNumbersVisible&lt;/a&gt; property to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">可以通过将&lt;a href=&quot;qml-qtquick-controls-calendar#weekNumbersVisible-prop&quot;&gt;weekNumbersVisible&lt;/a&gt;属性设置为 &lt;code&gt;true&lt;/code&gt; 来显示星期数。</target>
        </trans-unit>
        <trans-unit id="86019d0d92d2931aad4fe9f82b8882eb97f7ecce" translate="yes" xml:space="preserve">
          <source>WeekNumberColumn</source>
          <target state="translated">WeekNumberColumn</target>
        </trans-unit>
        <trans-unit id="eb5bc02155c1c98619e903c3304fa59dbb999a5c" translate="yes" xml:space="preserve">
          <source>WeekNumberColumn (QML type)</source>
          <target state="translated">周数列(QML类型)</target>
        </trans-unit>
        <trans-unit id="767a943073d98b5d3856df88505b41707b294713" translate="yes" xml:space="preserve">
          <source>WeekNumberColumn QML Type</source>
          <target state="translated">WeekNumberColumn QML类型</target>
        </trans-unit>
        <trans-unit id="372555342327281ca705f0ee17ec4c1ef2ef29cb" translate="yes" xml:space="preserve">
          <source>WeekNumberColumn can be used as a standalone control, but it is most often used in conjunction with &lt;a href=&quot;qml-qt-labs-calendar-monthgrid&quot;&gt;MonthGrid&lt;/a&gt;. Regardless of the use case, positioning of the column is left to the user.</source>
          <target state="translated">WeekNumberColumn可以用作独立控件，但最常与&lt;a href=&quot;qml-qt-labs-calendar-monthgrid&quot;&gt;MonthGrid&lt;/a&gt;结合使用。不管用例如何，列的位置都留给用户。</target>
        </trans-unit>
        <trans-unit id="878ff9270f4ec7eb69939dec114a6573d4826524" translate="yes" xml:space="preserve">
          <source>WeekNumberColumn presents week numbers in a column. The week numbers are calculated for a given &lt;a href=&quot;qml-qt-labs-calendar-weeknumbercolumn#month-prop&quot;&gt;month&lt;/a&gt; and &lt;a href=&quot;qml-qt-labs-calendar-weeknumbercolumn#year-prop&quot;&gt;year&lt;/a&gt;, using the specified &lt;a href=&quot;qml-qtquick-controls2-control#locale-prop&quot;&gt;locale&lt;/a&gt;.</source>
          <target state="translated">WeekNumberColumn在列中显示星期数。使用指定的&lt;a href=&quot;qml-qtquick-controls2-control#locale-prop&quot;&gt;语言环境&lt;/a&gt;，针对给定的&lt;a href=&quot;qml-qt-labs-calendar-weeknumbercolumn#month-prop&quot;&gt;月份&lt;/a&gt;和&lt;a href=&quot;qml-qt-labs-calendar-weeknumbercolumn#year-prop&quot;&gt;年份&lt;/a&gt;计算周数。</target>
        </trans-unit>
        <trans-unit id="9a13d84329d5dafdcb7f822e38ae3fff10b4085a" translate="yes" xml:space="preserve">
          <source>WeekNumberColumn.delegate</source>
          <target state="translated">WeekNumberColumn.delegate</target>
        </trans-unit>
        <trans-unit id="b447d1091ed7dd1bebd00325ab31ce82bed51d92" translate="yes" xml:space="preserve">
          <source>WeekNumberColumn.month</source>
          <target state="translated">WeekNumberColumn.month</target>
        </trans-unit>
        <trans-unit id="943a91646ed56fac3a15b75c4dcd4a7788108cb3" translate="yes" xml:space="preserve">
          <source>WeekNumberColumn.year</source>
          <target state="translated">WeekNumberColumn.year</target>
        </trans-unit>
        <trans-unit id="3a391c5b1f457da2b6172f7c76fc4d1dfae3cf44" translate="yes" xml:space="preserve">
          <source>Weight Scale UUID (service). The Weight Scale service exposes weight-related data from a scale for consumer healthcare, sports and fitness applications.</source>
          <target state="translated">体重秤UUID(服务)。体重秤服务从秤上公开与体重相关的数据,用于消费保健、运动和健身应用。</target>
        </trans-unit>
        <trans-unit id="f767308ef7f2c48da453802b956e6a2d317eda45" translate="yes" xml:space="preserve">
          <source>Well behaved models also implement &lt;a href=&quot;qabstractitemmodel#headerData&quot;&gt;headerData()&lt;/a&gt; to give tree and table views something to display in their headers.</source>
          <target state="translated">行为良好的模型还实现了&lt;a href=&quot;qabstractitemmodel#headerData&quot;&gt;headerData（），&lt;/a&gt;以使树形视图和表视图可以在其标题中显示。</target>
        </trans-unit>
        <trans-unit id="972f7f5cddb5bc76ac084ff923c82ffdb94fcb74" translate="yes" xml:space="preserve">
          <source>Well written Qt Quick 3D applications are expected to call &lt;a href=&quot;qquick3d#idealSurfaceFormat&quot;&gt;QQuick3D::idealSurfaceFormat&lt;/a&gt;() in their main() function, and use the returned &lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat&lt;/a&gt; as the default:</source>
          <target state="translated">编写良好的Qt Quick 3D应用程序应在其main（）函数中调用&lt;a href=&quot;qquick3d#idealSurfaceFormat&quot;&gt;QQuick3D :: idealSurfaceFormat&lt;/a&gt;（），并使用返回的&lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat&lt;/a&gt;作为默认值：</target>
        </trans-unit>
        <trans-unit id="97211a8888128314d9ca34d1005f08cb83ed5d9c" translate="yes" xml:space="preserve">
          <source>What</source>
          <target state="translated">What</target>
        </trans-unit>
        <trans-unit id="3a91b96d5e68c04a34191d75ec30f85511472e43" translate="yes" xml:space="preserve">
          <source>What Happens If A State Is Exited Before The Animation Has Finished</source>
          <target state="translated">如果一个国家在动画完成前退出会发生什么?</target>
        </trans-unit>
        <trans-unit id="a5b95866b545f293e2c22baf583addd6955adb06" translate="yes" xml:space="preserve">
          <source>What Qt Wayland Offers</source>
          <target state="translated">Qt Wayland提供什么</target>
        </trans-unit>
        <trans-unit id="f1c7876c2431b585c32362c45a116d39b49e3fb2" translate="yes" xml:space="preserve">
          <source>What arguments can appear in square brackets?</source>
          <target state="translated">哪些参数可以出现在方括号里?</target>
        </trans-unit>
        <trans-unit id="bf12281fadddea4a903c385214943b2396829309" translate="yes" xml:space="preserve">
          <source>What attribute of particles is directly affected.</source>
          <target state="translated">直接影响粒子的什么属性。</target>
        </trans-unit>
        <trans-unit id="f0d867763ab7110c3889573c8a2d94a48fcbf423" translate="yes" xml:space="preserve">
          <source>What do we mean by a combined 3D-2D scene?</source>
          <target state="translated">什么叫3D-2D结合的场景?</target>
        </trans-unit>
        <trans-unit id="f34508ff314363032e4898cf520c28d432b2fde5" translate="yes" xml:space="preserve">
          <source>What happens here is: when a child component is set on a spatial node of type &lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt;, it is first wrapped by a QQuick3DItem2D, which is just a container that adds 3D coordinates to a 2D item. This sets the base 3D transformation for how all further 2D children are rendered so that they appear correctly in the 3D scene.</source>
          <target state="translated">这里发生的是：当子组件设置在&lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt;类型的空间节点上时，它首先被QQuick3DItem2D包裹，QQuick3DItem2D只是一个将3D坐标添加到2D项的容器。这为所有其他2D子级的渲染方式设置了基础3D转换，以便它们在3D场景中正确显示。</target>
        </trans-unit>
        <trans-unit id="7561a585c86acefa327c8ff5c8e21bb71689528b" translate="yes" xml:space="preserve">
          <source>What happens if we switch the shader to sample &lt;code&gt;SCREEN_TEXTURE&lt;/code&gt; instead?</source>
          <target state="translated">如果我们将着色器切换为采样 &lt;code&gt;SCREEN_TEXTURE&lt;/code&gt; ,会发生什么情况？</target>
        </trans-unit>
        <trans-unit id="908189b95a2270b8d918aa650bd62e6015c86492" translate="yes" xml:space="preserve">
          <source>What happens if we switch this property to &lt;a href=&quot;qml-qtquick3d-custommaterial&quot;&gt;CustomMaterial&lt;/a&gt;.Unshaded?</source>
          <target state="translated">如果将此属性切换为&lt;a href=&quot;qml-qtquick3d-custommaterial&quot;&gt;CustomMaterial&lt;/a&gt; .Unshaded，会发生什么？</target>
        </trans-unit>
        <trans-unit id="052744ad88722c540c26b12167c015ec06975d82" translate="yes" xml:space="preserve">
          <source>What happens when you link depends on whether you use frameworks or not. We don't see a compelling reason to recommend one over the other.</source>
          <target state="translated">当你链接时会发生什么,取决于你是否使用框架。我们没有看到一个令人信服的理由来推荐一个而不是另一个。</target>
        </trans-unit>
        <trans-unit id="295e3792a1a059db7dcede99b827f01d3954a183" translate="yes" xml:space="preserve">
          <source>What if my input namespace is different from my output namespace?</source>
          <target state="translated">如果我的输入命名空间与输出命名空间不同怎么办?</target>
        </trans-unit>
        <trans-unit id="9a857dd2437938e703da57c58891b821e01a4c6b" translate="yes" xml:space="preserve">
          <source>What if we now replace &lt;a href=&quot;qml-qtquick3d-directionallight&quot;&gt;DirectionalLight&lt;/a&gt; with:</source>
          <target state="translated">如果我们现在将&lt;a href=&quot;qml-qtquick3d-directionallight&quot;&gt;DirectionalLight&lt;/a&gt;替换为：</target>
        </trans-unit>
        <trans-unit id="dfea7f098310df38f1c214fefbcd238c913a457f" translate="yes" xml:space="preserve">
          <source>What if we want to have 2D items within the 3D world, in a way that they truly participate in all 3D transforms? For example, can we have &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-text&quot;&gt;Text&lt;/a&gt; items placed within the 3D world, in a way that they follow the cube's rotation and are always placed above it?</source>
          <target state="translated">如果我们想在3D世界中拥有2D物品，使它们真正参与所有3D变换，该怎么办？例如，是否可以将&lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt;和&lt;a href=&quot;qml-qtquick-text&quot;&gt;Text&lt;/a&gt;项目放置在3D世界中，以使其跟随多维数据集的旋转并始终放置在其上方？</target>
        </trans-unit>
        <trans-unit id="12767e028b8b33b9ba47990cf494bbd3904aec84" translate="yes" xml:space="preserve">
          <source>What input method specific hints the widget has.</source>
          <target state="translated">小部件有哪些输入法具体提示。</target>
        </trans-unit>
        <trans-unit id="dc39b9a6e6f26aa6cc9a12da44be00aae7d22e33" translate="yes" xml:space="preserve">
          <source>What is &lt;code&gt;intermediateColorBuffer&lt;/code&gt;?</source>
          <target state="translated">什么是 &lt;code&gt;intermediateColorBuffer&lt;/code&gt; ？</target>
        </trans-unit>
        <trans-unit id="364007429eff8c97bc4d4b7e513270d89be657be" translate="yes" xml:space="preserve">
          <source>What is QML?</source>
          <target state="translated">什么是QML?</target>
        </trans-unit>
        <trans-unit id="e17b9340ad4720831c95a8522f08aa386cc292e2" translate="yes" xml:space="preserve">
          <source>What is Qt Quick?</source>
          <target state="translated">什么是Qt Quick?</target>
        </trans-unit>
        <trans-unit id="39ea9b04c66b4480d6c886a257db36daf4f2c330" translate="yes" xml:space="preserve">
          <source>What is a DITA Map?</source>
          <target state="translated">什么是DITA地图?</target>
        </trans-unit>
        <trans-unit id="f66eacd318bf68ecd7a4172da25f4cbffb450c37" translate="yes" xml:space="preserve">
          <source>What is important is the name of the directory that the qmldir is installed into. When the user imports our module, the QML engine uses the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtqml-modules-qmldir.html#contents-of-a-module-definition-qmldir-file&quot;&gt;module identifier&lt;/a&gt; (&lt;code&gt;TimeExample&lt;/code&gt;) to find the plugin, and so the directory in which it is installed must match the module identifier.</source>
          <target state="translated">重要的是安装qmldir的目录的名称。当用户导入我们的模块时，QML引擎使用&lt;a href=&quot;https://doc.qt.io/qt-5.13/qtqml-modules-qmldir.html#contents-of-a-module-definition-qmldir-file&quot;&gt;模块标识符&lt;/a&gt;（ &lt;code&gt;TimeExample&lt;/code&gt; ）查找插件，因此安装该插件的目录必须与模块标识符匹配。</target>
        </trans-unit>
        <trans-unit id="56ffda54cff84ae7c295711a906162e6f89179bb" translate="yes" xml:space="preserve">
          <source>What is important is the name of the directory that the qmldir is installed into. When the user imports our module, the QML engine uses the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtqml-modules-qmldir.html#contents-of-a-module-definition-qmldir-file&quot;&gt;module identifier&lt;/a&gt; (&lt;code&gt;TimeExample&lt;/code&gt;) to find the plugin, and so the directory in which it is installed must match the module identifier.</source>
          <target state="translated">重要的是安装qmldir的目录的名称。当用户导入我们的模块时，QML引擎使用&lt;a href=&quot;https://doc.qt.io/qt-5.15/qtqml-modules-qmldir.html#contents-of-a-module-definition-qmldir-file&quot;&gt;模块标识符&lt;/a&gt;（ &lt;code&gt;TimeExample&lt;/code&gt; ）查找插件，因此安装该插件的目录必须与模块标识符匹配。</target>
        </trans-unit>
        <trans-unit id="1d52da4aee68cede7718866985dfc8a83b58d382" translate="yes" xml:space="preserve">
          <source>What is important is the name of the directory that the qmldir is installed into. When the user imports our module, the QML engine uses the &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtqml-modules-qmldir.html#contents-of-a-module-definition-qmldir-file&quot;&gt;module identifier&lt;/a&gt; (&lt;code&gt;TimeExample&lt;/code&gt;) to find the plugin, and so the directory in which it is installed must match the module identifier.</source>
          <target state="translated">重要的是安装qmldir的目录的名称。当用户导入我们的模块时，QML引擎使用&lt;a href=&quot;https://doc.qt.io/qt-6.0/qtqml-modules-qmldir.html#contents-of-a-module-definition-qmldir-file&quot;&gt;模块标识符&lt;/a&gt;（ &lt;code&gt;TimeExample&lt;/code&gt; ）查找插件，因此安装该插件的目录必须与模块标识符匹配。</target>
        </trans-unit>
        <trans-unit id="9bc2635131e240dcafb2819e5d71d705d8f7a6f8" translate="yes" xml:space="preserve">
          <source>What properties have to be put inside a particular &lt;a href=&quot;qml-qtlocation-dynamicparameter&quot;&gt;DynamicParameter&lt;/a&gt; type for a particular plugin can be found in the documentation of the plugin. Note that DynamicParameters are &lt;b&gt;optional&lt;/b&gt;. By not specifying any of them, the Map will have the default behavior.</source>
          <target state="translated">在特定插件的特定&lt;a href=&quot;qml-qtlocation-dynamicparameter&quot;&gt;DynamicParameter&lt;/a&gt;类型内必须放置哪些属性，可以在该插件的文档中找到。请注意，DynamicParameters是&lt;b&gt;可选的&lt;/b&gt;。通过不指定它们中的任何一个，地图将具有默认行为。</target>
        </trans-unit>
        <trans-unit id="952f088fa16796aca403b0d7bd7990e7b8ea9015" translate="yes" xml:space="preserve">
          <source>What properties have to be put inside a particular DynamicParameter type for a particular plugin can be found in the documentation of the plugin.</source>
          <target state="translated">对于一个特定的插件,哪些属性必须放在特定的动态参数类型里面,可以在插件的文档中找到。</target>
        </trans-unit>
        <trans-unit id="99a2cceb544883c9d4fd8511523ad7e154e9e118" translate="yes" xml:space="preserve">
          <source>What tab should be set as current when &lt;a href=&quot;qtabbar#removeTab&quot;&gt;removeTab&lt;/a&gt; is called if the removed tab is also the current tab.</source>
          <target state="translated">如果删除的选项卡也是当前选项卡，则在调用&lt;a href=&quot;qtabbar#removeTab&quot;&gt;removeTab&lt;/a&gt;时应将哪个选项卡设置为当前选项卡。</target>
        </trans-unit>
        <trans-unit id="163d022685c2d4253cbf8f165ed04ffe6700c47d" translate="yes" xml:space="preserve">
          <source>What this example shows is possible to do with a &lt;a href=&quot;qml-qtquick3d-principledmaterial&quot;&gt;PrincipledMaterial&lt;/a&gt; too. Let's make it more interesting by doing a simple emboss effect in addition:</source>
          <target state="translated">此示例显示的内容也可以与&lt;a href=&quot;qml-qtquick3d-principledmaterial&quot;&gt;PrincipledMaterial&lt;/a&gt;一起使用。让我们通过做一个简单的浮雕效果使其更加有趣：</target>
        </trans-unit>
        <trans-unit id="197a93f48a709674005231e1863485534639c819" translate="yes" xml:space="preserve">
          <source>What this means is that you can implement as many controls as you like for your custom style, and place them almost anywhere. It also allows users to create their own styles for your application.</source>
          <target state="translated">这意味着你可以为你的自定义样式实现任意多的控件,并将它们放置在几乎任何地方。它还允许用户为你的应用程序创建自己的风格。</target>
        </trans-unit>
        <trans-unit id="1993c509dd0c5463e38a4a0589bef8931a264e63" translate="yes" xml:space="preserve">
          <source>What to do with the different client graphics buffers</source>
          <target state="translated">如何处理不同的客户端图形缓冲区?</target>
        </trans-unit>
        <trans-unit id="3febb8f0fb212ae52dcdb454cb322c2c1559a386" translate="yes" xml:space="preserve">
          <source>What you probably want to see instead are the &lt;code&gt;&amp;lt;recipe&amp;gt;&lt;/code&gt; elements that have empty &lt;code&gt;&amp;lt;method&amp;gt;&lt;/code&gt; elements:</source>
          <target state="translated">您可能希望看到的是具有空 &lt;code&gt;&amp;lt;method&amp;gt;&lt;/code&gt; 元素的 &lt;code&gt;&amp;lt;recipe&amp;gt;&lt;/code&gt; &amp;gt;元素：</target>
        </trans-unit>
        <trans-unit id="eb64e48286e9e39127222c2eb0330d37d629a5fd" translate="yes" xml:space="preserve">
          <source>What's New in Qt 6</source>
          <target state="translated">Qt 6的新功能</target>
        </trans-unit>
        <trans-unit id="625f45ed2e3f77661069fd0b4935ee10245cf794" translate="yes" xml:space="preserve">
          <source>What's New in Qt 6.0</source>
          <target state="translated">Qt 6.0中的新内容</target>
        </trans-unit>
        <trans-unit id="629d08df1df409e7886c5c11ef223e22e9e9fca7" translate="yes" xml:space="preserve">
          <source>What's new in Qt 4.7</source>
          <target state="translated">Qt 4.7中的新功能是什么?</target>
        </trans-unit>
        <trans-unit id="a8469d0d576ee5d765ed335f5bffcc22e8128055" translate="yes" xml:space="preserve">
          <source>Whatever form the underlying data structure takes, it is usually a good idea to supplement the standard &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; API in specialized models with one that allows more natural access to the underlying data structure. This makes it easier to populate the model with data, yet still enables other general model/view components to interact with it using the standard API. The model described below provides a custom constructor for just this purpose.</source>
          <target state="translated">无论基础数据结构采用什么形式，通常最好在专用模型中补充标准&lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; API，以允许更自然地访问基础数据结构。这样可以更轻松地用数据填充模型，但仍允许其他常规模型/视图组件使用标准API与之交互。下述模型为此提供了一个自定义构造函数。</target>
        </trans-unit>
        <trans-unit id="8eec75ee54baf1c26ea1a419c0e75e480e7d107b" translate="yes" xml:space="preserve">
          <source>WhatsThis</source>
          <target state="translated">WhatsThis</target>
        </trans-unit>
        <trans-unit id="ee3f5d5b9f3adb42ad9be6c7bc599808b7e12183" translate="yes" xml:space="preserve">
          <source>Wheel events are sent to the widget under the mouse cursor, but if that widget does not handle the event they are sent to the focus widget. Wheel events are generated for both mouse wheels and trackpad scroll gestures. There are two ways to read the wheel event delta: &lt;a href=&quot;qwheelevent#angleDelta&quot;&gt;angleDelta&lt;/a&gt;() returns the delta in wheel degrees. This value is always provided. &lt;a href=&quot;qwheelevent#pixelDelta&quot;&gt;pixelDelta&lt;/a&gt;() returns the delta in screen pixels and is available on platforms that have high-resolution trackpads, such as &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;. If that is the case, &lt;a href=&quot;qwheelevent#source&quot;&gt;source&lt;/a&gt;() will return &lt;a href=&quot;qt#MouseEventSource-enum&quot;&gt;Qt::MouseEventSynthesizedBySystem&lt;/a&gt;.</source>
          <target state="translated">Wheel事件将发送到鼠标光标下的小部件，但是如果该小部件不处理该事件，则会将它们发送到焦点小部件。鼠标滚轮和触控板滚动手势都会生成滚轮事件。有两种读取车轮事件增量的方法：&lt;a href=&quot;qwheelevent#angleDelta&quot;&gt;angleDelta&lt;/a&gt;（）返回车轮角度的增量。始终提供此值。&lt;a href=&quot;qwheelevent#pixelDelta&quot;&gt;pixelDelta&lt;/a&gt;（）返回以屏幕像素为单位的增量，并且在具有高分辨率触控板的平台（例如&lt;a href=&quot;internationalization#macos&quot;&gt;macOS）&lt;/a&gt;上可用。在这种情况下，&lt;a href=&quot;qwheelevent#source&quot;&gt;source&lt;/a&gt;（）将返回&lt;a href=&quot;qt#MouseEventSource-enum&quot;&gt;Qt :: MouseEventSynthesizedBySystem&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0dc3589de339aa1a5f758ca64eec3d34edfe4707" translate="yes" xml:space="preserve">
          <source>Wheel events are sent to the widget under the mouse cursor, but if that widget does not handle the event they are sent to the focus widget. Wheel events are generated for both mouse wheels and trackpad scroll gestures. There are two ways to read the wheel event delta: &lt;a href=&quot;qwheelevent#angleDelta&quot;&gt;angleDelta&lt;/a&gt;() returns the deltas in wheel degrees. These values are always provided. &lt;a href=&quot;qwheelevent#pixelDelta&quot;&gt;pixelDelta&lt;/a&gt;() returns the deltas in screen pixels, and is available on platforms that have high-resolution trackpads, such as macOS. If that is the case, &lt;a href=&quot;qinputevent#device&quot;&gt;device&lt;/a&gt;()-&amp;gt;&lt;a href=&quot;qevent#type&quot;&gt;type&lt;/a&gt;() will return QInputDevice::DeviceType::Touchpad.</source>
          <target state="translated">Wheel事件将发送到鼠标光标下的小部件，但是如果该小部件不处理该事件，则会将它们发送到焦点小部件。同时为鼠标滚轮和触控板滚动手势生成滚轮事件。有两种读取车轮事件增量的方法：&lt;a href=&quot;qwheelevent#angleDelta&quot;&gt;angleDelta&lt;/a&gt;（）返回车轮角度的增量。始终提供这些值。&lt;a href=&quot;qwheelevent#pixelDelta&quot;&gt;pixelDelta&lt;/a&gt;（）返回屏幕像素的增量，并且在具有高分辨率触控板的平台（例如macOS）上可用。在这种情况下，&lt;a href=&quot;qinputevent#device&quot;&gt;设备&lt;/a&gt;（）-&amp;gt;&lt;a href=&quot;qevent#type&quot;&gt;类型&lt;/a&gt;（）将返回QInputDevice :: DeviceType :: Touchpad。</target>
        </trans-unit>
        <trans-unit id="2e7b4e1c6a7b6aa075a59756437a60a44e41a706" translate="yes" xml:space="preserve">
          <source>Wheel events are sent to the widget under the mouse cursor, but if that widget does not handle the event they are sent to the focus widget. Wheel events are generated for both mouse wheels and trackpad scroll gestures. There are two ways to read the wheel event delta: &lt;a href=&quot;qwheelevent#angleDelta&quot;&gt;angleDelta&lt;/a&gt;() returns the deltas in wheel degrees. These values are always provided. &lt;a href=&quot;qwheelevent#pixelDelta&quot;&gt;pixelDelta&lt;/a&gt;() returns the deltas in screen pixels, and is available on platforms that have high-resolution trackpads, such as macOS. If that is the case, &lt;a href=&quot;qwheelevent#source&quot;&gt;source&lt;/a&gt;() will return &lt;a href=&quot;qt#MouseEventSource-enum&quot;&gt;Qt::MouseEventSynthesizedBySystem&lt;/a&gt;.</source>
          <target state="translated">Wheel事件将发送到鼠标光标下的小部件，但是如果该小部件不处理该事件，则会将它们发送到焦点小部件。同时为鼠标滚轮和触控板滚动手势生成滚轮事件。有两种读取车轮事件增量的方法：&lt;a href=&quot;qwheelevent#angleDelta&quot;&gt;angleDelta&lt;/a&gt;（）返回车轮角度的增量。始终提供这些值。&lt;a href=&quot;qwheelevent#pixelDelta&quot;&gt;pixelDelta&lt;/a&gt;（）返回屏幕像素的增量，并且在具有高分辨率触控板的平台（例如macOS）上可用。在这种情况下，&lt;a href=&quot;qwheelevent#source&quot;&gt;source&lt;/a&gt;（）将返回&lt;a href=&quot;qt#MouseEventSource-enum&quot;&gt;Qt :: MouseEventSynthesizedBySystem&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3d5d09f0bf28a26f226208f3c55c481ff5cd1071" translate="yes" xml:space="preserve">
          <source>Wheel events in the graphics view framework</source>
          <target state="translated">图形视图框架中的轮子事件</target>
        </trans-unit>
        <trans-unit id="2f9a04144c12aa6a0a70aca28f6f197de1ab5301" translate="yes" xml:space="preserve">
          <source>WheelEvent</source>
          <target state="translated">WheelEvent</target>
        </trans-unit>
        <trans-unit id="a1823b970b11b8a9b89c9306a5840acc5dbf562b" translate="yes" xml:space="preserve">
          <source>WheelEvent (QML type)</source>
          <target state="translated">轮子事件(QML类型</target>
        </trans-unit>
        <trans-unit id="246550e1a76a3ff97fe84d5f63e2fa253b921c33" translate="yes" xml:space="preserve">
          <source>WheelEvent QML Type</source>
          <target state="translated">WheelEvent QML类型</target>
        </trans-unit>
        <trans-unit id="cbbe58bce25951834630e64dd9b6a6c7bc7d30d5" translate="yes" xml:space="preserve">
          <source>WheelEvent.accepted</source>
          <target state="translated">WheelEvent.accepted</target>
        </trans-unit>
        <trans-unit id="c8ac526eec73ae51b08ba4dbf883916d54d111d6" translate="yes" xml:space="preserve">
          <source>WheelEvent.angleDelta</source>
          <target state="translated">WheelEvent.angleDelta</target>
        </trans-unit>
        <trans-unit id="a97374302b0712b79d4c6e63cd0e390a4568ad8e" translate="yes" xml:space="preserve">
          <source>WheelEvent.buttons</source>
          <target state="translated">WheelEvent.buttons</target>
        </trans-unit>
        <trans-unit id="26dc4a0386af7486bb281e868258f3a863e4f7ec" translate="yes" xml:space="preserve">
          <source>WheelEvent.inverted</source>
          <target state="translated">WheelEvent.inverted</target>
        </trans-unit>
        <trans-unit id="031bafb46460ea761ccd0b2318eed3dba81a7561" translate="yes" xml:space="preserve">
          <source>WheelEvent.modifiers</source>
          <target state="translated">WheelEvent.modifiers</target>
        </trans-unit>
        <trans-unit id="00a8c077d0e8964bb14dd415e1ad20ce653df397" translate="yes" xml:space="preserve">
          <source>WheelEvent.pixelDelta</source>
          <target state="translated">WheelEvent.pixelDelta</target>
        </trans-unit>
        <trans-unit id="c1dacb154a0136c85af43c883ae831be9ce68e06" translate="yes" xml:space="preserve">
          <source>WheelEvent.x</source>
          <target state="translated">WheelEvent.x</target>
        </trans-unit>
        <trans-unit id="230ef11cb03e402544f9e1995cee252cbe3ecffa" translate="yes" xml:space="preserve">
          <source>WheelEvent.y</source>
          <target state="translated">WheelEvent.y</target>
        </trans-unit>
        <trans-unit id="07e9e3384bb0c7e452cb2aa6a7726024c9b2ff1c" translate="yes" xml:space="preserve">
          <source>WheelHandler</source>
          <target state="translated">WheelHandler</target>
        </trans-unit>
        <trans-unit id="ef25d68fcb71a26afb803260073ce0f95758d65d" translate="yes" xml:space="preserve">
          <source>WheelHandler (QML type)</source>
          <target state="translated">WheelHandler(QML类型</target>
        </trans-unit>
        <trans-unit id="094aef52c50e6db137f7005d485fc7d1fa94626e" translate="yes" xml:space="preserve">
          <source>WheelHandler QML Type</source>
          <target state="translated">WheelHandler QML类型</target>
        </trans-unit>
        <trans-unit id="1a2d8b1710b924a26ead3052a54a14c2a8f7d761" translate="yes" xml:space="preserve">
          <source>WheelHandler handles only a rotating mouse wheel by default. Optionally it can handle smooth-scrolling events from touchpad gestures, by setting &lt;a href=&quot;qml-qtquick-wheelhandler#acceptedDevices-prop&quot;&gt;acceptedDevices&lt;/a&gt; to &lt;code&gt;PointerDevice.Mouse | PointerDevice.TouchPad&lt;/code&gt;.</source>
          <target state="translated">默认情况下，WheelHandler仅处理旋转的鼠标滚轮。通过将&lt;a href=&quot;qml-qtquick-wheelhandler#acceptedDevices-prop&quot;&gt;acceptedDevices&lt;/a&gt;设置为 &lt;code&gt;PointerDevice.Mouse | PointerDevice.TouchPad&lt;/code&gt; ，可以选择处理触摸板手势的平滑滚动事件。PointerDevice.TouchPad。</target>
        </trans-unit>
        <trans-unit id="3a1eb6028085758db688fa369ae4fe68f9149d78" translate="yes" xml:space="preserve">
          <source>WheelHandler is a handler that is used to interactively manipulate some numeric property of an Item as the user rotates the mouse wheel. Like other Input Handlers, by default it manipulates its &lt;a href=&quot;qml-qtquick-wheelhandler#target-prop&quot;&gt;target&lt;/a&gt;. Declare &lt;a href=&quot;qml-qtquick-wheelhandler#property-prop&quot;&gt;property&lt;/a&gt; to control which target property will be manipulated:</source>
          <target state="translated">WheelHandler是一个处理程序，用于在用户旋转鼠标滚轮时交互地操作Item的某些数字属性。像其他输入处理程序一样，默认情况下，它会操纵其&lt;a href=&quot;qml-qtquick-wheelhandler#target-prop&quot;&gt;target&lt;/a&gt;。声明&lt;a href=&quot;qml-qtquick-wheelhandler#property-prop&quot;&gt;属性&lt;/a&gt;以控制要操作的目标属性：</target>
        </trans-unit>
        <trans-unit id="9712b9df96bac3ee2eb51c53d389ac34d7e9c3a8" translate="yes" xml:space="preserve">
          <source>WheelHandler.acceptedButtons</source>
          <target state="translated">WheelHandler.acceptedButtons</target>
        </trans-unit>
        <trans-unit id="65031e575cee983b2825905a890e5cc9c86bb4d9" translate="yes" xml:space="preserve">
          <source>WheelHandler.acceptedDevices</source>
          <target state="translated">WheelHandler.acceptedDevices</target>
        </trans-unit>
        <trans-unit id="717756ced07ac02692dcab8b942ada4d5e8aff20" translate="yes" xml:space="preserve">
          <source>WheelHandler.acceptedModifiers</source>
          <target state="translated">WheelHandler.acceptedModifiers</target>
        </trans-unit>
        <trans-unit id="3fe9789263936ac4435a0844953bcddfd2df3768" translate="yes" xml:space="preserve">
          <source>WheelHandler.acceptedPointerTypes</source>
          <target state="translated">WheelHandler.acceptedPointerTypes</target>
        </trans-unit>
        <trans-unit id="4a2aaa90ae7c981db8eff4fec1d6899f3d87dcda" translate="yes" xml:space="preserve">
          <source>WheelHandler.active</source>
          <target state="translated">WheelHandler.active</target>
        </trans-unit>
        <trans-unit id="748e110be3ad5a6e4e5fc82db21934bbd9bd93f1" translate="yes" xml:space="preserve">
          <source>WheelHandler.activeTimeout</source>
          <target state="translated">WheelHandler.activeTimeout</target>
        </trans-unit>
        <trans-unit id="46012948e88c461bc2422a89c3051001daaf6b14" translate="yes" xml:space="preserve">
          <source>WheelHandler.canceled()</source>
          <target state="translated">WheelHandler.canceled()</target>
        </trans-unit>
        <trans-unit id="d707b25fdd4af05149e72b702f2b17daf6b92ebb" translate="yes" xml:space="preserve">
          <source>WheelHandler.cursorShape</source>
          <target state="translated">WheelHandler.cursorShape</target>
        </trans-unit>
        <trans-unit id="da484ddb6ccfd7d4ecd80557a521f3fcf92ca50f" translate="yes" xml:space="preserve">
          <source>WheelHandler.dragThreshold</source>
          <target state="translated">WheelHandler.dragThreshold</target>
        </trans-unit>
        <trans-unit id="4e479e961fd827a98b8ff72b78e782fde2147c9f" translate="yes" xml:space="preserve">
          <source>WheelHandler.enabled</source>
          <target state="translated">WheelHandler.enabled</target>
        </trans-unit>
        <trans-unit id="17b8998fcbf29e50259f82453339bbd2fd694a1c" translate="yes" xml:space="preserve">
          <source>WheelHandler.grabChanged()</source>
          <target state="translated">WheelHandler.grabChanged()</target>
        </trans-unit>
        <trans-unit id="a018ecac84f3f94b19fa4c9335b1dd7d527304f6" translate="yes" xml:space="preserve">
          <source>WheelHandler.grabPermissions</source>
          <target state="translated">WheelHandler.grabPermissions</target>
        </trans-unit>
        <trans-unit id="2875bfb43cabe83ddf5ac63445065fad12c367cf" translate="yes" xml:space="preserve">
          <source>WheelHandler.invertible</source>
          <target state="translated">WheelHandler.invertible</target>
        </trans-unit>
        <trans-unit id="78d3f16fcf0ceba279bb04784ec70157d2ec2104" translate="yes" xml:space="preserve">
          <source>WheelHandler.margin</source>
          <target state="translated">WheelHandler.margin</target>
        </trans-unit>
        <trans-unit id="930557ba8a3c182da7c7fca3fdaee1a4842d27e0" translate="yes" xml:space="preserve">
          <source>WheelHandler.orientation</source>
          <target state="translated">WheelHandler.orientation</target>
        </trans-unit>
        <trans-unit id="9ec751dae8f7c992650d35a9b45cb822910a96f3" translate="yes" xml:space="preserve">
          <source>WheelHandler.parent</source>
          <target state="translated">WheelHandler.parent</target>
        </trans-unit>
        <trans-unit id="8e92b2f864c6fb3534e5102d70be2c5ea69edb7d" translate="yes" xml:space="preserve">
          <source>WheelHandler.point</source>
          <target state="translated">WheelHandler.point</target>
        </trans-unit>
        <trans-unit id="97e8874abcfcc64d035654ef95a7321513d14352" translate="yes" xml:space="preserve">
          <source>WheelHandler.property</source>
          <target state="translated">WheelHandler.property</target>
        </trans-unit>
        <trans-unit id="7d4b706cb8fa80429681d31e68844ba0b07684b6" translate="yes" xml:space="preserve">
          <source>WheelHandler.rotation</source>
          <target state="translated">WheelHandler.rotation</target>
        </trans-unit>
        <trans-unit id="cc003d7f9a082f275dc80009aeca7f7492426bbe" translate="yes" xml:space="preserve">
          <source>WheelHandler.rotationScale</source>
          <target state="translated">WheelHandler.rotationScale</target>
        </trans-unit>
        <trans-unit id="144a32272f2c2538caf4dd562410fb57ad78b3df" translate="yes" xml:space="preserve">
          <source>WheelHandler.target</source>
          <target state="translated">WheelHandler.target</target>
        </trans-unit>
        <trans-unit id="2df35e30845731687aa769a876f9a331303cb795" translate="yes" xml:space="preserve">
          <source>WheelHandler.targetScaleMultiplier</source>
          <target state="translated">WheelHandler.targetScaleMultiplier</target>
        </trans-unit>
        <trans-unit id="78244656d3462a5a80e56e518ff610b39caa21d3" translate="yes" xml:space="preserve">
          <source>WheelHandler.targetTransformAroundCursor</source>
          <target state="translated">WheelHandler.targetTransformAroundCursor</target>
        </trans-unit>
        <trans-unit id="4e192876e621fcd7d0cfc054a53e4e6d38894a98" translate="yes" xml:space="preserve">
          <source>WheelHandler.wheel()</source>
          <target state="translated">WheelHandler.wheel()</target>
        </trans-unit>
        <trans-unit id="769bb19e615b7f8e2809e5882e2d05a18f57a531" translate="yes" xml:space="preserve">
          <source>When</source>
          <target state="translated">When</target>
        </trans-unit>
        <trans-unit id="32d1333a170d32f29105e8d704b8d931de832246" translate="yes" xml:space="preserve">
          <source>When *</source>
          <target state="translated">当*</target>
        </trans-unit>
        <trans-unit id="4012884f9b1a7ee9cf4a203b0bc49e15f5c281a6" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;configure-options&quot;&gt;configuring&lt;/a&gt; Qt for installation, it is possible to ensure that it is built to include debug symbols that can make it easier to track bugs in applications and libraries. However, on some platforms, building Qt in debug mode will cause applications to be larger than desirable.</source>
          <target state="translated">在&lt;a href=&quot;configure-options&quot;&gt;配置&lt;/a&gt;Qt进行安装时，可以确保将其构建为包含调试符号，从而可以更轻松地跟踪应用程序和库中的错误。但是，在某些平台上，以调试模式构建Qt将导致应用程序超出预期。</target>
        </trans-unit>
        <trans-unit id="4ed7422c4b381275d6494ce5497b021976af6b6c" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;configure-options#&quot;&gt;configuring&lt;/a&gt; Qt for installation, it is possible to ensure that it is built to include debug symbols that can make it easier to track bugs in applications and libraries. However, on some platforms, building Qt in debug mode will cause applications to be larger than desirable.</source>
          <target state="translated">在&lt;a href=&quot;configure-options#&quot;&gt;配置&lt;/a&gt; Qt进行安装时，可以确保它构建为包含调试符号，从而可以更轻松地跟踪应用程序和库中的错误。但是，在某些平台上，以调试模式构建Qt将导致应用程序超出预期。</target>
        </trans-unit>
        <trans-unit id="f082533d0051af453c4cc7c0993903cdfbb05e82" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qabstractspinbox#keyboardTracking-prop&quot;&gt;keyboard tracking&lt;/a&gt; is enabled (the default), every keystroke of editing a field triggers signals for value changes.</source>
          <target state="translated">当&lt;a href=&quot;qabstractspinbox#keyboardTracking-prop&quot;&gt;键盘跟踪&lt;/a&gt;启用（默认值），为价值变动编辑场触发信号的每个按键。</target>
        </trans-unit>
        <trans-unit id="369d9cfc62e315d40c391ad82bfdaa472a18113a" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qdockwidget#DockWidgetFeature-enum&quot;&gt;DockWidgetVerticalTitleBar&lt;/a&gt; is set on &lt;a href=&quot;qdockwidget&quot;&gt;QDockWidget&lt;/a&gt;, the title bar widget is repositioned accordingly. In &lt;a href=&quot;qwidget#resizeEvent&quot;&gt;resizeEvent&lt;/a&gt;(), the title bar should check what orientation it should assume:</source>
          <target state="translated">当&lt;a href=&quot;qdockwidget#DockWidgetFeature-enum&quot;&gt;DockWidgetVerticalTitleBar&lt;/a&gt;设置在&lt;a href=&quot;qdockwidget&quot;&gt;QDockWidget&lt;/a&gt;，widget被重新定位相应的标题栏。在&lt;a href=&quot;qwidget#resizeEvent&quot;&gt;resizeEvent&lt;/a&gt;（）中，标题栏应检查其应采用的方向：</target>
        </trans-unit>
        <trans-unit id="db8e1da66e519efacbcf5ae28e29d8b6a42af820" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qml-qtgraphicaleffects-innershadow#fast-prop&quot;&gt;fast&lt;/a&gt; property is set to true, this property has no effect.</source>
          <target state="translated">当&lt;a href=&quot;qml-qtgraphicaleffects-innershadow#fast-prop&quot;&gt;fast&lt;/a&gt;属性设置为true时，此属性无效。</target>
        </trans-unit>
        <trans-unit id="068fe878b2fd1b5879499e8ded388d63b122f13f" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qml-qtquick-controls2-scrollbar&quot;&gt;ScrollBar&lt;/a&gt; is attached &lt;a href=&quot;qml-qtquick-controls2-scrollbar#vertical-attached-prop&quot;&gt;vertically&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-controls2-scrollbar#horizontal-attached-prop&quot;&gt;horizontally&lt;/a&gt; to a Flickable, its geometry and the following properties are automatically set and updated as appropriate:</source>
          <target state="translated">将&lt;a href=&quot;qml-qtquick-controls2-scrollbar&quot;&gt;ScrollBar &lt;/a&gt;&lt;a href=&quot;qml-qtquick-controls2-scrollbar#vertical-attached-prop&quot;&gt;垂直&lt;/a&gt;或&lt;a href=&quot;qml-qtquick-controls2-scrollbar#horizontal-attached-prop&quot;&gt;水平&lt;/a&gt;连接到Flickable时，其几何形状和以下属性将自动设置并适当更新：</target>
        </trans-unit>
        <trans-unit id="2537c42519e3b600623d35e309f6c9c1c2ea818a" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qml-qtquick-extras-gauge#orientation-prop&quot;&gt;orientation&lt;/a&gt; is &lt;code&gt;Qt.Horizontal&lt;/code&gt;, the valid values are:</source>
          <target state="translated">当&lt;a href=&quot;qml-qtquick-extras-gauge#orientation-prop&quot;&gt;方向&lt;/a&gt;是 &lt;code&gt;Qt.Horizontal&lt;/code&gt; ，有效值为：</target>
        </trans-unit>
        <trans-unit id="d3a11e0e6e5e393e9278e077b734d35f0fe6c943" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qml-qtquick-shapes-shape#rendererType-prop&quot;&gt;rendererType&lt;/a&gt; is &lt;code&gt;Shape.GeometryRenderer&lt;/code&gt;, the input path is triangulated on the CPU during the polishing phase of the Shape. This is potentially expensive. To offload this work to separate worker threads, set this property to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">当&lt;a href=&quot;qml-qtquick-shapes-shape#rendererType-prop&quot;&gt;rendererType&lt;/a&gt;为 &lt;code&gt;Shape.GeometryRenderer&lt;/code&gt; 时，在Shape的抛光阶段，输入路径将在CPU上进行三角剖分。这可能很昂贵。要将工作分担到单独的工作线程中，请将此属性设置为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3c18767293ff3b0e325bc6a72a1b6a1318d5de9d" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qml-qtquick-shapes-shapepath#joinStyle-prop&quot;&gt;joinStyle&lt;/a&gt; is set to &lt;code&gt;ShapePath.MiterJoin&lt;/code&gt;, this property specifies how far the miter join can extend from the join point.</source>
          <target state="translated">当&lt;a href=&quot;qml-qtquick-shapes-shapepath#joinStyle-prop&quot;&gt;joinStyle&lt;/a&gt;设置为 &lt;code&gt;ShapePath.MiterJoin&lt;/code&gt; 时，此属性指定斜接连接可以从连接点延伸多远。</target>
        </trans-unit>
        <trans-unit id="bd4694a747179de1bb68ab2376f7fa36326e1ed9" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qml-qtquick-wheelhandler&quot;&gt;WheelHandler&lt;/a&gt; handles events that contain &lt;a href=&quot;qt#ScrollPhase-enum&quot;&gt;scroll phase&lt;/a&gt; information, such as events from some touchpads, the &lt;a href=&quot;stylesheet-reference#active&quot;&gt;active&lt;/a&gt; property will become &lt;code&gt;false&lt;/code&gt; as soon as an event with phase &lt;a href=&quot;qt#ScrollPhase-enum&quot;&gt;Qt::ScrollEnd&lt;/a&gt; is received; in that case the timeout is not necessary. But a conventional mouse with a wheel does not provide a scroll phase: the mouse cannot detect when the user has decided to stop scrolling, so the &lt;a href=&quot;stylesheet-reference#active&quot;&gt;active&lt;/a&gt; property transitions to &lt;code&gt;false&lt;/code&gt; after this much time has elapsed.</source>
          <target state="translated">当&lt;a href=&quot;qml-qtquick-wheelhandler&quot;&gt;WheelHandler&lt;/a&gt;处理包含&lt;a href=&quot;qt#ScrollPhase-enum&quot;&gt;滚动阶段&lt;/a&gt;信息的事件（例如来自某些触摸板的事件）时，&lt;a href=&quot;qt#ScrollPhase-enum&quot;&gt;一旦&lt;/a&gt;收到具有阶段Qt :: ScrollEnd的事件，&lt;a href=&quot;stylesheet-reference#active&quot;&gt;active&lt;/a&gt;属性将变为 &lt;code&gt;false&lt;/code&gt; ;否则，活动属性将变为false。在这种情况下，超时是没有必要的。但是，传统的带滚轮的鼠标无法提供滚动阶段：鼠标无法检测到用户何时决定停止滚动，因此经过了这么长的时间后，&lt;a href=&quot;stylesheet-reference#active&quot;&gt;活动&lt;/a&gt;属性会转换为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ebb49902621c20ad054cd905ff393c72148a9127" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qml-qtquick-wheelhandler&quot;&gt;WheelHandler&lt;/a&gt; handles events that contain &lt;a href=&quot;qt#ScrollPhase-enum&quot;&gt;scroll phase&lt;/a&gt; information, such as events from some touchpads, the &lt;a href=&quot;stylesheet-reference#active&quot;&gt;active&lt;/a&gt; property will become &lt;code&gt;false&lt;/code&gt; as soon as an event with phase &lt;a href=&quot;qt#ScrollPhase-enum&quot;&gt;Qt::ScrollEnd&lt;/a&gt; is received; in that case the timeout is not necessary. But a conventional mouse with a wheel does not provide the scroll phase: the mouse cannot detect when the user has decided to stop scrolling, so the &lt;a href=&quot;stylesheet-reference#active&quot;&gt;active&lt;/a&gt; property transitions to &lt;code&gt;false&lt;/code&gt; after this much time has elapsed.</source>
          <target state="translated">当&lt;a href=&quot;qml-qtquick-wheelhandler&quot;&gt;WheelHandler&lt;/a&gt;处理包含&lt;a href=&quot;qt#ScrollPhase-enum&quot;&gt;滚动阶段&lt;/a&gt;信息的事件（例如来自某些触摸板的事件）时，&lt;a href=&quot;qt#ScrollPhase-enum&quot;&gt;一旦&lt;/a&gt;收到具有阶段Qt :: ScrollEnd的事件，&lt;a href=&quot;stylesheet-reference#active&quot;&gt;active&lt;/a&gt;属性将变为 &lt;code&gt;false&lt;/code&gt; ;否则，活动属性将变为false。在这种情况下，超时是没有必要的。但是传统的带滚轮的鼠标无法提供滚动阶段：鼠标无法检测到用户何时决定停止滚动，因此经过了这么长的时间后，&lt;a href=&quot;stylesheet-reference#active&quot;&gt;活动&lt;/a&gt;属性会转换为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8048e21c76f9446c61b651141b0ad181583adef0" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qobject&quot;&gt;QObjects&lt;/a&gt; are created on the heap (i.e., created with</source>
          <target state="translated">在堆上创建&lt;a href=&quot;qobject&quot;&gt;QObject时&lt;/a&gt;（即使用</target>
        </trans-unit>
        <trans-unit id="4bc3005be93ece2557efc1b3b70d2d777b42720f" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qobject&quot;&gt;QObjects&lt;/a&gt; are created on the stack, the same behavior applies. Normally, the order of destruction still doesn't present a problem. Consider the following snippet:</source>
          <target state="translated">在堆栈上创建&lt;a href=&quot;qobject&quot;&gt;QObject时&lt;/a&gt;，将应用相同的行为。通常，销毁顺序仍然不会出现问题。考虑以下代码段：</target>
        </trans-unit>
        <trans-unit id="29f1b3daf43311cef69762476c52320fee461407" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qopenglcontext#create&quot;&gt;create&lt;/a&gt;() is called with native handles set, &lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt; does not take ownership of the handles, so destroying the &lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt; does not destroy the native context.</source>
          <target state="translated">在设置了本机句柄的情况下调用&lt;a href=&quot;qopenglcontext#create&quot;&gt;create&lt;/a&gt;（）时，&lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt;不会获取该句柄的所有权，因此销毁&lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt;不会销毁本机上下文。</target>
        </trans-unit>
        <trans-unit id="1ed83495c3a9572cee487cfe4ab135ee582eb1bb" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qpainter#begin&quot;&gt;QPainter::begin&lt;/a&gt;() is called, the &lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt; it operates on is prepared for a new page, enabling the &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; to be used immediately to paint the first page in a document. Once the first page has been painted, &lt;a href=&quot;qprinter#newPage&quot;&gt;newPage&lt;/a&gt;() can be called to request a new blank page to paint on, or &lt;a href=&quot;qpainter#end&quot;&gt;QPainter::end&lt;/a&gt;() can be called to finish printing. The second page and all following pages are prepared using a call to &lt;a href=&quot;qprinter#newPage&quot;&gt;newPage&lt;/a&gt;() before they are painted.</source>
          <target state="translated">当&lt;a href=&quot;qpainter#begin&quot;&gt;了QPainter ::开始&lt;/a&gt;（）被调用时，&lt;a href=&quot;qprinter&quot;&gt;QPrinter来&lt;/a&gt;它的运作上一个新的网页编写，使&lt;a href=&quot;qpainter&quot;&gt;QPainter的&lt;/a&gt;立即使用油漆的第一页一个文件内。绘制完第一页后，可以调用&lt;a href=&quot;qprinter#newPage&quot;&gt;newPage&lt;/a&gt;（）来请求绘制新的空白页，或者可以调用&lt;a href=&quot;qpainter#end&quot;&gt;QPainter :: end&lt;/a&gt;（）完成打印。第二页和随后的所有页面在绘制之前都使用对&lt;a href=&quot;qprinter#newPage&quot;&gt;newPage&lt;/a&gt;（）的调用进行准备。</target>
        </trans-unit>
        <trans-unit id="a040374952bef82ad3110d2104cbd2361507a71a" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qpainter#begin&quot;&gt;QPainter::begin&lt;/a&gt;() is called, the QPrinter it operates on is prepared for a new page, enabling the &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; to be used immediately to paint the first page in a document. Once the first page has been painted, &lt;a href=&quot;qprinter#newPage&quot;&gt;newPage&lt;/a&gt;() can be called to request a new blank page to paint on, or &lt;a href=&quot;qpainter#end&quot;&gt;QPainter::end&lt;/a&gt;() can be called to finish printing. The second page and all following pages are prepared using a call to &lt;a href=&quot;qprinter#newPage&quot;&gt;newPage&lt;/a&gt;() before they are painted.</source>
          <target state="translated">当&lt;a href=&quot;qpainter#begin&quot;&gt;了QPainter ::开始&lt;/a&gt;（）被调用，它运行在QPrinter则是一个新的网页编写，使&lt;a href=&quot;qpainter&quot;&gt;QPainter的&lt;/a&gt;立即使用油漆的第一页一个文件内。绘制完第一页后，可以调用&lt;a href=&quot;qprinter#newPage&quot;&gt;newPage&lt;/a&gt;（）来请求绘制新的空白页，或者可以调用&lt;a href=&quot;qpainter#end&quot;&gt;QPainter :: end&lt;/a&gt;（）完成打印。第二页和随后的所有页面在绘制之前都使用对&lt;a href=&quot;qprinter#newPage&quot;&gt;newPage&lt;/a&gt;（）的调用进行准备。</target>
        </trans-unit>
        <trans-unit id="2132738322003eb64c9c6a02ba3636be358ff774" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qplaintextedit&quot;&gt;QPlainTextEdit&lt;/a&gt; is used read-only the key bindings are limited to navigation, and text may only be selected with the mouse:</source>
          <target state="translated">当&lt;a href=&quot;qplaintextedit&quot;&gt;QPlainTextEdit&lt;/a&gt;使用只读时，键绑定仅限于导航，并且只能使用鼠标选择文本：</target>
        </trans-unit>
        <trans-unit id="a1cbf613a60143088f9ded6faf6fa5ff31064559" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qqmlcomponent&quot;&gt;QQmlComponent&lt;/a&gt; constructs an instance, it occurs in three steps:</source>
          <target state="translated">当&lt;a href=&quot;qqmlcomponent&quot;&gt;QQmlComponent&lt;/a&gt;构造一个实例时，它发生在三个步骤中：</target>
        </trans-unit>
        <trans-unit id="1d3dd2b06d7abdd2012e8653307609b9dca7b6c0" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qquickitem#polish&quot;&gt;polish&lt;/a&gt;() is called, the scene graph schedules a polish event for this item. When the scene graph is ready to render this item, it calls updatePolish() to do any item layout as required before it renders the next frame.</source>
          <target state="translated">当&lt;a href=&quot;qquickitem#polish&quot;&gt;抛光&lt;/a&gt;（）被调用时，场景图的时间表为这个项目抛光事件。当场景图准备渲染此项目时，它将在渲染下一帧之前调用updatePolish（）进行所需的任何项目布局。</target>
        </trans-unit>
        <trans-unit id="fdb2404d8f94babd0d1763bb41f0ba653ebe7903" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qregexpvalidator&quot;&gt;QRegExpValidator&lt;/a&gt; determines whether a string is &lt;a href=&quot;qvalidator#State-enum&quot;&gt;Acceptable&lt;/a&gt; or not, the regexp is treated as if it begins with the start of string assertion (&lt;b&gt;^&lt;/b&gt;) and ends with the end of string assertion (&lt;b&gt;$&lt;/b&gt;); the match is against the entire input string, or from the given position if a start position greater than zero is given.</source>
          <target state="translated">当&lt;a href=&quot;qregexpvalidator&quot;&gt;QRegExpValidator&lt;/a&gt;确定字符串是否可以&lt;a href=&quot;qvalidator#State-enum&quot;&gt;接受时&lt;/a&gt;，将regexp视为从字符串断言的开头（&lt;b&gt;^&lt;/b&gt;）开始到字符串断言的结束（&lt;b&gt;$&lt;/b&gt;）结束；匹配将针对整个输入字符串，如果给定的起始位置大于零，则从给定位置开始。</target>
        </trans-unit>
        <trans-unit id="a05be2c57c6c960755c5ba666c019e97d5fb9256" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qsensor#connectToBackend&quot;&gt;QSensor::connectToBackend&lt;/a&gt;() is called, the &lt;a href=&quot;qsensormanager#createBackend&quot;&gt;createBackend&lt;/a&gt;() function will be called.</source>
          <target state="translated">当&lt;a href=&quot;qsensor#connectToBackend&quot;&gt;QSensor :: connectToBackend&lt;/a&gt;（）被调用时，&lt;a href=&quot;qsensormanager#createBackend&quot;&gt;createBackend&lt;/a&gt;（）函数将被调用。</target>
        </trans-unit>
        <trans-unit id="b989e35c468a854106b411ae681aa5098d09dc07" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qspinbox&quot;&gt;QSpinBox&lt;/a&gt; paints itself, it creates a &lt;a href=&quot;qstyleoptionspinbox&quot;&gt;QStyleOptionSpinBox&lt;/a&gt; and asks the style to draw &lt;code&gt;CC_SpinBox&lt;/code&gt;. The edit field is a line edit that is a child of the spin box. The dimensions of the field are calculated by the style with &lt;code&gt;SC_SpinBoxEditField&lt;/code&gt;.</source>
          <target state="translated">当&lt;a href=&quot;qspinbox&quot;&gt;QSpinBox&lt;/a&gt;绘制自身时，它会创建一个&lt;a href=&quot;qstyleoptionspinbox&quot;&gt;QStyleOptionSpinBox&lt;/a&gt;并要求样式绘制 &lt;code&gt;CC_SpinBox&lt;/code&gt; 。编辑字段是行编辑，它是旋转框的子级。使用 &lt;code&gt;SC_SpinBoxEditField&lt;/code&gt; 通过样式计算字段的尺寸。</target>
        </trans-unit>
        <trans-unit id="8d6ef76b83d0b24340125905e68a2cd58df5e13a" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate&lt;/a&gt; paints its items, it draws &lt;a href=&quot;qstyle#ControlElement-enum&quot;&gt;CE_ItemViewItem&lt;/a&gt;, and calculates their size with &lt;a href=&quot;qstyle#ContentsType-enum&quot;&gt;CT_ItemViewItem&lt;/a&gt;. Note also that it uses &lt;a href=&quot;qstyle#SubElement-enum&quot;&gt;SE_ItemViewItemText&lt;/a&gt; to set the size of editors. When implementing a style to customize drawing of item views, you need to check the implementation of &lt;a href=&quot;qcommonstyle&quot;&gt;QCommonStyle&lt;/a&gt; (and any other subclasses from which your style inherits). This way, you find out which and how other style elements are painted, and you can then reimplement the painting of elements that should be drawn differently.</source>
          <target state="translated">当&lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate&lt;/a&gt;绘制其项目时，它将绘制&lt;a href=&quot;qstyle#ControlElement-enum&quot;&gt;CE_ItemViewItem&lt;/a&gt;并使用&lt;a href=&quot;qstyle#ContentsType-enum&quot;&gt;CT_ItemViewItem&lt;/a&gt;计算其大小。还要注意，它使用&lt;a href=&quot;qstyle#SubElement-enum&quot;&gt;SE_ItemViewItemText&lt;/a&gt;设置编辑器的大小。在实现样式以自定义项目视图的图形时，需要检查&lt;a href=&quot;qcommonstyle&quot;&gt;QCommonStyle&lt;/a&gt;（以及从其继承样式的任何其他子类）的实现。这样，您可以找出绘制哪些样式元素以及如何绘制其他样式元素，然后可以重新实现应该以不同方式绘制的元素的绘制。</target>
        </trans-unit>
        <trans-unit id="55966be334da9caaf8746ba7acb096ad107e6834" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qsurfaceformat#setDefaultFormat&quot;&gt;setDefaultFormat&lt;/a&gt;() is not called, this is a default-constructed &lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat&lt;/a&gt;.</source>
          <target state="translated">当&lt;a href=&quot;qsurfaceformat#setDefaultFormat&quot;&gt;setDefaultFormat&lt;/a&gt;（）不叫，这是一个缺省构造&lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c7efa0e1fde6dd5d2897211dec34038ac8d3a942" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qtextblock&quot;&gt;QTextBlock&lt;/a&gt;s are created, the &lt;a href=&quot;qtextdocument#defaultTextOption&quot;&gt;defaultTextOption&lt;/a&gt; is set on their &lt;a href=&quot;qtextlayout&quot;&gt;QTextLayout&lt;/a&gt;. This allows setting global properties for the document such as the default word wrap mode.</source>
          <target state="translated">当&lt;a href=&quot;qtextblock&quot;&gt;QTextBlock&lt;/a&gt;创建秒，&lt;a href=&quot;qtextdocument#defaultTextOption&quot;&gt;defaultTextOption&lt;/a&gt;设置自己的&lt;a href=&quot;qtextlayout&quot;&gt;QTextLayout&lt;/a&gt;。这允许设置文档的全局属性，例如默认的自动换行模式。</target>
        </trans-unit>
        <trans-unit id="4e1949ed80bb2c48913b996d9f4cacdea4c1ee42" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qtextblock&quot;&gt;QTextBlock&lt;/a&gt;s are created, the defaultTextOption is set on their &lt;a href=&quot;qtextlayout&quot;&gt;QTextLayout&lt;/a&gt;. This allows setting global properties for the document such as the default word wrap mode.</source>
          <target state="translated">当&lt;a href=&quot;qtextblock&quot;&gt;QTextBlock&lt;/a&gt;创建秒，defaultTextOption设置自己的&lt;a href=&quot;qtextlayout&quot;&gt;QTextLayout&lt;/a&gt;。这允许设置文档的全局属性，例如默认的自动换行模式。</target>
        </trans-unit>
        <trans-unit id="b325a2734b254fce15499dccbb94d7fc5d4dd1e5" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qtextedit&quot;&gt;QTextEdit&lt;/a&gt; is used read-only the key bindings are limited to navigation, and text may only be selected with the mouse:</source>
          <target state="translated">使用&lt;a href=&quot;qtextedit&quot;&gt;QTextEdit&lt;/a&gt;只读时，键绑定仅限于导航，并且只能使用鼠标选择文本：</target>
        </trans-unit>
        <trans-unit id="800ac5001a1f10a43a1506615ad1662fb3b47f34" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qtimeline&quot;&gt;QTimeLine&lt;/a&gt; is in Running state, this value is updated continuously as a function of the duration and direction of the timeline. Otherwise, it is value that was current when &lt;a href=&quot;qtimeline#stop&quot;&gt;stop&lt;/a&gt;() was called last, or the value set by setCurrentTime().</source>
          <target state="translated">当&lt;a href=&quot;qtimeline&quot;&gt;QTimeLine&lt;/a&gt;处于&amp;ldquo;运行&amp;rdquo;状态时，此值将根据时间线的持续时间和方向连续更新。否则，它是最后一次调用&lt;a href=&quot;qtimeline#stop&quot;&gt;stop&lt;/a&gt;（）时的当前值，或者是setCurrentTime（）设置的值。</target>
        </trans-unit>
        <trans-unit id="fd9edee77138c204df62021847fb438c71aa86c5" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qtquick-statesanimations-animations&quot;&gt;Transitions&lt;/a&gt; are used to animate state changes, they animate properties from their values in the current state to those defined in the new state (as defined by PropertyChanges objects). However, it is sometimes desirable to set a property value</source>
          <target state="translated">当使用&lt;a href=&quot;qtquick-statesanimations-animations&quot;&gt;Transitions&lt;/a&gt;为状态变化设置动画时，它们会将属性从当前状态中的值动画化为新状态中定义的属性（由PropertyChanges对象定义）。但是，有时希望设置属性值</target>
        </trans-unit>
        <trans-unit id="670177e5cc964489b3254306d4402e54f95e632a" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qtquick-statesanimations-animations#&quot;&gt;Transitions&lt;/a&gt; are used to animate state changes, they animate properties from their values in the current state to those defined in the new state (as defined by &lt;a href=&quot;qml-qtquick-propertychanges&quot;&gt;PropertyChanges&lt;/a&gt; objects). However, it is sometimes desirable to set a property value</source>
          <target state="translated">当使用&lt;a href=&quot;qtquick-statesanimations-animations#&quot;&gt;Transitions&lt;/a&gt;为状态变化设置动画时，它们会将属性从当前状态中的值动画化为新状态中定义的&lt;a href=&quot;qml-qtquick-propertychanges&quot;&gt;属性&lt;/a&gt;（由PropertyChanges对象定义）。但是，有时希望设置属性值</target>
        </trans-unit>
        <trans-unit id="adf54fd7881b01dd5fbb317fe0878e5876b7ee5a" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qvulkanwindow#supportsGrab&quot;&gt;supportsGrab&lt;/a&gt;() returns true, &lt;a href=&quot;qvulkanwindow&quot;&gt;QVulkanWindow&lt;/a&gt; can perform readbacks from the color buffer into a &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt;. &lt;a href=&quot;qvulkanwindow#grab&quot;&gt;grab&lt;/a&gt;() is a slow and inefficient operation, so frequent usage should be avoided. It is nonetheless valuable since it allows applications to take screenshots, or tools and tests to process and verify the output of the GPU rendering.</source>
          <target state="translated">当&lt;a href=&quot;qvulkanwindow#supportsGrab&quot;&gt;supportsGrab&lt;/a&gt;（）返回true时，&lt;a href=&quot;qvulkanwindow&quot;&gt;QVulkanWindow&lt;/a&gt;可以将颜色缓冲区中的内容读回到&lt;a href=&quot;qimage&quot;&gt;QImage中&lt;/a&gt;。&lt;a href=&quot;qvulkanwindow#grab&quot;&gt;catch&lt;/a&gt;（）是一种缓慢且效率低下的操作，因此应避免频繁使用。尽管如此，它还是很有价值的，因为它允许应用程序截取屏幕截图，或者使用工具和测试来处理和验证GPU渲染的输出。</target>
        </trans-unit>
        <trans-unit id="a855aaf2660d645fa9b8949d66a891591b9ae74f" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qvulkanwindow#supportsGrab&quot;&gt;supportsGrab&lt;/a&gt;() returns true, QVulkanWindow can perform readbacks from the color buffer into a &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt;. &lt;a href=&quot;qvulkanwindow#grab&quot;&gt;grab&lt;/a&gt;() is a slow and inefficient operation, so frequent usage should be avoided. It is nonetheless valuable since it allows applications to take screenshots, or tools and tests to process and verify the output of the GPU rendering.</source>
          <target state="translated">当&lt;a href=&quot;qvulkanwindow#supportsGrab&quot;&gt;supportsGrab&lt;/a&gt;（）返回true时，QVulkanWindow可以将颜色缓冲区中的内容读回到&lt;a href=&quot;qimage&quot;&gt;QImage中&lt;/a&gt;。&lt;a href=&quot;qvulkanwindow#grab&quot;&gt;catch&lt;/a&gt;（）是一种缓慢且效率低下的操作，因此应避免频繁使用。尽管如此，它还是很有价值的，因为它允许应用程序截取屏幕截图，或者使用工具和测试来处理和验证GPU渲染的输出。</target>
        </trans-unit>
        <trans-unit id="6823f0c205033d4ea128122af4b97d19b1b0c274" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qxmlquery&quot;&gt;QXmlQuery&lt;/a&gt; accesses resources (e.g., calling &lt;code&gt;fn:doc()&lt;/code&gt; to load a file, or accessing a device via a bound variable), the event loop is used, which means events will be processed. To avoid processing events when &lt;a href=&quot;qxmlquery&quot;&gt;QXmlQuery&lt;/a&gt; accesses resources, create your &lt;a href=&quot;qxmlquery&quot;&gt;QXmlQuery&lt;/a&gt; instance in a separate thread.</source>
          <target state="translated">当&lt;a href=&quot;qxmlquery&quot;&gt;QXmlQuery&lt;/a&gt;访问资源（例如，调用 &lt;code&gt;fn:doc()&lt;/code&gt; 加载文件或通过绑定变量访问设备）时，将使用事件循环，这意味着将处理事件。为了避免在&lt;a href=&quot;qxmlquery&quot;&gt;QXmlQuery&lt;/a&gt;访问资源时处理事件，请在单独的线程中创建&lt;a href=&quot;qxmlquery&quot;&gt;QXmlQuery&lt;/a&gt;实例。</target>
        </trans-unit>
        <trans-unit id="5a4303763eb160478daacc616e1e09a84ccb3fd3" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qxmlquery&quot;&gt;QXmlQuery&lt;/a&gt; calls &lt;a href=&quot;qabstractmessagehandler#message&quot;&gt;QAbstractMessageHandler::message&lt;/a&gt;(), the arguments are as follows:</source>
          <target state="translated">当&lt;a href=&quot;qxmlquery&quot;&gt;QXmlQuery&lt;/a&gt;调用&lt;a href=&quot;qabstractmessagehandler#message&quot;&gt;QAbstractMessageHandler :: message&lt;/a&gt;（）时，参数如下：</target>
        </trans-unit>
        <trans-unit id="2414e2eb1638148ea5acad1b6c425e2a2fa8d639" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qxmlquery#setQuery&quot;&gt;setQuery&lt;/a&gt;() is called, the query text is compiled into an internal data structure and optimized. The optimized form can then be reused for multiple evaluations of the query. Since the compile-and-optimize process can be expensive, repeating it for the same query should be avoided by using a separate instance of &lt;a href=&quot;qxmlquery&quot;&gt;QXmlQuery&lt;/a&gt; for each query text.</source>
          <target state="translated">当&lt;a href=&quot;qxmlquery#setQuery&quot;&gt;setQuery&lt;/a&gt;（）被调用时，查询文本被编译成内部数据结构和优化。然后可以将优化的表单重新用于查询的多个评估。由于编译和优化过程可能会很昂贵，因此应通过为每个查询文本使用单独的&lt;a href=&quot;qxmlquery&quot;&gt;QXmlQuery&lt;/a&gt;实例来避免针对同一查询重复该过程。</target>
        </trans-unit>
        <trans-unit id="df60f13705bccbfb1ebe641d5980c4f255529f48" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qxmlquery#setQuery&quot;&gt;setQuery&lt;/a&gt;() is called, the query text is compiled into an internal data structure and optimized. The optimized form can then be reused for multiple evaluations of the query. Since the compile-and-optimize process can be expensive, repeating it for the same query should be avoided by using a separate instance of QXmlQuery for each query text.</source>
          <target state="translated">当&lt;a href=&quot;qxmlquery#setQuery&quot;&gt;setQuery&lt;/a&gt;（）被调用时，查询文本被编译成内部数据结构和优化。然后，可以将优化后的表单重新用于查询的多个评估。由于编译和优化过程可能会很昂贵，因此应通过为每个查询文本使用单独的QXmlQuery实例来避免针对同一查询重复该过程。</target>
        </trans-unit>
        <trans-unit id="8f0e33d48640a9980a60399682ba53ff818618de" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qxmlschema&quot;&gt;QXmlSchema&lt;/a&gt; calls &lt;a href=&quot;qabstractmessagehandler#message&quot;&gt;QAbstractMessageHandler::message&lt;/a&gt;(), the arguments are as follows:</source>
          <target state="translated">当&lt;a href=&quot;qxmlschema&quot;&gt;QXmlSchema&lt;/a&gt;调用&lt;a href=&quot;qabstractmessagehandler#message&quot;&gt;QAbstractMessageHandler :: message&lt;/a&gt;（）时，参数如下：</target>
        </trans-unit>
        <trans-unit id="34a36de9f3978a9dc52660020f38e10757c3b33a" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qxmlschemavalidator&quot;&gt;QXmlSchemaValidator&lt;/a&gt; calls &lt;a href=&quot;qabstractmessagehandler#message&quot;&gt;QAbstractMessageHandler::message&lt;/a&gt;(), the arguments are as follows:</source>
          <target state="translated">当&lt;a href=&quot;qxmlschemavalidator&quot;&gt;QXmlSchemaValidator&lt;/a&gt;调用&lt;a href=&quot;qabstractmessagehandler#message&quot;&gt;QAbstractMessageHandler :: message&lt;/a&gt;（）时，参数如下：</target>
        </trans-unit>
        <trans-unit id="abc180cdaa67db2334bc9aec8221bc677db91dc0" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&amp;lt;param&amp;gt;&lt;/code&gt; elements are used in the &lt;code&gt;&amp;lt;send&amp;gt;&lt;/code&gt; element, the data will contain a &lt;a href=&quot;qvariant#QVariantMap-typedef&quot;&gt;QVariantMap&lt;/a&gt; where the key is the</source>
          <target state="translated">在 &lt;code&gt;&amp;lt;param&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;send&amp;gt;&lt;/code&gt; &amp;gt;元素中使用&amp;lt;param&amp;gt;元素时，数据将包含&lt;a href=&quot;qvariant#QVariantMap-typedef&quot;&gt;QVariantMap&lt;/a&gt;，其中键为</target>
        </trans-unit>
        <trans-unit id="a06133ee79a232acbfba343775e247dd1fc22db2" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;GL_ARB_framebuffer_sRGB&lt;/code&gt; or &lt;code&gt;GL_EXT_framebuffer_sRGB&lt;/code&gt; is supported by the platform and this value is set, the window will be created with an sRGB-capable default framebuffer. Note that some platforms may return windows with a sRGB-capable default framebuffer even when not requested explicitly.</source>
          <target state="translated">当平台支持 &lt;code&gt;GL_ARB_framebuffer_sRGB&lt;/code&gt; 或 &lt;code&gt;GL_EXT_framebuffer_sRGB&lt;/code&gt; 并设置了该值时，将使用支持sRGB的默认帧缓冲区创建窗口。请注意，即使未明确请求，某些平台也可能返回带有sRGB功能的默认帧缓冲区的窗口。</target>
        </trans-unit>
        <trans-unit id="aa3913ff2ab5c3e811ba7c183222c6fcac1a3447" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;QT_OPENGL_BUGLIST&lt;/code&gt; is not specified, a built-in list will be used. This typically includes some older, less-capable graphics cards with &lt;code&gt;disable_desktopgl&lt;/code&gt; set, in order to prevent Qt from using their unstable desktop OpenGL implementations and instead fall back to ANGLE right away.</source>
          <target state="translated">当 &lt;code&gt;QT_OPENGL_BUGLIST&lt;/code&gt; 没有指定，一个内置列表将被使用。这通常包括设置了 &lt;code&gt;disable_desktopgl&lt;/code&gt; 的一些较旧的，性能较弱的图形卡，以防止Qt使用其不稳定的桌面OpenGL实现，而立即退回ANGLE。</target>
        </trans-unit>
        <trans-unit id="0ee65f2df0437329eced55c1c7cc094832b06268" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;QT_OPENGL_BUGLIST&lt;/code&gt; is not specified, a built-in list will be used. This typically includes some older, less-capable graphics cards with &lt;code&gt;disable_desktopgl&lt;/code&gt; set, in order to prevent Qt from using their unstable desktop OpenGL implementations and instead fall back to attempting to load the software-based alternative library right away.</source>
          <target state="translated">当 &lt;code&gt;QT_OPENGL_BUGLIST&lt;/code&gt; 没有指定，一个内置列表将被使用。这通常包括设置了 &lt;code&gt;disable_desktopgl&lt;/code&gt; 的一些较旧的，性能欠佳的图形卡，以防止Qt使用其不稳定的桌面OpenGL实现，而转而尝试立即加载基于软件的替代库。</target>
        </trans-unit>
        <trans-unit id="ed4d9b70602719a6967792783570916cdfb715ef" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;button&lt;/code&gt; is clicked, the machine will transition into state &lt;code&gt;s2&lt;/code&gt;, which will set the geometry of the button, and then pop up a message box to alert the user that the geometry has been changed.</source>
          <target state="translated">当 &lt;code&gt;button&lt;/code&gt; 被点击时，机器将过渡到状态 &lt;code&gt;s2&lt;/code&gt; ，其将设置按钮的几何形状，然后弹出一个消息框以警告几何已经改变的用户。</target>
        </trans-unit>
        <trans-unit id="2388f2e21addac6210aabde322ea581bb6afffb1" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;mode&lt;/code&gt; is not defined, the mode that is reported as preferred by the system is chosen. The accepted values for &lt;code&gt;mode&lt;/code&gt; are: &lt;code&gt;off&lt;/code&gt;, &lt;code&gt;current&lt;/code&gt;, &lt;code&gt;preferred&lt;/code&gt;, &lt;code&gt;skip&lt;/code&gt;, width&lt;code&gt;x&lt;/code&gt;height, width&lt;code&gt;x&lt;/code&gt;height&lt;code&gt;@&lt;/code&gt;vrefresh, or a modeline string.</source>
          <target state="translated">当 &lt;code&gt;mode&lt;/code&gt; 没有被定义时，选择由该系统报告为优选的方式。 &lt;code&gt;mode&lt;/code&gt; 的可接受值为： &lt;code&gt;off&lt;/code&gt; ， &lt;code&gt;current&lt;/code&gt; ， &lt;code&gt;preferred&lt;/code&gt; ， &lt;code&gt;skip&lt;/code&gt; ，width &lt;code&gt;x&lt;/code&gt; height，width &lt;code&gt;x&lt;/code&gt; height &lt;code&gt;@&lt;/code&gt; vrefresh或modeline字符串。</target>
        </trans-unit>
        <trans-unit id="ad2de4e55d4aebd9b4557d94a6cf5c7e0065f8b8" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;mode&lt;/code&gt; is not defined, the system's preferred mode is chosen. The accepted values for &lt;code&gt;mode&lt;/code&gt; are: &lt;code&gt;off&lt;/code&gt;, &lt;code&gt;current&lt;/code&gt;, &lt;code&gt;preferred&lt;/code&gt;, &lt;code&gt;skip&lt;/code&gt;, width&lt;code&gt;x&lt;/code&gt;height, width&lt;code&gt;x&lt;/code&gt;height&lt;code&gt;@&lt;/code&gt;vrefresh, or a modeline string.</source>
          <target state="translated">当 &lt;code&gt;mode&lt;/code&gt; 没有被定义时，选择该系统的优选模式。可接受的 &lt;code&gt;mode&lt;/code&gt; 值为： &lt;code&gt;off&lt;/code&gt; ， &lt;code&gt;current&lt;/code&gt; ， &lt;code&gt;preferred&lt;/code&gt; ， &lt;code&gt;skip&lt;/code&gt; ，width &lt;code&gt;x&lt;/code&gt; height，width &lt;code&gt;x&lt;/code&gt; height &lt;code&gt;@&lt;/code&gt; vrefresh或modeline字符串。</target>
        </trans-unit>
        <trans-unit id="bebb2b33e2691fc3d175656c1b70af1ee1b6346d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;reanchorToRight&lt;/code&gt; is called, the function first sets the right anchor. At that point, both left and right anchors are set, and the item will be stretched horizontally to fill its parent. When the left anchor is unset, the new width will remain. Thus when updating anchors within JavaScript, you should first unset any anchors that are no longer required, and only then set any new anchors that are required, as shown below:</source>
          <target state="translated">当 &lt;code&gt;reanchorToRight&lt;/code&gt; 被调用时，函数首先设置正确的锚。此时，将设置左右锚点，然后将水平拉伸该项目以填充其父项。取消设置左锚点后，新的宽度将保留。因此，在JavaScript中更新锚点时，您应首先取消设置不再需要的所有锚点，然后再设置所需的任何新的锚点，如下所示：</target>
        </trans-unit>
        <trans-unit id="8825f7725f1dc91940c2a034ec29bd99db520ddf" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;s1&lt;/code&gt; 's final state is entered, &lt;code&gt;s1&lt;/code&gt; will automatically emit &lt;a href=&quot;qml-qtqml-statemachine-state#finished-signal&quot;&gt;finished&lt;/a&gt;. We use a signal transition to cause this event to trigger a state change:</source>
          <target state="translated">当进入 &lt;code&gt;s1&lt;/code&gt; 的最终状态时， &lt;code&gt;s1&lt;/code&gt; 将自动发出&lt;a href=&quot;qml-qtqml-statemachine-state#finished-signal&quot;&gt;finish&lt;/a&gt;。我们使用信号转换来导致此事件触发状态更改：</target>
        </trans-unit>
        <trans-unit id="a068e7c1d71be79be1747b295f8d0bdf7d0f76ad" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;s1&lt;/code&gt; 's final state is entered, &lt;code&gt;s1&lt;/code&gt; will automatically emit &lt;a href=&quot;qstate#finished&quot;&gt;finished()&lt;/a&gt;. We use a signal transition to cause this event to trigger a state change:</source>
          <target state="translated">当进入 &lt;code&gt;s1&lt;/code&gt; 的最终状态时， &lt;code&gt;s1&lt;/code&gt; 将自动发出&lt;a href=&quot;qstate#finished&quot;&gt;finish（）&lt;/a&gt;。我们使用信号转换来导致此事件触发状态更改：</target>
        </trans-unit>
        <trans-unit id="7c85d7dd31dd96c49b09a16e731e181b35179393" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;text&lt;/code&gt; changes, the C++ property &lt;code&gt;enteredText&lt;/code&gt; will update automatically.</source>
          <target state="translated">当 &lt;code&gt;text&lt;/code&gt; 的变化，C ++财产 &lt;code&gt;enteredText&lt;/code&gt; 将自动更新。</target>
        </trans-unit>
        <trans-unit id="274f974610c7463228dfb5154f647e8c8a8ccdcb" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;true&lt;/code&gt;, all generated numbers appearing in various series and axis labels will be localized using the &lt;a href=&quot;qlocale&quot;&gt;QLocale&lt;/a&gt; set with the &lt;a href=&quot;qchart#locale-prop&quot;&gt;locale&lt;/a&gt; property. When &lt;code&gt;false&lt;/code&gt;, the</source>
          <target state="translated">设置为 &lt;code&gt;true&lt;/code&gt; 时，将使用带有&lt;a href=&quot;qchart#locale-prop&quot;&gt;locale&lt;/a&gt;属性的&lt;a href=&quot;qlocale&quot;&gt;QLocale&lt;/a&gt;集来本地化出现在各个系列和轴标签中的所有生成的数字。如果为 &lt;code&gt;false&lt;/code&gt; ，则</target>
        </trans-unit>
        <trans-unit id="36e568b70799170c0d96b90a8147537bfc741c8b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;true&lt;/code&gt;, all generated numbers appearing in various series and axis labels will be localized using the &lt;a href=&quot;qlocale&quot;&gt;QLocale&lt;/a&gt; set with the &lt;a href=&quot;qml-qtcharts-chartview#locale-prop&quot;&gt;locale&lt;/a&gt; property. When &lt;code&gt;false&lt;/code&gt;, the</source>
          <target state="translated">设置为 &lt;code&gt;true&lt;/code&gt; 时，将使用带有&lt;a href=&quot;qml-qtcharts-chartview#locale-prop&quot;&gt;locale&lt;/a&gt;属性的&lt;a href=&quot;qlocale&quot;&gt;QLocale&lt;/a&gt;集来本地化出现在各个系列和轴标签中的所有生成的数字。如果为 &lt;code&gt;false&lt;/code&gt; ，则</target>
        </trans-unit>
        <trans-unit id="3e953b3a9be5222efb277759886bb97613fdfda7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;true&lt;/code&gt;, the style should underline the menu item's label mnemonic.</source>
          <target state="translated">如果为 &lt;code&gt;true&lt;/code&gt; ，则样式应在菜单项的标签助记符下划线。</target>
        </trans-unit>
        <trans-unit id="3172ee2682029786deccd528a524db012a091668" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;virtualIndex&lt;/code&gt; is not sufficient, the &lt;code&gt;virtualPos&lt;/code&gt; property can be used to explicitly specify the top-left position of the screen in question. Taking the previous example and assuming a resolution of 1080p for HDMI1, the following code snippet places a second HDMI-based screen below the first one:</source>
          <target state="translated">当 &lt;code&gt;virtualIndex&lt;/code&gt; 不足时， &lt;code&gt;virtualPos&lt;/code&gt; 属性可用于显式指定所讨论屏幕的左上角位置。以前面的示例为例，假设HDMI1的分辨率为1080p，下面的代码段将第二个基于HDMI的屏幕放在第一个屏幕下方：</target>
        </trans-unit>
        <trans-unit id="21a5b61887b0cac6a56dd588dce0ad7f3bbdb837" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;virtualIndex&lt;/code&gt; is not sufficient, the property &lt;code&gt;virtualPos&lt;/code&gt; can be used to explicitly specify the top-left position of the screen in question. Taking the previous example and assuming a resolution of 1080p for HDMI1, the following places a second HDMI-based screen below the first one:</source>
          <target state="translated">当 &lt;code&gt;virtualIndex&lt;/code&gt; 不足时，可以使用属性 &lt;code&gt;virtualPos&lt;/code&gt; 显式指定所讨论屏幕的左上位置。以前面的示例为例，假设HDMI1的分辨率为1080p，下面将在第二个基于HDMI的屏幕下方放置一个屏幕：</target>
        </trans-unit>
        <trans-unit id="ce9c2c5e673edc4df91dd9cd97b16eb59ee71073" translate="yes" xml:space="preserve">
          <source>When DPI scaling is used by the system, the logical surface size, which is used by mouse events, and the actual 'physical' size of the surface can differ. The &lt;a href=&quot;qml-qt3d-render-rendersurfaceselector#surfacePixelRatio-prop&quot;&gt;surfacePixelRatio&lt;/a&gt; is the factor to convert the logical size to the physical size.</source>
          <target state="translated">当系统使用DPI缩放时，鼠标事件使用的逻辑表面大小和表面的实际&amp;ldquo;物理&amp;rdquo;大小可能会有所不同。该&lt;a href=&quot;qml-qt3d-render-rendersurfaceselector#surfacePixelRatio-prop&quot;&gt;surfacePixelRatio&lt;/a&gt;是逻辑大小转换为物理尺寸的因素。</target>
        </trans-unit>
        <trans-unit id="67b4917a54c5a1f83822bb816252770e66fe2a99" translate="yes" xml:space="preserve">
          <source>When DPI scaling is used by the system, the logical surface size, which is used by mouse events, and the actual 'physical' size of the surface can differ. The &lt;a href=&quot;qt3drender-qrendersurfaceselector#surfacePixelRatio-prop&quot;&gt;surfacePixelRatio&lt;/a&gt; is the factor to convert the logical size to the physical size.</source>
          <target state="translated">当系统使用DPI缩放时，鼠标事件使用的逻辑表面大小和表面的实际&amp;ldquo;物理&amp;rdquo;大小可能会有所不同。该&lt;a href=&quot;qt3drender-qrendersurfaceselector#surfacePixelRatio-prop&quot;&gt;surfacePixelRatio&lt;/a&gt;是逻辑大小转换为物理尺寸的因素。</target>
        </trans-unit>
        <trans-unit id="f1b60dd5dc0ba61c9eadb5e24ff7b6a22b038279" translate="yes" xml:space="preserve">
          <source>When FPS measuring is enabled, the results for the last second are stored in this read-only property. It takes at least a second before this value updates after measuring is activated.</source>
          <target state="translated">当启用FPS测量时,最后一秒的结果存储在这个只读属性中。在测量被激活后,至少需要一秒钟的时间才能更新此值。</target>
        </trans-unit>
        <trans-unit id="c6d97e48bea8d713090e390fc1224dfc4ec5d0cc" translate="yes" xml:space="preserve">
          <source>When HSTS is enabled, for each HTTP response containing HSTS header and received over a secure transport, &lt;a href=&quot;qnetworkaccessmanager&quot;&gt;QNetworkAccessManager&lt;/a&gt; will update its HSTS cache, either remembering a host with a valid policy or removing a host with an expired or disabled HSTS policy.</source>
          <target state="translated">启用HSTS后，对于每个通过安全传输接收到的包含HSTS标头的HTTP响应，&lt;a href=&quot;qnetworkaccessmanager&quot;&gt;QNetworkAccessManager&lt;/a&gt;将更新其HSTS缓存，或者记住具有有效策略的主机，或者删除具有过期或禁用HSTS策略的主机。</target>
        </trans-unit>
        <trans-unit id="c813b063d1c6a422bc40a6bf5d97ec4ee0b41451" translate="yes" xml:space="preserve">
          <source>When HTML markup is used for text, Qt follows the rules defined by the &lt;a href=&quot;http://www.w3.org/TR/html401/&quot;&gt;HTML 4&lt;/a&gt; specification. This includes default properties for text layout, such as the direction of the text flow (left-to-right) which can be changed by applying the &lt;a href=&quot;#block-attributes&quot;&gt;&lt;code&gt;dir&lt;/code&gt;&lt;/a&gt; attribute to blocks of text.</source>
          <target state="translated">当HTML标记用于文本时，Qt遵循&lt;a href=&quot;http://www.w3.org/TR/html401/&quot;&gt;HTML 4&lt;/a&gt;规范定义的规则。这包括用于文本布局的默认属性，例如文本流的方向（从左到右），可以通过将&lt;a href=&quot;#block-attributes&quot;&gt; &lt;code&gt;dir&lt;/code&gt; &lt;/a&gt;属性应用于文本块来更改其方向。</target>
        </trans-unit>
        <trans-unit id="19e584a3c410cba7dfa95ae08639cd95d012b6b9" translate="yes" xml:space="preserve">
          <source>When HTML markup is used for text, Qt follows the rules defined by the &lt;a href=&quot;http://www.w3.org/TR/html401/&quot;&gt;HTML 4&lt;/a&gt; specification. This includes default properties for text layout, such as the direction of the text flow (left-to-right) which can be changed by applying the &lt;a href=&quot;richtext-html-subset#block-attributes&quot;&gt;&lt;code&gt;dir&lt;/code&gt;&lt;/a&gt; attribute to blocks of text.</source>
          <target state="translated">当HTML标记用于文本时，Qt遵循&lt;a href=&quot;http://www.w3.org/TR/html401/&quot;&gt;HTML 4&lt;/a&gt;规范定义的规则。这包括文本布局的默认属性，例如文本流的方向（从左到右），可以通过将&lt;a href=&quot;richtext-html-subset#block-attributes&quot;&gt; &lt;code&gt;dir&lt;/code&gt; &lt;/a&gt;属性应用于文本块来更改其方向。</target>
        </trans-unit>
        <trans-unit id="5d1022b311794461c30cab9756433a79175cb148" translate="yes" xml:space="preserve">
          <source>When HTML markup is used for text, Qt follows the rules defined by the &lt;a href=&quot;https://www.w3.org/TR/html401/&quot;&gt;HTML 4&lt;/a&gt; specification. This includes default properties for text layout, such as the direction of the text flow (left-to-right) which can be changed by applying the &lt;a href=&quot;richtext-html-subset#block-attributes&quot;&gt;&lt;code&gt;dir&lt;/code&gt;&lt;/a&gt; attribute to blocks of text.</source>
          <target state="translated">当HTML标记用于文本时，Qt遵循&lt;a href=&quot;https://www.w3.org/TR/html401/&quot;&gt;HTML 4&lt;/a&gt;规范定义的规则。这包括文本布局的默认属性，例如文本流的方向（从左到右），可以通过将&lt;a href=&quot;richtext-html-subset#block-attributes&quot;&gt; &lt;code&gt;dir&lt;/code&gt; &lt;/a&gt;属性应用于文本块来更改其方向。</target>
        </trans-unit>
        <trans-unit id="d031a5aad62e51b34085c95c6997afabca63874d" translate="yes" xml:space="preserve">
          <source>When LayoutDirectionAuto is used in conjunction with text layouting, it will imply that the text directionality is determined from the content of the string to be layouted.</source>
          <target state="translated">当LayoutDirectionAuto与文本布局结合使用时,它将意味着文本方向性是由要布局的字符串内容决定的。</target>
        </trans-unit>
        <trans-unit id="66418f264bb909da3c52c062e8ec0fb65ed558c8" translate="yes" xml:space="preserve">
          <source>When QDoc generates documentation for a project, it will also generate an &lt;code&gt;.index&lt;/code&gt; file containing URLs to each linkable entity in the project. Each dependency is a (lowercase) name of a project. This name must match with the base name of the index file generated for that project.</source>
          <target state="translated">当QDoc生成项目文档时，它还将生成一个 &lt;code&gt;.index&lt;/code&gt; 文件，其中包含指向该项目中每个可链接实体的URL。每个依赖项都是项目的（小写）名称。该名称必须与为该项目生成的索引文件的基本名称匹配。</target>
        </trans-unit>
        <trans-unit id="7dc427b9427e3f31178f1302dfba94644ceb86f8" translate="yes" xml:space="preserve">
          <source>When QML types produce logging messages, it improves traceability if they include the QML file and line number on which the particular instance was instantiated.</source>
          <target state="translated">当QML类型产生日志消息时,如果它们包含了特定实例被实例化的QML文件和行号,就可以提高可追溯性。</target>
        </trans-unit>
        <trans-unit id="28bd2e83bcbfe95859e587b4383125510038621a" translate="yes" xml:space="preserve">
          <source>When QPickingSettings::pickMode() is set to &lt;a href=&quot;qt3drender-qpickingsettings#PickMethod-enum&quot;&gt;QPickingSettings::TrianglePicking&lt;/a&gt;, the signals on &lt;a href=&quot;qt3drender-qobjectpicker&quot;&gt;QObjectPicker&lt;/a&gt; will carry an instance of &lt;a href=&quot;qt3drender-qpicktriangleevent&quot;&gt;QPickTriangleEvent&lt;/a&gt;.</source>
          <target state="translated">当QPickingSettings :: pickMode（）设置为&lt;a href=&quot;qt3drender-qpickingsettings#PickMethod-enum&quot;&gt;QPickingSettings :: TrianglePicking时&lt;/a&gt;，&lt;a href=&quot;qt3drender-qobjectpicker&quot;&gt;QObjectPicker&lt;/a&gt;上的信号将携带一个&lt;a href=&quot;qt3drender-qpicktriangleevent&quot;&gt;QPickTriangleEvent&lt;/a&gt;实例。</target>
        </trans-unit>
        <trans-unit id="df9dd3cc9e117bbee05447ec8831a1da2303f862" translate="yes" xml:space="preserve">
          <source>When QPickingSettings::pickMode() is set to &lt;a href=&quot;qt3drender-qpickingsettings#PickMethod-enum&quot;&gt;QPickingSettings::TrianglePicking&lt;/a&gt;, the signals on &lt;a href=&quot;qt3drender-qobjectpicker&quot;&gt;QObjectPicker&lt;/a&gt; will carry an instance of QPickTriangleEvent.</source>
          <target state="translated">当QPickingSettings :: pickMode（）设置为&lt;a href=&quot;qt3drender-qpickingsettings#PickMethod-enum&quot;&gt;QPickingSettings :: TrianglePicking时&lt;/a&gt;，&lt;a href=&quot;qt3drender-qobjectpicker&quot;&gt;QObjectPicker&lt;/a&gt;上的信号将携带一个QPickTriangleEvent实例。</target>
        </trans-unit>
        <trans-unit id="457be61d0f002d025c887c713d51fbbfadff17ad" translate="yes" xml:space="preserve">
          <source>When QPickingSettings::pickMode() is set to QPickingSettings::TrianglePicking, the signals on QObjectPicker will carry an instance of QPickTriangleEvent.</source>
          <target state="translated">当QPickingSettings::pickMode()设置为QPickingSettings::TrianglePicking时,QObjectPicker上的信号将携带一个QPickTriangleEvent的实例。</target>
        </trans-unit>
        <trans-unit id="508f9df752233b565bb26370c5a26e20603658ac" translate="yes" xml:space="preserve">
          <source>When QPlainTextEdit is used read-only the key bindings are limited to navigation, and text may only be selected with the mouse:</source>
          <target state="translated">当QPlainTextEdit只读使用时,键的绑定仅限于导航,而文本只能用鼠标选择。</target>
        </trans-unit>
        <trans-unit id="2b3dce7cb91174e257ba7a5b773f5733c0ba5ef8" translate="yes" xml:space="preserve">
          <source>When QRegExpValidator determines whether a string is &lt;a href=&quot;qvalidator#State-enum&quot;&gt;Acceptable&lt;/a&gt; or not, the regexp is treated as if it begins with the start of string assertion (&lt;b&gt;^&lt;/b&gt;) and ends with the end of string assertion (&lt;b&gt;$&lt;/b&gt;); the match is against the entire input string, or from the given position if a start position greater than zero is given.</source>
          <target state="translated">当QRegExpValidator确定字符串是否&lt;a href=&quot;qvalidator#State-enum&quot;&gt;可接受时&lt;/a&gt;，将正则表达式视为从字符串断言的开头（&lt;b&gt;^&lt;/b&gt;）开始到字符串断言的结尾（&lt;b&gt;$&lt;/b&gt;）结束；匹配将针对整个输入字符串，如果给定的起始位置大于零，则从给定位置进行匹配。</target>
        </trans-unit>
        <trans-unit id="44b35bfd10db30a7d0a3ac39d2072ec92e99876a" translate="yes" xml:space="preserve">
          <source>When QTextEdit is used read-only the key bindings are limited to navigation, and text may only be selected with the mouse:</source>
          <target state="translated">当QTextEdit是只读使用时,键的绑定仅限于导航,文本只能用鼠标选择。</target>
        </trans-unit>
        <trans-unit id="b100506a7296cf4856e2d55c43642a514b0d282b" translate="yes" xml:space="preserve">
          <source>When QXmlQuery accesses resources (e.g., calling &lt;code&gt;fn:doc()&lt;/code&gt; to load a file, or accessing a device via a bound variable), the event loop is used, which means events will be processed. To avoid processing events when QXmlQuery accesses resources, create your QXmlQuery instance in a separate thread.</source>
          <target state="translated">当QXmlQuery访问资源（例如，调用 &lt;code&gt;fn:doc()&lt;/code&gt; 加载文件或通过绑定变量访问设备）时，将使用事件循环，这意味着将处理事件。为了避免在QXmlQuery访问资源时处理事件，请在单独的线程中创建QXmlQuery实例。</target>
        </trans-unit>
        <trans-unit id="228d842e43fc176fb1a2d3aa0180185c47dc88bd" translate="yes" xml:space="preserve">
          <source>When Qt XML Patterns calls &lt;a href=&quot;qabstracturiresolver#resolve&quot;&gt;QAbstractUriResolver::resolve&lt;/a&gt;() the absolute URI is the URI mandated by the &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; language, and the relative URI is the URI specified by the user.</source>
          <target state="translated">当Qt XML模式调用&lt;a href=&quot;qabstracturiresolver#resolve&quot;&gt;QAbstractUriResolver :: resolve&lt;/a&gt;（）时，绝对URI是&lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt;语言规定的URI ，相对URI是用户指定的URI。</target>
        </trans-unit>
        <trans-unit id="e7ad967bec3128bd4f1fd05f2c5749f62466760b" translate="yes" xml:space="preserve">
          <source>When Qt XML Patterns calls &lt;a href=&quot;qabstracturiresolver#resolve&quot;&gt;QAbstractUriResolver::resolve&lt;/a&gt;() the absolute URI is the URI mandated by the &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; language, and the relative URI is the URI specified by the user.</source>
          <target state="translated">当Qt XML模式调用&lt;a href=&quot;qabstracturiresolver#resolve&quot;&gt;QAbstractUriResolver :: resolve&lt;/a&gt;（）时，绝对URI是&lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt;语言规定的URI ，而相对URI是用户指定的URI。</target>
        </trans-unit>
        <trans-unit id="f47f9cfcc0372f2d7543bfb2e549c724e778aa90" translate="yes" xml:space="preserve">
          <source>When Qt XML Patterns calls &lt;a href=&quot;qabstracturiresolver#resolve&quot;&gt;QAbstractUriResolver::resolve&lt;/a&gt;() the absolute URI is the URI mandated by the schema specification, and the relative URI is the URI specified by the user.</source>
          <target state="translated">当Qt XML模式调用&lt;a href=&quot;qabstracturiresolver#resolve&quot;&gt;QAbstractUriResolver :: resolve&lt;/a&gt;（）时，绝对URI是架构规范规定的URI，而相对URI是用户指定的URI。</target>
        </trans-unit>
        <trans-unit id="b7e889092d153ecf78cedbfcbcb9a5e6e6e850e1" translate="yes" xml:space="preserve">
          <source>When Qt XML Patterns evaluate path expressions, it emulate them through a combination of calls with &lt;a href=&quot;qabstractxmlnodemodel#SimpleAxis-enum&quot;&gt;QSimpleXmlNodeModel::SimpleAxis&lt;/a&gt; values. Therefore, the implementation of this function must return the node, if any, that appears on the</source>
          <target state="translated">当Qt XML模式评估路径表达式时，它将通过结合使用&lt;a href=&quot;qabstractxmlnodemodel#SimpleAxis-enum&quot;&gt;QSimpleXmlNodeModel :: SimpleAxis&lt;/a&gt;值的调用来模拟它们。因此，此功能的实现必须返回出现在节点上的节点（如果有）。</target>
        </trans-unit>
        <trans-unit id="e87346c400d28fb6331382be4402bbe0f7b9fc30" translate="yes" xml:space="preserve">
          <source>When Qt XML Patterns loads an XML resource, e.g., using the &lt;code&gt;fn:doc()&lt;/code&gt; function, the following schemes are supported:</source>
          <target state="translated">当Qt XML模式（例如，使用 &lt;code&gt;fn:doc()&lt;/code&gt; 函数）加载XML资源时，支持以下方案：</target>
        </trans-unit>
        <trans-unit id="8d2df247c302bc0aef9cb5b8701b3ccf2c5556f3" translate="yes" xml:space="preserve">
          <source>When Qt XML Patterns loads and queries XML files and produces XML output, it can always load the XML data into its default XML node model, where it can be traversed efficiently. The &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; below traverses the product orders found in the XML file</source>
          <target state="translated">当Qt XML Patterns加载和查询XML文件并产生XML输出时，它总是可以将XML数据加载到其默认XML节点模型中，从而可以在其中进行有效遍历。下面的&lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt;遍历XML文件中找到的产品订单</target>
        </trans-unit>
        <trans-unit id="fbd1af30e0b1f7879d2e090097ce1ee9bc1b1e77" translate="yes" xml:space="preserve">
          <source>When Qt XML Patterns loads and queries XML files and produces XML output, it can always load the XML data into its default XML node model, where it can be traversed efficiently. The XQuery below traverses the product orders found in the XML file</source>
          <target state="translated">当Qt XML Patterns加载和查询XML文件并产生XML输出时,它总是可以将XML数据加载到其默认的XML节点模型中,在那里可以有效地遍历。下面的XQuery遍历XML文件中的产品订单。</target>
        </trans-unit>
        <trans-unit id="27bec0f91bee9a8e04a2b33675d236e7ab402351" translate="yes" xml:space="preserve">
          <source>When Qt's translation tool, &lt;a href=&quot;https://doc.qt.io/qt-5.13/linguist-manager.html#using-lupdate&quot;&gt;lupdate&lt;/a&gt;, is used to process a set of source files, the text wrapped in tr() calls is stored in a section of the translation file that corresponds to its translation context.</source>
          <target state="translated">当Qt的翻译工具&lt;a href=&quot;https://doc.qt.io/qt-5.13/linguist-manager.html#using-lupdate&quot;&gt;lupdate&lt;/a&gt;用于处理一组源文件时，包裹在tr（）调用中的文本存储在翻译文件对应于其翻译上下文的部分中。</target>
        </trans-unit>
        <trans-unit id="785ca6db3b40442948e6e7e14bdd25ed39799f88" translate="yes" xml:space="preserve">
          <source>When Qt's translation tool, &lt;a href=&quot;https://doc.qt.io/qt-5.15/linguist-manager.html#using-lupdate&quot;&gt;lupdate&lt;/a&gt;, is used to process a set of source files, the text wrapped in tr() calls is stored in a section of the translation file that corresponds to its translation context.</source>
          <target state="translated">当Qt的翻译工具&lt;a href=&quot;https://doc.qt.io/qt-5.15/linguist-manager.html#using-lupdate&quot;&gt;lupdate&lt;/a&gt;用于处理一组源文件时，包裹在tr（）调用中的文本存储在翻译文件对应于其翻译上下文的部分中。</target>
        </trans-unit>
        <trans-unit id="ba680e61679f9aeda5f865655440baac889d7601" translate="yes" xml:space="preserve">
          <source>When Qt's translation tool, &lt;a href=&quot;https://doc.qt.io/qt-6.0/linguist-manager.html#using-lupdate&quot;&gt;lupdate&lt;/a&gt;, is used to process a set of source files, the text wrapped in tr() calls is stored in a section of the translation file that corresponds to its translation context.</source>
          <target state="translated">当Qt的翻译工具&lt;a href=&quot;https://doc.qt.io/qt-6.0/linguist-manager.html#using-lupdate&quot;&gt;lupdate&lt;/a&gt;用于处理一组源文件时，包裹在tr（）调用中的文本存储在翻译文件对应于其翻译上下文的部分中。</target>
        </trans-unit>
        <trans-unit id="d716f69d72489992d975e006d6741d1a3935bbd6" translate="yes" xml:space="preserve">
          <source>When Qt5 came along, Qt was divided into modules. Since then, many new modules have been added to Qt. As of version 5.5, there are over 40 separate modules in Qt5, each with its own documentation that links to (depends on) the documentation of other Qt modules.</source>
          <target state="translated">当Qt5出现的时候,Qt被划分为多个模块。从那时起,Qt中增加了许多新的模块。截至5.5版本,Qt5中有超过40个独立的模块,每个模块都有自己的文档,这些文档链接到(依赖于)其他Qt模块的文档。</target>
        </trans-unit>
        <trans-unit id="f177dcbb96dea9d408ace28c5d859883092740d9" translate="yes" xml:space="preserve">
          <source>When ScrollBar is attached &lt;a href=&quot;qml-qtquick-controls2-scrollbar#vertical-attached-prop&quot;&gt;vertically&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-controls2-scrollbar#horizontal-attached-prop&quot;&gt;horizontally&lt;/a&gt; to a Flickable, its geometry and the following properties are automatically set and updated as appropriate:</source>
          <target state="translated">当ScrollBar&lt;a href=&quot;qml-qtquick-controls2-scrollbar#vertical-attached-prop&quot;&gt;垂直&lt;/a&gt;或&lt;a href=&quot;qml-qtquick-controls2-scrollbar#horizontal-attached-prop&quot;&gt;水平&lt;/a&gt;连接到Flickable时，其几何形状和以下属性将自动设置并适当更新：</target>
        </trans-unit>
        <trans-unit id="709f09eba453dec3aff9d67b6d37f765373bd46f" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qfile&quot;&gt;QFile&lt;/a&gt; is opened using this function, behaviour of &lt;a href=&quot;qfiledevice#close&quot;&gt;close&lt;/a&gt;() is controlled by the &lt;a href=&quot;qfiledevice#FileHandleFlag-enum&quot;&gt;AutoCloseHandle&lt;/a&gt; flag. If &lt;a href=&quot;qfiledevice#FileHandleFlag-enum&quot;&gt;AutoCloseHandle&lt;/a&gt; is specified, and this function succeeds, then calling &lt;a href=&quot;qfiledevice#close&quot;&gt;close&lt;/a&gt;() closes the adopted handle. Otherwise, &lt;a href=&quot;qfiledevice#close&quot;&gt;close&lt;/a&gt;() does not actually close the file, but only flushes it.</source>
          <target state="translated">当&lt;a href=&quot;qfile&quot;&gt;QFile时&lt;/a&gt;使用此功能，行为打开&lt;a href=&quot;qfiledevice#close&quot;&gt;关闭&lt;/a&gt;（）由受控&lt;a href=&quot;qfiledevice#FileHandleFlag-enum&quot;&gt;AutoCloseHandle&lt;/a&gt;标志。如果指定了&lt;a href=&quot;qfiledevice#FileHandleFlag-enum&quot;&gt;AutoCloseHandle&lt;/a&gt;，并且此函数成功执行，则调用&lt;a href=&quot;qfiledevice#close&quot;&gt;close&lt;/a&gt;（）将关闭采用的句柄。否则，&lt;a href=&quot;qfiledevice#close&quot;&gt;close&lt;/a&gt;（）实际上不会关闭文件，而只会刷新它。</target>
        </trans-unit>
        <trans-unit id="cb1e3502bc0fff8a5da1c27970f713a4cbcb877b" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; receives Qt mouse, keyboard, and drag and drop events (&lt;a href=&quot;qmouseevent&quot;&gt;QMouseEvent&lt;/a&gt;, &lt;a href=&quot;qkeyevent&quot;&gt;QKeyEvent&lt;/a&gt;, QDragEvent, etc.), it translates them into instances of &lt;a href=&quot;qgraphicssceneevent&quot;&gt;QGraphicsSceneEvent&lt;/a&gt; subclasses and forwards them to the &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; it displays. The scene then forwards the events to the relevant items.</source>
          <target state="translated">当&lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt;接收到Qt鼠标，键盘和拖放事件（&lt;a href=&quot;qmouseevent&quot;&gt;QMouseEvent&lt;/a&gt;，&lt;a href=&quot;qkeyevent&quot;&gt;QKeyEvent&lt;/a&gt;，QDragEvent等）时，它将它们转换为&lt;a href=&quot;qgraphicssceneevent&quot;&gt;QGraphicsSceneEvent&lt;/a&gt;子类的实例，并将其转发到它显示的&lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt;。然后，场景将事件转发到相关项目。</target>
        </trans-unit>
        <trans-unit id="5554f9846d1af01927d9497ed433e3fe74b4e0e1" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; receives Qt mouse, keyboard, and drag and drop events (&lt;a href=&quot;qmouseevent&quot;&gt;QMouseEvent&lt;/a&gt;, &lt;a href=&quot;qkeyevent&quot;&gt;QKeyEvent&lt;/a&gt;, QDragEvent, etc.), it translates them into instances of QGraphicsSceneEvent subclasses and forwards them to the &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; it displays. The scene then forwards the events to the relevant items.</source>
          <target state="translated">当&lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt;接收到Qt鼠标，键盘和拖放事件（&lt;a href=&quot;qmouseevent&quot;&gt;QMouseEvent&lt;/a&gt;，&lt;a href=&quot;qkeyevent&quot;&gt;QKeyEvent&lt;/a&gt;，QDragEvent等）时，它将它们转换为QGraphicsSceneEvent子类的实例，并将其转发到它显示的&lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt;。然后，场景将事件转发到相关项目。</target>
        </trans-unit>
        <trans-unit id="7ca650c784a62d89aa1bd61df5a5c661ba25f79c" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; receives a &lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt; of type &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::ToolTip&lt;/a&gt;, it creates a &lt;a href=&quot;qgraphicsscenehelpevent&quot;&gt;QGraphicsSceneHelpEvent&lt;/a&gt;, which is forwarded to the scene. You can set a tooltip on a &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; with &lt;a href=&quot;qgraphicsitem#setToolTip&quot;&gt;setToolTip()&lt;/a&gt;; by default &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; displays the tooltip of the &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; with the highest z-value (i.e, the top-most item) under the mouse position.</source>
          <target state="translated">当&lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt;接收到&lt;a href=&quot;qevent&quot;&gt;QEvent &lt;/a&gt;&lt;a href=&quot;qevent#Type-enum&quot;&gt;:: ToolTip&lt;/a&gt;类型的QEvent时，它将创建&lt;a href=&quot;qgraphicsscenehelpevent&quot;&gt;QGraphicsSceneHelpEvent&lt;/a&gt;，并将其转发到场景。您可以使用&lt;a href=&quot;qgraphicsitem#setToolTip&quot;&gt;setToolTip（）&lt;/a&gt;在&lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt;上设置工具提示；默认情况下，&lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt;在鼠标位置下方显示具有最高z值（即，最顶部的项目）的&lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt;的工具提示。</target>
        </trans-unit>
        <trans-unit id="405906d74ba9d56a4a09585d6f6ec8dd6144ef07" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; receives a &lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt; of type &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::ToolTip&lt;/a&gt;, it creates a QGraphicsSceneHelpEvent, which is forwarded to the scene. You can set a tooltip on a &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; with &lt;a href=&quot;qgraphicsitem#setToolTip&quot;&gt;setToolTip()&lt;/a&gt;; by default &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; displays the tooltip of the &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; with the highest z-value (i.e, the top-most item) under the mouse position.</source>
          <target state="translated">当&lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt;接收到&lt;a href=&quot;qevent&quot;&gt;QEvent &lt;/a&gt;&lt;a href=&quot;qevent#Type-enum&quot;&gt;:: ToolTip&lt;/a&gt;类型的QEvent时，它将创建一个QGraphicsSceneHelpEvent，该事件将转发到场景。您可以使用&lt;a href=&quot;qgraphicsitem#setToolTip&quot;&gt;setToolTip（）&lt;/a&gt;在&lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt;上设置工具提示；默认情况下，&lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt;在鼠标位置下方显示具有最高z值（即，最顶部的项）的&lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt;的工具提示。</target>
        </trans-unit>
        <trans-unit id="393e354c9ea9f2a89f579509e189a24bb7a827a0" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; receives a &lt;a href=&quot;qhoverevent&quot;&gt;QHoverEvent&lt;/a&gt; event, it translates it into &lt;a href=&quot;qgraphicsscenehoverevent&quot;&gt;QGraphicsSceneHoverEvent&lt;/a&gt;. The event is then forwarded to the &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; associated with the view.</source>
          <target state="translated">当&lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt;收到&lt;a href=&quot;qhoverevent&quot;&gt;QHoverEvent&lt;/a&gt;事件时，它将其转换为&lt;a href=&quot;qgraphicsscenehoverevent&quot;&gt;QGraphicsSceneHoverEvent&lt;/a&gt;。然后将事件转发到与视图关联的&lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3ae68b18a5e42b2ce917dd23d94ec19620288dec" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; receives a &lt;a href=&quot;qhoverevent&quot;&gt;QHoverEvent&lt;/a&gt; event, it translates it into QGraphicsSceneHoverEvent. The event is then forwarded to the &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; associated with the view.</source>
          <target state="translated">当&lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt;收到&lt;a href=&quot;qhoverevent&quot;&gt;QHoverEvent&lt;/a&gt;事件时，它将其转换为QGraphicsSceneHoverEvent。然后将事件转发到与视图关联的&lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="beba9444d0901cd09b88793cbb92e83a0fb0a4c8" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; receives a &lt;a href=&quot;qmouseevent&quot;&gt;QMouseEvent&lt;/a&gt;, it translates it to a &lt;a href=&quot;qgraphicsscenemouseevent&quot;&gt;QGraphicsSceneMouseEvent&lt;/a&gt;. The event is then forwarded to the &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; associated with the view. If the event is not handled by the scene, the view may use it, e.g., for the &lt;a href=&quot;qgraphicsview#DragMode-enum&quot;&gt;DragMode&lt;/a&gt;.</source>
          <target state="translated">当&lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt;收到&lt;a href=&quot;qmouseevent&quot;&gt;QMouseEvent时&lt;/a&gt;，它将其转换为&lt;a href=&quot;qgraphicsscenemouseevent&quot;&gt;QGraphicsSceneMouseEvent&lt;/a&gt;。然后将事件转发到与视图关联的&lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt;。如果场景未处理事件，则视图可以将其用于例如&lt;a href=&quot;qgraphicsview#DragMode-enum&quot;&gt;DragMode&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0d58e00a0b32556ea464156ee58eaa63878af86f" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; receives a &lt;a href=&quot;qmouseevent&quot;&gt;QMouseEvent&lt;/a&gt;, it translates it to a QGraphicsSceneMouseEvent. The event is then forwarded to the &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; associated with the view. If the event is not handled by the scene, the view may use it, e.g., for the &lt;a href=&quot;qgraphicsview#DragMode-enum&quot;&gt;DragMode&lt;/a&gt;.</source>
          <target state="translated">当&lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt;收到&lt;a href=&quot;qmouseevent&quot;&gt;QMouseEvent时&lt;/a&gt;，它将其转换为QGraphicsSceneMouseEvent。然后将事件转发到与视图关联的&lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt;。如果事件未由场景处理，则视图可以使用该事件，例如，将其用于&lt;a href=&quot;qgraphicsview#DragMode-enum&quot;&gt;DragMode&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b1aa704cf88adf38927fd01a2a14f929a34849e2" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qml-qt3d-render-nodraw&quot;&gt;NoDraw&lt;/a&gt; node is present in a FrameGraph branch, this prevents the renderer from rendering any primitive. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">当FrameGraph分支中存在&lt;a href=&quot;qml-qt3d-render-nodraw&quot;&gt;NoDraw&lt;/a&gt;节点时，这将阻止渲染器渲染任何基元。&lt;a href=&quot;#details&quot;&gt;更多...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d712cc482a400f11481ce544723b23f89d2fced9" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; calls &lt;a href=&quot;https://doc.qt.io/qt-5.13/qaccessible-obsolete.html#updateAccessibility&quot;&gt;updateAccessibility()&lt;/a&gt;, clients that are listening to events are notified of the change. The function is used to post events to the assistive technology, and accessible &lt;a href=&quot;qaccessible#Event-enum&quot;&gt;events&lt;/a&gt; are posted by &lt;a href=&quot;https://doc.qt.io/qt-5.13/qaccessible-obsolete.html#updateAccessibility&quot;&gt;updateAccessibility()&lt;/a&gt;.</source>
          <target state="translated">当&lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;调用&lt;a href=&quot;https://doc.qt.io/qt-5.13/qaccessible-obsolete.html#updateAccessibility&quot;&gt;updateAccessibility（）时&lt;/a&gt;，将向侦听事件的客户端通知更改。该函数用于将事件发布到辅助技术，可访问&lt;a href=&quot;qaccessible#Event-enum&quot;&gt;事件&lt;/a&gt;由&lt;a href=&quot;https://doc.qt.io/qt-5.13/qaccessible-obsolete.html#updateAccessibility&quot;&gt;updateAccessibility（）&lt;/a&gt;发布。</target>
        </trans-unit>
        <trans-unit id="a44c30b5bf2354f4fd8f996e028fe8735a8ada05" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; calls &lt;a href=&quot;https://doc.qt.io/qt-5.15/qaccessible-obsolete.html#updateAccessibility&quot;&gt;updateAccessibility()&lt;/a&gt;, clients that are listening to events are notified of the change. The function is used to post events to the assistive technology, and accessible &lt;a href=&quot;qaccessible#Event-enum&quot;&gt;events&lt;/a&gt; are posted by &lt;a href=&quot;https://doc.qt.io/qt-5.15/qaccessible-obsolete.html#updateAccessibility&quot;&gt;updateAccessibility()&lt;/a&gt;.</source>
          <target state="translated">当&lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;调用&lt;a href=&quot;https://doc.qt.io/qt-5.15/qaccessible-obsolete.html#updateAccessibility&quot;&gt;updateAccessibility（）时&lt;/a&gt;，正在监听事件的客户端会收到有关更改的通知。该函数用于将事件发布到辅助技术，可访问&lt;a href=&quot;qaccessible#Event-enum&quot;&gt;事件&lt;/a&gt;由&lt;a href=&quot;https://doc.qt.io/qt-5.15/qaccessible-obsolete.html#updateAccessibility&quot;&gt;updateAccessibility（）&lt;/a&gt;发布。</target>
        </trans-unit>
        <trans-unit id="abe25525c8927613ab9c260ebd469a11b85a3f96" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; calls &lt;a href=&quot;qaccessible#updateAccessibility&quot;&gt;updateAccessibility()&lt;/a&gt;, clients that are listening to events are notified of the change. The function is used to post events to the assistive technology, and accessible &lt;a href=&quot;qaccessible#Event-enum&quot;&gt;events&lt;/a&gt; are posted by &lt;a href=&quot;qaccessible#updateAccessibility&quot;&gt;updateAccessibility()&lt;/a&gt;.</source>
          <target state="translated">当&lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;调用&lt;a href=&quot;qaccessible#updateAccessibility&quot;&gt;updateAccessibility（）时&lt;/a&gt;，正在监听事件的客户端会收到有关更改的通知。该函数用于将事件发布到辅助技术，可访问&lt;a href=&quot;qaccessible#Event-enum&quot;&gt;事件&lt;/a&gt;由&lt;a href=&quot;qaccessible#updateAccessibility&quot;&gt;updateAccessibility（）&lt;/a&gt;发布。</target>
        </trans-unit>
        <trans-unit id="bc5c853e12ceaddd145dd8068a3f01709b57c0cc" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; is deleted, it emits this &lt;a href=&quot;qobject#destroyed&quot;&gt;QObject::destroyed&lt;/a&gt;() signal. We want to catch this signal, wherever we might have a dangling reference to the deleted &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;, so we can clean it up. A suitable slot signature might be:</source>
          <target state="translated">当&lt;a href=&quot;qobject&quot;&gt;QObject的&lt;/a&gt;被删除时，它发射这个&lt;a href=&quot;qobject#destroyed&quot;&gt;的QObject ::破坏&lt;/a&gt;（）信号。无论何时何地都有对已删除&lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;的悬挂引用，我们都想捕获此信号，以便我们可以对其进行清理。合适的插槽签名可能是：</target>
        </trans-unit>
        <trans-unit id="d5dd864966ee74351524f25c84e86e7278c96ac6" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; is moved to another thread, all its children will be automatically moved too.</source>
          <target state="translated">当一个&lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;移到另一个线程时，它的所有子对象也将被自动移动。</target>
        </trans-unit>
        <trans-unit id="5954371cae64cc8ee9901844bd7778dc5d52aaf5" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; is passed to the &lt;a href=&quot;qjsengine#newQObject&quot;&gt;QJSEngine::newQObject&lt;/a&gt;() function, a Qt Script wrapper object is created that can be used to make the &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;'s signals, slots, properties, and child objects available to scripts.</source>
          <target state="translated">当&lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;传递给&lt;a href=&quot;qjsengine#newQObject&quot;&gt;QJSEngine :: newQObject&lt;/a&gt;（）函数时，将创建一个Qt脚本包装器对象，该对象可用于使&lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;的信号，插槽，属性和子对象可用于脚本。</target>
        </trans-unit>
        <trans-unit id="3af90ba954a525651c11676587fb2037323acba5" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; instance is deliberately hidden with &lt;a href=&quot;qwindow#hide&quot;&gt;hide&lt;/a&gt;() or &lt;a href=&quot;qwindow#visible-prop&quot;&gt;setVisible&lt;/a&gt;(false), it will stop rendering and its scene graph and graphics context might be released. The &lt;a href=&quot;qquickwindow#sceneGraphInvalidated&quot;&gt;sceneGraphInvalidated&lt;/a&gt;() signal will be emitted when this happens.</source>
          <target state="translated">当使用&lt;a href=&quot;qwindow#hide&quot;&gt;hide&lt;/a&gt;（）或&lt;a href=&quot;qwindow#visible-prop&quot;&gt;setVisible&lt;/a&gt;（false）故意隐藏&lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt;实例时，它将停止渲染并且可能会释放其场景图和图形上下文。所述&lt;a href=&quot;qquickwindow#sceneGraphInvalidated&quot;&gt;sceneGraphInvalidated&lt;/a&gt;发生这种情况时（在）信号将被发射。</target>
        </trans-unit>
        <trans-unit id="5554553d845c524ddee2156401f7cea7ba23f3a7" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qt3drender-qmemorybarrier&quot;&gt;QMemoryBarrier&lt;/a&gt; node is found in a FrameGraph branch, the barrier will be enforced prior to any draw or compute command even if these are defined deeper in the branch.</source>
          <target state="translated">当在FrameGraph分支中找到&lt;a href=&quot;qt3drender-qmemorybarrier&quot;&gt;QMemoryBarrier&lt;/a&gt;节点时，即使在分支中更深地定义了这些绘制或计算命令，也将在执行任何屏障之前执行该屏障。</target>
        </trans-unit>
        <trans-unit id="ba17b5ca58006cf8654bdb06b74fa570795c9e22" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qt3drender-qnodraw&quot;&gt;Qt3DRender::QNoDraw&lt;/a&gt; node is present in a FrameGraph branch, this prevents the renderer from rendering any primitive. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">当&lt;a href=&quot;qt3drender-qnodraw&quot;&gt;Qt3DRender :: QNoDraw&lt;/a&gt;节点存在于FrameGraph分支中时，这将阻止渲染器渲染任何基元。&lt;a href=&quot;#details&quot;&gt;更多...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="548a84d157a52956b642a6c79fa3b16cff4cbb88" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qt3drender-qnodraw&quot;&gt;Qt3DRender::QNoDraw&lt;/a&gt; node is present in a FrameGraph branch, this prevents the renderer from rendering any primitive. &lt;a href=&quot;qt3drender-qnodraw#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">当&lt;a href=&quot;qt3drender-qnodraw&quot;&gt;Qt3DRender :: QNoDraw&lt;/a&gt;节点存在于FrameGraph分支中时，这将阻止渲染器渲染任何基元。&lt;a href=&quot;qt3drender-qnodraw#details&quot;&gt;更多...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3cd19e17aad321610c519687f38dc05666afdeec" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qt3drender-qnopicking&quot;&gt;Qt3DRender::QNoPicking&lt;/a&gt; node is present in a FrameGraph branch, this prevents the render aspect from performing picking selection for the given branch. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">当FrameGraph分支中存在&lt;a href=&quot;qt3drender-qnopicking&quot;&gt;Qt3DRender :: QNoPicking&lt;/a&gt;节点时，这将阻止渲染方面对给定分支执行选择选择。&lt;a href=&quot;#details&quot;&gt;更多的...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="48029ceeb2e178ce68055405481fb634ea787fe6" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qt3drender-qnopicking&quot;&gt;Qt3DRender::QNoPicking&lt;/a&gt; node is present in a FrameGraph branch, this prevents the render aspect from performing picking selection for the given branch. &lt;a href=&quot;qt3drender-qnopicking#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">当FrameGraph分支中存在&lt;a href=&quot;qt3drender-qnopicking&quot;&gt;Qt3DRender :: QNoPicking&lt;/a&gt;节点时，这将阻止渲染方面对给定分支执行选择选择。&lt;a href=&quot;qt3drender-qnopicking#details&quot;&gt;更多的...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="88153895f9568d781c480af110178d98fc9ac494" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qtoolbar&quot;&gt;QToolBar&lt;/a&gt; is not a child of a &lt;a href=&quot;qmainwindow&quot;&gt;QMainWindow&lt;/a&gt;, it loses the ability to populate the extension pop up with widgets added to the toolbar using &lt;a href=&quot;qtoolbar#addWidget&quot;&gt;addWidget&lt;/a&gt;(). Please use widget actions created by inheriting &lt;a href=&quot;qwidgetaction&quot;&gt;QWidgetAction&lt;/a&gt; and implementing &lt;a href=&quot;qwidgetaction#createWidget&quot;&gt;QWidgetAction::createWidget&lt;/a&gt;() instead.</source>
          <target state="translated">当&lt;a href=&quot;qtoolbar&quot;&gt;QToolBar&lt;/a&gt;不是&lt;a href=&quot;qmainwindow&quot;&gt;QMainWindow&lt;/a&gt;的子级时，它将失去使用&lt;a href=&quot;qtoolbar#addWidget&quot;&gt;addWidget&lt;/a&gt;（）添加到工具栏中的小部件填充扩展弹出窗口的功能。请使用通过继承&lt;a href=&quot;qwidgetaction&quot;&gt;QWidgetAction&lt;/a&gt;并实现&lt;a href=&quot;qwidgetaction#createWidget&quot;&gt;QWidgetAction :: createWidget&lt;/a&gt;（）而创建的窗口小部件动作。</target>
        </trans-unit>
        <trans-unit id="ea339d196247f8a4535ab539b791214e5503ae1d" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qwizardpage#subTitle-prop&quot;&gt;subTitle&lt;/a&gt; is set, &lt;a href=&quot;qwizard&quot;&gt;QWizard&lt;/a&gt; displays it in a header, in which case it also uses the &lt;a href=&quot;qwizard#WizardPixmap-enum&quot;&gt;BannerPixmap&lt;/a&gt; and the &lt;a href=&quot;qwizard#WizardPixmap-enum&quot;&gt;LogoPixmap&lt;/a&gt; to decorate the header. The &lt;a href=&quot;qwizard#WizardPixmap-enum&quot;&gt;WatermarkPixmap&lt;/a&gt; is displayed on the left side, below the header. At the bottom, there is a row of buttons allowing the user to navigate through the pages.</source>
          <target state="translated">当&lt;a href=&quot;qwizardpage#subTitle-prop&quot;&gt;字幕&lt;/a&gt;设置，&lt;a href=&quot;qwizard&quot;&gt;QWizard&lt;/a&gt;其显示在报头中，在这种情况下，它也使用&lt;a href=&quot;qwizard#WizardPixmap-enum&quot;&gt;BannerPixmap&lt;/a&gt;和&lt;a href=&quot;qwizard#WizardPixmap-enum&quot;&gt;LogoPixmap&lt;/a&gt;装饰头部。所述&lt;a href=&quot;qwizard#WizardPixmap-enum&quot;&gt;WatermarkPixmap&lt;/a&gt;被显示在左侧，头部的下方。在底部，有一排按钮允许用户浏览页面。</target>
        </trans-unit>
        <trans-unit id="399d5e73a4a8b06dd36c1720633609c913f08193" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qwizardpage#subTitle-prop&quot;&gt;subTitle&lt;/a&gt; is set, QWizard displays it in a header, in which case it also uses the &lt;a href=&quot;qwizard#WizardPixmap-enum&quot;&gt;BannerPixmap&lt;/a&gt; and the &lt;a href=&quot;qwizard#WizardPixmap-enum&quot;&gt;LogoPixmap&lt;/a&gt; to decorate the header. The &lt;a href=&quot;qwizard#WizardPixmap-enum&quot;&gt;WatermarkPixmap&lt;/a&gt; is displayed on the left side, below the header. At the bottom, there is a row of buttons allowing the user to navigate through the pages.</source>
          <target state="translated">当&lt;a href=&quot;qwizardpage#subTitle-prop&quot;&gt;字幕&lt;/a&gt;设置，QWizard其显示在报头中，在这种情况下，它也使用&lt;a href=&quot;qwizard#WizardPixmap-enum&quot;&gt;BannerPixmap&lt;/a&gt;和&lt;a href=&quot;qwizard#WizardPixmap-enum&quot;&gt;LogoPixmap&lt;/a&gt;装饰头部。所述&lt;a href=&quot;qwizard#WizardPixmap-enum&quot;&gt;WatermarkPixmap&lt;/a&gt;被显示在左侧，头部的下方。在底部，有一排按钮允许用户浏览页面。</target>
        </trans-unit>
        <trans-unit id="7322771e8958658ead503160124f934fb65197f8" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;&amp;lt;content&amp;gt;&lt;/code&gt; element is used, the data will contain a single item with either the value of the</source>
          <target state="translated">当使用 &lt;code&gt;&amp;lt;content&amp;gt;&lt;/code&gt; 元素时，数据将包含单个项目，其值为</target>
        </trans-unit>
        <trans-unit id="2672663ccea1c72ceff571e1774f7c56bc159e61" translate="yes" xml:space="preserve">
          <source>When a D-Bus function returns a D-Bus variant, it can be retrieved as follows:</source>
          <target state="translated">当一个D-Bus函数返回一个D-Bus变体时,可以按以下方式检索。</target>
        </trans-unit>
        <trans-unit id="1017702957d7db1428d00195f1759c2c2ce9ca31" translate="yes" xml:space="preserve">
          <source>When a JavaScript file is imported this way, it is imported with a qualifier. The functions in that file are then accessible from the importing script via the qualifier (that is, as &lt;code&gt;Qualifier.functionName(params)&lt;/code&gt;).</source>
          <target state="translated">以这种方式导入JavaScript文件时，将使用限定符将其导入。然后可以通过限定符（即，作为 &lt;code&gt;Qualifier.functionName(params)&lt;/code&gt; ）从导入脚本访问该文件中的函数。</target>
        </trans-unit>
        <trans-unit id="8955c961f4e03b5b4c423d7e27242490dcc367cd" translate="yes" xml:space="preserve">
          <source>When a NoDraw node is present in a FrameGraph branch, this prevents the renderer from rendering any primitive. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">当FrameGraph分支中存在NoDraw节点时，这将阻止渲染器渲染任何基元。&lt;a href=&quot;#details&quot;&gt;更多的...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9346322a98372696210b54e5c6837cb02553ab5b" translate="yes" xml:space="preserve">
          <source>When a NoPicking node is present in a FrameGraph branch, this prevents the render aspect from performing picking selection for the given branch. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">当FrameGraph分支中存在NoPicking节点时，这将阻止渲染方面对给定分支执行选择选择。&lt;a href=&quot;#details&quot;&gt;更多的...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b5239011b0ce80a40d0520fced8dbad82a40aa0a" translate="yes" xml:space="preserve">
          <source>When a Plugin object is created, it is &quot;detached&quot; and not associated with any actual service plugin. Once it has received information via setting its &lt;a href=&quot;qml-qtlocation-plugin#name-prop&quot;&gt;name&lt;/a&gt;, &lt;a href=&quot;qml-qtlocation-plugin#preferred-prop&quot;&gt;preferred&lt;/a&gt;, or &lt;a href=&quot;qml-qtlocation-plugin#required-prop&quot;&gt;required&lt;/a&gt; properties, it will choose an appropriate service plugin to attach to. Plugin objects can only be attached once; to use multiple plugins, create multiple Plugin objects.</source>
          <target state="translated">创建插件对象时，它是&amp;ldquo;分离的&amp;rdquo;并且不与任何实际的服务插件关联。通过设置其&lt;a href=&quot;qml-qtlocation-plugin#name-prop&quot;&gt;name&lt;/a&gt;，&lt;a href=&quot;qml-qtlocation-plugin#preferred-prop&quot;&gt;preferred&lt;/a&gt;或&lt;a href=&quot;qml-qtlocation-plugin#required-prop&quot;&gt;required&lt;/a&gt;属性接收到信息后，它将选择要附加的适当服务插件。插件对象只能附加一次；要使用多个插件，请创建多个插件对象。</target>
        </trans-unit>
        <trans-unit id="b6f220e6e802d62e7eddcb10a35ca79f2887d75d" translate="yes" xml:space="preserve">
          <source>When a QML &lt;a href=&quot;qml-qtquick-item&quot;&gt;Item&lt;/a&gt; explicitly relinquishes focus (by setting its &lt;code&gt;focus&lt;/code&gt; property to &lt;code&gt;false&lt;/code&gt; while it has active focus), the system does not automatically select another type to receive focus. That is, it is possible for there to be no currently active focus.</source>
          <target state="translated">当QML &lt;a href=&quot;qml-qtquick-item&quot;&gt;项&lt;/a&gt;显式放弃焦点时（通过在其具有活动焦点时将其 &lt;code&gt;focus&lt;/code&gt; 属性设置为 &lt;code&gt;false&lt;/code&gt; ），系统不会自动选择其他类型来接收焦点。即，可能没有当前的活动焦点。</target>
        </trans-unit>
        <trans-unit id="7001a12de2df6c574e67e9da9ad3f2fc320aad4f" translate="yes" xml:space="preserve">
          <source>When a QML object type is used as a signal parameter, the parameter should use &lt;a href=&quot;qml-var&quot;&gt;var&lt;/a&gt; as the type, and the value should be received in C++ using the &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; type:</source>
          <target state="translated">当将QML对象类型用作信号参数时，该参数应使用&lt;a href=&quot;qml-var&quot;&gt;var&lt;/a&gt;作为类型，并且应使用&lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt;类型在C ++中接收该值：</target>
        </trans-unit>
        <trans-unit id="15f000278e72ce7b8d6c307887252da7193e1ede" translate="yes" xml:space="preserve">
          <source>When a QMemoryBarrier node is found in a FrameGraph branch, the barrier will be enforced prior to any draw or compute command even if these are defined deeper in the branch.</source>
          <target state="translated">当在FrameGraph分支中发现一个QMemoryBarrier节点时,即使在分支的更深处定义了QMemoryBarrier节点,该屏障也会在任何绘制或计算命令之前被强制执行。</target>
        </trans-unit>
        <trans-unit id="d860d62ecdfb8b15dcaa97f6730ceece19277c00" translate="yes" xml:space="preserve">
          <source>When a QObject is moved to another thread, all its children will be automatically moved too.</source>
          <target state="translated">当一个QObject被移动到另一个线程时,它的所有子线程也会被自动移动。</target>
        </trans-unit>
        <trans-unit id="ea1c515ed9acd99ab3e2af205a882f706575ebe6" translate="yes" xml:space="preserve">
          <source>When a QQuickWindow instance is deliberately hidden with &lt;a href=&quot;qwindow#hide&quot;&gt;hide&lt;/a&gt;() or &lt;a href=&quot;qwindow#visible-prop&quot;&gt;setVisible&lt;/a&gt;(false), it will stop rendering and its scene graph and graphics context might be released as well. This depends on the settings configured by &lt;a href=&quot;qquickwindow#setPersistentGraphics&quot;&gt;setPersistentGraphics&lt;/a&gt;() and &lt;a href=&quot;qquickwindow#setPersistentSceneGraph&quot;&gt;setPersistentSceneGraph&lt;/a&gt;(). The behavior in this respect is identical to explicitly calling the &lt;a href=&quot;qquickwindow#releaseResources&quot;&gt;releaseResources&lt;/a&gt;() function. A window can become not exposed, in other words non-renderable, by other means as well. This depends on the platform and windowing system. For example, on Windows minimizing a window makes it stop rendering. On macOS fully obscuring a window by other windows on top triggers the same. On Linux/X11, the behavior is dependent on the window manager.</source>
          <target state="translated">当QQuickWindow实例故意用&lt;a href=&quot;qwindow#hide&quot;&gt;hide&lt;/a&gt;（）或&lt;a href=&quot;qwindow#visible-prop&quot;&gt;setVisible&lt;/a&gt;（false）隐藏时，它将停止渲染，并且其场景图和图形上下文也可能会释放。这取决于&lt;a href=&quot;qquickwindow#setPersistentGraphics&quot;&gt;setPersistentGraphics&lt;/a&gt;（）和&lt;a href=&quot;qquickwindow#setPersistentSceneGraph&quot;&gt;setPersistentSceneGraph&lt;/a&gt;（）配置的设置。在这方面的行为与显式调用&lt;a href=&quot;qquickwindow#releaseResources&quot;&gt;releaseResources&lt;/a&gt;相同。（） 功能。窗口也不能通过其他方式暴露出来，换句话说是不可渲染的。这取决于平台和窗口系统。例如，在Windows上，最小化窗口会使窗口停止渲染。在macOS上，顶部的其他窗口完全遮盖了一个窗口，从而触发了相同的操作。在Linux / X11上，行为取决于窗口管理器。</target>
        </trans-unit>
        <trans-unit id="9bcadc0cb5a7c58faa28e7459e38798e9f6a2b6b" translate="yes" xml:space="preserve">
          <source>When a QQuickWindow instance is deliberately hidden with &lt;a href=&quot;qwindow#hide&quot;&gt;hide&lt;/a&gt;() or &lt;a href=&quot;qwindow#visible-prop&quot;&gt;setVisible&lt;/a&gt;(false), it will stop rendering and its scene graph and graphics context might be released. The &lt;a href=&quot;qquickwindow#sceneGraphInvalidated&quot;&gt;sceneGraphInvalidated&lt;/a&gt;() signal will be emitted when this happens.</source>
          <target state="translated">当使用&lt;a href=&quot;qwindow#hide&quot;&gt;hide&lt;/a&gt;（）或&lt;a href=&quot;qwindow#visible-prop&quot;&gt;setVisible&lt;/a&gt;（false）故意隐藏QQuickWindow实例时，它将停止渲染，并且可能会释放其场景图和图形上下文。所述&lt;a href=&quot;qquickwindow#sceneGraphInvalidated&quot;&gt;sceneGraphInvalidated&lt;/a&gt;发生这种情况时（在）信号将被发射。</target>
        </trans-unit>
        <trans-unit id="fc28ed271581b3aeebbcb657c64d87496cc2b2e9" translate="yes" xml:space="preserve">
          <source>When a QToolBar is not a child of a &lt;a href=&quot;qmainwindow&quot;&gt;QMainWindow&lt;/a&gt;, it loses the ability to populate the extension pop up with widgets added to the toolbar using &lt;a href=&quot;qtoolbar#addWidget&quot;&gt;addWidget&lt;/a&gt;(). Please use widget actions created by inheriting &lt;a href=&quot;qwidgetaction&quot;&gt;QWidgetAction&lt;/a&gt; and implementing &lt;a href=&quot;qwidgetaction#createWidget&quot;&gt;QWidgetAction::createWidget&lt;/a&gt;() instead.</source>
          <target state="translated">当QToolBar不是&lt;a href=&quot;qmainwindow&quot;&gt;QMainWindow&lt;/a&gt;的子级时，它将失去使用&lt;a href=&quot;qtoolbar#addWidget&quot;&gt;addWidget&lt;/a&gt;（）添加到工具栏中的小部件填充扩展弹出窗口的功能。请使用通过继承&lt;a href=&quot;qwidgetaction&quot;&gt;QWidgetAction&lt;/a&gt;并实现&lt;a href=&quot;qwidgetaction#createWidget&quot;&gt;QWidgetAction :: createWidget&lt;/a&gt;（）而创建的窗口小部件动作。</target>
        </trans-unit>
        <trans-unit id="f8aa88cb70cc32f83b8553c1a39321db3fc1b25e" translate="yes" xml:space="preserve">
          <source>When a Qt3DRender::QNoDraw node is present in a FrameGraph branch, this prevents the renderer from rendering any primitive</source>
          <target state="translated">当一个Qt3DRender::QNoDraw节点存在于FrameGraph分支中时,这将阻止渲染器渲染任何基元。</target>
        </trans-unit>
        <trans-unit id="7f62ed373c0ee65b35bdb2fc2d57ef6032e4e244" translate="yes" xml:space="preserve">
          <source>When a Qt3DRender::QNoPicking node is present in a FrameGraph branch, this prevents the render aspect from performing picking selection for the given branch</source>
          <target state="translated">当一个Qt3DRender::QNoPicking节点存在于一个FrameGraph分支中时,这将阻止渲染方面对给定分支进行选择。</target>
        </trans-unit>
        <trans-unit id="80a5e58bd25120521267d228a0fa00372555a677" translate="yes" xml:space="preserve">
          <source>When a TextureInput property is declared in an &lt;a href=&quot;qml-qtquick3d-effect&quot;&gt;Effect&lt;/a&gt; or a &lt;a href=&quot;qml-qtquick3d-custommaterial&quot;&gt;CustomMaterial&lt;/a&gt;, it will automatically be available as a sampler in all shaders by its property name.</source>
          <target state="translated">当在&lt;a href=&quot;qml-qtquick3d-effect&quot;&gt;Effect&lt;/a&gt;或&lt;a href=&quot;qml-qtquick3d-custommaterial&quot;&gt;CustomMaterial中&lt;/a&gt;声明TextureInput属性时，通过其属性名称，它将自动在所有着色器中用作采样器。</target>
        </trans-unit>
        <trans-unit id="40263f24ec17a09841c1926737df4393300f3b67" translate="yes" xml:space="preserve">
          <source>When a button is clicked in the button box, the &lt;a href=&quot;qdialogbuttonbox#clicked&quot;&gt;clicked&lt;/a&gt;() signal is emitted for the actual button is that is pressed. For convenience, if the button has an &lt;a href=&quot;qdialogbuttonbox#ButtonRole-enum&quot;&gt;AcceptRole&lt;/a&gt;, &lt;a href=&quot;qdialogbuttonbox#ButtonRole-enum&quot;&gt;RejectRole&lt;/a&gt;, or &lt;a href=&quot;qdialogbuttonbox#ButtonRole-enum&quot;&gt;HelpRole&lt;/a&gt;, the &lt;a href=&quot;qdialogbuttonbox#accepted&quot;&gt;accepted&lt;/a&gt;(), &lt;a href=&quot;qdialogbuttonbox#rejected&quot;&gt;rejected&lt;/a&gt;(), or &lt;a href=&quot;qdialogbuttonbox#helpRequested&quot;&gt;helpRequested&lt;/a&gt;() signals are emitted respectively.</source>
          <target state="translated">当在按钮框中单击一个按钮时，将为实际按下的按钮发出&lt;a href=&quot;qdialogbuttonbox#clicked&quot;&gt;clicked&lt;/a&gt;（）信号。为了方便起见，如果按钮具有&lt;a href=&quot;qdialogbuttonbox#ButtonRole-enum&quot;&gt;AcceptRole&lt;/a&gt;，&lt;a href=&quot;qdialogbuttonbox#ButtonRole-enum&quot;&gt;RejectRole&lt;/a&gt;，或&lt;a href=&quot;qdialogbuttonbox#ButtonRole-enum&quot;&gt;HelpRole&lt;/a&gt;，所述&lt;a href=&quot;qdialogbuttonbox#accepted&quot;&gt;接受&lt;/a&gt;（），&lt;a href=&quot;qdialogbuttonbox#rejected&quot;&gt;拒绝&lt;/a&gt;（），或&lt;a href=&quot;qdialogbuttonbox#helpRequested&quot;&gt;helpRequested&lt;/a&gt;（）信号被分别发射。</target>
        </trans-unit>
        <trans-unit id="3391d8c7ccaaea73a623e4d861dba6f56e546160" translate="yes" xml:space="preserve">
          <source>When a button is clicked in the button box, the &lt;a href=&quot;qml-qtquick-controls2-dialogbuttonbox#clicked-signal&quot;&gt;clicked()&lt;/a&gt; signal is emitted for the actual button that is pressed. In addition, the following signals are automatically emitted when a button with the respective role(s) is pressed:</source>
          <target state="translated">在按钮框中&lt;a href=&quot;qml-qtquick-controls2-dialogbuttonbox#clicked-signal&quot;&gt;单击&lt;/a&gt;按钮时，将为实际按下的按钮发出clicked（）信号。此外，当按下具有各自作用的按钮时，会自动发出以下信号：</target>
        </trans-unit>
        <trans-unit id="06c02f6a9dbac4345d72fdb9bb347db0a2b3bcdc" translate="yes" xml:space="preserve">
          <source>When a category is removed, the &lt;a href=&quot;qplacemanager&quot;&gt;QPlaceManager&lt;/a&gt; may emit the &lt;a href=&quot;qplacemanager#categoryRemoved&quot;&gt;QPlaceManager::categoryRemoved&lt;/a&gt;() signal. Whether a manager does so is provider specific. Managers accessing places from a web service will typically not emit these signals, while managers accessing places stored locally generally will.</source>
          <target state="translated">删除类别后，&lt;a href=&quot;qplacemanager&quot;&gt;QPlaceManager&lt;/a&gt;可能会发出&lt;a href=&quot;qplacemanager#categoryRemoved&quot;&gt;QPlaceManager :: categoryRemoved&lt;/a&gt;（）信号。经理是否这样做取决于提供商。从Web服务访问场所的管理员通常不会发出这些信号，而访问本地存储的场所的管理员通常会发出这些信号。</target>
        </trans-unit>
        <trans-unit id="2153d9fed3f02a16b6a6ca1c21681db29241b851" translate="yes" xml:space="preserve">
          <source>When a category is saved, the &lt;a href=&quot;qplacemanager&quot;&gt;QPlaceManager&lt;/a&gt; may emit &lt;a href=&quot;qplacemanager#categoryAdded&quot;&gt;QPlaceManager::categoryAdded&lt;/a&gt;() or &lt;a href=&quot;qplacemanager#categoryUpdated&quot;&gt;QPlaceManager::categoryUpdated&lt;/a&gt;() signals. However whether a manager does so or not is provider specific, managers accessing places from a web service will typically not emit these signals while managers accessing places locally stored generally will.</source>
          <target state="translated">保存类别后，&lt;a href=&quot;qplacemanager&quot;&gt;QPlaceManager&lt;/a&gt;可能会发出&lt;a href=&quot;qplacemanager#categoryAdded&quot;&gt;QPlaceManager :: categoryAdded&lt;/a&gt;（）或&lt;a href=&quot;qplacemanager#categoryUpdated&quot;&gt;QPlaceManager :: categoryUpdated&lt;/a&gt;（）信号。但是，无论管理者是否这样做都是特定于提供者的，从Web服务访问场所的管理者通常不会发出这些信号，而访问本地存储的场所的管理者通常会发出这些信号。</target>
        </trans-unit>
        <trans-unit id="74e1cabc1808cac1af0ca6415a34d8121f46bf6d" translate="yes" xml:space="preserve">
          <source>When a certain configuration is requested explicitly, no checks are done at application startup, that is, the system-provided opengl32.dll will not be examined.</source>
          <target state="translated">当显式请求某项配置时,在应用程序启动时不做任何检查,即不检查系统提供的opengl32.dll。</target>
        </trans-unit>
        <trans-unit id="0d7ef2995bb1b9278679a4db6eb4f1c8a80df088" translate="yes" xml:space="preserve">
          <source>When a child layout object is selected, its parent layout object can be selected by pressing down the &lt;b&gt;Shift&lt;/b&gt; key while clicking on it. This makes it possible to select a specific layout in a hierarchy, which is otherwise difficult due to the small frame.</source>
          <target state="translated">选择子布局对象时，可以通过在单击它的同时按下&lt;b&gt;Shift&lt;/b&gt;键来选择其父布局对象。这使得有可能在层次结构中选择特定的布局，否则由于尺寸较小而很难。</target>
        </trans-unit>
        <trans-unit id="4d44facce222efbda291b9b00896c00605e23c4d" translate="yes" xml:space="preserve">
          <source>When a class is marked &lt;a href=&quot;#reentrant-command&quot;&gt;\reentrant&lt;/a&gt; or &lt;a href=&quot;#threadsafe-command&quot;&gt;\threadsafe&lt;/a&gt;, functions in that class can be marked &lt;code&gt;nonreentrant&lt;/code&gt; using the &lt;a href=&quot;#nonreentrant-command&quot;&gt;\nonreentrant&lt;/a&gt; command.</source>
          <target state="translated">当一个类被标记为&lt;a href=&quot;#reentrant-command&quot;&gt;\ reentrant&lt;/a&gt;或&lt;a href=&quot;#threadsafe-command&quot;&gt;\ threadsafe时&lt;/a&gt;，可以使用&lt;a href=&quot;#nonreentrant-command&quot;&gt;\ nonreentrant&lt;/a&gt;命令将该类中的函数标记为 &lt;code&gt;nonreentrant&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0630e10d812ca6a44e69948c6fbb1d3fde2d9e6c" translate="yes" xml:space="preserve">
          <source>When a class is marked &lt;a href=&quot;#reentrant-command&quot;&gt;\reentrant&lt;/a&gt; or &lt;a href=&quot;#threadsafe-command&quot;&gt;\threadsafe&lt;/a&gt;, functions in that class can be marked &lt;code&gt;nonreentrant&lt;/code&gt; using this command in the &lt;a href=&quot;https://doc.qt.io/qt-5.13/13-qdoc-commands-topics.html#fn-command&quot;&gt;\fn&lt;/a&gt; comment of the functions to be excluded.</source>
          <target state="translated">当一个类被标记为&lt;a href=&quot;#reentrant-command&quot;&gt;\ reentrant&lt;/a&gt;或&lt;a href=&quot;#threadsafe-command&quot;&gt;\ threadsafe时&lt;/a&gt;，可以在要排除的函数的&lt;a href=&quot;https://doc.qt.io/qt-5.13/13-qdoc-commands-topics.html#fn-command&quot;&gt;\ fn&lt;/a&gt;注释中使用此命令将该类中的函数标记为 &lt;code&gt;nonreentrant&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2cd634a18329e27eaf5d023e852ce4e96a7d4f77" translate="yes" xml:space="preserve">
          <source>When a class is marked &lt;a href=&quot;17-qdoc-commands-thread#reentrant-command&quot;&gt;\reentrant&lt;/a&gt; or &lt;a href=&quot;17-qdoc-commands-thread#threadsafe-command&quot;&gt;\threadsafe&lt;/a&gt;, functions in that class can be marked &lt;code&gt;nonreentrant&lt;/code&gt; using the &lt;a href=&quot;17-qdoc-commands-thread#nonreentrant-command&quot;&gt;\nonreentrant&lt;/a&gt; command.</source>
          <target state="translated">当一个类被标记为&lt;a href=&quot;17-qdoc-commands-thread#reentrant-command&quot;&gt;\ reentrant&lt;/a&gt;或&lt;a href=&quot;17-qdoc-commands-thread#threadsafe-command&quot;&gt;\ threadsafe时&lt;/a&gt;，可以使用&lt;a href=&quot;17-qdoc-commands-thread#nonreentrant-command&quot;&gt;\ nonreentrant&lt;/a&gt;命令将该类中的函数标记为 &lt;code&gt;nonreentrant&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c7d7a9372711646e9a74f31e8f75f68b4197251e" translate="yes" xml:space="preserve">
          <source>When a class is marked &lt;a href=&quot;17-qdoc-commands-thread#reentrant-command&quot;&gt;\reentrant&lt;/a&gt; or &lt;a href=&quot;17-qdoc-commands-thread#threadsafe-command&quot;&gt;\threadsafe&lt;/a&gt;, functions in that class can be marked &lt;code&gt;nonreentrant&lt;/code&gt; using this command in the &lt;a href=&quot;https://doc.qt.io/qt-5.15/13-qdoc-commands-topics.html#fn-command&quot;&gt;\fn&lt;/a&gt; comment of the functions to be excluded.</source>
          <target state="translated">当一个类被标记为&lt;a href=&quot;17-qdoc-commands-thread#reentrant-command&quot;&gt;\ reentrant&lt;/a&gt;或&lt;a href=&quot;17-qdoc-commands-thread#threadsafe-command&quot;&gt;\ threadsafe时&lt;/a&gt;，可以在要排除的函数的&lt;a href=&quot;https://doc.qt.io/qt-5.15/13-qdoc-commands-topics.html#fn-command&quot;&gt;\ fn&lt;/a&gt;注释中使用此命令将该类中的函数标记为 &lt;code&gt;nonreentrant&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8204c9b3a557911ce4c0ccc0839328bb77424f63" translate="yes" xml:space="preserve">
          <source>When a class is marked &lt;a href=&quot;17-qdoc-commands-thread#reentrant-command&quot;&gt;\reentrant&lt;/a&gt; or &lt;a href=&quot;17-qdoc-commands-thread#threadsafe-command&quot;&gt;\threadsafe&lt;/a&gt;, functions in that class can be marked &lt;code&gt;nonreentrant&lt;/code&gt; using this command in the &lt;a href=&quot;https://doc.qt.io/qt-6.0/13-qdoc-commands-topics.html#fn-command&quot;&gt;\fn&lt;/a&gt; comment of the functions to be excluded.</source>
          <target state="translated">当一个类被标记为&lt;a href=&quot;17-qdoc-commands-thread#reentrant-command&quot;&gt;\ reentrant&lt;/a&gt;或&lt;a href=&quot;17-qdoc-commands-thread#threadsafe-command&quot;&gt;\ threadsafe时&lt;/a&gt;，可以在要排除的函数的&lt;a href=&quot;https://doc.qt.io/qt-6.0/13-qdoc-commands-topics.html#fn-command&quot;&gt;\ fn&lt;/a&gt;注释中使用此命令将该类中的函数标记为 &lt;code&gt;nonreentrant&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cb8493d30c9e50739fc7b9788b39ac10cc03ca43" translate="yes" xml:space="preserve">
          <source>When a composition mode is set it applies to all painting operator, pens, brushes, gradients and pixmap/image drawing.</source>
          <target state="translated">当设置了构图模式时,它适用于所有绘画操作者、钢笔、画笔、渐变和像素图/图像绘制。</target>
        </trans-unit>
        <trans-unit id="38b6f0bc81c40f221944d8b87c8853be0ed28449" translate="yes" xml:space="preserve">
          <source>When a container extension is required,</source>
          <target state="translated">当需要容器扩展时。</target>
        </trans-unit>
        <trans-unit id="3d9cf71db83196446628da0ad23fab2682179bc2" translate="yes" xml:space="preserve">
          <source>When a custom shader snippet uses the &lt;code&gt;DEPTH_TEXTURE&lt;/code&gt; or &lt;code&gt;SCREEN_TEXTURE&lt;/code&gt; keywords, it opts in to generating the corresponding textures in a separate render pass, which is not necessarily a cheap operation, but allows implementing a variety of techniques, such as refraction for glass-like materials.</source>
          <target state="translated">当自定义着色器代码片段使用 &lt;code&gt;DEPTH_TEXTURE&lt;/code&gt; 或 &lt;code&gt;SCREEN_TEXTURE&lt;/code&gt; 关键字时，它选择在单独的渲染通道中生成相应的纹理，这不一定是便宜的操作，但可以实现多种技术，例如折射玻璃状材料。</target>
        </trans-unit>
        <trans-unit id="0e4a24a47776590b3614eff94072d51c15c8244d" translate="yes" xml:space="preserve">
          <source>When a custom valueBar is defined, its &lt;a href=&quot;qml-qtquick-item#implicitWidth-prop&quot;&gt;implicitWidth&lt;/a&gt; property must be set.</source>
          <target state="translated">当一个自定义valueBar定义，其&lt;a href=&quot;qml-qtquick-item#implicitWidth-prop&quot;&gt;implicitWidth&lt;/a&gt;属性必须设置。</target>
        </trans-unit>
        <trans-unit id="6c4b40a6fbd23b160b7fe00aefbf0818b8bf8785" translate="yes" xml:space="preserve">
          <source>When a data stream operates on an asynchronous device, the chunks of data can arrive at arbitrary points in time. The &lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt; class implements a transaction mechanism that provides the ability to read the data atomically with a series of stream operators. As an example, you can handle incomplete reads from a socket by using a transaction in a slot connected to the readyRead() signal:</source>
          <target state="translated">当数据流在异步设备上运行时，数据块可以到达任意时间点。的&lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt;类实现一个事务机制，其提供以一系列流运营商原子读出的数据的能力。例如，您可以通过使用连接到readyRead（）信号的插槽中的事务来处理对套接字的不完整读取：</target>
        </trans-unit>
        <trans-unit id="2309abfd6e3825de006d2babd2f4bdd6e5bf7873" translate="yes" xml:space="preserve">
          <source>When a data stream operates on an asynchronous device, the chunks of data can arrive at arbitrary points in time. The QDataStream class implements a transaction mechanism that provides the ability to read the data atomically with a series of stream operators. As an example, you can handle incomplete reads from a socket by using a transaction in a slot connected to the readyRead() signal:</source>
          <target state="translated">当数据流在异步设备上运行时,数据块可以在任意时间点到达。QDataStream类实现了一个事务机制,该机制提供了用一系列流操作符原子式读取数据的能力。举个例子,你可以通过在连接到readyRead()信号的槽中使用事务来处理来自套接字的不完全读取。</target>
        </trans-unit>
        <trans-unit id="2b820cde4dc4a7341cb53aee76f1d46245199229" translate="yes" xml:space="preserve">
          <source>When a delay is set, the event will be queued for delivery after the timeout has passed. The state machine takes ownership of</source>
          <target state="translated">当设置了延迟后,事件将在超时后排队等待交付。状态机对</target>
        </trans-unit>
        <trans-unit id="23bd60283b08b2b77caeefa53fd2bdd658b2b566" translate="yes" xml:space="preserve">
          <source>When a delay is set, the event will be queued for delivery after the timeout has passed. The state machine takes ownership of the event and deletes it after processing.</source>
          <target state="translated">当设置了延迟后,事件将在超时后排队交付。状态机对该事件拥有所有权,并在处理后将其删除。</target>
        </trans-unit>
        <trans-unit id="d09fa2d377e5a85c50e883812625f0a7a5fde3e3" translate="yes" xml:space="preserve">
          <source>When a dock widget or tool bar is dragged over the main window, the main window adjusts its contents to indicate where the dock widget or tool bar will be docked if it is dropped. Setting this property causes &lt;a href=&quot;qmainwindow&quot;&gt;QMainWindow&lt;/a&gt; to move its contents in a smooth animation. Clearing this property causes the contents to snap into their new positions.</source>
          <target state="translated">当将停靠小部件或工具栏拖动到主窗口上方时，主窗口会调整其内容，以指示停靠小部件或工具栏在放置时将停靠的位置。设置此属性会使&lt;a href=&quot;qmainwindow&quot;&gt;QMainWindow&lt;/a&gt;以平滑的动画形式移动其内容。清除此属性会使内容捕捉到新位置。</target>
        </trans-unit>
        <trans-unit id="da9490d3c1f9946041e7eb1512b2be2ffa63a1b3" translate="yes" xml:space="preserve">
          <source>When a drag and drop operation is performed over a view, the underlying model is queried to determine which types of operation it supports and the MIME types it can accept. This information is provided by the &lt;a href=&quot;qabstractitemmodel#supportedDropActions&quot;&gt;QAbstractItemModel::supportedDropActions&lt;/a&gt;() and &lt;a href=&quot;qabstractitemmodel#mimeTypes&quot;&gt;QAbstractItemModel::mimeTypes&lt;/a&gt;() functions. Models that do not override the implementations provided by &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; support copy operations and the default internal MIME type for items.</source>
          <target state="translated">在视图上执行拖放操作时，将查询基础模型，以确定其支持的操作类型以及可以接受的MIME类型。此信息由&lt;a href=&quot;qabstractitemmodel#supportedDropActions&quot;&gt;QAbstractItemModel :: supportedDropActions&lt;/a&gt;（）和&lt;a href=&quot;qabstractitemmodel#mimeTypes&quot;&gt;QAbstractItemModel :: mimeTypes&lt;/a&gt;（）函数提供。不覆盖&lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt;提供的实现的模型支持复制操作和项的默认内部MIME类型。</target>
        </trans-unit>
        <trans-unit id="e9b8c9681d5d37404723c8f5a9ebfc9d97539a77" translate="yes" xml:space="preserve">
          <source>When a drag is &lt;a href=&quot;qml-qtquick-drag#active-attached-prop&quot;&gt;active&lt;/a&gt; on an item, any change in that item's position will generate a drag event that will be sent to any &lt;a href=&quot;qml-qtquick-droparea&quot;&gt;DropArea&lt;/a&gt; that intersects with the new position of the item. Other items which implement drag and drop event handlers can also receive these events.</source>
          <target state="translated">当对某个项目&lt;a href=&quot;qml-qtquick-drag#active-attached-prop&quot;&gt;激活&lt;/a&gt;拖动时，该项目位置的任何更改都将生成一个拖动事件，该事件将发送到与该项目的新位置相交的任何&lt;a href=&quot;qml-qtquick-droparea&quot;&gt;DropArea&lt;/a&gt;。实现拖放事件处理程序的其他项目也可以接收这些事件。</target>
        </trans-unit>
        <trans-unit id="c95a54f3a1918c06f2cbe85cf290554fb693d8ac" translate="yes" xml:space="preserve">
          <source>When a drag is not active this property holds the object that accepted the drop event that ended the drag, if no object accepted the drop or the drag was canceled the target will then be null.</source>
          <target state="translated">当拖动未激活时,该属性持有接受结束拖动的投放事件的对象,如果没有对象接受投放或拖动被取消,那么目标将为空。</target>
        </trans-unit>
        <trans-unit id="8dd9d07c03937978798b7bb1627270a6ea3c810d" translate="yes" xml:space="preserve">
          <source>When a drop occurs elsewhere in the view, and the row number is unusable, we append items to the top level of the model.</source>
          <target state="translated">当视图中的其他地方发生下降,而行号无法使用时,我们将项目追加到模型的顶层。</target>
        </trans-unit>
        <trans-unit id="f51c41bb148e0dd3152b4f6f3f9915d8028fe189" translate="yes" xml:space="preserve">
          <source>When a drop occurs in the widget, the dropEvent() handler function is called, and we can deal with each possible action in turn. First, we deal with drag and drop operations within the same widget:</source>
          <target state="translated">当小组件中发生拖放时,会调用 dropEvent()处理函数,我们可以依次处理每一个可能的操作。首先,我们处理同一小组件中的拖放操作。</target>
        </trans-unit>
        <trans-unit id="b42ee2ab5c63e4e31745c7c35ebc8cf0bcf255bd" translate="yes" xml:space="preserve">
          <source>When a drop occurs, the model index corresponding to the parent item will either be valid, indicating that the drop occurred on an item, or it will be invalid, indicating that the drop occurred somewhere in the view that corresponds to top level of the model.</source>
          <target state="translated">当发生掉落时,父项对应的模型索引要么有效,表示掉落发生在某项上,要么无效,表示掉落发生在模型顶层对应的视图的某处。</target>
        </trans-unit>
        <trans-unit id="fa514711ce33d2215ed2e3d6a6f7e5ed0189a13b" translate="yes" xml:space="preserve">
          <source>When a focus scope receives active focus, the contained type with &lt;code&gt;focus&lt;/code&gt; set (if any) also gets the active focus. If this type is also a &lt;a href=&quot;qml-qtquick-focusscope&quot;&gt;FocusScope&lt;/a&gt;, the proxying behavior continues. Both the focus scope and the sub-focused item will have the &lt;code&gt;activeFocus&lt;/code&gt; property set.</source>
          <target state="translated">当焦点范围获得活动焦点时，包含 &lt;code&gt;focus&lt;/code&gt; 集的包含类型（如果有）也将获得活动焦点。如果此类型也是&lt;a href=&quot;qml-qtquick-focusscope&quot;&gt;FocusScope&lt;/a&gt;，则代理行为将继续。焦点范围和子焦点项都将设置 &lt;code&gt;activeFocus&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="9e613a8bc60ebbcd1e9e0949919a88ee9070005d" translate="yes" xml:space="preserve">
          <source>When a formatter is attached to a value axis, the axis range cannot include negative values or the zero.</source>
          <target state="translated">当格式器附加到值轴上时,轴范围不能包括负值或零。</target>
        </trans-unit>
        <trans-unit id="6f6b92c6c88b8efb6145fe6bc4f3bfc2d29e118a" translate="yes" xml:space="preserve">
          <source>When a gesture is canceled, the &lt;a href=&quot;qgesturerecognizer#reset&quot;&gt;reset&lt;/a&gt;() function is called, giving the recognizer the chance to update the appropriate properties in the corresponding &lt;a href=&quot;qgesture&quot;&gt;QGesture&lt;/a&gt; object.</source>
          <target state="translated">取消手势后，将调用&lt;a href=&quot;qgesturerecognizer#reset&quot;&gt;reset&lt;/a&gt;（）函数，使识别器有机会更新相应&lt;a href=&quot;qgesture&quot;&gt;QGesture&lt;/a&gt;对象中的适当属性。</target>
        </trans-unit>
        <trans-unit id="428d7789009cbf1fc7ea52cad52f4379b3aabfc7" translate="yes" xml:space="preserve">
          <source>When a highlighted item is activated, the popup is closed, &lt;a href=&quot;qml-qtquick-controls2-combobox#currentIndex-prop&quot;&gt;currentIndex&lt;/a&gt; is set to &lt;code&gt;highlightedIndex&lt;/code&gt;, and the value of this property is reset to &lt;code&gt;-1&lt;/code&gt;, as there is no longer a highlighted item.</source>
          <target state="translated">当突出显示的项目被激活时，弹出窗口关闭，&lt;a href=&quot;qml-qtquick-controls2-combobox#currentIndex-prop&quot;&gt;CURRENTINDEX&lt;/a&gt;设置为 &lt;code&gt;highlightedIndex&lt;/code&gt; ，并且此属性的值重置为 &lt;code&gt;-1&lt;/code&gt; ，因为不再有一个突出显示的项目。</target>
        </trans-unit>
        <trans-unit id="4eebccda1013bfd9e4d9b4103626dd2994ae925f" translate="yes" xml:space="preserve">
          <source>When a key is pressed or released, a key event is generated and delivered to the focused Qt Quick &lt;a href=&quot;qml-qtquick-item&quot;&gt;Item&lt;/a&gt;. To facilitate the construction of reusable components and to address some of the cases unique to fluid user interfaces, the Qt Quick items add a scope based extension to Qt's traditional keyboard focus model.</source>
          <target state="translated">当按下或释放一个键时，会生成一个键事件并将其传递给重点Qt Quick &lt;a href=&quot;qml-qtquick-item&quot;&gt;Item&lt;/a&gt;。为了简化可重用组件的构造并解决某些易变的用户界面所特有的情况，Qt Quick项目为Qt的传统键盘焦点模型添加了基于范围的扩展。</target>
        </trans-unit>
        <trans-unit id="5280aa5c73ecda9d4fb3b4f001bfc13d6e4c77a0" translate="yes" xml:space="preserve">
          <source>When a key sequence is being typed at the keyboard, it is said to be ambiguous as long as it matches the start of more than one shortcut.</source>
          <target state="translated">当在键盘上输入一个键序时,只要符合一个以上的快捷键的开始,就可以说是模棱两可。</target>
        </trans-unit>
        <trans-unit id="332bb39a2cb3399af84efd51d32cde06e1b10d08" translate="yes" xml:space="preserve">
          <source>When a language/country pair is specified in the constructor, one of three things can happen:</source>
          <target state="translated">当在构造函数中指定语言/国家对时,可能会发生三种情况之一。</target>
        </trans-unit>
        <trans-unit id="8c010514fe89fada083c82bb7ef5814f38b6c278" translate="yes" xml:space="preserve">
          <source>When a layout is resized, items may grow or shrink. Due to this, items have a &lt;a href=&quot;qml-qtquick-layouts-layout#minimumWidth-attached-prop&quot;&gt;minimum size&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-layouts-layout#preferredWidth-attached-prop&quot;&gt;preferred size&lt;/a&gt; and a &lt;a href=&quot;qml-qtquick-layouts-layout#maximumWidth-attached-prop&quot;&gt;maximum size&lt;/a&gt;.</source>
          <target state="translated">调整布局大小时，项目可能会增加或缩小。因此，商品具有&lt;a href=&quot;qml-qtquick-layouts-layout#minimumWidth-attached-prop&quot;&gt;最小尺寸&lt;/a&gt;，&lt;a href=&quot;qml-qtquick-layouts-layout#preferredWidth-attached-prop&quot;&gt;首选尺寸&lt;/a&gt;和&lt;a href=&quot;qml-qtquick-layouts-layout#maximumWidth-attached-prop&quot;&gt;最大尺寸&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2aaeb9d71f67c32d894e19f355e445af1f673900" translate="yes" xml:space="preserve">
          <source>When a low-level graphics API is in use, the scenegraph will make sure there is a CPU-side wait for the GPU to complete all work submitted to the scenegraph's graphics command queue before the scenegraph's nodes are deleted. Therefore there is no need to issue additional waits here, unless the &lt;a href=&quot;qsgrendernode#render&quot;&gt;render&lt;/a&gt;() implementation is using additional command queues.</source>
          <target state="translated">使用低级图形API时，场景图将确保在CPU端等待GPU完成删除提交给场景图的图形命令队列的所有工作，然后再删除场景图的节点。因此，除非&lt;a href=&quot;qsgrendernode#render&quot;&gt;render&lt;/a&gt;（）实现使用其他命令队列，否则无需在此处发出其他等待。</target>
        </trans-unit>
        <trans-unit id="c845af89f01e419749914b45895c1bb235d5ce01" translate="yes" xml:space="preserve">
          <source>When a menu is torn off a second menu is shown to display the menu contents in a new window. When the menu is in this mode and the menu is visible returns &lt;code&gt;true&lt;/code&gt;; otherwise false.</source>
          <target state="translated">撕下菜单后，将显示另一个菜单，以在新窗口中显示菜单内容。当菜单处于此模式且菜单可见时，返回 &lt;code&gt;true&lt;/code&gt; ；否则，返回true。否则为假。</target>
        </trans-unit>
        <trans-unit id="728dd6daea54bbbc47c1c0afd43ec24383ab26a3" translate="yes" xml:space="preserve">
          <source>When a model is reset it means that any previous data reported from the model is now invalid and has to be queried for again. This also means that the current item and any selected items will become invalid.</source>
          <target state="translated">当一个模型被重置时,意味着以前从模型中报告的任何数据现在都是无效的,必须重新查询。这也意味着当前项目和任何选定的项目将变得无效。</target>
        </trans-unit>
        <trans-unit id="5f301e5dc3d747cffb379d30922ea2160d2c0277" translate="yes" xml:space="preserve">
          <source>When a model radically changes its data it can sometimes be easier to just call this function rather than emit &lt;a href=&quot;qabstractitemmodel#dataChanged&quot;&gt;dataChanged&lt;/a&gt;() to inform other components when the underlying data source, or its structure, has changed.</source>
          <target state="translated">当模型从根本上更改其数据时，有时可以更容易地调用此函数，而不是在基础数据源或其结构发生更改时发出&lt;a href=&quot;qabstractitemmodel#dataChanged&quot;&gt;dataChanged&lt;/a&gt;（）通知其他组件。</target>
        </trans-unit>
        <trans-unit id="798d38793d411f71af72b3a052c51c022e51937d" translate="yes" xml:space="preserve">
          <source>When a module name is used as the</source>
          <target state="translated">当使用模块名称作为</target>
        </trans-unit>
        <trans-unit id="c8bb4a36e1cc58b9d2f69c2e0e1701bc5743d489" translate="yes" xml:space="preserve">
          <source>When a new &lt;a href=&quot;q3dcamera&quot;&gt;Q3DCamera&lt;/a&gt; object is set, it is automatically added as child of the scene.</source>
          <target state="translated">设置新的&lt;a href=&quot;q3dcamera&quot;&gt;Q3DCamera&lt;/a&gt;对象后，它会自动添加为场景的子级。</target>
        </trans-unit>
        <trans-unit id="8b455ee9f46ef6792f12c0936577f332d927c927" translate="yes" xml:space="preserve">
          <source>When a new &lt;a href=&quot;q3dlight&quot;&gt;Q3DLight&lt;/a&gt; objects is set, it is automatically added as child of the scene.</source>
          <target state="translated">设置新的&lt;a href=&quot;q3dlight&quot;&gt;Q3DLight&lt;/a&gt;对象后，它将自动添加为场景的子级。</target>
        </trans-unit>
        <trans-unit id="92c136ff15dc3f6e6eb98af265af4b77642b9592" translate="yes" xml:space="preserve">
          <source>When a new column is flicked into view, &lt;a href=&quot;qml-qtquick-tableview&quot;&gt;TableView&lt;/a&gt; will determine its width by calling the &lt;a href=&quot;qml-qtquick-tableview#columnWidthProvider-prop&quot;&gt;columnWidthProvider&lt;/a&gt; function. &lt;a href=&quot;qml-qtquick-tableview&quot;&gt;TableView&lt;/a&gt; itself will never store row height or column width, as it's designed to support large models containing any number of rows and columns. Instead, it will ask the application whenever it needs to know.</source>
          <target state="translated">将新列滑动到视图中时，&lt;a href=&quot;qml-qtquick-tableview&quot;&gt;TableView&lt;/a&gt;将通过调用&lt;a href=&quot;qml-qtquick-tableview#columnWidthProvider-prop&quot;&gt;columnWidthProvider&lt;/a&gt;函数确定其宽度。&lt;a href=&quot;qml-qtquick-tableview&quot;&gt;TableView&lt;/a&gt;本身永远不会存储行高或列宽，因为它旨在支持包含任意数量的行和列的大型模型。相反，它将在需要知道时询问应用程序。</target>
        </trans-unit>
        <trans-unit id="bd3977fd3b9d0fff4ce92833839e9fd254909e52" translate="yes" xml:space="preserve">
          <source>When a new column is flicked into view, TableView will determine its width by calling the &lt;a href=&quot;qml-qtquick-tableview#columnWidthProvider-prop&quot;&gt;columnWidthProvider&lt;/a&gt; function. TableView does not store row height or column width, as it's designed to support large models containing any number of rows and columns. Instead, it will ask the application whenever it needs to know.</source>
          <target state="translated">将新列滑动到视图中时，TableView将通过调用&lt;a href=&quot;qml-qtquick-tableview#columnWidthProvider-prop&quot;&gt;columnWidthProvider&lt;/a&gt;函数来确定其宽度。TableView不存储行高或列宽，因为它旨在支持包含任意数量的行和列的大型模型。相反，它将在需要知道时询问应用程序。</target>
        </trans-unit>
        <trans-unit id="be74d7e819d89ccb9b1b730a61146409cce1e842" translate="yes" xml:space="preserve">
          <source>When a new connection is received, the client &lt;a href=&quot;qwebsocket&quot;&gt;QWebSocket&lt;/a&gt; is retrieved (`nextPendingConnection()`), and the signals we are interested in are connected to our slots (`textMessageReceived()`, `binaryMessageReceived()` and `disconnected()`). The client socket is remembered in a list, in case we would like to use it later (in this example, nothing is done with it).</source>
          <target state="translated">接收到新的连接时，将检索客户端&lt;a href=&quot;qwebsocket&quot;&gt;QWebSocket&lt;/a&gt;（`nextPendingConnection（）`），并将我们感兴趣的信号连接至插槽（`textMessageReceived（）`，`binaryMessageReceived（）`和`disconnected（）`）。 ）。客户端套接字会记住在列表中，以防我们稍后使用（在此示例中，它什么也没做）。</target>
        </trans-unit>
        <trans-unit id="bda773011b553996318d1ca0425ceb0218190f09" translate="yes" xml:space="preserve">
          <source>When a new group is pushed onto the debug groups stack, it will inherit the configuration of the group that was previously on the top of the stack. Vice versa, popping a debug group will restore the configuration of the debug group that becomes the new top.</source>
          <target state="translated">当一个新的组被推到调试组堆栈上时,它将继承之前在堆栈顶部的组的配置。反之亦然,弹出一个调试组会恢复成为新顶的调试组的配置。</target>
        </trans-unit>
        <trans-unit id="df3850f1d8b8a727c24246d0834526698fe4caf6" translate="yes" xml:space="preserve">
          <source>When a new value is assigned to the &lt;code&gt;firstname&lt;/code&gt; property, the binding expression for &lt;code&gt;fullname&lt;/code&gt; is marked as dirty. So when the last &lt;code&gt;qDebug()&lt;/code&gt; statement tries to read the name value of the &lt;code&gt;fullname&lt;/code&gt; property, the expression is evaluated again, &lt;code&gt;firstname()&lt;/code&gt; will be called again and return the new value.</source>
          <target state="translated">将新值分配给 &lt;code&gt;firstname&lt;/code&gt; 属性后， &lt;code&gt;fullname&lt;/code&gt; 的绑定表达式将标记为脏。因此，当最后一个 &lt;code&gt;qDebug()&lt;/code&gt; 语句尝试读取 &lt;code&gt;fullname&lt;/code&gt; 属性的名称值时，将再次对表达式求值， &lt;code&gt;firstname()&lt;/code&gt; 将再次被调用并返回新值。</target>
        </trans-unit>
        <trans-unit id="ec32af560002a3f2954d27992ea538e7e19a3001" translate="yes" xml:space="preserve">
          <source>When a node acquires a replica for a known source, it sends a request for that source to the host node. Upon receipt of this request, the host will create a reply packet with the current values of all properties of the source. If the requested replica is dynamic, it will include the API definition for the source. The replica's node will be included in the list of connections that receive changes to that source from then on.</source>
          <target state="translated">当一个节点获取一个已知源的副本时,它会向主机节点发送一个该源的请求。收到该请求后,主机将创建一个包含源的所有属性的当前值的回复包。如果请求的副本是动态的,它将包括源的API定义。从那时起,副本的节点将被包含在接收该源更改的连接列表中。</target>
        </trans-unit>
        <trans-unit id="2f9bbe722b869b83db0e2263dc70c8abde11f7e3" translate="yes" xml:space="preserve">
          <source>When a node acquires a replica for a known source, it sends a request for that source to the host node. Upon receiving this request, the host creates a reply packet with the current values for all properties of that source. If the requested replica is &lt;a href=&quot;qremoteobjectdynamicreplica&quot;&gt;dynamic&lt;/a&gt;, the reply packet includes the API definition for the source. From then on, the replica's node will be included in the list of connections that receive changes to that source.</source>
          <target state="translated">当节点获取已知源的副本时，它将对该源的请求发送到主机节点。主机收到此请求后，将使用该源的所有属性的当前值创建一个应答数据包。如果请求的副本是&lt;a href=&quot;qremoteobjectdynamicreplica&quot;&gt;dynamic&lt;/a&gt;，则回复包包括源的API定义。从那时起，副本的节点将包含在接收对该源所做的更改的连接列表中。</target>
        </trans-unit>
        <trans-unit id="d63ba8e6603b8cbc973323b39127ee0bc0ad55ba" translate="yes" xml:space="preserve">
          <source>When a page is about to be shown, &lt;a href=&quot;qwizard&quot;&gt;QWizard&lt;/a&gt; calls &lt;a href=&quot;qwizard#initializePage&quot;&gt;initializePage&lt;/a&gt;() (which in turn calls &lt;a href=&quot;qwizardpage#initializePage&quot;&gt;QWizardPage::initializePage&lt;/a&gt;()) to fill the page with default values. By default, this function does nothing, but it can be reimplemented to initialize the page's contents based on other pages' fields (see the &lt;a href=&quot;qwizard#initialize-page&quot;&gt;example above&lt;/a&gt;).</source>
          <target state="translated">当要显示页面时，&lt;a href=&quot;qwizard&quot;&gt;QWizard&lt;/a&gt;调用&lt;a href=&quot;qwizard#initializePage&quot;&gt;initializePage&lt;/a&gt;（）（依次调用&lt;a href=&quot;qwizardpage#initializePage&quot;&gt;QWizardPage :: initializePage&lt;/a&gt;（））以使用默认值填充页面。默认情况下，此功能不执行任何操作，但是可以根据其他页面的字段重新实现该功能以初始化页面的内容（请参见&lt;a href=&quot;qwizard#initialize-page&quot;&gt;上面&lt;/a&gt;的示例）。</target>
        </trans-unit>
        <trans-unit id="52b8a1c2a004bc4ae73bcc37ab97f637d0e15877" translate="yes" xml:space="preserve">
          <source>When a page is about to be shown, QWizard calls &lt;a href=&quot;qwizard#initializePage&quot;&gt;initializePage&lt;/a&gt;() (which in turn calls &lt;a href=&quot;qwizardpage#initializePage&quot;&gt;QWizardPage::initializePage&lt;/a&gt;()) to fill the page with default values. By default, this function does nothing, but it can be reimplemented to initialize the page's contents based on other pages' fields (see the &lt;a href=&quot;qwizard#initialize-page&quot;&gt;example above&lt;/a&gt;).</source>
          <target state="translated">当要显示页面时，QWizard调用&lt;a href=&quot;qwizard#initializePage&quot;&gt;initializePage&lt;/a&gt;（）（依次调用&lt;a href=&quot;qwizardpage#initializePage&quot;&gt;QWizardPage :: initializePage&lt;/a&gt;（））以使用默认值填充页面。默认情况下，此功能不执行任何操作，但是可以根据其他页面的字段重新实现该功能以初始化页面的内容（请参见&lt;a href=&quot;qwizard#initialize-page&quot;&gt;上面&lt;/a&gt;的示例）。</target>
        </trans-unit>
        <trans-unit id="c63e8b4686c2ce6ea480da0dde82d96ac157403d" translate="yes" xml:space="preserve">
          <source>When a parallel state group is entered, all its child states will be simultaneously entered. Transitions within the individual child states operate normally. However, any of the child states may take a transition which exits the parent state. When this happens, the parent state and all of its child states are exited.</source>
          <target state="translated">当输入一个平行状态组时,它的所有子状态将同时被输入。各个子状态内的转换正常进行。但是,任何一个子状态都可能采取退出父状态的转换。在此情况下,父状态和所有的子状态都会被退出。</target>
        </trans-unit>
        <trans-unit id="f1b2b5f7aefbb0cb0ec4ae4792cb7356d5cdee30" translate="yes" xml:space="preserve">
          <source>When a partial match is found, no captured substrings are returned, and the (implicit) capturing group 0 corresponding to the whole match captures the partially matched substring of the subject string.</source>
          <target state="translated">当发现部分匹配时,不返回捕获的子串,与整个匹配相对应的(隐式)捕获组0捕获主题字符串的部分匹配子串。</target>
        </trans-unit>
        <trans-unit id="949ea8688bbfcd915778d80bb9ad32883794d483" translate="yes" xml:space="preserve">
          <source>When a pinch gesture is started, the rotation is &lt;code&gt;0.0&lt;/code&gt;.</source>
          <target state="translated">当开始捏手势时，旋转为 &lt;code&gt;0.0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6eeed75e83f5493322e8f521ba32040bf1a5bd87" translate="yes" xml:space="preserve">
          <source>When a pinch gesture is started, the scale is &lt;code&gt;1.0&lt;/code&gt;.</source>
          <target state="translated">开始捏手势时，比例为 &lt;code&gt;1.0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3947f323d774ee42a9f53aab29ffa36c8280798a" translate="yes" xml:space="preserve">
          <source>When a pixmap is inserted and the cache is about to exceed its limit, it removes pixmaps until there is enough room for the pixmap to be inserted.</source>
          <target state="translated">当一个像素图被插入,而缓存即将超过它的极限时,它将删除像素图,直到有足够的空间来插入像素图。</target>
        </trans-unit>
        <trans-unit id="14e43d5273a0f220d3f6cca0d60985a5d4b8fc21" translate="yes" xml:space="preserve">
          <source>When a place is removed, the &lt;a href=&quot;qplacemanager&quot;&gt;QPlaceManager&lt;/a&gt; may emit the &lt;a href=&quot;qplacemanager#placeRemoved&quot;&gt;QPlaceManager::placeRemoved&lt;/a&gt;() signal. Whether a manager does so is provider specific. Managers accessing places from a web service will typically not emit these signals, while managers accessing places stored locally generally will.</source>
          <target state="translated">删除位置后，&lt;a href=&quot;qplacemanager&quot;&gt;QPlaceManager&lt;/a&gt;可能会发出&lt;a href=&quot;qplacemanager#placeRemoved&quot;&gt;QPlaceManager :: placeRemoved&lt;/a&gt;（）信号。经理是否这样做取决于提供商。从Web服务访问场所的管理员通常不会发出这些信号，而访问本地存储的场所的管理员通常会发出这些信号。</target>
        </trans-unit>
        <trans-unit id="955b392e62b44331ff658695f8bca3787dde24b9" translate="yes" xml:space="preserve">
          <source>When a place is saved, the &lt;a href=&quot;qplacemanager&quot;&gt;QPlaceManager&lt;/a&gt; may emit QPlaceManager::placedAdded() or &lt;a href=&quot;qplacemanager#placeUpdated&quot;&gt;QPlaceManager::placeUpdated&lt;/a&gt;() signals. However whether a manager does so or not is provider specific, managers accessing places from a web service will typically not emit these signals while managers accessing places locally stored generally will.</source>
          <target state="translated">保存位置后，&lt;a href=&quot;qplacemanager&quot;&gt;QPlaceManager&lt;/a&gt;可能会发出QPlaceManager :: placedAdded（）或&lt;a href=&quot;qplacemanager#placeUpdated&quot;&gt;QPlaceManager :: placeUpdated&lt;/a&gt;（）信号。但是，无论管理者是否这样做都是特定于提供者的，从Web服务访问场所的管理者通常不会发出这些信号，而访问本地存储的场所的管理者通常会发出这些信号。</target>
        </trans-unit>
        <trans-unit id="bb76ccab6b6330b8216b91871b1f1a7518967e70" translate="yes" xml:space="preserve">
          <source>When a preprocessor symbol is specified using the &lt;code&gt;defines&lt;/code&gt; variable, you can also use the &lt;a href=&quot;12-0-qdoc-commands-miscellaneous#if-command&quot;&gt;\if&lt;/a&gt; command to enclose documentation that only will be included if the preprocessor symbol is defined.</source>
          <target state="translated">当使用 &lt;code&gt;defines&lt;/code&gt; 变量指定预处理器符号时，您也可以使用&lt;a href=&quot;12-0-qdoc-commands-miscellaneous#if-command&quot;&gt;\ if&lt;/a&gt;命令来封装仅在定义了预处理器符号时才会包括的文档。</target>
        </trans-unit>
        <trans-unit id="f785beae5730b83f41acbcf90ef75b7556aac2f1" translate="yes" xml:space="preserve">
          <source>When a press event occurs, each instance of &lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;PointHandler&lt;/a&gt; chooses a single point which is not yet &quot;taken&quot; at that moment: if the press occurs within the bounds of the &lt;a href=&quot;qml-qtquick-pointhandler#parent-prop&quot;&gt;PointerHandler::parent&lt;/a&gt;, and no sibling &lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;PointHandler&lt;/a&gt; within the same &lt;a href=&quot;qml-qtquick-pointhandler#parent-prop&quot;&gt;PointerHandler::parent&lt;/a&gt; has yet acquired a passive grab on that point, and if the other constraints such as &lt;a href=&quot;qml-qtquick-pointhandler#acceptedButtons-prop&quot;&gt;acceptedButtons&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-pointhandler#acceptedDevices-prop&quot;&gt;acceptedDevices&lt;/a&gt; etc. are satisfied, it's eligible, and the &lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;PointHandler&lt;/a&gt; then acquires a passive grab. In this way, the &lt;a href=&quot;qml-qtquick-pointhandler#parent-prop&quot;&gt;PointerHandler::parent&lt;/a&gt; acts like an exclusive group: there can be multiple instances of &lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;PointHandler&lt;/a&gt;, and the set of pressed touchpoints will be distributed among them. Each &lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;PointHandler&lt;/a&gt; which has chosen a point to track has its &lt;a href=&quot;stylesheet-reference#active&quot;&gt;active&lt;/a&gt; property &lt;code&gt;true&lt;/code&gt;. It then continues to track its chosen point until release: the properties of the &lt;a href=&quot;qml-point&quot;&gt;point&lt;/a&gt; will be kept up-to-date. Any Item can bind to these properties, and thereby follow the point's movements.</source>
          <target state="translated">当发生press事件时，&lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;PointHandler的&lt;/a&gt;每个实例都会选择当时尚未&amp;ldquo;获取&amp;rdquo;的单个点：如果按下发生在&lt;a href=&quot;qml-qtquick-pointhandler#parent-prop&quot;&gt;PointerHandler :: parent&lt;/a&gt;的边界内，并且同一个&lt;a href=&quot;qml-qtquick-pointhandler#parent-prop&quot;&gt;PointerHandler :: parent&lt;/a&gt;内没有同级&lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;PointHandler。&lt;/a&gt;尚未在该点上获得被动抓取，并且如果满足其他约束（例如&lt;a href=&quot;qml-qtquick-pointhandler#acceptedButtons-prop&quot;&gt;acceptedButtons&lt;/a&gt;，&lt;a href=&quot;qml-qtquick-pointhandler#acceptedDevices-prop&quot;&gt;acceptedDevices&lt;/a&gt;等），则表明它符合条件，然后&lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;PointHandler&lt;/a&gt;获得被动抓取。这样，&lt;a href=&quot;qml-qtquick-pointhandler#parent-prop&quot;&gt;PointerHandler :: parent&lt;/a&gt;就像一个排他组：可以有多个&lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;PointHandler&lt;/a&gt;实例，按下的接触点集将在其中分布。每个选择要跟踪的点的&lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;PointHandler&lt;/a&gt;都有其&lt;a href=&quot;stylesheet-reference#active&quot;&gt;active&lt;/a&gt;属性 &lt;code&gt;true&lt;/code&gt; 。然后，它将继续跟踪其选择的点，直到释放为止：该&lt;a href=&quot;qml-point&quot;&gt;点&lt;/a&gt;的属性将保持最新。任何项目都可以绑定到这些属性，从而跟随点的移动。</target>
        </trans-unit>
        <trans-unit id="10016a67871d70f0506ab0f762c8c06369cdb0ed" translate="yes" xml:space="preserve">
          <source>When a press event occurs, each instance of PointHandler chooses a single point which is not yet &quot;taken&quot; at that moment: if the press occurs within the bounds of the &lt;a href=&quot;qml-qtquick-pointhandler#parent-prop&quot;&gt;PointerHandler::parent&lt;/a&gt;, and no sibling PointHandler within the same &lt;a href=&quot;qml-qtquick-pointhandler#parent-prop&quot;&gt;PointerHandler::parent&lt;/a&gt; has yet acquired a passive grab on that point, and if the other constraints such as &lt;a href=&quot;qml-qtquick-pointhandler#acceptedButtons-prop&quot;&gt;acceptedButtons&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-pointhandler#acceptedDevices-prop&quot;&gt;acceptedDevices&lt;/a&gt; etc. are satisfied, it's eligible, and the PointHandler then acquires a passive grab. In this way, the &lt;a href=&quot;qml-qtquick-pointhandler#parent-prop&quot;&gt;PointerHandler::parent&lt;/a&gt; acts like an exclusive group: there can be multiple instances of PointHandler, and the set of pressed touchpoints will be distributed among them. Each PointHandler which has chosen a point to track has its &lt;a href=&quot;stylesheet-reference#active&quot;&gt;active&lt;/a&gt; property &lt;code&gt;true&lt;/code&gt;. It then continues to track its chosen point until release: the properties of the &lt;a href=&quot;qml-point&quot;&gt;point&lt;/a&gt; will be kept up-to-date. Any Item can bind to these properties, and thereby follow the point's movements.</source>
          <target state="translated">当发生press事件时，PointHandler的每个实例都会选择当时尚未&amp;ldquo;获取&amp;rdquo;的单个点：如果按下发生在&lt;a href=&quot;qml-qtquick-pointhandler#parent-prop&quot;&gt;PointerHandler :: parent&lt;/a&gt;的边界内，并且同一个&lt;a href=&quot;qml-qtquick-pointhandler#parent-prop&quot;&gt;PointerHandler :: parent&lt;/a&gt;内没有同级PointHandler。尚未在该点上获得被动抓取，并且如果满足其他约束（例如&lt;a href=&quot;qml-qtquick-pointhandler#acceptedButtons-prop&quot;&gt;acceptedButtons&lt;/a&gt;，&lt;a href=&quot;qml-qtquick-pointhandler#acceptedDevices-prop&quot;&gt;acceptedDevices&lt;/a&gt;等），则表明它符合条件，然后PointHandler获得被动抓取。这样，&lt;a href=&quot;qml-qtquick-pointhandler#parent-prop&quot;&gt;PointerHandler :: parent&lt;/a&gt;就像一个专用组：可以有PointHandler的多个实例，并且所按下的接触点集将在其中分布。每个选择要跟踪的点的PointHandler都有其&lt;a href=&quot;stylesheet-reference#active&quot;&gt;主动&lt;/a&gt;财产 &lt;code&gt;true&lt;/code&gt; 。然后它将继续跟踪其选定的点，直到释放为止：该&lt;a href=&quot;qml-point&quot;&gt;点&lt;/a&gt;的属性将保持最新。任何项目都可以绑定到这些属性，从而跟随该点的移动。</target>
        </trans-unit>
        <trans-unit id="cfbfb0ebbd6646025b981fa339de3293519a353e" translate="yes" xml:space="preserve">
          <source>When a print request is accepted, the printer status would change, triggering a change in the status property. This would then be reported to all Replicas.</source>
          <target state="translated">当接受打印请求时,打印机状态将发生变化,从而触发状态属性的变化。然后,这将被报告给所有副本。</target>
        </trans-unit>
        <trans-unit id="666537301706b87af8a406d9ea46793d0d017481" translate="yes" xml:space="preserve">
          <source>When a process using &lt;a href=&quot;qsystemsemaphore&quot;&gt;QSystemSemaphore&lt;/a&gt; terminates for any reason, Unix automatically reverses the effect of all acquire operations that were not released. Thus if the process acquires a resource and then exits without releasing it, Unix will release that resource.</source>
          <target state="translated">当使用&lt;a href=&quot;qsystemsemaphore&quot;&gt;QSystemSemaphore&lt;/a&gt;的进程由于任何原因终止时，Unix会自动撤消所有未释放的获取操作的影响。因此，如果进程获取了一个资源然后退出而不释放它，Unix将释放该资源。</target>
        </trans-unit>
        <trans-unit id="df1a65bbb3d9b167018ca0c5cdabe5195c1a5eea" translate="yes" xml:space="preserve">
          <source>When a process using QSystemSemaphore terminates for any reason, Unix automatically reverses the effect of all acquire operations that were not released. Thus if the process acquires a resource and then exits without releasing it, Unix will release that resource.</source>
          <target state="translated">当使用QSystemSemaphore的进程因任何原因而终止时,Unix会自动撤销所有未释放的获取操作的效果。因此,如果进程获取了一个资源,然后在没有释放的情况下退出,Unix将释放该资源。</target>
        </trans-unit>
        <trans-unit id="3fb2e9f6ef5f613c87a38c8fd666c38c8b51fe6f" translate="yes" xml:space="preserve">
          <source>When a property sheet extension is required,</source>
          <target state="translated">当需要扩展财产表时。</target>
        </trans-unit>
        <trans-unit id="a0431b9169541b5942ac50072a09a56ca2303178" translate="yes" xml:space="preserve">
          <source>When a property value source object is assigned to a property, QML first tries to assign it normally, as though it were a regular QML type. Only if this assignment fails does the engine call the &lt;a href=&quot;qqmlpropertyvaluesource#setTarget&quot;&gt;setTarget()&lt;/a&gt; method. This allows the type to also be used in contexts other than just as a value source.</source>
          <target state="translated">将属性值源对象分配给属性后，QML首先尝试正常分配它，就像它是常规QML类型一样。仅当分配失败时，引擎才会调用&lt;a href=&quot;qqmlpropertyvaluesource#setTarget&quot;&gt;setTarget（）&lt;/a&gt;方法。这样一来，该类型还可以在其他环境中使用，而不仅仅是作为值源。</target>
        </trans-unit>
        <trans-unit id="5c0c5db3829a8327c7d24036abbfab378bf7a77f" translate="yes" xml:space="preserve">
          <source>When a query is run on XML data, as in the snippet above, the &lt;code&gt;doc()&lt;/code&gt; function returns the node in the built-in data model where the query evaluation will begin. But when a query is run on a custom node model containing non-XML data, one of the &lt;a href=&quot;qxmlquery#bindVariable&quot;&gt;bindVariable&lt;/a&gt;() functions must be called to bind a variable name to a starting node in the custom model. A $variable reference is used in the &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; text to access the starting node in the custom model. It is not necessary to declare the variable name external in the query. See the example in the documentation for &lt;a href=&quot;qabstractxmlnodemodel&quot;&gt;QAbstractXmlNodeModel&lt;/a&gt;.</source>
          <target state="translated">当对XML数据运行查询时，如上面的代码片段所示， &lt;code&gt;doc()&lt;/code&gt; 函数返回内置数据模型中的节点，在该节点上将开始进行查询评估。但是，当在包含非XML数据的定制节点模型上运行查询时，必须调用&lt;a href=&quot;qxmlquery#bindVariable&quot;&gt;bindVariable&lt;/a&gt;（）函数之一，以将变量名绑定到定制模型中的起始节点。在&lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt;文本中使用$ variable引用来访问定制模型中的起始节点。不必在查询中声明外部变量名。请参阅文档中的示例&lt;a href=&quot;qabstractxmlnodemodel&quot;&gt;QAbstractXmlNodeModel&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="865208c91375893b92d822994a4204209a37ba98" translate="yes" xml:space="preserve">
          <source>When a query is run on XML data, as in the snippet above, the &lt;code&gt;doc()&lt;/code&gt; function returns the node in the built-in data model where the query evaluation will begin. But when a query is run on a custom node model containing non-XML data, one of the &lt;a href=&quot;qxmlquery#bindVariable&quot;&gt;bindVariable&lt;/a&gt;() functions must be called to bind a variable name to a starting node in the custom model. A $variable reference is used in the &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; text to access the starting node in the custom model. It is not necessary to declare the variable name external in the query. See the example in the documentation for &lt;a href=&quot;qabstractxmlnodemodel&quot;&gt;QAbstractXmlNodeModel&lt;/a&gt;.</source>
          <target state="translated">当对XML数据运行查询时，如上面的代码片段所示， &lt;code&gt;doc()&lt;/code&gt; 函数返回内置数据模型中的节点，查询评估将在该节点上开始。但是，当在包含非XML数据的定制节点模型上运行查询时，必须调用&lt;a href=&quot;qxmlquery#bindVariable&quot;&gt;bindVariable&lt;/a&gt;（）函数之一，以将变量名绑定到定制模型中的起始节点。在&lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt;文本中使用$ variable引用来访问定制模型中的起始节点。无需在查询中声明外部变量名。请参阅文档中的示例&lt;a href=&quot;qabstractxmlnodemodel&quot;&gt;QAbstractXmlNodeModel&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4b9712c67436ef44e2898fc4063b230c597593f7" translate="yes" xml:space="preserve">
          <source>When a query runs, it parses documents, allocating internal data structures to hold them, and it may load other resources over the network. It reuses these allocated resources when possible, to avoid having to reload and reparse them.</source>
          <target state="translated">当一个查询运行时,它会解析文档,分配内部数据结构来保存它们,它可能会通过网络加载其他资源。它尽可能地重复使用这些分配的资源,以避免不得不重新加载和重新解析这些资源。</target>
        </trans-unit>
        <trans-unit id="8a593010a6662d2b59e4a72e57582a95f2f8033f" translate="yes" xml:space="preserve">
          <source>When a rectangular clip is set in combination with &lt;a href=&quot;qsgclipnode#setIsRectangular&quot;&gt;setIsRectangular&lt;/a&gt; the renderer may in some cases use a more optimal clip method.</source>
          <target state="translated">当结合&lt;a href=&quot;qsgclipnode#setIsRectangular&quot;&gt;setIsRectangular&lt;/a&gt;设置矩形剪辑时，渲染器在某些情况下可能会使用更优化的剪辑方法。</target>
        </trans-unit>
        <trans-unit id="65c8e122245f9ff6c381bb4990517a1724e6f958" translate="yes" xml:space="preserve">
          <source>When a relative URL is written to a &lt;code&gt;url&lt;/code&gt; type property, it is converted into a URL object, so &lt;b&gt;matching the URL value against the input string value will fail&lt;/b&gt;. Instead, convert the string to a URL using Qt.resolvedUrl() for means of comparison, and use &lt;code&gt;toString()&lt;/code&gt; to get the contents of the URL:</source>
          <target state="translated">将相对URL写入 &lt;code&gt;url&lt;/code&gt; type属性后，它将转换为URL对象，因此&lt;b&gt;将URL值与输入字符串值进行匹配将失败&lt;/b&gt;。相反，请使用Qt.resolvedUrl（）将字符串转换为URL以进行比较，然后使用 &lt;code&gt;toString()&lt;/code&gt; 来获取URL的内容：</target>
        </trans-unit>
        <trans-unit id="fccc71619fd1248dd374a7ce2288a8bbb7a01715" translate="yes" xml:space="preserve">
          <source>When a scene is set on a view, the &lt;a href=&quot;qgraphicsscene#changed&quot;&gt;QGraphicsScene::changed&lt;/a&gt;() signal is automatically connected to this view's &lt;a href=&quot;qgraphicsview#updateScene&quot;&gt;updateScene&lt;/a&gt;() slot, and the view's scroll bars are adjusted to fit the size of the scene.</source>
          <target state="translated">当在视图上设置场景时，&lt;a href=&quot;qgraphicsscene#changed&quot;&gt;QGraphicsScene :: changed&lt;/a&gt;（）信号自动连接到该视图的&lt;a href=&quot;qgraphicsview#updateScene&quot;&gt;updateScene&lt;/a&gt;（）插槽，并且视图的滚动条进行调整以适合场景的大小。</target>
        </trans-unit>
        <trans-unit id="a9d5b266152d0f4cd9bb69c2a4c651cf03cd822b" translate="yes" xml:space="preserve">
          <source>When a shared object is created, it sets the reference count to 1. The reference count is incremented whenever a new object references the shared data, and decremented when the object dereferences the shared data. The shared data is deleted when the reference count becomes zero.</source>
          <target state="translated">当创建共享对象时,它将引用计数设为1。每当有新对象引用共享数据时,引用计数就会递增,当对象取消引用共享数据时,引用计数就会递减。当引用计数变为零时,共享数据被删除。</target>
        </trans-unit>
        <trans-unit id="cc3649a6da4b8adb60932067105d0642a4d24c46" translate="yes" xml:space="preserve">
          <source>When a shortcut's key sequence is completed, activatedAmbiguously() is emitted if the key sequence is still ambiguous (i.e., it is the start of one or more other shortcuts). The &lt;a href=&quot;qshortcut#activated&quot;&gt;activated&lt;/a&gt;() signal is not emitted in this case.</source>
          <target state="translated">当快捷键的键序列完成时，如果键序列仍然不明确（即，它是一个或多个其他快捷键的开始），则发出ActivateAmbiguously（）。的&lt;a href=&quot;qshortcut#activated&quot;&gt;活化&lt;/a&gt;（）信号没有在这种情况下发射。</target>
        </trans-unit>
        <trans-unit id="6332ae030a9135a45f7906377ec58084cbfab446" translate="yes" xml:space="preserve">
          <source>When a signal is emitted, the slots connected to it are usually executed immediately, just like a normal function call. When this happens, the signals and slots mechanism is totally independent of any GUI event loop. Execution of the code following the &lt;code&gt;emit&lt;/code&gt; statement will occur once all slots have returned. The situation is slightly different when using &lt;a href=&quot;qt#ConnectionType-enum&quot;&gt;queued connections&lt;/a&gt;; in such a case, the code following the &lt;code&gt;emit&lt;/code&gt; keyword will continue immediately, and the slots will be executed later.</source>
          <target state="translated">发出信号后，与其连接的插槽通常会立即执行，就像正常的函数调用一样。发生这种情况时，信号和时隙机制完全独立于任何GUI事件循环。一旦所有插槽都返回，将执行 &lt;code&gt;emit&lt;/code&gt; 语句之后的代码。使用&lt;a href=&quot;qt#ConnectionType-enum&quot;&gt;排队连接&lt;/a&gt;时情况略有不同; 在这种情况下， &lt;code&gt;emit&lt;/code&gt; 关键字之后的代码将立即继续，并且稍后将执行插槽。</target>
        </trans-unit>
        <trans-unit id="9ddb05e9c434f565919399ed11ae59e44adc1a53" translate="yes" xml:space="preserve">
          <source>When a slot is called in an object due to a signal delivery or due to a remote method call, it is sometimes necessary to know the context in which that happened. In particular, if the slot determines that it wants to send the reply at a later opportunity or if it wants to reply with an error, the context is needed.</source>
          <target state="translated">当一个槽由于信号传递或由于远程方法调用而在对象中被调用时,有时需要知道发生这种情况的上下文。特别是,如果槽确定它想在以后的机会发送回复,或者它想用错误来回复,就需要上下文。</target>
        </trans-unit>
        <trans-unit id="b82f70b447a179232f4e12d074947bc0969bd039" translate="yes" xml:space="preserve">
          <source>When a split handle is dragged, the &lt;code&gt;SplitView.preferredWidth&lt;/code&gt; or &lt;code&gt;SplitView.preferredHeight&lt;/code&gt; property is overwritten, depending on the &lt;a href=&quot;qml-qtquick-controls2-splitview#orientation-prop&quot;&gt;orientation&lt;/a&gt; of the view.</source>
          <target state="translated">拖动拆分句柄时， &lt;code&gt;SplitView.preferredWidth&lt;/code&gt; 或 &lt;code&gt;SplitView.preferredHeight&lt;/code&gt; 属性将被覆盖，具体取决于视图的&lt;a href=&quot;qml-qtquick-controls2-splitview#orientation-prop&quot;&gt;方向&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7d4d5ea445229544da0d5338a305894b8698bdd0" translate="yes" xml:space="preserve">
          <source>When a split item is resized, the preferredHeight will be set in order to keep track of the new size.</source>
          <target state="translated">当一个拆分项目被调整大小时,为了跟踪新的大小,将设置首选高度。</target>
        </trans-unit>
        <trans-unit id="161235a5aac72fca97ccfb11b438ac5fe662b266" translate="yes" xml:space="preserve">
          <source>When a split item is resized, the preferredWidth will be set in order to keep track of the new size.</source>
          <target state="translated">当一个拆分项目被调整大小时,为了跟踪新的大小,将设置首选宽度。</target>
        </trans-unit>
        <trans-unit id="2a09b738b648e2f453338d46763c1dca7735230f" translate="yes" xml:space="preserve">
          <source>When a stack is added to a group using &lt;a href=&quot;qundogroup#addStack&quot;&gt;addStack&lt;/a&gt;(), the group does not take ownership of the stack. This means the stack has to be deleted separately from the group. When a stack is deleted, it is automatically removed from a group. A stack may belong to only one group. Adding it to another group will cause it to be removed from the previous group.</source>
          <target state="translated">使用&lt;a href=&quot;qundogroup#addStack&quot;&gt;addStack&lt;/a&gt;（）将堆栈添加到组中时，该组不拥有该堆栈的所有权。这意味着堆栈必须与组分开删除。删除堆栈后，它将自动从组中删除。堆栈可能仅属于一个组。将其添加到另一个组会将其从上一个组中删除。</target>
        </trans-unit>
        <trans-unit id="3d6e4a2b53c50f2891abb48a8f6f6cc25d79ab52" translate="yes" xml:space="preserve">
          <source>When a state extends another state, it inherits all the changes of that state.</source>
          <target state="translated">当一个状态扩展另一个状态时,它继承了该状态的所有变化。</target>
        </trans-unit>
        <trans-unit id="6a4a099453c8a8d91cb5a5c167ee9f1538c09b8c" translate="yes" xml:space="preserve">
          <source>When a state is active, all its parent states are active by definition. When</source>
          <target state="translated">当一个状态处于活动状态时,根据定义,它的所有父状态都处于活动状态。当</target>
        </trans-unit>
        <trans-unit id="ba9d99ab4b7d6deb7d6417df3035d1441aabe91d" translate="yes" xml:space="preserve">
          <source>When a state is exited prior to the animation finishing, the behavior of the state machine depends on the target state of the transition. If the target state explicitly assigns a value to the property, no additional action will be taken. The property will be assigned the value defined by the target state.</source>
          <target state="translated">当一个状态在动画结束前退出时,状态机的行为取决于过渡的目标状态。如果目标状态明确地给属性赋值,则不会采取额外的操作。该属性将被分配目标状态定义的值。</target>
        </trans-unit>
        <trans-unit id="537b863aa4165206f1678fd45b68c897e7e5bb32" translate="yes" xml:space="preserve">
          <source>When a string is surrounded by slashes, it is interpreted as a &lt;a href=&quot;qregularexpression&quot;&gt;regular expression&lt;/a&gt;.</source>
          <target state="translated">当字符串被斜杠包围时，它将被解释为&lt;a href=&quot;qregularexpression&quot;&gt;正则表达式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f4d38a1eefb6595f564c6b5c58858271837243de" translate="yes" xml:space="preserve">
          <source>When a style sheet is active, the &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; returned by &lt;a href=&quot;qwidget#style&quot;&gt;QWidget::style&lt;/a&gt;() is a wrapper &quot;style sheet&quot; style,</source>
          <target state="translated">当样式表处于活动状态时，由&lt;a href=&quot;qwidget#style&quot;&gt;QWidget :: style&lt;/a&gt;（）返回的&lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt;是包装器&amp;ldquo;样式表&amp;rdquo;样式，</target>
        </trans-unit>
        <trans-unit id="e7f2cf6a190dccb2e1846d702f8b4fdcc1492b48" translate="yes" xml:space="preserve">
          <source>When a task menu extension is required,</source>
          <target state="translated">当需要任务菜单扩展时。</target>
        </trans-unit>
        <trans-unit id="b2160c5e21033a9cae7267b16da76e63faf558c9" translate="yes" xml:space="preserve">
          <source>When a texture is sub-sampled, fewer pixels than in the original are displayed, resulting in undesirable artifacts based on which pixels are chosen. This effect is worsened when the model is moving, as different pixels are chosen at different times. In the image below, notice how the line between E3 and F3 is missing, strongly present between G3 and H3, then gone for the next 5 columns, and so on.</source>
          <target state="translated">当对纹理进行子采样时,显示的像素比原始的少,导致根据选择的像素而产生不理想的伪影。当模型移动时,这种效果会更加严重,因为在不同的时间选择不同的像素。在下图中,请注意E3和F3之间的线是如何消失的,G3和H3之间的线强烈存在,然后在接下来的5列中消失,以此类推。</target>
        </trans-unit>
        <trans-unit id="67462236b92450150e95164abdc0c9f99abaed6b" translate="yes" xml:space="preserve">
          <source>When a timer is started, the first trigger is usually after the specified interval has elapsed. It is sometimes desirable to trigger immediately when the timer is started; for example, to establish an initial state.</source>
          <target state="translated">当定时器启动时,第一次触发通常是在指定的时间间隔过后。有时最好在定时器启动时立即触发;例如,建立一个初始状态。</target>
        </trans-unit>
        <trans-unit id="af89fc9ae90b687bd3803dfbbaa74da9d0b068bb" translate="yes" xml:space="preserve">
          <source>When a toolbar is resized in such a way that it is too small to show all the items it contains, an extension button will appear as the last item in the toolbar. Pressing the extension button will pop up a menu containing the items that do not currently fit in the toolbar.</source>
          <target state="translated">当工具栏的大小调整到无法显示所有项目时,扩展按钮将作为工具栏的最后一个项目出现。按下扩展按钮将弹出一个菜单,其中包含了当前不适合在工具栏中显示的项目。</target>
        </trans-unit>
        <trans-unit id="fd7d3a341e5fbdb2b1a43242fcba495d019b0218" translate="yes" xml:space="preserve">
          <source>When a validator is set, the text field will only accept input which leaves the text property in an intermediate state. The &lt;a href=&quot;qml-qtquick-controls2-combobox#accepted-signal&quot;&gt;accepted&lt;/a&gt; signal will only be emitted if the text is in an acceptable state when the &lt;b&gt;Return&lt;/b&gt; or &lt;b&gt;Enter&lt;/b&gt; key is pressed.</source>
          <target state="translated">设置验证器后，文本字段将仅接受使text属性处于中间状态的输入。所述&lt;a href=&quot;qml-qtquick-controls2-combobox#accepted-signal&quot;&gt;接受的&lt;/a&gt;，如果文本是在可接受的状态下，当信号将仅发射&lt;b&gt;返回&lt;/b&gt;或&lt;b&gt;回车&lt;/b&gt;键被按下。</target>
        </trans-unit>
        <trans-unit id="9881f5360fc059aa0376cd9d05bbf2f898c14217" translate="yes" xml:space="preserve">
          <source>When a variable or property holds a basic type and it is assigned to another variable or property, then a copy of the value is made. In JavaScript, this value is called a primitive value.</source>
          <target state="translated">当一个变量或属性持有一个基本类型,并将其分配给另一个变量或属性时,那么就会对该值进行复制。在JavaScript中,这个值被称为基本值。</target>
        </trans-unit>
        <trans-unit id="c53c2d5ff931b774b8c26a43310ae5dc80383c71" translate="yes" xml:space="preserve">
          <source>When a version number is specified (using the &lt;code&gt;&lt;a href=&quot;#version&quot;&gt;version&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#versionsym&quot;&gt;versionsym&lt;/a&gt;&lt;/code&gt; variables in a &lt;code&gt;.qdocconf&lt;/code&gt; file), it is accessible through the corresponding \version command for use in the documentation.</source>
          <target state="translated">当指定一个版本号（使用 &lt;code&gt;&lt;a href=&quot;#version&quot;&gt;version&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#versionsym&quot;&gt;versionsym&lt;/a&gt;&lt;/code&gt; 在变量 &lt;code&gt;.qdocconf&lt;/code&gt; 文件），它是通过相应的\ version命令的文件用访问。</target>
        </trans-unit>
        <trans-unit id="684ca00eacddf983276d3d465bca149ba5b62e18" translate="yes" xml:space="preserve">
          <source>When a version number is specified (using the &lt;code&gt;&lt;a href=&quot;22-qdoc-configuration-generalvariables#version&quot;&gt;version&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;22-qdoc-configuration-generalvariables#versionsym&quot;&gt;versionsym&lt;/a&gt;&lt;/code&gt; variables in a &lt;code&gt;.qdocconf&lt;/code&gt; file), it is accessible through the corresponding \version command for use in the documentation.</source>
          <target state="translated">当指定一个版本号（使用 &lt;code&gt;&lt;a href=&quot;22-qdoc-configuration-generalvariables#version&quot;&gt;version&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;22-qdoc-configuration-generalvariables#versionsym&quot;&gt;versionsym&lt;/a&gt;&lt;/code&gt; 在变量 &lt;code&gt;.qdocconf&lt;/code&gt; 文件），它是通过相应的\ version命令的文件用访问。</target>
        </trans-unit>
        <trans-unit id="1aed6e59537ae181997a746ca0c8b7b7d30d9468" translate="yes" xml:space="preserve">
          <source>When a view transition is initialized, any property bindings that refer to the &lt;a href=&quot;qml-qtquick-viewtransition&quot;&gt;ViewTransition&lt;/a&gt; attached property are evaluated in preparation for the transition. Due to the nature of the internal construction of a view transition, the attributes of the &lt;a href=&quot;qml-qtquick-viewtransition&quot;&gt;ViewTransition&lt;/a&gt; attached property are only valid for the relevant item when the transition is initialized, and may not be valid when the transition is actually run.</source>
          <target state="translated">初始化视图过渡时，&lt;a href=&quot;qml-qtquick-viewtransition&quot;&gt;将对&lt;/a&gt;引用ViewTransition附加属性的所有属性绑定进行评估，以为过渡做准备。由于视图过渡的内部构造的性质，&lt;a href=&quot;qml-qtquick-viewtransition&quot;&gt;ViewTransition&lt;/a&gt;附加属性的属性仅在过渡被初始化时对相关项有效，而在过渡运行时可能无效。</target>
        </trans-unit>
        <trans-unit id="2f1582c86a02339dce081b982fa7bf2aabd7e9cf" translate="yes" xml:space="preserve">
          <source>When a view transition is initialized, any property bindings that refer to the ViewTransition attached property are evaluated in preparation for the transition. Due to the nature of the internal construction of a view transition, the attributes of the ViewTransition attached property are only valid for the relevant item when the transition is initialized, and may not be valid when the transition is actually run.</source>
          <target state="translated">当视图过渡被初始化时,任何引用ViewTransition附加属性的属性绑定都会在准备过渡时被评估。由于视图过渡的内部构造的性质,ViewTransition 附属属性的属性仅在过渡被初始化时对相关项有效,而在过渡实际运行时可能无效。</target>
        </trans-unit>
        <trans-unit id="079663e19f7c1ba992af80c0570d23237432e8c5" translate="yes" xml:space="preserve">
          <source>When a web site requests an SSL client certificate, and one or more certificates are found in the system's client certificate store, this class provides access to the certificates to choose from, as well as a method for selecting one.</source>
          <target state="translated">当一个网站请求SSL客户端证书,并且在系统的客户端证书存储中找到一个或多个证书时,这个类提供了对证书的访问,以及选择证书的方法。</target>
        </trans-unit>
        <trans-unit id="47f6110b5cfc30bcf437b8673336a30eccbb3a9e" translate="yes" xml:space="preserve">
          <source>When a web site requests an SSL client certificate, and one or more certificates are found in the system's client certificate store, this type provides access to the certificates to choose from, as well as a method for selecting one.</source>
          <target state="translated">当网站请求SSL客户端证书,并且在系统的客户端证书存储中找到了一个或多个证书时,该类型提供了对证书的访问选择,以及选择证书的方法。</target>
        </trans-unit>
        <trans-unit id="1a0abde4adaf9ada28bc188c310ca57b1baed315" translate="yes" xml:space="preserve">
          <source>When a widget &lt;a href=&quot;qwidget#acceptDrops-prop&quot;&gt;accepts drop events&lt;/a&gt;, it will receive this event if it has accepted the most recent &lt;a href=&quot;qdragenterevent&quot;&gt;QDragEnterEvent&lt;/a&gt; or &lt;a href=&quot;qdragmoveevent&quot;&gt;QDragMoveEvent&lt;/a&gt; sent to it.</source>
          <target state="translated">当小部件&lt;a href=&quot;qwidget#acceptDrops-prop&quot;&gt;接受放置事件时&lt;/a&gt;，如果它已接受发送给它的最新&lt;a href=&quot;qdragenterevent&quot;&gt;QDragEnterEvent&lt;/a&gt;或&lt;a href=&quot;qdragmoveevent&quot;&gt;QDragMoveEvent&lt;/a&gt;，它将接收此事件。</target>
        </trans-unit>
        <trans-unit id="460e4079ae7809950eebb7e9e8f3fa669aaa1958" translate="yes" xml:space="preserve">
          <source>When a widget asks a style to draw an element, it provides the style with a &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt;, which is a class that contains the information necessary for drawing. Thanks to &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt;, it is possible to make &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; draw widgets without linking in any code for the widget. This makes it possible to use &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt;'s draw functions on any paint device, i.e., you can draw a combobox on any widget, not just on a &lt;a href=&quot;qcombobox&quot;&gt;QComboBox&lt;/a&gt;.</source>
          <target state="translated">当小部件要求样式绘制元素时，它会为样式提供&lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt;，这是一个类，其中包含绘制所需的信息。由于使用了&lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt;，因此可以制作&lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt;绘制窗口小部件，而无需链接该窗口小部件的任何代码。这样就可以在任何绘画设备上使用&lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt;的绘制功能，即，您可以在任何窗口小部件上绘制一个组合框，而不仅仅是在&lt;a href=&quot;qcombobox&quot;&gt;QComboBox上&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="18244731262c183108a3e2f7ccadcf53e5fc48af" translate="yes" xml:space="preserve">
          <source>When a widget asks a style to draw an element, it provides the style with a &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt;, which is a class that contains the information necessary for drawing. Thanks to &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt;, it is possible to make &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; draw widgets without linking in any code for the widget. This makes it possible to use &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt;'s draw functions on any paint device, i.e., you can draw a combobox on any widget, not just on a &lt;a href=&quot;widgets-changes-qt6#qcombobox&quot;&gt;QComboBox&lt;/a&gt;.</source>
          <target state="translated">当窗口小部件要求样式绘制元素时，它会为样式提供&lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt;，这是一个类，其中包含绘制所需的信息。由于使用了&lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt;，因此可以制作&lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt;绘制窗口小部件，而无需链接该窗口小部件的任何代码。这样就可以在任何绘画设备上使用&lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt;的绘制功能，即，您可以在任何窗口小部件上绘制一个组合框，而不仅仅是在&lt;a href=&quot;widgets-changes-qt6#qcombobox&quot;&gt;QComboBox上&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e6f3f2c1aa86e2bdbf72b92865fad22cdf8f8992" translate="yes" xml:space="preserve">
          <source>When a widget is selected, normal clipboard operations such as cut, copy, and paste can be performed on it. All of these operations can be done and undone, as necessary.</source>
          <target state="translated">选择小组件后,可对其进行剪贴板操作,如剪切、复制和粘贴。所有这些操作都可以根据需要进行和撤销。</target>
        </trans-unit>
        <trans-unit id="32939db177a40f178792d1ab4a3586964a02a117" translate="yes" xml:space="preserve">
          <source>When a widget is used as a container to group a number of child widgets, it is known as a composite widget. These can be created by constructing a widget with the required visual properties - a &lt;a href=&quot;qframe&quot;&gt;QFrame&lt;/a&gt;, for example - and adding child widgets to it, usually managed by a layout. The above diagram shows such a composite widget that was created using Qt Designer.</source>
          <target state="translated">当将小部件用作对多个子小部件进行分组的容器时，它称为复合小部件。可以通过构造具有所需视觉属性的小部件（例如&lt;a href=&quot;qframe&quot;&gt;QFrame）&lt;/a&gt;并向其添加通常由布局管理的子小部件来创建这些小部件。上图显示了使用Qt Designer创建的复合窗口小部件。</target>
        </trans-unit>
        <trans-unit id="752f1a934fb7040e2a75e0adc0d7c4e3b00e3529" translate="yes" xml:space="preserve">
          <source>When a widget's font changes, it resolves its entries against its parent widget. If the widget does not have a parent widget, it resolves its entries against the scene. The widget then sends itself a &lt;a href=&quot;qevent#Type-enum&quot;&gt;FontChange&lt;/a&gt; event and notifies all its descendants so that they can resolve their fonts as well.</source>
          <target state="translated">当窗口小部件的字体更改时，它将根据其父窗口小部件解析其条目。如果该窗口小部件没有父窗口小部件，则会根据场景解析其条目。然后，小部件将自己发送一个&lt;a href=&quot;qevent#Type-enum&quot;&gt;FontChange&lt;/a&gt;事件并通知其所有后代，以便他们也可以解析其字体。</target>
        </trans-unit>
        <trans-unit id="8a4c47081bd0d78ce71a943dd5b9dd67bf60e6f3" translate="yes" xml:space="preserve">
          <source>When a widget's palette changes, it resolves its entries against its parent widget, or if it doesn't have a parent widget, it resolves against the scene. It then sends itself a &lt;a href=&quot;qevent#Type-enum&quot;&gt;PaletteChange&lt;/a&gt; event, and notifies all its descendants so they can resolve their palettes as well.</source>
          <target state="translated">当窗口小部件的调色板发生更改时，它将根据其父窗口小部件解析其条目，或者如果它没有父窗口小部件，则针对场景进行解析。然后，它向自己发送一个&lt;a href=&quot;qevent#Type-enum&quot;&gt;PaletteChange&lt;/a&gt;事件，并通知其所有后代，以便他们也可以解析其调色板。</target>
        </trans-unit>
        <trans-unit id="6c935a584189a93e055ba79f2173aba07e5d505b" translate="yes" xml:space="preserve">
          <source>When a window is not visible its visibility is Hidden, and setting visibility to &lt;a href=&quot;qwindow#Visibility-enum&quot;&gt;Hidden&lt;/a&gt; is the same as setting &lt;a href=&quot;qml-qtquick-window-window#visible-prop&quot;&gt;visible&lt;/a&gt; to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">当窗口不可见其知名度是隐藏的，并设置能见度&lt;a href=&quot;qwindow#Visibility-enum&quot;&gt;隐藏的&lt;/a&gt;是一样的设置&lt;a href=&quot;qml-qtquick-window-window#visible-prop&quot;&gt;可见&lt;/a&gt;，以 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f00f9a36cab0fd127d8e73ba8beab37d6aef658e" translate="yes" xml:space="preserve">
          <source>When a window is not visible its visibility is Hidden, and setting visibility to &lt;a href=&quot;qwindow#Visibility-enum&quot;&gt;Hidden&lt;/a&gt; is the same as setting &lt;a href=&quot;qml-window#visible-prop&quot;&gt;visible&lt;/a&gt; to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">当窗口不可见时，其可见性为&amp;ldquo;隐藏&amp;rdquo;，将可见性设置为&amp;ldquo;&lt;a href=&quot;qwindow#Visibility-enum&quot;&gt;隐藏&lt;/a&gt;&amp;rdquo;与将&amp;ldquo;&lt;a href=&quot;qml-window#visible-prop&quot;&gt;可见&amp;rdquo;&lt;/a&gt;设置为 &lt;code&gt;false&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="328cfe9dc26b3602c3dd93834eca6371ca53bcbc" translate="yes" xml:space="preserve">
          <source>When a window is using an OpenGL based surface and is appearing in full screen mode, problems can occur with other top-level windows which are part of the application. Due to limitations of the Windows DWM, compositing is not handled correctly for OpenGL based windows when going into full screen mode. As a result, other top-level windows are not placed on top of the full screen window when they are made visible. For example, menus may not appear correctly, or dialogs fail to show up.</source>
          <target state="translated">当一个窗口使用基于OpenGL的曲面并以全屏模式出现时,作为应用程序一部分的其他顶层窗口可能会出现问题。由于Windows DWM的限制,当进入全屏模式时,不能正确处理基于OpenGL的窗口的合成。因此,当其他顶层窗口变得可见时,它们不会被放置在全屏窗口的顶部。例如,菜单可能无法正确显示,或对话框无法显示。</target>
        </trans-unit>
        <trans-unit id="e6e925bbf3d90d27901234a3378310aa8ca76a99" translate="yes" xml:space="preserve">
          <source>When absolutely necessary, this limitation can be overcome by setting the &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_AlwaysStackOnTop&lt;/a&gt; attribute on the &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt;. Be aware however that this breaks stacking order, for example it will not be possible to have other widgets on top of the &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt;, so it should only be used in situations where a semi-transparent &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt; with other widgets visible underneath is required.</source>
          <target state="translated">在绝对必要的，这种限制可以通过设置来克服&lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;的Qt :: WA_AlwaysStackOnTop&lt;/a&gt;的属性&lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt;。但是请注意，这会破坏堆叠顺序，例如，不可能在&lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget的&lt;/a&gt;顶部放置其他小部件，因此，仅在需要半透明&lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt;及其下方需要其他小部件的情况下才应使用它。</target>
        </trans-unit>
        <trans-unit id="b6f91c3f1d20bbeecc7d389e5ae573aae0f28831" translate="yes" xml:space="preserve">
          <source>When absolutely necessary, this limitation can be overcome by setting the &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_AlwaysStackOnTop&lt;/a&gt; attribute on the &lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt;. Be aware, however that this breaks stacking order. For example it will not be possible to have other widgets on top of the &lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt;, so it should only be used in situations where a semi-transparent &lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt; with other widgets visible underneath is required.</source>
          <target state="translated">在绝对必要的，这种限制可以通过设置来克服&lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;的Qt :: WA_AlwaysStackOnTop&lt;/a&gt;的属性&lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt;。但是请注意，这会破坏堆叠顺序。例如，不可能在&lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt;上放置其他小部件，因此仅应在需要半透明&lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt;及其下方可见其他小部件的情况下使用。</target>
        </trans-unit>
        <trans-unit id="dd97e50e2c67a4ead279bf8d8832fc9a85185034" translate="yes" xml:space="preserve">
          <source>When absolutely necessary, this limitation can be overcome by setting the &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_AlwaysStackOnTop&lt;/a&gt; attribute on the QOpenGLWidget. Be aware however that this breaks stacking order, for example it will not be possible to have other widgets on top of the QOpenGLWidget, so it should only be used in situations where a semi-transparent QOpenGLWidget with other widgets visible underneath is required.</source>
          <target state="translated">在绝对必要时，可以通过在&lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;QOpenGLWidget&lt;/a&gt;上设置Qt :: WA_AlwaysStackOnTop属性来克服此限制。但是请注意，这会破坏堆叠顺序，例如，不可能在QOpenGLWidget的顶部放置其他小部件，因此仅应在需要半透明QOpenGLWidget及其下方可见其他小部件的情况下使用。</target>
        </trans-unit>
        <trans-unit id="e79a7fffcc2719cd295404f96fe561b573e17000" translate="yes" xml:space="preserve">
          <source>When absolutely necessary, this limitation can be overcome by setting the &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_AlwaysStackOnTop&lt;/a&gt; attribute on the QQuickWidget. Be aware, however that this breaks stacking order. For example it will not be possible to have other widgets on top of the QQuickWidget, so it should only be used in situations where a semi-transparent QQuickWidget with other widgets visible underneath is required.</source>
          <target state="translated">在绝对必要时，可以通过在&lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;QQuickWidget&lt;/a&gt;上设置Qt :: WA_AlwaysStackOnTop属性来克服此限制。但是请注意，这会破坏堆叠顺序。例如，不可能在QQuickWidget上放置其他小部件，因此仅应在需要半透明QQuickWidget及其下方可见其他小部件的情况下使用。</target>
        </trans-unit>
        <trans-unit id="9df5199ed73ebbcc06766d6511a4572850a19641" translate="yes" xml:space="preserve">
          <source>When access to the data is no longer needed be sure to call the &lt;a href=&quot;qabstractvideobuffer#unmap&quot;&gt;unmap&lt;/a&gt;() function to release the mapped memory and possibly update the buffer contents.</source>
          <target state="translated">当不再需要访问数据时，请确保调用&lt;a href=&quot;qabstractvideobuffer#unmap&quot;&gt;unmap&lt;/a&gt;（）函数以释放映射的内存并可能更新缓冲区内容。</target>
        </trans-unit>
        <trans-unit id="7f19c431a0d32b110924683908433279ea139496" translate="yes" xml:space="preserve">
          <source>When access to the data is no longer needed, be sure to call the &lt;a href=&quot;qvideoframe#unmap&quot;&gt;unmap&lt;/a&gt;() function to release the mapped memory and possibly update the video frame contents.</source>
          <target state="translated">当不再需要访问数据时，请确保调用&lt;a href=&quot;qvideoframe#unmap&quot;&gt;unmap&lt;/a&gt;（）函数以释放映射的内存并可能更新视频帧的内容。</target>
        </trans-unit>
        <trans-unit id="76c2596888d85f6b2c006508a41b7c104d68f3e1" translate="yes" xml:space="preserve">
          <source>When active is &lt;code&gt;true&lt;/code&gt;, and the delegate component is ready, the Instantiator will create objects according to the model. When active is &lt;code&gt;false&lt;/code&gt;, no objects will be created and any previously created objects will be destroyed.</source>
          <target state="translated">当active为 &lt;code&gt;true&lt;/code&gt; 时，并且委托组件已准备就绪，Instantiator将根据模型创建对象。当active为 &lt;code&gt;false&lt;/code&gt; 时，将不创建任何对象，并且将销毁任何先前创建的对象。</target>
        </trans-unit>
        <trans-unit id="12b8ae889e8cb41399d2e7e574fc759816dcd949" translate="yes" xml:space="preserve">
          <source>When active is true, and the delegate component is ready, the Instantiator will create objects according to the model. When active is false, no objects will be created and any previously created objects will be destroyed.</source>
          <target state="translated">当active为true,并且委托组件准备就绪时,Instantiator将根据模型创建对象。当active为false时,将不会创建任何对象,任何先前创建的对象将被销毁。</target>
        </trans-unit>
        <trans-unit id="bb891bbb3b1590bf7288c70b1d889bb5699abbfb" translate="yes" xml:space="preserve">
          <source>When adding or removing intervals from the time range, existing intervals within the range may be expanded, trimmed, deleted, merged or split to ensure that all intervals within the time range remain distinct and disjoint. As a consequence, all intervals added or removed from a time range must be &lt;a href=&quot;qmediatimeinterval#isNormal&quot;&gt;normal&lt;/a&gt;.</source>
          <target state="translated">在时间范围内添加或删除时间间隔时，可以扩展，修剪，删除，合并或拆分该时间范围内的现有时间间隔，以确保该时间范围内的所有时间间隔保持不同且不相交。结果，从时间范围添加或删除的所有间隔都必须是&lt;a href=&quot;qmediatimeinterval#isNormal&quot;&gt;正常的&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0d4f3812ee3ea698da8238994dd265c1c75c9c45" translate="yes" xml:space="preserve">
          <source>When adding text to a text edit, it is an advantage to add it in an edit block (see example below). The result is that the text edit does not need to build the entire document structure at once.</source>
          <target state="translated">当在文本编辑中添加文本时,将其添加在编辑块中是一个优势(见下面的例子)。其结果是,文本编辑不需要一次性建立整个文档结构。</target>
        </trans-unit>
        <trans-unit id="bb84371278c0809ff19ae10f5e09e0a84286da38" translate="yes" xml:space="preserve">
          <source>When adding touch events to the sequence,</source>
          <target state="translated">将触摸事件添加到序列中时。</target>
        </trans-unit>
        <trans-unit id="f1538eed1aaf041d2e66701f8146b1df9ccdc51d" translate="yes" xml:space="preserve">
          <source>When additional touch points are detected, Qt first looks to see if there are any active touch points on any ancestor or descendent of the widget under the new touch point. If there are, the new touch point is grouped with the first, and the new touch point will be sent in a single &lt;a href=&quot;qtouchevent&quot;&gt;QTouchEvent&lt;/a&gt; to the widget that handled the first touch point. (The widget under the new touch point will not receive an event).</source>
          <target state="translated">当检测到其他接触点时，Qt首先查看是否在新接触点下小部件的任何祖先或后代上有任何活动的接触点。如果有的话，新的接触点将与第一个接触点分组，并且新的接触点将在单个&lt;a href=&quot;qtouchevent&quot;&gt;QTouchEvent中&lt;/a&gt;发送到处理第一个接触点的小部件。（新接触点下的小部件将不会收到事件）。</target>
        </trans-unit>
        <trans-unit id="e556c9c43b8715d0148015f22447dd2e38354307" translate="yes" xml:space="preserve">
          <source>When additional touch points are detected, Qt first looks to see if there are any active touch points on any ancestor or descendent of the widget under the new touch point. If there are, the new touch point is grouped with the first, and the new touch point will be sent in a single QTouchEvent to the widget that handled the first touch point. (The widget under the new touch point will not receive an event).</source>
          <target state="translated">当检测到额外的触摸点时,Qt 首先查看新触摸点下的部件的祖先或后裔是否有任何活动的触摸点。如果有,新的触控点将与第一个触控点分组,新的触控点将以单个 QTouchEvent 发送给处理第一个触控点的小组件。(新触摸点下的小组件将不会收到事件)。</target>
        </trans-unit>
        <trans-unit id="7e4c9f17f04f10fedd1f9fd887395ad46b2aa135" translate="yes" xml:space="preserve">
          <source>When all content of the scene has stopped moving, the camera is jiggled very slightly between frames, and the result of each new frame is blended with the previous frames. The more frames you accumulate, the better looking the result.</source>
          <target state="translated">当场景中的所有内容都停止移动时,摄像机在帧与帧之间会有很轻微的抖动,每一帧新帧的结果都会与之前的帧融合。积累的帧数越多,效果越好看。</target>
        </trans-unit>
        <trans-unit id="e831f4eb7ef019746768c98e62442552c2eec2dc" translate="yes" xml:space="preserve">
          <source>When all the class attribute values are defined as they are in the style.css file that is used for rendering the Qt documentation, the above example is rendered as:</source>
          <target state="translated">当所有的类属性值都被定义为它们在用于渲染Qt文档的style.css文件中的值时,上面的例子被渲染为。</target>
        </trans-unit>
        <trans-unit id="bddff14c450c718712b8166ec8a19a179f1d175d" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtqml-modules-identifiedmodules.html#&quot;&gt;identified module&lt;/a&gt; is imported, the QML engine searches the</source>
          <target state="translated">当&lt;a href=&quot;https://doc.qt.io/qt-5.13/qtqml-modules-identifiedmodules.html#&quot;&gt;识别模块&lt;/a&gt;是进口的，QML引擎的搜索</target>
        </trans-unit>
        <trans-unit id="9add852e9635e48ec41c6e958905759815f12454" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtqml-modules-identifiedmodules.html&quot;&gt;identified module&lt;/a&gt; is imported, the QML engine searches the</source>
          <target state="translated">当&lt;a href=&quot;https://doc.qt.io/qt-5.15/qtqml-modules-identifiedmodules.html&quot;&gt;识别模块&lt;/a&gt;是进口的，QML引擎的搜索</target>
        </trans-unit>
        <trans-unit id="d40c465f050b8db28c4c35f598504d6759b5fa63" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtqml-modules-identifiedmodules.html&quot;&gt;identified module&lt;/a&gt; is imported, the QML engine searches the</source>
          <target state="translated">当&lt;a href=&quot;https://doc.qt.io/qt-6.0/qtqml-modules-identifiedmodules.html&quot;&gt;识别模块&lt;/a&gt;是进口的，QML引擎的搜索</target>
        </trans-unit>
        <trans-unit id="0cb0af928cd358589c97b0ea36760a95bf56bf0a" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;qml-qtquick-anchoranimation&quot;&gt;AnchorAnimation&lt;/a&gt; is used in a &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;Transition&lt;/a&gt;, it will animate any &lt;a href=&quot;qml-qtquick-anchorchanges&quot;&gt;AnchorChanges&lt;/a&gt; that have occurred during the state change. This can be overridden by setting a specific target item using the &lt;a href=&quot;qml-qtquick-anchorchanges#target-prop&quot;&gt;AnchorChanges.target&lt;/a&gt; property.</source>
          <target state="translated">当&lt;a href=&quot;qml-qtquick-anchoranimation&quot;&gt;AnchorAnimation&lt;/a&gt;在用过的&lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;过渡&lt;/a&gt;，这将动画任何&lt;a href=&quot;qml-qtquick-anchorchanges&quot;&gt;AnchorChanges&lt;/a&gt;状态变化过程中发生的。可以通过使用&lt;a href=&quot;qml-qtquick-anchorchanges#target-prop&quot;&gt;AnchorChanges.target&lt;/a&gt;属性设置特定的目标项目来覆盖它。</target>
        </trans-unit>
        <trans-unit id="f7ee3afe1168f0981bdb0b13f0d2799a8598f876" translate="yes" xml:space="preserve">
          <source>When an AnchorAnimation is used in a &lt;a href=&quot;https://doc.qt.io/qt-5.15/qmlexampletoggleswitch.html#transition&quot;&gt;Transition&lt;/a&gt;, it will animate any &lt;a href=&quot;qml-qtquick-anchorchanges&quot;&gt;AnchorChanges&lt;/a&gt; that have occurred during the state change. This can be overridden by setting a specific target item using the &lt;a href=&quot;qml-qtquick-anchorchanges#target-prop&quot;&gt;AnchorChanges.target&lt;/a&gt; property.</source>
          <target state="translated">当AnchorAnimation在用过的&lt;a href=&quot;https://doc.qt.io/qt-5.15/qmlexampletoggleswitch.html#transition&quot;&gt;过渡&lt;/a&gt;，这将动画任何&lt;a href=&quot;qml-qtquick-anchorchanges&quot;&gt;AnchorChanges&lt;/a&gt;状态变化过程中发生的。可以通过使用&lt;a href=&quot;qml-qtquick-anchorchanges#target-prop&quot;&gt;AnchorChanges.target&lt;/a&gt;属性设置特定的目标项目来覆盖它。</target>
        </trans-unit>
        <trans-unit id="faee301ab5657c0c6f33c4ac97a1da25b8e245c3" translate="yes" xml:space="preserve">
          <source>When an AnchorAnimation is used in a &lt;a href=&quot;https://doc.qt.io/qt-6.0/qmlexampletoggleswitch.html#transition&quot;&gt;Transition&lt;/a&gt;, it will animate any &lt;a href=&quot;qml-qtquick-anchorchanges&quot;&gt;AnchorChanges&lt;/a&gt; that have occurred during the state change. This can be overridden by setting a specific target item using the &lt;a href=&quot;qml-qtquick-anchorchanges#target-prop&quot;&gt;AnchorChanges.target&lt;/a&gt; property.</source>
          <target state="translated">当AnchorAnimation在用过的&lt;a href=&quot;https://doc.qt.io/qt-6.0/qmlexampletoggleswitch.html#transition&quot;&gt;过渡&lt;/a&gt;，这将动画任何&lt;a href=&quot;qml-qtquick-anchorchanges&quot;&gt;AnchorChanges&lt;/a&gt;状态变化过程中发生的。可以通过使用&lt;a href=&quot;qml-qtquick-anchorchanges#target-prop&quot;&gt;AnchorChanges.target&lt;/a&gt;属性设置特定的目标项目来覆盖它。</target>
        </trans-unit>
        <trans-unit id="3ba28642fdd34030f92c386fbe056673579dd0c3" translate="yes" xml:space="preserve">
          <source>When an accessible object is changed in a way that users need to know about, it notifies clients of the change by sending them an event via the accessible interface. This is how &lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt; calls &lt;a href=&quot;https://doc.qt.io/qt-5.13/qaccessible-obsolete.html#updateAccessibility&quot;&gt;updateAccessibility()&lt;/a&gt; to indicate that its value has changed:</source>
          <target state="translated">当以用户需要了解的方式更改可访问对象时，它通过可访问接口向客户端发送事件来通知更改。&lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt;就是这样调用&lt;a href=&quot;https://doc.qt.io/qt-5.13/qaccessible-obsolete.html#updateAccessibility&quot;&gt;updateAccessibility（）&lt;/a&gt;来指示其值已更改：</target>
        </trans-unit>
        <trans-unit id="b37fb5dbdfd3c126b6bb96b69ea36eec43900147" translate="yes" xml:space="preserve">
          <source>When an accessible object is changed in a way that users need to know about, it notifies clients of the change by sending them an event via the accessible interface. This is how &lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt; calls &lt;a href=&quot;https://doc.qt.io/qt-5.15/qaccessible-obsolete.html#updateAccessibility&quot;&gt;updateAccessibility()&lt;/a&gt; to indicate that its value has changed:</source>
          <target state="translated">当以用户需要了解的方式更改可访问对象时，它通过可访问接口向客户端发送事件来通知更改。&lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt;就是这样调用&lt;a href=&quot;https://doc.qt.io/qt-5.15/qaccessible-obsolete.html#updateAccessibility&quot;&gt;updateAccessibility（）&lt;/a&gt;来指示其值已更改：</target>
        </trans-unit>
        <trans-unit id="00d1038d5d102e70428982041f3613d0e5cf5771" translate="yes" xml:space="preserve">
          <source>When an accessible object is changed in a way that users need to know about, it notifies clients of the change by sending them an event via the accessible interface. This is how &lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt; calls &lt;a href=&quot;qaccessible#updateAccessibility&quot;&gt;updateAccessibility()&lt;/a&gt; to indicate that its value has changed:</source>
          <target state="translated">当以用户需要了解的方式更改可访问对象时，它通过可访问接口向客户端发送事件来通知更改。&lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt;就是这样调用&lt;a href=&quot;qaccessible#updateAccessibility&quot;&gt;updateAccessibility（）&lt;/a&gt;来指示其值已更改：</target>
        </trans-unit>
        <trans-unit id="6576db350133d85ab8ecdf7d5ae903317f8a0480" translate="yes" xml:space="preserve">
          <source>When an action is paired with buttons and menu items, the &lt;code&gt;enabled&lt;/code&gt;, &lt;code&gt;checkable&lt;/code&gt;, and &lt;code&gt;checked&lt;/code&gt; states are synced automatically. For example, in a word processor, if the user clicks a &quot;Bold&quot; toolbar button, the &quot;Bold&quot; menu item will automatically be checked. Buttons and menu items get their &lt;code&gt;text&lt;/code&gt; and &lt;code&gt;icon&lt;/code&gt; from the action by default. An action-specific &lt;code&gt;text&lt;/code&gt; or &lt;code&gt;icon&lt;/code&gt; can be overridden for a specific control by specifying &lt;code&gt;text&lt;/code&gt; or &lt;code&gt;icon&lt;/code&gt; directly on the control.</source>
          <target state="translated">当动作与按钮和菜单项配对时， &lt;code&gt;enabled&lt;/code&gt; ， &lt;code&gt;checkable&lt;/code&gt; 和 &lt;code&gt;checked&lt;/code&gt; 状态将自动同步。例如，在文字处理器中，如果用户单击&amp;ldquo;加粗&amp;rdquo;工具栏按钮，则将自动检查&amp;ldquo;加粗&amp;rdquo;菜单项。默认情况下，按钮和菜单项从操作中获取其 &lt;code&gt;text&lt;/code&gt; 和 &lt;code&gt;icon&lt;/code&gt; 。一个特定于操作的 &lt;code&gt;text&lt;/code&gt; 或 &lt;code&gt;icon&lt;/code&gt; 可以被覆盖，通过指定一个特定的控制 &lt;code&gt;text&lt;/code&gt; 或 &lt;code&gt;icon&lt;/code&gt; 上直接控制。</target>
        </trans-unit>
        <trans-unit id="afbbfa71a43b518eb49ebc7fe0e3a201130db196" translate="yes" xml:space="preserve">
          <source>When an animation is used as a value source or in a Behavior, the default target and property name to be animated can both be inferred.</source>
          <target state="translated">当动画作为值源或在Behavior中使用时,默认的目标和要动画的属性名都可以被推断出来。</target>
        </trans-unit>
        <trans-unit id="336fbed65cc485dcf3185a5f916cafb70ff1cbed" translate="yes" xml:space="preserve">
          <source>When an animation is used standalone, both the target and property need to be explicitly specified.</source>
          <target state="translated">当单独使用动画时,需要明确指定目标和属性。</target>
        </trans-unit>
        <trans-unit id="3e063384f01e7cc982fe175643205033a89ac5c6" translate="yes" xml:space="preserve">
          <source>When an application modal dialog is opened, the user must finish interacting with the dialog and close it before they can access any other window in the application. Window modal dialogs only block access to the window associated with the dialog, allowing the user to continue to use other windows in an application.</source>
          <target state="translated">当应用程序模态对话框被打开时,用户必须先完成与对话框的交互,并关闭它,然后才能访问应用程序中的任何其他窗口。窗口模态对话框只阻止访问与对话框相关的窗口,允许用户继续使用应用程序中的其他窗口。</target>
        </trans-unit>
        <trans-unit id="03f1ac029efa0e89898412a8bc3f237fc158d829" translate="yes" xml:space="preserve">
          <source>When an error occurs during a transaction (including an inner transaction failing), reading from the data stream is suspended (all subsequent read operations return empty/zero values) and subsequent inner transactions are forced to fail. Starting a new outermost transaction recovers from this state. This behavior makes it unnecessary to error-check every read operation separately.</source>
          <target state="translated">当一个事务中发生错误时(包括内部事务失败),从数据流中的读取将被暂停(所有后续的读取操作都返回空/零值),后续的内部事务将被迫失败。启动一个新的最外层事务可以从这种状态中恢复过来。这种行为使得没有必要分别对每个读操作进行错误检查。</target>
        </trans-unit>
        <trans-unit id="d4d4dd6c5a276f9a88210865c11ad3239fc05498" translate="yes" xml:space="preserve">
          <source>When an escape button can't be determined using these rules, pressing &lt;b&gt;Esc&lt;/b&gt; has no effect.</source>
          <target state="translated">如果无法使用这些规则确定转义按钮，则按&lt;b&gt;Esc键&lt;/b&gt;无效。</target>
        </trans-unit>
        <trans-unit id="88e91d6c3ac2f70e9dc327611729bb3fc23462f4" translate="yes" xml:space="preserve">
          <source>When an escape button could not be automatically detected, pressing &lt;b&gt;Esc&lt;/b&gt; has no effect.</source>
          <target state="translated">当无法自动检测到逃生按钮时，按&lt;b&gt;Esc键&lt;/b&gt;无效。</target>
        </trans-unit>
        <trans-unit id="60deb4d5ec6470a1989d6f1aae50fd37df3fb27a" translate="yes" xml:space="preserve">
          <source>When an event notification identified by</source>
          <target state="translated">当一个事件通知由</target>
        </trans-unit>
        <trans-unit id="cc1c8c604562d809abc5eea2fc6d1c3875525ea6" translate="yes" xml:space="preserve">
          <source>When an event occurs, Qt creates an event object to represent it by constructing an instance of the appropriate &lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt; subclass, and delivers it to a particular instance of &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; (or one of its subclasses) by calling its &lt;a href=&quot;qobject#event&quot;&gt;event()&lt;/a&gt; function.</source>
          <target state="translated">当事件发生时，Qt通过构造适当的&lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt;子类的实例来创建事件对象来表示它，并通过调用&lt;a href=&quot;qobject#event&quot;&gt;事件（）&lt;/a&gt;函数将其传递到&lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;的特定实例（或其子类之一）。</target>
        </trans-unit>
        <trans-unit id="de6f46d25c54bf3f5ae53599544aff515fdc8c6f" translate="yes" xml:space="preserve">
          <source>When an extension is requested,</source>
          <target state="translated">当申请延期时:</target>
        </trans-unit>
        <trans-unit id="82176d3ebc0806a90e56a238f12634352670b5cd" translate="yes" xml:space="preserve">
          <source>When an extension is required,</source>
          <target state="translated">当需要延期时。</target>
        </trans-unit>
        <trans-unit id="15891740de686f6443de37f1b681bce112b87311" translate="yes" xml:space="preserve">
          <source>When an input mask is set, the &lt;a href=&quot;qlineedit#text-prop&quot;&gt;text&lt;/a&gt;() method returns a modified copy of the line edit content where all the</source>
          <target state="translated">设置输入掩码后，&lt;a href=&quot;qlineedit#text-prop&quot;&gt;text&lt;/a&gt;（）方法将返回行编辑内容的修改后的副本，其中所有</target>
        </trans-unit>
        <trans-unit id="e58900421752248eb5fa9c7e1a8662c806ac6e45" translate="yes" xml:space="preserve">
          <source>When an item becomes the child of another item:</source>
          <target state="translated">当一个项目成为另一个项目的子项目时。</target>
        </trans-unit>
        <trans-unit id="6de19d2590d4fe0fe6e06630c40b5632e67df7b0" translate="yes" xml:space="preserve">
          <source>When an item gains the keyboard grab, it receives a &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::GrabKeyboard&lt;/a&gt; event. When it loses the keyboard grab, it receives a &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::UngrabKeyboard&lt;/a&gt; event. These events can be used to detect when your item gains or loses the keyboard grab through other means than gaining input focus.</source>
          <target state="translated">当某项获得键盘抓取时，它将收到&lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent :: GrabKeyboard&lt;/a&gt;事件。当失去键盘抓取功能时，它将收到&lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent :: UngrabKeyboard&lt;/a&gt;事件。这些事件可用于通过获取输入焦点以外的其他方式检测您的项目何时获得或失去键盘控制权。</target>
        </trans-unit>
        <trans-unit id="64c535dc14ed7e2aa62d21df9de2e71bdefba665" translate="yes" xml:space="preserve">
          <source>When an item gains the mouse grab, it receives a &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::GrabMouse&lt;/a&gt; event. When it loses the mouse grab, it receives a &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::UngrabMouse&lt;/a&gt; event. These events can be used to detect when your item gains or loses the mouse grab through other means than receiving mouse button events.</source>
          <target state="translated">当某项获得鼠标抓取时，它将收到&lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent :: GrabMouse&lt;/a&gt;事件。当失去鼠标抓取功能时，它将收到&lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent :: UngrabMouse&lt;/a&gt;事件。这些事件可用于通过接收鼠标按钮事件以外的其他方式检测您的物品何时获得或失去鼠标抓取。</target>
        </trans-unit>
        <trans-unit id="6f8dc2c7ef923f949343da800eb159af2c1dde1c" translate="yes" xml:space="preserve">
          <source>When an item in an item view is selected, also highlight the branch or other decoration.</source>
          <target state="translated">当项目视图中的项目被选中时,也要高亮显示分支或其他装饰。</target>
        </trans-unit>
        <trans-unit id="fcc2ea9c9f7cae3dd849abe3ca69b4158eef37eb" translate="yes" xml:space="preserve">
          <source>When an item is disabled, it is not possible to trigger it through its &lt;a href=&quot;qml-qt-labs-platform-menuitem#shortcut-prop&quot;&gt;shortcut&lt;/a&gt;.</source>
          <target state="translated">禁用某个项目后，将无法通过其&lt;a href=&quot;qml-qt-labs-platform-menuitem#shortcut-prop&quot;&gt;快捷方式&lt;/a&gt;触发它。</target>
        </trans-unit>
        <trans-unit id="452a0cf012b3cb9c186457a25f7cb1b1b7718e16" translate="yes" xml:space="preserve">
          <source>When an item is editable (and enabled), the user can edit the item by invoking one of the view's edit triggers; see &lt;a href=&quot;qabstractitemview#editTriggers-prop&quot;&gt;QAbstractItemView::editTriggers&lt;/a&gt;.</source>
          <target state="translated">当一个项目是可编辑的（并且已启用）时，用户可以通过调用视图的编辑触发器之一来编辑该项目。参见&lt;a href=&quot;qabstractitemview#editTriggers-prop&quot;&gt;QAbstractItemView :: editTriggers&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="53f7062365ff27f397c1a00527a4d2f3130aae95" translate="yes" xml:space="preserve">
          <source>When an item is enabled, the user can interact with it. The possible types of interaction are specified by the other item flags, such as &lt;a href=&quot;qstandarditem#isEditable&quot;&gt;isEditable&lt;/a&gt;() and &lt;a href=&quot;qstandarditem#isSelectable&quot;&gt;isSelectable&lt;/a&gt;().</source>
          <target state="translated">启用项目后，用户可以与其进行交互。交互的可能类型由其他项标志指定，例如&lt;a href=&quot;qstandarditem#isEditable&quot;&gt;isEditable&lt;/a&gt;（）和&lt;a href=&quot;qstandarditem#isSelectable&quot;&gt;isSelectable&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="cc78ed51b3f4dd69fbf5c809ac07b2202ac93036" translate="yes" xml:space="preserve">
          <source>When an item is flicked out, it moves to the</source>
          <target state="translated">当一个物品被弹出时,它就会移动到下面的</target>
        </trans-unit>
        <trans-unit id="edf649890497fe5584e977a2ddf9e845a6d9adbb" translate="yes" xml:space="preserve">
          <source>When an item's layer is enabled, the scene graph will allocate memory in the GPU equal to &lt;code&gt;width x height x 4&lt;/code&gt;. In memory constrained configurations, large layers should be used with care.</source>
          <target state="translated">启用项目的图层时，场景图将在GPU中分配等于 &lt;code&gt;width x height x 4&lt;/code&gt; 的内存。在内存受限的配置中，应谨慎使用大层。</target>
        </trans-unit>
        <trans-unit id="01223f794ced4ae7d5d61d347c9ab920ed50ad46" translate="yes" xml:space="preserve">
          <source>When an object is deleted, it emits a &lt;a href=&quot;qobject#destroyed&quot;&gt;destroyed&lt;/a&gt;() signal. You can catch this signal to avoid dangling references to QObjects.</source>
          <target state="translated">删除对象后，它将发出一个&lt;a href=&quot;qobject#destroyed&quot;&gt;destroy&lt;/a&gt;（）信号。您可以捕获此信号，以避免悬挂引用QObjects。</target>
        </trans-unit>
        <trans-unit id="b5486876fa77fcc351c0468b0f817e3d9df8a75d" translate="yes" xml:space="preserve">
          <source>When and whether you actually</source>
          <target state="translated">你何时以及是否真的</target>
        </trans-unit>
        <trans-unit id="9d01348a9aece3a4b6e828d26241b1bbac417b30" translate="yes" xml:space="preserve">
          <source>When animations are used to assign properties, a state no longer defines the exact values that a property will have when the machine is in the given state. While the animation is running, the property can potentially have any value, depending on the animation.</source>
          <target state="translated">当动画用于分配属性时,当机器处于给定状态时,一个状态不再定义属性的确切值。当动画运行时,属性有可能具有任何值,这取决于动画。</target>
        </trans-unit>
        <trans-unit id="e2fc21797749a0f52070944bd489489ff6abab01" translate="yes" xml:space="preserve">
          <source>When any item is added, moved or removed within the above view, the items below it are displaced, causing them to move down (or sideways, if horizontally orientated) within the view. As this displacement occurs, the items' movement to their new x,y positions within the view will be animated by a &lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation&lt;/a&gt; over one second, as specified.</source>
          <target state="translated">在上视图中添加，移动或删除任何项目时，其下方的项目都会移动，从而导致它们在视图内向下移动（或横向移动，如果水平放置）。当发生这种位移时，&lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;将按NumberAnimation&lt;/a&gt;在指定的时间内在一秒钟内将项目移动到视图中新的x，y位置的动画。</target>
        </trans-unit>
        <trans-unit id="6ad254e9576e1f6e7ddb5f7d88c66a573a0635ac" translate="yes" xml:space="preserve">
          <source>When any of the states is entered, the label's text will be changed accordingly.</source>
          <target state="translated">当输入任何一个状态时,标签的文字也会相应改变。</target>
        </trans-unit>
        <trans-unit id="92871574343d3169789071570bca986c9cf96ef4" translate="yes" xml:space="preserve">
          <source>When any of these are needed, the Connections type can be used instead.</source>
          <target state="translated">当需要这些类型时,可以使用连接类型代替。</target>
        </trans-unit>
        <trans-unit id="684810257cd0aed1db1716426f1de0a6c11c6d93" translate="yes" xml:space="preserve">
          <source>When any visible part of the scene changes or is reexposed, &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; will update the entire viewport. This approach is fastest when &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; spends more time figuring out what to draw than it would spend drawing (e.g., when very many small items are repeatedly updated). This is the preferred update mode for viewports that do not support partial updates, such as &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt;, and for viewports that need to disable scroll optimization.</source>
          <target state="translated">当场景的任何可见部分发生更改或重新曝光时，&lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt;将更新整个视口。当&lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt;用更多的时间来确定要绘制的内容时，这种方法是最快的（例如，当许多小物件被重复更新时）。对于不支持部分更新的视口（例如&lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt;）以及需要禁用滚动优化的视口，这是首选的更新模式。</target>
        </trans-unit>
        <trans-unit id="217cf31f7ecab879e6aeaf0c5c92b52eaff625db" translate="yes" xml:space="preserve">
          <source>When any visible part of the scene changes or is reexposed, &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; will update the entire viewport. This approach is fastest when &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; spends more time figuring out what to draw than it would spend drawing (e.g., when very many small items are repeatedly updated). This is the preferred update mode for viewports that do not support partial updates, such as QGLWidget, and for viewports that need to disable scroll optimization.</source>
          <target state="translated">当场景的任何可见部分发生更改或重新曝光时，&lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt;将更新整个视口。当&lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt;花更多的时间来确定要绘制的内容时，这种方法是最快的（例如，当很多小物件被重复更新时）。对于不支持部分更新的视口（例如QGLWidget）以及需要禁用滚动优化的视口，这是首选的更新模式。</target>
        </trans-unit>
        <trans-unit id="06d3ae994a8edf1ab3ef099d6fd125e756542e75" translate="yes" xml:space="preserve">
          <source>When any visible part of the scene changes or is reexposed, &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; will update the entire viewport. This approach is fastest when &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; spends more time figuring out what to draw than it would spend drawing (e.g., when very many small items are repeatedly updated). This is the preferred update mode for viewports that do not support partial updates, such as QOpenGLWidget, and for viewports that need to disable scroll optimization.</source>
          <target state="translated">当场景的任何可见部分发生更改或重新曝光时，&lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt;将更新整个视口。当&lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt;用更多的时间来确定要绘制的内容时，这种方法是最快的（例如，当许多小物件被重复更新时）。对于不支持部分更新的视口（例如QOpenGLWidget）以及需要禁用滚动优化的视口，这是首选的更新模式。</target>
        </trans-unit>
        <trans-unit id="a06bc6d7390ca623b0217a85f5d3800a53cff310" translate="yes" xml:space="preserve">
          <source>When applying &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-effects-topic.html#opacity&quot;&gt;opacity&lt;/a&gt; to an item hierarchy the opacity is applied to each item individually. This can lead to undesired visual results when the opacity is applied to a subtree. Consider the following example:</source>
          <target state="translated">将&lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-effects-topic.html#opacity&quot;&gt;不透明度&lt;/a&gt;应用于项目层次结构时，不透明度将分别应用于每个项目。当不透明度应用于子树时，这可能导致不希望的视觉结果。考虑以下示例：</target>
        </trans-unit>
        <trans-unit id="5a74e7e50f43c1fdec3974065e7b6a9d890d2418" translate="yes" xml:space="preserve">
          <source>When applying &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtquick-effects-topic.html#opacity&quot;&gt;opacity&lt;/a&gt; to an item hierarchy the opacity is applied to each item individually. This can lead to undesired visual results when the opacity is applied to a subtree. Consider the following example:</source>
          <target state="translated">将&lt;a href=&quot;https://doc.qt.io/qt-5.15/qtquick-effects-topic.html#opacity&quot;&gt;不透明度&lt;/a&gt;应用于项目层次结构时，不透明度将分别应用于每个项目。当不透明度应用于子树时，这可能导致不希望的视觉结果。考虑以下示例：</target>
        </trans-unit>
        <trans-unit id="78679de72c9d4b1f3d2b134f2faa28f329cfbb7a" translate="yes" xml:space="preserve">
          <source>When applying &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtquick-effects-topic.html#opacity&quot;&gt;opacity&lt;/a&gt; to an item hierarchy the opacity is applied to each item individually. This can lead to undesired visual results when the opacity is applied to a subtree. Consider the following example:</source>
          <target state="translated">将&lt;a href=&quot;https://doc.qt.io/qt-6.0/qtquick-effects-topic.html#opacity&quot;&gt;不透明度&lt;/a&gt;应用于项目层次结构时，不透明度将分别应用于每个项目。当不透明度应用于子树时，这可能导致不希望的视觉结果。考虑以下示例：</target>
        </trans-unit>
        <trans-unit id="03f4da2f8d439defdd9e3b555f171b3b3c94fa9c" translate="yes" xml:space="preserve">
          <source>When applying a clip to a subtree, that subtree needs to be rendered with a unique OpenGL state. This means that when &lt;a href=&quot;qml-qtquick-item#clip-prop&quot;&gt;Item::clip&lt;/a&gt; is true, batching of that item is limited to its children. When there are many children, like a &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-gridview&quot;&gt;GridView&lt;/a&gt;, or complex children, like a &lt;a href=&quot;qml-qtquick-controls-textarea&quot;&gt;TextArea&lt;/a&gt;, this is fine. One should, however, use clip on smaller items with caution as it prevents batching. This includes button label, text field or list delegate and table cells.</source>
          <target state="translated">将剪辑应用于子树时，该子树需要使用唯一的OpenGL状态进行渲染。这意味着当&lt;a href=&quot;qml-qtquick-item#clip-prop&quot;&gt;Item :: clip&lt;/a&gt;为true时，该项目的批处理仅限于其子项目。当有许多子级（例如&lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt;或&lt;a href=&quot;qml-qtquick-gridview&quot;&gt;GridView&lt;/a&gt;）或复杂子级（例如&lt;a href=&quot;qml-qtquick-controls-textarea&quot;&gt;TextArea）时&lt;/a&gt;，这很好。但是，应谨慎使用较小的物品，因为它会阻止批量生产。这包括按钮标签，文本字段或列表委托和表单元格。</target>
        </trans-unit>
        <trans-unit id="74f4063795ab227fe7ae24a79df545f1ccc36474" translate="yes" xml:space="preserve">
          <source>When applying a clip to a subtree, that subtree needs to be rendered with a unique OpenGL state. This means that when &lt;a href=&quot;qml-qtquick-item#clip-prop&quot;&gt;Item::clip&lt;/a&gt; is true, batching of that item is limited to its children. When there are many children, like a &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-gridview&quot;&gt;GridView&lt;/a&gt;, or complex children, like a &lt;a href=&quot;qml-qtquick-controls2-textarea&quot;&gt;TextArea&lt;/a&gt;, this is fine. One should, however, use clip on smaller items with caution as it prevents batching. This includes button label, text field or list delegate and table cells.</source>
          <target state="translated">将剪辑应用于子树时，需要使用唯一的OpenGL状态来渲染该子树。这意味着当&lt;a href=&quot;qml-qtquick-item#clip-prop&quot;&gt;Item :: clip&lt;/a&gt;为true时，该项目的批处理仅限于其子级。当有许多子级（例如&lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt;或&lt;a href=&quot;qml-qtquick-gridview&quot;&gt;GridView&lt;/a&gt;）或复杂的子级（例如&lt;a href=&quot;qml-qtquick-controls2-textarea&quot;&gt;TextArea）时&lt;/a&gt;，这很好。但是，应避免在较小的物品上使用夹子，因为它会阻止批量生产。这包括按钮标签，文本字段或列表委托和表格单元格。</target>
        </trans-unit>
        <trans-unit id="b46cb236869034e639f5c98ef59e6e0dc79b743e" translate="yes" xml:space="preserve">
          <source>When assigning values to properties in QML, any layouting the item must do as a result of the assignment might not take effect immediately, but can instead be postponed until the item is polished. For these cases, you can use this function to ensure that the item has been polished before the execution of the test continues. For example:</source>
          <target state="translated">当给QML中的属性赋值时,任何因赋值而必须对项目进行的布局可能不会立即生效,而是可以推迟到项目被打磨完毕。对于这些情况,你可以使用这个函数来确保在继续执行测试之前,项目已经被抛光。例如</target>
        </trans-unit>
        <trans-unit id="9aade8d1fb980c82f7d60913e871590165c272dc" translate="yes" xml:space="preserve">
          <source>When asynchronous is true the Instantiator will attempt to create objects asynchronously. This means that objects may not be available immediately, even if active is set to true.</source>
          <target state="translated">当asynchronous为true时,Instantiator将尝试异步创建对象。这意味着,即使将active设置为true,对象也可能不会立即可用。</target>
        </trans-unit>
        <trans-unit id="ed095d8711f54124e3343d3e3564a7eefda4e48d" translate="yes" xml:space="preserve">
          <source>When atEnd() and &lt;a href=&quot;qxmlstreamreader#hasError&quot;&gt;hasError&lt;/a&gt;() return true and &lt;a href=&quot;qxmlstreamreader#error&quot;&gt;error&lt;/a&gt;() returns &lt;a href=&quot;qxmlstreamreader#Error-enum&quot;&gt;PrematureEndOfDocumentError&lt;/a&gt;, it means the XML has been well-formed so far, but a complete XML document has not been parsed. The next chunk of XML can be added with &lt;a href=&quot;qxmlstreamreader#addData&quot;&gt;addData&lt;/a&gt;(), if the XML is being read from a &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt;, or by waiting for more data to arrive if the XML is being read from a &lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt;. Either way, atEnd() will return false once more data is available.</source>
          <target state="translated">当atEnd（）和&lt;a href=&quot;qxmlstreamreader#hasError&quot;&gt;hasError&lt;/a&gt;（）返回true且&lt;a href=&quot;qxmlstreamreader#error&quot;&gt;error&lt;/a&gt;（）返回&lt;a href=&quot;qxmlstreamreader#Error-enum&quot;&gt;PrematureEndOfDocumentError时&lt;/a&gt;，这表示XML到目前为止格式正确，但是尚未解析完整的XML文档。如果正在从&lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt;读取XML，则可以使用&lt;a href=&quot;qxmlstreamreader#addData&quot;&gt;addData&lt;/a&gt;（）添加下一个XML块，或者如果正在从&lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt;读取XML，则可以等待更多数据到达。无论哪种方式，一旦有更多数据可用，atEnd（）都将返回false。</target>
        </trans-unit>
        <trans-unit id="b3157310c43a1e88b9499e85e194d29092d5e110" translate="yes" xml:space="preserve">
          <source>When automatically registering QML types defined in C++, register an additional version of the module using this minor version. Generally, minor versions to be registered are inferred from the meta objects.</source>
          <target state="translated">当自动注册C++中定义的QML类型时,使用这个次要版本注册模块的附加版本。一般来说,要注册的次要版本是从元对象中推断出来的。</target>
        </trans-unit>
        <trans-unit id="769b89390fbaab8a30caa729005e13bd89dd70b2" translate="yes" xml:space="preserve">
          <source>When both the &lt;a href=&quot;qml-qtpurchasing-product#identifier-prop&quot;&gt;identifier&lt;/a&gt; and type is set, the product is queried from the external market place, and its other properties are updated asynchronously. At this point, the identifier and type can no longer be changed.</source>
          <target state="translated">当同时设置了&lt;a href=&quot;qml-qtpurchasing-product#identifier-prop&quot;&gt;标识符&lt;/a&gt;和类型时，将从外部市场查询产品，并异步更新其其他属性。此时，标识符和类型不能再更改。</target>
        </trans-unit>
        <trans-unit id="e66ead871376ec31f6b0bdabc0d22f6168fd30da" translate="yes" xml:space="preserve">
          <source>When both the identifier and &lt;a href=&quot;qml-qtpurchasing-product#type-prop&quot;&gt;type&lt;/a&gt; is set, the product is queried from the external market place, and its other properties are updated asynchronously. At this point, the identifier and type can no longer be changed.</source>
          <target state="translated">当同时设置了标识符和&lt;a href=&quot;qml-qtpurchasing-product#type-prop&quot;&gt;类型时&lt;/a&gt;，将从外部市场查询产品，并异步更新其其他属性。此时，标识符和类型不能再更改。</target>
        </trans-unit>
        <trans-unit id="a77db60a6597f85a3430717a9225f81f9e8efd43" translate="yes" xml:space="preserve">
          <source>When building Qt from source, the configuration system checks for the presence of the &lt;code&gt;openssl/opensslv.h&lt;/code&gt; header provided by source or developer packages of OpenSSL.</source>
          <target state="translated">从源代码构建Qt时，配置系统检查是否存在由 &lt;code&gt;openssl/opensslv.h&lt;/code&gt; 的源代码或开发人员软件包提供的openssl / opensslv.h标头。</target>
        </trans-unit>
        <trans-unit id="481f920a35be00bb71b2fc213b17ba321c9ce91c" translate="yes" xml:space="preserve">
          <source>When building a list or a tree that has only one column, this function provides a convenient way to append a single new</source>
          <target state="translated">当建立一个只有一列的列表或树时,这个函数提供了一个方便的方法来附加一个新的列。</target>
        </trans-unit>
        <trans-unit id="f4d252c2c2fbed789c886d3ea6d5aac266ab2c26" translate="yes" xml:space="preserve">
          <source>When building a list or a tree that has only one column, this function provides a convenient way to append a single new item.</source>
          <target state="translated">当建立一个只有一列的列表或树时,这个函数提供了一个方便的方法来追加一个新项目。</target>
        </trans-unit>
        <trans-unit id="c2ec3d7c6f7c3543ad312c99f702307e4ac89f3b" translate="yes" xml:space="preserve">
          <source>When building a list or a tree that has only one column, this function provides a convenient way to insert a single new item.</source>
          <target state="translated">当建立一个只有一列的列表或树时,这个函数提供了一个方便的方法来插入一个新项目。</target>
        </trans-unit>
        <trans-unit id="c58a8be8048f77481eaaa01a5f80fa127a65c9b2" translate="yes" xml:space="preserve">
          <source>When building a version of Qt linked against OpenSSL, Qt's build system will use CMake's &lt;code&gt;FindOpenSSL&lt;/code&gt; command to find OpenSSL in several standard locations. You can set the CMake variable OPENSSL_ROOT_DIR to force a specific location.</source>
          <target state="translated">当构建与OpenSSL链接的Qt版本时，Qt的构建系统将使用CMake的 &lt;code&gt;FindOpenSSL&lt;/code&gt; 命令在几个标准位置中查找OpenSSL。您可以将CMake变量OPENSSL_ROOT_DIR设置为强制指定位置。</target>
        </trans-unit>
        <trans-unit id="6c09737d74d2162e6fdbbf52bfd0b26549723d50" translate="yes" xml:space="preserve">
          <source>When building a version of Qt linked against OpenSSL, the build system will attempt to link with libssl and libcrypt libraries located in the default location on the developer's system. This location is configurable: set the &lt;code&gt;OPENSSL_LIBS&lt;/code&gt; environment variable to contain the linker options required to link Qt against the installed library. For example, on a Unix/Linux system:</source>
          <target state="translated">在构建与OpenSSL链接的Qt版本时，构建系统将尝试与位于开发人员系统默认位置的libssl和libcrypt库进行链接。此位置是可配置的：设置 &lt;code&gt;OPENSSL_LIBS&lt;/code&gt; 环境变量以包含将Qt与已安装的库链接所需的链接器选项。例如，在Unix / Linux系统上：</target>
        </trans-unit>
        <trans-unit id="c9861e5ecd8580ac9329bf8a380f56f7c6afce34" translate="yes" xml:space="preserve">
          <source>When building from source, ensure that the</source>
          <target state="translated">当从源头构建时,确保</target>
        </trans-unit>
        <trans-unit id="62819592f1c6df3a87bed54e97d13fd158256db9" translate="yes" xml:space="preserve">
          <source>When building from source, ensure that the &lt;a href=&quot;qtgraphicaleffects-index&quot;&gt;Qt Graphical Effects&lt;/a&gt; module is also built, as Qt Quick Controls 2 requires it.</source>
          <target state="translated">从源代码构建时，请确保也构建了&lt;a href=&quot;qtgraphicaleffects-index&quot;&gt;Qt图形效果&lt;/a&gt;模块，这是Qt Quick Controls 2所要求的。</target>
        </trans-unit>
        <trans-unit id="d0d5ad78ee0d3c591ef53c8a838b7b5e7736a74d" translate="yes" xml:space="preserve">
          <source>When building from source, ensure that the &lt;a href=&quot;qtgraphicaleffects-index&quot;&gt;Qt Graphical Effects&lt;/a&gt; module is also built, as Qt Quick Controls requires it.</source>
          <target state="translated">从源代码构建时，请确保还构建了&lt;a href=&quot;qtgraphicaleffects-index&quot;&gt;Qt图形效果&lt;/a&gt;模块，这是Qt Quick Controls要求的。</target>
        </trans-unit>
        <trans-unit id="7dbc1546897b44a424c69bc67e3cb704ad96c53a" translate="yes" xml:space="preserve">
          <source>When building from source, ensure that the modules and tools from the</source>
          <target state="translated">当从源码中构建时,确保模块和工具从</target>
        </trans-unit>
        <trans-unit id="7251f805a1544f17a9559e9785d85be1aae09528" translate="yes" xml:space="preserve">
          <source>When building user interfaces with the &lt;a href=&quot;qtquick-index&quot;&gt;Qt Quick&lt;/a&gt; module, all QML objects that are to be visually rendered must derive from the &lt;a href=&quot;qml-qtquick-item&quot;&gt;Item&lt;/a&gt; type, as it is the base type for all visual objects in &lt;a href=&quot;qtquick-index&quot;&gt;Qt Quick&lt;/a&gt;. This &lt;a href=&quot;qml-qtquick-item&quot;&gt;Item&lt;/a&gt; type is implemented by the &lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt; C++ class, which is provided by the &lt;a href=&quot;qtquick-index&quot;&gt;Qt Quick&lt;/a&gt; module. Therefore, this class should be subclassed when it is necessary to implement a visual type in C++ that can be integrated into a QML-based user interface.</source>
          <target state="translated">使用&lt;a href=&quot;qtquick-index&quot;&gt;Qt Quick&lt;/a&gt;模块构建用户界面时，所有要可视化呈现的QML对象必须派生自&lt;a href=&quot;qml-qtquick-item&quot;&gt;Item&lt;/a&gt;类型，因为它是&lt;a href=&quot;qtquick-index&quot;&gt;Qt Quick中&lt;/a&gt;所有可视对象的基本类型。此&lt;a href=&quot;qml-qtquick-item&quot;&gt;Item&lt;/a&gt;类型由&lt;a href=&quot;qtquick-index&quot;&gt;Qt Quick&lt;/a&gt;模块提供的&lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt; C ++类实现。因此，当有必要在C ++中实现可集成到基于QML的用户界面中的可视类型时，应将该类作为子类。</target>
        </trans-unit>
        <trans-unit id="573536b41f02e737bb17c87ec630c4949eebe25a" translate="yes" xml:space="preserve">
          <source>When built, the Qt Image Formats plugins are located as dynamic libraries in the runtime plugin directory (typically &lt;code&gt;plugins/imageformats&lt;/code&gt;), together with the default image format plugins. They may be deployed to the target system in the same way as other plugins, see the &lt;a href=&quot;https://doc.qt.io/qt-5.13/deployment-plugins.html&quot;&gt;Deploying Plugins&lt;/a&gt; documentation.</source>
          <target state="translated">构建后，Qt图像格式插件与动态库一起位于运行时插件目录（通常是 &lt;code&gt;plugins/imageformats&lt;/code&gt; ）中，同时还包含默认图像格式插件。可以按照与其他插件相同的方式将它们部署到目标系统，请参阅&amp;ldquo; &lt;a href=&quot;https://doc.qt.io/qt-5.13/deployment-plugins.html&quot;&gt;部署插件&amp;rdquo;&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="1e398ca745e5b7e0d76604dae601be679e6ea3ec" translate="yes" xml:space="preserve">
          <source>When built, the Qt Image Formats plugins are located as dynamic libraries in the runtime plugin directory (typically &lt;code&gt;plugins/imageformats&lt;/code&gt;), together with the default image format plugins. They may be deployed to the target system in the same way as other plugins, see the &lt;a href=&quot;https://doc.qt.io/qt-5.15/deployment-plugins.html&quot;&gt;Deploying Plugins&lt;/a&gt; documentation.</source>
          <target state="translated">生成后，Qt图像格式插件与动态库一起位于运行时插件目录（通常是 &lt;code&gt;plugins/imageformats&lt;/code&gt; ）中，同时还包含默认图像格式插件。可以按照与其他插件相同的方式将它们部署到目标系统，请参阅&amp;ldquo;&lt;a href=&quot;https://doc.qt.io/qt-5.15/deployment-plugins.html&quot;&gt;部署插件&amp;rdquo;&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="c262fdab9d5bbc4800f05d4b19c4606922c93521" translate="yes" xml:space="preserve">
          <source>When built, the Qt Image Formats plugins are located as dynamic libraries in the runtime plugin directory (typically &lt;code&gt;plugins/imageformats&lt;/code&gt;), together with the default image format plugins. They may be deployed to the target system in the same way as other plugins, see the &lt;a href=&quot;https://doc.qt.io/qt-6.0/deployment-plugins.html&quot;&gt;Deploying Plugins&lt;/a&gt; documentation.</source>
          <target state="translated">生成后，Qt图像格式插件与动态库一起位于运行时插件目录（通常是 &lt;code&gt;plugins/imageformats&lt;/code&gt; ）中，同时还包含默认图像格式插件。可以按照与其他插件相同的方式将它们部署到目标系统，请参阅&amp;ldquo;&lt;a href=&quot;https://doc.qt.io/qt-6.0/deployment-plugins.html&quot;&gt;部署插件&amp;rdquo;&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="85c65eea35b46ad9adc8aa9df7e19d248494566d" translate="yes" xml:space="preserve">
          <source>When caching is enabled, &lt;a href=&quot;qfileinfo&quot;&gt;QFileInfo&lt;/a&gt; reads the file information from the file system the first time it's needed, but generally not later.</source>
          <target state="translated">启用缓存后，&lt;a href=&quot;qfileinfo&quot;&gt;QFileInfo&lt;/a&gt;会在第一次需要时从文件系统中读取文件信息，但通常不会在以后。</target>
        </trans-unit>
        <trans-unit id="63f929311e0c136280261b1674d609c45952f607" translate="yes" xml:space="preserve">
          <source>When caching is enabled, an item's &lt;a href=&quot;qgraphicsitem#paint&quot;&gt;paint&lt;/a&gt;() function will generally draw into an offscreen pixmap cache; for any subsequent repaint requests, the Graphics View framework will redraw from the cache. This approach works particularly well with QGLWidget, which stores all the cache as OpenGL textures.</source>
          <target state="translated">启用缓存后，项目的&lt;a href=&quot;qgraphicsitem#paint&quot;&gt;paint&lt;/a&gt;（）函数通常会绘制到屏幕外的像素图缓存中；对于任何后续的重画请求，Graphics View框架将从缓存中重画。这种方法特别适用于QGLWidget，后者将所有缓存存储为OpenGL纹理。</target>
        </trans-unit>
        <trans-unit id="49d3402980e692757da4d25c7f056cfbcbc4090c" translate="yes" xml:space="preserve">
          <source>When calculating the size hint, &lt;a href=&quot;qgroupbox&quot;&gt;QGroupBox&lt;/a&gt; fetches three pixel metrics from the style: &lt;code&gt;PM_IndicatorWidth&lt;/code&gt;, &lt;code&gt;PM_CheckBoxLabelSpacing&lt;/code&gt;, and &lt;code&gt;PM_IndicatorHeight&lt;/code&gt;. &lt;a href=&quot;qgroupbox&quot;&gt;QGroupBox&lt;/a&gt; has the following style element tree:</source>
          <target state="translated">在计算大小提示时，&lt;a href=&quot;qgroupbox&quot;&gt;QGroupBox&lt;/a&gt;从样式中获取三个像素度量： &lt;code&gt;PM_IndicatorWidth&lt;/code&gt; ， &lt;code&gt;PM_CheckBoxLabelSpacing&lt;/code&gt; 和 &lt;code&gt;PM_IndicatorHeight&lt;/code&gt; 。&lt;a href=&quot;qgroupbox&quot;&gt;QGroupBox&lt;/a&gt;具有以下样式元素树：</target>
        </trans-unit>
        <trans-unit id="21b955b352a198452eb600dee09c98ed26feb22d" translate="yes" xml:space="preserve">
          <source>When calculating the slider's size hint, &lt;code&gt;PM_SliderThickness&lt;/code&gt; and &lt;code&gt;PM_SliderLength&lt;/code&gt; are queried from the style. As with scroll bars, the &lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt; only lets the user move the handle if the mouse is within &lt;code&gt;PM_MaximumDragDistance&lt;/code&gt; from the slider bounds. When it draws itself, it creates the style option and calls &lt;code&gt;drawComplexControl()&lt;/code&gt; with &lt;code&gt;CC_Slider&lt;/code&gt;:</source>
          <target state="translated">在计算滑块的大小提示时， &lt;code&gt;PM_SliderThickness&lt;/code&gt; &lt;code&gt;PM_SliderLength&lt;/code&gt; 中查询PM_SliderThickness和PM_SliderLength。与滚动条一样，如果鼠标位于滑块边界的 &lt;code&gt;PM_MaximumDragDistance&lt;/code&gt; 内，则&lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt;仅允许用户移动手柄。绘制自身时，它将创建样式选项，并使用 &lt;code&gt;CC_Slider&lt;/code&gt; 调用 &lt;code&gt;drawComplexControl()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1d40ba7fa0fde8f8ba84bf5f3be3928589a792a0" translate="yes" xml:space="preserve">
          <source>When called as a constructor, a new instance of the class will be created. Only constructors exposed by &lt;a href=&quot;qobject#Q_INVOKABLE&quot;&gt;Q_INVOKABLE&lt;/a&gt; will be visible from the script engine.</source>
          <target state="translated">当作为构造函数调用时，将创建该类的新实例。在脚本引擎中，只有&lt;a href=&quot;qobject#Q_INVOKABLE&quot;&gt;Q_INVOKABLE&lt;/a&gt;公开的构造函数可见。</target>
        </trans-unit>
        <trans-unit id="1a17521f28b13cf15c64f48b6b71bf71a004d243" translate="yes" xml:space="preserve">
          <source>When called by Qt,</source>
          <target state="translated">当被Qt调用时。</target>
        </trans-unit>
        <trans-unit id="f924cfbead8cb8e42622d4f7e73c2c8531c825b9" translate="yes" xml:space="preserve">
          <source>When calling &lt;a href=&quot;qquickwindow#releaseResources&quot;&gt;releaseResources&lt;/a&gt;(), or when the window gets hidden (more specifically, not renderable), some render loops have the possibility to release all, not just the cached, graphics resources. This can free up memory temporarily, but it also means the rendering engine will have to do a full, potentially costly reinitialization of the resources when the window needs to render again.</source>
          <target state="translated">当调用&lt;a href=&quot;qquickwindow#releaseResources&quot;&gt;releaseResources&lt;/a&gt;（）或窗口被隐藏（更具体地说，不可渲染）时，某些渲染循环可以释放所有资源，而不仅仅是释放缓存的图形资源。这样可以暂时释放内存，但是这也意味着当窗口需要再次渲染时，渲染引擎将不得不对资源进行完整的，潜在的昂贵的重新初始化。</target>
        </trans-unit>
        <trans-unit id="1f97347d6c83c0d6afe15b4ae0af8fee46e568aa" translate="yes" xml:space="preserve">
          <source>When calling &lt;a href=&quot;qquickwindow#releaseResources&quot;&gt;releaseResources&lt;/a&gt;(), when the window gets hidden (more specifically, not renderable), some render loops have the possibility to release the scene graph nodes and related graphics resources. This frees up memory temporarily, but will also mean the scene graph has to be rebuilt when the window renders next time.</source>
          <target state="translated">当调用&lt;a href=&quot;qquickwindow#releaseResources&quot;&gt;releaseResources&lt;/a&gt;（）时，当窗口被隐藏（更具体地说，不可渲染）时，某些渲染循环可能会释放场景图节点和相关的图形资源。这会暂时释放内存，但是这也意味着在下次渲染窗口时必须重新构建场景图。</target>
        </trans-unit>
        <trans-unit id="914ad22810e57e0a208c0b39ab77807e77834ddd" translate="yes" xml:space="preserve">
          <source>When calling Java functions that might throw an exception, it is important that you check, handle and clear out the exception before continuing.</source>
          <target state="translated">在调用可能会抛出异常的Java函数时,在继续调用之前,必须先检查、处理和清除异常。</target>
        </trans-unit>
        <trans-unit id="2a2e7ae65f87e90c76479fdc5ff2e4326b27c302" translate="yes" xml:space="preserve">
          <source>When calling this function, you can use the &lt;code&gt;SIGNAL()&lt;/code&gt; macro to pass a specific signal:</source>
          <target state="translated">调用此函数时，可以使用 &lt;code&gt;SIGNAL()&lt;/code&gt; 宏传递特定信号：</target>
        </trans-unit>
        <trans-unit id="16fd68ecc7c1ca2e0fddbce432b5a471d518bb57" translate="yes" xml:space="preserve">
          <source>When changing properties with values that may be defined within a resource file,</source>
          <target state="translated">当改变资源文件中可能定义的值的属性时。</target>
        </trans-unit>
        <trans-unit id="10172d955b561d851a1e685787b7d1f3cc20d57f" translate="yes" xml:space="preserve">
          <source>When changing the geometry, the widget, if visible, receives a move event (&lt;a href=&quot;qwidget#moveEvent&quot;&gt;moveEvent&lt;/a&gt;()) and/or a resize event (&lt;a href=&quot;qwidget#resizeEvent&quot;&gt;resizeEvent&lt;/a&gt;()) immediately. If the widget is not currently visible, it is guaranteed to receive appropriate events before it is shown.</source>
          <target state="translated">更改几何时，小部件（如果可见）会立即接收一个移动事件（&lt;a href=&quot;qwidget#moveEvent&quot;&gt;moveEvent&lt;/a&gt;（））和/或一个调整大小事件（&lt;a href=&quot;qwidget#resizeEvent&quot;&gt;resizeEvent&lt;/a&gt;（））。如果窗口小部件当前不可见，则可以确保在显示窗口小部件之前先接收适当的事件。</target>
        </trans-unit>
        <trans-unit id="3dcc6167c4c8ec1a522615dcd2a97bfd046a2f80" translate="yes" xml:space="preserve">
          <source>When changing the position, the widget, if visible, receives a move event (&lt;a href=&quot;qwidget#moveEvent&quot;&gt;moveEvent&lt;/a&gt;()) immediately. If the widget is not currently visible, it is guaranteed to receive an event before it is shown.</source>
          <target state="translated">更改位置时，小部件（如果可见）会立即接收一个移动事件（&lt;a href=&quot;qwidget#moveEvent&quot;&gt;moveEvent&lt;/a&gt;（））。如果该窗口小部件当前不可见，则可以保证在显示该事件之前会收到一个事件。</target>
        </trans-unit>
        <trans-unit id="d10e878de0de661440ee8d64ce4885521ddfa38a" translate="yes" xml:space="preserve">
          <source>When checking the signatures of its arguments, &lt;a href=&quot;qobject#connect&quot;&gt;QObject::connect&lt;/a&gt;() compares the data types literally. Thus, &lt;a href=&quot;qt#AlignmentFlag-enum&quot;&gt;Alignment&lt;/a&gt; and &lt;a href=&quot;qt#AlignmentFlag-enum&quot;&gt;Qt::Alignment&lt;/a&gt; are treated as two distinct types. To work around this limitation, make sure to fully qualify the data types when declaring signals and slots, and when establishing connections. For example:</source>
          <target state="translated">检查其参数的签名时，&lt;a href=&quot;qobject#connect&quot;&gt;QObject :: connect&lt;/a&gt;（）会按字面意义比较数据类型。因此，&lt;a href=&quot;qt#AlignmentFlag-enum&quot;&gt;Alignment&lt;/a&gt;和&lt;a href=&quot;qt#AlignmentFlag-enum&quot;&gt;Qt :: Alignment&lt;/a&gt;被视为两种不同的类型。要解决此限制，请确保在声明信号和插槽以及建立连接时完全限定数据类型。例如：</target>
        </trans-unit>
        <trans-unit id="6c76cad238f22ed5e500ffc1b09ea0553c302ab3" translate="yes" xml:space="preserve">
          <source>When choosing a widget to use as a placeholder, it is useful to compare the API of the missing widget with those of standard Qt widgets. For specialized widgets that subclass standard classes, the obvious choice of placeholder is the base class of the custom widget; for example, &lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt; might be used for specialized &lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt; subclasses.</source>
          <target state="translated">选择要用作占位符的小部件时，将丢失的小部件的API与标准Qt小部件的API进行比较非常有用。对于子类标准类的专用小部件，占位符的明显选择是自定义小部件的基类。例如，&lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt;可能用于专门的&lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt;子类。</target>
        </trans-unit>
        <trans-unit id="16d44be4536ee05b1e19ae36cfa871d577dd74c9" translate="yes" xml:space="preserve">
          <source>When client code handling the &lt;a href=&quot;qnetworkreply#redirected&quot;&gt;redirected&lt;/a&gt;() signal has verified the new URL, it emits this signal to allow the redirect to go ahead. This protocol applies to network requests whose redirects policy is set to &lt;a href=&quot;qnetworkrequest#RedirectPolicy-enum&quot;&gt;QNetworkRequest::UserVerifiedRedirectPolicy&lt;/a&gt;</source>
          <target state="translated">当处理&lt;a href=&quot;qnetworkreply#redirected&quot;&gt;redirected&lt;/a&gt;（）信号的客户端代码验证了新URL时，它将发出该信号以允许重定向继续进行。此协议适用于其重定向策略设置为&lt;a href=&quot;qnetworkrequest#RedirectPolicy-enum&quot;&gt;QNetworkRequest :: UserVerifiedRedirectPolicy的&lt;/a&gt;网络请求</target>
        </trans-unit>
        <trans-unit id="a496bd66ef281f3e102e4c15780975eb23b209d8" translate="yes" xml:space="preserve">
          <source>When combined with Subdirectories, this flag enables iterating through all subdirectories of the assigned path, following all symbolic links. Symbolic link loops (e.g., &quot;link&quot; =&amp;gt; &quot;.&quot; or &quot;link&quot; =&amp;gt; &quot;..&quot;) are automatically detected and ignored.</source>
          <target state="translated">当与子目录结合使用时，此标志允许在所有符号链接之后遍历分配路径的所有子目录。符号链接循环（例如，&amp;ldquo; link&amp;rdquo; =&amp;gt;&amp;ldquo;。&amp;rdquo;或&amp;ldquo; link&amp;rdquo; =&amp;gt;&amp;ldquo; ..&amp;rdquo;）将被自动检测并忽略。</target>
        </trans-unit>
        <trans-unit id="b152fe7b18bfb7ca1bd752cf950491f1cf2f642f" translate="yes" xml:space="preserve">
          <source>When communicating over a bus, applications obtain what is called a &quot;service name&quot;: it is how that application chooses to be known by other applications on the same bus. The service names are brokered by the D-Bus bus daemon and are used to route messages from one application to another. An analogous concept to service names are IP addresses and hostnames: a computer normally has one IP address and may have one or more hostnames associated with it, according to the services that it provides to the network.</source>
          <target state="translated">当在总线上通信时,应用程序会获得所谓的 &quot;服务名&quot;:它是该应用程序选择被同一总线上的其他应用程序所知的方式。服务名由D-Bus总线守护程序代理,用于将消息从一个应用程序路由到另一个应用程序。与服务名类似的概念是IP地址和主机名:一台计算机通常有一个IP地址,根据它向网络提供的服务,它可能有一个或多个主机名。</target>
        </trans-unit>
        <trans-unit id="2fa846a6fbf1d2acbf9baf6b25678819c4fcf27a" translate="yes" xml:space="preserve">
          <source>When compared to Qt Quick's 2D &lt;a href=&quot;qml-qtquick-shadereffect&quot;&gt;ShaderEffect&lt;/a&gt;, the 3D post-processing effects have the advantage of being able to work with depth buffer data, as well as the ability to implement multiple passes with intermediate buffers. In addition, the texture-related capabilities are extended: Qt Quick 3D allows more fine-grained control over filtering modes, and allows effects to work with texture formats other than RGBA8, for example, floating point formats.</source>
          <target state="translated">与Qt Quick的2D &lt;a href=&quot;qml-qtquick-shadereffect&quot;&gt;ShaderEffect相比&lt;/a&gt;，3D后处理效果具有能够处理深度缓冲区数据的优势，并具有使用中间缓冲区进行多次传递的能力。此外，还扩展了与纹理相关的功能：Qt Quick 3D允许对过滤模式进行更细粒度的控制，并允许效果与RGBA8以外的其他纹理格式一起使用，例如浮点格式。</target>
        </trans-unit>
        <trans-unit id="126be04937319506b64a5a64cc708426b1cfcb4c" translate="yes" xml:space="preserve">
          <source>When comparing &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt;, arrays and initializer lists of the value type can be passed as expected value:</source>
          <target state="translated">比较&lt;a href=&quot;qlist&quot;&gt;QList时&lt;/a&gt;，可以将值类型的数组和初始化程序列表作为预期值传递：</target>
        </trans-unit>
        <trans-unit id="504bd4b97e16da478eebaa7d208820d715529e5e" translate="yes" xml:space="preserve">
          <source>When comparing floating-point types (&lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, and &lt;code&gt;qfloat16&lt;/code&gt;), &lt;a href=&quot;qtglobal#qFuzzyCompare&quot;&gt;qFuzzyCompare&lt;/a&gt;() is used for finite values. If &lt;a href=&quot;qtglobal#qFuzzyIsNull&quot;&gt;qFuzzyIsNull&lt;/a&gt;() is true for both values, they are also considered equal. Infinities match if they have the same sign, and any NaN as actual value matches with any NaN as expected value (even though NaN != NaN, even when they're identical).</source>
          <target state="translated">比较浮点类型（ &lt;code&gt;float&lt;/code&gt; ， &lt;code&gt;double&lt;/code&gt; 和 &lt;code&gt;qfloat16&lt;/code&gt; ）时，&lt;a href=&quot;qtglobal#qFuzzyCompare&quot;&gt;qFuzzyCompare&lt;/a&gt;（）用于有限值。如果两个值的&lt;a href=&quot;qtglobal#qFuzzyIsNull&quot;&gt;qFuzzyIsNull&lt;/a&gt;（）为true，则它们也被视为相等。如果无穷大具有相同的符号，并且任何与实际值相同的NaN与任何与预期值相同的NaN匹配（即使NaN！= NaN，即使它们相同）也将匹配。</target>
        </trans-unit>
        <trans-unit id="4ae6fe5944e7f5e553d8111bc79c5d3e6ba7dace" translate="yes" xml:space="preserve">
          <source>When complete is &lt;code&gt;true&lt;/code&gt;, any interactive items declared in &lt;code&gt;left&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt;, or &lt;code&gt;behind&lt;/code&gt; will receive mouse events.</source>
          <target state="translated">当完全是 &lt;code&gt;true&lt;/code&gt; ，任何交互式项目宣布 &lt;code&gt;left&lt;/code&gt; ， &lt;code&gt;right&lt;/code&gt; ，或 &lt;code&gt;behind&lt;/code&gt; 将会收到鼠标事件。</target>
        </trans-unit>
        <trans-unit id="976e1921ad1ea5927a3b8bbd6237c76e52f7d321" translate="yes" xml:space="preserve">
          <source>When configured with &lt;code&gt;-opengl dynamic&lt;/code&gt;, neither Qt nor the applications built using &lt;code&gt;qmake&lt;/code&gt; or &lt;code&gt;CMake&lt;/code&gt; will link to opengl32.lib. Instead, the library is chosen and loaded at runtime. By default, Qt will determine whether the system's opengl32.dll provides OpenGL 2 functions. If these are present, opengl32.dll is used, otherwise it attempts to load &lt;code&gt;opengl32sw.dll&lt;/code&gt;. See below for details.</source>
          <target state="translated">当使用 &lt;code&gt;-opengl dynamic&lt;/code&gt; 配置时，Qt或使用 &lt;code&gt;qmake&lt;/code&gt; 或 &lt;code&gt;CMake&lt;/code&gt; 构建的应用程序都不会链接到opengl32.lib。而是在运行时选择并加载该库。默认情况下，Qt将确定​​系统的opengl32.dll是否提供OpenGL 2功能。如果存在这些文件，则使用opengl32.dll，否则它将尝试加载 &lt;code&gt;opengl32sw.dll&lt;/code&gt; 。有关详情，请参见下文。</target>
        </trans-unit>
        <trans-unit id="fbdde588f2333734eac7dbf667c998b588ec285f" translate="yes" xml:space="preserve">
          <source>When configured with &lt;code&gt;-opengl dynamic&lt;/code&gt;, neither Qt nor the applications built using &lt;code&gt;qmake&lt;/code&gt; will link to the opengl32 (standard desktop OpenGL) or QtANGLE libraries. Instead, the appropriate library is chosen at runtime. By default, Qt will determine whether the system's opengl32.dll provides OpenGL 2 functions. If these are present, opengl32.dll is used, otherwise the ANGLE libraries (libEGL.dll and libGLESv2.dll) will be used. In case the ANGLE libraries are missing or initialization fails for some reason, an additional fallback is attempted by trying to load &lt;code&gt;opengl32sw.dll&lt;/code&gt;. See below for details.</source>
          <target state="translated">当使用 &lt;code&gt;-opengl dynamic&lt;/code&gt; 配置时，Qt或使用 &lt;code&gt;qmake&lt;/code&gt; 构建的应用程序都不会链接到opengl32（标准桌面OpenGL）或QtANGLE库。而是在运行时选择适当的库。默认情况下，Qt将确定​​系统的opengl32.dll是否提供OpenGL 2功能。如果存在这些文件，则使用opengl32.dll，否则将使用ANGLE库（libEGL.dll和libGLESv2.dll）。如果ANGLE库丢失或由于某种原因初始化失败，则通过尝试加载 &lt;code&gt;opengl32sw.dll&lt;/code&gt; 来尝试其他回退。有关详情，请参见下文。</target>
        </trans-unit>
        <trans-unit id="c83d34a16b202ede327779ea8f89700f458b6d2a" translate="yes" xml:space="preserve">
          <source>When configuring, you can select a CMake generator. Note that CMake supports generators that cannot be used with Qt. Therefore, configure automatically selects a generator for you.</source>
          <target state="translated">配置时,你可以选择一个CMake生成器。注意 CMake 支持的生成器不能与 Qt 一起使用。因此,configure 会自动为你选择一个生成器。</target>
        </trans-unit>
        <trans-unit id="1731f47b651e66fd70df77e065cbada56a586326" translate="yes" xml:space="preserve">
          <source>When conflicts arise, the widget's own style sheet is always preferred to any inherited style sheet, irrespective of the specificity of the conflicting rules. Likewise, the parent widget's style sheet is preferred to the grandparent's, etc.</source>
          <target state="translated">当冲突发生时,无论冲突规则的具体性如何,小组件自己的样式表总是优先于任何继承的样式表。同样,父部件的样式表也比祖部件的样式表优先,等等。</target>
        </trans-unit>
        <trans-unit id="0ee6235e959f1c122804e1ee8f220bac499a0e14" translate="yes" xml:space="preserve">
          <source>When connecting to an ODBC datasource, you should pass the name of the ODBC datasource to the &lt;a href=&quot;qsqldatabase#setDatabaseName&quot;&gt;QSqlDatabase::setDatabaseName&lt;/a&gt;() function, rather than the actual database name.</source>
          <target state="translated">连接到ODBC数据源时，应将ODBC数据源的名称传递给&lt;a href=&quot;qsqldatabase#setDatabaseName&quot;&gt;QSqlDatabase :: setDatabaseName&lt;/a&gt;（）函数，而不是实际的数据库名称。</target>
        </trans-unit>
        <trans-unit id="2f2cbe1c8aedff9ebebfb5ee6584df1a788d8183" translate="yes" xml:space="preserve">
          <source>When connecting to signals in QML, the usual way is to create an &quot;on&amp;lt;Signal&amp;gt;&quot; handler that reacts when a signal is received, like this:</source>
          <target state="translated">当连接到QML中的信号时，通常的方法是创建一个&amp;ldquo; on &amp;lt;Signal&amp;gt;&amp;rdquo;处理程序，该处理程序在接收到信号时做出反应，如下所示：</target>
        </trans-unit>
        <trans-unit id="50ad6900d430167293c28de8c15b55b92afdb96d" translate="yes" xml:space="preserve">
          <source>When considering the above example, there are several parties involved:</source>
          <target state="translated">在考虑上述例子时,涉及到几个方面。</target>
        </trans-unit>
        <trans-unit id="1f8be66302822ad43cb41370fe8ce296df9c5d56" translate="yes" xml:space="preserve">
          <source>When constructing and showing a &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; that uses Vulkan to render, a Vulkan instance (&lt;code&gt;VkInstance&lt;/code&gt;), a physical device (&lt;code&gt;VkPhysicalDevice&lt;/code&gt;), a device (&lt;code&gt;VkDevice&lt;/code&gt;) and associated objects (queues, pools) are initialized through the Vulkan API. The same is mostly true when using &lt;a href=&quot;qquickrendercontrol&quot;&gt;QQuickRenderControl&lt;/a&gt; to redirect the rendering into a custom render target, such as a texture. While &lt;a href=&quot;qvulkaninstance&quot;&gt;QVulkanInstance&lt;/a&gt; construction is under the application's control then, the initialization of other graphics objects happen the same way in &lt;a href=&quot;qquickrendercontrol#initialize&quot;&gt;QQuickRenderControl::initialize&lt;/a&gt;() as with an on-screen &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt;.</source>
          <target state="translated">当构造和示出&lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt;使用福尔康渲染，一个福尔康实例（ &lt;code&gt;VkInstance&lt;/code&gt; ），物理设备（ &lt;code&gt;VkPhysicalDevice&lt;/code&gt; ），设备（ &lt;code&gt;VkDevice&lt;/code&gt; ）和相关联的对象（队列，池）通过福尔康API初始化。使用&lt;a href=&quot;qquickrendercontrol&quot;&gt;QQuickRenderControl&lt;/a&gt;将渲染重定向到自定义渲染目标（例如纹理）时，大多数情况都是如此。然后，在&lt;a href=&quot;qvulkaninstance&quot;&gt;QVulkanInstance&lt;/a&gt;构造由应用程序控制的情况下，其他图形对象的初始化在&lt;a href=&quot;qquickrendercontrol#initialize&quot;&gt;QQuickRenderControl :: initialize&lt;/a&gt;（）中的发生方式与屏幕上的&lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow相同&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="490cc9bd30b6bceb26457d2a8efbb90a6b3f5fe5" translate="yes" xml:space="preserve">
          <source>When control returns to the main event loop, all events that are stored in the queue will be sent using the &lt;a href=&quot;qcoreapplication#notify&quot;&gt;notify&lt;/a&gt;() function.</source>
          <target state="translated">当控制返回主事件循环时，将使用&lt;a href=&quot;qcoreapplication#notify&quot;&gt;notify&lt;/a&gt;（）函数发送队列中存储的所有事件。</target>
        </trans-unit>
        <trans-unit id="e0b92b7bfb7f8d04dcfbfbb18f560acc8b93fd1f" translate="yes" xml:space="preserve">
          <source>When converting from a &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; to an output encoding, write a &lt;a href=&quot;qchar#SpecialCharacter-enum&quot;&gt;QChar::ByteOrderMark&lt;/a&gt; as the first character if the output encoding supports this. This is the case for UTF-8, UTF-16 and UTF-32 encodings.</source>
          <target state="translated">从&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;转换为输出编码时，如果输出编码支持&lt;a href=&quot;qchar#SpecialCharacter-enum&quot;&gt;QChar :: ByteOrderMark&lt;/a&gt;，则将其写为第一个字符。对于UTF-8，UTF-16和UTF-32编码就是这种情况。</target>
        </trans-unit>
        <trans-unit id="a3a27bb53c99d0c2bcc135843d6530ba3852ad3b" translate="yes" xml:space="preserve">
          <source>When converting from an input encoding to a &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; the &lt;a href=&quot;qstringdecoder&quot;&gt;QStringDecoder&lt;/a&gt; usually skips an leading &lt;a href=&quot;qchar#SpecialCharacter-enum&quot;&gt;QChar::ByteOrderMark&lt;/a&gt;. When this flag is set, the byte order mark will not be skipped, but converted to utf-16 and inserted at the start of the created &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;.</source>
          <target state="translated">从输入编码转换为&lt;a href=&quot;qstring&quot;&gt;QString时&lt;/a&gt;，&lt;a href=&quot;qstringdecoder&quot;&gt;QStringDecoder&lt;/a&gt;通常会跳过开头的&lt;a href=&quot;qchar#SpecialCharacter-enum&quot;&gt;QChar :: ByteOrderMark&lt;/a&gt;。设置此标志后，将不跳过字节顺序标记，而是将其转换为utf-16并插入到创建的&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;的开头。</target>
        </trans-unit>
        <trans-unit id="a617205988b57dea8c2826ac4ae64f29a514cd0a" translate="yes" xml:space="preserve">
          <source>When created or cleared, the line edit will be filled with a copy of the input mask string where the meta characters have been removed, and the mask characters have been replaced with the</source>
          <target state="translated">当创建或清除时,行编辑将用输入掩码字符串的副本来填充,其中元字符已被删除,掩码字符已被替换为</target>
        </trans-unit>
        <trans-unit id="0aae57f52813e54337f9b3ba12b5d957d0e7706b" translate="yes" xml:space="preserve">
          <source>When creating a &lt;a href=&quot;qpagesize&quot;&gt;QPageSize&lt;/a&gt; using a custom &lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt; you can choose if you want &lt;a href=&quot;qpagesize&quot;&gt;QPageSize&lt;/a&gt; to try match the size to a standard page size. By default QPaperSize uses a &lt;a href=&quot;qpagesize#SizeMatchPolicy-enum&quot;&gt;FuzzyMatch&lt;/a&gt; mode where it will match a given page size to a standard page size if it falls within 3 postscript points of a defined standard size. You can override this to request only an exact match but this is not recommended as conversions between units can easily lose 3 points and result in incorrect page sizes.</source>
          <target state="translated">使用自定义&lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt;创建&lt;a href=&quot;qpagesize&quot;&gt;QPageSize时&lt;/a&gt;，可以选择是否希望&lt;a href=&quot;qpagesize&quot;&gt;QPageSize&lt;/a&gt;尝试将其大小与标准页面大小匹配。默认情况下，QPaperSize使用&lt;a href=&quot;qpagesize#SizeMatchPolicy-enum&quot;&gt;FuzzyMatch&lt;/a&gt;模式，如果它位于给定标准大小的3个后记点之内，它将匹配给定页面大小和标准页面大小。您可以覆盖此值以仅请求完全匹配，但是不建议您这样做，因为单元之间的转换很容易损失3点并导致不正确的页面尺寸。</target>
        </trans-unit>
        <trans-unit id="9ac98a689f6faf1b4d4a231d05990beaabb87945" translate="yes" xml:space="preserve">
          <source>When creating a &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; object, you must pass the name of your company or organization as well as the name of your application. For example, if your product is called Star Runner and your company is called MySoft, you would construct the &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; object as follows:</source>
          <target state="translated">创建&lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt;对象时，必须传递公司或组织的名称以及应用程序的名称。例如，如果您的产品称为Star Runner，而公司称为MySoft，则可以按以下方式构造&lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt;对象：</target>
        </trans-unit>
        <trans-unit id="acdb8c3cb9399aef996527a1d8f6a87298ec82bb" translate="yes" xml:space="preserve">
          <source>When creating a &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; to contain a URL from a &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; or a char*, always use &lt;a href=&quot;qstring#fromUtf8&quot;&gt;QString::fromUtf8&lt;/a&gt;().</source>
          <target state="translated">当创建&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;以包含来自&lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt;或char * 的URL时，请始终使用&lt;a href=&quot;qstring#fromUtf8&quot;&gt;QString :: fromUtf8&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="bbe42e39685b882db1d3c259aea5067777985606" translate="yes" xml:space="preserve">
          <source>When creating a QPageSize using a custom &lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt; you can choose if you want QPageSize to try match the size to a standard page size. By default QPaperSize uses a &lt;a href=&quot;qpagesize#SizeMatchPolicy-enum&quot;&gt;FuzzyMatch&lt;/a&gt; mode where it will match a given page size to a standard page size if it falls within 3 postscript points of a defined standard size. You can override this to request only an exact match but this is not recommended as conversions between units can easily lose 3 points and result in incorrect page sizes.</source>
          <target state="translated">使用自定义&lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt;创建QPageSize时，可以选择是否希望QPageSize尝试将其大小与标准页面大小匹配。默认情况下，QPaperSize使用&lt;a href=&quot;qpagesize#SizeMatchPolicy-enum&quot;&gt;FuzzyMatch&lt;/a&gt;模式，如果它位于给定标准大小的3个后记点之内，它将匹配给定页面大小和标准页面大小。您可以覆盖此值以仅请求完全匹配，但是不建议您这样做，因为单元之间的转换很容易损失3点并导致页面尺寸错误。</target>
        </trans-unit>
        <trans-unit id="2f4afccd147883bbee26d5e202b95e0e3a068c0b" translate="yes" xml:space="preserve">
          <source>When creating a QSettings object, you must pass the name of your company or organization as well as the name of your application. For example, if your product is called Star Runner and your company is called MySoft, you would construct the QSettings object as follows:</source>
          <target state="translated">当创建一个QSettings对象时,您必须传递您的公司或组织的名称以及您的应用程序的名称。例如,如果您的产品名为Star Runner,而您的公司名为MySoft,您将按如下方式构造QSettings对象。</target>
        </trans-unit>
        <trans-unit id="5d773d0579d473100a4c07b005ea00f7960a8020" translate="yes" xml:space="preserve">
          <source>When creating a custom help viewer the viewer can be configured by writing a custom collection file which could contain various keywords to be used to configure the help engine. These keywords and values and their meaning can be found in the help information for &lt;a href=&quot;https://doc.qt.io/qt-5.13/assistant-custom-help-viewer.html&quot;&gt;creating a custom help collection file&lt;/a&gt; for Assistant.</source>
          <target state="translated">在创建自定义帮助查看器时，可以通过编写自定义收集文件来配置查看器，该文件可能包含用于配置帮助引擎的各种关键字。这些关键字和值及其含义可以在用于为Assistant &lt;a href=&quot;https://doc.qt.io/qt-5.13/assistant-custom-help-viewer.html&quot;&gt;创建自定义帮助收集文件&lt;/a&gt;的帮助信息中找到。</target>
        </trans-unit>
        <trans-unit id="ed02b2b618cca08d2bfb9bef8750c41344446144" translate="yes" xml:space="preserve">
          <source>When creating a custom help viewer the viewer can be configured by writing a custom collection file which could contain various keywords to be used to configure the help engine. These keywords and values and their meaning can be found in the help information for &lt;a href=&quot;https://doc.qt.io/qt-5.15/assistant-custom-help-viewer.html&quot;&gt;creating a custom help collection file&lt;/a&gt; for Assistant.</source>
          <target state="translated">在创建自定义帮助查看器时，可以通过编写自定义收集文件来配置查看器，该文件可能包含用于配置帮助引擎的各种关键字。这些关键字和值及其含义可以在用于为Assistant&lt;a href=&quot;https://doc.qt.io/qt-5.15/assistant-custom-help-viewer.html&quot;&gt;创建自定义帮助收集文件&lt;/a&gt;的帮助信息中找到。</target>
        </trans-unit>
        <trans-unit id="65bcfdb381290d9bee6e16ff1d2353f984f24d0f" translate="yes" xml:space="preserve">
          <source>When creating a custom item, item coordinates are all you need to worry about; &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; and &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; will perform all transformations for you. This makes it very easy to implement custom items. For example, if you receive a mouse press or a drag enter event, the event position is given in item coordinates. The &lt;a href=&quot;qgraphicsitem#contains&quot;&gt;QGraphicsItem::contains&lt;/a&gt;() virtual function, which returns &lt;code&gt;true&lt;/code&gt; if a certain point is inside your item, and false otherwise, takes a point argument in item coordinates. Similarly, an item's bounding rect and shape are in item coordinates.</source>
          <target state="translated">创建自定义商品时，您只需要担心商品坐标；&lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt;和&lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt;将为您执行所有转换。这使得实现自定义项非常容易。例如，如果收到鼠标按下或拖动输入事件，则事件位置以项目坐标给出。该&lt;a href=&quot;qgraphicsitem#contains&quot;&gt;的QGraphicsItem ::包括&lt;/a&gt;（）虚函数，返回 &lt;code&gt;true&lt;/code&gt; ，如果某一个点就是你的项目里面，否则为false，需要在项目的坐标点的说法。类似地，项目的边界矩形和形状都在项目坐标中。</target>
        </trans-unit>
        <trans-unit id="9e08552b85a95188c1665a4dafe6b362ee82355f" translate="yes" xml:space="preserve">
          <source>When creating a map from sorted data inserting the largest key first with &lt;a href=&quot;qmap#constBegin&quot;&gt;constBegin&lt;/a&gt;() is faster than inserting in sorted order with &lt;a href=&quot;qmap#constEnd&quot;&gt;constEnd&lt;/a&gt;(), since &lt;a href=&quot;qmap#constEnd&quot;&gt;constEnd&lt;/a&gt;() - 1 (which is needed to check if the hint is valid) needs &lt;a href=&quot;containers#logarithmic-time&quot;&gt;logarithmic time&lt;/a&gt;.</source>
          <target state="translated">当创建从排序的数据与第一插入最大关键字的地图&lt;a href=&quot;qmap#constBegin&quot;&gt;constBegin&lt;/a&gt;（）比与以排序的顺序插入更快&lt;a href=&quot;qmap#constEnd&quot;&gt;constEnd&lt;/a&gt;（），因为&lt;a href=&quot;qmap#constEnd&quot;&gt;constEnd&lt;/a&gt;（） - 1（这是需要检查提示是有效的）需要&lt;a href=&quot;containers#logarithmic-time&quot;&gt;对数时间&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="277dae289340726b1f2f3cb7a7f1963aac1390e5" translate="yes" xml:space="preserve">
          <source>When creating a multi map from sorted data inserting the largest key first with &lt;a href=&quot;qmultimap#constBegin&quot;&gt;constBegin&lt;/a&gt;() is faster than inserting in sorted order with &lt;a href=&quot;qmultimap#constEnd&quot;&gt;constEnd&lt;/a&gt;(), since &lt;a href=&quot;qmultimap#constEnd&quot;&gt;constEnd&lt;/a&gt;() - 1 (which is needed to check if the hint is valid) needs &lt;a href=&quot;containers#logarithmic-time&quot;&gt;logarithmic time&lt;/a&gt;.</source>
          <target state="translated">当创建从排序的数据与第一插入最大键的多地图&lt;a href=&quot;qmultimap#constBegin&quot;&gt;constBegin&lt;/a&gt;（）被快于与以排序的顺序插入&lt;a href=&quot;qmultimap#constEnd&quot;&gt;constEnd&lt;/a&gt;（），因为&lt;a href=&quot;qmultimap#constEnd&quot;&gt;constEnd&lt;/a&gt;（） - 1（这是需要检查提示是有效的）需要&lt;a href=&quot;containers#logarithmic-time&quot;&gt;对数时间&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="da378fc2f1f498e22d7abb9c20072ff5f0d3d3c4" translate="yes" xml:space="preserve">
          <source>When creating a new model for an existing data structure, it is important to consider which type of model should be used to provide an interface onto the data. If the data structure can be represented as a list or table of items, you can subclass &lt;a href=&quot;qabstractlistmodel&quot;&gt;QAbstractListModel&lt;/a&gt; or &lt;a href=&quot;qabstracttablemodel&quot;&gt;QAbstractTableModel&lt;/a&gt; since these classes provide suitable default implementations for many functions.</source>
          <target state="translated">为现有数据结构创建新模型时，重要的是要考虑应使用哪种类型的模型来提供数据接口。如果数据结构可以表示为项目列表或表，则可以将&lt;a href=&quot;qabstractlistmodel&quot;&gt;QAbstractListModel&lt;/a&gt;或&lt;a href=&quot;qabstracttablemodel&quot;&gt;QAbstractTableModel&lt;/a&gt;子类化，因为这些类为许多功能提供了合适的默认实现。</target>
        </trans-unit>
        <trans-unit id="8500b569b9e4d2538da567830ca173bb7a100287" translate="yes" xml:space="preserve">
          <source>When creating a property binding from JavaScript, the &lt;code&gt;this&lt;/code&gt; keyword can be used to refer to the object which receives the binding. This is helpful for resolving ambiguities with property names.</source>
          <target state="translated">从JavaScript创建属性绑定时，可以使用 &lt;code&gt;this&lt;/code&gt; 关键字来引用接收绑定的对象。这有助于解决属性名称的歧义。</target>
        </trans-unit>
        <trans-unit id="a4acef9238768bf956778e2a447e1184f2109294" translate="yes" xml:space="preserve">
          <source>When creating an &lt;a href=&quot;qt3drender-qeffect&quot;&gt;QEffect&lt;/a&gt; that targets several versions of a graphics API, it is useful to create several &lt;a href=&quot;qt3drender-qtechnique&quot;&gt;QTechnique&lt;/a&gt; nodes each with a &lt;a href=&quot;qt3drender-qtechnique#graphicsApiFilter-prop&quot;&gt;graphicsApiFilter&lt;/a&gt; set to match one of the targeted GL versions. At runtime, the Qt3D renderer will select the most appropriate &lt;a href=&quot;qt3drender-qtechnique&quot;&gt;QTechnique&lt;/a&gt; based on which graphics API versions are supported and (if specified) the &lt;a href=&quot;qt3drender-qfilterkey&quot;&gt;QFilterKey&lt;/a&gt; nodes that satisfy a given &lt;a href=&quot;qt3drender-qtechniquefilter&quot;&gt;QTechniqueFilter&lt;/a&gt; in the FrameGraph.</source>
          <target state="translated">创建针对多个图形API版本的&lt;a href=&quot;qt3drender-qeffect&quot;&gt;QEffect时&lt;/a&gt;，创建多个&lt;a href=&quot;qt3drender-qtechnique&quot;&gt;QTechnique&lt;/a&gt;节点很有用，每个节点都设置了&lt;a href=&quot;qt3drender-qtechnique#graphicsApiFilter-prop&quot;&gt;graphicsApiFilter&lt;/a&gt;来匹配目标GL版本之一。在运行时，Qt3D渲染器将选择最合适的&lt;a href=&quot;qt3drender-qtechnique&quot;&gt;QTechnique&lt;/a&gt;在此基础上的图形API版本的支持和（如果指定）&lt;a href=&quot;qt3drender-qfilterkey&quot;&gt;QFilterKey&lt;/a&gt;满足给定节点&lt;a href=&quot;qt3drender-qtechniquefilter&quot;&gt;QTechniqueFilter&lt;/a&gt;在FrameGraph。</target>
        </trans-unit>
        <trans-unit id="74fe2d261fd9daef09d6ad1cf9640099d84a6e3f" translate="yes" xml:space="preserve">
          <source>When creating an &lt;a href=&quot;qt3drender-qeffect&quot;&gt;QEffect&lt;/a&gt; that targets several versions of a graphics API, it is useful to create several QTechnique nodes each with a &lt;a href=&quot;qt3drender-qtechnique#graphicsApiFilter-prop&quot;&gt;graphicsApiFilter&lt;/a&gt; set to match one of the targeted GL versions. At runtime, the Qt3D renderer will select the most appropriate QTechnique based on which graphics API versions are supported and (if specified) the &lt;a href=&quot;qt3drender-qfilterkey&quot;&gt;QFilterKey&lt;/a&gt; nodes that satisfy a given &lt;a href=&quot;qt3drender-qtechniquefilter&quot;&gt;QTechniqueFilter&lt;/a&gt; in the FrameGraph.</source>
          <target state="translated">创建针对多个图形API版本的&lt;a href=&quot;qt3drender-qeffect&quot;&gt;QEffect时&lt;/a&gt;，创建多个QTechnique节点非常有用，每个节点都设置了&lt;a href=&quot;qt3drender-qtechnique#graphicsApiFilter-prop&quot;&gt;graphicsApiFilter&lt;/a&gt;来匹配目标GL版本之一。在运行时，Qt3D渲染器将基于支持的图形API版本以及（如果指定的话）满足&lt;a href=&quot;qt3drender-qtechniquefilter&quot;&gt;FrameGraph&lt;/a&gt;中给定QTechniqueFilter的&lt;a href=&quot;qt3drender-qfilterkey&quot;&gt;QFilterKey&lt;/a&gt;节点来选择最合适的QTechnique。</target>
        </trans-unit>
        <trans-unit id="bd5a5c9f752ad47937d6434e44c62e97758c6944" translate="yes" xml:space="preserve">
          <source>When creating an Effect that targets several versions of a graphics API, it is useful to create several Technique nodes each with a &lt;a href=&quot;qml-qt3d-render-technique#graphicsApiFilter-prop&quot;&gt;graphicsApiFilter&lt;/a&gt; set to match one of the targeted versions. At runtime, the Qt3D renderer will select the most appropriate Technique based on which graphics API versions are supported and (if specified) the &lt;a href=&quot;qml-qt3d-render-filterkey&quot;&gt;FilterKey&lt;/a&gt; nodes that satisfy a given &lt;a href=&quot;qml-qt3d-render-techniquefilter&quot;&gt;TechniqueFilter&lt;/a&gt; in the FrameGraph.</source>
          <target state="translated">创建针对图形API多个版本的效果时，创建多个Technique节点非常有用，每个节点都设置了&lt;a href=&quot;qml-qt3d-render-technique#graphicsApiFilter-prop&quot;&gt;graphicsApiFilter&lt;/a&gt;来匹配目标版本之一。在运行时，Qt3D渲染器将根据选择最合适的技术在其上的图形API版本的支持和（如果指定）&lt;a href=&quot;qml-qt3d-render-filterkey&quot;&gt;FilterKey&lt;/a&gt;满足给定节点&lt;a href=&quot;qml-qt3d-render-techniquefilter&quot;&gt;TechniqueFilter&lt;/a&gt;在FrameGraph。</target>
        </trans-unit>
        <trans-unit id="f722c75ee9a2de387fc8f2d451fedcecaaa57d68" translate="yes" xml:space="preserve">
          <source>When creating custom items, use the new &lt;a href=&quot;qsgrectanglenode&quot;&gt;QSGRectangleNode&lt;/a&gt; and &lt;a href=&quot;qsgimagenode&quot;&gt;QSGImageNode&lt;/a&gt; classes. These replace the now deprecated QSGSimpleRectNode and QSGSimpleTextureNode. Unlike their predecessors, these new classes are interfaces, and implementations are created via the &lt;a href=&quot;qquickwindow#createRectangleNode&quot;&gt;QQuickWindow::createRectangleNode&lt;/a&gt;() and &lt;a href=&quot;qquickwindow#createImageNode&quot;&gt;QQuickWindow::createImageNode&lt;/a&gt;() factory functions.</source>
          <target state="translated">创建自定义项目时，请使用新的&lt;a href=&quot;qsgrectanglenode&quot;&gt;QSGRectangleNode&lt;/a&gt;和&lt;a href=&quot;qsgimagenode&quot;&gt;QSGImageNode&lt;/a&gt;类。这些替代了现在不推荐使用的QSGSimpleRectNode和QSGSimpleTextureNode。与它们的前辈不同，这些新类是接口，并且实现是通过&lt;a href=&quot;qquickwindow#createRectangleNode&quot;&gt;QQuickWindow :: createRectangleNode&lt;/a&gt;（）和&lt;a href=&quot;qquickwindow#createImageNode&quot;&gt;QQuickWindow :: createImageNode&lt;/a&gt;（）工厂函数创建的。</target>
        </trans-unit>
        <trans-unit id="ad1ca55154d7a13bb0a82b3ada46b98f3f2fa71a" translate="yes" xml:space="preserve">
          <source>When creating textures via C++ scene graph APIs like &lt;a href=&quot;qquickwindow#createTextureFromImage&quot;&gt;QQuickWindow::createTextureFromImage&lt;/a&gt;(), 32-bit formats won't involve any conversion, they'll map directly to the corresponding &lt;code&gt;R8G8B8A8_UNORM&lt;/code&gt; or &lt;code&gt;B8G8R8A8_UNORM&lt;/code&gt; format. Everything else will trigger a &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt;-based format conversion on the CPU first.</source>
          <target state="translated">通过诸如&lt;a href=&quot;qquickwindow#createTextureFromImage&quot;&gt;QQuickWindow :: createTextureFromImage&lt;/a&gt;（）之类的C ++场景图API创建纹理时，32位格式不涉及任何转换，它们将直接映射到相应的 &lt;code&gt;R8G8B8A8_UNORM&lt;/code&gt; 或 &lt;code&gt;B8G8R8A8_UNORM&lt;/code&gt; 格式。其他所有操作都会首先在CPU上触发基于&lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt;的格式转换。</target>
        </trans-unit>
        <trans-unit id="ac8c6318f0656d7823865940204d8f34b4f9e2dc" translate="yes" xml:space="preserve">
          <source>When creating user interfaces with Qt, particularly those with specialized controls and features, developers sometimes need to create new data types that can be used alongside or in place of Qt's existing set of value types.</source>
          <target state="translated">当使用Qt创建用户界面时,特别是那些具有特殊控件和功能的用户界面,开发人员有时需要创建新的数据类型,这些数据类型可以与Qt现有的值类型集一起使用,或者代替Qt现有的值类型集。</target>
        </trans-unit>
        <trans-unit id="7c5cad017177801067fb33fec32abbde43a2a0a2" translate="yes" xml:space="preserve">
          <source>When creating visual scenes with Qt Quick, it is important to understand the concept of the</source>
          <target state="translated">在使用Qt Quick创建可视化场景时,必须要了解Qt Quick的概念。</target>
        </trans-unit>
        <trans-unit id="50bc4a3f36be94206381ac944ed54f7e8e7a7edb" translate="yes" xml:space="preserve">
          <source>When data is transferred from C++ to QML, the ownership of the data always remains with C++. The exception to this rule is when a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; is returned from an explicit C++ method call: in this case, the QML engine assumes ownership of the object, unless the ownership of the object has explicitly been set to remain with C++ by invoking &lt;a href=&quot;qjsengine#setObjectOwnership&quot;&gt;QQmlEngine::setObjectOwnership&lt;/a&gt;() with &lt;a href=&quot;qjsengine#ObjectOwnership-enum&quot;&gt;QQmlEngine::CppOwnership&lt;/a&gt; specified.</source>
          <target state="translated">当数据从C ++传输到QML时，数据所有权始终由C ++保留。该规则的例外情况是从显式C ++方法调用返回&lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;时：在这种情况下，除非通过调用&lt;a href=&quot;qjsengine#setObjectOwnership&quot;&gt;QQmlEngine&lt;/a&gt;将对象的所有权显式设置为与C ++一起使用，否则QML引擎将假定该对象的所有权：使用&lt;a href=&quot;qjsengine#ObjectOwnership-enum&quot;&gt;QQmlEngine :: CppOwnership&lt;/a&gt;指定的setObjectOwnership（）。</target>
        </trans-unit>
        <trans-unit id="d8deccb0e684f6ccb3eb82d7b6672c38b9e7d190" translate="yes" xml:space="preserve">
          <source>When data is transferred from C++ to QML, the ownership of the data always remains with C++. The exception to this rule is when a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; is returned from an explicit C++ method call: in this case, the QML engine assumes ownership of the object, unless the ownership of the object has explicitly been set to remain with C++ by invoking &lt;a href=&quot;qqmlengine#setObjectOwnership&quot;&gt;QQmlEngine::setObjectOwnership&lt;/a&gt;() with &lt;a href=&quot;qqmlengine#ObjectOwnership-enum&quot;&gt;QQmlEngine::CppOwnership&lt;/a&gt; specified.</source>
          <target state="translated">当数据从C ++传输到QML时，数据所有权始终由C ++保留。该规则的例外情况是从显式C ++方法调用返回&lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;时：在这种情况下，除非通过调用&lt;a href=&quot;qqmlengine#setObjectOwnership&quot;&gt;QQmlEngine&lt;/a&gt;将对象的所有权显式设置为与C ++一起使用，否则QML引擎将假定该对象的所有权：使用&lt;a href=&quot;qqmlengine#ObjectOwnership-enum&quot;&gt;QQmlEngine :: CppOwnership&lt;/a&gt;指定的setObjectOwnership（）。</target>
        </trans-unit>
        <trans-unit id="833825b15200463ac0253e002ab1f7246eda7871" translate="yes" xml:space="preserve">
          <source>When data values are exchanged between QML and C++, they are converted by the QML engine to have the correct data types as appropriate for use in QML or C++. This requires the exchanged data to be of a type that is recognizable by the engine.</source>
          <target state="translated">当QML和C++之间交换数据值时,QML引擎会将其转换为适合在QML或C++中使用的正确数据类型。这就要求交换的数据必须是引擎可以识别的类型。</target>
        </trans-unit>
        <trans-unit id="884fbee58eaf141d201605823b7b1107d132d1f7" translate="yes" xml:space="preserve">
          <source>When data-modifying functions increase the size of the array, they may lead to reallocation of memory for the QByteArray object. When this happens, QByteArray expands by more than it immediately needs so as to have space for further expansion without reallocation until the size of the array has greatly increased.</source>
          <target state="translated">当数据修改函数增加数组的大小时,可能会导致QByteArray对象的内存重新分配。当这种情况发生时,QByteArray的膨胀量会超过它立即需要的量,这样就有了进一步膨胀的空间而不需要重新分配,直到数组的大小大大增加。</target>
        </trans-unit>
        <trans-unit id="88de44478b8ed2bd120794db0b7d5b455c64de25" translate="yes" xml:space="preserve">
          <source>When dealing with shared objects, there are two ways of copying an object. We usually speak about</source>
          <target state="translated">在处理共享对象时,有两种方式可以复制对象。我们通常说的是</target>
        </trans-unit>
        <trans-unit id="880f2e372d228c68b46fdc809205b92833a51398" translate="yes" xml:space="preserve">
          <source>When dealing with the D-Bus bus service or with remote applications over D-Bus, a number of error conditions can happen. This error conditions are sometimes signalled by a returned error value or by a &lt;a href=&quot;qdbuserror&quot;&gt;QDBusError&lt;/a&gt;.</source>
          <target state="translated">在处理D-Bus总线服务或通过D-Bus进行远程应用程序时，可能会发生许多错误情况。有时通过返回的错误值或&lt;a href=&quot;qdbuserror&quot;&gt;QDBusError&lt;/a&gt;发出此错误情况的信号。</target>
        </trans-unit>
        <trans-unit id="74f0ca37c9cc12fbb98f9f5310dd3caadcb27473" translate="yes" xml:space="preserve">
          <source>When dealing with the D-Bus bus service or with remote applications over D-Bus, a number of error conditions can happen. This error conditions are sometimes signalled by a returned error value or by a QDBusError.</source>
          <target state="translated">当处理D-Bus总线服务或通过D-Bus处理远程应用时,可能会发生一些错误情况。这些错误条件有时会通过返回的错误值或QDBusError发出信号。</target>
        </trans-unit>
        <trans-unit id="37e1660403429a1797eb4c0aeb989abc574ce656" translate="yes" xml:space="preserve">
          <source>When declaring properties in QML, it's easy and convenient to use the &quot;var&quot; type:</source>
          <target state="translated">在QML中声明属性时,使用 &quot;var &quot;类型很简单方便。</target>
        </trans-unit>
        <trans-unit id="499464bd993035896d274262364a35979c761cc8" translate="yes" xml:space="preserve">
          <source>When decoding Base64-encoded data, ignores errors in the input; invalid characters are simply skipped. This enum value has been added in Qt 5.15.</source>
          <target state="translated">当解码Base64编码的数据时,忽略输入中的错误;无效的字符将被跳过。在Qt 5.15中增加了这个枚举值。</target>
        </trans-unit>
        <trans-unit id="ee82abeedacfd233e0f6aece53f4beda554b1af8" translate="yes" xml:space="preserve">
          <source>When decoding Base64-encoded data, stops at the first decoding error. This enum value has been added in Qt 5.15.</source>
          <target state="translated">当解码Base64编码数据时,在第一次解码错误时停止。Qt 5.15中增加了这个值。</target>
        </trans-unit>
        <trans-unit id="f6c7b9b1412f471c238127a4b55f7698c8fb1c87" translate="yes" xml:space="preserve">
          <source>When defining your own needle component, the only properties that the style requires you to set are the &lt;a href=&quot;qml-qtquick-item#implicitWidth-prop&quot;&gt;implicitWidth&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-item#implicitHeight-prop&quot;&gt;implicitHeight&lt;/a&gt;.</source>
          <target state="translated">定义自己的针组件时，样式要求您设置的唯一属性是&lt;a href=&quot;qml-qtquick-item#implicitWidth-prop&quot;&gt;implicitWidth&lt;/a&gt;和&lt;a href=&quot;qml-qtquick-item#implicitHeight-prop&quot;&gt;implicitHeight&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a11f2000ac0edf67c2b20ae00acff6fb70863dbe" translate="yes" xml:space="preserve">
          <source>When deploying Qt applications built using Visual Studio 2005, or later, make sure that the manifest file that was created when the application was linked is handled correctly. This is handled automatically for projects that generate DLLs.</source>
          <target state="translated">当部署使用Visual Studio 2005或更高版本构建的Qt应用程序时,请确保正确处理应用程序链接时创建的清单文件。对于生成DLLs的项目,会自动处理这个文件。</target>
        </trans-unit>
        <trans-unit id="e3f2fc2611c302aed3276f1510a9d174ba6db392" translate="yes" xml:space="preserve">
          <source>When deploying the app, the compression is typically handled on the server side. We recommend to compress the wasm binaries because this typically reduces the size of the binary by 50 %.</source>
          <target state="translated">在部署应用程序时,压缩通常在服务器端处理。我们建议压缩wasm二进制文件,因为这通常会使二进制文件的大小减少50%。</target>
        </trans-unit>
        <trans-unit id="fc8ea9ac8ca6cf4cf6b3b5f4d012ccb4493d9e28" translate="yes" xml:space="preserve">
          <source>When developing applications that use D-Bus, it is sometimes useful to be able to see information about the messages that are sent and received across the bus by each application.</source>
          <target state="translated">在开发使用D-Bus的应用程序时,有时能够看到每个应用程序在总线上发送和接收的消息的信息是很有用的。</target>
        </trans-unit>
        <trans-unit id="1a1c1be356204dfd455ba7ec0d01e973b146ec67" translate="yes" xml:space="preserve">
          <source>When disabled, a &lt;a href=&quot;qml-qt3d-render-nodraw&quot;&gt;NoDraw&lt;/a&gt; node won't prevent the scene from being rendered. Toggling the enabled property is therefore a way to make a &lt;a href=&quot;qml-qt3d-render-nodraw&quot;&gt;NoDraw&lt;/a&gt; active or inactive.</source>
          <target state="translated">禁用后，&lt;a href=&quot;qml-qt3d-render-nodraw&quot;&gt;NoDraw&lt;/a&gt;节点不会阻止场景的渲染。因此，切换enabled属性是使&lt;a href=&quot;qml-qt3d-render-nodraw&quot;&gt;NoDraw&lt;/a&gt;处于活动状态或非活动状态的一种方法。</target>
        </trans-unit>
        <trans-unit id="857e0ffe6bd1478d0544df44c2c658d65e015926" translate="yes" xml:space="preserve">
          <source>When disabled, a &lt;a href=&quot;qt3drender-qnodraw&quot;&gt;Qt3DRender::QNoDraw&lt;/a&gt; node won't prevent the scene from being rendered. Toggling the enabled property is therefore a way to make a &lt;a href=&quot;qt3drender-qnodraw&quot;&gt;Qt3DRender::QNoDraw&lt;/a&gt; active or inactive.</source>
          <target state="translated">禁用后，&lt;a href=&quot;qt3drender-qnodraw&quot;&gt;Qt3DRender :: QNoDraw&lt;/a&gt;节点不会阻止场景的渲染。因此，切换enabled属性是使&lt;a href=&quot;qt3drender-qnodraw&quot;&gt;Qt3DRender :: QNoDraw&lt;/a&gt;处于活动状态或非活动状态的一种方法。</target>
        </trans-unit>
        <trans-unit id="a705f9e79dc5e0d4da74710091ca3394fb3c8ff6" translate="yes" xml:space="preserve">
          <source>When disabled, a &lt;a href=&quot;qt3drender-qnopicking&quot;&gt;Qt3DRender::QNoPicking&lt;/a&gt; node won't prevent picking from being performed. Toggling the enabled property is therefore a way to make a &lt;a href=&quot;qt3drender-qnopicking&quot;&gt;Qt3DRender::QNoPicking&lt;/a&gt; active or inactive.</source>
          <target state="translated">禁用后，&lt;a href=&quot;qt3drender-qnopicking&quot;&gt;Qt3DRender :: QNoPicking&lt;/a&gt;节点不会阻止执行选择。因此，切换启用的属性是使&lt;a href=&quot;qt3drender-qnopicking&quot;&gt;Qt3DRender :: QNoPicking&lt;/a&gt;处于活动状态或非活动状态的一种方法。</target>
        </trans-unit>
        <trans-unit id="c03a7230ca07cd92ed1e2c5c76edb68253bdb253" translate="yes" xml:space="preserve">
          <source>When disabled, a NoDraw node won't prevent the scene from being rendered. Toggling the enabled property is therefore a way to make a NoDraw active or inactive.</source>
          <target state="translated">当禁用时,NoDraw节点不会阻止场景的渲染。因此,切换启用属性是使 NoDraw 激活或不激活的一种方式。</target>
        </trans-unit>
        <trans-unit id="7e738f36ac893e8cd586e71209d223aa4927c0d5" translate="yes" xml:space="preserve">
          <source>When disabled, a NoPicking node won't prevent picking from being performed. Toggling the enabled property is therefore a way to make a NoPicking active or inactive.</source>
          <target state="translated">当禁用时,NoPicking节点不会阻止拣选的执行。因此,切换启用属性是使NoPicking激活或不激活的一种方式。</target>
        </trans-unit>
        <trans-unit id="382c790d1bb1d0cf3f278efbd5066d3785f4f5c9" translate="yes" xml:space="preserve">
          <source>When disabled, the &lt;a href=&quot;qml-qtquick3d-sceneenvironment#depthTestEnabled-prop&quot;&gt;depthTestEnabled&lt;/a&gt; property can be used to simultaneously override depth testing and the order of rendering the objects. The operation of this property is not as obvious as many of the other properties in the system so this page offers some insight into when, where, and why this property can be used.</source>
          <target state="translated">禁用时，&lt;a href=&quot;qml-qtquick3d-sceneenvironment#depthTestEnabled-prop&quot;&gt;depthTestEnabled&lt;/a&gt;属性可用于同时覆盖深度测试和渲染对象的顺序。该属性的操作不如系统中的许多其他属性那么明显，因此此页面提供了一些有关何时，何地以及为什么可以使用此属性的见解。</target>
        </trans-unit>
        <trans-unit id="bc1e687319c686b682a905da3e6616cd03084a73" translate="yes" xml:space="preserve">
          <source>When disabled, the normals on the surface are interpolated making the edges look round. When enabled, the normals are kept the same on a triangle making the color of the triangle solid. This makes the data more readable from the model.</source>
          <target state="translated">禁用时,曲面上的法线会被插值,使边缘看起来很圆。启用时,三角形上的法线保持不变,使三角形的颜色变成纯色。这使得数据在模型中更易读。</target>
        </trans-unit>
        <trans-unit id="24f4c0f2f49fed31d9cd8577cea9ab05b39be5e3" translate="yes" xml:space="preserve">
          <source>When displaying data from models in Qt item views, e.g., a &lt;a href=&quot;qtableview&quot;&gt;QTableView&lt;/a&gt;, the individual items are drawn by a delegate. Also, when an item is edited, it provides an editor widget, which is placed on top of the item view while editing takes place. &lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate&lt;/a&gt; is the default delegate for all Qt item views, and is installed upon them when they are created.</source>
          <target state="translated">当在Qt项目视图（例如&lt;a href=&quot;qtableview&quot;&gt;QTableView）中&lt;/a&gt;显示来自模型的数据时，单个项目由委托绘制。同样，在编辑项目时，它会提供一个编辑器小部件，在进行编辑时，该小部件将置于项目视图的顶部。&lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate&lt;/a&gt;是所有Qt项目视图的默认委托，并在创建它们时安装在它们上。</target>
        </trans-unit>
        <trans-unit id="e6e55cf5ea63dc5db3857d7ad604b687dae8d030" translate="yes" xml:space="preserve">
          <source>When displaying data from models in Qt item views, e.g., a &lt;a href=&quot;qtableview&quot;&gt;QTableView&lt;/a&gt;, the individual items are drawn by a delegate. Also, when an item is edited, it provides an editor widget, which is placed on top of the item view while editing takes place. QStyledItemDelegate is the default delegate for all Qt item views, and is installed upon them when they are created.</source>
          <target state="translated">当在Qt项目视图（例如&lt;a href=&quot;qtableview&quot;&gt;QTableView）中&lt;/a&gt;显示来自模型的数据时，单个项目由委托绘制。同样，在编辑项目时，它会提供一个编辑器小部件，在进行编辑时，该小部件将置于项目视图的顶部。QStyledItemDelegate是所有Qt项目视图的默认委托，并在创建它们时安装在它们上。</target>
        </trans-unit>
        <trans-unit id="0352c49318cb9d0b30ba555050217480183cb03e" translate="yes" xml:space="preserve">
          <source>When displaying items from a custom model in a standard view, it is often sufficient to simply ensure that the model returns appropriate data for each of the &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;roles&lt;/a&gt; that determine the appearance of items in views. The default delegate used by Qt's standard views uses this role information to display items in most of the common forms expected by users. However, it is sometimes necessary to have even more control over the appearance of items than the default delegate can provide.</source>
          <target state="translated">在标准视图中显示来自自定义模型的项目时，仅确保模型为确定视图中项目外观的每个&lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;角色&lt;/a&gt;返回适当的数据通常就足够了。 Qt标准视图使用的默认委托使用此角色信息以用户期望的大多数常见形式显示项目。但是，有时有必要对项目的外观进行更多控制，而不是默认委托可以提供的控制。</target>
        </trans-unit>
        <trans-unit id="159720c88af83f5ac94a174365550a72f0765067" translate="yes" xml:space="preserve">
          <source>When documenting a QML type in a</source>
          <target state="translated">当把一个QML类型记录在</target>
        </trans-unit>
        <trans-unit id="b7e55292b4abae3e9e4e7263b6533ed85abbb41e" translate="yes" xml:space="preserve">
          <source>When documenting a QML type in the</source>
          <target state="translated">当在</target>
        </trans-unit>
        <trans-unit id="fd4be1f4d3d4fe684047540a2b498b3e14a564e5" translate="yes" xml:space="preserve">
          <source>When doing replacement the area of the preedit string is ignored, thus a replacement starting at -1 with a length of 2 will remove the last character before the preedit string and the first character afterwards, and insert the commit string directly before the preedit string.</source>
          <target state="translated">在进行替换时,会忽略preedit字符串的区域,因此从-1开始,长度为2的替换会删除preedit字符串前的最后一个字符和后面的第一个字符,并直接在preedit字符串前插入提交字符串。</target>
        </trans-unit>
        <trans-unit id="7b591bbff5ab07d40d7612a73ab5fcdc537e41fa" translate="yes" xml:space="preserve">
          <source>When doubleclicking an item, the item will first receive a mouse press event, followed by a release event (i.e., a click), then a doubleclick event, and finally a release event.</source>
          <target state="translated">当双击一个项目时,该项目将首先收到鼠标按下事件,然后是释放事件(即点击),然后是双击事件,最后是释放事件。</target>
        </trans-unit>
        <trans-unit id="a02484f5ce286a79ae6a871b9106f5799cb1d5dc" translate="yes" xml:space="preserve">
          <source>When dragging the titlebar of a dock, all the tabs that are tabbed with it are going to be dragged. Implies AllowTabbedDocks. Does not work well if some QDockWidgets have restrictions in which area they are allowed. (This enum value was added in Qt 5.6.)</source>
          <target state="translated">当拖动dock的标题栏时,所有与之相关的标签页都会被拖动。意味着AllowTabbedDocks。如果某些QDockWidgets有限制在哪些区域允许拖动,则效果不好。(这个枚举值是在Qt 5.6中添加的。)</target>
        </trans-unit>
        <trans-unit id="19649a7c3fc63002d50d3cb1460af355d223d55e" translate="yes" xml:space="preserve">
          <source>When drawStaticText() is called, the layout of the &lt;a href=&quot;qstatictext&quot;&gt;QStaticText&lt;/a&gt; will be recalculated if any part of the &lt;a href=&quot;qstatictext&quot;&gt;QStaticText&lt;/a&gt; object has changed since the last time it was drawn. It will also be recalculated if the painter's font is not the same as when the &lt;a href=&quot;qstatictext&quot;&gt;QStaticText&lt;/a&gt; was last drawn, or, on any other paint engine than the OpenGL2 engine, if the painter's matrix has been altered since the static text was last drawn.</source>
          <target state="translated">调用drawStaticText（）时，如果自上次绘制以来，&lt;a href=&quot;qstatictext&quot;&gt;QStaticText&lt;/a&gt;对象的任何部分发生更改，则将重新计算&lt;a href=&quot;qstatictext&quot;&gt;QStaticText&lt;/a&gt;的布局。如果绘画者的字体与上次绘制&lt;a href=&quot;qstatictext&quot;&gt;QStaticText&lt;/a&gt;时的字体不同，或者在自上次绘制静态文本以来改变了绘画者的矩阵，或者在除OpenGL2引擎之外的任何其他绘画引擎上，也将重新计算。</target>
        </trans-unit>
        <trans-unit id="6f25e8af439c89e58b576aa15a0a79c869106881" translate="yes" xml:space="preserve">
          <source>When drawing text, the font is specified using the &lt;a href=&quot;gui-changes-qt6#qfont&quot;&gt;QFont&lt;/a&gt; class. Qt will use the font with the specified attributes, or if no matching font exists, Qt will use the closest matching installed font. The attributes of the font that is actually used can be retrieved using the &lt;a href=&quot;qfontinfo&quot;&gt;QFontInfo&lt;/a&gt; class. In addition, the &lt;a href=&quot;qfontmetrics&quot;&gt;QFontMetrics&lt;/a&gt; class provides the font measurements, and the &lt;a href=&quot;gui-changes-qt6#qfontdatabase&quot;&gt;QFontDatabase&lt;/a&gt; class provides information about the fonts available in the underlying window system.</source>
          <target state="translated">绘制文本时，使用&lt;a href=&quot;gui-changes-qt6#qfont&quot;&gt;QFont&lt;/a&gt;类指定字体。Qt将使用具有指定属性的字体，或者如果不存在匹配的字体，则Qt将使用最接近的匹配安装字体。可以使用&lt;a href=&quot;qfontinfo&quot;&gt;QFontInfo&lt;/a&gt;类来检索实际使用的字体的属性。此外，&lt;a href=&quot;qfontmetrics&quot;&gt;QFontMetrics&lt;/a&gt;类提供字体测量，而&lt;a href=&quot;gui-changes-qt6#qfontdatabase&quot;&gt;QFontDatabase&lt;/a&gt;类提供有关基础窗口系统中可用字体的信息。</target>
        </trans-unit>
        <trans-unit id="bb13eb36af2066f03f57ae49bb001cd98eedd84c" translate="yes" xml:space="preserve">
          <source>When drawing text, the font is specified using the &lt;a href=&quot;qfont&quot;&gt;QFont&lt;/a&gt; class. Qt will use the font with the specified attributes, or if no matching font exists, Qt will use the closest matching installed font. The attributes of the font that is actually used can be retrieved using the &lt;a href=&quot;qfontinfo&quot;&gt;QFontInfo&lt;/a&gt; class. In addition, the &lt;a href=&quot;qfontmetrics&quot;&gt;QFontMetrics&lt;/a&gt; class provides the font measurements, and the &lt;a href=&quot;qfontdatabase&quot;&gt;QFontDatabase&lt;/a&gt; class provides information about the fonts available in the underlying window system.</source>
          <target state="translated">绘制文本时，使用&lt;a href=&quot;qfont&quot;&gt;QFont&lt;/a&gt;类指定字体。Qt将使用具有指定属性的字体，或者如果不存在匹配的字体，则Qt将使用最接近的匹配安装字体。可以使用&lt;a href=&quot;qfontinfo&quot;&gt;QFontInfo&lt;/a&gt;类来检索实际使用的字体的属性。此外，&lt;a href=&quot;qfontmetrics&quot;&gt;QFontMetrics&lt;/a&gt;类提供字体测量，而&lt;a href=&quot;qfontdatabase&quot;&gt;QFontDatabase&lt;/a&gt;类提供有关基础窗口系统中可用字体的信息。</target>
        </trans-unit>
        <trans-unit id="2b8fa7bd4261a029b6f3fdf343d1e4a3de0c8942" translate="yes" xml:space="preserve">
          <source>When drawing with &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;, we specify points using logical coordinates which then are converted into the physical coordinates of the paint device.</source>
          <target state="translated">使用&lt;a href=&quot;qpainter&quot;&gt;QPainter进行&lt;/a&gt;绘制时，我们使用逻辑坐标指定点，然后将其转换为绘画设备的物理坐标。</target>
        </trans-unit>
        <trans-unit id="410e5ecacd6f13933f5b02a517c03bf075b15730" translate="yes" xml:space="preserve">
          <source>When drawing with &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;, we specify points using logical coordinates which then are converted into the physical coordinates of the paint device. The mapping of the logical coordinates to the physical coordinates are handled by &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;'s &lt;a href=&quot;qpainter#combinedTransform&quot;&gt;combinedTransform&lt;/a&gt;(), a combination of &lt;a href=&quot;qpainter#viewport&quot;&gt;viewport&lt;/a&gt;() and &lt;a href=&quot;qpainter#window&quot;&gt;window&lt;/a&gt;() and &lt;a href=&quot;qpainter#worldTransform&quot;&gt;worldTransform&lt;/a&gt;(). The &lt;a href=&quot;qpainter#viewport&quot;&gt;viewport&lt;/a&gt;() represents the physical coordinates specifying an arbitrary rectangle, the &lt;a href=&quot;qpainter#window&quot;&gt;window&lt;/a&gt;() describes the same rectangle in logical coordinates, and the &lt;a href=&quot;qpainter#worldTransform&quot;&gt;worldTransform&lt;/a&gt;() is identical with the transformation matrix.</source>
          <target state="translated">使用&lt;a href=&quot;qpainter&quot;&gt;QPainter进行&lt;/a&gt;绘制时，我们使用逻辑坐标指定点，然后将其转换为绘画设备的物理坐标。逻辑坐标到物理坐标的映射由&lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;的&lt;a href=&quot;qpainter#combinedTransform&quot;&gt;CombinedTransform&lt;/a&gt;（），&lt;a href=&quot;qpainter#viewport&quot;&gt;viewport&lt;/a&gt;（）和&lt;a href=&quot;qpainter#window&quot;&gt;window&lt;/a&gt;（）以及&lt;a href=&quot;qpainter#worldTransform&quot;&gt;worldTransform&lt;/a&gt;（）的组合处理。该&lt;a href=&quot;qpainter#viewport&quot;&gt;视口&lt;/a&gt;（）表示指定任意矩形的物理坐标，所述&lt;a href=&quot;qpainter#window&quot;&gt;窗口&lt;/a&gt;（）描述了在逻辑坐标相同的矩形，并且&lt;a href=&quot;qpainter#worldTransform&quot;&gt;worldTransform&lt;/a&gt;（）是与所述变换矩阵是相同的。</target>
        </trans-unit>
        <trans-unit id="fa068ff4a5704af2221f41b1b4da90e1a41df12c" translate="yes" xml:space="preserve">
          <source>When drawing with QPainter, we specify points using logical coordinates which then are converted into the physical coordinates of the paint device. The mapping of the logical coordinates to the physical coordinates are handled by QPainter's &lt;a href=&quot;qpainter#combinedTransform&quot;&gt;combinedTransform&lt;/a&gt;(), a combination of &lt;a href=&quot;qpainter#viewport&quot;&gt;viewport&lt;/a&gt;() and &lt;a href=&quot;qpainter#window&quot;&gt;window&lt;/a&gt;() and &lt;a href=&quot;qpainter#worldTransform&quot;&gt;worldTransform&lt;/a&gt;(). The &lt;a href=&quot;qpainter#viewport&quot;&gt;viewport&lt;/a&gt;() represents the physical coordinates specifying an arbitrary rectangle, the &lt;a href=&quot;qpainter#window&quot;&gt;window&lt;/a&gt;() describes the same rectangle in logical coordinates, and the &lt;a href=&quot;qpainter#worldTransform&quot;&gt;worldTransform&lt;/a&gt;() is identical with the transformation matrix.</source>
          <target state="translated">使用QPainter进行绘制时，我们使用逻辑坐标指定点，然后将其转换为绘画设备的物理坐标。逻辑坐标到物理坐标的映射由QPainter的&lt;a href=&quot;qpainter#combinedTransform&quot;&gt;CombinedTransform&lt;/a&gt;（），&lt;a href=&quot;qpainter#viewport&quot;&gt;viewport&lt;/a&gt;（）和&lt;a href=&quot;qpainter#window&quot;&gt;window&lt;/a&gt;（）以及&lt;a href=&quot;qpainter#worldTransform&quot;&gt;worldTransform&lt;/a&gt;（）的组合处理。该&lt;a href=&quot;qpainter#viewport&quot;&gt;视口&lt;/a&gt;（）表示指定任意矩形的物理坐标，所述&lt;a href=&quot;qpainter#window&quot;&gt;窗口&lt;/a&gt;（）描述了在逻辑坐标相同的矩形，并且&lt;a href=&quot;qpainter#worldTransform&quot;&gt;worldTransform&lt;/a&gt;（）是与所述变换矩阵是相同的。</target>
        </trans-unit>
        <trans-unit id="c5ed330ed405cc570c36b8d34b32b0e9f282124b" translate="yes" xml:space="preserve">
          <source>When drawing, the pixel rendering is controlled by the &lt;a href=&quot;qpainter#RenderHint-enum&quot;&gt;QPainter::Antialiasing&lt;/a&gt; render hint.</source>
          <target state="translated">绘制时，像素渲染由&lt;a href=&quot;qpainter#RenderHint-enum&quot;&gt;QPainter :: Antialiasing&lt;/a&gt;渲染提示控制。</target>
        </trans-unit>
        <trans-unit id="d15b0d71322e99bde4953dbe90c85c3ef7baf9a0" translate="yes" xml:space="preserve">
          <source>When drawing, the pixel rendering is controlled by the &lt;a href=&quot;qpainter#RenderHint-enum&quot;&gt;QPainter::Antialiasing&lt;/a&gt; render hint. The &lt;a href=&quot;qpainter#RenderHint-enum&quot;&gt;QPainter::RenderHint&lt;/a&gt; enum is used to specify flags to &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; that may or may not be respected by any given engine.</source>
          <target state="translated">绘制时，像素渲染由&lt;a href=&quot;qpainter#RenderHint-enum&quot;&gt;QPainter :: Antialiasing&lt;/a&gt;渲染提示控制。该&lt;a href=&quot;qpainter#RenderHint-enum&quot;&gt;QPainter的:: RenderHint&lt;/a&gt;枚举用于指定标志来&lt;a href=&quot;qpainter&quot;&gt;了QPainter&lt;/a&gt;可能会或可能不会被任何给定的发动机尊重。</target>
        </trans-unit>
        <trans-unit id="6ebdf8b96fea44b5a3aed78415b3fda3d62aa0c1" translate="yes" xml:space="preserve">
          <source>When driving animations, this function should be called once after drawing has completed. Calling this function multiple times will result in a single event being delivered to the window.</source>
          <target state="translated">当驱动动画时,该函数应在绘制完成后调用一次。多次调用此函数将导致一个事件被传递到窗口。</target>
        </trans-unit>
        <trans-unit id="1ce5dba37bb8921ab742160f013368e5f3259059" translate="yes" xml:space="preserve">
          <source>When duplicate skipping is enabled, successive readings with the same or very similar values are omitted. This helps reducing the amount of processing done, as less sensor readings are made available. As a consequence, readings arrive at an irregular interval.</source>
          <target state="translated">当启用重复跳过时,具有相同或非常相似值的连续读数将被省略。这有助于减少处理量,因为可用的传感器读数较少。因此,读数会以不规则的间隔到达。</target>
        </trans-unit>
        <trans-unit id="d5e3a8786c0102ae5523b4a9dad7cca51f61d1c8" translate="yes" xml:space="preserve">
          <source>When each primitive is large, this overhead is negligible, but in the case of a typical UI, there are many small items which add up to a considerable overhead.</source>
          <target state="translated">当每个基元都很大的时候,这个开销可以忽略不计,但是在典型的UI中,有很多小项会增加相当大的开销。</target>
        </trans-unit>
        <trans-unit id="cbc38d0da8ee345ba2fd00eef535419aae91f344" translate="yes" xml:space="preserve">
          <source>When editing data in an item view, &lt;a href=&quot;qitemdelegate&quot;&gt;QItemDelegate&lt;/a&gt; provides an editor widget, which is a widget that is placed on top of the view while editing takes place. Editors are created with a &lt;a href=&quot;qitemeditorfactory&quot;&gt;QItemEditorFactory&lt;/a&gt;; a default static instance provided by &lt;a href=&quot;qitemeditorfactory&quot;&gt;QItemEditorFactory&lt;/a&gt; is installed on all item delegates. You can set a custom factory using &lt;a href=&quot;qitemdelegate#setItemEditorFactory&quot;&gt;setItemEditorFactory&lt;/a&gt;() or set a new default factory with &lt;a href=&quot;qitemeditorfactory#setDefaultFactory&quot;&gt;QItemEditorFactory::setDefaultFactory&lt;/a&gt;(). It is the data stored in the item model with the &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;Qt::EditRole&lt;/a&gt; that is edited.</source>
          <target state="translated">在项目视图中编辑数据时，&lt;a href=&quot;qitemdelegate&quot;&gt;QItemDelegate&lt;/a&gt;提供了一个编辑器窗口小部件，该窗口小部件是在进行编辑时置于视图顶部的窗口小部件。使用&lt;a href=&quot;qitemeditorfactory&quot;&gt;QItemEditorFactory&lt;/a&gt;创建编辑器；由&lt;a href=&quot;qitemeditorfactory&quot;&gt;QItemEditorFactory&lt;/a&gt;提供的默认静态实例安装在所有项目委托上。您可以使用&lt;a href=&quot;qitemdelegate#setItemEditorFactory&quot;&gt;setItemEditorFactory&lt;/a&gt;（）设置自定义工厂，也可以使用&lt;a href=&quot;qitemeditorfactory#setDefaultFactory&quot;&gt;QItemEditorFactory :: setDefaultFactory&lt;/a&gt;（）设置新的默认工厂。使用&lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;Qt :: EditRole&lt;/a&gt;编辑的是存储在项目模型中的数据。</target>
        </trans-unit>
        <trans-unit id="e3121493bb1879d53220fddb4bd4e0247d179ffd" translate="yes" xml:space="preserve">
          <source>When editing data in an item view, QItemDelegate provides an editor widget, which is a widget that is placed on top of the view while editing takes place. Editors are created with a &lt;a href=&quot;qitemeditorfactory&quot;&gt;QItemEditorFactory&lt;/a&gt;; a default static instance provided by &lt;a href=&quot;qitemeditorfactory&quot;&gt;QItemEditorFactory&lt;/a&gt; is installed on all item delegates. You can set a custom factory using &lt;a href=&quot;qitemdelegate#setItemEditorFactory&quot;&gt;setItemEditorFactory&lt;/a&gt;() or set a new default factory with &lt;a href=&quot;qitemeditorfactory#setDefaultFactory&quot;&gt;QItemEditorFactory::setDefaultFactory&lt;/a&gt;(). It is the data stored in the item model with the &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;Qt::EditRole&lt;/a&gt; that is edited.</source>
          <target state="translated">在项目视图中编辑数据时，QItemDelegate提供了一个编辑器窗口小部件，该窗口小部件是在进行编辑时置于视图顶部的窗口小部件。编辑器是使用&lt;a href=&quot;qitemeditorfactory&quot;&gt;QItemEditorFactory&lt;/a&gt;创建的；由&lt;a href=&quot;qitemeditorfactory&quot;&gt;QItemEditorFactory&lt;/a&gt;提供的默认静态实例安装在所有项目委托上。您可以使用&lt;a href=&quot;qitemdelegate#setItemEditorFactory&quot;&gt;setItemEditorFactory&lt;/a&gt;（）设置自定义工厂，也可以使用&lt;a href=&quot;qitemeditorfactory#setDefaultFactory&quot;&gt;QItemEditorFactory :: setDefaultFactory&lt;/a&gt;（）设置新的默认工厂。将使用&lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;Qt :: EditRole&lt;/a&gt;编辑存储在项目模型中的数据。</target>
        </trans-unit>
        <trans-unit id="6f6344a0186d030dc605de997efbebf65f1b9a99" translate="yes" xml:space="preserve">
          <source>When editing data in an item view, editors are created and displayed by a delegate. &lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate&lt;/a&gt;, which is the delegate by default installed on Qt's item views, uses a &lt;a href=&quot;qitemeditorfactory&quot;&gt;QItemEditorFactory&lt;/a&gt; to create editors for it. A default unique instance provided by &lt;a href=&quot;qitemeditorfactory&quot;&gt;QItemEditorFactory&lt;/a&gt; is used by all item delegates. If you set a new default factory with &lt;a href=&quot;qitemeditorfactory#setDefaultFactory&quot;&gt;setDefaultFactory&lt;/a&gt;(), the new factory will be used by existing and new delegates.</source>
          <target state="translated">在项目视图中编辑数据时，将由委托创建并显示编辑器。&lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate&lt;/a&gt;是默认安装在Qt的项目视图上的委托，它使用&lt;a href=&quot;qitemeditorfactory&quot;&gt;QItemEditorFactory&lt;/a&gt;为其创建编辑器。所有项目委托都使用&lt;a href=&quot;qitemeditorfactory&quot;&gt;QItemEditorFactory&lt;/a&gt;提供的默认唯一实例。如果使用&lt;a href=&quot;qitemeditorfactory#setDefaultFactory&quot;&gt;setDefaultFactory&lt;/a&gt;（）设置新的默认工厂，则现有和新的委托将使用新工厂。</target>
        </trans-unit>
        <trans-unit id="4e2f4a385e37cf62cf1b97e80df94ad25fd55a99" translate="yes" xml:space="preserve">
          <source>When editing data in an item view, editors are created and displayed by a delegate. &lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate&lt;/a&gt;, which is the delegate by default installed on Qt's item views, uses a QItemEditorFactory to create editors for it. A default unique instance provided by QItemEditorFactory is used by all item delegates. If you set a new default factory with &lt;a href=&quot;qitemeditorfactory#setDefaultFactory&quot;&gt;setDefaultFactory&lt;/a&gt;(), the new factory will be used by existing and new delegates.</source>
          <target state="translated">在项目视图中编辑数据时，将由委托创建并显示编辑器。&lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate&lt;/a&gt;是默认安装在Qt的项目视图上的委托，它使用QItemEditorFactory为其创建编辑器。所有项目委托都使用QItemEditorFactory提供的默认唯一实例。如果使用&lt;a href=&quot;qitemeditorfactory#setDefaultFactory&quot;&gt;setDefaultFactory&lt;/a&gt;（）设置新的默认工厂，则现有和新的委托将使用新工厂。</target>
        </trans-unit>
        <trans-unit id="c0e7a6ec88186d061ca22e9701050d741f30a191" translate="yes" xml:space="preserve">
          <source>When editing is finished, either because the line edit lost focus or Return/Enter is pressed the &lt;a href=&quot;qlineedit#editingFinished&quot;&gt;editingFinished&lt;/a&gt;() signal is emitted.</source>
          <target state="translated">编辑完成后，由于行编辑失去焦点或按了Return / Enter键，将发出&lt;a href=&quot;qlineedit#editingFinished&quot;&gt;editFinished&lt;/a&gt;（）信号。</target>
        </trans-unit>
        <trans-unit id="d66bfe606de9465976bab385d92db6b5ec57c788" translate="yes" xml:space="preserve">
          <source>When editing of an item starts, this function is called with the</source>
          <target state="translated">当一个项目的编辑开始时,这个函数的调用是以</target>
        </trans-unit>
        <trans-unit id="b9a4a24a7b2e2cf96998146b51d4cf55a3e5c82a" translate="yes" xml:space="preserve">
          <source>When enabled and the label shows a pixmap, it will scale the pixmap to fill the available space.</source>
          <target state="translated">当启用时,标签上显示的是一张像素图,它将缩放像素图以填充可用空间。</target>
        </trans-unit>
        <trans-unit id="ad099014b60b35f0bc78bdb765b7842a9c27ccc5" translate="yes" xml:space="preserve">
          <source>When enabled, making a Shape visible will not wait for the content to become available. Instead, the GUI/main thread is not blocked and the results of the path rendering are shown only when all the asynchronous work has been finished.</source>
          <target state="translated">启用后,使Shape可见将不会等待内容可用,相反,GUI/主线程不会被阻塞,只有在所有异步工作完成后才会显示路径渲染结果。相反,GUI/主线程不会被阻塞,只有当所有异步工作完成后,才会显示路径渲染的结果。</target>
        </trans-unit>
        <trans-unit id="809e3c2e92b5437339d00438d8ac5682f3c1094a" translate="yes" xml:space="preserve">
          <source>When enabled, making a Shape visible will not wait for the content to become available. Instead, the gui/main thread is not blocked and the results of the path rendering are shown only when all the asynchronous work has been finished.</source>
          <target state="translated">启用后,使Shape可见将不会等待内容可用,相反,gui/main线程不会被阻塞,只有在所有异步工作完成后才会显示路径渲染结果。相反,gui/main线程不会被阻塞,只有当所有异步工作完成后,才会显示路径渲染的结果。</target>
        </trans-unit>
        <trans-unit id="fee807f59e511b5dcbfdf0c512929f1021ab0586" translate="yes" xml:space="preserve">
          <source>When enabled, the renderer performs a Z-prepass for opaque objects, meaning it renders them with a simple shader and color write disabled in order to get the depth buffer pre-filled before issuing draw calls for the main rendering passes.</source>
          <target state="translated">当启用时,渲染器会对不透明对象执行Z-prepass,这意味着它将在简单的着色器和禁用颜色写入的情况下渲染它们,以便在为主渲染通道发出绘制调用之前预先填充深度缓冲区。</target>
        </trans-unit>
        <trans-unit id="fef9dffa012fb5631fc857fa121adc562514620b" translate="yes" xml:space="preserve">
          <source>When enabled, this attribute disables the delivery of mouse events to the widget and its children. Mouse events are delivered to other widgets as if the widget and its children were not present in the widget hierarchy; mouse clicks and other events effectively &quot;pass through&quot; them. This attribute is disabled by default.</source>
          <target state="translated">启用时,此属性可禁用向小组件及其子代传递鼠标事件。鼠标事件会传递给其他小组件,就像小组件及其子代不存在于小组件层次结构中一样;鼠标点击和其他事件会有效地 &quot;穿过 &quot;它们。此属性默认为禁用。</target>
        </trans-unit>
        <trans-unit id="482662a30996d40d4a1c18a3374e7b2c360e9d38" translate="yes" xml:space="preserve">
          <source>When entering &quot;What's This?&quot; mode, a &lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt; of type Qt::EnterWhatsThisMode is sent to all toplevel widgets.</source>
          <target state="translated">输入&amp;ldquo;这是什么？&amp;rdquo;时 模式下，将Qt :: EnterWhatsThisMode类型的&lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt;发送到所有顶级小部件。</target>
        </trans-unit>
        <trans-unit id="6190eb6bb23c0ba0b8cd55075c9df2ea7f1a0eef" translate="yes" xml:space="preserve">
          <source>When executed together with the source-side example, the output is identical to &lt;a href=&quot;#qtro-example1&quot;&gt;Example 1&lt;/a&gt;.</source>
          <target state="translated">与源代码端示例一起执行时，输出与&lt;a href=&quot;#qtro-example1&quot;&gt;示例1&lt;/a&gt;相同。</target>
        </trans-unit>
        <trans-unit id="c6558b3205936d1c2767fe9741a81481ab905734" translate="yes" xml:space="preserve">
          <source>When executed, QDoc will exclude the listed directories from further consideration. Files in these directories will not be read by QDoc.</source>
          <target state="translated">当执行时,QDoc将把列出的目录排除在进一步的考虑范围之外,这些目录中的文件将不会被QDoc读取。这些目录中的文件将不会被QDoc读取。</target>
        </trans-unit>
        <trans-unit id="c9a96d672de3f61af853bd3fb2b4ddb09401c17a" translate="yes" xml:space="preserve">
          <source>When executed, QDoc will exclude the listed directories from further consideration. Files in these directories will not be read by qdoc.</source>
          <target state="translated">执行时,QDoc将把列出的目录排除在进一步的考虑之外。这些目录中的文件将不会被qdoc读取。</target>
        </trans-unit>
        <trans-unit id="f0b8e30c664f1e368519b1a60f634e4ae26e999b" translate="yes" xml:space="preserve">
          <source>When executed, QDoc will ignore the directories listed. &lt;b&gt;See also&lt;/b&gt;: &lt;a href=&quot;22-qdoc-configuration-generalvariables#excludefiles&quot;&gt;excludefiles&lt;/a&gt;.</source>
          <target state="translated">执行后，QDoc将忽略列出的目录。&lt;b&gt;另请参阅&lt;/b&gt;：&lt;a href=&quot;22-qdoc-configuration-generalvariables#excludefiles&quot;&gt;excludefiles&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ca04becdda83845f40b583b367041236f99a3f37" translate="yes" xml:space="preserve">
          <source>When executed, the first thing QDoc will do is to read through the headers specified in the &lt;a href=&quot;#headers&quot;&gt;&lt;code&gt;headers&lt;/code&gt;&lt;/a&gt; variable, and the ones located in the directories specified in the &lt;code&gt;headerdir&lt;/code&gt; variable (including all subdirectories), building an internal structure of the classes and their functions.</source>
          <target state="translated">执行后，QDoc要做的第一件事是通读&lt;a href=&quot;#headers&quot;&gt; &lt;code&gt;headers&lt;/code&gt; &lt;/a&gt;变量中指定的头文件以及 &lt;code&gt;headerdir&lt;/code&gt; 变量中指定的目录（包括所有子目录）中的目录，从而建立类及其函数的内部结构。</target>
        </trans-unit>
        <trans-unit id="5cb7e1f93541ac06ba092ca034af95b10f030b3f" translate="yes" xml:space="preserve">
          <source>When executed, the first thing QDoc will do is to read through the headers specified in the &lt;a href=&quot;10-qdoc-commands-tablesandlists#header-command&quot;&gt;&lt;code&gt;header&lt;/code&gt;&lt;/a&gt; variable, and the ones located in the directories specified in the &lt;code&gt;headerdir&lt;/code&gt; variable (including all subdirectories), building an internal structure of the classes and their functions.</source>
          <target state="translated">当执行时，QDoc要做的第一件事是通读&lt;a href=&quot;10-qdoc-commands-tablesandlists#header-command&quot;&gt; &lt;code&gt;header&lt;/code&gt; &lt;/a&gt;变量中指定的头文件，以及位于 &lt;code&gt;headerdir&lt;/code&gt; 变量中指定目录（包括所有子目录）中的文件头，建立类及其函数的内部结构。</target>
        </trans-unit>
        <trans-unit id="6f35fb24ec304ed2925435889439bd5ef8cff940" translate="yes" xml:space="preserve">
          <source>When executed, the first thing QDoc will do is to read through the headers specified in the &lt;a href=&quot;22-qdoc-configuration-generalvariables#headers&quot;&gt;&lt;code&gt;headers&lt;/code&gt;&lt;/a&gt; variable, and the ones located in the directories specified in the &lt;code&gt;headerdir&lt;/code&gt; variable (including all subdirectories), building an internal structure of the classes and their functions.</source>
          <target state="translated">当执行时，QDoc要做的第一件事是通读&lt;a href=&quot;22-qdoc-configuration-generalvariables#headers&quot;&gt; &lt;code&gt;headers&lt;/code&gt; &lt;/a&gt;变量中指定的头文件，以及位于 &lt;code&gt;headerdir&lt;/code&gt; 变量中指定目录（包括所有子目录）中的目录，建立类及其函数的内部结构。</target>
        </trans-unit>
        <trans-unit id="5c560866c3cc063739dbdcc11819b706f643936b" translate="yes" xml:space="preserve">
          <source>When expanding environment variables, the &lt;code&gt;${variable}&lt;/code&gt; syntax has different behavior compared to &lt;code&gt;$variable&lt;/code&gt;. The former expands the content of the variable in place to be parsed as part of the configuration file, while the latter simply assigns the content as a value for the current configuration variable. This has implications if the environment variable contains a list of elements separated by whitespace, or other formatting recognized by QDoc.</source>
          <target state="translated">在扩展环境变量，在 &lt;code&gt;${variable}&lt;/code&gt; 语法相比具有不同的行为 &lt;code&gt;$variable&lt;/code&gt; 。前者将变量的内容扩展到适当位置以作为配置文件的一部分进行解析，而后者只是将内容分配为当前配置变量的值。如果环境变量包含由空格或QDoc识别的其他格式分隔的元素列表，则可能会产生影响。</target>
        </trans-unit>
        <trans-unit id="09ffff96391333a52eee7a9ad80e057863c3ba11" translate="yes" xml:space="preserve">
          <source>When expanding is true &lt;a href=&quot;qtabbar&quot;&gt;QTabBar&lt;/a&gt; will expand the tabs to use the empty space.</source>
          <target state="translated">当扩展为true时，&lt;a href=&quot;qtabbar&quot;&gt;QTabBar&lt;/a&gt;将扩展选项卡以使用空白空间。</target>
        </trans-unit>
        <trans-unit id="2620b86db1234798b63f39503859611b9649e059" translate="yes" xml:space="preserve">
          <source>When exporting 9-patch images in several DPI variants (&lt;code&gt;@2x&lt;/code&gt;, &lt;code&gt;@3x&lt;/code&gt;, etc.), the 9-patch lines will typically be scaled up along with the image. There are several ways to fix this, but perhaps the simplest approach is to use &lt;a href=&quot;https://www.imagemagick.org/script/mogrify.php&quot;&gt;ImageMagick's mogrify&lt;/a&gt; tool. The tool has a &lt;code&gt;-shave&lt;/code&gt; feature that can be used to crop the image to reduce the thickness of the 9-patch lines:</source>
          <target state="translated">当导出几种DPI变体（ &lt;code&gt;@2x&lt;/code&gt; ， &lt;code&gt;@3x&lt;/code&gt; 等）的9补丁图像时，通常会与图像一起放大9补丁线。有几种解决方法，但也许最简单的方法是使用&lt;a href=&quot;https://www.imagemagick.org/script/mogrify.php&quot;&gt;ImageMagick的迁移&lt;/a&gt;工具。该工具具有 &lt;code&gt;-shave&lt;/code&gt; 功能，可用于裁剪图像以减小9面线的厚度：</target>
        </trans-unit>
        <trans-unit id="70acf7a58788a901870142345c474b753e5c2cea" translate="yes" xml:space="preserve">
          <source>When extending &lt;code&gt;QtService&lt;/code&gt;, you need to declare other items for loading all the necessary libs required for Qt, mainly the same items as in &lt;code&gt;&amp;lt;activity&amp;gt;&lt;/code&gt; section for &lt;code&gt;QtActivity&lt;/code&gt;. Add the following:</source>
          <target state="translated">扩展 &lt;code&gt;QtService&lt;/code&gt; 时，需要声明其他项来加载Qt所需的所有必需的库，这些项主要与 &lt;code&gt;QtActivity&lt;/code&gt; 的 &lt;code&gt;&amp;lt;activity&amp;gt;&lt;/code&gt; 部分中的项相同。添加以下内容：</target>
        </trans-unit>
        <trans-unit id="e5abd3482bf0f9993496037be30182385378e5e2" translate="yes" xml:space="preserve">
          <source>When extending &lt;code&gt;Service&lt;/code&gt;, just declare the service section as a normal Android service. Add the following inside the &lt;code&gt;&amp;lt;application&amp;gt;&lt;/code&gt; section:</source>
          <target state="translated">扩展 &lt;code&gt;Service&lt;/code&gt; 时，只需将service部分声明为正常的Android服务。在 &lt;code&gt;&amp;lt;application&amp;gt;&lt;/code&gt; 部分中添加以下内容：</target>
        </trans-unit>
        <trans-unit id="dd92947bef2cbe270c8052641e8c3450b891b43e" translate="yes" xml:space="preserve">
          <source>When extending QML with C++ code, a C++ class can be registered with the QML type system to enable the class to be used as a data type within QML code. While the properties, methods and signals of any &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;-derived class are accessible from QML, as discussed in &lt;a href=&quot;qtqml-cppintegration-exposecppattributes&quot;&gt;Exposing Attributes of C++ Types to QML&lt;/a&gt;, such a class cannot be used as a data type from QML until it is registered with the type system. Additionally registration can provide other features, such as allowing a class to be used as an instantiable &lt;a href=&quot;qtqml-typesystem-objecttypes&quot;&gt;QML object type&lt;/a&gt; from QML, or enabling a singleton instance of the class to be imported and used from QML.</source>
          <target state="translated">使用C ++代码扩展QML时，可以在QML类型系统中注册C ++类，以使该类可用作QML代码中的数据类型。从QML可以访问任何&lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;派生类的属性，方法和信号，如&lt;a href=&quot;qtqml-cppintegration-exposecppattributes&quot;&gt;将C ++类型的属性暴露&lt;/a&gt;给QML中所讨论的那样，此类类不能用作QML的数据类型，除非将其注册到类型系统中。另外，注册可以提供其他功能，例如允许从QML将类用作可实例化的&lt;a href=&quot;qtqml-typesystem-objecttypes&quot;&gt;QML对象类型&lt;/a&gt;，或者允许从QML导入和使用该类的单例实例。</target>
        </trans-unit>
        <trans-unit id="426d2b133ccf9d0aab48e582602ba3229910acac" translate="yes" xml:space="preserve">
          <source>When extending QML with C++ code, a C++ class can be registered with the QML type system to enable the class to be used as a data type within QML code. While the properties, methods and signals of any &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;-derived class are accessible from QML, as discussed in &lt;a href=&quot;qtqml-cppintegration-exposecppattributes#&quot;&gt;Exposing Attributes of C++ Types to QML&lt;/a&gt;, such a class cannot be used as a data type from QML until it is registered with the type system. Additionally registration can provide other features, such as allowing a class to be used as an instantiable &lt;a href=&quot;qtqml-typesystem-objecttypes#&quot;&gt;QML object type&lt;/a&gt; from QML, or enabling a singleton instance of the class to be imported and used from QML.</source>
          <target state="translated">使用C ++代码扩展QML时，可以在QML类型系统中注册C ++类，以使该类可用作QML代码中的数据类型。从QML可以访问任何&lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;派生类的属性，方法和信号，如&lt;a href=&quot;qtqml-cppintegration-exposecppattributes#&quot;&gt;将C ++类型的属性暴露&lt;/a&gt;给QML所讨论的那样，只有在将其注册到类型系统后，此类才能用作QML的数据类型。另外，注册还可以提供其他功能，例如允许从QML 将类用作可实例化的&lt;a href=&quot;qtqml-typesystem-objecttypes#&quot;&gt;QML对象类型&lt;/a&gt;，或者允许从QML导入和使用该类的单例实例。</target>
        </trans-unit>
        <trans-unit id="9db3502d0d4498df3a64124b7eb7242bd03e84ad" translate="yes" xml:space="preserve">
          <source>When generating DITA XML, qdoc outputs the nested</source>
          <target state="translated">在生成DITA XML时,qdoc输出嵌套的</target>
        </trans-unit>
        <trans-unit id="6359268011bd2e23ea07a88afa77e4d08fbb1147" translate="yes" xml:space="preserve">
          <source>When generating the reference documentation for a class, QDoc will create and link to a separate page documenting its obsolete functions. Usually an equivalent function is provided as an alternative.</source>
          <target state="translated">当为一个类生成参考文档时,QDoc将创建并链接到一个单独的页面,记录其过时的函数。通常会提供一个等价的函数作为替代。</target>
        </trans-unit>
        <trans-unit id="71f447939a909dfa27ce949444c9508a3a7d93da" translate="yes" xml:space="preserve">
          <source>When getting started with developing on a given embedded device, it is often necessary to verify the behavior of the device and drivers, and that the connected displays are working as they should. One easy way is to use the hellowindow example. Launching it with &lt;code&gt;-platform eglfs --multiscreen --timeout&lt;/code&gt; arguments shows a rotating Qt logo on each connected screen for a few seconds.</source>
          <target state="translated">开始在给定的嵌入式设备上进行开发时，通常需要验证设备和驱动程序的行为，以及所连接的显示器是否按预期工作。一种简单的方法是使用hellowindow示例。使用 &lt;code&gt;-platform eglfs --multiscreen --timeout&lt;/code&gt; 参数启动它会在每个连接的屏幕上显示旋转的Qt徽标几秒钟。</target>
        </trans-unit>
        <trans-unit id="b8ddc3778afe40355df31ec30ad7ce29680583ba" translate="yes" xml:space="preserve">
          <source>When handling the signal with &lt;code&gt;onLoadingChanged&lt;/code&gt;, various read-only parameters are available on the &lt;a href=&quot;qml-qtwebengine-webengineloadrequest&quot;&gt;WebEngineLoadRequest&lt;/a&gt; specified by</source>
          <target state="translated">当处理与信号 &lt;code&gt;onLoadingChanged&lt;/code&gt; ，各种只读参数都可以在&lt;a href=&quot;qml-qtwebengine-webengineloadrequest&quot;&gt;WebEngineLoadRequest&lt;/a&gt;指定由</target>
        </trans-unit>
        <trans-unit id="dd3376f42ea41d22705767c518b03411a09688ef" translate="yes" xml:space="preserve">
          <source>When handling this signal, changing the &lt;a href=&quot;qml-qtquick-mouseevent#accepted-prop&quot;&gt;accepted&lt;/a&gt; property of the</source>
          <target state="translated">在处理这个信号，改变&lt;a href=&quot;qml-qtquick-mouseevent#accepted-prop&quot;&gt;接受&lt;/a&gt;的财产</target>
        </trans-unit>
        <trans-unit id="6609fd77e98998e1210abc85df3c2fabea25a8b3" translate="yes" xml:space="preserve">
          <source>When handling this signal, if the &lt;a href=&quot;qml-qtquick-mouseevent#accepted-prop&quot;&gt;accepted&lt;/a&gt; property of the</source>
          <target state="translated">在处理该信号，如果&lt;a href=&quot;qml-qtquick-mouseevent#accepted-prop&quot;&gt;接受&lt;/a&gt;的财产</target>
        </trans-unit>
        <trans-unit id="b478004d57f010bec2ae3794bb546849c254693f" translate="yes" xml:space="preserve">
          <source>When handling this signal, use the &lt;a href=&quot;qml-qtquick-mouseevent#accepted-prop&quot;&gt;accepted&lt;/a&gt; property of the</source>
          <target state="translated">在处理这个信号，使用&lt;a href=&quot;qml-qtquick-mouseevent#accepted-prop&quot;&gt;公认&lt;/a&gt;的财产</target>
        </trans-unit>
        <trans-unit id="6295b7b616f0d9112be806cf906b2998b3813947" translate="yes" xml:space="preserve">
          <source>When having multiple displays connected, the level of support for targeting one or more of these from one single Qt application varies between the platform plugins and often depends on the device and its graphics stack.</source>
          <target state="translated">当连接了多个显示器时,不同的平台插件对一个或多个显示器的支持程度不同,通常取决于设备及其图形栈。</target>
        </trans-unit>
        <trans-unit id="33cb76c34e5dfbfadb36579df2b883f159a00960" translate="yes" xml:space="preserve">
          <source>When implemented, this function is responsible for checking the paint engine's current</source>
          <target state="translated">实现后,该函数负责检查油漆引擎当前的</target>
        </trans-unit>
        <trans-unit id="cb84a9cfef6f8292ec44602b7462e414abc9870a" translate="yes" xml:space="preserve">
          <source>When implementing a custom extension class, you must use Q_DECLARE_EXTENSION_INTERFACE() to enable usage of the &lt;a href=&quot;qextensionmanager#qt_extension&quot;&gt;qt_extension&lt;/a&gt;() function. The macro is normally located right after the class definition for</source>
          <target state="translated">在实现自定义扩展类时，必须使用Q_DECLARE_EXTENSION_INTERFACE（）启用&lt;a href=&quot;qextensionmanager#qt_extension&quot;&gt;qt_extension&lt;/a&gt;（）函数的使用。该宏通常位于以下类的定义之后</target>
        </trans-unit>
        <trans-unit id="84772bea2f59837a3da39c7af78975341f21eb2b" translate="yes" xml:space="preserve">
          <source>When implementing a custom style, you cannot assume that the widget is a &lt;a href=&quot;qspinbox&quot;&gt;QSpinBox&lt;/a&gt; just because the enum value is called &lt;a href=&quot;qstyle#PrimitiveElement-enum&quot;&gt;PE_IndicatorSpinUp&lt;/a&gt; or &lt;a href=&quot;qstyle#PrimitiveElement-enum&quot;&gt;PE_IndicatorSpinDown&lt;/a&gt;.</source>
          <target state="translated">在实现自定义样式时，不能仅仅因为枚举值称为&lt;a href=&quot;qstyle#PrimitiveElement-enum&quot;&gt;PE_IndicatorSpinUp&lt;/a&gt;或&lt;a href=&quot;qstyle#PrimitiveElement-enum&quot;&gt;PE_IndicatorSpinDown&lt;/a&gt;而就假定该小部件是&lt;a href=&quot;qspinbox&quot;&gt;QSpinBox&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="869ecc6a6e96e1eee7be87f15ad29e53d15bface" translate="yes" xml:space="preserve">
          <source>When implementing a custom widget plugin, a pointer to</source>
          <target state="translated">当实现一个自定义widget插件时,一个指向</target>
        </trans-unit>
        <trans-unit id="b5e58b90ddc89647665b1bcd29b18d24dcef1559" translate="yes" xml:space="preserve">
          <source>When implementing a custom widget plugin, you build it as a separate library. If you want to include several custom widget plugins in the same library, you must in addition subclass &lt;a href=&quot;qdesignercustomwidgetcollectioninterface&quot;&gt;QDesignerCustomWidgetCollectionInterface&lt;/a&gt;.</source>
          <target state="translated">实施自定义窗口小部件插件时，可以将其构建为单独的库。如果要在同一个库中包含几个自定义窗口小部件插件，则还必须另外子类&lt;a href=&quot;qdesignercustomwidgetcollectioninterface&quot;&gt;QDesignerCustomWidgetCollectionInterface&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5ea9264234b2724850203d32239a91745a3b4bcd" translate="yes" xml:space="preserve">
          <source>When implementing a custom widget plugin, you build it as a separate library. If you want to include several custom widget plugins in the same library, you must in addition subclass QDesignerCustomWidgetCollectionInterface.</source>
          <target state="translated">当实现一个自定义widget插件时,你要把它作为一个单独的库来构建。如果你想在同一个库中包含多个自定义widget插件,你必须另外子类QDesignerCustomWidgetCollectionInterface。</target>
        </trans-unit>
        <trans-unit id="4c647a12112d8ed46e7c8ca84107c20d588614b0" translate="yes" xml:space="preserve">
          <source>When implementing a custom widget plugin, you must subclass the &lt;a href=&quot;qdesignercustomwidgetinterface&quot;&gt;QDesignerCustomWidgetInterface&lt;/a&gt; to expose your plugin to</source>
          <target state="translated">实施自定义窗口小部件插件时，必须将&lt;a href=&quot;qdesignercustomwidgetinterface&quot;&gt;QDesignerCustomWidgetInterface&lt;/a&gt;子类化以将插件公开给</target>
        </trans-unit>
        <trans-unit id="91021ae6ff5dfe6164732e25da258734b737eb88" translate="yes" xml:space="preserve">
          <source>When implementing a custom widget you must subclass &lt;a href=&quot;qdesignercustomwidgetinterface&quot;&gt;QDesignerCustomWidgetInterface&lt;/a&gt; to expose your widget to</source>
          <target state="translated">实施自定义窗口小部件时，必须子类&lt;a href=&quot;qdesignercustomwidgetinterface&quot;&gt;QDesignerCustomWidgetInterface&lt;/a&gt;才能将窗口小部件公开给</target>
        </trans-unit>
        <trans-unit id="98de48237e2610b3ed96ebfc3b4b3e1647ecb00b" translate="yes" xml:space="preserve">
          <source>When implementing a custom widget you must subclass QDesignerCustomWidgetInterface to expose your widget to</source>
          <target state="translated">当您实现一个自定义widget时,您必须将QDesignerCustomWidgetInterface子类化,以便将您的widget暴露给</target>
        </trans-unit>
        <trans-unit id="595ba0ecf978bd65b6513cd7266fa82465645c81" translate="yes" xml:space="preserve">
          <source>When implementing a model it is important to remember that &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; does not store any data itself, it merely presents an interface that the views use to access the data. For a minimal read-only model it is only necessary to implement a few functions as there are default implementations for most of the interface. The class declaration is as follows:</source>
          <target state="translated">在实现模型时，重要的是要记住&lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt;本身并不存储任何数据，它仅提供一个视图用来访问数据的接口。对于最小的只读模型，仅需要实现一些功能，因为大多数接口都有默认实现。类声明如下：</target>
        </trans-unit>
        <trans-unit id="445cd07d2a0506cd16ff907563ea7c0e381a4ac2" translate="yes" xml:space="preserve">
          <source>When implementing a new widget, it is almost always useful to reimplement &lt;a href=&quot;qwidget#sizeHint-prop&quot;&gt;sizeHint&lt;/a&gt;() to provide a reasonable default size for the widget and to set the correct size policy with &lt;a href=&quot;qwidget#sizePolicy-prop&quot;&gt;setSizePolicy&lt;/a&gt;().</source>
          <target state="translated">实施新窗口小部件时，重新实现&lt;a href=&quot;qwidget#sizeHint-prop&quot;&gt;sizeHint&lt;/a&gt;（）为窗口小部件提供合理的默认大小并使用&lt;a href=&quot;qwidget#sizePolicy-prop&quot;&gt;setSizePolicy&lt;/a&gt;（）设置正确的大小策略几乎总是有用的。</target>
        </trans-unit>
        <trans-unit id="4c9d446fde723c06b31550398f72ba270ba5a90c" translate="yes" xml:space="preserve">
          <source>When implementing a subclass of this interface, there are only a handful of functions to implement, broken down into two classes:</source>
          <target state="translated">在实现这个接口的子类时,只需要实现少量的功能,分成两个类。</target>
        </trans-unit>
        <trans-unit id="d65384984581a6d6fbb1f4f4bccbb7923f82cdc1" translate="yes" xml:space="preserve">
          <source>When implementing a subclass, you must call this function</source>
          <target state="translated">当实现一个子类时,你必须调用这个函数。</target>
        </trans-unit>
        <trans-unit id="7c18f33bf2a59c6087f18cc24038056a308ad7f2" translate="yes" xml:space="preserve">
          <source>When implementing an accessibility interface for widgets, one would as a rule inherit &lt;a href=&quot;qaccessiblewidget&quot;&gt;QAccessibleWidget&lt;/a&gt;, which is a convenience class for widgets. Another available convenience class, which is inherited by &lt;a href=&quot;qaccessiblewidget&quot;&gt;QAccessibleWidget&lt;/a&gt;, is the &lt;a href=&quot;qaccessibleobject&quot;&gt;QAccessibleObject&lt;/a&gt;, which implements part of the interface for QObjects.</source>
          <target state="translated">当实现窗口小部件的可访问性接口时，通常会继承&lt;a href=&quot;qaccessiblewidget&quot;&gt;QAccessibleWidget&lt;/a&gt;，这是窗口小部件的便捷类。由&lt;a href=&quot;qaccessiblewidget&quot;&gt;QAccessibleWidget&lt;/a&gt;继承的另一个可用的便利类是&lt;a href=&quot;qaccessibleobject&quot;&gt;QAccessibleObject&lt;/a&gt;，它实现了QObjects接口的一部分。</target>
        </trans-unit>
        <trans-unit id="4e43675b73f85281cf7ffd4c9feb92576f97c666" translate="yes" xml:space="preserve">
          <source>When implementing an item model (that is, a concrete &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; subclass) one must abide to a very strict set of rules that ensure consistency for users of the model (views, proxy models, and so on).</source>
          <target state="translated">在实现项目模型（即具体的&lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt;子类）时，必须遵守一组非常严格的规则，以确保模型用户（视图，代理模型等）的一致性。</target>
        </trans-unit>
        <trans-unit id="71c25ae80d1eb821bd312d0369953f3099005788" translate="yes" xml:space="preserve">
          <source>When implementing drag and drop support in a custom model, if you will return data in formats other than the default internal MIME type, reimplement this function to return your list of MIME types.</source>
          <target state="translated">在自定义模型中实现拖放支持时,如果您将以默认内部 MIME 类型以外的格式返回数据,请重新实现此函数以返回您的 MIME 类型列表。</target>
        </trans-unit>
        <trans-unit id="3e1de2caa20c3401ccd297583ca14adb9e36f89e" translate="yes" xml:space="preserve">
          <source>When implementing drag and drop support in a custom model, it is possible to export items of data in specialized formats by reimplementing the following function:</source>
          <target state="translated">在自定义模型中实现拖放支持时,可以通过重新实现以下函数,以特殊格式导出数据项。</target>
        </trans-unit>
        <trans-unit id="891ebe7dedc591934a24e2e5c92f98ba49623d2e" translate="yes" xml:space="preserve">
          <source>When implementing styles, it is necessary to look through the code of the widgets and code of the base class and its ancestors. This is because the widgets use the style differently, because the implementation in the different styles' virtual functions can affect the state of the drawing (e.g., by altering the &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; state without restoring it and drawing some elements without using the appropriate pixel metrics and sub elements).</source>
          <target state="translated">在实现样式时，有必要查看小部件的代码以及基类及其祖先的代码。这是因为窗口小部件使用的样式不同，因为使用不同样式的虚函数的实现可能会影响图形的状态（例如，通过更改&lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;状态而不恢复它，并且绘制某些元素而不使用适当的像素度量和子元素）。元素）。</target>
        </trans-unit>
        <trans-unit id="1c4d91075815fdbbae33aba2b667fd4633c4c3da" translate="yes" xml:space="preserve">
          <source>When implementing the property write function, use &lt;a href=&quot;qaxbindable#requestPropertyChange&quot;&gt;requestPropertyChange&lt;/a&gt;() to get permission from the ActiveX client application to change this property. When the property changes, call &lt;a href=&quot;qaxbindable#propertyChanged&quot;&gt;propertyChanged&lt;/a&gt;() to notify the ActiveX client application about the change. If a fatal error occurs in the control, use the static &lt;a href=&quot;qaxbindable#reportError&quot;&gt;reportError&lt;/a&gt;() function to notify the client.</source>
          <target state="translated">在实现属性写入功能时，请使用&lt;a href=&quot;qaxbindable#requestPropertyChange&quot;&gt;requestPropertyChange&lt;/a&gt;（）从ActiveX客户端应用程序获取权限以更改此属性。当属性更改时，调用&lt;a href=&quot;qaxbindable#propertyChanged&quot;&gt;propertyChanged&lt;/a&gt;（）通知ActiveX客户端应用程序有关更改。如果控件中发生致命错误，请使用静态&lt;a href=&quot;qaxbindable#reportError&quot;&gt;reportError&lt;/a&gt;（）函数通知客户端。</target>
        </trans-unit>
        <trans-unit id="5c75a646668a787fcace5c55f81aa7bf0b70d1c6" translate="yes" xml:space="preserve">
          <source>When implementing the property write functions, use the &lt;a href=&quot;qaxbindable&quot;&gt;QAxBindable&lt;/a&gt; class's requestPropertyChange() and propertyChanged() functions to allow ActiveX clients to bind to the control properties.</source>
          <target state="translated">在实现属性写入功能时，请使用&lt;a href=&quot;qaxbindable&quot;&gt;QAxBindable&lt;/a&gt;类的requestPropertyChange（）和propertyChanged（）函数来允许ActiveX客户端绑定到控件属性。</target>
        </trans-unit>
        <trans-unit id="7b41031e55866a68b8184e142ce7198e2e1fe7ec" translate="yes" xml:space="preserve">
          <source>When implementing this function in subclasses of this class, you must construct and return new editor widgets with the parent widget specified.</source>
          <target state="translated">当在该类的子类中实现该函数时,必须用指定的父部件构造并返回新的编辑器部件。</target>
        </trans-unit>
        <trans-unit id="ca2afb7bc6684dc128113496ad1b730a33a4cb98" translate="yes" xml:space="preserve">
          <source>When implementing this function in subclasses, you must ensure that the editor widget's property specified by this function can accept the type the creator is registered for. For example, a creator which constructs &lt;a href=&quot;qcheckbox&quot;&gt;QCheckBox&lt;/a&gt; widgets to edit boolean values would return the &lt;a href=&quot;qabstractbutton#checkable-prop&quot;&gt;checkable&lt;/a&gt; property name from this function, and must be registered in the item editor factory for the &lt;a href=&quot;qmetatype#Type-enum&quot;&gt;QMetaType::Bool&lt;/a&gt; type.</source>
          <target state="translated">在子类中实现此功能时，必须确保此功能指定的编辑器小部件的属性可以接受创建者注册的类型。例如，构造&lt;a href=&quot;qcheckbox&quot;&gt;QCheckBox&lt;/a&gt;小部件以编辑布尔值的创建者将从该函数返回&lt;a href=&quot;qabstractbutton#checkable-prop&quot;&gt;可检查的&lt;/a&gt;属性名称，并且必须在&lt;a href=&quot;qmetatype#Type-enum&quot;&gt;QMetaType :: Bool&lt;/a&gt;类型的项目编辑器工厂中注册。</target>
        </trans-unit>
        <trans-unit id="1591d2c3ab41219fe3e148cfbb0593be15c3c678" translate="yes" xml:space="preserve">
          <source>When implementing this function in subclasses, you must ensure that the editor widget's property specified by this function can accept the type the creator is registered for. For example, a creator which constructs &lt;a href=&quot;qcheckbox&quot;&gt;QCheckBox&lt;/a&gt; widgets to edit boolean values would return the &lt;a href=&quot;qabstractbutton#checkable-prop&quot;&gt;checkable&lt;/a&gt; property name from this function, and must be registered in the item editor factory for the QVariant::Bool type.</source>
          <target state="translated">在子类中实现此功能时，必须确保此功能指定的编辑器小部件的属性可以接受创建者注册的类型。例如，构造&lt;a href=&quot;qcheckbox&quot;&gt;QCheckBox&lt;/a&gt;小部件以编辑布尔值的创建者将从该函数返回&lt;a href=&quot;qabstractbutton#checkable-prop&quot;&gt;可检查的&lt;/a&gt;属性名称，并且必须在项目编辑器工厂中注册QVariant :: Bool类型。</target>
        </trans-unit>
        <trans-unit id="8ce39d7538e9c5292578832459d332de3effbff1" translate="yes" xml:space="preserve">
          <source>When implementing this interface you will almost certainly also want to implement &lt;a href=&quot;qaccessibletextinterface&quot;&gt;QAccessibleTextInterface&lt;/a&gt;.</source>
          <target state="translated">在实现此接口时，几乎可以肯定也要实现&lt;a href=&quot;qaccessibletextinterface&quot;&gt;QAccessibleTextInterface&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6268d96d04a4d653a0acc9732f0ac32216ce55c6" translate="yes" xml:space="preserve">
          <source>When implementing you own custom graphics transform, you must call this function every time you change a parameter, to let &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; know that its transformation needs to be updated.</source>
          <target state="translated">在实现自己的自定义图形转换时，每次更改参数时都必须调用此函数，以使&lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt;知道需要更新其转换。</target>
        </trans-unit>
        <trans-unit id="e0faa4d1d0c8b9ed5d373ba76a73de237e335d71" translate="yes" xml:space="preserve">
          <source>When implementing your own implicitly shared classes, use the &lt;a href=&quot;qshareddata&quot;&gt;QSharedData&lt;/a&gt; and &lt;a href=&quot;qshareddatapointer&quot;&gt;QSharedDataPointer&lt;/a&gt; classes.</source>
          <target state="translated">When implementing your own implicitly shared classes, use the &lt;a href=&quot;qshareddata&quot;&gt;QSharedData&lt;/a&gt; and &lt;a href=&quot;qshareddatapointer&quot;&gt;QSharedDataPointer&lt;/a&gt; classes.</target>
        </trans-unit>
        <trans-unit id="ed089988e57c5a0f9eb64a54af80f4e4cc7da5be" translate="yes" xml:space="preserve">
          <source>When implementing your own itemview setSelection should call &lt;a href=&quot;qabstractitemview#selectionModel&quot;&gt;selectionModel&lt;/a&gt;()-&amp;gt;select(selection, flags) where selection is either an empty &lt;a href=&quot;qmodelindex&quot;&gt;QModelIndex&lt;/a&gt; or a &lt;a href=&quot;qitemselection&quot;&gt;QItemSelection&lt;/a&gt; that contains all items that are contained in</source>
          <target state="translated">在实现自己的itemview时，setSelection应该调用&lt;a href=&quot;qabstractitemview#selectionModel&quot;&gt;selectionModel&lt;/a&gt;（）-&amp;gt; select（selection，flags），其中selection是空的&lt;a href=&quot;qmodelindex&quot;&gt;QModelIndex&lt;/a&gt;或&lt;a href=&quot;qitemselection&quot;&gt;QItemSelection&lt;/a&gt;，其中包含</target>
        </trans-unit>
        <trans-unit id="90d1ebe5eabb55f03ec9c6da6079f40a2ff77a3d" translate="yes" xml:space="preserve">
          <source>When implementing your own style and customizing controls, there are some points to keep in mind to ensure that your application is as performant as possible.</source>
          <target state="translated">在实现自己的风格和自定义控件时,有一些要点需要牢记,以确保你的应用程序的性能尽可能高。</target>
        </trans-unit>
        <trans-unit id="b13759dc0478b7385db4120f936b29bbec97142e" translate="yes" xml:space="preserve">
          <source>When importing a &lt;a href=&quot;qtqml-typesystem-objecttypes&quot;&gt;QML object type&lt;/a&gt; with a property alias in the root object, however, the property appear as a regular Qt property and consequently can be used in alias references.</source>
          <target state="translated">但是，当在根对象中导入带有属性别名的&lt;a href=&quot;qtqml-typesystem-objecttypes&quot;&gt;QML对象类型&lt;/a&gt;时，该属性显示为常规Qt属性，因此可以在别名引用中使用。</target>
        </trans-unit>
        <trans-unit id="6d2c6cac0080194cff24d54acaddace27ee77592" translate="yes" xml:space="preserve">
          <source>When importing a &lt;a href=&quot;qtqml-typesystem-objecttypes#&quot;&gt;QML object type&lt;/a&gt; with a property alias in the root object, however, the property appear as a regular Qt property and consequently can be used in alias references.</source>
          <target state="translated">但是，当在根对象中导入带有属性别名的&lt;a href=&quot;qtqml-typesystem-objecttypes#&quot;&gt;QML对象类型&lt;/a&gt;时，该属性显示为常规Qt属性，因此可以在别名引用中使用。</target>
        </trans-unit>
        <trans-unit id="63972382ca72bfae9a1039f20443d3527d3f328d" translate="yes" xml:space="preserve">
          <source>When in Running state, &lt;a href=&quot;qtimeline&quot;&gt;QTimeLine&lt;/a&gt; also emits the &lt;a href=&quot;qtimeline#frameChanged&quot;&gt;frameChanged&lt;/a&gt;() signal when the frame changes.</source>
          <target state="translated">当处于运行状态时，当框架改变时，&lt;a href=&quot;qtimeline&quot;&gt;QTimeLine&lt;/a&gt;也会发出&lt;a href=&quot;qtimeline#frameChanged&quot;&gt;frameChanged&lt;/a&gt;（）信号。</target>
        </trans-unit>
        <trans-unit id="ef3e888a5ecf29cb8462a72debc447a17e27543a" translate="yes" xml:space="preserve">
          <source>When in StrictMode, if a parsing error is found, &lt;a href=&quot;qurl#isValid&quot;&gt;isValid&lt;/a&gt;() will return &lt;code&gt;false&lt;/code&gt; and &lt;a href=&quot;qurl#errorString&quot;&gt;errorString&lt;/a&gt;() will return a message describing the error. If more than one error is detected, it is undefined which error gets reported.</source>
          <target state="translated">在StrictMode中时，如果发现解析错误，则&lt;a href=&quot;qurl#isValid&quot;&gt;isValid&lt;/a&gt;（）将返回 &lt;code&gt;false&lt;/code&gt; ,而&lt;a href=&quot;qurl#errorString&quot;&gt;errorString&lt;/a&gt;（）将返回描述该错误的消息。如果检测到多个错误，则不确定报告哪个错误。</target>
        </trans-unit>
        <trans-unit id="3456c56afa83ec7dbd61d985f62e50c29f6549e1" translate="yes" xml:space="preserve">
          <source>When in keyboard-interactive mode, you can use the arrow and page keys to either move or resize the window. This property controls the arrow keys. The common way to enter keyboard interactive mode is to enter the subwindow menu, and select either &quot;resize&quot; or &quot;move&quot;.</source>
          <target state="translated">在键盘交互模式下,可以使用箭头键和页键移动或调整窗口大小。此属性控制方向键。进入键盘交互模式的常用方法是进入子窗口菜单,选择 &quot;调整大小 &quot;或 &quot;移动&quot;。</target>
        </trans-unit>
        <trans-unit id="3fb322ebc9c9cd2d657c0fb9d224a6635a538d7d" translate="yes" xml:space="preserve">
          <source>When in keyboard-interactive mode, you can use the arrow and page keys to either move or resize the window. This property controls the page keys. The common way to enter keyboard interactive mode is to enter the subwindow menu, and select either &quot;resize&quot; or &quot;move&quot;.</source>
          <target state="translated">在键盘交互模式下,可以使用箭头键和页键移动或调整窗口大小。此属性控制页键。进入键盘交互模式的常用方法是进入子窗口菜单,选择 &quot;调整大小 &quot;或 &quot;移动&quot;。</target>
        </trans-unit>
        <trans-unit id="2c08753db2a8aa137364ee7093529568335fe121" translate="yes" xml:space="preserve">
          <source>When inheriting &lt;a href=&quot;qabstractscrollarea&quot;&gt;QAbstractScrollArea&lt;/a&gt;, you need to do the following:</source>
          <target state="translated">继承&lt;a href=&quot;qabstractscrollarea&quot;&gt;QAbstractScrollArea时&lt;/a&gt;，需要执行以下操作：</target>
        </trans-unit>
        <trans-unit id="9110d9a8dc385178c6df16681bf45970bc611881" translate="yes" xml:space="preserve">
          <source>When inheriting QAbstractScrollArea, you need to do the following:</source>
          <target state="translated">在继承QAbstractScrollArea时,你需要做以下工作。</target>
        </trans-unit>
        <trans-unit id="ef5ec1307e1565c3ba533b6306e4c4fb6e84f432" translate="yes" xml:space="preserve">
          <source>When inserting action items you usually specify a receiver and a slot. The receiver will be notifed whenever the item is &lt;a href=&quot;qaction#triggered&quot;&gt;triggered()&lt;/a&gt;. In addition, &lt;a href=&quot;qmenu&quot;&gt;QMenu&lt;/a&gt; provides two signals, &lt;a href=&quot;qmenu#triggered&quot;&gt;triggered&lt;/a&gt;() and &lt;a href=&quot;qmenu#hovered&quot;&gt;hovered&lt;/a&gt;(), which signal the &lt;a href=&quot;qaction&quot;&gt;QAction&lt;/a&gt; that was triggered from the menu.</source>
          <target state="translated">插入动作项目时，通常会指定一个接收器和一个插槽。每当item被&lt;a href=&quot;qaction#triggered&quot;&gt;触发&lt;/a&gt;时，接收者都会收到通知。此外，&lt;a href=&quot;qmenu&quot;&gt;QMenu&lt;/a&gt;提供两个信号，&lt;a href=&quot;qmenu#triggered&quot;&gt;触发&lt;/a&gt;（）和&lt;a href=&quot;qmenu#hovered&quot;&gt;盘旋&lt;/a&gt;（），它用信号通知&lt;a href=&quot;qaction&quot;&gt;的QAction&lt;/a&gt;这是从菜单中触发。</target>
        </trans-unit>
        <trans-unit id="b0a12f123004137273217a41fe960ac1382b53f8" translate="yes" xml:space="preserve">
          <source>When inserting action items you usually specify a receiver and a slot. The receiver will be notifed whenever the item is &lt;a href=&quot;qaction#triggered&quot;&gt;triggered()&lt;/a&gt;. In addition, QMenu provides two signals, &lt;a href=&quot;qmenu#triggered&quot;&gt;triggered&lt;/a&gt;() and &lt;a href=&quot;qmenu#hovered&quot;&gt;hovered&lt;/a&gt;(), which signal the &lt;a href=&quot;qaction&quot;&gt;QAction&lt;/a&gt; that was triggered from the menu.</source>
          <target state="translated">插入动作项目时，通常会指定一个接收器和一个插槽。每当该项被&lt;a href=&quot;qaction#triggered&quot;&gt;触发（）&lt;/a&gt;时，接收者就会收到通知。此外，QMenu提供两个信号，&lt;a href=&quot;qmenu#triggered&quot;&gt;触发&lt;/a&gt;（）和&lt;a href=&quot;qmenu#hovered&quot;&gt;盘旋&lt;/a&gt;（），它用信号通知&lt;a href=&quot;qaction&quot;&gt;的QAction&lt;/a&gt;这是从菜单中触发。</target>
        </trans-unit>
        <trans-unit id="864005fb46a1674119933552576b5eb471667e9c" translate="yes" xml:space="preserve">
          <source>When inserting multiple records, you only need to call &lt;a href=&quot;qsqlquery#prepare&quot;&gt;QSqlQuery::prepare&lt;/a&gt;() once. Then you call &lt;a href=&quot;qsqlquery#bindValue&quot;&gt;bindValue()&lt;/a&gt; or &lt;a href=&quot;qsqlquery#addBindValue&quot;&gt;addBindValue()&lt;/a&gt; followed by &lt;a href=&quot;qsqlquery#exec-1&quot;&gt;exec()&lt;/a&gt; as many times as necessary.</source>
          <target state="translated">插入多个记录时，只需调用一次&lt;a href=&quot;qsqlquery#prepare&quot;&gt;QSqlQuery :: prepare&lt;/a&gt;（）。然后调用&lt;a href=&quot;qsqlquery#bindValue&quot;&gt;bindValue（）&lt;/a&gt;或&lt;a href=&quot;qsqlquery#addBindValue&quot;&gt;addBindValue（） &lt;/a&gt;，然后&lt;a href=&quot;qsqlquery#exec-1&quot;&gt;执行exec（）&lt;/a&gt;多次必要的。</target>
        </trans-unit>
        <trans-unit id="f4a6a2c17602b8ef1614b658343d290c1bd56516" translate="yes" xml:space="preserve">
          <source>When inserting such a fragment into a &lt;a href=&quot;qtextdocument&quot;&gt;QTextDocument&lt;/a&gt; the current char format of the &lt;a href=&quot;qtextcursor&quot;&gt;QTextCursor&lt;/a&gt; used for insertion is used as format for the text.</source>
          <target state="translated">当插入这样的片段成&lt;a href=&quot;qtextdocument&quot;&gt;另外，QTextDocument&lt;/a&gt;所述的当前char格式&lt;a href=&quot;qtextcursor&quot;&gt;QTextCursor&lt;/a&gt;用于插入被用作文本格式。</target>
        </trans-unit>
        <trans-unit id="6ee49651f87fc18143f2662752cc1cf4e9cb8b10" translate="yes" xml:space="preserve">
          <source>When integrating existing classes and technology into QML, APIs will often need tweaking to fit better into the declarative environment. Although the best results are usually obtained by modifying the original classes directly, if this is either not possible or is complicated by some other concerns, extension objects allow limited extension possibilities without direct modifications.</source>
          <target state="translated">在将现有的类和技术集成到QML中时,API往往需要进行调整,以便更好地适应声明式环境。虽然最好的结果通常是通过直接修改原始类来获得,但如果这不可能或者因为一些其他问题而变得复杂,扩展对象允许有限的扩展可能性,而无需直接修改。</target>
        </trans-unit>
        <trans-unit id="a1d7f8c8a007cd8aa13b4d3a21b00e026e596090" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;gui-changes-qt6#qfont&quot;&gt;QFont&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;font&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">与C ++集成时，请注意，&lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;从C ++传递到QML的&lt;/a&gt;任何&lt;a href=&quot;gui-changes-qt6#qfont&quot;&gt;QFont&lt;/a&gt;值都会自动转换为 &lt;code&gt;font&lt;/code&gt; 值，反之亦然。</target>
        </trans-unit>
        <trans-unit id="46cd534349e4b4409b3a901102a23c1cbd1d64c6" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qcolor&quot;&gt;QColor&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;color&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">与C ++集成时，请注意，&lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;从C ++传递到QML的&lt;/a&gt;任何&lt;a href=&quot;qcolor&quot;&gt;QColor&lt;/a&gt;值都会自动转换为 &lt;code&gt;color&lt;/code&gt; 值，反之亦然。</target>
        </trans-unit>
        <trans-unit id="59e07d9cc2cac329614b7169422187bba763b0d8" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; or &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;date&lt;/code&gt; value, and vice-versa. Note, however, that converting a &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; will result in UTC's start of the day, which falls on a different date in some other time-zones. It is usually more robust to convert the &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; via a &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; explicitly, specifying local-time or a relevant time-zone and selecting a time of day (such as noon) that reliably exists (daylight-savings transitions skip an hour, near one end or the other of a day).</source>
          <target state="translated">与C ++集成时，请注意，&lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;从C ++传递到QML的&lt;/a&gt;任何&lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt;或&lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt;值都会自动转换为 &lt;code&gt;date&lt;/code&gt; 值，反之亦然。但是请注意，转换&lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt;将导致UTC的开始，该日期在某些其他时区中处于不同的日期。通常，通过&lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt;显式转换&lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt;，指定本地时间或相关时区并选择可靠存在的一天中的某个时间（例如中午），将更加可靠（夏时制转换跳过一个小时，接近终点）或一天中的另一天）。</target>
        </trans-unit>
        <trans-unit id="94f4f40b3918cac601587862fbf8acc3e95d325a" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; or &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;date&lt;/code&gt; value, and vice-versa. Note, however, that converting a &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; will result in UTC's start of the day, which falls on a different date in some other time-zones. It is usually more robust to convert the &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; via a &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; explicitly, specifying local-time or a relevant time-zone and selecting a time of day (such as noon) that reliably exists (daylight-savings transitions skip an hour, near one end or the other of a day).</source>
          <target state="translated">与C ++集成时，请注意，&lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;从C ++传递到QML的&lt;/a&gt;任何&lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt;或&lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt;值都会自动转换为 &lt;code&gt;date&lt;/code&gt; 值，反之亦然。但是请注意，转换&lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt;将导致UTC的开始，该日期在某些其他时区中处于不同的日期。通常，通过&lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt;显式转换&lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt;，指定本地时间或相关时区并选择可靠地存在的一天中的某个时间（例如中午）（将夏时制转换跳过一个小时，接近终点）会更可靠。或另一天）。</target>
        </trans-unit>
        <trans-unit id="2a3e9ea44f85bb16e221814f180ac27358c1f643" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qfont&quot;&gt;QFont&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;font&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">与C ++集成时，请注意，&lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;从C ++传递到QML的&lt;/a&gt;任何&lt;a href=&quot;qfont&quot;&gt;QFont&lt;/a&gt;值都会自动转换为 &lt;code&gt;font&lt;/code&gt; 值，反之亦然。</target>
        </trans-unit>
        <trans-unit id="c80b7cd162c43b0104ef58b6d7d770bb2b3dc0c9" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qgeocircle&quot;&gt;QGeoCircle&lt;/a&gt; value passed into QML from C++ is automatically converted into a &lt;code&gt;geocircle&lt;/code&gt; value, and vise-versa.</source>
          <target state="translated">与C ++集成时，请注意，从C ++传递到QML的任何&lt;a href=&quot;qgeocircle&quot;&gt;QGeoCircle&lt;/a&gt;值都会自动转换为 &lt;code&gt;geocircle&lt;/code&gt; 值，反之亦然。</target>
        </trans-unit>
        <trans-unit id="f90dc519be0e60fb444dc1c5260f47cc6cd907ee" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qgeocoordinate&quot;&gt;QGeoCoordinate&lt;/a&gt; value passed into QML from C++ is automatically converted into a &lt;code&gt;coordinate&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">与C ++集成时，请注意，从C ++传递到QML的任何&lt;a href=&quot;qgeocoordinate&quot;&gt;QGeoCoordinate&lt;/a&gt;值都会自动转换为 &lt;code&gt;coordinate&lt;/code&gt; 值，反之亦然。</target>
        </trans-unit>
        <trans-unit id="c5bbf6333d877f577a96dba2b55b5c884f293ae5" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qgeopath&quot;&gt;QGeoPath&lt;/a&gt; value passed into QML from C++ is automatically converted into a &lt;code&gt;geopath&lt;/code&gt; value, and vice versa.</source>
          <target state="translated">与C ++集成时，请注意，从C ++传递到QML的任何&lt;a href=&quot;qgeopath&quot;&gt;QGeoPath&lt;/a&gt;值都会自动转换为 &lt;code&gt;geopath&lt;/code&gt; 值，反之亦然。</target>
        </trans-unit>
        <trans-unit id="fc4029c75e55b88c42d4329274584c8e9c0128eb" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qgeopolygon&quot;&gt;QGeoPolygon&lt;/a&gt; value passed into QML is automatically converted into a &lt;code&gt;geopolygon&lt;/code&gt;, and vice versa.</source>
          <target state="translated">与C ++集成时，请注意，传递给QML的任何&lt;a href=&quot;qgeopolygon&quot;&gt;QGeoPolygon&lt;/a&gt;值都会自动转换为 &lt;code&gt;geopolygon&lt;/code&gt; ，反之亦然。</target>
        </trans-unit>
        <trans-unit id="a7dba58612710895f3116ae91ec3e71bc80778eb" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qgeorectangle&quot;&gt;QGeoRectangle&lt;/a&gt; value passed into QML from C++ is automatically converted into a &lt;code&gt;georectangle&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">与C ++集成时，请注意，从C ++传递到QML的所有&lt;a href=&quot;qgeorectangle&quot;&gt;QGeoRectangle&lt;/a&gt;值都会自动转换为 &lt;code&gt;georectangle&lt;/code&gt; 值，反之亦然。</target>
        </trans-unit>
        <trans-unit id="4d5c3d73097853ceb2db3f5a71a11d6fad5cb8d2" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qgeoshape&quot;&gt;QGeoShape&lt;/a&gt; value passed into QML from C++ is automatically converted into a &lt;code&gt;geoshape&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">与C ++集成时，请注意，从C ++传递到QML的任何&lt;a href=&quot;qgeoshape&quot;&gt;QGeoShape&lt;/a&gt;值都会自动转换为 &lt;code&gt;geoshape&lt;/code&gt; 值，反之亦然。</target>
        </trans-unit>
        <trans-unit id="babd158b5780227850bc5ed9c758d5d58d7cd1f2" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt; or &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;point&lt;/code&gt; value. When a &lt;code&gt;point&lt;/code&gt; value is passed to C++, it is automatically converted into a &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; value.</source>
          <target state="translated">与C ++集成时，请注意，&lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;从C ++传递到QML的&lt;/a&gt;任何&lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt;或&lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt;值都会自动转换为 &lt;code&gt;point&lt;/code&gt; 值。当将 &lt;code&gt;point&lt;/code&gt; 值传递给C ++时，它将自动转换为&lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt;值。</target>
        </trans-unit>
        <trans-unit id="06f6b135e98805bdd8065da59a778cd9f4c5215e" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt; or &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;point&lt;/code&gt; value. When a &lt;code&gt;point&lt;/code&gt; value is passed to C++, it is automatically converted into a &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; value.</source>
          <target state="translated">与C ++集成时，请注意，&lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;从C ++传递到QML的&lt;/a&gt;任何&lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt;或&lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt;值都会自动转换为 &lt;code&gt;point&lt;/code&gt; 值。将 &lt;code&gt;point&lt;/code&gt; 值传递给C ++时，它会自动转换为&lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt;值。</target>
        </trans-unit>
        <trans-unit id="a84623eea3626c41bb0f62625b89382e6a0884d2" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qqmllistproperty&quot;&gt;QQmlListProperty&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;list&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">与C ++集成时，请注意，&lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;从C ++传递到QML的&lt;/a&gt;任何&lt;a href=&quot;qqmllistproperty&quot;&gt;QQmlListProperty&lt;/a&gt;值都会自动转换为 &lt;code&gt;list&lt;/code&gt; 值，反之亦然。</target>
        </trans-unit>
        <trans-unit id="4537d2f61ed5eb33aa48c28e4d1f2cbe5739fee6" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qqmllistproperty&quot;&gt;QQmlListProperty&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;list&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">与C ++集成时，请注意，&lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;从C ++传递到QML的&lt;/a&gt;任何&lt;a href=&quot;qqmllistproperty&quot;&gt;QQmlListProperty&lt;/a&gt;值都会自动转换为 &lt;code&gt;list&lt;/code&gt; 值，反之亦然。</target>
        </trans-unit>
        <trans-unit id="892030f32ca7d95430d43e3adb51ab41646ac62c" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; or &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;rect&lt;/code&gt; value, and vice-versa. When a &lt;code&gt;rect&lt;/code&gt; value is passed to C++, it is automatically converted into a &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; value.</source>
          <target state="translated">与C ++集成时，请注意，&lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;从C ++传递到QML的&lt;/a&gt;任何&lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt;或&lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt;值都会自动转换为 &lt;code&gt;rect&lt;/code&gt; 值，反之亦然。当将 &lt;code&gt;rect&lt;/code&gt; 值传递给C ++时，它将自动转换为&lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt;值。</target>
        </trans-unit>
        <trans-unit id="bde76fc240f3c1a3b45734a6b9372df275b0771e" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; or &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;rect&lt;/code&gt; value, and vice-versa. When a &lt;code&gt;rect&lt;/code&gt; value is passed to C++, it is automatically converted into a &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; value.</source>
          <target state="translated">与C ++集成时，请注意，&lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;从C ++传递到QML的&lt;/a&gt;任何&lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt;或&lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt;值都会自动转换为 &lt;code&gt;rect&lt;/code&gt; 值，反之亦然。当将 &lt;code&gt;rect&lt;/code&gt; 值传递给C ++时，它将自动转换为&lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt;值。</target>
        </trans-unit>
        <trans-unit id="e7418f4bf29ec0eb129b2a465879400da12bc2de" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt; or &lt;a href=&quot;qsizef&quot;&gt;QSizeF&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;size&lt;/code&gt; value, and vice-versa. When a &lt;code&gt;size&lt;/code&gt; value is passed to C++, it is automatically converted into a &lt;a href=&quot;qsizef&quot;&gt;QSizeF&lt;/a&gt; value.</source>
          <target state="translated">与C ++集成时，请注意，&lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;从C ++传递到QML的&lt;/a&gt;任何&lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt;或&lt;a href=&quot;qsizef&quot;&gt;QSizeF&lt;/a&gt;值都会自动转换为 &lt;code&gt;size&lt;/code&gt; 值，反之亦然。当将 &lt;code&gt;size&lt;/code&gt; 值传递给C ++时，它将自动转换为&lt;a href=&quot;qsizef&quot;&gt;QSizeF&lt;/a&gt;值。</target>
        </trans-unit>
        <trans-unit id="efe91bec14c646d63c8cb49b132911ca4fb70cf2" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt; or &lt;a href=&quot;qsizef&quot;&gt;QSizeF&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;size&lt;/code&gt; value, and vice-versa. When a &lt;code&gt;size&lt;/code&gt; value is passed to C++, it is automatically converted into a &lt;a href=&quot;qsizef&quot;&gt;QSizeF&lt;/a&gt; value.</source>
          <target state="translated">与C ++集成时，请注意，&lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;从C ++传递到QML的&lt;/a&gt;任何&lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt;或&lt;a href=&quot;qsizef&quot;&gt;QSizeF&lt;/a&gt;值都会自动转换为 &lt;code&gt;size&lt;/code&gt; 值，反之亦然。当将 &lt;code&gt;size&lt;/code&gt; 值传递给C ++时，它将自动转换为&lt;a href=&quot;qsizef&quot;&gt;QSizeF&lt;/a&gt;值。</target>
        </trans-unit>
        <trans-unit id="3ce59b6a0f0b4b392e20d60442b247d4ac83798d" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;string&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">与C ++集成时，请注意，&lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;从C ++传递到QML的&lt;/a&gt;任何&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;值都会自动转换为 &lt;code&gt;string&lt;/code&gt; 值，反之亦然。</target>
        </trans-unit>
        <trans-unit id="7fd4e1a3e2c35dda93f104508cebf19c9ae03217" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;string&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">与C ++集成时，请注意，&lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;从C ++传递到QML的&lt;/a&gt;任何&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;值都会自动转换为 &lt;code&gt;string&lt;/code&gt; 值，反之亦然。</target>
        </trans-unit>
        <trans-unit id="c9d28617421e54fcce89cbef003fdb53a193660b" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;url&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">与C ++集成时，请注意，&lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;从C ++传递到QML的&lt;/a&gt;任何&lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt;值都将自动转换为 &lt;code&gt;url&lt;/code&gt; 值，反之亦然。</target>
        </trans-unit>
        <trans-unit id="b5784d74b9c118ae7229636ff92faf312a5dfe71" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;url&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">与C ++集成时，请注意，&lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;从C ++传递到QML的&lt;/a&gt;任何&lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt;值都会自动转换为 &lt;code&gt;url&lt;/code&gt; 值，反之亦然。</target>
        </trans-unit>
        <trans-unit id="ed02fd90e62a507cb5dc19431423e1b9374d396b" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;variant&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">与C ++集成时，请注意，&lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;从C ++传递到QML的&lt;/a&gt;任何&lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt;值都会自动转换为 &lt;code&gt;variant&lt;/code&gt; 值，反之亦然。</target>
        </trans-unit>
        <trans-unit id="4782c07688335b98c18e7337dd4cb33a506d5caa" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;variant&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">与C ++集成时，请注意，&lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;从C ++传递到QML的&lt;/a&gt;任何&lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt;值都会自动转换为 &lt;code&gt;variant&lt;/code&gt; 值，反之亦然。</target>
        </trans-unit>
        <trans-unit id="0f08c295ab9d317506d3417a8c5ed2ce92dffe9c" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qvector3d&quot;&gt;QVector3D&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;vector3d&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">与C ++集成时，请注意，&lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;从C ++传递到QML的&lt;/a&gt;任何&lt;a href=&quot;qvector3d&quot;&gt;QVector3D&lt;/a&gt;值都会自动转换为 &lt;code&gt;vector3d&lt;/code&gt; 值，反之亦然。</target>
        </trans-unit>
        <trans-unit id="91da3853e2ebc605267bec0ae228daafb92fc978" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;code&gt;enum&lt;/code&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into an &lt;code&gt;enumeration&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">与C ++集成时，请注意，&lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;从C ++传递到QML的&lt;/a&gt;所有 &lt;code&gt;enum&lt;/code&gt; 值都会自动转换为 &lt;code&gt;enumeration&lt;/code&gt; 值，反之亦然。</target>
        </trans-unit>
        <trans-unit id="174229e59467abdea54b7e746d86e6764e7d6c9d" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;code&gt;enum&lt;/code&gt; value &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into an &lt;code&gt;enumeration&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">与C ++集成时，请注意，&lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;从C ++传递到QML的&lt;/a&gt;所有 &lt;code&gt;enum&lt;/code&gt; 值都会自动转换为 &lt;code&gt;enumeration&lt;/code&gt; 值，反之亦然。</target>
        </trans-unit>
        <trans-unit id="f7482e71bbdd52848ddeffbe95fcd0b8e2b5663e" translate="yes" xml:space="preserve">
          <source>When interacted with a mouse device, flicking is disabled and the scroll bars are interactive.</source>
          <target state="translated">当与鼠标设备交互时,禁止轻触,滚动条是交互式的。</target>
        </trans-unit>
        <trans-unit id="8777d7fa43f475169d9e2b3537e4248eaedbf1d8" translate="yes" xml:space="preserve">
          <source>When intermixing &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; and OpenGL, it is important to notify &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; that the OpenGL state may have been cluttered so it can restore its internal state. This is achieved by calling &lt;a href=&quot;qpainter#beginNativePainting&quot;&gt;QPainter::beginNativePainting&lt;/a&gt;() before starting the OpenGL rendering and calling &lt;a href=&quot;qpainter#endNativePainting&quot;&gt;QPainter::endNativePainting&lt;/a&gt;() after finishing.</source>
          <target state="translated">混合&lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;和OpenGL时，重要的是通知&lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; OpenGL状态可能已经杂乱无章，以便可以恢复其内部状态。这是通过调用实现&lt;a href=&quot;qpainter#beginNativePainting&quot;&gt;了QPainter :: beginNativePainting&lt;/a&gt;开始OpenGL渲染和调用（）之前&lt;a href=&quot;qpainter#endNativePainting&quot;&gt;的QPainter :: endNativePainting&lt;/a&gt;（）整理后。</target>
        </trans-unit>
        <trans-unit id="3c3351ce7fa4daf3d510e3944f9c0b1cd89614d0" translate="yes" xml:space="preserve">
          <source>When interoperating with another graphics engine, it may be necessary to get a QRhi instance that uses the same Metal device. This can be achieved by passing a pointer to a &lt;a href=&quot;qrhimetalnativehandles&quot;&gt;QRhiMetalNativeHandles&lt;/a&gt; to &lt;a href=&quot;qrhi#create&quot;&gt;QRhi::create&lt;/a&gt;(). The device must be set to a non-null value then. Optionally, a command queue object can be specified as well.</source>
          <target state="translated">与另一个图形引擎进行互操作时，可能有必要获取使用同一Metal设备的QRhi实例。这可以通过将指向&lt;a href=&quot;qrhimetalnativehandles&quot;&gt;QRhiMetalNativeHandles&lt;/a&gt;的指针传递给&lt;a href=&quot;qrhi#create&quot;&gt;QRhi :: create&lt;/a&gt;（）来实现。然后，必须将设备设置为非空值。（可选）还可以指定命令队列对象。</target>
        </trans-unit>
        <trans-unit id="61bd4cd2f160b9517401ee938d1cc345306ee16b" translate="yes" xml:space="preserve">
          <source>When invoking QDoc on a project that has dependencies and uses the &lt;code&gt;depends&lt;/code&gt; variable, one or more &lt;code&gt;-indexdir&lt;/code&gt; path(s) must be passed as command line option(s). QDoc uses these paths to search for the dependencies' index files.</source>
          <target state="translated">当对具有依赖关系，并使用一个项目调用的QDoc &lt;code&gt;depends&lt;/code&gt; 变量，一个或多个 &lt;code&gt;-indexdir&lt;/code&gt; 路径（一个或多个）必须作为命令行选项（S）被传递。QDoc使用这些路径搜索依赖项的索引文件。</target>
        </trans-unit>
        <trans-unit id="19950d97cb8c934f1e5c65f401298cb13bebd643" translate="yes" xml:space="preserve">
          <source>When invoking one of these options, or when an error happens (for instance an unknown option was passed), the current process will then stop, using the exit() function.</source>
          <target state="translated">当调用这些选项之一时,或者发生错误时(例如传递了一个未知的选项),当前进程将使用exit()函数停止。</target>
        </trans-unit>
        <trans-unit id="929e40a78bc8a0bfef832d1e3a9f16143f9379e2" translate="yes" xml:space="preserve">
          <source>When it comes from a &lt;a href=&quot;qtabletevent&quot;&gt;QTabletEvent&lt;/a&gt;, it identifies the serial number of the stylus in use.</source>
          <target state="translated">当它来自&lt;a href=&quot;qtabletevent&quot;&gt;QTabletEvent时&lt;/a&gt;，它标识使用中的手写笔的序列号。</target>
        </trans-unit>
        <trans-unit id="071c0d6d52ee604f468daeb0ab63c0a2099e201d" translate="yes" xml:space="preserve">
          <source>When it comes to more complex controls, it is sometimes better to split them up into separate building blocks. As an example, the complex &lt;a href=&quot;qml-qtquick-controls2-scrollview&quot;&gt;ScrollView&lt;/a&gt; control:</source>
          <target state="translated">当涉及到更复杂的控件时，有时最好将它们分成单独的构建块。例如，复杂的&lt;a href=&quot;qml-qtquick-controls2-scrollview&quot;&gt;ScrollView&lt;/a&gt;控件：</target>
        </trans-unit>
        <trans-unit id="8e8c72fd29bc00795105647d117aa1d234784718" translate="yes" xml:space="preserve">
          <source>When it comes to rendering, deferred rendering is a different beast in terms of renderer configuration compared to forward rendering. Instead of drawing each mesh and applying a shader effect to shade it, deferred rendering adopts a</source>
          <target state="translated">说到渲染,与正向渲染相比,延迟渲染在渲染器配置上是一头不同的野兽。延迟渲染不需要绘制每个网格并应用着色器效果对其进行着色,而是采用了</target>
        </trans-unit>
        <trans-unit id="626ed890d480d0a4b856052f27b67e8d0b322b1a" translate="yes" xml:space="preserve">
          <source>When it comes to texture support, the &lt;a href=&quot;qt3drender-qparameter&quot;&gt;QParameter&lt;/a&gt; value should be set to the appropriate &lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture&lt;/a&gt; subclass that matches the sampler type of the shader uniform.</source>
          <target state="translated">对于纹理支持，&lt;a href=&quot;qt3drender-qparameter&quot;&gt;应将QParameter&lt;/a&gt;值设置为与着色器统一的采样器类型匹配的适当&lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture&lt;/a&gt;子类。</target>
        </trans-unit>
        <trans-unit id="5979b40af94b30c33380148b42cb7fe798d86843" translate="yes" xml:space="preserve">
          <source>When it comes to texture support, the Parameter value should be set to the appropriate &lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;texture&lt;/a&gt; subclass that matches the sampler type of the shader uniform.</source>
          <target state="translated">关于纹理支持，应将&amp;ldquo;参数&amp;rdquo;值设置为与着色器统一的采样器类型匹配的适当&lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;纹理&lt;/a&gt;子类。</target>
        </trans-unit>
        <trans-unit id="71c851f5c2d819a86267b67c443581d3b3d61a3e" translate="yes" xml:space="preserve">
          <source>When it comes to texture support, the QParameter value should be set to the appropriate &lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture&lt;/a&gt; subclass that matches the sampler type of the shader uniform.</source>
          <target state="translated">对于纹理支持，应将QParameter值设置为与着色器统一的采样器类型匹配的适当&lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture&lt;/a&gt;子类。</target>
        </trans-unit>
        <trans-unit id="4b02d0bcf48f8ce6e8c4aa1efbf35437d4baed40" translate="yes" xml:space="preserve">
          <source>When it comes to uniform values from properties, all passes in the Effect read the same values in their shaders. If necessary it is possible to override the value of a uniform just for a given pass. This is achieved by adding the &lt;a href=&quot;qml-qtquick3d-setuniformvalue&quot;&gt;SetUniformValue&lt;/a&gt; command to the list of commands for the pass.</source>
          <target state="translated">当涉及到来自属性的统一值时，Effect中的所有遍次在其着色器中读取的值相同。如有必要，可以仅针对给定遍次覆盖统一值。这是通过将&lt;a href=&quot;qml-qtquick3d-setuniformvalue&quot;&gt;SetUniformValue&lt;/a&gt;命令添加到该传递的命令列表中来实现的。</target>
        </trans-unit>
        <trans-unit id="ac390c6893275dbab12f259c5a78a8285bc68bc5" translate="yes" xml:space="preserve">
          <source>When it does not call &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt;, Shape interacts with &lt;a href=&quot;qframe#Shadow-enum&quot;&gt;QFrame::Shadow&lt;/a&gt;, the &lt;a href=&quot;qframe#lineWidth-prop&quot;&gt;lineWidth&lt;/a&gt;() and the &lt;a href=&quot;qframe#midLineWidth-prop&quot;&gt;midLineWidth&lt;/a&gt;() to create the total result. See the picture of the frames in the main class documentation.</source>
          <target state="translated">当它不调用&lt;a href=&quot;qstyle&quot;&gt;QStyle时&lt;/a&gt;，Shape与&lt;a href=&quot;qframe#Shadow-enum&quot;&gt;QFrame :: Shadow&lt;/a&gt;，&lt;a href=&quot;qframe#lineWidth-prop&quot;&gt;lineWidth&lt;/a&gt;（）和&lt;a href=&quot;qframe#midLineWidth-prop&quot;&gt;midLineWidth&lt;/a&gt;（）交互以创建总结果。请参阅主类文档中的框架图片。</target>
        </trans-unit>
        <trans-unit id="4261303376e29e827bb3d9ad715c1736160cb00b" translate="yes" xml:space="preserve">
          <source>When it is necessary to reimplement the &lt;a href=&quot;qaccessibleinterface#child&quot;&gt;QAccessibleInterface::child&lt;/a&gt;() function and returning the child after constructing it, this function needs to be called.</source>
          <target state="translated">当需要重新实现&lt;a href=&quot;qaccessibleinterface#child&quot;&gt;QAccessibleInterface :: child&lt;/a&gt;（）函数并在构造后返回子级时，需要调用此函数。</target>
        </trans-unit>
        <trans-unit id="638905df9b46e03441949d29b36f66dcb7394603" translate="yes" xml:space="preserve">
          <source>When items of data are exported from a model in a drag and drop operation, they are encoded into an appropriate format corresponding to one or more MIME types. Models declare the MIME types that they can use to supply items by reimplementing the &lt;a href=&quot;qabstractitemmodel#mimeTypes&quot;&gt;QAbstractItemModel::mimeTypes&lt;/a&gt;() function, returning a list of standard MIME types.</source>
          <target state="translated">当通过拖放操作从模型中导出数据项时，会将它们编码为与一种或多种MIME类型相对应的适当格式。通过重新实现&lt;a href=&quot;qabstractitemmodel#mimeTypes&quot;&gt;QAbstractItemModel :: mimeTypes&lt;/a&gt;（）函数，并返回标准MIME类型的列表，模型声明了可用于提供项目的MIME类型。</target>
        </trans-unit>
        <trans-unit id="3d596a81dc328e917e2efe8c14460f7b21b5e36e" translate="yes" xml:space="preserve">
          <source>When iterating from 0 and up, it will return the items in the visual arranged order.</source>
          <target state="translated">当从0开始向上迭代时,将按视觉排列顺序返回项目。</target>
        </trans-unit>
        <trans-unit id="f808486c7714b611743ef8e1139711cba9bfa51a" translate="yes" xml:space="preserve">
          <source>When iterating over a &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt;, the items are arbitrarily ordered. With &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt;, the items are always sorted by key.</source>
          <target state="translated">在&lt;a href=&quot;qhash#qhash&quot;&gt;QHash上&lt;/a&gt;迭代时，可以任意排序项目。使用&lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt;，项始终按键排序。</target>
        </trans-unit>
        <trans-unit id="8c6bd39523d6a042b14b93d88385549366872e15" translate="yes" xml:space="preserve">
          <source>When iterating over a &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt;, the items are arbitrarily ordered. With QMap, the items are always sorted by key.</source>
          <target state="translated">在&lt;a href=&quot;qhash#qhash&quot;&gt;QHash上进行&lt;/a&gt;迭代时，这些项是任意排序的。使用QMap时，项目始终按键排序。</target>
        </trans-unit>
        <trans-unit id="c8708ebbe834470a66afd3e678569b47f4a25996" translate="yes" xml:space="preserve">
          <source>When iterating over a &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt;, the items are always sorted by key. With &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt;, the items are arbitrarily ordered.</source>
          <target state="translated">在&lt;a href=&quot;qmap&quot;&gt;QMap上进行&lt;/a&gt;迭代时，项始终按键排序。使用&lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt;，可以任意订购商品。</target>
        </trans-unit>
        <trans-unit id="908bbde912a8e2a5301227f6ea15bedbeee803e0" translate="yes" xml:space="preserve">
          <source>When iterating over a &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt;, the items are always sorted by key. With QHash, the items are arbitrarily ordered.</source>
          <target state="translated">在&lt;a href=&quot;qmap&quot;&gt;QMap上进行&lt;/a&gt;迭代时，项始终按键排序。使用QHash，可以任意订购商品。</target>
        </trans-unit>
        <trans-unit id="209836588351362f7e1be7058630803263938614" translate="yes" xml:space="preserve">
          <source>When iterating over a &lt;a href=&quot;qmultihash&quot;&gt;QMultiHash&lt;/a&gt;, the items are arbitrarily ordered. With QMultiMap, the items are always sorted by key.</source>
          <target state="translated">在&lt;a href=&quot;qmultihash&quot;&gt;QMultiHash上&lt;/a&gt;迭代时，这些项是任意排序的。使用QMultiMap时，项目始终按键排序。</target>
        </trans-unit>
        <trans-unit id="9a98982cb360d3887455667bec14b4371ac7fe09" translate="yes" xml:space="preserve">
          <source>When kerning is enabled, glyph metrics do not add up anymore, even for Latin text. In other words, the assumption that width('a') + width('b') is equal to width(&quot;ab&quot;) is not neccesairly true.</source>
          <target state="translated">当启用内核时,字形度量不再相加,即使是拉丁文文本。换句话说,width('a')+width('b')等于width(&quot;ab&quot;)的假设不一定正确。</target>
        </trans-unit>
        <trans-unit id="c7c90cd5b86c3de4a86dbc5bca9301f0623600e2" translate="yes" xml:space="preserve">
          <source>When kerning is enabled, glyph metrics do not add up anymore, even for Latin text. In other words, the assumption that width('a') + width('b') is equal to width(&quot;ab&quot;) is not necessarily true.</source>
          <target state="translated">启用内核后,字形指标不再相加,即使是拉丁文文本也是如此。换句话说,宽度('a')+宽度('b')等于宽度(&quot;ab&quot;)的假设不一定正确。</target>
        </trans-unit>
        <trans-unit id="1a521e51c1250eb56a9a96122f4249b5a5690e59" translate="yes" xml:space="preserve">
          <source>When keyboard tracking is disabled, changes are only signalled when focus leaves the text field after edits have modified the content. This allows the user to edit via an invalid date-time to reach a valid one.</source>
          <target state="translated">当键盘跟踪被禁用时,只有在编辑修改内容后焦点离开文本字段时,才会发出更改信号。这样用户就可以通过无效的日期时间来编辑,达到有效的日期时间。</target>
        </trans-unit>
        <trans-unit id="4935f0a00031f4e75a93ae9dcce7afc6159f9c52" translate="yes" xml:space="preserve">
          <source>When leaving &quot;What's This?&quot; mode, a &lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt; of type Qt::LeaveWhatsThisMode is sent to all toplevel widgets.</source>
          <target state="translated">离开时&amp;ldquo;这是什么？&amp;rdquo; 模式，将Qt :: LeaveWhatsThisMode类型的&lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt;发送到所有顶级小部件。</target>
        </trans-unit>
        <trans-unit id="68c47022708d018c6f6b21000a13611ed6e90869" translate="yes" xml:space="preserve">
          <source>When linking a library, qmake relies on the underlying platform to know what other libraries this library links against. However, if linking statically, qmake will not get this information unless we use the following &lt;code&gt;CONFIG&lt;/code&gt; options:</source>
          <target state="translated">链接库时，qmake依赖基础平台来了解该库链接的其他库。但是，如果静态链接，则除非使用以下 &lt;code&gt;CONFIG&lt;/code&gt; 选项，否则qmake不会获取此信息：</target>
        </trans-unit>
        <trans-unit id="a540dbd6e20238800d7ddd333a082e8843bed862" translate="yes" xml:space="preserve">
          <source>When listening for connections, the address and port on which the server is listening are available as &lt;a href=&quot;qtcpserver#serverAddress&quot;&gt;serverAddress&lt;/a&gt;() and &lt;a href=&quot;qtcpserver#serverPort&quot;&gt;serverPort&lt;/a&gt;().</source>
          <target state="translated">侦听连接时，服务器正在侦听的地址和端口可用作&lt;a href=&quot;qtcpserver#serverAddress&quot;&gt;serverAddress&lt;/a&gt;（）和&lt;a href=&quot;qtcpserver#serverPort&quot;&gt;serverPort&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="e0c7db0652d32fbb04e043b9bb98640d9fdf9268" translate="yes" xml:space="preserve">
          <source>When listening for connections, the address and port on which the server is listening are available as &lt;a href=&quot;qwebsocketserver#serverAddress&quot;&gt;serverAddress&lt;/a&gt;() and &lt;a href=&quot;qwebsocketserver#serverPort&quot;&gt;serverPort&lt;/a&gt;().</source>
          <target state="translated">侦听连接时，服务器正在侦听的地址和端口可用作&lt;a href=&quot;qwebsocketserver#serverAddress&quot;&gt;serverAddress&lt;/a&gt;（）和&lt;a href=&quot;qwebsocketserver#serverPort&quot;&gt;serverPort&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="31ca6375539521ce018e40aba55ef1cfd8ac0a7b" translate="yes" xml:space="preserve">
          <source>When listening for connections, the name which the server is listening on is available through &lt;a href=&quot;qlocalserver#serverName&quot;&gt;serverName&lt;/a&gt;().</source>
          <target state="translated">侦听连接时，可通过&lt;a href=&quot;qlocalserver#serverName&quot;&gt;serverName&lt;/a&gt;（）获得服务器正在侦听的名称。</target>
        </trans-unit>
        <trans-unit id="f562b333fc7588768d7b731fad5e57e2bf351983" translate="yes" xml:space="preserve">
          <source>When loading a QML object into a C++ application, it can be useful to directly embed some C++ data that can be used from within the QML code. This makes it possible, for example, to invoke a C++ method on the embedded object, or use a C++ object instance as a data model for a QML view.</source>
          <target state="translated">当把一个QML对象加载到C++应用程序中时,直接嵌入一些可以在QML代码中使用的C++数据是很有用的。例如,这样就可以在嵌入的对象上调用一个C++方法,或者使用一个C++对象实例作为QML视图的数据模型。</target>
        </trans-unit>
        <trans-unit id="5937553b7180f604506425e217e2f3d3eb8c1b4d" translate="yes" xml:space="preserve">
          <source>When loading the library, &lt;a href=&quot;qlibrary&quot;&gt;QLibrary&lt;/a&gt; searches in all system-specific library locations (for example, &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt; on Unix), unless the file name has an absolute path. After loading the library successfully, fileName() returns the fully-qualified file name of the library, including the full path to the library if one was given in the constructor or passed to setFileName().</source>
          <target state="translated">加载库时，除非文件名具有绝对路径，否则&lt;a href=&quot;qlibrary&quot;&gt;QLibrary会&lt;/a&gt;搜索所有系统特定的库位置（例如，Unix上的 &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt; ）。成功加载库后，fileName（）返回库的标准文件名，如果在构造函数中已指定或传递给setFileName（），则返回库的完整路径。</target>
        </trans-unit>
        <trans-unit id="90725888073e38b3afa3349da5a1b31dfd6e2335" translate="yes" xml:space="preserve">
          <source>When loading the plugin, &lt;a href=&quot;qpluginloader&quot;&gt;QPluginLoader&lt;/a&gt; searches in all plugin locations specified by &lt;a href=&quot;qcoreapplication#libraryPaths&quot;&gt;QCoreApplication::libraryPaths&lt;/a&gt;(), unless the file name has an absolute path. After loading the plugin successfully, fileName() returns the fully-qualified file name of the plugin, including the full path to the plugin if one was given in the constructor or passed to setFileName().</source>
          <target state="translated">当加载插件，&lt;a href=&quot;qpluginloader&quot;&gt;QPluginLoader&lt;/a&gt;搜索由指定的所有插件位置&lt;a href=&quot;qcoreapplication#libraryPaths&quot;&gt;QCoreApplication :: libraryPaths&lt;/a&gt;（），除非文件名有一个绝对路径。成功加载插件后，fileName（）返回插件的完全限定的文件名，如果在构造函数中已给定或传递给setFileName（），则包括插件的完整路径。</target>
        </trans-unit>
        <trans-unit id="07f1533b7f9a425f6f190f84dd677e6063996b77" translate="yes" xml:space="preserve">
          <source>When loading the plugin, &lt;a href=&quot;qpluginloader&quot;&gt;QPluginLoader&lt;/a&gt; searches in the current directory and in all plugin locations specified by &lt;a href=&quot;qcoreapplication#libraryPaths&quot;&gt;QCoreApplication::libraryPaths&lt;/a&gt;(), unless the file name has an absolute path. After loading the plugin successfully, fileName() returns the fully-qualified file name of the plugin, including the full path to the plugin if one was given in the constructor or passed to setFileName().</source>
          <target state="translated">加载插件时，除非文件名具有绝对路径，否则&lt;a href=&quot;qpluginloader&quot;&gt;QPluginLoader会&lt;/a&gt;在当前目录以及&lt;a href=&quot;qcoreapplication#libraryPaths&quot;&gt;QCoreApplication :: libraryPaths&lt;/a&gt;（）指定的所有插件位置中搜索。成功加载插件后，fileName（）返回插件的全限定文件名，如果在构造函数中已指定或传递给setFileName（），则包括插件的完整路径。</target>
        </trans-unit>
        <trans-unit id="fed00e705cb06cd3fa7ef9acd6a2a5b4614acebf" translate="yes" xml:space="preserve">
          <source>When making OpenGL function calls, it is strongly recommended to avoid calling the functions directly. Instead, prefer using &lt;a href=&quot;https://doc.qt.io/qt-5.13/qopenglfunctions.html&quot;&gt;QOpenGLFunctions&lt;/a&gt; (when making portable applications) or the versioned variants (for example, &lt;a href=&quot;https://doc.qt.io/qt-5.13/qopenglfunctions-3-2-core.html&quot;&gt;QOpenGLFunctions_3_2_Core&lt;/a&gt; and similar, when targeting modern, desktop-only OpenGL). This way the application will work correctly in all Qt build configurations, including the ones that perform dynamic OpenGL implementation loading which means applications are not directly linking to an GL implementation and thus direct function calls are not feasible.</source>
          <target state="translated">进行OpenGL函数调用时，强烈建议避免直接调用函数。相反，当使用现代的仅限桌面的OpenGL时，&lt;a href=&quot;https://doc.qt.io/qt-5.13/qopenglfunctions-3-2-core.html&quot;&gt;最好&lt;/a&gt;使用&lt;a href=&quot;https://doc.qt.io/qt-5.13/qopenglfunctions.html&quot;&gt;QOpenGLFunctions&lt;/a&gt;（在制作便携式应用程序时）或版本化的变体（例如QOpenGLFunctions_3_2_Core等）。这样，应用程序将在所有Qt构建配置中正常工作，包括执行动态OpenGL实现加载的配置，这意味着应用程序未直接链接到GL实现，因此直接函数调用不可行。</target>
        </trans-unit>
        <trans-unit id="f276cbbad1d8799cadf78ef781192531dc7ead31" translate="yes" xml:space="preserve">
          <source>When making OpenGL function calls, it is strongly recommended to avoid calling the functions directly. Instead, prefer using &lt;a href=&quot;https://doc.qt.io/qt-5.15/qopenglfunctions.html&quot;&gt;QOpenGLFunctions&lt;/a&gt; (when making portable applications) or the versioned variants (for example, &lt;a href=&quot;https://doc.qt.io/qt-5.15/qopenglfunctions-3-2-core.html&quot;&gt;QOpenGLFunctions_3_2_Core&lt;/a&gt; and similar, when targeting modern, desktop-only OpenGL). This way the application will work correctly in all Qt build configurations, including the ones that perform dynamic OpenGL implementation loading which means applications are not directly linking to an GL implementation and thus direct function calls are not feasible.</source>
          <target state="translated">进行OpenGL函数调用时，强烈建议避免直接调用函数。相反，更喜欢使用&lt;a href=&quot;https://doc.qt.io/qt-5.15/qopenglfunctions.html&quot;&gt;QOpenGLFunctions&lt;/a&gt;（在制作便携式应用程序时）或版本化的变体（例如，当针对现代的仅限桌面的OpenGL时，使用&lt;a href=&quot;https://doc.qt.io/qt-5.15/qopenglfunctions-3-2-core.html&quot;&gt;QOpenGLFunctions_3_2_Core&lt;/a&gt;和类似版本）。这样，应用程序将在所有Qt构建配置中正常工作，包括执行动态OpenGL实现加载的配置，这意味着应用程序未直接链接到GL实现，因此直接函数调用是不可行的。</target>
        </trans-unit>
        <trans-unit id="5b88e78507dd59fcfeb60168e7f95fe6bc3faf69" translate="yes" xml:space="preserve">
          <source>When making OpenGL function calls, it is strongly recommended to avoid calling the functions directly. Instead, prefer using &lt;a href=&quot;https://doc.qt.io/qt-6.0/qopenglfunctions.html&quot;&gt;QOpenGLFunctions&lt;/a&gt; (when making portable applications) or the versioned variants (for example, &lt;a href=&quot;https://doc.qt.io/qt-6.0/qopenglfunctions-3-2-core.html&quot;&gt;QOpenGLFunctions_3_2_Core&lt;/a&gt; and similar, when targeting modern, desktop-only OpenGL). This way the application will work correctly in all Qt build configurations, including the ones that perform dynamic OpenGL implementation loading which means applications are not directly linking to an GL implementation and thus direct function calls are not feasible.</source>
          <target state="translated">进行OpenGL函数调用时，强烈建议避免直接调用函数。相反，更喜欢使用&lt;a href=&quot;https://doc.qt.io/qt-6.0/qopenglfunctions.html&quot;&gt;QOpenGLFunctions&lt;/a&gt;（在制作便携式应用程序时）或版本化的变体（例如，当针对现代的仅限桌面的OpenGL时，使用&lt;a href=&quot;https://doc.qt.io/qt-6.0/qopenglfunctions-3-2-core.html&quot;&gt;QOpenGLFunctions_3_2_Core&lt;/a&gt;和类似版本）。这样，应用程序将在所有Qt构建配置中正常工作，包括执行动态OpenGL实现加载的配置，这意味着应用程序未直接链接到GL实现，因此直接函数调用是不可行的。</target>
        </trans-unit>
        <trans-unit id="e13241aa10bcc1564d523c6d4166d3b0339b40a0" translate="yes" xml:space="preserve">
          <source>When making a context current using &lt;a href=&quot;gui-changes-qt6#qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt;, do not check that the &lt;a href=&quot;qobject#thread-affinity&quot;&gt;QObject thread affinity&lt;/a&gt; of the &lt;a href=&quot;gui-changes-qt6#qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt; object is the same thread calling &lt;a href=&quot;qopenglcontext#makeCurrent&quot;&gt;makeCurrent()&lt;/a&gt;. This value was added in Qt 5.8.</source>
          <target state="translated">制作时使用上下文当前&lt;a href=&quot;gui-changes-qt6#qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt;，不检查&lt;a href=&quot;qobject#thread-affinity&quot;&gt;QObject的线程关联&lt;/a&gt;的的&lt;a href=&quot;gui-changes-qt6#qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt;对象是同一个线程调用&lt;a href=&quot;qopenglcontext#makeCurrent&quot;&gt;makeCurrent（） &lt;/a&gt;。这个值是在Qt 5.8中添加的。</target>
        </trans-unit>
        <trans-unit id="d7812b8e5267196ba2ad8e65b065aaa80e3d29f0" translate="yes" xml:space="preserve">
          <source>When making a context current using &lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt;, do not check that the &lt;a href=&quot;qobject#thread-affinity&quot;&gt;QObject thread affinity&lt;/a&gt; of the &lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt; object is the same thread calling &lt;a href=&quot;qopenglcontext#makeCurrent&quot;&gt;makeCurrent()&lt;/a&gt;. This value was added in Qt 5.8.</source>
          <target state="translated">制作时使用上下文当前&lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt;，不检查&lt;a href=&quot;qobject#thread-affinity&quot;&gt;QObject的线程关联&lt;/a&gt;的的&lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt;对象是同一个线程调用&lt;a href=&quot;qopenglcontext#makeCurrent&quot;&gt;makeCurrent（） &lt;/a&gt;。这个值是在Qt 5.8中添加的。</target>
        </trans-unit>
        <trans-unit id="3d457ffc5179988c0d911e245311c267b3667157" translate="yes" xml:space="preserve">
          <source>When making the temporary credentials request, the client authenticates using only the client credentials. When making the token request, the client authenticates using the client credentials as well as the temporary credentials. Once the client receives and stores the token credentials, it can proceed to access protected resources on behalf of the resource owner by making authenticated requests using the client credentials together with the token credentials received.</source>
          <target state="translated">当进行临时凭证请求时,客户端只使用客户端凭证进行验证。当进行令牌请求时,客户端使用客户端凭证和临时凭证进行身份验证。客户端收到并存储令牌凭证后,就可以使用客户端凭证和收到的令牌凭证进行认证请求,代表资源所有者访问受保护的资源。</target>
        </trans-unit>
        <trans-unit id="810316d46e7d600660a66af0e59fa7e02d7433b6" translate="yes" xml:space="preserve">
          <source>When managing dynamically created objects, you must ensure the creation context outlives the created object. Otherwise, if the creation context is destroyed first, the bindings and signal handlers in the dynamic object will no longer work.</source>
          <target state="translated">在管理动态创建的对象时,必须确保创建上下文比创建的对象要长。否则,如果创建上下文先被销毁,动态对象中的绑定和信号处理程序将不再工作。</target>
        </trans-unit>
        <trans-unit id="b19286d402c202adf58ff1b66a30b97e15b4a785" translate="yes" xml:space="preserve">
          <source>When manipulating selections, it is often helpful to think of &lt;a href=&quot;qitemselectionmodel&quot;&gt;QItemSelectionModel&lt;/a&gt; as a record of the selection state of all the items in an item model. Once a selection model is set up, collections of items can be selected, deselected, or their selection states can be toggled without the need to know which items are already selected. The indexes of all selected items can be retrieved at any time, and other components can be informed of changes to the selection model via the signals and slots mechanism.</source>
          <target state="translated">操纵选择时，将&lt;a href=&quot;qitemselectionmodel&quot;&gt;QItemSelectionModel&lt;/a&gt;视为项目模型中所有项目的选择状态的记录通常会很有帮助。一旦建立了选择模型，就可以选择，取消选择项目的集合，或者可以切换其选择状态，而无需知道已经选择了哪些项目。可以随时检索所有选定项目的索引，并且可以通过信号和时隙机制将选择模型的更改通知其他组件。</target>
        </trans-unit>
        <trans-unit id="d4893cb0b2ef7620d287061a0515bab60d47b9b9" translate="yes" xml:space="preserve">
          <source>When memory allocation fails, QByteArray throws a &lt;code&gt;std::bad_alloc&lt;/code&gt; exception if the application is being compiled with exception support. Out of memory conditions in Qt containers are the only case where Qt will throw exceptions. If exceptions are disabled, then running out of memory is undefined behavior.</source>
          <target state="translated">当内存分配失败时，如果正在使用异常支持编译应用程序，则QByteArray会引发 &lt;code&gt;std::bad_alloc&lt;/code&gt; 异常。Qt容器中的内存不足情况是Qt引发异常的唯一情况。如果禁用了例外，则用尽内存是未定义的行为。</target>
        </trans-unit>
        <trans-unit id="4fe612b6914bd28d3a91c181ce17418b66edda3f" translate="yes" xml:space="preserve">
          <source>When mirroring the layout using either the attached property &lt;a href=&quot;qml-qtquick-layoutmirroring#enabled-prop&quot;&gt;LayoutMirroring::enabled&lt;/a&gt; or by setting the &lt;a href=&quot;qml-qtquick-grid#layoutDirection-prop&quot;&gt;layoutDirection&lt;/a&gt;, the horizontal alignment of items will be mirrored as well. However, the property &lt;code&gt;horizontalItemAlignment&lt;/code&gt; will remain unchanged. To query the effective horizontal alignment of items, use the read-only property &lt;code&gt;effectiveHorizontalItemAlignment&lt;/code&gt;.</source>
          <target state="translated">当使用任一附加属性镜像布局&lt;a href=&quot;qml-qtquick-layoutmirroring#enabled-prop&quot;&gt;LayoutMirroring ::启用&lt;/a&gt;或通过设置&lt;a href=&quot;qml-qtquick-grid#layoutDirection-prop&quot;&gt;的layoutDirection&lt;/a&gt;，物品的水平取向将被镜像为好。但是，属性 &lt;code&gt;horizontalItemAlignment&lt;/code&gt; 将保持不变。要查询项目的有效水平对齐方式，请使用只读属性 &lt;code&gt;effectiveHorizontalItemAlignment&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e9debebd9aa12f2d598528bbeb0d545c66987f90" translate="yes" xml:space="preserve">
          <source>When mixing raw graphics (OpenGL, Vulkan, Metal, etc.) commands with scene graph rendering, it is necessary to call this function after recording commands to the command buffer used by the scene graph to render its main render pass. This is to avoid clobbering state.</source>
          <target state="translated">当将原始图形(OpenGL、Vulkan、Metal等)命令与场景图渲染混合时,有必要在将命令记录到场景图用于渲染其主渲染通道的命令缓冲区后调用此函数。这是为了避免出现clobbering状态。</target>
        </trans-unit>
        <trans-unit id="48e30ffa6a01f7853331128d4cf7b56aeea01dcd" translate="yes" xml:space="preserve">
          <source>When mixing raw graphics (OpenGL, Vulkan, Metal, etc.) commands with scene graph rendering, it is necessary to call this function before recording commands to the command buffer used by the scene graph to render its main render pass. This is to avoid clobbering state.</source>
          <target state="translated">当将原始图形(OpenGL、Vulkan、Metal等)命令与场景图渲染混合时,有必要在将命令记录到场景图用于渲染其主渲染通道的命令缓冲区之前调用此函数。这是为了避免出现clobbering状态。</target>
        </trans-unit>
        <trans-unit id="98292e6a711c0a97d142c6900df0dd3a1198f215" translate="yes" xml:space="preserve">
          <source>When model is not explicitly set, it will be synchronized with &lt;a href=&quot;qml-qtquick-controls2-verticalheaderview#syncView-prop&quot;&gt;syncView&lt;/a&gt;'s model once &lt;a href=&quot;qml-qtquick-controls2-verticalheaderview#syncView-prop&quot;&gt;syncView&lt;/a&gt; is set.</source>
          <target state="translated">如果模型没有明确设置，将与同步&lt;a href=&quot;qml-qtquick-controls2-verticalheaderview#syncView-prop&quot;&gt;syncView&lt;/a&gt;的模型一旦&lt;a href=&quot;qml-qtquick-controls2-verticalheaderview#syncView-prop&quot;&gt;syncView&lt;/a&gt;设置。</target>
        </trans-unit>
        <trans-unit id="67c4954bd29b0a4fd959263898f6a26791b7a7d0" translate="yes" xml:space="preserve">
          <source>When model is not explicitly set, the header will use the &lt;a href=&quot;qml-qtquick-controls2-horizontalheaderview#syncView-prop&quot;&gt;syncView&lt;/a&gt;'s model once &lt;a href=&quot;qml-qtquick-controls2-horizontalheaderview#syncView-prop&quot;&gt;syncView&lt;/a&gt; is set.</source>
          <target state="translated">如果模型没有明确设置，页眉将使用&lt;a href=&quot;qml-qtquick-controls2-horizontalheaderview#syncView-prop&quot;&gt;syncView&lt;/a&gt;的模型一旦&lt;a href=&quot;qml-qtquick-controls2-horizontalheaderview#syncView-prop&quot;&gt;syncView&lt;/a&gt;设置。</target>
        </trans-unit>
        <trans-unit id="ac2b797ba9d6873b70d7cdcf2a1e41cbc388241c" translate="yes" xml:space="preserve">
          <source>When multiple &lt;a href=&quot;opengl-changes-qt6#qopenglwidgets&quot;&gt;QOpenGLWidgets&lt;/a&gt; are added as children to the same top-level widget, their contexts will share with each other. This does not apply for QOpenGLWidget instances that belong to different windows.</source>
          <target state="translated">将多个&lt;a href=&quot;opengl-changes-qt6#qopenglwidgets&quot;&gt;QOpenGLWidget&lt;/a&gt;作为子级添加到同一顶层Widget时，它们的上下文将彼此共享。这不适用于属于不同窗口的QOpenGLWidget实例。</target>
        </trans-unit>
        <trans-unit id="b20aa7e6cd799e3bf7fad3e47e4d5468b0303506" translate="yes" xml:space="preserve">
          <source>When multiple QOpenGLWidgets are added as children to the same top-level widget, their contexts will share with each other. This does not apply for &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt; instances that belong to different windows.</source>
          <target state="translated">将多个QOpenGLWidgets作为子级添加到同一顶级Widget时，它们的上下文将彼此共享。这不适用于属于不同窗口的&lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt;实例。</target>
        </trans-unit>
        <trans-unit id="a052e77d465746dc1474a9b2e904f81e2b5f4c64" translate="yes" xml:space="preserve">
          <source>When multiple QOpenGLWidgets are added as children to the same top-level widget, their contexts will share with each other. This does not apply for QOpenGLWidget instances that belong to different windows.</source>
          <target state="translated">当多个 QOpenGLWidgets 被添加为同一顶层 widget 的子节点时,它们的上下文将相互共享。这不适用于属于不同窗口的 QOpenGLWidget 实例。</target>
        </trans-unit>
        <trans-unit id="be71f48901e09c1cafec1c8d3da6f3f42996e8be" translate="yes" xml:space="preserve">
          <source>When multiple render targets are in use,</source>
          <target state="translated">当使用多个渲染目标时。</target>
        </trans-unit>
        <trans-unit id="cca7faed1dcf3acb3787eb6ed52f3e078b4e846e" translate="yes" xml:space="preserve">
          <source>When multiple selectors could be applied to the same file, the first matching selector is chosen. The order selectors are checked in are:</source>
          <target state="translated">当多个选择器可以应用于同一个文件时,将选择第一个匹配的选择器。选择器被选中的顺序是:</target>
        </trans-unit>
        <trans-unit id="a2d60a792f80124c96dcd07ddb164770dfe0ca59" translate="yes" xml:space="preserve">
          <source>When multiple series are added to a graph, selecting an item in one of them will clear the selection on other series.</source>
          <target state="translated">当多个系列被添加到一个图形中时,选择其中一个系列的项目将清除其他系列的选择。</target>
        </trans-unit>
        <trans-unit id="b98c31c0b36eccbc7c80561d52175a75bcc24aef" translate="yes" xml:space="preserve">
          <source>When multiple textures are attached, the return value is the ID of the first one.</source>
          <target state="translated">当附加多个纹理时,返回值是第一个纹理的ID。</target>
        </trans-unit>
        <trans-unit id="5ea247c1f56cf273fe99668ba49d31b1b499bfbe" translate="yes" xml:space="preserve">
          <source>When multisample antialiasing is used, content rendered into framebuffer objects need additional extensions to support multisampling of framebuffers. Typically &lt;code&gt;GL_EXT_framebuffer_multisample&lt;/code&gt; and &lt;code&gt;GL_EXT_framebuffer_blit&lt;/code&gt;. Most desktop chips have these extensions present, but they are less common in embedded chips. When framebuffer multisampling is not available in the hardware, content rendered into framebuffer objects will not be antialiased, including the content of a &lt;a href=&quot;qml-qtquick-shadereffectsource&quot;&gt;ShaderEffectSource&lt;/a&gt;.</source>
          <target state="translated">使用多重采样抗锯齿时，渲染到帧缓冲区对象中的内容需要额外的扩展以支持帧缓冲区的多重采样。通常为 &lt;code&gt;GL_EXT_framebuffer_multisample&lt;/code&gt; 和 &lt;code&gt;GL_EXT_framebuffer_blit&lt;/code&gt; 。大多数台式机芯片都具有这些扩展名，但是在嵌入式芯片中却很少见。如果硬件中不提供帧缓冲区多重采样，则不会对渲染到帧缓冲区对象中的内容进行抗锯齿处理，包括&lt;a href=&quot;qml-qtquick-shadereffectsource&quot;&gt;ShaderEffectSource&lt;/a&gt;的内容。</target>
        </trans-unit>
        <trans-unit id="fccefc8901100b2f82142ca7d8bb3223d24d7501" translate="yes" xml:space="preserve">
          <source>When navigating the document structure, it is useful to begin at the root frame because it provides access to the entire document structure.</source>
          <target state="translated">在浏览文档结构时,从根框架开始是很有用的,因为它提供了对整个文档结构的访问。</target>
        </trans-unit>
        <trans-unit id="3e0a254e08acf9d6be4fd4d7a634988147b26055" translate="yes" xml:space="preserve">
          <source>When nested opacity gets below a certain threshold, the subtree might be marked as blocked, causing &lt;a href=&quot;qsgnode#isSubtreeBlocked&quot;&gt;isSubtreeBlocked&lt;/a&gt;() to return true. This is done for performance reasons.</source>
          <target state="translated">当嵌套的不透明度低于特定阈值时，子树可能被标记为已阻止，从而导致&lt;a href=&quot;qsgnode#isSubtreeBlocked&quot;&gt;isSubtreeBlocked&lt;/a&gt;（）返回true。这样做是出于性能原因。</target>
        </trans-unit>
        <trans-unit id="4d85ccf2069fc6eae18e11975d88bfe1fadc019f" translate="yes" xml:space="preserve">
          <source>When no windowing system is present, the mouse, keyboard and touch input are read directly via &lt;code&gt;evdev&lt;/code&gt;. Note that this requires that devices nodes &lt;code&gt;/input/event*&lt;/code&gt; are readable by the user. eglfs and vxworksfb has all the evdev input handling code built-in.</source>
          <target state="translated">如果没有窗口系统，则可以通过 &lt;code&gt;evdev&lt;/code&gt; 直接读取鼠标，键盘和触摸输入。请注意，这要求用户可以读取设备节点 &lt;code&gt;/input/event*&lt;/code&gt; 。eglfs和vxworksfb内置了所有evdev输入处理代码。</target>
        </trans-unit>
        <trans-unit id="5b0f164920aba9354f027a11efdb935f7ff22e14" translate="yes" xml:space="preserve">
          <source>When no windowing system is present, the mouse, keyboard, and touch input are read directly via &lt;code&gt;evdev&lt;/code&gt; or using helper libraries such as &lt;code&gt;libinput&lt;/code&gt; or &lt;code&gt;tslib&lt;/code&gt;. Note that this requires that device nodes &lt;code&gt;/dev/input/event*&lt;/code&gt; are readable by the user. &lt;code&gt;eglfs&lt;/code&gt; and &lt;code&gt;linuxfb&lt;/code&gt; have all the input handling code compiled-in.</source>
          <target state="translated">如果没有窗口系统，则可以通过 &lt;code&gt;evdev&lt;/code&gt; 或使用诸如 &lt;code&gt;libinput&lt;/code&gt; 或 &lt;code&gt;tslib&lt;/code&gt; 之类的帮助程序库直接读取鼠标，键盘和触摸输入。请注意，这要求用户可以读取设备节点 &lt;code&gt;/dev/input/event*&lt;/code&gt; 。 &lt;code&gt;eglfs&lt;/code&gt; 和 &lt;code&gt;linuxfb&lt;/code&gt; 具有所有已编译的输入处理代码。</target>
        </trans-unit>
        <trans-unit id="18d39e71149ec53d71da5bdfa496288bb4064e73" translate="yes" xml:space="preserve">
          <source>When not running with the RHI (and using OpenGL directly), the signal is emitted after the renderer has cleared the render target. This makes it possible to create applications that function identically both with and without the RHI.</source>
          <target state="translated">当不使用RHI运行时(直接使用OpenGL),信号会在渲染器清除渲染目标后发出。这使得创建有RHI和没有RHI的应用程序成为可能。</target>
        </trans-unit>
        <trans-unit id="a0721c385a99233431f8667a3ee0ae4fedf149b4" translate="yes" xml:space="preserve">
          <source>When not running with the RHI (and using OpenGL directly), the signal is emitted after the renderer has finished its rendering, but before &lt;a href=&quot;qquickwindow#afterRendering&quot;&gt;afterRendering&lt;/a&gt;(). This makes it possible to create applications that function identically both with and without the RHI.</source>
          <target state="translated">如果不与RHI一起运行（并直接使用OpenGL），则在渲染器完成渲染之后但在&lt;a href=&quot;qquickwindow#afterRendering&quot;&gt;afterRendering&lt;/a&gt;（）之前发出信号。这使得创建带有RHI和不带有RHI的相同功能的应用程序成为可能。</target>
        </trans-unit>
        <trans-unit id="dca5d911ae2265eef32ee4fee8077e25696a9db8" translate="yes" xml:space="preserve">
          <source>When one of the statements is a non-select statement a count of affected rows may be available instead of a result set.</source>
          <target state="translated">当其中一条语句是非选择语句时,可能会有受影响行的计数,而不是结果集。</target>
        </trans-unit>
        <trans-unit id="e9136aaa0ef09df9e9f07e3241b2a9f838fd494d" translate="yes" xml:space="preserve">
          <source>When operating in deterministic mode, &lt;a href=&quot;qrandomgenerator&quot;&gt;QRandomGenerator&lt;/a&gt; may be used for bulk data generation. In fact, applications that do not need cryptographically-secure or true random data are advised to use a regular &lt;a href=&quot;qrandomgenerator&quot;&gt;QRandomGenerator&lt;/a&gt; instead of &lt;a href=&quot;qrandomgenerator#system&quot;&gt;QRandomGenerator::system&lt;/a&gt;() for their random data needs.</source>
          <target state="translated">在确定性模式下运行时，&lt;a href=&quot;qrandomgenerator&quot;&gt;QRandomGenerator&lt;/a&gt;可用于批量数据生成。实际上，建议不需要密码安全或真实随机数据的应用程序使用常规&lt;a href=&quot;qrandomgenerator&quot;&gt;QRandomGenerator&lt;/a&gt;代替&lt;a href=&quot;qrandomgenerator#system&quot;&gt;QRandomGenerator :: system&lt;/a&gt;（）来满足其随机数据需求。</target>
        </trans-unit>
        <trans-unit id="601025c900ae42d4debb597407723c06012bd462" translate="yes" xml:space="preserve">
          <source>When operating in deterministic mode, QRandomGenerator may be used for bulk data generation. In fact, applications that do not need cryptographically-secure or true random data are advised to use a regular QRandomGenerator instead of &lt;a href=&quot;qrandomgenerator#system&quot;&gt;QRandomGenerator::system&lt;/a&gt;() for their random data needs.</source>
          <target state="translated">在确定性模式下运行时，QRandomGenerator可用于批量数据生成。实际上，建议不需要密码安全或真实随机数据的应用程序使用常规QRandomGenerator代替&lt;a href=&quot;qrandomgenerator#system&quot;&gt;QRandomGenerator :: system&lt;/a&gt;（）来满足其随机数据需求。</target>
        </trans-unit>
        <trans-unit id="ca0c853a6a3df272210d1c9d0c36c813572cdfe7" translate="yes" xml:space="preserve">
          <source>When operating on managed objects in normal C++ code, a little extra care must be taken because of the CLR's garbage collection. A normal pointer variable should not</source>
          <target state="translated">在正常的C++代码中对托管对象进行操作时,由于CLR的垃圾回收,必须格外小心。一个普通的指针变量不应该</target>
        </trans-unit>
        <trans-unit id="ea7e897063825784978303959c1455b5d44412c2" translate="yes" xml:space="preserve">
          <source>When options can be grouped, you can use a partially checked &lt;a href=&quot;qml-qtquick-controls2-checkbox&quot;&gt;CheckBox&lt;/a&gt; to represent the whole group. Use the checkbox's &lt;a href=&quot;qml-qtquick-controls2-checkbox#checkState-prop&quot;&gt;partially checked state&lt;/a&gt; when a user selects some, but not all, sub-items in the group.</source>
          <target state="translated">如果可以对选项进行分组，则可以使用部分选中的&lt;a href=&quot;qml-qtquick-controls2-checkbox&quot;&gt;CheckBox&lt;/a&gt;代表整个组。当用户选择组中的一些而非全部子项时，请使用复选框的&lt;a href=&quot;qml-qtquick-controls2-checkbox#checkState-prop&quot;&gt;部分选中状态&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fe4c38cfe45b7ff5d5ad3092c911b19539b422d2" translate="yes" xml:space="preserve">
          <source>When painting to a &lt;a href=&quot;qopenglpaintdevice&quot;&gt;QOpenGLPaintDevice&lt;/a&gt; using &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;, the state of the current OpenGL context will be altered by the paint engine to reflect its needs. Applications should not rely upon the OpenGL state being reset to its original conditions, particularly the current shader program, OpenGL viewport, texture units, and drawing modes.</source>
          <target state="translated">使用&lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;绘画到&lt;a href=&quot;qopenglpaintdevice&quot;&gt;QOpenGLPaintDevice&lt;/a&gt;时，绘画引擎将更改当前OpenGL上下文的状态以反映其需求。应用程序不应依赖于将OpenGL状态重置为其原始状态，尤其是当前的着色器程序，OpenGL视口，纹理单位和绘图模式。</target>
        </trans-unit>
        <trans-unit id="76720392a96856f8c1e5f2c5c0b848262c8e8089" translate="yes" xml:space="preserve">
          <source>When painting to a QOpenGLPaintDevice using &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;, the state of the current OpenGL context will be altered by the paint engine to reflect its needs. Applications should not rely upon the OpenGL state being reset to its original conditions, particularly the current shader program, OpenGL viewport, texture units, and drawing modes.</source>
          <target state="translated">使用&lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;绘画到QOpenGLPaintDevice时，绘画引擎将更改当前OpenGL上下文的状态以反映其需求。应用程序不应依赖于将OpenGL状态重置为其原始状态，尤其是当前的着色器程序，OpenGL视口，纹理单位和绘图模式。</target>
        </trans-unit>
        <trans-unit id="8e4b844ee7e4c5be1b0dab1bbe7aaa712b977db0" translate="yes" xml:space="preserve">
          <source>When paused, the current frame can be advanced manually by setting this property or calling &lt;a href=&quot;qml-qtquick-animatedsprite#advance-method&quot;&gt;advance()&lt;/a&gt;.</source>
          <target state="translated">暂停后，可以通过设置此属性或调用&lt;a href=&quot;qml-qtquick-animatedsprite#advance-method&quot;&gt;advance（）&lt;/a&gt;来手动推进当前帧。</target>
        </trans-unit>
        <trans-unit id="36bc00e334ac8aa1eea3755d12934f7608da4dea" translate="yes" xml:space="preserve">
          <source>When paused, the current frame can be advanced manually.</source>
          <target state="translated">暂停时,可手动推进当前帧。</target>
        </trans-unit>
        <trans-unit id="40753593df1bbb77361dbb8a61ae51ec564eb417" translate="yes" xml:space="preserve">
          <source>When performing a lookup on a service, zero or more records will be returned. Each record is represented by a &lt;a href=&quot;qdnsmailexchangerecord&quot;&gt;QDnsMailExchangeRecord&lt;/a&gt; instance.</source>
          <target state="translated">在服务上执行查找时，将返回零个或多个记录。每个记录均由&lt;a href=&quot;qdnsmailexchangerecord&quot;&gt;QDnsMailExchangeRecord&lt;/a&gt;实例表示。</target>
        </trans-unit>
        <trans-unit id="745159504ea8964595662dfda6ea6803520cab14" translate="yes" xml:space="preserve">
          <source>When performing a lookup on a service, zero or more records will be returned. Each record is represented by a &lt;a href=&quot;qdnsservicerecord&quot;&gt;QDnsServiceRecord&lt;/a&gt; instance.</source>
          <target state="translated">在服务上执行查找时，将返回零个或多个记录。每个记录由一个&lt;a href=&quot;qdnsservicerecord&quot;&gt;QDnsServiceRecord&lt;/a&gt;实例表示。</target>
        </trans-unit>
        <trans-unit id="6d6001a94eae9d4e4679d672b10ebf1476ba4b97" translate="yes" xml:space="preserve">
          <source>When performing a lookup on a service, zero or more records will be returned. Each record is represented by a QDnsMailExchangeRecord instance.</source>
          <target state="translated">当对一个服务进行查询时,将返回零条或多条记录,每条记录由一个QDnsMailExchangeRecord实例表示。每条记录由一个QDnsMailExchangeRecord实例表示。</target>
        </trans-unit>
        <trans-unit id="183c9e6bf9945fe2d7c4f1ece374cc4634d591ca" translate="yes" xml:space="preserve">
          <source>When performing a lookup on a service, zero or more records will be returned. Each record is represented by a QDnsServiceRecord instance.</source>
          <target state="translated">当对一个服务进行查找时,将返回零条或多条记录。每条记录由一个QDnsServiceRecord实例表示。</target>
        </trans-unit>
        <trans-unit id="89b6dd291204471e81a34c81e897e2eae987238a" translate="yes" xml:space="preserve">
          <source>When performing a name server lookup, zero or more records will be returned. Each record is represented by a &lt;a href=&quot;qdnsdomainnamerecord&quot;&gt;QDnsDomainNameRecord&lt;/a&gt; instance.</source>
          <target state="translated">执行名称服务器查找时，将返回零个或多个记录。每个记录由一个&lt;a href=&quot;qdnsdomainnamerecord&quot;&gt;QDnsDomainNameRecord&lt;/a&gt;实例表示。</target>
        </trans-unit>
        <trans-unit id="d31385d56b863dd8dbd104e645dc9977d21a36cc" translate="yes" xml:space="preserve">
          <source>When performing a name server lookup, zero or more records will be returned. Each record is represented by a QDnsDomainNameRecord instance.</source>
          <target state="translated">当执行名称服务器查询时,将返回零条或多条记录。每条记录由一个QDnsDomainNameRecord实例表示。</target>
        </trans-unit>
        <trans-unit id="3612e920959430b2f4633a7ed7ecb7c74231f462" translate="yes" xml:space="preserve">
          <source>When performing a text lookup, zero or more records will be returned. Each record is represented by a &lt;a href=&quot;qdnstextrecord&quot;&gt;QDnsTextRecord&lt;/a&gt; instance.</source>
          <target state="translated">执行文本查找时，将返回零个或多个记录。每个记录由一个&lt;a href=&quot;qdnstextrecord&quot;&gt;QDnsTextRecord&lt;/a&gt;实例表示。</target>
        </trans-unit>
        <trans-unit id="909f4885c9471951ef724c0551ca405b8644c385" translate="yes" xml:space="preserve">
          <source>When performing a text lookup, zero or more records will be returned. Each record is represented by a QDnsTextRecord instance.</source>
          <target state="translated">当执行文本查询时,将返回零条或多条记录。每条记录由一个QDnsTextRecord实例表示。</target>
        </trans-unit>
        <trans-unit id="711a9f71466771c6e4aade7928b9960c7cefd54f" translate="yes" xml:space="preserve">
          <source>When performing an address lookup, zero or more records will be returned. Each record is represented by a &lt;a href=&quot;qdnshostaddressrecord&quot;&gt;QDnsHostAddressRecord&lt;/a&gt; instance.</source>
          <target state="translated">执行地址查找时，将返回零个或多个记录。每个记录由一个&lt;a href=&quot;qdnshostaddressrecord&quot;&gt;QDnsHostAddressRecord&lt;/a&gt;实例表示。</target>
        </trans-unit>
        <trans-unit id="be3ad2654f5fa7ba6e1f52aec206ab62cc47cc26" translate="yes" xml:space="preserve">
          <source>When performing an address lookup, zero or more records will be returned. Each record is represented by a QDnsHostAddressRecord instance.</source>
          <target state="translated">当执行地址查询时,将返回零条或多条记录。每条记录由一个QDnsHostAddressRecord实例表示。</target>
        </trans-unit>
        <trans-unit id="63db06c50e58a3513cea1497dec1ed7741831f0b" translate="yes" xml:space="preserve">
          <source>When performing drawing using &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; only, it is also possible to perform the painting like it is done for ordinary widgets: by reimplementing &lt;a href=&quot;qopenglwidget#paintEvent&quot;&gt;paintEvent&lt;/a&gt;().</source>
          <target state="translated">仅使用&lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;执行绘图时，还可以像执行普通小部件一样执行绘图：通过重新实现&lt;a href=&quot;qopenglwidget#paintEvent&quot;&gt;paintEvent&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="4873852a94448fd952353de01e74e6bb7112405f" translate="yes" xml:space="preserve">
          <source>When performing verification steps in an autotest using &lt;a href=&quot;qtest#QCOMPARE&quot;&gt;QCOMPARE&lt;/a&gt;(), &lt;a href=&quot;qtest#QVERIFY&quot;&gt;QVERIFY&lt;/a&gt;(), and so on, side-effects should be avoided. Side-effects in verification steps can make a test difficult to understand. Also, they can easily break a test in ways that are difficult to diagnose when the test is changed to use &lt;a href=&quot;qtest#QTRY_VERIFY&quot;&gt;QTRY_VERIFY&lt;/a&gt;(), &lt;a href=&quot;qtest#QTRY_COMPARE&quot;&gt;QTRY_COMPARE&lt;/a&gt;() or &lt;a href=&quot;qtest#QBENCHMARK&quot;&gt;QBENCHMARK&lt;/a&gt;(). These can execute the passed expression multiple times, thus repeating any side-effects.</source>
          <target state="translated">使用&lt;a href=&quot;qtest#QCOMPARE&quot;&gt;QCOMPARE&lt;/a&gt;（），&lt;a href=&quot;qtest#QVERIFY&quot;&gt;QVERIFY&lt;/a&gt;（）等在自动测试中执行验证步骤时，应避免产生副作用。验证步骤中的副作用可能会使测试难以理解。此外，当将测试更改为使用&lt;a href=&quot;qtest#QTRY_VERIFY&quot;&gt;QTRY_VERIFY&lt;/a&gt;（），&lt;a href=&quot;qtest#QTRY_COMPARE&quot;&gt;QTRY_COMPARE&lt;/a&gt;（）或&lt;a href=&quot;qtest#QBENCHMARK&quot;&gt;QBENCHMARK&lt;/a&gt;（）时，它们很容易以难以诊断的方式中断测试。它们可以多次执行传递的表达式，从而重复出现任何副作用。</target>
        </trans-unit>
        <trans-unit id="38db5be01962103a3cc7ed36e0dd26d7c49283ec" translate="yes" xml:space="preserve">
          <source>When placed into a &lt;code&gt;.qml&lt;/code&gt; file and loaded by the QML engine, the above code creates a &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; object using the &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; type supplied by the &lt;code&gt;QtQuick&lt;/code&gt; module:</source>
          <target state="translated">当放置到 &lt;code&gt;.qml&lt;/code&gt; 文件中并由QML引擎加载时，以上代码使用 &lt;code&gt;QtQuick&lt;/code&gt; 模块提供的&lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt;类型创建&lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt;对象：</target>
        </trans-unit>
        <trans-unit id="6927c0eac9201c4bf4c31b692534ebe1bbcfa831" translate="yes" xml:space="preserve">
          <source>When populating a layout, the widgets are added to an internal list. The &lt;a href=&quot;qlayout#indexOf&quot;&gt;indexOf&lt;/a&gt;() function returns the index of a widget in that list. The widgets can either be added to the end of the list using the &lt;a href=&quot;qstackedlayout#addWidget&quot;&gt;addWidget&lt;/a&gt;() function, or inserted at a given index using the &lt;a href=&quot;qstackedlayout#insertWidget&quot;&gt;insertWidget&lt;/a&gt;() function. The &lt;a href=&quot;qlayout#removeWidget&quot;&gt;removeWidget&lt;/a&gt;() function removes the widget at the given index from the layout. The number of widgets contained in the layout, can be obtained using the &lt;a href=&quot;qstackedlayout#count-prop&quot;&gt;count&lt;/a&gt;() function.</source>
          <target state="translated">填充布局时，小部件将添加到内部列表中。该&lt;a href=&quot;qlayout#indexOf&quot;&gt;的indexOf&lt;/a&gt;（）函数返回该列表中的控件的索引。窗口小部件可以被添加到使用列表的末尾&lt;a href=&quot;qstackedlayout#addWidget&quot;&gt;addWidget&lt;/a&gt;（）函数，或插入使用一个给定的索引处&lt;a href=&quot;qstackedlayout#insertWidget&quot;&gt;insertWidget&lt;/a&gt;（）函数。所述&lt;a href=&quot;qlayout#removeWidget&quot;&gt;removeWidget&lt;/a&gt;（）函数将删除布局给定索引处的窗口小部件。可以使用&lt;a href=&quot;qstackedlayout#count-prop&quot;&gt;count&lt;/a&gt;（）函数获取布局中包含的小部件数量。</target>
        </trans-unit>
        <trans-unit id="9c28b221f7e83baed059e2a307e039e7c948b005" translate="yes" xml:space="preserve">
          <source>When populating a stacked widget, the widgets are added to an internal list. The &lt;a href=&quot;qstackedwidget#indexOf&quot;&gt;indexOf&lt;/a&gt;() function returns the index of a widget in that list. The widgets can either be added to the end of the list using the &lt;a href=&quot;qstackedwidget#addWidget&quot;&gt;addWidget&lt;/a&gt;() function, or inserted at a given index using the &lt;a href=&quot;qstackedwidget#insertWidget&quot;&gt;insertWidget&lt;/a&gt;() function. The &lt;a href=&quot;qstackedwidget#removeWidget&quot;&gt;removeWidget&lt;/a&gt;() function removes a widget from the stacked widget. The number of widgets contained in the stacked widget can be obtained using the &lt;a href=&quot;qstackedwidget#count-prop&quot;&gt;count&lt;/a&gt;() function.</source>
          <target state="translated">当填充堆叠的窗口小部件时，这些窗口小部件将添加到内部列表中。该&lt;a href=&quot;qstackedwidget#indexOf&quot;&gt;的indexOf&lt;/a&gt;（）函数返回该列表中的控件的索引。窗口小部件可以被添加到使用列表的末尾&lt;a href=&quot;qstackedwidget#addWidget&quot;&gt;addWidget&lt;/a&gt;（）函数，或插入使用一个给定的索引处&lt;a href=&quot;qstackedwidget#insertWidget&quot;&gt;insertWidget&lt;/a&gt;（）函数。所述&lt;a href=&quot;qstackedwidget#removeWidget&quot;&gt;removeWidget&lt;/a&gt;（）函数删除从层叠微件的微件。可以使用&lt;a href=&quot;qstackedwidget#count-prop&quot;&gt;count&lt;/a&gt;（）函数获取堆叠的小部件中包含的小部件的数量。</target>
        </trans-unit>
        <trans-unit id="543155192f84c64b5b7246452a09145b18b3004c" translate="yes" xml:space="preserve">
          <source>When popup windows are visible, this property is &lt;code&gt;true&lt;/code&gt; for both the active window</source>
          <target state="translated">当弹出窗口可见时，此属性对于两个活动窗口均为 &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bf9f03d6670f0731b056deb6a40d087fcc1eaf19" translate="yes" xml:space="preserve">
          <source>When positioning a menu with &lt;a href=&quot;qmenu#exec&quot;&gt;exec&lt;/a&gt;() or &lt;a href=&quot;qmenu#popup&quot;&gt;popup&lt;/a&gt;(), bear in mind that you cannot rely on the menu's current &lt;a href=&quot;qwidget#size-prop&quot;&gt;size&lt;/a&gt;(). For performance reasons, the menu adapts its size only when necessary. So in many cases, the size before and after the show is different. Instead, use &lt;a href=&quot;qmenu#sizeHint&quot;&gt;sizeHint&lt;/a&gt;() which calculates the proper size depending on the menu's current contents.</source>
          <target state="translated">使用&lt;a href=&quot;qmenu#exec&quot;&gt;exec&lt;/a&gt;（）或&lt;a href=&quot;qmenu#popup&quot;&gt;popup&lt;/a&gt;（）定位菜单时，请记住，您不能依赖菜单的当前&lt;a href=&quot;qwidget#size-prop&quot;&gt;大小&lt;/a&gt;（）。出于性能原因，菜单仅在必要时才调整其大小。因此，在很多情况下，演出前后的尺寸是不同的。而是使用&lt;a href=&quot;qmenu#sizeHint&quot;&gt;sizeHint&lt;/a&gt;（）来根据菜单的当前内容计算适当的大小。</target>
        </trans-unit>
        <trans-unit id="d446cf9e4868843729e697b92b7ac122b7540da1" translate="yes" xml:space="preserve">
          <source>When positioning a menu with &lt;a href=&quot;qmenu#exec&quot;&gt;exec&lt;/a&gt;() or popup(), bear in mind that you cannot rely on the menu's current &lt;a href=&quot;qwidget#size-prop&quot;&gt;size&lt;/a&gt;(). For performance reasons, the menu adapts its size only when necessary, so in many cases, the size before and after the show is different. Instead, use &lt;a href=&quot;qmenu#sizeHint&quot;&gt;sizeHint&lt;/a&gt;() which calculates the proper size depending on the menu's current contents.</source>
          <target state="translated">使用&lt;a href=&quot;qmenu#exec&quot;&gt;exec&lt;/a&gt;（）或popup（）定位菜单时，请记住您不能依赖菜单的当前&lt;a href=&quot;qwidget#size-prop&quot;&gt;大小&lt;/a&gt;（）。出于性能原因，菜单仅在必要时才调整其大小，因此在许多情况下，显示前后的大小是不同的。而是使用&lt;a href=&quot;qmenu#sizeHint&quot;&gt;sizeHint&lt;/a&gt;（）来根据菜单的当前内容计算适当的大小。</target>
        </trans-unit>
        <trans-unit id="7029c6cc034ef3f728d2bd0679222f0a517d5042" translate="yes" xml:space="preserve">
          <source>When positioning a menu with exec() or &lt;a href=&quot;qmenu#popup&quot;&gt;popup&lt;/a&gt;(), bear in mind that you cannot rely on the menu's current &lt;a href=&quot;qwidget#size-prop&quot;&gt;size&lt;/a&gt;(). For performance reasons, the menu adapts its size only when necessary. So in many cases, the size before and after the show is different. Instead, use &lt;a href=&quot;qmenu#sizeHint&quot;&gt;sizeHint&lt;/a&gt;() which calculates the proper size depending on the menu's current contents.</source>
          <target state="translated">使用exec（）或&lt;a href=&quot;qmenu#popup&quot;&gt;popup&lt;/a&gt;（）定位菜单时，请记住您不能依赖菜单的当前&lt;a href=&quot;qwidget#size-prop&quot;&gt;大小&lt;/a&gt;（）。出于性能原因，菜单仅在必要时才调整其大小。因此，在很多情况下，演出前后的尺寸是不同的。而是使用&lt;a href=&quot;qmenu#sizeHint&quot;&gt;sizeHint&lt;/a&gt;（）来根据菜单的当前内容计算适当的大小。</target>
        </trans-unit>
        <trans-unit id="b83e6f455038d9e44dcc627b24af2f87bdc39ec9" translate="yes" xml:space="preserve">
          <source>When possible, it is usually better style to disable the &lt;b&gt;Next&lt;/b&gt; or &lt;b&gt;Finish&lt;/b&gt; button (by specifying &lt;a href=&quot;qwizard#mandatory-fields&quot;&gt;mandatory fields&lt;/a&gt; or by reimplementing &lt;a href=&quot;qwizardpage#isComplete&quot;&gt;QWizardPage::isComplete&lt;/a&gt;()) than to reimplement validateCurrentPage().</source>
          <target state="translated">如果可能的话，禁用&amp;ldquo; &lt;b&gt;下一步&amp;rdquo;&lt;/b&gt;或&amp;ldquo; &lt;b&gt;完成&amp;rdquo;&lt;/b&gt;按钮（通过指定&lt;a href=&quot;qwizard#mandatory-fields&quot;&gt;必填字段&lt;/a&gt;或重新实现&lt;a href=&quot;qwizardpage#isComplete&quot;&gt;QWizardPage :: isComplete&lt;/a&gt;（））通常比重新实现validateCurrentPage（）更好。</target>
        </trans-unit>
        <trans-unit id="73d1c2ff7aa2a64e8d25144a78e96a2f710b582a" translate="yes" xml:space="preserve">
          <source>When possible, it is usually better style to disable the &lt;b&gt;Next&lt;/b&gt; or &lt;b&gt;Finish&lt;/b&gt; button (by specifying &lt;a href=&quot;qwizard#mandatory-fields&quot;&gt;mandatory fields&lt;/a&gt; or reimplementing &lt;a href=&quot;qwizardpage#isComplete&quot;&gt;isComplete&lt;/a&gt;()) than to reimplement validatePage().</source>
          <target state="translated">如果可能的话，禁用&amp;ldquo; &lt;b&gt;下一步&amp;rdquo;&lt;/b&gt;或&amp;ldquo; &lt;b&gt;完成&amp;rdquo;&lt;/b&gt;按钮（通过指定&lt;a href=&quot;qwizard#mandatory-fields&quot;&gt;必填字段&lt;/a&gt;或重新实现&lt;a href=&quot;qwizardpage#isComplete&quot;&gt;isComplete&lt;/a&gt;（））通常比重新实现validatePage（）更好。</target>
        </trans-unit>
        <trans-unit id="4c25870dd84e6151f006f88996bd899f2da5153f" translate="yes" xml:space="preserve">
          <source>When possible, this static function will use the native file dialog and not a &lt;a href=&quot;qfiledialog&quot;&gt;QFileDialog&lt;/a&gt;. On platforms which don't support selecting remote files, Qt will allow to select only local files.</source>
          <target state="translated">如果可能，此静态函数将使用本机文件对话框，而不使用&lt;a href=&quot;qfiledialog&quot;&gt;QFileDialog&lt;/a&gt;。在不支持选择远程文件的平台上，Qt将仅允许选择本地文件。</target>
        </trans-unit>
        <trans-unit id="0b489fbd5401aea28516b412c3104164f51acbe1" translate="yes" xml:space="preserve">
          <source>When posting a custom event to the state machine, you typically also have one or more custom transitions that can be triggered from events of that type. To create such a transition, you subclass &lt;a href=&quot;qabstracttransition&quot;&gt;QAbstractTransition&lt;/a&gt; and reimplement &lt;a href=&quot;qabstracttransition#eventTest&quot;&gt;QAbstractTransition::eventTest&lt;/a&gt;(), where you check if an event matches your event type (and optionally other criteria, e.g. attributes of the event object).</source>
          <target state="translated">将自定义事件发布到状态机时，通常还具有一个或多个可从该类型的事件触发的自定义转换。要创建这样的过渡，请子类化&lt;a href=&quot;qabstracttransition&quot;&gt;QAbstractTransition&lt;/a&gt;并重新实现&lt;a href=&quot;qabstracttransition#eventTest&quot;&gt;QAbstractTransition :: eventTest&lt;/a&gt;（），在其中检查事件是否与事件类型（以及可选的其他条件，例如事件对象的属性）匹配。</target>
        </trans-unit>
        <trans-unit id="c0626bfe8658560f4b9456379db258ae7347f2e4" translate="yes" xml:space="preserve">
          <source>When present in a state set, enables the seamless cubemap texture filtering as provided by the GL_ARB_seamless_cubemap extension (if available).</source>
          <target state="translated">在状态集中存在时,启用GL_ARB_seamless_cubemap扩展提供的无缝cubemap纹理过滤功能(如果可用)。</target>
        </trans-unit>
        <trans-unit id="dd42c97f91ca6cd533ba12641c6d6512a8021b98" translate="yes" xml:space="preserve">
          <source>When pressing the &quot;Pick Screen Color&quot; button, the cursor changes to a haircross and the colors on the screen are scanned. The user can pick up one by clicking the mouse or the Enter button. Pressing Escape restores the last color selected before entering this mode.</source>
          <target state="translated">当按下 &quot;拾取屏幕颜色 &quot;按钮时,光标会变成一个发叉,并扫描屏幕上的颜色。用户可以通过点击鼠标或回车键选取一种。按 &quot;Escape &quot;键可恢复进入该模式前最后选择的颜色。</target>
        </trans-unit>
        <trans-unit id="365ed507c80ed465082d4faf723c11a4f4a529f9" translate="yes" xml:space="preserve">
          <source>When printing directly to a printer on Windows or &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, &lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt; uses the built-in printer drivers. On X11, &lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt; uses the &lt;a href=&quot;http://www.cups.org/&quot;&gt;Common Unix Printing System (CUPS)&lt;/a&gt; to send PDF output to the printer. As an alternative, the &lt;a href=&quot;qprinter#printProgram&quot;&gt;printProgram&lt;/a&gt;() function can be used to specify the command or utility to use instead of the system default.</source>
          <target state="translated">在Windows或&lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;上直接打印到打印机时，&lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt;使用内置的打印机驱动程序。在X11上，&lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt;使用&lt;a href=&quot;http://www.cups.org/&quot;&gt;通用Unix打印系统（CUPS）&lt;/a&gt;将PDF输出发送到打印机。或者，可以使用&lt;a href=&quot;qprinter#printProgram&quot;&gt;printProgram&lt;/a&gt;（）函数来指定要使用的命令或实用程序，而不是系统默认值。</target>
        </trans-unit>
        <trans-unit id="9cee561b8e10ced76ed482af9619144ea4d1c14b" translate="yes" xml:space="preserve">
          <source>When printing directly to a printer on Windows or macOS, QPrinter uses the built-in printer drivers. On X11, QPrinter uses the &lt;a href=&quot;http://www.cups.org/&quot;&gt;Common Unix Printing System (CUPS)&lt;/a&gt; to send PDF output to the printer. As an alternative, the &lt;a href=&quot;qprinter#printProgram&quot;&gt;printProgram&lt;/a&gt;() function can be used to specify the command or utility to use instead of the system default.</source>
          <target state="translated">在Windows或macOS上直接打印到打印机时，QPrinter使用内置的打印机驱动程序。在X11上，QPrinter使用&lt;a href=&quot;http://www.cups.org/&quot;&gt;通用Unix打印系统（CUPS）&lt;/a&gt;将PDF输出发送到打印机。或者，可以使用&lt;a href=&quot;qprinter#printProgram&quot;&gt;printProgram&lt;/a&gt;（）函数来指定要使用的命令或实用程序，而不是系统默认值。</target>
        </trans-unit>
        <trans-unit id="8a917bfc1eb7e2e0eb94d05c9dbd0fafafddce11" translate="yes" xml:space="preserve">
          <source>When printing directly to a printer on Windows or macOS, QPrinter uses the built-in printer drivers. On X11, QPrinter uses the &lt;a href=&quot;https://www.cups.org/&quot;&gt;Common Unix Printing System (CUPS)&lt;/a&gt; to send PDF output to the printer. As an alternative, the &lt;a href=&quot;qprinter#printProgram&quot;&gt;printProgram&lt;/a&gt;() function can be used to specify the command or utility to use instead of the system default.</source>
          <target state="translated">在Windows或macOS上直接打印到打印机时，QPrinter使用内置的打印机驱动程序。在X11上，QPrinter使用&lt;a href=&quot;https://www.cups.org/&quot;&gt;通用Unix打印系统（CUPS）&lt;/a&gt;将PDF输出发送到打印机。或者，可以使用&lt;a href=&quot;qprinter#printProgram&quot;&gt;printProgram&lt;/a&gt;（）函数来指定要使用的命令或实用程序，而不是系统默认值。</target>
        </trans-unit>
        <trans-unit id="7baf1526ab727030bb94d023b433c10155cb76be" translate="yes" xml:space="preserve">
          <source>When processing</source>
          <target state="translated">处理时</target>
        </trans-unit>
        <trans-unit id="6d2106bb45d40ac84dd2228f91e6e53dfdbe85fe" translate="yes" xml:space="preserve">
          <source>When processing any of the \code, &lt;a href=&quot;#newcode-command&quot;&gt;\newcode&lt;/a&gt; or &lt;a href=&quot;#oldcode-command&quot;&gt;\oldcode&lt;/a&gt; commands, QDoc removes all indentation that is common for the verbatim code blocks within a &lt;code&gt;/&lt;/code&gt;&lt;code&gt;*!&lt;/code&gt; ... &lt;code&gt;*&lt;/code&gt;&lt;code&gt;/&lt;/code&gt; comment before it adds the standard indentation.</source>
          <target state="translated">当处理任何\ code，&lt;a href=&quot;#newcode-command&quot;&gt;\ newcode&lt;/a&gt;或&lt;a href=&quot;#oldcode-command&quot;&gt;\ oldcode&lt;/a&gt;命令时，QDoc会删除 &lt;code&gt;/&lt;/code&gt; &lt;code&gt;*!&lt;/code&gt; 内逐字代码块通用的所有缩进！... &lt;code&gt;*&lt;/code&gt; &lt;code&gt;/&lt;/code&gt; 在添加标准缩进之前添加注释。</target>
        </trans-unit>
        <trans-unit id="8ac017cc68b793557123c9ce971931fa3dec416c" translate="yes" xml:space="preserve">
          <source>When processing any of the \code, &lt;a href=&quot;06-qdoc-commands-includecodeinline#newcode-command&quot;&gt;\newcode&lt;/a&gt; or &lt;a href=&quot;06-qdoc-commands-includecodeinline#oldcode-command&quot;&gt;\oldcode&lt;/a&gt; commands, QDoc removes all indentation that is common for the verbatim code blocks within a &lt;code&gt;/&lt;/code&gt;&lt;code&gt;*!&lt;/code&gt; ... &lt;code&gt;*&lt;/code&gt;&lt;code&gt;/&lt;/code&gt; comment before it adds the standard indentation.</source>
          <target state="translated">当处理任何\ code，&lt;a href=&quot;06-qdoc-commands-includecodeinline#newcode-command&quot;&gt;\ newcode&lt;/a&gt;或&lt;a href=&quot;06-qdoc-commands-includecodeinline#oldcode-command&quot;&gt;\ oldcode&lt;/a&gt;命令时，QDoc会删除 &lt;code&gt;/&lt;/code&gt; &lt;code&gt;*!&lt;/code&gt; 内逐字代码块通用的所有缩进！... &lt;code&gt;*&lt;/code&gt; &lt;code&gt;/&lt;/code&gt; 在添加标准缩进之前先进行注释。</target>
        </trans-unit>
        <trans-unit id="0cc162586167c5dda9673822a3e347c76baa904e" translate="yes" xml:space="preserve">
          <source>When processing the &lt;code&gt;headers&lt;/code&gt; variable, QDoc behaves in the same way as it does when processing the &lt;a href=&quot;#headerdirs&quot;&gt;&lt;code&gt;headerdirs&lt;/code&gt;&lt;/a&gt; variable. For more information, see the &lt;a href=&quot;#headerdirs&quot;&gt;&lt;code&gt;headerdirs&lt;/code&gt;&lt;/a&gt; variable.</source>
          <target state="translated">在处理 &lt;code&gt;headers&lt;/code&gt; 变量时，QDoc的行为与处理&lt;a href=&quot;#headerdirs&quot;&gt; &lt;code&gt;headerdirs&lt;/code&gt; &lt;/a&gt;变量时的行为相同。有关更多信息，请参见&lt;a href=&quot;#headerdirs&quot;&gt; &lt;code&gt;headerdirs&lt;/code&gt; &lt;/a&gt;变量。</target>
        </trans-unit>
        <trans-unit id="9f6649e82a5699a0360075ae40dd46b9e5c7a464" translate="yes" xml:space="preserve">
          <source>When processing the &lt;code&gt;headers&lt;/code&gt; variable, QDoc behaves in the same way as it does when processing the &lt;a href=&quot;22-qdoc-configuration-generalvariables#headerdirs&quot;&gt;&lt;code&gt;headerdirs&lt;/code&gt;&lt;/a&gt; variable. For more information, see the &lt;a href=&quot;22-qdoc-configuration-generalvariables#headerdirs&quot;&gt;&lt;code&gt;headerdirs&lt;/code&gt;&lt;/a&gt; variable.</source>
          <target state="translated">在处理 &lt;code&gt;headers&lt;/code&gt; 变量时，QDoc的行为与处理&lt;a href=&quot;22-qdoc-configuration-generalvariables#headerdirs&quot;&gt; &lt;code&gt;headerdirs&lt;/code&gt; &lt;/a&gt;变量时的行为相同。有关更多信息，请参见&lt;a href=&quot;22-qdoc-configuration-generalvariables#headerdirs&quot;&gt; &lt;code&gt;headerdirs&lt;/code&gt; &lt;/a&gt;变量。</target>
        </trans-unit>
        <trans-unit id="8485caf25338b1f76aa184669dce3005f004482c" translate="yes" xml:space="preserve">
          <source>When processing the &lt;code&gt;images&lt;/code&gt; variable, QDoc behaves in the same way as it does when processing the &lt;a href=&quot;#imagedirs&quot;&gt;&lt;code&gt;imagedirs&lt;/code&gt;&lt;/a&gt; variable. For more information, see the &lt;a href=&quot;#imagedirs&quot;&gt;&lt;code&gt;imagedirs&lt;/code&gt;&lt;/a&gt; variable.</source>
          <target state="translated">处理 &lt;code&gt;images&lt;/code&gt; 变量时，QDoc的行为与处理&lt;a href=&quot;#imagedirs&quot;&gt; &lt;code&gt;imagedirs&lt;/code&gt; &lt;/a&gt;变量时的行为相同。有关更多信息，请参见&lt;a href=&quot;#imagedirs&quot;&gt; &lt;code&gt;imagedirs&lt;/code&gt; &lt;/a&gt;变量。</target>
        </trans-unit>
        <trans-unit id="83b7b87983b264f92514be824ef568bf74fc4531" translate="yes" xml:space="preserve">
          <source>When processing the &lt;code&gt;images&lt;/code&gt; variable, QDoc behaves in the same way as it does when processing the &lt;a href=&quot;22-qdoc-configuration-generalvariables#imagedirs&quot;&gt;&lt;code&gt;imagedirs&lt;/code&gt;&lt;/a&gt; variable. For more information, see the &lt;a href=&quot;22-qdoc-configuration-generalvariables#imagedirs&quot;&gt;&lt;code&gt;imagedirs&lt;/code&gt;&lt;/a&gt; variable.</source>
          <target state="translated">处理 &lt;code&gt;images&lt;/code&gt; 变量时，QDoc的行为与处理&lt;a href=&quot;22-qdoc-configuration-generalvariables#imagedirs&quot;&gt; &lt;code&gt;imagedirs&lt;/code&gt; &lt;/a&gt;变量时的行为相同。有关更多信息，请参见&lt;a href=&quot;22-qdoc-configuration-generalvariables#imagedirs&quot;&gt; &lt;code&gt;imagedirs&lt;/code&gt; &lt;/a&gt;变量。</target>
        </trans-unit>
        <trans-unit id="02ac4cb127779361e46edccdd9715135c772a6b4" translate="yes" xml:space="preserve">
          <source>When processing the &lt;code&gt;sources&lt;/code&gt; variable, QDoc behaves in the same way as it does when processing the &lt;a href=&quot;#sourcedirs-variable&quot;&gt;sourcedirs&lt;/a&gt; variable. For more information, see the &lt;a href=&quot;#sourcedirs-variable&quot;&gt;sourcedirs&lt;/a&gt; variable.</source>
          <target state="translated">处理 &lt;code&gt;sources&lt;/code&gt; 变量时，QDoc的行为与处理&lt;a href=&quot;#sourcedirs-variable&quot;&gt;sourcedirs&lt;/a&gt;变量时的行为相同。有关更多信息，请参见&lt;a href=&quot;#sourcedirs-variable&quot;&gt;sourcedirs&lt;/a&gt;变量。</target>
        </trans-unit>
        <trans-unit id="cad134d8c8f7cf34f150e5381504660ade1079a5" translate="yes" xml:space="preserve">
          <source>When processing the &lt;code&gt;sources&lt;/code&gt; variable, QDoc behaves in the same way as it does when processing the &lt;a href=&quot;22-qdoc-configuration-generalvariables#sourcedirs-variable&quot;&gt;sourcedirs&lt;/a&gt; variable. For more information, see the &lt;a href=&quot;22-qdoc-configuration-generalvariables#sourcedirs-variable&quot;&gt;sourcedirs&lt;/a&gt; variable.</source>
          <target state="translated">处理 &lt;code&gt;sources&lt;/code&gt; 变量时，QDoc的行为与处理&lt;a href=&quot;22-qdoc-configuration-generalvariables#sourcedirs-variable&quot;&gt;sourcedirs&lt;/a&gt;变量时的行为相同。有关更多信息，请参见&lt;a href=&quot;22-qdoc-configuration-generalvariables#sourcedirs-variable&quot;&gt;sourcedirs&lt;/a&gt;变量。</target>
        </trans-unit>
        <trans-unit id="d2f6258fc95387a5c4367b7340551e8c1e093ed8" translate="yes" xml:space="preserve">
          <source>When processing the header files specified in the &lt;a href=&quot;#headerdirs&quot;&gt;&lt;code&gt;headerdirs&lt;/code&gt;&lt;/a&gt; variable, QDoc will only read the files with the fileextensions specified in the &lt;code&gt;headers.fileextensions&lt;/code&gt; variable. In this way QDoc avoids spending time reading irrelevant files.</source>
          <target state="translated">处理&lt;a href=&quot;#headerdirs&quot;&gt; &lt;code&gt;headerdirs&lt;/code&gt; &lt;/a&gt;变量中指定的头文件时，QDoc仅读取具有 &lt;code&gt;headers.fileextensions&lt;/code&gt; 变量中指定的文件扩展名的文件。这样，QDoc可以避免花费时间阅读不相关的文件。</target>
        </trans-unit>
        <trans-unit id="e6e737bd0bca30837e70dbf0ba50e38a69eda1ae" translate="yes" xml:space="preserve">
          <source>When processing the header files specified in the &lt;a href=&quot;22-qdoc-configuration-generalvariables#headerdirs&quot;&gt;&lt;code&gt;headerdirs&lt;/code&gt;&lt;/a&gt; variable, QDoc will only read the files with the fileextensions specified in the &lt;code&gt;headers.fileextensions&lt;/code&gt; variable. In this way QDoc avoids spending time reading irrelevant files.</source>
          <target state="translated">在处理&lt;a href=&quot;22-qdoc-configuration-generalvariables#headerdirs&quot;&gt; &lt;code&gt;headerdirs&lt;/code&gt; &lt;/a&gt;变量中指定的头文件时，QDoc仅读取具有 &lt;code&gt;headers.fileextensions&lt;/code&gt; 变量中指定的文件扩展名的文件。这样，QDoc可以避免花费时间阅读不相关的文件。</target>
        </trans-unit>
        <trans-unit id="4ed979007a1c43ad6e1c65933f5ff78d1bf33f42" translate="yes" xml:space="preserve">
          <source>When processing the source files specified in the &lt;a href=&quot;#sourcedirs&quot;&gt;&lt;code&gt;sourcedirs&lt;/code&gt;&lt;/a&gt; variable, QDoc will only read the files with the fileextensions specified in the &lt;code&gt;sources.fileextensions&lt;/code&gt; variable. In this way QDoc avoid spending time reading irrelevant files.</source>
          <target state="translated">在处理&lt;a href=&quot;#sourcedirs&quot;&gt; &lt;code&gt;sourcedirs&lt;/code&gt; &lt;/a&gt;变量中指定的源文件时，QDoc仅读取具有 &lt;code&gt;sources.fileextensions&lt;/code&gt; 变量中指定的文件扩展名的文件。这样，QDoc可以避免花时间阅读不相关的文件。</target>
        </trans-unit>
        <trans-unit id="cfdcd3052995a6aaff22f71ef5141edb96daddb2" translate="yes" xml:space="preserve">
          <source>When processing the source files specified in the &lt;a href=&quot;22-qdoc-configuration-generalvariables#sourcedirs&quot;&gt;&lt;code&gt;sourcedirs&lt;/code&gt;&lt;/a&gt; variable, QDoc will only read the files with the fileextensions specified in the &lt;code&gt;sources.fileextensions&lt;/code&gt; variable. In this way QDoc avoid spending time reading irrelevant files.</source>
          <target state="translated">在处理&lt;a href=&quot;22-qdoc-configuration-generalvariables#sourcedirs&quot;&gt; &lt;code&gt;sourcedirs&lt;/code&gt; &lt;/a&gt;变量中指定的源文件时，QDoc仅读取具有 &lt;code&gt;sources.fileextensions&lt;/code&gt; 变量中指定的文件扩展名的文件。这样，QDoc可以避免花时间阅读不相关的文件。</target>
        </trans-unit>
        <trans-unit id="f3b3725626f2e2c1e184c3a3386769f3ccdb3009" translate="yes" xml:space="preserve">
          <source>When properties are defined on a &lt;a href=&quot;qt3dcore-qnode&quot;&gt;QNode&lt;/a&gt; subclass, their NOTIFY signal will automatically generate notifications that the Qt3D backend aspects will receive.</source>
          <target state="translated">在&lt;a href=&quot;qt3dcore-qnode&quot;&gt;QNode&lt;/a&gt;子类上定义属性后，其NOTIFY信号将自动生成Qt3D后端方面将接收的通知。</target>
        </trans-unit>
        <trans-unit id="c17f593088b99a91dc585e42d8e3fdd068f8c76c" translate="yes" xml:space="preserve">
          <source>When properties are defined on a QNode subclass, their NOTIFY signal will automatically generate notifications that the Qt3D backend aspects will receive.</source>
          <target state="translated">当属性定义在QNode子类上时,它们的NOTIFY信号将自动生成Qt3D后台方面的通知。</target>
        </trans-unit>
        <trans-unit id="22650f203b3bc55d65cd8bcc3c197b3e1ae94f80" translate="yes" xml:space="preserve">
          <source>When protecting for a short-term operation, it is acceptable to call &lt;a href=&quot;qlockfile#lock&quot;&gt;lock&lt;/a&gt;() and wait until any running operation finishes. When protecting a resource over a long time, however, the application should always call &lt;a href=&quot;qlockfile#setStaleLockTime&quot;&gt;setStaleLockTime&lt;/a&gt;(0) and then &lt;a href=&quot;qlockfile#tryLock&quot;&gt;tryLock&lt;/a&gt;() with a short timeout, in order to warn the user that the resource is locked.</source>
          <target state="translated">保护短期操作时，可以调用&lt;a href=&quot;qlockfile#lock&quot;&gt;lock&lt;/a&gt;（）并等待直到任何正在运行的操作完成为止。但是，在长时间保护资源时，应用程序应始终调用&lt;a href=&quot;qlockfile#setStaleLockTime&quot;&gt;setStaleLockTime&lt;/a&gt;（0），然后在较短的超时时间内调用&lt;a href=&quot;qlockfile#tryLock&quot;&gt;tryLock&lt;/a&gt;（），以警告用户资源已锁定。</target>
        </trans-unit>
        <trans-unit id="a64c630f83dc14fe3268c28b76ebc5e8374c55e6" translate="yes" xml:space="preserve">
          <source>When providing your own attributes, it may make sense to name your attribute using helpers such as &lt;a href=&quot;qt3dcore-qattribute#defaultPositionAttributeName&quot;&gt;QAttribute::defaultPositionAttributeName&lt;/a&gt;() as that will ensure your geometry will be compatible with picking and the various materials provided in the &lt;a href=&quot;https://doc.qt.io/qt-6.0/qt3dextras-module.html&quot;&gt;Qt3DExtras&lt;/a&gt; module.</source>
          <target state="translated">提供自己的属性时，使用诸如&lt;a href=&quot;qt3dcore-qattribute#defaultPositionAttributeName&quot;&gt;QAttribute :: defaultPositionAttributeName&lt;/a&gt;（）之类的助手来命名属性可能是有意义的，因为这将确保您的几何形状与拾取以及&lt;a href=&quot;https://doc.qt.io/qt-6.0/qt3dextras-module.html&quot;&gt;Qt3DExtras&lt;/a&gt;模块中提供的各种材质兼容。</target>
        </trans-unit>
        <trans-unit id="12b6bb01343a6f269ac19359f22a3d9b836dd641" translate="yes" xml:space="preserve">
          <source>When providing your own attributes, it may make sense to name your attribute using helpers such as &lt;a href=&quot;qt3drender-qattribute#defaultPositionAttributeName&quot;&gt;QAttribute::defaultPositionAttributeName&lt;/a&gt;() as that will ensure your geometry will be compatible with picking and the various materials provided in the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qt3dextras-module.html&quot;&gt;Qt3DExtras&lt;/a&gt; module.</source>
          <target state="translated">提供自己的属性时，使用诸如&lt;a href=&quot;qt3drender-qattribute#defaultPositionAttributeName&quot;&gt;QAttribute :: defaultPositionAttributeName&lt;/a&gt;（）之类的助手来命名属性可能是有意义的，因为这将确保您的几何形状与拾取以及&lt;a href=&quot;https://doc.qt.io/qt-5.13/qt3dextras-module.html&quot;&gt;Qt3DExtras&lt;/a&gt;模块中提供的各种材质兼容。</target>
        </trans-unit>
        <trans-unit id="1c5031580380ec45abd2184625b064726bd7956e" translate="yes" xml:space="preserve">
          <source>When providing your own attributes, it may make sense to name your attribute using helpers such as &lt;a href=&quot;qt3drender-qattribute#defaultPositionAttributeName&quot;&gt;QAttribute::defaultPositionAttributeName&lt;/a&gt;() as that will ensure your geometry will be compatible with picking and the various materials provided in the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qt3dextras-module.html&quot;&gt;Qt3DExtras&lt;/a&gt; module.</source>
          <target state="translated">提供自己的属性时，使用诸如&lt;a href=&quot;qt3drender-qattribute#defaultPositionAttributeName&quot;&gt;QAttribute :: defaultPositionAttributeName&lt;/a&gt;（）之类的助手来命名属性可能是有意义的，因为这将确保您的几何形状与拾取以及&lt;a href=&quot;https://doc.qt.io/qt-5.15/qt3dextras-module.html&quot;&gt;Qt3DExtras&lt;/a&gt;模块中提供的各种材质兼容。</target>
        </trans-unit>
        <trans-unit id="83204666112336ac2cd938437ecd85c2c9e42c43" translate="yes" xml:space="preserve">
          <source>When providing your own attributes, it may make sense to name your attribute using helpers such as QAttribute::defaultPositionAttributeName() as that will ensure your geometry will be compatible with picking and the various materials provided in the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qt3dextras-module.html&quot;&gt;Qt3DExtras&lt;/a&gt; module.</source>
          <target state="translated">提供自己的属性时，使用诸如QAttribute :: defaultPositionAttributeName（）之类的助手来命名属性可能是有意义的，因为这将确保您的几何形状与拾取以及&lt;a href=&quot;https://doc.qt.io/qt-5.13/qt3dextras-module.html&quot;&gt;Qt3DExtras&lt;/a&gt;模块中提供的各种材质兼容。</target>
        </trans-unit>
        <trans-unit id="7f0b771b8b6122f451fd39a4eec632c95f8abf9c" translate="yes" xml:space="preserve">
          <source>When providing your own attributes, it may make sense to name your attribute using helpers such as QAttribute::defaultPositionAttributeName() as that will ensure your geometry will be compatible with picking and the various materials provided in the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qt3dextras-module.html&quot;&gt;Qt3DExtras&lt;/a&gt; module.</source>
          <target state="translated">提供自己的属性时，使用诸如QAttribute :: defaultPositionAttributeName（）之类的助手来命名属性可能是有意义的，因为这将确保您的几何形状与拾取以及&lt;a href=&quot;https://doc.qt.io/qt-5.15/qt3dextras-module.html&quot;&gt;Qt3DExtras&lt;/a&gt;模块中提供的各种材质兼容。</target>
        </trans-unit>
        <trans-unit id="4d403f2b317d8a25ea1daa5531b9d0846e0f0138" translate="yes" xml:space="preserve">
          <source>When providing your own attributes, it may make sense to name your attribute using helpers such as QAttribute::defaultPositionAttributeName() as that will ensure your geometry will be compatible with picking and the various materials provided in the &lt;a href=&quot;https://doc.qt.io/qt-6.0/qt3dextras-module.html&quot;&gt;Qt3DExtras&lt;/a&gt; module.</source>
          <target state="translated">提供自己的属性时，使用诸如QAttribute :: defaultPositionAttributeName（）之类的助手来命名属性可能是有意义的，因为这将确保您的几何形状与拾取以及&lt;a href=&quot;https://doc.qt.io/qt-6.0/qt3dextras-module.html&quot;&gt;Qt3DExtras&lt;/a&gt;模块中提供的各种材质兼容。</target>
        </trans-unit>
        <trans-unit id="7be4e2868f53c5c712c37033765565589dd9a696" translate="yes" xml:space="preserve">
          <source>When qmake is run, an &lt;code&gt;Info.plist&lt;/code&gt; file is generated with appropriate default values.</source>
          <target state="translated">运行qmake时，将使用适当的默认值生成一个 &lt;code&gt;Info.plist&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="deaab1579f95ca0cb54a7c45e2f6602842f9bf55" translate="yes" xml:space="preserve">
          <source>When qmake processes the project file, it will generate a Makefile rule to allow the project to be built in both modes. This can be invoked in the following way:</source>
          <target state="translated">当qmake处理项目文件时,它会生成一个Makefile规则,允许项目在两种模式下构建。可以通过以下方式调用该规则。</target>
        </trans-unit>
        <trans-unit id="433bf4e26978749cad77ae5bdc38533c0acb441e" translate="yes" xml:space="preserve">
          <source>When queries are generated to be executed on the database only those fields for which &lt;a href=&quot;qsqlrecord#isGenerated&quot;&gt;isGenerated&lt;/a&gt;() is true are included in the generated SQL.</source>
          <target state="translated">当生成查询以在数据库上执行时，只有那些&lt;a href=&quot;qsqlrecord#isGenerated&quot;&gt;isGenerated&lt;/a&gt;（）为true的字段才包含在生成的SQL中。</target>
        </trans-unit>
        <trans-unit id="9333afa0fced835478399e93823c406d22de675b" translate="yes" xml:space="preserve">
          <source>When quoting is disabled, these types are printed without quotation characters and without escaping of non-printable characters.</source>
          <target state="translated">当禁用引号时,这些类型的打印没有引号,也没有不可打印字符的转义。</target>
        </trans-unit>
        <trans-unit id="2e3a5904501c88a29777d21a5ea08bedba058dd9" translate="yes" xml:space="preserve">
          <source>When reading from QByteArray(), the &lt;a href=&quot;qcborstreamreader#addData&quot;&gt;addData&lt;/a&gt;() function automatically calls this function. Calling it when the reading had not failed is a no-op.</source>
          <target state="translated">从QByteArray（）读取时，&lt;a href=&quot;qcborstreamreader#addData&quot;&gt;addData&lt;/a&gt;（）函数自动调用此函数。当阅读没有失败时调用它是没有操作的。</target>
        </trans-unit>
        <trans-unit id="2961583e309be088817f7af5160b0e7c63f99641" translate="yes" xml:space="preserve">
          <source>When reading, the end-of-line terminators are translated to '\n'. When writing, the end-of-line terminators are translated to the local encoding, for example '\r\n' for Win32.</source>
          <target state="translated">当读的时候,行结束符被翻译成'\n'。写入时,行结束符被翻译成本地编码,例如Win32的'\r\n'。</target>
        </trans-unit>
        <trans-unit id="0178fb06130fa3ace5f0116314a30ba2905b8155" translate="yes" xml:space="preserve">
          <source>When receiving an input method event, the text widget has to performs the following steps:</source>
          <target state="translated">当接收到输入法事件时,文本部件必须执行以下步骤。</target>
        </trans-unit>
        <trans-unit id="bc54aed1354ce805c861b084074c4b15f2941b02" translate="yes" xml:space="preserve">
          <source>When registered with QML in this way, they can be used as property types:</source>
          <target state="translated">当以这种方式向QML注册时,它们可以作为属性类型使用。</target>
        </trans-unit>
        <trans-unit id="6de85969ab467e39090e43789eb7746771150552" translate="yes" xml:space="preserve">
          <source>When registered with the QML engine in this way, they can be used as property types:</source>
          <target state="translated">当以这种方式在QML引擎中注册时,它们可以作为属性类型使用。</target>
        </trans-unit>
        <trans-unit id="658aa3d331e786b5cf19cdc003900fc565a01ebd" translate="yes" xml:space="preserve">
          <source>When reimplementing &lt;a href=&quot;qabstractitemmodel#insertColumns&quot;&gt;insertColumns&lt;/a&gt;() in a subclass, you must call this function</source>
          <target state="translated">在子类中重新实现&lt;a href=&quot;qabstractitemmodel#insertColumns&quot;&gt;insertColumns&lt;/a&gt;（）时，必须调用此函数</target>
        </trans-unit>
        <trans-unit id="4c93d0d6698e3e63d88035f6f5efca5fb6102f1c" translate="yes" xml:space="preserve">
          <source>When reimplementing &lt;a href=&quot;qabstractitemmodel#insertRows&quot;&gt;insertRows&lt;/a&gt;() in a subclass, you must call this function</source>
          <target state="translated">在子类中重新实现&lt;a href=&quot;qabstractitemmodel#insertRows&quot;&gt;insertRows&lt;/a&gt;（）时，必须调用此函数</target>
        </trans-unit>
        <trans-unit id="85d1f3aba6b52c7b19fa00f7d1afc309113e34b8" translate="yes" xml:space="preserve">
          <source>When reimplementing &lt;a href=&quot;qabstractitemmodel#removeColumns&quot;&gt;removeColumns&lt;/a&gt;() in a subclass, you must call this function</source>
          <target state="translated">在子类中重新实现&lt;a href=&quot;qabstractitemmodel#removeColumns&quot;&gt;removeColumns&lt;/a&gt;（）时，必须调用此函数</target>
        </trans-unit>
        <trans-unit id="f37a182e5a69ec7aec2bf70e9e8e6c7db8177d59" translate="yes" xml:space="preserve">
          <source>When reimplementing &lt;a href=&quot;qabstractitemmodel#removeRows&quot;&gt;removeRows&lt;/a&gt;() in a subclass, you must call this function</source>
          <target state="translated">在子类中重新实现&lt;a href=&quot;qabstractitemmodel#removeRows&quot;&gt;removeRows&lt;/a&gt;（）时，必须调用此函数</target>
        </trans-unit>
        <trans-unit id="9b0330becdc29ff2c73cb6957330004540cba4dd" translate="yes" xml:space="preserve">
          <source>When reimplementing &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; functions that take a &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt; parameter, you often need to cast the &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt; to a subclass (e.g., &lt;a href=&quot;qstyleoptionfocusrect&quot;&gt;QStyleOptionFocusRect&lt;/a&gt;). For safety, you can use &lt;a href=&quot;qstyleoption#qstyleoption_cast&quot;&gt;qstyleoption_cast&lt;/a&gt;() to ensure that the pointer type is correct. If the object isn't of the right type, &lt;a href=&quot;qstyleoption#qstyleoption_cast&quot;&gt;qstyleoption_cast&lt;/a&gt;() returns &lt;code&gt;nullptr&lt;/code&gt;. For example:</source>
          <target state="translated">当重新实现带有&lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt;参数的&lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt;函数时，通常需要将&lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption强制&lt;/a&gt;转换为子类（例如&lt;a href=&quot;qstyleoptionfocusrect&quot;&gt;QStyleOptionFocusRect&lt;/a&gt;）。为了安全起见，可以使用&lt;a href=&quot;qstyleoption#qstyleoption_cast&quot;&gt;qstyleoption_cast&lt;/a&gt;（）来确保指针类型正确。如果对象的类型不正确，则&lt;a href=&quot;qstyleoption#qstyleoption_cast&quot;&gt;qstyleoption_cast&lt;/a&gt;（）返回 &lt;code&gt;nullptr&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="9dfc851c4dac23e39db3f903a4238131999a47c4" translate="yes" xml:space="preserve">
          <source>When reimplementing &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; functions that take a &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt; parameter, you often need to cast the &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt; to a subclass. For safety, you can use &lt;a href=&quot;qstyleoption#qstyleoption_cast&quot;&gt;qstyleoption_cast&lt;/a&gt;() to ensure that the pointer type is correct. For example:</source>
          <target state="translated">重新实现带有&lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt;参数的&lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt;函数时，通常需要将&lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption强制&lt;/a&gt;转换为子类。为了安全起见，可以使用&lt;a href=&quot;qstyleoption#qstyleoption_cast&quot;&gt;qstyleoption_cast&lt;/a&gt;（）来确保指针类型正确。例如：</target>
        </trans-unit>
        <trans-unit id="7c3a36cf890d4e609cd3054eba937187efb84074" translate="yes" xml:space="preserve">
          <source>When reimplementing &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; functions that take a QStyleOption parameter, you often need to cast the QStyleOption to a subclass. For safety, you can use &lt;a href=&quot;qstyleoption#qstyleoption_cast&quot;&gt;qstyleoption_cast&lt;/a&gt;() to ensure that the pointer type is correct. For example:</source>
          <target state="translated">重新实现带有QStyleOption参数的&lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt;函数时，通常需要将QStyleOption强制转换为子类。为了安全起见，可以使用&lt;a href=&quot;qstyleoption#qstyleoption_cast&quot;&gt;qstyleoption_cast&lt;/a&gt;（）来确保指针类型正确。例如：</target>
        </trans-unit>
        <trans-unit id="ec235ac06dbbca492dcbe4cfde2eff2f73ed2863" translate="yes" xml:space="preserve">
          <source>When reimplementing &lt;a href=&quot;qstyleditemdelegate#paint&quot;&gt;paint&lt;/a&gt;(), one would typically handle the datatypes one would like to draw and use the superclass implementation for other types.</source>
          <target state="translated">重新实现&lt;a href=&quot;qstyleditemdelegate#paint&quot;&gt;paint&lt;/a&gt;（）时，通常会处理一个人希望绘制的数据类型，并将超类实现用于其他类型。</target>
        </trans-unit>
        <trans-unit id="fb3e42362330e9b7392e5e0ebae5fafed9a1a17a" translate="yes" xml:space="preserve">
          <source>When reimplementing a subclass, this method simplifies moving entities in your model. This method is responsible for moving persistent indexes in the model, which you would otherwise be required to do yourself. Using beginMoveColumns and &lt;a href=&quot;qabstractitemmodel#endMoveColumns&quot;&gt;endMoveColumns&lt;/a&gt; is an alternative to emitting &lt;a href=&quot;qabstractitemmodel#layoutAboutToBeChanged&quot;&gt;layoutAboutToBeChanged&lt;/a&gt; and &lt;a href=&quot;qabstractitemmodel#layoutChanged&quot;&gt;layoutChanged&lt;/a&gt; directly along with &lt;a href=&quot;qabstractitemmodel#changePersistentIndex&quot;&gt;changePersistentIndex&lt;/a&gt;.</source>
          <target state="translated">重新实现子类时，此方法可简化模型中的移动实体。此方法负责在模型中移动持久索引，否则您需要自己进行操作。使用beginMoveColumns和&lt;a href=&quot;qabstractitemmodel#endMoveColumns&quot;&gt;endMoveColumns&lt;/a&gt;是发射一个替代&lt;a href=&quot;qabstractitemmodel#layoutAboutToBeChanged&quot;&gt;layoutAboutToBeChanged&lt;/a&gt;和&lt;a href=&quot;qabstractitemmodel#layoutChanged&quot;&gt;layoutChanged&lt;/a&gt;直接沿&lt;a href=&quot;qabstractitemmodel#changePersistentIndex&quot;&gt;changePersistentIndex&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="37d54556abfd5846d3b883b6100f1fa44ae8b968" translate="yes" xml:space="preserve">
          <source>When reimplementing a subclass, this method simplifies moving entities in your model. This method is responsible for moving persistent indexes in the model, which you would otherwise be required to do yourself. Using beginMoveRows and &lt;a href=&quot;qabstractitemmodel#endMoveRows&quot;&gt;endMoveRows&lt;/a&gt; is an alternative to emitting &lt;a href=&quot;qabstractitemmodel#layoutAboutToBeChanged&quot;&gt;layoutAboutToBeChanged&lt;/a&gt; and &lt;a href=&quot;qabstractitemmodel#layoutChanged&quot;&gt;layoutChanged&lt;/a&gt; directly along with &lt;a href=&quot;qabstractitemmodel#changePersistentIndex&quot;&gt;changePersistentIndex&lt;/a&gt;.</source>
          <target state="translated">重新实现子类时，此方法可简化模型中的移动实体。此方法负责在模型中移动持久索引，否则您需要自己进行操作。使用beginMoveRows和&lt;a href=&quot;qabstractitemmodel#endMoveRows&quot;&gt;endMoveRows&lt;/a&gt;是发射一个替代&lt;a href=&quot;qabstractitemmodel#layoutAboutToBeChanged&quot;&gt;layoutAboutToBeChanged&lt;/a&gt;和&lt;a href=&quot;qabstractitemmodel#layoutChanged&quot;&gt;layoutChanged&lt;/a&gt;直接沿&lt;a href=&quot;qabstractitemmodel#changePersistentIndex&quot;&gt;changePersistentIndex&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ca95dc0c0eb787c2eeed20255a0cb245f62492af" translate="yes" xml:space="preserve">
          <source>When reimplementing canRead(), make sure that the I/O device (&lt;a href=&quot;qimageiohandler#device&quot;&gt;device&lt;/a&gt;()) is left in its original state (e.g., by using peek() rather than &lt;a href=&quot;qimageiohandler#read&quot;&gt;read&lt;/a&gt;()).</source>
          <target state="translated">重新实现canRead（）时，请确保I / O设备（&lt;a href=&quot;qimageiohandler#device&quot;&gt;device&lt;/a&gt;（））保持其原始状态（例如，通过使用peek（）而不是&lt;a href=&quot;qimageiohandler#read&quot;&gt;read&lt;/a&gt;（））。</target>
        </trans-unit>
        <trans-unit id="028d93193544c8ed47ad98dfeadb939c5667b03b" translate="yes" xml:space="preserve">
          <source>When reimplementing paint in a subclass. Use the &lt;a href=&quot;qstyleditemdelegate#initStyleOption&quot;&gt;initStyleOption&lt;/a&gt;() to set up the</source>
          <target state="translated">在子类中重新实现绘画时。使用&lt;a href=&quot;qstyleditemdelegate#initStyleOption&quot;&gt;initStyleOption&lt;/a&gt;（）设定</target>
        </trans-unit>
        <trans-unit id="df7f5f683e515c4160cc8d6065b4b4913422655c" translate="yes" xml:space="preserve">
          <source>When reimplementing the &lt;a href=&quot;qabstractitemmodel#setData&quot;&gt;setData&lt;/a&gt;() function, this signal must be emitted explicitly.</source>
          <target state="translated">重新实现&lt;a href=&quot;qabstractitemmodel#setData&quot;&gt;setData&lt;/a&gt;（）函数时，必须显式发出此信号。</target>
        </trans-unit>
        <trans-unit id="6f516d38e016de108e31954fe638b31e63f64384" translate="yes" xml:space="preserve">
          <source>When reimplementing the &lt;a href=&quot;qabstractitemmodel#setHeaderData&quot;&gt;setHeaderData&lt;/a&gt;() function, this signal must be emitted explicitly.</source>
          <target state="translated">重新实现&lt;a href=&quot;qabstractitemmodel#setHeaderData&quot;&gt;setHeaderData&lt;/a&gt;（）函数时，必须显式发出此信号。</target>
        </trans-unit>
        <trans-unit id="8bb42c54f45079c9c25f1595264e446c8f5dae51" translate="yes" xml:space="preserve">
          <source>When reimplementing the &lt;a href=&quot;qeventtransition#eventTest&quot;&gt;eventTest&lt;/a&gt;() function, you should first call the base implementation to verify that the event is a &lt;a href=&quot;qstatemachine-wrappedevent&quot;&gt;QStateMachine::WrappedEvent&lt;/a&gt; for the proper object and event type. You may then cast the event to a &lt;a href=&quot;qstatemachine-wrappedevent&quot;&gt;QStateMachine::WrappedEvent&lt;/a&gt; and get the original event by calling &lt;a href=&quot;qstatemachine-wrappedevent#event&quot;&gt;QStateMachine::WrappedEvent::event&lt;/a&gt;(), and perform additional checks on that object.</source>
          <target state="translated">重新实现&lt;a href=&quot;qeventtransition#eventTest&quot;&gt;eventTest&lt;/a&gt;（）函数时，应首先调用基本实现，以验证该事件是否为正确的对象和事件类型的&lt;a href=&quot;qstatemachine-wrappedevent&quot;&gt;QStateMachine :: WrappedEvent&lt;/a&gt;。然后，您可以将事件&lt;a href=&quot;qstatemachine-wrappedevent&quot;&gt;强制&lt;/a&gt;转换为QStateMachine :: WrappedEvent并通过调用&lt;a href=&quot;qstatemachine-wrappedevent#event&quot;&gt;QStateMachine :: WrappedEvent :: event&lt;/a&gt;（）获取原始事件，并对该对象执行其他检查。</target>
        </trans-unit>
        <trans-unit id="b124ac10b911b199139a9b1396e9a53e131374c7" translate="yes" xml:space="preserve">
          <source>When reimplementing this class, take care to return at least one element.</source>
          <target state="translated">在重新实现这个类的时候,注意至少要返回一个元素。</target>
        </trans-unit>
        <trans-unit id="55e2b93bd22d4647e3de872d6613c4f4629fae05" translate="yes" xml:space="preserve">
          <source>When reimplementing this function in a subclass, be careful to avoid calling &lt;a href=&quot;qmodelindex&quot;&gt;QModelIndex&lt;/a&gt; member functions, such as &lt;a href=&quot;qmodelindex#parent&quot;&gt;QModelIndex::parent&lt;/a&gt;(), since indexes belonging to your model will simply call your implementation, leading to infinite recursion.</source>
          <target state="translated">在子类中重新实现此函数时，请小心避免调用&lt;a href=&quot;qmodelindex&quot;&gt;QModelIndex&lt;/a&gt;成员函数，例如&lt;a href=&quot;qmodelindex#parent&quot;&gt;QModelIndex :: parent&lt;/a&gt;（），因为属于您模型的索引会简单地调用您的实现，从而导致无限递归。</target>
        </trans-unit>
        <trans-unit id="70e5caa7bbddd6d74b4efb7d8a7005f9825d497b" translate="yes" xml:space="preserve">
          <source>When reimplementing this function in a subclass, call &lt;a href=&quot;qabstractitemmodel#createIndex&quot;&gt;createIndex&lt;/a&gt;() to generate model indexes that other components can use to refer to items in your model.</source>
          <target state="translated">在子类中重新实现此函数时，调用&lt;a href=&quot;qabstractitemmodel#createIndex&quot;&gt;createIndex&lt;/a&gt;（）生成模型索引，其他组件可以使用该模型索引来引用模型中的项目。</target>
        </trans-unit>
        <trans-unit id="ba7f9d147f366305cacefe9a55e635566170bc6d" translate="yes" xml:space="preserve">
          <source>When reimplementing this function in a subclass, you should update the area held by the option's &lt;a href=&quot;qstyleoption#rect-var&quot;&gt;rect&lt;/a&gt; variable, using the option's &lt;a href=&quot;qstyleoption#state-var&quot;&gt;state&lt;/a&gt; variable to determine the state of the item to be displayed, and adjust the way it is painted accordingly.</source>
          <target state="translated">在子类中重新实现此功能时，应更新选项的&lt;a href=&quot;qstyleoption#rect-var&quot;&gt;rect&lt;/a&gt;变量所占的区域，使用选项的&lt;a href=&quot;qstyleoption#state-var&quot;&gt;状态&lt;/a&gt;变量来确定要显示的项目的状态，并相应地调整其绘制方式。</target>
        </trans-unit>
        <trans-unit id="4e2d2f89b79fefee58d5613beec7b9bd5dde6fb5" translate="yes" xml:space="preserve">
          <source>When reimplementing this function it is important that this function reads all the required data before returning. This is required in order for &lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt; to be able to operate on the class. &lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt; assumes all the requested information was read and therefore does not retry reading if there was a problem.</source>
          <target state="translated">重新实现此功能时，重要的是该功能在返回之前读取所有必需的数据。为了使&lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt;能够在类上进行操作，这是必需的。&lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt;假定已读取所有请求的信息，因此如果出现问题，则不会重试读取。</target>
        </trans-unit>
        <trans-unit id="e93d19bd100346fac19905c7b4a51959378ca55b" translate="yes" xml:space="preserve">
          <source>When reimplementing this function it is important that this function writes all the data available before returning. This is required in order for &lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt; to be able to operate on the class. &lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt; assumes all the information was written and therefore does not retry writing if there was a problem.</source>
          <target state="translated">重新实现此功能时，重要的是该函数在返回之前写入所有可用数据。为了使&lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt;能够在类上进行操作，这是必需的。&lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt;假定所有信息均已写入，因此如果出现问题，则不会重试写入。</target>
        </trans-unit>
        <trans-unit id="dbe06314296a3392519e885c147e88b10b0594de" translate="yes" xml:space="preserve">
          <source>When reimplementing this function, note that in case of text items, &lt;a href=&quot;qitemdelegate&quot;&gt;QItemDelegate&lt;/a&gt; adds a margin (i.e. 2 * &lt;a href=&quot;qstyle#PixelMetric-enum&quot;&gt;QStyle::PM_FocusFrameHMargin&lt;/a&gt;) to the length of the text.</source>
          <target state="translated">重新实现此功能时，请注意，在使用文本项的情况下，&lt;a href=&quot;qitemdelegate&quot;&gt;QItemDelegate&lt;/a&gt;在文本长度上添加一个空白（即2 * &lt;a href=&quot;qstyle#PixelMetric-enum&quot;&gt;QStyle :: PM_FocusFrameHMargin&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="197ccf9da55fd735f9643d4ab74a6bddeec9dfb0" translate="yes" xml:space="preserve">
          <source>When reimplementing this function, the &lt;a href=&quot;qabstractitemmodel#headerDataChanged&quot;&gt;headerDataChanged&lt;/a&gt;() signal must be emitted explicitly.</source>
          <target state="translated">重新实现此功能时，必须显式发出&lt;a href=&quot;qabstractitemmodel#headerDataChanged&quot;&gt;headerDataChanged&lt;/a&gt;（）信号。</target>
        </trans-unit>
        <trans-unit id="89a145bd42509fd307493a0a0013f21ce6e0557c" translate="yes" xml:space="preserve">
          <source>When relative paths are specified, qmake will mangle them into a form understood by the dynamic linker to be relative to the location of the referring executable or library. This is supported only by some platforms (currently Linux and Darwin-based ones) and is detectable by checking whether &lt;a href=&quot;#qmake-rel-rpath-base&quot;&gt;QMAKE_REL_RPATH_BASE&lt;/a&gt; is set.</source>
          <target state="translated">指定相对路径后，qmake会将其转换为动态链接器可理解为相对于引用可执行文件或库的位置的形式。仅某些平台（当前为Linux和基于Darwin的平台）支持此功能，并且可以通过检查是否设置了&lt;a href=&quot;#qmake-rel-rpath-base&quot;&gt;QMAKE_REL_RPATH_BASE&lt;/a&gt;来检测到。</target>
        </trans-unit>
        <trans-unit id="c2230aceb836e5f2b704deb69243134974a878df" translate="yes" xml:space="preserve">
          <source>When relative paths are specified, qmake will mangle them into a form understood by the dynamic linker to be relative to the location of the referring executable or library. This is supported only by some platforms (currently Linux and Darwin-based ones) and is detectable by checking whether &lt;a href=&quot;qmake-variable-reference#qmake-rel-rpath-base&quot;&gt;QMAKE_REL_RPATH_BASE&lt;/a&gt; is set.</source>
          <target state="translated">指定相对路径后，qmake会将其转换为动态链接器可理解为相对于引用可执行文件或库的位置的形式。仅某些平台（当前为Linux和基于Darwin的平台）支持此功能，并且可以通过检查是否设置了&lt;a href=&quot;qmake-variable-reference#qmake-rel-rpath-base&quot;&gt;QMAKE_REL_RPATH_BASE&lt;/a&gt;来检测到。</target>
        </trans-unit>
        <trans-unit id="9719c3fc7ea7358a427a328cfee1c891b8f4d398" translate="yes" xml:space="preserve">
          <source>When rendering a 3D scene, there are many scenarios where there is a need to embed 2D elements into 3D. There are two different ways to integrate 2D content inside of 3D scenes, each of which has its own path to get to the screen.</source>
          <target state="translated">在渲染一个3D场景时,有很多场景需要将2D元素嵌入到3D中。有两种不同的方式可以将2D内容集成到3D场景内部,每种方式都有自己的路径到达屏幕。</target>
        </trans-unit>
        <trans-unit id="b737ba18762f9d815ad8cc904c2c8daeaec43e4b" translate="yes" xml:space="preserve">
          <source>When rendering graphics, the matrix defines the transformations but the actual transformation is performed by the drawing routines in &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;.</source>
          <target state="translated">渲染图形时，矩阵定义了转换，但是实际的转换由&lt;a href=&quot;qpainter&quot;&gt;QPainter中&lt;/a&gt;的绘制例程执行。</target>
        </trans-unit>
        <trans-unit id="376ba91e9e24af226abc158db0a7aa54457a58c9" translate="yes" xml:space="preserve">
          <source>When rendering with OpenGL, the &lt;a href=&quot;gui-changes-qt6#qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt; of this window will be bound when this function is called. The only exception is if the native OpenGL has been destroyed outside Qt's control, for instance through EGL_CONTEXT_LOST.</source>
          <target state="translated">使用OpenGL渲染时，调用此函数时将绑定此窗口的&lt;a href=&quot;gui-changes-qt6#qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt;。唯一的例外是原生OpenGL是否已被Qt所控制，例如通过EGL_CONTEXT_LOST销毁了。</target>
        </trans-unit>
        <trans-unit id="e5653d7216920813d6171f95584427875defe394" translate="yes" xml:space="preserve">
          <source>When rendering with a graphics API where the concept is not applicable,</source>
          <target state="translated">当使用概念不适用的图形API进行渲染时。</target>
        </trans-unit>
        <trans-unit id="7c5109171a737854a9ba5a71e30fd9bd78572ca4" translate="yes" xml:space="preserve">
          <source>When rendering with a pen with an even number of pixels, the pixels will be rendered symetrically around the mathematical defined points, while rendering with a pen with an odd number of pixels, the spare pixel will be rendered to the right and below the mathematical point as in the one pixel case. See the &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; diagrams below for concrete examples.</source>
          <target state="translated">使用像素数为偶数的笔进行渲染时，将在数学定义的点周围对称地渲染像素，而使用像素数为奇数的笔进行渲染时，备用像素将在数学点的右侧和下方渲染与一像素的情况一样。具体示例请参见下面的&lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt;图。</target>
        </trans-unit>
        <trans-unit id="f6bb9fd28f420249ac748ef0297e189cfdea3c23" translate="yes" xml:space="preserve">
          <source>When rendering with a two pixels wide pen the boundary line will be split in the middle by the mathematical rectangle. This will be the case whenever the pen is set to an even number of pixels, while rendering with a pen with an odd number of pixels, the spare pixel will be rendered to the right and below the mathematical rectangle as in the one pixel case.</source>
          <target state="translated">当用两个像素宽的笔渲染时,边界线将被数学矩形从中间分割开来。当笔的像素数为偶数时,就会出现这种情况,而当用奇数像素的笔渲染时,多余的像素会像在一个像素的情况下一样,被渲染到数学矩形的右边和下面。</target>
        </trans-unit>
        <trans-unit id="d7e0077b12f54b280554348b8d31ed612bede88e" translate="yes" xml:space="preserve">
          <source>When rendering, &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; protects the painter state (see &lt;a href=&quot;qpainter#save&quot;&gt;QPainter::save&lt;/a&gt;()) when rendering the background or foreground, and when rendering each item. This allows you to leave the painter in an altered state (i.e., you can call &lt;a href=&quot;qpainter#setPen&quot;&gt;QPainter::setPen&lt;/a&gt;() or &lt;a href=&quot;qpainter#setBrush&quot;&gt;QPainter::setBrush&lt;/a&gt;() without restoring the state after painting). However, if the items consistently do restore the state, you should enable this flag to prevent &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; from doing the same.</source>
          <target state="translated">渲染时，&lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt;在渲染背景或前景以及渲染每个项目时会保护画家状态（请参阅&lt;a href=&quot;qpainter#save&quot;&gt;QPainter :: save&lt;/a&gt;（））。这使您可以使画家处于改变的状态（即，您可以调用&lt;a href=&quot;qpainter#setPen&quot;&gt;QPainter :: setPen&lt;/a&gt;（）或&lt;a href=&quot;qpainter#setBrush&quot;&gt;QPainter :: setBrush&lt;/a&gt;（）而不用在绘制后恢复状态）。但是，如果各项一致地确实恢复了状态，则应启用此标志以防止&lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt;这样做。</target>
        </trans-unit>
        <trans-unit id="d51a24d95c26c19a346a37f3dd7e864ef01ea9d8" translate="yes" xml:space="preserve">
          <source>When rendering, Graphics View's scene coordinates correspond to &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;'s</source>
          <target state="translated">渲染时，Graphics View的场景坐标对应于&lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;的</target>
        </trans-unit>
        <trans-unit id="b351cd57358f6774989d1cb0e0f8f4b5f818e8c3" translate="yes" xml:space="preserve">
          <source>When requesting an index for a model item, we must provide some information about the item's parent. Outside the model, the only way to refer to an item is through a model index, so a parent model index must also be given:</source>
          <target state="translated">当请求一个模型项的索引时,我们必须提供该项的父项的一些信息。在模型之外,引用一个项目的唯一方法是通过模型索引,所以还必须提供一个父模型索引。</target>
        </trans-unit>
        <trans-unit id="e3462b37efc9ed9435b6be891fff238475c5b943" translate="yes" xml:space="preserve">
          <source>When resizeEvent() is called, the viewport already has its new geometry: Its new size is accessible through the &lt;a href=&quot;qresizeevent#size&quot;&gt;QResizeEvent::size&lt;/a&gt;() function, and the old size through &lt;a href=&quot;qresizeevent#oldSize&quot;&gt;QResizeEvent::oldSize&lt;/a&gt;().</source>
          <target state="translated">调用resizeEvent（）时，视口已经具有新的几何形状：可通过&lt;a href=&quot;qresizeevent#size&quot;&gt;QResizeEvent :: size&lt;/a&gt;（）函数访问其新大小，而可通过&lt;a href=&quot;qresizeevent#oldSize&quot;&gt;QResizeEvent :: oldSize&lt;/a&gt;（）访问其旧大小。</target>
        </trans-unit>
        <trans-unit id="459145d7e5e0a2dddcfe14e374a8a522472aa332" translate="yes" xml:space="preserve">
          <source>When returning from C++, the engine will interrupt the normal flow of execution and call the the next pre-registered exception handler with an error object that contains the given</source>
          <target state="translated">当从C++返回时,引擎将中断正常的执行流程,并调用下一个预先注册的异常处理程序,该异常处理程序的错误对象包含给定的</target>
        </trans-unit>
        <trans-unit id="90d305ada35629da8b28508d253830cb3271219a" translate="yes" xml:space="preserve">
          <source>When rubberband selection ends this signal will be emitted with null vales.</source>
          <target state="translated">当橡皮筋选择结束时,这个信号将发出空值。</target>
        </trans-unit>
        <trans-unit id="d7d3ba7b84a869b7ec4d6428c30a1e381f521d40" translate="yes" xml:space="preserve">
          <source>When run in a Norwegian locale, this code could for instance display &quot;Price is kr 6,00&quot; for a one-dollar product.</source>
          <target state="translated">当在挪威当地运行时,这段代码可以显示 &quot;价格为6,00克朗 &quot;的一美元产品。</target>
        </trans-unit>
        <trans-unit id="f4b4ea8160e44027a1643f73bd2b4fc24a630c0f" translate="yes" xml:space="preserve">
          <source>When running QDoc to generate HTML, the example above will have no effect on the generated output, but if you run QDoc to generate DITA XML, the example will generate the following:</source>
          <target state="translated">当运行QDoc生成HTML时,上面的例子对生成的输出没有任何影响,但如果运行QDoc生成DITA XML,该例子将生成以下内容。</target>
        </trans-unit>
        <trans-unit id="313916658b849b20eb8b38c2b36d5a604ba7482c" translate="yes" xml:space="preserve">
          <source>When running QDoc to generate HTML, the example above will have no effect on the generated output.</source>
          <target state="translated">当运行QDoc生成HTML时,上面的例子对生成的输出没有影响。</target>
        </trans-unit>
        <trans-unit id="68eca509dfd034e35a8f7fa47ec0779beae30c64" translate="yes" xml:space="preserve">
          <source>When running Qt Web Engine examples in a Docker container and browsing content-heavy sites, BUS errors (SIGBUS) might be reported. Typically, this is caused by Docker running a container with a too small memory space (such as 64MB). To fix this problem, increase the memory space size.</source>
          <target state="translated">当在 Docker 容器中运行 Qt Web Engine 示例并浏览内容密集型网站时,可能会报告 BUS 错误 (SIGBUS)。通常情况下,这是由于Docker运行的容器内存空间太小(如64MB)造成的。要解决这个问题,请增加内存空间大小。</target>
        </trans-unit>
        <trans-unit id="e7b5c8f813c3abfb4aaffaf280cd321b1b8726b4" translate="yes" xml:space="preserve">
          <source>When running Qt-based applications without a windowing system, such as X11 or Wayland, some devices require vendor-specific adaptation code for EGL and OpenGL ES support. This is provided in form of backends for the EGLFS platform plugin. This is not relevant for non-accelerated platforms, such as those that use the &lt;a href=&quot;embedded-linux#linuxfb&quot;&gt;LinuxFB&lt;/a&gt; platform plugin, which is meant for software-based rendering only. As of Qt 6, many embedded systems use &lt;a href=&quot;https://en.wikipedia.org/wiki/Direct_Rendering_Manager&quot;&gt;drm&lt;/a&gt; to set a video mode, manage display connectors and graphical surfaces. For example, an NXP i.MX8-based device or a Raspberry Pi 4 will use this approach, and therefore the most commonly used backend for EGLFS is &lt;b&gt;eglfs_kms&lt;/b&gt;, which enables EGL and OpenGL ES based rendering with &lt;code&gt;drm&lt;/code&gt;, using &lt;code&gt;gbm&lt;/code&gt; for surface and buffer management. Older devices, such as the NXP i.MX6, will continue to use the legacy, GPU vendor-specific approach to connect EGL window surfaces to the framebuffer, using dedicated eglfs backends, such as &lt;code&gt;eglfs_viv&lt;/code&gt;.</source>
          <target state="translated">当运行没有窗口系统的基于Qt的应用程序（例如X11或Wayland）时，某些设备需要特定于供应商的适应代码才能支持EGL和OpenGL ES。这是以EGLFS平台插件的后端形式提供的。这与非加速平台（例如使用&lt;a href=&quot;embedded-linux#linuxfb&quot;&gt;LinuxFB&lt;/a&gt;平台插件的平台）无关，后者仅用于基于软件的渲染。从Qt 6开始，许多嵌入式系统都使用&lt;a href=&quot;https://en.wikipedia.org/wiki/Direct_Rendering_Manager&quot;&gt;drm&lt;/a&gt;设置视频模式，管理显示连接器和图形表面。例如，基于i.MX8-NXP装置或树莓裨4将使用这种方法，因此，对于EGLFS最常用的后端是&lt;b&gt;eglfs_kms&lt;/b&gt;，这使得能够EGL和OpenGL ES基于与再现 &lt;code&gt;drm&lt;/code&gt; ，使用 &lt;code&gt;gbm&lt;/code&gt; 用于表面和缓冲区管理。较旧的设备（例如NXP i.MX6）将继续使用传统的，GPU供应商特定的方法，通过专用的eglfs后端（例如 &lt;code&gt;eglfs_viv&lt;/code&gt; )将EGL窗口表面连接到帧缓冲区。</target>
        </trans-unit>
        <trans-unit id="ba74a44a4fe513e0e864500ccf8b7805d12bdf2c" translate="yes" xml:space="preserve">
          <source>When running the advertising procedure, a number of parameters can be configured, such as how fast to advertise or which clients, if any, can connect to the advertising device. These parameters are set via this class, and their values will be used when advertising is started by calling &lt;a href=&quot;qlowenergycontroller#startAdvertising&quot;&gt;QLowEnergyController::startAdvertising&lt;/a&gt;().</source>
          <target state="translated">在运行广告过程时，可以配置许多参数，例如广告投放速度或哪些客户端（如果有）可以连接到广告设备。这些参数是通过此类设置的，并且通过调用&lt;a href=&quot;qlowenergycontroller#startAdvertising&quot;&gt;QLowEnergyController :: startAdvertising&lt;/a&gt;（）启动广告时将使用它们的值。</target>
        </trans-unit>
        <trans-unit id="1e481bcca4c1c2d1651c8ca7889240a246da99ad" translate="yes" xml:space="preserve">
          <source>When running with the OpenGL backend of Qt Quick, both the generic, triangulation-based and the NVIDIA-specific &lt;code&gt;GL_NV_path_rendering&lt;/code&gt; methods are available. By default only the generic approach is used. Setting Shape.&lt;a href=&quot;qml-qtquick-shapes-shape#vendorExtensionsEnabled-prop&quot;&gt;vendorExtensionsEnabled&lt;/a&gt; property to &lt;code&gt;true&lt;/code&gt; leads to using NV_path_rendering on NVIDIA systems when running directly on OpenGL, and the generic method on others. When OpenGL is not used directly by the scene graph, for example because it is using the graphics abstraction layer (QRhi), only the generic shape renderer is available.</source>
          <target state="translated">与Qt Quick的OpenGL后端一起运行时，基于三角剖分的通用方法和基于NVIDIA的 &lt;code&gt;GL_NV_path_rendering&lt;/code&gt; 方法均可用。默认情况下，仅使用通用方法。设置形状。&lt;a href=&quot;qml-qtquick-shapes-shape#vendorExtensionsEnabled-prop&quot;&gt;vendorExtensionsEnabled&lt;/a&gt;属性设置为 &lt;code&gt;true&lt;/code&gt; 会导致在OpenGL系统上直接运行OpenGL时使用NV_path_rendering，而在其他系统上则使用通用方法。当场景图不直接使用OpenGL时（例如，因为它使用的是图形抽象层（QRhi）），则仅通用形状渲染器可用。</target>
        </trans-unit>
        <trans-unit id="419ca242c0e809f26e319a45853b06288d62f271" translate="yes" xml:space="preserve">
          <source>When running with the OpenGL backend of the scene graph, &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; offers the possibility to disable persistent OpenGL contexts as well. This setting is currently ignored by &lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt; and the context is always persistent. The OpenGL context is thus not destroyed when hiding the widget. The context is destroyed only when the widget is destroyed or when the widget gets reparented into another top-level widget's child hierarchy. However, some applications, in particular those that have their own graphics resources due to performing custom OpenGL rendering in the Qt Quick scene, may wish to disable the latter since they may not be prepared to handle the loss of the context when moving a &lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt; into another window. Such applications can set the QCoreApplication::AA_ShareOpenGLContexts attribute. For a discussion on the details of resource initialization and cleanup, refer to the &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt; documentation.</source>
          <target state="translated">与场景图的OpenGL后端一起运行时，&lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt;还提供了禁用持久OpenGL上下文的可能性。&lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt;当前忽略此设置，并且上下文始终是持久的。因此，隐藏小部件时不会破坏OpenGL上下文。仅当销毁小部件或将小部件重新关联到另一个顶级小部件的子层次结构时，上下文才被销毁。但是，某些应用程序，特别是那些由于在Qt Quick场景中执行自定义OpenGL渲染而具有自己的图形资源的应用程序，可能希望禁用后者，因为它们可能不准备在移动&lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt;时处理上下文的丢失。进入另一个窗口。此类应用程序可以设置QCoreApplication :: AA_ShareOpenGLContexts属性。有关资源初始化和清除的详细信息，请参阅&lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="31fa69229e2655989faeea8c24fbc639c55aaf43" translate="yes" xml:space="preserve">
          <source>When running with the OpenGL backend of the scene graph, &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; offers the possibility to disable persistent OpenGL contexts as well. This setting is currently ignored by QQuickWidget and the context is always persistent. The OpenGL context is thus not destroyed when hiding the widget. The context is destroyed only when the widget is destroyed or when the widget gets reparented into another top-level widget's child hierarchy. However, some applications, in particular those that have their own graphics resources due to performing custom OpenGL rendering in the Qt Quick scene, may wish to disable the latter since they may not be prepared to handle the loss of the context when moving a QQuickWidget into another window. Such applications can set the QCoreApplication::AA_ShareOpenGLContexts attribute. For a discussion on the details of resource initialization and cleanup, refer to the &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt; documentation.</source>
          <target state="translated">与场景图的OpenGL后端一起运行时，&lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt;还提供了禁用持久OpenGL上下文的可能性。QQuickWidget当前忽略此设置，并且上下文始终是持久的。因此，隐藏小部件时不会破坏OpenGL上下文。仅当销毁窗口小部件或将窗口小部件重新关联到另一个顶级窗口小部件的子层次结构时，上下文才被破坏。但是，某些应用程序，尤其是那些由于在Qt Quick场景中执行自定义OpenGL渲染而具有自己的图形资源的应用程序，可能希望禁用后者，因为在将QQuickWidget移入QtQuick场景时，它们可能不准备处理上下文的丢失。另一个窗口。这样的应用程序可以设置QCoreApplication :: AA_ShareOpenGLContexts属性。有关资源初始化和清除的详细信息，请参阅&lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="c2dc3890a6015b8657ffa4853aa53e53b5b8b626" translate="yes" xml:space="preserve">
          <source>When running with the OpenGL backend of the scene graph, &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; offers the possibility to disable persistent OpenGL contexts as well. This setting is currently ignored by QQuickWidget and the context is always persistent. The OpenGL context is thus not destroyed when hiding the widget. The context is destroyed only when the widget is destroyed or when the widget gets reparented into another top-level widget's child hierarchy. However, some applications, in particular those that have their own graphics resources due to performing custom OpenGL rendering in the Qt Quick scene, may wish to disable the latter since they may not be prepared to handle the loss of the context when moving a QQuickWidget into another window. Such applications can set the QCoreApplication::AA_ShareOpenGLContexts attribute. For a discussion on the details of resource initialization and cleanup, refer to the QOpenGLWidget documentation.</source>
          <target state="translated">与场景图的OpenGL后端一起运行时，&lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt;还提供了禁用持久OpenGL上下文的可能性。QQuickWidget当前忽略此设置，并且上下文始终是持久的。因此，隐藏小部件时不会破坏OpenGL上下文。仅当销毁窗口小部件或将窗口小部件重新关联到另一个顶级窗口小部件的子层次结构时，上下文才被破坏。但是，某些应用程序，尤其是那些由于在Qt Quick场景中执行自定义OpenGL渲染而具有自己的图形资源的应用程序，可能希望禁用后者，因为在将QQuickWidget移入QtQuick场景时，它们可能不准备处理上下文的丢失。另一个窗口。这样的应用程序可以设置QCoreApplication :: AA_ShareOpenGLContexts属性。有关资源初始化和清理的详细信息，</target>
        </trans-unit>
        <trans-unit id="4180cc40e3670129f26ab3b8aa7583731a04bc4b" translate="yes" xml:space="preserve">
          <source>When running with the default, OpenGL backend of Qt Quick, both the generic, triangulation-based and the NVIDIA-specific &lt;code&gt;GL_NV_path_rendering&lt;/code&gt; methods are available. By default only the generic approach is used. Setting Shape.&lt;a href=&quot;qml-qtquick-shapes-shape#vendorExtensionsEnabled-prop&quot;&gt;vendorExtensionsEnabled&lt;/a&gt; property to &lt;code&gt;true&lt;/code&gt; leads to using NV_path_rendering on NVIDIA systems, and the generic method on others.</source>
          <target state="translated">使用默认的Qt Quick OpenGL后端运行时，可以使用基于三角剖分的通用方法和特定于NVIDIA的 &lt;code&gt;GL_NV_path_rendering&lt;/code&gt; 方法。默认情况下，仅使用通用方法。设置形状。&lt;a href=&quot;qml-qtquick-shapes-shape#vendorExtensionsEnabled-prop&quot;&gt;vendorExtensionsEnabled&lt;/a&gt;属性设置为 &lt;code&gt;true&lt;/code&gt; 会导致在NVIDIA系统上使用NV_path_rendering，而在其他系统上则使用通用方法。</target>
        </trans-unit>
        <trans-unit id="22c17b7b950b81783fdb923684eedfd560adcd81" translate="yes" xml:space="preserve">
          <source>When runtime compilation is not in use and the shader properties refer to files with bytecode, the status is always Compiled. The contents of the shader is not examined (apart from basic reflection to discover vertex input elements and constant buffer data) until later in the rendering pipeline so potential errors (like layout or root signature mismatches) will only be detected at a later point.</source>
          <target state="translated">当运行时编译没有被使用,并且shader属性是指带有字节码的文件时,状态总是Compiled。在渲染流水线的后期,才会检查着色器的内容(除了发现顶点输入元素和常量缓冲区数据的基本反射外),因此潜在的错误(如布局或根签名不匹配)只会在后期被检测到。</target>
        </trans-unit>
        <trans-unit id="58111d4b497d62daae3e0a09bff9a306f73c232a" translate="yes" xml:space="preserve">
          <source>When sampling textures other than &lt;code&gt;SCREEN_TEXTURE&lt;/code&gt; and &lt;code&gt;DEPTH_TEXTURE&lt;/code&gt;, or when &lt;code&gt;FRAGCOORD&lt;/code&gt; is used to calculate the texture coordinate (which would be the typical use case for accessing the screen and depth textures), such an adjustment is not necessary.</source>
          <target state="translated">在对 &lt;code&gt;SCREEN_TEXTURE&lt;/code&gt; 和 &lt;code&gt;DEPTH_TEXTURE&lt;/code&gt; 以外的纹理进行采样时，或者在使用 &lt;code&gt;FRAGCOORD&lt;/code&gt; 计算纹理坐标（这将是访问屏幕和深度纹理的典型用例）时，无需进行此类调整。</target>
        </trans-unit>
        <trans-unit id="1cf799c203f3447ab5ee733162b36bb8365e9dec" translate="yes" xml:space="preserve">
          <source>When saving a form in</source>
          <target state="translated">当把表格保存在</target>
        </trans-unit>
        <trans-unit id="1e9c03991883db6f31187fbe5c35791a719629dc" translate="yes" xml:space="preserve">
          <source>When saving places between managers, there are a few things to be aware of. Some fields of a place such as the id, categories and icons are manager specific entities for example the categories in one manager may not be recognized in another. Therefore trying to save a place directly from one manager to another is not possible.</source>
          <target state="translated">当在经理之间保存地方时,有一些事情需要注意。一个地方的一些字段,如ID,类别和图标是经理特定的实体,例如,在一个经理的类别可能无法识别在另一个经理。因此,试图将一个地方从一个经理直接保存到另一个经理是不可能的。</target>
        </trans-unit>
        <trans-unit id="65dee2f6abcd14dfb6ffc451b8eef9d4e59664a3" translate="yes" xml:space="preserve">
          <source>When saving places between plugins, there are a few things to be aware of. Some fields of a place such as the id, categories and icons are plugin specific entities. For example the categories in one manager may not be recognised in another. Therefore trying to save a place directly from one plugin to another is not possible.</source>
          <target state="translated">在插件之间保存地方时,有几件事需要注意。一个地方的一些字段,如id,类别和图标是插件特定的实体。例如,一个管理器中的类别可能无法在另一个管理器中被识别。因此,试图将一个地方直接从一个插件保存到另一个是不可能的。</target>
        </trans-unit>
        <trans-unit id="16335d2940c0a9a4d44f0bf7877e3be7c7a4c25b" translate="yes" xml:space="preserve">
          <source>When scheduling cleanup of graphics resources using &lt;a href=&quot;qquickwindow#scheduleRenderJob&quot;&gt;QQuickWindow::scheduleRenderJob&lt;/a&gt;(), one should use either &lt;a href=&quot;qquickwindow#RenderStage-enum&quot;&gt;QQuickWindow::BeforeSynchronizingStage&lt;/a&gt; or &lt;a href=&quot;qquickwindow#RenderStage-enum&quot;&gt;QQuickWindow::AfterSynchronizingStage&lt;/a&gt;. The &lt;a href=&quot;qtquick-visualcanvas-scenegraph#scene-graph-and-rendering&quot;&gt;synchronization stage&lt;/a&gt; is where the scene graph is changed as a result of changes to the QML tree. If cleanup is scheduled at any other time, it may result in other parts of the scene graph referencing the newly deleted objects as these parts have not been updated.</source>
          <target state="translated">使用&lt;a href=&quot;qquickwindow#scheduleRenderJob&quot;&gt;QQuickWindow :: scheduleRenderJob&lt;/a&gt;（）安排图形资源的清理时，应使用&lt;a href=&quot;qquickwindow#RenderStage-enum&quot;&gt;QQuickWindow :: BeforeSynchronizingStage&lt;/a&gt;或&lt;a href=&quot;qquickwindow#RenderStage-enum&quot;&gt;QQuickWindow :: AfterSynchronizingStage&lt;/a&gt;。在&lt;a href=&quot;qtquick-visualcanvas-scenegraph#scene-graph-and-rendering&quot;&gt;同步阶段&lt;/a&gt;是其中场景图改变为更改QML树的结果。如果计划在其他任何时间进行清理，则可能会导致场景图的其他部分引用新删除的对象，因为这些部分尚未更新。</target>
        </trans-unit>
        <trans-unit id="0470cdb483508ebc7b70959dbd94540db4bc9c18" translate="yes" xml:space="preserve">
          <source>When sections are used, the first section command should be &lt;code&gt;section1&lt;/code&gt;.</source>
          <target state="translated">使用section时，第一个section命令应为 &lt;code&gt;section1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f5eedde8058556feb6cb3beeca59e7888ae6ece9" translate="yes" xml:space="preserve">
          <source>When selection is changed by clicking on the graph</source>
          <target state="translated">点击图形改变选择时</target>
        </trans-unit>
        <trans-unit id="00867511fe8868752b9e077a7707775ae9c1971d" translate="yes" xml:space="preserve">
          <source>When selection is changed explicitly via series API to a visible item</source>
          <target state="translated">当通过系列API将选择显式地改变为可见项时。</target>
        </trans-unit>
        <trans-unit id="2e1af7d1ebff8ce0a52ad99867add45c86a6ae89" translate="yes" xml:space="preserve">
          <source>When sending CAN FD frames, this flag is automatically set by the CAN FD hardware. &lt;code&gt;QCanBusFrame::setErrorStateIndicator()&lt;/code&gt; should only be used for application testing, e.g. on virtual CAN FD busses.</source>
          <target state="translated">发送CAN FD帧时，此标志由CAN FD硬件自动设置。 &lt;code&gt;QCanBusFrame::setErrorStateIndicator()&lt;/code&gt; 仅应用于应用程序测试，例如在虚拟CAN FD总线上。</target>
        </trans-unit>
        <trans-unit id="357729db045ad04ca40ebade91b854125d77106d" translate="yes" xml:space="preserve">
          <source>When sending CAN bus frames with &lt;a href=&quot;qcanbusdevice#ConfigurationKey-enum&quot;&gt;QCanBusDevice::ReceiveOwnKey&lt;/a&gt; enabled, all successfully sent frames are echoed to the receive queue and marked as local echo frames. &lt;code&gt;QCanBusFrame::setLocalEcho&lt;/code&gt; should therefore only be used for application testing, e.g. on virtual CAN busses.</source>
          <target state="translated">在启用&lt;a href=&quot;qcanbusdevice#ConfigurationKey-enum&quot;&gt;QCanBusDevice :: ReceiveOwnKey的情况下&lt;/a&gt;发送CAN总线帧时，所有成功发送的帧都会回显到接收队列中，并标记为本地回显帧。因此， &lt;code&gt;QCanBusFrame::setLocalEcho&lt;/code&gt; 应该仅用于应用程序测试，例如在虚拟CAN总线上。</target>
        </trans-unit>
        <trans-unit id="8bae5e50b5bdda4bb33ef7b2b1936a5c7112c234" translate="yes" xml:space="preserve">
          <source>When sending requests, to control the preference of when to use the cache and when to use the network, consider the following:</source>
          <target state="translated">在发送请求时,为了控制什么时候使用缓存,什么时候使用网络的偏好,可以考虑以下几点。</target>
        </trans-unit>
        <trans-unit id="73e7c0c4bd2ed4ad850a956107fc733151db2cb3" translate="yes" xml:space="preserve">
          <source>When sending, the &lt;a href=&quot;qnetworkdatagram#senderAddress&quot;&gt;senderAddress&lt;/a&gt;() and &lt;a href=&quot;qnetworkdatagram#senderPort&quot;&gt;senderPort&lt;/a&gt;() should contain the local address to be used when sending. The sender address must be an address that is assigned to this machine, which can be obtained using &lt;a href=&quot;qnetworkinterface&quot;&gt;QNetworkInterface&lt;/a&gt;, and the port number must be the port number that the socket is bound to. Either field can be left unset and will be filled in by the operating system with default values. The &lt;a href=&quot;qnetworkdatagram#destinationAddress&quot;&gt;destinationAddress&lt;/a&gt;() and &lt;a href=&quot;qnetworkdatagram#destinationPort&quot;&gt;destinationPort&lt;/a&gt;() fields may be set to a target address different from the one the UDP socket is currently associated with.</source>
          <target state="translated">发送时，&lt;a href=&quot;qnetworkdatagram#senderAddress&quot;&gt;senderAddress&lt;/a&gt;（）和&lt;a href=&quot;qnetworkdatagram#senderPort&quot;&gt;senderPort&lt;/a&gt;（）应该包含发送时要使用的本地地址。发件人地址必须是分配给此计算机的地址，可以使用&lt;a href=&quot;qnetworkinterface&quot;&gt;QNetworkInterface获取&lt;/a&gt;，并且端口号必须是套接字绑定到的端口号。这两个字段都可以保留不变，并且由操作系统使用默认值来填充。可以将&lt;a href=&quot;qnetworkdatagram#destinationAddress&quot;&gt;destinationAddress&lt;/a&gt;（）和&lt;a href=&quot;qnetworkdatagram#destinationPort&quot;&gt;destinationPort&lt;/a&gt;（）字段设置为与UDP套接字当前与之关联的目标地址不同的目标地址。</target>
        </trans-unit>
        <trans-unit id="bbc34b6972fd5a95f0e17a1bedd0814ddeba5170" translate="yes" xml:space="preserve">
          <source>When serialized item data is dropped onto a view, the data is inserted into the current model using its implementation of &lt;a href=&quot;qabstractitemmodel#dropMimeData&quot;&gt;QAbstractItemModel::dropMimeData&lt;/a&gt;(). The default implementation of this function will never overwrite any data in the model; instead, it tries to insert the items of data either as siblings of an item, or as children of that item.</source>
          <target state="translated">将序列化的项目数据放到视图上时，使用其&lt;a href=&quot;qabstractitemmodel#dropMimeData&quot;&gt;QAbstractItemModel :: dropMimeData&lt;/a&gt;（）实现将数据插入当前模型。该函数的默认实现将永远不会覆盖模型中的任何数据。而是尝试将数据项作为项的兄弟或项的子项插入。</target>
        </trans-unit>
        <trans-unit id="beb64bc37ef9e620c83f8575bbe6997166c3df77" translate="yes" xml:space="preserve">
          <source>When set on the characterFormat of a selection, the whole width of the text will be shown selected.</source>
          <target state="translated">当对一个选区的字符格式进行设置时,整个文本的宽度将被选中显示。</target>
        </trans-unit>
        <trans-unit id="270afeac1ae23334323cbd52bdb23f45e70ed478" translate="yes" xml:space="preserve">
          <source>When set to &lt;a href=&quot;qsensor#AxesOrientationMode-enum&quot;&gt;AutomaticOrientation&lt;/a&gt;, the reading values are automatically rotated when the screen orientation changes. In effect, the screen orientation is canceled out.</source>
          <target state="translated">设置为&lt;a href=&quot;qsensor#AxesOrientationMode-enum&quot;&gt;AutomaticOrientation&lt;/a&gt;时，屏幕方向更改时，读数值将自动旋转。实际上，屏幕方向被抵消了。</target>
        </trans-unit>
        <trans-unit id="e194e2df3cef00cb337af8c19d0b1fb4566ff905" translate="yes" xml:space="preserve">
          <source>When set to &lt;a href=&quot;qsensor#AxesOrientationMode-enum&quot;&gt;FixedOrientation&lt;/a&gt;, which is the default mode, no automatic rotation is applied to the reading. This is the only mode available for backends that do not support the &lt;a href=&quot;qsensor#Feature-enum&quot;&gt;QSensor::AxesOrientation&lt;/a&gt; feature.</source>
          <target state="translated">当设置为&lt;a href=&quot;qsensor#AxesOrientationMode-enum&quot;&gt;FixedOrientation时&lt;/a&gt;，这是默认模式，则不会将自动旋转应用于读数。这是不支持&lt;a href=&quot;qsensor#Feature-enum&quot;&gt;QSensor :: AxesOrientation&lt;/a&gt;功能的后端可用的唯一模式。</target>
        </trans-unit>
        <trans-unit id="f8c2be01f19679d844258975f1b00add910e8c48" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;1&lt;/code&gt;, Qt grabs the device for exclusive use.</source>
          <target state="translated">设置为 &lt;code&gt;1&lt;/code&gt; 时，Qt抓取该设备以专用。</target>
        </trans-unit>
        <trans-unit id="35fbd74909144bf9e11c35c0ff6fab64956af13b" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;false&lt;/code&gt;, rendering is done in single pass. In this mode the depth buffer is not used at all, and all objects are rendered in a single back to front pass.</source>
          <target state="translated">设置为 &lt;code&gt;false&lt;/code&gt; 时，渲染将单次完成。在此模式下，根本不使用深度缓冲区，并且所有对象都在一次从后到前的过程中渲染。</target>
        </trans-unit>
        <trans-unit id="f1c4e86e296a0003f811fe8398c8194c0172e276" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;transparent&lt;/code&gt;, no filling occurs.</source>
          <target state="translated">设置为 &lt;code&gt;transparent&lt;/code&gt; 时，不会发生填充。</target>
        </trans-unit>
        <trans-unit id="a494091a2d78c1c83239a6f4b1f78cd17e064c58" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;transparent&lt;/code&gt;, no stroking occurs.</source>
          <target state="translated">设置为 &lt;code&gt;transparent&lt;/code&gt; 时，不会发生描边。</target>
        </trans-unit>
        <trans-unit id="d01263f2091d195480c96c2d03450e33391dffb1" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the exterior of the item is padded with a 1 pixel wide transparent edge, making sampling outside the source texture use transparency instead of the edge pixels. Without this property, an image which has opaque edges will not get a blurred shadow.</source>
          <target state="translated">设置为 &lt;code&gt;true&lt;/code&gt; 时，将在项目的外部填充1像素宽的透明边缘，从而使在源纹理之外的采样使用透明度而不是边缘像素。没有此属性，边缘不透明的图像将不会产生模糊的阴影。</target>
        </trans-unit>
        <trans-unit id="b450467a36089b6e8cc7c9384688033053a7e1e0" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the exterior of the item is padded with a transparent edge, making sampling outside the source texture use transparency instead of the edge pixels. Without this property, an image which has opaque edges will not get a blurred edge.</source>
          <target state="translated">设置为 &lt;code&gt;true&lt;/code&gt; 时，将使用透明边缘填充项目的外部，从而使源纹理外部的采样使用透明而不是边缘像素。没有此属性，边缘不透明的图像将不会模糊。</target>
        </trans-unit>
        <trans-unit id="e4147d132167beace31a7c2f2898d532610dfada" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the mapping ignores any explicitly set column categories and overwrites them with automatically generated ones whenever the data from model is resolved. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果设置为 &lt;code&gt;true&lt;/code&gt; ，则映射将忽略任何显式设置的列类别，并在解析模型中的数据时使用自动生成的列类别覆盖它们。默认为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="36e27ee6dcb20f63a267c063b5f0dd2344ea8112" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the mapping ignores any explicitly set column categories and overwrites them with automatically generated ones whenever the data from the model is resolved. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果设置为 &lt;code&gt;true&lt;/code&gt; ，则映射将忽略任何显式设置的列类别，并在解析模型中的数据时使用自动生成的列类别覆盖它们。默认为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aeaf1add3a3c03b3752ea390e4de636b57ce02e7" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the mapping ignores any explicitly set column categories and overwrites them with automatically generated ones whenever the data from the model is resolved. Proxy minimum and maximum column values are also autogenerated from the data when this is set to &lt;code&gt;true&lt;/code&gt;. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果设置为 &lt;code&gt;true&lt;/code&gt; ，则映射将忽略任何显式设置的列类别，并在解析模型中的数据时使用自动生成的列类别覆盖它们。当设置为 &lt;code&gt;true&lt;/code&gt; 时，代理最小和最大列值也会从数据中自动生成。默认为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c86619e8213d5bed1738d02c582750355d6522a4" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the mapping ignores any explicitly set row categories and overwrites them with automatically generated ones whenever the data from model is resolved. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果设置为 &lt;code&gt;true&lt;/code&gt; ，则映射将忽略任何显式设置的行类别，并在解析模型中的数据时将其自动生成的类别覆盖。默认为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d11c86fa7ccfd6ba9e683cd50f0c094403577ac1" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the mapping ignores any explicitly set row categories and overwrites them with automatically generated ones whenever the data from the model is resolved. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果设置为 &lt;code&gt;true&lt;/code&gt; ，则映射将忽略任何显式设置的行类别，并在解析模型中的数据时使用自动生成的行类别覆盖它们。默认为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1301757ff1650814b570b349ec4348010d05817d" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the mapping ignores any explicitly set row categories and overwrites them with automatically generated ones whenever the data from the model is resolved. Proxy minimum and maximum row values are also autogenerated from the data when this is set to &lt;code&gt;true&lt;/code&gt;. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果设置为 &lt;code&gt;true&lt;/code&gt; ，则映射将忽略任何显式设置的行类别，并在解析模型中的数据时使用自动生成的行类别覆盖它们。当设置为 &lt;code&gt;true&lt;/code&gt; 时，代理最小和最大行值也会从数据中自动生成。默认为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7acc0959296f9d8e8c2e2b6cb1d3a66719167a16" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the mapping ignores row and column roles and categories, and uses the rows and columns from the model instead. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">设置为 &lt;code&gt;true&lt;/code&gt; 时，映射将忽略行和列的角色和类别，而是使用模型中的行和列。默认为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5f951719e1af643c50c67762d555cf0e850cebdd" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the mapping ignores row and column roles and categories, and uses the rows and columns from the model instead. Row and column headers are used for row and column labels. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">设置为 &lt;code&gt;true&lt;/code&gt; 时，映射将忽略行和列的角色和类别，而是使用模型中的行和列。行标题和列标题用于行和列标签。默认为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3496a774f53b66ac5b73d84b633a1d9d7d924d85" translate="yes" xml:space="preserve">
          <source>When set to a negative value, no stroking occurs.</source>
          <target state="translated">当设置为负值时,不会发生冲程。</target>
        </trans-unit>
        <trans-unit id="4e4ee14f2ec2d88c31367b1d93f593e8267881e4" translate="yes" xml:space="preserve">
          <source>When set to an empty string, the default label of the underlying platform is used. The default label is typically &lt;b&gt;Cancel&lt;/b&gt;.</source>
          <target state="translated">设置为空字符串时，将使用基础平台的默认标签。默认标签通常为&lt;b&gt;Cancel&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="71b7a30cacf1f3a3ee6a4172e8fb4bd21a402ed0" translate="yes" xml:space="preserve">
          <source>When set to an empty string, the default label of the underlying platform is used. The default label is typically &lt;b&gt;Open&lt;/b&gt; or &lt;b&gt;Save&lt;/b&gt; depending on which &lt;a href=&quot;qml-qt-labs-platform-filedialog#fileMode-prop&quot;&gt;fileMode&lt;/a&gt; the dialog is used in.</source>
          <target state="translated">设置为空字符串时，将使用基础平台的默认标签。默认标签通常是&lt;b&gt;打开&lt;/b&gt;还是&lt;b&gt;保存&lt;/b&gt;，这取决于&lt;a href=&quot;qml-qt-labs-platform-filedialog#fileMode-prop&quot;&gt;中将fileMode&lt;/a&gt;中使用的对话框。</target>
        </trans-unit>
        <trans-unit id="fa9215824a888cc448b2b5104b3e0edb6ca3f827" translate="yes" xml:space="preserve">
          <source>When set to an empty string, the default label of the underlying platform is used. The default label is typically &lt;b&gt;Open&lt;/b&gt;.</source>
          <target state="translated">设置为空字符串时，将使用基础平台的默认标签。默认标签通常为&lt;b&gt;Open&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="da31d475a6141d1527e3930e3b780117133be781" translate="yes" xml:space="preserve">
          <source>When set to true, a connection is made to the server with the given url. When set to false, the connection is closed. The default value is false.</source>
          <target state="translated">当设置为 &quot;true &quot;时,用给定的url建立与服务器的连接。当设置为false时,连接被关闭。默认值为false。</target>
        </trans-unit>
        <trans-unit id="d356d95380e0a7be709c939454d729283fff95fe" translate="yes" xml:space="preserve">
          <source>When set to true, updates are blocked and remote clients will not be notified about property changes.</source>
          <target state="translated">当设置为 &quot;true &quot;时,将阻止更新,并且不会通知远程客户端有关属性变化。</target>
        </trans-unit>
        <trans-unit id="9070c24af14ff16b55ce450d03070776a1d63544" translate="yes" xml:space="preserve">
          <source>When set, &lt;a href=&quot;qml-qtquick-shapes-shapepath&quot;&gt;ShapePath&lt;/a&gt;.&lt;a href=&quot;qml-qtquick-shapes-shapepath#fillColor-prop&quot;&gt;fillColor&lt;/a&gt; is ignored and filling is done using one of the &lt;a href=&quot;qml-qtquick-shapes-shapegradient&quot;&gt;ShapeGradient&lt;/a&gt; subtypes.</source>
          <target state="translated">设置后，为&lt;a href=&quot;qml-qtquick-shapes-shapepath&quot;&gt;ShapePath&lt;/a&gt;。&lt;a href=&quot;qml-qtquick-shapes-shapepath#fillColor-prop&quot;&gt;fillColor将&lt;/a&gt;被忽略，并使用&lt;a href=&quot;qml-qtquick-shapes-shapegradient&quot;&gt;ShapeGradient&lt;/a&gt;子类型之一进行填充。</target>
        </trans-unit>
        <trans-unit id="1d5a93253ef1915d6faa59a1fad7ff2aba883814" translate="yes" xml:space="preserve">
          <source>When set, &lt;code&gt;eglfs&lt;/code&gt; requests &lt;code&gt;FBIO_WAITFORVSYNC&lt;/code&gt; on the framebuffer device after each call to eglSwapBuffers(). This variable is only relevant for backends relying on the legacy Linux &lt;code&gt;fbdev&lt;/code&gt; subsystem. Normally, with a default swap interval of 1, Qt assumes that calling eglSwapBuffers() takes care of vsync; if it doesn't (for example, due to driver bugs), try setting &lt;code&gt;QT_QPA_EGLFS_FORCEVSYNC&lt;/code&gt; to a non-zero value.</source>
          <target state="translated">设置后， &lt;code&gt;eglfs&lt;/code&gt; 在每次调用eglSwapBuffers（）之后在帧缓冲设备上请求 &lt;code&gt;FBIO_WAITFORVSYNC&lt;/code&gt; 。该变量仅与依赖于传统Linux &lt;code&gt;fbdev&lt;/code&gt; 子系统的后端有关。通常，在默认交换间隔为1的情况下，Qt假定调用eglSwapBuffers（）会处理vsync。如果不是（例如由于驱动程序错误），请尝试将 &lt;code&gt;QT_QPA_EGLFS_FORCEVSYNC&lt;/code&gt; 设置为非零值。</target>
        </trans-unit>
        <trans-unit id="9744299b5e8df688636dffff69d9ac6cfe828468" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by column role before it is used as a column category. This property specifies the regular expression to find the portion of the mapped value to replace and &lt;a href=&quot;qml-qtdatavisualization-itemmodelbardataproxy#columnRoleReplace-prop&quot;&gt;columnRoleReplace&lt;/a&gt; property contains the replacement string. This is useful for example in parsing row and column categories from a single timestamp field in the item model.</source>
          <target state="translated">设置后，将在按列角色映射的值用作列类别之前对其进行搜索和替换。此属性指定正则表达式以查找要替换的映射值的一部分，并且&lt;a href=&quot;qml-qtdatavisualization-itemmodelbardataproxy#columnRoleReplace-prop&quot;&gt;columnRoleReplace&lt;/a&gt;属性包含替换字符串。例如，这在从项目模型中的单个时间戳字段解析行和列类别时很有用。</target>
        </trans-unit>
        <trans-unit id="8a131bdf52627ee3b863efe9743b906a421ee8f9" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by rotation role before it is used as a bar rotation angle. This property specifies the regular expression to find the portion of the mapped value to replace and &lt;a href=&quot;qml-qtdatavisualization-itemmodelbardataproxy#rotationRoleReplace-prop&quot;&gt;rotationRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">设置后，将在旋转角色所映射的值用作钢筋旋转角度之前对其进行搜索和替换。此属性指定正则表达式以查找要替换的映射值的一部分，并且&lt;a href=&quot;qml-qtdatavisualization-itemmodelbardataproxy#rotationRoleReplace-prop&quot;&gt;rotationRoleReplace&lt;/a&gt;属性包含替换字符串。</target>
        </trans-unit>
        <trans-unit id="9108433232a1c54c0f0add6d2c59552f382b7483" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by row role before it is used as a row category. This property specifies the regular expression to find the portion of the mapped value to replace and &lt;a href=&quot;qml-qtdatavisualization-itemmodelbardataproxy#rowRoleReplace-prop&quot;&gt;rowRoleReplace&lt;/a&gt; property contains the replacement string. This is useful for example in parsing row and column categories from a single timestamp field in the item model.</source>
          <target state="translated">设置后，将在按行角色映射的值用作行类别之前对其进行搜索和替换。此属性指定正则表达式以查找要替换的映射值的一部分，并且&lt;a href=&quot;qml-qtdatavisualization-itemmodelbardataproxy#rowRoleReplace-prop&quot;&gt;rowRoleReplace&lt;/a&gt;属性包含替换字符串。例如，这在从项目模型中的单个时间戳字段解析行和列类别时很有用。</target>
        </trans-unit>
        <trans-unit id="bc9c1cbcb787214aaefb29b1ef7ac7fde2064a50" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by the column role before it is used as a column category. This property specifies the regular expression to find the portion of the mapped value to replace and the &lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#columnRoleReplace-prop&quot;&gt;columnRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">设置后，在将列角色映射的值用作列类别之前对其进行搜索和替换。此属性指定正则表达式以查找要替换的映射值的一部分，并且&lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#columnRoleReplace-prop&quot;&gt;columnRoleReplace&lt;/a&gt;属性包含替换字符串。</target>
        </trans-unit>
        <trans-unit id="6c6f75996ea55b81eb144da97f4ddbf1f7b8d2df" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by the rotation role before it is used as item rotation. This property specifies the regular expression to find the portion of the mapped value to replace and &lt;a href=&quot;qml-qtdatavisualization-itemmodelscatterdataproxy#rotationRoleReplace-prop&quot;&gt;rotationRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">设置后，将在旋转角色所映射的值用作项目旋转之前对其进行搜索和替换。此属性指定正则表达式以查找要替换的映射值的一部分，并且&lt;a href=&quot;qml-qtdatavisualization-itemmodelscatterdataproxy#rotationRoleReplace-prop&quot;&gt;rotationRoleReplace&lt;/a&gt;属性包含替换字符串。</target>
        </trans-unit>
        <trans-unit id="4d7bce4ff7100e6fa830173aafe199aab62b818f" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by the row role before it is used as a row category. This property specifies the regular expression to find the portion of the mapped value to replace and the &lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#rowRoleReplace-prop&quot;&gt;rowRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">设置后，将在行角色映射的值用作行类别之前对其进行搜索和替换。此属性指定正则表达式以查找要替换的映射值的一部分，并且&lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#rowRoleReplace-prop&quot;&gt;rowRoleReplace&lt;/a&gt;属性包含替换字符串。</target>
        </trans-unit>
        <trans-unit id="885cf3aa8085356e119ac0af240743c4239afe83" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by the x position role before it is used as an item position value. This property specifies the regular expression to find the portion of the mapped value to replace and &lt;a href=&quot;qml-qtdatavisualization-itemmodelscatterdataproxy#xPosRoleReplace-prop&quot;&gt;xPosRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">设置后，将在x位置角色所映射的值用作项目位置值之前对其进行搜索和替换。此属性指定正则表达式以查找要替换的映射值的一部分，并且&lt;a href=&quot;qml-qtdatavisualization-itemmodelscatterdataproxy#xPosRoleReplace-prop&quot;&gt;xPosRoleReplace&lt;/a&gt;属性包含替换字符串。</target>
        </trans-unit>
        <trans-unit id="66303afda7fe28b42306b119120f8c9d8ffe13b2" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by the x position role before it is used as an item position value. This property specifies the regular expression to find the portion of the mapped value to replace and the &lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#xPosRoleReplace-prop&quot;&gt;xPosRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">设置后，将在x位置角色所映射的值用作项目位置值之前对其进行搜索和替换。此属性指定正则表达式以查找要替换的映射值的一部分，并且&lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#xPosRoleReplace-prop&quot;&gt;xPosRoleReplace&lt;/a&gt;属性包含替换字符串。</target>
        </trans-unit>
        <trans-unit id="177b7625ed57441e9caab15b1ba52de1056c1697" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by the y position role before it is used as an item position value. This property specifies the regular expression to find the portion of the mapped value to replace and &lt;a href=&quot;qml-qtdatavisualization-itemmodelscatterdataproxy#yPosRoleReplace-prop&quot;&gt;yPosRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">设置后，将在y位置角色所映射的值用作项目位置值之前对其进行搜索和替换。此属性指定正则表达式以查找要替换的映射值的一部分，并且&lt;a href=&quot;qml-qtdatavisualization-itemmodelscatterdataproxy#yPosRoleReplace-prop&quot;&gt;yPosRoleReplace&lt;/a&gt;属性包含替换字符串。</target>
        </trans-unit>
        <trans-unit id="4cd4628ea893e9ef8db7b0e103b8b8eb84582ee7" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by the y position role before it is used as an item position value. This property specifies the regular expression to find the portion of the mapped value to replace and the &lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#yPosRoleReplace-prop&quot;&gt;yPosRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">设置后，将在y位置角色所映射的值用作项目位置值之前对其进行搜索和替换。此属性指定正则表达式以查找要替换的映射值的一部分，并且&lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#yPosRoleReplace-prop&quot;&gt;yPosRoleReplace&lt;/a&gt;属性包含替换字符串。</target>
        </trans-unit>
        <trans-unit id="e690058b1d8c0f0ea729f77975b58803689a29ce" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by the z position role before it is used as an item position value. This property specifies the regular expression to find the portion of the mapped value to replace and &lt;a href=&quot;qml-qtdatavisualization-itemmodelscatterdataproxy#zPosRoleReplace-prop&quot;&gt;zPosRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">设置后，在将z位置角色所映射的值用作项目位置值之前对其进行搜索和替换。此属性指定正则表达式以查找要替换的映射值的一部分，并且&lt;a href=&quot;qml-qtdatavisualization-itemmodelscatterdataproxy#zPosRoleReplace-prop&quot;&gt;zPosRoleReplace&lt;/a&gt;属性包含替换字符串。</target>
        </trans-unit>
        <trans-unit id="8a50a48a136eb418621caa5d9975fa8698821525" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by the z position role before it is used as an item position value. This property specifies the regular expression to find the portion of the mapped value to replace and the &lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#zPosRoleReplace-prop&quot;&gt;zPosRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">设置后，在将z位置角色所映射的值用作项目位置值之前对其进行搜索和替换。此属性指定正则表达式以查找要替换的映射值的一部分，并且&lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#zPosRoleReplace-prop&quot;&gt;zPosRoleReplace&lt;/a&gt;属性包含替换字符串。</target>
        </trans-unit>
        <trans-unit id="9e6e26fa69d41d9769f5fde960eb52cd2c8473db" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by value role before it is used as a bar value. This property specifies the regular expression to find the portion of the mapped value to replace and &lt;a href=&quot;qml-qtdatavisualization-itemmodelbardataproxy#valueRoleReplace-prop&quot;&gt;valueRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">设置后，将搜索和替换按值角色映射的值，然后将其用作条形值。此属性指定正则表达式以查找要替换的映射值的一部分，并且&lt;a href=&quot;qml-qtdatavisualization-itemmodelbardataproxy#valueRoleReplace-prop&quot;&gt;valueRoleReplace&lt;/a&gt;属性包含替换字符串。</target>
        </trans-unit>
        <trans-unit id="57e671691d58c18370650113c81b9894428ab1c0" translate="yes" xml:space="preserve">
          <source>When set, some debugging information is printed on the debug output. For example, the input &lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat&lt;/a&gt; and the properties of the chosen EGL configuration are printed while creating a new context. When used together with Qt Quick's &lt;code&gt;QSG_INFO&lt;/code&gt; variable, you can get useful information for troubleshooting issues related to the EGL configuration.</source>
          <target state="translated">设置后，一些调试信息会打印在调试输出上。例如，在创建新上下文时，将打印输入&lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat&lt;/a&gt;和所选EGL配置的属性。与Qt Quick的 &lt;code&gt;QSG_INFO&lt;/code&gt; 变量一起使用时，您可以获得有关排除EGL配置相关问题的有用信息。</target>
        </trans-unit>
        <trans-unit id="c63ec68c079a9bce145854c06f681928a4a99fb9" translate="yes" xml:space="preserve">
          <source>When set, the red, green, and blue color channel sizes are ignored when &lt;code&gt;eglfs&lt;/code&gt; creates a new context, window or offscreen surface. Instead, the plugin requests a configuration with 8 bits per channel. This can be helpful on devices where configurations with less than 32 or 24 bits per pixel (for example, 5-6-5 or 4-4-4) are chosen by default despite knowing they are not ideal, for example, due to banding effects. Instead of changing application code, this variable provides a shortcut to force 24 or 32 bpp configurations.</source>
          <target state="translated">设置后，当 &lt;code&gt;eglfs&lt;/code&gt; 创建新的上下文，窗口或屏幕外表面时，红色，绿色和蓝色通道大小将被忽略。而是，插件请求每通道8位的配置。这对于在默认情况下选择每像素少于32或24位的配置（例如5-6-5或4-4-4）的设备很有帮助，尽管知道它们不理想，例如由于条带效果。代替更改应用程序代码，此变量提供了强制执行24或32 bpp配置的快捷方式。</target>
        </trans-unit>
        <trans-unit id="33b3bd9431a5daf3aec6eea2743d997f576dc8d8" translate="yes" xml:space="preserve">
          <source>When setting &lt;a href=&quot;qml-qtquick-item#clip-prop&quot;&gt;Item::clip&lt;/a&gt; to true, it will create a &lt;a href=&quot;qsgclipnode&quot;&gt;QSGClipNode&lt;/a&gt; with a rectangle in its geometry. The default renderer will apply this clip by using scissoring in OpenGL. If the item is rotated by a non-90-degree angle, the OpenGL's stencil buffer is used. Qt Quick Item only supports setting a rectangle as clip through QML, but the scene graph API and the default renderer can use any shape for clipping.</source>
          <target state="translated">将&lt;a href=&quot;qml-qtquick-item#clip-prop&quot;&gt;Item :: clip&lt;/a&gt;设置为true时，将创建一个&lt;a href=&quot;qsgclipnode&quot;&gt;QSGClipNode&lt;/a&gt;，其几何形状为矩形。默认渲染器将通过在OpenGL中使用剪刀来应用此剪辑。如果将项目旋转​​了非90度角，则使用OpenGL的模板缓冲区。Qt Quick Item仅支持通过QML将矩形设置为剪辑，但是场景图API和默认渲染器可以使用任何形状进行剪辑。</target>
        </trans-unit>
        <trans-unit id="a5ed62e892daca59bcdf47a39598aaed448ddccb" translate="yes" xml:space="preserve">
          <source>When setting a maximum date, the &lt;a href=&quot;qcalendarwidget#minimumDate-prop&quot;&gt;minimumDate&lt;/a&gt; and &lt;a href=&quot;qcalendarwidget#selectedDate-prop&quot;&gt;selectedDate&lt;/a&gt; properties are adjusted if the selection range becomes invalid. If the provided date is not a valid &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; object, the setMaximumDate() function does nothing.</source>
          <target state="translated">设置最大日期时，如果选择范围无效，则会调整&lt;a href=&quot;qcalendarwidget#minimumDate-prop&quot;&gt;minimumDate&lt;/a&gt;和&lt;a href=&quot;qcalendarwidget#selectedDate-prop&quot;&gt;selectedDate&lt;/a&gt;属性。如果提供的日期不是有效的&lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt;对象，则setMaximumDate（）函数将不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="c4ae2d023320be5119694dfde25d7c2125941c8d" translate="yes" xml:space="preserve">
          <source>When setting a minimum date, the &lt;a href=&quot;qcalendarwidget#maximumDate-prop&quot;&gt;maximumDate&lt;/a&gt; and &lt;a href=&quot;qcalendarwidget#selectedDate-prop&quot;&gt;selectedDate&lt;/a&gt; properties are adjusted if the selection range becomes invalid. If the provided date is not a valid &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; object, the setMinimumDate() function does nothing.</source>
          <target state="translated">设置最小日期时，如果选择范围无效，则会调整&lt;a href=&quot;qcalendarwidget#maximumDate-prop&quot;&gt;maximumDate&lt;/a&gt;和&lt;a href=&quot;qcalendarwidget#selectedDate-prop&quot;&gt;selectedDate&lt;/a&gt;属性。如果提供的日期不是有效的&lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt;对象，则setMinimumDate（）函数将不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="6eeb8a01ae2a0c99098eee6b5e541fd874b03835" translate="yes" xml:space="preserve">
          <source>When setting the fragment or vertex shader source code, the status will become Uncompiled. The first time the &lt;a href=&quot;qml-qtquick-shadereffect&quot;&gt;ShaderEffect&lt;/a&gt; is rendered with new shader source code, the shaders are compiled and linked, and the status is updated to Compiled or Error.</source>
          <target state="translated">设置片段或顶点着色器源代码时，状态将变为&amp;ldquo;未编译&amp;rdquo;。第一次使用新的着色器源代码渲染&lt;a href=&quot;qml-qtquick-shadereffect&quot;&gt;ShaderEffect时&lt;/a&gt;，将编译并链接着色器，并且状态将更新为&amp;ldquo;已编译&amp;rdquo;或&amp;ldquo;错误&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="12bc8cc3889504df656aec89fdae8d32b48b48bd" translate="yes" xml:space="preserve">
          <source>When setting the pick method to &lt;a href=&quot;qt3drender-qpickingsettings#PickResultMode-enum&quot;&gt;AllPicks&lt;/a&gt;, events will be triggered for all the entities with a &lt;a href=&quot;qt3drender-qobjectpicker&quot;&gt;QObjectPicker&lt;/a&gt; along the ray.</source>
          <target state="translated">当将pick方法设置为&lt;a href=&quot;qt3drender-qpickingsettings#PickResultMode-enum&quot;&gt;AllPicks时&lt;/a&gt;，将为所有带有沿射线的&lt;a href=&quot;qt3drender-qobjectpicker&quot;&gt;QObjectPicker&lt;/a&gt;的实体触发事件。</target>
        </trans-unit>
        <trans-unit id="faf0f4e80eb610da479dd49899491179142a9cfd" translate="yes" xml:space="preserve">
          <source>When setting the pick method to &lt;a href=&quot;qt3drender-qpickingsettings#PickResultMode-enum&quot;&gt;NearestPriorityPick&lt;/a&gt;, events will be triggered for the nearest highest priority picker. This can be used when a given element should always be selected even if others are in front of it.</source>
          <target state="translated">当将pick方法设置为&lt;a href=&quot;qt3drender-qpickingsettings#PickResultMode-enum&quot;&gt;NearestPriorityPick时&lt;/a&gt;，将为最接近的最高优先级选择器触发事件​​。当应该始终选择给定元素（即使其他元素在其前面）时，可以使用此方法。</target>
        </trans-unit>
        <trans-unit id="46eaad0ccb2bedbfcbdda653384c06947cbb2dbb" translate="yes" xml:space="preserve">
          <source>When setting the year using the Date constructor or set(UTC)FullYear(), the convention set by ISO 8601 is used and 0 is a valid year. This means negative years set with the constructor or set(UTC)FullYear() are zero-based and thus offset by one year from what is printed with toString() and friends. Parsing the output of any of the to*String() methods will yield the same date value you printed from. Date.parse() will recognize the different formats and their convention on the existence of year 0.</source>
          <target state="translated">当使用Date构造函数或set(UTC)FullYear()设置年份时,使用ISO 8601设置的惯例,0是有效的年份。这意味着用构造函数或set(UTC)FullYear()设置的负年份是基于零的,因此与toString()和friends的打印结果相差一年。解析任何一个to*String()方法的输出,都会得到你打印出来的相同的日期值。Date.parse()将识别不同的格式及其对0年存在的约定。</target>
        </trans-unit>
        <trans-unit id="99af14a2050e900c54b4cf4320044307dba2671c" translate="yes" xml:space="preserve">
          <source>When setting this property &lt;a href=&quot;qtextbrowser&quot;&gt;QTextBrowser&lt;/a&gt; tries to find a document with the specified name in the paths of the &lt;a href=&quot;qtextbrowser#searchPaths-prop&quot;&gt;searchPaths&lt;/a&gt; property and directory of the current source, unless the value is an absolute file path. It also checks for optional anchors and scrolls the document accordingly</source>
          <target state="translated">设置此属性时，除非该值是绝对文件路径，否则&lt;a href=&quot;qtextbrowser&quot;&gt;QTextBrowser&lt;/a&gt;尝试在&lt;a href=&quot;qtextbrowser#searchPaths-prop&quot;&gt;searchPaths&lt;/a&gt;属性的路径和当前源的目录中查找具有指定名称的文档。它还检查可选的锚点并相应地滚动文档</target>
        </trans-unit>
        <trans-unit id="fce20a64ddb9efcd0a6072a5a5807d0354c99c5b" translate="yes" xml:space="preserve">
          <source>When setting this property the &lt;a href=&quot;qdatetimeedit#maximumDate-prop&quot;&gt;maximumDate&lt;/a&gt; is adjusted if necessary, to ensure that the range remains valid. If the date is not a valid &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; object, this function does nothing.</source>
          <target state="translated">设置此属性时，如有必要，将调整&lt;a href=&quot;qdatetimeedit#maximumDate-prop&quot;&gt;maximumDate&lt;/a&gt;，以确保范围保持有效。如果日期不是有效的&lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt;对象，则此函数不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="f3536a246a03f23af815f636527d6ffa980281bd" translate="yes" xml:space="preserve">
          <source>When setting this property the &lt;a href=&quot;qdatetimeedit#maximumDateTime-prop&quot;&gt;maximumDateTime&lt;/a&gt;() is adjusted if necessary to ensure that the range remains valid. If the datetime is not a valid &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; object, this function does nothing.</source>
          <target state="translated">设置此属性时，如有必要，将调整&lt;a href=&quot;qdatetimeedit#maximumDateTime-prop&quot;&gt;maximumDateTime&lt;/a&gt;（）以确保范围保持有效。如果datetime不是有效的&lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt;对象，则此函数不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="1d3985b1214032de5548d5f37a050ce05224466f" translate="yes" xml:space="preserve">
          <source>When setting this property the &lt;a href=&quot;qdatetimeedit#maximumTime-prop&quot;&gt;maximumTime&lt;/a&gt; is adjusted if necessary, to ensure that the range remains valid. If the time is not a valid &lt;a href=&quot;qtime&quot;&gt;QTime&lt;/a&gt; object, this function does nothing.</source>
          <target state="translated">设置此属性时，如有必要，将调整&lt;a href=&quot;qdatetimeedit#maximumTime-prop&quot;&gt;maximumTime&lt;/a&gt;，以确保范围保持有效。如果时间不是有效的&lt;a href=&quot;qtime&quot;&gt;QTime&lt;/a&gt;对象，则此函数不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="3a94d8175867d402a4937ec027013411408a4199" translate="yes" xml:space="preserve">
          <source>When setting this property the &lt;a href=&quot;qdatetimeedit#minimumDate-prop&quot;&gt;minimumDate&lt;/a&gt; is adjusted if necessary to ensure that the range remains valid. If the date is not a valid &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; object, this function does nothing.</source>
          <target state="translated">设置此属性时，如有必要，将调整&lt;a href=&quot;qdatetimeedit#minimumDate-prop&quot;&gt;minimumDate&lt;/a&gt;以确保范围保持有效。如果日期不是有效的&lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt;对象，则此函数不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="d00e3ae41e62b165ec366eabf69c76f997cb71bc" translate="yes" xml:space="preserve">
          <source>When setting this property the &lt;a href=&quot;qdatetimeedit#minimumDateTime-prop&quot;&gt;minimumDateTime&lt;/a&gt;() is adjusted if necessary to ensure that the range remains valid. If the datetime is not a valid &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; object, this function does nothing.</source>
          <target state="translated">设置此属性时，如有必要，将调整&lt;a href=&quot;qdatetimeedit#minimumDateTime-prop&quot;&gt;minimumDateTime&lt;/a&gt;（）以确保范围保持有效。如果datetime不是有效的&lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt;对象，则此函数不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="fd101378453eccdf2e848a4824798dd5c0a85b7e" translate="yes" xml:space="preserve">
          <source>When setting this property the &lt;a href=&quot;qdoublespinbox#maximum-prop&quot;&gt;maximum&lt;/a&gt; is adjusted if necessary to ensure that the range remains valid.</source>
          <target state="translated">设置此属性时，如有必要，将调整&lt;a href=&quot;qdoublespinbox#maximum-prop&quot;&gt;最大值，&lt;/a&gt;以确保范围保持有效。</target>
        </trans-unit>
        <trans-unit id="d52e2cb44d7f2ae6749696edb496d673ee39757f" translate="yes" xml:space="preserve">
          <source>When setting this property the &lt;a href=&quot;qdoublespinbox#minimum-prop&quot;&gt;minimum&lt;/a&gt; is adjusted if necessary, to ensure that the range remains valid.</source>
          <target state="translated">设置此属性时，如有必要，将调整&lt;a href=&quot;qdoublespinbox#minimum-prop&quot;&gt;最小值&lt;/a&gt;，以确保范围保持有效。</target>
        </trans-unit>
        <trans-unit id="47cfedf6ef21c709f13ba69a81ab6789fc8a9fd1" translate="yes" xml:space="preserve">
          <source>When setting this property the &lt;a href=&quot;qspinbox#maximum-prop&quot;&gt;maximum&lt;/a&gt; is adjusted if necessary to ensure that the range remains valid.</source>
          <target state="translated">设置此属性时，如有必要，将调整&lt;a href=&quot;qspinbox#maximum-prop&quot;&gt;最大值，&lt;/a&gt;以确保范围保持有效。</target>
        </trans-unit>
        <trans-unit id="9b3aa09d9d597d2ccc6d81186f12b9dee43bde16" translate="yes" xml:space="preserve">
          <source>When setting this property the corresponding maximum value is adjusted if necessary, to ensure that the range remains valid.</source>
          <target state="translated">在设置该属性时,必要时调整相应的最大值,以确保该范围保持有效。</target>
        </trans-unit>
        <trans-unit id="ed5abb02b8b1a236c42c80272c5d4f7b5e792484" translate="yes" xml:space="preserve">
          <source>When setting this property the corresponding minimum value is adjusted if necessary, to ensure that the range remains valid.</source>
          <target state="translated">设置该属性时,必要时调整相应的最小值,以保证该范围保持有效。</target>
        </trans-unit>
        <trans-unit id="0e2d22ffaa8c87cce0769e98c3a06583fa170f8d" translate="yes" xml:space="preserve">
          <source>When setting this property the minimum is adjusted if necessary, to ensure that the range remains valid.</source>
          <target state="translated">当设置该属性时,必要时调整最小值,以确保该范围保持有效。</target>
        </trans-unit>
        <trans-unit id="10bbb03412564a8a76a7faa470981f3e92871bb0" translate="yes" xml:space="preserve">
          <source>When setting this property the timespec of the &lt;a href=&quot;qdatetimeedit&quot;&gt;QDateTimeEdit&lt;/a&gt; remains the same and the timespec of the new &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; is ignored.</source>
          <target state="translated">当设置该属性的的timespec &lt;a href=&quot;qdatetimeedit&quot;&gt;QDateTimeEdit&lt;/a&gt;保持不变，新的的timespec &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt;被忽略。</target>
        </trans-unit>
        <trans-unit id="2375a6809ff71a69632c1ba6bc4411bcbd56175e" translate="yes" xml:space="preserve">
          <source>When setting this property to a list of waypoints, each waypoint can be either a &lt;a href=&quot;qml-coordinate&quot;&gt;coordinate&lt;/a&gt; or a &lt;a href=&quot;qml-qtlocation-waypoint&quot;&gt;Waypoint&lt;/a&gt;, interchangeably. If a &lt;a href=&quot;qml-coordinate&quot;&gt;coordinate&lt;/a&gt; is passed, it will be internally converted to a &lt;a href=&quot;qml-qtlocation-waypoint&quot;&gt;Waypoint&lt;/a&gt;.</source>
          <target state="translated">将此属性设置为路点列表时，每个路点可以是&lt;a href=&quot;qml-coordinate&quot;&gt;坐标&lt;/a&gt;或路&lt;a href=&quot;qml-qtlocation-waypoint&quot;&gt;点&lt;/a&gt;，可以互换。如果传递了&lt;a href=&quot;qml-coordinate&quot;&gt;坐标&lt;/a&gt;，则它将在内部转换为&lt;a href=&quot;qml-qtlocation-waypoint&quot;&gt;Waypoint&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8c08c05c4f9a6cc8ebd2fa6d3ff3659b0e8d5359" translate="yes" xml:space="preserve">
          <source>When setting this property, the &lt;a href=&quot;qabstractslider#maximum-prop&quot;&gt;maximum&lt;/a&gt; is adjusted if necessary to ensure that the range remains valid. Also the slider's current value is adjusted to be within the new range.</source>
          <target state="translated">设置此属性时，如有必要，将调整&lt;a href=&quot;qabstractslider#maximum-prop&quot;&gt;最大值&lt;/a&gt;以确保范围保持有效。同样，将滑块的当前值调整到新范围内。</target>
        </trans-unit>
        <trans-unit id="083344e77b31d85a0b5a8a8283eca8fda3876952" translate="yes" xml:space="preserve">
          <source>When setting this property, the &lt;a href=&quot;qabstractslider#minimum-prop&quot;&gt;minimum&lt;/a&gt; is adjusted if necessary to ensure that the range remains valid. Also the slider's current value is adjusted to be within the new range.</source>
          <target state="translated">设置此属性时，如有必要，将调整&lt;a href=&quot;qabstractslider#minimum-prop&quot;&gt;最小值，&lt;/a&gt;以确保范围保持有效。同样，将滑块的当前值调整到新范围内。</target>
        </trans-unit>
        <trans-unit id="890b98dfbcb1358977a7219adcd63ac2cd2c0980" translate="yes" xml:space="preserve">
          <source>When setting this property, the &lt;a href=&quot;qdatetimeedit#minimumTime-prop&quot;&gt;minimumTime&lt;/a&gt; is adjusted if necessary to ensure that the range remains valid. If the time is not a valid &lt;a href=&quot;qtime&quot;&gt;QTime&lt;/a&gt; object, this function does nothing.</source>
          <target state="translated">设置此属性时，如有必要，将调整&lt;a href=&quot;qdatetimeedit#minimumTime-prop&quot;&gt;minimumTime&lt;/a&gt;以确保范围保持有效。如果时间不是有效的&lt;a href=&quot;qtime&quot;&gt;QTime&lt;/a&gt;对象，则此函数不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="fa2c9bb906ff3305eef76e88d6b8655a32b982f4" translate="yes" xml:space="preserve">
          <source>When setting this property, the &lt;a href=&quot;qml-qtcharts-pieseries#holeSize-prop&quot;&gt;holeSize&lt;/a&gt; property is adjusted if necessary, to ensure that the hole size is not greater than the pie size.</source>
          <target state="translated">设置此属性时，如有必要，将调整&lt;a href=&quot;qml-qtcharts-pieseries#holeSize-prop&quot;&gt;holeSize&lt;/a&gt;属性，以确保孔大小不大于饼图大小。</target>
        </trans-unit>
        <trans-unit id="f435a68f9316a9aad8d0bd9214e3829a97c2384f" translate="yes" xml:space="preserve">
          <source>When setting this property, the &lt;a href=&quot;qml-qtcharts-pieseries#size-prop&quot;&gt;size&lt;/a&gt; property is adjusted if necessary, to ensure that the hole size is not greater than the pie size.</source>
          <target state="translated">设置此属性时，如有必要，将调整&lt;a href=&quot;qml-qtcharts-pieseries#size-prop&quot;&gt;size&lt;/a&gt;属性，以确保孔大小不大于饼图大小。</target>
        </trans-unit>
        <trans-unit id="2614229e0748ff7798a30ec6c9a32c8bd564129c" translate="yes" xml:space="preserve">
          <source>When setting this property, the &lt;a href=&quot;qpieseries#holeSize-prop&quot;&gt;holeSize&lt;/a&gt; property is adjusted if necessary, to ensure that the hole size is not greater than the pie size.</source>
          <target state="translated">设置此属性时，如有必要，将调整&lt;a href=&quot;qpieseries#holeSize-prop&quot;&gt;holeSize&lt;/a&gt;属性，以确保孔大小不大于饼图大小。</target>
        </trans-unit>
        <trans-unit id="9676bb4e1b94754c72406b0dd8f30c9729452b6c" translate="yes" xml:space="preserve">
          <source>When setting this property, the &lt;a href=&quot;qpieseries#size-prop&quot;&gt;size&lt;/a&gt; property is adjusted if necessary, to ensure that the hole size is not greater than the pie size.</source>
          <target state="translated">设置此属性时，如有必要，将调整&lt;a href=&quot;qpieseries#size-prop&quot;&gt;size&lt;/a&gt;属性，以确保孔大小不大于饼图大小。</target>
        </trans-unit>
        <trans-unit id="5c4c814181687e53992d25bc4a345c8885416475" translate="yes" xml:space="preserve">
          <source>When setting this property, the &lt;a href=&quot;qprogressbar#maximum-prop&quot;&gt;maximum&lt;/a&gt; is adjusted if necessary to ensure that the range remains valid. If the current value falls outside the new range, the progress bar is reset with &lt;a href=&quot;qprogressbar#reset&quot;&gt;reset&lt;/a&gt;().</source>
          <target state="translated">设置此属性时，如有必要，将调整&lt;a href=&quot;qprogressbar#maximum-prop&quot;&gt;最大值&lt;/a&gt;以确保范围保持有效。如果当前值不在新范围内，则使用&lt;a href=&quot;qprogressbar#reset&quot;&gt;reset&lt;/a&gt;（）重置进度条。</target>
        </trans-unit>
        <trans-unit id="d10bb2cee1aba8ceaf054055bf90ceea6821e2bc" translate="yes" xml:space="preserve">
          <source>When setting this property, the &lt;a href=&quot;qprogressbar#minimum-prop&quot;&gt;minimum&lt;/a&gt; is adjusted if necessary to ensure that the range remains valid. If the current value falls outside the new range, the progress bar is reset with &lt;a href=&quot;qprogressbar#reset&quot;&gt;reset&lt;/a&gt;().</source>
          <target state="translated">设置此属性时，如有必要，将调整&lt;a href=&quot;qprogressbar#minimum-prop&quot;&gt;最小值，&lt;/a&gt;以确保范围保持有效。如果当前值不在新范围内，则使用&lt;a href=&quot;qprogressbar#reset&quot;&gt;reset&lt;/a&gt;（）重置进度条。</target>
        </trans-unit>
        <trans-unit id="32aea66ca6d6da71cb41f4c7cc9dc10b08e8577f" translate="yes" xml:space="preserve">
          <source>When setting this property, the maximum value is adjusted if necessary, to ensure that the range remains valid.</source>
          <target state="translated">在设置该属性时,必要时调整最大值,以保证范围内保持有效。</target>
        </trans-unit>
        <trans-unit id="b951c983b0aee73e158712980739ff70f149887e" translate="yes" xml:space="preserve">
          <source>When setting this property, the maximum value is adjusted if necessary, to ensure that the range remains valid. The value has to be greater than 0.</source>
          <target state="translated">在设置该属性时,必要时调整最大值,以确保该范围保持有效。该值必须大于0。</target>
        </trans-unit>
        <trans-unit id="7a55bcbc9be43eedc7805bdbb3ee9e54f14990ff" translate="yes" xml:space="preserve">
          <source>When setting this property, the minimum value is adjusted if necessary, to ensure that the range remains valid.</source>
          <target state="translated">设置该属性时,必要时调整最小值,以保证范围有效。</target>
        </trans-unit>
        <trans-unit id="c7876cf5d914de6fdd878ac65bed31fe69eb59c2" translate="yes" xml:space="preserve">
          <source>When setting this property, the minimum value is adjusted if necessary, to ensure that the range remains valid. The value has to be greater than 0.</source>
          <target state="translated">设置该属性时,必要时调整最小值,以确保范围保持有效。该值必须大于0。</target>
        </trans-unit>
        <trans-unit id="5cd6dbda7cf0ef9fd68544a0e1bb706ce0a9be68" translate="yes" xml:space="preserve">
          <source>When setting this property, the new &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; is converted to the timespec of the &lt;a href=&quot;qdatetimeedit&quot;&gt;QDateTimeEdit&lt;/a&gt;, which thus remains unchanged.</source>
          <target state="translated">当设置此属性，新&lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt;被转换成的的timespec &lt;a href=&quot;qdatetimeedit&quot;&gt;QDateTimeEdit&lt;/a&gt;，其因此保持不变。</target>
        </trans-unit>
        <trans-unit id="5de4dc53f812589029ed9067e97355562cb0e1d3" translate="yes" xml:space="preserve">
          <source>When setting up the rendering pipeline, call &lt;a href=&quot;qvulkanwindow#sampleCountFlagBits&quot;&gt;sampleCountFlagBits&lt;/a&gt;() to query the active sample count as a &lt;code&gt;VkSampleCountFlagBits&lt;/code&gt; value.</source>
          <target state="translated">设置渲染管道时，调用&lt;a href=&quot;qvulkanwindow#sampleCountFlagBits&quot;&gt;sampleCountFlagBits&lt;/a&gt;（）以 &lt;code&gt;VkSampleCountFlagBits&lt;/code&gt; 值查询活动样本计数。</target>
        </trans-unit>
        <trans-unit id="dfcd5a5c296c55f96b9ee5da99d93a616d2b11fc" translate="yes" xml:space="preserve">
          <source>When shaders were added to this program via &lt;a href=&quot;qopenglshaderprogram#addCacheableShaderFromSourceCode&quot;&gt;addCacheableShaderFromSourceCode&lt;/a&gt;() or &lt;a href=&quot;qopenglshaderprogram#addCacheableShaderFromSourceFile&quot;&gt;addCacheableShaderFromSourceFile&lt;/a&gt;(), program binaries are supported, and a cached binary is available on disk, actual compilation and linking are skipped. Instead, link() will initialize the program with the binary blob via glProgramBinary(). If there is no cached version of the program or it was generated with a different driver version, the shaders will be compiled from source and the program will get linked normally. This allows seamless upgrading of the graphics drivers, without having to worry about potentially incompatible binary formats.</source>
          <target state="translated">当通过&lt;a href=&quot;qopenglshaderprogram#addCacheableShaderFromSourceCode&quot;&gt;addCacheableShaderFromSourceCode&lt;/a&gt;（）或&lt;a href=&quot;qopenglshaderprogram#addCacheableShaderFromSourceFile&quot;&gt;addCacheableShaderFromSourceFile&lt;/a&gt;（）将着色器添加到此程序时，支持程序二进制文件，并且磁盘上有可用的缓存二进制文件，实际的编译和链接将被跳过。相反，link（）将通过glProgramBinary（）使用二进制Blob初始化程序。如果没有该程序的缓存版本，或者它是由其他驱动程序版本生成的，则将从源代码编译着色器，并且程序将正常链接。这样就可以无缝升级图形驱动程序，而不必担心潜在的不兼容二进制格式。</target>
        </trans-unit>
        <trans-unit id="87d3d39130885f5e5c6a9174de6513c3d33b6b27" translate="yes" xml:space="preserve">
          <source>When side-effects are unavoidable, ensure that the prior state is restored at the end of the test function, even if the test fails. This commonly requires use of an RAII (resource acquisition is initialization) class that restores state when the function returns, or a &lt;code&gt;cleanup()&lt;/code&gt; method. Do not simply put the restoration code at the end of the test. If part of the test fails, such code will be skipped and the prior state will not be restored.</source>
          <target state="translated">当不可避免的产生副作用时，即使测试失败，也请确保在测试功能结束时恢复先前的状态。这通常需要使用RAII（资源获取是初始化）类或 &lt;code&gt;cleanup()&lt;/code&gt; 方法，该类可在函数返回时恢复状态。不要简单地将恢复代码放在测试的结尾。如果部分测试失败，则将跳过此类代码，并且不会恢复先前的状态。</target>
        </trans-unit>
        <trans-unit id="64b2c21463a05b372aacfedaa2026900f87448ca" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; or &lt;a href=&quot;qabstractproxymodel&quot;&gt;QAbstractProxyModel&lt;/a&gt;, ensure that you emit &lt;a href=&quot;qabstractitemmodel#layoutAboutToBeChanged&quot;&gt;layoutAboutToBeChanged&lt;/a&gt;() before changing the order of items or altering the structure of the data you expose to views, and emit layoutChanged() after changing the layout.</source>
          <target state="translated">当对&lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt;或&lt;a href=&quot;qabstractproxymodel&quot;&gt;QAbstractProxyModel进行&lt;/a&gt;子类化时，请确保在更改项目顺序或更改要公开给视图的数据的结构之前发出&lt;a href=&quot;qabstractitemmodel#layoutAboutToBeChanged&quot;&gt;layoutAboutToBeChanged&lt;/a&gt;（），并在更改布局后发出layoutChanged（）。</target>
        </trans-unit>
        <trans-unit id="29ad4f995056d1ccd3dcee88f2d1086d0349dbfd" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt;, at the very least you must implement &lt;a href=&quot;qabstractitemmodel#index&quot;&gt;index&lt;/a&gt;(), &lt;a href=&quot;qabstractitemmodel#parent&quot;&gt;parent&lt;/a&gt;(), &lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount&lt;/a&gt;(), &lt;a href=&quot;qabstractitemmodel#columnCount&quot;&gt;columnCount&lt;/a&gt;(), and &lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt;(). These functions are used in all read-only models, and form the basis of editable models.</source>
          <target state="translated">子类化&lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel时&lt;/a&gt;，至少必须实现&lt;a href=&quot;qabstractitemmodel#index&quot;&gt;index&lt;/a&gt;（），&lt;a href=&quot;qabstractitemmodel#parent&quot;&gt;parent&lt;/a&gt;（），&lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount&lt;/a&gt;（），&lt;a href=&quot;qabstractitemmodel#columnCount&quot;&gt;columnCount&lt;/a&gt;（）和&lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt;（）。这些功能在所有只读模型中使用，并构成可编辑模型的基础。</target>
        </trans-unit>
        <trans-unit id="a191eed727edc2ae03b2ab93852a02163a6c05e0" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qabstractlistmodel&quot;&gt;QAbstractListModel&lt;/a&gt;, you must provide implementations of the &lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount&lt;/a&gt;() and &lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt;() functions. Well behaved models also provide a &lt;a href=&quot;qabstractitemmodel#headerData&quot;&gt;headerData&lt;/a&gt;() implementation.</source>
          <target state="translated">在子类化&lt;a href=&quot;qabstractlistmodel&quot;&gt;QAbstractListModel时&lt;/a&gt;，必须提供&lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount&lt;/a&gt;（）和&lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt;（）函数的实现。行为良好的模型还提供了&lt;a href=&quot;qabstractitemmodel#headerData&quot;&gt;headerData&lt;/a&gt;（）实现。</target>
        </trans-unit>
        <trans-unit id="34ee94bbac1ecea4e8ddb454d400be8aae1e7968" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qabstracttablemodel&quot;&gt;QAbstractTableModel&lt;/a&gt;, you must implement &lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount&lt;/a&gt;(), &lt;a href=&quot;qabstractitemmodel#columnCount&quot;&gt;columnCount&lt;/a&gt;(), and &lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt;(). Default implementations of the &lt;a href=&quot;qabstracttablemodel#index&quot;&gt;index&lt;/a&gt;() and &lt;a href=&quot;qabstractitemmodel#parent&quot;&gt;parent&lt;/a&gt;() functions are provided by &lt;a href=&quot;qabstracttablemodel&quot;&gt;QAbstractTableModel&lt;/a&gt;. Well behaved models will also implement &lt;a href=&quot;qabstractitemmodel#headerData&quot;&gt;headerData&lt;/a&gt;().</source>
          <target state="translated">在子类化&lt;a href=&quot;qabstracttablemodel&quot;&gt;QAbstractTableModel时&lt;/a&gt;，必须实现&lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount&lt;/a&gt;（），&lt;a href=&quot;qabstractitemmodel#columnCount&quot;&gt;columnCount&lt;/a&gt;（）和&lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt;（）。&lt;a href=&quot;qabstracttablemodel&quot;&gt;QAbstractTableModel&lt;/a&gt;提供了&lt;a href=&quot;qabstracttablemodel#index&quot;&gt;index&lt;/a&gt;（）和&lt;a href=&quot;qabstractitemmodel#parent&quot;&gt;parent&lt;/a&gt;（）函数的默认实现。行为良好的模型还将实现&lt;a href=&quot;qabstractitemmodel#headerData&quot;&gt;headerData&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="bc5ed4ae258b22a232b577325d7a45d5a74a6ae6" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qaccessibleactioninterface&quot;&gt;QAccessibleActionInterface&lt;/a&gt; you need to provide a list of &lt;a href=&quot;qaccessibleactioninterface#actionNames&quot;&gt;actionNames&lt;/a&gt; which is the primary means to discover the available actions. Action names are never localized. In order to present actions to the user there are two functions that need to return localized versions of the name and give a description of the action. For the predefined action names use &lt;a href=&quot;qaccessibleactioninterface#localizedActionName&quot;&gt;QAccessibleActionInterface::localizedActionName&lt;/a&gt;() and &lt;a href=&quot;qaccessibleactioninterface#localizedActionDescription&quot;&gt;QAccessibleActionInterface::localizedActionDescription&lt;/a&gt;() to return their localized counterparts.</source>
          <target state="translated">子类化&lt;a href=&quot;qaccessibleactioninterface&quot;&gt;QAccessibleActionInterface时，&lt;/a&gt;您需要提供&lt;a href=&quot;qaccessibleactioninterface#actionNames&quot;&gt;actionNames&lt;/a&gt;列表，这是发现可用操作的主要方法。操作名称永远不会本地化。为了向用户呈现操作，有两个函数需要返回名称的本地化版本并给出操作说明。对于预定义的动作名称，请使用&lt;a href=&quot;qaccessibleactioninterface#localizedActionName&quot;&gt;QAccessibleActionInterface :: localizedActionName&lt;/a&gt;（）和&lt;a href=&quot;qaccessibleactioninterface#localizedActionDescription&quot;&gt;QAccessibleActionInterface :: localizedActionDescription&lt;/a&gt;（）返回其本地化的对应名称。</target>
        </trans-unit>
        <trans-unit id="a25edef8cc00a94f017f1d9cbc6945550b8bf450" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt;, you must call QIODevice::seek() at the start of your function to ensure integrity with &lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt;'s built-in buffer.</source>
          <target state="translated">子类化&lt;a href=&quot;qiodevice&quot;&gt;QIODevice时&lt;/a&gt;，必须在函数开始时调用QIODevice :: seek（），以确保&lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt;的内置缓冲区的完整性。</target>
        </trans-unit>
        <trans-unit id="d195ef9dc4d6a9738e6783d4bc0696c9278d4ef4" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qitemdelegate&quot;&gt;QItemDelegate&lt;/a&gt; to create a delegate that displays items using a custom renderer, it is important to ensure that the delegate can render items suitably for all the required states; e.g. selected, disabled, checked. The documentation for the &lt;a href=&quot;qitemdelegate#paint&quot;&gt;paint&lt;/a&gt;() function contains some hints to show how this can be achieved.</source>
          <target state="translated">当将&lt;a href=&quot;qitemdelegate&quot;&gt;QItemDelegate&lt;/a&gt;子类化以创建使用自定义渲染器显示项目的委托时，重要的是要确保该委托可以针对所有所需状态适当地渲染项目。例如，选中，禁用，选中。&lt;a href=&quot;qitemdelegate#paint&quot;&gt;paint&lt;/a&gt;（）函数的文档包含一些提示，以显示如何实现此目的。</target>
        </trans-unit>
        <trans-unit id="bdfab8a00f506ea4624c5ba05bcfdffa0be88abb" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qlistwidgetitem&quot;&gt;QListWidgetItem&lt;/a&gt; to provide custom items, it is possible to define new types for them enabling them to be distinguished from standard items. For subclasses that require this feature, ensure that you call the base class constructor with a new type value equal to or greater than &lt;a href=&quot;qlistwidgetitem#ItemType-enum&quot;&gt;UserType&lt;/a&gt;, within</source>
          <target state="translated">当将&lt;a href=&quot;qlistwidgetitem&quot;&gt;QListWidgetItem&lt;/a&gt;子类化以提供自定义项目时，可以为它们定义新类型，从而使其能够与标准项目区分开。对于需要此功能的子类，请确保调用基类构造一个新的类型值等于或大于&lt;a href=&quot;qlistwidgetitem#ItemType-enum&quot;&gt;用户类型&lt;/a&gt;，内</target>
        </trans-unit>
        <trans-unit id="25983c5d275d61a5768d14102127d7627a6f2db7" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qstandarditem&quot;&gt;QStandardItem&lt;/a&gt; to provide custom items, it is possible to define new types for them so that they can be distinguished from the base class. The &lt;a href=&quot;qstandarditem#type&quot;&gt;type&lt;/a&gt;() function should be reimplemented to return a new type value equal to or greater than &lt;a href=&quot;qstandarditem#ItemType-enum&quot;&gt;UserType&lt;/a&gt;.</source>
          <target state="translated">当将&lt;a href=&quot;qstandarditem&quot;&gt;QStandardItem&lt;/a&gt;子类化以提供自定义项时，可以为其定义新类型，以便将它们与基类区分开。的&lt;a href=&quot;qstandarditem#type&quot;&gt;类型&lt;/a&gt;（）函数应当重新实现以返回一个新的类型值等于或大于&lt;a href=&quot;qstandarditem#ItemType-enum&quot;&gt;用户类型&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e6fbf6fe9133647e06d0faf1437cba6ca2cedd98" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qstandarditem&quot;&gt;QStandardItem&lt;/a&gt;, you can reimplement this function to provide &lt;a href=&quot;qstandarditemmodel&quot;&gt;QStandardItemModel&lt;/a&gt; with a factory that it can use to create new items on demand.</source>
          <target state="translated">子类化&lt;a href=&quot;qstandarditem&quot;&gt;QStandardItem时&lt;/a&gt;，可以重新实现此功能，以为&lt;a href=&quot;qstandarditemmodel&quot;&gt;QStandardItemModel&lt;/a&gt;提供一个工厂，该工厂可用于按需创建新项目。</target>
        </trans-unit>
        <trans-unit id="f2286413d50d08d040929b6ec39c68a3dddaf3c0" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qtablewidgetitem&quot;&gt;QTableWidgetItem&lt;/a&gt; to provide custom items, it is possible to define new types for them so that they can be distinguished from standard items. The constructors for subclasses that require this feature need to call the base class constructor with a new type value equal to or greater than &lt;a href=&quot;qtablewidgetitem#ItemType-enum&quot;&gt;UserType&lt;/a&gt;.</source>
          <target state="translated">将&lt;a href=&quot;qtablewidgetitem&quot;&gt;QTableWidgetItem&lt;/a&gt;子类化以提供自定义项时，可以为其定义新类型，以便将它们与标准项区分开。需要此功能的子类的构造函数需要使用等于或大于&lt;a href=&quot;qtablewidgetitem#ItemType-enum&quot;&gt;UserType&lt;/a&gt;的新类型值来调用基类构造函数。</target>
        </trans-unit>
        <trans-unit id="1002dc2f9f72071b49f3bc6989364ec60eb22d54" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qtreewidgetitem&quot;&gt;QTreeWidgetItem&lt;/a&gt; to provide custom items, it is possible to define new types for them so that they can be distinguished from standard items. The constructors for subclasses that require this feature need to call the base class constructor with a new type value equal to or greater than &lt;a href=&quot;qtreewidgetitem#ItemType-enum&quot;&gt;UserType&lt;/a&gt;.</source>
          <target state="translated">当将&lt;a href=&quot;qtreewidgetitem&quot;&gt;QTreeWidgetItem&lt;/a&gt;子类化以提供自定义项目时，可以为其定义新类型，以便将它们与标准项目区分开。需要此功能的子类的构造函数需要使用等于或大于&lt;a href=&quot;qtreewidgetitem#ItemType-enum&quot;&gt;UserType&lt;/a&gt;的新类型值来调用基类构造函数。</target>
        </trans-unit>
        <trans-unit id="59520faecedf14305609ce71b43c92f419907198" translate="yes" xml:space="preserve">
          <source>When subclassing QAbstractItemModel, at the very least you must implement &lt;a href=&quot;qabstractitemmodel#index&quot;&gt;index&lt;/a&gt;(), &lt;a href=&quot;qabstractitemmodel#parent&quot;&gt;parent&lt;/a&gt;(), &lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount&lt;/a&gt;(), &lt;a href=&quot;qabstractitemmodel#columnCount&quot;&gt;columnCount&lt;/a&gt;(), and &lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt;(). These functions are used in all read-only models, and form the basis of editable models.</source>
          <target state="translated">子类化QAbstractItemModel时，至少必须实现&lt;a href=&quot;qabstractitemmodel#index&quot;&gt;index&lt;/a&gt;（），&lt;a href=&quot;qabstractitemmodel#parent&quot;&gt;parent&lt;/a&gt;（），&lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount&lt;/a&gt;（），&lt;a href=&quot;qabstractitemmodel#columnCount&quot;&gt;columnCount&lt;/a&gt;（）和&lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt;（）。这些功能在所有只读模型中都使用，并且构成了可编辑模型的基础。</target>
        </trans-unit>
        <trans-unit id="3699b269f018546bac2b237f4b1ba2d9ba58cd5a" translate="yes" xml:space="preserve">
          <source>When subclassing QAbstractListModel, you must provide implementations of the &lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount&lt;/a&gt;() and &lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt;() functions. Well behaved models also provide a &lt;a href=&quot;qabstractitemmodel#headerData&quot;&gt;headerData&lt;/a&gt;() implementation.</source>
          <target state="translated">在子类化QAbstractListModel时，必须提供&lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount&lt;/a&gt;（）和&lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt;（）函数的实现。行为良好的模型还提供了&lt;a href=&quot;qabstractitemmodel#headerData&quot;&gt;headerData&lt;/a&gt;（）实现。</target>
        </trans-unit>
        <trans-unit id="b1062aef636e41c878017026955b733a82f0e58d" translate="yes" xml:space="preserve">
          <source>When subclassing QAbstractTableModel, you must implement &lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount&lt;/a&gt;(), &lt;a href=&quot;qabstractitemmodel#columnCount&quot;&gt;columnCount&lt;/a&gt;(), and &lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt;(). Default implementations of the &lt;a href=&quot;qabstracttablemodel#index&quot;&gt;index&lt;/a&gt;() and &lt;a href=&quot;qabstractitemmodel#parent&quot;&gt;parent&lt;/a&gt;() functions are provided by QAbstractTableModel. Well behaved models will also implement &lt;a href=&quot;qabstractitemmodel#headerData&quot;&gt;headerData&lt;/a&gt;().</source>
          <target state="translated">子类化QAbstractTableModel时，必须实现&lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount&lt;/a&gt;（），&lt;a href=&quot;qabstractitemmodel#columnCount&quot;&gt;columnCount&lt;/a&gt;（）和&lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt;（）。QAbstractTableModel提供了&lt;a href=&quot;qabstracttablemodel#index&quot;&gt;index&lt;/a&gt;（）和&lt;a href=&quot;qabstractitemmodel#parent&quot;&gt;parent&lt;/a&gt;（）函数的默认实现。行为良好的模型还将实现&lt;a href=&quot;qabstractitemmodel#headerData&quot;&gt;headerData&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="26b79d67e5a46121dc5b166539f6602a7e665200" translate="yes" xml:space="preserve">
          <source>When subclassing QAccessibleActionInterface you need to provide a list of &lt;a href=&quot;qaccessibleactioninterface#actionNames&quot;&gt;actionNames&lt;/a&gt; which is the primary means to discover the available actions. Action names are never localized. In order to present actions to the user there are two functions that need to return localized versions of the name and give a description of the action. For the predefined action names use &lt;a href=&quot;qaccessibleactioninterface#localizedActionName&quot;&gt;QAccessibleActionInterface::localizedActionName&lt;/a&gt;() and &lt;a href=&quot;qaccessibleactioninterface#localizedActionDescription&quot;&gt;QAccessibleActionInterface::localizedActionDescription&lt;/a&gt;() to return their localized counterparts.</source>
          <target state="translated">子类化QAccessibleActionInterface时，您需要提供&lt;a href=&quot;qaccessibleactioninterface#actionNames&quot;&gt;actionNames&lt;/a&gt;列表，这是发现可用操作的主要方法。操作名称永远不会本地化。为了向用户呈现操作，有两个函数需要返回名称的本地化版本并给出操作的描述。对于预定义的动作名称，请使用&lt;a href=&quot;qaccessibleactioninterface#localizedActionName&quot;&gt;QAccessibleActionInterface :: localizedActionName&lt;/a&gt;（）和&lt;a href=&quot;qaccessibleactioninterface#localizedActionDescription&quot;&gt;QAccessibleActionInterface :: localizedActionDescription&lt;/a&gt;（）返回其本地化的对应名称。</target>
        </trans-unit>
        <trans-unit id="1fd6e4c37e600fd73592fb3b27ecd0ad7ca47a17" translate="yes" xml:space="preserve">
          <source>When subclassing QItemDelegate to create a delegate that displays items using a custom renderer, it is important to ensure that the delegate can render items suitably for all the required states; e.g. selected, disabled, checked. The documentation for the &lt;a href=&quot;qitemdelegate#paint&quot;&gt;paint&lt;/a&gt;() function contains some hints to show how this can be achieved.</source>
          <target state="translated">当将QItemDelegate子类化以创建使用自定义渲染器显示项目的委托时，重要的是要确保该委托可以针对所有所需状态适当地渲染项目。例如，选中，禁用，选中。&lt;a href=&quot;qitemdelegate#paint&quot;&gt;paint&lt;/a&gt;（）函数的文档包含一些提示，以显示如何实现此目的。</target>
        </trans-unit>
        <trans-unit id="9e0f5aa88b44938c261cc9eef6f6e4a41afa7675" translate="yes" xml:space="preserve">
          <source>When subclassing QListWidgetItem to provide custom items, it is possible to define new types for them enabling them to be distinguished from standard items. For subclasses that require this feature, ensure that you call the base class constructor with a new type value equal to or greater than &lt;a href=&quot;qlistwidgetitem#ItemType-enum&quot;&gt;UserType&lt;/a&gt;, within</source>
          <target state="translated">当将QListWidgetItem子类化以提供自定义项目时，可以为它们定义新类型，从而使其能够与标准项目区分开。对于需要此功能的子类，请确保调用基类构造一个新的类型值等于或大于&lt;a href=&quot;qlistwidgetitem#ItemType-enum&quot;&gt;用户类型&lt;/a&gt;，内</target>
        </trans-unit>
        <trans-unit id="72aca5e914ed9fefcaccb35499bea805b895d281" translate="yes" xml:space="preserve">
          <source>When subclassing QStandardItem to provide custom items, it is possible to define new types for them so that they can be distinguished from the base class. The &lt;a href=&quot;qstandarditem#type&quot;&gt;type&lt;/a&gt;() function should be reimplemented to return a new type value equal to or greater than &lt;a href=&quot;qstandarditem#ItemType-enum&quot;&gt;UserType&lt;/a&gt;.</source>
          <target state="translated">当将QStandardItem子类化以提供自定义项时，可以为它们定义新的类型，以便可以将它们与基类区分开。的&lt;a href=&quot;qstandarditem#type&quot;&gt;类型&lt;/a&gt;（）函数应当重新实现以返回一个新的类型值等于或大于&lt;a href=&quot;qstandarditem#ItemType-enum&quot;&gt;用户类型&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="42b0b4032d93d4857496512b038b0674cfd26f89" translate="yes" xml:space="preserve">
          <source>When subclassing QTableWidgetItem to provide custom items, it is possible to define new types for them so that they can be distinguished from standard items. The constructors for subclasses that require this feature need to call the base class constructor with a new type value equal to or greater than &lt;a href=&quot;qtablewidgetitem#ItemType-enum&quot;&gt;UserType&lt;/a&gt;.</source>
          <target state="translated">当将QTableWidgetItem子类化以提供自定义项时，可以为其定义新类型，以便将它们与标准项区分开。需要此功能的子类的构造函数需要使用等于或大于&lt;a href=&quot;qtablewidgetitem#ItemType-enum&quot;&gt;UserType&lt;/a&gt;的新类型值来调用基类构造函数。</target>
        </trans-unit>
        <trans-unit id="3a47ebf3a47f4b0b127eba34804babe9e0cf37bc" translate="yes" xml:space="preserve">
          <source>When subclassing QTreeWidgetItem to provide custom items, it is possible to define new types for them so that they can be distinguished from standard items. The constructors for subclasses that require this feature need to call the base class constructor with a new type value equal to or greater than &lt;a href=&quot;qtreewidgetitem#ItemType-enum&quot;&gt;UserType&lt;/a&gt;.</source>
          <target state="translated">当将QTreeWidgetItem子类化以提供自定义项目时，可以为其定义新类型，以便将它们与标准项目区分开。需要此功能的子类的构造函数需要使用等于或大于&lt;a href=&quot;qtreewidgetitem#ItemType-enum&quot;&gt;UserType&lt;/a&gt;的新类型值来调用基类构造函数。</target>
        </trans-unit>
        <trans-unit id="706f7b1df0260af3c55347db3db3d7c9292cb895" translate="yes" xml:space="preserve">
          <source>When successful, the pointer to this &lt;a href=&quot;qvulkaninstance&quot;&gt;QVulkanInstance&lt;/a&gt; is retrievable via the static function current().</source>
          <target state="translated">成功后，可通过静态函数current（）检索此&lt;a href=&quot;qvulkaninstance&quot;&gt;QVulkanInstance&lt;/a&gt;的指针。</target>
        </trans-unit>
        <trans-unit id="52f02029e2dd95fea6c58bc7c6dd438e3036694c" translate="yes" xml:space="preserve">
          <source>When successful, the returned pointer is either a direct pointer to an interface (and can be cast, for example, to &lt;code&gt;ID3D12Device *&lt;/code&gt;) or a pointer to an opaque handle that needs to be dereferenced first (for example, &lt;code&gt;VkDevice dev = *static_cast&amp;lt;VkDevice *&amp;gt;(result)&lt;/code&gt;). The latter is necessary since such handles may have sizes different from a pointer.</source>
          <target state="translated">成功后，返回的指针可以是指向接口的直接指针（例如，可以 &lt;code&gt;ID3D12Device *&lt;/code&gt; 为ID3D12Device *），也可以指向需要首先取消引用的不透明句柄的指针（例如， &lt;code&gt;VkDevice dev = *static_cast&amp;lt;VkDevice *&amp;gt;(result)&lt;/code&gt; ）。后者是必需的，因为此类句柄的大小可能不同于指针。</target>
        </trans-unit>
        <trans-unit id="6a402a0ed822ea8251e3c7b0324b6fe2e26b6b26" translate="yes" xml:space="preserve">
          <source>When successful, the returned pointer is either a direct pointer to an interface, or a pointer to an opaque handle that needs to be dereferenced first (for example, &lt;code&gt;VkDevice dev = *static_cast&amp;lt;VkDevice *&amp;gt;(result)&lt;/code&gt;). The latter is necessary since such handles may have sizes different from a pointer.</source>
          <target state="translated">成功后，返回的指针要么是指向接口的直接指针，要么是指向首先需要取消引用的不透明句柄的指针（例如， &lt;code&gt;VkDevice dev = *static_cast&amp;lt;VkDevice *&amp;gt;(result)&lt;/code&gt; ）。后者是必需的，因为此类句柄的大小可能不同于指针。</target>
        </trans-unit>
        <trans-unit id="a17d1a89a27b012ae83e8f31b7d65d34068e4f39" translate="yes" xml:space="preserve">
          <source>When supported by the implementation of the underlying graphics API at run time, images can also be supplied in compressed texture files. The content must be a simple RGB(A) format 2D texture. Supported compression schemes are only limited by the underlying driver and GPU. The following container file formats are supported:</source>
          <target state="translated">当运行时底层图形API的实现支持时,也可以在压缩的纹理文件中提供图像。内容必须是简单的RGB(A)格式的2D纹理。支持的压缩方案仅受底层驱动程序和GPU的限制。支持以下容器文件格式。</target>
        </trans-unit>
        <trans-unit id="b61533f5bfe4f41a281b6739619bbe40223b42c1" translate="yes" xml:space="preserve">
          <source>When supported, the spot metering point is the (normalized) position of the point of the image where exposure metering will be performed. This is typically used to indicate an &quot;interesting&quot; area of the image that should be exposed properly.</source>
          <target state="translated">当支持时,点测光点是将执行曝光测光的图像点的(标准化)位置。这通常用于指示图像中应该正确曝光的 &quot;有趣 &quot;区域。</target>
        </trans-unit>
        <trans-unit id="ac6596f61ffb518b7cc53fdaa21ca7ddbe003ebf" translate="yes" xml:space="preserve">
          <source>When suspended, you can resume or cancel the awaiting computation:</source>
          <target state="translated">暂停时,你可以恢复或取消等待的计算。</target>
        </trans-unit>
        <trans-unit id="5f88abce90e32dce271b35e9107fb601ec017c62" translate="yes" xml:space="preserve">
          <source>When switching application styles, the color palette is set back to the initial colors or the system defaults. This is necessary since certain styles have to adapt the color palette to be fully style-guide compliant.</source>
          <target state="translated">当切换应用程序样式时,调色板会被设置回初始颜色或系统默认值。这是很有必要的,因为某些样式必须调整调色板才能完全符合样式指南。</target>
        </trans-unit>
        <trans-unit id="67873ce37a5513b0e5ae88b75e6f033ba8bb99f4" translate="yes" xml:space="preserve">
          <source>When tabsClosable is set to true a close button will appear on the tab on either the left or right hand side depending upon the style. When the button is clicked the tab the signal &lt;a href=&quot;qtabbar#tabCloseRequested&quot;&gt;tabCloseRequested&lt;/a&gt; will be emitted.</source>
          <target state="translated">当tabsClosable设置为true时，根据样式的不同，关闭按钮将出现在左侧或右侧的标签上。单击按钮时，将发出信号&lt;a href=&quot;qtabbar#tabCloseRequested&quot;&gt;tabClos​​eRequested&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="edd34e00a0649a39928db867a61af0bdd3698a54" translate="yes" xml:space="preserve">
          <source>When talking about version support on macOS, it's important to distinguish between the &lt;a href=&quot;#build-environment&quot;&gt;build environment&lt;/a&gt;; the platform you're building on or with, and the &lt;a href=&quot;#target-platforms&quot;&gt;target platforms&lt;/a&gt;; the platforms you are building for. The following macOS versions are supported.</source>
          <target state="translated">当谈到macOS上的版本支持时，重要的是要区分&lt;a href=&quot;#build-environment&quot;&gt;构建环境&lt;/a&gt;；您在其上或与其一起构建的平台以及&lt;a href=&quot;#target-platforms&quot;&gt;目标平台&lt;/a&gt;；您要构建的平台。支持以下macOS版本。</target>
        </trans-unit>
        <trans-unit id="46e5a0bd94336c26034fab948fd2202518bbe3a7" translate="yes" xml:space="preserve">
          <source>When talking about version support on macOS, it's important to distinguish between the &lt;a href=&quot;macos#build-environment&quot;&gt;build environment&lt;/a&gt;; the platform you're building on or with, and the &lt;a href=&quot;macos#target-platforms&quot;&gt;target platforms&lt;/a&gt;; the platforms you are building for. The following macOS versions are supported.</source>
          <target state="translated">当谈到macOS上的版本支持时，重要的是要区分&lt;a href=&quot;macos#build-environment&quot;&gt;构建环境&lt;/a&gt;；您在其上或与其一起构建的平台以及&lt;a href=&quot;macos#target-platforms&quot;&gt;目标平台&lt;/a&gt;；您要构建的平台。支持以下macOS版本。</target>
        </trans-unit>
        <trans-unit id="12b09dba91f90a77f1c0f316bc1593767614f52d" translate="yes" xml:space="preserve">
          <source>When targeting the default render target, the &lt;code&gt;rasterizationSamples&lt;/code&gt; field of &lt;code&gt;VkPipelineMultisampleStateCreateInfo&lt;/code&gt; must be set to this value.</source>
          <target state="translated">以默认渲染目标为目标时，必须将 &lt;code&gt;VkPipelineMultisampleStateCreateInfo&lt;/code&gt; 的 &lt;code&gt;rasterizationSamples&lt;/code&gt; 字段设置为此值。</target>
        </trans-unit>
        <trans-unit id="01a0c4cf5ca0b1b36842c832e9f49ed747142008" translate="yes" xml:space="preserve">
          <source>When testing classes that change their state based on timer events, the timer-based behavior needs to be taken into account when performing verification steps. Due to the variety of timing-dependent behavior, there is no single generic solution to this testing problem.</source>
          <target state="translated">当测试基于定时器事件改变状态的类时,在执行验证步骤时需要考虑到基于定时器的行为。由于依赖于定时器的行为多种多样,没有一个通用的解决方案来解决这个测试问题。</target>
        </trans-unit>
        <trans-unit id="977796166650ef7b381034a2e5ab66d22d9fde20" translate="yes" xml:space="preserve">
          <source>When text is selected this signal will be emitted with</source>
          <target state="translated">当文本被选中时,该信号将以如下方式发出</target>
        </trans-unit>
        <trans-unit id="55f3e3f1e06a97818ce0ffb33865599309fb29ae" translate="yes" xml:space="preserve">
          <source>When the</source>
          <target state="translated">当</target>
        </trans-unit>
        <trans-unit id="277e96c69a29982435c9191c9b7dc60d6543c8df" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qcombobox&quot;&gt;QComboBox&lt;/a&gt; is editable, use &lt;a href=&quot;qlineedit#placeholderText-prop&quot;&gt;QLineEdit::setPlaceholderText&lt;/a&gt;() instead.</source>
          <target state="translated">当&lt;a href=&quot;qcombobox&quot;&gt;QComboBox&lt;/a&gt;是可编辑的时，请改用&lt;a href=&quot;qlineedit#placeholderText-prop&quot;&gt;QLineEdit :: setPlaceholderText&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="96148eaf4c167de1a5cc9cb151bbca87c607e4e7" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qlogvalue3daxisformatter#base-prop&quot;&gt;base&lt;/a&gt; property value is non-zero, the whole axis range is often not equally divided into segments. The first and last segments are often smaller than the other segments. In extreme cases, this can lead to overlapping labels on the first and last two grid lines. By setting this property to &lt;code&gt;false&lt;/code&gt;, you can suppress showing the minimum and maximum labels for the axis in cases where the segments do not exactly fit the axis. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">当&lt;a href=&quot;qlogvalue3daxisformatter#base-prop&quot;&gt;基本&lt;/a&gt;属性值不为零时，整个轴范围通常不均等地划分为多个段。第一部分和最后一部分通常小于其他部分。在极端情况下，这可能导致前两条网格线上的标签重叠。通过将此属性设置为 &lt;code&gt;false&lt;/code&gt; ，可以在段不完全适合轴的情况下禁止显示该轴的最小和最大标签。默认为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fcebf5705064ce0455ad2b9bec751e51c083ccf2" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qml-qt3d-render-pointsize#sizeMode-prop&quot;&gt;sizeMode&lt;/a&gt; property is set to SizeMode::Fixed, the value is set using glPointSize(), if available. When using SizeMode::Programmable, gl_PointSize must be set within shader programs, the value provided to this &lt;a href=&quot;qml-qt3d-render-renderstate&quot;&gt;RenderState&lt;/a&gt; is ignored in that case.</source>
          <target state="translated">当&lt;a href=&quot;qml-qt3d-render-pointsize#sizeMode-prop&quot;&gt;sizeMode&lt;/a&gt;属性设置为SizeMode :: Fixed时，使用glPointSize（）设置该值（如果可用）。使用SizeMode :: Programmable时，必须在着色器程序中设置gl_PointSize，在这种情况下，将忽略提供给此&lt;a href=&quot;qml-qt3d-render-renderstate&quot;&gt;RenderState&lt;/a&gt;的值。</target>
        </trans-unit>
        <trans-unit id="01c131bddcc8fa92f9f3b0a589fa47980eb2d439" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qml-qt3d-render-pointsize#sizeMode-prop&quot;&gt;sizeMode&lt;/a&gt; property is set to SizeMode::Fixed, the value is set using glPointSize(), if available. When using SizeMode::Programmable, gl_PointSize must be set within shader programs, the value provided to this &lt;a href=&quot;qml-renderstate&quot;&gt;RenderState&lt;/a&gt; is ignored in that case.</source>
          <target state="translated">当&lt;a href=&quot;qml-qt3d-render-pointsize#sizeMode-prop&quot;&gt;sizeMode&lt;/a&gt;属性设置为SizeMode :: Fixed时，使用glPointSize（）设置该值（如果可用）。使用SizeMode :: Programmable时，必须在着色器程序中设置gl_PointSize，在这种情况下，将忽略提供给此&lt;a href=&quot;qml-renderstate&quot;&gt;RenderState&lt;/a&gt;的值。</target>
        </trans-unit>
        <trans-unit id="31b0eaa228f2b88891ce3db774ff73a70a98110c" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qml-qtdatavisualization-logvalueaxis3dformatter#base-prop&quot;&gt;base&lt;/a&gt; property value is non-zero, the whole axis range is often not equally divided into segments. The first and last segments are often smaller than the other segments. In extreme cases, this can lead to overlapping labels on the first and last two grid lines. By setting this property to &lt;code&gt;false&lt;/code&gt;, you can suppress showing the minimum and maximum labels for the axis in cases where the segments do not exactly fit the axis. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">当&lt;a href=&quot;qml-qtdatavisualization-logvalueaxis3dformatter#base-prop&quot;&gt;基本&lt;/a&gt;属性值不为零时，整个轴范围通常不均等地划分为多个段。第一部分和最后一部分通常小于其他部分。在极端情况下，这可能导致前两条网格线上的标签重叠。通过将此属性设置为 &lt;code&gt;false&lt;/code&gt; ，可以在段不完全适合轴的情况下禁止显示该轴的最小和最大标签。默认为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="987fec2f0c2c258849a742c9e14f0174fef55ec2" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qml-qtpositioning-positionsource&quot;&gt;PositionSource&lt;/a&gt; is active, position updates can be retrieved either by simply using the &lt;a href=&quot;qml-qtpositioning-positionsource#position-prop&quot;&gt;position&lt;/a&gt; property in a binding (as the value of another item's property), or by providing an implementation of the &lt;code&gt;onPositionChanged&lt;/code&gt; signal-handler.</source>
          <target state="translated">当&lt;a href=&quot;qml-qtpositioning-positionsource&quot;&gt;PositionSource&lt;/a&gt;处于活动状态时，可以通过简单地在绑定中使用&lt;a href=&quot;qml-qtpositioning-positionsource#position-prop&quot;&gt;position&lt;/a&gt;属性（作为另一个项目的属性的值）或提供 &lt;code&gt;onPositionChanged&lt;/code&gt; 信号处理程序的实现来检索位置更新。</target>
        </trans-unit>
        <trans-unit id="d6b06a8b392f311abc92743e16b8eaf852385858" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qml-qtquick-controls-stackview&quot;&gt;StackView&lt;/a&gt; needs a new transition, it first calls &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#getTransition-method&quot;&gt;StackViewDelegate.getTransition()&lt;/a&gt;. The base implementation of this function just looks for a property named &lt;code&gt;properties.name&lt;/code&gt; inside itself (root), which is how it finds &lt;code&gt;property Component pushTransition&lt;/code&gt; in the examples above.</source>
          <target state="translated">当&lt;a href=&quot;qml-qtquick-controls-stackview&quot;&gt;StackView&lt;/a&gt;需要新的过渡时，它首先调用&lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#getTransition-method&quot;&gt;StackViewDelegate.getTransition（）&lt;/a&gt;。该函数的基本实现只是在自身（根）中查找一个名为 &lt;code&gt;properties.name&lt;/code&gt; 的属性，这就是它在上面的示例中查找 &lt;code&gt;property Component pushTransition&lt;/code&gt; 的方式。</target>
        </trans-unit>
        <trans-unit id="13b2463be39cc72e16c7d4ca58b0c4d0edaade26" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qml-qtquick-flickable#boundsMovement-prop&quot;&gt;boundsMovement&lt;/a&gt; is &lt;code&gt;Flickable.FollowBoundsBehavior&lt;/code&gt;, a value other than &lt;code&gt;Flickable.StopAtBounds&lt;/code&gt; will give a feeling that the edges of the view are soft, rather than a hard physical boundary.</source>
          <target state="translated">当&lt;a href=&quot;qml-qtquick-flickable#boundsMovement-prop&quot;&gt;boundsMovement&lt;/a&gt;为 &lt;code&gt;Flickable.FollowBoundsBehavior&lt;/code&gt; 时，除 &lt;code&gt;Flickable.StopAtBounds&lt;/code&gt; 以外的其他值将给人一种感觉，即视图的边缘是柔软的，而不是硬的物理边界。</target>
        </trans-unit>
        <trans-unit id="bdd086e0b6a8d49e2b2713bf9ea24b942d740d18" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qml-qtquick-mousearea&quot;&gt;MouseArea&lt;/a&gt; is clicked, &lt;code&gt;fruitModel&lt;/code&gt; will have two roles,</source>
          <target state="translated">当&lt;a href=&quot;qml-qtquick-mousearea&quot;&gt;鼠标区域&lt;/a&gt;被点击时， &lt;code&gt;fruitModel&lt;/code&gt; 将有两个角色，</target>
        </trans-unit>
        <trans-unit id="531648fe487a96145ce0801a6bc88b47ddc3d5fa" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qml-qtquick-text&quot;&gt;Text&lt;/a&gt; object refers to its &lt;a href=&quot;qml-qtquick-item#parent-prop&quot;&gt;parent&lt;/a&gt; value in the above code, it is referring to its</source>
          <target state="translated">当上面的代码中&lt;a href=&quot;qml-qtquick-text&quot;&gt;Text&lt;/a&gt;对象引用&lt;a href=&quot;qml-qtquick-item#parent-prop&quot;&gt;其父&lt;/a&gt;值时，它就是引用其父对象</target>
        </trans-unit>
        <trans-unit id="cfbd43c514e575cbd44c06a9f1befeb8fbc6aa47" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qml-qtquick-virtualkeyboard-keyboardlayoutloader&quot;&gt;KeyboardLayoutLoader&lt;/a&gt; is used as a root item of a keyboard layout, the actual keyboard layouts are wrapped inside Component elements. The keyboard layout is activated by assigning the id of an active component to the sourceComponent property.</source>
          <target state="translated">当&lt;a href=&quot;qml-qtquick-virtualkeyboard-keyboardlayoutloader&quot;&gt;KeyboardLayoutLoader&lt;/a&gt;用作键盘布局的根项目时，实际的键盘布局将包装在Component元素内。通过将活动组件的ID分配给sourceComponent属性来激活键盘布局。</target>
        </trans-unit>
        <trans-unit id="f043241c3f7cc581207444dcc1dc86dbdeb3ef7b" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt; is clicked, the console prints,</source>
          <target state="translated">当&lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt;被点击时，控制台打印，</target>
        </trans-unit>
        <trans-unit id="d450f4ff62c8dd3eda6ad3d118faffcc34e07662" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qqmlengine&quot;&gt;QQmlEngine&lt;/a&gt; instantiates a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;, the context is set automatically.</source>
          <target state="translated">当&lt;a href=&quot;qqmlengine&quot;&gt;QQmlEngine&lt;/a&gt;实例化&lt;a href=&quot;qobject&quot;&gt;QObject时&lt;/a&gt;，将自动设置上下文。</target>
        </trans-unit>
        <trans-unit id="1a3ec88b091fae5c593926fbff02a507863cf15b" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qsensor#axesOrientationMode-prop&quot;&gt;axesOrientationMode&lt;/a&gt; property is set to &lt;a href=&quot;qsensor#AxesOrientationMode-enum&quot;&gt;UserOrientation&lt;/a&gt;, the angle for rotating the reading values is taken from this property. In other modes, the property has no effect.</source>
          <target state="translated">当&lt;a href=&quot;qsensor#axesOrientationMode-prop&quot;&gt;axesOrientationMode&lt;/a&gt;属性设置为&lt;a href=&quot;qsensor#AxesOrientationMode-enum&quot;&gt;UserOrientation时&lt;/a&gt;，从该属性获取旋转读数值的角度。在其他模式下，该属性无效。</target>
        </trans-unit>
        <trans-unit id="f8b6764b784c8d16407b8358832df499fd592a45" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qsgmaterial&quot;&gt;QSGMaterial&lt;/a&gt; reports &lt;a href=&quot;qsgmaterial#Flag-enum&quot;&gt;SupportsRhiShader&lt;/a&gt; in &lt;a href=&quot;qsgmaterial#flags&quot;&gt;flags&lt;/a&gt;(), the scene graph may request a &lt;a href=&quot;qsgmaterialrhishader&quot;&gt;QSGMaterialRhiShader&lt;/a&gt; instead of &lt;a href=&quot;qsgmaterialshader&quot;&gt;QSGMaterialShader&lt;/a&gt;. This is indicated by having the &lt;a href=&quot;qsgmaterial#Flag-enum&quot;&gt;RhiShaderWanted&lt;/a&gt; flag set. In this case the return value must be a QSGRhiMaterialShader subclass.</source>
          <target state="translated">当&lt;a href=&quot;qsgmaterial&quot;&gt;QSGMaterial&lt;/a&gt;在&lt;a href=&quot;qsgmaterial#flags&quot;&gt;标志&lt;/a&gt;（）中报告&lt;a href=&quot;qsgmaterial#Flag-enum&quot;&gt;SupportsRhiShader&lt;/a&gt;时，场景图可能会请求&lt;a href=&quot;qsgmaterialrhishader&quot;&gt;QSGMaterialRhiShader&lt;/a&gt;而不是&lt;a href=&quot;qsgmaterialshader&quot;&gt;QSGMaterialShader&lt;/a&gt;。通过设置&lt;a href=&quot;qsgmaterial#Flag-enum&quot;&gt;RhiShaderWanted&lt;/a&gt;标志可以表明这一点。在这种情况下，返回值必须是QSGRhiMaterialShader子类。</target>
        </trans-unit>
        <trans-unit id="3ec06e7607af8f8760e7b965130ca0af1c7c4afa" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qt#PenJoinStyle-enum&quot;&gt;Qt::MiterJoin&lt;/a&gt; style is applied, it is possible to use the &lt;a href=&quot;qpen#setMiterLimit&quot;&gt;setMiterLimit&lt;/a&gt;() function to specify how far the miter join can extend from the join point. The &lt;a href=&quot;qpen#miterLimit&quot;&gt;miterLimit&lt;/a&gt;() is used to reduce artifacts between line joins where the lines are close to parallel.</source>
          <target state="translated">当应用&lt;a href=&quot;qt#PenJoinStyle-enum&quot;&gt;Qt :: MiterJoin&lt;/a&gt;样式时，可以使用&lt;a href=&quot;qpen#setMiterLimit&quot;&gt;setMiterLimit&lt;/a&gt;（）函数指定斜接连接可以从连接点延伸多远。的&lt;a href=&quot;qpen#miterLimit&quot;&gt;miterLimit分别&lt;/a&gt;（）是用来减少线之间的工件连接，其中线是接近平行。</target>
        </trans-unit>
        <trans-unit id="8cff9e77f59469425f8797ff7538a94cb9830def" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qt3drender-qpointsize#sizeMode-prop&quot;&gt;sizeMode&lt;/a&gt; property is set to SizeMode::Fixed, the value is set using glPointSize(), if available. When using SizeMode::Programmable, gl_PointSize must be set within shader programs, the value provided to this &lt;a href=&quot;qml-qt3d-render-renderstate&quot;&gt;RenderState&lt;/a&gt; is ignored in that case.</source>
          <target state="translated">当&lt;a href=&quot;qt3drender-qpointsize#sizeMode-prop&quot;&gt;sizeMode&lt;/a&gt;属性设置为SizeMode :: Fixed时，使用glPointSize（）设置该值（如果可用）。使用SizeMode :: Programmable时，必须在着色器程序中设置gl_PointSize，在这种情况下，将忽略提供给此&lt;a href=&quot;qml-qt3d-render-renderstate&quot;&gt;RenderState&lt;/a&gt;的值。</target>
        </trans-unit>
        <trans-unit id="8109269e175dc39675b846ed563d3f286803d82a" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qt3drender-qpointsize#sizeMode-prop&quot;&gt;sizeMode&lt;/a&gt; property is set to SizeMode::Fixed, the value is set using glPointSize(), if available. When using SizeMode::Programmable, gl_PointSize must be set within shader programs, the value provided to this &lt;a href=&quot;qml-renderstate&quot;&gt;RenderState&lt;/a&gt; is ignored in that case.</source>
          <target state="translated">当&lt;a href=&quot;qt3drender-qpointsize#sizeMode-prop&quot;&gt;sizeMode&lt;/a&gt;属性设置为SizeMode :: Fixed时，使用glPointSize（）设置该值（如果可用）。使用SizeMode :: Programmable时，必须在着色器程序中设置gl_PointSize，在这种情况下，将忽略提供给此&lt;a href=&quot;qml-renderstate&quot;&gt;RenderState&lt;/a&gt;的值。</target>
        </trans-unit>
        <trans-unit id="ef51d747b8fb0e1aaf24623fb2724ee2f97056ec" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qtoolbutton&quot;&gt;QToolButton&lt;/a&gt; displays arrows, the &lt;a href=&quot;#up-arrow-sub&quot;&gt;::up-arrow&lt;/a&gt;, &lt;a href=&quot;#down-arrow-sub&quot;&gt;::down-arrow&lt;/a&gt;, &lt;a href=&quot;#left-arrow-sub&quot;&gt;::left-arrow&lt;/a&gt; and &lt;a href=&quot;#right-arrow-sub&quot;&gt;::right-arrow&lt;/a&gt; subcontrols are used.</source>
          <target state="translated">当&lt;a href=&quot;qtoolbutton&quot;&gt;QToolButton&lt;/a&gt;显示箭头时，将使用&lt;a href=&quot;#up-arrow-sub&quot;&gt;:: up-arrow&lt;/a&gt;，&lt;a href=&quot;#down-arrow-sub&quot;&gt;:: down-arrow&lt;/a&gt;，&lt;a href=&quot;#left-arrow-sub&quot;&gt;:: left-arrow&lt;/a&gt;和&lt;a href=&quot;#right-arrow-sub&quot;&gt;:: right-arrow子&lt;/a&gt;控件。</target>
        </trans-unit>
        <trans-unit id="233835321d7949264542584e5872cf0f2ee5c9ad" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qtoolbutton&quot;&gt;QToolButton&lt;/a&gt; displays arrows, the &lt;a href=&quot;stylesheet-reference#up-arrow-sub&quot;&gt;::up-arrow&lt;/a&gt;, &lt;a href=&quot;stylesheet-reference#down-arrow-sub&quot;&gt;::down-arrow&lt;/a&gt;, &lt;a href=&quot;stylesheet-reference#left-arrow-sub&quot;&gt;::left-arrow&lt;/a&gt; and &lt;a href=&quot;stylesheet-reference#right-arrow-sub&quot;&gt;::right-arrow&lt;/a&gt; subcontrols are used.</source>
          <target state="translated">当&lt;a href=&quot;qtoolbutton&quot;&gt;QToolButton&lt;/a&gt;显示箭头时，将使用&lt;a href=&quot;stylesheet-reference#up-arrow-sub&quot;&gt;:: up-arrow&lt;/a&gt;，&lt;a href=&quot;stylesheet-reference#down-arrow-sub&quot;&gt;:: down-arrow&lt;/a&gt;，&lt;a href=&quot;stylesheet-reference#left-arrow-sub&quot;&gt;:: left-arrow&lt;/a&gt;和&lt;a href=&quot;stylesheet-reference#right-arrow-sub&quot;&gt;:: right-arrow子&lt;/a&gt;控件。</target>
        </trans-unit>
        <trans-unit id="a51ead804c63868aa6b0c7c0b5911080ee61da02" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;widgets-changes-qt6#qcombobox&quot;&gt;QComboBox&lt;/a&gt; is editable, use &lt;a href=&quot;qlineedit#placeholderText-prop&quot;&gt;QLineEdit::setPlaceholderText&lt;/a&gt;() instead.</source>
          <target state="translated">当&lt;a href=&quot;widgets-changes-qt6#qcombobox&quot;&gt;QComboBox&lt;/a&gt;是可编辑的时，请改用&lt;a href=&quot;qlineedit#placeholderText-prop&quot;&gt;QLineEdit :: setPlaceholderText&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="a1a6fb9f01b0846bb260ddb329a9c95bfca49b3e" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;subdirs&lt;/code&gt; template is used, qmake generates a Makefile to examine each specified subdirectory, process any project file it finds there, and run the platform's &lt;code&gt;make&lt;/code&gt; tool on the newly-created Makefile. The &lt;code&gt;SUBDIRS&lt;/code&gt; variable is used to contain a list of all the subdirectories to be processed.</source>
          <target state="translated">使用 &lt;code&gt;subdirs&lt;/code&gt; 模板时，qmake会生成一个Makefile来检查每个指定的子目录，处理在该目录中找到的任何项目文件，然后在新创建的Makefile上运行平台的 &lt;code&gt;make&lt;/code&gt; 工具。所述 &lt;code&gt;SUBDIRS&lt;/code&gt; 变量用于包含所有待处理的子目录的列表。</target>
        </trans-unit>
        <trans-unit id="5b64d4e10455a073c6c16a2676284bd8b55dc704" translate="yes" xml:space="preserve">
          <source>When the KMS/DRM backend is in use, EGLFS reports all available screens in &lt;a href=&quot;qguiapplication#screens&quot;&gt;QGuiApplication::screens&lt;/a&gt;(). Applications can target different screens with different windows via &lt;a href=&quot;qwindow#setScreen&quot;&gt;QWindow::setScreen&lt;/a&gt;().</source>
          <target state="translated">使用KMS / DRM后端时，EGLFS报告&lt;a href=&quot;qguiapplication#screens&quot;&gt;QGuiApplication :: screens&lt;/a&gt;（）中的所有可用屏幕。应用程序可以通过&lt;a href=&quot;qwindow#setScreen&quot;&gt;QWindow :: setScreen&lt;/a&gt;（）将具有不同窗口的不同屏幕作为目标。</target>
        </trans-unit>
        <trans-unit id="13cb608250173ac51a45d65525231f711e5ba267" translate="yes" xml:space="preserve">
          <source>When the KMS/DRM backend is in use, eglfs reports all available screens in &lt;a href=&quot;qguiapplication#screens&quot;&gt;QGuiApplication::screens&lt;/a&gt;(). Applications can target different screens with different windows via &lt;a href=&quot;qwindow#setScreen&quot;&gt;QWindow::setScreen&lt;/a&gt;().</source>
          <target state="translated">使用KMS / DRM后端时，eglfs报告&lt;a href=&quot;qguiapplication#screens&quot;&gt;QGuiApplication :: screens&lt;/a&gt;（）中的所有可用屏幕。应用程序可以通过&lt;a href=&quot;qwindow#setScreen&quot;&gt;QWindow :: setScreen&lt;/a&gt;（）将具有不同窗口的不同屏幕作为目标。</target>
        </trans-unit>
        <trans-unit id="e9c697bf2c44fd91eecd755192f28a6e88860c7e" translate="yes" xml:space="preserve">
          <source>When the PositionSource is active, position updates can be retrieved either by simply using the &lt;a href=&quot;qml-qtpositioning-positionsource#position-prop&quot;&gt;position&lt;/a&gt; property in a binding (as the value of another item's property), or by providing an implementation of the &lt;code&gt;onPositionChanged&lt;/code&gt; signal-handler.</source>
          <target state="translated">当PositionSource处于活动状态时，可以通过仅使用绑定中的&lt;a href=&quot;qml-qtpositioning-positionsource#position-prop&quot;&gt;position&lt;/a&gt;属性（作为另一个项目的属性的值）或提供 &lt;code&gt;onPositionChanged&lt;/code&gt; 信号处理程序的实现来检索位置更新。</target>
        </trans-unit>
        <trans-unit id="590e6b713b7124a325673c8560f716815fb45204" translate="yes" xml:space="preserve">
          <source>When the QML engine encounters a use of &lt;code&gt;RandomNumberGenerator&lt;/code&gt; as a property value source, it invokes &lt;code&gt;RandomNumberGenerator::setTarget()&lt;/code&gt; to provide the type with the property to which the value source has been applied. When the internal timer in &lt;code&gt;RandomNumberGenerator&lt;/code&gt; triggers every 500 milliseconds, it will write a new number value to that specified property.</source>
          <target state="translated">当QML引擎遇到将 &lt;code&gt;RandomNumberGenerator&lt;/code&gt; 用作属性值源时，它将调用 &lt;code&gt;RandomNumberGenerator::setTarget()&lt;/code&gt; 为类型提供具有已应用值源的属性。当 &lt;code&gt;RandomNumberGenerator&lt;/code&gt; 中的内部计时器每500毫秒触发一次时，它将向该指定属性写入一个新的数字值。</target>
        </trans-unit>
        <trans-unit id="55bdd73045f54c63cca63284c91153ecc1e0e57c" translate="yes" xml:space="preserve">
          <source>When the QML engine processes this code, it creates a single instance of the</source>
          <target state="translated">当QML引擎处理这段代码时,它创建了一个单一的</target>
        </trans-unit>
        <trans-unit id="2200e5bee9d5bde2ef75b92345abdbbd47de48d7" translate="yes" xml:space="preserve">
          <source>When the Space key is pressed, the &lt;a href=&quot;qml-qtquick-item#visible-prop&quot;&gt;visible&lt;/a&gt; value of the green &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; is toggled. As it appears and disappears, the blue &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; moves within the Column, and the &lt;a href=&quot;qml-qtquick-column#move-prop&quot;&gt;move&lt;/a&gt; transition is automatically applied to the blue &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt;:</source>
          <target state="translated">当按下空格键时，绿色&lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;矩形&lt;/a&gt;的&lt;a href=&quot;qml-qtquick-item#visible-prop&quot;&gt;可见&lt;/a&gt;值将被切换。随着它的出现和消失，蓝色&lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt;在Column中移动，并且&lt;a href=&quot;qml-qtquick-column#move-prop&quot;&gt;移动&lt;/a&gt;过渡会自动应用于蓝色&lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="9c6490ecb547781d0dc7402f03b49e5ff063c783" translate="yes" xml:space="preserve">
          <source>When the StackView needs a new transition, it first calls &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#getTransition-method&quot;&gt;StackViewDelegate.getTransition()&lt;/a&gt;. The base implementation of this function just looks for a property named &lt;code&gt;properties.name&lt;/code&gt; inside itself (root), which is how it finds &lt;code&gt;property Component pushTransition&lt;/code&gt; in the examples above.</source>
          <target state="translated">当StackView需要新的过渡时，它首先调用&lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#getTransition-method&quot;&gt;StackViewDelegate.getTransition（）&lt;/a&gt;。该函数的基本实现只是在自身（根）中查找一个名为 &lt;code&gt;properties.name&lt;/code&gt; 的属性，这就是它在上面的示例中查找 &lt;code&gt;property Component pushTransition&lt;/code&gt; 的方式。</target>
        </trans-unit>
        <trans-unit id="6a3ce649d4099a8096022c6c669c9176b6fc57ee" translate="yes" xml:space="preserve">
          <source>When the \brief command is used to describe a class, we recommend using a complete sentence like this:</source>
          <target state="translated">当使用\brief命令来描述一个类时,我们建议使用像这样的完整句子。</target>
        </trans-unit>
        <trans-unit id="557b6338e75a33d13fe088abb975f18a855ab911" translate="yes" xml:space="preserve">
          <source>When the \brief command is used to describe a property or a variable, the brief text must be a sentence fragment starting with &quot;whether&quot; (for a boolean property or variable) or starting with &quot;the&quot; (for any other property or variable).</source>
          <target state="translated">当使用&quot;/brief &quot;命令来描述一个属性或变量时,简短的文本必须是以 &quot;whether &quot;开头的句子片段(对于布尔属性或变量)或以 &quot;the &quot;开头的句子片段(对于任何其他属性或变量)。</target>
        </trans-unit>
        <trans-unit id="68de879942c076ccf49dec3b35482feaabb2b36a" translate="yes" xml:space="preserve">
          <source>When the above view is flicked beyond its bounds, it will return to its bounds using the transition specified:</source>
          <target state="translated">当上面的视图被翻动到超出其边界时,它将使用指定的过渡返回到其边界。</target>
        </trans-unit>
        <trans-unit id="589227a0f3172c2f19894c29348f6198f079bcbc" translate="yes" xml:space="preserve">
          <source>When the active subwindow is maximized, the default behavior is to maximize the next subwindow that is activated. Set this option if you do not want this behavior.</source>
          <target state="translated">当活动的子窗口被最大化时,默认行为是最大化下一个被激活的子窗口。如果您不想要这种行为,请设置此选项。</target>
        </trans-unit>
        <trans-unit id="ab36dbc74560565de3f4f93285f3477fd906523a" translate="yes" xml:space="preserve">
          <source>When the allowed &lt;a href=&quot;qdatetimeedit#setDateTimeRange&quot;&gt;range&lt;/a&gt; is narrower than some time interval whose end it straddles, keyboard tracking prevents the user editing the date or time to access the later part of the interval. For example, for a range from 29.04.2020 to 02.05.2020 and an initial date of 30.04.2020, the user can change neither the month (May 30th is outside the range) nor the day (April 2nd is outside the range).</source>
          <target state="translated">当允许的&lt;a href=&quot;qdatetimeedit#setDateTimeRange&quot;&gt;范围&lt;/a&gt;小于某个跨越其范围的时间间隔时，键盘跟踪会阻止用户编辑日期或时间以访问该间隔的后半部分。例如，对于从29.04.2020到02.05.2020的范围，以及初始日期30.04.2020，用户既不能更改月份（5月30日不在范围内），也不能更改日期（4月2日不在范围内）。</target>
        </trans-unit>
        <trans-unit id="5a7ce62c114b1cc52094be5a1851abc5fc7f2e64" translate="yes" xml:space="preserve">
          <source>When the alpha channel is enabled either via &lt;a href=&quot;qquickwindow#setDefaultAlphaBuffer&quot;&gt;QQuickWindow::setDefaultAlphaBuffer&lt;/a&gt;() or by setting alphaBufferSize to a non-zero value in the window's &lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat&lt;/a&gt; or in the global format managed by &lt;a href=&quot;qsurfaceformat#setDefaultFormat&quot;&gt;QSurfaceFormat::setDefaultFormat&lt;/a&gt;(), the D3D12 backend will create a swapchain for composition and go through DirectComposition. This is necessary, because the mandatory flip model swapchain wouldn't support transparency otherwise.</source>
          <target state="translated">当通过&lt;a href=&quot;qquickwindow#setDefaultAlphaBuffer&quot;&gt;QQuickWindow :: setDefaultAlphaBuffer&lt;/a&gt;（）或通过在窗口的&lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat&lt;/a&gt;或&lt;a href=&quot;qsurfaceformat#setDefaultFormat&quot;&gt;QSurfaceFormat :: setDefaultFormat&lt;/a&gt;（）管理的全局格式中将alphaBufferSize设置为非零值来启用alpha通道时，D3D12后端将为组成并通过DirectComposition。这是必要的，因为强制翻转模型交换链否则将不支持透明性。</target>
        </trans-unit>
        <trans-unit id="9a1e6809f3ea75f0ed2e58d51575459791e1afbc" translate="yes" xml:space="preserve">
          <source>When the animation finishes it returns to the initial frame. This is the default behavior.</source>
          <target state="translated">当动画结束时,它会返回到初始帧。这是默认的行为。</target>
        </trans-unit>
        <trans-unit id="c2c6e776224aaea188a4e49fe2b71d9eeacafa46" translate="yes" xml:space="preserve">
          <source>When the animation finishes it stays on the final frame.</source>
          <target state="translated">当动画完成后,它停留在最后一帧。</target>
        </trans-unit>
        <trans-unit id="abead2ff8ba68473ab0f073d1c6b50c8ad980ea5" translate="yes" xml:space="preserve">
          <source>When the application is running with the generic, triangulation-based Shape implementation, the geometry generation happens entirely on the CPU. This is potentially expensive. Changing the set of path elements, changing the properties of these elements, or changing certain properties of the Shape itself all lead to retriangulation of the affected paths on every change. Therefore, applying animation to such properties can affect performance on less powerful systems.</source>
          <target state="translated">当应用程序使用通用的、基于三角测量的Shape实现运行时,几何图形的生成完全在CPU上进行。这可能是昂贵的。改变路径元素的集合,改变这些元素的属性,或者改变Shape本身的某些属性,都会导致每次改变受影响的路径都要重新三角测量。因此,在这些属性上应用动画可能会影响功能较弱的系统的性能。</target>
        </trans-unit>
        <trans-unit id="2dc59efa2f06087183eee0fb11a7e9582ff61062" translate="yes" xml:space="preserve">
          <source>When the application is running, an IDE or a tool that implements the binary protocol can connect to the open port.</source>
          <target state="translated">当应用程序运行时,IDE或实现二进制协议的工具可以连接到开放端口。</target>
        </trans-unit>
        <trans-unit id="c469e679911aae260b7551ead885271015ff56e7" translate="yes" xml:space="preserve">
          <source>When the application is started it has to register an message handler with &lt;a href=&quot;qnearfieldmanager#registerNdefMessageHandler&quot;&gt;registerNdefMessageHandler()&lt;/a&gt; The first NDEF message arriving in the handler is the message that started the application. See the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtnfc-corkboard-example.html#&quot;&gt;CorkBoard&lt;/a&gt; application for an example.</source>
          <target state="translated">启动应用程序时，它必须向registerNdefMessageHandler &lt;a href=&quot;qnearfieldmanager#registerNdefMessageHandler&quot;&gt;（）&lt;/a&gt;注册消息处理程序。到达处理程序的第一个NDEF消息是启动应用程序的消息。有关示例，请参见&lt;a href=&quot;https://doc.qt.io/qt-5.13/qtnfc-corkboard-example.html#&quot;&gt;CorkBoard&lt;/a&gt;应用程序。</target>
        </trans-unit>
        <trans-unit id="bf9811db4bca65a70c4bf17f4e8c83205ce8fbdb" translate="yes" xml:space="preserve">
          <source>When the application is started it has to register an message handler with &lt;a href=&quot;qnearfieldmanager#registerNdefMessageHandler&quot;&gt;registerNdefMessageHandler()&lt;/a&gt; The first NDEF message arriving in the handler is the message that started the application. See the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtnfc-corkboard-example.html&quot;&gt;CorkBoard&lt;/a&gt; application for an example.</source>
          <target state="translated">启动应用程序时，它必须向registerNdefMessageHandler &lt;a href=&quot;qnearfieldmanager#registerNdefMessageHandler&quot;&gt;（）&lt;/a&gt;注册消息处理程序。到达处理程序的第一个NDEF消息是启动应用程序的消息。有关示例，请参见&lt;a href=&quot;https://doc.qt.io/qt-5.15/qtnfc-corkboard-example.html&quot;&gt;CorkBoard&lt;/a&gt;应用程序。</target>
        </trans-unit>
        <trans-unit id="50a549dc65fe725b80a97de046a5a0dc3b6c6fb6" translate="yes" xml:space="preserve">
          <source>When the binding becomes inactive again, any direct bindings that were previously set on the property will be restored.</source>
          <target state="translated">当绑定再次变得不活跃时,之前在该属性上设置的任何直接绑定都将被恢复。</target>
        </trans-unit>
        <trans-unit id="9392393f9bb1d7b61b1f25e10ec17290326feeb8" translate="yes" xml:space="preserve">
          <source>When the built-in, default graphics adaptation is used,</source>
          <target state="translated">当使用内置的默认图形适配时。</target>
        </trans-unit>
        <trans-unit id="447dd45f7b45ede6829150c673fe906621c3daff" translate="yes" xml:space="preserve">
          <source>When the button is clicked, the purchase process is started. At some point in the future, either the &lt;a href=&quot;qml-qtpurchasing-product#onPurchaseFailed-signal&quot;&gt;onPurchaseFailed&lt;/a&gt; handler will be called (for example if the user cancels the transaction), or the &lt;a href=&quot;qml-qtpurchasing-product#onPurchaseSucceeded-signal&quot;&gt;onPurchaseSucceeded&lt;/a&gt; handler will be called.</source>
          <target state="translated">单击按钮后，开始购买过程。在将来的某个时候，将调用&lt;a href=&quot;qml-qtpurchasing-product#onPurchaseFailed-signal&quot;&gt;onPurchaseFailed&lt;/a&gt;处理程序（例如，如果用户取消了交易），或者将调用&lt;a href=&quot;qml-qtpurchasing-product#onPurchaseSucceeded-signal&quot;&gt;onPurchaseSucceeded&lt;/a&gt;处理程序。</target>
        </trans-unit>
        <trans-unit id="4ebbf8f547dd292e8432493d1f5c0d39a31ffd9b" translate="yes" xml:space="preserve">
          <source>When the client is connected successfully, we connect to the `onTextMessageReceived()` signal, and send out &quot;Hello, world!&quot;. If connected with the EchoServer, we will receive the same message back.</source>
          <target state="translated">当客户端连接成功后,我们连接到`onTextMessageReceived()`信号,并发出 &quot;你好,世界!&quot;。如果与EchoServer连接,我们会收到同样的消息回馈。</target>
        </trans-unit>
        <trans-unit id="5d66decd4409859b0e6cc5ba70ca923d5222b329" translate="yes" xml:space="preserve">
          <source>When the connection to the &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;Source&lt;/a&gt; object is made, the initialization step passes the current property values (see &lt;a href=&quot;qtremoteobjects-replica#replica-initialization&quot;&gt;Replica Initialization&lt;/a&gt;). In a DynamicReplica, the property/signal/slot details are also sent, allowing the replica object to be created on-the-fly. This can be conventient in QML or scripting, but has two primary disadvantages. First, the object is in effect &quot;empty&quot; until it is successfully initialized by the &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;Source&lt;/a&gt;. Second, in C++, calls must be made using &lt;a href=&quot;qmetaobject#invokeMethod&quot;&gt;QMetaObject::invokeMethod&lt;/a&gt;(), as the moc generated lookup will not be available.</source>
          <target state="translated">与&lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;Source&lt;/a&gt;对象建立连接后，初始化步骤将传递当前属性值（请参阅&lt;a href=&quot;qtremoteobjects-replica#replica-initialization&quot;&gt;副本初始化&lt;/a&gt;）。在DynamicReplica中，还将发送属性/信号/插槽详细信息，从而可以即时创建副本对象。这在QML或脚本编写中可能很方便，但是有两个主要缺点。首先，对象实际上是&amp;ldquo;空&amp;rdquo;的，直到由&lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;Source&lt;/a&gt;成功初始化为止。其次，在C ++中，必须使用&lt;a href=&quot;qmetaobject#invokeMethod&quot;&gt;QMetaObject :: invokeMethod&lt;/a&gt;（）进行调用，因为moc生成的查找将不可用。</target>
        </trans-unit>
        <trans-unit id="08ec6e33eebed26c7c57c8ed22fb0ac60abd982e" translate="yes" xml:space="preserve">
          <source>When the content is changed using any of these functions, any previous content is cleared.</source>
          <target state="translated">当使用这些功能改变内容时,之前的内容都会被清除。</target>
        </trans-unit>
        <trans-unit id="098eff2cee4bb06ded290defca5ca43aedeb73b3" translate="yes" xml:space="preserve">
          <source>When the current element is a map, you may also call &lt;a href=&quot;qcborstreamreader#isLengthKnown&quot;&gt;isLengthKnown&lt;/a&gt;() to find out if the map's size is explicit in the CBOR stream. If it is, that size can be obtained by calling &lt;a href=&quot;qcborstreamreader#length&quot;&gt;length&lt;/a&gt;().</source>
          <target state="translated">当当前元素是地图时，您还可以调用&lt;a href=&quot;qcborstreamreader#isLengthKnown&quot;&gt;isLengthKnown&lt;/a&gt;（）来确定地图的大小在CBOR流中是否是显式的。如果是这样，则可以通过调用&lt;a href=&quot;qcborstreamreader#length&quot;&gt;length&lt;/a&gt;（）获得该大小。</target>
        </trans-unit>
        <trans-unit id="bea6a9143e97cc060ee75f79678b23a7773047e8" translate="yes" xml:space="preserve">
          <source>When the current element is an array, you may also call &lt;a href=&quot;qcborstreamreader#isLengthKnown&quot;&gt;isLengthKnown&lt;/a&gt;() to find out if the array's size is explicit in the CBOR stream. If it is, that size can be obtained by calling &lt;a href=&quot;qcborstreamreader#length&quot;&gt;length&lt;/a&gt;().</source>
          <target state="translated">当当前元素是数组时，您也可以调用&lt;a href=&quot;qcborstreamreader#isLengthKnown&quot;&gt;isLengthKnown&lt;/a&gt;（）来确定数组的大小在CBOR流中是否是显式的。如果是这样，则可以通过调用&lt;a href=&quot;qcborstreamreader#length&quot;&gt;length&lt;/a&gt;（）获得该大小。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
