<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="qt">
    <body>
      <group id="qt">
        <trans-unit id="1b24d910a145f4c5008d5bda461465dab9c233b5" translate="yes" xml:space="preserve">
          <source>If you are using QMacCocoaViewContainer as a subclass and are accessing Cocoa API, it is probably simpler to have your file end with &lt;code&gt;.mm&lt;/code&gt; instead of &lt;code&gt;.cpp&lt;/code&gt;. Most Apple tools will correctly identify the source as Objective-C++.</source>
          <target state="translated">如果您使用QMacCocoaViewContainer作为子类并访问Cocoa API，则文件以 &lt;code&gt;.mm&lt;/code&gt; 而不是 &lt;code&gt;.cpp&lt;/code&gt; 结尾可能更简单。大多数Apple工具会正确地将源标识为Objective-C ++。</target>
        </trans-unit>
        <trans-unit id="5aa0be9550f6d982ee509d2621be3bbbef0f0cdf" translate="yes" xml:space="preserve">
          <source>If you are using a pragma library script to store application-wide instance data, consider using a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; singleton type instead. This should result in better performance, and will result in less JavaScript heap memory being used.</source>
          <target state="translated">如果您使用实用程序库脚本来存储应用程序范围内的实例数据，请考虑使用&lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;单例类型。这将导致更好的性能，并且将减少使用的JavaScript堆内存。</target>
        </trans-unit>
        <trans-unit id="3770d0073ac083205b9034be2c54e0470c39f38e" translate="yes" xml:space="preserve">
          <source>If you are using a shared configuration of Qt enter the &lt;code&gt;plugin&lt;/code&gt; subdirectory and run &lt;code&gt;qmake&lt;/code&gt; and your make tool to build a plugin that integrates the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qaxcontainer-module.html&quot;&gt;QAxContainer&lt;/a&gt; module into &lt;a href=&quot;qtdesigner-manual&quot;&gt;Qt Designer&lt;/a&gt;.</source>
          <target state="translated">如果您使用的是Qt的共享配置，请输入 &lt;code&gt;plugin&lt;/code&gt; 子目录，然后运行 &lt;code&gt;qmake&lt;/code&gt; 和您的make工具来构建将&lt;a href=&quot;https://doc.qt.io/qt-5.13/qaxcontainer-module.html&quot;&gt;QAxContainer&lt;/a&gt;模块集成到&lt;a href=&quot;qtdesigner-manual&quot;&gt;Qt Designer中&lt;/a&gt;的插件。</target>
        </trans-unit>
        <trans-unit id="19fc65f87770f099e77d3065ca78a198baf61865" translate="yes" xml:space="preserve">
          <source>If you are using a shared configuration of Qt enter the &lt;code&gt;plugin&lt;/code&gt; subdirectory and run &lt;code&gt;qmake&lt;/code&gt; and your make tool to build a plugin that integrates the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qaxcontainer-module.html&quot;&gt;QAxContainer&lt;/a&gt; module into &lt;a href=&quot;qtdesigner-manual&quot;&gt;Qt Designer&lt;/a&gt;.</source>
          <target state="translated">如果您使用的是Qt的共享配置，请输入 &lt;code&gt;plugin&lt;/code&gt; 子目录，然后运行 &lt;code&gt;qmake&lt;/code&gt; 和make工具来构建将&lt;a href=&quot;https://doc.qt.io/qt-5.15/qaxcontainer-module.html&quot;&gt;QAxContainer&lt;/a&gt;模块集成到&lt;a href=&quot;qtdesigner-manual&quot;&gt;Qt Designer中&lt;/a&gt;的插件。</target>
        </trans-unit>
        <trans-unit id="804809b08005ed145375e8b07500633c8542f86c" translate="yes" xml:space="preserve">
          <source>If you are using coordinates with Qt's raster-based paint engine, it is important to note that, while coordinates greater than +/- 2&lt;sup&gt;15&lt;/sup&gt; can be used, any painting performed with coordinates outside this range is not guaranteed to be shown; the drawing may be clipped. This is due to the use of &lt;code&gt;short int&lt;/code&gt; in the implementation.</source>
          <target state="translated">如果您将坐标与Qt的基于栅格的绘画引擎一起使用，则需要注意的是，尽管可以使用大于+/- 2 &lt;sup&gt;15的&lt;/sup&gt;坐标，但是不能保证显示坐标超出此范围的任何绘画。该图可能会被剪切。这是由于在实现中使用了 &lt;code&gt;short int&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6c0876b52f0bb97073b195db808c67ccd41dfa9f" translate="yes" xml:space="preserve">
          <source>If you are using multiple inheritance, &lt;code&gt;moc&lt;/code&gt; assumes that the first inherited class is a subclass of &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;. Also, be sure that only the first inherited class is a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;.</source>
          <target state="translated">如果使用多重继承， &lt;code&gt;moc&lt;/code&gt; 会假定第一个继承的类是&lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;的子类。另外，请确保只有第一个继承的类是&lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0118c72bf59f28a9993657d26d130211a27352ae" translate="yes" xml:space="preserve">
          <source>If you are using older versions of GDB you must run with the full path to the executable. Later versions allow you to pass the bundle name on the command line.</source>
          <target state="translated">如果你使用的是旧版本的GDB,你必须使用可执行文件的完整路径运行。后来的版本允许你在命令行中传递 bundle 名称。</target>
        </trans-unit>
        <trans-unit id="85b6bb08aa314f172681866d0c5bc4b59b8c4460" translate="yes" xml:space="preserve">
          <source>If you are using other libraries in your project in addition to those supplied with Qt, you need to specify them in your project file.</source>
          <target state="translated">如果你的项目中除了Qt提供的库之外,还使用了其他库,你需要在项目文件中指定它们。</target>
        </trans-unit>
        <trans-unit id="8a732d6c50e076fc75334ed75ced8d8ed40fd0bd" translate="yes" xml:space="preserve">
          <source>If you are using the &lt;b&gt;default message handler&lt;/b&gt; this function will abort to create a core dump. On Windows, for debug builds, this function will report a _CRT_ERROR enabling you to connect a debugger to the application.</source>
          <target state="translated">如果使用&lt;b&gt;默认消息处理程序，则&lt;/b&gt;此函数将中止以创建核心转储。在Windows上，对于调试版本，此函数将报告_CRT_ERROR，使您可以将调试器连接到应用程序。</target>
        </trans-unit>
        <trans-unit id="45295d1c90cb9b9c5438d7a1a26913d214a13541" translate="yes" xml:space="preserve">
          <source>If you are using the QRenderAspect,</source>
          <target state="translated">如果你使用的是QRenderAspect,</target>
        </trans-unit>
        <trans-unit id="c3b9a00ccce4e62ff266c186ade813aa22558a16" translate="yes" xml:space="preserve">
          <source>If you are using the mouse wheel to adjust the dial, the increment value is determined by the lesser value of &lt;a href=&quot;qapplication#wheelScrollLines-prop&quot;&gt;wheelScrollLines&lt;/a&gt; multipled by &lt;a href=&quot;qabstractslider#singleStep-prop&quot;&gt;singleStep&lt;/a&gt;, and &lt;a href=&quot;qabstractslider#pageStep-prop&quot;&gt;pageStep&lt;/a&gt;.</source>
          <target state="translated">如果使用鼠标滚轮调整转盘，则增量值由&lt;a href=&quot;qapplication#wheelScrollLines-prop&quot;&gt;wheelScrollLines&lt;/a&gt;乘以&lt;a href=&quot;qabstractslider#singleStep-prop&quot;&gt;singleStep&lt;/a&gt;和&lt;a href=&quot;qabstractslider#pageStep-prop&quot;&gt;pageStep&lt;/a&gt;的较小值确定。</target>
        </trans-unit>
        <trans-unit id="5680084fc0c9cb534680eb4e097fee45a07cc304" translate="yes" xml:space="preserve">
          <source>If you are working with large amounts of filtering and have to invoke &lt;a href=&quot;qsortfilterproxymodel#invalidateFilter&quot;&gt;invalidateFilter&lt;/a&gt;() repeatedly, using &lt;a href=&quot;qabstractitemmodel#beginResetModel&quot;&gt;beginResetModel&lt;/a&gt;() / &lt;a href=&quot;qabstractitemmodel#endResetModel&quot;&gt;endResetModel&lt;/a&gt;() may be more efficient, depending on the implementation of your model. However, &lt;a href=&quot;qabstractitemmodel#beginResetModel&quot;&gt;beginResetModel&lt;/a&gt;() / &lt;a href=&quot;qabstractitemmodel#endResetModel&quot;&gt;endResetModel&lt;/a&gt;() returns the proxy model to its original state, losing selection information, and will cause the proxy model to be repopulated.</source>
          <target state="translated">如果您要处理大量过滤，并且必须重复调用&lt;a href=&quot;qsortfilterproxymodel#invalidateFilter&quot;&gt;invalidateFilter&lt;/a&gt;（），则根据模型的实现，使用&lt;a href=&quot;qabstractitemmodel#beginResetModel&quot;&gt;beginResetModel&lt;/a&gt;（）/ &lt;a href=&quot;qabstractitemmodel#endResetModel&quot;&gt;endResetModel&lt;/a&gt;（）可能会更有效。但是，&lt;a href=&quot;qabstractitemmodel#beginResetModel&quot;&gt;beginResetModel&lt;/a&gt;（）/ &lt;a href=&quot;qabstractitemmodel#endResetModel&quot;&gt;endResetModel&lt;/a&gt;（）将代理模型返回到其原始状态，丢失选择信息，并且将导致重新填充代理模型。</target>
        </trans-unit>
        <trans-unit id="4e92252016948c7d93f00c52d4881602666a0f61" translate="yes" xml:space="preserve">
          <source>If you are working with large amounts of filtering and have to invoke &lt;a href=&quot;qsortfilterproxymodel#invalidateFilter&quot;&gt;invalidateFilter&lt;/a&gt;() repeatedly, using reset() may be more efficient, depending on the implementation of your model. However, reset() returns the proxy model to its original state, losing selection information, and will cause the proxy model to be repopulated.</source>
          <target state="translated">如果您要处理大量过滤操作，并且必须重复调用&lt;a href=&quot;qsortfilterproxymodel#invalidateFilter&quot;&gt;invalidateFilter&lt;/a&gt;（），则根据模型的实现，使用reset（）可能会更有效。但是，reset（）将代理模型返回到其原始状态，丢失选择信息，并且将导致重新填充代理模型。</target>
        </trans-unit>
        <trans-unit id="34e44643802042a92e26e2ac644b7bbd813df0ea" translate="yes" xml:space="preserve">
          <source>If you assign an &lt;a href=&quot;qml-qtquick-item&quot;&gt;Item&lt;/a&gt; to the data list, it becomes a child of the Window's &lt;a href=&quot;qml-qtquick-window-window#contentItem-prop&quot;&gt;contentItem&lt;/a&gt;, so that it appears inside the window. The item's parent will be the window's &lt;a href=&quot;qml-qtquick-window-window#contentItem-prop&quot;&gt;contentItem&lt;/a&gt;, which is the root of the Item ownership tree within that Window.</source>
          <target state="translated">如果将&lt;a href=&quot;qml-qtquick-item&quot;&gt;项目&lt;/a&gt;分配给数据列表，则该项目将成为Window的&lt;a href=&quot;qml-qtquick-window-window#contentItem-prop&quot;&gt;contentItem&lt;/a&gt;的子项，以便它出现在窗口内。项目的父项将是窗口的&lt;a href=&quot;qml-qtquick-window-window#contentItem-prop&quot;&gt;contentItem&lt;/a&gt;，该内容是该窗口内项目所有权树的根。</target>
        </trans-unit>
        <trans-unit id="b2116064952835f54f37cb796458792b576a489b" translate="yes" xml:space="preserve">
          <source>If you assign an &lt;a href=&quot;qml-qtquick-item&quot;&gt;Item&lt;/a&gt; to the data list, it becomes a child of the Window's &lt;a href=&quot;qml-window#contentItem-prop&quot;&gt;contentItem&lt;/a&gt;, so that it appears inside the window. The item's parent will be the window's &lt;a href=&quot;qml-window#contentItem-prop&quot;&gt;contentItem&lt;/a&gt;, which is the root of the Item ownership tree within that Window.</source>
          <target state="translated">如果将&lt;a href=&quot;qml-qtquick-item&quot;&gt;项目&lt;/a&gt;分配给数据列表，则该项目将成为Window的&lt;a href=&quot;qml-window#contentItem-prop&quot;&gt;contentItem&lt;/a&gt;的子项，以便它出现在窗口内。项的父项将是窗口的&lt;a href=&quot;qml-window#contentItem-prop&quot;&gt;contentItem&lt;/a&gt;，该内容是该窗口内&amp;ldquo;项&amp;rdquo;所有权树的根。</target>
        </trans-unit>
        <trans-unit id="5aaba7502661bc68db19eb08ff6699bd95815c44" translate="yes" xml:space="preserve">
          <source>If you assign an Item to the contentData list, it becomes a child of the window's &lt;a href=&quot;qml-qtquick-controls2-applicationwindow#contentItem-attached-prop&quot;&gt;contentItem&lt;/a&gt;, so that it appears inside the window. The item's parent will be the window's &lt;a href=&quot;qml-qtquick-controls2-applicationwindow#contentItem-attached-prop&quot;&gt;contentItem&lt;/a&gt;.</source>
          <target state="translated">如果将Item分配给contentData列表，它将成为窗口&lt;a href=&quot;qml-qtquick-controls2-applicationwindow#contentItem-attached-prop&quot;&gt;contentItem&lt;/a&gt;的子项，因此它会出现在窗口内。该项的父项将是窗口的&lt;a href=&quot;qml-qtquick-controls2-applicationwindow#contentItem-attached-prop&quot;&gt;contentItem&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ae7ce82b8f37a865273277d942e3addd51f65355" translate="yes" xml:space="preserve">
          <source>If you assign another Window to the data list, the nested window will become &quot;transient for&quot; the outer Window.</source>
          <target state="translated">如果您将另一个窗口分配给数据列表,嵌套的窗口将成为 &quot;瞬时的 &quot;外部窗口。</target>
        </trans-unit>
        <trans-unit id="6035c7d9b7cf831619fd5c7a4a0d37226189ee56" translate="yes" xml:space="preserve">
          <source>If you assign any other object type, it is added as a resource.</source>
          <target state="translated">如果您指定任何其他对象类型,它将被添加为资源。</target>
        </trans-unit>
        <trans-unit id="1c354aa520efd20d31e9318d38fb15177e0b11b8" translate="yes" xml:space="preserve">
          <source>If you build Qt directly from the Git repository, you should initialize the repository only with modules which are supported or build and install modules separately. This helps to prevent unexpected build problems.</source>
          <target state="translated">如果你直接从 Git 仓库中构建 Qt,你应该只用支持的模块初始化仓库,或者单独构建和安装模块。这有助于防止意外的构建问题。</target>
        </trans-unit>
        <trans-unit id="06fc70f2a7700754e8743bc2e93d51b94fb545ce" translate="yes" xml:space="preserve">
          <source>If you build Qt from a released source code distribution archive, the &lt;code&gt;configure&lt;/code&gt; tool ensures that the build will be made only for modules which are known to build for the target specified. Additionally, you can explicitly exclude unsupported or not needed modules from the build via the &lt;code&gt;-skip &amp;lt;module&amp;gt;&lt;/code&gt; option when running the &lt;code&gt;configure&lt;/code&gt; tool.</source>
          <target state="translated">如果您从已发布的源代码分发档案库中构建Qt，则 &lt;code&gt;configure&lt;/code&gt; 工具可确保仅针对已知针对指定目标进行构建的模块进行构建。此外，在运行 &lt;code&gt;configure&lt;/code&gt; 工具时，可以通过 &lt;code&gt;-skip &amp;lt;module&amp;gt;&lt;/code&gt; 选项从构建中明确排除不支持或不需要的模块。</target>
        </trans-unit>
        <trans-unit id="0e610364a79b087476ba6a095bd06550ca27dd37" translate="yes" xml:space="preserve">
          <source>If you call &lt;a href=&quot;qaudiodecoder#read&quot;&gt;read&lt;/a&gt;() before a buffer is ready, an invalid buffer will be returned, again without blocking.</source>
          <target state="translated">如果在缓冲区准备就绪之前调用&lt;a href=&quot;qaudiodecoder#read&quot;&gt;read&lt;/a&gt;（），则会返回一个无效的缓冲区，并且不会阻塞。</target>
        </trans-unit>
        <trans-unit id="c48e608f5b5491fc020146b414547db6c7503de9" translate="yes" xml:space="preserve">
          <source>If you call &lt;a href=&quot;qregexp#exactMatch&quot;&gt;exactMatch&lt;/a&gt;() with an empty pattern on an empty string it will return true; otherwise it returns &lt;code&gt;false&lt;/code&gt; since it operates over the whole string. If you call &lt;a href=&quot;qregexp#indexIn&quot;&gt;indexIn&lt;/a&gt;() with an empty pattern on</source>
          <target state="translated">如果您在一个空字符串上使用一个空模式调用&lt;a href=&quot;qregexp#exactMatch&quot;&gt;精确匹配&lt;/a&gt;（），它将返回true；否则，将返回true。否则它返回 &lt;code&gt;false&lt;/code&gt; ,因为它对整个字符串进行操作。如果您使用空模式调用&lt;a href=&quot;qregexp#indexIn&quot;&gt;indexIn&lt;/a&gt;（）</target>
        </trans-unit>
        <trans-unit id="cec9bbda48a93480232a0f202e7db7386279c388" translate="yes" xml:space="preserve">
          <source>If you can't parse the entire input in one go (for example, it is huge, or is being delivered over a network connection), data can be fed to the parser in pieces. This is achieved by telling &lt;a href=&quot;qxmlsimplereader#parse&quot;&gt;parse&lt;/a&gt;() to work incrementally, and making subsequent calls to the &lt;a href=&quot;qxmlsimplereader#parseContinue&quot;&gt;parseContinue&lt;/a&gt;() function, until all the data has been processed.</source>
          <target state="translated">如果您无法一次性解析整个输入（例如，巨大的输入或正在通过网络连接传送），则可以将数据分段地馈送到解析器。通过告诉&lt;a href=&quot;qxmlsimplereader#parse&quot;&gt;parse&lt;/a&gt;（）递增工作，然后对&lt;a href=&quot;qxmlsimplereader#parseContinue&quot;&gt;parseContinue&lt;/a&gt;（）函数进行后续调用，直到处理完所有数据，即可实现此目的。</target>
        </trans-unit>
        <trans-unit id="161a3dea480d3f0f0c723c9f283dc0ca633fd1f9" translate="yes" xml:space="preserve">
          <source>If you cannot determine a better proxy alternative, use &lt;a href=&quot;qnetworkproxy#ProxyType-enum&quot;&gt;QNetworkProxy::DefaultProxy&lt;/a&gt;, which tells the code querying for a proxy to use a higher alternative. For example, if this factory is set to a &lt;a href=&quot;qnetworkaccessmanager&quot;&gt;QNetworkAccessManager&lt;/a&gt; object, DefaultProxy will tell it to query the application-level proxy settings.</source>
          <target state="translated">如果您不能确定更好的代理替代方案，请使用&lt;a href=&quot;qnetworkproxy#ProxyType-enum&quot;&gt;QNetworkProxy :: DefaultProxy&lt;/a&gt;，它告诉查询代理的代码使用更高的替代方案。例如，如果将此工厂设置为&lt;a href=&quot;qnetworkaccessmanager&quot;&gt;QNetworkAccessManager&lt;/a&gt;对象，则DefaultProxy将告诉它查询应用程序级代理设置。</target>
        </trans-unit>
        <trans-unit id="47ee22ae7e0b70ca20b7a7ddcb373d31f54e2606" translate="yes" xml:space="preserve">
          <source>If you change the color of the legend, the style of the legend brush is set to &lt;a href=&quot;qt#BrushStyle-enum&quot;&gt;Qt::SolidPattern&lt;/a&gt;.</source>
          <target state="translated">如果更改图例的颜色，则图例画笔的样式将设置为&lt;a href=&quot;qt#BrushStyle-enum&quot;&gt;Qt :: SolidPattern&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7475bf20fe338cf02b178e9339633535de23b38a" translate="yes" xml:space="preserve">
          <source>If you change the values that a &lt;a href=&quot;qml-qtquick-tableview#rowHeightProvider-prop&quot;&gt;rowHeightProvider&lt;/a&gt; or a &lt;a href=&quot;qml-qtquick-tableview#columnWidthProvider-prop&quot;&gt;columnWidthProvider&lt;/a&gt; return for rows and columns inside the viewport, you must call &lt;a href=&quot;qml-qtquick-tableview#forceLayout-method&quot;&gt;forceLayout&lt;/a&gt;. This informs &lt;a href=&quot;qml-qtquick-tableview&quot;&gt;TableView&lt;/a&gt; that it needs to use the provider functions again to recalculate and update the layout.</source>
          <target state="translated">如果更改&lt;a href=&quot;qml-qtquick-tableview#rowHeightProvider-prop&quot;&gt;rowHeightProvider&lt;/a&gt;或&lt;a href=&quot;qml-qtquick-tableview#columnWidthProvider-prop&quot;&gt;columnWidthProvider&lt;/a&gt;为视口内的行和列返回的值，则必须调用&lt;a href=&quot;qml-qtquick-tableview#forceLayout-method&quot;&gt;forceLayout&lt;/a&gt;。这将通知&lt;a href=&quot;qml-qtquick-tableview&quot;&gt;TableView&lt;/a&gt;它需要再次使用提供程序功能来重新计算和更新布局。</target>
        </trans-unit>
        <trans-unit id="92bca5c90310c6b9e2402ae2496f378c208edc9e" translate="yes" xml:space="preserve">
          <source>If you change the values that a &lt;a href=&quot;qml-qtquick-tableview#rowHeightProvider-prop&quot;&gt;rowHeightProvider&lt;/a&gt; or a &lt;a href=&quot;qml-qtquick-tableview#columnWidthProvider-prop&quot;&gt;columnWidthProvider&lt;/a&gt; return for rows and columns inside the viewport, you must call &lt;a href=&quot;qml-qtquick-tableview#forceLayout-method&quot;&gt;forceLayout&lt;/a&gt;. This informs TableView that it needs to use the provider functions again to recalculate and update the layout.</source>
          <target state="translated">如果更改&lt;a href=&quot;qml-qtquick-tableview#rowHeightProvider-prop&quot;&gt;rowHeightProvider&lt;/a&gt;或&lt;a href=&quot;qml-qtquick-tableview#columnWidthProvider-prop&quot;&gt;columnWidthProvider&lt;/a&gt;为视口内的行和列返回的值，则必须调用&lt;a href=&quot;qml-qtquick-tableview#forceLayout-method&quot;&gt;forceLayout&lt;/a&gt;。这将通知TableView，它需要再次使用提供程序功能来重新计算和更新布局。</target>
        </trans-unit>
        <trans-unit id="500f7c2ed4541742fa250d78ebc48a1f3b9006ae" translate="yes" xml:space="preserve">
          <source>If you choose to represent a gesture by a custom &lt;a href=&quot;qgesture&quot;&gt;QGesture&lt;/a&gt; subclass, you will need to reimplement the &lt;a href=&quot;qgesturerecognizer#create&quot;&gt;create&lt;/a&gt;() function to construct instances of your gesture class. Similarly, you may need to reimplement the &lt;a href=&quot;qgesturerecognizer#reset&quot;&gt;reset&lt;/a&gt;() function if your custom gesture objects need to be specially handled when a gesture is canceled.</source>
          <target state="translated">如果选择通过自定义&lt;a href=&quot;qgesture&quot;&gt;QGesture&lt;/a&gt;子类表示手势，则将需要重新实现&lt;a href=&quot;qgesturerecognizer#create&quot;&gt;create&lt;/a&gt;（）函数以构造手势类的实例。同样，如果在取消手势时需要特别处理自定义手势对象，则可能需要重新实现&lt;a href=&quot;qgesturerecognizer#reset&quot;&gt;reset&lt;/a&gt;（）函数。</target>
        </trans-unit>
        <trans-unit id="575ee9c79996cf1fc9e83075aafbc7b1ede52c95" translate="yes" xml:space="preserve">
          <source>If you compile Qt yourself, you can configure how Qt uses OpenSSL by setting either the &lt;code&gt;-openssl&lt;/code&gt; / &lt;code&gt;-openssl-runtime&lt;/code&gt; or &lt;code&gt;-openssl-linked&lt;/code&gt; configure flags.</source>
          <target state="translated">如果您自己编译Qt，则可以通过设置 &lt;code&gt;-openssl&lt;/code&gt; / &lt;code&gt;-openssl-runtime&lt;/code&gt; 或 &lt;code&gt;-openssl-linked&lt;/code&gt; configure标志来配置Qt如何使用OpenSSL 。</target>
        </trans-unit>
        <trans-unit id="60298eee3c23b33b1a704690c48b9151a00629d4" translate="yes" xml:space="preserve">
          <source>If you create a custom style, you should take special care when drawing asymmetric elements to make sure that they also look correct in a mirrored layout. An easy way to test your styles is to run applications with the &lt;code&gt;-reverse&lt;/code&gt; command-line option or to call &lt;a href=&quot;qguiapplication#layoutDirection-prop&quot;&gt;QApplication::setLayoutDirection&lt;/a&gt;() in your &lt;code&gt;main()&lt;/code&gt; function.</source>
          <target state="translated">如果创建自定义样式，则在绘制非对称元素时应格外小心，以确保它们在镜像布局中也看起来正确。测试样式的一种简单方法是使用 &lt;code&gt;-reverse&lt;/code&gt; 命令行选项运行应用程序，或在 &lt;code&gt;main()&lt;/code&gt; 函数中调用&lt;a href=&quot;qguiapplication#layoutDirection-prop&quot;&gt;QApplication :: setLayoutDirection&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="17cd68422c27362470960984384c5dc705d301d1" translate="yes" xml:space="preserve">
          <source>If you create a new widget we strongly recommend that you use the colors in the palette rather than hard-coding specific colors.</source>
          <target state="translated">如果您创建一个新的小组件,我们强烈建议您使用调色板中的颜色,而不是硬性编码特定的颜色。</target>
        </trans-unit>
        <trans-unit id="3f4462d3119b6a25e2fe9303c0a819f7485e1e86" translate="yes" xml:space="preserve">
          <source>If you create a subclass of &lt;a href=&quot;qgraphicslayoutitem&quot;&gt;QGraphicsLayoutItem&lt;/a&gt; and reimplement its virtual functions, you will enable the layout to resize and position your item along with other QGraphicsLayoutItems including &lt;a href=&quot;graphicsview#qgraphicswidget&quot;&gt;QGraphicsWidget&lt;/a&gt; and &lt;a href=&quot;graphicsview#qgraphicslayout&quot;&gt;QGraphicsLayout&lt;/a&gt;.</source>
          <target state="translated">如果创建&lt;a href=&quot;qgraphicslayoutitem&quot;&gt;QGraphicsLayoutItem&lt;/a&gt;的子类并重新实现其虚拟功能，则将使布局能够与其他QGraphicsLayoutItems（包括&lt;a href=&quot;graphicsview#qgraphicswidget&quot;&gt;QGraphicsWidget&lt;/a&gt;和&lt;a href=&quot;graphicsview#qgraphicslayout&quot;&gt;QGraphicsLayout）&lt;/a&gt;一起调整项目的大小和位置。</target>
        </trans-unit>
        <trans-unit id="a1a612dece7462522525e84b25c5c8a2de0d8e80" translate="yes" xml:space="preserve">
          <source>If you create a subclass of QGraphicsLayoutItem and reimplement its virtual functions, you will enable the layout to resize and position your item along with other QGraphicsLayoutItems including &lt;a href=&quot;graphicsview#qgraphicswidget&quot;&gt;QGraphicsWidget&lt;/a&gt; and &lt;a href=&quot;graphicsview#qgraphicslayout&quot;&gt;QGraphicsLayout&lt;/a&gt;.</source>
          <target state="translated">如果创建QGraphicsLayoutItem的子类并重新实现其虚拟功能，则将使布局能够与其他QGraphicsLayoutItems一起调整大小和放置项目，包括&lt;a href=&quot;graphicsview#qgraphicswidget&quot;&gt;QGraphicsWidget&lt;/a&gt;和&lt;a href=&quot;graphicsview#qgraphicslayout&quot;&gt;QGraphicsLayout&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fbd1dc4f7124280b641957b9c985d0980cf1e5a2" translate="yes" xml:space="preserve">
          <source>If you create an element or attribute with &lt;a href=&quot;qdomdocument#createElement&quot;&gt;QDomDocument::createElement&lt;/a&gt;() or &lt;a href=&quot;qdomdocument#createAttribute&quot;&gt;QDomDocument::createAttribute&lt;/a&gt;(), the prefix will be an empty string. If you use &lt;a href=&quot;qdomdocument#createElementNS&quot;&gt;QDomDocument::createElementNS&lt;/a&gt;() or &lt;a href=&quot;qdomdocument#createAttributeNS&quot;&gt;QDomDocument::createAttributeNS&lt;/a&gt;() instead, the prefix will not be an empty string; but it might be an empty string if the name does not have a prefix.</source>
          <target state="translated">如果使用&lt;a href=&quot;qdomdocument#createElement&quot;&gt;QDomDocument :: createElement&lt;/a&gt;（）或&lt;a href=&quot;qdomdocument#createAttribute&quot;&gt;QDomDocument :: createAttribute&lt;/a&gt;（）创建元素或属性，则前缀将为空字符串。如果改用&lt;a href=&quot;qdomdocument#createElementNS&quot;&gt;QDomDocument :: createElementNS&lt;/a&gt;（）或&lt;a href=&quot;qdomdocument#createAttributeNS&quot;&gt;QDomDocument :: createAttributeNS&lt;/a&gt;（），则前缀将不是空字符串；但如果名称没有前缀，则该字符串可能为空。</target>
        </trans-unit>
        <trans-unit id="9a8af07b0934236da5d1098a000948ac0c59d159" translate="yes" xml:space="preserve">
          <source>If you create multiple database connections, specify a unique connection name for each one, when you call &lt;a href=&quot;qsqldatabase#addDatabase&quot;&gt;addDatabase&lt;/a&gt;(). Use &lt;a href=&quot;qsqldatabase#database&quot;&gt;database&lt;/a&gt;() with a connection name to get that connection. Use &lt;a href=&quot;qsqldatabase#removeDatabase&quot;&gt;removeDatabase&lt;/a&gt;() with a connection name to remove a connection. &lt;a href=&quot;qsqldatabase&quot;&gt;QSqlDatabase&lt;/a&gt; outputs a warning if you try to remove a connection referenced by other &lt;a href=&quot;qsqldatabase&quot;&gt;QSqlDatabase&lt;/a&gt; objects. Use &lt;a href=&quot;qsqldatabase#contains&quot;&gt;contains&lt;/a&gt;() to see if a given connection name is in the list of connections.</source>
          <target state="translated">如果创建多个数据库连接，则在调用&lt;a href=&quot;qsqldatabase#addDatabase&quot;&gt;addDatabase&lt;/a&gt;（）时为每个数据库指定唯一的连接名称。使用带有连接名称的&lt;a href=&quot;qsqldatabase#database&quot;&gt;database&lt;/a&gt;（）来获得该连接。使用带有连接名称的&lt;a href=&quot;qsqldatabase#removeDatabase&quot;&gt;removeDatabase&lt;/a&gt;（）来删除连接。如果尝试删除其他&lt;a href=&quot;qsqldatabase&quot;&gt;QSqlDatabase&lt;/a&gt;对象引用的连接，则&lt;a href=&quot;qsqldatabase&quot;&gt;QSqlDatabase将&lt;/a&gt;输出警告。使用&lt;a href=&quot;qsqldatabase#contains&quot;&gt;contains&lt;/a&gt;（）可以查看给定的连接名称是否在连接列表中。</target>
        </trans-unit>
        <trans-unit id="cf63af2b8619ee051d3e4a4b1749839916624b30" translate="yes" xml:space="preserve">
          <source>If you create multiple database connections, specify a unique connection name for each one, when you call &lt;a href=&quot;qsqldatabase#addDatabase&quot;&gt;addDatabase&lt;/a&gt;(). Use &lt;a href=&quot;qsqldatabase#database&quot;&gt;database&lt;/a&gt;() with a connection name to get that connection. Use &lt;a href=&quot;qsqldatabase#removeDatabase&quot;&gt;removeDatabase&lt;/a&gt;() with a connection name to remove a connection. QSqlDatabase outputs a warning if you try to remove a connection referenced by other QSqlDatabase objects. Use &lt;a href=&quot;qsqldatabase#contains&quot;&gt;contains&lt;/a&gt;() to see if a given connection name is in the list of connections.</source>
          <target state="translated">如果创建多个数据库连接，则在调用&lt;a href=&quot;qsqldatabase#addDatabase&quot;&gt;addDatabase&lt;/a&gt;（）时为每个数据库指定一个唯一的连接名称。使用带有连接名称的&lt;a href=&quot;qsqldatabase#database&quot;&gt;database&lt;/a&gt;（）来获得该连接。使用带有连接名称的&lt;a href=&quot;qsqldatabase#removeDatabase&quot;&gt;removeDatabase&lt;/a&gt;（）删除连接。如果尝试删除其他QSqlDatabase对象引用的连接，则QSqlDatabase将输出警告。使用&lt;a href=&quot;qsqldatabase#contains&quot;&gt;contains&lt;/a&gt;（）可以查看给定的连接名称是否在连接列表中。</target>
        </trans-unit>
        <trans-unit id="7646273ae2dbacaa23658a4e7083837be610751f" translate="yes" xml:space="preserve">
          <source>If you create new widgets in the mousePressEvent() the &lt;a href=&quot;qwidget#mouseReleaseEvent&quot;&gt;mouseReleaseEvent&lt;/a&gt;() may not end up where you expect, depending on the underlying window system (or X11 window manager), the widgets' location and maybe more.</source>
          <target state="translated">如果您在mousePressEvent（）中创建新的小部件，则&lt;a href=&quot;qwidget#mouseReleaseEvent&quot;&gt;mouseReleaseEvent&lt;/a&gt;（）可能不会在您期望的位置结束，具体取决于基础窗口系统（或X11窗口管理器），小部件的位置，甚至更多。</target>
        </trans-unit>
        <trans-unit id="8099c41c6c4619a93004cbcf0c3515483d52ce0b" translate="yes" xml:space="preserve">
          <source>If you declare the</source>
          <target state="translated">如果您申报的是</target>
        </trans-unit>
        <trans-unit id="9e4643eafbd0d4a96807a4ddcf5f41ce29cc0458" translate="yes" xml:space="preserve">
          <source>If you develop components you might want to control who is able to instantiate those components. Since the server binary can be shipped to and registered on any client machine it is possible for anybody to use those components in his own software.</source>
          <target state="translated">如果你开发组件,你可能想控制谁能够实例化这些组件。由于服务器二进制文件可以被运送到任何客户机上并在任何客户机上注册,所以任何人都可以在自己的软件中使用这些组件。</target>
        </trans-unit>
        <trans-unit id="8ec1ab807ee3535bc730f9e500858259db3a5b6a" translate="yes" xml:space="preserve">
          <source>If you develop on a Linux machine, you can also run the compositor within a window on your development machine. This lets you run clients in an environment that closely resembles the target device. Without rebuilding the client, you can also run it with &lt;code&gt;-platform wayland&lt;/code&gt; to run it inside the compositor. If you use &lt;code&gt;-platform xcb&lt;/code&gt; (for X11), you can run the client on the desktop. In other words, you can start developing your clients before the compositor is ready for use.</source>
          <target state="translated">如果在Linux机器上进行开发，则还可以在开发机器上的窗口中运行合成器。这使您可以在与目标设备非常相似的环境中运行客户端。无需重建客户端，您也可以使用 &lt;code&gt;-platform wayland&lt;/code&gt; 来运行它以在合成器中运行它。如果使用 &lt;code&gt;-platform xcb&lt;/code&gt; （用于X11），则可以在桌面上运行客户端。换句话说，您可以在准备好使用合成器之前就开始开发客户端。</target>
        </trans-unit>
        <trans-unit id="afa8bf4954cb5202a30b0fc12f02b6b538c3177e" translate="yes" xml:space="preserve">
          <source>If you did not build Qt with RPATH enabled, you can place the Qt runtime components in any folder in the file system. The following environment variables should point to valid locations assuming that the Qt installation is located in &lt;code&gt;&amp;lt;Qt-install-path&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">如果未在启用RPATH的情况下构建Qt，则可以将Qt运行时组件放置在文件系统中的任何文件夹中。假设Qt安装位于 &lt;code&gt;&amp;lt;Qt-install-path&amp;gt;&lt;/code&gt; 中，则以下环境变量应指向有效位置：</target>
        </trans-unit>
        <trans-unit id="f5ac96c3608663c3ee69d2ea4c3f3259795c6549" translate="yes" xml:space="preserve">
          <source>If you disable a parent item, all its children will also be disabled. If you enable a parent item, all children will be enabled, unless they have been explicitly disabled (i.e., if you call setEnabled(false) on a child, it will not be reenabled if its parent is disabled, and then enabled again).</source>
          <target state="translated">如果你禁用一个父项,它的所有子项也将被禁用。如果启用父项,所有的子项都将被启用,除非它们被明确地禁用(即,如果你对一个子项调用setEnabled(false),如果它的父项被禁用,它将不会被重新启用,然后再启用)。</target>
        </trans-unit>
        <trans-unit id="b84a34e331b907bd7ec85f721effe578cfa854d4" translate="yes" xml:space="preserve">
          <source>If you disable the &lt;code&gt;const char *&lt;/code&gt; to &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; automatic conversion by compiling your software with the macro &lt;code&gt;QT_NO_CAST_FROM_ASCII&lt;/code&gt; defined, you'll be very likely to catch any strings you are missing. See &lt;a href=&quot;qstring#fromUtf8&quot;&gt;QString::fromUtf8&lt;/a&gt;() and &lt;a href=&quot;qstring#fromLatin1&quot;&gt;QString::fromLatin1&lt;/a&gt;() for more information.</source>
          <target state="translated">如果通过使用定义的宏 &lt;code&gt;QT_NO_CAST_FROM_ASCII&lt;/code&gt; 编译软件来禁用将 &lt;code&gt;const char *&lt;/code&gt; 转换为&lt;a href=&quot;qstring&quot;&gt;QString的&lt;/a&gt;自动转换，则很可能会捕获丢失的任何字符串。有关更多信息，请参见&lt;a href=&quot;qstring#fromUtf8&quot;&gt;QString :: fromUtf8&lt;/a&gt;（）和&lt;a href=&quot;qstring#fromLatin1&quot;&gt;QString :: fromLatin1&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="1beb35be34924577a497d6aa4f5c769f34ab178d" translate="yes" xml:space="preserve">
          <source>If you disable the deprecated version using the &lt;a href=&quot;qtglobal#QT_DISABLE_DEPRECATED_BEFORE&quot;&gt;QT_DISABLE_DEPRECATED_BEFORE&lt;/a&gt; macro, then you can omit &lt;code&gt;Qt::ReturnByValue&lt;/code&gt; as shown below:</source>
          <target state="translated">如果使用&lt;a href=&quot;qtglobal#QT_DISABLE_DEPRECATED_BEFORE&quot;&gt;QT_DISABLE_DEPRECATED_BEFORE&lt;/a&gt;宏禁用了不推荐使用的版本，则可以省略 &lt;code&gt;Qt::ReturnByValue&lt;/code&gt; ，如下所示：</target>
        </trans-unit>
        <trans-unit id="7c6a1ddfc7d45f56ca6150fe2e413b375a67c3c1" translate="yes" xml:space="preserve">
          <source>If you do not see the entries for the gamepad you are using, check if the &lt;code&gt;joystick&lt;/code&gt; package is installed. If not, install the package and &lt;code&gt;grep&lt;/code&gt; the &lt;code&gt;dmesg&lt;/code&gt; logs again.</source>
          <target state="translated">如果看不到正在使用的游戏板的条目，请检查是否已安装 &lt;code&gt;joystick&lt;/code&gt; 包。如果没有，请安装包，并 &lt;code&gt;grep&lt;/code&gt; 的 &lt;code&gt;dmesg&lt;/code&gt; 的再次登录。</target>
        </trans-unit>
        <trans-unit id="ca2f383e2bf046db28456505c081643e252eeb5d" translate="yes" xml:space="preserve">
          <source>If you do not specify a format, the format of the decoded audio itself will be used. Otherwise, some format conversion will be applied.</source>
          <target state="translated">如果您没有指定格式,将使用解码后的音频本身的格式。否则,将应用一些格式转换。</target>
        </trans-unit>
        <trans-unit id="22140f6657582e35a247395d8b2f447b0f8c6672" translate="yes" xml:space="preserve">
          <source>If you do not use &lt;a href=&quot;qtglobal#Q_DECLARE_TYPEINFO&quot;&gt;Q_DECLARE_TYPEINFO&lt;/a&gt;, Qt will use &lt;a href=&quot;https://en.cppreference.com/w/cpp/types/is_trivial&quot;&gt;std::is_trivial_v&amp;lt;T&amp;gt;&lt;/a&gt; to indentify primitive types and it will require both &lt;a href=&quot;https://en.cppreference.com/w/cpp/types/is_trivially_copyable&quot;&gt;std::is_trivially_copyable_v&amp;lt;T&amp;gt;&lt;/a&gt; and &lt;a href=&quot;https://en.cppreference.com/w/cpp/types/is_destructible&quot;&gt;std::is_trivially_destructible_v&amp;lt;T&amp;gt;&lt;/a&gt; to identify relocatable types. This is always a safe choice, albeit of maybe suboptimal performance.</source>
          <target state="translated">如果不使用&lt;a href=&quot;qtglobal#Q_DECLARE_TYPEINFO&quot;&gt;Q_DECLARE_TYPEINFO&lt;/a&gt;，则Qt将使用&lt;a href=&quot;https://en.cppreference.com/w/cpp/types/is_trivial&quot;&gt;std :: is_trivial_v &amp;lt;T&amp;gt;&lt;/a&gt;识别基本类型，并且将需要&lt;a href=&quot;https://en.cppreference.com/w/cpp/types/is_trivially_copyable&quot;&gt;std :: is_trivially_copyable_v &amp;lt;T&amp;gt;&lt;/a&gt;和&lt;a href=&quot;https://en.cppreference.com/w/cpp/types/is_destructible&quot;&gt;std :: is_trivially_destructible_v &amp;lt;T&amp;gt;&lt;/a&gt;来标识可重定位的类型。尽管性能可能欠佳，但这始终是一个安全的选择。</target>
        </trans-unit>
        <trans-unit id="de1635a44cea7651e746c1686155d7406a62dc52" translate="yes" xml:space="preserve">
          <source>If you do not want all plugins added to QTPLUGIN to be automatically linked, remove &lt;code&gt;import_plugins&lt;/code&gt; from the &lt;code&gt;CONFIG&lt;/code&gt; variable:</source>
          <target state="translated">如果您不想自动链接添加到QTPLUGIN的所有插件， &lt;code&gt;import_plugins&lt;/code&gt; 从 &lt;code&gt;CONFIG&lt;/code&gt; 变量中删除import_plugins：</target>
        </trans-unit>
        <trans-unit id="cdd8ad11a5a8433d7c4e01c15d5566bd728f5503" translate="yes" xml:space="preserve">
          <source>If you do not want particles to automatically die after a time, for example if you wish to dispose of them manually, set lifeSpan to Emitter.InfiniteLife.</source>
          <target state="translated">如果你不想让粒子在一段时间后自动死亡,比如你想手动处理它们,可以将lifeSpan设置为Emitter.InfiniteLife。</target>
        </trans-unit>
        <trans-unit id="137e6ed64703982d6f6a1b7c58462d03cb2952de" translate="yes" xml:space="preserve">
          <source>If you do not want the line edit to have a context menu, you can set its &lt;a href=&quot;qwidget#contextMenuPolicy-prop&quot;&gt;contextMenuPolicy&lt;/a&gt; to &lt;a href=&quot;qt#ContextMenuPolicy-enum&quot;&gt;Qt::NoContextMenu&lt;/a&gt;. If you want to customize the context menu, reimplement this function. If you want to extend the standard context menu, reimplement this function, call &lt;a href=&quot;qlineedit#createStandardContextMenu&quot;&gt;createStandardContextMenu&lt;/a&gt;() and extend the menu returned.</source>
          <target state="translated">如果您不希望行编辑具有上下文菜单，则可以将其&lt;a href=&quot;qwidget#contextMenuPolicy-prop&quot;&gt;contextMenuPolicy&lt;/a&gt;设置为&lt;a href=&quot;qt#ContextMenuPolicy-enum&quot;&gt;Qt :: NoContextMenu&lt;/a&gt;。如果要自定义上下文菜单，请重新实现此功能。如果要扩展标准上下文菜单，请重新实现此功能，调用&lt;a href=&quot;qlineedit#createStandardContextMenu&quot;&gt;createStandardContextMenu&lt;/a&gt;（）并扩展返回的菜单。</target>
        </trans-unit>
        <trans-unit id="fc81d4dd3f76f07754477505ca4dd2bf14711219" translate="yes" xml:space="preserve">
          <source>If you do not want the text edit to have a context menu, you can set its &lt;a href=&quot;qwidget#contextMenuPolicy-prop&quot;&gt;contextMenuPolicy&lt;/a&gt; to &lt;a href=&quot;qt#ContextMenuPolicy-enum&quot;&gt;Qt::NoContextMenu&lt;/a&gt;. If you want to customize the context menu, reimplement this function. If you want to extend the standard context menu, reimplement this function, call &lt;a href=&quot;qplaintextedit#createStandardContextMenu&quot;&gt;createStandardContextMenu&lt;/a&gt;() and extend the menu returned.</source>
          <target state="translated">如果您不希望文本编辑具有上下文菜单，则可以将其&lt;a href=&quot;qwidget#contextMenuPolicy-prop&quot;&gt;contextMenuPolicy&lt;/a&gt;设置为&lt;a href=&quot;qt#ContextMenuPolicy-enum&quot;&gt;Qt :: NoContextMenu&lt;/a&gt;。如果要自定义上下文菜单，请重新实现此功能。如果要扩展标准上下文菜单，请重新实现此功能，调用&lt;a href=&quot;qplaintextedit#createStandardContextMenu&quot;&gt;createStandardContextMenu&lt;/a&gt;（）并扩展返回的菜单。</target>
        </trans-unit>
        <trans-unit id="264b0fb3179ab096c73c0b90036579cf8921a2f4" translate="yes" xml:space="preserve">
          <source>If you do not want the text edit to have a context menu, you can set its &lt;a href=&quot;qwidget#contextMenuPolicy-prop&quot;&gt;contextMenuPolicy&lt;/a&gt; to &lt;a href=&quot;qt#ContextMenuPolicy-enum&quot;&gt;Qt::NoContextMenu&lt;/a&gt;. If you want to customize the context menu, reimplement this function. If you want to extend the standard context menu, reimplement this function, call &lt;a href=&quot;qtextedit#createStandardContextMenu&quot;&gt;createStandardContextMenu&lt;/a&gt;() and extend the menu returned.</source>
          <target state="translated">如果您不希望文本编辑具有上下文菜单，则可以将其&lt;a href=&quot;qwidget#contextMenuPolicy-prop&quot;&gt;contextMenuPolicy&lt;/a&gt;设置为&lt;a href=&quot;qt#ContextMenuPolicy-enum&quot;&gt;Qt :: NoContextMenu&lt;/a&gt;。如果要自定义上下文菜单，请重新实现此功能。如果要扩展标准上下文菜单，请重新实现此功能，调用&lt;a href=&quot;qtextedit#createStandardContextMenu&quot;&gt;createStandardContextMenu&lt;/a&gt;（）并扩展返回的菜单。</target>
        </trans-unit>
        <trans-unit id="414a4b42e3e1fdf1f4fbba5afc1d7f27ca70c7d1" translate="yes" xml:space="preserve">
          <source>If you do not want to include all data contained in the model, or the autogenerated rows and columns are not ordered as you wish, you can specify which rows and columns should be included and in which order by defining an explicit list of categories for either or both of rows and columns.</source>
          <target state="translated">如果您不想包含模型中包含的所有数据,或者自动生成的行和列没有按照您的意愿排序,您可以通过为行和列中的任何一个或两个定义一个明确的类别列表来指定哪些行和列应该被包含,以及按什么顺序排列。</target>
        </trans-unit>
        <trans-unit id="057684615c560d24fa3d7850ba2b1690d752365f" translate="yes" xml:space="preserve">
          <source>If you do not want to provide plugins for your accessibility interfaces, you can use an interface factory (&lt;a href=&quot;qaccessible#InterfaceFactory-typedef&quot;&gt;QAccessible::InterfaceFactory&lt;/a&gt;), which is the recommended way to provide accessible interfaces in a statically-linked application.</source>
          <target state="translated">如果不想为可访问性接口提供插件，则可以使用接口工厂（&lt;a href=&quot;qaccessible#InterfaceFactory-typedef&quot;&gt;QAccessible :: InterfaceFactory&lt;/a&gt;），这是在静态链接的应用程序中提供可访问接口的推荐方法。</target>
        </trans-unit>
        <trans-unit id="40d74a535b955d54f4d75584d27c82f8baeb3109" translate="yes" xml:space="preserve">
          <source>If you do not want to use the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtsql-attribution-sqlite.html#sqlite&quot;&gt;SQLite&lt;/a&gt; library included with Qt, you can pass &lt;code&gt;-system-sqlite&lt;/code&gt; to the configure script to use the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtsql-attribution-sqlite.html#sqlite&quot;&gt;SQLite&lt;/a&gt; libraries of the operating system. This is recommended whenever possible, as it reduces the installation size and removes one component for which you need to track security advisories.</source>
          <target state="translated">如果您不想使用Qt附带的&lt;a href=&quot;https://doc.qt.io/qt-5.13/qtsql-attribution-sqlite.html#sqlite&quot;&gt;SQLite&lt;/a&gt;库，则可以将 &lt;code&gt;-system-sqlite&lt;/code&gt; 传递给configure脚本以使用操作系统的&lt;a href=&quot;https://doc.qt.io/qt-5.13/qtsql-attribution-sqlite.html#sqlite&quot;&gt;SQLite&lt;/a&gt;库。建议尽可能地这样做，因为它会减小安装大小并删除您需要跟踪安全公告的一个组件。</target>
        </trans-unit>
        <trans-unit id="b0ac722ef049b33f7fc11c0603adb986e2b05a42" translate="yes" xml:space="preserve">
          <source>If you do not want to use the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtsql-attribution-sqlite.html#sqlite&quot;&gt;SQLite&lt;/a&gt; library included with Qt, you can pass &lt;code&gt;-system-sqlite&lt;/code&gt; to the configure script to use the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtsql-attribution-sqlite.html#sqlite&quot;&gt;SQLite&lt;/a&gt; libraries of the operating system. This is recommended whenever possible, as it reduces the installation size and removes one component for which you need to track security advisories.</source>
          <target state="translated">如果您不想使用Qt附带的&lt;a href=&quot;https://doc.qt.io/qt-5.15/qtsql-attribution-sqlite.html#sqlite&quot;&gt;SQLite&lt;/a&gt;库，则可以将 &lt;code&gt;-system-sqlite&lt;/code&gt; 传递给configure脚本以使用操作系统的&lt;a href=&quot;https://doc.qt.io/qt-5.15/qtsql-attribution-sqlite.html#sqlite&quot;&gt;SQLite&lt;/a&gt;库。建议尽可能这样做，因为它会减小安装大小并删除您需要跟踪安全公告的一个组件。</target>
        </trans-unit>
        <trans-unit id="ec54c7ae0f7410e256224d6ec13062e4091485b8" translate="yes" xml:space="preserve">
          <source>If you do not want to use the &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtsql-attribution-sqlite.html#sqlite&quot;&gt;SQLite&lt;/a&gt; library included with Qt, you can pass &lt;code&gt;-system-sqlite&lt;/code&gt; to the configure script to use the &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtsql-attribution-sqlite.html#sqlite&quot;&gt;SQLite&lt;/a&gt; libraries of the operating system. This is recommended whenever possible, as it reduces the installation size and removes one component for which you need to track security advisories.</source>
          <target state="translated">如果您不想使用Qt附带的&lt;a href=&quot;https://doc.qt.io/qt-6.0/qtsql-attribution-sqlite.html#sqlite&quot;&gt;SQLite&lt;/a&gt;库，则可以将 &lt;code&gt;-system-sqlite&lt;/code&gt; 传递给configure脚本以使用操作系统的&lt;a href=&quot;https://doc.qt.io/qt-6.0/qtsql-attribution-sqlite.html#sqlite&quot;&gt;SQLite&lt;/a&gt;库。建议尽可能这样做，因为它会减小安装大小并删除您需要跟踪安全公告的一个组件。</target>
        </trans-unit>
        <trans-unit id="343aa26528918bf8eae80d3edfbc84e50deb8988" translate="yes" xml:space="preserve">
          <source>If you do not wish to store the address of the reading you may use the &lt;a href=&quot;qsensorbackend#reading&quot;&gt;reading&lt;/a&gt;() method to get it again later.</source>
          <target state="translated">如果您不希望存储读数的地址，则可以使用&lt;a href=&quot;qsensorbackend#reading&quot;&gt;reading&lt;/a&gt;（）方法稍后再获取它。</target>
        </trans-unit>
        <trans-unit id="59343985f92053a6f90ac9774ec6c299a593e440" translate="yes" xml:space="preserve">
          <source>If you do reimplement this function,</source>
          <target state="translated">如果你真的重新实现了这个功能。</target>
        </trans-unit>
        <trans-unit id="7459f1c7db2abb955632f345eb9bcbc56a6e2474" translate="yes" xml:space="preserve">
          <source>If you do reimplement this function, you should call the base class implementation.</source>
          <target state="translated">如果你确实重新实现了这个函数,你应该调用基类的实现。</target>
        </trans-unit>
        <trans-unit id="47d6e81d9e44e07739dfe3bc8280ba53c8a5bed7" translate="yes" xml:space="preserve">
          <source>If you don't care about overflow, or you know that overflow cannot occur, you can ignore the &lt;code&gt;overflow()&lt;/code&gt; signal, i.e. don't connect it to any slot.</source>
          <target state="translated">如果您不关心溢出，或者知道不会发生溢出，则可以忽略 &lt;code&gt;overflow()&lt;/code&gt; 信号，即不要将其连接到任何插槽。</target>
        </trans-unit>
        <trans-unit id="c3f8db5f627a6412eb185b92c3a869ae90aabc98" translate="yes" xml:space="preserve">
          <source>If you don't include the function name with the &lt;b&gt;\overload&lt;/b&gt; command, then instead of the &quot;This function overloads...&quot; line with the link to the documentation for the primary version, you get the old standard line:</source>
          <target state="translated">如果您未在&lt;b&gt;\ overload&lt;/b&gt;命令中包含函数名称，那么将使用旧的标准行，而不是带有指向主要版本的文档链接的&amp;ldquo;此函数重载...&amp;rdquo;行：</target>
        </trans-unit>
        <trans-unit id="3c156da325286cb2d3f119765787f3d6db7b29ac" translate="yes" xml:space="preserve">
          <source>If you don't mind the source-incompatibility of return values of &lt;a href=&quot;qutf8stringview#data&quot;&gt;QUtf8StringView::data&lt;/a&gt;() etc changing when compiling under C++17 or C++20, use &quot;QUtf8StringView&quot;. You will need to write your code in such a way that it adapts to the differences in the QUtf8StringView API in different C++ versions.</source>
          <target state="translated">如果您不介意在C ++ 17或C ++ 20下编译时&lt;a href=&quot;qutf8stringview#data&quot;&gt;QUtf8StringView :: data&lt;/a&gt;（）等返回值的源不兼容，请使用&amp;ldquo; QUtf8StringView&amp;rdquo;。您将需要以适合不同C ++版本中QUtf8StringView API中的差异的方式编写代码。</target>
        </trans-unit>
        <trans-unit id="f4b13e746ac6ed5f37e7487d2823fe3bfc4ac180" translate="yes" xml:space="preserve">
          <source>If you don't need C++11 noexcept semantics, e.g. because your function can't possibly throw, don't use this macro, use &lt;a href=&quot;qtglobal#Q_DECL_NOTHROW&quot;&gt;Q_DECL_NOTHROW&lt;/a&gt; instead.</source>
          <target state="translated">如果您不需要C ++ 11 noexcept语义，例如因为您的函数不可能抛出，请不要使用此宏，而应使用&lt;a href=&quot;qtglobal#Q_DECL_NOTHROW&quot;&gt;Q_DECL_NOTHROW&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4954e43d9e3bcabd409cd1c9115411f1b727fd8d" translate="yes" xml:space="preserve">
          <source>If you don't need a future object, you can call &lt;a href=&quot;qtconcurrent-qtaskbuilder#spawn&quot;&gt;QtConcurrent::QTaskBuilder::spawn&lt;/a&gt;(QtConcurrent::FutureResult::Ignore):</source>
          <target state="translated">如果不需要将来的对象，则可以调用&lt;a href=&quot;qtconcurrent-qtaskbuilder#spawn&quot;&gt;QtConcurrent :: QTaskBuilder :: spawn&lt;/a&gt;（QtConcurrent :: FutureResult :: Ignore）：</target>
        </trans-unit>
        <trans-unit id="3494cf7669c2fb0939996104376f4477c4c09a5f" translate="yes" xml:space="preserve">
          <source>If you don't pass parent &lt;code&gt;window&lt;/code&gt; in the constrcutor, you can at a later point use &lt;a href=&quot;qwidget#setLayout&quot;&gt;QWidget::setLayout&lt;/a&gt;() to install the QHBoxLayout object onto &lt;code&gt;window&lt;/code&gt;. At that point, the widgets in the layout are reparented to have &lt;code&gt;window&lt;/code&gt; as their parent.</source>
          <target state="translated">如果您没有在构造 &lt;code&gt;window&lt;/code&gt; 中传递父窗口，则可以稍后使用&lt;a href=&quot;qwidget#setLayout&quot;&gt;QWidget :: setLayout&lt;/a&gt;（）将QHBoxLayout对象安装到 &lt;code&gt;window&lt;/code&gt; 上。此时，布局中的小部件将重新进行父级化，以将 &lt;code&gt;window&lt;/code&gt; 作为其父级。</target>
        </trans-unit>
        <trans-unit id="0bdd5cbfbe7b631d79e00b853ec1ed6d410519a0" translate="yes" xml:space="preserve">
          <source>If you don't pass parent &lt;code&gt;window&lt;/code&gt; in the constrcutor, you can at a later point use &lt;a href=&quot;qwidget#setLayout&quot;&gt;QWidget::setLayout&lt;/a&gt;() to install the QVBoxLayout object onto &lt;code&gt;window&lt;/code&gt;. At that point, the widgets in the layout are reparented to have &lt;code&gt;window&lt;/code&gt; as their parent.</source>
          <target state="translated">如果您没有在构造函数中传递父 &lt;code&gt;window&lt;/code&gt; ，则可以在以后使用&lt;a href=&quot;qwidget#setLayout&quot;&gt;QWidget :: setLayout&lt;/a&gt;（）将QVBoxLayout对象安装到 &lt;code&gt;window&lt;/code&gt; 上。此时，布局中的小部件将重新进行父级化，以将 &lt;code&gt;window&lt;/code&gt; 作为其父级。</target>
        </trans-unit>
        <trans-unit id="f4aac5a2cb5b5ba20fa581bac2ac4ecdfa698a32" translate="yes" xml:space="preserve">
          <source>If you don't set at least the content and error handlers, the parser will fall back on its default behavior---and will do nothing.</source>
          <target state="translated">如果你不设置至少是内容和错误处理程序,解析器将回到它的默认行为------并且什么也不做。</target>
        </trans-unit>
        <trans-unit id="5041c0834c26c12411e9d4b9de6cf518e963de2e" translate="yes" xml:space="preserve">
          <source>If you don't use the return value, &lt;a href=&quot;qcontiguouscache#removeFirst&quot;&gt;removeFirst&lt;/a&gt;() is more efficient.</source>
          <target state="translated">如果不使用返回值，则&lt;a href=&quot;qcontiguouscache#removeFirst&quot;&gt;removeFirst&lt;/a&gt;（）会更有效。</target>
        </trans-unit>
        <trans-unit id="6f0b3ec2e3f2240b0c9bd99bec86af00d556f943" translate="yes" xml:space="preserve">
          <source>If you don't use the return value, &lt;a href=&quot;qcontiguouscache#removeLast&quot;&gt;removeLast&lt;/a&gt;() is more efficient.</source>
          <target state="translated">如果不使用返回值，则&lt;a href=&quot;qcontiguouscache#removeLast&quot;&gt;removeLast&lt;/a&gt;（）会更有效。</target>
        </trans-unit>
        <trans-unit id="c3eda638d5401c3d46365a3d5398cb614bb77093" translate="yes" xml:space="preserve">
          <source>If you don't use the return value, &lt;a href=&quot;qhash#remove&quot;&gt;remove&lt;/a&gt;() is more efficient.</source>
          <target state="translated">如果不使用返回值，则&lt;a href=&quot;qhash#remove&quot;&gt;remove&lt;/a&gt;（）效率更高。</target>
        </trans-unit>
        <trans-unit id="6238b630b08739411aeb3e4860079290f1daeb6a" translate="yes" xml:space="preserve">
          <source>If you don't use the return value, &lt;a href=&quot;qjsonarray#removeAt&quot;&gt;removeAt&lt;/a&gt;() is more efficient.</source>
          <target state="translated">如果不使用返回值，则&lt;a href=&quot;qjsonarray#removeAt&quot;&gt;removeAt&lt;/a&gt;（）会更有效。</target>
        </trans-unit>
        <trans-unit id="16389cdcb2d83186dca00f19daf34b971a56ae6c" translate="yes" xml:space="preserve">
          <source>If you don't use the return value, &lt;a href=&quot;qlinkedlist#removeFirst&quot;&gt;removeFirst&lt;/a&gt;() is more efficient.</source>
          <target state="translated">如果不使用返回值，则&lt;a href=&quot;qlinkedlist#removeFirst&quot;&gt;removeFirst&lt;/a&gt;（）会更有效。</target>
        </trans-unit>
        <trans-unit id="e532d96c70aba46349957efbde0774df9e51d4ff" translate="yes" xml:space="preserve">
          <source>If you don't use the return value, &lt;a href=&quot;qlinkedlist#removeLast&quot;&gt;removeLast&lt;/a&gt;() is more efficient.</source>
          <target state="translated">如果不使用返回值，则&lt;a href=&quot;qlinkedlist#removeLast&quot;&gt;removeLast&lt;/a&gt;（）会更有效。</target>
        </trans-unit>
        <trans-unit id="2c512ded4975686b35f1fb701d84a9b7cd1d15e6" translate="yes" xml:space="preserve">
          <source>If you don't use the return value, &lt;a href=&quot;qlist#removeAt&quot;&gt;removeAt&lt;/a&gt;() is more efficient.</source>
          <target state="translated">如果不使用返回值，则&lt;a href=&quot;qlist#removeAt&quot;&gt;removeAt&lt;/a&gt;（）会更有效。</target>
        </trans-unit>
        <trans-unit id="3580c79a00255579ecf1dc06e86b78e8a44314f1" translate="yes" xml:space="preserve">
          <source>If you don't use the return value, &lt;a href=&quot;qlist#removeFirst&quot;&gt;removeFirst&lt;/a&gt;() is more efficient.</source>
          <target state="translated">如果不使用返回值，则&lt;a href=&quot;qlist#removeFirst&quot;&gt;removeFirst&lt;/a&gt;（）会更有效。</target>
        </trans-unit>
        <trans-unit id="9e0c4f65190d8ec00e741c79f6a58ec29cd4558a" translate="yes" xml:space="preserve">
          <source>If you don't use the return value, &lt;a href=&quot;qlist#removeLast&quot;&gt;removeLast&lt;/a&gt;() is more efficient.</source>
          <target state="translated">如果不使用返回值，则&lt;a href=&quot;qlist#removeLast&quot;&gt;removeLast&lt;/a&gt;（）会更有效。</target>
        </trans-unit>
        <trans-unit id="7b89e12bb904cadd6f68a456bf8a4d218049020f" translate="yes" xml:space="preserve">
          <source>If you don't use the return value, &lt;a href=&quot;qmap#remove&quot;&gt;remove&lt;/a&gt;() is more efficient.</source>
          <target state="translated">如果不使用返回值，则&lt;a href=&quot;qmap#remove&quot;&gt;remove&lt;/a&gt;（）效率更高。</target>
        </trans-unit>
        <trans-unit id="5ac0a2971841e658b73261c39032b429d6cbbc35" translate="yes" xml:space="preserve">
          <source>If you don't use the return value, &lt;a href=&quot;qmultihash#remove-1&quot;&gt;remove&lt;/a&gt;() is more efficient.</source>
          <target state="translated">如果不使用返回值，则&lt;a href=&quot;qmultihash#remove-1&quot;&gt;remove&lt;/a&gt;（）效率更高。</target>
        </trans-unit>
        <trans-unit id="ff26bd9b0737f12402a01bd942d38bdb4ae2db34" translate="yes" xml:space="preserve">
          <source>If you don't use the return value, &lt;a href=&quot;qmultimap#remove&quot;&gt;remove&lt;/a&gt;() is more efficient.</source>
          <target state="translated">如果不使用返回值，则&lt;a href=&quot;qmultimap#remove&quot;&gt;remove&lt;/a&gt;（）效率更高。</target>
        </trans-unit>
        <trans-unit id="8b4317833de468d14b7193cf24bfa578254f1bac" translate="yes" xml:space="preserve">
          <source>If you don't use the return value, &lt;a href=&quot;qvector#removeLast&quot;&gt;removeLast&lt;/a&gt;() is more efficient.</source>
          <target state="translated">如果不使用返回值，则&lt;a href=&quot;qvector#removeLast&quot;&gt;removeLast&lt;/a&gt;（）会更有效。</target>
        </trans-unit>
        <trans-unit id="26a968b5c8c8e8a4fc392e15d89984fdeec66025" translate="yes" xml:space="preserve">
          <source>If you don't want to deal with the above source-incompatibilities, or if you need to maintain binary compatibility between C++20 and C++17 builds, use &quot;q_no_char8_t::QUtf8StringView&quot; explicitly. Be aware that the &lt;code&gt;q_no_char8_t&lt;/code&gt; version will disappear in Qt 7.</source>
          <target state="translated">如果不想处理上述源代码不兼容性，或者需要维护C ++ 20和C ++ 17构建之间的二进制兼容性，请显式使用&amp;ldquo; q_no_char8_t :: QUtf8StringView&amp;rdquo;。请注意， &lt;code&gt;q_no_char8_t&lt;/code&gt; 版本将在Qt 7中消失。</target>
        </trans-unit>
        <trans-unit id="98a6cadcb257cc7405bae4f90b3e1e2945c7348f" translate="yes" xml:space="preserve">
          <source>If you don't want to reuse items or if the &lt;a href=&quot;qml-qtquick-tableview#delegate-prop&quot;&gt;delegate&lt;/a&gt; cannot support it, you can set the &lt;a href=&quot;qml-qtquick-tableview#reuseItems-prop&quot;&gt;reuseItems&lt;/a&gt; property to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果你不想重复使用的物品，或者如果&lt;a href=&quot;qml-qtquick-tableview#delegate-prop&quot;&gt;代表&lt;/a&gt;不能支持它，你可以设置&lt;a href=&quot;qml-qtquick-tableview#reuseItems-prop&quot;&gt;reuseItems&lt;/a&gt;属性为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="838b97a9339f2b2d2c2a71a001cc2517e1ae6341" translate="yes" xml:space="preserve">
          <source>If you don't want to use frameworks, simply configure Qt with &lt;code&gt;-no-framework&lt;/code&gt;.</source>
          <target state="translated">如果您不想使用框架，只需将Qt配置为 &lt;code&gt;-no-framework&lt;/code&gt; 即可。</target>
        </trans-unit>
        <trans-unit id="0a836131e0f2704bfd556204956a2e5fd4bc8cef" translate="yes" xml:space="preserve">
          <source>If you draw any graphics items on top of a chart containing an accelerated series, the accelerated series is drawn over those items.</source>
          <target state="translated">如果在包含加速系列的图表上绘制任何图形项,加速系列就会在这些项上绘制。</target>
        </trans-unit>
        <trans-unit id="70073c2e33637d94e0f741698ec0d2592dfc1ea1" translate="yes" xml:space="preserve">
          <source>If you enable a focus policy (i.e., not &lt;a href=&quot;qt#FocusPolicy-enum&quot;&gt;Qt::NoFocus&lt;/a&gt;), &lt;a href=&quot;graphicsview#qgraphicswidget&quot;&gt;QGraphicsWidget&lt;/a&gt; will automatically enable the &lt;a href=&quot;qgraphicsitem#GraphicsItemFlag-enum&quot;&gt;ItemIsFocusable&lt;/a&gt; flag. Setting &lt;a href=&quot;qt#FocusPolicy-enum&quot;&gt;Qt::NoFocus&lt;/a&gt; on a widget will clear the &lt;a href=&quot;qgraphicsitem#GraphicsItemFlag-enum&quot;&gt;ItemIsFocusable&lt;/a&gt; flag. If the widget currently has keyboard focus, the widget will automatically lose focus.</source>
          <target state="translated">如果启用了焦点策略（即，不是&lt;a href=&quot;qt#FocusPolicy-enum&quot;&gt;Qt :: NoFocus&lt;/a&gt;），则&lt;a href=&quot;graphicsview#qgraphicswidget&quot;&gt;QGraphicsWidget&lt;/a&gt;将自动启用&lt;a href=&quot;qgraphicsitem#GraphicsItemFlag-enum&quot;&gt;ItemIsFocusable&lt;/a&gt;标志。在小部件上设置&lt;a href=&quot;qt#FocusPolicy-enum&quot;&gt;Qt :: NoFocus&lt;/a&gt;将清除&lt;a href=&quot;qgraphicsitem#GraphicsItemFlag-enum&quot;&gt;ItemIsFocusable&lt;/a&gt;标志。如果小部件当前具有键盘焦点，则该小部件将自动失去焦点。</target>
        </trans-unit>
        <trans-unit id="41dc335fec90b30b3454b0f635c1e50125bda194" translate="yes" xml:space="preserve">
          <source>If you enable this option, a rubber band control is used to represent the subwindow's outline, and the user moves this instead of the subwindow itself. As a result, the subwindow remains in its original position until the move operation has completed, at which time a &lt;a href=&quot;qmoveevent&quot;&gt;QMoveEvent&lt;/a&gt; is sent to the window. By default, this option is disabled.</source>
          <target state="translated">如果启用此选项，则将使用橡皮筋控件来表示子窗口的轮廓，并且用户将其移动而不是子窗口本身。结果，子窗口将保持在其原始位置，直到移动操作完成为止，此时&lt;a href=&quot;qmoveevent&quot;&gt;QMoveEvent&lt;/a&gt;被发送到窗口。默认情况下，此选项处于禁用状态。</target>
        </trans-unit>
        <trans-unit id="33f5358221b7caed93fe5c10ea0c248f1b41a5c2" translate="yes" xml:space="preserve">
          <source>If you enable this option, a rubber band control is used to represent the subwindow's outline, and the user resizes this instead of the subwindow itself. As a result, the subwindow maintains its original position and size until the resize operation has been completed, at which time it will receive a single &lt;a href=&quot;qresizeevent&quot;&gt;QResizeEvent&lt;/a&gt;. By default, this option is disabled.</source>
          <target state="translated">如果启用此选项，将使用橡皮筋控件表示子窗口的轮廓，并且用户将调整其大小，而不是子窗口本身的大小。结果，子窗口将保持其原始位置和大小，直到调整大小操作完成为止，此时它将收到一个&lt;a href=&quot;qresizeevent&quot;&gt;QResizeEvent&lt;/a&gt;。默认情况下，此选项处于禁用状态。</target>
        </trans-unit>
        <trans-unit id="ee9e15e9e7e88dd472e71c94c981951ef20f8571" translate="yes" xml:space="preserve">
          <source>If you enable this option, the widget's &lt;a href=&quot;qwidget#mask&quot;&gt;QWidget::mask&lt;/a&gt;() is ignored when rendering into the target. By default, this option is disabled.</source>
          <target state="translated">如果启用此选项，则将小部件的&lt;a href=&quot;qwidget#mask&quot;&gt;QWidget :: mask&lt;/a&gt;（）渲染到目标时将被忽略。默认情况下，此选项处于禁用状态。</target>
        </trans-unit>
        <trans-unit id="29baace13a9463b22a74a74a22cd35d6e24e59e4" translate="yes" xml:space="preserve">
          <source>If you enable this option, the widget's background is rendered into the target even if &lt;a href=&quot;qwidget#autoFillBackground-prop&quot;&gt;autoFillBackground&lt;/a&gt; is not set. By default, this option is enabled.</source>
          <target state="translated">如果启用此选项，则即使未设置&lt;a href=&quot;qwidget#autoFillBackground-prop&quot;&gt;autoFillBackground&lt;/a&gt;，小部件的背景也会渲染到目标中。默认情况下，启用此选项。</target>
        </trans-unit>
        <trans-unit id="7ca699664ee5b0a2558f5e46c84fccb5c7a7c628" translate="yes" xml:space="preserve">
          <source>If you enable this option, the widget's children are rendered recursively into the target. By default, this option is enabled.</source>
          <target state="translated">如果您启用此选项,小组件的子节点将递归地渲染到目标中。默认情况下,此选项已启用。</target>
        </trans-unit>
        <trans-unit id="2a44f4aa208acbf490ca3cc98609e0f8457532a5" translate="yes" xml:space="preserve">
          <source>If you encounter issues, always set the &lt;code&gt;QSG_INFO&lt;/code&gt; and &lt;code&gt;QT_D3D_DEBUG&lt;/code&gt; environment variables to &lt;code&gt;1&lt;/code&gt;, to get debug and warning messages printed on the debug output. &lt;code&gt;QT_D3D_DEBUG&lt;/code&gt; enables the Direct3D debug layer.</source>
          <target state="translated">如果遇到问题，请始终将 &lt;code&gt;QSG_INFO&lt;/code&gt; 和 &lt;code&gt;QT_D3D_DEBUG&lt;/code&gt; 环境变量设置为 &lt;code&gt;1&lt;/code&gt; ，以获取打印在调试输出上的调试和警告消息。 &lt;code&gt;QT_D3D_DEBUG&lt;/code&gt; 启用Direct3D调试层。</target>
        </trans-unit>
        <trans-unit id="ad40d497502697850fda1deea9f60068b4a3ecc3" translate="yes" xml:space="preserve">
          <source>If you exclusively use function objects then you will get compile time errors if you attempt to use a function not included in that version and profile. This is obviously a lot easier to debug than undefined behavior at run time.</source>
          <target state="translated">如果你只使用函数对象,那么如果你试图使用一个没有包含在该版本和配置文件中的函数,你将得到编译时的错误。这显然比运行时的未定义行为更容易调试。</target>
        </trans-unit>
        <trans-unit id="ec4c5fc223f0c10dcc5beafaa6caffa95226dcd5" translate="yes" xml:space="preserve">
          <source>If you experience very slow access of the ODBC datasource, make sure that ODBC call tracing is turned off in the ODBC datasource manager.</source>
          <target state="translated">如果遇到ODBC数据源访问速度非常慢的情况,请确保在ODBC数据源管理器中关闭ODBC调用跟踪。</target>
        </trans-unit>
        <trans-unit id="28e8c8e90363713071c08bffc584af58a728c846" translate="yes" xml:space="preserve">
          <source>If you get linkage errors in the final building phase of your program, saying that &lt;code&gt;YourClass::className()&lt;/code&gt; is undefined or that &lt;code&gt;YourClass&lt;/code&gt; lacks a vtable, something has been done wrong. Most often, you have forgotten to compile or &lt;code&gt;#include&lt;/code&gt; the moc-generated C++ code, or (in the former case) include that object file in the link command. If you use &lt;code&gt;qmake&lt;/code&gt;, try rerunning it to update your makefile. This should do the trick.</source>
          <target state="translated">如果在程序的最终构建阶段遇到链接错误，说未定义 &lt;code&gt;YourClass::className()&lt;/code&gt; 或 &lt;code&gt;YourClass&lt;/code&gt; 缺少vtable，则说明操作有误。大多数情况下，您忘记编译或 &lt;code&gt;#include&lt;/code&gt; moc生成的C ++代码，或者（在前一种情况下）在link命令中包括该对象文件。如果使用 &lt;code&gt;qmake&lt;/code&gt; ，请尝试重新运行它以更新您的makefile。这应该可以解决问题。</target>
        </trans-unit>
        <trans-unit id="eb19136b2ee8f51e016ddebdf8cf1cafd00b88de" translate="yes" xml:space="preserve">
          <source>If you had both an Adobe and a Cronyx Helvetica, you might get either.</source>
          <target state="translated">如果你同时拥有一个Adobe和一个Cronyx Helvetica,你可能会得到其中之一。</target>
        </trans-unit>
        <trans-unit id="093501ca07e1b048873f519ee54bbe9affd78b82" translate="yes" xml:space="preserve">
          <source>If you have XML like this:</source>
          <target state="translated">如果你的XML是这样的。</target>
        </trans-unit>
        <trans-unit id="8d7fa731b64eef42e9c01535220404d74f72d884" translate="yes" xml:space="preserve">
          <source>If you have a C++-only test project, you can add the following line to your project file:</source>
          <target state="translated">如果你有一个纯C++的测试项目,你可以在你的项目文件中添加以下一行。</target>
        </trans-unit>
        <trans-unit id="0f3028a3f541466286a12cfacbcb9811b5158360" translate="yes" xml:space="preserve">
          <source>If you have a CPU with multiple cores, a multi-process system can help distribute the load evenly across different cores, making more efficient use of your CPU.</source>
          <target state="translated">如果您的CPU有多个核心,多进程系统可以帮助将负载均匀地分配到不同的核心上,从而更有效地利用CPU。</target>
        </trans-unit>
        <trans-unit id="a513986a1bf7e1220dab5eefa567b76a52bcd6b8" translate="yes" xml:space="preserve">
          <source>If you have a complex UI, then multi-process is useful because if one part of the UI crashes, it doesn't affect the entire system. Similarly, the display won't freeze, even when one client freezes.</source>
          <target state="translated">如果你有一个复杂的UI,那么多进程是有用的,因为如果UI的一个部分崩溃,它不会影响整个系统。同样,即使一个客户端冻结,显示也不会冻结。</target>
        </trans-unit>
        <trans-unit id="d37de89818a0a93f6cd07292f522f47de7107ae7" translate="yes" xml:space="preserve">
          <source>If you have a custom component or an application that embeds</source>
          <target state="translated">如果你有一个自定义组件或一个嵌入了</target>
        </trans-unit>
        <trans-unit id="b7117b76ff8d814f10a4596a6862b2d44fee9406" translate="yes" xml:space="preserve">
          <source>If you have a font which matches on family, even if none of the other attributes match, this font will be chosen in preference to a font which doesn't match on family but which does match on the other attributes. This is because font family is the dominant search criteria.</source>
          <target state="translated">如果您有一个字体在家族上匹配,即使其他属性都不匹配,也会优先选择这个字体,而不是在家族上不匹配但在其他属性上匹配的字体。这是因为字体家族是主要的搜索标准。</target>
        </trans-unit>
        <trans-unit id="edb8fa84e65c82236eb5f0f616d31d8b82c3f7b8" translate="yes" xml:space="preserve">
          <source>If you have a loop where you do some processing, but only the final result of the processing is important, it is often better to update a temporary accumulator which you afterwards assign to the property you need to update, rather than incrementally updating the property itself, in order to avoid triggering re-evaluation of binding expressions during the intermediate stages of accumulation.</source>
          <target state="translated">如果你有一个循环,在这个循环中,你做了一些处理,但只有处理的最终结果是重要的,那么通常情况下,更新一个临时的累加器,之后将其分配给你需要更新的属性,而不是增量地更新属性本身,以避免在累加的中间阶段触发绑定表达式的重新评估。</target>
        </trans-unit>
        <trans-unit id="7833a0e9686bea974ea7046d997ccb46fe3b0afd" translate="yes" xml:space="preserve">
          <source>If you have a new style class called &lt;code&gt;MyStyle&lt;/code&gt; that you want to make available as a plugin, the class needs to be defined as follows (&lt;code&gt;mystyleplugin.h&lt;/code&gt;):</source>
          <target state="translated">如果您有一个名为 &lt;code&gt;MyStyle&lt;/code&gt; 的新样式类要作为插件提供，则该类的定义如下（ &lt;code&gt;mystyleplugin.h&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="3f4d5741fec7d17ca29f8c5099a118c8c010c66e" translate="yes" xml:space="preserve">
          <source>If you have a pointer to an object, you can use &lt;a href=&quot;qobject#metaObject&quot;&gt;metaObject&lt;/a&gt;() to retrieve the meta-object associated with that object.</source>
          <target state="translated">如果您有一个指向对象的指针，则可以使用&lt;a href=&quot;qobject#metaObject&quot;&gt;metaObject&lt;/a&gt;（）检索与该对象关联的元对象。</target>
        </trans-unit>
        <trans-unit id="fc4c2bd6a20a583368114747bf95813ca0ed13d2" translate="yes" xml:space="preserve">
          <source>If you have code that looks like this:</source>
          <target state="translated">如果你的代码看起来像这样。</target>
        </trans-unit>
        <trans-unit id="1d42bdafc68ae936bd171e32c366e91c134b7e92" translate="yes" xml:space="preserve">
          <source>If you have elements which are totally covered by other (opaque) elements, it is best to set their &quot;visible&quot; property to &lt;code&gt;false&lt;/code&gt; or they will be drawn needlessly.</source>
          <target state="translated">如果您的元素完全被其他（不透明）元素覆盖，则最好将其&amp;ldquo; visible&amp;rdquo;属性设置为 &lt;code&gt;false&lt;/code&gt; ，否则将不必要地绘制它们。</target>
        </trans-unit>
        <trans-unit id="dfc4e0f8c2bf7525a3a838de728f9d8bd61c812d" translate="yes" xml:space="preserve">
          <source>If you have large forms that do not fit in the Qt Creator &lt;b&gt;Design&lt;/b&gt; mode, you can open them in the stand-alone</source>
          <target state="translated">如果您有不适合在Qt Creator &lt;b&gt;设计&lt;/b&gt;模式下使用的大型表单，则可以独立打开它们</target>
        </trans-unit>
        <trans-unit id="4b0b4fe41787d4b4f7c373135e22dcffa7954df8" translate="yes" xml:space="preserve">
          <source>If you have many occurrences of a certain set of keys, you can use arrays to make your life easier. For example, let's suppose that you want to save a variable-length list of user names and passwords. You could then write:</source>
          <target state="translated">如果你的某一组键有许多次出现,你可以使用数组来让你的生活更轻松。例如,假设你想保存一个长度可变的用户名和密码列表。然后你可以写道</target>
        </trans-unit>
        <trans-unit id="593656e2cbae068866581c1bb67f541d54a1eec4" translate="yes" xml:space="preserve">
          <source>If you have no pointer to an actual object instance but still want to access the meta-object of a class, you can use &lt;a href=&quot;qobject#staticMetaObject-var&quot;&gt;staticMetaObject&lt;/a&gt;.</source>
          <target state="translated">如果您没有指向实际对象实例的指针，但仍想访问类的元对象，则可以使用&lt;a href=&quot;qobject#staticMetaObject-var&quot;&gt;staticMetaObject&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="073ec092d3e6402042ace4ab5ccf8f01d19d871b" translate="yes" xml:space="preserve">
          <source>If you have only one single custom widget then you can set it as default widget using &lt;a href=&quot;qwidgetaction#setDefaultWidget&quot;&gt;setDefaultWidget&lt;/a&gt;(). That widget will then be used if the action is added to a &lt;a href=&quot;qtoolbar&quot;&gt;QToolBar&lt;/a&gt;, or in general to an action container that supports &lt;a href=&quot;qwidgetaction&quot;&gt;QWidgetAction&lt;/a&gt;. If a &lt;a href=&quot;qwidgetaction&quot;&gt;QWidgetAction&lt;/a&gt; with only a default widget is added to two toolbars at the same time then the default widget is shown only in the first toolbar the action was added to. &lt;a href=&quot;qwidgetaction&quot;&gt;QWidgetAction&lt;/a&gt; takes over ownership of the default widget.</source>
          <target state="translated">如果只有一个自定义窗口小部件，则可以使用&lt;a href=&quot;qwidgetaction#setDefaultWidget&quot;&gt;setDefaultWidget&lt;/a&gt;（）将其设置为默认窗口小部件。如果加入的动作到该部件将随后被用于&lt;a href=&quot;qtoolbar&quot;&gt;在QToolBar&lt;/a&gt;，或一般地的动作容器支持&lt;a href=&quot;qwidgetaction&quot;&gt;QWidgetAction&lt;/a&gt;。如果将仅具有默认窗口小部件的&lt;a href=&quot;qwidgetaction&quot;&gt;QWidgetAction&lt;/a&gt;同时添加到两个工具栏，则默认窗口小部件仅显示在添加了该动作的第一个工具栏中。&lt;a href=&quot;qwidgetaction&quot;&gt;QWidgetAction&lt;/a&gt;接管了默认小部件的所有权。</target>
        </trans-unit>
        <trans-unit id="6433e5e862427569ee1551b82308f0512b5bce47" translate="yes" xml:space="preserve">
          <source>If you have only one single custom widget then you can set it as default widget using &lt;a href=&quot;qwidgetaction#setDefaultWidget&quot;&gt;setDefaultWidget&lt;/a&gt;(). That widget will then be used if the action is added to a &lt;a href=&quot;qtoolbar&quot;&gt;QToolBar&lt;/a&gt;, or in general to an action container that supports QWidgetAction. If a QWidgetAction with only a default widget is added to two toolbars at the same time then the default widget is shown only in the first toolbar the action was added to. QWidgetAction takes over ownership of the default widget.</source>
          <target state="translated">如果只有一个自定义窗口小部件，则可以使用&lt;a href=&quot;qwidgetaction#setDefaultWidget&quot;&gt;setDefaultWidget&lt;/a&gt;（）将其设置为默认窗口小部件。如果加入的动作到该部件将随后被用于&lt;a href=&quot;qtoolbar&quot;&gt;在QToolBar&lt;/a&gt;，或一般地的动作容器支持QWidgetAction。如果将仅具有默认窗口小部件的QWidgetAction同时添加到两个工具栏，则默认窗口小部件仅显示在添加了操作的第一个工具栏中。QWidgetAction接管了默认小部件的所有权。</target>
        </trans-unit>
        <trans-unit id="b044cf74f2358671783da692819f13ac65606c4d" translate="yes" xml:space="preserve">
          <source>If you have problems installing open source versions of Qt provided by your Linux distribution, for example, from RPM or APT repositories, please consult the maintainers of the distribution.</source>
          <target state="translated">如果你在安装你的Linux发行版提供的Qt开源版本时遇到问题,例如,从RPM或APT仓库中安装,请咨询发行版的维护者。</target>
        </trans-unit>
        <trans-unit id="43e0f84948bbeba6b3511f8f03e7121e68df5cf7" translate="yes" xml:space="preserve">
          <source>If you have programatically created the arguments, as opposed to getting them from the arguments in &lt;code&gt;main()&lt;/code&gt;, it is likely of interest to use QTest::qExec(&lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; *, const &lt;a href=&quot;qstringlist&quot;&gt;QStringList&lt;/a&gt; &amp;amp;) since it is Unicode safe.</source>
          <target state="translated">如果您以编程方式创建了参数，而不是从 &lt;code&gt;main()&lt;/code&gt; 的参数中获取参数，则可能会使用QTest :: qExec（&lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; *，const &lt;a href=&quot;qstringlist&quot;&gt;QStringList&lt;/a&gt;＆），因为它是Unicode安全的。</target>
        </trans-unit>
        <trans-unit id="67532b014024b48dccc7bd6b4f01cf6849669d04" translate="yes" xml:space="preserve">
          <source>If you have reimplemented &lt;a href=&quot;qtimeline#valueForTime&quot;&gt;valueForTime&lt;/a&gt;(), this value is ignored.</source>
          <target state="translated">如果您重新实现了&lt;a href=&quot;qtimeline#valueForTime&quot;&gt;valueForTime&lt;/a&gt;（），则将忽略此值。</target>
        </trans-unit>
        <trans-unit id="3c4f5edd184fd000c128f5048b97d4d92bf3821e" translate="yes" xml:space="preserve">
          <source>If you have resources in a library, you need to force initialization of your resources by calling &lt;a href=&quot;qdir#Q_INIT_RESOURCE&quot;&gt;Q_INIT_RESOURCE&lt;/a&gt;() with the base name of the &lt;code&gt;.qrc&lt;/code&gt; file. For example:</source>
          <target state="translated">如果库中有资源，则需要通过使用 &lt;code&gt;.qrc&lt;/code&gt; 文件的基本名称调用&lt;a href=&quot;qdir#Q_INIT_RESOURCE&quot;&gt;Q_INIT_RESOURCE&lt;/a&gt;（）来强制初始化资源。例如：</target>
        </trans-unit>
        <trans-unit id="4efcb21d844a9a9269c0619eb7765d115b79b762" translate="yes" xml:space="preserve">
          <source>If you have seen regexps described elsewhere, they may have looked different from the ones shown here. This is because some sets of characters and some quantifiers are so common that they have been given special symbols to represent them. &lt;b&gt;[0-9]&lt;/b&gt; can be replaced with the symbol &lt;b&gt;\d&lt;/b&gt;. The quantifier to match exactly one occurrence, &lt;b&gt;{1,1}&lt;/b&gt;, can be replaced with the expression itself, i.e. &lt;b&gt;x{1,1}&lt;/b&gt; is the same as &lt;b&gt;x&lt;/b&gt;. So our 0 to 99 matcher could be written as &lt;b&gt;^\d{1,2}$&lt;/b&gt;. It can also be written &lt;b&gt;^\d\d{0,1}$&lt;/b&gt;, i.e.</source>
          <target state="translated">如果您在其他地方看到过正则表达式，则它们看起来可能与此处所示的不同。这是因为某些字符集和一些量词太常见了，以致于给它们指定了特殊的符号来表示它们。&lt;b&gt;[0-9]&lt;/b&gt;可以用符号&lt;b&gt;\ d&lt;/b&gt;代替。可以完全匹配一次出现的量词&lt;b&gt;{1,1}&lt;/b&gt;可以用表达式本身替换，即&lt;b&gt;x {1,1}&lt;/b&gt;与&lt;b&gt;x&lt;/b&gt;相同。因此我们的0到99匹配器可以写成&lt;b&gt;^ \ d {1,2} $&lt;/b&gt;。也可以写成&lt;b&gt;^ \ d \ d {0,1} $&lt;/b&gt;，即</target>
        </trans-unit>
        <trans-unit id="99eb71782f95aa9f75d79617643a560c36139759" translate="yes" xml:space="preserve">
          <source>If you hide a parent item, all its children will also be hidden. If you show a parent item, all children will be shown, unless they have been explicitly hidden (i.e., if you call setVisible(false) on a child, it will not be reshown even if its parent is hidden, and then shown again).</source>
          <target state="translated">如果你隐藏一个父项,它的所有子项也会被隐藏。如果你显示一个父项,所有的子项都会被显示,除非它们已经被明确地隐藏了(即,如果你对一个子项调用setVisible(false),即使它的父项被隐藏,也不会被重新显示,然后再显示)。</target>
        </trans-unit>
        <trans-unit id="3e76e7caf35eee52604b222848022d14ae7e690c" translate="yes" xml:space="preserve">
          <source>If you ignore the event (i.e., by calling &lt;a href=&quot;qevent#ignore&quot;&gt;QEvent::ignore&lt;/a&gt;()),</source>
          <target state="translated">如果您忽略事件（即通过调用&lt;a href=&quot;qevent#ignore&quot;&gt;QEvent :: ignore&lt;/a&gt;（）），</target>
        </trans-unit>
        <trans-unit id="b5be8bce7d84f21c1008d75c236bbe2fd2fa45a8" translate="yes" xml:space="preserve">
          <source>If you ignore the event, (i.e., by calling &lt;a href=&quot;qevent#ignore&quot;&gt;QEvent::ignore&lt;/a&gt;(),) it will propagate to any item beneath this item. If no items accept the event, it will be ignored by the scene, and propagate to the view (e.g., the view's vertical scroll bar).</source>
          <target state="translated">如果忽略该事件（即，通过调用&lt;a href=&quot;qevent#ignore&quot;&gt;QEvent :: ignore&lt;/a&gt;（）），它将传播到该项目下面的任何项目。如果没有项目接受该事件，则该事件将被场景忽略，并传播到视图（例如，视图的垂直滚动条）。</target>
        </trans-unit>
        <trans-unit id="d0b5138a89d332131f26aa61549d834762616824" translate="yes" xml:space="preserve">
          <source>If you implement &lt;a href=&quot;qabstractscrollarea#scrollContentsBy&quot;&gt;scrollContentsBy&lt;/a&gt;() in a subclass of &lt;a href=&quot;qabstractitemview&quot;&gt;QAbstractItemView&lt;/a&gt;, call this function before you call &lt;a href=&quot;qwidget#scroll&quot;&gt;QWidget::scroll&lt;/a&gt;() on the viewport. Alternatively, just call &lt;a href=&quot;qabstractitemview#update&quot;&gt;update&lt;/a&gt;().</source>
          <target state="translated">如果您在&lt;a href=&quot;qabstractitemview&quot;&gt;QAbstractItemView&lt;/a&gt;的子类中实现&lt;a href=&quot;qabstractscrollarea#scrollContentsBy&quot;&gt;scrollContentsBy&lt;/a&gt;（），请在调用视口上的&lt;a href=&quot;qwidget#scroll&quot;&gt;QWidget :: scroll&lt;/a&gt;（）之前先调用此函数。或者，只需调用&lt;a href=&quot;qabstractitemview#update&quot;&gt;update&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="4125209b6ce63aa8c8f3650e5c6a37c6c7ff1328" translate="yes" xml:space="preserve">
          <source>If you implement your own model, you can reimplement this function if you want to support insertions. Alternatively, you can provide your own API for altering the data.</source>
          <target state="translated">如果你实现了自己的模型,如果你想支持插入,你可以重新实现这个功能。另外,你也可以提供自己的API来改变数据。</target>
        </trans-unit>
        <trans-unit id="d331f2f6a611d244753300f85e1e74aca09e6fe4" translate="yes" xml:space="preserve">
          <source>If you implement your own model, you can reimplement this function if you want to support insertions. Alternatively, you can provide your own API for altering the data. In either case, you will need to call &lt;a href=&quot;qabstractitemmodel#beginInsertRows&quot;&gt;beginInsertRows&lt;/a&gt;() and &lt;a href=&quot;qabstractitemmodel#endInsertRows&quot;&gt;endInsertRows&lt;/a&gt;() to notify other components that the model has changed.</source>
          <target state="translated">如果实现自己的模型，则如果要支持插入，则可以重新实现此功能。另外，您可以提供自己的API来更改数据。无论哪种情况，您都需要调用&lt;a href=&quot;qabstractitemmodel#beginInsertRows&quot;&gt;beginInsertRows&lt;/a&gt;（）和&lt;a href=&quot;qabstractitemmodel#endInsertRows&quot;&gt;endInsertRows&lt;/a&gt;（）来通知其他组件模型已更改。</target>
        </trans-unit>
        <trans-unit id="106510d50377a8cd03188b6d7c0fd7c458fa892f" translate="yes" xml:space="preserve">
          <source>If you implement your own model, you can reimplement this function if you want to support moving. Alternatively, you can provide your own API for altering the data.</source>
          <target state="translated">如果你实现了自己的模型,如果你想支持移动,你可以重新实现这个功能。另外,你也可以提供自己的API来改变数据。</target>
        </trans-unit>
        <trans-unit id="2edbb20a834141e84df6cf15ba7e897a962af7bb" translate="yes" xml:space="preserve">
          <source>If you implement your own model, you can reimplement this function if you want to support removing. Alternatively, you can provide your own API for altering the data.</source>
          <target state="translated">如果你实现了自己的模型,如果你想支持删除,你可以重新实现这个功能。另外,你也可以提供自己的API来改变数据。</target>
        </trans-unit>
        <trans-unit id="ab60b25c79bdcda285d18c592f7167e340feb06a" translate="yes" xml:space="preserve">
          <source>If you include &amp;lt;QtDebug&amp;gt;, a more convenient syntax is also available:</source>
          <target state="translated">如果包含&amp;lt;QtDebug&amp;gt;，则还可以使用更方便的语法：</target>
        </trans-unit>
        <trans-unit id="207679727f9b11ffb1852492267dde99e64deb5b" translate="yes" xml:space="preserve">
          <source>If you include &lt;code&gt;&amp;lt;QtDebug&amp;gt;&lt;/code&gt;, a more convenient syntax is also available:</source>
          <target state="translated">如果包含 &lt;code&gt;&amp;lt;QtDebug&amp;gt;&lt;/code&gt; ，那么还可以使用更方便的语法：</target>
        </trans-unit>
        <trans-unit id="1c4832ad82817ce9ca13b654baaa7923c3c0c260" translate="yes" xml:space="preserve">
          <source>If you include the &amp;lt;QtDebug&amp;gt; header file, the &lt;code&gt;qDebug()&lt;/code&gt; macro can also be used as an output stream. For example:</source>
          <target state="translated">如果包含&amp;lt;QtDebug&amp;gt;头文件，则 &lt;code&gt;qDebug()&lt;/code&gt; 宏也可以用作输出流。例如：</target>
        </trans-unit>
        <trans-unit id="3ae64c01642f09e9b36108cb089b8bf5e640b581" translate="yes" xml:space="preserve">
          <source>If you include the &lt;code&gt;%L&lt;/code&gt; modifier when you specify a parameter, the number is localized according to the current regional settings. For example, in the following code snippet, &lt;code&gt;%L1&lt;/code&gt; means to format the first parameters according to the number formatting conventions of the currently selected locale (geographical region):</source>
          <target state="translated">如果在指定参数时包括 &lt;code&gt;%L&lt;/code&gt; 修饰符，则数字将根据当前区域设置进行本地化。例如，在以下代码段中， &lt;code&gt;%L1&lt;/code&gt; 表示根据当前所选区域设置（地理区域）的数字格式设置约定来格式化第一个参数：</target>
        </trans-unit>
        <trans-unit id="c35fec5071466912f6e977d5b38d0d1971590123" translate="yes" xml:space="preserve">
          <source>If you include the above in your qdocconf file for qtbase, there will be no class documentation generated for &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt;.</source>
          <target state="translated">如果将上述内容包含在qtbase的qdoc​​conf文件中，则不会为&lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt;生成任何类文档。</target>
        </trans-unit>
        <trans-unit id="1abbd5680dbcffd5c6003dcdc0860cbeaaddf46c" translate="yes" xml:space="preserve">
          <source>If you include the above in your qdocconf file for qtbase, there will be no class documentation generated for &lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;QWidget&lt;/a&gt;.</source>
          <target state="translated">如果将上述内容包含在qtbase的qdoc​​conf文件中，则不会为&lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;QWidget&lt;/a&gt;生成任何类文档。</target>
        </trans-unit>
        <trans-unit id="3103fdd817a46630a8a027a0c13d71ac5ffafc84" translate="yes" xml:space="preserve">
          <source>If you install Clang in a custom location you need to tell CMake where to find it. This can be done by adding the installation path to the &lt;code&gt;CMAKE_PREFIX_PATH&lt;/code&gt; CMake cache variable.</source>
          <target state="translated">如果在自定义位置安装Clang，则需要告诉CMake在哪里找到它。可以通过将安装路径添加到 &lt;code&gt;CMAKE_PREFIX_PATH&lt;/code&gt; CMake缓存变量来完成。</target>
        </trans-unit>
        <trans-unit id="bbdbaeef7f9a11af31f794e5fdc36526ddcc677c" translate="yes" xml:space="preserve">
          <source>If you installed additional OpenGL drivers from your hardware vendor, then you may want to consider using this version of OpenGL instead of ANGLE. To use OpenGL, pass the command line options &lt;code&gt;-opengl desktop&lt;/code&gt; to the configure script.</source>
          <target state="translated">如果您从硬件供应商处安装了其他OpenGL驱动程序，则可能需要考虑使用此版本的OpenGL，而不是ANGLE。要使用OpenGL，请将命令行选项 &lt;code&gt;-opengl desktop&lt;/code&gt; 传递给configure脚本。</target>
        </trans-unit>
        <trans-unit id="ea209d0aa612b39eaf83772d3fa5d10a5ac7f4e1" translate="yes" xml:space="preserve">
          <source>If you intend to use Qt Charts C++ classes in your application, use the following include and using directives:</source>
          <target state="translated">如果你打算在你的应用程序中使用Qt Charts C++类,请使用以下的包含和使用指令。</target>
        </trans-unit>
        <trans-unit id="013cb061ad1d682c520847a81164689a638779b9" translate="yes" xml:space="preserve">
          <source>If you intend to use Qt Data Visualization C++ classes in your application, use the following include and using directives:</source>
          <target state="translated">如果你打算在你的应用程序中使用Qt Data Visualization C++类,请使用以下的include和using指令。</target>
        </trans-unit>
        <trans-unit id="87e83a7a4a4b2cc04ff93e0ccddd6d0ea6f1b471" translate="yes" xml:space="preserve">
          <source>If you intend to use the C++ classes in your application, include the C++ definitions using the following directive:</source>
          <target state="translated">如果你打算在你的应用程序中使用C++类,请使用以下指令包含C++定义。</target>
        </trans-unit>
        <trans-unit id="1c306d26aba22c480b4cb5c9819286c146a14567" translate="yes" xml:space="preserve">
          <source>If you invoke the &lt;a href=&quot;qwidget#show&quot;&gt;show()&lt;/a&gt; function after hiding a dialog, the dialog will be displayed in its original position. This is because the window manager decides the position for windows that have not been explicitly placed by the programmer. To preserve the position of a dialog that has been moved by the user, save its position in your &lt;a href=&quot;qwidget#closeEvent&quot;&gt;closeEvent()&lt;/a&gt; handler and then move the dialog to that position, before showing it again.</source>
          <target state="translated">如果在隐藏对话框后调用&lt;a href=&quot;qwidget#show&quot;&gt;show（）&lt;/a&gt;函数，该对话框将以其原始位置显示。这是因为窗口管理器决定了程序员未明确放置的窗口的位置。要保留用户已移动的对话框的位置，请将其位置保存在&lt;a href=&quot;qwidget#closeEvent&quot;&gt;closeEvent（）&lt;/a&gt;处理程序中，然后将对话框移至该位置，然后再次显示它。</target>
        </trans-unit>
        <trans-unit id="0f804f726a66c4e54a56a123b766c3508c288994" translate="yes" xml:space="preserve">
          <source>If you just need to display a small piece of rich text use &lt;a href=&quot;qlabel&quot;&gt;QLabel&lt;/a&gt;.</source>
          <target state="translated">如果只需要显示一小段富文本，请使用&lt;a href=&quot;qlabel&quot;&gt;QLabel&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="671426a4ddfca9ca8181c499337c24b4302d8c51" translate="yes" xml:space="preserve">
          <source>If you just want to iterate over all the items in a container in order, you can use Qt's &lt;code&gt;foreach&lt;/code&gt; keyword. The keyword is a Qt-specific addition to the C++ language, and is implemented using the preprocessor.</source>
          <target state="translated">如果只想按顺序遍历容器中的所有项目，则可以使用Qt的 &lt;code&gt;foreach&lt;/code&gt; 关键字。关键字是Qt特定于C ++语言的添加，并使用预处理器实现。</target>
        </trans-unit>
        <trans-unit id="5d1a6fde8942f05249887dbeaacee61a0c4df298" translate="yes" xml:space="preserve">
          <source>If you just want to serialize your XML in a human-readable format, use &lt;a href=&quot;qxmlformatter&quot;&gt;QXmlFormatter&lt;/a&gt; as it is. The default indentation level is 4 spaces, but you can set your own indentation value &lt;a href=&quot;qxmlformatter#setIndentationDepth&quot;&gt;setIndentationDepth&lt;/a&gt;().</source>
          <target state="translated">如果只想以人类可读的格式序列化XML，请按&lt;a href=&quot;qxmlformatter&quot;&gt;原样&lt;/a&gt;使用QXmlFormatter。默认缩进级别为4个空格，但是您可以设置自己的缩进值&lt;a href=&quot;qxmlformatter#setIndentationDepth&quot;&gt;setIndentationDepth&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="f5e6b735305931f1169ec0c149ee824c73679192" translate="yes" xml:space="preserve">
          <source>If you just want to serialize your XML in a human-readable format, use QXmlFormatter as it is. The default indentation level is 4 spaces, but you can set your own indentation value &lt;a href=&quot;qxmlformatter#setIndentationDepth&quot;&gt;setIndentationDepth&lt;/a&gt;().</source>
          <target state="translated">如果只想以人类可读的格式序列化XML，请按原样使用QXmlFormatter。默认缩进级别为4个空格，但是您可以设置自己的缩进值&lt;a href=&quot;qxmlformatter#setIndentationDepth&quot;&gt;setIndentationDepth&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="46e56bf216eac5daf92da5b89455b45f437042ff" translate="yes" xml:space="preserve">
          <source>If you just want to store a single text block (i.e., a &quot;comment&quot; or just a description), you can either pass an empty key, or use a generic key like &quot;Description&quot;.</source>
          <target state="translated">如果你只是想存储一个单一的文本块(例如,一个 &quot;评论 &quot;或只是一个描述),你可以传递一个空键,或者使用一个通用键,如 &quot;描述&quot;。</target>
        </trans-unit>
        <trans-unit id="2b0f8112d0bacf60286bec0b9fdae8d2d17d85e7" translate="yes" xml:space="preserve">
          <source>If you know approximately how many items you will store in a container, you can start by calling &lt;a href=&quot;qstring#reserve&quot;&gt;reserve()&lt;/a&gt;, and when you are done populating the container, you can call &lt;a href=&quot;qstring#squeeze&quot;&gt;squeeze()&lt;/a&gt; to release the extra preallocated memory.</source>
          <target state="translated">如果您知道将在一个容器中存储大约多少个项目，则可以通过调用&lt;a href=&quot;qstring#reserve&quot;&gt;reserve（）开始&lt;/a&gt;，并在完成容器的填充后，可以调用&lt;a href=&quot;qstring#squeeze&quot;&gt;squeeze（）&lt;/a&gt;释放额外的预分配内存。</target>
        </trans-unit>
        <trans-unit id="e506536703fb7f20a6bdf79b9f8f4456e55d8b44" translate="yes" xml:space="preserve">
          <source>If you know in advance approximately how many items the &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt; will contain, you can call &lt;a href=&quot;qvector#reserve&quot;&gt;reserve&lt;/a&gt;(), asking &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt; to preallocate a certain amount of memory. You can also call &lt;a href=&quot;qvector#capacity&quot;&gt;capacity&lt;/a&gt;() to find out how much memory &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt; actually allocated.</source>
          <target state="translated">如果您事先知道&lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt;大约包含多少个项目，则可以调用&lt;a href=&quot;qvector#reserve&quot;&gt;reserve&lt;/a&gt;（），要求&lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt;预分配一定数量的内存。您也可以拨打&lt;a href=&quot;qvector#capacity&quot;&gt;容量&lt;/a&gt;（）来找出多少内存&lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt;实际分配。</target>
        </trans-unit>
        <trans-unit id="432767fcac192bebe7770952f060a5be63ab630e" translate="yes" xml:space="preserve">
          <source>If you know in advance approximately how many items the QList will contain, you can call &lt;a href=&quot;qlist#reserve&quot;&gt;reserve&lt;/a&gt;(), asking QList to preallocate a certain amount of memory. You can also call &lt;a href=&quot;qlist#capacity&quot;&gt;capacity&lt;/a&gt;() to find out how much memory QList actually allocated.</source>
          <target state="translated">如果您事先知道QList将包含多少个项目，则可以调用&lt;a href=&quot;qlist#reserve&quot;&gt;reserve&lt;/a&gt;（），要求QList预分配一定数量的内存。您也可以拨打&lt;a href=&quot;qlist#capacity&quot;&gt;容量&lt;/a&gt;（）来找出多少内存的QList实际分配。</target>
        </trans-unit>
        <trans-unit id="8831f5eaa089dd7af7e487dc3ee126943c7239ab" translate="yes" xml:space="preserve">
          <source>If you know in advance approximately how many items the QVector will contain, you can call &lt;a href=&quot;qvector#reserve&quot;&gt;reserve&lt;/a&gt;(), asking QVector to preallocate a certain amount of memory. You can also call &lt;a href=&quot;qvector#capacity&quot;&gt;capacity&lt;/a&gt;() to find out how much memory QVector actually allocated.</source>
          <target state="translated">如果您事先知道QVector将包含多少个项目，则可以调用&lt;a href=&quot;qvector#reserve&quot;&gt;reserve&lt;/a&gt;（），要求QVector预分配一定数量的内存。您也可以拨打&lt;a href=&quot;qvector#capacity&quot;&gt;容量&lt;/a&gt;（）来找出多少内存QVector实际分配。</target>
        </trans-unit>
        <trans-unit id="5b0ab01e4eafc43d1dabeb4a0ac0f5fa01c4c896" translate="yes" xml:space="preserve">
          <source>If you know in advance how large the byte array will be, you can call this function, and if you call &lt;a href=&quot;qbytearray#resize&quot;&gt;resize&lt;/a&gt;() often you are likely to get better performance.</source>
          <target state="translated">如果事先知道字节数组将有多大，则可以调用此函数，并且如果调用&lt;a href=&quot;qbytearray#resize&quot;&gt;resize&lt;/a&gt;（），通常可能会获得更好的性能。</target>
        </trans-unit>
        <trans-unit id="3e864d54faac7f1116f076f7891b2cba9fa0387e" translate="yes" xml:space="preserve">
          <source>If you know that</source>
          <target state="translated">如果你知道</target>
        </trans-unit>
        <trans-unit id="25543a785b45632b691af66aeb9dcf2a862fd0af" translate="yes" xml:space="preserve">
          <source>If you know up front what the height of the table will be, assign a value to &lt;code&gt;contentHeight&lt;/code&gt; explicitly, to avoid unnecessary calculations and updates to the &lt;a href=&quot;qml-qtquick-tableview&quot;&gt;TableView&lt;/a&gt;.</source>
          <target state="translated">如果您预先知道表格的高度，请为 &lt;code&gt;contentHeight&lt;/code&gt; 明确分配一个值，以避免不必要的计算和对&lt;a href=&quot;qml-qtquick-tableview&quot;&gt;TableView的&lt;/a&gt;更新。</target>
        </trans-unit>
        <trans-unit id="76ecbbf6e35548252c0274214fd7812d5146cce6" translate="yes" xml:space="preserve">
          <source>If you know up front what the width of the table will be, assign a value to &lt;code&gt;contentWidth&lt;/code&gt; explicitly, to avoid unnecessary calculations and updates to the &lt;a href=&quot;qml-qtquick-tableview&quot;&gt;TableView&lt;/a&gt;.</source>
          <target state="translated">如果您预先知道表的宽度，请为 &lt;code&gt;contentWidth&lt;/code&gt; 显式分配一个值，以避免不必要的计算和对&lt;a href=&quot;qml-qtquick-tableview&quot;&gt;TableView的&lt;/a&gt;更新。</target>
        </trans-unit>
        <trans-unit id="a21f5df05b7a59948adea2c8aabebcdcb02fc17d" translate="yes" xml:space="preserve">
          <source>If you know what the height of the table will be, assign a value to &lt;code&gt;contentHeight&lt;/code&gt;, to avoid unnecessary calculations and updates to the &lt;a href=&quot;qml-qtquick-tableview&quot;&gt;TableView&lt;/a&gt;.</source>
          <target state="translated">如果您知道表格的高度，请为 &lt;code&gt;contentHeight&lt;/code&gt; 分配一个值，以避免不必要的计算和对&lt;a href=&quot;qml-qtquick-tableview&quot;&gt;TableView的&lt;/a&gt;更新。</target>
        </trans-unit>
        <trans-unit id="da9dad8a9f3c1ee9f030f201321dc8473a9e4658" translate="yes" xml:space="preserve">
          <source>If you know what the width of the table will be, assign a value to &lt;code&gt;contentWidth&lt;/code&gt;, to avoid unnecessary calculations and updates to the &lt;a href=&quot;qml-qtquick-tableview&quot;&gt;TableView&lt;/a&gt;.</source>
          <target state="translated">如果您知道表格的宽度，请为 &lt;code&gt;contentWidth&lt;/code&gt; 分配一个值，以避免不必要的计算和对&lt;a href=&quot;qml-qtquick-tableview&quot;&gt;TableView的&lt;/a&gt;更新。</target>
        </trans-unit>
        <trans-unit id="9f92abc2a00b2f80db551ba62e402726d7c10657" translate="yes" xml:space="preserve">
          <source>If you later on convert the returned html string into a byte array for transmission over a network or when saving to disk you should specify the encoding you're going to use for the conversion to a byte array here.</source>
          <target state="translated">如果您稍后将返回的 html 字符串转换为一个字节数组,以便在网络上传输或保存到磁盘上,您应该在这里指定您将使用的编码来转换为一个字节数组。</target>
        </trans-unit>
        <trans-unit id="e7c0048e898893a6e5d1c8cb46448f039b953244" translate="yes" xml:space="preserve">
          <source>If you lazy load components, or create objects dynamically during a JavaScript expression, it is often better to &lt;code&gt;destroy()&lt;/code&gt; them manually rather than wait for automatic garbage collection to do so. See the prior section on &lt;a href=&quot;#controlling-element-lifetime&quot;&gt;Controlling Element Lifetime&lt;/a&gt; for more information.</source>
          <target state="translated">如果您懒惰加载组件，或者在JavaScript表达式中动态创建对象，通常最好手动 &lt;code&gt;destroy()&lt;/code&gt; 它们，而不是等待自动垃圾收集这样做。有关更多信息，请参见&lt;a href=&quot;#controlling-element-lifetime&quot;&gt;控制元素生存&lt;/a&gt;期的前一部分。</target>
        </trans-unit>
        <trans-unit id="b09d8f8ae798436ff1127b350907c3434183e173" translate="yes" xml:space="preserve">
          <source>If you lazy load components, or create objects dynamically during a JavaScript expression, it is often better to &lt;code&gt;destroy()&lt;/code&gt; them manually rather than wait for automatic garbage collection to do so. See the prior section on &lt;a href=&quot;qtquick-performance#controlling-element-lifetime&quot;&gt;Controlling Element Lifetime&lt;/a&gt; for more information.</source>
          <target state="translated">如果您懒加载组件，或者在JavaScript表达式中动态创建对象，通常最好手动 &lt;code&gt;destroy()&lt;/code&gt; 它们，而不是等待自动垃圾收集这样做。有关更多信息，请参见上一节&amp;ldquo;&lt;a href=&quot;qtquick-performance#controlling-element-lifetime&quot;&gt;控制元素的生存时间&lt;/a&gt;&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="f1b6e142a71a05aa00ba5bae3b0b5f2ae89756c9" translate="yes" xml:space="preserve">
          <source>If you leave out</source>
          <target state="translated">如果你撇开</target>
        </trans-unit>
        <trans-unit id="2db783b80ff1020ccaceac55ba2023405ff45002" translate="yes" xml:space="preserve">
          <source>If you make a mistake, simply double click outside of any number or choose &lt;b&gt;Restart&lt;/b&gt; from the form's context menu to start again. If you have many widgets on your form and would like to change the tab order in the middle or at the end of the tab order chain, you can edit it at any position. Press &lt;b&gt;Ctrl&lt;/b&gt; and click the number from which you want to start. Alternatively, choose &lt;b&gt;Start from Here&lt;/b&gt; in the context menu.</source>
          <target state="translated">如果输入有误，只需在任意数字之外双击​​即可，或从表单的上下文菜单中选择&amp;ldquo; &lt;b&gt;重新启动&lt;/b&gt; &amp;rdquo;以&lt;b&gt;重新&lt;/b&gt;启动。如果表单上有许多小部件，并且想在标签顺序链的中间或末尾更改标签顺序，则可以在任何位置进行编辑。按&lt;b&gt;Ctrl键&lt;/b&gt;，然后单击要从其开始的数字。或者，在上下文菜单中选择&amp;ldquo; &lt;b&gt;从这里开始&amp;rdquo;&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="d6243f8fa37fa62c4ab8dc9f019c9d4a49cb12c4" translate="yes" xml:space="preserve">
          <source>If you modify a primary key, the record might slip through your fingers while you are trying to populate it.</source>
          <target state="translated">如果你修改了一个主键,记录可能会在你试图填充它时从你的手指中溜走。</target>
        </trans-unit>
        <trans-unit id="fee78d1a8d6e37dec838fcf815b60c25dd57ea2e" translate="yes" xml:space="preserve">
          <source>If you move the widget as a result of the mouse event, use the global position returned by &lt;a href=&quot;qmouseevent#globalPos&quot;&gt;globalPos&lt;/a&gt;() to avoid a shaking motion.</source>
          <target state="translated">如果由于鼠标事件而移动了窗口小部件，请使用&lt;a href=&quot;qmouseevent#globalPos&quot;&gt;globalPos&lt;/a&gt;（）返回的全局位置以避免晃动。</target>
        </trans-unit>
        <trans-unit id="48836d76f845406462aa8231c83942c16a308fb1" translate="yes" xml:space="preserve">
          <source>If you move the widget as a result of the mouse event, use the screen position returned by &lt;a href=&quot;qmouseevent#screenPos&quot;&gt;screenPos&lt;/a&gt;() to avoid a shaking motion.</source>
          <target state="translated">如果由于鼠标事件而移动了窗口小部件，请使用&lt;a href=&quot;qmouseevent#screenPos&quot;&gt;screenPos&lt;/a&gt;（）返回的屏幕位置以避免晃动。</target>
        </trans-unit>
        <trans-unit id="a94049d4fb9f710d3ac1e5672cbaf20893df6f70" translate="yes" xml:space="preserve">
          <source>If you move widgets around in response to mouse events, use &lt;a href=&quot;qtabletevent#globalPos&quot;&gt;globalPos&lt;/a&gt;() instead of this function.</source>
          <target state="translated">如果为了响应鼠标事件而移动窗口小部件，请使用&lt;a href=&quot;qtabletevent#globalPos&quot;&gt;globalPos&lt;/a&gt;（）代替此函数。</target>
        </trans-unit>
        <trans-unit id="1cb7bd27fb2afab61fc9d90a41c1cc5333493ec1" translate="yes" xml:space="preserve">
          <source>If you move widgets around in response to mouse events, use &lt;a href=&quot;qtabletevent#globalPosF&quot;&gt;globalPosF&lt;/a&gt;() instead of this function.</source>
          <target state="translated">如果为了响应鼠标事件而移动窗口小部件，请使用&lt;a href=&quot;qtabletevent#globalPosF&quot;&gt;globalPosF&lt;/a&gt;（）代替此函数。</target>
        </trans-unit>
        <trans-unit id="83c0aad04edd004e9e13c72746c9d3a127af846a" translate="yes" xml:space="preserve">
          <source>If you move your widgets around in response to mouse events, use &lt;a href=&quot;qsinglepointevent#globalPosition&quot;&gt;globalPosition&lt;/a&gt;() instead.</source>
          <target state="translated">如果为了响应鼠标事件而移动窗口小部件，请改用&lt;a href=&quot;qsinglepointevent#globalPosition&quot;&gt;globalPosition&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="bc1189230837866bd16163177bf8f8b92b690b0f" translate="yes" xml:space="preserve">
          <source>If you move your widgets around in response to mouse events, use &lt;a href=&quot;qwheelevent#globalPos&quot;&gt;globalPos&lt;/a&gt;() instead of this function.</source>
          <target state="translated">如果为了响应鼠标事件而移动窗口小部件，请使用&lt;a href=&quot;qwheelevent#globalPos&quot;&gt;globalPos&lt;/a&gt;（）代替此函数。</target>
        </trans-unit>
        <trans-unit id="69ef74d3f62546691122624c9d6b9996fde5f307" translate="yes" xml:space="preserve">
          <source>If you move your widgets around in response to mouse events, use &lt;a href=&quot;qwheelevent#globalPosF&quot;&gt;globalPosF&lt;/a&gt;() instead of this function.</source>
          <target state="translated">如果为了响应鼠标事件而移动窗口小部件，请使用&lt;a href=&quot;qwheelevent#globalPosF&quot;&gt;globalPosF&lt;/a&gt;（）代替此函数。</target>
        </trans-unit>
        <trans-unit id="37276a6f0cbfcd4889e785a9d12618f9eb2622ef" translate="yes" xml:space="preserve">
          <source>If you move your widgets around in response to mouse events, use &lt;a href=&quot;qwheelevent#globalPosition&quot;&gt;globalPosition&lt;/a&gt;() instead of this function.</source>
          <target state="translated">如果为了响应鼠标事件而移动窗口小部件，请使用&lt;a href=&quot;qwheelevent#globalPosition&quot;&gt;globalPosition&lt;/a&gt;（）代替此函数。</target>
        </trans-unit>
        <trans-unit id="98398f110a351968fea2d7f0aafa7392066d7e46" translate="yes" xml:space="preserve">
          <source>If you must expose a &lt;a href=&quot;qvariant#QVariantMap-typedef&quot;&gt;QVariantMap&lt;/a&gt; to QML, use a &quot;var&quot; property rather than a &quot;variant&quot; property. In general, &quot;property var&quot; should be considered to be superior to &quot;property variant&quot; for every use-case from &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-qmlmodule.html&quot;&gt;QtQuick&lt;/a&gt; 2.0 and newer (note that &quot;property variant&quot; is marked as obsolete), as it allows a true JavaScript reference to be stored (which can reduce the number of conversions required in certain expressions).</source>
          <target state="translated">如果必须将&lt;a href=&quot;qvariant#QVariantMap-typedef&quot;&gt;QVariantMap&lt;/a&gt;公开给QML，请使用&amp;ldquo; var&amp;rdquo;属性而不是&amp;ldquo; variant&amp;rdquo;属性。通常，对于&lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-qmlmodule.html&quot;&gt;QtQuick&lt;/a&gt; 2.0及更高版本中的每个用例，&amp;ldquo; property var&amp;rdquo;都应被认为优于&amp;ldquo; propertyvariant&amp;rdquo; （请注意，&amp;ldquo; property variant&amp;rdquo;被标记为已过时），因为它允许使用真正的JavaScript引用。存储（可以减少某些表达式中所需的转换次数）。</target>
        </trans-unit>
        <trans-unit id="05f329b89fe9ff3851a650a9b125b5ec499ab13b" translate="yes" xml:space="preserve">
          <source>If you must expose a &lt;a href=&quot;qvariant#QVariantMap-typedef&quot;&gt;QVariantMap&lt;/a&gt; to QML, use a &quot;var&quot; property rather than a &quot;variant&quot; property. In general, &quot;property var&quot; should be considered to be superior to &quot;property variant&quot; for every use-case from &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtquick-module.html&quot;&gt;QtQuick&lt;/a&gt; 2.0 and newer (note that &quot;property variant&quot; is marked as obsolete), as it allows a true JavaScript reference to be stored (which can reduce the number of conversions required in certain expressions).</source>
          <target state="translated">如果必须将&lt;a href=&quot;qvariant#QVariantMap-typedef&quot;&gt;QVariantMap&lt;/a&gt;公开给QML，请使用&amp;ldquo; var&amp;rdquo;属性而不是&amp;ldquo; variant&amp;rdquo;属性。通常，对于&lt;a href=&quot;https://doc.qt.io/qt-5.15/qtquick-module.html&quot;&gt;QtQuick&lt;/a&gt; 2.0及更高版本中的每个用例，&amp;ldquo; property var&amp;rdquo;都应被认为优于&amp;ldquo; propertyvariant&amp;rdquo; （请注意，&amp;ldquo; property variant&amp;rdquo;被标记为已过时），因为它允许使用真正的JavaScript引用。存储（可以减少某些表达式中所需的转换次数）。</target>
        </trans-unit>
        <trans-unit id="55733338828e7c2187d64767b31ca3e4f75f2727" translate="yes" xml:space="preserve">
          <source>If you must expose a &lt;a href=&quot;qvariant#QVariantMap-typedef&quot;&gt;QVariantMap&lt;/a&gt; to QML, use a &quot;var&quot; property rather than a &quot;variant&quot; property. In general, &quot;property var&quot; should be considered to be superior to &quot;property variant&quot; for every use-case from &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtquick-module.html&quot;&gt;QtQuick&lt;/a&gt; 2.0 and newer (note that &quot;property variant&quot; is marked as obsolete), as it allows a true JavaScript reference to be stored (which can reduce the number of conversions required in certain expressions).</source>
          <target state="translated">如果必须将&lt;a href=&quot;qvariant#QVariantMap-typedef&quot;&gt;QVariantMap&lt;/a&gt;公开给QML，请使用&amp;ldquo; var&amp;rdquo;属性而不是&amp;ldquo; variant&amp;rdquo;属性。通常，对于&lt;a href=&quot;https://doc.qt.io/qt-6.0/qtquick-module.html&quot;&gt;QtQuick&lt;/a&gt; 2.0及更高版本中的每个用例，&amp;ldquo; property var&amp;rdquo;都应被认为优于&amp;ldquo; propertyvariant&amp;rdquo; （请注意，&amp;ldquo; property variant&amp;rdquo;被标记为已过时），因为它允许使用真正的JavaScript引用。存储（可以减少某些表达式中所需的转换次数）。</target>
        </trans-unit>
        <trans-unit id="c2d2d4d5382a8845849da6e1184539b78f29d016" translate="yes" xml:space="preserve">
          <source>If you navigate within a result set, and use next() and seek() only for browsing forward, you can call &lt;a href=&quot;qsqlquery#setForwardOnly&quot;&gt;QSqlQuery::setForwardOnly&lt;/a&gt;(true) before calling exec(). This is an easy optimization that will speed up the query significantly when operating on large result sets.</source>
          <target state="translated">如果在结果集中导航，并且仅将next（）和seek（）用于向前浏览，则可以在调用exec（）之前调用&lt;a href=&quot;qsqlquery#setForwardOnly&quot;&gt;QSqlQuery :: setForwardOnly&lt;/a&gt;（true）。这是一个简单的优化，在处理大型结果集时将大大加快查询速度。</target>
        </trans-unit>
        <trans-unit id="f0be1ad7bf98429079625ea60af0aa6a3256b39e" translate="yes" xml:space="preserve">
          <source>If you need C++11 noexcept semantics, don't use this macro, use &lt;a href=&quot;qtglobal#Q_DECL_NOEXCEPT&quot;&gt;Q_DECL_NOEXCEPT&lt;/a&gt;/&lt;a href=&quot;qtglobal#Q_DECL_NOEXCEPT_EXPR&quot;&gt;Q_DECL_NOEXCEPT_EXPR&lt;/a&gt; instead.</source>
          <target state="translated">如果您需要C ++ 11 noexcept语义，请不要使用此宏，而应使用&lt;a href=&quot;qtglobal#Q_DECL_NOEXCEPT&quot;&gt;Q_DECL_NOEXCEPT&lt;/a&gt; / &lt;a href=&quot;qtglobal#Q_DECL_NOEXCEPT_EXPR&quot;&gt;Q_DECL_NOEXCEPT_EXPR&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5ead8b6ac852866dc1489d0e461e4bf87214a911" translate="yes" xml:space="preserve">
          <source>If you need a custom label, you can replace the label item.</source>
          <target state="translated">如果你需要定制标签,可以更换标签项目。</target>
        </trans-unit>
        <trans-unit id="c8c746c5663479d6496c060d0ca18d654d964dd4" translate="yes" xml:space="preserve">
          <source>If you need a custom transport protocol for Qt Remote Objects, you need to register the client &amp;amp; server implementation here.</source>
          <target state="translated">如果您需要Qt远程对象的自定义传输协议，则需要在此处注册客户端和服务器实现。</target>
        </trans-unit>
        <trans-unit id="1cf280db22d6d52488b60a0e249b954f6baf900f" translate="yes" xml:space="preserve">
          <source>If you need a model to use with an item view such as QML's List View element or the C++ widgets &lt;a href=&quot;qlistview&quot;&gt;QListView&lt;/a&gt; or &lt;a href=&quot;qtableview&quot;&gt;QTableView&lt;/a&gt;, you should consider subclassing &lt;a href=&quot;qabstractlistmodel&quot;&gt;QAbstractListModel&lt;/a&gt; or &lt;a href=&quot;qabstracttablemodel&quot;&gt;QAbstractTableModel&lt;/a&gt; instead of this class.</source>
          <target state="translated">如果您需要一个用于项目视图的模型，例如QML的List View元素或C ++小部件&lt;a href=&quot;qlistview&quot;&gt;QListView&lt;/a&gt;或&lt;a href=&quot;qtableview&quot;&gt;QTableView&lt;/a&gt;，则应考虑继承&lt;a href=&quot;qabstractlistmodel&quot;&gt;QAbstractListModel&lt;/a&gt;或&lt;a href=&quot;qabstracttablemodel&quot;&gt;QAbstractTableModel&lt;/a&gt;而不是此类。</target>
        </trans-unit>
        <trans-unit id="bb7be3fd0c46756019cfdb4476764790df813f72" translate="yes" xml:space="preserve">
          <source>If you need a more specific run-time error to describe an exception, you can use the &lt;a href=&quot;qjsengine#throwError-1&quot;&gt;throwError(QJSValue::ErrorType errorType, const QString &amp;amp;message)&lt;/a&gt; overload.</source>
          <target state="translated">如果您需要更具体的运行时错误来描述异常，则可以使用&lt;a href=&quot;qjsengine#throwError-1&quot;&gt;throwError（QJSValue :: ErrorType errorType，const QString＆message）&lt;/a&gt;重载。</target>
        </trans-unit>
        <trans-unit id="c5ab13ffd4dd0d04293eb4de3600e7136f20fb6d" translate="yes" xml:space="preserve">
          <source>If you need a real linked list, which guarantees &lt;a href=&quot;containers#algorithmic-complexity&quot;&gt;constant time&lt;/a&gt; insertions mid-list and uses iterators to items rather than indexes, use &lt;a href=&quot;qlinkedlist&quot;&gt;QLinkedList&lt;/a&gt;.</source>
          <target state="translated">如果您需要一个真正的链表，该链表可以保证在列表中插入&lt;a href=&quot;containers#algorithmic-complexity&quot;&gt;固定时间&lt;/a&gt;并使用迭代器而不是索引，请使用&lt;a href=&quot;qlinkedlist&quot;&gt;QLinkedList&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="18b41a817247a2fdc5d60d915b10338355018e11" translate="yes" xml:space="preserve">
          <source>If you need a real linked list, which guarantees &lt;a href=&quot;containers#algorithmic-complexity&quot;&gt;constant time&lt;/a&gt; insertions mid-list and uses iterators to items rather than indexes, use QLinkedList.</source>
          <target state="translated">如果您需要一个真正的链表，该链表可保证在列表中插入&lt;a href=&quot;containers#algorithmic-complexity&quot;&gt;固定时间&lt;/a&gt;并使用迭代器而不是索引，请使用QLinkedList。</target>
        </trans-unit>
        <trans-unit id="c473b66882c7a635a7ee5e44106b0098b8eb1668" translate="yes" xml:space="preserve">
          <source>If you need a real linked list, which guarantees &lt;a href=&quot;containers#algorithmic-complexity&quot;&gt;constant time&lt;/a&gt; insertions mid-list and uses iterators to items rather than indexes, use std::list.</source>
          <target state="translated">如果您需要一个真正的链表，该链表可保证在列表中插入&lt;a href=&quot;containers#algorithmic-complexity&quot;&gt;固定时间&lt;/a&gt;并使用迭代器而不是索引，请使用std :: list。</target>
        </trans-unit>
        <trans-unit id="82835375128e32f063444bcf40d34143273bf20c" translate="yes" xml:space="preserve">
          <source>If you need a real linked list, with guarantees of &lt;a href=&quot;containers#constant-time&quot;&gt;constant time&lt;/a&gt; insertions in the middle of the list and iterators to items rather than indexes, use &lt;a href=&quot;qlinkedlist&quot;&gt;QLinkedList&lt;/a&gt;.</source>
          <target state="translated">如果您需要一个真正的链表，并且要保证在链表中间&lt;a href=&quot;containers#constant-time&quot;&gt;不断&lt;/a&gt;插入时间，并且可以迭代到项而不是索引，请使用&lt;a href=&quot;qlinkedlist&quot;&gt;QLinkedList&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="647c12208e77ed45041182e96e8e5a6527760d13" translate="yes" xml:space="preserve">
          <source>If you need a real linked list, with guarantees of &lt;a href=&quot;containers#constant-time&quot;&gt;constant time&lt;/a&gt; insertions in the middle of the list and iterators to items rather than indexes, use QLinkedList.</source>
          <target state="translated">如果您需要一个真实的链表，并且要保证在链表的中间有&lt;a href=&quot;containers#constant-time&quot;&gt;固定的时间&lt;/a&gt;插入，并且可以迭代到项而不是索引，请使用QLinkedList。</target>
        </trans-unit>
        <trans-unit id="449ac37f3ec502739738b80b8c9304f044771abf" translate="yes" xml:space="preserve">
          <source>If you need even more complex behavior than can be achieved with combinations of multiple handlers with multiple modifier flags, you can check the modifiers in JavaScript code:</source>
          <target state="translated">如果你需要更复杂的行为,而不是用多个修饰符标志的多个处理程序的组合来实现,你可以在JavaScript代码中检查修饰符。</target>
        </trans-unit>
        <trans-unit id="ae62ee476f6be8ba03c585936179280826e4656d" translate="yes" xml:space="preserve">
          <source>If you need full-control over how the projection matrix is created, this is the camera to use.</source>
          <target state="translated">如果您需要完全控制投影矩阵的创建方式,就可以使用这款摄像机。</target>
        </trans-unit>
        <trans-unit id="2ff7766b8126fa8cbc1466fed1f0e58190dcb2a0" translate="yes" xml:space="preserve">
          <source>If you need only to find out if the service is registered or unregistered only, without being notified that the ownership changed, consider using the specific modes for those operations. This class is more efficient if you use the more specific modes.</source>
          <target state="translated">如果你只需要找出服务是注册还是未注册,而不需要被通知所有权发生了变化,可以考虑使用这些操作的特定模式。如果你使用更具体的模式,这个类的效率会更高。</target>
        </trans-unit>
        <trans-unit id="ccbe8ac683ad87263216c93c889911927b43a223" translate="yes" xml:space="preserve">
          <source>If you need the always-true version of C++11 noexcept, use &lt;a href=&quot;qtglobal#Q_DECL_NOEXCEPT&quot;&gt;Q_DECL_NOEXCEPT&lt;/a&gt;.</source>
          <target state="translated">如果您需要C ++ 11 noexcept的永远真实版本，请使用&lt;a href=&quot;qtglobal#Q_DECL_NOEXCEPT&quot;&gt;Q_DECL_NOEXCEPT&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cba64fb8058145d48a493bb7b0fd35b6484109d5" translate="yes" xml:space="preserve">
          <source>If you need the operator version of C++11 noexcept, use &lt;a href=&quot;qtglobal#Q_DECL_NOEXCEPT_EXPR&quot;&gt;Q_DECL_NOEXCEPT_EXPR&lt;/a&gt;(x).</source>
          <target state="translated">如果需要C ++ 11 nooperator版本，请使用&lt;a href=&quot;qtglobal#Q_DECL_NOEXCEPT_EXPR&quot;&gt;Q_DECL_NOEXCEPT_EXPR&lt;/a&gt;（x）。</target>
        </trans-unit>
        <trans-unit id="9ee8c3221c99146b0e5e11193014fd65ae082d49" translate="yes" xml:space="preserve">
          <source>If you need the same transformations over and over, you can also use &lt;a href=&quot;qtransform&quot;&gt;QTransform&lt;/a&gt; objects and the &lt;a href=&quot;qpainter#worldTransform&quot;&gt;QPainter::worldTransform&lt;/a&gt;() and &lt;a href=&quot;qpainter#setWorldTransform&quot;&gt;QPainter::setWorldTransform&lt;/a&gt;() functions. You can at any time save the &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;'s transformation matrix by calling the &lt;a href=&quot;qpainter#save&quot;&gt;QPainter::save&lt;/a&gt;() function which saves the matrix on an internal stack. The &lt;a href=&quot;qpainter#restore&quot;&gt;QPainter::restore&lt;/a&gt;() function pops it back.</source>
          <target state="translated">如果需要反复进行相同的转换，则还可以使用&lt;a href=&quot;qtransform&quot;&gt;QTransform&lt;/a&gt;对象以及&lt;a href=&quot;qpainter#worldTransform&quot;&gt;QPainter :: worldTransform&lt;/a&gt;（）和&lt;a href=&quot;qpainter#setWorldTransform&quot;&gt;QPainter :: setWorldTransform&lt;/a&gt;（）函数。您可以随时调用&lt;a href=&quot;qpainter#save&quot;&gt;QPainter :: save&lt;/a&gt;（）函数来保存&lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;的转换矩阵，该函数将矩阵保存在内部堆栈中。该&lt;a href=&quot;qpainter#restore&quot;&gt;QPainter的::恢复&lt;/a&gt;（）函数弹出回来。</target>
        </trans-unit>
        <trans-unit id="957945d5b8560d51a2336561d3b078926428d4e6" translate="yes" xml:space="preserve">
          <source>If you need to access properties or pass parameters of unsupported datatypes you must access the COM object directly through its &lt;code&gt;IDispatch&lt;/code&gt; implementation or other interfaces. Those interfaces can be retrieved through &lt;a href=&quot;qaxbase#queryInterface&quot;&gt;queryInterface&lt;/a&gt;().</source>
          <target state="translated">如果需要访问属性或传递不受支持的数据类型的参数，则必须直接通过其 &lt;code&gt;IDispatch&lt;/code&gt; 实现或其他接口访问COM对象。可以通过&lt;a href=&quot;qaxbase#queryInterface&quot;&gt;queryInterface&lt;/a&gt;（）检索这些接口。</target>
        </trans-unit>
        <trans-unit id="0f5b04a0753b7c48a75e79fc700b949642ace0fd" translate="yes" xml:space="preserve">
          <source>If you need to change some settings when a widget is polished, reimplement &lt;a href=&quot;qwidget#event&quot;&gt;event&lt;/a&gt;() and handle the &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::Polish&lt;/a&gt; event type.</source>
          <target state="translated">如果您需要在小部件抛光时更改某些设置，请重新实现&lt;a href=&quot;qwidget#event&quot;&gt;事件&lt;/a&gt;（）并处理&lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent :: Polish&lt;/a&gt;事件类型。</target>
        </trans-unit>
        <trans-unit id="a69bdfba6ff23a4b4157931795226cafaa943e60" translate="yes" xml:space="preserve">
          <source>If you need to determine whether an object is an instance of a particular class for the purpose of casting it, consider using &lt;a href=&quot;qobject#qobject_cast&quot;&gt;qobject_cast&lt;/a&gt;&amp;lt;Type *&amp;gt;(object) instead.</source>
          <target state="translated">如果您需要确定某个对象是否是特定类的实例以进行转换，请考虑改用&lt;a href=&quot;qobject#qobject_cast&quot;&gt;qobject_cast&lt;/a&gt; &amp;lt;Type *&amp;gt;（object）。</target>
        </trans-unit>
        <trans-unit id="7189bef7b3a3389b6825b2a88460691d1aa98363" translate="yes" xml:space="preserve">
          <source>If you need to draw a complex shape, especially if you need to do so repeatedly, consider creating a &lt;a href=&quot;qpainterpath&quot;&gt;QPainterPath&lt;/a&gt; and drawing it using &lt;a href=&quot;qpainter#drawPath&quot;&gt;drawPath&lt;/a&gt;().</source>
          <target state="translated">如果您需要绘制复杂的形状，尤其是需要重复绘制，请考虑创建一个&lt;a href=&quot;qpainterpath&quot;&gt;QPainterPath&lt;/a&gt;并使用&lt;a href=&quot;qpainter#drawPath&quot;&gt;drawPath&lt;/a&gt;（）对其进行绘制。</target>
        </trans-unit>
        <trans-unit id="e144aa8c94a98fe073cb59b66d95e6071fb6d69b" translate="yes" xml:space="preserve">
          <source>If you need to ensure that the subdirectories are built in a particular order, use the &lt;code&gt;.depends&lt;/code&gt; modifier on the relevant &lt;code&gt;SUBDIRS&lt;/code&gt; elements.</source>
          <target state="translated">如果需要确保以特定顺序构建子目录，请在相关的 &lt;code&gt;SUBDIRS&lt;/code&gt; 元素上使用 &lt;code&gt;.depends&lt;/code&gt; 修饰符。</target>
        </trans-unit>
        <trans-unit id="3fc46b15e20a06df652aee6a62607471919cf5fb" translate="yes" xml:space="preserve">
          <source>If you need to ensure that the subdirectories are built in the order in which they are specified, update the &lt;a href=&quot;#config&quot;&gt;CONFIG&lt;/a&gt; variable to include the &lt;code&gt;ordered&lt;/code&gt; option:</source>
          <target state="translated">如果需要确保按照指定的顺序构建子目录，请更新&lt;a href=&quot;#config&quot;&gt;CONFIG&lt;/a&gt;变量以包含 &lt;code&gt;ordered&lt;/code&gt; 选项：</target>
        </trans-unit>
        <trans-unit id="519adfd81a5373cd725dc77ba69d6aa56719cd7c" translate="yes" xml:space="preserve">
          <source>If you need to expose data to QML components, you need to make them available to the context of the current QML engine. See &lt;a href=&quot;qqmlcontext&quot;&gt;QQmlContext&lt;/a&gt; for more information.</source>
          <target state="translated">如果需要将数据公开给QML组件，则需要使它们可用于当前QML引擎的上下文。有关更多信息，请参见&lt;a href=&quot;qqmlcontext&quot;&gt;QQmlContext&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d9b7d0be063a4569fd31f202dedd7cca3cd9a550" translate="yes" xml:space="preserve">
          <source>If you need to handle incoming TCP connections (e.g., in a server application), use the &lt;a href=&quot;qtcpserver&quot;&gt;QTcpServer&lt;/a&gt; class. Call &lt;a href=&quot;qtcpserver#listen&quot;&gt;QTcpServer::listen&lt;/a&gt;() to set up the server, and connect to the &lt;a href=&quot;qtcpserver#newConnection&quot;&gt;QTcpServer::newConnection&lt;/a&gt;() signal, which is emitted once for every client that connects. In your slot, call &lt;a href=&quot;qtcpserver#nextPendingConnection&quot;&gt;QTcpServer::nextPendingConnection&lt;/a&gt;() to accept the connection and use the returned &lt;a href=&quot;qtcpsocket&quot;&gt;QTcpSocket&lt;/a&gt; to communicate with the client.</source>
          <target state="translated">如果您需要处理传入的TCP连接（例如，在服务器应用程序中），请使用&lt;a href=&quot;qtcpserver&quot;&gt;QTcpServer&lt;/a&gt;类。调用&lt;a href=&quot;qtcpserver#listen&quot;&gt;QTcpServer :: listen&lt;/a&gt;（）设置服务器，并连接到&lt;a href=&quot;qtcpserver#newConnection&quot;&gt;QTcpServer :: newConnection&lt;/a&gt;（）信号，该信号对于每个连接的客户端发出一次。在您的插槽中，调用&lt;a href=&quot;qtcpserver#nextPendingConnection&quot;&gt;QTcpServer :: nextPendingConnection&lt;/a&gt;（）接受连接，并使用返回的&lt;a href=&quot;qtcpsocket&quot;&gt;QTcpSocket&lt;/a&gt;与客户端进行通信。</target>
        </trans-unit>
        <trans-unit id="9c2072c17e040860f444f8edd85f0a7ccd07039b" translate="yes" xml:space="preserve">
          <source>If you need to have translatable text completely outside a function, there are two macros to help: &lt;a href=&quot;#QT_TR_NOOP&quot;&gt;QT_TR_NOOP&lt;/a&gt;() and &lt;a href=&quot;#QT_TRANSLATE_NOOP&quot;&gt;QT_TRANSLATE_NOOP&lt;/a&gt;(). They merely mark the text for extraction by the &lt;code&gt;lupdate&lt;/code&gt; tool. The macros expand to just the text (without the context).</source>
          <target state="translated">如果需要在函数外部完全具有可翻译文本，则有两个宏可以帮助您：&lt;a href=&quot;#QT_TR_NOOP&quot;&gt;QT_TR_NOOP&lt;/a&gt;（）和&lt;a href=&quot;#QT_TRANSLATE_NOOP&quot;&gt;QT_TRANSLATE_NOOP&lt;/a&gt;（）。它们仅标记要由 &lt;code&gt;lupdate&lt;/code&gt; 工具提取的文本。宏扩展为仅文本（不带上下文）。</target>
        </trans-unit>
        <trans-unit id="ecbfcdaaf0441a92102c53a124dcb64f3f3ec0f0" translate="yes" xml:space="preserve">
          <source>If you need to have translatable text completely outside a function, there are two macros to help: &lt;a href=&quot;qtglobal#QT_TR_NOOP&quot;&gt;QT_TR_NOOP&lt;/a&gt;() and &lt;a href=&quot;qtglobal#QT_TRANSLATE_NOOP&quot;&gt;QT_TRANSLATE_NOOP&lt;/a&gt;(). They merely mark the text for extraction by the &lt;code&gt;lupdate&lt;/code&gt; tool. The macros expand to just the text (without the context).</source>
          <target state="translated">如果您需要在函数外部完全具有可翻译文本，则有两个宏可以帮助您：&lt;a href=&quot;qtglobal#QT_TR_NOOP&quot;&gt;QT_TR_NOOP&lt;/a&gt;（）和&lt;a href=&quot;qtglobal#QT_TRANSLATE_NOOP&quot;&gt;QT_TRANSLATE_NOOP&lt;/a&gt;（）。它们仅标记要由 &lt;code&gt;lupdate&lt;/code&gt; 工具提取的文本。宏扩展为仅文本（没有上下文）。</target>
        </trans-unit>
        <trans-unit id="aab2531b447cc12880786ec55864c21278ccbf87" translate="yes" xml:space="preserve">
          <source>If you need to have two different strings for &lt;a href=&quot;qundocommand#text&quot;&gt;text&lt;/a&gt;() and &lt;a href=&quot;qundocommand#actionText&quot;&gt;actionText&lt;/a&gt;(), separate them with &quot;\n&quot; and pass into this function. Even if you do not use this feature for English strings during development, you can still let translators use two different strings in order to match specific languages' needs. The described feature and the function &lt;a href=&quot;qundocommand#actionText&quot;&gt;actionText&lt;/a&gt;() are available since Qt 4.8.</source>
          <target state="translated">如果您需要&lt;a href=&quot;qundocommand#text&quot;&gt;text&lt;/a&gt;（）和&lt;a href=&quot;qundocommand#actionText&quot;&gt;actionText&lt;/a&gt;（）使用两个不同的字符串，请用&amp;ldquo; \ n&amp;rdquo;将它们分开，然后传递给此函数。即使在开发过程中不对英语字符串使用此功能，您仍然可以让翻译人员使用两个不同的字符串来满足特定语言的需求。从Qt 4.8开始，已描述的功能和功能&lt;a href=&quot;qundocommand#actionText&quot;&gt;actionText&lt;/a&gt;（）可用。</target>
        </trans-unit>
        <trans-unit id="1a9a2adacfff0b2777d2e32710905d3d4b9316e0" translate="yes" xml:space="preserve">
          <source>If you need to hide the implementation details, you can use the &amp;lt;Type&amp;gt;Source class instead, which is the 2nd class declared in the header file. This class definition does not provide data members, and makes the getter/setter functions pure virtual as well. You have more flexibility in how you implement the class, although you need to write more code.</source>
          <target state="translated">如果需要隐藏实现细节，则可以改用&amp;lt;Type&amp;gt; Source类，它是头文件中声明的第二个类。该类定义不提供数据成员，并且使getter / setter函数也成为纯虚拟的。尽管您需要编写更多的代码，但是在实现类的方式上具有更大的灵活性。</target>
        </trans-unit>
        <trans-unit id="e3af702020c7b9d9688c3e3208a2f4855b647ce9" translate="yes" xml:space="preserve">
          <source>If you need to hide your implementation details, use the second class declared in the header file, the &amp;lt;Type&amp;gt;Source class. This class' definition does not provide data members, and also makes the getter/setter functions pure virtual. While you may need to write more code, using this class gives you more flexibility in your implementation.</source>
          <target state="translated">如果需要隐藏实现细节，请使用头文件中声明的第二个类&amp;lt;Type&amp;gt; Source类。此类的定义不提供数据成员，还使getter / setter函数成为纯虚拟的。尽管您可能需要编写更多代码，但是使用此类可为您提供更多的实现灵活性。</target>
        </trans-unit>
        <trans-unit id="d9cdef74aa4c95ffef75289e890aed596df23b78" translate="yes" xml:space="preserve">
          <source>If you need to identify specific objects, your application should provide UI for registering objects and mapping them to functionality: allow the user to select a meaning, virtual tool, or action, prompt the user to bring the object into proximity, and store a mapping from uniqueId to its purpose, for example in &lt;a href=&quot;qml-qt-labs-settings-settings&quot;&gt;Settings&lt;/a&gt;.</source>
          <target state="translated">如果需要标识特定的对象，则应用程序应提供用于注册对象并将其映射到功能的UI：允许用户选择含义，虚拟工具或动作，提示用户将对象移近并存储映射从uniqueId到其用途，例如在&lt;a href=&quot;qml-qt-labs-settings-settings&quot;&gt;Settings中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="424e57500c05caf36ad3723c09a844bed95cd8be" translate="yes" xml:space="preserve">
          <source>If you need to insert a new item into the list at a particular position, then it should be constructed without a parent widget. The &lt;a href=&quot;qlistwidget#insertItem&quot;&gt;insertItem&lt;/a&gt;() function should then be used to place it within the list. The list widget will take ownership of the item.</source>
          <target state="translated">如果需要在列表中的特定位置插入新项目，则应在没有父窗口小部件的情况下构造它。该&lt;a href=&quot;qlistwidget#insertItem&quot;&gt;insertItem&lt;/a&gt;则（）函数应使用其放置在列表中。列表小部件将获得该项目的所有权。</target>
        </trans-unit>
        <trans-unit id="91a7a709a86a27efd33ac820b90801a38fa581ba" translate="yes" xml:space="preserve">
          <source>If you need to interpolate other variant types, including custom types, you have to implement interpolation for these yourself. To do this, you can register an interpolator function for a given type. This function takes 3 parameters: the start value, the end value, and the current progress.</source>
          <target state="translated">如果您需要插值其他变体类型,包括自定义类型,您必须自己实现这些类型的插值。要做到这一点,您可以为给定类型注册一个插值函数。这个函数需要3个参数:开始值、结束值和当前进度。</target>
        </trans-unit>
        <trans-unit id="c7e71c5a4256fd85d63df26476bf25d106f61378" translate="yes" xml:space="preserve">
          <source>If you need to keep iterators over a long period of time, we recommend that you use &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt; rather than &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt;.</source>
          <target state="translated">如果需要长时间保留迭代器，建议您使用&lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt;而不是&lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="48b99de8c00fa981d6a3a2d933ca368802d8dec1" translate="yes" xml:space="preserve">
          <source>If you need to keep iterators over a long period of time, we recommend that you use &lt;a href=&quot;qmultimap&quot;&gt;QMultiMap&lt;/a&gt; rather than &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt;.</source>
          <target state="translated">如果需要长时间保留迭代器，建议您使用&lt;a href=&quot;qmultimap&quot;&gt;QMultiMap&lt;/a&gt;而不是&lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b9bae6cb773992572d8fda376620998eb2666889" translate="yes" xml:space="preserve">
          <source>If you need to mix both operators, you can use the &lt;code&gt;if&lt;/code&gt; function to specify operator precedence.</source>
          <target state="translated">如果需要混合使用两个运算符，则可以使用 &lt;code&gt;if&lt;/code&gt; 函数指定运算符优先级。</target>
        </trans-unit>
        <trans-unit id="bd38e2abcc058e1e2d4291dfaf58e15f21d80da9" translate="yes" xml:space="preserve">
          <source>If you need to programatically insert translations into a &lt;a href=&quot;qtranslator&quot;&gt;QTranslator&lt;/a&gt;, this function can be reimplemented.</source>
          <target state="translated">如果您需要以编程方式将翻译插入&lt;a href=&quot;qtranslator&quot;&gt;QTranslator&lt;/a&gt;，则可以重新实现此功能。</target>
        </trans-unit>
        <trans-unit id="abdd8296c8ec5fc28dfa79ecfbd861b121d7e2a6" translate="yes" xml:space="preserve">
          <source>If you need to provide a scrolling view onto another widget, it may be more convenient to use the &lt;a href=&quot;qscrollarea&quot;&gt;QScrollArea&lt;/a&gt; class because this provides a viewport widget and scroll bars. &lt;a href=&quot;qscrollbar&quot;&gt;QScrollBar&lt;/a&gt; is useful if you need to implement similar functionality for specialized widgets using &lt;a href=&quot;qabstractscrollarea&quot;&gt;QAbstractScrollArea&lt;/a&gt;; for example, if you decide to subclass &lt;a href=&quot;qabstractitemview&quot;&gt;QAbstractItemView&lt;/a&gt;. For most other situations where a slider control is used to obtain a value within a given range, the &lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt; class may be more appropriate for your needs.</source>
          <target state="translated">如果需要在另一个窗口小部件上提供滚动视图，则使用&lt;a href=&quot;qscrollarea&quot;&gt;QScrollArea&lt;/a&gt;类可能更方便，因为它提供了视口窗口小部件和滚动条。如果需要使用&lt;a href=&quot;qabstractscrollarea&quot;&gt;QAbstractScrollArea&lt;/a&gt;为专用小部件实现类似功能，则&lt;a href=&quot;qscrollbar&quot;&gt;QScrollBar&lt;/a&gt;很有用；例如，如果您决定子类&lt;a href=&quot;qabstractitemview&quot;&gt;QAbstractItemView&lt;/a&gt;。对于使用滑块控件获取给定范围内的值的大多数其他情况，&lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt;类可能更适合您的需求。</target>
        </trans-unit>
        <trans-unit id="83285c7eb745c15a4f76e1f43c21916c640944d9" translate="yes" xml:space="preserve">
          <source>If you need to provide a scrolling view onto another widget, it may be more convenient to use the &lt;a href=&quot;qscrollarea&quot;&gt;QScrollArea&lt;/a&gt; class because this provides a viewport widget and scroll bars. QScrollBar is useful if you need to implement similar functionality for specialized widgets using &lt;a href=&quot;qabstractscrollarea&quot;&gt;QAbstractScrollArea&lt;/a&gt;; for example, if you decide to subclass &lt;a href=&quot;qabstractitemview&quot;&gt;QAbstractItemView&lt;/a&gt;. For most other situations where a slider control is used to obtain a value within a given range, the &lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt; class may be more appropriate for your needs.</source>
          <target state="translated">如果需要在另一个窗口小部件上提供滚动视图，则使用&lt;a href=&quot;qscrollarea&quot;&gt;QScrollArea&lt;/a&gt;类可能更方便，因为它提供了视口窗口小部件和滚动条。如果需要使用&lt;a href=&quot;qabstractscrollarea&quot;&gt;QAbstractScrollArea&lt;/a&gt;为专门的小部件实现类似的功能，则QScrollBar很有用；例如，如果您决定子类&lt;a href=&quot;qabstractitemview&quot;&gt;QAbstractItemView&lt;/a&gt;。对于使用滑块控件获取给定范围内的值的大多数其他情况，&lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt;类可能更适合您的需求。</target>
        </trans-unit>
        <trans-unit id="aee0d7e82a69b338949c0fd649b848c1c596b557" translate="yes" xml:space="preserve">
          <source>If you need to react to events that pass parameters of unsupported datatypes you can use the generic signal that delivers the event data as provided by the COM event.</source>
          <target state="translated">如果你需要对传递不支持的数据类型参数的事件做出反应,你可以使用通用信号来传递由COM事件提供的事件数据。</target>
        </trans-unit>
        <trans-unit id="35c4a43a0f45047fb22ad1d9a2cdc1fa48448055" translate="yes" xml:space="preserve">
          <source>If you need to register a C++ class to use from QML, you can call &lt;a href=&quot;qqmlengine#qmlRegisterType&quot;&gt;qmlRegisterType&lt;/a&gt;() before declaring your &lt;a href=&quot;qqmlapplicationengine&quot;&gt;QQmlApplicationEngine&lt;/a&gt;. See &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtqml-cppintegration-overview.html#defining-qml-types-from-c&quot;&gt;Defining QML Types from C++&lt;/a&gt; for more information.</source>
          <target state="translated">如果需要注册C ++类以从QML使用，则可以在声明&lt;a href=&quot;qqmlapplicationengine&quot;&gt;QQmlApplicationEngine&lt;/a&gt;之前调用&lt;a href=&quot;qqmlengine#qmlRegisterType&quot;&gt;qmlRegisterType&lt;/a&gt;（）。有关更多信息，请参见&lt;a href=&quot;https://doc.qt.io/qt-6.0/qtqml-cppintegration-overview.html#defining-qml-types-from-c&quot;&gt;从C ++定义QML类型&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6fbe9cee9a63dbb8da30a1f9d07d90fe350cd2da" translate="yes" xml:space="preserve">
          <source>If you need to register a C++ class to use from QML, you can call &lt;a href=&quot;qqmlengine#qmlRegisterType-1&quot;&gt;qmlRegisterType&lt;/a&gt;() before declaring your &lt;a href=&quot;qqmlapplicationengine&quot;&gt;QQmlApplicationEngine&lt;/a&gt;. See &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtqml-cppintegration-overview.html#defining-qml-types-from-c&quot;&gt;Defining QML Types from C++&lt;/a&gt; for more information.</source>
          <target state="translated">如果需要注册C ++类以从QML使用，则可以在声明&lt;a href=&quot;qqmlapplicationengine&quot;&gt;QQmlApplicationEngine&lt;/a&gt;之前调用&lt;a href=&quot;qqmlengine#qmlRegisterType-1&quot;&gt;qmlRegisterType&lt;/a&gt;（）。有关更多信息，请参见&lt;a href=&quot;https://doc.qt.io/qt-5.13/qtqml-cppintegration-overview.html#defining-qml-types-from-c&quot;&gt;从C ++定义QML类型&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4da1023da64bed4ee2747c0a03e3ae5bf283d7ba" translate="yes" xml:space="preserve">
          <source>If you need to register a C++ class to use from QML, you can call qmlRegisterType() before declaring your &lt;a href=&quot;qqmlapplicationengine&quot;&gt;QQmlApplicationEngine&lt;/a&gt;. See &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtqml-cppintegration-overview.html#defining-qml-types-from-c&quot;&gt;Defining QML Types from C++&lt;/a&gt; for more information.</source>
          <target state="translated">如果需要注册要从QML使用的C ++类，则可以在声明&lt;a href=&quot;qqmlapplicationengine&quot;&gt;QQmlApplicationEngine&lt;/a&gt;之前调用qmlRegisterType（）。有关更多信息，请参见&lt;a href=&quot;https://doc.qt.io/qt-5.15/qtqml-cppintegration-overview.html#defining-qml-types-from-c&quot;&gt;从C ++定义QML类型&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="070df41811e4cfcb443c483f838b46b263327697" translate="yes" xml:space="preserve">
          <source>If you need to save the cookies to disk, you have to derive from &lt;a href=&quot;qnetworkcookiejar&quot;&gt;QNetworkCookieJar&lt;/a&gt; and save the cookies to disk yourself.</source>
          <target state="translated">如果需要将cookie保存到磁盘，则必须从&lt;a href=&quot;qnetworkcookiejar&quot;&gt;QNetworkCookieJar&lt;/a&gt;派生并将cookie自己保存到磁盘。</target>
        </trans-unit>
        <trans-unit id="11677a07f59fd2e9a0986a72e6b84c2aa0ffc7b2" translate="yes" xml:space="preserve">
          <source>If you need to set the height of a given row to a fixed value, call &lt;a href=&quot;qheaderview#resizeSection&quot;&gt;QHeaderView::resizeSection&lt;/a&gt;() on the table's vertical header.</source>
          <target state="translated">如果需要将给定行的高度设置为固定值，请在表的垂直标题上调用&lt;a href=&quot;qheaderview#resizeSection&quot;&gt;QHeaderView :: resizeSection&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="06aa884764c4854a13cd94643e4c1dc676f0acf2" translate="yes" xml:space="preserve">
          <source>If you need to set the width of a given column to a fixed value, call &lt;a href=&quot;qheaderview#resizeSection&quot;&gt;QHeaderView::resizeSection&lt;/a&gt;() on the table's horizontal header.</source>
          <target state="translated">如果需要将给定列的宽度设置为固定值，请在表的水平标题上调用&lt;a href=&quot;qheaderview#resizeSection&quot;&gt;QHeaderView :: resizeSection&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="8d8ffa11866f62c1262dc9debe5cf831cc949b36" translate="yes" xml:space="preserve">
          <source>If you need to set the width of a given column to a fixed value, call &lt;a href=&quot;qheaderview#resizeSection&quot;&gt;QHeaderView::resizeSection&lt;/a&gt;() on the view's header.</source>
          <target state="translated">如果需要将给定列的宽度设置为固定值，请在视图的标题上调用&lt;a href=&quot;qheaderview#resizeSection&quot;&gt;QHeaderView :: resizeSection&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="0286f8be9252c5d9e1bca98024dcfe5d86e42c9c" translate="yes" xml:space="preserve">
          <source>If you need to store multiple entries for the same key in the hash table, use &lt;a href=&quot;qmultihash&quot;&gt;QMultiHash&lt;/a&gt;.</source>
          <target state="translated">如果需要在哈希表中为同一键存储多个条目，请使用&lt;a href=&quot;qmultihash&quot;&gt;QMultiHash&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="37c115c6486d5e86ef8fcd9338eb375846af8d7b" translate="yes" xml:space="preserve">
          <source>If you need to trigger a repaint from places other than &lt;a href=&quot;qopenglwidget#paintGL&quot;&gt;paintGL&lt;/a&gt;() (a typical example is when using &lt;a href=&quot;qtimer&quot;&gt;timers&lt;/a&gt; to animate scenes), you should call the widget's &lt;a href=&quot;qwidget#update&quot;&gt;update&lt;/a&gt;() function to schedule an update.</source>
          <target state="translated">如果需要从&lt;a href=&quot;qopenglwidget#paintGL&quot;&gt;paintGL&lt;/a&gt;（）以外的地方触发重绘（典型示例是使用&lt;a href=&quot;qtimer&quot;&gt;计时器&lt;/a&gt;为场景设置动画），则应调用小部件的&lt;a href=&quot;qwidget#update&quot;&gt;update&lt;/a&gt;（）函数来安排更新。</target>
        </trans-unit>
        <trans-unit id="a9d06232d9c3dd95a5b84067a80c515158f99fb4" translate="yes" xml:space="preserve">
          <source>If you need to use the &lt;code&gt;widget&lt;/code&gt; argument to obtain additional information, be careful to ensure that it isn't 0 and that it is of the correct type before using it. For example:</source>
          <target state="translated">如果需要使用 &lt;code&gt;widget&lt;/code&gt; 参数来获取其他信息，请在使用前注意确保它不为0，并且类型正确。例如：</target>
        </trans-unit>
        <trans-unit id="342e5e2c96f1b7735f5d0c43329a1275eddb3a9f" translate="yes" xml:space="preserve">
          <source>If you need toggle behavior (see &lt;a href=&quot;qabstractbutton#checkable-prop&quot;&gt;setCheckable&lt;/a&gt;()) or a button that auto-repeats the activation signal when being pushed down like the arrows in a scroll bar (see &lt;a href=&quot;qabstractbutton#autoRepeat-prop&quot;&gt;setAutoRepeat&lt;/a&gt;()), a command button is probably not what you want. When in doubt, use a tool button.</source>
          <target state="translated">如果您需要切换行为（请参阅&lt;a href=&quot;qabstractbutton#checkable-prop&quot;&gt;setCheckable&lt;/a&gt;（））或在按下时像滚动条中的箭头一样自动重复激活信号的按钮（请参阅&lt;a href=&quot;qabstractbutton#autoRepeat-prop&quot;&gt;setAutoRepeat&lt;/a&gt;（）），则可能不需要命令按钮。如有疑问，请使用工具按钮。</target>
        </trans-unit>
        <trans-unit id="595944df693a930933ce18bd6f32394d05a05c6f" translate="yes" xml:space="preserve">
          <source>If you only need to extract the values from a hash (not the keys), you can also use &lt;a href=&quot;containers#foreach&quot;&gt;foreach&lt;/a&gt;:</source>
          <target state="translated">如果只需要从哈希中提取值（而不是键），则也可以使用&lt;a href=&quot;containers#foreach&quot;&gt;foreach&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="cb290be20faaadde003e66d6e10ca093fb9aec1a" translate="yes" xml:space="preserve">
          <source>If you only need to extract the values from a map (not the keys), you can also use &lt;a href=&quot;containers#foreach&quot;&gt;foreach&lt;/a&gt;:</source>
          <target state="translated">如果只需要从映射中提取值（而不是键），则也可以使用&lt;a href=&quot;containers#foreach&quot;&gt;foreach&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="af9902078a527e4b41418e71e29f173b97546a06" translate="yes" xml:space="preserve">
          <source>If you only need to show plain text in an item, consider using &lt;a href=&quot;qgraphicssimpletextitem&quot;&gt;QGraphicsSimpleTextItem&lt;/a&gt; instead.</source>
          <target state="translated">如果只需要在项目中显示纯文本，请考虑改用&lt;a href=&quot;qgraphicssimpletextitem&quot;&gt;QGraphicsSimpleTextItem&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6f9b4ddd1365ec08cf519039f7e8811fb01096af" translate="yes" xml:space="preserve">
          <source>If you only target C++17, then use &quot;QUtf8StringView&quot;. It will be an alias for &lt;code&gt;q_no_char8_t::QUtf8StringView&lt;/code&gt; and for the time being, you're ok.</source>
          <target state="translated">如果您仅针对C ++ 17，则使用&amp;ldquo; QUtf8StringView&amp;rdquo;。它将是 &lt;code&gt;q_no_char8_t::QUtf8StringView&lt;/code&gt; 的别名，暂时还可以。</target>
        </trans-unit>
        <trans-unit id="80e3574d0ae3b6fee5aa4501057535009cba2140" translate="yes" xml:space="preserve">
          <source>If you only target C++20, then use &quot;QUtf8StringView&quot;. It will be an alias for &lt;code&gt;q_has_char8_t::QUtf8StringView&lt;/code&gt; and you'll never look back.</source>
          <target state="translated">如果您仅针对C ++ 20，则使用&amp;ldquo; QUtf8StringView&amp;rdquo;。这将是 &lt;code&gt;q_has_char8_t::QUtf8StringView&lt;/code&gt; 的别名，您将永远不会回头。</target>
        </trans-unit>
        <trans-unit id="8d9a6fad5ee10addfae06f1d28f7009954de1b27" translate="yes" xml:space="preserve">
          <source>If you only want to remove the entries in the current &lt;a href=&quot;qsettings#group&quot;&gt;group&lt;/a&gt;(), use remove(&quot;&quot;) instead.</source>
          <target state="translated">如果只想删除当前&lt;a href=&quot;qsettings#group&quot;&gt;组&lt;/a&gt;（）中的条目，请改用remove（&amp;ldquo;&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="1981b65c0e1afa08eff47ad52174318a614d9ae7" translate="yes" xml:space="preserve">
          <source>If you open the buffer in write-only mode or read-write mode and write something into the &lt;a href=&quot;qbuffer&quot;&gt;QBuffer&lt;/a&gt;,</source>
          <target state="translated">如果您以只读模式或读写模式打开缓冲区，然后将某些内容写入&lt;a href=&quot;qbuffer&quot;&gt;QBuffer&lt;/a&gt;，</target>
        </trans-unit>
        <trans-unit id="600e577be0bb8581c5ea8ecaa5317edcd0285a1d" translate="yes" xml:space="preserve">
          <source>If you open the buffer in write-only mode or read-write mode and write something into the QBuffer,</source>
          <target state="translated">如果你以只写模式或读写模式打开缓冲区,并向QBuffer中写入一些东西。</target>
        </trans-unit>
        <trans-unit id="b1432aef431beb90fd8a3836144deeea09dc4ba0" translate="yes" xml:space="preserve">
          <source>If you parse XML data that does not utilize namespaces according to the XML specification or doesn't use namespaces at all, you can use the element's &lt;a href=&quot;qxmlstreamreader#qualifiedName&quot;&gt;qualifiedName&lt;/a&gt;() instead. A qualified name is the element's &lt;a href=&quot;qxmlstreamreader#prefix&quot;&gt;prefix&lt;/a&gt;() followed by colon followed by the element's local &lt;a href=&quot;qxmlstreamreader#name&quot;&gt;name&lt;/a&gt;() - exactly like the element appears in the raw XML data. Since the mapping &lt;a href=&quot;qxmlstreamreader#namespaceUri&quot;&gt;namespaceUri&lt;/a&gt; to prefix is neither unique nor universal, &lt;a href=&quot;qxmlstreamreader#qualifiedName&quot;&gt;qualifiedName&lt;/a&gt;() should be avoided for namespace-compliant XML data.</source>
          <target state="translated">如果您解析的XML数据没有根据XML规范使用命名空间，或者根本不使用命名空间，则可以改用元素的&lt;a href=&quot;qxmlstreamreader#qualifiedName&quot;&gt;qualifiedName&lt;/a&gt;（）。限定名称是元素的&lt;a href=&quot;qxmlstreamreader#prefix&quot;&gt;前缀&lt;/a&gt;（），后跟冒号，然后是元素的本地&lt;a href=&quot;qxmlstreamreader#name&quot;&gt;名称&lt;/a&gt;（），就像元素出现在原始XML数据中一样。由于将&lt;a href=&quot;qxmlstreamreader#namespaceUri&quot;&gt;名称空间&lt;/a&gt; Uri 映射到前缀既不是唯一的也不是通用的，因此应避免使用符合名称空间的XML数据&lt;a href=&quot;qxmlstreamreader#qualifiedName&quot;&gt;qualifiedName&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="a9cadaec13e38df68e5abb156e901760e7c27372" translate="yes" xml:space="preserve">
          <source>If you pass &lt;code&gt;stsvar&lt;/code&gt;, the command's exit status will be stored in that variable. If the command crashes, the status will be -1, otherwise a non-negative exit code of the command's choosing. Usually, comparing the status with zero (success) is sufficient.</source>
          <target state="translated">如果传递 &lt;code&gt;stsvar&lt;/code&gt; ，则命令的退出状态将存储在该变量中。如果该命令崩溃，则状态将为-1，否则该命令选择的非负退出代码。通常，将状态与零（成功）进行比较就足够了。</target>
        </trans-unit>
        <trans-unit id="2468029b6202e79cf90eedbcc8b9f8bac7c82f7e" translate="yes" xml:space="preserve">
          <source>If you pass a directory or file, the &lt;a href=&quot;qstorageinfo&quot;&gt;QStorageInfo&lt;/a&gt; object will refer to the volume where this directory or file is located. You can check if the created object is correct using the &lt;a href=&quot;qstorageinfo#isValid&quot;&gt;isValid&lt;/a&gt;() method.</source>
          <target state="translated">如果传递目录或文件，则&lt;a href=&quot;qstorageinfo&quot;&gt;QStorageInfo&lt;/a&gt;对象将引用该目录或文件所在的卷。您可以使用&lt;a href=&quot;qstorageinfo#isValid&quot;&gt;isValid&lt;/a&gt;（）方法检查创建的对象是否正确。</target>
        </trans-unit>
        <trans-unit id="451dc2da551fdf636ae7e6c8321ddc68f964c27c" translate="yes" xml:space="preserve">
          <source>If you pass a directory or file, the QStorageInfo object will refer to the volume where this directory or file is located. You can check if the created object is correct using the &lt;a href=&quot;qstorageinfo#isValid&quot;&gt;isValid&lt;/a&gt;() method.</source>
          <target state="translated">如果传递目录或文件，则QStorageInfo对象将引用此目录或文件所在的卷。您可以使用&lt;a href=&quot;qstorageinfo#isValid&quot;&gt;isValid&lt;/a&gt;（）方法检查创建的对象是否正确。</target>
        </trans-unit>
        <trans-unit id="095eb0d3621325e3be7f0f3c9d8de12134c82c50" translate="yes" xml:space="preserve">
          <source>If you pass a literal IP address to</source>
          <target state="translated">如果你把一个真实的IP地址传给</target>
        </trans-unit>
        <trans-unit id="c440b0ccf58e2711892efe6e2daa75e11c2eb77f" translate="yes" xml:space="preserve">
          <source>If you pass a parent to &lt;a href=&quot;qrubberband&quot;&gt;QRubberBand&lt;/a&gt;'s constructor, the rubber band will display only inside its parent, but stays on top of other child widgets. If no parent is passed, &lt;a href=&quot;qrubberband&quot;&gt;QRubberBand&lt;/a&gt; will act as a top-level widget.</source>
          <target state="translated">如果将父&lt;a href=&quot;qrubberband&quot;&gt;级&lt;/a&gt;传递给QRubberBand的构造函数，橡皮筋将仅显示在其父级内部，但停留在其他子级小部件的顶部。如果未传递任何父代，则&lt;a href=&quot;qrubberband&quot;&gt;QRubberBand&lt;/a&gt;将充当顶级窗口小部件。</target>
        </trans-unit>
        <trans-unit id="9facde74fcc71bab24515fc10c78fc7f6c339319" translate="yes" xml:space="preserve">
          <source>If you pass a parent to QRubberBand's constructor, the rubber band will display only inside its parent, but stays on top of other child widgets. If no parent is passed, QRubberBand will act as a top-level widget.</source>
          <target state="translated">如果您向QRubberBand的构造函数传递了一个父节点,那么橡皮筋将仅在其父节点内显示,但会停留在其他子部件的顶部。如果没有传递父节点,QRubberBand将作为一个顶层widget。</target>
        </trans-unit>
        <trans-unit id="62e8444ae36f62517044d3ed8475a9711c363cef" translate="yes" xml:space="preserve">
          <source>If you pass in a named container (an lvalue) for</source>
          <target state="translated">如果你传入一个命名的容器(一个l值),为</target>
        </trans-unit>
        <trans-unit id="2309c47279edfcd798da8d48fca3c47ece7a09d5" translate="yes" xml:space="preserve">
          <source>If you pass in a named container (an lvalue)for</source>
          <target state="translated">如果你传入一个命名的容器(一个l值)作为</target>
        </trans-unit>
        <trans-unit id="7df01e112c0e66fa3b64cddf64988aad98792d5d" translate="yes" xml:space="preserve">
          <source>If you pass named objects (lvalues), then QStringTokenizer does not store a copy. You are responsible to keep the named object's data around for longer than the tokenizer operates on it:</source>
          <target state="translated">如果你传递命名对象(lvalues),那么QStringTokenizer不会存储一个副本。你有责任将命名对象的数据保存在周围,时间长于tokenizer对它的操作。</target>
        </trans-unit>
        <trans-unit id="58ac130298ee38b7431712a4fcde652ae17a3c46" translate="yes" xml:space="preserve">
          <source>If you pass the SubPath option, this introspection has to include all child nodes. Otherwise &lt;a href=&quot;qdbus&quot;&gt;QDBus&lt;/a&gt; handles the introspection of the child nodes.</source>
          <target state="translated">如果传递SubPath选项，则此自省必须包括所有子节点。否则，&lt;a href=&quot;qdbus&quot;&gt;QDBus会&lt;/a&gt;处理子节点的自省。</target>
        </trans-unit>
        <trans-unit id="62cbd3dd55a6c3dd22dd756d6bec35f6568c6d0e" translate="yes" xml:space="preserve">
          <source>If you pass the function a format string and a list of arguments, it works in similar way to the C printf() function. The format should be a Latin-1 string.</source>
          <target state="translated">如果你传给函数一个格式字符串和一个参数列表,它的工作方式类似于C语言的printf()函数。格式应该是一个Latin-1的字符串。</target>
        </trans-unit>
        <trans-unit id="42f31dacf417f05e127400fc88bee63ad97c25aa" translate="yes" xml:space="preserve">
          <source>If you prefer the STL-style iterators, you can call &lt;a href=&quot;qmultimap#find&quot;&gt;find&lt;/a&gt;() to get the iterator for the first item with a key and iterate from there:</source>
          <target state="translated">如果您更喜欢STL样式的迭代器，则可以调用&lt;a href=&quot;qmultimap#find&quot;&gt;find&lt;/a&gt;（）来获取具有键的第一项的迭代器，然后从那里进行迭代：</target>
        </trans-unit>
        <trans-unit id="bfe35a94f18877c56725758571c2d1f2bbda275e" translate="yes" xml:space="preserve">
          <source>If you provide 'A' as an argument to the \list command, the bullets are replaced with characters in alphabetical order:</source>
          <target state="translated">如果你提供'A'作为\list命令的参数,则按字母顺序用字符代替子弹。</target>
        </trans-unit>
        <trans-unit id="ae37e01cf5eb2864e6b40947b465f94efbf33c9a" translate="yes" xml:space="preserve">
          <source>If you provide 'i' as the argument, the bullets are replaced with roman numerals:</source>
          <target state="translated">如果你提供'i'作为参数,子弹会被罗马数字代替。</target>
        </trans-unit>
        <trans-unit id="731970c1d1538198d94cf0457f2b4f3e4be894b3" translate="yes" xml:space="preserve">
          <source>If you re-implement this method in a subclass, be sure to call</source>
          <target state="translated">如果你在一个子类中重新实现这个方法,请务必调用</target>
        </trans-unit>
        <trans-unit id="c345887566efa1bc25ea77a4606f6a41c7e58022" translate="yes" xml:space="preserve">
          <source>If you reimplement &lt;a href=&quot;qwizardpage#isComplete&quot;&gt;isComplete&lt;/a&gt;(), make sure to emit completeChanged() whenever the value of &lt;a href=&quot;qwizardpage#isComplete&quot;&gt;isComplete&lt;/a&gt;() changes, to ensure that &lt;a href=&quot;qwizard&quot;&gt;QWizard&lt;/a&gt; updates the enabled or disabled state of its buttons.</source>
          <target state="translated">如果重新实现&lt;a href=&quot;qwizardpage#isComplete&quot;&gt;isComplete&lt;/a&gt;（），请确保每当&lt;a href=&quot;qwizardpage#isComplete&quot;&gt;isComplete&lt;/a&gt;（）的值更改时就发出completeChanged（），以确保&lt;a href=&quot;qwizard&quot;&gt;QWizard&lt;/a&gt;更新其按钮的启用或禁用状态。</target>
        </trans-unit>
        <trans-unit id="914843405683e7c66dc5a8782b04dd8c9a8dd7df" translate="yes" xml:space="preserve">
          <source>If you reimplement this function in a subclass, note that the value you return is only used when &lt;a href=&quot;qtableview#resizeRowToContents&quot;&gt;resizeRowToContents&lt;/a&gt;() is called. In that case, if a larger row height is required by either the vertical header or the item delegate, that width will be used instead.</source>
          <target state="translated">如果在子类中重新实现此函数，请注意，仅在&lt;a href=&quot;qtableview#resizeRowToContents&quot;&gt;调用resizeRowToContents&lt;/a&gt;（）时使用返回的值。在这种情况下，如果垂直标题或项目委托要求更大的行高，则将使用该宽度。</target>
        </trans-unit>
        <trans-unit id="dc4cc9b4c334f4a25945c6d6e420725dabce950f" translate="yes" xml:space="preserve">
          <source>If you reimplement this function in a subclass, note that the value you return is only used when &lt;a href=&quot;qtreeview#resizeColumnToContents&quot;&gt;resizeColumnToContents&lt;/a&gt;() is called. In that case, if a larger column width is required by either the view's header or the item delegate, that width will be used instead.</source>
          <target state="translated">如果在子类中重新实现此函数，请注意，仅在&lt;a href=&quot;qtreeview#resizeColumnToContents&quot;&gt;调用resizeColumnToContents&lt;/a&gt;（）时使用返回的值。在这种情况下，如果视图的标题或项目委托需要更大的列宽，则将使用该宽度。</target>
        </trans-unit>
        <trans-unit id="80faad784ed683b7ebe81a65a067e804edbd5ae4" translate="yes" xml:space="preserve">
          <source>If you reimplement this function in a subclass, note that the value you return will be used when &lt;a href=&quot;qtableview#resizeColumnToContents&quot;&gt;resizeColumnToContents&lt;/a&gt;() or &lt;a href=&quot;qheaderview#resizeSections-1&quot;&gt;QHeaderView::resizeSections&lt;/a&gt;() is called. If a larger column width is required by either the horizontal header or the item delegate, the larger width will be used instead.</source>
          <target state="translated">如果在子类中重新实现此函数，请注意，当&lt;a href=&quot;qtableview#resizeColumnToContents&quot;&gt;调用resizeColumnToContents&lt;/a&gt;（）或&lt;a href=&quot;qheaderview#resizeSections-1&quot;&gt;QHeaderView :: resizeSections&lt;/a&gt;（）时，将使用返回的值。如果水平标题或项目委托要求更大的列宽，则将使用更大的宽度。</target>
        </trans-unit>
        <trans-unit id="14bf8a36129c68c52297b33af2104f3a3e57519f" translate="yes" xml:space="preserve">
          <source>If you reimplement this function in your custom model, you must also reimplement the member functions that call it: &lt;a href=&quot;qabstractitemmodel#mimeData&quot;&gt;mimeData&lt;/a&gt;() and &lt;a href=&quot;qabstractitemmodel#dropMimeData&quot;&gt;dropMimeData&lt;/a&gt;().</source>
          <target state="translated">如果在自定义模型中重新实现此函数，则还必须重新实现调用它的成员函数：&lt;a href=&quot;qabstractitemmodel#mimeData&quot;&gt;mimeData&lt;/a&gt;（）和&lt;a href=&quot;qabstractitemmodel#dropMimeData&quot;&gt;dropMimeData&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="241523b4fecf200ea38f75fde41e25bf784b4fb7" translate="yes" xml:space="preserve">
          <source>If you reimplement this function to show a custom pop-up, make sure you call &lt;a href=&quot;qcombobox#hidePopup&quot;&gt;hidePopup&lt;/a&gt;() to reset the internal state.</source>
          <target state="translated">如果重新实现此功能以显示自定义弹出窗口，请确保调用&lt;a href=&quot;qcombobox#hidePopup&quot;&gt;hidePopup&lt;/a&gt;（）重置内部状态。</target>
        </trans-unit>
        <trans-unit id="317cef53e92834b58f8db232e0262505d2f0d722" translate="yes" xml:space="preserve">
          <source>If you reimplement this function you also have to implement &lt;a href=&quot;qaxbindable#readData&quot;&gt;readData&lt;/a&gt;(). The default implementation does nothing and returns false.</source>
          <target state="translated">如果重新实现此功能，则还必须实现&lt;a href=&quot;qaxbindable#readData&quot;&gt;readData&lt;/a&gt;（）。默认实现不执行任何操作，并返回false。</target>
        </trans-unit>
        <trans-unit id="a5f6f0fc3652bfa4cdf346a95036c06abc5448ad" translate="yes" xml:space="preserve">
          <source>If you reimplement this function you also have to implement &lt;a href=&quot;qaxbindable#writeData&quot;&gt;writeData&lt;/a&gt;(). The default implementation does nothing and returns false.</source>
          <target state="translated">如果重新实现此功能，则还必须实现&lt;a href=&quot;qaxbindable#writeData&quot;&gt;writeData&lt;/a&gt;（）。默认实现不执行任何操作，并返回false。</target>
        </trans-unit>
        <trans-unit id="59c499ef805f5adda87a6e828740b95fa5da9b9c" translate="yes" xml:space="preserve">
          <source>If you reimplement this function you must also reimplement &lt;a href=&quot;qaxfactory#unregisterClass&quot;&gt;unregisterClass&lt;/a&gt;() to remove the additional registry values.</source>
          <target state="translated">如果重新实现此功能，则还必须重新实现&lt;a href=&quot;qaxfactory#unregisterClass&quot;&gt;unregisterClass&lt;/a&gt;（）来删除其他注册表值。</target>
        </trans-unit>
        <trans-unit id="5dafa3e034af5fad97569d1e5e7ef17dc7603299" translate="yes" xml:space="preserve">
          <source>If you reimplement this function you must also reimplement the destructor to call clear(), and call this implementation at the end of your clear() function.</source>
          <target state="translated">如果你重新实现这个函数,你也必须重新实现destructor来调用clear(),并在你的clear()函数的最后调用这个实现。</target>
        </trans-unit>
        <trans-unit id="ba7b5a834b411685e0a6145d25de991fe9466f7e" translate="yes" xml:space="preserve">
          <source>If you reimplement this function, be careful to return the correct value: it should return the number of bytes read in this line, including the terminating newline, or 0 if there is no line to be read at this point. If an error occurs, it should return -1 if and only if no bytes were read. Reading past EOF is considered an error.</source>
          <target state="translated">如果你重新实现这个函数,要注意返回正确的值:它应该返回这一行中读取的字节数,包括终止的换行,如果此时没有行要读,则返回0。如果发生错误,如果且仅在没有读取字节的情况下,它应该返回-1。读过EOF后,就会被认为是一个错误。</target>
        </trans-unit>
        <trans-unit id="7f0f811b2dee4e47f7f67e785a39ee8b1336e278" translate="yes" xml:space="preserve">
          <source>If you reimplement this function, make sure to emit &lt;a href=&quot;qwizardpage#completeChanged&quot;&gt;completeChanged&lt;/a&gt;(), from the rest of your implementation, whenever the value of isComplete() changes. This ensures that &lt;a href=&quot;qwizard&quot;&gt;QWizard&lt;/a&gt; updates the enabled or disabled state of its buttons. An example of the reimplementation is available &lt;a href=&quot;http://doc.qt.io/archives/qq/qq22-qwizard.html#validatebeforeitstoolate&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">如果重新实现此函数，请确保在isComplete（）值更改时，从实现的其余部分中发出&lt;a href=&quot;qwizardpage#completeChanged&quot;&gt;completeChanged&lt;/a&gt;（）。这样可以确保&lt;a href=&quot;qwizard&quot;&gt;QWizard&lt;/a&gt;更新其按钮的启用或禁用状态。重新实现的示例在&lt;a href=&quot;http://doc.qt.io/archives/qq/qq22-qwizard.html#validatebeforeitstoolate&quot;&gt;此处提供&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3e6ad76dd2545ca29e5f4d05ad586440ae727b43" translate="yes" xml:space="preserve">
          <source>If you reimplement this function, make sure to emit &lt;a href=&quot;qwizardpage#completeChanged&quot;&gt;completeChanged&lt;/a&gt;(), from the rest of your implementation, whenever the value of isComplete() changes. This ensures that &lt;a href=&quot;qwizard&quot;&gt;QWizard&lt;/a&gt; updates the enabled or disabled state of its buttons. An example of the reimplementation is available &lt;a href=&quot;https://doc.qt.io/archives/qq/qq22-qwizard.html#validatebeforeitstoolate&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">如果重新实现此函数，请确保在isComplete（）的值更改时，从实现的其余部分中发出&lt;a href=&quot;qwizardpage#completeChanged&quot;&gt;completeChanged&lt;/a&gt;（）。这样可以确保&lt;a href=&quot;qwizard&quot;&gt;QWizard&lt;/a&gt;更新其按钮的启用或禁用状态。重新实现的示例在&lt;a href=&quot;https://doc.qt.io/archives/qq/qq22-qwizard.html#validatebeforeitstoolate&quot;&gt;此处提供&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6121aea8e26ace6bd5c7785a32c8007ecd435fbe" translate="yes" xml:space="preserve">
          <source>If you reimplement this function, note that the ownership of the returned &lt;a href=&quot;qmimedata&quot;&gt;QMimeData&lt;/a&gt; object is passed to the caller. The selection can be retrieved by using the &lt;a href=&quot;qplaintextedit#textCursor&quot;&gt;textCursor&lt;/a&gt;() function.</source>
          <target state="translated">如果重新实现此功能，请注意，返回的&lt;a href=&quot;qmimedata&quot;&gt;QMimeData&lt;/a&gt;对象的所有权将传递给调用方。可以使用&lt;a href=&quot;qplaintextedit#textCursor&quot;&gt;textCursor&lt;/a&gt;（）函数来检索选择。</target>
        </trans-unit>
        <trans-unit id="019f7bf1d1d734e24dd917dd0cee3eadc03d7fdb" translate="yes" xml:space="preserve">
          <source>If you reimplement this function, note that the ownership of the returned &lt;a href=&quot;qmimedata&quot;&gt;QMimeData&lt;/a&gt; object is passed to the caller. The selection can be retrieved by using the &lt;a href=&quot;qtextedit#textCursor&quot;&gt;textCursor&lt;/a&gt;() function.</source>
          <target state="translated">如果重新实现此功能，请注意，返回的&lt;a href=&quot;qmimedata&quot;&gt;QMimeData&lt;/a&gt;对象的所有权将传递给调用方。可以使用&lt;a href=&quot;qtextedit#textCursor&quot;&gt;textCursor&lt;/a&gt;（）函数来检索选择。</target>
        </trans-unit>
        <trans-unit id="cb9847e6d068a4d16b5a592e0e7de1fa8a05363e" translate="yes" xml:space="preserve">
          <source>If you reimplement this function, you can return other &lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;QVariant&lt;/a&gt; types. The table below shows which variant types are supported depending on the resource type:</source>
          <target state="translated">如果重新实现此功能，则可以返回其他&lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;QVariant&lt;/a&gt;类型。下表显示了根据资源类型支持哪些变体类型：</target>
        </trans-unit>
        <trans-unit id="48ee44b9472494640a1a02db7be151a05fbbfe6f" translate="yes" xml:space="preserve">
          <source>If you reimplement this function, you can return other &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; types. The table below shows which variant types are supported depending on the resource type:</source>
          <target state="translated">如果重新实现此功能，则可以返回其他&lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt;类型。下表显示了根据资源类型支持哪些变体类型：</target>
        </trans-unit>
        <trans-unit id="19a862905403389a4b02d238d2699e0e0553cbaf" translate="yes" xml:space="preserve">
          <source>If you reimplement this handler, it is very important that you &lt;a href=&quot;qevent&quot;&gt;ignore()&lt;/a&gt; the event if you do not handle it, so that the widget's parent can interpret it.</source>
          <target state="translated">如果重新实现此处理程序，则不处理该事件就必须&lt;a href=&quot;qevent&quot;&gt;忽略（）&lt;/a&gt;事件，以便小部件的父级可以解释该事件，这一点非常重要。</target>
        </trans-unit>
        <trans-unit id="bd6881e41238ecfdfdf2717ee493442d7a4ad036" translate="yes" xml:space="preserve">
          <source>If you reimplement this handler, it is very important that you call the base class implementation if you do not act upon the key.</source>
          <target state="translated">如果你重新实现这个处理程序,如果你不对密钥采取行动,那么调用基类实现是非常重要的。</target>
        </trans-unit>
        <trans-unit id="7e8e223786b37a873a7278ae8baeb7e9b6b9e63c" translate="yes" xml:space="preserve">
          <source>If you reimplement this you must also reimplement &lt;a href=&quot;qabstractitemdelegate#paint&quot;&gt;paint&lt;/a&gt;().</source>
          <target state="translated">如果重新实现，则还必须重新实现&lt;a href=&quot;qabstractitemdelegate#paint&quot;&gt;paint&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="637e7ac5550b4557cb47b73ba483c57837079309" translate="yes" xml:space="preserve">
          <source>If you reimplement this you must also reimplement &lt;a href=&quot;qabstractitemdelegate#sizeHint&quot;&gt;sizeHint&lt;/a&gt;().</source>
          <target state="translated">如果重新实现，则还必须重新实现&lt;a href=&quot;qabstractitemdelegate#sizeHint&quot;&gt;sizeHint&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="ce640650d17e4498675375a04b2eb5b8a0016844" translate="yes" xml:space="preserve">
          <source>If you reimplement this, you may also need to reimplement &lt;a href=&quot;qdatetimeedit#validate&quot;&gt;validate&lt;/a&gt;().</source>
          <target state="translated">如果重新实现，则可能还需要重新实现&lt;a href=&quot;qdatetimeedit#validate&quot;&gt;validate&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="a33c3d76f7cfc8a3320bef2d8f1e863c93b633cd" translate="yes" xml:space="preserve">
          <source>If you reimplement this, you may also need to reimplement &lt;a href=&quot;qdoublespinbox#valueFromText&quot;&gt;valueFromText&lt;/a&gt;().</source>
          <target state="translated">如果重新实现，则可能还需要重新实现&lt;a href=&quot;qdoublespinbox#valueFromText&quot;&gt;valueFromText&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="7e6e004075e74e9581fdc0b4adde39e723bceee2" translate="yes" xml:space="preserve">
          <source>If you reimplement this, you may also need to reimplement &lt;a href=&quot;qspinbox#valueFromText&quot;&gt;valueFromText&lt;/a&gt;() and &lt;a href=&quot;qspinbox#validate&quot;&gt;validate&lt;/a&gt;()</source>
          <target state="translated">如果重新实现，则可能还需要重新实现&lt;a href=&quot;qspinbox#valueFromText&quot;&gt;valueFromText&lt;/a&gt;（）和&lt;a href=&quot;qspinbox#validate&quot;&gt;validate&lt;/a&gt;（）</target>
        </trans-unit>
        <trans-unit id="61c6c0ecdb63f8b2f25af84016eb5d0840d86ca0" translate="yes" xml:space="preserve">
          <source>If you rely on any specific behavior regarding the restoration of plain values when bindings get disabled you should migrate to explicitly set the restoreMode.</source>
          <target state="translated">如果你依赖任何关于恢复纯值的特定行为,当绑定被禁用时,你应该迁移到显式设置 restoreMode。</target>
        </trans-unit>
        <trans-unit id="037eabcdd3665a989ed4b2e44de2d118c2dd4856" translate="yes" xml:space="preserve">
          <source>If you remove the menu bar, a new one can be created by selecting the &lt;b&gt;Create Menu Bar&lt;/b&gt; option from the context menu, obtained by right-clicking within the main window form.</source>
          <target state="translated">如果删除菜单栏，可以通过从上下文菜单中选择&amp;ldquo; &lt;b&gt;创建菜单栏&amp;rdquo;&lt;/b&gt;选项来创建一个新的菜单栏，方法是在主窗口窗体中单击鼠标右键。</target>
        </trans-unit>
        <trans-unit id="ccfdab642e1e2bbb6355170fc5b98e2173313427" translate="yes" xml:space="preserve">
          <source>If you replace 'A' with '1', the list items are numbered in ascending order:</source>
          <target state="translated">如果将'A'替换为'1',则列表项目将按升序编号。</target>
        </trans-unit>
        <trans-unit id="d82384c56b8b47dd8ba0f28c64d195e5e8098152" translate="yes" xml:space="preserve">
          <source>If you require finer control over playing sounds, consider the &lt;a href=&quot;qsoundeffect&quot;&gt;QSoundEffect&lt;/a&gt; or &lt;a href=&quot;qaudiooutput&quot;&gt;QAudioOutput&lt;/a&gt; classes.</source>
          <target state="translated">如果您需要更好地控制播放声音，请考虑使用&lt;a href=&quot;qsoundeffect&quot;&gt;QSoundEffect&lt;/a&gt;或&lt;a href=&quot;qaudiooutput&quot;&gt;QAudioOutput&lt;/a&gt;类。</target>
        </trans-unit>
        <trans-unit id="70a2df5240d20ed12120f0888cff3009256a2d06" translate="yes" xml:space="preserve">
          <source>If you restore the Z value, the item's insertion order will decide its stacking order.</source>
          <target state="translated">如果恢复Z值,物品的插入顺序将决定其堆叠顺序。</target>
        </trans-unit>
        <trans-unit id="2c7ed57b46833bd7c963562211c28f66948481e5" translate="yes" xml:space="preserve">
          <source>If you set &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;'s &lt;a href=&quot;qpainter#RenderHint-enum&quot;&gt;anti-aliasing&lt;/a&gt; render hint, the pixels will be rendered symetrically on both sides of the mathematically defined points:</source>
          <target state="translated">如果设置&lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;的&lt;a href=&quot;qpainter#RenderHint-enum&quot;&gt;抗锯齿&lt;/a&gt;渲染提示，将在数学上定义的点的两侧对称地渲染像素：</target>
        </trans-unit>
        <trans-unit id="8352adcdbe7da1f5d344e31d4c80a76e560b4956" translate="yes" xml:space="preserve">
          <source>If you set &lt;code&gt;QML_IMPORT_TRACE=1&lt;/code&gt; before running the &lt;a href=&quot;qtquick-qmlscene&quot;&gt;QML Scene&lt;/a&gt; or your QML C++ application, you will see output similar to:</source>
          <target state="translated">如果在运行&lt;a href=&quot;qtquick-qmlscene&quot;&gt;QML Scene&lt;/a&gt;或QML C ++应用程序之前设置 &lt;code&gt;QML_IMPORT_TRACE=1&lt;/code&gt; ，则将看到类似以下的输出：</target>
        </trans-unit>
        <trans-unit id="403ac36c3dc11f4321381173d9b10dd0fa897d5e" translate="yes" xml:space="preserve">
          <source>If you set &lt;code&gt;QML_IMPORT_TRACE=1&lt;/code&gt; before running the &lt;a href=&quot;qtquick-qmlscene#&quot;&gt;QML Scene&lt;/a&gt; or your QML C++ application, you will see output similar to:</source>
          <target state="translated">如果在运行&lt;a href=&quot;qtquick-qmlscene#&quot;&gt;QML Scene&lt;/a&gt;或QML C ++应用程序之前设置 &lt;code&gt;QML_IMPORT_TRACE=1&lt;/code&gt; ，则将看到类似以下的输出：</target>
        </trans-unit>
        <trans-unit id="b21f1fecce8de5aee80732e924198937055530fd" translate="yes" xml:space="preserve">
          <source>If you set &lt;code&gt;acceptedModifiers&lt;/code&gt; to an OR combination of modifier keys, it means</source>
          <target state="translated">如果将 &lt;code&gt;acceptedModifiers&lt;/code&gt; 设置为修饰键的OR组合，则表示</target>
        </trans-unit>
        <trans-unit id="1bef83b959da9c78ca1c919563bd96a50bdf2db6" translate="yes" xml:space="preserve">
          <source>If you set a cursorDelegate for a &lt;a href=&quot;qml-qtquick-textedit&quot;&gt;TextEdit&lt;/a&gt;, this delegate will be used for drawing the cursor instead of the standard cursor. An instance of the delegate will be created and managed by the text edit when a cursor is needed, and the x and y properties of delegate instance will be set so as to be one pixel before the top left of the current character.</source>
          <target state="translated">如果为&lt;a href=&quot;qml-qtquick-textedit&quot;&gt;TextEdit&lt;/a&gt;设置cursorDelegate ，则此委托将用于绘制光标而不是标准光标。需要光标时，将通过文本编辑来创建和管理委托的一个实例，并将委托实例的x和y属性设置为当前字符左上角一个像素。</target>
        </trans-unit>
        <trans-unit id="bbd4f27ee17216328f29625eaca8cfb2ff7dc6c3" translate="yes" xml:space="preserve">
          <source>If you set a cursorDelegate for a &lt;a href=&quot;qml-qtquick-textinput&quot;&gt;TextInput&lt;/a&gt;, this delegate will be used for drawing the cursor instead of the standard cursor. An instance of the delegate will be created and managed by the &lt;a href=&quot;qml-qtquick-textinput&quot;&gt;TextInput&lt;/a&gt; when a cursor is needed, and the x property of the delegate instance will be set so as to be one pixel before the top left of the current character.</source>
          <target state="translated">如果为&lt;a href=&quot;qml-qtquick-textinput&quot;&gt;TextInput&lt;/a&gt;设置cursorDelegate ，则此委托将用于绘制光标而不是标准光标。需要光标时，将由&lt;a href=&quot;qml-qtquick-textinput&quot;&gt;TextInput&lt;/a&gt;创建和管理委托的实例，并将委托实例的x属性设置为当前字符左上角一个像素。</target>
        </trans-unit>
        <trans-unit id="047958af1c10584793fadf46dfff954803186cf9" translate="yes" xml:space="preserve">
          <source>If you set a drop action that is not one of the possible actions, the drag and drop operation will default to a copy operation.</source>
          <target state="translated">如果设置的拖放操作不在可能的操作之列,则拖放操作将默认为复制操作。</target>
        </trans-unit>
        <trans-unit id="a5a96eb99713196f9a09efc6f3f1749958e02b44" translate="yes" xml:space="preserve">
          <source>If you set a font that isn't available, Qt finds a close match. &lt;a href=&quot;qpainter#font&quot;&gt;font&lt;/a&gt;() will return what you set using setFont() and &lt;a href=&quot;qpainter#fontInfo&quot;&gt;fontInfo&lt;/a&gt;() returns the font actually being used (which may be the same).</source>
          <target state="translated">如果您设置的字体不可用，Qt会找到一个紧密匹配的字体。&lt;a href=&quot;qpainter#font&quot;&gt;font&lt;/a&gt;（）将返回您使用setFont（）设置的内容，&lt;a href=&quot;qpainter#fontInfo&quot;&gt;fontInfo&lt;/a&gt;（）将返回实际使用的字体（可能相同）。</target>
        </trans-unit>
        <trans-unit id="004043069d8a07628c90c4b4958ae006433f2857" translate="yes" xml:space="preserve">
          <source>If you set a list of point types as values, the x-coordinate of the point specifies its zero-based index in the bar set. The size of the bar set is the highest x-coordinate value + 1. If a point is missing for any x-coordinate between zero and the highest value, it gets the value zero.</source>
          <target state="translated">如果你设置了一个点类型的列表作为值,点的x坐标指定了它在条形集中基于零的索引。条形集的大小是最高x坐标值+1。如果一个点在零和最高值之间的任何x坐标缺失,它得到的值是零。</target>
        </trans-unit>
        <trans-unit id="fdc9233830c1d652cc4418de75ef220f3d6bf0d6" translate="yes" xml:space="preserve">
          <source>If you set a list of real types as values, they directly define the bar set values.</source>
          <target state="translated">如果将实类型列表设置为值,它们直接定义条形集的值。</target>
        </trans-unit>
        <trans-unit id="d026b32ff4e11356bacbf6f7cec5aac64d62b2ec" translate="yes" xml:space="preserve">
          <source>If you set a proxy factory with this function, any application level proxies set with &lt;a href=&quot;qnetworkproxy#setApplicationProxy&quot;&gt;QNetworkProxy::setApplicationProxy&lt;/a&gt; will be overridden, and &lt;a href=&quot;qnetworkproxyfactory#usesSystemConfiguration&quot;&gt;usesSystemConfiguration&lt;/a&gt;() will return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果使用此功能设置了代理工厂，则使用&lt;a href=&quot;qnetworkproxy#setApplicationProxy&quot;&gt;QNetworkProxy :: setApplicationProxy&lt;/a&gt;设置的任何应用程序级别的代理都将被覆盖，并且&lt;a href=&quot;qnetworkproxyfactory#usesSystemConfiguration&quot;&gt;usingSystemConfiguration&lt;/a&gt;（）将返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b13a093dc2ce286f0c9ccccb7cc994fb7903b344" translate="yes" xml:space="preserve">
          <source>If you set a text width on the &lt;a href=&quot;qstatictext&quot;&gt;QStaticText&lt;/a&gt; object, this will bound the text. The text will be formatted so that no line exceeds the given width. The text width set for &lt;a href=&quot;qstatictext&quot;&gt;QStaticText&lt;/a&gt; will not automatically be used for clipping. To achieve clipping in addition to line breaks, use &lt;a href=&quot;qpainter#setClipRect&quot;&gt;QPainter::setClipRect&lt;/a&gt;(). The position of the text is decided by the argument passed to &lt;a href=&quot;qpainter#drawStaticText&quot;&gt;QPainter::drawStaticText&lt;/a&gt;() and can change from call to call with a minimal impact on performance.</source>
          <target state="translated">如果在&lt;a href=&quot;qstatictext&quot;&gt;QStaticText&lt;/a&gt;对象上设置文本宽度，则将绑定文本。文本将被格式化，以便没有行超过给定的宽度。为&lt;a href=&quot;qstatictext&quot;&gt;QStaticText&lt;/a&gt;设置的文本宽度不会自动用于剪切。除了换行以外，还可以实现裁剪，请使用&lt;a href=&quot;qpainter#setClipRect&quot;&gt;QPainter :: setClipRect&lt;/a&gt;（）。文本的位置由传递给&lt;a href=&quot;qpainter#drawStaticText&quot;&gt;QPainter :: drawStaticText&lt;/a&gt;（）的参数确定，并且可以在每次调用之间更改，而对性能的影响最小。</target>
        </trans-unit>
        <trans-unit id="c83155cd44c2bdec5285147a3c974bb1325efb43" translate="yes" xml:space="preserve">
          <source>If you set a text width on the QStaticText object, this will bound the text. The text will be formatted so that no line exceeds the given width. The text width set for QStaticText will not automatically be used for clipping. To achieve clipping in addition to line breaks, use &lt;a href=&quot;qpainter#setClipRect&quot;&gt;QPainter::setClipRect&lt;/a&gt;(). The position of the text is decided by the argument passed to &lt;a href=&quot;qpainter#drawStaticText&quot;&gt;QPainter::drawStaticText&lt;/a&gt;() and can change from call to call with a minimal impact on performance.</source>
          <target state="translated">如果在QStaticText对象上设置文本宽度，则将绑定文本。文本将被格式化，以使任何行都不会超过给定的宽度。为QStaticText设置的文本宽度不会自动用于剪切。要实现除换行之外的剪辑，请使用&lt;a href=&quot;qpainter#setClipRect&quot;&gt;QPainter :: setClipRect&lt;/a&gt;（）。文本的位置由传递给&lt;a href=&quot;qpainter#drawStaticText&quot;&gt;QPainter :: drawStaticText&lt;/a&gt;（）的参数确定，并且可以在每次调用之间更改，而对性能的影响最小。</target>
        </trans-unit>
        <trans-unit id="f5118897b753fa9be9a7cd2e59ff122df27064a9" translate="yes" xml:space="preserve">
          <source>If you set handleWidth to 1 or 0, the actual grab area will grow to overlap a few pixels of its respective widgets.</source>
          <target state="translated">如果你将handleWidth设置为1或0,实际的抓取区域将增长到与其各自的widgets重叠几个像素。</target>
        </trans-unit>
        <trans-unit id="d0ec48d57a2e4338f862d2ee757f449cd9f198c0" translate="yes" xml:space="preserve">
          <source>If you set the rectangle to a null rectangle (for example, &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt;(0, 0, 0, 0)), then the resulting frame rectangle is equivalent to the &lt;a href=&quot;qwidget#rect-prop&quot;&gt;widget rectangle&lt;/a&gt;.</source>
          <target state="translated">如果将矩形设置为空矩形（例如&lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt;（0，0，0，0）），则生成的框架矩形等效于&lt;a href=&quot;qwidget#rect-prop&quot;&gt;小部件矩形&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="431602cc3b53aaddb31c020ccf0ff4c5479bf5ad" translate="yes" xml:space="preserve">
          <source>If you set this property to &lt;code&gt;false&lt;/code&gt;, ensure the application provides a way to remove the file once it is no longer needed, including passing the responsibility on to another process. Always use the &lt;a href=&quot;qtemporaryfile#fileName&quot;&gt;fileName&lt;/a&gt;() function to obtain the name and never try to guess the name that &lt;a href=&quot;qtemporaryfile&quot;&gt;QTemporaryFile&lt;/a&gt; has generated.</source>
          <target state="translated">如果将此属性设置为 &lt;code&gt;false&lt;/code&gt; ，请确保应用程序提供了一种在不再需要该文件时将其删除的方法，包括将责任转移给另一个进程。始终使用&lt;a href=&quot;qtemporaryfile#fileName&quot;&gt;fileName&lt;/a&gt;（）函数获取名称，并且永远不要尝试猜测&lt;a href=&quot;qtemporaryfile&quot;&gt;QTemporaryFile&lt;/a&gt;已生成的名称。</target>
        </trans-unit>
        <trans-unit id="643778f0fba3e1dca37f5ecfec036f6d4506a847" translate="yes" xml:space="preserve">
          <source>If you simply want to check whether a &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; contains a particular character or substring, use &lt;a href=&quot;qbytearray#contains&quot;&gt;contains&lt;/a&gt;(). If you want to find out how many times a particular character or substring occurs in the byte array, use &lt;a href=&quot;qbytearray#count-3&quot;&gt;count&lt;/a&gt;(). If you want to replace all occurrences of a particular value with another, use one of the two-parameter &lt;a href=&quot;qbytearray#replace&quot;&gt;replace&lt;/a&gt;() overloads.</source>
          <target state="translated">如果仅想检查&lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt;是否包含特定字符或子字符串，请使用&lt;a href=&quot;qbytearray#contains&quot;&gt;contains&lt;/a&gt;（）。如果要找出某个特定字符或子字符串在字节数组中出现多少次，请使用&lt;a href=&quot;qbytearray#count-3&quot;&gt;count&lt;/a&gt;（）。如果要用另一个值替换所有出现的特定值，请使用两个参数的&lt;a href=&quot;qbytearray#replace&quot;&gt;replace&lt;/a&gt;（）重载之一。</target>
        </trans-unit>
        <trans-unit id="cac976791d1e9addf9b904ba22f784baa1588a2b" translate="yes" xml:space="preserve">
          <source>If you simply want to check whether a QByteArray contains a particular byte sequence, use &lt;a href=&quot;qbytearray#contains&quot;&gt;contains&lt;/a&gt;(). If you want to find out how many times a particular byte sequence occurs in the byte array, use &lt;a href=&quot;qbytearray#count-2&quot;&gt;count&lt;/a&gt;(). If you want to replace all occurrences of a particular value with another, use one of the two-parameter &lt;a href=&quot;qbytearray#replace&quot;&gt;replace&lt;/a&gt;() overloads.</source>
          <target state="translated">如果只想检查QByteArray是否包含特定的字节序列，请使用&lt;a href=&quot;qbytearray#contains&quot;&gt;contains&lt;/a&gt;（）。如果要找出特定字节序列在字节数组中出现了多少次，请使用&lt;a href=&quot;qbytearray#count-2&quot;&gt;count&lt;/a&gt;（）。如果要用另一个值替换所有出现的特定值，请使用两个参数的&lt;a href=&quot;qbytearray#replace&quot;&gt;replace&lt;/a&gt;（）重载之一。</target>
        </trans-unit>
        <trans-unit id="87a2577ad564dd126a26b47aade6cf82e32b532f" translate="yes" xml:space="preserve">
          <source>If you simply want to check whether a QByteArray contains a particular character or substring, use &lt;a href=&quot;qbytearray#contains&quot;&gt;contains&lt;/a&gt;(). If you want to find out how many times a particular character or substring occurs in the byte array, use &lt;a href=&quot;qbytearray#count-3&quot;&gt;count&lt;/a&gt;(). If you want to replace all occurrences of a particular value with another, use one of the two-parameter &lt;a href=&quot;qbytearray#replace&quot;&gt;replace&lt;/a&gt;() overloads.</source>
          <target state="translated">如果仅想检查QByteArray是否包含特定字符或子字符串，请使用&lt;a href=&quot;qbytearray#contains&quot;&gt;contains&lt;/a&gt;（）。如果要找出某个特定字符或子字符串在字节数组中出现多少次，请使用&lt;a href=&quot;qbytearray#count-3&quot;&gt;count&lt;/a&gt;（）。如果要用另一个值替换所有出现的特定值，请使用两个参数的&lt;a href=&quot;qbytearray#replace&quot;&gt;replace&lt;/a&gt;（）重载之一。</target>
        </trans-unit>
        <trans-unit id="08c8df14c776daca73491e96a250ef3ebfeca9c6" translate="yes" xml:space="preserve">
          <source>If you simply want to check whether a list contains a particular value, use &lt;a href=&quot;qlist#contains&quot;&gt;contains&lt;/a&gt;(). If you want to find out how many times a particular value occurs in the list, use &lt;a href=&quot;qlist#count-1&quot;&gt;count&lt;/a&gt;().</source>
          <target state="translated">如果只想检查列表是否包含特定值，请使用&lt;a href=&quot;qlist#contains&quot;&gt;contains&lt;/a&gt;（）。如果要找出列表中某个特定值出现的&lt;a href=&quot;qlist#count-1&quot;&gt;次数&lt;/a&gt;，请使用count（）。</target>
        </trans-unit>
        <trans-unit id="24518665c949173b5a4db723c29cc8031141b05a" translate="yes" xml:space="preserve">
          <source>If you simply want to check whether a list contains a particular value, use &lt;a href=&quot;qlist#contains&quot;&gt;contains&lt;/a&gt;(). If you want to find out how many times a particular value occurs in the list, use &lt;a href=&quot;qlist#count-1&quot;&gt;count&lt;/a&gt;(). If you want to replace all occurrences of a particular value with another, use &lt;a href=&quot;qlist#replace&quot;&gt;replace&lt;/a&gt;().</source>
          <target state="translated">如果仅想检查列表是否包含特定值，请使用&lt;a href=&quot;qlist#contains&quot;&gt;contains&lt;/a&gt;（）。如果要找出列表中特定值出现的&lt;a href=&quot;qlist#count-1&quot;&gt;次数&lt;/a&gt;，请使用count（）。如果要用另一个值替换所有出现的特定值，请使用&lt;a href=&quot;qlist#replace&quot;&gt;replace&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="ad6e5b02153501b6bb6236aff4d1862201610206" translate="yes" xml:space="preserve">
          <source>If you simply want to check whether a vector contains a particular value, use &lt;a href=&quot;qvector#contains&quot;&gt;contains&lt;/a&gt;(). If you want to find out how many times a particular value occurs in the vector, use &lt;a href=&quot;qvector#count-1&quot;&gt;count&lt;/a&gt;().</source>
          <target state="translated">如果只想检查向量是否包含特定值，请使用&lt;a href=&quot;qvector#contains&quot;&gt;contains&lt;/a&gt;（）。如果要找出向量中特定值出现了多少次，请使用&lt;a href=&quot;qvector#count-1&quot;&gt;count&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="2e296f249be4339e6509618575b567b889bbaad2" translate="yes" xml:space="preserve">
          <source>If you specify a deployment target value lower than what Qt requires, the application will almost certainly crash somewhere in the Qt libraries when run on an older version than Qt supports. Therefore, make sure that the actual build system code reflects the minimum OS version that is actually required.</source>
          <target state="translated">如果你指定的部署目标值低于Qt的要求,当应用程序在比Qt支持的旧版本上运行时,几乎肯定会在Qt库的某个地方崩溃。因此,确保实际的构建系统代码反映了实际需要的最低操作系统版本。</target>
        </trans-unit>
        <trans-unit id="7bcb3f27d98dc21bbbbdb2fca0feff41e2a96fee" translate="yes" xml:space="preserve">
          <source>If you specify a non-empty rect the tip will be hidden as soon as you move your cursor out of this area.</source>
          <target state="translated">如果你指定了一个非空的矩形,当你把光标移出这个区域时,提示就会被隐藏。</target>
        </trans-unit>
        <trans-unit id="5c568e1672c79d12d4f2fa5377fd0caa16da352f" translate="yes" xml:space="preserve">
          <source>If you specify a size of 0, the widget will be invisible. The size policies of the widgets are preserved. That is, a value smaller than the minimal size hint of the respective widget will be replaced by the value of the hint.</source>
          <target state="translated">如果您指定的大小为 0,小组件将不可见。小组件的大小策略将被保留。也就是说,小于各小组件最小尺寸提示的值将被提示值取代。</target>
        </trans-unit>
        <trans-unit id="c3fd839eb46fe8c9d85d7a5a8a27da4e517f92a1" translate="yes" xml:space="preserve">
          <source>If you specify an invalid format the format will not be set.</source>
          <target state="translated">如果您指定了无效的格式,则不会设置格式。</target>
        </trans-unit>
        <trans-unit id="fbc28d16ade9336d7264eba8457e21db3442a949" translate="yes" xml:space="preserve">
          <source>If you specify both DirsFirst and Reversed, directories are still put first, but in reverse order; the files will be listed after the directories, again in reverse order.</source>
          <target state="translated">如果你同时指定了DirsFirst和Reversed,目录仍然会被放在第一位,但顺序相反;文件会被列在目录之后,同样顺序相反。</target>
        </trans-unit>
        <trans-unit id="c50f9aa246ab355f1fe19024f21f5d5e73d6b6dd" translate="yes" xml:space="preserve">
          <source>If you store types that &lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;QVariant&lt;/a&gt; can't convert to &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; (e.g., &lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt;, &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt;, and &lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt;), Qt uses an &lt;code&gt;@&lt;/code&gt;-based syntax to encode the type. For example:</source>
          <target state="translated">如果您存储&lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;QVariant&lt;/a&gt;无法转换为&lt;a href=&quot;qstring&quot;&gt;QString的类型&lt;/a&gt;（例如&lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt;，&lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt;和&lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt;），则Qt使用基于 &lt;code&gt;@&lt;/code&gt; 的语法对类型进行编码。例如：</target>
        </trans-unit>
        <trans-unit id="231c42a287b5db792543b45ee495ed920b2f5439" translate="yes" xml:space="preserve">
          <source>If you store types that &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; can't convert to &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; (e.g., &lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt;, &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt;, and &lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt;), Qt uses an &lt;code&gt;@&lt;/code&gt;-based syntax to encode the type. For example:</source>
          <target state="translated">如果您存储&lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt;无法转换为&lt;a href=&quot;qstring&quot;&gt;QString的类型&lt;/a&gt;（例如&lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt;，&lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt;和&lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt;），则Qt使用基于 &lt;code&gt;@&lt;/code&gt; 的语法对类型进行编码。例如：</target>
        </trans-unit>
        <trans-unit id="c87ff348d61b82364184c96386b64b0cf54c3a7d" translate="yes" xml:space="preserve">
          <source>If you subclass &lt;a href=&quot;qabstractspinbox&quot;&gt;QAbstractSpinBox&lt;/a&gt; you will need to reimplement this function.</source>
          <target state="translated">如果您是&lt;a href=&quot;qabstractspinbox&quot;&gt;QAbstractSpinBox的&lt;/a&gt;子类，则需要重新实现此函数。</target>
        </trans-unit>
        <trans-unit id="ae78e35466488b5b971a806f36b2c10e455e5af7" translate="yes" xml:space="preserve">
          <source>If you subclass &lt;a href=&quot;qstandarditem&quot;&gt;QStandardItem&lt;/a&gt; and reimplement this function, your reimplementation should call &lt;a href=&quot;qstandarditem#emitDataChanged&quot;&gt;emitDataChanged&lt;/a&gt;() if you do not call the base implementation of setData(). This will ensure that e.g. views using the model are notified of the changes.</source>
          <target state="translated">如果将&lt;a href=&quot;qstandarditem&quot;&gt;QStandardItem&lt;/a&gt;子类化并重新实现此函数，则如果不调用setData（）的基本实现，则重新实现应调用&lt;a href=&quot;qstandarditem#emitDataChanged&quot;&gt;emitDataChanged&lt;/a&gt;（）。这将确保例如将使用该模型的视图通知更改。</target>
        </trans-unit>
        <trans-unit id="fc0b440d0989d912bb6682da839ae855b265651a" translate="yes" xml:space="preserve">
          <source>If you subclass &lt;code&gt;QAbstractSpinBox&lt;/code&gt; you must reimplement this function. Note that this function is called even if the resulting value will be outside the bounds of minimum and maximum. It's this function's job to handle these situations.</source>
          <target state="translated">如果子类 &lt;code&gt;QAbstractSpinBox&lt;/code&gt; ，则必须重新实现此函数。请注意，即使结果值超出最小和最大范围，也会调用此函数。处理这些情况是此功能的工作。</target>
        </trans-unit>
        <trans-unit id="9353c85818adf16a4bc1a52e583895bd302ea2de" translate="yes" xml:space="preserve">
          <source>If you subclass from &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt;, you need to provide a paintEvent for your custom &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; as below:</source>
          <target state="translated">如果您是&lt;a href=&quot;qwidget&quot;&gt;QWidget的&lt;/a&gt;子类，则需要为自定义&lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt;提供paintEvent，如下所示：</target>
        </trans-unit>
        <trans-unit id="bb52f46952c4064cd0eeb2d22c8c7cb412d66c28" translate="yes" xml:space="preserve">
          <source>If you subclass from &lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;QWidget&lt;/a&gt;, you need to provide a paintEvent for your custom &lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;QWidget&lt;/a&gt; as below:</source>
          <target state="translated">如果您是&lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;QWidget的&lt;/a&gt;子类，则需要为您的自定义&lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;QWidget&lt;/a&gt;提供paintEvent，如下所示：</target>
        </trans-unit>
        <trans-unit id="ece176f56b7b3a3ec40536468261faa29b795910" translate="yes" xml:space="preserve">
          <source>If you support drag and drop in your application, and want to start a drag and drop operation after the user has held down a mouse button for a certain amount of time, you should use this property's value as the delay.</source>
          <target state="translated">如果您的应用程序支持拖放,并希望在用户按住鼠标按钮一定时间后开始拖放操作,则应使用此属性的值作为延迟。</target>
        </trans-unit>
        <trans-unit id="8f148dd579171b7166c03213ee0d96a67bc0cade" translate="yes" xml:space="preserve">
          <source>If you support drag and drop in your application, and want to start a drag and drop operation after the user has moved the cursor a certain distance with a button held down, you should use this property's value as the minimum distance required.</source>
          <target state="translated">如果您在应用程序中支持拖放,并希望在用户按住按钮移动光标一定距离后开始拖放操作,则应使用此属性的值作为所需的最小距离。</target>
        </trans-unit>
        <trans-unit id="f13d66513fe41fec722e9d07d27596122258a5a2" translate="yes" xml:space="preserve">
          <source>If you target both C++17 and C++20, then you have a choice to make:</source>
          <target state="translated">如果你的目标是C++17和C++20,那么你可以选择。</target>
        </trans-unit>
        <trans-unit id="8085f25bc7d3665287233d8b17e5b0d757de1c83" translate="yes" xml:space="preserve">
          <source>If you then set the goal state to the</source>
          <target state="translated">如果你再将目标状态设置为</target>
        </trans-unit>
        <trans-unit id="a1ca8967666264a51f7b4a705a3ff46be5298235" translate="yes" xml:space="preserve">
          <source>If you throw an exception that is not a subclass of &lt;a href=&quot;qexception&quot;&gt;QException&lt;/a&gt;, the Qt functions will throw a &lt;a href=&quot;qunhandledexception&quot;&gt;QUnhandledException&lt;/a&gt; in the receiver thread.</source>
          <target state="translated">如果抛出的异常不是&lt;a href=&quot;qexception&quot;&gt;QException&lt;/a&gt;的子类，则Qt函数将在接收器线程中抛出&lt;a href=&quot;qunhandledexception&quot;&gt;QUnhandledException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1e6fe6b18019d3901f3bd7bd5cde046c4a9dd373" translate="yes" xml:space="preserve">
          <source>If you throw an exception that is not a subclass of QException, the &lt;a href=&quot;qtconcurrent-index&quot;&gt;Qt Concurrent&lt;/a&gt; functions will throw a &lt;a href=&quot;qunhandledexception&quot;&gt;QUnhandledException&lt;/a&gt; in the receiver thread.</source>
          <target state="translated">如果引发的异常不是QException的子类，则&lt;a href=&quot;qtconcurrent-index&quot;&gt;Qt Concurrent&lt;/a&gt;函数将在接收器线程中引发&lt;a href=&quot;qunhandledexception&quot;&gt;QUnhandledException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ddc45a2b5d97538714b537dca7a4e0f201861cd9" translate="yes" xml:space="preserve">
          <source>If you throw an exception that is not a subclass of QException, the Qt functions will throw a &lt;a href=&quot;qunhandledexception&quot;&gt;QUnhandledException&lt;/a&gt; in the receiver thread.</source>
          <target state="translated">如果引发的异常不是QException的子类，则Qt函数将在接收器线程中引发&lt;a href=&quot;qunhandledexception&quot;&gt;QUnhandledException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="027dcf6fa70f50b1e0fcca67f8e009d8475a3f1a" translate="yes" xml:space="preserve">
          <source>If you try to clear the error stack, make sure not just keep going until GL_NO_ERROR is returned but also break on GL_CONTEXT_LOST as that error value will keep repeating.</source>
          <target state="translated">如果你试图清除错误堆栈,确保不只是继续前进,直到GL_NO_ERROR被返回,还要在GL_CONTEXT_LOST上中断,因为那个错误值会不断重复。</target>
        </trans-unit>
        <trans-unit id="66d8fb540e390350ceab15ad11cb2d14cbfa76b0" translate="yes" xml:space="preserve">
          <source>If you try to pass a value from another enum or just a plain integer other than 0, the compiler will report an error. If you need to cast integer values to flags in a untyped fashion, you can use the explicit &lt;a href=&quot;qflags&quot;&gt;QFlags&lt;/a&gt; constructor as cast operator.</source>
          <target state="translated">如果尝试传递另一个枚举的值或只是0以外的纯整数​​，则编译器将报告错误。如果需要以无类型的方式将整数值转换为标志，则可以将显式&lt;a href=&quot;qflags&quot;&gt;QFlags&lt;/a&gt;构造函数用作转换运算符。</target>
        </trans-unit>
        <trans-unit id="dcb44c725b25ec894202eb06cd1d44a2a0f69d55" translate="yes" xml:space="preserve">
          <source>If you try to pass a value from another enum or just a plain integer other than 0, the compiler will report an error. If you need to cast integer values to flags in a untyped fashion, you can use the explicit QFlags constructor as cast operator.</source>
          <target state="translated">如果你试图从另一个枚举中传递一个值,或者只是一个0以外的普通整数,编译器将报告一个错误。如果您需要以非类型的方式将整数值转换为标志,您可以使用显式QFlags构造函数作为转换操作符。</target>
        </trans-unit>
        <trans-unit id="bb489276c3a79691beb36d8c22727f950ccbce1a" translate="yes" xml:space="preserve">
          <source>If you use &lt;a href=&quot;qabstractitemview#scrollDirtyRegion&quot;&gt;scrollDirtyRegion&lt;/a&gt;() and implement a &lt;a href=&quot;qabstractscrollarea#paintEvent&quot;&gt;paintEvent&lt;/a&gt;() in a subclass of &lt;a href=&quot;qabstractitemview&quot;&gt;QAbstractItemView&lt;/a&gt;, you should translate the area given by the paint event with the offset returned from this function.</source>
          <target state="translated">如果使用&lt;a href=&quot;qabstractitemview#scrollDirtyRegion&quot;&gt;scrollDirtyRegion&lt;/a&gt;（）并在&lt;a href=&quot;qabstractitemview&quot;&gt;QAbstractItemView&lt;/a&gt;的子类中实现&lt;a href=&quot;qabstractscrollarea#paintEvent&quot;&gt;paintEvent&lt;/a&gt;（），则应使用此函数返回的偏移量转换paint事件给定的区域。</target>
        </trans-unit>
        <trans-unit id="e6aba7ba4a932684c2acb8eec62838cbcb85b7d7" translate="yes" xml:space="preserve">
          <source>If you use &lt;a href=&quot;qmake-manual&quot;&gt;qmake&lt;/a&gt; to build your projects, Qt GUI is included by default. To disable Qt GUI, add the following line to your &lt;code&gt;.pro&lt;/code&gt; file:</source>
          <target state="translated">如果使用&lt;a href=&quot;qmake-manual&quot;&gt;qmake&lt;/a&gt;生成项目，则默认包含Qt GUI。要禁用Qt GUI，请将以下行添加到您的 &lt;code&gt;.pro&lt;/code&gt; 文件中：</target>
        </trans-unit>
        <trans-unit id="38adad0e80433ce5374cc3c78d3eeea7fbd65411" translate="yes" xml:space="preserve">
          <source>If you use &lt;a href=&quot;qmake-manual&quot;&gt;qmake&lt;/a&gt; to build your projects, Qt5Core is linked by default.</source>
          <target state="translated">如果使用&lt;a href=&quot;qmake-manual&quot;&gt;qmake&lt;/a&gt;生成项目，则默认情况下会链接Qt5Core。</target>
        </trans-unit>
        <trans-unit id="bc4325b1354acc5281ba2a79d5d91a7fe1bf2be8" translate="yes" xml:space="preserve">
          <source>If you use &lt;a href=&quot;qmake-manual&quot;&gt;qmake&lt;/a&gt; to build your projects, Qt6Core is linked by default.</source>
          <target state="translated">如果使用&lt;a href=&quot;qmake-manual&quot;&gt;qmake&lt;/a&gt;生成项目，则默认情况下会链接Qt6Core。</target>
        </trans-unit>
        <trans-unit id="e8e48c29c8a771681aeab39c3750bbdd6685da63" translate="yes" xml:space="preserve">
          <source>If you use &lt;a href=&quot;qmake-manual&quot;&gt;qmake&lt;/a&gt; to create your makefiles, build rules will be included that call the moc when required, so you will not need to use the moc directly. For more background information on &lt;code&gt;moc&lt;/code&gt;, see &lt;a href=&quot;why-moc&quot;&gt;Why Does Qt Use Moc for Signals and Slots?&lt;/a&gt;</source>
          <target state="translated">如果使用&lt;a href=&quot;qmake-manual&quot;&gt;qmake&lt;/a&gt;创建makefile，则将包含在需要时调用moc的构建规则，因此您无需直接使用moc。有关 &lt;code&gt;moc&lt;/code&gt; 的更多背景信息，请参阅&lt;a href=&quot;why-moc&quot;&gt;Qt为什么将Moc用于信号和插槽？&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5075d8a58cbccf2b19a18fc8f3d40ecfa88c3b3e" translate="yes" xml:space="preserve">
          <source>If you use &lt;a href=&quot;qmake-manual&quot;&gt;qmake&lt;/a&gt; to create your makefiles, build rules will be included that call the moc when required, so you will not need to use the moc directly. For more background information on &lt;code&gt;moc&lt;/code&gt;, see &lt;a href=&quot;why-moc#&quot;&gt;Why Does Qt Use Moc for Signals and Slots?&lt;/a&gt;</source>
          <target state="translated">如果使用&lt;a href=&quot;qmake-manual&quot;&gt;qmake&lt;/a&gt;创建makefile，则将包含在需要时调用moc的构建规则，因此您无需直接使用moc。有关 &lt;code&gt;moc&lt;/code&gt; 的更多背景信息，请参阅&lt;a href=&quot;why-moc#&quot;&gt;Qt为什么将Moc用于信号和插槽？&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b813a975620cedd1d63c1f6520825459dbde2ad0" translate="yes" xml:space="preserve">
          <source>If you use &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; from many places in your application, you might want to specify the organization name and the application name using &lt;a href=&quot;qcoreapplication#organizationName-prop&quot;&gt;QCoreApplication::setOrganizationName&lt;/a&gt;() and &lt;a href=&quot;qcoreapplication#applicationName-prop&quot;&gt;QCoreApplication::setApplicationName&lt;/a&gt;(), and then use the default &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; constructor:</source>
          <target state="translated">如果您从应用程序中的许多地方使用&lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt;，则可能要使用&lt;a href=&quot;qcoreapplication#organizationName-prop&quot;&gt;QCoreApplication :: setOrganizationName&lt;/a&gt;（）和&lt;a href=&quot;qcoreapplication#applicationName-prop&quot;&gt;QCoreApplication :: setApplicationName&lt;/a&gt;（）来指定组织名称和应用程序名称，然后使用默认的&lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt;构造函数：</target>
        </trans-unit>
        <trans-unit id="add980e843a7ddc5f181f430dafc7f2dc6cb6c8e" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;qmake&lt;/code&gt; and Makefiles, use the &lt;code&gt;QMAKE_LFLAGS_SONAME&lt;/code&gt; setting:</source>
          <target state="translated">如果使用 &lt;code&gt;qmake&lt;/code&gt; 和Makefile，请使用 &lt;code&gt;QMAKE_LFLAGS_SONAME&lt;/code&gt; 设置：</target>
        </trans-unit>
        <trans-unit id="5ca554fbe42cc1b563f4e294b48a29dc639174dd" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;qmake&lt;/code&gt;, &lt;code&gt;uic&lt;/code&gt; will be invoked automatically for header files.</source>
          <target state="translated">如果使用 &lt;code&gt;qmake&lt;/code&gt; ，则将自动为头文件调用 &lt;code&gt;uic&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e7d198e76b0848bba0df3f109a280cd4be89b9b1" translate="yes" xml:space="preserve">
          <source>If you use QSettings from many places in your application, you might want to specify the organization name and the application name using &lt;a href=&quot;qcoreapplication#organizationName-prop&quot;&gt;QCoreApplication::setOrganizationName&lt;/a&gt;() and &lt;a href=&quot;qcoreapplication#applicationName-prop&quot;&gt;QCoreApplication::setApplicationName&lt;/a&gt;(), and then use the default QSettings constructor:</source>
          <target state="translated">如果您从应用程序中的许多地方使用QSettings，则可能要使用&lt;a href=&quot;qcoreapplication#organizationName-prop&quot;&gt;QCoreApplication :: setOrganizationName&lt;/a&gt;（）和&lt;a href=&quot;qcoreapplication#applicationName-prop&quot;&gt;QCoreApplication :: setApplicationName&lt;/a&gt;（）来指定组织名称和应用程序名称，然后使用默认的QSettings构造函数：</target>
        </trans-unit>
        <trans-unit id="8046036d7c642b36de61fa7d4f65213dd3c58f67" translate="yes" xml:space="preserve">
          <source>If you use a brush with a &lt;a href=&quot;qgradient&quot;&gt;QGradient&lt;/a&gt;, the gradient is relative to the item's coordinate system.</source>
          <target state="translated">如果使用带有&lt;a href=&quot;qgradient&quot;&gt;QGradient&lt;/a&gt;的画笔，则渐变是相对于项目的坐标系的。</target>
        </trans-unit>
        <trans-unit id="c0c7225d70c96d951d167a22fe91ba16e501ed52" translate="yes" xml:space="preserve">
          <source>If you use a read-write &lt;a href=&quot;qsqlrelationaltablemodel&quot;&gt;QSqlRelationalTableModel&lt;/a&gt;, you probably want to use &lt;a href=&quot;qsqlrelationaldelegate&quot;&gt;QSqlRelationalDelegate&lt;/a&gt; on the view. Unlike the default delegate, &lt;a href=&quot;qsqlrelationaldelegate&quot;&gt;QSqlRelationalDelegate&lt;/a&gt; provides a combobox for fields that are foreign keys into other tables. To use the class, simply call &lt;a href=&quot;qabstractitemview#setItemDelegate&quot;&gt;QAbstractItemView::setItemDelegate&lt;/a&gt;() on the view with an instance of &lt;a href=&quot;qsqlrelationaldelegate&quot;&gt;QSqlRelationalDelegate&lt;/a&gt;:</source>
          <target state="translated">如果使用读写&lt;a href=&quot;qsqlrelationaltablemodel&quot;&gt;QSqlRelationalTableModel&lt;/a&gt;，则可能要在视图上使用&lt;a href=&quot;qsqlrelationaldelegate&quot;&gt;QSqlRelationalDelegate&lt;/a&gt;。与默认委托不同，&lt;a href=&quot;qsqlrelationaldelegate&quot;&gt;QSqlRelationalDelegate&lt;/a&gt;为作为其他表外键的字段提供了一个组合框。要使用该类，只需使用&lt;a href=&quot;qabstractitemview#setItemDelegate&quot;&gt;QSqlRelationalDelegate&lt;/a&gt;实例在视图上调用QAbstractItemView :: setItemDelegate（）&lt;a href=&quot;qsqlrelationaldelegate&quot;&gt;即可&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="7267dab6ad282a831b2450c95cd58c10f01a164f" translate="yes" xml:space="preserve">
          <source>If you use a read-write QSqlRelationalTableModel, you probably want to use &lt;a href=&quot;qsqlrelationaldelegate&quot;&gt;QSqlRelationalDelegate&lt;/a&gt; on the view. Unlike the default delegate, &lt;a href=&quot;qsqlrelationaldelegate&quot;&gt;QSqlRelationalDelegate&lt;/a&gt; provides a combobox for fields that are foreign keys into other tables. To use the class, simply call &lt;a href=&quot;qabstractitemview#setItemDelegate&quot;&gt;QAbstractItemView::setItemDelegate&lt;/a&gt;() on the view with an instance of &lt;a href=&quot;qsqlrelationaldelegate&quot;&gt;QSqlRelationalDelegate&lt;/a&gt;:</source>
          <target state="translated">如果使用读写QSqlRelationalTableModel，则可能要在视图上使用&lt;a href=&quot;qsqlrelationaldelegate&quot;&gt;QSqlRelationalDelegate&lt;/a&gt;。与默认委托不同，&lt;a href=&quot;qsqlrelationaldelegate&quot;&gt;QSqlRelationalDelegate&lt;/a&gt;为作为其他表外键的字段提供了一个组合框。要使用该类，只需使用&lt;a href=&quot;qabstractitemview#setItemDelegate&quot;&gt;QSqlRelationalDelegate&lt;/a&gt;的实例在视图上调用QAbstractItemView :: setItemDelegate（）&lt;a href=&quot;qsqlrelationaldelegate&quot;&gt;即可&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="c025e0f62d5d506b03891dcc3eaa3313b1ceb63f" translate="yes" xml:space="preserve">
          <source>If you use another build system, you can pass the following defines to the compiler:</source>
          <target state="translated">如果你使用其他的构建系统,你可以将以下定义传递给编译器。</target>
        </trans-unit>
        <trans-unit id="90bf696ac5affef197c98e800663b6802cd8d7c8" translate="yes" xml:space="preserve">
          <source>If you use the &lt;a href=&quot;qwidget#windowModified-prop&quot;&gt;windowModified&lt;/a&gt; mechanism, the window title must contain a &quot;[*]&quot; placeholder, which indicates where the '*' should appear. Normally, it should appear right after the file name (e.g., &quot;document1.txt[*] - Text Editor&quot;). If the &lt;a href=&quot;qwidget#windowModified-prop&quot;&gt;windowModified&lt;/a&gt; property is &lt;code&gt;false&lt;/code&gt; (the default), the placeholder is simply removed.</source>
          <target state="translated">如果使用&lt;a href=&quot;qwidget#windowModified-prop&quot;&gt;windowModified&lt;/a&gt;机制，则窗口标题必须包含&amp;ldquo; [*]&amp;rdquo;占位符，该占位符指示应在何处显示&amp;ldquo; *&amp;rdquo;。通常，它应该出现在文件名之后（例如，&amp;ldquo; document1.txt [*]-文本编辑器&amp;rdquo;）。如果&lt;a href=&quot;qwidget#windowModified-prop&quot;&gt;windowModified&lt;/a&gt;属性为 &lt;code&gt;false&lt;/code&gt; （默认值），则仅删除占位符。</target>
        </trans-unit>
        <trans-unit id="c104e6782e776da7461bb5c1aab379d1fa1f4f8b" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;Q_CLASSINFO()&lt;/code&gt; macro to provide the unique identifiers or other attributes for your class you can use the &lt;code&gt;QAXFACTORY_BEGIN()&lt;/code&gt;, &lt;code&gt;QAXCLASS()&lt;/code&gt; and &lt;code&gt;QAXFACTORY_END()&lt;/code&gt; macros to expose one or more classes as COM objects.</source>
          <target state="translated">如果使用 &lt;code&gt;Q_CLASSINFO()&lt;/code&gt; 宏为类提供唯一的标识符或其他属性，则可以使用 &lt;code&gt;QAXFACTORY_BEGIN()&lt;/code&gt; ， &lt;code&gt;QAXCLASS()&lt;/code&gt; 和 &lt;code&gt;QAXFACTORY_END()&lt;/code&gt; 宏将一个或多个类公开为COM对象。</target>
        </trans-unit>
        <trans-unit id="164b8c02eec01fef31a24f7930bbb2f55c2f7660" translate="yes" xml:space="preserve">
          <source>If you use the glBindFramebuffer() in &lt;a href=&quot;https://doc.qt.io/qt-5.13/qopenglfunctions.html&quot;&gt;QOpenGLFunctions&lt;/a&gt; you do not have to worry about this, as it automatically binds the current context's defaultFramebufferObject() when 0 is passed.</source>
          <target state="translated">如果在QOpenGLFunctions中使用glBindFramebuffer（），&lt;a href=&quot;https://doc.qt.io/qt-5.13/qopenglfunctions.html&quot;&gt;则&lt;/a&gt;不必担心，因为当传递0时它将自动绑定当前上下文的defaultFramebufferObject（）。</target>
        </trans-unit>
        <trans-unit id="fb17754f91efde520feefac682c5ad6ae082a405" translate="yes" xml:space="preserve">
          <source>If you use the glBindFramebuffer() in &lt;a href=&quot;https://doc.qt.io/qt-5.15/qopenglfunctions.html&quot;&gt;QOpenGLFunctions&lt;/a&gt; you do not have to worry about this, as it automatically binds the current context's defaultFramebufferObject() when 0 is passed.</source>
          <target state="translated">如果在QOpenGLFunctions中使用glBindFramebuffer（），&lt;a href=&quot;https://doc.qt.io/qt-5.15/qopenglfunctions.html&quot;&gt;则&lt;/a&gt;不必担心，因为当传递0时它将自动绑定当前上下文的defaultFramebufferObject（）。</target>
        </trans-unit>
        <trans-unit id="f468c4dcd7ae0f41a77be8739a867319c8333d20" translate="yes" xml:space="preserve">
          <source>If you use the glBindFramebuffer() in &lt;a href=&quot;https://doc.qt.io/qt-6.0/qopenglfunctions.html&quot;&gt;QOpenGLFunctions&lt;/a&gt; you do not have to worry about this, as it automatically binds the current context's defaultFramebufferObject() when 0 is passed.</source>
          <target state="translated">如果在QOpenGLFunctions中使用glBindFramebuffer（），&lt;a href=&quot;https://doc.qt.io/qt-6.0/qopenglfunctions.html&quot;&gt;则&lt;/a&gt;不必担心，因为当传递0时它将自动绑定当前上下文的defaultFramebufferObject（）。</target>
        </trans-unit>
        <trans-unit id="0f12ce158944d746542b9a9070afb13270bd3b5d" translate="yes" xml:space="preserve">
          <source>If you use this signal handler, emitParticles will not be emitted.</source>
          <target state="translated">如果你使用这个信号处理程序,emitParticles将不会被发射。</target>
        </trans-unit>
        <trans-unit id="465dd22453cd823b86d8a7cec428c5c9a97d2db7" translate="yes" xml:space="preserve">
          <source>If you want a blocking lookup, use the &lt;a href=&quot;qhostinfo#fromName&quot;&gt;QHostInfo::fromName&lt;/a&gt;() function:</source>
          <target state="translated">如果要阻止查找，请使用&lt;a href=&quot;qhostinfo#fromName&quot;&gt;QHostInfo :: fromName&lt;/a&gt;（）函数：</target>
        </trans-unit>
        <trans-unit id="78ed224dea9cfd5f1b0963e7c161808ef5c73770" translate="yes" xml:space="preserve">
          <source>If you want a specific button to be default you need to call &lt;a href=&quot;qpushbutton#default-prop&quot;&gt;QPushButton::setDefault&lt;/a&gt;() on it yourself. However, if there is no default button set and to preserve which button is the default button across platforms when using the &lt;a href=&quot;qpushbutton#autoDefault-prop&quot;&gt;QPushButton::autoDefault&lt;/a&gt; property, the first push button with the accept role is made the default button when the &lt;a href=&quot;qdialogbuttonbox&quot;&gt;QDialogButtonBox&lt;/a&gt; is shown,</source>
          <target state="translated">如果要使特定按钮为默认按钮，则需要自己对其调用&lt;a href=&quot;qpushbutton#default-prop&quot;&gt;QPushButton :: setDefault&lt;/a&gt;（）。但是，如果没有默认的按钮设置，并保留哪个按钮是横跨使用时，平台上的默认按钮&lt;a href=&quot;qpushbutton#autoDefault-prop&quot;&gt;QPushButton :: autoDefault&lt;/a&gt;财产，与接受角色的第一个按钮成为默认按钮时&lt;a href=&quot;qdialogbuttonbox&quot;&gt;QDialogBu​​ttonBox&lt;/a&gt;所示，</target>
        </trans-unit>
        <trans-unit id="0fa2282427297e4978d3699f219b2c5e588f1c63" translate="yes" xml:space="preserve">
          <source>If you want a specific button to be default you need to call &lt;a href=&quot;qpushbutton#default-prop&quot;&gt;QPushButton::setDefault&lt;/a&gt;() on it yourself. However, if there is no default button set and to preserve which button is the default button across platforms when using the &lt;a href=&quot;qpushbutton#autoDefault-prop&quot;&gt;QPushButton::autoDefault&lt;/a&gt; property, the first push button with the accept role is made the default button when the QDialogButtonBox is shown,</source>
          <target state="translated">如果要使特定按钮为默认按钮，则需要自己对其调用&lt;a href=&quot;qpushbutton#default-prop&quot;&gt;QPushButton :: setDefault&lt;/a&gt;（）。但是，如果没有设置默认按钮，并且在使用&lt;a href=&quot;qpushbutton#autoDefault-prop&quot;&gt;QPushButton :: autoDefault&lt;/a&gt;属性时要保留哪个按钮是跨平台的默认按钮，则当显示QDialogBu​​ttonBox时，具有accept角色的第一个按钮将成为默认按钮，</target>
        </trans-unit>
        <trans-unit id="d0ee116c48b7a25f03a5fdc1279c7c88d799aac8" translate="yes" xml:space="preserve">
          <source>If you want a table that uses your own data model you should use &lt;a href=&quot;qtableview&quot;&gt;QTableView&lt;/a&gt; rather than this class.</source>
          <target state="translated">如果要使用自己的数据模型的表，则应使用&lt;a href=&quot;qtableview&quot;&gt;QTableView&lt;/a&gt;而不是此类。</target>
        </trans-unit>
        <trans-unit id="4066f30b49e877beb77fbbb1b03dbbd2aab03b4a" translate="yes" xml:space="preserve">
          <source>If you want all windows in a Mac application to share one menu bar, don't use this function to create it, because the menu bar created here will have this &lt;a href=&quot;qmainwindow&quot;&gt;QMainWindow&lt;/a&gt; as its parent. Instead, you must create a menu bar that does not have a parent, which you can then share among all the Mac windows. Create a parent-less menu bar this way:</source>
          <target state="translated">如果要让Mac应用程序中的所有窗口共享一个菜单栏，请不要使用此功能来创建它，因为在此处创建的菜单栏将以该&lt;a href=&quot;qmainwindow&quot;&gt;QMainWindow&lt;/a&gt;作为其父项。而是必须创建一个没有父项的菜单栏，然后​​可以在所有Mac窗口之间共享。通过以下方式创建无父菜单栏：</target>
        </trans-unit>
        <trans-unit id="31b95d83456383d9523b22a6f580deb4b0c226d2" translate="yes" xml:space="preserve">
          <source>If you want all windows in a Mac application to share one menu bar, you must create a menu bar that does not have a parent. Create a parent-less menu bar this way:</source>
          <target state="translated">如果你想让Mac应用程序中的所有窗口共享一个菜单栏,你必须创建一个没有父级的菜单栏。这样创建一个没有父级的菜单栏。</target>
        </trans-unit>
        <trans-unit id="8ea9eff46c8438d5355c7754f5d314f0d0331659" translate="yes" xml:space="preserve">
          <source>If you want different graphics or audio for different geographical regions, you can use Qt.&lt;a href=&quot;technical-guide#locale&quot;&gt;locale&lt;/a&gt;() to get the current locale. Then you choose appropriate graphics or audio for that locale.</source>
          <target state="translated">如果要在不同的地理区域使用不同的图形或音频，则可以使用Qt。&lt;a href=&quot;technical-guide#locale&quot;&gt;locale&lt;/a&gt;（）获取当前语言环境。然后，为该语言环境选择适当的图形或音频。</target>
        </trans-unit>
        <trans-unit id="96fd471fc25b52cec53b8d2cc0b1229f4fd6c36d" translate="yes" xml:space="preserve">
          <source>If you want different graphics or audio for different geographical regions, you can use Qt.locale() to get the current locale. Then you choose appropriate graphics or audio for that locale.</source>
          <target state="translated">如果你想为不同的地理区域选择不同的图形或音频,你可以使用Qt.locale()来获取当前的语言环境。然后为该地区选择合适的图形或音频。</target>
        </trans-unit>
        <trans-unit id="446f88c9cddd8c4474604644640db651614e76a6" translate="yes" xml:space="preserve">
          <source>If you want neither the default, nor the minimal QPA plugin to be linked automatically, use:</source>
          <target state="translated">如果你既不想让默认的,也不想让最小的QPA插件自动链接,请使用。</target>
        </trans-unit>
        <trans-unit id="2d47cc94dbf68db6da16e38d0ed6134803359234" translate="yes" xml:space="preserve">
          <source>If you want the ScrollView to only scroll vertically, you can bind &lt;a href=&quot;qml-qtquick-controls2-pane#contentWidth-prop&quot;&gt;contentWidth&lt;/a&gt; to &lt;a href=&quot;qml-qtquick-controls2-control#availableWidth-prop&quot;&gt;availableWidth&lt;/a&gt; (and vice versa for contentHeight). This will let the contents fill out all the available space horizontally inside the ScrollView, taking any padding or scroll bars into account.</source>
          <target state="translated">如果希望ScrollView仅垂直滚动，则可以将&lt;a href=&quot;qml-qtquick-controls2-pane#contentWidth-prop&quot;&gt;contentWidth&lt;/a&gt;绑定到&lt;a href=&quot;qml-qtquick-controls2-control#availableWidth-prop&quot;&gt;availableWidth&lt;/a&gt;（对于contentHeight则相反）。这将使内容在ScrollView内水平填充所有可用空间，同时考虑到任何填充或滚动条。</target>
        </trans-unit>
        <trans-unit id="0b89c527347aa3766219b2a3bded0796f0992a5d" translate="yes" xml:space="preserve">
          <source>If you want the items to occupy adjacent memory positions, use &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt;.</source>
          <target state="translated">如果您希望这些项目占据相邻的内存位置，请使用&lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9fdd7c36b6c3979f02bf13657853e90c75d56a84" translate="yes" xml:space="preserve">
          <source>If you want the plugin to be loadable then one approach is to create a subdirectory under the application, and place the plugin in that directory. If you distribute any of the plugins that come with Qt (the ones located in the &lt;code&gt;plugins&lt;/code&gt; directory), you must copy the subdirectory under &lt;code&gt;plugins&lt;/code&gt; where the plugin is located to your applications root folder (i.e., do not include the &lt;code&gt;plugins&lt;/code&gt; directory).</source>
          <target state="translated">如果您希望插件可加载，则一种方法是在应用程序下创建一个子目录，并将插件放置在该目录中。如果分发Qt附带的任何插件（位于 &lt;code&gt;plugins&lt;/code&gt; 目录中），则必须将 &lt;code&gt;plugins&lt;/code&gt; 所在的插件下的子目录复制到应用程序的根文件夹（即，不包括 &lt;code&gt;plugins&lt;/code&gt; 目录）。</target>
        </trans-unit>
        <trans-unit id="1547dbbe53958db51bfc0636fe2d9a75dcedc772" translate="yes" xml:space="preserve">
          <source>If you want the rest of the URL to be case insensitive, you will have to take care of that yourself inside your image provider.</source>
          <target state="translated">如果你想让URL的其他部分不区分大小写,你必须在你的图片提供者中自己处理。</target>
        </trans-unit>
        <trans-unit id="b2ceee3ac5c8d581ed65d658427fc7dba2f3ab94" translate="yes" xml:space="preserve">
          <source>If you want the widget to be deleted when it is closed, create it with the &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_DeleteOnClose&lt;/a&gt; flag. This is very useful for independent top-level windows in a multi-window application.</source>
          <target state="translated">如果希望在关闭小部件时将其删除，请使用&lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt :: WA_DeleteOnClose&lt;/a&gt;标志创建它。这对于多窗口应用程序中的独立顶级窗口非常有用。</target>
        </trans-unit>
        <trans-unit id="f616738a391d1d34bf98d9064907be46ceb77ccb" translate="yes" xml:space="preserve">
          <source>If you want to abort the print job, &lt;a href=&quot;qprinter#abort&quot;&gt;abort&lt;/a&gt;() will try its best to stop printing. It may cancel the entire job or just part of it.</source>
          <target state="translated">如果要中止打印作业，&lt;a href=&quot;qprinter#abort&quot;&gt;abort&lt;/a&gt;（）将尽最大努力停止打印。它可能会取消全部或部分工作。</target>
        </trans-unit>
        <trans-unit id="072f5ce0b0ae384f54c36e755b7c3114bd8b4caa" translate="yes" xml:space="preserve">
          <source>If you want to access the text of a node use &lt;a href=&quot;qdomelement#text&quot;&gt;text&lt;/a&gt;(), e.g.</source>
          <target state="translated">如果要访问节点的文本，请使用&lt;a href=&quot;qdomelement#text&quot;&gt;text&lt;/a&gt;（），例如</target>
        </trans-unit>
        <trans-unit id="af270e6549ee7a5853d9d59523cdb19eafa6e734" translate="yes" xml:space="preserve">
          <source>If you want to append a certain number of identical characters to the string, use the &lt;a href=&quot;qstring#resize-1&quot;&gt;resize&lt;/a&gt;(int, &lt;a href=&quot;qchar&quot;&gt;QChar&lt;/a&gt;) overload.</source>
          <target state="translated">如果要在字符串后附加一定数量的相同字符，请使用&lt;a href=&quot;qstring#resize-1&quot;&gt;resize&lt;/a&gt;（int，&lt;a href=&quot;qchar&quot;&gt;QChar&lt;/a&gt;）重载。</target>
        </trans-unit>
        <trans-unit id="d3f48ed15b40dae528dee1be307fa458c590e4e7" translate="yes" xml:space="preserve">
          <source>If you want to append a certain number of identical characters to the string, use the &lt;a href=&quot;qstring#resize-1&quot;&gt;resize&lt;/a&gt;(qsizetype, &lt;a href=&quot;qchar&quot;&gt;QChar&lt;/a&gt;) overload.</source>
          <target state="translated">如果要在字符串后附加一定数量的相同字符，请使用&lt;a href=&quot;qstring#resize-1&quot;&gt;resize&lt;/a&gt;（qsizetype，&lt;a href=&quot;qchar&quot;&gt;QChar&lt;/a&gt;）重载。</target>
        </trans-unit>
        <trans-unit id="74615ef5923d5f6bd1ef246221c633d243a15754" translate="yes" xml:space="preserve">
          <source>If you want to be notified when a state machine sends out an event, you can connect to the corresponding signal. For example, for a media player state machine which indicates that playback has stopped by sending an event, you can write:</source>
          <target state="translated">如果你想在状态机发出事件时得到通知,你可以连接到相应的信号。例如,对于一个媒体播放器的状态机,它通过发送事件来指示播放已经停止,你可以写。</target>
        </trans-unit>
        <trans-unit id="829cc87afe3eb42cae7ecff016f3497ad8d384a4" translate="yes" xml:space="preserve">
          <source>If you want to be sure not to lose any debug message, you must use real-time logging instead of calling this function. However, debug messages might still be generated in the timespan between context creation and activation of real-time logging (or, in general, when the real-time logging is disabled).</source>
          <target state="translated">如果想确保不丢失任何调试消息,就必须使用实时日志而不是调用这个函数。但是,在创建上下文和激活实时日志之间的时间段内(或者,在一般情况下,当实时日志被禁用时),可能仍然会产生调试消息。</target>
        </trans-unit>
        <trans-unit id="edd46e63010e9398a3500347fb1d6ed771b6b5b7" translate="yes" xml:space="preserve">
          <source>If you want to build a new dynamic library combining the Qt 4 dynamic libraries, you need to introduce the &lt;code&gt;ld -r&lt;/code&gt; flag. Then relocation information is stored in the output file, so that this file could be the subject of another &lt;code&gt;ld&lt;/code&gt; run. This is done by setting the &lt;code&gt;-r&lt;/code&gt; flag in the &lt;code&gt;.pro&lt;/code&gt; file, and the &lt;code&gt;LFLAGS&lt;/code&gt; settings.</source>
          <target state="translated">如果要构建结合了Qt 4动态库的新动态库，则需要引入 &lt;code&gt;ld -r&lt;/code&gt; 标志。然后，重定位信息将存储在输出文件中，以便该文件可能成为另一个 &lt;code&gt;ld&lt;/code&gt; 运行的主题。这是通过在 &lt;code&gt;.pro&lt;/code&gt; 文件中设置 &lt;code&gt;-r&lt;/code&gt; 标志以及 &lt;code&gt;LFLAGS&lt;/code&gt; 设置来完成的。</target>
        </trans-unit>
        <trans-unit id="843fe25910ba44929f16216b7ddc23cd36be1a71" translate="yes" xml:space="preserve">
          <source>If you want to build a project</source>
          <target state="translated">如果你想建立一个项目</target>
        </trans-unit>
        <trans-unit id="b52f7beae447ca8d6352804a7b7084b76da5b4fb" translate="yes" xml:space="preserve">
          <source>If you want to change the item's bounding rectangle, you must first call &lt;a href=&quot;qgraphicsitem#prepareGeometryChange&quot;&gt;prepareGeometryChange&lt;/a&gt;(). This notifies the scene of the imminent change, so that it can update its item geometry index; otherwise, the scene will be unaware of the item's new geometry, and the results are undefined (typically, rendering artifacts are left within the view).</source>
          <target state="translated">如果要更改项目的边界矩形，则必须首先调用&lt;a href=&quot;qgraphicsitem#prepareGeometryChange&quot;&gt;prepareGeometryChange&lt;/a&gt;（）。这会通知场景即将发生的更改，以便它可以更新其项目几何索引；否则，场景将不会意识到该项目的新几何形状，并且结果是不确定的（通常，渲染工件保留在视图中）。</target>
        </trans-unit>
        <trans-unit id="29b647f4eb645fd0ecb89a84fc729ec79f1f0b4a" translate="yes" xml:space="preserve">
          <source>If you want to check the peer's complete chain of certificates, use &lt;a href=&quot;qsslconfiguration#peerCertificateChain&quot;&gt;peerCertificateChain&lt;/a&gt;() to get them all at once.</source>
          <target state="translated">如果要检查对等方的完整证书链，请使用&lt;a href=&quot;qsslconfiguration#peerCertificateChain&quot;&gt;peerCertificateChain&lt;/a&gt;（）一次获取所有证书。</target>
        </trans-unit>
        <trans-unit id="0a9b450069a96b0a6e8a58b97599d28425e77362" translate="yes" xml:space="preserve">
          <source>If you want to check the peer's complete chain of certificates, use &lt;a href=&quot;qsslsocket#peerCertificateChain&quot;&gt;peerCertificateChain&lt;/a&gt;() to get them all at once.</source>
          <target state="translated">如果要检查对等方的完整证书链，请使用&lt;a href=&quot;qsslsocket#peerCertificateChain&quot;&gt;peerCertificateChain&lt;/a&gt;（）一次获取所有证书。</target>
        </trans-unit>
        <trans-unit id="c1930bdafa7c0b87829238cba843e2649235ef5e" translate="yes" xml:space="preserve">
          <source>If you want to check whether the hash contains a particular key, use &lt;a href=&quot;qhash#contains&quot;&gt;contains&lt;/a&gt;():</source>
          <target state="translated">如果要检查哈希是否包含特定键，请使用&lt;a href=&quot;qhash#contains&quot;&gt;contains&lt;/a&gt;（）：</target>
        </trans-unit>
        <trans-unit id="23d935961b3f68a99328d654a216f4d3c0e893da" translate="yes" xml:space="preserve">
          <source>If you want to check whether the map contains a certain key, use &lt;a href=&quot;qmap#contains&quot;&gt;contains&lt;/a&gt;():</source>
          <target state="translated">如果要检查地图是否包含某个键，请使用&lt;a href=&quot;qmap#contains&quot;&gt;contains&lt;/a&gt;（）：</target>
        </trans-unit>
        <trans-unit id="7031ab5669dd3dca1e9a56598b25f7661444fad9" translate="yes" xml:space="preserve">
          <source>If you want to check whether the map contains a certain key, use &lt;a href=&quot;qmultimap#contains&quot;&gt;contains&lt;/a&gt;():</source>
          <target state="translated">如果要检查地图是否包含某个键，请使用&lt;a href=&quot;qmultimap#contains&quot;&gt;contains&lt;/a&gt;（）：</target>
        </trans-unit>
        <trans-unit id="fdb3c94f4828e2e69eb0db0933e5d9bb481bdfda" translate="yes" xml:space="preserve">
          <source>If you want to compare</source>
          <target state="translated">如果你想比较</target>
        </trans-unit>
        <trans-unit id="e82e2ac2e85f322df34660e42809cbc06868df5b" translate="yes" xml:space="preserve">
          <source>If you want to continue connecting despite the errors that have occurred, you must call &lt;a href=&quot;qdtls#ignoreVerificationErrors&quot;&gt;ignoreVerificationErrors&lt;/a&gt;().</source>
          <target state="translated">如果尽管发生了错误&lt;a href=&quot;qdtls#ignoreVerificationErrors&quot;&gt;仍要&lt;/a&gt;继续连接，则必须调用ignoreVerificationErrors（）。</target>
        </trans-unit>
        <trans-unit id="593b23d3289a4ff04c05a350d8fd85bdefb223cc" translate="yes" xml:space="preserve">
          <source>If you want to continue connecting despite the errors that have occurred, you must call &lt;a href=&quot;qsslsocket#ignoreSslErrors&quot;&gt;QSslSocket::ignoreSslErrors&lt;/a&gt;() from inside a slot connected to this signal. If you need to access the error list at a later point, you can call &lt;a href=&quot;qsslsocket#sslErrors&quot;&gt;sslErrors&lt;/a&gt;() (without arguments).</source>
          <target state="translated">如果尽管发生错误&lt;a href=&quot;qsslsocket#ignoreSslErrors&quot;&gt;仍要&lt;/a&gt;继续连接，则必须从连接到该信号的插槽内部调用QSslSocket :: ignoreSslErrors（）。如果以后需要访问错误列表，则可以调用&lt;a href=&quot;qsslsocket#sslErrors&quot;&gt;sslErrors&lt;/a&gt;（）（不带参数）。</target>
        </trans-unit>
        <trans-unit id="3fc008b1487219c920d44672da93dcae563b7751" translate="yes" xml:space="preserve">
          <source>If you want to continue connecting despite the errors that have occurred, you must call &lt;a href=&quot;qsslsocket#ignoreSslErrors&quot;&gt;QSslSocket::ignoreSslErrors&lt;/a&gt;() from inside a slot connected to this signal. If you need to access the error list at a later point, you can call &lt;a href=&quot;qsslsocket#sslHandshakeErrors&quot;&gt;sslHandshakeErrors&lt;/a&gt;().</source>
          <target state="translated">如果尽管发生错误&lt;a href=&quot;qsslsocket#ignoreSslErrors&quot;&gt;仍要&lt;/a&gt;继续连接，则必须从连接到该信号的插槽内部调用QSslSocket :: ignoreSslErrors（）。如果以后需要访问错误列表，则可以调用&lt;a href=&quot;qsslsocket#sslHandshakeErrors&quot;&gt;sslHandshakeErrors&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="7e824420bc3b83685fc893bd934a9bc6683d5906" translate="yes" xml:space="preserve">
          <source>If you want to control a tooltip's behavior, you can intercept the &lt;a href=&quot;qwidget#event&quot;&gt;event&lt;/a&gt;() function and catch the &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::ToolTip&lt;/a&gt; event (e.g., if you want to customize the area for which the tooltip should be shown).</source>
          <target state="translated">如果要控制工具提示的行为，则可以拦截&lt;a href=&quot;qwidget#event&quot;&gt;event&lt;/a&gt;（）函数并捕获&lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent :: ToolTip&lt;/a&gt;事件（例如，如果要自定义应显示工具提示的区域）。</target>
        </trans-unit>
        <trans-unit id="c2d5bf02509f579dcb98946a92761ca94da3aae3" translate="yes" xml:space="preserve">
          <source>If you want to control the &quot;What's This?&quot; behavior of a widget manually see &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_CustomWhatsThis&lt;/a&gt;.</source>
          <target state="translated">如果要控制&amp;ldquo;这是什么？&amp;rdquo; 窗口小部件的行为请参见&lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt :: WA_CustomWhatsThis&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ed9d7672cfabd9a5697756d2b93c54e6a0ba7c97" translate="yes" xml:space="preserve">
          <source>If you want to create a &lt;a href=&quot;qsslsocket&quot;&gt;QSslSocket&lt;/a&gt; on the server side of a connection, you should instead call &lt;a href=&quot;qsslsocket#startServerEncryption&quot;&gt;startServerEncryption&lt;/a&gt;() upon receiving the incoming connection through &lt;a href=&quot;qtcpserver&quot;&gt;QTcpServer&lt;/a&gt;.</source>
          <target state="translated">如果要在连接的服务器端创建&lt;a href=&quot;qsslsocket&quot;&gt;QSslSocket&lt;/a&gt;，则应在通过&lt;a href=&quot;qtcpserver&quot;&gt;QTcpServer&lt;/a&gt;接收到传入的连接时调用&lt;a href=&quot;qsslsocket#startServerEncryption&quot;&gt;startServerEncryption&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="6364a818a1ea0ef1877be04ba18d5b6f66a20bba" translate="yes" xml:space="preserve">
          <source>If you want to create a cursor with your own bitmap, either use the &lt;a href=&quot;qcursor&quot;&gt;QCursor&lt;/a&gt; constructor which takes a bitmap and a mask or the constructor which takes a pixmap as arguments.</source>
          <target state="translated">如果要使用自己的位图创建游标，请使用采用位图和掩码的&lt;a href=&quot;qcursor&quot;&gt;QCursor&lt;/a&gt;构造函数或采用像素图作为参数的构造函数。</target>
        </trans-unit>
        <trans-unit id="aaf7e2203b548e872050b875fbfb55c6cd626034" translate="yes" xml:space="preserve">
          <source>If you want to create a cursor with your own bitmap, either use the QCursor constructor which takes a bitmap and a mask or the constructor which takes a pixmap as arguments.</source>
          <target state="translated">如果你想用你自己的位图来创建一个光标,可以使用QCursor构造函数(它需要一个位图和一个掩码)或者使用构造函数(它需要一个像素图作为参数)。</target>
        </trans-unit>
        <trans-unit id="130b75aa02ccf684bfd7c5f0b345cba58a662fc5" translate="yes" xml:space="preserve">
          <source>If you want to create a custom popup menu, reimplement this function and return a newly-created popup menu. Ownership of the popup menu is transferred to the caller.</source>
          <target state="translated">如果你想创建一个自定义的弹出菜单,请重新实现这个函数并返回一个新创建的弹出菜单。弹出菜单的所有权转移给调用者。</target>
        </trans-unit>
        <trans-unit id="5ff7d1d9131c0f8103df914e4a7059bb6a8f90da" translate="yes" xml:space="preserve">
          <source>If you want to create your makefiles yourself, here are some tips on how to include moc handling.</source>
          <target state="translated">如果你想自己创建makefile,这里有一些关于如何包含moc处理的提示。</target>
        </trans-unit>
        <trans-unit id="a707b4cc84c90bce7334604418a837b327eb07ee" translate="yes" xml:space="preserve">
          <source>If you want to create your own SQL drivers, you can subclass this class and reimplement its pure virtual functions and those virtual functions that you need. See &lt;a href=&quot;sql-driver#how-to-write-your-own-database-driver&quot;&gt;How to Write Your Own Database Driver&lt;/a&gt; for more information.</source>
          <target state="translated">如果要创建自己的SQL驱动程序，则可以继承该类并重新实现其纯虚函数以及所需的那些虚函数。有关更多信息，请参见&lt;a href=&quot;sql-driver#how-to-write-your-own-database-driver&quot;&gt;如何编写自己的数据库驱动程序&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4cd00e1cb4ef832c6d6c10ccd947e0dc976d42f2" translate="yes" xml:space="preserve">
          <source>If you want to create your own configurable transformation, you can create a subclass of &lt;a href=&quot;qgraphicstransform&quot;&gt;QGraphicsTransform&lt;/a&gt; (or any or the existing subclasses), and reimplement the pure virtual &lt;a href=&quot;qgraphicstransform#applyTo&quot;&gt;applyTo&lt;/a&gt;() function, which takes a pointer to a &lt;a href=&quot;qmatrix4x4&quot;&gt;QMatrix4x4&lt;/a&gt;. Each operation you would like to apply should be exposed as properties (e.g., customTransform-&amp;gt;setVerticalShear(2.5)). Inside you reimplementation of &lt;a href=&quot;qgraphicstransform#applyTo&quot;&gt;applyTo&lt;/a&gt;(), you can modify the provided transform respectively.</source>
          <target state="translated">如果要创建自己的可配置转换，则可以创建&lt;a href=&quot;qgraphicstransform&quot;&gt;QGraphicsTransform&lt;/a&gt;的子类（或任何或现有的子类），然后重新实现纯虚拟的&lt;a href=&quot;qgraphicstransform#applyTo&quot;&gt;applyTo&lt;/a&gt;（）函数，该函数采用指向&lt;a href=&quot;qmatrix4x4&quot;&gt;QMatrix4x4&lt;/a&gt;的指针。您要应用的每个操作都应公开为属性（例如customTransform-&amp;gt; setVerticalShear（2.5））。在重新实现&lt;a href=&quot;qgraphicstransform#applyTo&quot;&gt;applyTo&lt;/a&gt;（）的内部，可以分别修改提供的转换。</target>
        </trans-unit>
        <trans-unit id="ce1a87cd207a19454d912a7861f9c87183a863ad" translate="yes" xml:space="preserve">
          <source>If you want to create your own configurable transformation, you can create a subclass of QGraphicsTransform (or any or the existing subclasses), and reimplement the pure virtual &lt;a href=&quot;qgraphicstransform#applyTo&quot;&gt;applyTo&lt;/a&gt;() function, which takes a pointer to a &lt;a href=&quot;qmatrix4x4&quot;&gt;QMatrix4x4&lt;/a&gt;. Each operation you would like to apply should be exposed as properties (e.g., customTransform-&amp;gt;setVerticalShear(2.5)). Inside you reimplementation of &lt;a href=&quot;qgraphicstransform#applyTo&quot;&gt;applyTo&lt;/a&gt;(), you can modify the provided transform respectively.</source>
          <target state="translated">如果要创建自己的可配置转换，则可以创建QGraphicsTransform的子类（或任何或现有的子类），然后重新实现纯虚拟的&lt;a href=&quot;qgraphicstransform#applyTo&quot;&gt;applyTo&lt;/a&gt;（）函数，该函数采用指向&lt;a href=&quot;qmatrix4x4&quot;&gt;QMatrix4x4&lt;/a&gt;的指针。您要应用的每个操作都应公开为属性（例如customTransform-&amp;gt; setVerticalShear（2.5））。在重新实现&lt;a href=&quot;qgraphicstransform#applyTo&quot;&gt;applyTo&lt;/a&gt;（）的内部，您可以分别修改提供的转换。</target>
        </trans-unit>
        <trans-unit id="892e584524cab25e78f87f3d6a40b0ffd8130114" translate="yes" xml:space="preserve">
          <source>If you want to define code for specific versions of macOS, use the availability macros defined in</source>
          <target state="translated">如果你想为特定版本的macOS定义代码,请使用定义在</target>
        </trans-unit>
        <trans-unit id="45df5b12dbd5aa838901a53b2069cb521cd37d58" translate="yes" xml:space="preserve">
          <source>If you want to define your own contentItem, use either a &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-pathview&quot;&gt;PathView&lt;/a&gt; as the root item. For a wrapping Tumbler, use &lt;a href=&quot;qml-qtquick-pathview&quot;&gt;PathView&lt;/a&gt;:</source>
          <target state="translated">如果要定义自己的contentItem，请使用&lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt;或&lt;a href=&quot;qml-qtquick-pathview&quot;&gt;PathView&lt;/a&gt;作为根项目。对于包装的不倒翁，请使用&lt;a href=&quot;qml-qtquick-pathview&quot;&gt;PathView&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="3dd1a5bc4c7a4320ada8bf718a2be1299c978da2" translate="yes" xml:space="preserve">
          <source>If you want to display each label above its associated field (instead of next to it), set this property to &lt;a href=&quot;qformlayout#RowWrapPolicy-enum&quot;&gt;WrapAllRows&lt;/a&gt;.</source>
          <target state="translated">如果要在与其关联的字段上方（而不是旁边）显示每个标签，请将此属性设置为&lt;a href=&quot;qformlayout#RowWrapPolicy-enum&quot;&gt;WrapAllRows&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="98c56457474602455ea9e72ba790cac4f00decf0" translate="yes" xml:space="preserve">
          <source>If you want to display potentially long text in a limited space, you probably want to use &lt;code&gt;elide&lt;/code&gt; instead.</source>
          <target state="translated">如果要在有限的空间中显示可能较长的文本，则可能要改用 &lt;code&gt;elide&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f618c1040caac6ca9177c4bb9135805b3dc92b79" translate="yes" xml:space="preserve">
          <source>If you want to do complex tree operations it is useful to have a lightweight class to store nodes and their relations. &lt;a href=&quot;qdomdocumentfragment&quot;&gt;QDomDocumentFragment&lt;/a&gt; stores a subtree of a document which does not necessarily represent a well-formed XML document.</source>
          <target state="translated">如果要执行复杂的树操作，则有一个轻量级的类来存储节点及其关系非常有用。&lt;a href=&quot;qdomdocumentfragment&quot;&gt;QDomDocumentFragment&lt;/a&gt;存储文档的子树，它不一定表示格式正确的XML文档。</target>
        </trans-unit>
        <trans-unit id="cfc107efd0bc539538e5ae708721bcb44cb1032e" translate="yes" xml:space="preserve">
          <source>If you want to do complex tree operations it is useful to have a lightweight class to store nodes and their relations. QDomDocumentFragment stores a subtree of a document which does not necessarily represent a well-formed XML document.</source>
          <target state="translated">如果你想进行复杂的树操作,那么有一个轻量级的类来存储节点和它们的关系是很有用的。QDomDocumentFragment存储了一个文档的子树,它不一定代表一个格式良好的XML文档。</target>
        </trans-unit>
        <trans-unit id="9e6b9d0f74edcf13c88c150acd668db3566c2fe1" translate="yes" xml:space="preserve">
          <source>If you want to enable sorting in your table widget, do so after you have populated it with items, otherwise sorting may interfere with the insertion order (see &lt;a href=&quot;qtablewidget#setItem&quot;&gt;setItem&lt;/a&gt;() for details).</source>
          <target state="translated">如果要在表窗口小部件中启用排序，请在为其填充项目后进行，否则排序可能会干扰插入顺序（有关详细信息，请参见&lt;a href=&quot;qtablewidget#setItem&quot;&gt;setItem&lt;/a&gt;（））。</target>
        </trans-unit>
        <trans-unit id="6514036df6c7d55763ed7bf89f4062e33ae06d27" translate="yes" xml:space="preserve">
          <source>If you want to expand the string so that it reaches a certain width and fill the new positions with a particular character, use the &lt;a href=&quot;qstring#leftJustified&quot;&gt;leftJustified&lt;/a&gt;() function:</source>
          <target state="translated">如果要扩展字符串以使其达到特定宽度并用特定字符填充新位置，请使用&lt;a href=&quot;qstring#leftJustified&quot;&gt;leftJustified&lt;/a&gt;（）函数：</target>
        </trans-unit>
        <trans-unit id="980f1a5ad7854c9fbf7e44136ce5c8f9add8f8f5" translate="yes" xml:space="preserve">
          <source>If you want to find all occurrences of a particular byte or sequence of bytes in a QByteArray, use &lt;a href=&quot;qbytearray#indexOf&quot;&gt;indexOf&lt;/a&gt;() or &lt;a href=&quot;qbytearray#lastIndexOf&quot;&gt;lastIndexOf&lt;/a&gt;(). The former searches forward starting from a given index position, the latter searches backward. Both return the index position of the byte sequence if they find it; otherwise, they return -1. For example, here's a typical loop that finds all occurrences of a particular string:</source>
          <target state="translated">如果要查找QByteArray中所有出现的特定字节或字节序列，请使用&lt;a href=&quot;qbytearray#indexOf&quot;&gt;indexOf&lt;/a&gt;（）或&lt;a href=&quot;qbytearray#lastIndexOf&quot;&gt;lastIndexOf&lt;/a&gt;（）。前者从给定的索引位置开始向前搜索，后者向后搜索。如果找到字节序列，它们都返回字节序列的索引位置；否则，它们返回-1。例如，下面是一个典型的循环，查找所有出现的特定字符串：</target>
        </trans-unit>
        <trans-unit id="87bc52b74dde73e1fdb370694004887ba136ffa6" translate="yes" xml:space="preserve">
          <source>If you want to find all occurrences of a particular character or substring in a &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt;, use &lt;a href=&quot;qbytearray#indexOf&quot;&gt;indexOf&lt;/a&gt;() or &lt;a href=&quot;qbytearray#lastIndexOf&quot;&gt;lastIndexOf&lt;/a&gt;(). The former searches forward starting from a given index position, the latter searches backward. Both return the index position of the character or substring if they find it; otherwise, they return -1. For example, here's a typical loop that finds all occurrences of a particular substring:</source>
          <target state="translated">如果要查找&lt;a href=&quot;qbytearray&quot;&gt;QByteArray中&lt;/a&gt;所有出现的特定字符或子字符串，请使用&lt;a href=&quot;qbytearray#indexOf&quot;&gt;indexOf&lt;/a&gt;（）或&lt;a href=&quot;qbytearray#lastIndexOf&quot;&gt;lastIndexOf&lt;/a&gt;（）。前者从给定的索引位置开始向前搜索，后者向后搜索。两者都返回找到的字符或子字符串的索引位置；否则，它们返回-1。例如，这是一个典型的循环，查找所有出现的特定子字符串：</target>
        </trans-unit>
        <trans-unit id="039ee666228be87bbc3c0658e63f25230c55feb4" translate="yes" xml:space="preserve">
          <source>If you want to find all occurrences of a particular character or substring in a &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;, use the &lt;a href=&quot;qstring#indexOf&quot;&gt;indexOf&lt;/a&gt;() or &lt;a href=&quot;qstring#lastIndexOf&quot;&gt;lastIndexOf&lt;/a&gt;() functions. The former searches forward starting from a given index position, the latter searches backward. Both return the index position of the character or substring if they find it; otherwise, they return -1. For example, here is a typical loop that finds all occurrences of a particular substring:</source>
          <target state="translated">如果要查找&lt;a href=&quot;qstring&quot;&gt;QString中&lt;/a&gt;所有出现的特定字符或子字符串，请使用&lt;a href=&quot;qstring#indexOf&quot;&gt;indexOf&lt;/a&gt;（）或&lt;a href=&quot;qstring#lastIndexOf&quot;&gt;lastIndexOf&lt;/a&gt;（）函数。前者从给定的索引位置开始向前搜索，后者向后搜索。两者都返回找到的字符或子字符串的索引位置；否则，它们返回-1。例如，下面是一个典型的循环，查找所有出现的特定子字符串：</target>
        </trans-unit>
        <trans-unit id="56bb63ed303f16e96d55d5478b4b9c073d0cc994" translate="yes" xml:space="preserve">
          <source>If you want to find all occurrences of a particular character or substring in a QByteArray, use &lt;a href=&quot;qbytearray#indexOf&quot;&gt;indexOf&lt;/a&gt;() or &lt;a href=&quot;qbytearray#lastIndexOf&quot;&gt;lastIndexOf&lt;/a&gt;(). The former searches forward starting from a given index position, the latter searches backward. Both return the index position of the character or substring if they find it; otherwise, they return -1. For example, here's a typical loop that finds all occurrences of a particular substring:</source>
          <target state="translated">如果要查找QByteArray中所有出现的特定字符或子字符串，请使用&lt;a href=&quot;qbytearray#indexOf&quot;&gt;indexOf&lt;/a&gt;（）或&lt;a href=&quot;qbytearray#lastIndexOf&quot;&gt;lastIndexOf&lt;/a&gt;（）。前者从给定的索引位置开始向前搜索，后者向后搜索。两者都返回字符或子字符串的索引位置（如果找到的话）；否则，它们返回-1。例如，这是一个典型的循环，查找所有出现的特定子字符串：</target>
        </trans-unit>
        <trans-unit id="d213c716f1df90f368f7ec77c8c3f39cba25c43f" translate="yes" xml:space="preserve">
          <source>If you want to find all occurrences of a particular character or substring in a QString, use the &lt;a href=&quot;qstring#indexOf&quot;&gt;indexOf&lt;/a&gt;() or &lt;a href=&quot;qstring#lastIndexOf&quot;&gt;lastIndexOf&lt;/a&gt;() functions. The former searches forward starting from a given index position, the latter searches backward. Both return the index position of the character or substring if they find it; otherwise, they return -1. For example, here is a typical loop that finds all occurrences of a particular substring:</source>
          <target state="translated">如果要查找QString中所有出现的特定字符或子字符串，请使用&lt;a href=&quot;qstring#indexOf&quot;&gt;indexOf&lt;/a&gt;（）或&lt;a href=&quot;qstring#lastIndexOf&quot;&gt;lastIndexOf&lt;/a&gt;（）函数。前者从给定的索引位置开始向前搜索，后者向后搜索。两者都返回字符或子字符串的索引位置（如果找到的话）；否则，它们返回-1。例如，下面是一个典型的循环，该循环查找特定子字符串的所有匹配项：</target>
        </trans-unit>
        <trans-unit id="27bdeff94521d79ebae9498359259da99a578304" translate="yes" xml:space="preserve">
          <source>If you want to find all occurrences of a particular value in a list, use &lt;a href=&quot;qlist#indexOf&quot;&gt;indexOf&lt;/a&gt;() or &lt;a href=&quot;qlist#lastIndexOf&quot;&gt;lastIndexOf&lt;/a&gt;(). The former searches forward starting from a given index position, the latter searches backward. Both return the index of a matching item if they find it; otherwise, they return -1. For example:</source>
          <target state="translated">如果要查找列表中所有出现的特定值，请使用&lt;a href=&quot;qlist#indexOf&quot;&gt;indexOf&lt;/a&gt;（）或&lt;a href=&quot;qlist#lastIndexOf&quot;&gt;lastIndexOf&lt;/a&gt;（）。前者从给定的索引位置开始向前搜索，后者向后搜索。两者均找到匹配项的索引，则返回它们；否则，它们返回-1。例如：</target>
        </trans-unit>
        <trans-unit id="97d0d2f3ed435511125508c65ab8a45a2062cc06" translate="yes" xml:space="preserve">
          <source>If you want to find all occurrences of a particular value in a list, use &lt;a href=&quot;qlist#indexOf&quot;&gt;indexOf&lt;/a&gt;() or &lt;a href=&quot;qlist#lastIndexOf&quot;&gt;lastIndexOf&lt;/a&gt;(). The former searches forward starting from a given index position, the latter searches backward. Both return the index of the matching item if they found one; otherwise, they return -1. For example:</source>
          <target state="translated">如果要查找列表中所有出现的特定值，请使用&lt;a href=&quot;qlist#indexOf&quot;&gt;indexOf&lt;/a&gt;（）或&lt;a href=&quot;qlist#lastIndexOf&quot;&gt;lastIndexOf&lt;/a&gt;（）。前者从给定的索引位置开始向前搜索，后者向后搜索。如果找到匹配项，则两者都返回匹配项的索引；否则，返回匹配项的索引。否则，它们返回-1。例如：</target>
        </trans-unit>
        <trans-unit id="4fd1fe40bbf0af92b8be371546623b59516fd074" translate="yes" xml:space="preserve">
          <source>If you want to find all occurrences of a particular value in a vector, use &lt;a href=&quot;qvector#indexOf&quot;&gt;indexOf&lt;/a&gt;() or &lt;a href=&quot;qvector#lastIndexOf&quot;&gt;lastIndexOf&lt;/a&gt;(). The former searches forward starting from a given index position, the latter searches backward. Both return the index of the matching item if they found one; otherwise, they return -1. For example:</source>
          <target state="translated">如果要查找向量中所有出现的特定值，请使用&lt;a href=&quot;qvector#indexOf&quot;&gt;indexOf&lt;/a&gt;（）或&lt;a href=&quot;qvector#lastIndexOf&quot;&gt;lastIndexOf&lt;/a&gt;（）。前者从给定的索引位置开始向前搜索，后者向后搜索。如果找到一个，则两者都返回匹配项的索引。否则，它们返回-1。例如：</target>
        </trans-unit>
        <trans-unit id="a4c3e9969fbbaff4bfc63ca9b9594928ad5c07e3" translate="yes" xml:space="preserve">
          <source>If you want to find all occurrences of a particular value, use &lt;a href=&quot;qfutureiterator#findNext&quot;&gt;findNext&lt;/a&gt;() or &lt;a href=&quot;qfutureiterator#findPrevious&quot;&gt;findPrevious&lt;/a&gt;() in a loop.</source>
          <target state="translated">如果要查找所有出现的特定值，请在循环中使用&lt;a href=&quot;qfutureiterator#findNext&quot;&gt;findNext&lt;/a&gt;（）或&lt;a href=&quot;qfutureiterator#findPrevious&quot;&gt;findPrevious&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="f14231631997736aff9bf24da2c44e69b1deb9c1" translate="yes" xml:space="preserve">
          <source>If you want to find all occurrences of a particular value, use &lt;a href=&quot;qhashiterator#findNext&quot;&gt;findNext&lt;/a&gt;() in a loop. For example:</source>
          <target state="translated">如果要查找所有出现的特定值，请在循环中使用&lt;a href=&quot;qhashiterator#findNext&quot;&gt;findNext&lt;/a&gt;（）。例如：</target>
        </trans-unit>
        <trans-unit id="898951fabb2a0eafcd00294a33ae1f37a06ebddf" translate="yes" xml:space="preserve">
          <source>If you want to find all occurrences of a particular value, use &lt;a href=&quot;qhashiterator#findNext&quot;&gt;findNext&lt;/a&gt;() or &lt;a href=&quot;qhashiterator#findPrevious&quot;&gt;findPrevious&lt;/a&gt;() in a loop. For example:</source>
          <target state="translated">如果要查找所有出现的特定值，请在循环中使用&lt;a href=&quot;qhashiterator#findNext&quot;&gt;findNext&lt;/a&gt;（）或&lt;a href=&quot;qhashiterator#findPrevious&quot;&gt;findPrevious&lt;/a&gt;（）。例如：</target>
        </trans-unit>
        <trans-unit id="4b82cd87403265c3fee60ae6331015acbbe690bd" translate="yes" xml:space="preserve">
          <source>If you want to find all occurrences of a particular value, use &lt;a href=&quot;qlinkedlistiterator#findNext&quot;&gt;findNext&lt;/a&gt;() or &lt;a href=&quot;qlinkedlistiterator#findPrevious&quot;&gt;findPrevious&lt;/a&gt;() in a loop.</source>
          <target state="translated">如果要查找所有出现的特定值，请在循环中使用&lt;a href=&quot;qlinkedlistiterator#findNext&quot;&gt;findNext&lt;/a&gt;（）或&lt;a href=&quot;qlinkedlistiterator#findPrevious&quot;&gt;findPrevious&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="3e2537f0565774525da7ed64dac47ab4a40e2305" translate="yes" xml:space="preserve">
          <source>If you want to find all occurrences of a particular value, use &lt;a href=&quot;qlistiterator#findNext&quot;&gt;findNext&lt;/a&gt;() or &lt;a href=&quot;qlistiterator#findPrevious&quot;&gt;findPrevious&lt;/a&gt;() in a loop.</source>
          <target state="translated">如果要查找所有出现的特定值，请在循环中使用&lt;a href=&quot;qlistiterator#findNext&quot;&gt;findNext&lt;/a&gt;（）或&lt;a href=&quot;qlistiterator#findPrevious&quot;&gt;findPrevious&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="092c0df4a0b9fa279f43249c5212612d6ef96a38" translate="yes" xml:space="preserve">
          <source>If you want to find all occurrences of a particular value, use &lt;a href=&quot;qmapiterator#findNext&quot;&gt;findNext&lt;/a&gt;() or &lt;a href=&quot;qmapiterator#findPrevious&quot;&gt;findPrevious&lt;/a&gt;() in a loop. For example:</source>
          <target state="translated">如果要查找所有出现的特定值，请在循环中使用&lt;a href=&quot;qmapiterator#findNext&quot;&gt;findNext&lt;/a&gt;（）或&lt;a href=&quot;qmapiterator#findPrevious&quot;&gt;findPrevious&lt;/a&gt;（）。例如：</target>
        </trans-unit>
        <trans-unit id="4ae26266091f5d71c224dc6039260ea461fa73af" translate="yes" xml:space="preserve">
          <source>If you want to find all occurrences of a particular value, use &lt;a href=&quot;qmultimapiterator#findNext&quot;&gt;findNext&lt;/a&gt;() or &lt;a href=&quot;qmultimapiterator#findPrevious&quot;&gt;findPrevious&lt;/a&gt;() in a loop. For example:</source>
          <target state="translated">如果要查找所有出现的特定值，请在循环中使用&lt;a href=&quot;qmultimapiterator#findNext&quot;&gt;findNext&lt;/a&gt;（）或&lt;a href=&quot;qmultimapiterator#findPrevious&quot;&gt;findPrevious&lt;/a&gt;（）。例如：</target>
        </trans-unit>
        <trans-unit id="4b0051160bb1fdba0e5d011e3f8147f93a5c344d" translate="yes" xml:space="preserve">
          <source>If you want to find all occurrences of a particular value, use &lt;a href=&quot;qmutablehashiterator#findNext&quot;&gt;findNext&lt;/a&gt;() in a loop. For example:</source>
          <target state="translated">如果要查找所有出现的特定值，请在循环中使用&lt;a href=&quot;qmutablehashiterator#findNext&quot;&gt;findNext&lt;/a&gt;（）。例如：</target>
        </trans-unit>
        <trans-unit id="b7c55e1a6cb9f3947aa66f6df9204c79725e274f" translate="yes" xml:space="preserve">
          <source>If you want to find all occurrences of a particular value, use &lt;a href=&quot;qmutablehashiterator#findNext&quot;&gt;findNext&lt;/a&gt;() or &lt;a href=&quot;qmutablehashiterator#findPrevious&quot;&gt;findPrevious&lt;/a&gt;() in a loop. For example:</source>
          <target state="translated">如果要查找所有出现的特定值，请在循环中使用&lt;a href=&quot;qmutablehashiterator#findNext&quot;&gt;findNext&lt;/a&gt;（）或&lt;a href=&quot;qmutablehashiterator#findPrevious&quot;&gt;findPrevious&lt;/a&gt;（）。例如：</target>
        </trans-unit>
        <trans-unit id="3f7a8dd0427879e3fd8e9577c8dfaa12e390a3ad" translate="yes" xml:space="preserve">
          <source>If you want to find all occurrences of a particular value, use &lt;a href=&quot;qmutablelinkedlistiterator#findNext&quot;&gt;findNext&lt;/a&gt;() or &lt;a href=&quot;qmutablelinkedlistiterator#findPrevious&quot;&gt;findPrevious&lt;/a&gt;() in a loop.</source>
          <target state="translated">如果要查找所有出现的特定值，请在循环中使用&lt;a href=&quot;qmutablelinkedlistiterator#findNext&quot;&gt;findNext&lt;/a&gt;（）或&lt;a href=&quot;qmutablelinkedlistiterator#findPrevious&quot;&gt;findPrevious&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="d2c2d1220486fde408994dbb3f861d6a131310dd" translate="yes" xml:space="preserve">
          <source>If you want to find all occurrences of a particular value, use &lt;a href=&quot;qmutablelistiterator#findNext&quot;&gt;findNext&lt;/a&gt;() or &lt;a href=&quot;qmutablelistiterator#findPrevious&quot;&gt;findPrevious&lt;/a&gt;() in a loop.</source>
          <target state="translated">如果要查找所有出现的特定值，请在循环中使用&lt;a href=&quot;qmutablelistiterator#findNext&quot;&gt;findNext&lt;/a&gt;（）或&lt;a href=&quot;qmutablelistiterator#findPrevious&quot;&gt;findPrevious&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="6c4574f8d03dabcd80250d9ff8bc30c171345919" translate="yes" xml:space="preserve">
          <source>If you want to find all occurrences of a particular value, use &lt;a href=&quot;qmutablemapiterator#findNext&quot;&gt;findNext&lt;/a&gt;() or &lt;a href=&quot;qmutablemapiterator#findPrevious&quot;&gt;findPrevious&lt;/a&gt;() in a loop. For example:</source>
          <target state="translated">如果要查找所有出现的特定值，请在循环中使用&lt;a href=&quot;qmutablemapiterator#findNext&quot;&gt;findNext&lt;/a&gt;（）或&lt;a href=&quot;qmutablemapiterator#findPrevious&quot;&gt;findPrevious&lt;/a&gt;（）。例如：</target>
        </trans-unit>
        <trans-unit id="7bc780ef949f91f0152eb6e8c39fe1716c4a2604" translate="yes" xml:space="preserve">
          <source>If you want to find all occurrences of a particular value, use &lt;a href=&quot;qmutablemultimapiterator#findNext&quot;&gt;findNext&lt;/a&gt;() or &lt;a href=&quot;qmutablemultimapiterator#findPrevious&quot;&gt;findPrevious&lt;/a&gt;() in a loop. For example:</source>
          <target state="translated">如果要查找所有出现的特定值，请在循环中使用&lt;a href=&quot;qmutablemultimapiterator#findNext&quot;&gt;findNext&lt;/a&gt;（）或&lt;a href=&quot;qmutablemultimapiterator#findPrevious&quot;&gt;findPrevious&lt;/a&gt;（）。例如：</target>
        </trans-unit>
        <trans-unit id="215948c402f89b1d0e279407c4317a276aa1d8e1" translate="yes" xml:space="preserve">
          <source>If you want to find all occurrences of a particular value, use &lt;a href=&quot;qmutablevectoriterator#findNext&quot;&gt;findNext&lt;/a&gt;() or &lt;a href=&quot;qmutablevectoriterator#findPrevious&quot;&gt;findPrevious&lt;/a&gt;() in a loop.</source>
          <target state="translated">如果要查找所有出现的特定值，请在循环中使用&lt;a href=&quot;qmutablevectoriterator#findNext&quot;&gt;findNext&lt;/a&gt;（）或&lt;a href=&quot;qmutablevectoriterator#findPrevious&quot;&gt;findPrevious&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="2a53799d90a3f80407eb44d3086cc5e422647bd7" translate="yes" xml:space="preserve">
          <source>If you want to find all occurrences of a particular value, use &lt;a href=&quot;qsetiterator#findNext&quot;&gt;findNext&lt;/a&gt;() or &lt;a href=&quot;qsetiterator#findPrevious&quot;&gt;findPrevious&lt;/a&gt;() in a loop.</source>
          <target state="translated">如果要查找所有出现的特定值，请在循环中使用&lt;a href=&quot;qsetiterator#findNext&quot;&gt;findNext&lt;/a&gt;（）或&lt;a href=&quot;qsetiterator#findPrevious&quot;&gt;findPrevious&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="24f67f821a227bf0a8d722bc4e53136270262bf1" translate="yes" xml:space="preserve">
          <source>If you want to find all occurrences of a particular value, use &lt;a href=&quot;qvectoriterator#findNext&quot;&gt;findNext&lt;/a&gt;() or &lt;a href=&quot;qvectoriterator#findPrevious&quot;&gt;findPrevious&lt;/a&gt;() in a loop.</source>
          <target state="translated">如果要查找所有出现的特定值，请在循环中使用&lt;a href=&quot;qvectoriterator#findNext&quot;&gt;findNext&lt;/a&gt;（）或&lt;a href=&quot;qvectoriterator#findPrevious&quot;&gt;findPrevious&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="ec7b23d25e51deabb1188265f05be9abd0cb9659" translate="yes" xml:space="preserve">
          <source>If you want to find the directory containing the application's executable, see &lt;a href=&quot;qcoreapplication#applicationDirPath&quot;&gt;QCoreApplication::applicationDirPath&lt;/a&gt;().</source>
          <target state="translated">如果要查找包含应用程序可执行文件的目录，请参见&lt;a href=&quot;qcoreapplication#applicationDirPath&quot;&gt;QCoreApplication :: applicationDirPath&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="555f6e4ee413aca7be22902a76f9c68413d21a0b" translate="yes" xml:space="preserve">
          <source>If you want to get only the peer's immediate certificate, use &lt;a href=&quot;qsslconfiguration#peerCertificate&quot;&gt;peerCertificate&lt;/a&gt;().</source>
          <target state="translated">如果只想获取对等方的即时证书，请使用&lt;a href=&quot;qsslconfiguration#peerCertificate&quot;&gt;peerCertificate&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="5f588095f3464b16d49f361f0c4bfe90fc18f4b0" translate="yes" xml:space="preserve">
          <source>If you want to get only the peer's immediate certificate, use &lt;a href=&quot;qsslsocket#peerCertificate&quot;&gt;peerCertificate&lt;/a&gt;().</source>
          <target state="translated">如果只想获取对等方的即时证书，请使用&lt;a href=&quot;qsslsocket#peerCertificate&quot;&gt;peerCertificate&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="259fa74d33ed5c4b05c0e2870301509985e1ba3f" translate="yes" xml:space="preserve">
          <source>If you want to get the first or last item in a linked list, use &lt;a href=&quot;qlinkedlist#first&quot;&gt;first&lt;/a&gt;() or &lt;a href=&quot;qlinkedlist#last&quot;&gt;last&lt;/a&gt;(). If you want to remove an item from either end of the list, use &lt;a href=&quot;qlinkedlist#removeFirst&quot;&gt;removeFirst&lt;/a&gt;() or &lt;a href=&quot;qlinkedlist#removeLast&quot;&gt;removeLast&lt;/a&gt;(). If you want to remove all occurrences of a given value in the list, use &lt;a href=&quot;qlinkedlist#removeAll&quot;&gt;removeAll&lt;/a&gt;().</source>
          <target state="translated">如果要获取链表中的第一项或最后一项，请使用&lt;a href=&quot;qlinkedlist#first&quot;&gt;first&lt;/a&gt;（）或&lt;a href=&quot;qlinkedlist#last&quot;&gt;last&lt;/a&gt;（）。如果要从列表的任一端删除项目，请使用&lt;a href=&quot;qlinkedlist#removeFirst&quot;&gt;removeFirst&lt;/a&gt;（）或&lt;a href=&quot;qlinkedlist#removeLast&quot;&gt;removeLast&lt;/a&gt;（）。如果要删除列表中所有出现的给定值，请使用&lt;a href=&quot;qlinkedlist#removeAll&quot;&gt;removeAll&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="2230d8498d7120ad007e4bbdd51b64b890af4f49" translate="yes" xml:space="preserve">
          <source>If you want to give your users maximum freedom in what strings they can pass to your function, accompany the &lt;a href=&quot;qstringview&quot;&gt;QStringView&lt;/a&gt; overload with overloads for</source>
          <target state="translated">如果您想让用户最大程度地自由选择可以传递给函数的字符串，请结合使用&lt;a href=&quot;qstringview&quot;&gt;QStringView&lt;/a&gt;重载和</target>
        </trans-unit>
        <trans-unit id="f02aa78cec200e885cfd616e7a54bc352d18c2be" translate="yes" xml:space="preserve">
          <source>If you want to give your users maximum freedom in what strings they can pass to your function, accompany the QStringView overload with overloads for</source>
          <target state="translated">如果你想给你的用户最大的自由度,让他们可以向你的函数传递什么样的字符串,那么在QStringView的重载中加上</target>
        </trans-unit>
        <trans-unit id="953f5ea0a079ed12456cbeb78eb6e19ac8eeba7e" translate="yes" xml:space="preserve">
          <source>If you want to give your users maximum freedom in what strings they can pass to your function, consider using &lt;a href=&quot;qanystringview&quot;&gt;QAnyStringView&lt;/a&gt; instead.</source>
          <target state="translated">如果要给用户最大程度的自由，他们可以将哪些字符串传递给函数，请考虑改用&lt;a href=&quot;qanystringview&quot;&gt;QAnyStringView&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f02a2109ca061f9e7cc06bf4bce8ef695f60c1e8" translate="yes" xml:space="preserve">
          <source>If you want to give your users maximum freedom in what type of data they can pass to your function, accompany the QByteArrayView overload with overloads for</source>
          <target state="translated">如果你想让你的用户在他们可以传递给你的函数的数据类型上有最大的自由度,那么在QByteArrayView重载的同时,你可以使用</target>
        </trans-unit>
        <trans-unit id="4246d6b83ef0b1afdc8b1a9f53698034957eb38a" translate="yes" xml:space="preserve">
          <source>If you want to insert many records at the same time, it is often more efficient to separate the query from the actual values being inserted. This can be done using placeholders. Qt supports two placeholder syntaxes: named binding and positional binding. Here's an example of named binding:</source>
          <target state="translated">如果你想同时插入许多记录,通常将查询与实际插入的值分开是更有效的。这可以通过使用占位符来实现。Qt支持两种占位符语法:命名绑定和位置绑定。下面是一个命名绑定的例子。</target>
        </trans-unit>
        <trans-unit id="8320992c150ec7f0ac1d4db708fa844d42e7033e" translate="yes" xml:space="preserve">
          <source>If you want to insert, modify, or remove items in the middle of the list, you must use an iterator. &lt;a href=&quot;qlinkedlist&quot;&gt;QLinkedList&lt;/a&gt; provides both &lt;a href=&quot;containers#java-style-iterators&quot;&gt;Java-style iterators&lt;/a&gt; (&lt;a href=&quot;qlinkedlistiterator&quot;&gt;QLinkedListIterator&lt;/a&gt; and &lt;a href=&quot;qmutablelinkedlistiterator&quot;&gt;QMutableLinkedListIterator&lt;/a&gt;) and &lt;a href=&quot;containers#stl-style-iterators&quot;&gt;STL-style iterators&lt;/a&gt; (&lt;a href=&quot;qlinkedlist-const-iterator&quot;&gt;QLinkedList::const_iterator&lt;/a&gt; and &lt;a href=&quot;qlinkedlist-iterator&quot;&gt;QLinkedList::iterator&lt;/a&gt;). See the documentation for these classes for details.</source>
          <target state="translated">如果要在列表中间插入，修改或删除项目，则必须使用迭代器。&lt;a href=&quot;qlinkedlist&quot;&gt;QLinkedList&lt;/a&gt;提供&lt;a href=&quot;containers#java-style-iterators&quot;&gt;Java样式的迭代器&lt;/a&gt;（&lt;a href=&quot;qlinkedlistiterator&quot;&gt;QLinkedListIterator&lt;/a&gt;和&lt;a href=&quot;qmutablelinkedlistiterator&quot;&gt;QMutableLinkedListIterator&lt;/a&gt;）和&lt;a href=&quot;containers#stl-style-iterators&quot;&gt;STL样式的迭代器&lt;/a&gt;（&lt;a href=&quot;qlinkedlist-const-iterator&quot;&gt;QLinkedList :: const_iterator&lt;/a&gt;和&lt;a href=&quot;qlinkedlist-iterator&quot;&gt;QLinkedList :: iterator&lt;/a&gt;）。有关详细信息，请参见这些类的文档。</target>
        </trans-unit>
        <trans-unit id="03b674d9044e326b0cc6a97090649e896351fcd8" translate="yes" xml:space="preserve">
          <source>If you want to insert, modify, or remove items in the middle of the list, you must use an iterator. QLinkedList provides both &lt;a href=&quot;containers#java-style-iterators&quot;&gt;Java-style iterators&lt;/a&gt; (&lt;a href=&quot;qlinkedlistiterator&quot;&gt;QLinkedListIterator&lt;/a&gt; and &lt;a href=&quot;qmutablelinkedlistiterator&quot;&gt;QMutableLinkedListIterator&lt;/a&gt;) and &lt;a href=&quot;containers#stl-style-iterators&quot;&gt;STL-style iterators&lt;/a&gt; (&lt;a href=&quot;qlinkedlist-const-iterator&quot;&gt;QLinkedList::const_iterator&lt;/a&gt; and &lt;a href=&quot;qlinkedlist-iterator&quot;&gt;QLinkedList::iterator&lt;/a&gt;). See the documentation for these classes for details.</source>
          <target state="translated">如果要在列表中间插入，修改或删除项目，则必须使用迭代器。QLinkedList提供&lt;a href=&quot;containers#java-style-iterators&quot;&gt;Java样式的迭代器&lt;/a&gt;（&lt;a href=&quot;qlinkedlistiterator&quot;&gt;QLinkedListIterator&lt;/a&gt;和&lt;a href=&quot;qmutablelinkedlistiterator&quot;&gt;QMutableLinkedListIterator&lt;/a&gt;）和&lt;a href=&quot;containers#stl-style-iterators&quot;&gt;STL样式的迭代器&lt;/a&gt;（&lt;a href=&quot;qlinkedlist-const-iterator&quot;&gt;QLinkedList :: const_iterator&lt;/a&gt;和&lt;a href=&quot;qlinkedlist-iterator&quot;&gt;QLinkedList :: iterator&lt;/a&gt;）。有关详细信息，请参见这些类的文档。</target>
        </trans-unit>
        <trans-unit id="46cb2573391b3e65f575469bb95c023562dba964" translate="yes" xml:space="preserve">
          <source>If you want to insert, modify, or remove items in the middle of the list, you must use an iterator. QLinkedList provides both &lt;a href=&quot;java-style-iterators#java-style-iterators&quot;&gt;Java-style iterators&lt;/a&gt; (&lt;a href=&quot;qlinkedlistiterator&quot;&gt;QLinkedListIterator&lt;/a&gt; and &lt;a href=&quot;qmutablelinkedlistiterator&quot;&gt;QMutableLinkedListIterator&lt;/a&gt;) and &lt;a href=&quot;containers#stl-style-iterators&quot;&gt;STL-style iterators&lt;/a&gt; (&lt;a href=&quot;qlinkedlist-const-iterator&quot;&gt;QLinkedList::const_iterator&lt;/a&gt; and &lt;a href=&quot;qlinkedlist-iterator&quot;&gt;QLinkedList::iterator&lt;/a&gt;). See the documentation for these classes for details.</source>
          <target state="translated">如果要在列表中间插入，修改或删除项目，则必须使用迭代器。QLinkedList提供&lt;a href=&quot;java-style-iterators#java-style-iterators&quot;&gt;Java样式的迭代器&lt;/a&gt;（&lt;a href=&quot;qlinkedlistiterator&quot;&gt;QLinkedListIterator&lt;/a&gt;和&lt;a href=&quot;qmutablelinkedlistiterator&quot;&gt;QMutableLinkedListIterator&lt;/a&gt;）和&lt;a href=&quot;containers#stl-style-iterators&quot;&gt;STL样式的迭代器&lt;/a&gt;（&lt;a href=&quot;qlinkedlist-const-iterator&quot;&gt;QLinkedList :: const_iterator&lt;/a&gt;和&lt;a href=&quot;qlinkedlist-iterator&quot;&gt;QLinkedList :: iterator&lt;/a&gt;）。有关详细信息，请参见这些类的文档。</target>
        </trans-unit>
        <trans-unit id="a3b3e33d661d3a733b124525ba2561b6b52910a0" translate="yes" xml:space="preserve">
          <source>If you want to iterate over the list, you can use the &lt;a href=&quot;containers#foreach&quot;&gt;foreach&lt;/a&gt; pseudo-keyword:</source>
          <target state="translated">如果要遍历列表，可以使用&lt;a href=&quot;containers#foreach&quot;&gt;foreach&lt;/a&gt;伪关键字：</target>
        </trans-unit>
        <trans-unit id="c92b86b63ccc1777115a271d645ee3bf2b6e9eee" translate="yes" xml:space="preserve">
          <source>If you want to iterate over the properties of a script object, use the &lt;a href=&quot;qjsvalueiterator&quot;&gt;QJSValueIterator&lt;/a&gt; class.</source>
          <target state="translated">如果要遍历脚本对象的属性，请使用&lt;a href=&quot;qjsvalueiterator&quot;&gt;QJSValueIterator&lt;/a&gt;类。</target>
        </trans-unit>
        <trans-unit id="56374bf96c11588ed136b8f810e31006caed97e6" translate="yes" xml:space="preserve">
          <source>If you want to just run a function in a separate thread without adjusting any parameters, use &lt;a href=&quot;concurrent-changes-qt6#qtconcurrent-run&quot;&gt;QtConcurrent::run&lt;/a&gt; as that lets you write less code. The &lt;a href=&quot;qtconcurrent#task&quot;&gt;QtConcurrent::task&lt;/a&gt; is designed for cases where you need to perform extra configurations steps.</source>
          <target state="translated">如果只想在一个单独的线程中运行一个函数而不调整任何参数，请使用&lt;a href=&quot;concurrent-changes-qt6#qtconcurrent-run&quot;&gt;QtConcurrent :: run，&lt;/a&gt;因为这样可以减少代码编写量。该&lt;a href=&quot;qtconcurrent#task&quot;&gt;QtConcurrent ::任务&lt;/a&gt;是专门为那些需要执行额外的配置步骤的情况。</target>
        </trans-unit>
        <trans-unit id="18af9e9094d839882658054a3f98e2243ae331c7" translate="yes" xml:space="preserve">
          <source>If you want to know about changes to items see the &lt;a href=&quot;qabstractitemview#dataChanged&quot;&gt;dataChanged&lt;/a&gt;() signal.</source>
          <target state="translated">如果您想了解项目的更改，请参见&lt;a href=&quot;qabstractitemview#dataChanged&quot;&gt;dataChanged&lt;/a&gt;（）信号。</target>
        </trans-unit>
        <trans-unit id="1c3819c472a114c60cfcc0efb6c8e2b33d8f4dc2" translate="yes" xml:space="preserve">
          <source>If you want to know the advance width of the string (to lay out a set of strings next to each other), use &lt;a href=&quot;qfontmetrics#horizontalAdvance&quot;&gt;horizontalAdvance&lt;/a&gt;() instead.</source>
          <target state="translated">如果您想知道字符串的超前宽度（将一组字符串彼此并排放置），请改用&lt;a href=&quot;qfontmetrics#horizontalAdvance&quot;&gt;horizo​​ntalAdvance&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="840aa119e2ce11cd80a3be1fcbcd6761cdfcfc1a" translate="yes" xml:space="preserve">
          <source>If you want to know the advance width of the string (to lay out a set of strings next to each other), use &lt;a href=&quot;qfontmetricsf#horizontalAdvance&quot;&gt;horizontalAdvance&lt;/a&gt;() instead.</source>
          <target state="translated">如果您想知道字符串的超前宽度（将一组字符串彼此并排放置），请改用&lt;a href=&quot;qfontmetricsf#horizontalAdvance&quot;&gt;horizo​​ntalAdvance&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="2eea2b62960c148390b6813c85f9525893b2d799" translate="yes" xml:space="preserve">
          <source>If you want to limit the total number of paragraphs in a &lt;a href=&quot;qplaintextedit&quot;&gt;QPlainTextEdit&lt;/a&gt;, as it is for example useful in a log viewer, then you can use the &lt;a href=&quot;qplaintextedit#maximumBlockCount-prop&quot;&gt;maximumBlockCount&lt;/a&gt; property. The combination of &lt;a href=&quot;qplaintextedit#maximumBlockCount-prop&quot;&gt;setMaximumBlockCount&lt;/a&gt;() and &lt;a href=&quot;qplaintextedit#appendPlainText&quot;&gt;appendPlainText&lt;/a&gt;() turns &lt;a href=&quot;qplaintextedit&quot;&gt;QPlainTextEdit&lt;/a&gt; into an efficient viewer for log text. The scrolling can be reduced with the &lt;a href=&quot;qplaintextedit#centerOnScroll-prop&quot;&gt;centerOnScroll&lt;/a&gt;() property, making the log viewer even faster. Text can be formatted in a limited way, either using a syntax highlighter (see below), or by appending html-formatted text with &lt;a href=&quot;qplaintextedit#appendHtml&quot;&gt;appendHtml&lt;/a&gt;(). While &lt;a href=&quot;qplaintextedit&quot;&gt;QPlainTextEdit&lt;/a&gt; does not support complex rich text rendering with tables and floats, it does support limited paragraph-based formatting that you may need in a log viewer.</source>
          <target state="translated">如果要限制&lt;a href=&quot;qplaintextedit&quot;&gt;QPlainTextEdit中&lt;/a&gt;的段落总数，例如在日志查看器中很有用，则可以使用&lt;a href=&quot;qplaintextedit#maximumBlockCount-prop&quot;&gt;maximumBlockCount&lt;/a&gt;属性。&lt;a href=&quot;qplaintextedit#maximumBlockCount-prop&quot;&gt;setMaximumBlockCount&lt;/a&gt;（）和&lt;a href=&quot;qplaintextedit#appendPlainText&quot;&gt;appendPlainText&lt;/a&gt;（）的组合使&lt;a href=&quot;qplaintextedit&quot;&gt;QPlainTextEdit&lt;/a&gt;成为日志文本的有效查看器。可以使用&lt;a href=&quot;qplaintextedit#centerOnScroll-prop&quot;&gt;centerOnScroll&lt;/a&gt;（）属性减少滚动，从而使日志查看器更快。可以使用语法荧光笔（请参见下文）或通过将HTML格式的文本附加到&lt;a href=&quot;qplaintextedit#appendHtml&quot;&gt;appendHtml&lt;/a&gt;（）以有限的方式对文本进行格式化。而&lt;a href=&quot;qplaintextedit&quot;&gt;QPlainTextEdit&lt;/a&gt; 不支持使用表和浮点数进行复杂的富文本格式呈现，它确实支持在日志查看器中可能需要的基于段落的有限格式。</target>
        </trans-unit>
        <trans-unit id="c03b0d91f766b2476164685df4428c8b2781851d" translate="yes" xml:space="preserve">
          <source>If you want to limit the total number of paragraphs in a &lt;a href=&quot;qtextedit&quot;&gt;QTextEdit&lt;/a&gt;, as for example it is often useful in a log viewer, then you can use &lt;a href=&quot;qtextdocument&quot;&gt;QTextDocument&lt;/a&gt;'s maximumBlockCount property for that.</source>
          <target state="translated">如果要限制&lt;a href=&quot;qtextedit&quot;&gt;QTextEdit中&lt;/a&gt;的段落总数，例如在日志查看器中通常很有用，则可以&lt;a href=&quot;qtextdocument&quot;&gt;为此&lt;/a&gt;使用QTextDocument的maximumBlockCount属性。</target>
        </trans-unit>
        <trans-unit id="e2ba9830ea7627a9343bf7b76d829fd57f08ad9b" translate="yes" xml:space="preserve">
          <source>If you want to limit the total number of paragraphs in a QPlainTextEdit, as it is for example useful in a log viewer, then you can use the &lt;a href=&quot;qplaintextedit#maximumBlockCount-prop&quot;&gt;maximumBlockCount&lt;/a&gt; property. The combination of &lt;a href=&quot;qplaintextedit#maximumBlockCount-prop&quot;&gt;setMaximumBlockCount&lt;/a&gt;() and &lt;a href=&quot;qplaintextedit#appendPlainText&quot;&gt;appendPlainText&lt;/a&gt;() turns QPlainTextEdit into an efficient viewer for log text. The scrolling can be reduced with the &lt;a href=&quot;qplaintextedit#centerOnScroll-prop&quot;&gt;centerOnScroll&lt;/a&gt;() property, making the log viewer even faster. Text can be formatted in a limited way, either using a syntax highlighter (see below), or by appending html-formatted text with &lt;a href=&quot;qplaintextedit#appendHtml&quot;&gt;appendHtml&lt;/a&gt;(). While QPlainTextEdit does not support complex rich text rendering with tables and floats, it does support limited paragraph-based formatting that you may need in a log viewer.</source>
          <target state="translated">如果要限制QPlainTextEdit中的段落总数，例如在日志查看器中很有用，则可以使用&lt;a href=&quot;qplaintextedit#maximumBlockCount-prop&quot;&gt;maximumBlockCount&lt;/a&gt;属性。&lt;a href=&quot;qplaintextedit#maximumBlockCount-prop&quot;&gt;setMaximumBlockCount&lt;/a&gt;（）和&lt;a href=&quot;qplaintextedit#appendPlainText&quot;&gt;appendPlainText&lt;/a&gt;（）的组合使QPlainTextEdit成为日志文本的有效查看器。可以使用&lt;a href=&quot;qplaintextedit#centerOnScroll-prop&quot;&gt;centerOnScroll&lt;/a&gt;（）属性减少滚动，从而使日志查看器更快。可以使用语法荧光笔（请参见下文）或通过将HTML格式的文本附加到&lt;a href=&quot;qplaintextedit#appendHtml&quot;&gt;appendHtml&lt;/a&gt;（）中，以有限的方式设置文本的格式。虽然QPlainTextEdit不支持使用表和浮点数进行复杂的RTF呈现，但它确实支持在日志查看器中可能需要的有限的基于段落的格式。</target>
        </trans-unit>
        <trans-unit id="f0bca11d38fed71aecd9e903f587fc04e0c527e9" translate="yes" xml:space="preserve">
          <source>If you want to limit the total number of paragraphs in a QTextEdit, as for example it is often useful in a log viewer, then you can use &lt;a href=&quot;qtextdocument&quot;&gt;QTextDocument&lt;/a&gt;'s maximumBlockCount property for that.</source>
          <target state="translated">如果要限制QTextEdit中的段落总数，例如在日志查看器中通常很有用，则可以&lt;a href=&quot;qtextdocument&quot;&gt;为此&lt;/a&gt;使用QTextDocument的maximumBlockCount属性。</target>
        </trans-unit>
        <trans-unit id="2542ae60875a8dfd6df1bddc693ecc9fa841dd45" translate="yes" xml:space="preserve">
          <source>If you want to load documents stored in the Qt resource system use &lt;code&gt;qrc&lt;/code&gt; as the scheme in the URL to load. For example, for the document resource path &lt;code&gt;:/docs/index.html&lt;/code&gt; use &lt;code&gt;qrc:/docs/index.html&lt;/code&gt; as the URL with &lt;a href=&quot;qtextbrowser#setSource&quot;&gt;setSource&lt;/a&gt;().</source>
          <target state="translated">如果要加载存储在Qt资源系统中的文档，请使用 &lt;code&gt;qrc&lt;/code&gt; 作为要加载的URL中的方案。例如，对于文档资源路径 &lt;code&gt;:/docs/index.html&lt;/code&gt; ,请使用 &lt;code&gt;qrc:/docs/index.html&lt;/code&gt; 作为带有&lt;a href=&quot;qtextbrowser#setSource&quot;&gt;setSource&lt;/a&gt;（）的URL 。</target>
        </trans-unit>
        <trans-unit id="958b74a332153748fcd377612a5ab6c6f94575c2" translate="yes" xml:space="preserve">
          <source>If you want to load documents stored in the Qt resource system use &lt;code&gt;qrc&lt;/code&gt; as the scheme in the URL to load. For example, for the document resource path &lt;code&gt;:/docs/index.html&lt;/code&gt; use &lt;code&gt;qrc:/docs/index.html&lt;/code&gt; as the URL with &lt;a href=&quot;qtextbrowser#source-prop&quot;&gt;setSource&lt;/a&gt;().</source>
          <target state="translated">如果要加载存储在Qt资源系统中的文档，请使用 &lt;code&gt;qrc&lt;/code&gt; 作为要加载的URL中的方案。例如，对于文档资源路径 &lt;code&gt;:/docs/index.html&lt;/code&gt; ,请使用 &lt;code&gt;qrc:/docs/index.html&lt;/code&gt; 作为带有&lt;a href=&quot;qtextbrowser#source-prop&quot;&gt;setSource&lt;/a&gt;（）的URL 。</target>
        </trans-unit>
        <trans-unit id="b12879b76a2aa0ce099bef336488f9360fde4a65" translate="yes" xml:space="preserve">
          <source>If you want to make a &lt;a href=&quot;qml-qtquick-controls2-textarea&quot;&gt;TextArea&lt;/a&gt; scrollable, for example, when it covers an entire application page, it can be placed inside a &lt;a href=&quot;qml-qtquick-controls2-scrollview&quot;&gt;ScrollView&lt;/a&gt;.</source>
          <target state="translated">例如，如果要使&lt;a href=&quot;qml-qtquick-controls2-textarea&quot;&gt;TextArea&lt;/a&gt;可滚动，则当它覆盖整个应用程序页面时，可以将其放在&lt;a href=&quot;qml-qtquick-controls2-scrollview&quot;&gt;ScrollView内&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0f6b33a5ea49ab490c0a5bfbcab1c555b0192b4f" translate="yes" xml:space="preserve">
          <source>If you want to make a TextArea scrollable, for example, when it covers an entire application page, it can be placed inside a &lt;a href=&quot;qml-qtquick-controls2-scrollview&quot;&gt;ScrollView&lt;/a&gt;.</source>
          <target state="translated">例如，如果要使TextArea可滚动，则当它覆盖整个应用程序页面时，可以将其放在&lt;a href=&quot;qml-qtquick-controls2-scrollview&quot;&gt;ScrollView内&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0420de4f97c6bd0d0460b7ae76d840ae331c84f5" translate="yes" xml:space="preserve">
          <source>If you want to modify a sequence in-place, use QtConcurrent::filter():</source>
          <target state="translated">如果你想在原地修改一个序列,使用QtConcurrent::filter()。</target>
        </trans-unit>
        <trans-unit id="6dde1ff3076b0db9615214ba9185f8123aff9335" translate="yes" xml:space="preserve">
          <source>If you want to modify a sequence in-place, use QtConcurrent::map(). The map function must then be of the form:</source>
          <target state="translated">如果你想在原地修改一个序列,使用QtConcurrent::map()。然后map函数必须是这样的形式。</target>
        </trans-unit>
        <trans-unit id="d8adeaac6d9eeb2f3e405e34bb22896e1c0e4730" translate="yes" xml:space="preserve">
          <source>If you want to navigate through all the (key, value) pairs stored in a &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt;, you can use an iterator. &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt; provides both &lt;a href=&quot;containers#java-style-iterators&quot;&gt;Java-style iterators&lt;/a&gt; (&lt;a href=&quot;qhashiterator&quot;&gt;QHashIterator&lt;/a&gt; and &lt;a href=&quot;qmutablehashiterator&quot;&gt;QMutableHashIterator&lt;/a&gt;) and &lt;a href=&quot;containers#stl-style-iterators&quot;&gt;STL-style iterators&lt;/a&gt; (&lt;a href=&quot;qhash-const-iterator&quot;&gt;QHash::const_iterator&lt;/a&gt; and &lt;a href=&quot;qhash-iterator&quot;&gt;QHash::iterator&lt;/a&gt;). Here's how to iterate over a &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt;&amp;lt;&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;, int&amp;gt; using a Java-style iterator:</source>
          <target state="translated">如果要浏览&lt;a href=&quot;qhash#qhash&quot;&gt;QHash中&lt;/a&gt;存储的所有（键，值）对，则可以使用迭代器。&lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt;提供&lt;a href=&quot;containers#java-style-iterators&quot;&gt;Java样式的迭代器&lt;/a&gt;（&lt;a href=&quot;qhashiterator&quot;&gt;QHashIterator&lt;/a&gt;和&lt;a href=&quot;qmutablehashiterator&quot;&gt;QMutableHashIterator&lt;/a&gt;）和&lt;a href=&quot;containers#stl-style-iterators&quot;&gt;STL样式的迭代器&lt;/a&gt;（&lt;a href=&quot;qhash-const-iterator&quot;&gt;QHash :: const_iterator&lt;/a&gt;和&lt;a href=&quot;qhash-iterator&quot;&gt;QHash :: iterator&lt;/a&gt;）。以下是使用Java样式的迭代器在&lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt; &amp;lt; &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;，int&amp;gt;上进行迭代的方法：</target>
        </trans-unit>
        <trans-unit id="ebc60af08240e3c0d4572b58b54204bd9cae77c9" translate="yes" xml:space="preserve">
          <source>If you want to navigate through all the (key, value) pairs stored in a &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt;, you can use an iterator. &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt; provides both &lt;a href=&quot;containers#java-style-iterators&quot;&gt;Java-style iterators&lt;/a&gt; (&lt;a href=&quot;qmapiterator&quot;&gt;QMapIterator&lt;/a&gt; and &lt;a href=&quot;qmutablemapiterator&quot;&gt;QMutableMapIterator&lt;/a&gt;) and &lt;a href=&quot;containers#stl-style-iterators&quot;&gt;STL-style iterators&lt;/a&gt; (&lt;a href=&quot;qmap-const-iterator&quot;&gt;QMap::const_iterator&lt;/a&gt; and &lt;a href=&quot;qmap-iterator&quot;&gt;QMap::iterator&lt;/a&gt;). Here's how to iterate over a &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt;&amp;lt;&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;, int&amp;gt; using a Java-style iterator:</source>
          <target state="translated">如果要浏览&lt;a href=&quot;qmap&quot;&gt;QMap中&lt;/a&gt;存储的所有（键，值）对，则可以使用迭代器。&lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt;提供&lt;a href=&quot;containers#java-style-iterators&quot;&gt;Java样式的迭代器&lt;/a&gt;（&lt;a href=&quot;qmapiterator&quot;&gt;QMapIterator&lt;/a&gt;和&lt;a href=&quot;qmutablemapiterator&quot;&gt;QMutableMapIterator&lt;/a&gt;）和&lt;a href=&quot;containers#stl-style-iterators&quot;&gt;STL样式的迭代器&lt;/a&gt;（&lt;a href=&quot;qmap-const-iterator&quot;&gt;QMap :: const_iterator&lt;/a&gt;和&lt;a href=&quot;qmap-iterator&quot;&gt;QMap :: iterator&lt;/a&gt;）。以下是使用Java样式的迭代器在&lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt; &amp;lt; &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;，int&amp;gt;上进行迭代的方法：</target>
        </trans-unit>
        <trans-unit id="fa75b2b1a54160e859dd6e1c3b9c89a867812ac8" translate="yes" xml:space="preserve">
          <source>If you want to navigate through all the (key, value) pairs stored in a QHash, you can use an iterator. QHash provides both &lt;a href=&quot;containers#java-style-iterators&quot;&gt;Java-style iterators&lt;/a&gt; (&lt;a href=&quot;qhashiterator&quot;&gt;QHashIterator&lt;/a&gt; and &lt;a href=&quot;qmutablehashiterator&quot;&gt;QMutableHashIterator&lt;/a&gt;) and &lt;a href=&quot;containers#stl-style-iterators&quot;&gt;STL-style iterators&lt;/a&gt; (&lt;a href=&quot;qhash-const-iterator&quot;&gt;QHash::const_iterator&lt;/a&gt; and &lt;a href=&quot;qhash-iterator&quot;&gt;QHash::iterator&lt;/a&gt;). Here's how to iterate over a QHash&amp;lt;&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;, int&amp;gt; using a Java-style iterator:</source>
          <target state="translated">如果要浏览QHash中存储的所有（键，值）对，则可以使用迭代器。QHash提供&lt;a href=&quot;containers#java-style-iterators&quot;&gt;Java样式的迭代器&lt;/a&gt;（&lt;a href=&quot;qhashiterator&quot;&gt;QHashIterator&lt;/a&gt;和&lt;a href=&quot;qmutablehashiterator&quot;&gt;QMutableHashIterator&lt;/a&gt;）和&lt;a href=&quot;containers#stl-style-iterators&quot;&gt;STL样式的迭代器&lt;/a&gt;（&lt;a href=&quot;qhash-const-iterator&quot;&gt;QHash :: const_iterator&lt;/a&gt;和&lt;a href=&quot;qhash-iterator&quot;&gt;QHash :: iterator&lt;/a&gt;）。以下是使用Java样式的迭代器在QHash &amp;lt; &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;，int&amp;gt;上进行迭代的方法：</target>
        </trans-unit>
        <trans-unit id="3259686f4196bc7ee4a364f35939514f537d2cc8" translate="yes" xml:space="preserve">
          <source>If you want to navigate through all the (key, value) pairs stored in a QHash, you can use an iterator. QHash provides both &lt;a href=&quot;java-style-iterators#java-style-iterators&quot;&gt;Java-style iterators&lt;/a&gt; (&lt;a href=&quot;qhashiterator&quot;&gt;QHashIterator&lt;/a&gt; and &lt;a href=&quot;qmutablehashiterator&quot;&gt;QMutableHashIterator&lt;/a&gt;) and &lt;a href=&quot;containers#stl-style-iterators&quot;&gt;STL-style iterators&lt;/a&gt; (&lt;a href=&quot;qhash-const-iterator&quot;&gt;QHash::const_iterator&lt;/a&gt; and &lt;a href=&quot;qhash-iterator&quot;&gt;QHash::iterator&lt;/a&gt;). Here's how to iterate over a QHash&amp;lt;&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;, int&amp;gt; using a Java-style iterator:</source>
          <target state="translated">如果要浏览QHash中存储的所有（键，值）对，则可以使用迭代器。QHash提供&lt;a href=&quot;java-style-iterators#java-style-iterators&quot;&gt;Java样式的迭代器&lt;/a&gt;（&lt;a href=&quot;qhashiterator&quot;&gt;QHashIterator&lt;/a&gt;和&lt;a href=&quot;qmutablehashiterator&quot;&gt;QMutableHashIterator&lt;/a&gt;）和&lt;a href=&quot;containers#stl-style-iterators&quot;&gt;STL样式的迭代器&lt;/a&gt;（&lt;a href=&quot;qhash-const-iterator&quot;&gt;QHash :: const_iterator&lt;/a&gt;和&lt;a href=&quot;qhash-iterator&quot;&gt;QHash :: iterator&lt;/a&gt;）。以下是使用Java样式的迭代器在QHash &amp;lt; &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;，int&amp;gt;上进行迭代的方法：</target>
        </trans-unit>
        <trans-unit id="ba255037c612eb52fcecf41cc205f36d1ad64e1e" translate="yes" xml:space="preserve">
          <source>If you want to navigate through all the (key, value) pairs stored in a QMap, you can use an iterator. QMap provides both &lt;a href=&quot;containers#java-style-iterators&quot;&gt;Java-style iterators&lt;/a&gt; (&lt;a href=&quot;qmapiterator&quot;&gt;QMapIterator&lt;/a&gt; and &lt;a href=&quot;qmutablemapiterator&quot;&gt;QMutableMapIterator&lt;/a&gt;) and &lt;a href=&quot;containers#stl-style-iterators&quot;&gt;STL-style iterators&lt;/a&gt; (&lt;a href=&quot;qmap-const-iterator&quot;&gt;QMap::const_iterator&lt;/a&gt; and &lt;a href=&quot;qmap-iterator&quot;&gt;QMap::iterator&lt;/a&gt;). Here's how to iterate over a QMap&amp;lt;&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;, int&amp;gt; using a Java-style iterator:</source>
          <target state="translated">如果要浏览QMap中存储的所有（键，值）对，则可以使用迭代器。QMap提供&lt;a href=&quot;containers#java-style-iterators&quot;&gt;Java样式的迭代器&lt;/a&gt;（&lt;a href=&quot;qmapiterator&quot;&gt;QMapIterator&lt;/a&gt;和&lt;a href=&quot;qmutablemapiterator&quot;&gt;QMutableMapIterator&lt;/a&gt;）和&lt;a href=&quot;containers#stl-style-iterators&quot;&gt;STL样式的迭代器&lt;/a&gt;（&lt;a href=&quot;qmap-const-iterator&quot;&gt;QMap :: const_iterator&lt;/a&gt;和&lt;a href=&quot;qmap-iterator&quot;&gt;QMap :: iterator&lt;/a&gt;）。以下是使用Java样式的迭代器在QMap &amp;lt; &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;，int&amp;gt;上进行迭代的方法：</target>
        </trans-unit>
        <trans-unit id="5e77d36c8e4098f59cf123dcdee3713e86cdc6c1" translate="yes" xml:space="preserve">
          <source>If you want to navigate through all the (key, value) pairs stored in a QMap, you can use an iterator. QMap provides both &lt;a href=&quot;java-style-iterators#java-style-iterators&quot;&gt;Java-style iterators&lt;/a&gt; (&lt;a href=&quot;qmapiterator&quot;&gt;QMapIterator&lt;/a&gt; and &lt;a href=&quot;qmutablemapiterator&quot;&gt;QMutableMapIterator&lt;/a&gt;) and &lt;a href=&quot;containers#stl-style-iterators&quot;&gt;STL-style iterators&lt;/a&gt; (&lt;a href=&quot;qmap-const-iterator&quot;&gt;QMap::const_iterator&lt;/a&gt; and &lt;a href=&quot;qmap-iterator&quot;&gt;QMap::iterator&lt;/a&gt;). Here's how to iterate over a QMap&amp;lt;&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;, int&amp;gt; using a Java-style iterator:</source>
          <target state="translated">如果要浏览QMap中存储的所有（键，值）对，则可以使用迭代器。QMap提供&lt;a href=&quot;java-style-iterators#java-style-iterators&quot;&gt;Java样式的迭代器&lt;/a&gt;（&lt;a href=&quot;qmapiterator&quot;&gt;QMapIterator&lt;/a&gt;和&lt;a href=&quot;qmutablemapiterator&quot;&gt;QMutableMapIterator&lt;/a&gt;）和&lt;a href=&quot;containers#stl-style-iterators&quot;&gt;STL样式的迭代器&lt;/a&gt;（&lt;a href=&quot;qmap-const-iterator&quot;&gt;QMap :: const_iterator&lt;/a&gt;和&lt;a href=&quot;qmap-iterator&quot;&gt;QMap :: iterator&lt;/a&gt;）。以下是使用Java样式的迭代器在QMap &amp;lt; &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;，int&amp;gt;上进行迭代的方法：</target>
        </trans-unit>
        <trans-unit id="a8c6c0c807bb8fa533a9ab7fd95579cedf337248" translate="yes" xml:space="preserve">
          <source>If you want to navigate through all the (key, value) pairs stored in a QMultiMap, you can use an iterator. QMultiMap provides both &lt;a href=&quot;java-style-iterators#java-style-iterators&quot;&gt;Java-style iterators&lt;/a&gt; (&lt;a href=&quot;qmultimapiterator&quot;&gt;QMultiMapIterator&lt;/a&gt; and &lt;a href=&quot;qmutablemultimapiterator&quot;&gt;QMutableMultiMapIterator&lt;/a&gt;) and &lt;a href=&quot;containers#stl-style-iterators&quot;&gt;STL-style iterators&lt;/a&gt; (&lt;a href=&quot;qmultimap-const-iterator&quot;&gt;QMultiMap::const_iterator&lt;/a&gt; and &lt;a href=&quot;qmultimap-iterator&quot;&gt;QMultiMap::iterator&lt;/a&gt;). Here's how to iterate over a QMultiMap&amp;lt;&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;, int&amp;gt; using a Java-style iterator:</source>
          <target state="translated">如果要浏览QMultiMap中存储的所有（键，值）对，则可以使用迭代器。QMultiMap提供&lt;a href=&quot;java-style-iterators#java-style-iterators&quot;&gt;Java样式的迭代器&lt;/a&gt;（&lt;a href=&quot;qmultimapiterator&quot;&gt;QMultiMapIterator&lt;/a&gt;和&lt;a href=&quot;qmutablemultimapiterator&quot;&gt;QMutableMultiMapIterator&lt;/a&gt;）和&lt;a href=&quot;containers#stl-style-iterators&quot;&gt;STL样式的迭代器&lt;/a&gt;（&lt;a href=&quot;qmultimap-const-iterator&quot;&gt;QMultiMap :: const_iterator&lt;/a&gt;和&lt;a href=&quot;qmultimap-iterator&quot;&gt;QMultiMap :: iterator&lt;/a&gt;）。以下是使用Java样式的迭代器在QMultiMap &amp;lt; &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;，int&amp;gt;上进行迭代的方法：</target>
        </trans-unit>
        <trans-unit id="b20716bbd0aa09befd167b9400ee62464348694e" translate="yes" xml:space="preserve">
          <source>If you want to navigate through all the values stored in a &lt;a href=&quot;qset&quot;&gt;QSet&lt;/a&gt;, you can use an iterator. &lt;a href=&quot;qset&quot;&gt;QSet&lt;/a&gt; supports both &lt;a href=&quot;containers#java-style-iterators&quot;&gt;Java-style iterators&lt;/a&gt; (&lt;a href=&quot;qsetiterator&quot;&gt;QSetIterator&lt;/a&gt; and &lt;a href=&quot;qmutablesetiterator&quot;&gt;QMutableSetIterator&lt;/a&gt;) and &lt;a href=&quot;containers#stl-style-iterators&quot;&gt;STL-style iterators&lt;/a&gt; (&lt;a href=&quot;qset-iterator&quot;&gt;QSet::iterator&lt;/a&gt; and &lt;a href=&quot;qset-const-iterator&quot;&gt;QSet::const_iterator&lt;/a&gt;). Here's how to iterate over a &lt;a href=&quot;qset&quot;&gt;QSet&lt;/a&gt;&amp;lt;&lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; *&amp;gt; using a Java-style iterator:</source>
          <target state="translated">如果要浏览&lt;a href=&quot;qset&quot;&gt;QSet中&lt;/a&gt;存储的所有值，则可以使用迭代器。&lt;a href=&quot;qset&quot;&gt;QSet&lt;/a&gt;支持&lt;a href=&quot;containers#java-style-iterators&quot;&gt;Java样式的迭代器&lt;/a&gt;（&lt;a href=&quot;qsetiterator&quot;&gt;QSetIterator&lt;/a&gt;和&lt;a href=&quot;qmutablesetiterator&quot;&gt;QMutableSetIterator&lt;/a&gt;）和&lt;a href=&quot;containers#stl-style-iterators&quot;&gt;STL样式的迭代器&lt;/a&gt;（&lt;a href=&quot;qset-iterator&quot;&gt;QSet :: iterator&lt;/a&gt;和&lt;a href=&quot;qset-const-iterator&quot;&gt;QSet :: const_iterator&lt;/a&gt;）。以下是使用Java样式的迭代器遍历&lt;a href=&quot;qset&quot;&gt;QSet&lt;/a&gt; &amp;lt; &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; *&amp;gt;的方法：</target>
        </trans-unit>
        <trans-unit id="fc325a6b34a19261ae0c91dd146b59748747b9c2" translate="yes" xml:space="preserve">
          <source>If you want to navigate through all the values stored in a QSet, you can use an iterator. QSet supports both &lt;a href=&quot;containers#java-style-iterators&quot;&gt;Java-style iterators&lt;/a&gt; (&lt;a href=&quot;qsetiterator&quot;&gt;QSetIterator&lt;/a&gt; and &lt;a href=&quot;qmutablesetiterator&quot;&gt;QMutableSetIterator&lt;/a&gt;) and &lt;a href=&quot;containers#stl-style-iterators&quot;&gt;STL-style iterators&lt;/a&gt; (&lt;a href=&quot;qset-iterator&quot;&gt;QSet::iterator&lt;/a&gt; and &lt;a href=&quot;qset-const-iterator&quot;&gt;QSet::const_iterator&lt;/a&gt;). Here's how to iterate over a QSet&amp;lt;&lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; *&amp;gt; using a Java-style iterator:</source>
          <target state="translated">如果要浏览存储在QSet中的所有值，则可以使用迭代器。QSet支持&lt;a href=&quot;containers#java-style-iterators&quot;&gt;Java样式的迭代器&lt;/a&gt;（&lt;a href=&quot;qsetiterator&quot;&gt;QSetIterator&lt;/a&gt;和&lt;a href=&quot;qmutablesetiterator&quot;&gt;QMutableSetIterator&lt;/a&gt;）和&lt;a href=&quot;containers#stl-style-iterators&quot;&gt;STL样式的迭代器&lt;/a&gt;（&lt;a href=&quot;qset-iterator&quot;&gt;QSet :: iterator&lt;/a&gt;和&lt;a href=&quot;qset-const-iterator&quot;&gt;QSet :: const_iterator&lt;/a&gt;）。以下是使用Java样式的迭代器遍历QSet &amp;lt; &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; *&amp;gt;的方法：</target>
        </trans-unit>
        <trans-unit id="cf5e93754d16d99fcbea8f8046851aae17215846" translate="yes" xml:space="preserve">
          <source>If you want to navigate through all the values stored in a QSet, you can use an iterator. QSet supports both &lt;a href=&quot;java-style-iterators#java-style-iterators&quot;&gt;Java-style iterators&lt;/a&gt; (&lt;a href=&quot;qsetiterator&quot;&gt;QSetIterator&lt;/a&gt; and &lt;a href=&quot;qmutablesetiterator&quot;&gt;QMutableSetIterator&lt;/a&gt;) and &lt;a href=&quot;containers#stl-style-iterators&quot;&gt;STL-style iterators&lt;/a&gt; (&lt;a href=&quot;qset-iterator&quot;&gt;QSet::iterator&lt;/a&gt; and &lt;a href=&quot;qset-const-iterator&quot;&gt;QSet::const_iterator&lt;/a&gt;). Here's how to iterate over a QSet&amp;lt;&lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;QWidget&lt;/a&gt; *&amp;gt; using a Java-style iterator:</source>
          <target state="translated">如果要浏览存储在QSet中的所有值，则可以使用迭代器。QSet支持&lt;a href=&quot;java-style-iterators#java-style-iterators&quot;&gt;Java样式的迭代器&lt;/a&gt;（&lt;a href=&quot;qsetiterator&quot;&gt;QSetIterator&lt;/a&gt;和&lt;a href=&quot;qmutablesetiterator&quot;&gt;QMutableSetIterator&lt;/a&gt;）和&lt;a href=&quot;containers#stl-style-iterators&quot;&gt;STL样式的迭代器&lt;/a&gt;（&lt;a href=&quot;qset-iterator&quot;&gt;QSet :: iterator&lt;/a&gt;和&lt;a href=&quot;qset-const-iterator&quot;&gt;QSet :: const_iterator&lt;/a&gt;）。以下是使用Java样式的迭代器遍历QSet &amp;lt; &lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;QWidget&lt;/a&gt; *&amp;gt;的方法：</target>
        </trans-unit>
        <trans-unit id="236a93db4a1d0f7ce94c428455da527fbe453ad5" translate="yes" xml:space="preserve">
          <source>If you want to obtain the length of the data up to and excluding the first '\0' byte, call &lt;a href=&quot;qbytearray#qstrlen&quot;&gt;qstrlen&lt;/a&gt;() on the byte array.</source>
          <target state="translated">如果要获取直到第一个'\ 0'字节为止的数据长度，请在字节数组上调用&lt;a href=&quot;qbytearray#qstrlen&quot;&gt;qstrlen&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="fd6a6b3eb89e36681847d3a753e1b94077fbd42c" translate="yes" xml:space="preserve">
          <source>If you want to obtain the length of the data up to and excluding the first '\0' character, call &lt;a href=&quot;qbytearray#qstrlen&quot;&gt;qstrlen&lt;/a&gt;() on the byte array.</source>
          <target state="translated">如果要获取直到第一个'\ 0'字符为止的数据长度，请在字节数组上调用&lt;a href=&quot;qbytearray#qstrlen&quot;&gt;qstrlen&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="9dfae933ac79cc33edd3dbc61fb58a87498e4218" translate="yes" xml:space="preserve">
          <source>If you want to provide a guaranteed fallback for platforms that do not support theme icons, you can use the second argument:</source>
          <target state="translated">如果你想为不支持主题图标的平台提供一个有保障的后备方案,你可以使用第二个参数。</target>
        </trans-unit>
        <trans-unit id="1db9564dfa61dd28433eb70fca5b8e74b0cfc6e1" translate="yes" xml:space="preserve">
          <source>If you want to provide plugins for use with Qt Designer, see the Qt Designer module documentation.</source>
          <target state="translated">如果你想提供与Qt Designer一起使用的插件,请参阅Qt Designer模块文档。</target>
        </trans-unit>
        <trans-unit id="d752ee6abc56ad70cc035e97e08c8c1a5bb8ed99" translate="yes" xml:space="preserve">
          <source>If you want to provide support for web sites that allow the user to open new windows, such as pop-up windows, you can subclass &lt;a href=&quot;qwebengineview&quot;&gt;QWebEngineView&lt;/a&gt; and reimplement the &lt;a href=&quot;qwebengineview#createWindow&quot;&gt;createWindow&lt;/a&gt;() function.</source>
          <target state="translated">如果要为允许用户打开新窗口（例如弹出窗口）的网站提供支持，则可以将&lt;a href=&quot;qwebengineview&quot;&gt;QWebEngineView&lt;/a&gt;子类化并重新实现&lt;a href=&quot;qwebengineview#createWindow&quot;&gt;createWindow&lt;/a&gt;（）函数。</target>
        </trans-unit>
        <trans-unit id="d7aa7b5584e7555a6d888eb37328199ba37a1e69" translate="yes" xml:space="preserve">
          <source>If you want to provide support for web sites that allow the user to open new windows, such as pop-up windows, you can subclass QWebEngineView and reimplement the &lt;a href=&quot;qwebengineview#createWindow&quot;&gt;createWindow&lt;/a&gt;() function.</source>
          <target state="translated">如果要为允许用户打开新窗口（例如弹出窗口）的网站提供支持，则可以继承QWebEngineView的子类并重新实现&lt;a href=&quot;qwebengineview#createWindow&quot;&gt;createWindow&lt;/a&gt;（）函数。</target>
        </trans-unit>
        <trans-unit id="1bfc523424c8243bdf30d15255ee2b9ba5b0b3c7" translate="yes" xml:space="preserve">
          <source>If you want to provide your users with an editable rich text editor, use &lt;a href=&quot;qtextedit&quot;&gt;QTextEdit&lt;/a&gt;. If you want a text browser without hypertext navigation use &lt;a href=&quot;qtextedit&quot;&gt;QTextEdit&lt;/a&gt;, and use &lt;a href=&quot;qtextedit#readOnly-prop&quot;&gt;QTextEdit::setReadOnly&lt;/a&gt;() to disable editing. If you just need to display a small piece of rich text use &lt;a href=&quot;qlabel&quot;&gt;QLabel&lt;/a&gt;.</source>
          <target state="translated">如果要为用户提供可编辑的RTF编辑器，请使用&lt;a href=&quot;qtextedit&quot;&gt;QTextEdit&lt;/a&gt;。如果要使用没有超文本导航的文本浏览器，请使用&lt;a href=&quot;qtextedit&quot;&gt;QTextEdit&lt;/a&gt;，并使用&lt;a href=&quot;qtextedit#readOnly-prop&quot;&gt;QTextEdit :: setReadOnly&lt;/a&gt;（）禁用编辑。如果只需要显示一小段富文本，请使用&lt;a href=&quot;qlabel&quot;&gt;QLabel&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3ee969597a0600019ade75416316647fc0e6d9d0" translate="yes" xml:space="preserve">
          <source>If you want to remove an object from the cache for a particular key, call &lt;a href=&quot;qcache#remove&quot;&gt;remove&lt;/a&gt;(). This will also delete the object. If you want to remove an object from the cache without the &lt;a href=&quot;qcache&quot;&gt;QCache&lt;/a&gt; deleting it, use &lt;a href=&quot;qcache#take&quot;&gt;take&lt;/a&gt;().</source>
          <target state="translated">如果要从高速缓存中&lt;a href=&quot;qcache#remove&quot;&gt;删除&lt;/a&gt;特定键的对象，请调用remove（）。这也将删除对象。如果要从缓存中删除一个对象而不用&lt;a href=&quot;qcache&quot;&gt;QCache&lt;/a&gt;删除它，请使用&lt;a href=&quot;qcache#take&quot;&gt;take&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="8bce0ab0de5a755eb7d8898d503d990fd8269964" translate="yes" xml:space="preserve">
          <source>If you want to remove an object from the cache for a particular key, call &lt;a href=&quot;qcache#remove&quot;&gt;remove&lt;/a&gt;(). This will also delete the object. If you want to remove an object from the cache without the QCache deleting it, use &lt;a href=&quot;qcache#take&quot;&gt;take&lt;/a&gt;().</source>
          <target state="translated">如果要从缓存中&lt;a href=&quot;qcache#remove&quot;&gt;删除&lt;/a&gt;特定键的对象，请调用remove（）。这也将删除对象。如果要从缓存中删除一个对象而不用QCache删除它，请使用&lt;a href=&quot;qcache#take&quot;&gt;take&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="de95e27c0ba8453eb485155237ef997413f9832c" translate="yes" xml:space="preserve">
          <source>If you want to remove characters from the</source>
          <target state="translated">如果你想从</target>
        </trans-unit>
        <trans-unit id="ef371b9382f4cd607dccd67bf00e4dbc96b7c58a" translate="yes" xml:space="preserve">
          <source>If you want to remove items as you iterate over the hash, use &lt;a href=&quot;qmutablehashiterator#remove&quot;&gt;remove&lt;/a&gt;(). If you want to modify the value of an item, use &lt;a href=&quot;qmutablehashiterator#setValue&quot;&gt;setValue&lt;/a&gt;().</source>
          <target state="translated">如果要在遍历哈希值时删除项目，请使用&lt;a href=&quot;qmutablehashiterator#remove&quot;&gt;remove&lt;/a&gt;（）。如果要修改项目的值，请使用&lt;a href=&quot;qmutablehashiterator#setValue&quot;&gt;setValue&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="b8309cc38c8ce729c85673e89ad866ebb77ca098" translate="yes" xml:space="preserve">
          <source>If you want to remove items as you iterate over the list, use &lt;a href=&quot;qmutablelinkedlistiterator#remove&quot;&gt;remove&lt;/a&gt;(). If you want to modify the value of an item, use &lt;a href=&quot;qmutablelinkedlistiterator#setValue&quot;&gt;setValue&lt;/a&gt;(). If you want to insert a new item in the list, use &lt;a href=&quot;qmutablelinkedlistiterator#insert&quot;&gt;insert&lt;/a&gt;().</source>
          <target state="translated">如果要在遍历列表时删除项目，请使用&lt;a href=&quot;qmutablelinkedlistiterator#remove&quot;&gt;remove&lt;/a&gt;（）。如果要修改项目的值，请使用&lt;a href=&quot;qmutablelinkedlistiterator#setValue&quot;&gt;setValue&lt;/a&gt;（）。如果要在列表中插入新项目，请使用&lt;a href=&quot;qmutablelinkedlistiterator#insert&quot;&gt;insert&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="10376d50da4d07a2e0e13c459ae06c0f3bdf15f1" translate="yes" xml:space="preserve">
          <source>If you want to remove items as you iterate over the list, use &lt;a href=&quot;qmutablelistiterator#remove&quot;&gt;remove&lt;/a&gt;(). If you want to modify the value of an item, use &lt;a href=&quot;qmutablelistiterator#setValue&quot;&gt;setValue&lt;/a&gt;(). If you want to insert a new item in the list, use &lt;a href=&quot;qmutablelistiterator#insert&quot;&gt;insert&lt;/a&gt;().</source>
          <target state="translated">如果要在遍历列表时删除项目，请使用&lt;a href=&quot;qmutablelistiterator#remove&quot;&gt;remove&lt;/a&gt;（）。如果要修改项目的值，请使用&lt;a href=&quot;qmutablelistiterator#setValue&quot;&gt;setValue&lt;/a&gt;（）。如果要在列表中插入新项目，请使用&lt;a href=&quot;qmutablelistiterator#insert&quot;&gt;insert&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="e79b00991d7411d8730611af60e4448d620be40f" translate="yes" xml:space="preserve">
          <source>If you want to remove items as you iterate over the map, use &lt;a href=&quot;qmutablemapiterator#remove&quot;&gt;remove&lt;/a&gt;(). If you want to modify the value of an item, use &lt;a href=&quot;qmutablemapiterator#setValue&quot;&gt;setValue&lt;/a&gt;().</source>
          <target state="translated">如果要在遍历地图时删除项目，请使用&lt;a href=&quot;qmutablemapiterator#remove&quot;&gt;remove&lt;/a&gt;（）。如果要修改项目的值，请使用&lt;a href=&quot;qmutablemapiterator#setValue&quot;&gt;setValue&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="58f529c1e2bd66646146fee0accb5d94552c3133" translate="yes" xml:space="preserve">
          <source>If you want to remove items as you iterate over the map, use &lt;a href=&quot;qmutablemultimapiterator#remove&quot;&gt;remove&lt;/a&gt;(). If you want to modify the value of an item, use &lt;a href=&quot;qmutablemultimapiterator#setValue&quot;&gt;setValue&lt;/a&gt;().</source>
          <target state="translated">如果要在遍历地图时删除项目，请使用&lt;a href=&quot;qmutablemultimapiterator#remove&quot;&gt;remove&lt;/a&gt;（）。如果要修改项目的值，请使用&lt;a href=&quot;qmutablemultimapiterator#setValue&quot;&gt;setValue&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="e3544fda3dbbc15c7c70a6df904991bf6f723fcf" translate="yes" xml:space="preserve">
          <source>If you want to remove items as you iterate over the set, use &lt;a href=&quot;qmutablesetiterator#remove&quot;&gt;remove&lt;/a&gt;().</source>
          <target state="translated">如果要在遍历集合时删除项目，请使用&lt;a href=&quot;qmutablesetiterator#remove&quot;&gt;remove&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="52adc96426aaf31b367417826338bf9e429eaab0" translate="yes" xml:space="preserve">
          <source>If you want to remove items as you iterate over the vector, use &lt;a href=&quot;qmutablevectoriterator#remove&quot;&gt;remove&lt;/a&gt;(). If you want to modify the value of an item, use &lt;a href=&quot;qmutablevectoriterator#setValue&quot;&gt;setValue&lt;/a&gt;(). If you want to insert a new item in the vector, use &lt;a href=&quot;qmutablevectoriterator#insert&quot;&gt;insert&lt;/a&gt;().</source>
          <target state="translated">如果要在遍历向量时删除项目，请使用&lt;a href=&quot;qmutablevectoriterator#remove&quot;&gt;remove&lt;/a&gt;（）。如果要修改项目的值，请使用&lt;a href=&quot;qmutablevectoriterator#setValue&quot;&gt;setValue&lt;/a&gt;（）。如果要在向量中插入新项目，请使用&lt;a href=&quot;qmutablevectoriterator#insert&quot;&gt;insert&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="6fda9fdf9261a6245582f8837e5859eea092ed4b" translate="yes" xml:space="preserve">
          <source>If you want to remove the row from the form layout and delete the inserted layout, use &lt;a href=&quot;qformlayout#removeRow&quot;&gt;removeRow&lt;/a&gt;() instead.</source>
          <target state="translated">如果要从表单布局中删除行并删除插入的布局，请改用&lt;a href=&quot;qformlayout#removeRow&quot;&gt;removeRow&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="5b5de4c69911fc30f9b82bfa504e693900ea36ee" translate="yes" xml:space="preserve">
          <source>If you want to remove the row from the form layout without deleting the inserted layout, use &lt;a href=&quot;qformlayout#takeRow&quot;&gt;takeRow&lt;/a&gt;() instead.</source>
          <target state="translated">如果要从表单布局中删除行而不删除插入的布局，请改用&lt;a href=&quot;qformlayout#takeRow&quot;&gt;takeRow&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="fa1ce005f8df0dab7960ecac023bfee749fbe509" translate="yes" xml:space="preserve">
          <source>If you want to remove the row from the layout and delete the widgets, use &lt;a href=&quot;qformlayout#removeRow&quot;&gt;removeRow&lt;/a&gt;() instead.</source>
          <target state="translated">如果要从布局中删除行并删除小部件，请使用&lt;a href=&quot;qformlayout#removeRow&quot;&gt;removeRow&lt;/a&gt;（）代替。</target>
        </trans-unit>
        <trans-unit id="a3f3d65e85e892eceb0bc7744f0008ea7233fffd" translate="yes" xml:space="preserve">
          <source>If you want to remove the row from the layout without deleting the widgets, use &lt;a href=&quot;qformlayout#takeRow&quot;&gt;takeRow&lt;/a&gt;() instead.</source>
          <target state="translated">如果要从布局中删除行而不删除窗口小部件，请改用&lt;a href=&quot;qformlayout#takeRow&quot;&gt;takeRow&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="64cdda339bec7f812dc4dd44c78a96f48277db67" translate="yes" xml:space="preserve">
          <source>If you want to replace the base class's function, you must implement everything yourself. However, if you only want to extend the base class's functionality, then you implement what you want and call the base class to obtain the default behavior for any cases you do not want to handle.</source>
          <target state="translated">如果你想替换基类的功能,你必须自己实现一切。然而,如果你只想扩展基类的功能,那么你就实现你想要的东西,并调用基类来获得你不想处理的任何情况的默认行为。</target>
        </trans-unit>
        <trans-unit id="c7aa4540624b95acabdbadb09c58519aa35fef4c" translate="yes" xml:space="preserve">
          <source>If you want to retrieve all the values for a single key, you can use values(const Key &amp;amp;key), which returns a &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt;&amp;lt;T&amp;gt;:</source>
          <target state="translated">如果要检索单个键的所有值，则可以使用values（const Key＆key），它返回&lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; &amp;lt;T&amp;gt;：</target>
        </trans-unit>
        <trans-unit id="bfd3e6d68a92bd8adc8f0c02f20d7b430c619d3b" translate="yes" xml:space="preserve">
          <source>If you want to run a function that accepts arguments by reference, you should use &lt;a href=&quot;https://en.cppreference.com/w/cpp/utility/functional/ref&quot;&gt;std::ref/cref&lt;/a&gt; auxiliary functions. These functions create thin wrappers around passed arguments:</source>
          <target state="translated">如果要运行通过引用接受参数的函数，则应使用&lt;a href=&quot;https://en.cppreference.com/w/cpp/utility/functional/ref&quot;&gt;std :: ref / cref&lt;/a&gt;辅助函数。这些函数围绕传递的参数创建精简包装器：</target>
        </trans-unit>
        <trans-unit id="e89eb3afeb225e87d907879175af3afcf126c9a5" translate="yes" xml:space="preserve">
          <source>If you want to save or restore many settings with the same prefix, you can specify the prefix using &lt;a href=&quot;qsettings#beginGroup&quot;&gt;beginGroup&lt;/a&gt;() and call &lt;a href=&quot;qsettings#endGroup&quot;&gt;endGroup&lt;/a&gt;() at the end. Here's the same example again, but this time using the group mechanism:</source>
          <target state="translated">如果要保存或恢复许多具有相同前缀的设置，则可以使用&lt;a href=&quot;qsettings#beginGroup&quot;&gt;beginGroup&lt;/a&gt;（）指定前缀，并在最后调用&lt;a href=&quot;qsettings#endGroup&quot;&gt;endGroup&lt;/a&gt;（）。这再次是相同的示例，但是这次使用组机制：</target>
        </trans-unit>
        <trans-unit id="a75869a744ee8993dcf20ae9c6b9a50d513b38ca" translate="yes" xml:space="preserve">
          <source>If you want to save your changes, and at the same time preserve the original contents, you can use the &lt;a href=&quot;qdesignerwidgetboxinterface#save&quot;&gt;save&lt;/a&gt;() function combined with the &lt;a href=&quot;qdesignerwidgetboxinterface#setFileName&quot;&gt;setFileName&lt;/a&gt;() function to save your changes into another file. Remember to store the name of the original file first:</source>
          <target state="translated">如果要保存更改，同时保留原始内容，则可以将&lt;a href=&quot;qdesignerwidgetboxinterface#save&quot;&gt;save&lt;/a&gt;（）函数与&lt;a href=&quot;qdesignerwidgetboxinterface#setFileName&quot;&gt;setFileName&lt;/a&gt;（）函数结合使用，以将更改保存到另一个文件中。请记住首先存储原始文件的名称：</target>
        </trans-unit>
        <trans-unit id="c0905b1777f0fd800c421f7d245b1e5b746013b1" translate="yes" xml:space="preserve">
          <source>If you want to see if a &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; starts or ends with a particular substring use &lt;a href=&quot;qstring#startsWith&quot;&gt;startsWith&lt;/a&gt;() or &lt;a href=&quot;qstring#endsWith&quot;&gt;endsWith&lt;/a&gt;(). If you simply want to check whether a &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; contains a particular character or substring, use the &lt;a href=&quot;qstring#contains&quot;&gt;contains&lt;/a&gt;() function. If you want to find out how many times a particular character or substring occurs in the string, use &lt;a href=&quot;qstring#count-1&quot;&gt;count&lt;/a&gt;().</source>
          <target state="translated">如果要查看&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;是否以特定的子字符串开头或结尾，请使用&lt;a href=&quot;qstring#startsWith&quot;&gt;startsWith&lt;/a&gt;（）或&lt;a href=&quot;qstring#endsWith&quot;&gt;endssWith&lt;/a&gt;（）。如果只想检查&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;是否包含特定字符或子字符串，请使用&lt;a href=&quot;qstring#contains&quot;&gt;contains&lt;/a&gt;（）函数。如果要确定字符串中某个特定字符或子字符串出现了多少次，请使用&lt;a href=&quot;qstring#count-1&quot;&gt;count&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="533da401175c4651a179dc28ba93270aba76a4e6" translate="yes" xml:space="preserve">
          <source>If you want to see if a QString starts or ends with a particular substring use &lt;a href=&quot;qstring#startsWith&quot;&gt;startsWith&lt;/a&gt;() or &lt;a href=&quot;qstring#endsWith&quot;&gt;endsWith&lt;/a&gt;(). If you simply want to check whether a QString contains a particular character or substring, use the &lt;a href=&quot;qstring#contains&quot;&gt;contains&lt;/a&gt;() function. If you want to find out how many times a particular character or substring occurs in the string, use &lt;a href=&quot;qstring#count-1&quot;&gt;count&lt;/a&gt;().</source>
          <target state="translated">如果要查看QString是否以特定的子字符串开头或结尾，请使用&lt;a href=&quot;qstring#startsWith&quot;&gt;startsWith&lt;/a&gt;（）或&lt;a href=&quot;qstring#endsWith&quot;&gt;endersWith&lt;/a&gt;（）。如果仅想检查QString是否包含特定字符或子字符串，请使用&lt;a href=&quot;qstring#contains&quot;&gt;contains&lt;/a&gt;（）函数。如果要确定字符串中某个特定字符或子字符串出现了多少次，请使用&lt;a href=&quot;qstring#count-1&quot;&gt;count&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="9a8f9333a015252bd2352bd9fc0af4626df206b9" translate="yes" xml:space="preserve">
          <source>If you want to set several items of a particular row (say, by calling setItem() in a loop), you may want to turn off sorting before doing so, and turn it back on afterwards; this will allow you to use the same</source>
          <target state="translated">如果你想设置某一行的几个项目(比如说,在循环中调用setItem()),你可能想在这样做之前关闭排序,然后再打开;这将允许你使用相同的</target>
        </trans-unit>
        <trans-unit id="bbca6a7d342806310527b218a8084ddfb4bd37d3" translate="yes" xml:space="preserve">
          <source>If you want to show a tooltip immediately, while the mouse is moving (e.g., to get the mouse coordinates with &lt;a href=&quot;qmouseevent#pos&quot;&gt;QMouseEvent::pos&lt;/a&gt;() and show them as a tooltip), you must first enable mouse tracking as described above. Then, to ensure that the tooltip is updated immediately, you must call &lt;a href=&quot;qtooltip#showText&quot;&gt;QToolTip::showText&lt;/a&gt;() instead of &lt;a href=&quot;qwidget#toolTip-prop&quot;&gt;setToolTip&lt;/a&gt;() in your implementation of mouseMoveEvent().</source>
          <target state="translated">如果要在鼠标移动时立即显示工具提示（例如，使用&lt;a href=&quot;qmouseevent#pos&quot;&gt;QMouseEvent :: pos&lt;/a&gt;（）获取鼠标坐标并将其显示为工具提示），则必须如上所述首先启用鼠标跟踪。然后，以确保提示会立即更新，你必须调用&lt;a href=&quot;qtooltip#showText&quot;&gt;QToolTip :: showText&lt;/a&gt;（），而不是&lt;a href=&quot;qwidget#toolTip-prop&quot;&gt;setToolTip&lt;/a&gt;在实施mouseMoveEvent的（）（）。</target>
        </trans-unit>
        <trans-unit id="cfa70650fd011d8c6b69c7e7e3eebd7b65431d31" translate="yes" xml:space="preserve">
          <source>If you want to sort your strings in an arbitrary order, consider using the &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt; class. For example, you could use a &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt;&amp;lt;&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;, &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;&amp;gt; to create a case-insensitive ordering (e.g. with the keys being lower-case versions of the strings, and the values being the strings), or a &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt;&amp;lt;int, &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;&amp;gt; to sort the strings by some integer index.</source>
          <target state="translated">如果要以任意顺序对字符串进行排序，请考虑使用&lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt;类。例如，您可以使用&lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt; &amp;lt; &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;，&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; &amp;gt;创建不区分大小写的排序（例如，键是字符串的小写版本，而值是字符串），或&lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt; &amp;lt;int，&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; &amp;gt;按某个整数索引对字符串进行排序。</target>
        </trans-unit>
        <trans-unit id="f76a13f9a50f1cd7cbab92e1e2b73729d9143b78" translate="yes" xml:space="preserve">
          <source>If you want to specify the widget's size hint for a given width or height, you can provide the fixed dimension in</source>
          <target state="translated">如果您想为给定的宽度或高度指定小组件的大小提示,您可以在</target>
        </trans-unit>
        <trans-unit id="d0ee609e91b445855383ec2c6155845fa3a8bd55" translate="yes" xml:space="preserve">
          <source>If you want to store a single block of data (e.g., a comment), you can pass an empty key, or use a generic key like &quot;Description&quot;.</source>
          <target state="translated">如果你想存储一个单一的数据块(例如,一个评论),你可以传递一个空键,或者使用一个通用键,如 &quot;描述&quot;。</target>
        </trans-unit>
        <trans-unit id="2a4f0a5bfe2dadd4ac482d1e22ddabd24ae0e99b" translate="yes" xml:space="preserve">
          <source>If you want to support several different ABIs in your application in Google Play, the recommendation is to build an Application App Bundle (AAB) containing binaries for each of the ABIs. Based on your AAB, Google Play generates optimized Application Packages (APK) for each device requesting a download.</source>
          <target state="translated">如果您想在 Google Play 中的应用程序中支持多个不同的 ABI,建议建立一个应用程序应用程序捆绑包 (AAB),其中包含每个 ABI 的二进制文件。基于您的AAB,Google Play会为每个请求下载的设备生成优化的应用程序包(APK)。</target>
        </trans-unit>
        <trans-unit id="2f81b7d8db42ec507d0dba034e10ab727008ab07" translate="yes" xml:space="preserve">
          <source>If you want to support several different architectures in your application, the recommendation is to build separate APKs for each architecture, so that each APK only contains the binaries required for the targeted architecture. For more information about this, see the Android documentation about &lt;a href=&quot;http://developer.android.com/google/play/publishing/multiple-apks.html&quot;&gt;Multiple APK Support&lt;/a&gt;.</source>
          <target state="translated">如果要在应用程序中支持几种不同的体系结构，建议为每种体系结构构建单独的APK，以便每个APK仅包含目标体系结构所需的二进制文件。有关此的更多信息，请参阅Android文档中有关&amp;ldquo; &lt;a href=&quot;http://developer.android.com/google/play/publishing/multiple-apks.html&quot;&gt;多个APK支持&amp;rdquo;的信息&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="72c5fa334893fab33e3b0b02a2877a1c1100827d" translate="yes" xml:space="preserve">
          <source>If you want to use &lt;a href=&quot;qflags&quot;&gt;QFlags&lt;/a&gt; for your own enum types, use the &lt;a href=&quot;qflags#Q_DECLARE_FLAGS&quot;&gt;Q_DECLARE_FLAGS&lt;/a&gt;() and &lt;a href=&quot;qflags#Q_DECLARE_OPERATORS_FOR_FLAGS&quot;&gt;Q_DECLARE_OPERATORS_FOR_FLAGS&lt;/a&gt;().</source>
          <target state="translated">如果要为自己的枚举类型使用&lt;a href=&quot;qflags&quot;&gt;QFlags&lt;/a&gt;，请使用&lt;a href=&quot;qflags#Q_DECLARE_FLAGS&quot;&gt;Q_DECLARE_FLAGS&lt;/a&gt;（）和&lt;a href=&quot;qflags#Q_DECLARE_OPERATORS_FOR_FLAGS&quot;&gt;Q_DECLARE_OPERATORS_FOR_FLAGS&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="01fe2a555ef6e3330c4094498511ceeabc1b9764" translate="yes" xml:space="preserve">
          <source>If you want to use &lt;code&gt;QStringRef&lt;/code&gt; further, you need to link against the new Qt5Compat module and add this line to your &lt;a href=&quot;qmake-manual&quot;&gt;qmake&lt;/a&gt;&lt;code&gt;.pro&lt;/code&gt; file:</source>
          <target state="translated">如果要进一步使用 &lt;code&gt;QStringRef&lt;/code&gt; ，则需要链接到新的Qt5Compat模块，并将此行添加到&lt;a href=&quot;qmake-manual&quot;&gt;qmake &lt;/a&gt; &lt;code&gt;.pro&lt;/code&gt; 文件中：</target>
        </trans-unit>
        <trans-unit id="6b463fe5232536dbaebee4ffdb67aea9757aa428" translate="yes" xml:space="preserve">
          <source>If you want to use INI files on all platforms instead of the native API, you can pass &lt;a href=&quot;qsettings#Format-enum&quot;&gt;QSettings::IniFormat&lt;/a&gt; as the first argument to the &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; constructor, followed by the scope, the organization name, and the application name:</source>
          <target state="translated">如果要在所有平台上使用INI文件而不是本机API，可以将&lt;a href=&quot;qsettings#Format-enum&quot;&gt;QSettings :: IniFormat&lt;/a&gt;作为第一个参数传递给&lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt;构造函数，然后是范围，组织名称和应用程序名称：</target>
        </trans-unit>
        <trans-unit id="4f1cd327ab2090b7b62092c8e761553b7f9ba85e" translate="yes" xml:space="preserve">
          <source>If you want to use INI files on all platforms instead of the native API, you can pass &lt;a href=&quot;qsettings#Format-enum&quot;&gt;QSettings::IniFormat&lt;/a&gt; as the first argument to the QSettings constructor, followed by the scope, the organization name, and the application name:</source>
          <target state="translated">如果要在所有平台上使用INI文件而不是本机API，则可以将&lt;a href=&quot;qsettings#Format-enum&quot;&gt;QSettings :: IniFormat&lt;/a&gt;作为第一个参数传递给QSettings构造函数，然后是范围，组织名称和应用程序名称：</target>
        </trans-unit>
        <trans-unit id="addb3447529bf7a9e75873d603636728a2848ddb" translate="yes" xml:space="preserve">
          <source>If you want to use QFlags for your own enum types, use the &lt;a href=&quot;qflags#Q_DECLARE_FLAGS&quot;&gt;Q_DECLARE_FLAGS&lt;/a&gt;() and &lt;a href=&quot;qflags#Q_DECLARE_OPERATORS_FOR_FLAGS&quot;&gt;Q_DECLARE_OPERATORS_FOR_FLAGS&lt;/a&gt;().</source>
          <target state="translated">如果要对自己的枚举类型使用QFlags，请使用&lt;a href=&quot;qflags#Q_DECLARE_FLAGS&quot;&gt;Q_DECLARE_FLAGS&lt;/a&gt;（）和&lt;a href=&quot;qflags#Q_DECLARE_OPERATORS_FOR_FLAGS&quot;&gt;Q_DECLARE_OPERATORS_FOR_FLAGS&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="503c6e60564c4b89c106e617da9c3ec82fdf48b5" translate="yes" xml:space="preserve">
          <source>If you want to use Q_DECLARE_INTERFACE with interface classes declared in a namespace then you have to make sure the Q_DECLARE_INTERFACE is not inside a namespace though. For example:</source>
          <target state="translated">如果你想对在命名空间中声明的接口类使用Q_DECLARE_INTERFACE,那么你必须确保Q_DECLARE_INTERFACE不在命名空间中。例如</target>
        </trans-unit>
        <trans-unit id="b35675b93a592dae0c6fee364af226250b2a5072" translate="yes" xml:space="preserve">
          <source>If you want to use a &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; to hold child widgets you will usually want to add a layout to the parent &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt;. See &lt;a href=&quot;layout#&quot;&gt;Layout Management&lt;/a&gt; for more information.</source>
          <target state="translated">如果要使用&lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt;来容纳子窗口小部件，通常需要向父&lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt;添加布局。有关更多信息，请参见&lt;a href=&quot;layout#&quot;&gt;布局管理&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b5a573f0d86d70a56471b8113708290e4a37b8cf" translate="yes" xml:space="preserve">
          <source>If you want to use a QWidget to hold child widgets you will usually want to add a layout to the parent QWidget. See &lt;a href=&quot;layout&quot;&gt;Layout Management&lt;/a&gt; for more information.</source>
          <target state="translated">如果要使用QWidget来容纳子窗口小部件，通常需要向父QWidget添加布局。有关更多信息，请参见&lt;a href=&quot;layout&quot;&gt;布局管理&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a245a7594cedd664f521f8d7d5f40f59d2d63ed0" translate="yes" xml:space="preserve">
          <source>If you want to use a different suffix, you must change &lt;code&gt;SHLIB_EXT&lt;/code&gt; in the previous command, and set the &lt;code&gt;ANDROID_OPENSSL_SUFFIX&lt;/code&gt; environment variable before you access the Qt Network API.</source>
          <target state="translated">如果要使用其他后缀，则必须在访问Qt Network API之前更改上一个命令中的 &lt;code&gt;SHLIB_EXT&lt;/code&gt; ，并设置 &lt;code&gt;ANDROID_OPENSSL_SUFFIX&lt;/code&gt; 环境变量。</target>
        </trans-unit>
        <trans-unit id="a75288387750d6649bbe76b48200a4459bccf73d" translate="yes" xml:space="preserve">
          <source>If you want to use a filter function takes more than one argument, you can use a lambda function or &lt;code&gt;std::bind()&lt;/code&gt; to transform it onto a function that takes one argument.</source>
          <target state="translated">如果要使用带多个参数的过滤器函数，则可以使用lambda函数或 &lt;code&gt;std::bind()&lt;/code&gt; 将其转换为带一个参数的函数。</target>
        </trans-unit>
        <trans-unit id="3a895ee318b395fc5d95d98cb1fb6d4a4bd0d6d1" translate="yes" xml:space="preserve">
          <source>If you want to use a framebuffer object with multisampling enabled as a texture, you first need to copy from it to a regular framebuffer object using QOpenGLContext::blitFramebuffer().</source>
          <target state="translated">如果你想使用一个启用了多采样的framebuffer对象作为纹理,你首先需要使用QOpenGLContext::blitFramebuffer()从它复制到一个普通的framebuffer对象。</target>
        </trans-unit>
        <trans-unit id="75c598917b455b9d08c43e1b09257e52ee5de965" translate="yes" xml:space="preserve">
          <source>If you want to use a map function that takes more than one argument you can use a lambda function or &lt;code&gt;std::bind()&lt;/code&gt; to transform it onto a function that takes one argument.</source>
          <target state="translated">如果要使用带有多个参数的map函数，则可以使用lambda函数或 &lt;code&gt;std::bind()&lt;/code&gt; 将其转换为带有一个参数的函数。</target>
        </trans-unit>
        <trans-unit id="fb7f4cd9dd1afebbefc117ff4a87ac14d67c7e1e" translate="yes" xml:space="preserve">
          <source>If you want to use an existing callable object, you need to either copy/move it to &lt;a href=&quot;qtconcurrent#task&quot;&gt;QtConcurrent::task&lt;/a&gt; or wrap it with std::ref/cref:</source>
          <target state="translated">如果要使用现有的可调用对象，则需要将其复制/移动到&lt;a href=&quot;qtconcurrent#task&quot;&gt;QtConcurrent :: task&lt;/a&gt;或使用std :: ref / cref进行包装：</target>
        </trans-unit>
        <trans-unit id="cf14b20ed394796f34b2a1defe39edffcae66ee0" translate="yes" xml:space="preserve">
          <source>If you want to use controls in your server in web-pages you need to make the server available to the browser used to view your page, and you need to specify the location of the server package in your page.</source>
          <target state="translated">如果你想在网页中使用服务器中的控件,你需要让用于查看你的页面的浏览器可以使用服务器,你需要在你的页面中指定服务器包的位置。</target>
        </trans-unit>
        <trans-unit id="0b59a35e51c3e470c7228aef4894f32e97ca9378" translate="yes" xml:space="preserve">
          <source>If you want to use multiple filters, separate each one with</source>
          <target state="translated">如果你想使用多个滤镜,请将每个滤镜用</target>
        </trans-unit>
        <trans-unit id="67acd904a6cfb20bf5d4ec9de62718a79958a636" translate="yes" xml:space="preserve">
          <source>If you want to use other QDoc commands within an argument that contains spaces, you always need to enclose the argument in braces. But QDoc is smart enough to count parentheses [3], so you don't need braces in cases like this:</source>
          <target state="translated">如果你想在一个包含空格的参数中使用其他QDoc命令,你总是需要用大括号将参数括起来。但是QDoc很聪明,可以算出括号[3],所以在这种情况下你不需要括号。</target>
        </trans-unit>
        <trans-unit id="e304f4d162cdd6b91149941db5a4861ae2782588" translate="yes" xml:space="preserve">
          <source>If you want to use other types as the key, make sure that you provide operator==() and a &lt;a href=&quot;qhash#qHashx&quot;&gt;qHash&lt;/a&gt;() implementation.</source>
          <target state="translated">如果要使用其他类型作为键，请确保提供operator ==（）和&lt;a href=&quot;qhash#qHashx&quot;&gt;qHash&lt;/a&gt;（）实现。</target>
        </trans-unit>
        <trans-unit id="6ccc476e76b0adc6832203cb021a00a392cecd37" translate="yes" xml:space="preserve">
          <source>If you want to use other types as the key, make sure that you provide operator==() and a &lt;a href=&quot;qhash#qHashx&quot;&gt;qHash&lt;/a&gt;() implementation. The convenience &lt;a href=&quot;qhash#qHashMulti&quot;&gt;qHashMulti&lt;/a&gt;() function can be used to implement &lt;a href=&quot;qhash#qHashx&quot;&gt;qHash&lt;/a&gt;() for a custom type, where one usually wants to produce a hash value from multiple fields:</source>
          <target state="translated">如果要使用其他类型作为键，请确保提供operator ==（）和&lt;a href=&quot;qhash#qHashx&quot;&gt;qHash&lt;/a&gt;（）实现。便利的&lt;a href=&quot;qhash#qHashMulti&quot;&gt;qHashMulti&lt;/a&gt;（）函数可用于为一种自定义类型实现&lt;a href=&quot;qhash#qHashx&quot;&gt;qHash&lt;/a&gt;（），在这种情况下，通常需要从多个字段中生成哈希值：</target>
        </trans-unit>
        <trans-unit id="3f6c5acd529fc7e81ee3f63f1eabc430a55977a4" translate="yes" xml:space="preserve">
          <source>If you want to use some dynamic libraries in the macOS application bundle (the application directory), create a subdirectory named</source>
          <target state="translated">如果你想在macOS应用程序包(应用程序目录)中使用一些动态库,请创建一个名为</target>
        </trans-unit>
        <trans-unit id="5e38a66accf5331c873d39eb454d16cdef463f6e" translate="yes" xml:space="preserve">
          <source>If you want to wake up a specific thread, the solution is typically to use different wait conditions and have different threads wait on different conditions.</source>
          <target state="translated">如果你想唤醒某个特定的线程,解决方案通常是使用不同的等待条件,让不同的线程在不同的条件下等待。</target>
        </trans-unit>
        <trans-unit id="e9846382b615d7c2d8abab6b96cbfaebf6b28668" translate="yes" xml:space="preserve">
          <source>If you want to write portably, you can use individual rules of the following form:</source>
          <target state="translated">如果你想进行移植式写作,可以使用以下形式的单独规则。</target>
        </trans-unit>
        <trans-unit id="1067ba1a8e8e88de78541f6de042b3358633a518" translate="yes" xml:space="preserve">
          <source>If you want your application to report errors to the user or to perform customized error handling, you should subclass this class.</source>
          <target state="translated">如果你想让你的应用程序向用户报告错误或执行自定义的错误处理,你应该子类这个类。</target>
        </trans-unit>
        <trans-unit id="4b269b734135e0af61e1e0e9f959a070ded81c32" translate="yes" xml:space="preserve">
          <source>If you wish to build the OCI plugin manually with this method, the procedure looks like this:</source>
          <target state="translated">如果你想用这种方法手动构建OCI插件,过程是这样的。</target>
        </trans-unit>
        <trans-unit id="a81b48ae699cf322716c07ff38971ce61e6d019e" translate="yes" xml:space="preserve">
          <source>If you wish to change any of the bounding rectangles calculated by the style or the painting of check box indicators, you can subclass &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt;. Note, however, that the size of the items can also be affected by reimplementing &lt;a href=&quot;qstyleditemdelegate#sizeHint&quot;&gt;sizeHint&lt;/a&gt;().</source>
          <target state="translated">如果要更改通过样式或复选框指示器的绘制计算出的任何边界矩形，可以将&lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt;子类化。但是请注意，重新实现&lt;a href=&quot;qstyleditemdelegate#sizeHint&quot;&gt;sizeHint&lt;/a&gt;（）也会影响项目的大小。</target>
        </trans-unit>
        <trans-unit id="243c44ef42200392a025ddde85473dedd9e40e54" translate="yes" xml:space="preserve">
          <source>If you wish to create an object without setting a parent, specify &lt;code&gt;null&lt;/code&gt; for the</source>
          <target state="translated">如果你想不设置父创建一个对象，指定 &lt;code&gt;null&lt;/code&gt; 的</target>
        </trans-unit>
        <trans-unit id="7fb97e146e5862a6a33947d92bf8771517ccdc13" translate="yes" xml:space="preserve">
          <source>If you wish to customize the painting of item views, you should implement a custom style. Please see the &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; class documentation for details.</source>
          <target state="translated">如果要自定义项目视图的绘画，则应实现自定义样式。有关详细信息，请参见&lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt;类文档。</target>
        </trans-unit>
        <trans-unit id="0a69ca08ab96c13641a6508b794546aec257c0fa" translate="yes" xml:space="preserve">
          <source>If you wish to declare a property to store a list of values which are not necessarily QML object-type values, you should declare a &lt;a href=&quot;qml-var&quot;&gt;var&lt;/a&gt; property instead.</source>
          <target state="translated">如果希望声明一个属性来存储值列表，这些值不一定是QML对象类型值，则应声明一个&lt;a href=&quot;qml-var&quot;&gt;var&lt;/a&gt;属性。</target>
        </trans-unit>
        <trans-unit id="a29175bb9c1cb3bbb036059c5f8bb1434c22ddb9" translate="yes" xml:space="preserve">
          <source>If you wish to have a command-line tool that does not use the GUI for example, &lt;code&gt;moc&lt;/code&gt;, &lt;code&gt;uic&lt;/code&gt; or &lt;code&gt;ls&lt;/code&gt;, you can tell qmake to disable bundle creation from the &lt;code&gt;CONFIG&lt;/code&gt; variable in the project file:</source>
          <target state="translated">如果希望使用不使用GUI的命令行工具，例如 &lt;code&gt;moc&lt;/code&gt; ， &lt;code&gt;uic&lt;/code&gt; 或 &lt;code&gt;ls&lt;/code&gt; ，则可以告诉qmake从项目文件中的 &lt;code&gt;CONFIG&lt;/code&gt; 变量禁用捆绑创建：</target>
        </trans-unit>
        <trans-unit id="e0b38ff477d19d2ca774b839b6974e90def6b73c" translate="yes" xml:space="preserve">
          <source>If you wish to introduce a delay between animations in a &lt;a href=&quot;qsequentialanimationgroup&quot;&gt;QSequentialAnimationGroup&lt;/a&gt;, you can insert a &lt;a href=&quot;qpauseanimation&quot;&gt;QPauseAnimation&lt;/a&gt;. This class does not animate anything, but does not &lt;a href=&quot;qabstractanimation#finished&quot;&gt;finish&lt;/a&gt; before a specified number of milliseconds have elapsed from when it was started. You specify the duration of the pause in the constructor. It can also be set directly with &lt;a href=&quot;qpauseanimation#duration-prop&quot;&gt;setDuration&lt;/a&gt;().</source>
          <target state="translated">如果希望在&lt;a href=&quot;qsequentialanimationgroup&quot;&gt;QSequentialAnimationGroup中的&lt;/a&gt;动画之间引入延迟，则可以插入&lt;a href=&quot;qpauseanimation&quot;&gt;QPauseAnimation&lt;/a&gt;。此类不会设置任何动画，但是在启动后经过指定的毫秒数之前不会&lt;a href=&quot;qabstractanimation#finished&quot;&gt;结束&lt;/a&gt;。您可以在构造函数中指定暂停的持续时间。也可以使用&lt;a href=&quot;qpauseanimation#duration-prop&quot;&gt;setDuration&lt;/a&gt;（）直接设置。</target>
        </trans-unit>
        <trans-unit id="04ae6f1a7617a095c9e9d93929995d5f54dabae0" translate="yes" xml:space="preserve">
          <source>If you wish to introduce a delay between animations in a &lt;a href=&quot;qsequentialanimationgroup&quot;&gt;QSequentialAnimationGroup&lt;/a&gt;, you can insert a QPauseAnimation. This class does not animate anything, but does not &lt;a href=&quot;qabstractanimation#finished&quot;&gt;finish&lt;/a&gt; before a specified number of milliseconds have elapsed from when it was started. You specify the duration of the pause in the constructor. It can also be set directly with &lt;a href=&quot;qpauseanimation#duration-prop&quot;&gt;setDuration&lt;/a&gt;().</source>
          <target state="translated">如果希望在&lt;a href=&quot;qsequentialanimationgroup&quot;&gt;QSequentialAnimationGroup中的&lt;/a&gt;动画之间引入延迟，则可以插入QPauseAnimation。此类不会设置任何动画，但是在启动后经过指定的毫秒数之前不会&lt;a href=&quot;qabstractanimation#finished&quot;&gt;完成&lt;/a&gt;动画处理。您可以在构造函数中指定暂停的持续时间。也可以使用&lt;a href=&quot;qpauseanimation#duration-prop&quot;&gt;setDuration&lt;/a&gt;（）直接设置。</target>
        </trans-unit>
        <trans-unit id="159d5838bcccb58b7af4b96b38caaf465a1b9c5d" translate="yes" xml:space="preserve">
          <source>If you wish to load an entire scene made of several objects, you should rather use the &lt;a href=&quot;qt3drender-qsceneloader&quot;&gt;Qt3DRender::QSceneLoader&lt;/a&gt; instead.</source>
          <target state="translated">如果要加载由多个对象组成的整个场景，则应改用&lt;a href=&quot;qt3drender-qsceneloader&quot;&gt;Qt3DRender :: QSceneLoader&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f84b7b6c5d543e62d3e7e0f79484d8066e3531f3" translate="yes" xml:space="preserve">
          <source>If you wish to make the context current in order to do clean-up, make sure to only connect to the signal using a direct connection.</source>
          <target state="translated">如果你想让上下文成为电流以便进行清理,请确保只使用直接连接来连接信号。</target>
        </trans-unit>
        <trans-unit id="e21582ab084164eddf1b291820920631b9959c06" translate="yes" xml:space="preserve">
          <source>If you wish to remove elements from a sequence rather than simply replace them with default constructed values, do not use the indexed delete operator (&quot;delete sequence[i]&quot;) but instead use the &lt;code&gt;splice&lt;/code&gt; function (&quot;sequence.splice(startIndex, deleteCount)&quot;).</source>
          <target state="translated">如果您希望从序列中删除元素，而不是简单地用默认构造的值替换它们，请不要使用索引的删除运算符（&amp;ldquo; delete sequence [i]&amp;rdquo;），而要使用 &lt;code&gt;splice&lt;/code&gt; 函数（&amp;ldquo; sequence.splice（startIndex，deleteCount） ）&amp;ldquo;）。</target>
        </trans-unit>
        <trans-unit id="0b4e499bc4c5986671c6ef5dbd86bfbbc1b58f7e" translate="yes" xml:space="preserve">
          <source>If you wish to reset the decoded format to that of the original audio file, you can specify an invalid</source>
          <target state="translated">如果您希望将解码格式重置为原始音频文件的格式,您可以指定一个无效的</target>
        </trans-unit>
        <trans-unit id="815e2bd5cf4e2b9061fda121d653346b3e929a30" translate="yes" xml:space="preserve">
          <source>If you wish to take advantage of the features provided by the model/view approach while still using an item-based interface, consider using view classes, such as &lt;a href=&quot;qlistview&quot;&gt;QListView&lt;/a&gt;, &lt;a href=&quot;qtableview&quot;&gt;QTableView&lt;/a&gt;, and &lt;a href=&quot;qtreeview&quot;&gt;QTreeView&lt;/a&gt; with &lt;a href=&quot;qstandarditemmodel&quot;&gt;QStandardItemModel&lt;/a&gt;.</source>
          <target state="translated">如果希望在仍然使用基于项目的接口的同时利用模型/视图方法提供的功能，请考虑将视图类（例如&lt;a href=&quot;qlistview&quot;&gt;QListView&lt;/a&gt;，&lt;a href=&quot;qtableview&quot;&gt;QTableView&lt;/a&gt;和&lt;a href=&quot;qtreeview&quot;&gt;QTreeView）&lt;/a&gt;与&lt;a href=&quot;qstandarditemmodel&quot;&gt;QStandardItemModel &lt;/a&gt;一起使用。</target>
        </trans-unit>
        <trans-unit id="8e1f06dfa8cd5f427a710f53d1541f65623bd15f" translate="yes" xml:space="preserve">
          <source>If you would like the application's contents to stay where they are when the drawer is opened, don't apply a translation.</source>
          <target state="translated">如果您希望应用程序的内容在抽屉打开时保持原样,请不要应用翻译。</target>
        </trans-unit>
        <trans-unit id="7e446879f3a6c39567356e2b8a5d47375a000288" translate="yes" xml:space="preserve">
          <source>If you would like to avoid automatic type detection and specify the type explicitly, call &lt;a href=&quot;qtextbrowser#setSource&quot;&gt;setSource&lt;/a&gt;() rather than setting this property.</source>
          <target state="translated">如果要避免自动类型检测并显式指定类型，请调用&lt;a href=&quot;qtextbrowser#setSource&quot;&gt;setSource&lt;/a&gt;（）而不是设置此属性。</target>
        </trans-unit>
        <trans-unit id="c8230a79340cd030d300061280fb08c720196a9e" translate="yes" xml:space="preserve">
          <source>If you would like to avoid automatic type detection and specify the type explicitly, call setSource() rather than setting this property.</source>
          <target state="translated">如果你想避免自动类型检测并明确指定类型,请调用setSource()而不是设置此属性。</target>
        </trans-unit>
        <trans-unit id="d913c5bfa651c86cfe9561db0fdfbd7bd0d1157f" translate="yes" xml:space="preserve">
          <source>If you would like to draw your own window decoration, you can set your own frame margins to override the default margins.</source>
          <target state="translated">如果你想绘制自己的窗口装饰,你可以设置自己的框架边距来覆盖默认边距。</target>
        </trans-unit>
        <trans-unit id="d1e57f6a403b9d00ba20ede07640d663f94d9bb2" translate="yes" xml:space="preserve">
          <source>If you would prefer that the font and palette propagate to child widgets, you can set the &lt;a href=&quot;qt#ApplicationAttribute-enum&quot;&gt;Qt::AA_UseStyleSheetPropagationInWidgetStyles&lt;/a&gt; flag, like this:</source>
          <target state="translated">如果您希望字体和调色板传播到子窗口小部件，则可以设置&lt;a href=&quot;qt#ApplicationAttribute-enum&quot;&gt;Qt :: AA_UseStyleSheetPropagationInWidgetStyles&lt;/a&gt;标志，如下所示：</target>
        </trans-unit>
        <trans-unit id="972ddea2508fd6833d6df718ba7d1b3bad696c8f" translate="yes" xml:space="preserve">
          <source>If you write your own widgets that have an option to set a small pixmap, consider allowing a &lt;a href=&quot;qicon&quot;&gt;QIcon&lt;/a&gt; to be set for that pixmap. The Qt class &lt;a href=&quot;qtoolbutton&quot;&gt;QToolButton&lt;/a&gt; is an example of such a widget.</source>
          <target state="translated">如果您编写自己的窗口小部件并具有设置小像素图的选项，请考虑允许为该像素图设置&lt;a href=&quot;qicon&quot;&gt;QIcon&lt;/a&gt;。Qt类&lt;a href=&quot;qtoolbutton&quot;&gt;QToolButton&lt;/a&gt;是此类小部件的示例。</target>
        </trans-unit>
        <trans-unit id="70ad39bd391f84b09b6f58ebfcc52a797283659a" translate="yes" xml:space="preserve">
          <source>If you write your own widgets that have an option to set a small pixmap, consider allowing a QIcon to be set for that pixmap. The Qt class &lt;a href=&quot;qtoolbutton&quot;&gt;QToolButton&lt;/a&gt; is an example of such a widget.</source>
          <target state="translated">如果您编写自己的窗口小部件并具有设置小像素图的选项，请考虑允许为该像素图设置QIcon。Qt类&lt;a href=&quot;qtoolbutton&quot;&gt;QToolButton&lt;/a&gt;是此类小部件的示例。</target>
        </trans-unit>
        <trans-unit id="daabc7cf04dec890de4a59eed0e93f81b14b18c1" translate="yes" xml:space="preserve">
          <source>If you're developing on a 64-bit Linux machine, you must install the following dependencies in order to run 32-bit executables like &lt;code&gt;adb&lt;/code&gt;, which allows Qt Creator to find devices to deploy to:</source>
          <target state="translated">如果您在64位Linux计算机上进行开发，则必须安装以下依赖项才能运行32位可执行文件（如 &lt;code&gt;adb&lt;/code&gt; )，该文件允许Qt Creator查找要部署到的设备：</target>
        </trans-unit>
        <trans-unit id="b0f9e77f326132cb99010f3b80c315e87cee86ae" translate="yes" xml:space="preserve">
          <source>If you're using &lt;a href=&quot;qqmlapplicationengine&quot;&gt;QQmlApplicationEngine&lt;/a&gt; and the value changes, &lt;a href=&quot;qqmlengine#retranslate&quot;&gt;QQmlEngine::retranslate()&lt;/a&gt; will be called.</source>
          <target state="translated">如果您使用的是&lt;a href=&quot;qqmlapplicationengine&quot;&gt;QQmlApplicationEngine&lt;/a&gt;，并且值更改，&lt;a href=&quot;qqmlengine#retranslate&quot;&gt;则将调用QQmlEngine :: retranslate（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="52ec66617c3f186edc12f8637d33a23d8270f0c2" translate="yes" xml:space="preserve">
          <source>If you're using &lt;a href=&quot;qtquickcontrols2-styles#compile-time-style-selection&quot;&gt;compile-time style selection&lt;/a&gt;, the qmldir should also import the fallback style:</source>
          <target state="translated">如果您使用的是&lt;a href=&quot;qtquickcontrols2-styles#compile-time-style-selection&quot;&gt;编译时样式选择&lt;/a&gt;，则qmldir也应导入后备样式：</target>
        </trans-unit>
        <trans-unit id="7291b8f5e7b74175825eec8a86f93115af0aa7c0" translate="yes" xml:space="preserve">
          <source>If you're using the same application (.so file) for activity and also for service, you need to use &lt;code&gt;android.app.arguments&lt;/code&gt;&lt;code&gt;meta-data&lt;/code&gt; to pass some arguments to your &lt;code&gt;main&lt;/code&gt; function in order to know which one is which.</source>
          <target state="translated">如果您使用同一应用程序（.so文件）进行活动和服务，则需要使用 &lt;code&gt;android.app.arguments&lt;/code&gt; &lt;code&gt;meta-data&lt;/code&gt; 将一些参数传递给 &lt;code&gt;main&lt;/code&gt; 函数，以便知道哪个是哪个。</target>
        </trans-unit>
        <trans-unit id="eb4e00a828abcf6435bc775c3c853cc29a3dfb89" translate="yes" xml:space="preserve">
          <source>If you're worried about namespace pollution, you can disable these macros by adding the following line to your &lt;code&gt;.pro&lt;/code&gt; file:</source>
          <target state="translated">如果您担心命名空间污染，可以通过在 &lt;code&gt;.pro&lt;/code&gt; 文件中添加以下行来禁用这些宏：</target>
        </trans-unit>
        <trans-unit id="6f24a1eec5e9c1e1ce83961a3e75273b1d21ddc2" translate="yes" xml:space="preserve">
          <source>If you're worried about namespace pollution, you can disable this macro by adding the following line to your &lt;code&gt;.pro&lt;/code&gt; file:</source>
          <target state="translated">如果您担心命名空间污染，可以通过在 &lt;code&gt;.pro&lt;/code&gt; 文件中添加以下行来禁用此宏：</target>
        </trans-unit>
        <trans-unit id="5d3ec4f946efef6b52c2be3199c8fd259d436ee8" translate="yes" xml:space="preserve">
          <source>If your &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; can return atomic value items of type &lt;code&gt;xs:QName&lt;/code&gt;, they will appear in your &lt;a href=&quot;qxmlresultitems&quot;&gt;QXmlResultItems&lt;/a&gt; as instances of &lt;a href=&quot;qxmlname&quot;&gt;QXmlName&lt;/a&gt;. Since the &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; class does not support the &lt;a href=&quot;qxmlname&quot;&gt;QXmlName&lt;/a&gt; class directly, extracting them from &lt;a href=&quot;qxmlresultitems&quot;&gt;QXmlResultItems&lt;/a&gt; requires a bit of slight-of-hand using the &lt;a href=&quot;qmetatype&quot;&gt;Qt metatype system&lt;/a&gt;. We must modify our example to use a couple of template functions, a friend of &lt;a href=&quot;qmetatype&quot;&gt;QMetaType&lt;/a&gt; (&lt;a href=&quot;qmetatype#qMetaTypeId&quot;&gt;qMetaTypeId&lt;/a&gt;&amp;lt;T&amp;gt;()) and a friend of &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; (&lt;a href=&quot;qvariant#qvariant_cast&quot;&gt;qvariant_cast&lt;/a&gt;&amp;lt;T&amp;gt;()):</source>
          <target state="translated">如果您的&lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt;可以返回类型为 &lt;code&gt;xs:QName&lt;/code&gt; 的原子值项目，则它们将作为&lt;a href=&quot;qxmlresultitems&quot;&gt;QXmlName的&lt;/a&gt;实例出现在&lt;a href=&quot;qxmlname&quot;&gt;QXmlResultItems中&lt;/a&gt;。由于&lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt;类不直接支持&lt;a href=&quot;qxmlname&quot;&gt;QXmlName&lt;/a&gt;类，因此使用&lt;a href=&quot;qmetatype&quot;&gt;Qt元类型系统&lt;/a&gt;从&lt;a href=&quot;qxmlresultitems&quot;&gt;QXmlResultItems中&lt;/a&gt;提取它们需要一些技巧。我们必须修改示例以使用几个模板函数，一个&lt;a href=&quot;qmetatype&quot;&gt;QMetaType&lt;/a&gt;的朋友（&lt;a href=&quot;qmetatype#qMetaTypeId&quot;&gt;qMetaTypeId&lt;/a&gt; &amp;lt;T&amp;gt;（））和一个&lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt;的朋友（&lt;a href=&quot;qvariant#qvariant_cast&quot;&gt;qvariant_cast&lt;/a&gt; &amp;lt;T&amp;gt;（））：</target>
        </trans-unit>
        <trans-unit id="d0b10c56ece24e57b4de992cfac85be3d5c33c4a" translate="yes" xml:space="preserve">
          <source>If your &lt;code&gt;Info.plist&lt;/code&gt; file contains an entry for &lt;code&gt;NSPhotoLibraryUsageDescription&lt;/code&gt;, qmake will automatically include an extra plugin which enables access to the native image picker. If the directory in your &lt;a href=&quot;qfiledialog&quot;&gt;QFileDialog&lt;/a&gt; is set to:</source>
          <target state="translated">如果您的 &lt;code&gt;Info.plist&lt;/code&gt; 文件包含 &lt;code&gt;NSPhotoLibraryUsageDescription&lt;/code&gt; 的条目，则qmake将自动包含一个额外的插件，该插件使您能够访问本机图像选择器。如果您的&lt;a href=&quot;qfiledialog&quot;&gt;QFileDialog中&lt;/a&gt;的目录设置为：</target>
        </trans-unit>
        <trans-unit id="612fb54a1db4926e1242c0e5627f6593e80562a3" translate="yes" xml:space="preserve">
          <source>If your Item uses the &lt;a href=&quot;qml-qtquick-behavior&quot;&gt;Behavior&lt;/a&gt; type to define animations for property changes, you should always use either &lt;a href=&quot;qobject#setProperty&quot;&gt;QObject::setProperty&lt;/a&gt;(), QQmlProperty(), or &lt;a href=&quot;qmetaproperty#write&quot;&gt;QMetaProperty::write&lt;/a&gt;() when you need to modify those properties from C++. This ensures that the QML engine knows about the property change. Otherwise, the engine won't be able to carry out your requested animation. Note that these functions incur a slight performance penalty. For more details, see &lt;a href=&quot;qtqml-cppintegration-interactqmlfromcpp#accessing-members-of-a-qml-object-type-from-c&quot;&gt;Accessing Members of a QML Object Type from C++&lt;/a&gt;.</source>
          <target state="translated">如果您的项目使用&amp;ldquo; &lt;a href=&quot;qml-qtquick-behavior&quot;&gt;行为&amp;rdquo;&lt;/a&gt;类型来定义属性更改的动画，则当需要从C ++修改这些属性时，应始终使用&lt;a href=&quot;qobject#setProperty&quot;&gt;QObject :: setProperty&lt;/a&gt;（），QQmlProperty（）或&lt;a href=&quot;qmetaproperty#write&quot;&gt;QMetaProperty :: write&lt;/a&gt;（）。这样可以确保QML引擎了解属性更改。否则，引擎将无法执行您请求的动画。请注意，这些功能会导致轻微的性能损失。有关更多详细信息，请参见&lt;a href=&quot;qtqml-cppintegration-interactqmlfromcpp#accessing-members-of-a-qml-object-type-from-c&quot;&gt;从C ++访问QML对象类型的成员&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="de85f7adb720be31015d2f53bdbdc47e962a6d98" translate="yes" xml:space="preserve">
          <source>If your OpenGL implementation supports the GL_EXT_texture_filter_anisotropic extension this function sets the maximum anisotropy level to</source>
          <target state="translated">如果你的OpenGL实现支持GL_EXT_texture_filter_anisotropic扩展,这个函数将最大的各向异性水平设置为</target>
        </trans-unit>
        <trans-unit id="e2646f4e473d40bdf4424a95af63654825817e99" translate="yes" xml:space="preserve">
          <source>If your QML type is defined in a</source>
          <target state="translated">如果你的QML类型被定义在</target>
        </trans-unit>
        <trans-unit id="f689dbad9e71c2662095aa7b027ce2241d810411" translate="yes" xml:space="preserve">
          <source>If your XQuery can return atomic value items of type &lt;code&gt;xs:QName&lt;/code&gt;, they will appear in your &lt;a href=&quot;qxmlresultitems&quot;&gt;QXmlResultItems&lt;/a&gt; as instances of &lt;a href=&quot;qxmlname&quot;&gt;QXmlName&lt;/a&gt;. Since the &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; class does not support the &lt;a href=&quot;qxmlname&quot;&gt;QXmlName&lt;/a&gt; class directly, extracting them from &lt;a href=&quot;qxmlresultitems&quot;&gt;QXmlResultItems&lt;/a&gt; requires a bit of slight-of-hand using the &lt;a href=&quot;qmetatype&quot;&gt;Qt metatype system&lt;/a&gt;. We must modify our example to use a couple of template functions, a friend of &lt;a href=&quot;qmetatype&quot;&gt;QMetaType&lt;/a&gt; (&lt;a href=&quot;qmetatype#qMetaTypeId&quot;&gt;qMetaTypeId&lt;/a&gt;&amp;lt;T&amp;gt;()) and a friend of &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; (&lt;a href=&quot;qvariant#qvariant_cast&quot;&gt;qvariant_cast&lt;/a&gt;&amp;lt;T&amp;gt;()):</source>
          <target state="translated">如果您的XQuery可以返回类型为 &lt;code&gt;xs:QName&lt;/code&gt; 的原子值项目，则它们将作为&lt;a href=&quot;qxmlresultitems&quot;&gt;QXmlName的&lt;/a&gt;实例出现在&lt;a href=&quot;qxmlname&quot;&gt;QXmlResultItems中&lt;/a&gt;。由于&lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt;类不直接支持&lt;a href=&quot;qxmlname&quot;&gt;QXmlName&lt;/a&gt;类，因此使用&lt;a href=&quot;qmetatype&quot;&gt;Qt元类型系统&lt;/a&gt;从&lt;a href=&quot;qxmlresultitems&quot;&gt;QXmlResultItems中&lt;/a&gt;提取它们需要一些技巧。我们必须修改示例以使用几个模板函数，一个&lt;a href=&quot;qmetatype&quot;&gt;QMetaType&lt;/a&gt;的朋友（&lt;a href=&quot;qmetatype#qMetaTypeId&quot;&gt;qMetaTypeId&lt;/a&gt; &amp;lt;T&amp;gt;（））和一个&lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt;的朋友（&lt;a href=&quot;qvariant#qvariant_cast&quot;&gt;qvariant_cast&lt;/a&gt; &amp;lt;T&amp;gt;（））：</target>
        </trans-unit>
        <trans-unit id="c33b6b405c4832e4a47175cade4878c811a12def" translate="yes" xml:space="preserve">
          <source>If your application consists of multiple views (for example, multiple tabs) but only one is required at any one time, you can use lazy instantiation to minimize the amount of memory you need to have allocated at any given time. See the prior section on &lt;a href=&quot;#lazy-initialization&quot;&gt;Lazy Initialization&lt;/a&gt; for more information.</source>
          <target state="translated">如果您的应用程序包含多个视图（例如，多个选项卡），但一次只需要一个视图，则可以使用延迟实例化来最小化在任何给定时间需要分配的内存量。有关更多信息，请参见上一节中的&amp;ldquo; &lt;a href=&quot;#lazy-initialization&quot;&gt;延迟初始化&lt;/a&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="680e6834a8553c2024765fd2b6fbbcf758f8891d" translate="yes" xml:space="preserve">
          <source>If your application consists of multiple views (for example, multiple tabs) but only one is required at any one time, you can use lazy instantiation to minimize the amount of memory you need to have allocated at any given time. See the prior section on &lt;a href=&quot;qtquick-performance#lazy-initialization&quot;&gt;Lazy Initialization&lt;/a&gt; for more information.</source>
          <target state="translated">如果您的应用程序包含多个视图（例如，多个选项卡），但在任何一次仅需要一个视图，则可以使用延迟实例化来最小化在任何给定时间需要分配的内存量。有关更多信息，请参见上一节中的&amp;ldquo;&lt;a href=&quot;qtquick-performance#lazy-initialization&quot;&gt;延迟初始化&lt;/a&gt;&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="f6f5700ed93aaf0ac491f9cb45ab94a73d11e831" translate="yes" xml:space="preserve">
          <source>If your application has unlockable products, and does not store the purchase states of these products in a way which makes it possible to restore them when the user reinstalls the application, you should provide a way for the user to restore the purchases manually.</source>
          <target state="translated">如果你的应用程序有可解锁的产品,并且没有将这些产品的购买状态存储在用户重新安装应用程序时可以恢复,你应该提供一种方法让用户手动恢复购买状态。</target>
        </trans-unit>
        <trans-unit id="d0175517087d7f87f877b49ec96ed43e9993e54b" translate="yes" xml:space="preserve">
          <source>If your application is very simple, it may be possible to store the entire application state in additional command line options. This is usually a very bad idea because command lines are often limited to a few hundred bytes. Instead, use &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt;, temporary files, or a database for this purpose. By marking the data with the unique &lt;a href=&quot;qsessionmanager#sessionId&quot;&gt;sessionId&lt;/a&gt;(), you will be able to restore the application in a future session.</source>
          <target state="translated">如果您的应用程序非常简单，则可以将整个应用程序状态存储在其他命令行选项中。这通常是一个非常糟糕的主意，因为命令行通常限制为几百个字节。而是使用&lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt;，临时文件或数据库来实现此目的。通过使用唯一的&lt;a href=&quot;qsessionmanager#sessionId&quot;&gt;sessionId&lt;/a&gt;（）标记数据，您将能够在以后的会话中还原该应用程序。</target>
        </trans-unit>
        <trans-unit id="00f996db434fbd4148cd3d64abf4c29be1ff38af" translate="yes" xml:space="preserve">
          <source>If your application loads a large image but displays it in a small-sized element, set the &quot;sourceSize&quot; property to the size of the element being rendered to ensure that the smaller-scaled version of the image is kept in memory, rather than the large one.</source>
          <target state="translated">如果您的应用程序加载了一张大图像,但在一个小尺寸的元素中显示它,则将 &quot;sourceSize &quot;属性设置为正在渲染的元素的尺寸,以确保在内存中保留较小比例的图像版本,而不是大图像。</target>
        </trans-unit>
        <trans-unit id="789639fdd37b60c698e7a10d7b66e854894f964d" translate="yes" xml:space="preserve">
          <source>If your application or library cannot be ported right now, the &lt;a href=&quot;qxmlsimplereader&quot;&gt;QXmlSimpleReader&lt;/a&gt; and related classes do still exist in Qt5Compat to keep old code-bases working. If you want to use those SAX classes further, you need to link against the new Qt5Compat module and add this line to your &lt;a href=&quot;qmake-manual&quot;&gt;qmake&lt;/a&gt;&lt;code&gt;.pro&lt;/code&gt; file:</source>
          <target state="translated">如果您现在无法移植您的应用程序或库，则&lt;a href=&quot;qxmlsimplereader&quot;&gt;Qt5Compat中&lt;/a&gt;仍然存在QXmlSimpleReader和相关类，以保持旧的代码库正常工作。如果要进一步使用那些SAX类，则需要链接到新的Qt5Compat模块，并将此行添加到&lt;a href=&quot;qmake-manual&quot;&gt;qmake &lt;/a&gt; &lt;code&gt;.pro&lt;/code&gt; 文件中：</target>
        </trans-unit>
        <trans-unit id="86f9b3e44da0ce922b11cc124e5a293028e87f8f" translate="yes" xml:space="preserve">
          <source>If your backend has already allocated a reading you should pass the address of this to the function. Otherwise you should pass 0 and the function will return the address of the reading your backend should use when it wants to notify the sensor API of new readings.</source>
          <target state="translated">如果您的后端已经分配了一个读数,您应该将其地址传递给函数。否则,您应该传递 0,当您的后端想要通知传感器 API 新读数时,该函数将返回您的后端应该使用的读数地址。</target>
        </trans-unit>
        <trans-unit id="8dad3ce2a056ce4e9de595ce577839ebdd7b32d3" translate="yes" xml:space="preserve">
          <source>If your compiler supports the C++11 standard, the three &lt;a href=&quot;qcommandlineparser#addOption&quot;&gt;addOption&lt;/a&gt;() calls in the above example can be simplified:</source>
          <target state="translated">如果您的编译器支持C ++ 11标准，则可以简化上述示例中的三个&lt;a href=&quot;qcommandlineparser#addOption&quot;&gt;addOption&lt;/a&gt;（）调用：</target>
        </trans-unit>
        <trans-unit id="c66f3be6bd529839255d9695af3e672dce04dbbb" translate="yes" xml:space="preserve">
          <source>If your effect changes, use &lt;a href=&quot;qgraphicseffect#update&quot;&gt;update&lt;/a&gt;() to request for a redraw. If your custom effect changes the bounding rectangle of the source, e.g., a radial glow effect may need to apply an extra margin, you can reimplement the virtual &lt;a href=&quot;qgraphicseffect#boundingRectFor&quot;&gt;boundingRectFor&lt;/a&gt;() function, and call &lt;a href=&quot;qgraphicseffect#updateBoundingRect&quot;&gt;updateBoundingRect&lt;/a&gt;() to notify the framework whenever this rectangle changes. The virtual &lt;a href=&quot;qgraphicseffect#sourceChanged&quot;&gt;sourceChanged&lt;/a&gt;() function is called to notify the effects that the source has changed in some way - e.g., if the source is a &lt;a href=&quot;qgraphicsrectitem&quot;&gt;QGraphicsRectItem&lt;/a&gt; and its rectangle parameters have changed.</source>
          <target state="translated">如果效果改变，请使用&lt;a href=&quot;qgraphicseffect#update&quot;&gt;update&lt;/a&gt;（）请求重画。如果您的自定义效果更改了源的边界矩形，例如，放射发光效果可能需要应用额外的边距，则可以重新实现虚拟&lt;a href=&quot;qgraphicseffect#boundingRectFor&quot;&gt;boundingRectFor&lt;/a&gt;（）函数，并在此矩形发生变化时调用&lt;a href=&quot;qgraphicseffect#updateBoundingRect&quot;&gt;updateBoundingRect&lt;/a&gt;（）来通知框架。调用virtual &lt;a href=&quot;qgraphicseffect#sourceChanged&quot;&gt;sourceChanged&lt;/a&gt;（）函数以通知效果该源已以某种方式更改-例如，如果该源是&lt;a href=&quot;qgraphicsrectitem&quot;&gt;QGraphicsRectItem&lt;/a&gt;并且其矩形参数已更改。</target>
        </trans-unit>
        <trans-unit id="8e482e3ad7cd2848c95b1c63b9a6a5f87d71a074" translate="yes" xml:space="preserve">
          <source>If your goal is orthogonal surveillance of eventpoints, an older alternative was &lt;a href=&quot;qobject#installEventFilter&quot;&gt;QObject::installEventFilter()&lt;/a&gt;, but that has never been a built-in &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-module.html&quot;&gt;QtQuick&lt;/a&gt; feature: it requires some C++ code, such as a &lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt; subclass. &lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;PointHandler&lt;/a&gt; is more efficient than that, because only pointer events will be delivered to it, during the course of normal event delivery in &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt;; whereas an event filter needs to filter all QEvents of all types, and thus sets itself up as a potential event delivery bottleneck.</source>
          <target state="translated">如果您的目标是对事件点进行正交监视，则较旧的替代方法是&lt;a href=&quot;qobject#installEventFilter&quot;&gt;QObject :: installEventFilter（）&lt;/a&gt;，但是它从来不是内置的&lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-module.html&quot;&gt;QtQuick&lt;/a&gt;功能：它需要一些C ++代码，例如&lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt;子类。&lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;PointHandler&lt;/a&gt;的效率更高，因为在&lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow中&lt;/a&gt;的常规事件传递过程中，仅将指针事件传递给它。事件过滤器需要过滤所有类型的所有QEvent，因此将其自身设置为潜在的事件传递瓶颈。</target>
        </trans-unit>
        <trans-unit id="d2d390363a28518c722d80f4572c890904320dea" translate="yes" xml:space="preserve">
          <source>If your goal is orthogonal surveillance of eventpoints, an older alternative was &lt;a href=&quot;qobject#installEventFilter&quot;&gt;QObject::installEventFilter()&lt;/a&gt;, but that has never been a built-in &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtquick-module.html&quot;&gt;QtQuick&lt;/a&gt; feature: it requires some C++ code, such as a &lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt; subclass. PointHandler is more efficient than that, because only pointer events will be delivered to it, during the course of normal event delivery in &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt;; whereas an event filter needs to filter all QEvents of all types, and thus sets itself up as a potential event delivery bottleneck.</source>
          <target state="translated">如果您的目标是对事件点进行正交监视，则较旧的替代方法是&lt;a href=&quot;qobject#installEventFilter&quot;&gt;QObject :: installEventFilter（）&lt;/a&gt;，但是它从来不是内置的&lt;a href=&quot;https://doc.qt.io/qt-5.15/qtquick-module.html&quot;&gt;QtQuick&lt;/a&gt;功能：它需要一些C ++代码，例如&lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt;子类。PointHandler的效率更高，因为在&lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow中&lt;/a&gt;的常规事件传递过程中，仅将指针事件传递给它。事件过滤器需要过滤所有类型的所有QEvent，因此将其自身设置为潜在的事件传递瓶颈。</target>
        </trans-unit>
        <trans-unit id="41324db23b7962f67a307c3d550f8530fd67c3b2" translate="yes" xml:space="preserve">
          <source>If your goal is orthogonal surveillance of eventpoints, an older alternative was &lt;a href=&quot;qobject#installEventFilter&quot;&gt;QObject::installEventFilter()&lt;/a&gt;, but that has never been a built-in &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtquick-module.html&quot;&gt;QtQuick&lt;/a&gt; feature: it requires some C++ code, such as a &lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt; subclass. PointHandler is more efficient than that, because only pointer events will be delivered to it, during the course of normal event delivery in &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt;; whereas an event filter needs to filter all QEvents of all types, and thus sets itself up as a potential event delivery bottleneck.</source>
          <target state="translated">如果您的目标是对事件点进行正交监视，则较旧的替代方法是&lt;a href=&quot;qobject#installEventFilter&quot;&gt;QObject :: installEventFilter（）&lt;/a&gt;，但是它从来不是内置的&lt;a href=&quot;https://doc.qt.io/qt-6.0/qtquick-module.html&quot;&gt;QtQuick&lt;/a&gt;功能：它需要一些C ++代码，例如&lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt;子类。PointHandler的效率更高，因为在&lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow中&lt;/a&gt;的常规事件传递过程中，仅将指针事件传递给它。事件过滤器需要过滤所有类型的所有QEvent，因此将其自身设置为潜在的事件传递瓶颈。</target>
        </trans-unit>
        <trans-unit id="b6f54b2f4fa96edac6ea810d92d44a2ecacd96aa" translate="yes" xml:space="preserve">
          <source>If your item is displayed in several areas then visualRect should return the primary area that contains index and not the complete area that index might encompasses, touch or cause drawing.</source>
          <target state="translated">如果你的项目是显示在几个区域,那么visualRect应该返回包含索引的主要区域,而不是索引可能包含的完整区域,触摸或导致绘制。</target>
        </trans-unit>
        <trans-unit id="72c337b2451ed3b8885c5abc8d5400ec57e41dc3" translate="yes" xml:space="preserve">
          <source>If your model is sortable, i.e, if it reimplements the &lt;a href=&quot;qabstractitemmodel#sort&quot;&gt;QAbstractItemModel::sort&lt;/a&gt;() function, both &lt;a href=&quot;qtableview&quot;&gt;QTableView&lt;/a&gt; and &lt;a href=&quot;qtreeview&quot;&gt;QTreeView&lt;/a&gt; provide an API that allows you to sort your model data programmatically. In addition, you can enable interactive sorting (i.e. allowing the users to sort the data by clicking the view's headers), by connecting the &lt;a href=&quot;qheaderview#sortIndicatorChanged&quot;&gt;QHeaderView::sortIndicatorChanged&lt;/a&gt;() signal to the &lt;a href=&quot;qtableview#sortByColumn&quot;&gt;QTableView::sortByColumn&lt;/a&gt;() slot or the &lt;a href=&quot;qtreeview#sortByColumn&quot;&gt;QTreeView::sortByColumn&lt;/a&gt;() slot, respectively.</source>
          <target state="translated">如果您的模型是可排序的，即，如果重新实现了&lt;a href=&quot;qabstractitemmodel#sort&quot;&gt;QAbstractItemModel :: sort&lt;/a&gt;（）函数，则&lt;a href=&quot;qtableview&quot;&gt;QTableView&lt;/a&gt;和&lt;a href=&quot;qtreeview&quot;&gt;QTreeView都将&lt;/a&gt;提供一个API，该API允许您以编程方式对模型数据进行排序。另外，通过将&lt;a href=&quot;qheaderview#sortIndicatorChanged&quot;&gt;QHeaderView :: sortIndicatorChanged&lt;/a&gt;（）信号连接到&lt;a href=&quot;qtableview#sortByColumn&quot;&gt;QTableView :: sortByColumn&lt;/a&gt;（）插槽或&lt;a href=&quot;qtreeview#sortByColumn&quot;&gt;QTreeView :: sortByColumn&lt;/a&gt;（ ）插槽。</target>
        </trans-unit>
        <trans-unit id="6f98e8b5d221b3e2e8a7a394a8d830a40068ddc9" translate="yes" xml:space="preserve">
          <source>If your model is used within QML and requires roles other than the default ones provided by the &lt;a href=&quot;qabstractitemmodel#roleNames&quot;&gt;roleNames&lt;/a&gt;() function, you must override it.</source>
          <target state="translated">如果您的模型在QML中使用，并且需要除&lt;a href=&quot;qabstractitemmodel#roleNames&quot;&gt;roleNames&lt;/a&gt;（）函数提供的默认角色以外的其他角色，则必须覆盖它。</target>
        </trans-unit>
        <trans-unit id="ffe3a904b6a83fdb84f5b0761b6b0cb7bd178c42" translate="yes" xml:space="preserve">
          <source>If your project has custom &lt;code&gt;CMake&lt;/code&gt; build configurations, you have to map your custom configuration to either the debug or the release Qt configuration.</source>
          <target state="translated">如果您的项目具有自定义 &lt;code&gt;CMake&lt;/code&gt; 构建配置，则必须将自定义配置映射到调试或发布Qt配置。</target>
        </trans-unit>
        <trans-unit id="c32e9f4943a6c23b62d891ccf355dae1b1293bb3" translate="yes" xml:space="preserve">
          <source>If your project has custom CMake build configurations, it may be necessary to set a mapping from your custom configuration to either the debug or release Qt configuration.</source>
          <target state="translated">如果你的项目有自定义的 CMake 构建配置,可能需要从你的自定义配置到调试或发布 Qt 配置设置一个映射。</target>
        </trans-unit>
        <trans-unit id="a412b7fbd30159b9499635e4236b0aa30262e5ff" translate="yes" xml:space="preserve">
          <source>If your project is a</source>
          <target state="translated">如果您的项目是一个</target>
        </trans-unit>
        <trans-unit id="45ce7ce9273e622183118d4a8028a97f4b77a7d5" translate="yes" xml:space="preserve">
          <source>If your reimplementation of &lt;a href=&quot;qabstractitemmodel#fetchMore&quot;&gt;fetchMore()&lt;/a&gt; adds rows to the model, you need to call &lt;a href=&quot;qabstractitemmodel#beginInsertRows&quot;&gt;beginInsertRows()&lt;/a&gt; and &lt;a href=&quot;qabstractitemmodel#endInsertRows&quot;&gt;endInsertRows()&lt;/a&gt;. Also, both &lt;a href=&quot;qabstractitemmodel#canFetchMore&quot;&gt;canFetchMore()&lt;/a&gt; and &lt;a href=&quot;qabstractitemmodel#fetchMore&quot;&gt;fetchMore()&lt;/a&gt; must be reimplemented as their default implementation returns false and does nothing.</source>
          <target state="translated">如果重新实现&lt;a href=&quot;qabstractitemmodel#fetchMore&quot;&gt;fetchMore（）&lt;/a&gt;将行添加到模型中，则需要调用&lt;a href=&quot;qabstractitemmodel#beginInsertRows&quot;&gt;beginInsertRows（）&lt;/a&gt;和&lt;a href=&quot;qabstractitemmodel#endInsertRows&quot;&gt;endInsertRows（）&lt;/a&gt;。另外，必须重新实现&lt;a href=&quot;qabstractitemmodel#canFetchMore&quot;&gt;canFetchMore（）&lt;/a&gt;和&lt;a href=&quot;qabstractitemmodel#fetchMore&quot;&gt;fetchMore（），&lt;/a&gt;因为它们的默认实现返回false并且不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="6058b6b4398293fb98ebb9b0df37b61e7de26d54" translate="yes" xml:space="preserve">
          <source>If your test case needs QML imports, then you can add them as &lt;code&gt;-import&lt;/code&gt; options to the test program command-line.</source>
          <target state="translated">如果您的测试用例需要QML导入，则可以将它们作为 &lt;code&gt;-import&lt;/code&gt; 选项添加到测试程序命令行中。</target>
        </trans-unit>
        <trans-unit id="47af96af8e00c193855c890bc0707a860e54d143" translate="yes" xml:space="preserve">
          <source>If your widget only contains child widgets, you probably do not need to implement any event handlers. If you want to detect a mouse click in a child widget call the child's &lt;a href=&quot;qwidget#underMouse&quot;&gt;underMouse&lt;/a&gt;() function inside the widget's &lt;a href=&quot;qwidget#mousePressEvent&quot;&gt;mousePressEvent&lt;/a&gt;().</source>
          <target state="translated">如果您的窗口小部件仅包含子窗口小部件，则可能不需要实现任何事件处理程序。如果要检测一个孩子鼠标点击小工具叫孩子的&lt;a href=&quot;qwidget#underMouse&quot;&gt;underMouse&lt;/a&gt;小部件的（）函数中&lt;a href=&quot;qwidget#mousePressEvent&quot;&gt;mousePressEvent&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="002ed8bdc649a7b2b45d46f1414f126b970d97c9" translate="yes" xml:space="preserve">
          <source>If, at a later time, the replica's node gets notified that the requested source is available from a connected node, at that point it will request the source and start the initialization process.</source>
          <target state="translated">如果在以后的时间里,副本的节点得到通知,请求的源可以从连接的节点获得,这时它将请求源并开始初始化过程。</target>
        </trans-unit>
        <trans-unit id="efb98d3c8757c13c00568dad7341a60498040025" translate="yes" xml:space="preserve">
          <source>If, at a later time, the replica's node gets notified that the requested source is available from a connected node, it will at that point request the source and start the initialization process.</source>
          <target state="translated">如果在以后的时间里,副本的节点得到通知,请求的源可以从连接的节点获得,它将在此时请求源并开始初始化过程。</target>
        </trans-unit>
        <trans-unit id="fe7b1ce59b4e0aa5b6b2c140336559a9b5893b11" translate="yes" xml:space="preserve">
          <source>If, for example, the OpenGL polygon mode is changed by the user inside a beginNativePaint()/&lt;a href=&quot;qpainter#endNativePainting&quot;&gt;endNativePainting&lt;/a&gt;() block, it will not be reset to the default state by &lt;a href=&quot;qpainter#endNativePainting&quot;&gt;endNativePainting&lt;/a&gt;(). Here is an example that shows intermixing of painter commands and raw OpenGL commands:</source>
          <target state="translated">如果，例如，OpenGL的多边形模式由用户beginNativePaint（）/内改变&lt;a href=&quot;qpainter#endNativePainting&quot;&gt;endNativePainting&lt;/a&gt;（）块中，它不会被重置为默认状态由&lt;a href=&quot;qpainter#endNativePainting&quot;&gt;endNativePainting&lt;/a&gt;（）。这是显示画家命令和原始OpenGL命令的混合的示例：</target>
        </trans-unit>
        <trans-unit id="f4b93ae87fadd21a13fe26a4b1b7229793967d06" translate="yes" xml:space="preserve">
          <source>If, for instance, you want to connect to a server that uses a self-signed certificate, consider the following snippet:</source>
          <target state="translated">例如,如果你想连接到一个使用自签名证书的服务器,请考虑以下代码段。</target>
        </trans-unit>
        <trans-unit id="a21a10cc6baa8fc7709ded12402fb06e21bc2e8d" translate="yes" xml:space="preserve">
          <source>If, within the document's directory, there is a &lt;code&gt;dummydata&lt;/code&gt; directory which contains a &lt;code&gt;lottoNumbers.qml&lt;/code&gt; file like this:</source>
          <target state="translated">如果在文档目录中存在一个 &lt;code&gt;dummydata&lt;/code&gt; 目录，其中包含如下的 &lt;code&gt;lottoNumbers.qml&lt;/code&gt; 文件：</target>
        </trans-unit>
        <trans-unit id="deb76489f9b5200ca7f43df75295b472c27ddb2f" translate="yes" xml:space="preserve">
          <source>Ignore any Unicode byte-order mark and don't generate any.</source>
          <target state="translated">忽略任何Unicode字节顺序标记,不产生任何标记。</target>
        </trans-unit>
        <trans-unit id="8b89e0c0fc34677d43ff0d0ac2650038d7cee304" translate="yes" xml:space="preserve">
          <source>Ignore any implicit or explicit &lt;code&gt;-nograb&lt;/code&gt;. &lt;code&gt;-dograb&lt;/code&gt; wins over &lt;code&gt;-nograb&lt;/code&gt; even when &lt;code&gt;-nograb&lt;/code&gt; is last on the command line.</source>
          <target state="translated">忽略任何隐式或显式 &lt;code&gt;-nograb&lt;/code&gt; 。 &lt;code&gt;-dograb&lt;/code&gt; 胜过 &lt;code&gt;-nograb&lt;/code&gt; ,即使 &lt;code&gt;-nograb&lt;/code&gt; 在命令行上最后一次也是如此。</target>
        </trans-unit>
        <trans-unit id="5f1886462ca23c26b64e8191a9497ba505fc1d9d" translate="yes" xml:space="preserve">
          <source>Ignore possible converter states between different function calls to encode or decode strings. This will also cause the &lt;a href=&quot;qstringconverter&quot;&gt;QStringConverter&lt;/a&gt; to raise an error if an incomplete sequence of data is encountered.</source>
          <target state="translated">忽略不同函数调用之间可能的转换器状态，以对字符串进行编码或解码。如果遇到不完整的数据序列，这还将导致&lt;a href=&quot;qstringconverter&quot;&gt;QStringConverter&lt;/a&gt;引发错误。</target>
        </trans-unit>
        <trans-unit id="a2ff2565c03de3852a8466f2d4f2afb8bf1ceb3d" translate="yes" xml:space="preserve">
          <source>Ignore the action (do nothing with the data).</source>
          <target state="translated">忽略该动作(不对数据做任何处理)。</target>
        </trans-unit>
        <trans-unit id="f8d389bf9f10dd7ee0995def4b935f1728b59794" translate="yes" xml:space="preserve">
          <source>Ignore the layout item rect from the style when laying out this widget with &lt;a href=&quot;qlayout&quot;&gt;QLayout&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;qlayout&quot;&gt;QLayout&lt;/a&gt;布局此小部件时，忽略样式中的布局项rect 。</target>
        </trans-unit>
        <trans-unit id="d6dc167c9331f258371c27b269795d215b36d8f6" translate="yes" xml:space="preserve">
          <source>Ignores a navigation request.</source>
          <target state="translated">忽略导航请求。</target>
        </trans-unit>
        <trans-unit id="3b5991af665588b7019909a6819ff7f96fea5b14" translate="yes" xml:space="preserve">
          <source>Ignores messages created by &lt;a href=&quot;#qDebug&quot;&gt;qDebug&lt;/a&gt;(), &lt;a href=&quot;#qInfo&quot;&gt;qInfo&lt;/a&gt;() or &lt;a href=&quot;#qWarning&quot;&gt;qWarning&lt;/a&gt;(). If the</source>
          <target state="translated">忽略由&lt;a href=&quot;#qDebug&quot;&gt;qDebug&lt;/a&gt;（），&lt;a href=&quot;#qInfo&quot;&gt;qInfo&lt;/a&gt;（）或&lt;a href=&quot;#qWarning&quot;&gt;qWarning&lt;/a&gt;（）创建的消息。如果</target>
        </trans-unit>
        <trans-unit id="9a4ab3fd8e773e1c5a4c036f3e06e781ad87d7e7" translate="yes" xml:space="preserve">
          <source>Ignores messages created by &lt;a href=&quot;#qDebug&quot;&gt;qDebug&lt;/a&gt;(), &lt;a href=&quot;#qInfo&quot;&gt;qInfo&lt;/a&gt;() or &lt;a href=&quot;#qWarning&quot;&gt;qWarning&lt;/a&gt;(). If the message matching</source>
          <target state="translated">忽略由&lt;a href=&quot;#qDebug&quot;&gt;qDebug&lt;/a&gt;（），&lt;a href=&quot;#qInfo&quot;&gt;qInfo&lt;/a&gt;（）或&lt;a href=&quot;#qWarning&quot;&gt;qWarning&lt;/a&gt;（）创建的消息。如果消息匹配</target>
        </trans-unit>
        <trans-unit id="e7f2bd8be166f44d0879eae36e26b698ee16bb3c" translate="yes" xml:space="preserve">
          <source>Ignores messages created by &lt;a href=&quot;qtglobal#qDebug&quot;&gt;qDebug&lt;/a&gt;(), &lt;a href=&quot;qtglobal#qInfo&quot;&gt;qInfo&lt;/a&gt;() or &lt;a href=&quot;qtglobal#qWarning&quot;&gt;qWarning&lt;/a&gt;(). If the</source>
          <target state="translated">忽略由&lt;a href=&quot;qtglobal#qDebug&quot;&gt;qDebug&lt;/a&gt;（），&lt;a href=&quot;qtglobal#qInfo&quot;&gt;qInfo&lt;/a&gt;（）或&lt;a href=&quot;qtglobal#qWarning&quot;&gt;qWarning&lt;/a&gt;（）创建的消息。如果</target>
        </trans-unit>
        <trans-unit id="78eed9534d6e7b81d1fbaa75e10d0bb068ad70ca" translate="yes" xml:space="preserve">
          <source>Ignores messages created by &lt;a href=&quot;qtglobal#qDebug&quot;&gt;qDebug&lt;/a&gt;(), &lt;a href=&quot;qtglobal#qInfo&quot;&gt;qInfo&lt;/a&gt;() or &lt;a href=&quot;qtglobal#qWarning&quot;&gt;qWarning&lt;/a&gt;(). If the message matching</source>
          <target state="translated">忽略由&lt;a href=&quot;qtglobal#qDebug&quot;&gt;qDebug&lt;/a&gt;（），&lt;a href=&quot;qtglobal#qInfo&quot;&gt;qInfo&lt;/a&gt;（）或&lt;a href=&quot;qtglobal#qWarning&quot;&gt;qWarning&lt;/a&gt;（）创建的消息。如果消息匹配</target>
        </trans-unit>
        <trans-unit id="e08e09459cd53c1cf2831f9b645d01d7895f8178" translate="yes" xml:space="preserve">
          <source>Ignores the certificate error and continues the loading of the requested URL.</source>
          <target state="translated">忽略证书错误,继续加载请求的URL。</target>
        </trans-unit>
        <trans-unit id="c7b42c5e8793c4e11f5b0d98e83629eed9b662e4" translate="yes" xml:space="preserve">
          <source>Illegal</source>
          <target state="translated">Illegal</target>
        </trans-unit>
        <trans-unit id="1ae48c552e312029e7dd471fc7df5778829c9500" translate="yes" xml:space="preserve">
          <source>Illustrator</source>
          <target state="translated">Illustrator</target>
        </trans-unit>
        <trans-unit id="50e19fda0d5b4b74a4a1a1d584e56578693a4ea4" translate="yes" xml:space="preserve">
          <source>Image</source>
          <target state="translated">Image</target>
        </trans-unit>
        <trans-unit id="694a7d34908dab879c97aaa1a20efc15273c8f9a" translate="yes" xml:space="preserve">
          <source>Image (QML type)</source>
          <target state="translated">图像(QML类型)</target>
        </trans-unit>
        <trans-unit id="79437dd7e3b6791d059634682f61cbf70ef60de0" translate="yes" xml:space="preserve">
          <source>Image Caching</source>
          <target state="translated">图像缓存</target>
        </trans-unit>
        <trans-unit id="435ed9e69df99cb4a2651c265421f92dd8dbdb74" translate="yes" xml:space="preserve">
          <source>Image Composition Example</source>
          <target state="translated">图像构成实例</target>
        </trans-unit>
        <trans-unit id="9c804e7e28cc6e5f7931d50ba6b994cd4bb2c59f" translate="yes" xml:space="preserve">
          <source>Image Elements</source>
          <target state="translated">图像元素</target>
        </trans-unit>
        <trans-unit id="c8f6654a5156a1080fb81d03686a08b3810bb836" translate="yes" xml:space="preserve">
          <source>Image Formats</source>
          <target state="translated">图像格式</target>
        </trans-unit>
        <trans-unit id="020c26033d73e6845fa697166de8d81a0273c034" translate="yes" xml:space="preserve">
          <source>Image Information</source>
          <target state="translated">图像信息</target>
        </trans-unit>
        <trans-unit id="095667f1fcd46b132e81c4336dd2b0f23e1bc404" translate="yes" xml:space="preserve">
          <source>Image Loading</source>
          <target state="translated">图片加载</target>
        </trans-unit>
        <trans-unit id="887e15fde467a33abf575d3973eec9f31b0f6acb" translate="yes" xml:space="preserve">
          <source>Image QML Type</source>
          <target state="translated">图像QML类型</target>
        </trans-unit>
        <trans-unit id="3e3c60bcc53ebc1195757e000b7e24211c1032cb" translate="yes" xml:space="preserve">
          <source>Image Transformations</source>
          <target state="translated">图像转换</target>
        </trans-unit>
        <trans-unit id="c93acc3a97633745105d6cc43cef0f3052324c7f" translate="yes" xml:space="preserve">
          <source>Image and video attributes</source>
          <target state="translated">图像和视频属性</target>
        </trans-unit>
        <trans-unit id="bd515d467966171b1b569cab3ad8c383dd82ba0b" translate="yes" xml:space="preserve">
          <source>Image based lighting</source>
          <target state="translated">基于图像的照明</target>
        </trans-unit>
        <trans-unit id="3f39d743789b43f0e5ded023f5634754a7d8a59f" translate="yes" xml:space="preserve">
          <source>Image based lighting, light probes, skybox</source>
          <target state="translated">基于图像的照明、光探针、天箱。</target>
        </trans-unit>
        <trans-unit id="25ec2cd54333ae10dd0843f128a4c45de34a9e42" translate="yes" xml:space="preserve">
          <source>Image brightness adjustment.</source>
          <target state="translated">图像亮度调整。</target>
        </trans-unit>
        <trans-unit id="95492d385542f3f54bea997ef816e6a4e12be9bd" translate="yes" xml:space="preserve">
          <source>Image brightness adjustment. Valid brightness adjustment values range between -1.0 and 1.0, with a default of 0.</source>
          <target state="translated">图像亮度调整。有效的亮度调整值范围在-1.0和1.0之间,默认为0。</target>
        </trans-unit>
        <trans-unit id="91707570630a91e9bff1ec54c38a0d9ec324c4f3" translate="yes" xml:space="preserve">
          <source>Image brightness.</source>
          <target state="translated">图像亮度。</target>
        </trans-unit>
        <trans-unit id="6ddeef6f06f0a2b4b7ad6dfce532c37fc3e01e43" translate="yes" xml:space="preserve">
          <source>Image can handle any image format supported by Qt, loaded from any URL scheme supported by Qt.</source>
          <target state="translated">图像可以处理Qt支持的任何图像格式,从Qt支持的任何URL方案加载。</target>
        </trans-unit>
        <trans-unit id="a4208d4bbe29c2555b678741b5e94f5d75dc6684" translate="yes" xml:space="preserve">
          <source>Image contrast adjustment.</source>
          <target state="translated">图像对比度调整。</target>
        </trans-unit>
        <trans-unit id="73ac3b48d87bc88c249b538d2fac1bc8580d9661" translate="yes" xml:space="preserve">
          <source>Image contrast adjustment. Valid contrast adjustment values range between -1.0 and 1.0, with a default of 0.</source>
          <target state="translated">图像对比度调整。有效的对比度调整值范围在-1.0和1.0之间,默认值为0。</target>
        </trans-unit>
        <trans-unit id="ac31afc4738a10181084968969c4aef9c2fd6306" translate="yes" xml:space="preserve">
          <source>Image contrast.</source>
          <target state="translated">对比图像。</target>
        </trans-unit>
        <trans-unit id="3a16d66fc7fdc6f10674e5ea84911fc345ac8e2b" translate="yes" xml:space="preserve">
          <source>Image effects that attempt to find where things look bad and sweep the problems under the carpet.</source>
          <target state="translated">试图找到事情看起来不好的地方,把问题扫到地毯下的图像效果。</target>
        </trans-unit>
        <trans-unit id="69570f5a7752afa94ff2d8813e24aef45221acbd" translate="yes" xml:space="preserve">
          <source>Image elements with the &quot;asynchronous&quot; property set to &lt;code&gt;true&lt;/code&gt; will load images in a low-priority worker thread.</source>
          <target state="translated">将&amp;ldquo; asynchronous&amp;rdquo;属性设置为 &lt;code&gt;true&lt;/code&gt; 的图像元素将在低优先级工作线程中加载图像。</target>
        </trans-unit>
        <trans-unit id="9877178fec8f6b4da1432c696f45a4f0e551354a" translate="yes" xml:space="preserve">
          <source>Image encoder settings are changed, including resolution.</source>
          <target state="translated">更改图像编码器设置,包括分辨率。</target>
        </trans-unit>
        <trans-unit id="f3186d67ab09b9326a4f6f94f91614f075fb8d75" translate="yes" xml:space="preserve">
          <source>Image file for the &lt;code&gt;iconic&lt;/code&gt; tile template icon. Default provided by the mkspec.</source>
          <target state="translated">&lt;code&gt;iconic&lt;/code&gt; 平铺模板图标的图像文件。mkspec提供的默认值。</target>
        </trans-unit>
        <trans-unit id="275322b6c0dd9dbb459aac968ddec77ea63c6f97" translate="yes" xml:space="preserve">
          <source>Image file for the small &lt;code&gt;iconic&lt;/code&gt; tile template logo. Default provided by the mkspec.</source>
          <target state="translated">小 &lt;code&gt;iconic&lt;/code&gt; 平铺模板徽标的图像文件。mkspec提供的默认值。</target>
        </trans-unit>
        <trans-unit id="8b1b3e79d8e6deef1a97d6db9e0d8cf8a4856822" translate="yes" xml:space="preserve">
          <source>Image filter applied. Since 5.5</source>
          <target state="translated">应用图像过滤器。从5.5开始</target>
        </trans-unit>
        <trans-unit id="9bfe13d3bb7d52f768d03527bc5e63b414117605" translate="yes" xml:space="preserve">
          <source>Image formats that support animation return true for this value in &lt;a href=&quot;qimageiohandler#supportsOption&quot;&gt;supportsOption&lt;/a&gt;(); otherwise, false is returned.</source>
          <target state="translated">支持动画的图像格式在&lt;a href=&quot;qimageiohandler#supportsOption&quot;&gt;supportsOption&lt;/a&gt;（）中对此值返回true 。否则，返回false。</target>
        </trans-unit>
        <trans-unit id="e962ce20336f0d46a9be4c9caaed139b713a25df" translate="yes" xml:space="preserve">
          <source>Image formats that support different saving variants should return a list of supported variant names (&lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt;&amp;lt;&lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt;&amp;gt;) in this option.</source>
          <target state="translated">支持不同保存变体的图像格式应在此选项中返回支持的变体名称列表（&lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; &amp;lt; &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; &amp;gt;）。</target>
        </trans-unit>
        <trans-unit id="6e8f891038fc55e95d7ba0adc5e0d8152f2b87dd" translate="yes" xml:space="preserve">
          <source>Image plugins are queried first, based on either the optional format string, or the file name suffix (if the source device is a file). No content detection is done at this stage. &lt;a href=&quot;qimagereader&quot;&gt;QImageReader&lt;/a&gt; will choose the first plugin that supports reading for this format.</source>
          <target state="translated">首先根据可选格式字符串或文件名后缀（如果源设备是文件）查询图像插件。在此阶段不进行任何内容检测。&lt;a href=&quot;qimagereader&quot;&gt;QImageReader&lt;/a&gt;将选择第一个支持此格式读取的插件。</target>
        </trans-unit>
        <trans-unit id="237651054978b2d4b607041a12a5a4d8fcf34177" translate="yes" xml:space="preserve">
          <source>Image properties</source>
          <target state="translated">图像属性</target>
        </trans-unit>
        <trans-unit id="fb6c2609830118b9111385555fc0bbdd0e3256c4" translate="yes" xml:space="preserve">
          <source>Image providers enable support for pixmap and threaded image requests. See the &lt;a href=&quot;qquickimageprovider&quot;&gt;QQuickImageProvider&lt;/a&gt; documentation for details on implementing and using image providers.</source>
          <target state="translated">图像提供程序支持对像素图和线程图像请求的支持。有关实现和使用图像提供程序的详细信息，请参见&lt;a href=&quot;qquickimageprovider&quot;&gt;QQuickImageProvider&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="29d0591bf7c64915c032bdc01a04093207a8c33e" translate="yes" xml:space="preserve">
          <source>Image providers must be registered with the QML engine. The only information the QML engine knows about image providers is the type of image data they provide. To use an image provider to acquire image data, you must cast the &lt;a href=&quot;qqmlimageproviderbase&quot;&gt;QQmlImageProviderBase&lt;/a&gt; pointer to a &lt;a href=&quot;qquickimageprovider&quot;&gt;QQuickImageProvider&lt;/a&gt; pointer.</source>
          <target state="translated">图像提供程序必须在QML引擎中注册。 QML引擎唯一了解图像提供程序的信息是它们提供的图像数据的类型。要使用图像提供程序获取图像数据，必须将&lt;a href=&quot;qqmlimageproviderbase&quot;&gt;QQmlImageProviderBase&lt;/a&gt;指针转换为&lt;a href=&quot;qquickimageprovider&quot;&gt;QQuickImageProvider&lt;/a&gt;指针。</target>
        </trans-unit>
        <trans-unit id="f81738afc2d6552913ac248592f8f2c95b66363a" translate="yes" xml:space="preserve">
          <source>Image providers must be registered with the QML engine. The only information the QML engine knows about image providers is the type of image data they provide. To use an image provider to acquire image data, you must cast the QQmlImageProviderBase pointer to a &lt;a href=&quot;qquickimageprovider&quot;&gt;QQuickImageProvider&lt;/a&gt; pointer.</source>
          <target state="translated">图像提供程序必须在QML引擎中注册。QML引擎唯一了解图像提供者的信息是它们提供的图像数据的类型。要使用图像提供程序获取图像数据，必须将QQmlImageProviderBase指针转换为&lt;a href=&quot;qquickimageprovider&quot;&gt;QQuickImageProvider&lt;/a&gt;指针。</target>
        </trans-unit>
        <trans-unit id="763422616dfc1429eb1f64c5051d9b1e3d20eae6" translate="yes" xml:space="preserve">
          <source>Image providers that support &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; or Texture loading automatically include support for asychronous loading of images. To enable asynchronous loading for an image source, set the &lt;code&gt;asynchronous&lt;/code&gt; property to &lt;code&gt;true&lt;/code&gt; for the relevant &lt;a href=&quot;qqmlimageproviderbase#ImageType-enum&quot;&gt;Image&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-borderimage&quot;&gt;BorderImage&lt;/a&gt; object. When this is enabled, the image request to the provider is run in a low priority thread, allowing image loading to be executed in the background, and reducing the performance impact on the user interface.</source>
          <target state="translated">自动支持&lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt;或Texture加载的图像提供程序包括对图像的异步加载的支持。要为图像源启用异步加载，请将相关&lt;a href=&quot;qqmlimageproviderbase#ImageType-enum&quot;&gt;Image&lt;/a&gt;或&lt;a href=&quot;qml-qtquick-borderimage&quot;&gt;BorderImage&lt;/a&gt;对象的 &lt;code&gt;asynchronous&lt;/code&gt; 属性设置为 &lt;code&gt;true&lt;/code&gt; 。启用此功能后，将在低优先级线程中运行对提供程序的图像请求，从而允许在后台执行图像加载，并减少对用户界面的性能影响。</target>
        </trans-unit>
        <trans-unit id="e6f8d7e518013a08d011ed13bfea81eaebdb6afc" translate="yes" xml:space="preserve">
          <source>Image providers that support &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; or Texture loading automatically include support for asychronous loading of images. To enable asynchronous loading for an image source, set the &lt;code&gt;asynchronous&lt;/code&gt; property to &lt;code&gt;true&lt;/code&gt; for the relevant &lt;a href=&quot;qqmlimageproviderbase#ImageType-enum&quot;&gt;Image&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-borderimage&quot;&gt;BorderImage&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-animatedimage&quot;&gt;AnimatedImage&lt;/a&gt; object. When this is enabled, the image request to the provider is run in a low priority thread, allowing image loading to be executed in the background, and reducing the performance impact on the user interface.</source>
          <target state="translated">自动支持&lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt;或Texture加载的图像提供程序包括对图像的异步加载的支持。要为图像源启用异步加载，请将相关&lt;a href=&quot;qqmlimageproviderbase#ImageType-enum&quot;&gt;Image&lt;/a&gt;，&lt;a href=&quot;qml-qtquick-borderimage&quot;&gt;BorderImage&lt;/a&gt;或&lt;a href=&quot;qml-qtquick-animatedimage&quot;&gt;AnimatedImage&lt;/a&gt;对象的 &lt;code&gt;asynchronous&lt;/code&gt; 属性设置为 &lt;code&gt;true&lt;/code&gt; 。启用此功能后，将在低优先级线程中运行对提供程序的图像请求，从而允许在后台执行图像加载，并减少对用户界面的性能影响。</target>
        </trans-unit>
        <trans-unit id="3af7ea35d9fde4a078ea166b03f499ec47abe29b" translate="yes" xml:space="preserve">
          <source>Image saturation adjustment.</source>
          <target state="translated">图像饱和度调整。</target>
        </trans-unit>
        <trans-unit id="3e65e85a090fb6e7477d5a3b1e7a2855a1326e06" translate="yes" xml:space="preserve">
          <source>Image saturation adjustment. Valid saturation adjustment values range between -1.0 and 1.0, the default is 0.</source>
          <target state="translated">图像饱和度调整。有效的饱和度调整值范围在-1.0和1.0之间,默认为0。</target>
        </trans-unit>
        <trans-unit id="bca26e88da3a7eee962836f0c298ce3b8db42011" translate="yes" xml:space="preserve">
          <source>Image saturation.</source>
          <target state="translated">图像饱和度。</target>
        </trans-unit>
        <trans-unit id="e647c8bdaf024656c516f69d0984a9f533dcc14c" translate="yes" xml:space="preserve">
          <source>Image will only be read and written into from shaders</source>
          <target state="translated">图像只能从着色器中读取和写入。</target>
        </trans-unit>
        <trans-unit id="5d8c0d00e5aa5672cfb5ad8d1d03fa5b65a49ded" translate="yes" xml:space="preserve">
          <source>Image will only be read from in shaders</source>
          <target state="translated">图像只能从着色器中读取。</target>
        </trans-unit>
        <trans-unit id="21c28ca99512e3a1fc878440ad464846e2aa6275" translate="yes" xml:space="preserve">
          <source>Image will only be written into from shaders</source>
          <target state="translated">图像只能从着色器中写入。</target>
        </trans-unit>
        <trans-unit id="928b6c38c5c6ad5bc05175c8228da1b877e6d347" translate="yes" xml:space="preserve">
          <source>Image.Error - an error occurred while loading the image</source>
          <target state="translated">Image.Error-加载图像时发生错误。</target>
        </trans-unit>
        <trans-unit id="fdd798ed25fabe589c67ede96b0e7a5218283256" translate="yes" xml:space="preserve">
          <source>Image.Loading - the image is currently being loaded</source>
          <target state="translated">Image.Loading-当前正在加载图片。</target>
        </trans-unit>
        <trans-unit id="3ec8d7682cb58d6c6e548c37d5ae72911a9f4210" translate="yes" xml:space="preserve">
          <source>Image.Null - no image has been set</source>
          <target state="translated">Image.Null-没有设置图像。</target>
        </trans-unit>
        <trans-unit id="dcd8cd6d001a04bf784a8b8dc1c97305a40b6b39" translate="yes" xml:space="preserve">
          <source>Image.Pad - the image is not transformed</source>
          <target state="translated">Image.Pad-图像没有被转换。</target>
        </trans-unit>
        <trans-unit id="996dcd45b334e04253024ca0f51f128ebb8843f1" translate="yes" xml:space="preserve">
          <source>Image.PreserveAspectCrop - the image is scaled uniformly to fill, cropping if necessary</source>
          <target state="translated">Image.PreserveAspectCrop-统一缩放图像以填充,必要时进行裁剪。</target>
        </trans-unit>
        <trans-unit id="456737d85a7affa731fda32cfd5344db5ea6b05c" translate="yes" xml:space="preserve">
          <source>Image.PreserveAspectFit - the image is scaled uniformly to fit without cropping</source>
          <target state="translated">Image.PreserveAspectFit-统一缩放图像,以适应不裁剪。</target>
        </trans-unit>
        <trans-unit id="d5a9b4d7ee83a91af7204802450523ae3c12e4f6" translate="yes" xml:space="preserve">
          <source>Image.Ready - the image has been loaded</source>
          <target state="translated">Image.Ready-图像已被加载</target>
        </trans-unit>
        <trans-unit id="3aebc538730d04d2a802dd11d430b80029a039ef" translate="yes" xml:space="preserve">
          <source>Image.Stretch - the image is scaled to fit</source>
          <target state="translated">Image.Stretch-缩放图像以适应。</target>
        </trans-unit>
        <trans-unit id="5866c887415282ccbe6ecdb3c5e22dad6029cf00" translate="yes" xml:space="preserve">
          <source>Image.Tile - the image is duplicated horizontally and vertically</source>
          <target state="translated">Image.Tile-图像在水平和垂直方向上被复制。</target>
        </trans-unit>
        <trans-unit id="6f9e2edb98f895ab18ccc4111c4efe4e41867eda" translate="yes" xml:space="preserve">
          <source>Image.TileHorizontally - the image is stretched vertically and tiled horizontally</source>
          <target state="translated">Image.TileHorizontally-图像被垂直拉伸并水平铺设。</target>
        </trans-unit>
        <trans-unit id="391b47aa3cd271a9daddeda34eaf2b6aa3d626c1" translate="yes" xml:space="preserve">
          <source>Image.TileVertically - the image is stretched horizontally and tiled vertically</source>
          <target state="translated">Image.TileVertically-图像被水平拉伸并垂直平铺。</target>
        </trans-unit>
        <trans-unit id="d6c38eebab4996faca39a61387f11734014ed745" translate="yes" xml:space="preserve">
          <source>Image.asynchronous</source>
          <target state="translated">Image.asynchronous</target>
        </trans-unit>
        <trans-unit id="ee13e88cc2d8429bd0e84569058745f8aaeb1a93" translate="yes" xml:space="preserve">
          <source>Image.autoTransform</source>
          <target state="translated">Image.autoTransform</target>
        </trans-unit>
        <trans-unit id="b0377717d7941893302faaf81814ed98ea2d7622" translate="yes" xml:space="preserve">
          <source>Image.cache</source>
          <target state="translated">Image.cache</target>
        </trans-unit>
        <trans-unit id="976615648c6069d39f479406ac7fe94eefde58ba" translate="yes" xml:space="preserve">
          <source>Image.currentFrame</source>
          <target state="translated">Image.currentFrame</target>
        </trans-unit>
        <trans-unit id="ab1255ca30a91f3cd25ab0e57ec660b4f5ecfeb4" translate="yes" xml:space="preserve">
          <source>Image.fillMode</source>
          <target state="translated">Image.fillMode</target>
        </trans-unit>
        <trans-unit id="ad573f968adee6878ec85a4abdaedccb5d6fa928" translate="yes" xml:space="preserve">
          <source>Image.horizontalAlignment</source>
          <target state="translated">Image.horizontalAlignment</target>
        </trans-unit>
        <trans-unit id="1facf1f35ca5349ae3b9ea70dd19c2ea04ac9b44" translate="yes" xml:space="preserve">
          <source>Image.mipmap</source>
          <target state="translated">Image.mipmap</target>
        </trans-unit>
        <trans-unit id="0e8cc6db33bc3c4ab271c7b726e57fb977391405" translate="yes" xml:space="preserve">
          <source>Image.mirror</source>
          <target state="translated">Image.mirror</target>
        </trans-unit>
        <trans-unit id="d0160a133716871758abf8e18e7936bb925a16ea" translate="yes" xml:space="preserve">
          <source>Image.paintedHeight</source>
          <target state="translated">Image.paintedHeight</target>
        </trans-unit>
        <trans-unit id="3b25ae29fc4d55eec7943b7ec5a498c62dcd74ff" translate="yes" xml:space="preserve">
          <source>Image.paintedWidth</source>
          <target state="translated">Image.paintedWidth</target>
        </trans-unit>
        <trans-unit id="de87aa3185b24ad1493103a100803dbb270c22b3" translate="yes" xml:space="preserve">
          <source>Image.progress</source>
          <target state="translated">Image.progress</target>
        </trans-unit>
        <trans-unit id="688db74617785d8792fd6dac0163d86491e68bf3" translate="yes" xml:space="preserve">
          <source>Image.smooth</source>
          <target state="translated">Image.smooth</target>
        </trans-unit>
        <trans-unit id="74321de2400f60219e4a107097684edb50af5a62" translate="yes" xml:space="preserve">
          <source>Image.source</source>
          <target state="translated">Image.source</target>
        </trans-unit>
        <trans-unit id="b55da9515d0b6ac8b36cc30be85a2a29d8926405" translate="yes" xml:space="preserve">
          <source>Image.sourceClipRect</source>
          <target state="translated">Image.sourceClipRect</target>
        </trans-unit>
        <trans-unit id="22ec86da187637e16793239f1f24227b28641cfd" translate="yes" xml:space="preserve">
          <source>Image.sourceSize</source>
          <target state="translated">Image.sourceSize</target>
        </trans-unit>
        <trans-unit id="3f0569c61b23bcc39889a1c5b87594abd2006728" translate="yes" xml:space="preserve">
          <source>Image.status</source>
          <target state="translated">Image.status</target>
        </trans-unit>
        <trans-unit id="c85483e061fb2550c5c3fa4c24fe316d19f82a74" translate="yes" xml:space="preserve">
          <source>ImageModel</source>
          <target state="translated">ImageModel</target>
        </trans-unit>
        <trans-unit id="c4bf499ce91167a244a40e33b3c5af2789d5fb0e" translate="yes" xml:space="preserve">
          <source>ImageModel (QML type)</source>
          <target state="translated">ImageModel (QML类型)</target>
        </trans-unit>
        <trans-unit id="59950b3e811ed99a9c914e2377bb67082275677f" translate="yes" xml:space="preserve">
          <source>ImageModel QML Type</source>
          <target state="translated">ImageModel QML类型</target>
        </trans-unit>
        <trans-unit id="aa559d902bbdfc074fc54e03683a47d9a68b0824" translate="yes" xml:space="preserve">
          <source>ImageModel.batchSize</source>
          <target state="translated">ImageModel.batchSize</target>
        </trans-unit>
        <trans-unit id="525461577fa14892f5e57d06e765998397832861" translate="yes" xml:space="preserve">
          <source>ImageModel.place</source>
          <target state="translated">ImageModel.place</target>
        </trans-unit>
        <trans-unit id="5019ba7443c773767aa6c273471e05caaea7efc1" translate="yes" xml:space="preserve">
          <source>ImageModel.totalCount</source>
          <target state="translated">ImageModel.totalCount</target>
        </trans-unit>
        <trans-unit id="c65cc34f2b07c05b2eed7123e24715503cca6a44" translate="yes" xml:space="preserve">
          <source>ImageParticle (QML type)</source>
          <target state="translated">ImageParticle (QML类型)</target>
        </trans-unit>
        <trans-unit id="22edc8f820fa657012f9afa99e3a0b8cafda3b91" translate="yes" xml:space="preserve">
          <source>ImageParticle QML Type</source>
          <target state="translated">ImageParticle QML类型</target>
        </trans-unit>
        <trans-unit id="2917331d3411d102098484d743240448fd34b97c" translate="yes" xml:space="preserve">
          <source>ImageParticle.alpha</source>
          <target state="translated">ImageParticle.alpha</target>
        </trans-unit>
        <trans-unit id="6cee5f1d50f09fc8f54ebd7a9367d1fd37b32cb1" translate="yes" xml:space="preserve">
          <source>ImageParticle.alphaVariation</source>
          <target state="translated">ImageParticle.alphaVariation</target>
        </trans-unit>
        <trans-unit id="a4e470c1f71bc70e2279d8b3b598887935f5683c" translate="yes" xml:space="preserve">
          <source>ImageParticle.autoRotation</source>
          <target state="translated">ImageParticle.autoRotation</target>
        </trans-unit>
        <trans-unit id="a94096d1c04919e35ed6abae4e9b770db2929035" translate="yes" xml:space="preserve">
          <source>ImageParticle.blueVariation</source>
          <target state="translated">ImageParticle.blueVariation</target>
        </trans-unit>
        <trans-unit id="99face9f1d2ee034dc7db9ff5d893245bc80bc8a" translate="yes" xml:space="preserve">
          <source>ImageParticle.color</source>
          <target state="translated">ImageParticle.color</target>
        </trans-unit>
        <trans-unit id="5ac102a43502def25e562873808fff18c7dce6f6" translate="yes" xml:space="preserve">
          <source>ImageParticle.colorTable</source>
          <target state="translated">ImageParticle.colorTable</target>
        </trans-unit>
        <trans-unit id="de229a30611ee4126745b75c2f4c677fb5b5847f" translate="yes" xml:space="preserve">
          <source>ImageParticle.colorVariation</source>
          <target state="translated">ImageParticle.colorVariation</target>
        </trans-unit>
        <trans-unit id="32a1d00b0c127f972c64016e56f284b4b6586bab" translate="yes" xml:space="preserve">
          <source>ImageParticle.entryEffect</source>
          <target state="translated">ImageParticle.entryEffect</target>
        </trans-unit>
        <trans-unit id="8ef54b955256c3e37fd5e3248ea107e1d234a749" translate="yes" xml:space="preserve">
          <source>ImageParticle.greenVariation</source>
          <target state="translated">ImageParticle.greenVariation</target>
        </trans-unit>
        <trans-unit id="660663b76e8f0edd070c8dc402599cba2603fa02" translate="yes" xml:space="preserve">
          <source>ImageParticle.opacityTable</source>
          <target state="translated">ImageParticle.opacityTable</target>
        </trans-unit>
        <trans-unit id="46db9a819d23ee76024933e7e57aa8ad2b527073" translate="yes" xml:space="preserve">
          <source>ImageParticle.redVariation</source>
          <target state="translated">ImageParticle.redVariation</target>
        </trans-unit>
        <trans-unit id="6633a6167fdf4a9062ef69bef27baf23a07249b3" translate="yes" xml:space="preserve">
          <source>ImageParticle.rotation</source>
          <target state="translated">ImageParticle.rotation</target>
        </trans-unit>
        <trans-unit id="668326488a064a3831192c97955baf88fd5cad18" translate="yes" xml:space="preserve">
          <source>ImageParticle.rotationVariation</source>
          <target state="translated">ImageParticle.rotationVariation</target>
        </trans-unit>
        <trans-unit id="13761192c94b70a0be32d6de5f07bb97c31d881d" translate="yes" xml:space="preserve">
          <source>ImageParticle.rotationVelocity</source>
          <target state="translated">ImageParticle.rotationVelocity</target>
        </trans-unit>
        <trans-unit id="26cf47b403b85871d3581bd5b23a297a0792e037" translate="yes" xml:space="preserve">
          <source>ImageParticle.rotationVelocityVariation</source>
          <target state="translated">ImageParticle.rotationVelocityVariation</target>
        </trans-unit>
        <trans-unit id="aa323ab2f7070ad7aaae17d04dacc88506528698" translate="yes" xml:space="preserve">
          <source>ImageParticle.sizeTable</source>
          <target state="translated">ImageParticle.sizeTable</target>
        </trans-unit>
        <trans-unit id="6352315790977a0a3e8476798ad5523a06670dfd" translate="yes" xml:space="preserve">
          <source>ImageParticle.source</source>
          <target state="translated">ImageParticle.source</target>
        </trans-unit>
        <trans-unit id="e53ab5f234349a98cd73f3443109ae3e9daf3710" translate="yes" xml:space="preserve">
          <source>ImageParticle.sprites</source>
          <target state="translated">ImageParticle.sprites</target>
        </trans-unit>
        <trans-unit id="33111124e4f659aafd87ca47db056e4060fd0cdf" translate="yes" xml:space="preserve">
          <source>ImageParticle.spritesInterpolate</source>
          <target state="translated">ImageParticle.spritesInterpolate</target>
        </trans-unit>
        <trans-unit id="95ef25e59a5efd4f664decc85ebb47b4ea273947" translate="yes" xml:space="preserve">
          <source>ImageParticle.status</source>
          <target state="translated">ImageParticle.status</target>
        </trans-unit>
        <trans-unit id="ce1f3bf01950470667d3b7925b9cfbdcf6f4b67d" translate="yes" xml:space="preserve">
          <source>ImageParticle.xVector</source>
          <target state="translated">ImageParticle.xVector</target>
        </trans-unit>
        <trans-unit id="ed72047b8155e46dc8f331b19b6568184e79c36a" translate="yes" xml:space="preserve">
          <source>ImageParticle.yVector</source>
          <target state="translated">ImageParticle.yVector</target>
        </trans-unit>
        <trans-unit id="acc969ec26a9fa09a95ee15e89ed5069dcd1f620" translate="yes" xml:space="preserve">
          <source>ImageParticles implictly share data on particles if multiple ImageParticles are painting the same logical particle group. This is broken down along the four capabilities listed above. So if one &lt;a href=&quot;qml-qtquick-particles-imageparticle&quot;&gt;ImageParticle&lt;/a&gt; defines data for rendering the particles in one of those capabilities, and the other does not, then both will draw the particles the same in that aspect automatically. This is primarily useful when there is some random variation on the particle which is supposed to stay with it when switching painters. If both ImageParticles define how they should appear for that aspect, they diverge and each appears as it is defined.</source>
          <target state="translated">如果多个ImageParticle绘制相同的逻辑粒子组，则ImageParticle隐式共享粒子上的数据。这按上面列出的四个功能细分。因此，如果一个&lt;a href=&quot;qml-qtquick-particles-imageparticle&quot;&gt;ImageParticle&lt;/a&gt;定义了用于使用这些功能之一渲染粒子的数据，而另一项却没有，则两者都会自动在该方面绘制相同的粒子。当切换画家时，如果粒子上存在一些随机变化（应该保留在粒子上），这将非常有用。如果两个ImageParticle都定义了它们在该方面的显示方式，则它们会发散，并且每个都按定义出现。</target>
        </trans-unit>
        <trans-unit id="eb205da20d56a8fa0526f26b278fe9b0ac0f89ce" translate="yes" xml:space="preserve">
          <source>ImageParticles implictly share data on particles if multiple ImageParticles are painting the same logical particle group. This is broken down along the four capabilities listed above. So if one ImageParticle defines data for rendering the particles in one of those capabilities, and the other does not, then both will draw the particles the same in that aspect automatically. This is primarily useful when there is some random variation on the particle which is supposed to stay with it when switching painters. If both ImageParticles define how they should appear for that aspect, they diverge and each appears as it is defined.</source>
          <target state="translated">如果多个ImageParticles在绘制同一个逻辑粒子组,ImageParticles就会牵连共享粒子的数据。这沿着上面列出的四种能力进行细分。所以,如果一个ImageParticle在其中一个能力中定义了渲染粒子的数据,而另一个没有定义,那么两者将在该方面自动绘制相同的粒子。这主要是在粒子上有一些随机变化时很有用,而这些变化在切换画师时应该会一直存在。如果两个ImageParticles都定义了它们在那个方面应该如何出现,那么它们就会出现分歧,各自按照定义的方式出现。</target>
        </trans-unit>
        <trans-unit id="09e871c98fef3b901a775def173e4126aaf73b42" translate="yes" xml:space="preserve">
          <source>Images</source>
          <target state="translated">Images</target>
        </trans-unit>
        <trans-unit id="9bba00ba7cfbf846512e4b84315d6e44095836f5" translate="yes" xml:space="preserve">
          <source>Images are a vital part of any user interface. Unfortunately, they are also a big source of problems due to the time it takes to load them, the amount of memory they consume, and the way in which they are used.</source>
          <target state="translated">图片是任何用户界面的重要组成部分。不幸的是,由于加载图片所需的时间、占用的内存以及使用图片的方式,图片也是问题的一大来源。</target>
        </trans-unit>
        <trans-unit id="a734ad37e2d1f31fec162317151529307cd631ea" translate="yes" xml:space="preserve">
          <source>Images are cached and shared internally, so if several Image items have the same &lt;a href=&quot;qml-qtquick-image#source-prop&quot;&gt;source&lt;/a&gt;, only one copy of the image will be loaded.</source>
          <target state="translated">图像在内部进行缓存和共享，因此，如果多个Image项具有相同的&lt;a href=&quot;qml-qtquick-image#source-prop&quot;&gt;来源&lt;/a&gt;，则只会加载该图像的一个副本。</target>
        </trans-unit>
        <trans-unit id="1c5c0421bf41e3a0987ed37803b634b987e386ef" translate="yes" xml:space="preserve">
          <source>Images are often quite large, and so it is wise to ensure that loading an image doesn't block the UI thread. Set the &quot;asynchronous&quot; property of the QML Image element to &lt;code&gt;true&lt;/code&gt; to enable asynchronous loading of images from the local file system (remote images are always loaded asynchronously) where this would not result in a negative impact upon the aesthetics of the user interface.</source>
          <target state="translated">图片通常很大，因此明智的做法是确保加载图片不会阻塞UI线程。将QML Image元素的&amp;ldquo; a​​synchronous&amp;rdquo;属性设置为 &lt;code&gt;true&lt;/code&gt; ,以允许从本地文件系统异步加载图像（远程图像始终异步加载），这不会对用户界面的美观产生负面影响。</target>
        </trans-unit>
        <trans-unit id="f09ebb2d58c3eafe46a2586752de4caa7ca959c5" translate="yes" xml:space="preserve">
          <source>Images can be supplied in any format for which Qt has an image reader, so SVG drawings can be included alongside PNG, TIFF and other bitmap formats.</source>
          <target state="translated">图像可以以Qt有图像阅读器的任何格式提供,因此SVG图可以与PNG、TIFF和其他位图格式一起包含。</target>
        </trans-unit>
        <trans-unit id="bd391d8013e9e2002aff23680c469ff1379c7172" translate="yes" xml:space="preserve">
          <source>Images in &lt;a href=&quot;qtextdocument&quot;&gt;QTextDocument&lt;/a&gt; are represented by text fragments that reference external images via the resource mechanism. Images are created using the cursor interface, and can be modified later by changing the character format of the image's text fragment:</source>
          <target state="translated">在图像&lt;a href=&quot;qtextdocument&quot;&gt;另外，QTextDocument&lt;/a&gt;是由经由资源机构引用外部图像文本片段表示。图像是使用光标界面创建的，以后可以通过更改图像文本片段的字符格式进行修改：</target>
        </trans-unit>
        <trans-unit id="1403bc6b73053c035d7035ed1d07b43737448bbc" translate="yes" xml:space="preserve">
          <source>Images returned by a &lt;a href=&quot;qquickimageprovider&quot;&gt;QQuickImageProvider&lt;/a&gt; are automatically cached, similar to any image loaded by the QML engine. When an image with a &quot;image://&quot; prefix is loaded from cache, &lt;a href=&quot;qquickimageprovider#requestImage&quot;&gt;requestImage&lt;/a&gt;() and &lt;a href=&quot;qquickimageprovider#requestPixmap&quot;&gt;requestPixmap&lt;/a&gt;() will not be called for the relevant image provider. If an image should always be fetched from the image provider, and should not be cached at all, set the &lt;code&gt;cache&lt;/code&gt; property to &lt;code&gt;false&lt;/code&gt; for the relevant &lt;a href=&quot;qqmlimageproviderbase#ImageType-enum&quot;&gt;Image&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-borderimage&quot;&gt;BorderImage&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-animatedimage&quot;&gt;AnimatedImage&lt;/a&gt; object.</source>
          <target state="translated">由&lt;a href=&quot;qquickimageprovider&quot;&gt;QQuickImageProvider&lt;/a&gt;返回的图像将被自动缓存，类似于QML引擎加载的任何图像。当从缓存中加载带有&amp;ldquo; image：//&amp;rdquo;前缀的图像时，相关图像提供者将不会调用&lt;a href=&quot;qquickimageprovider#requestImage&quot;&gt;requestImage&lt;/a&gt;（）和&lt;a href=&quot;qquickimageprovider#requestPixmap&quot;&gt;requestPixmap&lt;/a&gt;（）。如果应该始终从图像提供者获取图像，并且根本不应该对其进行缓存，则将相关&lt;a href=&quot;qqmlimageproviderbase#ImageType-enum&quot;&gt;Image&lt;/a&gt;，&lt;a href=&quot;qml-qtquick-borderimage&quot;&gt;BorderImage&lt;/a&gt;或&lt;a href=&quot;qml-qtquick-animatedimage&quot;&gt;AnimatedImage&lt;/a&gt;对象的 &lt;code&gt;cache&lt;/code&gt; 属性设置为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e8a7f7783030ea6c5e2cb60481633f66a4f34ba9" translate="yes" xml:space="preserve">
          <source>Images returned by a QQuickImageProvider are automatically cached, similar to any image loaded by the QML engine. When an image with a &quot;image://&quot; prefix is loaded from cache, &lt;a href=&quot;qquickimageprovider#requestImage&quot;&gt;requestImage&lt;/a&gt;() and &lt;a href=&quot;qquickimageprovider#requestPixmap&quot;&gt;requestPixmap&lt;/a&gt;() will not be called for the relevant image provider. If an image should always be fetched from the image provider, and should not be cached at all, set the &lt;code&gt;cache&lt;/code&gt; property to &lt;code&gt;false&lt;/code&gt; for the relevant &lt;a href=&quot;qqmlimageproviderbase#ImageType-enum&quot;&gt;Image&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-borderimage&quot;&gt;BorderImage&lt;/a&gt; object.</source>
          <target state="translated">由QQuickImageProvider返回的图像将被自动缓存，类似于QML引擎加载的任何图像。当从缓存中加载带有&amp;ldquo; image：//&amp;rdquo;前缀的图像时，相关图像提供者将不会调用&lt;a href=&quot;qquickimageprovider#requestImage&quot;&gt;requestImage&lt;/a&gt;（）和&lt;a href=&quot;qquickimageprovider#requestPixmap&quot;&gt;requestPixmap&lt;/a&gt;（）。如果应该始终从图像提供者获取图像，并且根本不应该对其进行缓存，则将相关&lt;a href=&quot;qqmlimageproviderbase#ImageType-enum&quot;&gt;Image&lt;/a&gt;或&lt;a href=&quot;qml-qtquick-borderimage&quot;&gt;BorderImage&lt;/a&gt;对象的 &lt;code&gt;cache&lt;/code&gt; 属性设置为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="98054ab5470e957311b5d94c8723f2b9b9cb8aec" translate="yes" xml:space="preserve">
          <source>Imagine Section</source>
          <target state="translated">想象中的科室</target>
        </trans-unit>
        <trans-unit id="dad00638754ac36048fbd57bbed553cd6109f1e7" translate="yes" xml:space="preserve">
          <source>Imagine Style</source>
          <target state="translated">想象中的风格</target>
        </trans-unit>
        <trans-unit id="f3f1ce65c7d662de103f9b182bf637fc9badc9d7" translate="yes" xml:space="preserve">
          <source>Imagine Style.Imagine.path</source>
          <target state="translated">想象中的风格.想象中的路径</target>
        </trans-unit>
        <trans-unit id="38e93318fb9a14392730f2d9e9abd6cc6b7227a1" translate="yes" xml:space="preserve">
          <source>Imagine that we wanted to add an &quot;interrupt&quot; mechanism to the example discussed in the previous section; the user should be able to click a button to have the state machine perform some non-related task, after which the state machine should resume whatever it was doing before (i.e. return to the old state, which is one of &lt;code&gt;s11&lt;/code&gt;, &lt;code&gt;s12&lt;/code&gt; and &lt;code&gt;s13&lt;/code&gt; in this case).</source>
          <target state="translated">假设我们想在上一节中讨论的示例中添加&amp;ldquo;中断&amp;rdquo;机制；用户应该能够单击按钮以使状态机执行一些无关的任务，此后状态机应恢复之前的操作（即返回到旧状态，即 &lt;code&gt;s11&lt;/code&gt; ， &lt;code&gt;s12&lt;/code&gt; 和 &lt;code&gt;s13&lt;/code&gt; 之一)在这种情况下）。</target>
        </trans-unit>
        <trans-unit id="d46bf7f0635f256bb62b8e6e4435cce21887a239" translate="yes" xml:space="preserve">
          <source>Imagine that we wanted to add an &quot;interrupt&quot; mechanism to the example discussed in the previous section; the user should be able to click a button to have the state machine perform some non-related task, after which the state machine should resume whatever it was doing before (i.e. return to the old state, which is one of the three states in this case).</source>
          <target state="translated">想象一下,我们想在上一节讨论的例子中增加一个 &quot;中断 &quot;机制;用户应该能够点击一个按钮,让状态机执行一些无关的任务,之后状态机应该恢复之前正在做的事情(即回到旧的状态,也就是本例中的三种状态之一)。</target>
        </trans-unit>
        <trans-unit id="bc336dfa996544380b34bd2032fb453005551001" translate="yes" xml:space="preserve">
          <source>Imagine we need to check whether all properties of the &lt;a href=&quot;qwindow&quot;&gt;QWindow&lt;/a&gt; class that represent minimum and maximum dimensions are properly writable. The following example demonstrates one of the approaches:</source>
          <target state="translated">想象一下，我们需要检查&lt;a href=&quot;qwindow&quot;&gt;QWindow&lt;/a&gt;类的代表最小和最大尺寸的所有属性是否正确可写。下面的示例演示了一种方法：</target>
        </trans-unit>
        <trans-unit id="9cace0481141bb12622f97fa076722e410411c47" translate="yes" xml:space="preserve">
          <source>Imagine.path : string</source>
          <target state="translated">Imagine.path:string</target>
        </trans-unit>
        <trans-unit id="868930280894191b54d63d2127ac6fdebf557223" translate="yes" xml:space="preserve">
          <source>Immediate</source>
          <target state="translated">Immediate</target>
        </trans-unit>
        <trans-unit id="4cc0fc1bb9145c589383805a2b9e7642df617e2d" translate="yes" xml:space="preserve">
          <source>Immediate Alert UUID (service). The service exposes a control point to allow a peer device to cause the device to immediately alert.</source>
          <target state="translated">立即警报UUID(服务)。该服务暴露了一个控制点,允许对等设备引起设备立即报警。</target>
        </trans-unit>
        <trans-unit id="8f74d40b0ddca001d8ec191cbc118ef0fc66bc1c" translate="yes" xml:space="preserve">
          <source>Immediate Property Changes in Transitions</source>
          <target state="translated">过渡中的即时属性变化</target>
        </trans-unit>
        <trans-unit id="68339c6c58f9820acd9d75108c7f0576ba2cad11" translate="yes" xml:space="preserve">
          <source>Immediately completes any ongoing transition. /sa Animation.complete</source>
          <target state="translated">立即完成任何正在进行的转换。/sa Animation.complete</target>
        </trans-unit>
        <trans-unit id="c5601651de7fcae66afe4aba0873b88413dde4f1" translate="yes" xml:space="preserve">
          <source>Immediately dispatches all events which have been previously queued with &lt;a href=&quot;qcoreapplication#postEvent&quot;&gt;QCoreApplication::postEvent&lt;/a&gt;() and which are for the object</source>
          <target state="translated">立即分派之前已与&lt;a href=&quot;qcoreapplication#postEvent&quot;&gt;QCoreApplication :: postEvent&lt;/a&gt;（）排队的所有事件。</target>
        </trans-unit>
        <trans-unit id="bda227a1a554a0d13546ebf5fcba2f685ff2cbe8" translate="yes" xml:space="preserve">
          <source>Immediately sets &lt;code&gt;isFullScreen&lt;/code&gt; property to &lt;code&gt;false&lt;/code&gt;. It can be used to notify the browser engine when the windowing system forces the application to leave fullscreen mode.</source>
          <target state="translated">立即将 &lt;code&gt;isFullScreen&lt;/code&gt; 属性设置为 &lt;code&gt;false&lt;/code&gt; 。当窗口系统强制应用程序退出全屏模式时，它可以用于通知浏览器引擎。</target>
        </trans-unit>
        <trans-unit id="2a134b5272d27d4a7900f567cac0f94068b20dd6" translate="yes" xml:space="preserve">
          <source>Immediately triggers the painted texture's &lt;a href=&quot;qt3drender-qpaintedtextureimage#paint&quot;&gt;paint&lt;/a&gt;() function, which in turn uploads the new image to the GPU. If you are making multiple changes to a painted texture, consider waiting until all changes are complete before calling update, in order to minimize the number of repaints required.</source>
          <target state="translated">立即触发绘制的纹理的&lt;a href=&quot;qt3drender-qpaintedtextureimage#paint&quot;&gt;paint&lt;/a&gt;（）函数，该函数又将新图像上载到GPU。如果要对绘制的纹理进行多次更改，请考虑等待所有更改完成后再调用update，以最大程度地减少所需的重新绘制次数。</target>
        </trans-unit>
        <trans-unit id="d88a43ea93f14a1fa3a0d0d58d578a933a0f86b9" translate="yes" xml:space="preserve">
          <source>Imperative Value Assignment</source>
          <target state="translated">必要的价值分配</target>
        </trans-unit>
        <trans-unit id="7dffd111dffd7824c6ed8202c2f8de8f2971d5ad" translate="yes" xml:space="preserve">
          <source>Implement a new rendering technique without having to modify Qt 3D's internals</source>
          <target state="translated">实现一种新的渲染技术,而无需修改Qt 3D的内部结构。</target>
        </trans-unit>
        <trans-unit id="7e7520350429491e18c887be4f965b5bdd1d0d48" translate="yes" xml:space="preserve">
          <source>Implement an &lt;code&gt;onStatusChanged&lt;/code&gt; signal handler:</source>
          <target state="translated">实现一个 &lt;code&gt;onStatusChanged&lt;/code&gt; 信号处理程序：</target>
        </trans-unit>
        <trans-unit id="e346f9fffc6ceccab78a2154371197615995d409" translate="yes" xml:space="preserve">
          <source>Implement new geoservices and positioning plugins.</source>
          <target state="translated">实现新的地理服务和定位插件。</target>
        </trans-unit>
        <trans-unit id="bd323a55150b6fa8d2b20d8db4165a3936d48610" translate="yes" xml:space="preserve">
          <source>Implement the &lt;a href=&quot;qtextobjectinterface&quot;&gt;QTextObjectInterface&lt;/a&gt; class.</source>
          <target state="translated">实现&lt;a href=&quot;qtextobjectinterface&quot;&gt;QTextObjectInterface&lt;/a&gt;类。</target>
        </trans-unit>
        <trans-unit id="e21ac13ac5de0146f5ac8d178af6c955fbf20b0d" translate="yes" xml:space="preserve">
          <source>Implement the QTextObjectInterface class.</source>
          <target state="translated">实现QTextObjectInterface类。</target>
        </trans-unit>
        <trans-unit id="824c61e83f5938134d2ccf320782b112d83564ae" translate="yes" xml:space="preserve">
          <source>Implement the method to compare this texture data generator to</source>
          <target state="translated">实现了将此纹理数据生成器与其他数据生成器进行比较的方法。</target>
        </trans-unit>
        <trans-unit id="77704c55abe49f13d980c280e8b0fc7c85fcb538" translate="yes" xml:space="preserve">
          <source>Implement the method to return the texture image data.</source>
          <target state="translated">实现返回纹理图像数据的方法。</target>
        </trans-unit>
        <trans-unit id="a355b7b38f031aa2b039a06b19988649aa6d14f6" translate="yes" xml:space="preserve">
          <source>Implement the methods of the COM interfaces, and use &lt;a href=&quot;qaxaggregated#object&quot;&gt;QAxAggregated::object&lt;/a&gt;() if you need to make calls to the &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; subclass implementing the control.</source>
          <target state="translated">实现COM接口的方法，如果需要对实现控件的&lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;子类进行调用，请使用&lt;a href=&quot;qaxaggregated#object&quot;&gt;QAxAggregated :: object&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="406f172389da11abc4e5a7989bb113ad823f5e4d" translate="yes" xml:space="preserve">
          <source>Implement this factory once in your COM server to provide information about the components the server can create. Subclass &lt;a href=&quot;qaxfactory&quot;&gt;QAxFactory&lt;/a&gt; and implement the pure virtual functions in any implementation file (e.g. main.cpp), and export the factory using the &lt;code&gt;QAXFACTORY_EXPORT()&lt;/code&gt; macro.</source>
          <target state="translated">在COM服务器中一次实现该工厂，以提供有关服务器可以创建的组件的信息。子类&lt;a href=&quot;qaxfactory&quot;&gt;QAxFactory&lt;/a&gt;并在任何实现文件（例如main.cpp）中实现纯虚函数，并使用 &lt;code&gt;QAXFACTORY_EXPORT()&lt;/code&gt; 宏导出工厂。</target>
        </trans-unit>
        <trans-unit id="fc294b550f73b4facd3cac2fd6a28b18cc251133" translate="yes" xml:space="preserve">
          <source>Implement this factory once in your COM server to provide information about the components the server can create. Subclass QAxFactory and implement the pure virtual functions in any implementation file (e.g. main.cpp), and export the factory using the &lt;code&gt;QAXFACTORY_EXPORT()&lt;/code&gt; macro.</source>
          <target state="translated">在COM服务器中一次实现该工厂，以提供有关服务器可以创建的组件的信息。子类QAxFactory并在任何实现文件（例如main.cpp）中实现纯虚函数，并使用 &lt;code&gt;QAXFACTORY_EXPORT()&lt;/code&gt; 宏导出工厂。</target>
        </trans-unit>
        <trans-unit id="5f23feaf099c6971edc686af99d77cf8503cddd5" translate="yes" xml:space="preserve">
          <source>Implement this function to create a driver matching the type specified by the given</source>
          <target state="translated">实现该函数,创建一个与给定的</target>
        </trans-unit>
        <trans-unit id="224dc13ea57027949d3f6874a7204d4c998cf6f1" translate="yes" xml:space="preserve">
          <source>Implement this method to return the QTextureImageDataGeneratorPtr instance, which will provide the data for the texture image.</source>
          <target state="translated">实现此方法返回QTextureImageDataGeneratorPtr实例,它将为纹理图像提供数据。</target>
        </trans-unit>
        <trans-unit id="4c14c2fe30be49d5c733a53729dcc63f006d7a5e" translate="yes" xml:space="preserve">
          <source>Implement this method to return the QTextureImageDataGeneratorPtr, which will provide the data for the texture image.</source>
          <target state="translated">实现此方法返回QTextureImageDataGeneratorPtr,它将提供纹理图像的数据。</target>
        </trans-unit>
        <trans-unit id="3e089de4af7d9ddc1e6da0131bcd834096b8d142" translate="yes" xml:space="preserve">
          <source>Implement this method to return the image type supported by this image provider.</source>
          <target state="translated">实现这个方法来返回这个图像提供者支持的图像类型。</target>
        </trans-unit>
        <trans-unit id="2d352d18dc68af4a8806f9abd203677132d57e4c" translate="yes" xml:space="preserve">
          <source>Implement this method to return the image with</source>
          <target state="translated">实现此方法,以返回带有</target>
        </trans-unit>
        <trans-unit id="041a244fbd31fdc4f744aa3a7078f19300173476" translate="yes" xml:space="preserve">
          <source>Implement this method to return the job that will provide the texture with</source>
          <target state="translated">实现这个方法来返回将提供纹理的作业,并将其与</target>
        </trans-unit>
        <trans-unit id="6d0a303aa84f1afcec28a14303ec4efacff0ca6c" translate="yes" xml:space="preserve">
          <source>Implement this method to return the pixmap with</source>
          <target state="translated">实现这个方法,以返回像素图。</target>
        </trans-unit>
        <trans-unit id="69d72131ccbaa4ec47b90c0870e016e31fcbae0f" translate="yes" xml:space="preserve">
          <source>Implement this method to return the texture with</source>
          <target state="translated">实现这个方法来返回带有</target>
        </trans-unit>
        <trans-unit id="e64cc5bcea5fe36b7f04f0ed3588d5c7d3924f08" translate="yes" xml:space="preserve">
          <source>Implement this pure virtual function in your subclass.</source>
          <target state="translated">在你的子类中实现这个纯虚拟函数。</target>
        </trans-unit>
        <trans-unit id="ade43a8b3b00e99ac666e4cb294e52b6d22f6e46" translate="yes" xml:space="preserve">
          <source>Implement this to return the properties of this image provider.</source>
          <target state="translated">实现这个功能来返回这个图像提供者的属性。</target>
        </trans-unit>
        <trans-unit id="8781d615fd77be9578225c40ac67b9471394cced" translate="yes" xml:space="preserve">
          <source>Implementation</source>
          <target state="translated">Implementation</target>
        </trans-unit>
        <trans-unit id="7a5b3d65c8b1ef6dfcd4d330d512a64c7e307980" translate="yes" xml:space="preserve">
          <source>Implementation &lt;a href=&quot;qtexttospeech#setLocale&quot;&gt;QTextToSpeech::setLocale&lt;/a&gt;(</source>
          <target state="translated">实现&lt;a href=&quot;qtexttospeech#setLocale&quot;&gt;QTextToSpeech :: setLocale&lt;/a&gt;（</target>
        </trans-unit>
        <trans-unit id="768eca589194c251ad5053258cf35e3750aed13d" translate="yes" xml:space="preserve">
          <source>Implementation Issues</source>
          <target state="translated">执行问题</target>
        </trans-unit>
        <trans-unit id="bac8c2f94d12883bc12d802245b943cdfe608152" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;qtexttospeech#availableLocales&quot;&gt;QTextToSpeech::availableLocales&lt;/a&gt;().</source>
          <target state="translated">实施&lt;a href=&quot;qtexttospeech#availableLocales&quot;&gt;QTextToSpeech :: availableLocales&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="252365b05ef1276e15ece6c3868d4b4d1312185c" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;qtexttospeech#availableVoices&quot;&gt;QTextToSpeech::availableVoices&lt;/a&gt;().</source>
          <target state="translated">实施&lt;a href=&quot;qtexttospeech#availableVoices&quot;&gt;QTextToSpeech :: availableVoices&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="8915b9793a0c76b65653decd9f3391b5b718cc01" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;qtexttospeech#locale-prop&quot;&gt;QTextToSpeech::locale&lt;/a&gt;().</source>
          <target state="translated">实施&lt;a href=&quot;qtexttospeech#locale-prop&quot;&gt;QTextToSpeech ::区域设置&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="6f3142270e620ef5d5695917fd099c3e16e4d4f7" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;qtexttospeech#pause&quot;&gt;QTextToSpeech::pause&lt;/a&gt;().</source>
          <target state="translated">实施&lt;a href=&quot;qtexttospeech#pause&quot;&gt;QTextToSpeech ::暂停&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="5183464314eeea0721641bc39fe137ddb971f6a8" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;qtexttospeech#pitch-prop&quot;&gt;QTextToSpeech::pitch&lt;/a&gt;().</source>
          <target state="translated">实施&lt;a href=&quot;qtexttospeech#pitch-prop&quot;&gt;QTextToSpeech ::间距&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="65270c60c0c4cc1a3b051c8c55c1da9a1ee2403c" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;qtexttospeech#pitch-prop&quot;&gt;QTextToSpeech::setPitch&lt;/a&gt;(</source>
          <target state="translated">实施&lt;a href=&quot;qtexttospeech#pitch-prop&quot;&gt;QTextToSpeech :: setPitch&lt;/a&gt;（</target>
        </trans-unit>
        <trans-unit id="732cb6eaf2b5223b253b4065c81c85598c5188db" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;qtexttospeech#rate-prop&quot;&gt;QTextToSpeech::rate&lt;/a&gt;().</source>
          <target state="translated">实施&lt;a href=&quot;qtexttospeech#rate-prop&quot;&gt;QTextToSpeech ::率&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="683a708a3cbf5e893a3adac0630fc2ed3d390a48" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;qtexttospeech#rate-prop&quot;&gt;QTextToSpeech::setRate&lt;/a&gt;(</source>
          <target state="translated">实施&lt;a href=&quot;qtexttospeech#rate-prop&quot;&gt;QTextToSpeech :: setRate&lt;/a&gt;（</target>
        </trans-unit>
        <trans-unit id="6c81f536d52969f0a1f6daadfe044b4f1679c8d4" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;qtexttospeech#resume&quot;&gt;QTextToSpeech::resume&lt;/a&gt;().</source>
          <target state="translated">实施&lt;a href=&quot;qtexttospeech#resume&quot;&gt;QTextToSpeech ::简历&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="d34333cb782ffdfedde949f5263cc3e9f3223d1b" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;qtexttospeech#say&quot;&gt;QTextToSpeech::say&lt;/a&gt;(</source>
          <target state="translated">实施&lt;a href=&quot;qtexttospeech#say&quot;&gt;QTextToSpeech ::发言权&lt;/a&gt;（</target>
        </trans-unit>
        <trans-unit id="0c04b71feeddae254af4e863df6c0a64a030f1b2" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;qtexttospeech#setVoice&quot;&gt;QTextToSpeech::setVoice&lt;/a&gt;(</source>
          <target state="translated">实施&lt;a href=&quot;qtexttospeech#setVoice&quot;&gt;QTextToSpeech :: setVoice&lt;/a&gt;（</target>
        </trans-unit>
        <trans-unit id="813cdd156d3a421694a5df93ffe85f18088d4859" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;qtexttospeech#state-prop&quot;&gt;QTextToSpeech::state&lt;/a&gt;().</source>
          <target state="translated">实施&lt;a href=&quot;qtexttospeech#state-prop&quot;&gt;QTextToSpeech ::状态&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="58f6ecbddb418e3cc37e34f885c16afa614ed155" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;qtexttospeech#stop&quot;&gt;QTextToSpeech::stop&lt;/a&gt;().</source>
          <target state="translated">实施&lt;a href=&quot;qtexttospeech#stop&quot;&gt;QTextToSpeech ::停止&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="e9b90b10d7c8933fad8a80cbf878e2f12d1fe6b3" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;qtexttospeech#voice-prop&quot;&gt;QTextToSpeech::voice&lt;/a&gt;().</source>
          <target state="translated">实施&lt;a href=&quot;qtexttospeech#voice-prop&quot;&gt;QTextToSpeech ::声音&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="742124903e5f6679c84652579896852bd1d161d5" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;qtexttospeech#volume-prop&quot;&gt;QTextToSpeech::setVolume&lt;/a&gt;(</source>
          <target state="translated">实施&lt;a href=&quot;qtexttospeech#volume-prop&quot;&gt;QTextToSpeech :: setVolume&lt;/a&gt;（</target>
        </trans-unit>
        <trans-unit id="6f8bbfa959122fc74c77cd0e797f2e308faaefc2" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;qtexttospeech#volume-prop&quot;&gt;QTextToSpeech::volume&lt;/a&gt;().</source>
          <target state="translated">实施&lt;a href=&quot;qtexttospeech#volume-prop&quot;&gt;QTextToSpeech ::体积&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="f50927869456efd939126c6c4217e180c662927b" translate="yes" xml:space="preserve">
          <source>Implementation of a simple XML parser</source>
          <target state="translated">一个简单的XML解析器的实现</target>
        </trans-unit>
        <trans-unit id="52a6aa695ff12612c420aa2b2acd3323473ecae0" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;a href=&quot;qaccessibleinterface#statex&quot;&gt;QAccessibleInterface::state&lt;/a&gt;() return a combination of these flags.</source>
          <target state="translated">的实现&lt;a href=&quot;qaccessibleinterface#statex&quot;&gt;QAccessibleInterface ::状态&lt;/a&gt;（）返回这些标志的组合。</target>
        </trans-unit>
        <trans-unit id="62322beaafd8ec9a39b5baa61167ebb3ad7e6a17" translate="yes" xml:space="preserve">
          <source>Implementations of relations() return a combination of these flags. Some values are mutually exclusive.</source>
          <target state="translated">relations()的实现会返回这些标志的组合。有些值是相互排斥的。</target>
        </trans-unit>
        <trans-unit id="dfd938198bd1fdd36254588bf9e65c70d3614476" translate="yes" xml:space="preserve">
          <source>Implementations of this function are not expected to, and should not create any graphics resources (native texture objects) in case there are none yet.</source>
          <target state="translated">这个函数的实现不需要,也不应该创建任何图形资源(原生纹理对象),以防还没有。</target>
        </trans-unit>
        <trans-unit id="9b40982de342c9aa065e55edd172558d53cd6bcf" translate="yes" xml:space="preserve">
          <source>Implementations of this function are recommended to return the same instance for multiple calls to limit memory usage.</source>
          <target state="translated">建议该函数的实现在多次调用时返回同一个实例,以限制内存的使用。</target>
        </trans-unit>
        <trans-unit id="b949b5c89a7c002626b5129900e736b4b67b517b" translate="yes" xml:space="preserve">
          <source>Implementations that do not modify the video frame can simply return</source>
          <target state="translated">不修改视频帧的实现可以简单的返回</target>
        </trans-unit>
        <trans-unit id="7ce635db6989f56f270c4c9da77887cc9ddbabbf" translate="yes" xml:space="preserve">
          <source>Implementations that store graphics resources outside the node tree, such as an item implementing &lt;a href=&quot;qquickitem#textureProvider&quot;&gt;QQuickItem::textureProvider&lt;/a&gt;(), will need to take care in cleaning it up correctly depending on how the item is used in QML. The situations to handle are:</source>
          <target state="translated">将图形资源存储在节点树之外的实现（例如，实现&lt;a href=&quot;qquickitem#textureProvider&quot;&gt;QQuickItem :: textureProvider&lt;/a&gt;（）的项）将需要谨慎地进行清理，具体取决于项在QML中的使用方式。需要处理的情况是：</target>
        </trans-unit>
        <trans-unit id="45917572504116cc9d3aa541f552d3b9c98c9711" translate="yes" xml:space="preserve">
          <source>Implemented Categories</source>
          <target state="translated">已实施的类别</target>
        </trans-unit>
        <trans-unit id="79e4fc5d855be3f3ef0e736af8f6d4efedb9d969" translate="yes" xml:space="preserve">
          <source>Implemented in subclasses to add an</source>
          <target state="translated">在子类中实现,以增加一个</target>
        </trans-unit>
        <trans-unit id="f0be64a6f2f844bf8edb3d02f82270333257e4ac" translate="yes" xml:space="preserve">
          <source>Implemented in subclasses to return the maximum size of this item.</source>
          <target state="translated">在子类中实现,返回这个项目的最大尺寸。</target>
        </trans-unit>
        <trans-unit id="99a9442344617bb0f8b2765b1c9268a73d0b2f75" translate="yes" xml:space="preserve">
          <source>Implemented in subclasses to return the minimum size of this item.</source>
          <target state="translated">在子类中实现,返回这个项目的最小尺寸。</target>
        </trans-unit>
        <trans-unit id="c3a89331232f593071f453b5cf4851f994ffbc17" translate="yes" xml:space="preserve">
          <source>Implemented in subclasses to return the preferred size of this item.</source>
          <target state="translated">在子类中实现,返回这个项目的首选大小。</target>
        </trans-unit>
        <trans-unit id="48a71464c037110bac9ac7e4e37c746810204c17" translate="yes" xml:space="preserve">
          <source>Implemented in subclasses to return whether this item is empty, i.e. whether it contains any widgets.</source>
          <target state="translated">在子类中实现,返回这个项目是否为空,即是否包含任何小组件。</target>
        </trans-unit>
        <trans-unit id="80f4138d0dc744a4ebbac34c57270cb9e3e0b348" translate="yes" xml:space="preserve">
          <source>Implemented in subclasses to set this item's geometry to</source>
          <target state="translated">在子类中实现,将这个项目的几何体设置为</target>
        </trans-unit>
        <trans-unit id="a13de6052d7908b65e5da5504abdf7a6b611fa94" translate="yes" xml:space="preserve">
          <source>Implemented using an FTP proxy, it is useful only in the context of FTP requests (see &lt;a href=&quot;qnetworkaccessmanager&quot;&gt;QNetworkAccessManager&lt;/a&gt;)</source>
          <target state="translated">使用FTP代理实现，仅在FTP请求的上下文中才有用（请参阅&lt;a href=&quot;qnetworkaccessmanager&quot;&gt;QNetworkAccessManager&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="6f51578ba32a5f1095c7802cc7ac37ae56fabad4" translate="yes" xml:space="preserve">
          <source>Implemented using normal HTTP commands, it is useful only in the context of HTTP requests (see &lt;a href=&quot;qnetworkaccessmanager&quot;&gt;QNetworkAccessManager&lt;/a&gt;)</source>
          <target state="translated">使用常规HTTP命令实现，仅在HTTP请求的上下文中才有用（请参阅&lt;a href=&quot;qnetworkaccessmanager&quot;&gt;QNetworkAccessManager&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="37eaa6052778fa54b8c36b894ab76b71c291e275" translate="yes" xml:space="preserve">
          <source>Implemented using the &quot;CONNECT&quot; command, supports only outgoing TCP connections; supports authentication.</source>
          <target state="translated">使用 &quot;CONNECT &quot;命令实现,只支持外发TCP连接;支持认证。</target>
        </trans-unit>
        <trans-unit id="c36f0570f5d32e2cbf0d6f246f67f04c076cc4ca" translate="yes" xml:space="preserve">
          <source>Implementers must provide a unique combination of providerName() and providerVersion() per plugin.</source>
          <target state="translated">实现者必须为每个插件提供唯一的 providerName()和 providerVersion()组合。</target>
        </trans-unit>
        <trans-unit id="89c6516a41c7f89456772eefae5063a8a95198cb" translate="yes" xml:space="preserve">
          <source>Implementing Accessibility</source>
          <target state="translated">实施无障碍环境</target>
        </trans-unit>
        <trans-unit id="37055ff4688db34b01056929097bdf4e9a1647a9" translate="yes" xml:space="preserve">
          <source>Implementing Accessible Plugins</source>
          <target state="translated">实施可访问的插件</target>
        </trans-unit>
        <trans-unit id="62db8de0d5a43bd04c2e49c138c595d8be9bf39a" translate="yes" xml:space="preserve">
          <source>Implementing Attached Objects: An Example</source>
          <target state="translated">实现附加对象。实例</target>
        </trans-unit>
        <trans-unit id="1284919614dda5c4849a9d835fdf6246b454a23f" translate="yes" xml:space="preserve">
          <source>Implementing Containers</source>
          <target state="translated">实施容器</target>
        </trans-unit>
        <trans-unit id="88757e72266ba18e73a64b75a68b2a454adbda62" translate="yes" xml:space="preserve">
          <source>Implementing Controls</source>
          <target state="translated">实施控制</target>
        </trans-unit>
        <trans-unit id="da3c580339754281809a3e83b0ad26e13dd93a1a" translate="yes" xml:space="preserve">
          <source>Implementing Interface Factories</source>
          <target state="translated">实现接口工厂</target>
        </trans-unit>
        <trans-unit id="93a7e62b8b482382a12442f268a928d84247e783" translate="yes" xml:space="preserve">
          <source>Implementing New Back-Ends and Porting</source>
          <target state="translated">实施新的后端和移植。</target>
        </trans-unit>
        <trans-unit id="a697df395e011b66cb0286f725767f5fb97c05d5" translate="yes" xml:space="preserve">
          <source>Implementing Plugins</source>
          <target state="translated">实施插件</target>
        </trans-unit>
        <trans-unit id="105d092e17fec216e8d6c23e821004c74a0ffe87" translate="yes" xml:space="preserve">
          <source>Implementing a Custom CAN Plugin</source>
          <target state="translated">实现一个自定义的CAN插件</target>
        </trans-unit>
        <trans-unit id="3ac815e3336452c287cb246a2566818a76c57da8" translate="yes" xml:space="preserve">
          <source>Implementing a Custom Input Method</source>
          <target state="translated">实现自定义输入法</target>
        </trans-unit>
        <trans-unit id="c3cad3660d34c8c4eb4fd640e52d906820ac9980" translate="yes" xml:space="preserve">
          <source>Implementing a Custom Style</source>
          <target state="translated">实施自定义样式</target>
        </trans-unit>
        <trans-unit id="2f1e6e2499a481cc5e8da70677aff24ce7688e68" translate="yes" xml:space="preserve">
          <source>Implementing a subclass of QAbstractVideoSurface</source>
          <target state="translated">实现QAbstractVideoSurface的一个子类。</target>
        </trans-unit>
        <trans-unit id="9a8faa504839bd228eefcc80f99ef25836ebf8fb" translate="yes" xml:space="preserve">
          <source>Implementing the &lt;a href=&quot;qwebengineurlrequestinterceptor&quot;&gt;QWebEngineUrlRequestInterceptor&lt;/a&gt; interface and installing the interceptor on the profile enables intercepting, blocking, and modifying URL requests before they reach the networking stack of Chromium.</source>
          <target state="translated">实施&lt;a href=&quot;qwebengineurlrequestinterceptor&quot;&gt;QWebEngineUrlRequestInterceptor&lt;/a&gt;接口并在配置文件上安装拦截器，可以在URL请求到达Chromium的网络堆栈之前对其进行拦截，阻止和修改。</target>
        </trans-unit>
        <trans-unit id="3e688de840fb7260f136ec74910e06f507c8217d" translate="yes" xml:space="preserve">
          <source>Implementing the &lt;a href=&quot;qwebengineurlrequestinterceptor&quot;&gt;QWebEngineUrlRequestInterceptor&lt;/a&gt; interface and registering the interceptor on a profile by &lt;a href=&quot;qwebengineprofile#setUrlRequestInterceptor&quot;&gt;setUrlRequestInterceptor&lt;/a&gt;() enables intercepting, blocking, and modifying URL requests (&lt;a href=&quot;qwebengineurlrequestinfo&quot;&gt;QWebEngineUrlRequestInfo&lt;/a&gt;) before they reach the networking stack of Chromium.</source>
          <target state="translated">实施&lt;a href=&quot;qwebengineurlrequestinterceptor&quot;&gt;QWebEngineUrlRequestInterceptor&lt;/a&gt;接口并通过&lt;a href=&quot;qwebengineprofile#setUrlRequestInterceptor&quot;&gt;setUrlRequestInterceptor&lt;/a&gt;（）在配置文件上注册拦截器，可以在URL请求（&lt;a href=&quot;qwebengineurlrequestinfo&quot;&gt;QWebEngineUrlRequestInfo&lt;/a&gt;）到达Chromium的网络堆栈之前对其进行拦截，阻止和修改。</target>
        </trans-unit>
        <trans-unit id="4dd1cd2566050206f34018201521db4e116a53c7" translate="yes" xml:space="preserve">
          <source>Implementing the &lt;a href=&quot;qwebengineurlrequestinterceptor&quot;&gt;QWebEngineUrlRequestInterceptor&lt;/a&gt; interface and registering the interceptor on a profile by setRequestInterceptor() enables intercepting, blocking, and modifying URL requests (&lt;a href=&quot;qwebengineurlrequestinfo&quot;&gt;QWebEngineUrlRequestInfo&lt;/a&gt;) before they reach the networking stack of Chromium.</source>
          <target state="translated">实施&lt;a href=&quot;qwebengineurlrequestinterceptor&quot;&gt;QWebEngineUrlRequestInterceptor&lt;/a&gt;接口并通过setRequestInterceptor（）在配置文件上注册拦截器，可以在URL请求（&lt;a href=&quot;qwebengineurlrequestinfo&quot;&gt;QWebEngineUrlRequestInfo&lt;/a&gt;）到达Chromium的网络堆栈之前对其进行拦截，阻止和修改。</target>
        </trans-unit>
        <trans-unit id="2310b9fe383f075595e60e4e1744ab91d940d24f" translate="yes" xml:space="preserve">
          <source>Implementing the two constructors for class &lt;code&gt;Employee&lt;/code&gt; is also straightforward. Both create a new instance of &lt;code&gt;EmployeeData&lt;/code&gt; and assign it to the</source>
          <target state="translated">为 &lt;code&gt;Employee&lt;/code&gt; 类实现两个构造函数也很简单。两者都创建 &lt;code&gt;EmployeeData&lt;/code&gt; 的新实例并将其分配给</target>
        </trans-unit>
        <trans-unit id="8fedd5f9af10dcc2065402dce17c1a81d202eaa7" translate="yes" xml:space="preserve">
          <source>Implementing this is currently not feasible, because the Xcode concept of Active Build Configurations is conceptually different from the qmake idea of build targets.</source>
          <target state="translated">实现这一点目前还不可行,因为Xcode的Active Build Configurations概念与qmake的构建目标概念不同。</target>
        </trans-unit>
        <trans-unit id="a1d579b66264b8b69e731bda1e199f60583ec640" translate="yes" xml:space="preserve">
          <source>Implementing/Inheriting Reply Objects</source>
          <target state="translated">实现/继承回复对象</target>
        </trans-unit>
        <trans-unit id="a2c9281ebd86d2e5784c7a81af42b5a91f637f7d" translate="yes" xml:space="preserve">
          <source>Implementors should stop the sensors.</source>
          <target state="translated">实施者应停止传感器。</target>
        </trans-unit>
        <trans-unit id="44b4324428af79c0b75bfdc681f936837b39bf38" translate="yes" xml:space="preserve">
          <source>Implementors would use this to instantiate QSensors and connect signals.</source>
          <target state="translated">实现者将使用它来实例化 QSensors 并连接信号。</target>
        </trans-unit>
        <trans-unit id="7ae338d79a5230e4b43efdab06001e96e0e0f071" translate="yes" xml:space="preserve">
          <source>Implements OAuth 1 signature methods. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">实现OAuth 1签名方法。&lt;a href=&quot;#details&quot;&gt;更多...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9dbab7cc5aaaa4d4e4728f3d8a25dde8406f8f83" translate="yes" xml:space="preserve">
          <source>Implements a TCP socket that talks the WebSocket protocol. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">实现一个使用WebSocket协议的TCP套接字。&lt;a href=&quot;#details&quot;&gt;更多...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="07ce00efe44e974c973ad1854fbe7895987692e8" translate="yes" xml:space="preserve">
          <source>Implements a WebSocket-based server. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">实现基于WebSocket的服务器。&lt;a href=&quot;#details&quot;&gt;更多...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4bc4316bd595db94a09151c95ec09e3615ceda18" translate="yes" xml:space="preserve">
          <source>Implements a main() function that executes all tests in</source>
          <target state="translated">实现了一个main()函数,该函数可以执行</target>
        </trans-unit>
        <trans-unit id="11e5db6cf1adf659b0180252b6472dcbb09db170" translate="yes" xml:space="preserve">
          <source>Implements a main() function that instantiates a &lt;a href=&quot;qcoreapplication&quot;&gt;QCoreApplication&lt;/a&gt; object and the</source>
          <target state="translated">实现main（）函数，该函数实例化&lt;a href=&quot;qcoreapplication&quot;&gt;QCoreApplication&lt;/a&gt;对象，并且</target>
        </trans-unit>
        <trans-unit id="769582a411ec116dae3da4fce76e27f46a1e28f4" translate="yes" xml:space="preserve">
          <source>Implements a main() function that instantiates an application object and the</source>
          <target state="translated">实现一个main()函数,该函数实例化了一个应用程序对象和该应用程序的</target>
        </trans-unit>
        <trans-unit id="58df4016dcc0a1e6f025cd9c6e4efb4b5e74814c" translate="yes" xml:space="preserve">
          <source>Implements a plain text layout for QTextDocument</source>
          <target state="translated">为QTextDocument实现纯文本布局。</target>
        </trans-unit>
        <trans-unit id="817d2e38832dc5e530d8da9e24d5f4c39ecc59c7" translate="yes" xml:space="preserve">
          <source>Implements a splitter widget</source>
          <target state="translated">实施一个分割器部件</target>
        </trans-unit>
        <trans-unit id="ed071f20bf56590f18c4cef7b3c7c4ffb71a5d5d" translate="yes" xml:space="preserve">
          <source>Implements the clipping functionality in the scene graph</source>
          <target state="translated">在场景图中实现剪接功能。</target>
        </trans-unit>
        <trans-unit id="360dfa2ecac7b96dfbfcd613fe35c133883f2811" translate="yes" xml:space="preserve">
          <source>Implements transformations in the scene graph</source>
          <target state="translated">在场景图中实现变换</target>
        </trans-unit>
        <trans-unit id="4a4e5714e68750a6616682cf4332ca27085f7c07" translate="yes" xml:space="preserve">
          <source>Implications for Application Security</source>
          <target state="translated">对应用安全的影响</target>
        </trans-unit>
        <trans-unit id="d1b0c2da64929c52614a0ea37031fc3f08a659ba" translate="yes" xml:space="preserve">
          <source>Implications of Garbage Collection</source>
          <target state="translated">垃圾收集的影响</target>
        </trans-unit>
        <trans-unit id="37cafc62e0335cc769516aaf21c4deb5286f0977" translate="yes" xml:space="preserve">
          <source>Implicit Sharing</source>
          <target state="translated">隐性分享</target>
        </trans-unit>
        <trans-unit id="008b49b9ffac23b845fdc5aceab2e0cf4741c4da" translate="yes" xml:space="preserve">
          <source>Implicit Sharing in Detail</source>
          <target state="translated">隐性共享的细节</target>
        </trans-unit>
        <trans-unit id="cdb6ebf7715b4bffbd4c4dd2a2aae70eddfcd8b9" translate="yes" xml:space="preserve">
          <source>Implicit cast to &lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;QVariant&lt;/a&gt;. Equivalent to calling &lt;a href=&quot;qvariant#fromValue&quot;&gt;QVariant::fromValue&lt;/a&gt;() with this object as argument.</source>
          <target state="translated">隐式转换为&lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;QVariant&lt;/a&gt;。等效于以该对象作为参数调用&lt;a href=&quot;qvariant#fromValue&quot;&gt;QVariant :: fromValue&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="966abcfa7bdb99429306a8cf6ca30cf3373a6089" translate="yes" xml:space="preserve">
          <source>Implicit cast to &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt;. Equivalent to calling &lt;a href=&quot;qvariant#fromValue&quot;&gt;QVariant::fromValue&lt;/a&gt;() with this object as argument.</source>
          <target state="translated">隐式转换为&lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt;。等效于以该对象作为参数调用&lt;a href=&quot;qvariant#fromValue&quot;&gt;QVariant :: fromValue&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="ff32335dbb51abb4375899515ea8df57a9c058e6" translate="yes" xml:space="preserve">
          <source>Implicit construction of a &lt;a href=&quot;gui-changes-qt6#qbitmap&quot;&gt;QBitmap&lt;/a&gt; from a &lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt; is no longer supported. The constructor and assignment operator have been made explicit and marked as deprecated. Use the new static factory function &lt;a href=&quot;qbitmap#fromPixmap&quot;&gt;fromPixmap&lt;/a&gt; instead.</source>
          <target state="translated">不再支持从&lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt;隐式构造&lt;a href=&quot;gui-changes-qt6#qbitmap&quot;&gt;QBitmap&lt;/a&gt;。构造函数和赋值运算符已明确显示并标记为已弃用。请改用&lt;a href=&quot;qbitmap#fromPixmap&quot;&gt;fromPixmap中&lt;/a&gt;的新静态工厂函数。</target>
        </trans-unit>
        <trans-unit id="813ed1c1303d4a62b31c5b0a2e596e9eae4d4564" translate="yes" xml:space="preserve">
          <source>Implicit construction of a &lt;a href=&quot;gui-changes-qt6#qcursor&quot;&gt;QCursor&lt;/a&gt; from a &lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt; is no longer supported, the constructor has been made explicit.</source>
          <target state="translated">从&lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt;隐式构造&lt;a href=&quot;gui-changes-qt6#qcursor&quot;&gt;QCursor&lt;/a&gt;不再受支持，构造函数已明确。</target>
        </trans-unit>
        <trans-unit id="3e7bbbb28d40bbb6d5979d4288643e53d8506e6a" translate="yes" xml:space="preserve">
          <source>Implicit conversions between QFuture and other types</source>
          <target state="translated">QFuture和其他类型之间的隐式转换。</target>
        </trans-unit>
        <trans-unit id="00704da9b767c062d791dbf94a3d54d1682ec9a5" translate="yes" xml:space="preserve">
          <source>Implicit conversions cannot be done between signals and slots.</source>
          <target state="translated">信号和插槽之间不能进行隐式转换。</target>
        </trans-unit>
        <trans-unit id="6c30cd01ca170437484abc595c9d9485ad31782e" translate="yes" xml:space="preserve">
          <source>Implicit sharing automatically detaches the object from a shared block if the object is about to change and the reference count is greater than one. (This is often called</source>
          <target state="translated">如果对象即将发生变化,且引用数大于1,则隐式共享会自动将对象从共享块中分离出来。(这通常被称为 &quot;隐式共享&quot;。</target>
        </trans-unit>
        <trans-unit id="af5545c5727bf3de7176b7b17f4242870d3a2817" translate="yes" xml:space="preserve">
          <source>Implicit sharing iterator problem</source>
          <target state="translated">隐式共享迭代器问题</target>
        </trans-unit>
        <trans-unit id="601f1ceaa652300a5d75c64915d5edfc352c8ebb" translate="yes" xml:space="preserve">
          <source>Implicit sharing might not be right for the &lt;code&gt;Employee&lt;/code&gt; class. Consider a simple example that creates two instances of the implicitly shared &lt;code&gt;Employee&lt;/code&gt; class.</source>
          <target state="translated">隐式共享可能不适用于 &lt;code&gt;Employee&lt;/code&gt; 类。考虑一个简单的示例，该示例创建隐式共享 &lt;code&gt;Employee&lt;/code&gt; 类的两个实例。</target>
        </trans-unit>
        <trans-unit id="c9c4834109dffe1f19ab4a49e9550da5ca048239" translate="yes" xml:space="preserve">
          <source>Implicit sharing mostly takes place behind the scenes; the programmer rarely needs to worry about it. However, Qt's container iterators have different behavior than those from the STL. Read &lt;a href=&quot;containers#implicit-sharing-iterator-problem&quot;&gt;Implicit sharing iterator problem&lt;/a&gt;.</source>
          <target state="translated">隐式共享主要发生在幕后。程序员很少需要担心它。但是，Qt的容器迭代器的行为不同于STL的行为。阅读&lt;a href=&quot;containers#implicit-sharing-iterator-problem&quot;&gt;隐式共享迭代器问题&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="01f8daedd3b6c5e9250fa35409773860241f5ac3" translate="yes" xml:space="preserve">
          <source>Implicit vs Explicit Sharing</source>
          <target state="translated">隐性与显性共享</target>
        </trans-unit>
        <trans-unit id="573dd3b4ab30316ae01dc2ccdd4c4c8c99b02418" translate="yes" xml:space="preserve">
          <source>Implicitly Shared Classes</source>
          <target state="translated">隐式共享类</target>
        </trans-unit>
        <trans-unit id="0170645197d080aa6d0d99799c0d55e8e2b3f7b3" translate="yes" xml:space="preserve">
          <source>Import Statement:</source>
          <target state="translated">进口声明:</target>
        </trans-unit>
        <trans-unit id="c84abb908c7f215124958ecd568ac8e0169e3de4" translate="yes" xml:space="preserve">
          <source>Import Statements</source>
          <target state="translated">进口声明</target>
        </trans-unit>
        <trans-unit id="cc9d210a6de060e7aa82158f000d6783d2ce29b2" translate="yes" xml:space="preserve">
          <source>Import Types</source>
          <target state="translated">进口类型</target>
        </trans-unit>
        <trans-unit id="0c7e14afb3fc6058836716fb5b5da1b28b34671f" translate="yes" xml:space="preserve">
          <source>Import and Export Restrictions</source>
          <target state="translated">进出口限制</target>
        </trans-unit>
        <trans-unit id="dd3e917e0a6dfc3dfd19158b36b1be97ca89b8c0" translate="yes" xml:space="preserve">
          <source>Import the types using the the following statement:</source>
          <target state="translated">使用以下语句导入类型。</target>
        </trans-unit>
        <trans-unit id="5121b999d9c7ec346a3f31830e3f222e9d03a8b1" translate="yes" xml:space="preserve">
          <source>Important C++ Classes Provided By The Qt QML Module</source>
          <target state="translated">Qt QML模块提供的重要C++类。</target>
        </trans-unit>
        <trans-unit id="e62a4997192c1e818765bef08838d899ef08c24f" translate="yes" xml:space="preserve">
          <source>Important Classes</source>
          <target state="translated">重要班级</target>
        </trans-unit>
        <trans-unit id="61e87e57acb875ed2bbb75fd5ef43644845fe655" translate="yes" xml:space="preserve">
          <source>Important Concepts in Qt Quick</source>
          <target state="translated">Qt Quick中的重要概念</target>
        </trans-unit>
        <trans-unit id="38bb3266d02c231b329affcd4d6c0cb05bb6549a" translate="yes" xml:space="preserve">
          <source>Important inherited functions: &lt;a href=&quot;qabstractbutton#text-prop&quot;&gt;text&lt;/a&gt;(), &lt;a href=&quot;qabstractbutton#text-prop&quot;&gt;setText&lt;/a&gt;(), &lt;a href=&quot;qabstractbutton#text-prop&quot;&gt;text&lt;/a&gt;(), pixmap(), setPixmap(), accel(), setAccel(), isToggleButton(), &lt;a href=&quot;qabstractbutton#down-prop&quot;&gt;setDown&lt;/a&gt;(), &lt;a href=&quot;qabstractbutton#down-prop&quot;&gt;isDown&lt;/a&gt;(), isOn(), &lt;a href=&quot;qcheckbox#checkState&quot;&gt;checkState&lt;/a&gt;(), &lt;a href=&quot;qabstractbutton#autoRepeat-prop&quot;&gt;autoRepeat&lt;/a&gt;(), isExclusiveToggle(), &lt;a href=&quot;qabstractbutton#group&quot;&gt;group&lt;/a&gt;(), &lt;a href=&quot;qabstractbutton#autoRepeat-prop&quot;&gt;setAutoRepeat&lt;/a&gt;(), &lt;a href=&quot;qabstractbutton#toggle&quot;&gt;toggle&lt;/a&gt;(), &lt;a href=&quot;qabstractbutton#pressed&quot;&gt;pressed&lt;/a&gt;(), &lt;a href=&quot;qabstractbutton#released&quot;&gt;released&lt;/a&gt;(), &lt;a href=&quot;qabstractbutton#clicked&quot;&gt;clicked&lt;/a&gt;(), &lt;a href=&quot;qabstractbutton#toggled&quot;&gt;toggled&lt;/a&gt;(), &lt;a href=&quot;qcheckbox#checkState&quot;&gt;checkState&lt;/a&gt;(), and &lt;a href=&quot;qcheckbox#stateChanged&quot;&gt;stateChanged&lt;/a&gt;().</source>
          <target state="translated">重要的继承函数：&lt;a href=&quot;qabstractbutton#text-prop&quot;&gt;text&lt;/a&gt;（），&lt;a href=&quot;qabstractbutton#text-prop&quot;&gt;setText&lt;/a&gt;（），&lt;a href=&quot;qabstractbutton#text-prop&quot;&gt;text&lt;/a&gt;（），pixmap（），setPixmap（），accel（），setAccel（），isToggleButton（），&lt;a href=&quot;qabstractbutton#down-prop&quot;&gt;setDown&lt;/a&gt;（），&lt;a href=&quot;qabstractbutton#down-prop&quot;&gt;isDown&lt;/a&gt;（），isOn（），&lt;a href=&quot;qcheckbox#checkState&quot;&gt;checkState&lt;/a&gt;（ ），&lt;a href=&quot;qabstractbutton#autoRepeat-prop&quot;&gt;autoRepeat&lt;/a&gt;（），isExclusiveToggle（），&lt;a href=&quot;qabstractbutton#group&quot;&gt;group&lt;/a&gt;（），&lt;a href=&quot;qabstractbutton#autoRepeat-prop&quot;&gt;setAutoRepeat&lt;/a&gt;（），&lt;a href=&quot;qabstractbutton#toggle&quot;&gt;toggle&lt;/a&gt;（），&lt;a href=&quot;qabstractbutton#pressed&quot;&gt;按下&lt;/a&gt;（），&lt;a href=&quot;qabstractbutton#released&quot;&gt;released&lt;/a&gt;（），&lt;a href=&quot;qabstractbutton#clicked&quot;&gt;单击&lt;/a&gt;（），&lt;a href=&quot;qabstractbutton#toggled&quot;&gt;toggleed&lt;/a&gt;（），&lt;a href=&quot;qcheckbox#checkState&quot;&gt;checkState&lt;/a&gt;（）和&lt;a href=&quot;qcheckbox#stateChanged&quot;&gt;stateChanged&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="e834ab849cfcf5fcf233f800c32a7947a1ab8d02" translate="yes" xml:space="preserve">
          <source>Important inherited members: &lt;a href=&quot;qabstractbutton#text-prop&quot;&gt;text&lt;/a&gt;(), &lt;a href=&quot;qabstractbutton#text-prop&quot;&gt;setText&lt;/a&gt;(), &lt;a href=&quot;qabstractbutton#text-prop&quot;&gt;text&lt;/a&gt;(), &lt;a href=&quot;qabstractbutton#down-prop&quot;&gt;setDown&lt;/a&gt;(), &lt;a href=&quot;qabstractbutton#down-prop&quot;&gt;isDown&lt;/a&gt;(), &lt;a href=&quot;qabstractbutton#autoRepeat-prop&quot;&gt;autoRepeat&lt;/a&gt;(), &lt;a href=&quot;qabstractbutton#group&quot;&gt;group&lt;/a&gt;(), &lt;a href=&quot;qabstractbutton#autoRepeat-prop&quot;&gt;setAutoRepeat&lt;/a&gt;(), &lt;a href=&quot;qabstractbutton#toggle&quot;&gt;toggle&lt;/a&gt;(), &lt;a href=&quot;qabstractbutton#pressed&quot;&gt;pressed&lt;/a&gt;(), &lt;a href=&quot;qabstractbutton#released&quot;&gt;released&lt;/a&gt;(), &lt;a href=&quot;qabstractbutton#clicked&quot;&gt;clicked&lt;/a&gt;(), and &lt;a href=&quot;qabstractbutton#toggled&quot;&gt;toggled&lt;/a&gt;().</source>
          <target state="translated">重要的继承成员：&lt;a href=&quot;qabstractbutton#text-prop&quot;&gt;text&lt;/a&gt;（），&lt;a href=&quot;qabstractbutton#text-prop&quot;&gt;setText&lt;/a&gt;（），&lt;a href=&quot;qabstractbutton#text-prop&quot;&gt;text&lt;/a&gt;（），&lt;a href=&quot;qabstractbutton#down-prop&quot;&gt;setDown&lt;/a&gt;（），&lt;a href=&quot;qabstractbutton#down-prop&quot;&gt;isDown&lt;/a&gt;（），&lt;a href=&quot;qabstractbutton#autoRepeat-prop&quot;&gt;autoRepeat&lt;/a&gt;（），&lt;a href=&quot;qabstractbutton#group&quot;&gt;group&lt;/a&gt;（），&lt;a href=&quot;qabstractbutton#autoRepeat-prop&quot;&gt;setAutoRepeat&lt;/a&gt;（），&lt;a href=&quot;qabstractbutton#toggle&quot;&gt;toggle&lt;/a&gt;（），&lt;a href=&quot;qabstractbutton#pressed&quot;&gt;按下&lt;/a&gt;（），&lt;a href=&quot;qabstractbutton#released&quot;&gt;释放&lt;/a&gt;（），&lt;a href=&quot;qabstractbutton#clicked&quot;&gt;单击&lt;/a&gt;（ ），然后&lt;a href=&quot;qabstractbutton#toggled&quot;&gt;切换&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="4ceffdf5e30809d3bf6a2dd72aa906bcf29fbdfc" translate="yes" xml:space="preserve">
          <source>Important notes</source>
          <target state="translated">重要说明</target>
        </trans-unit>
        <trans-unit id="037371a95f20d05f36a578d9da5d0b9b47ba7da4" translate="yes" xml:space="preserve">
          <source>Important: please note that this proxy only supports dragging a single row. It will assert if called with indexes from multiple rows, because dragging rows that might come from different source models cannot be implemented generically by this proxy model. Each piece of data in the &lt;a href=&quot;qmimedata&quot;&gt;QMimeData&lt;/a&gt; needs to be merged, which is data-type-specific. Reimplement this method in a subclass if you want to support dragging multiple rows.</source>
          <target state="translated">重要提示：请注意，此代理仅支持拖动单行。它会断言是否使用来自多行的索引进行调用，因为此代理模型无法通用实现可能来自不同源模型的拖动行。&lt;a href=&quot;qmimedata&quot;&gt;QMimeData&lt;/a&gt;中的每条数据都需要合并，这是特定于数据类型的。如果要支持拖动多行，请在子类中重新实现此方法。</target>
        </trans-unit>
        <trans-unit id="d8596abf671da0c3ab4421f86863a266d9d9052b" translate="yes" xml:space="preserve">
          <source>Important: the</source>
          <target state="translated">重要的是:</target>
        </trans-unit>
        <trans-unit id="421387e5ef6af9880ac182b025362e5f7a797ecf" translate="yes" xml:space="preserve">
          <source>Imported JavaScript resources are always qualified using the &quot;as&quot; keyword. The qualifier for JavaScript resources must start with an uppercase letter, and must be unique, so there is always a one-to-one mapping between qualifiers and JavaScript files. (This also means qualifiers cannot be named the same as built-in JavaScript objects such as &lt;code&gt;Date&lt;/code&gt; and &lt;code&gt;Math&lt;/code&gt;).</source>
          <target state="translated">导入的JavaScript资源始终使用&amp;ldquo; as&amp;rdquo;关键字进行限定。JavaScript资源的限定符必须以大写字母开头，并且必须是唯一的，因此限定符和JavaScript文件之间始终存在一对一的映射。（这也意味着限定符的名称不能与内置JavaScript对象（例如 &lt;code&gt;Date&lt;/code&gt; 和 &lt;code&gt;Math&lt;/code&gt; ）的名称相同）。</target>
        </trans-unit>
        <trans-unit id="f216a0084bc7745d65be29d2011c58160936bc5a" translate="yes" xml:space="preserve">
          <source>Imported library targets</source>
          <target state="translated">导入库目标</target>
        </trans-unit>
        <trans-unit id="99d044d9c559cc35a01b48d24159e07faf855129" translate="yes" xml:space="preserve">
          <source>Imported targets</source>
          <target state="translated">进口目标</target>
        </trans-unit>
        <trans-unit id="11dafcf83eb318084b653400651f7c58f6eef584" translate="yes" xml:space="preserve">
          <source>Imported targets are created for each Qt module. Imported target names should be preferred instead of using a variable like Qt5&amp;lt;Module&amp;gt;&lt;a href=&quot;windows-requirements#libraries&quot;&gt;_LIBRARIES&lt;/a&gt; in CMake commands such as &lt;code&gt;target_link_libraries&lt;/code&gt;. The actual path to the library can be obtained using the &lt;a href=&quot;https://cmake.org/cmake/help/latest/prop_tgt/LOCATION.html#&quot;&gt;LOCATION property&lt;/a&gt;:</source>
          <target state="translated">为每个Qt模块创建导入的目标。进口目标名称应该是首选的，而不是使用像QT5 &amp;lt;模块&amp;gt;可变&lt;a href=&quot;windows-requirements#libraries&quot;&gt;_LIBRARIES&lt;/a&gt;在CMake的命令，如 &lt;code&gt;target_link_libraries&lt;/code&gt; 。可以使用&lt;a href=&quot;https://cmake.org/cmake/help/latest/prop_tgt/LOCATION.html#&quot;&gt;LOCATION属性&lt;/a&gt;获取库的实际路径：</target>
        </trans-unit>
        <trans-unit id="607d7e9258bfe0eecc003608448f1db24d5ec4d3" translate="yes" xml:space="preserve">
          <source>Imported targets are created with the configurations Qt was configured with. That is, if Qt was configured with the -debug switch, an imported target with the configuration DEBUG will be created. If Qt was configured with the -release switch an imported target with the configuration RELEASE will be created. If Qt was configured with the -debug-and-release switch (the default on windows), then imported targets will be created with both RELEASE and DEBUG configurations.</source>
          <target state="translated">导入的目标会以Qt配置的配置来创建,也就是说,如果Qt被配置为-debug开关,则会创建一个配置为DEBUG的导入目标。也就是说,如果Qt被配置为-debug开关,则会创建一个配置为DEBUG的导入目标。如果Qt被配置为-release开关,则会创建一个配置为RELEASE的导入目标。如果Qt被配置为-debug-and-release开关(windows的默认值),那么导入的目标将被创建为配置为RELEASE和DEBUG的目标。</target>
        </trans-unit>
        <trans-unit id="03937bf492185baa003ec4c62f0f1cd2fec5e1d4" translate="yes" xml:space="preserve">
          <source>Imported targets are created with the same configurations as when Qt was configured. That is:</source>
          <target state="translated">导入的目标是以与Qt配置时相同的配置创建的。也就是说。</target>
        </trans-unit>
        <trans-unit id="514e6d7bf5926c4a5eb4c9a2ab417a20d120dc38" translate="yes" xml:space="preserve">
          <source>Importing GeoJSON</source>
          <target state="translated">导入GeoJSON</target>
        </trans-unit>
        <trans-unit id="2b572b92b7abf6a1404a9607ac9225599106712c" translate="yes" xml:space="preserve">
          <source>Importing JavaScript Resources In QML</source>
          <target state="translated">在QML中导入JavaScript资源</target>
        </trans-unit>
        <trans-unit id="a07d3b9984c3a9bb2a032c822da70a93c7d5a86f" translate="yes" xml:space="preserve">
          <source>Importing JavaScript Resources in QML</source>
          <target state="translated">在QML中导入JavaScript资源</target>
        </trans-unit>
        <trans-unit id="74f90fa59d49413174a28e0868f3b476bbe060db" translate="yes" xml:space="preserve">
          <source>Importing QML Document Directories</source>
          <target state="translated">导入QML文档目录</target>
        </trans-unit>
        <trans-unit id="e614479e838d142f1dc08e45e6aa8226fbf00096" translate="yes" xml:space="preserve">
          <source>Importing Qt Widgets</source>
          <target state="translated">导入Qt Widgets</target>
        </trans-unit>
        <trans-unit id="d2dd5e07565ac8d8ed0199fb178fb1a5b42ff516" translate="yes" xml:space="preserve">
          <source>Importing Types Defined Outside the Current Directory</source>
          <target state="translated">导入当前目录外定义的类型</target>
        </trans-unit>
        <trans-unit id="6436b24c8b5937824d5797f0351890daff53b895" translate="yes" xml:space="preserve">
          <source>Importing a JavaScript Resource from Another JavaScript Resource</source>
          <target state="translated">从另一个JavaScript资源导入JavaScript资源</target>
        </trans-unit>
        <trans-unit id="c8de67a37292988e83a4969d75ac4ef4efa0ba8a" translate="yes" xml:space="preserve">
          <source>Importing a JavaScript Resource from a QML Document</source>
          <target state="translated">从QML文档导入JavaScript资源</target>
        </trans-unit>
        <trans-unit id="2278e17098d88be8c7b169c057329a0036bb6869" translate="yes" xml:space="preserve">
          <source>Importing a QML Module from a JavaScript Resource</source>
          <target state="translated">从JavaScript资源导入一个QML模块。</target>
        </trans-unit>
        <trans-unit id="1f340d5738a67cc37f52af2ddc2babbc36dfe2a5" translate="yes" xml:space="preserve">
          <source>Importing a style now has extra meaning due to the way that imports work internally. Previously, importing &lt;code&gt;QtQuick.Controls&lt;/code&gt; would register the control types from the current style with the QML engine:</source>
          <target state="translated">由于导入在内部工作的方式，现在导入样式具有额外的意义。以前，导入 &lt;code&gt;QtQuick.Controls&lt;/code&gt; 会使用QML引擎注册当前样式的控件类型：</target>
        </trans-unit>
        <trans-unit id="6bba5262454eb84a52bf916ea0754dee9d03ca43" translate="yes" xml:space="preserve">
          <source>Importing and Using the QtQuick Module</source>
          <target state="translated">导入和使用QtQuick模块</target>
        </trans-unit>
        <trans-unit id="715536e90c655a21594c2ca6c3c6c79f182e85fc" translate="yes" xml:space="preserve">
          <source>Importing into a Qualified Local Namespace</source>
          <target state="translated">导入到一个合格的本地命名空间</target>
        </trans-unit>
        <trans-unit id="e42328ac01cd03a47978f064c93b392caf3861f0" translate="yes" xml:space="preserve">
          <source>Imports</source>
          <target state="translated">Imports</target>
        </trans-unit>
        <trans-unit id="206133b58740639c059f5c141eb877a2e5a78b92" translate="yes" xml:space="preserve">
          <source>Imports Within JavaScript Resources</source>
          <target state="translated">在JavaScript资源中导入</target>
        </trans-unit>
        <trans-unit id="20d1724dc0065a29a73e7b81b2e4c1ad97a8259e" translate="yes" xml:space="preserve">
          <source>Imports a PKCS#12 (pfx) file from the specified</source>
          <target state="translated">从指定的PKCS#12 (pfx)文件导入。</target>
        </trans-unit>
        <trans-unit id="6ec64477d61ce39f7adb564802340feafc5c3403" translate="yes" xml:space="preserve">
          <source>Imports the module located at</source>
          <target state="translated">导入位于</target>
        </trans-unit>
        <trans-unit id="a609773be3db299eb3ee92dbb63b3af44ab307f6" translate="yes" xml:space="preserve">
          <source>Imports the node</source>
          <target state="translated">导入节点</target>
        </trans-unit>
        <trans-unit id="c63b46833cf99c262fb11d741881043c6481c791" translate="yes" xml:space="preserve">
          <source>Imports the plugin named</source>
          <target state="translated">导入名为</target>
        </trans-unit>
        <trans-unit id="e932034bc98957b640d8d76431e91ecc7c2c5bb7" translate="yes" xml:space="preserve">
          <source>Imports will also be sorted in alphabetical order. This can be disabled by specifying the &lt;code&gt;-n&lt;/code&gt; flag.</source>
          <target state="translated">导入也将按字母顺序排序。可以通过指定 &lt;code&gt;-n&lt;/code&gt; 标志来禁用它。</target>
        </trans-unit>
        <trans-unit id="47ee6ecf0c2b2b386e6e8d2bd53dba4baea22e01" translate="yes" xml:space="preserve">
          <source>Improving Performance</source>
          <target state="translated">提高绩效</target>
        </trans-unit>
        <trans-unit id="ddea352dcc582538bbfc283cb12d7349937488a2" translate="yes" xml:space="preserve">
          <source>Improving Test Output</source>
          <target state="translated">提高测试输出</target>
        </trans-unit>
        <trans-unit id="0035950efc8dee1fcbaf7fe816bff53a4b73790a" translate="yes" xml:space="preserve">
          <source>Improving the example</source>
          <target state="translated">改进范例</target>
        </trans-unit>
        <trans-unit id="aef36502d67b0520654deb764dd055a7e905cfdd" translate="yes" xml:space="preserve">
          <source>In</source>
          <target state="translated">In</target>
        </trans-unit>
        <trans-unit id="ef7a9eb24298b4d4021043721623ae7468909079" translate="yes" xml:space="preserve">
          <source>In 4.6, an internal template class &lt;code&gt;QStringBuilder&lt;/code&gt; has been added along with a few helper functions. This class is marked internal and does not appear in the documentation, because you aren't meant to instantiate it in your code. Its use will be automatic, as described below. The class is found in &lt;code&gt;src/corelib/tools/qstringbuilder.cpp&lt;/code&gt; if you want to have a look at it.</source>
          <target state="translated">在4.6中，添加了内部模板类 &lt;code&gt;QStringBuilder&lt;/code&gt; 以及一些辅助函数。该类被标记为内部类，因此不会出现在文档中，因为您无意在代码中实例化该类。如下所述，它将自动使用。如果要查看该类，可以在 &lt;code&gt;src/corelib/tools/qstringbuilder.cpp&lt;/code&gt; 中找到。</target>
        </trans-unit>
        <trans-unit id="c3c47d4cb3450680a3fff33e177e4b3aaf72cc1a" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;21-2-qtgui-qdocconf&quot;&gt;qtgui.qdocconf&lt;/a&gt;:</source>
          <target state="translated">在&lt;a href=&quot;21-2-qtgui-qdocconf&quot;&gt;qtgui.qdocconf中&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="326df58c22c2f4d956b599d5c76613f97da612d3" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;21-2-qtgui-qdocconf#&quot;&gt;qtgui.qdocconf&lt;/a&gt;:</source>
          <target state="translated">在&lt;a href=&quot;21-2-qtgui-qdocconf#&quot;&gt;qtgui.qdocconf中&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="43e96fe070ff544483374b881ecc91e3f74cce5c" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;designer-buddy-mode&quot;&gt;Buddy Editing Mode&lt;/a&gt;, buddy widgets can be assigned to label widgets to help them handle keyboard focus correctly.</source>
          <target state="translated">在&amp;ldquo;&lt;a href=&quot;designer-buddy-mode&quot;&gt;好友编辑模式&amp;rdquo;中&lt;/a&gt;，可以将好友窗口小部件分配给标签窗口小部件，以帮助它们正确处理键盘焦点。</target>
        </trans-unit>
        <trans-unit id="fc97e869e1ad7c93a414a67faa3bae4ef8434220" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;designer-buddy-mode#&quot;&gt;Buddy Editing Mode&lt;/a&gt;, buddy widgets can be assigned to label widgets to help them handle keyboard focus correctly.</source>
          <target state="translated">在&amp;ldquo; &lt;a href=&quot;designer-buddy-mode#&quot;&gt;好友编辑模式&amp;rdquo;下&lt;/a&gt;，可以将好友小部件分配给标签小部件，以帮助它们正确处理键盘焦点。</target>
        </trans-unit>
        <trans-unit id="20f8678fdc6961d3594b0967caf6986e6a681e05" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;designer-connection-mode&quot;&gt;Signals and Slots&lt;/a&gt; mode, we can connect widgets together using Qt's signals and slots mechanism. To switch to this mode, press &lt;b&gt;F4&lt;/b&gt;.</source>
          <target state="translated">在&lt;a href=&quot;designer-connection-mode&quot;&gt;信号和插槽&lt;/a&gt;模式下，我们可以使用Qt的信号和插槽机制将小部件连接在一起。要切换到此模式，请按&lt;b&gt;F4&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="f6dd39d6827fd65d615b8a4204e31b579aead189" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;designer-connection-mode#&quot;&gt;Signals and Slots&lt;/a&gt; mode, we can connect widgets together using Qt's signals and slots mechanism. To switch to this mode, press &lt;b&gt;F4&lt;/b&gt;.</source>
          <target state="translated">在&lt;a href=&quot;designer-connection-mode#&quot;&gt;信号和插槽&lt;/a&gt;模式下，我们可以使用Qt的信号和插槽机制将小部件连接在一起。要切换到此模式，请按&lt;b&gt;F4&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="d79726e8775fc2d74b40dcc52834b92c6546c379" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;designer-tab-order&quot;&gt;Tab Order Editing Mode&lt;/a&gt;, we can set the order in which widgets receive the keyboard focus.</source>
          <target state="translated">在&amp;ldquo;&lt;a href=&quot;designer-tab-order&quot;&gt;标签顺序编辑模式&amp;rdquo;下&lt;/a&gt;，我们可以设置小部件接收键盘焦点的顺序。</target>
        </trans-unit>
        <trans-unit id="befa89ac4b712f09deabc1ee7047cb13c4cc7064" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;designer-tab-order#&quot;&gt;Tab Order Editing Mode&lt;/a&gt;, we can set the order in which widgets receive the keyboard focus.</source>
          <target state="translated">在&amp;ldquo; &lt;a href=&quot;designer-tab-order#&quot;&gt;标签顺序编辑模式&amp;rdquo;下&lt;/a&gt;，我们可以设置小部件接收键盘焦点的顺序。</target>
        </trans-unit>
        <trans-unit id="dd65f7a3440b31faaf73284926ce3c66141e5721" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;designer-widget-mode&quot;&gt;Edit&lt;/a&gt; mode, we can change the appearance of the form, add layouts, and edit the properties of each widget. To switch to this mode, press &lt;b&gt;F3&lt;/b&gt;. This is</source>
          <target state="translated">在&amp;ldquo;&lt;a href=&quot;designer-widget-mode&quot;&gt;编辑&amp;rdquo;&lt;/a&gt;模式下，我们可以更改表单的外观，添加布局以及编辑每个小部件的属性。要切换到此模式，请按&lt;b&gt;F3&lt;/b&gt;键。这是</target>
        </trans-unit>
        <trans-unit id="324244d6ee5e1a69e36c3fcbca02a16a7a7da391" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;designer-widget-mode#&quot;&gt;Edit&lt;/a&gt; mode, we can change the appearance of the form, add layouts, and edit the properties of each widget. To switch to this mode, press &lt;b&gt;F3&lt;/b&gt;. This is</source>
          <target state="translated">在&amp;ldquo; &lt;a href=&quot;designer-widget-mode#&quot;&gt;编辑&amp;rdquo;&lt;/a&gt;模式下，我们可以更改表单的外观，添加布局以及编辑每个小部件的属性。要切换到此模式，请按&lt;b&gt;F3&lt;/b&gt;键。这是</target>
        </trans-unit>
        <trans-unit id="9c2a2a6f0f93bfb60fe81fe8c040ede3a3427534" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtsql-attribution-sqlite.html#sqlite&quot;&gt;SQLite&lt;/a&gt; any column, with the exception of an INTEGER PRIMARY KEY column, may be used to store any type of value. For instance, a column declared as INTEGER may contain an integer value in one row and a text value in the next. This is due to &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtsql-attribution-sqlite.html#sqlite&quot;&gt;SQLite&lt;/a&gt; associating the type of a value with the value itself rather than with the column it is stored in. A consequence of this is that the type returned by &lt;a href=&quot;qsqlfield#type&quot;&gt;QSqlField::type&lt;/a&gt;() only indicates the field's recommended type. No assumption of the actual type should be made from this and the type of the individual values should be checked.</source>
          <target state="translated">在&lt;a href=&quot;https://doc.qt.io/qt-5.13/qtsql-attribution-sqlite.html#sqlite&quot;&gt;SQLite中&lt;/a&gt;，除INTEGER PRIMARY KEY列外，任何列均可用于存储任何类型的值。例如，声明为INTEGER的列可能在一行中包含一个整数值，而在下一行中包含一个文本值。这是由于&lt;a href=&quot;https://doc.qt.io/qt-5.13/qtsql-attribution-sqlite.html#sqlite&quot;&gt;SQLite&lt;/a&gt;将值的类型与值本身而不是与其存储在其中的列相关联。其结果是&lt;a href=&quot;qsqlfield#type&quot;&gt;QSqlField :: type&lt;/a&gt;（）返回的类型仅表示字段的推荐类型。不应以此为基础假设实际类型，而应检查各个值的类型。</target>
        </trans-unit>
        <trans-unit id="898e97b3873a22cd75b80b8186b803d2aa15f688" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtsql-attribution-sqlite.html#sqlite&quot;&gt;SQLite&lt;/a&gt; any column, with the exception of an INTEGER PRIMARY KEY column, may be used to store any type of value. For instance, a column declared as INTEGER may contain an integer value in one row and a text value in the next. This is due to &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtsql-attribution-sqlite.html#sqlite&quot;&gt;SQLite&lt;/a&gt; associating the type of a value with the value itself rather than with the column it is stored in. A consequence of this is that the type returned by &lt;a href=&quot;qsqlfield#type&quot;&gt;QSqlField::type&lt;/a&gt;() only indicates the field's recommended type. No assumption of the actual type should be made from this and the type of the individual values should be checked.</source>
          <target state="translated">在&lt;a href=&quot;https://doc.qt.io/qt-5.15/qtsql-attribution-sqlite.html#sqlite&quot;&gt;SQLite中&lt;/a&gt;，除INTEGER PRIMARY KEY列外，任何列均可用于存储任何类型的值。例如，声明为INTEGER的列可能在一行中包含一个整数值，而在下一行中包含一个文本值。这是由于&lt;a href=&quot;https://doc.qt.io/qt-5.15/qtsql-attribution-sqlite.html#sqlite&quot;&gt;SQLite&lt;/a&gt;将值的类型与值本身而不是与其存储在其中的列相关联。其结果是，由&lt;a href=&quot;qsqlfield#type&quot;&gt;QSqlField :: type&lt;/a&gt;（）返回的类型仅指示字段的推荐类型。不应以此为基础假定实际类型，而应检查各个值的类型。</target>
        </trans-unit>
        <trans-unit id="60ef290d9a3eac6a379a4294f767134f099d9e7a" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtsql-attribution-sqlite.html#sqlite&quot;&gt;SQLite&lt;/a&gt; any column, with the exception of an INTEGER PRIMARY KEY column, may be used to store any type of value. For instance, a column declared as INTEGER may contain an integer value in one row and a text value in the next. This is due to &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtsql-attribution-sqlite.html#sqlite&quot;&gt;SQLite&lt;/a&gt; associating the type of a value with the value itself rather than with the column it is stored in. A consequence of this is that the type returned by QSqlField::type() only indicates the field's recommended type. No assumption of the actual type should be made from this and the type of the individual values should be checked.</source>
          <target state="translated">在&lt;a href=&quot;https://doc.qt.io/qt-6.0/qtsql-attribution-sqlite.html#sqlite&quot;&gt;SQLite中&lt;/a&gt;，除INTEGER PRIMARY KEY列外，任何列均可用于存储任何类型的值。例如，声明为INTEGER的列可能在一行中包含一个整数值，而在下一行中包含一个文本值。这是由于&lt;a href=&quot;https://doc.qt.io/qt-6.0/qtsql-attribution-sqlite.html#sqlite&quot;&gt;SQLite&lt;/a&gt;将值的类型与值本身而不是与其存储在其中的列相关联。其结果是，由QSqlField :: type（）返回的类型仅指示字段的推荐类型。不应以此为基础假定实际类型，而应检查各个值的类型。</target>
        </trans-unit>
        <trans-unit id="1050c82e66e2ca15d3f9f7d14444d78564000618" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;q3dbars&quot;&gt;Q3DBars&lt;/a&gt; from CameraPresetFrontBelow onward these only work for graphs including negative values. They act as Preset...Low for positive-only values.</source>
          <target state="translated">在&lt;a href=&quot;q3dbars&quot;&gt;Q3DBars&lt;/a&gt;从CameraPresetFrontBelow起为图包括负值这些只是工作。对于仅正值，它们充当Preset ... Low。</target>
        </trans-unit>
        <trans-unit id="6b3db1c4c3e1f5b8b9327970bcaa1c06fbddd100" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt;, the notion of uppercase and lowercase and of which character is greater than or less than another character is locale dependent. This affects functions that support a case insensitive option or that compare or lowercase or uppercase their arguments. Case insensitive operations and comparisons will be accurate if both strings contain only ASCII characters. (If &lt;code&gt;$LC_CTYPE&lt;/code&gt; is set, most Unix systems do &quot;the right thing&quot;.) Functions that this affects include &lt;a href=&quot;qbytearray#contains&quot;&gt;contains&lt;/a&gt;(), &lt;a href=&quot;qbytearray#indexOf&quot;&gt;indexOf&lt;/a&gt;(), &lt;a href=&quot;qbytearray#lastIndexOf&quot;&gt;lastIndexOf&lt;/a&gt;(), operator&amp;lt;(), operator&amp;lt;=(), operator&amp;gt;(), operator&amp;gt;=(), &lt;a href=&quot;qbytearray#isLower&quot;&gt;isLower&lt;/a&gt;(), &lt;a href=&quot;qbytearray#isUpper&quot;&gt;isUpper&lt;/a&gt;(), &lt;a href=&quot;qbytearray#toLower&quot;&gt;toLower&lt;/a&gt;() and &lt;a href=&quot;qbytearray#toUpper&quot;&gt;toUpper&lt;/a&gt;().</source>
          <target state="translated">在&lt;a href=&quot;qbytearray&quot;&gt;QByteArray中&lt;/a&gt;，大写和小写以及字符大于或小于另一个字符的概念均取决于语言环境。这会影响支持不区分大小写选项的函数，或者将其参数比较或小写或大写的函数。如果两个字符串都仅包含ASCII字符，则不区分大小写的操作和比较将是准确的。 （如果 &lt;code&gt;$LC_CTYPE&lt;/code&gt; 设置，大部分Unix系统做&amp;ldquo;正确的事情&amp;rdquo;。）的功能，这种影响包括&lt;a href=&quot;qbytearray#contains&quot;&gt;包含&lt;/a&gt;（）&lt;a href=&quot;qbytearray#indexOf&quot;&gt;的indexOf&lt;/a&gt;（），&lt;a href=&quot;qbytearray#lastIndexOf&quot;&gt;lastIndexOf&lt;/a&gt;（），操作员&amp;lt;（）操作符&amp;lt;=（），操作员&amp;gt;（） ，operator&amp;gt; =（），&lt;a href=&quot;qbytearray#isLower&quot;&gt;isLower&lt;/a&gt;（），&lt;a href=&quot;qbytearray#isUpper&quot;&gt;isUpper&lt;/a&gt;（），&lt;a href=&quot;qbytearray#toLower&quot;&gt;toLower&lt;/a&gt;（）和&lt;a href=&quot;qbytearray#toUpper&quot;&gt;toUpper&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="5bc9e99a66225747d294b3acd8055641ed98310b" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;qml-qtquick-borderimage&quot;&gt;BorderImage&lt;/a&gt;, this property is read-only.</source>
          <target state="translated">在&lt;a href=&quot;qml-qtquick-borderimage&quot;&gt;BorderImage中&lt;/a&gt;，此属性为只读。</target>
        </trans-unit>
        <trans-unit id="f4f7b3d5772d8f9ff07fed8bd3c99db10e91db64" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;qopenglwidget#paintGL&quot;&gt;paintGL&lt;/a&gt;() the current context is always accessible by caling &lt;a href=&quot;qopenglcontext#currentContext&quot;&gt;QOpenGLContext::currentContext&lt;/a&gt;(). From this context an already initialized, ready-to-be-used &lt;a href=&quot;https://doc.qt.io/qt-5.13/qopenglfunctions.html&quot;&gt;QOpenGLFunctions&lt;/a&gt; instance is retrievable by calling &lt;a href=&quot;qopenglcontext#functions&quot;&gt;QOpenGLContext::functions&lt;/a&gt;(). An alternative to prefixing every GL call is to inherit from &lt;a href=&quot;https://doc.qt.io/qt-5.13/qopenglfunctions.html&quot;&gt;QOpenGLFunctions&lt;/a&gt; and call &lt;a href=&quot;https://doc.qt.io/qt-5.13/qopenglfunctions.html#initializeOpenGLFunctions&quot;&gt;QOpenGLFunctions::initializeOpenGLFunctions&lt;/a&gt;() in &lt;a href=&quot;qopenglwidget#initializeGL&quot;&gt;initializeGL&lt;/a&gt;().</source>
          <target state="translated">在&lt;a href=&quot;qopenglwidget#paintGL&quot;&gt;paintGL&lt;/a&gt;（）中，始终可以通过&lt;a href=&quot;qopenglcontext#currentContext&quot;&gt;校准QOpenGLContext :: currentContext&lt;/a&gt;（）来访问当前上下文。从该上下文中，可以通过调用&lt;a href=&quot;qopenglcontext#functions&quot;&gt;QOpenGLContext :: functions&lt;/a&gt;（）来检索已经初始化且可以使用的&lt;a href=&quot;https://doc.qt.io/qt-5.13/qopenglfunctions.html&quot;&gt;QOpenGLFunctions&lt;/a&gt;实例。给每个GL调用加前缀的一种替代方法是从&lt;a href=&quot;https://doc.qt.io/qt-5.13/qopenglfunctions.html&quot;&gt;QOpenGLFunctions&lt;/a&gt;继承并在&lt;a href=&quot;qopenglwidget#initializeGL&quot;&gt;initializeGL&lt;/a&gt;（）中调用&lt;a href=&quot;https://doc.qt.io/qt-5.13/qopenglfunctions.html#initializeOpenGLFunctions&quot;&gt;QOpenGLFunctions :: &lt;/a&gt;initializeOpenGLFunctions（）。</target>
        </trans-unit>
        <trans-unit id="1790ecbaee738c1c9ed2015b2526d7bd8d2a3226" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;qopenglwidget#paintGL&quot;&gt;paintGL&lt;/a&gt;() the current context is always accessible by caling &lt;a href=&quot;qopenglcontext#currentContext&quot;&gt;QOpenGLContext::currentContext&lt;/a&gt;(). From this context an already initialized, ready-to-be-used &lt;a href=&quot;https://doc.qt.io/qt-5.15/qopenglfunctions.html&quot;&gt;QOpenGLFunctions&lt;/a&gt; instance is retrievable by calling &lt;a href=&quot;qopenglcontext#functions&quot;&gt;QOpenGLContext::functions&lt;/a&gt;(). An alternative to prefixing every GL call is to inherit from &lt;a href=&quot;https://doc.qt.io/qt-5.15/qopenglfunctions.html&quot;&gt;QOpenGLFunctions&lt;/a&gt; and call &lt;a href=&quot;https://doc.qt.io/qt-5.15/qopenglfunctions.html#initializeOpenGLFunctions&quot;&gt;QOpenGLFunctions::initializeOpenGLFunctions&lt;/a&gt;() in &lt;a href=&quot;qopenglwidget#initializeGL&quot;&gt;initializeGL&lt;/a&gt;().</source>
          <target state="translated">在&lt;a href=&quot;qopenglwidget#paintGL&quot;&gt;paintGL&lt;/a&gt;（）中，始终可以通过&lt;a href=&quot;qopenglcontext#currentContext&quot;&gt;校准QOpenGLContext :: currentContext&lt;/a&gt;（）来访问当前上下文。从该上下文中，可以通过调用&lt;a href=&quot;qopenglcontext#functions&quot;&gt;QOpenGLContext :: functions&lt;/a&gt;（）来检索已初始化且可以使用的&lt;a href=&quot;https://doc.qt.io/qt-5.15/qopenglfunctions.html&quot;&gt;QOpenGLFunctions&lt;/a&gt;实例。给每个GL调用&lt;a href=&quot;https://doc.qt.io/qt-5.15/qopenglfunctions.html&quot;&gt;加上&lt;/a&gt;前缀的替代方法是从QOpenGLFunctions继承并在&lt;a href=&quot;qopenglwidget#initializeGL&quot;&gt;initializeGL&lt;/a&gt;（）中调用&lt;a href=&quot;https://doc.qt.io/qt-5.15/qopenglfunctions.html#initializeOpenGLFunctions&quot;&gt;QOpenGLFunctions :: &lt;/a&gt;initializeOpenGLFunctions（）。</target>
        </trans-unit>
        <trans-unit id="2eb67d9f79eb958abe5843b7c98aee45219b673e" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;qopenglwidget#paintGL&quot;&gt;paintGL&lt;/a&gt;() the current context is always accessible by caling &lt;a href=&quot;qopenglcontext#currentContext&quot;&gt;QOpenGLContext::currentContext&lt;/a&gt;(). From this context an already initialized, ready-to-be-used &lt;a href=&quot;https://doc.qt.io/qt-6.0/qopenglfunctions.html&quot;&gt;QOpenGLFunctions&lt;/a&gt; instance is retrievable by calling &lt;a href=&quot;qopenglcontext#functions&quot;&gt;QOpenGLContext::functions&lt;/a&gt;(). An alternative to prefixing every GL call is to inherit from &lt;a href=&quot;https://doc.qt.io/qt-6.0/qopenglfunctions.html&quot;&gt;QOpenGLFunctions&lt;/a&gt; and call &lt;a href=&quot;https://doc.qt.io/qt-6.0/qopenglfunctions.html#initializeOpenGLFunctions&quot;&gt;QOpenGLFunctions::initializeOpenGLFunctions&lt;/a&gt;() in &lt;a href=&quot;qopenglwidget#initializeGL&quot;&gt;initializeGL&lt;/a&gt;().</source>
          <target state="translated">在&lt;a href=&quot;qopenglwidget#paintGL&quot;&gt;paintGL&lt;/a&gt;（）中，始终可以通过&lt;a href=&quot;qopenglcontext#currentContext&quot;&gt;校准QOpenGLContext :: currentContext&lt;/a&gt;（）来访问当前上下文。从该上下文中，可以通过调用&lt;a href=&quot;qopenglcontext#functions&quot;&gt;QOpenGLContext :: functions&lt;/a&gt;（）来检索已初始化且可以使用的&lt;a href=&quot;https://doc.qt.io/qt-6.0/qopenglfunctions.html&quot;&gt;QOpenGLFunctions&lt;/a&gt;实例。给每个GL调用&lt;a href=&quot;https://doc.qt.io/qt-6.0/qopenglfunctions.html&quot;&gt;加上&lt;/a&gt;前缀的替代方法是从QOpenGLFunctions继承并在&lt;a href=&quot;qopenglwidget#initializeGL&quot;&gt;initializeGL&lt;/a&gt;（）中调用&lt;a href=&quot;https://doc.qt.io/qt-6.0/qopenglfunctions.html#initializeOpenGLFunctions&quot;&gt;QOpenGLFunctions :: &lt;/a&gt;initializeOpenGLFunctions（）。</target>
        </trans-unit>
        <trans-unit id="e22d59b4ac15f2934ae0f539de702d29edbada1a" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;qopenglwidget#paintGL&quot;&gt;paintGL&lt;/a&gt;(), instead of issuing OpenGL commands, construct a &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; object for use on the widget.</source>
          <target state="translated">在&lt;a href=&quot;qopenglwidget#paintGL&quot;&gt;paintGL&lt;/a&gt;（）中，代替发出OpenGL命令，构造一个&lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;对象以在小部件上使用。</target>
        </trans-unit>
        <trans-unit id="102f20572c1558e58f97f35a68a42d4742462282" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;qpagelayout#Mode-enum&quot;&gt;FullPageMode&lt;/a&gt; the current margins and minimum margins are not taken into account. The paintable rectangle is the full page rectangle, and the current margins can be set to any values regardless of the minimum margins and page size.</source>
          <target state="translated">在&lt;a href=&quot;qpagelayout#Mode-enum&quot;&gt;FullPageMode中&lt;/a&gt;，不考虑当前边距和最小边距。可绘制矩形是整页矩形，并且当前边距可以设置为任何值，而不管最小边距和页面大小如何。</target>
        </trans-unit>
        <trans-unit id="4533bb0f381ac4db27f694953828d813df5eb651" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;qregexp&quot;&gt;QRegExp&lt;/a&gt;, apart from within character classes, &lt;code&gt;^&lt;/code&gt; always signifies the start of the string, so carets must always be escaped unless used for that purpose. In Perl the meaning of caret varies automagically depending on where it occurs so escaping it is rarely necessary. The same applies to &lt;code&gt;$&lt;/code&gt; which in &lt;a href=&quot;qregexp&quot;&gt;QRegExp&lt;/a&gt; always signifies the end of the string.</source>
          <target state="translated">在&lt;a href=&quot;qregexp&quot;&gt;QRegExp中&lt;/a&gt;，除了在字符类中之外， &lt;code&gt;^&lt;/code&gt; 始终表示字符串的开头，因此，除非用于此目的，否则必须始终对插入符号进行转义。在Perl中，插入记号的含义会根据其出现的位置而自动变化，因此很少需要转义。同样适用于 &lt;code&gt;$&lt;/code&gt; ，&lt;a href=&quot;qregexp&quot;&gt;QRegExp中的&lt;/a&gt;$始终表示字符串的结尾。</target>
        </trans-unit>
        <trans-unit id="34c7461c83e0322301f1f0463aacd703e90a1ac4" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;qregexp&quot;&gt;QRegExp&lt;/a&gt;&lt;b&gt;.&lt;/b&gt; matches any character, therefore all &lt;a href=&quot;qregexp&quot;&gt;QRegExp&lt;/a&gt; regexps have the equivalent of Perl's &lt;code&gt;/s&lt;/code&gt; option. &lt;a href=&quot;qregexp&quot;&gt;QRegExp&lt;/a&gt; does not have an equivalent to Perl's &lt;code&gt;/m&lt;/code&gt; option, but this can be emulated in various ways for example by splitting the input into lines or by looping with a regexp that searches for newlines.</source>
          <target state="translated">在&lt;a href=&quot;qregexp&quot;&gt;QRegExp中&lt;/a&gt;&lt;b&gt;。&lt;/b&gt;匹配任何字符，因此所有&lt;a href=&quot;qregexp&quot;&gt;QRegExp正则表达式&lt;/a&gt;都具有Perl的 &lt;code&gt;/s&lt;/code&gt; 选项。&lt;a href=&quot;qregexp&quot;&gt;QRegExp&lt;/a&gt;不具有与Perl的 &lt;code&gt;/m&lt;/code&gt; 选项等效的功能，但是可以通过多种方式进行模拟，例如，将输入分成几行，或者使用搜索新行的regexp循环。</target>
        </trans-unit>
        <trans-unit id="d78103a0bf29f3ac831f14a2cce77ea4ec4d796b" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;qsqltablemodel#EditStrategy-enum&quot;&gt;OnManualSubmit&lt;/a&gt;, on success the model will be repopulated. Any views presenting it will lose their selections.</source>
          <target state="translated">在&lt;a href=&quot;qsqltablemodel#EditStrategy-enum&quot;&gt;OnManualSubmit中&lt;/a&gt;，成功后将重新填充模型。呈现它的所有视图都将丢失选择。</target>
        </trans-unit>
        <trans-unit id="78182114514d11701af8135a7229828fbb5e805c" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;qsslsocket&quot;&gt;QSslSocket&lt;/a&gt;, the function that returns a list of errors encountered during the TLS handshake:</source>
          <target state="translated">在&lt;a href=&quot;qsslsocket&quot;&gt;QSslSocket中&lt;/a&gt;，该函数返回TLS握手期间遇到的错误的列表：</target>
        </trans-unit>
        <trans-unit id="c0815e431a0586bbc8bf11a6e0c1f906926f248e" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;qtconcurrentrun#concurrent-run-basic-mode&quot;&gt;basic mode&lt;/a&gt; T is the same type as the return value of</source>
          <target state="translated">在&lt;a href=&quot;qtconcurrentrun#concurrent-run-basic-mode&quot;&gt;基本模式下，&lt;/a&gt; T与返回值的类型相同</target>
        </trans-unit>
        <trans-unit id="2f2e6405f459bccd46c0e2d2dbd790000ae9ad47" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;qtconcurrentrun#concurrent-run-basic-mode&quot;&gt;basic mode&lt;/a&gt; the &lt;a href=&quot;qtcore-changes-qt6#qfuture&quot;&gt;QFuture&lt;/a&gt; returned can only be used to query for the running/finished status and the return value of the function. In particular, canceling or pausing can be issued only if the computations behind the future has not been started.</source>
          <target state="translated">在&lt;a href=&quot;qtconcurrentrun#concurrent-run-basic-mode&quot;&gt;基本模式下&lt;/a&gt;，返回的&lt;a href=&quot;qtcore-changes-qt6#qfuture&quot;&gt;QFuture&lt;/a&gt;仅可用于查询函数的运行/完成状态和返回值。特别是，只有在未开始进行将来的计算时，才可以发出取消或暂停的命令。</target>
        </trans-unit>
        <trans-unit id="d152b4de6b440309c8f0f7675e16bd461297908f" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;qtconcurrentrun#concurrent-run-with-promise&quot;&gt;run with promise mode&lt;/a&gt;, similar to</source>
          <target state="translated">在&lt;a href=&quot;qtconcurrentrun#concurrent-run-with-promise&quot;&gt;使用promise模式运行时&lt;/a&gt;，类似于</target>
        </trans-unit>
        <trans-unit id="9db1135bee62928f27c6abade8b83add964defdd" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;qtconcurrentrun#concurrent-run-with-promise&quot;&gt;run with promise mode&lt;/a&gt;, the</source>
          <target state="translated">在&lt;a href=&quot;qtconcurrentrun#concurrent-run-with-promise&quot;&gt;以诺言模式运行时&lt;/a&gt;，</target>
        </trans-unit>
        <trans-unit id="c3805adeb8f7382fb11b5374382478b33c1eaf86" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt;, all expressions evaluate to a sequence of items, where each item is either an XML node or an atomic value. The query in the following snippet evaluates to sequence of five items.</source>
          <target state="translated">在&lt;a href=&quot;xmlprocessing&quot;&gt;XQuery中&lt;/a&gt;，所有表达式求值为一个项目序列，其中每个项目都是XML节点或原子值。以下代码段中的查询计算得出五个项目的序列。</target>
        </trans-unit>
        <trans-unit id="0f03eae54f7019c0beb9b13d3a72c5ddc05e8d46" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt;, all expressions evaluate to a sequence of items, where each item is either an XML node or an atomic value. The query in the following snippet evaluates to sequence of five items.</source>
          <target state="translated">在&lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery中&lt;/a&gt;，所有表达式求值为一个项目序列，其中每个项目都是XML节点或原子值。以下代码段中的查询计算得出五个项目的序列。</target>
        </trans-unit>
        <trans-unit id="6782b899ab6ca676331734f74e7c9e743ad57f85" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Employee&lt;/code&gt;'s</source>
          <target state="translated">在 &lt;code&gt;Employee&lt;/code&gt; 的</target>
        </trans-unit>
        <trans-unit id="e0b0f3a86f2a2b1ee87ffd729f3f0a5da1700e61" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;QtQuick 2.0&lt;/code&gt;, support has been added to allow JavaScript resources to import other JavaScript resources and also QML type namespaces using a variation of the standard QML import syntax (where all of the previously described rules and qualifications apply).</source>
          <target state="translated">在 &lt;code&gt;QtQuick 2.0&lt;/code&gt; 中，添加了支持以允许JavaScript资源使用标准QML导入语法的变体（适用所有先前描述的规则和限定条件）来导入其他JavaScript资源以及QML类型的名称空间。</target>
        </trans-unit>
        <trans-unit id="f002fd20f8e2ac83f670273f937d744bfb5c712d" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;main.cpp&lt;/code&gt;, we use a &lt;a href=&quot;qsharedpointer&quot;&gt;QSharedPointer&lt;/a&gt; to hold a replica of the remote object, and then instantiate a replica requestor object:</source>
          <target state="translated">在 &lt;code&gt;main.cpp&lt;/code&gt; 中，我们使用&lt;a href=&quot;qsharedpointer&quot;&gt;QSharedPointer&lt;/a&gt;来保存远程对象的副本，然后实例化副本请求者对象：</target>
        </trans-unit>
        <trans-unit id="1dfd9f2d68bfedf825e1117ada8dd3b697e0b246" translate="yes" xml:space="preserve">
          <source>In C++ and Java, we write nested &lt;code&gt;for&lt;/code&gt; loops and recursive functions to traverse XML trees in search of elements of interest. In &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt;, we write these iterative and recursive algorithms with</source>
          <target state="translated">在C ++和Java中，我们编写嵌套的 &lt;code&gt;for&lt;/code&gt; 循环和递归函数以遍历XML树以查找感兴趣的元素。在&lt;a href=&quot;xmlprocessing&quot;&gt;XQuery中&lt;/a&gt;，我们使用以下代码编写了这些迭代和递归算法：</target>
        </trans-unit>
        <trans-unit id="7ee66d17b8b208295a43cee0e9053ad98a73d31d" translate="yes" xml:space="preserve">
          <source>In C++ and Java, we write nested &lt;code&gt;for&lt;/code&gt; loops and recursive functions to traverse XML trees in search of elements of interest. In &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt;, we write these iterative and recursive algorithms with</source>
          <target state="translated">在C ++和Java中，我们编写嵌套的 &lt;code&gt;for&lt;/code&gt; 循环和递归函数以遍历XML树以查找感兴趣的元素。在&lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery中&lt;/a&gt;，我们使用以下代码编写这些迭代和递归算法</target>
        </trans-unit>
        <trans-unit id="b8246f73abc937e67247e5ba24850b15f3aaac07" translate="yes" xml:space="preserve">
          <source>In C++, a route query is performed using the &lt;a href=&quot;qgeoroutingmanager#calculateRoute&quot;&gt;calculate()&lt;/a&gt; method of the &lt;a href=&quot;qgeoroutingmanager&quot;&gt;QGeoRoutingManager&lt;/a&gt; class. The returned route reply can contain multiple routes to the same destination.</source>
          <target state="translated">在C ++中，使用&lt;a href=&quot;qgeoroutingmanager&quot;&gt;QGeoRoutingManager&lt;/a&gt;类的compute &lt;a href=&quot;qgeoroutingmanager#calculateRoute&quot;&gt;（）&lt;/a&gt;方法执行路由查询。返回的路由回复可以包含到同一目的地的多个路由。</target>
        </trans-unit>
        <trans-unit id="7523558bb10e86aa6ac1d9a9f29b12513317cc38" translate="yes" xml:space="preserve">
          <source>In C++, an address-to-coordinate query is performed using the &lt;a href=&quot;qgeocodingmanager#geocode&quot;&gt;geocode()&lt;/a&gt; method of the &lt;a href=&quot;qgeocodingmanager&quot;&gt;QGeoCodingManager&lt;/a&gt; class. For coordinate-to-address queries, the &lt;a href=&quot;qgeocodingmanager#reverseGeocode&quot;&gt;reverseGeocode()&lt;/a&gt; method is available on the same class. Instances of &lt;a href=&quot;qgeocodingmanager&quot;&gt;QGeoCodingManager&lt;/a&gt; are available via &lt;a href=&quot;qgeoserviceprovider&quot;&gt;QGeoServiceProvider&lt;/a&gt;.</source>
          <target state="translated">在C ++中，使用&lt;a href=&quot;qgeocodingmanager&quot;&gt;QGeoCodingManager&lt;/a&gt;类的&lt;a href=&quot;qgeocodingmanager#geocode&quot;&gt;geocode（）&lt;/a&gt;方法执行地址到坐标的查询。对于坐标到地址的查询，&lt;a href=&quot;qgeocodingmanager#reverseGeocode&quot;&gt;reverseGeocode（）&lt;/a&gt;方法在同一类上可用。实例&lt;a href=&quot;qgeocodingmanager&quot;&gt;QGeoCodingManager&lt;/a&gt;通过提供&lt;a href=&quot;qgeoserviceprovider&quot;&gt;QGeoServiceProvider&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="25333e58b1d0f590a3c010b5ff102f4d6a7128df" translate="yes" xml:space="preserve">
          <source>In C++17 mode, &lt;code&gt;q_no_char8_t&lt;/code&gt; is an inline namespace, in C++20 it's &lt;code&gt;q_has_char8_t&lt;/code&gt;. This means that the name &quot;QUtf8StringView&quot; (without explicit namespace) will denote different types in C++17 and C++20 modes.</source>
          <target state="translated">在C ++ 17模式下， &lt;code&gt;q_no_char8_t&lt;/code&gt; 是一个内联命名空间，在C ++ 20中，它是 &lt;code&gt;q_has_char8_t&lt;/code&gt; 。这意味着名称&amp;ldquo; QUtf8StringView&amp;rdquo;（无显式命名空间）将表示C ++ 17和C ++ 20模式下的不同类型。</target>
        </trans-unit>
        <trans-unit id="2693f757fed72c00a8210bf6426fa3a3557bcfb0" translate="yes" xml:space="preserve">
          <source>In C++20, &lt;code&gt;u8&quot;&quot;&lt;/code&gt; string literals changed their type from &lt;code&gt;const char[]&lt;/code&gt; to &lt;code&gt;const char8_t[]&lt;/code&gt;. If Qt 6 could have depended on C++20, QUtf8StringView would store &lt;code&gt;char8_t&lt;/code&gt; natively, and the following functions and aliases would use (pointers to) &lt;code&gt;char8_t&lt;/code&gt;:</source>
          <target state="translated">在C ++ 20中， &lt;code&gt;u8&quot;&quot;&lt;/code&gt; 字符串文字的类型从 &lt;code&gt;const char[]&lt;/code&gt; 更改为 &lt;code&gt;const char8_t[]&lt;/code&gt; 。如果Qt 6可能依赖于C ++ 20，则QUtf8StringView将本地存储 &lt;code&gt;char8_t&lt;/code&gt; ，并且以下函数和别名将使用（指向） &lt;code&gt;char8_t&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b9950c40c08c3eb37f9da6294b4ac50817b59124" translate="yes" xml:space="preserve">
          <source>In D-Bus, all method calls must generate a reply to the caller, unless the caller explicitly indicates otherwise (see &lt;a href=&quot;qdbusmessage#isReplyRequired&quot;&gt;isReplyRequired&lt;/a&gt;()). &lt;a href=&quot;qtdbus-index&quot;&gt;QtDBus&lt;/a&gt; automatically generates such replies for any slots being called, but it also allows slots to indicate whether they will take responsibility of sending the reply at a later time, after the function has finished processing.</source>
          <target state="translated">在D-Bus中，所有方法调用都必须生成对调用者的答复，除非调用者明确指出不这样做（请参见&lt;a href=&quot;qdbusmessage#isReplyRequired&quot;&gt;isReplyRequired&lt;/a&gt;（））。&lt;a href=&quot;qtdbus-index&quot;&gt;QtDBus会&lt;/a&gt;为正在调用的任何插槽自动生成此类回复，但它也允许插槽指示在函数完成处理之后，它们是否将在以后的时间发送回复。</target>
        </trans-unit>
        <trans-unit id="9d63ba0bbdb26f139be11b6b67022482e1fc2523" translate="yes" xml:space="preserve">
          <source>In D-Bus, all method calls must generate a reply to the caller, unless the caller explicitly indicates otherwise (see &lt;a href=&quot;qdbusmessage#isReplyRequired&quot;&gt;isReplyRequired&lt;/a&gt;()). &lt;a href=&quot;qtdbus-index#&quot;&gt;QtDBus&lt;/a&gt; automatically generates such replies for any slots being called, but it also allows slots to indicate whether they will take responsibility of sending the reply at a later time, after the function has finished processing.</source>
          <target state="translated">在D-Bus中，所有方法调用都必须生成对调用者的答复，除非调用者明确指出不这样做（请参见&lt;a href=&quot;qdbusmessage#isReplyRequired&quot;&gt;isReplyRequired&lt;/a&gt;（））。&lt;a href=&quot;qtdbus-index#&quot;&gt;QtDBus会&lt;/a&gt;为正在调用的任何插槽自动生成此类答复，但它也允许插槽指示在函数完成处理后，它们是否将在以后的时间发送答复。</target>
        </trans-unit>
        <trans-unit id="0c48781818edf5ae7431830c82f2ce26575af0fa" translate="yes" xml:space="preserve">
          <source>In GUI programming, when we ...</source>
          <target state="translated">在GUI编程中,当我们 ...</target>
        </trans-unit>
        <trans-unit id="31787f727b5520489db1141c1a2618ab4880194c" translate="yes" xml:space="preserve">
          <source>In GUI programming, when we change one widget, we often want another widget to be notified. More generally, we want objects of any kind to be able to communicate with one another. For example, if a user clicks a &lt;b&gt;Close&lt;/b&gt; button, we probably want the window's &lt;a href=&quot;qwidget#close&quot;&gt;close()&lt;/a&gt; function to be called.</source>
          <target state="translated">在GUI编程中，当我们更改一个小部件时，我们通常希望通知另一个小部件。更一般而言，我们希望任何类型的对象都能够相互通信。例如，如果用户单击&amp;ldquo; &lt;b&gt;关闭&amp;rdquo;&lt;/b&gt;按钮，我们可能希望调用窗口的&lt;a href=&quot;qwidget#close&quot;&gt;close（）&lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="6f84352494b204af5b471d74c1ca517b2a721430" translate="yes" xml:space="preserve">
          <source>In IDE integrations, a list of the project's resource (.qrc) file can be activated, making them available to</source>
          <target state="translated">在IDE集成中,可以激活项目的资源(.qrc)文件列表,使它们可用于</target>
        </trans-unit>
        <trans-unit id="62363fbd2cc3e4782808c14ad9017dcf0038e307" translate="yes" xml:space="preserve">
          <source>In INI files, &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; uses the &lt;code&gt;@&lt;/code&gt; character as a metacharacter in some contexts, to encode Qt-specific data types (e.g., &lt;code&gt;@Rect&lt;/code&gt;), and might therefore misinterpret it when it occurs in pure INI files.</source>
          <target state="translated">在INI文件中，&lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt;在某些情况下使用 &lt;code&gt;@&lt;/code&gt; 字符作为元字符，以编码特定于Qt的数据类型（例如 &lt;code&gt;@Rect&lt;/code&gt; ），因此当它出现在纯INI文件中时可能会误解它。</target>
        </trans-unit>
        <trans-unit id="a9b31585e2b74e16f24f709a4bd7694e401f7c10" translate="yes" xml:space="preserve">
          <source>In INI files, QSettings uses the &lt;code&gt;@&lt;/code&gt; character as a metacharacter in some contexts, to encode Qt-specific data types (e.g., &lt;code&gt;@Rect&lt;/code&gt;), and might therefore misinterpret it when it occurs in pure INI files.</source>
          <target state="translated">在INI文件中，QSettings在某些情况下使用 &lt;code&gt;@&lt;/code&gt; 字符作为元字符来编码特定于Qt的数据类型（例如 &lt;code&gt;@Rect&lt;/code&gt; ），因此，当它出现在纯INI文件中时，可能会误解它。</target>
        </trans-unit>
        <trans-unit id="905f97c6279f4dcfcd08709b37c0645cd9237913" translate="yes" xml:space="preserve">
          <source>In Linux/X11 platforms, Qt provides support for session management. Sessions allow events to be propagated to processes, for example, to notify when a shutdown occurs. The process and applications can then perform any necessary operations such as save open documents.</source>
          <target state="translated">在Linux/X11平台上,Qt提供了对会话管理的支持。会话允许将事件传播给进程,例如,在关闭发生时通知。然后,进程和应用程序可以执行任何必要的操作,如保存打开的文档。</target>
        </trans-unit>
        <trans-unit id="73d12a549b6815a3e8aedfb9e069dc81f7801462" translate="yes" xml:space="preserve">
          <source>In Makefile mode, qmake will generate a Makefile that is used to build the project. Additionally, the following options may be used in this mode to influence the way the project file is generated:</source>
          <target state="translated">在Makefile模式下,qmake将生成一个Makefile,用于构建项目。此外,在此模式下,以下选项可以用来影响项目文件的生成方式。</target>
        </trans-unit>
        <trans-unit id="dc791c8db7c5d33265eb9f97a69fca3d32a0e650" translate="yes" xml:space="preserve">
          <source>In QByteArray, the notion of uppercase and lowercase and of case-independent comparison is limited to ASCII. Non-ASCII characters are treated as caseless, since their case depends on encoding. This affects functions that support a case insensitive option or that change the case of their arguments. Functions that this affects include &lt;a href=&quot;qbytearray#contains&quot;&gt;contains&lt;/a&gt;(), &lt;a href=&quot;qbytearray#indexOf&quot;&gt;indexOf&lt;/a&gt;(), &lt;a href=&quot;qbytearray#lastIndexOf&quot;&gt;lastIndexOf&lt;/a&gt;(), &lt;a href=&quot;qbytearray#isLower&quot;&gt;isLower&lt;/a&gt;(), &lt;a href=&quot;qbytearray#isUpper&quot;&gt;isUpper&lt;/a&gt;(), &lt;a href=&quot;qbytearray#toLower&quot;&gt;toLower&lt;/a&gt;() and &lt;a href=&quot;qbytearray#toUpper&quot;&gt;toUpper&lt;/a&gt;().</source>
          <target state="translated">在QByteArray中，大写和小写以及不区分大小写的比较的概念仅限于ASCII。非ASCII字符被视为无大小写，因为它们的大小写取决于编码。这会影响支持不区分大小写选项或更改其参数大小写的函数。这会影响的函数包括&lt;a href=&quot;qbytearray#contains&quot;&gt;contains&lt;/a&gt;（），&lt;a href=&quot;qbytearray#indexOf&quot;&gt;indexOf&lt;/a&gt;（），&lt;a href=&quot;qbytearray#lastIndexOf&quot;&gt;lastIndexOf&lt;/a&gt;（），&lt;a href=&quot;qbytearray#isLower&quot;&gt;isLower&lt;/a&gt;（），&lt;a href=&quot;qbytearray#isUpper&quot;&gt;isUpper&lt;/a&gt;（），&lt;a href=&quot;qbytearray#toLower&quot;&gt;toLower&lt;/a&gt;（）和&lt;a href=&quot;qbytearray#toUpper&quot;&gt;toUpper&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="c9e47542165cfda58cd7234b9ff957197fb37acd" translate="yes" xml:space="preserve">
          <source>In QByteArray, the notion of uppercase and lowercase and of which character is greater than or less than another character is done in the Latin-1 locale. This affects functions that support a case insensitive option or that compare or lowercase or uppercase their arguments. Case insensitive operations and comparisons will be accurate if both strings contain only Latin-1 characters. Functions that this affects include &lt;a href=&quot;qbytearray#contains&quot;&gt;contains&lt;/a&gt;(), &lt;a href=&quot;qbytearray#indexOf&quot;&gt;indexOf&lt;/a&gt;(), &lt;a href=&quot;qbytearray#lastIndexOf&quot;&gt;lastIndexOf&lt;/a&gt;(), operator&amp;lt;(), operator&amp;lt;=(), operator&amp;gt;(), operator&amp;gt;=(), &lt;a href=&quot;qbytearray#isLower&quot;&gt;isLower&lt;/a&gt;(), &lt;a href=&quot;qbytearray#isUpper&quot;&gt;isUpper&lt;/a&gt;(), &lt;a href=&quot;qbytearray#toLower&quot;&gt;toLower&lt;/a&gt;() and &lt;a href=&quot;qbytearray#toUpper&quot;&gt;toUpper&lt;/a&gt;().</source>
          <target state="translated">在QByteArray中，在Latin-1语言环境中完成了大写和小写以及字符大于或小于另一个字符的概念。这会影响支持不区分大小写的选项的函数，或者比较或区分大小写其参数的函数。如果两个字符串都仅包含Latin-1字符，则不区分大小写的操作和比较将是准确的。功能，这将影响包括&lt;a href=&quot;qbytearray#contains&quot;&gt;包含&lt;/a&gt;（），&lt;a href=&quot;qbytearray#indexOf&quot;&gt;的indexOf&lt;/a&gt;（），&lt;a href=&quot;qbytearray#lastIndexOf&quot;&gt;lastIndexOf&lt;/a&gt;（），操作员&amp;lt;（），操作员&amp;lt;=（），操作员&amp;gt;（），操作员&amp;gt; =（），&lt;a href=&quot;qbytearray#isLower&quot;&gt;islower判断&lt;/a&gt;（），&lt;a href=&quot;qbytearray#isUpper&quot;&gt;isUpper&lt;/a&gt;（），&lt;a href=&quot;qbytearray#toLower&quot;&gt;tolower的&lt;/a&gt;（）和&lt;a href=&quot;qbytearray#toUpper&quot;&gt;toUpper&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="2bc0d992d39dfda70e0f80268f798c93a5d51ef0" translate="yes" xml:space="preserve">
          <source>In QML,</source>
          <target state="translated">在QML中。</target>
        </trans-unit>
        <trans-unit id="fe5505bb833d413930f5af4b4c8cd44370f07e50" translate="yes" xml:space="preserve">
          <source>In QML, a</source>
          <target state="translated">在QML中,一个</target>
        </trans-unit>
        <trans-unit id="22b722de1b0f5b29d1bf6d421694efa7e9f547a3" translate="yes" xml:space="preserve">
          <source>In QML, component instances connect their component scopes together to form a scope hierarchy. Component instances can directly access the component scopes of their ancestors.</source>
          <target state="translated">在 QML 中,组件实例将它们的组件作用域连接在一起,形成一个作用域层次结构。组件实例可以直接访问它们祖先的组件作用域。</target>
        </trans-unit>
        <trans-unit id="d9a2d2687b22a0d2440a26c33ff38b069da1cb2a" translate="yes" xml:space="preserve">
          <source>In QML, it's possible to use imperative JavaScript code to perform tasks such as responding to input events, send data over a network, and so on. Imperative code has an important place in QML, but it's also important to be aware of when not to use it.</source>
          <target state="translated">在QML中,可以使用命令式JavaScript代码来执行任务,如响应输入事件、通过网络发送数据等。命令式代码在QML中有着重要的地位,但也要注意什么时候不使用它。</target>
        </trans-unit>
        <trans-unit id="4817b38a259ab07481a7c7925d3e1e9762e26743" translate="yes" xml:space="preserve">
          <source>In QML, property bindings result in a dependency between the properties of different objects.</source>
          <target state="translated">在QML中,属性绑定导致了不同对象的属性之间的依赖性。</target>
        </trans-unit>
        <trans-unit id="d17cf5cce9a4ef8a72686f5c9a62f3434aeff0d5" translate="yes" xml:space="preserve">
          <source>In QML, the global object is constant - existing properties cannot be modified or deleted, and no new properties may be created.</source>
          <target state="translated">在QML中,全局对象是恒定的--不能修改或删除现有的属性,也不能创建新的属性。</target>
        </trans-unit>
        <trans-unit id="6d0496769a4fb551ed19f7a9a3ad7bfe94ae4251" translate="yes" xml:space="preserve">
          <source>In QML, this would normally result in both the default &lt;code&gt;background&lt;/code&gt; implementation and the one-off, custom &lt;code&gt;background&lt;/code&gt; items being created. Qt Quick Controls uses a technique that avoids creating both items, and instead only creates the custom &lt;code&gt;background&lt;/code&gt;, greatly improving the creation performance of controls.</source>
          <target state="translated">在QML中，这通常会导致默认 &lt;code&gt;background&lt;/code&gt; 实现和一次性创建的自定义 &lt;code&gt;background&lt;/code&gt; 项被创建。Qt快速控件使用一种避免创建两个项目的技术，而是仅创建自定义 &lt;code&gt;background&lt;/code&gt; ，从而大大提高了控件的创建性能。</target>
        </trans-unit>
        <trans-unit id="45f9c39be1612fa3a972201b91a8e35401843622" translate="yes" xml:space="preserve">
          <source>In QML, we assign a string to the &lt;code&gt;baz&lt;/code&gt; property of &lt;code&gt;bar&lt;/code&gt;:</source>
          <target state="translated">在QML中，我们为 &lt;code&gt;bar&lt;/code&gt; 的 &lt;code&gt;baz&lt;/code&gt; 属性分配一个字符串：</target>
        </trans-unit>
        <trans-unit id="15d3d6e4435036450093d183e504f2f058f4ba0a" translate="yes" xml:space="preserve">
          <source>In QRegExp &lt;b&gt;.&lt;/b&gt; matches any character, therefore all QRegExp regexps have the equivalent of Perl's &lt;code&gt;/s&lt;/code&gt; option. QRegExp does not have an equivalent to Perl's &lt;code&gt;/m&lt;/code&gt; option, but this can be emulated in various ways for example by splitting the input into lines or by looping with a regexp that searches for newlines.</source>
          <target state="translated">在QRegExp中&lt;b&gt;。&lt;/b&gt;匹配任何字符，因此所有QRegExp正则表达式都具有Perl的 &lt;code&gt;/s&lt;/code&gt; 选项。QRegExp不具有与Perl的 &lt;code&gt;/m&lt;/code&gt; 选项等效的功能，但是可以通过多种方式来模拟，例如，将输入分成几行，或者使用搜索新行的regexp循环。</target>
        </trans-unit>
        <trans-unit id="7fae58a36264ae0e95c2898581bca4993364e92f" translate="yes" xml:space="preserve">
          <source>In QRegExp, apart from within character classes, &lt;code&gt;^&lt;/code&gt; always signifies the start of the string, so carets must always be escaped unless used for that purpose. In Perl the meaning of caret varies automagically depending on where it occurs so escaping it is rarely necessary. The same applies to &lt;code&gt;$&lt;/code&gt; which in QRegExp always signifies the end of the string.</source>
          <target state="translated">在QRegExp中，除了字符类之内， &lt;code&gt;^&lt;/code&gt; 始终表示字符串的开头，因此，除非用于此目的，否则必须始终对插入符号进行转义。在Perl中，插入记号的含义会根据其出现的位置自动变化，因此很少需要转义。这同样适用于 &lt;code&gt;$&lt;/code&gt; ，它在QRegExp中始终表示字符串的结尾。</target>
        </trans-unit>
        <trans-unit id="75a5a20d18c763c9cbd9f4bc205562f8b91bd585" translate="yes" xml:space="preserve">
          <source>In Qt 4.2 and later, Qt Designer also includes a style sheet syntax highlighter and validator. The validator indicates if the syntax is valid or invalid, at the bottom left of the &lt;b&gt;Edit Style Sheet&lt;/b&gt; dialog.</source>
          <target state="translated">在Qt 4.2和更高版本中，Qt Designer还包括样式表语法突出显示器和验证器。验证器在&amp;ldquo; &lt;b&gt;编辑样式表&amp;rdquo;&lt;/b&gt;对话框的左下方指示语法是否有效。</target>
        </trans-unit>
        <trans-unit id="e21f38741bf64f98b29bb902de48f675160b07c2" translate="yes" xml:space="preserve">
          <source>In Qt 4.3 and later, the alignment of the image image's position can be specified using relative or absolute position.</source>
          <target state="translated">在Qt 4.3及以后的版本中,可以使用相对位置或绝对位置来指定图像影像的位置排列。</target>
        </trans-unit>
        <trans-unit id="2da1aaff06f6544e32c55ab157f670096cbb5521" translate="yes" xml:space="preserve">
          <source>In Qt 4.3 and later, the alignment of the image within the rectangle can be specified using &lt;a href=&quot;#image-position-prop&quot;&gt;image-position&lt;/a&gt;.</source>
          <target state="translated">在Qt 4.3及更高版本中，可以使用&lt;a href=&quot;#image-position-prop&quot;&gt;image-position&lt;/a&gt;指定图像在矩形内的对齐方式。</target>
        </trans-unit>
        <trans-unit id="48055a6ef885a2f87b21c6a950e3165dfdf04bbd" translate="yes" xml:space="preserve">
          <source>In Qt 4.3 and later, the alignment of the image within the rectangle can be specified using &lt;a href=&quot;stylesheet-reference#image-position-prop&quot;&gt;image-position&lt;/a&gt;.</source>
          <target state="translated">在Qt 4.3及更高版本中，可以使用&lt;a href=&quot;stylesheet-reference#image-position-prop&quot;&gt;image-position&lt;/a&gt;指定图像在矩形内的对齐方式。</target>
        </trans-unit>
        <trans-unit id="8f5c9359a5865f79b998c5ec2448f1975acc0223" translate="yes" xml:space="preserve">
          <source>In Qt 4.4 and earlier, this disambiguation parameter was the preferred way to specify comments to translators.</source>
          <target state="translated">在Qt 4.4和更早的版本中,这个消除歧义的参数是向翻译者指定注释的首选方式。</target>
        </trans-unit>
        <trans-unit id="7bd37077ffde2457133567f5d209d5f0f95ac3ec" translate="yes" xml:space="preserve">
          <source>In Qt 4.4, it was possible to use the static functions to show a sheet on &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;. This is no longer supported in Qt 4.5. If you want this functionality, use &lt;a href=&quot;qprintdialog#open&quot;&gt;QPrintDialog::open&lt;/a&gt;().</source>
          <target state="translated">在Qt 4.4中，可以使用静态功能在&lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;上显示表格。Qt 4.5不再支持此功能。如果需要此功能，请使用&lt;a href=&quot;qprintdialog#open&quot;&gt;QPrintDialog :: open&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="7554b413f7d4245771a413ce84f84b7e7010d3a4" translate="yes" xml:space="preserve">
          <source>In Qt 4.4, it was possible to use the static functions to show a sheet on macOS. This is no longer supported in Qt 4.5. If you want this functionality, use &lt;a href=&quot;qprintdialog#open&quot;&gt;QPrintDialog::open&lt;/a&gt;().</source>
          <target state="translated">在Qt 4.4中，可以使用静态功能在macOS上显示表格。Qt 4.5不再支持此功能。如果需要此功能，请使用&lt;a href=&quot;qprintdialog#open&quot;&gt;QPrintDialog :: open&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="9e1e9437c8cec7fc00d4f9e1a42fca433cba397e" translate="yes" xml:space="preserve">
          <source>In Qt 4.4, the capability was tied to the proxy type, but since Qt 4.5 it is possible to remove the capability of caching from a proxy by calling &lt;a href=&quot;qnetworkproxy#setCapabilities&quot;&gt;setCapabilities&lt;/a&gt;().</source>
          <target state="translated">在Qt 4.4中，功能与代理类型有关，但是从Qt 4.5开始，可以通过调用&lt;a href=&quot;qnetworkproxy#setCapabilities&quot;&gt;setCapabilities&lt;/a&gt;（）从代理中删除缓存功能。</target>
        </trans-unit>
        <trans-unit id="5839b43646c58d4d96e22402bfb02944ea1009cb" translate="yes" xml:space="preserve">
          <source>In Qt 5 all platforms are created using the &lt;a href=&quot;qpa&quot;&gt;Qt Platform Abstraction&lt;/a&gt; (QPA), which makes it easy to port Qt into a new operating system.</source>
          <target state="translated">在Qt 5中，所有平台都是使用&lt;a href=&quot;qpa&quot;&gt;Qt平台抽象&lt;/a&gt;（QPA）创建的，这使得将Qt轻松移植到新的操作系统中变得很容易。</target>
        </trans-unit>
        <trans-unit id="1301a851a486167f117da749b4b68c3edbaa10b8" translate="yes" xml:space="preserve">
          <source>In Qt 5 all platforms are created using the &lt;a href=&quot;qpa#&quot;&gt;Qt Platform Abstraction&lt;/a&gt; (QPA), which makes it easy to port Qt into a new operating system.</source>
          <target state="translated">在Qt 5中，所有平台都是使用&lt;a href=&quot;qpa#&quot;&gt;Qt平台抽象&lt;/a&gt;（QPA）创建的，这使得将Qt轻松移植到新的操作系统中变得很容易。</target>
        </trans-unit>
        <trans-unit id="d8b6c8014680e1eb362134796b460eff27d88dc4" translate="yes" xml:space="preserve">
          <source>In Qt 5 type registration happened with &lt;a href=&quot;qqmlengine#qmlRegisterType&quot;&gt;qmlRegisterType&lt;/a&gt;:</source>
          <target state="translated">在Qt 5中，类型注册发生在&lt;a href=&quot;qqmlengine#qmlRegisterType&quot;&gt;qmlRegisterType上&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="f07d1478be8655dffd70e69183b240d740e0e93b" translate="yes" xml:space="preserve">
          <source>In Qt 5, &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt; could be used to create multi-valued hashes by using QHash::insertMulti, and &lt;a href=&quot;qmultihash&quot;&gt;QMultiHash&lt;/a&gt; was deriving vom &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt;.</source>
          <target state="translated">在Qt 5，&lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt;可用于使用QHash :: insertMulti创建多值散列和&lt;a href=&quot;qmultihash&quot;&gt;QMultiHash&lt;/a&gt;是获得VOM &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8f132df83dcb0620ff7fa15cdb225a35e3213b4e" translate="yes" xml:space="preserve">
          <source>In Qt 5, &lt;code&gt;sizeof(QList&amp;lt;T&amp;gt;)&lt;/code&gt; was equal to a size of a pointer. Now, the extra pointer indirection is removed and &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; data members are directly stored in the object. By default, expect &lt;code&gt;sizeof(QList&amp;lt;T&amp;gt;)&lt;/code&gt; to be equal to the size of 3 pointers.</source>
          <target state="translated">在Qt 5中， &lt;code&gt;sizeof(QList&amp;lt;T&amp;gt;)&lt;/code&gt; 等于指针的大小。现在，删除了多余的指针间接，并将&lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt;数据成员直接存储在对象中。默认情况下，期望 &lt;code&gt;sizeof(QList&amp;lt;T&amp;gt;)&lt;/code&gt; 等于3个指针的大小。</target>
        </trans-unit>
        <trans-unit id="35dd5e8abb6f3b91684ca76b93e37e8ac728b0f0" translate="yes" xml:space="preserve">
          <source>In Qt 5, QSGMaterialShader was tied to OpenGL. It was built directly on QOpenGLShaderProgram and had functions like &lt;code&gt;updateState()&lt;/code&gt; that could issue arbitrary OpenGL commands. This is no longer the case in Qt 6. QSGMaterialShader is not strictly data-oriented, meaning it provides data (shaders and the desired pipeline state changes) together with logic that updates data in a uniform buffer. Graphics API access is not provided. This means that a QSGMaterialShader cannot make OpenGL, Vulkan, Metal, or Direct 3D calls on its own. Together with the unified shader management, this allows a QSGMaterialShader to be written once, and be functional with any of the supported graphics APIs at run time.</source>
          <target state="translated">在Qt 5中，QSGMaterialShader与OpenGL绑定。它直接建立在QOpenGLShaderProgram上，并具有诸如 &lt;code&gt;updateState()&lt;/code&gt; 之类的功能，可以发出任意的OpenGL命令。在Qt 6中不再是这种情况。QSGMaterialShader不再严格地面向数据，这意味着它提供数据（着色器和所需的管道状态更改）以及在统一缓冲区中更新数据的逻辑。不提供图形API访问。这意味着QSGMaterialShader无法单独进行OpenGL，Vulkan，Metal或Direct 3D调用。结合统一的着色器管理，这使得QSGMaterialShader可以编写一次，并在运行时与任何受支持的图形API一起使用。</target>
        </trans-unit>
        <trans-unit id="03f93bcc620482aef015a4e70795dc9656186638" translate="yes" xml:space="preserve">
          <source>In Qt 5, a replacement set of OpenGL-support classes were added to Qt Gui. This was in order to support OpenGL as the cross-platform graphics API that served as foundation for graphics in Qt.</source>
          <target state="translated">在 Qt 5 中,Qt Gui 中加入了一组替代的 OpenGL 支持类。这是为了支持 OpenGL 作为跨平台图形 API,作为 Qt 中图形的基础。</target>
        </trans-unit>
        <trans-unit id="5b13f2bf52db8505d6d0c26739d5c7e2e28136c8" translate="yes" xml:space="preserve">
          <source>In Qt 5, effects were provided in form of GLSL (OpenGL Shading Language) source code, often embedded as strings into QML. Starting with Qt 5.8, referring to files, either local ones or in the Qt resource system, became possible as well.</source>
          <target state="translated">在Qt 5中,效果是以GLSL(OpenGL Shading Language)源码的形式提供的,通常是以字符串的形式嵌入到QML中。从Qt 5.8开始,也可以引用本地或Qt资源系统中的文件。</target>
        </trans-unit>
        <trans-unit id="b659d33107de01079f98fe3585737e676602f945" translate="yes" xml:space="preserve">
          <source>In Qt 5, you would typically use a device spec under the</source>
          <target state="translated">在Qt 5中,你通常会使用在</target>
        </trans-unit>
        <trans-unit id="aa925293de9a142b7c8d5af95d61271893f43ceb" translate="yes" xml:space="preserve">
          <source>In Qt 5.0, Qt Quick always relied on OpenGL (OpenGL ES 2.0 or OpenGL 2.0) to parse the scene graph and render the results to a render target.</source>
          <target state="translated">在Qt 5.0中,Qt Quick总是依靠OpenGL(OpenGL ES 2.0或OpenGL 2.0)来解析场景图并将结果渲染到渲染目标。</target>
        </trans-unit>
        <trans-unit id="d1c2da74233eacfd350077f4f5a0ec7d5f2a4f31" translate="yes" xml:space="preserve">
          <source>In Qt 5.10, these handlers were introduced in a separate Qt.labs.handlers module. Now they are included with Qt Quick since 5.12. The pre-existing &lt;a href=&quot;qml-qtquick-keys&quot;&gt;Keys&lt;/a&gt; attached property is similar in concept, so we refer to the pointing-device-oriented handlers plus &lt;code&gt;Keys&lt;/code&gt; together as the set of Input Handlers. We expect to offer more attached-property use cases in future versions of Qt.</source>
          <target state="translated">在Qt 5.10中，这些处理程序是在单独的Qt.labs.handlers模块中引入的。从5.12开始，它们已包含在Qt Quick中。预先存在的&lt;a href=&quot;qml-qtquick-keys&quot;&gt;Keys&lt;/a&gt;附加属性在概念上类似，因此我们将面向指针设备的处理程序和 &lt;code&gt;Keys&lt;/code&gt; 一起称为&amp;ldquo;输入处理程序&amp;rdquo;集。我们期望在Qt的未来版本中提供更多的附加属性用例。</target>
        </trans-unit>
        <trans-unit id="86c8d4d7fc5cec040333b22a87472bb791c034b9" translate="yes" xml:space="preserve">
          <source>In Qt 5.4, there was an experimental implementation of high DPI scaling introduced via the &lt;code&gt;QT_DEVICE_PIXEL_RATIO&lt;/code&gt; environment variable, that you could set to a numerical scale factor or &lt;code&gt;auto&lt;/code&gt;. This variable was deprecated in Qt 5.6.</source>
          <target state="translated">在Qt 5.4中，通过 &lt;code&gt;QT_DEVICE_PIXEL_RATIO&lt;/code&gt; 环境变量引入了高DPI缩放比例的实验性实现，您可以将其设置为数字比例因子或 &lt;code&gt;auto&lt;/code&gt; 。在Qt 5.6中不推荐使用此变量。</target>
        </trans-unit>
        <trans-unit id="550fb2966f40d2910b51b3b06b90dc7f3c8ba368" translate="yes" xml:space="preserve">
          <source>In Qt 6 &lt;a href=&quot;qnetworkaccessmanager&quot;&gt;QNetworkAccessManager&lt;/a&gt; enables HTTP/2 protocol by default. Depending on the scheme (&quot;https&quot; or &quot;http&quot;), &lt;a href=&quot;qnetworkaccessmanager&quot;&gt;QNetworkAccessManager&lt;/a&gt; will use the Application Layer Protocol Negotiation TLS extension or &quot;protocol upgrade&quot; HTTP header to negotiate HTTP/2. If HTTP/2 cannot be negotiated, the access manager will fall back to using HTTP/1.1. If your application can only use HTTP/1.1, you have to disable HTTP/2 manually on a new request:</source>
          <target state="translated">在Qt 6中，&lt;a href=&quot;qnetworkaccessmanager&quot;&gt;QNetworkAccessManager&lt;/a&gt;默认启用HTTP / 2协议。根据方案（&amp;ldquo; https&amp;rdquo;或&amp;ldquo; http&amp;rdquo;），&lt;a href=&quot;qnetworkaccessmanager&quot;&gt;QNetworkAccessManager&lt;/a&gt;将使用应用程序层协议协商TLS扩展或&amp;ldquo;协议升级&amp;rdquo; HTTP标头来协商HTTP / 2。如果无法协商HTTP / 2，则访问管理器将退回到使用HTTP / 1.1。如果您的应用程序只能使用HTTP / 1.1，则必须在新请求上手动禁用HTTP / 2：</target>
        </trans-unit>
        <trans-unit id="f5290d3945976e99c297c1c184fb7a39f0aa1308" translate="yes" xml:space="preserve">
          <source>In Qt 6 the default approach is to use automatic registration with the help of the build system. Instead of calling &lt;a href=&quot;qqmlengine#qmlRegisterType&quot;&gt;qmlRegisterType&lt;/a&gt;, the &lt;code&gt;.pro&lt;/code&gt; file can now contain:</source>
          <target state="translated">在Qt 6中，默认方法是在构建系统的帮助下使用自动注册。 &lt;code&gt;.pro&lt;/code&gt; 文件现在可以包含以下&lt;a href=&quot;qqmlengine#qmlRegisterType&quot;&gt;内容&lt;/a&gt;，而不是调用qmlRegisterType：</target>
        </trans-unit>
        <trans-unit id="dbbeaa7efd9790849a24a2e0d04264b7dbf0688a" translate="yes" xml:space="preserve">
          <source>In Qt 6, &lt;code&gt;+material&lt;/code&gt; becomes &lt;code&gt;+Material&lt;/code&gt;:</source>
          <target state="translated">在Qt 6中， &lt;code&gt;+material&lt;/code&gt; 变为 &lt;code&gt;+Material&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="91a2309f5eba68b008f2f1d63da2613e2309ae86" translate="yes" xml:space="preserve">
          <source>In Qt 6, Qt Quick has support for graphics APIs, such as Vulkan, Metal, and Direct3D 11 as well. Therefore, working with GLSL source strings is no longer feasible. Rather, the new shader pipeline is based on compiling Vulkan-compatible GLSL code into &lt;a href=&quot;https://www.khronos.org/spir/&quot;&gt;SPIR-V&lt;/a&gt;, followed by gathering reflection information and translating into other shading languages, such as HLSL, the Metal Shading Language, and various GLSL versions. The resulting assets are packed together into a single package, typically stored in files with an extension of &lt;code&gt;.qsb&lt;/code&gt;. This process is done offline or at application build time at latest. At run time, the scene graph and the underlying graphics abstraction consumes these &lt;code&gt;.qsb&lt;/code&gt; files. Therefore, ShaderEffect expects file (local or qrc) references in Qt 6 in place of inline shader code.</source>
          <target state="translated">在Qt 6中，Qt Quick支持图形API，例如Vulkan，Metal和Direct3D 11。因此，使用GLSL源字符串不再可行。相反，新的着色器管道基于将Vulkan兼容的GLSL代码编译为&lt;a href=&quot;https://www.khronos.org/spir/&quot;&gt;SPIR-V&lt;/a&gt;，然后收集反射信息并转换为其他着色语言，例如HLSL，金属着色语言和各种GLSL版本。所得资产打包在一起，形成一个包，通常存储在扩展名为 &lt;code&gt;.qsb&lt;/code&gt; 的文件中。此过程是脱机完成的，或者最晚在应用程序构建时完成的。在运行时，场景图和基础图形抽象消耗了这些 &lt;code&gt;.qsb&lt;/code&gt; 文件。因此，ShaderEffect希望在Qt 6中引用文件（本地或qrc）引用，而不是嵌入式着色器代码。</target>
        </trans-unit>
        <trans-unit id="b8ddd6c6dfc0af3b3ceab5c8f0c664051889bab3" translate="yes" xml:space="preserve">
          <source>In Qt 6, both the major and minor versions match, and version numbers may be omitted from imports in QML. If the version is omitted, the latest version will be used.</source>
          <target state="translated">在Qt 6中,主要版本和次要版本都是匹配的,在QML中导入时可以省略版本号。如果省略了版本,将使用最新的版本。</target>
        </trans-unit>
        <trans-unit id="19f1d61a3233bf58147babfff0e7123dd5ea6024" translate="yes" xml:space="preserve">
          <source>In Qt 6, both types and use cases are distinct, and QHash::insertMulti got removed.</source>
          <target state="translated">在Qt 6中,这两种类型和用例是不同的,QHash::insertMulti被删除了。</target>
        </trans-unit>
        <trans-unit id="349907fbdcb4366e353345cf676ecb551a8327de" translate="yes" xml:space="preserve">
          <source>In Qt 6, registration of comparators, and cQDebug and QDataStream streaming operators is done automatically. Consequently, &lt;code&gt;QMetaType::registerEqualsComparator()&lt;/code&gt;, &lt;code&gt;QMetaType::registerComparators()&lt;/code&gt;, &lt;code&gt;qRegisterMetaTypeStreamOperators()&lt;/code&gt; and &lt;code&gt;QMetaType::registerDebugStreamOperator()&lt;/code&gt; do no longer exist. Calls to those methods have to be removed when porting to Qt 6.</source>
          <target state="translated">在Qt 6中，比较器以及cQDebug和QDataStream流运算符的注册是自动完成的。因此， &lt;code&gt;QMetaType::registerEqualsComparator()&lt;/code&gt; ， &lt;code&gt;QMetaType::registerComparators()&lt;/code&gt; ， &lt;code&gt;qRegisterMetaTypeStreamOperators()&lt;/code&gt; 和 &lt;code&gt;QMetaType::registerDebugStreamOperator()&lt;/code&gt; 不再存在。移植到Qt 6时，必须删除对这些方法的调用。</target>
        </trans-unit>
        <trans-unit id="aadcf36950c0f58fd08cc319ccf14a2decc9d296" translate="yes" xml:space="preserve">
          <source>In Qt 6, the &lt;a href=&quot;qprocess#start&quot;&gt;QProcess::start&lt;/a&gt;() overload that interprets a single command string by splitting it into program name and arguments is renamed to &lt;a href=&quot;qprocess#startCommand&quot;&gt;QProcess::startCommand&lt;/a&gt;(). However, a &lt;a href=&quot;qprocess#start&quot;&gt;QProcess::start&lt;/a&gt;() overload that takes a single string, as well as a &lt;a href=&quot;qstringlist&quot;&gt;QStringList&lt;/a&gt; for arguments exists. Since the &lt;a href=&quot;qstringlist&quot;&gt;QStringList&lt;/a&gt; parameter defaults to the empty list, existing code only passing a string will still compile, but will fail to execute the process if it is a complete command string that includes arguments.</source>
          <target state="translated">在Qt 6中，通过将单个命令字符串拆分为程序名称和参数来解释单个命令字符串的&lt;a href=&quot;qprocess#start&quot;&gt;QProcess :: start&lt;/a&gt;（）重载被重命名为&lt;a href=&quot;qprocess#startCommand&quot;&gt;QProcess :: startCommand&lt;/a&gt;（）。但是，存在一个使用单个字符串的&lt;a href=&quot;qprocess#start&quot;&gt;QProcess :: start&lt;/a&gt;（）重载以及一个用于参数的&lt;a href=&quot;qstringlist&quot;&gt;QStringList&lt;/a&gt;。由于&lt;a href=&quot;qstringlist&quot;&gt;QStringList&lt;/a&gt;参数默认为空列表，因此仅传递字符串的现有代码仍将编译，但如果它是包含参数的完整命令字符串，则将无法执行该过程。</target>
        </trans-unit>
        <trans-unit id="90a8ee72b12b37a18417009af4853c22acec772e" translate="yes" xml:space="preserve">
          <source>In Qt 6, the copy constructor and assignment operator for &lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt; subclasses have been made protected to prevent implicit copying. If you need to copy events, use the &lt;a href=&quot;qevent#clone&quot;&gt;clone&lt;/a&gt; method, which will return a heap-allocated copy of the &lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt; object. Make sure you delete the clone, perhaps using std::unique_ptr, unless you post it (in which case Qt will delete it once it has been delivered).</source>
          <target state="translated">在Qt 6中，对&lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt;子类的复制构造函数和赋值运算符进行了保护，以防止隐式复制。如果需要复制事件，请使用&lt;a href=&quot;qevent#clone&quot;&gt;clone&lt;/a&gt;方法，该方法将返回&lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt;对象的堆分配副本。确保删除克隆，也许使用std :: unique_ptr删除，除非您将其发布（在这种情况下，Qt将在交付后将其删除）。</target>
        </trans-unit>
        <trans-unit id="f28961c0fd60502f6bfe8242b14641c4a4e6d9b2" translate="yes" xml:space="preserve">
          <source>In Qt 6, the default approach is to ship &lt;code&gt;.qsb&lt;/code&gt; files with the application, typically embedded via the resource system, and referenced when calling &lt;a href=&quot;qsgmaterialshader#setShaderFileName&quot;&gt;setShaderFileName&lt;/a&gt;(). The &lt;code&gt;.qsb&lt;/code&gt; files are generated offline, or at latest at application build time, from Vulkan-style GLSL source code using the &lt;code&gt;qsb&lt;/code&gt; tool from the Qt Shader Tools module.</source>
          <target state="translated">在Qt 6中，默认方法是将 &lt;code&gt;.qsb&lt;/code&gt; 文件与应用程序一起发送，通常是通过资源系统嵌入的，并在调用&lt;a href=&quot;qsgmaterialshader#setShaderFileName&quot;&gt;setShaderFileName&lt;/a&gt;（）时引用。该 &lt;code&gt;.qsb&lt;/code&gt; 文件在最新的应用程序生成时，从福尔康式GLSL源代码使用离线生成，或 &lt;code&gt;qsb&lt;/code&gt; 从Qt的着色器工具模块的工具。</target>
        </trans-unit>
        <trans-unit id="8815c0f05ffb057c160ca2ba639f4c7b4c06225c" translate="yes" xml:space="preserve">
          <source>In Qt 6, the default redirect policy has changed from manual to &lt;a href=&quot;qnetworkrequest#RedirectPolicy-enum&quot;&gt;QNetworkRequest::NoLessSafeRedirectPolicy&lt;/a&gt;. If your application relies on manual redirect handling (it connects its slot to the &lt;a href=&quot;qnetworkreply#redirected&quot;&gt;QNetworkReply::redirected&lt;/a&gt; signal), you have to explicitly set this policy when creating a request:</source>
          <target state="translated">在Qt 6中，默认重定向策略已从手动更改为&lt;a href=&quot;qnetworkrequest#RedirectPolicy-enum&quot;&gt;QNetworkRequest :: NoLessSafeRedirectPolicy&lt;/a&gt;。如果您的应用程序依靠手动重定向处理（它将其插槽连接到&lt;a href=&quot;qnetworkreply#redirected&quot;&gt;QNetworkReply :: redirected&lt;/a&gt;信号），则在创建请求时必须显式设置此策略：</target>
        </trans-unit>
        <trans-unit id="6f7292a3bf8071845e26b6efe3b7336248aa0181" translate="yes" xml:space="preserve">
          <source>In Qt 6, the installation experience is easier and more flexible than before.The installation includes the &lt;b&gt;Qt Essentials&lt;/b&gt; and a few of the most commonly used &lt;b&gt;Qt Add-Ons&lt;/b&gt;. The Qt Add-Ons are moved outside of the main installation, but still available by running the installer. You can read the list of Qt modules in the &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtmodules.html&quot;&gt;Qt Modules&lt;/a&gt; page.</source>
          <target state="translated">在Qt 6中，安装体验比以前更轻松，更灵活。安装包括&lt;b&gt;Qt Essentials&lt;/b&gt;和一些最常用的&lt;b&gt;Qt附加组件&lt;/b&gt;。Qt附加组件已移至主要安装之外，但仍可通过运行安装程序来使用。您可以在&amp;ldquo; &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtmodules.html&quot;&gt;Qt模块&amp;rdquo;&lt;/a&gt;页面中阅读Qt模块列表。</target>
        </trans-unit>
        <trans-unit id="149a7492a2501937ab3024ce07024bbad59f32ac" translate="yes" xml:space="preserve">
          <source>In Qt 6, the new &lt;a href=&quot;qtcore-changes-qt6#qpromise&quot;&gt;QPromise&lt;/a&gt; class should be used instead of unofficial QFutureInterface as a &quot;setter&quot; counterpart of &lt;a href=&quot;qtcore-changes-qt6#qfuture&quot;&gt;QFuture&lt;/a&gt;.</source>
          <target state="translated">在Qt 6，新&lt;a href=&quot;qtcore-changes-qt6#qpromise&quot;&gt;QPromise&lt;/a&gt;类应该被用来代替非官方QFutureInterface作为的&amp;ldquo;设定部&amp;rdquo;对口&lt;a href=&quot;qtcore-changes-qt6#qfuture&quot;&gt;QFuture&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fb5d132efe8edfde8987763dc3602882a10d58c7" translate="yes" xml:space="preserve">
          <source>In Qt 6, there were some improvements to &lt;a href=&quot;qtcore-changes-qt6#qfuture&quot;&gt;QFuture&lt;/a&gt; and &lt;a href=&quot;qfuturewatcher&quot;&gt;QFutureWatcher&lt;/a&gt; which caused the following behavioral changes:</source>
          <target state="translated">在Qt 6中，对&lt;a href=&quot;qtcore-changes-qt6#qfuture&quot;&gt;QFuture&lt;/a&gt;和&lt;a href=&quot;qfuturewatcher&quot;&gt;QFutureWatcher&lt;/a&gt;进行了一些改进，从而导致了以下行为更改：</target>
        </trans-unit>
        <trans-unit id="d13092d8242548acd685b513972ce734667bb9b6" translate="yes" xml:space="preserve">
          <source>In Qt 6, these have been migrated to the &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtopengl-index.html&quot;&gt;Qt OpenGL&lt;/a&gt; module. They are still usable and fully supported for applications depending on OpenGL directly. However, they are no longer considered foundational, since Qt has been extended to support other graphics APIs in its foundation, such as Direct3D, Metal and Vulkan.</source>
          <target state="translated">在Qt 6中，这些已迁移到&lt;a href=&quot;https://doc.qt.io/qt-6.0/qtopengl-index.html&quot;&gt;Qt OpenGL&lt;/a&gt;模块。它们仍然可用，并且完全受直接依赖OpenGL的应用程序的支持。但是，它们不再被视为基础，因为Qt已扩展为支持基础中的其他图形API，例如Direct3D，Metal和Vulkan。</target>
        </trans-unit>
        <trans-unit id="b8bdf46ab1dd38601c57e7327f4c43d9a585908a" translate="yes" xml:space="preserve">
          <source>In Qt 6.0 inline shader strings are no longer supported, neither in Qt Quick nor in Qt Quick 3D. (make note of the fact that these properties are URLs, not strings) However, due to their intrinsically dynamic nature, custom materials and post-processing effects in Qt Quick 3D still provide shader snippets in source form in the referenced files. This is a difference to &lt;a href=&quot;qml-qtquick-shadereffect&quot;&gt;ShaderEffect&lt;/a&gt; where the shaders are complete on their own, with no further amending by the engine, and so are expected to be provided as pre-conditioned &lt;code&gt;.qsb&lt;/code&gt; shader packs.</source>
          <target state="translated">在Qt 6.0和Qt Quick 3D中不再支持嵌入式着色器字符串。（请注意，这些属性是URL，而不是字符串）。但是，由于Qt Quick 3D具有固有的动态特性，自定义材质和后处理效果仍会在引用文件中以源格式提供着色器片段。这与&lt;a href=&quot;qml-qtquick-shadereffect&quot;&gt;ShaderEffect&lt;/a&gt;有所不同，在ShaderEffect上，着色器是独立完成的，无需引擎进一步修改，因此预计将以预处理的 &lt;code&gt;.qsb&lt;/code&gt; 着色器包提供。</target>
        </trans-unit>
        <trans-unit id="3c82b751027c4aa4bef24e60138c4bf9e442183f" translate="yes" xml:space="preserve">
          <source>In Qt 6.0 the Canvas item supports one render target: &lt;code&gt;Canvas.Image&lt;/code&gt;.</source>
          <target state="translated">在Qt 6.0中，Canvas项支持一个渲染目标： &lt;code&gt;Canvas.Image&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8ae3434f467261f2c591e28d7ac56fb2359d209d" translate="yes" xml:space="preserve">
          <source>In Qt Creator, tested examples on iOS can be looked up. Use the &lt;code&gt;ios&lt;/code&gt; keyword to search for examples in the Qt Creator Welcome mode. Note that some examples may have limited functionality.</source>
          <target state="translated">在Qt Creator中，可以查看iOS上经过测试的示例。使用 &lt;code&gt;ios&lt;/code&gt; 关键字在Qt Creator欢迎模式下搜索示例。请注意，某些示例的功能可能有限。</target>
        </trans-unit>
        <trans-unit id="2f7cb963098912f7677e39836c1fdad9458b8dc8" translate="yes" xml:space="preserve">
          <source>In Qt Quick 2.0, this property has minimal impact on performance.</source>
          <target state="translated">在Qt Quick 2.0中,这个属性对性能的影响很小。</target>
        </trans-unit>
        <trans-unit id="b8513c922742d54c8b75152dfa2908eddfe88422" translate="yes" xml:space="preserve">
          <source>In Qt Quick 3D, you can import 3D models and scenes that are created using 3D modeling tools. To see the supported file formats, see the &lt;a href=&quot;qtquick3d-tool-balsam&quot;&gt;Balsam tool&lt;/a&gt; documentation.</source>
          <target state="translated">在Qt Quick 3D中，您可以导入使用3D建模工具创建的3D模型和场景。要查看支持的文件格式，请参阅&lt;a href=&quot;qtquick3d-tool-balsam&quot;&gt;Balsam工具&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="a8c1d5254603872065c8e6712d0092447f70f7c3" translate="yes" xml:space="preserve">
          <source>In Qt Quick Controls 2, a style is essentially an interchangeable set of QML files within a single directory. There are three requirements for a style to be &lt;a href=&quot;qtquickcontrols2-styles#using-styles-in-qt-quick-controls-2&quot;&gt;usable&lt;/a&gt;:</source>
          <target state="translated">在Qt Quick Controls 2中，样式本质上是单个目录中一组可互换的QML文件。要&lt;a href=&quot;qtquickcontrols2-styles#using-styles-in-qt-quick-controls-2&quot;&gt;使用&lt;/a&gt;一种样式，有三个要求：</target>
        </trans-unit>
        <trans-unit id="f58b06b0ad0e7908b9c680c9e77f233784db115a" translate="yes" xml:space="preserve">
          <source>In Qt Quick Controls 2, styles no longer provide components that are dynamically instantiated by controls, but controls themselves consist of item delegates that can be replaced. In effect, this means that delegates are Qt Quick items that are instantiated on the spot, as properties of the control, and are simply parented to the control.</source>
          <target state="translated">在Qt Quick Controls 2中,样式不再提供由控件动态实例化的组件,而是控件本身由可替换的项目委托组成。实际上,这意味着委派是Qt Quick的项目,作为控件的属性,被当场实例化,并被简单地作为控件的家长。</target>
        </trans-unit>
        <trans-unit id="6185592e902218514da030d4316379e538d43b7f" translate="yes" xml:space="preserve">
          <source>In Qt Quick Controls, a style is essentially a set of QML files within a single directory. There are four requirements for a style to be &lt;a href=&quot;qtquickcontrols2-styles#using-styles-in-qt-quick-controls&quot;&gt;usable&lt;/a&gt;:</source>
          <target state="translated">在Qt Quick Controls中，样式本质上是单个目录中的一组QML文件。要&lt;a href=&quot;qtquickcontrols2-styles#using-styles-in-qt-quick-controls&quot;&gt;使用&lt;/a&gt;一种样式，有四个要求：</target>
        </trans-unit>
        <trans-unit id="a54ad556f19ad29ab93dd87cafe273c30d1285eb" translate="yes" xml:space="preserve">
          <source>In Qt Quick Controls, a style is essentially an interchangeable set of QML files within a single directory. There are three requirements for a style to be &lt;a href=&quot;qtquickcontrols2-styles#using-styles-in-qt-quick-controls&quot;&gt;usable&lt;/a&gt;:</source>
          <target state="translated">在Qt Quick Controls中，样式本质上是单个目录内可互换的一组QML文件。要&lt;a href=&quot;qtquickcontrols2-styles#using-styles-in-qt-quick-controls&quot;&gt;使用&lt;/a&gt;一种样式，有三个要求：</target>
        </trans-unit>
        <trans-unit id="dad0d387bc437ed4588c35f5d3c0a55bb1f765b0" translate="yes" xml:space="preserve">
          <source>In Qt Quick Controls, styles no longer provide components that are dynamically instantiated by controls, but controls themselves consist of item delegates that can be replaced. In effect, this means that delegates are Qt Quick items that are instantiated on the spot, as properties of the control, and are simply parented to the control.</source>
          <target state="translated">在Qt Quick Controls中,样式不再提供由控件动态实例化的组件,而是控件本身由可以替换的项目委托组成。实际上,这意味着委派是Qt Quick的项目,作为控件的属性,被当场实例化,并简单地作为控件的父级。</target>
        </trans-unit>
        <trans-unit id="7fb4cae27d8f0cd835a1823fc7ebfe1ea95c00a7" translate="yes" xml:space="preserve">
          <source>In Qt Quick however, it's normal for an Item or Event Handler to accept only the individual points in a &lt;a href=&quot;qtouchevent&quot;&gt;QTouchEvent&lt;/a&gt; that are actually participating in a gesture, while other points can be delivered to other items or handlers. For the sake of consistency, that applies to any &lt;a href=&quot;qpointerevent&quot;&gt;QPointerEvent&lt;/a&gt;; and delivery is done only when all points in a &lt;a href=&quot;qpointerevent&quot;&gt;QPointerEvent&lt;/a&gt; have been accepted.</source>
          <target state="translated">但是，在Qt Quick中，项目或事件处理程序仅接受&lt;a href=&quot;qtouchevent&quot;&gt;QTouchEvent&lt;/a&gt;中实际参与手势的各个点是正常的，而其他点则可以传递给其他项目或处理程序。为了一致性，这适用于任何&lt;a href=&quot;qpointerevent&quot;&gt;QPointerEvent&lt;/a&gt;；仅当&lt;a href=&quot;qpointerevent&quot;&gt;QPointerEvent中的&lt;/a&gt;所有点都被接受时，才进行传递。</target>
        </trans-unit>
        <trans-unit id="b5d00b3bfe57d29bbdd23a278835667af74ea455" translate="yes" xml:space="preserve">
          <source>In Qt for Embedded Linux, painting is a pure software implementation. But starting with Qt 4.2, it is possible to add an accelerated graphics driver to take advantage of available hardware resources.</source>
          <target state="translated">在Qt for Embedded Linux中,绘画是一个纯软件实现。但从Qt 4.2开始,可以添加一个加速的图形驱动程序来利用现有的硬件资源。</target>
        </trans-unit>
        <trans-unit id="e0ddb22c783ba2635ae916d9e01be57f2657a418" translate="yes" xml:space="preserve">
          <source>In Qt there is a often a need to represent the layout of the pixels in a graphics buffer. Internally &lt;a href=&quot;qpixelformat&quot;&gt;QPixelFormat&lt;/a&gt; stores everything in a 64 bit datastructure. This gives performance but also some limitations.</source>
          <target state="translated">在Qt中，经常需要表示图形缓冲区中像素的布局。在内部，&lt;a href=&quot;qpixelformat&quot;&gt;QPixelFormat&lt;/a&gt;将所有内容存储在64位数据结构中。这不仅提供了性能，还带来了一些限制。</target>
        </trans-unit>
        <trans-unit id="ee11902b43073c2f1a49ce99a5f5ee8bfcaa598b" translate="yes" xml:space="preserve">
          <source>In Qt there is a often a need to represent the layout of the pixels in a graphics buffer. Internally QPixelFormat stores everything in a 64 bit datastructure. This gives performance but also some limitations.</source>
          <target state="translated">在Qt中,经常需要在图形缓冲区中表示像素的布局。在QPixelFormat内部,所有的东西都存储在一个64位的数据结构中。这给了性能,但也有一些限制。</target>
        </trans-unit>
        <trans-unit id="63893ce74e6ced89c15bfc878e9d467f7a92faa1" translate="yes" xml:space="preserve">
          <source>In Qt versions before 5.4, this constructor was &lt;code&gt;explicit&lt;/code&gt;. In Qt 5.4 and later, it no longer is and can be used for C++11-style uniform initialization:</source>
          <target state="translated">在5.4之前的Qt版本中，此构造函数是 &lt;code&gt;explicit&lt;/code&gt; 。在Qt 5.4和更高版本中，它不再是并且可以用于C ++ 11样式的统一初始化：</target>
        </trans-unit>
        <trans-unit id="414ba0c2c428e511ff72f14df0252cd424defcd3" translate="yes" xml:space="preserve">
          <source>In Qt, &lt;a href=&quot;qtabbar&quot;&gt;QTabBar&lt;/a&gt; uses the style to draw its tabs. Tabs exist either in a &lt;a href=&quot;qtabwidget&quot;&gt;QTabWidget&lt;/a&gt;, which contains a &lt;a href=&quot;qtabbar&quot;&gt;QTabBar&lt;/a&gt;, or as a separate bar. If the bar is not part of a tab widget, it draws its own base.</source>
          <target state="translated">在Qt中，&lt;a href=&quot;qtabbar&quot;&gt;QTabBar&lt;/a&gt;使用样式绘制其选项卡。翼片在任一存在&lt;a href=&quot;qtabwidget&quot;&gt;QTabWidget&lt;/a&gt;，它包含一个&lt;a href=&quot;qtabbar&quot;&gt;QTabBar&lt;/a&gt;，或作为一个单独的棒。如果该栏不是选项卡小部件的一部分，它将绘制自己的基数。</target>
        </trans-unit>
        <trans-unit id="53fc45ccf8ff6c2c17d0ddf9b72209c858a2c8b1" translate="yes" xml:space="preserve">
          <source>In Qt, Unicode characters are 16-bit entities without any markup or structure. This class represents such an entity. It is lightweight, so it can be used everywhere. Most compilers treat it like an &lt;code&gt;unsigned short&lt;/code&gt;.</source>
          <target state="translated">在Qt中，Unicode字符是16位实体，没有任何标记或结构。此类表示这样的实体。它重量轻，因此可以在任何地方使用。大多数编译器将其视为 &lt;code&gt;unsigned short&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c68161e5025664a0ac293a55a828704a0cbcad3a" translate="yes" xml:space="preserve">
          <source>In Qt, and in most applications that use Qt, most or all user-visible strings are stored using Unicode. Qt provides:</source>
          <target state="translated">在Qt和大多数使用Qt的应用程序中,大多数或所有用户可见的字符串都使用Unicode存储。Qt提供了:</target>
        </trans-unit>
        <trans-unit id="eac7144094ff090daf359b45347bdcb9efd80947" translate="yes" xml:space="preserve">
          <source>In Qt, events are objects, derived from the abstract &lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt; class, that represent things that have happened either within an application or as a result of outside activity that the application needs to know about. Events can be received and handled by any instance of a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; subclass, but they are especially relevant to widgets. This document describes how events are delivered and handled in a typical application.</source>
          <target state="translated">在Qt中，事件是从抽象&lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt;类派生的对象，它们表示发生在应用程序内部或由于应用程序需要了解的外部活动而发生的事情。事件可以由&lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;子类的任何实例接收和处理，但是它们与小部件尤其相关。本文档介绍了在典型应用程序中如何传递和处理事件。</target>
        </trans-unit>
        <trans-unit id="849b14dff590398aba602de88700a986333573d3" translate="yes" xml:space="preserve">
          <source>In Qt, only the &lt;a href=&quot;qwidget#focusPolicy-prop&quot;&gt;QWidget::setFocusPolicy&lt;/a&gt;() function affects click-to-focus.</source>
          <target state="translated">在Qt中，只有&lt;a href=&quot;qwidget#focusPolicy-prop&quot;&gt;QWidget :: setFocusPolicy&lt;/a&gt;（）函数会影响单击焦点。</target>
        </trans-unit>
        <trans-unit id="15fd12f867719ae4a4464c703001a54f55c8e80e" translate="yes" xml:space="preserve">
          <source>In Qt, printers are represented by &lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt;, a paint device that provides functionality specific to printing, such as support for multiple pages and double-sided output. As a result, printing involves using a &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; to paint onto a series of pages in the same way that you would paint onto a custom widget or image.</source>
          <target state="translated">在Qt中，打印机由&lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt;代表，QPrinter是一种绘画设备，可提供特定于打印的功能，例如支持多页和双面输出。结果，打印涉及使用&lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;以与自定义窗口小部件或图像相同的方式绘制到一系列页面上。</target>
        </trans-unit>
        <trans-unit id="6249b7e9079795af469dac88f40752d05817431d" translate="yes" xml:space="preserve">
          <source>In Qt, the &lt;a href=&quot;qabstractbutton&quot;&gt;QAbstractButton&lt;/a&gt; base class provides most of the modes and other API, and &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt; provides GUI logic. See &lt;a href=&quot;qabstractbutton&quot;&gt;QAbstractButton&lt;/a&gt; for more information about the API.</source>
          <target state="translated">在Qt中，&lt;a href=&quot;qabstractbutton&quot;&gt;QAbstractButton&lt;/a&gt;基类提供大多数模式和其他API，而&lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt;提供GUI逻辑。有关API的更多信息，请参见&lt;a href=&quot;qabstractbutton&quot;&gt;QAbstractButton&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ecf015e7564db0d7bb25f426856a39008e35e7dc" translate="yes" xml:space="preserve">
          <source>In Qt, the &lt;a href=&quot;qabstractbutton&quot;&gt;QAbstractButton&lt;/a&gt; base class provides most of the modes and other API, and QPushButton provides GUI logic. See &lt;a href=&quot;qabstractbutton&quot;&gt;QAbstractButton&lt;/a&gt; for more information about the API.</source>
          <target state="translated">在Qt中，&lt;a href=&quot;qabstractbutton&quot;&gt;QAbstractButton&lt;/a&gt;基类提供大多数模式和其他API，而QPushButton提供GUI逻辑。有关API的更多信息，请参见&lt;a href=&quot;qabstractbutton&quot;&gt;QAbstractButton&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="694d95eac501dc5a240807b6c9dd7ba788a59f47" translate="yes" xml:space="preserve">
          <source>In Qt, the &lt;a href=&quot;qvector3d&quot;&gt;QVector3D&lt;/a&gt; class was documented with the following QDoc comment:</source>
          <target state="translated">在Qt中，使用以下QDoc注释记录了&lt;a href=&quot;qvector3d&quot;&gt;QVector3D&lt;/a&gt;类：</target>
        </trans-unit>
        <trans-unit id="9d9a550f5f7390e62ffd41f8d0063964f8b12845" translate="yes" xml:space="preserve">
          <source>In Qt, the &lt;a href=&quot;widgets-changes-qt6#qabstractbutton&quot;&gt;QAbstractButton&lt;/a&gt; base class provides most of the modes and other API, and QPushButton provides GUI logic. See &lt;a href=&quot;widgets-changes-qt6#qabstractbutton&quot;&gt;QAbstractButton&lt;/a&gt; for more information about the API.</source>
          <target state="translated">在Qt中，&lt;a href=&quot;widgets-changes-qt6#qabstractbutton&quot;&gt;QAbstractButton&lt;/a&gt;基类提供大多数模式和其他API，而QPushButton提供GUI逻辑。有关API的更多信息，请参见&lt;a href=&quot;widgets-changes-qt6#qabstractbutton&quot;&gt;QAbstractButton&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="81e7f13c19bd0db5d160904a2301522c68a90150" translate="yes" xml:space="preserve">
          <source>In Qt, we have an alternative to the callback technique: We use signals and slots. A signal is emitted when a particular event occurs. Qt's widgets have many predefined signals, but we can always subclass widgets to add our own signals to them. A slot is a function that is called in response to a particular signal. Qt's widgets have many pre-defined slots, but it is common practice to subclass widgets and add your own slots so that you can handle the signals that you are interested in.</source>
          <target state="translated">在Qt中,我们有一个替代回调技术的方法。我们使用信号和槽。当一个特定的事件发生时,就会发出一个信号。Qt的widgets有许多预定义的信号,但我们可以随时对widgets进行子类化以添加我们自己的信号。槽是一个响应特定信号而被调用的函数。Qt的widgets有许多预定义的slot,但通常的做法是子类widgets并添加自己的slot,这样你就可以处理你感兴趣的信号。</target>
        </trans-unit>
        <trans-unit id="b54bd41df643a393d2a3ca28c846808bdce80dd0" translate="yes" xml:space="preserve">
          <source>In Qt3D 5.9, &lt;a href=&quot;qt3drender-qmesh&quot;&gt;QMesh&lt;/a&gt; supports the following formats:</source>
          <target state="translated">在Qt3D 5.9中，&lt;a href=&quot;qt3drender-qmesh&quot;&gt;QMesh&lt;/a&gt;支持以下格式：</target>
        </trans-unit>
        <trans-unit id="2126249dd3052dc8ea5cd46acab4c4eb0c44b8fb" translate="yes" xml:space="preserve">
          <source>In Qt3D 5.9, Mesh supports the following formats:</source>
          <target state="translated">在Qt3D 5.9中,Mesh支持以下格式。</target>
        </trans-unit>
        <trans-unit id="894d2f880c88594d644f71b73869653869d47b52" translate="yes" xml:space="preserve">
          <source>In Qt3D 5.9, QMesh supports the following formats:</source>
          <target state="translated">在Qt3D 5.9中,QMesh支持以下格式。</target>
        </trans-unit>
        <trans-unit id="8da8e603ca3bb5ba0720d8ebe639ba90f3bce947" translate="yes" xml:space="preserve">
          <source>In Qt6 &lt;a href=&quot;qtcore-changes-qt6#qregexp&quot;&gt;QRegExp&lt;/a&gt; got removed from Qt Core. If your application cannot be ported right now, &lt;code&gt;QRegExp&lt;/code&gt; still exists in Qt5Compat to keep these code-bases working. If you want to use &lt;code&gt;QRegExp&lt;/code&gt; further, you need to link against the new Qt5Compat module and add this line to your &lt;a href=&quot;qmake-manual&quot;&gt;qmake&lt;/a&gt;&lt;code&gt;.pro&lt;/code&gt; file:</source>
          <target state="translated">在Qt6中，&lt;a href=&quot;qtcore-changes-qt6#qregexp&quot;&gt;QRegExp&lt;/a&gt;已从Qt Core中删除。如果您的应用程序现在无法移植，则 &lt;code&gt;QRegExp&lt;/code&gt; 仍然存在QRegExp以使这些代码库正常工作。如果要进一步使用 &lt;code&gt;QRegExp&lt;/code&gt; ，则需要链接到新的Qt5Compat模块，并将此行添加到&lt;a href=&quot;qmake-manual&quot;&gt;qmake &lt;/a&gt; &lt;code&gt;.pro&lt;/code&gt; 文件中：</target>
        </trans-unit>
        <trans-unit id="84fbbe109d7cfc5893b8b48507f2cbcbd5d258c9" translate="yes" xml:space="preserve">
          <source>In Qt6 &lt;a href=&quot;qtcore-changes-qt6#qstringref&quot;&gt;QStringRef&lt;/a&gt; got removed from Qt Core. To ease porting of existing applications without touching the whole code-base, the &lt;code&gt;QStringRef&lt;/code&gt; class did not vanish completely and instead it got moved into the Qt5Compat module.</source>
          <target state="translated">在Qt6中，&lt;a href=&quot;qtcore-changes-qt6#qstringref&quot;&gt;QStringRef&lt;/a&gt;已从Qt Core中删除。为了在不影响整个代码库的情况下简化现有应用程序的移植， &lt;code&gt;QStringRef&lt;/code&gt; 类并未完全消失，而是移入了Qt5Compat模块中。</target>
        </trans-unit>
        <trans-unit id="3c6789576be29e1def991fa58caa868758528b2c" translate="yes" xml:space="preserve">
          <source>In Qt6, &lt;code&gt;SAX&lt;/code&gt; classes have been removed and therefore &lt;a href=&quot;qdomdocument&quot;&gt;QDomDocument&lt;/a&gt; cannot use them anymore. That's why it has been re-implemented using the &lt;a href=&quot;xml-changes-qt6#qxmlstreamreader&quot;&gt;QXmlStreamReader&lt;/a&gt;. This brings a few behavioral changes:</source>
          <target state="translated">在Qt6中， &lt;code&gt;SAX&lt;/code&gt; 类已被删除，因此&lt;a href=&quot;qdomdocument&quot;&gt;QDomDocument&lt;/a&gt;无法再使用它们。这就是为什么使用&lt;a href=&quot;xml-changes-qt6#qxmlstreamreader&quot;&gt;QXmlStreamReader&lt;/a&gt;重新实现了它的原因。这带来了一些行为上的变化：</target>
        </trans-unit>
        <trans-unit id="1720edd3049a1ab0e266f4f6daa2ffffab521477" translate="yes" xml:space="preserve">
          <source>In Qt6, all &lt;code&gt;SAX&lt;/code&gt; classes have been removed from Qt XML, please use &lt;a href=&quot;xml-changes-qt6#qxmlstreamreader&quot;&gt;QXmlStreamReader&lt;/a&gt; for reading XML files. Here are some simple steps to port your current code to &lt;a href=&quot;xml-changes-qt6#qxmlstreamreader&quot;&gt;QXmlStreamReader&lt;/a&gt;:</source>
          <target state="translated">在Qt6中，所有的 &lt;code&gt;SAX&lt;/code&gt; 类都已从Qt XML中删除，请使用&lt;a href=&quot;xml-changes-qt6#qxmlstreamreader&quot;&gt;QXmlStreamReader&lt;/a&gt;读取XML文件。以下是一些简单的步骤，可将当前代码移植到&lt;a href=&quot;xml-changes-qt6#qxmlstreamreader&quot;&gt;QXmlStreamReader&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="3d6279affd075187d88a58e226aadfa9dd753edd" translate="yes" xml:space="preserve">
          <source>In Qt6, all methods taking the &lt;code&gt;QRegExp&lt;/code&gt; got removed from our code-base. Therefore it is very likely that you will have to port your application or library to &lt;a href=&quot;qtcore-changes-qt6#qregularexpression&quot;&gt;QRegularExpression&lt;/a&gt;.</source>
          <target state="translated">在Qt6中，所有采用 &lt;code&gt;QRegExp&lt;/code&gt; 的方法都已从我们的代码库中删除。因此，很有可能您必须将应用程序或库&lt;a href=&quot;qtcore-changes-qt6#qregularexpression&quot;&gt;移植&lt;/a&gt;到QRegularExpression。</target>
        </trans-unit>
        <trans-unit id="aef2571329f9ba43e99f797ee9547f63efa7ae07" translate="yes" xml:space="preserve">
          <source>In QtRO, a node is an endpoint for communication. In a remote objects network, each participant, be it a process or a device, needs its own node. QtRO is a peer-to-peer network, with connected nodes being the links in the network.</source>
          <target state="translated">在QtRO中,节点是一个通信的端点。在远程对象网络中,每个参与者,无论是进程还是设备,都需要自己的节点。QtRO是一个点对点的网络,连接的节点是网络中的链接。</target>
        </trans-unit>
        <trans-unit id="3fc1f1eaab49c5f920f4f94f193a125e33be9fe3" translate="yes" xml:space="preserve">
          <source>In QtRO, the original object is called the &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;Source&lt;/a&gt;. It's a fully-implemented C++ class, with the necessary business logic to provide the required functionality. Copies of this object are called &lt;a href=&quot;qtremoteobjects-replica#replica&quot;&gt;Replica&lt;/a&gt;s. You don&amp;rsquo;t need to write any C++ code for a replica; you request an instance from a node instead. While you do need some code to use the replica, such as connecting signals to your own slots, you don&amp;rsquo;t need to implement the internal behavior &amp;ndash; that's already done for you in the source.</source>
          <target state="translated">在QtRO中，原始对象称为&lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;Source&lt;/a&gt;。这是一个完全实现的C ++类，具有提供所需功能的必要业务逻辑。该对象的&lt;a href=&quot;qtremoteobjects-replica#replica&quot;&gt;副本&lt;/a&gt;称为Replica。您无需为副本编写任何C ++代码。您从节点请求实例。尽管确实需要一些代码来使用副本，例如将信号连接到自己的插槽，但是您无需实现内部行为-源代码中已经为您完成了。</target>
        </trans-unit>
        <trans-unit id="c2523a8f7408dd870d0a1d43a52286838bb0d211" translate="yes" xml:space="preserve">
          <source>In RPC, the client makes a request and waits for the response.</source>
          <target state="translated">在RPC中,客户端发出请求并等待响应。</target>
        </trans-unit>
        <trans-unit id="3cbbfe5979b17f206686250eb3f92a1fa75e464a" translate="yes" xml:space="preserve">
          <source>In RPC, the server doesn't push anything to the client unless it's in response to a request.</source>
          <target state="translated">在RPC中,服务器不会向客户端推送任何东西,除非是响应一个请求。</target>
        </trans-unit>
        <trans-unit id="45d3485287b17067f45fc7f064c5ee0de5a2fcc3" translate="yes" xml:space="preserve">
          <source>In TCP emulation mode, accepted clients use a single continuous byte stream for data transmission, and &lt;a href=&quot;qsctpserver&quot;&gt;QSctpServer&lt;/a&gt; acts like a plain &lt;a href=&quot;qtcpserver&quot;&gt;QTcpServer&lt;/a&gt;. Call &lt;a href=&quot;qtcpserver#nextPendingConnection&quot;&gt;nextPendingConnection&lt;/a&gt;() to accept the pending connection as a connected &lt;a href=&quot;qtcpsocket&quot;&gt;QTcpSocket&lt;/a&gt;. The function returns a pointer to a &lt;a href=&quot;qtcpsocket&quot;&gt;QTcpSocket&lt;/a&gt; in &lt;a href=&quot;qabstractsocket#SocketState-enum&quot;&gt;QAbstractSocket::ConnectedState&lt;/a&gt; that you can use for communicating with the client. This mode gives access only to basic SCTP protocol features. The socket transmits SCTP packets over IP at system level and interacts through the &lt;a href=&quot;qtcpsocket&quot;&gt;QTcpSocket&lt;/a&gt; interface with the application.</source>
          <target state="translated">在TCP仿真模式下，接受的客户端使用单个连续字节流进行数据传输，并且&lt;a href=&quot;qsctpserver&quot;&gt;QSctpServer的&lt;/a&gt;行为就像普通的&lt;a href=&quot;qtcpserver&quot;&gt;QTcpServer一样&lt;/a&gt;。调用&lt;a href=&quot;qtcpserver#nextPendingConnection&quot;&gt;nextPendingConnection&lt;/a&gt;（）以将挂起的连接接受为已连接的&lt;a href=&quot;qtcpsocket&quot;&gt;QTcpSocket&lt;/a&gt;。该函数返回一个指向&lt;a href=&quot;qtcpsocket&quot;&gt;与QTcpSocket&lt;/a&gt;在&lt;a href=&quot;qabstractsocket#SocketState-enum&quot;&gt;QAbstractSocket :: ConnectedState&lt;/a&gt;，您可以使用与客户机进行通信。此模式仅允许访问基本的SCTP协议功能。套接字在系统级别通过IP传输SCTP数据包，并通过&lt;a href=&quot;qtcpsocket&quot;&gt;QTcpSocket&lt;/a&gt;接口与应用程序进行交互。</target>
        </trans-unit>
        <trans-unit id="ee0f0e951922cb51b04638a512bf74e823d6f2f5" translate="yes" xml:space="preserve">
          <source>In TCP emulation mode, accepted clients use a single continuous byte stream for data transmission, and QSctpServer acts like a plain &lt;a href=&quot;qtcpserver&quot;&gt;QTcpServer&lt;/a&gt;. Call &lt;a href=&quot;qtcpserver#nextPendingConnection&quot;&gt;nextPendingConnection&lt;/a&gt;() to accept the pending connection as a connected &lt;a href=&quot;qtcpsocket&quot;&gt;QTcpSocket&lt;/a&gt;. The function returns a pointer to a &lt;a href=&quot;qtcpsocket&quot;&gt;QTcpSocket&lt;/a&gt; in &lt;a href=&quot;qabstractsocket#SocketState-enum&quot;&gt;QAbstractSocket::ConnectedState&lt;/a&gt; that you can use for communicating with the client. This mode gives access only to basic SCTP protocol features. The socket transmits SCTP packets over IP at system level and interacts through the &lt;a href=&quot;qtcpsocket&quot;&gt;QTcpSocket&lt;/a&gt; interface with the application.</source>
          <target state="translated">在TCP仿真模式下，接受的客户端使用单个连续字节流进行数据传输，并且QSctpServer的行为就像普通的&lt;a href=&quot;qtcpserver&quot;&gt;QTcpServer一样&lt;/a&gt;。调用&lt;a href=&quot;qtcpserver#nextPendingConnection&quot;&gt;nextPendingConnection&lt;/a&gt;（）以将挂起的连接接受为已连接的&lt;a href=&quot;qtcpsocket&quot;&gt;QTcpSocket&lt;/a&gt;。该函数返回一个指向&lt;a href=&quot;qtcpsocket&quot;&gt;与QTcpSocket&lt;/a&gt;在&lt;a href=&quot;qabstractsocket#SocketState-enum&quot;&gt;QAbstractSocket :: ConnectedState&lt;/a&gt;，您可以使用与客户机进行通信。此模式仅允许访问基本的SCTP协议功能。套接字在系统级别通过IP传输SCTP数据包，并通过&lt;a href=&quot;qtcpsocket&quot;&gt;QTcpSocket&lt;/a&gt;接口与应用程序进行交互。</target>
        </trans-unit>
        <trans-unit id="44a49ce007c82f83e07df2ca6d842352ca2d5348" translate="yes" xml:space="preserve">
          <source>In TolerantMode, the parser has the following behaviour:</source>
          <target state="translated">在TolerantMode中,解析器有以下行为。</target>
        </trans-unit>
        <trans-unit id="9ce703d78bc316e614736f30d7696a28179319d2" translate="yes" xml:space="preserve">
          <source>In Unicode, comparison is not necessarily possible and case conversion is very difficult at best. Unicode, covering the &quot;entire&quot; world, also includes most of the world's case and sorting problems. operator==() and friends will do comparison based purely on the numeric Unicode value (code point) of the characters, and &lt;a href=&quot;qchar#toUpper&quot;&gt;toUpper&lt;/a&gt;() and &lt;a href=&quot;qchar#toLower&quot;&gt;toLower&lt;/a&gt;() will do case changes when the character has a well-defined uppercase/lowercase equivalent. For locale-dependent comparisons, use &lt;a href=&quot;qstring#localeAwareCompare&quot;&gt;QString::localeAwareCompare&lt;/a&gt;().</source>
          <target state="translated">在Unicode中，比较不一定是可能的，并且大小写转换最多是非常困难的。涵盖&amp;ldquo;整个&amp;rdquo;世界的Unicode还包括世界上大多数情况下的大小写和排序问题。运算符==（）和朋友将完全根据字符的Unicode数字值（代码点）进行比较，当字符具有明确定义的大写/小写等效项时，&lt;a href=&quot;qchar#toUpper&quot;&gt;toUpper&lt;/a&gt;（）和&lt;a href=&quot;qchar#toLower&quot;&gt;toLower&lt;/a&gt;（）将进行大小写更改。对于与语言环境相关的比较，请使用&lt;a href=&quot;qstring#localeAwareCompare&quot;&gt;QString :: localeAwareCompare&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="2af810392d2eed210bbaa3693616186a26defb42" translate="yes" xml:space="preserve">
          <source>In Unix, if the</source>
          <target state="translated">在Unix中,如果</target>
        </trans-unit>
        <trans-unit id="494e9f241ce2d3b45a99d226ba6b7caf13fad469" translate="yes" xml:space="preserve">
          <source>In Windows a request for the &quot;Courier&quot; font is automatically changed to &quot;Courier New&quot;, an improved version of Courier that allows for smooth scaling. The older &quot;Courier&quot; bitmap font can be selected by setting the &lt;a href=&quot;qfont#StyleStrategy-enum&quot;&gt;PreferBitmap&lt;/a&gt; style strategy (see &lt;a href=&quot;qfont#setStyleStrategy&quot;&gt;setStyleStrategy&lt;/a&gt;()).</source>
          <target state="translated">在Windows中，对&amp;ldquo; Courier&amp;rdquo;字体的请求会自动更改为&amp;ldquo; Courier New&amp;rdquo;，这是Courier的改进版本，可以平滑缩放。可以通过设置&lt;a href=&quot;qfont#StyleStrategy-enum&quot;&gt;PreferBitmap&lt;/a&gt;样式策略来选择较早的&amp;ldquo; Courier&amp;rdquo;位图字体（请参阅&lt;a href=&quot;qfont#setStyleStrategy&quot;&gt;setStyleStrategy&lt;/a&gt;（））。</target>
        </trans-unit>
        <trans-unit id="6ce2ce9fe5778060c4194ef00f287de9d761cae7" translate="yes" xml:space="preserve">
          <source>In Windows,</source>
          <target state="translated">在Windows中。</target>
        </trans-unit>
        <trans-unit id="9bf983d41771df979f4153d3847cee83fa0e0748" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;Transition&lt;/a&gt;</source>
          <target state="translated">在&lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;过渡&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="16c8daa95d653d72d94cd314dc58feaaa5539d88" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;https://doc.qt.io/qt-5.15/qmlexampletoggleswitch.html#transition&quot;&gt;Transition&lt;/a&gt;</source>
          <target state="translated">在&lt;a href=&quot;https://doc.qt.io/qt-5.15/qmlexampletoggleswitch.html#transition&quot;&gt;过渡&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2be23374ee037d7134eb6bf62d981de285fa009b" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;https://doc.qt.io/qt-6.0/qmlexampletoggleswitch.html#transition&quot;&gt;Transition&lt;/a&gt;</source>
          <target state="translated">在&lt;a href=&quot;https://doc.qt.io/qt-6.0/qmlexampletoggleswitch.html#transition&quot;&gt;过渡&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6653e14008f4417e834970c4961ea469d9475daf" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; with stickyFocus set to true, focus will remain unchanged when the user clicks into the scene background or on an item that does not accept focus. Otherwise, focus will be cleared.</source>
          <target state="translated">在将stickyFocus设置为true 的&lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene中&lt;/a&gt;，当用户单击场景背景或不接受焦点的项目时，焦点将保持不变。否则，焦点将被清除。</target>
        </trans-unit>
        <trans-unit id="f7eb4b68c9bdf8cfec5b4299db1dd99f11fbebbc" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;qml-qtquick-behavior&quot;&gt;Behavior&lt;/a&gt;</source>
          <target state="translated">在&lt;a href=&quot;qml-qtquick-behavior&quot;&gt;行为上&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9c4518881d0fae2553c0574fe79a4ce737d3d4d5" translate="yes" xml:space="preserve">
          <source>In a PSK handshake, the client must derive a key, which must match the key set on the server. The exact algorithm of deriving the key depends on the application; however, for this purpose, the server may send an</source>
          <target state="translated">在PSK握手过程中,客户端必须推导出一个密钥,该密钥必须与服务器上设置的密钥相匹配。获取密钥的确切算法取决于应用程序;但是,为了达到这个目的,服务器可以发送一个</target>
        </trans-unit>
        <trans-unit id="fab0475567a2f1adb31f2020c772c1ffed8a805f" translate="yes" xml:space="preserve">
          <source>In a QtRO network, information is passed between processes via QRemoteObjectNodes (&quot;nodes&quot;). This peer-to-peer functionality uses a small number of distinct packets passing the necessary data between nodes.</source>
          <target state="translated">在QtRO网络中,信息通过QRemoteObjectNodes(&quot;节点&quot;)在进程之间传递。这种点对点功能使用少量不同的数据包在节点之间传递必要的数据。</target>
        </trans-unit>
        <trans-unit id="6218f8eee9e61e6aa5151636d0b2ccf7e487e310" translate="yes" xml:space="preserve">
          <source>In a Unicode context some positions in the text are not valid cursor positions, because the position is inside a Unicode surrogate or a grapheme cluster.</source>
          <target state="translated">在Unicode上下文中,文本中的某些位置不是有效的光标位置,因为该位置位于Unicode代用词或词组群内。</target>
        </trans-unit>
        <trans-unit id="5c39f0e8ca68705256be1acacf31347f7302d59a" translate="yes" xml:space="preserve">
          <source>In a Window without a tab bar, toolbar, or URL bar.</source>
          <target state="translated">在一个没有标签栏、工具栏或URL栏的窗口中。</target>
        </trans-unit>
        <trans-unit id="f5da8f790fb4231ba27c98ca26644ab6a296d548" translate="yes" xml:space="preserve">
          <source>In a class that uses &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtuitools-module.html&quot;&gt;QtUiTools&lt;/a&gt; to build its user interface at run time, we can locate objects in the form using &lt;a href=&quot;qobject#findChild&quot;&gt;QObject::findChild&lt;/a&gt;(). For example, in the following code, we locate some components based on their object names and widget types:</source>
          <target state="translated">在使用&lt;a href=&quot;https://doc.qt.io/qt-5.13/qtuitools-module.html&quot;&gt;QtUiTools&lt;/a&gt;在运行时构建其用户界面的类中，我们可以使用&lt;a href=&quot;qobject#findChild&quot;&gt;QObject :: findChild&lt;/a&gt;（）查找表单中的对象。例如，在以下代码中，我们根据组件的对象名称和窗口小部件类型来定位它们：</target>
        </trans-unit>
        <trans-unit id="c72b219d913a224b855c63ccb60d517b88cd9948" translate="yes" xml:space="preserve">
          <source>In a class that uses &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtuitools-module.html&quot;&gt;QtUiTools&lt;/a&gt; to build its user interface at run time, we can locate objects in the form using &lt;a href=&quot;qobject#findChild&quot;&gt;QObject::findChild&lt;/a&gt;(). For example, in the following code, we locate some components based on their object names and widget types:</source>
          <target state="translated">在使用&lt;a href=&quot;https://doc.qt.io/qt-5.15/qtuitools-module.html&quot;&gt;QtUiTools&lt;/a&gt;在运行时构建其用户界面的类中，我们可以使用&lt;a href=&quot;qobject#findChild&quot;&gt;QObject :: findChild&lt;/a&gt;（）查找表单中的对象。例如，在以下代码中，我们根据组件的对象名称和窗口小部件类型来定位它们：</target>
        </trans-unit>
        <trans-unit id="7f2311f88b30094f9016ca99e37c13ba7ce30e59" translate="yes" xml:space="preserve">
          <source>In a class that uses &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtuitools-module.html&quot;&gt;QtUiTools&lt;/a&gt; to build its user interface at run time, we can locate objects in the form using &lt;a href=&quot;qobject#findChild&quot;&gt;QObject::findChild&lt;/a&gt;(). For example, in the following code, we locate some components based on their object names and widget types:</source>
          <target state="translated">在使用&lt;a href=&quot;https://doc.qt.io/qt-6.0/qtuitools-module.html&quot;&gt;QtUiTools&lt;/a&gt;在运行时构建其用户界面的类中，我们可以使用&lt;a href=&quot;qobject#findChild&quot;&gt;QObject :: findChild&lt;/a&gt;（）查找表单中的对象。例如，在以下代码中，我们根据组件的对象名称和窗口小部件类型来定位它们：</target>
        </trans-unit>
        <trans-unit id="5aa355897d713d5ad162616e9f25066da691a1b2" translate="yes" xml:space="preserve">
          <source>In a data-driven test, marks the row associated with</source>
          <target state="translated">在数据驱动的测试中,标记与以下内容相关的行</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
