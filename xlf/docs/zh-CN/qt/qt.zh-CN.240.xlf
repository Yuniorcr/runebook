<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="qt">
    <body>
      <group id="qt">
        <trans-unit id="adf54fd7881b01dd5fbb317fe0878e5876b7ee5a" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qvulkanwindow#supportsGrab&quot;&gt;supportsGrab&lt;/a&gt;() returns true, &lt;a href=&quot;qvulkanwindow&quot;&gt;QVulkanWindow&lt;/a&gt; can perform readbacks from the color buffer into a &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt;. &lt;a href=&quot;qvulkanwindow#grab&quot;&gt;grab&lt;/a&gt;() is a slow and inefficient operation, so frequent usage should be avoided. It is nonetheless valuable since it allows applications to take screenshots, or tools and tests to process and verify the output of the GPU rendering.</source>
          <target state="translated">当&lt;a href=&quot;qvulkanwindow#supportsGrab&quot;&gt;supportsGrab&lt;/a&gt;（）返回true时，&lt;a href=&quot;qvulkanwindow&quot;&gt;QVulkanWindow&lt;/a&gt;可以将颜色缓冲区中的内容读回到&lt;a href=&quot;qimage&quot;&gt;QImage中&lt;/a&gt;。&lt;a href=&quot;qvulkanwindow#grab&quot;&gt;catch&lt;/a&gt;（）是一种缓慢且效率低下的操作，因此应避免频繁使用。尽管如此，它还是很有价值的，因为它允许应用程序截取屏幕截图，或者使用工具和测试来处理和验证GPU渲染的输出。</target>
        </trans-unit>
        <trans-unit id="a855aaf2660d645fa9b8949d66a891591b9ae74f" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qvulkanwindow#supportsGrab&quot;&gt;supportsGrab&lt;/a&gt;() returns true, QVulkanWindow can perform readbacks from the color buffer into a &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt;. &lt;a href=&quot;qvulkanwindow#grab&quot;&gt;grab&lt;/a&gt;() is a slow and inefficient operation, so frequent usage should be avoided. It is nonetheless valuable since it allows applications to take screenshots, or tools and tests to process and verify the output of the GPU rendering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6823f0c205033d4ea128122af4b97d19b1b0c274" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qxmlquery&quot;&gt;QXmlQuery&lt;/a&gt; accesses resources (e.g., calling &lt;code&gt;fn:doc()&lt;/code&gt; to load a file, or accessing a device via a bound variable), the event loop is used, which means events will be processed. To avoid processing events when &lt;a href=&quot;qxmlquery&quot;&gt;QXmlQuery&lt;/a&gt; accesses resources, create your &lt;a href=&quot;qxmlquery&quot;&gt;QXmlQuery&lt;/a&gt; instance in a separate thread.</source>
          <target state="translated">当&lt;a href=&quot;qxmlquery&quot;&gt;QXmlQuery&lt;/a&gt;访问资源（例如，调用 &lt;code&gt;fn:doc()&lt;/code&gt; 加载文件或通过绑定变量访问设备）时，将使用事件循环，这意味着将处理事件。为了避免在&lt;a href=&quot;qxmlquery&quot;&gt;QXmlQuery&lt;/a&gt;访问资源时处理事件，请在单独的线程中创建&lt;a href=&quot;qxmlquery&quot;&gt;QXmlQuery&lt;/a&gt;实例。</target>
        </trans-unit>
        <trans-unit id="5a4303763eb160478daacc616e1e09a84ccb3fd3" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qxmlquery&quot;&gt;QXmlQuery&lt;/a&gt; calls &lt;a href=&quot;qabstractmessagehandler#message&quot;&gt;QAbstractMessageHandler::message&lt;/a&gt;(), the arguments are as follows:</source>
          <target state="translated">当&lt;a href=&quot;qxmlquery&quot;&gt;QXmlQuery&lt;/a&gt;调用&lt;a href=&quot;qabstractmessagehandler#message&quot;&gt;QAbstractMessageHandler :: message&lt;/a&gt;（）时，参数如下：</target>
        </trans-unit>
        <trans-unit id="2414e2eb1638148ea5acad1b6c425e2a2fa8d639" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qxmlquery#setQuery&quot;&gt;setQuery&lt;/a&gt;() is called, the query text is compiled into an internal data structure and optimized. The optimized form can then be reused for multiple evaluations of the query. Since the compile-and-optimize process can be expensive, repeating it for the same query should be avoided by using a separate instance of &lt;a href=&quot;qxmlquery&quot;&gt;QXmlQuery&lt;/a&gt; for each query text.</source>
          <target state="translated">当&lt;a href=&quot;qxmlquery#setQuery&quot;&gt;setQuery&lt;/a&gt;（）被调用时，查询文本被编译成内部数据结构和优化。然后可以将优化的表单重新用于查询的多个评估。由于编译和优化过程可能会很昂贵，因此应通过为每个查询文本使用单独的&lt;a href=&quot;qxmlquery&quot;&gt;QXmlQuery&lt;/a&gt;实例来避免针对同一查询重复该过程。</target>
        </trans-unit>
        <trans-unit id="df60f13705bccbfb1ebe641d5980c4f255529f48" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qxmlquery#setQuery&quot;&gt;setQuery&lt;/a&gt;() is called, the query text is compiled into an internal data structure and optimized. The optimized form can then be reused for multiple evaluations of the query. Since the compile-and-optimize process can be expensive, repeating it for the same query should be avoided by using a separate instance of QXmlQuery for each query text.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f0e33d48640a9980a60399682ba53ff818618de" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qxmlschema&quot;&gt;QXmlSchema&lt;/a&gt; calls &lt;a href=&quot;qabstractmessagehandler#message&quot;&gt;QAbstractMessageHandler::message&lt;/a&gt;(), the arguments are as follows:</source>
          <target state="translated">当&lt;a href=&quot;qxmlschema&quot;&gt;QXmlSchema&lt;/a&gt;调用&lt;a href=&quot;qabstractmessagehandler#message&quot;&gt;QAbstractMessageHandler :: message&lt;/a&gt;（）时，参数如下：</target>
        </trans-unit>
        <trans-unit id="34a36de9f3978a9dc52660020f38e10757c3b33a" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qxmlschemavalidator&quot;&gt;QXmlSchemaValidator&lt;/a&gt; calls &lt;a href=&quot;qabstractmessagehandler#message&quot;&gt;QAbstractMessageHandler::message&lt;/a&gt;(), the arguments are as follows:</source>
          <target state="translated">当&lt;a href=&quot;qxmlschemavalidator&quot;&gt;QXmlSchemaValidator&lt;/a&gt;调用&lt;a href=&quot;qabstractmessagehandler#message&quot;&gt;QAbstractMessageHandler :: message&lt;/a&gt;（）时，参数如下：</target>
        </trans-unit>
        <trans-unit id="abc180cdaa67db2334bc9aec8221bc677db91dc0" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&amp;lt;param&amp;gt;&lt;/code&gt; elements are used in the &lt;code&gt;&amp;lt;send&amp;gt;&lt;/code&gt; element, the data will contain a &lt;a href=&quot;qvariant#QVariantMap-typedef&quot;&gt;QVariantMap&lt;/a&gt; where the key is the</source>
          <target state="translated">在 &lt;code&gt;&amp;lt;param&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;send&amp;gt;&lt;/code&gt; &amp;gt;元素中使用&amp;lt;param&amp;gt;元素时，数据将包含&lt;a href=&quot;qvariant#QVariantMap-typedef&quot;&gt;QVariantMap&lt;/a&gt;，其中键为</target>
        </trans-unit>
        <trans-unit id="a06133ee79a232acbfba343775e247dd1fc22db2" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;GL_ARB_framebuffer_sRGB&lt;/code&gt; or &lt;code&gt;GL_EXT_framebuffer_sRGB&lt;/code&gt; is supported by the platform and this value is set, the window will be created with an sRGB-capable default framebuffer. Note that some platforms may return windows with a sRGB-capable default framebuffer even when not requested explicitly.</source>
          <target state="translated">当平台支持 &lt;code&gt;GL_ARB_framebuffer_sRGB&lt;/code&gt; 或 &lt;code&gt;GL_EXT_framebuffer_sRGB&lt;/code&gt; 并设置了该值时，将使用支持sRGB的默认帧缓冲区创建窗口。请注意，即使未明确请求，某些平台也可能返回带有sRGB功能的默认帧缓冲区的窗口。</target>
        </trans-unit>
        <trans-unit id="aa3913ff2ab5c3e811ba7c183222c6fcac1a3447" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;QT_OPENGL_BUGLIST&lt;/code&gt; is not specified, a built-in list will be used. This typically includes some older, less-capable graphics cards with &lt;code&gt;disable_desktopgl&lt;/code&gt; set, in order to prevent Qt from using their unstable desktop OpenGL implementations and instead fall back to ANGLE right away.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed4d9b70602719a6967792783570916cdfb715ef" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;button&lt;/code&gt; is clicked, the machine will transition into state &lt;code&gt;s2&lt;/code&gt;, which will set the geometry of the button, and then pop up a message box to alert the user that the geometry has been changed.</source>
          <target state="translated">当 &lt;code&gt;button&lt;/code&gt; 被点击时，机器将过渡到状态 &lt;code&gt;s2&lt;/code&gt; ，其将设置按钮的几何形状，然后弹出一个消息框以警告几何已经改变的用户。</target>
        </trans-unit>
        <trans-unit id="2388f2e21addac6210aabde322ea581bb6afffb1" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;mode&lt;/code&gt; is not defined, the mode that is reported as preferred by the system is chosen. The accepted values for &lt;code&gt;mode&lt;/code&gt; are: &lt;code&gt;off&lt;/code&gt;, &lt;code&gt;current&lt;/code&gt;, &lt;code&gt;preferred&lt;/code&gt;, &lt;code&gt;skip&lt;/code&gt;, width&lt;code&gt;x&lt;/code&gt;height, width&lt;code&gt;x&lt;/code&gt;height&lt;code&gt;@&lt;/code&gt;vrefresh, or a modeline string.</source>
          <target state="translated">当 &lt;code&gt;mode&lt;/code&gt; 没有被定义时，选择由该系统报告为优选的方式。 &lt;code&gt;mode&lt;/code&gt; 的可接受值为： &lt;code&gt;off&lt;/code&gt; ， &lt;code&gt;current&lt;/code&gt; ， &lt;code&gt;preferred&lt;/code&gt; ， &lt;code&gt;skip&lt;/code&gt; ，width &lt;code&gt;x&lt;/code&gt; height，width &lt;code&gt;x&lt;/code&gt; height &lt;code&gt;@&lt;/code&gt; vrefresh或modeline字符串。</target>
        </trans-unit>
        <trans-unit id="ad2de4e55d4aebd9b4557d94a6cf5c7e0065f8b8" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;mode&lt;/code&gt; is not defined, the system's preferred mode is chosen. The accepted values for &lt;code&gt;mode&lt;/code&gt; are: &lt;code&gt;off&lt;/code&gt;, &lt;code&gt;current&lt;/code&gt;, &lt;code&gt;preferred&lt;/code&gt;, &lt;code&gt;skip&lt;/code&gt;, width&lt;code&gt;x&lt;/code&gt;height, width&lt;code&gt;x&lt;/code&gt;height&lt;code&gt;@&lt;/code&gt;vrefresh, or a modeline string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bebb2b33e2691fc3d175656c1b70af1ee1b6346d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;reanchorToRight&lt;/code&gt; is called, the function first sets the right anchor. At that point, both left and right anchors are set, and the item will be stretched horizontally to fill its parent. When the left anchor is unset, the new width will remain. Thus when updating anchors within JavaScript, you should first unset any anchors that are no longer required, and only then set any new anchors that are required, as shown below:</source>
          <target state="translated">当 &lt;code&gt;reanchorToRight&lt;/code&gt; 被调用时，函数首先设置正确的锚。此时，将设置左右锚点，然后将水平拉伸该项目以填充其父项。取消设置左锚点后，新的宽度将保留。因此，在JavaScript中更新锚点时，您应首先取消设置不再需要的所有锚点，然后再设置所需的任何新的锚点，如下所示：</target>
        </trans-unit>
        <trans-unit id="8825f7725f1dc91940c2a034ec29bd99db520ddf" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;s1&lt;/code&gt; 's final state is entered, &lt;code&gt;s1&lt;/code&gt; will automatically emit &lt;a href=&quot;qml-qtqml-statemachine-state#finished-signal&quot;&gt;finished&lt;/a&gt;. We use a signal transition to cause this event to trigger a state change:</source>
          <target state="translated">当进入 &lt;code&gt;s1&lt;/code&gt; 的最终状态时， &lt;code&gt;s1&lt;/code&gt; 将自动发出&lt;a href=&quot;qml-qtqml-statemachine-state#finished-signal&quot;&gt;finish&lt;/a&gt;。我们使用信号转换来导致此事件触发状态更改：</target>
        </trans-unit>
        <trans-unit id="a068e7c1d71be79be1747b295f8d0bdf7d0f76ad" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;s1&lt;/code&gt; 's final state is entered, &lt;code&gt;s1&lt;/code&gt; will automatically emit &lt;a href=&quot;qstate#finished&quot;&gt;finished()&lt;/a&gt;. We use a signal transition to cause this event to trigger a state change:</source>
          <target state="translated">当进入 &lt;code&gt;s1&lt;/code&gt; 的最终状态时， &lt;code&gt;s1&lt;/code&gt; 将自动发出&lt;a href=&quot;qstate#finished&quot;&gt;finish（）&lt;/a&gt;。我们使用信号转换来导致此事件触发状态更改：</target>
        </trans-unit>
        <trans-unit id="7c85d7dd31dd96c49b09a16e731e181b35179393" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;text&lt;/code&gt; changes, the C++ property &lt;code&gt;enteredText&lt;/code&gt; will update automatically.</source>
          <target state="translated">当 &lt;code&gt;text&lt;/code&gt; 的变化，C ++财产 &lt;code&gt;enteredText&lt;/code&gt; 将自动更新。</target>
        </trans-unit>
        <trans-unit id="274f974610c7463228dfb5154f647e8c8a8ccdcb" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;true&lt;/code&gt;, all generated numbers appearing in various series and axis labels will be localized using the &lt;a href=&quot;qlocale&quot;&gt;QLocale&lt;/a&gt; set with the &lt;a href=&quot;qchart#locale-prop&quot;&gt;locale&lt;/a&gt; property. When &lt;code&gt;false&lt;/code&gt;, the</source>
          <target state="translated">设置为 &lt;code&gt;true&lt;/code&gt; 时，将使用带有&lt;a href=&quot;qchart#locale-prop&quot;&gt;locale&lt;/a&gt;属性的&lt;a href=&quot;qlocale&quot;&gt;QLocale&lt;/a&gt;集来本地化出现在各个系列和轴标签中的所有生成的数字。如果为 &lt;code&gt;false&lt;/code&gt; ，则</target>
        </trans-unit>
        <trans-unit id="36e568b70799170c0d96b90a8147537bfc741c8b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;true&lt;/code&gt;, all generated numbers appearing in various series and axis labels will be localized using the &lt;a href=&quot;qlocale&quot;&gt;QLocale&lt;/a&gt; set with the &lt;a href=&quot;qml-qtcharts-chartview#locale-prop&quot;&gt;locale&lt;/a&gt; property. When &lt;code&gt;false&lt;/code&gt;, the</source>
          <target state="translated">设置为 &lt;code&gt;true&lt;/code&gt; 时，将使用带有&lt;a href=&quot;qml-qtcharts-chartview#locale-prop&quot;&gt;locale&lt;/a&gt;属性的&lt;a href=&quot;qlocale&quot;&gt;QLocale&lt;/a&gt;集来本地化出现在各个系列和轴标签中的所有生成的数字。如果为 &lt;code&gt;false&lt;/code&gt; ，则</target>
        </trans-unit>
        <trans-unit id="3e953b3a9be5222efb277759886bb97613fdfda7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;true&lt;/code&gt;, the style should underline the menu item's label mnemonic.</source>
          <target state="translated">如果为 &lt;code&gt;true&lt;/code&gt; ，则样式应在菜单项的标签助记符下划线。</target>
        </trans-unit>
        <trans-unit id="3172ee2682029786deccd528a524db012a091668" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;virtualIndex&lt;/code&gt; is not sufficient, the &lt;code&gt;virtualPos&lt;/code&gt; property can be used to explicitly specify the top-left position of the screen in question. Taking the previous example and assuming a resolution of 1080p for HDMI1, the following code snippet places a second HDMI-based screen below the first one:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21a5b61887b0cac6a56dd588dce0ad7f3bbdb837" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;virtualIndex&lt;/code&gt; is not sufficient, the property &lt;code&gt;virtualPos&lt;/code&gt; can be used to explicitly specify the top-left position of the screen in question. Taking the previous example and assuming a resolution of 1080p for HDMI1, the following places a second HDMI-based screen below the first one:</source>
          <target state="translated">当 &lt;code&gt;virtualIndex&lt;/code&gt; 不足时，可以使用属性 &lt;code&gt;virtualPos&lt;/code&gt; 显式指定所讨论屏幕的左上位置。以前面的示例为例，假设HDMI1的分辨率为1080p，下面将在第二个基于HDMI的屏幕下方放置一个屏幕：</target>
        </trans-unit>
        <trans-unit id="ce9c2c5e673edc4df91dd9cd97b16eb59ee71073" translate="yes" xml:space="preserve">
          <source>When DPI scaling is used by the system, the logical surface size, which is used by mouse events, and the actual 'physical' size of the surface can differ. The &lt;a href=&quot;qml-qt3d-render-rendersurfaceselector#surfacePixelRatio-prop&quot;&gt;surfacePixelRatio&lt;/a&gt; is the factor to convert the logical size to the physical size.</source>
          <target state="translated">当系统使用DPI缩放时，鼠标事件使用的逻辑表面大小和表面的实际&amp;ldquo;物理&amp;rdquo;大小可能会有所不同。该&lt;a href=&quot;qml-qt3d-render-rendersurfaceselector#surfacePixelRatio-prop&quot;&gt;surfacePixelRatio&lt;/a&gt;是逻辑大小转换为物理尺寸的因素。</target>
        </trans-unit>
        <trans-unit id="67b4917a54c5a1f83822bb816252770e66fe2a99" translate="yes" xml:space="preserve">
          <source>When DPI scaling is used by the system, the logical surface size, which is used by mouse events, and the actual 'physical' size of the surface can differ. The &lt;a href=&quot;qt3drender-qrendersurfaceselector#surfacePixelRatio-prop&quot;&gt;surfacePixelRatio&lt;/a&gt; is the factor to convert the logical size to the physical size.</source>
          <target state="translated">当系统使用DPI缩放时，鼠标事件使用的逻辑表面大小和表面的实际&amp;ldquo;物理&amp;rdquo;大小可能会有所不同。该&lt;a href=&quot;qt3drender-qrendersurfaceselector#surfacePixelRatio-prop&quot;&gt;surfacePixelRatio&lt;/a&gt;是逻辑大小转换为物理尺寸的因素。</target>
        </trans-unit>
        <trans-unit id="f1b60dd5dc0ba61c9eadb5e24ff7b6a22b038279" translate="yes" xml:space="preserve">
          <source>When FPS measuring is enabled, the results for the last second are stored in this read-only property. It takes at least a second before this value updates after measuring is activated.</source>
          <target state="translated">当启用FPS测量时,最后一秒的结果存储在这个只读属性中。在测量被激活后,至少需要一秒钟的时间才能更新此值。</target>
        </trans-unit>
        <trans-unit id="c6d97e48bea8d713090e390fc1224dfc4ec5d0cc" translate="yes" xml:space="preserve">
          <source>When HSTS is enabled, for each HTTP response containing HSTS header and received over a secure transport, &lt;a href=&quot;qnetworkaccessmanager&quot;&gt;QNetworkAccessManager&lt;/a&gt; will update its HSTS cache, either remembering a host with a valid policy or removing a host with an expired or disabled HSTS policy.</source>
          <target state="translated">启用HSTS后，对于每个通过安全传输接收到的包含HSTS标头的HTTP响应，&lt;a href=&quot;qnetworkaccessmanager&quot;&gt;QNetworkAccessManager&lt;/a&gt;将更新其HSTS缓存，或者记住具有有效策略的主机，或者删除具有过期或禁用HSTS策略的主机。</target>
        </trans-unit>
        <trans-unit id="c813b063d1c6a422bc40a6bf5d97ec4ee0b41451" translate="yes" xml:space="preserve">
          <source>When HTML markup is used for text, Qt follows the rules defined by the &lt;a href=&quot;http://www.w3.org/TR/html401/&quot;&gt;HTML 4&lt;/a&gt; specification. This includes default properties for text layout, such as the direction of the text flow (left-to-right) which can be changed by applying the &lt;a href=&quot;#block-attributes&quot;&gt;&lt;code&gt;dir&lt;/code&gt;&lt;/a&gt; attribute to blocks of text.</source>
          <target state="translated">当HTML标记用于文本时，Qt遵循&lt;a href=&quot;http://www.w3.org/TR/html401/&quot;&gt;HTML 4&lt;/a&gt;规范定义的规则。这包括用于文本布局的默认属性，例如文本流的方向（从左到右），可以通过将&lt;a href=&quot;#block-attributes&quot;&gt; &lt;code&gt;dir&lt;/code&gt; &lt;/a&gt;属性应用于文本块来更改其方向。</target>
        </trans-unit>
        <trans-unit id="19e584a3c410cba7dfa95ae08639cd95d012b6b9" translate="yes" xml:space="preserve">
          <source>When HTML markup is used for text, Qt follows the rules defined by the &lt;a href=&quot;http://www.w3.org/TR/html401/&quot;&gt;HTML 4&lt;/a&gt; specification. This includes default properties for text layout, such as the direction of the text flow (left-to-right) which can be changed by applying the &lt;a href=&quot;richtext-html-subset#block-attributes&quot;&gt;&lt;code&gt;dir&lt;/code&gt;&lt;/a&gt; attribute to blocks of text.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d031a5aad62e51b34085c95c6997afabca63874d" translate="yes" xml:space="preserve">
          <source>When LayoutDirectionAuto is used in conjunction with text layouting, it will imply that the text directionality is determined from the content of the string to be layouted.</source>
          <target state="translated">当LayoutDirectionAuto与文本布局结合使用时,它将意味着文本方向性是由要布局的字符串内容决定的。</target>
        </trans-unit>
        <trans-unit id="66418f264bb909da3c52c062e8ec0fb65ed558c8" translate="yes" xml:space="preserve">
          <source>When QDoc generates documentation for a project, it will also generate an &lt;code&gt;.index&lt;/code&gt; file containing URLs to each linkable entity in the project. Each dependency is a (lowercase) name of a project. This name must match with the base name of the index file generated for that project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dc427b9427e3f31178f1302dfba94644ceb86f8" translate="yes" xml:space="preserve">
          <source>When QML types produce logging messages, it improves traceability if they include the QML file and line number on which the particular instance was instantiated.</source>
          <target state="translated">当QML类型产生日志消息时,如果它们包含了特定实例被实例化的QML文件和行号,就可以提高可追溯性。</target>
        </trans-unit>
        <trans-unit id="28bd2e83bcbfe95859e587b4383125510038621a" translate="yes" xml:space="preserve">
          <source>When QPickingSettings::pickMode() is set to &lt;a href=&quot;qt3drender-qpickingsettings#PickMethod-enum&quot;&gt;QPickingSettings::TrianglePicking&lt;/a&gt;, the signals on &lt;a href=&quot;qt3drender-qobjectpicker&quot;&gt;QObjectPicker&lt;/a&gt; will carry an instance of &lt;a href=&quot;qt3drender-qpicktriangleevent&quot;&gt;QPickTriangleEvent&lt;/a&gt;.</source>
          <target state="translated">当QPickingSettings :: pickMode（）设置为&lt;a href=&quot;qt3drender-qpickingsettings#PickMethod-enum&quot;&gt;QPickingSettings :: TrianglePicking时&lt;/a&gt;，&lt;a href=&quot;qt3drender-qobjectpicker&quot;&gt;QObjectPicker&lt;/a&gt;上的信号将携带一个&lt;a href=&quot;qt3drender-qpicktriangleevent&quot;&gt;QPickTriangleEvent&lt;/a&gt;实例。</target>
        </trans-unit>
        <trans-unit id="df9dd3cc9e117bbee05447ec8831a1da2303f862" translate="yes" xml:space="preserve">
          <source>When QPickingSettings::pickMode() is set to &lt;a href=&quot;qt3drender-qpickingsettings#PickMethod-enum&quot;&gt;QPickingSettings::TrianglePicking&lt;/a&gt;, the signals on &lt;a href=&quot;qt3drender-qobjectpicker&quot;&gt;QObjectPicker&lt;/a&gt; will carry an instance of QPickTriangleEvent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="457be61d0f002d025c887c713d51fbbfadff17ad" translate="yes" xml:space="preserve">
          <source>When QPickingSettings::pickMode() is set to QPickingSettings::TrianglePicking, the signals on QObjectPicker will carry an instance of QPickTriangleEvent.</source>
          <target state="translated">当QPickingSettings::pickMode()设置为QPickingSettings::TrianglePicking时,QObjectPicker上的信号将携带一个QPickTriangleEvent的实例。</target>
        </trans-unit>
        <trans-unit id="508f9df752233b565bb26370c5a26e20603658ac" translate="yes" xml:space="preserve">
          <source>When QPlainTextEdit is used read-only the key bindings are limited to navigation, and text may only be selected with the mouse:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b3dce7cb91174e257ba7a5b773f5733c0ba5ef8" translate="yes" xml:space="preserve">
          <source>When QRegExpValidator determines whether a string is &lt;a href=&quot;qvalidator#State-enum&quot;&gt;Acceptable&lt;/a&gt; or not, the regexp is treated as if it begins with the start of string assertion (&lt;b&gt;^&lt;/b&gt;) and ends with the end of string assertion (&lt;b&gt;$&lt;/b&gt;); the match is against the entire input string, or from the given position if a start position greater than zero is given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44b35bfd10db30a7d0a3ac39d2072ec92e99876a" translate="yes" xml:space="preserve">
          <source>When QTextEdit is used read-only the key bindings are limited to navigation, and text may only be selected with the mouse:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b100506a7296cf4856e2d55c43642a514b0d282b" translate="yes" xml:space="preserve">
          <source>When QXmlQuery accesses resources (e.g., calling &lt;code&gt;fn:doc()&lt;/code&gt; to load a file, or accessing a device via a bound variable), the event loop is used, which means events will be processed. To avoid processing events when QXmlQuery accesses resources, create your QXmlQuery instance in a separate thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="228d842e43fc176fb1a2d3aa0180185c47dc88bd" translate="yes" xml:space="preserve">
          <source>When Qt XML Patterns calls &lt;a href=&quot;qabstracturiresolver#resolve&quot;&gt;QAbstractUriResolver::resolve&lt;/a&gt;() the absolute URI is the URI mandated by the &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; language, and the relative URI is the URI specified by the user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7ad967bec3128bd4f1fd05f2c5749f62466760b" translate="yes" xml:space="preserve">
          <source>When Qt XML Patterns calls &lt;a href=&quot;qabstracturiresolver#resolve&quot;&gt;QAbstractUriResolver::resolve&lt;/a&gt;() the absolute URI is the URI mandated by the &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; language, and the relative URI is the URI specified by the user.</source>
          <target state="translated">当Qt XML模式调用&lt;a href=&quot;qabstracturiresolver#resolve&quot;&gt;QAbstractUriResolver :: resolve&lt;/a&gt;（）时，绝对URI是&lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt;语言规定的URI ，而相对URI是用户指定的URI。</target>
        </trans-unit>
        <trans-unit id="f47f9cfcc0372f2d7543bfb2e549c724e778aa90" translate="yes" xml:space="preserve">
          <source>When Qt XML Patterns calls &lt;a href=&quot;qabstracturiresolver#resolve&quot;&gt;QAbstractUriResolver::resolve&lt;/a&gt;() the absolute URI is the URI mandated by the schema specification, and the relative URI is the URI specified by the user.</source>
          <target state="translated">当Qt XML模式调用&lt;a href=&quot;qabstracturiresolver#resolve&quot;&gt;QAbstractUriResolver :: resolve&lt;/a&gt;（）时，绝对URI是架构规范规定的URI，而相对URI是用户指定的URI。</target>
        </trans-unit>
        <trans-unit id="b7e889092d153ecf78cedbfcbcb9a5e6e6e850e1" translate="yes" xml:space="preserve">
          <source>When Qt XML Patterns evaluate path expressions, it emulate them through a combination of calls with &lt;a href=&quot;qabstractxmlnodemodel#SimpleAxis-enum&quot;&gt;QSimpleXmlNodeModel::SimpleAxis&lt;/a&gt; values. Therefore, the implementation of this function must return the node, if any, that appears on the</source>
          <target state="translated">当Qt XML模式评估路径表达式时，它将通过结合使用&lt;a href=&quot;qabstractxmlnodemodel#SimpleAxis-enum&quot;&gt;QSimpleXmlNodeModel :: SimpleAxis&lt;/a&gt;值的调用来模拟它们。因此，此功能的实现必须返回出现在节点上的节点（如果有）。</target>
        </trans-unit>
        <trans-unit id="e87346c400d28fb6331382be4402bbe0f7b9fc30" translate="yes" xml:space="preserve">
          <source>When Qt XML Patterns loads an XML resource, e.g., using the &lt;code&gt;fn:doc()&lt;/code&gt; function, the following schemes are supported:</source>
          <target state="translated">当Qt XML模式（例如，使用 &lt;code&gt;fn:doc()&lt;/code&gt; 函数）加载XML资源时，支持以下方案：</target>
        </trans-unit>
        <trans-unit id="8d2df247c302bc0aef9cb5b8701b3ccf2c5556f3" translate="yes" xml:space="preserve">
          <source>When Qt XML Patterns loads and queries XML files and produces XML output, it can always load the XML data into its default XML node model, where it can be traversed efficiently. The &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; below traverses the product orders found in the XML file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbd1af30e0b1f7879d2e090097ce1ee9bc1b1e77" translate="yes" xml:space="preserve">
          <source>When Qt XML Patterns loads and queries XML files and produces XML output, it can always load the XML data into its default XML node model, where it can be traversed efficiently. The XQuery below traverses the product orders found in the XML file</source>
          <target state="translated">当Qt XML Patterns加载和查询XML文件并产生XML输出时,它总是可以将XML数据加载到其默认的XML节点模型中,在那里可以有效地遍历。下面的XQuery遍历XML文件中的产品订单。</target>
        </trans-unit>
        <trans-unit id="27bec0f91bee9a8e04a2b33675d236e7ab402351" translate="yes" xml:space="preserve">
          <source>When Qt's translation tool, &lt;a href=&quot;https://doc.qt.io/qt-5.13/linguist-manager.html#using-lupdate&quot;&gt;lupdate&lt;/a&gt;, is used to process a set of source files, the text wrapped in tr() calls is stored in a section of the translation file that corresponds to its translation context.</source>
          <target state="translated">当Qt的翻译工具&lt;a href=&quot;https://doc.qt.io/qt-5.13/linguist-manager.html#using-lupdate&quot;&gt;lupdate&lt;/a&gt;用于处理一组源文件时，包裹在tr（）调用中的文本存储在翻译文件对应于其翻译上下文的部分中。</target>
        </trans-unit>
        <trans-unit id="785ca6db3b40442948e6e7e14bdd25ed39799f88" translate="yes" xml:space="preserve">
          <source>When Qt's translation tool, &lt;a href=&quot;https://doc.qt.io/qt-5.15/linguist-manager.html#using-lupdate&quot;&gt;lupdate&lt;/a&gt;, is used to process a set of source files, the text wrapped in tr() calls is stored in a section of the translation file that corresponds to its translation context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d716f69d72489992d975e006d6741d1a3935bbd6" translate="yes" xml:space="preserve">
          <source>When Qt5 came along, Qt was divided into modules. Since then, many new modules have been added to Qt. As of version 5.5, there are over 40 separate modules in Qt5, each with its own documentation that links to (depends on) the documentation of other Qt modules.</source>
          <target state="translated">当Qt5出现的时候,Qt被划分为多个模块。从那时起,Qt中增加了许多新的模块。截至5.5版本,Qt5中有超过40个独立的模块,每个模块都有自己的文档,这些文档链接到(依赖于)其他Qt模块的文档。</target>
        </trans-unit>
        <trans-unit id="f177dcbb96dea9d408ace28c5d859883092740d9" translate="yes" xml:space="preserve">
          <source>When ScrollBar is attached &lt;a href=&quot;qml-qtquick-controls2-scrollbar#vertical-attached-prop&quot;&gt;vertically&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-controls2-scrollbar#horizontal-attached-prop&quot;&gt;horizontally&lt;/a&gt; to a Flickable, its geometry and the following properties are automatically set and updated as appropriate:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="709f09eba453dec3aff9d67b6d37f765373bd46f" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qfile&quot;&gt;QFile&lt;/a&gt; is opened using this function, behaviour of &lt;a href=&quot;qfiledevice#close&quot;&gt;close&lt;/a&gt;() is controlled by the &lt;a href=&quot;qfiledevice#FileHandleFlag-enum&quot;&gt;AutoCloseHandle&lt;/a&gt; flag. If &lt;a href=&quot;qfiledevice#FileHandleFlag-enum&quot;&gt;AutoCloseHandle&lt;/a&gt; is specified, and this function succeeds, then calling &lt;a href=&quot;qfiledevice#close&quot;&gt;close&lt;/a&gt;() closes the adopted handle. Otherwise, &lt;a href=&quot;qfiledevice#close&quot;&gt;close&lt;/a&gt;() does not actually close the file, but only flushes it.</source>
          <target state="translated">当&lt;a href=&quot;qfile&quot;&gt;QFile时&lt;/a&gt;使用此功能，行为打开&lt;a href=&quot;qfiledevice#close&quot;&gt;关闭&lt;/a&gt;（）由受控&lt;a href=&quot;qfiledevice#FileHandleFlag-enum&quot;&gt;AutoCloseHandle&lt;/a&gt;标志。如果指定了&lt;a href=&quot;qfiledevice#FileHandleFlag-enum&quot;&gt;AutoCloseHandle&lt;/a&gt;，并且此函数成功执行，则调用&lt;a href=&quot;qfiledevice#close&quot;&gt;close&lt;/a&gt;（）将关闭采用的句柄。否则，&lt;a href=&quot;qfiledevice#close&quot;&gt;close&lt;/a&gt;（）实际上不会关闭文件，而只会刷新它。</target>
        </trans-unit>
        <trans-unit id="cb1e3502bc0fff8a5da1c27970f713a4cbcb877b" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; receives Qt mouse, keyboard, and drag and drop events (&lt;a href=&quot;qmouseevent&quot;&gt;QMouseEvent&lt;/a&gt;, &lt;a href=&quot;qkeyevent&quot;&gt;QKeyEvent&lt;/a&gt;, QDragEvent, etc.), it translates them into instances of &lt;a href=&quot;qgraphicssceneevent&quot;&gt;QGraphicsSceneEvent&lt;/a&gt; subclasses and forwards them to the &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; it displays. The scene then forwards the events to the relevant items.</source>
          <target state="translated">当&lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt;接收到Qt鼠标，键盘和拖放事件（&lt;a href=&quot;qmouseevent&quot;&gt;QMouseEvent&lt;/a&gt;，&lt;a href=&quot;qkeyevent&quot;&gt;QKeyEvent&lt;/a&gt;，QDragEvent等）时，它将它们转换为&lt;a href=&quot;qgraphicssceneevent&quot;&gt;QGraphicsSceneEvent&lt;/a&gt;子类的实例，并将其转发到它显示的&lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt;。然后，场景将事件转发到相关项目。</target>
        </trans-unit>
        <trans-unit id="5554f9846d1af01927d9497ed433e3fe74b4e0e1" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; receives Qt mouse, keyboard, and drag and drop events (&lt;a href=&quot;qmouseevent&quot;&gt;QMouseEvent&lt;/a&gt;, &lt;a href=&quot;qkeyevent&quot;&gt;QKeyEvent&lt;/a&gt;, QDragEvent, etc.), it translates them into instances of QGraphicsSceneEvent subclasses and forwards them to the &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; it displays. The scene then forwards the events to the relevant items.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ca650c784a62d89aa1bd61df5a5c661ba25f79c" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; receives a &lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt; of type &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::ToolTip&lt;/a&gt;, it creates a &lt;a href=&quot;qgraphicsscenehelpevent&quot;&gt;QGraphicsSceneHelpEvent&lt;/a&gt;, which is forwarded to the scene. You can set a tooltip on a &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; with &lt;a href=&quot;qgraphicsitem#setToolTip&quot;&gt;setToolTip()&lt;/a&gt;; by default &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; displays the tooltip of the &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; with the highest z-value (i.e, the top-most item) under the mouse position.</source>
          <target state="translated">当&lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt;接收到&lt;a href=&quot;qevent&quot;&gt;QEvent &lt;/a&gt;&lt;a href=&quot;qevent#Type-enum&quot;&gt;:: ToolTip&lt;/a&gt;类型的QEvent时，它将创建&lt;a href=&quot;qgraphicsscenehelpevent&quot;&gt;QGraphicsSceneHelpEvent&lt;/a&gt;，并将其转发到场景。您可以使用&lt;a href=&quot;qgraphicsitem#setToolTip&quot;&gt;setToolTip（）&lt;/a&gt;在&lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt;上设置工具提示；默认情况下，&lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt;在鼠标位置下方显示具有最高z值（即，最顶部的项目）的&lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt;的工具提示。</target>
        </trans-unit>
        <trans-unit id="405906d74ba9d56a4a09585d6f6ec8dd6144ef07" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; receives a &lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt; of type &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::ToolTip&lt;/a&gt;, it creates a QGraphicsSceneHelpEvent, which is forwarded to the scene. You can set a tooltip on a &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; with &lt;a href=&quot;qgraphicsitem#setToolTip&quot;&gt;setToolTip()&lt;/a&gt;; by default &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; displays the tooltip of the &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; with the highest z-value (i.e, the top-most item) under the mouse position.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="393e354c9ea9f2a89f579509e189a24bb7a827a0" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; receives a &lt;a href=&quot;qhoverevent&quot;&gt;QHoverEvent&lt;/a&gt; event, it translates it into &lt;a href=&quot;qgraphicsscenehoverevent&quot;&gt;QGraphicsSceneHoverEvent&lt;/a&gt;. The event is then forwarded to the &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; associated with the view.</source>
          <target state="translated">当&lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt;收到&lt;a href=&quot;qhoverevent&quot;&gt;QHoverEvent&lt;/a&gt;事件时，它将其转换为&lt;a href=&quot;qgraphicsscenehoverevent&quot;&gt;QGraphicsSceneHoverEvent&lt;/a&gt;。然后将事件转发到与视图关联的&lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3ae68b18a5e42b2ce917dd23d94ec19620288dec" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; receives a &lt;a href=&quot;qhoverevent&quot;&gt;QHoverEvent&lt;/a&gt; event, it translates it into QGraphicsSceneHoverEvent. The event is then forwarded to the &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; associated with the view.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="beba9444d0901cd09b88793cbb92e83a0fb0a4c8" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; receives a &lt;a href=&quot;qmouseevent&quot;&gt;QMouseEvent&lt;/a&gt;, it translates it to a &lt;a href=&quot;qgraphicsscenemouseevent&quot;&gt;QGraphicsSceneMouseEvent&lt;/a&gt;. The event is then forwarded to the &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; associated with the view. If the event is not handled by the scene, the view may use it, e.g., for the &lt;a href=&quot;qgraphicsview#DragMode-enum&quot;&gt;DragMode&lt;/a&gt;.</source>
          <target state="translated">当&lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt;收到&lt;a href=&quot;qmouseevent&quot;&gt;QMouseEvent时&lt;/a&gt;，它将其转换为&lt;a href=&quot;qgraphicsscenemouseevent&quot;&gt;QGraphicsSceneMouseEvent&lt;/a&gt;。然后将事件转发到与视图关联的&lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt;。如果场景未处理事件，则视图可以将其用于例如&lt;a href=&quot;qgraphicsview#DragMode-enum&quot;&gt;DragMode&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0d58e00a0b32556ea464156ee58eaa63878af86f" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; receives a &lt;a href=&quot;qmouseevent&quot;&gt;QMouseEvent&lt;/a&gt;, it translates it to a QGraphicsSceneMouseEvent. The event is then forwarded to the &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; associated with the view. If the event is not handled by the scene, the view may use it, e.g., for the &lt;a href=&quot;qgraphicsview#DragMode-enum&quot;&gt;DragMode&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1aa704cf88adf38927fd01a2a14f929a34849e2" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qml-qt3d-render-nodraw&quot;&gt;NoDraw&lt;/a&gt; node is present in a FrameGraph branch, this prevents the renderer from rendering any primitive. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">当FrameGraph分支中存在&lt;a href=&quot;qml-qt3d-render-nodraw&quot;&gt;NoDraw&lt;/a&gt;节点时，这将阻止渲染器渲染任何基元。&lt;a href=&quot;#details&quot;&gt;更多...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d712cc482a400f11481ce544723b23f89d2fced9" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; calls &lt;a href=&quot;https://doc.qt.io/qt-5.13/qaccessible-obsolete.html#updateAccessibility&quot;&gt;updateAccessibility()&lt;/a&gt;, clients that are listening to events are notified of the change. The function is used to post events to the assistive technology, and accessible &lt;a href=&quot;qaccessible#Event-enum&quot;&gt;events&lt;/a&gt; are posted by &lt;a href=&quot;https://doc.qt.io/qt-5.13/qaccessible-obsolete.html#updateAccessibility&quot;&gt;updateAccessibility()&lt;/a&gt;.</source>
          <target state="translated">当&lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;调用&lt;a href=&quot;https://doc.qt.io/qt-5.13/qaccessible-obsolete.html#updateAccessibility&quot;&gt;updateAccessibility（）时&lt;/a&gt;，将向侦听事件的客户端通知更改。该函数用于将事件发布到辅助技术，可访问&lt;a href=&quot;qaccessible#Event-enum&quot;&gt;事件&lt;/a&gt;由&lt;a href=&quot;https://doc.qt.io/qt-5.13/qaccessible-obsolete.html#updateAccessibility&quot;&gt;updateAccessibility（）&lt;/a&gt;发布。</target>
        </trans-unit>
        <trans-unit id="a44c30b5bf2354f4fd8f996e028fe8735a8ada05" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; calls &lt;a href=&quot;https://doc.qt.io/qt-5.15/qaccessible-obsolete.html#updateAccessibility&quot;&gt;updateAccessibility()&lt;/a&gt;, clients that are listening to events are notified of the change. The function is used to post events to the assistive technology, and accessible &lt;a href=&quot;qaccessible#Event-enum&quot;&gt;events&lt;/a&gt; are posted by &lt;a href=&quot;https://doc.qt.io/qt-5.15/qaccessible-obsolete.html#updateAccessibility&quot;&gt;updateAccessibility()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc5c853e12ceaddd145dd8068a3f01709b57c0cc" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; is deleted, it emits this &lt;a href=&quot;qobject#destroyed&quot;&gt;QObject::destroyed&lt;/a&gt;() signal. We want to catch this signal, wherever we might have a dangling reference to the deleted &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;, so we can clean it up. A suitable slot signature might be:</source>
          <target state="translated">当&lt;a href=&quot;qobject&quot;&gt;QObject的&lt;/a&gt;被删除时，它发射这个&lt;a href=&quot;qobject#destroyed&quot;&gt;的QObject ::破坏&lt;/a&gt;（）信号。无论何时何地都有对已删除&lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;的悬挂引用，我们都想捕获此信号，以便我们可以对其进行清理。合适的插槽签名可能是：</target>
        </trans-unit>
        <trans-unit id="d5dd864966ee74351524f25c84e86e7278c96ac6" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; is moved to another thread, all its children will be automatically moved too.</source>
          <target state="translated">当一个&lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;移到另一个线程时，它的所有子对象也将被自动移动。</target>
        </trans-unit>
        <trans-unit id="5954371cae64cc8ee9901844bd7778dc5d52aaf5" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; is passed to the &lt;a href=&quot;qjsengine#newQObject&quot;&gt;QJSEngine::newQObject&lt;/a&gt;() function, a Qt Script wrapper object is created that can be used to make the &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;'s signals, slots, properties, and child objects available to scripts.</source>
          <target state="translated">当&lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;传递给&lt;a href=&quot;qjsengine#newQObject&quot;&gt;QJSEngine :: newQObject&lt;/a&gt;（）函数时，将创建一个Qt脚本包装器对象，该对象可用于使&lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;的信号，插槽，属性和子对象可用于脚本。</target>
        </trans-unit>
        <trans-unit id="3af90ba954a525651c11676587fb2037323acba5" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; instance is deliberately hidden with &lt;a href=&quot;qwindow#hide&quot;&gt;hide&lt;/a&gt;() or &lt;a href=&quot;qwindow#visible-prop&quot;&gt;setVisible&lt;/a&gt;(false), it will stop rendering and its scene graph and graphics context might be released. The &lt;a href=&quot;qquickwindow#sceneGraphInvalidated&quot;&gt;sceneGraphInvalidated&lt;/a&gt;() signal will be emitted when this happens.</source>
          <target state="translated">当使用&lt;a href=&quot;qwindow#hide&quot;&gt;hide&lt;/a&gt;（）或&lt;a href=&quot;qwindow#visible-prop&quot;&gt;setVisible&lt;/a&gt;（false）故意隐藏&lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt;实例时，它将停止渲染并且可能会释放其场景图和图形上下文。所述&lt;a href=&quot;qquickwindow#sceneGraphInvalidated&quot;&gt;sceneGraphInvalidated&lt;/a&gt;发生这种情况时（在）信号将被发射。</target>
        </trans-unit>
        <trans-unit id="5554553d845c524ddee2156401f7cea7ba23f3a7" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qt3drender-qmemorybarrier&quot;&gt;QMemoryBarrier&lt;/a&gt; node is found in a FrameGraph branch, the barrier will be enforced prior to any draw or compute command even if these are defined deeper in the branch.</source>
          <target state="translated">当在FrameGraph分支中找到&lt;a href=&quot;qt3drender-qmemorybarrier&quot;&gt;QMemoryBarrier&lt;/a&gt;节点时，即使在分支中更深地定义了这些绘制或计算命令，也将在执行任何屏障之前执行该屏障。</target>
        </trans-unit>
        <trans-unit id="ba17b5ca58006cf8654bdb06b74fa570795c9e22" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qt3drender-qnodraw&quot;&gt;Qt3DRender::QNoDraw&lt;/a&gt; node is present in a FrameGraph branch, this prevents the renderer from rendering any primitive. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">当&lt;a href=&quot;qt3drender-qnodraw&quot;&gt;Qt3DRender :: QNoDraw&lt;/a&gt;节点存在于FrameGraph分支中时，这将阻止渲染器渲染任何基元。&lt;a href=&quot;#details&quot;&gt;更多...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="548a84d157a52956b642a6c79fa3b16cff4cbb88" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qt3drender-qnodraw&quot;&gt;Qt3DRender::QNoDraw&lt;/a&gt; node is present in a FrameGraph branch, this prevents the renderer from rendering any primitive. &lt;a href=&quot;qt3drender-qnodraw#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">当&lt;a href=&quot;qt3drender-qnodraw&quot;&gt;Qt3DRender :: QNoDraw&lt;/a&gt;节点存在于FrameGraph分支中时，这将阻止渲染器渲染任何基元。&lt;a href=&quot;qt3drender-qnodraw#details&quot;&gt;更多...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3cd19e17aad321610c519687f38dc05666afdeec" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qt3drender-qnopicking&quot;&gt;Qt3DRender::QNoPicking&lt;/a&gt; node is present in a FrameGraph branch, this prevents the render aspect from performing picking selection for the given branch. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48029ceeb2e178ce68055405481fb634ea787fe6" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qt3drender-qnopicking&quot;&gt;Qt3DRender::QNoPicking&lt;/a&gt; node is present in a FrameGraph branch, this prevents the render aspect from performing picking selection for the given branch. &lt;a href=&quot;qt3drender-qnopicking#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88153895f9568d781c480af110178d98fc9ac494" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qtoolbar&quot;&gt;QToolBar&lt;/a&gt; is not a child of a &lt;a href=&quot;qmainwindow&quot;&gt;QMainWindow&lt;/a&gt;, it loses the ability to populate the extension pop up with widgets added to the toolbar using &lt;a href=&quot;qtoolbar#addWidget&quot;&gt;addWidget&lt;/a&gt;(). Please use widget actions created by inheriting &lt;a href=&quot;qwidgetaction&quot;&gt;QWidgetAction&lt;/a&gt; and implementing &lt;a href=&quot;qwidgetaction#createWidget&quot;&gt;QWidgetAction::createWidget&lt;/a&gt;() instead.</source>
          <target state="translated">当&lt;a href=&quot;qtoolbar&quot;&gt;QToolBar&lt;/a&gt;不是&lt;a href=&quot;qmainwindow&quot;&gt;QMainWindow&lt;/a&gt;的子级时，它将失去使用&lt;a href=&quot;qtoolbar#addWidget&quot;&gt;addWidget&lt;/a&gt;（）添加到工具栏中的小部件填充扩展弹出窗口的功能。请使用通过继承&lt;a href=&quot;qwidgetaction&quot;&gt;QWidgetAction&lt;/a&gt;并实现&lt;a href=&quot;qwidgetaction#createWidget&quot;&gt;QWidgetAction :: createWidget&lt;/a&gt;（）而创建的窗口小部件动作。</target>
        </trans-unit>
        <trans-unit id="ea339d196247f8a4535ab539b791214e5503ae1d" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qwizardpage#subTitle-prop&quot;&gt;subTitle&lt;/a&gt; is set, &lt;a href=&quot;qwizard&quot;&gt;QWizard&lt;/a&gt; displays it in a header, in which case it also uses the &lt;a href=&quot;qwizard#WizardPixmap-enum&quot;&gt;BannerPixmap&lt;/a&gt; and the &lt;a href=&quot;qwizard#WizardPixmap-enum&quot;&gt;LogoPixmap&lt;/a&gt; to decorate the header. The &lt;a href=&quot;qwizard#WizardPixmap-enum&quot;&gt;WatermarkPixmap&lt;/a&gt; is displayed on the left side, below the header. At the bottom, there is a row of buttons allowing the user to navigate through the pages.</source>
          <target state="translated">当&lt;a href=&quot;qwizardpage#subTitle-prop&quot;&gt;字幕&lt;/a&gt;设置，&lt;a href=&quot;qwizard&quot;&gt;QWizard&lt;/a&gt;其显示在报头中，在这种情况下，它也使用&lt;a href=&quot;qwizard#WizardPixmap-enum&quot;&gt;BannerPixmap&lt;/a&gt;和&lt;a href=&quot;qwizard#WizardPixmap-enum&quot;&gt;LogoPixmap&lt;/a&gt;装饰头部。所述&lt;a href=&quot;qwizard#WizardPixmap-enum&quot;&gt;WatermarkPixmap&lt;/a&gt;被显示在左侧，头部的下方。在底部，有一排按钮允许用户浏览页面。</target>
        </trans-unit>
        <trans-unit id="399d5e73a4a8b06dd36c1720633609c913f08193" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qwizardpage#subTitle-prop&quot;&gt;subTitle&lt;/a&gt; is set, QWizard displays it in a header, in which case it also uses the &lt;a href=&quot;qwizard#WizardPixmap-enum&quot;&gt;BannerPixmap&lt;/a&gt; and the &lt;a href=&quot;qwizard#WizardPixmap-enum&quot;&gt;LogoPixmap&lt;/a&gt; to decorate the header. The &lt;a href=&quot;qwizard#WizardPixmap-enum&quot;&gt;WatermarkPixmap&lt;/a&gt; is displayed on the left side, below the header. At the bottom, there is a row of buttons allowing the user to navigate through the pages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7322771e8958658ead503160124f934fb65197f8" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;&amp;lt;content&amp;gt;&lt;/code&gt; element is used, the data will contain a single item with either the value of the</source>
          <target state="translated">当使用 &lt;code&gt;&amp;lt;content&amp;gt;&lt;/code&gt; 元素时，数据将包含单个项目，其值为</target>
        </trans-unit>
        <trans-unit id="2672663ccea1c72ceff571e1774f7c56bc159e61" translate="yes" xml:space="preserve">
          <source>When a D-Bus function returns a D-Bus variant, it can be retrieved as follows:</source>
          <target state="translated">当一个D-Bus函数返回一个D-Bus变体时,可以按以下方式检索。</target>
        </trans-unit>
        <trans-unit id="1017702957d7db1428d00195f1759c2c2ce9ca31" translate="yes" xml:space="preserve">
          <source>When a JavaScript file is imported this way, it is imported with a qualifier. The functions in that file are then accessible from the importing script via the qualifier (that is, as &lt;code&gt;Qualifier.functionName(params)&lt;/code&gt;).</source>
          <target state="translated">以这种方式导入JavaScript文件时，将使用限定符将其导入。然后可以通过限定符（即，作为 &lt;code&gt;Qualifier.functionName(params)&lt;/code&gt; ）从导入脚本访问该文件中的函数。</target>
        </trans-unit>
        <trans-unit id="8955c961f4e03b5b4c423d7e27242490dcc367cd" translate="yes" xml:space="preserve">
          <source>When a NoDraw node is present in a FrameGraph branch, this prevents the renderer from rendering any primitive. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9346322a98372696210b54e5c6837cb02553ab5b" translate="yes" xml:space="preserve">
          <source>When a NoPicking node is present in a FrameGraph branch, this prevents the render aspect from performing picking selection for the given branch. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5239011b0ce80a40d0520fced8dbad82a40aa0a" translate="yes" xml:space="preserve">
          <source>When a Plugin object is created, it is &quot;detached&quot; and not associated with any actual service plugin. Once it has received information via setting its &lt;a href=&quot;qml-qtlocation-plugin#name-prop&quot;&gt;name&lt;/a&gt;, &lt;a href=&quot;qml-qtlocation-plugin#preferred-prop&quot;&gt;preferred&lt;/a&gt;, or &lt;a href=&quot;qml-qtlocation-plugin#required-prop&quot;&gt;required&lt;/a&gt; properties, it will choose an appropriate service plugin to attach to. Plugin objects can only be attached once; to use multiple plugins, create multiple Plugin objects.</source>
          <target state="translated">创建插件对象时，它是&amp;ldquo;分离的&amp;rdquo;并且不与任何实际的服务插件关联。通过设置其&lt;a href=&quot;qml-qtlocation-plugin#name-prop&quot;&gt;name&lt;/a&gt;，&lt;a href=&quot;qml-qtlocation-plugin#preferred-prop&quot;&gt;preferred&lt;/a&gt;或&lt;a href=&quot;qml-qtlocation-plugin#required-prop&quot;&gt;required&lt;/a&gt;属性接收到信息后，它将选择要附加的适当服务插件。插件对象只能附加一次；要使用多个插件，请创建多个插件对象。</target>
        </trans-unit>
        <trans-unit id="b6f220e6e802d62e7eddcb10a35ca79f2887d75d" translate="yes" xml:space="preserve">
          <source>When a QML &lt;a href=&quot;qml-qtquick-item&quot;&gt;Item&lt;/a&gt; explicitly relinquishes focus (by setting its &lt;code&gt;focus&lt;/code&gt; property to &lt;code&gt;false&lt;/code&gt; while it has active focus), the system does not automatically select another type to receive focus. That is, it is possible for there to be no currently active focus.</source>
          <target state="translated">当QML &lt;a href=&quot;qml-qtquick-item&quot;&gt;项&lt;/a&gt;显式放弃焦点时（通过在其具有活动焦点时将其 &lt;code&gt;focus&lt;/code&gt; 属性设置为 &lt;code&gt;false&lt;/code&gt; ），系统不会自动选择其他类型来接收焦点。即，可能没有当前的活动焦点。</target>
        </trans-unit>
        <trans-unit id="7001a12de2df6c574e67e9da9ad3f2fc320aad4f" translate="yes" xml:space="preserve">
          <source>When a QML object type is used as a signal parameter, the parameter should use &lt;a href=&quot;qml-var&quot;&gt;var&lt;/a&gt; as the type, and the value should be received in C++ using the &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; type:</source>
          <target state="translated">当将QML对象类型用作信号参数时，该参数应使用&lt;a href=&quot;qml-var&quot;&gt;var&lt;/a&gt;作为类型，并且应使用&lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt;类型在C ++中接收该值：</target>
        </trans-unit>
        <trans-unit id="15f000278e72ce7b8d6c307887252da7193e1ede" translate="yes" xml:space="preserve">
          <source>When a QMemoryBarrier node is found in a FrameGraph branch, the barrier will be enforced prior to any draw or compute command even if these are defined deeper in the branch.</source>
          <target state="translated">当在FrameGraph分支中发现一个QMemoryBarrier节点时,即使在分支的更深处定义了QMemoryBarrier节点,该屏障也会在任何绘制或计算命令之前被强制执行。</target>
        </trans-unit>
        <trans-unit id="d860d62ecdfb8b15dcaa97f6730ceece19277c00" translate="yes" xml:space="preserve">
          <source>When a QObject is moved to another thread, all its children will be automatically moved too.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bcadc0cb5a7c58faa28e7459e38798e9f6a2b6b" translate="yes" xml:space="preserve">
          <source>When a QQuickWindow instance is deliberately hidden with &lt;a href=&quot;qwindow#hide&quot;&gt;hide&lt;/a&gt;() or &lt;a href=&quot;qwindow#visible-prop&quot;&gt;setVisible&lt;/a&gt;(false), it will stop rendering and its scene graph and graphics context might be released. The &lt;a href=&quot;qquickwindow#sceneGraphInvalidated&quot;&gt;sceneGraphInvalidated&lt;/a&gt;() signal will be emitted when this happens.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc28ed271581b3aeebbcb657c64d87496cc2b2e9" translate="yes" xml:space="preserve">
          <source>When a QToolBar is not a child of a &lt;a href=&quot;qmainwindow&quot;&gt;QMainWindow&lt;/a&gt;, it loses the ability to populate the extension pop up with widgets added to the toolbar using &lt;a href=&quot;qtoolbar#addWidget&quot;&gt;addWidget&lt;/a&gt;(). Please use widget actions created by inheriting &lt;a href=&quot;qwidgetaction&quot;&gt;QWidgetAction&lt;/a&gt; and implementing &lt;a href=&quot;qwidgetaction#createWidget&quot;&gt;QWidgetAction::createWidget&lt;/a&gt;() instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8aa88cb70cc32f83b8553c1a39321db3fc1b25e" translate="yes" xml:space="preserve">
          <source>When a Qt3DRender::QNoDraw node is present in a FrameGraph branch, this prevents the renderer from rendering any primitive</source>
          <target state="translated">当一个Qt3DRender::QNoDraw节点存在于FrameGraph分支中时,这将阻止渲染器渲染任何基元。</target>
        </trans-unit>
        <trans-unit id="7f62ed373c0ee65b35bdb2fc2d57ef6032e4e244" translate="yes" xml:space="preserve">
          <source>When a Qt3DRender::QNoPicking node is present in a FrameGraph branch, this prevents the render aspect from performing picking selection for the given branch</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40263f24ec17a09841c1926737df4393300f3b67" translate="yes" xml:space="preserve">
          <source>When a button is clicked in the button box, the &lt;a href=&quot;qdialogbuttonbox#clicked&quot;&gt;clicked&lt;/a&gt;() signal is emitted for the actual button is that is pressed. For convenience, if the button has an &lt;a href=&quot;qdialogbuttonbox#ButtonRole-enum&quot;&gt;AcceptRole&lt;/a&gt;, &lt;a href=&quot;qdialogbuttonbox#ButtonRole-enum&quot;&gt;RejectRole&lt;/a&gt;, or &lt;a href=&quot;qdialogbuttonbox#ButtonRole-enum&quot;&gt;HelpRole&lt;/a&gt;, the &lt;a href=&quot;qdialogbuttonbox#accepted&quot;&gt;accepted&lt;/a&gt;(), &lt;a href=&quot;qdialogbuttonbox#rejected&quot;&gt;rejected&lt;/a&gt;(), or &lt;a href=&quot;qdialogbuttonbox#helpRequested&quot;&gt;helpRequested&lt;/a&gt;() signals are emitted respectively.</source>
          <target state="translated">当在按钮框中单击一个按钮时，将为实际按下的按钮发出&lt;a href=&quot;qdialogbuttonbox#clicked&quot;&gt;clicked&lt;/a&gt;（）信号。为了方便起见，如果按钮具有&lt;a href=&quot;qdialogbuttonbox#ButtonRole-enum&quot;&gt;AcceptRole&lt;/a&gt;，&lt;a href=&quot;qdialogbuttonbox#ButtonRole-enum&quot;&gt;RejectRole&lt;/a&gt;，或&lt;a href=&quot;qdialogbuttonbox#ButtonRole-enum&quot;&gt;HelpRole&lt;/a&gt;，所述&lt;a href=&quot;qdialogbuttonbox#accepted&quot;&gt;接受&lt;/a&gt;（），&lt;a href=&quot;qdialogbuttonbox#rejected&quot;&gt;拒绝&lt;/a&gt;（），或&lt;a href=&quot;qdialogbuttonbox#helpRequested&quot;&gt;helpRequested&lt;/a&gt;（）信号被分别发射。</target>
        </trans-unit>
        <trans-unit id="3391d8c7ccaaea73a623e4d861dba6f56e546160" translate="yes" xml:space="preserve">
          <source>When a button is clicked in the button box, the &lt;a href=&quot;qml-qtquick-controls2-dialogbuttonbox#clicked-signal&quot;&gt;clicked()&lt;/a&gt; signal is emitted for the actual button that is pressed. In addition, the following signals are automatically emitted when a button with the respective role(s) is pressed:</source>
          <target state="translated">在按钮框中&lt;a href=&quot;qml-qtquick-controls2-dialogbuttonbox#clicked-signal&quot;&gt;单击&lt;/a&gt;按钮时，将为实际按下的按钮发出clicked（）信号。此外，当按下具有各自作用的按钮时，会自动发出以下信号：</target>
        </trans-unit>
        <trans-unit id="06c02f6a9dbac4345d72fdb9bb347db0a2b3bcdc" translate="yes" xml:space="preserve">
          <source>When a category is removed, the &lt;a href=&quot;qplacemanager&quot;&gt;QPlaceManager&lt;/a&gt; may emit the &lt;a href=&quot;qplacemanager#categoryRemoved&quot;&gt;QPlaceManager::categoryRemoved&lt;/a&gt;() signal. Whether a manager does so is provider specific. Managers accessing places from a web service will typically not emit these signals, while managers accessing places stored locally generally will.</source>
          <target state="translated">删除类别后，&lt;a href=&quot;qplacemanager&quot;&gt;QPlaceManager&lt;/a&gt;可能会发出&lt;a href=&quot;qplacemanager#categoryRemoved&quot;&gt;QPlaceManager :: categoryRemoved&lt;/a&gt;（）信号。经理是否这样做取决于提供商。从Web服务访问场所的管理员通常不会发出这些信号，而访问本地存储的场所的管理员通常会发出这些信号。</target>
        </trans-unit>
        <trans-unit id="2153d9fed3f02a16b6a6ca1c21681db29241b851" translate="yes" xml:space="preserve">
          <source>When a category is saved, the &lt;a href=&quot;qplacemanager&quot;&gt;QPlaceManager&lt;/a&gt; may emit &lt;a href=&quot;qplacemanager#categoryAdded&quot;&gt;QPlaceManager::categoryAdded&lt;/a&gt;() or &lt;a href=&quot;qplacemanager#categoryUpdated&quot;&gt;QPlaceManager::categoryUpdated&lt;/a&gt;() signals. However whether a manager does so or not is provider specific, managers accessing places from a web service will typically not emit these signals while managers accessing places locally stored generally will.</source>
          <target state="translated">保存类别后，&lt;a href=&quot;qplacemanager&quot;&gt;QPlaceManager&lt;/a&gt;可能会发出&lt;a href=&quot;qplacemanager#categoryAdded&quot;&gt;QPlaceManager :: categoryAdded&lt;/a&gt;（）或&lt;a href=&quot;qplacemanager#categoryUpdated&quot;&gt;QPlaceManager :: categoryUpdated&lt;/a&gt;（）信号。但是，无论管理者是否这样做都是特定于提供者的，从Web服务访问场所的管理者通常不会发出这些信号，而访问本地存储的场所的管理者通常会发出这些信号。</target>
        </trans-unit>
        <trans-unit id="74e1cabc1808cac1af0ca6415a34d8121f46bf6d" translate="yes" xml:space="preserve">
          <source>When a certain configuration is requested explicitly, no checks are done at application startup, that is, the system-provided opengl32.dll will not be examined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d7ef2995bb1b9278679a4db6eb4f1c8a80df088" translate="yes" xml:space="preserve">
          <source>When a child layout object is selected, its parent layout object can be selected by pressing down the &lt;b&gt;Shift&lt;/b&gt; key while clicking on it. This makes it possible to select a specific layout in a hierarchy, which is otherwise difficult due to the small frame.</source>
          <target state="translated">选择子布局对象时，可以通过在单击它的同时按下&lt;b&gt;Shift&lt;/b&gt;键来选择其父布局对象。这使得有可能在层次结构中选择特定的布局，否则由于尺寸较小而很难。</target>
        </trans-unit>
        <trans-unit id="4d44facce222efbda291b9b00896c00605e23c4d" translate="yes" xml:space="preserve">
          <source>When a class is marked &lt;a href=&quot;#reentrant-command&quot;&gt;\reentrant&lt;/a&gt; or &lt;a href=&quot;#threadsafe-command&quot;&gt;\threadsafe&lt;/a&gt;, functions in that class can be marked &lt;code&gt;nonreentrant&lt;/code&gt; using the &lt;a href=&quot;#nonreentrant-command&quot;&gt;\nonreentrant&lt;/a&gt; command.</source>
          <target state="translated">当一个类被标记为&lt;a href=&quot;#reentrant-command&quot;&gt;\ reentrant&lt;/a&gt;或&lt;a href=&quot;#threadsafe-command&quot;&gt;\ threadsafe时&lt;/a&gt;，可以使用&lt;a href=&quot;#nonreentrant-command&quot;&gt;\ nonreentrant&lt;/a&gt;命令将该类中的函数标记为 &lt;code&gt;nonreentrant&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0630e10d812ca6a44e69948c6fbb1d3fde2d9e6c" translate="yes" xml:space="preserve">
          <source>When a class is marked &lt;a href=&quot;#reentrant-command&quot;&gt;\reentrant&lt;/a&gt; or &lt;a href=&quot;#threadsafe-command&quot;&gt;\threadsafe&lt;/a&gt;, functions in that class can be marked &lt;code&gt;nonreentrant&lt;/code&gt; using this command in the &lt;a href=&quot;https://doc.qt.io/qt-5.13/13-qdoc-commands-topics.html#fn-command&quot;&gt;\fn&lt;/a&gt; comment of the functions to be excluded.</source>
          <target state="translated">当一个类被标记为&lt;a href=&quot;#reentrant-command&quot;&gt;\ reentrant&lt;/a&gt;或&lt;a href=&quot;#threadsafe-command&quot;&gt;\ threadsafe时&lt;/a&gt;，可以在要排除的函数的&lt;a href=&quot;https://doc.qt.io/qt-5.13/13-qdoc-commands-topics.html#fn-command&quot;&gt;\ fn&lt;/a&gt;注释中使用此命令将该类中的函数标记为 &lt;code&gt;nonreentrant&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2cd634a18329e27eaf5d023e852ce4e96a7d4f77" translate="yes" xml:space="preserve">
          <source>When a class is marked &lt;a href=&quot;17-qdoc-commands-thread#reentrant-command&quot;&gt;\reentrant&lt;/a&gt; or &lt;a href=&quot;17-qdoc-commands-thread#threadsafe-command&quot;&gt;\threadsafe&lt;/a&gt;, functions in that class can be marked &lt;code&gt;nonreentrant&lt;/code&gt; using the &lt;a href=&quot;17-qdoc-commands-thread#nonreentrant-command&quot;&gt;\nonreentrant&lt;/a&gt; command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7d7a9372711646e9a74f31e8f75f68b4197251e" translate="yes" xml:space="preserve">
          <source>When a class is marked &lt;a href=&quot;17-qdoc-commands-thread#reentrant-command&quot;&gt;\reentrant&lt;/a&gt; or &lt;a href=&quot;17-qdoc-commands-thread#threadsafe-command&quot;&gt;\threadsafe&lt;/a&gt;, functions in that class can be marked &lt;code&gt;nonreentrant&lt;/code&gt; using this command in the &lt;a href=&quot;https://doc.qt.io/qt-5.15/13-qdoc-commands-topics.html#fn-command&quot;&gt;\fn&lt;/a&gt; comment of the functions to be excluded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb8493d30c9e50739fc7b9788b39ac10cc03ca43" translate="yes" xml:space="preserve">
          <source>When a composition mode is set it applies to all painting operator, pens, brushes, gradients and pixmap/image drawing.</source>
          <target state="translated">当设置了构图模式时,它适用于所有绘画操作者、钢笔、画笔、渐变和像素图/图像绘制。</target>
        </trans-unit>
        <trans-unit id="38b6f0bc81c40f221944d8b87c8853be0ed28449" translate="yes" xml:space="preserve">
          <source>When a container extension is required,</source>
          <target state="translated">当需要容器扩展时。</target>
        </trans-unit>
        <trans-unit id="0e4a24a47776590b3614eff94072d51c15c8244d" translate="yes" xml:space="preserve">
          <source>When a custom valueBar is defined, its &lt;a href=&quot;qml-qtquick-item#implicitWidth-prop&quot;&gt;implicitWidth&lt;/a&gt; property must be set.</source>
          <target state="translated">当一个自定义valueBar定义，其&lt;a href=&quot;qml-qtquick-item#implicitWidth-prop&quot;&gt;implicitWidth&lt;/a&gt;属性必须设置。</target>
        </trans-unit>
        <trans-unit id="6c4b40a6fbd23b160b7fe00aefbf0818b8bf8785" translate="yes" xml:space="preserve">
          <source>When a data stream operates on an asynchronous device, the chunks of data can arrive at arbitrary points in time. The &lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt; class implements a transaction mechanism that provides the ability to read the data atomically with a series of stream operators. As an example, you can handle incomplete reads from a socket by using a transaction in a slot connected to the readyRead() signal:</source>
          <target state="translated">当数据流在异步设备上运行时，数据块可以到达任意时间点。的&lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt;类实现一个事务机制，其提供以一系列流运营商原子读出的数据的能力。例如，您可以通过使用连接到readyRead（）信号的插槽中的事务来处理对套接字的不完整读取：</target>
        </trans-unit>
        <trans-unit id="2309abfd6e3825de006d2babd2f4bdd6e5bf7873" translate="yes" xml:space="preserve">
          <source>When a data stream operates on an asynchronous device, the chunks of data can arrive at arbitrary points in time. The QDataStream class implements a transaction mechanism that provides the ability to read the data atomically with a series of stream operators. As an example, you can handle incomplete reads from a socket by using a transaction in a slot connected to the readyRead() signal:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b820cde4dc4a7341cb53aee76f1d46245199229" translate="yes" xml:space="preserve">
          <source>When a delay is set, the event will be queued for delivery after the timeout has passed. The state machine takes ownership of</source>
          <target state="translated">当设置了延迟后,事件将在超时后排队等待交付。状态机对</target>
        </trans-unit>
        <trans-unit id="23bd60283b08b2b77caeefa53fd2bdd658b2b566" translate="yes" xml:space="preserve">
          <source>When a delay is set, the event will be queued for delivery after the timeout has passed. The state machine takes ownership of the event and deletes it after processing.</source>
          <target state="translated">当设置了延迟后,事件将在超时后排队交付。状态机对该事件拥有所有权,并在处理后将其删除。</target>
        </trans-unit>
        <trans-unit id="d09fa2d377e5a85c50e883812625f0a7a5fde3e3" translate="yes" xml:space="preserve">
          <source>When a dock widget or tool bar is dragged over the main window, the main window adjusts its contents to indicate where the dock widget or tool bar will be docked if it is dropped. Setting this property causes &lt;a href=&quot;qmainwindow&quot;&gt;QMainWindow&lt;/a&gt; to move its contents in a smooth animation. Clearing this property causes the contents to snap into their new positions.</source>
          <target state="translated">当将停靠小部件或工具栏拖动到主窗口上方时，主窗口会调整其内容，以指示停靠小部件或工具栏在放置时将停靠的位置。设置此属性会使&lt;a href=&quot;qmainwindow&quot;&gt;QMainWindow&lt;/a&gt;以平滑的动画形式移动其内容。清除此属性会使内容捕捉到新位置。</target>
        </trans-unit>
        <trans-unit id="da9490d3c1f9946041e7eb1512b2be2ffa63a1b3" translate="yes" xml:space="preserve">
          <source>When a drag and drop operation is performed over a view, the underlying model is queried to determine which types of operation it supports and the MIME types it can accept. This information is provided by the &lt;a href=&quot;qabstractitemmodel#supportedDropActions&quot;&gt;QAbstractItemModel::supportedDropActions&lt;/a&gt;() and &lt;a href=&quot;qabstractitemmodel#mimeTypes&quot;&gt;QAbstractItemModel::mimeTypes&lt;/a&gt;() functions. Models that do not override the implementations provided by &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; support copy operations and the default internal MIME type for items.</source>
          <target state="translated">在视图上执行拖放操作时，将查询基础模型，以确定其支持的操作类型以及可以接受的MIME类型。此信息由&lt;a href=&quot;qabstractitemmodel#supportedDropActions&quot;&gt;QAbstractItemModel :: supportedDropActions&lt;/a&gt;（）和&lt;a href=&quot;qabstractitemmodel#mimeTypes&quot;&gt;QAbstractItemModel :: mimeTypes&lt;/a&gt;（）函数提供。不覆盖&lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt;提供的实现的模型支持复制操作和项的默认内部MIME类型。</target>
        </trans-unit>
        <trans-unit id="e9b8c9681d5d37404723c8f5a9ebfc9d97539a77" translate="yes" xml:space="preserve">
          <source>When a drag is &lt;a href=&quot;qml-qtquick-drag#active-attached-prop&quot;&gt;active&lt;/a&gt; on an item, any change in that item's position will generate a drag event that will be sent to any &lt;a href=&quot;qml-qtquick-droparea&quot;&gt;DropArea&lt;/a&gt; that intersects with the new position of the item. Other items which implement drag and drop event handlers can also receive these events.</source>
          <target state="translated">当对某个项目&lt;a href=&quot;qml-qtquick-drag#active-attached-prop&quot;&gt;激活&lt;/a&gt;拖动时，该项目位置的任何更改都将生成一个拖动事件，该事件将发送到与该项目的新位置相交的任何&lt;a href=&quot;qml-qtquick-droparea&quot;&gt;DropArea&lt;/a&gt;。实现拖放事件处理程序的其他项目也可以接收这些事件。</target>
        </trans-unit>
        <trans-unit id="c95a54f3a1918c06f2cbe85cf290554fb693d8ac" translate="yes" xml:space="preserve">
          <source>When a drag is not active this property holds the object that accepted the drop event that ended the drag, if no object accepted the drop or the drag was canceled the target will then be null.</source>
          <target state="translated">当拖动未激活时,该属性持有接受结束拖动的投放事件的对象,如果没有对象接受投放或拖动被取消,那么目标将为空。</target>
        </trans-unit>
        <trans-unit id="8dd9d07c03937978798b7bb1627270a6ea3c810d" translate="yes" xml:space="preserve">
          <source>When a drop occurs elsewhere in the view, and the row number is unusable, we append items to the top level of the model.</source>
          <target state="translated">当视图中的其他地方发生下降,而行号无法使用时,我们将项目追加到模型的顶层。</target>
        </trans-unit>
        <trans-unit id="f51c41bb148e0dd3152b4f6f3f9915d8028fe189" translate="yes" xml:space="preserve">
          <source>When a drop occurs in the widget, the dropEvent() handler function is called, and we can deal with each possible action in turn. First, we deal with drag and drop operations within the same widget:</source>
          <target state="translated">当小组件中发生拖放时,会调用 dropEvent()处理函数,我们可以依次处理每一个可能的操作。首先,我们处理同一小组件中的拖放操作。</target>
        </trans-unit>
        <trans-unit id="b42ee2ab5c63e4e31745c7c35ebc8cf0bcf255bd" translate="yes" xml:space="preserve">
          <source>When a drop occurs, the model index corresponding to the parent item will either be valid, indicating that the drop occurred on an item, or it will be invalid, indicating that the drop occurred somewhere in the view that corresponds to top level of the model.</source>
          <target state="translated">当发生掉落时,父项对应的模型索引要么有效,表示掉落发生在某项上,要么无效,表示掉落发生在模型顶层对应的视图的某处。</target>
        </trans-unit>
        <trans-unit id="fa514711ce33d2215ed2e3d6a6f7e5ed0189a13b" translate="yes" xml:space="preserve">
          <source>When a focus scope receives active focus, the contained type with &lt;code&gt;focus&lt;/code&gt; set (if any) also gets the active focus. If this type is also a &lt;a href=&quot;qml-qtquick-focusscope&quot;&gt;FocusScope&lt;/a&gt;, the proxying behavior continues. Both the focus scope and the sub-focused item will have the &lt;code&gt;activeFocus&lt;/code&gt; property set.</source>
          <target state="translated">当焦点范围获得活动焦点时，包含 &lt;code&gt;focus&lt;/code&gt; 集的包含类型（如果有）也将获得活动焦点。如果此类型也是&lt;a href=&quot;qml-qtquick-focusscope&quot;&gt;FocusScope&lt;/a&gt;，则代理行为将继续。焦点范围和子焦点项都将设置 &lt;code&gt;activeFocus&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="9e613a8bc60ebbcd1e9e0949919a88ee9070005d" translate="yes" xml:space="preserve">
          <source>When a formatter is attached to a value axis, the axis range cannot include negative values or the zero.</source>
          <target state="translated">当格式器附加到值轴上时,轴范围不能包括负值或零。</target>
        </trans-unit>
        <trans-unit id="6f6b92c6c88b8efb6145fe6bc4f3bfc2d29e118a" translate="yes" xml:space="preserve">
          <source>When a gesture is canceled, the &lt;a href=&quot;qgesturerecognizer#reset&quot;&gt;reset&lt;/a&gt;() function is called, giving the recognizer the chance to update the appropriate properties in the corresponding &lt;a href=&quot;qgesture&quot;&gt;QGesture&lt;/a&gt; object.</source>
          <target state="translated">取消手势后，将调用&lt;a href=&quot;qgesturerecognizer#reset&quot;&gt;reset&lt;/a&gt;（）函数，使识别器有机会更新相应&lt;a href=&quot;qgesture&quot;&gt;QGesture&lt;/a&gt;对象中的适当属性。</target>
        </trans-unit>
        <trans-unit id="428d7789009cbf1fc7ea52cad52f4379b3aabfc7" translate="yes" xml:space="preserve">
          <source>When a highlighted item is activated, the popup is closed, &lt;a href=&quot;qml-qtquick-controls2-combobox#currentIndex-prop&quot;&gt;currentIndex&lt;/a&gt; is set to &lt;code&gt;highlightedIndex&lt;/code&gt;, and the value of this property is reset to &lt;code&gt;-1&lt;/code&gt;, as there is no longer a highlighted item.</source>
          <target state="translated">当突出显示的项目被激活时，弹出窗口关闭，&lt;a href=&quot;qml-qtquick-controls2-combobox#currentIndex-prop&quot;&gt;CURRENTINDEX&lt;/a&gt;设置为 &lt;code&gt;highlightedIndex&lt;/code&gt; ，并且此属性的值重置为 &lt;code&gt;-1&lt;/code&gt; ，因为不再有一个突出显示的项目。</target>
        </trans-unit>
        <trans-unit id="4eebccda1013bfd9e4d9b4103626dd2994ae925f" translate="yes" xml:space="preserve">
          <source>When a key is pressed or released, a key event is generated and delivered to the focused Qt Quick &lt;a href=&quot;qml-qtquick-item&quot;&gt;Item&lt;/a&gt;. To facilitate the construction of reusable components and to address some of the cases unique to fluid user interfaces, the Qt Quick items add a scope based extension to Qt's traditional keyboard focus model.</source>
          <target state="translated">当按下或释放一个键时，会生成一个键事件并将其传递给重点Qt Quick &lt;a href=&quot;qml-qtquick-item&quot;&gt;Item&lt;/a&gt;。为了简化可重用组件的构造并解决某些易变的用户界面所特有的情况，Qt Quick项目为Qt的传统键盘焦点模型添加了基于范围的扩展。</target>
        </trans-unit>
        <trans-unit id="5280aa5c73ecda9d4fb3b4f001bfc13d6e4c77a0" translate="yes" xml:space="preserve">
          <source>When a key sequence is being typed at the keyboard, it is said to be ambiguous as long as it matches the start of more than one shortcut.</source>
          <target state="translated">当在键盘上输入一个键序时,只要符合一个以上的快捷键的开始,就可以说是模棱两可。</target>
        </trans-unit>
        <trans-unit id="332bb39a2cb3399af84efd51d32cde06e1b10d08" translate="yes" xml:space="preserve">
          <source>When a language/country pair is specified in the constructor, one of three things can happen:</source>
          <target state="translated">当在构造函数中指定语言/国家对时,可能会发生三种情况之一。</target>
        </trans-unit>
        <trans-unit id="8c010514fe89fada083c82bb7ef5814f38b6c278" translate="yes" xml:space="preserve">
          <source>When a layout is resized, items may grow or shrink. Due to this, items have a &lt;a href=&quot;qml-qtquick-layouts-layout#minimumWidth-attached-prop&quot;&gt;minimum size&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-layouts-layout#preferredWidth-attached-prop&quot;&gt;preferred size&lt;/a&gt; and a &lt;a href=&quot;qml-qtquick-layouts-layout#maximumWidth-attached-prop&quot;&gt;maximum size&lt;/a&gt;.</source>
          <target state="translated">调整布局大小时，项目可能会增加或缩小。因此，商品具有&lt;a href=&quot;qml-qtquick-layouts-layout#minimumWidth-attached-prop&quot;&gt;最小尺寸&lt;/a&gt;，&lt;a href=&quot;qml-qtquick-layouts-layout#preferredWidth-attached-prop&quot;&gt;首选尺寸&lt;/a&gt;和&lt;a href=&quot;qml-qtquick-layouts-layout#maximumWidth-attached-prop&quot;&gt;最大尺寸&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2aaeb9d71f67c32d894e19f355e445af1f673900" translate="yes" xml:space="preserve">
          <source>When a low-level graphics API is in use, the scenegraph will make sure there is a CPU-side wait for the GPU to complete all work submitted to the scenegraph's graphics command queue before the scenegraph's nodes are deleted. Therefore there is no need to issue additional waits here, unless the &lt;a href=&quot;qsgrendernode#render&quot;&gt;render&lt;/a&gt;() implementation is using additional command queues.</source>
          <target state="translated">使用低级图形API时，场景图将确保在CPU端等待GPU完成删除提交给场景图的图形命令队列的所有工作，然后再删除场景图的节点。因此，除非&lt;a href=&quot;qsgrendernode#render&quot;&gt;render&lt;/a&gt;（）实现使用其他命令队列，否则无需在此处发出其他等待。</target>
        </trans-unit>
        <trans-unit id="c845af89f01e419749914b45895c1bb235d5ce01" translate="yes" xml:space="preserve">
          <source>When a menu is torn off a second menu is shown to display the menu contents in a new window. When the menu is in this mode and the menu is visible returns &lt;code&gt;true&lt;/code&gt;; otherwise false.</source>
          <target state="translated">撕下菜单后，将显示另一个菜单，以在新窗口中显示菜单内容。当菜单处于此模式且菜单可见时，返回 &lt;code&gt;true&lt;/code&gt; ；否则，返回true。否则为假。</target>
        </trans-unit>
        <trans-unit id="728dd6daea54bbbc47c1c0afd43ec24383ab26a3" translate="yes" xml:space="preserve">
          <source>When a model is reset it means that any previous data reported from the model is now invalid and has to be queried for again. This also means that the current item and any selected items will become invalid.</source>
          <target state="translated">当一个模型被重置时,意味着以前从模型中报告的任何数据现在都是无效的,必须重新查询。这也意味着当前项目和任何选定的项目将变得无效。</target>
        </trans-unit>
        <trans-unit id="5f301e5dc3d747cffb379d30922ea2160d2c0277" translate="yes" xml:space="preserve">
          <source>When a model radically changes its data it can sometimes be easier to just call this function rather than emit &lt;a href=&quot;qabstractitemmodel#dataChanged&quot;&gt;dataChanged&lt;/a&gt;() to inform other components when the underlying data source, or its structure, has changed.</source>
          <target state="translated">当模型从根本上更改其数据时，有时可以更容易地调用此函数，而不是在基础数据源或其结构发生更改时发出&lt;a href=&quot;qabstractitemmodel#dataChanged&quot;&gt;dataChanged&lt;/a&gt;（）通知其他组件。</target>
        </trans-unit>
        <trans-unit id="798d38793d411f71af72b3a052c51c022e51937d" translate="yes" xml:space="preserve">
          <source>When a module name is used as the</source>
          <target state="translated">当使用模块名称作为</target>
        </trans-unit>
        <trans-unit id="c8bb4a36e1cc58b9d2f69c2e0e1701bc5743d489" translate="yes" xml:space="preserve">
          <source>When a new &lt;a href=&quot;q3dcamera&quot;&gt;Q3DCamera&lt;/a&gt; object is set, it is automatically added as child of the scene.</source>
          <target state="translated">设置新的&lt;a href=&quot;q3dcamera&quot;&gt;Q3DCamera&lt;/a&gt;对象后，它会自动添加为场景的子级。</target>
        </trans-unit>
        <trans-unit id="8b455ee9f46ef6792f12c0936577f332d927c927" translate="yes" xml:space="preserve">
          <source>When a new &lt;a href=&quot;q3dlight&quot;&gt;Q3DLight&lt;/a&gt; objects is set, it is automatically added as child of the scene.</source>
          <target state="translated">设置新的&lt;a href=&quot;q3dlight&quot;&gt;Q3DLight&lt;/a&gt;对象后，它将自动添加为场景的子级。</target>
        </trans-unit>
        <trans-unit id="92c136ff15dc3f6e6eb98af265af4b77642b9592" translate="yes" xml:space="preserve">
          <source>When a new column is flicked into view, &lt;a href=&quot;qml-qtquick-tableview&quot;&gt;TableView&lt;/a&gt; will determine its width by calling the &lt;a href=&quot;qml-qtquick-tableview#columnWidthProvider-prop&quot;&gt;columnWidthProvider&lt;/a&gt; function. &lt;a href=&quot;qml-qtquick-tableview&quot;&gt;TableView&lt;/a&gt; itself will never store row height or column width, as it's designed to support large models containing any number of rows and columns. Instead, it will ask the application whenever it needs to know.</source>
          <target state="translated">将新列滑动到视图中时，&lt;a href=&quot;qml-qtquick-tableview&quot;&gt;TableView&lt;/a&gt;将通过调用&lt;a href=&quot;qml-qtquick-tableview#columnWidthProvider-prop&quot;&gt;columnWidthProvider&lt;/a&gt;函数确定其宽度。&lt;a href=&quot;qml-qtquick-tableview&quot;&gt;TableView&lt;/a&gt;本身永远不会存储行高或列宽，因为它旨在支持包含任意数量的行和列的大型模型。相反，它将在需要知道时询问应用程序。</target>
        </trans-unit>
        <trans-unit id="bd3977fd3b9d0fff4ce92833839e9fd254909e52" translate="yes" xml:space="preserve">
          <source>When a new column is flicked into view, TableView will determine its width by calling the &lt;a href=&quot;qml-qtquick-tableview#columnWidthProvider-prop&quot;&gt;columnWidthProvider&lt;/a&gt; function. TableView does not store row height or column width, as it's designed to support large models containing any number of rows and columns. Instead, it will ask the application whenever it needs to know.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be74d7e819d89ccb9b1b730a61146409cce1e842" translate="yes" xml:space="preserve">
          <source>When a new connection is received, the client &lt;a href=&quot;qwebsocket&quot;&gt;QWebSocket&lt;/a&gt; is retrieved (`nextPendingConnection()`), and the signals we are interested in are connected to our slots (`textMessageReceived()`, `binaryMessageReceived()` and `disconnected()`). The client socket is remembered in a list, in case we would like to use it later (in this example, nothing is done with it).</source>
          <target state="translated">接收到新的连接时，将检索客户端&lt;a href=&quot;qwebsocket&quot;&gt;QWebSocket&lt;/a&gt;（`nextPendingConnection（）`），并将我们感兴趣的信号连接至插槽（`textMessageReceived（）`，`binaryMessageReceived（）`和`disconnected（）`）。 ）。客户端套接字会记住在列表中，以防我们稍后使用（在此示例中，它什么也没做）。</target>
        </trans-unit>
        <trans-unit id="bda773011b553996318d1ca0425ceb0218190f09" translate="yes" xml:space="preserve">
          <source>When a new group is pushed onto the debug groups stack, it will inherit the configuration of the group that was previously on the top of the stack. Vice versa, popping a debug group will restore the configuration of the debug group that becomes the new top.</source>
          <target state="translated">当一个新的组被推到调试组堆栈上时,它将继承之前在堆栈顶部的组的配置。反之亦然,弹出一个调试组会恢复成为新顶的调试组的配置。</target>
        </trans-unit>
        <trans-unit id="ec32af560002a3f2954d27992ea538e7e19a3001" translate="yes" xml:space="preserve">
          <source>When a node acquires a replica for a known source, it sends a request for that source to the host node. Upon receipt of this request, the host will create a reply packet with the current values of all properties of the source. If the requested replica is dynamic, it will include the API definition for the source. The replica's node will be included in the list of connections that receive changes to that source from then on.</source>
          <target state="translated">当一个节点获取一个已知源的副本时,它会向主机节点发送一个该源的请求。收到该请求后,主机将创建一个包含源的所有属性的当前值的回复包。如果请求的副本是动态的,它将包括源的API定义。从那时起,副本的节点将被包含在接收该源更改的连接列表中。</target>
        </trans-unit>
        <trans-unit id="2f9bbe722b869b83db0e2263dc70c8abde11f7e3" translate="yes" xml:space="preserve">
          <source>When a node acquires a replica for a known source, it sends a request for that source to the host node. Upon receiving this request, the host creates a reply packet with the current values for all properties of that source. If the requested replica is &lt;a href=&quot;qremoteobjectdynamicreplica&quot;&gt;dynamic&lt;/a&gt;, the reply packet includes the API definition for the source. From then on, the replica's node will be included in the list of connections that receive changes to that source.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d63ba8e6603b8cbc973323b39127ee0bc0ad55ba" translate="yes" xml:space="preserve">
          <source>When a page is about to be shown, &lt;a href=&quot;qwizard&quot;&gt;QWizard&lt;/a&gt; calls &lt;a href=&quot;qwizard#initializePage&quot;&gt;initializePage&lt;/a&gt;() (which in turn calls &lt;a href=&quot;qwizardpage#initializePage&quot;&gt;QWizardPage::initializePage&lt;/a&gt;()) to fill the page with default values. By default, this function does nothing, but it can be reimplemented to initialize the page's contents based on other pages' fields (see the &lt;a href=&quot;qwizard#initialize-page&quot;&gt;example above&lt;/a&gt;).</source>
          <target state="translated">当要显示页面时，&lt;a href=&quot;qwizard&quot;&gt;QWizard&lt;/a&gt;调用&lt;a href=&quot;qwizard#initializePage&quot;&gt;initializePage&lt;/a&gt;（）（依次调用&lt;a href=&quot;qwizardpage#initializePage&quot;&gt;QWizardPage :: initializePage&lt;/a&gt;（））以使用默认值填充页面。默认情况下，此功能不执行任何操作，但是可以根据其他页面的字段重新实现该功能以初始化页面的内容（请参见&lt;a href=&quot;qwizard#initialize-page&quot;&gt;上面&lt;/a&gt;的示例）。</target>
        </trans-unit>
        <trans-unit id="52b8a1c2a004bc4ae73bcc37ab97f637d0e15877" translate="yes" xml:space="preserve">
          <source>When a page is about to be shown, QWizard calls &lt;a href=&quot;qwizard#initializePage&quot;&gt;initializePage&lt;/a&gt;() (which in turn calls &lt;a href=&quot;qwizardpage#initializePage&quot;&gt;QWizardPage::initializePage&lt;/a&gt;()) to fill the page with default values. By default, this function does nothing, but it can be reimplemented to initialize the page's contents based on other pages' fields (see the &lt;a href=&quot;qwizard#initialize-page&quot;&gt;example above&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c63e8b4686c2ce6ea480da0dde82d96ac157403d" translate="yes" xml:space="preserve">
          <source>When a parallel state group is entered, all its child states will be simultaneously entered. Transitions within the individual child states operate normally. However, any of the child states may take a transition which exits the parent state. When this happens, the parent state and all of its child states are exited.</source>
          <target state="translated">当输入一个平行状态组时,它的所有子状态将同时被输入。各个子状态内的转换正常进行。但是,任何一个子状态都可能采取退出父状态的转换。在此情况下,父状态和所有的子状态都会被退出。</target>
        </trans-unit>
        <trans-unit id="f1b2b5f7aefbb0cb0ec4ae4792cb7356d5cdee30" translate="yes" xml:space="preserve">
          <source>When a partial match is found, no captured substrings are returned, and the (implicit) capturing group 0 corresponding to the whole match captures the partially matched substring of the subject string.</source>
          <target state="translated">当发现部分匹配时,不返回捕获的子串,与整个匹配相对应的(隐式)捕获组0捕获主题字符串的部分匹配子串。</target>
        </trans-unit>
        <trans-unit id="949ea8688bbfcd915778d80bb9ad32883794d483" translate="yes" xml:space="preserve">
          <source>When a pinch gesture is started, the rotation is &lt;code&gt;0.0&lt;/code&gt;.</source>
          <target state="translated">当开始捏手势时，旋转为 &lt;code&gt;0.0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6eeed75e83f5493322e8f521ba32040bf1a5bd87" translate="yes" xml:space="preserve">
          <source>When a pinch gesture is started, the scale is &lt;code&gt;1.0&lt;/code&gt;.</source>
          <target state="translated">开始捏手势时，比例为 &lt;code&gt;1.0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3947f323d774ee42a9f53aab29ffa36c8280798a" translate="yes" xml:space="preserve">
          <source>When a pixmap is inserted and the cache is about to exceed its limit, it removes pixmaps until there is enough room for the pixmap to be inserted.</source>
          <target state="translated">当一个像素图被插入,而缓存即将超过它的极限时,它将删除像素图,直到有足够的空间来插入像素图。</target>
        </trans-unit>
        <trans-unit id="14e43d5273a0f220d3f6cca0d60985a5d4b8fc21" translate="yes" xml:space="preserve">
          <source>When a place is removed, the &lt;a href=&quot;qplacemanager&quot;&gt;QPlaceManager&lt;/a&gt; may emit the &lt;a href=&quot;qplacemanager#placeRemoved&quot;&gt;QPlaceManager::placeRemoved&lt;/a&gt;() signal. Whether a manager does so is provider specific. Managers accessing places from a web service will typically not emit these signals, while managers accessing places stored locally generally will.</source>
          <target state="translated">删除位置后，&lt;a href=&quot;qplacemanager&quot;&gt;QPlaceManager&lt;/a&gt;可能会发出&lt;a href=&quot;qplacemanager#placeRemoved&quot;&gt;QPlaceManager :: placeRemoved&lt;/a&gt;（）信号。经理是否这样做取决于提供商。从Web服务访问场所的管理员通常不会发出这些信号，而访问本地存储的场所的管理员通常会发出这些信号。</target>
        </trans-unit>
        <trans-unit id="955b392e62b44331ff658695f8bca3787dde24b9" translate="yes" xml:space="preserve">
          <source>When a place is saved, the &lt;a href=&quot;qplacemanager&quot;&gt;QPlaceManager&lt;/a&gt; may emit QPlaceManager::placedAdded() or &lt;a href=&quot;qplacemanager#placeUpdated&quot;&gt;QPlaceManager::placeUpdated&lt;/a&gt;() signals. However whether a manager does so or not is provider specific, managers accessing places from a web service will typically not emit these signals while managers accessing places locally stored generally will.</source>
          <target state="translated">保存位置后，&lt;a href=&quot;qplacemanager&quot;&gt;QPlaceManager&lt;/a&gt;可能会发出QPlaceManager :: placedAdded（）或&lt;a href=&quot;qplacemanager#placeUpdated&quot;&gt;QPlaceManager :: placeUpdated&lt;/a&gt;（）信号。但是，无论管理者是否这样做都是特定于提供者的，从Web服务访问场所的管理者通常不会发出这些信号，而访问本地存储的场所的管理者通常会发出这些信号。</target>
        </trans-unit>
        <trans-unit id="bb76ccab6b6330b8216b91871b1f1a7518967e70" translate="yes" xml:space="preserve">
          <source>When a preprocessor symbol is specified using the &lt;code&gt;defines&lt;/code&gt; variable, you can also use the &lt;a href=&quot;12-0-qdoc-commands-miscellaneous#if-command&quot;&gt;\if&lt;/a&gt; command to enclose documentation that only will be included if the preprocessor symbol is defined.</source>
          <target state="translated">当使用 &lt;code&gt;defines&lt;/code&gt; 变量指定预处理器符号时，您也可以使用&lt;a href=&quot;12-0-qdoc-commands-miscellaneous#if-command&quot;&gt;\ if&lt;/a&gt;命令来封装仅在定义了预处理器符号时才会包括的文档。</target>
        </trans-unit>
        <trans-unit id="f785beae5730b83f41acbcf90ef75b7556aac2f1" translate="yes" xml:space="preserve">
          <source>When a press event occurs, each instance of &lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;PointHandler&lt;/a&gt; chooses a single point which is not yet &quot;taken&quot; at that moment: if the press occurs within the bounds of the &lt;a href=&quot;qml-qtquick-pointhandler#parent-prop&quot;&gt;PointerHandler::parent&lt;/a&gt;, and no sibling &lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;PointHandler&lt;/a&gt; within the same &lt;a href=&quot;qml-qtquick-pointhandler#parent-prop&quot;&gt;PointerHandler::parent&lt;/a&gt; has yet acquired a passive grab on that point, and if the other constraints such as &lt;a href=&quot;qml-qtquick-pointhandler#acceptedButtons-prop&quot;&gt;acceptedButtons&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-pointhandler#acceptedDevices-prop&quot;&gt;acceptedDevices&lt;/a&gt; etc. are satisfied, it's eligible, and the &lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;PointHandler&lt;/a&gt; then acquires a passive grab. In this way, the &lt;a href=&quot;qml-qtquick-pointhandler#parent-prop&quot;&gt;PointerHandler::parent&lt;/a&gt; acts like an exclusive group: there can be multiple instances of &lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;PointHandler&lt;/a&gt;, and the set of pressed touchpoints will be distributed among them. Each &lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;PointHandler&lt;/a&gt; which has chosen a point to track has its &lt;a href=&quot;stylesheet-reference#active&quot;&gt;active&lt;/a&gt; property &lt;code&gt;true&lt;/code&gt;. It then continues to track its chosen point until release: the properties of the &lt;a href=&quot;qml-point&quot;&gt;point&lt;/a&gt; will be kept up-to-date. Any Item can bind to these properties, and thereby follow the point's movements.</source>
          <target state="translated">当发生press事件时，&lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;PointHandler的&lt;/a&gt;每个实例都会选择当时尚未&amp;ldquo;获取&amp;rdquo;的单个点：如果按下发生在&lt;a href=&quot;qml-qtquick-pointhandler#parent-prop&quot;&gt;PointerHandler :: parent&lt;/a&gt;的边界内，并且同一个&lt;a href=&quot;qml-qtquick-pointhandler#parent-prop&quot;&gt;PointerHandler :: parent&lt;/a&gt;内没有同级&lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;PointHandler。&lt;/a&gt;尚未在该点上获得被动抓取，并且如果满足其他约束（例如&lt;a href=&quot;qml-qtquick-pointhandler#acceptedButtons-prop&quot;&gt;acceptedButtons&lt;/a&gt;，&lt;a href=&quot;qml-qtquick-pointhandler#acceptedDevices-prop&quot;&gt;acceptedDevices&lt;/a&gt;等），则表明它符合条件，然后&lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;PointHandler&lt;/a&gt;获得被动抓取。这样，&lt;a href=&quot;qml-qtquick-pointhandler#parent-prop&quot;&gt;PointerHandler :: parent&lt;/a&gt;就像一个排他组：可以有多个&lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;PointHandler&lt;/a&gt;实例，按下的接触点集将在其中分布。每个选择要跟踪的点的&lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;PointHandler&lt;/a&gt;都有其&lt;a href=&quot;stylesheet-reference#active&quot;&gt;active&lt;/a&gt;属性 &lt;code&gt;true&lt;/code&gt; 。然后，它将继续跟踪其选择的点，直到释放为止：该&lt;a href=&quot;qml-point&quot;&gt;点&lt;/a&gt;的属性将保持最新。任何项目都可以绑定到这些属性，从而跟随点的移动。</target>
        </trans-unit>
        <trans-unit id="10016a67871d70f0506ab0f762c8c06369cdb0ed" translate="yes" xml:space="preserve">
          <source>When a press event occurs, each instance of PointHandler chooses a single point which is not yet &quot;taken&quot; at that moment: if the press occurs within the bounds of the &lt;a href=&quot;qml-qtquick-pointhandler#parent-prop&quot;&gt;PointerHandler::parent&lt;/a&gt;, and no sibling PointHandler within the same &lt;a href=&quot;qml-qtquick-pointhandler#parent-prop&quot;&gt;PointerHandler::parent&lt;/a&gt; has yet acquired a passive grab on that point, and if the other constraints such as &lt;a href=&quot;qml-qtquick-pointhandler#acceptedButtons-prop&quot;&gt;acceptedButtons&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-pointhandler#acceptedDevices-prop&quot;&gt;acceptedDevices&lt;/a&gt; etc. are satisfied, it's eligible, and the PointHandler then acquires a passive grab. In this way, the &lt;a href=&quot;qml-qtquick-pointhandler#parent-prop&quot;&gt;PointerHandler::parent&lt;/a&gt; acts like an exclusive group: there can be multiple instances of PointHandler, and the set of pressed touchpoints will be distributed among them. Each PointHandler which has chosen a point to track has its &lt;a href=&quot;stylesheet-reference#active&quot;&gt;active&lt;/a&gt; property &lt;code&gt;true&lt;/code&gt;. It then continues to track its chosen point until release: the properties of the &lt;a href=&quot;qml-point&quot;&gt;point&lt;/a&gt; will be kept up-to-date. Any Item can bind to these properties, and thereby follow the point's movements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfbfb0ebbd6646025b981fa339de3293519a353e" translate="yes" xml:space="preserve">
          <source>When a print request is accepted, the printer status would change, triggering a change in the status property. This would then be reported to all Replicas.</source>
          <target state="translated">当接受打印请求时,打印机状态将发生变化,从而触发状态属性的变化。然后,这将被报告给所有副本。</target>
        </trans-unit>
        <trans-unit id="666537301706b87af8a406d9ea46793d0d017481" translate="yes" xml:space="preserve">
          <source>When a process using &lt;a href=&quot;qsystemsemaphore&quot;&gt;QSystemSemaphore&lt;/a&gt; terminates for any reason, Unix automatically reverses the effect of all acquire operations that were not released. Thus if the process acquires a resource and then exits without releasing it, Unix will release that resource.</source>
          <target state="translated">当使用&lt;a href=&quot;qsystemsemaphore&quot;&gt;QSystemSemaphore&lt;/a&gt;的进程由于任何原因终止时，Unix会自动撤消所有未释放的获取操作的影响。因此，如果进程获取了一个资源然后退出而不释放它，Unix将释放该资源。</target>
        </trans-unit>
        <trans-unit id="df1a65bbb3d9b167018ca0c5cdabe5195c1a5eea" translate="yes" xml:space="preserve">
          <source>When a process using QSystemSemaphore terminates for any reason, Unix automatically reverses the effect of all acquire operations that were not released. Thus if the process acquires a resource and then exits without releasing it, Unix will release that resource.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fb2e9f6ef5f613c87a38c8fd666c38c8b51fe6f" translate="yes" xml:space="preserve">
          <source>When a property sheet extension is required,</source>
          <target state="translated">当需要扩展财产表时。</target>
        </trans-unit>
        <trans-unit id="a0431b9169541b5942ac50072a09a56ca2303178" translate="yes" xml:space="preserve">
          <source>When a property value source object is assigned to a property, QML first tries to assign it normally, as though it were a regular QML type. Only if this assignment fails does the engine call the &lt;a href=&quot;qqmlpropertyvaluesource#setTarget&quot;&gt;setTarget()&lt;/a&gt; method. This allows the type to also be used in contexts other than just as a value source.</source>
          <target state="translated">将属性值源对象分配给属性后，QML首先尝试正常分配它，就像它是常规QML类型一样。仅当分配失败时，引擎才会调用&lt;a href=&quot;qqmlpropertyvaluesource#setTarget&quot;&gt;setTarget（）&lt;/a&gt;方法。这样一来，该类型还可以在其他环境中使用，而不仅仅是作为值源。</target>
        </trans-unit>
        <trans-unit id="5c0c5db3829a8327c7d24036abbfab378bf7a77f" translate="yes" xml:space="preserve">
          <source>When a query is run on XML data, as in the snippet above, the &lt;code&gt;doc()&lt;/code&gt; function returns the node in the built-in data model where the query evaluation will begin. But when a query is run on a custom node model containing non-XML data, one of the &lt;a href=&quot;qxmlquery#bindVariable&quot;&gt;bindVariable&lt;/a&gt;() functions must be called to bind a variable name to a starting node in the custom model. A $variable reference is used in the &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; text to access the starting node in the custom model. It is not necessary to declare the variable name external in the query. See the example in the documentation for &lt;a href=&quot;qabstractxmlnodemodel&quot;&gt;QAbstractXmlNodeModel&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="865208c91375893b92d822994a4204209a37ba98" translate="yes" xml:space="preserve">
          <source>When a query is run on XML data, as in the snippet above, the &lt;code&gt;doc()&lt;/code&gt; function returns the node in the built-in data model where the query evaluation will begin. But when a query is run on a custom node model containing non-XML data, one of the &lt;a href=&quot;qxmlquery#bindVariable&quot;&gt;bindVariable&lt;/a&gt;() functions must be called to bind a variable name to a starting node in the custom model. A $variable reference is used in the &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; text to access the starting node in the custom model. It is not necessary to declare the variable name external in the query. See the example in the documentation for &lt;a href=&quot;qabstractxmlnodemodel&quot;&gt;QAbstractXmlNodeModel&lt;/a&gt;.</source>
          <target state="translated">当对XML数据运行查询时，如上面的代码片段所示， &lt;code&gt;doc()&lt;/code&gt; 函数返回内置数据模型中的节点，查询评估将在该节点上开始。但是，当在包含非XML数据的定制节点模型上运行查询时，必须调用&lt;a href=&quot;qxmlquery#bindVariable&quot;&gt;bindVariable&lt;/a&gt;（）函数之一，以将变量名绑定到定制模型中的起始节点。在&lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt;文本中使用$ variable引用来访问定制模型中的起始节点。无需在查询中声明外部变量名。请参阅文档中的示例&lt;a href=&quot;qabstractxmlnodemodel&quot;&gt;QAbstractXmlNodeModel&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4b9712c67436ef44e2898fc4063b230c597593f7" translate="yes" xml:space="preserve">
          <source>When a query runs, it parses documents, allocating internal data structures to hold them, and it may load other resources over the network. It reuses these allocated resources when possible, to avoid having to reload and reparse them.</source>
          <target state="translated">当一个查询运行时,它会解析文档,分配内部数据结构来保存它们,它可能会通过网络加载其他资源。它尽可能地重复使用这些分配的资源,以避免不得不重新加载和重新解析这些资源。</target>
        </trans-unit>
        <trans-unit id="8a593010a6662d2b59e4a72e57582a95f2f8033f" translate="yes" xml:space="preserve">
          <source>When a rectangular clip is set in combination with &lt;a href=&quot;qsgclipnode#setIsRectangular&quot;&gt;setIsRectangular&lt;/a&gt; the renderer may in some cases use a more optimal clip method.</source>
          <target state="translated">当结合&lt;a href=&quot;qsgclipnode#setIsRectangular&quot;&gt;setIsRectangular&lt;/a&gt;设置矩形剪辑时，渲染器在某些情况下可能会使用更优化的剪辑方法。</target>
        </trans-unit>
        <trans-unit id="65c8e122245f9ff6c381bb4990517a1724e6f958" translate="yes" xml:space="preserve">
          <source>When a relative URL is written to a &lt;code&gt;url&lt;/code&gt; type property, it is converted into a URL object, so &lt;b&gt;matching the URL value against the input string value will fail&lt;/b&gt;. Instead, convert the string to a URL using Qt.resolvedUrl() for means of comparison, and use &lt;code&gt;toString()&lt;/code&gt; to get the contents of the URL:</source>
          <target state="translated">将相对URL写入 &lt;code&gt;url&lt;/code&gt; type属性后，它将转换为URL对象，因此&lt;b&gt;将URL值与输入字符串值进行匹配将失败&lt;/b&gt;。相反，请使用Qt.resolvedUrl（）将字符串转换为URL以进行比较，然后使用 &lt;code&gt;toString()&lt;/code&gt; 来获取URL的内容：</target>
        </trans-unit>
        <trans-unit id="fccc71619fd1248dd374a7ce2288a8bbb7a01715" translate="yes" xml:space="preserve">
          <source>When a scene is set on a view, the &lt;a href=&quot;qgraphicsscene#changed&quot;&gt;QGraphicsScene::changed&lt;/a&gt;() signal is automatically connected to this view's &lt;a href=&quot;qgraphicsview#updateScene&quot;&gt;updateScene&lt;/a&gt;() slot, and the view's scroll bars are adjusted to fit the size of the scene.</source>
          <target state="translated">当在视图上设置场景时，&lt;a href=&quot;qgraphicsscene#changed&quot;&gt;QGraphicsScene :: changed&lt;/a&gt;（）信号自动连接到该视图的&lt;a href=&quot;qgraphicsview#updateScene&quot;&gt;updateScene&lt;/a&gt;（）插槽，并且视图的滚动条进行调整以适合场景的大小。</target>
        </trans-unit>
        <trans-unit id="a9d5b266152d0f4cd9bb69c2a4c651cf03cd822b" translate="yes" xml:space="preserve">
          <source>When a shared object is created, it sets the reference count to 1. The reference count is incremented whenever a new object references the shared data, and decremented when the object dereferences the shared data. The shared data is deleted when the reference count becomes zero.</source>
          <target state="translated">当创建共享对象时,它将引用计数设为1。每当有新对象引用共享数据时,引用计数就会递增,当对象取消引用共享数据时,引用计数就会递减。当引用计数变为零时,共享数据被删除。</target>
        </trans-unit>
        <trans-unit id="cc3649a6da4b8adb60932067105d0642a4d24c46" translate="yes" xml:space="preserve">
          <source>When a shortcut's key sequence is completed, activatedAmbiguously() is emitted if the key sequence is still ambiguous (i.e., it is the start of one or more other shortcuts). The &lt;a href=&quot;qshortcut#activated&quot;&gt;activated&lt;/a&gt;() signal is not emitted in this case.</source>
          <target state="translated">当快捷键的键序列完成时，如果键序列仍然不明确（即，它是一个或多个其他快捷键的开始），则发出ActivateAmbiguously（）。的&lt;a href=&quot;qshortcut#activated&quot;&gt;活化&lt;/a&gt;（）信号没有在这种情况下发射。</target>
        </trans-unit>
        <trans-unit id="6332ae030a9135a45f7906377ec58084cbfab446" translate="yes" xml:space="preserve">
          <source>When a signal is emitted, the slots connected to it are usually executed immediately, just like a normal function call. When this happens, the signals and slots mechanism is totally independent of any GUI event loop. Execution of the code following the &lt;code&gt;emit&lt;/code&gt; statement will occur once all slots have returned. The situation is slightly different when using &lt;a href=&quot;qt#ConnectionType-enum&quot;&gt;queued connections&lt;/a&gt;; in such a case, the code following the &lt;code&gt;emit&lt;/code&gt; keyword will continue immediately, and the slots will be executed later.</source>
          <target state="translated">发出信号后，与其连接的插槽通常会立即执行，就像正常的函数调用一样。发生这种情况时，信号和时隙机制完全独立于任何GUI事件循环。一旦所有插槽都返回，将执行 &lt;code&gt;emit&lt;/code&gt; 语句之后的代码。使用&lt;a href=&quot;qt#ConnectionType-enum&quot;&gt;排队连接&lt;/a&gt;时情况略有不同; 在这种情况下， &lt;code&gt;emit&lt;/code&gt; 关键字之后的代码将立即继续，并且稍后将执行插槽。</target>
        </trans-unit>
        <trans-unit id="9ddb05e9c434f565919399ed11ae59e44adc1a53" translate="yes" xml:space="preserve">
          <source>When a slot is called in an object due to a signal delivery or due to a remote method call, it is sometimes necessary to know the context in which that happened. In particular, if the slot determines that it wants to send the reply at a later opportunity or if it wants to reply with an error, the context is needed.</source>
          <target state="translated">当一个槽由于信号传递或由于远程方法调用而在对象中被调用时,有时需要知道发生这种情况的上下文。特别是,如果槽确定它想在以后的机会发送回复,或者它想用错误来回复,就需要上下文。</target>
        </trans-unit>
        <trans-unit id="b82f70b447a179232f4e12d074947bc0969bd039" translate="yes" xml:space="preserve">
          <source>When a split handle is dragged, the &lt;code&gt;SplitView.preferredWidth&lt;/code&gt; or &lt;code&gt;SplitView.preferredHeight&lt;/code&gt; property is overwritten, depending on the &lt;a href=&quot;qml-qtquick-controls2-splitview#orientation-prop&quot;&gt;orientation&lt;/a&gt; of the view.</source>
          <target state="translated">拖动拆分句柄时， &lt;code&gt;SplitView.preferredWidth&lt;/code&gt; 或 &lt;code&gt;SplitView.preferredHeight&lt;/code&gt; 属性将被覆盖，具体取决于视图的&lt;a href=&quot;qml-qtquick-controls2-splitview#orientation-prop&quot;&gt;方向&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7d4d5ea445229544da0d5338a305894b8698bdd0" translate="yes" xml:space="preserve">
          <source>When a split item is resized, the preferredHeight will be set in order to keep track of the new size.</source>
          <target state="translated">当一个拆分项目被调整大小时,为了跟踪新的大小,将设置首选高度。</target>
        </trans-unit>
        <trans-unit id="161235a5aac72fca97ccfb11b438ac5fe662b266" translate="yes" xml:space="preserve">
          <source>When a split item is resized, the preferredWidth will be set in order to keep track of the new size.</source>
          <target state="translated">当一个拆分项目被调整大小时,为了跟踪新的大小,将设置首选宽度。</target>
        </trans-unit>
        <trans-unit id="2a09b738b648e2f453338d46763c1dca7735230f" translate="yes" xml:space="preserve">
          <source>When a stack is added to a group using &lt;a href=&quot;qundogroup#addStack&quot;&gt;addStack&lt;/a&gt;(), the group does not take ownership of the stack. This means the stack has to be deleted separately from the group. When a stack is deleted, it is automatically removed from a group. A stack may belong to only one group. Adding it to another group will cause it to be removed from the previous group.</source>
          <target state="translated">使用&lt;a href=&quot;qundogroup#addStack&quot;&gt;addStack&lt;/a&gt;（）将堆栈添加到组中时，该组不拥有该堆栈的所有权。这意味着堆栈必须与组分开删除。删除堆栈后，它将自动从组中删除。堆栈可能仅属于一个组。将其添加到另一个组会将其从上一个组中删除。</target>
        </trans-unit>
        <trans-unit id="3d6e4a2b53c50f2891abb48a8f6f6cc25d79ab52" translate="yes" xml:space="preserve">
          <source>When a state extends another state, it inherits all the changes of that state.</source>
          <target state="translated">当一个状态扩展另一个状态时,它继承了该状态的所有变化。</target>
        </trans-unit>
        <trans-unit id="6a4a099453c8a8d91cb5a5c167ee9f1538c09b8c" translate="yes" xml:space="preserve">
          <source>When a state is active, all its parent states are active by definition. When</source>
          <target state="translated">当一个状态处于活动状态时,根据定义,它的所有父状态都处于活动状态。当</target>
        </trans-unit>
        <trans-unit id="ba9d99ab4b7d6deb7d6417df3035d1441aabe91d" translate="yes" xml:space="preserve">
          <source>When a state is exited prior to the animation finishing, the behavior of the state machine depends on the target state of the transition. If the target state explicitly assigns a value to the property, no additional action will be taken. The property will be assigned the value defined by the target state.</source>
          <target state="translated">当一个状态在动画结束前退出时,状态机的行为取决于过渡的目标状态。如果目标状态明确地给属性赋值,则不会采取额外的操作。该属性将被分配目标状态定义的值。</target>
        </trans-unit>
        <trans-unit id="537b863aa4165206f1678fd45b68c897e7e5bb32" translate="yes" xml:space="preserve">
          <source>When a string is surrounded by slashes, it is interpreted as a &lt;a href=&quot;qregularexpression&quot;&gt;regular expression&lt;/a&gt;.</source>
          <target state="translated">当字符串被斜杠包围时，它将被解释为&lt;a href=&quot;qregularexpression&quot;&gt;正则表达式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f4d38a1eefb6595f564c6b5c58858271837243de" translate="yes" xml:space="preserve">
          <source>When a style sheet is active, the &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; returned by &lt;a href=&quot;qwidget#style&quot;&gt;QWidget::style&lt;/a&gt;() is a wrapper &quot;style sheet&quot; style,</source>
          <target state="translated">当样式表处于活动状态时，由&lt;a href=&quot;qwidget#style&quot;&gt;QWidget :: style&lt;/a&gt;（）返回的&lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt;是包装器&amp;ldquo;样式表&amp;rdquo;样式，</target>
        </trans-unit>
        <trans-unit id="e7f2cf6a190dccb2e1846d702f8b4fdcc1492b48" translate="yes" xml:space="preserve">
          <source>When a task menu extension is required,</source>
          <target state="translated">当需要任务菜单扩展时。</target>
        </trans-unit>
        <trans-unit id="b2160c5e21033a9cae7267b16da76e63faf558c9" translate="yes" xml:space="preserve">
          <source>When a texture is sub-sampled, fewer pixels than in the original are displayed, resulting in undesirable artifacts based on which pixels are chosen. This effect is worsened when the model is moving, as different pixels are chosen at different times. In the image below, notice how the line between E3 and F3 is missing, strongly present between G3 and H3, then gone for the next 5 columns, and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67462236b92450150e95164abdc0c9f99abaed6b" translate="yes" xml:space="preserve">
          <source>When a timer is started, the first trigger is usually after the specified interval has elapsed. It is sometimes desirable to trigger immediately when the timer is started; for example, to establish an initial state.</source>
          <target state="translated">当定时器启动时,第一次触发通常是在指定的时间间隔过后。有时最好在定时器启动时立即触发;例如,建立一个初始状态。</target>
        </trans-unit>
        <trans-unit id="af89fc9ae90b687bd3803dfbbaa74da9d0b068bb" translate="yes" xml:space="preserve">
          <source>When a toolbar is resized in such a way that it is too small to show all the items it contains, an extension button will appear as the last item in the toolbar. Pressing the extension button will pop up a menu containing the items that do not currently fit in the toolbar.</source>
          <target state="translated">当工具栏的大小调整到无法显示所有项目时,扩展按钮将作为工具栏的最后一个项目出现。按下扩展按钮将弹出一个菜单,其中包含了当前不适合在工具栏中显示的项目。</target>
        </trans-unit>
        <trans-unit id="fd7d3a341e5fbdb2b1a43242fcba495d019b0218" translate="yes" xml:space="preserve">
          <source>When a validator is set, the text field will only accept input which leaves the text property in an intermediate state. The &lt;a href=&quot;qml-qtquick-controls2-combobox#accepted-signal&quot;&gt;accepted&lt;/a&gt; signal will only be emitted if the text is in an acceptable state when the &lt;b&gt;Return&lt;/b&gt; or &lt;b&gt;Enter&lt;/b&gt; key is pressed.</source>
          <target state="translated">设置验证器后，文本字段将仅接受使text属性处于中间状态的输入。所述&lt;a href=&quot;qml-qtquick-controls2-combobox#accepted-signal&quot;&gt;接受的&lt;/a&gt;，如果文本是在可接受的状态下，当信号将仅发射&lt;b&gt;返回&lt;/b&gt;或&lt;b&gt;回车&lt;/b&gt;键被按下。</target>
        </trans-unit>
        <trans-unit id="9881f5360fc059aa0376cd9d05bbf2f898c14217" translate="yes" xml:space="preserve">
          <source>When a variable or property holds a basic type and it is assigned to another variable or property, then a copy of the value is made. In JavaScript, this value is called a primitive value.</source>
          <target state="translated">当一个变量或属性持有一个基本类型,并将其分配给另一个变量或属性时,那么就会对该值进行复制。在JavaScript中,这个值被称为基本值。</target>
        </trans-unit>
        <trans-unit id="c53c2d5ff931b774b8c26a43310ae5dc80383c71" translate="yes" xml:space="preserve">
          <source>When a version number is specified (using the &lt;code&gt;&lt;a href=&quot;#version&quot;&gt;version&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#versionsym&quot;&gt;versionsym&lt;/a&gt;&lt;/code&gt; variables in a &lt;code&gt;.qdocconf&lt;/code&gt; file), it is accessible through the corresponding \version command for use in the documentation.</source>
          <target state="translated">当指定一个版本号（使用 &lt;code&gt;&lt;a href=&quot;#version&quot;&gt;version&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#versionsym&quot;&gt;versionsym&lt;/a&gt;&lt;/code&gt; 在变量 &lt;code&gt;.qdocconf&lt;/code&gt; 文件），它是通过相应的\ version命令的文件用访问。</target>
        </trans-unit>
        <trans-unit id="684ca00eacddf983276d3d465bca149ba5b62e18" translate="yes" xml:space="preserve">
          <source>When a version number is specified (using the &lt;code&gt;&lt;a href=&quot;22-qdoc-configuration-generalvariables#version&quot;&gt;version&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;22-qdoc-configuration-generalvariables#versionsym&quot;&gt;versionsym&lt;/a&gt;&lt;/code&gt; variables in a &lt;code&gt;.qdocconf&lt;/code&gt; file), it is accessible through the corresponding \version command for use in the documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aed6e59537ae181997a746ca0c8b7b7d30d9468" translate="yes" xml:space="preserve">
          <source>When a view transition is initialized, any property bindings that refer to the &lt;a href=&quot;qml-qtquick-viewtransition&quot;&gt;ViewTransition&lt;/a&gt; attached property are evaluated in preparation for the transition. Due to the nature of the internal construction of a view transition, the attributes of the &lt;a href=&quot;qml-qtquick-viewtransition&quot;&gt;ViewTransition&lt;/a&gt; attached property are only valid for the relevant item when the transition is initialized, and may not be valid when the transition is actually run.</source>
          <target state="translated">初始化视图过渡时，&lt;a href=&quot;qml-qtquick-viewtransition&quot;&gt;将对&lt;/a&gt;引用ViewTransition附加属性的所有属性绑定进行评估，以为过渡做准备。由于视图过渡的内部构造的性质，&lt;a href=&quot;qml-qtquick-viewtransition&quot;&gt;ViewTransition&lt;/a&gt;附加属性的属性仅在过渡被初始化时对相关项有效，而在过渡运行时可能无效。</target>
        </trans-unit>
        <trans-unit id="2f1582c86a02339dce081b982fa7bf2aabd7e9cf" translate="yes" xml:space="preserve">
          <source>When a view transition is initialized, any property bindings that refer to the ViewTransition attached property are evaluated in preparation for the transition. Due to the nature of the internal construction of a view transition, the attributes of the ViewTransition attached property are only valid for the relevant item when the transition is initialized, and may not be valid when the transition is actually run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="079663e19f7c1ba992af80c0570d23237432e8c5" translate="yes" xml:space="preserve">
          <source>When a web site requests an SSL client certificate, and one or more certificates are found in the system's client certificate store, this class provides access to the certificates to choose from, as well as a method for selecting one.</source>
          <target state="translated">当一个网站请求SSL客户端证书,并且在系统的客户端证书存储中找到一个或多个证书时,这个类提供了对证书的访问,以及选择证书的方法。</target>
        </trans-unit>
        <trans-unit id="47f6110b5cfc30bcf437b8673336a30eccbb3a9e" translate="yes" xml:space="preserve">
          <source>When a web site requests an SSL client certificate, and one or more certificates are found in the system's client certificate store, this type provides access to the certificates to choose from, as well as a method for selecting one.</source>
          <target state="translated">当网站请求SSL客户端证书,并且在系统的客户端证书存储中找到了一个或多个证书时,该类型提供了对证书的访问选择,以及选择证书的方法。</target>
        </trans-unit>
        <trans-unit id="1a0abde4adaf9ada28bc188c310ca57b1baed315" translate="yes" xml:space="preserve">
          <source>When a widget &lt;a href=&quot;qwidget#acceptDrops-prop&quot;&gt;accepts drop events&lt;/a&gt;, it will receive this event if it has accepted the most recent &lt;a href=&quot;qdragenterevent&quot;&gt;QDragEnterEvent&lt;/a&gt; or &lt;a href=&quot;qdragmoveevent&quot;&gt;QDragMoveEvent&lt;/a&gt; sent to it.</source>
          <target state="translated">当小部件&lt;a href=&quot;qwidget#acceptDrops-prop&quot;&gt;接受放置事件时&lt;/a&gt;，如果它已接受发送给它的最新&lt;a href=&quot;qdragenterevent&quot;&gt;QDragEnterEvent&lt;/a&gt;或&lt;a href=&quot;qdragmoveevent&quot;&gt;QDragMoveEvent&lt;/a&gt;，它将接收此事件。</target>
        </trans-unit>
        <trans-unit id="460e4079ae7809950eebb7e9e8f3fa669aaa1958" translate="yes" xml:space="preserve">
          <source>When a widget asks a style to draw an element, it provides the style with a &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt;, which is a class that contains the information necessary for drawing. Thanks to &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt;, it is possible to make &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; draw widgets without linking in any code for the widget. This makes it possible to use &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt;'s draw functions on any paint device, i.e., you can draw a combobox on any widget, not just on a &lt;a href=&quot;qcombobox&quot;&gt;QComboBox&lt;/a&gt;.</source>
          <target state="translated">当小部件要求样式绘制元素时，它会为样式提供&lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt;，这是一个类，其中包含绘制所需的信息。由于使用了&lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt;，因此可以制作&lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt;绘制窗口小部件，而无需链接该窗口小部件的任何代码。这样就可以在任何绘画设备上使用&lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt;的绘制功能，即，您可以在任何窗口小部件上绘制一个组合框，而不仅仅是在&lt;a href=&quot;qcombobox&quot;&gt;QComboBox上&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e6f3f2c1aa86e2bdbf72b92865fad22cdf8f8992" translate="yes" xml:space="preserve">
          <source>When a widget is selected, normal clipboard operations such as cut, copy, and paste can be performed on it. All of these operations can be done and undone, as necessary.</source>
          <target state="translated">选择小组件后,可对其进行剪贴板操作,如剪切、复制和粘贴。所有这些操作都可以根据需要进行和撤销。</target>
        </trans-unit>
        <trans-unit id="32939db177a40f178792d1ab4a3586964a02a117" translate="yes" xml:space="preserve">
          <source>When a widget is used as a container to group a number of child widgets, it is known as a composite widget. These can be created by constructing a widget with the required visual properties - a &lt;a href=&quot;qframe&quot;&gt;QFrame&lt;/a&gt;, for example - and adding child widgets to it, usually managed by a layout. The above diagram shows such a composite widget that was created using Qt Designer.</source>
          <target state="translated">当将小部件用作对多个子小部件进行分组的容器时，它称为复合小部件。可以通过构造具有所需视觉属性的小部件（例如&lt;a href=&quot;qframe&quot;&gt;QFrame）&lt;/a&gt;并向其添加通常由布局管理的子小部件来创建这些小部件。上图显示了使用Qt Designer创建的复合窗口小部件。</target>
        </trans-unit>
        <trans-unit id="752f1a934fb7040e2a75e0adc0d7c4e3b00e3529" translate="yes" xml:space="preserve">
          <source>When a widget's font changes, it resolves its entries against its parent widget. If the widget does not have a parent widget, it resolves its entries against the scene. The widget then sends itself a &lt;a href=&quot;qevent#Type-enum&quot;&gt;FontChange&lt;/a&gt; event and notifies all its descendants so that they can resolve their fonts as well.</source>
          <target state="translated">当窗口小部件的字体更改时，它将根据其父窗口小部件解析其条目。如果该窗口小部件没有父窗口小部件，则会根据场景解析其条目。然后，小部件将自己发送一个&lt;a href=&quot;qevent#Type-enum&quot;&gt;FontChange&lt;/a&gt;事件并通知其所有后代，以便他们也可以解析其字体。</target>
        </trans-unit>
        <trans-unit id="8a4c47081bd0d78ce71a943dd5b9dd67bf60e6f3" translate="yes" xml:space="preserve">
          <source>When a widget's palette changes, it resolves its entries against its parent widget, or if it doesn't have a parent widget, it resolves against the scene. It then sends itself a &lt;a href=&quot;qevent#Type-enum&quot;&gt;PaletteChange&lt;/a&gt; event, and notifies all its descendants so they can resolve their palettes as well.</source>
          <target state="translated">当窗口小部件的调色板发生更改时，它将根据其父窗口小部件解析其条目，或者如果它没有父窗口小部件，则针对场景进行解析。然后，它向自己发送一个&lt;a href=&quot;qevent#Type-enum&quot;&gt;PaletteChange&lt;/a&gt;事件，并通知其所有后代，以便他们也可以解析其调色板。</target>
        </trans-unit>
        <trans-unit id="6c935a584189a93e055ba79f2173aba07e5d505b" translate="yes" xml:space="preserve">
          <source>When a window is not visible its visibility is Hidden, and setting visibility to &lt;a href=&quot;qwindow#Visibility-enum&quot;&gt;Hidden&lt;/a&gt; is the same as setting &lt;a href=&quot;qml-qtquick-window-window#visible-prop&quot;&gt;visible&lt;/a&gt; to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">当窗口不可见其知名度是隐藏的，并设置能见度&lt;a href=&quot;qwindow#Visibility-enum&quot;&gt;隐藏的&lt;/a&gt;是一样的设置&lt;a href=&quot;qml-qtquick-window-window#visible-prop&quot;&gt;可见&lt;/a&gt;，以 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="328cfe9dc26b3602c3dd93834eca6371ca53bcbc" translate="yes" xml:space="preserve">
          <source>When a window is using an OpenGL based surface and is appearing in full screen mode, problems can occur with other top-level windows which are part of the application. Due to limitations of the Windows DWM, compositing is not handled correctly for OpenGL based windows when going into full screen mode. As a result, other top-level windows are not placed on top of the full screen window when they are made visible. For example, menus may not appear correctly, or dialogs fail to show up.</source>
          <target state="translated">当一个窗口使用基于OpenGL的曲面并以全屏模式出现时,作为应用程序一部分的其他顶层窗口可能会出现问题。由于Windows DWM的限制,当进入全屏模式时,不能正确处理基于OpenGL的窗口的合成。因此,当其他顶层窗口变得可见时,它们不会被放置在全屏窗口的顶部。例如,菜单可能无法正确显示,或对话框无法显示。</target>
        </trans-unit>
        <trans-unit id="e6e925bbf3d90d27901234a3378310aa8ca76a99" translate="yes" xml:space="preserve">
          <source>When absolutely necessary, this limitation can be overcome by setting the &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_AlwaysStackOnTop&lt;/a&gt; attribute on the &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt;. Be aware however that this breaks stacking order, for example it will not be possible to have other widgets on top of the &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt;, so it should only be used in situations where a semi-transparent &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt; with other widgets visible underneath is required.</source>
          <target state="translated">在绝对必要的，这种限制可以通过设置来克服&lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;的Qt :: WA_AlwaysStackOnTop&lt;/a&gt;的属性&lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt;。但是请注意，这会破坏堆叠顺序，例如，不可能在&lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget的&lt;/a&gt;顶部放置其他小部件，因此，仅在需要半透明&lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt;及其下方需要其他小部件的情况下才应使用它。</target>
        </trans-unit>
        <trans-unit id="b6f91c3f1d20bbeecc7d389e5ae573aae0f28831" translate="yes" xml:space="preserve">
          <source>When absolutely necessary, this limitation can be overcome by setting the &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_AlwaysStackOnTop&lt;/a&gt; attribute on the &lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt;. Be aware, however that this breaks stacking order. For example it will not be possible to have other widgets on top of the &lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt;, so it should only be used in situations where a semi-transparent &lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt; with other widgets visible underneath is required.</source>
          <target state="translated">在绝对必要的，这种限制可以通过设置来克服&lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;的Qt :: WA_AlwaysStackOnTop&lt;/a&gt;的属性&lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt;。但是请注意，这会破坏堆叠顺序。例如，不可能在&lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt;上放置其他小部件，因此仅应在需要半透明&lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt;及其下方可见其他小部件的情况下使用。</target>
        </trans-unit>
        <trans-unit id="dd97e50e2c67a4ead279bf8d8832fc9a85185034" translate="yes" xml:space="preserve">
          <source>When absolutely necessary, this limitation can be overcome by setting the &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_AlwaysStackOnTop&lt;/a&gt; attribute on the QOpenGLWidget. Be aware however that this breaks stacking order, for example it will not be possible to have other widgets on top of the QOpenGLWidget, so it should only be used in situations where a semi-transparent QOpenGLWidget with other widgets visible underneath is required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e79a7fffcc2719cd295404f96fe561b573e17000" translate="yes" xml:space="preserve">
          <source>When absolutely necessary, this limitation can be overcome by setting the &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_AlwaysStackOnTop&lt;/a&gt; attribute on the QQuickWidget. Be aware, however that this breaks stacking order. For example it will not be possible to have other widgets on top of the QQuickWidget, so it should only be used in situations where a semi-transparent QQuickWidget with other widgets visible underneath is required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9df5199ed73ebbcc06766d6511a4572850a19641" translate="yes" xml:space="preserve">
          <source>When access to the data is no longer needed be sure to call the &lt;a href=&quot;qabstractvideobuffer#unmap&quot;&gt;unmap&lt;/a&gt;() function to release the mapped memory and possibly update the buffer contents.</source>
          <target state="translated">当不再需要访问数据时，请确保调用&lt;a href=&quot;qabstractvideobuffer#unmap&quot;&gt;unmap&lt;/a&gt;（）函数以释放映射的内存并可能更新缓冲区内容。</target>
        </trans-unit>
        <trans-unit id="7f19c431a0d32b110924683908433279ea139496" translate="yes" xml:space="preserve">
          <source>When access to the data is no longer needed, be sure to call the &lt;a href=&quot;qvideoframe#unmap&quot;&gt;unmap&lt;/a&gt;() function to release the mapped memory and possibly update the video frame contents.</source>
          <target state="translated">当不再需要访问数据时，请确保调用&lt;a href=&quot;qvideoframe#unmap&quot;&gt;unmap&lt;/a&gt;（）函数以释放映射的内存并可能更新视频帧的内容。</target>
        </trans-unit>
        <trans-unit id="76c2596888d85f6b2c006508a41b7c104d68f3e1" translate="yes" xml:space="preserve">
          <source>When active is &lt;code&gt;true&lt;/code&gt;, and the delegate component is ready, the Instantiator will create objects according to the model. When active is &lt;code&gt;false&lt;/code&gt;, no objects will be created and any previously created objects will be destroyed.</source>
          <target state="translated">当active为 &lt;code&gt;true&lt;/code&gt; 时，并且委托组件已准备就绪，Instantiator将根据模型创建对象。当active为 &lt;code&gt;false&lt;/code&gt; 时，将不创建任何对象，并且将销毁任何先前创建的对象。</target>
        </trans-unit>
        <trans-unit id="12b8ae889e8cb41399d2e7e574fc759816dcd949" translate="yes" xml:space="preserve">
          <source>When active is true, and the delegate component is ready, the Instantiator will create objects according to the model. When active is false, no objects will be created and any previously created objects will be destroyed.</source>
          <target state="translated">当active为true,并且委托组件准备就绪时,Instantiator将根据模型创建对象。当active为false时,将不会创建任何对象,任何先前创建的对象将被销毁。</target>
        </trans-unit>
        <trans-unit id="bb891bbb3b1590bf7288c70b1d889bb5699abbfb" translate="yes" xml:space="preserve">
          <source>When adding or removing intervals from the time range, existing intervals within the range may be expanded, trimmed, deleted, merged or split to ensure that all intervals within the time range remain distinct and disjoint. As a consequence, all intervals added or removed from a time range must be &lt;a href=&quot;qmediatimeinterval#isNormal&quot;&gt;normal&lt;/a&gt;.</source>
          <target state="translated">在时间范围内添加或删除时间间隔时，可以扩展，修剪，删除，合并或拆分该时间范围内的现有时间间隔，以确保该时间范围内的所有时间间隔保持不同且不相交。结果，从时间范围添加或删除的所有间隔都必须是&lt;a href=&quot;qmediatimeinterval#isNormal&quot;&gt;正常的&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0d4f3812ee3ea698da8238994dd265c1c75c9c45" translate="yes" xml:space="preserve">
          <source>When adding text to a text edit, it is an advantage to add it in an edit block (see example below). The result is that the text edit does not need to build the entire document structure at once.</source>
          <target state="translated">当在文本编辑中添加文本时,将其添加在编辑块中是一个优势(见下面的例子)。其结果是,文本编辑不需要一次性建立整个文档结构。</target>
        </trans-unit>
        <trans-unit id="bb84371278c0809ff19ae10f5e09e0a84286da38" translate="yes" xml:space="preserve">
          <source>When adding touch events to the sequence,</source>
          <target state="translated">将触摸事件添加到序列中时。</target>
        </trans-unit>
        <trans-unit id="f1538eed1aaf041d2e66701f8146b1df9ccdc51d" translate="yes" xml:space="preserve">
          <source>When additional touch points are detected, Qt first looks to see if there are any active touch points on any ancestor or descendent of the widget under the new touch point. If there are, the new touch point is grouped with the first, and the new touch point will be sent in a single &lt;a href=&quot;qtouchevent&quot;&gt;QTouchEvent&lt;/a&gt; to the widget that handled the first touch point. (The widget under the new touch point will not receive an event).</source>
          <target state="translated">当检测到其他接触点时，Qt首先查看是否在新接触点下小部件的任何祖先或后代上有任何活动的接触点。如果有的话，新的接触点将与第一个接触点分组，并且新的接触点将在单个&lt;a href=&quot;qtouchevent&quot;&gt;QTouchEvent中&lt;/a&gt;发送到处理第一个接触点的小部件。（新接触点下的小部件将不会收到事件）。</target>
        </trans-unit>
        <trans-unit id="e556c9c43b8715d0148015f22447dd2e38354307" translate="yes" xml:space="preserve">
          <source>When additional touch points are detected, Qt first looks to see if there are any active touch points on any ancestor or descendent of the widget under the new touch point. If there are, the new touch point is grouped with the first, and the new touch point will be sent in a single QTouchEvent to the widget that handled the first touch point. (The widget under the new touch point will not receive an event).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e4c9f17f04f10fedd1f9fd887395ad46b2aa135" translate="yes" xml:space="preserve">
          <source>When all content of the scene has stopped moving, the camera is jiggled very slightly between frames, and the result of each new frame is blended with the previous frames. The more frames you accumulate, the better looking the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e831f4eb7ef019746768c98e62442552c2eec2dc" translate="yes" xml:space="preserve">
          <source>When all the class attribute values are defined as they are in the style.css file that is used for rendering the Qt documentation, the above example is rendered as:</source>
          <target state="translated">当所有的类属性值都被定义为它们在用于渲染Qt文档的style.css文件中的值时,上面的例子被渲染为。</target>
        </trans-unit>
        <trans-unit id="bddff14c450c718712b8166ec8a19a179f1d175d" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtqml-modules-identifiedmodules.html#&quot;&gt;identified module&lt;/a&gt; is imported, the QML engine searches the</source>
          <target state="translated">当&lt;a href=&quot;https://doc.qt.io/qt-5.13/qtqml-modules-identifiedmodules.html#&quot;&gt;识别模块&lt;/a&gt;是进口的，QML引擎的搜索</target>
        </trans-unit>
        <trans-unit id="9add852e9635e48ec41c6e958905759815f12454" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtqml-modules-identifiedmodules.html&quot;&gt;identified module&lt;/a&gt; is imported, the QML engine searches the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cb0af928cd358589c97b0ea36760a95bf56bf0a" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;qml-qtquick-anchoranimation&quot;&gt;AnchorAnimation&lt;/a&gt; is used in a &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;Transition&lt;/a&gt;, it will animate any &lt;a href=&quot;qml-qtquick-anchorchanges&quot;&gt;AnchorChanges&lt;/a&gt; that have occurred during the state change. This can be overridden by setting a specific target item using the &lt;a href=&quot;qml-qtquick-anchorchanges#target-prop&quot;&gt;AnchorChanges.target&lt;/a&gt; property.</source>
          <target state="translated">当&lt;a href=&quot;qml-qtquick-anchoranimation&quot;&gt;AnchorAnimation&lt;/a&gt;在用过的&lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;过渡&lt;/a&gt;，这将动画任何&lt;a href=&quot;qml-qtquick-anchorchanges&quot;&gt;AnchorChanges&lt;/a&gt;状态变化过程中发生的。可以通过使用&lt;a href=&quot;qml-qtquick-anchorchanges#target-prop&quot;&gt;AnchorChanges.target&lt;/a&gt;属性设置特定的目标项目来覆盖它。</target>
        </trans-unit>
        <trans-unit id="f7ee3afe1168f0981bdb0b13f0d2799a8598f876" translate="yes" xml:space="preserve">
          <source>When an AnchorAnimation is used in a &lt;a href=&quot;https://doc.qt.io/qt-5.15/qmlexampletoggleswitch.html#transition&quot;&gt;Transition&lt;/a&gt;, it will animate any &lt;a href=&quot;qml-qtquick-anchorchanges&quot;&gt;AnchorChanges&lt;/a&gt; that have occurred during the state change. This can be overridden by setting a specific target item using the &lt;a href=&quot;qml-qtquick-anchorchanges#target-prop&quot;&gt;AnchorChanges.target&lt;/a&gt; property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ba28642fdd34030f92c386fbe056673579dd0c3" translate="yes" xml:space="preserve">
          <source>When an accessible object is changed in a way that users need to know about, it notifies clients of the change by sending them an event via the accessible interface. This is how &lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt; calls &lt;a href=&quot;https://doc.qt.io/qt-5.13/qaccessible-obsolete.html#updateAccessibility&quot;&gt;updateAccessibility()&lt;/a&gt; to indicate that its value has changed:</source>
          <target state="translated">当以用户需要了解的方式更改可访问对象时，它通过可访问接口向客户端发送事件来通知更改。&lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt;就是这样调用&lt;a href=&quot;https://doc.qt.io/qt-5.13/qaccessible-obsolete.html#updateAccessibility&quot;&gt;updateAccessibility（）&lt;/a&gt;来指示其值已更改：</target>
        </trans-unit>
        <trans-unit id="b37fb5dbdfd3c126b6bb96b69ea36eec43900147" translate="yes" xml:space="preserve">
          <source>When an accessible object is changed in a way that users need to know about, it notifies clients of the change by sending them an event via the accessible interface. This is how &lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt; calls &lt;a href=&quot;https://doc.qt.io/qt-5.15/qaccessible-obsolete.html#updateAccessibility&quot;&gt;updateAccessibility()&lt;/a&gt; to indicate that its value has changed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6576db350133d85ab8ecdf7d5ae903317f8a0480" translate="yes" xml:space="preserve">
          <source>When an action is paired with buttons and menu items, the &lt;code&gt;enabled&lt;/code&gt;, &lt;code&gt;checkable&lt;/code&gt;, and &lt;code&gt;checked&lt;/code&gt; states are synced automatically. For example, in a word processor, if the user clicks a &quot;Bold&quot; toolbar button, the &quot;Bold&quot; menu item will automatically be checked. Buttons and menu items get their &lt;code&gt;text&lt;/code&gt; and &lt;code&gt;icon&lt;/code&gt; from the action by default. An action-specific &lt;code&gt;text&lt;/code&gt; or &lt;code&gt;icon&lt;/code&gt; can be overridden for a specific control by specifying &lt;code&gt;text&lt;/code&gt; or &lt;code&gt;icon&lt;/code&gt; directly on the control.</source>
          <target state="translated">当动作与按钮和菜单项配对时， &lt;code&gt;enabled&lt;/code&gt; ， &lt;code&gt;checkable&lt;/code&gt; 和 &lt;code&gt;checked&lt;/code&gt; 状态将自动同步。例如，在文字处理器中，如果用户单击&amp;ldquo;加粗&amp;rdquo;工具栏按钮，则将自动检查&amp;ldquo;加粗&amp;rdquo;菜单项。默认情况下，按钮和菜单项从操作中获取其 &lt;code&gt;text&lt;/code&gt; 和 &lt;code&gt;icon&lt;/code&gt; 。一个特定于操作的 &lt;code&gt;text&lt;/code&gt; 或 &lt;code&gt;icon&lt;/code&gt; 可以被覆盖，通过指定一个特定的控制 &lt;code&gt;text&lt;/code&gt; 或 &lt;code&gt;icon&lt;/code&gt; 上直接控制。</target>
        </trans-unit>
        <trans-unit id="afbbfa71a43b518eb49ebc7fe0e3a201130db196" translate="yes" xml:space="preserve">
          <source>When an animation is used as a value source or in a Behavior, the default target and property name to be animated can both be inferred.</source>
          <target state="translated">当动画作为值源或在Behavior中使用时,默认的目标和要动画的属性名都可以被推断出来。</target>
        </trans-unit>
        <trans-unit id="336fbed65cc485dcf3185a5f916cafb70ff1cbed" translate="yes" xml:space="preserve">
          <source>When an animation is used standalone, both the target and property need to be explicitly specified.</source>
          <target state="translated">当单独使用动画时,需要明确指定目标和属性。</target>
        </trans-unit>
        <trans-unit id="3e063384f01e7cc982fe175643205033a89ac5c6" translate="yes" xml:space="preserve">
          <source>When an application modal dialog is opened, the user must finish interacting with the dialog and close it before they can access any other window in the application. Window modal dialogs only block access to the window associated with the dialog, allowing the user to continue to use other windows in an application.</source>
          <target state="translated">当应用程序模态对话框被打开时,用户必须先完成与对话框的交互,并关闭它,然后才能访问应用程序中的任何其他窗口。窗口模态对话框只阻止访问与对话框相关的窗口,允许用户继续使用应用程序中的其他窗口。</target>
        </trans-unit>
        <trans-unit id="03f1ac029efa0e89898412a8bc3f237fc158d829" translate="yes" xml:space="preserve">
          <source>When an error occurs during a transaction (including an inner transaction failing), reading from the data stream is suspended (all subsequent read operations return empty/zero values) and subsequent inner transactions are forced to fail. Starting a new outermost transaction recovers from this state. This behavior makes it unnecessary to error-check every read operation separately.</source>
          <target state="translated">当一个事务中发生错误时(包括内部事务失败),从数据流中的读取将被暂停(所有后续的读取操作都返回空/零值),后续的内部事务将被迫失败。启动一个新的最外层事务可以从这种状态中恢复过来。这种行为使得没有必要分别对每个读操作进行错误检查。</target>
        </trans-unit>
        <trans-unit id="d4d4dd6c5a276f9a88210865c11ad3239fc05498" translate="yes" xml:space="preserve">
          <source>When an escape button can't be determined using these rules, pressing &lt;b&gt;Esc&lt;/b&gt; has no effect.</source>
          <target state="translated">如果无法使用这些规则确定转义按钮，则按&lt;b&gt;Esc键&lt;/b&gt;无效。</target>
        </trans-unit>
        <trans-unit id="88e91d6c3ac2f70e9dc327611729bb3fc23462f4" translate="yes" xml:space="preserve">
          <source>When an escape button could not be automatically detected, pressing &lt;b&gt;Esc&lt;/b&gt; has no effect.</source>
          <target state="translated">当无法自动检测到逃生按钮时，按&lt;b&gt;Esc键&lt;/b&gt;无效。</target>
        </trans-unit>
        <trans-unit id="60deb4d5ec6470a1989d6f1aae50fd37df3fb27a" translate="yes" xml:space="preserve">
          <source>When an event notification identified by</source>
          <target state="translated">当一个事件通知由</target>
        </trans-unit>
        <trans-unit id="cc1c8c604562d809abc5eea2fc6d1c3875525ea6" translate="yes" xml:space="preserve">
          <source>When an event occurs, Qt creates an event object to represent it by constructing an instance of the appropriate &lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt; subclass, and delivers it to a particular instance of &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; (or one of its subclasses) by calling its &lt;a href=&quot;qobject#event&quot;&gt;event()&lt;/a&gt; function.</source>
          <target state="translated">当事件发生时，Qt通过构造适当的&lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt;子类的实例来创建事件对象来表示它，并通过调用&lt;a href=&quot;qobject#event&quot;&gt;事件（）&lt;/a&gt;函数将其传递到&lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;的特定实例（或其子类之一）。</target>
        </trans-unit>
        <trans-unit id="de6f46d25c54bf3f5ae53599544aff515fdc8c6f" translate="yes" xml:space="preserve">
          <source>When an extension is requested,</source>
          <target state="translated">当申请延期时:</target>
        </trans-unit>
        <trans-unit id="82176d3ebc0806a90e56a238f12634352670b5cd" translate="yes" xml:space="preserve">
          <source>When an extension is required,</source>
          <target state="translated">当需要延期时。</target>
        </trans-unit>
        <trans-unit id="15891740de686f6443de37f1b681bce112b87311" translate="yes" xml:space="preserve">
          <source>When an input mask is set, the &lt;a href=&quot;qlineedit#text-prop&quot;&gt;text&lt;/a&gt;() method returns a modified copy of the line edit content where all the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e58900421752248eb5fa9c7e1a8662c806ac6e45" translate="yes" xml:space="preserve">
          <source>When an item becomes the child of another item:</source>
          <target state="translated">当一个项目成为另一个项目的子项目时。</target>
        </trans-unit>
        <trans-unit id="6de19d2590d4fe0fe6e06630c40b5632e67df7b0" translate="yes" xml:space="preserve">
          <source>When an item gains the keyboard grab, it receives a &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::GrabKeyboard&lt;/a&gt; event. When it loses the keyboard grab, it receives a &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::UngrabKeyboard&lt;/a&gt; event. These events can be used to detect when your item gains or loses the keyboard grab through other means than gaining input focus.</source>
          <target state="translated">当某项获得键盘抓取时，它将收到&lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent :: GrabKeyboard&lt;/a&gt;事件。当失去键盘抓取功能时，它将收到&lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent :: UngrabKeyboard&lt;/a&gt;事件。这些事件可用于通过获取输入焦点以外的其他方式检测您的项目何时获得或失去键盘控制权。</target>
        </trans-unit>
        <trans-unit id="64c535dc14ed7e2aa62d21df9de2e71bdefba665" translate="yes" xml:space="preserve">
          <source>When an item gains the mouse grab, it receives a &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::GrabMouse&lt;/a&gt; event. When it loses the mouse grab, it receives a &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::UngrabMouse&lt;/a&gt; event. These events can be used to detect when your item gains or loses the mouse grab through other means than receiving mouse button events.</source>
          <target state="translated">当某项获得鼠标抓取时，它将收到&lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent :: GrabMouse&lt;/a&gt;事件。当失去鼠标抓取功能时，它将收到&lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent :: UngrabMouse&lt;/a&gt;事件。这些事件可用于通过接收鼠标按钮事件以外的其他方式检测您的物品何时获得或失去鼠标抓取。</target>
        </trans-unit>
        <trans-unit id="6f8dc2c7ef923f949343da800eb159af2c1dde1c" translate="yes" xml:space="preserve">
          <source>When an item in an item view is selected, also highlight the branch or other decoration.</source>
          <target state="translated">当项目视图中的项目被选中时,也要高亮显示分支或其他装饰。</target>
        </trans-unit>
        <trans-unit id="fcc2ea9c9f7cae3dd849abe3ca69b4158eef37eb" translate="yes" xml:space="preserve">
          <source>When an item is disabled, it is not possible to trigger it through its &lt;a href=&quot;qml-qt-labs-platform-menuitem#shortcut-prop&quot;&gt;shortcut&lt;/a&gt;.</source>
          <target state="translated">禁用某个项目后，将无法通过其&lt;a href=&quot;qml-qt-labs-platform-menuitem#shortcut-prop&quot;&gt;快捷方式&lt;/a&gt;触发它。</target>
        </trans-unit>
        <trans-unit id="452a0cf012b3cb9c186457a25f7cb1b1b7718e16" translate="yes" xml:space="preserve">
          <source>When an item is editable (and enabled), the user can edit the item by invoking one of the view's edit triggers; see &lt;a href=&quot;qabstractitemview#editTriggers-prop&quot;&gt;QAbstractItemView::editTriggers&lt;/a&gt;.</source>
          <target state="translated">当一个项目是可编辑的（并且已启用）时，用户可以通过调用视图的编辑触发器之一来编辑该项目。参见&lt;a href=&quot;qabstractitemview#editTriggers-prop&quot;&gt;QAbstractItemView :: editTriggers&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="53f7062365ff27f397c1a00527a4d2f3130aae95" translate="yes" xml:space="preserve">
          <source>When an item is enabled, the user can interact with it. The possible types of interaction are specified by the other item flags, such as &lt;a href=&quot;qstandarditem#isEditable&quot;&gt;isEditable&lt;/a&gt;() and &lt;a href=&quot;qstandarditem#isSelectable&quot;&gt;isSelectable&lt;/a&gt;().</source>
          <target state="translated">启用项目后，用户可以与其进行交互。交互的可能类型由其他项标志指定，例如&lt;a href=&quot;qstandarditem#isEditable&quot;&gt;isEditable&lt;/a&gt;（）和&lt;a href=&quot;qstandarditem#isSelectable&quot;&gt;isSelectable&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="cc78ed51b3f4dd69fbf5c809ac07b2202ac93036" translate="yes" xml:space="preserve">
          <source>When an item is flicked out, it moves to the</source>
          <target state="translated">当一个物品被弹出时,它就会移动到下面的</target>
        </trans-unit>
        <trans-unit id="edf649890497fe5584e977a2ddf9e845a6d9adbb" translate="yes" xml:space="preserve">
          <source>When an item's layer is enabled, the scene graph will allocate memory in the GPU equal to &lt;code&gt;width x height x 4&lt;/code&gt;. In memory constrained configurations, large layers should be used with care.</source>
          <target state="translated">启用项目的图层时，场景图将在GPU中分配等于 &lt;code&gt;width x height x 4&lt;/code&gt; 的内存。在内存受限的配置中，应谨慎使用大层。</target>
        </trans-unit>
        <trans-unit id="01223f794ced4ae7d5d61d347c9ab920ed50ad46" translate="yes" xml:space="preserve">
          <source>When an object is deleted, it emits a &lt;a href=&quot;qobject#destroyed&quot;&gt;destroyed&lt;/a&gt;() signal. You can catch this signal to avoid dangling references to QObjects.</source>
          <target state="translated">删除对象后，它将发出一个&lt;a href=&quot;qobject#destroyed&quot;&gt;destroy&lt;/a&gt;（）信号。您可以捕获此信号，以避免悬挂引用QObjects。</target>
        </trans-unit>
        <trans-unit id="b5486876fa77fcc351c0468b0f817e3d9df8a75d" translate="yes" xml:space="preserve">
          <source>When and whether you actually</source>
          <target state="translated">你何时以及是否真的</target>
        </trans-unit>
        <trans-unit id="9d01348a9aece3a4b6e828d26241b1bbac417b30" translate="yes" xml:space="preserve">
          <source>When animations are used to assign properties, a state no longer defines the exact values that a property will have when the machine is in the given state. While the animation is running, the property can potentially have any value, depending on the animation.</source>
          <target state="translated">当动画用于分配属性时,当机器处于给定状态时,一个状态不再定义属性的确切值。当动画运行时,属性有可能具有任何值,这取决于动画。</target>
        </trans-unit>
        <trans-unit id="e2fc21797749a0f52070944bd489489ff6abab01" translate="yes" xml:space="preserve">
          <source>When any item is added, moved or removed within the above view, the items below it are displaced, causing them to move down (or sideways, if horizontally orientated) within the view. As this displacement occurs, the items' movement to their new x,y positions within the view will be animated by a &lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation&lt;/a&gt; over one second, as specified.</source>
          <target state="translated">在上视图中添加，移动或删除任何项目时，其下方的项目都会移动，从而导致它们在视图内向下移动（或横向移动，如果水平放置）。当发生这种位移时，&lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;将按NumberAnimation&lt;/a&gt;在指定的时间内在一秒钟内将项目移动到视图中新的x，y位置的动画。</target>
        </trans-unit>
        <trans-unit id="6ad254e9576e1f6e7ddb5f7d88c66a573a0635ac" translate="yes" xml:space="preserve">
          <source>When any of the states is entered, the label's text will be changed accordingly.</source>
          <target state="translated">当输入任何一个状态时,标签的文字也会相应改变。</target>
        </trans-unit>
        <trans-unit id="92871574343d3169789071570bca986c9cf96ef4" translate="yes" xml:space="preserve">
          <source>When any of these are needed, the Connections type can be used instead.</source>
          <target state="translated">当需要这些类型时,可以使用连接类型代替。</target>
        </trans-unit>
        <trans-unit id="684810257cd0aed1db1716426f1de0a6c11c6d93" translate="yes" xml:space="preserve">
          <source>When any visible part of the scene changes or is reexposed, &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; will update the entire viewport. This approach is fastest when &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; spends more time figuring out what to draw than it would spend drawing (e.g., when very many small items are repeatedly updated). This is the preferred update mode for viewports that do not support partial updates, such as &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt;, and for viewports that need to disable scroll optimization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="217cf31f7ecab879e6aeaf0c5c92b52eaff625db" translate="yes" xml:space="preserve">
          <source>When any visible part of the scene changes or is reexposed, &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; will update the entire viewport. This approach is fastest when &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; spends more time figuring out what to draw than it would spend drawing (e.g., when very many small items are repeatedly updated). This is the preferred update mode for viewports that do not support partial updates, such as QGLWidget, and for viewports that need to disable scroll optimization.</source>
          <target state="translated">当场景的任何可见部分发生更改或重新曝光时，&lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt;将更新整个视口。当&lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt;花更多的时间来确定要绘制的内容时，这种方法是最快的（例如，当很多小物件被重复更新时）。对于不支持部分更新的视口（例如QGLWidget）以及需要禁用滚动优化的视口，这是首选的更新模式。</target>
        </trans-unit>
        <trans-unit id="a06bc6d7390ca623b0217a85f5d3800a53cff310" translate="yes" xml:space="preserve">
          <source>When applying &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-effects-topic.html#opacity&quot;&gt;opacity&lt;/a&gt; to an item hierarchy the opacity is applied to each item individually. This can lead to undesired visual results when the opacity is applied to a subtree. Consider the following example:</source>
          <target state="translated">将&lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-effects-topic.html#opacity&quot;&gt;不透明度&lt;/a&gt;应用于项目层次结构时，不透明度将分别应用于每个项目。当不透明度应用于子树时，这可能导致不希望的视觉结果。考虑以下示例：</target>
        </trans-unit>
        <trans-unit id="5a74e7e50f43c1fdec3974065e7b6a9d890d2418" translate="yes" xml:space="preserve">
          <source>When applying &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtquick-effects-topic.html#opacity&quot;&gt;opacity&lt;/a&gt; to an item hierarchy the opacity is applied to each item individually. This can lead to undesired visual results when the opacity is applied to a subtree. Consider the following example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03f4da2f8d439defdd9e3b555f171b3b3c94fa9c" translate="yes" xml:space="preserve">
          <source>When applying a clip to a subtree, that subtree needs to be rendered with a unique OpenGL state. This means that when &lt;a href=&quot;qml-qtquick-item#clip-prop&quot;&gt;Item::clip&lt;/a&gt; is true, batching of that item is limited to its children. When there are many children, like a &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-gridview&quot;&gt;GridView&lt;/a&gt;, or complex children, like a &lt;a href=&quot;qml-qtquick-controls-textarea&quot;&gt;TextArea&lt;/a&gt;, this is fine. One should, however, use clip on smaller items with caution as it prevents batching. This includes button label, text field or list delegate and table cells.</source>
          <target state="translated">将剪辑应用于子树时，该子树需要使用唯一的OpenGL状态进行渲染。这意味着当&lt;a href=&quot;qml-qtquick-item#clip-prop&quot;&gt;Item :: clip&lt;/a&gt;为true时，该项目的批处理仅限于其子项目。当有许多子级（例如&lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt;或&lt;a href=&quot;qml-qtquick-gridview&quot;&gt;GridView&lt;/a&gt;）或复杂子级（例如&lt;a href=&quot;qml-qtquick-controls-textarea&quot;&gt;TextArea）时&lt;/a&gt;，这很好。但是，应谨慎使用较小的物品，因为它会阻止批量生产。这包括按钮标签，文本字段或列表委托和表单元格。</target>
        </trans-unit>
        <trans-unit id="74f4063795ab227fe7ae24a79df545f1ccc36474" translate="yes" xml:space="preserve">
          <source>When applying a clip to a subtree, that subtree needs to be rendered with a unique OpenGL state. This means that when &lt;a href=&quot;qml-qtquick-item#clip-prop&quot;&gt;Item::clip&lt;/a&gt; is true, batching of that item is limited to its children. When there are many children, like a &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-gridview&quot;&gt;GridView&lt;/a&gt;, or complex children, like a &lt;a href=&quot;qml-qtquick-controls2-textarea&quot;&gt;TextArea&lt;/a&gt;, this is fine. One should, however, use clip on smaller items with caution as it prevents batching. This includes button label, text field or list delegate and table cells.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b46cb236869034e639f5c98ef59e6e0dc79b743e" translate="yes" xml:space="preserve">
          <source>When assigning values to properties in QML, any layouting the item must do as a result of the assignment might not take effect immediately, but can instead be postponed until the item is polished. For these cases, you can use this function to ensure that the item has been polished before the execution of the test continues. For example:</source>
          <target state="translated">当给QML中的属性赋值时,任何因赋值而必须对项目进行的布局可能不会立即生效,而是可以推迟到项目被打磨完毕。对于这些情况,你可以使用这个函数来确保在继续执行测试之前,项目已经被抛光。例如</target>
        </trans-unit>
        <trans-unit id="9aade8d1fb980c82f7d60913e871590165c272dc" translate="yes" xml:space="preserve">
          <source>When asynchronous is true the Instantiator will attempt to create objects asynchronously. This means that objects may not be available immediately, even if active is set to true.</source>
          <target state="translated">当asynchronous为true时,Instantiator将尝试异步创建对象。这意味着,即使将active设置为true,对象也可能不会立即可用。</target>
        </trans-unit>
        <trans-unit id="ed095d8711f54124e3343d3e3564a7eefda4e48d" translate="yes" xml:space="preserve">
          <source>When atEnd() and &lt;a href=&quot;qxmlstreamreader#hasError&quot;&gt;hasError&lt;/a&gt;() return true and &lt;a href=&quot;qxmlstreamreader#error&quot;&gt;error&lt;/a&gt;() returns &lt;a href=&quot;qxmlstreamreader#Error-enum&quot;&gt;PrematureEndOfDocumentError&lt;/a&gt;, it means the XML has been well-formed so far, but a complete XML document has not been parsed. The next chunk of XML can be added with &lt;a href=&quot;qxmlstreamreader#addData&quot;&gt;addData&lt;/a&gt;(), if the XML is being read from a &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt;, or by waiting for more data to arrive if the XML is being read from a &lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt;. Either way, atEnd() will return false once more data is available.</source>
          <target state="translated">当atEnd（）和&lt;a href=&quot;qxmlstreamreader#hasError&quot;&gt;hasError&lt;/a&gt;（）返回true且&lt;a href=&quot;qxmlstreamreader#error&quot;&gt;error&lt;/a&gt;（）返回&lt;a href=&quot;qxmlstreamreader#Error-enum&quot;&gt;PrematureEndOfDocumentError时&lt;/a&gt;，这表示XML到目前为止格式正确，但是尚未解析完整的XML文档。如果正在从&lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt;读取XML，则可以使用&lt;a href=&quot;qxmlstreamreader#addData&quot;&gt;addData&lt;/a&gt;（）添加下一个XML块，或者如果正在从&lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt;读取XML，则可以等待更多数据到达。无论哪种方式，一旦有更多数据可用，atEnd（）都将返回false。</target>
        </trans-unit>
        <trans-unit id="b3157310c43a1e88b9499e85e194d29092d5e110" translate="yes" xml:space="preserve">
          <source>When automatically registering QML types defined in C++, register an additional version of the module using this minor version. Generally, minor versions to be registered are inferred from the meta objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="769b89390fbaab8a30caa729005e13bd89dd70b2" translate="yes" xml:space="preserve">
          <source>When both the &lt;a href=&quot;qml-qtpurchasing-product#identifier-prop&quot;&gt;identifier&lt;/a&gt; and type is set, the product is queried from the external market place, and its other properties are updated asynchronously. At this point, the identifier and type can no longer be changed.</source>
          <target state="translated">当同时设置了&lt;a href=&quot;qml-qtpurchasing-product#identifier-prop&quot;&gt;标识符&lt;/a&gt;和类型时，将从外部市场查询产品，并异步更新其其他属性。此时，标识符和类型不能再更改。</target>
        </trans-unit>
        <trans-unit id="e66ead871376ec31f6b0bdabc0d22f6168fd30da" translate="yes" xml:space="preserve">
          <source>When both the identifier and &lt;a href=&quot;qml-qtpurchasing-product#type-prop&quot;&gt;type&lt;/a&gt; is set, the product is queried from the external market place, and its other properties are updated asynchronously. At this point, the identifier and type can no longer be changed.</source>
          <target state="translated">当同时设置了标识符和&lt;a href=&quot;qml-qtpurchasing-product#type-prop&quot;&gt;类型时&lt;/a&gt;，将从外部市场查询产品，并异步更新其其他属性。此时，标识符和类型不能再更改。</target>
        </trans-unit>
        <trans-unit id="a77db60a6597f85a3430717a9225f81f9e8efd43" translate="yes" xml:space="preserve">
          <source>When building Qt from source, the configuration system checks for the presence of the &lt;code&gt;openssl/opensslv.h&lt;/code&gt; header provided by source or developer packages of OpenSSL.</source>
          <target state="translated">从源代码构建Qt时，配置系统检查是否存在由 &lt;code&gt;openssl/opensslv.h&lt;/code&gt; 的源代码或开发人员软件包提供的openssl / opensslv.h标头。</target>
        </trans-unit>
        <trans-unit id="481f920a35be00bb71b2fc213b17ba321c9ce91c" translate="yes" xml:space="preserve">
          <source>When building a list or a tree that has only one column, this function provides a convenient way to append a single new</source>
          <target state="translated">当建立一个只有一列的列表或树时,这个函数提供了一个方便的方法来附加一个新的列。</target>
        </trans-unit>
        <trans-unit id="f4d252c2c2fbed789c886d3ea6d5aac266ab2c26" translate="yes" xml:space="preserve">
          <source>When building a list or a tree that has only one column, this function provides a convenient way to append a single new item.</source>
          <target state="translated">当建立一个只有一列的列表或树时,这个函数提供了一个方便的方法来追加一个新项目。</target>
        </trans-unit>
        <trans-unit id="c2ec3d7c6f7c3543ad312c99f702307e4ac89f3b" translate="yes" xml:space="preserve">
          <source>When building a list or a tree that has only one column, this function provides a convenient way to insert a single new item.</source>
          <target state="translated">当建立一个只有一列的列表或树时,这个函数提供了一个方便的方法来插入一个新项目。</target>
        </trans-unit>
        <trans-unit id="6c09737d74d2162e6fdbbf52bfd0b26549723d50" translate="yes" xml:space="preserve">
          <source>When building a version of Qt linked against OpenSSL, the build system will attempt to link with libssl and libcrypt libraries located in the default location on the developer's system. This location is configurable: set the &lt;code&gt;OPENSSL_LIBS&lt;/code&gt; environment variable to contain the linker options required to link Qt against the installed library. For example, on a Unix/Linux system:</source>
          <target state="translated">在构建与OpenSSL链接的Qt版本时，构建系统将尝试与位于开发人员系统默认位置的libssl和libcrypt库进行链接。此位置是可配置的：设置 &lt;code&gt;OPENSSL_LIBS&lt;/code&gt; 环境变量以包含将Qt与已安装的库链接所需的链接器选项。例如，在Unix / Linux系统上：</target>
        </trans-unit>
        <trans-unit id="c9861e5ecd8580ac9329bf8a380f56f7c6afce34" translate="yes" xml:space="preserve">
          <source>When building from source, ensure that the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62819592f1c6df3a87bed54e97d13fd158256db9" translate="yes" xml:space="preserve">
          <source>When building from source, ensure that the &lt;a href=&quot;qtgraphicaleffects-index&quot;&gt;Qt Graphical Effects&lt;/a&gt; module is also built, as Qt Quick Controls 2 requires it.</source>
          <target state="translated">从源代码构建时，请确保也构建了&lt;a href=&quot;qtgraphicaleffects-index&quot;&gt;Qt图形效果&lt;/a&gt;模块，这是Qt Quick Controls 2所要求的。</target>
        </trans-unit>
        <trans-unit id="d0d5ad78ee0d3c591ef53c8a838b7b5e7736a74d" translate="yes" xml:space="preserve">
          <source>When building from source, ensure that the &lt;a href=&quot;qtgraphicaleffects-index&quot;&gt;Qt Graphical Effects&lt;/a&gt; module is also built, as Qt Quick Controls requires it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7251f805a1544f17a9559e9785d85be1aae09528" translate="yes" xml:space="preserve">
          <source>When building user interfaces with the &lt;a href=&quot;qtquick-index&quot;&gt;Qt Quick&lt;/a&gt; module, all QML objects that are to be visually rendered must derive from the &lt;a href=&quot;qml-qtquick-item&quot;&gt;Item&lt;/a&gt; type, as it is the base type for all visual objects in &lt;a href=&quot;qtquick-index&quot;&gt;Qt Quick&lt;/a&gt;. This &lt;a href=&quot;qml-qtquick-item&quot;&gt;Item&lt;/a&gt; type is implemented by the &lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt; C++ class, which is provided by the &lt;a href=&quot;qtquick-index&quot;&gt;Qt Quick&lt;/a&gt; module. Therefore, this class should be subclassed when it is necessary to implement a visual type in C++ that can be integrated into a QML-based user interface.</source>
          <target state="translated">使用&lt;a href=&quot;qtquick-index&quot;&gt;Qt Quick&lt;/a&gt;模块构建用户界面时，所有要可视化呈现的QML对象必须派生自&lt;a href=&quot;qml-qtquick-item&quot;&gt;Item&lt;/a&gt;类型，因为它是&lt;a href=&quot;qtquick-index&quot;&gt;Qt Quick中&lt;/a&gt;所有可视对象的基本类型。此&lt;a href=&quot;qml-qtquick-item&quot;&gt;Item&lt;/a&gt;类型由&lt;a href=&quot;qtquick-index&quot;&gt;Qt Quick&lt;/a&gt;模块提供的&lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt; C ++类实现。因此，当有必要在C ++中实现可集成到基于QML的用户界面中的可视类型时，应将该类作为子类。</target>
        </trans-unit>
        <trans-unit id="573536b41f02e737bb17c87ec630c4949eebe25a" translate="yes" xml:space="preserve">
          <source>When built, the Qt Image Formats plugins are located as dynamic libraries in the runtime plugin directory (typically &lt;code&gt;plugins/imageformats&lt;/code&gt;), together with the default image format plugins. They may be deployed to the target system in the same way as other plugins, see the &lt;a href=&quot;https://doc.qt.io/qt-5.13/deployment-plugins.html&quot;&gt;Deploying Plugins&lt;/a&gt; documentation.</source>
          <target state="translated">构建后，Qt图像格式插件与动态库一起位于运行时插件目录（通常是 &lt;code&gt;plugins/imageformats&lt;/code&gt; ）中，同时还包含默认图像格式插件。可以按照与其他插件相同的方式将它们部署到目标系统，请参阅&amp;ldquo; &lt;a href=&quot;https://doc.qt.io/qt-5.13/deployment-plugins.html&quot;&gt;部署插件&amp;rdquo;&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="1e398ca745e5b7e0d76604dae601be679e6ea3ec" translate="yes" xml:space="preserve">
          <source>When built, the Qt Image Formats plugins are located as dynamic libraries in the runtime plugin directory (typically &lt;code&gt;plugins/imageformats&lt;/code&gt;), together with the default image format plugins. They may be deployed to the target system in the same way as other plugins, see the &lt;a href=&quot;https://doc.qt.io/qt-5.15/deployment-plugins.html&quot;&gt;Deploying Plugins&lt;/a&gt; documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85c65eea35b46ad9adc8aa9df7e19d248494566d" translate="yes" xml:space="preserve">
          <source>When caching is enabled, &lt;a href=&quot;qfileinfo&quot;&gt;QFileInfo&lt;/a&gt; reads the file information from the file system the first time it's needed, but generally not later.</source>
          <target state="translated">启用缓存后，&lt;a href=&quot;qfileinfo&quot;&gt;QFileInfo&lt;/a&gt;会在第一次需要时从文件系统中读取文件信息，但通常不会在以后。</target>
        </trans-unit>
        <trans-unit id="63f929311e0c136280261b1674d609c45952f607" translate="yes" xml:space="preserve">
          <source>When caching is enabled, an item's &lt;a href=&quot;qgraphicsitem#paint&quot;&gt;paint&lt;/a&gt;() function will generally draw into an offscreen pixmap cache; for any subsequent repaint requests, the Graphics View framework will redraw from the cache. This approach works particularly well with QGLWidget, which stores all the cache as OpenGL textures.</source>
          <target state="translated">启用缓存后，项目的&lt;a href=&quot;qgraphicsitem#paint&quot;&gt;paint&lt;/a&gt;（）函数通常会绘制到屏幕外的像素图缓存中；对于任何后续的重画请求，Graphics View框架将从缓存中重画。这种方法特别适用于QGLWidget，后者将所有缓存存储为OpenGL纹理。</target>
        </trans-unit>
        <trans-unit id="49d3402980e692757da4d25c7f056cfbcbc4090c" translate="yes" xml:space="preserve">
          <source>When calculating the size hint, &lt;a href=&quot;qgroupbox&quot;&gt;QGroupBox&lt;/a&gt; fetches three pixel metrics from the style: &lt;code&gt;PM_IndicatorWidth&lt;/code&gt;, &lt;code&gt;PM_CheckBoxLabelSpacing&lt;/code&gt;, and &lt;code&gt;PM_IndicatorHeight&lt;/code&gt;. &lt;a href=&quot;qgroupbox&quot;&gt;QGroupBox&lt;/a&gt; has the following style element tree:</source>
          <target state="translated">在计算大小提示时，&lt;a href=&quot;qgroupbox&quot;&gt;QGroupBox&lt;/a&gt;从样式中获取三个像素度量： &lt;code&gt;PM_IndicatorWidth&lt;/code&gt; ， &lt;code&gt;PM_CheckBoxLabelSpacing&lt;/code&gt; 和 &lt;code&gt;PM_IndicatorHeight&lt;/code&gt; 。&lt;a href=&quot;qgroupbox&quot;&gt;QGroupBox&lt;/a&gt;具有以下样式元素树：</target>
        </trans-unit>
        <trans-unit id="21b955b352a198452eb600dee09c98ed26feb22d" translate="yes" xml:space="preserve">
          <source>When calculating the slider's size hint, &lt;code&gt;PM_SliderThickness&lt;/code&gt; and &lt;code&gt;PM_SliderLength&lt;/code&gt; are queried from the style. As with scroll bars, the &lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt; only lets the user move the handle if the mouse is within &lt;code&gt;PM_MaximumDragDistance&lt;/code&gt; from the slider bounds. When it draws itself, it creates the style option and calls &lt;code&gt;drawComplexControl()&lt;/code&gt; with &lt;code&gt;CC_Slider&lt;/code&gt;:</source>
          <target state="translated">在计算滑块的大小提示时， &lt;code&gt;PM_SliderThickness&lt;/code&gt; &lt;code&gt;PM_SliderLength&lt;/code&gt; 中查询PM_SliderThickness和PM_SliderLength。与滚动条一样，如果鼠标位于滑块边界的 &lt;code&gt;PM_MaximumDragDistance&lt;/code&gt; 内，则&lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt;仅允许用户移动手柄。绘制自身时，它将创建样式选项，并使用 &lt;code&gt;CC_Slider&lt;/code&gt; 调用 &lt;code&gt;drawComplexControl()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1d40ba7fa0fde8f8ba84bf5f3be3928589a792a0" translate="yes" xml:space="preserve">
          <source>When called as a constructor, a new instance of the class will be created. Only constructors exposed by &lt;a href=&quot;qobject#Q_INVOKABLE&quot;&gt;Q_INVOKABLE&lt;/a&gt; will be visible from the script engine.</source>
          <target state="translated">当作为构造函数调用时，将创建该类的新实例。在脚本引擎中，只有&lt;a href=&quot;qobject#Q_INVOKABLE&quot;&gt;Q_INVOKABLE&lt;/a&gt;公开的构造函数可见。</target>
        </trans-unit>
        <trans-unit id="1a17521f28b13cf15c64f48b6b71bf71a004d243" translate="yes" xml:space="preserve">
          <source>When called by Qt,</source>
          <target state="translated">当被Qt调用时。</target>
        </trans-unit>
        <trans-unit id="914ad22810e57e0a208c0b39ab77807e77834ddd" translate="yes" xml:space="preserve">
          <source>When calling Java functions that might throw an exception, it is important that you check, handle and clear out the exception before continuing.</source>
          <target state="translated">在调用可能会抛出异常的Java函数时,在继续调用之前,必须先检查、处理和清除异常。</target>
        </trans-unit>
        <trans-unit id="2a2e7ae65f87e90c76479fdc5ff2e4326b27c302" translate="yes" xml:space="preserve">
          <source>When calling this function, you can use the &lt;code&gt;SIGNAL()&lt;/code&gt; macro to pass a specific signal:</source>
          <target state="translated">调用此函数时，可以使用 &lt;code&gt;SIGNAL()&lt;/code&gt; 宏传递特定信号：</target>
        </trans-unit>
        <trans-unit id="16fd68ecc7c1ca2e0fddbce432b5a471d518bb57" translate="yes" xml:space="preserve">
          <source>When changing properties with values that may be defined within a resource file,</source>
          <target state="translated">当改变资源文件中可能定义的值的属性时。</target>
        </trans-unit>
        <trans-unit id="10172d955b561d851a1e685787b7d1f3cc20d57f" translate="yes" xml:space="preserve">
          <source>When changing the geometry, the widget, if visible, receives a move event (&lt;a href=&quot;qwidget#moveEvent&quot;&gt;moveEvent&lt;/a&gt;()) and/or a resize event (&lt;a href=&quot;qwidget#resizeEvent&quot;&gt;resizeEvent&lt;/a&gt;()) immediately. If the widget is not currently visible, it is guaranteed to receive appropriate events before it is shown.</source>
          <target state="translated">更改几何时，小部件（如果可见）会立即接收一个移动事件（&lt;a href=&quot;qwidget#moveEvent&quot;&gt;moveEvent&lt;/a&gt;（））和/或一个调整大小事件（&lt;a href=&quot;qwidget#resizeEvent&quot;&gt;resizeEvent&lt;/a&gt;（））。如果窗口小部件当前不可见，则可以确保在显示窗口小部件之前先接收适当的事件。</target>
        </trans-unit>
        <trans-unit id="3dcc6167c4c8ec1a522615dcd2a97bfd046a2f80" translate="yes" xml:space="preserve">
          <source>When changing the position, the widget, if visible, receives a move event (&lt;a href=&quot;qwidget#moveEvent&quot;&gt;moveEvent&lt;/a&gt;()) immediately. If the widget is not currently visible, it is guaranteed to receive an event before it is shown.</source>
          <target state="translated">更改位置时，小部件（如果可见）会立即接收一个移动事件（&lt;a href=&quot;qwidget#moveEvent&quot;&gt;moveEvent&lt;/a&gt;（））。如果该窗口小部件当前不可见，则可以保证在显示该事件之前会收到一个事件。</target>
        </trans-unit>
        <trans-unit id="d10e878de0de661440ee8d64ce4885521ddfa38a" translate="yes" xml:space="preserve">
          <source>When checking the signatures of its arguments, &lt;a href=&quot;qobject#connect&quot;&gt;QObject::connect&lt;/a&gt;() compares the data types literally. Thus, &lt;a href=&quot;qt#AlignmentFlag-enum&quot;&gt;Alignment&lt;/a&gt; and &lt;a href=&quot;qt#AlignmentFlag-enum&quot;&gt;Qt::Alignment&lt;/a&gt; are treated as two distinct types. To work around this limitation, make sure to fully qualify the data types when declaring signals and slots, and when establishing connections. For example:</source>
          <target state="translated">检查其参数的签名时，&lt;a href=&quot;qobject#connect&quot;&gt;QObject :: connect&lt;/a&gt;（）会按字面意义比较数据类型。因此，&lt;a href=&quot;qt#AlignmentFlag-enum&quot;&gt;Alignment&lt;/a&gt;和&lt;a href=&quot;qt#AlignmentFlag-enum&quot;&gt;Qt :: Alignment&lt;/a&gt;被视为两种不同的类型。要解决此限制，请确保在声明信号和插槽以及建立连接时完全限定数据类型。例如：</target>
        </trans-unit>
        <trans-unit id="6c76cad238f22ed5e500ffc1b09ea0553c302ab3" translate="yes" xml:space="preserve">
          <source>When choosing a widget to use as a placeholder, it is useful to compare the API of the missing widget with those of standard Qt widgets. For specialized widgets that subclass standard classes, the obvious choice of placeholder is the base class of the custom widget; for example, &lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt; might be used for specialized &lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt; subclasses.</source>
          <target state="translated">选择要用作占位符的小部件时，将丢失的小部件的API与标准Qt小部件的API进行比较非常有用。对于子类标准类的专用小部件，占位符的明显选择是自定义小部件的基类。例如，&lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt;可能用于专门的&lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt;子类。</target>
        </trans-unit>
        <trans-unit id="16d44be4536ee05b1e19ae36cfa871d577dd74c9" translate="yes" xml:space="preserve">
          <source>When client code handling the &lt;a href=&quot;qnetworkreply#redirected&quot;&gt;redirected&lt;/a&gt;() signal has verified the new URL, it emits this signal to allow the redirect to go ahead. This protocol applies to network requests whose redirects policy is set to &lt;a href=&quot;qnetworkrequest#RedirectPolicy-enum&quot;&gt;QNetworkRequest::UserVerifiedRedirectPolicy&lt;/a&gt;</source>
          <target state="translated">当处理&lt;a href=&quot;qnetworkreply#redirected&quot;&gt;redirected&lt;/a&gt;（）信号的客户端代码验证了新URL时，它将发出该信号以允许重定向继续进行。此协议适用于其重定向策略设置为&lt;a href=&quot;qnetworkrequest#RedirectPolicy-enum&quot;&gt;QNetworkRequest :: UserVerifiedRedirectPolicy的&lt;/a&gt;网络请求</target>
        </trans-unit>
        <trans-unit id="a496bd66ef281f3e102e4c15780975eb23b209d8" translate="yes" xml:space="preserve">
          <source>When combined with Subdirectories, this flag enables iterating through all subdirectories of the assigned path, following all symbolic links. Symbolic link loops (e.g., &quot;link&quot; =&amp;gt; &quot;.&quot; or &quot;link&quot; =&amp;gt; &quot;..&quot;) are automatically detected and ignored.</source>
          <target state="translated">当与子目录结合使用时，此标志允许在所有符号链接之后遍历分配路径的所有子目录。符号链接循环（例如，&amp;ldquo; link&amp;rdquo; =&amp;gt;&amp;ldquo;。&amp;rdquo;或&amp;ldquo; link&amp;rdquo; =&amp;gt;&amp;ldquo; ..&amp;rdquo;）将被自动检测并忽略。</target>
        </trans-unit>
        <trans-unit id="b152fe7b18bfb7ca1bd752cf950491f1cf2f642f" translate="yes" xml:space="preserve">
          <source>When communicating over a bus, applications obtain what is called a &quot;service name&quot;: it is how that application chooses to be known by other applications on the same bus. The service names are brokered by the D-Bus bus daemon and are used to route messages from one application to another. An analogous concept to service names are IP addresses and hostnames: a computer normally has one IP address and may have one or more hostnames associated with it, according to the services that it provides to the network.</source>
          <target state="translated">当在总线上通信时,应用程序会获得所谓的 &quot;服务名&quot;:它是该应用程序选择被同一总线上的其他应用程序所知的方式。服务名由D-Bus总线守护程序代理,用于将消息从一个应用程序路由到另一个应用程序。与服务名类似的概念是IP地址和主机名:一台计算机通常有一个IP地址,根据它向网络提供的服务,它可能有一个或多个主机名。</target>
        </trans-unit>
        <trans-unit id="504bd4b97e16da478eebaa7d208820d715529e5e" translate="yes" xml:space="preserve">
          <source>When comparing floating-point types (&lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, and &lt;code&gt;qfloat16&lt;/code&gt;), &lt;a href=&quot;qtglobal#qFuzzyCompare&quot;&gt;qFuzzyCompare&lt;/a&gt;() is used for finite values. If &lt;a href=&quot;qtglobal#qFuzzyIsNull&quot;&gt;qFuzzyIsNull&lt;/a&gt;() is true for both values, they are also considered equal. Infinities match if they have the same sign, and any NaN as actual value matches with any NaN as expected value (even though NaN != NaN, even when they're identical).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ae6fe5944e7f5e553d8111bc79c5d3e6ba7dace" translate="yes" xml:space="preserve">
          <source>When complete is &lt;code&gt;true&lt;/code&gt;, any interactive items declared in &lt;code&gt;left&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt;, or &lt;code&gt;behind&lt;/code&gt; will receive mouse events.</source>
          <target state="translated">当完全是 &lt;code&gt;true&lt;/code&gt; ，任何交互式项目宣布 &lt;code&gt;left&lt;/code&gt; ， &lt;code&gt;right&lt;/code&gt; ，或 &lt;code&gt;behind&lt;/code&gt; 将会收到鼠标事件。</target>
        </trans-unit>
        <trans-unit id="fbdde588f2333734eac7dbf667c998b588ec285f" translate="yes" xml:space="preserve">
          <source>When configured with &lt;code&gt;-opengl dynamic&lt;/code&gt;, neither Qt nor the applications built using &lt;code&gt;qmake&lt;/code&gt; will link to the opengl32 (standard desktop OpenGL) or QtANGLE libraries. Instead, the appropriate library is chosen at runtime. By default, Qt will determine whether the system's opengl32.dll provides OpenGL 2 functions. If these are present, opengl32.dll is used, otherwise the ANGLE libraries (libEGL.dll and libGLESv2.dll) will be used. In case the ANGLE libraries are missing or initialization fails for some reason, an additional fallback is attempted by trying to load &lt;code&gt;opengl32sw.dll&lt;/code&gt;. See below for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1731f47b651e66fd70df77e065cbada56a586326" translate="yes" xml:space="preserve">
          <source>When conflicts arise, the widget's own style sheet is always preferred to any inherited style sheet, irrespective of the specificity of the conflicting rules. Likewise, the parent widget's style sheet is preferred to the grandparent's, etc.</source>
          <target state="translated">当冲突发生时,无论冲突规则的具体性如何,小组件自己的样式表总是优先于任何继承的样式表。同样,父部件的样式表也比祖部件的样式表优先,等等。</target>
        </trans-unit>
        <trans-unit id="0ee6235e959f1c122804e1ee8f220bac499a0e14" translate="yes" xml:space="preserve">
          <source>When connecting to an ODBC datasource, you should pass the name of the ODBC datasource to the &lt;a href=&quot;qsqldatabase#setDatabaseName&quot;&gt;QSqlDatabase::setDatabaseName&lt;/a&gt;() function, rather than the actual database name.</source>
          <target state="translated">连接到ODBC数据源时，应将ODBC数据源的名称传递给&lt;a href=&quot;qsqldatabase#setDatabaseName&quot;&gt;QSqlDatabase :: setDatabaseName&lt;/a&gt;（）函数，而不是实际的数据库名称。</target>
        </trans-unit>
        <trans-unit id="2f2cbe1c8aedff9ebebfb5ee6584df1a788d8183" translate="yes" xml:space="preserve">
          <source>When connecting to signals in QML, the usual way is to create an &quot;on&amp;lt;Signal&amp;gt;&quot; handler that reacts when a signal is received, like this:</source>
          <target state="translated">当连接到QML中的信号时，通常的方法是创建一个&amp;ldquo; on &amp;lt;Signal&amp;gt;&amp;rdquo;处理程序，该处理程序在接收到信号时做出反应，如下所示：</target>
        </trans-unit>
        <trans-unit id="50ad6900d430167293c28de8c15b55b92afdb96d" translate="yes" xml:space="preserve">
          <source>When considering the above example, there are several parties involved:</source>
          <target state="translated">在考虑上述例子时,涉及到几个方面。</target>
        </trans-unit>
        <trans-unit id="490cc9bd30b6bceb26457d2a8efbb90a6b3f5fe5" translate="yes" xml:space="preserve">
          <source>When control returns to the main event loop, all events that are stored in the queue will be sent using the &lt;a href=&quot;qcoreapplication#notify&quot;&gt;notify&lt;/a&gt;() function.</source>
          <target state="translated">当控制返回主事件循环时，将使用&lt;a href=&quot;qcoreapplication#notify&quot;&gt;notify&lt;/a&gt;（）函数发送队列中存储的所有事件。</target>
        </trans-unit>
        <trans-unit id="a617205988b57dea8c2826ac4ae64f29a514cd0a" translate="yes" xml:space="preserve">
          <source>When created or cleared, the line edit will be filled with a copy of the input mask string where the meta characters have been removed, and the mask characters have been replaced with the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aae57f52813e54337f9b3ba12b5d957d0e7706b" translate="yes" xml:space="preserve">
          <source>When creating a &lt;a href=&quot;qpagesize&quot;&gt;QPageSize&lt;/a&gt; using a custom &lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt; you can choose if you want &lt;a href=&quot;qpagesize&quot;&gt;QPageSize&lt;/a&gt; to try match the size to a standard page size. By default QPaperSize uses a &lt;a href=&quot;qpagesize#SizeMatchPolicy-enum&quot;&gt;FuzzyMatch&lt;/a&gt; mode where it will match a given page size to a standard page size if it falls within 3 postscript points of a defined standard size. You can override this to request only an exact match but this is not recommended as conversions between units can easily lose 3 points and result in incorrect page sizes.</source>
          <target state="translated">使用自定义&lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt;创建&lt;a href=&quot;qpagesize&quot;&gt;QPageSize时&lt;/a&gt;，可以选择是否希望&lt;a href=&quot;qpagesize&quot;&gt;QPageSize&lt;/a&gt;尝试将其大小与标准页面大小匹配。默认情况下，QPaperSize使用&lt;a href=&quot;qpagesize#SizeMatchPolicy-enum&quot;&gt;FuzzyMatch&lt;/a&gt;模式，如果它位于给定标准大小的3个后记点之内，它将匹配给定页面大小和标准页面大小。您可以覆盖此值以仅请求完全匹配，但是不建议您这样做，因为单元之间的转换很容易损失3点并导致不正确的页面尺寸。</target>
        </trans-unit>
        <trans-unit id="9ac98a689f6faf1b4d4a231d05990beaabb87945" translate="yes" xml:space="preserve">
          <source>When creating a &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; object, you must pass the name of your company or organization as well as the name of your application. For example, if your product is called Star Runner and your company is called MySoft, you would construct the &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; object as follows:</source>
          <target state="translated">创建&lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt;对象时，必须传递公司或组织的名称以及应用程序的名称。例如，如果您的产品称为Star Runner，而公司称为MySoft，则可以按以下方式构造&lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt;对象：</target>
        </trans-unit>
        <trans-unit id="acdb8c3cb9399aef996527a1d8f6a87298ec82bb" translate="yes" xml:space="preserve">
          <source>When creating a &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; to contain a URL from a &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; or a char*, always use &lt;a href=&quot;qstring#fromUtf8&quot;&gt;QString::fromUtf8&lt;/a&gt;().</source>
          <target state="translated">当创建&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;以包含来自&lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt;或char * 的URL时，请始终使用&lt;a href=&quot;qstring#fromUtf8&quot;&gt;QString :: fromUtf8&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="bbe42e39685b882db1d3c259aea5067777985606" translate="yes" xml:space="preserve">
          <source>When creating a QPageSize using a custom &lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt; you can choose if you want QPageSize to try match the size to a standard page size. By default QPaperSize uses a &lt;a href=&quot;qpagesize#SizeMatchPolicy-enum&quot;&gt;FuzzyMatch&lt;/a&gt; mode where it will match a given page size to a standard page size if it falls within 3 postscript points of a defined standard size. You can override this to request only an exact match but this is not recommended as conversions between units can easily lose 3 points and result in incorrect page sizes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f4afccd147883bbee26d5e202b95e0e3a068c0b" translate="yes" xml:space="preserve">
          <source>When creating a QSettings object, you must pass the name of your company or organization as well as the name of your application. For example, if your product is called Star Runner and your company is called MySoft, you would construct the QSettings object as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d773d0579d473100a4c07b005ea00f7960a8020" translate="yes" xml:space="preserve">
          <source>When creating a custom help viewer the viewer can be configured by writing a custom collection file which could contain various keywords to be used to configure the help engine. These keywords and values and their meaning can be found in the help information for &lt;a href=&quot;https://doc.qt.io/qt-5.13/assistant-custom-help-viewer.html&quot;&gt;creating a custom help collection file&lt;/a&gt; for Assistant.</source>
          <target state="translated">在创建自定义帮助查看器时，可以通过编写自定义收集文件来配置查看器，该文件可能包含用于配置帮助引擎的各种关键字。这些关键字和值及其含义可以在用于为Assistant &lt;a href=&quot;https://doc.qt.io/qt-5.13/assistant-custom-help-viewer.html&quot;&gt;创建自定义帮助收集文件&lt;/a&gt;的帮助信息中找到。</target>
        </trans-unit>
        <trans-unit id="ed02b2b618cca08d2bfb9bef8750c41344446144" translate="yes" xml:space="preserve">
          <source>When creating a custom help viewer the viewer can be configured by writing a custom collection file which could contain various keywords to be used to configure the help engine. These keywords and values and their meaning can be found in the help information for &lt;a href=&quot;https://doc.qt.io/qt-5.15/assistant-custom-help-viewer.html&quot;&gt;creating a custom help collection file&lt;/a&gt; for Assistant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65bcfdb381290d9bee6e16ff1d2353f984f24d0f" translate="yes" xml:space="preserve">
          <source>When creating a custom item, item coordinates are all you need to worry about; &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; and &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; will perform all transformations for you. This makes it very easy to implement custom items. For example, if you receive a mouse press or a drag enter event, the event position is given in item coordinates. The &lt;a href=&quot;qgraphicsitem#contains&quot;&gt;QGraphicsItem::contains&lt;/a&gt;() virtual function, which returns &lt;code&gt;true&lt;/code&gt; if a certain point is inside your item, and false otherwise, takes a point argument in item coordinates. Similarly, an item's bounding rect and shape are in item coordinates.</source>
          <target state="translated">创建自定义商品时，您只需要担心商品坐标；&lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt;和&lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt;将为您执行所有转换。这使得实现自定义项非常容易。例如，如果收到鼠标按下或拖动输入事件，则事件位置以项目坐标给出。该&lt;a href=&quot;qgraphicsitem#contains&quot;&gt;的QGraphicsItem ::包括&lt;/a&gt;（）虚函数，返回 &lt;code&gt;true&lt;/code&gt; ，如果某一个点就是你的项目里面，否则为false，需要在项目的坐标点的说法。类似地，项目的边界矩形和形状都在项目坐标中。</target>
        </trans-unit>
        <trans-unit id="9e08552b85a95188c1665a4dafe6b362ee82355f" translate="yes" xml:space="preserve">
          <source>When creating a map from sorted data inserting the largest key first with &lt;a href=&quot;qmap#constBegin&quot;&gt;constBegin&lt;/a&gt;() is faster than inserting in sorted order with &lt;a href=&quot;qmap#constEnd&quot;&gt;constEnd&lt;/a&gt;(), since &lt;a href=&quot;qmap#constEnd&quot;&gt;constEnd&lt;/a&gt;() - 1 (which is needed to check if the hint is valid) needs &lt;a href=&quot;containers#logarithmic-time&quot;&gt;logarithmic time&lt;/a&gt;.</source>
          <target state="translated">当创建从排序的数据与第一插入最大关键字的地图&lt;a href=&quot;qmap#constBegin&quot;&gt;constBegin&lt;/a&gt;（）比与以排序的顺序插入更快&lt;a href=&quot;qmap#constEnd&quot;&gt;constEnd&lt;/a&gt;（），因为&lt;a href=&quot;qmap#constEnd&quot;&gt;constEnd&lt;/a&gt;（） - 1（这是需要检查提示是有效的）需要&lt;a href=&quot;containers#logarithmic-time&quot;&gt;对数时间&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="da378fc2f1f498e22d7abb9c20072ff5f0d3d3c4" translate="yes" xml:space="preserve">
          <source>When creating a new model for an existing data structure, it is important to consider which type of model should be used to provide an interface onto the data. If the data structure can be represented as a list or table of items, you can subclass &lt;a href=&quot;qabstractlistmodel&quot;&gt;QAbstractListModel&lt;/a&gt; or &lt;a href=&quot;qabstracttablemodel&quot;&gt;QAbstractTableModel&lt;/a&gt; since these classes provide suitable default implementations for many functions.</source>
          <target state="translated">为现有数据结构创建新模型时，重要的是要考虑应使用哪种类型的模型来提供数据接口。如果数据结构可以表示为项目列表或表，则可以将&lt;a href=&quot;qabstractlistmodel&quot;&gt;QAbstractListModel&lt;/a&gt;或&lt;a href=&quot;qabstracttablemodel&quot;&gt;QAbstractTableModel&lt;/a&gt;子类化，因为这些类为许多功能提供了合适的默认实现。</target>
        </trans-unit>
        <trans-unit id="8500b569b9e4d2538da567830ca173bb7a100287" translate="yes" xml:space="preserve">
          <source>When creating a property binding from JavaScript, the &lt;code&gt;this&lt;/code&gt; keyword can be used to refer to the object which receives the binding. This is helpful for resolving ambiguities with property names.</source>
          <target state="translated">从JavaScript创建属性绑定时，可以使用 &lt;code&gt;this&lt;/code&gt; 关键字来引用接收绑定的对象。这有助于解决属性名称的歧义。</target>
        </trans-unit>
        <trans-unit id="a4acef9238768bf956778e2a447e1184f2109294" translate="yes" xml:space="preserve">
          <source>When creating an &lt;a href=&quot;qt3drender-qeffect&quot;&gt;QEffect&lt;/a&gt; that targets several versions of a graphics API, it is useful to create several &lt;a href=&quot;qt3drender-qtechnique&quot;&gt;QTechnique&lt;/a&gt; nodes each with a &lt;a href=&quot;qt3drender-qtechnique#graphicsApiFilter-prop&quot;&gt;graphicsApiFilter&lt;/a&gt; set to match one of the targeted GL versions. At runtime, the Qt3D renderer will select the most appropriate &lt;a href=&quot;qt3drender-qtechnique&quot;&gt;QTechnique&lt;/a&gt; based on which graphics API versions are supported and (if specified) the &lt;a href=&quot;qt3drender-qfilterkey&quot;&gt;QFilterKey&lt;/a&gt; nodes that satisfy a given &lt;a href=&quot;qt3drender-qtechniquefilter&quot;&gt;QTechniqueFilter&lt;/a&gt; in the FrameGraph.</source>
          <target state="translated">创建针对多个图形API版本的&lt;a href=&quot;qt3drender-qeffect&quot;&gt;QEffect时&lt;/a&gt;，创建多个&lt;a href=&quot;qt3drender-qtechnique&quot;&gt;QTechnique&lt;/a&gt;节点很有用，每个节点都设置了&lt;a href=&quot;qt3drender-qtechnique#graphicsApiFilter-prop&quot;&gt;graphicsApiFilter&lt;/a&gt;来匹配目标GL版本之一。在运行时，Qt3D渲染器将选择最合适的&lt;a href=&quot;qt3drender-qtechnique&quot;&gt;QTechnique&lt;/a&gt;在此基础上的图形API版本的支持和（如果指定）&lt;a href=&quot;qt3drender-qfilterkey&quot;&gt;QFilterKey&lt;/a&gt;满足给定节点&lt;a href=&quot;qt3drender-qtechniquefilter&quot;&gt;QTechniqueFilter&lt;/a&gt;在FrameGraph。</target>
        </trans-unit>
        <trans-unit id="74fe2d261fd9daef09d6ad1cf9640099d84a6e3f" translate="yes" xml:space="preserve">
          <source>When creating an &lt;a href=&quot;qt3drender-qeffect&quot;&gt;QEffect&lt;/a&gt; that targets several versions of a graphics API, it is useful to create several QTechnique nodes each with a &lt;a href=&quot;qt3drender-qtechnique#graphicsApiFilter-prop&quot;&gt;graphicsApiFilter&lt;/a&gt; set to match one of the targeted GL versions. At runtime, the Qt3D renderer will select the most appropriate QTechnique based on which graphics API versions are supported and (if specified) the &lt;a href=&quot;qt3drender-qfilterkey&quot;&gt;QFilterKey&lt;/a&gt; nodes that satisfy a given &lt;a href=&quot;qt3drender-qtechniquefilter&quot;&gt;QTechniqueFilter&lt;/a&gt; in the FrameGraph.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd5a5c9f752ad47937d6434e44c62e97758c6944" translate="yes" xml:space="preserve">
          <source>When creating an Effect that targets several versions of a graphics API, it is useful to create several Technique nodes each with a &lt;a href=&quot;qml-qt3d-render-technique#graphicsApiFilter-prop&quot;&gt;graphicsApiFilter&lt;/a&gt; set to match one of the targeted versions. At runtime, the Qt3D renderer will select the most appropriate Technique based on which graphics API versions are supported and (if specified) the &lt;a href=&quot;qml-qt3d-render-filterkey&quot;&gt;FilterKey&lt;/a&gt; nodes that satisfy a given &lt;a href=&quot;qml-qt3d-render-techniquefilter&quot;&gt;TechniqueFilter&lt;/a&gt; in the FrameGraph.</source>
          <target state="translated">创建针对图形API多个版本的效果时，创建多个Technique节点非常有用，每个节点都设置了&lt;a href=&quot;qml-qt3d-render-technique#graphicsApiFilter-prop&quot;&gt;graphicsApiFilter&lt;/a&gt;来匹配目标版本之一。在运行时，Qt3D渲染器将根据选择最合适的技术在其上的图形API版本的支持和（如果指定）&lt;a href=&quot;qml-qt3d-render-filterkey&quot;&gt;FilterKey&lt;/a&gt;满足给定节点&lt;a href=&quot;qml-qt3d-render-techniquefilter&quot;&gt;TechniqueFilter&lt;/a&gt;在FrameGraph。</target>
        </trans-unit>
        <trans-unit id="f722c75ee9a2de387fc8f2d451fedcecaaa57d68" translate="yes" xml:space="preserve">
          <source>When creating custom items, use the new &lt;a href=&quot;qsgrectanglenode&quot;&gt;QSGRectangleNode&lt;/a&gt; and &lt;a href=&quot;qsgimagenode&quot;&gt;QSGImageNode&lt;/a&gt; classes. These replace the now deprecated QSGSimpleRectNode and QSGSimpleTextureNode. Unlike their predecessors, these new classes are interfaces, and implementations are created via the &lt;a href=&quot;qquickwindow#createRectangleNode&quot;&gt;QQuickWindow::createRectangleNode&lt;/a&gt;() and &lt;a href=&quot;qquickwindow#createImageNode&quot;&gt;QQuickWindow::createImageNode&lt;/a&gt;() factory functions.</source>
          <target state="translated">创建自定义项目时，请使用新的&lt;a href=&quot;qsgrectanglenode&quot;&gt;QSGRectangleNode&lt;/a&gt;和&lt;a href=&quot;qsgimagenode&quot;&gt;QSGImageNode&lt;/a&gt;类。这些替代了现在不推荐使用的QSGSimpleRectNode和QSGSimpleTextureNode。与它们的前辈不同，这些新类是接口，并且实现是通过&lt;a href=&quot;qquickwindow#createRectangleNode&quot;&gt;QQuickWindow :: createRectangleNode&lt;/a&gt;（）和&lt;a href=&quot;qquickwindow#createImageNode&quot;&gt;QQuickWindow :: createImageNode&lt;/a&gt;（）工厂函数创建的。</target>
        </trans-unit>
        <trans-unit id="ad1ca55154d7a13bb0a82b3ada46b98f3f2fa71a" translate="yes" xml:space="preserve">
          <source>When creating textures via C++ scene graph APIs like &lt;a href=&quot;qquickwindow#createTextureFromImage&quot;&gt;QQuickWindow::createTextureFromImage&lt;/a&gt;(), 32-bit formats won't involve any conversion, they'll map directly to the corresponding &lt;code&gt;R8G8B8A8_UNORM&lt;/code&gt; or &lt;code&gt;B8G8R8A8_UNORM&lt;/code&gt; format. Everything else will trigger a &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt;-based format conversion on the CPU first.</source>
          <target state="translated">通过诸如&lt;a href=&quot;qquickwindow#createTextureFromImage&quot;&gt;QQuickWindow :: createTextureFromImage&lt;/a&gt;（）之类的C ++场景图API创建纹理时，32位格式不涉及任何转换，它们将直接映射到相应的 &lt;code&gt;R8G8B8A8_UNORM&lt;/code&gt; 或 &lt;code&gt;B8G8R8A8_UNORM&lt;/code&gt; 格式。其他所有操作都会首先在CPU上触发基于&lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt;的格式转换。</target>
        </trans-unit>
        <trans-unit id="ac8c6318f0656d7823865940204d8f34b4f9e2dc" translate="yes" xml:space="preserve">
          <source>When creating user interfaces with Qt, particularly those with specialized controls and features, developers sometimes need to create new data types that can be used alongside or in place of Qt's existing set of value types.</source>
          <target state="translated">当使用Qt创建用户界面时,特别是那些具有特殊控件和功能的用户界面,开发人员有时需要创建新的数据类型,这些数据类型可以与Qt现有的值类型集一起使用,或者代替Qt现有的值类型集。</target>
        </trans-unit>
        <trans-unit id="7c5cad017177801067fb33fec32abbde43a2a0a2" translate="yes" xml:space="preserve">
          <source>When creating visual scenes with Qt Quick, it is important to understand the concept of the</source>
          <target state="translated">在使用Qt Quick创建可视化场景时,必须要了解Qt Quick的概念。</target>
        </trans-unit>
        <trans-unit id="d8deccb0e684f6ccb3eb82d7b6672c38b9e7d190" translate="yes" xml:space="preserve">
          <source>When data is transferred from C++ to QML, the ownership of the data always remains with C++. The exception to this rule is when a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; is returned from an explicit C++ method call: in this case, the QML engine assumes ownership of the object, unless the ownership of the object has explicitly been set to remain with C++ by invoking &lt;a href=&quot;qqmlengine#setObjectOwnership&quot;&gt;QQmlEngine::setObjectOwnership&lt;/a&gt;() with &lt;a href=&quot;qqmlengine#ObjectOwnership-enum&quot;&gt;QQmlEngine::CppOwnership&lt;/a&gt; specified.</source>
          <target state="translated">当数据从C ++传输到QML时，数据所有权始终由C ++保留。该规则的例外情况是从显式C ++方法调用返回&lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;时：在这种情况下，除非通过调用&lt;a href=&quot;qqmlengine#setObjectOwnership&quot;&gt;QQmlEngine&lt;/a&gt;将对象的所有权显式设置为与C ++一起使用，否则QML引擎将假定该对象的所有权：使用&lt;a href=&quot;qqmlengine#ObjectOwnership-enum&quot;&gt;QQmlEngine :: CppOwnership&lt;/a&gt;指定的setObjectOwnership（）。</target>
        </trans-unit>
        <trans-unit id="833825b15200463ac0253e002ab1f7246eda7871" translate="yes" xml:space="preserve">
          <source>When data values are exchanged between QML and C++, they are converted by the QML engine to have the correct data types as appropriate for use in QML or C++. This requires the exchanged data to be of a type that is recognizable by the engine.</source>
          <target state="translated">当QML和C++之间交换数据值时,QML引擎会将其转换为适合在QML或C++中使用的正确数据类型。这就要求交换的数据必须是引擎可以识别的类型。</target>
        </trans-unit>
        <trans-unit id="88de44478b8ed2bd120794db0b7d5b455c64de25" translate="yes" xml:space="preserve">
          <source>When dealing with shared objects, there are two ways of copying an object. We usually speak about</source>
          <target state="translated">在处理共享对象时,有两种方式可以复制对象。我们通常说的是</target>
        </trans-unit>
        <trans-unit id="880f2e372d228c68b46fdc809205b92833a51398" translate="yes" xml:space="preserve">
          <source>When dealing with the D-Bus bus service or with remote applications over D-Bus, a number of error conditions can happen. This error conditions are sometimes signalled by a returned error value or by a &lt;a href=&quot;qdbuserror&quot;&gt;QDBusError&lt;/a&gt;.</source>
          <target state="translated">在处理D-Bus总线服务或通过D-Bus进行远程应用程序时，可能会发生许多错误情况。有时通过返回的错误值或&lt;a href=&quot;qdbuserror&quot;&gt;QDBusError&lt;/a&gt;发出此错误情况的信号。</target>
        </trans-unit>
        <trans-unit id="74f0ca37c9cc12fbb98f9f5310dd3caadcb27473" translate="yes" xml:space="preserve">
          <source>When dealing with the D-Bus bus service or with remote applications over D-Bus, a number of error conditions can happen. This error conditions are sometimes signalled by a returned error value or by a QDBusError.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37e1660403429a1797eb4c0aeb989abc574ce656" translate="yes" xml:space="preserve">
          <source>When declaring properties in QML, it's easy and convenient to use the &quot;var&quot; type:</source>
          <target state="translated">在QML中声明属性时,使用 &quot;var &quot;类型很简单方便。</target>
        </trans-unit>
        <trans-unit id="499464bd993035896d274262364a35979c761cc8" translate="yes" xml:space="preserve">
          <source>When decoding Base64-encoded data, ignores errors in the input; invalid characters are simply skipped. This enum value has been added in Qt 5.15.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee82abeedacfd233e0f6aece53f4beda554b1af8" translate="yes" xml:space="preserve">
          <source>When decoding Base64-encoded data, stops at the first decoding error. This enum value has been added in Qt 5.15.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6c7b9b1412f471c238127a4b55f7698c8fb1c87" translate="yes" xml:space="preserve">
          <source>When defining your own needle component, the only properties that the style requires you to set are the &lt;a href=&quot;qml-qtquick-item#implicitWidth-prop&quot;&gt;implicitWidth&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-item#implicitHeight-prop&quot;&gt;implicitHeight&lt;/a&gt;.</source>
          <target state="translated">定义自己的针组件时，样式要求您设置的唯一属性是&lt;a href=&quot;qml-qtquick-item#implicitWidth-prop&quot;&gt;implicitWidth&lt;/a&gt;和&lt;a href=&quot;qml-qtquick-item#implicitHeight-prop&quot;&gt;implicitHeight&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a11f2000ac0edf67c2b20ae00acff6fb70863dbe" translate="yes" xml:space="preserve">
          <source>When deploying Qt applications built using Visual Studio 2005, or later, make sure that the manifest file that was created when the application was linked is handled correctly. This is handled automatically for projects that generate DLLs.</source>
          <target state="translated">当部署使用Visual Studio 2005或更高版本构建的Qt应用程序时,请确保正确处理应用程序链接时创建的清单文件。对于生成DLLs的项目,会自动处理这个文件。</target>
        </trans-unit>
        <trans-unit id="e3f2fc2611c302aed3276f1510a9d174ba6db392" translate="yes" xml:space="preserve">
          <source>When deploying the app, the compression is typically handled on the server side. We recommend to compress the wasm binaries because this typically reduces the size of the binary by 50 %.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc8ea9ac8ca6cf4cf6b3b5f4d012ccb4493d9e28" translate="yes" xml:space="preserve">
          <source>When developing applications that use D-Bus, it is sometimes useful to be able to see information about the messages that are sent and received across the bus by each application.</source>
          <target state="translated">在开发使用D-Bus的应用程序时,有时能够看到每个应用程序在总线上发送和接收的消息的信息是很有用的。</target>
        </trans-unit>
        <trans-unit id="1a1c1be356204dfd455ba7ec0d01e973b146ec67" translate="yes" xml:space="preserve">
          <source>When disabled, a &lt;a href=&quot;qml-qt3d-render-nodraw&quot;&gt;NoDraw&lt;/a&gt; node won't prevent the scene from being rendered. Toggling the enabled property is therefore a way to make a &lt;a href=&quot;qml-qt3d-render-nodraw&quot;&gt;NoDraw&lt;/a&gt; active or inactive.</source>
          <target state="translated">禁用后，&lt;a href=&quot;qml-qt3d-render-nodraw&quot;&gt;NoDraw&lt;/a&gt;节点不会阻止场景的渲染。因此，切换enabled属性是使&lt;a href=&quot;qml-qt3d-render-nodraw&quot;&gt;NoDraw&lt;/a&gt;处于活动状态或非活动状态的一种方法。</target>
        </trans-unit>
        <trans-unit id="857e0ffe6bd1478d0544df44c2c658d65e015926" translate="yes" xml:space="preserve">
          <source>When disabled, a &lt;a href=&quot;qt3drender-qnodraw&quot;&gt;Qt3DRender::QNoDraw&lt;/a&gt; node won't prevent the scene from being rendered. Toggling the enabled property is therefore a way to make a &lt;a href=&quot;qt3drender-qnodraw&quot;&gt;Qt3DRender::QNoDraw&lt;/a&gt; active or inactive.</source>
          <target state="translated">禁用后，&lt;a href=&quot;qt3drender-qnodraw&quot;&gt;Qt3DRender :: QNoDraw&lt;/a&gt;节点不会阻止场景的渲染。因此，切换enabled属性是使&lt;a href=&quot;qt3drender-qnodraw&quot;&gt;Qt3DRender :: QNoDraw&lt;/a&gt;处于活动状态或非活动状态的一种方法。</target>
        </trans-unit>
        <trans-unit id="a705f9e79dc5e0d4da74710091ca3394fb3c8ff6" translate="yes" xml:space="preserve">
          <source>When disabled, a &lt;a href=&quot;qt3drender-qnopicking&quot;&gt;Qt3DRender::QNoPicking&lt;/a&gt; node won't prevent picking from being performed. Toggling the enabled property is therefore a way to make a &lt;a href=&quot;qt3drender-qnopicking&quot;&gt;Qt3DRender::QNoPicking&lt;/a&gt; active or inactive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c03a7230ca07cd92ed1e2c5c76edb68253bdb253" translate="yes" xml:space="preserve">
          <source>When disabled, a NoDraw node won't prevent the scene from being rendered. Toggling the enabled property is therefore a way to make a NoDraw active or inactive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e738f36ac893e8cd586e71209d223aa4927c0d5" translate="yes" xml:space="preserve">
          <source>When disabled, a NoPicking node won't prevent picking from being performed. Toggling the enabled property is therefore a way to make a NoPicking active or inactive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="382c790d1bb1d0cf3f278efbd5066d3785f4f5c9" translate="yes" xml:space="preserve">
          <source>When disabled, the &lt;a href=&quot;qml-qtquick3d-sceneenvironment#depthTestEnabled-prop&quot;&gt;depthTestEnabled&lt;/a&gt; property can be used to simultaneously override depth testing and the order of rendering the objects. The operation of this property is not as obvious as many of the other properties in the system so this page offers some insight into when, where, and why this property can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc1e687319c686b682a905da3e6616cd03084a73" translate="yes" xml:space="preserve">
          <source>When disabled, the normals on the surface are interpolated making the edges look round. When enabled, the normals are kept the same on a triangle making the color of the triangle solid. This makes the data more readable from the model.</source>
          <target state="translated">禁用时,曲面上的法线会被插值,使边缘看起来很圆。启用时,三角形上的法线保持不变,使三角形的颜色变成纯色。这使得数据在模型中更易读。</target>
        </trans-unit>
        <trans-unit id="24f4c0f2f49fed31d9cd8577cea9ab05b39be5e3" translate="yes" xml:space="preserve">
          <source>When displaying data from models in Qt item views, e.g., a &lt;a href=&quot;qtableview&quot;&gt;QTableView&lt;/a&gt;, the individual items are drawn by a delegate. Also, when an item is edited, it provides an editor widget, which is placed on top of the item view while editing takes place. &lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate&lt;/a&gt; is the default delegate for all Qt item views, and is installed upon them when they are created.</source>
          <target state="translated">当在Qt项目视图（例如&lt;a href=&quot;qtableview&quot;&gt;QTableView）中&lt;/a&gt;显示来自模型的数据时，单个项目由委托绘制。同样，在编辑项目时，它会提供一个编辑器小部件，在进行编辑时，该小部件将置于项目视图的顶部。&lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate&lt;/a&gt;是所有Qt项目视图的默认委托，并在创建它们时安装在它们上。</target>
        </trans-unit>
        <trans-unit id="e6e55cf5ea63dc5db3857d7ad604b687dae8d030" translate="yes" xml:space="preserve">
          <source>When displaying data from models in Qt item views, e.g., a &lt;a href=&quot;qtableview&quot;&gt;QTableView&lt;/a&gt;, the individual items are drawn by a delegate. Also, when an item is edited, it provides an editor widget, which is placed on top of the item view while editing takes place. QStyledItemDelegate is the default delegate for all Qt item views, and is installed upon them when they are created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0352c49318cb9d0b30ba555050217480183cb03e" translate="yes" xml:space="preserve">
          <source>When displaying items from a custom model in a standard view, it is often sufficient to simply ensure that the model returns appropriate data for each of the &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;roles&lt;/a&gt; that determine the appearance of items in views. The default delegate used by Qt's standard views uses this role information to display items in most of the common forms expected by users. However, it is sometimes necessary to have even more control over the appearance of items than the default delegate can provide.</source>
          <target state="translated">在标准视图中显示来自自定义模型的项目时，仅确保模型为确定视图中项目外观的每个&lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;角色&lt;/a&gt;返回适当的数据通常就足够了。 Qt标准视图使用的默认委托使用此角色信息以用户期望的大多数常见形式显示项目。但是，有时有必要对项目的外观进行更多控制，而不是默认委托可以提供的控制。</target>
        </trans-unit>
        <trans-unit id="159720c88af83f5ac94a174365550a72f0765067" translate="yes" xml:space="preserve">
          <source>When documenting a QML type in a</source>
          <target state="translated">当把一个QML类型记录在</target>
        </trans-unit>
        <trans-unit id="b7e55292b4abae3e9e4e7263b6533ed85abbb41e" translate="yes" xml:space="preserve">
          <source>When documenting a QML type in the</source>
          <target state="translated">当在</target>
        </trans-unit>
        <trans-unit id="fd4be1f4d3d4fe684047540a2b498b3e14a564e5" translate="yes" xml:space="preserve">
          <source>When doing replacement the area of the preedit string is ignored, thus a replacement starting at -1 with a length of 2 will remove the last character before the preedit string and the first character afterwards, and insert the commit string directly before the preedit string.</source>
          <target state="translated">在进行替换时,会忽略preedit字符串的区域,因此从-1开始,长度为2的替换会删除preedit字符串前的最后一个字符和后面的第一个字符,并直接在preedit字符串前插入提交字符串。</target>
        </trans-unit>
        <trans-unit id="7b591bbff5ab07d40d7612a73ab5fcdc537e41fa" translate="yes" xml:space="preserve">
          <source>When doubleclicking an item, the item will first receive a mouse press event, followed by a release event (i.e., a click), then a doubleclick event, and finally a release event.</source>
          <target state="translated">当双击一个项目时,该项目将首先收到鼠标按下事件,然后是释放事件(即点击),然后是双击事件,最后是释放事件。</target>
        </trans-unit>
        <trans-unit id="a02484f5ce286a79ae6a871b9106f5799cb1d5dc" translate="yes" xml:space="preserve">
          <source>When dragging the titlebar of a dock, all the tabs that are tabbed with it are going to be dragged. Implies AllowTabbedDocks. Does not work well if some QDockWidgets have restrictions in which area they are allowed. (This enum value was added in Qt 5.6.)</source>
          <target state="translated">当拖动dock的标题栏时,所有与之相关的标签页都会被拖动。意味着AllowTabbedDocks。如果某些QDockWidgets有限制在哪些区域允许拖动,则效果不好。(这个枚举值是在Qt 5.6中添加的。)</target>
        </trans-unit>
        <trans-unit id="19649a7c3fc63002d50d3cb1460af355d223d55e" translate="yes" xml:space="preserve">
          <source>When drawStaticText() is called, the layout of the &lt;a href=&quot;qstatictext&quot;&gt;QStaticText&lt;/a&gt; will be recalculated if any part of the &lt;a href=&quot;qstatictext&quot;&gt;QStaticText&lt;/a&gt; object has changed since the last time it was drawn. It will also be recalculated if the painter's font is not the same as when the &lt;a href=&quot;qstatictext&quot;&gt;QStaticText&lt;/a&gt; was last drawn, or, on any other paint engine than the OpenGL2 engine, if the painter's matrix has been altered since the static text was last drawn.</source>
          <target state="translated">调用drawStaticText（）时，如果自上次绘制以来，&lt;a href=&quot;qstatictext&quot;&gt;QStaticText&lt;/a&gt;对象的任何部分发生更改，则将重新计算&lt;a href=&quot;qstatictext&quot;&gt;QStaticText&lt;/a&gt;的布局。如果绘画者的字体与上次绘制&lt;a href=&quot;qstatictext&quot;&gt;QStaticText&lt;/a&gt;时的字体不同，或者在自上次绘制静态文本以来改变了绘画者的矩阵，或者在除OpenGL2引擎之外的任何其他绘画引擎上，也将重新计算。</target>
        </trans-unit>
        <trans-unit id="bb13eb36af2066f03f57ae49bb001cd98eedd84c" translate="yes" xml:space="preserve">
          <source>When drawing text, the font is specified using the &lt;a href=&quot;qfont&quot;&gt;QFont&lt;/a&gt; class. Qt will use the font with the specified attributes, or if no matching font exists, Qt will use the closest matching installed font. The attributes of the font that is actually used can be retrieved using the &lt;a href=&quot;qfontinfo&quot;&gt;QFontInfo&lt;/a&gt; class. In addition, the &lt;a href=&quot;qfontmetrics&quot;&gt;QFontMetrics&lt;/a&gt; class provides the font measurements, and the &lt;a href=&quot;qfontdatabase&quot;&gt;QFontDatabase&lt;/a&gt; class provides information about the fonts available in the underlying window system.</source>
          <target state="translated">绘制文本时，使用&lt;a href=&quot;qfont&quot;&gt;QFont&lt;/a&gt;类指定字体。Qt将使用具有指定属性的字体，或者如果不存在匹配的字体，则Qt将使用最接近的匹配安装字体。可以使用&lt;a href=&quot;qfontinfo&quot;&gt;QFontInfo&lt;/a&gt;类来检索实际使用的字体的属性。此外，&lt;a href=&quot;qfontmetrics&quot;&gt;QFontMetrics&lt;/a&gt;类提供字体测量，而&lt;a href=&quot;qfontdatabase&quot;&gt;QFontDatabase&lt;/a&gt;类提供有关基础窗口系统中可用字体的信息。</target>
        </trans-unit>
        <trans-unit id="2b8fa7bd4261a029b6f3fdf343d1e4a3de0c8942" translate="yes" xml:space="preserve">
          <source>When drawing with &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;, we specify points using logical coordinates which then are converted into the physical coordinates of the paint device.</source>
          <target state="translated">使用&lt;a href=&quot;qpainter&quot;&gt;QPainter进行&lt;/a&gt;绘制时，我们使用逻辑坐标指定点，然后将其转换为绘画设备的物理坐标。</target>
        </trans-unit>
        <trans-unit id="410e5ecacd6f13933f5b02a517c03bf075b15730" translate="yes" xml:space="preserve">
          <source>When drawing with &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;, we specify points using logical coordinates which then are converted into the physical coordinates of the paint device. The mapping of the logical coordinates to the physical coordinates are handled by &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;'s &lt;a href=&quot;qpainter#combinedTransform&quot;&gt;combinedTransform&lt;/a&gt;(), a combination of &lt;a href=&quot;qpainter#viewport&quot;&gt;viewport&lt;/a&gt;() and &lt;a href=&quot;qpainter#window&quot;&gt;window&lt;/a&gt;() and &lt;a href=&quot;qpainter#worldTransform&quot;&gt;worldTransform&lt;/a&gt;(). The &lt;a href=&quot;qpainter#viewport&quot;&gt;viewport&lt;/a&gt;() represents the physical coordinates specifying an arbitrary rectangle, the &lt;a href=&quot;qpainter#window&quot;&gt;window&lt;/a&gt;() describes the same rectangle in logical coordinates, and the &lt;a href=&quot;qpainter#worldTransform&quot;&gt;worldTransform&lt;/a&gt;() is identical with the transformation matrix.</source>
          <target state="translated">使用&lt;a href=&quot;qpainter&quot;&gt;QPainter进行&lt;/a&gt;绘制时，我们使用逻辑坐标指定点，然后将其转换为绘画设备的物理坐标。逻辑坐标到物理坐标的映射由&lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;的&lt;a href=&quot;qpainter#combinedTransform&quot;&gt;CombinedTransform&lt;/a&gt;（），&lt;a href=&quot;qpainter#viewport&quot;&gt;viewport&lt;/a&gt;（）和&lt;a href=&quot;qpainter#window&quot;&gt;window&lt;/a&gt;（）以及&lt;a href=&quot;qpainter#worldTransform&quot;&gt;worldTransform&lt;/a&gt;（）的组合处理。该&lt;a href=&quot;qpainter#viewport&quot;&gt;视口&lt;/a&gt;（）表示指定任意矩形的物理坐标，所述&lt;a href=&quot;qpainter#window&quot;&gt;窗口&lt;/a&gt;（）描述了在逻辑坐标相同的矩形，并且&lt;a href=&quot;qpainter#worldTransform&quot;&gt;worldTransform&lt;/a&gt;（）是与所述变换矩阵是相同的。</target>
        </trans-unit>
        <trans-unit id="fa068ff4a5704af2221f41b1b4da90e1a41df12c" translate="yes" xml:space="preserve">
          <source>When drawing with QPainter, we specify points using logical coordinates which then are converted into the physical coordinates of the paint device. The mapping of the logical coordinates to the physical coordinates are handled by QPainter's &lt;a href=&quot;qpainter#combinedTransform&quot;&gt;combinedTransform&lt;/a&gt;(), a combination of &lt;a href=&quot;qpainter#viewport&quot;&gt;viewport&lt;/a&gt;() and &lt;a href=&quot;qpainter#window&quot;&gt;window&lt;/a&gt;() and &lt;a href=&quot;qpainter#worldTransform&quot;&gt;worldTransform&lt;/a&gt;(). The &lt;a href=&quot;qpainter#viewport&quot;&gt;viewport&lt;/a&gt;() represents the physical coordinates specifying an arbitrary rectangle, the &lt;a href=&quot;qpainter#window&quot;&gt;window&lt;/a&gt;() describes the same rectangle in logical coordinates, and the &lt;a href=&quot;qpainter#worldTransform&quot;&gt;worldTransform&lt;/a&gt;() is identical with the transformation matrix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5ed330ed405cc570c36b8d34b32b0e9f282124b" translate="yes" xml:space="preserve">
          <source>When drawing, the pixel rendering is controlled by the &lt;a href=&quot;qpainter#RenderHint-enum&quot;&gt;QPainter::Antialiasing&lt;/a&gt; render hint.</source>
          <target state="translated">绘制时，像素渲染由&lt;a href=&quot;qpainter#RenderHint-enum&quot;&gt;QPainter :: Antialiasing&lt;/a&gt;渲染提示控制。</target>
        </trans-unit>
        <trans-unit id="d15b0d71322e99bde4953dbe90c85c3ef7baf9a0" translate="yes" xml:space="preserve">
          <source>When drawing, the pixel rendering is controlled by the &lt;a href=&quot;qpainter#RenderHint-enum&quot;&gt;QPainter::Antialiasing&lt;/a&gt; render hint. The &lt;a href=&quot;qpainter#RenderHint-enum&quot;&gt;QPainter::RenderHint&lt;/a&gt; enum is used to specify flags to &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; that may or may not be respected by any given engine.</source>
          <target state="translated">绘制时，像素渲染由&lt;a href=&quot;qpainter#RenderHint-enum&quot;&gt;QPainter :: Antialiasing&lt;/a&gt;渲染提示控制。该&lt;a href=&quot;qpainter#RenderHint-enum&quot;&gt;QPainter的:: RenderHint&lt;/a&gt;枚举用于指定标志来&lt;a href=&quot;qpainter&quot;&gt;了QPainter&lt;/a&gt;可能会或可能不会被任何给定的发动机尊重。</target>
        </trans-unit>
        <trans-unit id="6ebdf8b96fea44b5a3aed78415b3fda3d62aa0c1" translate="yes" xml:space="preserve">
          <source>When driving animations, this function should be called once after drawing has completed. Calling this function multiple times will result in a single event being delivered to the window.</source>
          <target state="translated">当驱动动画时,该函数应在绘制完成后调用一次。多次调用此函数将导致一个事件被传递到窗口。</target>
        </trans-unit>
        <trans-unit id="1ce5dba37bb8921ab742160f013368e5f3259059" translate="yes" xml:space="preserve">
          <source>When duplicate skipping is enabled, successive readings with the same or very similar values are omitted. This helps reducing the amount of processing done, as less sensor readings are made available. As a consequence, readings arrive at an irregular interval.</source>
          <target state="translated">当启用重复跳过时,具有相同或非常相似值的连续读数将被省略。这有助于减少处理量,因为可用的传感器读数较少。因此,读数会以不规则的间隔到达。</target>
        </trans-unit>
        <trans-unit id="d5e3a8786c0102ae5523b4a9dad7cca51f61d1c8" translate="yes" xml:space="preserve">
          <source>When each primitive is large, this overhead is negligible, but in the case of a typical UI, there are many small items which add up to a considerable overhead.</source>
          <target state="translated">当每个基元都很大的时候,这个开销可以忽略不计,但是在典型的UI中,有很多小项会增加相当大的开销。</target>
        </trans-unit>
        <trans-unit id="cbc38d0da8ee345ba2fd00eef535419aae91f344" translate="yes" xml:space="preserve">
          <source>When editing data in an item view, &lt;a href=&quot;qitemdelegate&quot;&gt;QItemDelegate&lt;/a&gt; provides an editor widget, which is a widget that is placed on top of the view while editing takes place. Editors are created with a &lt;a href=&quot;qitemeditorfactory&quot;&gt;QItemEditorFactory&lt;/a&gt;; a default static instance provided by &lt;a href=&quot;qitemeditorfactory&quot;&gt;QItemEditorFactory&lt;/a&gt; is installed on all item delegates. You can set a custom factory using &lt;a href=&quot;qitemdelegate#setItemEditorFactory&quot;&gt;setItemEditorFactory&lt;/a&gt;() or set a new default factory with &lt;a href=&quot;qitemeditorfactory#setDefaultFactory&quot;&gt;QItemEditorFactory::setDefaultFactory&lt;/a&gt;(). It is the data stored in the item model with the &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;Qt::EditRole&lt;/a&gt; that is edited.</source>
          <target state="translated">在项目视图中编辑数据时，&lt;a href=&quot;qitemdelegate&quot;&gt;QItemDelegate&lt;/a&gt;提供了一个编辑器窗口小部件，该窗口小部件是在进行编辑时置于视图顶部的窗口小部件。使用&lt;a href=&quot;qitemeditorfactory&quot;&gt;QItemEditorFactory&lt;/a&gt;创建编辑器；由&lt;a href=&quot;qitemeditorfactory&quot;&gt;QItemEditorFactory&lt;/a&gt;提供的默认静态实例安装在所有项目委托上。您可以使用&lt;a href=&quot;qitemdelegate#setItemEditorFactory&quot;&gt;setItemEditorFactory&lt;/a&gt;（）设置自定义工厂，也可以使用&lt;a href=&quot;qitemeditorfactory#setDefaultFactory&quot;&gt;QItemEditorFactory :: setDefaultFactory&lt;/a&gt;（）设置新的默认工厂。使用&lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;Qt :: EditRole&lt;/a&gt;编辑的是存储在项目模型中的数据。</target>
        </trans-unit>
        <trans-unit id="e3121493bb1879d53220fddb4bd4e0247d179ffd" translate="yes" xml:space="preserve">
          <source>When editing data in an item view, QItemDelegate provides an editor widget, which is a widget that is placed on top of the view while editing takes place. Editors are created with a &lt;a href=&quot;qitemeditorfactory&quot;&gt;QItemEditorFactory&lt;/a&gt;; a default static instance provided by &lt;a href=&quot;qitemeditorfactory&quot;&gt;QItemEditorFactory&lt;/a&gt; is installed on all item delegates. You can set a custom factory using &lt;a href=&quot;qitemdelegate#setItemEditorFactory&quot;&gt;setItemEditorFactory&lt;/a&gt;() or set a new default factory with &lt;a href=&quot;qitemeditorfactory#setDefaultFactory&quot;&gt;QItemEditorFactory::setDefaultFactory&lt;/a&gt;(). It is the data stored in the item model with the &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;Qt::EditRole&lt;/a&gt; that is edited.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f6344a0186d030dc605de997efbebf65f1b9a99" translate="yes" xml:space="preserve">
          <source>When editing data in an item view, editors are created and displayed by a delegate. &lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate&lt;/a&gt;, which is the delegate by default installed on Qt's item views, uses a &lt;a href=&quot;qitemeditorfactory&quot;&gt;QItemEditorFactory&lt;/a&gt; to create editors for it. A default unique instance provided by &lt;a href=&quot;qitemeditorfactory&quot;&gt;QItemEditorFactory&lt;/a&gt; is used by all item delegates. If you set a new default factory with &lt;a href=&quot;qitemeditorfactory#setDefaultFactory&quot;&gt;setDefaultFactory&lt;/a&gt;(), the new factory will be used by existing and new delegates.</source>
          <target state="translated">在项目视图中编辑数据时，将由委托创建并显示编辑器。&lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate&lt;/a&gt;是默认安装在Qt的项目视图上的委托，它使用&lt;a href=&quot;qitemeditorfactory&quot;&gt;QItemEditorFactory&lt;/a&gt;为其创建编辑器。所有项目委托都使用&lt;a href=&quot;qitemeditorfactory&quot;&gt;QItemEditorFactory&lt;/a&gt;提供的默认唯一实例。如果使用&lt;a href=&quot;qitemeditorfactory#setDefaultFactory&quot;&gt;setDefaultFactory&lt;/a&gt;（）设置新的默认工厂，则现有和新的委托将使用新工厂。</target>
        </trans-unit>
        <trans-unit id="4e2f4a385e37cf62cf1b97e80df94ad25fd55a99" translate="yes" xml:space="preserve">
          <source>When editing data in an item view, editors are created and displayed by a delegate. &lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate&lt;/a&gt;, which is the delegate by default installed on Qt's item views, uses a QItemEditorFactory to create editors for it. A default unique instance provided by QItemEditorFactory is used by all item delegates. If you set a new default factory with &lt;a href=&quot;qitemeditorfactory#setDefaultFactory&quot;&gt;setDefaultFactory&lt;/a&gt;(), the new factory will be used by existing and new delegates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0e7a6ec88186d061ca22e9701050d741f30a191" translate="yes" xml:space="preserve">
          <source>When editing is finished, either because the line edit lost focus or Return/Enter is pressed the &lt;a href=&quot;qlineedit#editingFinished&quot;&gt;editingFinished&lt;/a&gt;() signal is emitted.</source>
          <target state="translated">编辑完成后，由于行编辑失去焦点或按了Return / Enter键，将发出&lt;a href=&quot;qlineedit#editingFinished&quot;&gt;editFinished&lt;/a&gt;（）信号。</target>
        </trans-unit>
        <trans-unit id="d66bfe606de9465976bab385d92db6b5ec57c788" translate="yes" xml:space="preserve">
          <source>When editing of an item starts, this function is called with the</source>
          <target state="translated">当一个项目的编辑开始时,这个函数的调用是以</target>
        </trans-unit>
        <trans-unit id="b9a4a24a7b2e2cf96998146b51d4cf55a3e5c82a" translate="yes" xml:space="preserve">
          <source>When enabled and the label shows a pixmap, it will scale the pixmap to fill the available space.</source>
          <target state="translated">当启用时,标签上显示的是一张像素图,它将缩放像素图以填充可用空间。</target>
        </trans-unit>
        <trans-unit id="809e3c2e92b5437339d00438d8ac5682f3c1094a" translate="yes" xml:space="preserve">
          <source>When enabled, making a Shape visible will not wait for the content to become available. Instead, the gui/main thread is not blocked and the results of the path rendering are shown only when all the asynchronous work has been finished.</source>
          <target state="translated">启用后,使Shape可见将不会等待内容可用,相反,gui/main线程不会被阻塞,只有在所有异步工作完成后才会显示路径渲染结果。相反,gui/main线程不会被阻塞,只有当所有异步工作完成后,才会显示路径渲染的结果。</target>
        </trans-unit>
        <trans-unit id="fee807f59e511b5dcbfdf0c512929f1021ab0586" translate="yes" xml:space="preserve">
          <source>When enabled, the renderer performs a Z-prepass for opaque objects, meaning it renders them with a simple shader and color write disabled in order to get the depth buffer pre-filled before issuing draw calls for the main rendering passes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fef9dffa012fb5631fc857fa121adc562514620b" translate="yes" xml:space="preserve">
          <source>When enabled, this attribute disables the delivery of mouse events to the widget and its children. Mouse events are delivered to other widgets as if the widget and its children were not present in the widget hierarchy; mouse clicks and other events effectively &quot;pass through&quot; them. This attribute is disabled by default.</source>
          <target state="translated">启用时,此属性可禁用向小组件及其子代传递鼠标事件。鼠标事件会传递给其他小组件,就像小组件及其子代不存在于小组件层次结构中一样;鼠标点击和其他事件会有效地 &quot;穿过 &quot;它们。此属性默认为禁用。</target>
        </trans-unit>
        <trans-unit id="482662a30996d40d4a1c18a3374e7b2c360e9d38" translate="yes" xml:space="preserve">
          <source>When entering &quot;What's This?&quot; mode, a &lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt; of type Qt::EnterWhatsThisMode is sent to all toplevel widgets.</source>
          <target state="translated">输入&amp;ldquo;这是什么？&amp;rdquo;时 模式下，将Qt :: EnterWhatsThisMode类型的&lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt;发送到所有顶级小部件。</target>
        </trans-unit>
        <trans-unit id="6190eb6bb23c0ba0b8cd55075c9df2ea7f1a0eef" translate="yes" xml:space="preserve">
          <source>When executed together with the source-side example, the output is identical to &lt;a href=&quot;#qtro-example1&quot;&gt;Example 1&lt;/a&gt;.</source>
          <target state="translated">与源代码端示例一起执行时，输出与&lt;a href=&quot;#qtro-example1&quot;&gt;示例1&lt;/a&gt;相同。</target>
        </trans-unit>
        <trans-unit id="c6558b3205936d1c2767fe9741a81481ab905734" translate="yes" xml:space="preserve">
          <source>When executed, QDoc will exclude the listed directories from further consideration. Files in these directories will not be read by QDoc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9a96d672de3f61af853bd3fb2b4ddb09401c17a" translate="yes" xml:space="preserve">
          <source>When executed, QDoc will exclude the listed directories from further consideration. Files in these directories will not be read by qdoc.</source>
          <target state="translated">执行时,QDoc将把列出的目录排除在进一步的考虑之外。这些目录中的文件将不会被qdoc读取。</target>
        </trans-unit>
        <trans-unit id="f0b8e30c664f1e368519b1a60f634e4ae26e999b" translate="yes" xml:space="preserve">
          <source>When executed, QDoc will ignore the directories listed. &lt;b&gt;See also&lt;/b&gt;: &lt;a href=&quot;22-qdoc-configuration-generalvariables#excludefiles&quot;&gt;excludefiles&lt;/a&gt;.</source>
          <target state="translated">执行后，QDoc将忽略列出的目录。&lt;b&gt;另请参阅&lt;/b&gt;：&lt;a href=&quot;22-qdoc-configuration-generalvariables#excludefiles&quot;&gt;excludefiles&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ca04becdda83845f40b583b367041236f99a3f37" translate="yes" xml:space="preserve">
          <source>When executed, the first thing QDoc will do is to read through the headers specified in the &lt;a href=&quot;#headers&quot;&gt;&lt;code&gt;headers&lt;/code&gt;&lt;/a&gt; variable, and the ones located in the directories specified in the &lt;code&gt;headerdir&lt;/code&gt; variable (including all subdirectories), building an internal structure of the classes and their functions.</source>
          <target state="translated">执行后，QDoc要做的第一件事是通读&lt;a href=&quot;#headers&quot;&gt; &lt;code&gt;headers&lt;/code&gt; &lt;/a&gt;变量中指定的头文件以及 &lt;code&gt;headerdir&lt;/code&gt; 变量中指定的目录（包括所有子目录）中的目录，从而建立类及其函数的内部结构。</target>
        </trans-unit>
        <trans-unit id="5cb7e1f93541ac06ba092ca034af95b10f030b3f" translate="yes" xml:space="preserve">
          <source>When executed, the first thing QDoc will do is to read through the headers specified in the &lt;a href=&quot;10-qdoc-commands-tablesandlists#header-command&quot;&gt;&lt;code&gt;header&lt;/code&gt;&lt;/a&gt; variable, and the ones located in the directories specified in the &lt;code&gt;headerdir&lt;/code&gt; variable (including all subdirectories), building an internal structure of the classes and their functions.</source>
          <target state="translated">当执行时，QDoc要做的第一件事是通读&lt;a href=&quot;10-qdoc-commands-tablesandlists#header-command&quot;&gt; &lt;code&gt;header&lt;/code&gt; &lt;/a&gt;变量中指定的头文件，以及位于 &lt;code&gt;headerdir&lt;/code&gt; 变量中指定目录（包括所有子目录）中的文件头，建立类及其函数的内部结构。</target>
        </trans-unit>
        <trans-unit id="6f35fb24ec304ed2925435889439bd5ef8cff940" translate="yes" xml:space="preserve">
          <source>When executed, the first thing QDoc will do is to read through the headers specified in the &lt;a href=&quot;22-qdoc-configuration-generalvariables#headers&quot;&gt;&lt;code&gt;headers&lt;/code&gt;&lt;/a&gt; variable, and the ones located in the directories specified in the &lt;code&gt;headerdir&lt;/code&gt; variable (including all subdirectories), building an internal structure of the classes and their functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09ffff96391333a52eee7a9ad80e057863c3ba11" translate="yes" xml:space="preserve">
          <source>When expanding is true &lt;a href=&quot;qtabbar&quot;&gt;QTabBar&lt;/a&gt; will expand the tabs to use the empty space.</source>
          <target state="translated">当扩展为true时，&lt;a href=&quot;qtabbar&quot;&gt;QTabBar&lt;/a&gt;将扩展选项卡以使用空白空间。</target>
        </trans-unit>
        <trans-unit id="2620b86db1234798b63f39503859611b9649e059" translate="yes" xml:space="preserve">
          <source>When exporting 9-patch images in several DPI variants (&lt;code&gt;@2x&lt;/code&gt;, &lt;code&gt;@3x&lt;/code&gt;, etc.), the 9-patch lines will typically be scaled up along with the image. There are several ways to fix this, but perhaps the simplest approach is to use &lt;a href=&quot;https://www.imagemagick.org/script/mogrify.php&quot;&gt;ImageMagick's mogrify&lt;/a&gt; tool. The tool has a &lt;code&gt;-shave&lt;/code&gt; feature that can be used to crop the image to reduce the thickness of the 9-patch lines:</source>
          <target state="translated">当导出几种DPI变体（ &lt;code&gt;@2x&lt;/code&gt; ， &lt;code&gt;@3x&lt;/code&gt; 等）的9补丁图像时，通常会与图像一起放大9补丁线。有几种解决方法，但也许最简单的方法是使用&lt;a href=&quot;https://www.imagemagick.org/script/mogrify.php&quot;&gt;ImageMagick的迁移&lt;/a&gt;工具。该工具具有 &lt;code&gt;-shave&lt;/code&gt; 功能，可用于裁剪图像以减小9面线的厚度：</target>
        </trans-unit>
        <trans-unit id="70acf7a58788a901870142345c474b753e5c2cea" translate="yes" xml:space="preserve">
          <source>When extending &lt;code&gt;QtService&lt;/code&gt;, you need to declare other items for loading all the necessary libs required for Qt, mainly the same items as in &lt;code&gt;&amp;lt;activity&amp;gt;&lt;/code&gt; section for &lt;code&gt;QtActivity&lt;/code&gt;. Add the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5abd3482bf0f9993496037be30182385378e5e2" translate="yes" xml:space="preserve">
          <source>When extending &lt;code&gt;Service&lt;/code&gt;, just declare the service section as a normal Android service. Add the following inside the &lt;code&gt;&amp;lt;application&amp;gt;&lt;/code&gt; section:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd92947bef2cbe270c8052641e8c3450b891b43e" translate="yes" xml:space="preserve">
          <source>When extending QML with C++ code, a C++ class can be registered with the QML type system to enable the class to be used as a data type within QML code. While the properties, methods and signals of any &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;-derived class are accessible from QML, as discussed in &lt;a href=&quot;qtqml-cppintegration-exposecppattributes&quot;&gt;Exposing Attributes of C++ Types to QML&lt;/a&gt;, such a class cannot be used as a data type from QML until it is registered with the type system. Additionally registration can provide other features, such as allowing a class to be used as an instantiable &lt;a href=&quot;qtqml-typesystem-objecttypes&quot;&gt;QML object type&lt;/a&gt; from QML, or enabling a singleton instance of the class to be imported and used from QML.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="426d2b133ccf9d0aab48e582602ba3229910acac" translate="yes" xml:space="preserve">
          <source>When extending QML with C++ code, a C++ class can be registered with the QML type system to enable the class to be used as a data type within QML code. While the properties, methods and signals of any &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;-derived class are accessible from QML, as discussed in &lt;a href=&quot;qtqml-cppintegration-exposecppattributes#&quot;&gt;Exposing Attributes of C++ Types to QML&lt;/a&gt;, such a class cannot be used as a data type from QML until it is registered with the type system. Additionally registration can provide other features, such as allowing a class to be used as an instantiable &lt;a href=&quot;qtqml-typesystem-objecttypes#&quot;&gt;QML object type&lt;/a&gt; from QML, or enabling a singleton instance of the class to be imported and used from QML.</source>
          <target state="translated">使用C ++代码扩展QML时，可以在QML类型系统中注册C ++类，以使该类可用作QML代码中的数据类型。从QML可以访问任何&lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;派生类的属性，方法和信号，如&lt;a href=&quot;qtqml-cppintegration-exposecppattributes#&quot;&gt;将C ++类型的属性暴露&lt;/a&gt;给QML所讨论的那样，只有在将其注册到类型系统后，此类才能用作QML的数据类型。另外，注册还可以提供其他功能，例如允许从QML 将类用作可实例化的&lt;a href=&quot;qtqml-typesystem-objecttypes#&quot;&gt;QML对象类型&lt;/a&gt;，或者允许从QML导入和使用该类的单例实例。</target>
        </trans-unit>
        <trans-unit id="9db3502d0d4498df3a64124b7eb7242bd03e84ad" translate="yes" xml:space="preserve">
          <source>When generating DITA XML, qdoc outputs the nested</source>
          <target state="translated">在生成DITA XML时,qdoc输出嵌套的</target>
        </trans-unit>
        <trans-unit id="6359268011bd2e23ea07a88afa77e4d08fbb1147" translate="yes" xml:space="preserve">
          <source>When generating the reference documentation for a class, QDoc will create and link to a separate page documenting its obsolete functions. Usually an equivalent function is provided as an alternative.</source>
          <target state="translated">当为一个类生成参考文档时,QDoc将创建并链接到一个单独的页面,记录其过时的函数。通常会提供一个等价的函数作为替代。</target>
        </trans-unit>
        <trans-unit id="71f447939a909dfa27ce949444c9508a3a7d93da" translate="yes" xml:space="preserve">
          <source>When getting started with developing on a given embedded device, it is often necessary to verify the behavior of the device and drivers, and that the connected displays are working as they should. One easy way is to use the hellowindow example. Launching it with &lt;code&gt;-platform eglfs --multiscreen --timeout&lt;/code&gt; arguments shows a rotating Qt logo on each connected screen for a few seconds.</source>
          <target state="translated">开始在给定的嵌入式设备上进行开发时，通常需要验证设备和驱动程序的行为，以及所连接的显示器是否按预期工作。一种简单的方法是使用hellowindow示例。使用 &lt;code&gt;-platform eglfs --multiscreen --timeout&lt;/code&gt; 参数启动它会在每个连接的屏幕上显示旋转的Qt徽标几秒钟。</target>
        </trans-unit>
        <trans-unit id="b8ddc3778afe40355df31ec30ad7ce29680583ba" translate="yes" xml:space="preserve">
          <source>When handling the signal with &lt;code&gt;onLoadingChanged&lt;/code&gt;, various read-only parameters are available on the &lt;a href=&quot;qml-qtwebengine-webengineloadrequest&quot;&gt;WebEngineLoadRequest&lt;/a&gt; specified by</source>
          <target state="translated">当处理与信号 &lt;code&gt;onLoadingChanged&lt;/code&gt; ，各种只读参数都可以在&lt;a href=&quot;qml-qtwebengine-webengineloadrequest&quot;&gt;WebEngineLoadRequest&lt;/a&gt;指定由</target>
        </trans-unit>
        <trans-unit id="dd3376f42ea41d22705767c518b03411a09688ef" translate="yes" xml:space="preserve">
          <source>When handling this signal, changing the &lt;a href=&quot;qml-qtquick-mouseevent#accepted-prop&quot;&gt;accepted&lt;/a&gt; property of the</source>
          <target state="translated">在处理这个信号，改变&lt;a href=&quot;qml-qtquick-mouseevent#accepted-prop&quot;&gt;接受&lt;/a&gt;的财产</target>
        </trans-unit>
        <trans-unit id="6609fd77e98998e1210abc85df3c2fabea25a8b3" translate="yes" xml:space="preserve">
          <source>When handling this signal, if the &lt;a href=&quot;qml-qtquick-mouseevent#accepted-prop&quot;&gt;accepted&lt;/a&gt; property of the</source>
          <target state="translated">在处理该信号，如果&lt;a href=&quot;qml-qtquick-mouseevent#accepted-prop&quot;&gt;接受&lt;/a&gt;的财产</target>
        </trans-unit>
        <trans-unit id="b478004d57f010bec2ae3794bb546849c254693f" translate="yes" xml:space="preserve">
          <source>When handling this signal, use the &lt;a href=&quot;qml-qtquick-mouseevent#accepted-prop&quot;&gt;accepted&lt;/a&gt; property of the</source>
          <target state="translated">在处理这个信号，使用&lt;a href=&quot;qml-qtquick-mouseevent#accepted-prop&quot;&gt;公认&lt;/a&gt;的财产</target>
        </trans-unit>
        <trans-unit id="6295b7b616f0d9112be806cf906b2998b3813947" translate="yes" xml:space="preserve">
          <source>When having multiple displays connected, the level of support for targeting one or more of these from one single Qt application varies between the platform plugins and often depends on the device and its graphics stack.</source>
          <target state="translated">当连接了多个显示器时,不同的平台插件对一个或多个显示器的支持程度不同,通常取决于设备及其图形栈。</target>
        </trans-unit>
        <trans-unit id="33cb76c34e5dfbfadb36579df2b883f159a00960" translate="yes" xml:space="preserve">
          <source>When implemented, this function is responsible for checking the paint engine's current</source>
          <target state="translated">实现后,该函数负责检查油漆引擎当前的</target>
        </trans-unit>
        <trans-unit id="cb84a9cfef6f8292ec44602b7462e414abc9870a" translate="yes" xml:space="preserve">
          <source>When implementing a custom extension class, you must use Q_DECLARE_EXTENSION_INTERFACE() to enable usage of the &lt;a href=&quot;qextensionmanager#qt_extension&quot;&gt;qt_extension&lt;/a&gt;() function. The macro is normally located right after the class definition for</source>
          <target state="translated">在实现自定义扩展类时，必须使用Q_DECLARE_EXTENSION_INTERFACE（）启用&lt;a href=&quot;qextensionmanager#qt_extension&quot;&gt;qt_extension&lt;/a&gt;（）函数的使用。该宏通常位于以下类的定义之后</target>
        </trans-unit>
        <trans-unit id="84772bea2f59837a3da39c7af78975341f21eb2b" translate="yes" xml:space="preserve">
          <source>When implementing a custom style, you cannot assume that the widget is a &lt;a href=&quot;qspinbox&quot;&gt;QSpinBox&lt;/a&gt; just because the enum value is called &lt;a href=&quot;qstyle#PrimitiveElement-enum&quot;&gt;PE_IndicatorSpinUp&lt;/a&gt; or &lt;a href=&quot;qstyle#PrimitiveElement-enum&quot;&gt;PE_IndicatorSpinDown&lt;/a&gt;.</source>
          <target state="translated">在实现自定义样式时，不能仅仅因为枚举值称为&lt;a href=&quot;qstyle#PrimitiveElement-enum&quot;&gt;PE_IndicatorSpinUp&lt;/a&gt;或&lt;a href=&quot;qstyle#PrimitiveElement-enum&quot;&gt;PE_IndicatorSpinDown&lt;/a&gt;而就假定该小部件是&lt;a href=&quot;qspinbox&quot;&gt;QSpinBox&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="869ecc6a6e96e1eee7be87f15ad29e53d15bface" translate="yes" xml:space="preserve">
          <source>When implementing a custom widget plugin, a pointer to</source>
          <target state="translated">当实现一个自定义widget插件时,一个指向</target>
        </trans-unit>
        <trans-unit id="b5e58b90ddc89647665b1bcd29b18d24dcef1559" translate="yes" xml:space="preserve">
          <source>When implementing a custom widget plugin, you build it as a separate library. If you want to include several custom widget plugins in the same library, you must in addition subclass &lt;a href=&quot;qdesignercustomwidgetcollectioninterface&quot;&gt;QDesignerCustomWidgetCollectionInterface&lt;/a&gt;.</source>
          <target state="translated">实施自定义窗口小部件插件时，可以将其构建为单独的库。如果要在同一个库中包含几个自定义窗口小部件插件，则还必须另外子类&lt;a href=&quot;qdesignercustomwidgetcollectioninterface&quot;&gt;QDesignerCustomWidgetCollectionInterface&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5ea9264234b2724850203d32239a91745a3b4bcd" translate="yes" xml:space="preserve">
          <source>When implementing a custom widget plugin, you build it as a separate library. If you want to include several custom widget plugins in the same library, you must in addition subclass QDesignerCustomWidgetCollectionInterface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c647a12112d8ed46e7c8ca84107c20d588614b0" translate="yes" xml:space="preserve">
          <source>When implementing a custom widget plugin, you must subclass the &lt;a href=&quot;qdesignercustomwidgetinterface&quot;&gt;QDesignerCustomWidgetInterface&lt;/a&gt; to expose your plugin to</source>
          <target state="translated">实施自定义窗口小部件插件时，必须将&lt;a href=&quot;qdesignercustomwidgetinterface&quot;&gt;QDesignerCustomWidgetInterface&lt;/a&gt;子类化以将插件公开给</target>
        </trans-unit>
        <trans-unit id="91021ae6ff5dfe6164732e25da258734b737eb88" translate="yes" xml:space="preserve">
          <source>When implementing a custom widget you must subclass &lt;a href=&quot;qdesignercustomwidgetinterface&quot;&gt;QDesignerCustomWidgetInterface&lt;/a&gt; to expose your widget to</source>
          <target state="translated">实施自定义窗口小部件时，必须子类&lt;a href=&quot;qdesignercustomwidgetinterface&quot;&gt;QDesignerCustomWidgetInterface&lt;/a&gt;才能将窗口小部件公开给</target>
        </trans-unit>
        <trans-unit id="98de48237e2610b3ed96ebfc3b4b3e1647ecb00b" translate="yes" xml:space="preserve">
          <source>When implementing a custom widget you must subclass QDesignerCustomWidgetInterface to expose your widget to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="595ba0ecf978bd65b6513cd7266fa82465645c81" translate="yes" xml:space="preserve">
          <source>When implementing a model it is important to remember that &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; does not store any data itself, it merely presents an interface that the views use to access the data. For a minimal read-only model it is only necessary to implement a few functions as there are default implementations for most of the interface. The class declaration is as follows:</source>
          <target state="translated">在实现模型时，重要的是要记住&lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt;本身并不存储任何数据，它仅提供一个视图用来访问数据的接口。对于最小的只读模型，仅需要实现一些功能，因为大多数接口都有默认实现。类声明如下：</target>
        </trans-unit>
        <trans-unit id="445cd07d2a0506cd16ff907563ea7c0e381a4ac2" translate="yes" xml:space="preserve">
          <source>When implementing a new widget, it is almost always useful to reimplement &lt;a href=&quot;qwidget#sizeHint-prop&quot;&gt;sizeHint&lt;/a&gt;() to provide a reasonable default size for the widget and to set the correct size policy with &lt;a href=&quot;qwidget#sizePolicy-prop&quot;&gt;setSizePolicy&lt;/a&gt;().</source>
          <target state="translated">实施新窗口小部件时，重新实现&lt;a href=&quot;qwidget#sizeHint-prop&quot;&gt;sizeHint&lt;/a&gt;（）为窗口小部件提供合理的默认大小并使用&lt;a href=&quot;qwidget#sizePolicy-prop&quot;&gt;setSizePolicy&lt;/a&gt;（）设置正确的大小策略几乎总是有用的。</target>
        </trans-unit>
        <trans-unit id="4c9d446fde723c06b31550398f72ba270ba5a90c" translate="yes" xml:space="preserve">
          <source>When implementing a subclass of this interface, there are only a handful of functions to implement, broken down into two classes:</source>
          <target state="translated">在实现这个接口的子类时,只需要实现少量的功能,分成两个类。</target>
        </trans-unit>
        <trans-unit id="d65384984581a6d6fbb1f4f4bccbb7923f82cdc1" translate="yes" xml:space="preserve">
          <source>When implementing a subclass, you must call this function</source>
          <target state="translated">当实现一个子类时,你必须调用这个函数。</target>
        </trans-unit>
        <trans-unit id="7c18f33bf2a59c6087f18cc24038056a308ad7f2" translate="yes" xml:space="preserve">
          <source>When implementing an accessibility interface for widgets, one would as a rule inherit &lt;a href=&quot;qaccessiblewidget&quot;&gt;QAccessibleWidget&lt;/a&gt;, which is a convenience class for widgets. Another available convenience class, which is inherited by &lt;a href=&quot;qaccessiblewidget&quot;&gt;QAccessibleWidget&lt;/a&gt;, is the &lt;a href=&quot;qaccessibleobject&quot;&gt;QAccessibleObject&lt;/a&gt;, which implements part of the interface for QObjects.</source>
          <target state="translated">当实现窗口小部件的可访问性接口时，通常会继承&lt;a href=&quot;qaccessiblewidget&quot;&gt;QAccessibleWidget&lt;/a&gt;，这是窗口小部件的便捷类。由&lt;a href=&quot;qaccessiblewidget&quot;&gt;QAccessibleWidget&lt;/a&gt;继承的另一个可用的便利类是&lt;a href=&quot;qaccessibleobject&quot;&gt;QAccessibleObject&lt;/a&gt;，它实现了QObjects接口的一部分。</target>
        </trans-unit>
        <trans-unit id="4e43675b73f85281cf7ffd4c9feb92576f97c666" translate="yes" xml:space="preserve">
          <source>When implementing an item model (that is, a concrete &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; subclass) one must abide to a very strict set of rules that ensure consistency for users of the model (views, proxy models, and so on).</source>
          <target state="translated">在实现项目模型（即具体的&lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt;子类）时，必须遵守一组非常严格的规则，以确保模型用户（视图，代理模型等）的一致性。</target>
        </trans-unit>
        <trans-unit id="71c25ae80d1eb821bd312d0369953f3099005788" translate="yes" xml:space="preserve">
          <source>When implementing drag and drop support in a custom model, if you will return data in formats other than the default internal MIME type, reimplement this function to return your list of MIME types.</source>
          <target state="translated">在自定义模型中实现拖放支持时,如果您将以默认内部 MIME 类型以外的格式返回数据,请重新实现此函数以返回您的 MIME 类型列表。</target>
        </trans-unit>
        <trans-unit id="3e1de2caa20c3401ccd297583ca14adb9e36f89e" translate="yes" xml:space="preserve">
          <source>When implementing drag and drop support in a custom model, it is possible to export items of data in specialized formats by reimplementing the following function:</source>
          <target state="translated">在自定义模型中实现拖放支持时,可以通过重新实现以下函数,以特殊格式导出数据项。</target>
        </trans-unit>
        <trans-unit id="891ebe7dedc591934a24e2e5c92f98ba49623d2e" translate="yes" xml:space="preserve">
          <source>When implementing styles, it is necessary to look through the code of the widgets and code of the base class and its ancestors. This is because the widgets use the style differently, because the implementation in the different styles' virtual functions can affect the state of the drawing (e.g., by altering the &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; state without restoring it and drawing some elements without using the appropriate pixel metrics and sub elements).</source>
          <target state="translated">在实现样式时，有必要查看小部件的代码以及基类及其祖先的代码。这是因为窗口小部件使用的样式不同，因为使用不同样式的虚函数的实现可能会影响图形的状态（例如，通过更改&lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;状态而不恢复它，并且绘制某些元素而不使用适当的像素度量和子元素）。元素）。</target>
        </trans-unit>
        <trans-unit id="1c4d91075815fdbbae33aba2b667fd4633c4c3da" translate="yes" xml:space="preserve">
          <source>When implementing the property write function, use &lt;a href=&quot;qaxbindable#requestPropertyChange&quot;&gt;requestPropertyChange&lt;/a&gt;() to get permission from the ActiveX client application to change this property. When the property changes, call &lt;a href=&quot;qaxbindable#propertyChanged&quot;&gt;propertyChanged&lt;/a&gt;() to notify the ActiveX client application about the change. If a fatal error occurs in the control, use the static &lt;a href=&quot;qaxbindable#reportError&quot;&gt;reportError&lt;/a&gt;() function to notify the client.</source>
          <target state="translated">在实现属性写入功能时，请使用&lt;a href=&quot;qaxbindable#requestPropertyChange&quot;&gt;requestPropertyChange&lt;/a&gt;（）从ActiveX客户端应用程序获取权限以更改此属性。当属性更改时，调用&lt;a href=&quot;qaxbindable#propertyChanged&quot;&gt;propertyChanged&lt;/a&gt;（）通知ActiveX客户端应用程序有关更改。如果控件中发生致命错误，请使用静态&lt;a href=&quot;qaxbindable#reportError&quot;&gt;reportError&lt;/a&gt;（）函数通知客户端。</target>
        </trans-unit>
        <trans-unit id="5c75a646668a787fcace5c55f81aa7bf0b70d1c6" translate="yes" xml:space="preserve">
          <source>When implementing the property write functions, use the &lt;a href=&quot;qaxbindable&quot;&gt;QAxBindable&lt;/a&gt; class's requestPropertyChange() and propertyChanged() functions to allow ActiveX clients to bind to the control properties.</source>
          <target state="translated">在实现属性写入功能时，请使用&lt;a href=&quot;qaxbindable&quot;&gt;QAxBindable&lt;/a&gt;类的requestPropertyChange（）和propertyChanged（）函数来允许ActiveX客户端绑定到控件属性。</target>
        </trans-unit>
        <trans-unit id="7b41031e55866a68b8184e142ce7198e2e1fe7ec" translate="yes" xml:space="preserve">
          <source>When implementing this function in subclasses of this class, you must construct and return new editor widgets with the parent widget specified.</source>
          <target state="translated">当在该类的子类中实现该函数时,必须用指定的父部件构造并返回新的编辑器部件。</target>
        </trans-unit>
        <trans-unit id="1591d2c3ab41219fe3e148cfbb0593be15c3c678" translate="yes" xml:space="preserve">
          <source>When implementing this function in subclasses, you must ensure that the editor widget's property specified by this function can accept the type the creator is registered for. For example, a creator which constructs &lt;a href=&quot;qcheckbox&quot;&gt;QCheckBox&lt;/a&gt; widgets to edit boolean values would return the &lt;a href=&quot;qabstractbutton#checkable-prop&quot;&gt;checkable&lt;/a&gt; property name from this function, and must be registered in the item editor factory for the QVariant::Bool type.</source>
          <target state="translated">在子类中实现此功能时，必须确保此功能指定的编辑器小部件的属性可以接受创建者注册的类型。例如，构造&lt;a href=&quot;qcheckbox&quot;&gt;QCheckBox&lt;/a&gt;小部件以编辑布尔值的创建者将从该函数返回&lt;a href=&quot;qabstractbutton#checkable-prop&quot;&gt;可检查的&lt;/a&gt;属性名称，并且必须在项目编辑器工厂中注册QVariant :: Bool类型。</target>
        </trans-unit>
        <trans-unit id="8ce39d7538e9c5292578832459d332de3effbff1" translate="yes" xml:space="preserve">
          <source>When implementing this interface you will almost certainly also want to implement &lt;a href=&quot;qaccessibletextinterface&quot;&gt;QAccessibleTextInterface&lt;/a&gt;.</source>
          <target state="translated">在实现此接口时，几乎可以肯定也要实现&lt;a href=&quot;qaccessibletextinterface&quot;&gt;QAccessibleTextInterface&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6268d96d04a4d653a0acc9732f0ac32216ce55c6" translate="yes" xml:space="preserve">
          <source>When implementing you own custom graphics transform, you must call this function every time you change a parameter, to let &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; know that its transformation needs to be updated.</source>
          <target state="translated">在实现自己的自定义图形转换时，每次更改参数时都必须调用此函数，以使&lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt;知道需要更新其转换。</target>
        </trans-unit>
        <trans-unit id="e0faa4d1d0c8b9ed5d373ba76a73de237e335d71" translate="yes" xml:space="preserve">
          <source>When implementing your own implicitly shared classes, use the &lt;a href=&quot;qshareddata&quot;&gt;QSharedData&lt;/a&gt; and &lt;a href=&quot;qshareddatapointer&quot;&gt;QSharedDataPointer&lt;/a&gt; classes.</source>
          <target state="translated">When implementing your own implicitly shared classes, use the &lt;a href=&quot;qshareddata&quot;&gt;QSharedData&lt;/a&gt; and &lt;a href=&quot;qshareddatapointer&quot;&gt;QSharedDataPointer&lt;/a&gt; classes.</target>
        </trans-unit>
        <trans-unit id="ed089988e57c5a0f9eb64a54af80f4e4cc7da5be" translate="yes" xml:space="preserve">
          <source>When implementing your own itemview setSelection should call &lt;a href=&quot;qabstractitemview#selectionModel&quot;&gt;selectionModel&lt;/a&gt;()-&amp;gt;select(selection, flags) where selection is either an empty &lt;a href=&quot;qmodelindex&quot;&gt;QModelIndex&lt;/a&gt; or a &lt;a href=&quot;qitemselection&quot;&gt;QItemSelection&lt;/a&gt; that contains all items that are contained in</source>
          <target state="translated">在实现自己的itemview时，setSelection应该调用&lt;a href=&quot;qabstractitemview#selectionModel&quot;&gt;selectionModel&lt;/a&gt;（）-&amp;gt; select（selection，flags），其中selection是空的&lt;a href=&quot;qmodelindex&quot;&gt;QModelIndex&lt;/a&gt;或&lt;a href=&quot;qitemselection&quot;&gt;QItemSelection&lt;/a&gt;，其中包含</target>
        </trans-unit>
        <trans-unit id="90d1ebe5eabb55f03ec9c6da6079f40a2ff77a3d" translate="yes" xml:space="preserve">
          <source>When implementing your own style and customizing controls, there are some points to keep in mind to ensure that your application is as performant as possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b13759dc0478b7385db4120f936b29bbec97142e" translate="yes" xml:space="preserve">
          <source>When importing a &lt;a href=&quot;qtqml-typesystem-objecttypes&quot;&gt;QML object type&lt;/a&gt; with a property alias in the root object, however, the property appear as a regular Qt property and consequently can be used in alias references.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d2c6cac0080194cff24d54acaddace27ee77592" translate="yes" xml:space="preserve">
          <source>When importing a &lt;a href=&quot;qtqml-typesystem-objecttypes#&quot;&gt;QML object type&lt;/a&gt; with a property alias in the root object, however, the property appear as a regular Qt property and consequently can be used in alias references.</source>
          <target state="translated">但是，当在根对象中导入带有属性别名的&lt;a href=&quot;qtqml-typesystem-objecttypes#&quot;&gt;QML对象类型&lt;/a&gt;时，该属性显示为常规Qt属性，因此可以在别名引用中使用。</target>
        </trans-unit>
        <trans-unit id="63972382ca72bfae9a1039f20443d3527d3f328d" translate="yes" xml:space="preserve">
          <source>When in Running state, &lt;a href=&quot;qtimeline&quot;&gt;QTimeLine&lt;/a&gt; also emits the &lt;a href=&quot;qtimeline#frameChanged&quot;&gt;frameChanged&lt;/a&gt;() signal when the frame changes.</source>
          <target state="translated">当处于运行状态时，当框架改变时，&lt;a href=&quot;qtimeline&quot;&gt;QTimeLine&lt;/a&gt;也会发出&lt;a href=&quot;qtimeline#frameChanged&quot;&gt;frameChanged&lt;/a&gt;（）信号。</target>
        </trans-unit>
        <trans-unit id="ef3e888a5ecf29cb8462a72debc447a17e27543a" translate="yes" xml:space="preserve">
          <source>When in StrictMode, if a parsing error is found, &lt;a href=&quot;qurl#isValid&quot;&gt;isValid&lt;/a&gt;() will return &lt;code&gt;false&lt;/code&gt; and &lt;a href=&quot;qurl#errorString&quot;&gt;errorString&lt;/a&gt;() will return a message describing the error. If more than one error is detected, it is undefined which error gets reported.</source>
          <target state="translated">在StrictMode中时，如果发现解析错误，则&lt;a href=&quot;qurl#isValid&quot;&gt;isValid&lt;/a&gt;（）将返回 &lt;code&gt;false&lt;/code&gt; ,而&lt;a href=&quot;qurl#errorString&quot;&gt;errorString&lt;/a&gt;（）将返回描述该错误的消息。如果检测到多个错误，则不确定报告哪个错误。</target>
        </trans-unit>
        <trans-unit id="3456c56afa83ec7dbd61d985f62e50c29f6549e1" translate="yes" xml:space="preserve">
          <source>When in keyboard-interactive mode, you can use the arrow and page keys to either move or resize the window. This property controls the arrow keys. The common way to enter keyboard interactive mode is to enter the subwindow menu, and select either &quot;resize&quot; or &quot;move&quot;.</source>
          <target state="translated">在键盘交互模式下,可以使用箭头键和页键移动或调整窗口大小。此属性控制方向键。进入键盘交互模式的常用方法是进入子窗口菜单,选择 &quot;调整大小 &quot;或 &quot;移动&quot;。</target>
        </trans-unit>
        <trans-unit id="3fb322ebc9c9cd2d657c0fb9d224a6635a538d7d" translate="yes" xml:space="preserve">
          <source>When in keyboard-interactive mode, you can use the arrow and page keys to either move or resize the window. This property controls the page keys. The common way to enter keyboard interactive mode is to enter the subwindow menu, and select either &quot;resize&quot; or &quot;move&quot;.</source>
          <target state="translated">在键盘交互模式下,可以使用箭头键和页键移动或调整窗口大小。此属性控制页键。进入键盘交互模式的常用方法是进入子窗口菜单,选择 &quot;调整大小 &quot;或 &quot;移动&quot;。</target>
        </trans-unit>
        <trans-unit id="2c08753db2a8aa137364ee7093529568335fe121" translate="yes" xml:space="preserve">
          <source>When inheriting &lt;a href=&quot;qabstractscrollarea&quot;&gt;QAbstractScrollArea&lt;/a&gt;, you need to do the following:</source>
          <target state="translated">继承&lt;a href=&quot;qabstractscrollarea&quot;&gt;QAbstractScrollArea时&lt;/a&gt;，需要执行以下操作：</target>
        </trans-unit>
        <trans-unit id="9110d9a8dc385178c6df16681bf45970bc611881" translate="yes" xml:space="preserve">
          <source>When inheriting QAbstractScrollArea, you need to do the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef5ec1307e1565c3ba533b6306e4c4fb6e84f432" translate="yes" xml:space="preserve">
          <source>When inserting action items you usually specify a receiver and a slot. The receiver will be notifed whenever the item is &lt;a href=&quot;qaction#triggered&quot;&gt;triggered()&lt;/a&gt;. In addition, &lt;a href=&quot;qmenu&quot;&gt;QMenu&lt;/a&gt; provides two signals, &lt;a href=&quot;qmenu#triggered&quot;&gt;triggered&lt;/a&gt;() and &lt;a href=&quot;qmenu#hovered&quot;&gt;hovered&lt;/a&gt;(), which signal the &lt;a href=&quot;qaction&quot;&gt;QAction&lt;/a&gt; that was triggered from the menu.</source>
          <target state="translated">插入动作项目时，通常会指定一个接收器和一个插槽。每当item被&lt;a href=&quot;qaction#triggered&quot;&gt;触发&lt;/a&gt;时，接收者都会收到通知。此外，&lt;a href=&quot;qmenu&quot;&gt;QMenu&lt;/a&gt;提供两个信号，&lt;a href=&quot;qmenu#triggered&quot;&gt;触发&lt;/a&gt;（）和&lt;a href=&quot;qmenu#hovered&quot;&gt;盘旋&lt;/a&gt;（），它用信号通知&lt;a href=&quot;qaction&quot;&gt;的QAction&lt;/a&gt;这是从菜单中触发。</target>
        </trans-unit>
        <trans-unit id="b0a12f123004137273217a41fe960ac1382b53f8" translate="yes" xml:space="preserve">
          <source>When inserting action items you usually specify a receiver and a slot. The receiver will be notifed whenever the item is &lt;a href=&quot;qaction#triggered&quot;&gt;triggered()&lt;/a&gt;. In addition, QMenu provides two signals, &lt;a href=&quot;qmenu#triggered&quot;&gt;triggered&lt;/a&gt;() and &lt;a href=&quot;qmenu#hovered&quot;&gt;hovered&lt;/a&gt;(), which signal the &lt;a href=&quot;qaction&quot;&gt;QAction&lt;/a&gt; that was triggered from the menu.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="864005fb46a1674119933552576b5eb471667e9c" translate="yes" xml:space="preserve">
          <source>When inserting multiple records, you only need to call &lt;a href=&quot;qsqlquery#prepare&quot;&gt;QSqlQuery::prepare&lt;/a&gt;() once. Then you call &lt;a href=&quot;qsqlquery#bindValue&quot;&gt;bindValue()&lt;/a&gt; or &lt;a href=&quot;qsqlquery#addBindValue&quot;&gt;addBindValue()&lt;/a&gt; followed by &lt;a href=&quot;qsqlquery#exec-1&quot;&gt;exec()&lt;/a&gt; as many times as necessary.</source>
          <target state="translated">插入多个记录时，只需调用一次&lt;a href=&quot;qsqlquery#prepare&quot;&gt;QSqlQuery :: prepare&lt;/a&gt;（）。然后调用&lt;a href=&quot;qsqlquery#bindValue&quot;&gt;bindValue（）&lt;/a&gt;或&lt;a href=&quot;qsqlquery#addBindValue&quot;&gt;addBindValue（） &lt;/a&gt;，然后&lt;a href=&quot;qsqlquery#exec-1&quot;&gt;执行exec（）&lt;/a&gt;多次必要的。</target>
        </trans-unit>
        <trans-unit id="f4a6a2c17602b8ef1614b658343d290c1bd56516" translate="yes" xml:space="preserve">
          <source>When inserting such a fragment into a &lt;a href=&quot;qtextdocument&quot;&gt;QTextDocument&lt;/a&gt; the current char format of the &lt;a href=&quot;qtextcursor&quot;&gt;QTextCursor&lt;/a&gt; used for insertion is used as format for the text.</source>
          <target state="translated">当插入这样的片段成&lt;a href=&quot;qtextdocument&quot;&gt;另外，QTextDocument&lt;/a&gt;所述的当前char格式&lt;a href=&quot;qtextcursor&quot;&gt;QTextCursor&lt;/a&gt;用于插入被用作文本格式。</target>
        </trans-unit>
        <trans-unit id="6ee49651f87fc18143f2662752cc1cf4e9cb8b10" translate="yes" xml:space="preserve">
          <source>When integrating existing classes and technology into QML, APIs will often need tweaking to fit better into the declarative environment. Although the best results are usually obtained by modifying the original classes directly, if this is either not possible or is complicated by some other concerns, extension objects allow limited extension possibilities without direct modifications.</source>
          <target state="translated">在将现有的类和技术集成到QML中时,API往往需要进行调整,以便更好地适应声明式环境。虽然最好的结果通常是通过直接修改原始类来获得,但如果这不可能或者因为一些其他问题而变得复杂,扩展对象允许有限的扩展可能性,而无需直接修改。</target>
        </trans-unit>
        <trans-unit id="46cd534349e4b4409b3a901102a23c1cbd1d64c6" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qcolor&quot;&gt;QColor&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;color&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">与C ++集成时，请注意，&lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;从C ++传递到QML的&lt;/a&gt;任何&lt;a href=&quot;qcolor&quot;&gt;QColor&lt;/a&gt;值都会自动转换为 &lt;code&gt;color&lt;/code&gt; 值，反之亦然。</target>
        </trans-unit>
        <trans-unit id="59e07d9cc2cac329614b7169422187bba763b0d8" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; or &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;date&lt;/code&gt; value, and vice-versa. Note, however, that converting a &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; will result in UTC's start of the day, which falls on a different date in some other time-zones. It is usually more robust to convert the &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; via a &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; explicitly, specifying local-time or a relevant time-zone and selecting a time of day (such as noon) that reliably exists (daylight-savings transitions skip an hour, near one end or the other of a day).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94f4f40b3918cac601587862fbf8acc3e95d325a" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; or &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;date&lt;/code&gt; value, and vice-versa. Note, however, that converting a &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; will result in UTC's start of the day, which falls on a different date in some other time-zones. It is usually more robust to convert the &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; via a &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; explicitly, specifying local-time or a relevant time-zone and selecting a time of day (such as noon) that reliably exists (daylight-savings transitions skip an hour, near one end or the other of a day).</source>
          <target state="translated">与C ++集成时，请注意，&lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;从C ++传递到QML的&lt;/a&gt;任何&lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt;或&lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt;值都会自动转换为 &lt;code&gt;date&lt;/code&gt; 值，反之亦然。但是请注意，转换&lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt;将导致UTC的开始，该日期在某些其他时区中处于不同的日期。通常，通过&lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt;显式转换&lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt;，指定本地时间或相关时区并选择可靠地存在的一天中的某个时间（例如中午）（将夏时制转换跳过一个小时，接近终点）会更可靠。或另一天）。</target>
        </trans-unit>
        <trans-unit id="2a3e9ea44f85bb16e221814f180ac27358c1f643" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qfont&quot;&gt;QFont&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;font&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">与C ++集成时，请注意，&lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;从C ++传递到QML的&lt;/a&gt;任何&lt;a href=&quot;qfont&quot;&gt;QFont&lt;/a&gt;值都会自动转换为 &lt;code&gt;font&lt;/code&gt; 值，反之亦然。</target>
        </trans-unit>
        <trans-unit id="c80b7cd162c43b0104ef58b6d7d770bb2b3dc0c9" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qgeocircle&quot;&gt;QGeoCircle&lt;/a&gt; value passed into QML from C++ is automatically converted into a &lt;code&gt;geocircle&lt;/code&gt; value, and vise-versa.</source>
          <target state="translated">与C ++集成时，请注意，从C ++传递到QML的任何&lt;a href=&quot;qgeocircle&quot;&gt;QGeoCircle&lt;/a&gt;值都会自动转换为 &lt;code&gt;geocircle&lt;/code&gt; 值，反之亦然。</target>
        </trans-unit>
        <trans-unit id="f90dc519be0e60fb444dc1c5260f47cc6cd907ee" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qgeocoordinate&quot;&gt;QGeoCoordinate&lt;/a&gt; value passed into QML from C++ is automatically converted into a &lt;code&gt;coordinate&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">与C ++集成时，请注意，从C ++传递到QML的任何&lt;a href=&quot;qgeocoordinate&quot;&gt;QGeoCoordinate&lt;/a&gt;值都会自动转换为 &lt;code&gt;coordinate&lt;/code&gt; 值，反之亦然。</target>
        </trans-unit>
        <trans-unit id="c5bbf6333d877f577a96dba2b55b5c884f293ae5" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qgeopath&quot;&gt;QGeoPath&lt;/a&gt; value passed into QML from C++ is automatically converted into a &lt;code&gt;geopath&lt;/code&gt; value, and vice versa.</source>
          <target state="translated">与C ++集成时，请注意，从C ++传递到QML的任何&lt;a href=&quot;qgeopath&quot;&gt;QGeoPath&lt;/a&gt;值都会自动转换为 &lt;code&gt;geopath&lt;/code&gt; 值，反之亦然。</target>
        </trans-unit>
        <trans-unit id="fc4029c75e55b88c42d4329274584c8e9c0128eb" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qgeopolygon&quot;&gt;QGeoPolygon&lt;/a&gt; value passed into QML is automatically converted into a &lt;code&gt;geopolygon&lt;/code&gt;, and vice versa.</source>
          <target state="translated">与C ++集成时，请注意，传递给QML的任何&lt;a href=&quot;qgeopolygon&quot;&gt;QGeoPolygon&lt;/a&gt;值都会自动转换为 &lt;code&gt;geopolygon&lt;/code&gt; ，反之亦然。</target>
        </trans-unit>
        <trans-unit id="a7dba58612710895f3116ae91ec3e71bc80778eb" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qgeorectangle&quot;&gt;QGeoRectangle&lt;/a&gt; value passed into QML from C++ is automatically converted into a &lt;code&gt;georectangle&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">与C ++集成时，请注意，从C ++传递到QML的所有&lt;a href=&quot;qgeorectangle&quot;&gt;QGeoRectangle&lt;/a&gt;值都会自动转换为 &lt;code&gt;georectangle&lt;/code&gt; 值，反之亦然。</target>
        </trans-unit>
        <trans-unit id="4d5c3d73097853ceb2db3f5a71a11d6fad5cb8d2" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qgeoshape&quot;&gt;QGeoShape&lt;/a&gt; value passed into QML from C++ is automatically converted into a &lt;code&gt;geoshape&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">与C ++集成时，请注意，从C ++传递到QML的任何&lt;a href=&quot;qgeoshape&quot;&gt;QGeoShape&lt;/a&gt;值都会自动转换为 &lt;code&gt;geoshape&lt;/code&gt; 值，反之亦然。</target>
        </trans-unit>
        <trans-unit id="babd158b5780227850bc5ed9c758d5d58d7cd1f2" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt; or &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;point&lt;/code&gt; value. When a &lt;code&gt;point&lt;/code&gt; value is passed to C++, it is automatically converted into a &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06f6b135e98805bdd8065da59a778cd9f4c5215e" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt; or &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;point&lt;/code&gt; value. When a &lt;code&gt;point&lt;/code&gt; value is passed to C++, it is automatically converted into a &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; value.</source>
          <target state="translated">与C ++集成时，请注意，&lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;从C ++传递到QML的&lt;/a&gt;任何&lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt;或&lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt;值都会自动转换为 &lt;code&gt;point&lt;/code&gt; 值。将 &lt;code&gt;point&lt;/code&gt; 值传递给C ++时，它会自动转换为&lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt;值。</target>
        </trans-unit>
        <trans-unit id="a84623eea3626c41bb0f62625b89382e6a0884d2" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qqmllistproperty&quot;&gt;QQmlListProperty&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;list&lt;/code&gt; value, and vice-versa.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4537d2f61ed5eb33aa48c28e4d1f2cbe5739fee6" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qqmllistproperty&quot;&gt;QQmlListProperty&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;list&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">与C ++集成时，请注意，&lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;从C ++传递到QML的&lt;/a&gt;任何&lt;a href=&quot;qqmllistproperty&quot;&gt;QQmlListProperty&lt;/a&gt;值都会自动转换为 &lt;code&gt;list&lt;/code&gt; 值，反之亦然。</target>
        </trans-unit>
        <trans-unit id="892030f32ca7d95430d43e3adb51ab41646ac62c" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; or &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;rect&lt;/code&gt; value, and vice-versa. When a &lt;code&gt;rect&lt;/code&gt; value is passed to C++, it is automatically converted into a &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bde76fc240f3c1a3b45734a6b9372df275b0771e" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; or &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;rect&lt;/code&gt; value, and vice-versa. When a &lt;code&gt;rect&lt;/code&gt; value is passed to C++, it is automatically converted into a &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; value.</source>
          <target state="translated">与C ++集成时，请注意，&lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;从C ++传递到QML的&lt;/a&gt;任何&lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt;或&lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt;值都会自动转换为 &lt;code&gt;rect&lt;/code&gt; 值，反之亦然。当将 &lt;code&gt;rect&lt;/code&gt; 值传递给C ++时，它将自动转换为&lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt;值。</target>
        </trans-unit>
        <trans-unit id="e7418f4bf29ec0eb129b2a465879400da12bc2de" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt; or &lt;a href=&quot;qsizef&quot;&gt;QSizeF&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;size&lt;/code&gt; value, and vice-versa. When a &lt;code&gt;size&lt;/code&gt; value is passed to C++, it is automatically converted into a &lt;a href=&quot;qsizef&quot;&gt;QSizeF&lt;/a&gt; value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efe91bec14c646d63c8cb49b132911ca4fb70cf2" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt; or &lt;a href=&quot;qsizef&quot;&gt;QSizeF&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;size&lt;/code&gt; value, and vice-versa. When a &lt;code&gt;size&lt;/code&gt; value is passed to C++, it is automatically converted into a &lt;a href=&quot;qsizef&quot;&gt;QSizeF&lt;/a&gt; value.</source>
          <target state="translated">与C ++集成时，请注意，&lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;从C ++传递到QML的&lt;/a&gt;任何&lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt;或&lt;a href=&quot;qsizef&quot;&gt;QSizeF&lt;/a&gt;值都会自动转换为 &lt;code&gt;size&lt;/code&gt; 值，反之亦然。当将 &lt;code&gt;size&lt;/code&gt; 值传递给C ++时，它将自动转换为&lt;a href=&quot;qsizef&quot;&gt;QSizeF&lt;/a&gt;值。</target>
        </trans-unit>
        <trans-unit id="3ce59b6a0f0b4b392e20d60442b247d4ac83798d" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;string&lt;/code&gt; value, and vice-versa.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fd4e1a3e2c35dda93f104508cebf19c9ae03217" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;string&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">与C ++集成时，请注意，&lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;从C ++传递到QML的&lt;/a&gt;任何&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;值都会自动转换为 &lt;code&gt;string&lt;/code&gt; 值，反之亦然。</target>
        </trans-unit>
        <trans-unit id="c9d28617421e54fcce89cbef003fdb53a193660b" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;url&lt;/code&gt; value, and vice-versa.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5784d74b9c118ae7229636ff92faf312a5dfe71" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;url&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">与C ++集成时，请注意，&lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;从C ++传递到QML的&lt;/a&gt;任何&lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt;值都会自动转换为 &lt;code&gt;url&lt;/code&gt; 值，反之亦然。</target>
        </trans-unit>
        <trans-unit id="ed02fd90e62a507cb5dc19431423e1b9374d396b" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;variant&lt;/code&gt; value, and vice-versa.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4782c07688335b98c18e7337dd4cb33a506d5caa" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;variant&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">与C ++集成时，请注意，&lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;从C ++传递到QML的&lt;/a&gt;任何&lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt;值都会自动转换为 &lt;code&gt;variant&lt;/code&gt; 值，反之亦然。</target>
        </trans-unit>
        <trans-unit id="0f08c295ab9d317506d3417a8c5ed2ce92dffe9c" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qvector3d&quot;&gt;QVector3D&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;vector3d&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">与C ++集成时，请注意，&lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;从C ++传递到QML的&lt;/a&gt;任何&lt;a href=&quot;qvector3d&quot;&gt;QVector3D&lt;/a&gt;值都会自动转换为 &lt;code&gt;vector3d&lt;/code&gt; 值，反之亦然。</target>
        </trans-unit>
        <trans-unit id="91da3853e2ebc605267bec0ae228daafb92fc978" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;code&gt;enum&lt;/code&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into an &lt;code&gt;enumeration&lt;/code&gt; value, and vice-versa.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="174229e59467abdea54b7e746d86e6764e7d6c9d" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;code&gt;enum&lt;/code&gt; value &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into an &lt;code&gt;enumeration&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">与C ++集成时，请注意，&lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;从C ++传递到QML的&lt;/a&gt;所有 &lt;code&gt;enum&lt;/code&gt; 值都会自动转换为 &lt;code&gt;enumeration&lt;/code&gt; 值，反之亦然。</target>
        </trans-unit>
        <trans-unit id="f7482e71bbdd52848ddeffbe95fcd0b8e2b5663e" translate="yes" xml:space="preserve">
          <source>When interacted with a mouse device, flicking is disabled and the scroll bars are interactive.</source>
          <target state="translated">当与鼠标设备交互时,禁止轻触,滚动条是交互式的。</target>
        </trans-unit>
        <trans-unit id="8777d7fa43f475169d9e2b3537e4248eaedbf1d8" translate="yes" xml:space="preserve">
          <source>When intermixing &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; and OpenGL, it is important to notify &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; that the OpenGL state may have been cluttered so it can restore its internal state. This is achieved by calling &lt;a href=&quot;qpainter#beginNativePainting&quot;&gt;QPainter::beginNativePainting&lt;/a&gt;() before starting the OpenGL rendering and calling &lt;a href=&quot;qpainter#endNativePainting&quot;&gt;QPainter::endNativePainting&lt;/a&gt;() after finishing.</source>
          <target state="translated">混合&lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;和OpenGL时，重要的是通知&lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; OpenGL状态可能已经杂乱无章，以便可以恢复其内部状态。这是通过调用实现&lt;a href=&quot;qpainter#beginNativePainting&quot;&gt;了QPainter :: beginNativePainting&lt;/a&gt;开始OpenGL渲染和调用（）之前&lt;a href=&quot;qpainter#endNativePainting&quot;&gt;的QPainter :: endNativePainting&lt;/a&gt;（）整理后。</target>
        </trans-unit>
        <trans-unit id="3c3351ce7fa4daf3d510e3944f9c0b1cd89614d0" translate="yes" xml:space="preserve">
          <source>When interoperating with another graphics engine, it may be necessary to get a QRhi instance that uses the same Metal device. This can be achieved by passing a pointer to a &lt;a href=&quot;qrhimetalnativehandles&quot;&gt;QRhiMetalNativeHandles&lt;/a&gt; to &lt;a href=&quot;qrhi#create&quot;&gt;QRhi::create&lt;/a&gt;(). The device must be set to a non-null value then. Optionally, a command queue object can be specified as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61bd4cd2f160b9517401ee938d1cc345306ee16b" translate="yes" xml:space="preserve">
          <source>When invoking QDoc on a project that has dependencies and uses the &lt;code&gt;depends&lt;/code&gt; variable, one or more &lt;code&gt;-indexdir&lt;/code&gt; path(s) must be passed as command line option(s). QDoc uses these paths to search for the dependencies' index files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19950d97cb8c934f1e5c65f401298cb13bebd643" translate="yes" xml:space="preserve">
          <source>When invoking one of these options, or when an error happens (for instance an unknown option was passed), the current process will then stop, using the exit() function.</source>
          <target state="translated">当调用这些选项之一时,或者发生错误时(例如传递了一个未知的选项),当前进程将使用exit()函数停止。</target>
        </trans-unit>
        <trans-unit id="071c0d6d52ee604f468daeb0ab63c0a2099e201d" translate="yes" xml:space="preserve">
          <source>When it comes to more complex controls, it is sometimes better to split them up into separate building blocks. As an example, the complex &lt;a href=&quot;qml-qtquick-controls2-scrollview&quot;&gt;ScrollView&lt;/a&gt; control:</source>
          <target state="translated">当涉及到更复杂的控件时，有时最好将它们分成单独的构建块。例如，复杂的&lt;a href=&quot;qml-qtquick-controls2-scrollview&quot;&gt;ScrollView&lt;/a&gt;控件：</target>
        </trans-unit>
        <trans-unit id="8e8c72fd29bc00795105647d117aa1d234784718" translate="yes" xml:space="preserve">
          <source>When it comes to rendering, deferred rendering is a different beast in terms of renderer configuration compared to forward rendering. Instead of drawing each mesh and applying a shader effect to shade it, deferred rendering adopts a</source>
          <target state="translated">说到渲染,与正向渲染相比,延迟渲染在渲染器配置上是一头不同的野兽。延迟渲染不需要绘制每个网格并应用着色器效果对其进行着色,而是采用了</target>
        </trans-unit>
        <trans-unit id="626ed890d480d0a4b856052f27b67e8d0b322b1a" translate="yes" xml:space="preserve">
          <source>When it comes to texture support, the &lt;a href=&quot;qt3drender-qparameter&quot;&gt;QParameter&lt;/a&gt; value should be set to the appropriate &lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture&lt;/a&gt; subclass that matches the sampler type of the shader uniform.</source>
          <target state="translated">对于纹理支持，&lt;a href=&quot;qt3drender-qparameter&quot;&gt;应将QParameter&lt;/a&gt;值设置为与着色器统一的采样器类型匹配的适当&lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture&lt;/a&gt;子类。</target>
        </trans-unit>
        <trans-unit id="5979b40af94b30c33380148b42cb7fe798d86843" translate="yes" xml:space="preserve">
          <source>When it comes to texture support, the Parameter value should be set to the appropriate &lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;texture&lt;/a&gt; subclass that matches the sampler type of the shader uniform.</source>
          <target state="translated">关于纹理支持，应将&amp;ldquo;参数&amp;rdquo;值设置为与着色器统一的采样器类型匹配的适当&lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;纹理&lt;/a&gt;子类。</target>
        </trans-unit>
        <trans-unit id="71c851f5c2d819a86267b67c443581d3b3d61a3e" translate="yes" xml:space="preserve">
          <source>When it comes to texture support, the QParameter value should be set to the appropriate &lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture&lt;/a&gt; subclass that matches the sampler type of the shader uniform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac390c6893275dbab12f259c5a78a8285bc68bc5" translate="yes" xml:space="preserve">
          <source>When it does not call &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt;, Shape interacts with &lt;a href=&quot;qframe#Shadow-enum&quot;&gt;QFrame::Shadow&lt;/a&gt;, the &lt;a href=&quot;qframe#lineWidth-prop&quot;&gt;lineWidth&lt;/a&gt;() and the &lt;a href=&quot;qframe#midLineWidth-prop&quot;&gt;midLineWidth&lt;/a&gt;() to create the total result. See the picture of the frames in the main class documentation.</source>
          <target state="translated">当它不调用&lt;a href=&quot;qstyle&quot;&gt;QStyle时&lt;/a&gt;，Shape与&lt;a href=&quot;qframe#Shadow-enum&quot;&gt;QFrame :: Shadow&lt;/a&gt;，&lt;a href=&quot;qframe#lineWidth-prop&quot;&gt;lineWidth&lt;/a&gt;（）和&lt;a href=&quot;qframe#midLineWidth-prop&quot;&gt;midLineWidth&lt;/a&gt;（）交互以创建总结果。请参阅主类文档中的框架图片。</target>
        </trans-unit>
        <trans-unit id="4261303376e29e827bb3d9ad715c1736160cb00b" translate="yes" xml:space="preserve">
          <source>When it is necessary to reimplement the &lt;a href=&quot;qaccessibleinterface#child&quot;&gt;QAccessibleInterface::child&lt;/a&gt;() function and returning the child after constructing it, this function needs to be called.</source>
          <target state="translated">当需要重新实现&lt;a href=&quot;qaccessibleinterface#child&quot;&gt;QAccessibleInterface :: child&lt;/a&gt;（）函数并在构造后返回子级时，需要调用此函数。</target>
        </trans-unit>
        <trans-unit id="638905df9b46e03441949d29b36f66dcb7394603" translate="yes" xml:space="preserve">
          <source>When items of data are exported from a model in a drag and drop operation, they are encoded into an appropriate format corresponding to one or more MIME types. Models declare the MIME types that they can use to supply items by reimplementing the &lt;a href=&quot;qabstractitemmodel#mimeTypes&quot;&gt;QAbstractItemModel::mimeTypes&lt;/a&gt;() function, returning a list of standard MIME types.</source>
          <target state="translated">当通过拖放操作从模型中导出数据项时，会将它们编码为与一种或多种MIME类型相对应的适当格式。通过重新实现&lt;a href=&quot;qabstractitemmodel#mimeTypes&quot;&gt;QAbstractItemModel :: mimeTypes&lt;/a&gt;（）函数，并返回标准MIME类型的列表，模型声明了可用于提供项目的MIME类型。</target>
        </trans-unit>
        <trans-unit id="3d596a81dc328e917e2efe8c14460f7b21b5e36e" translate="yes" xml:space="preserve">
          <source>When iterating from 0 and up, it will return the items in the visual arranged order.</source>
          <target state="translated">当从0开始向上迭代时,将按视觉排列顺序返回项目。</target>
        </trans-unit>
        <trans-unit id="f808486c7714b611743ef8e1139711cba9bfa51a" translate="yes" xml:space="preserve">
          <source>When iterating over a &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt;, the items are arbitrarily ordered. With &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt;, the items are always sorted by key.</source>
          <target state="translated">在&lt;a href=&quot;qhash#qhash&quot;&gt;QHash上&lt;/a&gt;迭代时，可以任意排序项目。使用&lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt;，项始终按键排序。</target>
        </trans-unit>
        <trans-unit id="8c6bd39523d6a042b14b93d88385549366872e15" translate="yes" xml:space="preserve">
          <source>When iterating over a &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt;, the items are arbitrarily ordered. With QMap, the items are always sorted by key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8708ebbe834470a66afd3e678569b47f4a25996" translate="yes" xml:space="preserve">
          <source>When iterating over a &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt;, the items are always sorted by key. With &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt;, the items are arbitrarily ordered.</source>
          <target state="translated">在&lt;a href=&quot;qmap&quot;&gt;QMap上进行&lt;/a&gt;迭代时，项始终按键排序。使用&lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt;，可以任意订购商品。</target>
        </trans-unit>
        <trans-unit id="908bbde912a8e2a5301227f6ea15bedbeee803e0" translate="yes" xml:space="preserve">
          <source>When iterating over a &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt;, the items are always sorted by key. With QHash, the items are arbitrarily ordered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a98982cb360d3887455667bec14b4371ac7fe09" translate="yes" xml:space="preserve">
          <source>When kerning is enabled, glyph metrics do not add up anymore, even for Latin text. In other words, the assumption that width('a') + width('b') is equal to width(&quot;ab&quot;) is not neccesairly true.</source>
          <target state="translated">当启用内核时,字形度量不再相加,即使是拉丁文文本。换句话说,width('a')+width('b')等于width(&quot;ab&quot;)的假设不一定正确。</target>
        </trans-unit>
        <trans-unit id="c7c90cd5b86c3de4a86dbc5bca9301f0623600e2" translate="yes" xml:space="preserve">
          <source>When kerning is enabled, glyph metrics do not add up anymore, even for Latin text. In other words, the assumption that width('a') + width('b') is equal to width(&quot;ab&quot;) is not necessarily true.</source>
          <target state="translated">启用内核后,字形指标不再相加,即使是拉丁文文本也是如此。换句话说,宽度('a')+宽度('b')等于宽度(&quot;ab&quot;)的假设不一定正确。</target>
        </trans-unit>
        <trans-unit id="1a521e51c1250eb56a9a96122f4249b5a5690e59" translate="yes" xml:space="preserve">
          <source>When keyboard tracking is disabled, changes are only signalled when focus leaves the text field after edits have modified the content. This allows the user to edit via an invalid date-time to reach a valid one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4935f0a00031f4e75a93ae9dcce7afc6159f9c52" translate="yes" xml:space="preserve">
          <source>When leaving &quot;What's This?&quot; mode, a &lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt; of type Qt::LeaveWhatsThisMode is sent to all toplevel widgets.</source>
          <target state="translated">离开时&amp;ldquo;这是什么？&amp;rdquo; 模式，将Qt :: LeaveWhatsThisMode类型的&lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt;发送到所有顶级小部件。</target>
        </trans-unit>
        <trans-unit id="68c47022708d018c6f6b21000a13611ed6e90869" translate="yes" xml:space="preserve">
          <source>When linking a library, qmake relies on the underlying platform to know what other libraries this library links against. However, if linking statically, qmake will not get this information unless we use the following &lt;code&gt;CONFIG&lt;/code&gt; options:</source>
          <target state="translated">链接库时，qmake依赖基础平台来了解该库链接的其他库。但是，如果静态链接，则除非使用以下 &lt;code&gt;CONFIG&lt;/code&gt; 选项，否则qmake不会获取此信息：</target>
        </trans-unit>
        <trans-unit id="a540dbd6e20238800d7ddd333a082e8843bed862" translate="yes" xml:space="preserve">
          <source>When listening for connections, the address and port on which the server is listening are available as &lt;a href=&quot;qtcpserver#serverAddress&quot;&gt;serverAddress&lt;/a&gt;() and &lt;a href=&quot;qtcpserver#serverPort&quot;&gt;serverPort&lt;/a&gt;().</source>
          <target state="translated">侦听连接时，服务器正在侦听的地址和端口可用作&lt;a href=&quot;qtcpserver#serverAddress&quot;&gt;serverAddress&lt;/a&gt;（）和&lt;a href=&quot;qtcpserver#serverPort&quot;&gt;serverPort&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="e0c7db0652d32fbb04e043b9bb98640d9fdf9268" translate="yes" xml:space="preserve">
          <source>When listening for connections, the address and port on which the server is listening are available as &lt;a href=&quot;qwebsocketserver#serverAddress&quot;&gt;serverAddress&lt;/a&gt;() and &lt;a href=&quot;qwebsocketserver#serverPort&quot;&gt;serverPort&lt;/a&gt;().</source>
          <target state="translated">侦听连接时，服务器正在侦听的地址和端口可用作&lt;a href=&quot;qwebsocketserver#serverAddress&quot;&gt;serverAddress&lt;/a&gt;（）和&lt;a href=&quot;qwebsocketserver#serverPort&quot;&gt;serverPort&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="31ca6375539521ce018e40aba55ef1cfd8ac0a7b" translate="yes" xml:space="preserve">
          <source>When listening for connections, the name which the server is listening on is available through &lt;a href=&quot;qlocalserver#serverName&quot;&gt;serverName&lt;/a&gt;().</source>
          <target state="translated">侦听连接时，可通过&lt;a href=&quot;qlocalserver#serverName&quot;&gt;serverName&lt;/a&gt;（）获得服务器正在侦听的名称。</target>
        </trans-unit>
        <trans-unit id="f562b333fc7588768d7b731fad5e57e2bf351983" translate="yes" xml:space="preserve">
          <source>When loading a QML object into a C++ application, it can be useful to directly embed some C++ data that can be used from within the QML code. This makes it possible, for example, to invoke a C++ method on the embedded object, or use a C++ object instance as a data model for a QML view.</source>
          <target state="translated">当把一个QML对象加载到C++应用程序中时,直接嵌入一些可以在QML代码中使用的C++数据是很有用的。例如,这样就可以在嵌入的对象上调用一个C++方法,或者使用一个C++对象实例作为QML视图的数据模型。</target>
        </trans-unit>
        <trans-unit id="5937553b7180f604506425e217e2f3d3eb8c1b4d" translate="yes" xml:space="preserve">
          <source>When loading the library, &lt;a href=&quot;qlibrary&quot;&gt;QLibrary&lt;/a&gt; searches in all system-specific library locations (for example, &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt; on Unix), unless the file name has an absolute path. After loading the library successfully, fileName() returns the fully-qualified file name of the library, including the full path to the library if one was given in the constructor or passed to setFileName().</source>
          <target state="translated">加载库时，除非文件名具有绝对路径，否则&lt;a href=&quot;qlibrary&quot;&gt;QLibrary会&lt;/a&gt;搜索所有系统特定的库位置（例如，Unix上的 &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt; ）。成功加载库后，fileName（）返回库的标准文件名，如果在构造函数中已指定或传递给setFileName（），则返回库的完整路径。</target>
        </trans-unit>
        <trans-unit id="90725888073e38b3afa3349da5a1b31dfd6e2335" translate="yes" xml:space="preserve">
          <source>When loading the plugin, &lt;a href=&quot;qpluginloader&quot;&gt;QPluginLoader&lt;/a&gt; searches in all plugin locations specified by &lt;a href=&quot;qcoreapplication#libraryPaths&quot;&gt;QCoreApplication::libraryPaths&lt;/a&gt;(), unless the file name has an absolute path. After loading the plugin successfully, fileName() returns the fully-qualified file name of the plugin, including the full path to the plugin if one was given in the constructor or passed to setFileName().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07f1533b7f9a425f6f190f84dd677e6063996b77" translate="yes" xml:space="preserve">
          <source>When loading the plugin, &lt;a href=&quot;qpluginloader&quot;&gt;QPluginLoader&lt;/a&gt; searches in the current directory and in all plugin locations specified by &lt;a href=&quot;qcoreapplication#libraryPaths&quot;&gt;QCoreApplication::libraryPaths&lt;/a&gt;(), unless the file name has an absolute path. After loading the plugin successfully, fileName() returns the fully-qualified file name of the plugin, including the full path to the plugin if one was given in the constructor or passed to setFileName().</source>
          <target state="translated">加载插件时，除非文件名具有绝对路径，否则&lt;a href=&quot;qpluginloader&quot;&gt;QPluginLoader会&lt;/a&gt;在当前目录以及&lt;a href=&quot;qcoreapplication#libraryPaths&quot;&gt;QCoreApplication :: libraryPaths&lt;/a&gt;（）指定的所有插件位置中搜索。成功加载插件后，fileName（）返回插件的全限定文件名，如果在构造函数中已指定或传递给setFileName（），则包括插件的完整路径。</target>
        </trans-unit>
        <trans-unit id="fed00e705cb06cd3fa7ef9acd6a2a5b4614acebf" translate="yes" xml:space="preserve">
          <source>When making OpenGL function calls, it is strongly recommended to avoid calling the functions directly. Instead, prefer using &lt;a href=&quot;https://doc.qt.io/qt-5.13/qopenglfunctions.html&quot;&gt;QOpenGLFunctions&lt;/a&gt; (when making portable applications) or the versioned variants (for example, &lt;a href=&quot;https://doc.qt.io/qt-5.13/qopenglfunctions-3-2-core.html&quot;&gt;QOpenGLFunctions_3_2_Core&lt;/a&gt; and similar, when targeting modern, desktop-only OpenGL). This way the application will work correctly in all Qt build configurations, including the ones that perform dynamic OpenGL implementation loading which means applications are not directly linking to an GL implementation and thus direct function calls are not feasible.</source>
          <target state="translated">进行OpenGL函数调用时，强烈建议避免直接调用函数。相反，当使用现代的仅限桌面的OpenGL时，&lt;a href=&quot;https://doc.qt.io/qt-5.13/qopenglfunctions-3-2-core.html&quot;&gt;最好&lt;/a&gt;使用&lt;a href=&quot;https://doc.qt.io/qt-5.13/qopenglfunctions.html&quot;&gt;QOpenGLFunctions&lt;/a&gt;（在制作便携式应用程序时）或版本化的变体（例如QOpenGLFunctions_3_2_Core等）。这样，应用程序将在所有Qt构建配置中正常工作，包括执行动态OpenGL实现加载的配置，这意味着应用程序未直接链接到GL实现，因此直接函数调用不可行。</target>
        </trans-unit>
        <trans-unit id="f276cbbad1d8799cadf78ef781192531dc7ead31" translate="yes" xml:space="preserve">
          <source>When making OpenGL function calls, it is strongly recommended to avoid calling the functions directly. Instead, prefer using &lt;a href=&quot;https://doc.qt.io/qt-5.15/qopenglfunctions.html&quot;&gt;QOpenGLFunctions&lt;/a&gt; (when making portable applications) or the versioned variants (for example, &lt;a href=&quot;https://doc.qt.io/qt-5.15/qopenglfunctions-3-2-core.html&quot;&gt;QOpenGLFunctions_3_2_Core&lt;/a&gt; and similar, when targeting modern, desktop-only OpenGL). This way the application will work correctly in all Qt build configurations, including the ones that perform dynamic OpenGL implementation loading which means applications are not directly linking to an GL implementation and thus direct function calls are not feasible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7812b8e5267196ba2ad8e65b065aaa80e3d29f0" translate="yes" xml:space="preserve">
          <source>When making a context current using &lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt;, do not check that the &lt;a href=&quot;qobject#thread-affinity&quot;&gt;QObject thread affinity&lt;/a&gt; of the &lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt; object is the same thread calling &lt;a href=&quot;qopenglcontext#makeCurrent&quot;&gt;makeCurrent()&lt;/a&gt;. This value was added in Qt 5.8.</source>
          <target state="translated">制作时使用上下文当前&lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt;，不检查&lt;a href=&quot;qobject#thread-affinity&quot;&gt;QObject的线程关联&lt;/a&gt;的的&lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt;对象是同一个线程调用&lt;a href=&quot;qopenglcontext#makeCurrent&quot;&gt;makeCurrent（） &lt;/a&gt;。这个值是在Qt 5.8中添加的。</target>
        </trans-unit>
        <trans-unit id="3d457ffc5179988c0d911e245311c267b3667157" translate="yes" xml:space="preserve">
          <source>When making the temporary credentials request, the client authenticates using only the client credentials. When making the token request, the client authenticates using the client credentials as well as the temporary credentials. Once the client receives and stores the token credentials, it can proceed to access protected resources on behalf of the resource owner by making authenticated requests using the client credentials together with the token credentials received.</source>
          <target state="translated">当进行临时凭证请求时,客户端只使用客户端凭证进行验证。当进行令牌请求时,客户端使用客户端凭证和临时凭证进行身份验证。客户端收到并存储令牌凭证后,就可以使用客户端凭证和收到的令牌凭证进行认证请求,代表资源所有者访问受保护的资源。</target>
        </trans-unit>
        <trans-unit id="810316d46e7d600660a66af0e59fa7e02d7433b6" translate="yes" xml:space="preserve">
          <source>When managing dynamically created objects, you must ensure the creation context outlives the created object. Otherwise, if the creation context is destroyed first, the bindings and signal handlers in the dynamic object will no longer work.</source>
          <target state="translated">在管理动态创建的对象时,必须确保创建上下文比创建的对象要长。否则,如果创建上下文先被销毁,动态对象中的绑定和信号处理程序将不再工作。</target>
        </trans-unit>
        <trans-unit id="b19286d402c202adf58ff1b66a30b97e15b4a785" translate="yes" xml:space="preserve">
          <source>When manipulating selections, it is often helpful to think of &lt;a href=&quot;qitemselectionmodel&quot;&gt;QItemSelectionModel&lt;/a&gt; as a record of the selection state of all the items in an item model. Once a selection model is set up, collections of items can be selected, deselected, or their selection states can be toggled without the need to know which items are already selected. The indexes of all selected items can be retrieved at any time, and other components can be informed of changes to the selection model via the signals and slots mechanism.</source>
          <target state="translated">操纵选择时，将&lt;a href=&quot;qitemselectionmodel&quot;&gt;QItemSelectionModel&lt;/a&gt;视为项目模型中所有项目的选择状态的记录通常会很有帮助。一旦建立了选择模型，就可以选择，取消选择项目的集合，或者可以切换其选择状态，而无需知道已经选择了哪些项目。可以随时检索所有选定项目的索引，并且可以通过信号和时隙机制将选择模型的更改通知其他组件。</target>
        </trans-unit>
        <trans-unit id="4fe612b6914bd28d3a91c181ce17418b66edda3f" translate="yes" xml:space="preserve">
          <source>When mirroring the layout using either the attached property &lt;a href=&quot;qml-qtquick-layoutmirroring#enabled-prop&quot;&gt;LayoutMirroring::enabled&lt;/a&gt; or by setting the &lt;a href=&quot;qml-qtquick-grid#layoutDirection-prop&quot;&gt;layoutDirection&lt;/a&gt;, the horizontal alignment of items will be mirrored as well. However, the property &lt;code&gt;horizontalItemAlignment&lt;/code&gt; will remain unchanged. To query the effective horizontal alignment of items, use the read-only property &lt;code&gt;effectiveHorizontalItemAlignment&lt;/code&gt;.</source>
          <target state="translated">当使用任一附加属性镜像布局&lt;a href=&quot;qml-qtquick-layoutmirroring#enabled-prop&quot;&gt;LayoutMirroring ::启用&lt;/a&gt;或通过设置&lt;a href=&quot;qml-qtquick-grid#layoutDirection-prop&quot;&gt;的layoutDirection&lt;/a&gt;，物品的水平取向将被镜像为好。但是，属性 &lt;code&gt;horizontalItemAlignment&lt;/code&gt; 将保持不变。要查询项目的有效水平对齐方式，请使用只读属性 &lt;code&gt;effectiveHorizontalItemAlignment&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e9debebd9aa12f2d598528bbeb0d545c66987f90" translate="yes" xml:space="preserve">
          <source>When mixing raw graphics (OpenGL, Vulkan, Metal, etc.) commands with scene graph rendering, it is necessary to call this function after recording commands to the command buffer used by the scene graph to render its main render pass. This is to avoid clobbering state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48e30ffa6a01f7853331128d4cf7b56aeea01dcd" translate="yes" xml:space="preserve">
          <source>When mixing raw graphics (OpenGL, Vulkan, Metal, etc.) commands with scene graph rendering, it is necessary to call this function before recording commands to the command buffer used by the scene graph to render its main render pass. This is to avoid clobbering state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98292e6a711c0a97d142c6900df0dd3a1198f215" translate="yes" xml:space="preserve">
          <source>When model is not explicitly set, it will be synchronized with &lt;a href=&quot;qml-qtquick-controls2-verticalheaderview#syncView-prop&quot;&gt;syncView&lt;/a&gt;'s model once &lt;a href=&quot;qml-qtquick-controls2-verticalheaderview#syncView-prop&quot;&gt;syncView&lt;/a&gt; is set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67c4954bd29b0a4fd959263898f6a26791b7a7d0" translate="yes" xml:space="preserve">
          <source>When model is not explicitly set, the header will use the &lt;a href=&quot;qml-qtquick-controls2-horizontalheaderview#syncView-prop&quot;&gt;syncView&lt;/a&gt;'s model once &lt;a href=&quot;qml-qtquick-controls2-horizontalheaderview#syncView-prop&quot;&gt;syncView&lt;/a&gt; is set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b20aa7e6cd799e3bf7fad3e47e4d5468b0303506" translate="yes" xml:space="preserve">
          <source>When multiple QOpenGLWidgets are added as children to the same top-level widget, their contexts will share with each other. This does not apply for &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt; instances that belong to different windows.</source>
          <target state="translated">将多个QOpenGLWidgets作为子级添加到同一顶级Widget时，它们的上下文将彼此共享。这不适用于属于不同窗口的&lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt;实例。</target>
        </trans-unit>
        <trans-unit id="a052e77d465746dc1474a9b2e904f81e2b5f4c64" translate="yes" xml:space="preserve">
          <source>When multiple QOpenGLWidgets are added as children to the same top-level widget, their contexts will share with each other. This does not apply for QOpenGLWidget instances that belong to different windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be71f48901e09c1cafec1c8d3da6f3f42996e8be" translate="yes" xml:space="preserve">
          <source>When multiple render targets are in use,</source>
          <target state="translated">当使用多个渲染目标时。</target>
        </trans-unit>
        <trans-unit id="cca7faed1dcf3acb3787eb6ed52f3e078b4e846e" translate="yes" xml:space="preserve">
          <source>When multiple selectors could be applied to the same file, the first matching selector is chosen. The order selectors are checked in are:</source>
          <target state="translated">当多个选择器可以应用于同一个文件时,将选择第一个匹配的选择器。选择器被选中的顺序是:</target>
        </trans-unit>
        <trans-unit id="a2d60a792f80124c96dcd07ddb164770dfe0ca59" translate="yes" xml:space="preserve">
          <source>When multiple series are added to a graph, selecting an item in one of them will clear the selection on other series.</source>
          <target state="translated">当多个系列被添加到一个图形中时,选择其中一个系列的项目将清除其他系列的选择。</target>
        </trans-unit>
        <trans-unit id="b98c31c0b36eccbc7c80561d52175a75bcc24aef" translate="yes" xml:space="preserve">
          <source>When multiple textures are attached, the return value is the ID of the first one.</source>
          <target state="translated">当附加多个纹理时,返回值是第一个纹理的ID。</target>
        </trans-unit>
        <trans-unit id="5ea247c1f56cf273fe99668ba49d31b1b499bfbe" translate="yes" xml:space="preserve">
          <source>When multisample antialiasing is used, content rendered into framebuffer objects need additional extensions to support multisampling of framebuffers. Typically &lt;code&gt;GL_EXT_framebuffer_multisample&lt;/code&gt; and &lt;code&gt;GL_EXT_framebuffer_blit&lt;/code&gt;. Most desktop chips have these extensions present, but they are less common in embedded chips. When framebuffer multisampling is not available in the hardware, content rendered into framebuffer objects will not be antialiased, including the content of a &lt;a href=&quot;qml-qtquick-shadereffectsource&quot;&gt;ShaderEffectSource&lt;/a&gt;.</source>
          <target state="translated">使用多重采样抗锯齿时，渲染到帧缓冲区对象中的内容需要额外的扩展以支持帧缓冲区的多重采样。通常为 &lt;code&gt;GL_EXT_framebuffer_multisample&lt;/code&gt; 和 &lt;code&gt;GL_EXT_framebuffer_blit&lt;/code&gt; 。大多数台式机芯片都具有这些扩展名，但是在嵌入式芯片中却很少见。如果硬件中不提供帧缓冲区多重采样，则不会对渲染到帧缓冲区对象中的内容进行抗锯齿处理，包括&lt;a href=&quot;qml-qtquick-shadereffectsource&quot;&gt;ShaderEffectSource&lt;/a&gt;的内容。</target>
        </trans-unit>
        <trans-unit id="fccefc8901100b2f82142ca7d8bb3223d24d7501" translate="yes" xml:space="preserve">
          <source>When navigating the document structure, it is useful to begin at the root frame because it provides access to the entire document structure.</source>
          <target state="translated">在浏览文档结构时,从根框架开始是很有用的,因为它提供了对整个文档结构的访问。</target>
        </trans-unit>
        <trans-unit id="3e0a254e08acf9d6be4fd4d7a634988147b26055" translate="yes" xml:space="preserve">
          <source>When nested opacity gets below a certain threshold, the subtree might be marked as blocked, causing &lt;a href=&quot;qsgnode#isSubtreeBlocked&quot;&gt;isSubtreeBlocked&lt;/a&gt;() to return true. This is done for performance reasons.</source>
          <target state="translated">当嵌套的不透明度低于特定阈值时，子树可能被标记为已阻止，从而导致&lt;a href=&quot;qsgnode#isSubtreeBlocked&quot;&gt;isSubtreeBlocked&lt;/a&gt;（）返回true。这样做是出于性能原因。</target>
        </trans-unit>
        <trans-unit id="4d85ccf2069fc6eae18e11975d88bfe1fadc019f" translate="yes" xml:space="preserve">
          <source>When no windowing system is present, the mouse, keyboard and touch input are read directly via &lt;code&gt;evdev&lt;/code&gt;. Note that this requires that devices nodes &lt;code&gt;/input/event*&lt;/code&gt; are readable by the user. eglfs and vxworksfb has all the evdev input handling code built-in.</source>
          <target state="translated">如果没有窗口系统，则可以通过 &lt;code&gt;evdev&lt;/code&gt; 直接读取鼠标，键盘和触摸输入。请注意，这要求用户可以读取设备节点 &lt;code&gt;/input/event*&lt;/code&gt; 。eglfs和vxworksfb内置了所有evdev输入处理代码。</target>
        </trans-unit>
        <trans-unit id="5b0f164920aba9354f027a11efdb935f7ff22e14" translate="yes" xml:space="preserve">
          <source>When no windowing system is present, the mouse, keyboard, and touch input are read directly via &lt;code&gt;evdev&lt;/code&gt; or using helper libraries such as &lt;code&gt;libinput&lt;/code&gt; or &lt;code&gt;tslib&lt;/code&gt;. Note that this requires that device nodes &lt;code&gt;/dev/input/event*&lt;/code&gt; are readable by the user. &lt;code&gt;eglfs&lt;/code&gt; and &lt;code&gt;linuxfb&lt;/code&gt; have all the input handling code compiled-in.</source>
          <target state="translated">如果没有窗口系统，则可以通过 &lt;code&gt;evdev&lt;/code&gt; 或使用诸如 &lt;code&gt;libinput&lt;/code&gt; 或 &lt;code&gt;tslib&lt;/code&gt; 之类的帮助程序库直接读取鼠标，键盘和触摸输入。请注意，这要求用户可以读取设备节点 &lt;code&gt;/dev/input/event*&lt;/code&gt; 。 &lt;code&gt;eglfs&lt;/code&gt; 和 &lt;code&gt;linuxfb&lt;/code&gt; 具有所有已编译的输入处理代码。</target>
        </trans-unit>
        <trans-unit id="18d39e71149ec53d71da5bdfa496288bb4064e73" translate="yes" xml:space="preserve">
          <source>When not running with the RHI (and using OpenGL directly), the signal is emitted after the renderer has cleared the render target. This makes it possible to create applications that function identically both with and without the RHI.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0721c385a99233431f8667a3ee0ae4fedf149b4" translate="yes" xml:space="preserve">
          <source>When not running with the RHI (and using OpenGL directly), the signal is emitted after the renderer has finished its rendering, but before &lt;a href=&quot;qquickwindow#afterRendering&quot;&gt;afterRendering&lt;/a&gt;(). This makes it possible to create applications that function identically both with and without the RHI.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dca5d911ae2265eef32ee4fee8077e25696a9db8" translate="yes" xml:space="preserve">
          <source>When one of the statements is a non-select statement a count of affected rows may be available instead of a result set.</source>
          <target state="translated">当其中一条语句是非选择语句时,可能会有受影响行的计数,而不是结果集。</target>
        </trans-unit>
        <trans-unit id="e9136aaa0ef09df9e9f07e3241b2a9f838fd494d" translate="yes" xml:space="preserve">
          <source>When operating in deterministic mode, &lt;a href=&quot;qrandomgenerator&quot;&gt;QRandomGenerator&lt;/a&gt; may be used for bulk data generation. In fact, applications that do not need cryptographically-secure or true random data are advised to use a regular &lt;a href=&quot;qrandomgenerator&quot;&gt;QRandomGenerator&lt;/a&gt; instead of &lt;a href=&quot;qrandomgenerator#system&quot;&gt;QRandomGenerator::system&lt;/a&gt;() for their random data needs.</source>
          <target state="translated">在确定性模式下运行时，&lt;a href=&quot;qrandomgenerator&quot;&gt;QRandomGenerator&lt;/a&gt;可用于批量数据生成。实际上，建议不需要密码安全或真实随机数据的应用程序使用常规&lt;a href=&quot;qrandomgenerator&quot;&gt;QRandomGenerator&lt;/a&gt;代替&lt;a href=&quot;qrandomgenerator#system&quot;&gt;QRandomGenerator :: system&lt;/a&gt;（）来满足其随机数据需求。</target>
        </trans-unit>
        <trans-unit id="601025c900ae42d4debb597407723c06012bd462" translate="yes" xml:space="preserve">
          <source>When operating in deterministic mode, QRandomGenerator may be used for bulk data generation. In fact, applications that do not need cryptographically-secure or true random data are advised to use a regular QRandomGenerator instead of &lt;a href=&quot;qrandomgenerator#system&quot;&gt;QRandomGenerator::system&lt;/a&gt;() for their random data needs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca0c853a6a3df272210d1c9d0c36c813572cdfe7" translate="yes" xml:space="preserve">
          <source>When operating on managed objects in normal C++ code, a little extra care must be taken because of the CLR's garbage collection. A normal pointer variable should not</source>
          <target state="translated">在正常的C++代码中对托管对象进行操作时,由于CLR的垃圾回收,必须格外小心。一个普通的指针变量不应该</target>
        </trans-unit>
        <trans-unit id="ea7e897063825784978303959c1455b5d44412c2" translate="yes" xml:space="preserve">
          <source>When options can be grouped, you can use a partially checked &lt;a href=&quot;qml-qtquick-controls2-checkbox&quot;&gt;CheckBox&lt;/a&gt; to represent the whole group. Use the checkbox's &lt;a href=&quot;qml-qtquick-controls2-checkbox#checkState-prop&quot;&gt;partially checked state&lt;/a&gt; when a user selects some, but not all, sub-items in the group.</source>
          <target state="translated">如果可以对选项进行分组，则可以使用部分选中的&lt;a href=&quot;qml-qtquick-controls2-checkbox&quot;&gt;CheckBox&lt;/a&gt;代表整个组。当用户选择组中的一些而非全部子项时，请使用复选框的&lt;a href=&quot;qml-qtquick-controls2-checkbox#checkState-prop&quot;&gt;部分选中状态&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fe4c38cfe45b7ff5d5ad3092c911b19539b422d2" translate="yes" xml:space="preserve">
          <source>When painting to a &lt;a href=&quot;qopenglpaintdevice&quot;&gt;QOpenGLPaintDevice&lt;/a&gt; using &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;, the state of the current OpenGL context will be altered by the paint engine to reflect its needs. Applications should not rely upon the OpenGL state being reset to its original conditions, particularly the current shader program, OpenGL viewport, texture units, and drawing modes.</source>
          <target state="translated">使用&lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;绘画到&lt;a href=&quot;qopenglpaintdevice&quot;&gt;QOpenGLPaintDevice&lt;/a&gt;时，绘画引擎将更改当前OpenGL上下文的状态以反映其需求。应用程序不应依赖于将OpenGL状态重置为其原始状态，尤其是当前的着色器程序，OpenGL视口，纹理单位和绘图模式。</target>
        </trans-unit>
        <trans-unit id="76720392a96856f8c1e5f2c5c0b848262c8e8089" translate="yes" xml:space="preserve">
          <source>When painting to a QOpenGLPaintDevice using &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;, the state of the current OpenGL context will be altered by the paint engine to reflect its needs. Applications should not rely upon the OpenGL state being reset to its original conditions, particularly the current shader program, OpenGL viewport, texture units, and drawing modes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e4b844ee7e4c5be1b0dab1bbe7aaa712b977db0" translate="yes" xml:space="preserve">
          <source>When paused, the current frame can be advanced manually by setting this property or calling &lt;a href=&quot;qml-qtquick-animatedsprite#advance-method&quot;&gt;advance()&lt;/a&gt;.</source>
          <target state="translated">暂停后，可以通过设置此属性或调用&lt;a href=&quot;qml-qtquick-animatedsprite#advance-method&quot;&gt;advance（）&lt;/a&gt;来手动推进当前帧。</target>
        </trans-unit>
        <trans-unit id="36bc00e334ac8aa1eea3755d12934f7608da4dea" translate="yes" xml:space="preserve">
          <source>When paused, the current frame can be advanced manually.</source>
          <target state="translated">暂停时,可手动推进当前帧。</target>
        </trans-unit>
        <trans-unit id="40753593df1bbb77361dbb8a61ae51ec564eb417" translate="yes" xml:space="preserve">
          <source>When performing a lookup on a service, zero or more records will be returned. Each record is represented by a &lt;a href=&quot;qdnsmailexchangerecord&quot;&gt;QDnsMailExchangeRecord&lt;/a&gt; instance.</source>
          <target state="translated">在服务上执行查找时，将返回零个或多个记录。每个记录均由&lt;a href=&quot;qdnsmailexchangerecord&quot;&gt;QDnsMailExchangeRecord&lt;/a&gt;实例表示。</target>
        </trans-unit>
        <trans-unit id="745159504ea8964595662dfda6ea6803520cab14" translate="yes" xml:space="preserve">
          <source>When performing a lookup on a service, zero or more records will be returned. Each record is represented by a &lt;a href=&quot;qdnsservicerecord&quot;&gt;QDnsServiceRecord&lt;/a&gt; instance.</source>
          <target state="translated">在服务上执行查找时，将返回零个或多个记录。每个记录由一个&lt;a href=&quot;qdnsservicerecord&quot;&gt;QDnsServiceRecord&lt;/a&gt;实例表示。</target>
        </trans-unit>
        <trans-unit id="6d6001a94eae9d4e4679d672b10ebf1476ba4b97" translate="yes" xml:space="preserve">
          <source>When performing a lookup on a service, zero or more records will be returned. Each record is represented by a QDnsMailExchangeRecord instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="183c9e6bf9945fe2d7c4f1ece374cc4634d591ca" translate="yes" xml:space="preserve">
          <source>When performing a lookup on a service, zero or more records will be returned. Each record is represented by a QDnsServiceRecord instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89b6dd291204471e81a34c81e897e2eae987238a" translate="yes" xml:space="preserve">
          <source>When performing a name server lookup, zero or more records will be returned. Each record is represented by a &lt;a href=&quot;qdnsdomainnamerecord&quot;&gt;QDnsDomainNameRecord&lt;/a&gt; instance.</source>
          <target state="translated">执行名称服务器查找时，将返回零个或多个记录。每个记录由一个&lt;a href=&quot;qdnsdomainnamerecord&quot;&gt;QDnsDomainNameRecord&lt;/a&gt;实例表示。</target>
        </trans-unit>
        <trans-unit id="d31385d56b863dd8dbd104e645dc9977d21a36cc" translate="yes" xml:space="preserve">
          <source>When performing a name server lookup, zero or more records will be returned. Each record is represented by a QDnsDomainNameRecord instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3612e920959430b2f4633a7ed7ecb7c74231f462" translate="yes" xml:space="preserve">
          <source>When performing a text lookup, zero or more records will be returned. Each record is represented by a &lt;a href=&quot;qdnstextrecord&quot;&gt;QDnsTextRecord&lt;/a&gt; instance.</source>
          <target state="translated">执行文本查找时，将返回零个或多个记录。每个记录由一个&lt;a href=&quot;qdnstextrecord&quot;&gt;QDnsTextRecord&lt;/a&gt;实例表示。</target>
        </trans-unit>
        <trans-unit id="909f4885c9471951ef724c0551ca405b8644c385" translate="yes" xml:space="preserve">
          <source>When performing a text lookup, zero or more records will be returned. Each record is represented by a QDnsTextRecord instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="711a9f71466771c6e4aade7928b9960c7cefd54f" translate="yes" xml:space="preserve">
          <source>When performing an address lookup, zero or more records will be returned. Each record is represented by a &lt;a href=&quot;qdnshostaddressrecord&quot;&gt;QDnsHostAddressRecord&lt;/a&gt; instance.</source>
          <target state="translated">执行地址查找时，将返回零个或多个记录。每个记录由一个&lt;a href=&quot;qdnshostaddressrecord&quot;&gt;QDnsHostAddressRecord&lt;/a&gt;实例表示。</target>
        </trans-unit>
        <trans-unit id="be3ad2654f5fa7ba6e1f52aec206ab62cc47cc26" translate="yes" xml:space="preserve">
          <source>When performing an address lookup, zero or more records will be returned. Each record is represented by a QDnsHostAddressRecord instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63db06c50e58a3513cea1497dec1ed7741831f0b" translate="yes" xml:space="preserve">
          <source>When performing drawing using &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; only, it is also possible to perform the painting like it is done for ordinary widgets: by reimplementing &lt;a href=&quot;qopenglwidget#paintEvent&quot;&gt;paintEvent&lt;/a&gt;().</source>
          <target state="translated">仅使用&lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;执行绘图时，还可以像执行普通小部件一样执行绘图：通过重新实现&lt;a href=&quot;qopenglwidget#paintEvent&quot;&gt;paintEvent&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="4873852a94448fd952353de01e74e6bb7112405f" translate="yes" xml:space="preserve">
          <source>When performing verification steps in an autotest using &lt;a href=&quot;qtest#QCOMPARE&quot;&gt;QCOMPARE&lt;/a&gt;(), &lt;a href=&quot;qtest#QVERIFY&quot;&gt;QVERIFY&lt;/a&gt;(), and so on, side-effects should be avoided. Side-effects in verification steps can make a test difficult to understand. Also, they can easily break a test in ways that are difficult to diagnose when the test is changed to use &lt;a href=&quot;qtest#QTRY_VERIFY&quot;&gt;QTRY_VERIFY&lt;/a&gt;(), &lt;a href=&quot;qtest#QTRY_COMPARE&quot;&gt;QTRY_COMPARE&lt;/a&gt;() or &lt;a href=&quot;qtest#QBENCHMARK&quot;&gt;QBENCHMARK&lt;/a&gt;(). These can execute the passed expression multiple times, thus repeating any side-effects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38db5be01962103a3cc7ed36e0dd26d7c49283ec" translate="yes" xml:space="preserve">
          <source>When placed into a &lt;code&gt;.qml&lt;/code&gt; file and loaded by the QML engine, the above code creates a &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; object using the &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; type supplied by the &lt;code&gt;QtQuick&lt;/code&gt; module:</source>
          <target state="translated">当放置到 &lt;code&gt;.qml&lt;/code&gt; 文件中并由QML引擎加载时，以上代码使用 &lt;code&gt;QtQuick&lt;/code&gt; 模块提供的&lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt;类型创建&lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt;对象：</target>
        </trans-unit>
        <trans-unit id="6927c0eac9201c4bf4c31b692534ebe1bbcfa831" translate="yes" xml:space="preserve">
          <source>When populating a layout, the widgets are added to an internal list. The &lt;a href=&quot;qlayout#indexOf&quot;&gt;indexOf&lt;/a&gt;() function returns the index of a widget in that list. The widgets can either be added to the end of the list using the &lt;a href=&quot;qstackedlayout#addWidget&quot;&gt;addWidget&lt;/a&gt;() function, or inserted at a given index using the &lt;a href=&quot;qstackedlayout#insertWidget&quot;&gt;insertWidget&lt;/a&gt;() function. The &lt;a href=&quot;qlayout#removeWidget&quot;&gt;removeWidget&lt;/a&gt;() function removes the widget at the given index from the layout. The number of widgets contained in the layout, can be obtained using the &lt;a href=&quot;qstackedlayout#count-prop&quot;&gt;count&lt;/a&gt;() function.</source>
          <target state="translated">填充布局时，小部件将添加到内部列表中。该&lt;a href=&quot;qlayout#indexOf&quot;&gt;的indexOf&lt;/a&gt;（）函数返回该列表中的控件的索引。窗口小部件可以被添加到使用列表的末尾&lt;a href=&quot;qstackedlayout#addWidget&quot;&gt;addWidget&lt;/a&gt;（）函数，或插入使用一个给定的索引处&lt;a href=&quot;qstackedlayout#insertWidget&quot;&gt;insertWidget&lt;/a&gt;（）函数。所述&lt;a href=&quot;qlayout#removeWidget&quot;&gt;removeWidget&lt;/a&gt;（）函数将删除布局给定索引处的窗口小部件。可以使用&lt;a href=&quot;qstackedlayout#count-prop&quot;&gt;count&lt;/a&gt;（）函数获取布局中包含的小部件数量。</target>
        </trans-unit>
        <trans-unit id="9c28b221f7e83baed059e2a307e039e7c948b005" translate="yes" xml:space="preserve">
          <source>When populating a stacked widget, the widgets are added to an internal list. The &lt;a href=&quot;qstackedwidget#indexOf&quot;&gt;indexOf&lt;/a&gt;() function returns the index of a widget in that list. The widgets can either be added to the end of the list using the &lt;a href=&quot;qstackedwidget#addWidget&quot;&gt;addWidget&lt;/a&gt;() function, or inserted at a given index using the &lt;a href=&quot;qstackedwidget#insertWidget&quot;&gt;insertWidget&lt;/a&gt;() function. The &lt;a href=&quot;qstackedwidget#removeWidget&quot;&gt;removeWidget&lt;/a&gt;() function removes a widget from the stacked widget. The number of widgets contained in the stacked widget can be obtained using the &lt;a href=&quot;qstackedwidget#count-prop&quot;&gt;count&lt;/a&gt;() function.</source>
          <target state="translated">当填充堆叠的窗口小部件时，这些窗口小部件将添加到内部列表中。该&lt;a href=&quot;qstackedwidget#indexOf&quot;&gt;的indexOf&lt;/a&gt;（）函数返回该列表中的控件的索引。窗口小部件可以被添加到使用列表的末尾&lt;a href=&quot;qstackedwidget#addWidget&quot;&gt;addWidget&lt;/a&gt;（）函数，或插入使用一个给定的索引处&lt;a href=&quot;qstackedwidget#insertWidget&quot;&gt;insertWidget&lt;/a&gt;（）函数。所述&lt;a href=&quot;qstackedwidget#removeWidget&quot;&gt;removeWidget&lt;/a&gt;（）函数删除从层叠微件的微件。可以使用&lt;a href=&quot;qstackedwidget#count-prop&quot;&gt;count&lt;/a&gt;（）函数获取堆叠的小部件中包含的小部件的数量。</target>
        </trans-unit>
        <trans-unit id="543155192f84c64b5b7246452a09145b18b3004c" translate="yes" xml:space="preserve">
          <source>When popup windows are visible, this property is &lt;code&gt;true&lt;/code&gt; for both the active window</source>
          <target state="translated">当弹出窗口可见时，此属性对于两个活动窗口均为 &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bf9f03d6670f0731b056deb6a40d087fcc1eaf19" translate="yes" xml:space="preserve">
          <source>When positioning a menu with &lt;a href=&quot;qmenu#exec&quot;&gt;exec&lt;/a&gt;() or &lt;a href=&quot;qmenu#popup&quot;&gt;popup&lt;/a&gt;(), bear in mind that you cannot rely on the menu's current &lt;a href=&quot;qwidget#size-prop&quot;&gt;size&lt;/a&gt;(). For performance reasons, the menu adapts its size only when necessary. So in many cases, the size before and after the show is different. Instead, use &lt;a href=&quot;qmenu#sizeHint&quot;&gt;sizeHint&lt;/a&gt;() which calculates the proper size depending on the menu's current contents.</source>
          <target state="translated">使用&lt;a href=&quot;qmenu#exec&quot;&gt;exec&lt;/a&gt;（）或&lt;a href=&quot;qmenu#popup&quot;&gt;popup&lt;/a&gt;（）定位菜单时，请记住，您不能依赖菜单的当前&lt;a href=&quot;qwidget#size-prop&quot;&gt;大小&lt;/a&gt;（）。出于性能原因，菜单仅在必要时才调整其大小。因此，在很多情况下，演出前后的尺寸是不同的。而是使用&lt;a href=&quot;qmenu#sizeHint&quot;&gt;sizeHint&lt;/a&gt;（）来根据菜单的当前内容计算适当的大小。</target>
        </trans-unit>
        <trans-unit id="d446cf9e4868843729e697b92b7ac122b7540da1" translate="yes" xml:space="preserve">
          <source>When positioning a menu with &lt;a href=&quot;qmenu#exec&quot;&gt;exec&lt;/a&gt;() or popup(), bear in mind that you cannot rely on the menu's current &lt;a href=&quot;qwidget#size-prop&quot;&gt;size&lt;/a&gt;(). For performance reasons, the menu adapts its size only when necessary, so in many cases, the size before and after the show is different. Instead, use &lt;a href=&quot;qmenu#sizeHint&quot;&gt;sizeHint&lt;/a&gt;() which calculates the proper size depending on the menu's current contents.</source>
          <target state="translated">使用&lt;a href=&quot;qmenu#exec&quot;&gt;exec&lt;/a&gt;（）或popup（）定位菜单时，请记住您不能依赖菜单的当前&lt;a href=&quot;qwidget#size-prop&quot;&gt;大小&lt;/a&gt;（）。出于性能原因，菜单仅在必要时才调整其大小，因此在许多情况下，显示前后的大小是不同的。而是使用&lt;a href=&quot;qmenu#sizeHint&quot;&gt;sizeHint&lt;/a&gt;（）来根据菜单的当前内容计算适当的大小。</target>
        </trans-unit>
        <trans-unit id="7029c6cc034ef3f728d2bd0679222f0a517d5042" translate="yes" xml:space="preserve">
          <source>When positioning a menu with exec() or &lt;a href=&quot;qmenu#popup&quot;&gt;popup&lt;/a&gt;(), bear in mind that you cannot rely on the menu's current &lt;a href=&quot;qwidget#size-prop&quot;&gt;size&lt;/a&gt;(). For performance reasons, the menu adapts its size only when necessary. So in many cases, the size before and after the show is different. Instead, use &lt;a href=&quot;qmenu#sizeHint&quot;&gt;sizeHint&lt;/a&gt;() which calculates the proper size depending on the menu's current contents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b83e6f455038d9e44dcc627b24af2f87bdc39ec9" translate="yes" xml:space="preserve">
          <source>When possible, it is usually better style to disable the &lt;b&gt;Next&lt;/b&gt; or &lt;b&gt;Finish&lt;/b&gt; button (by specifying &lt;a href=&quot;qwizard#mandatory-fields&quot;&gt;mandatory fields&lt;/a&gt; or by reimplementing &lt;a href=&quot;qwizardpage#isComplete&quot;&gt;QWizardPage::isComplete&lt;/a&gt;()) than to reimplement validateCurrentPage().</source>
          <target state="translated">如果可能的话，禁用&amp;ldquo; &lt;b&gt;下一步&amp;rdquo;&lt;/b&gt;或&amp;ldquo; &lt;b&gt;完成&amp;rdquo;&lt;/b&gt;按钮（通过指定&lt;a href=&quot;qwizard#mandatory-fields&quot;&gt;必填字段&lt;/a&gt;或重新实现&lt;a href=&quot;qwizardpage#isComplete&quot;&gt;QWizardPage :: isComplete&lt;/a&gt;（））通常比重新实现validateCurrentPage（）更好。</target>
        </trans-unit>
        <trans-unit id="73d1c2ff7aa2a64e8d25144a78e96a2f710b582a" translate="yes" xml:space="preserve">
          <source>When possible, it is usually better style to disable the &lt;b&gt;Next&lt;/b&gt; or &lt;b&gt;Finish&lt;/b&gt; button (by specifying &lt;a href=&quot;qwizard#mandatory-fields&quot;&gt;mandatory fields&lt;/a&gt; or reimplementing &lt;a href=&quot;qwizardpage#isComplete&quot;&gt;isComplete&lt;/a&gt;()) than to reimplement validatePage().</source>
          <target state="translated">如果可能的话，禁用&amp;ldquo; &lt;b&gt;下一步&amp;rdquo;&lt;/b&gt;或&amp;ldquo; &lt;b&gt;完成&amp;rdquo;&lt;/b&gt;按钮（通过指定&lt;a href=&quot;qwizard#mandatory-fields&quot;&gt;必填字段&lt;/a&gt;或重新实现&lt;a href=&quot;qwizardpage#isComplete&quot;&gt;isComplete&lt;/a&gt;（））通常比重新实现validatePage（）更好。</target>
        </trans-unit>
        <trans-unit id="4c25870dd84e6151f006f88996bd899f2da5153f" translate="yes" xml:space="preserve">
          <source>When possible, this static function will use the native file dialog and not a &lt;a href=&quot;qfiledialog&quot;&gt;QFileDialog&lt;/a&gt;. On platforms which don't support selecting remote files, Qt will allow to select only local files.</source>
          <target state="translated">如果可能，此静态函数将使用本机文件对话框，而不使用&lt;a href=&quot;qfiledialog&quot;&gt;QFileDialog&lt;/a&gt;。在不支持选择远程文件的平台上，Qt将仅允许选择本地文件。</target>
        </trans-unit>
        <trans-unit id="0b489fbd5401aea28516b412c3104164f51acbe1" translate="yes" xml:space="preserve">
          <source>When posting a custom event to the state machine, you typically also have one or more custom transitions that can be triggered from events of that type. To create such a transition, you subclass &lt;a href=&quot;qabstracttransition&quot;&gt;QAbstractTransition&lt;/a&gt; and reimplement &lt;a href=&quot;qabstracttransition#eventTest&quot;&gt;QAbstractTransition::eventTest&lt;/a&gt;(), where you check if an event matches your event type (and optionally other criteria, e.g. attributes of the event object).</source>
          <target state="translated">将自定义事件发布到状态机时，通常还具有一个或多个可从该类型的事件触发的自定义转换。要创建这样的过渡，请子类化&lt;a href=&quot;qabstracttransition&quot;&gt;QAbstractTransition&lt;/a&gt;并重新实现&lt;a href=&quot;qabstracttransition#eventTest&quot;&gt;QAbstractTransition :: eventTest&lt;/a&gt;（），在其中检查事件是否与事件类型（以及可选的其他条件，例如事件对象的属性）匹配。</target>
        </trans-unit>
        <trans-unit id="c0626bfe8658560f4b9456379db258ae7347f2e4" translate="yes" xml:space="preserve">
          <source>When present in a state set, enables the seamless cubemap texture filtering as provided by the GL_ARB_seamless_cubemap extension (if available).</source>
          <target state="translated">在状态集中存在时,启用GL_ARB_seamless_cubemap扩展提供的无缝cubemap纹理过滤功能(如果可用)。</target>
        </trans-unit>
        <trans-unit id="dd42c97f91ca6cd533ba12641c6d6512a8021b98" translate="yes" xml:space="preserve">
          <source>When pressing the &quot;Pick Screen Color&quot; button, the cursor changes to a haircross and the colors on the screen are scanned. The user can pick up one by clicking the mouse or the Enter button. Pressing Escape restores the last color selected before entering this mode.</source>
          <target state="translated">当按下 &quot;拾取屏幕颜色 &quot;按钮时,光标会变成一个发叉,并扫描屏幕上的颜色。用户可以通过点击鼠标或回车键选取一种。按 &quot;Escape &quot;键可恢复进入该模式前最后选择的颜色。</target>
        </trans-unit>
        <trans-unit id="365ed507c80ed465082d4faf723c11a4f4a529f9" translate="yes" xml:space="preserve">
          <source>When printing directly to a printer on Windows or &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, &lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt; uses the built-in printer drivers. On X11, &lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt; uses the &lt;a href=&quot;http://www.cups.org/&quot;&gt;Common Unix Printing System (CUPS)&lt;/a&gt; to send PDF output to the printer. As an alternative, the &lt;a href=&quot;qprinter#printProgram&quot;&gt;printProgram&lt;/a&gt;() function can be used to specify the command or utility to use instead of the system default.</source>
          <target state="translated">在Windows或&lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;上直接打印到打印机时，&lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt;使用内置的打印机驱动程序。在X11上，&lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt;使用&lt;a href=&quot;http://www.cups.org/&quot;&gt;通用Unix打印系统（CUPS）&lt;/a&gt;将PDF输出发送到打印机。或者，可以使用&lt;a href=&quot;qprinter#printProgram&quot;&gt;printProgram&lt;/a&gt;（）函数来指定要使用的命令或实用程序，而不是系统默认值。</target>
        </trans-unit>
        <trans-unit id="9cee561b8e10ced76ed482af9619144ea4d1c14b" translate="yes" xml:space="preserve">
          <source>When printing directly to a printer on Windows or macOS, QPrinter uses the built-in printer drivers. On X11, QPrinter uses the &lt;a href=&quot;http://www.cups.org/&quot;&gt;Common Unix Printing System (CUPS)&lt;/a&gt; to send PDF output to the printer. As an alternative, the &lt;a href=&quot;qprinter#printProgram&quot;&gt;printProgram&lt;/a&gt;() function can be used to specify the command or utility to use instead of the system default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7baf1526ab727030bb94d023b433c10155cb76be" translate="yes" xml:space="preserve">
          <source>When processing</source>
          <target state="translated">处理时</target>
        </trans-unit>
        <trans-unit id="6d2106bb45d40ac84dd2228f91e6e53dfdbe85fe" translate="yes" xml:space="preserve">
          <source>When processing any of the \code, &lt;a href=&quot;#newcode-command&quot;&gt;\newcode&lt;/a&gt; or &lt;a href=&quot;#oldcode-command&quot;&gt;\oldcode&lt;/a&gt; commands, QDoc removes all indentation that is common for the verbatim code blocks within a &lt;code&gt;/&lt;/code&gt;&lt;code&gt;*!&lt;/code&gt; ... &lt;code&gt;*&lt;/code&gt;&lt;code&gt;/&lt;/code&gt; comment before it adds the standard indentation.</source>
          <target state="translated">当处理任何\ code，&lt;a href=&quot;#newcode-command&quot;&gt;\ newcode&lt;/a&gt;或&lt;a href=&quot;#oldcode-command&quot;&gt;\ oldcode&lt;/a&gt;命令时，QDoc会删除 &lt;code&gt;/&lt;/code&gt; &lt;code&gt;*!&lt;/code&gt; 内逐字代码块通用的所有缩进！... &lt;code&gt;*&lt;/code&gt; &lt;code&gt;/&lt;/code&gt; 在添加标准缩进之前添加注释。</target>
        </trans-unit>
        <trans-unit id="8ac017cc68b793557123c9ce971931fa3dec416c" translate="yes" xml:space="preserve">
          <source>When processing any of the \code, &lt;a href=&quot;06-qdoc-commands-includecodeinline#newcode-command&quot;&gt;\newcode&lt;/a&gt; or &lt;a href=&quot;06-qdoc-commands-includecodeinline#oldcode-command&quot;&gt;\oldcode&lt;/a&gt; commands, QDoc removes all indentation that is common for the verbatim code blocks within a &lt;code&gt;/&lt;/code&gt;&lt;code&gt;*!&lt;/code&gt; ... &lt;code&gt;*&lt;/code&gt;&lt;code&gt;/&lt;/code&gt; comment before it adds the standard indentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cc162586167c5dda9673822a3e347c76baa904e" translate="yes" xml:space="preserve">
          <source>When processing the &lt;code&gt;headers&lt;/code&gt; variable, QDoc behaves in the same way as it does when processing the &lt;a href=&quot;#headerdirs&quot;&gt;&lt;code&gt;headerdirs&lt;/code&gt;&lt;/a&gt; variable. For more information, see the &lt;a href=&quot;#headerdirs&quot;&gt;&lt;code&gt;headerdirs&lt;/code&gt;&lt;/a&gt; variable.</source>
          <target state="translated">在处理 &lt;code&gt;headers&lt;/code&gt; 变量时，QDoc的行为与处理&lt;a href=&quot;#headerdirs&quot;&gt; &lt;code&gt;headerdirs&lt;/code&gt; &lt;/a&gt;变量时的行为相同。有关更多信息，请参见&lt;a href=&quot;#headerdirs&quot;&gt; &lt;code&gt;headerdirs&lt;/code&gt; &lt;/a&gt;变量。</target>
        </trans-unit>
        <trans-unit id="9f6649e82a5699a0360075ae40dd46b9e5c7a464" translate="yes" xml:space="preserve">
          <source>When processing the &lt;code&gt;headers&lt;/code&gt; variable, QDoc behaves in the same way as it does when processing the &lt;a href=&quot;22-qdoc-configuration-generalvariables#headerdirs&quot;&gt;&lt;code&gt;headerdirs&lt;/code&gt;&lt;/a&gt; variable. For more information, see the &lt;a href=&quot;22-qdoc-configuration-generalvariables#headerdirs&quot;&gt;&lt;code&gt;headerdirs&lt;/code&gt;&lt;/a&gt; variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8485caf25338b1f76aa184669dce3005f004482c" translate="yes" xml:space="preserve">
          <source>When processing the &lt;code&gt;images&lt;/code&gt; variable, QDoc behaves in the same way as it does when processing the &lt;a href=&quot;#imagedirs&quot;&gt;&lt;code&gt;imagedirs&lt;/code&gt;&lt;/a&gt; variable. For more information, see the &lt;a href=&quot;#imagedirs&quot;&gt;&lt;code&gt;imagedirs&lt;/code&gt;&lt;/a&gt; variable.</source>
          <target state="translated">处理 &lt;code&gt;images&lt;/code&gt; 变量时，QDoc的行为与处理&lt;a href=&quot;#imagedirs&quot;&gt; &lt;code&gt;imagedirs&lt;/code&gt; &lt;/a&gt;变量时的行为相同。有关更多信息，请参见&lt;a href=&quot;#imagedirs&quot;&gt; &lt;code&gt;imagedirs&lt;/code&gt; &lt;/a&gt;变量。</target>
        </trans-unit>
        <trans-unit id="83b7b87983b264f92514be824ef568bf74fc4531" translate="yes" xml:space="preserve">
          <source>When processing the &lt;code&gt;images&lt;/code&gt; variable, QDoc behaves in the same way as it does when processing the &lt;a href=&quot;22-qdoc-configuration-generalvariables#imagedirs&quot;&gt;&lt;code&gt;imagedirs&lt;/code&gt;&lt;/a&gt; variable. For more information, see the &lt;a href=&quot;22-qdoc-configuration-generalvariables#imagedirs&quot;&gt;&lt;code&gt;imagedirs&lt;/code&gt;&lt;/a&gt; variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02ac4cb127779361e46edccdd9715135c772a6b4" translate="yes" xml:space="preserve">
          <source>When processing the &lt;code&gt;sources&lt;/code&gt; variable, QDoc behaves in the same way as it does when processing the &lt;a href=&quot;#sourcedirs-variable&quot;&gt;sourcedirs&lt;/a&gt; variable. For more information, see the &lt;a href=&quot;#sourcedirs-variable&quot;&gt;sourcedirs&lt;/a&gt; variable.</source>
          <target state="translated">处理 &lt;code&gt;sources&lt;/code&gt; 变量时，QDoc的行为与处理&lt;a href=&quot;#sourcedirs-variable&quot;&gt;sourcedirs&lt;/a&gt;变量时的行为相同。有关更多信息，请参见&lt;a href=&quot;#sourcedirs-variable&quot;&gt;sourcedirs&lt;/a&gt;变量。</target>
        </trans-unit>
        <trans-unit id="cad134d8c8f7cf34f150e5381504660ade1079a5" translate="yes" xml:space="preserve">
          <source>When processing the &lt;code&gt;sources&lt;/code&gt; variable, QDoc behaves in the same way as it does when processing the &lt;a href=&quot;22-qdoc-configuration-generalvariables#sourcedirs-variable&quot;&gt;sourcedirs&lt;/a&gt; variable. For more information, see the &lt;a href=&quot;22-qdoc-configuration-generalvariables#sourcedirs-variable&quot;&gt;sourcedirs&lt;/a&gt; variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2f6258fc95387a5c4367b7340551e8c1e093ed8" translate="yes" xml:space="preserve">
          <source>When processing the header files specified in the &lt;a href=&quot;#headerdirs&quot;&gt;&lt;code&gt;headerdirs&lt;/code&gt;&lt;/a&gt; variable, QDoc will only read the files with the fileextensions specified in the &lt;code&gt;headers.fileextensions&lt;/code&gt; variable. In this way QDoc avoids spending time reading irrelevant files.</source>
          <target state="translated">处理&lt;a href=&quot;#headerdirs&quot;&gt; &lt;code&gt;headerdirs&lt;/code&gt; &lt;/a&gt;变量中指定的头文件时，QDoc仅读取具有 &lt;code&gt;headers.fileextensions&lt;/code&gt; 变量中指定的文件扩展名的文件。这样，QDoc可以避免花费时间阅读不相关的文件。</target>
        </trans-unit>
        <trans-unit id="e6e737bd0bca30837e70dbf0ba50e38a69eda1ae" translate="yes" xml:space="preserve">
          <source>When processing the header files specified in the &lt;a href=&quot;22-qdoc-configuration-generalvariables#headerdirs&quot;&gt;&lt;code&gt;headerdirs&lt;/code&gt;&lt;/a&gt; variable, QDoc will only read the files with the fileextensions specified in the &lt;code&gt;headers.fileextensions&lt;/code&gt; variable. In this way QDoc avoids spending time reading irrelevant files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ed979007a1c43ad6e1c65933f5ff78d1bf33f42" translate="yes" xml:space="preserve">
          <source>When processing the source files specified in the &lt;a href=&quot;#sourcedirs&quot;&gt;&lt;code&gt;sourcedirs&lt;/code&gt;&lt;/a&gt; variable, QDoc will only read the files with the fileextensions specified in the &lt;code&gt;sources.fileextensions&lt;/code&gt; variable. In this way QDoc avoid spending time reading irrelevant files.</source>
          <target state="translated">在处理&lt;a href=&quot;#sourcedirs&quot;&gt; &lt;code&gt;sourcedirs&lt;/code&gt; &lt;/a&gt;变量中指定的源文件时，QDoc仅读取具有 &lt;code&gt;sources.fileextensions&lt;/code&gt; 变量中指定的文件扩展名的文件。这样，QDoc可以避免花时间阅读不相关的文件。</target>
        </trans-unit>
        <trans-unit id="cfdcd3052995a6aaff22f71ef5141edb96daddb2" translate="yes" xml:space="preserve">
          <source>When processing the source files specified in the &lt;a href=&quot;22-qdoc-configuration-generalvariables#sourcedirs&quot;&gt;&lt;code&gt;sourcedirs&lt;/code&gt;&lt;/a&gt; variable, QDoc will only read the files with the fileextensions specified in the &lt;code&gt;sources.fileextensions&lt;/code&gt; variable. In this way QDoc avoid spending time reading irrelevant files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3b3725626f2e2c1e184c3a3386769f3ccdb3009" translate="yes" xml:space="preserve">
          <source>When properties are defined on a &lt;a href=&quot;qt3dcore-qnode&quot;&gt;QNode&lt;/a&gt; subclass, their NOTIFY signal will automatically generate notifications that the Qt3D backend aspects will receive.</source>
          <target state="translated">在&lt;a href=&quot;qt3dcore-qnode&quot;&gt;QNode&lt;/a&gt;子类上定义属性后，其NOTIFY信号将自动生成Qt3D后端方面将接收的通知。</target>
        </trans-unit>
        <trans-unit id="c17f593088b99a91dc585e42d8e3fdd068f8c76c" translate="yes" xml:space="preserve">
          <source>When properties are defined on a QNode subclass, their NOTIFY signal will automatically generate notifications that the Qt3D backend aspects will receive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22650f203b3bc55d65cd8bcc3c197b3e1ae94f80" translate="yes" xml:space="preserve">
          <source>When protecting for a short-term operation, it is acceptable to call &lt;a href=&quot;qlockfile#lock&quot;&gt;lock&lt;/a&gt;() and wait until any running operation finishes. When protecting a resource over a long time, however, the application should always call &lt;a href=&quot;qlockfile#setStaleLockTime&quot;&gt;setStaleLockTime&lt;/a&gt;(0) and then &lt;a href=&quot;qlockfile#tryLock&quot;&gt;tryLock&lt;/a&gt;() with a short timeout, in order to warn the user that the resource is locked.</source>
          <target state="translated">保护短期操作时，可以调用&lt;a href=&quot;qlockfile#lock&quot;&gt;lock&lt;/a&gt;（）并等待直到任何正在运行的操作完成为止。但是，在长时间保护资源时，应用程序应始终调用&lt;a href=&quot;qlockfile#setStaleLockTime&quot;&gt;setStaleLockTime&lt;/a&gt;（0），然后在较短的超时时间内调用&lt;a href=&quot;qlockfile#tryLock&quot;&gt;tryLock&lt;/a&gt;（），以警告用户资源已锁定。</target>
        </trans-unit>
        <trans-unit id="12b6bb01343a6f269ac19359f22a3d9b836dd641" translate="yes" xml:space="preserve">
          <source>When providing your own attributes, it may make sense to name your attribute using helpers such as &lt;a href=&quot;qt3drender-qattribute#defaultPositionAttributeName&quot;&gt;QAttribute::defaultPositionAttributeName&lt;/a&gt;() as that will ensure your geometry will be compatible with picking and the various materials provided in the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qt3dextras-module.html&quot;&gt;Qt3DExtras&lt;/a&gt; module.</source>
          <target state="translated">提供自己的属性时，使用诸如&lt;a href=&quot;qt3drender-qattribute#defaultPositionAttributeName&quot;&gt;QAttribute :: defaultPositionAttributeName&lt;/a&gt;（）之类的助手来命名属性可能是有意义的，因为这将确保您的几何形状与拾取以及&lt;a href=&quot;https://doc.qt.io/qt-5.13/qt3dextras-module.html&quot;&gt;Qt3DExtras&lt;/a&gt;模块中提供的各种材质兼容。</target>
        </trans-unit>
        <trans-unit id="1c5031580380ec45abd2184625b064726bd7956e" translate="yes" xml:space="preserve">
          <source>When providing your own attributes, it may make sense to name your attribute using helpers such as &lt;a href=&quot;qt3drender-qattribute#defaultPositionAttributeName&quot;&gt;QAttribute::defaultPositionAttributeName&lt;/a&gt;() as that will ensure your geometry will be compatible with picking and the various materials provided in the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qt3dextras-module.html&quot;&gt;Qt3DExtras&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83204666112336ac2cd938437ecd85c2c9e42c43" translate="yes" xml:space="preserve">
          <source>When providing your own attributes, it may make sense to name your attribute using helpers such as QAttribute::defaultPositionAttributeName() as that will ensure your geometry will be compatible with picking and the various materials provided in the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qt3dextras-module.html&quot;&gt;Qt3DExtras&lt;/a&gt; module.</source>
          <target state="translated">提供自己的属性时，使用诸如QAttribute :: defaultPositionAttributeName（）之类的助手来命名属性可能是有意义的，因为这将确保您的几何形状与拾取以及&lt;a href=&quot;https://doc.qt.io/qt-5.13/qt3dextras-module.html&quot;&gt;Qt3DExtras&lt;/a&gt;模块中提供的各种材质兼容。</target>
        </trans-unit>
        <trans-unit id="7f0b771b8b6122f451fd39a4eec632c95f8abf9c" translate="yes" xml:space="preserve">
          <source>When providing your own attributes, it may make sense to name your attribute using helpers such as QAttribute::defaultPositionAttributeName() as that will ensure your geometry will be compatible with picking and the various materials provided in the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qt3dextras-module.html&quot;&gt;Qt3DExtras&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7be4e2868f53c5c712c37033765565589dd9a696" translate="yes" xml:space="preserve">
          <source>When qmake is run, an &lt;code&gt;Info.plist&lt;/code&gt; file is generated with appropriate default values.</source>
          <target state="translated">运行qmake时，将使用适当的默认值生成一个 &lt;code&gt;Info.plist&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="deaab1579f95ca0cb54a7c45e2f6602842f9bf55" translate="yes" xml:space="preserve">
          <source>When qmake processes the project file, it will generate a Makefile rule to allow the project to be built in both modes. This can be invoked in the following way:</source>
          <target state="translated">当qmake处理项目文件时,它会生成一个Makefile规则,允许项目在两种模式下构建。可以通过以下方式调用该规则。</target>
        </trans-unit>
        <trans-unit id="433bf4e26978749cad77ae5bdc38533c0acb441e" translate="yes" xml:space="preserve">
          <source>When queries are generated to be executed on the database only those fields for which &lt;a href=&quot;qsqlrecord#isGenerated&quot;&gt;isGenerated&lt;/a&gt;() is true are included in the generated SQL.</source>
          <target state="translated">当生成查询以在数据库上执行时，只有那些&lt;a href=&quot;qsqlrecord#isGenerated&quot;&gt;isGenerated&lt;/a&gt;（）为true的字段才包含在生成的SQL中。</target>
        </trans-unit>
        <trans-unit id="9333afa0fced835478399e93823c406d22de675b" translate="yes" xml:space="preserve">
          <source>When quoting is disabled, these types are printed without quotation characters and without escaping of non-printable characters.</source>
          <target state="translated">当禁用引号时,这些类型的打印没有引号,也没有不可打印字符的转义。</target>
        </trans-unit>
        <trans-unit id="2e3a5904501c88a29777d21a5ea08bedba058dd9" translate="yes" xml:space="preserve">
          <source>When reading from QByteArray(), the &lt;a href=&quot;qcborstreamreader#addData&quot;&gt;addData&lt;/a&gt;() function automatically calls this function. Calling it when the reading had not failed is a no-op.</source>
          <target state="translated">从QByteArray（）读取时，&lt;a href=&quot;qcborstreamreader#addData&quot;&gt;addData&lt;/a&gt;（）函数自动调用此函数。当阅读没有失败时调用它是没有操作的。</target>
        </trans-unit>
        <trans-unit id="2961583e309be088817f7af5160b0e7c63f99641" translate="yes" xml:space="preserve">
          <source>When reading, the end-of-line terminators are translated to '\n'. When writing, the end-of-line terminators are translated to the local encoding, for example '\r\n' for Win32.</source>
          <target state="translated">当读的时候,行结束符被翻译成'\n'。写入时,行结束符被翻译成本地编码,例如Win32的'\r\n'。</target>
        </trans-unit>
        <trans-unit id="0178fb06130fa3ace5f0116314a30ba2905b8155" translate="yes" xml:space="preserve">
          <source>When receiving an input method event, the text widget has to performs the following steps:</source>
          <target state="translated">当接收到输入法事件时,文本部件必须执行以下步骤。</target>
        </trans-unit>
        <trans-unit id="bc54aed1354ce805c861b084074c4b15f2941b02" translate="yes" xml:space="preserve">
          <source>When registered with QML in this way, they can be used as property types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6de85969ab467e39090e43789eb7746771150552" translate="yes" xml:space="preserve">
          <source>When registered with the QML engine in this way, they can be used as property types:</source>
          <target state="translated">当以这种方式在QML引擎中注册时,它们可以作为属性类型使用。</target>
        </trans-unit>
        <trans-unit id="658aa3d331e786b5cf19cdc003900fc565a01ebd" translate="yes" xml:space="preserve">
          <source>When reimplementing &lt;a href=&quot;qabstractitemmodel#insertColumns&quot;&gt;insertColumns&lt;/a&gt;() in a subclass, you must call this function</source>
          <target state="translated">在子类中重新实现&lt;a href=&quot;qabstractitemmodel#insertColumns&quot;&gt;insertColumns&lt;/a&gt;（）时，必须调用此函数</target>
        </trans-unit>
        <trans-unit id="4c93d0d6698e3e63d88035f6f5efca5fb6102f1c" translate="yes" xml:space="preserve">
          <source>When reimplementing &lt;a href=&quot;qabstractitemmodel#insertRows&quot;&gt;insertRows&lt;/a&gt;() in a subclass, you must call this function</source>
          <target state="translated">在子类中重新实现&lt;a href=&quot;qabstractitemmodel#insertRows&quot;&gt;insertRows&lt;/a&gt;（）时，必须调用此函数</target>
        </trans-unit>
        <trans-unit id="85d1f3aba6b52c7b19fa00f7d1afc309113e34b8" translate="yes" xml:space="preserve">
          <source>When reimplementing &lt;a href=&quot;qabstractitemmodel#removeColumns&quot;&gt;removeColumns&lt;/a&gt;() in a subclass, you must call this function</source>
          <target state="translated">在子类中重新实现&lt;a href=&quot;qabstractitemmodel#removeColumns&quot;&gt;removeColumns&lt;/a&gt;（）时，必须调用此函数</target>
        </trans-unit>
        <trans-unit id="f37a182e5a69ec7aec2bf70e9e8e6c7db8177d59" translate="yes" xml:space="preserve">
          <source>When reimplementing &lt;a href=&quot;qabstractitemmodel#removeRows&quot;&gt;removeRows&lt;/a&gt;() in a subclass, you must call this function</source>
          <target state="translated">在子类中重新实现&lt;a href=&quot;qabstractitemmodel#removeRows&quot;&gt;removeRows&lt;/a&gt;（）时，必须调用此函数</target>
        </trans-unit>
        <trans-unit id="9b0330becdc29ff2c73cb6957330004540cba4dd" translate="yes" xml:space="preserve">
          <source>When reimplementing &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; functions that take a &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt; parameter, you often need to cast the &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt; to a subclass (e.g., &lt;a href=&quot;qstyleoptionfocusrect&quot;&gt;QStyleOptionFocusRect&lt;/a&gt;). For safety, you can use &lt;a href=&quot;qstyleoption#qstyleoption_cast&quot;&gt;qstyleoption_cast&lt;/a&gt;() to ensure that the pointer type is correct. If the object isn't of the right type, &lt;a href=&quot;qstyleoption#qstyleoption_cast&quot;&gt;qstyleoption_cast&lt;/a&gt;() returns &lt;code&gt;nullptr&lt;/code&gt;. For example:</source>
          <target state="translated">当重新实现带有&lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt;参数的&lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt;函数时，通常需要将&lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption强制&lt;/a&gt;转换为子类（例如&lt;a href=&quot;qstyleoptionfocusrect&quot;&gt;QStyleOptionFocusRect&lt;/a&gt;）。为了安全起见，可以使用&lt;a href=&quot;qstyleoption#qstyleoption_cast&quot;&gt;qstyleoption_cast&lt;/a&gt;（）来确保指针类型正确。如果对象的类型不正确，则&lt;a href=&quot;qstyleoption#qstyleoption_cast&quot;&gt;qstyleoption_cast&lt;/a&gt;（）返回 &lt;code&gt;nullptr&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="9dfc851c4dac23e39db3f903a4238131999a47c4" translate="yes" xml:space="preserve">
          <source>When reimplementing &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; functions that take a &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt; parameter, you often need to cast the &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt; to a subclass. For safety, you can use &lt;a href=&quot;qstyleoption#qstyleoption_cast&quot;&gt;qstyleoption_cast&lt;/a&gt;() to ensure that the pointer type is correct. For example:</source>
          <target state="translated">重新实现带有&lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt;参数的&lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt;函数时，通常需要将&lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption强制&lt;/a&gt;转换为子类。为了安全起见，可以使用&lt;a href=&quot;qstyleoption#qstyleoption_cast&quot;&gt;qstyleoption_cast&lt;/a&gt;（）来确保指针类型正确。例如：</target>
        </trans-unit>
        <trans-unit id="7c3a36cf890d4e609cd3054eba937187efb84074" translate="yes" xml:space="preserve">
          <source>When reimplementing &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; functions that take a QStyleOption parameter, you often need to cast the QStyleOption to a subclass. For safety, you can use &lt;a href=&quot;qstyleoption#qstyleoption_cast&quot;&gt;qstyleoption_cast&lt;/a&gt;() to ensure that the pointer type is correct. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec235ac06dbbca492dcbe4cfde2eff2f73ed2863" translate="yes" xml:space="preserve">
          <source>When reimplementing &lt;a href=&quot;qstyleditemdelegate#paint&quot;&gt;paint&lt;/a&gt;(), one would typically handle the datatypes one would like to draw and use the superclass implementation for other types.</source>
          <target state="translated">重新实现&lt;a href=&quot;qstyleditemdelegate#paint&quot;&gt;paint&lt;/a&gt;（）时，通常会处理一个人希望绘制的数据类型，并将超类实现用于其他类型。</target>
        </trans-unit>
        <trans-unit id="fb3e42362330e9b7392e5e0ebae5fafed9a1a17a" translate="yes" xml:space="preserve">
          <source>When reimplementing a subclass, this method simplifies moving entities in your model. This method is responsible for moving persistent indexes in the model, which you would otherwise be required to do yourself. Using beginMoveColumns and &lt;a href=&quot;qabstractitemmodel#endMoveColumns&quot;&gt;endMoveColumns&lt;/a&gt; is an alternative to emitting &lt;a href=&quot;qabstractitemmodel#layoutAboutToBeChanged&quot;&gt;layoutAboutToBeChanged&lt;/a&gt; and &lt;a href=&quot;qabstractitemmodel#layoutChanged&quot;&gt;layoutChanged&lt;/a&gt; directly along with &lt;a href=&quot;qabstractitemmodel#changePersistentIndex&quot;&gt;changePersistentIndex&lt;/a&gt;.</source>
          <target state="translated">重新实现子类时，此方法可简化模型中的移动实体。此方法负责在模型中移动持久索引，否则您需要自己进行操作。使用beginMoveColumns和&lt;a href=&quot;qabstractitemmodel#endMoveColumns&quot;&gt;endMoveColumns&lt;/a&gt;是发射一个替代&lt;a href=&quot;qabstractitemmodel#layoutAboutToBeChanged&quot;&gt;layoutAboutToBeChanged&lt;/a&gt;和&lt;a href=&quot;qabstractitemmodel#layoutChanged&quot;&gt;layoutChanged&lt;/a&gt;直接沿&lt;a href=&quot;qabstractitemmodel#changePersistentIndex&quot;&gt;changePersistentIndex&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="37d54556abfd5846d3b883b6100f1fa44ae8b968" translate="yes" xml:space="preserve">
          <source>When reimplementing a subclass, this method simplifies moving entities in your model. This method is responsible for moving persistent indexes in the model, which you would otherwise be required to do yourself. Using beginMoveRows and &lt;a href=&quot;qabstractitemmodel#endMoveRows&quot;&gt;endMoveRows&lt;/a&gt; is an alternative to emitting &lt;a href=&quot;qabstractitemmodel#layoutAboutToBeChanged&quot;&gt;layoutAboutToBeChanged&lt;/a&gt; and &lt;a href=&quot;qabstractitemmodel#layoutChanged&quot;&gt;layoutChanged&lt;/a&gt; directly along with &lt;a href=&quot;qabstractitemmodel#changePersistentIndex&quot;&gt;changePersistentIndex&lt;/a&gt;.</source>
          <target state="translated">重新实现子类时，此方法可简化模型中的移动实体。此方法负责在模型中移动持久索引，否则您需要自己进行操作。使用beginMoveRows和&lt;a href=&quot;qabstractitemmodel#endMoveRows&quot;&gt;endMoveRows&lt;/a&gt;是发射一个替代&lt;a href=&quot;qabstractitemmodel#layoutAboutToBeChanged&quot;&gt;layoutAboutToBeChanged&lt;/a&gt;和&lt;a href=&quot;qabstractitemmodel#layoutChanged&quot;&gt;layoutChanged&lt;/a&gt;直接沿&lt;a href=&quot;qabstractitemmodel#changePersistentIndex&quot;&gt;changePersistentIndex&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ca95dc0c0eb787c2eeed20255a0cb245f62492af" translate="yes" xml:space="preserve">
          <source>When reimplementing canRead(), make sure that the I/O device (&lt;a href=&quot;qimageiohandler#device&quot;&gt;device&lt;/a&gt;()) is left in its original state (e.g., by using peek() rather than &lt;a href=&quot;qimageiohandler#read&quot;&gt;read&lt;/a&gt;()).</source>
          <target state="translated">重新实现canRead（）时，请确保I / O设备（&lt;a href=&quot;qimageiohandler#device&quot;&gt;device&lt;/a&gt;（））保持其原始状态（例如，通过使用peek（）而不是&lt;a href=&quot;qimageiohandler#read&quot;&gt;read&lt;/a&gt;（））。</target>
        </trans-unit>
        <trans-unit id="028d93193544c8ed47ad98dfeadb939c5667b03b" translate="yes" xml:space="preserve">
          <source>When reimplementing paint in a subclass. Use the &lt;a href=&quot;qstyleditemdelegate#initStyleOption&quot;&gt;initStyleOption&lt;/a&gt;() to set up the</source>
          <target state="translated">在子类中重新实现绘画时。使用&lt;a href=&quot;qstyleditemdelegate#initStyleOption&quot;&gt;initStyleOption&lt;/a&gt;（）设定</target>
        </trans-unit>
        <trans-unit id="df7f5f683e515c4160cc8d6065b4b4913422655c" translate="yes" xml:space="preserve">
          <source>When reimplementing the &lt;a href=&quot;qabstractitemmodel#setData&quot;&gt;setData&lt;/a&gt;() function, this signal must be emitted explicitly.</source>
          <target state="translated">重新实现&lt;a href=&quot;qabstractitemmodel#setData&quot;&gt;setData&lt;/a&gt;（）函数时，必须显式发出此信号。</target>
        </trans-unit>
        <trans-unit id="6f516d38e016de108e31954fe638b31e63f64384" translate="yes" xml:space="preserve">
          <source>When reimplementing the &lt;a href=&quot;qabstractitemmodel#setHeaderData&quot;&gt;setHeaderData&lt;/a&gt;() function, this signal must be emitted explicitly.</source>
          <target state="translated">重新实现&lt;a href=&quot;qabstractitemmodel#setHeaderData&quot;&gt;setHeaderData&lt;/a&gt;（）函数时，必须显式发出此信号。</target>
        </trans-unit>
        <trans-unit id="8bb42c54f45079c9c25f1595264e446c8f5dae51" translate="yes" xml:space="preserve">
          <source>When reimplementing the &lt;a href=&quot;qeventtransition#eventTest&quot;&gt;eventTest&lt;/a&gt;() function, you should first call the base implementation to verify that the event is a &lt;a href=&quot;qstatemachine-wrappedevent&quot;&gt;QStateMachine::WrappedEvent&lt;/a&gt; for the proper object and event type. You may then cast the event to a &lt;a href=&quot;qstatemachine-wrappedevent&quot;&gt;QStateMachine::WrappedEvent&lt;/a&gt; and get the original event by calling &lt;a href=&quot;qstatemachine-wrappedevent#event&quot;&gt;QStateMachine::WrappedEvent::event&lt;/a&gt;(), and perform additional checks on that object.</source>
          <target state="translated">重新实现&lt;a href=&quot;qeventtransition#eventTest&quot;&gt;eventTest&lt;/a&gt;（）函数时，应首先调用基本实现，以验证该事件是否为正确的对象和事件类型的&lt;a href=&quot;qstatemachine-wrappedevent&quot;&gt;QStateMachine :: WrappedEvent&lt;/a&gt;。然后，您可以将事件&lt;a href=&quot;qstatemachine-wrappedevent&quot;&gt;强制&lt;/a&gt;转换为QStateMachine :: WrappedEvent并通过调用&lt;a href=&quot;qstatemachine-wrappedevent#event&quot;&gt;QStateMachine :: WrappedEvent :: event&lt;/a&gt;（）获取原始事件，并对该对象执行其他检查。</target>
        </trans-unit>
        <trans-unit id="b124ac10b911b199139a9b1396e9a53e131374c7" translate="yes" xml:space="preserve">
          <source>When reimplementing this class, take care to return at least one element.</source>
          <target state="translated">在重新实现这个类的时候,注意至少要返回一个元素。</target>
        </trans-unit>
        <trans-unit id="55e2b93bd22d4647e3de872d6613c4f4629fae05" translate="yes" xml:space="preserve">
          <source>When reimplementing this function in a subclass, be careful to avoid calling &lt;a href=&quot;qmodelindex&quot;&gt;QModelIndex&lt;/a&gt; member functions, such as &lt;a href=&quot;qmodelindex#parent&quot;&gt;QModelIndex::parent&lt;/a&gt;(), since indexes belonging to your model will simply call your implementation, leading to infinite recursion.</source>
          <target state="translated">在子类中重新实现此函数时，请小心避免调用&lt;a href=&quot;qmodelindex&quot;&gt;QModelIndex&lt;/a&gt;成员函数，例如&lt;a href=&quot;qmodelindex#parent&quot;&gt;QModelIndex :: parent&lt;/a&gt;（），因为属于您模型的索引会简单地调用您的实现，从而导致无限递归。</target>
        </trans-unit>
        <trans-unit id="70e5caa7bbddd6d74b4efb7d8a7005f9825d497b" translate="yes" xml:space="preserve">
          <source>When reimplementing this function in a subclass, call &lt;a href=&quot;qabstractitemmodel#createIndex&quot;&gt;createIndex&lt;/a&gt;() to generate model indexes that other components can use to refer to items in your model.</source>
          <target state="translated">在子类中重新实现此函数时，调用&lt;a href=&quot;qabstractitemmodel#createIndex&quot;&gt;createIndex&lt;/a&gt;（）生成模型索引，其他组件可以使用该模型索引来引用模型中的项目。</target>
        </trans-unit>
        <trans-unit id="ba7f9d147f366305cacefe9a55e635566170bc6d" translate="yes" xml:space="preserve">
          <source>When reimplementing this function in a subclass, you should update the area held by the option's &lt;a href=&quot;qstyleoption#rect-var&quot;&gt;rect&lt;/a&gt; variable, using the option's &lt;a href=&quot;qstyleoption#state-var&quot;&gt;state&lt;/a&gt; variable to determine the state of the item to be displayed, and adjust the way it is painted accordingly.</source>
          <target state="translated">在子类中重新实现此功能时，应更新选项的&lt;a href=&quot;qstyleoption#rect-var&quot;&gt;rect&lt;/a&gt;变量所占的区域，使用选项的&lt;a href=&quot;qstyleoption#state-var&quot;&gt;状态&lt;/a&gt;变量来确定要显示的项目的状态，并相应地调整其绘制方式。</target>
        </trans-unit>
        <trans-unit id="4e2d2f89b79fefee58d5613beec7b9bd5dde6fb5" translate="yes" xml:space="preserve">
          <source>When reimplementing this function it is important that this function reads all the required data before returning. This is required in order for &lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt; to be able to operate on the class. &lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt; assumes all the requested information was read and therefore does not retry reading if there was a problem.</source>
          <target state="translated">重新实现此功能时，重要的是该功能在返回之前读取所有必需的数据。为了使&lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt;能够在类上进行操作，这是必需的。&lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt;假定已读取所有请求的信息，因此如果出现问题，则不会重试读取。</target>
        </trans-unit>
        <trans-unit id="e93d19bd100346fac19905c7b4a51959378ca55b" translate="yes" xml:space="preserve">
          <source>When reimplementing this function it is important that this function writes all the data available before returning. This is required in order for &lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt; to be able to operate on the class. &lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt; assumes all the information was written and therefore does not retry writing if there was a problem.</source>
          <target state="translated">重新实现此功能时，重要的是该函数在返回之前写入所有可用数据。为了使&lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt;能够在类上进行操作，这是必需的。&lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt;假定所有信息均已写入，因此如果出现问题，则不会重试写入。</target>
        </trans-unit>
        <trans-unit id="dbe06314296a3392519e885c147e88b10b0594de" translate="yes" xml:space="preserve">
          <source>When reimplementing this function, note that in case of text items, &lt;a href=&quot;qitemdelegate&quot;&gt;QItemDelegate&lt;/a&gt; adds a margin (i.e. 2 * &lt;a href=&quot;qstyle#PixelMetric-enum&quot;&gt;QStyle::PM_FocusFrameHMargin&lt;/a&gt;) to the length of the text.</source>
          <target state="translated">重新实现此功能时，请注意，在使用文本项的情况下，&lt;a href=&quot;qitemdelegate&quot;&gt;QItemDelegate&lt;/a&gt;在文本长度上添加一个空白（即2 * &lt;a href=&quot;qstyle#PixelMetric-enum&quot;&gt;QStyle :: PM_FocusFrameHMargin&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="197ccf9da55fd735f9643d4ab74a6bddeec9dfb0" translate="yes" xml:space="preserve">
          <source>When reimplementing this function, the &lt;a href=&quot;qabstractitemmodel#headerDataChanged&quot;&gt;headerDataChanged&lt;/a&gt;() signal must be emitted explicitly.</source>
          <target state="translated">重新实现此功能时，必须显式发出&lt;a href=&quot;qabstractitemmodel#headerDataChanged&quot;&gt;headerDataChanged&lt;/a&gt;（）信号。</target>
        </trans-unit>
        <trans-unit id="89a145bd42509fd307493a0a0013f21ce6e0557c" translate="yes" xml:space="preserve">
          <source>When relative paths are specified, qmake will mangle them into a form understood by the dynamic linker to be relative to the location of the referring executable or library. This is supported only by some platforms (currently Linux and Darwin-based ones) and is detectable by checking whether &lt;a href=&quot;#qmake-rel-rpath-base&quot;&gt;QMAKE_REL_RPATH_BASE&lt;/a&gt; is set.</source>
          <target state="translated">指定相对路径后，qmake会将其转换为动态链接器可理解为相对于引用可执行文件或库的位置的形式。仅某些平台（当前为Linux和基于Darwin的平台）支持此功能，并且可以通过检查是否设置了&lt;a href=&quot;#qmake-rel-rpath-base&quot;&gt;QMAKE_REL_RPATH_BASE&lt;/a&gt;来检测到。</target>
        </trans-unit>
        <trans-unit id="c2230aceb836e5f2b704deb69243134974a878df" translate="yes" xml:space="preserve">
          <source>When relative paths are specified, qmake will mangle them into a form understood by the dynamic linker to be relative to the location of the referring executable or library. This is supported only by some platforms (currently Linux and Darwin-based ones) and is detectable by checking whether &lt;a href=&quot;qmake-variable-reference#qmake-rel-rpath-base&quot;&gt;QMAKE_REL_RPATH_BASE&lt;/a&gt; is set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b737ba18762f9d815ad8cc904c2c8daeaec43e4b" translate="yes" xml:space="preserve">
          <source>When rendering graphics, the matrix defines the transformations but the actual transformation is performed by the drawing routines in &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;.</source>
          <target state="translated">渲染图形时，矩阵定义了转换，但是实际的转换由&lt;a href=&quot;qpainter&quot;&gt;QPainter中&lt;/a&gt;的绘制例程执行。</target>
        </trans-unit>
        <trans-unit id="7c5109171a737854a9ba5a71e30fd9bd78572ca4" translate="yes" xml:space="preserve">
          <source>When rendering with a pen with an even number of pixels, the pixels will be rendered symetrically around the mathematical defined points, while rendering with a pen with an odd number of pixels, the spare pixel will be rendered to the right and below the mathematical point as in the one pixel case. See the &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; diagrams below for concrete examples.</source>
          <target state="translated">使用像素数为偶数的笔进行渲染时，将在数学定义的点周围对称地渲染像素，而使用像素数为奇数的笔进行渲染时，备用像素将在数学点的右侧和下方渲染与一像素的情况一样。具体示例请参见下面的&lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt;图。</target>
        </trans-unit>
        <trans-unit id="f6bb9fd28f420249ac748ef0297e189cfdea3c23" translate="yes" xml:space="preserve">
          <source>When rendering with a two pixels wide pen the boundary line will be split in the middle by the mathematical rectangle. This will be the case whenever the pen is set to an even number of pixels, while rendering with a pen with an odd number of pixels, the spare pixel will be rendered to the right and below the mathematical rectangle as in the one pixel case.</source>
          <target state="translated">当用两个像素宽的笔渲染时,边界线将被数学矩形从中间分割开来。当笔的像素数为偶数时,就会出现这种情况,而当用奇数像素的笔渲染时,多余的像素会像在一个像素的情况下一样,被渲染到数学矩形的右边和下面。</target>
        </trans-unit>
        <trans-unit id="d7e0077b12f54b280554348b8d31ed612bede88e" translate="yes" xml:space="preserve">
          <source>When rendering, &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; protects the painter state (see &lt;a href=&quot;qpainter#save&quot;&gt;QPainter::save&lt;/a&gt;()) when rendering the background or foreground, and when rendering each item. This allows you to leave the painter in an altered state (i.e., you can call &lt;a href=&quot;qpainter#setPen&quot;&gt;QPainter::setPen&lt;/a&gt;() or &lt;a href=&quot;qpainter#setBrush&quot;&gt;QPainter::setBrush&lt;/a&gt;() without restoring the state after painting). However, if the items consistently do restore the state, you should enable this flag to prevent &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; from doing the same.</source>
          <target state="translated">渲染时，&lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt;在渲染背景或前景以及渲染每个项目时会保护画家状态（请参阅&lt;a href=&quot;qpainter#save&quot;&gt;QPainter :: save&lt;/a&gt;（））。这使您可以使画家处于改变的状态（即，您可以调用&lt;a href=&quot;qpainter#setPen&quot;&gt;QPainter :: setPen&lt;/a&gt;（）或&lt;a href=&quot;qpainter#setBrush&quot;&gt;QPainter :: setBrush&lt;/a&gt;（）而不用在绘制后恢复状态）。但是，如果各项一致地确实恢复了状态，则应启用此标志以防止&lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt;这样做。</target>
        </trans-unit>
        <trans-unit id="d51a24d95c26c19a346a37f3dd7e864ef01ea9d8" translate="yes" xml:space="preserve">
          <source>When rendering, Graphics View's scene coordinates correspond to &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;'s</source>
          <target state="translated">渲染时，Graphics View的场景坐标对应于&lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;的</target>
        </trans-unit>
        <trans-unit id="b351cd57358f6774989d1cb0e0f8f4b5f818e8c3" translate="yes" xml:space="preserve">
          <source>When requesting an index for a model item, we must provide some information about the item's parent. Outside the model, the only way to refer to an item is through a model index, so a parent model index must also be given:</source>
          <target state="translated">当请求一个模型项的索引时,我们必须提供该项的父项的一些信息。在模型之外,引用一个项目的唯一方法是通过模型索引,所以还必须提供一个父模型索引。</target>
        </trans-unit>
        <trans-unit id="e3462b37efc9ed9435b6be891fff238475c5b943" translate="yes" xml:space="preserve">
          <source>When resizeEvent() is called, the viewport already has its new geometry: Its new size is accessible through the &lt;a href=&quot;qresizeevent#size&quot;&gt;QResizeEvent::size&lt;/a&gt;() function, and the old size through &lt;a href=&quot;qresizeevent#oldSize&quot;&gt;QResizeEvent::oldSize&lt;/a&gt;().</source>
          <target state="translated">调用resizeEvent（）时，视口已经具有新的几何形状：可通过&lt;a href=&quot;qresizeevent#size&quot;&gt;QResizeEvent :: size&lt;/a&gt;（）函数访问其新大小，而可通过&lt;a href=&quot;qresizeevent#oldSize&quot;&gt;QResizeEvent :: oldSize&lt;/a&gt;（）访问其旧大小。</target>
        </trans-unit>
        <trans-unit id="459145d7e5e0a2dddcfe14e374a8a522472aa332" translate="yes" xml:space="preserve">
          <source>When returning from C++, the engine will interrupt the normal flow of execution and call the the next pre-registered exception handler with an error object that contains the given</source>
          <target state="translated">当从C++返回时,引擎将中断正常的执行流程,并调用下一个预先注册的异常处理程序,该异常处理程序的错误对象包含给定的</target>
        </trans-unit>
        <trans-unit id="90d305ada35629da8b28508d253830cb3271219a" translate="yes" xml:space="preserve">
          <source>When rubberband selection ends this signal will be emitted with null vales.</source>
          <target state="translated">当橡皮筋选择结束时,这个信号将发出空值。</target>
        </trans-unit>
        <trans-unit id="d7d3ba7b84a869b7ec4d6428c30a1e381f521d40" translate="yes" xml:space="preserve">
          <source>When run in a Norwegian locale, this code could for instance display &quot;Price is kr 6,00&quot; for a one-dollar product.</source>
          <target state="translated">当在挪威当地运行时,这段代码可以显示 &quot;价格为6,00克朗 &quot;的一美元产品。</target>
        </trans-unit>
        <trans-unit id="f4b4ea8160e44027a1643f73bd2b4fc24a630c0f" translate="yes" xml:space="preserve">
          <source>When running QDoc to generate HTML, the example above will have no effect on the generated output, but if you run QDoc to generate DITA XML, the example will generate the following:</source>
          <target state="translated">当运行QDoc生成HTML时,上面的例子对生成的输出没有任何影响,但如果运行QDoc生成DITA XML,该例子将生成以下内容。</target>
        </trans-unit>
        <trans-unit id="313916658b849b20eb8b38c2b36d5a604ba7482c" translate="yes" xml:space="preserve">
          <source>When running QDoc to generate HTML, the example above will have no effect on the generated output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68eca509dfd034e35a8f7fa47ec0779beae30c64" translate="yes" xml:space="preserve">
          <source>When running Qt Web Engine examples in a Docker container and browsing content-heavy sites, BUS errors (SIGBUS) might be reported. Typically, this is caused by Docker running a container with a too small memory space (such as 64MB). To fix this problem, increase the memory space size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba74a44a4fe513e0e864500ccf8b7805d12bdf2c" translate="yes" xml:space="preserve">
          <source>When running the advertising procedure, a number of parameters can be configured, such as how fast to advertise or which clients, if any, can connect to the advertising device. These parameters are set via this class, and their values will be used when advertising is started by calling &lt;a href=&quot;qlowenergycontroller#startAdvertising&quot;&gt;QLowEnergyController::startAdvertising&lt;/a&gt;().</source>
          <target state="translated">在运行广告过程时，可以配置许多参数，例如广告投放速度或哪些客户端（如果有）可以连接到广告设备。这些参数是通过此类设置的，并且通过调用&lt;a href=&quot;qlowenergycontroller#startAdvertising&quot;&gt;QLowEnergyController :: startAdvertising&lt;/a&gt;（）启动广告时将使用它们的值。</target>
        </trans-unit>
        <trans-unit id="1e481bcca4c1c2d1651c8ca7889240a246da99ad" translate="yes" xml:space="preserve">
          <source>When running with the OpenGL backend of Qt Quick, both the generic, triangulation-based and the NVIDIA-specific &lt;code&gt;GL_NV_path_rendering&lt;/code&gt; methods are available. By default only the generic approach is used. Setting Shape.&lt;a href=&quot;qml-qtquick-shapes-shape#vendorExtensionsEnabled-prop&quot;&gt;vendorExtensionsEnabled&lt;/a&gt; property to &lt;code&gt;true&lt;/code&gt; leads to using NV_path_rendering on NVIDIA systems when running directly on OpenGL, and the generic method on others. When OpenGL is not used directly by the scene graph, for example because it is using the graphics abstraction layer (QRhi), only the generic shape renderer is available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="419ca242c0e809f26e319a45853b06288d62f271" translate="yes" xml:space="preserve">
          <source>When running with the OpenGL backend of the scene graph, &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; offers the possibility to disable persistent OpenGL contexts as well. This setting is currently ignored by &lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt; and the context is always persistent. The OpenGL context is thus not destroyed when hiding the widget. The context is destroyed only when the widget is destroyed or when the widget gets reparented into another top-level widget's child hierarchy. However, some applications, in particular those that have their own graphics resources due to performing custom OpenGL rendering in the Qt Quick scene, may wish to disable the latter since they may not be prepared to handle the loss of the context when moving a &lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt; into another window. Such applications can set the QCoreApplication::AA_ShareOpenGLContexts attribute. For a discussion on the details of resource initialization and cleanup, refer to the &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt; documentation.</source>
          <target state="translated">与场景图的OpenGL后端一起运行时，&lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt;还提供了禁用持久OpenGL上下文的可能性。&lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt;当前忽略此设置，并且上下文始终是持久的。因此，隐藏小部件时不会破坏OpenGL上下文。仅当销毁小部件或将小部件重新关联到另一个顶级小部件的子层次结构时，上下文才被销毁。但是，某些应用程序，特别是那些由于在Qt Quick场景中执行自定义OpenGL渲染而具有自己的图形资源的应用程序，可能希望禁用后者，因为它们可能不准备在移动&lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt;时处理上下文的丢失。进入另一个窗口。此类应用程序可以设置QCoreApplication :: AA_ShareOpenGLContexts属性。有关资源初始化和清除的详细信息，请参阅&lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="31fa69229e2655989faeea8c24fbc639c55aaf43" translate="yes" xml:space="preserve">
          <source>When running with the OpenGL backend of the scene graph, &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; offers the possibility to disable persistent OpenGL contexts as well. This setting is currently ignored by QQuickWidget and the context is always persistent. The OpenGL context is thus not destroyed when hiding the widget. The context is destroyed only when the widget is destroyed or when the widget gets reparented into another top-level widget's child hierarchy. However, some applications, in particular those that have their own graphics resources due to performing custom OpenGL rendering in the Qt Quick scene, may wish to disable the latter since they may not be prepared to handle the loss of the context when moving a QQuickWidget into another window. Such applications can set the QCoreApplication::AA_ShareOpenGLContexts attribute. For a discussion on the details of resource initialization and cleanup, refer to the &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt; documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4180cc40e3670129f26ab3b8aa7583731a04bc4b" translate="yes" xml:space="preserve">
          <source>When running with the default, OpenGL backend of Qt Quick, both the generic, triangulation-based and the NVIDIA-specific &lt;code&gt;GL_NV_path_rendering&lt;/code&gt; methods are available. By default only the generic approach is used. Setting Shape.&lt;a href=&quot;qml-qtquick-shapes-shape#vendorExtensionsEnabled-prop&quot;&gt;vendorExtensionsEnabled&lt;/a&gt; property to &lt;code&gt;true&lt;/code&gt; leads to using NV_path_rendering on NVIDIA systems, and the generic method on others.</source>
          <target state="translated">使用默认的Qt Quick OpenGL后端运行时，可以使用基于三角剖分的通用方法和特定于NVIDIA的 &lt;code&gt;GL_NV_path_rendering&lt;/code&gt; 方法。默认情况下，仅使用通用方法。设置形状。&lt;a href=&quot;qml-qtquick-shapes-shape#vendorExtensionsEnabled-prop&quot;&gt;vendorExtensionsEnabled&lt;/a&gt;属性设置为 &lt;code&gt;true&lt;/code&gt; 会导致在NVIDIA系统上使用NV_path_rendering，而在其他系统上则使用通用方法。</target>
        </trans-unit>
        <trans-unit id="22c17b7b950b81783fdb923684eedfd560adcd81" translate="yes" xml:space="preserve">
          <source>When runtime compilation is not in use and the shader properties refer to files with bytecode, the status is always Compiled. The contents of the shader is not examined (apart from basic reflection to discover vertex input elements and constant buffer data) until later in the rendering pipeline so potential errors (like layout or root signature mismatches) will only be detected at a later point.</source>
          <target state="translated">当运行时编译没有被使用,并且shader属性是指带有字节码的文件时,状态总是Compiled。在渲染流水线的后期,才会检查着色器的内容(除了发现顶点输入元素和常量缓冲区数据的基本反射外),因此潜在的错误(如布局或根签名不匹配)只会在后期被检测到。</target>
        </trans-unit>
        <trans-unit id="1cf799c203f3447ab5ee733162b36bb8365e9dec" translate="yes" xml:space="preserve">
          <source>When saving a form in</source>
          <target state="translated">当把表格保存在</target>
        </trans-unit>
        <trans-unit id="1e9c03991883db6f31187fbe5c35791a719629dc" translate="yes" xml:space="preserve">
          <source>When saving places between managers, there are a few things to be aware of. Some fields of a place such as the id, categories and icons are manager specific entities for example the categories in one manager may not be recognized in another. Therefore trying to save a place directly from one manager to another is not possible.</source>
          <target state="translated">当在经理之间保存地方时,有一些事情需要注意。一个地方的一些字段,如ID,类别和图标是经理特定的实体,例如,在一个经理的类别可能无法识别在另一个经理。因此,试图将一个地方从一个经理直接保存到另一个经理是不可能的。</target>
        </trans-unit>
        <trans-unit id="65dee2f6abcd14dfb6ffc451b8eef9d4e59664a3" translate="yes" xml:space="preserve">
          <source>When saving places between plugins, there are a few things to be aware of. Some fields of a place such as the id, categories and icons are plugin specific entities. For example the categories in one manager may not be recognised in another. Therefore trying to save a place directly from one plugin to another is not possible.</source>
          <target state="translated">在插件之间保存地方时,有几件事需要注意。一个地方的一些字段,如id,类别和图标是插件特定的实体。例如,一个管理器中的类别可能无法在另一个管理器中被识别。因此,试图将一个地方直接从一个插件保存到另一个是不可能的。</target>
        </trans-unit>
        <trans-unit id="16335d2940c0a9a4d44f0bf7877e3be7c7a4c25b" translate="yes" xml:space="preserve">
          <source>When scheduling cleanup of graphics resources using &lt;a href=&quot;qquickwindow#scheduleRenderJob&quot;&gt;QQuickWindow::scheduleRenderJob&lt;/a&gt;(), one should use either &lt;a href=&quot;qquickwindow#RenderStage-enum&quot;&gt;QQuickWindow::BeforeSynchronizingStage&lt;/a&gt; or &lt;a href=&quot;qquickwindow#RenderStage-enum&quot;&gt;QQuickWindow::AfterSynchronizingStage&lt;/a&gt;. The &lt;a href=&quot;qtquick-visualcanvas-scenegraph#scene-graph-and-rendering&quot;&gt;synchronization stage&lt;/a&gt; is where the scene graph is changed as a result of changes to the QML tree. If cleanup is scheduled at any other time, it may result in other parts of the scene graph referencing the newly deleted objects as these parts have not been updated.</source>
          <target state="translated">使用&lt;a href=&quot;qquickwindow#scheduleRenderJob&quot;&gt;QQuickWindow :: scheduleRenderJob&lt;/a&gt;（）安排图形资源的清理时，应使用&lt;a href=&quot;qquickwindow#RenderStage-enum&quot;&gt;QQuickWindow :: BeforeSynchronizingStage&lt;/a&gt;或&lt;a href=&quot;qquickwindow#RenderStage-enum&quot;&gt;QQuickWindow :: AfterSynchronizingStage&lt;/a&gt;。在&lt;a href=&quot;qtquick-visualcanvas-scenegraph#scene-graph-and-rendering&quot;&gt;同步阶段&lt;/a&gt;是其中场景图改变为更改QML树的结果。如果计划在其他任何时间进行清理，则可能会导致场景图的其他部分引用新删除的对象，因为这些部分尚未更新。</target>
        </trans-unit>
        <trans-unit id="0470cdb483508ebc7b70959dbd94540db4bc9c18" translate="yes" xml:space="preserve">
          <source>When sections are used, the first section command should be &lt;code&gt;section1&lt;/code&gt;.</source>
          <target state="translated">使用section时，第一个section命令应为 &lt;code&gt;section1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f5eedde8058556feb6cb3beeca59e7888ae6ece9" translate="yes" xml:space="preserve">
          <source>When selection is changed by clicking on the graph</source>
          <target state="translated">点击图形改变选择时</target>
        </trans-unit>
        <trans-unit id="00867511fe8868752b9e077a7707775ae9c1971d" translate="yes" xml:space="preserve">
          <source>When selection is changed explicitly via series API to a visible item</source>
          <target state="translated">当通过系列API将选择显式地改变为可见项时。</target>
        </trans-unit>
        <trans-unit id="2e1af7d1ebff8ce0a52ad99867add45c86a6ae89" translate="yes" xml:space="preserve">
          <source>When sending CAN FD frames, this flag is automatically set by the CAN FD hardware. &lt;code&gt;QCanBusFrame::setErrorStateIndicator()&lt;/code&gt; should only be used for application testing, e.g. on virtual CAN FD busses.</source>
          <target state="translated">发送CAN FD帧时，此标志由CAN FD硬件自动设置。 &lt;code&gt;QCanBusFrame::setErrorStateIndicator()&lt;/code&gt; 仅应用于应用程序测试，例如在虚拟CAN FD总线上。</target>
        </trans-unit>
        <trans-unit id="357729db045ad04ca40ebade91b854125d77106d" translate="yes" xml:space="preserve">
          <source>When sending CAN bus frames with &lt;a href=&quot;qcanbusdevice#ConfigurationKey-enum&quot;&gt;QCanBusDevice::ReceiveOwnKey&lt;/a&gt; enabled, all successfully sent frames are echoed to the receive queue and marked as local echo frames. &lt;code&gt;QCanBusFrame::setLocalEcho&lt;/code&gt; should therefore only be used for application testing, e.g. on virtual CAN busses.</source>
          <target state="translated">在启用&lt;a href=&quot;qcanbusdevice#ConfigurationKey-enum&quot;&gt;QCanBusDevice :: ReceiveOwnKey的情况下&lt;/a&gt;发送CAN总线帧时，所有成功发送的帧都会回显到接收队列中，并标记为本地回显帧。因此， &lt;code&gt;QCanBusFrame::setLocalEcho&lt;/code&gt; 应该仅用于应用程序测试，例如在虚拟CAN总线上。</target>
        </trans-unit>
        <trans-unit id="8bae5e50b5bdda4bb33ef7b2b1936a5c7112c234" translate="yes" xml:space="preserve">
          <source>When sending requests, to control the preference of when to use the cache and when to use the network, consider the following:</source>
          <target state="translated">在发送请求时,为了控制什么时候使用缓存,什么时候使用网络的偏好,可以考虑以下几点。</target>
        </trans-unit>
        <trans-unit id="73e7c0c4bd2ed4ad850a956107fc733151db2cb3" translate="yes" xml:space="preserve">
          <source>When sending, the &lt;a href=&quot;qnetworkdatagram#senderAddress&quot;&gt;senderAddress&lt;/a&gt;() and &lt;a href=&quot;qnetworkdatagram#senderPort&quot;&gt;senderPort&lt;/a&gt;() should contain the local address to be used when sending. The sender address must be an address that is assigned to this machine, which can be obtained using &lt;a href=&quot;qnetworkinterface&quot;&gt;QNetworkInterface&lt;/a&gt;, and the port number must be the port number that the socket is bound to. Either field can be left unset and will be filled in by the operating system with default values. The &lt;a href=&quot;qnetworkdatagram#destinationAddress&quot;&gt;destinationAddress&lt;/a&gt;() and &lt;a href=&quot;qnetworkdatagram#destinationPort&quot;&gt;destinationPort&lt;/a&gt;() fields may be set to a target address different from the one the UDP socket is currently associated with.</source>
          <target state="translated">发送时，&lt;a href=&quot;qnetworkdatagram#senderAddress&quot;&gt;senderAddress&lt;/a&gt;（）和&lt;a href=&quot;qnetworkdatagram#senderPort&quot;&gt;senderPort&lt;/a&gt;（）应该包含发送时要使用的本地地址。发件人地址必须是分配给此计算机的地址，可以使用&lt;a href=&quot;qnetworkinterface&quot;&gt;QNetworkInterface获取&lt;/a&gt;，并且端口号必须是套接字绑定到的端口号。这两个字段都可以保留不变，并且由操作系统使用默认值来填充。可以将&lt;a href=&quot;qnetworkdatagram#destinationAddress&quot;&gt;destinationAddress&lt;/a&gt;（）和&lt;a href=&quot;qnetworkdatagram#destinationPort&quot;&gt;destinationPort&lt;/a&gt;（）字段设置为与UDP套接字当前与之关联的目标地址不同的目标地址。</target>
        </trans-unit>
        <trans-unit id="bbc34b6972fd5a95f0e17a1bedd0814ddeba5170" translate="yes" xml:space="preserve">
          <source>When serialized item data is dropped onto a view, the data is inserted into the current model using its implementation of &lt;a href=&quot;qabstractitemmodel#dropMimeData&quot;&gt;QAbstractItemModel::dropMimeData&lt;/a&gt;(). The default implementation of this function will never overwrite any data in the model; instead, it tries to insert the items of data either as siblings of an item, or as children of that item.</source>
          <target state="translated">将序列化的项目数据放到视图上时，使用其&lt;a href=&quot;qabstractitemmodel#dropMimeData&quot;&gt;QAbstractItemModel :: dropMimeData&lt;/a&gt;（）实现将数据插入当前模型。该函数的默认实现将永远不会覆盖模型中的任何数据。而是尝试将数据项作为项的兄弟或项的子项插入。</target>
        </trans-unit>
        <trans-unit id="beb64bc37ef9e620c83f8575bbe6997166c3df77" translate="yes" xml:space="preserve">
          <source>When set on the characterFormat of a selection, the whole width of the text will be shown selected.</source>
          <target state="translated">当对一个选区的字符格式进行设置时,整个文本的宽度将被选中显示。</target>
        </trans-unit>
        <trans-unit id="270afeac1ae23334323cbd52bdb23f45e70ed478" translate="yes" xml:space="preserve">
          <source>When set to &lt;a href=&quot;qsensor#AxesOrientationMode-enum&quot;&gt;AutomaticOrientation&lt;/a&gt;, the reading values are automatically rotated when the screen orientation changes. In effect, the screen orientation is canceled out.</source>
          <target state="translated">设置为&lt;a href=&quot;qsensor#AxesOrientationMode-enum&quot;&gt;AutomaticOrientation&lt;/a&gt;时，屏幕方向更改时，读数值将自动旋转。实际上，屏幕方向被抵消了。</target>
        </trans-unit>
        <trans-unit id="e194e2df3cef00cb337af8c19d0b1fb4566ff905" translate="yes" xml:space="preserve">
          <source>When set to &lt;a href=&quot;qsensor#AxesOrientationMode-enum&quot;&gt;FixedOrientation&lt;/a&gt;, which is the default mode, no automatic rotation is applied to the reading. This is the only mode available for backends that do not support the &lt;a href=&quot;qsensor#Feature-enum&quot;&gt;QSensor::AxesOrientation&lt;/a&gt; feature.</source>
          <target state="translated">当设置为&lt;a href=&quot;qsensor#AxesOrientationMode-enum&quot;&gt;FixedOrientation时&lt;/a&gt;，这是默认模式，则不会将自动旋转应用于读数。这是不支持&lt;a href=&quot;qsensor#Feature-enum&quot;&gt;QSensor :: AxesOrientation&lt;/a&gt;功能的后端可用的唯一模式。</target>
        </trans-unit>
        <trans-unit id="f8c2be01f19679d844258975f1b00add910e8c48" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;1&lt;/code&gt;, Qt grabs the device for exclusive use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35fbd74909144bf9e11c35c0ff6fab64956af13b" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;false&lt;/code&gt;, rendering is done in single pass. In this mode the depth buffer is not used at all, and all objects are rendered in a single back to front pass.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1c4e86e296a0003f811fe8398c8194c0172e276" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;transparent&lt;/code&gt;, no filling occurs.</source>
          <target state="translated">设置为 &lt;code&gt;transparent&lt;/code&gt; 时，不会发生填充。</target>
        </trans-unit>
        <trans-unit id="a494091a2d78c1c83239a6f4b1f78cd17e064c58" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;transparent&lt;/code&gt;, no stroking occurs.</source>
          <target state="translated">设置为 &lt;code&gt;transparent&lt;/code&gt; 时，不会发生描边。</target>
        </trans-unit>
        <trans-unit id="d01263f2091d195480c96c2d03450e33391dffb1" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the exterior of the item is padded with a 1 pixel wide transparent edge, making sampling outside the source texture use transparency instead of the edge pixels. Without this property, an image which has opaque edges will not get a blurred shadow.</source>
          <target state="translated">设置为 &lt;code&gt;true&lt;/code&gt; 时，将在项目的外部填充1像素宽的透明边缘，从而使在源纹理之外的采样使用透明度而不是边缘像素。没有此属性，边缘不透明的图像将不会产生模糊的阴影。</target>
        </trans-unit>
        <trans-unit id="b450467a36089b6e8cc7c9384688033053a7e1e0" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the exterior of the item is padded with a transparent edge, making sampling outside the source texture use transparency instead of the edge pixels. Without this property, an image which has opaque edges will not get a blurred edge.</source>
          <target state="translated">设置为 &lt;code&gt;true&lt;/code&gt; 时，将使用透明边缘填充项目的外部，从而使源纹理外部的采样使用透明而不是边缘像素。没有此属性，边缘不透明的图像将不会模糊。</target>
        </trans-unit>
        <trans-unit id="e4147d132167beace31a7c2f2898d532610dfada" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the mapping ignores any explicitly set column categories and overwrites them with automatically generated ones whenever the data from model is resolved. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果设置为 &lt;code&gt;true&lt;/code&gt; ，则映射将忽略任何显式设置的列类别，并在解析模型中的数据时使用自动生成的列类别覆盖它们。默认为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="36e27ee6dcb20f63a267c063b5f0dd2344ea8112" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the mapping ignores any explicitly set column categories and overwrites them with automatically generated ones whenever the data from the model is resolved. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果设置为 &lt;code&gt;true&lt;/code&gt; ，则映射将忽略任何显式设置的列类别，并在解析模型中的数据时使用自动生成的列类别覆盖它们。默认为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aeaf1add3a3c03b3752ea390e4de636b57ce02e7" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the mapping ignores any explicitly set column categories and overwrites them with automatically generated ones whenever the data from the model is resolved. Proxy minimum and maximum column values are also autogenerated from the data when this is set to &lt;code&gt;true&lt;/code&gt;. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果设置为 &lt;code&gt;true&lt;/code&gt; ，则映射将忽略任何显式设置的列类别，并在解析模型中的数据时使用自动生成的列类别覆盖它们。当设置为 &lt;code&gt;true&lt;/code&gt; 时，代理最小和最大列值也会从数据中自动生成。默认为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c86619e8213d5bed1738d02c582750355d6522a4" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the mapping ignores any explicitly set row categories and overwrites them with automatically generated ones whenever the data from model is resolved. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果设置为 &lt;code&gt;true&lt;/code&gt; ，则映射将忽略任何显式设置的行类别，并在解析模型中的数据时将其自动生成的类别覆盖。默认为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d11c86fa7ccfd6ba9e683cd50f0c094403577ac1" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the mapping ignores any explicitly set row categories and overwrites them with automatically generated ones whenever the data from the model is resolved. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果设置为 &lt;code&gt;true&lt;/code&gt; ，则映射将忽略任何显式设置的行类别，并在解析模型中的数据时使用自动生成的行类别覆盖它们。默认为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1301757ff1650814b570b349ec4348010d05817d" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the mapping ignores any explicitly set row categories and overwrites them with automatically generated ones whenever the data from the model is resolved. Proxy minimum and maximum row values are also autogenerated from the data when this is set to &lt;code&gt;true&lt;/code&gt;. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果设置为 &lt;code&gt;true&lt;/code&gt; ，则映射将忽略任何显式设置的行类别，并在解析模型中的数据时使用自动生成的行类别覆盖它们。当设置为 &lt;code&gt;true&lt;/code&gt; 时，代理最小和最大行值也会从数据中自动生成。默认为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7acc0959296f9d8e8c2e2b6cb1d3a66719167a16" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the mapping ignores row and column roles and categories, and uses the rows and columns from the model instead. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">设置为 &lt;code&gt;true&lt;/code&gt; 时，映射将忽略行和列的角色和类别，而是使用模型中的行和列。默认为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5f951719e1af643c50c67762d555cf0e850cebdd" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the mapping ignores row and column roles and categories, and uses the rows and columns from the model instead. Row and column headers are used for row and column labels. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">设置为 &lt;code&gt;true&lt;/code&gt; 时，映射将忽略行和列的角色和类别，而是使用模型中的行和列。行标题和列标题用于行和列标签。默认为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3496a774f53b66ac5b73d84b633a1d9d7d924d85" translate="yes" xml:space="preserve">
          <source>When set to a negative value, no stroking occurs.</source>
          <target state="translated">当设置为负值时,不会发生冲程。</target>
        </trans-unit>
        <trans-unit id="4e4ee14f2ec2d88c31367b1d93f593e8267881e4" translate="yes" xml:space="preserve">
          <source>When set to an empty string, the default label of the underlying platform is used. The default label is typically &lt;b&gt;Cancel&lt;/b&gt;.</source>
          <target state="translated">设置为空字符串时，将使用基础平台的默认标签。默认标签通常为&lt;b&gt;Cancel&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="71b7a30cacf1f3a3ee6a4172e8fb4bd21a402ed0" translate="yes" xml:space="preserve">
          <source>When set to an empty string, the default label of the underlying platform is used. The default label is typically &lt;b&gt;Open&lt;/b&gt; or &lt;b&gt;Save&lt;/b&gt; depending on which &lt;a href=&quot;qml-qt-labs-platform-filedialog#fileMode-prop&quot;&gt;fileMode&lt;/a&gt; the dialog is used in.</source>
          <target state="translated">设置为空字符串时，将使用基础平台的默认标签。默认标签通常是&lt;b&gt;打开&lt;/b&gt;还是&lt;b&gt;保存&lt;/b&gt;，这取决于&lt;a href=&quot;qml-qt-labs-platform-filedialog#fileMode-prop&quot;&gt;中将fileMode&lt;/a&gt;中使用的对话框。</target>
        </trans-unit>
        <trans-unit id="fa9215824a888cc448b2b5104b3e0edb6ca3f827" translate="yes" xml:space="preserve">
          <source>When set to an empty string, the default label of the underlying platform is used. The default label is typically &lt;b&gt;Open&lt;/b&gt;.</source>
          <target state="translated">设置为空字符串时，将使用基础平台的默认标签。默认标签通常为&lt;b&gt;Open&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="da31d475a6141d1527e3930e3b780117133be781" translate="yes" xml:space="preserve">
          <source>When set to true, a connection is made to the server with the given url. When set to false, the connection is closed. The default value is false.</source>
          <target state="translated">当设置为 &quot;true &quot;时,用给定的url建立与服务器的连接。当设置为false时,连接被关闭。默认值为false。</target>
        </trans-unit>
        <trans-unit id="d356d95380e0a7be709c939454d729283fff95fe" translate="yes" xml:space="preserve">
          <source>When set to true, updates are blocked and remote clients will not be notified about property changes.</source>
          <target state="translated">当设置为 &quot;true &quot;时,将阻止更新,并且不会通知远程客户端有关属性变化。</target>
        </trans-unit>
        <trans-unit id="9070c24af14ff16b55ce450d03070776a1d63544" translate="yes" xml:space="preserve">
          <source>When set, &lt;a href=&quot;qml-qtquick-shapes-shapepath&quot;&gt;ShapePath&lt;/a&gt;.&lt;a href=&quot;qml-qtquick-shapes-shapepath#fillColor-prop&quot;&gt;fillColor&lt;/a&gt; is ignored and filling is done using one of the &lt;a href=&quot;qml-qtquick-shapes-shapegradient&quot;&gt;ShapeGradient&lt;/a&gt; subtypes.</source>
          <target state="translated">设置后，为&lt;a href=&quot;qml-qtquick-shapes-shapepath&quot;&gt;ShapePath&lt;/a&gt;。&lt;a href=&quot;qml-qtquick-shapes-shapepath#fillColor-prop&quot;&gt;fillColor将&lt;/a&gt;被忽略，并使用&lt;a href=&quot;qml-qtquick-shapes-shapegradient&quot;&gt;ShapeGradient&lt;/a&gt;子类型之一进行填充。</target>
        </trans-unit>
        <trans-unit id="1d5a93253ef1915d6faa59a1fad7ff2aba883814" translate="yes" xml:space="preserve">
          <source>When set, &lt;code&gt;eglfs&lt;/code&gt; requests &lt;code&gt;FBIO_WAITFORVSYNC&lt;/code&gt; on the framebuffer device after each call to eglSwapBuffers(). This variable is only relevant for backends relying on the legacy Linux &lt;code&gt;fbdev&lt;/code&gt; subsystem. Normally, with a default swap interval of 1, Qt assumes that calling eglSwapBuffers() takes care of vsync; if it doesn't (for example, due to driver bugs), try setting &lt;code&gt;QT_QPA_EGLFS_FORCEVSYNC&lt;/code&gt; to a non-zero value.</source>
          <target state="translated">设置后， &lt;code&gt;eglfs&lt;/code&gt; 在每次调用eglSwapBuffers（）之后在帧缓冲设备上请求 &lt;code&gt;FBIO_WAITFORVSYNC&lt;/code&gt; 。该变量仅与依赖于传统Linux &lt;code&gt;fbdev&lt;/code&gt; 子系统的后端有关。通常，在默认交换间隔为1的情况下，Qt假定调用eglSwapBuffers（）会处理vsync。如果不是（例如由于驱动程序错误），请尝试将 &lt;code&gt;QT_QPA_EGLFS_FORCEVSYNC&lt;/code&gt; 设置为非零值。</target>
        </trans-unit>
        <trans-unit id="9744299b5e8df688636dffff69d9ac6cfe828468" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by column role before it is used as a column category. This property specifies the regular expression to find the portion of the mapped value to replace and &lt;a href=&quot;qml-qtdatavisualization-itemmodelbardataproxy#columnRoleReplace-prop&quot;&gt;columnRoleReplace&lt;/a&gt; property contains the replacement string. This is useful for example in parsing row and column categories from a single timestamp field in the item model.</source>
          <target state="translated">设置后，将在按列角色映射的值用作列类别之前对其进行搜索和替换。此属性指定正则表达式以查找要替换的映射值的一部分，并且&lt;a href=&quot;qml-qtdatavisualization-itemmodelbardataproxy#columnRoleReplace-prop&quot;&gt;columnRoleReplace&lt;/a&gt;属性包含替换字符串。例如，这在从项目模型中的单个时间戳字段解析行和列类别时很有用。</target>
        </trans-unit>
        <trans-unit id="8a131bdf52627ee3b863efe9743b906a421ee8f9" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by rotation role before it is used as a bar rotation angle. This property specifies the regular expression to find the portion of the mapped value to replace and &lt;a href=&quot;qml-qtdatavisualization-itemmodelbardataproxy#rotationRoleReplace-prop&quot;&gt;rotationRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">设置后，将在旋转角色所映射的值用作钢筋旋转角度之前对其进行搜索和替换。此属性指定正则表达式以查找要替换的映射值的一部分，并且&lt;a href=&quot;qml-qtdatavisualization-itemmodelbardataproxy#rotationRoleReplace-prop&quot;&gt;rotationRoleReplace&lt;/a&gt;属性包含替换字符串。</target>
        </trans-unit>
        <trans-unit id="9108433232a1c54c0f0add6d2c59552f382b7483" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by row role before it is used as a row category. This property specifies the regular expression to find the portion of the mapped value to replace and &lt;a href=&quot;qml-qtdatavisualization-itemmodelbardataproxy#rowRoleReplace-prop&quot;&gt;rowRoleReplace&lt;/a&gt; property contains the replacement string. This is useful for example in parsing row and column categories from a single timestamp field in the item model.</source>
          <target state="translated">设置后，将在按行角色映射的值用作行类别之前对其进行搜索和替换。此属性指定正则表达式以查找要替换的映射值的一部分，并且&lt;a href=&quot;qml-qtdatavisualization-itemmodelbardataproxy#rowRoleReplace-prop&quot;&gt;rowRoleReplace&lt;/a&gt;属性包含替换字符串。例如，这在从项目模型中的单个时间戳字段解析行和列类别时很有用。</target>
        </trans-unit>
        <trans-unit id="bc9c1cbcb787214aaefb29b1ef7ac7fde2064a50" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by the column role before it is used as a column category. This property specifies the regular expression to find the portion of the mapped value to replace and the &lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#columnRoleReplace-prop&quot;&gt;columnRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">设置后，在将列角色映射的值用作列类别之前对其进行搜索和替换。此属性指定正则表达式以查找要替换的映射值的一部分，并且&lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#columnRoleReplace-prop&quot;&gt;columnRoleReplace&lt;/a&gt;属性包含替换字符串。</target>
        </trans-unit>
        <trans-unit id="6c6f75996ea55b81eb144da97f4ddbf1f7b8d2df" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by the rotation role before it is used as item rotation. This property specifies the regular expression to find the portion of the mapped value to replace and &lt;a href=&quot;qml-qtdatavisualization-itemmodelscatterdataproxy#rotationRoleReplace-prop&quot;&gt;rotationRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">设置后，将在旋转角色所映射的值用作项目旋转之前对其进行搜索和替换。此属性指定正则表达式以查找要替换的映射值的一部分，并且&lt;a href=&quot;qml-qtdatavisualization-itemmodelscatterdataproxy#rotationRoleReplace-prop&quot;&gt;rotationRoleReplace&lt;/a&gt;属性包含替换字符串。</target>
        </trans-unit>
        <trans-unit id="4d7bce4ff7100e6fa830173aafe199aab62b818f" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by the row role before it is used as a row category. This property specifies the regular expression to find the portion of the mapped value to replace and the &lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#rowRoleReplace-prop&quot;&gt;rowRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">设置后，将在行角色映射的值用作行类别之前对其进行搜索和替换。此属性指定正则表达式以查找要替换的映射值的一部分，并且&lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#rowRoleReplace-prop&quot;&gt;rowRoleReplace&lt;/a&gt;属性包含替换字符串。</target>
        </trans-unit>
        <trans-unit id="885cf3aa8085356e119ac0af240743c4239afe83" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by the x position role before it is used as an item position value. This property specifies the regular expression to find the portion of the mapped value to replace and &lt;a href=&quot;qml-qtdatavisualization-itemmodelscatterdataproxy#xPosRoleReplace-prop&quot;&gt;xPosRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">设置后，将在x位置角色所映射的值用作项目位置值之前对其进行搜索和替换。此属性指定正则表达式以查找要替换的映射值的一部分，并且&lt;a href=&quot;qml-qtdatavisualization-itemmodelscatterdataproxy#xPosRoleReplace-prop&quot;&gt;xPosRoleReplace&lt;/a&gt;属性包含替换字符串。</target>
        </trans-unit>
        <trans-unit id="66303afda7fe28b42306b119120f8c9d8ffe13b2" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by the x position role before it is used as an item position value. This property specifies the regular expression to find the portion of the mapped value to replace and the &lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#xPosRoleReplace-prop&quot;&gt;xPosRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">设置后，将在x位置角色所映射的值用作项目位置值之前对其进行搜索和替换。此属性指定正则表达式以查找要替换的映射值的一部分，并且&lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#xPosRoleReplace-prop&quot;&gt;xPosRoleReplace&lt;/a&gt;属性包含替换字符串。</target>
        </trans-unit>
        <trans-unit id="177b7625ed57441e9caab15b1ba52de1056c1697" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by the y position role before it is used as an item position value. This property specifies the regular expression to find the portion of the mapped value to replace and &lt;a href=&quot;qml-qtdatavisualization-itemmodelscatterdataproxy#yPosRoleReplace-prop&quot;&gt;yPosRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">设置后，将在y位置角色所映射的值用作项目位置值之前对其进行搜索和替换。此属性指定正则表达式以查找要替换的映射值的一部分，并且&lt;a href=&quot;qml-qtdatavisualization-itemmodelscatterdataproxy#yPosRoleReplace-prop&quot;&gt;yPosRoleReplace&lt;/a&gt;属性包含替换字符串。</target>
        </trans-unit>
        <trans-unit id="4cd4628ea893e9ef8db7b0e103b8b8eb84582ee7" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by the y position role before it is used as an item position value. This property specifies the regular expression to find the portion of the mapped value to replace and the &lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#yPosRoleReplace-prop&quot;&gt;yPosRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">设置后，将在y位置角色所映射的值用作项目位置值之前对其进行搜索和替换。此属性指定正则表达式以查找要替换的映射值的一部分，并且&lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#yPosRoleReplace-prop&quot;&gt;yPosRoleReplace&lt;/a&gt;属性包含替换字符串。</target>
        </trans-unit>
        <trans-unit id="e690058b1d8c0f0ea729f77975b58803689a29ce" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by the z position role before it is used as an item position value. This property specifies the regular expression to find the portion of the mapped value to replace and &lt;a href=&quot;qml-qtdatavisualization-itemmodelscatterdataproxy#zPosRoleReplace-prop&quot;&gt;zPosRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">设置后，在将z位置角色所映射的值用作项目位置值之前对其进行搜索和替换。此属性指定正则表达式以查找要替换的映射值的一部分，并且&lt;a href=&quot;qml-qtdatavisualization-itemmodelscatterdataproxy#zPosRoleReplace-prop&quot;&gt;zPosRoleReplace&lt;/a&gt;属性包含替换字符串。</target>
        </trans-unit>
        <trans-unit id="8a50a48a136eb418621caa5d9975fa8698821525" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by the z position role before it is used as an item position value. This property specifies the regular expression to find the portion of the mapped value to replace and the &lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#zPosRoleReplace-prop&quot;&gt;zPosRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">设置后，在将z位置角色所映射的值用作项目位置值之前对其进行搜索和替换。此属性指定正则表达式以查找要替换的映射值的一部分，并且&lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#zPosRoleReplace-prop&quot;&gt;zPosRoleReplace&lt;/a&gt;属性包含替换字符串。</target>
        </trans-unit>
        <trans-unit id="9e6e26fa69d41d9769f5fde960eb52cd2c8473db" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by value role before it is used as a bar value. This property specifies the regular expression to find the portion of the mapped value to replace and &lt;a href=&quot;qml-qtdatavisualization-itemmodelbardataproxy#valueRoleReplace-prop&quot;&gt;valueRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">设置后，将搜索和替换按值角色映射的值，然后将其用作条形值。此属性指定正则表达式以查找要替换的映射值的一部分，并且&lt;a href=&quot;qml-qtdatavisualization-itemmodelbardataproxy#valueRoleReplace-prop&quot;&gt;valueRoleReplace&lt;/a&gt;属性包含替换字符串。</target>
        </trans-unit>
        <trans-unit id="57e671691d58c18370650113c81b9894428ab1c0" translate="yes" xml:space="preserve">
          <source>When set, some debugging information is printed on the debug output. For example, the input &lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat&lt;/a&gt; and the properties of the chosen EGL configuration are printed while creating a new context. When used together with Qt Quick's &lt;code&gt;QSG_INFO&lt;/code&gt; variable, you can get useful information for troubleshooting issues related to the EGL configuration.</source>
          <target state="translated">设置后，一些调试信息会打印在调试输出上。例如，在创建新上下文时，将打印输入&lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat&lt;/a&gt;和所选EGL配置的属性。与Qt Quick的 &lt;code&gt;QSG_INFO&lt;/code&gt; 变量一起使用时，您可以获得有关排除EGL配置相关问题的有用信息。</target>
        </trans-unit>
        <trans-unit id="c63ec68c079a9bce145854c06f681928a4a99fb9" translate="yes" xml:space="preserve">
          <source>When set, the red, green, and blue color channel sizes are ignored when &lt;code&gt;eglfs&lt;/code&gt; creates a new context, window or offscreen surface. Instead, the plugin requests a configuration with 8 bits per channel. This can be helpful on devices where configurations with less than 32 or 24 bits per pixel (for example, 5-6-5 or 4-4-4) are chosen by default despite knowing they are not ideal, for example, due to banding effects. Instead of changing application code, this variable provides a shortcut to force 24 or 32 bpp configurations.</source>
          <target state="translated">设置后，当 &lt;code&gt;eglfs&lt;/code&gt; 创建新的上下文，窗口或屏幕外表面时，红色，绿色和蓝色通道大小将被忽略。而是，插件请求每通道8位的配置。这对于在默认情况下选择每像素少于32或24位的配置（例如5-6-5或4-4-4）的设备很有帮助，尽管知道它们不理想，例如由于条带效果。代替更改应用程序代码，此变量提供了强制执行24或32 bpp配置的快捷方式。</target>
        </trans-unit>
        <trans-unit id="33b3bd9431a5daf3aec6eea2743d997f576dc8d8" translate="yes" xml:space="preserve">
          <source>When setting &lt;a href=&quot;qml-qtquick-item#clip-prop&quot;&gt;Item::clip&lt;/a&gt; to true, it will create a &lt;a href=&quot;qsgclipnode&quot;&gt;QSGClipNode&lt;/a&gt; with a rectangle in its geometry. The default renderer will apply this clip by using scissoring in OpenGL. If the item is rotated by a non-90-degree angle, the OpenGL's stencil buffer is used. Qt Quick Item only supports setting a rectangle as clip through QML, but the scene graph API and the default renderer can use any shape for clipping.</source>
          <target state="translated">将&lt;a href=&quot;qml-qtquick-item#clip-prop&quot;&gt;Item :: clip&lt;/a&gt;设置为true时，将创建一个&lt;a href=&quot;qsgclipnode&quot;&gt;QSGClipNode&lt;/a&gt;，其几何形状为矩形。默认渲染器将通过在OpenGL中使用剪刀来应用此剪辑。如果将项目旋转​​了非90度角，则使用OpenGL的模板缓冲区。Qt Quick Item仅支持通过QML将矩形设置为剪辑，但是场景图API和默认渲染器可以使用任何形状进行剪辑。</target>
        </trans-unit>
        <trans-unit id="a5ed62e892daca59bcdf47a39598aaed448ddccb" translate="yes" xml:space="preserve">
          <source>When setting a maximum date, the &lt;a href=&quot;qcalendarwidget#minimumDate-prop&quot;&gt;minimumDate&lt;/a&gt; and &lt;a href=&quot;qcalendarwidget#selectedDate-prop&quot;&gt;selectedDate&lt;/a&gt; properties are adjusted if the selection range becomes invalid. If the provided date is not a valid &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; object, the setMaximumDate() function does nothing.</source>
          <target state="translated">设置最大日期时，如果选择范围无效，则会调整&lt;a href=&quot;qcalendarwidget#minimumDate-prop&quot;&gt;minimumDate&lt;/a&gt;和&lt;a href=&quot;qcalendarwidget#selectedDate-prop&quot;&gt;selectedDate&lt;/a&gt;属性。如果提供的日期不是有效的&lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt;对象，则setMaximumDate（）函数将不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="c4ae2d023320be5119694dfde25d7c2125941c8d" translate="yes" xml:space="preserve">
          <source>When setting a minimum date, the &lt;a href=&quot;qcalendarwidget#maximumDate-prop&quot;&gt;maximumDate&lt;/a&gt; and &lt;a href=&quot;qcalendarwidget#selectedDate-prop&quot;&gt;selectedDate&lt;/a&gt; properties are adjusted if the selection range becomes invalid. If the provided date is not a valid &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; object, the setMinimumDate() function does nothing.</source>
          <target state="translated">设置最小日期时，如果选择范围无效，则会调整&lt;a href=&quot;qcalendarwidget#maximumDate-prop&quot;&gt;maximumDate&lt;/a&gt;和&lt;a href=&quot;qcalendarwidget#selectedDate-prop&quot;&gt;selectedDate&lt;/a&gt;属性。如果提供的日期不是有效的&lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt;对象，则setMinimumDate（）函数将不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="6eeb8a01ae2a0c99098eee6b5e541fd874b03835" translate="yes" xml:space="preserve">
          <source>When setting the fragment or vertex shader source code, the status will become Uncompiled. The first time the &lt;a href=&quot;qml-qtquick-shadereffect&quot;&gt;ShaderEffect&lt;/a&gt; is rendered with new shader source code, the shaders are compiled and linked, and the status is updated to Compiled or Error.</source>
          <target state="translated">设置片段或顶点着色器源代码时，状态将变为&amp;ldquo;未编译&amp;rdquo;。第一次使用新的着色器源代码渲染&lt;a href=&quot;qml-qtquick-shadereffect&quot;&gt;ShaderEffect时&lt;/a&gt;，将编译并链接着色器，并且状态将更新为&amp;ldquo;已编译&amp;rdquo;或&amp;ldquo;错误&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="12bc8cc3889504df656aec89fdae8d32b48b48bd" translate="yes" xml:space="preserve">
          <source>When setting the pick method to &lt;a href=&quot;qt3drender-qpickingsettings#PickResultMode-enum&quot;&gt;AllPicks&lt;/a&gt;, events will be triggered for all the entities with a &lt;a href=&quot;qt3drender-qobjectpicker&quot;&gt;QObjectPicker&lt;/a&gt; along the ray.</source>
          <target state="translated">当将pick方法设置为&lt;a href=&quot;qt3drender-qpickingsettings#PickResultMode-enum&quot;&gt;AllPicks时&lt;/a&gt;，将为所有带有沿射线的&lt;a href=&quot;qt3drender-qobjectpicker&quot;&gt;QObjectPicker&lt;/a&gt;的实体触发事件。</target>
        </trans-unit>
        <trans-unit id="faf0f4e80eb610da479dd49899491179142a9cfd" translate="yes" xml:space="preserve">
          <source>When setting the pick method to &lt;a href=&quot;qt3drender-qpickingsettings#PickResultMode-enum&quot;&gt;NearestPriorityPick&lt;/a&gt;, events will be triggered for the nearest highest priority picker. This can be used when a given element should always be selected even if others are in front of it.</source>
          <target state="translated">当将pick方法设置为&lt;a href=&quot;qt3drender-qpickingsettings#PickResultMode-enum&quot;&gt;NearestPriorityPick时&lt;/a&gt;，将为最接近的最高优先级选择器触发事件​​。当应该始终选择给定元素（即使其他元素在其前面）时，可以使用此方法。</target>
        </trans-unit>
        <trans-unit id="46eaad0ccb2bedbfcbdda653384c06947cbb2dbb" translate="yes" xml:space="preserve">
          <source>When setting the year using the Date constructor or set(UTC)FullYear(), the convention set by ISO 8601 is used and 0 is a valid year. This means negative years set with the constructor or set(UTC)FullYear() are zero-based and thus offset by one year from what is printed with toString() and friends. Parsing the output of any of the to*String() methods will yield the same date value you printed from. Date.parse() will recognize the different formats and their convention on the existence of year 0.</source>
          <target state="translated">当使用Date构造函数或set(UTC)FullYear()设置年份时,使用ISO 8601设置的惯例,0是有效的年份。这意味着用构造函数或set(UTC)FullYear()设置的负年份是基于零的,因此与toString()和friends的打印结果相差一年。解析任何一个to*String()方法的输出,都会得到你打印出来的相同的日期值。Date.parse()将识别不同的格式及其对0年存在的约定。</target>
        </trans-unit>
        <trans-unit id="99af14a2050e900c54b4cf4320044307dba2671c" translate="yes" xml:space="preserve">
          <source>When setting this property &lt;a href=&quot;qtextbrowser&quot;&gt;QTextBrowser&lt;/a&gt; tries to find a document with the specified name in the paths of the &lt;a href=&quot;qtextbrowser#searchPaths-prop&quot;&gt;searchPaths&lt;/a&gt; property and directory of the current source, unless the value is an absolute file path. It also checks for optional anchors and scrolls the document accordingly</source>
          <target state="translated">设置此属性时，除非该值是绝对文件路径，否则&lt;a href=&quot;qtextbrowser&quot;&gt;QTextBrowser&lt;/a&gt;尝试在&lt;a href=&quot;qtextbrowser#searchPaths-prop&quot;&gt;searchPaths&lt;/a&gt;属性的路径和当前源的目录中查找具有指定名称的文档。它还检查可选的锚点并相应地滚动文档</target>
        </trans-unit>
        <trans-unit id="fce20a64ddb9efcd0a6072a5a5807d0354c99c5b" translate="yes" xml:space="preserve">
          <source>When setting this property the &lt;a href=&quot;qdatetimeedit#maximumDate-prop&quot;&gt;maximumDate&lt;/a&gt; is adjusted if necessary, to ensure that the range remains valid. If the date is not a valid &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; object, this function does nothing.</source>
          <target state="translated">设置此属性时，如有必要，将调整&lt;a href=&quot;qdatetimeedit#maximumDate-prop&quot;&gt;maximumDate&lt;/a&gt;，以确保范围保持有效。如果日期不是有效的&lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt;对象，则此函数不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="f3536a246a03f23af815f636527d6ffa980281bd" translate="yes" xml:space="preserve">
          <source>When setting this property the &lt;a href=&quot;qdatetimeedit#maximumDateTime-prop&quot;&gt;maximumDateTime&lt;/a&gt;() is adjusted if necessary to ensure that the range remains valid. If the datetime is not a valid &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; object, this function does nothing.</source>
          <target state="translated">设置此属性时，如有必要，将调整&lt;a href=&quot;qdatetimeedit#maximumDateTime-prop&quot;&gt;maximumDateTime&lt;/a&gt;（）以确保范围保持有效。如果datetime不是有效的&lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt;对象，则此函数不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="1d3985b1214032de5548d5f37a050ce05224466f" translate="yes" xml:space="preserve">
          <source>When setting this property the &lt;a href=&quot;qdatetimeedit#maximumTime-prop&quot;&gt;maximumTime&lt;/a&gt; is adjusted if necessary, to ensure that the range remains valid. If the time is not a valid &lt;a href=&quot;qtime&quot;&gt;QTime&lt;/a&gt; object, this function does nothing.</source>
          <target state="translated">设置此属性时，如有必要，将调整&lt;a href=&quot;qdatetimeedit#maximumTime-prop&quot;&gt;maximumTime&lt;/a&gt;，以确保范围保持有效。如果时间不是有效的&lt;a href=&quot;qtime&quot;&gt;QTime&lt;/a&gt;对象，则此函数不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="3a94d8175867d402a4937ec027013411408a4199" translate="yes" xml:space="preserve">
          <source>When setting this property the &lt;a href=&quot;qdatetimeedit#minimumDate-prop&quot;&gt;minimumDate&lt;/a&gt; is adjusted if necessary to ensure that the range remains valid. If the date is not a valid &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; object, this function does nothing.</source>
          <target state="translated">设置此属性时，如有必要，将调整&lt;a href=&quot;qdatetimeedit#minimumDate-prop&quot;&gt;minimumDate&lt;/a&gt;以确保范围保持有效。如果日期不是有效的&lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt;对象，则此函数不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="d00e3ae41e62b165ec366eabf69c76f997cb71bc" translate="yes" xml:space="preserve">
          <source>When setting this property the &lt;a href=&quot;qdatetimeedit#minimumDateTime-prop&quot;&gt;minimumDateTime&lt;/a&gt;() is adjusted if necessary to ensure that the range remains valid. If the datetime is not a valid &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; object, this function does nothing.</source>
          <target state="translated">设置此属性时，如有必要，将调整&lt;a href=&quot;qdatetimeedit#minimumDateTime-prop&quot;&gt;minimumDateTime&lt;/a&gt;（）以确保范围保持有效。如果datetime不是有效的&lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt;对象，则此函数不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="fd101378453eccdf2e848a4824798dd5c0a85b7e" translate="yes" xml:space="preserve">
          <source>When setting this property the &lt;a href=&quot;qdoublespinbox#maximum-prop&quot;&gt;maximum&lt;/a&gt; is adjusted if necessary to ensure that the range remains valid.</source>
          <target state="translated">设置此属性时，如有必要，将调整&lt;a href=&quot;qdoublespinbox#maximum-prop&quot;&gt;最大值，&lt;/a&gt;以确保范围保持有效。</target>
        </trans-unit>
        <trans-unit id="d52e2cb44d7f2ae6749696edb496d673ee39757f" translate="yes" xml:space="preserve">
          <source>When setting this property the &lt;a href=&quot;qdoublespinbox#minimum-prop&quot;&gt;minimum&lt;/a&gt; is adjusted if necessary, to ensure that the range remains valid.</source>
          <target state="translated">设置此属性时，如有必要，将调整&lt;a href=&quot;qdoublespinbox#minimum-prop&quot;&gt;最小值&lt;/a&gt;，以确保范围保持有效。</target>
        </trans-unit>
        <trans-unit id="47cfedf6ef21c709f13ba69a81ab6789fc8a9fd1" translate="yes" xml:space="preserve">
          <source>When setting this property the &lt;a href=&quot;qspinbox#maximum-prop&quot;&gt;maximum&lt;/a&gt; is adjusted if necessary to ensure that the range remains valid.</source>
          <target state="translated">设置此属性时，如有必要，将调整&lt;a href=&quot;qspinbox#maximum-prop&quot;&gt;最大值，&lt;/a&gt;以确保范围保持有效。</target>
        </trans-unit>
        <trans-unit id="9b3aa09d9d597d2ccc6d81186f12b9dee43bde16" translate="yes" xml:space="preserve">
          <source>When setting this property the corresponding maximum value is adjusted if necessary, to ensure that the range remains valid.</source>
          <target state="translated">在设置该属性时,必要时调整相应的最大值,以确保该范围保持有效。</target>
        </trans-unit>
        <trans-unit id="ed5abb02b8b1a236c42c80272c5d4f7b5e792484" translate="yes" xml:space="preserve">
          <source>When setting this property the corresponding minimum value is adjusted if necessary, to ensure that the range remains valid.</source>
          <target state="translated">设置该属性时,必要时调整相应的最小值,以保证该范围保持有效。</target>
        </trans-unit>
        <trans-unit id="0e2d22ffaa8c87cce0769e98c3a06583fa170f8d" translate="yes" xml:space="preserve">
          <source>When setting this property the minimum is adjusted if necessary, to ensure that the range remains valid.</source>
          <target state="translated">当设置该属性时,必要时调整最小值,以确保该范围保持有效。</target>
        </trans-unit>
        <trans-unit id="10bbb03412564a8a76a7faa470981f3e92871bb0" translate="yes" xml:space="preserve">
          <source>When setting this property the timespec of the &lt;a href=&quot;qdatetimeedit&quot;&gt;QDateTimeEdit&lt;/a&gt; remains the same and the timespec of the new &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; is ignored.</source>
          <target state="translated">当设置该属性的的timespec &lt;a href=&quot;qdatetimeedit&quot;&gt;QDateTimeEdit&lt;/a&gt;保持不变，新的的timespec &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt;被忽略。</target>
        </trans-unit>
        <trans-unit id="2375a6809ff71a69632c1ba6bc4411bcbd56175e" translate="yes" xml:space="preserve">
          <source>When setting this property to a list of waypoints, each waypoint can be either a &lt;a href=&quot;qml-coordinate&quot;&gt;coordinate&lt;/a&gt; or a &lt;a href=&quot;qml-qtlocation-waypoint&quot;&gt;Waypoint&lt;/a&gt;, interchangeably. If a &lt;a href=&quot;qml-coordinate&quot;&gt;coordinate&lt;/a&gt; is passed, it will be internally converted to a &lt;a href=&quot;qml-qtlocation-waypoint&quot;&gt;Waypoint&lt;/a&gt;.</source>
          <target state="translated">将此属性设置为路点列表时，每个路点可以是&lt;a href=&quot;qml-coordinate&quot;&gt;坐标&lt;/a&gt;或路&lt;a href=&quot;qml-qtlocation-waypoint&quot;&gt;点&lt;/a&gt;，可以互换。如果传递了&lt;a href=&quot;qml-coordinate&quot;&gt;坐标&lt;/a&gt;，则它将在内部转换为&lt;a href=&quot;qml-qtlocation-waypoint&quot;&gt;Waypoint&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8c08c05c4f9a6cc8ebd2fa6d3ff3659b0e8d5359" translate="yes" xml:space="preserve">
          <source>When setting this property, the &lt;a href=&quot;qabstractslider#maximum-prop&quot;&gt;maximum&lt;/a&gt; is adjusted if necessary to ensure that the range remains valid. Also the slider's current value is adjusted to be within the new range.</source>
          <target state="translated">设置此属性时，如有必要，将调整&lt;a href=&quot;qabstractslider#maximum-prop&quot;&gt;最大值&lt;/a&gt;以确保范围保持有效。同样，将滑块的当前值调整到新范围内。</target>
        </trans-unit>
        <trans-unit id="083344e77b31d85a0b5a8a8283eca8fda3876952" translate="yes" xml:space="preserve">
          <source>When setting this property, the &lt;a href=&quot;qabstractslider#minimum-prop&quot;&gt;minimum&lt;/a&gt; is adjusted if necessary to ensure that the range remains valid. Also the slider's current value is adjusted to be within the new range.</source>
          <target state="translated">设置此属性时，如有必要，将调整&lt;a href=&quot;qabstractslider#minimum-prop&quot;&gt;最小值，&lt;/a&gt;以确保范围保持有效。同样，将滑块的当前值调整到新范围内。</target>
        </trans-unit>
        <trans-unit id="890b98dfbcb1358977a7219adcd63ac2cd2c0980" translate="yes" xml:space="preserve">
          <source>When setting this property, the &lt;a href=&quot;qdatetimeedit#minimumTime-prop&quot;&gt;minimumTime&lt;/a&gt; is adjusted if necessary to ensure that the range remains valid. If the time is not a valid &lt;a href=&quot;qtime&quot;&gt;QTime&lt;/a&gt; object, this function does nothing.</source>
          <target state="translated">设置此属性时，如有必要，将调整&lt;a href=&quot;qdatetimeedit#minimumTime-prop&quot;&gt;minimumTime&lt;/a&gt;以确保范围保持有效。如果时间不是有效的&lt;a href=&quot;qtime&quot;&gt;QTime&lt;/a&gt;对象，则此函数不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="fa2c9bb906ff3305eef76e88d6b8655a32b982f4" translate="yes" xml:space="preserve">
          <source>When setting this property, the &lt;a href=&quot;qml-qtcharts-pieseries#holeSize-prop&quot;&gt;holeSize&lt;/a&gt; property is adjusted if necessary, to ensure that the hole size is not greater than the pie size.</source>
          <target state="translated">设置此属性时，如有必要，将调整&lt;a href=&quot;qml-qtcharts-pieseries#holeSize-prop&quot;&gt;holeSize&lt;/a&gt;属性，以确保孔大小不大于饼图大小。</target>
        </trans-unit>
        <trans-unit id="f435a68f9316a9aad8d0bd9214e3829a97c2384f" translate="yes" xml:space="preserve">
          <source>When setting this property, the &lt;a href=&quot;qml-qtcharts-pieseries#size-prop&quot;&gt;size&lt;/a&gt; property is adjusted if necessary, to ensure that the hole size is not greater than the pie size.</source>
          <target state="translated">设置此属性时，如有必要，将调整&lt;a href=&quot;qml-qtcharts-pieseries#size-prop&quot;&gt;size&lt;/a&gt;属性，以确保孔大小不大于饼图大小。</target>
        </trans-unit>
        <trans-unit id="2614229e0748ff7798a30ec6c9a32c8bd564129c" translate="yes" xml:space="preserve">
          <source>When setting this property, the &lt;a href=&quot;qpieseries#holeSize-prop&quot;&gt;holeSize&lt;/a&gt; property is adjusted if necessary, to ensure that the hole size is not greater than the pie size.</source>
          <target state="translated">设置此属性时，如有必要，将调整&lt;a href=&quot;qpieseries#holeSize-prop&quot;&gt;holeSize&lt;/a&gt;属性，以确保孔大小不大于饼图大小。</target>
        </trans-unit>
        <trans-unit id="9676bb4e1b94754c72406b0dd8f30c9729452b6c" translate="yes" xml:space="preserve">
          <source>When setting this property, the &lt;a href=&quot;qpieseries#size-prop&quot;&gt;size&lt;/a&gt; property is adjusted if necessary, to ensure that the hole size is not greater than the pie size.</source>
          <target state="translated">设置此属性时，如有必要，将调整&lt;a href=&quot;qpieseries#size-prop&quot;&gt;size&lt;/a&gt;属性，以确保孔大小不大于饼图大小。</target>
        </trans-unit>
        <trans-unit id="5c4c814181687e53992d25bc4a345c8885416475" translate="yes" xml:space="preserve">
          <source>When setting this property, the &lt;a href=&quot;qprogressbar#maximum-prop&quot;&gt;maximum&lt;/a&gt; is adjusted if necessary to ensure that the range remains valid. If the current value falls outside the new range, the progress bar is reset with &lt;a href=&quot;qprogressbar#reset&quot;&gt;reset&lt;/a&gt;().</source>
          <target state="translated">设置此属性时，如有必要，将调整&lt;a href=&quot;qprogressbar#maximum-prop&quot;&gt;最大值&lt;/a&gt;以确保范围保持有效。如果当前值不在新范围内，则使用&lt;a href=&quot;qprogressbar#reset&quot;&gt;reset&lt;/a&gt;（）重置进度条。</target>
        </trans-unit>
        <trans-unit id="d10bb2cee1aba8ceaf054055bf90ceea6821e2bc" translate="yes" xml:space="preserve">
          <source>When setting this property, the &lt;a href=&quot;qprogressbar#minimum-prop&quot;&gt;minimum&lt;/a&gt; is adjusted if necessary to ensure that the range remains valid. If the current value falls outside the new range, the progress bar is reset with &lt;a href=&quot;qprogressbar#reset&quot;&gt;reset&lt;/a&gt;().</source>
          <target state="translated">设置此属性时，如有必要，将调整&lt;a href=&quot;qprogressbar#minimum-prop&quot;&gt;最小值，&lt;/a&gt;以确保范围保持有效。如果当前值不在新范围内，则使用&lt;a href=&quot;qprogressbar#reset&quot;&gt;reset&lt;/a&gt;（）重置进度条。</target>
        </trans-unit>
        <trans-unit id="32aea66ca6d6da71cb41f4c7cc9dc10b08e8577f" translate="yes" xml:space="preserve">
          <source>When setting this property, the maximum value is adjusted if necessary, to ensure that the range remains valid.</source>
          <target state="translated">在设置该属性时,必要时调整最大值,以保证范围内保持有效。</target>
        </trans-unit>
        <trans-unit id="b951c983b0aee73e158712980739ff70f149887e" translate="yes" xml:space="preserve">
          <source>When setting this property, the maximum value is adjusted if necessary, to ensure that the range remains valid. The value has to be greater than 0.</source>
          <target state="translated">在设置该属性时,必要时调整最大值,以确保该范围保持有效。该值必须大于0。</target>
        </trans-unit>
        <trans-unit id="7a55bcbc9be43eedc7805bdbb3ee9e54f14990ff" translate="yes" xml:space="preserve">
          <source>When setting this property, the minimum value is adjusted if necessary, to ensure that the range remains valid.</source>
          <target state="translated">设置该属性时,必要时调整最小值,以保证范围有效。</target>
        </trans-unit>
        <trans-unit id="c7876cf5d914de6fdd878ac65bed31fe69eb59c2" translate="yes" xml:space="preserve">
          <source>When setting this property, the minimum value is adjusted if necessary, to ensure that the range remains valid. The value has to be greater than 0.</source>
          <target state="translated">设置该属性时,必要时调整最小值,以确保范围保持有效。该值必须大于0。</target>
        </trans-unit>
        <trans-unit id="5de4dc53f812589029ed9067e97355562cb0e1d3" translate="yes" xml:space="preserve">
          <source>When setting up the rendering pipeline, call &lt;a href=&quot;qvulkanwindow#sampleCountFlagBits&quot;&gt;sampleCountFlagBits&lt;/a&gt;() to query the active sample count as a &lt;code&gt;VkSampleCountFlagBits&lt;/code&gt; value.</source>
          <target state="translated">设置渲染管道时，调用&lt;a href=&quot;qvulkanwindow#sampleCountFlagBits&quot;&gt;sampleCountFlagBits&lt;/a&gt;（）以 &lt;code&gt;VkSampleCountFlagBits&lt;/code&gt; 值查询活动样本计数。</target>
        </trans-unit>
        <trans-unit id="dfcd5a5c296c55f96b9ee5da99d93a616d2b11fc" translate="yes" xml:space="preserve">
          <source>When shaders were added to this program via &lt;a href=&quot;qopenglshaderprogram#addCacheableShaderFromSourceCode&quot;&gt;addCacheableShaderFromSourceCode&lt;/a&gt;() or &lt;a href=&quot;qopenglshaderprogram#addCacheableShaderFromSourceFile&quot;&gt;addCacheableShaderFromSourceFile&lt;/a&gt;(), program binaries are supported, and a cached binary is available on disk, actual compilation and linking are skipped. Instead, link() will initialize the program with the binary blob via glProgramBinary(). If there is no cached version of the program or it was generated with a different driver version, the shaders will be compiled from source and the program will get linked normally. This allows seamless upgrading of the graphics drivers, without having to worry about potentially incompatible binary formats.</source>
          <target state="translated">当通过&lt;a href=&quot;qopenglshaderprogram#addCacheableShaderFromSourceCode&quot;&gt;addCacheableShaderFromSourceCode&lt;/a&gt;（）或&lt;a href=&quot;qopenglshaderprogram#addCacheableShaderFromSourceFile&quot;&gt;addCacheableShaderFromSourceFile&lt;/a&gt;（）将着色器添加到此程序时，支持程序二进制文件，并且磁盘上有可用的缓存二进制文件，实际的编译和链接将被跳过。相反，link（）将通过glProgramBinary（）使用二进制Blob初始化程序。如果没有该程序的缓存版本，或者它是由其他驱动程序版本生成的，则将从源代码编译着色器，并且程序将正常链接。这样就可以无缝升级图形驱动程序，而不必担心潜在的不兼容二进制格式。</target>
        </trans-unit>
        <trans-unit id="87d3d39130885f5e5c6a9174de6513c3d33b6b27" translate="yes" xml:space="preserve">
          <source>When side-effects are unavoidable, ensure that the prior state is restored at the end of the test function, even if the test fails. This commonly requires use of an RAII (resource acquisition is initialization) class that restores state when the function returns, or a &lt;code&gt;cleanup()&lt;/code&gt; method. Do not simply put the restoration code at the end of the test. If part of the test fails, such code will be skipped and the prior state will not be restored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64b2c21463a05b372aacfedaa2026900f87448ca" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; or &lt;a href=&quot;qabstractproxymodel&quot;&gt;QAbstractProxyModel&lt;/a&gt;, ensure that you emit &lt;a href=&quot;qabstractitemmodel#layoutAboutToBeChanged&quot;&gt;layoutAboutToBeChanged&lt;/a&gt;() before changing the order of items or altering the structure of the data you expose to views, and emit layoutChanged() after changing the layout.</source>
          <target state="translated">当对&lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt;或&lt;a href=&quot;qabstractproxymodel&quot;&gt;QAbstractProxyModel进行&lt;/a&gt;子类化时，请确保在更改项目顺序或更改要公开给视图的数据的结构之前发出&lt;a href=&quot;qabstractitemmodel#layoutAboutToBeChanged&quot;&gt;layoutAboutToBeChanged&lt;/a&gt;（），并在更改布局后发出layoutChanged（）。</target>
        </trans-unit>
        <trans-unit id="29ad4f995056d1ccd3dcee88f2d1086d0349dbfd" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt;, at the very least you must implement &lt;a href=&quot;qabstractitemmodel#index&quot;&gt;index&lt;/a&gt;(), &lt;a href=&quot;qabstractitemmodel#parent&quot;&gt;parent&lt;/a&gt;(), &lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount&lt;/a&gt;(), &lt;a href=&quot;qabstractitemmodel#columnCount&quot;&gt;columnCount&lt;/a&gt;(), and &lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt;(). These functions are used in all read-only models, and form the basis of editable models.</source>
          <target state="translated">子类化&lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel时&lt;/a&gt;，至少必须实现&lt;a href=&quot;qabstractitemmodel#index&quot;&gt;index&lt;/a&gt;（），&lt;a href=&quot;qabstractitemmodel#parent&quot;&gt;parent&lt;/a&gt;（），&lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount&lt;/a&gt;（），&lt;a href=&quot;qabstractitemmodel#columnCount&quot;&gt;columnCount&lt;/a&gt;（）和&lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt;（）。这些功能在所有只读模型中使用，并构成可编辑模型的基础。</target>
        </trans-unit>
        <trans-unit id="a191eed727edc2ae03b2ab93852a02163a6c05e0" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qabstractlistmodel&quot;&gt;QAbstractListModel&lt;/a&gt;, you must provide implementations of the &lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount&lt;/a&gt;() and &lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt;() functions. Well behaved models also provide a &lt;a href=&quot;qabstractitemmodel#headerData&quot;&gt;headerData&lt;/a&gt;() implementation.</source>
          <target state="translated">在子类化&lt;a href=&quot;qabstractlistmodel&quot;&gt;QAbstractListModel时&lt;/a&gt;，必须提供&lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount&lt;/a&gt;（）和&lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt;（）函数的实现。行为良好的模型还提供了&lt;a href=&quot;qabstractitemmodel#headerData&quot;&gt;headerData&lt;/a&gt;（）实现。</target>
        </trans-unit>
        <trans-unit id="34ee94bbac1ecea4e8ddb454d400be8aae1e7968" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qabstracttablemodel&quot;&gt;QAbstractTableModel&lt;/a&gt;, you must implement &lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount&lt;/a&gt;(), &lt;a href=&quot;qabstractitemmodel#columnCount&quot;&gt;columnCount&lt;/a&gt;(), and &lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt;(). Default implementations of the &lt;a href=&quot;qabstracttablemodel#index&quot;&gt;index&lt;/a&gt;() and &lt;a href=&quot;qabstractitemmodel#parent&quot;&gt;parent&lt;/a&gt;() functions are provided by &lt;a href=&quot;qabstracttablemodel&quot;&gt;QAbstractTableModel&lt;/a&gt;. Well behaved models will also implement &lt;a href=&quot;qabstractitemmodel#headerData&quot;&gt;headerData&lt;/a&gt;().</source>
          <target state="translated">在子类化&lt;a href=&quot;qabstracttablemodel&quot;&gt;QAbstractTableModel时&lt;/a&gt;，必须实现&lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount&lt;/a&gt;（），&lt;a href=&quot;qabstractitemmodel#columnCount&quot;&gt;columnCount&lt;/a&gt;（）和&lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt;（）。&lt;a href=&quot;qabstracttablemodel&quot;&gt;QAbstractTableModel&lt;/a&gt;提供了&lt;a href=&quot;qabstracttablemodel#index&quot;&gt;index&lt;/a&gt;（）和&lt;a href=&quot;qabstractitemmodel#parent&quot;&gt;parent&lt;/a&gt;（）函数的默认实现。行为良好的模型还将实现&lt;a href=&quot;qabstractitemmodel#headerData&quot;&gt;headerData&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="bc5ed4ae258b22a232b577325d7a45d5a74a6ae6" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qaccessibleactioninterface&quot;&gt;QAccessibleActionInterface&lt;/a&gt; you need to provide a list of &lt;a href=&quot;qaccessibleactioninterface#actionNames&quot;&gt;actionNames&lt;/a&gt; which is the primary means to discover the available actions. Action names are never localized. In order to present actions to the user there are two functions that need to return localized versions of the name and give a description of the action. For the predefined action names use &lt;a href=&quot;qaccessibleactioninterface#localizedActionName&quot;&gt;QAccessibleActionInterface::localizedActionName&lt;/a&gt;() and &lt;a href=&quot;qaccessibleactioninterface#localizedActionDescription&quot;&gt;QAccessibleActionInterface::localizedActionDescription&lt;/a&gt;() to return their localized counterparts.</source>
          <target state="translated">子类化&lt;a href=&quot;qaccessibleactioninterface&quot;&gt;QAccessibleActionInterface时，&lt;/a&gt;您需要提供&lt;a href=&quot;qaccessibleactioninterface#actionNames&quot;&gt;actionNames&lt;/a&gt;列表，这是发现可用操作的主要方法。操作名称永远不会本地化。为了向用户呈现操作，有两个函数需要返回名称的本地化版本并给出操作说明。对于预定义的动作名称，请使用&lt;a href=&quot;qaccessibleactioninterface#localizedActionName&quot;&gt;QAccessibleActionInterface :: localizedActionName&lt;/a&gt;（）和&lt;a href=&quot;qaccessibleactioninterface#localizedActionDescription&quot;&gt;QAccessibleActionInterface :: localizedActionDescription&lt;/a&gt;（）返回其本地化的对应名称。</target>
        </trans-unit>
        <trans-unit id="a25edef8cc00a94f017f1d9cbc6945550b8bf450" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt;, you must call QIODevice::seek() at the start of your function to ensure integrity with &lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt;'s built-in buffer.</source>
          <target state="translated">子类化&lt;a href=&quot;qiodevice&quot;&gt;QIODevice时&lt;/a&gt;，必须在函数开始时调用QIODevice :: seek（），以确保&lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt;的内置缓冲区的完整性。</target>
        </trans-unit>
        <trans-unit id="d195ef9dc4d6a9738e6783d4bc0696c9278d4ef4" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qitemdelegate&quot;&gt;QItemDelegate&lt;/a&gt; to create a delegate that displays items using a custom renderer, it is important to ensure that the delegate can render items suitably for all the required states; e.g. selected, disabled, checked. The documentation for the &lt;a href=&quot;qitemdelegate#paint&quot;&gt;paint&lt;/a&gt;() function contains some hints to show how this can be achieved.</source>
          <target state="translated">当将&lt;a href=&quot;qitemdelegate&quot;&gt;QItemDelegate&lt;/a&gt;子类化以创建使用自定义渲染器显示项目的委托时，重要的是要确保该委托可以针对所有所需状态适当地渲染项目。例如，选中，禁用，选中。&lt;a href=&quot;qitemdelegate#paint&quot;&gt;paint&lt;/a&gt;（）函数的文档包含一些提示，以显示如何实现此目的。</target>
        </trans-unit>
        <trans-unit id="bdfab8a00f506ea4624c5ba05bcfdffa0be88abb" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qlistwidgetitem&quot;&gt;QListWidgetItem&lt;/a&gt; to provide custom items, it is possible to define new types for them enabling them to be distinguished from standard items. For subclasses that require this feature, ensure that you call the base class constructor with a new type value equal to or greater than &lt;a href=&quot;qlistwidgetitem#ItemType-enum&quot;&gt;UserType&lt;/a&gt;, within</source>
          <target state="translated">当将&lt;a href=&quot;qlistwidgetitem&quot;&gt;QListWidgetItem&lt;/a&gt;子类化以提供自定义项目时，可以为它们定义新类型，从而使其能够与标准项目区分开。对于需要此功能的子类，请确保调用基类构造一个新的类型值等于或大于&lt;a href=&quot;qlistwidgetitem#ItemType-enum&quot;&gt;用户类型&lt;/a&gt;，内</target>
        </trans-unit>
        <trans-unit id="25983c5d275d61a5768d14102127d7627a6f2db7" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qstandarditem&quot;&gt;QStandardItem&lt;/a&gt; to provide custom items, it is possible to define new types for them so that they can be distinguished from the base class. The &lt;a href=&quot;qstandarditem#type&quot;&gt;type&lt;/a&gt;() function should be reimplemented to return a new type value equal to or greater than &lt;a href=&quot;qstandarditem#ItemType-enum&quot;&gt;UserType&lt;/a&gt;.</source>
          <target state="translated">当将&lt;a href=&quot;qstandarditem&quot;&gt;QStandardItem&lt;/a&gt;子类化以提供自定义项时，可以为其定义新类型，以便将它们与基类区分开。的&lt;a href=&quot;qstandarditem#type&quot;&gt;类型&lt;/a&gt;（）函数应当重新实现以返回一个新的类型值等于或大于&lt;a href=&quot;qstandarditem#ItemType-enum&quot;&gt;用户类型&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e6fbf6fe9133647e06d0faf1437cba6ca2cedd98" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qstandarditem&quot;&gt;QStandardItem&lt;/a&gt;, you can reimplement this function to provide &lt;a href=&quot;qstandarditemmodel&quot;&gt;QStandardItemModel&lt;/a&gt; with a factory that it can use to create new items on demand.</source>
          <target state="translated">子类化&lt;a href=&quot;qstandarditem&quot;&gt;QStandardItem时&lt;/a&gt;，可以重新实现此功能，以为&lt;a href=&quot;qstandarditemmodel&quot;&gt;QStandardItemModel&lt;/a&gt;提供一个工厂，该工厂可用于按需创建新项目。</target>
        </trans-unit>
        <trans-unit id="f2286413d50d08d040929b6ec39c68a3dddaf3c0" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qtablewidgetitem&quot;&gt;QTableWidgetItem&lt;/a&gt; to provide custom items, it is possible to define new types for them so that they can be distinguished from standard items. The constructors for subclasses that require this feature need to call the base class constructor with a new type value equal to or greater than &lt;a href=&quot;qtablewidgetitem#ItemType-enum&quot;&gt;UserType&lt;/a&gt;.</source>
          <target state="translated">将&lt;a href=&quot;qtablewidgetitem&quot;&gt;QTableWidgetItem&lt;/a&gt;子类化以提供自定义项时，可以为其定义新类型，以便将它们与标准项区分开。需要此功能的子类的构造函数需要使用等于或大于&lt;a href=&quot;qtablewidgetitem#ItemType-enum&quot;&gt;UserType&lt;/a&gt;的新类型值来调用基类构造函数。</target>
        </trans-unit>
        <trans-unit id="1002dc2f9f72071b49f3bc6989364ec60eb22d54" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qtreewidgetitem&quot;&gt;QTreeWidgetItem&lt;/a&gt; to provide custom items, it is possible to define new types for them so that they can be distinguished from standard items. The constructors for subclasses that require this feature need to call the base class constructor with a new type value equal to or greater than &lt;a href=&quot;qtreewidgetitem#ItemType-enum&quot;&gt;UserType&lt;/a&gt;.</source>
          <target state="translated">当将&lt;a href=&quot;qtreewidgetitem&quot;&gt;QTreeWidgetItem&lt;/a&gt;子类化以提供自定义项目时，可以为其定义新类型，以便将它们与标准项目区分开。需要此功能的子类的构造函数需要使用等于或大于&lt;a href=&quot;qtreewidgetitem#ItemType-enum&quot;&gt;UserType&lt;/a&gt;的新类型值来调用基类构造函数。</target>
        </trans-unit>
        <trans-unit id="59520faecedf14305609ce71b43c92f419907198" translate="yes" xml:space="preserve">
          <source>When subclassing QAbstractItemModel, at the very least you must implement &lt;a href=&quot;qabstractitemmodel#index&quot;&gt;index&lt;/a&gt;(), &lt;a href=&quot;qabstractitemmodel#parent&quot;&gt;parent&lt;/a&gt;(), &lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount&lt;/a&gt;(), &lt;a href=&quot;qabstractitemmodel#columnCount&quot;&gt;columnCount&lt;/a&gt;(), and &lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt;(). These functions are used in all read-only models, and form the basis of editable models.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3699b269f018546bac2b237f4b1ba2d9ba58cd5a" translate="yes" xml:space="preserve">
          <source>When subclassing QAbstractListModel, you must provide implementations of the &lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount&lt;/a&gt;() and &lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt;() functions. Well behaved models also provide a &lt;a href=&quot;qabstractitemmodel#headerData&quot;&gt;headerData&lt;/a&gt;() implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1062aef636e41c878017026955b733a82f0e58d" translate="yes" xml:space="preserve">
          <source>When subclassing QAbstractTableModel, you must implement &lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount&lt;/a&gt;(), &lt;a href=&quot;qabstractitemmodel#columnCount&quot;&gt;columnCount&lt;/a&gt;(), and &lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt;(). Default implementations of the &lt;a href=&quot;qabstracttablemodel#index&quot;&gt;index&lt;/a&gt;() and &lt;a href=&quot;qabstractitemmodel#parent&quot;&gt;parent&lt;/a&gt;() functions are provided by QAbstractTableModel. Well behaved models will also implement &lt;a href=&quot;qabstractitemmodel#headerData&quot;&gt;headerData&lt;/a&gt;().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26b79d67e5a46121dc5b166539f6602a7e665200" translate="yes" xml:space="preserve">
          <source>When subclassing QAccessibleActionInterface you need to provide a list of &lt;a href=&quot;qaccessibleactioninterface#actionNames&quot;&gt;actionNames&lt;/a&gt; which is the primary means to discover the available actions. Action names are never localized. In order to present actions to the user there are two functions that need to return localized versions of the name and give a description of the action. For the predefined action names use &lt;a href=&quot;qaccessibleactioninterface#localizedActionName&quot;&gt;QAccessibleActionInterface::localizedActionName&lt;/a&gt;() and &lt;a href=&quot;qaccessibleactioninterface#localizedActionDescription&quot;&gt;QAccessibleActionInterface::localizedActionDescription&lt;/a&gt;() to return their localized counterparts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fd6e4c37e600fd73592fb3b27ecd0ad7ca47a17" translate="yes" xml:space="preserve">
          <source>When subclassing QItemDelegate to create a delegate that displays items using a custom renderer, it is important to ensure that the delegate can render items suitably for all the required states; e.g. selected, disabled, checked. The documentation for the &lt;a href=&quot;qitemdelegate#paint&quot;&gt;paint&lt;/a&gt;() function contains some hints to show how this can be achieved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e0f5aa88b44938c261cc9eef6f6e4a41afa7675" translate="yes" xml:space="preserve">
          <source>When subclassing QListWidgetItem to provide custom items, it is possible to define new types for them enabling them to be distinguished from standard items. For subclasses that require this feature, ensure that you call the base class constructor with a new type value equal to or greater than &lt;a href=&quot;qlistwidgetitem#ItemType-enum&quot;&gt;UserType&lt;/a&gt;, within</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72aca5e914ed9fefcaccb35499bea805b895d281" translate="yes" xml:space="preserve">
          <source>When subclassing QStandardItem to provide custom items, it is possible to define new types for them so that they can be distinguished from the base class. The &lt;a href=&quot;qstandarditem#type&quot;&gt;type&lt;/a&gt;() function should be reimplemented to return a new type value equal to or greater than &lt;a href=&quot;qstandarditem#ItemType-enum&quot;&gt;UserType&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42b0b4032d93d4857496512b038b0674cfd26f89" translate="yes" xml:space="preserve">
          <source>When subclassing QTableWidgetItem to provide custom items, it is possible to define new types for them so that they can be distinguished from standard items. The constructors for subclasses that require this feature need to call the base class constructor with a new type value equal to or greater than &lt;a href=&quot;qtablewidgetitem#ItemType-enum&quot;&gt;UserType&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a47ebf3a47f4b0b127eba34804babe9e0cf37bc" translate="yes" xml:space="preserve">
          <source>When subclassing QTreeWidgetItem to provide custom items, it is possible to define new types for them so that they can be distinguished from standard items. The constructors for subclasses that require this feature need to call the base class constructor with a new type value equal to or greater than &lt;a href=&quot;qtreewidgetitem#ItemType-enum&quot;&gt;UserType&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="706f7b1df0260af3c55347db3db3d7c9292cb895" translate="yes" xml:space="preserve">
          <source>When successful, the pointer to this &lt;a href=&quot;qvulkaninstance&quot;&gt;QVulkanInstance&lt;/a&gt; is retrievable via the static function current().</source>
          <target state="translated">成功后，可通过静态函数current（）检索此&lt;a href=&quot;qvulkaninstance&quot;&gt;QVulkanInstance&lt;/a&gt;的指针。</target>
        </trans-unit>
        <trans-unit id="52f02029e2dd95fea6c58bc7c6dd438e3036694c" translate="yes" xml:space="preserve">
          <source>When successful, the returned pointer is either a direct pointer to an interface (and can be cast, for example, to &lt;code&gt;ID3D12Device *&lt;/code&gt;) or a pointer to an opaque handle that needs to be dereferenced first (for example, &lt;code&gt;VkDevice dev = *static_cast&amp;lt;VkDevice *&amp;gt;(result)&lt;/code&gt;). The latter is necessary since such handles may have sizes different from a pointer.</source>
          <target state="translated">成功后，返回的指针可以是指向接口的直接指针（例如，可以 &lt;code&gt;ID3D12Device *&lt;/code&gt; 为ID3D12Device *），也可以指向需要首先取消引用的不透明句柄的指针（例如， &lt;code&gt;VkDevice dev = *static_cast&amp;lt;VkDevice *&amp;gt;(result)&lt;/code&gt; ）。后者是必需的，因为此类句柄的大小可能不同于指针。</target>
        </trans-unit>
        <trans-unit id="b61533f5bfe4f41a281b6739619bbe40223b42c1" translate="yes" xml:space="preserve">
          <source>When supported, the spot metering point is the (normalized) position of the point of the image where exposure metering will be performed. This is typically used to indicate an &quot;interesting&quot; area of the image that should be exposed properly.</source>
          <target state="translated">当支持时,点测光点是将执行曝光测光的图像点的(标准化)位置。这通常用于指示图像中应该正确曝光的 &quot;有趣 &quot;区域。</target>
        </trans-unit>
        <trans-unit id="5f88abce90e32dce271b35e9107fb601ec017c62" translate="yes" xml:space="preserve">
          <source>When switching application styles, the color palette is set back to the initial colors or the system defaults. This is necessary since certain styles have to adapt the color palette to be fully style-guide compliant.</source>
          <target state="translated">当切换应用程序样式时,调色板会被设置回初始颜色或系统默认值。这是很有必要的,因为某些样式必须调整调色板才能完全符合样式指南。</target>
        </trans-unit>
        <trans-unit id="67873ce37a5513b0e5ae88b75e6f033ba8bb99f4" translate="yes" xml:space="preserve">
          <source>When tabsClosable is set to true a close button will appear on the tab on either the left or right hand side depending upon the style. When the button is clicked the tab the signal &lt;a href=&quot;qtabbar#tabCloseRequested&quot;&gt;tabCloseRequested&lt;/a&gt; will be emitted.</source>
          <target state="translated">当tabsClosable设置为true时，根据样式的不同，关闭按钮将出现在左侧或右侧的标签上。单击按钮时，将发出信号&lt;a href=&quot;qtabbar#tabCloseRequested&quot;&gt;tabClos​​eRequested&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="edd34e00a0649a39928db867a61af0bdd3698a54" translate="yes" xml:space="preserve">
          <source>When talking about version support on macOS, it's important to distinguish between the &lt;a href=&quot;#build-environment&quot;&gt;build environment&lt;/a&gt;; the platform you're building on or with, and the &lt;a href=&quot;#target-platforms&quot;&gt;target platforms&lt;/a&gt;; the platforms you are building for. The following macOS versions are supported.</source>
          <target state="translated">当谈到macOS上的版本支持时，重要的是要区分&lt;a href=&quot;#build-environment&quot;&gt;构建环境&lt;/a&gt;；您在其上或与其一起构建的平台以及&lt;a href=&quot;#target-platforms&quot;&gt;目标平台&lt;/a&gt;；您要构建的平台。支持以下macOS版本。</target>
        </trans-unit>
        <trans-unit id="46e5a0bd94336c26034fab948fd2202518bbe3a7" translate="yes" xml:space="preserve">
          <source>When talking about version support on macOS, it's important to distinguish between the &lt;a href=&quot;macos#build-environment&quot;&gt;build environment&lt;/a&gt;; the platform you're building on or with, and the &lt;a href=&quot;macos#target-platforms&quot;&gt;target platforms&lt;/a&gt;; the platforms you are building for. The following macOS versions are supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12b09dba91f90a77f1c0f316bc1593767614f52d" translate="yes" xml:space="preserve">
          <source>When targeting the default render target, the &lt;code&gt;rasterizationSamples&lt;/code&gt; field of &lt;code&gt;VkPipelineMultisampleStateCreateInfo&lt;/code&gt; must be set to this value.</source>
          <target state="translated">以默认渲染目标为目标时，必须将 &lt;code&gt;VkPipelineMultisampleStateCreateInfo&lt;/code&gt; 的 &lt;code&gt;rasterizationSamples&lt;/code&gt; 字段设置为此值。</target>
        </trans-unit>
        <trans-unit id="01a0c4cf5ca0b1b36842c832e9f49ed747142008" translate="yes" xml:space="preserve">
          <source>When testing classes that change their state based on timer events, the timer-based behavior needs to be taken into account when performing verification steps. Due to the variety of timing-dependent behavior, there is no single generic solution to this testing problem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="977796166650ef7b381034a2e5ab66d22d9fde20" translate="yes" xml:space="preserve">
          <source>When text is selected this signal will be emitted with</source>
          <target state="translated">当文本被选中时,该信号将以如下方式发出</target>
        </trans-unit>
        <trans-unit id="55f3e3f1e06a97818ce0ffb33865599309fb29ae" translate="yes" xml:space="preserve">
          <source>When the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="277e96c69a29982435c9191c9b7dc60d6543c8df" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qcombobox&quot;&gt;QComboBox&lt;/a&gt; is editable, use &lt;a href=&quot;qlineedit#placeholderText-prop&quot;&gt;QLineEdit::setPlaceholderText&lt;/a&gt;() instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96148eaf4c167de1a5cc9cb151bbca87c607e4e7" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qlogvalue3daxisformatter#base-prop&quot;&gt;base&lt;/a&gt; property value is non-zero, the whole axis range is often not equally divided into segments. The first and last segments are often smaller than the other segments. In extreme cases, this can lead to overlapping labels on the first and last two grid lines. By setting this property to &lt;code&gt;false&lt;/code&gt;, you can suppress showing the minimum and maximum labels for the axis in cases where the segments do not exactly fit the axis. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">当&lt;a href=&quot;qlogvalue3daxisformatter#base-prop&quot;&gt;基本&lt;/a&gt;属性值不为零时，整个轴范围通常不均等地划分为多个段。第一部分和最后一部分通常小于其他部分。在极端情况下，这可能导致前两条网格线上的标签重叠。通过将此属性设置为 &lt;code&gt;false&lt;/code&gt; ，可以在段不完全适合轴的情况下禁止显示该轴的最小和最大标签。默认为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fcebf5705064ce0455ad2b9bec751e51c083ccf2" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qml-qt3d-render-pointsize#sizeMode-prop&quot;&gt;sizeMode&lt;/a&gt; property is set to SizeMode::Fixed, the value is set using glPointSize(), if available. When using SizeMode::Programmable, gl_PointSize must be set within shader programs, the value provided to this &lt;a href=&quot;qml-qt3d-render-renderstate&quot;&gt;RenderState&lt;/a&gt; is ignored in that case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01c131bddcc8fa92f9f3b0a589fa47980eb2d439" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qml-qt3d-render-pointsize#sizeMode-prop&quot;&gt;sizeMode&lt;/a&gt; property is set to SizeMode::Fixed, the value is set using glPointSize(), if available. When using SizeMode::Programmable, gl_PointSize must be set within shader programs, the value provided to this &lt;a href=&quot;qml-renderstate&quot;&gt;RenderState&lt;/a&gt; is ignored in that case.</source>
          <target state="translated">当&lt;a href=&quot;qml-qt3d-render-pointsize#sizeMode-prop&quot;&gt;sizeMode&lt;/a&gt;属性设置为SizeMode :: Fixed时，使用glPointSize（）设置该值（如果可用）。使用SizeMode :: Programmable时，必须在着色器程序中设置gl_PointSize，在这种情况下，将忽略提供给此&lt;a href=&quot;qml-renderstate&quot;&gt;RenderState&lt;/a&gt;的值。</target>
        </trans-unit>
        <trans-unit id="31b0eaa228f2b88891ce3db774ff73a70a98110c" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qml-qtdatavisualization-logvalueaxis3dformatter#base-prop&quot;&gt;base&lt;/a&gt; property value is non-zero, the whole axis range is often not equally divided into segments. The first and last segments are often smaller than the other segments. In extreme cases, this can lead to overlapping labels on the first and last two grid lines. By setting this property to &lt;code&gt;false&lt;/code&gt;, you can suppress showing the minimum and maximum labels for the axis in cases where the segments do not exactly fit the axis. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">当&lt;a href=&quot;qml-qtdatavisualization-logvalueaxis3dformatter#base-prop&quot;&gt;基本&lt;/a&gt;属性值不为零时，整个轴范围通常不均等地划分为多个段。第一部分和最后一部分通常小于其他部分。在极端情况下，这可能导致前两条网格线上的标签重叠。通过将此属性设置为 &lt;code&gt;false&lt;/code&gt; ，可以在段不完全适合轴的情况下禁止显示该轴的最小和最大标签。默认为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="987fec2f0c2c258849a742c9e14f0174fef55ec2" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qml-qtpositioning-positionsource&quot;&gt;PositionSource&lt;/a&gt; is active, position updates can be retrieved either by simply using the &lt;a href=&quot;qml-qtpositioning-positionsource#position-prop&quot;&gt;position&lt;/a&gt; property in a binding (as the value of another item's property), or by providing an implementation of the &lt;code&gt;onPositionChanged&lt;/code&gt; signal-handler.</source>
          <target state="translated">当&lt;a href=&quot;qml-qtpositioning-positionsource&quot;&gt;PositionSource&lt;/a&gt;处于活动状态时，可以通过简单地在绑定中使用&lt;a href=&quot;qml-qtpositioning-positionsource#position-prop&quot;&gt;position&lt;/a&gt;属性（作为另一个项目的属性的值）或提供 &lt;code&gt;onPositionChanged&lt;/code&gt; 信号处理程序的实现来检索位置更新。</target>
        </trans-unit>
        <trans-unit id="d6b06a8b392f311abc92743e16b8eaf852385858" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qml-qtquick-controls-stackview&quot;&gt;StackView&lt;/a&gt; needs a new transition, it first calls &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#getTransition-method&quot;&gt;StackViewDelegate.getTransition()&lt;/a&gt;. The base implementation of this function just looks for a property named &lt;code&gt;properties.name&lt;/code&gt; inside itself (root), which is how it finds &lt;code&gt;property Component pushTransition&lt;/code&gt; in the examples above.</source>
          <target state="translated">当&lt;a href=&quot;qml-qtquick-controls-stackview&quot;&gt;StackView&lt;/a&gt;需要新的过渡时，它首先调用&lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#getTransition-method&quot;&gt;StackViewDelegate.getTransition（）&lt;/a&gt;。该函数的基本实现只是在自身（根）中查找一个名为 &lt;code&gt;properties.name&lt;/code&gt; 的属性，这就是它在上面的示例中查找 &lt;code&gt;property Component pushTransition&lt;/code&gt; 的方式。</target>
        </trans-unit>
        <trans-unit id="13b2463be39cc72e16c7d4ca58b0c4d0edaade26" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qml-qtquick-flickable#boundsMovement-prop&quot;&gt;boundsMovement&lt;/a&gt; is &lt;code&gt;Flickable.FollowBoundsBehavior&lt;/code&gt;, a value other than &lt;code&gt;Flickable.StopAtBounds&lt;/code&gt; will give a feeling that the edges of the view are soft, rather than a hard physical boundary.</source>
          <target state="translated">当&lt;a href=&quot;qml-qtquick-flickable#boundsMovement-prop&quot;&gt;boundsMovement&lt;/a&gt;为 &lt;code&gt;Flickable.FollowBoundsBehavior&lt;/code&gt; 时，除 &lt;code&gt;Flickable.StopAtBounds&lt;/code&gt; 以外的其他值将给人一种感觉，即视图的边缘是柔软的，而不是硬的物理边界。</target>
        </trans-unit>
        <trans-unit id="bdd086e0b6a8d49e2b2713bf9ea24b942d740d18" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qml-qtquick-mousearea&quot;&gt;MouseArea&lt;/a&gt; is clicked, &lt;code&gt;fruitModel&lt;/code&gt; will have two roles,</source>
          <target state="translated">当&lt;a href=&quot;qml-qtquick-mousearea&quot;&gt;鼠标区域&lt;/a&gt;被点击时， &lt;code&gt;fruitModel&lt;/code&gt; 将有两个角色，</target>
        </trans-unit>
        <trans-unit id="531648fe487a96145ce0801a6bc88b47ddc3d5fa" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qml-qtquick-text&quot;&gt;Text&lt;/a&gt; object refers to its &lt;a href=&quot;qml-qtquick-item#parent-prop&quot;&gt;parent&lt;/a&gt; value in the above code, it is referring to its</source>
          <target state="translated">当上面的代码中&lt;a href=&quot;qml-qtquick-text&quot;&gt;Text&lt;/a&gt;对象引用&lt;a href=&quot;qml-qtquick-item#parent-prop&quot;&gt;其父&lt;/a&gt;值时，它就是引用其父对象</target>
        </trans-unit>
        <trans-unit id="cfbd43c514e575cbd44c06a9f1befeb8fbc6aa47" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qml-qtquick-virtualkeyboard-keyboardlayoutloader&quot;&gt;KeyboardLayoutLoader&lt;/a&gt; is used as a root item of a keyboard layout, the actual keyboard layouts are wrapped inside Component elements. The keyboard layout is activated by assigning the id of an active component to the sourceComponent property.</source>
          <target state="translated">当&lt;a href=&quot;qml-qtquick-virtualkeyboard-keyboardlayoutloader&quot;&gt;KeyboardLayoutLoader&lt;/a&gt;用作键盘布局的根项目时，实际的键盘布局将包装在Component元素内。通过将活动组件的ID分配给sourceComponent属性来激活键盘布局。</target>
        </trans-unit>
        <trans-unit id="f043241c3f7cc581207444dcc1dc86dbdeb3ef7b" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt; is clicked, the console prints,</source>
          <target state="translated">当&lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt;被点击时，控制台打印，</target>
        </trans-unit>
        <trans-unit id="d450f4ff62c8dd3eda6ad3d118faffcc34e07662" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qqmlengine&quot;&gt;QQmlEngine&lt;/a&gt; instantiates a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;, the context is set automatically.</source>
          <target state="translated">当&lt;a href=&quot;qqmlengine&quot;&gt;QQmlEngine&lt;/a&gt;实例化&lt;a href=&quot;qobject&quot;&gt;QObject时&lt;/a&gt;，将自动设置上下文。</target>
        </trans-unit>
        <trans-unit id="1a3ec88b091fae5c593926fbff02a507863cf15b" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qsensor#axesOrientationMode-prop&quot;&gt;axesOrientationMode&lt;/a&gt; property is set to &lt;a href=&quot;qsensor#AxesOrientationMode-enum&quot;&gt;UserOrientation&lt;/a&gt;, the angle for rotating the reading values is taken from this property. In other modes, the property has no effect.</source>
          <target state="translated">当&lt;a href=&quot;qsensor#axesOrientationMode-prop&quot;&gt;axesOrientationMode&lt;/a&gt;属性设置为&lt;a href=&quot;qsensor#AxesOrientationMode-enum&quot;&gt;UserOrientation时&lt;/a&gt;，从该属性获取旋转读数值的角度。在其他模式下，该属性无效。</target>
        </trans-unit>
        <trans-unit id="f8b6764b784c8d16407b8358832df499fd592a45" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qsgmaterial&quot;&gt;QSGMaterial&lt;/a&gt; reports &lt;a href=&quot;qsgmaterial#Flag-enum&quot;&gt;SupportsRhiShader&lt;/a&gt; in &lt;a href=&quot;qsgmaterial#flags&quot;&gt;flags&lt;/a&gt;(), the scene graph may request a &lt;a href=&quot;qsgmaterialrhishader&quot;&gt;QSGMaterialRhiShader&lt;/a&gt; instead of &lt;a href=&quot;qsgmaterialshader&quot;&gt;QSGMaterialShader&lt;/a&gt;. This is indicated by having the &lt;a href=&quot;qsgmaterial#Flag-enum&quot;&gt;RhiShaderWanted&lt;/a&gt; flag set. In this case the return value must be a QSGRhiMaterialShader subclass.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ec06e7607af8f8760e7b965130ca0af1c7c4afa" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qt#PenJoinStyle-enum&quot;&gt;Qt::MiterJoin&lt;/a&gt; style is applied, it is possible to use the &lt;a href=&quot;qpen#setMiterLimit&quot;&gt;setMiterLimit&lt;/a&gt;() function to specify how far the miter join can extend from the join point. The &lt;a href=&quot;qpen#miterLimit&quot;&gt;miterLimit&lt;/a&gt;() is used to reduce artifacts between line joins where the lines are close to parallel.</source>
          <target state="translated">当应用&lt;a href=&quot;qt#PenJoinStyle-enum&quot;&gt;Qt :: MiterJoin&lt;/a&gt;样式时，可以使用&lt;a href=&quot;qpen#setMiterLimit&quot;&gt;setMiterLimit&lt;/a&gt;（）函数指定斜接连接可以从连接点延伸多远。的&lt;a href=&quot;qpen#miterLimit&quot;&gt;miterLimit分别&lt;/a&gt;（）是用来减少线之间的工件连接，其中线是接近平行。</target>
        </trans-unit>
        <trans-unit id="8cff9e77f59469425f8797ff7538a94cb9830def" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qt3drender-qpointsize#sizeMode-prop&quot;&gt;sizeMode&lt;/a&gt; property is set to SizeMode::Fixed, the value is set using glPointSize(), if available. When using SizeMode::Programmable, gl_PointSize must be set within shader programs, the value provided to this &lt;a href=&quot;qml-qt3d-render-renderstate&quot;&gt;RenderState&lt;/a&gt; is ignored in that case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8109269e175dc39675b846ed563d3f286803d82a" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qt3drender-qpointsize#sizeMode-prop&quot;&gt;sizeMode&lt;/a&gt; property is set to SizeMode::Fixed, the value is set using glPointSize(), if available. When using SizeMode::Programmable, gl_PointSize must be set within shader programs, the value provided to this &lt;a href=&quot;qml-renderstate&quot;&gt;RenderState&lt;/a&gt; is ignored in that case.</source>
          <target state="translated">当&lt;a href=&quot;qt3drender-qpointsize#sizeMode-prop&quot;&gt;sizeMode&lt;/a&gt;属性设置为SizeMode :: Fixed时，使用glPointSize（）设置该值（如果可用）。使用SizeMode :: Programmable时，必须在着色器程序中设置gl_PointSize，在这种情况下，将忽略提供给此&lt;a href=&quot;qml-renderstate&quot;&gt;RenderState&lt;/a&gt;的值。</target>
        </trans-unit>
        <trans-unit id="ef51d747b8fb0e1aaf24623fb2724ee2f97056ec" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qtoolbutton&quot;&gt;QToolButton&lt;/a&gt; displays arrows, the &lt;a href=&quot;#up-arrow-sub&quot;&gt;::up-arrow&lt;/a&gt;, &lt;a href=&quot;#down-arrow-sub&quot;&gt;::down-arrow&lt;/a&gt;, &lt;a href=&quot;#left-arrow-sub&quot;&gt;::left-arrow&lt;/a&gt; and &lt;a href=&quot;#right-arrow-sub&quot;&gt;::right-arrow&lt;/a&gt; subcontrols are used.</source>
          <target state="translated">当&lt;a href=&quot;qtoolbutton&quot;&gt;QToolButton&lt;/a&gt;显示箭头时，将使用&lt;a href=&quot;#up-arrow-sub&quot;&gt;:: up-arrow&lt;/a&gt;，&lt;a href=&quot;#down-arrow-sub&quot;&gt;:: down-arrow&lt;/a&gt;，&lt;a href=&quot;#left-arrow-sub&quot;&gt;:: left-arrow&lt;/a&gt;和&lt;a href=&quot;#right-arrow-sub&quot;&gt;:: right-arrow子&lt;/a&gt;控件。</target>
        </trans-unit>
        <trans-unit id="233835321d7949264542584e5872cf0f2ee5c9ad" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qtoolbutton&quot;&gt;QToolButton&lt;/a&gt; displays arrows, the &lt;a href=&quot;stylesheet-reference#up-arrow-sub&quot;&gt;::up-arrow&lt;/a&gt;, &lt;a href=&quot;stylesheet-reference#down-arrow-sub&quot;&gt;::down-arrow&lt;/a&gt;, &lt;a href=&quot;stylesheet-reference#left-arrow-sub&quot;&gt;::left-arrow&lt;/a&gt; and &lt;a href=&quot;stylesheet-reference#right-arrow-sub&quot;&gt;::right-arrow&lt;/a&gt; subcontrols are used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1a6fb9f01b0846bb260ddb329a9c95bfca49b3e" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;subdirs&lt;/code&gt; template is used, qmake generates a Makefile to examine each specified subdirectory, process any project file it finds there, and run the platform's &lt;code&gt;make&lt;/code&gt; tool on the newly-created Makefile. The &lt;code&gt;SUBDIRS&lt;/code&gt; variable is used to contain a list of all the subdirectories to be processed.</source>
          <target state="translated">使用 &lt;code&gt;subdirs&lt;/code&gt; 模板时，qmake会生成一个Makefile来检查每个指定的子目录，处理在该目录中找到的任何项目文件，然后在新创建的Makefile上运行平台的 &lt;code&gt;make&lt;/code&gt; 工具。所述 &lt;code&gt;SUBDIRS&lt;/code&gt; 变量用于包含所有待处理的子目录的列表。</target>
        </trans-unit>
        <trans-unit id="5b64d4e10455a073c6c16a2676284bd8b55dc704" translate="yes" xml:space="preserve">
          <source>When the KMS/DRM backend is in use, EGLFS reports all available screens in &lt;a href=&quot;qguiapplication#screens&quot;&gt;QGuiApplication::screens&lt;/a&gt;(). Applications can target different screens with different windows via &lt;a href=&quot;qwindow#setScreen&quot;&gt;QWindow::setScreen&lt;/a&gt;().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13cb608250173ac51a45d65525231f711e5ba267" translate="yes" xml:space="preserve">
          <source>When the KMS/DRM backend is in use, eglfs reports all available screens in &lt;a href=&quot;qguiapplication#screens&quot;&gt;QGuiApplication::screens&lt;/a&gt;(). Applications can target different screens with different windows via &lt;a href=&quot;qwindow#setScreen&quot;&gt;QWindow::setScreen&lt;/a&gt;().</source>
          <target state="translated">使用KMS / DRM后端时，eglfs报告&lt;a href=&quot;qguiapplication#screens&quot;&gt;QGuiApplication :: screens&lt;/a&gt;（）中的所有可用屏幕。应用程序可以通过&lt;a href=&quot;qwindow#setScreen&quot;&gt;QWindow :: setScreen&lt;/a&gt;（）将具有不同窗口的不同屏幕作为目标。</target>
        </trans-unit>
        <trans-unit id="e9c697bf2c44fd91eecd755192f28a6e88860c7e" translate="yes" xml:space="preserve">
          <source>When the PositionSource is active, position updates can be retrieved either by simply using the &lt;a href=&quot;qml-qtpositioning-positionsource#position-prop&quot;&gt;position&lt;/a&gt; property in a binding (as the value of another item's property), or by providing an implementation of the &lt;code&gt;onPositionChanged&lt;/code&gt; signal-handler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="590e6b713b7124a325673c8560f716815fb45204" translate="yes" xml:space="preserve">
          <source>When the QML engine encounters a use of &lt;code&gt;RandomNumberGenerator&lt;/code&gt; as a property value source, it invokes &lt;code&gt;RandomNumberGenerator::setTarget()&lt;/code&gt; to provide the type with the property to which the value source has been applied. When the internal timer in &lt;code&gt;RandomNumberGenerator&lt;/code&gt; triggers every 500 milliseconds, it will write a new number value to that specified property.</source>
          <target state="translated">当QML引擎遇到将 &lt;code&gt;RandomNumberGenerator&lt;/code&gt; 用作属性值源时，它将调用 &lt;code&gt;RandomNumberGenerator::setTarget()&lt;/code&gt; 为类型提供具有已应用值源的属性。当 &lt;code&gt;RandomNumberGenerator&lt;/code&gt; 中的内部计时器每500毫秒触发一次时，它将向该指定属性写入一个新的数字值。</target>
        </trans-unit>
        <trans-unit id="55bdd73045f54c63cca63284c91153ecc1e0e57c" translate="yes" xml:space="preserve">
          <source>When the QML engine processes this code, it creates a single instance of the</source>
          <target state="translated">当QML引擎处理这段代码时,它创建了一个单一的</target>
        </trans-unit>
        <trans-unit id="2200e5bee9d5bde2ef75b92345abdbbd47de48d7" translate="yes" xml:space="preserve">
          <source>When the Space key is pressed, the &lt;a href=&quot;qml-qtquick-item#visible-prop&quot;&gt;visible&lt;/a&gt; value of the green &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; is toggled. As it appears and disappears, the blue &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; moves within the Column, and the &lt;a href=&quot;qml-qtquick-column#move-prop&quot;&gt;move&lt;/a&gt; transition is automatically applied to the blue &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt;:</source>
          <target state="translated">当按下空格键时，绿色&lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;矩形&lt;/a&gt;的&lt;a href=&quot;qml-qtquick-item#visible-prop&quot;&gt;可见&lt;/a&gt;值将被切换。随着它的出现和消失，蓝色&lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt;在Column中移动，并且&lt;a href=&quot;qml-qtquick-column#move-prop&quot;&gt;移动&lt;/a&gt;过渡会自动应用于蓝色&lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="9c6490ecb547781d0dc7402f03b49e5ff063c783" translate="yes" xml:space="preserve">
          <source>When the StackView needs a new transition, it first calls &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#getTransition-method&quot;&gt;StackViewDelegate.getTransition()&lt;/a&gt;. The base implementation of this function just looks for a property named &lt;code&gt;properties.name&lt;/code&gt; inside itself (root), which is how it finds &lt;code&gt;property Component pushTransition&lt;/code&gt; in the examples above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a3ce649d4099a8096022c6c669c9176b6fc57ee" translate="yes" xml:space="preserve">
          <source>When the \brief command is used to describe a class, we recommend using a complete sentence like this:</source>
          <target state="translated">当使用\brief命令来描述一个类时,我们建议使用像这样的完整句子。</target>
        </trans-unit>
        <trans-unit id="557b6338e75a33d13fe088abb975f18a855ab911" translate="yes" xml:space="preserve">
          <source>When the \brief command is used to describe a property or a variable, the brief text must be a sentence fragment starting with &quot;whether&quot; (for a boolean property or variable) or starting with &quot;the&quot; (for any other property or variable).</source>
          <target state="translated">当使用&quot;/brief &quot;命令来描述一个属性或变量时,简短的文本必须是以 &quot;whether &quot;开头的句子片段(对于布尔属性或变量)或以 &quot;the &quot;开头的句子片段(对于任何其他属性或变量)。</target>
        </trans-unit>
        <trans-unit id="68de879942c076ccf49dec3b35482feaabb2b36a" translate="yes" xml:space="preserve">
          <source>When the above view is flicked beyond its bounds, it will return to its bounds using the transition specified:</source>
          <target state="translated">当上面的视图被翻动到超出其边界时,它将使用指定的过渡返回到其边界。</target>
        </trans-unit>
        <trans-unit id="589227a0f3172c2f19894c29348f6198f079bcbc" translate="yes" xml:space="preserve">
          <source>When the active subwindow is maximized, the default behavior is to maximize the next subwindow that is activated. Set this option if you do not want this behavior.</source>
          <target state="translated">当活动的子窗口被最大化时,默认行为是最大化下一个被激活的子窗口。如果您不想要这种行为,请设置此选项。</target>
        </trans-unit>
        <trans-unit id="ab36dbc74560565de3f4f93285f3477fd906523a" translate="yes" xml:space="preserve">
          <source>When the allowed &lt;a href=&quot;qdatetimeedit#setDateTimeRange&quot;&gt;range&lt;/a&gt; is narrower than some time interval whose end it straddles, keyboard tracking prevents the user editing the date or time to access the later part of the interval. For example, for a range from 29.04.2020 to 02.05.2020 and an initial date of 30.04.2020, the user can change neither the month (May 30th is outside the range) nor the day (April 2nd is outside the range).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a7ce62c114b1cc52094be5a1851abc5fc7f2e64" translate="yes" xml:space="preserve">
          <source>When the alpha channel is enabled either via &lt;a href=&quot;qquickwindow#setDefaultAlphaBuffer&quot;&gt;QQuickWindow::setDefaultAlphaBuffer&lt;/a&gt;() or by setting alphaBufferSize to a non-zero value in the window's &lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat&lt;/a&gt; or in the global format managed by &lt;a href=&quot;qsurfaceformat#setDefaultFormat&quot;&gt;QSurfaceFormat::setDefaultFormat&lt;/a&gt;(), the D3D12 backend will create a swapchain for composition and go through DirectComposition. This is necessary, because the mandatory flip model swapchain wouldn't support transparency otherwise.</source>
          <target state="translated">当通过&lt;a href=&quot;qquickwindow#setDefaultAlphaBuffer&quot;&gt;QQuickWindow :: setDefaultAlphaBuffer&lt;/a&gt;（）或通过在窗口的&lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat&lt;/a&gt;或&lt;a href=&quot;qsurfaceformat#setDefaultFormat&quot;&gt;QSurfaceFormat :: setDefaultFormat&lt;/a&gt;（）管理的全局格式中将alphaBufferSize设置为非零值来启用alpha通道时，D3D12后端将为组成并通过DirectComposition。这是必要的，因为强制翻转模型交换链否则将不支持透明性。</target>
        </trans-unit>
        <trans-unit id="9a1e6809f3ea75f0ed2e58d51575459791e1afbc" translate="yes" xml:space="preserve">
          <source>When the animation finishes it returns to the initial frame. This is the default behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2c6e776224aaea188a4e49fe2b71d9eeacafa46" translate="yes" xml:space="preserve">
          <source>When the animation finishes it stays on the final frame.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abead2ff8ba68473ab0f073d1c6b50c8ad980ea5" translate="yes" xml:space="preserve">
          <source>When the application is running with the generic, triangulation-based Shape implementation, the geometry generation happens entirely on the CPU. This is potentially expensive. Changing the set of path elements, changing the properties of these elements, or changing certain properties of the Shape itself all lead to retriangulation of the affected paths on every change. Therefore, applying animation to such properties can affect performance on less powerful systems.</source>
          <target state="translated">当应用程序使用通用的、基于三角测量的Shape实现运行时,几何图形的生成完全在CPU上进行。这可能是昂贵的。改变路径元素的集合,改变这些元素的属性,或者改变Shape本身的某些属性,都会导致每次改变受影响的路径都要重新三角测量。因此,在这些属性上应用动画可能会影响功能较弱的系统的性能。</target>
        </trans-unit>
        <trans-unit id="2dc59efa2f06087183eee0fb11a7e9582ff61062" translate="yes" xml:space="preserve">
          <source>When the application is running, an IDE or a tool that implements the binary protocol can connect to the open port.</source>
          <target state="translated">当应用程序运行时,IDE或实现二进制协议的工具可以连接到开放端口。</target>
        </trans-unit>
        <trans-unit id="c469e679911aae260b7551ead885271015ff56e7" translate="yes" xml:space="preserve">
          <source>When the application is started it has to register an message handler with &lt;a href=&quot;qnearfieldmanager#registerNdefMessageHandler&quot;&gt;registerNdefMessageHandler()&lt;/a&gt; The first NDEF message arriving in the handler is the message that started the application. See the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtnfc-corkboard-example.html#&quot;&gt;CorkBoard&lt;/a&gt; application for an example.</source>
          <target state="translated">启动应用程序时，它必须向registerNdefMessageHandler &lt;a href=&quot;qnearfieldmanager#registerNdefMessageHandler&quot;&gt;（）&lt;/a&gt;注册消息处理程序。到达处理程序的第一个NDEF消息是启动应用程序的消息。有关示例，请参见&lt;a href=&quot;https://doc.qt.io/qt-5.13/qtnfc-corkboard-example.html#&quot;&gt;CorkBoard&lt;/a&gt;应用程序。</target>
        </trans-unit>
        <trans-unit id="bf9811db4bca65a70c4bf17f4e8c83205ce8fbdb" translate="yes" xml:space="preserve">
          <source>When the application is started it has to register an message handler with &lt;a href=&quot;qnearfieldmanager#registerNdefMessageHandler&quot;&gt;registerNdefMessageHandler()&lt;/a&gt; The first NDEF message arriving in the handler is the message that started the application. See the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtnfc-corkboard-example.html&quot;&gt;CorkBoard&lt;/a&gt; application for an example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50a549dc65fe725b80a97de046a5a0dc3b6c6fb6" translate="yes" xml:space="preserve">
          <source>When the binding becomes inactive again, any direct bindings that were previously set on the property will be restored.</source>
          <target state="translated">当绑定再次变得不活跃时,之前在该属性上设置的任何直接绑定都将被恢复。</target>
        </trans-unit>
        <trans-unit id="447dd45f7b45ede6829150c673fe906621c3daff" translate="yes" xml:space="preserve">
          <source>When the button is clicked, the purchase process is started. At some point in the future, either the &lt;a href=&quot;qml-qtpurchasing-product#onPurchaseFailed-signal&quot;&gt;onPurchaseFailed&lt;/a&gt; handler will be called (for example if the user cancels the transaction), or the &lt;a href=&quot;qml-qtpurchasing-product#onPurchaseSucceeded-signal&quot;&gt;onPurchaseSucceeded&lt;/a&gt; handler will be called.</source>
          <target state="translated">单击按钮后，开始购买过程。在将来的某个时候，将调用&lt;a href=&quot;qml-qtpurchasing-product#onPurchaseFailed-signal&quot;&gt;onPurchaseFailed&lt;/a&gt;处理程序（例如，如果用户取消了交易），或者将调用&lt;a href=&quot;qml-qtpurchasing-product#onPurchaseSucceeded-signal&quot;&gt;onPurchaseSucceeded&lt;/a&gt;处理程序。</target>
        </trans-unit>
        <trans-unit id="4ebbf8f547dd292e8432493d1f5c0d39a31ffd9b" translate="yes" xml:space="preserve">
          <source>When the client is connected successfully, we connect to the `onTextMessageReceived()` signal, and send out &quot;Hello, world!&quot;. If connected with the EchoServer, we will receive the same message back.</source>
          <target state="translated">当客户端连接成功后,我们连接到`onTextMessageReceived()`信号,并发出 &quot;你好,世界!&quot;。如果与EchoServer连接,我们会收到同样的消息回馈。</target>
        </trans-unit>
        <trans-unit id="5d66decd4409859b0e6cc5ba70ca923d5222b329" translate="yes" xml:space="preserve">
          <source>When the connection to the &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;Source&lt;/a&gt; object is made, the initialization step passes the current property values (see &lt;a href=&quot;qtremoteobjects-replica#replica-initialization&quot;&gt;Replica Initialization&lt;/a&gt;). In a DynamicReplica, the property/signal/slot details are also sent, allowing the replica object to be created on-the-fly. This can be conventient in QML or scripting, but has two primary disadvantages. First, the object is in effect &quot;empty&quot; until it is successfully initialized by the &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;Source&lt;/a&gt;. Second, in C++, calls must be made using &lt;a href=&quot;qmetaobject#invokeMethod&quot;&gt;QMetaObject::invokeMethod&lt;/a&gt;(), as the moc generated lookup will not be available.</source>
          <target state="translated">与&lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;Source&lt;/a&gt;对象建立连接后，初始化步骤将传递当前属性值（请参阅&lt;a href=&quot;qtremoteobjects-replica#replica-initialization&quot;&gt;副本初始化&lt;/a&gt;）。在DynamicReplica中，还将发送属性/信号/插槽详细信息，从而可以即时创建副本对象。这在QML或脚本编写中可能很方便，但是有两个主要缺点。首先，对象实际上是&amp;ldquo;空&amp;rdquo;的，直到由&lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;Source&lt;/a&gt;成功初始化为止。其次，在C ++中，必须使用&lt;a href=&quot;qmetaobject#invokeMethod&quot;&gt;QMetaObject :: invokeMethod&lt;/a&gt;（）进行调用，因为moc生成的查找将不可用。</target>
        </trans-unit>
        <trans-unit id="08ec6e33eebed26c7c57c8ed22fb0ac60abd982e" translate="yes" xml:space="preserve">
          <source>When the content is changed using any of these functions, any previous content is cleared.</source>
          <target state="translated">当使用这些功能改变内容时,之前的内容都会被清除。</target>
        </trans-unit>
        <trans-unit id="098eff2cee4bb06ded290defca5ca43aedeb73b3" translate="yes" xml:space="preserve">
          <source>When the current element is a map, you may also call &lt;a href=&quot;qcborstreamreader#isLengthKnown&quot;&gt;isLengthKnown&lt;/a&gt;() to find out if the map's size is explicit in the CBOR stream. If it is, that size can be obtained by calling &lt;a href=&quot;qcborstreamreader#length&quot;&gt;length&lt;/a&gt;().</source>
          <target state="translated">当当前元素是地图时，您还可以调用&lt;a href=&quot;qcborstreamreader#isLengthKnown&quot;&gt;isLengthKnown&lt;/a&gt;（）来确定地图的大小在CBOR流中是否是显式的。如果是这样，则可以通过调用&lt;a href=&quot;qcborstreamreader#length&quot;&gt;length&lt;/a&gt;（）获得该大小。</target>
        </trans-unit>
        <trans-unit id="bea6a9143e97cc060ee75f79678b23a7773047e8" translate="yes" xml:space="preserve">
          <source>When the current element is an array, you may also call &lt;a href=&quot;qcborstreamreader#isLengthKnown&quot;&gt;isLengthKnown&lt;/a&gt;() to find out if the array's size is explicit in the CBOR stream. If it is, that size can be obtained by calling &lt;a href=&quot;qcborstreamreader#length&quot;&gt;length&lt;/a&gt;().</source>
          <target state="translated">当当前元素是数组时，您也可以调用&lt;a href=&quot;qcborstreamreader#isLengthKnown&quot;&gt;isLengthKnown&lt;/a&gt;（）来确定数组的大小在CBOR流中是否是显式的。如果是这样，则可以通过调用&lt;a href=&quot;qcborstreamreader#length&quot;&gt;length&lt;/a&gt;（）获得该大小。</target>
        </trans-unit>
        <trans-unit id="f84400c746d8fc0a5a48647d3e3c7ab1cfd364c9" translate="yes" xml:space="preserve">
          <source>When the current file changes for local operations, this signal is emitted with the new file name as the</source>
          <target state="translated">当当前文件发生变化进行本地操作时,会发出这个信号,新文件名为</target>
        </trans-unit>
        <trans-unit id="0a86295fc3e43e6a47bc831aed3e39216c7b217d" translate="yes" xml:space="preserve">
          <source>When the current file changes, this signal is emitted with the new file URL as the</source>
          <target state="translated">当当前文件发生变化时,会发出这个信号,新的文件网址作为</target>
        </trans-unit>
        <trans-unit id="8d02ddfa1e09fd4df4941f2aea01335858653f59" translate="yes" xml:space="preserve">
          <source>When the current loop changes, &lt;a href=&quot;qabstractanimation&quot;&gt;QAbstractAnimation&lt;/a&gt; emits the &lt;a href=&quot;qabstractanimation#currentLoopChanged&quot;&gt;currentLoopChanged&lt;/a&gt;() signal.</source>
          <target state="translated">当当前循环改变时，&lt;a href=&quot;qabstractanimation&quot;&gt;QAbstractAnimation&lt;/a&gt;发出&lt;a href=&quot;qabstractanimation#currentLoopChanged&quot;&gt;currentLoopChanged&lt;/a&gt;（）信号。</target>
        </trans-unit>
        <trans-unit id="0cfe43b8f234528af4d27981c91186f3fac30622" translate="yes" xml:space="preserve">
          <source>When the current size of the cache is greater than the &lt;a href=&quot;qnetworkdiskcache#maximumCacheSize&quot;&gt;maximumCacheSize&lt;/a&gt;() older cache files are removed until the total size is less then 90% of &lt;a href=&quot;qnetworkdiskcache#maximumCacheSize&quot;&gt;maximumCacheSize&lt;/a&gt;() starting with the oldest ones first using the file creation date to determine how old a cache file is.</source>
          <target state="translated">当高速缓存的当前大小大于&lt;a href=&quot;qnetworkdiskcache#maximumCacheSize&quot;&gt;maximumCacheSize&lt;/a&gt;（）时，将删除较旧的高速缓存文件，直到总大小小于&lt;a href=&quot;qnetworkdiskcache#maximumCacheSize&quot;&gt;maxmaxCacheSize&lt;/a&gt;（）的90％，然后从最早的文件开始，首先使用文件创建日期确定高速缓存文件的年代是。</target>
        </trans-unit>
        <trans-unit id="3e61c9290a3e31fccfacad9bcadb7f0ab37cb158" translate="yes" xml:space="preserve">
          <source>When the cursor is moved and the underlying formatting attributes change, the &lt;a href=&quot;qtextedit#currentCharFormatChanged&quot;&gt;currentCharFormatChanged&lt;/a&gt;() signal is emitted to reflect the new attributes at the new cursor position.</source>
          <target state="translated">当光标移动并且基础格式属性更改时，会发出&lt;a href=&quot;qtextedit#currentCharFormatChanged&quot;&gt;currentCharFormatChanged&lt;/a&gt;（）信号以在新光标位置反映新属性。</target>
        </trans-unit>
        <trans-unit id="0bcf3c2857361e33820b911b748bda8d3e8f2499" translate="yes" xml:space="preserve">
          <source>When the cursor is over an object that can be used in a connection, the object will be highlighted.</source>
          <target state="translated">当光标在一个可用于连接的对象上时,该对象将被高亮显示。</target>
        </trans-unit>
        <trans-unit id="d5828b4053e945be1fe64d76bbf73ddc4acecf13" translate="yes" xml:space="preserve">
          <source>When the dark theme is in use, different &lt;a href=&quot;#pre-defined-shades&quot;&gt;shades&lt;/a&gt; of the pre-defined colors are used by default:</source>
          <target state="translated">使用深色主题时，默认情况下使用不同&lt;a href=&quot;#pre-defined-shades&quot;&gt;阴影&lt;/a&gt;的预定义颜色：</target>
        </trans-unit>
        <trans-unit id="3e63c161b63a9e90882d13f563f0753fdc02220f" translate="yes" xml:space="preserve">
          <source>When the dark theme is in use, different &lt;a href=&quot;qtquickcontrols2-material#pre-defined-shades&quot;&gt;shades&lt;/a&gt; of the pre-defined colors are used by default:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa15325522b12e3e10e05b6e7845de4c15cc9516" translate="yes" xml:space="preserve">
          <source>When the data has been set, the model must let the views know that some data has changed. This is done by emitting the &lt;a href=&quot;qabstractitemmodel#dataChanged&quot;&gt;dataChanged()&lt;/a&gt; signal. Since only one item of data has changed, the range of items specified in the signal is limited to just one model index.</source>
          <target state="translated">设置数据后，模型必须让视图知道某些数据已更改。这是通过发出&lt;a href=&quot;qabstractitemmodel#dataChanged&quot;&gt;dataChanged（）&lt;/a&gt;信号完成的。由于仅一项数据已更改，因此信号中指定的项范围仅限于一个模型索引。</target>
        </trans-unit>
        <trans-unit id="268c6bc406e79834c8bfc145b96838dee4c8962b" translate="yes" xml:space="preserve">
          <source>When the default OpenGL &lt;a href=&quot;qtquick-visualcanvas-scenegraph&quot;&gt;scene graph&lt;/a&gt; backend is in use, images can also be supplied in compressed texture files. The content must be a simple RGB(A) format 2D texture. Supported compression schemes are only limited by the underlying OpenGL driver and GPU. The following container file formats are supported:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39d841b77292d3e68d73048948b5c24756c32f98" translate="yes" xml:space="preserve">
          <source>When the default OpenGL &lt;a href=&quot;qtquick-visualcanvas-scenegraph#&quot;&gt;scene graph&lt;/a&gt; backend is in use, images can also be supplied in compressed texture files. The content must be a simple RGB(A) format 2D texture. Supported compression schemes are only limited by the underlying OpenGL driver and GPU. The following container file formats are supported:</source>
          <target state="translated">使用默认的OpenGL &lt;a href=&quot;qtquick-visualcanvas-scenegraph#&quot;&gt;场景图&lt;/a&gt;后端时，还可以在压缩的纹理文件中提供图像。内容必须是简单的RGB（A）格式2D纹理。支持的压缩方案仅受基础OpenGL驱动程序和GPU的限制。支持以下容器文件格式：</target>
        </trans-unit>
        <trans-unit id="64564ede097c86de33c3d219ff3f4d6b55c9c533" translate="yes" xml:space="preserve">
          <source>When the dialog needs to generate a set of preview pages, the &lt;a href=&quot;qprintpreviewdialog#paintRequested&quot;&gt;paintRequested&lt;/a&gt;() signal will be emitted. You can use the exact same code for the actual printing as for having the preview generated, including calling &lt;a href=&quot;qprinter#newPage&quot;&gt;QPrinter::newPage&lt;/a&gt;() to start a new page in the preview. Connect a slot to the &lt;a href=&quot;qprintpreviewdialog#paintRequested&quot;&gt;paintRequested&lt;/a&gt;() signal, where you draw onto the &lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt; object that is passed into the slot.</source>
          <target state="translated">当对话框需要生成一组预览页面时，将发出&lt;a href=&quot;qprintpreviewdialog#paintRequested&quot;&gt;paintRequested&lt;/a&gt;（）信号。您可以使用与生成预览时完全相同的代码进行实际打印，包括调用&lt;a href=&quot;qprinter#newPage&quot;&gt;QPrinter :: newPage&lt;/a&gt;（）在预览中启动新页面。将插槽连接到&lt;a href=&quot;qprintpreviewdialog#paintRequested&quot;&gt;paintRequested&lt;/a&gt;（）信号，在此处绘制传递到该插槽的&lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="442b26fe36b5b6b28e8fee4c93f0f0f9179a4be0" translate="yes" xml:space="preserve">
          <source>When the disk cache is disabled, via &lt;a href=&quot;qt#ApplicationAttribute-enum&quot;&gt;Qt::AA_DisableShaderDiskCache&lt;/a&gt; for example, or the OpenGL context has no support for context binaries, calling this function is equivalent to &lt;a href=&quot;qopenglshaderprogram#addShaderFromSourceCode&quot;&gt;addShaderFromSourceCode&lt;/a&gt;().</source>
          <target state="translated">当禁用磁盘缓存时，例如通过&lt;a href=&quot;qt#ApplicationAttribute-enum&quot;&gt;Qt :: AA_DisableShaderDiskCache&lt;/a&gt;，或者OpenGL上下文不支持上下文二进制文件，则调用此函数等效于&lt;a href=&quot;qopenglshaderprogram#addShaderFromSourceCode&quot;&gt;addShaderFromSourceCode&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="9a274b9868a858f6451036974bc85cd45ebacc98" translate="yes" xml:space="preserve">
          <source>When the disk cache is disabled, via &lt;a href=&quot;qt#ApplicationAttribute-enum&quot;&gt;Qt::AA_DisableShaderDiskCache&lt;/a&gt; for example, or the OpenGL context has no support for context binaries, calling this function is equivalent to &lt;a href=&quot;qopenglshaderprogram#addShaderFromSourceFile&quot;&gt;addShaderFromSourceFile&lt;/a&gt;().</source>
          <target state="translated">当禁用磁盘缓存时，例如通过&lt;a href=&quot;qt#ApplicationAttribute-enum&quot;&gt;Qt :: AA_DisableShaderDiskCache&lt;/a&gt;，或者OpenGL上下文不支持上下文二进制文件，则调用此函数等效于&lt;a href=&quot;qopenglshaderprogram#addShaderFromSourceFile&quot;&gt;addShaderFromSourceFile&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="cfc128bc4fe84e02bab33b87cc2068b75786b6b9" translate="yes" xml:space="preserve">
          <source>When the dock widget lays out its contents it asks the style for these pixel metrics: &lt;code&gt;PM_DockWidgetSeparatorExtent&lt;/code&gt;, &lt;code&gt;PM_DockWidgetTitleBarButtonMargin&lt;/code&gt;, &lt;code&gt;PM_DockWidgetFrameWidth&lt;/code&gt;, and &lt;code&gt;PM_DockWidgetTitleMargin&lt;/code&gt;. It also calculates the bounding rectangles of the float and close buttons with &lt;code&gt;SE_DockWidgetCloseButton&lt;/code&gt; and &lt;code&gt;SE_DockWidgetFloatButton&lt;/code&gt;.</source>
          <target state="translated">当停靠小部件 &lt;code&gt;PM_DockWidgetSeparatorExtent&lt;/code&gt; 其内容时，它会询问这些像素度量的样式：PM_DockWidgetSeparatorExtent， &lt;code&gt;PM_DockWidgetTitleBarButtonMargin&lt;/code&gt; ， &lt;code&gt;PM_DockWidgetFrameWidth&lt;/code&gt; 和 &lt;code&gt;PM_DockWidgetTitleMargin&lt;/code&gt; 。它还使用 &lt;code&gt;SE_DockWidgetCloseButton&lt;/code&gt; 和 &lt;code&gt;SE_DockWidgetFloatButton&lt;/code&gt; 计算浮动按钮和关闭按钮的边界矩形。</target>
        </trans-unit>
        <trans-unit id="dc07829ed23956686aa2110b6aa13a3a31695d82" translate="yes" xml:space="preserve">
          <source>When the edit strategy is &lt;a href=&quot;qsqltablemodel#EditStrategy-enum&quot;&gt;OnManualSubmit&lt;/a&gt;, deletion of rows from the database is delayed until &lt;a href=&quot;qsqltablemodel#submitAll&quot;&gt;submitAll&lt;/a&gt;() is called.</source>
          <target state="translated">当编辑策略为&lt;a href=&quot;qsqltablemodel#EditStrategy-enum&quot;&gt;OnManualSubmit时&lt;/a&gt;，将从数据库中删除行的操作延迟到&lt;a href=&quot;qsqltablemodel#submitAll&quot;&gt;调用commitAll&lt;/a&gt;（）为止。</target>
        </trans-unit>
        <trans-unit id="69d60b285999f455929d7c354ec16df415cf791e" translate="yes" xml:space="preserve">
          <source>When the error occurs in code that uses the &lt;a href=&quot;qaxfactory#QAXCLASS&quot;&gt;QAXCLASS&lt;/a&gt;() or QAXFACTORY_DEFAULT() macro, the widget class had no constructor that can be used by the default factory. Either add a standard widget constructor or implement a custom factory that doesn't require one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ce533133f051ef361f68d445640b0f45e1ae0bd" translate="yes" xml:space="preserve">
          <source>When the error occurs in code that uses the &lt;a href=&quot;qaxfactory#QAXFACTORY_DEFAULT&quot;&gt;QAXFACTORY_DEFAULT&lt;/a&gt;() macro, the widget class had no constructor that can be used by the default factory. Either add a standard widget constructor or implement a custom factory that doesn't require one.</source>
          <target state="translated">当在使用&lt;a href=&quot;qaxfactory#QAXFACTORY_DEFAULT&quot;&gt;QAXFACTORY_DEFAULT&lt;/a&gt;（）宏的代码中发生错误时，窗口小部件类没有默认工厂可以使用的构造函数。添加标准的窗口小部件构造函数或实现不需要的自定义工厂。</target>
        </trans-unit>
        <trans-unit id="67528e55cc72382a76299d4a29a6d404185ca633" translate="yes" xml:space="preserve">
          <source>When the error occurs in code that uses the &lt;a href=&quot;qaxfactory#QAXFACTORY_EXPORT&quot;&gt;QAXFACTORY_EXPORT&lt;/a&gt;() macro, the &lt;a href=&quot;qaxfactory&quot;&gt;QAxFactory&lt;/a&gt; subclass had no appropriate constructor. Provide a public class constructor like</source>
          <target state="translated">当使用&lt;a href=&quot;qaxfactory#QAXFACTORY_EXPORT&quot;&gt;QAXFACTORY_EXPORT&lt;/a&gt;（）宏的代码中发生错误时，&lt;a href=&quot;qaxfactory&quot;&gt;QAxFactory&lt;/a&gt;子类没有适当的构造函数。提供类似的公共类构造函数</target>
        </trans-unit>
        <trans-unit id="667bcb82ac840306758fe028ef02a3142d64c33c" translate="yes" xml:space="preserve">
          <source>When the file was created (may not be not supported on UNIX).</source>
          <target state="translated">文件创建的时间(UNIX上可能不支持)。</target>
        </trans-unit>
        <trans-unit id="b25b4b7cadd51d3809c6192d30e9736fd31ceee0" translate="yes" xml:space="preserve">
          <source>When the file was most recently accessed (e.g. read or written to).</source>
          <target state="translated">最近一次访问文件的时间(如读取或写入)。</target>
        </trans-unit>
        <trans-unit id="4c27bd30e3a44efb1b186d178c93f6ceaf40ce32" translate="yes" xml:space="preserve">
          <source>When the file was most recently modified.</source>
          <target state="translated">最近一次修改文件的时间。</target>
        </trans-unit>
        <trans-unit id="d5d340431973f92573daf9a19dcdb9fd00b81737" translate="yes" xml:space="preserve">
          <source>When the file's metadata was last changed.</source>
          <target state="translated">文件的元数据最后一次被修改的时间。</target>
        </trans-unit>
        <trans-unit id="0ed30361bc54f69e5900b60fbcec5e46b66fc62b" translate="yes" xml:space="preserve">
          <source>When the filter object's &lt;a href=&quot;qobject#eventFilter&quot;&gt;eventFilter()&lt;/a&gt; implementation is called, it can accept or reject the event, and allow or deny further processing of the event. If all the event filters allow further processing of an event (by each returning &lt;code&gt;false&lt;/code&gt;), the event is sent to the target object itself. If one of them stops processing (by returning &lt;code&gt;true&lt;/code&gt;), the target and any later event filters do not get to see the event at all.</source>
          <target state="translated">调用过滤器对象的&lt;a href=&quot;qobject#eventFilter&quot;&gt;eventFilter（）&lt;/a&gt;实现时，它可以接受或拒绝事件，并允许或拒绝事件的进一步处理。如果所有事件过滤器都允许对事件进行进一步处理（每次返回 &lt;code&gt;false&lt;/code&gt; ），则事件将被发送到目标对象本身。如果其中一个停止处理（通过返回 &lt;code&gt;true&lt;/code&gt; ），则目标和任何以后的事件过滤器将根本看不到该事件。</target>
        </trans-unit>
        <trans-unit id="837b081290388ef24310dab55793156db9eb9dfc" translate="yes" xml:space="preserve">
          <source>When the first touch point is detected, the destination widget is determined firstly by the location on screen and secondly by the propagation rules.</source>
          <target state="translated">当检测到第一个触摸点时,首先通过屏幕上的位置来确定目标小部件,其次通过传播规则来确定。</target>
        </trans-unit>
        <trans-unit id="da3ee5de937f78331baaaed7a12ec8f5b5ae3e7b" translate="yes" xml:space="preserve">
          <source>When the format is extended and a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60ff0e9974e90a3bb46faadb679db78b2703c023" translate="yes" xml:space="preserve">
          <source>When the format is not explicitly set via this function, the format returned by &lt;a href=&quot;qsurfaceformat#defaultFormat&quot;&gt;QSurfaceFormat::defaultFormat&lt;/a&gt;() will be used. This means that when having multiple OpenGL widgets, individual calls to this function can be replaced by one single call to &lt;a href=&quot;qsurfaceformat#setDefaultFormat&quot;&gt;QSurfaceFormat::setDefaultFormat&lt;/a&gt;() before creating the first widget.</source>
          <target state="translated">如果未通过此函数显式设置格式，&lt;a href=&quot;qsurfaceformat#defaultFormat&quot;&gt;则将使用QSurfaceFormat :: defaultFormat&lt;/a&gt;（）返回的格式。这意味着，当具有多个OpenGL窗口小部件时，可以在创建第一个窗口小部件之前用对&lt;a href=&quot;qsurfaceformat#setDefaultFormat&quot;&gt;QSurfaceFormat :: setDefaultFormat&lt;/a&gt;（）的单个调用来替换对此函数的单个调用。</target>
        </trans-unit>
        <trans-unit id="2beb1fd6e4f28222293604d7f4d897a896d350d1" translate="yes" xml:space="preserve">
          <source>When the format is not explicitly set via this function, the format returned by &lt;a href=&quot;qsurfaceformat#defaultFormat&quot;&gt;QSurfaceFormat::defaultFormat&lt;/a&gt;() will be used. This means that when having multiple contexts, individual calls to this function can be replaced by one single call to &lt;a href=&quot;qsurfaceformat#setDefaultFormat&quot;&gt;QSurfaceFormat::setDefaultFormat&lt;/a&gt;() before creating the first context.</source>
          <target state="translated">如果未通过此函数显式设置格式，&lt;a href=&quot;qsurfaceformat#defaultFormat&quot;&gt;则将使用QSurfaceFormat :: defaultFormat&lt;/a&gt;（）返回的格式。这意味着，当具有多个上下文时，可以在创建第一个上下文之前用对&lt;a href=&quot;qsurfaceformat#setDefaultFormat&quot;&gt;QSurfaceFormat :: setDefaultFormat&lt;/a&gt;（）的单个调用来替换对此函数的单个调用。</target>
        </trans-unit>
        <trans-unit id="00713dadf93099ecb982ada3e77d69bdabc871f2" translate="yes" xml:space="preserve">
          <source>When the format is not explicitly set via this function, the format returned by &lt;a href=&quot;qsurfaceformat#defaultFormat&quot;&gt;QSurfaceFormat::defaultFormat&lt;/a&gt;() will be used. This means that when having multiple windows, individual calls to this function can be replaced by one single call to &lt;a href=&quot;qsurfaceformat#setDefaultFormat&quot;&gt;QSurfaceFormat::setDefaultFormat&lt;/a&gt;() before creating the first window.</source>
          <target state="translated">如果未通过此函数显式设置格式，&lt;a href=&quot;qsurfaceformat#defaultFormat&quot;&gt;则将使用QSurfaceFormat :: defaultFormat&lt;/a&gt;（）返回的格式。这意味着当有多个窗口时，在创建第一个窗口之前，可以通过对&lt;a href=&quot;qsurfaceformat#setDefaultFormat&quot;&gt;QSurfaceFormat :: setDefaultFormat&lt;/a&gt;（）的单个调用来替换对此函数的单个调用。</target>
        </trans-unit>
        <trans-unit id="25d8d569194c95628c8a9af91c9b0f5b8ee86128" translate="yes" xml:space="preserve">
          <source>When the given</source>
          <target state="translated">当给定的</target>
        </trans-unit>
        <trans-unit id="a84c5e22d39ffceb346211bc14286a14c79f8784" translate="yes" xml:space="preserve">
          <source>When the horizontal alignment of a text item is not explicitly set, the text element is automatically aligned to the natural reading direction of the text. By default left-to-right text like English is aligned to the left side of the text area, and right-to-left text like Arabic is aligned to the right side of the text area. The alignment of a text element with empty text takes its alignment cue from &lt;a href=&quot;qinputmethod#inputDirection-prop&quot;&gt;QInputMethod::inputDirection&lt;/a&gt;(), which is based on the active system locale.</source>
          <target state="translated">当未明确设置文本项目的水平对齐方式时，文本元素将自动对齐到文本的自然阅读方向。默认情况下，从左至右的文本（如英语）对齐到文本区域的左侧，从右向左的文本（如阿拉伯语）对齐到文本区域的右侧。文本元素与空文本的对齐方式取自&lt;a href=&quot;qinputmethod#inputDirection-prop&quot;&gt;QInputMethod :: inputDirection&lt;/a&gt;（）的对齐方式，该方法基于活动的系统区域设置。</target>
        </trans-unit>
        <trans-unit id="2f163bb4526ffce4c5d0c97da01d544fc9ab7648" translate="yes" xml:space="preserve">
          <source>When the image is ready, &lt;a href=&quot;qml-qtquick-canvas#imageLoaded-signal&quot;&gt;imageLoaded&lt;/a&gt; will be emitted. The loaded image can be unloaded by the &lt;a href=&quot;qml-qtquick-canvas#unloadImage-method&quot;&gt;unloadImage()&lt;/a&gt; method.</source>
          <target state="translated">图片准备好后，将发出&lt;a href=&quot;qml-qtquick-canvas#imageLoaded-signal&quot;&gt;imageLoaded&lt;/a&gt;。可以通过&lt;a href=&quot;qml-qtquick-canvas#unloadImage-method&quot;&gt;unloadImage（）&lt;/a&gt;方法卸载已加载的图像。</target>
        </trans-unit>
        <trans-unit id="4722dd5405336bb1dc515fbc7e7e1db0a5d91ef2" translate="yes" xml:space="preserve">
          <source>When the image is scaled, regions of the source image are scaled or tiled to create the displayed border image in the following way:</source>
          <target state="translated">当图像被缩放时,源图像的区域被缩放或平铺,以如下方式创建显示的边界图像。</target>
        </trans-unit>
        <trans-unit id="cb1a5c40c986de8b7e66b324c82e0775e3788bc6" translate="yes" xml:space="preserve">
          <source>When the image is used, the color table must be large enough to have entries for all the pixel/index values present in the image, otherwise the results are undefined.</source>
          <target state="translated">当使用图像时,颜色表必须足够大,以使图像中存在的所有像素/索引值都有条目,否则结果是未定义的。</target>
        </trans-unit>
        <trans-unit id="a62a0ab3afb30df54c7a307954a51b28f0879b31" translate="yes" xml:space="preserve">
          <source>When the indexing process has finished, the search engine can be used to search through the index for a given term using the search() function. When the search input is passed to the search engine, the &lt;a href=&quot;qhelpsearchengine#searchingStarted&quot;&gt;searchingStarted&lt;/a&gt;() signal is emitted. When the search finishes, the &lt;a href=&quot;qhelpsearchengine#searchingFinished&quot;&gt;searchingFinished&lt;/a&gt;() signal is emitted. The search process can be stopped by calling &lt;a href=&quot;qhelpsearchengine#cancelSearching&quot;&gt;cancelSearching&lt;/a&gt;().</source>
          <target state="translated">索引过程完成后，可以使用搜索引擎使用search（）函数在索引中搜索给定术语。当搜索输入传递到搜索引擎时，将发出&lt;a href=&quot;qhelpsearchengine#searchingStarted&quot;&gt;searchingStarted&lt;/a&gt;（）信号。搜索完成后，将发出&lt;a href=&quot;qhelpsearchengine#searchingFinished&quot;&gt;searchingFinished&lt;/a&gt;（）信号。可以通过调用&lt;a href=&quot;qhelpsearchengine#cancelSearching&quot;&gt;cancelSearching&lt;/a&gt;（）停止搜索过程。</target>
        </trans-unit>
        <trans-unit id="abed85d30a721e876a4399c7b26aa9eed3e46ead" translate="yes" xml:space="preserve">
          <source>When the input method requires the UI to update the contents of a selection list, it will emit the &lt;a href=&quot;qml-qtquick-virtualkeyboard-inputmethod#selectionListChanged-signal&quot;&gt;InputMethod::selectionListChanged&lt;/a&gt; signal. Likewise, if the input method requires the UI to highlight an item in the list, it will emit the &lt;a href=&quot;qml-qtquick-virtualkeyboard-inputmethod#selectionListActiveItemChanged-signal&quot;&gt;InputMethod::selectionListActiveItemChanged&lt;/a&gt; signal.</source>
          <target state="translated">当输入法要求UI更新选择列表的内容时，它将发出&lt;a href=&quot;qml-qtquick-virtualkeyboard-inputmethod#selectionListChanged-signal&quot;&gt;InputMethod :: selectionListChanged&lt;/a&gt;信号。同样，如果输入法要求UI突出显示列表中的项目，则它将发出&lt;a href=&quot;qml-qtquick-virtualkeyboard-inputmethod#selectionListActiveItemChanged-signal&quot;&gt;InputMethod :: selectionListActiveItemChanged&lt;/a&gt;信号。</target>
        </trans-unit>
        <trans-unit id="af13632c6936ddc6476f8bec001c16d3ccdb1b88" translate="yes" xml:space="preserve">
          <source>When the interaction is completed we strongly recommend releasing the user interaction semaphore with a call to &lt;a href=&quot;qsessionmanager#release&quot;&gt;release&lt;/a&gt;(). This way, other applications may get the chance to interact with the user while your application is still busy saving data. (The semaphore is implicitly released when the application exits.)</source>
          <target state="translated">交互完成后，我们强烈建议您通过调用&lt;a href=&quot;qsessionmanager#release&quot;&gt;release&lt;/a&gt;（）释放用户交互信号。这样，当您的应用程序仍在忙于保存数据时，其他应用程序就有机会与用户进行交互。（当应用程序退出时，信号量被隐式释放。）</target>
        </trans-unit>
        <trans-unit id="a08dbc79fd5ced7fe929c3d064e1b645b21d39b2" translate="yes" xml:space="preserve">
          <source>When the labels are editable the user will be able to change the range of the axis conveniently by editing any of the labels. This feature is only supported for the &lt;a href=&quot;qvalueaxis&quot;&gt;QValueAxis&lt;/a&gt; and the &lt;a href=&quot;qdatetimeaxis&quot;&gt;QDateTimeAxis&lt;/a&gt;.</source>
          <target state="translated">当标签是可编辑的时，用户将能够通过编辑任何标签来方便地更改轴的范围。此功能仅支持对&lt;a href=&quot;qvalueaxis&quot;&gt;QValueAxis&lt;/a&gt;和&lt;a href=&quot;qdatetimeaxis&quot;&gt;QDateTimeAxis&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="16aac338dd8507181525a913639f185cb93e3d46" translate="yes" xml:space="preserve">
          <source>When the layout direction is set on a widget, it will propagate to the widget's children, but not to a child that is a window and not to a child for which setLayoutDirection() has been explicitly called. Also, child widgets added</source>
          <target state="translated">当在小组件上设置布局方向时,它将传播到小组件的子节点,但不会传播到作为窗口的子节点,也不会传播到已明确调用 setLayoutDirection()的子节点。此外,添加的子部件</target>
        </trans-unit>
        <trans-unit id="757e208faf34bd91da1b625ef70871bbc740552e" translate="yes" xml:space="preserve">
          <source>When the layout's geometry changes, &lt;a href=&quot;graphicsview#qgraphicslayout&quot;&gt;QGraphicsLayout&lt;/a&gt; immediately rearranges all of its managed items by calling &lt;a href=&quot;qgraphicslayoutitem#setGeometry&quot;&gt;setGeometry&lt;/a&gt;() on each item. This rearrangement is called</source>
          <target state="translated">当布局的几何形状更改时，&lt;a href=&quot;graphicsview#qgraphicslayout&quot;&gt;QGraphicsLayout&lt;/a&gt;通过在每个项目上调用&lt;a href=&quot;qgraphicslayoutitem#setGeometry&quot;&gt;setGeometry&lt;/a&gt;（）来立即重新排列其所有托管项目。这种重排称为</target>
        </trans-unit>
        <trans-unit id="14d52274c262e663bee4bb6936d376e01f9d9786" translate="yes" xml:space="preserve">
          <source>When the layout's geometry changes, QGraphicsLayout immediately rearranges all of its managed items by calling &lt;a href=&quot;qgraphicslayoutitem#setGeometry&quot;&gt;setGeometry&lt;/a&gt;() on each item. This rearrangement is called</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4868cf3fc8227fd58f7cf326e3d937144f921d5" translate="yes" xml:space="preserve">
          <source>When the locale is not specified, the default system locale is used instead.</source>
          <target state="translated">当没有指定locale时,将使用默认的系统locale。</target>
        </trans-unit>
        <trans-unit id="d8c8da609611d53dcc5b14869c74793f679093e3" translate="yes" xml:space="preserve">
          <source>When the machine is in state &lt;code&gt;s2&lt;/code&gt;, the machine will play the default animation for the property &lt;code&gt;fooBar&lt;/code&gt; since this property is assigned by &lt;code&gt;s2&lt;/code&gt;.</source>
          <target state="translated">当机器处于状态 &lt;code&gt;s2&lt;/code&gt; 时，机器将为 &lt;code&gt;fooBar&lt;/code&gt; 属性播放默认动画，因为此属性是由 &lt;code&gt;s2&lt;/code&gt; 分配的。</target>
        </trans-unit>
        <trans-unit id="e08c3bd224be28ab8da0d15a3e80244ae34b5521" translate="yes" xml:space="preserve">
          <source>When the map is displayed, each possible geographic coordinate that is visible will map to some pixel X and Y coordinate on the screen. To perform conversions between these two, Map provides the &lt;a href=&quot;qml-qtlocation-map#toCoordinate-method&quot;&gt;toCoordinate&lt;/a&gt; and &lt;a href=&quot;qml-qtlocation-map#fromCoordinate-method&quot;&gt;fromCoordinate&lt;/a&gt; functions, which are of general utility.</source>
          <target state="translated">显示地图时，可见的每个可能的地理坐标都将映射到屏幕上的某些像素X和Y坐标。为了在这两者之间进行转换，Map提供了&lt;a href=&quot;qml-qtlocation-map#toCoordinate-method&quot;&gt;toCoordinate&lt;/a&gt;和&lt;a href=&quot;qml-qtlocation-map#fromCoordinate-method&quot;&gt;fromCoordinate&lt;/a&gt;函数，它们具有通用性。</target>
        </trans-unit>
        <trans-unit id="c5d7b44152d91a8b1270640c20696e9ece89a8be" translate="yes" xml:space="preserve">
          <source>When the mode changes, &lt;a href=&quot;qsslsocket&quot;&gt;QSslSocket&lt;/a&gt; emits &lt;a href=&quot;qsslsocket#modeChanged&quot;&gt;modeChanged&lt;/a&gt;()</source>
          <target state="translated">当模式改变时，&lt;a href=&quot;qsslsocket&quot;&gt;QSslSocket&lt;/a&gt;发射&lt;a href=&quot;qsslsocket#modeChanged&quot;&gt;modeChanged&lt;/a&gt;（）</target>
        </trans-unit>
        <trans-unit id="f34a87a12fe283ceded3dd1abbd77031338a6cd0" translate="yes" xml:space="preserve">
          <source>When the model has multiple roles, &lt;code&gt;textRole&lt;/code&gt; can be set to determine which role should be displayed.</source>
          <target state="translated">当模型具有多个角色时，可以设置 &lt;code&gt;textRole&lt;/code&gt; 以确定应该显示哪个角色。</target>
        </trans-unit>
        <trans-unit id="da9a781aefd18e2834be4ea55a33a7e98b410511" translate="yes" xml:space="preserve">
          <source>When the model has multiple roles, textRole can be set to determine which role should be displayed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="422c5c92ca52eb6e2a6538c002cc9123999cfea0" translate="yes" xml:space="preserve">
          <source>When the mouse is pressed, the &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; changes to the</source>
          <target state="translated">按下鼠标后，&lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;矩形&lt;/a&gt;变为</target>
        </trans-unit>
        <trans-unit id="5657ede20e143f6d442db18b090e618d804d1de7" translate="yes" xml:space="preserve">
          <source>When the mouse moves over the item,</source>
          <target state="translated">当鼠标移动到该项目上时。</target>
        </trans-unit>
        <trans-unit id="91af59e60e5984086456c7ad2a2054d514962b50" translate="yes" xml:space="preserve">
          <source>When the number of commands on a stack exceedes the stack's undoLimit, commands are deleted from the bottom of the stack. Macro commands (commands with child commands) are treated as one command. The default value is 0, which means that there is no limit.</source>
          <target state="translated">当堆栈上的命令数量超过堆栈的 undoLimit 时,命令将从堆栈底部删除。宏命令(带有子命令的命令)被视为一条命令。默认值为0,这意味着没有限制。</target>
        </trans-unit>
        <trans-unit id="001d63f0ced7bf39910f29efe7f6f5fd05b477ff" translate="yes" xml:space="preserve">
          <source>When the number of matches cannot be determined in advance, a common idiom is to use &lt;a href=&quot;qregexp#cap&quot;&gt;cap&lt;/a&gt;() in a loop. For example:</source>
          <target state="translated">当无法预先确定匹配数时，常见的习惯用法是在循环中使用&lt;a href=&quot;qregexp#cap&quot;&gt;cap&lt;/a&gt;（）。例如：</target>
        </trans-unit>
        <trans-unit id="19d271264efc628bb86bca221e850d0c5cb77458" translate="yes" xml:space="preserve">
          <source>When the object supports multiple selections (e.g. in a word processor), this adds a new selection, otherwise it replaces the previous selection.</source>
          <target state="translated">当对象支持多个选择时(例如在文字处理机中),这将增加一个新的选择,否则它将替换之前的选择。</target>
        </trans-unit>
        <trans-unit id="73cf6131f4a582c72bc9f9330edcb48af4fcc81f" translate="yes" xml:space="preserve">
          <source>When the page is inserted into a wizard using &lt;a href=&quot;qwizard#addPage&quot;&gt;QWizard::addPage&lt;/a&gt;() or &lt;a href=&quot;qwizard#setPage&quot;&gt;QWizard::setPage&lt;/a&gt;(), the parent is automatically set to be the wizard.</source>
          <target state="translated">当使用&lt;a href=&quot;qwizard#addPage&quot;&gt;QWizard :: addPage&lt;/a&gt;（）或&lt;a href=&quot;qwizard#setPage&quot;&gt;QWizard :: setPage&lt;/a&gt;（）将页面插入向导时，父级将自动设置为向导。</target>
        </trans-unit>
        <trans-unit id="35fc6c728ad882d547072f431eb37b1425e9f468" translate="yes" xml:space="preserve">
          <source>When the paint event occurs, the update region has normally been erased, so you are painting on the widget's background.</source>
          <target state="translated">当油漆事件发生时,更新区域通常已被擦除,因此您是在小组件的背景上作画。</target>
        </trans-unit>
        <trans-unit id="f30c7c3f40f1a872547881cd7951c22cee36c1cd" translate="yes" xml:space="preserve">
          <source>When the parameter is set to &lt;a href=&quot;qopengltexture#DepthStencilMode-enum&quot;&gt;DepthMode&lt;/a&gt;, then accessing it from the shader will access the depth component as a single float, as normal. But when the parameter is set to &lt;a href=&quot;qopengltexture#DepthStencilMode-enum&quot;&gt;StencilMode&lt;/a&gt;, the shader will access the stencil component.</source>
          <target state="translated">当参数设置为&lt;a href=&quot;qopengltexture#DepthStencilMode-enum&quot;&gt;DepthMode时&lt;/a&gt;，从着色器对其进行访问将照常作为单个浮点访问深度分量。但是，当参数设置为&lt;a href=&quot;qopengltexture#DepthStencilMode-enum&quot;&gt;StencilMode时&lt;/a&gt;，着色器将访问模板组件。</target>
        </trans-unit>
        <trans-unit id="2375fc19af6a76757eb823a66fb6127ba87e61c2" translate="yes" xml:space="preserve">
          <source>When the parser encounters an error, it signals the event by making &lt;a href=&quot;qurl#isValid&quot;&gt;isValid&lt;/a&gt;() return false and &lt;a href=&quot;qurl#toString&quot;&gt;toString&lt;/a&gt;() / &lt;a href=&quot;qurl#toEncoded&quot;&gt;toEncoded&lt;/a&gt;() return an empty string. If it is necessary to show the user the reason why the URL failed to parse, the error condition can be obtained from &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; by calling &lt;a href=&quot;qurl#errorString&quot;&gt;errorString&lt;/a&gt;(). Note that this message is highly technical and may not make sense to end-users.</source>
          <target state="translated">当解析器遇到错误时，它将通过使&lt;a href=&quot;qurl#isValid&quot;&gt;isValid&lt;/a&gt;（）返回false以及&lt;a href=&quot;qurl#toString&quot;&gt;toString&lt;/a&gt;（）/ &lt;a href=&quot;qurl#toEncoded&quot;&gt;toEncoded&lt;/a&gt;（）返回空字符串来通知事件。如果有必要向用户显示URL解析失败的原因，则可以通过调用&lt;a href=&quot;qurl#errorString&quot;&gt;errorString&lt;/a&gt;（）从&lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt;获取错误条件。请注意，此消息是高度技术性的，对最终用户而言可能没有意义。</target>
        </trans-unit>
        <trans-unit id="811d686f479044d2209c2819d361efa6d361ce38" translate="yes" xml:space="preserve">
          <source>When the parser encounters an error, it signals the event by making &lt;a href=&quot;qurl#isValid&quot;&gt;isValid&lt;/a&gt;() return false and &lt;a href=&quot;qurl#toString&quot;&gt;toString&lt;/a&gt;() / &lt;a href=&quot;qurl#toEncoded&quot;&gt;toEncoded&lt;/a&gt;() return an empty string. If it is necessary to show the user the reason why the URL failed to parse, the error condition can be obtained from QUrl by calling &lt;a href=&quot;qurl#errorString&quot;&gt;errorString&lt;/a&gt;(). Note that this message is highly technical and may not make sense to end-users.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50ba901eeb2daca251dbecc6e227457e431d3835" translate="yes" xml:space="preserve">
          <source>When the player object is buffering; this property holds the percentage of the temporary buffer that is filled. The buffer will need to reach 100% filled before playback can start or resume, at which time &lt;a href=&quot;qmediaplayer#mediaStatus-prop&quot;&gt;mediaStatus&lt;/a&gt;() will return &lt;a href=&quot;qmediaplayer#MediaStatus-enum&quot;&gt;BufferedMedia&lt;/a&gt; or &lt;a href=&quot;qmediaplayer#MediaStatus-enum&quot;&gt;BufferingMedia&lt;/a&gt;. If the value is anything lower than &lt;code&gt;100&lt;/code&gt;, &lt;a href=&quot;qmediaplayer#mediaStatus-prop&quot;&gt;mediaStatus&lt;/a&gt;() will return &lt;a href=&quot;qmediaplayer#MediaStatus-enum&quot;&gt;StalledMedia&lt;/a&gt;.</source>
          <target state="translated">当播放器对象正在缓冲时；此属性保存已填充的临时缓冲区的百分比。在开始或继续播放之前，缓冲区需要达到100％的已满状态，此时&lt;a href=&quot;qmediaplayer#mediaStatus-prop&quot;&gt;mediaStatus&lt;/a&gt;（）将返回&lt;a href=&quot;qmediaplayer#MediaStatus-enum&quot;&gt;BufferedMedia&lt;/a&gt;或&lt;a href=&quot;qmediaplayer#MediaStatus-enum&quot;&gt;BufferingMedia&lt;/a&gt;。如果该值小于 &lt;code&gt;100&lt;/code&gt; ，&lt;a href=&quot;qmediaplayer#mediaStatus-prop&quot;&gt;mediaStatus&lt;/a&gt;（）将返回&lt;a href=&quot;qmediaplayer#MediaStatus-enum&quot;&gt;StalledMedia&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="da64dfb7cefdbeef317abcd7e43d7b305a5ee3ab" translate="yes" xml:space="preserve">
          <source>When the popup actually receives focus, &lt;a href=&quot;qml-qtquick-controls2-popup#activeFocus-prop&quot;&gt;activeFocus&lt;/a&gt; will be &lt;code&gt;true&lt;/code&gt;. For more information, see &lt;a href=&quot;qtquick-input-focus&quot;&gt;Keyboard Focus in Qt Quick&lt;/a&gt;.</source>
          <target state="translated">当弹出窗口实际获得焦点时，&lt;a href=&quot;qml-qtquick-controls2-popup#activeFocus-prop&quot;&gt;activeFocus&lt;/a&gt;将为 &lt;code&gt;true&lt;/code&gt; 。有关更多信息，请参见&lt;a href=&quot;qtquick-input-focus&quot;&gt;Qt Quick中的Keyboard Focus&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d6f2faeb8b71e0aaa953aece87da658ef327fd51" translate="yes" xml:space="preserve">
          <source>When the popup actually receives focus, activeFocus will be &lt;code&gt;true&lt;/code&gt;. For more information, see &lt;a href=&quot;qtquick-input-focus&quot;&gt;Keyboard Focus in Qt Quick&lt;/a&gt;.</source>
          <target state="translated">当弹出窗口实际获得焦点时，activeFocus将为 &lt;code&gt;true&lt;/code&gt; 。有关更多信息，请参见&lt;a href=&quot;qtquick-input-focus&quot;&gt;Qt Quick中的Keyboard Focus&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c1bac0637a72484b23805b1cfc6b209249217f5b" translate="yes" xml:space="preserve">
          <source>When the process exits, &lt;a href=&quot;qprocess&quot;&gt;QProcess&lt;/a&gt; reenters the &lt;a href=&quot;qprocess#ProcessState-enum&quot;&gt;NotRunning&lt;/a&gt; state (the initial state), and emits &lt;a href=&quot;qprocess#finished&quot;&gt;finished&lt;/a&gt;().</source>
          <target state="translated">当处理退出，&lt;a href=&quot;qprocess&quot;&gt;QProcess中&lt;/a&gt;重新进入&lt;a href=&quot;qprocess#ProcessState-enum&quot;&gt;notrunning状态&lt;/a&gt;的状态（初始状态），并发出&lt;a href=&quot;qprocess#finished&quot;&gt;完成&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="166deb4e86216777686c8338ec5e1b04fbb74123" translate="yes" xml:space="preserve">
          <source>When the process exits, QProcess reenters the &lt;a href=&quot;qprocess#ProcessState-enum&quot;&gt;NotRunning&lt;/a&gt; state (the initial state), and emits &lt;a href=&quot;qprocess#finished&quot;&gt;finished&lt;/a&gt;().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48359f3ebe88aa74d829db24de3e755c6a235ddd" translate="yes" xml:space="preserve">
          <source>When the property is &lt;a href=&quot;qt#CursorMoveStyle-enum&quot;&gt;Qt::LogicalMoveStyle&lt;/a&gt; (the default), within a LTR text block, increase cursor position when pressing left arrow key, decrease cursor position when pressing the right arrow key. If the text block is right to left, the opposite behavior applies.</source>
          <target state="translated">当属性为&lt;a href=&quot;qt#CursorMoveStyle-enum&quot;&gt;Qt :: LogicalMoveStyle&lt;/a&gt;（默认值）时，在LTR文本块中，按左箭头键时增加光标位置，按右箭头键时减少光标位置。如果文本块从右到左，则适用相反的行为。</target>
        </trans-unit>
        <trans-unit id="8bce9d7a133b3737e2c5d22d038d7b3c4e7911f8" translate="yes" xml:space="preserve">
          <source>When the property is set to &lt;a href=&quot;qcalendarwidget#SelectionMode-enum&quot;&gt;NoSelection&lt;/a&gt;, the user will be unable to select dates, but they can still be selected programmatically. Note that the date that is selected when the property is set to &lt;a href=&quot;qcalendarwidget#SelectionMode-enum&quot;&gt;NoSelection&lt;/a&gt; will still be the selected date of the calendar.</source>
          <target state="translated">当属性设置为&lt;a href=&quot;qcalendarwidget#SelectionMode-enum&quot;&gt;NoSelection时&lt;/a&gt;，用户将无法选择日期，但仍可以通过编程方式选择日期。请注意，将属性设置为&lt;a href=&quot;qcalendarwidget#SelectionMode-enum&quot;&gt;NoSelection&lt;/a&gt;时选择的日期仍将是日历的选定日期。</target>
        </trans-unit>
        <trans-unit id="1fdcbc355a573b53369d224635c5476baea07222" translate="yes" xml:space="preserve">
          <source>When the property is set to false, these controls are hidden.</source>
          <target state="translated">当该属性设置为false时,这些控件被隐藏。</target>
        </trans-unit>
        <trans-unit id="aa8094b9e2a50ed05d31d86aa20fac7cfb61c508" translate="yes" xml:space="preserve">
          <source>When the renderer reaches a leaf node of the framegraph, it collects together all of the state specified by the path from the leaf node to the root node. This defines the state used to render a section of the frame. If you are interested in the internals of Qt 3D, this collection of state is called a</source>
          <target state="translated">当渲染器到达框架图的叶子节点时,它将叶子节点到根节点的路径所指定的所有状态收集在一起。这定义了用于渲染帧的一部分的状态。如果您对 Qt 3D 的内部结构感兴趣,这个状态集合被称为</target>
        </trans-unit>
        <trans-unit id="db214d0296a6a87ece4578bc42783f851f457093" translate="yes" xml:space="preserve">
          <source>When the request is processed and a reply is available, it should be sent using the &lt;code&gt;QDBusMessage&lt;/code&gt; object that was obtained. In our example, the reply code could be something as follows:</source>
          <target state="translated">处理请求并提供答复后，应使用获取的 &lt;code&gt;QDBusMessage&lt;/code&gt; 对象发送该请求。在我们的示例中，回复代码可能如下所示：</target>
        </trans-unit>
        <trans-unit id="53d591cc65e5ee2ed7378bddbef5b69a1bcfde7b" translate="yes" xml:space="preserve">
          <source>When the results of an &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; are returned in a sequence of &lt;a href=&quot;qxmlresultitems&quot;&gt;result items&lt;/a&gt;, atomic values in the sequence are treated as instances of &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt;. Suppose that instead of serializing the results of the &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; as XML, we process the results programatically. Modify the standard Qt XML Patterns code sequence to call the overload of &lt;a href=&quot;qxmlquery#evaluateTo&quot;&gt;QXmlQuery::evaluateTo&lt;/a&gt;() that populates a sequence of &lt;a href=&quot;qxmlresultitems&quot;&gt;result items&lt;/a&gt; with the &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; results:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="351834125e0c92d0f208676bc4e74950d662675c" translate="yes" xml:space="preserve">
          <source>When the results of an XQuery are returned in a sequence of &lt;a href=&quot;qxmlresultitems&quot;&gt;result items&lt;/a&gt;, atomic values in the sequence are treated as instances of &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt;. Suppose that instead of serializing the results of the XQuery as XML, we process the results programatically. Modify the standard Qt XML Patterns code sequence to call the overload of &lt;a href=&quot;qxmlquery#evaluateTo&quot;&gt;QXmlQuery::evaluateTo&lt;/a&gt;() that populates a sequence of &lt;a href=&quot;qxmlresultitems&quot;&gt;result items&lt;/a&gt; with the XQuery results:</source>
          <target state="translated">当XQuery的结果在&lt;a href=&quot;qxmlresultitems&quot;&gt;结果项&lt;/a&gt;序列中返回时，该序列中的原子值被视为&lt;a href=&quot;qvariant&quot;&gt;QVariant的&lt;/a&gt;实例。假设我们没有以编程方式处理结果，而不是将XQuery的结果序列化为XML。修改标准的Qt XML模式代码序列以调用&lt;a href=&quot;qxmlquery#evaluateTo&quot;&gt;QXmlQuery :: evaluateTo&lt;/a&gt;（）的重载，该重载用XQuery结果填充&lt;a href=&quot;qxmlresultitems&quot;&gt;结果项&lt;/a&gt;序列：</target>
        </trans-unit>
        <trans-unit id="763552f30b01b66449cf8883bed75293d360c6fc" translate="yes" xml:space="preserve">
          <source>When the return value is &lt;code&gt;false&lt;/code&gt;, vertex array object support is not available. This is not an error: on systems with OpenGL 2.x or OpenGL ES 2.0 vertex array objects may not be supported. The application is free to continue execution in this case, but it then has to be prepared to operate in a VAO-less manner too. This means that instead of merely calling &lt;a href=&quot;qopenglvertexarrayobject#bind&quot;&gt;bind&lt;/a&gt;(), the value of &lt;a href=&quot;qopenglvertexarrayobject#isCreated&quot;&gt;isCreated&lt;/a&gt;() must be checked and the vertex arrays has to be initialized in the traditional way when there is no vertex array object present.</source>
          <target state="translated">当返回值为 &lt;code&gt;false&lt;/code&gt; 时，不支持顶点数组对象。这不是错误：在带有OpenGL 2.x或OpenGL ES 2.0顶点数组对象的系统上，可能不支持此功能。在这种情况下，应用程序可以自由地继续执行，但是随后还必须准备以无VAO的方式运行。这意味着必须检查&lt;a href=&quot;qopenglvertexarrayobject#isCreated&quot;&gt;isCreated&lt;/a&gt;（）的值，而不仅仅是调用&lt;a href=&quot;qopenglvertexarrayobject#bind&quot;&gt;bind&lt;/a&gt;（），并且当不存在顶点数组对象时，必须以传统方式初始化顶点数组。</target>
        </trans-unit>
        <trans-unit id="446681578342ec9dac4cdce0d061b46969bca33b" translate="yes" xml:space="preserve">
          <source>When the run type is set to Manual, calling trigger will make the compute command be executed for the next</source>
          <target state="translated">当运行类型设置为手动时,调用触发器将使计算命令在下一次运行时被执行。</target>
        </trans-unit>
        <trans-unit id="cbc6fc235d0cf1450284a0b09b674e76a1fb4c28" translate="yes" xml:space="preserve">
          <source>When the sample count is greater than 1, &lt;a href=&quot;qvulkanwindow&quot;&gt;QVulkanWindow&lt;/a&gt; will create a multisample color buffer instead of simply targeting the swapchain's images. The rendering in the multisample buffer will get resolved into the non-multisample buffers at the end of each frame.</source>
          <target state="translated">当样本数量大于1时，&lt;a href=&quot;qvulkanwindow&quot;&gt;QVulkanWindow&lt;/a&gt;将创建一个多样本颜色缓冲区，而不是简单地针对交换链的图像。多样本缓冲区中的渲染将在每个帧的末尾解析为非多样本缓冲区。</target>
        </trans-unit>
        <trans-unit id="a0108434fca29b4ba915f772a93d81ad894fc73c" translate="yes" xml:space="preserve">
          <source>When the scene graph processes the request, it will call &lt;a href=&quot;qquickitem#updatePolish&quot;&gt;updatePolish&lt;/a&gt;() on this item.</source>
          <target state="translated">当场景图处理请求时，它将对此项目调用&lt;a href=&quot;qquickitem#updatePolish&quot;&gt;updatePolish&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="79ad0782b661b14989a03456b369b188f17379b0" translate="yes" xml:space="preserve">
          <source>When the scene is active, this functions returns the scene's current focus item, or &lt;code&gt;nullptr&lt;/code&gt; if no item currently has focus. When the scene is inactive, this functions returns the item that will gain input focus when the scene becomes active.</source>
          <target state="translated">当场景处于活动状态时，此函数返回场景的当前焦点项；如果当前没有焦点，则返回 &lt;code&gt;nullptr&lt;/code&gt; 。当场景处于非活动状态时，此函数返回在场景变为活动状态时将获得输入焦点的项目。</target>
        </trans-unit>
        <trans-unit id="9df9de9d839910e5f63e81af88c3113617106dce" translate="yes" xml:space="preserve">
          <source>When the scene is rendered, any item whose width or height, transformed to the target view, is smaller that minimumRenderSize(), will not be rendered. If an item is not rendered and it clips its children items they will also not be rendered. Set this value to speed up rendering of scenes with many objects rendered on a zoomed out view.</source>
          <target state="translated">当场景被渲染时,任何项目的宽度或高度,转换到目标视图后,如果小于最小渲染尺寸(),将不会被渲染。如果一个项目没有被渲染,并且它剪辑了它的子项目,它们也不会被渲染。设置这个值可以加快在放大视图上渲染许多对象的场景的渲染速度。</target>
        </trans-unit>
        <trans-unit id="0a43ef95854a2f8ebe7bf8d74d52b1e7933022c7" translate="yes" xml:space="preserve">
          <source>When the script has been executed,</source>
          <target state="translated">当脚本被执行后。</target>
        </trans-unit>
        <trans-unit id="d413663e989f70315f8c202cae18ed2f762ace07" translate="yes" xml:space="preserve">
          <source>When the scroll bars change value, we need to update the widget position, i.e., find the part of the widget that is to be drawn in the viewport:</source>
          <target state="translated">当滚动条的数值发生变化时,我们需要更新widget的位置,即找到widget在视口中要绘制的部分。</target>
        </trans-unit>
        <trans-unit id="7e550de4fcd183b4278cd6cc624e2d0424a701cc" translate="yes" xml:space="preserve">
          <source>When the selected test users that you have added to your alpha or beta program purchase in-app products in your application, they will make actual purchases and will be charged for them. For testing purchases, you can register the e-mail addresses that should have testing access, under &lt;b&gt;Settings&lt;/b&gt; in the developer console. The users with these e-mail addresses can purchase your in-app products without being charged for the purchase, and the transaction is canceled automatically at a later stage.</source>
          <target state="translated">当您添加到Alpha或Beta计划中的所选测试用户购买了应用程序中的应用内商品时，他们将进行实际购买并向他们收费。对于测试购买，您可以在开发者控制台的&lt;b&gt;&amp;ldquo;设置&amp;rdquo;&lt;/b&gt;下注册应该具有测试访问权限的电子邮件地址。具有这些电子邮件地址的用户可以购买您的应用内商品，而无需支付购买费用，并且交易会在以后自动取消。</target>
        </trans-unit>
        <trans-unit id="afec543fcd1da24c4160336959d91fe3f583bac8" translate="yes" xml:space="preserve">
          <source>When the selection changes and the dialog is accepted, this signal is emitted with the (possibly empty) list of selected</source>
          <target state="translated">当选择发生变化,对话框被接受时,这个信号与所选的(可能是空的)列表一起发出。</target>
        </trans-unit>
        <trans-unit id="904758544b0861950c3ab2beb21af5f0d9b36272" translate="yes" xml:space="preserve">
          <source>When the selection changes and the dialog is accepted, this signal is emitted with the (possibly empty) selected</source>
          <target state="translated">当选择发生变化,对话框被接受时,这个信号与所选的(可能是空的)对象一起发出。</target>
        </trans-unit>
        <trans-unit id="e7de7d16009452344b6e4636a059a260b420895c" translate="yes" xml:space="preserve">
          <source>When the selection changes for local operations and the dialog is accepted, this signal is emitted with the (possibly empty) list of</source>
          <target state="translated">当本地操作的选择发生变化,并且对话框被接受时,这个信号发出的(可能是空的)列表中的</target>
        </trans-unit>
        <trans-unit id="f75edcab2adacd739be3bdebfa6bfa280edf2de0" translate="yes" xml:space="preserve">
          <source>When the selection changes for local operations and the dialog is accepted, this signal is emitted with the (possibly empty) selected</source>
          <target state="translated">当本地操作的选择发生变化,且对话框被接受时,发出该信号,所选的(可能为空)。</target>
        </trans-unit>
        <trans-unit id="5131d672b1bc3aac6ebdcf6c8b2ac57826b0e767" translate="yes" xml:space="preserve">
          <source>When the selection mode changes and the selected item is visible</source>
          <target state="translated">当选择模式发生变化,所选项目可见时。</target>
        </trans-unit>
        <trans-unit id="31520c42359fb2cf1348100dd78b79ebb3e7ffdd" translate="yes" xml:space="preserve">
          <source>When the sensor is started with buffering option, values are collected from that moment onwards. There is no pre-existing buffer that can be utilized.</source>
          <target state="translated">当传感器以缓冲选项启动时,从那一刻开始收集值。没有预先存在的缓冲区可以利用。</target>
        </trans-unit>
        <trans-unit id="ce0fb53c6b17959f1dc8d1d19b6e99cbdbd76451" translate="yes" xml:space="preserve">
          <source>When the server receives the ClientHello message with a cookie, it generates a new cookie as described above. This new cookie is compared to the one found in the ClientHello message.</source>
          <target state="translated">当服务器接收到带有cookie的ClientHello消息时,它会生成一个新的cookie,如上所述。这个新的cookie会与ClientHello消息中发现的cookie进行比较。</target>
        </trans-unit>
        <trans-unit id="f10b8edd85c55e75835eb4536f6583dfa1033451" translate="yes" xml:space="preserve">
          <source>When the service that this method call is sent to is already running, the method call is sent to it. If the service is not running yet, the D-Bus daemon is requested to autostart the service that is assigned to this service name. This is handled by .service files that are placed in a directory known to the D-Bus server. These files then each contain a service name and the path to a program that should be executed when this service name is requested.</source>
          <target state="translated">当这个方法调用所要发送的服务已经在运行时,方法调用就会被发送到它。如果服务还没有运行,则要求D-Bus守护进程自动启动分配给这个服务名的服务。这是由.service文件来处理的,这些文件被放置在D-Bus服务器已知的目录中。然后,这些文件都包含一个服务名和一个程序的路径,当这个服务名被请求时,这个程序应该被执行。</target>
        </trans-unit>
        <trans-unit id="c0cd1279176cf81f0c6aca038bccf60c5d81a29f" translate="yes" xml:space="preserve">
          <source>When the shader program is used normally, the shader program's id will be created on demand.</source>
          <target state="translated">正常使用shader程序时,shader程序的id会按需创建。</target>
        </trans-unit>
        <trans-unit id="a62f09dbef147b4bf1f669c8ce754ebe864f003f" translate="yes" xml:space="preserve">
          <source>When the signal associated with this signal transition is emitted the guard condition is evaluated. In the guard condition the arguments of the signal can be used as demonstrated in the example below.</source>
          <target state="translated">当与该信号转换相关的信号发出时,将评估防护条件。在保护条件中,可以使用信号的参数,如下例所示。</target>
        </trans-unit>
        <trans-unit id="558725310a73c041dc3d4a5f9bb58e65f3b99606" translate="yes" xml:space="preserve">
          <source>When the signal is emitted, the &lt;a href=&quot;qabstractslider#sliderPosition-prop&quot;&gt;sliderPosition&lt;/a&gt; has been adjusted according to the action, but the &lt;a href=&quot;qabstractslider#value-prop&quot;&gt;value&lt;/a&gt; has not yet been propagated (meaning the &lt;a href=&quot;qabstractslider#valueChanged&quot;&gt;valueChanged&lt;/a&gt;() signal was not yet emitted), and the visual display has not been updated. In slots connected to this signal you can thus safely adjust any action by calling &lt;a href=&quot;qabstractslider#sliderPosition-prop&quot;&gt;setSliderPosition&lt;/a&gt;() yourself, based on both the action and the slider's value.</source>
          <target state="translated">发出信号时，已根据操作调整了&lt;a href=&quot;qabstractslider#sliderPosition-prop&quot;&gt;sliderPosition&lt;/a&gt;，但尚未传播该&lt;a href=&quot;qabstractslider#value-prop&quot;&gt;值&lt;/a&gt;（这意味着尚未发出&lt;a href=&quot;qabstractslider#valueChanged&quot;&gt;valueChanged&lt;/a&gt;（）信号），并且视觉显示尚未更新。因此，在与此信号连接的插槽中，您可以根据动作和滑块的值自己调用&lt;a href=&quot;qabstractslider#sliderPosition-prop&quot;&gt;setSliderPosition&lt;/a&gt;（）来安全地调整任何动作。</target>
        </trans-unit>
        <trans-unit id="908f9032f0a18c7bfa32894d77bc808328603452" translate="yes" xml:space="preserve">
          <source>When the source and target areas' sizes do not match, the source contents are stretched to fit into the target area. By passing a &lt;a href=&quot;qt#AspectRatioMode-enum&quot;&gt;Qt::AspectRatioMode&lt;/a&gt; to the rendering function you are using, you can choose to maintain or ignore the aspect ratio of the scene when the contents are stretched.</source>
          <target state="translated">当源区域和目标区域的大小不匹配时，将拉伸源内容以适合目标区域。通过将&lt;a href=&quot;qt#AspectRatioMode-enum&quot;&gt;Qt :: AspectRatioMode&lt;/a&gt;传递给正在使用的渲染功能，可以选择在拉伸内容时保持或忽略场景的宽高比。</target>
        </trans-unit>
        <trans-unit id="8b00e9d3dd0cfb3eafd24644444bab1097364474" translate="yes" xml:space="preserve">
          <source>When the source is static, the &lt;a href=&quot;qml-qtgraphicaleffects-dropshadow#cached-prop&quot;&gt;cached&lt;/a&gt; property can be set to allocate another buffer to avoid performing the blur every time it is drawn.</source>
          <target state="translated">当源是静态的时，可以将&lt;a href=&quot;qml-qtgraphicaleffects-dropshadow#cached-prop&quot;&gt;cached&lt;/a&gt;属性设置为分配另一个缓冲区，以避免在每次绘制时执行模糊。</target>
        </trans-unit>
        <trans-unit id="3ad8f5ada47559d8d884af8a03a452189fd6075c" translate="yes" xml:space="preserve">
          <source>When the space key is pressed, adding an item to the model, the new item will fade in and increase in scale over 400 milliseconds as it is added to the view. Also, any item that is displaced by the addition of a new item will animate to its new position in the view over 400 milliseconds, as specified by the &lt;code&gt;displaced&lt;/code&gt; transition.</source>
          <target state="translated">当按下空格键，向模型中添加一个项目时，新项目将淡入并随着添加到视图中而在400毫秒内按比例增加。同样，通过添加新项目而被替换的任何项目将在400毫秒内动画化其视图中的新位置，这由被 &lt;code&gt;displaced&lt;/code&gt; 过渡指定。</target>
        </trans-unit>
        <trans-unit id="a9fca68b12abe757685e2f8e3f26bf8a64e1d4fe" translate="yes" xml:space="preserve">
          <source>When the space key is pressed, three items are moved from index 5 to index 1. For each moved item, the &lt;code&gt;moveTransition&lt;/code&gt; sequence presumably animates the item's color to &quot;yellow&quot;, then animates it to its final position, then changes the item color back to &quot;lightsteelblue&quot; using a &lt;a href=&quot;qml-qtquick-scriptaction&quot;&gt;ScriptAction&lt;/a&gt;. However, when run, the transition does not produce the intended result:</source>
          <target state="translated">当按下空格键时，三个项目从索引5移到索引1。对于每个移动的项目， &lt;code&gt;moveTransition&lt;/code&gt; 序列大概将其颜色设置为&amp;ldquo;黄色&amp;rdquo;，然后将其设置为最终位置，然后将其更改回原来的颜色。使用&lt;a href=&quot;qml-qtquick-scriptaction&quot;&gt;ScriptAction&lt;/a&gt;来&amp;ldquo; lightsteelblue&amp;rdquo; 。但是，运行时，过渡不会产生预期的结果：</target>
        </trans-unit>
        <trans-unit id="aed377e3125e7efb3e464b02103995ebd5fa07a4" translate="yes" xml:space="preserve">
          <source>When the string is not already a valid URL, a best guess is performed, making various web related assumptions.</source>
          <target state="translated">当该字符串不是有效的URL时,会进行最佳猜测,做出各种网络相关的假设。</target>
        </trans-unit>
        <trans-unit id="8b456c366b0bedadf7f4c24ff98787915a0f574f" translate="yes" xml:space="preserve">
          <source>When the text changes the &lt;a href=&quot;qlineedit#textChanged&quot;&gt;textChanged&lt;/a&gt;() signal is emitted; when the text changes other than by calling &lt;a href=&quot;qlineedit#text-prop&quot;&gt;setText&lt;/a&gt;() the &lt;a href=&quot;qlineedit#textEdited&quot;&gt;textEdited&lt;/a&gt;() signal is emitted; when the cursor is moved the &lt;a href=&quot;qlineedit#cursorPositionChanged&quot;&gt;cursorPositionChanged&lt;/a&gt;() signal is emitted; and when the Return or Enter key is pressed the &lt;a href=&quot;qlineedit#returnPressed&quot;&gt;returnPressed&lt;/a&gt;() signal is emitted.</source>
          <target state="translated">当文本更改时，将发出&lt;a href=&quot;qlineedit#textChanged&quot;&gt;textChanged&lt;/a&gt;（）信号；当文本不是通过调用&lt;a href=&quot;qlineedit#text-prop&quot;&gt;setText&lt;/a&gt;（）进行更改时，将发出&lt;a href=&quot;qlineedit#textEdited&quot;&gt;textEdited&lt;/a&gt;（）信号；当光标移动时，会发出&lt;a href=&quot;qlineedit#cursorPositionChanged&quot;&gt;cursorPositionChanged&lt;/a&gt;（）信号；当按下Return或Enter键时，将返回&lt;a href=&quot;qlineedit#returnPressed&quot;&gt;returnPressed&lt;/a&gt;（）信号。</target>
        </trans-unit>
        <trans-unit id="76aa286a7763afdcffbd10ec6e5b9d39bd8e0eec" translate="yes" xml:space="preserve">
          <source>When the texture coordinate is even, only the fractional part is used. When odd, the texture coordinate is set to &lt;code&gt;1 - fractional part&lt;/code&gt;. This value has been introduced in Qt 5.10.</source>
          <target state="translated">当纹理坐标为偶数时，仅使用小数部分。当为奇数时，纹理坐标设置为 &lt;code&gt;1 - fractional part&lt;/code&gt; 。此值已在Qt 5.10中引入。</target>
        </trans-unit>
        <trans-unit id="4630c4b073fe0b95c546ea9b15793119393a3a9b" translate="yes" xml:space="preserve">
          <source>When the thread is terminated, all threads waiting for the thread to finish will be woken up.</source>
          <target state="translated">当线程被终止时,所有等待线程结束的线程将被唤醒。</target>
        </trans-unit>
        <trans-unit id="87fd2e26c464b557c4a3c28bad0e013a2a60bdaf" translate="yes" xml:space="preserve">
          <source>When the timeline is disabled, all items will have their regular values. When the timeline is enabled, the values of items are determined by the current frame and the keyframes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8b9c7726d3aff7845aa848c6697f0885c506e1a" translate="yes" xml:space="preserve">
          <source>When the title bar is vertical, the &lt;a href=&quot;#vertical-ps&quot;&gt;:vertical&lt;/a&gt; pseudo class is set. In addition, depending on &lt;a href=&quot;qdockwidget#DockWidgetFeature-enum&quot;&gt;QDockWidget::DockWidgetFeature&lt;/a&gt;, the &lt;a href=&quot;#closable-ps&quot;&gt;:closable&lt;/a&gt;, &lt;a href=&quot;#floatable-ps&quot;&gt;:floatable&lt;/a&gt; and &lt;a href=&quot;#movable-ps&quot;&gt;:movable&lt;/a&gt; pseudo states are set.</source>
          <target state="translated">当标题栏为垂直时，将设置&lt;a href=&quot;#vertical-ps&quot;&gt;：vertical&lt;/a&gt;伪类。另外，根据&lt;a href=&quot;qdockwidget#DockWidgetFeature-enum&quot;&gt;QDockWidget :: DockWidgetFeature&lt;/a&gt;，设置&lt;a href=&quot;#closable-ps&quot;&gt;：&lt;/a&gt;closesable，&lt;a href=&quot;#floatable-ps&quot;&gt;：floatable&lt;/a&gt;和&lt;a href=&quot;#movable-ps&quot;&gt;：movable&lt;/a&gt;伪状态。</target>
        </trans-unit>
        <trans-unit id="dcbf714b2e65ae5994ea2abb0210ddd12a11925f" translate="yes" xml:space="preserve">
          <source>When the title bar is vertical, the &lt;a href=&quot;stylesheet-reference#vertical-ps&quot;&gt;:vertical&lt;/a&gt; pseudo class is set. In addition, depending on &lt;a href=&quot;qdockwidget#DockWidgetFeature-enum&quot;&gt;QDockWidget::DockWidgetFeature&lt;/a&gt;, the &lt;a href=&quot;stylesheet-reference#closable-ps&quot;&gt;:closable&lt;/a&gt;, &lt;a href=&quot;stylesheet-reference#floatable-ps&quot;&gt;:floatable&lt;/a&gt; and &lt;a href=&quot;stylesheet-reference#movable-ps&quot;&gt;:movable&lt;/a&gt; pseudo states are set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf6a38dec8a46a3efde082aa9bb646234ab5665d" translate="yes" xml:space="preserve">
          <source>When the traceEnd method is called, the input method may begin processing of the data contained in the trace object. After processing the data, the input method should destroy the object. This also removes the trace rendered to the screen.</source>
          <target state="translated">当调用traceEnd方法时,输入方法可以开始处理跟踪对象中包含的数据。在处理完数据后,输入方法应该销毁该对象。这也就删除了渲染到屏幕上的跟踪对象。</target>
        </trans-unit>
        <trans-unit id="5ed406ff23fcc29a091f1169edcf6e63e1f2b5ea" translate="yes" xml:space="preserve">
          <source>When the transition is initialized, the &lt;a href=&quot;qml-qtquick-propertyaction&quot;&gt;PropertyAction&lt;/a&gt;&lt;code&gt;target&lt;/code&gt; will be set to the respective &lt;a href=&quot;qml-qtquick-viewtransition&quot;&gt;ViewTransition&lt;/a&gt;.item for the transition and will later run with the correct item target as expected.</source>
          <target state="translated">初始化过渡后，&lt;a href=&quot;qml-qtquick-propertyaction&quot;&gt;PropertyAction &lt;/a&gt; &lt;code&gt;target&lt;/code&gt; 将设置为过渡的相应&lt;a href=&quot;qml-qtquick-viewtransition&quot;&gt;ViewTransition&lt;/a&gt; .item，然后将按预期使用正确的项目目标运行。</target>
        </trans-unit>
        <trans-unit id="a112026d8a84f01ac36a7325fb20f0691ad743ce" translate="yes" xml:space="preserve">
          <source>When the transition is initialized, the &lt;a href=&quot;qml-qtquick-propertyaction&quot;&gt;PropertyAction&lt;/a&gt;&lt;code&gt;target&lt;/code&gt; will be set to the respective ViewTransition.item for the transition and will later run with the correct item target as expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61999efc5174872ead16b86264178dba1fb54b01" translate="yes" xml:space="preserve">
          <source>When the transition starts, the &lt;a href=&quot;qml-qtquick-controls-stackview&quot;&gt;StackView&lt;/a&gt; will search for a transition that matches the operation executed. There are three transitions to choose from: &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#pushTransition-prop&quot;&gt;pushTransition&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#popTransition-prop&quot;&gt;popTransition&lt;/a&gt;, and &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#replaceTransition-prop&quot;&gt;replaceTransition&lt;/a&gt;. Each implements how &lt;code&gt;enterItem&lt;/code&gt; should animate in, and &lt;code&gt;exitItem&lt;/code&gt; out. The transitions are collected inside a &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate&quot;&gt;StackViewDelegate&lt;/a&gt; object assigned to &lt;a href=&quot;qml-qtquick-controls-stackview#delegate-prop&quot;&gt;delegate&lt;/a&gt;. By default, popTransition and replaceTransition will be the same as pushTransition, unless you set them to something else.</source>
          <target state="translated">过渡开始时，&lt;a href=&quot;qml-qtquick-controls-stackview&quot;&gt;StackView&lt;/a&gt;将搜索与执行的操作匹配的过渡。有三种转换可供选择：&lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#pushTransition-prop&quot;&gt;pushTransition&lt;/a&gt;，&lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#popTransition-prop&quot;&gt;popTransition&lt;/a&gt;和&lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#replaceTransition-prop&quot;&gt;replaceTransition&lt;/a&gt;。每个工具如何 &lt;code&gt;enterItem&lt;/code&gt; 应该在动画和 &lt;code&gt;exitItem&lt;/code&gt; 出来。转换收集在分配给&lt;a href=&quot;qml-qtquick-controls-stackview#delegate-prop&quot;&gt;委托&lt;/a&gt;的&lt;a href=&quot;qml-qtquick-controls-stackviewdelegate&quot;&gt;StackViewDelegate&lt;/a&gt;对象内。默认情况下，除非您将popTransition和replaceTransition设置为其他值，否则它们将与pushTransition相同。</target>
        </trans-unit>
        <trans-unit id="b481fca32b65e43470c3c94e4e0c2377f104c54a" translate="yes" xml:space="preserve">
          <source>When the transition starts, the StackView will search for a transition that matches the operation executed. There are three transitions to choose from: &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#pushTransition-prop&quot;&gt;pushTransition&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#popTransition-prop&quot;&gt;popTransition&lt;/a&gt;, and &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#replaceTransition-prop&quot;&gt;replaceTransition&lt;/a&gt;. Each implements how &lt;code&gt;enterItem&lt;/code&gt; should animate in, and &lt;code&gt;exitItem&lt;/code&gt; out. The transitions are collected inside a &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate&quot;&gt;StackViewDelegate&lt;/a&gt; object assigned to &lt;a href=&quot;qml-qtquick-controls-stackview#delegate-prop&quot;&gt;delegate&lt;/a&gt;. By default, popTransition and replaceTransition will be the same as pushTransition, unless you set them to something else.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89b086c5ef03dd1208f5e9b3c1c02fa2b6600cb5" translate="yes" xml:space="preserve">
          <source>When the type is &lt;code&gt;LineString&lt;/code&gt; the data ia a &lt;a href=&quot;qgeopath&quot;&gt;QGeoPath&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6627a2ffbe714cf5363a2179e7f88f8aa52c1d77" translate="yes" xml:space="preserve">
          <source>When the type is &lt;code&gt;MultiLineString&lt;/code&gt;, the data is a List of LineStrings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f684debed13b1e187fdab34246a351f68171025c" translate="yes" xml:space="preserve">
          <source>When the type is &lt;code&gt;MultiPoint&lt;/code&gt;, the data is a List of Points.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65efa0e33ec24ae86c53c350f1ee9d661694a7b1" translate="yes" xml:space="preserve">
          <source>When the type is &lt;code&gt;MultiPolygon&lt;/code&gt;, the data is a List of Polygons.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbc2b0b0072c28b487940a65dedc17930539d2ec" translate="yes" xml:space="preserve">
          <source>When the type is &lt;code&gt;Point&lt;/code&gt;, the data is a &lt;a href=&quot;qgeocircle&quot;&gt;QGeoCircle&lt;/a&gt; with the point coordinates stored in the center property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23332dc4a0d7fb448b924e422877dc966cb8e77a" translate="yes" xml:space="preserve">
          <source>When the type is &lt;code&gt;Polygon&lt;/code&gt;, the data is a &lt;a href=&quot;qgeopolygon&quot;&gt;QGeoPolygon&lt;/a&gt; (holes are supported).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37e47c478e8b7cde10b9e2d57a87561d517265a6" translate="yes" xml:space="preserve">
          <source>When the underlying rendering API is OpenGL, this function should return a mask where each bit represents graphics states changed by the &lt;a href=&quot;qsgrendernode#render&quot;&gt;render&lt;/a&gt;() function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3151bd80e155cc711d1dfb4c28d12fa02d1b602b" translate="yes" xml:space="preserve">
          <source>When the update behavior is set to &lt;code&gt;NoPartialUpdate&lt;/code&gt;, there is no separate framebuffer object. In this case the returned value is the ID of the default framebuffer.</source>
          <target state="translated">将更新行为设置为 &lt;code&gt;NoPartialUpdate&lt;/code&gt; 时，没有单独的帧缓冲区对象。在这种情况下，返回值是默认帧缓冲区的ID。</target>
        </trans-unit>
        <trans-unit id="38a70a3f9388a6d25db9221a160c7eb74efac68f" translate="yes" xml:space="preserve">
          <source>When the update mode is set to &lt;a href=&quot;qopenglwindow#UpdateBehavior-enum&quot;&gt;NoPartialUpdate&lt;/a&gt;, there is no difference between this function and &lt;a href=&quot;qopenglwindow#paintGL&quot;&gt;paintGL&lt;/a&gt;(), performing rendering in either of them leads to the same result.</source>
          <target state="translated">当更新模式设置为&lt;a href=&quot;qopenglwindow#UpdateBehavior-enum&quot;&gt;NoPartialUpdate时&lt;/a&gt;，此函数和&lt;a href=&quot;qopenglwindow#paintGL&quot;&gt;paintGL&lt;/a&gt;（）之间没有区别，在它们两者中执行渲染都会导致相同的结果。</target>
        </trans-unit>
        <trans-unit id="90a4d8b7976d6357d0d51104a651d5693a247b6e" translate="yes" xml:space="preserve">
          <source>When the update mode is set to &lt;code&gt;NoPartialUpdate&lt;/code&gt;, there is no difference between this function and &lt;a href=&quot;qopenglwindow#paintGL&quot;&gt;paintGL&lt;/a&gt;(), performing rendering in either of them leads to the same result.</source>
          <target state="translated">当更新模式设置为 &lt;code&gt;NoPartialUpdate&lt;/code&gt; 时，此函数和&lt;a href=&quot;qopenglwindow#paintGL&quot;&gt;paintGL&lt;/a&gt;（）之间没有区别，在它们两者中执行渲染都会导致相同的结果。</target>
        </trans-unit>
        <trans-unit id="7fbf049a32dd0640f6dd43ed769625f8cee33a4d" translate="yes" xml:space="preserve">
          <source>When the user attempts to close a window, the &lt;a href=&quot;qml-qtquick-window-window#closing-signal&quot;&gt;closing&lt;/a&gt; signal will be emitted. You can force the window to stay open (for example to prompt the user to save changes) by writing an &lt;code&gt;onClosing&lt;/code&gt; handler and setting &lt;code&gt;close.accepted = false&lt;/code&gt;.</source>
          <target state="translated">当用户试图关闭窗户时，将发出&lt;a href=&quot;qml-qtquick-window-window#closing-signal&quot;&gt;关闭&lt;/a&gt;信号。您可以通过编写 &lt;code&gt;onClosing&lt;/code&gt; 处理程序并设置 &lt;code&gt;close.accepted = false&lt;/code&gt; 来强制窗口保持打开状态（例如，提示用户保存更改）。</target>
        </trans-unit>
        <trans-unit id="f089242c4828bfa1c4990e6f2f452f8aa6f68fa8" translate="yes" xml:space="preserve">
          <source>When the user clicks anywhere within the rectangle, &lt;code&gt;sendMessage()&lt;/code&gt; is called, triggering the &lt;code&gt;WorkerScript.onMessage()&lt;/code&gt; handler in &lt;code&gt;script.mjs&lt;/code&gt;. This in turn sends a reply message that is then received by the &lt;code&gt;onMessage()&lt;/code&gt; handler of &lt;code&gt;myWorker&lt;/code&gt;.</source>
          <target state="translated">当用户的矩形范围内的任何地方点击， &lt;code&gt;sendMessage()&lt;/code&gt; 被调用时，触发 &lt;code&gt;WorkerScript.onMessage()&lt;/code&gt; 中的处理程序 &lt;code&gt;script.mjs&lt;/code&gt; 。依次发送一个回复消息，然后由 &lt;code&gt;myWorker&lt;/code&gt; 的 &lt;code&gt;onMessage()&lt;/code&gt; 处理程序接收该消息。</target>
        </trans-unit>
        <trans-unit id="9e806fe43114f8c1140dcea68026addc98aa8292" translate="yes" xml:space="preserve">
          <source>When the user enters a new string in an editable combobox, the widget may or may not insert it, and it can insert it in several locations. The default policy is &lt;a href=&quot;qcombobox#InsertPolicy-enum&quot;&gt;InsertAtBottom&lt;/a&gt; but you can change this using &lt;a href=&quot;qcombobox#insertPolicy-prop&quot;&gt;setInsertPolicy&lt;/a&gt;().</source>
          <target state="translated">当用户在可编辑的组合框中输入新字符串时，该窗口小部件可能会插入也可能不会插入，并且可以将其插入多个位置。默认策略是&lt;a href=&quot;qcombobox#InsertPolicy-enum&quot;&gt;InsertAtBottom，&lt;/a&gt;但是您可以使用&lt;a href=&quot;qcombobox#insertPolicy-prop&quot;&gt;setInsertPolicy&lt;/a&gt;（）进行更改。</target>
        </trans-unit>
        <trans-unit id="7a33c93bf7f01a0e67730291d39734d96a1a1c84" translate="yes" xml:space="preserve">
          <source>When the user has finished editing the value in the spin box, the view asks the delegate to store the edited value in the model by calling the &lt;a href=&quot;qabstractitemdelegate#setModelData&quot;&gt;setModelData()&lt;/a&gt; function.</source>
          <target state="translated">当用户完成在旋转框中的值编辑后，视图通过调用&lt;a href=&quot;qabstractitemdelegate#setModelData&quot;&gt;setModelData（）&lt;/a&gt;函数要求委托将已编辑的值存储在模型中。</target>
        </trans-unit>
        <trans-unit id="92fa0779d8d3b6243f1940a69448d7de41b9ecd3" translate="yes" xml:space="preserve">
          <source>When the user presses or releases a key, the following occurs:</source>
          <target state="translated">当用户按下或松开某个键时,会发生以下情况。</target>
        </trans-unit>
        <trans-unit id="0593af2ddbf4e80d0b0321de8e5024100fcd08c9" translate="yes" xml:space="preserve">
          <source>When the user presses the first key on a keyboard, an input context is created. This input context will contain a string of the typed characters.</source>
          <target state="translated">当用户按下键盘上的第一个键时,一个输入上下文会被创建。这个输入上下文将包含一个输入字符的字符串。</target>
        </trans-unit>
        <trans-unit id="17b14a687e250bb8ebffd69d26cedf3fe0182667" translate="yes" xml:space="preserve">
          <source>When the user presses the shortcut key indicated by this label, the keyboard focus is transferred to the label's buddy widget.</source>
          <target state="translated">当用户按下该标签所指示的快捷键时,键盘焦点会转移到该标签的好友小部件上。</target>
        </trans-unit>
        <trans-unit id="d8718161543f49d12ebfce2a24d45c7fc9cbd16e" translate="yes" xml:space="preserve">
          <source>When the user resizes the window, the size will move in steps of &lt;a href=&quot;qwindow#sizeIncrement&quot;&gt;sizeIncrement&lt;/a&gt;().&lt;a href=&quot;qwindow#width-prop&quot;&gt;width&lt;/a&gt;() pixels horizontally and &lt;a href=&quot;qwindow#sizeIncrement&quot;&gt;sizeIncrement&lt;/a&gt;().&lt;a href=&quot;qwindow#height-prop&quot;&gt;height&lt;/a&gt;() pixels vertically, with &lt;a href=&quot;qwindow#baseSize&quot;&gt;baseSize&lt;/a&gt;() as the basis.</source>
          <target state="translated">当用户调整窗口大小时，大小将以&lt;a href=&quot;qwindow#sizeIncrement&quot;&gt;sizeIncrement&lt;/a&gt;（）的步长移动。水平的&lt;a href=&quot;qwindow#width-prop&quot;&gt;width&lt;/a&gt;（）像素和&lt;a href=&quot;qwindow#sizeIncrement&quot;&gt;sizeIncrement&lt;/a&gt;（）。垂直&lt;a href=&quot;qwindow#height-prop&quot;&gt;高度&lt;/a&gt;（）像素，以&lt;a href=&quot;qwindow#baseSize&quot;&gt;baseSize&lt;/a&gt;（）为基础。</target>
        </trans-unit>
        <trans-unit id="9e453a57cc507da9b2902f79db75133ddc061ac8" translate="yes" xml:space="preserve">
          <source>When the user resizes the window, the size will move in steps of sizeIncrement().&lt;a href=&quot;qwidget#width-prop&quot;&gt;width&lt;/a&gt;() pixels horizontally and sizeIncrement.&lt;a href=&quot;qwidget#height-prop&quot;&gt;height&lt;/a&gt;() pixels vertically, with &lt;a href=&quot;qwidget#baseSize-prop&quot;&gt;baseSize&lt;/a&gt;() as the basis. Preferred widget sizes are for non-negative integers</source>
          <target state="translated">当用户调整窗口大小时，大小将以sizeIncrement（）的步长移动。水平的&lt;a href=&quot;qwidget#width-prop&quot;&gt;width&lt;/a&gt;（）像素和sizeIncrement。垂直&lt;a href=&quot;qwidget#height-prop&quot;&gt;高度&lt;/a&gt;（）像素，以&lt;a href=&quot;qwidget#baseSize-prop&quot;&gt;baseSize&lt;/a&gt;（）为基础。首选窗口小部件大小适用于非负整数</target>
        </trans-unit>
        <trans-unit id="e9e23684b39294a601601a344c7bf87e80ee521d" translate="yes" xml:space="preserve">
          <source>When the user selects a new font, the &lt;a href=&quot;qfontcombobox#currentFontChanged&quot;&gt;currentFontChanged&lt;/a&gt;() signal is emitted in addition to &lt;a href=&quot;qcombobox#currentIndexChanged&quot;&gt;currentIndexChanged&lt;/a&gt;().</source>
          <target state="translated">当用户选择新字体时，除了&lt;a href=&quot;qcombobox#currentIndexChanged&quot;&gt;currentIndexChanged&lt;/a&gt;（）之外，还会发出&lt;a href=&quot;qfontcombobox#currentFontChanged&quot;&gt;currentFontChanged&lt;/a&gt;（）信号。</target>
        </trans-unit>
        <trans-unit id="4da46bc51fcc82534c06603bbbd59ebe7d50ebb4" translate="yes" xml:space="preserve">
          <source>When the user selects an item in the list, the input method responds to the event in the &lt;a href=&quot;qml-qtquick-virtualkeyboard-inputmethod#selectionListItemSelected-method&quot;&gt;InputMethod::selectionListItemSelected&lt;/a&gt; method callback.</source>
          <target state="translated">当用户在列表中选择一个项目时，输入法将响应&lt;a href=&quot;qml-qtquick-virtualkeyboard-inputmethod#selectionListItemSelected-method&quot;&gt;InputMethod :: selectionListItemSelected&lt;/a&gt;方法回调中的事件。</target>
        </trans-unit>
        <trans-unit id="c109346817c0c000e5fe1e4e0a164874e2cf7eaf" translate="yes" xml:space="preserve">
          <source>When the user selects an item in the usual way, the selection is cleared and the new item selected. However, if the user presses the Ctrl key when clicking on an item, the clicked item gets toggled and all other items are left untouched. If the user presses the Shift key while clicking on an item, all items between the current item and the clicked item are selected or unselected, depending on the state of the clicked item. Multiple items can be selected by dragging the mouse over them.</source>
          <target state="translated">当用户以通常的方式选择一个项目时,选择会被清除,并选择新的项目。但是,如果用户在点击一个项目时按下Ctrl键,被点击的项目就会被切换,而其他项目则不会被触及。如果用户在点击一个项目时按Shift键,则当前项目和被点击项目之间的所有项目都会被选中或取消选中,这取决于被点击项目的状态。通过在多个项目上拖动鼠标,可以选择多个项目。</target>
        </trans-unit>
        <trans-unit id="239784d9cf52110a5610a0352def4b21651a1ec0" translate="yes" xml:space="preserve">
          <source>When the user selects an item in the usual way, the selection is cleared and the new item selected. However, if the user presses the Shift key while clicking on an item, all items between the current item and the clicked item are selected or unselected, depending on the state of the clicked item.</source>
          <target state="translated">当用户以通常的方式选择一个项目时,选择的项目会被清除,并选择新的项目,但如果用户在点击一个项目时按Shift键,则当前项目和点击的项目之间的所有项目都会被选择或不被选择,这取决于点击项目的状态。但是,如果用户在点击项目时按Shift键,则根据点击项目的状态,当前项目和被点击项目之间的所有项目都会被选择或取消选择。</target>
        </trans-unit>
        <trans-unit id="b63a60a0cef1fb52e61ed1b641072b5077221c1a" translate="yes" xml:space="preserve">
          <source>When the user selects an item in the usual way, the selection status of that item is toggled and the other items are left alone. Multiple items can be toggled by dragging the mouse over them.</source>
          <target state="translated">当用户以通常的方式选择一个项目时,该项目的选择状态被切换,而其他项目则被单独保留。通过在多个项目上拖动鼠标,可以切换多个项目。</target>
        </trans-unit>
        <trans-unit id="48e3c32ce598a7fbfd8868c52569756e58fdf828" translate="yes" xml:space="preserve">
          <source>When the user selects an item, any already-selected item becomes unselected. It is possible for the user to deselect the selected item by pressing the Ctrl key when clicking the selected item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="432b100478d155eb5754fdf1b8519f514ff3bcfa" translate="yes" xml:space="preserve">
          <source>When the user selects an item, any already-selected item becomes unselected. It is possible for the user to deselect the selected item.</source>
          <target state="translated">当用户选择一个项目时,任何已经选择的项目将被取消选择。用户可以取消选择项目。</target>
        </trans-unit>
        <trans-unit id="40c8efdfbff08c7bc6b912d42d8681b4819162a6" translate="yes" xml:space="preserve">
          <source>When the user triggers a step whilst holding the &lt;a href=&quot;qt#KeyboardModifier-enum&quot;&gt;Qt::ControlModifier&lt;/a&gt;, &lt;a href=&quot;qabstractspinbox&quot;&gt;QAbstractSpinBox&lt;/a&gt; steps by 10 instead of making a single step. This step modifier affects wheel events, key events and interaction with the spinbox buttons. Note that on &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, Control corresponds to the Command key.</source>
          <target state="translated">当用户在按住&lt;a href=&quot;qt#KeyboardModifier-enum&quot;&gt;Qt :: ControlModifier的情况下&lt;/a&gt;触发某个步骤时，&lt;a href=&quot;qabstractspinbox&quot;&gt;QAbstractSpinBox将&lt;/a&gt;逐步执行10次操作，而不是执行单个步骤。此步骤修改器会影响滚轮事件，键事件以及与Spinbox按钮的交互。请注意，在&lt;a href=&quot;internationalization#macos&quot;&gt;macOS上&lt;/a&gt;，Control对应于Command键。</target>
        </trans-unit>
        <trans-unit id="34d7335e57478339ba71faccb6f2bf5634476339" translate="yes" xml:space="preserve">
          <source>When the user triggers a step whilst holding the &lt;a href=&quot;qt#KeyboardModifier-enum&quot;&gt;Qt::ControlModifier&lt;/a&gt;, QAbstractSpinBox steps by 10 instead of making a single step. This step modifier affects wheel events, key events and interaction with the spinbox buttons. Note that on macOS, Control corresponds to the Command key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3de1fafb709edfc8e71149ea8ddc3fd104d090bd" translate="yes" xml:space="preserve">
          <source>When the user types the &lt;a href=&quot;qkeysequence&quot;&gt;key sequence&lt;/a&gt; for a given shortcut, the shortcut's &lt;a href=&quot;qshortcut#activated&quot;&gt;activated&lt;/a&gt;() signal is emitted. (In the case of ambiguity, the &lt;a href=&quot;qshortcut#activatedAmbiguously&quot;&gt;activatedAmbiguously&lt;/a&gt;() signal is emitted.) A shortcut is &quot;listened for&quot; by Qt's event loop when the shortcut's parent widget is receiving events.</source>
          <target state="translated">当用户键入给定快捷方式的&lt;a href=&quot;qkeysequence&quot;&gt;按键序列时&lt;/a&gt;，将发出快捷方式的&lt;a href=&quot;qshortcut#activated&quot;&gt;Activated&lt;/a&gt;（）信号。（在模棱两可的情况下，会发出&lt;a href=&quot;qshortcut#activatedAmbiguously&quot;&gt;ActivateAmbiguously&lt;/a&gt;（）信号。）当快捷方式的父窗口小部件正在接收事件时，Qt的事件循环会&amp;ldquo;监听&amp;rdquo;该快捷方式。</target>
        </trans-unit>
        <trans-unit id="07467a76ec47313778f1640f3f2853d179a4c454" translate="yes" xml:space="preserve">
          <source>When the user uses the arrows to change the spin box's value the value will be incremented/decremented by the amount of the singleStep. The default value is 1. Setting a singleStep value of less than 0 does nothing.</source>
          <target state="translated">当用户使用箭头改变自旋盒的值时,该值将按单步的数值递增/递减,默认值为1。默认值是1。设置一个小于0的singleStep值不会有任何作用。</target>
        </trans-unit>
        <trans-unit id="1a7fbae2e2cb0c5b805b7e0f23104cafdd5b43a3" translate="yes" xml:space="preserve">
          <source>When the user uses the arrows to change the spin box's value the value will be incremented/decremented by the amount of the singleStep. The default value is 1.0. Setting a singleStep value of less than 0 does nothing.</source>
          <target state="translated">当用户使用箭头改变自旋盒的值时,该值将按单步的量递增/递减。默认值是1.0。设置一个小于0的singleStep值不会有任何作用。</target>
        </trans-unit>
        <trans-unit id="55b72162369d6d7fefe6c5eeff0d064284c9c1e9" translate="yes" xml:space="preserve">
          <source>When the user wants to purchase a product, call &lt;a href=&quot;qinappproduct#purchase&quot;&gt;QInAppProduct::purchase&lt;/a&gt;() on the product. This launches a platform-specific, asynchronous process to purchase the product, for example by requesting the user's password and confirmation of the purchase. In most cases, you must make sure that the application UI is not accepting input while the purchase request is being processed, as this is not handled automatically on all platforms.</source>
          <target state="translated">当用户想要购买产品时，请&lt;a href=&quot;qinappproduct#purchase&quot;&gt;对该&lt;/a&gt;产品调用QInAppProduct :: purchase（）。这将启动特定于平台的异步过程来购买产品，例如通过请求用户密码和购买确认。在大多数情况下，您必须确保在处理购买请求时应用程序UI不接受输入，因为并非在所有平台上都会自动处理输入。</target>
        </trans-unit>
        <trans-unit id="53e007fcb539e15013065a7fcca5f31963711f7f" translate="yes" xml:space="preserve">
          <source>When the view changes, the &lt;code&gt;inputViewChanged&lt;/code&gt; signal is emitted.</source>
          <target state="translated">当视图更改时，将发出 &lt;code&gt;inputViewChanged&lt;/code&gt; 信号。</target>
        </trans-unit>
        <trans-unit id="6bf292009c41ae3996b782ddaf7f2171babcb34d" translate="yes" xml:space="preserve">
          <source>When the view is initialized, the view will create all the necessary items for the view, then animate them to their correct positions within the view over one second.</source>
          <target state="translated">当视图被初始化后,视图将为视图创建所有必要的项目,然后在一秒钟内将它们动画化到视图中的正确位置。</target>
        </trans-unit>
        <trans-unit id="bf9267cdf13126ffe2807371579c3234aa2c025f" translate="yes" xml:space="preserve">
          <source>When the widget is embedded, its state (e.g., visible, enabled, geometry, size hints) is copied into the proxy widget. If the embedded widget is explicitly hidden or disabled, the proxy widget will become explicitly hidden or disabled after embedding is complete. The class documentation has a full overview over the shared state.</source>
          <target state="translated">嵌入小组件时,其状态(如可见、启用、几何体、大小提示)将被复制到代理小组件中。如果嵌入的小组件被显式隐藏或禁用,则嵌入完成后,代理小组件将成为显式隐藏或禁用。类文档中有关于共享状态的完整概述。</target>
        </trans-unit>
        <trans-unit id="0eed7c85c5152e46b5d87508ebba22a259d445d6" translate="yes" xml:space="preserve">
          <source>When the widget needs to generate a set of preview pages, a &lt;a href=&quot;qprintpreviewwidget#paintRequested&quot;&gt;paintRequested&lt;/a&gt;() signal will be emitted from the widget. Connect a slot to this signal, and draw onto the &lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt; passed in as a signal parameter. Call &lt;a href=&quot;qprinter#newPage&quot;&gt;QPrinter::newPage&lt;/a&gt;(), to start a new page in the preview.</source>
          <target state="translated">当窗口小部件需要生成一组预览页面时，将从窗口小部件发出&lt;a href=&quot;qprintpreviewwidget#paintRequested&quot;&gt;paintRequested&lt;/a&gt;（）信号。将插槽连接到该信号，然后绘制到作为信号参数传入的&lt;a href=&quot;qprinter&quot;&gt;QPrinter上&lt;/a&gt;。调用&lt;a href=&quot;qprinter#newPage&quot;&gt;QPrinter :: newPage&lt;/a&gt;（），以在预览中开始一个新页面。</target>
        </trans-unit>
        <trans-unit id="17365a086c8d8f3707090a7d37af79afa83d7862" translate="yes" xml:space="preserve">
          <source>When the widget's window and the related OpenGL resources are not yet initialized, the return value is the format that has been set via &lt;a href=&quot;qopenglwidget#setFormat&quot;&gt;setFormat&lt;/a&gt;().</source>
          <target state="translated">当窗口小部件的窗口和相关的OpenGL资源尚未初始化时，返回值就是通过&lt;a href=&quot;qopenglwidget#setFormat&quot;&gt;setFormat&lt;/a&gt;（）设置的格式。</target>
        </trans-unit>
        <trans-unit id="43847dedad7e1417643232066e6b313499c2942c" translate="yes" xml:space="preserve">
          <source>When the widget-style font and palette propagation is enabled, font and palette changes made through Qt Style Sheets will behave as though the user had manually called the corresponding &lt;a href=&quot;qwidget#palette-prop&quot;&gt;QWidget::setPalette&lt;/a&gt;() and &lt;a href=&quot;qwidget#font-prop&quot;&gt;QWidget::setFont&lt;/a&gt;() methods on all of the QWidgets targeted by the style sheet. If this would have caused propagation in C++, it will cause propagation in style sheets and vice versa.</source>
          <target state="translated">当启用插件式的字体和调色板传播，字体和调色板改变通过Qt的样式表由将表现得好像用户已经手动地称为对应&lt;a href=&quot;qwidget#palette-prop&quot;&gt;的QWidget ::调用SetPalette&lt;/a&gt;（）和&lt;a href=&quot;qwidget#font-prop&quot;&gt;QWidget的:: setfont程序&lt;/a&gt;上的所有的（）方法样式表定位的QWidget。如果这会导致在C ++中传播，那么将导致在样式表中传播，反之亦然。</target>
        </trans-unit>
        <trans-unit id="d46c08525c4ed676f1a7ccbb248c7080204996de" translate="yes" xml:space="preserve">
          <source>When the window is made visible, the content is updated automatically. Further updates can be requested by calling &lt;a href=&quot;qwindow#requestUpdate&quot;&gt;QWindow::requestUpdate&lt;/a&gt;(). To render continuously, call &lt;a href=&quot;qwindow#requestUpdate&quot;&gt;requestUpdate&lt;/a&gt;() after &lt;a href=&quot;qvulkanwindow#frameReady&quot;&gt;frameReady&lt;/a&gt;().</source>
          <target state="translated">使窗口可见后，内容将自动更新。可以通过调用&lt;a href=&quot;qwindow#requestUpdate&quot;&gt;QWindow :: requestUpdate&lt;/a&gt;（）来请求进一步的更新。要连续渲染，请在&lt;a href=&quot;qvulkanwindow#frameReady&quot;&gt;frameReady&lt;/a&gt;（）之后调用&lt;a href=&quot;qwindow#requestUpdate&quot;&gt;requestUpdate&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="d0885d46fa70f463e2de0a22a1a8f497582d4166" translate="yes" xml:space="preserve">
          <source>When the window is not exposed, it is shown by the application but it is still not showing in the windowing system, so the application should minimize rendering and other graphical activities.</source>
          <target state="translated">当窗口没有暴露出来时,虽然被应用程序显示出来了,但在窗口系统中仍然没有显示出来,所以应用程序应该尽量减少渲染和其他图形活动。</target>
        </trans-unit>
        <trans-unit id="298ff46be999c313b755a4569e2c0f50522cc6cd" translate="yes" xml:space="preserve">
          <source>When the window state changes, the widget receives a &lt;a href=&quot;qwidget#changeEvent&quot;&gt;changeEvent&lt;/a&gt;() of type &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::WindowStateChange&lt;/a&gt;.</source>
          <target state="translated">当窗口状态更改时，窗口小部件会收到&lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent :: WindowStateChange&lt;/a&gt;类型的&lt;a href=&quot;qwidget#changeEvent&quot;&gt;changeEvent&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="4430665a811124c03a76c8e73574aa765dc47098" translate="yes" xml:space="preserve">
          <source>When there are too many tabs in a tab bar for its size, the tab bar can either choose to expand its size or to add buttons that allow you to scroll through the tabs.</source>
          <target state="translated">当标签栏中的标签太多而无法满足其大小时,标签栏可以选择扩大其大小或添加按钮,允许你滚动浏览标签。</target>
        </trans-unit>
        <trans-unit id="328188d436a703678d89704707e3862740fee438" translate="yes" xml:space="preserve">
          <source>When these images are loaded by QML, it looks for a matching image provider and calls its &lt;a href=&quot;qquickimageprovider#requestImage&quot;&gt;requestImage&lt;/a&gt;() or &lt;a href=&quot;qquickimageprovider#requestPixmap&quot;&gt;requestPixmap&lt;/a&gt;() method (depending on its &lt;a href=&quot;qquickimageprovider#imageType&quot;&gt;imageType&lt;/a&gt;()) to load the image. The method is called with the &lt;code&gt;id&lt;/code&gt; parameter set to &quot;yellow&quot; for the first image, and &quot;red&quot; for the second.</source>
          <target state="translated">当这些图像由QML加载时，它将查找匹配的图像提供程序，并调用其&lt;a href=&quot;qquickimageprovider#requestImage&quot;&gt;requestImage&lt;/a&gt;（）或&lt;a href=&quot;qquickimageprovider#requestPixmap&quot;&gt;requestPixmap&lt;/a&gt;（）方法（取决于其&lt;a href=&quot;qquickimageprovider#imageType&quot;&gt;imageType&lt;/a&gt;（））来加载图像。调用该方法时，第一个图像的 &lt;code&gt;id&lt;/code&gt; 参数设置为&amp;ldquo;黄色&amp;rdquo;，第二个图像的id参数设置为&amp;ldquo;红色&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="280d1db6d231e9b9540bfc8acf026c5df8031216" translate="yes" xml:space="preserve">
          <source>When this argument is used, a second argument is required, which specifies the module whose classes are to be listed. QDoc generates a table containing those classes. Each class is listed with the text of its &lt;a href=&quot;11-qdoc-commands-specialcontent#brief-command&quot;&gt;\brief&lt;/a&gt; command.</source>
          <target state="translated">使用此参数时，需要第二个参数，该参数指定要列出其类的模块。QDoc生成一个包含这些类的表。每个类都列出了其&lt;a href=&quot;11-qdoc-commands-specialcontent#brief-command&quot;&gt;\ brief&lt;/a&gt;命令的文本。</target>
        </trans-unit>
        <trans-unit id="ed8f319625948db2e4a131ba28a779620a6396b0" translate="yes" xml:space="preserve">
          <source>When this attribute is set, the native on-screen virtual keyboard will not be shown automatically when a text input widget gains focus on a system without a physical keyboard. Currently supported on the Windows platform only. This value was added in 5.15</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="278d7e1255bd96582c739bd15df2833e0be8a868" translate="yes" xml:space="preserve">
          <source>When this code is loaded by the engine, it creates an object tree with a &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; object at the root; this object has a &lt;a href=&quot;qml-qtquick-gradient&quot;&gt;Gradient&lt;/a&gt; child object, which in turn has two &lt;a href=&quot;qml-qtquick-gradientstop&quot;&gt;GradientStop&lt;/a&gt; children.</source>
          <target state="translated">当引擎加载此代码时，它将创建一个对象树，其根为&lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt;对象。该对象具有一个&lt;a href=&quot;qml-qtquick-gradient&quot;&gt;Gradient&lt;/a&gt;子对象，而该对象又具有两个&lt;a href=&quot;qml-qtquick-gradientstop&quot;&gt;GradientStop&lt;/a&gt;子对象。</target>
        </trans-unit>
        <trans-unit id="bef518027d6e82c3441e9a6878947589c6671093" translate="yes" xml:space="preserve">
          <source>When this event occurs it is customary to show a &lt;a href=&quot;qmenu&quot;&gt;QMenu&lt;/a&gt; with a context menu, if this is relevant to the context.</source>
          <target state="translated">发生此事件时，通常会显示带有上下文菜单的&lt;a href=&quot;qmenu&quot;&gt;QMenu&lt;/a&gt;（如果与上下文相关）。</target>
        </trans-unit>
        <trans-unit id="1c5aa92c276833ef89412fc07466f6fcff736ad0" translate="yes" xml:space="preserve">
          <source>When this feature is on (the default is off), clicking on a header section sorts the items according to that column. By clicking repeatedly, the user can alternate between ascending and descending order.</source>
          <target state="translated">当此功能开启时(默认情况下是关闭的),点击页眉部分会根据该列进行排序。通过反复点击,用户可以在升序和降序之间交替进行。</target>
        </trans-unit>
        <trans-unit id="5aafd154ba0fcb35eccabb15e1a7d96cc39747d6" translate="yes" xml:space="preserve">
          <source>When this function is called after the program has been linked, the program will need to be relinked for the change to take effect.</source>
          <target state="translated">当这个函数在程序被链接后被调用时,程序需要重新链接才能使改变生效。</target>
        </trans-unit>
        <trans-unit id="c9186348bdc67fdf223b859066aa3c52ea35863b" translate="yes" xml:space="preserve">
          <source>When this function is called multiple times in quick succession with the same function as its first argument, that function will be called only once.</source>
          <target state="translated">当这个函数以同一个函数作为第一个参数连续多次调用时,该函数将只被调用一次。</target>
        </trans-unit>
        <trans-unit id="398a779395d95b160c8ff7f5a1fe0f7602c5e153" translate="yes" xml:space="preserve">
          <source>When this function is called, the purchase process is initiated. At some point during the process, the &lt;a href=&quot;qinappstore#transactionReady&quot;&gt;QInAppStore::transactionReady&lt;/a&gt;() signal is emitted, and the slot registered earlier is called. In this function, you can save data about a successful purchase so that it survives across application runs. After verifying that the data has been stored, finalize the transaction. If the transaction fails, display information about the failure to the user and finalize the transaction.</source>
          <target state="translated">调用此功能后，将启动购买过程。在此过程中的某个时刻，将&lt;a href=&quot;qinappstore#transactionReady&quot;&gt;发出QInAppStore :: transactionReady&lt;/a&gt;（）信号，并调用较早注册的插槽。在此功能中，您可以保存有关成功购买的数据，以便在整个应用程序运行中保留下来。验证数据已存储后，完成交易。如果事务失败，请向用户显示有关失败的信息并完成事务。</target>
        </trans-unit>
        <trans-unit id="0a8adea584e450f3c916a9833293ed806c718263" translate="yes" xml:space="preserve">
          <source>When this hint is set and it is applicable, the clip region will be generated from &lt;a href=&quot;qsgclipnode#clipRect&quot;&gt;clipRect&lt;/a&gt;() rather than &lt;a href=&quot;qsgbasicgeometrynode#geometry&quot;&gt;geometry&lt;/a&gt;().</source>
          <target state="translated">设置此提示并使其适用后，剪辑区域将从&lt;a href=&quot;qsgclipnode#clipRect&quot;&gt;clipRect&lt;/a&gt;（）而不是&lt;a href=&quot;qsgbasicgeometrynode#geometry&quot;&gt;geometry&lt;/a&gt;（）生成。</target>
        </trans-unit>
        <trans-unit id="25c548388c50d22300a6331c81e8413c5cbc46fc" translate="yes" xml:space="preserve">
          <source>When this is enabled, qmake will process all libraries linked to by the application and find their meta-information. qmake will use this to determine the relevant linking information, specifically adding values to the application project file's list of &lt;a href=&quot;qmake-variable-reference#defines&quot;&gt;DEFINES&lt;/a&gt; as well as &lt;a href=&quot;qmake-variable-reference#libs&quot;&gt;LIBS&lt;/a&gt;. Once qmake has processed this file, it will then look through the newly introduced libraries in the &lt;code&gt;LIBS&lt;/code&gt; variable, and find their dependent .prl files, continuing until all libraries have been resolved. At this point, the Makefile is created as usual, and the libraries are linked explicitly against the application.</source>
          <target state="translated">启用此功能后，qmake将处理该应用程序链接的所有库，并找到它们的元信息。 qmake将使用它来确定相关的链接信息，特别是将值添加到应用程序项目文件的&lt;a href=&quot;qmake-variable-reference#defines&quot;&gt;DEFINES&lt;/a&gt;以及&lt;a href=&quot;qmake-variable-reference#libs&quot;&gt;LIBS&lt;/a&gt;列表中。一旦qmake处理了该文件，它将在 &lt;code&gt;LIBS&lt;/code&gt; 变量中浏览新引入的库，并找到它们的相关.prl文件，直到所有库都被解析为止。此时，将像往常一样创建Makefile，并将库与应用程序明确链接。</target>
        </trans-unit>
        <trans-unit id="e1c2654888290051c11e8d6edd467ee92c8e7a88" translate="yes" xml:space="preserve">
          <source>When this is repeated for each leaf node in the framegraph, the frame is complete and the renderer calls &lt;a href=&quot;qopenglcontext#swapBuffers&quot;&gt;QOpenGLContext::swapBuffers&lt;/a&gt;() to display the frame.</source>
          <target state="translated">对框架图中的每个叶节点重复此操作时，框架已完成，渲染器调用&lt;a href=&quot;qopenglcontext#swapBuffers&quot;&gt;QOpenGLContext :: swapBuffers&lt;/a&gt;（）来显示框架。</target>
        </trans-unit>
        <trans-unit id="ec52fd20354c1402a9e5c8a902314529744bb69a" translate="yes" xml:space="preserve">
          <source>When this method is called it additionally sets either the &lt;a href=&quot;qml-qtquick-controls-textarea#selectionStart-prop&quot;&gt;selectionStart&lt;/a&gt; or the &lt;a href=&quot;qml-qtquick-controls-textarea#selectionEnd-prop&quot;&gt;selectionEnd&lt;/a&gt; (whichever was at the previous cursor position) to the specified position. This allows you to easily extend and contract the selected text range.</source>
          <target state="translated">调用此方法时，它还会将&lt;a href=&quot;qml-qtquick-controls-textarea#selectionStart-prop&quot;&gt;selectionStart&lt;/a&gt;或&lt;a href=&quot;qml-qtquick-controls-textarea#selectionEnd-prop&quot;&gt;selectionEnd&lt;/a&gt;（以先前的光标位置为准）设置为指定位置。这使您可以轻松扩展和缩小所选文本范围。</target>
        </trans-unit>
        <trans-unit id="0b402258b559da375e5607dca734ac8dba2f14ee" translate="yes" xml:space="preserve">
          <source>When this method is called it additionally sets either the &lt;a href=&quot;qml-qtquick-textedit#selectionStart-prop&quot;&gt;selectionStart&lt;/a&gt; or the &lt;a href=&quot;qml-qtquick-textedit#selectionEnd-prop&quot;&gt;selectionEnd&lt;/a&gt; (whichever was at the previous cursor position) to the specified position. This allows you to easily extend and contract the selected text range.</source>
          <target state="translated">调用此方法时，它还会将&lt;a href=&quot;qml-qtquick-textedit#selectionStart-prop&quot;&gt;selectionStart&lt;/a&gt;或&lt;a href=&quot;qml-qtquick-textedit#selectionEnd-prop&quot;&gt;selectionEnd&lt;/a&gt;（以先前的光标位置为准）设置为指定位置。这使您可以轻松扩展和缩小所选文本范围。</target>
        </trans-unit>
        <trans-unit id="81183ac8bcf1dd186d0806619cf0a4b7150e1d76" translate="yes" xml:space="preserve">
          <source>When this method is called it additionally sets either the &lt;a href=&quot;qml-qtquick-textinput#selectionStart-prop&quot;&gt;selectionStart&lt;/a&gt; or the &lt;a href=&quot;qml-qtquick-textinput#selectionEnd-prop&quot;&gt;selectionEnd&lt;/a&gt; (whichever was at the previous cursor position) to the specified position. This allows you to easily extend and contract the selected text range.</source>
          <target state="translated">调用此方法时，它还会将&lt;a href=&quot;qml-qtquick-textinput#selectionStart-prop&quot;&gt;selectionStart&lt;/a&gt;或&lt;a href=&quot;qml-qtquick-textinput#selectionEnd-prop&quot;&gt;selectionEnd&lt;/a&gt;（以先前的光标位置为准）设置为指定位置。这使您可以轻松扩展和缩小所选文本范围。</target>
        </trans-unit>
        <trans-unit id="3be9f15b12fa7586e346464303593068b7d2ddce" translate="yes" xml:space="preserve">
          <source>When this method is called, or when the user tries to close the window by its title bar button, the &lt;a href=&quot;qml-qtquick-window-window#closing-signal&quot;&gt;closing&lt;/a&gt; signal will be emitted. If there is no handler, or the handler does not revoke permission to close, the window will subsequently close. If the &lt;a href=&quot;qguiapplication#quitOnLastWindowClosed-prop&quot;&gt;QGuiApplication::quitOnLastWindowClosed&lt;/a&gt; property is &lt;code&gt;true&lt;/code&gt;, and there are no other windows open, the application will quit.</source>
          <target state="translated">当调用此方法时，或者当用户尝试通过其标题栏按钮关闭窗口时，将发出&lt;a href=&quot;qml-qtquick-window-window#closing-signal&quot;&gt;关闭&lt;/a&gt;信号。如果没有处理程序，或者处理程序未撤消关闭权限，则该窗口随后将关闭。如果&lt;a href=&quot;qguiapplication#quitOnLastWindowClosed-prop&quot;&gt;QGuiApplication :: quitOnLastWindowClosed&lt;/a&gt;属性为 &lt;code&gt;true&lt;/code&gt; ，并且没有其他窗口打开，则应用程序将退出。</target>
        </trans-unit>
        <trans-unit id="4ca058932c3f0b4bb0aeaff104b696065bebb8ff" translate="yes" xml:space="preserve">
          <source>When this option is enabled, qmake will process all libraries linked to by the application and find their meta-information (see &lt;a href=&quot;qmake-advanced-usage#libdepend&quot;&gt;Library Dependencies&lt;/a&gt; for more info).</source>
          <target state="translated">启用此选项后，qmake将处理该应用程序链接的所有库并找到其元信息（有关更多信息，请参见&lt;a href=&quot;qmake-advanced-usage#libdepend&quot;&gt;库依赖关系&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="e954b1e0533aa197768aa31122dd76fd088a3473" translate="yes" xml:space="preserve">
          <source>When this option is set, &lt;a href=&quot;qtextline#naturalTextWidth&quot;&gt;QTextLine::naturalTextWidth&lt;/a&gt;() and &lt;a href=&quot;qtextline#naturalTextRect&quot;&gt;QTextLine::naturalTextRect&lt;/a&gt;() will return a value that includes the width of trailing spaces in the text; otherwise this width is excluded.</source>
          <target state="translated">设置此选项后，&lt;a href=&quot;qtextline#naturalTextWidth&quot;&gt;QTextLine :: naturalTextWidth&lt;/a&gt;（）和&lt;a href=&quot;qtextline#naturalTextRect&quot;&gt;QTextLine :: naturalTextRect&lt;/a&gt;（）将返回一个值，该值包括文本中尾随空格的宽度。否则，将不包括此宽度。</target>
        </trans-unit>
        <trans-unit id="7e4b2c0654bf40a5f19574c6810ff26dfd4d2ceb" translate="yes" xml:space="preserve">
          <source>When this option is set, &lt;a href=&quot;qtextline#naturalTextWidth&quot;&gt;QTextLine::naturalTextWidth&lt;/a&gt;() and naturalTextRect() will return a value that includes the width of trailing spaces in the text; otherwise this width is excluded.</source>
          <target state="translated">设置此选项后，&lt;a href=&quot;qtextline#naturalTextWidth&quot;&gt;QTextLine :: naturalTextWidth&lt;/a&gt;（）和naturalTextRect（）将返回一个值，该值包括文本中尾随空格的宽度。否则，将不包括此宽度。</target>
        </trans-unit>
        <trans-unit id="f271981227ef20d87cc64f0259c4f19f522399df" translate="yes" xml:space="preserve">
          <source>When this property changes, a scrollable view should automatically scroll itself in such a way as to ensure that this region is visible; for example, it could try to position the upper-left corner near the upper-left of its own viewport, subject to the constraints of the scrollable area.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c42f5c456658d1e6cc7ae9de66d3b8a114c246a" translate="yes" xml:space="preserve">
          <source>When this property changes, the &lt;code&gt;topLevelChanged()&lt;/code&gt; signal is emitted.</source>
          <target state="translated">当此属性更改时，将发出 &lt;code&gt;topLevelChanged()&lt;/code&gt; 信号。</target>
        </trans-unit>
        <trans-unit id="2e8947f71029eebb8d494bf176ad2f080cf20f26" translate="yes" xml:space="preserve">
          <source>When this property is &lt;code&gt;false&lt;/code&gt;, it's not possible to drag the dial across the from and to values.</source>
          <target state="translated">如果此属性为 &lt;code&gt;false&lt;/code&gt; ，则无法将拨盘拖动到from和to值之间。</target>
        </trans-unit>
        <trans-unit id="2cf377eb087a92958eeac23380aef05f26d062d5" translate="yes" xml:space="preserve">
          <source>When this property is &lt;code&gt;true&lt;/code&gt; (the default), the next month, previous month, month selection, year selection controls are shown on top.</source>
          <target state="translated">当此属性为 &lt;code&gt;true&lt;/code&gt; （默认设置）时，下个月，上个月，月份选择，年份选择控件显示在顶部。</target>
        </trans-unit>
        <trans-unit id="e001d3612422e2e98bda1806f3de5d100dc0ffd9" translate="yes" xml:space="preserve">
          <source>When this property is &lt;code&gt;true&lt;/code&gt; and the &lt;a href=&quot;qml-qtquick3d-model#tessellationMode-prop&quot;&gt;tessellationMode&lt;/a&gt; is not Model.NoTessellation, a wireframe is displayed to highlight the additional geometry created by the tessellation generator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c6308ea5aac847e02c97a8f794ffa729d592dd4" translate="yes" xml:space="preserve">
          <source>When this property is &lt;code&gt;true&lt;/code&gt; object outside the frustum will be culled, meaning they will not be rendered. By default this property is set to &lt;code&gt;false&lt;/code&gt;, but for complex scene where a lot of the objects are outside the camera frustum it might be beneficial to enable frustum culling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c6d22c0bbc6a53d1f13528b30f888d0610b3d76" translate="yes" xml:space="preserve">
          <source>When this property is &lt;code&gt;true&lt;/code&gt;, shadows can be cast onto this item. So the shadow map is applied to this model by the renderer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae3ac6a5c511fb8757d09b3ced0b9ec19d6b694d" translate="yes" xml:space="preserve">
          <source>When this property is &lt;code&gt;true&lt;/code&gt;, the geometry of this model is used when rendering to the shadow maps.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5435f7b9bf2979fd82564870b5b12500055a6cde" translate="yes" xml:space="preserve">
          <source>When this property is enabled it scatters the edges of the ambient occlusion shadow bands to improve smoothness (at the risk of sometimes producing obvious patterned artifacts).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e970705b8c985988e06ca43a11e32d86795a38e" translate="yes" xml:space="preserve">
          <source>When this property is enabled more shortcuts are taken to approximate the light contributes of the light probe at the expense of quality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dac3a5e67061b28cd41b0e9edb5be2c4bdef12b" translate="yes" xml:space="preserve">
          <source>When this property is enabled temporal antialiasing will be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fd821d6a927b06c3741219adce2a495492f9002" translate="yes" xml:space="preserve">
          <source>When this property is enabled, the light will cast shadows. The default value is false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="100dd97a4fb38bb0a31c18fad05f76672fb1531a" translate="yes" xml:space="preserve">
          <source>When this property is enabled, the material will use vertex colors from the mesh. These will be multiplied by any other colors specified for the material.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf43a8d4ad0de35433838bc85feefa148dfa808b" translate="yes" xml:space="preserve">
          <source>When this property is set and the &lt;a href=&quot;qml-qtquick-springanimation#velocity-prop&quot;&gt;velocity&lt;/a&gt; value is greater than 0, the &lt;a href=&quot;qml-qtquick-springanimation#velocity-prop&quot;&gt;velocity&lt;/a&gt; limits the maximum speed.</source>
          <target state="translated">设置此属性并且&lt;a href=&quot;qml-qtquick-springanimation#velocity-prop&quot;&gt;速度&lt;/a&gt;值大于0时，&lt;a href=&quot;qml-qtquick-springanimation#velocity-prop&quot;&gt;速度&lt;/a&gt;将限制最大速度。</target>
        </trans-unit>
        <trans-unit id="bf92afa5571a2082abd019a22b3b5e076f89feca" translate="yes" xml:space="preserve">
          <source>When this property is set any current decoding is stopped, and any audio buffers are discarded.</source>
          <target state="translated">当此属性被设置时,任何当前的解码都会停止,任何音频缓冲区都会被丢弃。</target>
        </trans-unit>
        <trans-unit id="6f37ded37bad8b26d03755297e0d0d1d2d468416" translate="yes" xml:space="preserve">
          <source>When this property is set the tab widget frame is not rendered. This mode is useful for showing document-type pages where the page covers most of the tab widget area.</source>
          <target state="translated">设置此属性时,标签小组件框架不会呈现。此模式对于显示文档类型的页面很有用,因为页面覆盖了大部分标签小组件区域。</target>
        </trans-unit>
        <trans-unit id="bb1f39d69438f440f90e503c95bb71197010e140" translate="yes" xml:space="preserve">
          <source>When this property is set to &lt;a href=&quot;qcalendarwidget#SelectionMode-enum&quot;&gt;SingleSelection&lt;/a&gt;, the user can select a date within the minimum and maximum allowed dates, using either the mouse or the keyboard.</source>
          <target state="translated">当此属性设置为&lt;a href=&quot;qcalendarwidget#SelectionMode-enum&quot;&gt;SingleSelection时&lt;/a&gt;，用户可以使用鼠标或键盘在最小和最大允许日期内选择一个日期。</target>
        </trans-unit>
        <trans-unit id="4747a4a028b83a9e0e586a4b5157956a8881beee" translate="yes" xml:space="preserve">
          <source>When this property is set to &lt;a href=&quot;qt#CursorMoveStyle-enum&quot;&gt;Qt::VisualMoveStyle&lt;/a&gt;, the line edit will use visual movement style. Pressing the left arrow key will always cause the cursor to move left, regardless of the text's writing direction. The same behavior applies to right arrow key.</source>
          <target state="translated">当此属性设置为&lt;a href=&quot;qt#CursorMoveStyle-enum&quot;&gt;Qt :: VisualMoveStyle时&lt;/a&gt;，线编辑将使用视觉移动样式。无论文本的书写方向如何，按左箭头键都将始终导致光标向左移动。右箭头键也有相同的行为。</target>
        </trans-unit>
        <trans-unit id="6350e57b73a741c92757bc74c17a0770b6b20fee" translate="yes" xml:space="preserve">
          <source>When this property is set to &lt;code&gt;false&lt;/code&gt;, the Z-buffer is not used, the depth test is skipped, and all objects, including fully opaque ones, are rendered in one go sorted back to front.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0edc644e371fc7727ba54cb716093cdd57e0cd9c" translate="yes" xml:space="preserve">
          <source>When this property is set, the given folder will be treated as the root in the file system, so that you can only traverse subfolders within it.</source>
          <target state="translated">当设置此属性时,给定的文件夹将被视为文件系统中的根目录,因此你只能遍历其中的子文件夹。</target>
        </trans-unit>
        <trans-unit id="b2d44a4363149f5868c0478951229cd0f684ca40" translate="yes" xml:space="preserve">
          <source>When this property is set, the specified opacity is also applied individually to child items. This may have an unintended effect in some circumstances. For example in the second set of rectangles below, the red rectangle has specified an opacity of 0.5, which affects the opacity of its blue child rectangle even though the child has not specified an opacity.</source>
          <target state="translated">当设置此属性时,指定的不透明度也会单独应用于子项目。这在某些情况下可能会产生意想不到的效果。例如,在下面第二组矩形中,红色矩形指定了 0.5 的不透明度,这会影响蓝色子矩形的不透明度,即使子矩形没有指定不透明度。</target>
        </trans-unit>
        <trans-unit id="1f016f4e737a52e8f462fcd37b82c141a90134d0" translate="yes" xml:space="preserve">
          <source>When this property is true, the Node (and its children) can be visible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9f5748d3f3423c22760b03f83dc84f38b1f3b1f" translate="yes" xml:space="preserve">
          <source>When this propery is set to false text edit will accept only plain text input from the user. For example through clipboard or drag and drop.</source>
          <target state="translated">当这个属性设置为false时,文本编辑将只接受用户的纯文本输入。例如,通过剪贴板或拖放。</target>
        </trans-unit>
        <trans-unit id="aec3729055d25b18cd030179a5d7fbd186ecaf3f" translate="yes" xml:space="preserve">
          <source>When this restore policy is set, the machine will automatically restore all properties. If it enters a state where a given property is not set, it will first search the hierarchy of ancestors to see if the property is defined there. If it is, the property will be restored to the value defined by the closest ancestor. If not, it will be restored to its initial value (i.e. the value of the property before any property assignments in states were executed.)</source>
          <target state="translated">当设置该还原策略时,机器将自动还原所有属性。如果它进入一个给定属性未被设置的状态,它将首先搜索祖先的层次结构,查看该属性是否在那里被定义。如果有,该属性将被还原为最接近的祖先所定义的值。如果没有,它将被恢复到它的初始值(即在状态中的任何属性赋值被执行之前的属性值)。</target>
        </trans-unit>
        <trans-unit id="2cb4559c1cf0ab4e52e4f01892955e108435ae26" translate="yes" xml:space="preserve">
          <source>When this signal is emitted, the event loop has already stopped running. No more events will be processed in the thread, except for deferred deletion events. This signal can be connected to &lt;a href=&quot;qobject#deleteLater&quot;&gt;QObject::deleteLater&lt;/a&gt;(), to free objects in that thread.</source>
          <target state="translated">发出此信号时，事件循环已经停止运行。除了延迟的删除事件外，线程中将不再处理其他事件。该信号可以连接到&lt;a href=&quot;qobject#deleteLater&quot;&gt;QObject :: deleteLater&lt;/a&gt;（），以释放该线程中的对象。</target>
        </trans-unit>
        <trans-unit id="bc470d3a44b5fd1b983e2c2d38610b55df6e2808" translate="yes" xml:space="preserve">
          <source>When this signal is emitted, the socket may not be ready for a reconnect attempt. In that case, attempts to reconnect should be done from the event loop. For example, use a &lt;a href=&quot;qtimer#singleShot&quot;&gt;QTimer::singleShot&lt;/a&gt;() with 0 as the timeout.</source>
          <target state="translated">发出此信号后，插座可能未准备好进行重新连接。在这种情况下，应尝试从事件循环中进行重新连接。例如，使用&lt;a href=&quot;qtimer#singleShot&quot;&gt;QTimer :: singleShot&lt;/a&gt;（）将0用作超时。</target>
        </trans-unit>
        <trans-unit id="68f5a54216eb63b6271e28125c316438880cf091" translate="yes" xml:space="preserve">
          <source>When tr() is called, it looks up the translatable string using a &lt;a href=&quot;qtranslator&quot;&gt;QTranslator&lt;/a&gt; object. For translation to work, one or more of these must have been installed on the application object in the way described in &lt;a href=&quot;internationalization#enabling-translation&quot;&gt;Enabling Translation&lt;/a&gt;.</source>
          <target state="translated">调用tr（）时，它将使用&lt;a href=&quot;qtranslator&quot;&gt;QTranslator&lt;/a&gt;对象查找可翻译的字符串。为了使翻译正常工作，必须按照&amp;ldquo; &lt;a href=&quot;internationalization#enabling-translation&quot;&gt;启用翻译&amp;rdquo;&lt;/a&gt;中所述的方式将其中一个或多个安装在应用程序对象上。</target>
        </trans-unit>
        <trans-unit id="b9ebf77d443c0f3c1d237e7890cbd696ca28dded" translate="yes" xml:space="preserve">
          <source>When transforming a pixmap using the &lt;a href=&quot;qpixmap#transformed&quot;&gt;transformed&lt;/a&gt;() function, the transformation matrix is internally adjusted to compensate for unwanted translation, i.e. &lt;a href=&quot;qpixmap#transformed&quot;&gt;transformed&lt;/a&gt;() returns the smallest pixmap containing all transformed points of the original pixmap. This function returns the modified matrix, which maps points correctly from the original pixmap into the new pixmap.</source>
          <target state="translated">当使用&lt;a href=&quot;qpixmap#transformed&quot;&gt;transformed&lt;/a&gt;（）函数对像素图进行转换时，将对转换矩阵进行内部调整以补偿不必要的翻译，即&lt;a href=&quot;qpixmap#transformed&quot;&gt;transform&lt;/a&gt;（）返回包含原始像素图的所有转换点的最小像素图。此函数返回修改后的矩阵，该矩阵将点正确地从原始像素图映射到新像素图。</target>
        </trans-unit>
        <trans-unit id="e797276249bcc854a69b6e49354f4d62d00c23f8" translate="yes" xml:space="preserve">
          <source>When transforming an embedded widget, Graphics View makes sure that the widget is transformed resolution independently, allowing the fonts and style to stay crisp when zoomed in. (Note that the effect of resolution independence depends on the style.)</source>
          <target state="translated">在转换嵌入式小组件时,Graphics View可确保小组件独立地转换分辨率,使字体和样式在放大时保持清晰。注意,分辨率独立的效果取决于样式)。</target>
        </trans-unit>
        <trans-unit id="3aa1fd29b9548bcc37cb012b55271fdb19e2ee54" translate="yes" xml:space="preserve">
          <source>When transforming an image using the &lt;a href=&quot;qimage#transformed&quot;&gt;transformed&lt;/a&gt;() function, the transformation matrix is internally adjusted to compensate for unwanted translation, i.e. &lt;a href=&quot;qimage#transformed&quot;&gt;transformed&lt;/a&gt;() returns the smallest image containing all transformed points of the original image. This function returns the modified matrix, which maps points correctly from the original image into the new image.</source>
          <target state="translated">当使用&lt;a href=&quot;qimage#transformed&quot;&gt;transformd&lt;/a&gt;（）函数对图像进行转换时，将对转换矩阵进行内部调整以补偿不必要的平移，即，&lt;a href=&quot;qimage#transformed&quot;&gt;transformd&lt;/a&gt;（）返回包含原始图像所有转换点的最小图像。此函数返回修改后的矩阵，该矩阵将点正确地从原始图像映射到新图像。</target>
        </trans-unit>
        <trans-unit id="4d6a460eeff2d6a334a698745ed9d8d6a6ebeec9" translate="yes" xml:space="preserve">
          <source>When transforming an image using the transformed() function, the transformation matrix is internally adjusted to compensate for unwanted translation, i.e. transformed() returns the smallest image containing all transformed points of the original image. This function returns the modified matrix, which maps points correctly from the original image into the new image.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7221d90a96209f3128795a80a97a531cead2f548" translate="yes" xml:space="preserve">
          <source>When transforming from clip to normalized space, a division by the w component of the vector components takes place. To prevent dividing by 0 if w equals to 0, it is set to 1.</source>
          <target state="translated">当从剪辑转换到归一化空间时,会发生矢量分量的w分量除法。如果w等于0,为了防止除以0,将其设置为1。</target>
        </trans-unit>
        <trans-unit id="fbec62568b02f257db0ec31fbe2b5f21cf0c220e" translate="yes" xml:space="preserve">
          <source>When transforming from clip to normalized space, a division by the w component on the vector components takes place. To prevent dividing by 0 if w equals to 0, it is set to 1.</source>
          <target state="translated">当从剪辑转换到归一化空间时,向量分量上的w分量会被除掉。如果w等于0,为了防止除以0,将其设置为1。</target>
        </trans-unit>
        <trans-unit id="f520f592321df5d529bf39711026e14f01be91fb" translate="yes" xml:space="preserve">
          <source>When true, the menu contains a special tear-off item (often shown as a dashed line at the top of the menu) that creates a copy of the menu when it is triggered.</source>
          <target state="translated">当为真时,菜单中包含一个特殊的拆分项(通常显示为菜单顶部的虚线),当它被触发时,会创建一个菜单的副本。</target>
        </trans-unit>
        <trans-unit id="a89b60404dcbc2f5c915acfe02c16712d4bb61d2" translate="yes" xml:space="preserve">
          <source>When two manuals are located in the same virtual folder, it is possible to refer to sections of the other manual using relative paths. The virtual folder tag is mandatory and the folder must not contain any '/'.</source>
          <target state="translated">当两本手册位于同一个虚拟文件夹中时,可以使用相对路径引用另一本手册的章节。虚拟文件夹标签是必须的,并且文件夹不得包含任何&quot;/&quot;。</target>
        </trans-unit>
        <trans-unit id="611300300598b513a04acdc4158b65a1b90365bd" translate="yes" xml:space="preserve">
          <source>When two widgets are adjacent to each other in a horizontal layout, setting the horizontal stretch factor of the widget on the left to 2 and the factor of widget on the right to 1 will ensure that the widget on the left will always be twice the size of the one on the right.</source>
          <target state="translated">当两个小组件在水平布局中相邻时,将左边小组件的水平拉伸系数设置为2,右边小组件的系数设置为1,将确保左边小组件的大小始终是右边小组件的两倍。</target>
        </trans-unit>
        <trans-unit id="33931b591564c5ce659c5439a00ac167ba2235e2" translate="yes" xml:space="preserve">
          <source>When two widgets are adjacent to each other in a vertical layout, setting the vertical stretch factor of the widget on the top to 2 and the factor of widget on the bottom to 1 will ensure that the widget on the top will always be twice the size of the one on the bottom.</source>
          <target state="translated">当两个小组件在垂直布局中相邻时,将顶部小组件的垂直拉伸系数设置为2,底部小组件的系数设置为1,将确保顶部小组件的大小始终是底部小组件的两倍。</target>
        </trans-unit>
        <trans-unit id="55c03842e144167485cbd5e8643bcbb80f6a7794" translate="yes" xml:space="preserve">
          <source>When unshared (or const version is called), this executes in &lt;a href=&quot;containers#constant-time&quot;&gt;constant time&lt;/a&gt;.</source>
          <target state="translated">取消共享（或调用const版本）时，此操作将以&lt;a href=&quot;containers#constant-time&quot;&gt;固定时间&lt;/a&gt;执行。</target>
        </trans-unit>
        <trans-unit id="bcc9e75ff489b96d3335be53af67c254b116188b" translate="yes" xml:space="preserve">
          <source>When unshared (or const version is called), this executes in &lt;a href=&quot;containers#logarithmic-time&quot;&gt;logarithmic time&lt;/a&gt;.</source>
          <target state="translated">当取消共享（或调用const版本）时，此操作以&lt;a href=&quot;containers#logarithmic-time&quot;&gt;对数时间&lt;/a&gt;执行。</target>
        </trans-unit>
        <trans-unit id="991f02e2c91e5a7647479f2f811f8738759e3c87" translate="yes" xml:space="preserve">
          <source>When updating the current time, &lt;a href=&quot;qtimeline&quot;&gt;QTimeLine&lt;/a&gt; will emit &lt;a href=&quot;qtimeline#valueChanged&quot;&gt;valueChanged&lt;/a&gt;() if the current value changed, and &lt;a href=&quot;qtimeline#frameChanged&quot;&gt;frameChanged&lt;/a&gt;() if the frame changed.</source>
          <target state="translated">更新当前时间时，如果当前值发生更改，&lt;a href=&quot;qtimeline&quot;&gt;QTimeLine&lt;/a&gt;将发出&lt;a href=&quot;qtimeline#valueChanged&quot;&gt;valueChanged&lt;/a&gt;（），如果框架发生更改，则将发出&lt;a href=&quot;qtimeline#frameChanged&quot;&gt;frameChanged&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="daf7b6e7fdbba2dfca1eadbe18a1d7de3b720e7b" translate="yes" xml:space="preserve">
          <source>When used as a context menu, the recommended way of opening the menu is to call &lt;a href=&quot;qml-qtquick-controls2-menu#popup-method&quot;&gt;popup()&lt;/a&gt;. Unless a position is explicitly specified, the menu is positioned at the mouse cursor on desktop platforms that have a mouse cursor available, and otherwise centered over its parent item.</source>
          <target state="translated">当用作上下文菜单时，建议打开菜单的方法是调用&lt;a href=&quot;qml-qtquick-controls2-menu#popup-method&quot;&gt;popup（）&lt;/a&gt;。除非明确指定位置，否则菜单将位于有鼠标光标的桌面平台上的鼠标光标处，否则将位于其父项上方。</target>
        </trans-unit>
        <trans-unit id="e42ccc06c2943db340e29e9634bf18dbc9e13468" translate="yes" xml:space="preserve">
          <source>When used as a popup menu, it is easiest to specify the position by specifying the desired &lt;a href=&quot;qml-qtquick-controls2-popup#x-prop&quot;&gt;x&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-controls2-popup#y-prop&quot;&gt;y&lt;/a&gt; coordinates using the respective properties, and call &lt;a href=&quot;qml-qtquick-controls2-popup#open-method&quot;&gt;open()&lt;/a&gt; to open the menu.</source>
          <target state="translated">当用作弹出菜单时，最简单的方法是使用相应的属性通过指定所需的&lt;a href=&quot;qml-qtquick-controls2-popup#x-prop&quot;&gt;x&lt;/a&gt;和&lt;a href=&quot;qml-qtquick-controls2-popup#y-prop&quot;&gt;y&lt;/a&gt;坐标来指定位置，然后调用&lt;a href=&quot;qml-qtquick-controls2-popup#open-method&quot;&gt;open（）&lt;/a&gt;打开菜单。</target>
        </trans-unit>
        <trans-unit id="51c1a4b96d0ac9fe7349345183028fcd340a1cf9" translate="yes" xml:space="preserve">
          <source>When used as a standalone application,</source>
          <target state="translated">当作为一个独立的应用程序使用时。</target>
        </trans-unit>
        <trans-unit id="7c8523a9cdaa732605d1c3ca0c57e7327514b32b" translate="yes" xml:space="preserve">
          <source>When used as an interface type, &lt;a href=&quot;qstringview&quot;&gt;QStringView&lt;/a&gt; allows a single function to accept a wide variety of UTF-16 string data sources. One function accepting &lt;a href=&quot;qstringview&quot;&gt;QStringView&lt;/a&gt; thus replaces three function overloads (taking &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;, &lt;a href=&quot;qstringref&quot;&gt;QStringRef&lt;/a&gt;, and &lt;code&gt;(const QChar*, int)&lt;/code&gt;), while at the same time enabling even more string data sources to be passed to the function, such as &lt;code&gt;u&quot;Hello World&quot;&lt;/code&gt;, a &lt;code&gt;char16_t&lt;/code&gt; string literal.</source>
          <target state="translated">当用作接口类型时，&lt;a href=&quot;qstringview&quot;&gt;QStringView&lt;/a&gt;允许单个函数接受各种UTF-16字符串数据源。因此，一个接受&lt;a href=&quot;qstringview&quot;&gt;QStringView的&lt;/a&gt;函数替换了三个函数重载（采用&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;，&lt;a href=&quot;qstringref&quot;&gt;QStringRef&lt;/a&gt;和 &lt;code&gt;(const QChar*, int)&lt;/code&gt; ），同时允许将更多的字符串数据源传递给该函数，例如 &lt;code&gt;u&quot;Hello World&quot;&lt;/code&gt; ，一个 &lt;code&gt;char16_t&lt;/code&gt; 字符串文字。</target>
        </trans-unit>
        <trans-unit id="3d30f2719e4dfd488693920afd51d738514f58fc" translate="yes" xml:space="preserve">
          <source>When used as an interface type, QStringView allows a single function to accept a wide variety of UTF-16 string data sources. One function accepting QStringView thus replaces three function overloads (taking &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;, &lt;a href=&quot;qstringref&quot;&gt;QStringRef&lt;/a&gt;, and &lt;code&gt;(const QChar*, int)&lt;/code&gt;), while at the same time enabling even more string data sources to be passed to the function, such as &lt;code&gt;u&quot;Hello World&quot;&lt;/code&gt;, a &lt;code&gt;char16_t&lt;/code&gt; string literal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e868d59396f0fc788445bb00690275ea6245ac1" translate="yes" xml:space="preserve">
          <source>When used as flags, enumerators can be combined using the OR operator.</source>
          <target state="translated">当作为标志使用时,可以使用OR操作符将枚举器组合起来。</target>
        </trans-unit>
        <trans-unit id="06c2c617a12597a994b108366e0d50cfb932d1fd" translate="yes" xml:space="preserve">
          <source>When used as part of a Transition, you can also target a specific &lt;a href=&quot;qml-qtquick-statechangescript&quot;&gt;StateChangeScript&lt;/a&gt; to run using the &lt;code&gt;scriptName&lt;/code&gt; property.</source>
          <target state="translated">当用作过渡的一部分时，您还可以使用 &lt;code&gt;scriptName&lt;/code&gt; 属性将特定的&lt;a href=&quot;qml-qtquick-statechangescript&quot;&gt;StateChangeScript定位&lt;/a&gt;为运行。</target>
        </trans-unit>
        <trans-unit id="59f0102a4ce38b4f2ee3e6dec5be09d72963e0c7" translate="yes" xml:space="preserve">
          <source>When used in a &lt;a href=&quot;qml-qtquick-sequentialanimation&quot;&gt;SequentialAnimation&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-pauseanimation&quot;&gt;PauseAnimation&lt;/a&gt; is a step when nothing happens, for a specified duration.</source>
          <target state="translated">在&lt;a href=&quot;qml-qtquick-sequentialanimation&quot;&gt;SequentialAnimation中&lt;/a&gt;使用时，&lt;a href=&quot;qml-qtquick-pauseanimation&quot;&gt;PauseAnimation&lt;/a&gt;是在指定的持续时间内什么都没有发生的步骤。</target>
        </trans-unit>
        <trans-unit id="32a85cc6f1a776a818b49cfac1cb9534a2a52415" translate="yes" xml:space="preserve">
          <source>When used in a &lt;a href=&quot;qml-qtquick-sequentialanimation&quot;&gt;SequentialAnimation&lt;/a&gt;, PauseAnimation is a step when nothing happens, for a specified duration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1ec54421dbb8796f81a74d96171dee0c22a448e" translate="yes" xml:space="preserve">
          <source>When used in a transition, a property animation is assumed to match</source>
          <target state="translated">当在过渡期中使用时,属性动画被假设为与</target>
        </trans-unit>
        <trans-unit id="c62896cbdfc7c3f4c1df9f239489204e6ebe788a" translate="yes" xml:space="preserve">
          <source>When used in a transition, if no target is specified, all &lt;a href=&quot;qml-qtquick-parentchange&quot;&gt;ParentChange&lt;/a&gt; occurrences are animated by the &lt;a href=&quot;qml-qtquick-parentanimation&quot;&gt;ParentAnimation&lt;/a&gt;.</source>
          <target state="translated">在过渡中使用时，如果未指定目标，则所有&lt;a href=&quot;qml-qtquick-parentchange&quot;&gt;ParentChange&lt;/a&gt;事件均由&lt;a href=&quot;qml-qtquick-parentanimation&quot;&gt;ParentAnimation&lt;/a&gt;设置动画。</target>
        </trans-unit>
        <trans-unit id="28b437395e782784d83371eebd653fd7c3c66b90" translate="yes" xml:space="preserve">
          <source>When used in a transition, the path can be specified without start or end points, for example:</source>
          <target state="translated">例如,在过渡期中使用时,可以不指定路径的起始点或终点。</target>
        </trans-unit>
        <trans-unit id="ad15b94076fc6d62e74b16ac21ba031bb2e8713a" translate="yes" xml:space="preserve">
          <source>When used in combination with &lt;a href=&quot;qtreeview&quot;&gt;QTreeView&lt;/a&gt;, the first column is not movable (since it contains the tree structure), by default. You can make it movable with &lt;a href=&quot;qheaderview#firstSectionMovable-prop&quot;&gt;setFirstSectionMovable&lt;/a&gt;(true).</source>
          <target state="translated">当与&lt;a href=&quot;qtreeview&quot;&gt;QTreeView&lt;/a&gt;结合使用时，默认情况下第一列是不可移动的（因为它包含树结构）。您可以使用&lt;a href=&quot;qheaderview#firstSectionMovable-prop&quot;&gt;setFirstSectionMovable&lt;/a&gt;（true）使它可移动。</target>
        </trans-unit>
        <trans-unit id="80921d8c37af7cbb33ff4de031ae482a77195e92" translate="yes" xml:space="preserve">
          <source>When used in conjunction with QTextureWrapMode::Repeat, textureScale provides a simple way to tile a texture across a surface. For example, a texture scale of &lt;code&gt;4.0&lt;/code&gt; would result in 16 (4x4) tiles.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8adf2789c382dae59470f104ac31491a01be4c17" translate="yes" xml:space="preserve">
          <source>When used in conjunction with WrapMode.Repeat, textureScale provides a simple way to tile a texture across a surface. For example, a texture scale of &lt;code&gt;4.0&lt;/code&gt; would result in 16 (4x4) tiles.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="004dc51d90326bec6d46cfd29896a25f4617d992" translate="yes" xml:space="preserve">
          <source>When used in conjunction with the &lt;a href=&quot;qml-qtquick-loader#source-prop&quot;&gt;source&lt;/a&gt; property, loading and compilation will also be performed in a background thread.</source>
          <target state="translated">当与&lt;a href=&quot;qml-qtquick-loader#source-prop&quot;&gt;source&lt;/a&gt;属性一起使用时，加载和编译也将在后台线程中执行。</target>
        </trans-unit>
        <trans-unit id="50af634dadcc9340640490a9af221cd3bbb07199" translate="yes" xml:space="preserve">
          <source>When used in conjunction with the &lt;a href=&quot;qml-qtquick3d-loader3d#source-prop&quot;&gt;source&lt;/a&gt; property, loading and compilation will also be performed in a background thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b5ebb2f8eef3c956f23605775c3ca22ba3215b5" translate="yes" xml:space="preserve">
          <source>When used with list models, the first item in the returned list is used for matching.</source>
          <target state="translated">当与列表模型一起使用时,返回的列表中的第一个项目被用于匹配。</target>
        </trans-unit>
        <trans-unit id="2aa79e373766a60d20b2141aeac582a5a8df07d6" translate="yes" xml:space="preserve">
          <source>When user defines a new functor or generator, they need to implement the &lt;a href=&quot;qt3drender-qabstractfunctor#id&quot;&gt;QAbstractFunctor::id&lt;/a&gt;() method, which should be done using the &lt;code&gt;QT3D_FUNCTOR&lt;/code&gt; macro in the class definition.</source>
          <target state="translated">当用户定义新的函子或生成器时，他们需要实现&lt;a href=&quot;qt3drender-qabstractfunctor#id&quot;&gt;QAbstractFunctor :: id&lt;/a&gt;（）方法，该方法应使用类定义中的 &lt;code&gt;QT3D_FUNCTOR&lt;/code&gt; 宏来完成。</target>
        </trans-unit>
        <trans-unit id="1426cfebd5b7719f33b6e2b9f2a97f042b4572ab" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;qabstractscrollarea&quot;&gt;QAbstractScrollArea&lt;/a&gt; based widgets, you should enable the &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_AcceptTouchEvents&lt;/a&gt; attribute on the scroll area's &lt;a href=&quot;qabstractscrollarea#viewport&quot;&gt;viewport&lt;/a&gt;.</source>
          <target state="translated">使用基于&lt;a href=&quot;qabstractscrollarea&quot;&gt;QAbstractScrollArea&lt;/a&gt;的窗口小部件时，应在滚动区域的&lt;a href=&quot;qabstractscrollarea#viewport&quot;&gt;视口&lt;/a&gt;上启用&lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt :: WA_AcceptTouchEvents&lt;/a&gt;属性。</target>
        </trans-unit>
        <trans-unit id="575c3ca33cbc8c0e49967dd6868de7d0cd46c7ed" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;qfuture&quot;&gt;QFuture&lt;/a&gt;, transferred exceptions will be thrown when calling the following functions:</source>
          <target state="translated">使用&lt;a href=&quot;qfuture&quot;&gt;QFuture&lt;/a&gt;时，调用以下函数时将引发已传送的异常：</target>
        </trans-unit>
        <trans-unit id="6d8f6cec0c5597c992eb3a8a60ec3ad82996acf4" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;qml-qt3d-render-objectpicker&quot;&gt;ObjectPicker&lt;/a&gt; components, picking is triggered by mouse events.</source>
          <target state="translated">使用&lt;a href=&quot;qml-qt3d-render-objectpicker&quot;&gt;ObjectPicker&lt;/a&gt;组件时，鼠标事件触发选择。</target>
        </trans-unit>
        <trans-unit id="84a71d92671a35f5e7502b348babb72bc64cf8ed" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;qml-qt3d-render-raycaster&quot;&gt;RayCaster&lt;/a&gt; or &lt;a href=&quot;qml-qt3d-render-screenraycaster&quot;&gt;ScreenRayCaster&lt;/a&gt; components, picking can be explicitly triggered by the application.</source>
          <target state="translated">使用&lt;a href=&quot;qml-qt3d-render-raycaster&quot;&gt;RayCaster&lt;/a&gt;或&lt;a href=&quot;qml-qt3d-render-screenraycaster&quot;&gt;ScreenRayCaster&lt;/a&gt;组件时，拾取可以由应用程序显式触发。</target>
        </trans-unit>
        <trans-unit id="8b9d22db787646c3b272fef7eabbedc341942ce2" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;qpointer&quot;&gt;QPointer&lt;/a&gt; on a &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; (or a subclass of &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt;), previously the &lt;a href=&quot;qpointer&quot;&gt;QPointer&lt;/a&gt; would be cleared by the &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; destructor. Now, the &lt;a href=&quot;qpointer&quot;&gt;QPointer&lt;/a&gt; is cleared by the &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; destructor (since this is when &lt;a href=&quot;qweakpointer&quot;&gt;QWeakPointer&lt;/a&gt; objects are cleared). Any QPointers tracking a widget will &lt;b&gt;NOT&lt;/b&gt; be cleared before the &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; destructor destroys the children for the widget being tracked.</source>
          <target state="translated">当使用&lt;a href=&quot;qpointer&quot;&gt;QPointer&lt;/a&gt;上的&lt;a href=&quot;qwidget&quot;&gt;QWidget的&lt;/a&gt;（或子类&lt;a href=&quot;qwidget&quot;&gt;的QWidget&lt;/a&gt;），先前的&lt;a href=&quot;qpointer&quot;&gt;QPointer&lt;/a&gt;将通过清除&lt;a href=&quot;qwidget&quot;&gt;QWidget的&lt;/a&gt;析构函数。现在，通过&lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;析构函数清除&lt;a href=&quot;qpointer&quot;&gt;QPointer&lt;/a&gt;（因为这是清除&lt;a href=&quot;qweakpointer&quot;&gt;QWeakPointer&lt;/a&gt;对象的时间）。在&lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt;析构函数销毁要跟踪的窗口小部件的子级之前，&lt;b&gt;不会&lt;/b&gt;清除任何跟踪窗口小部件的QPointers 。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
