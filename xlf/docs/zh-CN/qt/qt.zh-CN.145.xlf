<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="qt">
    <body>
      <group id="qt">
        <trans-unit id="32b02425d9853ce65d20ccf60cd781de0c25f0fa" translate="yes" xml:space="preserve">
          <source>In a dialog, only one push button at a time can be the default button. This button is then displayed with an additional frame (depending on the GUI style).</source>
          <target state="translated">在一个对话框中,一次只能有一个按钮作为默认按钮。然后,这个按钮会以一个额外的框架来显示(取决于GUI的风格)。</target>
        </trans-unit>
        <trans-unit id="5840fc04c775cb5eafc17840ec2593d69d5e757d" translate="yes" xml:space="preserve">
          <source>In a dialog, you might create two data entry widgets and a label for each, and set up the geometry layout so each label is just to the left of its data entry widget (its &quot;buddy&quot;), for example:</source>
          <target state="translated">在一个对话框中,您可以创建两个数据输入部件和一个标签,并设置几何布局,使每个标签仅在其数据输入部件(其 &quot;好友&quot;)的左侧,例如。</target>
        </trans-unit>
        <trans-unit id="0223a182442f7895c0406cf184e3f8f02061a818" translate="yes" xml:space="preserve">
          <source>In a directory listed in the &lt;code&gt;QMAKEFEATURES&lt;/code&gt; environment variable that contains a list of directories delimited by the platform's path list separator (colon for Unix, semicolon for Windows).</source>
          <target state="translated">在 &lt;code&gt;QMAKEFEATURES&lt;/code&gt; 环境变量中列出的目录中，该目录包含由平台的路径列表分隔符（Unix为冒号，Windows为分号）分隔的目录列表。</target>
        </trans-unit>
        <trans-unit id="65e4400a6f0cc6b23439b153bd0bcdfaa94a1486" translate="yes" xml:space="preserve">
          <source>In a directory listed in the &lt;code&gt;QMAKEFEATURES&lt;/code&gt; property variable that contains a list of directories delimited by the platform's path list separator.</source>
          <target state="translated">在 &lt;code&gt;QMAKEFEATURES&lt;/code&gt; 属性变量中列出的目录中，该目录包含由平台的路径列表分隔符分隔的目录列表。</target>
        </trans-unit>
        <trans-unit id="3ff5c7a849ff5c8fe8062e09e1d7738485395550" translate="yes" xml:space="preserve">
          <source>In a features directory residing beneath the directory provided by the &lt;a href=&quot;qmake-environment-reference#qmakespec&quot;&gt;QMAKESPEC&lt;/a&gt; environment variable. For example: &lt;code&gt;$QMAKESPEC/&amp;lt;features&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">在功能目录中，该目录位于&lt;a href=&quot;qmake-environment-reference#qmakespec&quot;&gt;QMAKESPEC&lt;/a&gt;环境变量提供的目录下。例如： &lt;code&gt;$QMAKESPEC/&amp;lt;features&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f60fa36c0fdf26b6763bb3e61aff44f2c4143e32" translate="yes" xml:space="preserve">
          <source>In a features directory residing in the &lt;code&gt;data_install/mkspecs&lt;/code&gt; directory. For example: &lt;code&gt;data_install/mkspecs/&amp;lt;features&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">在位于 &lt;code&gt;data_install/mkspecs&lt;/code&gt; 目录中的功能目录中。例如： &lt;code&gt;data_install/mkspecs/&amp;lt;features&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="074d7f8495491bc45054ca37812e0a8211941cb7" translate="yes" xml:space="preserve">
          <source>In a features directory residing within a &lt;code&gt;mkspecs&lt;/code&gt; directory. &lt;code&gt;mkspecs&lt;/code&gt; directories can be located beneath any of the directories listed in the &lt;code&gt;QMAKEPATH&lt;/code&gt; environment variable that contains a list of directories delimited by the platform's path list separator. For example: &lt;code&gt;$QMAKEPATH/mkspecs/&amp;lt;features&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;mkspecs&lt;/code&gt; 目录中的features目录中。 &lt;code&gt;mkspecs&lt;/code&gt; 目录可以位于 &lt;code&gt;QMAKEPATH&lt;/code&gt; 环境变量中列出的任何目录下，该目录包含由平台的路径列表分隔符分隔的目录列表。例如： &lt;code&gt;$QMAKEPATH/mkspecs/&amp;lt;features&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="057beeea1f96dcb8cf250e01fe97b0226a7d338e" translate="yes" xml:space="preserve">
          <source>In a features directory that exists as a sibling of the directory specified by the &lt;code&gt;QMAKESPEC&lt;/code&gt; environment variable. For example: &lt;code&gt;$QMAKESPEC/../&amp;lt;features&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">在功能目录中，该目录作为 &lt;code&gt;QMAKESPEC&lt;/code&gt; 环境变量指定的目录的同级存在。例如： &lt;code&gt;$QMAKESPEC/../&amp;lt;features&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5456bb8b747a03034dc4d04d4a515509b5440144" translate="yes" xml:space="preserve">
          <source>In a framework project, this variable contains the name to be used for the framework that is built.</source>
          <target state="translated">在一个框架项目中,这个变量包含了要用于构建的框架的名称。</target>
        </trans-unit>
        <trans-unit id="cf0f5be9f92923592abdfcf59ee582bc84bb5458" translate="yes" xml:space="preserve">
          <source>In a future version, some may be marked as deploy-time static and be moved during the deployment step as an optimization. As selectors come with a performance cost, it is recommended to avoid their use in circumstances involving performance-critical code.</source>
          <target state="translated">在未来的版本中,有些可能会被标记为部署时静态,并在部署步骤中作为优化被移动。由于选择器是有性能代价的,建议避免在涉及性能关键型代码的情况下使用它们。</target>
        </trans-unit>
        <trans-unit id="57f591bcef10c6dbe2444406829777a8fc30da46" translate="yes" xml:space="preserve">
          <source>In a multi-process system, if one client has a memory leak and consumes lots of memory, that memory is recovered when that client exits. In contrast with single-process, the memory leak remains until the entire system restarts.</source>
          <target state="translated">在多进程系统中,如果一个客户端出现了内存泄漏,消耗了大量的内存,当该客户端退出时,该内存就会被恢复。与单进程不同的是,在整个系统重新启动之前,内存泄漏一直存在。</target>
        </trans-unit>
        <trans-unit id="b797d3e2bc0d1169f32746140230ecfa781372a8" translate="yes" xml:space="preserve">
          <source>In a non-const member function of &lt;code&gt;Employee&lt;/code&gt;, whenever the</source>
          <target state="translated">在 &lt;code&gt;Employee&lt;/code&gt; 的非常量成员函数中，每当</target>
        </trans-unit>
        <trans-unit id="8af648be3237f594b90af346057fd024db5cd072" translate="yes" xml:space="preserve">
          <source>In a non-exclusive group, checking and unchecking actions does not affect the other actions in the group. Furthermore, the value of the &lt;a href=&quot;qml-qtquick-controls2-actiongroup#checkedAction-prop&quot;&gt;checkedAction&lt;/a&gt; property is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">在非独占组中，选中和取消选中操作不会影响该组中的其他操作。此外，&lt;a href=&quot;qml-qtquick-controls2-actiongroup#checkedAction-prop&quot;&gt;checkedAction&lt;/a&gt;属性的值为 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ecc1085249b660e214f6ce7b1f833baaba59a9dc" translate="yes" xml:space="preserve">
          <source>In a non-exclusive group, checking and unchecking buttons does not affect the other buttons in the group. Furthermore, the value of the &lt;a href=&quot;qml-qtquick-controls2-buttongroup#checkedButton-prop&quot;&gt;checkedButton&lt;/a&gt; property is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">在非排他性组中，选中和取消选中按钮不会影响该组中的其他按钮。此外，&lt;a href=&quot;qml-qtquick-controls2-buttongroup#checkedButton-prop&quot;&gt;checkedButton&lt;/a&gt;属性的值为 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="47c8a951ead74ffc551cf228f129ac458a517bde" translate="yes" xml:space="preserve">
          <source>In a project file, variables are used to hold lists of strings. In the simplest projects, these variables inform qmake about the configuration options to use, or supply filenames and paths to use in the build process.</source>
          <target state="translated">在一个项目文件中,变量是用来存放字符串列表的,在最简单的项目中,这些变量会告知qmake要使用的配置选项,或者提供文件名和路径。在最简单的项目中,这些变量会告知qmake要使用的配置选项,或者提供构建过程中要使用的文件名和路径。</target>
        </trans-unit>
        <trans-unit id="c6d745760babbf9ff3b6f363a6bbf25b6fc4996b" translate="yes" xml:space="preserve">
          <source>In a project with multiple sub-projects (for example, Qt modules), each sub-project typically defines its own landing page while the same home page is used across all sub-projects.</source>
          <target state="translated">在一个有多个子项目的项目中(例如Qt模块),每个子项目通常会定义自己的着陆页,而所有子项目都使用同一个主页。</target>
        </trans-unit>
        <trans-unit id="50a12001eea6b5a938330a3657e270c884c78bb9" translate="yes" xml:space="preserve">
          <source>In a read-only text edit the user can only navigate through the text and select text; modifying the text is not possible.</source>
          <target state="translated">在只读文本编辑中,用户只能浏览文本和选择文本,修改文本是不可能的。</target>
        </trans-unit>
        <trans-unit id="5c9aacdc19410c07bfb1fad74e785fca733026bd" translate="yes" xml:space="preserve">
          <source>In a real world scenario, you do not want to have dependencies of the application making use of the custom widgets to the</source>
          <target state="translated">在现实世界的场景中,你不希望应用程序的依赖性,利用自定义widget到的</target>
        </trans-unit>
        <trans-unit id="35202bd5c646f9ca02c711f689dea2f022787aa8" translate="yes" xml:space="preserve">
          <source>In a separate Window.</source>
          <target state="translated">在一个单独的窗口中。</target>
        </trans-unit>
        <trans-unit id="e66b37a78da29f7ea0ca0a0b99d6191a01fd3bdc" translate="yes" xml:space="preserve">
          <source>In a signal handler</source>
          <target state="translated">在信号处理机中</target>
        </trans-unit>
        <trans-unit id="f70847208d54651f184f1d885d85b25a4cf196b7" translate="yes" xml:space="preserve">
          <source>In a similar manner only the center of a bounding box is taken into consideration when searching. The boundaries of the box are not honored.</source>
          <target state="translated">类似地,在搜索时只考虑边界框的中心。框的边界不被尊重。</target>
        </trans-unit>
        <trans-unit id="124eb1a9a370c1e5f9d89da45e2d578d93580351" translate="yes" xml:space="preserve">
          <source>In a similar way, you can later use your customized XML file:</source>
          <target state="translated">以类似的方式,你以后可以使用你定制的XML文件。</target>
        </trans-unit>
        <trans-unit id="3153a2a6f46323be3744bca7b05701c4ca2608a9" translate="yes" xml:space="preserve">
          <source>In a single-process system, all clients can access each other's memory. For example, there's no isolation for sensitive data transfer; every line of code must be equally trustworthy. This isolation is there, by design, in multi-process systems.</source>
          <target state="translated">在单进程系统中,所有的客户端都可以访问对方的内存。例如,敏感数据的传输没有隔离,每一行代码都必须是同样可信的。在多进程系统中,通过设计,这种隔离是存在的。</target>
        </trans-unit>
        <trans-unit id="93cfe35695a7f4b787bebce9d4c376b5630c5bff" translate="yes" xml:space="preserve">
          <source>In a single-process system, all parts of the UI run in one, single process. In a multi-process system, all clients run in their own, dedicated process. With Qt, at any point in your development process, you can choose to switch between single-process and multi-process.</source>
          <target state="translated">在单进程系统中,UI的所有部分都运行在一个单一的进程中。在多进程系统中,所有的客户端都运行在自己的专用进程中。使用Qt,在开发过程中的任何时候,您都可以选择在单进程和多进程之间切换。</target>
        </trans-unit>
        <trans-unit id="df30b4977c6a16aeadaeda81729eb4d5f6275427" translate="yes" xml:space="preserve">
          <source>In a single-process system, if you're using the same textures, background, or icons in many places, those images are only stored once. In contrast, if you use these images in a multi-process system, then you have to store them multiple times. In this case, one solution is to share graphical resource between clients. Qt already allows sharing image resources in main memory across processes without involving Wayland. Sharing GPU textures across processes, on the other hand, requires more intricate solutions. Such solutions are currently in development for the Qt Wayland Compositor.</source>
          <target state="translated">在单进程系统中,如果你在很多地方使用相同的纹理、背景或图标,这些图像只需存储一次。相反,如果你在多进程系统中使用这些图像,那么你必须多次存储它们。在这种情况下,一种解决方案是在客户端之间共享图形资源。Qt已经允许跨进程共享主内存中的图像资源,而不涉及Wayland。另一方面,跨进程共享GPU纹理则需要更复杂的解决方案。这种解决方案目前正在为Qt Wayland Compositor开发。</target>
        </trans-unit>
        <trans-unit id="ecb1f268902adf4a8cbf75c866ab70bbd18f3c9c" translate="yes" xml:space="preserve">
          <source>In a situation such as the above, it is still possible to retrieve the actual matrix determinant by setting the RequiresDeterminant flag in the material and calling the &lt;a href=&quot;qsgmaterialrhishader-renderstate#determinant&quot;&gt;determinant&lt;/a&gt;() accessor.</source>
          <target state="translated">在上述情况下，仍然可以通过在材料中设置RequiresDeterminant标志并调用&lt;a href=&quot;qsgmaterialrhishader-renderstate#determinant&quot;&gt;determinant&lt;/a&gt;（）访问器来检索实际的矩阵行列式。</target>
        </trans-unit>
        <trans-unit id="0186a5ac830e37b10101828cfdbf3877f56f7125" translate="yes" xml:space="preserve">
          <source>In a situation such as the above, it is still possible to retrieve the actual matrix determinant by setting the RequiresDeterminant flag in the material and calling the &lt;a href=&quot;qsgmaterialshader-renderstate#determinant&quot;&gt;determinant&lt;/a&gt;() accessor.</source>
          <target state="translated">在上述情况下，仍然可以通过在材料中设置RequiresDeterminant标志并调用&lt;a href=&quot;qsgmaterialshader-renderstate#determinant&quot;&gt;determinant&lt;/a&gt;（）访问器来检索实际的矩阵行列式。</target>
        </trans-unit>
        <trans-unit id="74ff351856fd5aa0b4dd6182c28bfc2e05f06733" translate="yes" xml:space="preserve">
          <source>In a tab of the same window, without hiding the currently visible web engine view.</source>
          <target state="translated">在同一窗口的一个标签页中,不隐藏当前可见的网络引擎视图。</target>
        </trans-unit>
        <trans-unit id="ed375bcdf79a7ea9640ff4a86c37b210370ba4a7" translate="yes" xml:space="preserve">
          <source>In a tab of the same window.</source>
          <target state="translated">在同一窗口的一个标签中。</target>
        </trans-unit>
        <trans-unit id="2d5fcb572360924dfa9646ae46cfedc4060afe15" translate="yes" xml:space="preserve">
          <source>In a typical multi-head configuration, multiple physical monitors are combined in one X11 screen. This means this method returns the same number for each of the physical monitors. In such a setup you are interested in the monitor information as provided by the X11 RandR extension. This is available through QDesktopWidget and QScreen.</source>
          <target state="translated">在典型的多头配置中,多个物理显示器被组合在一个X11屏幕中。这意味着该方法为每个物理显示器返回相同的数字。在这样的设置中,你对X11 RandR扩展所提供的显示器信息感兴趣。这可以通过QDesktopWidget和QScreen获得。</target>
        </trans-unit>
        <trans-unit id="32434ce60c560ceb6a77ff3dda094acfb7645559" translate="yes" xml:space="preserve">
          <source>In a view, there is always a current item and a selected item - two independent states. An item can be the current item and selected at the same time. The view is responsible for ensuring that there is always a current item as keyboard navigation, for example, requires a current item.</source>
          <target state="translated">在一个视图中,总是有一个当前项和一个选中项--两个独立的状态。一个项可以同时是当前项和选中项。视图负责确保始终有一个当前项,例如键盘导航需要一个当前项。</target>
        </trans-unit>
        <trans-unit id="61525c42caac5b47fd6e085f79ed17ef7bb39940" translate="yes" xml:space="preserve">
          <source>In accordance with ISO 8601, each week falls in the year to which most of its days belong, in the Gregorian calendar. As ISO 8601's week starts on Monday, this is the year in which the week's Thursday falls. Most years have 52 weeks, but some have 53.</source>
          <target state="translated">根据ISO 8601标准,每一周都是在其大部分日子所属的年份,即格里高利历。由于ISO 8601的一周从周一开始,所以该周的星期四就在这一年。大多数年份有52周,但有些年份有53周。</target>
        </trans-unit>
        <trans-unit id="3af86b961f912e442202b68c4f0ceaec0a9a306c" translate="yes" xml:space="preserve">
          <source>In accordance with ISO 8601, weeks start on Monday and the first Thursday of a year is always in week 1 of that year. Most years have 52 weeks, but some have 53.</source>
          <target state="translated">根据ISO 8601,周数从星期一开始,一年的第一个星期四总是在该年的第1周。大多数年份有52周,但有些年份有53周。</target>
        </trans-unit>
        <trans-unit id="683d8c3e3a66c0acad5edcd82caa9ee007b84f7c" translate="yes" xml:space="preserve">
          <source>In addition &lt;a href=&quot;qaudiorecorder&quot;&gt;QAudioRecorder&lt;/a&gt; provides functionality for selecting the audio input.</source>
          <target state="translated">此外，&lt;a href=&quot;qaudiorecorder&quot;&gt;QAudioRecorder&lt;/a&gt;还提供用于选择音频输入的功能。</target>
        </trans-unit>
        <trans-unit id="c47cb2960d27520cc8cee5127eccd6ebc2460762" translate="yes" xml:space="preserve">
          <source>In addition &lt;a href=&quot;qpen&quot;&gt;QPen&lt;/a&gt; provides the &lt;a href=&quot;qpen#color&quot;&gt;color&lt;/a&gt;() and &lt;a href=&quot;qpen#setColor&quot;&gt;setColor&lt;/a&gt;() convenience functions to extract and set the color of the pen's brush, respectively. Pens may also be compared and streamed.</source>
          <target state="translated">此外，&lt;a href=&quot;qpen&quot;&gt;QPen&lt;/a&gt;提供了&lt;a href=&quot;qpen#color&quot;&gt;color&lt;/a&gt;（）和&lt;a href=&quot;qpen#setColor&quot;&gt;setColor&lt;/a&gt;（）便捷功能，分别提取和设置笔刷的颜色。笔也可以进行比较和流式传输。</target>
        </trans-unit>
        <trans-unit id="5a77f78edbc889ca45627b477008bb777297ced4" translate="yes" xml:space="preserve">
          <source>In addition QAudioRecorder provides functionality for selecting the audio input.</source>
          <target state="translated">此外QAudioRecorder还提供了选择音频输入的功能。</target>
        </trans-unit>
        <trans-unit id="e0ebfec8badc68fa8c9a18fecc7072ba8185809c" translate="yes" xml:space="preserve">
          <source>In addition QPen provides the &lt;a href=&quot;qpen#color&quot;&gt;color&lt;/a&gt;() and &lt;a href=&quot;qpen#setColor&quot;&gt;setColor&lt;/a&gt;() convenience functions to extract and set the color of the pen's brush, respectively. Pens may also be compared and streamed.</source>
          <target state="translated">此外，QPen提供了&lt;a href=&quot;qpen#color&quot;&gt;color&lt;/a&gt;（）和&lt;a href=&quot;qpen#setColor&quot;&gt;setColor&lt;/a&gt;（）便捷功能，分别提取和设置笔刷的颜色。笔也可以进行比较和流式传输。</target>
        </trans-unit>
        <trans-unit id="a0379878d7d72c63efc971f1bdb08e5ede18e4c6" translate="yes" xml:space="preserve">
          <source>In addition the following expressions can be used to specify the time:</source>
          <target state="translated">此外,还可以使用以下表达式来指定时间。</target>
        </trans-unit>
        <trans-unit id="df9ef188c1cb674d205e023d5ddf6254baaafb97" translate="yes" xml:space="preserve">
          <source>In addition the type's QML file must have pragma Singleton statement among its import statements.</source>
          <target state="translated">此外,该类型的QML文件必须在其导入语句中包含Pragma Singleton语句。</target>
        </trans-unit>
        <trans-unit id="17d38f6932f39d7e48e129266f5198f583c62f19" translate="yes" xml:space="preserve">
          <source>In addition to &lt;a href=&quot;qaccessible&quot;&gt;QAccessible&lt;/a&gt;'s static functions, Qt offers one generic interface, &lt;a href=&quot;qaccessibleinterface&quot;&gt;QAccessibleInterface&lt;/a&gt;, that can be used to wrap all widgets and objects (e.g., &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt;). This single interface provides all the metadata necessary for the assistive technologies. Qt provides implementations of this interface for its built-in widgets as plugins.</source>
          <target state="translated">除了&lt;a href=&quot;qaccessible&quot;&gt;QAccessible&lt;/a&gt;的静态函数，Qt还提供了一个通用接口&lt;a href=&quot;qaccessibleinterface&quot;&gt;QAccessibleInterface&lt;/a&gt;，可用于包装所有小部件和对象（例如&lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt;）。该单一界面提供了辅助技术所需的所有元数据。 Qt为其内置小部件（作为插件）提供了此接口的实现。</target>
        </trans-unit>
        <trans-unit id="58764f3dc838568b7a78fe42c0db905846e95ebf" translate="yes" xml:space="preserve">
          <source>In addition to &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt;, Qt also provides the &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; class to store string data. For most purposes, &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; is the class you want to use. It stores 16-bit Unicode characters, making it easy to store non-ASCII/non-Latin-1 characters in your application. Furthermore, &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; is used throughout in the Qt API. The two main cases where &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; is appropriate are when you need to store raw binary data, and when memory conservation is critical (e.g., with Qt for Embedded Linux).</source>
          <target state="translated">除了&lt;a href=&quot;qbytearray&quot;&gt;QByteArray之外&lt;/a&gt;，Qt还提供了&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;类来存储字符串数据。对于大多数目的，&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;是您要使用的类。它存储16位Unicode字符，使在应用程序中轻松存储非ASCII /非拉丁1字符成为可能。此外，在Qt API中始终使用&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;。&lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt;适用的两种主要情况是：您需要存储原始二进制数据时，以及内存保护至关重要时（例如，对于嵌入式Linux使用Qt）。</target>
        </trans-unit>
        <trans-unit id="1fcc475fabc680f5d514ea0a74271c19204252af" translate="yes" xml:space="preserve">
          <source>In addition to &lt;a href=&quot;qsqlquery&quot;&gt;QSqlQuery&lt;/a&gt;, Qt offers three higher-level classes for accessing databases. These classes are &lt;a href=&quot;qsqlquerymodel&quot;&gt;QSqlQueryModel&lt;/a&gt;, &lt;a href=&quot;qsqltablemodel&quot;&gt;QSqlTableModel&lt;/a&gt;, and &lt;a href=&quot;qsqlrelationaltablemodel&quot;&gt;QSqlRelationalTableModel&lt;/a&gt;.</source>
          <target state="translated">除了&lt;a href=&quot;qsqlquery&quot;&gt;QSqlQuery之外&lt;/a&gt;，Qt还提供了三个用于访问数据库的更高级别的类。这些类是&lt;a href=&quot;qsqlquerymodel&quot;&gt;QSqlQueryModel&lt;/a&gt;，&lt;a href=&quot;qsqltablemodel&quot;&gt;QSqlTableModel&lt;/a&gt;和&lt;a href=&quot;qsqlrelationaltablemodel&quot;&gt;QSqlRelationalTableModel&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bb0f23f32742c7c2e59f50364b2e13280c9d3869" translate="yes" xml:space="preserve">
          <source>In addition to &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;, Qt also provides the &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; class to store raw bytes and traditional 8-bit '\0'-terminated strings. For most purposes, &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; is the class you want to use. It is used throughout the Qt API, and the Unicode support ensures that your applications will be easy to translate if you want to expand your application's market at some point. The two main cases where &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; is appropriate are when you need to store raw binary data, and when memory conservation is critical (like in embedded systems).</source>
          <target state="translated">除了&lt;a href=&quot;qstring&quot;&gt;QString之外&lt;/a&gt;，Qt还提供&lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt;类来存储原始字节和传统的以8位'\ 0'终止的字符串。对于大多数目的，&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;是您要使用的类。它在整个Qt API中使用，并且Unicode支持可确保您希望在某个时候扩展应用程序市场时轻松地翻译您的应用程序。&lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt;适用的两种主要情况是：您需要存储原始二进制数据时，以及内存保留至关重要时（例如在嵌入式系统中）。</target>
        </trans-unit>
        <trans-unit id="2ff80e50f3f3cc96e7e113a02a60316d0af440e9" translate="yes" xml:space="preserve">
          <source>In addition to &lt;a href=&quot;qtsql-changes-qt6#qsqlquery&quot;&gt;QSqlQuery&lt;/a&gt;, Qt offers three higher-level classes for accessing databases. These classes are &lt;a href=&quot;qsqlquerymodel&quot;&gt;QSqlQueryModel&lt;/a&gt;, &lt;a href=&quot;qsqltablemodel&quot;&gt;QSqlTableModel&lt;/a&gt;, and &lt;a href=&quot;qsqlrelationaltablemodel&quot;&gt;QSqlRelationalTableModel&lt;/a&gt;.</source>
          <target state="translated">除了&lt;a href=&quot;qtsql-changes-qt6#qsqlquery&quot;&gt;QSqlQuery之外&lt;/a&gt;，Qt还提供了三个用于访问数据库的更高级别的类。这些类是&lt;a href=&quot;qsqlquerymodel&quot;&gt;QSqlQueryModel&lt;/a&gt;，&lt;a href=&quot;qsqltablemodel&quot;&gt;QSqlTableModel&lt;/a&gt;和&lt;a href=&quot;qsqlrelationaltablemodel&quot;&gt;QSqlRelationalTableModel&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0bb10a136edeed1290e419aec55791d22496b61f" translate="yes" xml:space="preserve">
          <source>In addition to &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt;, Qt also provides &lt;a href=&quot;qvarlengtharray&quot;&gt;QVarLengthArray&lt;/a&gt;, a very low-level class with little functionality that is optimized for speed.</source>
          <target state="translated">除了&lt;a href=&quot;qvector&quot;&gt;QVector之外&lt;/a&gt;，Qt还提供&lt;a href=&quot;qvarlengtharray&quot;&gt;QVarLengthArray&lt;/a&gt;，这是一个非常底层的类，几乎没有针对速度进行优化的功能。</target>
        </trans-unit>
        <trans-unit id="f6dd8027e4df78dd3d3c0fe582211fdaf0b1a0fd" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;QT_QPA_EGLFS_DEBUG&lt;/code&gt;, &lt;code&gt;eglfs&lt;/code&gt; also supports Qt's modern categorized logging system. The following logging categories are available:</source>
          <target state="translated">除了 &lt;code&gt;QT_QPA_EGLFS_DEBUG&lt;/code&gt; 之外， &lt;code&gt;eglfs&lt;/code&gt; 还支持Qt的现代分类日志系统。以下日志记录类别可用：</target>
        </trans-unit>
        <trans-unit id="44b5febe92f9b7dabfe294b1a92afea290dc6cb8" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;QT_QPA_EGLFS_DEBUG&lt;/code&gt;, eglfs also supports the more modern categorized logging system of Qt. The following logging categories are available:</source>
          <target state="translated">除了 &lt;code&gt;QT_QPA_EGLFS_DEBUG&lt;/code&gt; 之外，eglfs还支持更现代的Qt分类日志系统。以下日志记录类别可用：</target>
        </trans-unit>
        <trans-unit id="9bf249f6281c6efae2c6fd1e64ccd58e52b76d3a" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;foreach&lt;/code&gt;, Qt also provides a &lt;code&gt;forever&lt;/code&gt; pseudo-keyword for infinite loops:</source>
          <target state="translated">除了 &lt;code&gt;foreach&lt;/code&gt; 之外，Qt还为无限循环提供了 &lt;code&gt;forever&lt;/code&gt; 伪关键字：</target>
        </trans-unit>
        <trans-unit id="c5cb3a1821f20774222d57b7872a2df90d980b43" translate="yes" xml:space="preserve">
          <source>In addition to OpenGL, the &lt;code&gt;software&lt;/code&gt; backend of Qt Quick also supports &lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt;. Other backends, for example the Direct 3D 12 one, are not compatible however and attempting to construct a &lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt; will lead to problems.</source>
          <target state="translated">除OpenGL外，Qt Quick 的 &lt;code&gt;software&lt;/code&gt; 后端还支持&lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt;。其他后端，例如Direct 3D 12，则不兼容，但是尝试构造&lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt;将导致问题。</target>
        </trans-unit>
        <trans-unit id="3d44fcc3edabbed7fb44af03ec5b774fc131d748" translate="yes" xml:space="preserve">
          <source>In addition to OpenGL, the &lt;code&gt;software&lt;/code&gt; backend of Qt Quick also supports QQuickWidget. Other backends, for example &lt;a href=&quot;qtquick-visualcanvas-adaptations#openvg&quot;&gt;OpenVG&lt;/a&gt;, are not compatible however and attempting to construct a QQuickWidget will lead to problems.</source>
          <target state="translated">除OpenGL外，Qt Quick的 &lt;code&gt;software&lt;/code&gt; 后端还支持QQuickWidget。但是其他后端（例如&lt;a href=&quot;qtquick-visualcanvas-adaptations#openvg&quot;&gt;OpenVG&lt;/a&gt;）不兼容，尝试构造QQuickWidget会导致问题。</target>
        </trans-unit>
        <trans-unit id="2377e52057df7bb60d9b7d93a8cf7f5b586e800b" translate="yes" xml:space="preserve">
          <source>In addition to OpenGL, the &lt;code&gt;software&lt;/code&gt; backend of Qt Quick also supports QQuickWidget. Other backends, for example the Direct 3D 12 one, are not compatible however and attempting to construct a QQuickWidget will lead to problems.</source>
          <target state="translated">除OpenGL外，Qt Quick的 &lt;code&gt;software&lt;/code&gt; 后端还支持QQuickWidget。其他后端，例如Direct 3D 12，则不兼容，但是尝试构造QQuickWidget会导致问题。</target>
        </trans-unit>
        <trans-unit id="62e1c573c57c1da1208cee3145a4e243f9a40dc3" translate="yes" xml:space="preserve">
          <source>In addition to QAccessible's static functions, Qt offers one generic interface, &lt;a href=&quot;qaccessibleinterface&quot;&gt;QAccessibleInterface&lt;/a&gt;, that can be used to wrap all widgets and objects (e.g., &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt;). This single interface provides all the metadata necessary for the assistive technologies. Qt provides implementations of this interface for its built-in widgets as plugins.</source>
          <target state="translated">除了QAccessible的静态函数之外，Qt还提供了一个通用接口&lt;a href=&quot;qaccessibleinterface&quot;&gt;QAccessibleInterface&lt;/a&gt;，该接口可用于包装所有小部件和对象（例如&lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt;）。这个单一的界面提供了辅助技术所需的所有元数据。Qt为其内置小部件（作为插件）提供了此接口的实现。</target>
        </trans-unit>
        <trans-unit id="cf055029b3027700cb7c857d06c21531bddcf24a" translate="yes" xml:space="preserve">
          <source>In addition to QByteArray, Qt also provides the &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; class to store string data. For most purposes, &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; is the class you want to use. It stores 16-bit Unicode characters, making it easy to store non-ASCII/non-Latin-1 characters in your application. Furthermore, &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; is used throughout in the Qt API. The two main cases where QByteArray is appropriate are when you need to store raw binary data, and when memory conservation is critical (e.g., with Qt for Embedded Linux).</source>
          <target state="translated">除了QByteArray，Qt还提供了&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;类来存储字符串数据。对于大多数目的，&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;是您要使用的类。它存储16位Unicode字符，从而可以轻松地在应用程序中存储非ASCII /非拉丁1字符。此外，在Qt API中始终使用&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;。QByteArray适用的两个主要情况是：您需要存储原始二进制数据时，以及内存保护至关重要时（例如，对于嵌入式Linux使用Qt）。</target>
        </trans-unit>
        <trans-unit id="30a7570b80e29edffe1d1ee1edfac5a1928d3fb8" translate="yes" xml:space="preserve">
          <source>In addition to QByteArray, Qt also provides the &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; class to store string data. For most purposes, &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; is the class you want to use. It understands its content as Unicode text (encoded using UTF-16) where QByteArray aims to avoid assumptions about the encoding or semantics of the bytes it stores (aside from a few legacy cases where it uses ASCII). Furthermore, &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; is used throughout in the Qt API. The two main cases where QByteArray is appropriate are when you need to store raw binary data, and when memory conservation is critical (e.g., with Qt for Embedded Linux).</source>
          <target state="translated">除了QByteArray，Qt还提供了&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;类来存储字符串数据。对于大多数目的，&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;是您要使用的类。它将其内容理解为Unicode文本（使用UTF-16编码），其中QByteArray旨在避免对其存储的字节的编码或语义进行假设（除了一些使用ASCII的传统情况）。此外，在Qt API中始终使用&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;。QByteArray适用的两个主要情况是：您需要存储原始二进制数据时，以及内存保护至关重要时（例如，对于嵌入式Linux使用Qt）。</target>
        </trans-unit>
        <trans-unit id="2b32c9857ac58ce5f4a53162ca2900d7c44de025" translate="yes" xml:space="preserve">
          <source>In addition to QList, Qt also provides &lt;a href=&quot;qvarlengtharray&quot;&gt;QVarLengthArray&lt;/a&gt;, a very low-level class with little functionality that is optimized for speed.</source>
          <target state="translated">除了QList之外，Qt还提供&lt;a href=&quot;qvarlengtharray&quot;&gt;QVarLengthArray&lt;/a&gt;，这是一个非常低级的类，几乎没有针对速度进行优化的功能。</target>
        </trans-unit>
        <trans-unit id="806da2e753ba5a3c323b35c747ac1f15e66ebe88" translate="yes" xml:space="preserve">
          <source>In addition to QString, Qt also provides the &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; class to store raw bytes and traditional 8-bit '\0'-terminated strings. For most purposes, QString is the class you want to use. It is used throughout the Qt API, and the Unicode support ensures that your applications will be easy to translate if you want to expand your application's market at some point. The two main cases where &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; is appropriate are when you need to store raw binary data, and when memory conservation is critical (like in embedded systems).</source>
          <target state="translated">除了QString，Qt还提供了&lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt;类来存储原始字节和传统的以8位'\ 0'终止的字符串。对于大多数目的，QString是您要使用的类。它在整个Qt API中使用，并且Unicode支持确保如果您想在某个时候扩展应用程序市场，则可以轻松地翻译您的应用程序。&lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt;适用的两种主要情况是：您需要存储原始二进制数据时，以及内存保留至关重要时（例如在嵌入式系统中）。</target>
        </trans-unit>
        <trans-unit id="361e8b05e11dc6b8bae0de93eba839ea2379112a" translate="yes" xml:space="preserve">
          <source>In addition to QVector, Qt also provides &lt;a href=&quot;qvarlengtharray&quot;&gt;QVarLengthArray&lt;/a&gt;, a very low-level class with little functionality that is optimized for speed.</source>
          <target state="translated">除了QVector之外，Qt还提供&lt;a href=&quot;qvarlengtharray&quot;&gt;QVarLengthArray&lt;/a&gt;，这是一个非常低级的类，几乎没有针对速度进行优化的功能。</target>
        </trans-unit>
        <trans-unit id="7b2804da3db3ffeb7c4eaf5a3b1106f875dcd822" translate="yes" xml:space="preserve">
          <source>In addition to Qt Quick and native OpenGL applications, EGLFS supports software-rendered windows, like &lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;QWidget&lt;/a&gt;, too. For &lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;QWidget&lt;/a&gt;, the widgets' contents are rendered using the CPU into images, which are then uploaded into textures and composited by the plugin.</source>
          <target state="translated">除了Qt Quick和本机OpenGL应用程序之外，EGLFS还支持软件渲染的窗口，例如&lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;QWidget&lt;/a&gt;。对于&lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;QWidget&lt;/a&gt;，小部件的内容使用CPU渲染为图像，然后将其上载为纹理并由插件进行合成。</target>
        </trans-unit>
        <trans-unit id="ca3d8881625f1cc734f7cb3e67b13d3865fca7b5" translate="yes" xml:space="preserve">
          <source>In addition to adjusting project files and including headers, the application should also manually set the rendering backend to OpenGL in order to use this functionality when working with Qt Quick. By default, Qt will use the most appropriate graphics API on the target platform. See the &lt;a href=&quot;qtquick-visualcanvas-scenegraph-renderer#rendering-via-the-qt-rendering-hardware-interface&quot;&gt;RHI rendering documentation&lt;/a&gt; for more details.</source>
          <target state="translated">除了调整项目文件和包括标头之外，应用程序还应手动将渲染后端设置为OpenGL，以便在使用Qt Quick时使用此功能。默认情况下，Qt将在目标平台上使用最合适的图形API。有关更多详细信息，请参见&lt;a href=&quot;qtquick-visualcanvas-scenegraph-renderer#rendering-via-the-qt-rendering-hardware-interface&quot;&gt;RHI渲染文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="325dae532505d0e5d00579590446e30e351abf77" translate="yes" xml:space="preserve">
          <source>In addition to being anchored to the map, the &lt;a href=&quot;qml-qtlocation-mapquickitem&quot;&gt;MapQuickItem&lt;/a&gt; can optionally follow the scale of the map, and change size when the Map is zoomed in or zoomed out. This behaviour is controlled by the &lt;a href=&quot;qml-qtlocation-mapquickitem#zoomLevel-prop&quot;&gt;zoomLevel&lt;/a&gt; property. The default behaviour if &lt;a href=&quot;qml-qtlocation-mapquickitem#zoomLevel-prop&quot;&gt;zoomLevel&lt;/a&gt; is not set is for the item to be drawn &quot;on the screen&quot; rather than &quot;on the map&quot;, so that its size remains the same regardless of the zoom level of the Map.</source>
          <target state="translated">除了锚定在地图上之外，&lt;a href=&quot;qml-qtlocation-mapquickitem&quot;&gt;MapQuickItem&lt;/a&gt;还可以选择遵循地图的比例，并在放大或缩小地图时更改大小。此行为由&lt;a href=&quot;qml-qtlocation-mapquickitem#zoomLevel-prop&quot;&gt;zoomLevel&lt;/a&gt;属性控制。如果未设置&lt;a href=&quot;qml-qtlocation-mapquickitem#zoomLevel-prop&quot;&gt;zoomLevel，&lt;/a&gt;则默认行为是在&amp;ldquo;屏幕上&amp;rdquo;而不是&amp;ldquo;在地图上&amp;rdquo;绘制项目，因此无论地图的缩放级别如何，其大小均保持不变。</target>
        </trans-unit>
        <trans-unit id="e1e5b59c1a3b81bdb812af9bb8bccb9a212a4162" translate="yes" xml:space="preserve">
          <source>In addition to being anchored to the map, the MapQuickItem can optionally follow the scale of the map, and change size when the Map is zoomed in or zoomed out. This behaviour is controlled by the &lt;a href=&quot;qml-qtlocation-mapquickitem#zoomLevel-prop&quot;&gt;zoomLevel&lt;/a&gt; property. The default behaviour if &lt;a href=&quot;qml-qtlocation-mapquickitem#zoomLevel-prop&quot;&gt;zoomLevel&lt;/a&gt; is not set is for the item to be drawn &quot;on the screen&quot; rather than &quot;on the map&quot;, so that its size remains the same regardless of the zoom level of the Map.</source>
          <target state="translated">除了锚定在地图上之外，MapQuickItem还可以选择遵循地图的比例，并在放大或缩小地图时更改大小。此行为由&lt;a href=&quot;qml-qtlocation-mapquickitem#zoomLevel-prop&quot;&gt;zoomLevel&lt;/a&gt;属性控制。如果未设置&lt;a href=&quot;qml-qtlocation-mapquickitem#zoomLevel-prop&quot;&gt;zoomLevel，&lt;/a&gt;则默认行为是在&amp;ldquo;屏幕上&amp;rdquo;而不是&amp;ldquo;在地图上&amp;rdquo;绘制项目，因此无论地图的缩放级别如何，其大小均保持不变。</target>
        </trans-unit>
        <trans-unit id="222025e778efe8b0f64a49aca21af282baff2983" translate="yes" xml:space="preserve">
          <source>In addition to being used with &lt;a href=&quot;qopenglcontext#setNativeHandle&quot;&gt;QOpenGLContext::setNativeHandle&lt;/a&gt;(), this class is used also to retrieve the native context handle, that is, a HGLRC value, from a &lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt;. Calling &lt;a href=&quot;qopenglcontext#nativeHandle&quot;&gt;QOpenGLContext::nativeHandle&lt;/a&gt;() returns a &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; which, on Windows with opengl32.dll at least, will contain a &lt;a href=&quot;qwglnativecontext&quot;&gt;QWGLNativeContext&lt;/a&gt;:</source>
          <target state="translated">除了与&lt;a href=&quot;qopenglcontext#setNativeHandle&quot;&gt;QOpenGLContext :: setNativeHandle&lt;/a&gt;（）一起使用外，该类还用于从&lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext中&lt;/a&gt;检索本地上下文句柄，即HGLRC值。调用&lt;a href=&quot;qopenglcontext#nativeHandle&quot;&gt;QOpenGLContext :: nativeHandle&lt;/a&gt;（）返回一个&lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt;，在Windows上至少带有opengl32.dll 的QVariant中将包含一个&lt;a href=&quot;qwglnativecontext&quot;&gt;QWGLNativeContext&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="c63503d0a707bd58bb6c860c59087ad3ce7760ec" translate="yes" xml:space="preserve">
          <source>In addition to being used with &lt;a href=&quot;qopenglcontext#setNativeHandle&quot;&gt;QOpenGLContext::setNativeHandle&lt;/a&gt;(), this class is used also to retrieve the native context handle, that is, a HGLRC value, from a &lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt;. Calling &lt;a href=&quot;qopenglcontext#nativeHandle&quot;&gt;QOpenGLContext::nativeHandle&lt;/a&gt;() returns a &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; which, on Windows with opengl32.dll at least, will contain a QWGLNativeContext:</source>
          <target state="translated">除了与&lt;a href=&quot;qopenglcontext#setNativeHandle&quot;&gt;QOpenGLContext :: setNativeHandle&lt;/a&gt;（）一起使用之外，此类还用于从&lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt;检索本机上下文句柄，即HGLRC值。调用&lt;a href=&quot;qopenglcontext#nativeHandle&quot;&gt;QOpenGLContext :: nativeHandle&lt;/a&gt;（）返回一个&lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt;，在Windows上至少带有opengl32.dll的QVariant将包含QWGLNativeContext：</target>
        </trans-unit>
        <trans-unit id="8821f95317c861f0b886a746e0a555a4702d6df9" translate="yes" xml:space="preserve">
          <source>In addition to calling the convenience event handlers, this function is responsible for converting mouse move events to hover events for when there is no mouse grabber item. Hover events are delivered directly to items; there is no convenience function for them.</source>
          <target state="translated">除了调用便利事件处理程序外,这个函数还负责将鼠标移动事件转换为悬停事件,以便在没有鼠标抓取器项目时使用。悬停事件是直接传递给物品的,没有方便事件处理函数。</target>
        </trans-unit>
        <trans-unit id="11c8e56658b7f7db09b4bc7da36d333b06677626" translate="yes" xml:space="preserve">
          <source>In addition to containing the item, scene, and screen coordinates of the event (as &lt;a href=&quot;qgraphicsscenemouseevent#pos&quot;&gt;pos&lt;/a&gt;(), &lt;a href=&quot;qgraphicsscenemouseevent#scenePos&quot;&gt;scenePos&lt;/a&gt;(), and &lt;a href=&quot;qgraphicsscenemouseevent#screenPos&quot;&gt;screenPos&lt;/a&gt;()), mouse events also contain the coordinates of the previous mouse event received by the view. These can be retrieved with &lt;a href=&quot;qgraphicsscenemouseevent#lastPos&quot;&gt;lastPos&lt;/a&gt;(), &lt;a href=&quot;qgraphicsscenemouseevent#lastScreenPos&quot;&gt;lastScreenPos&lt;/a&gt;(), and &lt;a href=&quot;qgraphicsscenemouseevent#lastScenePos&quot;&gt;lastScenePos&lt;/a&gt;().</source>
          <target state="translated">鼠标事件除了包含事件的项目，场景和屏幕坐标（如&lt;a href=&quot;qgraphicsscenemouseevent#pos&quot;&gt;pos&lt;/a&gt;（），&lt;a href=&quot;qgraphicsscenemouseevent#scenePos&quot;&gt;scenePos&lt;/a&gt;（）和&lt;a href=&quot;qgraphicsscenemouseevent#screenPos&quot;&gt;screenPos&lt;/a&gt;（））外，还包含视图接收的上一个鼠标事件的坐标。可以使用&lt;a href=&quot;qgraphicsscenemouseevent#lastPos&quot;&gt;lastPos&lt;/a&gt;（），&lt;a href=&quot;qgraphicsscenemouseevent#lastScreenPos&quot;&gt;lastScreenPos&lt;/a&gt;（）和&lt;a href=&quot;qgraphicsscenemouseevent#lastScenePos&quot;&gt;lastScenePos&lt;/a&gt;（）检索它们。</target>
        </trans-unit>
        <trans-unit id="f539b7194ee987de596fca3b232ace808aad2ce7" translate="yes" xml:space="preserve">
          <source>In addition to controlling the management of widgets, you can control the current selection in the form window using the &lt;a href=&quot;qdesignerformwindowinterface#selectWidget&quot;&gt;selectWidget&lt;/a&gt;(), &lt;a href=&quot;qdesignerformwindowinterface#clearSelection&quot;&gt;clearSelection&lt;/a&gt;() and &lt;a href=&quot;qdesignerformwindowinterface#emitSelectionChanged&quot;&gt;emitSelectionChanged&lt;/a&gt;() functions, and the &lt;a href=&quot;qdesignerformwindowinterface#selectionChanged&quot;&gt;selectionChanged&lt;/a&gt;() signal.</source>
          <target state="translated">除了控制窗口小部件的管理之外，还可以使用&lt;a href=&quot;qdesignerformwindowinterface#selectWidget&quot;&gt;selectWidget&lt;/a&gt;（），&lt;a href=&quot;qdesignerformwindowinterface#clearSelection&quot;&gt;clearSelection&lt;/a&gt;（）和&lt;a href=&quot;qdesignerformwindowinterface#emitSelectionChanged&quot;&gt;emitSelectionChanged&lt;/a&gt;（）函数以及&lt;a href=&quot;qdesignerformwindowinterface#selectionChanged&quot;&gt;selectionChanged&lt;/a&gt;（）信号来控制表单窗口中的当前选择。</target>
        </trans-unit>
        <trans-unit id="2749249d61fcba3d628135453123502aee7c5881" translate="yes" xml:space="preserve">
          <source>In addition to coordinate based data, it is possible to attach an arbitrary data channel for each data point.</source>
          <target state="translated">除了基于坐标的数据,还可以为每个数据点附加一个任意的数据通道。</target>
        </trans-unit>
        <trans-unit id="860442a28b85ce7c77a454c3e2b9c8a9e8a96e88" translate="yes" xml:space="preserve">
          <source>In addition to core XML support, classes for higher level querying and manipulation of XML data are provided by the Qt XML Patterns module. In the Qt SVG module, the QSvgRenderer and QSvgGenerator classes can read and write a subset of SVG, an XML-based file format. Qt also provides helper functions that may be useful to those working with XML and XHTML: see Qt::escape() and Qt::convertFromPlainText().</source>
          <target state="translated">除了核心的XML支持外,Qt XML Patterns模块还提供了更高级别的查询和操作XML数据的类。在Qt SVG模块中,QSvgRenderer和QSvgGenerator类可以读取和写入SVG的子集,SVG是一种基于XML的文件格式。Qt还提供了对那些使用XML和XHTML的人可能有用的帮助函数:参见Qt::escal()和Qt::convertFromPlainText()。</target>
        </trans-unit>
        <trans-unit id="96ab0ff9ab1deb68ff7f11842fa6faa44833ae75" translate="yes" xml:space="preserve">
          <source>In addition to data provided by the expression's &lt;a href=&quot;qqmlcontext&quot;&gt;QQmlContext&lt;/a&gt;, the scope object's properties are also in scope during the expression's evaluation.</source>
          <target state="translated">除表达式的&lt;a href=&quot;qqmlcontext&quot;&gt;QQmlContext&lt;/a&gt;提供的数据外，作用域对象的属性也在表达式的求值过程中。</target>
        </trans-unit>
        <trans-unit id="30bca362e71a3024326276c40634885f8c55e764" translate="yes" xml:space="preserve">
          <source>In addition to defining which column the data belongs to, the value indicated by the column role is also set as the X-coordinate value of &lt;a href=&quot;qsurfacedataitem&quot;&gt;QSurfaceDataItem&lt;/a&gt; when model data is resolved, unless a separate x position role is also defined.</source>
          <target state="translated">除了定义数据属于哪一列之外，解析模型数据时，除非定义了单独的x位置角色，否则由列角色指示的值还将设置为&lt;a href=&quot;qsurfacedataitem&quot;&gt;QSurfaceDataItem&lt;/a&gt;的X坐标值。</target>
        </trans-unit>
        <trans-unit id="3a366a9f9c645932396430dfd059e8111420d987" translate="yes" xml:space="preserve">
          <source>In addition to defining which row the data belongs to, the value indicated by the row role is also set as the Z-coordinate value of &lt;a href=&quot;qsurfacedataitem&quot;&gt;QSurfaceDataItem&lt;/a&gt; when model data is resolved, unless a separate z position role is also defined.</source>
          <target state="translated">除了定义数据所属的行&lt;a href=&quot;qsurfacedataitem&quot;&gt;之外&lt;/a&gt;，解析模型数据时，除非定义了单独的z位置角色，否则行角色指示的值还将设置为QSurfaceDataItem的Z坐标值。</target>
        </trans-unit>
        <trans-unit id="cf401cf475e46f85bb0131da5516bd0be8251b32" translate="yes" xml:space="preserve">
          <source>In addition to drawing, the style needs to provide the widgets with information on which sub control (if any) a mouse press was made on. For instance, a &lt;a href=&quot;qscrollbar&quot;&gt;QScrollBar&lt;/a&gt; needs to know if the user pressed the slider, the slider groove, or one of the buttons.</source>
          <target state="translated">除了绘图外，样式还需要向小部件提供有关鼠标按下在哪个子控件（如果有）上的信息。例如，&lt;a href=&quot;qscrollbar&quot;&gt;QScrollBar&lt;/a&gt;需要知道用户是否按下了滑块，滑块凹槽或按钮之一。</target>
        </trans-unit>
        <trans-unit id="d9d9c59d69e027e39f0ec4fbe75766e3dadc6e3f" translate="yes" xml:space="preserve">
          <source>In addition to event handling, the &lt;a href=&quot;qvulkanwindow&quot;&gt;QVulkanWindow&lt;/a&gt; subclass is responsible for providing an implementation for &lt;a href=&quot;qvulkanwindow#createRenderer&quot;&gt;QVulkanWindow::createRenderer&lt;/a&gt;() as well. This is where the window and renderer get connected. A typical implementation will simply create a new instance of a subclass of &lt;a href=&quot;qvulkanwindowrenderer&quot;&gt;QVulkanWindowRenderer&lt;/a&gt;.</source>
          <target state="translated">除了事件处理之外，&lt;a href=&quot;qvulkanwindow&quot;&gt;QVulkanWindow&lt;/a&gt;子类还负责提供&lt;a href=&quot;qvulkanwindow#createRenderer&quot;&gt;QVulkanWindow :: createRenderer&lt;/a&gt;（）的实现。这是窗口和渲染器连接的地方。一个典型的实现将简单地创建&lt;a href=&quot;qvulkanwindowrenderer&quot;&gt;QVulkanWindowRenderer&lt;/a&gt;子类的新实例。</target>
        </trans-unit>
        <trans-unit id="d1420ab508e784b2250b3d6cdba8f6ec84453bdb" translate="yes" xml:space="preserve">
          <source>In addition to event handling, the &lt;a href=&quot;qvulkanwindow&quot;&gt;QVulkanWindow&lt;/a&gt; subclass is responsible for providing an implementation for &lt;a href=&quot;qvulkanwindow#createRenderer&quot;&gt;QVulkanWindow::createRenderer&lt;/a&gt;() as well. This is where the window and renderer get connected. A typical implementation will simply create a new instance of a subclass of QVulkanWindowRenderer.</source>
          <target state="translated">除了事件处理之外，&lt;a href=&quot;qvulkanwindow&quot;&gt;QVulkanWindow&lt;/a&gt;子类还负责提供&lt;a href=&quot;qvulkanwindow#createRenderer&quot;&gt;QVulkanWindow :: createRenderer&lt;/a&gt;（）的实现。这是窗口和渲染器连接的地方。典型的实现将只创建QVulkanWindowRenderer子类的新实例。</target>
        </trans-unit>
        <trans-unit id="6193b0f82c7728f2fba62b9bb5e211c3d6071a88" translate="yes" xml:space="preserve">
          <source>In addition to groups, &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; also supports an &quot;array&quot; concept. See &lt;a href=&quot;qsettings#beginReadArray&quot;&gt;beginReadArray&lt;/a&gt;() and &lt;a href=&quot;qsettings#beginWriteArray&quot;&gt;beginWriteArray&lt;/a&gt;() for details.</source>
          <target state="translated">除了组之外，&lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt;还支持&amp;ldquo;数组&amp;rdquo;概念。有关详细信息，请参见&lt;a href=&quot;qsettings#beginReadArray&quot;&gt;beginReadArray&lt;/a&gt;（）和&lt;a href=&quot;qsettings#beginWriteArray&quot;&gt;beginWriteArray&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="5dbc3c0c7d23d9174ba93b9f7ce9b9b023cce4a4" translate="yes" xml:space="preserve">
          <source>In addition to groups, QSettings also supports an &quot;array&quot; concept. See &lt;a href=&quot;qsettings#beginReadArray&quot;&gt;beginReadArray&lt;/a&gt;() and &lt;a href=&quot;qsettings#beginWriteArray&quot;&gt;beginWriteArray&lt;/a&gt;() for details.</source>
          <target state="translated">除了组之外，QSettings还支持&amp;ldquo;数组&amp;rdquo;概念。有关详细信息，请参见&lt;a href=&quot;qsettings#beginReadArray&quot;&gt;beginReadArray&lt;/a&gt;（）和&lt;a href=&quot;qsettings#beginWriteArray&quot;&gt;beginWriteArray&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="3868ec7d585a5a461a3c76d6bc8a4bbf85befd24" translate="yes" xml:space="preserve">
          <source>In addition to merging compatible primitives into batches, the default renderer also tries to minimize the amount of data that needs to be sent to the GPU for every frame. The default renderer identifies subtrees which belong together and tries to put these into separate batches. Once batches are identified, they are merged, uploaded and stored in GPU memory, using Vertex Buffer Objects.</source>
          <target state="translated">除了将兼容的基元合并到批次中,默认渲染器还试图将每一帧需要发送到 GPU 的数据量降至最低。默认渲染器会识别属于一起的子树,并尝试将这些子树放入单独的批次中。一旦确定了批次,就会使用顶点缓冲对象将它们合并、上传并存储在GPU内存中。</target>
        </trans-unit>
        <trans-unit id="ed5456d2bef1e65628af0ed642141020a0888549" translate="yes" xml:space="preserve">
          <source>In addition to normal file downloads, which consist simply of retrieving some raw bytes from the network and writing them to disk, Qt WebEngine also supports saving complete web pages, which involves parsing the page's HTML, downloading any dependent resources, and potentially packaging everything into a special file format (&lt;a href=&quot;qml-qtwebengine-webenginedownloaditem#savePageFormat-prop&quot;&gt;savePageFormat&lt;/a&gt;). To check if a download is for a file or a web page, use &lt;a href=&quot;qml-qtwebengine-webenginedownloaditem#isSavePageDownload-prop&quot;&gt;isSavePageDownload&lt;/a&gt;.</source>
          <target state="translated">除了普通的文件下载（仅包括从网络中检索一些原始字节并将它们写入磁盘）之外，Qt WebEngine还支持保存完整的网页，这涉及解析页面的HTML，下载任何相关资源以及潜在地将所有内容打包到一种特殊的文件格式（&lt;a href=&quot;qml-qtwebengine-webenginedownloaditem#savePageFormat-prop&quot;&gt;savePageFormat&lt;/a&gt;）。要检查下载是针对文件还是网页，请使用&lt;a href=&quot;qml-qtwebengine-webenginedownloaditem#isSavePageDownload-prop&quot;&gt;isSavePageDownload&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f8483c9f7066fd3ab82bade1bce9da25ae1c8d54" translate="yes" xml:space="preserve">
          <source>In addition to normal file downloads, which consist simply of retrieving some raw bytes from the network and writing them to disk, Qt WebEngine also supports saving complete web pages, which involves parsing the page's HTML, downloading any dependent resources, and potentially packaging everything into a special file format (&lt;a href=&quot;qwebenginedownloaditem#savePageFormat&quot;&gt;savePageFormat&lt;/a&gt;). To check if a download is for a file or a web page, use &lt;a href=&quot;qwebenginedownloaditem#isSavePageDownload&quot;&gt;isSavePageDownload&lt;/a&gt;.</source>
          <target state="translated">除了普通的文件下载（仅包括从网络中检索一些原始字节并将它们写入磁盘）之外，Qt WebEngine还支持保存完整的网页，这涉及解析页面的HTML，下载任何相关资源以及潜在地将所有内容打包到一种特殊的文件格式（&lt;a href=&quot;qwebenginedownloaditem#savePageFormat&quot;&gt;savePageFormat&lt;/a&gt;）。要检查下载是针对文件还是网页，请使用&lt;a href=&quot;qwebenginedownloaditem#isSavePageDownload&quot;&gt;isSavePageDownload&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="76f5c232a66c386c0de18bdee8c0604283addb0f" translate="yes" xml:space="preserve">
          <source>In addition to parsing the options (like &lt;a href=&quot;qcommandlineparser#parse&quot;&gt;parse&lt;/a&gt;()), this function also handles the builtin options and handles errors.</source>
          <target state="translated">除了解析选项（如&lt;a href=&quot;qcommandlineparser#parse&quot;&gt;parse&lt;/a&gt;（））外，此函数还处理内置选项并处理错误。</target>
        </trans-unit>
        <trans-unit id="4f4a60305692fbef8b1954acf1606abde5b6592e" translate="yes" xml:space="preserve">
          <source>In addition to perspective projection, orthographic projection can be used to create 2D graphs by replacing the default input handler with one that does not allow rotating the graph and setting the camera to view the graph directly from the side or from the top.</source>
          <target state="translated">除了透视投影外,正交投影还可以用来创建二维图形,方法是将默认的输入处理程序替换为不允许旋转图形的处理程序,并将摄像机设置为直接从侧面或顶部查看图形。</target>
        </trans-unit>
        <trans-unit id="a3cd65e3efc9c51d5089304cafe5bba6b0346841" translate="yes" xml:space="preserve">
          <source>In addition to programmable materials and post-processing, there are two types of data that is normally provided in form of files (&lt;code&gt;.mesh&lt;/code&gt; files or images such as &lt;code&gt;.png&lt;/code&gt;):</source>
          <target state="translated">除了可编程材料和后处理之外，通常还以文件形式（ &lt;code&gt;.mesh&lt;/code&gt; 文件或图像，如 &lt;code&gt;.png&lt;/code&gt; ）提供两种类型的数据：</target>
        </trans-unit>
        <trans-unit id="1775812fafed7ba3b19fdc10f43d092c8b962bc0" translate="yes" xml:space="preserve">
          <source>In addition to providing the &lt;a href=&quot;signalsandslots&quot;&gt;signals and slots&lt;/a&gt; mechanism for communication between objects (the main reason for introducing the system), the meta-object code provides the following additional features:</source>
          <target state="translated">除了提供用于对象之间通信的&lt;a href=&quot;signalsandslots&quot;&gt;信号和时隙&lt;/a&gt;机制（引入系统的主要原因）之外，元对象代码还提供了以下附加功能：</target>
        </trans-unit>
        <trans-unit id="1361d6305eba16b69a305d034e7abe8e488775cb" translate="yes" xml:space="preserve">
          <source>In addition to providing the &lt;a href=&quot;signalsandslots#&quot;&gt;signals and slots&lt;/a&gt; mechanism for communication between objects (the main reason for introducing the system), the meta-object code provides the following additional features:</source>
          <target state="translated">除了提供用于对象之间通信的&lt;a href=&quot;signalsandslots#&quot;&gt;信号和时隙&lt;/a&gt;机制（引入系统的主要原因）之外，元对象代码还提供以下附加功能：</target>
        </trans-unit>
        <trans-unit id="608863a3b34aea5eafec5a706f8343d6c33db486" translate="yes" xml:space="preserve">
          <source>In addition to setting state flags the &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt; contains other information about the widget: &lt;code&gt;direction&lt;/code&gt; is the layout direction of the layout, &lt;code&gt;rect&lt;/code&gt; is the bounding rectangle of the widget (the area in which to draw), &lt;code&gt;palette&lt;/code&gt; is the &lt;a href=&quot;qpalette&quot;&gt;QPalette&lt;/a&gt; that should be used for drawing the widget, and &lt;code&gt;fontMetrics&lt;/code&gt; is the metrics of the font that is used by the widget.</source>
          <target state="translated">除了设置状态标志之外，&lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption还&lt;/a&gt;包含有关小部件的其他信息： &lt;code&gt;direction&lt;/code&gt; 是布局的布局方向， &lt;code&gt;rect&lt;/code&gt; 是小部件的边界矩形（绘制区域）， &lt;code&gt;palette&lt;/code&gt; 是应用于以下用途的&lt;a href=&quot;qpalette&quot;&gt;QPalette&lt;/a&gt;绘制窗口小部件， &lt;code&gt;fontMetrics&lt;/code&gt; 是窗口小部件使用的字体的度量。</target>
        </trans-unit>
        <trans-unit id="e97c71f5c8ffe70cd236c7a10dfbb4138631b3c2" translate="yes" xml:space="preserve">
          <source>In addition to sorting, &lt;a href=&quot;qsortfilterproxymodel&quot;&gt;QSortFilterProxyModel&lt;/a&gt; can be used to hide items that do not match a certain filter. The filter is specified using a &lt;a href=&quot;qregexp&quot;&gt;QRegExp&lt;/a&gt; object and is applied to the &lt;a href=&quot;qsortfilterproxymodel#filterRole-prop&quot;&gt;filterRole&lt;/a&gt;() (&lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;Qt::DisplayRole&lt;/a&gt; by default) of each item, for a given column. The &lt;a href=&quot;qregexp&quot;&gt;QRegExp&lt;/a&gt; object can be used to match a regular expression, a wildcard pattern, or a fixed string. For example:</source>
          <target state="translated">除了排序外，&lt;a href=&quot;qsortfilterproxymodel&quot;&gt;QSortFilterProxyModel&lt;/a&gt;还可用于隐藏与某个过滤器不匹配的项目。过滤器使用&lt;a href=&quot;qregexp&quot;&gt;QRegExp&lt;/a&gt;对象指定，并应用于给定列的每个项目的&lt;a href=&quot;qsortfilterproxymodel#filterRole-prop&quot;&gt;filterRole&lt;/a&gt;（）（默认为&lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;Qt :: DisplayRole&lt;/a&gt;）。所述&lt;a href=&quot;qregexp&quot;&gt;QRegExp&lt;/a&gt;对象可以被用来匹配正则表达式，通配符模式，或固定字符串。例如：</target>
        </trans-unit>
        <trans-unit id="b699c7a80bcc76b2dace75f3e9ad9ff9630986f2" translate="yes" xml:space="preserve">
          <source>In addition to sorting, QSortFilterProxyModel can be used to hide items that do not match a certain filter. The filter is specified using a &lt;a href=&quot;qregexp&quot;&gt;QRegExp&lt;/a&gt; object and is applied to the &lt;a href=&quot;qsortfilterproxymodel#filterRole-prop&quot;&gt;filterRole&lt;/a&gt;() (&lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;Qt::DisplayRole&lt;/a&gt; by default) of each item, for a given column. The &lt;a href=&quot;qregexp&quot;&gt;QRegExp&lt;/a&gt; object can be used to match a regular expression, a wildcard pattern, or a fixed string. For example:</source>
          <target state="translated">除了排序外，QSortFilterProxyModel还可用于隐藏与某个过滤器不匹配的项目。过滤器使用&lt;a href=&quot;qregexp&quot;&gt;QRegExp&lt;/a&gt;对象指定，并应用于给定列的每个项目的&lt;a href=&quot;qsortfilterproxymodel#filterRole-prop&quot;&gt;filterRole&lt;/a&gt;（）（默认为&lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;Qt :: DisplayRole&lt;/a&gt;）。所述&lt;a href=&quot;qregexp&quot;&gt;QRegExp&lt;/a&gt;对象可以被用来匹配正则表达式，通配符模式，或固定字符串。例如：</target>
        </trans-unit>
        <trans-unit id="554d7d5cd389312416c368c96ab8b5bb2a9e5062" translate="yes" xml:space="preserve">
          <source>In addition to sorting, QSortFilterProxyModel can be used to hide items that do not match a certain filter. The filter is specified using a &lt;a href=&quot;qtcore-changes-qt6#qregularexpression&quot;&gt;QRegularExpression&lt;/a&gt; object and is applied to the &lt;a href=&quot;qsortfilterproxymodel#filterRole-prop&quot;&gt;filterRole&lt;/a&gt;() (&lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;Qt::DisplayRole&lt;/a&gt; by default) of each item, for a given column. The &lt;a href=&quot;qtcore-changes-qt6#qregularexpression&quot;&gt;QRegularExpression&lt;/a&gt; object can be used to match a regular expression, a wildcard pattern, or a fixed string. For example:</source>
          <target state="translated">除了排序外，QSortFilterProxyModel还可用于隐藏与某个过滤器不匹配的项目。过滤器使用&lt;a href=&quot;qtcore-changes-qt6#qregularexpression&quot;&gt;QRegularExpression&lt;/a&gt;对象指定，并应用于给定列的每个项目的&lt;a href=&quot;qsortfilterproxymodel#filterRole-prop&quot;&gt;filterRole&lt;/a&gt;（）（默认为&lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;Qt :: DisplayRole&lt;/a&gt;）。所述&lt;a href=&quot;qtcore-changes-qt6#qregularexpression&quot;&gt;QRegularExpression&lt;/a&gt;对象可以被用来匹配正则表达式，通配符模式，或固定字符串。例如：</target>
        </trans-unit>
        <trans-unit id="5b8eb1ee7525ba77b95e29b40ab1fbfd79676d3b" translate="yes" xml:space="preserve">
          <source>In addition to specifying the attributes in QML, it is also possible to specify them via environment variables or in a configuration file. Attributes specified in QML take precedence over all other methods.</source>
          <target state="translated">除了在QML中指定属性外,还可以通过环境变量或在配置文件中指定属性。QML中指定的属性优先于所有其他方法。</target>
        </trans-unit>
        <trans-unit id="0155e0a679d61241e117c2329f6d0d979bde7477" translate="yes" xml:space="preserve">
          <source>In addition to specifying the path in QML, it is also possible to specify it via an &lt;a href=&quot;#imagine-customization-environment-variable&quot;&gt;environment variable&lt;/a&gt; or in a &lt;a href=&quot;#imagine-customization-configuration-file&quot;&gt;configuration file&lt;/a&gt;. Attributes specified in QML take precedence over all other methods.</source>
          <target state="translated">除了在QML中指定路径外，还可以通过&lt;a href=&quot;#imagine-customization-environment-variable&quot;&gt;环境变量&lt;/a&gt;或在&lt;a href=&quot;#imagine-customization-configuration-file&quot;&gt;配置文件中&lt;/a&gt;指定路径。QML中指定的属性优先于所有其他方法。</target>
        </trans-unit>
        <trans-unit id="c38902248e9111e63258becc31f0fbc0ef0028e5" translate="yes" xml:space="preserve">
          <source>In addition to specifying the path in QML, it is also possible to specify it via an &lt;a href=&quot;qtquickcontrols2-imagine#imagine-customization-environment-variable&quot;&gt;environment variable&lt;/a&gt; or in a &lt;a href=&quot;qtquickcontrols2-imagine#imagine-customization-configuration-file&quot;&gt;configuration file&lt;/a&gt;. Attributes specified in QML take precedence over all other methods.</source>
          <target state="translated">除了在QML中指定路径之外，还可以通过&lt;a href=&quot;qtquickcontrols2-imagine#imagine-customization-environment-variable&quot;&gt;环境变量&lt;/a&gt;或在&lt;a href=&quot;qtquickcontrols2-imagine#imagine-customization-configuration-file&quot;&gt;配置文件中&lt;/a&gt;指定路径。QML中指定的属性优先于所有其他方法。</target>
        </trans-unit>
        <trans-unit id="ec764b284bd78c68c070ec70cb6943f8decbe9f1" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;a href=&quot;qsensorgesture#detected&quot;&gt;QSensorGesture::detected&lt;/a&gt;() signal, Sensor Gesture Recognizers can have their own specific signals, and may be discovered through &lt;a href=&quot;qsensorgesture#gestureSignals&quot;&gt;QSensorGesture::gestureSignals&lt;/a&gt;().</source>
          <target state="translated">除了&lt;a href=&quot;qsensorgesture#detected&quot;&gt;QSensorGesture :: detected&lt;/a&gt;（）信号之外，Sensor Gesture Recognizers还可以具有自己的特定信号，并且可以通过&lt;a href=&quot;qsensorgesture#gestureSignals&quot;&gt;QSensorGesture :: gestureSignals&lt;/a&gt;（）发现。</target>
        </trans-unit>
        <trans-unit id="209c33f7140e48e1880a478a03c3f56c9124cdd6" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;a href=&quot;qtqml-typesystem-basictypes&quot;&gt;QML Basic Types&lt;/a&gt;, the module comes with the following QML object types:</source>
          <target state="translated">除了&lt;a href=&quot;qtqml-typesystem-basictypes&quot;&gt;QML基本类型之外&lt;/a&gt;，该模块还具有以下QML对象类型：</target>
        </trans-unit>
        <trans-unit id="52c782ad46d1294574253126cd5c9c5f784d753b" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;a href=&quot;qtqml-typesystem-basictypes#&quot;&gt;QML Basic Types&lt;/a&gt;, the module comes with the following QML object types:</source>
          <target state="translated">除了&lt;a href=&quot;qtqml-typesystem-basictypes#&quot;&gt;QML基本类型之外&lt;/a&gt;，该模块还具有以下QML对象类型：</target>
        </trans-unit>
        <trans-unit id="417e8f4aadd4e491d8bdc2da3b8079084ab4beec" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;index&lt;/code&gt; property, a list of model data roles are available in the context of each delegate:</source>
          <target state="translated">除了 &lt;code&gt;index&lt;/code&gt; 属性之外，每个委托的上下文中还提供了一系列模型数据角色：</target>
        </trans-unit>
        <trans-unit id="a3ef24a6177217e50cdd9ee78dfc67377f72be66" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;win32&lt;/code&gt;, &lt;code&gt;macx&lt;/code&gt;, and &lt;code&gt;unix&lt;/code&gt; values used in many scope conditions, various other built-in platform and compiler-specific values can be tested with scopes. These are based on platform specifications provided in Qt's &lt;code&gt;mkspecs&lt;/code&gt; directory. For example, the following lines from a project file show the current specification in use and test for the &lt;code&gt;linux-g++&lt;/code&gt; specification:</source>
          <target state="translated">除了在许多范围条件下使用的 &lt;code&gt;win32&lt;/code&gt; ， &lt;code&gt;macx&lt;/code&gt; 和 &lt;code&gt;unix&lt;/code&gt; 值之外，还可以使用范围测试各种其他内置平台和特定于编译器的值。这些基于Qt的 &lt;code&gt;mkspecs&lt;/code&gt; 目录中提供的平台规范。例如，项目文件中的以下几行显示了当前使用的规范，并测试了 &lt;code&gt;linux-g++&lt;/code&gt; 规范：</target>
        </trans-unit>
        <trans-unit id="37e96a7a2b6385ac07699da5e97ccb33da1f4c22" translate="yes" xml:space="preserve">
          <source>In addition to the above types, Object3D can also serve as the parent for &lt;a href=&quot;qml-qtquick-item&quot;&gt;Qt Quick items&lt;/a&gt;, as well as arbitrary &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; instances. For more information on adding 2D items to the 3D scene, refer to &lt;a href=&quot;qtquick3d-2d&quot;&gt;Qt Quick 3D Scenes with 2D Content&lt;/a&gt;.</source>
          <target state="translated">除了上述类型之外，Object3D还可以用作&lt;a href=&quot;qml-qtquick-item&quot;&gt;Qt Quick项目&lt;/a&gt;以及任意&lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;实例的父项。有关将2D项目添加到3D场景的更多信息，请参阅&lt;a href=&quot;qtquick3d-2d&quot;&gt;带有2D内容的Qt Quick 3D场景&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8f70defdd2fa2e597cc5666167d05b26cad5bd42" translate="yes" xml:space="preserve">
          <source>In addition to the application developer APIs, Qt also interfaces with the platform when providing the underlying implementations of the cross-platform building blocks in Qt.</source>
          <target state="translated">除了应用开发者的API之外,Qt在提供Qt中跨平台构件的底层实现时,也会与平台进行接口。</target>
        </trans-unit>
        <trans-unit id="dfa395ac5b58e499194cf81c46c2f9bd4bb920ce" translate="yes" xml:space="preserve">
          <source>In addition to the base Qt Quick 3D Model, additional functionality is provided by the following module imports:</source>
          <target state="translated">除了基本的Qt Quick 3D模型外,以下模块的导入还提供了额外的功能。</target>
        </trans-unit>
        <trans-unit id="76ea6e9178553b17cdc78a03bf69f88badb843eb" translate="yes" xml:space="preserve">
          <source>In addition to the build time configuration, Qt supports choosing and loading the OpenGL implementation at runtime. To use this mode, pass &lt;code&gt;-opengl dynamic&lt;/code&gt; to the configure script.</source>
          <target state="translated">除了构建时间配置之外，Qt还支持在运行时选择和加载OpenGL实现。要使用此模式， &lt;code&gt;-opengl dynamic&lt;/code&gt; 传递给configure脚本。</target>
        </trans-unit>
        <trans-unit id="87cfd16fd78c2b465cefa0f4ffa05984e81073df" translate="yes" xml:space="preserve">
          <source>In addition to the camera projection, the camera direction is also calculated as this is necessary for lighting calculations in the shading code.</source>
          <target state="translated">除了摄像机的投影外,还要计算摄像机的方向,因为这是阴影代码中照明计算所必需的。</target>
        </trans-unit>
        <trans-unit id="7af3e3298d92ef46918d809b8a96064abbcc8ca4" translate="yes" xml:space="preserve">
          <source>In addition to the checked and unchecked states, there is a third state: partially checked. The partially checked state can be enabled using the &lt;a href=&quot;qml-qtquick-controls2-checkbox#tristate-prop&quot;&gt;tristate&lt;/a&gt; property. This state indicates that the regular checked/unchecked state can not be determined; generally because of other states that affect the checkbox. This state is useful when several child nodes are selected in a treeview, for example.</source>
          <target state="translated">除了已检查和未检查状态之外，还有第三种状态：部分已检查。可以使用&lt;a href=&quot;qml-qtquick-controls2-checkbox#tristate-prop&quot;&gt;tristate&lt;/a&gt;属性启用部分检查的状态。此状态表示无法确定常规检查/未检查状态；通常是由于其他影响复选框的状态。例如，当在树视图中选择几个子节点时，此状态很有用。</target>
        </trans-unit>
        <trans-unit id="30fe8d793a4d1dc565113d3ae097c00698b55f22" translate="yes" xml:space="preserve">
          <source>In addition to the checked and unchecked states, there is a third state: partially checked. The partially checked state can be enabled using the &lt;a href=&quot;qml-qtquick-controls2-checkdelegate#tristate-prop&quot;&gt;tristate&lt;/a&gt; property. This state indicates that the regular checked/unchecked state can not be determined; generally because of other states that affect the check delegate. This state is useful when several child nodes are selected in a treeview, for example.</source>
          <target state="translated">除了已检查和未检查状态之外，还有第三种状态：部分已检查。可以使用&lt;a href=&quot;qml-qtquick-controls2-checkdelegate#tristate-prop&quot;&gt;tristate&lt;/a&gt;属性启用部分检查的状态。此状态表示无法确定常规检查/未检查状态；通常是因为其他状态会影响检查委托。例如，当在树视图中选择几个子节点时，此状态很有用。</target>
        </trans-unit>
        <trans-unit id="eab7e7dd6c4505763be2492ac8ad26d746b93263" translate="yes" xml:space="preserve">
          <source>In addition to the checked and unchecked states, there is a third state: partially checked. This state indicates that the regular checked/unchecked state can not be determined; generally because of other states that affect the checkbox. This state is useful when several child nodes are selected in a treeview, for example.</source>
          <target state="translated">除了选中和未选中的状态外,还有第三种状态:部分选中。这种状态表示无法确定常规的选中/未选中状态;一般是由于其他状态影响了复选框。例如,当在树形视图中选择了几个子节点时,这种状态就很有用。</target>
        </trans-unit>
        <trans-unit id="6a017e3c2b18cce999dbad22cc20e6564e42134b" translate="yes" xml:space="preserve">
          <source>In addition to the compiled-in</source>
          <target state="translated">除了编译后的</target>
        </trans-unit>
        <trans-unit id="3880f2d8f61ee136dcf0759b666df50668837724" translate="yes" xml:space="preserve">
          <source>In addition to the constraints on the lvalue-this overload, this rvalue-this overload is only available when this &lt;a href=&quot;qstringtokenizer&quot;&gt;QStringTokenizer&lt;/a&gt; does not store the haystack internally, as this could create a container full of dangling references:</source>
          <target state="translated">除了对左值-此重载的约束之外，仅当此&lt;a href=&quot;qstringtokenizer&quot;&gt;QStringTokenizer&lt;/a&gt;不在内部存储干草堆时，此右值-此重载才可用，因为这可能会创建一个充满悬空引用的容器：</target>
        </trans-unit>
        <trans-unit id="9eaf3e7f3dcb62f52f067b4b06b4c1eb3965285c" translate="yes" xml:space="preserve">
          <source>In addition to the encoding, &lt;a href=&quot;qaudioformat&quot;&gt;QAudioFormat&lt;/a&gt; contains other parameters that further specify how the audio sample data is arranged. These are the frequency, the number of channels, the sample size, the sample type, and the byte order. The following table describes these in more detail.</source>
          <target state="translated">除编码外，&lt;a href=&quot;qaudioformat&quot;&gt;QAudioFormat&lt;/a&gt;包含其他参数，这些参数进一步指定如何安排音频样本数据。这些是频率，通道数，样本大小，样本类型和字节顺序。下表更详细地描述了这些。</target>
        </trans-unit>
        <trans-unit id="9a244ea8bb5b1a8cb06619e7a69bc8d2849c5770" translate="yes" xml:space="preserve">
          <source>In addition to the encoding, QAudioFormat contains other parameters that further specify how the audio sample data is arranged. These are the frequency, the number of channels, the sample size, the sample type, and the byte order. The following table describes these in more detail.</source>
          <target state="translated">除了编码,QAudioFormat还包含其他参数,进一步指定音频样本数据的排列方式。这些参数是频率、通道数、样本大小、样本类型和字节顺序。下表对这些参数进行了更详细的描述。</target>
        </trans-unit>
        <trans-unit id="df8285b2079bd253f4ffb0db090898de7b186b6e" translate="yes" xml:space="preserve">
          <source>In addition to the expressions, recognized in the format string to represent parts of the date and time, by &lt;a href=&quot;qdate#fromString&quot;&gt;QDate::fromString&lt;/a&gt;() and &lt;a href=&quot;qtime#fromString&quot;&gt;QTime::fromString&lt;/a&gt;(), this method supports:</source>
          <target state="translated">除了通过&lt;a href=&quot;qdate#fromString&quot;&gt;QDate :: fromString&lt;/a&gt;（）和&lt;a href=&quot;qtime#fromString&quot;&gt;QTime :: fromString&lt;/a&gt;（）在格式字符串中识别的表示日期和时间部分的表达式之外，此方法还支持：</target>
        </trans-unit>
        <trans-unit id="01161f1235543028af2e64aca9b51ee52eb5c08f" translate="yes" xml:space="preserve">
          <source>In addition to the functions inherited from &lt;a href=&quot;qgradient&quot;&gt;QGradient&lt;/a&gt;, the &lt;a href=&quot;qconicalgradient&quot;&gt;QConicalGradient&lt;/a&gt; class provides the &lt;a href=&quot;qconicalgradient#angle&quot;&gt;angle&lt;/a&gt;() and &lt;a href=&quot;qconicalgradient#center&quot;&gt;center&lt;/a&gt;() functions returning the start angle and center of the gradient.</source>
          <target state="translated">除了继承自&lt;a href=&quot;qgradient&quot;&gt;QGradient&lt;/a&gt;的函数之外，&lt;a href=&quot;qconicalgradient&quot;&gt;QConicalGradient&lt;/a&gt;类还提供了返回梯度的起始角度和中心的&lt;a href=&quot;qconicalgradient#angle&quot;&gt;angle&lt;/a&gt;（）和&lt;a href=&quot;qconicalgradient#center&quot;&gt;center&lt;/a&gt;（）函数。</target>
        </trans-unit>
        <trans-unit id="877fb9f84fc362bbe3e371e803b3b05e197b5c8f" translate="yes" xml:space="preserve">
          <source>In addition to the functions inherited from &lt;a href=&quot;qgradient&quot;&gt;QGradient&lt;/a&gt;, the &lt;a href=&quot;qlineargradient&quot;&gt;QLinearGradient&lt;/a&gt; class provides the &lt;a href=&quot;qlineargradient#finalStop&quot;&gt;finalStop&lt;/a&gt;() function which returns the final stop point of the gradient, and the &lt;a href=&quot;qlineargradient#start&quot;&gt;start&lt;/a&gt;() function returning the start point of the gradient.</source>
          <target state="translated">除了从&lt;a href=&quot;qgradient&quot;&gt;QGradient&lt;/a&gt;继承的函数之外，&lt;a href=&quot;qlineargradient&quot;&gt;QLinearGradient&lt;/a&gt;类还提供了&lt;a href=&quot;qlineargradient#finalStop&quot;&gt;finalStop&lt;/a&gt;（）函数（该函数返回渐变的最终停止点）和&lt;a href=&quot;qlineargradient#start&quot;&gt;start&lt;/a&gt;（）函数（其返回渐变的起点）。</target>
        </trans-unit>
        <trans-unit id="ac59c2d44b382d3ea1218ff478b5b46bdb551e68" translate="yes" xml:space="preserve">
          <source>In addition to the functions inherited from &lt;a href=&quot;qgradient&quot;&gt;QGradient&lt;/a&gt;, the &lt;a href=&quot;qradialgradient&quot;&gt;QRadialGradient&lt;/a&gt; class provides the &lt;a href=&quot;qradialgradient#center&quot;&gt;center&lt;/a&gt;(), &lt;a href=&quot;qradialgradient#focalPoint&quot;&gt;focalPoint&lt;/a&gt;() and &lt;a href=&quot;qradialgradient#radius&quot;&gt;radius&lt;/a&gt;() functions returning the gradient's center, focal point and radius respectively.</source>
          <target state="translated">除了从&lt;a href=&quot;qgradient&quot;&gt;QGradient&lt;/a&gt;继承的函数之外，&lt;a href=&quot;qradialgradient&quot;&gt;QRadialGradient&lt;/a&gt;类还提供了分别返回渐变的中心，焦点和半径的&lt;a href=&quot;qradialgradient#center&quot;&gt;center&lt;/a&gt;（），&lt;a href=&quot;qradialgradient#focalPoint&quot;&gt;focusPoint&lt;/a&gt;（）和&lt;a href=&quot;qradialgradient#radius&quot;&gt;radius&lt;/a&gt;（）函数。</target>
        </trans-unit>
        <trans-unit id="a9e3f0e289ff08bc7c8585f151a1938dfa82edb9" translate="yes" xml:space="preserve">
          <source>In addition to the functions inherited from &lt;a href=&quot;qgradient&quot;&gt;QGradient&lt;/a&gt;, the QConicalGradient class provides the &lt;a href=&quot;qconicalgradient#angle&quot;&gt;angle&lt;/a&gt;() and &lt;a href=&quot;qconicalgradient#center&quot;&gt;center&lt;/a&gt;() functions returning the start angle and center of the gradient.</source>
          <target state="translated">除了继承自&lt;a href=&quot;qgradient&quot;&gt;QGradient&lt;/a&gt;的函数外，QConicalGradient类还提供了返回坡度起始角和中心的&lt;a href=&quot;qconicalgradient#angle&quot;&gt;angle&lt;/a&gt;（）和&lt;a href=&quot;qconicalgradient#center&quot;&gt;center&lt;/a&gt;（）函数。</target>
        </trans-unit>
        <trans-unit id="3b46c23dc12791879a9c6b6742440cc7b8bbe144" translate="yes" xml:space="preserve">
          <source>In addition to the functions inherited from &lt;a href=&quot;qgradient&quot;&gt;QGradient&lt;/a&gt;, the QLinearGradient class provides the &lt;a href=&quot;qlineargradient#finalStop&quot;&gt;finalStop&lt;/a&gt;() function which returns the final stop point of the gradient, and the &lt;a href=&quot;qlineargradient#start&quot;&gt;start&lt;/a&gt;() function returning the start point of the gradient.</source>
          <target state="translated">除了从&lt;a href=&quot;qgradient&quot;&gt;QGradient&lt;/a&gt;继承的函数之外，QLinearGradient类还提供了&lt;a href=&quot;qlineargradient#finalStop&quot;&gt;finalStop&lt;/a&gt;（）函数（该函数返回渐变的最终停止点）和&lt;a href=&quot;qlineargradient#start&quot;&gt;start&lt;/a&gt;（）函数（其返回渐变的起点）。</target>
        </trans-unit>
        <trans-unit id="e77a4943e03b7dc27a7bd182d58b845e6058d12e" translate="yes" xml:space="preserve">
          <source>In addition to the functions inherited from &lt;a href=&quot;qgradient&quot;&gt;QGradient&lt;/a&gt;, the QRadialGradient class provides the &lt;a href=&quot;qradialgradient#center&quot;&gt;center&lt;/a&gt;(), &lt;a href=&quot;qradialgradient#focalPoint&quot;&gt;focalPoint&lt;/a&gt;() and &lt;a href=&quot;qradialgradient#radius&quot;&gt;radius&lt;/a&gt;() functions returning the gradient's center, focal point and radius respectively.</source>
          <target state="translated">除了继承自&lt;a href=&quot;qgradient&quot;&gt;QGradient&lt;/a&gt;的函数之外，QRadialGradient类还提供了分别返回渐变的中心，焦点和半径的&lt;a href=&quot;qradialgradient#center&quot;&gt;center&lt;/a&gt;（），&lt;a href=&quot;qradialgradient#focalPoint&quot;&gt;focusPoint&lt;/a&gt;（）和&lt;a href=&quot;qradialgradient#radius&quot;&gt;radius&lt;/a&gt;（）函数。</target>
        </trans-unit>
        <trans-unit id="1c821cc6fdd1abd00a61f5849aa01361ecb0459e" translate="yes" xml:space="preserve">
          <source>In addition to the functions provided by &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt;, QPolygon provides some point-specific functions.</source>
          <target state="translated">除了&lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt;提供的功能外，QPolygon还提供了一些特定于点的功能。</target>
        </trans-unit>
        <trans-unit id="511d4be7f2f1914de36f69a74e5010125659e7b0" translate="yes" xml:space="preserve">
          <source>In addition to the functions provided by &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt;, QPolygonF provides the &lt;a href=&quot;qpolygonf#boundingRect&quot;&gt;boundingRect&lt;/a&gt;() and &lt;a href=&quot;qpolygonf#translate&quot;&gt;translate&lt;/a&gt;() functions for geometry operations. Use the &lt;a href=&quot;qtransform#map&quot;&gt;QTransform::map&lt;/a&gt;() function for more general transformations of QPolygonFs.</source>
          <target state="translated">除了&lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt;提供的功能之外，QPolygonF还提供用于几何操作的&lt;a href=&quot;qpolygonf#boundingRect&quot;&gt;boundingRect&lt;/a&gt;（）和&lt;a href=&quot;qpolygonf#translate&quot;&gt;translate&lt;/a&gt;（）函数。使用&lt;a href=&quot;qtransform#map&quot;&gt;QTransform :: map&lt;/a&gt;（）函数可对QPolygonF进行更一般的转换。</target>
        </trans-unit>
        <trans-unit id="90cb87a4726b92cf26795c1b0b605c676ee538e3" translate="yes" xml:space="preserve">
          <source>In addition to the functions provided by &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt;, &lt;a href=&quot;qpolygon&quot;&gt;QPolygon&lt;/a&gt; provides some point-specific functions.</source>
          <target state="translated">除了&lt;a href=&quot;qpolygon&quot;&gt;QVector&lt;/a&gt;提供的功能&lt;a href=&quot;qvector&quot;&gt;外&lt;/a&gt;，QPolygon还提供了一些特定于点的功能。</target>
        </trans-unit>
        <trans-unit id="0af4b5582ced69e4efe9d71c097c3238d24bc513" translate="yes" xml:space="preserve">
          <source>In addition to the functions provided by &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt;, &lt;a href=&quot;qpolygonf&quot;&gt;QPolygonF&lt;/a&gt; provides the &lt;a href=&quot;qpolygonf#boundingRect&quot;&gt;boundingRect&lt;/a&gt;() and &lt;a href=&quot;qpolygonf#translate&quot;&gt;translate&lt;/a&gt;() functions for geometry operations. Use the &lt;a href=&quot;qmatrix#map&quot;&gt;QMatrix::map&lt;/a&gt;() function for more general transformations of QPolygonFs.</source>
          <target state="translated">除了&lt;a href=&quot;qpolygonf&quot;&gt;QVector&lt;/a&gt;提供的功能&lt;a href=&quot;qvector&quot;&gt;外&lt;/a&gt;，QPolygonF还提供了&lt;a href=&quot;qpolygonf#boundingRect&quot;&gt;boundingRect&lt;/a&gt;（）和&lt;a href=&quot;qpolygonf#translate&quot;&gt;translate&lt;/a&gt;（）函数用于几何运算。使用&lt;a href=&quot;qmatrix#map&quot;&gt;QMatrix :: map&lt;/a&gt;（）函数可对QPolygonF进行更常规的转换。</target>
        </trans-unit>
        <trans-unit id="b4d5db9f1e31428d2f2cb9ffecaf834a3e9aba83" translate="yes" xml:space="preserve">
          <source>In addition to the functions provided by &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt;, QPolygon provides some point-specific functions.</source>
          <target state="translated">除了QVector提供的功能&lt;a href=&quot;qvector&quot;&gt;外&lt;/a&gt;，QPolygon还提供了一些特定于点的功能。</target>
        </trans-unit>
        <trans-unit id="d5675d8d18582185f35a6dc1a0b286add20f7daa" translate="yes" xml:space="preserve">
          <source>In addition to the functions provided by &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt;, QPolygonF provides the &lt;a href=&quot;qpolygonf#boundingRect&quot;&gt;boundingRect&lt;/a&gt;() and &lt;a href=&quot;qpolygonf#translate&quot;&gt;translate&lt;/a&gt;() functions for geometry operations. Use the &lt;a href=&quot;qtransform#map&quot;&gt;QTransform::map&lt;/a&gt;() function for more general transformations of QPolygonFs.</source>
          <target state="translated">除了QVector提供的功能&lt;a href=&quot;qvector&quot;&gt;外&lt;/a&gt;，QPolygonF还提供了&lt;a href=&quot;qpolygonf#boundingRect&quot;&gt;boundingRect&lt;/a&gt;（）和&lt;a href=&quot;qpolygonf#translate&quot;&gt;translate&lt;/a&gt;（）函数用于几何运算。使用&lt;a href=&quot;qtransform#map&quot;&gt;QTransform :: map&lt;/a&gt;（）函数可对QPolygonF进行更一般的转换。</target>
        </trans-unit>
        <trans-unit id="fe5baa5613db9a07f2d362e38916ab845c4f0edf" translate="yes" xml:space="preserve">
          <source>In addition to the locale and collation strategy, several optional flags can be set that influence the result of the collation.</source>
          <target state="translated">除了locale和整理策略之外,还可以设置一些影响整理结果的可选标志。</target>
        </trans-unit>
        <trans-unit id="f8f3f432050e4b246a5ff857a8616045f7e2d660" translate="yes" xml:space="preserve">
          <source>In addition to the more traditional &lt;a href=&quot;qml-qtquick-grid&quot;&gt;Grid&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-row&quot;&gt;Row&lt;/a&gt;, and &lt;a href=&quot;qml-qtquick-column&quot;&gt;Column&lt;/a&gt;, Qt Quick also provides a way to layout items using the concept of</source>
          <target state="translated">除了更传统的&lt;a href=&quot;qml-qtquick-grid&quot;&gt;Grid&lt;/a&gt;，&lt;a href=&quot;qml-qtquick-row&quot;&gt;Row&lt;/a&gt;和&lt;a href=&quot;qml-qtquick-column&quot;&gt;Column之外&lt;/a&gt;，Qt Quick还提供了一种使用以下概念来布局项目的方法：</target>
        </trans-unit>
        <trans-unit id="bd1769bbaee36477bcc222f28d1b3f1dc4fdbb46" translate="yes" xml:space="preserve">
          <source>In addition to the normal &lt;a href=&quot;qml-qtquick-text&quot;&gt;Text&lt;/a&gt; type, Label follows the font and color scheme of the system. Use the &lt;code&gt;text&lt;/code&gt; property to assign a text to the label. For other properties check &lt;a href=&quot;qml-qtquick-text&quot;&gt;Text&lt;/a&gt;.</source>
          <target state="translated">除了普通的&amp;ldquo; &lt;a href=&quot;qml-qtquick-text&quot;&gt;文本&amp;rdquo;&lt;/a&gt;类型外，&amp;ldquo;标签&amp;rdquo;还遵循系统的字体和颜色方案。使用 &lt;code&gt;text&lt;/code&gt; 属性将文本分配给标签。对于其他属性，请检查&lt;a href=&quot;qml-qtquick-text&quot;&gt;Text&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3241102cc7dd4992b6edb728cbe2a9f013091640" translate="yes" xml:space="preserve">
          <source>In addition to the normal key event data, also contains</source>
          <target state="translated">除了正常的关键事件数据外,还含有</target>
        </trans-unit>
        <trans-unit id="c5488ff097ad45e29b3b27b5e777318782f47ccb" translate="yes" xml:space="preserve">
          <source>In addition to the original behaviour of &lt;a href=&quot;qsslsocket#connectToHostEncrypted&quot;&gt;connectToHostEncrypted&lt;/a&gt;, this overloaded method enables the usage of a different hostname (</source>
          <target state="translated">除了&lt;a href=&quot;qsslsocket#connectToHostEncrypted&quot;&gt;connectToHostEncrypted&lt;/a&gt;的原始行为外，此重载方法还允许使用其他主机名（</target>
        </trans-unit>
        <trans-unit id="36f5ccbfefe91daac258836641044049f0c56457" translate="yes" xml:space="preserve">
          <source>In addition to the original behaviour of connectToHostEncrypted, this overloaded method enables the usage of a different hostname (</source>
          <target state="translated">除了connectToHostEncrypted的原始行为外,这个重载方法还可以使用不同的主机名(</target>
        </trans-unit>
        <trans-unit id="21fb91fa11606656b3adc5dc6835305200665c5d" translate="yes" xml:space="preserve">
          <source>In addition to the overloaded stream operators documented here, any Qt classes that you might want to serialize to a &lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt; will have appropriate stream operators declared as non-member of the class:</source>
          <target state="translated">除了此处记录的重载流运算符之外，您可能要序列化为&lt;a href=&quot;qdatastream&quot;&gt;QDataStream的&lt;/a&gt;所有Qt类都将具有适当的流运算符，这些流运算符声明为该类的非成员：</target>
        </trans-unit>
        <trans-unit id="bc01324075577dbbd63ee06845f075d618cb50eb" translate="yes" xml:space="preserve">
          <source>In addition to the overloaded stream operators documented here, any Qt classes that you might want to serialize to a QDataStream will have appropriate stream operators declared as non-member of the class:</source>
          <target state="translated">除了这里记录的重载流操作符之外,任何你可能想要序列化为QDataStream的Qt类都会有相应的流操作符声明为该类的非成员。</target>
        </trans-unit>
        <trans-unit id="82e5ba02ce74bd7c5fa0fb2e1d15e44165d43fb9" translate="yes" xml:space="preserve">
          <source>In addition to the public API, the scene graph has an adaptation layer which opens up the implementation to do hardware specific adaptations. This is an undocumented, internal and private plugin API, which lets hardware adaptation teams make the most of their hardware. It includes:</source>
          <target state="translated">除了公开的API,场景图还有一个适配层,它开放了做硬件特定适配的实现。这是一个未被记录的、内部的、私有的插件API,它让硬件适配团队可以充分利用硬件。它包括</target>
        </trans-unit>
        <trans-unit id="6a6c3ce6d985ea5289aaa8da876be075c128e730" translate="yes" xml:space="preserve">
          <source>In addition to the signals and slots shown above, &lt;code&gt;moc&lt;/code&gt; also implements object properties as in the next example. The &lt;a href=&quot;qobject#Q_PROPERTY&quot;&gt;Q_PROPERTY&lt;/a&gt;() macro declares an object property, while &lt;a href=&quot;qobject#Q_ENUM&quot;&gt;Q_ENUM&lt;/a&gt;() declares a list of enumeration types within the class to be usable inside the &lt;a href=&quot;properties&quot;&gt;property system&lt;/a&gt;.</source>
          <target state="translated">除了上面显示的信号和插槽， &lt;code&gt;moc&lt;/code&gt; 还实现了对象属性，如下例所示。所述&lt;a href=&quot;qobject#Q_PROPERTY&quot;&gt;Q_PROPERTY&lt;/a&gt;（）宏声明的对象属性，而&lt;a href=&quot;qobject#Q_ENUM&quot;&gt;Q_ENUM&lt;/a&gt;（）中声明的类中枚举类型的列表是内部可用&lt;a href=&quot;properties&quot;&gt;属性系统&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0dc3ccf2ba055573f41ffab03bf5059e4c36e6fe" translate="yes" xml:space="preserve">
          <source>In addition to the standard CMYK model, Qt provides an alpha-channel to feature &lt;a href=&quot;qcolor#alpha-blended-drawing&quot;&gt;alpha-blended drawing&lt;/a&gt;.</source>
          <target state="translated">除了标准的CMYK模型外，Qt还提供了一个alpha通道，以具有&lt;a href=&quot;qcolor#alpha-blended-drawing&quot;&gt;alpha混合绘图功能&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0be17f054f12e2fb38a6a1f485ac2bf01fa897ed" translate="yes" xml:space="preserve">
          <source>In addition to the standard HSV model, Qt provides an alpha-channel to feature &lt;a href=&quot;qcolor#alpha-blended-drawing&quot;&gt;alpha-blended drawing&lt;/a&gt;.</source>
          <target state="translated">除了标准的HSV模型外，Qt还提供了一个alpha通道，以具有&lt;a href=&quot;qcolor#alpha-blended-drawing&quot;&gt;alpha混合绘图功能&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f9c4e1ecc5601fcf9e9447bb69488d9d57d4ef15" translate="yes" xml:space="preserve">
          <source>In addition to the standard toolbar and context menu entries, there is also a set of keyboard shortcuts to apply layouts on widgets.</source>
          <target state="translated">除了标准的工具栏和上下文菜单条目外,还有一组键盘快捷键,用于在小组件上应用布局。</target>
        </trans-unit>
        <trans-unit id="b09afcccf5027fee867e941626ff3448febeaf82" translate="yes" xml:space="preserve">
          <source>In addition to the standard widget styles for each platform, widgets can also be styled according to rules specified in a &lt;a href=&quot;stylesheet&quot;&gt;style sheet&lt;/a&gt;. This feature enables you to customize the appearance of specific widgets to provide visual cues to users about their purpose. For example, a button could be styled in a particular way to indicate that it performs a destructive action.</source>
          <target state="translated">除了每个平台的标准窗口小部件样式外，还可以根据&lt;a href=&quot;stylesheet&quot;&gt;样式表中&lt;/a&gt;指定的规则来设置窗口小部件的样式。此功能使您可以自定义特定小部件的外观，以向用户提供有关其用途的视觉提示。例如，可以以特定方式设置按钮样式，以指示其执行了破坏性操作。</target>
        </trans-unit>
        <trans-unit id="6dcbc9ef9242a5ec4e23f73cbc3b577f639b3b87" translate="yes" xml:space="preserve">
          <source>In addition to the standard widget styles for each platform, widgets can also be styled according to rules specified in a &lt;a href=&quot;stylesheet#&quot;&gt;style sheet&lt;/a&gt;. This feature enables you to customize the appearance of specific widgets to provide visual cues to users about their purpose. For example, a button could be styled in a particular way to indicate that it performs a destructive action.</source>
          <target state="translated">除了每个平台的标准窗口小部件样式外，还可以根据&lt;a href=&quot;stylesheet#&quot;&gt;样式表中&lt;/a&gt;指定的规则来设置窗口小部件的样式。此功能使您可以自定义特定小部件的外观，以向用户提供有关其用途的视觉提示。例如，可以以特定方式设置按钮样式，以指示其执行了破坏性操作。</target>
        </trans-unit>
        <trans-unit id="9bae76ffe4383123793f13b43b96fced6eb87f9b" translate="yes" xml:space="preserve">
          <source>In addition to the supported extensions above, many other common extensions will be returned in a reasonably structured way. Extensions that the SSL backend has no support for at all will be returned as a &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt;.</source>
          <target state="translated">除了上面支持的扩展之外，还将以合理的结构方式返回许多其他常见的扩展。SSL后端完全不支持的扩展将作为&lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt;返回。</target>
        </trans-unit>
        <trans-unit id="045bbb78e1954a03a7a0c662484fd4300d5c27fc" translate="yes" xml:space="preserve">
          <source>In addition to the username and password required for authentication, a &lt;a href=&quot;qauthenticator&quot;&gt;QAuthenticator&lt;/a&gt; object can also contain additional options. The &lt;a href=&quot;qauthenticator#options&quot;&gt;options&lt;/a&gt;() function can be used to query incoming options sent by the server; the &lt;a href=&quot;qauthenticator#setOption&quot;&gt;setOption&lt;/a&gt;() function can be used to set outgoing options, to be processed by the authenticator calculation. The options accepted and provided depend on the authentication type (see method()).</source>
          <target state="translated">除了身份验证所需的用户名和密码之外，&lt;a href=&quot;qauthenticator&quot;&gt;QAuthenticator&lt;/a&gt;对象还可以包含其他选项。的&lt;a href=&quot;qauthenticator#options&quot;&gt;选项&lt;/a&gt;（）函数可以被用于由服务器发送查询传入选项;所述&lt;a href=&quot;qauthenticator#setOption&quot;&gt;的SetOption&lt;/a&gt;（）函数可以被用来指定设备发送的选择，以由认证计算处理。接受和提供的选项取决于身份验证类型（请参见method（））。</target>
        </trans-unit>
        <trans-unit id="a2b6063dc6e8ba50cdc3adbfbf879598fd578538" translate="yes" xml:space="preserve">
          <source>In addition to the username and password required for authentication, a QAuthenticator object can also contain additional options. The &lt;a href=&quot;qauthenticator#options&quot;&gt;options&lt;/a&gt;() function can be used to query incoming options sent by the server; the &lt;a href=&quot;qauthenticator#setOption&quot;&gt;setOption&lt;/a&gt;() function can be used to set outgoing options, to be processed by the authenticator calculation. The options accepted and provided depend on the authentication type (see method()).</source>
          <target state="translated">除了身份验证所需的用户名和密码之外，QAuthenticator对象还可以包含其他选项。的&lt;a href=&quot;qauthenticator#options&quot;&gt;选项&lt;/a&gt;（）函数可以被用于由服务器发送查询传入选项; 所述&lt;a href=&quot;qauthenticator#setOption&quot;&gt;的SetOption&lt;/a&gt;（）函数可以被用来指定设备发送的选择，以由认证计算处理。接受和提供的选项取决于身份验证类型（请参见method（））。</target>
        </trans-unit>
        <trans-unit id="dae48ceb544b86a9722e1bf250b1c20f5f9e3d04" translate="yes" xml:space="preserve">
          <source>In addition to the usual checked and unchecked states, &lt;a href=&quot;qcheckbox&quot;&gt;QCheckBox&lt;/a&gt; optionally provides a third state to indicate &quot;no change&quot;. This is useful whenever you need to give the user the option of neither checking nor unchecking a checkbox. If you need this third state, enable it with &lt;a href=&quot;qcheckbox#tristate-prop&quot;&gt;setTristate&lt;/a&gt;(), and use &lt;a href=&quot;qcheckbox#checkState&quot;&gt;checkState&lt;/a&gt;() to query the current toggle state.</source>
          <target state="translated">除了通常的选中和未选中状态之外，&lt;a href=&quot;qcheckbox&quot;&gt;QCheckBox还&lt;/a&gt;可以选择提供第三种状态以指示&amp;ldquo;无更改&amp;rdquo;。每当您需要为用户提供既不选中也不取消选中复选框的选项时，这将很有用。如果需要此第三状态，请使用&lt;a href=&quot;qcheckbox#tristate-prop&quot;&gt;setTristate&lt;/a&gt;（）启用它，然后使用&lt;a href=&quot;qcheckbox#checkState&quot;&gt;checkState&lt;/a&gt;（）查询当前的切换状态。</target>
        </trans-unit>
        <trans-unit id="4482092064f941cb7bf1f4780f1f4f1c7aa06a10" translate="yes" xml:space="preserve">
          <source>In addition to the usual checked and unchecked states, QCheckBox optionally provides a third state to indicate &quot;no change&quot;. This is useful whenever you need to give the user the option of neither checking nor unchecking a checkbox. If you need this third state, enable it with &lt;a href=&quot;qcheckbox#tristate-prop&quot;&gt;setTristate&lt;/a&gt;(), and use &lt;a href=&quot;qcheckbox#checkState&quot;&gt;checkState&lt;/a&gt;() to query the current toggle state.</source>
          <target state="translated">除了通常的选中和未选中状态之外，QCheckBox还可以选择提供第三种状态来指示&amp;ldquo;无更改&amp;rdquo;。每当您需要为用户提供既不选中也不取消选中复选框的选项时，此功能将非常有用。如果需要此第三个状态，请使用&lt;a href=&quot;qcheckbox#tristate-prop&quot;&gt;setTristate&lt;/a&gt;（）启用它，然后使用&lt;a href=&quot;qcheckbox#checkState&quot;&gt;checkState&lt;/a&gt;（）查询当前的切换状态。</target>
        </trans-unit>
        <trans-unit id="43521fb550ae8e7c824622aefa4d418ea35da248" translate="yes" xml:space="preserve">
          <source>In addition to the wizard style, there are several options that control the look and feel of the wizard. These can be set using &lt;a href=&quot;qwizard#setOption&quot;&gt;setOption&lt;/a&gt;() or &lt;a href=&quot;qwizard#options-prop&quot;&gt;setOptions&lt;/a&gt;(). For example, &lt;a href=&quot;qwizard#WizardOption-enum&quot;&gt;HaveHelpButton&lt;/a&gt; makes &lt;a href=&quot;qwizard&quot;&gt;QWizard&lt;/a&gt; show a &lt;b&gt;Help&lt;/b&gt; button along with the other wizard buttons.</source>
          <target state="translated">除向导样式外，还有几个选项可控制向导的外观。可以使用&lt;a href=&quot;qwizard#setOption&quot;&gt;setOption&lt;/a&gt;（）或&lt;a href=&quot;qwizard#options-prop&quot;&gt;setOptions&lt;/a&gt;（）进行设置。例如，&lt;a href=&quot;qwizard#WizardOption-enum&quot;&gt;HaveHelpButton&lt;/a&gt;使&lt;a href=&quot;qwizard&quot;&gt;QWizard&lt;/a&gt;显示&lt;b&gt;帮助&lt;/b&gt;按钮以及其他向导按钮。</target>
        </trans-unit>
        <trans-unit id="23f86e084dc4b0f965e695b5d8e8e250be404e69" translate="yes" xml:space="preserve">
          <source>In addition to the wizard style, there are several options that control the look and feel of the wizard. These can be set using &lt;a href=&quot;qwizard#setOption&quot;&gt;setOption&lt;/a&gt;() or &lt;a href=&quot;qwizard#options-prop&quot;&gt;setOptions&lt;/a&gt;(). For example, &lt;a href=&quot;qwizard#WizardOption-enum&quot;&gt;HaveHelpButton&lt;/a&gt; makes QWizard show a &lt;b&gt;Help&lt;/b&gt; button along with the other wizard buttons.</source>
          <target state="translated">除向导样式外，还有几个选项可控制向导的外观。可以使用&lt;a href=&quot;qwizard#setOption&quot;&gt;setOption&lt;/a&gt;（）或&lt;a href=&quot;qwizard#options-prop&quot;&gt;setOptions&lt;/a&gt;（）进行设置。例如，&lt;a href=&quot;qwizard#WizardOption-enum&quot;&gt;HaveHelpButton&lt;/a&gt;使QWizard显示&lt;b&gt;帮助&lt;/b&gt;按钮以及其他向导按钮。</target>
        </trans-unit>
        <trans-unit id="3d9f4713c3814a84441ed7cc08ac012384c4c7c1" translate="yes" xml:space="preserve">
          <source>In addition to types deriving from Node, it is also possible to parent other types to a Node. This includes &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; instances, where the Node merely serves as the &lt;a href=&quot;qobject#parent&quot;&gt;QObject parent&lt;/a&gt;, and &lt;a href=&quot;qtquick3d-2d&quot;&gt;Qt Quick items&lt;/a&gt;.</source>
          <target state="translated">除了从Node派生的类型之外，还可以将其他类型作为父对象。这包括&lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;实例（其中Node仅充当&lt;a href=&quot;qobject#parent&quot;&gt;QObject的父对象&lt;/a&gt;）和&lt;a href=&quot;qtquick3d-2d&quot;&gt;Qt Quick项目&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e17331832d0fac1a23987c46547dc1e75ff48651" translate="yes" xml:space="preserve">
          <source>In addition to using static meshes, it is possible to implement a &lt;a href=&quot;qquick3dgeometry&quot;&gt;custom geometry&lt;/a&gt; provider that provides the model with custom vertex data at run-time. See the &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtquick3d-customgeometry-example.html&quot;&gt;Custom Geometry Example&lt;/a&gt; for an example on how to create and use a custom material with your model.</source>
          <target state="translated">除了使用静态网格物体外，还可以实现一个&lt;a href=&quot;qquick3dgeometry&quot;&gt;自定义几何图形&lt;/a&gt;提供程序，该提供程序在运行时为模型提供自定义顶点数据。有关如何在模型中创建和使用自定义材料的示例，请参见&amp;ldquo;&lt;a href=&quot;https://doc.qt.io/qt-6.0/qtquick3d-customgeometry-example.html&quot;&gt;自定义几何示例&lt;/a&gt;&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="cdd18e5b71e6b68fe8f805a94a5e93bdd8b32775" translate="yes" xml:space="preserve">
          <source>In addition you can query the current formatting and user data using the &lt;a href=&quot;qsyntaxhighlighter#format&quot;&gt;format&lt;/a&gt;() and &lt;a href=&quot;qsyntaxhighlighter#currentBlockUserData&quot;&gt;currentBlockUserData&lt;/a&gt;() functions respectively. You can also attach user data to the current text block using the &lt;a href=&quot;qsyntaxhighlighter#setCurrentBlockUserData&quot;&gt;setCurrentBlockUserData&lt;/a&gt;() function. &lt;a href=&quot;qtextblockuserdata&quot;&gt;QTextBlockUserData&lt;/a&gt; can be used to store custom settings. In the case of syntax highlighting, it is in particular interesting as cache storage for information that you may figure out while parsing the paragraph's text. For an example, see the &lt;a href=&quot;qsyntaxhighlighter#setCurrentBlockUserData&quot;&gt;setCurrentBlockUserData&lt;/a&gt;() documentation.</source>
          <target state="translated">另外，您可以分别使用&lt;a href=&quot;qsyntaxhighlighter#format&quot;&gt;format&lt;/a&gt;（）和&lt;a href=&quot;qsyntaxhighlighter#currentBlockUserData&quot;&gt;currentBlockUserData&lt;/a&gt;（）函数查询当前格式和用户数据。您还可以使用&lt;a href=&quot;qsyntaxhighlighter#setCurrentBlockUserData&quot;&gt;setCurrentBlockUserData&lt;/a&gt;（）函数将用户数据附加到当前文本块。&lt;a href=&quot;qtextblockuserdata&quot;&gt;QTextBlockUserData&lt;/a&gt;可用于存储自定义设置。在语法高亮显示的情况下，它特别有趣，因为它可以存储在解析段落文本时可能会发现的信息。有关示例，请参见&lt;a href=&quot;qsyntaxhighlighter#setCurrentBlockUserData&quot;&gt;setCurrentBlockUserData&lt;/a&gt;（）文档。</target>
        </trans-unit>
        <trans-unit id="a09089230bafdc9eed0b4278c8a9e46cfe92e906" translate="yes" xml:space="preserve">
          <source>In addition you can specify a curve's threshold, controlling the granularity with which a curve is drawn, using the &lt;a href=&quot;qpainterpathstroker#setCurveThreshold&quot;&gt;setCurveThreshold&lt;/a&gt;() function. The default threshold is a well adjusted value (0.25), and normally you should not need to modify it. However, you can make the curve's appearance smoother by decreasing its value.</source>
          <target state="translated">另外，您可以使用&lt;a href=&quot;qpainterpathstroker#setCurveThreshold&quot;&gt;setCurveThreshold&lt;/a&gt;（）函数来指定曲线的阈值，控制绘制曲线的粒度。默认阈值是一个调整良好的值（0.25），通常您无需修改​​它。但是，可以通过减小其值来使曲线的外观更平滑。</target>
        </trans-unit>
        <trans-unit id="af9d69a85de071c5503c968b6878570e7a051f81" translate="yes" xml:space="preserve">
          <source>In addition,</source>
          <target state="translated">此外:</target>
        </trans-unit>
        <trans-unit id="4babc89dd6c166e0c65f2079d856d20f7a427c69" translate="yes" xml:space="preserve">
          <source>In addition, &lt;a href=&quot;qbuttongroup&quot;&gt;QButtonGroup&lt;/a&gt; can map between integers and buttons. You can assign an integer id to a button with &lt;a href=&quot;qbuttongroup#setId&quot;&gt;setId&lt;/a&gt;(), and retrieve it with &lt;a href=&quot;qbuttongroup#id&quot;&gt;id&lt;/a&gt;(). The id of the currently checked button is available with &lt;a href=&quot;qbuttongroup#checkedId&quot;&gt;checkedId&lt;/a&gt;(), and there is an overloaded signal &lt;a href=&quot;qbuttongroup#buttonClicked&quot;&gt;buttonClicked&lt;/a&gt;() which emits the id of the button. The id &lt;code&gt;-1&lt;/code&gt; is reserved by &lt;a href=&quot;qbuttongroup&quot;&gt;QButtonGroup&lt;/a&gt; to mean &quot;no such button&quot;. The purpose of the mapping mechanism is to simplify the representation of enum values in a user interface.</source>
          <target state="translated">另外，&lt;a href=&quot;qbuttongroup&quot;&gt;QButtonGroup&lt;/a&gt;可以在整数和按钮之间进行映射。您可以使用&lt;a href=&quot;qbuttongroup#setId&quot;&gt;setId&lt;/a&gt;（）为按钮分配一个整数id ，然后使用&lt;a href=&quot;qbuttongroup#id&quot;&gt;id&lt;/a&gt;（）对其进行检索。当前选中的按钮的id可与&lt;a href=&quot;qbuttongroup#checkedId&quot;&gt;checkedId&lt;/a&gt;（）一起使用，并且有一个重载的信号&lt;a href=&quot;qbuttongroup#buttonClicked&quot;&gt;buttonClicked&lt;/a&gt;（），它发出按钮的id。id &lt;code&gt;-1&lt;/code&gt; 由&lt;a href=&quot;qbuttongroup&quot;&gt;QButtonGroup&lt;/a&gt;保留，表示&amp;ldquo;无此按钮&amp;rdquo;。映射机制的目的是简化用户界面中枚举值的表示。</target>
        </trans-unit>
        <trans-unit id="e9800f88f80534b79f93e4fbc116787e4a0a4bc9" translate="yes" xml:space="preserve">
          <source>In addition, &lt;a href=&quot;qdesignerformwindowmanagerinterface&quot;&gt;QDesignerFormWindowManagerInterface&lt;/a&gt; contains a collection of functions that enables you to intervene and control</source>
          <target state="translated">另外，&lt;a href=&quot;qdesignerformwindowmanagerinterface&quot;&gt;QDesignerFormWindowManagerInterface&lt;/a&gt;包含一组函数，使您可以进行干预和控制</target>
        </trans-unit>
        <trans-unit id="7101167786b4f33575c031b3f25584c8316f3307" translate="yes" xml:space="preserve">
          <source>In addition, &lt;a href=&quot;qgraphicsitemgroup&quot;&gt;QGraphicsItemGroup&lt;/a&gt; is a special item that combines child event handling with a useful interface for adding and removing items to and from a group. Adding an item to a &lt;a href=&quot;qgraphicsitemgroup&quot;&gt;QGraphicsItemGroup&lt;/a&gt; will keep the item's original position and transformation, whereas reparenting items in general will cause the child to reposition itself relative to its new parent. For convenience, you can create &lt;a href=&quot;qgraphicsitemgroup&quot;&gt;QGraphicsItemGroup&lt;/a&gt;s through the scene by calling &lt;a href=&quot;qgraphicsscene#createItemGroup&quot;&gt;QGraphicsScene::createItemGroup&lt;/a&gt;().</source>
          <target state="translated">此外，&lt;a href=&quot;qgraphicsitemgroup&quot;&gt;QGraphicsItemGroup&lt;/a&gt;是一个特殊项目，它将子事件处理与有用的界面相结合，用于在组中添加项或从组中删除项。将项目添加到&lt;a href=&quot;qgraphicsitemgroup&quot;&gt;QGraphicsItemGroup&lt;/a&gt;中将保留该项目的原始位置和变换，而通常对项目进行父项设置将导致子级相对于其新父级重新定位自身。为了方便起见，您可以通过调用&lt;a href=&quot;qgraphicsscene#createItemGroup&quot;&gt;QGraphicsScene :: createItemGroup&lt;/a&gt;（）在整个场景中创建&lt;a href=&quot;qgraphicsitemgroup&quot;&gt;QGraphicsItemGroup&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9932170715abe979bd672a850450f1e95e87f370" translate="yes" xml:space="preserve">
          <source>In addition, &lt;a href=&quot;qml-qtquick-viewtransition&quot;&gt;ViewTransition&lt;/a&gt; provides properties specific to the items which are the target of the operation that triggered the transition:</source>
          <target state="translated">另外，&lt;a href=&quot;qml-qtquick-viewtransition&quot;&gt;ViewTransition&lt;/a&gt;提供了特定于项目的属性，这些属性是触发过渡的操作的目标：</target>
        </trans-unit>
        <trans-unit id="f47e93a20e07e14b05f17c112a8284c932cb10fd" translate="yes" xml:space="preserve">
          <source>In addition, &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; provides the &lt;a href=&quot;qrect#getCoords&quot;&gt;getCoords&lt;/a&gt;() function which extracts the position of the rectangle's top-left and bottom-right corner, and the &lt;a href=&quot;qrect#getRect&quot;&gt;getRect&lt;/a&gt;() function which extracts the rectangle's top-left corner, width and height. Use the &lt;a href=&quot;qrect#setCoords&quot;&gt;setCoords&lt;/a&gt;() and &lt;a href=&quot;qrect#setRect&quot;&gt;setRect&lt;/a&gt;() function to manipulate the rectangle's coordinates and dimensions in one go.</source>
          <target state="translated">另外，&lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt;提供了&lt;a href=&quot;qrect#getCoords&quot;&gt;getCoords&lt;/a&gt;（）函数，该函数提取矩形的左上角和右下角的位置，以及&lt;a href=&quot;qrect#getRect&quot;&gt;getRect&lt;/a&gt;（）函数，提取矩形的左上角，宽度和高度。使用&lt;a href=&quot;qrect#setCoords&quot;&gt;setCoords&lt;/a&gt;（）和&lt;a href=&quot;qrect#setRect&quot;&gt;setRect&lt;/a&gt;（）函数可以一次性操作矩形的坐标和尺寸。</target>
        </trans-unit>
        <trans-unit id="28c715c4d611d2eace18dfa7ba865f61b93cdbfb" translate="yes" xml:space="preserve">
          <source>In addition, &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; provides the &lt;a href=&quot;qrectf#getCoords&quot;&gt;getCoords&lt;/a&gt;() function which extracts the position of the rectangle's top-left and bottom-right corner, and the &lt;a href=&quot;qrectf#getRect&quot;&gt;getRect&lt;/a&gt;() function which extracts the rectangle's top-left corner, width and height. Use the &lt;a href=&quot;qrectf#setCoords&quot;&gt;setCoords&lt;/a&gt;() and &lt;a href=&quot;qrectf#setRect&quot;&gt;setRect&lt;/a&gt;() function to manipulate the rectangle's coordinates and dimensions in one go.</source>
          <target state="translated">另外，&lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt;提供了&lt;a href=&quot;qrectf#getCoords&quot;&gt;getCoords&lt;/a&gt;（）函数，该函数提取矩形的左上角和右下角的位置，以及&lt;a href=&quot;qrectf#getRect&quot;&gt;getRect&lt;/a&gt;（）函数，提取矩形的左上角，宽度和高度。使用&lt;a href=&quot;qrectf#setCoords&quot;&gt;setCoords&lt;/a&gt;（）和&lt;a href=&quot;qrectf#setRect&quot;&gt;setRect&lt;/a&gt;（）函数可以一次性操作矩形的坐标和尺寸。</target>
        </trans-unit>
        <trans-unit id="909743cdef726cab568394ea75f444bd548316d7" translate="yes" xml:space="preserve">
          <source>In addition, &lt;a href=&quot;qregularexpressionmatch&quot;&gt;QRegularExpressionMatch&lt;/a&gt; returns the substrings captured by the capturing groups in the pattern string. The implicit capturing group with index 0 captures the result of the whole match. The &lt;a href=&quot;qregularexpressionmatch#captured&quot;&gt;captured&lt;/a&gt;() function returns each substring captured, either by the capturing group's index or by its name:</source>
          <target state="translated">另外，&lt;a href=&quot;qregularexpressionmatch&quot;&gt;QRegularExpressionMatch&lt;/a&gt;返回模式字符串中捕获组捕获的子字符串。索引为0的隐式捕获组捕获整个匹配的结果。所述&lt;a href=&quot;qregularexpressionmatch#captured&quot;&gt;捕获的&lt;/a&gt;（）函数返回每个子捕获，或者通过捕获组的索引或通过其名称：</target>
        </trans-unit>
        <trans-unit id="dee0d9a370aaadea9a4d185748317b1c06665f7b" translate="yes" xml:space="preserve">
          <source>In addition, BeginNativeGesture and EndNativeGesture are sent before and after gesture event streams:</source>
          <target state="translated">此外,BeginNativeGesture和EndNativeGesture在手势事件流前后发送。</target>
        </trans-unit>
        <trans-unit id="ef758b3f8333e9857e8cbd013860ab9e6d7dcdcb" translate="yes" xml:space="preserve">
          <source>In addition, D-Bus defines two well-known buses, called the system bus and the session bus. These buses are special in the sense that they have well-defined semantics: some services are defined to be found in one or both of these buses.</source>
          <target state="translated">此外,D-Bus还定义了两个著名的总线,称为系统总线和会话总线。这些总线的特殊之处在于它们具有明确的语义:一些服务被定义为可以在这些总线中的一个或两个中找到。</target>
        </trans-unit>
        <trans-unit id="d56d60278f8be76536f6341fadefef1c9f1e809d" translate="yes" xml:space="preserve">
          <source>In addition, QButtonGroup can map between integers and buttons. You can assign an integer id to a button with &lt;a href=&quot;qbuttongroup#setId&quot;&gt;setId&lt;/a&gt;(), and retrieve it with &lt;a href=&quot;qbuttongroup#id&quot;&gt;id&lt;/a&gt;(). The id of the currently checked button is available with &lt;a href=&quot;qbuttongroup#checkedId&quot;&gt;checkedId&lt;/a&gt;(), and there is an overloaded signal &lt;a href=&quot;qbuttongroup#buttonClicked&quot;&gt;buttonClicked&lt;/a&gt;() which emits the id of the button. The id &lt;code&gt;-1&lt;/code&gt; is reserved by QButtonGroup to mean &quot;no such button&quot;. The purpose of the mapping mechanism is to simplify the representation of enum values in a user interface.</source>
          <target state="translated">另外，QButtonGroup可以在整数和按钮之间进行映射。您可以使用&lt;a href=&quot;qbuttongroup#setId&quot;&gt;setId&lt;/a&gt;（）将整数id分配给按钮，然后使用&lt;a href=&quot;qbuttongroup#id&quot;&gt;id&lt;/a&gt;（）检索它。当前选中按钮的ID可以与&lt;a href=&quot;qbuttongroup#checkedId&quot;&gt;checkedId&lt;/a&gt;（）一起使用，并且有一个重载的信号&lt;a href=&quot;qbuttongroup#buttonClicked&quot;&gt;buttonClicked&lt;/a&gt;（），它发出按钮的ID。id &lt;code&gt;-1&lt;/code&gt; 由QButtonGroup保留，表示&amp;ldquo;无此按钮&amp;rdquo;。映射机制的目的是简化用户界面中枚举值的表示。</target>
        </trans-unit>
        <trans-unit id="b272ac8c70fa82b3823671e5cb7a241a63ebee31" translate="yes" xml:space="preserve">
          <source>In addition, QDesignerFormWindowManagerInterface contains a collection of functions that enables you to intervene and control</source>
          <target state="translated">此外,QDesignerFormWindowManagerInterface还包含了一个函数集合,可以让您干预和控制</target>
        </trans-unit>
        <trans-unit id="58ee892583deb6d4d41b8c8b843c3b60ef4c1329" translate="yes" xml:space="preserve">
          <source>In addition, QML also extends the behavior of the instanceof function to allow for type checking against QML types. This means that you may use it to verify that a variable is indeed the type you expect, for example:</source>
          <target state="translated">此外,QML还扩展了instanceof函数的行为,允许对QML类型进行类型检查。这意味着您可以用它来验证一个变量是否确实是您所期望的类型,例如。</target>
        </trans-unit>
        <trans-unit id="77026bc774f019d465cb985bb88e2ef3536b43fb" translate="yes" xml:space="preserve">
          <source>In addition, QML provides several other types useful for animation:</source>
          <target state="translated">此外,QML还提供了其他几种对动画有用的类型。</target>
        </trans-unit>
        <trans-unit id="78909068f57e396d3206a9f3bf48e373f6f281be" translate="yes" xml:space="preserve">
          <source>In addition, QRect provides the &lt;a href=&quot;qrect#getCoords&quot;&gt;getCoords&lt;/a&gt;() function which extracts the position of the rectangle's top-left and bottom-right corner, and the &lt;a href=&quot;qrect#getRect&quot;&gt;getRect&lt;/a&gt;() function which extracts the rectangle's top-left corner, width and height. Use the &lt;a href=&quot;qrect#setCoords&quot;&gt;setCoords&lt;/a&gt;() and &lt;a href=&quot;qrect#setRect&quot;&gt;setRect&lt;/a&gt;() function to manipulate the rectangle's coordinates and dimensions in one go.</source>
          <target state="translated">另外，QRect提供了&lt;a href=&quot;qrect#getCoords&quot;&gt;getCoords&lt;/a&gt;（）函数，该函数提取矩形的左上角和右下角的位置，以及&lt;a href=&quot;qrect#getRect&quot;&gt;getRect&lt;/a&gt;（）函数，提取矩形的左上角，宽度和高度。使用&lt;a href=&quot;qrect#setCoords&quot;&gt;setCoords&lt;/a&gt;（）和&lt;a href=&quot;qrect#setRect&quot;&gt;setRect&lt;/a&gt;（）函数可以一次性操作矩形的坐标和尺寸。</target>
        </trans-unit>
        <trans-unit id="5fcb487f588f206f89ed9d6a0a32c7d80fdf204b" translate="yes" xml:space="preserve">
          <source>In addition, QRectF provides the &lt;a href=&quot;qrectf#getCoords&quot;&gt;getCoords&lt;/a&gt;() function which extracts the position of the rectangle's top-left and bottom-right corner, and the &lt;a href=&quot;qrectf#getRect&quot;&gt;getRect&lt;/a&gt;() function which extracts the rectangle's top-left corner, width and height. Use the &lt;a href=&quot;qrectf#setCoords&quot;&gt;setCoords&lt;/a&gt;() and &lt;a href=&quot;qrectf#setRect&quot;&gt;setRect&lt;/a&gt;() function to manipulate the rectangle's coordinates and dimensions in one go.</source>
          <target state="translated">另外，QRectF提供了&lt;a href=&quot;qrectf#getCoords&quot;&gt;getCoords&lt;/a&gt;（）函数，该函数提取矩形的左上角和右下角的位置，以及&lt;a href=&quot;qrectf#getRect&quot;&gt;getRect&lt;/a&gt;（）函数，提取矩形的左上角，宽度和高度。使用&lt;a href=&quot;qrectf#setCoords&quot;&gt;setCoords&lt;/a&gt;（）和&lt;a href=&quot;qrectf#setRect&quot;&gt;setRect&lt;/a&gt;（）函数可以一次性操作矩形的坐标和尺寸。</target>
        </trans-unit>
        <trans-unit id="a45b9993bfcae9c5dba0def58fd31a905dee9509" translate="yes" xml:space="preserve">
          <source>In addition, QRegularExpressionMatch returns the substrings captured by the capturing groups in the pattern string. The implicit capturing group with index 0 captures the result of the whole match. The &lt;a href=&quot;qregularexpressionmatch#captured&quot;&gt;captured&lt;/a&gt;() function returns each substring captured, either by the capturing group's index or by its name:</source>
          <target state="translated">另外，QRegularExpressionMatch返回模式字符串中捕获组捕获的子字符串。索引为0的隐式捕获组捕获整个匹配的结果。所述&lt;a href=&quot;qregularexpressionmatch#captured&quot;&gt;捕获的&lt;/a&gt;（）函数返回每个子捕获，或者通过捕获组的索引或通过其名称：</target>
        </trans-unit>
        <trans-unit id="9cb9a05822f94850d265bd43fe3ad424a0579317" translate="yes" xml:space="preserve">
          <source>In addition, Qt Core provides a platform-independent mechanism for storing binary files in the application's executable.</source>
          <target state="translated">此外,Qt Core还提供了一个独立于平台的机制,用于在应用程序的可执行文件中存储二进制文件。</target>
        </trans-unit>
        <trans-unit id="e6413e0907e17d23446cc05dbd3e37c5fbc5bdc3" translate="yes" xml:space="preserve">
          <source>In addition, Qt Wayland Compositor is available under the &lt;a href=&quot;http://www.gnu.org/licenses/gpl-3.0.html&quot;&gt;GNU General Public License, version 3&lt;/a&gt;, while the Qt Wayland integration plugin is available under the &lt;a href=&quot;http://www.gnu.org/licenses/gpl-3.0.html&quot;&gt;GNU General Public License, version 3&lt;/a&gt; or the &lt;a href=&quot;http://www.gnu.org/licenses/gpl-2.0.html&quot;&gt;GNU General Public License, version 2&lt;/a&gt;.</source>
          <target state="translated">此外，可以在&lt;a href=&quot;http://www.gnu.org/licenses/gpl-3.0.html&quot;&gt;GNU通用公共许可证版本3&lt;/a&gt;下使用Qt Wayland Compositor ，而在&lt;a href=&quot;http://www.gnu.org/licenses/gpl-3.0.html&quot;&gt;GNU通用公共许可证版本3&lt;/a&gt;或&lt;a href=&quot;http://www.gnu.org/licenses/gpl-2.0.html&quot;&gt;GNU通用公共许可证版本2上&lt;/a&gt;可以使用Qt Wayland集成插件。</target>
        </trans-unit>
        <trans-unit id="20672dc5f5c1fd25cf3853bdfddac936b1f7b9c7" translate="yes" xml:space="preserve">
          <source>In addition, Qt Wayland Compositor is available under the &lt;a href=&quot;https://www.gnu.org/licenses/gpl-3.0.html&quot;&gt;GNU General Public License, version 3&lt;/a&gt;, while the Qt Wayland integration plugin is available under the &lt;a href=&quot;https://www.gnu.org/licenses/gpl-3.0.html&quot;&gt;GNU General Public License, version 3&lt;/a&gt; or the &lt;a href=&quot;https://www.gnu.org/licenses/gpl-2.0.html&quot;&gt;GNU General Public License, version 2&lt;/a&gt;.</source>
          <target state="translated">此外，可以在&lt;a href=&quot;https://www.gnu.org/licenses/gpl-3.0.html&quot;&gt;GNU通用公共许可证版本3&lt;/a&gt;下使用Qt Wayland Compositor ，而在&lt;a href=&quot;https://www.gnu.org/licenses/gpl-3.0.html&quot;&gt;GNU通用公共许可证版本3&lt;/a&gt;或&lt;a href=&quot;https://www.gnu.org/licenses/gpl-2.0.html&quot;&gt;GNU通用公共许可证版本2上&lt;/a&gt;可以使用Qt Wayland集成插件。</target>
        </trans-unit>
        <trans-unit id="a75f43f682b1fd3051c65a70b2469454aa434705" translate="yes" xml:space="preserve">
          <source>In addition, Qt provides three global manipulators that take a parameter: &lt;a href=&quot;qtextstream#qSetFieldWidth&quot;&gt;qSetFieldWidth&lt;/a&gt;(), &lt;a href=&quot;qtextstream#qSetPadChar&quot;&gt;qSetPadChar&lt;/a&gt;(), and &lt;a href=&quot;qtextstream#qSetRealNumberPrecision&quot;&gt;qSetRealNumberPrecision&lt;/a&gt;().</source>
          <target state="translated">此外，Qt提供了三个带参数的全局操纵器：&lt;a href=&quot;qtextstream#qSetFieldWidth&quot;&gt;qSetFieldWidth&lt;/a&gt;（），&lt;a href=&quot;qtextstream#qSetPadChar&quot;&gt;qSetPadChar&lt;/a&gt;（）和&lt;a href=&quot;qtextstream#qSetRealNumberPrecision&quot;&gt;qSetRealNumberPrecision&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="ec6ba1dfccefb8ea0bface2588cf2a1aa451cc7f" translate="yes" xml:space="preserve">
          <source>In addition, ViewTransition provides properties specific to the items which are the target of the operation that triggered the transition:</source>
          <target state="translated">此外,ViewTransition还提供了特定于触发过渡的操作目标的项目的属性。</target>
        </trans-unit>
        <trans-unit id="b914c9a13b980209076c664272d3474ddbfaeedf" translate="yes" xml:space="preserve">
          <source>In addition, Windows are always filled with &lt;a href=&quot;qpalette#ColorRole-enum&quot;&gt;QPalette::Window&lt;/a&gt;, unless the WA_OpaquePaintEvent or WA_NoSystemBackground attributes are set.</source>
          <target state="translated">此外，除非设置WA_OpaquePaintEvent或WA_NoSystemBackground属性，否则Windows始终会用&lt;a href=&quot;qpalette#ColorRole-enum&quot;&gt;QPalette :: Window&lt;/a&gt;填充。</target>
        </trans-unit>
        <trans-unit id="d2ad048be8b28912305cac5e9340fbdf557eb523" translate="yes" xml:space="preserve">
          <source>In addition, a &lt;a href=&quot;qinappstore#transactionReady&quot;&gt;transactionReady&lt;/a&gt;() signal may be emitted for any existing transaction which has not yet been finalized. At this point, you should check if the transaction has previously been registered. If it hasn't, register it right away. Finally, call &lt;a href=&quot;qinapptransaction#finalize&quot;&gt;QInAppTransaction::finalize&lt;/a&gt;() on the transaction.</source>
          <target state="translated">另外，可以为尚未完成的任何现有事务发出&lt;a href=&quot;qinappstore#transactionReady&quot;&gt;transactionReady&lt;/a&gt;（）信号。此时，您应该检查该交易之前是否已注册。如果还没有，请立即注册。最后，在事务上调用&lt;a href=&quot;qinapptransaction#finalize&quot;&gt;QInAppTransaction :: finalize&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="298aaf11e6ababff88df1d84101d9d211251a1d1" translate="yes" xml:space="preserve">
          <source>In addition, a &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; that has a parent can become a window by setting the &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt::Window&lt;/a&gt; flag. Depending on the window management system such</source>
          <target state="translated">此外，通过设置&lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt :: Window&lt;/a&gt;标志，具有父级的&lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt;可以成为窗口。取决于这样的窗口管理系统</target>
        </trans-unit>
        <trans-unit id="6c383d87d9ecf4b661ffc1a562764aa9bc4166c8" translate="yes" xml:space="preserve">
          <source>In addition, a &lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;QWidget&lt;/a&gt; that has a parent can become a window by setting the &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt::Window&lt;/a&gt; flag. Depending on the window management system such</source>
          <target state="translated">另外，通过设置&lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt :: Window&lt;/a&gt;标志，具有父项的&lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;QWidget&lt;/a&gt;可以成为窗口。取决于这样的窗口管理系统</target>
        </trans-unit>
        <trans-unit id="83d5a80e1b843b708991828a30680c97b1afbd2b" translate="yes" xml:space="preserve">
          <source>In addition, a json file (&lt;code&gt;mystyleplugin.json&lt;/code&gt;) containing meta data describing the plugin is required for most plugins. For style plugins it simply contains a list of styles that can be created by the plugin:</source>
          <target state="translated">此外，大多数插件都需要一个包含描述插件的元数据的json文件（ &lt;code&gt;mystyleplugin.json&lt;/code&gt; ）。对于样式插件，它仅包含可以由该插件创建的样式列表：</target>
        </trans-unit>
        <trans-unit id="e177f7bdf5fc56ccdaf4497efb44f1eca607df17" translate="yes" xml:space="preserve">
          <source>In addition, a page might also execute scripts added through &lt;a href=&quot;qwebengineprofile#scripts&quot;&gt;QWebEngineProfile::scripts&lt;/a&gt;().</source>
          <target state="translated">此外，页面还可以执行通过&lt;a href=&quot;qwebengineprofile#scripts&quot;&gt;QWebEngineProfile :: scripts&lt;/a&gt;（）添加的脚本。</target>
        </trans-unit>
        <trans-unit id="5159fe6cbb8ad71a53796901f6a8fff8c6920b1c" translate="yes" xml:space="preserve">
          <source>In addition, a path can be added to the current path using the &lt;a href=&quot;qpainterpath#connectPath&quot;&gt;connectPath&lt;/a&gt;() function. But note that this function will connect the last element of the current path to the first element of given one by adding a line.</source>
          <target state="translated">另外，可以使用&lt;a href=&quot;qpainterpath#connectPath&quot;&gt;connectPath&lt;/a&gt;（）函数将路径添加到当前路径。但是请注意，此函数将通过添加一条线将当前路径的最后一个元素连接到给定元素的第一个元素。</target>
        </trans-unit>
        <trans-unit id="82b9975d9e7fe693dc5d865f4967bd299624c8ad" translate="yes" xml:space="preserve">
          <source>In addition, any property that can be mapped to a GLSL type can be made available to the shaders. The following list shows how properties are mapped:</source>
          <target state="translated">此外,任何可以映射到GLSL类型的属性都可以被着色器使用。下面的列表显示了属性的映射方式。</target>
        </trans-unit>
        <trans-unit id="55d3a109895fb8d65710b14af04dc9baaf5b9fcd" translate="yes" xml:space="preserve">
          <source>In addition, any property that can be mapped to an OpenGL Shading Language (GLSL) type is available as a uniform variable. The following list shows how properties are mapped to GLSL uniform variables:</source>
          <target state="translated">此外,任何可以映射到OpenGL着色语言(GLSL)类型的属性都可以作为统一变量使用。下面的列表显示了如何将属性映射到GLSL统一变量。</target>
        </trans-unit>
        <trans-unit id="c7e4524fdaa4266008b062613a51b847f8c288da" translate="yes" xml:space="preserve">
          <source>In addition, creating a subclass of &lt;a href=&quot;qabstractvideobuffer&quot;&gt;QAbstractVideoBuffer&lt;/a&gt; will allow you to construct video frames from preallocated or static buffers, in cases where the &lt;a href=&quot;qvideoframe&quot;&gt;QVideoFrame&lt;/a&gt; constructors taking a &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; or a &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; do not suffice. This may be necessary when implementing a new hardware accelerated video system, for example.</source>
          <target state="translated">另外，在&lt;a href=&quot;qvideoframe&quot;&gt;QVideoFrame&lt;/a&gt;构造函数采用&lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt;或&lt;a href=&quot;qimage&quot;&gt;QImage &lt;/a&gt;不足的情况下，创建&lt;a href=&quot;qabstractvideobuffer&quot;&gt;QAbstractVideoBuffer&lt;/a&gt;的子类将使您能够从预分配的缓冲区或静态缓冲区构造视频帧。例如，在实施新的硬件加速视频系统时，这可能是必需的。</target>
        </trans-unit>
        <trans-unit id="d80ac9fa39f368ebbabb6aa4b9d2a72f870f9b4d" translate="yes" xml:space="preserve">
          <source>In addition, creating a subclass of QAbstractVideoBuffer will allow you to construct video frames from preallocated or static buffers, in cases where the &lt;a href=&quot;qvideoframe&quot;&gt;QVideoFrame&lt;/a&gt; constructors taking a &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; or a &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; do not suffice. This may be necessary when implementing a new hardware accelerated video system, for example.</source>
          <target state="translated">另外，在&lt;a href=&quot;qvideoframe&quot;&gt;QVideoFrame&lt;/a&gt;构造函数使用&lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt;或&lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt;不足的情况下，创建QAbstractVideoBuffer的子类将使您能够从预分配的缓冲区或静态缓冲区构造视频帧。例如，在实施新的硬件加速视频系统时，这可能是必需的。</target>
        </trans-unit>
        <trans-unit id="eade8bb89fa5de3837f420f3a88ab6294e206f2f" translate="yes" xml:space="preserve">
          <source>In addition, each handle has the following read-only attached properties:</source>
          <target state="translated">此外,每个句柄有以下只读的附加属性。</target>
        </trans-unit>
        <trans-unit id="0204642a4605eb9b9fb8ab0685a3599f114b81d8" translate="yes" xml:space="preserve">
          <source>In addition, examples use the modules &lt;a href=&quot;qtquickcontrols-index&quot;&gt;Qt Quick Controls&lt;/a&gt; and &lt;a href=&quot;qtgraphicaleffects-index&quot;&gt;Qt Graphical Effects&lt;/a&gt; for additional functionality.</source>
          <target state="translated">此外，示例还使用模块&lt;a href=&quot;qtquickcontrols-index&quot;&gt;Qt Quick Controls&lt;/a&gt;和&lt;a href=&quot;qtgraphicaleffects-index&quot;&gt;Qt图形效果&lt;/a&gt;来获得附加功能。</target>
        </trans-unit>
        <trans-unit id="b36b766570493df9a080cb585b48c3dca94dab7d" translate="yes" xml:space="preserve">
          <source>In addition, in order for anything to be rendered in the View3D, the scene needs a &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtquick3d-intro-example.html#camera&quot;&gt;Camera&lt;/a&gt;. If there is only a single &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtquick3d-intro-example.html#camera&quot;&gt;Camera&lt;/a&gt; in the scene, then this will automatically be picked. Otherwise, the &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtquick3d-intro-example.html#camera&quot;&gt;camera&lt;/a&gt; property can be used to select the camera. The &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtquick3d-intro-example.html#camera&quot;&gt;Camera&lt;/a&gt; decides which parts of the scene are visible, and how they are projected onto the 2D surface.</source>
          <target state="translated">另外，为了在View3D中渲染任何东西，场景需要一个&lt;a href=&quot;https://doc.qt.io/qt-6.0/qtquick3d-intro-example.html#camera&quot;&gt;Camera&lt;/a&gt;。如果场景中只有一个&lt;a href=&quot;https://doc.qt.io/qt-6.0/qtquick3d-intro-example.html#camera&quot;&gt;摄像头&lt;/a&gt;，则将自动选择该摄像头。否则，可以使用&lt;a href=&quot;https://doc.qt.io/qt-6.0/qtquick3d-intro-example.html#camera&quot;&gt;相机&lt;/a&gt;属性来选择相机。该&lt;a href=&quot;https://doc.qt.io/qt-6.0/qtquick3d-intro-example.html#camera&quot;&gt;相机&lt;/a&gt;决定哪些场景的部分是可见的，以及它们是如何投射到2D表面。</target>
        </trans-unit>
        <trans-unit id="0dd109b1b85b88138905dd380068e554d860c7ac" translate="yes" xml:space="preserve">
          <source>In addition, it is only emitted for top-level, standalone animations. It will not be emitted for animations in a Behavior or Transition, or animations that are part of an animation group.</source>
          <target state="translated">此外,它只对顶层的独立动画发出。行为或过渡中的动画,或作为动画组的一部分的动画,不会发出它。</target>
        </trans-unit>
        <trans-unit id="2490e3e5a334237da1567a783f01e8009fc9ce74" translate="yes" xml:space="preserve">
          <source>In addition, only affine transformations are supported by drawStaticText(). Calling drawStaticText() on a projected painter will perform slightly worse than using the regular drawText() call, so this should be avoided.</source>
          <target state="translated">此外,drawStaticText()只支持非线性变换。在投影画家上调用drawStaticText()会比使用常规的drawText()调用的性能稍差,所以应该避免这样做。</target>
        </trans-unit>
        <trans-unit id="f211d92c6ab40a26b8f54de18a81d384509a32e9" translate="yes" xml:space="preserve">
          <source>In addition, since the skeleton is an abstract representation, the model need to specify geometry information for the joints. For performance reasons, this is not done by specifying the information directly. Instead, &lt;a href=&quot;qml-qtquick3d-model#inverseBindPoses-prop&quot;&gt;Model.inverseBindPoses&lt;/a&gt; contains the</source>
          <target state="translated">另外，由于骨架是抽象表示，因此模型需要指定关节的几何信息。出于性能原因，不能通过直接指定信息来完成此操作。相反，&lt;a href=&quot;qml-qtquick3d-model#inverseBindPoses-prop&quot;&gt;Model.inverseBindPoses&lt;/a&gt;包含</target>
        </trans-unit>
        <trans-unit id="b8bc69ff5c35899fdb2f28fb402ec2dbcb3da958" translate="yes" xml:space="preserve">
          <source>In addition, some of the examples rely on &lt;a href=&quot;qtquickcontrols-index&quot;&gt;Qt Quick Controls&lt;/a&gt;.</source>
          <target state="translated">此外，某些示例还依赖&lt;a href=&quot;qtquickcontrols-index&quot;&gt;Qt Quick Controls&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f19eb41eaf7e0ee26c76e1ac8b4d2b2dc1e7135e" translate="yes" xml:space="preserve">
          <source>In addition, style sheets can be used to provide a distinctive look and feel for your application, without having to subclass &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt;. For example, you can specify arbitrary images for radio buttons and check boxes to make them stand out. Using this technique, you can also achieve minor customizations that would normally require subclassing several style classes, such as specifying a &lt;a href=&quot;qstyle#styleHint&quot;&gt;style hint&lt;/a&gt;. The &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtwidgets-widgets-stylesheet-example.html#&quot;&gt;Style Sheet&lt;/a&gt; example depicted below defines two distinctive style sheets that you can try out and modify at will.</source>
          <target state="translated">此外，样式表可用于为您的应用程序提供独特的外观，而不必&lt;a href=&quot;qstyle&quot;&gt;继承QStyle&lt;/a&gt;。例如，您可以为单选按钮和复选框指定任意图像以使其突出。使用此技术，您还可以实现较小的自定义，这些自定义通常需要将多个样式类进行子类化，例如指定&lt;a href=&quot;qstyle#styleHint&quot;&gt;样式提示&lt;/a&gt;。下面描述的&lt;a href=&quot;https://doc.qt.io/qt-5.13/qtwidgets-widgets-stylesheet-example.html#&quot;&gt;样式表示&lt;/a&gt;例定义了两个独特的样式表，您可以随意尝试和修改它们。</target>
        </trans-unit>
        <trans-unit id="96e9c9128799e1368bad842ffa766e71f000e848" translate="yes" xml:space="preserve">
          <source>In addition, style sheets can be used to provide a distinctive look and feel for your application, without having to subclass &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt;. For example, you can specify arbitrary images for radio buttons and check boxes to make them stand out. Using this technique, you can also achieve minor customizations that would normally require subclassing several style classes, such as specifying a &lt;a href=&quot;qstyle#styleHint&quot;&gt;style hint&lt;/a&gt;. The &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtwidgets-widgets-stylesheet-example.html&quot;&gt;Style Sheet&lt;/a&gt; example depicted below defines two distinctive style sheets that you can try out and modify at will.</source>
          <target state="translated">此外，样式表可用于为您的应用程序提供独特的外观，而不必&lt;a href=&quot;qstyle&quot;&gt;继承QStyle&lt;/a&gt;。例如，您可以为单选按钮和复选框指定任意图像以使其突出。使用这种技术，您还可以实现较小的自定义，这些自定义通常需要将多个样式类进行子类化，例如指定&lt;a href=&quot;qstyle#styleHint&quot;&gt;样式提示&lt;/a&gt;。下面描述的&lt;a href=&quot;https://doc.qt.io/qt-5.15/qtwidgets-widgets-stylesheet-example.html&quot;&gt;样式表示&lt;/a&gt;例定义了两个独特的样式表，您可以随意尝试和修改它们。</target>
        </trans-unit>
        <trans-unit id="f9b591986289d0ea4677b5a2e1b88944d95f92c4" translate="yes" xml:space="preserve">
          <source>In addition, style sheets can be used to provide a distinctive look and feel for your application, without having to subclass &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt;. For example, you can specify arbitrary images for radio buttons and check boxes to make them stand out. Using this technique, you can also achieve minor customizations that would normally require subclassing several style classes, such as specifying a &lt;a href=&quot;qstyle#styleHint&quot;&gt;style hint&lt;/a&gt;. The &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtwidgets-widgets-stylesheet-example.html&quot;&gt;Style Sheet&lt;/a&gt; example depicted below defines two distinctive style sheets that you can try out and modify at will.</source>
          <target state="translated">此外，样式表可用于为您的应用程序提供独特的外观，而不必&lt;a href=&quot;qstyle&quot;&gt;继承QStyle&lt;/a&gt;。例如，您可以为单选按钮和复选框指定任意图像以使其突出。使用这种技术，您还可以实现较小的自定义，这些自定义通常需要将多个样式类进行子类化，例如指定&lt;a href=&quot;qstyle#styleHint&quot;&gt;样式提示&lt;/a&gt;。下面描述的&lt;a href=&quot;https://doc.qt.io/qt-6.0/qtwidgets-widgets-stylesheet-example.html&quot;&gt;样式表示&lt;/a&gt;例定义了两个独特的样式表，您可以随意尝试和修改它们。</target>
        </trans-unit>
        <trans-unit id="37770a999540fd15e550dc216ea0b1887914b1b4" translate="yes" xml:space="preserve">
          <source>In addition, the</source>
          <target state="translated">此外,</target>
        </trans-unit>
        <trans-unit id="4294cbe29d0a211f41be2675d1170fd01484c757" translate="yes" xml:space="preserve">
          <source>In addition, the &lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt; class provides the &lt;a href=&quot;qpoint#manhattanLength&quot;&gt;manhattanLength&lt;/a&gt;() function which gives an inexpensive approximation of the length of the &lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt; object interpreted as a vector. Finally, &lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt; objects can be streamed as well as compared.</source>
          <target state="translated">另外，&lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt;类提供了&lt;a href=&quot;qpoint#manhattanLength&quot;&gt;manhattanLength&lt;/a&gt;（）函数，该函数提供了廉价的&lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt;对象长度的近似值，该对象被解释为向量。最后，&lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt;对象可以进行流传输并进行比较。</target>
        </trans-unit>
        <trans-unit id="807bea15a65b9c94213161b391497ccdf492154c" translate="yes" xml:space="preserve">
          <source>In addition, the &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; class provides a constructor converting a &lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt; object into a &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; object, and a corresponding &lt;a href=&quot;qpointf#toPoint&quot;&gt;toPoint&lt;/a&gt;() function which returns a &lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt; copy of</source>
          <target state="translated">此外，&lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt;类提供了一个将&lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt;对象转换为&lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt;对象的构造函数，以及一个对应的&lt;a href=&quot;qpointf#toPoint&quot;&gt;toPoint&lt;/a&gt;（）函数，该函数返回QPointF的&lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt;副本。</target>
        </trans-unit>
        <trans-unit id="3637f28f454cec0a1068776d551d93e59bf42145" translate="yes" xml:space="preserve">
          <source>In addition, the &lt;a href=&quot;qstringlist#operator-2b&quot;&gt;operator+&lt;/a&gt;() function allows you to concatenate two string lists into one. To sort a string list, use the &lt;a href=&quot;qstringlist#sort&quot;&gt;sort&lt;/a&gt;() function.</source>
          <target state="translated">另外，&lt;a href=&quot;qstringlist#operator-2b&quot;&gt;operator +&lt;/a&gt;（）函数允许您将两个字符串列表连接为一个。要对字符串列表进行&lt;a href=&quot;qstringlist#sort&quot;&gt;排序&lt;/a&gt;，请使用sort（）函数。</target>
        </trans-unit>
        <trans-unit id="66461439f94dba43b25e37e7160162baf0cbc4f5" translate="yes" xml:space="preserve">
          <source>In addition, the &lt;a href=&quot;stylesheet-reference#image-prop&quot;&gt;image&lt;/a&gt; property may be used to draw an image over the border-image. The image specified does not tile or stretch and when its size does not match the size of the widget, its alignment is specified using the &lt;a href=&quot;stylesheet-reference#image-position-prop&quot;&gt;image-position&lt;/a&gt; property. Unlike background-image and border-image, one may specify a SVG in the image property, in which case the image is scaled automatically according to the widget size.</source>
          <target state="translated">此外，&lt;a href=&quot;stylesheet-reference#image-prop&quot;&gt;图像&lt;/a&gt;属性可用于在边框图像上绘制图像。指定的图像不平铺或拉伸，并且当其大小与小部件的大小不匹配时，将使用&lt;a href=&quot;stylesheet-reference#image-position-prop&quot;&gt;image-position&lt;/a&gt;属性指定其对齐方式。与背景图片和边框图片不同，可以在图片属性中指定SVG，在这种情况下，图片会根据小部件尺寸自动缩放。</target>
        </trans-unit>
        <trans-unit id="0be9d3ab130c96780568d37ff0c851e6dbb7a73b" translate="yes" xml:space="preserve">
          <source>In addition, the QPoint class provides the &lt;a href=&quot;qpoint#manhattanLength&quot;&gt;manhattanLength&lt;/a&gt;() function which gives an inexpensive approximation of the length of the QPoint object interpreted as a vector. Finally, QPoint objects can be streamed as well as compared.</source>
          <target state="translated">另外，QPoint类提供了&lt;a href=&quot;qpoint#manhattanLength&quot;&gt;manhattanLength&lt;/a&gt;（）函数，该函数提供了廉价的QPoint对象长度的近似值，该对象被解释为向量。最后，QPoint对象可以流式传输并进行比较。</target>
        </trans-unit>
        <trans-unit id="6c47ff418cdd400994917113195d181b6b415ec0" translate="yes" xml:space="preserve">
          <source>In addition, the QPointF class provides a constructor converting a &lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt; object into a QPointF object, and a corresponding &lt;a href=&quot;qpointf#toPoint&quot;&gt;toPoint&lt;/a&gt;() function which returns a &lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt; copy of</source>
          <target state="translated">另外，QPointF类提供了一个将&lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt;对象转换为QPointF对象的构造函数，以及一个对应的&lt;a href=&quot;qpointf#toPoint&quot;&gt;toPoint&lt;/a&gt;（）函数，该函数返回QPointF的&lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt;副本。</target>
        </trans-unit>
        <trans-unit id="dea77fbe280f92dee21373f59390dc366899517d" translate="yes" xml:space="preserve">
          <source>In addition, the class &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt; has been moved to a new module, named Qt OpenGL Widgets.</source>
          <target state="translated">此外，类&lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt;已移至名为Qt OpenGL Widgets的新模块。</target>
        </trans-unit>
        <trans-unit id="f0a46630ab43bb00e5b49a5179d16ab40545a5dd" translate="yes" xml:space="preserve">
          <source>In addition, the class provides a couple of enums: The &lt;a href=&quot;qstyleoptiontoolbar#ToolBarFeature-enum&quot;&gt;ToolBarFeature&lt;/a&gt; enum is used to describe whether a toolbar is movable or not, and the &lt;a href=&quot;qstyleoptiontoolbar#ToolBarPosition-enum&quot;&gt;ToolBarPosition&lt;/a&gt; enum is used to describe the position of a toolbar line, as well as the toolbar's position within the line.</source>
          <target state="translated">此外，该类还提供了一些枚举：&lt;a href=&quot;qstyleoptiontoolbar#ToolBarFeature-enum&quot;&gt;ToolBarFeature&lt;/a&gt;枚举用于描述工具栏是否可移动，而&lt;a href=&quot;qstyleoptiontoolbar#ToolBarPosition-enum&quot;&gt;ToolBarPosition&lt;/a&gt;枚举用于描述工具栏行的位置以及该工具栏在行中的位置。</target>
        </trans-unit>
        <trans-unit id="2ba86444f7fcc6614720b4640a80b993cf8794df" translate="yes" xml:space="preserve">
          <source>In addition, the conversion to &lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;QVariant&lt;/a&gt; is not completely lossless. Please see the documentation in &lt;a href=&quot;qcborvalue#toVariant&quot;&gt;QCborValue::toVariant&lt;/a&gt;() for more information.</source>
          <target state="translated">此外，转换为&lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;QVariant&lt;/a&gt;并不是完全无损的。请参阅&lt;a href=&quot;qcborvalue#toVariant&quot;&gt;QCborValue :: toVariant&lt;/a&gt;（）中的文档以获取更多信息。</target>
        </trans-unit>
        <trans-unit id="75d5ff971616d26e5375ef2a0ec1826ba1c540ca" translate="yes" xml:space="preserve">
          <source>In addition, the conversion to &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; is not completely lossless. Please see the documentation in &lt;a href=&quot;qcborvalue#toVariant&quot;&gt;QCborValue::toVariant&lt;/a&gt;() for more information.</source>
          <target state="translated">此外，转换为&lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt;并非完全无损。请参阅&lt;a href=&quot;qcborvalue#toVariant&quot;&gt;QCborValue :: toVariant&lt;/a&gt;（）中的文档以获取更多信息。</target>
        </trans-unit>
        <trans-unit id="2c0aad9a5f4d6d3691448b59800e8efecbf2634e" translate="yes" xml:space="preserve">
          <source>In addition, the dialog provides the option of selecting an &lt;b&gt;Icon&lt;/b&gt; for the action, as well as removing the current icon.</source>
          <target state="translated">此外，对话框还提供了为操作选择&lt;b&gt;图标&lt;/b&gt;以及删除当前图标的选项。</target>
        </trans-unit>
        <trans-unit id="f1e61f5cc2b8a1a7c9fe1993a17a4377dc5970c7" translate="yes" xml:space="preserve">
          <source>In addition, the extensions &quot;nec-vdc&quot;, &quot;ibm-vdc&quot; and &quot;udc&quot; are supported.</source>
          <target state="translated">此外,还支持 &quot;nec-vdc&quot;、&quot;ibm-vdc &quot;和 &quot;udc &quot;等扩展。</target>
        </trans-unit>
        <trans-unit id="1ea450e4219d5bab329f2b96ad472f7728b09be1" translate="yes" xml:space="preserve">
          <source>In addition, the following must be decided before configuring:</source>
          <target state="translated">此外,在配置前必须决定以下事项。</target>
        </trans-unit>
        <trans-unit id="3154207d78cebec16ad2a44095214e734adfa54b" translate="yes" xml:space="preserve">
          <source>In addition, the following tools are required for building the &lt;a href=&quot;qtwebengine-index&quot;&gt;Qt WebEngine&lt;/a&gt; module:</source>
          <target state="translated">另外，构建&lt;a href=&quot;qtwebengine-index&quot;&gt;Qt WebEngine&lt;/a&gt;模块需要以下工具：</target>
        </trans-unit>
        <trans-unit id="334be7c783ae69325d868c8da8d12cde4136c0a0" translate="yes" xml:space="preserve">
          <source>In addition, the following tools are required for building the &lt;a href=&quot;qtwebengine-index#&quot;&gt;Qt WebEngine&lt;/a&gt; module:</source>
          <target state="translated">另外，需要以下工具来构建&lt;a href=&quot;qtwebengine-index#&quot;&gt;Qt WebEngine&lt;/a&gt;模块：</target>
        </trans-unit>
        <trans-unit id="0453fbf34dc2eba5602d502c98ac28714d17df39" translate="yes" xml:space="preserve">
          <source>In addition, the following types are also supported: &lt;a href=&quot;qchar&quot;&gt;QChar&lt;/a&gt;, &lt;a href=&quot;qlatin1char&quot;&gt;QLatin1Char&lt;/a&gt;.</source>
          <target state="translated">此外，还支持以下类型：&lt;a href=&quot;qchar&quot;&gt;QChar&lt;/a&gt;，&lt;a href=&quot;qlatin1char&quot;&gt;QLatin1Char&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="259a8a4680ce9ea422a3b43fc3383c00eb6a9891" translate="yes" xml:space="preserve">
          <source>In addition, the menu item &lt;code&gt;triggered()&lt;/code&gt; and &lt;code&gt;toggled()&lt;/code&gt; signals will not be emitted. Instead, the action &lt;code&gt;triggered()&lt;/code&gt; and &lt;code&gt;toggled()&lt;/code&gt; signals will be.</source>
          <target state="translated">此外，将不会发出菜单项 &lt;code&gt;triggered()&lt;/code&gt; 和 &lt;code&gt;toggled()&lt;/code&gt; 信号。取而代之的是，将 &lt;code&gt;triggered()&lt;/code&gt; action （）和 &lt;code&gt;toggled()&lt;/code&gt; 信号。</target>
        </trans-unit>
        <trans-unit id="544e92fffbac4dd68d060c68b488a2fb20754198" translate="yes" xml:space="preserve">
          <source>In addition, the mesh topology (primitive type) must be specified too. For indexed drawing, the data for an index buffer must be provided as well.</source>
          <target state="translated">此外,还必须指定网格拓扑(基元类型)。对于索引绘图,还必须提供索引缓冲区的数据。</target>
        </trans-unit>
        <trans-unit id="57898156cd4bdc735abe027f8d52c69114c111dd" translate="yes" xml:space="preserve">
          <source>In addition, the property is marked as</source>
          <target state="translated">此外,该物业还被标记为</target>
        </trans-unit>
        <trans-unit id="eff9231505151a209a8e5699e0cede17c3ebc5a3" translate="yes" xml:space="preserve">
          <source>In addition, there is now only one valid, case-sensitive form for style names: &quot;Material&quot;, &quot;MyStyle&quot;, and so on. That is: the style name must exactly match the name of the QML module. This also applies to file selectors, where previously, all style names were lower case. For example, where the following was a valid structure for a Qt 5 project:</source>
          <target state="translated">此外,现在样式名称只有一种有效的、区分大小写的形式。&quot;Material&quot;,&quot;MyStyle&quot;,等等.也就是说:样式名必须与QML模块的名称完全匹配。这也适用于文件选择器,以前所有的样式名都是小写的。例如,在Qt 5项目中,以下是一个有效的结构。</target>
        </trans-unit>
        <trans-unit id="c256e841e5885018f8d36ae9f87bdc49ef0fa441" translate="yes" xml:space="preserve">
          <source>In addition, true will be returned for shortcuts (&lt;code&gt;*.lnk&lt;/code&gt; files) on Windows. Opening those will open the &lt;code&gt;.lnk&lt;/code&gt; file itself.</source>
          <target state="translated">此外，Windows上的快捷方式（ &lt;code&gt;*.lnk&lt;/code&gt; 文件）将返回true 。打开这些文件将打开 &lt;code&gt;.lnk&lt;/code&gt; 文件本身。</target>
        </trans-unit>
        <trans-unit id="131ab7d55f95ac9c63a0b79d67f59f9c9f514eab" translate="yes" xml:space="preserve">
          <source>In addition, true will be returned for shortcuts (&lt;code&gt;*.lnk&lt;/code&gt; files) on Windows. This behavior is deprecated and will likely change in a future version of Qt. Opening those will open the &lt;code&gt;.lnk&lt;/code&gt; file itself.</source>
          <target state="translated">此外，Windows上的快捷方式（ &lt;code&gt;*.lnk&lt;/code&gt; 文件）将返回true 。此行为已被弃用，并且可能会在Qt的未来版本中更改。打开这些文件将打开 &lt;code&gt;.lnk&lt;/code&gt; 文件本身。</target>
        </trans-unit>
        <trans-unit id="b85bf730226efcb8dbba20f8b402be883786be4b" translate="yes" xml:space="preserve">
          <source>In addition, you can customize or create your own user interface by deriving your own loader class.</source>
          <target state="translated">此外,你可以通过派生你自己的加载器类来定制或创建你自己的用户界面。</target>
        </trans-unit>
        <trans-unit id="f8775a5f4292c4d5a3d2ec861b0eb5ed5abe3c49" translate="yes" xml:space="preserve">
          <source>In addition, you can use features introduced with Windows 7, such as Aero Peek, Jump Lists, a progress indicator on a taskbar button, or a thumbnail toolbar.</source>
          <target state="translated">此外,您还可以使用Windows 7引入的功能,如Aero Peek、Jump Lists、任务栏按钮上的进度指示器或缩略图工具栏。</target>
        </trans-unit>
        <trans-unit id="463c64bcc9966c4d69bde36ea74f4415b5444bc3" translate="yes" xml:space="preserve">
          <source>In additional to a copy of the &lt;a href=&quot;qbluetoothtransferrequest&quot;&gt;QBluetoothTransferRequest&lt;/a&gt; object used to create the request, &lt;a href=&quot;qbluetoothtransferreply&quot;&gt;QBluetoothTransferReply&lt;/a&gt; contains the contents of the reply itself.</source>
          <target state="translated">除了用于创建请求的&lt;a href=&quot;qbluetoothtransferrequest&quot;&gt;QBluetoothTransferRequest&lt;/a&gt;对象的副本之外，&lt;a href=&quot;qbluetoothtransferreply&quot;&gt;QBluetoothTransferReply还&lt;/a&gt;包含答复本身的内容。</target>
        </trans-unit>
        <trans-unit id="7c48fd3cc2f690e861cb313730241881862f1ac2" translate="yes" xml:space="preserve">
          <source>In additional to a copy of the &lt;a href=&quot;qbluetoothtransferrequest&quot;&gt;QBluetoothTransferRequest&lt;/a&gt; object used to create the request, QBluetoothTransferReply contains the contents of the reply itself.</source>
          <target state="translated">除了用于创建请求的&lt;a href=&quot;qbluetoothtransferrequest&quot;&gt;QBluetoothTransferRequest&lt;/a&gt;对象的副本之外，QBluetoothTransferReply还包含答复本身的内容。</target>
        </trans-unit>
        <trans-unit id="7963ae02d9ae56508ad29960b63dd83d294ccbb8" translate="yes" xml:space="preserve">
          <source>In alert state, the window indicates that it demands attention, for example by flashing or bouncing the taskbar entry.</source>
          <target state="translated">在警戒状态下,窗口表示需要注意,例如通过闪烁或弹出任务栏条目。</target>
        </trans-unit>
        <trans-unit id="4514bd62bce43fb3e470760f2f43559ef1f9a8f1" translate="yes" xml:space="preserve">
          <source>In all cases,</source>
          <target state="translated">在所有情况下:</target>
        </trans-unit>
        <trans-unit id="b2ddeff0647b1e25802a4a6fbff662d14d08cb99" translate="yes" xml:space="preserve">
          <source>In all of the &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; functions that take &lt;code&gt;const char *&lt;/code&gt; parameters, the &lt;code&gt;const char *&lt;/code&gt; is interpreted as a classic C-style '\0'-terminated string encoded in UTF-8. It is legal for the &lt;code&gt;const char *&lt;/code&gt; parameter to be &lt;code&gt;nullptr&lt;/code&gt;.</source>
          <target state="translated">在所有采用 &lt;code&gt;const char *&lt;/code&gt; 参数的&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;函数中， &lt;code&gt;const char *&lt;/code&gt; 被解释为以UTF-8编码的经典C风格'\ 0'终止的字符串。 &lt;code&gt;const char *&lt;/code&gt; 参数为 &lt;code&gt;nullptr&lt;/code&gt; 是合法的。</target>
        </trans-unit>
        <trans-unit id="606b894b4e9644bb97a708a2c9e7a6f700495ba6" translate="yes" xml:space="preserve">
          <source>In all of the QString functions that take &lt;code&gt;const char *&lt;/code&gt; parameters, the &lt;code&gt;const char *&lt;/code&gt; is interpreted as a classic C-style '\0'-terminated string encoded in UTF-8. It is legal for the &lt;code&gt;const char *&lt;/code&gt; parameter to be &lt;code&gt;nullptr&lt;/code&gt;.</source>
          <target state="translated">在所有采用 &lt;code&gt;const char *&lt;/code&gt; 参数的QString函数中， &lt;code&gt;const char *&lt;/code&gt; 被解释为以UTF-8编码的经典C风格'\ 0'终止的字符串。 &lt;code&gt;const char *&lt;/code&gt; 参数为 &lt;code&gt;nullptr&lt;/code&gt; 是合法的。</target>
        </trans-unit>
        <trans-unit id="46185100ddc5fa96ee7b078daa3ff964a2e06d05" translate="yes" xml:space="preserve">
          <source>In all other Unix-type systems, this function always returns &quot;unknown&quot;.</source>
          <target state="translated">在所有其他Unix类型的系统中,这个函数总是返回 &quot;未知&quot;。</target>
        </trans-unit>
        <trans-unit id="3d4e3e330fdaf3532958f7d2e3fa664ddbaa42cc" translate="yes" xml:space="preserve">
          <source>In all other aspects, the class is the same. Please refer to &lt;a href=&quot;qrandomgenerator&quot;&gt;QRandomGenerator&lt;/a&gt;'s documentation for more information.</source>
          <target state="translated">在所有其他方面，类别是相同的。请参阅&lt;a href=&quot;qrandomgenerator&quot;&gt;QRandomGenerator&lt;/a&gt;的文档以获取更多信息。</target>
        </trans-unit>
        <trans-unit id="f275549afeb6ce9e54fd32ffe522dc9b4853886d" translate="yes" xml:space="preserve">
          <source>In all other cases</source>
          <target state="translated">在所有其他情况下</target>
        </trans-unit>
        <trans-unit id="47e08556e5e2c760deb39a74b3062bbe01c81e54" translate="yes" xml:space="preserve">
          <source>In all other cases, the new &lt;a href=&quot;qrandomgenerator&quot;&gt;QRandomGenerator&lt;/a&gt; object will start at the same position in the deterministic sequence as the</source>
          <target state="translated">在所有其他情况下，新的&lt;a href=&quot;qrandomgenerator&quot;&gt;QRandomGenerator&lt;/a&gt;对象将在确定性顺序中与</target>
        </trans-unit>
        <trans-unit id="21d0eac833f7227dea6d012f1d3c6b82b36bcb3b" translate="yes" xml:space="preserve">
          <source>In all other cases, the new QRandomGenerator object will start at the same position in the deterministic sequence as the</source>
          <target state="translated">在所有其他情况下,新的QRandomGenerator对象将从确定性序列中的相同位置开始,作为</target>
        </trans-unit>
        <trans-unit id="2d52301091442ee7f197c20e330e83b794ca3e19" translate="yes" xml:space="preserve">
          <source>In all other cases, where the source code to the custom widgets is available, we can adapt the custom widget for use with</source>
          <target state="translated">在所有其他情况下,如果有自定义小组件的源代码,我们可以调整自定义小组件,以便使用</target>
        </trans-unit>
        <trans-unit id="cea8912a36ba47c9a555c445dd112d414d9fe8b1" translate="yes" xml:space="preserve">
          <source>In all other respects, property value sources are regular QML types that can have properties, signals methods and so on, but with the added capability that they can be used to change property values using the &lt;code&gt;&amp;lt;PropertyValueSource&amp;gt; on &amp;lt;property&amp;gt;&lt;/code&gt; syntax.</source>
          <target state="translated">在所有其他方面，属性值源是常规QML类型，可以具有属性，信号方法等，但具有附加功能，可以使用 &lt;code&gt;&amp;lt;PropertyValueSource&amp;gt; on &amp;lt;property&amp;gt;&lt;/code&gt; 语法上的&amp;lt;PropertyValueSource&amp;gt;更改属性值。</target>
        </trans-unit>
        <trans-unit id="68be1244c692e681b85f7a736975755b80b13362" translate="yes" xml:space="preserve">
          <source>In all the other cases it's possible to start the camera directly from unloaded state.</source>
          <target state="translated">在所有其他情况下,可以直接从未加载状态启动摄像机。</target>
        </trans-unit>
        <trans-unit id="ea87c3113788a784159fd7dac0b5a0b9556cc440" translate="yes" xml:space="preserve">
          <source>In all the other cases, it's possible to start the camera directly from the unloaded state.</source>
          <target state="translated">在所有其他情况下,可以直接从未加载状态启动摄像机。</target>
        </trans-unit>
        <trans-unit id="4b9233a51e1e060331ea3b736194c375facb2023" translate="yes" xml:space="preserve">
          <source>In an exclusive group, the user cannot uncheck the currently checked action by triggering it; instead, another action in the group must be triggered to set the new checked action for that group.</source>
          <target state="translated">在专属组中,用户不能通过触发当前选中的动作来取消选中,而必须触发组中的另一个动作,为该组设置新的选中动作。</target>
        </trans-unit>
        <trans-unit id="690db6b2a51f1eaf775df4d65497a1a51cb723e6" translate="yes" xml:space="preserve">
          <source>In an exclusive group, the user cannot uncheck the currently checked button by clicking on it; instead, another button in the group must be clicked to set the new checked button for that group.</source>
          <target state="translated">在专属组中,用户不能通过点击当前选中的按钮来取消选中,而必须点击组中的另一个按钮来设置该组的新选中按钮。</target>
        </trans-unit>
        <trans-unit id="9336b9cc8f537feeae957a4aefb184706e860089" translate="yes" xml:space="preserve">
          <source>In an exclusive menu item group, only one item can be checked at any time; checking another item automatically unchecks the previously checked one.</source>
          <target state="translated">在一个专属的菜单项目组中,任何时候只能选中一个项目,选中另一个项目会自动取消选中之前的项目。</target>
        </trans-unit>
        <trans-unit id="139759fe936af14ab258217452c17e6bf0d141bf" translate="yes" xml:space="preserve">
          <source>In an image over a title bar in the Java style, we show the bounding rectangles of the sub elements supported by the Java style (all of which are drawn with standard pixmaps). It is usual to draw the button backgrounds using &lt;code&gt;PE_PanelButtonTool&lt;/code&gt;, but it's not mandatory.</source>
          <target state="translated">在Java样式的标题栏上方的图像中，我们显示了Java样式支持的子元素的边界矩形（所有子元素均使用标准像素图绘制）。通常使用 &lt;code&gt;PE_PanelButtonTool&lt;/code&gt; 绘制按钮背景，但这不是强制性的。</target>
        </trans-unit>
        <trans-unit id="16e96054603e3b6b045c9475e4054772c913f367" translate="yes" xml:space="preserve">
          <source>In any application which expects to create translucent windows, it's necessary to set this to true before creating the first &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt;. The default value is false.</source>
          <target state="translated">在希望创建半透明窗口的任何应用程序中，必须在创建第一个&lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt;之前将其设置为true 。默认值为false。</target>
        </trans-unit>
        <trans-unit id="692fa6695bdd339718247690e7bfb93f9cd60a4f" translate="yes" xml:space="preserve">
          <source>In applications many common commands can be invoked via menus, toolbar buttons, and keyboard shortcuts. Since the user expects each command to be performed in the same way, regardless of the user interface used, it is useful to represent each command as an</source>
          <target state="translated">在应用程序中,许多常见的命令可以通过菜单、工具栏按钮和键盘快捷键来调用。由于用户希望每条命令都以同样的方式执行,不管使用的是哪种用户界面,因此将每条命令表示为一个</target>
        </trans-unit>
        <trans-unit id="ec16753f9b169809d5315cca662d85c483c4a9f2" translate="yes" xml:space="preserve">
          <source>In applications, windows provide the screen space upon which the user interface is built. Windows separate applications visually from each other and usually provide a window decoration that allows the user to resize and position the applications according to his preferences. Windows are typically integrated into the desktop environment and to some degree managed by the window management system that the desktop environment provides. For instance, selected windows of an application are represented in the task bar.</source>
          <target state="translated">在应用程序中,窗口提供了建立用户界面的屏幕空间。窗口在视觉上将应用程序与其他应用程序分开,通常提供一个窗口装饰,允许用户根据自己的喜好调整应用程序的大小和位置。窗口通常集成在桌面环境中,并在一定程度上由桌面环境提供的窗口管理系统进行管理。例如,应用程序的选定窗口在任务栏中表示。</target>
        </trans-unit>
        <trans-unit id="da98e6fbeabb2716d313454293ae17c5537c72bb" translate="yes" xml:space="preserve">
          <source>In areas beyond this image, pixels are set to 0. For 32-bit RGB images, this means black; for 32-bit ARGB images, this means transparent black; for 8-bit images, this means the color with index 0 in the color table which can be anything; for 1-bit images, this means &lt;a href=&quot;qt#GlobalColor-enum&quot;&gt;Qt::color0&lt;/a&gt;.</source>
          <target state="translated">在此图像之外的区域中，像素设置为0。对于32位ARGB图像，这意味着透明的黑色；对于8位图像，这意味着颜色表中索引为0的颜色可以是任何颜色；对于1位图像，这意味着&lt;a href=&quot;qt#GlobalColor-enum&quot;&gt;Qt :: color0&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c989f99f7fca6bc1c632b6912280beb6031bbad0" translate="yes" xml:space="preserve">
          <source>In automatic focusing modes, the &lt;a href=&quot;qml-qtmultimedia-camerafocus#focusPointMode-prop&quot;&gt;focusPointMode&lt;/a&gt; property and &lt;a href=&quot;qml-qtmultimedia-camerafocus#focusZones-prop&quot;&gt;focusZones&lt;/a&gt; property provide information and control over how automatic focusing is performed.</source>
          <target state="translated">在自动聚焦模式下，&lt;a href=&quot;qml-qtmultimedia-camerafocus#focusPointMode-prop&quot;&gt;focusPointMode&lt;/a&gt;属性和&lt;a href=&quot;qml-qtmultimedia-camerafocus#focusZones-prop&quot;&gt;focusZones&lt;/a&gt;属性提供信息并控制如何执行自动聚焦。</target>
        </trans-unit>
        <trans-unit id="8317ef30e050c1b2a18c87c257ee398e6393d9ce" translate="yes" xml:space="preserve">
          <source>In bar charts, bars are defined as bar sets that contain one data value for each category. The position of a bar is specified by the category and its height by the data value. Bar series that contain multiple bar sets group together bars that belong to the same category. The way the bars are displayed is determined by the subclass of this class chosen to create the bar chart.</source>
          <target state="translated">在柱状图中,柱状图被定义为包含每个类别一个数据值的柱状集。条形图的位置由类别指定,其高度由数据值指定。包含多个条形图集的条形图系列将属于同一类别的条形图组合在一起。条形图的显示方式由选择创建条形图的该类子类决定。</target>
        </trans-unit>
        <trans-unit id="45ee35eebc89a7516006609749715a9cf14e1e70" translate="yes" xml:space="preserve">
          <source>In bar charts, bars are defined as bar sets that contain one data value for each category. The position of a bar is specified by the category and its height by the data value. Bar series that contain multiple bar sets group together bars that belong to the same category. The way the bars are displayed is determined by the type chosen to create the bar chart: &lt;a href=&quot;qml-qtcharts-barseries&quot;&gt;BarSeries&lt;/a&gt;, &lt;a href=&quot;qml-qtcharts-stackedbarseries&quot;&gt;StackedBarSeries&lt;/a&gt;, &lt;a href=&quot;qml-qtcharts-percentbarseries&quot;&gt;PercentBarSeries&lt;/a&gt;, &lt;a href=&quot;qml-qtcharts-horizontalbarseries&quot;&gt;HorizontalBarSeries&lt;/a&gt;, &lt;a href=&quot;qml-qtcharts-horizontalstackedbarseries&quot;&gt;HorizontalStackedBarSeries&lt;/a&gt;, or &lt;a href=&quot;qml-qtcharts-horizontalpercentbarseries&quot;&gt;HorizontalPercentBarSeries&lt;/a&gt;.</source>
          <target state="translated">在条形图中，条形定义为每个类别包含一个数据值的条形集。条形图的位置由类别指定，其高度由数据值指定。包含多个钢筋集的钢筋系列将属于同一类别的钢筋组合在一起。条形的显示方式由创建条形图所选择的类型决定：&lt;a href=&quot;qml-qtcharts-barseries&quot;&gt;BarSeries&lt;/a&gt;，&lt;a href=&quot;qml-qtcharts-stackedbarseries&quot;&gt;StackedBarSeries&lt;/a&gt;，&lt;a href=&quot;qml-qtcharts-percentbarseries&quot;&gt;PercentBarSeries&lt;/a&gt;，&lt;a href=&quot;qml-qtcharts-horizontalbarseries&quot;&gt;Horizo​​ntalBarSeries&lt;/a&gt;，&lt;a href=&quot;qml-qtcharts-horizontalstackedbarseries&quot;&gt;Horizo​​ntalStackedBarSeries&lt;/a&gt;或&lt;a href=&quot;qml-qtcharts-horizontalpercentbarseries&quot;&gt;Horizo​​ntalPercentBarSeries&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1da4b7608499cb4d9199ddde1548bf4d9b453c3d" translate="yes" xml:space="preserve">
          <source>In both cases &lt;a href=&quot;qerrormessage&quot;&gt;QErrorMessage&lt;/a&gt; will queue pending messages and display them in order, with each new message being shown as soon as the user has accepted the previous message. Once the user has specified that a message is not to be shown again it is automatically skipped, and the dialog will show the next appropriate message in the queue.</source>
          <target state="translated">在这两种情况下，&lt;a href=&quot;qerrormessage&quot;&gt;QErrorMessage&lt;/a&gt;都会将待处理的消息排队，并按顺序显示它们，并且每当用户接受前一条消息时，就会显示每个新消息。一旦用户指定不再显示一条消息，它将自动跳过，对话框将在队列中显示下一条适当的消息。</target>
        </trans-unit>
        <trans-unit id="d8a4a925424bbd69b0411894710d9d7a2226dfcf" translate="yes" xml:space="preserve">
          <source>In both cases QErrorMessage will queue pending messages and display them in order, with each new message being shown as soon as the user has accepted the previous message. Once the user has specified that a message is not to be shown again it is automatically skipped, and the dialog will show the next appropriate message in the queue.</source>
          <target state="translated">在这两种情况下,QErrorMessage都会将待处理的消息排成队列并按顺序显示,当用户接受了上一条消息后,每条新消息都会被显示出来。一旦用户指定某条消息不被再次显示,它将被自动跳过,对话框将显示队列中下一条合适的消息。</target>
        </trans-unit>
        <trans-unit id="48727c4f24c1b1bebdfe2449a2dc47ec53057414" translate="yes" xml:space="preserve">
          <source>In both cases the position information is received via the &lt;a href=&quot;qgeopositioninfosource#positionUpdated&quot;&gt;positionUpdated&lt;/a&gt;() signal and the last known position can be accessed with &lt;a href=&quot;qnmeapositioninfosource#lastKnownPosition&quot;&gt;lastKnownPosition&lt;/a&gt;().</source>
          <target state="translated">在这两种情况下，都通过&lt;a href=&quot;qgeopositioninfosource#positionUpdated&quot;&gt;positionUpdated&lt;/a&gt;（）信号接收位置信息，并且可以使用&lt;a href=&quot;qnmeapositioninfosource#lastKnownPosition&quot;&gt;lastKnownPosition&lt;/a&gt;（）访问最近的已知位置。</target>
        </trans-unit>
        <trans-unit id="b3b23cd22d7aec875c727844783902cf6f75a89a" translate="yes" xml:space="preserve">
          <source>In both cases you can only rely on the child being a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; (or, if &lt;a href=&quot;qobject#isWidgetType&quot;&gt;QObject::isWidgetType&lt;/a&gt;() returns &lt;code&gt;true&lt;/code&gt;, a &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt;). This is because in the &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::ChildAdded&lt;/a&gt; case the child is not yet fully constructed; in the &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::ChildRemoved&lt;/a&gt; case it might have already been destructed.</source>
          <target state="translated">在这两种情况下，您只能依靠子对象为&lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;（或者，如果&lt;a href=&quot;qobject#isWidgetType&quot;&gt;QObject :: isWidgetType&lt;/a&gt;（）返回 &lt;code&gt;true&lt;/code&gt; ，则为&lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt;）。这是因为在&lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent :: ChildAdded&lt;/a&gt;情况下，子级尚未完全构建。在&lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent :: ChildRemoved&lt;/a&gt;情况下，它可能已经被破坏。</target>
        </trans-unit>
        <trans-unit id="ac70efc8bd20e8a9b5d71475a37740f026a3ef86" translate="yes" xml:space="preserve">
          <source>In both cases you can only rely on the child being a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; (or, if &lt;a href=&quot;qobject#isWidgetType&quot;&gt;QObject::isWidgetType&lt;/a&gt;() returns &lt;code&gt;true&lt;/code&gt;, a &lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;QWidget&lt;/a&gt;). This is because in the &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::ChildAdded&lt;/a&gt; case the child is not yet fully constructed; in the &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::ChildRemoved&lt;/a&gt; case it might have already been destructed.</source>
          <target state="translated">在这两种情况下，您只能依靠子对象为&lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;（或者，如果&lt;a href=&quot;qobject#isWidgetType&quot;&gt;QObject :: isWidgetType&lt;/a&gt;（）返回 &lt;code&gt;true&lt;/code&gt; ，则为&lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;QWidget&lt;/a&gt;）。这是因为在&lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent :: ChildAdded&lt;/a&gt;情况下，子级尚未完全构建；在&lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent :: ChildRemoved&lt;/a&gt;情况下，它可能已经被破坏。</target>
        </trans-unit>
        <trans-unit id="6b47b90c72db98cef0d0517fc03051399c430e8c" translate="yes" xml:space="preserve">
          <source>In both cases, a ray will be cast through the scene to find geometry intersecting the ray.</source>
          <target state="translated">在这两种情况下,一条射线将被投射到场景中去寻找与射线相交的几何体。</target>
        </trans-unit>
        <trans-unit id="16d0dd1c3efc95f3e6feb7ff726f68584afab600" translate="yes" xml:space="preserve">
          <source>In both cases, the file may either be a local file or in a &lt;a href=&quot;resources&quot;&gt;resource&lt;/a&gt;.</source>
          <target state="translated">在这两种情况下，文件都可以是本地文件，也可以是&lt;a href=&quot;resources&quot;&gt;resource中的&lt;/a&gt;文件。</target>
        </trans-unit>
        <trans-unit id="b4f61469829ccedc96d407de227553d31019c412" translate="yes" xml:space="preserve">
          <source>In both modes the progress dialog may be customized by replacing the child widgets with custom widgets by using &lt;a href=&quot;qprogressdialog#setLabel&quot;&gt;setLabel&lt;/a&gt;(), &lt;a href=&quot;qprogressdialog#setBar&quot;&gt;setBar&lt;/a&gt;(), and &lt;a href=&quot;qprogressdialog#setCancelButton&quot;&gt;setCancelButton&lt;/a&gt;(). The functions &lt;a href=&quot;qprogressdialog#labelText-prop&quot;&gt;setLabelText&lt;/a&gt;() and &lt;a href=&quot;qprogressdialog#setCancelButtonText&quot;&gt;setCancelButtonText&lt;/a&gt;() set the texts shown.</source>
          <target state="translated">在两种模式下，都可以通过使用&lt;a href=&quot;qprogressdialog#setLabel&quot;&gt;setLabel&lt;/a&gt;（），&lt;a href=&quot;qprogressdialog#setBar&quot;&gt;setBar&lt;/a&gt;（）和&lt;a href=&quot;qprogressdialog#setCancelButton&quot;&gt;setCancelButton&lt;/a&gt;（）将子小部件替换为自定义小部件来定制进度对话框。函数&lt;a href=&quot;qprogressdialog#labelText-prop&quot;&gt;setLabelText&lt;/a&gt;（）和&lt;a href=&quot;qprogressdialog#setCancelButtonText&quot;&gt;setCancelButtonText&lt;/a&gt;（）设置显示的文本。</target>
        </trans-unit>
        <trans-unit id="6abdd1e00428bd13a38cc59cc27012745da0841f" translate="yes" xml:space="preserve">
          <source>In both scenarios the size of the item and the Loader are identical. This ensures that anchoring to the Loader is equivalent to anchoring to the loaded item.</source>
          <target state="translated">在这两种情况下,项目和加载器的大小是相同的。这就确保了锚定到加载器上等同于锚定到加载的项目上。</target>
        </trans-unit>
        <trans-unit id="3b6410812bb79165260872e790b3aeeacfb98336" translate="yes" xml:space="preserve">
          <source>In both the &lt;a href=&quot;qobject#Q_PROPERTY&quot;&gt;Q_PROPERTY&lt;/a&gt; and return from &lt;a href=&quot;qobject#Q_INVOKABLE&quot;&gt;Q_INVOKABLE&lt;/a&gt; cases, the elements of a std::vector are copied. This copying may be an expensive operation, so std::vector should be used judiciously.</source>
          <target state="translated">在&lt;a href=&quot;qobject#Q_PROPERTY&quot;&gt;Q_PROPERTY&lt;/a&gt;和从&lt;a href=&quot;qobject#Q_INVOKABLE&quot;&gt;Q_INVOKABLE&lt;/a&gt;返回的情况下，都将复制std :: vector的元素。这种复制可能是一项昂贵的操作，因此应谨慎使用std :: vector。</target>
        </trans-unit>
        <trans-unit id="dda0089d34ad9f159900c7c59a6831aead8730ac" translate="yes" xml:space="preserve">
          <source>In both these cases, we provide</source>
          <target state="translated">在这两种情况下,我们提供</target>
        </trans-unit>
        <trans-unit id="8ba2c56c2973199791cd11f73ae5b03f53ca84eb" translate="yes" xml:space="preserve">
          <source>In case memory allocation fails, &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; will throw a &lt;code&gt;std::bad_alloc&lt;/code&gt; exception. Out of memory conditions in the Qt containers are the only case where Qt will throw exceptions.</source>
          <target state="translated">万一内存分配失败，&lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt;将抛出 &lt;code&gt;std::bad_alloc&lt;/code&gt; 异常。Qt容器中的内存不足情况是Qt引发异常的唯一情况。</target>
        </trans-unit>
        <trans-unit id="ef15aa7461c89d9fc123f519ddcbd5713e865016" translate="yes" xml:space="preserve">
          <source>In case memory allocation fails, &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; will throw a &lt;code&gt;std::bad_alloc&lt;/code&gt; exception. Out of memory conditions in the Qt containers are the only case where Qt will throw exceptions.</source>
          <target state="translated">万一内存分配失败，&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;将抛出 &lt;code&gt;std::bad_alloc&lt;/code&gt; 异常。Qt容器中的内存不足情况是Qt引发异常的唯一情况。</target>
        </trans-unit>
        <trans-unit id="589322a4fd437840ac5d03458d5e677d518922ad" translate="yes" xml:space="preserve">
          <source>In case memory allocation fails, &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt; will use the &lt;a href=&quot;qtglobal#Q_CHECK_PTR&quot;&gt;Q_CHECK_PTR&lt;/a&gt; macro, which will throw a &lt;code&gt;std::bad_alloc&lt;/code&gt; exception if the application is being compiled with exception support. If exceptions are disabled, then running out of memory is undefined behavior.</source>
          <target state="translated">万一内存分配失败，&lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt;将使用&lt;a href=&quot;qtglobal#Q_CHECK_PTR&quot;&gt;Q_CHECK_PTR&lt;/a&gt;宏，如果正在使用异常支持编译应用程序，则它将抛出 &lt;code&gt;std::bad_alloc&lt;/code&gt; 异常。如果禁用了异常，则内存不足是未定义的行为。</target>
        </trans-unit>
        <trans-unit id="cf793d8ff1bc3843822c95bfed9623d641287e5a" translate="yes" xml:space="preserve">
          <source>In case memory allocation fails, QByteArray will throw a &lt;code&gt;std::bad_alloc&lt;/code&gt; exception. Out of memory conditions in the Qt containers are the only case where Qt will throw exceptions.</source>
          <target state="translated">万一内存分配失败，QByteArray将抛出 &lt;code&gt;std::bad_alloc&lt;/code&gt; 异常。Qt容器中的内存不足情况是Qt引发异常的唯一情况。</target>
        </trans-unit>
        <trans-unit id="e114642af1422602eea14007a4e88b10771e860b" translate="yes" xml:space="preserve">
          <source>In case memory allocation fails, QList will use the &lt;a href=&quot;qtglobal#Q_CHECK_PTR&quot;&gt;Q_CHECK_PTR&lt;/a&gt; macro, which will throw a &lt;code&gt;std::bad_alloc&lt;/code&gt; exception if the application is being compiled with exception support. If exceptions are disabled, then running out of memory is undefined behavior.</source>
          <target state="translated">万一内存分配失败，QList将使用&lt;a href=&quot;qtglobal#Q_CHECK_PTR&quot;&gt;Q_CHECK_PTR&lt;/a&gt;宏，如果正在使用异常支持编译应用程序，则它将抛出 &lt;code&gt;std::bad_alloc&lt;/code&gt; 异常。如果禁用了例外，则用尽内存是未定义的行为。</target>
        </trans-unit>
        <trans-unit id="c0c113d67f78f255d83cdf614e2f994647b5d053" translate="yes" xml:space="preserve">
          <source>In case memory allocation fails, QString will throw a &lt;code&gt;std::bad_alloc&lt;/code&gt; exception. Out of memory conditions in the Qt containers are the only case where Qt will throw exceptions.</source>
          <target state="translated">万一内存分配失败，QString将抛出 &lt;code&gt;std::bad_alloc&lt;/code&gt; 异常。Qt容器中的内存不足情况是Qt引发异常的唯一情况。</target>
        </trans-unit>
        <trans-unit id="49912a13afca71d82eee411238c0bb595e0cf9a6" translate="yes" xml:space="preserve">
          <source>In case memory allocation fails, QVector will use the &lt;a href=&quot;qtglobal#Q_CHECK_PTR&quot;&gt;Q_CHECK_PTR&lt;/a&gt; macro, which will throw a &lt;code&gt;std::bad_alloc&lt;/code&gt; exception if the application is being compiled with exception support. If exceptions are disabled, then running out of memory is undefined behavior.</source>
          <target state="translated">万一内存分配失败，QVector将使用&lt;a href=&quot;qtglobal#Q_CHECK_PTR&quot;&gt;Q_CHECK_PTR&lt;/a&gt;宏，如果正在使用异常支持编译应用程序，则它将抛出 &lt;code&gt;std::bad_alloc&lt;/code&gt; 异常。如果禁用了例外，则用尽内存是未定义的行为。</target>
        </trans-unit>
        <trans-unit id="403f40fd85f4c2cdd8b3e799596aba751f98f07b" translate="yes" xml:space="preserve">
          <source>In case of Direct3D 12, all combinations are supported. If the &lt;a href=&quot;qml-qtquick-shadereffect#vertexShader-prop&quot;&gt;vertexShader&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-shadereffect#fragmentShader-prop&quot;&gt;fragmentShader&lt;/a&gt; properties form a valid URL with the &lt;code&gt;file&lt;/code&gt; or &lt;code&gt;qrc&lt;/code&gt; schema, the bytecode or HLSL source code is read from the specified file. The type of the file contents is detected automatically. Otherwise, the string is treated as HLSL source code and is compiled at runtime, assuming Shader Model 5.0 and an entry point of &lt;code&gt;&quot;main&quot;&lt;/code&gt;. This allows dynamically constructing shader strings. However, whenever the shader source code is static, it is strongly recommended to pre-compile to bytecode using the &lt;code&gt;fxc&lt;/code&gt; tool and refer to these files from QML. This will be a lot more efficient at runtime and allows catching syntax errors in the shaders at compile time.</source>
          <target state="translated">对于Direct3D 12，支持所有组合。如果&lt;a href=&quot;qml-qtquick-shadereffect#vertexShader-prop&quot;&gt;vertexShader&lt;/a&gt;和&lt;a href=&quot;qml-qtquick-shadereffect#fragmentShader-prop&quot;&gt;fragmentShader&lt;/a&gt;属性与 &lt;code&gt;file&lt;/code&gt; 或 &lt;code&gt;qrc&lt;/code&gt; 模式形成有效的URL，则将从指定文件中读取字节码或HLSL源代码。自动检测文件内容的类型。否则，将字符串视为HLSL源代码，并在运行时进行编译，并假定使用Shader Model 5.0和入口点 &lt;code&gt;&quot;main&quot;&lt;/code&gt; 。这允许动态构造着色器字符串。但是，无论何时着色器源代码是静态的，都强烈建议使用 &lt;code&gt;fxc&lt;/code&gt; 将其预编译为字节码工具并从QML引用这些文件。这将在运行时提高效率，并允许在编译时捕获着色器中的语法错误。</target>
        </trans-unit>
        <trans-unit id="1c14cde32faa4da56bd1b22b376c08b53ff772c4" translate="yes" xml:space="preserve">
          <source>In case of a 32-bit image, the &lt;a href=&quot;qimage#setPixel&quot;&gt;setPixel&lt;/a&gt;() function can be used to alter the color of the pixel at the given coordinates to any other color specified as an ARGB quadruplet. To make a suitable &lt;a href=&quot;qcolor#QRgb-typedef&quot;&gt;QRgb&lt;/a&gt; value, use the &lt;a href=&quot;qcolor#qRgb&quot;&gt;qRgb&lt;/a&gt;() (adding a default alpha component to the given RGB values, i.e. creating an opaque color) or &lt;a href=&quot;qcolor#qRgba&quot;&gt;qRgba&lt;/a&gt;() function. For example:</source>
          <target state="translated">对于32位图像，可以使用&lt;a href=&quot;qimage#setPixel&quot;&gt;setPixel&lt;/a&gt;（）函数将给定坐标处像素的颜色更改为指定为ARGB四联体的任何其他颜色。要获得合适的&lt;a href=&quot;qcolor#QRgb-typedef&quot;&gt;QRgb&lt;/a&gt;值，请使用&lt;a href=&quot;qcolor#qRgb&quot;&gt;qRgb&lt;/a&gt;（）（向给定的RGB值添加默认的alpha分量，即创建不透明的颜色）或&lt;a href=&quot;qcolor#qRgba&quot;&gt;qRgba&lt;/a&gt;（）函数。例如：</target>
        </trans-unit>
        <trans-unit id="5d7d5bcfadd6c3fe703c910abf652c70be9ff65b" translate="yes" xml:space="preserve">
          <source>In case of a 8-bit and monchrome images, the pixel value is only an index from the image's color table. So the &lt;a href=&quot;qimage#setPixel&quot;&gt;setPixel&lt;/a&gt;() function can only be used to alter the color of the pixel at the given coordinates to a predefined color from the image's color table, i.e. it can only change the pixel's index value. To alter or add a color to an image's color table, use the &lt;a href=&quot;qimage#setColor&quot;&gt;setColor&lt;/a&gt;() function.</source>
          <target state="translated">如果是8位和单色图像，则像素值只是图像颜色表中的索引。因此，&lt;a href=&quot;qimage#setPixel&quot;&gt;setPixel&lt;/a&gt;（）函数只能用于将给定坐标处的像素颜色更改为图像颜色表中的预定义颜色，即只能更改像素的索引值。若要更改颜色或将颜色添加到图像的色表，请使用&lt;a href=&quot;qimage#setColor&quot;&gt;setColor&lt;/a&gt;（）函数。</target>
        </trans-unit>
        <trans-unit id="a851d9fe112db829b09fad6f6917a830554ffe43" translate="yes" xml:space="preserve">
          <source>In case of a synthesized event, for example a mouse event that was generated from a touch event, &lt;code&gt;device()&lt;/code&gt; continues to return the touchscreen device, so that you can tell that it did not come from an actual mouse. Thus &lt;code&gt;mouseEvent.source()-&amp;gt;type() != QInputDevice::DeviceType::Mouse&lt;/code&gt; is one possible replacement for the Qt 5 expression &lt;code&gt;mouseEvent.source() == Qt::MouseEventSynthesizedByQt&lt;/code&gt;.</source>
          <target state="translated">如果是合成事件，例如从触摸事件生成的鼠标事件， &lt;code&gt;device()&lt;/code&gt; 会继续返回触摸屏设备，这样您就可以知道它不是来自实际的鼠标。因此， &lt;code&gt;mouseEvent.source()-&amp;gt;type() != QInputDevice::DeviceType::Mouse&lt;/code&gt; 是Qt 5表达式 &lt;code&gt;mouseEvent.source() == Qt::MouseEventSynthesizedByQt&lt;/code&gt; 一种可能替代。</target>
        </trans-unit>
        <trans-unit id="724cba1dcf313bb869b22da346f5f89258880c94" translate="yes" xml:space="preserve">
          <source>In case of having multiple screens, it is also possible to show the splash screen on a different screen than the primary one. For example:</source>
          <target state="translated">在有多个屏幕的情况下,也可以在与主屏幕不同的屏幕上显示闪屏。例如:</target>
        </trans-unit>
        <trans-unit id="cec00035a1597adbdaa9047833b476dabefb639c" translate="yes" xml:space="preserve">
          <source>In case of monochrome and 8-bit images, the &lt;a href=&quot;qimage#colorCount&quot;&gt;colorCount&lt;/a&gt;() and &lt;a href=&quot;qimage#colorTable&quot;&gt;colorTable&lt;/a&gt;() functions provide information about the color components used to store the image data: The &lt;a href=&quot;qimage#colorTable&quot;&gt;colorTable&lt;/a&gt;() function returns the image's entire color table. To obtain a single entry, use the &lt;a href=&quot;qimage#pixelIndex&quot;&gt;pixelIndex&lt;/a&gt;() function to retrieve the pixel index for a given pair of coordinates, then use the &lt;a href=&quot;qimage#color&quot;&gt;color&lt;/a&gt;() function to retrieve the color. Note that if you create an 8-bit image manually, you have to set a valid color table on the image as well.</source>
          <target state="translated">对于单色和8位图像，&lt;a href=&quot;qimage#colorCount&quot;&gt;colorCount&lt;/a&gt;（）和&lt;a href=&quot;qimage#colorTable&quot;&gt;colorTable&lt;/a&gt;（）函数提供有关用于存储图像数据的颜色分量的信息：&lt;a href=&quot;qimage#colorTable&quot;&gt;colorTable&lt;/a&gt;（）函数返回图像的整个颜色表。要获取单个条目，请使用&lt;a href=&quot;qimage#pixelIndex&quot;&gt;pixelIndex&lt;/a&gt;（）函数检索给定坐标对的像素索引，然后使用&lt;a href=&quot;qimage#color&quot;&gt;color&lt;/a&gt;（）函数检索颜色。请注意，如果手动创建8位图像，则还必须在图像上设置有效的颜色表。</target>
        </trans-unit>
        <trans-unit id="9f557a853f9dcfb42e9e7e75aa25bfa12a9a5690" translate="yes" xml:space="preserve">
          <source>In case of monochrome and 8-bit images, the image is first converted to a 32-bit pixmap and then filled with the colors in the color table. If this is too expensive an operation, you can use &lt;a href=&quot;qbitmap#fromImage&quot;&gt;QBitmap::fromImage&lt;/a&gt;() instead.</source>
          <target state="translated">对于单色和8位图像，首先将图像转换为32位像素图，然后在色表中填充颜色。如果此操作过于昂贵，则可以改用&lt;a href=&quot;qbitmap#fromImage&quot;&gt;QBitmap :: fromImage&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="9fa67a1070b08a851e693bbd2542ad775e33396c" translate="yes" xml:space="preserve">
          <source>In case of parsing error, returns an empty &lt;a href=&quot;qpageranges&quot;&gt;QPageRanges&lt;/a&gt; object.</source>
          <target state="translated">如果发生解析错误，则返回一个空的&lt;a href=&quot;qpageranges&quot;&gt;QPageRanges&lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="d8a0296aba6dcfa0a1a1a5597305f635dc74150d" translate="yes" xml:space="preserve">
          <source>In case of scaled image reading, the quality setting may also influence the tradeoff level between visual quality and execution speed of the scaling algorithm.</source>
          <target state="translated">在缩放图像读取的情况下,质量设置也可能影响缩放算法的视觉质量和执行速度之间的权衡水平。</target>
        </trans-unit>
        <trans-unit id="d9f9e57feb9696fefa51cb0a67b9e44cf7890dd7" translate="yes" xml:space="preserve">
          <source>In case of the</source>
          <target state="translated">如果是</target>
        </trans-unit>
        <trans-unit id="4ae544507d3486de8b97f48520e17ee0e147c2d6" translate="yes" xml:space="preserve">
          <source>In case the</source>
          <target state="translated">如果是</target>
        </trans-unit>
        <trans-unit id="593f205da1c052290a1493d0e66e6609df894718" translate="yes" xml:space="preserve">
          <source>In case the environment variable is not set, or contains an invalid directory, the virtual keyboard falls back to the default built-in layouts.</source>
          <target state="translated">如果环境变量没有被设置,或者包含一个无效的目录,虚拟键盘会回到默认的内置布局。</target>
        </trans-unit>
        <trans-unit id="7fa48d768cf215396ea33c0e816f375dc4a64a2d" translate="yes" xml:space="preserve">
          <source>In case the environment variable is not set, or contains an invalid style name, the virtual keyboard falls back in the default built-in style.</source>
          <target state="translated">如果环境变量没有设置,或者包含一个无效的样式名称,虚拟键盘就会回到默认的内置样式。</target>
        </trans-unit>
        <trans-unit id="062a2e9136354c61add4182e5499e92258fe3943" translate="yes" xml:space="preserve">
          <source>In case the input manifest file should not be processed and only copied to the target directory, the verbatim configuration needs to be set.</source>
          <target state="translated">如果不处理输入的清单文件,只复制到目标目录,则需要设置逐字配置。</target>
        </trans-unit>
        <trans-unit id="b49eabccfb18df9a9fa4a7e77113f4890f8d8cc1" translate="yes" xml:space="preserve">
          <source>In case the old code relied on the specialization of the qLess() functor, then a workaround is explicitly passing an instance of the qLess() class to the STL function, for instance like this:</source>
          <target state="translated">如果旧的代码依赖于qLess()漏斗的特殊化,那么一个变通的办法是显式地将qLess()类的实例传递给STL函数,比如像这样。</target>
        </trans-unit>
        <trans-unit id="854bc338fc82cd645a280613c93774b792dc760e" translate="yes" xml:space="preserve">
          <source>In case the peer's identity cannot be validated during the handshake, the application must inspect errors returned by &lt;a href=&quot;qdtls#peerVerificationErrors&quot;&gt;peerVerificationErrors&lt;/a&gt;() and then either ignore errors by calling &lt;a href=&quot;qdtls#ignoreVerificationErrors&quot;&gt;ignoreVerificationErrors&lt;/a&gt;() or abort the handshake by calling &lt;a href=&quot;qdtls#abortHandshake&quot;&gt;abortHandshake&lt;/a&gt;(). If errors were ignored, the handshake can be resumed by calling &lt;a href=&quot;qdtls#resumeHandshake&quot;&gt;resumeHandshake&lt;/a&gt;().</source>
          <target state="translated">如果对等的身份不能在握手期间进行验证，应用程序必须检查错误返回由&lt;a href=&quot;qdtls#peerVerificationErrors&quot;&gt;peerVerificationErrors&lt;/a&gt;（），然后要么忽略通过调用错误&lt;a href=&quot;qdtls#ignoreVerificationErrors&quot;&gt;ignoreVerificationErrors&lt;/a&gt;（）或中止调用握手&lt;a href=&quot;qdtls#abortHandshake&quot;&gt;abortHandshake&lt;/a&gt;（）。如果忽略了错误，则可以通过调用&lt;a href=&quot;qdtls#resumeHandshake&quot;&gt;resumeHandshake&lt;/a&gt;（）恢复握手。</target>
        </trans-unit>
        <trans-unit id="443a05df41b9b488c4430ad1a042096a6bb504e9" translate="yes" xml:space="preserve">
          <source>In case the variant contains a type not directly supported by &lt;a href=&quot;dbus-changes-qt6#qdbusargument&quot;&gt;QDBusArgument&lt;/a&gt;, the value of the returned &lt;a href=&quot;qdbusvariant&quot;&gt;QDBusVariant&lt;/a&gt; will contain another &lt;a href=&quot;dbus-changes-qt6#qdbusargument&quot;&gt;QDBusArgument&lt;/a&gt;. It is your responsibility to further demarshall it into another type.</source>
          <target state="translated">如果变量包含&lt;a href=&quot;dbus-changes-qt6#qdbusargument&quot;&gt;QDBusArgument&lt;/a&gt;不直接支持的类型，则返回的&lt;a href=&quot;qdbusvariant&quot;&gt;QDBusVariant&lt;/a&gt;的值将包含另一个&lt;a href=&quot;dbus-changes-qt6#qdbusargument&quot;&gt;QDBusArgument&lt;/a&gt;。您有责任进一步将其编组为另一种类型。</target>
        </trans-unit>
        <trans-unit id="545192acf356e40b2ed271a1b563337b471f4054" translate="yes" xml:space="preserve">
          <source>In case the variant contains a type not directly supported by &lt;a href=&quot;qdbusargument&quot;&gt;QDBusArgument&lt;/a&gt;, the value of the returned &lt;a href=&quot;qdbusvariant&quot;&gt;QDBusVariant&lt;/a&gt; will contain another &lt;a href=&quot;qdbusargument&quot;&gt;QDBusArgument&lt;/a&gt;. It is your responsibility to further demarshall it into another type.</source>
          <target state="translated">如果变量包含&lt;a href=&quot;qdbusargument&quot;&gt;QDBusArgument&lt;/a&gt;不直接支持的类型，则返回的&lt;a href=&quot;qdbusvariant&quot;&gt;QDBusVariant&lt;/a&gt;的值将包含另一个&lt;a href=&quot;qdbusargument&quot;&gt;QDBusArgument&lt;/a&gt;。您有责任进一步将其编组为另一种类型。</target>
        </trans-unit>
        <trans-unit id="0f3e28ef45b6dabf51c46c2a84ed7163d3dba6df" translate="yes" xml:space="preserve">
          <source>In case you already ported your application or library to the &lt;a href=&quot;cmake-manual&quot;&gt;cmake&lt;/a&gt; build system, add the following to your &lt;code&gt;CMakeList.txt&lt;/code&gt;:</source>
          <target state="translated">如果您已经将应用程序或库移植到了&lt;a href=&quot;cmake-manual&quot;&gt;cmake&lt;/a&gt;构建系统，请将以下内容添加到 &lt;code&gt;CMakeList.txt&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="9dc0e3475dc4358a0868f9b62af555733e8f226e" translate="yes" xml:space="preserve">
          <source>In case you want to pass a result to another asynchronous task, you can use &lt;a href=&quot;qfuture#then&quot;&gt;QFuture::then&lt;/a&gt;() to create a chain of dependent tasks. See the &lt;a href=&quot;qtcore-changes-qt6#qfuture&quot;&gt;QFuture&lt;/a&gt; documentation for more details.</source>
          <target state="translated">如果要将结果传递给另一个异步任务，则可以使用&lt;a href=&quot;qfuture#then&quot;&gt;QFuture :: then&lt;/a&gt;（）创建一系列依赖任务。有关更多详细信息，请参见&lt;a href=&quot;qtcore-changes-qt6#qfuture&quot;&gt;QFuture&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="e570868f4356eb6490a48ad675c8dc61891c9112" translate="yes" xml:space="preserve">
          <source>In cases where an atomic operation is only supported in newer generations of the processor, &lt;a href=&quot;qatomicinteger&quot;&gt;QAtomicInteger&lt;/a&gt; also provides a way to check at runtime what your hardware supports with the &lt;a href=&quot;qatomicinteger#isReferenceCountingNative&quot;&gt;isReferenceCountingNative&lt;/a&gt;(), &lt;a href=&quot;qatomicinteger#isTestAndSetNative&quot;&gt;isTestAndSetNative&lt;/a&gt;(), &lt;a href=&quot;qatomicinteger#isFetchAndStoreNative&quot;&gt;isFetchAndStoreNative&lt;/a&gt;(), and &lt;a href=&quot;qatomicinteger#isFetchAndAddNative&quot;&gt;isFetchAndAddNative&lt;/a&gt;() functions. Wait-free implementations can be detected using the &lt;a href=&quot;qatomicinteger#isReferenceCountingWaitFree&quot;&gt;isReferenceCountingWaitFree&lt;/a&gt;(), &lt;a href=&quot;qatomicinteger#isTestAndSetWaitFree&quot;&gt;isTestAndSetWaitFree&lt;/a&gt;(), &lt;a href=&quot;qatomicinteger#isFetchAndStoreWaitFree&quot;&gt;isFetchAndStoreWaitFree&lt;/a&gt;(), and &lt;a href=&quot;qatomicinteger#isFetchAndAddWaitFree&quot;&gt;isFetchAndAddWaitFree&lt;/a&gt;() functions.</source>
          <target state="translated">在仅新一代处理器中支持原子操作的情况下，&lt;a href=&quot;qatomicinteger&quot;&gt;QAtomicInteger&lt;/a&gt;还提供了一种在运行时通过&lt;a href=&quot;qatomicinteger#isReferenceCountingNative&quot;&gt;isReferenceCountingNative&lt;/a&gt;（），&lt;a href=&quot;qatomicinteger#isTestAndSetNative&quot;&gt;isTestAndSetNative&lt;/a&gt;（），&lt;a href=&quot;qatomicinteger#isFetchAndStoreNative&quot;&gt;isTestAndSetNative&lt;/a&gt;（），&lt;a href=&quot;qatomicinteger#isFetchAndAddNative&quot;&gt;isFetchAndStoreNative&lt;/a&gt;（）和isFetchAndAddNative（）函数检查硬件支持什么的方法。可以使用&lt;a href=&quot;qatomicinteger#isReferenceCountingWaitFree&quot;&gt;isReferenceCountingWaitFree&lt;/a&gt;（），&lt;a href=&quot;qatomicinteger#isTestAndSetWaitFree&quot;&gt;isTestAndSetWaitFree&lt;/a&gt;（），&lt;a href=&quot;qatomicinteger#isFetchAndStoreWaitFree&quot;&gt;isFetchAndStoreWaitFree&lt;/a&gt;（）和&lt;a href=&quot;qatomicinteger#isFetchAndAddWaitFree&quot;&gt;isFetchAndAddWaitFree&lt;/a&gt;（）函数来检测无等待的实现。</target>
        </trans-unit>
        <trans-unit id="90c0466e27e4ab9491979baf07dcdde1a18d3fd9" translate="yes" xml:space="preserve">
          <source>In cases where an atomic operation is only supported in newer generations of the processor, &lt;a href=&quot;qatomicpointer&quot;&gt;QAtomicPointer&lt;/a&gt; also provides a way to check at runtime what your hardware supports with the &lt;a href=&quot;qatomicpointer#isTestAndSetNative&quot;&gt;isTestAndSetNative&lt;/a&gt;(), &lt;a href=&quot;qatomicpointer#isFetchAndStoreNative&quot;&gt;isFetchAndStoreNative&lt;/a&gt;(), and &lt;a href=&quot;qatomicpointer#isFetchAndAddNative&quot;&gt;isFetchAndAddNative&lt;/a&gt;() functions. Wait-free implementations can be detected using the &lt;a href=&quot;qatomicpointer#isTestAndSetWaitFree&quot;&gt;isTestAndSetWaitFree&lt;/a&gt;(), &lt;a href=&quot;qatomicpointer#isFetchAndStoreWaitFree&quot;&gt;isFetchAndStoreWaitFree&lt;/a&gt;(), and &lt;a href=&quot;qatomicpointer#isFetchAndAddWaitFree&quot;&gt;isFetchAndAddWaitFree&lt;/a&gt;() functions.</source>
          <target state="translated">如果仅在新一代处理器中支持原子操作，则&lt;a href=&quot;qatomicpointer&quot;&gt;QAtomicPointer&lt;/a&gt;还提供了一种在运行时检查&lt;a href=&quot;qatomicpointer#isTestAndSetNative&quot;&gt;isTestAndSetNative&lt;/a&gt;（），&lt;a href=&quot;qatomicpointer#isFetchAndStoreNative&quot;&gt;isFetchAndStoreNative&lt;/a&gt;（）和&lt;a href=&quot;qatomicpointer#isFetchAndAddNative&quot;&gt;isFetchAndAddNative&lt;/a&gt;（）函数对您的硬件支持什么的方法。可以使用&lt;a href=&quot;qatomicpointer#isTestAndSetWaitFree&quot;&gt;isTestAndSetWaitFree&lt;/a&gt;（），&lt;a href=&quot;qatomicpointer#isFetchAndStoreWaitFree&quot;&gt;isFetchAndStoreWaitFree&lt;/a&gt;（）和&lt;a href=&quot;qatomicpointer#isFetchAndAddWaitFree&quot;&gt;isFetchAndAddWaitFree&lt;/a&gt;（）函数来检测无等待的实现。</target>
        </trans-unit>
        <trans-unit id="0091932713f3d777bcf03a0497e62d487a0b1c30" translate="yes" xml:space="preserve">
          <source>In cases where an atomic operation is only supported in newer generations of the processor, QAtomicInteger also provides a way to check at runtime what your hardware supports with the &lt;a href=&quot;qatomicinteger#isReferenceCountingNative&quot;&gt;isReferenceCountingNative&lt;/a&gt;(), &lt;a href=&quot;qatomicinteger#isTestAndSetNative&quot;&gt;isTestAndSetNative&lt;/a&gt;(), &lt;a href=&quot;qatomicinteger#isFetchAndStoreNative&quot;&gt;isFetchAndStoreNative&lt;/a&gt;(), and &lt;a href=&quot;qatomicinteger#isFetchAndAddNative&quot;&gt;isFetchAndAddNative&lt;/a&gt;() functions. Wait-free implementations can be detected using the &lt;a href=&quot;qatomicinteger#isReferenceCountingWaitFree&quot;&gt;isReferenceCountingWaitFree&lt;/a&gt;(), &lt;a href=&quot;qatomicinteger#isTestAndSetWaitFree&quot;&gt;isTestAndSetWaitFree&lt;/a&gt;(), &lt;a href=&quot;qatomicinteger#isFetchAndStoreWaitFree&quot;&gt;isFetchAndStoreWaitFree&lt;/a&gt;(), and &lt;a href=&quot;qatomicinteger#isFetchAndAddWaitFree&quot;&gt;isFetchAndAddWaitFree&lt;/a&gt;() functions.</source>
          <target state="translated">在仅新一代处理器中支持原子操作的情况下，QAtomicInteger还提供了一种在运行时检查&lt;a href=&quot;qatomicinteger#isReferenceCountingNative&quot;&gt;isReferenceCountingNative&lt;/a&gt;（），&lt;a href=&quot;qatomicinteger#isTestAndSetNative&quot;&gt;isTestAndSetNative&lt;/a&gt;（），&lt;a href=&quot;qatomicinteger#isFetchAndStoreNative&quot;&gt;isTestAndSetNative&lt;/a&gt;（），&lt;a href=&quot;qatomicinteger#isFetchAndAddNative&quot;&gt;isFetchAndStoreNative&lt;/a&gt;（）和isFetchAndAddNative（）函数对硬件支持的方法。可以使用&lt;a href=&quot;qatomicinteger#isReferenceCountingWaitFree&quot;&gt;isReferenceCountingWaitFree&lt;/a&gt;（），&lt;a href=&quot;qatomicinteger#isTestAndSetWaitFree&quot;&gt;isTestAndSetWaitFree&lt;/a&gt;（），&lt;a href=&quot;qatomicinteger#isFetchAndStoreWaitFree&quot;&gt;isFetchAndStoreWaitFree&lt;/a&gt;（）和&lt;a href=&quot;qatomicinteger#isFetchAndAddWaitFree&quot;&gt;isFetchAndAddWaitFree&lt;/a&gt;（）函数来检测无等待的实现。</target>
        </trans-unit>
        <trans-unit id="ce4784f4f9070ba2ed5a2dd2a9c189d338393afc" translate="yes" xml:space="preserve">
          <source>In cases where an atomic operation is only supported in newer generations of the processor, QAtomicPointer also provides a way to check at runtime what your hardware supports with the &lt;a href=&quot;qatomicpointer#isTestAndSetNative&quot;&gt;isTestAndSetNative&lt;/a&gt;(), &lt;a href=&quot;qatomicpointer#isFetchAndStoreNative&quot;&gt;isFetchAndStoreNative&lt;/a&gt;(), and &lt;a href=&quot;qatomicpointer#isFetchAndAddNative&quot;&gt;isFetchAndAddNative&lt;/a&gt;() functions. Wait-free implementations can be detected using the &lt;a href=&quot;qatomicpointer#isTestAndSetWaitFree&quot;&gt;isTestAndSetWaitFree&lt;/a&gt;(), &lt;a href=&quot;qatomicpointer#isFetchAndStoreWaitFree&quot;&gt;isFetchAndStoreWaitFree&lt;/a&gt;(), and &lt;a href=&quot;qatomicpointer#isFetchAndAddWaitFree&quot;&gt;isFetchAndAddWaitFree&lt;/a&gt;() functions.</source>
          <target state="translated">在仅新一代处理器中支持原子操作的情况下，QAtomicPointer还提供了一种在运行时检查&lt;a href=&quot;qatomicpointer#isTestAndSetNative&quot;&gt;isTestAndSetNative&lt;/a&gt;（），&lt;a href=&quot;qatomicpointer#isFetchAndStoreNative&quot;&gt;isFetchAndStoreNative&lt;/a&gt;（）和&lt;a href=&quot;qatomicpointer#isFetchAndAddNative&quot;&gt;isFetchAndAddNative&lt;/a&gt;（）函数对您的硬件支持什么的方法。可以使用&lt;a href=&quot;qatomicpointer#isTestAndSetWaitFree&quot;&gt;isTestAndSetWaitFree&lt;/a&gt;（），&lt;a href=&quot;qatomicpointer#isFetchAndStoreWaitFree&quot;&gt;isFetchAndStoreWaitFree&lt;/a&gt;（）和&lt;a href=&quot;qatomicpointer#isFetchAndAddWaitFree&quot;&gt;isFetchAndAddWaitFree&lt;/a&gt;（）函数来检测无等待的实现。</target>
        </trans-unit>
        <trans-unit id="6cc7cb8f56c52c62b79f7c46c534f50e4b95ffec" translate="yes" xml:space="preserve">
          <source>In cases where anchors are used to match the widths or heights of widgets, it is convenient to use the &lt;a href=&quot;qgraphicsanchorlayout#addAnchors&quot;&gt;addAnchors&lt;/a&gt;() function. As with the other functions for specifying anchors, it can also be used to anchor a widget to a layout.</source>
          <target state="translated">如果使用锚点来匹配窗口小部件的宽度或高度，则使用&lt;a href=&quot;qgraphicsanchorlayout#addAnchors&quot;&gt;addAnchors&lt;/a&gt;（）函数很方便。与其他用于指定锚点的功能一样，它也可以用于将小部件锚定到布局。</target>
        </trans-unit>
        <trans-unit id="da791f973c7954950e7dec5bd6cbf317ffe952f8" translate="yes" xml:space="preserve">
          <source>In cases where it is not possible to fit the rect plus margins inside the viewport the contents are scrolled so that as much as possible is visible from</source>
          <target state="translated">如果在视口内无法容纳矩形加边距,则内容将被滚动,以使尽可能多的内容从</target>
        </trans-unit>
        <trans-unit id="43cba2c07e1fd54805178ce5d941c420ce760ec6" translate="yes" xml:space="preserve">
          <source>In cases where the favorites plugin does not support matching by alternative identifiers, then the &lt;a href=&quot;qtlocation-index#plugin-references-and-parameters&quot;&gt;plugin documentation&lt;/a&gt; should be consulted to see precisely what key-value parameters to set.</source>
          <target state="translated">如果收藏夹插件不支持通过备用标识符进行匹配，则应查阅&lt;a href=&quot;qtlocation-index#plugin-references-and-parameters&quot;&gt;插件文档&lt;/a&gt;以准确了解要设置的键值参数。</target>
        </trans-unit>
        <trans-unit id="5e2f28ed2f5a200d6ff44885dfa169512b420d25" translate="yes" xml:space="preserve">
          <source>In cases where this is not enough, Qt provides access to the delivery of the native events. A global event filter that receives all native events can be installed by using &lt;a href=&quot;qcoreapplication#installNativeEventFilter&quot;&gt;QCoreApplication::installNativeEventFilter&lt;/a&gt;(), while per-window native events can be handled in &lt;a href=&quot;qwindow#nativeEvent&quot;&gt;QWindow::nativeEvent&lt;/a&gt;().</source>
          <target state="translated">在这还不够的情况下，Qt提供对本机事件传递的访问。可以使用&lt;a href=&quot;qcoreapplication#installNativeEventFilter&quot;&gt;QCoreApplication :: installNativeEventFilter&lt;/a&gt;（）安装接收所有本机事件的全局事件过滤器，而可以在&lt;a href=&quot;qwindow#nativeEvent&quot;&gt;QWindow :: nativeEvent&lt;/a&gt;（）中处理每个窗口的本机事件。</target>
        </trans-unit>
        <trans-unit id="c6d71b24ddb6aa8ada2ae25e34032ae1809be895" translate="yes" xml:space="preserve">
          <source>In certain cases the parent layout is put into QLayout::FreeResize mode, meaning that it will not adapt the layout of its contents to fit inside small sized windows, or even prevent the user from making the window too small to be usable. This can be overcome by subclassing the problematic widgets, and implementing suitable &lt;a href=&quot;qwidget#sizeHint-prop&quot;&gt;sizeHint()&lt;/a&gt; and &lt;a href=&quot;qwidget#minimumSizeHint-prop&quot;&gt;minimumSizeHint()&lt;/a&gt; functions.</source>
          <target state="translated">在某些情况下，父布局被置于QLayout :: FreeResize模式下，这意味着它不会调整其内容的布局以适合小型窗口，甚至阻止用户使窗口变得太小而无法使用。通过子类化有问题的小部件，并实现适当的&lt;a href=&quot;qwidget#sizeHint-prop&quot;&gt;sizeHint（）&lt;/a&gt;和&lt;a href=&quot;qwidget#minimumSizeHint-prop&quot;&gt;minimumSizeHint（）&lt;/a&gt;函数，可以克服此问题。</target>
        </trans-unit>
        <trans-unit id="53994a9c8298728d70b4eada69cf0a9d3d9765fe" translate="yes" xml:space="preserve">
          <source>In certain scenarios, &lt;a href=&quot;qregexp&quot;&gt;QRegExp&lt;/a&gt; was too lenient and accepted patterns that are simply invalid when using QRegularExpression. These are somehow easy to detect, because the QRegularExpression objects built with these patterns are not valid (cf. &lt;a href=&quot;qregularexpression#isValid&quot;&gt;isValid&lt;/a&gt;()).</source>
          <target state="translated">在某些情况下，&lt;a href=&quot;qregexp&quot;&gt;QRegExp&lt;/a&gt;太宽容，无法接受的模式在使用QRegularExpression时完全无效。由于使用这些模式构建的QRegularExpression对象无效，因此以某种方式易于检测（请参见&lt;a href=&quot;qregularexpression#isValid&quot;&gt;isValid&lt;/a&gt;（））。</target>
        </trans-unit>
        <trans-unit id="5e4ed90a8e7487cd6c9be47ef1c07b2ab9c58711" translate="yes" xml:space="preserve">
          <source>In certain scenarios, QRegExp was too lenient and accepted patterns that are simply invalid when using &lt;a href=&quot;qtcore-changes-qt6#qregularexpression&quot;&gt;QRegularExpression&lt;/a&gt;. These are somehow easy to detect, because the &lt;a href=&quot;qtcore-changes-qt6#qregularexpression&quot;&gt;QRegularExpression&lt;/a&gt; objects built with these patterns are not valid (cf. &lt;a href=&quot;qregularexpression#isValid&quot;&gt;QRegularExpression::isValid&lt;/a&gt;()).</source>
          <target state="translated">在某些情况下，QRegExp太宽容，无法接受的模式在使用&lt;a href=&quot;qtcore-changes-qt6#qregularexpression&quot;&gt;QRegularExpression&lt;/a&gt;时完全无效。这些以某种方式易于检测，因为使用这些模式构建的&lt;a href=&quot;qtcore-changes-qt6#qregularexpression&quot;&gt;QRegularExpression&lt;/a&gt;对象无效（请参阅&lt;a href=&quot;qregularexpression#isValid&quot;&gt;QRegularExpression :: isValid&lt;/a&gt;（））。</target>
        </trans-unit>
        <trans-unit id="a41b4ac3933eda1476b14382ed0a1006fe9f565d" translate="yes" xml:space="preserve">
          <source>In charge of dispatching keyboard events to attached QQKeyboardHandler objects</source>
          <target state="translated">负责调度键盘事件到附加的QQKeyboardHandler对象。</target>
        </trans-unit>
        <trans-unit id="62594d9650efc77f9adb66b52aa57691e8a522f0" translate="yes" xml:space="preserve">
          <source>In class &lt;code&gt;Employee&lt;/code&gt;, note the single data member, a</source>
          <target state="translated">在 &lt;code&gt;Employee&lt;/code&gt; 类中，请注意单个数据成员a</target>
        </trans-unit>
        <trans-unit id="b45d35c7c4a845cb78c51a71a5fffbaf1765a2e0" translate="yes" xml:space="preserve">
          <source>In classic CSS, when font and color of an item is not explicitly set, it gets automatically inherited from the parent. By default, when using Qt Style Sheets, a widget does &lt;b&gt;not&lt;/b&gt; automatically inherit its font and color setting from its parent widget.</source>
          <target state="translated">在经典CSS中，当未明确设置项目的字体和颜色时，它将自动从父项继承。默认情况下，使用Qt样式表时，小部件并&lt;b&gt;不能&lt;/b&gt;自动继承其父控件的字体和颜色设置。</target>
        </trans-unit>
        <trans-unit id="5e29793c801fa55b34ee41a3ad89961ce0d845a4" translate="yes" xml:space="preserve">
          <source>In complex wizards, pages are identified by IDs. These IDs are typically defined using an enum. For example:</source>
          <target state="translated">在复杂的向导中,页面由ID标识。这些ID通常使用一个枚举来定义。例如:</target>
        </trans-unit>
        <trans-unit id="231ad4b10b376ab7dd4b4161d3aff190a50bf442" translate="yes" xml:space="preserve">
          <source>In contrast to</source>
          <target state="translated">与此相反的是</target>
        </trans-unit>
        <trans-unit id="2aac7d402261de7266f7684761e23369ae2b9abf" translate="yes" xml:space="preserve">
          <source>In contrast to &lt;a href=&quot;#translations&quot;&gt;TRANSLATIONS&lt;/a&gt;, translation files in &lt;code&gt;EXTRA_TRANSLATIONS&lt;/code&gt; will be processed only by &lt;a href=&quot;https://doc.qt.io/qt-5.13/linguist-manager.html#using-lrelease&quot;&gt;lrelease&lt;/a&gt;, not &lt;a href=&quot;https://doc.qt.io/qt-5.13/linguist-manager.html#using-lupdate&quot;&gt;lupdate&lt;/a&gt;.</source>
          <target state="translated">与此相反&lt;a href=&quot;#translations&quot;&gt;译本&lt;/a&gt;，在翻译文件 &lt;code&gt;EXTRA_TRANSLATIONS&lt;/code&gt; 将被处理只能由&lt;a href=&quot;https://doc.qt.io/qt-5.13/linguist-manager.html#using-lrelease&quot;&gt;lrelease，即可&lt;/a&gt;，不&lt;a href=&quot;https://doc.qt.io/qt-5.13/linguist-manager.html#using-lupdate&quot;&gt;lupdate&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e2a196eafe5fec635b2bbdc654a994018eadbf5d" translate="yes" xml:space="preserve">
          <source>In contrast to &lt;a href=&quot;qfileinfo#canonicalPath&quot;&gt;canonicalPath&lt;/a&gt;() symbolic links or redundant &quot;.&quot; or &quot;..&quot; elements are not necessarily removed.</source>
          <target state="translated">与&lt;a href=&quot;qfileinfo#canonicalPath&quot;&gt;canonicalPath&lt;/a&gt;（）相比，符号链接或冗余&amp;ldquo;。&amp;rdquo; 或&amp;ldquo; ..&amp;rdquo;元素不一定要删除。</target>
        </trans-unit>
        <trans-unit id="d4d4f542dc4b15b17617ba7302c0f4de2245d7b1" translate="yes" xml:space="preserve">
          <source>In contrast to &lt;a href=&quot;qfileinfo#isSymLink&quot;&gt;isSymLink&lt;/a&gt;(), false will be returned for shortcuts (&lt;code&gt;*.lnk&lt;/code&gt; files) on Windows. Use &lt;a href=&quot;qfileinfo#isShortcut&quot;&gt;QFileInfo::isShortcut&lt;/a&gt;() instead.</source>
          <target state="translated">与&lt;a href=&quot;qfileinfo#isSymLink&quot;&gt;isSymLink&lt;/a&gt;（）相比，Windows上的快捷方式（ &lt;code&gt;*.lnk&lt;/code&gt; 文件）将返回false 。使用&lt;a href=&quot;qfileinfo#isShortcut&quot;&gt;QFileInfo :: isShortcut&lt;/a&gt;（）代替。</target>
        </trans-unit>
        <trans-unit id="7b00dedbb27975a52293f7f2888b30c2a7fdf0e1" translate="yes" xml:space="preserve">
          <source>In contrast to &lt;a href=&quot;qmake-variable-reference#translations&quot;&gt;TRANSLATIONS&lt;/a&gt;, translation files in &lt;code&gt;EXTRA_TRANSLATIONS&lt;/code&gt; will be processed only by &lt;a href=&quot;https://doc.qt.io/qt-5.15/linguist-manager.html#using-lrelease&quot;&gt;lrelease&lt;/a&gt;, not &lt;a href=&quot;https://doc.qt.io/qt-5.15/linguist-manager.html#using-lupdate&quot;&gt;lupdate&lt;/a&gt;.</source>
          <target state="translated">与此相反&lt;a href=&quot;qmake-variable-reference#translations&quot;&gt;译本&lt;/a&gt;，在翻译文件 &lt;code&gt;EXTRA_TRANSLATIONS&lt;/code&gt; 将被处理只能由&lt;a href=&quot;https://doc.qt.io/qt-5.15/linguist-manager.html#using-lrelease&quot;&gt;lrelease，即可&lt;/a&gt;，不&lt;a href=&quot;https://doc.qt.io/qt-5.15/linguist-manager.html#using-lupdate&quot;&gt;lupdate&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="618de9361835eece5e572eaed710bb3d6060cd4e" translate="yes" xml:space="preserve">
          <source>In contrast to &lt;a href=&quot;qmake-variable-reference#translations&quot;&gt;TRANSLATIONS&lt;/a&gt;, translation files in &lt;code&gt;EXTRA_TRANSLATIONS&lt;/code&gt; will be processed only by &lt;a href=&quot;https://doc.qt.io/qt-6.0/linguist-manager.html#using-lrelease&quot;&gt;lrelease&lt;/a&gt;, not &lt;a href=&quot;https://doc.qt.io/qt-6.0/linguist-manager.html#using-lupdate&quot;&gt;lupdate&lt;/a&gt;.</source>
          <target state="translated">与此相反&lt;a href=&quot;qmake-variable-reference#translations&quot;&gt;译本&lt;/a&gt;，在翻译文件 &lt;code&gt;EXTRA_TRANSLATIONS&lt;/code&gt; 将被处理只能由&lt;a href=&quot;https://doc.qt.io/qt-6.0/linguist-manager.html#using-lrelease&quot;&gt;lrelease，即可&lt;/a&gt;，不&lt;a href=&quot;https://doc.qt.io/qt-6.0/linguist-manager.html#using-lupdate&quot;&gt;lupdate&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="40a9fa83d5c4840547d5095aa74f02059ad912f6" translate="yes" xml:space="preserve">
          <source>In contrast to &lt;a href=&quot;qtimeline#start&quot;&gt;start&lt;/a&gt;(), this function does not restart the timeline before it resumes.</source>
          <target state="translated">与&lt;a href=&quot;qtimeline#start&quot;&gt;start&lt;/a&gt;（）相比，此函数不会在恢复之前重新启动时间轴。</target>
        </trans-unit>
        <trans-unit id="fb7097e105e1037d49889af33e5f80c02e2bd8d7" translate="yes" xml:space="preserve">
          <source>In contrast to event specifications in SCXML documents, spaces are not allowed in the</source>
          <target state="translated">与SCXML文档中的事件规格不同,在SCXML文档中不允许有空格。</target>
        </trans-unit>
        <trans-unit id="4a772d6172888ba23751f095769c3d0f199153a2" translate="yes" xml:space="preserve">
          <source>In contrast to most other layouts, child Items' &lt;a href=&quot;qml-qtquick-layouts-layout#fillWidth-attached-prop&quot;&gt;Layout.fillWidth&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-layouts-layout#fillHeight-attached-prop&quot;&gt;Layout.fillHeight&lt;/a&gt; properties default to &lt;code&gt;true&lt;/code&gt;. As a consequence, child items are by default filled to match the size of the &lt;a href=&quot;qml-qtquick-layouts-stacklayout&quot;&gt;StackLayout&lt;/a&gt; as long as their &lt;a href=&quot;qml-qtquick-layouts-layout#maximumWidth-attached-prop&quot;&gt;Layout.maximumWidth&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-layouts-layout#maximumHeight-attached-prop&quot;&gt;Layout.maximumHeight&lt;/a&gt; does not prevent it.</source>
          <target state="translated">与大多数其他布局相比，子Items的&lt;a href=&quot;qml-qtquick-layouts-layout#fillWidth-attached-prop&quot;&gt;Layout.fillWidth&lt;/a&gt;和&lt;a href=&quot;qml-qtquick-layouts-layout#fillHeight-attached-prop&quot;&gt;Layout.fillHeight&lt;/a&gt;属性默认为 &lt;code&gt;true&lt;/code&gt; 。因此，默认情况下，只要子项的&lt;a href=&quot;qml-qtquick-layouts-layout#maximumWidth-attached-prop&quot;&gt;Layout.maximumWidth&lt;/a&gt;或&lt;a href=&quot;qml-qtquick-layouts-layout#maximumHeight-attached-prop&quot;&gt;Layout.maximumHeight&lt;/a&gt;阻止子项填充，以匹配&lt;a href=&quot;qml-qtquick-layouts-stacklayout&quot;&gt;StackLayout&lt;/a&gt;的大小。</target>
        </trans-unit>
        <trans-unit id="0ec20c859cd3420b2a4413d164250f026415f0bc" translate="yes" xml:space="preserve">
          <source>In contrast to most other layouts, child Items' &lt;a href=&quot;qml-qtquick-layouts-layout#fillWidth-attached-prop&quot;&gt;Layout.fillWidth&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-layouts-layout#fillHeight-attached-prop&quot;&gt;Layout.fillHeight&lt;/a&gt; properties default to &lt;code&gt;true&lt;/code&gt;. As a consequence, child items are by default filled to match the size of the StackLayout as long as their &lt;a href=&quot;qml-qtquick-layouts-layout#maximumWidth-attached-prop&quot;&gt;Layout.maximumWidth&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-layouts-layout#maximumHeight-attached-prop&quot;&gt;Layout.maximumHeight&lt;/a&gt; does not prevent it.</source>
          <target state="translated">与大多数其他布局相比，子Items的&lt;a href=&quot;qml-qtquick-layouts-layout#fillWidth-attached-prop&quot;&gt;Layout.fillWidth&lt;/a&gt;和&lt;a href=&quot;qml-qtquick-layouts-layout#fillHeight-attached-prop&quot;&gt;Layout.fillHeight&lt;/a&gt;属性默认为 &lt;code&gt;true&lt;/code&gt; 。因此，默认情况下，只要子项的&lt;a href=&quot;qml-qtquick-layouts-layout#maximumWidth-attached-prop&quot;&gt;Layout.maximumWidth&lt;/a&gt;或&lt;a href=&quot;qml-qtquick-layouts-layout#maximumHeight-attached-prop&quot;&gt;Layout.maximumHeight&lt;/a&gt;阻止子项填充，以匹配StackLayout的大小。</target>
        </trans-unit>
        <trans-unit id="221c871c00778299b08348aca174c31cdde4ac9e" translate="yes" xml:space="preserve">
          <source>In contrast, datagram mode is message-oriented and provides a complete simultaneous transmission of multiple data streams between endpoints. Call &lt;a href=&quot;qsctpserver#nextPendingDatagramConnection&quot;&gt;nextPendingDatagramConnection&lt;/a&gt;() to accept the pending datagram-mode connection as a connected &lt;a href=&quot;qsctpsocket&quot;&gt;QSctpSocket&lt;/a&gt;.</source>
          <target state="translated">相反，数据报模式是面向消息的，并且在端点之间提供了多个数据流的完全同时传输。调用&lt;a href=&quot;qsctpserver#nextPendingDatagramConnection&quot;&gt;nextPendingDatagramConnection&lt;/a&gt;（）以接受挂起的数据报模式连接作为已连接的&lt;a href=&quot;qsctpsocket&quot;&gt;QSctpSocket&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6e787bef3e57569e1b4e97caaf24bc5f7bf4106d" translate="yes" xml:space="preserve">
          <source>In contrast, functor-based connections are checked by the compiler. The compiler catches errors at compile-time, enables implicit conversions between compatible types, and recognizes different names of the same type.</source>
          <target state="translated">相反,基于漏斗的连接由编译器检查。编译器在编译时捕捉错误,允许在兼容类型之间进行隐式转换,并识别同一类型的不同名称。</target>
        </trans-unit>
        <trans-unit id="f38ef06a2c4def729d64a10c8350bfda693b07db" translate="yes" xml:space="preserve">
          <source>In contrast, properties of an &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtqml-typesystem-topic.html#qml-object-types&quot;&gt;object type&lt;/a&gt; emit their own property change signals, and a property change signal handler for an object-type property is only invoked when the property is reassigned to a different object value.</source>
          <target state="translated">相反，&lt;a href=&quot;https://doc.qt.io/qt-5.13/qtqml-typesystem-topic.html#qml-object-types&quot;&gt;对象类型&lt;/a&gt;的属性会发出自己的属性更改信号，并且仅当将属性重新分配给其他对象值时，才调用对象类型属性的属性更改信号处理程序。</target>
        </trans-unit>
        <trans-unit id="657c9918ecd776a1aafb08d2b614c01eae78c6f6" translate="yes" xml:space="preserve">
          <source>In contrast, properties of an &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtqml-typesystem-topic.html#qml-object-types&quot;&gt;object type&lt;/a&gt; emit their own property change signals, and a property change signal handler for an object-type property is only invoked when the property is reassigned to a different object value.</source>
          <target state="translated">相反，&lt;a href=&quot;https://doc.qt.io/qt-5.15/qtqml-typesystem-topic.html#qml-object-types&quot;&gt;对象类型&lt;/a&gt;的属性会发出自己的属性更改信号，并且仅在将属性重新分配给其他对象值时才调用对象类型属性的属性更改信号处理程序。</target>
        </trans-unit>
        <trans-unit id="73d37f657dea8be040584e138b1df81404e68eae" translate="yes" xml:space="preserve">
          <source>In contrast, properties of an &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtqml-typesystem-topic.html#qml-object-types&quot;&gt;object type&lt;/a&gt; emit their own property change signals, and a property change signal handler for an object-type property is only invoked when the property is reassigned to a different object value.</source>
          <target state="translated">相反，&lt;a href=&quot;https://doc.qt.io/qt-6.0/qtqml-typesystem-topic.html#qml-object-types&quot;&gt;对象类型&lt;/a&gt;的属性会发出自己的属性更改信号，并且仅在将属性重新分配给其他对象值时才调用对象类型属性的属性更改信号处理程序。</target>
        </trans-unit>
        <trans-unit id="14d70c8987f7df0bae4a098c83c6017992fe13ed" translate="yes" xml:space="preserve">
          <source>In contrast, setting a font and palette using &lt;a href=&quot;qwidget#font-prop&quot;&gt;QWidget::setFont&lt;/a&gt;() and &lt;a href=&quot;qwidget#palette-prop&quot;&gt;QWidget::setPalette&lt;/a&gt;() propagates to child widgets.</source>
          <target state="translated">相反，使用&lt;a href=&quot;qwidget#font-prop&quot;&gt;QWidget :: setFont&lt;/a&gt;（）和&lt;a href=&quot;qwidget#palette-prop&quot;&gt;QWidget :: setPalette&lt;/a&gt;（）设置字体和调色板会传播到子窗口小部件。</target>
        </trans-unit>
        <trans-unit id="7f1fc3d94746b812dc1a973c5e2550874e4f1cf6" translate="yes" xml:space="preserve">
          <source>In contrast, with the functor-based syntax, an overloaded signal or slot must be casted to tell the compiler which instance to use.</source>
          <target state="translated">与此相反,在基于漏斗的语法中,必须投掷一个重载信号或槽来告诉编译器使用哪个实例。</target>
        </trans-unit>
        <trans-unit id="47704f927094ac2336750dc0c531d2e3723bd0c2" translate="yes" xml:space="preserve">
          <source>In datagram mode, &lt;a href=&quot;qsctpsocket&quot;&gt;QSctpSocket&lt;/a&gt; performs the buffering of datagrams independently for each channel. You can queue a datagram to the buffer of the current channel by calling &lt;a href=&quot;qsctpsocket#writeDatagram&quot;&gt;writeDatagram&lt;/a&gt;() and read a pending datagram by calling &lt;a href=&quot;qsctpsocket#readDatagram&quot;&gt;readDatagram&lt;/a&gt;() respectively.</source>
          <target state="translated">在数据报模式下，&lt;a href=&quot;qsctpsocket&quot;&gt;QSctpSocket&lt;/a&gt;为每个通道独立执行数据报的缓冲。您可以通过调用&lt;a href=&quot;qsctpsocket#writeDatagram&quot;&gt;writeDatagram&lt;/a&gt;（）将数据报排队到当前通道的缓冲区中，并通过分别调用&lt;a href=&quot;qsctpsocket#readDatagram&quot;&gt;readDatagram&lt;/a&gt;（）来读取挂起的数据报。</target>
        </trans-unit>
        <trans-unit id="e90047f588e8a9c66ec5b2323534c12ac24c09f0" translate="yes" xml:space="preserve">
          <source>In datagram mode, QSctpSocket performs the buffering of datagrams independently for each channel. You can queue a datagram to the buffer of the current channel by calling &lt;a href=&quot;qsctpsocket#writeDatagram&quot;&gt;writeDatagram&lt;/a&gt;() and read a pending datagram by calling &lt;a href=&quot;qsctpsocket#readDatagram&quot;&gt;readDatagram&lt;/a&gt;() respectively.</source>
          <target state="translated">在数据报模式下，QSctpSocket为每个通道独立执行数据报的缓冲。您可以通过调用&lt;a href=&quot;qsctpsocket#writeDatagram&quot;&gt;writeDatagram&lt;/a&gt;（）将数据报排队到当前通道的缓冲区中，并通过分别调用&lt;a href=&quot;qsctpsocket#readDatagram&quot;&gt;readDatagram&lt;/a&gt;（）来读取挂起的数据报。</target>
        </trans-unit>
        <trans-unit id="07e42511b7abf9bb54e833603926aeb7b222def2" translate="yes" xml:space="preserve">
          <source>In debug builds the condition is enforced by an assert to facilitate debugging.</source>
          <target state="translated">在调试构建中,为了方便调试,条件是通过断言来执行的。</target>
        </trans-unit>
        <trans-unit id="b71abd6efd254a650af3c09142186b5133ce0d87" translate="yes" xml:space="preserve">
          <source>In edit mode, press</source>
          <target state="translated">在编辑模式下,按</target>
        </trans-unit>
        <trans-unit id="25b9da12cb823d2c1d6a5223dbf28325a3d8baa6" translate="yes" xml:space="preserve">
          <source>In edit mode, select the desired faces. (</source>
          <target state="translated">在编辑模式下,选择所需的面。(</target>
        </trans-unit>
        <trans-unit id="27ca71f516af27079bf83c99568901eec725fb82" translate="yes" xml:space="preserve">
          <source>In editable models, this opens the current item for editing. The Escape key can be used to cancel the editing process and revert any changes to the data displayed.</source>
          <target state="translated">在可编辑模型中,这将打开当前项目进行编辑。Escape 键可用于取消编辑过程并恢复对显示数据的任何更改。</target>
        </trans-unit>
        <trans-unit id="25d14e1ec2b5b306276db7124338a02023a6c82e" translate="yes" xml:space="preserve">
          <source>In effect, when a command is pushed, it becomes the top-most command on the stack.</source>
          <target state="translated">实际上,当一条命令被推送后,它就会成为堆栈上最顶端的命令。</target>
        </trans-unit>
        <trans-unit id="767704cb9fd04546381b49fcfd02b90d83e7c7cb" translate="yes" xml:space="preserve">
          <source>In either case, the value may be either a</source>
          <target state="translated">在这两种情况下,该值可以是一个</target>
        </trans-unit>
        <trans-unit id="e5771972b8071936a553417ed46282eae06dbd5e" translate="yes" xml:space="preserve">
          <source>In fact, any JavaScript expression (no matter how complex) may be used in a property binding definition, as long as the result of the expression is a value whose type can be assigned to the property. This includes side effects. However, complex bindings and side effects are discouraged because they can reduce the performance, readability, and maintainability of the code.</source>
          <target state="translated">事实上,任何JavaScript表达式(无论多么复杂)都可以在属性绑定定义中使用,只要表达式的结果是一个类型可以分配给属性的值。这包括副作用。但是,我们不鼓励使用复杂的绑定和副作用,因为它们会降低代码的性能、可读性和可维护性。</target>
        </trans-unit>
        <trans-unit id="20030dd4b75e22ef5740f4e7e8489490113c4e84" translate="yes" xml:space="preserve">
          <source>In full, the RenderViews created are:</source>
          <target state="translated">完整来说,创建的RenderViews是。</target>
        </trans-unit>
        <trans-unit id="bb19f0f7570b0febe9bc2b6bebf1e844928a04ec" translate="yes" xml:space="preserve">
          <source>In fullscreen mode, the virtual keyboard replicates the contents of the focused input field to the fullscreen input field located at the top of the keyboard.</source>
          <target state="translated">在全屏模式下,虚拟键盘将焦点输入栏的内容复制到位于键盘顶部的全屏输入栏。</target>
        </trans-unit>
        <trans-unit id="2d5906462ad37b4fc10efbd813a86f2cafbda7f2" translate="yes" xml:space="preserve">
          <source>In general a document structuring command considers everything that follows it until the first line break as its argument. The argument is rendered as the unit's title. If the title needs to be spanned over several lines, make sure that each line (except the last one) is ended with a backslash.</source>
          <target state="translated">一般来说,一个文档结构化命令将后面的所有内容,直到第一个换行符作为它的参数。这个参数被渲染为单元的标题。如果标题需要跨越几行,请确保每一行(除了最后一行)都以反斜杠结束。</target>
        </trans-unit>
        <trans-unit id="167a7ef27ae33540c81ee2290a8d3d775d231aad" translate="yes" xml:space="preserve">
          <source>In general an enabled widget handles keyboard and mouse events; a disabled widget does not. An exception is made with &lt;a href=&quot;qabstractbutton&quot;&gt;QAbstractButton&lt;/a&gt;.</source>
          <target state="translated">通常，已启用的窗口小部件处理键盘和鼠标事件。禁用的小部件则不会。&lt;a href=&quot;qabstractbutton&quot;&gt;QAbstractButton&lt;/a&gt;例外。</target>
        </trans-unit>
        <trans-unit id="d021729bebd5b79255de19024fac6ea9df2157a6" translate="yes" xml:space="preserve">
          <source>In general an enabled widget handles keyboard and mouse events; a disabled widget does not. An exception is made with &lt;a href=&quot;widgets-changes-qt6#qabstractbutton&quot;&gt;QAbstractButton&lt;/a&gt;.</source>
          <target state="translated">通常，已启用的窗口小部件处理键盘和鼠标事件。禁用的小部件则不会。&lt;a href=&quot;widgets-changes-qt6#qabstractbutton&quot;&gt;QAbstractButton&lt;/a&gt;例外。</target>
        </trans-unit>
        <trans-unit id="8cc625bb55279831e729a96b7ba93ed54e0b4b61" translate="yes" xml:space="preserve">
          <source>In general returns the modal dialog's result code, &lt;code&gt;Accepted&lt;/code&gt; or &lt;code&gt;Rejected&lt;/code&gt;.</source>
          <target state="translated">通常返回模态对话框的结果代码 &lt;code&gt;Accepted&lt;/code&gt; 或 &lt;code&gt;Rejected&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e9fd7bb71f823cf713a3ecec34253b92dc6cbfcf" translate="yes" xml:space="preserve">
          <source>In general there are two steps to completing an in-app purchase using the API:</source>
          <target state="translated">一般来说,使用API完成应用内购买有两个步骤。</target>
        </trans-unit>
        <trans-unit id="30673a5ebb6575bf00ffabd14fa8a0d19b73bc55" translate="yes" xml:space="preserve">
          <source>In general we can implement a default event handler by double clicking on the widget in the form, but the default events for our widgets are right now not defined.</source>
          <target state="translated">一般情况下,我们可以通过双击窗体中的小部件来实现一个默认的事件处理程序,但是我们的小部件的默认事件现在还没有定义。</target>
        </trans-unit>
        <trans-unit id="fc58706396cf19f31560982fb0e3ab7ba9781ad7" translate="yes" xml:space="preserve">
          <source>In general you should use one of the predefined action names, unless describing an action that does not fit these:</source>
          <target state="translated">一般来说,您应该使用预定义的动作名称之一,除非描述的动作不符合这些名称。</target>
        </trans-unit>
        <trans-unit id="7d8cf290113d81f0cede60c757cf3b594dd8539e" translate="yes" xml:space="preserve">
          <source>In general, QDoc will generate &quot;See also&quot; links that interconnect the functions that access the same property. It recognizes four different syntax versions:</source>
          <target state="translated">一般来说,QDoc会生成 &quot;又见 &quot;链接,将访问同一属性的函数相互连接。它可以识别四种不同的语法版本。</target>
        </trans-unit>
        <trans-unit id="94ffe95519cbb62c5b86a0ab65f4b339f724b6c1" translate="yes" xml:space="preserve">
          <source>In general, a title command considers everything that follows it until the first line break as its argument. If the title is so long it must span multiple lines, end each line (except the last one) with a backslash.</source>
          <target state="translated">一般来说,标题命令会把它后面的所有内容,直到第一行的换行符作为它的参数,如果标题太长,必须跨越多行,那么每行(除了最后一行)都要用反斜杠结束。如果标题太长,必须跨越多行,那么每行(除了最后一行)都用反斜杠结束。</target>
        </trans-unit>
        <trans-unit id="98dd314277e1d0ada247bc3c672aabba6543f947" translate="yes" xml:space="preserve">
          <source>In general, an address is suitable for publication if it is an address this machine will be reached at for an indeterminate amount of time, though it need not be permanent. For example, addresses obtained via DHCP are often eligible, but cryptographically-generated temporary IPv6 addresses are not.</source>
          <target state="translated">一般来说,如果一个地址是一个可以在不确定的时间内到达这台机器的地址,那么这个地址就适合公布,尽管它不一定是永久性的。例如,通过DHCP获得的地址通常符合条件,但通过加密方式生成的临时IPv6地址则不符合条件。</target>
        </trans-unit>
        <trans-unit id="55acea3c2eb5e73edd7468a7a4dafb1085d723ed" translate="yes" xml:space="preserve">
          <source>In general, animating a property will cause any bindings which reference that property to be re-evaluated. Usually, this is what is desired but in other cases it may be better to disable the binding prior to performing the animation, and then reassign the binding once the animation has completed.</source>
          <target state="translated">一般来说,动画一个属性会导致任何引用该属性的绑定被重新评估。通常,这是我们所希望的,但在其他情况下,最好是在执行动画之前禁用绑定,然后在动画完成后重新分配绑定。</target>
        </trans-unit>
        <trans-unit id="d50f64d09939ac18488580b2d7a1face739cfb64" translate="yes" xml:space="preserve">
          <source>In general, creating QObjects before the &lt;a href=&quot;qapplication&quot;&gt;QApplication&lt;/a&gt; is not supported and can lead to weird crashes on exit, depending on the platform. This means static instances of &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; are also not supported. A properly structured single or multi-threaded application should make the &lt;a href=&quot;qapplication&quot;&gt;QApplication&lt;/a&gt; be the first created, and last destroyed &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;.</source>
          <target state="translated">通常，不支持在&lt;a href=&quot;qapplication&quot;&gt;QApplication&lt;/a&gt;之前创建QObject，这可能导致退出时发生奇怪的崩溃，具体取决于平台。这意味着也不支持&lt;a href=&quot;qobject&quot;&gt;QObject的&lt;/a&gt;静态实例。正确构造的单线程或多线程应用程序应使&lt;a href=&quot;qapplication&quot;&gt;QApplication&lt;/a&gt;成为第一个创建，最后一个销毁的&lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3163ba6967198fa96a626de9bd8f394ad413b305" translate="yes" xml:space="preserve">
          <source>In general, events come from the underlying window system (&lt;a href=&quot;qevent#spontaneous&quot;&gt;spontaneous&lt;/a&gt;() returns &lt;code&gt;true&lt;/code&gt;), but it is also possible to manually send events using &lt;a href=&quot;qcoreapplication#sendEvent&quot;&gt;QCoreApplication::sendEvent&lt;/a&gt;() and &lt;a href=&quot;qcoreapplication#postEvent&quot;&gt;QCoreApplication::postEvent&lt;/a&gt;() (&lt;a href=&quot;qevent#spontaneous&quot;&gt;spontaneous&lt;/a&gt;() returns &lt;code&gt;false&lt;/code&gt;).</source>
          <target state="translated">通常，事件来自基础窗口系统（&lt;a href=&quot;qevent#spontaneous&quot;&gt;自发&lt;/a&gt;（）返回 &lt;code&gt;true&lt;/code&gt; ），但是也可以使用&lt;a href=&quot;qcoreapplication#sendEvent&quot;&gt;QCoreApplication :: sendEvent&lt;/a&gt;（）和&lt;a href=&quot;qcoreapplication#postEvent&quot;&gt;QCoreApplication :: postEvent&lt;/a&gt;（）手动发送事件（&lt;a href=&quot;qevent#spontaneous&quot;&gt;自发&lt;/a&gt;（）返回 &lt;code&gt;false&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="7e1849f84d16bd0766ea8eb662b93a02850cb20f" translate="yes" xml:space="preserve">
          <source>In general, every Qt code entity such as properties, classes, methods, signals, and enumerations have a corresponding &lt;a href=&quot;qdoc-guide-writing#qdoc-topics&quot;&gt;topic command&lt;/a&gt;. QDoc will associate the documentation to the source using C++ naming rules.</source>
          <target state="translated">通常，每个Qt代码实体（例如属性，类，方法，信号和枚举）都有相应的&lt;a href=&quot;qdoc-guide-writing#qdoc-topics&quot;&gt;主题命令&lt;/a&gt;。QDoc将使用C ++命名规则将文档与源关联。</target>
        </trans-unit>
        <trans-unit id="2517cd279222c6f9d8801a3f3219d6fbf5a2de96" translate="yes" xml:space="preserve">
          <source>In general, for visualizing key focus, this property is preferred over &lt;a href=&quot;qml-qtquick-item#activeFocus-prop&quot;&gt;Item::activeFocus&lt;/a&gt;. This ensures that key focus is only visualized when interacting with keys - not when interacting via touch or mouse.</source>
          <target state="translated">通常，为了可视化按键焦点，此属性优于&lt;a href=&quot;qml-qtquick-item#activeFocus-prop&quot;&gt;Item :: activeFocus&lt;/a&gt;。这样可以确保仅在与按键进行交互时才显示按键焦点，而不是在通过触摸或鼠标进行交互时可见。</target>
        </trans-unit>
        <trans-unit id="3cfd9239afb114e51ac0078b1b52a454c1bd0350" translate="yes" xml:space="preserve">
          <source>In general, it is recommended that you are somewhat familiar with MSAA, which Qt's accessibility support originally was built for. You should also study the enum values of &lt;a href=&quot;qaccessible&quot;&gt;QAccessible&lt;/a&gt;, which describe the roles, actions, relationships, and events that you need to consider.</source>
          <target state="translated">通常，建议您对MSAA有所了解，而MSAA最初是为Qt的可访问性支持而建立的。您还应该研究&lt;a href=&quot;qaccessible&quot;&gt;QAccessible&lt;/a&gt;的枚举值，该枚举值描述您需要考虑的角色，动作，关系和事件。</target>
        </trans-unit>
        <trans-unit id="2692f7b2cb6d6d341ef938261c6eb784c6d5859b" translate="yes" xml:space="preserve">
          <source>In general, large and complex Map items such as polygons and polylines with large numbers of vertices can have an adverse effect on UI performance. Further, more detailed notes on this are in the documentation for each map item type.</source>
          <target state="translated">一般来说,大而复杂的地图项,如具有大量顶点的多边形和多直线,会对UI性能产生不利影响。此外,在每个地图项类型的文档中都有更详细的说明。</target>
        </trans-unit>
        <trans-unit id="1d4535d3c722b8e58e4d5f10e8bfeafccedbf548" translate="yes" xml:space="preserve">
          <source>In general, sensor data is oriented relative to &lt;a href=&quot;qplatformscreen#nativeOrientation&quot;&gt;QPlatformScreen::nativeOrientation&lt;/a&gt;, that is to the top of the device when the device is held in its natural orientation (normally when the device logo appears the right side up). If values are to be displayed on the screen, the values may need to be transformed so that they match the user interface orientation. A sensor may define its data as being oriented to the UI. This will be noted in the documentation for the sensor.</source>
          <target state="translated">通常，传感器数据是相对于&lt;a href=&quot;qplatformscreen#nativeOrientation&quot;&gt;QPlatformScreen :: nativeOrientation&lt;/a&gt;定向的，即以自然方向握住设备时（通常在设备徽标朝右上方时），该数据指向设备的顶部。如果要在屏幕上显示值，则可能需要对值进行转换，以使其与用户界面方向匹配。传感器可以将其数据定义为面向UI。这将在传感器的文档中进行说明。</target>
        </trans-unit>
        <trans-unit id="761d50d515b1823ae30af6b7a8144a8ab3eaa504" translate="yes" xml:space="preserve">
          <source>In general, sensor data is oriented relative to &lt;a href=&quot;qscreen#nativeOrientation-prop&quot;&gt;QScreen::nativeOrientation&lt;/a&gt;, that is to the top of the device when the device is held in its natural orientation (normally when the device logo appears the right side up). If values are to be displayed on the screen, the values may need to be transformed so that they match the user interface orientation. A sensor may define its data as being oriented to the UI. This will be noted in the documentation for the sensor.</source>
          <target state="translated">通常，传感器数据是相对于&lt;a href=&quot;qscreen#nativeOrientation-prop&quot;&gt;QScreen :: nativeOrientation&lt;/a&gt;定向的，即以自然方向握住设备时（通常在设备徽标朝上时，即朝设备顶部）。如果要在屏幕上显示值，则可能需要对值进行转换，以使其与用户界面方向匹配。传感器可以将其数据定义为面向UI。这将在传感器的文档中进行说明。</target>
        </trans-unit>
        <trans-unit id="f2d461ad9e2451af5a014dd5528ca190e7ae0e72" translate="yes" xml:space="preserve">
          <source>In general, simple logic should be defined in-line in the QML file, but more complex logic should be separated into code-behind implementation resources for maintainability and readability.</source>
          <target state="translated">一般来说,简单的逻辑应该在QML文件中内嵌定义,但较复杂的逻辑应该分离到代码后面的实现资源中,以保证可维护性和可读性。</target>
        </trans-unit>
        <trans-unit id="6849e63b08f87190a4b7fa882e9fc4b5445d543e" translate="yes" xml:space="preserve">
          <source>In general, the pointer will be invalid after the statement in which qUtf16Printable() is used. This is because the pointer may have been obtained from a temporary expression, which will fall out of scope.</source>
          <target state="translated">一般来说,在使用qUtf16Printable()的语句之后,指针将无效。这是因为指针可能是从一个临时表达式中获得的,而这个表达式将超出范围。</target>
        </trans-unit>
        <trans-unit id="6c622bb388124a5b26778b067a582514ab280201" translate="yes" xml:space="preserve">
          <source>In general, these are accessible from QML regardless of whether a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;-derived class has been &lt;a href=&quot;qtqml-cppintegration-definetypes#registering-c-types-with-the-qml-type-system&quot;&gt;registered with the QML type system&lt;/a&gt;. However, if a class is to be used in a way that requires the engine to access additional type information &amp;mdash; for example, if the class itself is to be used as a method parameter or property, or if one of its enum types is to be used in this way &amp;mdash; then the class may need to be registered.</source>
          <target state="translated">通常，无论是否已向&lt;a href=&quot;qtqml-cppintegration-definetypes#registering-c-types-with-the-qml-type-system&quot;&gt;QML类型系统注册&lt;/a&gt;了&lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;派生类，都可以从QML访问它们。但是，如果以要求引擎访问其他类型信息的方式使用类，例如，如果将类本身用作方法的参数或属性，或者要使用其枚举类型之一，则以这种方式使用-那么可能需要注册该类。</target>
        </trans-unit>
        <trans-unit id="61d4e33d0bc4ecf054832e4c44c5098f53bdf3c7" translate="yes" xml:space="preserve">
          <source>In general, this uuid is invalid on every platform but &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; and iOS. It is used as a workaround for those two platforms as they do not provide Bluetooth addresses for found Bluetooth Low Energy devices. Every other platform uses &lt;a href=&quot;qbluetoothdeviceinfo#address&quot;&gt;address&lt;/a&gt;() instead.</source>
          <target state="translated">通常，此uuid在除&lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;和iOS之外的所有平台上均无效。它被用作这两个平台的解决方法，因为它们不为找到的低功耗蓝牙设备提供蓝牙地址。每个其他平台都使用&lt;a href=&quot;qbluetoothdeviceinfo#address&quot;&gt;address&lt;/a&gt;（）代替。</target>
        </trans-unit>
        <trans-unit id="d3a17f19fd5126f7725d3873fb30280ab6070015" translate="yes" xml:space="preserve">
          <source>In general, this uuid is invalid on every platform but macOS and iOS. It is used as a workaround for those two platforms as they do not provide Bluetooth addresses for found Bluetooth Low Energy devices. Every other platform uses &lt;a href=&quot;qbluetoothdeviceinfo#address&quot;&gt;address&lt;/a&gt;() instead.</source>
          <target state="translated">通常，此uuid在除macOS和iOS之外的所有平台上均无效。由于这两个平台没有为找到的低功耗蓝牙设备提供蓝牙地址，因此它被用作解决方法。每个其他平台都使用&lt;a href=&quot;qbluetoothdeviceinfo#address&quot;&gt;address&lt;/a&gt;（）代替。</target>
        </trans-unit>
        <trans-unit id="84ceb92332ee7e2712c382b2842be15ad2b3a3dd" translate="yes" xml:space="preserve">
          <source>In general, we recommend that you create a &lt;a href=&quot;qcoreapplication&quot;&gt;QCoreApplication&lt;/a&gt;, &lt;a href=&quot;qguiapplication&quot;&gt;QGuiApplication&lt;/a&gt; or a &lt;a href=&quot;qapplication&quot;&gt;QApplication&lt;/a&gt; object in your &lt;code&gt;main()&lt;/code&gt; function as early as possible. &lt;a href=&quot;qcoreapplication#exec&quot;&gt;exec&lt;/a&gt;() will not return until the event loop exits; e.g., when &lt;a href=&quot;qcoreapplication#quit&quot;&gt;quit&lt;/a&gt;() is called.</source>
          <target state="translated">通常，我们建议您&lt;a href=&quot;qguiapplication&quot;&gt;尽早&lt;/a&gt;在 &lt;code&gt;main()&lt;/code&gt; 函数中创建&lt;a href=&quot;qcoreapplication&quot;&gt;QCoreApplication&lt;/a&gt;，QGuiApplication或&lt;a href=&quot;qapplication&quot;&gt;QApplication&lt;/a&gt;对象。&lt;a href=&quot;qcoreapplication#exec&quot;&gt;exec&lt;/a&gt;（）在事件循环退出之前不会返回；例如，当&lt;a href=&quot;qcoreapplication#quit&quot;&gt;quit&lt;/a&gt;（）被调用时。</target>
        </trans-unit>
        <trans-unit id="5273e641e1af5db67dd313f689d2ae03d3f0dc1c" translate="yes" xml:space="preserve">
          <source>In general, we recommend that you create a QCoreApplication, &lt;a href=&quot;qguiapplication&quot;&gt;QGuiApplication&lt;/a&gt; or a &lt;a href=&quot;qapplication&quot;&gt;QApplication&lt;/a&gt; object in your &lt;code&gt;main()&lt;/code&gt; function as early as possible. &lt;a href=&quot;qcoreapplication#exec&quot;&gt;exec&lt;/a&gt;() will not return until the event loop exits; e.g., when &lt;a href=&quot;qcoreapplication#quit&quot;&gt;quit&lt;/a&gt;() is called.</source>
          <target state="translated">通常，我们建议您&lt;a href=&quot;qguiapplication&quot;&gt;尽早&lt;/a&gt;在 &lt;code&gt;main()&lt;/code&gt; 函数中创建QCoreApplication，QGuiApplication或&lt;a href=&quot;qapplication&quot;&gt;QApplication&lt;/a&gt;对象。&lt;a href=&quot;qcoreapplication#exec&quot;&gt;exec&lt;/a&gt;（）在事件循环退出之前不会返回；例如，当&lt;a href=&quot;qcoreapplication#quit&quot;&gt;quit&lt;/a&gt;（）被调用时。</target>
        </trans-unit>
        <trans-unit id="d9e4277a8585c35d53b91045f546875f4b1b8bc1" translate="yes" xml:space="preserve">
          <source>In general, we recommend that you use &lt;a href=&quot;qhash#contains&quot;&gt;contains&lt;/a&gt;() and &lt;a href=&quot;qhash#value&quot;&gt;value&lt;/a&gt;() rather than operator[]() for looking up a key in a hash. The reason is that operator[]() silently inserts an item into the hash if no item exists with the same key (unless the hash is const). For example, the following code snippet will create 1000 items in memory:</source>
          <target state="translated">通常，我们建议您使用&lt;a href=&quot;qhash#contains&quot;&gt;contains&lt;/a&gt;（）和&lt;a href=&quot;qhash#value&quot;&gt;value&lt;/a&gt;（）而不是operator []（）来查找哈希中的键。原因是如果不存在具有相同键的项，operator []（）会将项静默插入到哈希中（除非哈希为const）。例如，以下代码片段将在内存中创建1000个项目：</target>
        </trans-unit>
        <trans-unit id="b0007a434f71d259618694822d5bfeba83e1dd00" translate="yes" xml:space="preserve">
          <source>In general, we recommend that you use &lt;a href=&quot;qmap#contains&quot;&gt;contains&lt;/a&gt;() and &lt;a href=&quot;qmap#value&quot;&gt;value&lt;/a&gt;() rather than operator[]() for looking up a key in a map. The reason is that operator[]() silently inserts an item into the map if no item exists with the same key (unless the map is const). For example, the following code snippet will create 1000 items in memory:</source>
          <target state="translated">通常，我们建议您使用&lt;a href=&quot;qmap#contains&quot;&gt;contains&lt;/a&gt;（）和&lt;a href=&quot;qmap#value&quot;&gt;value&lt;/a&gt;（）而不是operator []（）在地图中查找键。原因是如果不存在具有相同键的项，operator []（）会以静默方式将一项插入地图（除非地图为const）。例如，以下代码片段将在内存中创建1000个项目：</target>
        </trans-unit>
        <trans-unit id="995231ad234230a9b8a6a0e6e825f932f6c3528a" translate="yes" xml:space="preserve">
          <source>In general, you will rarely ever need to call this function. &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt;'s internal hash table automatically grows to provide good performance without wasting too much memory.</source>
          <target state="translated">通常，您几乎不需要调用此函数。&lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt;的内部哈希表会自动增长以提供良好的性能，而不会浪费太多内存。</target>
        </trans-unit>
        <trans-unit id="dc5622e36d535a53db4beeb4bbbfc01f7a4d6e23" translate="yes" xml:space="preserve">
          <source>In general, you will rarely ever need to call this function. &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt;'s internal hash table automatically shrinks or grows to provide good performance without wasting too much memory.</source>
          <target state="translated">通常，您几乎不需要调用此函数。&lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt;的内部哈希表会自动缩小或增长以提供良好的性能，而不会浪费太多内存。</target>
        </trans-unit>
        <trans-unit id="19a04368af0343289fa3b76e8b7ef2051808deb3" translate="yes" xml:space="preserve">
          <source>In general, you will rarely ever need to call this function. &lt;a href=&quot;qset&quot;&gt;QSet&lt;/a&gt;'s internal hash table automatically shrinks or grows to provide good performance without wasting too much memory.</source>
          <target state="translated">通常，您几乎不需要调用此函数。&lt;a href=&quot;qset&quot;&gt;QSet&lt;/a&gt;的内部哈希表会自动缩小或增长以提供良好的性能，而不会浪费太多内存。</target>
        </trans-unit>
        <trans-unit id="ba9eb27b95af0b2827dafa339ac25524deb224bf" translate="yes" xml:space="preserve">
          <source>In hierarchical models where finding the number of children of a given item is an expensive operation, it is useful to ensure that the model's &lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount()&lt;/a&gt; implementation is only called when necessary. In such cases, the &lt;a href=&quot;qabstractitemmodel#hasChildren&quot;&gt;hasChildren()&lt;/a&gt; function can be reimplemented to provide an inexpensive way for views to check for the presence of children and, in the case of &lt;a href=&quot;qtreeview&quot;&gt;QTreeView&lt;/a&gt;, draw the appropriate decoration for their parent item.</source>
          <target state="translated">在查找给定项目的子&lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;代数&lt;/a&gt;是一项昂贵操作的层次模型中，确保仅在必要时才调用模型的rowCount（）实现非常有用。在这种情况下，可以重新实现&lt;a href=&quot;qabstractitemmodel#hasChildren&quot;&gt;hasChildren（）&lt;/a&gt;函数，以提供一种廉价的方法来查看视图是否存在子项，对于&lt;a href=&quot;qtreeview&quot;&gt;QTreeView而言&lt;/a&gt;，为其子项绘制适当的装饰。</target>
        </trans-unit>
        <trans-unit id="cb92e51877c2515aad653fa53a73570269080b5a" translate="yes" xml:space="preserve">
          <source>In hierarchical models, when a drop occurs on an item, it would be better to insert new items into the model as children of that item. In the simple example shown here, the model only has one level, so this approach is not appropriate.</source>
          <target state="translated">在分层模型中,当一个项目发生掉落时,最好将新的项目作为该项目的子项目插入到模型中。在这里所示的简单例子中,模型只有一个层次,所以这种方法是不合适的。</target>
        </trans-unit>
        <trans-unit id="00c0cae839ddda624334a2403483c7352f65cd8e" translate="yes" xml:space="preserve">
          <source>In its most basic form, a model can be accessed as a simple table in which items are located by their row and column numbers.</source>
          <target state="translated">在其最基本的形式中,一个模型可以作为一个简单的表格被访问,其中的项目通过其行号和列号来定位。</target>
        </trans-unit>
        <trans-unit id="dbc0cc9cd4253bcc283de2f132ac5c7d434d46b6" translate="yes" xml:space="preserve">
          <source>In its most common form, a key sequence describes a combination of keys that must be used together to perform some action. Key sequences are used with &lt;a href=&quot;qaction&quot;&gt;QAction&lt;/a&gt; objects to specify which keyboard shortcuts can be used to trigger actions.</source>
          <target state="translated">按键序列以其最常见的形式描述了必须一起使用才能执行某些操作的按键组合。键序列与&lt;a href=&quot;qaction&quot;&gt;QAction&lt;/a&gt;对象一起使用，以指定可用于触发操作的键盘快捷键。</target>
        </trans-unit>
        <trans-unit id="b667f86f48fc68b85ef71c107d6544fbee938d65" translate="yes" xml:space="preserve">
          <source>In its simplest form, a tree widget can be constructed in the following way:</source>
          <target state="translated">在最简单的形式下,树状小组件可以用以下方式构建。</target>
        </trans-unit>
        <trans-unit id="7dcd072fc314743db90dadec9d0a600d1ddbed98" translate="yes" xml:space="preserve">
          <source>In itself, a &lt;a href=&quot;qt3drender-qmaterial&quot;&gt;QMaterial&lt;/a&gt; doesn't do anything. It's only when it references a &lt;a href=&quot;qt3drender-qeffect&quot;&gt;QEffect&lt;/a&gt; node that a &lt;a href=&quot;qt3drender-qmaterial&quot;&gt;QMaterial&lt;/a&gt; becomes useful.</source>
          <target state="translated">本身，&lt;a href=&quot;qt3drender-qmaterial&quot;&gt;QMaterial&lt;/a&gt;不会执行任何操作。只有在引用&lt;a href=&quot;qt3drender-qeffect&quot;&gt;QEffect&lt;/a&gt;节点时，&lt;a href=&quot;qt3drender-qmaterial&quot;&gt;QMaterial才有&lt;/a&gt;用。</target>
        </trans-unit>
        <trans-unit id="de2cc45bab651e1c7dac8b1681471a3a08848efc" translate="yes" xml:space="preserve">
          <source>In itself, a Material doesn't do anything. It's only when it references an Effect node that a Material becomes useful.</source>
          <target state="translated">材质本身并没有任何作用。只有当它引用一个效果节点时,Material才变得有用。</target>
        </trans-unit>
        <trans-unit id="e363f703a6970bd71136fc865ce0a88b99a86de3" translate="yes" xml:space="preserve">
          <source>In itself, a QMaterial doesn't do anything. It's only when it references a &lt;a href=&quot;qt3drender-qeffect&quot;&gt;QEffect&lt;/a&gt; node that a QMaterial becomes useful.</source>
          <target state="translated">本身，QMaterial不会执行任何操作。仅当它引用&lt;a href=&quot;qt3drender-qeffect&quot;&gt;QEffect&lt;/a&gt;节点时，QMaterial才有用。</target>
        </trans-unit>
        <trans-unit id="f2584c43252a8dc553e4314115f45d5e3c816240" translate="yes" xml:space="preserve">
          <source>In keyboard-interactive mode, the windows are moved and resized with the keyboard. You can enter this mode through the system menu of the window. The &lt;a href=&quot;qmdisubwindow#keyboardSingleStep-prop&quot;&gt;keyboardSingleStep&lt;/a&gt; and &lt;a href=&quot;qmdisubwindow#keyboardPageStep-prop&quot;&gt;keyboardPageStep&lt;/a&gt; properties control the distance the widget is moved or resized for each keypress event. When shift is pressed down page step is used; otherwise single step is used.</source>
          <target state="translated">在键盘交互模式下，使用键盘移动窗口并调整窗口大小。您可以通过窗口的系统菜单进入此模式。的&lt;a href=&quot;qmdisubwindow#keyboardSingleStep-prop&quot;&gt;keyboardSingleStep&lt;/a&gt;和&lt;a href=&quot;qmdisubwindow#keyboardPageStep-prop&quot;&gt;keyboardPageStep&lt;/a&gt;属性控制窗口小部件被移动或调整大小为每个按键事件的距离。当按下shift键时，使用页面步进；否则，将使用单一步骤。</target>
        </trans-unit>
        <trans-unit id="019d4a8d63e5cf2686f8b92fdb64afdacb4830e6" translate="yes" xml:space="preserve">
          <source>In line with most implementations today, &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; will assume the INI file is utf-8 encoded. This means that keys and values will be decoded as utf-8 encoded entries and written back as utf-8.</source>
          <target state="translated">与当今的大多数实现一致，&lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt;将假定INI文件是utf-8编码的。这意味着键和值将被解码为utf-8编码的条目，并写回为utf-8。</target>
        </trans-unit>
        <trans-unit id="8d9dce4b47f86fcc46f9fd0d8b8e3c72cb0bff73" translate="yes" xml:space="preserve">
          <source>In many cases it is sufficient to receive signals through signal handlers rather than using the connect() function. However, using the &lt;code&gt;connect&lt;/code&gt; method allows a signal to be received by multiple methods as shown earlier, which would not be possible with signal handlers as they must be uniquely named. Also, the &lt;code&gt;connect&lt;/code&gt; method is useful when connecting signals to &lt;a href=&quot;qtqml-javascript-dynamicobjectcreation&quot;&gt;dynamically created objects&lt;/a&gt;.</source>
          <target state="translated">在许多情况下，通过信号处理程序接收信号而不是使用connect（）函数就足够了。但是，使用 &lt;code&gt;connect&lt;/code&gt; 方法可以通过多种方法接收信号，如前所述，这对于信号处理程序来说是不可能的，因为它们必须唯一地命名。同样，当将信号连接到&lt;a href=&quot;qtqml-javascript-dynamicobjectcreation&quot;&gt;动态创建的对象&lt;/a&gt;时， &lt;code&gt;connect&lt;/code&gt; 方法也很有用。</target>
        </trans-unit>
        <trans-unit id="f4616ef1618967d6d6591d1a4505628dc05ae149" translate="yes" xml:space="preserve">
          <source>In many cases it is sufficient to receive signals through signal handlers rather than using the connect() function. However, using the &lt;code&gt;connect&lt;/code&gt; method allows a signal to be received by multiple methods as shown earlier, which would not be possible with signal handlers as they must be uniquely named. Also, the &lt;code&gt;connect&lt;/code&gt; method is useful when connecting signals to &lt;a href=&quot;qtqml-javascript-dynamicobjectcreation#&quot;&gt;dynamically created objects&lt;/a&gt;.</source>
          <target state="translated">在许多情况下，通过信号处理程序接收信号而不是使用connect（）函数就足够了。但是，使用 &lt;code&gt;connect&lt;/code&gt; 方法可以通过多种方法接收信号，如前所述，这对于信号处理程序来说是不可能的，因为它们必须唯一地命名。另外， &lt;code&gt;connect&lt;/code&gt; 信号连接到&lt;a href=&quot;qtqml-javascript-dynamicobjectcreation#&quot;&gt;动态创建的对象&lt;/a&gt;时，connect方法很有用。</target>
        </trans-unit>
        <trans-unit id="d785d6c000a5fe3467d5ab1dab6fc441daf8ae7d" translate="yes" xml:space="preserve">
          <source>In many cases the torch hardware is shared with camera flash functionality, and might be automatically controlled by the device. You have control over the power level (of course, higher power levels are brighter but reduce battery life significantly).</source>
          <target state="translated">在许多情况下,电筒硬件与相机闪光灯功能共享,可能由设备自动控制。你可以控制功率水平(当然,更高的功率水平更亮,但会大大减少电池寿命)。</target>
        </trans-unit>
        <trans-unit id="161ae7ee9897550d357db6468a55ca2ca1146c1d" translate="yes" xml:space="preserve">
          <source>In many cases these properties do not need to be explicitly specified, as they can be inferred from the animation framework:</source>
          <target state="translated">在许多情况下,这些属性不需要明确指定,因为它们可以从动画框架中推断出来。</target>
        </trans-unit>
        <trans-unit id="3a7bd39609818c74e82eaebc3b22311f55a717b7" translate="yes" xml:space="preserve">
          <source>In many cases, &lt;a href=&quot;qreadwritelock&quot;&gt;QReadWriteLock&lt;/a&gt; is a direct competitor to &lt;a href=&quot;qmutex&quot;&gt;QMutex&lt;/a&gt;. &lt;a href=&quot;qreadwritelock&quot;&gt;QReadWriteLock&lt;/a&gt; is a good choice if there are many concurrent reads and writing occurs infrequently.</source>
          <target state="translated">在许多情况下，&lt;a href=&quot;qreadwritelock&quot;&gt;QReadWriteLock&lt;/a&gt;是直接竞争对手&lt;a href=&quot;qmutex&quot;&gt;QMutex&lt;/a&gt;。如果有许多并发读取并且很少发生写入，则&lt;a href=&quot;qreadwritelock&quot;&gt;QReadWriteLock&lt;/a&gt;是一个不错的选择。</target>
        </trans-unit>
        <trans-unit id="cdc945eef5b6d0e6d1cd2c4df87c7e141e4f43e5" translate="yes" xml:space="preserve">
          <source>In many cases, QReadWriteLock is a direct competitor to &lt;a href=&quot;qmutex&quot;&gt;QMutex&lt;/a&gt;. QReadWriteLock is a good choice if there are many concurrent reads and writing occurs infrequently.</source>
          <target state="translated">在许多情况下，QReadWriteLock是直接竞争对手&lt;a href=&quot;qmutex&quot;&gt;QMutex&lt;/a&gt;。如果有许多并发读取并且很少发生写入，则QReadWriteLock是一个不错的选择。</target>
        </trans-unit>
        <trans-unit id="b16bee62c9c48e4c2ca9d8d2c32391aa363b033b" translate="yes" xml:space="preserve">
          <source>In many cases, the internal state of a control can be more efficiently processed in C++. For example, handling input events in C++ makes a difference for controls that would otherwise need to create internal MouseAreas and attached Keys objects.</source>
          <target state="translated">在许多情况下,控件的内部状态可以在C++中得到更有效的处理。例如,用C++处理输入事件,对于那些需要创建内部MouseAreas和附加Keys对象的控件来说,就会有不同的效果。</target>
        </trans-unit>
        <trans-unit id="f609949c9c12ed4aaeb5e4385fbcad5eaa080388" translate="yes" xml:space="preserve">
          <source>In many project files, the assignment (&lt;code&gt;=&lt;/code&gt;) and append (&lt;code&gt;+=&lt;/code&gt;) operators can be used to include all the information about a project. The typical pattern of use is to assign a list of values to a variable, and append more values depending on the result of various tests. Since qmake defines certain variables using default values, it is sometimes necessary to use the removal (&lt;code&gt;-=&lt;/code&gt;) operator to filter out values that are not required. The following sections describe how to use operators to manipulate the contents of variables.</source>
          <target state="translated">在许多项目文件中，赋值（ &lt;code&gt;=&lt;/code&gt; ）和append（ &lt;code&gt;+=&lt;/code&gt; ）运算符可用于包括有关项目的所有信息。典型的使用模式是为变量分配值列表，并根据各种测试的结果附加更多值。由于qmake使用默认值定义某些变量，因此有时有必要使用remove（ &lt;code&gt;-=&lt;/code&gt; ）运算符过滤掉不需要的值。以下各节描述如何使用运算符来操纵变量的内容。</target>
        </trans-unit>
        <trans-unit id="782917b6030b45e21219e726acc63fe353c72ceb" translate="yes" xml:space="preserve">
          <source>In many user interfaces, it is sufficient to set a visual object's opacity to 0 or to move the visual object off the screen instead of deleting it. If you have lots of dynamically created objects, however, you may receive a worthwhile performance benefit if unused objects are deleted.</source>
          <target state="translated">在许多用户界面中,只要将可视对象的不透明度设置为0,或者将可视对象从屏幕上移开就可以了,而不是删除它。然而,如果你有很多动态创建的对象,如果删除未使用的对象,你可能会收到值得的性能优势。</target>
        </trans-unit>
        <trans-unit id="78d9649203441474de67ef8c858231e2a462eb10" translate="yes" xml:space="preserve">
          <source>In many wizards, the contents of a page may affect the default values of the fields of a later page. To make it easy to communicate between pages, &lt;a href=&quot;qwizard&quot;&gt;QWizard&lt;/a&gt; supports a &quot;field&quot; mechanism that allows you to register a field (e.g., a &lt;a href=&quot;qlineedit&quot;&gt;QLineEdit&lt;/a&gt;) on a page and to access its value from any page. It is also possible to specify mandatory fields (i.e., fields that must be filled before the user can advance to the next page).</source>
          <target state="translated">在许多向导中，页面的内容可能会影响后面页面的字段的默认值。为了使页面之间的通信变得容易，&lt;a href=&quot;qwizard&quot;&gt;QWizard&lt;/a&gt;支持&amp;ldquo;字段&amp;rdquo;机制，该机制允许您在页面上注册字段（例如&lt;a href=&quot;qlineedit&quot;&gt;QLineEdit&lt;/a&gt;）并从任何页面访问其值。也可以指定必填字段（即，在用户可以前进到下一页之前必须填充的字段）。</target>
        </trans-unit>
        <trans-unit id="340a548e3daa2a531166f65a82fc421c7864c735" translate="yes" xml:space="preserve">
          <source>In many wizards, the contents of a page may affect the default values of the fields of a later page. To make it easy to communicate between pages, &lt;a href=&quot;qwizard&quot;&gt;QWizard&lt;/a&gt; supports a &lt;a href=&quot;qwizard#registering-and-using-fields&quot;&gt;&quot;field&quot; mechanism&lt;/a&gt; that allows you to register a field (e.g., a &lt;a href=&quot;qlineedit&quot;&gt;QLineEdit&lt;/a&gt;) on a page and to access its value from any page. Fields are global to the entire wizard and make it easy for any single page to access information stored by another page, without having to put all the logic in &lt;a href=&quot;qwizard&quot;&gt;QWizard&lt;/a&gt; or having the pages know explicitly about each other. Fields are registered using &lt;a href=&quot;qwizardpage#registerField&quot;&gt;registerField&lt;/a&gt;() and can be accessed at any time using &lt;a href=&quot;qwizardpage#field&quot;&gt;field&lt;/a&gt;() and &lt;a href=&quot;qwizardpage#setField&quot;&gt;setField&lt;/a&gt;().</source>
          <target state="translated">在许多向导中，页面的内容可能会影响后面页面的字段的默认值。为了使页面之间的通信变得容易，&lt;a href=&quot;qwizard&quot;&gt;QWizard&lt;/a&gt;支持&lt;a href=&quot;qwizard#registering-and-using-fields&quot;&gt;&amp;ldquo;字段&amp;rdquo;机制&lt;/a&gt;，该机制允许您在页面上注册字段（例如&lt;a href=&quot;qlineedit&quot;&gt;QLineEdit&lt;/a&gt;）并从任何页面访问其值。字段是整个向导的全局字段，使任何单个页面都可以轻松访问另一页面存储的信息，而不必将所有逻辑放入&lt;a href=&quot;qwizard&quot;&gt;QWizard&lt;/a&gt;或使各页面彼此明确地了解。字段是使用&lt;a href=&quot;qwizardpage#registerField&quot;&gt;registerField&lt;/a&gt;（）注册的，并且可以随时使用&lt;a href=&quot;qwizardpage#field&quot;&gt;field&lt;/a&gt;（）和&lt;a href=&quot;qwizardpage#setField&quot;&gt;setField&lt;/a&gt;（）进行访问。</target>
        </trans-unit>
        <trans-unit id="60a36409aef8188573ab3c54d5f01a5a07d5125c" translate="yes" xml:space="preserve">
          <source>In many wizards, the contents of a page may affect the default values of the fields of a later page. To make it easy to communicate between pages, QWizard supports a &quot;field&quot; mechanism that allows you to register a field (e.g., a &lt;a href=&quot;qlineedit&quot;&gt;QLineEdit&lt;/a&gt;) on a page and to access its value from any page. It is also possible to specify mandatory fields (i.e., fields that must be filled before the user can advance to the next page).</source>
          <target state="translated">在许多向导中，页面的内容可能会影响后面页面的字段的默认值。为了使页面之间的通信变得容易，QWizard支持&amp;ldquo;字段&amp;rdquo;机制，该机制允许您在页面上注册字段（例如&lt;a href=&quot;qlineedit&quot;&gt;QLineEdit&lt;/a&gt;）并从任何页面访问其值。也可以指定必填字段（即，在用户可以前进到下一页之前必须填充的字段）。</target>
        </trans-unit>
        <trans-unit id="f18a6c09fd6cb157b1e37176352d7968fbaeebaf" translate="yes" xml:space="preserve">
          <source>In member functions where an argument</source>
          <target state="translated">在有参数的成员函数中</target>
        </trans-unit>
        <trans-unit id="7d9cbbf03d10a0b89b193fdd16a70bbef05fcda3" translate="yes" xml:space="preserve">
          <source>In memory, resources are represented by a tree of resource objects. The tree is automatically built at startup and used by &lt;a href=&quot;qfile&quot;&gt;QFile&lt;/a&gt; for resolving paths to resources. You can use a &lt;a href=&quot;qdir&quot;&gt;QDir&lt;/a&gt; initialized with &quot;:/&quot; to navigate through the resource tree from the root.</source>
          <target state="translated">在内存中，资源由资源对象树表示。该树在启动时自动构建，并由&lt;a href=&quot;qfile&quot;&gt;QFile&lt;/a&gt;用于解析资源路径。您可以使用以&amp;ldquo;：/&amp;rdquo;初始化的&lt;a href=&quot;qdir&quot;&gt;QDir&lt;/a&gt;从根目录浏览资源树。</target>
        </trans-unit>
        <trans-unit id="220a9a22a5e747671c32d0cc7b5fa3d602a8c0a8" translate="yes" xml:space="preserve">
          <source>In most cases it is better to use either &lt;a href=&quot;qcontiguouscache#at&quot;&gt;at&lt;/a&gt;() or &lt;a href=&quot;qcontiguouscache#insert&quot;&gt;insert&lt;/a&gt;().</source>
          <target state="translated">在大多数情况下，最好是既可以使用&lt;a href=&quot;qcontiguouscache#at&quot;&gt;在&lt;/a&gt;（）或&lt;a href=&quot;qcontiguouscache#insert&quot;&gt;插入&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="fd8565e7cf43454d4a874faeda6b26b5eab778b5" translate="yes" xml:space="preserve">
          <source>In most cases it is better to use either &lt;a href=&quot;qcontiguouscache#at&quot;&gt;at&lt;/a&gt;() or &lt;a href=&quot;qcontiguouscache#insert-1&quot;&gt;insert&lt;/a&gt;().</source>
          <target state="translated">在大多数情况下，最好&lt;a href=&quot;qcontiguouscache#at&quot;&gt;在&lt;/a&gt;（）或&lt;a href=&quot;qcontiguouscache#insert-1&quot;&gt;insert&lt;/a&gt;（）处使用。</target>
        </trans-unit>
        <trans-unit id="73197b5aa23629d2e7100cc32d11106dcdef78e9" translate="yes" xml:space="preserve">
          <source>In most cases the indexes will not exceed 0 to INT_MAX, and &lt;a href=&quot;qcontiguouscache#normalizeIndexes&quot;&gt;normalizeIndexes&lt;/a&gt;() will not need to be used.</source>
          <target state="translated">在大多数情况下，索引不会超过0到INT_MAX，并且不需要使用&lt;a href=&quot;qcontiguouscache#normalizeIndexes&quot;&gt;normalizeIndexes&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="61941430557547c2cafc6d78e6fe67b961b1fdcf" translate="yes" xml:space="preserve">
          <source>In most cases the state chage is caused by &lt;a href=&quot;qcameracontrol#setState&quot;&gt;QCameraControl::setState&lt;/a&gt;(), but if critical error has occurred the state changes to &lt;a href=&quot;qcamera#State-enum&quot;&gt;QCamera::UnloadedState&lt;/a&gt;.</source>
          <target state="translated">在大多数情况下，状态变化是由&lt;a href=&quot;qcameracontrol#setState&quot;&gt;QCameraControl :: setState&lt;/a&gt;（）引起的，但是如果发生严重错误，则状态将更改为&lt;a href=&quot;qcamera#State-enum&quot;&gt;QCamera :: UnloadedState&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c26bd4a4c500ac565eae1b1328dab78467ff1701" translate="yes" xml:space="preserve">
          <source>In most cases this function returns the same string as &lt;a href=&quot;qsqlquery#lastQuery&quot;&gt;lastQuery&lt;/a&gt;(). If a prepared query with placeholders is executed on a DBMS that does not support it, the preparation of this query is emulated. The placeholders in the original query are replaced with their bound values to form a new query. This function returns the modified query. It is mostly useful for debugging purposes.</source>
          <target state="translated">在大多数情况下，此函数返回与&lt;a href=&quot;qsqlquery#lastQuery&quot;&gt;lastQuery&lt;/a&gt;（）相同的字符串。如果在不支持占位符的预准备查询是在不支持占位符的DBMS上执行的，则将模拟该查询的准备。原始查询中的占位符将替换为其绑定值，以形成一个新查询。此函数返回修改后的查询。它主要用于调试目的。</target>
        </trans-unit>
        <trans-unit id="ccdd1f4dc787718433566c661cac339bc2cf8f74" translate="yes" xml:space="preserve">
          <source>In most cases where you would consider using function pointers as signal or slot parameters, we think inheritance is a better alternative. Here is an example of illegal syntax:</source>
          <target state="translated">在大多数情况下,你会考虑使用函数指针作为信号或槽参数,我们认为继承是一个更好的选择。下面是一个非法语法的例子。</target>
        </trans-unit>
        <trans-unit id="6034aed0417ebe53af1d84f5a1c61a3e76db55a2" translate="yes" xml:space="preserve">
          <source>In most cases, application developers will not be using the skinning API manually. The normal workflow is to use an external content creation tool to define the skeleton and the skin (this is sometimes also referred to as</source>
          <target state="translated">在大多数情况下,应用程序开发人员不会手动使用换肤API。正常的工作流程是使用外部内容创建工具来定义骨架和皮肤(这有时也被称为 &quot;皮肤&quot;)。</target>
        </trans-unit>
        <trans-unit id="a8916466ca092f76775d62ec89be7e64ec9658cc" translate="yes" xml:space="preserve">
          <source>In most cases, changes made to a graph are detected by Qt 3D and a new cache entry will be generated. One case were this will not happen is when code snippets included by a graphs are changed. To work around that, clearing the cache directory or setting environment variable QT3D_REBUILD_SHADER_CACHE can be used to force shader code to be generated again.</source>
          <target state="translated">在大多数情况下,Qt 3D会检测到对图形的修改,并生成一个新的缓存条目。有一种情况不会发生,那就是当一个图形所包含的代码片段被更改时。为了解决这个问题,可以通过清除缓存目录或设置环境变量QT3D_REBUILD_SHADER_CACHE来强制重新生成着色器代码。</target>
        </trans-unit>
        <trans-unit id="ed458223351dc80f129b8d1e0771b835bd8c9289" translate="yes" xml:space="preserve">
          <source>In most cases, existing layout-aware classes such as &lt;a href=&quot;graphicsview#qgraphicswidget&quot;&gt;QGraphicsWidget&lt;/a&gt; and &lt;a href=&quot;graphicsview#qgraphicslayout&quot;&gt;QGraphicsLayout&lt;/a&gt; already provide the functionality you require. However, subclassing these classes will enable you to create both graphical elements that work well with layouts (&lt;a href=&quot;graphicsview#qgraphicswidget&quot;&gt;QGraphicsWidget&lt;/a&gt;) or custom layouts (&lt;a href=&quot;graphicsview#qgraphicslayout&quot;&gt;QGraphicsLayout&lt;/a&gt;).</source>
          <target state="translated">在大多数情况下，现有的可感知布局的类（例如&lt;a href=&quot;graphicsview#qgraphicswidget&quot;&gt;QGraphicsWidget&lt;/a&gt;和&lt;a href=&quot;graphicsview#qgraphicslayout&quot;&gt;QGraphicsLayout）&lt;/a&gt;已经提供了您所需的功能。但是，通过子类化这些类，将使您能够创建与布局（&lt;a href=&quot;graphicsview#qgraphicswidget&quot;&gt;QGraphicsWidget&lt;/a&gt;）或自定义布局（&lt;a href=&quot;graphicsview#qgraphicslayout&quot;&gt;QGraphicsLayout&lt;/a&gt;）一起使用的图形元素。</target>
        </trans-unit>
        <trans-unit id="a1f9cd42bca7bf8549d0b7506bf7a2ff5d5b751f" translate="yes" xml:space="preserve">
          <source>In most cases, it is not wise to manually invoke the garbage collector, as it will block the GUI thread for a substantial period of time. This can result in skipped frames and jerky animations, which should be avoided at all costs.</source>
          <target state="translated">在大多数情况下,手动调用垃圾收集器是不明智的,因为它会在相当长的一段时间内阻塞GUI线程。这可能导致跳帧和抖动的动画,应不惜一切代价避免。</target>
        </trans-unit>
        <trans-unit id="927428fec6043727a4df5c30289799179e4307b4" translate="yes" xml:space="preserve">
          <source>In most cases, this is the Unicode representation of the key code.</source>
          <target state="translated">在大多数情况下,这是关键代码的Unicode表示。</target>
        </trans-unit>
        <trans-unit id="36881272bd5823b4dc7cf0473854f220400954b3" translate="yes" xml:space="preserve">
          <source>In most cases, using &lt;code&gt;@rpath&lt;/code&gt; is sufficient and recommended:</source>
          <target state="translated">在大多数情况下，使用 &lt;code&gt;@rpath&lt;/code&gt; 就足够了，建议：</target>
        </trans-unit>
        <trans-unit id="29704ffa56b268da56f994cc9b0178b8fc8f5fa5" translate="yes" xml:space="preserve">
          <source>In most cases, you will also implement &lt;a href=&quot;qlayout#minimumSize&quot;&gt;minimumSize()&lt;/a&gt;.</source>
          <target state="translated">在大多数情况下，您还将实现&lt;a href=&quot;qlayout#minimumSize&quot;&gt;minimumSize（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a720d87c85cb4a3f7abf598e33c014fe235fcfae" translate="yes" xml:space="preserve">
          <source>In most main window style applications you would use the &lt;a href=&quot;qmainwindow#menuBar&quot;&gt;menuBar()&lt;/a&gt; function provided in &lt;a href=&quot;qmainwindow&quot;&gt;QMainWindow&lt;/a&gt;, adding &lt;a href=&quot;qmenu&quot;&gt;QMenu&lt;/a&gt;s to the menu bar and adding &lt;a href=&quot;qaction&quot;&gt;QAction&lt;/a&gt;s to the pop-up menus.</source>
          <target state="translated">在大多数主窗口样式应用程序中，您将使用&lt;a href=&quot;qmainwindow&quot;&gt;QMainWindow中&lt;/a&gt;提供的&lt;a href=&quot;qmainwindow#menuBar&quot;&gt;menuBar（）&lt;/a&gt;函数，将&lt;a href=&quot;qmenu&quot;&gt;QMenu&lt;/a&gt;添加到菜单栏，并将&lt;a href=&quot;qaction&quot;&gt;QAction&lt;/a&gt;添加到弹出菜单。</target>
        </trans-unit>
        <trans-unit id="5eb42ddc37d565d38c3af20b6bc404c9a2eced6e" translate="yes" xml:space="preserve">
          <source>In most programs, the &lt;a href=&quot;qdbuspendingcall&quot;&gt;QDBusPendingCall&lt;/a&gt; class will not be used directly. It can be safely replaced with the template-based &lt;a href=&quot;qdbuspendingreply&quot;&gt;QDBusPendingReply&lt;/a&gt;, in order to access the contents of the reply or wait for it to be complete.</source>
          <target state="translated">在大多数程序中，不会直接使用&lt;a href=&quot;qdbuspendingcall&quot;&gt;QDBusPendingCall&lt;/a&gt;类。可以安全地将其替换为基于模板的&lt;a href=&quot;qdbuspendingreply&quot;&gt;QDBusPendingReply&lt;/a&gt;，以访问答复的内容或等待其完成。</target>
        </trans-unit>
        <trans-unit id="99a6ebb56f474cc9391b16ba27cac80b782b2b1d" translate="yes" xml:space="preserve">
          <source>In most programs, the QDBusPendingCall class will not be used directly. It can be safely replaced with the template-based &lt;a href=&quot;dbus-changes-qt6#qdbuspendingreply&quot;&gt;QDBusPendingReply&lt;/a&gt;, in order to access the contents of the reply or wait for it to be complete.</source>
          <target state="translated">在大多数程序中，不会直接使用QDBusPendingCall类。可以安全地将其替换为基于模板的&lt;a href=&quot;dbus-changes-qt6#qdbuspendingreply&quot;&gt;QDBusPendingReply&lt;/a&gt;，以访问答复的内容或等待其完成。</target>
        </trans-unit>
        <trans-unit id="c815b26a3edbe457cbae84dc60e50ed929f80007" translate="yes" xml:space="preserve">
          <source>In most programs, the QDBusPendingCall class will not be used directly. It can be safely replaced with the template-based &lt;a href=&quot;qdbuspendingreply&quot;&gt;QDBusPendingReply&lt;/a&gt;, in order to access the contents of the reply or wait for it to be complete.</source>
          <target state="translated">在大多数程序中，不会直接使用QDBusPendingCall类。可以安全地将其替换为基于模板的&lt;a href=&quot;qdbuspendingreply&quot;&gt;QDBusPendingReply&lt;/a&gt;，以访问答复的内容或等待其完成。</target>
        </trans-unit>
        <trans-unit id="25ef42d72c72aebdfd6e5f25839b3db569e9d5ca" translate="yes" xml:space="preserve">
          <source>In most scenarios where a QML component wants the appearance of a synchronous instantiation, it should use this mode.</source>
          <target state="translated">在大多数情况下,如果一个QML组件希望出现一个同步实例化,它应该使用这种模式。</target>
        </trans-unit>
        <trans-unit id="3b6e9ee122d981f49721c96d6590322a10156a9b" translate="yes" xml:space="preserve">
          <source>In most script engines the only supported parameter type is &quot;const &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt;&amp;amp;&quot;, for example, to call a JavaScript function</source>
          <target state="translated">在大多数脚本引擎中，唯一受支持的参数类型是&amp;ldquo; const &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt;＆&amp;rdquo;，例如，以调用JavaScript函数</target>
        </trans-unit>
        <trans-unit id="b9b3ae5449e8c0871d12fd80aa098dc61f16fb2f" translate="yes" xml:space="preserve">
          <source>In most situations you'll want to specify the position yourself, for example, the current mouse position:</source>
          <target state="translated">在大多数情况下,你会希望自己指定位置,例如,当前的鼠标位置。</target>
        </trans-unit>
        <trans-unit id="10adffde2587482f7449d231df99d659614e6ea6" translate="yes" xml:space="preserve">
          <source>In most styles, Active and Inactive look the same.</source>
          <target state="translated">在大多数风格中,Active和Inactive看起来是一样的。</target>
        </trans-unit>
        <trans-unit id="3a627b1dad187b65f6e604a11cc750e597d9b793" translate="yes" xml:space="preserve">
          <source>In most subclasses, the number of columns is independent of the</source>
          <target state="translated">在大多数子类中,列的数量与</target>
        </trans-unit>
        <trans-unit id="6130a48c765ff0cdefaf8fdfe6cfc6cfe78961ca" translate="yes" xml:space="preserve">
          <source>In multi-window mode, you can arrange each of the tool windows to suit your working style. The main window consists of a menu bar, a tool bar, and a widget box that contains the widgets you can use to create your user interface.</source>
          <target state="translated">在多窗口模式下,您可以安排每个工具窗口以适应您的工作风格。主窗口由一个菜单栏、一个工具栏和一个小部件框组成,其中包含了您可以用来创建用户界面的小部件。</target>
        </trans-unit>
        <trans-unit id="136eb8f687bce846390884eaa3f58e0492d486f4" translate="yes" xml:space="preserve">
          <source>In multithreaded applications, implicit sharing takes place, as explained in &lt;a href=&quot;https://doc.qt.io/qt-5.13/threads-modules.html#threads-and-implicitly-shared-classes&quot;&gt;Threads and Implicitly Shared Classes&lt;/a&gt;.</source>
          <target state="translated">在多线程应用程序中，发生隐式共享，如&lt;a href=&quot;https://doc.qt.io/qt-5.13/threads-modules.html#threads-and-implicitly-shared-classes&quot;&gt;线程和隐式共享类中所述&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="933ee9e77d46ca8e86438896a8675d21f482a5d7" translate="yes" xml:space="preserve">
          <source>In multithreaded applications, implicit sharing takes place, as explained in &lt;a href=&quot;https://doc.qt.io/qt-5.15/threads-modules.html#threads-and-implicitly-shared-classes&quot;&gt;Threads and Implicitly Shared Classes&lt;/a&gt;.</source>
          <target state="translated">在多线程应用程序中，发生隐式共享，如&lt;a href=&quot;https://doc.qt.io/qt-5.15/threads-modules.html#threads-and-implicitly-shared-classes&quot;&gt;线程和隐式共享类中所述&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a760f55348be40c6a588b0b017e92233afca46cb" translate="yes" xml:space="preserve">
          <source>In multithreaded applications, implicit sharing takes place, as explained in &lt;a href=&quot;https://doc.qt.io/qt-6.0/threads-modules.html#threads-and-implicitly-shared-classes&quot;&gt;Threads and Implicitly Shared Classes&lt;/a&gt;.</source>
          <target state="translated">在多线程应用程序中，发生隐式共享，如&lt;a href=&quot;https://doc.qt.io/qt-6.0/threads-modules.html#threads-and-implicitly-shared-classes&quot;&gt;线程和隐式共享类中所述&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9dc95d48282ba6c9ac051d25113f7878c32facc8" translate="yes" xml:space="preserve">
          <source>In multithreaded applications, you can use &lt;a href=&quot;qtimer&quot;&gt;QTimer&lt;/a&gt; in any thread that has an event loop. To start an event loop from a non-GUI thread, use &lt;a href=&quot;qthread#exec&quot;&gt;QThread::exec&lt;/a&gt;(). Qt uses the timer's &lt;a href=&quot;qobject#thread&quot;&gt;thread affinity&lt;/a&gt; to determine which thread will emit the &lt;a href=&quot;qtimer#timeout&quot;&gt;timeout()&lt;/a&gt; signal. Because of this, you must start and stop the timer in its thread; it is not possible to start a timer from another thread.</source>
          <target state="translated">在多线程应用程序中，可以在具有事件循环的任何线程中使用&lt;a href=&quot;qtimer&quot;&gt;QTimer&lt;/a&gt;。要从非GUI线程启动事件循环，请使用&lt;a href=&quot;qthread#exec&quot;&gt;QThread :: exec&lt;/a&gt;（）。Qt使用计时器的&lt;a href=&quot;qobject#thread&quot;&gt;线程亲和力&lt;/a&gt;来确定哪个线程将发出&lt;a href=&quot;qtimer#timeout&quot;&gt;timeout（）&lt;/a&gt;信号。因此，您必须在其线程中启动和停止计时器。无法从另一个线程启动计时器。</target>
        </trans-unit>
        <trans-unit id="107ef5c0c80ad28ce250b248a591c1a309846695" translate="yes" xml:space="preserve">
          <source>In multithreaded applications, you can use QTimer in any thread that has an event loop. To start an event loop from a non-GUI thread, use &lt;a href=&quot;qthread#exec&quot;&gt;QThread::exec&lt;/a&gt;(). Qt uses the timer's &lt;a href=&quot;qobject#thread&quot;&gt;thread affinity&lt;/a&gt; to determine which thread will emit the &lt;a href=&quot;qtimer#timeout&quot;&gt;timeout()&lt;/a&gt; signal. Because of this, you must start and stop the timer in its thread; it is not possible to start a timer from another thread.</source>
          <target state="translated">在多线程应用程序中，可以在具有事件循环的任何线程中使用QTimer。要从非GUI线程启动事件循环，请使用&lt;a href=&quot;qthread#exec&quot;&gt;QThread :: exec&lt;/a&gt;（）。Qt使用计时器的&lt;a href=&quot;qobject#thread&quot;&gt;线程亲和力&lt;/a&gt;来确定哪个线程将发出&lt;a href=&quot;qtimer#timeout&quot;&gt;timeout（）&lt;/a&gt;信号。因此，您必须在其线程中启动和停止计时器。无法从另一个线程启动计时器。</target>
        </trans-unit>
        <trans-unit id="739ac81164da07ab48d8f4814e3fb516cf63658c" translate="yes" xml:space="preserve">
          <source>In multithreaded applications, you can use the timer mechanism in any thread that has an event loop. To start an event loop from a non-GUI thread, use &lt;a href=&quot;qthread#exec&quot;&gt;QThread::exec&lt;/a&gt;(). Qt uses the object's &lt;a href=&quot;qobject#thread&quot;&gt;thread affinity&lt;/a&gt; to determine which thread will deliver the &lt;a href=&quot;qtimerevent&quot;&gt;QTimerEvent&lt;/a&gt;. Because of this, you must start and stop all timers in the object's thread; it is not possible to start timers for objects in another thread.</source>
          <target state="translated">在多线程应用程序中，可以在具有事件循环的任何线程中使用计时器机制。要从非GUI线程启动事件循环，请使用&lt;a href=&quot;qthread#exec&quot;&gt;QThread :: exec&lt;/a&gt;（）。 Qt使用对象的&lt;a href=&quot;qobject#thread&quot;&gt;线程亲和力&lt;/a&gt;来确定哪个线程将传递&lt;a href=&quot;qtimerevent&quot;&gt;QTimerEvent&lt;/a&gt;。因此，您必须启动和停止对象线程中的所有计时器。无法为另一个线程中的对象启动计时器。</target>
        </trans-unit>
        <trans-unit id="3ca4c9a93301656b1f48a6a5915c6b74365aac4f" translate="yes" xml:space="preserve">
          <source>In object mode, select the object.</source>
          <target state="translated">在对象模式下,选择对象。</target>
        </trans-unit>
        <trans-unit id="45ba01ce603721c5c3cdfd5374b21039c18778de" translate="yes" xml:space="preserve">
          <source>In order for &lt;code&gt;find_package&lt;/code&gt; to be successful, Qt 5 must be found below the CMAKE_PREFIX_PATH, or the &lt;code&gt;Qt5_DIR&lt;/code&gt; must be set in the &lt;code&gt;CMake&lt;/code&gt; cache to the location of the &lt;code&gt;Qt5Config.cmake&lt;/code&gt; file. The easiest way to use &lt;code&gt;CMake&lt;/code&gt; is to set the CMAKE_PREFIX_PATH environment variable to the install prefix of Qt 5.</source>
          <target state="translated">为了使 &lt;code&gt;find_package&lt;/code&gt; 成功，必须在CMAKE_PREFIX_PATH下找到Qt 5，或者必须在 &lt;code&gt;CMake&lt;/code&gt; 缓存 &lt;code&gt;Qt5_DIR&lt;/code&gt; 设置为 &lt;code&gt;Qt5Config.cmake&lt;/code&gt; 文件的位置。使用 &lt;code&gt;CMake&lt;/code&gt; 的最简单方法是将CMAKE_PREFIX_PATH环境变量设置为Qt 5的安装前缀。</target>
        </trans-unit>
        <trans-unit id="273d0750c57092ee6ca57a6f1e9a7b1e391e9099" translate="yes" xml:space="preserve">
          <source>In order for Transition to correctly animate state changes, it is sometimes necessary for the engine to fast forward and rewind a state (that is, internally set and unset the state) before it is finally applied. The process is as follows:</source>
          <target state="translated">为了使Transition能够正确地对状态变化进行动画处理,有时需要引擎在最终应用前对一个状态进行快进和倒退(即内部设置和解除设置状态)。这个过程如下。</target>
        </trans-unit>
        <trans-unit id="9d29bc5512257f9d56906cc19a69d3155049a056" translate="yes" xml:space="preserve">
          <source>In order for plugins to work correctly on all platforms, you need to ensure that they export the symbols needed by</source>
          <target state="translated">为了让插件在所有平台上都能正常工作,您需要确保它们导出的符号由</target>
        </trans-unit>
        <trans-unit id="0a6f94686f76c9574e69b70f7c1db25e859ad3ce" translate="yes" xml:space="preserve">
          <source>In order for qmllint to work properly, it requires type information. That information is provided by qmltypes files. qmltypes files in the current directory, as well as those for Qt's built-in types, are discovered automatically. For qmltypes files from libraries that reside outside of the current directory, you can provide their path via the -I flag.</source>
          <target state="translated">为了让qmllint正常工作,它需要类型信息,这些信息由qmltypes文件提供。当前目录中的qmltypes文件以及Qt内置类型的文件会被自动发现。对于来自当前目录之外的库的qmltypes文件,你可以通过-I标志提供它们的路径。</target>
        </trans-unit>
        <trans-unit id="1d5d1e4bafd07a9fac3603a5110c7e5e85f15938" translate="yes" xml:space="preserve">
          <source>In order for the OpenCOLLADA exporter to be active, some options must be enabled or disabled in the &lt;code&gt;Plug-in Manager&lt;/code&gt;. To find it, go to &lt;b&gt;Window &amp;gt; Settings/Preferences &amp;gt; Plug-in Manager&lt;/b&gt;.</source>
          <target state="translated">为了使OpenCOLLADA导出器处于活动状态，必须在 &lt;code&gt;Plug-in Manager&lt;/code&gt; 启用或禁用某些选项。要找到它，请转到&lt;b&gt;窗口&amp;gt;设置/首选项&amp;gt;插件管理器&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="751af52cba3c3bdac047322a94b2f47a381b15c0" translate="yes" xml:space="preserve">
          <source>In order for the skeleton to have an effect, the model's &lt;a href=&quot;qml-qtquick3d-model#geometry-prop&quot;&gt;geometry&lt;/a&gt; needs to include skinning information. This is done by including &lt;a href=&quot;qquick3dgeometry#addAttribute&quot;&gt;vertex attributes&lt;/a&gt; with &lt;code&gt;JointSemantic&lt;/code&gt; and &lt;code&gt;WeightSemantic&lt;/code&gt; in the vertex buffer.</source>
          <target state="translated">为了使骨骼起作用，模型的&lt;a href=&quot;qml-qtquick3d-model#geometry-prop&quot;&gt;几何形状&lt;/a&gt;需要包含蒙皮信息。这是通过在顶点缓冲区中包含带有 &lt;code&gt;JointSemantic&lt;/code&gt; 和 &lt;code&gt;WeightSemantic&lt;/code&gt; 的&lt;a href=&quot;qquick3dgeometry#addAttribute&quot;&gt;顶点属性&lt;/a&gt;来完成的。</target>
        </trans-unit>
        <trans-unit id="10b438f20068ac31bda35998838ab5e66398e889" translate="yes" xml:space="preserve">
          <source>In order to &lt;a href=&quot;qremoteobjecthostbase#enableRemoting&quot;&gt;QRemoteObjectHost::enableRemoting&lt;/a&gt;() &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;Source&lt;/a&gt; objects over &lt;a href=&quot;qtremoteobjects-external-schemas#external-qiodevices&quot;&gt;External QIODevices&lt;/a&gt;, Qt Remote Objects needs access to the communications channel (a &lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt;) between the respective nodes. It is the addHostSideConnection() call that enables this on the &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;Source&lt;/a&gt; side, taking the</source>
          <target state="translated">为了通过&lt;a href=&quot;qtremoteobjects-external-schemas#external-qiodevices&quot;&gt;外部QIODevices&lt;/a&gt;通过&lt;a href=&quot;qremoteobjecthostbase#enableRemoting&quot;&gt;QRemoteObjectHost :: enableRemoting&lt;/a&gt;（）&lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;源&lt;/a&gt;对象，Qt远程对象需要访问各个节点之间的通信通道（&lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt;）。正是addHostSideConnection（）调用在&lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;源&lt;/a&gt;端启用了此功能，</target>
        </trans-unit>
        <trans-unit id="e9836ec8586dbb95dedd80563985226020c2de07" translate="yes" xml:space="preserve">
          <source>In order to &lt;a href=&quot;qremoteobjectnode#acquire&quot;&gt;QRemoteObjectNode::acquire&lt;/a&gt;() &lt;a href=&quot;qtremoteobjects-replica#replica&quot;&gt;Replica&lt;/a&gt; objects over &lt;a href=&quot;qtremoteobjects-external-schemas#external-qiodevices&quot;&gt;External QIODevices&lt;/a&gt;, Qt Remote Objects needs access to the communications channel (a &lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt;) between the respective nodes. It is the addClientSideConnection() call that enables this, taking the</source>
          <target state="translated">为了在&lt;a href=&quot;qtremoteobjects-external-schemas#external-qiodevices&quot;&gt;外部QIODevices上&lt;/a&gt;&lt;a href=&quot;qtremoteobjects-replica#replica&quot;&gt;复制&lt;/a&gt;&lt;a href=&quot;qremoteobjectnode#acquire&quot;&gt;QRemoteObjectNode :: acquire&lt;/a&gt;（）复制对象，Qt远程对象需要访问各个节点之间的通信通道（&lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt;）。启用此功能的是addClientSideConnection（）调用，</target>
        </trans-unit>
        <trans-unit id="30b280a0f639348b1558b91ca8e0cb63e767d4fa" translate="yes" xml:space="preserve">
          <source>In order to access in-app products from your application, you must register them in Google Play. Go to the &lt;b&gt;In-app products&lt;/b&gt; page and click &lt;b&gt;Add new product&lt;/b&gt;.</source>
          <target state="translated">为了从您的应用程序访问应用程序内产品，您必须在Google Play中注册它们。转到&lt;b&gt;应用内商品&lt;/b&gt;页面，然后点击&lt;b&gt;添加新产品&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="5233b82e07c82933175c5f09dfc4d0290b374f52" translate="yes" xml:space="preserve">
          <source>In order to access in-app products from your application, you must register them to the Windows Store. Go the the &lt;b&gt;IAPs&lt;/b&gt; page and click &lt;b&gt;Create a new IAP&lt;/b&gt;.</source>
          <target state="translated">为了从您的应用程序访问应用程序内产品，您必须将它们注册到Windows应用商店。转到&amp;ldquo; &lt;b&gt;IAP&amp;rdquo;&lt;/b&gt;页面，然后单击&amp;ldquo; &lt;b&gt;创建新IAP&amp;rdquo;&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="813cd9e0152da5629452ea757d91e732907fbf24" translate="yes" xml:space="preserve">
          <source>In order to accomplish cross-referencing, there needs to be a link between the original place and the favorited place and this is typically handled via an alternative identifier attribute. The favorited place contains an alternative identifier attribute which has the identifier of the original place.</source>
          <target state="translated">为了完成交叉引用,需要在原始地点和最喜欢的地点之间建立联系,这通常是通过一个替代标识符属性来处理。最喜欢的地方包含一个替代标识符属性,该属性具有原始地方的标识符。</target>
        </trans-unit>
        <trans-unit id="7654ffe5f59aa8b415f329e4d2a4f635740bcbc5" translate="yes" xml:space="preserve">
          <source>In order to accurately and quickly apply transformations and effects to items, Graphics View is built with the assumption that the user's hardware is able to provide reasonable performance for floating point instructions.</source>
          <target state="translated">为了准确、快速地将变换和效果应用到项目上,Graphics View的建立是以用户的硬件能够为浮点指令提供合理的性能为前提的。</target>
        </trans-unit>
        <trans-unit id="d107a525685e68af28a5e7ff750440b98cb5f4f7" translate="yes" xml:space="preserve">
          <source>In order to allow in-app purchases in your application, register the products in your application. Start by creating an application-global instance of &lt;a href=&quot;qinappstore&quot;&gt;QInAppStore&lt;/a&gt;, and use the registerProduct() function to register each product.</source>
          <target state="translated">为了允许在您的应用程序中进行应用内购买，请在您的应用程序中注册产品。首先创建&lt;a href=&quot;qinappstore&quot;&gt;QInAppStore&lt;/a&gt;的应用程序全局实例，然后使用registerProduct（）函数注册每个产品。</target>
        </trans-unit>
        <trans-unit id="606b2c3b73681df340c8c9cff026d4849c2c1a79" translate="yes" xml:space="preserve">
          <source>In order to allow shader code to be written once in Qt applications and libraries, all shaders are expected to be written in a single language which is then compiled into SPIR-V. This shanding language is Vulkan-compatible GLSL at the moment. This is different from the OpenGL-style GLSL Qt 5.x expects. See the &lt;a href=&quot;https://github.com/KhronosGroup/GLSL/blob/master/extensions/khr/GL_KHR_vulkan_glsl.txt&quot;&gt;GL_KHR_vulkan_glsl specification&lt;/a&gt; for an overview of the differences.</source>
          <target state="translated">为了允许在Qt应用程序和库中一次编写着色器代码，所有着色器均应以一种语言编写，然后将其编译为SPIR-V。目前，此尚定语言是Vulkan兼容的GLSL。这与OpenGL样式的GLSL Qt 5.x期望的有所不同。有关差异的概述，请参见&lt;a href=&quot;https://github.com/KhronosGroup/GLSL/blob/master/extensions/khr/GL_KHR_vulkan_glsl.txt&quot;&gt;GL_KHR_vulkan_glsl规范&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ac5886d32c751738229c75dd8e987ff557081068" translate="yes" xml:space="preserve">
          <source>In order to allow users to edit files with write permissions in a directory with restricted permissions, call setDirectWriteFallback() with</source>
          <target state="translated">为了允许用户在有限制权限的目录中编辑有写权限的文件,调用setDirectWriteFallback()与</target>
        </trans-unit>
        <trans-unit id="10a4870692521fed0a531ef8286ef53c637bbc59" translate="yes" xml:space="preserve">
          <source>In order to append without inserting a new paragraph, call &lt;code&gt;myTextEdit.insert(myTextEdit.length, text)&lt;/code&gt; instead.</source>
          <target state="translated">为了追加而不插入新的段落，请调用 &lt;code&gt;myTextEdit.insert(myTextEdit.length, text)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="27da4ea99eb2d7dbbc249d146c1f5ce076127b2c" translate="yes" xml:space="preserve">
          <source>In order to apply the values played back from the channels of data in the animation clip, the clip animator needs to have a &lt;a href=&quot;qt3danimation-qchannelmapper&quot;&gt;QChannelMapper&lt;/a&gt; object assigned to the &lt;a href=&quot;qt3danimation-qabstractclipanimator#channelMapper-prop&quot;&gt;channelMapper&lt;/a&gt; property.</source>
          <target state="translated">为了应用从动画剪辑中的数据通道播放的值，剪辑动画制作者需要将&lt;a href=&quot;qt3danimation-qchannelmapper&quot;&gt;QChannelMapper&lt;/a&gt;对象分配给&lt;a href=&quot;qt3danimation-qabstractclipanimator#channelMapper-prop&quot;&gt;channelMapper&lt;/a&gt;属性。</target>
        </trans-unit>
        <trans-unit id="1b5921d05daeea9767841f5911250cc0691d8e18" translate="yes" xml:space="preserve">
          <source>In order to apply the values played back from the channels of data in the animation clip, the clip animator needs to have a ChannelMapper object assigned to the channelMapper property.</source>
          <target state="translated">为了应用动画剪辑中数据通道播放的值,剪辑动画师需要有一个ChannelMapper对象分配给channelMapper属性。</target>
        </trans-unit>
        <trans-unit id="99b4d150c3515bcf7e23d650b6c2008ed79ae74e" translate="yes" xml:space="preserve">
          <source>In order to apply the values played back from the channels of data in the animation clip, the clip animator needs to have a QChannelMapper object assigned to the &lt;a href=&quot;qt3danimation-qabstractclipanimator#channelMapper-prop&quot;&gt;channelMapper&lt;/a&gt; property.</source>
          <target state="translated">为了应用从动画剪辑中的数据通道回放的值，剪辑动画制作者需要将QChannelMapper对象分配给&lt;a href=&quot;qt3danimation-qabstractclipanimator#channelMapper-prop&quot;&gt;channelMapper&lt;/a&gt;属性。</target>
        </trans-unit>
        <trans-unit id="9eedf5f587698ff08fe02d8f6da9afd8ec0c528d" translate="yes" xml:space="preserve">
          <source>In order to avoid confusion, do not put two groups of radio buttons next to each other.</source>
          <target state="translated">为了避免混淆,不要把两组单选按钮挨在一起。</target>
        </trans-unit>
        <trans-unit id="e6b2394d0e8025876c5e81fb5fca85edcc30d366" translate="yes" xml:space="preserve">
          <source>In order to avoid this worst-case behavior, the calculation of the hash value done by &lt;a href=&quot;qhash#qHashx&quot;&gt;qHash&lt;/a&gt;() can be salted by a random seed, that nullifies the attack's extent. This seed is automatically generated by &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt; once per process, and then passed by &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt; as the second argument of the two-arguments overload of the &lt;a href=&quot;qhash#qHashx&quot;&gt;qHash&lt;/a&gt;() function.</source>
          <target state="translated">为了避免这种最坏情况的行为，可以通过随机种子对&lt;a href=&quot;qhash#qHashx&quot;&gt;qHash&lt;/a&gt;（）进行的哈希值计算进行计算，这会使攻击的范围无效。该种子由&lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt;每个进程自动生成一次，然后由&lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt;传递，作为&lt;a href=&quot;qhash#qHashx&quot;&gt;qHash&lt;/a&gt;（）函数的两个参数重载的第二个参数。</target>
        </trans-unit>
        <trans-unit id="926d3cee39fbe558fdc2230dc61692b10c1a5409" translate="yes" xml:space="preserve">
          <source>In order to avoid this worst-case behavior, the calculation of the hash value done by &lt;a href=&quot;qhash#qHashx&quot;&gt;qHash&lt;/a&gt;() can be salted by a random seed, that nullifies the attack's extent. This seed is automatically generated by QHash once per process, and then passed by QHash as the second argument of the two-arguments overload of the &lt;a href=&quot;qhash#qHashx&quot;&gt;qHash&lt;/a&gt;() function.</source>
          <target state="translated">为了避免出现这种最坏情况的行为，可以使用随机种子对&lt;a href=&quot;qhash#qHashx&quot;&gt;qHash&lt;/a&gt;（）完成的哈希值的计算进行加盐处理，从而使攻击的范围无效。该种子由QHash在每个进程中自动生成一次，然后由QHash作为&lt;a href=&quot;qhash#qHashx&quot;&gt;qHash&lt;/a&gt;（）函数的两个参数重载的第二个参数传递。</target>
        </trans-unit>
        <trans-unit id="bfa17f101dcbd4e9710c799e2b5dc56691a4bdba" translate="yes" xml:space="preserve">
          <source>In order to be able to handle relative paths, this method takes an optional</source>
          <target state="translated">为了能够处理相对路径,本方法取一个可选的</target>
        </trans-unit>
        <trans-unit id="cd4ac30d665c227ccd3175246c4999850e299e04" translate="yes" xml:space="preserve">
          <source>In order to be considered &quot;canonical&quot;, a CBOR stream must meet the following requirements:</source>
          <target state="translated">为了被视为 &quot;规范&quot;,CBOR流必须满足以下要求:</target>
        </trans-unit>
        <trans-unit id="a8773022e28cbabc01911661d6e667737b76af71" translate="yes" xml:space="preserve">
          <source>In order to behave asynchronously and not introduce stutters or freezes in an application, the process of creating objects a QQmlIncubators must be driven only during the application's idle time. &lt;a href=&quot;qqmlincubationcontroller&quot;&gt;QQmlIncubationController&lt;/a&gt; allows the application to control exactly when, how often and for how long this processing occurs.</source>
          <target state="translated">为了异步行为并且不会在应用程序中造成卡顿或停滞，必须仅在应用程序的空闲时间内驱动创建QQmlIncubator的对象的过程。&lt;a href=&quot;qqmlincubationcontroller&quot;&gt;QQmlIncubationController&lt;/a&gt;允许应用程序精确控制此处理的时间，频率和持续时间。</target>
        </trans-unit>
        <trans-unit id="4392c01d24cac5c444f4f852a738c8c60c7e6bcc" translate="yes" xml:space="preserve">
          <source>In order to behave asynchronously and not introduce stutters or freezes in an application, the process of creating objects a QQmlIncubators must be driven only during the application's idle time. QQmlIncubationController allows the application to control exactly when, how often and for how long this processing occurs.</source>
          <target state="translated">为了在应用程序中表现得异步,不引入停顿或冻结,创建对象的过程一个QQmlIncubators必须只在应用程序的空闲时间驱动。QQmlIncubationController允许应用程序确切地控制这种处理发生的时间、频率和时间。</target>
        </trans-unit>
        <trans-unit id="eab7a0bf94f2e52c8b8a60bc41a1dab7327116a0" translate="yes" xml:space="preserve">
          <source>In order to cause the window to be centered above its transient</source>
          <target state="translated">为了使窗口的中心位置高于其瞬时的位置。</target>
        </trans-unit>
        <trans-unit id="cbca8baadc999b96b836a9b38d1b87445b3753f6" translate="yes" xml:space="preserve">
          <source>In order to cause the window to be centered above its transient parent by default, depending on the window manager, it may also be necessary to set the &lt;a href=&quot;qml-qtquick-window-window#flags-prop&quot;&gt;Window::flags&lt;/a&gt; property with a suitable &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt::WindowType&lt;/a&gt; (such as &lt;code&gt;Qt::Dialog&lt;/code&gt;).</source>
          <target state="translated">为了使窗口默认情况下在其临时父窗口上方居中，这取决于窗口管理器，还可能需要使用合适的&lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt :: WindowType&lt;/a&gt;（例如 &lt;code&gt;Qt::Dialog&lt;/code&gt; ）设置&lt;a href=&quot;qml-qtquick-window-window#flags-prop&quot;&gt;Window :: flags&lt;/a&gt;属性。。</target>
        </trans-unit>
        <trans-unit id="6ead02df7a2891508aad6cc1deb3cb1f3b8e3594" translate="yes" xml:space="preserve">
          <source>In order to cause the window to be centered above its transient parent by default, depending on the window manager, it may also be necessary to set the &lt;a href=&quot;qml-window#flags-prop&quot;&gt;Window::flags&lt;/a&gt; property with a suitable &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt::WindowType&lt;/a&gt; (such as &lt;code&gt;Qt::Dialog&lt;/code&gt;).</source>
          <target state="translated">为了使窗口默认情况下位于其临时父窗口上方，根据窗口管理器的不同，可能还需要使用适当的&lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt :: WindowType&lt;/a&gt;（例如 &lt;code&gt;Qt::Dialog&lt;/code&gt; ）设置&lt;a href=&quot;qml-window#flags-prop&quot;&gt;Window :: flags&lt;/a&gt;属性。。</target>
        </trans-unit>
        <trans-unit id="a52ec2b4f643adf51bba1888c621570cd78b8728" translate="yes" xml:space="preserve">
          <source>In order to cause the window to be centered above its transient parent by default, depending on the window manager, it may also be necessary to set the &lt;a href=&quot;qwindow#flags-prop&quot;&gt;flags&lt;/a&gt; property with a suitable &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt::WindowType&lt;/a&gt; (such as &lt;code&gt;Qt::Dialog&lt;/code&gt;).</source>
          <target state="translated">为了使窗口默认情况下位于其临时父窗口上方，根据窗口管理器的不同，可能还需要使用适当的&lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt :: WindowType&lt;/a&gt;（例如 &lt;code&gt;Qt::Dialog&lt;/code&gt; ）设置&lt;a href=&quot;qwindow#flags-prop&quot;&gt;flags&lt;/a&gt;属性。</target>
        </trans-unit>
        <trans-unit id="07ac98914dfe8f4e4136c600d1f65ff9c9cfe3e2" translate="yes" xml:space="preserve">
          <source>In order to conform to C/C++ naming conventions &quot;Dir&quot; is prepended to the codes used in the Unicode Standard.</source>
          <target state="translated">为了符合C/C++的命名惯例,在Unicode标准中使用的代码前加上了 &quot;Dir&quot;。</target>
        </trans-unit>
        <trans-unit id="9e1e682d0fc9b26f29b52c7416d19029656145ab" translate="yes" xml:space="preserve">
          <source>In order to conform to C/C++ naming conventions &quot;Joining_&quot; is prepended to the codes used in the Unicode Standard.</source>
          <target state="translated">为了符合C/C++的命名惯例,在Unicode标准中使用的代码前加上了 &quot;Joining_&quot;。</target>
        </trans-unit>
        <trans-unit id="eb270840e76faff8640691680236b1a394ebf5dd" translate="yes" xml:space="preserve">
          <source>In order to conform to C/C++ naming conventions &quot;Script_&quot; is prepended to the codes used in the Unicode Standard.</source>
          <target state="translated">为了符合C/C++的命名惯例,在Unicode标准中使用的代码前加上了 &quot;Script_&quot;。</target>
        </trans-unit>
        <trans-unit id="9af9f0c87800086847f3e1f36a0a32ac193b32fa" translate="yes" xml:space="preserve">
          <source>In order to construct a correctly functioning framegraph tree, you should know a few rules about how it is traversed and how to feed it to the Qt 3D renderer.</source>
          <target state="translated">为了构建一个正确运行的框架图树,你应该知道一些关于如何遍历框架图树以及如何将其馈送到Qt 3D渲染器的规则。</target>
        </trans-unit>
        <trans-unit id="f18ba4a788703fe91904fb4d556a9b828358a7a0" translate="yes" xml:space="preserve">
          <source>In order to customize an existing style, inherit &lt;a href=&quot;qproxystyle&quot;&gt;QProxyStyle&lt;/a&gt; and reimplement the desired virtual methods. &lt;a href=&quot;qproxystyle&quot;&gt;QProxyStyle&lt;/a&gt; allows one to specify a certain base style, or it will automatically use the application style when the base style is left unspecified. The former gives a full control on the base style and works best if the customization expects a certain style behavior, whereas the latter provides a platform agnostic way to customize the application style that defaults to the native platform style.</source>
          <target state="translated">为了自定义现有样式，请继承&lt;a href=&quot;qproxystyle&quot;&gt;QProxyStyle&lt;/a&gt;并重新实现所需的虚拟方法。&lt;a href=&quot;qproxystyle&quot;&gt;QProxyStyle&lt;/a&gt;允许您指定某种基本样式，或者当未指定基本样式时，它将自动使用应用程序样式。前者可以完全控制基本样式，如果自定义期望某种样式行为，则效果最好，而后者则提供了一种平台不可知的方式来自定义默认为本机平台样式的应用程序样式。</target>
        </trans-unit>
        <trans-unit id="7b8e427a12f9166e734e17315c12bed4668cff8d" translate="yes" xml:space="preserve">
          <source>In order to determine what options an image handler supports, Qt will call &lt;a href=&quot;qimageiohandler#supportsOption&quot;&gt;supportsOption&lt;/a&gt;() and &lt;a href=&quot;qimageiohandler#setOption&quot;&gt;setOption&lt;/a&gt;(). Make sure to reimplement these functions if you can provide support for any of the options in the &lt;a href=&quot;qimageiohandler#ImageOption-enum&quot;&gt;ImageOption&lt;/a&gt; enum.</source>
          <target state="translated">为了确定图像处理程序支持哪些选项，Qt将调用&lt;a href=&quot;qimageiohandler#supportsOption&quot;&gt;supportsOption&lt;/a&gt;（）和&lt;a href=&quot;qimageiohandler#setOption&quot;&gt;setOption&lt;/a&gt;（）。如果可以为&lt;a href=&quot;qimageiohandler#ImageOption-enum&quot;&gt;ImageOption&lt;/a&gt;枚举中的任何选项提供支持，请确保重新实现这些功能。</target>
        </trans-unit>
        <trans-unit id="4cfe698a4ad29b789ea1afc2062ba97f1174b270" translate="yes" xml:space="preserve">
          <source>In order to do so, you can create a &lt;a href=&quot;qopengldebugmessage&quot;&gt;QOpenGLDebugMessage&lt;/a&gt; object by calling &lt;a href=&quot;qopengldebugmessage#createApplicationMessage&quot;&gt;createApplicationMessage()&lt;/a&gt; or &lt;a href=&quot;qopengldebugmessage#createThirdPartyMessage&quot;&gt;createThirdPartyMessage()&lt;/a&gt;, and then inserting it into the log by calling &lt;a href=&quot;qopengldebuglogger#logMessage&quot;&gt;logMessage&lt;/a&gt;():</source>
          <target state="translated">为此，您可以通过调用&lt;a href=&quot;qopengldebugmessage#createApplicationMessage&quot;&gt;createApplicationMessage（）&lt;/a&gt;或&lt;a href=&quot;qopengldebugmessage#createThirdPartyMessage&quot;&gt;createThirdPartyMessage（）&lt;/a&gt;创建一个&lt;a href=&quot;qopengldebugmessage&quot;&gt;QOpenGLDebugMessage&lt;/a&gt;对象，然后通过调用&lt;a href=&quot;qopengldebuglogger#logMessage&quot;&gt;logMessage&lt;/a&gt;（）将其插入日志中：</target>
        </trans-unit>
        <trans-unit id="f758463f5cdf5461c20dde0c0676e9f09517772c" translate="yes" xml:space="preserve">
          <source>In order to draw one element from a model, a view (through its delegates) will generally request multiple roles for the same index by calling &lt;code&gt;data()&lt;/code&gt; as many times as needed:</source>
          <target state="translated">为了从模型中绘制一个元素，一个视图（通过其委托）通常会通过根据需要多次调用 &lt;code&gt;data()&lt;/code&gt; 来请求同一索引的多个角色：</target>
        </trans-unit>
        <trans-unit id="3332997d32b1ce89721edcd4aeaeb1d3f5900b42" translate="yes" xml:space="preserve">
          <source>In order to ensure drag operations work properly, it is important to reimplement the following functions that remove data from the model:</source>
          <target state="translated">为了确保拖动操作正常工作,必须重新实现以下从模型中删除数据的函数。</target>
        </trans-unit>
        <trans-unit id="c171a6fd49179a1e32af671ec262c87073e91ab4" translate="yes" xml:space="preserve">
          <source>In order to ensure that a popup is displayed above other items in the scene, it is recommended to use &lt;a href=&quot;qml-qtquick-controls2-applicationwindow&quot;&gt;ApplicationWindow&lt;/a&gt;. &lt;a href=&quot;qml-qtquick-controls2-applicationwindow&quot;&gt;ApplicationWindow&lt;/a&gt; also provides background dimming effects.</source>
          <target state="translated">为了确保在场景中其他项目上方显示弹出窗口，建议使用&lt;a href=&quot;qml-qtquick-controls2-applicationwindow&quot;&gt;ApplicationWindow&lt;/a&gt;。&lt;a href=&quot;qml-qtquick-controls2-applicationwindow&quot;&gt;ApplicationWindow&lt;/a&gt;还提供背景调光效果。</target>
        </trans-unit>
        <trans-unit id="1746cfd97b27b008e9ba50f3292417b2a2315d6e" translate="yes" xml:space="preserve">
          <source>In order to ensure that a popup is displayed above other items in the scene, it is recommended to use &lt;a href=&quot;qtquickcontrols-changes-qt6#applicationwindow&quot;&gt;ApplicationWindow&lt;/a&gt;. &lt;a href=&quot;qtquickcontrols-changes-qt6#applicationwindow&quot;&gt;ApplicationWindow&lt;/a&gt; also provides background dimming effects.</source>
          <target state="translated">为了确保在场景中其他项目上方显示弹出窗口，建议使用&lt;a href=&quot;qtquickcontrols-changes-qt6#applicationwindow&quot;&gt;ApplicationWindow&lt;/a&gt;。&lt;a href=&quot;qtquickcontrols-changes-qt6#applicationwindow&quot;&gt;ApplicationWindow&lt;/a&gt;还提供背景调光效果。</target>
        </trans-unit>
        <trans-unit id="9ff3f293b7985b97460b900c816c723e46801887" translate="yes" xml:space="preserve">
          <source>In order to export as FBX, you must have the FBX export add-on installed and enabled in Blender. With the default installation of Blender, the &lt;code&gt;Import-Export: FBX format&lt;/code&gt; should be installed. If you do not have the option to export as FBX avaialble, ensure that the add-on is enabled by following the steps:</source>
          <target state="translated">为了导出为FBX，必须在Blender中安装并启用FBX导出附加组件。对于Blender的默认安装，应安装 &lt;code&gt;Import-Export: FBX format&lt;/code&gt; 。如果您没有导出为FBX可用选项，请按照以下步骤确保启用了加载项：</target>
        </trans-unit>
        <trans-unit id="dbbcaa1b4c6c581f9b2c0adf80607868930c75d7" translate="yes" xml:space="preserve">
          <source>In order to facilitate verification of the most common D-Bus errors generated by the D-Bus implementation and by the bus daemon itself, &lt;a href=&quot;qdbuserror&quot;&gt;QDBusError&lt;/a&gt; can be compared to a set of pre-defined values:</source>
          <target state="translated">为了便于验证由D-Bus实现和总线守护程序本身生成的最常见D-Bus错误，可以将&lt;a href=&quot;qdbuserror&quot;&gt;QDBusError&lt;/a&gt;与一组预定义值进行比较：</target>
        </trans-unit>
        <trans-unit id="bf5422c9a0bf4e432d87ea7ba1d07e96bffd9fbe" translate="yes" xml:space="preserve">
          <source>In order to generate such messages, you need to enable the informational output for the &lt;code&gt;qt.qml.binding.removal&lt;/code&gt; logging category, for instance by calling:</source>
          <target state="translated">为了生成此类消息，您需要启用 &lt;code&gt;qt.qml.binding.removal&lt;/code&gt; 日志记录类别的信息输出，例如，通过调用以下命令：</target>
        </trans-unit>
        <trans-unit id="b0e18dd8d9382b9e4ab6eff01b7ac89dd4470580" translate="yes" xml:space="preserve">
          <source>In order to get an application designed for low DPI values running on a high resolution monitors quickly, consider one of the scaling options (let the application run as</source>
          <target state="translated">为了让一个为低DPI值设计的应用程序在高分辨率显示器上快速运行,可以考虑其中一个缩放选项(让应用程序以</target>
        </trans-unit>
        <trans-unit id="05788d09e0bce3911756b506eda62412477e1884" translate="yes" xml:space="preserve">
          <source>In order to help applications migrate from OpenGL-based code without having to flip Y coordinates in the vertex data, and to allow using &lt;a href=&quot;qmatrix4x4&quot;&gt;QMatrix4x4&lt;/a&gt; functions like &lt;a href=&quot;qmatrix4x4#perspective&quot;&gt;QMatrix4x4::perspective&lt;/a&gt;() while keeping the Vulkan viewport's minDepth and maxDepth set to 0 and 1, &lt;a href=&quot;qvulkanwindow&quot;&gt;QVulkanWindow&lt;/a&gt; provides a correction matrix retrievable by calling &lt;a href=&quot;qvulkanwindow#clipCorrectionMatrix&quot;&gt;clipCorrectionMatrix&lt;/a&gt;().</source>
          <target state="translated">为了帮助应用程序从基于OpenGL的代码迁移而不必翻转顶点数据中的Y坐标，并允许使用&lt;a href=&quot;qmatrix4x4&quot;&gt;QMatrix4x4&lt;/a&gt;函数，例如&lt;a href=&quot;qmatrix4x4#perspective&quot;&gt;QMatrix4x4 :: perspective&lt;/a&gt;（），同时将Vulkan视口的minDepth和maxDepth设置为0和1，&lt;a href=&quot;qvulkanwindow&quot;&gt;QVulkanWindow&lt;/a&gt;通过调用&lt;a href=&quot;qvulkanwindow#clipCorrectionMatrix&quot;&gt;clipCorrectionMatrix&lt;/a&gt;（）提供可检索的校正矩阵。</target>
        </trans-unit>
        <trans-unit id="c89b568ea317b80810ac6ef26edda8cf60b1bc7d" translate="yes" xml:space="preserve">
          <source>In order to help applications migrate from OpenGL-based code without having to flip Y coordinates in the vertex data, and to allow using &lt;a href=&quot;qmatrix4x4&quot;&gt;QMatrix4x4&lt;/a&gt; functions like &lt;a href=&quot;qmatrix4x4#perspective&quot;&gt;QMatrix4x4::perspective&lt;/a&gt;() while keeping the Vulkan viewport's minDepth and maxDepth set to 0 and 1, QVulkanWindow provides a correction matrix retrievable by calling &lt;a href=&quot;qvulkanwindow#clipCorrectionMatrix&quot;&gt;clipCorrectionMatrix&lt;/a&gt;().</source>
          <target state="translated">为了帮助应用程序从基于OpenGL的代码迁移而不必翻转顶点数据中的Y坐标，并允许使用&lt;a href=&quot;qmatrix4x4&quot;&gt;QMatrix4x4&lt;/a&gt;函数，例如&lt;a href=&quot;qmatrix4x4#perspective&quot;&gt;QMatrix4x4 :: perspective&lt;/a&gt;（），同时将Vulkan视口的minDepth和maxDepth设置为0和1，QVulkanWindow通过调用&lt;a href=&quot;qvulkanwindow#clipCorrectionMatrix&quot;&gt;clipCorrectionMatrix&lt;/a&gt;（）提供可检索的校正矩阵。</target>
        </trans-unit>
        <trans-unit id="352f9d1daa19e27628f8adbbf3e6bb3b572f385a" translate="yes" xml:space="preserve">
          <source>In order to improve rendering performance, objects that are very small can be rendered using far fewer details, in geometry or texture.</source>
          <target state="translated">为了提高渲染性能,可以使用更少的几何或纹理细节来渲染非常小的物体。</target>
        </trans-unit>
        <trans-unit id="adf46a9b2ab0abcc4529b05d713981200646ea92" translate="yes" xml:space="preserve">
          <source>In order to invoke the action, &lt;a href=&quot;qaccessibleactioninterface#doAction&quot;&gt;doAction&lt;/a&gt;() is called with an action name.</source>
          <target state="translated">为了调用该动作，使用动作名称调用&lt;a href=&quot;qaccessibleactioninterface#doAction&quot;&gt;doAction&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="30c723dfd3494d19b1d8256d9a098a1871b1c594" translate="yes" xml:space="preserve">
          <source>In order to make it possible for Qt Quick Controls 2 to find the configuration file, it must be built into application's resources using the &lt;a href=&quot;resources&quot;&gt;The Qt Resource System&lt;/a&gt;. Here's an example &lt;code&gt;.qrc&lt;/code&gt; file:</source>
          <target state="translated">为了使Qt Quick Controls 2能够找到配置文件，必须使用&lt;a href=&quot;resources&quot;&gt;The Qt Resource System&lt;/a&gt;将其内置到应用程序的资源中。这是一个示例 &lt;code&gt;.qrc&lt;/code&gt; 文件：</target>
        </trans-unit>
        <trans-unit id="109fc8f4542a13adb137e40f040addcd8fe17f42" translate="yes" xml:space="preserve">
          <source>In order to make it possible for Qt Quick Controls to find the configuration file, it must be built into application's resources using the &lt;a href=&quot;resources&quot;&gt;The Qt Resource System&lt;/a&gt;. Here's an example &lt;code&gt;.qrc&lt;/code&gt; file:</source>
          <target state="translated">为了使Qt Quick Controls能够找到配置文件，必须使用&lt;a href=&quot;resources&quot;&gt;The Qt Resource System&lt;/a&gt;将其内置到应用程序的资源中。这是一个示例 &lt;code&gt;.qrc&lt;/code&gt; 文件：</target>
        </trans-unit>
        <trans-unit id="c293186fef6700bd78044fbc053ecf384b85c4d2" translate="yes" xml:space="preserve">
          <source>In order to modify your dialog's close behavior, you can reimplement the functions &lt;a href=&quot;qdialog#accept&quot;&gt;accept&lt;/a&gt;(), &lt;a href=&quot;qdialog#reject&quot;&gt;reject&lt;/a&gt;() or &lt;a href=&quot;qdialog#done&quot;&gt;done&lt;/a&gt;(). The &lt;a href=&quot;qwidget#closeEvent&quot;&gt;closeEvent()&lt;/a&gt; function should only be reimplemented to preserve the dialog's position or to override the standard close or reject behavior.</source>
          <target state="translated">为了修改对话框的关闭行为，您可以重新实现功能&lt;a href=&quot;qdialog#accept&quot;&gt;accept&lt;/a&gt;（），&lt;a href=&quot;qdialog#reject&quot;&gt;reject&lt;/a&gt;（）或&lt;a href=&quot;qdialog#done&quot;&gt;done&lt;/a&gt;（）。该&lt;a href=&quot;qwidget#closeEvent&quot;&gt;的closeEvent（）&lt;/a&gt;函数只应重新实现保存对话框的位置或覆盖标准接近或拒绝的行为。</target>
        </trans-unit>
        <trans-unit id="595db3f0857c6c9533d3516b74fb18708745016c" translate="yes" xml:space="preserve">
          <source>In order to only set a mouse cursor shape for a region without reacting to mouse events set the &lt;a href=&quot;qml-qtquick-mousearea#acceptedButtons-prop&quot;&gt;acceptedButtons&lt;/a&gt; to none:</source>
          <target state="translated">为了只为区域设置鼠标光标形状而不对鼠标事件做出反应，请将&lt;a href=&quot;qml-qtquick-mousearea#acceptedButtons-prop&quot;&gt;acceptedButtons&lt;/a&gt;设置为none：</target>
        </trans-unit>
        <trans-unit id="ed7e7f5f7cec0ce5fe90c693f441ab5123bc40f8" translate="yes" xml:space="preserve">
          <source>In order to parse standalone documents that do use undeclared namespace prefixes, you can turn off namespace processing completely with the &lt;a href=&quot;qxmlstreamreader#namespaceProcessing-prop&quot;&gt;namespaceProcessing&lt;/a&gt; property.</source>
          <target state="translated">为了解析使用未声明的名称空间前缀的独立文档，您可以使用&lt;a href=&quot;qxmlstreamreader#namespaceProcessing-prop&quot;&gt;namespaceProcessing&lt;/a&gt;属性完全关闭名称空间处理。</target>
        </trans-unit>
        <trans-unit id="22488f2fb9bc31cc03c8ffece771f6c5dad33dea" translate="yes" xml:space="preserve">
          <source>In order to perform a match you can simply invoke the &lt;a href=&quot;qregularexpression#match&quot;&gt;match&lt;/a&gt;() function passing a string to match against. We refer to this string as the</source>
          <target state="translated">为了执行匹配，您可以简单地调用&lt;a href=&quot;qregularexpression#match&quot;&gt;match&lt;/a&gt;（）函数，并传递一个字符串进行匹配。我们将此字符串称为</target>
        </trans-unit>
        <trans-unit id="27d9746de5d1bd667c997070120c7089cb319c69" translate="yes" xml:space="preserve">
          <source>In order to perform a search operation we simply create a &lt;a href=&quot;qplacesearchrequest&quot;&gt;QPlaceSearchRequest&lt;/a&gt; and set the desired search parameters, such as a search term and search center.</source>
          <target state="translated">为了执行搜索操作，我们只需创建一个&lt;a href=&quot;qplacesearchrequest&quot;&gt;QPlaceSearchRequest&lt;/a&gt;并设置所需的搜索参数，例如搜索词和搜索中心。</target>
        </trans-unit>
        <trans-unit id="990dae2ac10c8c0c0c07be8097513e57dbe9f673" translate="yes" xml:space="preserve">
          <source>In order to perform an action when the value for a particular handle changes, use the following syntax:</source>
          <target state="translated">为了在特定句柄的值发生变化时执行操作,使用以下语法。</target>
        </trans-unit>
        <trans-unit id="9d8cc764d2636377c9d350844454983b703891c4" translate="yes" xml:space="preserve">
          <source>In order to perform the matching, we create a &lt;a href=&quot;qplacematchrequest&quot;&gt;QPlaceMatchRequest&lt;/a&gt; and assign it the search results from the origin manager. The &lt;a href=&quot;qplacematchrequest&quot;&gt;QPlaceMatchRequest&lt;/a&gt; will be used on the destination manager to return corresponding places. We also specify matching parameters which are key value pairs. As mentioned previously, this can vary depending on the manager but typically the key is &lt;a href=&quot;qplacematchrequest#AlternativeId-var&quot;&gt;QPlaceMatchRequest::AlternativeId&lt;/a&gt; to indicate we are matching by alternative id, the value in this case would be x_id_here which specifies which alternative identifier attribute we are using to do the matching.</source>
          <target state="translated">为了执行匹配，我们创建了一个&lt;a href=&quot;qplacematchrequest&quot;&gt;QPlaceMatchRequest&lt;/a&gt;并将其从源管理器中分配给搜索结果。该&lt;a href=&quot;qplacematchrequest&quot;&gt;QPlaceMatchRequest&lt;/a&gt;将在目的地管理器用来返回相应的地方。我们还指定匹配参数，它们是键值对。如前所述，这可能会因管理者而异，但通常，键为&lt;a href=&quot;qplacematchrequest#AlternativeId-var&quot;&gt;QPlaceMatchRequest :: AlternativeId&lt;/a&gt;表示我们正在按备用ID进行匹配，在这种情况下，值为x_id_here，它指定了我们用于进行匹配的备用标识符属性。</target>
        </trans-unit>
        <trans-unit id="a6dbd5164517c2126a3c5d4152236f8f3118599e" translate="yes" xml:space="preserve">
          <source>In order to preserve the trust of users, QML application developers should not load and execute arbitrary JavaScript or QML resources. For example, consider the QML code below:</source>
          <target state="translated">为了维护用户的信任,QML应用开发者不应该加载和执行任意的JavaScript或QML资源。例如,考虑下面的QML代码。</target>
        </trans-unit>
        <trans-unit id="b6e99a203dfdb0f33a5655989b6755ddb0403b5a" translate="yes" xml:space="preserve">
          <source>In order to preserve the trust of users, application developers should not evaluate arbitrary JavaScript code. The JavaScript engine's sandbox is only a semantic barrier. The script is evaluated in the same process and with the same privileges as the rest of the application and shares the same memory. As a consequence, C++ objects exposed to scripts are accessible without additional security guards.</source>
          <target state="translated">为了维护用户的信任,应用开发者不应该评估任意的JavaScript代码。JavaScript引擎的沙箱只是一个语义上的障碍。脚本与应用程序的其他部分在同一进程中以相同的权限进行评估,并共享相同的内存。因此,暴露在脚本中的C++对象无需额外的安全防护就可以访问。</target>
        </trans-unit>
        <trans-unit id="762fba914ff16b1c9d3cb7722b8c65aee3c0b035" translate="yes" xml:space="preserve">
          <source>In order to purchase a product, call the object's purchase() method. This launches a platform-specific, asynchronous process to purchase the product, for example by requesting the user's password and confirmation of the purchase. In most cases, you should make sure that the application UI is not accepting input while the purchasing request is being processed, as this is not handled automatically on all platforms.</source>
          <target state="translated">为了购买产品,调用对象的purchase()方法。这将启动一个特定于平台的异步进程来购买产品,例如,通过请求用户的密码和确认购买。在大多数情况下,您应该确保在处理购买请求时,应用程序UI不接受输入,因为这不是在所有平台上自动处理的。</target>
        </trans-unit>
        <trans-unit id="58771b56f861325466bbe8868ec03f5ee285687e" translate="yes" xml:space="preserve">
          <source>In order to receive mouse movement events, the preceding mouse press event must be accepted (by overriding &lt;a href=&quot;qquickitem#mousePressEvent&quot;&gt;mousePressEvent&lt;/a&gt;(), for example) and &lt;a href=&quot;qquickitem#acceptedMouseButtons&quot;&gt;acceptedMouseButtons&lt;/a&gt;() must return the relevant mouse button.</source>
          <target state="translated">为了接收鼠标移动事件，必须接受前面的鼠标按下事件（例如，通过重写&lt;a href=&quot;qquickitem#mousePressEvent&quot;&gt;mousePressEvent&lt;/a&gt;（）），并且&lt;a href=&quot;qquickitem#acceptedMouseButtons&quot;&gt;acceptedMouseButtons&lt;/a&gt;（）必须返回相关的鼠标按钮。</target>
        </trans-unit>
        <trans-unit id="944d91ab59ba82d14656dded84e0977b699fdac1" translate="yes" xml:space="preserve">
          <source>In order to receive mouse press events, &lt;a href=&quot;qquickitem#acceptedMouseButtons&quot;&gt;acceptedMouseButtons&lt;/a&gt;() must return the relevant mouse button.</source>
          <target state="translated">为了接收鼠标按下事件，&lt;a href=&quot;qquickitem#acceptedMouseButtons&quot;&gt;acceptedMouseButtons&lt;/a&gt;（）必须返回相关的鼠标按钮。</target>
        </trans-unit>
        <trans-unit id="034f4e178ca638e5d3b47e5344b72326da0c9d38" translate="yes" xml:space="preserve">
          <source>In order to receive mouse release events, the preceding mouse press event must be accepted (by overriding &lt;a href=&quot;qquickitem#mousePressEvent&quot;&gt;mousePressEvent&lt;/a&gt;(), for example) and &lt;a href=&quot;qquickitem#acceptedMouseButtons&quot;&gt;acceptedMouseButtons&lt;/a&gt;() must return the relevant mouse button.</source>
          <target state="translated">为了接收鼠标释放事件，必须接受前面的鼠标按下事件（例如，通过重写&lt;a href=&quot;qquickitem#mousePressEvent&quot;&gt;mousePressEvent&lt;/a&gt;（）），并且&lt;a href=&quot;qquickitem#acceptedMouseButtons&quot;&gt;acceptedMouseButtons&lt;/a&gt;（）必须返回相关的鼠标按钮。</target>
        </trans-unit>
        <trans-unit id="e65580b7a71f4b74e660a49e586e196f6738956f" translate="yes" xml:space="preserve">
          <source>In order to restore and activate a minimized window (while preserving its maximized and/or full-screen state), use the following:</source>
          <target state="translated">为了恢复和激活最小化窗口(同时保留其最大化和/或全屏状态),请使用以下方法。</target>
        </trans-unit>
        <trans-unit id="239bc75b82c4d0119111f8e91adb1394d201ce03" translate="yes" xml:space="preserve">
          <source>In order to run an application with a specific style, either configure the style using &lt;a href=&quot;qquickstyle&quot;&gt;QQuickStyle&lt;/a&gt; in C++, pass a command line argument, or set an environment variable. Alternatively, the preferred style and style-specific attributes can be specified in a configuration file.</source>
          <target state="translated">为了运行具有特定样式的应用程序，请使用C ++中的&lt;a href=&quot;qquickstyle&quot;&gt;QQuickStyle&lt;/a&gt;配置样式，传递命令行参数或设置环境变量。或者，可以在配置文件中指定首选样式和样式特定的属性。</target>
        </trans-unit>
        <trans-unit id="fa0d2b13442b7e65fa15e6bf769a48c084a4c415" translate="yes" xml:space="preserve">
          <source>In order to save bandwidth, sometimes a backend will only return places which are partially populated with details. This can be checked with the &lt;a href=&quot;qml-qtlocation-place#detailsFetched-prop&quot;&gt;Place::detailsFetched&lt;/a&gt; property which indicates whether all availalable details have been fetched or not. If not, the &lt;a href=&quot;qml-qtlocation-place#getDetails-method&quot;&gt;Place::getDetails&lt;/a&gt;() method can be invoked to fetch the remaining details.</source>
          <target state="translated">为了节省带宽，有时后端只会返回部分填充了详细信息的地方。可以使用&lt;a href=&quot;qml-qtlocation-place#detailsFetched-prop&quot;&gt;Place :: detailsFetched&lt;/a&gt;属性检查该属性，该属性指示是否已获取所有可用的详细信息。如果不是，则可以调用&lt;a href=&quot;qml-qtlocation-place#getDetails-method&quot;&gt;Place :: getDetails&lt;/a&gt;（）方法以获取其余的详细信息。</target>
        </trans-unit>
        <trans-unit id="33ba98aa49ecb34866969862fdccd9fac01c5199" translate="yes" xml:space="preserve">
          <source>In order to simplify the management of the enabled / disabled statuses, &lt;a href=&quot;qopengldebugmessage&quot;&gt;QOpenGLDebugMessage&lt;/a&gt; also supports the concept of &lt;code&gt;debug groups&lt;/code&gt;. A debug group contains the group of enabled / disabled configurations of debug messages. Moreover, debug groups are organized in a stack: it is possible to push and pop groups by calling &lt;a href=&quot;qopengldebuglogger#pushGroup&quot;&gt;pushGroup&lt;/a&gt;() and &lt;a href=&quot;qopengldebuglogger#popGroup&quot;&gt;popGroup&lt;/a&gt;() respectively. (When an OpenGL context is created, there is already a group in the stack).</source>
          <target state="translated">为了简化对启用/禁用状态的管理，&lt;a href=&quot;qopengldebugmessage&quot;&gt;QOpenGLDebugMessage&lt;/a&gt;还支持 &lt;code&gt;debug groups&lt;/code&gt; 的概念。调试组包含启用/禁用的调试消息配置组。此外，调试组是按堆栈组织的：可以分别通过调用&lt;a href=&quot;qopengldebuglogger#pushGroup&quot;&gt;pushGroup&lt;/a&gt;（）和&lt;a href=&quot;qopengldebuglogger#popGroup&quot;&gt;popGroup&lt;/a&gt;（）来推送和弹出组。 （创建OpenGL上下文时，堆栈中已经有一个组）。</target>
        </trans-unit>
        <trans-unit id="ae1b4a169d3419fd6ac0895b85077008ef3fa9e6" translate="yes" xml:space="preserve">
          <source>In order to support future compatibility, QCborValues containing extended Qt types compare equal to the tag type of the same contents. In other words, the following expression is true:</source>
          <target state="translated">为了支持未来的兼容性,包含扩展Qt类型的QCborValues与相同内容的标签类型进行等价比较。换句话说,以下表达式为真。</target>
        </trans-unit>
        <trans-unit id="891906f6b832cfd43f7613beff3b18541b8948d3" translate="yes" xml:space="preserve">
          <source>In order to test in-app purchases in your application, you first have to publish it. To limit the users who can access the application before it is ready for production, it can be published as either alpha or beta, in the respective tabs on the &lt;b&gt;APK&lt;/b&gt; page of the developer console. In order to make an alpha or beta application, fill out all the required information about the application, upload the &lt;code&gt;APK&lt;/code&gt; file under the &lt;b&gt;Beta testing&lt;/b&gt; or &lt;b&gt;Alpha testing&lt;/b&gt; tab, and mark the application as &lt;b&gt;published&lt;/b&gt;.</source>
          <target state="translated">为了在您的应用程序中测试应用程序内购买，您首先必须发布它。为了限制在准备好投入生产之前可以访问该应用程序的用户，可以在开发人员控制台的&lt;b&gt;APK&lt;/b&gt;页面上的相应标签中以Alpha或Beta版本发布该应用程序。为了制作Alpha或Beta应用程序，请填写有关该应用程序的所有必需信息，在&lt;b&gt;Beta测试&lt;/b&gt;或&lt;b&gt;Alpha测试&lt;/b&gt;标签下上传 &lt;code&gt;APK&lt;/code&gt; 文件，并将该应用标记为&lt;b&gt;已发布&lt;/b&gt;。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="acfdb1e58048ef1106e285ccf1135aa6a2d1154e" translate="yes" xml:space="preserve">
          <source>In order to test in-app purchases in your application, you first have to publish it. To limit the users who can access the application before it is ready for production, it can be published as either alpha or beta.</source>
          <target state="translated">为了在您的应用程序中测试应用内购买,您首先必须发布它。为了限制用户可以访问应用程序,在它准备生产之前,它可以作为alpha或beta发布。</target>
        </trans-unit>
        <trans-unit id="3eac5655794100ecd477fa39e106ff98f98a33f3" translate="yes" xml:space="preserve">
          <source>In order to track scroll bar movements, reimplement the virtual function &lt;a href=&quot;qabstractscrollarea#scrollContentsBy&quot;&gt;scrollContentsBy&lt;/a&gt;(). In order to fine-tune scrolling behavior, connect to a scroll bar's &lt;a href=&quot;qabstractslider#actionTriggered&quot;&gt;QAbstractSlider::actionTriggered&lt;/a&gt;() signal and adjust the &lt;a href=&quot;qabstractslider#sliderPosition-prop&quot;&gt;QAbstractSlider::sliderPosition&lt;/a&gt; as you wish.</source>
          <target state="translated">为了跟踪滚动条的移动，请重新实现虚拟函数&lt;a href=&quot;qabstractscrollarea#scrollContentsBy&quot;&gt;scrollContentsBy&lt;/a&gt;（）。为了微调滚动行为，请连接到滚动条的&lt;a href=&quot;qabstractslider#actionTriggered&quot;&gt;QAbstractSlider :: actionTriggered&lt;/a&gt;（）信号，并根据需要调整&lt;a href=&quot;qabstractslider#sliderPosition-prop&quot;&gt;QAbstractSlider :: sliderPosition&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dbe485a6cb246c26c71c6f42e96a132e7f89a894" translate="yes" xml:space="preserve">
          <source>In order to trigger the event on &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, the application must be configured to let the OS know what kind of file(s) it should react on.</source>
          <target state="translated">为了在&lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;上触发事件，必须将应用程序配置为让OS知道它应该对哪种文件做出反应。</target>
        </trans-unit>
        <trans-unit id="e1973803c5a405a401322f0652e8808d2699da28" translate="yes" xml:space="preserve">
          <source>In order to trigger the event on macOS, the application must be configured to let the OS know what kind of file(s) it should react on.</source>
          <target state="translated">为了在macOS上触发事件,必须对应用程序进行配置,让操作系统知道它应该对什么样的文件做出反应。</target>
        </trans-unit>
        <trans-unit id="fc215aa01eb248e06d0e4a9dc8f9435c2cc3eed0" translate="yes" xml:space="preserve">
          <source>In order to use &lt;a href=&quot;android&quot;&gt;Qt for Android&lt;/a&gt;, you need the following:</source>
          <target state="translated">为了使用&lt;a href=&quot;android&quot;&gt;Qt for Android&lt;/a&gt;，您需要满足以下条件：</target>
        </trans-unit>
        <trans-unit id="7e3be75fdce4c59f485783bed52658ee521a7009" translate="yes" xml:space="preserve">
          <source>In order to use &lt;a href=&quot;android#&quot;&gt;Qt for Android&lt;/a&gt;, you need the following:</source>
          <target state="translated">为了将&lt;a href=&quot;android#&quot;&gt;Qt用于Android&lt;/a&gt;，您需要满足以下条件：</target>
        </trans-unit>
        <trans-unit id="cf9631d352c48b641ff0d7847aa100abb55c5398" translate="yes" xml:space="preserve">
          <source>In order to use an adaptor, one must create a class which inherits &lt;a href=&quot;qdbusabstractadaptor&quot;&gt;QDBusAbstractAdaptor&lt;/a&gt;. Since that is a standard &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;-derived class, the &lt;a href=&quot;qobject#Q_OBJECT&quot;&gt;Q_OBJECT&lt;/a&gt; macro must appear in the declaration and the source file must be processed with the &lt;a href=&quot;moc&quot;&gt;moc&lt;/a&gt; tool. The class must also contain one &lt;a href=&quot;qobject#Q_CLASSINFO&quot;&gt;Q_CLASSINFO&lt;/a&gt; entry with the &lt;code&gt;&quot;D-Bus Interface&quot;&lt;/code&gt; name, declaring which interface it is exporting. Only one entry per class is supported.</source>
          <target state="translated">为了使用适配器，必须创建一个继承&lt;a href=&quot;qdbusabstractadaptor&quot;&gt;QDBusAbstractAdaptor&lt;/a&gt;的类。由于这是标准的&lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;派生的类，因此&lt;a href=&quot;qobject#Q_OBJECT&quot;&gt;Q_OBJECT&lt;/a&gt;宏必须出现在声明中，并且必须使用&lt;a href=&quot;moc&quot;&gt;moc&lt;/a&gt;工具处理源文件。该类还必须包含一个带有 &lt;code&gt;&quot;D-Bus Interface&quot;&lt;/code&gt; 名称的&lt;a href=&quot;qobject#Q_CLASSINFO&quot;&gt;Q_CLASSINFO&lt;/a&gt;条目，声明其正在导出哪个接口。每个课程仅支持一个条目。</target>
        </trans-unit>
        <trans-unit id="9eabef0817ab7612f568bd2200c9fde22e20789d" translate="yes" xml:space="preserve">
          <source>In order to use an iterator any of the standard algorithms, its iterator traits need to be known. As &lt;a href=&quot;qsequentialiterable&quot;&gt;QSequentialIterable&lt;/a&gt; can work with many different kinds of containers, we cannot declare the traits in the iterator classes themselves. A QTaggedIterator gives you a way to explicitly declare a trait for a concrete instance of an iterator or &lt;a href=&quot;qconstiterator&quot;&gt;QConstIterator&lt;/a&gt;.</source>
          <target state="translated">为了使用迭代器的任何标准算法，需要知道其迭代器特征。由于&lt;a href=&quot;qsequentialiterable&quot;&gt;QSequentialIterable&lt;/a&gt;可以使用许多不同类型的容器，因此我们无法在迭代器类本身中声明特征。QTaggedIterator提供了一种为迭代器或&lt;a href=&quot;qconstiterator&quot;&gt;QConstIterator&lt;/a&gt;的具体实例显式声明特征的方法。</target>
        </trans-unit>
        <trans-unit id="53b87ac57098715353e27b54a2c69f580646a7c7" translate="yes" xml:space="preserve">
          <source>In order to use one's own type with Qt D-Bus, the type has to be declared as a Qt meta-type with the &lt;a href=&quot;qmetatype#Q_DECLARE_METATYPE&quot;&gt;Q_DECLARE_METATYPE&lt;/a&gt;() macro and registered with the &lt;a href=&quot;qdbusargument#qDBusRegisterMetaType&quot;&gt;qDBusRegisterMetaType&lt;/a&gt;() function. The streaming operators &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; will be automatically found by the registration system.</source>
          <target state="translated">为了在Qt D-Bus中使用自己的类型，必须使用&lt;a href=&quot;qmetatype#Q_DECLARE_METATYPE&quot;&gt;Q_DECLARE_METATYPE&lt;/a&gt;（）宏将该类型声明为Qt元类型，并使用&lt;a href=&quot;qdbusargument#qDBusRegisterMetaType&quot;&gt;qDBusRegisterMetaType&lt;/a&gt;（）函数进行注册。流媒体运算符 &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; 和 &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; 将由注册系统自动找到。</target>
        </trans-unit>
        <trans-unit id="3a4e1b184c4ee4edd48b10c40c92ea172614ec75" translate="yes" xml:space="preserve">
          <source>In order to use the bundled icon theme, an application should call &lt;a href=&quot;qicon#setThemeName&quot;&gt;QIcon::setThemeName&lt;/a&gt;() before loading the main QML file:</source>
          <target state="translated">为了使用捆绑的图标主题，应用程序应在加载主QML文件之前调用&lt;a href=&quot;qicon#setThemeName&quot;&gt;QIcon :: setThemeName&lt;/a&gt;（）：</target>
        </trans-unit>
        <trans-unit id="cc188245c46a2da5cd37a410602599ed3f979cdc" translate="yes" xml:space="preserve">
          <source>In order to use the registered singleton type in QML, you must import the URI with the corresponding version.</source>
          <target state="translated">为了在QML中使用注册的单子类型,你必须导入相应版本的URI。</target>
        </trans-unit>
        <trans-unit id="fb3afc705c4d4bc91938057bcf4fadb835f5a69e" translate="yes" xml:space="preserve">
          <source>In order to use the registered singleton type in QML, you must import the singleton type.</source>
          <target state="translated">为了在QML中使用注册的单子类型,你必须导入单子类型。</target>
        </trans-unit>
        <trans-unit id="7d17f70074df889467be626f3995483d2addfbea" translate="yes" xml:space="preserve">
          <source>In other cases you will need to supply the signature yourself, and it is important that the signature matches the function you want to call. The signature structure is &lt;b&gt;(A)R&lt;/b&gt;, where &lt;b&gt;A&lt;/b&gt; is the type of the argument(s) and &lt;b&gt;R&lt;/b&gt; is the return type. Array types in the signature must have the &lt;b&gt;[&lt;/b&gt; suffix and the fully-qualified type names must have the &lt;b&gt;L&lt;/b&gt; prefix and &lt;b&gt;;&lt;/b&gt; suffix.</source>
          <target state="translated">在其他情况下，您需要自己提供签名，并且签名必须与要调用的功能匹配，这一点很重要。签名结构是&lt;b&gt;（A）R&lt;/b&gt;，其中&lt;b&gt;A&lt;/b&gt;是参数的类型，&lt;b&gt;R&lt;/b&gt;是返回类型。签名中的数组类型必须带有&lt;b&gt;[&lt;/b&gt;后缀，完全限定的类型名称必须带有&lt;b&gt;L&lt;/b&gt;前缀和&lt;b&gt;; &lt;/b&gt;后缀。</target>
        </trans-unit>
        <trans-unit id="9d455378a76d68ba5bdcdeb2fb9f14642ae276bb" translate="yes" xml:space="preserve">
          <source>In other cases, a pattern ported from &lt;a href=&quot;qregexp&quot;&gt;QRegExp&lt;/a&gt; to QRegularExpression may silently change semantics. Therefore, it is necessary to review the patterns used. The most notable cases of silent incompatibility are:</source>
          <target state="translated">在其他情况下，从&lt;a href=&quot;qregexp&quot;&gt;QRegExp&lt;/a&gt;移植到QRegularExpression的模式可能会默默地更改语义。因此，有必要审查使用的模式。沉默不兼容的最显着情况是：</target>
        </trans-unit>
        <trans-unit id="cff62e08bb0fd53e6c21df78ce74ee64d82ff8a5" translate="yes" xml:space="preserve">
          <source>In other cases, a pattern ported from &lt;code&gt;QRegExp&lt;/code&gt; to &lt;a href=&quot;qtcore-changes-qt6#qregularexpression&quot;&gt;QRegularExpression&lt;/a&gt; may silently change semantics. Therefore, it is necessary to review the patterns used. The most notable cases of silent incompatibility are:</source>
          <target state="translated">在其他情况下，图案从移植 &lt;code&gt;QRegExp&lt;/code&gt; 到&lt;a href=&quot;qtcore-changes-qt6#qregularexpression&quot;&gt;QRegularExpression&lt;/a&gt;可能默默地变化语义。因此，有必要审查使用的模式。沉默不兼容的最显着情况是：</target>
        </trans-unit>
        <trans-unit id="4d2f1a44792e00db7873e7639289783d168d9c70" translate="yes" xml:space="preserve">
          <source>In other cases, a pattern ported from QRegExp to &lt;a href=&quot;qtcore-changes-qt6#qregularexpression&quot;&gt;QRegularExpression&lt;/a&gt; may silently change semantics. Therefore, it is necessary to review the patterns used. The most notable cases of silent incompatibility are:</source>
          <target state="translated">在其他情况下，图案从QRegExp移植到&lt;a href=&quot;qtcore-changes-qt6#qregularexpression&quot;&gt;QRegularExpression&lt;/a&gt;可能默默地变化语义。因此，有必要审查使用的模式。沉默不兼容的最显着情况是：</target>
        </trans-unit>
        <trans-unit id="01527088776ea39b26a63e8592a37443bd83921b" translate="yes" xml:space="preserve">
          <source>In other files, it has to be prefixed with the name of its containing component.</source>
          <target state="translated">在其他文件中,它必须以其包含的组件名称为前缀。</target>
        </trans-unit>
        <trans-unit id="71c8e793c48baa19e9e861ca2d6a96ac2c587831" translate="yes" xml:space="preserve">
          <source>In other words, the proxy will have all rows of the first source model, followed by all rows of the second source model, and so on.</source>
          <target state="translated">换句话说,代理将拥有第一个源模型的所有行,然后是第二个源模型的所有行,以此类推。</target>
        </trans-unit>
        <trans-unit id="e3ec810f88d7ad1c4d7d04f694729ec8e79c50d5" translate="yes" xml:space="preserve">
          <source>In our delegate, we can then bind the</source>
          <target state="translated">在我们的代表中,我们可以将</target>
        </trans-unit>
        <trans-unit id="fd757abf8f41bb3e0600f489e8f951fb229f8854" translate="yes" xml:space="preserve">
          <source>In our example, the &lt;code&gt;&quot;healthPotion&quot;&lt;/code&gt; is a consumable product, because the user should be able to buy any number of health potions and add them to their in-game inventory.</source>
          <target state="translated">在我们的示例中， &lt;code&gt;&quot;healthPotion&quot;&lt;/code&gt; 是一种消耗品，因为用户应该能够购买任意数量的健康药水并将其添加到游戏中的库存中。</target>
        </trans-unit>
        <trans-unit id="d3269e302be6e28e3c121a9a7e3e7959fa4362c0" translate="yes" xml:space="preserve">
          <source>In our example, the control is a &lt;a href=&quot;qstyle#ControlElement-enum&quot;&gt;QStyle::CE_PushButton&lt;/a&gt;, and according to the &lt;a href=&quot;qstyle#drawControl&quot;&gt;QStyle::drawControl&lt;/a&gt;() documentation the corresponding class is &lt;a href=&quot;qstyleoptionbutton&quot;&gt;QStyleOptionButton&lt;/a&gt;.</source>
          <target state="translated">在我们的示例中，控件是&lt;a href=&quot;qstyle#ControlElement-enum&quot;&gt;QStyle :: CE_PushButton&lt;/a&gt;，根据&lt;a href=&quot;qstyle#drawControl&quot;&gt;QStyle :: drawControl&lt;/a&gt;（）文档，相应的类是&lt;a href=&quot;qstyleoptionbutton&quot;&gt;QStyleOptionButton&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5d7eb38f743704f4a3ec59be92859fb1d77fdb4b" translate="yes" xml:space="preserve">
          <source>In particular calling update whenever the cursor position changes is important as that often causes other query attributes like surrounding text and text selection to change as well. The attributes that often change together with cursor position have been grouped in &lt;a href=&quot;qt#InputMethodQuery-enum&quot;&gt;Qt::ImQueryInput&lt;/a&gt; value for convenience.</source>
          <target state="translated">特别是在光标位置发生变化时调用更新非常重要，因为这通常会导致其他查询属性（如周围的文本和文本选择）也发生变化。为了方便起见，经常与光标位置一起更改的属性已分组在&lt;a href=&quot;qt#InputMethodQuery-enum&quot;&gt;Qt :: ImQueryInput&lt;/a&gt;值中。</target>
        </trans-unit>
        <trans-unit id="3c064b8988cc079e71884c37f141206a12483fd0" translate="yes" xml:space="preserve">
          <source>In particular, QML currently supports:</source>
          <target state="translated">特别是,QML目前支持:</target>
        </trans-unit>
        <trans-unit id="f044a192708817302082a9b98b00d91488208886" translate="yes" xml:space="preserve">
          <source>In particular, if</source>
          <target state="translated">特别是,如果</target>
        </trans-unit>
        <trans-unit id="6bd2b529749df25d085d0c1d75f528673e0dcc17" translate="yes" xml:space="preserve">
          <source>In particular, in the last case we want the regular expression engine to report a partial match: we are successfully matching the pattern against the subject string but the matching cannot continue because the end of the subject is encountered. Notice, however, that the matching algorithm should continue and try all possibilities, and in case a complete (non-partial) match is found, then this one should be reported, and the input string accepted as fully valid.</source>
          <target state="translated">特别是在最后一种情况下,我们希望正则表达式引擎报告一个部分匹配:我们成功地将模式与主题字符串进行了匹配,但由于遇到了主题的结尾,匹配无法继续。但是请注意,匹配算法应该继续进行,并尝试所有的可能性,如果发现了一个完整的(非部分)匹配,那么应该报告这个匹配,并接受输入字符串为完全有效。</target>
        </trans-unit>
        <trans-unit id="0eacce3b7f64260a935c559f5a26420bb297d1d4" translate="yes" xml:space="preserve">
          <source>In particular, this may be useful in order to access functionality provided via a singleton type; see &lt;a href=&quot;qqmlengine#QML_SINGLETON&quot;&gt;QML_SINGLETON&lt;/a&gt; for more information.</source>
          <target state="translated">特别是，这对于访问通过单例类型提供的功能可能很有用；有关更多信息，请参见&lt;a href=&quot;qqmlengine#QML_SINGLETON&quot;&gt;QML_SINGLETON&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0408c88246551a7cd9cf01a51efa481f9fcb3708" translate="yes" xml:space="preserve">
          <source>In particular, this may be useful in order to access functionality provided via a singleton type; see &lt;a href=&quot;qqmlengine#qmlRegisterSingletonType&quot;&gt;qmlRegisterSingletonType&lt;/a&gt;() for more information.</source>
          <target state="translated">特别是，这对于访问通过单例类型提供的功能可能很有用；有关更多信息，请参见&lt;a href=&quot;qqmlengine#qmlRegisterSingletonType&quot;&gt;qmlRegisterSingletonType&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="5a507e0c95322db4179bf9554016bf5d9ed5ac31" translate="yes" xml:space="preserve">
          <source>In practice the most common combinations are expected to be the following:</source>
          <target state="translated">在实践中,最常见的组合预计如下:</target>
        </trans-unit>
        <trans-unit id="a820314cab280acd6b3c5950b5edbd24f5c17f06" translate="yes" xml:space="preserve">
          <source>In practice this configure command is equivalent to the following direct CMake call:</source>
          <target state="translated">在实践中,这个configure命令相当于下面的直接CMake调用。</target>
        </trans-unit>
        <trans-unit id="7d04a48b74ffeda38d5e4f0534a4eaddd90455fe" translate="yes" xml:space="preserve">
          <source>In practice this function is often called from a slot connected to the &lt;a href=&quot;qquickwindow#beforeRenderPassRecording&quot;&gt;beforeRenderPassRecording&lt;/a&gt;() or &lt;a href=&quot;qquickwindow#afterRenderPassRecording&quot;&gt;afterRenderPassRecording&lt;/a&gt;() signals.</source>
          <target state="translated">在实践中，这功能通常由连接到一个时隙称为&lt;a href=&quot;qquickwindow#beforeRenderPassRecording&quot;&gt;beforeRenderPassRecording&lt;/a&gt;（）或&lt;a href=&quot;qquickwindow#afterRenderPassRecording&quot;&gt;afterRenderPassRecording&lt;/a&gt;（）信号。</target>
        </trans-unit>
        <trans-unit id="e6420d958b52ec74d2f4d416713ffaec58cbba3d" translate="yes" xml:space="preserve">
          <source>In practice, additional error checking needs to be performed on the positional arguments and option values. For example, ranges of numbers should be checked.</source>
          <target state="translated">在实践中,需要对位置参数和选项值进行额外的错误检查。例如,应检查数字的范围。</target>
        </trans-unit>
        <trans-unit id="c9649dc9661cd56dc8690eb9e41d0c267ec90959" translate="yes" xml:space="preserve">
          <source>In practice, it often happens that a single &lt;a href=&quot;qt3drender-qeffect&quot;&gt;QEffect&lt;/a&gt; is being referenced by several &lt;a href=&quot;qt3drender-qmaterial&quot;&gt;QMaterial&lt;/a&gt; components. This allows to only create the effect, techniques, passes and shaders once while allowing to specify the material by adding &lt;a href=&quot;qt3drender-qparameter&quot;&gt;QParameter&lt;/a&gt; instances.</source>
          <target state="translated">在实践中，经常会发生多个&lt;a href=&quot;qt3drender-qmaterial&quot;&gt;QMaterial&lt;/a&gt;组件引用单个&lt;a href=&quot;qt3drender-qeffect&quot;&gt;QEffect的&lt;/a&gt;情况。这仅允许创建一次效果，技术，通过和着色器，同时允许通过添加&lt;a href=&quot;qt3drender-qparameter&quot;&gt;QParameter&lt;/a&gt;实例来指定材质。</target>
        </trans-unit>
        <trans-unit id="a9b2cbb6380dc64215d75c749f5b303d4727043c" translate="yes" xml:space="preserve">
          <source>In practice, it often happens that a single &lt;a href=&quot;qt3drender-qeffect&quot;&gt;QEffect&lt;/a&gt; is being referenced by several QMaterial components. This allows to only create the effect, techniques, passes and shaders once while allowing to specify the material by adding &lt;a href=&quot;qt3drender-qparameter&quot;&gt;QParameter&lt;/a&gt; instances.</source>
          <target state="translated">在实践中，经常会发生多个QMaterial组件引用单个&lt;a href=&quot;qt3drender-qeffect&quot;&gt;QEffect的&lt;/a&gt;情况。这仅允许创建效果，技术，通过和着色器一次，同时允许通过添加&lt;a href=&quot;qt3drender-qparameter&quot;&gt;QParameter&lt;/a&gt;实例来指定材质。</target>
        </trans-unit>
        <trans-unit id="d3aac8815ccf30d39940f820118f556398786c1c" translate="yes" xml:space="preserve">
          <source>In practice, it often happens that a single Effect is being referenced by several Material components. This allows to only create the effect, techniques, passes and shaders once while allowing to specify the material by adding Parameter instances.</source>
          <target state="translated">在实践中,经常会发生一个效果被多个材质组件引用的情况,这时只需创建一次效果、技术、通道和着色器,同时允许通过添加Parameter实例来指定材质。这允许只创建一次效果、技术、通道和着色器,同时允许通过添加Parameter实例来指定材质。</target>
        </trans-unit>
        <trans-unit id="34ece7a22518032100e8b60b803f635ea620c604" translate="yes" xml:space="preserve">
          <source>In practice, the impossibility of using GUI classes in other threads than the main thread can easily be worked around by putting time-consuming operations in a separate worker thread and displaying the results on screen in the main thread when the worker thread is finished. This is the approach used for implementing the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtcore-threads-mandelbrot-example.html&quot;&gt;Mandelbrot Example&lt;/a&gt; and the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtnetwork-blockingfortuneclient-example.html&quot;&gt;Blocking Fortune Client Example&lt;/a&gt;.</source>
          <target state="translated">实际上，可以通过将耗时的操作放在单独的工作线程中并在工作线程完成后在主线程的屏幕上显示结果来轻松解决在主线程以外的其他线程中使用GUI类的可能性。这是用于实现&lt;a href=&quot;https://doc.qt.io/qt-5.13/qtcore-threads-mandelbrot-example.html&quot;&gt;Mandelbrot示例&lt;/a&gt;和&lt;a href=&quot;https://doc.qt.io/qt-5.13/qtnetwork-blockingfortuneclient-example.html&quot;&gt;Blocking Fortune Client示例的方法&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="46e722d18bec0bd4cf3a8a580be56b2541dcf1a8" translate="yes" xml:space="preserve">
          <source>In practice, the impossibility of using GUI classes in other threads than the main thread can easily be worked around by putting time-consuming operations in a separate worker thread and displaying the results on screen in the main thread when the worker thread is finished. This is the approach used for implementing the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtcore-threads-mandelbrot-example.html&quot;&gt;Mandelbrot Example&lt;/a&gt; and the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtnetwork-blockingfortuneclient-example.html&quot;&gt;Blocking Fortune Client Example&lt;/a&gt;.</source>
          <target state="translated">实际上，可以通过将耗时的操作放在单独的工作线程中，并在工作线程完成后在主线程的屏幕上显示结果，来轻松解决在主线程以外的其他线程中使用GUI类的可能性。这是用于实现&lt;a href=&quot;https://doc.qt.io/qt-5.15/qtcore-threads-mandelbrot-example.html&quot;&gt;Mandelbrot示例&lt;/a&gt;和&lt;a href=&quot;https://doc.qt.io/qt-5.15/qtnetwork-blockingfortuneclient-example.html&quot;&gt;Blocking Fortune Client示例的方法&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="518755929d2774f62f055f37f4572b7830114134" translate="yes" xml:space="preserve">
          <source>In practice, the impossibility of using GUI classes in other threads than the main thread can easily be worked around by putting time-consuming operations in a separate worker thread and displaying the results on screen in the main thread when the worker thread is finished. This is the approach used for implementing the &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtcore-threads-mandelbrot-example.html&quot;&gt;Mandelbrot Example&lt;/a&gt; and the &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtnetwork-blockingfortuneclient-example.html&quot;&gt;Blocking Fortune Client Example&lt;/a&gt;.</source>
          <target state="translated">实际上，可以通过将耗时的操作放在单独的工作线程中，并在工作线程完成后在主线程的屏幕上显示结果，来轻松解决在主线程以外的其他线程中使用GUI类的可能性。这是用于实现&lt;a href=&quot;https://doc.qt.io/qt-6.0/qtcore-threads-mandelbrot-example.html&quot;&gt;Mandelbrot示例&lt;/a&gt;和&lt;a href=&quot;https://doc.qt.io/qt-6.0/qtnetwork-blockingfortuneclient-example.html&quot;&gt;Blocking Fortune Client示例的方法&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="01bc404839e234ba8ab44abaf332354bdfbe4a5d" translate="yes" xml:space="preserve">
          <source>In practice, this means that the application developer should:</source>
          <target state="translated">在实践中,这意味着应用开发者应该。</target>
        </trans-unit>
        <trans-unit id="584fcaeaa9a00dd83ceb7534ecaf4817a7fe4b00" translate="yes" xml:space="preserve">
          <source>In previous versions of Qt, &lt;a href=&quot;qabstractprintdialog#exec&quot;&gt;exec&lt;/a&gt;() the print dialog would create a sheet by default the dialog was given a parent. This is no longer supported in Qt 4.5. If you want to use sheets, use &lt;a href=&quot;qprintdialog#open&quot;&gt;QPrintDialog::open&lt;/a&gt;() instead.</source>
          <target state="translated">在以前的Qt版本中，默认情况下&lt;a href=&quot;qabstractprintdialog#exec&quot;&gt;exec&lt;/a&gt;（）的&amp;ldquo;打印&amp;rdquo;对话框将创建一个工作表，该对话框被赋予了父级。Qt 4.5不再支持此功能。如果要使用图纸，请改用&lt;a href=&quot;qprintdialog#open&quot;&gt;QPrintDialog :: open&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="86d4b04056db642bac0638e0c4ffb321e1299f92" translate="yes" xml:space="preserve">
          <source>In previous versions of Qt, &lt;a href=&quot;qdialog#exec&quot;&gt;exec&lt;/a&gt;() the print dialog would create a sheet by default the dialog was given a parent. This is no longer supported in Qt 4.5. If you want to use sheets, use &lt;a href=&quot;qprintdialog#open&quot;&gt;QPrintDialog::open&lt;/a&gt;() instead.</source>
          <target state="translated">在以前的Qt版本中，默认情况下，&lt;a href=&quot;qdialog#exec&quot;&gt;exec&lt;/a&gt;（）打印对话框将创建一个工作表，该对话框被赋予父级。Qt 4.5不再支持此功能。如果要使用图纸，请改用&lt;a href=&quot;qprintdialog#open&quot;&gt;QPrintDialog :: open&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="3b5f9c82640ac7c66877027ca298b3995f9f02f4" translate="yes" xml:space="preserve">
          <source>In previous versions of Qt, the static functions would create a sheet by default if the static function was given a parent. This is no longer supported and does nothing in Qt 4.5, The static functions will always be an application modal dialog. If you want to use sheets, use &lt;a href=&quot;qfiledialog#open&quot;&gt;QFileDialog::open&lt;/a&gt;() instead.</source>
          <target state="translated">在早期版本的Qt中，如果为静态函数指定了父级，则默认情况下静态函数会创建一个工作表。在Qt 4.5中不再支持此功能，并且不执行任何操作。静态函数将始终是应用程序模式对话框。如果要使用图纸，请改用&lt;a href=&quot;qfiledialog#open&quot;&gt;QFileDialog :: open&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="c6482c6f24bb5a73f6a2f88d95345457a7372a5b" translate="yes" xml:space="preserve">
          <source>In project mode, qmake will generate a project file. Additionally, you may supply the following options in this mode:</source>
          <target state="translated">在项目模式下,qmake会生成一个项目文件。此外,您还可以在该模式下提供以下选项。</target>
        </trans-unit>
        <trans-unit id="52eb3773db85903a8f69c6bdfd4e460d11e7a30c" translate="yes" xml:space="preserve">
          <source>In read-only mode, the user can still copy the text to the clipboard, or drag and drop the text (if &lt;a href=&quot;qlineedit#echoMode-prop&quot;&gt;echoMode&lt;/a&gt;() is &lt;a href=&quot;qlineedit#EchoMode-enum&quot;&gt;Normal&lt;/a&gt;), but cannot edit it.</source>
          <target state="translated">在只读模式下，用户仍然可以将文本复制到剪贴板，或拖放文本（如果&lt;a href=&quot;qlineedit#echoMode-prop&quot;&gt;echoMode&lt;/a&gt;（）为&lt;a href=&quot;qlineedit#EchoMode-enum&quot;&gt;Normal&lt;/a&gt;），但不能对其进行编辑。</target>
        </trans-unit>
        <trans-unit id="7ea2966fca2f27a136908152df12da4dd338a57b" translate="yes" xml:space="preserve">
          <source>In read-only mode, the user can still copy the text to the clipboard, or drag and drop the text; but cannot edit it.</source>
          <target state="translated">在只读模式下,用户仍然可以将文本复制到剪贴板,或拖放文本;但不能编辑它。</target>
        </trans-unit>
        <trans-unit id="b56c5145455e3fcd374d1b301c13388031ed45d7" translate="yes" xml:space="preserve">
          <source>In read-only mode, the user can use the help engine with a collection file installed in a read-only location. In this case, some functionality won't be accessible, like registering additional documentation, filter editing, or any action that would require changes to the collection file. Setting it to &lt;code&gt;false&lt;/code&gt; enables the full functionality of the help engine.</source>
          <target state="translated">在只读模式下，用户可以将帮助引擎与安装在只读位置的收集文件一起使用。在这种情况下，某些功能将无法访问，例如注册其他文档，过滤器编辑或任何需要更改集合文件的操作。将其设置为 &lt;code&gt;false&lt;/code&gt; 可启用帮助引擎的全部功能。</target>
        </trans-unit>
        <trans-unit id="f370d1bcdf4b02c16a4e490f598de020a265b0b5" translate="yes" xml:space="preserve">
          <source>In real life, chromatic aberration is an optical phenomenon causing color fringes in high contrast areas. These color fringes are caused by different colors refracting at different angels splitting white light into a spectrum. This is called dispersion.</source>
          <target state="translated">在现实生活中,色差是一种光学现象,会在高对比度区域造成颜色边缘。这些色斑是由于不同的颜色以不同的角度折射,将白光分割成一个光谱造成的。这就是所谓的色散。</target>
        </trans-unit>
        <trans-unit id="9096d8234b80c472ceb6ba577a7ed7c91d3f250f" translate="yes" xml:space="preserve">
          <source>In render function, for each visual object:</source>
          <target state="translated">在渲染函数中,对于每个可视对象。</target>
        </trans-unit>
        <trans-unit id="9477c26d43c2a174197428d1b5bfa57d28f0c94f" translate="yes" xml:space="preserve">
          <source>In response to the initial ClientHello message, the server sends a HelloVerifyRequest, which contains a cookie. This cookie is a cryptographic hash and is generated using the client's address, port number, and the server's secret (which is a cryptographically strong pseudo-random sequence of bytes).</source>
          <target state="translated">作为对初始ClientHello消息的响应,服务器发送一个HelloVerifyRequest,其中包含一个cookie。这个cookie是一个加密哈希,使用客户端的地址、端口号和服务器的秘密(这是一个加密的强伪随机字节序列)生成。</target>
        </trans-unit>
        <trans-unit id="27b5f5b55cebbe5ba07d8b7894baf84d3fbea19e" translate="yes" xml:space="preserve">
          <source>In right-to-left language speaking cultures, people naturally scan and read graphic elements and text from the right to left. The general rule of thumb is that content (like photos, videos and maps) is not mirrored, but positioning of the content (like application layouts and the flow of visual elements) is mirrored. For example, photos shown in chronological order should flow from right to left, the low end range of the horizontal sliders should be located at the right side of the slider, and text lines should be aligned to the right side of the available text area. The location of visual elements should not be mirrored when the position is related to a content; for example, when a position marker is shown to indicate a location on a map. Also, there are some special cases you may need to take into account where right-to-left language speakers are used to left-to-right positioning, for example when using number dialers in phones and media play, pause, rewind and forward buttons in music players.</source>
          <target state="translated">在从右到左的语言文化中,人们会自然地从右到左扫描和阅读图形元素和文本。一般的经验法则是,内容(如照片、视频和地图)不镜像,但内容的定位(如应用布局和视觉元素的流动)是镜像的。例如,按时间顺序显示的照片应该从右到左流动,水平滑块的低端范围应该位于滑块的右侧,文本行应该对准可用文本区域的右侧。当视觉元素的位置与内容相关时,不应镜像;例如,当位置标记显示为地图上的位置时,不应镜像。另外,在一些特殊情况下,你可能需要考虑到从右到左的语言使用者习惯于从左到右的定位,例如在使用电话中的数字拨号器和媒体播放、音乐播放器中的暂停、倒带和前进按钮时。</target>
        </trans-unit>
        <trans-unit id="d739643e33524ace5ab6eace22efddca9e20969c" translate="yes" xml:space="preserve">
          <source>In scene initialization function, for each visual object:</source>
          <target state="translated">在场景初始化函数中,对于每个视觉对象。</target>
        </trans-unit>
        <trans-unit id="6f30d77d4100ef4141082397d2a9dab02e6a7059" translate="yes" xml:space="preserve">
          <source>In shell surface integrations, such as QWaylandWlShellIntegration and QWaylandXdgShellV5Integration, maximize and fullscreen requests from the client will only have an effect if the integration has the primary view of the surface.</source>
          <target state="translated">在壳表面集成中,如QWaylandWlShellIntegration和QWaylandXdgShellV5Integration,来自客户端的最大化和全屏请求只有在集成具有表面的主视图时才会产生效果。</target>
        </trans-unit>
        <trans-unit id="ec0266fa95240508cdb33878f5d0a757c54a7e5c" translate="yes" xml:space="preserve">
          <source>In situations where a feature of the native platform is not exposed in Qt, it can be helpful to access the native handles maintained by Qt, and use those to call the native APIs instead.</source>
          <target state="translated">在Qt中没有暴露原生平台功能的情况下,访问Qt维护的原生句柄,并使用这些句柄来调用原生API是很有帮助的。</target>
        </trans-unit>
        <trans-unit id="7dc9e2b3217e1e07d5cd990ab9fd086112d1b9c5" translate="yes" xml:space="preserve">
          <source>In small to medium sized projects, a build script typically lists all source files and then compiles the executable in one go. This means that the build scripts for the tests must list the needed source files again.</source>
          <target state="translated">在中小型项目中,构建脚本通常会列出所有源文件,然后一次性编译可执行文件。这意味着,测试的构建脚本必须再次列出所需的源文件。</target>
        </trans-unit>
        <trans-unit id="2b243fb67a5ea1c66941228cfb17b8a4f4d74cbe" translate="yes" xml:space="preserve">
          <source>In some GUI styles a default button is drawn with an extra frame around it, up to 3 pixels or more. Qt automatically keeps this space free around auto-default buttons, i.e., auto-default buttons may have a slightly larger size hint.</source>
          <target state="translated">在一些GUI样式中,一个默认按钮周围会多画一个框,最多3个像素或更多。Qt会自动在自动默认按钮周围保留这个空间,也就是说,自动默认按钮可能会有一个稍大的尺寸提示。</target>
        </trans-unit>
        <trans-unit id="416585172015229e64ef426fff8e77481ff2b51b" translate="yes" xml:space="preserve">
          <source>In some applications, it may make sense to have actions with icons in the toolbar, but not in menus. If true, the icon (if valid) is shown in the menu, when it is false, it is not shown.</source>
          <target state="translated">在某些应用程序中,将带有图标的操作放在工具栏中而不放在菜单中可能是有意义的。如果为真,图标(如果有效)会显示在菜单中,如果为假,则不显示。</target>
        </trans-unit>
        <trans-unit id="e7e0698c1ec7fc5eb17dc208e98e215be5d4f0ae" translate="yes" xml:space="preserve">
          <source>In some applications, it may make sense to have actions with shortcuts in context menus. If true, the shortcut (if valid) is shown when the action is shown via a context menu, when it is false, it is not shown.</source>
          <target state="translated">在某些应用程序中,在上下文菜单中设置带有快捷方式的操作可能是有意义的。如果为真,当动作通过上下文菜单显示时,快捷方式(如果有效)就会显示,如果为假,则不会显示。</target>
        </trans-unit>
        <trans-unit id="33a8f44653ad7acca962e66bf2bd7bae24b4eb04" translate="yes" xml:space="preserve">
          <source>In some cases (e.g. dropping multiple email attachments), multiple data values are available. They can be accessed by adding an &lt;code&gt;index&lt;/code&gt; value:</source>
          <target state="translated">在某些情况下（例如删除多个电子邮件附件），可以使用多个数据值。可以通过添加 &lt;code&gt;index&lt;/code&gt; 值来访问它们：</target>
        </trans-unit>
        <trans-unit id="2a5f240081b2d373ff2d02be32db6d5de83b7057" translate="yes" xml:space="preserve">
          <source>In some cases an API is too platform specific to be included in the cross platform Qt classes, but is still useful to include. These APIs are available either in the same way as when accessing the underlying native handles, through the &lt;a href=&quot;qopenglcontext#nativeInterface&quot;&gt;nativeInterface()&lt;/a&gt; accessor, or directly as static function in the native interface.</source>
          <target state="translated">在某些情况下，API太特定于平台而不能包含在跨平台Qt类中，但仍然有用。这些API的使用方式与通过&lt;a href=&quot;qopenglcontext#nativeInterface&quot;&gt;nativeInterface（）&lt;/a&gt;访问器访问基础本机句柄的方式相同，也可以作为本机接口中的静态函数直接使用。</target>
        </trans-unit>
        <trans-unit id="843fcdf9edd577ff40518fb8089bc3790d3fa656" translate="yes" xml:space="preserve">
          <source>In some cases and for less frequently used encodings it may be necessary to write your own &lt;a href=&quot;qtextcodec&quot;&gt;QTextCodec&lt;/a&gt; subclass. Depending on the urgency, it may be useful to contact Qt's technical support team or ask on the &lt;code&gt;qt-interest&lt;/code&gt; mailing list to see if someone else is already working on supporting the encoding.</source>
          <target state="translated">在某些情况下，对于不太常用的编码，可能有必要编写自己的&lt;a href=&quot;qtextcodec&quot;&gt;QTextCodec&lt;/a&gt;子类。根据紧急情况，联系Qt的技术支持团队或在 &lt;code&gt;qt-interest&lt;/code&gt; 的qt邮件列表中询问是否有人正在致力于支持编码可能很有用。</target>
        </trans-unit>
        <trans-unit id="8a92f39184c895256f5a7c6db1217258254daaa5" translate="yes" xml:space="preserve">
          <source>In some cases changing these settings may result in a longer delay before an image is ready.</source>
          <target state="translated">在某些情况下,更改这些设置可能会导致在图像准备好之前有更长的延迟。</target>
        </trans-unit>
        <trans-unit id="f91121f9956527af6306a84bb5613efd97efa8ee" translate="yes" xml:space="preserve">
          <source>In some cases internationalization is simple, for example, making a US application accessible to Australian or British users may require little more than a few spelling corrections. But to make a US application usable by Japanese users, or a Korean application usable by German users, will require that the software operate not only in different languages, but use different input techniques, character encodings and presentation conventions.</source>
          <target state="translated">在某些情况下,国际化是很简单的,例如,要使澳大利亚或英国用户能够使用美国的应用程序,可能只需要修改一些拼写。但是,要使日本用户可以使用美国的应用程序,或德国用户可以使用韩国的应用程序,就需要软件不仅以不同的语言操作,而且使用不同的输入技术、字符编码和显示惯例。</target>
        </trans-unit>
        <trans-unit id="183909d14a1f852600e3e34b5ec35b4a844b4013" translate="yes" xml:space="preserve">
          <source>In some cases it can be more beneficial to draw the pixmap to a painter with a scale set rather than scaling the pixmap. This is the case when the painter is for instance based on OpenGL or when the scale factor changes rapidly.</source>
          <target state="translated">在某些情况下,将pixmap绘制到带有比例尺设置的绘图器上比缩放pixmap更有利。例如,当画家是基于OpenGL的,或者当比例因子快速变化时,就会出现这种情况。</target>
        </trans-unit>
        <trans-unit id="04d1b72091a29a6578327eb1a20d9e3d6683e5cc" translate="yes" xml:space="preserve">
          <source>In some cases it is necessary for a control to have a drop shadow, for example. However, if we were to add a drop shadow to the button above, it would affect its size, which presents problems for both layouting and mouse/touch input boundaries.</source>
          <target state="translated">在某些情况下,控件有必要有一个下拉阴影,例如。但是,如果我们要给上面的按钮添加一个下拉阴影,就会影响它的大小,这就给布局和鼠标/触摸输入边界带来了问题。</target>
        </trans-unit>
        <trans-unit id="c1053dd709e57e11ff2ff048501cdb1191b39349" translate="yes" xml:space="preserve">
          <source>In some cases it may be desirable to access a signal outside of the object that emits it. For these purposes, the &lt;code&gt;QtQuick&lt;/code&gt; module provides the &lt;a href=&quot;qml-qtqml-connections&quot;&gt;Connections&lt;/a&gt; type for connecting to signals of arbitrary objects. A &lt;a href=&quot;qml-qtqml-connections&quot;&gt;Connections&lt;/a&gt; object can receive any signal from its specified &lt;a href=&quot;qml-qtqml-connections#target-prop&quot;&gt;target&lt;/a&gt;.</source>
          <target state="translated">在某些情况下，可能希望访问发出信号的对象之外的信号。为此， &lt;code&gt;QtQuick&lt;/code&gt; 模块提供了&lt;a href=&quot;qml-qtqml-connections&quot;&gt;Connections&lt;/a&gt;类型，用于连接到任意对象的信号。阿&lt;a href=&quot;qml-qtqml-connections&quot;&gt;连接&lt;/a&gt;对象可以接收来自它的指定的任何信号&lt;a href=&quot;qml-qtqml-connections#target-prop&quot;&gt;的目标&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="923702524b8a824d82d474e4042381dd4f8db231" translate="yes" xml:space="preserve">
          <source>In some cases it may be necessary to perform a video mode set on application startup even when the screen reports that the desired resolution is already set. This is normally optimized away, but if the screen stays powered down, try setting the environment variable &lt;code&gt;QT_QPA_EGLFS_ALWAYS_SET_MODE&lt;/code&gt; to a non-zero value and relaunch the application.</source>
          <target state="translated">在某些情况下，即使屏幕报告已设置所需的分辨率，也可能需要在应用程序启动时执行视频模式设置。通常可以进行优化，但是如果屏幕保持关闭状态，请尝试将环境变量 &lt;code&gt;QT_QPA_EGLFS_ALWAYS_SET_MODE&lt;/code&gt; 设置为非零值，然后重新启动应用程序。</target>
        </trans-unit>
        <trans-unit id="21ef113bfb1073bca51faf7d55677f9bc895fdb2" translate="yes" xml:space="preserve">
          <source>In some cases it may be required to call &lt;a href=&quot;qnetworkconfigurationmanager#updateConfigurations&quot;&gt;updateConfigurations&lt;/a&gt;() and wait for the &lt;a href=&quot;qnetworkconfigurationmanager#updateCompleted&quot;&gt;updateCompleted&lt;/a&gt;() signal before calling this function.</source>
          <target state="translated">在某些情况下，可能需要先调用&lt;a href=&quot;qnetworkconfigurationmanager#updateConfigurations&quot;&gt;updateConfigurations&lt;/a&gt;（）并等待&lt;a href=&quot;qnetworkconfigurationmanager#updateCompleted&quot;&gt;updateCompleted&lt;/a&gt;（）信号，然后才能调用此函数。</target>
        </trans-unit>
        <trans-unit id="4c02984c7cb3ffce7032812aa08442b7bc00527b" translate="yes" xml:space="preserve">
          <source>In some cases it may be undesirable to play a sound effect - for example, when initiating video recording the sound itself may be recorded.</source>
          <target state="translated">在某些情况下,可能不希望播放声音效果--例如,当启动视频录制时,声音本身可能会被录制。</target>
        </trans-unit>
        <trans-unit id="620031e38d73b7471c0d4e44825e6139f594aa81" translate="yes" xml:space="preserve">
          <source>In some cases properties contain a logical group of sub-property attributes. These sub-property attributes can be assigned to using either the dot notation or group notation.</source>
          <target state="translated">在某些情况下,属性包含一个逻辑的子属性属性组。这些子属性可以使用点符号或组符号来分配。</target>
        </trans-unit>
        <trans-unit id="aa9926d183a9d7f0c51856d01ecd9e05f58927d0" translate="yes" xml:space="preserve">
          <source>In some cases the automatic querying of the physical screen size via DRM may fail. Normally the &lt;code&gt;QT_QPA_EGLFS_PHYSICAL_WIDTH&lt;/code&gt; and &lt;code&gt;QT_QPA_EGLFS_PHYSICAL_HEIGHT&lt;/code&gt; environment variable would be used to provide the missing values, however this is not suitable anymore when multiple screens are present. Instead, use the &lt;code&gt;physicalWidth&lt;/code&gt; and &lt;code&gt;physicalHeight&lt;/code&gt; properties in the &lt;code&gt;outputs&lt;/code&gt; list to specify the sizes in millimeters.</source>
          <target state="translated">在某些情况下，通过DRM自动查询物理屏幕尺寸可能会失败。通常，将使用 &lt;code&gt;QT_QPA_EGLFS_PHYSICAL_WIDTH&lt;/code&gt; 和 &lt;code&gt;QT_QPA_EGLFS_PHYSICAL_HEIGHT&lt;/code&gt; 环境变量来提供缺少的值，但是当存在多个屏幕时，这不再适用。而是使用 &lt;code&gt;outputs&lt;/code&gt; 列表中的 &lt;code&gt;physicalWidth&lt;/code&gt; 和 &lt;code&gt;physicalHeight&lt;/code&gt; 属性指定以毫米为单位的大小。</target>
        </trans-unit>
        <trans-unit id="258ccc09ab212e443008a01568e6bceef2ecfa15" translate="yes" xml:space="preserve">
          <source>In some cases the functionality may not be available (for example, if the current operating system or platform does not provide the required functionality), or it may be temporarily unavailable (for example, audio playback during a phone call or similar).</source>
          <target state="translated">在某些情况下,该功能可能无法使用(例如,如果当前的操作系统或平台没有提供所需的功能),或者暂时无法使用(例如,在电话或类似情况下的音频播放)。</target>
        </trans-unit>
        <trans-unit id="85a0516966e42e8b8671b423be1faf9b1e34a91b" translate="yes" xml:space="preserve">
          <source>In some cases the peripheral generates value updates which the central is interested in receiving. In order for a characteristic to support such notifications it must have the &lt;a href=&quot;qlowenergycharacteristic#PropertyType-enum&quot;&gt;QLowEnergyCharacteristic::Notify&lt;/a&gt; or &lt;a href=&quot;qlowenergycharacteristic#PropertyType-enum&quot;&gt;QLowEnergyCharacteristic::Indicate&lt;/a&gt; property and a descriptor of type &lt;a href=&quot;qbluetoothuuid#DescriptorType-enum&quot;&gt;QBluetoothUuid::ClientCharacteristicConfiguration&lt;/a&gt;. Provided those conditions are fulfilled notifications can be enabled as shown in the following code segment:</source>
          <target state="translated">在某些情况下，外围设备生成价值更新，而中央则希望接收该价值更新。为了使特性支持此类通知，它必须具有&lt;a href=&quot;qlowenergycharacteristic#PropertyType-enum&quot;&gt;QLowEnergyCharacteristic :: Notify&lt;/a&gt;或&lt;a href=&quot;qlowenergycharacteristic#PropertyType-enum&quot;&gt;QLowEnergyCharacteristic :: Indicate&lt;/a&gt;属性以及类型为&lt;a href=&quot;qbluetoothuuid#DescriptorType-enum&quot;&gt;QBluetoothUuid :: ClientCharacteristicConfiguration&lt;/a&gt;的描述符。如果满足这些条件，则可以启用通知，如以下代码段所示：</target>
        </trans-unit>
        <trans-unit id="a268a7e99380f4ea4cd542df2c6410112901b1e9" translate="yes" xml:space="preserve">
          <source>In some cases the source video stream requires a certain orientation to be correct. This includes sources like a camera viewfinder, where the displayed viewfinder should match reality, no matter what rotation the rest of the user interface has.</source>
          <target state="translated">在某些情况下,源视频流要求一定的方向是正确的。这包括像相机取景器这样的源,无论用户界面的其他部分如何旋转,显示的取景器都应该与现实相符。</target>
        </trans-unit>
        <trans-unit id="48421f7799ae214cef7492b1c1b972a28a837934" translate="yes" xml:space="preserve">
          <source>In some cases the video buffer might be stored in video memory or otherwise inaccessible memory, so it is necessary to map the buffer before accessing the pixel data. This may involve copying the contents around, so avoid mapping and unmapping unless required.</source>
          <target state="translated">在某些情况下,视频缓冲区可能存储在视频内存或其他不可访问的内存中,因此在访问像素数据之前有必要对缓冲区进行映射。这可能会涉及到复制内容,所以除非需要,否则要避免映射和取消映射。</target>
        </trans-unit>
        <trans-unit id="dfb5df4808e66665cfcb730202fb1c7050e20123" translate="yes" xml:space="preserve">
          <source>In some cases the video frame data might be stored in video memory or otherwise inaccessible memory, so it is necessary to map a frame before accessing the pixel data. This may involve copying the contents around, so avoid mapping and unmapping unless required.</source>
          <target state="translated">在某些情况下,视频帧数据可能存储在视频存储器或其他无法访问的存储器中,因此在访问像素数据之前有必要对帧进行映射。这可能会涉及到复制内容,所以除非必要,否则要避免映射和取消映射。</target>
        </trans-unit>
        <trans-unit id="14e9a4063cec4c7bef4f5348419948d27bf2ce39" translate="yes" xml:space="preserve">
          <source>In some cases this may cause unintended behavior. For example, a state that changes a view's</source>
          <target state="translated">在某些情况下,这可能会导致非预期的行为。例如,一个状态改变了视图的</target>
        </trans-unit>
        <trans-unit id="a550e6990b7577675be06e7842087f41604449fc" translate="yes" xml:space="preserve">
          <source>In some cases this setting may change automatically as a result of temperature or battery conditions.</source>
          <target state="translated">在某些情况下,该设置可能会因温度或电池条件而自动改变。</target>
        </trans-unit>
        <trans-unit id="2a6bb4d4e22cf5c7bd4c64610c78b9203a0596cc" translate="yes" xml:space="preserve">
          <source>In some cases when application is complex e.g. it's scene graph contains lot's of Items, scene graph can consume more stack memory than what is available by default for the render thread. Default stack memory size is 64KB. Using the environment variable QSG_RENDERTHREAD_STACK_SIZE, it is possible to increase the stack size available for the scene graph render thread.</source>
          <target state="translated">在某些情况下,当应用程序是复杂的,例如它的场景图包含了大量的项目,场景图可能会消耗比渲染线程默认可用的更多的栈内存。默认的栈内存大小是64KB。使用环境变量QSG_RENDERTHREAD_STACK_SIZE,可以增加场景图渲染线程的堆栈内存大小。</target>
        </trans-unit>
        <trans-unit id="d6f8a4824c8690795d32ad499948e9a1f3af1ecd" translate="yes" xml:space="preserve">
          <source>In some cases you may choose to use a Behavior to animate a property change caused by a state change. While this works well for some situations, in other situations it may lead to unexpected behavior.</source>
          <target state="translated">在某些情况下,您可能会选择使用行为来对状态变化引起的属性变化进行动画。虽然这在某些情况下效果很好,但在其他情况下可能会导致意外的行为。</target>
        </trans-unit>
        <trans-unit id="54c15ac83d44ce37a0189c329d15b4f928be27be" translate="yes" xml:space="preserve">
          <source>In some cases you may want to modify the value of a property when a certain condition is met but leave it unmodified otherwise. Often, it's not possible to do this with direct bindings, as you have to supply values for all possible branches.</source>
          <target state="translated">在某些情况下,您可能希望在满足某个条件时修改某个属性的值,而在其他情况下不修改它。通常情况下,使用直接绑定不可能做到这一点,因为你必须为所有可能的分支提供值。</target>
        </trans-unit>
        <trans-unit id="2bda29f7e738612273aabfbb087124bd5833039f" translate="yes" xml:space="preserve">
          <source>In some cases you may wish to use a Loader within a view delegate to improve delegate loading performance. This works well in most cases, but there is one important issue to be aware of related to the &lt;a href=&quot;qml-qtqml-component#creation-context&quot;&gt;creation context&lt;/a&gt; of a Component.</source>
          <target state="translated">在某些情况下，您可能希望在视图委托中使用加载程序以提高委托加载性能。在大多数情况下，此方法效果很好，但是要注意与组件的&lt;a href=&quot;qml-qtqml-component#creation-context&quot;&gt;创建上下文&lt;/a&gt;有关的一个重要问题。</target>
        </trans-unit>
        <trans-unit id="874c41570555235045f45e49cda6de0c4b8c78af" translate="yes" xml:space="preserve">
          <source>In some cases, a complex application (for example, using a lot of custom QML components) may cause the QML loader thread to consume stack memory more than the 32 KB available by default. Using the environment variable &lt;code&gt;QML_LOADERTHREAD_STACK_SIZE&lt;/code&gt;, it is possible to increase the stack size available for the QML loader thread.</source>
          <target state="translated">在某些情况下，复杂的应用程序（例如，使用许多自定义QML组件）可能导致QML加载器线程消耗的堆栈内存多于默认情况下可用的32 KB。使用环境变量 &lt;code&gt;QML_LOADERTHREAD_STACK_SIZE&lt;/code&gt; ，可以增加可用于QML加载器线程的堆栈大小。</target>
        </trans-unit>
        <trans-unit id="3b9d9f5d1235fa67ccc3f54fbf189565a53279e2" translate="yes" xml:space="preserve">
          <source>In some cases, it can be useful to be able to detect when the property has actually been assigned the value defined by a state.</source>
          <target state="translated">在某些情况下,能够检测到属性何时被实际分配了状态所定义的值是很有用的。</target>
        </trans-unit>
        <trans-unit id="b65be868fcbadc305bdc3cdebf4fd7214cd94b94" translate="yes" xml:space="preserve">
          <source>In some cases, it is relevant when a layout is added to a widget. When you set the widget of a &lt;a href=&quot;qdockwidget&quot;&gt;QDockWidget&lt;/a&gt; or a &lt;a href=&quot;qscrollarea&quot;&gt;QScrollArea&lt;/a&gt; (with &lt;a href=&quot;qdockwidget#setWidget&quot;&gt;QDockWidget::setWidget&lt;/a&gt;() and &lt;a href=&quot;qscrollarea#setWidget&quot;&gt;QScrollArea::setWidget&lt;/a&gt;()), the layout must already have been set on the widget. If not, the widget will not be visible.</source>
          <target state="translated">在某些情况下，将布局添加到窗口小部件很重要。当您设置&lt;a href=&quot;qdockwidget&quot;&gt;QDockWidget&lt;/a&gt;或&lt;a href=&quot;qscrollarea&quot;&gt;QScrollArea&lt;/a&gt;的窗口小部件（使用&lt;a href=&quot;qdockwidget#setWidget&quot;&gt;QDockWidget :: setWidget&lt;/a&gt;（）和&lt;a href=&quot;qscrollarea#setWidget&quot;&gt;QScrollArea :: setWidget&lt;/a&gt;（））时，必须已经在窗口小部件上设置了布局。如果没有，则小部件将不可见。</target>
        </trans-unit>
        <trans-unit id="5dfcad5e5edafeb77b0cca023961159f6802708d" translate="yes" xml:space="preserve">
          <source>In some cases, such as when reparenting between items with clipping enabled, it is useful to animate the parent change via another item that does not have clipping enabled. Such an item can be set using the &lt;a href=&quot;qml-qtquick-parentanimation#via-prop&quot;&gt;via&lt;/a&gt; property.</source>
          <target state="translated">在某些情况下，例如在启用了裁剪的项目之间进行父级化时，通过另一个未启用裁剪的项目为父级更改设置动画非常有用。可以使用&lt;a href=&quot;qml-qtquick-parentanimation#via-prop&quot;&gt;via&lt;/a&gt;属性设置此类项目。</target>
        </trans-unit>
        <trans-unit id="f1bd3abbd5b8e817487ee69c4f7e2e19dee37c4f" translate="yes" xml:space="preserve">
          <source>In some cases, such as with Unix domain sockets on Linux, the access to the socket will be determined by file system permissions, and are created based on the umask. Setting the access flags will overide this and will restrict or permit access as specified.</source>
          <target state="translated">在某些情况下,比如Linux上的Unix域套接字,对套接字的访问将由文件系统权限决定,并根据umask创建。设置访问标志将覆盖这一点,并将限制或允许指定的访问。</target>
        </trans-unit>
        <trans-unit id="654ac9421c46d54fbbfa686e76d8aba1cf1a8945" translate="yes" xml:space="preserve">
          <source>In some cases, the content dimensions can be automatically set based on the &lt;a href=&quot;qml-qtquick-item#childrenRect.width-prop&quot;&gt;childrenRect.width&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-item#childrenRect.height-prop&quot;&gt;childrenRect.height&lt;/a&gt; properties of the &lt;a href=&quot;qml-qtquick-flickable#contentItem-prop&quot;&gt;contentItem&lt;/a&gt;. For example, the previous snippet could be rewritten with:</source>
          <target state="translated">在某些情况下，可以基于&lt;a href=&quot;qml-qtquick-flickable#contentItem-prop&quot;&gt;contentItem&lt;/a&gt;的&lt;a href=&quot;qml-qtquick-item#childrenRect.width-prop&quot;&gt;childrenRect.width&lt;/a&gt;和&lt;a href=&quot;qml-qtquick-item#childrenRect.height-prop&quot;&gt;childrenRect.height&lt;/a&gt;属性自动设置内容尺寸。例如，先前的代码段可以用以下代码重写：</target>
        </trans-unit>
        <trans-unit id="5434ee63284e7d3858767cee9240a2601f7fb402" translate="yes" xml:space="preserve">
          <source>In some cases, the impact of increased memory pressure can be extreme. In some situations, trading off memory usage for an assumed performance gain can result in increased page-thrash or cache-thrash, causing a huge reduction in performance. It is always necessary to benchmark the impact of trade-offs carefully in order to determine which solution is best in a given situation.</source>
          <target state="translated">在某些情况下,增加内存压力的影响可能是极端的。在某些情况下,用内存使用量来换取假设的性能提升,可能会导致页面乱码或缓存乱码的增加,从而导致性能的大幅下降。为了确定在特定情况下哪种解决方案是最好的,总是有必要仔细地对折衷的影响进行基准测试。</target>
        </trans-unit>
        <trans-unit id="4968ba7999c7294d40c547303ad493ab2ba4767a" translate="yes" xml:space="preserve">
          <source>In some circumstances, for special protocols, it's the local port number can also be used with a query of type &lt;a href=&quot;qnetworkproxyquery#QueryType-enum&quot;&gt;QNetworkProxyQuery::TcpSocket&lt;/a&gt;. When that happens, the socket is indicating it wishes to use the port number</source>
          <target state="translated">在某些情况下，对于特殊协议，它的本地端口号也可以与&lt;a href=&quot;qnetworkproxyquery#QueryType-enum&quot;&gt;QNetworkProxyQuery :: TcpSocket&lt;/a&gt;类型的查询一起使用。发生这种情况时，套接字指示它希望使用端口号</target>
        </trans-unit>
        <trans-unit id="3523f113c028f04478865a8bb71a266b290cfdb5" translate="yes" xml:space="preserve">
          <source>In some circumstances, the called slot may not be able to process the request immediately. This is frequently the case when the request involves an I/O or networking operation which may block.</source>
          <target state="translated">在某些情况下,被调用的插槽可能无法立即处理请求。当请求涉及I/O或网络操作时,这种情况经常发生,因为这种操作可能会阻塞。</target>
        </trans-unit>
        <trans-unit id="241a6483756c0179a4c7b61ebbe5bef1af1389f9" translate="yes" xml:space="preserve">
          <source>In some languages the order of arguments may need to change, and this can easily be achieved by changing the order of the % arguments. For example:</source>
          <target state="translated">在某些语言中,参数的顺序可能需要改变,这可以通过改变%参数的顺序轻松实现。例如</target>
        </trans-unit>
        <trans-unit id="1fb478c17aaf1c2efe6aa5581ab0395bfd01ce54" translate="yes" xml:space="preserve">
          <source>In some occasions text edits should not allow the user to input tabulators or change indentation using the &lt;b&gt;Tab&lt;/b&gt; key, as this breaks the focus chain. The default is false.</source>
          <target state="translated">在某些情况下，文本编辑不应允许用户使用&lt;b&gt;Tab&lt;/b&gt;键输入制表符或更改缩进，因为这会破坏焦点链。默认为false。</target>
        </trans-unit>
        <trans-unit id="fc8e9311f6cecac5035d0591006fca709f8aa184" translate="yes" xml:space="preserve">
          <source>In some scenarios, rendering errors may be introduced and/or performance can suffer in this mode. When objects intersect or overlap each other, depth testing and the two pass rendering technique are necessary to achieve the correct results.</source>
          <target state="translated">在某些情况下,在这种模式下可能会引入渲染错误和/或性能会受到影响。当物体相互交错或重叠时,需要进行深度测试和两遍渲染技术,以获得正确的结果。</target>
        </trans-unit>
        <trans-unit id="b800f8d0d60a9c558d98902c62bde05c9459de23" translate="yes" xml:space="preserve">
          <source>In some situations it is useful to group &lt;a href=&quot;qaction&quot;&gt;QAction&lt;/a&gt; objects together. For example, if you have a &lt;b&gt;Left Align&lt;/b&gt; action, a &lt;b&gt;Right Align&lt;/b&gt; action, a &lt;b&gt;Justify&lt;/b&gt; action, and a &lt;b&gt;Center&lt;/b&gt; action, only one of these actions should be active at any one time. One simple way of achieving this is to group the actions together in an action group, inheriting QActionGroup.</source>
          <target state="translated">在某些情况下，将&lt;a href=&quot;qaction&quot;&gt;QAction&lt;/a&gt;对象分组在一起很有用。例如，如果您具有&amp;ldquo;&lt;b&gt;左对齐&amp;rdquo;&lt;/b&gt;动作，&amp;ldquo;&lt;b&gt;右对齐&amp;rdquo;&lt;/b&gt;动作，&amp;ldquo;&lt;b&gt;对齐&amp;rdquo;&lt;/b&gt;动作和&amp;ldquo;&lt;b&gt;居中&amp;rdquo;&lt;/b&gt;动作，则这些动作中的任何一个在任何时候都应该处于活动状态。一种简单的实现方法是继承QActionGroup，将动作分组到一个动作组中。</target>
        </trans-unit>
        <trans-unit id="6233e700f5658deeeb11e052468b2ab04255843d" translate="yes" xml:space="preserve">
          <source>In some situations it is useful to group &lt;a href=&quot;qaction&quot;&gt;QAction&lt;/a&gt; objects together. For example, if you have a &lt;b&gt;Left Align&lt;/b&gt; action, a &lt;b&gt;Right Align&lt;/b&gt; action, a &lt;b&gt;Justify&lt;/b&gt; action, and a &lt;b&gt;Center&lt;/b&gt; action, only one of these actions should be active at any one time. One simple way of achieving this is to group the actions together in an action group.</source>
          <target state="translated">在某些情况下，将&lt;a href=&quot;qaction&quot;&gt;QAction&lt;/a&gt;对象分组在一起很有用。例如，如果您具有&amp;ldquo; &lt;b&gt;左对齐&amp;rdquo;&lt;/b&gt;动作，&amp;ldquo; &lt;b&gt;右对齐&amp;rdquo;&lt;/b&gt;动作，&amp;ldquo; &lt;b&gt;对齐&amp;rdquo;&lt;/b&gt;动作和&amp;ldquo; &lt;b&gt;居中&amp;rdquo;&lt;/b&gt;动作，则这些动作中的任何一个在任何时候都应该处于活动状态。实现此目的的一种简单方法是将操作分组到一个操作组中。</target>
        </trans-unit>
        <trans-unit id="ec01e3125218c7aa7e4acb9ff7f7ab1327614746" translate="yes" xml:space="preserve">
          <source>In some situations, it is possible to trade-off increased memory usage for decreased processing time. For example, caching the result of a symbol lookup used in a tight loop to a temporary variable in a JavaScript expression will result in a significant performance improvement when evaluating that expression, but it involves allocating a temporary variable. In some cases, these trade-offs are sensible (such as the case above, which is almost always sensible), but in other cases it may be better to allow processing to take slightly longer in order to avoid increasing the memory pressure on the system.</source>
          <target state="translated">在某些情况下,可以用增加的内存使用量来换取减少的处理时间。例如,将紧缩循环中使用的符号查找结果缓存到JavaScript表达式中的临时变量中,在评估该表达式时将会有显著的性能提升,但这涉及到分配一个临时变量。在某些情况下,这些权衡是明智的(比如上面的情况,几乎都是明智的),但在其他情况下,为了避免增加系统的内存压力,让处理时间稍微长一点可能更好。</target>
        </trans-unit>
        <trans-unit id="3a65e171ba344d27c2bc3135a6656497e102c1bf" translate="yes" xml:space="preserve">
          <source>In some situations, it is useful to give a translation context explicitly by fully qualifying the call to tr(); for example:</source>
          <target state="translated">在某些情况下,通过完全限定对tr()的调用来显式地给出翻译上下文是很有用的;例如。</target>
        </trans-unit>
        <trans-unit id="975078149e2e7255befaef187ec5cad85153778c" translate="yes" xml:space="preserve">
          <source>In some situations, the state of one toggle action should depend on the state of others. For example, &quot;Left Align&quot;, &quot;Center&quot; and &quot;Right Align&quot; toggle actions are mutually exclusive. To achieve exclusive toggling, add the relevant toggle actions to a &lt;a href=&quot;qactiongroup&quot;&gt;QActionGroup&lt;/a&gt; with the &lt;a href=&quot;qactiongroup#exclusive-prop&quot;&gt;QActionGroup::exclusive&lt;/a&gt; property set to true.</source>
          <target state="translated">在某些情况下，一个切换动作的状态应取决于其他动作的状态。例如，&amp;ldquo;左对齐&amp;rdquo;，&amp;ldquo;居中&amp;rdquo;和&amp;ldquo;右对齐&amp;rdquo;切换动作是互斥的。为了达到独占来回切换，添加相关的切换动作的&lt;a href=&quot;qactiongroup&quot;&gt;QActionGroup&lt;/a&gt;与&lt;a href=&quot;qactiongroup#exclusive-prop&quot;&gt;QActionGroup ::专属&lt;/a&gt;属性设置为true。</target>
        </trans-unit>
        <trans-unit id="323c27f7a345a0e27d2fef8ef7183d984fb16109" translate="yes" xml:space="preserve">
          <source>In some situations, the state of one toggle action should depend on the state of others. For example, &quot;Left Align&quot;, &quot;Center&quot; and &quot;Right Align&quot; toggle actions are mutually exclusive. To achieve exclusive toggling, add the relevant toggle actions to a &lt;a href=&quot;qactiongroup&quot;&gt;QActionGroup&lt;/a&gt; with the QActionGroup::exclusive property set to true.</source>
          <target state="translated">在某些情况下，一个切换动作的状态应取决于其他动作的状态。例如，&amp;ldquo;左对齐&amp;rdquo;，&amp;ldquo;居中&amp;rdquo;和&amp;ldquo;右对齐&amp;rdquo;切换动作是互斥的。为了达到独占来回切换，添加相关的切换动作的&lt;a href=&quot;qactiongroup&quot;&gt;QActionGroup&lt;/a&gt;与QActionGroup ::专属属性设置为true。</target>
        </trans-unit>
        <trans-unit id="da099b7b9b3cf8dd0ef98773710f3f41aa5b9afe" translate="yes" xml:space="preserve">
          <source>In some situations, the width of regions 2 and 8 may not be an exact multiple of the width of the corresponding regions in the source image. Similarly, the height of regions 4 and 6 may not be an exact multiple of the height of the corresponding regions. It can be useful to use &lt;a href=&quot;qml-qtquick-borderimage#horizontalTileMode-prop&quot;&gt;BorderImage.Round&lt;/a&gt; instead of &lt;a href=&quot;qml-qtquick-borderimage#horizontalTileMode-prop&quot;&gt;BorderImage.Repeat&lt;/a&gt; in cases like these.</source>
          <target state="translated">在某些情况下，区域2和8的宽度可能不是源图像中相应区域宽度的精确倍数。类似地，区域4和6的高度可以不是对应区域的高度的精确倍数。在这种情况下，使用&lt;a href=&quot;qml-qtquick-borderimage#horizontalTileMode-prop&quot;&gt;BorderImage.Round&lt;/a&gt;代替&lt;a href=&quot;qml-qtquick-borderimage#horizontalTileMode-prop&quot;&gt;BorderImage.Repeat&lt;/a&gt;可能会很有用。</target>
        </trans-unit>
        <trans-unit id="cccf8fea954dfdae839b9b461ce87885d251e3ef" translate="yes" xml:space="preserve">
          <source>In some special cases it may be necessary to override the Vulkan library name. This can be achieved by setting the &lt;code&gt;QT_VULKAN_LIB&lt;/code&gt; environment variable.</source>
          <target state="translated">在某些特殊情况下，可能有必要覆盖Vulkan库名称。这可以通过设置 &lt;code&gt;QT_VULKAN_LIB&lt;/code&gt; 环境变量来实现。</target>
        </trans-unit>
        <trans-unit id="597877827cd82985b7564fa6e61767164b61770b" translate="yes" xml:space="preserve">
          <source>In some state machines it can be useful to focus the attention on assigning properties in states, not on restoring them when the state is no longer active. If you know that a property should always be restored to its initial value when the machine enters a state that does not explicitly give the property a value, you can set the global restore policy to &lt;a href=&quot;qstate#RestorePolicy-enum&quot;&gt;QStateMachine::RestoreProperties&lt;/a&gt;.</source>
          <target state="translated">在某些状态机中，将注意力集中在分配状态中的属性上，而不是在状态不再活动时恢复它们上，可能会很有用。如果您知道当机器进入未显式赋予该属性值的状态时应始终将其恢复为初始值，则可以将全局恢复策略设置为&lt;a href=&quot;qstate#RestorePolicy-enum&quot;&gt;QStateMachine :: RestoreProperties&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ef8acd187a435dd6a714e2f0e2e4336b32bbc6db" translate="yes" xml:space="preserve">
          <source>In some use cases it may be necessary to turn the interface off despite of open sessions. This can be achieved by calling &lt;a href=&quot;qnetworksession#stop&quot;&gt;stop()&lt;/a&gt;. An example use case could be a network manager type of application allowing the user to control the overall state of the devices connectivity.</source>
          <target state="translated">在某些用例中，尽管有打开的会话，可能仍需要关闭接口。这可以通过调用&lt;a href=&quot;qnetworksession#stop&quot;&gt;stop（）&lt;/a&gt;来实现。示例用例可以是允许用户控制设备连接的总体状态的应用程序的网络管理器类型。</target>
        </trans-unit>
        <trans-unit id="6c0bc9e6bd03c67533a62525483e2f23d095adcd" translate="yes" xml:space="preserve">
          <source>In some use cases the horizontal axis grid is mostly covered by the surface, so it can be more useful to display the horizontal axis grid on top of the graph rather than on the bottom. A typical use case for this is showing 2D spectrograms using orthoGraphic projection with a top-down viewpoint.</source>
          <target state="translated">在某些用例中,水平轴网格大部分被表面覆盖,因此将水平轴网格显示在图形的顶部而不是底部可能更有用。一个典型的用例是使用正图形投影,以自上而下的视角显示二维谱图。</target>
        </trans-unit>
        <trans-unit id="013226cabeda2af6ef8f227f857dcd13ebf3e1ea" translate="yes" xml:space="preserve">
          <source>In special cases tests may want to disable the processing of the events. This can be achieved by setting</source>
          <target state="translated">在特殊情况下,测试可能希望禁用事件的处理。这可以通过设置</target>
        </trans-unit>
        <trans-unit id="7452d49f64c970393bfd80306f87f3e26f44a0f2" translate="yes" xml:space="preserve">
          <source>In standard views, a</source>
          <target state="translated">在标准视图中,a</target>
        </trans-unit>
        <trans-unit id="ae4b097ff709c25e429ac49f202a71496bfc7f8a" translate="yes" xml:space="preserve">
          <source>In such Qt builds, many Qt shared libraries, and also Qt applications will have a dependency to opengl32.dll, and therefore using an alternative library is not possible.</source>
          <target state="translated">在这样的Qt构建中,许多Qt共享库以及Qt应用程序都会对opengl32.dll产生依赖,因此使用替代库是不可能的。</target>
        </trans-unit>
        <trans-unit id="164a5aefb4e39073a4a04fead6f543c66536fbb1" translate="yes" xml:space="preserve">
          <source>In such cases, the following yields the expected results:</source>
          <target state="translated">在这种情况下,下面就会产生预期的结果。</target>
        </trans-unit>
        <trans-unit id="8f544ece13de7f5c398d0ce0f69c0fcaea9d7c95" translate="yes" xml:space="preserve">
          <source>In summary, &lt;a href=&quot;qvarlengtharray&quot;&gt;QVarLengthArray&lt;/a&gt; is a low-level optimization class that only makes sense in very specific cases. It is used a few places inside Qt and was added to Qt's public API for the convenience of advanced users.</source>
          <target state="translated">总之，&lt;a href=&quot;qvarlengtharray&quot;&gt;QVarLengthArray&lt;/a&gt;是一个低级优化类，仅在非常特殊的情况下才有意义。它在Qt内的几个地方使用，并已添加到Qt的公共API中，以方便高级用户使用。</target>
        </trans-unit>
        <trans-unit id="01404b1665ff5bee8b39009a3dbb648e5cfcb96f" translate="yes" xml:space="preserve">
          <source>In summary, QVarLengthArray is a low-level optimization class that only makes sense in very specific cases. It is used a few places inside Qt and was added to Qt's public API for the convenience of advanced users.</source>
          <target state="translated">总之,QVarLengthArray是一个低级的优化类,只有在非常特殊的情况下才有意义。它在Qt内部使用的地方很少,为了方便高级用户,它被添加到Qt的公共API中。</target>
        </trans-unit>
        <trans-unit id="f370d8fd1ae76025ade06837edabb5a99c24598d" translate="yes" xml:space="preserve">
          <source>In summary, to set an icon, use</source>
          <target state="translated">总之,要设置一个图标,使用</target>
        </trans-unit>
        <trans-unit id="fed7d9752b11297f2deeaad7c01533dae2c3f1b9" translate="yes" xml:space="preserve">
          <source>In syntactic terms, a QML object type is one which can be used to declare an object by specifying the</source>
          <target state="translated">在语法上,QML对象类型是一种可以通过指定的</target>
        </trans-unit>
        <trans-unit id="b56fa35038d379699c4022d19966422243f5e330" translate="yes" xml:space="preserve">
          <source>In terms of stacking order, this component is displayed above the delegate and highlight components, but below the foreground component.</source>
          <target state="translated">在堆叠顺序上,该组件显示在委托和高亮组件之上,但低于前景组件。</target>
        </trans-unit>
        <trans-unit id="457e23421e8521cf6f1ded404af0fb789b691073" translate="yes" xml:space="preserve">
          <source>In that case, &lt;a href=&quot;qml-qtcharts-pieseries#at-method&quot;&gt;PieSeries.at()&lt;/a&gt; or &lt;a href=&quot;qml-qtcharts-pieseries#find-method&quot;&gt;PieSeries.find&lt;/a&gt; can be used to access the properties of an individual &lt;a href=&quot;qml-qtcharts-pieslice&quot;&gt;PieSlice&lt;/a&gt; instance.</source>
          <target state="translated">在这种情况下，可以使用&lt;a href=&quot;qml-qtcharts-pieseries#at-method&quot;&gt;PieSeries.at（）&lt;/a&gt;或&lt;a href=&quot;qml-qtcharts-pieseries#find-method&quot;&gt;PieSeries.find&lt;/a&gt;来访问单个&lt;a href=&quot;qml-qtcharts-pieslice&quot;&gt;PieSlice&lt;/a&gt;实例的属性。</target>
        </trans-unit>
        <trans-unit id="9f0c0bbbbb610108981afd9c9bfd9139b4fbbf67" translate="yes" xml:space="preserve">
          <source>In that case, &lt;a href=&quot;qml-qtcharts-pieseries#at-method&quot;&gt;PieSeries.at()&lt;/a&gt; or &lt;a href=&quot;qml-qtcharts-pieseries#find-method&quot;&gt;PieSeries.find&lt;/a&gt; can be used to access the properties of an individual PieSlice instance.</source>
          <target state="translated">在这种情况下，可以使用&lt;a href=&quot;qml-qtcharts-pieseries#at-method&quot;&gt;PieSeries.at（）&lt;/a&gt;或&lt;a href=&quot;qml-qtcharts-pieseries#find-method&quot;&gt;PieSeries.find&lt;/a&gt;访问单个PieSlice实例的属性。</target>
        </trans-unit>
        <trans-unit id="5790208d3978b524af92d93f41391c3573ec2c57" translate="yes" xml:space="preserve">
          <source>In that example, the thread will exit after the run function has returned. There will not be any event loop running in the thread unless you call &lt;a href=&quot;qthread#exec&quot;&gt;exec&lt;/a&gt;().</source>
          <target state="translated">在该示例中，线程将在run函数返回后退出。除非您调用&lt;a href=&quot;qthread#exec&quot;&gt;exec&lt;/a&gt;（），否则线程中不会运行任何事件循环。</target>
        </trans-unit>
        <trans-unit id="b6abefb0ebc02351d5d08f8505d9c39811bfa807" translate="yes" xml:space="preserve">
          <source>In the</source>
          <target state="translated">在</target>
        </trans-unit>
        <trans-unit id="0f13869d816e7c62f6a51e2c34e2ea27e0c6e194" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtdbus-complexpingpong-example.html#&quot;&gt;D-Bus Complex Ping Pong Example&lt;/a&gt;, &lt;code&gt;complexpong.h&lt;/code&gt; and &lt;code&gt;complexpong.cpp&lt;/code&gt; show an implementation of &lt;a href=&quot;qdbusabstractadaptor&quot;&gt;QDBusAbstractAdaptor&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;https://doc.qt.io/qt-5.13/qtdbus-complexpingpong-example.html#&quot;&gt;d-总线复乒乓实施例&lt;/a&gt;， &lt;code&gt;complexpong.h&lt;/code&gt; 和 &lt;code&gt;complexpong.cpp&lt;/code&gt; 显示的实施&lt;a href=&quot;qdbusabstractadaptor&quot;&gt;QDBusAbstractAdaptor&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ec35b4a3a60508bb357e68a03513ab97f33987bb" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtdbus-complexpingpong-example.html&quot;&gt;D-Bus Complex Ping Pong Example&lt;/a&gt;, &lt;code&gt;complexpong.h&lt;/code&gt; and &lt;code&gt;complexpong.cpp&lt;/code&gt; show an implementation of &lt;a href=&quot;qdbusabstractadaptor&quot;&gt;QDBusAbstractAdaptor&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;https://doc.qt.io/qt-5.15/qtdbus-complexpingpong-example.html&quot;&gt;d-总线复乒乓实施例&lt;/a&gt;， &lt;code&gt;complexpong.h&lt;/code&gt; 和 &lt;code&gt;complexpong.cpp&lt;/code&gt; 显示的实施&lt;a href=&quot;qdbusabstractadaptor&quot;&gt;QDBusAbstractAdaptor&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d5aa6e54082c84913b42e7e887fa2cf527cc4e23" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtdbus-complexpingpong-example.html&quot;&gt;D-Bus Complex Ping Pong Example&lt;/a&gt;, &lt;code&gt;complexpong.h&lt;/code&gt; and &lt;code&gt;complexpong.cpp&lt;/code&gt; show an implementation of &lt;a href=&quot;qdbusabstractadaptor&quot;&gt;QDBusAbstractAdaptor&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;https://doc.qt.io/qt-6.0/qtdbus-complexpingpong-example.html&quot;&gt;d-总线复乒乓实施例&lt;/a&gt;， &lt;code&gt;complexpong.h&lt;/code&gt; 和 &lt;code&gt;complexpong.cpp&lt;/code&gt; 显示的实施&lt;a href=&quot;qdbusabstractadaptor&quot;&gt;QDBusAbstractAdaptor&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="162bc0b4a098f3761ef3249d00dace83612c0945" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;qabstracttransition#eventTest&quot;&gt;eventTest()&lt;/a&gt; reimplementation, we first check if the event type is the desired one; if so, we cast the event to a &lt;code&gt;StringEvent&lt;/code&gt; and perform the string comparison.</source>
          <target state="translated">在&lt;a href=&quot;qabstracttransition#eventTest&quot;&gt;eventTest（）&lt;/a&gt;重新实现中，我们首先检查事件类型是否是所需的；如果是这样，我们将事件转换为 &lt;code&gt;StringEvent&lt;/code&gt; 并执行字符串比较。</target>
        </trans-unit>
        <trans-unit id="57e431c91e3a785910255234cef24a4c0ecd15c4" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; / &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; world, it is some times favorable to cache complex content in a pixmap, image or texture. In Qt Quick, because of the techniques already applied by the &lt;a href=&quot;qtquick-visualcanvas-scenegraph-renderer#&quot;&gt;scene graph renderer&lt;/a&gt;, this will in most cases not be the case. Excessive draw calls are already reduced because of batching and a cache will in most cases end up blending more pixels than the original content. The overhead of rendering to an offscreen and the blending involved with drawing the resulting texture is therefore often more costly than simply letting the item and its children be drawn normally.</source>
          <target state="translated">在&lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; / &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt;世界中，在像素图，图像或纹理中缓存复杂内容有时是有利的。在Qt Quick中，由于&lt;a href=&quot;qtquick-visualcanvas-scenegraph-renderer#&quot;&gt;场景图渲染器&lt;/a&gt;已经应用了技术，因此在大多数情况下并非如此。由于批量处理，已经减少了过多的绘制调用，并且在大多数情况下，缓存最终将混合比原始内容更多的像素。因此，与简单地正常绘制项目及其子项相比，渲染到屏幕外的开销以及与绘制最终纹理有关的混合通常会更加昂贵。</target>
        </trans-unit>
        <trans-unit id="a2244c8990bf5c7b0af9090a75b57eab78f7c963" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; / &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; world, it is sometimes favorable to cache complex content in a pixmap, image or texture. In Qt Quick, because of the techniques already applied by the &lt;a href=&quot;qtquick-visualcanvas-scenegraph-renderer&quot;&gt;scene graph renderer&lt;/a&gt;, this will in most cases not be the case. Excessive draw calls are already reduced because of batching and a cache will in most cases end up blending more pixels than the original content. The overhead of rendering to an offscreen and the blending involved with drawing the resulting texture is therefore often more costly than simply letting the item and its children be drawn normally.</source>
          <target state="translated">在&lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; / &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt;世界中，有时最好在像素图，图像或纹理中缓存复杂的内容。在Qt Quick中，由于&lt;a href=&quot;qtquick-visualcanvas-scenegraph-renderer&quot;&gt;场景图形渲染器&lt;/a&gt;已经应用了技术，因此在大多数情况下并非如此。由于批量处理，已经减少了过多的绘制调用，并且在大多数情况下，缓存最终将混合比原始内容更多的像素。因此，与简单地正常绘制项目及其子项相比，渲染到屏幕外的开销以及与绘制最终纹理有关的混合的开销通常更高。</target>
        </trans-unit>
        <trans-unit id="eea9e8dff487c0e0fb359df06250577b27da332a" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; / &lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;QWidget&lt;/a&gt; world, it is sometimes favorable to cache complex content in a pixmap, image or texture. In Qt Quick, because of the techniques already applied by the &lt;a href=&quot;qtquick-visualcanvas-scenegraph-renderer&quot;&gt;scene graph renderer&lt;/a&gt;, this will in most cases not be the case. Excessive draw calls are already reduced because of batching and a cache will in most cases end up blending more pixels than the original content. The overhead of rendering to an offscreen and the blending involved with drawing the resulting texture is therefore often more costly than simply letting the item and its children be drawn normally.</source>
          <target state="translated">在&lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; / &lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;QWidget&lt;/a&gt;世界中，有时最好在像素图，图像或纹理中缓存复杂的内容。在Qt Quick中，由于&lt;a href=&quot;qtquick-visualcanvas-scenegraph-renderer&quot;&gt;场景图形渲染器&lt;/a&gt;已经应用了技术，因此在大多数情况下并非如此。由于批量处理，已经减少了过多的绘制调用，并且在大多数情况下，缓存最终将混合比原始内容更多的像素。因此，与简单地正常绘制项目及其子项相比，渲染到屏幕外的开销以及与绘制最终纹理有关的混合的开销通常更高。</target>
        </trans-unit>
        <trans-unit id="37d939b74cde175b71c6be9dd50c53f23af1da98" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;qsensor#AxesOrientationMode-enum&quot;&gt;AutomaticOrientation&lt;/a&gt; mode, the readings are rotated based on the screen orientation, and therefore this property will be equal to the current screen orientation.</source>
          <target state="translated">在&lt;a href=&quot;qsensor#AxesOrientationMode-enum&quot;&gt;AutomaticOrientation&lt;/a&gt;模式下，读数将根据屏幕方向旋转，因此此属性将等于当前屏幕方向。</target>
        </trans-unit>
        <trans-unit id="04f88163784997d8102c2cef5150b940a5e480ff" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;qsensor#AxesOrientationMode-enum&quot;&gt;UserOrientation&lt;/a&gt; mode, the readings are rotated based on the &lt;a href=&quot;qsensor#userOrientation-prop&quot;&gt;userOrientation&lt;/a&gt; property, and therefore this property is equal to the &lt;a href=&quot;qsensor#userOrientation-prop&quot;&gt;userOrientation&lt;/a&gt; property.</source>
          <target state="translated">在&lt;a href=&quot;qsensor#AxesOrientationMode-enum&quot;&gt;UserOrientation&lt;/a&gt;模式下，读数将根据&lt;a href=&quot;qsensor#userOrientation-prop&quot;&gt;userOrientation&lt;/a&gt;属性进行旋转，因此该属性等于&lt;a href=&quot;qsensor#userOrientation-prop&quot;&gt;userOrientation&lt;/a&gt;属性。</target>
        </trans-unit>
        <trans-unit id="bdd706a711fa67c209b0d0c2e27f9e33fd367aec" translate="yes" xml:space="preserve">
          <source>In the &lt;b&gt;App IDs&lt;/b&gt; tab of the &lt;b&gt;Developer Certificate, Identifiers, and Profiles&lt;/b&gt; manager, click the &lt;b&gt;+&lt;/b&gt; button to create a New App ID. This will open up the page to register a new iOS App ID.</source>
          <target state="translated">在&lt;b&gt;开发人员证书，标识符和配置文件&lt;/b&gt;管理器的&amp;ldquo; &lt;b&gt;应用程序ID&amp;rdquo;&lt;/b&gt;选项卡中，单击&lt;b&gt;+&lt;/b&gt;按钮创建新的应用程序ID。这将打开页面以注册新的iOS应用ID。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f5dd03a24aeea45b153e932a3e0af98ee040f6ff" translate="yes" xml:space="preserve">
          <source>In the &lt;b&gt;App Services&lt;/b&gt; area make sure that the &lt;b&gt;In-App Purchases&lt;/b&gt; is checked. Click &lt;b&gt;continue&lt;/b&gt; your to complete the App ID registration.</source>
          <target state="translated">在&amp;ldquo; &lt;b&gt;应用程序服务&amp;rdquo;&lt;/b&gt;区域中，确保已选中&amp;ldquo; &lt;b&gt;应用程序内购买&amp;rdquo;&lt;/b&gt;。单击&lt;b&gt;继续，&lt;/b&gt;以完成App ID注册。</target>
        </trans-unit>
        <trans-unit id="87da9cea12fe9772bb40ec9890618272be8747c5" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;.plist&lt;/code&gt; file, you can define some variables which qmake will replace with the relevant values:</source>
          <target state="translated">在 &lt;code&gt;.plist&lt;/code&gt; 文件中，您可以定义一些变量，qmake将用相关的值替换这些变量：</target>
        </trans-unit>
        <trans-unit id="69a9fd76bba1bfb4f2c2688ac8a1fb05feb5a9bb" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;.pro&lt;/code&gt; file for your application, you need the following entry:</source>
          <target state="translated">在您的应用程序的 &lt;code&gt;.pro&lt;/code&gt; 文件中，您需要输入以下内容：</target>
        </trans-unit>
        <trans-unit id="fc24789ab06f08f55a0fc23861c4c281824df067" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;service_main.cpp&lt;/code&gt; you could have the following:</source>
          <target state="translated">在 &lt;code&gt;service_main.cpp&lt;/code&gt; 中,您可以具有以下内容：</target>
        </trans-unit>
        <trans-unit id="cdbd9ad121de8e48729b5f47fbd44bf610991787" translate="yes" xml:space="preserve">
          <source>In the C++ file:</source>
          <target state="translated">在C++文件中。</target>
        </trans-unit>
        <trans-unit id="dd084a5753431273388f3e60f04ad68299a55461" translate="yes" xml:space="preserve">
          <source>In the DOM specification, this is the only way to create a non-null document. For historical reasons, Qt also allows to create the document using the default empty constructor. The resulting document is null, but becomes non-null when a factory function, for example &lt;a href=&quot;qdomdocument#createElement&quot;&gt;QDomDocument::createElement&lt;/a&gt;(), is called. The document also becomes non-null when setContent() is called.</source>
          <target state="translated">在DOM规范中，这是创建非null文档的唯一方法。由于历史原因，Qt还允许使用默认的空构造函数创建文档。结果文档为null，但在调用工厂函数（例如&lt;a href=&quot;qdomdocument#createElement&quot;&gt;QDomDocument :: createElement&lt;/a&gt;（））时变为非null 。调用setContent（）时，文档也将变为非null。</target>
        </trans-unit>
        <trans-unit id="5b680088f957473689841e354e1bde6dde64d84e" translate="yes" xml:space="preserve">
          <source>In the Gregorian calendar, there is no year 0. Dates in that year are considered invalid. The year -1 is the year &quot;1 before Christ&quot; or &quot;1 before common era.&quot; The day before 1 January 1 CE, QDate(1, 1, 1), is 31 December 1 BCE, QDate(-1, 12, 31). Various other calendars behave similarly; see &lt;a href=&quot;qcalendar#hasYearZero&quot;&gt;QCalendar::hasYearZero&lt;/a&gt;().</source>
          <target state="translated">在阳历中，没有0年。该年中的日期被认为是无效的。-1年是&amp;ldquo;基督之前1年&amp;rdquo;或&amp;ldquo;普通时代之前1年&amp;rdquo;。公元1年1月1日（QDate（1，1，1））的前一天是公元前12年1月31日QDate（-1，12，31）。其他各种日历的行为也类似。参见&lt;a href=&quot;qcalendar#hasYearZero&quot;&gt;QCalendar :: hasYearZero&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="d4d9f0a10c4c9a854dec147039223243e7e0b574" translate="yes" xml:space="preserve">
          <source>In the Idle state it's allowed to query camera capabilities, set capture resolution, codecs, etc.</source>
          <target state="translated">在闲置状态下,可以查询摄像机的功能,设置采集分辨率、编解码器等。</target>
        </trans-unit>
        <trans-unit id="8bb5ed0dca5213d6a5fe8fbcc42e41cf037c8b58" translate="yes" xml:space="preserve">
          <source>In the Idle state you can query camera capabilities, set capture resolution, codecs, and so on.</source>
          <target state="translated">在闲置状态下,可以查询摄像机功能,设置采集分辨率、编解码器等。</target>
        </trans-unit>
        <trans-unit id="f1db5d804394981f915e76bc91755412488c5ac5" translate="yes" xml:space="preserve">
          <source>In the Java style, the tab bar shape and label have the same bounding rectangle as &lt;code&gt;CE_TabBarTab&lt;/code&gt;. Notice that the tabs overlap with the tab widget frame. The base of the tab bar (if drawn) is the area where the tabs and frame overlap.</source>
          <target state="translated">在Java样式中，选项卡栏形状和标签与 &lt;code&gt;CE_TabBarTab&lt;/code&gt; 具有相同的边界矩形。请注意，选项卡与选项卡小部件框架重叠。标签栏（如果已绘制）的底部是标签和框架重叠的区域。</target>
        </trans-unit>
        <trans-unit id="7b4ece440c8d95e4496540cedfce41fe09a8d424" translate="yes" xml:space="preserve">
          <source>In the QML language syntax, there is a notion of &lt;a href=&quot;qtqml-syntax-objectattributes#attached-properties-and-attached-signal-handlers&quot;&gt;&lt;i&gt;attached properties&lt;/i&gt; and &lt;i&gt;attached signal handlers&lt;/i&gt;&lt;/a&gt;, which are additional attributes that are attached to an object. Essentially, such attributes are implemented and provided by an</source>
          <target state="translated">在QML语言语法中，存在&lt;a href=&quot;qtqml-syntax-objectattributes#attached-properties-and-attached-signal-handlers&quot;&gt;&lt;i&gt;附加属性&lt;/i&gt;和&lt;i&gt;附加信号处理程序&lt;/i&gt;&lt;/a&gt;的概念，它们是附加到对象的附加属性。本质上，此类属性是由</target>
        </trans-unit>
        <trans-unit id="9de994ae7065ff0629ef8698d52fae0aa9afa8c5" translate="yes" xml:space="preserve">
          <source>In the Unix/X11 AT-SPI implementation, applications become accessible when two conditions are met:</source>
          <target state="translated">在Unix/X11 AT-SPI的实现中,当满足两个条件时,应用程序可以被访问。</target>
        </trans-unit>
        <trans-unit id="ee9e81d8cc3e8a4adfc5e0c7748b208cfc6fe7c0" translate="yes" xml:space="preserve">
          <source>In the WHERE statement, each non-null field of</source>
          <target state="translated">在WHERE语句中,每个非空字段的</target>
        </trans-unit>
        <trans-unit id="6f6f7ad4674c4c4505b592190446eb701f994122" translate="yes" xml:space="preserve">
          <source>In the Widget Editing Mode, objects can be dragged from the main window's widget box to a form, edited, resized, dragged around on the form, and even dragged between forms. Object properties can be modified interactively, so that changes can be seen immediately. The editing interface is intuitive for simple operations, yet it still supports Qt's powerful layout facilities.</source>
          <target state="translated">在 &quot;小部件编辑模式 &quot;中,可以将对象从主窗口的小部件框拖到窗体上,进行编辑、调整大小、在窗体上拖动,甚至在窗体之间拖动。对象的属性可以交互式修改,因此可以立即看到变化。编辑界面直观,操作简单,但它仍然支持Qt强大的布局设施。</target>
        </trans-unit>
        <trans-unit id="67556c80897d5a3a2c3176910f8fb2db8eb1c615" translate="yes" xml:space="preserve">
          <source>In the above assignment, the value of &lt;code&gt;PWD&lt;/code&gt; is read immediately when the project file is processed, but &lt;code&gt;$(PWD)&lt;/code&gt; is assigned to &lt;code&gt;DESTDIR&lt;/code&gt; in the generated Makefile. This makes the build process more flexible as long as the environment variable is set correctly when the Makefile is processed.</source>
          <target state="translated">在上述分配中，当处理项目文件时，将立即读取 &lt;code&gt;PWD&lt;/code&gt; 的值，但是 &lt;code&gt;$(PWD)&lt;/code&gt; 被分配给生成的Makefile中的 &lt;code&gt;DESTDIR&lt;/code&gt; 。只要在处理Makefile时正确设置了环境变量，构建过程就会更加灵活。</target>
        </trans-unit>
        <trans-unit id="b3a0e96d852ac671feaa2b81ca3ff3c7721420ca" translate="yes" xml:space="preserve">
          <source>In the above assignment, the value of the &lt;code&gt;PWD&lt;/code&gt; environment variable is read when the project file is processed.</source>
          <target state="translated">在上述分配中，当处理项目文件时，将读取 &lt;code&gt;PWD&lt;/code&gt; 环境变量的值。</target>
        </trans-unit>
        <trans-unit id="4849f955a25344dd83e2b80d8df33bfd22e7919d" translate="yes" xml:space="preserve">
          <source>In the above case, the path start will be the item's current position, and the path end will be the item's target position in the target state.</source>
          <target state="translated">在上述情况下,路径起点为物品的当前位置,路径终点为物品在目标状态下的目标位置。</target>
        </trans-unit>
        <trans-unit id="791c8130e8761a8f3bf03bea7cbc7d087cb6621a" translate="yes" xml:space="preserve">
          <source>In the above code, a whole word is selected using this method. &lt;a href=&quot;qtextcursor&quot;&gt;QTextCursor&lt;/a&gt; provides a number of common move operations for selecting individual characters, words, lines, and whole blocks.</source>
          <target state="translated">在上面的代码中，使用此方法选择了整个单词。&lt;a href=&quot;qtextcursor&quot;&gt;QTextCursor&lt;/a&gt;提供了许多常用的移动操作，用于选择单个字符，单词，行和整个块。</target>
        </trans-unit>
        <trans-unit id="92adf25594982f9941ca5d04e0e063244190206a" translate="yes" xml:space="preserve">
          <source>In the above code, since the model is derived from &lt;a href=&quot;qstringlistmodel&quot;&gt;QStringListModel&lt;/a&gt;, we obtain a default set of flags by calling its implementation of the flags() function.</source>
          <target state="translated">在上面的代码中，由于模型是从&lt;a href=&quot;qstringlistmodel&quot;&gt;QStringListModel&lt;/a&gt;派生的，因此我们通过调用flags（）函数的实现来获得默认的标志集。</target>
        </trans-unit>
        <trans-unit id="23f203a1c2478fd4ea15e9a8717f6fa6de040c82" translate="yes" xml:space="preserve">
          <source>In the above diagram, a semi-transparent rectangular child widget with an area removed is constructed and added to a parent widget (a &lt;a href=&quot;qlabel&quot;&gt;QLabel&lt;/a&gt; showing a pixmap). Then, different properties and widget attributes are set to achieve different effects:</source>
          <target state="translated">在上图中，构造了一个删除区域的半透明矩形子窗口小部件并将其添加到父窗口小部件（显示像素图的&lt;a href=&quot;qlabel&quot;&gt;QLabel&lt;/a&gt;）。然后，设置不同的属性和窗口小部件属性以实现不同的效果：</target>
        </trans-unit>
        <trans-unit id="dea94ee650dbb2f98833468075bf1634d06c70c9" translate="yes" xml:space="preserve">
          <source>In the above example the &lt;a href=&quot;qbytearray#replace&quot;&gt;replace&lt;/a&gt;() function's first two arguments are the position from which to start replacing and the number of bytes that should be replaced.</source>
          <target state="translated">在上面的示例中，&lt;a href=&quot;qbytearray#replace&quot;&gt;replace&lt;/a&gt;（）函数的前两个参数是开始替换的位置以及应替换的字节数。</target>
        </trans-unit>
        <trans-unit id="f0faa87e2786bc7816634decf32116ffc37e6509" translate="yes" xml:space="preserve">
          <source>In the above example we circumvent the last rule by adding a</source>
          <target state="translated">在上面的例子中,我们通过添加一个叫做</target>
        </trans-unit>
        <trans-unit id="4fce397b35eb53fa7404ef938c55c61d0545cc0b" translate="yes" xml:space="preserve">
          <source>In the above example, a modal &lt;a href=&quot;qfiledialog&quot;&gt;QFileDialog&lt;/a&gt; is created using a static function. The dialog initially displays the contents of the &quot;/home/jana&quot; directory, and displays files matching the patterns given in the string &quot;Image Files (*.png *.jpg *.bmp)&quot;. The parent of the file dialog is set to</source>
          <target state="translated">在上面的示例中，使用静态函数创建模式&lt;a href=&quot;qfiledialog&quot;&gt;QFileDialog&lt;/a&gt;。该对话框最初显示&amp;ldquo; / home / jana&amp;rdquo;目录的内容，并显示与字符串&amp;ldquo; Image Files（* .png * .jpg * .bmp）&amp;rdquo;中给出的模式匹配的文件。文件对话框的父级设置为</target>
        </trans-unit>
        <trans-unit id="90fff16b05f63307cc41cfbf8deedb141ddc8f7e" translate="yes" xml:space="preserve">
          <source>In the above example, a modal QFileDialog is created using a static function. The dialog initially displays the contents of the &quot;/home/jana&quot; directory, and displays files matching the patterns given in the string &quot;Image Files (*.png *.jpg *.bmp)&quot;. The parent of the file dialog is set to</source>
          <target state="translated">在上面的例子中,使用静态函数创建了一个模态的QFileDialog。对话框最初显示&quot;/home/jana &quot;目录的内容,并显示与 &quot;Image Files (*.png *.jpg *.bmp)&quot;字符串中给出的模式相匹配的文件。文件对话框的父文件被设置为&quot;/home/jana &quot;目录下的内容。</target>
        </trans-unit>
        <trans-unit id="f78b1d34265001ff2f332358ede088f23c5d6826" translate="yes" xml:space="preserve">
          <source>In the above example, a modal file dialog is created and shown. If the user clicked OK, the file they selected is put in &lt;code&gt;fileName&lt;/code&gt;.</source>
          <target state="translated">在上面的示例中，创建并显示了一个模式文件对话框。如果用户单击&amp;ldquo;确定&amp;rdquo;，则他们选择的文件将放在 &lt;code&gt;fileName&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="7389b1f6fcb0075b550d83cc787a3c13c282650e" translate="yes" xml:space="preserve">
          <source>In the above example, only the intermediate binding will be re-evaluated each time, resulting in a significant performance increase.</source>
          <target state="translated">在上面的例子中,每次只需重新评估中间的结合物,从而使性能显著提高。</target>
        </trans-unit>
        <trans-unit id="4a8fae03a2b0cb2191c66f647b2733f1def1468b" translate="yes" xml:space="preserve">
          <source>In the above example, the &lt;a href=&quot;qml-qtquick-text&quot;&gt;Text&lt;/a&gt; object will have normal opacity, since the line opacity: 0.5 has been turned into a comment.</source>
          <target state="translated">在上面的示例中，&lt;a href=&quot;qml-qtquick-text&quot;&gt;Text&lt;/a&gt;对象将具有正常的不透明度，因为线不透明度：0.5已被转换为注释。</target>
        </trans-unit>
        <trans-unit id="26fd98790deaa5f699734de43a63c6fbe8293d1d" translate="yes" xml:space="preserve">
          <source>In the above example, the associated NOTIFY signal for the &lt;code&gt;author&lt;/code&gt; property is &lt;code&gt;authorChanged&lt;/code&gt;, as specified in the &lt;a href=&quot;qobject#Q_PROPERTY&quot;&gt;Q_PROPERTY&lt;/a&gt;() macro call. This means that whenever the signal is emitted &amp;mdash; as it is when the author changes in Message::setAuthor() &amp;mdash; this notifies the QML engine that any bindings involving the &lt;code&gt;author&lt;/code&gt; property must be updated, and in turn, the engine will update the &lt;code&gt;text&lt;/code&gt; property by calling &lt;code&gt;Message::author()&lt;/code&gt; again.</source>
          <target state="translated">在上面的示例中，与 &lt;code&gt;author&lt;/code&gt; 属性相关联的NOTIFY信号是 &lt;code&gt;authorChanged&lt;/code&gt; ，如&lt;a href=&quot;qobject#Q_PROPERTY&quot;&gt;Q_PROPERTY&lt;/a&gt;（）宏调用中所指定。这意味着每当发出信号时（如作者在Message :: setAuthor（）中进行更改时一样），这会通知QML引擎必须更新涉及 &lt;code&gt;author&lt;/code&gt; 属性的所有绑定，然后，引擎将更新 &lt;code&gt;text&lt;/code&gt; 通过再次调用 &lt;code&gt;Message::author()&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="52035459085e014010da31cbbf38d8144f6c306d" translate="yes" xml:space="preserve">
          <source>In the above example, the filter is set to &lt;code&gt;&quot;Images (*.png *.xpm *.jpg)&quot;&lt;/code&gt;, this means that only files with the extension &lt;code&gt;png&lt;/code&gt;, &lt;code&gt;xpm&lt;/code&gt;, or &lt;code&gt;jpg&lt;/code&gt; will be shown in the &lt;a href=&quot;qfiledialog&quot;&gt;QFileDialog&lt;/a&gt;. You can apply several filters by using &lt;a href=&quot;qfiledialog#setNameFilters&quot;&gt;setNameFilters&lt;/a&gt;(). Use &lt;a href=&quot;qfiledialog#selectNameFilter&quot;&gt;selectNameFilter&lt;/a&gt;() to select one of the filters you've given as the file dialog's default filter.</source>
          <target state="translated">在上面的示例中，过滤器设置为 &lt;code&gt;&quot;Images (*.png *.xpm *.jpg)&quot;&lt;/code&gt; ，这意味着&lt;a href=&quot;qfiledialog&quot;&gt;QFileDialog中&lt;/a&gt;仅显示扩展名为 &lt;code&gt;png&lt;/code&gt; ， &lt;code&gt;xpm&lt;/code&gt; 或 &lt;code&gt;jpg&lt;/code&gt; 的文件。您可以使用&lt;a href=&quot;qfiledialog#setNameFilters&quot;&gt;setNameFilters&lt;/a&gt;（）应用多个过滤器。使用&lt;a href=&quot;qfiledialog#selectNameFilter&quot;&gt;selectNameFilter&lt;/a&gt;（）选择您提供的一个过滤器作为文件对话框的默认过滤器。</target>
        </trans-unit>
        <trans-unit id="2c260ca6f2ba9dc4897ca2ad41e51ef6d948db05" translate="yes" xml:space="preserve">
          <source>In the above example, the filter is set to &lt;code&gt;&quot;Images (*.png *.xpm *.jpg)&quot;&lt;/code&gt;, this means that only files with the extension &lt;code&gt;png&lt;/code&gt;, &lt;code&gt;xpm&lt;/code&gt;, or &lt;code&gt;jpg&lt;/code&gt; will be shown in the QFileDialog. You can apply several filters by using &lt;a href=&quot;qfiledialog#setNameFilters&quot;&gt;setNameFilters&lt;/a&gt;(). Use &lt;a href=&quot;qfiledialog#selectNameFilter&quot;&gt;selectNameFilter&lt;/a&gt;() to select one of the filters you've given as the file dialog's default filter.</source>
          <target state="translated">在上面的示例中，过滤器设置为 &lt;code&gt;&quot;Images (*.png *.xpm *.jpg)&quot;&lt;/code&gt; ，这意味着QFileDialog中仅显示扩展名为 &lt;code&gt;png&lt;/code&gt; ， &lt;code&gt;xpm&lt;/code&gt; 或 &lt;code&gt;jpg&lt;/code&gt; 的文件。您可以使用&lt;a href=&quot;qfiledialog#setNameFilters&quot;&gt;setNameFilters&lt;/a&gt;（）应用多个过滤器。使用&lt;a href=&quot;qfiledialog#selectNameFilter&quot;&gt;selectNameFilter&lt;/a&gt;（）选择您提供的一个过滤器，作为文件对话框的默认过滤器。</target>
        </trans-unit>
        <trans-unit id="1cd88730ef838fc8d07abd4cb0faf90585717feb" translate="yes" xml:space="preserve">
          <source>In the above example, the input method allocates the word candidate list for its use.</source>
          <target state="translated">在上面的例子中,输入法分配单词候选列表供其使用。</target>
        </trans-unit>
        <trans-unit id="e7955e5c64c92ff547f3d25a340bd97077f23556" translate="yes" xml:space="preserve">
          <source>In the above example, the key size is inherited from parent elements in this order:</source>
          <target state="translated">在上面的例子中,键的大小是按照这个顺序从父元素继承的。</target>
        </trans-unit>
        <trans-unit id="ac1bec79b26271f29bc1213cc9adbd94afa09587" translate="yes" xml:space="preserve">
          <source>In the above example, the mode of the file dialog is set to &lt;a href=&quot;qfiledialog#FileMode-enum&quot;&gt;AnyFile&lt;/a&gt;, meaning that the user can select any file, or even specify a file that doesn't exist. This mode is useful for creating a &quot;Save As&quot; file dialog. Use &lt;a href=&quot;qfiledialog#FileMode-enum&quot;&gt;ExistingFile&lt;/a&gt; if the user must select an existing file, or &lt;a href=&quot;qfiledialog#FileMode-enum&quot;&gt;Directory&lt;/a&gt; if only a directory may be selected. See the &lt;a href=&quot;qfiledialog#FileMode-enum&quot;&gt;QFileDialog::FileMode&lt;/a&gt; enum for the complete list of modes.</source>
          <target state="translated">在上面的示例中，文件对话框的模式设置为&lt;a href=&quot;qfiledialog#FileMode-enum&quot;&gt;AnyFile&lt;/a&gt;，这意味着用户可以选择任何文件，甚至可以指定一个不存在的文件。此模式对于创建&amp;ldquo;另存为&amp;rdquo;文件对话框很有用。如果用户必须选择现有文件，则使用&lt;a href=&quot;qfiledialog#FileMode-enum&quot;&gt;ExistingFile；&lt;/a&gt;如果只能选择目录，则使用&lt;a href=&quot;qfiledialog#FileMode-enum&quot;&gt;Directory&lt;/a&gt;。有关模式的完整列表，请参见&lt;a href=&quot;qfiledialog#FileMode-enum&quot;&gt;QFileDialog :: FileMode&lt;/a&gt;枚举。</target>
        </trans-unit>
        <trans-unit id="05a2caab0c0536df310b455d81063c38cd4bc01e" translate="yes" xml:space="preserve">
          <source>In the above example, the red rectangle has a high z value, but is still stacked below the blue rectangle. This is because it is a child of the green rectangle, and the green rectangle is a sibling of the blue rectangle. The z value of the green rectangle is lower than that of the blue rectangle, so the green rectangle and all children will be stacked beneath the blue rectangle.</source>
          <target state="translated">在上面的例子中,红色矩形的z值很高,但仍然堆叠在蓝色矩形的下方。这是因为它是绿色矩形的孩子,而绿色矩形是蓝色矩形的兄弟姐妹。绿色矩形的z值比蓝色矩形的z值低,所以绿色矩形和所有的子矩形将叠加在蓝色矩形的下方。</target>
        </trans-unit>
        <trans-unit id="480656f8f31f766a08f232700e80b063b2db8ab7" translate="yes" xml:space="preserve">
          <source>In the above example, we conceptually scale the SVG graphic to 1024x1024 first, and then cut out a region of interest that is 512x512 pixels from a location 100 pixels from the top and left edges. Thus &lt;code&gt;sourceSize&lt;/code&gt; determines the scale, but the actual output image is 512x512 pixels.</source>
          <target state="translated">在上面的示例中，我们从概念上首先将SVG图形缩放为1024x1024，然后从顶部和左侧边缘100像素的位置中切出512x512像素的感兴趣区域。因此， &lt;code&gt;sourceSize&lt;/code&gt; 决定了比例，但是实际的输出图像是512x512像素。</target>
        </trans-unit>
        <trans-unit id="8440511dfdd68e429a1da7d100d7f5e5fd084b5e" translate="yes" xml:space="preserve">
          <source>In the above example, we neglected to mention how to handle selections of items. This subject is covered in more detail in the section about &lt;a href=&quot;#handling-selections-in-item-views&quot;&gt;Handling Selections in Item Views&lt;/a&gt;.</source>
          <target state="translated">在上面的示例中，我们忽略了提及如何处理项目选择。&lt;a href=&quot;#handling-selections-in-item-views&quot;&gt;在&amp;ldquo;项目视图&amp;rdquo;中的&amp;ldquo;处理选择&lt;/a&gt; &amp;rdquo;部分中将更详细地介绍此主题。</target>
        </trans-unit>
        <trans-unit id="dd2a0168bbb8b7584494cd4b55c1db29b01fcb56" translate="yes" xml:space="preserve">
          <source>In the above example, we neglected to mention how to handle selections of items. This subject is covered in more detail in the section about &lt;a href=&quot;model-view-programming#handling-selections-in-item-views&quot;&gt;Handling Selections in Item Views&lt;/a&gt;.</source>
          <target state="translated">在上面的示例中，我们忽略了如何处理项目选择。&lt;a href=&quot;model-view-programming#handling-selections-in-item-views&quot;&gt;在&amp;ldquo;项目视图&amp;rdquo;中的&amp;ldquo;处理选择&lt;/a&gt;&amp;rdquo;部分中将更详细地介绍此主题。</target>
        </trans-unit>
        <trans-unit id="78c6c3c91133829773409779fa43cb0deacc4aa9" translate="yes" xml:space="preserve">
          <source>In the above examples, the &lt;code&gt;Console&lt;/code&gt; edition only includes the contents of four modules. Only the classes from these modules will be used when the &lt;a href=&quot;12-0-qdoc-commands-miscellaneous#generatelist-command&quot;&gt;generatelist&lt;/a&gt; command is used to generate a list of classes for this edition:</source>
          <target state="translated">在以上示例中， &lt;code&gt;Console&lt;/code&gt; 版本仅包含四个模块的内容。当使用&lt;a href=&quot;12-0-qdoc-commands-miscellaneous#generatelist-command&quot;&gt;generatelist&lt;/a&gt;命令生成此版本的类列表时，将仅使用这些模块中的类：</target>
        </trans-unit>
        <trans-unit id="bf1b26c8502de9e92ebe525817b41cfcc7fb9699" translate="yes" xml:space="preserve">
          <source>In the above line, &lt;code&gt;USE_MY_STUFF&lt;/code&gt; will only be added to the list of pre-processor defines if it is not already defined. Note that the &lt;a href=&quot;qmake-function-reference#unique&quot;&gt;unique()&lt;/a&gt; function can also be used to ensure that a variable only contains one instance of each value.</source>
          <target state="translated">在上一行中，如果尚未定义 &lt;code&gt;USE_MY_STUFF&lt;/code&gt; ，则只会将其添加到预处理器定义列表中。请注意，&lt;a href=&quot;qmake-function-reference#unique&quot;&gt;unique（）&lt;/a&gt;函数还可用于确保变量仅包含每个值的一个实例。</target>
        </trans-unit>
        <trans-unit id="91b2f7e3a7379d60e71e8a0ad9b4ca0f4baf86d9" translate="yes" xml:space="preserve">
          <source>In the above line, any values in the list that start with &lt;code&gt;QT_D&lt;/code&gt; or &lt;code&gt;QT_T&lt;/code&gt; are replaced with &lt;code&gt;QT&lt;/code&gt;.</source>
          <target state="translated">在上一行中，列表中以 &lt;code&gt;QT_D&lt;/code&gt; 或 &lt;code&gt;QT_T&lt;/code&gt; 开头的任何值都将替换为 &lt;code&gt;QT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="12e32dff5085b20cc64db7542e7c40356df3d9db" translate="yes" xml:space="preserve">
          <source>In the above lines, qmake knows what needs to be copied, and will handle the installation process automatically.</source>
          <target state="translated">在上面的行文中,qmake知道需要复制什么,并会自动处理安装过程。</target>
        </trans-unit>
        <trans-unit id="35d1c4d14308bc4fdef8eec5b71409fc3d9adc9e" translate="yes" xml:space="preserve">
          <source>In the above sample the sound effect will be played when the &lt;a href=&quot;qml-qtquick-mousearea&quot;&gt;MouseArea&lt;/a&gt; is clicked.</source>
          <target state="translated">在上面的示例中，单击&lt;a href=&quot;qml-qtquick-mousearea&quot;&gt;MouseArea&lt;/a&gt;时将播放声音效果。</target>
        </trans-unit>
        <trans-unit id="08573c6b11eb5aa9f9479849a235a368e8127e62" translate="yes" xml:space="preserve">
          <source>In the above sample when the parent of &lt;a href=&quot;qml-qtquick-mousearea&quot;&gt;MouseArea&lt;/a&gt; is clicked, an area of 800x600 pixels with an id of 'video', the source &quot;video.avi&quot; will play in that area. Notice also that signals for the &lt;a href=&quot;qml-qtquick-keys&quot;&gt;Keys&lt;/a&gt; have been defined so that a spacebar will toggle the pause button; the left arrow will move the current position in the video to 5 seconds previously; and the right arrow will advance the current position in the video by 5 seconds.</source>
          <target state="translated">在上面的示例中，当单击&lt;a href=&quot;qml-qtquick-mousearea&quot;&gt;MouseArea&lt;/a&gt;的父级时，id为&amp;ldquo; video&amp;rdquo;的800x600像素区域将在该区域中播放源&amp;ldquo; video.avi&amp;rdquo;。还请注意，已经定义了&lt;a href=&quot;qml-qtquick-keys&quot;&gt;按键的&lt;/a&gt;信号，以便空格键可以切换暂停按钮；向左箭头会将视频中的当前位置移至5秒之前；并且向右箭头会将视频中的当前位置提前5秒钟。</target>
        </trans-unit>
        <trans-unit id="d447248144f69b8bf3f953183e709a74a32b386f" translate="yes" xml:space="preserve">
          <source>In the above situations, it is still possible to design forms with the aim of using custom widgets in the application. To achieve this, we can use the widget promotion feature of</source>
          <target state="translated">在上述情况下,仍然可以以在应用程序中使用自定义小部件为目的来设计表单。为了达到这个目的,我们可以使用小部件推广功能的</target>
        </trans-unit>
        <trans-unit id="3331e798ca3ace3a215a35ec6c8dcd768c49a723" translate="yes" xml:space="preserve">
          <source>In the above snippet the cursor will still become visible when the &lt;a href=&quot;qml-qtquick-textinput&quot;&gt;TextInput&lt;/a&gt; gains active focus.</source>
          <target state="translated">在上面的代码段中，当&lt;a href=&quot;qml-qtquick-textinput&quot;&gt;TextInput&lt;/a&gt;获得活动焦点时，光标仍将变为可见。</target>
        </trans-unit>
        <trans-unit id="f4a373056767122ef26106979322c003bb04fcf6" translate="yes" xml:space="preserve">
          <source>In the above snippet, &lt;a href=&quot;qmetaobject#property&quot;&gt;QMetaObject::property&lt;/a&gt;() is used to get &lt;a href=&quot;qmetaproperty&quot;&gt;metadata&lt;/a&gt; about each property defined in some unknown class. The property name is fetched from the metadata and passed to &lt;a href=&quot;qobject#property&quot;&gt;QObject::property&lt;/a&gt;() to get the &lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;value&lt;/a&gt; of the property in the current &lt;a href=&quot;qobject&quot;&gt;object&lt;/a&gt;.</source>
          <target state="translated">在上面的代码片段中，&lt;a href=&quot;qmetaobject#property&quot;&gt;QMetaObject :: property&lt;/a&gt;（）用于获取有关某个未知类中定义的每个属性的&lt;a href=&quot;qmetaproperty&quot;&gt;元数据&lt;/a&gt;。从元数据中获取属性名称，并将其传递给&lt;a href=&quot;qobject#property&quot;&gt;QObject :: property&lt;/a&gt;（）以获取当前&lt;a href=&quot;qobject&quot;&gt;对象中&lt;/a&gt;属性的&lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;值&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="778d5c49efcd63b405579dd6f8e7514a08305900" translate="yes" xml:space="preserve">
          <source>In the above snippet, &lt;a href=&quot;qmetaobject#property&quot;&gt;QMetaObject::property&lt;/a&gt;() is used to get &lt;a href=&quot;qmetaproperty&quot;&gt;metadata&lt;/a&gt; about each property defined in some unknown class. The property name is fetched from the metadata and passed to &lt;a href=&quot;qobject#property&quot;&gt;QObject::property&lt;/a&gt;() to get the &lt;a href=&quot;qvariant&quot;&gt;value&lt;/a&gt; of the property in the current &lt;a href=&quot;qobject&quot;&gt;object&lt;/a&gt;.</source>
          <target state="translated">在上面的代码片段中，&lt;a href=&quot;qmetaobject#property&quot;&gt;QMetaObject :: property&lt;/a&gt;（）用于获取有关某个未知类中定义的每个属性的&lt;a href=&quot;qmetaproperty&quot;&gt;元数据&lt;/a&gt;。从元数据中获取属性名称，并将其传递给&lt;a href=&quot;qobject#property&quot;&gt;QObject :: property&lt;/a&gt;（）以获取当前&lt;a href=&quot;qobject&quot;&gt;对象中&lt;/a&gt;属性的&lt;a href=&quot;qvariant&quot;&gt;值&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e12ff91a301a5754bfc26c58b618a6895b33b177" translate="yes" xml:space="preserve">
          <source>In the above style rule, &lt;code&gt;QPushButton&lt;/code&gt; is the selector and &lt;code&gt;{ color: red }&lt;/code&gt; is the declaration. The rule specifies that &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt; and its subclasses (e.g., &lt;code&gt;MyPushButton&lt;/code&gt;) should use red as their foreground color.</source>
          <target state="translated">在上述样式规则中， &lt;code&gt;QPushButton&lt;/code&gt; 是选择器， &lt;code&gt;{ color: red }&lt;/code&gt; 是声明。该规则指定&lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt;及其子类（例如 &lt;code&gt;MyPushButton&lt;/code&gt; ）应使用红色作为其前景色。</target>
        </trans-unit>
        <trans-unit id="b5491dea569a48c821c5d3cc5fa871d9841d9b0b" translate="yes" xml:space="preserve">
          <source>In the active state as soon as camera is started the viewfinder displays video frames and the camera is ready for capture.</source>
          <target state="translated">在活动状态下,只要相机启动,取景器就会显示视频帧,相机就可以进行拍摄。</target>
        </trans-unit>
        <trans-unit id="4105802f7fa87d449178ae4278075b284b6abb9b" translate="yes" xml:space="preserve">
          <source>In the active state the viewfinder frames are available and the camera is ready for capture.</source>
          <target state="translated">在活动状态下,取景框可用,相机已准备好进行拍摄。</target>
        </trans-unit>
        <trans-unit id="98f3ab4e1391da0c7cbc31b26b2019df50318e14" translate="yes" xml:space="preserve">
          <source>In the active state, the viewfinder frames are available and the camera is ready for capture.</source>
          <target state="translated">在活动状态下,取景框可用,相机可以进行拍摄。</target>
        </trans-unit>
        <trans-unit id="6fe43ce054c52dd0645bc2d81f31513eb5520e68" translate="yes" xml:space="preserve">
          <source>In the animation below, the first checkbox is tri-state:</source>
          <target state="translated">在下面的动画中,第一个复选框是三态的。</target>
        </trans-unit>
        <trans-unit id="a06074144e41dec3d566205f517c989ed933d003" translate="yes" xml:space="preserve">
          <source>In the animation below, the first checkdelegate is tri-state:</source>
          <target state="translated">在下面的动画中,第一个检查代表是三态。</target>
        </trans-unit>
        <trans-unit id="1ce44d5844cf9c7d884181be6345d42674e7ab6a" translate="yes" xml:space="preserve">
          <source>In the application's &lt;a href=&quot;qml-qtquick-virtualkeyboard-inputpanel&quot;&gt;InputPanel&lt;/a&gt;, add the following code:</source>
          <target state="translated">在应用程序的&lt;a href=&quot;qml-qtquick-virtualkeyboard-inputpanel&quot;&gt;InputPanel中&lt;/a&gt;，添加以下代码：</target>
        </trans-unit>
        <trans-unit id="11529092a568d2ebed4559cd5b0c3132a36a0dba" translate="yes" xml:space="preserve">
          <source>In the application, resource paths can be used in most places instead of ordinary file system paths. In particular, you can pass a resource path instead of a file name to the &lt;a href=&quot;qicon&quot;&gt;QIcon&lt;/a&gt;, &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt;, or &lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt; constructor:</source>
          <target state="translated">在应用程序中，可以在大多数地方使用资源路径，而不是普通的文件系统路径。特别是，您可以将资源路径而不是文件名传递给&lt;a href=&quot;qicon&quot;&gt;QIcon&lt;/a&gt;，&lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt;或&lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt;构造函数：</target>
        </trans-unit>
        <trans-unit id="093794bd305ddfae860139dd84bba3a916168ac6" translate="yes" xml:space="preserve">
          <source>In the application, this resource would be registered with code like this:</source>
          <target state="translated">在应用程序中,这个资源将用这样的代码注册。</target>
        </trans-unit>
        <trans-unit id="5aa9db2337634be8f880cb78c2fffea3cd290535" translate="yes" xml:space="preserve">
          <source>In the base class this is a pure virtual function.</source>
          <target state="translated">在基类中,这是一个纯虚拟函数。</target>
        </trans-unit>
        <trans-unit id="f7cd5a68e95a94289db1ac56a4a3d86a14733425" translate="yes" xml:space="preserve">
          <source>In the below sections we will present a toolchain file that can be used in many cases, with minimal customization. It is based on the approach presented in &lt;a href=&quot;https://www.qt.io/blog/standalone-boot2qt-/-yocto-sdk-cmake-toolchain&quot;&gt;this blog post&lt;/a&gt;.</source>
          <target state="translated">在以下各节中，我们将介绍一个工具链文件，该文件可在许多情况下使用，而无需进行任何定制。它基于&lt;a href=&quot;https://www.qt.io/blog/standalone-boot2qt-/-yocto-sdk-cmake-toolchain&quot;&gt;此博客文章中&lt;/a&gt;介绍的方法。</target>
        </trans-unit>
        <trans-unit id="e5103749357b6394f7985e837d39c213852f1028" translate="yes" xml:space="preserve">
          <source>In the branch delegate you have access to the following special properties:</source>
          <target state="translated">在分支委托中,您可以访问以下特殊属性。</target>
        </trans-unit>
        <trans-unit id="52854a801e231867b5e93209f75904f0423e5d7b" translate="yes" xml:space="preserve">
          <source>In the case of &lt;b&gt;Tab&lt;/b&gt;, &lt;b&gt;Backtab&lt;/b&gt;, &lt;b&gt;Enter&lt;/b&gt; and &lt;b&gt;Return&lt;/b&gt; key press events, the</source>
          <target state="translated">对于&lt;b&gt;Tab&lt;/b&gt;，&lt;b&gt;Backtab&lt;/b&gt;，&lt;b&gt;Enter&lt;/b&gt;和&lt;b&gt;Return&lt;/b&gt;键按下事件，</target>
        </trans-unit>
        <trans-unit id="0780880e8284aeee383317793fd94a1ca17307f9" translate="yes" xml:space="preserve">
          <source>In the case of &lt;code&gt;fn:doc()&lt;/code&gt;, the absolute URI is the base URI in the static context (which most likely is the location of the query). Rather than use the URI the user specified, the return value of &lt;a href=&quot;qabstracturiresolver#resolve&quot;&gt;QAbstractUriResolver::resolve&lt;/a&gt;() will be used.</source>
          <target state="translated">对于 &lt;code&gt;fn:doc()&lt;/code&gt; ，绝对URI是静态上下文中的基础URI（最有可能是查询的位置）。不是使用用户指定的URI，而是使用&lt;a href=&quot;qabstracturiresolver#resolve&quot;&gt;QAbstractUriResolver :: resolve&lt;/a&gt;（）的返回值。</target>
        </trans-unit>
        <trans-unit id="476df6664814d3170809cfc84a7a9d225a742f8a" translate="yes" xml:space="preserve">
          <source>In the case of a checkable &lt;a href=&quot;qgroupbox&quot;&gt;QGroupBox&lt;/a&gt;, the title includes the check indicator. The indicator is styled using the &lt;a href=&quot;#indicator-sub&quot;&gt;::indicator&lt;/a&gt; subcontrol. The &lt;a href=&quot;#spacing-prop&quot;&gt;spacing&lt;/a&gt; property can be used to control the spacing between the text and indicator.</source>
          <target state="translated">对于可检查的&lt;a href=&quot;qgroupbox&quot;&gt;QGroupBox&lt;/a&gt;，标题包括检查指示符。指示器使用&lt;a href=&quot;#indicator-sub&quot;&gt;:: indicator子&lt;/a&gt;控件设置样式。的&lt;a href=&quot;#spacing-prop&quot;&gt;间隔&lt;/a&gt;属性可用于控制文本和指示器之间的间距。</target>
        </trans-unit>
        <trans-unit id="bc6403ce8320f0badfc0d3ff944bd06c2869984f" translate="yes" xml:space="preserve">
          <source>In the case of a checkable &lt;a href=&quot;qgroupbox&quot;&gt;QGroupBox&lt;/a&gt;, the title includes the check indicator. The indicator is styled using the &lt;a href=&quot;stylesheet-reference#indicator-sub&quot;&gt;::indicator&lt;/a&gt; subcontrol. The &lt;a href=&quot;stylesheet-reference#spacing-prop&quot;&gt;spacing&lt;/a&gt; property can be used to control the spacing between the text and indicator.</source>
          <target state="translated">对于可检查的&lt;a href=&quot;qgroupbox&quot;&gt;QGroupBox&lt;/a&gt;，标题包括检查指示符。该指示器使用&lt;a href=&quot;stylesheet-reference#indicator-sub&quot;&gt;:: indicator子&lt;/a&gt;控件设置样式。的&lt;a href=&quot;stylesheet-reference#spacing-prop&quot;&gt;间隔&lt;/a&gt;属性可用于控制文本和指示器之间的间距。</target>
        </trans-unit>
        <trans-unit id="c841a239b1f23504d92454f01a42039f4003cb72" translate="yes" xml:space="preserve">
          <source>In the case of an error, a &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtscript-index.html&quot;&gt;Qt Script&lt;/a&gt; Error object is thrown. This object has an additional property, &lt;code&gt;qmlErrors&lt;/code&gt;, which is an array of the errors encountered. Each object in this array has the members &lt;code&gt;lineNumber&lt;/code&gt;, &lt;code&gt;columnNumber&lt;/code&gt;, &lt;code&gt;fileName&lt;/code&gt; and &lt;code&gt;message&lt;/code&gt;. For example, if the above snippet had misspelled color as 'colro' then the array would contain an object like the following: { &quot;lineNumber&quot; : 1, &quot;columnNumber&quot; : 32, &quot;fileName&quot; : &quot;dynamicSnippet1&quot;, &quot;message&quot; : &quot;Cannot assign to non-existent property &quot;colro&quot;&quot;}.</source>
          <target state="translated">如果发生错误，将抛出&lt;a href=&quot;https://doc.qt.io/qt-5.13/qtscript-index.html&quot;&gt;Qt脚本&lt;/a&gt;错误对象。该对象还有一个附加属性 &lt;code&gt;qmlErrors&lt;/code&gt; ，它是遇到的错误的数组。此数组中的每个对象都有成员 &lt;code&gt;lineNumber&lt;/code&gt; ， &lt;code&gt;columnNumber&lt;/code&gt; ， &lt;code&gt;fileName&lt;/code&gt; 和 &lt;code&gt;message&lt;/code&gt; 。例如，如果上述代码段的颜色拼写错误为'colro'，则该数组将包含如下对象：{&amp;ldquo; lineNumber&amp;rdquo;：1，&amp;ldquo; columnNumber&amp;rdquo;：32，&amp;ldquo; fileName&amp;rdquo;：&amp;ldquo; dynamicSnippet1&amp;rdquo;，&amp;ldquo; message&amp;rdquo;： &amp;ldquo;无法分配给不存在的属性&amp;ldquo; colro&amp;rdquo;&amp;ldquo;}。</target>
        </trans-unit>
        <trans-unit id="1f41c8b939c4a62952483b3e29fe7b69d9d43cba" translate="yes" xml:space="preserve">
          <source>In the case of an error, a &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtscript-index.html&quot;&gt;Qt Script&lt;/a&gt; Error object is thrown. This object has an additional property, &lt;code&gt;qmlErrors&lt;/code&gt;, which is an array of the errors encountered. Each object in this array has the members &lt;code&gt;lineNumber&lt;/code&gt;, &lt;code&gt;columnNumber&lt;/code&gt;, &lt;code&gt;fileName&lt;/code&gt; and &lt;code&gt;message&lt;/code&gt;. For example, if the above snippet had misspelled color as 'colro' then the array would contain an object like the following: { &quot;lineNumber&quot; : 1, &quot;columnNumber&quot; : 32, &quot;fileName&quot; : &quot;dynamicSnippet1&quot;, &quot;message&quot; : &quot;Cannot assign to non-existent property &quot;colro&quot;&quot;}.</source>
          <target state="translated">如果发生错误，将抛出&lt;a href=&quot;https://doc.qt.io/qt-5.15/qtscript-index.html&quot;&gt;Qt脚本&lt;/a&gt;错误对象。该对象还有一个附加属性 &lt;code&gt;qmlErrors&lt;/code&gt; ，它是遇到的错误的数组。此数组中的每个对象都有成员 &lt;code&gt;lineNumber&lt;/code&gt; ， &lt;code&gt;columnNumber&lt;/code&gt; ， &lt;code&gt;fileName&lt;/code&gt; 和 &lt;code&gt;message&lt;/code&gt; 。例如，如果上述代码段的颜色拼写错误为'colro'，则该数组将包含如下对象：{&amp;ldquo; lineNumber&amp;rdquo;：1，&amp;ldquo; columnNumber&amp;rdquo;：32，&amp;ldquo; fileName&amp;rdquo;：&amp;ldquo; dynamicSnippet1&amp;rdquo;，&amp;ldquo; message&amp;rdquo;： &amp;ldquo;无法分配给不存在的属性&amp;ldquo; colro&amp;rdquo;&amp;ldquo;}。</target>
        </trans-unit>
        <trans-unit id="37e65a36db5f9e7ce2b957d78aaa84d6ff90e336" translate="yes" xml:space="preserve">
          <source>In the case of an error, a &lt;a href=&quot;qqmlerror&quot;&gt;QQmlError&lt;/a&gt; object is thrown. This object has an additional property, &lt;code&gt;qmlErrors&lt;/code&gt;, which is an array of the errors encountered. Each object in this array has the members &lt;code&gt;lineNumber&lt;/code&gt;, &lt;code&gt;columnNumber&lt;/code&gt;, &lt;code&gt;fileName&lt;/code&gt; and &lt;code&gt;message&lt;/code&gt;. For example, if the above snippet had misspelled color as 'colro' then the array would contain an object like the following: { &quot;lineNumber&quot; : 1, &quot;columnNumber&quot; : 32, &quot;fileName&quot; : &quot;dynamicSnippet1&quot;, &quot;message&quot; : &quot;Cannot assign to non-existent property &quot;colro&quot;&quot;}.</source>
          <target state="translated">如果发生错误，将抛出&lt;a href=&quot;qqmlerror&quot;&gt;QQmlError&lt;/a&gt;对象。该对象还有一个附加属性 &lt;code&gt;qmlErrors&lt;/code&gt; ，它是遇到的错误的数组。此数组中的每个对象都有成员 &lt;code&gt;lineNumber&lt;/code&gt; ， &lt;code&gt;columnNumber&lt;/code&gt; ， &lt;code&gt;fileName&lt;/code&gt; 和 &lt;code&gt;message&lt;/code&gt; 。例如，如果上述代码段的颜色拼写错误为'colro'，则该数组将包含如下对象：{&amp;ldquo; lineNumber&amp;rdquo;：1，&amp;ldquo; columnNumber&amp;rdquo;：32，&amp;ldquo; fileName&amp;rdquo;：&amp;ldquo; dynamicSnippet1&amp;rdquo;，&amp;ldquo; message&amp;rdquo;： &amp;ldquo;无法分配给不存在的属性&amp;ldquo; colro&amp;rdquo;&amp;ldquo;}。</target>
        </trans-unit>
        <trans-unit id="0824274244abdbd52bff471c964c47cedfe5858d" translate="yes" xml:space="preserve">
          <source>In the case of comparing floats and doubles, &lt;a href=&quot;#qFuzzyCompare&quot;&gt;qFuzzyCompare&lt;/a&gt;() is used for comparing. This means that comparing to 0 will likely fail. One solution to this is to compare to 1, and add 1 to the produced output.</source>
          <target state="translated">在比较浮点数和双精度数的情况下，使用&lt;a href=&quot;#qFuzzyCompare&quot;&gt;qFuzzyCompare&lt;/a&gt;（）进行比较。这意味着与0比较可能会失败。一种解决方案是比较1，然后将产生的输出加1。</target>
        </trans-unit>
        <trans-unit id="8bc6b3262f626e98377a151d42e98ada92bdb9aa" translate="yes" xml:space="preserve">
          <source>In the case of queries of type &lt;a href=&quot;qnetworkproxyquery#QueryType-enum&quot;&gt;QNetworkProxyQuery::UrlRequest&lt;/a&gt;, this function returns the value of the scheme component of the URL.</source>
          <target state="translated">对于&lt;a href=&quot;qnetworkproxyquery#QueryType-enum&quot;&gt;QNetworkProxyQuery :: UrlRequest&lt;/a&gt;类型的查询，此函数返回URL的方案组件的值。</target>
        </trans-unit>
        <trans-unit id="180620aebe5082c9a9db3b49a73f0451d604fbee" translate="yes" xml:space="preserve">
          <source>In the case of the default OpenGL adaptation the context of this window will be bound when this function is called. The only exception is if the native OpenGL has been destroyed outside Qt's control, for instance through EGL_CONTEXT_LOST.</source>
          <target state="translated">在默认OpenGL适配的情况下,当调用该函数时,该窗口的上下文将被绑定。唯一的例外是,如果原生OpenGL在Qt控制之外被破坏,例如通过EGL_CONTEXT_LOST。</target>
        </trans-unit>
        <trans-unit id="302b4a1de7fc10868e07089fb5eb6a54d9241902" translate="yes" xml:space="preserve">
          <source>In the case the string corresponds to a valid file path on the system, a file:// URL is constructed, using &lt;a href=&quot;qurl#fromLocalFile&quot;&gt;QUrl::fromLocalFile&lt;/a&gt;().</source>
          <target state="translated">如果字符串对应于系统上的有效文件路径，则使用&lt;a href=&quot;qurl#fromLocalFile&quot;&gt;QUrl :: fromLocalFile&lt;/a&gt;（）构造file：// URL 。</target>
        </trans-unit>
        <trans-unit id="b8917b869fce1b4f2373fc587ff1159fcd5aaaf0" translate="yes" xml:space="preserve">
          <source>In the case where a file contains multiple animations, it is possible to select which animation should be loaded by way of query parameters on the source url. The accepted query parameters are animationIndex and animationName. If both are specified, animationName is ignored.</source>
          <target state="translated">在一个文件包含多个动画的情况下,可以通过对源网址的查询参数来选择应该加载哪个动画。接受的查询参数是animationIndex和animationName。如果指定了这两个参数,animationName将被忽略。</target>
        </trans-unit>
        <trans-unit id="9970ca9194b59467b4465baf132eacc1ea8cd7a7" translate="yes" xml:space="preserve">
          <source>In the case where an icon can only possibly have one image URL, the parameter key of &lt;code&gt;&quot;singleUrl&quot;&lt;/code&gt; can be used with a &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; value. Any Icon with this parameter will always return the specified URL regardless of the requested icon size and not defer to any Plugin.</source>
          <target state="translated">在一个图标可能仅具有一个图像URL的情况下， &lt;code&gt;&quot;singleUrl&quot;&lt;/code&gt; 的参数键可以与&lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt;值一起使用。不管请求的图标大小如何，带有此参数的任何Icon都将始终返回指定的URL，并且不遵循任何插件。</target>
        </trans-unit>
        <trans-unit id="b6dafd1675255377501babc739c62dd031c0b87c" translate="yes" xml:space="preserve">
          <source>In the class constructor you add the interfaces to your custom widgets to the list which you return in the &lt;a href=&quot;qdesignercustomwidgetcollectioninterface#customWidgets&quot;&gt;customWidgets&lt;/a&gt;() function:</source>
          <target state="translated">在类构造函数中，将自定义小部件的接口添加到在&lt;a href=&quot;qdesignercustomwidgetcollectioninterface#customWidgets&quot;&gt;customWidgets&lt;/a&gt;（）函数中返回的列表：</target>
        </trans-unit>
        <trans-unit id="2f985c4af31f9b16cab55135f47c6d6e919b4114" translate="yes" xml:space="preserve">
          <source>In the clipboard model, the user can</source>
          <target state="translated">在剪贴板模型中,用户可以</target>
        </trans-unit>
        <trans-unit id="cbba5f50ddea3356e28a3b0772fb4d3dfe4616af" translate="yes" xml:space="preserve">
          <source>In the code snippets so far, we used the unary &lt;code&gt;*&lt;/code&gt; operator to retrieve the item (of type &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;) stored at a certain iterator position, and we then called &lt;a href=&quot;qstring#toLower&quot;&gt;QString::toLower&lt;/a&gt;() on it. Most C++ compilers also allow us to write &lt;code&gt;i-&amp;gt;toLower()&lt;/code&gt;, but some don't.</source>
          <target state="translated">在到目前为止的代码段中，我们使用一元 &lt;code&gt;*&lt;/code&gt; 运算符检索存储在某个迭代器位置的项目（类型&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;），然后在其上调用&lt;a href=&quot;qstring#toLower&quot;&gt;QString :: toLower&lt;/a&gt;（）。大多数C ++编译器还允许我们编写 &lt;code&gt;i-&amp;gt;toLower()&lt;/code&gt; ，但有些则不允许。</target>
        </trans-unit>
        <trans-unit id="124e39d73adbb34143a94895eae6f328439ba3eb" translate="yes" xml:space="preserve">
          <source>In the common case of interleaved linear PCM data, the codec will be &quot;audio/pcm&quot;, and the samples for all channels will be interleaved. One sample for each channel for the same instant in time is referred to as a frame in Qt Multimedia (and other places).</source>
          <target state="translated">在常见的交错线性PCM数据的情况下,编解码器将是 &quot;audio/pcm&quot;,所有通道的样本将是交错的。在Qt Multimedia(和其他地方)中,每个通道在同一时刻的一个样本被称为一帧。</target>
        </trans-unit>
        <trans-unit id="8a4d1bdb49c84c11153ae631579c2138e30d7956" translate="yes" xml:space="preserve">
          <source>In the common case of simply using a &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; as the source of texture pixel data most of the above steps are performed automatically.</source>
          <target state="translated">在简单地将&lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt;用作纹理像素数据源的常见情况下，上述大多数步骤都是自动执行的。</target>
        </trans-unit>
        <trans-unit id="8da8e3805b741a984ea93a66a1272a507e49e1ef" translate="yes" xml:space="preserve">
          <source>In the common case, it is useful to call the &lt;a href=&quot;qtglobal#qDebugx&quot;&gt;qDebug&lt;/a&gt;() function to obtain a default &lt;a href=&quot;qdebug&quot;&gt;QDebug&lt;/a&gt; object to use for writing debugging information.</source>
          <target state="translated">在常见情况下，调用&lt;a href=&quot;qtglobal#qDebugx&quot;&gt;qDebug&lt;/a&gt;（）函数以获得用于写入调试信息的默认&lt;a href=&quot;qdebug&quot;&gt;QDebug&lt;/a&gt;对象很有用。</target>
        </trans-unit>
        <trans-unit id="479d43eb5e8df23ffbbea2419251a42341ff82ab" translate="yes" xml:space="preserve">
          <source>In the common case, it is useful to call the &lt;a href=&quot;qtglobal#qDebugx&quot;&gt;qDebug&lt;/a&gt;() function to obtain a default QDebug object to use for writing debugging information.</source>
          <target state="translated">在通常情况下，调用&lt;a href=&quot;qtglobal#qDebugx&quot;&gt;qDebug&lt;/a&gt;（）函数以获得用于写入调试信息的默认QDebug对象很有用。</target>
        </trans-unit>
        <trans-unit id="b17c300f21b0e795728fffc213f58fce115ab850" translate="yes" xml:space="preserve">
          <source>In the cookies are equal, the client is considered to be real, and the server can continue with a TLS handshake procedure.</source>
          <target state="translated">在Cookie相等的情况下,客户端被认为是真实的,服务器可以继续进行TLS握手程序。</target>
        </trans-unit>
        <trans-unit id="b036303f55d614ffcf9a344777119a33d88c19ae" translate="yes" xml:space="preserve">
          <source>In the course of this section, we will look at the style elements, the style options, and the functions of &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt;. Finally, we describe how the palette is used.</source>
          <target state="translated">在本节中，我们将看一下样式元素，样式选项和&lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt;的功能。最后，我们描述如何使用调色板。</target>
        </trans-unit>
        <trans-unit id="8c9da98054ac779e0d109342bf29b26e8998dac9" translate="yes" xml:space="preserve">
          <source>In the current implementation the Qt XML classes follow the definition that the prefix</source>
          <target state="translated">在当前的实现中,Qt XML类遵循的定义是,前缀为</target>
        </trans-unit>
        <trans-unit id="0a2e7cc57f6d075df2486f0ea3fdf26afb4ee0e3" translate="yes" xml:space="preserve">
          <source>In the default &lt;a href=&quot;qpagelayout#Mode-enum&quot;&gt;StandardMode&lt;/a&gt; the current margins and minimum margins are always taken into account. The paintable rectangle is the full page rectangle less the current margins, and the current margins can only be set to values between the minimum margins and the maximum margins allowed by the full page size.</source>
          <target state="translated">在默认的&lt;a href=&quot;qpagelayout#Mode-enum&quot;&gt;StandardMode中&lt;/a&gt;，始终考虑当前边距和最小边距。可绘制矩形是整页矩形减去当前页边距，并且当前页边距只能设置为整页大小所允许的最小页边距和最大页边距之间的值。</target>
        </trans-unit>
        <trans-unit id="0af4f12a2438da5389e981b2a43981e2330d13c2" translate="yes" xml:space="preserve">
          <source>In the default implementation, supportsGeocoding() and supportsReverseGeocoding() returns false while &lt;a href=&quot;qgeocodingmanagerengine#geocode&quot;&gt;geocode&lt;/a&gt;() and &lt;a href=&quot;qgeocodingmanagerengine#reverseGeocode&quot;&gt;reverseGeocode&lt;/a&gt;() cause &lt;a href=&quot;qgeocodereply#Error-enum&quot;&gt;QGeoCodeReply::UnsupportedOptionError&lt;/a&gt; to occur.</source>
          <target state="translated">在默认实现中，当&lt;a href=&quot;qgeocodingmanagerengine#geocode&quot;&gt;geocode&lt;/a&gt;（）和&lt;a href=&quot;qgeocodingmanagerengine#reverseGeocode&quot;&gt;reverseGeocode&lt;/a&gt;（）导致&lt;a href=&quot;qgeocodereply#Error-enum&quot;&gt;QGeoCodeReply :: UnsupportedOptionError&lt;/a&gt;发生时，supportsGeocoding（）和supportsReverseGeocoding（）返回false 。</target>
        </trans-unit>
        <trans-unit id="2bd8170ef8a59ecadee40ae365f975fcf7870a37" translate="yes" xml:space="preserve">
          <source>In the default implementation, supportsRouteUpdates() returns false and &lt;a href=&quot;qgeoroutingmanagerengine#updateRoute&quot;&gt;updateRoute&lt;/a&gt;() returns a &lt;a href=&quot;qgeoroutereply&quot;&gt;QGeoRouteReply&lt;/a&gt; object containing a &lt;a href=&quot;qgeoroutereply#Error-enum&quot;&gt;QGeoRouteReply::UnsupportedOptionError&lt;/a&gt;.</source>
          <target state="translated">在默认实现中，supportsRou​​teUpdates（）返回false，而&lt;a href=&quot;qgeoroutingmanagerengine#updateRoute&quot;&gt;updateRoute&lt;/a&gt;（）返回包含&lt;a href=&quot;qgeoroutereply#Error-enum&quot;&gt;QGeoRouteReply :: UnsupportedOptionError&lt;/a&gt;的&lt;a href=&quot;qgeoroutereply&quot;&gt;QGeoRouteReply&lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="5b97b88d857abd592cc5a47911673c45f447de45" translate="yes" xml:space="preserve">
          <source>In the default implementation, the search is reset if</source>
          <target state="translated">在默认的实现中,如果出现以下情况,搜索将被重置</target>
        </trans-unit>
        <trans-unit id="0478285b5fc700b8ba538808a471d5f384467f73" translate="yes" xml:space="preserve">
          <source>In the default implementation, the text either contains a percentage value that indicates the progress so far, or it is blank because the progress bar is in the reset state.</source>
          <target state="translated">在默认的实现中,文本要么包含一个百分比值,表示到目前为止的进度,要么是空白的,因为进度条处于重置状态。</target>
        </trans-unit>
        <trans-unit id="a6798e6ffde70f7209f8a6967c59bde077018721" translate="yes" xml:space="preserve">
          <source>In the default mode, &lt;a href=&quot;qsensor#AxesOrientationMode-enum&quot;&gt;QSensor::FixedOrientation&lt;/a&gt;, the reading values remain unaffected by the orientation. In the &lt;a href=&quot;qsensor#AxesOrientationMode-enum&quot;&gt;QSensor::AutomaticOrientation&lt;/a&gt; mode, the reading values are automatically rotated by taking the current screen orientation into account. And finally, in the &lt;a href=&quot;qsensor#AxesOrientationMode-enum&quot;&gt;QSensor::UserOrientation&lt;/a&gt; mode, the reading values are rotated according to a user-specified orientation.</source>
          <target state="translated">在默认模式&lt;a href=&quot;qsensor#AxesOrientationMode-enum&quot;&gt;QSensor :: FixedOrientation中&lt;/a&gt;，读数值不受方向的影响。在&lt;a href=&quot;qsensor#AxesOrientationMode-enum&quot;&gt;QSensor :: AutomaticOrientation&lt;/a&gt;模式下，考虑当前屏幕方向会自动旋转读数值。最后，在&lt;a href=&quot;qsensor#AxesOrientationMode-enum&quot;&gt;QSensor :: UserOrientation&lt;/a&gt;模式下，读取值根据用户指定的方向旋转。</target>
        </trans-unit>
        <trans-unit id="ad6929bbae910ceee52ca84922a13b3920781577" translate="yes" xml:space="preserve">
          <source>In the delegate you have access to the following special properties:</source>
          <target state="translated">在委托人中,您可以访问以下特殊属性。</target>
        </trans-unit>
        <trans-unit id="b2534f4f89a188c5999ea508d895176982cc0b73" translate="yes" xml:space="preserve">
          <source>In the dialog's constructor we set up the widgets as before, and connect the &lt;b&gt;Cancel&lt;/b&gt; button's &lt;a href=&quot;qabstractbutton#clicked&quot;&gt;clicked()&lt;/a&gt; signal to the dialog's reject() slot. We also disable the &lt;a href=&quot;qpushbutton#autoDefault-prop&quot;&gt;autoDefault&lt;/a&gt; property in both buttons to ensure that the dialog does not interfere with the way that the line edit handles return key events:</source>
          <target state="translated">在对话框的构造函数中，我们像以前一样设置小部件，然后将&amp;ldquo; &lt;b&gt;取消&amp;rdquo;&lt;/b&gt;按钮的&lt;a href=&quot;qabstractbutton#clicked&quot;&gt;clicked（）&lt;/a&gt;信号连接到对话框的reject（）插槽。我们还禁用了两个按钮中的&lt;a href=&quot;qpushbutton#autoDefault-prop&quot;&gt;autoDefault&lt;/a&gt;属性，以确保对话框不会干扰行编辑处理返回键事件的方式：</target>
        </trans-unit>
        <trans-unit id="82c71c0d4f75f98f48b8d5cd419f95c14a047975" translate="yes" xml:space="preserve">
          <source>In the drop down list, select &lt;b&gt;Triangulate&lt;/b&gt;.</source>
          <target state="translated">在下拉列表中，选择&lt;b&gt;Triangulate&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="08bf3c71618a2603cedc205b0af171f24a51a82b" translate="yes" xml:space="preserve">
          <source>In the end we must remember to make &lt;code&gt;main()&lt;/code&gt; pass the control to Qt. &lt;a href=&quot;qcoreapplication#exec&quot;&gt;QCoreApplication::exec&lt;/a&gt;() will return when the application exits...</source>
          <target state="translated">最后，我们必须记住要使 &lt;code&gt;main()&lt;/code&gt; 将控件传递给Qt。&lt;a href=&quot;qcoreapplication#exec&quot;&gt;QCoreApplication :: exec&lt;/a&gt;（）将在应用程序退出时返回...</target>
        </trans-unit>
        <trans-unit id="58420c6de2ba679e27caab480527f70881be2502" translate="yes" xml:space="preserve">
          <source>In the event that you are running a local loop which calls this function continuously, without an event loop, the &lt;a href=&quot;qevent#Type-enum&quot;&gt;DeferredDelete&lt;/a&gt; events will not be processed. This can affect the behaviour of widgets, e.g. &lt;a href=&quot;qtooltip&quot;&gt;QToolTip&lt;/a&gt;, that rely on &lt;a href=&quot;qevent#Type-enum&quot;&gt;DeferredDelete&lt;/a&gt; events to function properly. An alternative would be to call &lt;a href=&quot;qcoreapplication#sendPostedEvents&quot;&gt;sendPostedEvents()&lt;/a&gt; from within that local loop.</source>
          <target state="translated">如果您正在运行连续调用此函数的本地循环，而没有事件循环，则不会处理&lt;a href=&quot;qevent#Type-enum&quot;&gt;DeferredDelete&lt;/a&gt;事件。这可能会影响依赖&lt;a href=&quot;qevent#Type-enum&quot;&gt;DeferredDelete&lt;/a&gt;事件的小部件（例如&lt;a href=&quot;qtooltip&quot;&gt;QToolTip）&lt;/a&gt;的行为，以使其正常运行。一种替代方法是从该本地循环中调用&lt;a href=&quot;qcoreapplication#sendPostedEvents&quot;&gt;sendPostedEvents（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3ddf9748fa9fb248455e59b7f0f5621900cafef1" translate="yes" xml:space="preserve">
          <source>In the example &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; above, the second and third steps are both axis steps. Both apply the &lt;code&gt;element(name)&lt;/code&gt; node test to nodes encountered while traversing along some axis. But in this example, the two axis steps are written in a &lt;a href=&quot;xquery-introduction#shorthand-form&quot;&gt;shorthand form&lt;/a&gt;, where the axis specifier and the node test are not written explicitly but are implied. XQueries are normally written in this shorthand form, but they can also be written in the longhand form. If we rewrite the &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; in the longhand form, it looks like this:</source>
          <target state="translated">在上面的示例&lt;a href=&quot;xmlprocessing&quot;&gt;XQuery中&lt;/a&gt;，第二步和第三步都是轴步。两者都将 &lt;code&gt;element(name)&lt;/code&gt; 节点测试应用于沿某个轴遍历时遇到的节点。但是在此示例中，两个轴步以&lt;a href=&quot;xquery-introduction#shorthand-form&quot;&gt;简写形式&lt;/a&gt;编写，其中轴说明符和节点测试不是显式编写的，而是暗含的。XQueries通常以这种简写形式编写，但是它们也可以以简写形式编写。如果我们以长格式重写&lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt;，则它看起来像这样：</target>
        </trans-unit>
        <trans-unit id="72cdfe261c710f3bc0661c21f511997cedee110e" translate="yes" xml:space="preserve">
          <source>In the example &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; above, the second and third steps are both axis steps. Both apply the &lt;code&gt;element(name)&lt;/code&gt; node test to nodes encountered while traversing along some axis. But in this example, the two axis steps are written in a &lt;a href=&quot;#shorthand-form&quot;&gt;shorthand form&lt;/a&gt;, where the axis specifier and the node test are not written explicitly but are implied. XQueries are normally written in this shorthand form, but they can also be written in the longhand form. If we rewrite the &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; in the longhand form, it looks like this:</source>
          <target state="translated">在上面的示例&lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery中&lt;/a&gt;，第二步和第三步都是轴步。两者都将 &lt;code&gt;element(name)&lt;/code&gt; 节点测试应用于沿某个轴遍历时遇到的节点。但是在此示例中，两个轴步以&lt;a href=&quot;#shorthand-form&quot;&gt;简写形式&lt;/a&gt;编写，其中轴说明符和节点测试未显式编写，但被隐含。 XQueries通常以这种简写形式编写，但是它们也可以以简写形式编写。如果我们以长格式重写&lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt;，则它看起来像这样：</target>
        </trans-unit>
        <trans-unit id="1540e0ba5a23ab6ecdac5ae38326c96fae2b3570" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;a href=&quot;qvarlengtharray&quot;&gt;QVarLengthArray&lt;/a&gt; will preallocate 1024 elements on the stack and use them unless &lt;code&gt;n + 1&lt;/code&gt; is greater than 1024. If you omit the second template argument, &lt;a href=&quot;qvarlengtharray&quot;&gt;QVarLengthArray&lt;/a&gt;'s default of 256 is used.</source>
          <target state="translated">在上面的示例中，&lt;a href=&quot;qvarlengtharray&quot;&gt;QVarLengthArray&lt;/a&gt;将在堆栈上预分配1024个元素，除非 &lt;code&gt;n + 1&lt;/code&gt; 大于1024 ，否则将使用它们。如果忽略第二个模板参数，则使用&lt;a href=&quot;qvarlengtharray&quot;&gt;QVarLengthArray&lt;/a&gt;的默认值256。</target>
        </trans-unit>
        <trans-unit id="aba7caa3cf341198fe242e78d0bd2c61020d4ba4" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;b&gt;Alt+U&lt;/b&gt; moves the keyboard focus to the group box. See the &lt;a href=&quot;qshortcut#mnemonic&quot;&gt;QShortcut&lt;/a&gt; documentation for details (to display an actual ampersand, use '&amp;amp;&amp;amp;').</source>
          <target state="translated">在上面的示例中，&lt;b&gt;Alt + U&lt;/b&gt;将键盘焦点移到组框。有关详细信息，请参见&lt;a href=&quot;qshortcut#mnemonic&quot;&gt;QShortcut&lt;/a&gt;文档（要显示实际的&amp;ldquo;＆&amp;rdquo;号，请使用&amp;ldquo; &amp;amp;&amp;amp;&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="c5c177374468ed6ec2a7627bc2bfbadc8a7cc42c" translate="yes" xml:space="preserve">
          <source>In the example above, QVarLengthArray will preallocate 1024 elements on the stack and use them unless &lt;code&gt;n + 1&lt;/code&gt; is greater than 1024. If you omit the second template argument, QVarLengthArray's default of 256 is used.</source>
          <target state="translated">在上面的示例中，QVarLengthArray将在堆栈上预分配1024个元素，除非 &lt;code&gt;n + 1&lt;/code&gt; 大于1024，否则将使用它们。如果忽略第二个模板参数，则使用QVarLengthArray的默认值256。</target>
        </trans-unit>
        <trans-unit id="5a29e3743977f058b9b27432244e6b5e6ae14312" translate="yes" xml:space="preserve">
          <source>In the example above, an expected fail will be written into the test output if the variable &lt;code&gt;i&lt;/code&gt; is not 42. If the variable &lt;code&gt;i&lt;/code&gt; is 42, an unexpected pass is written instead. The QEXPECT_FAIL() has no influence on the second &lt;a href=&quot;qtest#QCOMPARE&quot;&gt;QCOMPARE&lt;/a&gt;() statement in the example.</source>
          <target state="translated">在上面的示例中，如果变量 &lt;code&gt;i&lt;/code&gt; 不为42，则预期的失败将被写入测试输出。如果变量 &lt;code&gt;i&lt;/code&gt; 为42，则写入意外的遍。在示例中，QEXPECT_FAIL（）对第二个&lt;a href=&quot;qtest#QCOMPARE&quot;&gt;QCOMPARE&lt;/a&gt;（）语句没有影响。</target>
        </trans-unit>
        <trans-unit id="ec77cc8baea6451f3b9f84d6cf09cc3bcc9f4dce" translate="yes" xml:space="preserve">
          <source>In the example above, the template specialization for the clone() function calls the</source>
          <target state="translated">在上面的例子中,clone()函数的模板专用化调用了</target>
        </trans-unit>
        <trans-unit id="ec9bdbb3a3c66b35fb808b0997f8cc411d66fe9d" translate="yes" xml:space="preserve">
          <source>In the example above, we first set the current block state to 0. Then, if the previous block ended within a comment, we highlight from the beginning of the current block (&lt;code&gt;startIndex = 0&lt;/code&gt;). Otherwise, we search for the given start expression. If the specified end expression cannot be found in the text block, we change the current block state by calling &lt;a href=&quot;qsyntaxhighlighter#setCurrentBlockState&quot;&gt;setCurrentBlockState&lt;/a&gt;(), and make sure that the rest of the block is highlighted.</source>
          <target state="translated">在上面的示例中，我们首先将当前块状态设置为0。然后，如果前一个块在注释内结束，则从当前块的开头突出显示（ &lt;code&gt;startIndex = 0&lt;/code&gt; ）。否则，我们搜索给定的起始表达式。如果在文本块中找不到指定的结束表达式，则可以通过调用&lt;a href=&quot;qsyntaxhighlighter#setCurrentBlockState&quot;&gt;setCurrentBlockState&lt;/a&gt;（）来更改当前块的状态，并确保突出显示该块的其余部分。</target>
        </trans-unit>
        <trans-unit id="d7d55174bb91d92336e0eb3339b393cc4ebbfbb0" translate="yes" xml:space="preserve">
          <source>In the example above, we set a context property on the root context to expose the C++ object to QML. This means that the property is available to every component loaded by the engine. Context properties are useful for objects that must be available as soon as the QML is loaded and cannot be instantiated in QML.</source>
          <target state="translated">在上面的例子中,我们在根上下文上设置了一个上下文属性,将C++对象暴露给QML。这意味着该属性对引擎加载的每个组件都是可用的。上下文属性对于那些必须在QML加载后就可以使用,并且不能在QML中实例化的对象非常有用。</target>
        </trans-unit>
        <trans-unit id="c97c3d6b593559336f77d8a689881d7bab00fc1a" translate="yes" xml:space="preserve">
          <source>In the example above, we've relied on Qt's global &lt;a href=&quot;qhash#qhash&quot;&gt;qHash&lt;/a&gt;(const &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; &amp;amp;, uint) to give us a hash value for the employee's name, and XOR'ed this with the day they were born to help produce unique hashes for people with the same name.</source>
          <target state="translated">在上面的示例中，我们依靠Qt的全局&lt;a href=&quot;qhash#qhash&quot;&gt;qHash&lt;/a&gt;（const &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;＆，uint）为员工姓名提供了哈希值，并在他们出生的那一天对其进行了XOR处理，以帮助为具有同名。</target>
        </trans-unit>
        <trans-unit id="2aaa6d773c67d90aa07fa3feda293306b8b6dd45" translate="yes" xml:space="preserve">
          <source>In the example above, we've relied on Qt's own implementation of &lt;a href=&quot;qhash#qHashx&quot;&gt;qHash&lt;/a&gt;() for &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; and &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; to give us a hash value for the employee's name and date of birth respectively.</source>
          <target state="translated">在上面的示例中，我们依靠Qt自己对&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;和&lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt;的&lt;a href=&quot;qhash#qHashx&quot;&gt;qHash&lt;/a&gt;（）实现来分别为我们提供员工姓名和出生日期的哈希值。</target>
        </trans-unit>
        <trans-unit id="0dc7adeac1b277e34300fd5d178489f2de0df0e3" translate="yes" xml:space="preserve">
          <source>In the example below, custom &lt;a href=&quot;qml-qtquick-controls2-rangeslider#from-prop&quot;&gt;from&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-controls2-rangeslider#to-prop&quot;&gt;to&lt;/a&gt; values are set, and the initial positions of the &lt;a href=&quot;qml-qtquick-controls2-rangeslider#first-prop&quot;&gt;first&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-controls2-rangeslider#second-prop&quot;&gt;second&lt;/a&gt; handles are set:</source>
          <target state="translated">在下面的示例中，设置了定制的&lt;a href=&quot;qml-qtquick-controls2-rangeslider#from-prop&quot;&gt;from&lt;/a&gt;和&lt;a href=&quot;qml-qtquick-controls2-rangeslider#to-prop&quot;&gt;to&lt;/a&gt;值，并设置了&lt;a href=&quot;qml-qtquick-controls2-rangeslider#first-prop&quot;&gt;第一个&lt;/a&gt;和&lt;a href=&quot;qml-qtquick-controls2-rangeslider#second-prop&quot;&gt;第二个&lt;/a&gt;手柄的初始位置：</target>
        </trans-unit>
        <trans-unit id="901772f1ce46e7dc0d3342b5491786e828a59716" translate="yes" xml:space="preserve">
          <source>In the example below, custom &lt;a href=&quot;qml-qtquick-controls2-slider#from-prop&quot;&gt;from&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-controls2-slider#value-prop&quot;&gt;value&lt;/a&gt;, and &lt;a href=&quot;qml-qtquick-controls2-slider#to-prop&quot;&gt;to&lt;/a&gt; values are set:</source>
          <target state="translated">在以下示例中，设置了自定义&lt;a href=&quot;qml-qtquick-controls2-slider#from-prop&quot;&gt;from&lt;/a&gt;，&lt;a href=&quot;qml-qtquick-controls2-slider#value-prop&quot;&gt;value&lt;/a&gt;和&lt;a href=&quot;qml-qtquick-controls2-slider#to-prop&quot;&gt;to&lt;/a&gt;值：</target>
        </trans-unit>
        <trans-unit id="a5739a38d2823101c1d59a80724de1929c397f87" translate="yes" xml:space="preserve">
          <source>In the example below, we decrease the height of the tickmarks:</source>
          <target state="translated">在下面的例子中,我们降低了刻度线的高度。</target>
        </trans-unit>
        <trans-unit id="0de9861b09f5f9e5be6874d4c2a2189a0b482e52" translate="yes" xml:space="preserve">
          <source>In the example below, we decrease the width of the minor tickmarks:</source>
          <target state="translated">在下面的例子中,我们减少小刻度线的宽度。</target>
        </trans-unit>
        <trans-unit id="090d1a166df46385d8f217eaa03d77850b67b346" translate="yes" xml:space="preserve">
          <source>In the example output, several values have been set using default values obtained from the QDoc configuration file. See &lt;a href=&quot;21-3-qt-dita-xml-output#&quot;&gt;Generating DITA XML Output&lt;/a&gt; for details.</source>
          <target state="translated">在示例输出中，使用从QDoc配置文件获得的默认值设置了多个值。有关详细信息，请参见&lt;a href=&quot;21-3-qt-dita-xml-output#&quot;&gt;生成DITA XML输出&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9b6c383bdd9c7199a5ac185ee9a8e4187a4a3dca" translate="yes" xml:space="preserve">
          <source>In the example shown above, two views of the same type were used to display the same model's data. However, if two different types of view were used, the selected items may be represented very differently in each view; for example, a contiguous selection in a table view can be represented as a fragmented set of highlighted items in a tree view.</source>
          <target state="translated">在上图所示的例子中,使用了两个相同类型的视图来显示同一模型的数据。然而,如果使用了两种不同类型的视图,则所选项目在每个视图中的表示方式可能非常不同;例如,在表格视图中的连续选择在树形视图中可以表示为一组零散的高亮项目。</target>
        </trans-unit>
        <trans-unit id="d0f623a8e91b09e473d555a9d32f4433e146d31b" translate="yes" xml:space="preserve">
          <source>In the example we are going to use a Raspberry Pi 4 SDK (toolchain+sysroot) generated via Yocto, but the instructions here are completely generic, with no dependency on Yocto. The steps are the same with any other toolchain and sysroot, once the toolchain file is updated with the correct cross compiler and other paths.</source>
          <target state="translated">在这个例子中,我们将使用通过Yocto生成的Raspberry Pi 4 SDK(toolchain+sysroot),但这里的说明是完全通用的,不依赖于Yocto。一旦工具链文件更新为正确的交叉编译器和其他路径,步骤与其他工具链和sysroot是一样的。</target>
        </trans-unit>
        <trans-unit id="22b5a17f90422db2a83ff1da975aaf10a658ac71" translate="yes" xml:space="preserve">
          <source>In the example, QDoc didn't need a</source>
          <target state="translated">在本例中,QDoc不需要一个</target>
        </trans-unit>
        <trans-unit id="2d4c74b90ed7327c871e7c9db2b832ce09857c20" translate="yes" xml:space="preserve">
          <source>In the example, for the US we would leave the translation of &quot;AMPM&quot; as it is and thereby use the 12-hour clock branch; but in Europe we would translate it as something else to make the code use the 24-hour clock branch.</source>
          <target state="translated">在这个例子中,对于美国来说,我们会保留 &quot;AMPM &quot;的翻译,从而使用12小时的时钟分支;但在欧洲,我们会把它翻译成其他东西,使代码使用24小时的时钟分支。</target>
        </trans-unit>
        <trans-unit id="2082b270ec671febf3797e8598da895ab18ed2d9" translate="yes" xml:space="preserve">
          <source>In the example, qdoc didn't need a</source>
          <target state="translated">在这个例子中,qdoc不需要一个</target>
        </trans-unit>
        <trans-unit id="23bccdaa8a9c34d06b49ce3a473c4efab01cafc8" translate="yes" xml:space="preserve">
          <source>In the example, the enumeration type that is the property type is declared in MyClass and registered with the &lt;a href=&quot;metaobjects&quot;&gt;Meta-Object System&lt;/a&gt; using the &lt;a href=&quot;qobject#Q_ENUM&quot;&gt;Q_ENUM&lt;/a&gt;() macro. This makes the enumeration values available as strings for use as in the call to &lt;a href=&quot;qobject#setProperty&quot;&gt;setProperty()&lt;/a&gt;. Had the enumeration type been declared in another class, its fully qualified name (i.e., OtherClass::Priority) would be required, and that other class would also have to inherit &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; and register the enumeration type there using the &lt;a href=&quot;qobject#Q_ENUM&quot;&gt;Q_ENUM&lt;/a&gt;() macro.</source>
          <target state="translated">在该示例中，作为属性类型的枚举类型在MyClass中声明，并使用&lt;a href=&quot;qobject#Q_ENUM&quot;&gt;Q_ENUM&lt;/a&gt;（）宏在&lt;a href=&quot;metaobjects&quot;&gt;元对象系统中&lt;/a&gt;注册。这使得枚举值可以作为字符串使用，以用于&lt;a href=&quot;qobject#setProperty&quot;&gt;setProperty（）&lt;/a&gt;的调用。如果在另一个类中声明了枚举类型，则将需要其完全限定名称（即OtherClass :: Priority），并且该其他类还必须继承&lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;并使用&lt;a href=&quot;qobject#Q_ENUM&quot;&gt;Q_ENUM&lt;/a&gt;（）宏在其中注册该枚举类型。</target>
        </trans-unit>
        <trans-unit id="96ac981619b2e22ed5047ee2df0edf2a33aff18b" translate="yes" xml:space="preserve">
          <source>In the example, the enumeration type that is the property type is declared in MyClass and registered with the &lt;a href=&quot;metaobjects#&quot;&gt;Meta-Object System&lt;/a&gt; using the &lt;a href=&quot;qobject#Q_ENUM&quot;&gt;Q_ENUM&lt;/a&gt;() macro. This makes the enumeration values available as strings for use as in the call to &lt;a href=&quot;qobject#setProperty&quot;&gt;setProperty()&lt;/a&gt;. Had the enumeration type been declared in another class, its fully qualified name (i.e., OtherClass::Priority) would be required, and that other class would also have to inherit &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; and register the enumeration type there using the &lt;a href=&quot;qobject#Q_ENUM&quot;&gt;Q_ENUM&lt;/a&gt;() macro.</source>
          <target state="translated">在该示例中，作为属性类型的枚举类型在MyClass中声明，并使用&lt;a href=&quot;qobject#Q_ENUM&quot;&gt;Q_ENUM&lt;/a&gt;（）宏在&lt;a href=&quot;metaobjects#&quot;&gt;元对象系统中&lt;/a&gt;注册。这使得枚举值可以作为字符串使用，以用于&lt;a href=&quot;qobject#setProperty&quot;&gt;setProperty（）&lt;/a&gt;的调用。如果枚举类型在另一个类中声明，则将需要其完全限定的名称（即，OtherClass :: Priority），并且另一个类别也必须继承&lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;并使用&lt;a href=&quot;qobject#Q_ENUM&quot;&gt;Q_ENUM&lt;/a&gt;（）宏在此处注册枚举类型。</target>
        </trans-unit>
        <trans-unit id="871e54560c81446ae41e8e37228eeb0158495db1" translate="yes" xml:space="preserve">
          <source>In the example, we start by comparing the employees' names. If they're equal, we compare their dates of birth to break the tie.</source>
          <target state="translated">在这个例子中,我们首先比较员工的姓名。如果他们的名字相同,我们就比较他们的出生日期,以打破平局。</target>
        </trans-unit>
        <trans-unit id="2439ff4140aeb1647e04fd550853ab6492c67be3" translate="yes" xml:space="preserve">
          <source>In the first line in snippet above, a file URL is constructed from a local, relative path. A file URL with a relative path only makes sense if there is a base URL to resolve it against. For example:</source>
          <target state="translated">在上面代码段的第一行中,文件URL是由一个本地的相对路径构建的。一个相对路径的文件URL只有在有一个基础URL来解析它时才有意义。例如</target>
        </trans-unit>
        <trans-unit id="3ee8fb560994f8b7d0e722e67bce2dd4772d32aa" translate="yes" xml:space="preserve">
          <source>In the following animation, three &lt;a href=&quot;qml-qtquick-controls2-label&quot;&gt;Label&lt;/a&gt; controls are pushed onto a stack view with the &lt;a href=&quot;qml-qtquick-controls2-stackview#push-method&quot;&gt;push()&lt;/a&gt; function:</source>
          <target state="translated">在以下动画中，使用&lt;a href=&quot;qml-qtquick-controls2-stackview#push-method&quot;&gt;push（）&lt;/a&gt;函数将三个&lt;a href=&quot;qml-qtquick-controls2-label&quot;&gt;Label&lt;/a&gt;控件推入堆栈视图：</target>
        </trans-unit>
        <trans-unit id="f96e261c4933f8bc1a17cd985490c34b14f89ec1" translate="yes" xml:space="preserve">
          <source>In the following animation, we &lt;a href=&quot;qml-qtquick-controls2-stackview#replace-method&quot;&gt;replace&lt;/a&gt; the topmost item with &lt;code&gt;D&lt;/code&gt;:</source>
          <target state="translated">在下面的动画中，我们&lt;a href=&quot;qml-qtquick-controls2-stackview#replace-method&quot;&gt;将&lt;/a&gt;最上面的项目替换为 &lt;code&gt;D&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="111f6d9c712f2c81a8b4aeeaa01bfbe30557a196" translate="yes" xml:space="preserve">
          <source>In the following animation, we unwind the stack to the first item by calling &lt;code&gt;pop(null)&lt;/code&gt;:</source>
          <target state="translated">在下面的动画中，我们通过调用 &lt;code&gt;pop(null)&lt;/code&gt; 将堆栈展开到第一项：</target>
        </trans-unit>
        <trans-unit id="9fa72b336529fd5b4a41073264aba34f6f0d897b" translate="yes" xml:space="preserve">
          <source>In the following code snippet, the &lt;code&gt;not front&lt;/code&gt; text is an id to differentiate this &quot;Back&quot; text from the backstepping &quot;Back&quot; text:</source>
          <target state="translated">在下面的代码片段中，&amp;ldquo; &lt;code&gt;not front&lt;/code&gt; &amp;rdquo;文本是一个ID，用于区分此&amp;ldquo; Back&amp;rdquo;文本和Backstepping&amp;ldquo; Back&amp;rdquo;文本：</target>
        </trans-unit>
        <trans-unit id="b757eb68596d90025f293b4adcdf944d51a2a5c5" translate="yes" xml:space="preserve">
          <source>In the following code snippet, the text on the &lt;code&gt;//:&lt;/code&gt; line is the main comment for the translator.</source>
          <target state="translated">在以下代码段中， &lt;code&gt;//:&lt;/code&gt; 行上的文本是翻译程序的主要注释。</target>
        </trans-unit>
        <trans-unit id="f04c01f4e036fa31cb18e1431e24927d2351e913" translate="yes" xml:space="preserve">
          <source>In the following code snippet, we create two &lt;code&gt;Counter&lt;/code&gt; objects and connect the first object's &lt;code&gt;valueChanged()&lt;/code&gt; signal to the second object's &lt;code&gt;setValue()&lt;/code&gt; slot using &lt;a href=&quot;qobject#connect&quot;&gt;QObject::connect&lt;/a&gt;():</source>
          <target state="translated">在以下代码片段中，我们创建两个 &lt;code&gt;Counter&lt;/code&gt; 对象，并使用&lt;a href=&quot;qobject#connect&quot;&gt;QObject :: connect&lt;/a&gt;（）将第一个对象的 &lt;code&gt;valueChanged()&lt;/code&gt; 信号连接到第二个对象的 &lt;code&gt;setValue()&lt;/code&gt; 插槽：</target>
        </trans-unit>
        <trans-unit id="622414a8cf4fe591df097a16a7643cd447aabede" translate="yes" xml:space="preserve">
          <source>In the following code, the text supplied in the event is passed to a &lt;a href=&quot;qtextbrowser&quot;&gt;QTextBrowser&lt;/a&gt; and a &lt;a href=&quot;qcombobox&quot;&gt;QComboBox&lt;/a&gt; is filled with the list of MIME types that are used to describe the data:</source>
          <target state="translated">在下面的代码中，事件中提供的文本将传递到&lt;a href=&quot;qtextbrowser&quot;&gt;QTextBrowser，&lt;/a&gt;并且&lt;a href=&quot;qcombobox&quot;&gt;QComboBox&lt;/a&gt;会填充用于描述数据的MIME类型的列表：</target>
        </trans-unit>
        <trans-unit id="be429f577f9c2139d1960bc0d57d38abce60ba31" translate="yes" xml:space="preserve">
          <source>In the following code, the text supplied in the event is passed to a &lt;a href=&quot;qtextbrowser&quot;&gt;QTextBrowser&lt;/a&gt; and a &lt;a href=&quot;widgets-changes-qt6#qcombobox&quot;&gt;QComboBox&lt;/a&gt; is filled with the list of MIME types that are used to describe the data:</source>
          <target state="translated">在下面的代码中，事件中提供的文本将传递到&lt;a href=&quot;qtextbrowser&quot;&gt;QTextBrowser，&lt;/a&gt;并且&lt;a href=&quot;widgets-changes-qt6#qcombobox&quot;&gt;QComboBox&lt;/a&gt;会填充用于描述数据的MIME类型的列表：</target>
        </trans-unit>
        <trans-unit id="61c53712c1afd7973830d6f8bfc31e688b36ad36" translate="yes" xml:space="preserve">
          <source>In the following code, we provide a slot that receives the &lt;a href=&quot;qitemselectionmodel#currentChanged&quot;&gt;currentChanged()&lt;/a&gt; signal, and uses the information provided to update the status bar of a &lt;a href=&quot;qmainwindow&quot;&gt;QMainWindow&lt;/a&gt;:</source>
          <target state="translated">在下面的代码中，我们提供了一个插槽，用于接收&lt;a href=&quot;qitemselectionmodel#currentChanged&quot;&gt;currentChanged（）&lt;/a&gt;信号，并使用所提供的信息来更新&lt;a href=&quot;qmainwindow&quot;&gt;QMainWindow&lt;/a&gt;的状态栏：</target>
        </trans-unit>
        <trans-unit id="8c2b035c6b28162fbba78ca6c3317891d2e87bbe" translate="yes" xml:space="preserve">
          <source>In the following code, we provide a slot that receives the &lt;a href=&quot;qitemselectionmodel#selectionChanged&quot;&gt;selectionChanged()&lt;/a&gt; signal, fills in the selected items with a string, and clears the contents of the deselected items.</source>
          <target state="translated">在下面的代码中，我们提供了一个插槽，用于接收&lt;a href=&quot;qitemselectionmodel#selectionChanged&quot;&gt;selectionChanged（）&lt;/a&gt;信号，用字符串填充所选的项目，并清除取消选择的项目的内容。</target>
        </trans-unit>
        <trans-unit id="6cf9cf0e5068f95ce7e06ded2831757552ec865a" translate="yes" xml:space="preserve">
          <source>In the following example a C++ method in</source>
          <target state="translated">在下面的例子中,一个C++方法在</target>
        </trans-unit>
        <trans-unit id="4d02ddec645db505d3eeebeeee290af798ebf119" translate="yes" xml:space="preserve">
          <source>In the following example a default &lt;a href=&quot;qml-qtlocation-routequery&quot;&gt;RouteQuery&lt;/a&gt; is declared within &lt;a href=&quot;qml-qtlocation-routemodel&quot;&gt;RouteModel&lt;/a&gt;.</source>
          <target state="translated">在以下示例中，在&lt;a href=&quot;qml-qtlocation-routequery&quot;&gt;RouteModel&lt;/a&gt;中声明了默认的&lt;a href=&quot;qml-qtlocation-routemodel&quot;&gt;RouteQuery&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4da163d57149813e89ffa98f14de916b00f75660" translate="yes" xml:space="preserve">
          <source>In the following example both continuations will run in a new thread (but in the same one).</source>
          <target state="translated">在下面的例子中,两个延续将在一个新的线程中运行(但在同一个线程中)。</target>
        </trans-unit>
        <trans-unit id="ae4de3b3b05758ef20d101a54f004d4086d000e7" translate="yes" xml:space="preserve">
          <source>In the following example both continuations will run in new threads using the same thread pool.</source>
          <target state="translated">在下面的示例中,两个延续将在新的线程中使用同一个线程池运行。</target>
        </trans-unit>
        <trans-unit id="7f33f02aaa6910c3a74694a37c79f2598ee20b84" translate="yes" xml:space="preserve">
          <source>In the following example the line join style changes automatically based on the value of joinStyleIndex:</source>
          <target state="translated">在下面的例子中,行连接样式根据joinStyleIndex的值自动改变。</target>
        </trans-unit>
        <trans-unit id="67c5696202e36e70eaaadaa8cd25a2e81bdf9faf" translate="yes" xml:space="preserve">
          <source>In the following example we change the top and bottom anchors of an item using &lt;a href=&quot;qml-qtquick-anchorchanges&quot;&gt;AnchorChanges&lt;/a&gt;, and the top and bottom anchor margins using &lt;a href=&quot;qml-qtquick-propertychanges&quot;&gt;PropertyChanges&lt;/a&gt;:</source>
          <target state="translated">在以下示例中，我们使用&lt;a href=&quot;qml-qtquick-anchorchanges&quot;&gt;AnchorChanges&lt;/a&gt;更改项目的顶部和底部锚点，并使用&lt;a href=&quot;qml-qtquick-propertychanges&quot;&gt;PropertyChanges&lt;/a&gt;更改顶部和底部锚点边距：</target>
        </trans-unit>
        <trans-unit id="aa7fa50ed60568451f8e6f286366848ba1f74169" translate="yes" xml:space="preserve">
          <source>In the following example we change the top and bottom anchors of an item using AnchorChanges, and the top and bottom anchor margins using &lt;a href=&quot;qml-qtquick-propertychanges&quot;&gt;PropertyChanges&lt;/a&gt;:</source>
          <target state="translated">在下面的示例中，我们使用AnchorChanges更改项目的顶部和底部锚点，并使用&lt;a href=&quot;qml-qtquick-propertychanges&quot;&gt;PropertyChanges&lt;/a&gt;更改顶部和底部锚点边距：</target>
        </trans-unit>
        <trans-unit id="f56fa458d5b1f88eb4269cd4d72db1416e61f851" translate="yes" xml:space="preserve">
          <source>In the following example we have a Path made up of three PathLines. Normally, the items of the &lt;a href=&quot;qml-qtquick-pathview&quot;&gt;PathView&lt;/a&gt; would be laid out equally along this path, with an equal number of items per line segment. &lt;a href=&quot;qml-qtquick-pathpercent&quot;&gt;PathPercent&lt;/a&gt; allows us to specify that the first and third lines should each hold 10% of the laid out items, while the second line should hold the remaining 80%.</source>
          <target state="translated">在以下示例中，我们具有由三个路径线组成的路径。通常，&lt;a href=&quot;qml-qtquick-pathview&quot;&gt;PathView&lt;/a&gt;的项将沿着该路径均匀地布置，每行段具有相等数量的项。&lt;a href=&quot;qml-qtquick-pathpercent&quot;&gt;PathPercent&lt;/a&gt;允许我们指定第一行和第三行应分别占布局项的10％，而第二行应保留其余80％。</target>
        </trans-unit>
        <trans-unit id="a885bd6f57711148c7e8669240ed3c5ae6de2749" translate="yes" xml:space="preserve">
          <source>In the following example we match strings containing 'mail' or 'letter' or 'correspondence' but only match whole words i.e. not 'email'</source>
          <target state="translated">在下面的例子中,我们匹配包含 &quot;mail &quot;或 &quot;letter &quot;或 &quot;correspondence &quot;的字符串,但只匹配整个单词,即不匹配 &quot;email&quot;。</target>
        </trans-unit>
        <trans-unit id="f76ca5184fc13ae062befac58afa357bfb179a95" translate="yes" xml:space="preserve">
          <source>In the following example we use &lt;a href=&quot;qml-qtquick-rotationanimation&quot;&gt;RotationAnimation&lt;/a&gt; to animate the rotation between states via the shortest path:</source>
          <target state="translated">在以下示例中，我们使用&lt;a href=&quot;qml-qtquick-rotationanimation&quot;&gt;RotationAnimation&lt;/a&gt;通过最短路径为状态之间的旋转设置动画：</target>
        </trans-unit>
        <trans-unit id="e6288836c7adceaf47dc63b39d0159627821da0d" translate="yes" xml:space="preserve">
          <source>In the following example we use RotationAnimation to animate the rotation between states via the shortest path:</source>
          <target state="translated">在下面的例子中,我们使用RotationAnimation通过最短路径来制作状态之间的旋转动画。</target>
        </trans-unit>
        <trans-unit id="41c909003b7e0631788266c02806d165f54fcc92" translate="yes" xml:space="preserve">
          <source>In the following example, &lt;a href=&quot;qml-qtquick-controls2-swipedelegate&quot;&gt;SwipeDelegate&lt;/a&gt; is used in a &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; to allow items to be removed from it by swiping to the left:</source>
          <target state="translated">在下面的示例中，在&lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView中&lt;/a&gt;使用&lt;a href=&quot;qml-qtquick-controls2-swipedelegate&quot;&gt;SwipeDelegate&lt;/a&gt;允许通过向左滑动来从其中删除项目：</target>
        </trans-unit>
        <trans-unit id="beb2ca750883ba0f209500d0bde04ade441db658" translate="yes" xml:space="preserve">
          <source>In the following example, &lt;code&gt;comp1&lt;/code&gt; is created within the root context of MyItem.qml, and any objects instantiated from this component will have access to the ids and properties within that context, such as &lt;code&gt;internalSettings.color&lt;/code&gt;. When &lt;code&gt;comp1&lt;/code&gt; is used as a &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; delegate in another context (as in main.qml below), it will continue to have access to the properties of its creation context (which would otherwise be private to external users).</source>
          <target state="translated">在下面的示例中，在 &lt;code&gt;comp1&lt;/code&gt; 的根上下文中创建comp1，并且从该组件实例化的任何对象都可以访问该上下文中的id和属性，例如 &lt;code&gt;internalSettings.color&lt;/code&gt; 。当 &lt;code&gt;comp1&lt;/code&gt; 在另一个上下文中用作&lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt;委托时（如下面的main.qml中所示），它将继续有权访问其创建上下文的属性（否则它将对外部用户私有）。</target>
        </trans-unit>
        <trans-unit id="f5b697e314fcc8c0c2a77f8d2cea534fbcdd860b" translate="yes" xml:space="preserve">
          <source>In the following example, &lt;code&gt;input&lt;/code&gt; will be given active focus when &lt;code&gt;scope&lt;/code&gt; gains active focus:</source>
          <target state="translated">在以下示例中，当 &lt;code&gt;scope&lt;/code&gt; 获得主动焦点时， &lt;code&gt;input&lt;/code&gt; 将被赋予主动焦点：</target>
        </trans-unit>
        <trans-unit id="4e0819da2dbd645615c889341498dfb2518bb623" translate="yes" xml:space="preserve">
          <source>In the following example, SwipeDelegate is used in a &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; to allow items to be removed from it by swiping to the left:</source>
          <target state="translated">在下面的示例中，在&lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView中&lt;/a&gt;使用SwipeDelegate允许向左滑动，从而从其中删除项目：</target>
        </trans-unit>
        <trans-unit id="58c896bb0118fd4b17c3e17913bd0f14d13381d1" translate="yes" xml:space="preserve">
          <source>In the following example, a &lt;a href=&quot;qml-qttest-signalspy&quot;&gt;SignalSpy&lt;/a&gt; is installed to watch the &quot;clicked&quot; signal on a user-defined Button type. When the signal is emitted, the &lt;a href=&quot;qml-qttest-signalspy#count-prop&quot;&gt;count&lt;/a&gt; property on the spy will be increased.</source>
          <target state="translated">在下面的示例中，安装了&lt;a href=&quot;qml-qttest-signalspy&quot;&gt;SignalSpy&lt;/a&gt;来监视用户定义的Button类型上的&amp;ldquo;单击&amp;rdquo;信号。发出信号后，间谍的&lt;a href=&quot;qml-qttest-signalspy#count-prop&quot;&gt;计数&lt;/a&gt;属性将增加。</target>
        </trans-unit>
        <trans-unit id="22378d815a5bf559d36ea737919d7de134256242" translate="yes" xml:space="preserve">
          <source>In the following example, a &lt;a href=&quot;qml-signalspy&quot;&gt;SignalSpy&lt;/a&gt; is installed to watch the &quot;clicked&quot; signal on a user-defined Button type. When the signal is emitted, the &lt;a href=&quot;qml-signalspy#count-prop&quot;&gt;count&lt;/a&gt; property on the spy will be increased.</source>
          <target state="translated">在下面的示例中，安装了&lt;a href=&quot;qml-signalspy&quot;&gt;SignalSpy&lt;/a&gt;来监视用户定义的Button类型上的&amp;ldquo;单击&amp;rdquo;信号。发出信号后，间谍的&lt;a href=&quot;qml-signalspy#count-prop&quot;&gt;计数&lt;/a&gt;属性将增加。</target>
        </trans-unit>
        <trans-unit id="9bd283878d95b8e8b04ed49b21027ac0175cb50a" translate="yes" xml:space="preserve">
          <source>In the following example, a &lt;code&gt;SELECT * FROM&lt;/code&gt; query is executed. Since the order of the columns is not defined, &lt;a href=&quot;qsqlrecord#indexOf&quot;&gt;QSqlRecord::indexOf&lt;/a&gt;() is used to obtain the index of a column.</source>
          <target state="translated">在以下示例中，执行 &lt;code&gt;SELECT * FROM&lt;/code&gt; 查询。由于未定义列的顺序，因此&lt;a href=&quot;qsqlrecord#indexOf&quot;&gt;QSqlRecord :: indexOf&lt;/a&gt;（）用于获取列的索引。</target>
        </trans-unit>
        <trans-unit id="b574e2ffddb2a728a47d6e0edfc1d4407d42d92f" translate="yes" xml:space="preserve">
          <source>In the following example, a SignalSpy is installed to watch the &quot;clicked&quot; signal on a user-defined Button type. When the signal is emitted, the &lt;a href=&quot;qml-qttest-signalspy#count-prop&quot;&gt;count&lt;/a&gt; property on the spy will be increased.</source>
          <target state="translated">在以下示例中，安装了SignalSpy来监视用户定义的Button类型上的&amp;ldquo;单击&amp;rdquo;信号。发出信号后，间谍的&lt;a href=&quot;qml-qttest-signalspy#count-prop&quot;&gt;计数&lt;/a&gt;属性将增加。</target>
        </trans-unit>
        <trans-unit id="c691a15610ea578a567805e044a101f496f9194a" translate="yes" xml:space="preserve">
          <source>In the following example, clicking on the QML object makes the C++ object print a message, and vice-versa. Here is the QML type (in &lt;code&gt;QmlGui.qml&lt;/code&gt;):</source>
          <target state="translated">在下面的示例中，单击QML对象会使C ++对象打印一条消息，反之亦然。这是QML类型（在 &lt;code&gt;QmlGui.qml&lt;/code&gt; 中）：</target>
        </trans-unit>
        <trans-unit id="f623ecae6b0bf3deb0b4709dfed34b752dd6da21" translate="yes" xml:space="preserve">
          <source>In the following example, color is applied for all color groups:</source>
          <target state="translated">在下面的例子中,颜色适用于所有颜色组。</target>
        </trans-unit>
        <trans-unit id="a6df2cdf4213aee987d4b8b2674d10f643c33bbc" translate="yes" xml:space="preserve">
          <source>In the following example, colors will be different for enabled and disabled states:</source>
          <target state="translated">在下面的例子中,启用和禁用状态下的颜色会有所不同。</target>
        </trans-unit>
        <trans-unit id="bd38a731aead71ed9be686fff959ae1dfac6c231" translate="yes" xml:space="preserve">
          <source>In the following example, the &lt;code&gt;addConstant()&lt;/code&gt; method will add 13 to the parameter passed just as the programmer would expect irrespective of the value of the QML object's &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; properties.</source>
          <target state="translated">在下面的示例中，无论程序员如何期望QML对象的 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 属性的值， &lt;code&gt;addConstant()&lt;/code&gt; 方法都将13传递给所传递的参数。</target>
        </trans-unit>
        <trans-unit id="59547659499bdcf5cff2c44ed1079fc9831e4602" translate="yes" xml:space="preserve">
          <source>In the following example, the &lt;code&gt;color&lt;/code&gt; property of &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; depends on the &lt;code&gt;pressed&lt;/code&gt; property of &lt;a href=&quot;qml-qtquick-taphandler&quot;&gt;TapHandler&lt;/a&gt;. This relationship is described using a conditional expression:</source>
          <target state="translated">在下面的示例中，&lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt;的 &lt;code&gt;color&lt;/code&gt; 属性取决于&lt;a href=&quot;qml-qtquick-taphandler&quot;&gt;TapHandler&lt;/a&gt;的 &lt;code&gt;pressed&lt;/code&gt; 属性。使用条件表达式描述此关系：</target>
        </trans-unit>
        <trans-unit id="80c0f852f3619a0ba059397adca8341bc8b6fac9" translate="yes" xml:space="preserve">
          <source>In the following example, the &lt;code&gt;index&lt;/code&gt; context property inserted by the &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; into &lt;code&gt;delegateComponent&lt;/code&gt;'s context will be inaccessible to Text, as the Loader will use the creation context of &lt;code&gt;myComponent&lt;/code&gt; as the parent context when instantiating it, and &lt;code&gt;index&lt;/code&gt; does not refer to anything within that context chain.</source>
          <target state="translated">在以下示例中，Text将无法访问&lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt;插入到 &lt;code&gt;delegateComponent&lt;/code&gt; Components的上下文中的 &lt;code&gt;index&lt;/code&gt; 上下文属性，因为在实例化Loader时，它将使用 &lt;code&gt;myComponent&lt;/code&gt; 的创建上下文作为父上下文，并且 &lt;code&gt;index&lt;/code&gt; 不会引用其中的任何内容该上下文链。</target>
        </trans-unit>
        <trans-unit id="2c1a3b0b7aa04aadcdeaef781ce1273789fd1a3c" translate="yes" xml:space="preserve">
          <source>In the following example, the TextSender class emits a &lt;code&gt;textCompleted()&lt;/code&gt; signal which carries a &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; parameter. Here is the class declaration:</source>
          <target state="translated">在下面的示例中，TextSender类发出带有&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;参数的 &lt;code&gt;textCompleted()&lt;/code&gt; 信号。这是类声明：</target>
        </trans-unit>
        <trans-unit id="a3352880eeab52d6c62295880543212828a87c46" translate="yes" xml:space="preserve">
          <source>In the following example, the accent color of the highlighted button is changed to &lt;code&gt;Material.Orange&lt;/code&gt;:</source>
          <target state="translated">在以下示例中，突出显示的按钮的强调色更改为 &lt;code&gt;Material.Orange&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="78d19a444e0e511a3cb9dcaba69cc7663ab9bb2f" translate="yes" xml:space="preserve">
          <source>In the following example, the accent color of the highlighted button is changed to &lt;code&gt;Universal.Orange&lt;/code&gt;:</source>
          <target state="translated">在以下示例中，突出显示的按钮的强调色更改为 &lt;code&gt;Universal.Orange&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="eb9cd8fd9bd05420727217cf1a0a22388215db8c" translate="yes" xml:space="preserve">
          <source>In the following example, the addition of explicit prevents &lt;code&gt;myItem.width&lt;/code&gt; from being bound to &lt;code&gt;parent.width&lt;/code&gt;. Instead, it is assigned the value of &lt;code&gt;parent.width&lt;/code&gt; at the time of the state change.</source>
          <target state="translated">在以下示例中，添加的explicit防止 &lt;code&gt;myItem.width&lt;/code&gt; 绑定到 &lt;code&gt;parent.width&lt;/code&gt; 。而是在状态更改时为它分配 &lt;code&gt;parent.width&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="96e5e49a119542cf78e7a0de167b4f79267fd829" translate="yes" xml:space="preserve">
          <source>In the following example, the background color of the button is changed to &lt;code&gt;Material.Teal&lt;/code&gt;:</source>
          <target state="translated">在以下示例中，按钮的背景色更改为 &lt;code&gt;Material.Teal&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c0b747eb4cdd1148dbcce2713324d55431bba2e2" translate="yes" xml:space="preserve">
          <source>In the following example, the background color of the pane is changed to &lt;code&gt;Universal.Steel&lt;/code&gt;:</source>
          <target state="translated">在以下示例中，窗格的背景色更改为 &lt;code&gt;Universal.Steel&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a77a03410ece85274f6797b0ef16fdc7b0ab5063" translate="yes" xml:space="preserve">
          <source>In the following example, the delegate shows the property</source>
          <target state="translated">在下面的示例中,委托人显示了属性</target>
        </trans-unit>
        <trans-unit id="cc781dd00dd5a638dbe28a63fadb0fd0a139d73f" translate="yes" xml:space="preserve">
          <source>In the following example, the elevation of the pane is set to &lt;code&gt;6&lt;/code&gt; in order to achieve the look of an &lt;a href=&quot;https://material.google.com/components/cards.html&quot;&gt;elevated card&lt;/a&gt;:</source>
          <target state="translated">在下面的示例中，窗格的高程设置为 &lt;code&gt;6&lt;/code&gt; ，以实现&lt;a href=&quot;https://material.google.com/components/cards.html&quot;&gt;高架卡&lt;/a&gt;的外观：</target>
        </trans-unit>
        <trans-unit id="6bc2b9e30678181b82a731599506d1f147727a2c" translate="yes" xml:space="preserve">
          <source>In the following example, the foreground color of the button is set to &lt;code&gt;Material.Pink&lt;/code&gt;:</source>
          <target state="translated">在下面的示例中，按钮的前景色设置为 &lt;code&gt;Material.Pink&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="d7f80fed26df86ccdd2d3e899168b46e040786bc" translate="yes" xml:space="preserve">
          <source>In the following example, the foreground color of the button is set to &lt;code&gt;Universal.Pink&lt;/code&gt;:</source>
          <target state="translated">在下面的示例中，按钮的前景色设置为 &lt;code&gt;Universal.Pink&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="4989d038344e505731fc2f0e8ab973e6410cb836" translate="yes" xml:space="preserve">
          <source>In the following example, the geometry of each child &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; is bound to that of the parent &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt;. If the geometry of the parent &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; were to change, the geometry of each child &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; would automatically update due to the property bindings.</source>
          <target state="translated">在以下示例中，每个子&lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt;的几何均绑定到父&lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt;的几何。如果父&lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;矩形&lt;/a&gt;的几何形状发生变化，则由于属性绑定，每个子&lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;矩形&lt;/a&gt;的几何形状将自动更新。</target>
        </trans-unit>
        <trans-unit id="341370626c1f494f2c5d38563983b3c8f0df9d88" translate="yes" xml:space="preserve">
          <source>In the following example, the rectangle will spin indefinitely.</source>
          <target state="translated">在下面的例子中,矩形将无限旋转。</target>
        </trans-unit>
        <trans-unit id="743d3704b4909878d3c325ebfc5ee54a02e4c5fa" translate="yes" xml:space="preserve">
          <source>In the following example, the theme for both the pane and the button is set to &lt;code&gt;Material.Dark&lt;/code&gt;:</source>
          <target state="translated">在下面的示例中，窗格和按钮的主题都设置为 &lt;code&gt;Material.Dark&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="2a3d0c980e6076e4372b5a4c0cbaa2d332daabe0" translate="yes" xml:space="preserve">
          <source>In the following example, the theme for both the pane and the button is set to &lt;code&gt;Universal.Dark&lt;/code&gt;:</source>
          <target state="translated">在下面的示例中，窗格和按钮的主题都设置为 &lt;code&gt;Universal.Dark&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="f707a116dec82eb863cb33247b6dd8baae00de63" translate="yes" xml:space="preserve">
          <source>In the following example, we animate a green rectangle along a bezier path.</source>
          <target state="translated">在下面的例子中,我们沿贝塞尔路径制作一个绿色矩形的动画。</target>
        </trans-unit>
        <trans-unit id="f158cd8619df9c72bf318794a5b1bc26fa7e5c13" translate="yes" xml:space="preserve">
          <source>In the following example, we append a CBOR Tag 1 (Unix &lt;code&gt;time_t&lt;/code&gt;) and an integer representing the current time to the stream, obtained using the &lt;code&gt;time()&lt;/code&gt; function:</source>
          <target state="translated">在以下示例中，我们将CBOR标签1（Unix &lt;code&gt;time_t&lt;/code&gt; ）和一个表示当前时间的整数附加到流中，该整数是使用 &lt;code&gt;time()&lt;/code&gt; 函数获得的：</target>
        </trans-unit>
        <trans-unit id="d6fd9744796d1b104621935a4a6328f618455725" translate="yes" xml:space="preserve">
          <source>In the following example, we append a CBOR Tag 36 (Regular Expression) and a &lt;a href=&quot;qregularexpression&quot;&gt;QRegularExpression&lt;/a&gt;'s pattern to the stream:</source>
          <target state="translated">在以下示例中，我们将CBOR标签36（正则表达式）和&lt;a href=&quot;qregularexpression&quot;&gt;QRegularExpression&lt;/a&gt;的模式附加到流中：</target>
        </trans-unit>
        <trans-unit id="dde8423def1bf713051467e8b52e0ba9b677e316" translate="yes" xml:space="preserve">
          <source>In the following example, we append a CBOR Tag 36 (Regular Expression) and a &lt;a href=&quot;qtcore-changes-qt6#qregularexpression&quot;&gt;QRegularExpression&lt;/a&gt;'s pattern to the stream:</source>
          <target state="translated">在以下示例中，我们将CBOR标签36（正则表达式）和&lt;a href=&quot;qtcore-changes-qt6#qregularexpression&quot;&gt;QRegularExpression&lt;/a&gt;的模式附加到流中：</target>
        </trans-unit>
        <trans-unit id="e01cfb48210852f8dd95e4408d9268565b905118" translate="yes" xml:space="preserve">
          <source>In the following example, we declare a property of the enumeration type &lt;code&gt;Priority&lt;/code&gt; that is also called &lt;code&gt;priority&lt;/code&gt; and has a get function &lt;code&gt;priority()&lt;/code&gt; and a set function &lt;code&gt;setPriority()&lt;/code&gt;.</source>
          <target state="translated">在下面的示例中，我们声明枚举类型 &lt;code&gt;Priority&lt;/code&gt; 的属性，该属性也称为 &lt;code&gt;priority&lt;/code&gt; ,并且具有get函数 &lt;code&gt;priority()&lt;/code&gt; 和set函数 &lt;code&gt;setPriority()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9b4a3a1f331007024f30f7e139ccf549e42fccb1" translate="yes" xml:space="preserve">
          <source>In the following example, we have a block of code which is run often (in this case, it is the contents of an explicit loop; but it could be a commonly-evaluated binding expression, for example) and in it, we resolve the object with the &quot;rect&quot; id and its &quot;color&quot; property multiple times:</source>
          <target state="translated">在下面的例子中,我们有一个经常运行的代码块(在这种情况下,它是一个显式循环的内容;但它可能是一个常用的评价绑定表达式,例如),在其中,我们多次解析具有 &quot;rect &quot;id的对象及其 &quot;color &quot;属性。</target>
        </trans-unit>
        <trans-unit id="5ee21d4a3a60fbc00455c78c23d1b1a49e5e2daa" translate="yes" xml:space="preserve">
          <source>In the following example, we have two small rectangles that follow our touch points.</source>
          <target state="translated">在下面的例子中,我们有两个小矩形,按照我们的触摸点。</target>
        </trans-unit>
        <trans-unit id="56883a9b4926a32a7dd3884ccc5a7fe11a5dc3fb" translate="yes" xml:space="preserve">
          <source>In the following example, we write the values -1, -2&lt;sup&gt;32&lt;/sup&gt; and INT64_MIN:</source>
          <target state="translated">在下面的示例中，我们编写值-1，-2 &lt;sup&gt;32&lt;/sup&gt;和INT64_MIN：</target>
        </trans-unit>
        <trans-unit id="c042b833c02669722bfb4cea9e7ff1e503c59868" translate="yes" xml:space="preserve">
          <source>In the following sections we will take a look at how this can be achieved. While the example uses &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-text&quot;&gt;Text&lt;/a&gt;, any Qt Quick content, including Qt Quick Controls, &lt;a href=&quot;qml-qtquick-shapes-shape&quot;&gt;Shape&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-shadereffect&quot;&gt;ShaderEffect&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-particles-particlesystem&quot;&gt;ParticleSystem&lt;/a&gt;, can be used this way.</source>
          <target state="translated">在以下各节中，我们将研究如何实现这一目标。虽然示例使用&lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt;和&lt;a href=&quot;qml-qtquick-text&quot;&gt;Text&lt;/a&gt;，但是可以使用Qt Quick的任何内容，包括Qt Quick Controls，&lt;a href=&quot;qml-qtquick-shapes-shape&quot;&gt;Shape&lt;/a&gt;，&lt;a href=&quot;qml-qtquick-shadereffect&quot;&gt;ShaderEffect&lt;/a&gt;，&lt;a href=&quot;qml-qtquick-particles-particlesystem&quot;&gt;ParticleSystem&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c4f49c2cda8c5197cbdb2d193c5e6de20fce89f5" translate="yes" xml:space="preserve">
          <source>In the following snippet we animate the addition of a right anchor to a &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt;:</source>
          <target state="translated">在以下代码段中，我们为在&lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle上&lt;/a&gt;添加右锚点设置了动画：</target>
        </trans-unit>
        <trans-unit id="c7be1cf0dcf07a7af9e364bcc18d12513fdfed2c" translate="yes" xml:space="preserve">
          <source>In the following table, the various modes are illustrated with animations. The movement and the &lt;a href=&quot;qml-qtquick-controls2-scrollbar#stepSize-prop&quot;&gt;stepSize&lt;/a&gt; (&lt;code&gt;0.25&lt;/code&gt;) are identical in each animation.</source>
          <target state="translated">在下表中，用动画说明了各种模式。每个动画中的移动和&lt;a href=&quot;qml-qtquick-controls2-scrollbar#stepSize-prop&quot;&gt;stepSize&lt;/a&gt;（ &lt;code&gt;0.25&lt;/code&gt; ）都相同。</target>
        </trans-unit>
        <trans-unit id="dd3fb0d762d56fc045cc53eb59db05be298a4209" translate="yes" xml:space="preserve">
          <source>In the following table, the various modes are illustrated with animations. The movement of the mouse cursor and the &lt;a href=&quot;qml-qtquick-controls2-slider#stepSize-prop&quot;&gt;stepSize&lt;/a&gt; (&lt;code&gt;0.2&lt;/code&gt;) are identical in each animation.</source>
          <target state="translated">在下表中，用动画说明了各种模式。每个动画中鼠标光标的移动和&lt;a href=&quot;qml-qtquick-controls2-slider#stepSize-prop&quot;&gt;stepSize&lt;/a&gt;（ &lt;code&gt;0.2&lt;/code&gt; ）都相同。</target>
        </trans-unit>
        <trans-unit id="8e1eef09ea620a7bcaff164ce888f61fc4682e29" translate="yes" xml:space="preserve">
          <source>In the forms settings dialog you can specify the &lt;b&gt;Author&lt;/b&gt; of the form.</source>
          <target state="translated">在表单设置对话框中，您可以指定表单的&lt;b&gt;作者&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="5a6082e9b911ab0b6ba75d67f55be589f6bfd348" translate="yes" xml:space="preserve">
          <source>In the future, this may be extended to specify other types of paragraph decorations.</source>
          <target state="translated">将来可以扩展到指定其他类型的段落装饰。</target>
        </trans-unit>
        <trans-unit id="e60a0aced65c1ee590fed2890ff810aee3e6d361" translate="yes" xml:space="preserve">
          <source>In the generated HTML, the delimited text is surrounded by a &lt;b&gt;&amp;lt;div class=&quot;LegaleseLeft&quot;&amp;gt;&lt;/b&gt; and &lt;b&gt;&amp;lt;/div&amp;gt;&lt;/b&gt; tags.</source>
          <target state="translated">在生成的HTML中，分隔的文本由&lt;b&gt;&amp;lt;div class =&amp;ldquo; LegaleseLeft&amp;rdquo;&amp;gt;&lt;/b&gt;和&lt;b&gt;&amp;lt;/ div&amp;gt;&lt;/b&gt;标记包围。</target>
        </trans-unit>
        <trans-unit id="c57ee3f7da3bc2fe3421eb7c814d7e4cd4bda70e" translate="yes" xml:space="preserve">
          <source>In the header delegate you have access to the following special properties:</source>
          <target state="translated">在头委托中,您可以访问以下特殊属性。</target>
        </trans-unit>
        <trans-unit id="8173b8ef4a5f53c2549b7e4febc3ca8abd181b96" translate="yes" xml:space="preserve">
          <source>In the illustration above, Application One's primary screen is screen 0, and App Two's primary screen is screen 1.</source>
          <target state="translated">在上图中,应用一的主屏幕是0屏,应用二的主屏幕是1屏。</target>
        </trans-unit>
        <trans-unit id="3fb432b3ba74ad6dc109c6c379bc4fff8bedeee3" translate="yes" xml:space="preserve">
          <source>In the image above, the application's contents are</source>
          <target state="translated">在上图中,应用程序的内容为</target>
        </trans-unit>
        <trans-unit id="c211da3ff0af505bb1a04f177de23028d06c25e4" translate="yes" xml:space="preserve">
          <source>In the image below, the Rectangle on the left has transparent borders and has blurred edges, whereas the Rectangle on the right does not:</source>
          <target state="translated">在下图中,左边的矩形有透明的边框,并且边缘模糊,而右边的矩形则没有。</target>
        </trans-unit>
        <trans-unit id="191949eada4e16c66ee51b0e511e500ba2bcfade" translate="yes" xml:space="preserve">
          <source>In the image below, the dashed line represents the button's clickable area, as well as the space that it will take up in a layout. The shadow is marked by the striped area behind it:</source>
          <target state="translated">在下图中,虚线代表了按钮的可点击区域,以及它在布局中所占用的空间。阴影由其背后的条纹区域标记。</target>
        </trans-unit>
        <trans-unit id="f648a46e343e549b31e734ea66fd63991f85987c" translate="yes" xml:space="preserve">
          <source>In the image below, there are 3 MapQuickItems that are identical except for the value of their &lt;a href=&quot;qml-qtlocation-mapquickitem#anchorPoint-prop&quot;&gt;anchorPoint&lt;/a&gt; properties. The values of &lt;a href=&quot;qml-qtlocation-mapquickitem#anchorPoint-prop&quot;&gt;anchorPoint&lt;/a&gt; for each are written on top of the item.</source>
          <target state="translated">在下图中，除了其&lt;a href=&quot;qml-qtlocation-mapquickitem#anchorPoint-prop&quot;&gt;anchorPoint&lt;/a&gt;属性的值外，还有3个相同的MapQuickItem 。每个项目的&lt;a href=&quot;qml-qtlocation-mapquickitem#anchorPoint-prop&quot;&gt;anchorPoint&lt;/a&gt;值都写在该项目的顶部。</target>
        </trans-unit>
        <trans-unit id="082f7f30e8907c70363ecd18171de71be62db1d7" translate="yes" xml:space="preserve">
          <source>In the item delegate you have access to the following special properties:</source>
          <target state="translated">在项目委托中,您可以访问以下特殊属性。</target>
        </trans-unit>
        <trans-unit id="7bb6abe2856b41a5ce3d15e52bcc5ddd2f2d9067" translate="yes" xml:space="preserve">
          <source>In the left-most case, the blue backgrounds can be drawn in one call and the two text elements in another call, as the texts only overlap a background which they are stacked in front of. In the right-most case, the background of &quot;Item 4&quot; overlaps the text of &quot;Item 3&quot; so in this case, each of backgrounds and texts needs to be drawn using separate calls.</source>
          <target state="translated">在最左边的情况下,蓝色背景可以在一个调用中绘制,而两个文本元素可以在另一个调用中绘制,因为文本只与它们堆叠在前面的背景重叠。在最右边的例子中,&quot;项目4 &quot;的背景与 &quot;项目3 &quot;的文本重叠,因此在这种情况下,背景和文本需要分别使用不同的调用来绘制。</target>
        </trans-unit>
        <trans-unit id="177b7d5c2decfb03bbfe45d40de7969b7109f90f" translate="yes" xml:space="preserve">
          <source>In the long term, the application should be adapted to run unmodified:</source>
          <target state="translated">从长远来看,应该调整应用程序,使其不被修改运行。</target>
        </trans-unit>
        <trans-unit id="8c3da8e46d1d8e95626b65e9bb8214b9d517af62" translate="yes" xml:space="preserve">
          <source>In the longer term, the application should be adapted to run unmodified:</source>
          <target state="translated">从长远来看,应调整应用程序,使其不加修改地运行。</target>
        </trans-unit>
        <trans-unit id="51c6be12ebbbbbce5a427c8b0a320a8136d5c56c" translate="yes" xml:space="preserve">
          <source>In the main function, help should be printed to the standard output if the help option was passed and the application should return the exit code 0.</source>
          <target state="translated">在主函数中,如果通过了帮助选项,应将帮助打印到标准输出,应用程序应返回退出代码0。</target>
        </trans-unit>
        <trans-unit id="ed013eb27af18e56a8b0e5420faef98e6525a1de" translate="yes" xml:space="preserve">
          <source>In the material slots list, select the desired material slot.</source>
          <target state="translated">在材料槽列表中,选择所需的材料槽。</target>
        </trans-unit>
        <trans-unit id="5e1a3459ad641f2f0c92cc0960f241ccfd42b74e" translate="yes" xml:space="preserve">
          <source>In the member function documentation,</source>
          <target state="translated">在成员职能文件中:</target>
        </trans-unit>
        <trans-unit id="d77c5dd9303a67ac6d7d5aebb50b969970257a99" translate="yes" xml:space="preserve">
          <source>In the middle of the header</source>
          <target state="translated">在标题的中间</target>
        </trans-unit>
        <trans-unit id="af661d34da446aba519642819b2c4cf4140ea33d" translate="yes" xml:space="preserve">
          <source>In the mode Wildcard, the wildcard characters cannot be escaped. In the mode &lt;a href=&quot;qregexp#PatternSyntax-enum&quot;&gt;WildcardUnix&lt;/a&gt;, the character '\' escapes the wildcard.</source>
          <target state="translated">在通配符模式下，不能对通配符进行转义。在&lt;a href=&quot;qregexp#PatternSyntax-enum&quot;&gt;WildcardUnix&lt;/a&gt;模式下，字符'\'转义通配符。</target>
        </trans-unit>
        <trans-unit id="f8b69786d48f5ae87bab7e6f1ebdcfe64ffe3ce7" translate="yes" xml:space="preserve">
          <source>In the model/view architecture, the model provides a standard interface that views and delegates use to access data. In Qt, the standard interface is defined by the &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; class. No matter how the items of data are stored in any underlying data structure, all subclasses of &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; represent the data as a hierarchical structure containing tables of items. Views use this</source>
          <target state="translated">在模型/视图体系结构中，模型提供了视图和委托用来访问数据的标准接口。在Qt中，标准接口由&lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt;类定义。无论数据项如何存储在任何基础数据结构中，&lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel的&lt;/a&gt;所有子类都将数据表示为包含项表的层次结构。视图使用此</target>
        </trans-unit>
        <trans-unit id="275784bafdfff3eb16930135da34d48478b10553" translate="yes" xml:space="preserve">
          <source>In the model/view architecture, the view obtains items of data from the model and presents them to the user. The way that the data is presented need not resemble the representation of the data provided by the model, and may be</source>
          <target state="translated">在模型/视图架构中,视图从模型中获取数据项,并将其呈现给用户。数据的呈现方式不必与模型提供的数据表示方式相似,可以是</target>
        </trans-unit>
        <trans-unit id="a49a54368d26d92ba28f5862b8e174823625e9b2" translate="yes" xml:space="preserve">
          <source>In the model/view framework, items of data supplied by a single model can be shared by any number of views, and each of these can possibly represent the same information in completely different ways. Custom views and delegates are effective ways to provide radically different representations of the same data. However, applications often need to provide conventional views onto processed versions of the same data, such as differently-sorted views onto a list of items.</source>
          <target state="translated">在模型/视图框架中,由单一模型提供的数据项可以由任何数量的视图共享,其中每个视图都可能以完全不同的方式表示相同的信息。自定义视图和委托是为同一数据提供完全不同的表示方式的有效方法。然而,应用程序经常需要在同一数据的处理版本上提供常规视图,例如在项目列表上提供不同排序的视图。</target>
        </trans-unit>
        <trans-unit id="a21e4b40007ffeb9d778d238317abb44d5c23fe4" translate="yes" xml:space="preserve">
          <source>In the next example the first &lt;a href=&quot;qfuture#onCanceled&quot;&gt;onCanceled&lt;/a&gt;() (&lt;code&gt;Block 2&lt;/code&gt;) is removed:</source>
          <target state="translated">在下一个示例中，第一个&lt;a href=&quot;qfuture#onCanceled&quot;&gt;onCanceled&lt;/a&gt;（）（ &lt;code&gt;Block 2&lt;/code&gt; ）被删除：</target>
        </trans-unit>
        <trans-unit id="e1336f1f47c6dbd46a0c5fbd43afadfef23c59a5" translate="yes" xml:space="preserve">
          <source>In the next example we demonstrate how you can append content to an editable combo box by reacting to the &lt;a href=&quot;qml-qtquick-controls-combobox#accepted-signal&quot;&gt;accepted&lt;/a&gt; signal. Note that you have to explicitly prevent duplicates.</source>
          <target state="translated">在下一个示例中，我们演示如何通过对&lt;a href=&quot;qml-qtquick-controls-combobox#accepted-signal&quot;&gt;接受的&lt;/a&gt;信号做出反应，将内容追加到可编辑的组合框。请注意，您必须明确防止重复。</target>
        </trans-unit>
        <trans-unit id="fff6d48c82e62be915aadae1c2c6306b781872ae" translate="yes" xml:space="preserve">
          <source>In the next example, a &lt;a href=&quot;qml-qtquick-focusscope&quot;&gt;FocusScope&lt;/a&gt; type is added to the component, and the visual result shown.</source>
          <target state="translated">在下一个示例中，将&lt;a href=&quot;qml-qtquick-focusscope&quot;&gt;FocusScope&lt;/a&gt;类型添加到组件，并显示可视结果。</target>
        </trans-unit>
        <trans-unit id="3a84ddb296d495f44770fbc6512d1d10fc13b94a" translate="yes" xml:space="preserve">
          <source>In the next section &lt;b&gt;In-App Purchase Details&lt;/b&gt; you specify the details for at least one language. When the app requests the product details like &lt;code&gt;title&lt;/code&gt; and &lt;code&gt;description&lt;/code&gt;, they will be provided in the language of their locale if they are available. Create language details for the regions you expect to distribute app in.</source>
          <target state="translated">在下一部分&amp;ldquo; &lt;b&gt;应用内购买详细信息&amp;rdquo;中，&lt;/b&gt;您可以指定至少一种语言的详细信息。当应用程序请求商品详细信息（例如 &lt;code&gt;title&lt;/code&gt; 和 &lt;code&gt;description&lt;/code&gt; ，将以其所在地区的语言提供（如果有）。为您希望在其中分发应用程序的区域创建语言详细信息。</target>
        </trans-unit>
        <trans-unit id="42f41286e6a6c222e5fb44103c0dcb5543cb5b89" translate="yes" xml:space="preserve">
          <source>In the normal case, where animations are not used, this will operate as expected. However, if an animation for the &lt;code&gt;geometry&lt;/code&gt; of &lt;code&gt;button&lt;/code&gt; is set on the transition between &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt;, the animation will be started when &lt;code&gt;s2&lt;/code&gt; is entered, but the &lt;code&gt;geometry&lt;/code&gt; property will not actually reach its defined value before the animation is finished running. In this case, the message box will pop up before the geometry of the button has actually been set.</source>
          <target state="translated">在正常情况下，如果不使用动画，它将按预期运行。然而，如果对动画 &lt;code&gt;geometry&lt;/code&gt; 的 &lt;code&gt;button&lt;/code&gt; 设置在之间的过渡 &lt;code&gt;s1&lt;/code&gt; 和 &lt;code&gt;s2&lt;/code&gt; ，动画将被启动时， &lt;code&gt;s2&lt;/code&gt; 进入，但 &lt;code&gt;geometry&lt;/code&gt; 性能实际上不会达到规定值之前的动画运行完毕。在这种情况下，将在实际设置按钮的几何形状之前弹出消息框。</target>
        </trans-unit>
        <trans-unit id="17325e9c13239f8bec358a47722a114c09a84b73" translate="yes" xml:space="preserve">
          <source>In the preferences dialog box, locate the &lt;b&gt;Collada I/O&lt;/b&gt; section under &lt;b&gt;File I/O&lt;/b&gt;. Ensure that the &lt;b&gt;Save Triangles as Triangles&lt;/b&gt; option is checked.</source>
          <target state="translated">在&amp;ldquo;首选项&amp;rdquo;对话框中，在&amp;ldquo;&lt;b&gt;文件I / O&amp;rdquo;&lt;/b&gt;下找到&amp;ldquo; &lt;b&gt;Collada I / O&amp;rdquo;&lt;/b&gt;部分。确保选中&amp;ldquo;&lt;b&gt;将三角形另存为三角形&amp;rdquo;&lt;/b&gt;选项。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ac99875170e76bb77a35adf7514e7d860053b108" translate="yes" xml:space="preserve">
          <source>In the previous example the Image item will implicitly get scroll behavior as if it was used within a &lt;a href=&quot;qml-qtquick-flickable&quot;&gt;Flickable&lt;/a&gt;. The width and height of the child item will be used to define the size of the content area.</source>
          <target state="translated">在前面的示例中，Image项将隐式地获得滚动行为，就像在&lt;a href=&quot;qml-qtquick-flickable&quot;&gt;Flickable&lt;/a&gt;中使用了它一样。子项的宽度和高度将用于定义内容区域的大小。</target>
        </trans-unit>
        <trans-unit id="772b0f71c73902deebe22dad6acf14257c43a016" translate="yes" xml:space="preserve">
          <source>In the previous example,</source>
          <target state="translated">在前面的例子中。</target>
        </trans-unit>
        <trans-unit id="c98f84e7920e2d706fb32da691ff01f1a6ea38e3" translate="yes" xml:space="preserve">
          <source>In the previous example, the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-animation-example.html#propertyanimation&quot;&gt;PropertyAnimation&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation&lt;/a&gt; objects needed to specify particular &lt;a href=&quot;qml-qtquick-propertyanimation#target-prop&quot;&gt;target&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-propertyanimation#properties-prop&quot;&gt;properties&lt;/a&gt; values to specify the objects and properties that should be animated. This can be avoided by using the</source>
          <target state="translated">在前面的示例中，需要使用&lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-animation-example.html#propertyanimation&quot;&gt;PropertyAnimation&lt;/a&gt;和&lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation&lt;/a&gt;对象来指定特定的&lt;a href=&quot;qml-qtquick-propertyanimation#target-prop&quot;&gt;目标&lt;/a&gt;和&lt;a href=&quot;qml-qtquick-propertyanimation#properties-prop&quot;&gt;属性&lt;/a&gt;值，以指定应设置动画的对象和属性。可以通过使用</target>
        </trans-unit>
        <trans-unit id="b8c3f6b5d4707cf4cd86612144462b4d92515e94" translate="yes" xml:space="preserve">
          <source>In the previous example, the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtquick-animation-example.html#propertyanimation&quot;&gt;PropertyAnimation&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation&lt;/a&gt; objects needed to specify particular &lt;a href=&quot;qml-qtquick-propertyanimation#target-prop&quot;&gt;target&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-propertyanimation#properties-prop&quot;&gt;properties&lt;/a&gt; values to specify the objects and properties that should be animated. This can be avoided by using the</source>
          <target state="translated">在前面的示例中，需要使用&lt;a href=&quot;https://doc.qt.io/qt-5.15/qtquick-animation-example.html#propertyanimation&quot;&gt;PropertyAnimation&lt;/a&gt;和&lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation&lt;/a&gt;对象来指定特定的&lt;a href=&quot;qml-qtquick-propertyanimation#target-prop&quot;&gt;目标&lt;/a&gt;和&lt;a href=&quot;qml-qtquick-propertyanimation#properties-prop&quot;&gt;属性&lt;/a&gt;值，以指定应设置动画的对象和属性。可以通过使用</target>
        </trans-unit>
        <trans-unit id="470e4a3556453aa9f435b570f202da3edc9504db" translate="yes" xml:space="preserve">
          <source>In the previous example, the &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtquick-animation-example.html#propertyanimation&quot;&gt;PropertyAnimation&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation&lt;/a&gt; objects needed to specify particular &lt;a href=&quot;qml-qtquick-propertyanimation#target-prop&quot;&gt;target&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-propertyanimation#properties-prop&quot;&gt;properties&lt;/a&gt; values to specify the objects and properties that should be animated. This can be avoided by using the</source>
          <target state="translated">在前面的示例中，需要使用&lt;a href=&quot;https://doc.qt.io/qt-6.0/qtquick-animation-example.html#propertyanimation&quot;&gt;PropertyAnimation&lt;/a&gt;和&lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation&lt;/a&gt;对象来指定特定的&lt;a href=&quot;qml-qtquick-propertyanimation#target-prop&quot;&gt;目标&lt;/a&gt;和&lt;a href=&quot;qml-qtquick-propertyanimation#properties-prop&quot;&gt;属性&lt;/a&gt;值，以指定应设置动画的对象和属性。可以通过使用</target>
        </trans-unit>
        <trans-unit id="2678a9c929c58e4117992261fd411c31e21f57e1" translate="yes" xml:space="preserve">
          <source>In the previous example, the &lt;code&gt;first&lt;/code&gt; property is bound to an empty expression, whose result is undefined. The &lt;code&gt;second&lt;/code&gt; property is bound to an expression which contains a single, empty expression block (&quot;{}&quot;), which similarly has an undefined result. The &lt;code&gt;third&lt;/code&gt; property is bound to an expression which is evaluated as an empty object declaration, and thus the property will be initialized with that empty object value.</source>
          <target state="translated">在前面的示例中，第 &lt;code&gt;first&lt;/code&gt; 属性绑定到一个空表达式，其结果是不确定的。所述 &lt;code&gt;second&lt;/code&gt; 属性绑定到其中包含一个单一的，空表达块（&amp;ldquo;{}&amp;rdquo;），其类似地具有一个未定义的结果的表达式。所述 &lt;code&gt;third&lt;/code&gt; 属性绑定到其被评价为一个空对象的声明，并因此该属性将与该空对象值进行初始化的表达式。</target>
        </trans-unit>
        <trans-unit id="92ee099e4a752c82bfa9a9a7bedb92d22f069ed1" translate="yes" xml:space="preserve">
          <source>In the previous example, the rectangles &lt;code&gt;r0&lt;/code&gt; and &lt;code&gt;r1&lt;/code&gt; do not have any custom properties, and thus the JavaScript and QML engines consider them both to be of the same type. That is, &lt;code&gt;r0&lt;/code&gt; and &lt;code&gt;r1&lt;/code&gt; are both considered to be of the explicitly defined &lt;code&gt;Rectangle&lt;/code&gt; type. The rectangles &lt;code&gt;r2&lt;/code&gt;, &lt;code&gt;r3&lt;/code&gt; and &lt;code&gt;r4&lt;/code&gt; each have custom properties and are each considered to be of different (implicit) types. Note that &lt;code&gt;r3&lt;/code&gt; and &lt;code&gt;r4&lt;/code&gt; are each considered to be of different types, even though they have identical property information, simply because the custom property was not declared in the component which they are instances of.</source>
          <target state="translated">在前面的示例中，矩形 &lt;code&gt;r0&lt;/code&gt; 和 &lt;code&gt;r1&lt;/code&gt; 没有任何自定义属性，因此JavaScript和QML引擎将它们视为同一类型。即， &lt;code&gt;r0&lt;/code&gt; 和 &lt;code&gt;r1&lt;/code&gt; 都被认为是显式定义的 &lt;code&gt;Rectangle&lt;/code&gt; 类型。矩形 &lt;code&gt;r2&lt;/code&gt; ， &lt;code&gt;r3&lt;/code&gt; 和 &lt;code&gt;r4&lt;/code&gt; 每个都具有自定义属性，并且每个矩形都被视为不同（隐式）类型。请注意， &lt;code&gt;r3&lt;/code&gt; 和 &lt;code&gt;r4&lt;/code&gt; 即使它们具有相同的属性信息，它们也被认为是不同类型的，这仅仅是因为自定义属性未在其实例的组件中声明。</target>
        </trans-unit>
        <trans-unit id="c2d170d35d98882879d1582bff3bbe1a36253602" translate="yes" xml:space="preserve">
          <source>In the properties panel, select the &lt;b&gt;material&lt;/b&gt; tab.</source>
          <target state="translated">在属性面板中，选择&amp;ldquo;&lt;b&gt;材质&amp;rdquo;&lt;/b&gt;选项卡。</target>
        </trans-unit>
        <trans-unit id="71a58bdaf4897e02b754535e7683da68018828c6" translate="yes" xml:space="preserve">
          <source>In the properties panel, select the material tab.</source>
          <target state="translated">在属性面板中,选择材料选项卡。</target>
        </trans-unit>
        <trans-unit id="e3f84a9ff267abb577cc935f6add6f080297c590" translate="yes" xml:space="preserve">
          <source>In the properties panel, select the modifiers tab.</source>
          <target state="translated">在属性面板中,选择修改器标签。</target>
        </trans-unit>
        <trans-unit id="c4a5f9e89da640948f69456d909fb4d55bf31b7e" translate="yes" xml:space="preserve">
          <source>In the property editor of Visual Studio we can modify the properties of our controls - &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt; exposes the &lt;code&gt;QWidget&lt;/code&gt; API and has many properties, while QAxWidget2 has only the Visual Studio standard properties in addition to its own property &quot;lineWidth&quot; in the &quot;Miscellaneous&quot; category. The objects are named &quot;axQPushButton1&quot; and &quot;axQAxWidget21&quot;, and since especially the last name is a bit confusing we rename the objects to &quot;resetButton&quot; and &quot;circleWidget&quot;.</source>
          <target state="translated">在Visual Studio中的属性编辑器我们可以修改控件的属性- &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt;公开 &lt;code&gt;QWidget&lt;/code&gt; 的 API，它具有许多特性，而QAxWidget2除了自己的财产&amp;ldquo;的lineWidth&amp;rdquo;中的&amp;ldquo;其他&amp;rdquo;类别只有在Visual Studio标准属性。这些对象被命名为&amp;ldquo; axQPushButton1&amp;rdquo;和&amp;ldquo; axQAxWidget21&amp;rdquo;，并且由于尤其是姓氏有点令人困惑，因此我们将对象重命名为&amp;ldquo; resetButton&amp;rdquo;和&amp;ldquo; circleWidget&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="c0b81292a316bfa3aac884a259c2bc9cdfb2c8aa" translate="yes" xml:space="preserve">
          <source>In the rare case of a date that was entirely skipped (this happens when a zone east of the international date-line switches to being west of it), the return shall be invalid. Passing &lt;a href=&quot;qt#TimeSpec-enum&quot;&gt;Qt::TimeZone&lt;/a&gt; as</source>
          <target state="translated">在极少数情况下，如果某个日期被完全跳过（国际日期线以东的区域切换到其以西的区域时，就会发生这种情况），则返回无效。将&lt;a href=&quot;qt#TimeSpec-enum&quot;&gt;Qt :: TimeZone&lt;/a&gt;传递为</target>
        </trans-unit>
        <trans-unit id="e477cd86bad09a09c16dec5ba813622fdbb4a44c" translate="yes" xml:space="preserve">
          <source>In the row delegate you have access to the following special properties:</source>
          <target state="translated">在行委托中,你可以访问以下特殊属性。</target>
        </trans-unit>
        <trans-unit id="801210748fb4e2e33b01b46d33a3b7b73d92c752" translate="yes" xml:space="preserve">
          <source>In the same manner, &lt;a href=&quot;qml-qtquick-controls2-spinbox&quot;&gt;SpinBox&lt;/a&gt; can be customized to accept floating point numbers:</source>
          <target state="translated">以相同的方式，可以自定义&lt;a href=&quot;qml-qtquick-controls2-spinbox&quot;&gt;SpinBox&lt;/a&gt;以接受浮点数：</target>
        </trans-unit>
        <trans-unit id="b227c5efb22ef0f2410b42cf14130672e8c6ba3f" translate="yes" xml:space="preserve">
          <source>In the same manner, SpinBox can be customized to accept floating point numbers:</source>
          <target state="translated">以同样的方式,SpinBox可以被定制为接受浮点数。</target>
        </trans-unit>
        <trans-unit id="e4cfdf9c5fb054c03b6216a6d300c49b3e804f04" translate="yes" xml:space="preserve">
          <source>In the section about &lt;a href=&quot;#wildcards-in-name-tests&quot;&gt;using wildcards in name tests&lt;/a&gt;, we saw three simple example XQueries, each of which selected a different list of XML attributes from the cookbook. We couldn't use &lt;code&gt;xmlpatterns&lt;/code&gt; to run these queries, however, because &lt;code&gt;xmlpatterns&lt;/code&gt; sends the &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; results to a &lt;a href=&quot;qxmlserializer&quot;&gt;serializer&lt;/a&gt;, which expects to serialize the results as well-formed XML. Since a list of XML attributes by itself is not well-formed XML, the serializer reported an error for each &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt;.</source>
          <target state="translated">在有关&lt;a href=&quot;#wildcards-in-name-tests&quot;&gt;在名称测试中使用通配符&lt;/a&gt;的部分，我们看到了三个简单的示例XQueries，每个示例都从菜谱中选择了不同的XML属性列表。但是，我们无法使用 &lt;code&gt;xmlpatterns&lt;/code&gt; 运行这些查询，因为 &lt;code&gt;xmlpatterns&lt;/code&gt; 将&lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt;结果发送到&lt;a href=&quot;qxmlserializer&quot;&gt;序列化器&lt;/a&gt;，该序列化器希望将结果序列化为格式正确的XML。由于XML属性列表本身不是格式正确的XML，因此序列化程序为每个&lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt;报告一个错误。</target>
        </trans-unit>
        <trans-unit id="5a128015a674ebe1abbeba2144e6cc34dfe2d46d" translate="yes" xml:space="preserve">
          <source>In the section about &lt;a href=&quot;xquery-introduction#wildcards-in-name-tests&quot;&gt;using wildcards in name tests&lt;/a&gt;, we saw three simple example XQueries, each of which selected a different list of XML attributes from the cookbook. We couldn't use &lt;code&gt;xmlpatterns&lt;/code&gt; to run these queries, however, because &lt;code&gt;xmlpatterns&lt;/code&gt; sends the &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; results to a &lt;a href=&quot;qxmlserializer&quot;&gt;serializer&lt;/a&gt;, which expects to serialize the results as well-formed XML. Since a list of XML attributes by itself is not well-formed XML, the serializer reported an error for each &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt;.</source>
          <target state="translated">在有关&lt;a href=&quot;xquery-introduction#wildcards-in-name-tests&quot;&gt;在名称测试中使用通配符&lt;/a&gt;的部分，我们看到了三个简单的示例XQueries，每个示例都从菜谱中选择了不同的XML属性列表。但是，我们无法使用 &lt;code&gt;xmlpatterns&lt;/code&gt; 运行这些查询，因为 &lt;code&gt;xmlpatterns&lt;/code&gt; 将&lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt;结果发送到&lt;a href=&quot;qxmlserializer&quot;&gt;序列化器&lt;/a&gt;，该序列化器希望将结果序列化为格式正确的XML。由于XML属性列表本身不是格式正确的XML，因此序列化程序针对每个&lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt;报告一个错误。</target>
        </trans-unit>
        <trans-unit id="3375442e852a098b37b733339d4e20adf3b09f02" translate="yes" xml:space="preserve">
          <source>In the simplest case, the target of a drag and drop action receives a copy of the data being dragged, and the source decides whether to delete the original. This is described by the &lt;code&gt;CopyAction&lt;/code&gt; action. The target may also choose to handle other actions, specifically the &lt;code&gt;MoveAction&lt;/code&gt; and &lt;code&gt;LinkAction&lt;/code&gt; actions. If the source calls &lt;a href=&quot;qdrag#exec&quot;&gt;QDrag::exec&lt;/a&gt;(), and it returns &lt;code&gt;MoveAction&lt;/code&gt;, the source is responsible for deleting any original data if it chooses to do so. The &lt;a href=&quot;qmimedata&quot;&gt;QMimeData&lt;/a&gt; and &lt;a href=&quot;qdrag&quot;&gt;QDrag&lt;/a&gt; objects created by the source widget</source>
          <target state="translated">在最简单的情况下，拖放操作的目标将收到正在拖动的数据的副本，而源将决定是否删除原始数据。这由 &lt;code&gt;CopyAction&lt;/code&gt; 操作描述。目标还可以选择处理其他动作，特别是 &lt;code&gt;MoveAction&lt;/code&gt; 和 &lt;code&gt;LinkAction&lt;/code&gt; 动作。如果源调用&lt;a href=&quot;qdrag#exec&quot;&gt;QDrag :: exec&lt;/a&gt;（），并且返回 &lt;code&gt;MoveAction&lt;/code&gt; ，则源负责选择删除任何原始数据。由源小部件创建的&lt;a href=&quot;qmimedata&quot;&gt;QMimeData&lt;/a&gt;和&lt;a href=&quot;qdrag&quot;&gt;QDrag&lt;/a&gt;对象</target>
        </trans-unit>
        <trans-unit id="62eff399bf62cee712f1205397f622c033ee20a2" translate="yes" xml:space="preserve">
          <source>In the snippet above, &lt;code&gt;index&lt;/code&gt; is the same for the entire call. This means that accessing to the necessary data structures in order to retrieve the information for &lt;code&gt;index&lt;/code&gt; can be done only once (hoisting the relevant code out of the loop).</source>
          <target state="translated">在上面的代码段中，整个调用的 &lt;code&gt;index&lt;/code&gt; 相同。这意味着访问必要的数据结构以检索 &lt;code&gt;index&lt;/code&gt; 信息只能进行一次（将相关代码提升到循环之外）。</target>
        </trans-unit>
        <trans-unit id="2254b056bbcad6f18a38091e4bbdf3abbd41041c" translate="yes" xml:space="preserve">
          <source>In the snippet above, the following occurs with the executable &lt;code&gt;myapp&lt;/code&gt;:</source>
          <target state="translated">在上面的代码段中，可执行文件 &lt;code&gt;myapp&lt;/code&gt; 发生以下情况：</target>
        </trans-unit>
        <trans-unit id="4b9cd544023cebfc582b57171a486c13536f9da2" translate="yes" xml:space="preserve">
          <source>In the snippet below, the Rectangle on the left has transparent borders and has blurred edges, whereas the Rectangle on the right does not.</source>
          <target state="translated">在下面的代码段中,左边的矩形具有透明的边框和模糊的边缘,而右边的矩形则没有。</target>
        </trans-unit>
        <trans-unit id="b928f56f82db0d1d484f603348dff5be3a155807" translate="yes" xml:space="preserve">
          <source>In the snippet below, the search model has been assigned to the &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt;'s &lt;a href=&quot;qml-qtquick-listview#model-prop&quot;&gt;model&lt;/a&gt; property. When the model is updated with new results, the &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; is automatically updated to reflect the model's new data items.</source>
          <target state="translated">在下面的代码段中，搜索模型已分配给&lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt;的&lt;a href=&quot;qml-qtquick-listview#model-prop&quot;&gt;model&lt;/a&gt;属性。使用新结果更新模型时，&lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt;将自动更新以反映模型的新数据项。</target>
        </trans-unit>
        <trans-unit id="96fd8a43e0a0a576fc00481b0e03bef2707b6cc0" translate="yes" xml:space="preserve">
          <source>In the snippet we see that the [QML]{&lt;a href=&quot;qml-qtlocation-geocodemodel&quot;&gt;GeocodeModel&lt;/a&gt;} contains the plugin and two signal handlers. One for changes in status &lt;a href=&quot;qml-qtlocation-geocodemodel#status-prop&quot;&gt;&lt;code&gt;onStatusChanged&lt;/code&gt;&lt;/a&gt; and the other to update the centering of the Map object &lt;a href=&quot;qml-qtlocation-geocodemodel#locationsChanged-signal&quot;&gt;&lt;code&gt;onLocationsChanged&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在代码段中，我们看到[QML] { &lt;a href=&quot;qml-qtlocation-geocodemodel&quot;&gt;GeocodeModel&lt;/a&gt; }包含插件和两个信号处理程序。一个用于状态&lt;a href=&quot;qml-qtlocation-geocodemodel#status-prop&quot;&gt; &lt;code&gt;onStatusChanged&lt;/code&gt; 的&lt;/a&gt;更改，另一个用于更新Map对象&lt;a href=&quot;qml-qtlocation-geocodemodel#locationsChanged-signal&quot;&gt; &lt;code&gt;onLocationsChanged&lt;/code&gt; 的居中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="989abc71adb9a757a2b4a71aa1947dc82bb1a16f" translate="yes" xml:space="preserve">
          <source>In the special case where an Affector has no possible effect (e.g. Affector {}), this signal will be emitted for all particles being considered if you connect to it. This allows you to execute arbitrary code in response to particles (use the Affector::onAffectParticles signal handler if you want to execute code which affects the particles themselves). As this executes JavaScript code per particle, it is not recommended to use this signal with a high-volume particle system.</source>
          <target state="translated">在一个Affector不可能产生影响的特殊情况下(例如Affector {}),如果你连接到它,所有被考虑的粒子都会发出这个信号。这允许你在响应粒子时执行任意代码(如果你想执行影响粒子本身的代码,请使用Affector::onAffectParticles信号处理程序)。由于这会对每个粒子执行JavaScript代码,所以不建议在高容量粒子系统中使用这个信号。</target>
        </trans-unit>
        <trans-unit id="d66ae85ea2294c0c19f4823ddc222eaff12c166a" translate="yes" xml:space="preserve">
          <source>In the specified directories, QDoc will only read the files with the &lt;code&gt;fileextensions&lt;/code&gt; specified in the &lt;a href=&quot;#headers-fileextensions&quot;&gt;&lt;code&gt;headers.fileextensions&lt;/code&gt;&lt;/a&gt; variable. The default extensions are *.ch, *.h, *.h++, *.hh, *.hpp, and *.hxx&quot;. The files specified by &lt;a href=&quot;#headers&quot;&gt;&lt;code&gt;headers&lt;/code&gt;&lt;/a&gt; will be read without taking into account their fileextensions.</source>
          <target state="translated">在指定的目录中，QDoc将仅读取具有&lt;a href=&quot;#headers-fileextensions&quot;&gt; &lt;code&gt;headers.fileextensions&lt;/code&gt; &lt;/a&gt;变量中指定的文件 &lt;code&gt;fileextensions&lt;/code&gt; 的文件。默认扩展名是* .ch，*。h，*。h ++，*。hh，*。hpp和* .hxx&amp;rdquo;。&lt;a href=&quot;#headers&quot;&gt; &lt;code&gt;headers&lt;/code&gt; &lt;/a&gt;指定的文件将在不考虑其文件扩展名的情况下被读取。</target>
        </trans-unit>
        <trans-unit id="5f1d82693b5802f23c8c35ee835e2826f2e77081" translate="yes" xml:space="preserve">
          <source>In the specified directories, QDoc will only read the files with the &lt;code&gt;fileextensions&lt;/code&gt; specified in the &lt;a href=&quot;#sources-fileextensions&quot;&gt;&lt;code&gt;sources.fileextensions&lt;/code&gt;&lt;/a&gt; variable. The default extensions are *.c++, *.cc, *.cpp and *.cxx. The files specified by &lt;a href=&quot;#sources&quot;&gt;&lt;code&gt;sources&lt;/code&gt;&lt;/a&gt; will be read independent of their fileextensions.</source>
          <target state="translated">在指定的目录中，QDoc将仅读取具有&lt;a href=&quot;#sources-fileextensions&quot;&gt; &lt;code&gt;sources.fileextensions&lt;/code&gt; &lt;/a&gt;变量中指定的文件 &lt;code&gt;fileextensions&lt;/code&gt; 的文件。默认扩展名是* .c ++，*。cc，*。cpp和* .cxx。将读取&lt;a href=&quot;#sources&quot;&gt; &lt;code&gt;sources&lt;/code&gt; &lt;/a&gt;指定的文件，而与文件扩展名无关。</target>
        </trans-unit>
        <trans-unit id="056fdd9f20b3fc01c1122801f4ecdae7833b86a9" translate="yes" xml:space="preserve">
          <source>In the specified directories, QDoc will only read the files with the &lt;code&gt;fileextensions&lt;/code&gt; specified in the &lt;a href=&quot;22-qdoc-configuration-generalvariables#headers-fileextensions&quot;&gt;&lt;code&gt;headers.fileextensions&lt;/code&gt;&lt;/a&gt; variable. The default extensions are *.ch, *.h, *.h++, *.hh, *.hpp, and *.hxx&quot;. The files specified by &lt;a href=&quot;22-qdoc-configuration-generalvariables#headers&quot;&gt;&lt;code&gt;headers&lt;/code&gt;&lt;/a&gt; will be read without taking into account their fileextensions.</source>
          <target state="translated">在指定的目录中，QDoc将仅读取具有&lt;a href=&quot;22-qdoc-configuration-generalvariables#headers-fileextensions&quot;&gt; &lt;code&gt;headers.fileextensions&lt;/code&gt; &lt;/a&gt;变量中指定的文件 &lt;code&gt;fileextensions&lt;/code&gt; 的文件。默认扩展名是* .ch，*。h，*。h ++，*。hh，*。hpp和* .hxx&amp;rdquo;。&lt;a href=&quot;22-qdoc-configuration-generalvariables#headers&quot;&gt; &lt;code&gt;headers&lt;/code&gt; &lt;/a&gt;指定的文件将在不考虑其文件扩展名的情况下被读取。</target>
        </trans-unit>
        <trans-unit id="6151ef08358a2f0dd0f4bce198cfa260d7a12f83" translate="yes" xml:space="preserve">
          <source>In the specified directories, QDoc will only read the files with the &lt;code&gt;fileextensions&lt;/code&gt; specified in the &lt;a href=&quot;22-qdoc-configuration-generalvariables#sources-fileextensions&quot;&gt;&lt;code&gt;sources.fileextensions&lt;/code&gt;&lt;/a&gt; variable. The default extensions are *.c++, *.cc, *.cpp and *.cxx. The files specified by &lt;a href=&quot;22-qdoc-configuration-generalvariables#sources&quot;&gt;&lt;code&gt;sources&lt;/code&gt;&lt;/a&gt; will be read independent of their fileextensions.</source>
          <target state="translated">在指定的目录中，QDoc将仅读取具有在&lt;a href=&quot;22-qdoc-configuration-generalvariables#sources-fileextensions&quot;&gt; &lt;code&gt;sources.fileextensions&lt;/code&gt; &lt;/a&gt;变量中指定的文件 &lt;code&gt;fileextensions&lt;/code&gt; 的文件。默认扩展名是* .c ++，*。cc，*。cpp和* .cxx。将读取&lt;a href=&quot;22-qdoc-configuration-generalvariables#sources&quot;&gt; &lt;code&gt;sources&lt;/code&gt; &lt;/a&gt;指定的文件，而与文件扩展名无关。</target>
        </trans-unit>
        <trans-unit id="40ee7dde22903ab927cdf7620a9752a18131af59" translate="yes" xml:space="preserve">
          <source>In the standard case, the alpha channel is ignored and a fully opaque image is created (typically of format &lt;a href=&quot;qimage#Format-enum&quot;&gt;QImage::Format_RGB32&lt;/a&gt;).</source>
          <target state="translated">在标准情况下，将忽略Alpha通道并创建完全不透明的图像（通常为&lt;a href=&quot;qimage#Format-enum&quot;&gt;QImage :: Format_RGB32&lt;/a&gt;格式）。</target>
        </trans-unit>
        <trans-unit id="eb199f938c6665059b05a219c1f50caa25100d21" translate="yes" xml:space="preserve">
          <source>In the style structure tree, we also include &lt;a href=&quot;qmenu&quot;&gt;QMenu&lt;/a&gt; as it also does styling related work. The bounding rectangles of menu items are calculated for the menu's size hint and when the menu is displayed or resized.</source>
          <target state="translated">在样式结构树中，我们还包括&lt;a href=&quot;qmenu&quot;&gt;QMenu，&lt;/a&gt;因为它也进行样式相关的工作。菜单项的边界矩形是为菜单的大小提示以及菜单的显示或调整大小而计算的。</target>
        </trans-unit>
        <trans-unit id="8e458fb9d3f3f7da311ceeabb2595a4265cb5e04" translate="yes" xml:space="preserve">
          <source>In the table above, &lt;code&gt;&amp;lt;APPNAME&amp;gt;&lt;/code&gt; is usually the organization name, the application name, or both, or a unique name generated at packaging. Similarly, &amp;lt;APPROOT&amp;gt; is the location where this application is installed (often a sandbox). &amp;lt;APPDIR&amp;gt; is the directory containing the application executable.</source>
          <target state="translated">在上表中， &lt;code&gt;&amp;lt;APPNAME&amp;gt;&lt;/code&gt; 通常是组织名称，应用程序名称或两者，或者是包装时生成的唯一名称。同样，&amp;lt;APPROOT&amp;gt;是此应用程序的安装位置（通常是沙箱）。&amp;lt;APPDIR&amp;gt;是包含应用程序可执行文件的目录。</target>
        </trans-unit>
        <trans-unit id="cf5f7ca52e42eebde54614781228fa2e1a26817d" translate="yes" xml:space="preserve">
          <source>In the table, &quot;Amort.&quot; stands for &quot;amortized behavior&quot;. For example, &quot;Amort. O(1)&quot; means that if you call the function only once, you might get O(</source>
          <target state="translated">在表中,&quot;Amort.&quot;代表 &quot;摊销行为&quot;。例如,&quot;Amort.O(1)&quot;意味着如果你只调用该函数一次,你可能会得到O(</target>
        </trans-unit>
        <trans-unit id="b40fb8aac34cbe6100c7335e6381c93eebb9d63a" translate="yes" xml:space="preserve">
          <source>In the world of &lt;a href=&quot;qtquick-index&quot;&gt;QML&lt;/a&gt;, there are additional entities we need to document such as QML signals, attached properties, and QML methods. Internally, they use Qt technologies, however, QML API documentation requires different layout and naming conventions from the Qt C++ API documentation.</source>
          <target state="translated">在&lt;a href=&quot;qtquick-index&quot;&gt;QML&lt;/a&gt;的世界中，我们还需要记录其他实体，例如QML信号，附加属性和QML方法。在内部，他们使用Qt技术，但是，QML API文档要求与Qt C ++ API文档不同的布局和命名约定。</target>
        </trans-unit>
        <trans-unit id="1aa8717ef358ec50a15dea47b01dc1443cd08e34" translate="yes" xml:space="preserve">
          <source>In theory this would allow running your application on every single macOS version released, but for practical (and technical) reasons there is a lower limit to this range, known as the</source>
          <target state="translated">理论上来说,这将允许你的应用程序在每一个已发布的macOS版本上运行,但由于实际(和技术)原因,这个范围有一个下限,称为</target>
        </trans-unit>
        <trans-unit id="255207de917da7fa96bb3e4dfe04909f6d3feaad" translate="yes" xml:space="preserve">
          <source>In these examples, the comments will be associated with the strings passed to tr() in the context of each call.</source>
          <target state="translated">在这些例子中,注释将与每个调用的上下文中传递给tr()的字符串相关联。</target>
        </trans-unit>
        <trans-unit id="859a3deb5ba0f625fda298b3e50025df3ff51021" translate="yes" xml:space="preserve">
          <source>In this approach, we subclass a Qt widget and set up the user interface from within the constructor. Components used in this way expose the widgets and layouts used in the form to the Qt widget subclass, and provide a standard system for making signal and slot connections between the user interface and other objects in your application. The generated &lt;code&gt;Ui::CalculatorForm&lt;/code&gt; structure is a member of the class.</source>
          <target state="translated">在这种方法中，我们将Qt小部件子类化，并从构造函数内部设置用户界面。以这种方式使用的组件将表单中使用的小部件和布局暴露给Qt小部件子类，并提供了用于在用户界面和应用程序中的其他对象之间建立信号和插槽连接的标准系统。生成的 &lt;code&gt;Ui::CalculatorForm&lt;/code&gt; 结构是该类的成员。</target>
        </trans-unit>
        <trans-unit id="362c94c7e88772e9d32d521fb79b74f48ba4533c" translate="yes" xml:space="preserve">
          <source>In this case the -D option ensures that the &lt;code&gt;consoleedition&lt;/code&gt; preprocessor symbol is defined when QDoc processes the source files defined in the qtgui.qdocconf file.</source>
          <target state="translated">在这种情况下，-D选项可确保 &lt;code&gt;consoleedition&lt;/code&gt; 处理在qtgui.qdocconf文件中定义的源文件时定义了consoleedition预处理程序符号。</target>
        </trans-unit>
        <trans-unit id="d5bc21bdf3a5bc63ec2e556ed0988ffbfff9bbfd" translate="yes" xml:space="preserve">
          <source>In this case the -D option ensures that the &lt;code&gt;qtforpython&lt;/code&gt; preprocessor symbol is defined when QDoc processes the source files defined in the qtgui.qdocconf file.</source>
          <target state="translated">在这种情况下，-D选项可确保 &lt;code&gt;qtforpython&lt;/code&gt; 处理在qtgui.qdocconf文件中定义的源文件时定义了qtforpython预处理程序符号。</target>
        </trans-unit>
        <trans-unit id="6dbc7ebb89b91db904e7a322a6d918545a6d30a2" translate="yes" xml:space="preserve">
          <source>In this case the content size of the &lt;a href=&quot;qml-qtquick-controls-scrollview&quot;&gt;ScrollView&lt;/a&gt; will simply mirror that of its contained &lt;a href=&quot;qml-qtquick-controls-scrollview#flickableItem-prop&quot;&gt;flickableItem&lt;/a&gt;.</source>
          <target state="translated">在这种情况下，&lt;a href=&quot;qml-qtquick-controls-scrollview&quot;&gt;ScrollView&lt;/a&gt;的内容大小将仅反映其包含的&lt;a href=&quot;qml-qtquick-controls-scrollview#flickableItem-prop&quot;&gt;flickableItem的大小&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f138d863bd31fe2ee9a4b0dd602baa3a5349ea12" translate="yes" xml:space="preserve">
          <source>In this case the content size of the ScrollView will simply mirror that of its contained &lt;a href=&quot;qml-qtquick-controls-scrollview#flickableItem-prop&quot;&gt;flickableItem&lt;/a&gt;.</source>
          <target state="translated">在这种情况下，ScrollView的内容大小将仅反映其包含的&lt;a href=&quot;qml-qtquick-controls-scrollview#flickableItem-prop&quot;&gt;flickableItem的大小&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="54fdfbf35158389fca9671272bd410b6866e806d" translate="yes" xml:space="preserve">
          <source>In this case the events will occur in the following way:</source>
          <target state="translated">在这种情况下,事件将以下列方式发生。</target>
        </trans-unit>
        <trans-unit id="1b4ea093b00f035470dcb0bcfe53e07e95f4ad32" translate="yes" xml:space="preserve">
          <source>In this case the whole chain of continuations will be interrupted.</source>
          <target state="translated">在这种情况下,整个延续的链条将被打断。</target>
        </trans-unit>
        <trans-unit id="69c2a3e1849c296af6d0417f143fe71be3f75d05" translate="yes" xml:space="preserve">
          <source>In this case we chose &lt;code&gt;8&lt;/code&gt; pixel margins, so we set the &lt;code&gt;implicitWidth&lt;/code&gt; of the tickmarks to that.</source>
          <target state="translated">在这种情况下，我们选择了 &lt;code&gt;8&lt;/code&gt; 个像素边距，因此我们将刻度线的 &lt;code&gt;implicitWidth&lt;/code&gt; 宽度设置为该值。</target>
        </trans-unit>
        <trans-unit id="d96e23997fff4df9e9731671989278a1f195855e" translate="yes" xml:space="preserve">
          <source>In this case we want the application to quit when the state machine is finished, so the machine's</source>
          <target state="translated">在这种情况下,我们希望应用程序在状态机完成后退出,所以机器的</target>
        </trans-unit>
        <trans-unit id="e1b975488490d31b42113087f62327369de204d0" translate="yes" xml:space="preserve">
          <source>In this case we want the application to quit when the state machine is finished, so the machine's &lt;a href=&quot;qstate#finished&quot;&gt;finished()&lt;/a&gt; signal is connected to the application's &lt;a href=&quot;qcoreapplication#quit&quot;&gt;quit()&lt;/a&gt; slot.</source>
          <target state="translated">在这种情况下，我们希望状态机完成时退出应用程序，因此该机的&lt;a href=&quot;qstate#finished&quot;&gt;finish（）&lt;/a&gt;信号连接到应用程序的&lt;a href=&quot;qcoreapplication#quit&quot;&gt;quit（）&lt;/a&gt;插槽。</target>
        </trans-unit>
        <trans-unit id="fb3ffe58383d7277d71ec72c56b71b5ccdb59e72" translate="yes" xml:space="preserve">
          <source>In this case, &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;'s internal data will be generated at compile time; no conversion or allocation will occur at runtime.</source>
          <target state="translated">在这种情况下，&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;的内部数据将在编译时生成。在运行时不会发生任何转换或分配。</target>
        </trans-unit>
        <trans-unit id="b7b16fee52137c726210b352bd2a3513af71290f" translate="yes" xml:space="preserve">
          <source>In this case, Pane cannot calculate a sensible implicit size. Since we're anchoring the &lt;a href=&quot;qml-qtquick-controls2-pageindicator&quot;&gt;PageIndicator&lt;/a&gt; over the &lt;a href=&quot;qml-qtquick-controls2-swipeview&quot;&gt;SwipeView&lt;/a&gt;, we can simply set the content size to the view's implicit size:</source>
          <target state="translated">在这种情况下，Pane无法计算合理的隐式大小。由于我们将&lt;a href=&quot;qml-qtquick-controls2-pageindicator&quot;&gt;PageIndicator&lt;/a&gt;锚定在SwipeView之上，&lt;a href=&quot;qml-qtquick-controls2-swipeview&quot;&gt;因此&lt;/a&gt;我们可以简单地将内容大小设置为视图的隐式大小：</target>
        </trans-unit>
        <trans-unit id="0c14340d72a02580e23a64a2b4670ce106e45f16" translate="yes" xml:space="preserve">
          <source>In this case, Popup cannot calculate a sensible implicit size. Since we're anchoring the &lt;a href=&quot;qml-qtquick-controls2-pageindicator&quot;&gt;PageIndicator&lt;/a&gt; over the &lt;a href=&quot;qml-qtquick-controls2-swipeview&quot;&gt;SwipeView&lt;/a&gt;, we can simply set the content size to the view's implicit size:</source>
          <target state="translated">在这种情况下，Popup无法计算合理的隐式大小。由于我们将&lt;a href=&quot;qml-qtquick-controls2-pageindicator&quot;&gt;PageIndicator&lt;/a&gt;锚定在SwipeView之上，&lt;a href=&quot;qml-qtquick-controls2-swipeview&quot;&gt;因此&lt;/a&gt;我们可以简单地将内容大小设置为视图的隐式大小：</target>
        </trans-unit>
        <trans-unit id="55d2bd1f24a4bc5b8d4a75b8ac6bd6239d493a88" translate="yes" xml:space="preserve">
          <source>In this case, a margin of 5 pixels is reserved to the left of</source>
          <target state="translated">在这种情况下,左边的</target>
        </trans-unit>
        <trans-unit id="2559699cff65ead711a811fd8cb59e14e6e11bff" translate="yes" xml:space="preserve">
          <source>In this case, create the correct wrapper class explicitly:</source>
          <target state="translated">在这种情况下,显式创建正确的封装类。</target>
        </trans-unit>
        <trans-unit id="d72df5d9857db08c85e9d865105471fa46d122b7" translate="yes" xml:space="preserve">
          <source>In this case, instead of:</source>
          <target state="translated">在这种情况下,代替。</target>
        </trans-unit>
        <trans-unit id="d44d0c003d379650806aa61e32500800e5f47f98" translate="yes" xml:space="preserve">
          <source>In this case, it may help to register the server as Administrator.</source>
          <target state="translated">在这种情况下,将服务器注册为管理员可能会有帮助。</target>
        </trans-unit>
        <trans-unit id="4de0ffe19fb979ad27b3dd71c09d8ee90acf5a96" translate="yes" xml:space="preserve">
          <source>In this case, the &lt;code&gt;Ui::CalculatorForm&lt;/code&gt; is an interface description object from the &lt;code&gt;ui_calculatorform.h&lt;/code&gt; file that sets up all the dialog's widgets and the connections between its signals and slots.</source>
          <target state="translated">在这种情况下， &lt;code&gt;Ui::CalculatorForm&lt;/code&gt; 是 &lt;code&gt;ui_calculatorform.h&lt;/code&gt; 文件中的接口描述对象，该对象设置所有对话框的小部件以及其信号和插槽之间的连接。</target>
        </trans-unit>
        <trans-unit id="761305134fb58163fb1211cb04e3a83c4da88d12" translate="yes" xml:space="preserve">
          <source>In this case, the QQuickWindow represents the scene, and provides the intrastructure for rendering a frame. It will not be backed by a render loop and a native window. Instead, in this case the application drives rendering, effectively substituting for the render loops. This allows generating image sequences, rendering into textures for use in external 3D engines, or rendering Qt Quick content within a VR environment.</source>
          <target state="translated">在这种情况下,QQuickWindow代表了场景,并提供了渲染一帧的基础结构。它不会被渲染循环和本地窗口所支持。相反,在这种情况下,应用程序将驱动渲染,有效地替代渲染循环。这允许生成图像序列,渲染成纹理供外部3D引擎使用,或在VR环境中渲染Qt Quick内容。</target>
        </trans-unit>
        <trans-unit id="557cb66c99ce847b1304ea0d2bca926ea7fa7f82" translate="yes" xml:space="preserve">
          <source>In this case, the Text item will be created in the engine's &lt;a href=&quot;qqmlengine#rootContext&quot;&gt;root context&lt;/a&gt;.</source>
          <target state="translated">在这种情况下，将在引擎的&lt;a href=&quot;qqmlengine#rootContext&quot;&gt;根上下文中&lt;/a&gt;创建Text项。</target>
        </trans-unit>
        <trans-unit id="c2fe0b85a97ec0c6f60af5b8b7ab7d0828ea2f99" translate="yes" xml:space="preserve">
          <source>In this case, the content on the display connected via DisplayPort will be the same as on the HDMI one. This is ensured by scanning out the same buffer on both.</source>
          <target state="translated">在这种情况下,通过DisplayPort连接的显示器上的内容将与HDMI显示器上的内容相同。这是通过在两者上扫描出相同的缓冲区来确保的。</target>
        </trans-unit>
        <trans-unit id="335f5842e550058035279d36d68ce4217c4bd258" translate="yes" xml:space="preserve">
          <source>In this case, the default font query will be used with no modifications (so font size, for instance, will be the system default).</source>
          <target state="translated">在这种情况下,将使用默认的字体查询,不做任何修改(所以字体大小,例如,将是系统默认的)。</target>
        </trans-unit>
        <trans-unit id="5093c104f6dbd51736a8187dd3bd4b0f6b1d9d6c" translate="yes" xml:space="preserve">
          <source>In this case, the engine will emit an error and refuse to load the file.</source>
          <target state="translated">在这种情况下,引擎会发出一个错误并拒绝加载文件。</target>
        </trans-unit>
        <trans-unit id="6e9923736f41d1c99c5ade89166c3d1e07ec481f" translate="yes" xml:space="preserve">
          <source>In this case, the file is accessible as &lt;code&gt;:/myresources/cut-img.png&lt;/code&gt;.</source>
          <target state="translated">在这种情况下，可以通过 &lt;code&gt;:/myresources/cut-img.png&lt;/code&gt; 访问该文件。</target>
        </trans-unit>
        <trans-unit id="9e4817c64065a76057f86d53f70dd09bfacecc35" translate="yes" xml:space="preserve">
          <source>In this case, the filter attributes</source>
          <target state="translated">在这种情况下,过滤器的属性是</target>
        </trans-unit>
        <trans-unit id="5db201376463ec4ac414b7caf1047c66a4faa690" translate="yes" xml:space="preserve">
          <source>In this case, the left edge of</source>
          <target state="translated">在这种情况下,左边缘的</target>
        </trans-unit>
        <trans-unit id="f0ead38ce400183da10325a74e03ec2d21aa8a43" translate="yes" xml:space="preserve">
          <source>In this case, the name of the</source>
          <target state="translated">的名称。</target>
        </trans-unit>
        <trans-unit id="9dc83f168232d217b8a040e7b9dd001b4be5feb5" translate="yes" xml:space="preserve">
          <source>In this case, the order of destruction causes a problem. The parent's destructor is called first because it was created last. It then calls the destructor of its child, &lt;code&gt;quit&lt;/code&gt;, which is incorrect because &lt;code&gt;quit&lt;/code&gt; is a local variable. When &lt;code&gt;quit&lt;/code&gt; subsequently goes out of scope, its destructor is called again, this time correctly, but the damage has already been done.</source>
          <target state="translated">在这种情况下，破坏顺序会引起问题。首先调用父级的析构函数，因为它是最后创建的。然后，它将调用其子项的析构函数 &lt;code&gt;quit&lt;/code&gt; ，这是不正确的，因为 &lt;code&gt;quit&lt;/code&gt; 是局部变量。当 &lt;code&gt;quit&lt;/code&gt; 随后超出范围时，它的析构函数将再次被调用，这一次是正确的，但是损害已经造成。</target>
        </trans-unit>
        <trans-unit id="bf2fce7fc50e346d6aa873ac66e0403499b0f04a" translate="yes" xml:space="preserve">
          <source>In this case, the regular expression engine should report a partial match, so that we can match again adding new data and (eventually) get a complete match. This implies that the regular expression engine may assume that there are other characters</source>
          <target state="translated">在这种情况下,正则表达式引擎应该报告一个部分匹配,这样我们就可以再次添加新的数据进行匹配,(最终)得到一个完整的匹配。这意味着,正则表达式引擎可能会假设还有其他的字符</target>
        </trans-unit>
        <trans-unit id="b6d78751de3cfb23108400a3b33466817569417c" translate="yes" xml:space="preserve">
          <source>In this case, the return value is unimportant; we return an arbitrary value to satisfy the compiler.</source>
          <target state="translated">在这种情况下,返回值是不重要的,我们返回一个任意的值来满足编译器的要求。</target>
        </trans-unit>
        <trans-unit id="9ec7f7d20357b4785d0506c8b802f3a49cbf18dd" translate="yes" xml:space="preserve">
          <source>In this case, the subpattern &lt;code&gt;abc\\w+X&lt;/code&gt; partially matches the subject string; however, the subpattern &lt;code&gt;def&lt;/code&gt; matches the subject string completely, and therefore a complete match is reported.</source>
          <target state="translated">在这种情况下，子模式 &lt;code&gt;abc\\w+X&lt;/code&gt; 部分匹配主题字符串；但是，子模式 &lt;code&gt;def&lt;/code&gt; 与主题字符串完全匹配，因此报告了完全匹配。</target>
        </trans-unit>
        <trans-unit id="32e27bbec8f2b28526f2a1647b8241468b8f9d32" translate="yes" xml:space="preserve">
          <source>In this case, the texture interpolation between a fully-transparent pixel and its neighboring somewhat-opaque pixel blends the RGB values between the two. If you use the image editing tool's transparent layers, the RGB values for certain transparent pixels are saved as white, and you will thus see white fringing at the edges of your transparent regions.</source>
          <target state="translated">在这种情况下,完全透明的像素与其相邻的有些不透明的像素之间的纹理插值会将两者之间的RGB值混合。如果你使用图像编辑工具的透明图层,某些透明像素的RGB值会被保存为白色,因此你会在透明区域的边缘看到白色边缘。</target>
        </trans-unit>
        <trans-unit id="1621cf0096ee51e3a619b6331b188460f09d0bd5" translate="yes" xml:space="preserve">
          <source>In this case, the widgets used in the user interface can be accessed in the same say as a widget created in code by hand. We no longer require the &lt;code&gt;ui&lt;/code&gt; prefix to access them.</source>
          <target state="translated">在这种情况下，可以用与手动编写代码中的窗口小部件相同的方式访问用户界面中使用的窗口小部件。我们不再需要 &lt;code&gt;ui&lt;/code&gt; 前缀来访问它们。</target>
        </trans-unit>
        <trans-unit id="f75ffd3874db6ea6ce0b615a59236fe8404b4e5d" translate="yes" xml:space="preserve">
          <source>In this case, we accept the proposed action without checking what it is. In a real world application, it may be necessary to return from the &lt;a href=&quot;qwidget#dropEvent&quot;&gt;dropEvent()&lt;/a&gt; function without accepting the proposed action or handling the data if the action is not relevant. For example, we may choose to ignore &lt;a href=&quot;qt#DropAction-enum&quot;&gt;Qt::LinkAction&lt;/a&gt; actions if we do not support links to external sources in our application.</source>
          <target state="translated">在这种情况下，我们接受建议的操作而不检查它是什么。在现实世界的应用程序中，可能需要从&lt;a href=&quot;qwidget#dropEvent&quot;&gt;dropEvent（）&lt;/a&gt;函数返回而不接受建议的操作或处理与操作无关的数据。例如，如果我们不支持在应用程序中指向外部源的链接，则可以选择忽略&lt;a href=&quot;qt#DropAction-enum&quot;&gt;Qt :: LinkAction&lt;/a&gt;操作。</target>
        </trans-unit>
        <trans-unit id="12de9c11e19e2cf1aa429067cf7c63431e574ddf" translate="yes" xml:space="preserve">
          <source>In this case, we just use the geometry information provided by the view option in the item rectangle. A delegate that renders items with several elements would not use the item rectangle directly. It would position the editor in relation to the other elements in the item.</source>
          <target state="translated">在这种情况下,我们只需要在 item 矩形中使用视图选项提供的几何信息。渲染有多个元素的项目的委托不会直接使用 item 矩形,它将根据项目中其他元素的关系定位编辑器。它将根据项目中其他元素的关系来定位编辑器。</target>
        </trans-unit>
        <trans-unit id="a5b579c1c4a5b92543cefd293a9eb46587cc9a52" translate="yes" xml:space="preserve">
          <source>In this case, we refuse to deal with move operations. Each type of drop action that we accept is checked and dealt with accordingly:</source>
          <target state="translated">在这种情况下,我们拒绝处理移动操作。我们接受的每一种投放操作都会进行相应的检查和处理。</target>
        </trans-unit>
        <trans-unit id="9acf73b8652dc00675062e9a5cb9499c1c12038b" translate="yes" xml:space="preserve">
          <source>In this case, we set up a default &lt;a href=&quot;qfilesystemmodel&quot;&gt;QFileSystemModel&lt;/a&gt;, obtain a parent index using a specific implementation of &lt;a href=&quot;qfilesystemmodel#index&quot;&gt;index()&lt;/a&gt; provided by that model, and we count the number of rows in the model using the &lt;a href=&quot;qfilesystemmodel#rowCount&quot;&gt;rowCount()&lt;/a&gt; function.</source>
          <target state="translated">在这种情况下，我们设置默认的&lt;a href=&quot;qfilesystemmodel&quot;&gt;QFileSystemModel&lt;/a&gt;，使用该模型提供的&lt;a href=&quot;qfilesystemmodel#index&quot;&gt;index（）&lt;/a&gt;的特定实现获取父索引，然后使用&lt;a href=&quot;qfilesystemmodel#rowCount&quot;&gt;rowCount（）&lt;/a&gt;函数对模型中的行数进行计数。</target>
        </trans-unit>
        <trans-unit id="8343e7cf55f18383906f6a3af0acd82dba14d3f8" translate="yes" xml:space="preserve">
          <source>In this case, we start by setting up a default &lt;a href=&quot;qfilesystemmodel&quot;&gt;QFileSystemModel&lt;/a&gt;. We connect it to a lambda, in which we will obtain a parent index using a specific implementation of &lt;a href=&quot;qfilesystemmodel#index&quot;&gt;index()&lt;/a&gt; provided by that model. In the lambda, we count the number of rows in the model using the &lt;a href=&quot;qfilesystemmodel#rowCount&quot;&gt;rowCount()&lt;/a&gt; function. Finally, we set the root path of the &lt;a href=&quot;qfilesystemmodel&quot;&gt;QFileSystemModel&lt;/a&gt; so it starts loading data and triggers the lambda.</source>
          <target state="translated">在这种情况下，我们首先设置默认的&lt;a href=&quot;qfilesystemmodel&quot;&gt;QFileSystemModel&lt;/a&gt;。我们将其连接到lambda，在其中我们将使用该模型提供的&lt;a href=&quot;qfilesystemmodel#index&quot;&gt;index（）&lt;/a&gt;的特定实现来获取父索引。在lambda中，我们使用&lt;a href=&quot;qfilesystemmodel#rowCount&quot;&gt;rowCount（）&lt;/a&gt;函数对模型中的行数进行计数。最后，我们设置&lt;a href=&quot;qfilesystemmodel&quot;&gt;QFileSystemModel&lt;/a&gt;的根路径，以便它开始加载数据并触发lambda。</target>
        </trans-unit>
        <trans-unit id="e105cc32dae04734242b23d52e7cc6250dbcb385" translate="yes" xml:space="preserve">
          <source>In this case, when the result of the lookup is ready, the slot or signal &lt;code&gt;function&lt;/code&gt; in &lt;code&gt;receiver&lt;/code&gt; is called with a &lt;a href=&quot;qhostinfo&quot;&gt;QHostInfo&lt;/a&gt; argument. The &lt;a href=&quot;qhostinfo&quot;&gt;QHostInfo&lt;/a&gt; object can then be inspected to get the results of the lookup.</source>
          <target state="translated">在这种情况下，当查找的结果是准备好时，狭槽或信号 &lt;code&gt;function&lt;/code&gt; 在 &lt;code&gt;receiver&lt;/code&gt; 是带一个&lt;a href=&quot;qhostinfo&quot;&gt;QHostInfo&lt;/a&gt;参数。该&lt;a href=&quot;qhostinfo&quot;&gt;QHostInfo&lt;/a&gt;然后对象可以被检查，以获取查找结果。</target>
        </trans-unit>
        <trans-unit id="c51e900b55884395dfabf713dd789c6e80fbe934" translate="yes" xml:space="preserve">
          <source>In this case, you need to have a sub-project with a &lt;code&gt;lib&lt;/code&gt; template that provides a different executable for the service. A sample project &lt;code&gt;.pro&lt;/code&gt; is:</source>
          <target state="translated">在这种情况下，您需要一个带有 &lt;code&gt;lib&lt;/code&gt; 模板的子项目，该模板为服务提供不同的可执行文件。一个示例项目 &lt;code&gt;.pro&lt;/code&gt; 是：</target>
        </trans-unit>
        <trans-unit id="de22ce1b8b536997974c104fcfaa9f3c17db2579" translate="yes" xml:space="preserve">
          <source>In this chapter, we look at each of the structural elements used in a rich text document, outline their features and uses, and show how to examine their contents. Document editing is described in &lt;a href=&quot;richtext-cursor&quot;&gt;The QTextCursor Interface&lt;/a&gt;.</source>
          <target state="translated">在本章中，我们研究了富文本文档中使用的每个结构元素，概述了它们的功能和用途，并展示了如何检查其内容。&lt;a href=&quot;richtext-cursor&quot;&gt;QTextCursor界面中&lt;/a&gt;介绍了文档编辑。</target>
        </trans-unit>
        <trans-unit id="2edc8f830b62cce7cad4ec3440f658823ce98aa6" translate="yes" xml:space="preserve">
          <source>In this chapter, we look at each of the structural elements used in a rich text document, outline their features and uses, and show how to examine their contents. Document editing is described in &lt;a href=&quot;richtext-cursor#&quot;&gt;The QTextCursor Interface&lt;/a&gt;.</source>
          <target state="translated">在本章中，我们研究了富文本文档中使用的每个结构元素，概述了它们的功能和用途，并展示了如何检查其内容。&lt;a href=&quot;richtext-cursor#&quot;&gt;QTextCursor接口中&lt;/a&gt;介绍了文档编辑。</target>
        </trans-unit>
        <trans-unit id="80c6e171cbf5feee976517b022361c692a20a725" translate="yes" xml:space="preserve">
          <source>In this code sample, we loop through all devices that are able to output sound, i.e., play an audio stream in a supported format. For each device we find, we simply print the &lt;a href=&quot;qaudiodeviceinfo#deviceName&quot;&gt;deviceName&lt;/a&gt;().</source>
          <target state="translated">在此代码示例中，我们循环浏览所有能够输出声音的设备，即以受支持的格式播放音频流。对于找到的每个设备，我们只需打印&lt;a href=&quot;qaudiodeviceinfo#deviceName&quot;&gt;deviceName&lt;/a&gt;（）。</target>
        </trans-unit>
        <trans-unit id="1b5206919f18117e9f9142181c621fe66ea653e5" translate="yes" xml:space="preserve">
          <source>In this context same as Locale.ShortFormat</source>
          <target state="translated">在此上下文中,与Locale.ShortFormat相同。</target>
        </trans-unit>
        <trans-unit id="77d00177c82097c5be50486e9ab9d1159a60412b" translate="yes" xml:space="preserve">
          <source>In this discussion, we will concentrate on &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; and &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt;. The iterator types for &lt;a href=&quot;qlinkedlist&quot;&gt;QLinkedList&lt;/a&gt;, &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt;, and &lt;a href=&quot;qset&quot;&gt;QSet&lt;/a&gt; have exactly the same interface as &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt;'s iterators; similarly, the iterator types for &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt; have the same interface as &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt;'s iterators.</source>
          <target state="translated">在此讨论中，我们将专注于&lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt;和&lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt;。&lt;a href=&quot;qlinkedlist&quot;&gt;QLinkedList&lt;/a&gt;，&lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt;和&lt;a href=&quot;qset&quot;&gt;QSet&lt;/a&gt;的迭代器类型与&lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt;的迭代器具有完全相同的接口。同样，&lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt;的迭代器类型与&lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt;的迭代器具有相同的接口。</target>
        </trans-unit>
        <trans-unit id="5cb0dfba726aef19da406e338c4572e830559fd4" translate="yes" xml:space="preserve">
          <source>In this discussion, we will concentrate on &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; and &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt;. The iterator types for &lt;a href=&quot;qset&quot;&gt;QSet&lt;/a&gt; have exactly the same interface as &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt;'s iterators; similarly, the iterator types for &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt; have the same interface as &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt;'s iterators.</source>
          <target state="translated">在此讨论中，我们将专注于&lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt;和&lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt;。&lt;a href=&quot;qset&quot;&gt;QSet&lt;/a&gt;的迭代器类型与&lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt;的迭代器具有完全相同的接口；同样，&lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt;的迭代器类型与&lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt;的迭代器具有相同的接口。</target>
        </trans-unit>
        <trans-unit id="f5c1d5453199ec850f95b3864b16bde1f1033ecc" translate="yes" xml:space="preserve">
          <source>In this discussion, we will concentrate on &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; and &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt;. The iterator types for QLinkedList, &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt;, and &lt;a href=&quot;qset&quot;&gt;QSet&lt;/a&gt; have exactly the same interface as &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt;'s iterators; similarly, the iterator types for &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt; have the same interface as &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt;'s iterators.</source>
          <target state="translated">在此讨论中，我们将专注于&lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt;和&lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt;。QLinkedList，&lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt;和&lt;a href=&quot;qset&quot;&gt;QSet&lt;/a&gt;的迭代器类型与&lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt;的迭代器具有完全相同的接口。同样，&lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt;的迭代器类型与&lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt;的迭代器具有相同的接口。</target>
        </trans-unit>
        <trans-unit id="c5b9f46acbee65ef19179225693f73e525c0e7d2" translate="yes" xml:space="preserve">
          <source>In this document, we take a custom type and describe how to integrate it into Qt's object model so that it can be stored in the same way as standard Qt types. We then show how to register the custom type to allow it to be used in signals and slots connections.</source>
          <target state="translated">在这篇文档中,我们采用了一个自定义类型,并描述了如何将其集成到Qt的对象模型中,使其能够以与标准Qt类型相同的方式存储。然后,我们将展示如何注册自定义类型,以允许它在信号和插槽连接中使用。</target>
        </trans-unit>
        <trans-unit id="deae06da34c5ea98ed2af81fad213ae5b7bbd837" translate="yes" xml:space="preserve">
          <source>In this example our input lines have the format company name, web address and country. Unfortunately the regexp is rather long and not very versatile -- the code will break if we add any more fields. A simpler and better solution is to look for the separator, '\t' in this case, and take the surrounding text. The &lt;a href=&quot;qstring#split&quot;&gt;QString::split&lt;/a&gt;() function can take a separator string or regexp as an argument and split a string accordingly.</source>
          <target state="translated">在此示例中，我们的输入行的格式为公司名称，网址和国家/地区。不幸的是，正则表达式很长，而且用途不多-如果我们添加更多字段，代码就会中断。一个更简单，更好的解决方案是查找分隔符&amp;ldquo; \ t&amp;rdquo;，并获取周围的文本。所述&lt;a href=&quot;qstring#split&quot;&gt;的QString ::分裂&lt;/a&gt;（）函数可以取一个分隔符字符串或正则表达式作为参数，并相应的分割的字符串。</target>
        </trans-unit>
        <trans-unit id="c68e45ce12232cea0e4433fbb4169154abeebb9d" translate="yes" xml:space="preserve">
          <source>In this example the shortcut is</source>
          <target state="translated">在这个例子中,快捷方式是</target>
        </trans-unit>
        <trans-unit id="fac57de8cb8e27d59e842bd29d3ab7f5e8c83dc4" translate="yes" xml:space="preserve">
          <source>In this example we are demonstrating how to use a &lt;a href=&quot;qml-qtqml-models-listmodel&quot;&gt;ListModel&lt;/a&gt; with a combo box.</source>
          <target state="translated">在此示例中，我们演示了如何将&lt;a href=&quot;qml-qtqml-models-listmodel&quot;&gt;ListModel&lt;/a&gt;与组合框一起使用。</target>
        </trans-unit>
        <trans-unit id="93132fdab803388ac80aa961ecde776ae47e6982" translate="yes" xml:space="preserve">
          <source>In this example we are demonstrating how to use a ListModel with a combo box.</source>
          <target state="translated">在这个例子中,我们将演示如何使用带有组合框的ListModel。</target>
        </trans-unit>
        <trans-unit id="1189e66d8d1010b7362db4792af15820adbb91c5" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;anim1&lt;/code&gt; and &lt;code&gt;anim2&lt;/code&gt; are two &lt;a href=&quot;qpropertyanimation&quot;&gt;QPropertyAnimation&lt;/a&gt;s that have already been set up.</source>
          <target state="translated">在此示例中， &lt;code&gt;anim1&lt;/code&gt; 和 &lt;code&gt;anim2&lt;/code&gt; 是已经设置的两个&lt;a href=&quot;qpropertyanimation&quot;&gt;QPropertyAnimation&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0e76e3fd9da832a8ce5a7866306c4863e5056d1a" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;anim1&lt;/code&gt; and &lt;code&gt;anim2&lt;/code&gt; are two already set up &lt;a href=&quot;qpropertyanimation&quot;&gt;QPropertyAnimation&lt;/a&gt;s.</source>
          <target state="translated">在此示例中， &lt;code&gt;anim1&lt;/code&gt; 和 &lt;code&gt;anim2&lt;/code&gt; 是两个已经设置的&lt;a href=&quot;qpropertyanimation&quot;&gt;QPropertyAnimation&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b19490627b2544a644d6217034dd7faaa7ea324c" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;p1&lt;/code&gt; and &lt;code&gt;p2&lt;/code&gt; share data until &lt;a href=&quot;qpainter#begin&quot;&gt;QPainter::begin&lt;/a&gt;() is called for &lt;code&gt;p2&lt;/code&gt;, because painting a pixmap will modify it.</source>
          <target state="translated">在此示例中， &lt;code&gt;p1&lt;/code&gt; 和 &lt;code&gt;p2&lt;/code&gt; 共享数据，直到为 &lt;code&gt;p2&lt;/code&gt; 调用&lt;a href=&quot;qpainter#begin&quot;&gt;QPainter :: begin&lt;/a&gt;（）为止，因为绘制像素图会对其进行修改。</target>
        </trans-unit>
        <trans-unit id="d3e9a0c073a6c98292de8fb5126a0361b67561b0" translate="yes" xml:space="preserve">
          <source>In this example, a predefined gradient is set up differently depending on the orientation of the handle. &lt;a href=&quot;qsplitterhandle&quot;&gt;QSplitterHandle&lt;/a&gt; provides a reasonable size hint for the handle, so the subclass does not need to provide a reimplementation of &lt;a href=&quot;qsplitterhandle#sizeHint&quot;&gt;sizeHint&lt;/a&gt;() unless the handle has special size requirements.</source>
          <target state="translated">在此示例中，根据手柄的方向不同地设置了预定义的渐变。&lt;a href=&quot;qsplitterhandle&quot;&gt;QSplitterHandle&lt;/a&gt;为句柄提供了合理的大小提示，因此，除非句柄有特殊的大小要求，&lt;a href=&quot;qsplitterhandle#sizeHint&quot;&gt;否则&lt;/a&gt;子类不需要提供对sizeHint（）的重新实现。</target>
        </trans-unit>
        <trans-unit id="6f9d1c6da4b4119b87b9a6d3aca87056d4d65ca7" translate="yes" xml:space="preserve">
          <source>In this example, a predefined gradient is set up differently depending on the orientation of the handle. QSplitterHandle provides a reasonable size hint for the handle, so the subclass does not need to provide a reimplementation of &lt;a href=&quot;qsplitterhandle#sizeHint&quot;&gt;sizeHint&lt;/a&gt;() unless the handle has special size requirements.</source>
          <target state="translated">在此示例中，根据手柄的方向不同地设置了预定义的渐变。QSplitterHandle为句柄提供了合理的大小提示，因此，除非句柄有特殊的大小要求，&lt;a href=&quot;qsplitterhandle#sizeHint&quot;&gt;否则&lt;/a&gt;子类不需要提供对sizeHint（）的重新实现。</target>
        </trans-unit>
        <trans-unit id="999da1ad9787398f1d2e84ddb26854e2f75d0230" translate="yes" xml:space="preserve">
          <source>In this example, both the &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; and the &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; functions may produce a different number of reads/writes. This can confuse the Qt D-Bus type system and should be avoided.</source>
          <target state="translated">在此示例中， &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; 和 &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; 函数都可能产生不同数量的读取/写入。这可能会使Qt D-Bus类型的系统感到困惑，应避免使用。</target>
        </trans-unit>
        <trans-unit id="0b4c78e1bc50276fe63e7f90612ec2b4d6685ef7" translate="yes" xml:space="preserve">
          <source>In this example, if the user clicks OK the font they chose will be used, and if they click Cancel the original font is used.</source>
          <target state="translated">在这个例子中,如果用户点击 &quot;确定&quot;,就会使用他们选择的字体,如果他们点击 &quot;取消&quot;,就会使用原来的字体。</target>
        </trans-unit>
        <trans-unit id="2fcaccfcc775dc4e2a1aed36721366878fcca6b8" translate="yes" xml:space="preserve">
          <source>In this example, keyboard focus is transferred to the label's buddy (the &lt;a href=&quot;qlineedit&quot;&gt;QLineEdit&lt;/a&gt;) when the user presses Alt+P. If the buddy was a button (inheriting from &lt;a href=&quot;qabstractbutton&quot;&gt;QAbstractButton&lt;/a&gt;), triggering the mnemonic would emulate a button click.</source>
          <target state="translated">在此示例中，当用户按下Alt + P时，键盘焦点转移到了标签的好友（&lt;a href=&quot;qlineedit&quot;&gt;QLineEdit&lt;/a&gt;）上。如果伙伴是一个按钮（从&lt;a href=&quot;qabstractbutton&quot;&gt;QAbstractButton&lt;/a&gt;继承），则触发助记符将模拟按钮单击。</target>
        </trans-unit>
        <trans-unit id="2faf272681546fd3a889eb564ab412eac1cc354d" translate="yes" xml:space="preserve">
          <source>In this example, keyboard focus is transferred to the label's buddy (the &lt;a href=&quot;qlineedit&quot;&gt;QLineEdit&lt;/a&gt;) when the user presses Alt+P. If the buddy was a button (inheriting from &lt;a href=&quot;widgets-changes-qt6#qabstractbutton&quot;&gt;QAbstractButton&lt;/a&gt;), triggering the mnemonic would emulate a button click.</source>
          <target state="translated">在此示例中，当用户按下Alt + P时，键盘焦点转移到了标签的好友（&lt;a href=&quot;qlineedit&quot;&gt;QLineEdit&lt;/a&gt;）上。如果伙伴是一个按钮（继承自&lt;a href=&quot;widgets-changes-qt6#qabstractbutton&quot;&gt;QAbstractButton&lt;/a&gt;），则触发助记符将模拟按钮单击。</target>
        </trans-unit>
        <trans-unit id="d15b59b3fdb51e89ff35ae53f4be8eb8fedcf2ef" translate="yes" xml:space="preserve">
          <source>In this example, main.qml will normally use Component.qml for the Component type. However on a unix platform, the unix selector will be present and the +unix/Component.qml version will be used instead. Note that this acts like swapping out Component.qml with +unix/Component.qml, so when using Component.qml you should not need to alter any paths based on which version was selected.</source>
          <target state="translated">在这个例子中,main.qml通常会使用Component.qml作为Component类型。然而在unix平台上,unix选择器将会出现,而+unix/Component.qml版本将会被使用。请注意,这就像用+unix/Component.qml替换Component.qml一样,所以当使用Component.qml时,您不应该需要根据选择的版本来改变任何路径。</target>
        </trans-unit>
        <trans-unit id="3ff9fb3748987a1b472588cbf21d795b62d10160" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;MyWidget&lt;/code&gt; constructor relays a signal from a private member variable, and makes it available under a name that relates to &lt;code&gt;MyWidget&lt;/code&gt;.</source>
          <target state="translated">在此示例中， &lt;code&gt;MyWidget&lt;/code&gt; 构造函数中继来自私有成员变量的信号，并使其在与 &lt;code&gt;MyWidget&lt;/code&gt; 相关的名称下可用。</target>
        </trans-unit>
        <trans-unit id="1e3649d3f75d265bca2550faf5b7d5abd9dda84e" translate="yes" xml:space="preserve">
          <source>In this example, the dock widget can only be placed in the left and right dock areas, and it is initially placed in the left dock area.</source>
          <target state="translated">在这个例子中,dock小部件只能放置在左、右dock区域,而且它最初是放置在左dock区域。</target>
        </trans-unit>
        <trans-unit id="0b72b94b4757c02a73386ac2ac7762e13e401756" translate="yes" xml:space="preserve">
          <source>In this example, the lambda function made the connection simple even though &lt;a href=&quot;qabstractbutton#clicked&quot;&gt;QPushButton::clicked&lt;/a&gt;() and &lt;code&gt;TextSender::textCompleted()&lt;/code&gt; have incompatible parameters. In contrast, a string-based implementation would require extra boilerplate code.</source>
          <target state="translated">在此示例中，即使&lt;a href=&quot;qabstractbutton#clicked&quot;&gt;QPushButton :: clicked&lt;/a&gt;（）和 &lt;code&gt;TextSender::textCompleted()&lt;/code&gt; 具有不兼容的参数，lambda函数也使连接变得简单。相反，基于字符串的实现将需要额外的样板代码。</target>
        </trans-unit>
        <trans-unit id="235379df72b319b5f0ef8b2f33686cc77de424dc" translate="yes" xml:space="preserve">
          <source>In this example, the page entitled &quot;Qt Creator Manual&quot; contains a nested list of links to pages in the documentation which is duplicated in Qt Assistant's Contents tab.</source>
          <target state="translated">在这个例子中,标题为 &quot;Qt Creator Manual &quot;的页面包含了一个嵌套的文档页面链接列表,该列表在Qt Assistant的内容选项卡中是重复的。</target>
        </trans-unit>
        <trans-unit id="2da94753c669c0b214155883e8a88e777ac9bf77" translate="yes" xml:space="preserve">
          <source>In this example, the shortcut is</source>
          <target state="translated">在这个例子中,快捷方式是</target>
        </trans-unit>
        <trans-unit id="d3564d070713315e9b062415b2c5d0a34613c1ad" translate="yes" xml:space="preserve">
          <source>In this example, the source object is a simple binary switch that will toggle its state based on a timer. When the state changes, a signal is emitted by the source which QtRO propagates to all replicas. As the replica will have the same properties, signals and slots as were exposed from the source object, any slots connected to the replica's signal will be called when the replica receives the signal. The client process then echoes back the received switch state to the source by emitting its own signal which is connected to a slot on the replica.</source>
          <target state="translated">在这个例子中,源对象是一个简单的二进制开关,它将根据定时器来切换其状态。当状态改变时,源对象会发出一个信号,QtRO会将这个信号传播给所有的副本。由于复制体将拥有与从源对象中暴露出来的相同的属性、信号和插槽,当复制体接收到信号时,连接到复制体信号的任何插槽都将被调用。然后,客户端进程通过发射自己的信号将接收到的开关状态回传给源,而这个信号是连接到复制体上的槽。</target>
        </trans-unit>
        <trans-unit id="e36ccd2f1c46f5ff63faa5283e47c4297e4baad8" translate="yes" xml:space="preserve">
          <source>In this example, the timer is started by a call to &lt;a href=&quot;qelapsedtimer#start&quot;&gt;start&lt;/a&gt;() and the elapsed time is calculated by the &lt;a href=&quot;qelapsedtimer#elapsed&quot;&gt;elapsed&lt;/a&gt;() function.</source>
          <target state="translated">在此示例中，计时器通过调用&lt;a href=&quot;qelapsedtimer#start&quot;&gt;start&lt;/a&gt;（）来启动，而经过的时间是通过&lt;a href=&quot;qelapsedtimer#elapsed&quot;&gt;lapsed&lt;/a&gt;（）函数来计算的。</target>
        </trans-unit>
        <trans-unit id="a27ca901639e7c105df3fd5c77af46728ef15bc6" translate="yes" xml:space="preserve">
          <source>In this example, the timer is started by a call to &lt;a href=&quot;qelapsedtimer#start&quot;&gt;start&lt;/a&gt;() and the elapsed timer is calculated by the &lt;a href=&quot;qelapsedtimer#elapsed&quot;&gt;elapsed&lt;/a&gt;() function.</source>
          <target state="translated">在此示例中，计时器通过调用&lt;a href=&quot;qelapsedtimer#start&quot;&gt;start&lt;/a&gt;（）来启动，而经过的计时器则由&lt;a href=&quot;qelapsedtimer#elapsed&quot;&gt;lapsed&lt;/a&gt;（）函数计算。</target>
        </trans-unit>
        <trans-unit id="04368f892c2f39db24b113e7bf2d0296b1a1de0b" translate="yes" xml:space="preserve">
          <source>In this example, the toolbar is restricted to the top and bottom toolbar areas of the main window, and is initially placed in the top tool bar area. We can see that the actions specified by &lt;code&gt;newAct&lt;/code&gt; and &lt;code&gt;openAct&lt;/code&gt; will be displayed both on the toolbar and in the file menu.</source>
          <target state="translated">在此示例中，工具栏仅限于主窗口的顶部和底部工具栏区域，并且最初放置在顶部工具栏区域中。我们可以看到 &lt;code&gt;newAct&lt;/code&gt; 和 &lt;code&gt;openAct&lt;/code&gt; 指定的动作将同时显示在工具栏和文件菜单中。</target>
        </trans-unit>
        <trans-unit id="7630fea80062eea7b38dbc08e557a2c772f26d23" translate="yes" xml:space="preserve">
          <source>In this example, there will be some level of data loss because the &lt;code&gt;%FF&lt;/code&gt; cannot be converted.</source>
          <target state="translated">在此示例中，由于 &lt;code&gt;%FF&lt;/code&gt; 无法转换，因此会有一定程度的数据丢失。</target>
        </trans-unit>
        <trans-unit id="f801de70955d3907c634e712bc385370e892b307" translate="yes" xml:space="preserve">
          <source>In this example, we implement the shader effect manually. The &lt;a href=&quot;qtgraphicaleffects-index&quot;&gt;Qt Graphical Effects&lt;/a&gt; module contains a suite of ready-made effects for use with Qt Quick.</source>
          <target state="translated">在此示例中，我们手动实现了着色器效果。在&lt;a href=&quot;qtgraphicaleffects-index&quot;&gt;Qt的图形特效&lt;/a&gt;模块包含一套与Qt Quick的使用现成的效果。</target>
        </trans-unit>
        <trans-unit id="949cde144af3ddb388161b46bf77b0212b49247e" translate="yes" xml:space="preserve">
          <source>In this example, we know that the editor widget is a spin box, but we could have provided different editors for different types of data in the model, in which case we would need to cast the widget to the appropriate type before accessing its member functions.</source>
          <target state="translated">在这个例子中,我们知道编辑器widget是一个旋转框,但我们可以为模型中不同类型的数据提供不同的编辑器,在这种情况下,我们需要在访问它的成员函数之前将widget投向适当的类型。</target>
        </trans-unit>
        <trans-unit id="302e8cd2260bab3b6df359498303c437334ae297" translate="yes" xml:space="preserve">
          <source>In this example, when &lt;code&gt;button&lt;/code&gt; is clicked, the machine will enter &lt;code&gt;s2&lt;/code&gt;. It will remain in state &lt;code&gt;s2&lt;/code&gt; until the &lt;code&gt;geometry&lt;/code&gt; property has been set to &lt;code&gt;QRect(0, 0, 50, 50)&lt;/code&gt;. Then it will transition into &lt;code&gt;s3&lt;/code&gt;. When &lt;code&gt;s3&lt;/code&gt; is entered, the message box will pop up. If the transition into &lt;code&gt;s2&lt;/code&gt; has an animation for the &lt;code&gt;geometry&lt;/code&gt; property, then the machine will stay in &lt;code&gt;s2&lt;/code&gt; until the animation has finished playing. If there is no such animation, it will simply set the property and immediately enter state &lt;code&gt;s3&lt;/code&gt;.</source>
          <target state="translated">在此示例中，当单击 &lt;code&gt;button&lt;/code&gt; 时，机器将输入 &lt;code&gt;s2&lt;/code&gt; 。它将保持状态 &lt;code&gt;s2&lt;/code&gt; ,直到 &lt;code&gt;geometry&lt;/code&gt; 属性设置为 &lt;code&gt;QRect(0, 0, 50, 50)&lt;/code&gt; 为止。然后它将转换为 &lt;code&gt;s3&lt;/code&gt; 。当 &lt;code&gt;s3&lt;/code&gt; 输入，消息框弹出。如果向 &lt;code&gt;s2&lt;/code&gt; 的过渡中有一个 &lt;code&gt;geometry&lt;/code&gt; 属性的动画，则机器将停留在 &lt;code&gt;s2&lt;/code&gt; 中,直到动画播放完毕。如果没有这样的动画，它将简单地设置属性并立即进入状态 &lt;code&gt;s3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1688a407b207637b41abe1be9043ecb899dfd3d6" translate="yes" xml:space="preserve">
          <source>In this example, when the table view needs to provide an editor, it asks the delegate to provide an editor widget that is appropriate for the item being modified. The &lt;a href=&quot;qabstractitemdelegate#createEditor&quot;&gt;createEditor()&lt;/a&gt; function is supplied with everything that the delegate needs to be able to set up a suitable widget:</source>
          <target state="translated">在此示例中，当表视图需要提供编辑器时，它要求委托人提供适合于要修改的项目的编辑器小部件。所述&lt;a href=&quot;qabstractitemdelegate#createEditor&quot;&gt;createEditor（）&lt;/a&gt;函数与一切供给该委托需要能够设置一个合适的插件：</target>
        </trans-unit>
        <trans-unit id="6b4b45f883cad08400fe2f283e3df0277bface4f" translate="yes" xml:space="preserve">
          <source>In this image the black dot is positioned at (0,0) within the item coordinates of the red rectangle. If the red rectangle was the root item of the scene, then the black dot would also be positioned at (0,0) in scene coordinates.</source>
          <target state="translated">在这幅图中,黑点被定位在红色矩形的项目坐标中的(0,0)处,如果红色矩形是场景的根项目,那么黑点也会被定位在场景坐标的(0,0)处。如果红色矩形是场景的根项,那么黑点也会被定位在场景坐标的(0,0)处。</target>
        </trans-unit>
        <trans-unit id="efb41aa226d00b5cd9c17115bdf160b8d8cefd1f" translate="yes" xml:space="preserve">
          <source>In this instance, to avoid this issue, the view could set the property using a &lt;a href=&quot;qml-qtquick-propertyaction&quot;&gt;PropertyAction&lt;/a&gt; instead:</source>
          <target state="translated">在这种情况下，为避免出现此问题，视图可以改用&lt;a href=&quot;qml-qtquick-propertyaction&quot;&gt;PropertyAction&lt;/a&gt;设置属性：</target>
        </trans-unit>
        <trans-unit id="1c79f673d02c6a0b02afffb6a4413bac50fd2c46" translate="yes" xml:space="preserve">
          <source>In this mode the gradient coordinates are relative to the bounding rectangle of the object being drawn, with (0,0) in the top left corner, and (1,1) in the bottom right corner of the object's bounding rectangle. This value was added in Qt 5.12.</source>
          <target state="translated">在这种模式下,梯度坐标是相对于被绘制对象的边界矩形而言的,(0,0)在对象的左上角,(1,1)在对象边界矩形的右下角。这个值是在Qt 5.12中增加的。</target>
        </trans-unit>
        <trans-unit id="4bac153adc4b9fa8e68ca852dc8eface50bf9220" translate="yes" xml:space="preserve">
          <source>In this mode the gradient coordinates are relative to the bounding rectangle of the paint device, with (0,0) in the top left corner, and (1,1) in the bottom right corner of the paint device.</source>
          <target state="translated">在这种模式下,渐变坐标是相对于涂装设备的边界矩形,(0,0)在左上角,(1,1)在涂装设备的右下角。</target>
        </trans-unit>
        <trans-unit id="f99379591ca05eb12bd4a6f61185a599485cd60c" translate="yes" xml:space="preserve">
          <source>In this mode the tool button displays a special arrow to indicate that a menu is present. The menu is displayed when the arrow part of the button is pressed.</source>
          <target state="translated">在这种模式下,工具按钮会显示一个特殊的箭头,表示有菜单存在。当按下按钮的箭头部分时,就会显示菜单。</target>
        </trans-unit>
        <trans-unit id="a5a4b03e05731f32b56648a426c9e32b56ddc0e9" translate="yes" xml:space="preserve">
          <source>In this mode, a thread can lock the same &lt;a href=&quot;qreadwritelock&quot;&gt;QReadWriteLock&lt;/a&gt; multiple times. The &lt;a href=&quot;qreadwritelock&quot;&gt;QReadWriteLock&lt;/a&gt; won't be unlocked until a corresponding number of &lt;a href=&quot;qreadwritelock#unlock&quot;&gt;unlock&lt;/a&gt;() calls have been made.</source>
          <target state="translated">在此模式下，线程可以多次锁定同一&lt;a href=&quot;qreadwritelock&quot;&gt;QReadWriteLock&lt;/a&gt;。该&lt;a href=&quot;qreadwritelock&quot;&gt;QReadWriteLock&lt;/a&gt;不会被解锁，直到相应数量的&lt;a href=&quot;qreadwritelock#unlock&quot;&gt;解锁&lt;/a&gt;（）调用已经作出。</target>
        </trans-unit>
        <trans-unit id="cf8071f22e099a59fd4dd42f20046f8ac50f765e" translate="yes" xml:space="preserve">
          <source>In this mode, a thread can lock the same mutex multiple times and the mutex won't be unlocked until a corresponding number of &lt;a href=&quot;qmutex#unlock&quot;&gt;unlock&lt;/a&gt;() calls have been made.</source>
          <target state="translated">在这种模式下，线程可以多次锁定同一个互斥锁，并且只有在进行了相应数量的&lt;a href=&quot;qmutex#unlock&quot;&gt;unlock&lt;/a&gt;（）调用后，互斥锁才会被解锁。</target>
        </trans-unit>
        <trans-unit id="88d0a5220bdccf1681c678bb134055ed3908fc94" translate="yes" xml:space="preserve">
          <source>In this mode, a thread can lock the same mutex multiple times and the mutex won't be unlocked until a corresponding number of &lt;a href=&quot;qmutex#unlock&quot;&gt;unlock&lt;/a&gt;() calls have been made. You should use &lt;a href=&quot;qrecursivemutex&quot;&gt;QRecursiveMutex&lt;/a&gt; for this use-case.</source>
          <target state="translated">在这种模式下，一个线程可以多次锁定同一个互斥锁，并且只有在进行了相应数量的&lt;a href=&quot;qmutex#unlock&quot;&gt;unlock&lt;/a&gt;（）调用后，该互斥锁才会被解锁。您应该在此用例中使用&lt;a href=&quot;qrecursivemutex&quot;&gt;QRecursiveMutex&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="39fcfd26a81ee3c453c79d5569011ba1a79f42c0" translate="yes" xml:space="preserve">
          <source>In this mode, a thread may only lock a &lt;a href=&quot;qreadwritelock&quot;&gt;QReadWriteLock&lt;/a&gt; once.</source>
          <target state="translated">在这种模式下，一个线程只能锁定一次&lt;a href=&quot;qreadwritelock&quot;&gt;QReadWriteLock&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5f6efbbcec8516b4d059c7b41ece0e309e734609" translate="yes" xml:space="preserve">
          <source>In this mode, a thread may only lock a mutex once.</source>
          <target state="translated">在这种模式下,一个线程只能锁定一个mutex一次。</target>
        </trans-unit>
        <trans-unit id="51c4b84006f4a9a6f5eaba5872cb21631d3572f7" translate="yes" xml:space="preserve">
          <source>In this mode, the &lt;code&gt;files&lt;/code&gt; argument can be a list of files or directories. If a directory is specified, it will be included in the &lt;a href=&quot;qmake-variable-reference#dependpath&quot;&gt;DEPENDPATH&lt;/a&gt; variable, and relevant code from there will be included in the generated project file. If a file is given, it will be appended to the correct variable, depending on its extension. For example, UI files are added to &lt;a href=&quot;qmake-variable-reference#forms&quot;&gt;FORMS&lt;/a&gt;, and C++ files are added to &lt;a href=&quot;qmake-variable-reference#sources&quot;&gt;SOURCES&lt;/a&gt;.</source>
          <target state="translated">在这种模式下， &lt;code&gt;files&lt;/code&gt; 参数可以是文件或目录的列表。如果指定了目录，则该目录将包含在&lt;a href=&quot;qmake-variable-reference#dependpath&quot;&gt;DEPENDPATH&lt;/a&gt;变量中，并且该目录中的相关代码将包含在生成的项目文件中。如果给出了文件，则将根据其扩展名将其附加到正确的变量中。例如，将UI文件添加到&lt;a href=&quot;qmake-variable-reference#forms&quot;&gt;FORMS&lt;/a&gt;，将C ++文件添加到&lt;a href=&quot;qmake-variable-reference#sources&quot;&gt;SOURCES&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b5ea371b73c38c196b0320941a7a5faa4ff5dcbe" translate="yes" xml:space="preserve">
          <source>In this model, the item in the string list that corresponds to the model index is replaced by the value provided. However, before we can modify the string list, we must make sure that the index is valid, the item is of the correct type, and that the role is supported. By convention, we insist that the role is the &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;EditRole&lt;/a&gt; since this is the role used by the standard item delegate. For boolean values, however, you can use &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;Qt::CheckStateRole&lt;/a&gt; and set the &lt;a href=&quot;qt#ItemFlag-enum&quot;&gt;Qt::ItemIsUserCheckable&lt;/a&gt; flag; a checkbox is then used for editing the value. The underlying data in this model is the same for all roles, so this detail just makes it easier to integrate the model with standard components.</source>
          <target state="translated">在此模型中，字符串列表中与模型索引对应的项目将替换为所提供的值。但是，在修改字符串列表之前，我们必须确保索引有效，项目的类型正确并且支持该角色。按照惯例，我们坚持认为角色是&lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;EditRole，&lt;/a&gt;因为这是标准项目委托使用的角色。但是，对于布尔值，可以使用&lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;Qt :: CheckStateRole&lt;/a&gt;并设置&lt;a href=&quot;qt#ItemFlag-enum&quot;&gt;Qt :: ItemIsUserCheckable&lt;/a&gt;标志；然后将使用一个复选框来编辑值。对于所有角色，该模型中的基础数据都是相同的，因此，此详细信息仅使该模型与标准组件的集成更加容易。</target>
        </trans-unit>
        <trans-unit id="7c4ae048ff841aa06e0864405ffed2086e736baf" translate="yes" xml:space="preserve">
          <source>In this path expression, both &lt;code&gt;recipe&lt;/code&gt; and &lt;code&gt;title&lt;/code&gt; are name tests written in the shorthand form. &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; resolves these names (&lt;a href=&quot;http://www.w3.org/TR/xquery/#id-basics&quot;&gt;QNames&lt;/a&gt;) to their expanded form using whatever &lt;a href=&quot;http://www.w3.org/TR/xquery/#dt-namespace-declaration&quot;&gt;namespace declarations&lt;/a&gt; it knows about. Resolving a name to its expanded form means replacing its namespace prefix, if one is present (there aren't any present in the example), with a namespace URI. The expanded name then consists of the namespace URI and the local name.</source>
          <target state="translated">在此路径表达式中， &lt;code&gt;recipe&lt;/code&gt; 和 &lt;code&gt;title&lt;/code&gt; 都是以简写形式编写的名称测试。&lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt;使用它知道的任何&lt;a href=&quot;http://www.w3.org/TR/xquery/#dt-namespace-declaration&quot;&gt;名称空间声明&lt;/a&gt;，将这些名称（&lt;a href=&quot;http://www.w3.org/TR/xquery/#id-basics&quot;&gt;QNames&lt;/a&gt;）解析为其扩展形式。将名称解析为其扩展形式意味着用名称空间URI替换其名称空间前缀（如果存在）（示例中不存在）。然后，扩展名称由名称空间URI和本地名称组成。</target>
        </trans-unit>
        <trans-unit id="5605cad4c620ef3a8507b3d76f04febe9af7a320" translate="yes" xml:space="preserve">
          <source>In this path expression, both &lt;code&gt;recipe&lt;/code&gt; and &lt;code&gt;title&lt;/code&gt; are name tests written in the shorthand form. &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; resolves these names (&lt;a href=&quot;http://www.w3.org/TR/xquery/#id-basics&quot;&gt;QNames&lt;/a&gt;) to their expanded form using whatever &lt;a href=&quot;http://www.w3.org/TR/xquery/#dt-namespace-declaration&quot;&gt;namespace declarations&lt;/a&gt; it knows about. Resolving a name to its expanded form means replacing its namespace prefix, if one is present (there aren't any present in the example), with a namespace URI. The expanded name then consists of the namespace URI and the local name.</source>
          <target state="translated">在此路径表达式中， &lt;code&gt;recipe&lt;/code&gt; 和 &lt;code&gt;title&lt;/code&gt; 都是以简写形式编写的名称测试。&lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt;使用其知道的任何&lt;a href=&quot;http://www.w3.org/TR/xquery/#dt-namespace-declaration&quot;&gt;名称空间声明&lt;/a&gt;将这些名称（&lt;a href=&quot;http://www.w3.org/TR/xquery/#id-basics&quot;&gt;QNames&lt;/a&gt;）解析为其扩展形式。将名称解析为扩展形式意味着用名称空间URI替换其名称空间前缀（如果存在）（示例中不存在）。然后，扩展名称由名称空间URI和本地名称组成。</target>
        </trans-unit>
        <trans-unit id="234eaf6971e188df3c64ddb37bfe43b7d37738d9" translate="yes" xml:space="preserve">
          <source>In this section we will explain the procedure of implementing accessible plugins for your interfaces. A plugin is a class stored in a shared library that can be loaded at run-time. It is convenient to distribute interfaces as plugins since they will only be loaded when required.</source>
          <target state="translated">在本节中,我们将解释为您的接口实现可访问插件的过程。插件是一个存储在共享库中的类,可以在运行时加载。将接口作为插件发布是很方便的,因为只有在需要的时候才会加载它们。</target>
        </trans-unit>
        <trans-unit id="54d3ed97e636aea202d0e7406445c6021f10ea06" translate="yes" xml:space="preserve">
          <source>In this section we will have a look at some implementation issues. Finally, we will see a complete example on the styling of a Java widget. We will continue to use the Java style throughout the document for examples and widget images. The implementation itself is somewhat involved, and it is not intended that you should read through it.</source>
          <target state="translated">在本节中,我们将看看一些实现问题。最后,我们将看到一个完整的Java小组件样式的例子。我们将在整个文档中继续使用Java风格的例子和小组件图像。实现本身有些涉及,不打算让你通读。</target>
        </trans-unit>
        <trans-unit id="c0df91c69d5811751122073dd073984a8a527e0b" translate="yes" xml:space="preserve">
          <source>In this section we will show the most basic way to use Qt in a CMake project. We will walk through an example project that is utilizing &lt;a href=&quot;qtwidgets-index&quot;&gt;Qt Widgets&lt;/a&gt;.</source>
          <target state="translated">在本节中，我们将展示在CMake项目中使用Qt的最基本方法。我们将逐步介绍一个利用&lt;a href=&quot;qtwidgets-index&quot;&gt;Qt Widgets&lt;/a&gt;的示例项目。</target>
        </trans-unit>
        <trans-unit id="3260e6a623886cc2b28bfaeb75b17b834e8dc4a2" translate="yes" xml:space="preserve">
          <source>In this section, we create a simple read-only model to explore the basic principles of the model/view architecture. Later in this section, we adapt this simple model so that items can be modified by the user.</source>
          <target state="translated">在本节中,我们创建了一个简单的只读模型来探索模型/视图架构的基本原理。在本节的后面,我们将对这个简单的模型进行调整,以便用户可以修改项目。</target>
        </trans-unit>
        <trans-unit id="10539b1f975fafffe2435b86b80bdefa49531feb" translate="yes" xml:space="preserve">
          <source>In this section, we implement a simple model based on a list of strings, so the &lt;a href=&quot;qabstractlistmodel&quot;&gt;QAbstractListModel&lt;/a&gt; provides an ideal base class on which to build.</source>
          <target state="translated">在本节中，我们基于字符串列表实现一个简单的模型，因此&lt;a href=&quot;qabstractlistmodel&quot;&gt;QAbstractListModel&lt;/a&gt;提供了一个理想的基础类来进行构建。</target>
        </trans-unit>
        <trans-unit id="91c09ec270f1ce6cb036dc00b51571c7578d1550" translate="yes" xml:space="preserve">
          <source>In this section, we will examine how most of Qt's widgets are styled. Hopefully, this will save you some time and effort while developing your own styles and widgets. You will not find information here that is not attainable elsewhere (i.e., by examining the source code or the class descriptions for the style related classes).</source>
          <target state="translated">在本节中,我们将研究大多数Qt的widget是如何进行样式设计的。希望这能为您在开发自己的样式和小组件时节省一些时间和精力。你不会在这里找到在其他地方找不到的信息(例如,通过检查源代码或风格相关类的类描述)。</target>
        </trans-unit>
        <trans-unit id="3f47cd1ace10fa43698bf499821a9365534b48c8" translate="yes" xml:space="preserve">
          <source>In this section, you will find an overview of creating and exporting 3D assets to use in Qt Quick 3D. For more detailed information, see the section for the &lt;a href=&quot;quick3d-asset-conditioning-3d-assets#exporting-from-different-tools&quot;&gt;specific 3D modeling tool&lt;/a&gt; that you are using.</source>
          <target state="translated">在本节中，您将概述创建和导出要在Qt Quick 3D中使用的3D资产。有关更多详细信息，请参阅所用&lt;a href=&quot;quick3d-asset-conditioning-3d-assets#exporting-from-different-tools&quot;&gt;特定3D建模工具&lt;/a&gt;的部分。</target>
        </trans-unit>
        <trans-unit id="f74dd0586be28685f37f6c5e141d9d8eeb1a83be" translate="yes" xml:space="preserve">
          <source>In this situation the application must determine which widget within the window should receive the focus.</source>
          <target state="translated">在这种情况下,应用程序必须确定窗口中的哪个小组件应该接收焦点。</target>
        </trans-unit>
        <trans-unit id="d65c68dcc986167cbb47bec6fde19614928981a0" translate="yes" xml:space="preserve">
          <source>In this situation we can either move the component inline,</source>
          <target state="translated">在这种情况下,我们可以将组件内联移动。</target>
        </trans-unit>
        <trans-unit id="f77e3a6148f95c824aff40abfaad81cae846b66c" translate="yes" xml:space="preserve">
          <source>In this state, the camera still consumes power.</source>
          <target state="translated">在这种状态下,相机仍然会消耗电力。</target>
        </trans-unit>
        <trans-unit id="2718cb561f3575be5202c9c3990958a6a9e9ed5f" translate="yes" xml:space="preserve">
          <source>In this topic we summarize those changes in &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtopengl-index.html&quot;&gt;Qt OpenGL&lt;/a&gt;, and provide guidance to handle them.</source>
          <target state="translated">在本主题中，我们总结了&lt;a href=&quot;https://doc.qt.io/qt-6.0/qtopengl-index.html&quot;&gt;Qt OpenGL中的&lt;/a&gt;那些更改，并提供了处理这些更改的指导。</target>
        </trans-unit>
        <trans-unit id="5eb9d0e213c819baab4ce6670b7bfe73be022ac7" translate="yes" xml:space="preserve">
          <source>In this topic we summarize those changes in Qt Concurrent, and provide guidance to handle them.</source>
          <target state="translated">在本专题中,我们总结了Qt Concurrent中的那些变化,并提供了处理它们的指导。</target>
        </trans-unit>
        <trans-unit id="f9f4f5f7451a8e3ec8b5aa07ea6c7bd8ea780721" translate="yes" xml:space="preserve">
          <source>In this topic we summarize those changes in Qt Core, and provide guidance to handle them.</source>
          <target state="translated">在本专题中,我们总结了Qt Core中的那些变化,并提供了处理它们的指导。</target>
        </trans-unit>
        <trans-unit id="eb19f8fcc9faeba40c08630b1bba709d72f1a3bb" translate="yes" xml:space="preserve">
          <source>In this topic we summarize those changes in Qt DBus, and provide guidance to handle them.</source>
          <target state="translated">在本专题中,我们总结了Qt DBus中的那些变化,并提供了处理它们的指导。</target>
        </trans-unit>
        <trans-unit id="100b2ba96dc763d2ad1f58d520efe73ac104c626" translate="yes" xml:space="preserve">
          <source>In this topic we summarize those changes in Qt GUI, and provide guidance to handle them.</source>
          <target state="translated">在本专题中,我们总结了Qt GUI的那些变化,并提供了处理这些变化的指导。</target>
        </trans-unit>
        <trans-unit id="bc3fddb02433fe15735f0a8664ed0a6dc58f6071" translate="yes" xml:space="preserve">
          <source>In this topic we summarize those changes in Qt Image Formats, and provide guidance to handle them.</source>
          <target state="translated">在本专题中,我们总结了Qt图像格式中的那些变化,并提供了处理它们的指导。</target>
        </trans-unit>
        <trans-unit id="87c953946218141d81a4447f805eee07b24e3124" translate="yes" xml:space="preserve">
          <source>In this topic we summarize those changes in Qt Network Authorization, and provide guidance to handle them.</source>
          <target state="translated">在本专题中,我们总结了Qt网络授权的那些变化,并提供处理指南。</target>
        </trans-unit>
        <trans-unit id="26b5e600fab8b4d92a045fa1346ee0a4bc41841f" translate="yes" xml:space="preserve">
          <source>In this topic we summarize those changes in Qt Network, and provide guidance to handle them.</source>
          <target state="translated">在本专题中,我们总结了Qt网络的那些变化,并提供了处理这些变化的指导。</target>
        </trans-unit>
        <trans-unit id="4be784b23bfa6346a4083dd1fd46feee299c7b41" translate="yes" xml:space="preserve">
          <source>In this topic we summarize those changes in Qt Print Support, and provide guidance to handle them.</source>
          <target state="translated">在本专题中,我们总结了Qt打印支持中的那些变化,并提供了处理它们的指导。</target>
        </trans-unit>
        <trans-unit id="6df80fdf5182cf3b0f303f0df67c2db66d183ff4" translate="yes" xml:space="preserve">
          <source>In this topic we summarize those changes in Qt Quick 3D, and provide guidance to handle them.</source>
          <target state="translated">在本专题中,我们总结了Qt Quick 3D中的那些变化,并提供了处理它们的指导。</target>
        </trans-unit>
        <trans-unit id="02f081ac81cbfc38fca17bc34074c16fee234829" translate="yes" xml:space="preserve">
          <source>In this topic we summarize those changes in Qt Quick Controls, and provide guidance to handle them.</source>
          <target state="translated">在本专题中,我们总结了Qt Quick Controls的那些变化,并提供了处理它们的指导。</target>
        </trans-unit>
        <trans-unit id="f26af38683012886efd02c1dd95acde79807096e" translate="yes" xml:space="preserve">
          <source>In this topic we summarize those changes in Qt Quick Labs Platform, and provide guidance to handle them.</source>
          <target state="translated">在本专题中,我们总结了Qt快速实验室平台的那些变化,并提供了处理指南。</target>
        </trans-unit>
        <trans-unit id="a998c1430627191b1895c9a8c7e37baa628a4b0d" translate="yes" xml:space="preserve">
          <source>In this topic we summarize those changes in Qt SQL, and provide guidance to handle them.</source>
          <target state="translated">在本专题中,我们总结了Qt SQL中的那些变化,并提供了处理它们的指导。</target>
        </trans-unit>
        <trans-unit id="383eb28fad6ed4a531d3f009b3a4f183da77d78f" translate="yes" xml:space="preserve">
          <source>In this topic we summarize those changes in Qt SVG, and provide guidance to handle them.</source>
          <target state="translated">在本专题中,我们总结了Qt SVG中的那些变化,并提供了处理它们的指导。</target>
        </trans-unit>
        <trans-unit id="a3c3b92c64f3c54e317198c9eed962778a820b6a" translate="yes" xml:space="preserve">
          <source>In this topic we summarize those changes in Qt Test, and provide guidance to handle them.</source>
          <target state="translated">在本专题中,我们总结了Qt Test中的那些变化,并提供了处理这些变化的指导。</target>
        </trans-unit>
        <trans-unit id="abff527d8e70f5f423797a26f1c4ccd038afe634" translate="yes" xml:space="preserve">
          <source>In this topic we summarize those changes in Qt Wayland Compositor, and provide guidance to handle them.</source>
          <target state="translated">在本专题中,我们总结了Qt Wayland Compositor的那些变化,并提供了处理它们的指导。</target>
        </trans-unit>
        <trans-unit id="df9d2385d3218d725f1085e2f131544c4ea48404" translate="yes" xml:space="preserve">
          <source>In this topic we summarize those changes in Qt Widgets, and provide guidance to handle them.</source>
          <target state="translated">在本专题中,我们总结了Qt Widgets的那些变化,并提供了处理这些变化的指导。</target>
        </trans-unit>
        <trans-unit id="fd64cbd4bf67765e0cf60800b8f345967a08ad61" translate="yes" xml:space="preserve">
          <source>In this topic we summarize those changes in Qt XML, and provide guidance to handle them.</source>
          <target state="translated">在本专题中,我们总结了Qt XML中的这些变化,并提供了处理它们的指导。</target>
        </trans-unit>
        <trans-unit id="8749c880d56a5412352f906c01a343927e4ae051" translate="yes" xml:space="preserve">
          <source>In this topic we summarize those changes in Qt3D, and provide guidance to handle them.</source>
          <target state="translated">在本专题中,我们总结了Qt3D中的这些变化,并提供了处理它们的指导。</target>
        </trans-unit>
        <trans-unit id="1062d235d1c4f3cc085f9aaebe56578fb475810f" translate="yes" xml:space="preserve">
          <source>In this type of device, the touch surface and display are integrated. This means the surface and display typically have the same size, such that there is a direct relationship between the touch points' physical positions and the coordinate reported by &lt;a href=&quot;qeventpoint&quot;&gt;QEventPoint&lt;/a&gt;. As a result, Qt allows the user to interact directly with multiple QWidgets, QGraphicsItems, or Qt Quick Items at the same time.</source>
          <target state="translated">在这种类型的设备中，触摸表面和显示器是集成的。这意味着表面和显示器通常具有相同的大小，从而在触摸点的物理位置和&lt;a href=&quot;qeventpoint&quot;&gt;QEventPoint&lt;/a&gt;报告的坐标之间存在直接关系。结果，Qt允许用户同时直接与多个QWidget，QGraphicsItems或Qt Quick Items进行交互。</target>
        </trans-unit>
        <trans-unit id="7f94475de620540cea71799bb6accd7b99465255" translate="yes" xml:space="preserve">
          <source>In this type of device, the touch surface and display are integrated. This means the surface and display typically have the same size, such that there is a direct relationship between the touch points' physical positions and the coordinate reported by &lt;a href=&quot;qtouchevent-touchpoint&quot;&gt;QTouchEvent::TouchPoint&lt;/a&gt;. As a result, Qt allows the user to interact directly with multiple QWidgets and QGraphicsItems at the same time.</source>
          <target state="translated">在这种类型的设备中，触摸表面和显示器是集成的。这意味着表面和显示器通常具有相同的大小，从而在触摸点的物理位置和&lt;a href=&quot;qtouchevent-touchpoint&quot;&gt;QTouchEvent :: TouchPoint&lt;/a&gt;报告的坐标之间存在直接关系。结果，Qt允许用户同时直接与多个QWidget和QGraphicsItems交互。</target>
        </trans-unit>
        <trans-unit id="6685aa01d1b3fcca52863e41b8119da93842cd0b" translate="yes" xml:space="preserve">
          <source>In this type of device, the touch surface is separate from the display. There is not a direct relationship between the physical touch location and the on-screen coordinates. Instead, they are calculated relative to the current mouse position, and the user must use the touch-pad to move this reference point. Unlike touch-screens, Qt allows users to only interact with a single &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; or &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; at a time.</source>
          <target state="translated">在这种类型的设备中，触摸表面与显示器分离。物理触摸位置和屏幕上的坐标之间没有直接关系。相反，它们是相对于当前鼠标位置计算的，用户必须使用触摸板移动该参考点。与触摸屏不同，Qt允许用户一次仅与单个&lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt;或&lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt;进行交互。</target>
        </trans-unit>
        <trans-unit id="66946372302723dbc39686181c362595a68f3f34" translate="yes" xml:space="preserve">
          <source>In this type of device, the touch surface is separate from the display. There is not a direct relationship between the physical touch location and the on-screen coordinates. Instead, they are calculated relative to the current mouse position, and the user must use the touch-pad to move this reference point. Unlike touch-screens, Qt allows users to only interact with a single &lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;QWidget&lt;/a&gt; or &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; at a time.</source>
          <target state="translated">在这种类型的设备中，触摸表面与显示器分离。物理触摸位置和屏幕坐标之间没有直接关系。相反，它们是相对于当前鼠标位置计算的，用户必须使用触摸板移动该参考点。与触摸屏不同，Qt允许用户一次仅与单个&lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;QWidget&lt;/a&gt;或&lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt;进行交互。</target>
        </trans-unit>
        <trans-unit id="2b2535faab60201dc65f2b10fa2b5ffba2ee808d" translate="yes" xml:space="preserve">
          <source>In this way an object declaration may &lt;a href=&quot;qtqml-typesystem-objecttypes#defining-object-types-from-qml&quot;&gt;expose a particular value&lt;/a&gt; to outside objects or maintain some internal state more easily.</source>
          <target state="translated">这样，对象声明可以&lt;a href=&quot;qtqml-typesystem-objecttypes#defining-object-types-from-qml&quot;&gt;将特定的值暴露&lt;/a&gt;给外部对象，或者更容易维护一些内部状态。</target>
        </trans-unit>
        <trans-unit id="9d883efb35cac06454a54d0337ddbcf3332cfbc9" translate="yes" xml:space="preserve">
          <source>In this way you can do a visual parenthesis matching and highlight from the current cursor position to the matching parenthesis. That makes it easier to spot a missing parenthesis in your code and to find where a corresponding opening/closing parenthesis is when editing parenthesis intensive code.</source>
          <target state="translated">通过这种方式,您可以进行可视化的小括号匹配,并从当前光标位置高亮显示到匹配的小括号。这样就可以更容易地发现代码中缺失的小括号,并在编辑小括号密集的代码时,找到对应的开/闭括号的位置。</target>
        </trans-unit>
        <trans-unit id="65952435f5dc1053c6d61dfc47bb7e6eeaf06f91" translate="yes" xml:space="preserve">
          <source>In this way, modular user interface types are assembled and reused within an application.</source>
          <target state="translated">通过这种方式,模块化的用户界面类型在一个应用程序中被组装和重用。</target>
        </trans-unit>
        <trans-unit id="3de767a5f61844da8fcb371c7514c56d9009cc74" translate="yes" xml:space="preserve">
          <source>In toolbars, the icon is used as the tool button icon; in menus, it is displayed to the left of the menu text. There is no default icon.</source>
          <target state="translated">在工具栏中,该图标作为工具按钮图标使用;在菜单中,它显示在菜单文本的左侧。没有默认的图标。</target>
        </trans-unit>
        <trans-unit id="e8558be4cbe55217d99da0c999c4bef98bb07c70" translate="yes" xml:space="preserve">
          <source>In total, there are four levels for sections in QDoc: &lt;code&gt;\section1&lt;/code&gt;, &lt;code&gt;\section2&lt;/code&gt;, &lt;code&gt;\section3&lt;/code&gt; and &lt;code&gt;\section4&lt;/code&gt;. These correspond to the traditional section, subsection, subsubsection and subsubsubsection.</source>
          <target state="translated">QDoc中的节总共有四个级别： &lt;code&gt;\section1&lt;/code&gt; ， &lt;code&gt;\section2&lt;/code&gt; ， &lt;code&gt;\section3&lt;/code&gt; 和 &lt;code&gt;\section4&lt;/code&gt; 。这些对应于传统的节，小节，小节和小节。</target>
        </trans-unit>
        <trans-unit id="4351286a425286096d471d342fe0417768836e7b" translate="yes" xml:space="preserve">
          <source>In traditional user interfaces, views can be scrolled using standard controls, such as scroll bars and arrow buttons. In some situations, it is also possible to drag the view directly by pressing and holding a mouse button while moving the cursor. In touch-based user interfaces, this dragging action is often complemented with a flicking action, where scrolling continues after the user has stopped touching the view.</source>
          <target state="translated">在传统的用户界面中,可以使用标准的控件,如滚动条和箭头按钮来滚动视图。在某些情况下,也可以在移动光标的同时按住鼠标按钮直接拖动视图。在基于触摸的用户界面中,这种拖动动作通常与轻触动作相辅相成,在用户停止触摸视图后,滚动继续进行。</target>
        </trans-unit>
        <trans-unit id="f258c69f22317c14e8206b56e29ba44e76398da4" translate="yes" xml:space="preserve">
          <source>In widget applications, certain widgets can use '&amp;amp;' in front of a character. This will automatically create a mnemonic (a shortcut) for that character, e.g. &quot;E&amp;amp;xit&quot; will create the shortcut &lt;b&gt;Alt+X&lt;/b&gt; (use '&amp;amp;&amp;amp;' to display an actual ampersand). The widget might consume and perform an action on a given shortcut. On X11 the ampersand will not be shown and the character will be underlined. On Windows, shortcuts are normally not displayed until the user presses the &lt;b&gt;Alt&lt;/b&gt; key, but this is a setting the user can change. On Mac, shortcuts are disabled by default. Call &lt;a href=&quot;qkeysequence#qt_set_sequence_auto_mnemonic&quot;&gt;qt_set_sequence_auto_mnemonic&lt;/a&gt;() to enable them. However, because mnemonic shortcuts do not fit in with Aqua's guidelines, Qt will not show the shortcut character underlined.</source>
          <target state="translated">在窗口小部件应用程序中，某些窗口小部件可以在字符前面使用&amp;ldquo;＆&amp;rdquo;。这将自动为该字符创建一个助记符（快捷方式），例如&amp;ldquo; E＆xit&amp;rdquo;将创建快捷键&lt;b&gt;Alt + X&lt;/b&gt;（使用&amp;ldquo; &amp;amp;&amp;amp;&amp;rdquo;显示实际的&amp;ldquo;＆&amp;rdquo;号）。该小部件可能会消耗并在给定的快捷方式上执行操作。在X11上，将不显示与号，并在字符下划线。在Windows上，通常不会显示快捷方式，除非用户按下&lt;b&gt;Alt&lt;/b&gt;键，但这是用户可以更改的设置。在Mac上，默认情况下禁用快捷方式。调用&lt;a href=&quot;qkeysequence#qt_set_sequence_auto_mnemonic&quot;&gt;qt_set_sequence_auto_mnemonic&lt;/a&gt;（）启用它们。但是，由于助记符快捷方式不符合Aqua的准则，因此Qt不会在带下划线的快捷方式字符上显示。</target>
        </trans-unit>
        <trans-unit id="6aaafeefcb43476d4c9477cdad1175f7b376a547" translate="yes" xml:space="preserve">
          <source>In widget-based applications, this property is not used, as it's only meaningful for a widget to accept or reject a complete &lt;a href=&quot;qinputevent&quot;&gt;QInputEvent&lt;/a&gt;.</source>
          <target state="translated">在基于窗口小部件的应用程序中，不使用此属性，因为对于窗口小部件而言，仅接受或拒绝完整的&lt;a href=&quot;qinputevent&quot;&gt;QInputEvent才有意义&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2b39c6b56a1a873cf646e6b3b27f95ed83f3439e" translate="yes" xml:space="preserve">
          <source>In your &lt;a href=&quot;qaxbindable&quot;&gt;QAxBindable&lt;/a&gt; subclass, implement &lt;a href=&quot;qaxbindable#createAggregate&quot;&gt;QAxBindable::createAggregate&lt;/a&gt;() to return a new object of the &lt;a href=&quot;qaxaggregated&quot;&gt;QAxAggregated&lt;/a&gt; subclass.</source>
          <target state="translated">在您的&lt;a href=&quot;qaxbindable&quot;&gt;QAxBindable&lt;/a&gt;子类中，实现&lt;a href=&quot;qaxbindable#createAggregate&quot;&gt;QAxBindable :: createAggregate&lt;/a&gt;（）以返回&lt;a href=&quot;qaxaggregated&quot;&gt;QAxAggregated&lt;/a&gt;子类的新对象。</target>
        </trans-unit>
        <trans-unit id="e08dc5194d05b6c6fcdb177b54541a9fe51a1537" translate="yes" xml:space="preserve">
          <source>In your &lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt; subclasses, override clone(), and declare the protected and default-implemented copy constructor and assignment operator like this:</source>
          <target state="translated">在您的&lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt;子类中，重写clone（），并声明受保护的和默认实现的复制构造函数和赋值运算符，如下所示：</target>
        </trans-unit>
        <trans-unit id="63d2d509606741256342c77c9b94f6727b2ddd39" translate="yes" xml:space="preserve">
          <source>In your &lt;a href=&quot;qexception&quot;&gt;QException&lt;/a&gt; subclass, reimplement clone() like this:</source>
          <target state="translated">在您的&lt;a href=&quot;qexception&quot;&gt;QException&lt;/a&gt;子类中，重新实现clone（），如下所示：</target>
        </trans-unit>
        <trans-unit id="dd2fcbeb7884806ac64f611bf2ba25de6cbb9514" translate="yes" xml:space="preserve">
          <source>In your &lt;a href=&quot;qexception&quot;&gt;QException&lt;/a&gt; subclass, reimplement raise() like this:</source>
          <target state="translated">在您的&lt;a href=&quot;qexception&quot;&gt;QException&lt;/a&gt;子类中，重新实现raise（），如下所示：</target>
        </trans-unit>
        <trans-unit id="1aad9d4262c115a217ea35af3bbe0130fb028821" translate="yes" xml:space="preserve">
          <source>In your configuration file, set your &lt;code&gt;outputformats&lt;/code&gt; variable to &lt;code&gt;DITAXML&lt;/code&gt;, and send the output to an appropriate directory:</source>
          <target state="translated">在配置文件中，将 &lt;code&gt;outputformats&lt;/code&gt; 变量设置为 &lt;code&gt;DITAXML&lt;/code&gt; ，然后将输出发送到适当的目录：</target>
        </trans-unit>
        <trans-unit id="391d4c696460971bd0866dd82b78c9f902720909" translate="yes" xml:space="preserve">
          <source>In your own code, please use only &lt;code&gt;QUtf8StringView&lt;/code&gt; and/or &lt;code&gt;q_no_char8_t::QUtf8StringView&lt;/code&gt;:</source>
          <target state="translated">在您自己的代码中，请仅使用 &lt;code&gt;QUtf8StringView&lt;/code&gt; 和/或 &lt;code&gt;q_no_char8_t::QUtf8StringView&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="769cfd06088af9845715bff54aafd9073099ac35" translate="yes" xml:space="preserve">
          <source>In your reimplementation of this function, if you want to filter the</source>
          <target state="translated">在你对这个函数的重新实现中,如果你想过滤一下</target>
        </trans-unit>
        <trans-unit id="427fe9e274e6f7646ab5f0deb14eec78dd36fab2" translate="yes" xml:space="preserve">
          <source>In your reimplementation of this function, if you want to stop the event being handled by Qt, return true and set</source>
          <target state="translated">在你对这个函数的重新实现中,如果你想停止Qt对事件的处理,返回true并设置</target>
        </trans-unit>
        <trans-unit id="f961645c55c0b98e856d14a71b4d7fe3ad5f3874" translate="yes" xml:space="preserve">
          <source>In-App Purchases</source>
          <target state="translated">应用内购买</target>
        </trans-unit>
        <trans-unit id="c5f3fec7bd65d1e33a7327f41ace571bdb281ccc" translate="yes" xml:space="preserve">
          <source>In-App Purchasing</source>
          <target state="translated">应用内购买</target>
        </trans-unit>
        <trans-unit id="229d515f509ad82bcd53f709b3ca353b175a13b4" translate="yes" xml:space="preserve">
          <source>In-App purchasing can only be tested on the actual hardware for the iOS platform. For more information refer to the &lt;a href=&quot;http://developer.apple.com/in-app-purchase/&quot;&gt;iOS documentation&lt;/a&gt;.</source>
          <target state="translated">应用内购买只能在iOS平台的实际硬件上进行测试。有关更多信息，请参阅&lt;a href=&quot;http://developer.apple.com/in-app-purchase/&quot;&gt;iOS文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="da7b66e1d584f7382180975b2990383747934177" translate="yes" xml:space="preserve">
          <source>In-App purchasing for &lt;a href=&quot;supported-platforms#winrt&quot;&gt;WinRT&lt;/a&gt; differentiates between two modes:</source>
          <target state="translated">&lt;a href=&quot;supported-platforms#winrt&quot;&gt;WinRT&lt;/a&gt;的应用内购买区分两种模式：</target>
        </trans-unit>
        <trans-unit id="faf1192558e81dd0caccc8ea7443a78efd2db6f6" translate="yes" xml:space="preserve">
          <source>In-App purchasing for WinRT differentiates between two modes:</source>
          <target state="translated">WinRT的应用内购买区分为两种模式。</target>
        </trans-unit>
        <trans-unit id="d61ae781ad501b98baf8c7fac2203050048064c6" translate="yes" xml:space="preserve">
          <source>In-Depth Memory Allocation Considerations</source>
          <target state="translated">深入的内存分配考虑</target>
        </trans-unit>
        <trans-unit id="b89bb5ff5c8429f56a85f36063f920a4d959b3e6" translate="yes" xml:space="preserve">
          <source>In-app billing service</source>
          <target state="translated">应用内计费服务</target>
        </trans-unit>
        <trans-unit id="957b8acbbcffca282d9fb4135026f4a00dec0dcd" translate="yes" xml:space="preserve">
          <source>In-app products will be available once you have published the application.</source>
          <target state="translated">应用内产品将在您发布应用后提供。</target>
        </trans-unit>
        <trans-unit id="0f27319b26f4231b0090f8ed768563c7d37495cb" translate="yes" xml:space="preserve">
          <source>In-app purchases are a way to monetize an application. These purchases are made from inside the application and can include anything from unlocking content to virtual items. The Qt Purchasing API is built on the system APIs for in-app purchases, which means the purchase process is more familiar to the user, and the information already stored by the platform (such as credit card information) can be used to simplify the purchase process.</source>
          <target state="translated">应用内购买是应用盈利的一种方式。这些购买是从应用内部进行的,可以包括从解锁内容到虚拟物品的任何东西。Qt Purchasing API是建立在应用内购买的系统API基础上的,这意味着用户对购买过程更加熟悉,平台已经存储的信息(如信用卡信息)可以用来简化购买过程。</target>
        </trans-unit>
        <trans-unit id="0d77760dfc42dc3720305af5dea4f411b55778eb" translate="yes" xml:space="preserve">
          <source>In-process servers can be registered using the &lt;code&gt;regsvr32&lt;/code&gt; tool available on all Windows systems.</source>
          <target state="translated">可以使用所有Windows系统上可用的 &lt;code&gt;regsvr32&lt;/code&gt; 工具来注册进程内服务器。</target>
        </trans-unit>
        <trans-unit id="09af574c7f20770e2ba62ab519196e2d4d08efa4" translate="yes" xml:space="preserve">
          <source>Inactive</source>
          <target state="translated">Inactive</target>
        </trans-unit>
        <trans-unit id="b3ae7850d6f2a44a03399e9a0dba5a89c8cc487d" translate="yes" xml:space="preserve">
          <source>Incidentally, &lt;a href=&quot;qlcdnumber&quot;&gt;QLCDNumber&lt;/a&gt; is the very oldest part of Qt, tracing its roots back to a BASIC program on the &lt;a href=&quot;http://www.nvg.ntnu.no/sinclair/computers/zxspectrum/zxspectrum.htm#&quot;&gt;Sinclair Spectrum&lt;/a&gt;.</source>
          <target state="translated">顺便说一句，&lt;a href=&quot;qlcdnumber&quot;&gt;QLCDNumber&lt;/a&gt;是Qt的最老部分，其根源可以追溯到&lt;a href=&quot;http://www.nvg.ntnu.no/sinclair/computers/zxspectrum/zxspectrum.htm#&quot;&gt;Sinclair Spectrum&lt;/a&gt;上的BASIC程序。</target>
        </trans-unit>
        <trans-unit id="72fbd3be5003e3120ca9f394b6148b8520d0b768" translate="yes" xml:space="preserve">
          <source>Incidentally, QLCDNumber is the very oldest part of Qt, tracing its roots back to a BASIC program on the &lt;a href=&quot;http://www.nvg.ntnu.no/sinclair/computers/zxspectrum/zxspectrum.htm&quot;&gt;Sinclair Spectrum&lt;/a&gt;.</source>
          <target state="translated">顺便说一句，QLCDNumber是Qt的最老部分，其根源可以追溯到&lt;a href=&quot;http://www.nvg.ntnu.no/sinclair/computers/zxspectrum/zxspectrum.htm&quot;&gt;Sinclair Spectrum&lt;/a&gt;上的BASIC程序。</target>
        </trans-unit>
        <trans-unit id="e794db49ca9cd25f93986ee6089723c877e37e32" translate="yes" xml:space="preserve">
          <source>Includable Functions</source>
          <target state="translated">可包含的功能</target>
        </trans-unit>
        <trans-unit id="1521a666fd6d8d437d41c159ff934a47f7429e39" translate="yes" xml:space="preserve">
          <source>Include debugging help for mismatched calls to unbind. See &lt;a href=&quot;https://developer.android.com/reference/android/content/Context.html#BIND_DEBUG_UNBIND&quot;&gt;BIND_DEBUG_UNBIND&lt;/a&gt; documentation for more details.</source>
          <target state="translated">包括调试帮助，用于不匹配的取消绑定调用。有关更多详细信息，请参见&lt;a href=&quot;https://developer.android.com/reference/android/content/Context.html#BIND_DEBUG_UNBIND&quot;&gt;BIND_DEBUG_UNBIND&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="2bc3fb3eaaf1e96edaa226b1b4b3f9af011ca27b" translate="yes" xml:space="preserve">
          <source>Include the header which defines the type.</source>
          <target state="translated">包括定义类型的头。</target>
        </trans-unit>
        <trans-unit id="0bf6b578622f60be8bbfa44c31e5ef1143efa871" translate="yes" xml:space="preserve">
          <source>Include the leading separator (if any) in the result string.</source>
          <target state="translated">在结果字符串中包含前导分隔符(如果有的话)。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
