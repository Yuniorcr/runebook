<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="docker">
    <body>
      <group id="docker">
        <trans-unit id="10cc55b4e5a8d47bdbcdbe70d599e97ab931b718" translate="yes" xml:space="preserve">
          <source>Expose ports without publishing them to the host machine - they&amp;rsquo;ll only be accessible to linked services. Only the internal port can be specified.</source>
          <target state="translated">公开端口而不将其发布到主机上-只有链接的服务才能访问它们。只能指定内部端口。</target>
        </trans-unit>
        <trans-unit id="e767ce644c04911f18c98b70d31d374b9eb56cd3" translate="yes" xml:space="preserve">
          <source>Expose ports.</source>
          <target state="translated">暴露端口。</target>
        </trans-unit>
        <trans-unit id="1619f9c5566c78e1d11c4ff900380478003ac635" translate="yes" xml:space="preserve">
          <source>Expose ports. Either specify both ports (&lt;code&gt;HOST:CONTAINER&lt;/code&gt;), or just the container port (an ephemeral host port is chosen).</source>
          <target state="translated">露出端口。要么指定两个端口（ &lt;code&gt;HOST:CONTAINER&lt;/code&gt; ），要么仅指定容器端口（选择临时主机端口）。</target>
        </trans-unit>
        <trans-unit id="1fbc71f7387278269f1d957e28390616407593f9" translate="yes" xml:space="preserve">
          <source>Exposed port number, such as &lt;code&gt;DB_PORT_5432_TCP_PORT=5432&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;DB_PORT_5432_TCP_PORT=5432&lt;/code&gt; 端口号，例如DB_PORT_5432_TCP_PORT = 5432</target>
        </trans-unit>
        <trans-unit id="d62bff054d1ae4b7900a38f3e9ee0b3444fd521c" translate="yes" xml:space="preserve">
          <source>Exposed ports.</source>
          <target state="translated">暴露的端口。</target>
        </trans-unit>
        <trans-unit id="3105862e09650234250b61444f5ddb0b9b8b7c98" translate="yes" xml:space="preserve">
          <source>Exposes WordPress on port 30000 of the host machine, so that you can access it from external hosts. You can expose port 80 instead if you do not have a web server running on port 80 of the host machine.</source>
          <target state="translated">将WordPress暴露在主机的30000端口上,这样您就可以从外部主机访问它。如果您没有在主机的80端口上运行的Web服务器,您可以暴露80端口。</target>
        </trans-unit>
        <trans-unit id="47c7c7ba02689bdfe8fac698936944594767c963" translate="yes" xml:space="preserve">
          <source>Express dependency between services, Service dependencies cause the following behaviors:</source>
          <target state="translated">表示服务之间的依赖关系,服务依赖会导致以下行为。</target>
        </trans-unit>
        <trans-unit id="68a134f7e49c8860c88eb0b67bcd14cb443270ec" translate="yes" xml:space="preserve">
          <source>Express dependency between services, which has two effects:</source>
          <target state="translated">表达服务之间的依赖关系,这有两个效果。</target>
        </trans-unit>
        <trans-unit id="e64ffe047868ebb24ac6b257af5f051e7f6caf40" translate="yes" xml:space="preserve">
          <source>Extend another service, in the current file or another, optionally overriding configuration.</source>
          <target state="translated">扩展另一个服务,在当前文件或另一个,可选择覆盖配置。</target>
        </trans-unit>
        <trans-unit id="161d32faaff143d7590da9bcd1ca3c7b7b4bee8d" translate="yes" xml:space="preserve">
          <source>Extended description</source>
          <target state="translated">扩展说明</target>
        </trans-unit>
        <trans-unit id="9102b67eb74161bf5739f97d399e8cca8296b36a" translate="yes" xml:space="preserve">
          <source>Extending an entire Compose file by &lt;a href=&quot;index#multiple-compose-files&quot;&gt;using multiple Compose files&lt;/a&gt;</source>
          <target state="translated">通过&lt;a href=&quot;index#multiple-compose-files&quot;&gt;使用多个Compose文件&lt;/a&gt;扩展整个Compose文件</target>
        </trans-unit>
        <trans-unit id="6c0b262b322484366b736a907cf2b63e2f1189c3" translate="yes" xml:space="preserve">
          <source>Extending an individual service is useful when you have multiple services that have a common configuration. The example below is a Compose app with two services: a web application and a queue worker. Both services use the same codebase and share many configuration options.</source>
          <target state="translated">当您拥有多个具有共同配置的服务时,扩展单个服务非常有用。下面的示例是一个具有两个服务的 Compose 应用程序:一个 Web 应用程序和一个队列工作者。两个服务都使用相同的代码库并共享许多配置选项。</target>
        </trans-unit>
        <trans-unit id="45f90ec3f1e60b8d22f7d8e0320fec2e1c4925a4" translate="yes" xml:space="preserve">
          <source>Extending individual services with &lt;a href=&quot;index#extending-services&quot;&gt;the &lt;code&gt;extends&lt;/code&gt; field&lt;/a&gt; (for Compose file versions up to 2.1)</source>
          <target state="translated">延伸个别服务&lt;a href=&quot;index#extending-services&quot;&gt;的 &lt;code&gt;extends&lt;/code&gt; 字段&lt;/a&gt;（用于撰写文件版本到2.1）</target>
        </trans-unit>
        <trans-unit id="fea7d09b0172e42db8b4095d4228b89a2dc7a781" translate="yes" xml:space="preserve">
          <source>Extending services</source>
          <target state="translated">扩大服务范围</target>
        </trans-unit>
        <trans-unit id="b8911778c9fba90f4c057ef35b96269e91c23ac5" translate="yes" xml:space="preserve">
          <source>Extension fields</source>
          <target state="translated">扩展领域</target>
        </trans-unit>
        <trans-unit id="25ef7b426747adfde8e7cee3a78fcaf439560176" translate="yes" xml:space="preserve">
          <source>External components, such as cloud load balancers, can access the service on the PublishedPort of any node in the cluster whether or not the node is currently running the task for the service. All nodes in the swarm route ingress connections to a running task instance.</source>
          <target state="translated">外部组件(如云负载均衡器)可以通过集群中任何节点的 PublishedPort 访问服务,无论该节点当前是否正在运行该服务的任务。群中的所有节点都会将入口连接路由到正在运行的任务实例上。</target>
        </trans-unit>
        <trans-unit id="88a26707fe24cd98fc98c5ab675aa6efa0354e81" translate="yes" xml:space="preserve">
          <source>External implementation features</source>
          <target state="translated">外部执行特点</target>
        </trans-unit>
        <trans-unit id="2df7c6ad0c1d697b076b44b742ad83a265e266ec" translate="yes" xml:space="preserve">
          <source>External volumes are always created with docker stack deploy</source>
          <target state="translated">外部卷总是用docker堆栈deploy来创建。</target>
        </trans-unit>
        <trans-unit id="15168c1fc7995a3bda7e8147826c809d91841678" translate="yes" xml:space="preserve">
          <source>External volumes that do not exist &lt;em&gt;are created&lt;/em&gt; if you use &lt;a href=&quot;#deploy&quot;&gt;docker stack deploy&lt;/a&gt; to launch the app in &lt;a href=&quot;../../engine/swarm/index&quot;&gt;swarm mode&lt;/a&gt; (instead of &lt;a href=&quot;../reference/up/index&quot;&gt;docker compose up&lt;/a&gt;). In swarm mode, a volume is automatically created when it is defined by a service. As service tasks are scheduled on new nodes, &lt;a href=&quot;https://github.com/docker/swarmkit/blob/master/README/&quot;&gt;swarmkit&lt;/a&gt; creates the volume on the local node. To learn more, see &lt;a href=&quot;https://github.com/moby/moby/issues/29976&quot;&gt;moby/moby#29976&lt;/a&gt;.</source>
          <target state="translated">如果您使用&lt;a href=&quot;#deploy&quot;&gt;docker stack deploy&lt;/a&gt;以&lt;a href=&quot;../../engine/swarm/index&quot;&gt;群体模式&lt;/a&gt;启动应用程序（而不是&lt;a href=&quot;../reference/up/index&quot;&gt;docker compose up&lt;/a&gt;），&lt;em&gt;则会创建&lt;/em&gt;不存在的外部卷。在群模式下，由服务定义卷后将自动创建该卷。由于服务任务是在新节点上安排的，因此&lt;a href=&quot;https://github.com/docker/swarmkit/blob/master/README/&quot;&gt;swarmkit&lt;/a&gt;在本地节点上创建卷。要了解更多信息，请参见&lt;a href=&quot;https://github.com/moby/moby/issues/29976&quot;&gt;moby / moby＃29976&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="69a9dac6efea62707611763428619cdecc46fa49" translate="yes" xml:space="preserve">
          <source>FOWNER</source>
          <target state="translated">FOWNER</target>
        </trans-unit>
        <trans-unit id="8e7f00cffd27676bd86f7a41b4fecf304cf6d5a6" translate="yes" xml:space="preserve">
          <source>FROM</source>
          <target state="translated">FROM</target>
        </trans-unit>
        <trans-unit id="7b817867f7950dd64ffa6bb8b39b3a24e057710f" translate="yes" xml:space="preserve">
          <source>FSETID</source>
          <target state="translated">FSETID</target>
        </trans-unit>
        <trans-unit id="0950f1a60851cc92b56c7a7fbcd6fcf8bf42bed9" translate="yes" xml:space="preserve">
          <source>Failure rate to tolerate during a rollback</source>
          <target state="translated">在回滚过程中可容忍的故障率。</target>
        </trans-unit>
        <trans-unit id="3f228debbb439b7b1f8c1b5f1e2fafb87ab5778e" translate="yes" xml:space="preserve">
          <source>Failure rate to tolerate during a rollback (default 0)</source>
          <target state="translated">在回滚过程中可容忍的故障率(默认为0)。</target>
        </trans-unit>
        <trans-unit id="1ee75a5d4048975d35f9a0da09c9bc2e67401147" translate="yes" xml:space="preserve">
          <source>Failure rate to tolerate during an update</source>
          <target state="translated">在更新过程中容忍的失败率</target>
        </trans-unit>
        <trans-unit id="8e41dafe24b8e98505b8b2f5f08ed3b3dee52413" translate="yes" xml:space="preserve">
          <source>Failure rate to tolerate during an update (default 0)</source>
          <target state="translated">更新过程中容忍的失败率(默认为0</target>
        </trans-unit>
        <trans-unit id="ca27a0bac93ec2d83df6d32cae9fd11cbaa465aa" translate="yes" xml:space="preserve">
          <source>Fault Tolerance</source>
          <target state="translated">容错率</target>
        </trans-unit>
        <trans-unit id="dc6720ec19a045ad4a41542f0a1931e0dd8a15c7" translate="yes" xml:space="preserve">
          <source>Feature Deprecation Policy</source>
          <target state="translated">功能废弃政策</target>
        </trans-unit>
        <trans-unit id="5a6ace8a0d67202b6a12d2b8687690b1324abee4" translate="yes" xml:space="preserve">
          <source>Feature highlights</source>
          <target state="translated">特色亮点</target>
        </trans-unit>
        <trans-unit id="3286949be5f9c0e2f39ddf6e437d797d23e49cbd" translate="yes" xml:space="preserve">
          <source>Feature options</source>
          <target state="translated">功能选项</target>
        </trans-unit>
        <trans-unit id="fc338f87a058158eb824b53705961801516a9460" translate="yes" xml:space="preserve">
          <source>Features</source>
          <target state="translated">Features</target>
        </trans-unit>
        <trans-unit id="bc5fc74a0c921be17dde1b381a9a43609da45dab" translate="yes" xml:space="preserve">
          <source>Fedora</source>
          <target state="translated">Fedora</target>
        </trans-unit>
        <trans-unit id="db28646201232a1d472af5ee747adae8ccf3c157" translate="yes" xml:space="preserve">
          <source>Fetch the logs of a container</source>
          <target state="translated">获取容器的日志</target>
        </trans-unit>
        <trans-unit id="eb5b38f5a58944684e8d2dc83a9cb9e1f17f669c" translate="yes" xml:space="preserve">
          <source>Fetch the logs of a service or task</source>
          <target state="translated">获取服务或任务的日志。</target>
        </trans-unit>
        <trans-unit id="479d806c144be804128caa2e2a55d68248c3013b" translate="yes" xml:space="preserve">
          <source>File mode of the tmpfs in octal. (e.g.</source>
          <target state="translated">tmpfs的文件模式,单位为八进制。(例如</target>
        </trans-unit>
        <trans-unit id="410867a8d746780656c7afa6302f50564b7bca8f" translate="yes" xml:space="preserve">
          <source>Files and state on disk</source>
          <target state="translated">文件和磁盘上的状态</target>
        </trans-unit>
        <trans-unit id="d7decf1aa22b02ae8abf9a96849ee423eee838e4" translate="yes" xml:space="preserve">
          <source>Filter</source>
          <target state="translated">Filter</target>
        </trans-unit>
        <trans-unit id="d600800f7900f101638275541b8da4023176f070" translate="yes" xml:space="preserve">
          <source>Filter by exit signal</source>
          <target state="translated">按出口信号过滤</target>
        </trans-unit>
        <trans-unit id="77b6f6141940aa9f15c840f98693412c7ae70370" translate="yes" xml:space="preserve">
          <source>Filter events by criteria</source>
          <target state="translated">按标准过滤事件</target>
        </trans-unit>
        <trans-unit id="ab731432fea41b3e082bc35806547ae3a28f48e9" translate="yes" xml:space="preserve">
          <source>Filter events by time</source>
          <target state="translated">按时间过滤事件</target>
        </trans-unit>
        <trans-unit id="640790603f3ecbc2b0f007b68bb2a4fdc6962815" translate="yes" xml:space="preserve">
          <source>Filter images by reference</source>
          <target state="translated">按参考文献过滤图像</target>
        </trans-unit>
        <trans-unit id="7e2bcaa91ef285441340e377f905181d36b6a42b" translate="yes" xml:space="preserve">
          <source>Filter images by time</source>
          <target state="translated">按时间过滤图像</target>
        </trans-unit>
        <trans-unit id="7f74589fe05009f7909335b66ed93724d1a2e2a2" translate="yes" xml:space="preserve">
          <source>Filter output based on conditions provided</source>
          <target state="translated">根据提供的条件过滤输出</target>
        </trans-unit>
        <trans-unit id="9075edca21736af901d2add18e4d9491f2452b4d" translate="yes" xml:space="preserve">
          <source>Filtering</source>
          <target state="translated">Filtering</target>
        </trans-unit>
        <trans-unit id="02ad80c98c2aba9c2c0ee285bbacb832e17e3f0f" translate="yes" xml:space="preserve">
          <source>Filtering on both &lt;code&gt;key&lt;/code&gt;&lt;em&gt;and&lt;/em&gt;&lt;code&gt;value&lt;/code&gt; of the label, produces the expected result:</source>
          <target state="translated">同时过滤标签的 &lt;code&gt;key&lt;/code&gt; &lt;em&gt;和&lt;/em&gt; &lt;code&gt;value&lt;/code&gt; ，会产生预期的结果：</target>
        </trans-unit>
        <trans-unit id="a57c0d9cff01bc0bf8dfb239e93f01b4c27ed679" translate="yes" xml:space="preserve">
          <source>Filtering with &lt;code&gt;before&lt;/code&gt; would give:</source>
          <target state="translated">用 &lt;code&gt;before&lt;/code&gt; 过滤将得到：</target>
        </trans-unit>
        <trans-unit id="5d693a3237875e523ade80913305f07c0d600fb0" translate="yes" xml:space="preserve">
          <source>Filtering with &lt;code&gt;reference&lt;/code&gt; would give:</source>
          <target state="translated">&lt;code&gt;reference&lt;/code&gt; 过滤将得到：</target>
        </trans-unit>
        <trans-unit id="6c44fdb5c3ad6e5bdf8193c70970138671389714" translate="yes" xml:space="preserve">
          <source>Filtering with &lt;code&gt;since&lt;/code&gt; would give:</source>
          <target state="translated">具有过滤 &lt;code&gt;since&lt;/code&gt; 会给：</target>
        </trans-unit>
        <trans-unit id="d414611e6289ed9a2a817ad183fa014b4147455d" translate="yes" xml:space="preserve">
          <source>Filtering with multiple &lt;code&gt;reference&lt;/code&gt; would give, either match A or B:</source>
          <target state="translated">使用多个 &lt;code&gt;reference&lt;/code&gt; 过滤将得出匹配A或B的结果：</target>
        </trans-unit>
        <trans-unit id="69612f321e27e4f832f808b875cc54c3521ece6c" translate="yes" xml:space="preserve">
          <source>Filters containers based on their healthcheck status. One of &lt;code&gt;starting&lt;/code&gt;, &lt;code&gt;healthy&lt;/code&gt;, &lt;code&gt;unhealthy&lt;/code&gt; or &lt;code&gt;none&lt;/code&gt;.</source>
          <target state="translated">根据健康检查状态过滤容器。一 &lt;code&gt;starting&lt;/code&gt; ， &lt;code&gt;healthy&lt;/code&gt; ， &lt;code&gt;unhealthy&lt;/code&gt; 或者 &lt;code&gt;none&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5795d795526f86884093e8a90467b50876d23df7" translate="yes" xml:space="preserve">
          <source>Filters containers created before or after a given container ID or name</source>
          <target state="translated">过滤在给定容器ID或名称之前或之后创建的容器。</target>
        </trans-unit>
        <trans-unit id="6026deb4aa5a2a3c02af920eab62a65264cf103a" translate="yes" xml:space="preserve">
          <source>Filters containers that are a &amp;ldquo;task&amp;rdquo; for a service. Boolean option (&lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;)</source>
          <target state="translated">筛选作为服务&amp;ldquo;任务&amp;rdquo;的容器。布尔选项（ &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="1c4bb21ae08095d6170daee2f696815adb874d44" translate="yes" xml:space="preserve">
          <source>Filters containers which publish or expose a given port. Expressed as &lt;code&gt;&amp;lt;port&amp;gt;[/&amp;lt;proto&amp;gt;]&lt;/code&gt; or &lt;code&gt;&amp;lt;startport-endport&amp;gt;/[&amp;lt;proto&amp;gt;]&lt;/code&gt;</source>
          <target state="translated">筛选发布或公开给定端口的容器。表示为 &lt;code&gt;&amp;lt;port&amp;gt;[/&amp;lt;proto&amp;gt;]&lt;/code&gt; 或 &lt;code&gt;&amp;lt;startport-endport&amp;gt;/[&amp;lt;proto&amp;gt;]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b0e450b88d7c72346fd6945f7a9d5986312ba3d0" translate="yes" xml:space="preserve">
          <source>Filters containers which share a given image as an ancestor. Expressed as &lt;code&gt;&amp;lt;image-name&amp;gt;[:&amp;lt;tag&amp;gt;]&lt;/code&gt;, &lt;code&gt;&amp;lt;image id&amp;gt;&lt;/code&gt;, or &lt;code&gt;&amp;lt;image@digest&amp;gt;&lt;/code&gt;</source>
          <target state="translated">筛选共享给定图像作为祖先的容器。表示为 &lt;code&gt;&amp;lt;image-name&amp;gt;[:&amp;lt;tag&amp;gt;]&lt;/code&gt; ， &lt;code&gt;&amp;lt;image id&amp;gt;&lt;/code&gt; 或 &lt;code&gt;&amp;lt;image@digest&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c2d898f3ce102a6810216628ad5970d15ace76a5" translate="yes" xml:space="preserve">
          <source>Filters running containers connected to a given network.</source>
          <target state="translated">过滤连接到给定网络的运行容器。</target>
        </trans-unit>
        <trans-unit id="c06fd49fa5a6a64634581e170d14f4d1c398e58d" translate="yes" xml:space="preserve">
          <source>Filters running containers which have mounted a given volume or bind mount.</source>
          <target state="translated">过滤已挂载给定卷或绑定挂载的运行容器。</target>
        </trans-unit>
        <trans-unit id="c431796ca420e6a7c02b2e3f9abb01b4d1c23648" translate="yes" xml:space="preserve">
          <source>Finally when signing an image, we will need to export the passphrase of the signing key. This was created when the key was loaded into the local Docker trust store with &lt;code&gt;$ docker trust key load&lt;/code&gt;.</source>
          <target state="translated">最后，在对图像进行签名时，我们将需要导出签名密钥的密码。这是在将密钥通过 &lt;code&gt;$ docker trust key load&lt;/code&gt; 加载到本地Docker Trust Store中时创建的。</target>
        </trans-unit>
        <trans-unit id="b5dc1b015f206ca7874975675ea63a51bfd5d822" translate="yes" xml:space="preserve">
          <source>Finally you will need to add the private key into your local Docker trust store.</source>
          <target state="translated">最后你需要将私钥添加到你本地的Docker信任商店中。</target>
        </trans-unit>
        <trans-unit id="f818536ddbf306feb6891aa3cd76c54f3943496c" translate="yes" xml:space="preserve">
          <source>Finally, &lt;code&gt;docker-compose.yml&lt;/code&gt; is where the magic happens. This file describes the services that comprise your app (a database and a web app), how to get each one&amp;rsquo;s Docker image (the database just runs on a pre-made PostgreSQL image, and the web app is built from the current directory), and the configuration needed to link them together and expose the web app&amp;rsquo;s port.</source>
          <target state="translated">最后，神奇的地方就是 &lt;code&gt;docker-compose.yml&lt;/code&gt; 。该文件描述了组成您的应用程序（数据库和Web应用程序）的服务，如何获取每个人的Docker映像（数据库仅在预制的PostgreSQL映像上运行，并且Web应用程序是从当前目录构建的），以及将它们链接在一起并公开Web应用程序端口所需的配置。</target>
        </trans-unit>
        <trans-unit id="3544a0d9931c381ceaeadc392fc38ea2810a717c" translate="yes" xml:space="preserve">
          <source>Finally, Notary server notifies the client that their upload was successful.</source>
          <target state="translated">最后,公证服务器通知客户,他们的上传成功。</target>
        </trans-unit>
        <trans-unit id="d6aadd0ba1a57fa7d54146f69c2f64d3e67b3482" translate="yes" xml:space="preserve">
          <source>Finally, clean up after your test by stopping and removing the container, and then removing the image.</source>
          <target state="translated">最后,在你的测试后,通过停止和删除容器,然后删除图像进行清理。</target>
        </trans-unit>
        <trans-unit id="9714faaa10a31f5be73dee9d0070895cfb69f68e" translate="yes" xml:space="preserve">
          <source>Finally, if you run Docker on a server, it is recommended to run exclusively Docker on the server, and move all other services within containers controlled by Docker. Of course, it is fine to keep your favorite admin tools (probably at least an SSH server), as well as existing monitoring/supervision processes, such as NRPE and collectd.</source>
          <target state="translated">最后,如果你在服务器上运行Docker,建议只在服务器上运行Docker,并将所有其他服务移动到由Docker控制的容器内。当然,保留你最喜欢的管理工具(可能至少是一个SSH服务器),以及现有的监控/监督进程,如NRPE和collectd,也是可以的。</target>
        </trans-unit>
        <trans-unit id="2217e3e4a858c8204ac82dc889b9cc7dd620b363" translate="yes" xml:space="preserve">
          <source>Finally, in Docker 17.04 and higher, &lt;code&gt;--rollback&lt;/code&gt; cannot be used in conjunction with other flags to &lt;code&gt;docker service update&lt;/code&gt;.</source>
          <target state="translated">最后，在Docker 17.04及更高版本中，-- &lt;code&gt;--rollback&lt;/code&gt; 不能与docker &lt;code&gt;docker service update&lt;/code&gt; 其他标志一起使用。</target>
        </trans-unit>
        <trans-unit id="f57448584f9cc43f455aa0aab1881c0872662120" translate="yes" xml:space="preserve">
          <source>Finally, to help with automation, you can have Docker write the container ID out to a file of your choosing. This is similar to how some programs might write out their process ID to a file (you&amp;rsquo;ve seen them as PID files):</source>
          <target state="translated">最后，为了帮助自动化，您可以让Docker将容器ID写入您选择的文件中。这类似于某些程序将其进程ID写入文件（您已将它们视为PID文件）的方式类似：</target>
        </trans-unit>
        <trans-unit id="6906b86088888eb8546af8d0118fdab3cf4f7372" translate="yes" xml:space="preserve">
          <source>Finally, we will use the delegation private key to sign a particular tag and push it up to the registry.</source>
          <target state="translated">最后,我们将使用授权私钥来签署一个特定的标签,并将其推送到注册表。</target>
        </trans-unit>
        <trans-unit id="92fc4acade75b1ccbb1b5a96a8ff65d3f6b10c06" translate="yes" xml:space="preserve">
          <source>Finally, you may want to specify which files to include in the context, rather than which to exclude. To achieve this, specify &lt;code&gt;*&lt;/code&gt; as the first pattern, followed by one or more &lt;code&gt;!&lt;/code&gt; exception patterns.</source>
          <target state="translated">最后，您可能想要指定要包含在上下文中的文件，而不是要排除的文件。为此，将 &lt;code&gt;*&lt;/code&gt; 指定为第一个模式，然后指定一个或多个 &lt;code&gt;!&lt;/code&gt; 异常模式。</target>
        </trans-unit>
        <trans-unit id="259d31bb34b3c0a0e077c6d33ffc28ed89e63128" translate="yes" xml:space="preserve">
          <source>Finally, you need to &lt;code&gt;push&lt;/code&gt; your manifest list to the desired registry. Below are descriptions of these three commands, and an example putting them all together.</source>
          <target state="translated">最后，您需要 &lt;code&gt;push&lt;/code&gt; 清单列表推送到所需的注册表。下面是对这三个命令的描述，以及将它们全部组合在一起的示例。</target>
        </trans-unit>
        <trans-unit id="8fd935241a1ccd2211b04f0321e48886e426412e" translate="yes" xml:space="preserve">
          <source>Finally, you need to create the database. In another terminal, run:</source>
          <target state="translated">最后,你需要创建数据库。在另一个终端,运行。</target>
        </trans-unit>
        <trans-unit id="83d85ce55eb317788dc65fb1efb8f89244e4307b" translate="yes" xml:space="preserve">
          <source>Find a specific port mapping</source>
          <target state="translated">找到一个特定的端口映射</target>
        </trans-unit>
        <trans-unit id="13fa60c3b3e08672f84a5135a4ac7e2623136ff9" translate="yes" xml:space="preserve">
          <source>Find network plugins</source>
          <target state="translated">寻找网络插件</target>
        </trans-unit>
        <trans-unit id="5cee6e7e616c938639b70650e8245a62a7a5cf68" translate="yes" xml:space="preserve">
          <source>Find the &lt;a href=&quot;https://docs.docker.com/install/#supported-platforms&quot;&gt;install instructions&lt;/a&gt; for Docker Engine --- Community on the platform of your choice.</source>
          <target state="translated">在您选择的平台上找到Docker Engine --- Community 的&lt;a href=&quot;https://docs.docker.com/install/#supported-platforms&quot;&gt;安装说明&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="52d5fc6e2545bef3fd448493145258f54498b4a1" translate="yes" xml:space="preserve">
          <source>Find the number of tasks running as part of a service</source>
          <target state="translated">查找作为服务一部分运行的任务数量</target>
        </trans-unit>
        <trans-unit id="d05317fb15464e667ff061aad99a88d79458897a" translate="yes" xml:space="preserve">
          <source>Finding a plugin</source>
          <target state="translated">找到一个插件</target>
        </trans-unit>
        <trans-unit id="414493a61bfe6a3e1bca2041f8b189cda955841f" translate="yes" xml:space="preserve">
          <source>Fine-tune bandwidth allocation by device. Each item in the list must have two keys:</source>
          <target state="translated">按设备微调带宽分配。列表中的每个项目必须有两个键。</target>
        </trans-unit>
        <trans-unit id="9f93fcd65aed246f6b56aaeb31480a9272b15cd5" translate="yes" xml:space="preserve">
          <source>First of all, &lt;strong&gt;only trusted users should be allowed to control your Docker daemon&lt;/strong&gt;. This is a direct consequence of some powerful Docker features. Specifically, Docker allows you to share a directory between the Docker host and a guest container; and it allows you to do so without limiting the access rights of the container. This means that you can start a container where the &lt;code&gt;/host&lt;/code&gt; directory is the &lt;code&gt;/&lt;/code&gt; directory on your host; and the container can alter your host filesystem without any restriction. This is similar to how virtualization systems allow filesystem resource sharing. Nothing prevents you from sharing your root filesystem (or even your root block device) with a virtual machine.</source>
          <target state="translated">首先，&lt;strong&gt;应仅允许受信任的用户控制您的Docker守护进程&lt;/strong&gt;。这是一些强大的Docker功能的直接结果。具体来说，Docker允许您在Docker主机和来宾容器之间共享目录。并且它允许您这样做而不会限制容器的访问权限。这意味着您可以启动一个容器，其中 &lt;code&gt;/host&lt;/code&gt; 目录是主机上的 &lt;code&gt;/&lt;/code&gt; 目录；并且容器可以无限制地更改您的主机文件系统。这类似于虚拟化系统允许文件系统资源共享的方式。没有什么可以阻止您与虚拟机共享根文件系统（甚至根块设备）。</target>
        </trans-unit>
        <trans-unit id="d14a9370ad1103e2d07dacfa097736d6eeb238b2" translate="yes" xml:space="preserve">
          <source>First save the new image by finding the container ID (using &lt;a href=&quot;../ps/index&quot;&gt;&lt;code&gt;docker ps&lt;/code&gt;&lt;/a&gt;) and then committing it to a new image name. Note that only &lt;code&gt;a-z0-9-_.&lt;/code&gt; are allowed when naming images:</source>
          <target state="translated">首先通过找到容器ID（使用&lt;a href=&quot;../ps/index&quot;&gt; &lt;code&gt;docker ps&lt;/code&gt; &lt;/a&gt;）保存新映像，然后将其提交给新映像名称。请注意，只有 &lt;code&gt;a-z0-9-_.&lt;/code&gt; 命名图像时被允许：</target>
        </trans-unit>
        <trans-unit id="04448eeef6a550c82cc0fd8f35aecc69667b1679" translate="yes" xml:space="preserve">
          <source>First we will add the delegation private key to the local Docker trust repository. (By default this is stored in &lt;code&gt;~/.docker/trust/&lt;/code&gt;). If you are generating delegation keys with &lt;code&gt;$ docker trust key generate&lt;/code&gt;, the private key is automatically added to the local trust store. If you are importing a separate key, such as one from a UCP Client Bundle you will need to use the &lt;code&gt;$ docker trust key load&lt;/code&gt; command.</source>
          <target state="translated">首先，我们将委派私钥添加到本地Docker信任库中。（默认情况下，它存储在 &lt;code&gt;~/.docker/trust/&lt;/code&gt; ）。如果使用 &lt;code&gt;$ docker trust key generate&lt;/code&gt; 生成委派密钥，则私钥会自动添加到本地信任存储中。如果要导入单独的密钥（例如，从UCP客户端捆绑包中导入），则需要使用 &lt;code&gt;$ docker trust key load&lt;/code&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="9247ff9257fd2f1f65e6eb48b10cd8bb50d8471d" translate="yes" xml:space="preserve">
          <source>First, Compose builds the image for the &lt;code&gt;web&lt;/code&gt; service using the &lt;code&gt;Dockerfile&lt;/code&gt;. Then it runs &lt;code&gt;rails new&lt;/code&gt; inside a new container, using that image. Once it&amp;rsquo;s done, you should have generated a fresh app.</source>
          <target state="translated">首先，Compose 使用 &lt;code&gt;Dockerfile&lt;/code&gt; 为 &lt;code&gt;web&lt;/code&gt; 服务构建映像。然后，使用该映像在新容器中运行 &lt;code&gt;rails new&lt;/code&gt; 。完成后，您应该已经生成了一个新应用。</target>
        </trans-unit>
        <trans-unit id="a4c3ab04bf48fb4e40c7ba46df68ccf37baeb93c" translate="yes" xml:space="preserve">
          <source>First, create an overlay network on a manager node the docker network create command:</source>
          <target state="translated">首先,在管理器节点上创建一个覆盖网络的docker网络创建命令。</target>
        </trans-unit>
        <trans-unit id="c83fc5ec66c9c65162a4a8fbbbc2c9e5f9e915ee" translate="yes" xml:space="preserve">
          <source>First, create overlay network on a manager node using the &lt;code&gt;docker network create&lt;/code&gt; command with the &lt;code&gt;--driver overlay&lt;/code&gt; flag.</source>
          <target state="translated">首先，使用带有 &lt;code&gt;--driver overlay&lt;/code&gt; 标志的docker &lt;code&gt;docker network create&lt;/code&gt; 命令在管理器节点上创建覆盖网络。</target>
        </trans-unit>
        <trans-unit id="f046ebcba9b52f3dd3b664bb50e9e065aab6e275" translate="yes" xml:space="preserve">
          <source>First, find the ID of the &lt;code&gt;mysql&lt;/code&gt; container task.</source>
          <target state="translated">首先，找到 &lt;code&gt;mysql&lt;/code&gt; 容器任务的ID 。</target>
        </trans-unit>
        <trans-unit id="54ee5e8ff32c0596a1928a8bd873c17a5f190256" translate="yes" xml:space="preserve">
          <source>First, let&amp;rsquo;s create some volumes to illustrate this;</source>
          <target state="translated">首先，让我们创建一些卷来说明这一点；</target>
        </trans-unit>
        <trans-unit id="0fc3c85159e1cda9d6d8437732629919da8e860c" translate="yes" xml:space="preserve">
          <source>First, on the &lt;strong&gt;Docker daemon&amp;rsquo;s host machine&lt;/strong&gt;, generate CA private and public keys:</source>
          <target state="translated">首先，在&lt;strong&gt;Docker守护程序的主机上&lt;/strong&gt;，生成CA私钥和公钥：</target>
        </trans-unit>
        <trans-unit id="444f7cb18e4c5861ad31efb8a57c41fd23d5bacb" translate="yes" xml:space="preserve">
          <source>First, quickly create a virtual switch for your virtual machines (VMs) to share, so they can connect to each other.</source>
          <target state="translated">首先,快速为您的虚拟机(VM)创建一个虚拟交换机来共享,这样它们就可以相互连接。</target>
        </trans-unit>
        <trans-unit id="96cbae3e155f1d9161fc02945d0af79b89bc3d66" translate="yes" xml:space="preserve">
          <source>First, specify the arguments in your Dockerfile:</source>
          <target state="translated">首先,在你的Docker文件中指定参数。</target>
        </trans-unit>
        <trans-unit id="862b2f12afc91efbeca488ea0d1e8410e3ebe571" translate="yes" xml:space="preserve">
          <source>First, start a container.</source>
          <target state="translated">首先,启动一个容器。</target>
        </trans-unit>
        <trans-unit id="7a45b5f00da3de07aa5ff907babcdec7174735ed" translate="yes" xml:space="preserve">
          <source>First, the command passed by &lt;code&gt;run&lt;/code&gt; overrides the command defined in the service configuration. For example, if the &lt;code&gt;web&lt;/code&gt; service configuration is started with &lt;code&gt;bash&lt;/code&gt;, then &lt;code&gt;docker-compose run web python app.py&lt;/code&gt; overrides it with &lt;code&gt;python app.py&lt;/code&gt;.</source>
          <target state="translated">首先， &lt;code&gt;run&lt;/code&gt; 传递的命令将覆盖服务配置中定义的命令。例如，如果 &lt;code&gt;web&lt;/code&gt; 服务配置开始 &lt;code&gt;bash&lt;/code&gt; ，那么 &lt;code&gt;docker-compose run web python app.py&lt;/code&gt; 覆盖它与 &lt;code&gt;python app.py&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a774409a00c21de377cf8ed5c6a56b8547973042" translate="yes" xml:space="preserve">
          <source>Flag</source>
          <target state="translated">Flag</target>
        </trans-unit>
        <trans-unit id="5934c9bc41702137908811ade80842e4a75fd7e5" translate="yes" xml:space="preserve">
          <source>Flexible: Even the most complex applications can be containerized.</source>
          <target state="translated">灵活。即使是最复杂的应用也可以容器化。</target>
        </trans-unit>
        <trans-unit id="930f69b51fd17123cc140776719e699727398f20" translate="yes" xml:space="preserve">
          <source>Flocker plugin</source>
          <target state="translated">Flocker插件</target>
        </trans-unit>
        <trans-unit id="fcc6594bb0b92c4eb7e3a8e3e7dc4f65990189e5" translate="yes" xml:space="preserve">
          <source>Fluentd logging driver for Docker. Writes log messages to &lt;code&gt;fluentd&lt;/code&gt; (forward input).</source>
          <target state="translated">Docker的流利日志记录驱动程序。将日志消息 &lt;code&gt;fluentd&lt;/code&gt; （转发输入）。</target>
        </trans-unit>
        <trans-unit id="c415de307b5b66bc1d7410ab29dc16cd1007efd3" translate="yes" xml:space="preserve">
          <source>Follow along with this example to create a Dockerized &lt;a href=&quot;https://aws.amazon.com/&quot;&gt;Amazon Web Services (AWS)&lt;/a&gt; EC2 instance.</source>
          <target state="translated">跟随此示例创建一个Dockerized &lt;a href=&quot;https://aws.amazon.com/&quot;&gt;Amazon Web Services（AWS）&lt;/a&gt; EC2实例。</target>
        </trans-unit>
        <trans-unit id="02c70a70472cc26b862c39358f0a40d7c3cc1dc3" translate="yes" xml:space="preserve">
          <source>Follow along with this example to create a Dockerized &lt;a href=&quot;https://digitalocean.com&quot;&gt;DigitalOcean&lt;/a&gt; Droplet (cloud host).</source>
          <target state="translated">跟随此示例创建Dockerized &lt;a href=&quot;https://digitalocean.com&quot;&gt;DigitalOcean&lt;/a&gt; Droplet（云主机）。</target>
        </trans-unit>
        <trans-unit id="50e557ca59ee1c15418cfad996f28c84fcc2e59e" translate="yes" xml:space="preserve">
          <source>Follow log output</source>
          <target state="translated">遵循日志输出</target>
        </trans-unit>
        <trans-unit id="a2a986220319ce46e96db408ea8a7aa7ebae81cb" translate="yes" xml:space="preserve">
          <source>Follow the &lt;a href=&quot;https://docs.docker.com/ee&quot;&gt;instructions to install Docker Enterprise on your own host&lt;/a&gt;.</source>
          <target state="translated">按照&lt;a href=&quot;https://docs.docker.com/ee&quot;&gt;说明在自己的主机上安装Docker Enterprise&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7491d11292ea61353bb977068a2d14f20b4e1925" translate="yes" xml:space="preserve">
          <source>Follow the instructions below to install Compose on Mac, Windows, Windows Server 2016, or Linux systems, or find out about alternatives like using the &lt;code&gt;pip&lt;/code&gt; Python package manager or installing Compose as a container.</source>
          <target state="translated">请按照以下说明在Mac，Windows，Windows Server 2016或Linux系统上安装Compose，或者查找其他替代方法，例如使用 &lt;code&gt;pip&lt;/code&gt; Python软件包管理器或将Compose作为容器安装。</target>
        </trans-unit>
        <trans-unit id="1c87591d1c74e455474e0d27e9b59e8200e1175a" translate="yes" xml:space="preserve">
          <source>Follow the instructions in the plugin&amp;rsquo;s documentation.</source>
          <target state="translated">请遵循插件文档中的说明。</target>
        </trans-unit>
        <trans-unit id="8cd709b42b8b24dbbf2eecf73d92670b739574f7" translate="yes" xml:space="preserve">
          <source>Follow these instructions if you are running the Docker daemon and client directly on Microsoft Windows Server with &lt;a href=&quot;https://docs.docker.com/install/windows/docker-ee/&quot;&gt;Docker Engine - Enterprise&lt;/a&gt;, and want to install Docker Compose.</source>
          <target state="translated">如果要在具有&lt;a href=&quot;https://docs.docker.com/install/windows/docker-ee/&quot;&gt;Docker Engine-Enterprise的&lt;/a&gt; Microsoft Windows Server上直接运行Docker守护程序和客户端，并要安装Docker Compose，请遵循以下说明。</target>
        </trans-unit>
        <trans-unit id="38f6bae8156c03d163a5ae6b34a1c27cc9994cd1" translate="yes" xml:space="preserve">
          <source>Following is a sample &lt;code&gt;config.json&lt;/code&gt; file:</source>
          <target state="translated">以下是一个示例 &lt;code&gt;config.json&lt;/code&gt; 文件：</target>
        </trans-unit>
        <trans-unit id="2ccfdb35cd2c70fc2e2c954da1e73f673bc44961" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;../compose-versioning/index#version-1&quot;&gt;version 1 files&lt;/a&gt;, both named volumes and container volumes use the specified driver.</source>
          <target state="translated">对于&lt;a href=&quot;../compose-versioning/index#version-1&quot;&gt;版本1文件&lt;/a&gt;，命名卷和容器卷都使用指定的驱动程序。</target>
        </trans-unit>
        <trans-unit id="6aeb3988c30c40f245ce885ddbb2d8ffdec3c689" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;https://github.com/docker/labs/blob/master/README/&quot;&gt;Docker Labs&lt;/a&gt; tutorials on networking, start with &lt;a href=&quot;https://github.com/docker/labs/blob/master/networking/README/&quot;&gt;Designing Scalable, Portable Docker Container Networks&lt;/a&gt;</source>
          <target state="translated">有关网络的&lt;a href=&quot;https://github.com/docker/labs/blob/master/README/&quot;&gt;Docker Labs&lt;/a&gt;教程，请从&lt;a href=&quot;https://github.com/docker/labs/blob/master/networking/README/&quot;&gt;设计可扩展的便携式Docker容器网络开始&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="707347c8c03a4f73500708e4156a0e7959e515f2" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;alpine&lt;/code&gt;, the following dependency packages are needed: &lt;code&gt;py-pip&lt;/code&gt;, &lt;code&gt;python-dev&lt;/code&gt;, &lt;code&gt;libffi-dev&lt;/code&gt;, &lt;code&gt;openssl-dev&lt;/code&gt;, &lt;code&gt;gcc&lt;/code&gt;, &lt;code&gt;libc-dev&lt;/code&gt;, and &lt;code&gt;make&lt;/code&gt;.</source>
          <target state="translated">对于 &lt;code&gt;alpine&lt;/code&gt; ，需要以下依赖包： &lt;code&gt;py-pip&lt;/code&gt; ， &lt;code&gt;python-dev&lt;/code&gt; ， &lt;code&gt;libffi-dev&lt;/code&gt; ， &lt;code&gt;openssl-dev&lt;/code&gt; ， &lt;code&gt;gcc&lt;/code&gt; ， &lt;code&gt;libc-dev&lt;/code&gt; 和 &lt;code&gt;make&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="25cd7558fc1eb89ad48721ecba5e2b80b4b94b1f" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;cmd.exe&lt;/code&gt;:</source>
          <target state="translated">对于 &lt;code&gt;cmd.exe&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="cc8ec8aab7cf095cf0579846c7e7e6468215e121" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;nproc&lt;/code&gt; usage</source>
          <target state="translated">对于 &lt;code&gt;nproc&lt;/code&gt; 用法</target>
        </trans-unit>
        <trans-unit id="e612c0940787b80000ce35849581da833855ddfb" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;overlay&lt;/code&gt; networks or custom plugins that support multi-host connectivity, containers connected to the same multi-host network but launched from different Engines can also communicate in this way.</source>
          <target state="translated">对于支持多主机连接的 &lt;code&gt;overlay&lt;/code&gt; 网络或自定义插件，连接到同一多主机网络但从不同引擎启动的容器也可以这种方式进行通信。</target>
        </trans-unit>
        <trans-unit id="cfdbd6b18e68b8c72413226ed965f8182655d20b" translate="yes" xml:space="preserve">
          <source>For &lt;strong&gt;global services&lt;/strong&gt;, the swarm runs one task for the service on every available node in the cluster.</source>
          <target state="translated">对于&lt;strong&gt;全局服务&lt;/strong&gt;，群集在集群中的每个可用节点上为该服务运行一项任务。</target>
        </trans-unit>
        <trans-unit id="fb0fd0140da0a27d3976dba20b66f605cfb23f71" translate="yes" xml:space="preserve">
          <source>For AWS EC2, this command creates an instance called &amp;ldquo;aws-sandbox&amp;rdquo;:</source>
          <target state="translated">对于AWS EC2，此命令将创建一个名为&amp;ldquo; aws-sandbox&amp;rdquo;的实例：</target>
        </trans-unit>
        <trans-unit id="447cacaf9b16fc4c7f5e6ca9f806f31c719b0973" translate="yes" xml:space="preserve">
          <source>For DCT the name of the second delegation, in the below example &lt;code&gt;jeff&lt;/code&gt;, is there to help you keep track of the owner of the keys. In more advanced use cases of Notary additional delegations are used for hierarchy.</source>
          <target state="translated">对于DCT，第二个委托的名称（在下面的示例 &lt;code&gt;jeff&lt;/code&gt; 中）可以帮助您跟踪密钥的所有者。在公证人的更高级用例中，附加委托用于层次结构。</target>
        </trans-unit>
        <trans-unit id="8940a70f822bcb03782618de91f324cb90d20601" translate="yes" xml:space="preserve">
          <source>For DigitalOcean, this command creates a Droplet (cloud host) called &amp;ldquo;docker-sandbox&amp;rdquo;.</source>
          <target state="translated">对于DigitalOcean，此命令将创建一个名为&amp;ldquo; docker-sandbox&amp;rdquo;的Droplet（云主机）。</target>
        </trans-unit>
        <trans-unit id="c485fcd62e167979ddb95eaee13ff6a2a364df2c" translate="yes" xml:space="preserve">
          <source>For IPv6 use the &lt;code&gt;-6&lt;/code&gt; flag instead of the &lt;code&gt;-4&lt;/code&gt; flag. For other network devices, replace &lt;code&gt;eth0&lt;/code&gt; with the correct device name (for example &lt;code&gt;docker0&lt;/code&gt; for the bridge device).</source>
          <target state="translated">对于IPv6，请使用 &lt;code&gt;-6&lt;/code&gt; 标志而不是 &lt;code&gt;-4&lt;/code&gt; 标志。对于其他网络设备，将 &lt;code&gt;eth0&lt;/code&gt; 替换为正确的设备名称（例如，桥接设备的 &lt;code&gt;docker0&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="ee6dfc4ad5c5ab997d84f93afddd72ecb7a3a7d4" translate="yes" xml:space="preserve">
          <source>For PowerShell:</source>
          <target state="translated">对于PowerShell。</target>
        </trans-unit>
        <trans-unit id="1b25a772948c6c56539966318b1a20ad70311f9c" translate="yes" xml:space="preserve">
          <source>For Windows, the format of the string passed to the &lt;code&gt;--device&lt;/code&gt; option is in the form of &lt;code&gt;--device=&amp;lt;IdType&amp;gt;/&amp;lt;Id&amp;gt;&lt;/code&gt;. Beginning with Windows Server 2019 and Windows 10 October 2018 Update, Windows only supports an IdType of &lt;code&gt;class&lt;/code&gt; and the Id as a &lt;a href=&quot;https://docs.microsoft.com/en-us/windows-hardware/drivers/install/overview-of-device-interface-classes&quot;&gt;device interface class GUID&lt;/a&gt;. Refer to the table defined in the &lt;a href=&quot;https://docs.microsoft.com/en-us/virtualization/windowscontainers/deploy-containers/hardware-devices-in-containers&quot;&gt;Windows container docs&lt;/a&gt; for a list of container-supported device interface class GUIDs.</source>
          <target state="translated">对于Windows，传递给 &lt;code&gt;--device&lt;/code&gt; 选项的字符串格式为 &lt;code&gt;--device=&amp;lt;IdType&amp;gt;/&amp;lt;Id&amp;gt;&lt;/code&gt; 的形式。从Windows Server 2019和Windows 10 October 2018 Update开始，Windows仅支持IdType &lt;code&gt;class&lt;/code&gt; 和Id作为&lt;a href=&quot;https://docs.microsoft.com/en-us/windows-hardware/drivers/install/overview-of-device-interface-classes&quot;&gt;设备接口类GUID&lt;/a&gt;。有关容器支持的设备接口类GUID的列表，请参考&lt;a href=&quot;https://docs.microsoft.com/en-us/virtualization/windowscontainers/deploy-containers/hardware-devices-in-containers&quot;&gt;Windows容器文档&lt;/a&gt;中定义的表。</target>
        </trans-unit>
        <trans-unit id="fc9462e52246f5281496d962fc8b90628772ef20" translate="yes" xml:space="preserve">
          <source>For a complete list of &lt;code&gt;docker-machine&lt;/code&gt; subcommands, see the &lt;a href=&quot;../reference/help/index&quot;&gt;Docker Machine subcommand reference&lt;/a&gt;.</source>
          <target state="translated">有关 &lt;code&gt;docker-machine&lt;/code&gt; 子命令的完整列表，请参阅&lt;a href=&quot;../reference/help/index&quot;&gt;Docker Machine子命令参考&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3cf6a74624e619431401ab6d507c88398d72715e" translate="yes" xml:space="preserve">
          <source>For a full explanation of Compose&amp;rsquo;s use of Docker networking features and all network driver options, see the &lt;a href=&quot;../networking/index&quot;&gt;Networking guide&lt;/a&gt;.</source>
          <target state="translated">有关Compose使用Docker网络功能和所有网络驱动程序选项的完整说明，请参阅《&lt;a href=&quot;../networking/index&quot;&gt;网络指南》&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="356d0c9cd338533c7b0340d2989710578bfa324f" translate="yes" xml:space="preserve">
          <source>For a full list of drivers that work with &lt;code&gt;docker-machine create&lt;/code&gt; and information on how to use them, see &lt;a href=&quot;../../drivers/index&quot;&gt;Machine drivers&lt;/a&gt;.</source>
          <target state="translated">有关可与 &lt;code&gt;docker-machine create&lt;/code&gt; 一起使用的驱动程序的完整列表以及有关如何使用它们的信息，请参阅&lt;a href=&quot;../../drivers/index&quot;&gt;机器驱动程序&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fcc3765e5b6cbccc69b945d121e72879678bd785" translate="yes" xml:space="preserve">
          <source>For a full list of the flags/settings available and their defaults, see the output of &lt;code&gt;docker-machine create -h&lt;/code&gt; at the command line, the &lt;a href=&quot;../reference/create/index&quot;&gt;create&lt;/a&gt; command in the Machine &lt;a href=&quot;../reference/index&quot;&gt;command line reference&lt;/a&gt;, and &lt;a href=&quot;../drivers/os-base/index&quot;&gt;driver options and operating system defaults&lt;/a&gt; in the Machine driver reference.</source>
          <target state="translated">对于现有的标志/设置及其默认值的完整列表，请参阅的输出 &lt;code&gt;docker-machine create -h&lt;/code&gt; 在命令行中，&lt;a href=&quot;../reference/create/index&quot;&gt;创建&lt;/a&gt;于机命令&lt;a href=&quot;../reference/index&quot;&gt;命令行参考&lt;/a&gt;，并&lt;a href=&quot;../drivers/os-base/index&quot;&gt;驱动程序选项和操作系统默认&lt;/a&gt;的机器驱动程序参考。</target>
        </trans-unit>
        <trans-unit id="02bf6fa6bb3e32c4f9bb0834d4a8ed5d2922eb8a" translate="yes" xml:space="preserve">
          <source>For a more interesting test, run a Dockerized webserver on your new machine.</source>
          <target state="translated">要想进行更有趣的测试,可以在你的新机器上运行一个Docker化的web服务器。</target>
        </trans-unit>
        <trans-unit id="3e4f0e2d2909b9c3de7a0591599d13dbe7d88823" translate="yes" xml:space="preserve">
          <source>For a replicated service, you specify the number of identical tasks you want to run. For example, you decide to deploy an HTTP service with three replicas, each serving the same content.</source>
          <target state="translated">对于复制的服务,您可以指定要运行的相同任务的数量。例如,你决定部署一个有三个副本的HTTP服务,每个副本服务于相同的内容。</target>
        </trans-unit>
        <trans-unit id="9f50231702efc7479af395282f05f7bd91cdff89" translate="yes" xml:space="preserve">
          <source>For a step-by-step guide on using Machine to create Docker hosts on Digital Ocean, see the &lt;a href=&quot;../examples/ocean/index&quot;&gt;DigitalOcean Example&lt;/a&gt;.</source>
          <target state="translated">有关使用Machine在Digital Ocean上创建Docker主机的分步指南，请参阅&lt;a href=&quot;../examples/ocean/index&quot;&gt;DigitalOcean示例&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2c1f040e62ba21f3108502b13d5895d0b02b9f7c" translate="yes" xml:space="preserve">
          <source>For a step-by-step guide on using Machine to create Dockerized AWS instances, see the &lt;a href=&quot;../examples/aws/index&quot;&gt;Amazon Web Services (AWS) example&lt;/a&gt;.</source>
          <target state="translated">有关使用Machine创建Dockerized AWS实例的分步指南，请参阅&lt;a href=&quot;../examples/aws/index&quot;&gt;Amazon Web Services（AWS）示例&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5af28b648ec0036ec492c739939181d43deb2459" translate="yes" xml:space="preserve">
          <source>For a working example of how to build and use an &lt;code&gt;overlay&lt;/code&gt; network with a service in swarm mode, see the Docker Labs tutorial on &lt;a href=&quot;https://github.com/docker/labs/blob/master/networking/A3-overlay-networking/&quot;&gt;Overlay networking and service discovery&lt;/a&gt;.</source>
          <target state="translated">有关如何以群集模式构建和使用带有服务的 &lt;code&gt;overlay&lt;/code&gt; 网络的有效示例，请参阅《&lt;a href=&quot;https://github.com/docker/labs/blob/master/networking/A3-overlay-networking/&quot;&gt;覆盖网络和服务发现》&lt;/a&gt;的Docker Labs教程。</target>
        </trans-unit>
        <trans-unit id="6ae0bd335974b03456db03f08f9550d51014c762" translate="yes" xml:space="preserve">
          <source>For additional information on working with labels, see &lt;a href=&quot;https://docs.docker.com/config&quot;&gt;&lt;em&gt;Labels - custom metadata in Docker&lt;/em&gt;&lt;/a&gt; in the Docker User Guide.</source>
          <target state="translated">有关使用标签的更多信息，请参阅《 Docker用户指南》中的&amp;ldquo; &lt;a href=&quot;https://docs.docker.com/config&quot;&gt;&lt;em&gt;标签-Docker&lt;/em&gt;&lt;/a&gt;中的&lt;em&gt;自定义元数据&lt;/em&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="164e065852bf7edd5e3976e6f1e47ad1a0fa77b8" translate="yes" xml:space="preserve">
          <source>For all other images, the image name as displayed on Docker Hub, prefixed by &lt;code&gt;docker.io&lt;/code&gt;.</source>
          <target state="translated">对于所有其他映像，该映像名称在Docker Hub上显示，并以 &lt;code&gt;docker.io&lt;/code&gt; 为前缀。</target>
        </trans-unit>
        <trans-unit id="698142429b77e3b1b97abb32d5eb1fc84336ce60" translate="yes" xml:space="preserve">
          <source>For an example of using the &lt;code&gt;-f&lt;/code&gt; option at the command line, suppose you are running the &lt;a href=&quot;../../rails/index&quot;&gt;Compose Rails sample&lt;/a&gt;, and have a &lt;code&gt;docker-compose.yml&lt;/code&gt; file in a directory called &lt;code&gt;sandbox/rails&lt;/code&gt;. You can use a command like &lt;a href=&quot;../pull/index&quot;&gt;docker-compose pull&lt;/a&gt; to get the postgres image for the &lt;code&gt;db&lt;/code&gt; service from anywhere by using the &lt;code&gt;-f&lt;/code&gt; flag as follows: &lt;code&gt;docker-compose -f ~/sandbox/rails/docker-compose.yml pull db&lt;/code&gt;</source>
          <target state="translated">对于在命令行上使用 &lt;code&gt;-f&lt;/code&gt; 选项的示例，假设您正在运行&lt;a href=&quot;../../rails/index&quot;&gt;Compose Rails示例&lt;/a&gt;，并且在名为 &lt;code&gt;sandbox/rails&lt;/code&gt; 的目录中有一个 &lt;code&gt;docker-compose.yml&lt;/code&gt; 文件。您可以使用 &lt;code&gt;-f&lt;/code&gt; 标志，使用 &lt;code&gt;docker-compose -f ~/sandbox/rails/docker-compose.yml pull db&lt;/code&gt; &lt;a href=&quot;../pull/index&quot;&gt;-compose pull之&lt;/a&gt;类的命令从任何地方获取 &lt;code&gt;db&lt;/code&gt; 服务的postgres图像，如下所示：docker-compose -f〜/ sandbox / rails / docker-compose.yml pull db</target>
        </trans-unit>
        <trans-unit id="224d353aeaa4adc0517d4f2094e35f8b314e8fc9" translate="yes" xml:space="preserve">
          <source>For an in-depth look at how it works under the hood, see the networking concepts lab on the &lt;a href=&quot;https://github.com/docker/labs/blob/master/networking/concepts/06-overlay-networks/&quot;&gt;Overlay Driver Network Architecture&lt;/a&gt;.</source>
          <target state="translated">有关深入了解其工作原理的信息，请参见&amp;ldquo; &lt;a href=&quot;https://github.com/docker/labs/blob/master/networking/concepts/06-overlay-networks/&quot;&gt;覆盖驱动程序网络体系结构&amp;rdquo;&lt;/a&gt;上的网络概念实验室。</target>
        </trans-unit>
        <trans-unit id="5431c67341cea28238f50ac412688afe75c321ba" translate="yes" xml:space="preserve">
          <source>For an overview of swarm mode, see &lt;a href=&quot;../key-concepts/index&quot;&gt;Swarm mode key concepts&lt;/a&gt;. For an overview of how services work, see &lt;a href=&quot;../how-swarm-mode-works/services/index&quot;&gt;How services work&lt;/a&gt;.</source>
          <target state="translated">有关群集模式的概述，请参见&amp;ldquo; &lt;a href=&quot;../key-concepts/index&quot;&gt;群集模式关键概念&amp;rdquo;&lt;/a&gt;。对于服务如何工作的概述，请参阅&lt;a href=&quot;../how-swarm-mode-works/services/index&quot;&gt;如何服务工作&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5086222cf1ea0d4859abd639635eb2ac4e721eb0" translate="yes" xml:space="preserve">
          <source>For any Linux template, you may use the shorter name composed only of the name and version, as shown below.</source>
          <target state="translated">对于任何Linux模板,你可以使用仅由名称和版本组成的较短名称,如下所示。</target>
        </trans-unit>
        <trans-unit id="09bb43634e55c77ed5d3514650cc2104c13ce495" translate="yes" xml:space="preserve">
          <source>For best performance and portability, you should avoid writing important data directly into a container&amp;rsquo;s writable layer, instead using data volumes or bind mounts. This principle also applies to services.</source>
          <target state="translated">为了获得最佳性能和可移植性，应避免将重要数据直接写入容器的可写层，而不要使用数据卷或绑定挂载。此原则也适用于服务。</target>
        </trans-unit>
        <trans-unit id="f99f0d1d6beb7ad4c1c3cc69c002d37520afd0e8" translate="yes" xml:space="preserve">
          <source>For best performance the metadata should be on a different spindle than the data, or even better on an SSD.</source>
          <target state="translated">为了获得最佳性能,元数据应该放在与数据不同的主轴上,甚至最好放在SSD上。</target>
        </trans-unit>
        <trans-unit id="d7ee7b77d4a0882f4ac1e7f7c9672ec1fbda8947" translate="yes" xml:space="preserve">
          <source>For client authentication, create a client key and certificate signing request:</source>
          <target state="translated">对于客户端认证,创建客户端密钥和证书签署请求。</target>
        </trans-unit>
        <trans-unit id="4ff88ff5c7d8c60731ee07fbca64ee8ce3a62b02" translate="yes" xml:space="preserve">
          <source>For commands that can potentially hijack the HTTP connection (&lt;code&gt;HTTP Upgrade&lt;/code&gt;), such as &lt;code&gt;exec&lt;/code&gt;, the authorization plugin is only called for the initial HTTP requests. Once the plugin approves the command, authorization is not applied to the rest of the flow. Specifically, the streaming data is not passed to the authorization plugins. For commands that return chunked HTTP response, such as &lt;code&gt;logs&lt;/code&gt; and &lt;code&gt;events&lt;/code&gt;, only the HTTP request is sent to the authorization plugins.</source>
          <target state="translated">对于可能会劫持HTTP连接（ &lt;code&gt;HTTP Upgrade&lt;/code&gt; ）的命令，例如 &lt;code&gt;exec&lt;/code&gt; ，仅针对初始HTTP请求调用授权插件。插件批准命令后，授权将不会应用于其余流程。具体来说，流数据不会传递到授权插件。对于返回分块HTTP响应的命令（例如 &lt;code&gt;logs&lt;/code&gt; 和 &lt;code&gt;events&lt;/code&gt; ，仅将HTTP请求发送到授权插件。</target>
        </trans-unit>
        <trans-unit id="34abd2d11ef46ad10e7a3110f03bd013efc9c7a8" translate="yes" xml:space="preserve">
          <source>For convenience, &lt;code&gt;docker-machine&lt;/code&gt; uses sensible defaults for choosing settings such as the image that the server is based on, but you override the defaults using the respective flags, such as &lt;code&gt;--digitalocean-image&lt;/code&gt;. This is useful if, for example, you want to create a cloud server with a lot of memory and CPUs, rather than the default behavior of creating smaller servers.</source>
          <target state="translated">为方便起见， &lt;code&gt;docker-machine&lt;/code&gt; 使用合理的默认值来选择设置，例如服务器所基于的图像，但是您使用相应的标志（例如 &lt;code&gt;--digitalocean-image&lt;/code&gt; )覆盖了默认值。例如，如果要创建具有大量内存和CPU的云服务器，而不是创建较小服务器的默认行为，则此功能很有用。</target>
        </trans-unit>
        <trans-unit id="286a0c806fd0ce791b00259f7039fdf6c314a01f" translate="yes" xml:space="preserve">
          <source>For detailed information about using secrets, refer to &lt;a href=&quot;../../../swarm/secrets/index&quot;&gt;manage sensitive data with Docker secrets&lt;/a&gt;.</source>
          <target state="translated">有关使用机密的详细信息，请参阅&lt;a href=&quot;../../../swarm/secrets/index&quot;&gt;使用Docker机密管理敏感数据&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="694a779b492c9ba00e460b86a750a2409471112a" translate="yes" xml:space="preserve">
          <source>For detailed information on using &lt;code&gt;ARG&lt;/code&gt; and &lt;code&gt;ENV&lt;/code&gt; instructions, see the &lt;a href=&quot;../../builder/index&quot;&gt;Dockerfile reference&lt;/a&gt;.</source>
          <target state="translated">有关使用 &lt;code&gt;ARG&lt;/code&gt; 和 &lt;code&gt;ENV&lt;/code&gt; 指令的详细信息，请参阅&lt;a href=&quot;../../builder/index&quot;&gt;Dockerfile参考&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3b7bb720cd93e7fcd6976fa80a2516f2894912a1" translate="yes" xml:space="preserve">
          <source>For details about how to use this feature, as well as limitations, see &lt;a href=&quot;../../../security/userns-remap/index&quot;&gt;Isolate containers with a user namespace&lt;/a&gt;.</source>
          <target state="translated">有关如何使用此功能以及限制的详细信息，请参阅&lt;a href=&quot;../../../security/userns-remap/index&quot;&gt;使用用户名称空间隔离容器&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8d4504d3de98560555b28bad9d66cc9b3ce944b6" translate="yes" xml:space="preserve">
          <source>For details on using production-oriented features, see &lt;a href=&quot;production/index&quot;&gt;compose in production&lt;/a&gt; in this documentation.</source>
          <target state="translated">有关使用面向生产的功能的详细信息，请参阅本文档中的&lt;a href=&quot;production/index&quot;&gt;compose&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c8c68aee3378ec50eb6e45cf815b4943b0b39db5" translate="yes" xml:space="preserve">
          <source>For details on versions and how to upgrade, see &lt;a href=&quot;index#versioning&quot;&gt;Versioning&lt;/a&gt; and &lt;a href=&quot;index#upgrading&quot;&gt;Upgrading&lt;/a&gt;.</source>
          <target state="translated">有关版本以及如何升级的详细信息，请参见&amp;ldquo; &lt;a href=&quot;index#versioning&quot;&gt;版本控制&lt;/a&gt;和&lt;a href=&quot;index#upgrading&quot;&gt;升级&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="aee748905971e1f678b317265cdc67e48045bc8f" translate="yes" xml:space="preserve">
          <source>For each machine you create, the Docker host address is the IP address of the Linux VM. This address is assigned by the &lt;code&gt;docker-machine create&lt;/code&gt; subcommand. You use the &lt;code&gt;docker-machine ls&lt;/code&gt; command to list the machines you have created. The &lt;code&gt;docker-machine ip &amp;lt;machine-name&amp;gt;&lt;/code&gt; command returns a specific host&amp;rsquo;s IP address.</source>
          <target state="translated">对于您创建的每台机器，Docker主机地址都是Linux VM的IP地址。该地址由 &lt;code&gt;docker-machine create&lt;/code&gt; 子命令分配。您使用 &lt;code&gt;docker-machine ls&lt;/code&gt; 命令列出您创建的机器。该 &lt;code&gt;docker-machine ip &amp;lt;machine-name&amp;gt;&lt;/code&gt; 命令返回特定主机的IP地址。</target>
        </trans-unit>
        <trans-unit id="9459d6465fc0bc6c90c4ecd0a5c4ade3ca2315d2" translate="yes" xml:space="preserve">
          <source>For each replica of the service, the engine requests a volume named &amp;ldquo;my-volume&amp;rdquo; from the default (&amp;ldquo;local&amp;rdquo;) volume driver where the task is deployed. If the volume does not exist, the engine creates a new volume and applies the &amp;ldquo;color&amp;rdquo; and &amp;ldquo;shape&amp;rdquo; labels.</source>
          <target state="translated">对于服务的每个副本，引擎从部署任务的默认（&amp;ldquo;本地&amp;rdquo;）卷驱动程序请求一个名为&amp;ldquo; my-volume&amp;rdquo;的卷。如果该体积不存在，则引擎将创建一个新体积并应用&amp;ldquo;颜色&amp;rdquo;和&amp;ldquo;形状&amp;rdquo;标签。</target>
        </trans-unit>
        <trans-unit id="6e99fb7a7d1989586946c5082ec1ad05e014504f" translate="yes" xml:space="preserve">
          <source>For easy reference, the following list of environment variables are supported by the &lt;code&gt;docker&lt;/code&gt; command line:</source>
          <target state="translated">为便于参考， &lt;code&gt;docker&lt;/code&gt; 命令行支持以下环境变量列表：</target>
        </trans-unit>
        <trans-unit id="154414a87ee244ef3429961a073b1623eb7c45b7" translate="yes" xml:space="preserve">
          <source>For example to leave the swarm on a worker node:</source>
          <target state="translated">例如要把蜂群留在一个工人节点上。</target>
        </trans-unit>
        <trans-unit id="188857146aed5513efbd5f9711e7ae4b5ab3b893" translate="yes" xml:space="preserve">
          <source>For example use &lt;code&gt;[&quot;program&quot;, &quot;arg1&quot;, &quot;arg2&quot;]&lt;/code&gt; not &lt;code&gt;&quot;program arg1 arg2&quot;&lt;/code&gt;. Using the string form causes Docker to run your process using &lt;code&gt;bash&lt;/code&gt; which doesn&amp;rsquo;t handle signals properly. Compose always uses the JSON form, so don&amp;rsquo;t worry if you override the command or entrypoint in your Compose file.</source>
          <target state="translated">例如，使用 &lt;code&gt;[&quot;program&quot;, &quot;arg1&quot;, &quot;arg2&quot;]&lt;/code&gt; 而不是 &lt;code&gt;&quot;program arg1 arg2&quot;&lt;/code&gt; 。使用字符串形式会使Docker使用无法正确处理信号的 &lt;code&gt;bash&lt;/code&gt; 运行您的进程。Compose始终使用JSON格式，因此如果您覆盖Compose文件中的命令或入口点，请不要担心。</target>
        </trans-unit>
        <trans-unit id="fa18ec8ff6a597055736afdbee7a3f7b840a1c4b" translate="yes" xml:space="preserve">
          <source>For example you might add something like this:</source>
          <target state="translated">例如,你可以添加这样的东西。</target>
        </trans-unit>
        <trans-unit id="3735a5efd056df9559b5bf23dc89b47698731804" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;http://localhost/VolumeDriver.List&lt;/code&gt;</source>
          <target state="translated">例如， &lt;code&gt;http://localhost/VolumeDriver.List&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e9410afdbe46f29ed657ee0ba67d7c3831be8bd8" translate="yes" xml:space="preserve">
          <source>For example, a service set up with &lt;code&gt;--update-parallelism 1 --rollback-parallelism 3&lt;/code&gt; will update one task at a time during a normal update, but during a rollback, 3 tasks at a time will get rolled back. These rollback parameters are respected both during automatic rollbacks and for rollbacks initiated manually using &lt;code&gt;--rollback&lt;/code&gt;.</source>
          <target state="translated">例如，使用 &lt;code&gt;--update-parallelism 1 --rollback-parallelism 3&lt;/code&gt; 设置的服务将在正常更新期间一次更新一个任务，但是在回滚期间，一次将更新3个任务。这些回滚参数在自动回滚期间以及使用 &lt;code&gt;--rollback&lt;/code&gt; 手动启动的回滚中都受到尊重。</target>
        </trans-unit>
        <trans-unit id="929473a1e11e684957acdb996cfd5c41a1d6f4e7" translate="yes" xml:space="preserve">
          <source>For example, changes to environment variables (which are added after a container is built, but before the container&amp;rsquo;s command is executed) are not updated after restarting.</source>
          <target state="translated">例如，重新启动后不会更新对环境变量的更改（在构建容器之后但在执行容器的命令之前添加）。</target>
        </trans-unit>
        <trans-unit id="1addd6c46201ea5dd56ae7ab185929e68ef8b8f5" translate="yes" xml:space="preserve">
          <source>For example, consider a system with more than three cores. If you start one container &lt;code&gt;{C0}&lt;/code&gt; with &lt;code&gt;-c=512&lt;/code&gt; running one process, and another container &lt;code&gt;{C1}&lt;/code&gt; with &lt;code&gt;-c=1024&lt;/code&gt; running two processes, this can result in the following division of CPU shares:</source>
          <target state="translated">例如，考虑具有三个以上内核的系统。如果您使用 &lt;code&gt;-c=512&lt;/code&gt; 运行一个进程来启动一个容器 &lt;code&gt;{C0}&lt;/code&gt; ，而使用 &lt;code&gt;-c=1024&lt;/code&gt; 运行两个进程来启动另一个容器 &lt;code&gt;{C1}&lt;/code&gt; ，则可能导致以下CPU份额划分：</target>
        </trans-unit>
        <trans-unit id="b2f3cbb7504b8388489227a083e3a11eb5b07b7b" translate="yes" xml:space="preserve">
          <source>For example, consider building the following Dockerfile using &lt;code&gt;--build-arg HTTP_PROXY=http://user:pass@proxy.lon.example.com&lt;/code&gt;</source>
          <target state="translated">例如，考虑使用 &lt;code&gt;--build-arg HTTP_PROXY=http://user:pass@proxy.lon.example.com&lt;/code&gt; 构建以下Dockerfile。</target>
        </trans-unit>
        <trans-unit id="43683586fd5aff33c8a74fbd57d5c4419f621a16" translate="yes" xml:space="preserve">
          <source>For example, consider these two Dockerfile:</source>
          <target state="translated">例如,考虑这两个Dockerfile。</target>
        </trans-unit>
        <trans-unit id="f761d448faf51e489efbfa56295f1ebeb5b7f92c" translate="yes" xml:space="preserve">
          <source>For example, consider this command line:</source>
          <target state="translated">例如,考虑这个命令行。</target>
        </trans-unit>
        <trans-unit id="81991816c7fa2f977dec203299f1f126cac01a7b" translate="yes" xml:space="preserve">
          <source>For example, consider three containers, one has a cpu-share of 1024 and two others have a cpu-share setting of 512. When processes in all three containers attempt to use 100% of CPU, the first container would receive 50% of the total CPU time. If you add a fourth container with a cpu-share of 1024, the first container only gets 33% of the CPU. The remaining containers receive 16.5%, 16.5% and 33% of the CPU.</source>
          <target state="translated">例如,考虑三个容器,一个容器的cpu-share为1024,另外两个容器的cpu-share设置为512。当三个容器中的进程都试图使用100%的CPU时,第一个容器将获得50%的CPU总时间。如果添加第四个cpu-share为1024的容器,第一个容器只能获得33%的CPU。其余的容器分别获得16.5%、16.5%和33%的CPU。</target>
        </trans-unit>
        <trans-unit id="ccf7c444c5d5fb56703ebae64f23ac3f420d9384" translate="yes" xml:space="preserve">
          <source>For example, given the following secret:</source>
          <target state="translated">例如,给定以下秘密。</target>
        </trans-unit>
        <trans-unit id="8ed8a037ceec4b25d45ed1622fee4828caf43586" translate="yes" xml:space="preserve">
          <source>For example, given the following service;</source>
          <target state="translated">例如,给定以下服务:</target>
        </trans-unit>
        <trans-unit id="93cc8290a129b890f3a56506769758068c2fbc7a" translate="yes" xml:space="preserve">
          <source>For example, if the default &lt;code&gt;10.0.0.0/8&lt;/code&gt; range conflicts with already allocated address space in your network, then it is desirable to ensure that networks use a different range without requiring Swarm users to specify each subnet with the &lt;code&gt;--subnet&lt;/code&gt; command.</source>
          <target state="translated">例如，如果默认的 &lt;code&gt;10.0.0.0/8&lt;/code&gt; 范围与网络中已分配的地址空间冲突，则最好确保网络使用不同的范围，而无需Swarm用户使用 &lt;code&gt;--subnet&lt;/code&gt; 命令指定每个子网。</target>
        </trans-unit>
        <trans-unit id="67f4e51d0c6823f5aedc08a121fe12672dd94886" translate="yes" xml:space="preserve">
          <source>For example, if the machine uses Ubuntu as the underlying operating system, it runs a command similar to &lt;code&gt;sudo apt-get upgrade docker-engine&lt;/code&gt;, because Machine expects Ubuntu machines it manages to use this package. As another example, if the machine uses boot2docker for its OS, this command downloads the latest boot2docker ISO and replace the machine&amp;rsquo;s existing ISO with the latest.</source>
          <target state="translated">例如，如果机器使用Ubuntu作为基础操作系统，则它运行类似于 &lt;code&gt;sudo apt-get upgrade docker-engine&lt;/code&gt; 的命令，因为Machine希望它设法使用此软件包的Ubuntu机器。再举一个例子，如果机器使用boot2docker作为其OS，则此命令将下载最新的boot2docker ISO并将机器的现有ISO替换为最新的ISO。</target>
        </trans-unit>
        <trans-unit id="9ce66046739189038b749374187942548cab0c80" translate="yes" xml:space="preserve">
          <source>For example, if the original service defines &lt;code&gt;image: webapp&lt;/code&gt; and the local service defines &lt;code&gt;build: .&lt;/code&gt; then the resulting service has a &lt;code&gt;build: .&lt;/code&gt; and no &lt;code&gt;image&lt;/code&gt; option.</source>
          <target state="translated">例如，如果原始服务定义了 &lt;code&gt;image: webapp&lt;/code&gt; ，而本地服务定义了 &lt;code&gt;build: .&lt;/code&gt; ：。那么生成的服务具有以下 &lt;code&gt;build: .&lt;/code&gt; 并且没有 &lt;code&gt;image&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="99ffaa981af0eedeb459ed96a813a331a5ce2ad6" translate="yes" xml:space="preserve">
          <source>For example, if you follow along with the &lt;a href=&quot;../../../engine/swarm/swarm-tutorial/index&quot;&gt;Swarm mode tutorial&lt;/a&gt; which asks you to create &lt;a href=&quot;../../../engine/swarm/swarm-tutorial/index#three-networked-host-machines&quot;&gt;three networked host machines&lt;/a&gt;, you can create these swarm nodes: &lt;code&gt;manager1&lt;/code&gt;, &lt;code&gt;worker1&lt;/code&gt;, &lt;code&gt;worker2&lt;/code&gt;.</source>
          <target state="translated">例如，如果跟随&lt;a href=&quot;../../../engine/swarm/swarm-tutorial/index&quot;&gt;Swarm模式教程&lt;/a&gt;，该教程要求您创建&lt;a href=&quot;../../../engine/swarm/swarm-tutorial/index#three-networked-host-machines&quot;&gt;三台联网的主机&lt;/a&gt;，则可以创建以下swarm节点： &lt;code&gt;manager1&lt;/code&gt; ， &lt;code&gt;worker1&lt;/code&gt; 和 &lt;code&gt;worker2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3fd5c1d51615687547df73c7d631a0f825cbaa1b" translate="yes" xml:space="preserve">
          <source>For example, if you named your directory &lt;code&gt;my_wordpress&lt;/code&gt;:</source>
          <target state="translated">例如，如果您将目录命名为 &lt;code&gt;my_wordpress&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="cacd1f4811295ea25a505e6c624c7745bd5b0a2b" translate="yes" xml:space="preserve">
          <source>For example, if you started a container with this command:</source>
          <target state="translated">例如,如果你用这个命令启动一个容器。</target>
        </trans-unit>
        <trans-unit id="4f3baa4c96da7d1ddf4e2dda43da2a91693162ab" translate="yes" xml:space="preserve">
          <source>For example, if your image is a reusable Python application builder, it will require application source code to be added in a particular directory, and it might require a build script to be called &lt;em&gt;after&lt;/em&gt; that. You can&amp;rsquo;t just call &lt;code&gt;ADD&lt;/code&gt; and &lt;code&gt;RUN&lt;/code&gt; now, because you don&amp;rsquo;t yet have access to the application source code, and it will be different for each application build. You could simply provide application developers with a boilerplate &lt;code&gt;Dockerfile&lt;/code&gt; to copy-paste into their application, but that is inefficient, error-prone and difficult to update because it mixes with application-specific code.</source>
          <target state="translated">例如，如果您的图像是可重用的Python应用程序构建器，则将需要在特定目录中添加应用程序源代码，并且&lt;em&gt;此后&lt;/em&gt;可能需要调用构建脚本。您不能立即调用 &lt;code&gt;ADD&lt;/code&gt; 和 &lt;code&gt;RUN&lt;/code&gt; ，因为您还没有访问应用程序源代码的权限，并且每个应用程序构建的源代码都不同。您可以简单地为应用程序开发人员提供一个样板 &lt;code&gt;Dockerfile&lt;/code&gt; ,以将其复制粘贴到其应用程序中，但这效率低下，容易出错且难以更新，因为它与特定于应用程序的代码混合在一起。</target>
        </trans-unit>
        <trans-unit id="90a78c6a0dbbdde9d0e73df87b9e7224f895a446" translate="yes" xml:space="preserve">
          <source>For example, imagine you want to load balance between three instances of an HTTP listener. The diagram below shows an HTTP listener service with three replicas. Each of the three instances of the listener is a task in the swarm.</source>
          <target state="translated">例如,想象你想在一个HTTP监听器的三个实例之间进行负载平衡。下图显示了一个具有三个副本的HTTP监听器服务。该监听器的三个实例中的每一个都是蜂群中的一个任务。</target>
        </trans-unit>
        <trans-unit id="f4dbfcff4a6bfe3bc8857e222af481a54046eb19" translate="yes" xml:space="preserve">
          <source>For example, imagine you want to transfer your local directory &lt;code&gt;/Users/&amp;lt;username&amp;gt;/webapp&lt;/code&gt; to a remote machine and bind mount it into a container on the remote host. If the remote user is &lt;code&gt;ubuntu&lt;/code&gt;, use a command like this:</source>
          <target state="translated">例如，假设您要将本地目录 &lt;code&gt;/Users/&amp;lt;username&amp;gt;/webapp&lt;/code&gt; 转移到远程计算机，并将其绑定安装到远程主机上的容器中。如果远程用户是 &lt;code&gt;ubuntu&lt;/code&gt; ，请使用如下命令：</target>
        </trans-unit>
        <trans-unit id="9caa53b34eb8308759c049e6a67f51ff797e27f2" translate="yes" xml:space="preserve">
          <source>For example, in a swarm with &lt;em&gt;5 nodes&lt;/em&gt;, if you lose &lt;em&gt;3 nodes&lt;/em&gt;, you don&amp;rsquo;t have a quorum. Therefore you can&amp;rsquo;t add or remove nodes until you recover one of the unavailable manager nodes or recover the swarm with disaster recovery commands. See &lt;a href=&quot;#recover-from-disaster&quot;&gt;Recover from disaster&lt;/a&gt;.</source>
          <target state="translated">例如，在具有&lt;em&gt;5个节点&lt;/em&gt;的群集中，如果丢失&lt;em&gt;3个节点&lt;/em&gt;，则没有仲裁。因此，在恢复不可用的管理器节点之一或使用灾难恢复命令恢复群集之前，您无法添加或删除节点。请参阅&lt;a href=&quot;#recover-from-disaster&quot;&gt;从灾难中恢复&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0296843ec1d5473f3328a00514f701c45812e695" translate="yes" xml:space="preserve">
          <source>For example, let&amp;rsquo;s say that you wanted to run a single Notary server instance:</source>
          <target state="translated">例如，假设您要运行一个公证服务器实例：</target>
        </trans-unit>
        <trans-unit id="a97c89090dfbc9c2483eeb05a62998440629aefd" translate="yes" xml:space="preserve">
          <source>For example, let&amp;rsquo;s use &lt;code&gt;-o&lt;/code&gt; or &lt;code&gt;--opt&lt;/code&gt; options to specify an IP address binding when publishing ports:</source>
          <target state="translated">例如，让我们在发布端口时使用 &lt;code&gt;-o&lt;/code&gt; 或 &lt;code&gt;--opt&lt;/code&gt; 选项来指定IP地址绑定：</target>
        </trans-unit>
        <trans-unit id="12b205b313c8275a5b70e2be24a07f291d7fc3a1" translate="yes" xml:space="preserve">
          <source>For example, run this command to use a directory called &lt;code&gt;docker&lt;/code&gt; in the branch &lt;code&gt;container&lt;/code&gt;:</source>
          <target state="translated">例如，运行以下命令以在分支 &lt;code&gt;container&lt;/code&gt; 使用名为 &lt;code&gt;docker&lt;/code&gt; 的目录：</target>
        </trans-unit>
        <trans-unit id="17873e64711d815edf10b0b4d913508a569f8359" translate="yes" xml:space="preserve">
          <source>For example, running &lt;code&gt;docker run -d&lt;/code&gt; will set the value to &lt;code&gt;true&lt;/code&gt;, so your container &lt;strong&gt;will&lt;/strong&gt; run in &amp;ldquo;detached&amp;rdquo; mode, in the background.</source>
          <target state="translated">例如，运行 &lt;code&gt;docker run -d&lt;/code&gt; 会将值设置为 &lt;code&gt;true&lt;/code&gt; ，因此您的容器&lt;strong&gt;将&lt;/strong&gt;在后台以&amp;ldquo;分离&amp;rdquo;模式运行。</target>
        </trans-unit>
        <trans-unit id="297eaf0cc9729550e3b8b00ac959910e971a9c91" translate="yes" xml:space="preserve">
          <source>For example, suppose you have this &lt;code&gt;docker-compose.yml&lt;/code&gt; file from the &lt;a href=&quot;../../rails/index&quot;&gt;Quickstart: Compose and Rails&lt;/a&gt; sample.</source>
          <target state="translated">例如，假设您具有&lt;a href=&quot;../../rails/index&quot;&gt;Quickstart：Compose and Rails&lt;/a&gt;示例中 &lt;code&gt;docker-compose.yml&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="d6185be54f486cceec56c79779506f262c4df4b5" translate="yes" xml:space="preserve">
          <source>For example, suppose your app is in a directory called &lt;code&gt;myapp&lt;/code&gt;, and your &lt;code&gt;docker-compose.yml&lt;/code&gt; looks like this:</source>
          <target state="translated">例如，假设您的应用程序位于名为 &lt;code&gt;myapp&lt;/code&gt; 的目录中，并且 &lt;code&gt;docker-compose.yml&lt;/code&gt; 如下所示：</target>
        </trans-unit>
        <trans-unit id="0f36b49dbbf1a5b76e12f4f660c13eeb2bdd76ee" translate="yes" xml:space="preserve">
          <source>For example, the &lt;a href=&quot;../envvars/index#compose_file&quot;&gt;COMPOSE_FILE environment variable&lt;/a&gt; relates to the &lt;code&gt;-f&lt;/code&gt; flag, and &lt;a href=&quot;../envvars/index#compose_project_name&quot;&gt;COMPOSE_PROJECT_NAME environment variable&lt;/a&gt; relates to the &lt;code&gt;-p&lt;/code&gt; flag.</source>
          <target state="translated">例如，&lt;a href=&quot;../envvars/index#compose_file&quot;&gt;COMPOSE_FILE环境变量&lt;/a&gt;与 &lt;code&gt;-f&lt;/code&gt; 标志有关，&lt;a href=&quot;../envvars/index#compose_project_name&quot;&gt;COMPOSE_PROJECT_NAME环境变量&lt;/a&gt;与 &lt;code&gt;-p&lt;/code&gt; 标志有关。</target>
        </trans-unit>
        <trans-unit id="236773d8dda420fa66146304077c9e4dda4417b6" translate="yes" xml:space="preserve">
          <source>For example, the &lt;code&gt;flocker&lt;/code&gt; plugin might create a UNIX socket at &lt;code&gt;/run/docker/plugins/flocker.sock&lt;/code&gt;.</source>
          <target state="translated">例如， &lt;code&gt;flocker&lt;/code&gt; 插件可能会产生在UNIX插座 &lt;code&gt;/run/docker/plugins/flocker.sock&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b4e3b6190b64b0e1f69a644d1dc881d630f60683" translate="yes" xml:space="preserve">
          <source>For example, the configuration above specifies the default password alias to be &lt;code&gt;passwordalias1&lt;/code&gt;.</source>
          <target state="translated">例如，上面的配置将默认密码别名指定为 &lt;code&gt;passwordalias1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cac30fc9c71aba134ae70a8a8bd8074aa2fe7aa5" translate="yes" xml:space="preserve">
          <source>For example, the following command publishes port 80 in the nginx container to port 8080 for any node in the swarm:</source>
          <target state="translated">例如,下面的命令将nginx容器中的80端口发布到群中任何节点的8080端口。</target>
        </trans-unit>
        <trans-unit id="9ae86335c1bfeb27534084781c305b2b21baa1c1" translate="yes" xml:space="preserve">
          <source>For example, the following creates a &lt;code&gt;tmpfs&lt;/code&gt; volume called &lt;code&gt;foo&lt;/code&gt; with a size of 100 megabyte and &lt;code&gt;uid&lt;/code&gt; of 1000.</source>
          <target state="translated">例如，以下代码创建一个名为 &lt;code&gt;foo&lt;/code&gt; 的 &lt;code&gt;tmpfs&lt;/code&gt; 卷，其大小为100兆字节， &lt;code&gt;uid&lt;/code&gt; 为1000。</target>
        </trans-unit>
        <trans-unit id="ad4d0c24124b21bd2a1d07a5093bd86963e3a363" translate="yes" xml:space="preserve">
          <source>For example, the following limits tasks for the redis service to nodes where the node type label equals queue:</source>
          <target state="translated">例如,以下将redis服务的任务限制在节点类型标签等于队列的节点。</target>
        </trans-unit>
        <trans-unit id="9c87de7737e213ff0ae2b5afab0c3c574ca391e0" translate="yes" xml:space="preserve">
          <source>For example, the following will start nginx with its default content, listening on port 80:</source>
          <target state="translated">例如,下面将启动nginx的默认内容,监听端口为80。</target>
        </trans-unit>
        <trans-unit id="3dab00e0e39b837859de1b519f5dc22305231205" translate="yes" xml:space="preserve">
          <source>For example, to add a &lt;code&gt;type&lt;/code&gt; label to identify nodes where the scheduler should deploy message queue service tasks:</source>
          <target state="translated">例如，添加 &lt;code&gt;type&lt;/code&gt; 标签以标识调度程序应在其中部署消息队列服务任务的节点：</target>
        </trans-unit>
        <trans-unit id="deb6b1dc72c1c6cf36c3bea5d09aab1e5584b6f7" translate="yes" xml:space="preserve">
          <source>For example, to change a manager node to &lt;code&gt;Drain&lt;/code&gt; availability:</source>
          <target state="translated">例如，要将管理器节点更改为 &lt;code&gt;Drain&lt;/code&gt; 可用性：</target>
        </trans-unit>
        <trans-unit id="c07e894b09764511a69589296e6c36e7c5070d46" translate="yes" xml:space="preserve">
          <source>For example, to check every five minutes or so that a web-server is able to serve the site&amp;rsquo;s main page within three seconds:</source>
          <target state="translated">例如，要每五分钟检查一次，以便网络服务器能够在三秒钟内为站点的主页提供服务：</target>
        </trans-unit>
        <trans-unit id="dbaac476e081b5f78a913c84fad2d379db534393" translate="yes" xml:space="preserve">
          <source>For example, to connect using OpenSSL:</source>
          <target state="translated">例如,使用OpenSSL进行连接。</target>
        </trans-unit>
        <trans-unit id="ca16e922069fc63da9a1fde9da1dbd1fe6b86f91" translate="yes" xml:space="preserve">
          <source>For example, to create an instance from the latest Ubuntu 16 LTS image, specify &lt;code&gt;https://www.googleapis.com/compute/v1/projects/ubuntu-os-cloud/global/images/family/ubuntu-1604-lts&lt;/code&gt;.</source>
          <target state="translated">例如，要从最新的Ubuntu 16 LTS映像创建实例，请指定 &lt;code&gt;https://www.googleapis.com/compute/v1/projects/ubuntu-os-cloud/global/images/family/ubuntu-1604-lts&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dd7cd8af0ea65c62a417b6317fa1839fc5be13ac" translate="yes" xml:space="preserve">
          <source>For example, to list all images in the &amp;ldquo;java&amp;rdquo; repository, run this command :</source>
          <target state="translated">例如，要列出&amp;ldquo; java&amp;rdquo;存储库中的所有图像，请运行以下命令：</target>
        </trans-unit>
        <trans-unit id="f4db7861ce1d3fb8918f7977c719cb59be568c67" translate="yes" xml:space="preserve">
          <source>For example, to use &lt;code&gt;wait-for-it.sh&lt;/code&gt; or &lt;code&gt;wait-for&lt;/code&gt; to wrap your service&amp;rsquo;s command:</source>
          <target state="translated">例如，使用 &lt;code&gt;wait-for-it.sh&lt;/code&gt; 或 &lt;code&gt;wait-for&lt;/code&gt; 包装服务的命令：</target>
        </trans-unit>
        <trans-unit id="d2623db0d0e2d09f8a17269bbb968dea5e914431" translate="yes" xml:space="preserve">
          <source>For example, when a container exits, its associated thin device is removed. If that device has leaked into some other mount namespace and can&amp;rsquo;t be removed, the container exit still succeeds and this option causes the system to schedule the device for deferred removal. It does not wait in a loop trying to remove a busy device.</source>
          <target state="translated">例如，当容器退出时，其关联的瘦设备将被移除。如果该设备泄漏到其他挂载名称空间中并且无法删除，则容器退出仍然成功，并且此选项导致系统安排该设备进行延迟删除。它不会在循环中尝试删除忙碌的设备。</target>
        </trans-unit>
        <trans-unit id="20609fc6f521d91e7d34b7cc3171302ab5bea485" translate="yes" xml:space="preserve">
          <source>For example, when running this command on Mac 10.13.2, place the completion script in &lt;code&gt;/usr/local/etc/bash_completion.d/&lt;/code&gt;.</source>
          <target state="translated">例如，在Mac 10.13.2上运行此命令时，请将完成脚本放在 &lt;code&gt;/usr/local/etc/bash_completion.d/&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="7e36a0467a1f46422bc62de5d3f37912a4051ced" translate="yes" xml:space="preserve">
          <source>For example, with DCT enabled a &lt;code&gt;docker pull someimage:latest&lt;/code&gt; only succeeds if &lt;code&gt;someimage:latest&lt;/code&gt; is signed. However, an operation with an explicit content hash always succeeds as long as the hash exists:</source>
          <target state="translated">例如，启用DCT后，仅当 &lt;code&gt;someimage:latest&lt;/code&gt; 已签名时，docker &lt;code&gt;docker pull someimage:latest&lt;/code&gt; 才会成功。但是，只要存在哈希，使用显式内容哈希的操作始终会成功：</target>
        </trans-unit>
        <trans-unit id="db0942a188496bc0871a311383cc4e4b29b2fff4" translate="yes" xml:space="preserve">
          <source>For example, you can set:</source>
          <target state="translated">例如,你可以设置。</target>
        </trans-unit>
        <trans-unit id="44379329a386f8515196e574d47d30bdca5373d2" translate="yes" xml:space="preserve">
          <source>For example, you can specify either &lt;code&gt;/foo&lt;/code&gt; or &lt;code&gt;foo&lt;/code&gt; for a &lt;code&gt;host-src&lt;/code&gt; value. If you supply the &lt;code&gt;/foo&lt;/code&gt; value, Docker creates a bind mount. If you supply the &lt;code&gt;foo&lt;/code&gt; specification, Docker creates a named volume.</source>
          <target state="translated">例如，您可以为 &lt;code&gt;host-src&lt;/code&gt; 值指定 &lt;code&gt;/foo&lt;/code&gt; 或 &lt;code&gt;foo&lt;/code&gt; 。如果提供 &lt;code&gt;/foo&lt;/code&gt; 值，则Docker将创建绑定安装。如果提供 &lt;code&gt;foo&lt;/code&gt; 规范，则Docker将创建一个命名卷。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="62884713c46b5d6247319e2bb37008efbf289db1" translate="yes" xml:space="preserve">
          <source>For full Kubernetes Integration</source>
          <target state="translated">对于完整的Kubernetes集成</target>
        </trans-unit>
        <trans-unit id="d5366cba2c8355a098d3bb1b98810ef287dc0d86" translate="yes" xml:space="preserve">
          <source>For full details of the network configuration options available, see the following references:</source>
          <target state="translated">有关可用的网络配置选项的全部细节,请参见以下参考资料。</target>
        </trans-unit>
        <trans-unit id="ea39178cf82e6f8359776ff35ccf95f1466ca5e1" translate="yes" xml:space="preserve">
          <source>For full specific configuration information, see the configuration files for the Notary &lt;a href=&quot;../server-config/index&quot;&gt;server&lt;/a&gt; or &lt;a href=&quot;../signer-config/index&quot;&gt;signer&lt;/a&gt;.</source>
          <target state="translated">有关特定配置的完整信息，请参阅公证&lt;a href=&quot;../server-config/index&quot;&gt;服务器&lt;/a&gt;或&lt;a href=&quot;../signer-config/index&quot;&gt;签名者&lt;/a&gt;的配置文件。</target>
        </trans-unit>
        <trans-unit id="713751e2adddd25f8b0c472c5310ea15ed5e767a" translate="yes" xml:space="preserve">
          <source>For in-depth information about volumes, refer to &lt;a href=&quot;https://docs.docker.com/storage&quot;&gt;manage data in containers&lt;/a&gt;</source>
          <target state="translated">有关卷的深入信息，请参阅&lt;a href=&quot;https://docs.docker.com/storage&quot;&gt;管理容器中的数据&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b28c0f92ae03372b2ccefbf1c96430d92320886e" translate="yes" xml:space="preserve">
          <source>For information about how to create an authorization plugin, see &lt;a href=&quot;../../../extend/plugins_authorization/index&quot;&gt;authorization plugin&lt;/a&gt; section in the Docker extend section of this documentation.</source>
          <target state="translated">有关如何创建授权插件的信息，请参阅本文档&amp;ldquo; Docker扩展&amp;rdquo;部分中的&amp;ldquo; &lt;a href=&quot;../../../extend/plugins_authorization/index&quot;&gt;授权插件&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="76211605a0a0c6ec24d5b566af61764b6f4add38" translate="yes" xml:space="preserve">
          <source>For information about maintaining a quorum and disaster recovery, refer to the &lt;a href=&quot;../admin_guide/index&quot;&gt;Swarm administration guide&lt;/a&gt;.</source>
          <target state="translated">有关维护仲裁和灾难恢复的信息，请参阅《&lt;a href=&quot;../admin_guide/index&quot;&gt;Swarm管理指南》&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="150b94c4964196da1cd7cfaf1b9a970f38966263" translate="yes" xml:space="preserve">
          <source>For information about the legacy plugin system available in Docker Engine 1.12 and earlier, see &lt;a href=&quot;legacy_plugins/index&quot;&gt;Understand legacy Docker Engine plugins&lt;/a&gt;.</source>
          <target state="translated">有关Docker Engine 1.12和更早版本中可用的旧版插件系统的信息，请参阅&lt;a href=&quot;legacy_plugins/index&quot;&gt;了解旧版Docker Engine插件&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="51e4c9ca46c388ac786568ecee3b5d8825b52360" translate="yes" xml:space="preserve">
          <source>For information on connecting a container to a network, see the &lt;a href=&quot;https://docs.docker.com/network&quot;&gt;&amp;ldquo;&lt;em&gt;Docker network overview&lt;/em&gt;&amp;rdquo;&lt;/a&gt;.</source>
          <target state="translated">有关将容器连接到网络的信息，请参阅&lt;a href=&quot;https://docs.docker.com/network&quot;&gt;&amp;ldquo; &lt;em&gt;Docker网络概述&lt;/em&gt; &amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="82d698c77013162ff08eb58d4f59087a71fbaf03" translate="yes" xml:space="preserve">
          <source>For instance, if you wanted to override the storage URL of the Notary server configuration:</source>
          <target state="translated">例如,如果你想覆盖公证服务器配置的存储URL。</target>
        </trans-unit>
        <trans-unit id="abc897209b2f98b7966665fa36a5eddbbc44f66d" translate="yes" xml:space="preserve">
          <source>For instance:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="29602251a011cb230da3e546ff699c26cee82685" translate="yes" xml:space="preserve">
          <source>For interacting with the network stack, instead of using &lt;code&gt;--privileged&lt;/code&gt; they should use &lt;code&gt;--cap-add=NET_ADMIN&lt;/code&gt; to modify the network interfaces.</source>
          <target state="translated">为了与网络堆栈进行 &lt;code&gt;--privileged&lt;/code&gt; ，应该使用 &lt;code&gt;--cap-add=NET_ADMIN&lt;/code&gt; 来修改网络接口，而不是使用--privileged。</target>
        </trans-unit>
        <trans-unit id="8f48e10fad25c7d1d56dfd91b749873d9a11df4a" translate="yes" xml:space="preserve">
          <source>For interactive processes (like a shell), you must use &lt;code&gt;-i -t&lt;/code&gt; together in order to allocate a tty for the container process. &lt;code&gt;-i -t&lt;/code&gt; is often written &lt;code&gt;-it&lt;/code&gt; as you&amp;rsquo;ll see in later examples. Specifying &lt;code&gt;-t&lt;/code&gt; is forbidden when the client is receiving its standard input from a pipe, as in:</source>
          <target state="translated">对于交互式进程（如shell），必须一起使用 &lt;code&gt;-i -t&lt;/code&gt; 才能为容器进程分配tty。 &lt;code&gt;-i -t&lt;/code&gt; 通常写为 &lt;code&gt;-it&lt;/code&gt; ，您将在后面的示例中看到它。当客户端从管道接收其标准输入时，禁止指定 &lt;code&gt;-t&lt;/code&gt; ，如下所示：</target>
        </trans-unit>
        <trans-unit id="19f5fd22c7c5ad54b6fa1edeaffe520af48ab5f3" translate="yes" xml:space="preserve">
          <source>For machines other than &lt;code&gt;default&lt;/code&gt;, and commands other than those listed above, you must always specify the name explicitly as an argument.</source>
          <target state="translated">对于 &lt;code&gt;default&lt;/code&gt; 以外的计算机和上面所列以外的命令，必须始终将名称明确指定为参数。</target>
        </trans-unit>
        <trans-unit id="dd3268db578d58ee0de7ce51652a0f5e6a13f533" translate="yes" xml:space="preserve">
          <source>For master builds and nightly feature releases refer to the description in &lt;a href=&quot;https://github.com/moby/buildkit/blob/master/README/&quot;&gt;the source repository&lt;/a&gt;.</source>
          <target state="translated">有关主版本和每晚发布的功能，请参考&lt;a href=&quot;https://github.com/moby/buildkit/blob/master/README/&quot;&gt;源存储库中&lt;/a&gt;的描述。</target>
        </trans-unit>
        <trans-unit id="c0b8a5e74f32e400ed8611cf5a56c405023c97c2" translate="yes" xml:space="preserve">
          <source>For more detail about swarm managers and administering a swarm, see &lt;a href=&quot;../admin_guide/index&quot;&gt;Administer and maintain a swarm of Docker Engines&lt;/a&gt;.</source>
          <target state="translated">有关集群管理器和管理集群的更多详细信息，请参阅《&lt;a href=&quot;../admin_guide/index&quot;&gt;管理和维护Docker引擎集群》&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="134c4195deaf16fa4afe60d19497958bd97f48c1" translate="yes" xml:space="preserve">
          <source>For more detailed documentation about how to deploy Notary Server, see the &lt;a href=&quot;../../../../notary/running_a_service/index&quot;&gt;instructions to run a Notary service&lt;/a&gt; as well as &lt;a href=&quot;https://github.com/theupdateframework/notary&quot;&gt;the Notary repository&lt;/a&gt; for more information.</source>
          <target state="translated">有关如何部署Notary Server的更多详细文档，请参阅&lt;a href=&quot;../../../../notary/running_a_service/index&quot;&gt;运行Notary服务&lt;/a&gt;的说明以及&lt;a href=&quot;https://github.com/theupdateframework/notary&quot;&gt;Notary存储库&lt;/a&gt;以获取更多信息。</target>
        </trans-unit>
        <trans-unit id="b30c9a2e4a09e6f66ccfb38de04c2abb1c6cd1ca" translate="yes" xml:space="preserve">
          <source>For more detailed information about how to use notary outside of the Docker Content Trust use cases, refer to the Notary CLI documentation &lt;a href=&quot;https://github.com/theupdateframework/notary/blob/master/docs/command_reference/&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">有关如何在Docker Content Trust用例之外使用公证的更多详细信息，请参阅&lt;a href=&quot;https://github.com/theupdateframework/notary/blob/master/docs/command_reference/&quot;&gt;此处&lt;/a&gt;的公证CLI文档</target>
        </trans-unit>
        <trans-unit id="34b0237bd57dcea366952be6342f40204d71828c" translate="yes" xml:space="preserve">
          <source>For more details about image tag resolution, see &lt;a href=&quot;#specify-the-image-version-the-service-should-use&quot;&gt;Specify the image version the service should use&lt;/a&gt;.</source>
          <target state="translated">有关图像标签解析的更多详细信息，请参阅&lt;a href=&quot;#specify-the-image-version-the-service-should-use&quot;&gt;指定服务应使用的图像版本&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0c2220c6d906eac94e4990dfc6192b5a0530d0f6" translate="yes" xml:space="preserve">
          <source>For more information about bind propagation, see the &lt;a href=&quot;https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt&quot;&gt;Linux kernel documentation for shared subtree&lt;/a&gt;.</source>
          <target state="translated">有关绑定传播的更多信息，请参见&lt;a href=&quot;https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt&quot;&gt;Linux内核文档中的共享子树&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="54b72b23989ff742f32784ce9fa32d4045faf424" translate="yes" xml:space="preserve">
          <source>For more information about different Docker Enterprise license types visit https://www.docker.com/licenses</source>
          <target state="translated">有关不同的Docker Enterprise许可证类型的更多信息,请访问https://www.docker.com/licenses。</target>
        </trans-unit>
        <trans-unit id="163d01a43b8e15f4f16909e5fa7ea056432b9d16" translate="yes" xml:space="preserve">
          <source>For more information about images, layers, and the content-addressable store, refer to &lt;a href=&quot;https://docs.docker.com/storage/storagedriver&quot;&gt;understand images, containers, and storage drivers&lt;/a&gt;.</source>
          <target state="translated">有关图像，图层和内容可寻址存储的更多信息，请参阅&lt;a href=&quot;https://docs.docker.com/storage/storagedriver&quot;&gt;了解图像，容器和存储驱动程序&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dca8bfe82f612148bd629c13ee21d41ccbdf4e2f" translate="yes" xml:space="preserve">
          <source>For more information about installing Docker or &lt;code&gt;sudo&lt;/code&gt; configuration, refer to the &lt;a href=&quot;https://docs.docker.com/install/&quot;&gt;installation&lt;/a&gt; instructions for your operating system.</source>
          <target state="translated">有关安装Docker或 &lt;code&gt;sudo&lt;/code&gt; 配置的更多信息，请参阅您操作系统的&lt;a href=&quot;https://docs.docker.com/install/&quot;&gt;安装&lt;/a&gt;说明。</target>
        </trans-unit>
        <trans-unit id="7ed4ff4d7b46567091de3a223f0ee0e2f538d82d" translate="yes" xml:space="preserve">
          <source>For more information about labels, refer to &lt;a href=&quot;https://docs.docker.com/config&quot;&gt;apply custom metadata&lt;/a&gt;.</source>
          <target state="translated">有关标签的更多信息，请参阅&lt;a href=&quot;https://docs.docker.com/config&quot;&gt;应用自定义元数据&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="25e34ad8487594394f5ece7c14ddc89ecb38552d" translate="yes" xml:space="preserve">
          <source>For more information about named volumes, see &lt;a href=&quot;https://docs.docker.com/storage&quot;&gt;Data Volumes&lt;/a&gt;.</source>
          <target state="translated">有关命名卷的更多信息，请参见&lt;a href=&quot;https://docs.docker.com/storage&quot;&gt;数据卷&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="03a45d6fe2bf7af80fd96d02c68acaf012abec50" translate="yes" xml:space="preserve">
          <source>For more information about selecting and configuring logging drivers, refer to &lt;a href=&quot;https://docs.docker.com/config/containers/logging&quot;&gt;Configure logging drivers&lt;/a&gt;.</source>
          <target state="translated">有关选择和配置日志记录驱动程序的更多信息，请参阅&lt;a href=&quot;https://docs.docker.com/config/containers/logging&quot;&gt;配置日志记录驱动程序&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dc8fdcbc11fbf20d689346ce17623c4db599f8cd" translate="yes" xml:space="preserve">
          <source>For more information about selecting and configuring logging drivers, refer to &lt;a href=&quot;https://docs.docker.com/config/containers/logging/configure/&quot;&gt;Configure logging drivers&lt;/a&gt;.</source>
          <target state="translated">有关选择和配置日志记录驱动程序的更多信息，请参阅&lt;a href=&quot;https://docs.docker.com/config/containers/logging/configure/&quot;&gt;配置日志记录驱动程序&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c2b2956e44cdcc786cd2c54702b01eb0a12185c9" translate="yes" xml:space="preserve">
          <source>For more information about the Compose file, see the &lt;a href=&quot;compose-file/index&quot;&gt;Compose file reference&lt;/a&gt;.</source>
          <target state="translated">有关Compose文件的更多信息，请参见&lt;a href=&quot;compose-file/index&quot;&gt;Compose文件参考&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b9d53ab6fabb14595d4358e40785585a79adb1ce" translate="yes" xml:space="preserve">
          <source>For more information and resources, visit &lt;a href=&quot;https://docs.docker.com/opensource&quot;&gt;our help page&lt;/a&gt;.</source>
          <target state="translated">有关更多信息和资源，请访问&lt;a href=&quot;https://docs.docker.com/opensource&quot;&gt;我们的帮助页面&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="af00edf9585c9e9c647d4a7f140d2a889676e716" translate="yes" xml:space="preserve">
          <source>For more information and resources, visit the &lt;a href=&quot;https://docs.docker.com/opensource&quot;&gt;Getting Help project page&lt;/a&gt;.</source>
          <target state="translated">有关更多信息和资源，请访问&amp;ldquo; &lt;a href=&quot;https://docs.docker.com/opensource&quot;&gt;获得帮助&amp;rdquo;项目页面&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a4b204aa89e744ecce7c53f675ec1b36ef051a9e" translate="yes" xml:space="preserve">
          <source>For more information on configs, see &lt;a href=&quot;../../engine/swarm/configs/index&quot;&gt;configs&lt;/a&gt;.</source>
          <target state="translated">有关配置的更多信息，请参见&lt;a href=&quot;../../engine/swarm/configs/index&quot;&gt;configs&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9226fb6709780377051ee0ef78785ad9d7e3485d" translate="yes" xml:space="preserve">
          <source>For more information on configuring Docker Content Trust Signature Verificiation, go to &lt;a href=&quot;../trust/content_trust/index&quot;&gt;Content trust in Docker&lt;/a&gt;.</source>
          <target state="translated">有关配置Docker内容信任签名验证的更多信息，请转到&lt;a href=&quot;../trust/content_trust/index&quot;&gt;Docker中的内容信任&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d8cf03f019ce23577ddec42e109abde3bb6a6d4e" translate="yes" xml:space="preserve">
          <source>For more information on constraints, refer to the &lt;code&gt;docker service create&lt;/code&gt;&lt;a href=&quot;../../reference/commandline/service_create/index&quot;&gt;CLI reference&lt;/a&gt;.</source>
          <target state="translated">有关约束的更多信息，请参考 &lt;code&gt;docker service create&lt;/code&gt; &lt;a href=&quot;../../reference/commandline/service_create/index&quot;&gt;CLI reference&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5b07196d6d5b559b457b5886fee3d0998b43732b" translate="yes" xml:space="preserve">
          <source>For more information on how publishing ports works, see &lt;a href=&quot;#publish-ports&quot;&gt;publish ports&lt;/a&gt;.</source>
          <target state="translated">有关发布端口如何工作的更多信息，请参见&lt;a href=&quot;#publish-ports&quot;&gt;发布端口&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="67e085bf46dc5fc5519747f667353d4093decedb" translate="yes" xml:space="preserve">
          <source>For more information on how to create data volumes and the use of volume drivers, see &lt;a href=&quot;https://docs.docker.com/storage/volumes/&quot;&gt;Use volumes&lt;/a&gt;.</source>
          <target state="translated">有关如何创建数据卷和使用卷驱动程序的更多信息，请参见&lt;a href=&quot;https://docs.docker.com/storage/volumes/&quot;&gt;使用卷&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="14665ae278648b3b2a8e6c22584f8e466bcb77c9" translate="yes" xml:space="preserve">
          <source>For more information on how to write Dockerfiles, see the &lt;a href=&quot;../../get-started/index#building-an-image-from-a-dockerfile&quot;&gt;Docker user guide&lt;/a&gt; and the &lt;a href=&quot;../../engine/reference/builder/index&quot;&gt;Dockerfile reference&lt;/a&gt;.</source>
          <target state="translated">有关如何编写Dockerfile的更多信息，请参阅《&lt;a href=&quot;../../get-started/index#building-an-image-from-a-dockerfile&quot;&gt;Docker用户指南》&lt;/a&gt;和《&lt;a href=&quot;../../engine/reference/builder/index&quot;&gt;Dockerfile参考》&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="580e352f4fee900b98b9b0153f6ef8135654e219" translate="yes" xml:space="preserve">
          <source>For more information on joining a manager node to a swarm, refer to &lt;a href=&quot;../join-nodes/index&quot;&gt;Join nodes to a swarm&lt;/a&gt;.</source>
          <target state="translated">有关将管理器节点&lt;a href=&quot;../join-nodes/index&quot;&gt;加入&lt;/a&gt;群集的更多信息，请参阅将节点加入群集。</target>
        </trans-unit>
        <trans-unit id="a40d49d3f5ee7312495a34d145fbffef34a195f4" translate="yes" xml:space="preserve">
          <source>For more information on overlay networking and service discovery, refer to &lt;a href=&quot;https://docs.docker.com/network&quot;&gt;Attach services to an overlay network&lt;/a&gt; and &lt;a href=&quot;https://docs.docker.com/network&quot;&gt;Docker swarm mode overlay network security model&lt;/a&gt;.</source>
          <target state="translated">有关覆盖网络和服务发现的更多信息，请参阅&lt;a href=&quot;https://docs.docker.com/network&quot;&gt;将服务附加到覆盖网络&lt;/a&gt;和&lt;a href=&quot;https://docs.docker.com/network&quot;&gt;Docker swarm模式覆盖网络安全模型&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="28fb44e7b42617f37524d51315f58a226b620824" translate="yes" xml:space="preserve">
          <source>For more information on secrets, see &lt;a href=&quot;../../engine/swarm/secrets/index&quot;&gt;secrets&lt;/a&gt;.</source>
          <target state="translated">有关机密的更多信息，请参见&lt;a href=&quot;../../engine/swarm/secrets/index&quot;&gt;机密&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e8fdd03484f4c1f12e8b30bff6aeb11dad6801da" translate="yes" xml:space="preserve">
          <source>For more information on swarm administration refer to the &lt;a href=&quot;../admin_guide/index&quot;&gt;Swarm administration guide&lt;/a&gt;.</source>
          <target state="translated">有关群管理的更多信息，请参阅《&lt;a href=&quot;../admin_guide/index&quot;&gt;群管理指南》&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="559e4b57ccf6139096cf34f9a5cde88d91a26161" translate="yes" xml:space="preserve">
          <source>For more information, see the &lt;a href=&quot;../compose-file/index#variable-substitution&quot;&gt;Variable substitution&lt;/a&gt; section in the Compose file reference.</source>
          <target state="translated">有关更多信息，请参见Compose文件参考中的&amp;ldquo; &lt;a href=&quot;../compose-file/index#variable-substitution&quot;&gt;变量替换&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="8835d197ca0f0b5e45bb83fcc1597e7703a11106" translate="yes" xml:space="preserve">
          <source>For more information, see the &lt;a href=&quot;https://www.kernel.org/doc/Documentation/scheduler/sched-bwc.txt&quot;&gt;CFS documentation on bandwidth limiting&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，请参阅&lt;a href=&quot;https://www.kernel.org/doc/Documentation/scheduler/sched-bwc.txt&quot;&gt;有关带宽限制&lt;/a&gt;的CFS文档。</target>
        </trans-unit>
        <trans-unit id="0f2c8a684147f911b3b8f0c4a85548b408dcb738" translate="yes" xml:space="preserve">
          <source>For more on &lt;code&gt;extends&lt;/code&gt;, see the &lt;a href=&quot;../../extends/index#extending-services&quot;&gt;the extends documentation&lt;/a&gt;.</source>
          <target state="translated">有关 &lt;code&gt;extends&lt;/code&gt; 更多信息，请参见&lt;a href=&quot;../../extends/index#extending-services&quot;&gt;扩展文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="271a8641a024a42a950327ed78bedf5647fa3569" translate="yes" xml:space="preserve">
          <source>For most use cases, multi-stage builds are a better alternative, as they give more fine-grained control over your build, and can take advantage of future optimizations in the builder. Refer to the &lt;a href=&quot;https://docs.docker.com/develop/develop-images/multistage-build/&quot;&gt;use multi-stage builds&lt;/a&gt; section in the userguide for more information.</source>
          <target state="translated">对于大多数用例，多阶段构建是更好的选择，因为它们可以对构建进行更细粒度的控制，并可以利用构建器中的未来优化。有关更多信息，请参考用户指南中的&amp;ldquo; &lt;a href=&quot;https://docs.docker.com/develop/develop-images/multistage-build/&quot;&gt;使用多阶段构建&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="5b0d16b1fba86dedb1acc7c4f1ad72e57ee711bd" translate="yes" xml:space="preserve">
          <source>For non-interactive scriptable deployments, download your license from https://hub.docker.com/ then specify the file with the &amp;lsquo;--license&amp;rsquo; flag.</source>
          <target state="translated">对于非交互式可脚本部署，请从https://hub.docker.com/下载许可证，然后使用'--license'标志指定文件。</target>
        </trans-unit>
        <trans-unit id="60a96dc8277b211e383d9bc9390440d2cfc2930c" translate="yes" xml:space="preserve">
          <source>For now, however, if you want to create &lt;em&gt;multiple&lt;/em&gt; local machines, you still need Docker Machine to create and manage machines for multi-node experimentation. Both Docker Desktop for Mac and Docker Desktop for Windows include the newest version of Docker Machine, so when you install either of these, you get &lt;code&gt;docker-machine&lt;/code&gt;.</source>
          <target state="translated">但是，现在，如果要创建&lt;em&gt;多个&lt;/em&gt;本地计算机，则仍需要Docker Machine来创建和管理用于多节点实验的计算机。适用于Mac的Docker桌面和适用于Windows的Docker桌面都包含最新版本的Docker Machine，因此，在安装其中任何一个时，都将获得 &lt;code&gt;docker-machine&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c95e03d75f152dabaf7a06018ed438672c440840" translate="yes" xml:space="preserve">
          <source>For official images (identifiable by the &amp;ldquo;Official Image&amp;rdquo; moniker), the image name as displayed on Docker Hub, prefixed with &lt;code&gt;docker.io/library/&lt;/code&gt;. For example, if you would normally type &lt;code&gt;docker pull ubuntu&lt;/code&gt; you must enter &lt;code&gt;notary {cmd} docker.io/library/ubuntu&lt;/code&gt;.</source>
          <target state="translated">对于正式映像（可由&amp;ldquo; Official Image&amp;rdquo;绰号标识），在Docker Hub上显示的映像名称以 &lt;code&gt;docker.io/library/&lt;/code&gt; 为前缀。例如，如果您通常键入 &lt;code&gt;docker pull ubuntu&lt;/code&gt; ，则必须输入 &lt;code&gt;notary {cmd} docker.io/library/ubuntu&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dab95a5874153c9e1a31615cb63e34d284d71754" translate="yes" xml:space="preserve">
          <source>For our example, the commands are:</source>
          <target state="translated">在我们的例子中,命令是:</target>
        </trans-unit>
        <trans-unit id="f2f05049fcc859cd3e98045f52b1fdfe4fb64443" translate="yes" xml:space="preserve">
          <source>For single-value options like &lt;code&gt;image&lt;/code&gt;, &lt;code&gt;command&lt;/code&gt; or &lt;code&gt;mem_limit&lt;/code&gt;, the new value replaces the old value.</source>
          <target state="translated">对于 &lt;code&gt;image&lt;/code&gt; ， &lt;code&gt;command&lt;/code&gt; 或 &lt;code&gt;mem_limit&lt;/code&gt; 之类的单值选项，新值将替换旧值。</target>
        </trans-unit>
        <trans-unit id="1d0a2cb815145a86f819db52409f285ede37c561" translate="yes" xml:space="preserve">
          <source>For systems that have recent aufs version (i.e., &lt;code&gt;dirperm1&lt;/code&gt; mount option can be set), docker will attempt to fix the issue automatically by mounting the layers with &lt;code&gt;dirperm1&lt;/code&gt; option. More details on &lt;code&gt;dirperm1&lt;/code&gt; option can be found at &lt;a href=&quot;https://github.com/sfjro/aufs3-linux/tree/aufs3.18/Documentation/filesystems/aufs&quot;&gt;&lt;code&gt;aufs&lt;/code&gt; man page&lt;/a&gt;</source>
          <target state="translated">对于具有最新aufs版本的系统（即，可以设置 &lt;code&gt;dirperm1&lt;/code&gt; 安装选项），docker将尝试通过使用 &lt;code&gt;dirperm1&lt;/code&gt; 选项安装各层来自动修复该问题。有关 &lt;code&gt;dirperm1&lt;/code&gt; 选项的更多详细信息，请参见&lt;a href=&quot;https://github.com/sfjro/aufs3-linux/tree/aufs3.18/Documentation/filesystems/aufs&quot;&gt; &lt;code&gt;aufs&lt;/code&gt; 手册页&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c7aceccd97e71a3bff5b3e627905c415a89ae3d7" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;targets/releases&lt;/code&gt; delegation role to sign content, the delegation user must possess the private key corresponding to this public key. This command restricts this delegation to only publish content under pathnames prefixed by &lt;code&gt;delegation/path&lt;/code&gt;. With the given path of &amp;ldquo;delegation/path&amp;rdquo;, the &lt;code&gt;targets/releases&lt;/code&gt; role could sign paths like &amp;ldquo;delegation/path/content.txt&amp;rdquo;, &amp;ldquo;delegation/path_file.txt&amp;rdquo; and &amp;ldquo;delegation/path.txt&amp;rdquo;. You can add more paths in a comma-separated list under &lt;code&gt;--paths&lt;/code&gt;, or pass the &lt;code&gt;--all-paths&lt;/code&gt; flag to allow this delegation to publish content under any pathname.</source>
          <target state="translated">对于 &lt;code&gt;targets/releases&lt;/code&gt; 委托角色来签名内容，委托用户必须拥有与此公共密钥相对应的私有密钥。此命令将限制此委派以仅发布以Delegation &lt;code&gt;delegation/path&lt;/code&gt; 为前缀的路径名下的内容。使用给定的&amp;ldquo;授权/路径&amp;rdquo;路径， &lt;code&gt;targets/releases&lt;/code&gt; 角色可以签署诸如&amp;ldquo;授权/路径/content.txt&amp;rdquo;，&amp;ldquo;授权/path_file.txt&amp;rdquo;和&amp;ldquo;授权/path.txt&amp;rdquo;的路径。您可以在 &lt;code&gt;--paths&lt;/code&gt; 下以逗号分隔的列表中添加更多路径，或传递 &lt;code&gt;--all-paths&lt;/code&gt; 标志以允许此委托以任何路径名发布内容。</target>
        </trans-unit>
        <trans-unit id="bbb8305cc3ce54466b6cd1be8dd158891b03417c" translate="yes" xml:space="preserve">
          <source>For the &lt;strong&gt;multi-value options&lt;/strong&gt;&lt;code&gt;ports&lt;/code&gt;, &lt;code&gt;expose&lt;/code&gt;, &lt;code&gt;external_links&lt;/code&gt;, &lt;code&gt;dns&lt;/code&gt;, &lt;code&gt;dns_search&lt;/code&gt;, and &lt;code&gt;tmpfs&lt;/code&gt;, Compose concatenates both sets of values:</source>
          <target state="translated">对于&lt;strong&gt;多值选项&lt;/strong&gt; &lt;code&gt;ports&lt;/code&gt; ， &lt;code&gt;expose&lt;/code&gt; ， &lt;code&gt;external_links&lt;/code&gt; ， &lt;code&gt;dns&lt;/code&gt; ， &lt;code&gt;dns_search&lt;/code&gt; 和 &lt;code&gt;tmpfs&lt;/code&gt; ，Compose连接这两组值：</target>
        </trans-unit>
        <trans-unit id="8ba6752ae0cdb31055e57ee9cc71aa5ba9ea1e74" translate="yes" xml:space="preserve">
          <source>For the full set of available filters and expressions, see the &lt;a href=&quot;https://docs.docker.com/swarm/scheduler/filter/&quot;&gt;Swarm documentation&lt;/a&gt;.</source>
          <target state="translated">有关可用过滤器和表达式的完整集合，请参见&lt;a href=&quot;https://docs.docker.com/swarm/scheduler/filter/&quot;&gt;Swarm文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b9b4e65b35dc4516d408559cc11873bc95a94870" translate="yes" xml:space="preserve">
          <source>For the most part, you can pick out any field from the JSON in a fairly straightforward manner.</source>
          <target state="translated">在大多数情况下,你可以以一种相当直接的方式从JSON中挑选出任何字段。</target>
        </trans-unit>
        <trans-unit id="7e24d434df7abbdbed1bca87fd765086211b5d01" translate="yes" xml:space="preserve">
          <source>For the most predictable behavior, ensure that all swarm nodes are running Docker 17.06 or higher.</source>
          <target state="translated">为了获得最可预测的行为,请确保所有群集节点都在运行Docker 17.06或更高版本。</target>
        </trans-unit>
        <trans-unit id="956ac3d1457dc4bde02561b8bd56392a8dc0e498" translate="yes" xml:space="preserve">
          <source>For this example, the new Droplet is called &lt;code&gt;docker-sandbox&lt;/code&gt;:</source>
          <target state="translated">在此示例中，新的Droplet称为 &lt;code&gt;docker-sandbox&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="22bf5428ece73f9832bec22b26627f5c6b56b8ef" translate="yes" xml:space="preserve">
          <source>For this example, we created a virtual switch called &lt;code&gt;Primary Virtual Switch&lt;/code&gt;.</source>
          <target state="translated">在此示例中，我们创建了一个称为 &lt;code&gt;Primary Virtual Switch&lt;/code&gt; 的虚拟交换机。</target>
        </trans-unit>
        <trans-unit id="8dd8cffcef825b05c408e06792aa76d4b2327a6e" translate="yes" xml:space="preserve">
          <source>For this project, you need to create a Dockerfile, a Python dependencies file, and a &lt;code&gt;docker-compose.yml&lt;/code&gt; file. (You can use either a &lt;code&gt;.yml&lt;/code&gt; or &lt;code&gt;.yaml&lt;/code&gt; extension for this file.)</source>
          <target state="translated">对于此项目，您需要创建一个Dockerfile，一个Python依赖项文件和一个 &lt;code&gt;docker-compose.yml&lt;/code&gt; 文件。（您可以为此文件使用 &lt;code&gt;.yml&lt;/code&gt; 或 &lt;code&gt;.yaml&lt;/code&gt; 扩展名。）</target>
        </trans-unit>
        <trans-unit id="89b34d7c236301a269209483a9512bf580d0c296" translate="yes" xml:space="preserve">
          <source>For this reason, consider defining an additional Compose file, say &lt;code&gt;production.yml&lt;/code&gt;, which specifies production-appropriate configuration. This configuration file only needs to include the changes you&amp;rsquo;d like to make from the original Compose file. The additional Compose file can be applied over the original &lt;code&gt;docker-compose.yml&lt;/code&gt; to create a new configuration.</source>
          <target state="translated">因此，请考虑定义一个附加的Compose文件，例如 &lt;code&gt;production.yml&lt;/code&gt; ，它指定适合生产的配置。该配置文件仅需要包含您想要对原始Compose文件进行的更改。可以将其他Compose文件应用于原始 &lt;code&gt;docker-compose.yml&lt;/code&gt; 以创建新配置。</target>
        </trans-unit>
        <trans-unit id="1be658f3b92588270cc15de4c1aeeba172066cb0" translate="yes" xml:space="preserve">
          <source>For this reason, the REST API endpoint (used by the Docker CLI to communicate with the Docker daemon) changed in Docker 0.5.2, and now uses a UNIX socket instead of a TCP socket bound on 127.0.0.1 (the latter being prone to cross-site request forgery attacks if you happen to run Docker directly on your local machine, outside of a VM). You can then use traditional UNIX permission checks to limit access to the control socket.</source>
          <target state="translated">为此,在Docker 0.5.2中改变了REST API端点(Docker CLI用来与Docker守护进程通信),现在使用UNIX套接字,而不是绑定在127.0.0.1上的TCP套接字(如果你碰巧在虚拟机之外的本地机器上直接运行Docker的话,后者容易引起跨站请求伪造攻击)。然后你可以使用传统的UNIX权限检查来限制对控制套接字的访问。</target>
        </trans-unit>
        <trans-unit id="55c0512227499e363436d77d61306954ff75b779" translate="yes" xml:space="preserve">
          <source>For version 2.0 of the format, &lt;code&gt;external&lt;/code&gt; cannot be used in conjunction with other network configuration keys (&lt;code&gt;driver&lt;/code&gt;, &lt;code&gt;driver_opts&lt;/code&gt;, &lt;code&gt;ipam&lt;/code&gt;, &lt;code&gt;internal&lt;/code&gt;). This limitation no longer exists for &lt;a href=&quot;../compose-versioning/index#version-21&quot;&gt;version 2.1&lt;/a&gt; and above.</source>
          <target state="translated">对于该格式的2.0版， &lt;code&gt;external&lt;/code&gt; 不能与其他网络配置键（ &lt;code&gt;driver&lt;/code&gt; ， &lt;code&gt;driver_opts&lt;/code&gt; ， &lt;code&gt;ipam&lt;/code&gt; ， &lt;code&gt;internal&lt;/code&gt; ）一起使用。对于&lt;a href=&quot;../compose-versioning/index#version-21&quot;&gt;2.1&lt;/a&gt;及更高版本，此限制不再存在。</target>
        </trans-unit>
        <trans-unit id="b6db84ed69cd13af32c06719b1991abd5aa784e9" translate="yes" xml:space="preserve">
          <source>For version 2.0 of the format, &lt;code&gt;external&lt;/code&gt; cannot be used in conjunction with other volume configuration keys (&lt;code&gt;driver&lt;/code&gt;, &lt;code&gt;driver_opts&lt;/code&gt;, &lt;code&gt;labels&lt;/code&gt;). This limitation no longer exists for &lt;a href=&quot;../compose-versioning/index#version-21&quot;&gt;version 2.1&lt;/a&gt; and above.</source>
          <target state="translated">对于格式2.0版， &lt;code&gt;external&lt;/code&gt; 不能与其他卷配置键（ &lt;code&gt;driver&lt;/code&gt; ， &lt;code&gt;driver_opts&lt;/code&gt; ， &lt;code&gt;labels&lt;/code&gt; ）一起使用。对于&lt;a href=&quot;../compose-versioning/index#version-21&quot;&gt;2.1&lt;/a&gt;及更高版本，此限制不再存在。</target>
        </trans-unit>
        <trans-unit id="616c013d120401b89c42a71cc8808b7fd3df4d25" translate="yes" xml:space="preserve">
          <source>For version 3.3 and below of the format, &lt;code&gt;external&lt;/code&gt; cannot be used in conjunction with other network configuration keys (&lt;code&gt;driver&lt;/code&gt;, &lt;code&gt;driver_opts&lt;/code&gt;, &lt;code&gt;ipam&lt;/code&gt;, &lt;code&gt;internal&lt;/code&gt;). This limitation no longer exists for &lt;a href=&quot;compose-versioning/index#version-34&quot;&gt;version 3.4&lt;/a&gt; and above.</source>
          <target state="translated">对于该格式的3.3版及更低版本， &lt;code&gt;external&lt;/code&gt; 不能与其他网络配置键（ &lt;code&gt;driver&lt;/code&gt; ， &lt;code&gt;driver_opts&lt;/code&gt; ， &lt;code&gt;ipam&lt;/code&gt; ， &lt;code&gt;internal&lt;/code&gt; ）结合使用。对于&lt;a href=&quot;compose-versioning/index#version-34&quot;&gt;3.4&lt;/a&gt;及更高版本，此限制不再存在。</target>
        </trans-unit>
        <trans-unit id="bf18270bcb0b883b053dc1c60baf663bb0b8c272" translate="yes" xml:space="preserve">
          <source>For version 3.3 and below of the format, &lt;code&gt;external&lt;/code&gt; cannot be used in conjunction with other volume configuration keys (&lt;code&gt;driver&lt;/code&gt;, &lt;code&gt;driver_opts&lt;/code&gt;, &lt;code&gt;labels&lt;/code&gt;). This limitation no longer exists for &lt;a href=&quot;compose-versioning/index#version-34&quot;&gt;version 3.4&lt;/a&gt; and above.</source>
          <target state="translated">对于该格式的3.3版及更低版本， &lt;code&gt;external&lt;/code&gt; 不能与其他卷配置键（ &lt;code&gt;driver&lt;/code&gt; ， &lt;code&gt;driver_opts&lt;/code&gt; ， &lt;code&gt;labels&lt;/code&gt; ）一起使用。对于&lt;a href=&quot;compose-versioning/index#version-34&quot;&gt;3.4&lt;/a&gt;及更高版本，此限制不再存在。</target>
        </trans-unit>
        <trans-unit id="f9afee299aba0d401e62065d746fcc356f416236" translate="yes" xml:space="preserve">
          <source>Force create a new cluster from current state</source>
          <target state="translated">强制从当前状态创建一个新的集群</target>
        </trans-unit>
        <trans-unit id="ffe69cc485ff658043cc42f4902c04e7a8d6b09f" translate="yes" xml:space="preserve">
          <source>Force removal of the image</source>
          <target state="translated">强制删除图像</target>
        </trans-unit>
        <trans-unit id="229c55dfaca028bf7cfef7dc627152c2af359ede" translate="yes" xml:space="preserve">
          <source>Force remove a node from the swarm</source>
          <target state="translated">强制从蜂群中删除一个节点</target>
        </trans-unit>
        <trans-unit id="406db54e3abff369fddfe503307a2a70d5f41bc8" translate="yes" xml:space="preserve">
          <source>Force the container to disconnect from a network</source>
          <target state="translated">强制容器与网络断开连接</target>
        </trans-unit>
        <trans-unit id="6680f7a8870252cbed4ec8ea429862849a3f871d" translate="yes" xml:space="preserve">
          <source>Force the disable of an active plugin</source>
          <target state="translated">强制关闭活动中的插件</target>
        </trans-unit>
        <trans-unit id="8a33555a38c511700b5d1ae3ae93e29f1b9f5499" translate="yes" xml:space="preserve">
          <source>Force the removal of a context in use</source>
          <target state="translated">强制删除使用中的上下文</target>
        </trans-unit>
        <trans-unit id="62b45047a99ee6674e7e008d270166ad1c348276" translate="yes" xml:space="preserve">
          <source>Force the removal of a running container (uses SIGKILL)</source>
          <target state="translated">强制移除正在运行的容器(使用SIGKILL)。</target>
        </trans-unit>
        <trans-unit id="c0d61bd04c5fbbee83f15b02f2d884e770b15063" translate="yes" xml:space="preserve">
          <source>Force the removal of an active plugin</source>
          <target state="translated">强制删除活动插件</target>
        </trans-unit>
        <trans-unit id="d2243470861089be803d922e7a30924401a391a7" translate="yes" xml:space="preserve">
          <source>Force the removal of one or more volumes</source>
          <target state="translated">强制删除一个或多个卷</target>
        </trans-unit>
        <trans-unit id="f312de45e6a40e2de073bf378473cc1a2369216b" translate="yes" xml:space="preserve">
          <source>Force the swarm to rebalance</source>
          <target state="translated">迫使虫群重新平衡</target>
        </trans-unit>
        <trans-unit id="c06e3ec6ba4d32c91dd87af847fef4fb84ee70f2" translate="yes" xml:space="preserve">
          <source>Force this node to leave the swarm, ignoring warnings</source>
          <target state="translated">强制该节点离开虫群,忽略警告。</target>
        </trans-unit>
        <trans-unit id="a85f94902a59f50f2a418ff47b6306ba4fdda829" translate="yes" xml:space="preserve">
          <source>Force update even if no changes require it</source>
          <target state="translated">即使没有变化也要强制更新</target>
        </trans-unit>
        <trans-unit id="f01410523237ffac132845ad9d10538c42f94789" translate="yes" xml:space="preserve">
          <source>Force-remove a running container</source>
          <target state="translated">强制删除正在运行的容器</target>
        </trans-unit>
        <trans-unit id="8dcc686dfba68c99f8e7cb9d3fb72b82a6c9b888" translate="yes" xml:space="preserve">
          <source>Forces running containers to stop by sending a &lt;code&gt;SIGKILL&lt;/code&gt; signal. Optionally the signal can be passed, for example:</source>
          <target state="translated">通过发送 &lt;code&gt;SIGKILL&lt;/code&gt; 信号来强制运行中的容器停止。可选地，可以传递信号，例如：</target>
        </trans-unit>
        <trans-unit id="e3a20ef13144cabfd7237a24ab82c637e82ce623" translate="yes" xml:space="preserve">
          <source>Forcibly remove a node</source>
          <target state="translated">强制删除一个节点</target>
        </trans-unit>
        <trans-unit id="8352d19d209922284236d3551ee7aed0aa67a969" translate="yes" xml:space="preserve">
          <source>Forcibly remove an inaccessible node from a swarm</source>
          <target state="translated">从群中强行删除一个不可访问的节点。</target>
        </trans-unit>
        <trans-unit id="f7745efdedae8430f407638389ab56b4f858eeed" translate="yes" xml:space="preserve">
          <source>Foreground</source>
          <target state="translated">Foreground</target>
        </trans-unit>
        <trans-unit id="041a5dec481d6bf0724caeaa84bc135d7d9062d4" translate="yes" xml:space="preserve">
          <source>Format</source>
          <target state="translated">Format</target>
        </trans-unit>
        <trans-unit id="49408c5ca514b719eac953a6bbd84a077d01680d" translate="yes" xml:space="preserve">
          <source>Format as JSON</source>
          <target state="translated">格式为JSON</target>
        </trans-unit>
        <trans-unit id="39d2e03f2e26543021089a14d2cd71f93bc839e6" translate="yes" xml:space="preserve">
          <source>Format the output</source>
          <target state="translated">输出格式</target>
        </trans-unit>
        <trans-unit id="6454bbbd2b93e7a470ed8675888bbcd47205f0ed" translate="yes" xml:space="preserve">
          <source>Format the output using the given Go template</source>
          <target state="translated">使用给定的Go模板进行输出格式化</target>
        </trans-unit>
        <trans-unit id="841f832857c780b47f478b4f21d34d8995af64b8" translate="yes" xml:space="preserve">
          <source>Formatting</source>
          <target state="translated">Formatting</target>
        </trans-unit>
        <trans-unit id="29527e1c376ee4bcbb6714965180b18b1e1cb7a0" translate="yes" xml:space="preserve">
          <source>Formatting the output</source>
          <target state="translated">输出的格式化</target>
        </trans-unit>
        <trans-unit id="467a77b7c1a6472ed6e13990989aae65ac956726" translate="yes" xml:space="preserve">
          <source>Fortunately when using the &lt;code&gt;$ docker trust&lt;/code&gt; commands, we will automatically initialize a repository, manage the repository keys, and add a collaborator&amp;rsquo;s key to the &lt;code&gt;targets/releases&lt;/code&gt; delegation via &lt;code&gt;docker trust signer add&lt;/code&gt;.</source>
          <target state="translated">幸运的是，在使用 &lt;code&gt;$ docker trust&lt;/code&gt; 命令时，我们将自动初始化存储库，管理存储库密钥，并通过 &lt;code&gt;docker trust signer add&lt;/code&gt; 将协作者的密钥添加到 &lt;code&gt;targets/releases&lt;/code&gt; 委托中。</target>
        </trans-unit>
        <trans-unit id="38268fd8dbb017ec4ab6dcdbb25a7c1ed13c58c3" translate="yes" xml:space="preserve">
          <source>Four of the Dockerfile commands cannot be overridden at runtime: &lt;code&gt;FROM&lt;/code&gt;, &lt;code&gt;MAINTAINER&lt;/code&gt;, &lt;code&gt;RUN&lt;/code&gt;, and &lt;code&gt;ADD&lt;/code&gt;. Everything else has a corresponding override in &lt;code&gt;docker run&lt;/code&gt;. We&amp;rsquo;ll go through what the developer might have set in each Dockerfile instruction and how the operator can override that setting.</source>
          <target state="translated">在运行时无法覆盖以下四个Dockerfile命令： &lt;code&gt;FROM&lt;/code&gt; ， &lt;code&gt;MAINTAINER&lt;/code&gt; ， &lt;code&gt;RUN&lt;/code&gt; 和 &lt;code&gt;ADD&lt;/code&gt; 。其他所有内容在 &lt;code&gt;docker run&lt;/code&gt; 中都有相应的覆盖。我们将介绍开发人员可能在每个Dockerfile指令中设置的内容，以及操作员如何覆盖该设置。</target>
        </trans-unit>
        <trans-unit id="af90cef80988974dd76636b3adb5f472768f785d" translate="yes" xml:space="preserve">
          <source>Frequently asked questions</source>
          <target state="translated">常见的问题</target>
        </trans-unit>
        <trans-unit id="ec047a56e845558e1731ee061b01073cfea2ff68" translate="yes" xml:space="preserve">
          <source>From &lt;code&gt;docker-compose&lt;/code&gt;:</source>
          <target state="translated">从 &lt;code&gt;docker-compose&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="fd8289350ea17783bc93c61db927437efc2687bf" translate="yes" xml:space="preserve">
          <source>From here you can do everything you learned about in parts 2 and 3.</source>
          <target state="translated">从这里你可以做你在第二和第三部分学到的一切。</target>
        </trans-unit>
        <trans-unit id="449ab4f3925ece4db8a57b83c0e94335be023995" translate="yes" xml:space="preserve">
          <source>From here you can do everything you learned about in previous parts of the tutorial.</source>
          <target state="translated">从这里,你可以做你在前面的教程部分学到的一切。</target>
        </trans-unit>
        <trans-unit id="0194b18f2f7b4432a9a2e687308c6ced82ae4647" translate="yes" xml:space="preserve">
          <source>From now on, you can use &lt;code&gt;docker run&lt;/code&gt; and run your app on any machine with this command:</source>
          <target state="translated">从现在开始，您可以使用 &lt;code&gt;docker run&lt;/code&gt; 并通过以下命令在任何计算机上运行您的应用程序：</target>
        </trans-unit>
        <trans-unit id="956ff8343ab67909410600a26d5f109cd95d93e4" translate="yes" xml:space="preserve">
          <source>From the AWS menus, select &lt;strong&gt;Services&lt;/strong&gt; &amp;gt; &lt;strong&gt;IAM&lt;/strong&gt; to get started.</source>
          <target state="translated">在AWS菜单中，选择&lt;strong&gt;服务&lt;/strong&gt; &amp;gt; &lt;strong&gt;IAM&lt;/strong&gt;以开始使用。</target>
        </trans-unit>
        <trans-unit id="90f1b6a32d15eb97fb6e5cff6efefde16b6400eb" translate="yes" xml:space="preserve">
          <source>From the command line, run &lt;code&gt;docker node inspect &amp;lt;id-node&amp;gt;&lt;/code&gt; to query the nodes. For instance, to query the reachability of the node as a manager:</source>
          <target state="translated">从命令行运行 &lt;code&gt;docker node inspect &amp;lt;id-node&amp;gt;&lt;/code&gt; 来查询节点。例如，要查询节点作为管理者的可达性：</target>
        </trans-unit>
        <trans-unit id="967bcd5ce7159e40d77a43ef0368fcade23d1d92" translate="yes" xml:space="preserve">
          <source>From this point on, all new node certificates issued are signed with the new root CA, and do not contain any intermediates.</source>
          <target state="translated">从此,所有新签发的节点证书都是与新的根CA签署的,不包含任何中间环节。</target>
        </trans-unit>
        <trans-unit id="335f3b4a3d405e2d4b01be74e8d2f61edc6550a7" translate="yes" xml:space="preserve">
          <source>From those commands, we can see that &lt;code&gt;manager1&lt;/code&gt; is both at the status &lt;code&gt;reachable&lt;/code&gt; as a manager and &lt;code&gt;ready&lt;/code&gt; as a worker.</source>
          <target state="translated">从这些命令中，我们可以看到 &lt;code&gt;manager1&lt;/code&gt; 既处于管理者 &lt;code&gt;reachable&lt;/code&gt; 状态又 &lt;code&gt;ready&lt;/code&gt; 工作者状态。</target>
        </trans-unit>
        <trans-unit id="b85f5d1178a131088a76c1a36179562d8bca8da4" translate="yes" xml:space="preserve">
          <source>From your project directory, start up your application by running &lt;code&gt;docker-compose up&lt;/code&gt;.</source>
          <target state="translated">在项目目录中，通过运行 &lt;code&gt;docker-compose up&lt;/code&gt; 来启动应用程序。</target>
        </trans-unit>
        <trans-unit id="732528e9391666886858509f010a261f26833e5b" translate="yes" xml:space="preserve">
          <source>From your project directory, type &lt;code&gt;docker-compose up&lt;/code&gt; to build the app with the updated Compose file, and run it.</source>
          <target state="translated">在项目目录中，键入 &lt;code&gt;docker-compose up&lt;/code&gt; 以使用更新的Compose文件构建应用程序，然后运行它。</target>
        </trans-unit>
        <trans-unit id="40f85c660757f599cc1b255f437d1323982d5c39" translate="yes" xml:space="preserve">
          <source>Full URL, such as &lt;code&gt;DB_PORT=tcp://172.17.0.5:5432&lt;/code&gt;</source>
          <target state="translated">完整URL，例如 &lt;code&gt;DB_PORT=tcp://172.17.0.5:5432&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ef73c5354384685e9eaf339df1c2a8360e8241f1" translate="yes" xml:space="preserve">
          <source>Full URL, such as &lt;code&gt;DB_PORT_5432_TCP=tcp://172.17.0.5:5432&lt;/code&gt;</source>
          <target state="translated">完整URL，例如 &lt;code&gt;DB_PORT_5432_TCP=tcp://172.17.0.5:5432&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f7ddbd43e90b6f2dd187621985159b4e46678677" translate="yes" xml:space="preserve">
          <source>Full container capabilities (--privileged)</source>
          <target state="translated">完整的容器功能(-特权)</target>
        </trans-unit>
        <trans-unit id="9dc31143091e9ea6de501377e88db64cf87122c9" translate="yes" xml:space="preserve">
          <source>Full detail on these flags, the problems they solve, and their &lt;code&gt;docker run&lt;/code&gt; counterparts is in the Docker Desktop for Mac topic &lt;a href=&quot;https://docs.docker.com/docker-for-mac/osxfs-caching/&quot;&gt;Performance tuning for volume mounts (shared filesystems)&lt;/a&gt;.</source>
          <target state="translated">这些标志的详细信息，它们所解决的问题以及与 &lt;code&gt;docker run&lt;/code&gt; 的问题在Docker Desktop for Mac主题中&lt;a href=&quot;https://docs.docker.com/docker-for-mac/osxfs-caching/&quot;&gt;针对卷装载（共享文件系统）进行性能调优&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="eeb692087d629b32f2f1820369d9756d60c5cba8" translate="yes" xml:space="preserve">
          <source>Full name</source>
          <target state="translated">全名</target>
        </trans-unit>
        <trans-unit id="14b79e642439f31013446b809db6f1eabf68edf5" translate="yes" xml:space="preserve">
          <source>Fully qualified container name, such as &lt;code&gt;DB_1_NAME=/myapp_web_1/myapp_db_1&lt;/code&gt;</source>
          <target state="translated">完全限定的容器名称，例如 &lt;code&gt;DB_1_NAME=/myapp_web_1/myapp_db_1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0e44c8b638baa470dbb5f127964c092cc77ea465" translate="yes" xml:space="preserve">
          <source>Further reading</source>
          <target state="translated">进一步阅读</target>
        </trans-unit>
        <trans-unit id="1bcb44f5d1ee1783c081e60efc3a940a8a5f4405" translate="yes" xml:space="preserve">
          <source>Further reference information is available on the &lt;a href=&quot;http://man7.org/linux/man-pages/man7/capabilities.7.html&quot;&gt;capabilities(7) - Linux man page&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://man7.org/linux/man-pages/man7/capabilities.7.html&quot;&gt;功能（7）-Linux手册页&lt;/a&gt;上提供了更多参考信息。</target>
        </trans-unit>
        <trans-unit id="8232f5f709f3c8d7a2b6a65fd4572436973477a0" translate="yes" xml:space="preserve">
          <source>Fuxi Volume Plugin</source>
          <target state="translated">伏羲音量插件</target>
        </trans-unit>
        <trans-unit id="400df617426074f7a1d3e72230098eda5c8df643" translate="yes" xml:space="preserve">
          <source>GPU devices to add to the container (&amp;lsquo;all&amp;rsquo; to pass all GPUs)</source>
          <target state="translated">要添加到容器中的GPU设备（&amp;ldquo;全部&amp;rdquo;通过所有GPU）</target>
        </trans-unit>
        <trans-unit id="8fccc069576bf17f5e7e17b4b3c176d69ed30562" translate="yes" xml:space="preserve">
          <source>General form</source>
          <target state="translated">一般形式</target>
        </trans-unit>
        <trans-unit id="6fbf147c71a40b7a7ce191e58e7241180d751550" translate="yes" xml:space="preserve">
          <source>Generally, you do not need to force the swarm to rebalance its tasks. When you add a new node to a swarm, or a node reconnects to the swarm after a period of unavailability, the swarm does not automatically give a workload to the idle node. This is a design decision. If the swarm periodically shifted tasks to different nodes for the sake of balance, the clients using those tasks would be disrupted. The goal is to avoid disrupting running services for the sake of balance across the swarm. When new tasks start, or when a node with running tasks becomes unavailable, those tasks are given to less busy nodes. The goal is eventual balance, with minimal disruption to the end user.</source>
          <target state="translated">一般来说,您不需要强制蜂群重新平衡其任务。当您将新节点添加到蜂群中,或者某个节点在一段不可用的时间后重新连接到蜂群中时,蜂群不会自动给闲置节点分配工作负载。这是一个设计决定。如果蜂群为了平衡而周期性地将任务转移到不同的节点上,那么使用这些任务的客户端就会被打乱。目标是为了整个蜂群的平衡,避免中断正在运行的服务。当新的任务开始时,或者当一个有运行任务的节点变得不可用时,这些任务就会被交给不太繁忙的节点。目标是最终的平衡,对终端用户的干扰最小。</target>
        </trans-unit>
        <trans-unit id="644d86c2b8f866c04433746baa7e8b0f2cba8f64" translate="yes" xml:space="preserve">
          <source>Generate a CSR using the root key.</source>
          <target state="translated">使用根密钥生成一个CSR。</target>
        </trans-unit>
        <trans-unit id="e967d39d65ee77d3f7ba72d1e9081eabff69dc92" translate="yes" xml:space="preserve">
          <source>Generate a Distributed Application Bundle (DAB) from the Compose file.</source>
          <target state="translated">从Compose文件中生成分布式应用包(DAB)。</target>
        </trans-unit>
        <trans-unit id="5a0ec17a13466e19309645b5110deac758728d83" translate="yes" xml:space="preserve">
          <source>Generate a random alphanumeric password for MySQL and store it as a Docker secret with the name &lt;code&gt;mysql_password&lt;/code&gt; using the &lt;code&gt;docker secret create&lt;/code&gt; command. To make the password shorter or longer, adjust the last argument of the &lt;code&gt;openssl&lt;/code&gt; command. This is just one way to create a relatively random password. You can use another command to generate the password if you choose.</source>
          <target state="translated">生成用于MySQL的随机字母数字密码，并使用 &lt;code&gt;mysql_password&lt;/code&gt; &lt;code&gt;docker secret create&lt;/code&gt; 命令将其存储为Docker秘密，名称为mysql_password。要使密码变短或变长，请调整 &lt;code&gt;openssl&lt;/code&gt; 命令的最后一个参数。这只是创建相对随机密码的一种方法。您可以选择使用另一个命令来生成密码。</target>
        </trans-unit>
        <trans-unit id="67855c41928429f4f9eb74522862e8bc3b7720f0" translate="yes" xml:space="preserve">
          <source>Generate a root CA and TLS certificate and key for your site. For production sites, you may want to use a service such as &lt;code&gt;Let&amp;rsquo;s Encrypt&lt;/code&gt; to generate the TLS certificate and key, but this example uses command-line tools. This step is a little complicated, but is only a set-up step so that you have something to store as a Docker secret. If you want to skip these sub-steps, you can &lt;a href=&quot;https://letsencrypt.org/getting-started/&quot;&gt;use Let&amp;rsquo;s Encrypt&lt;/a&gt; to generate the site key and certificate, name the files &lt;code&gt;site.key&lt;/code&gt; and &lt;code&gt;site.crt&lt;/code&gt;, and skip to &lt;a href=&quot;#configure-the-nginx-container&quot;&gt;Configure the Nginx container&lt;/a&gt;.</source>
          <target state="translated">为您的站点生成根CA和TLS证书以及密钥。对于生产站点，您可能需要使用诸如&amp;ldquo; &lt;code&gt;Let&amp;rsquo;s Encrypt&lt;/code&gt; 类的服务来生成TLS证书和密钥，但是本示例使用命令行工具。此步骤有点复杂，但仅是设置步骤，因此您可以将某些内容存储为Docker机密。如果要跳过这些子步骤，可以&lt;a href=&quot;https://letsencrypt.org/getting-started/&quot;&gt;使用&amp;ldquo;让我们加密&amp;rdquo;&lt;/a&gt;来生成站点密钥和证书，将文件命名为 &lt;code&gt;site.key&lt;/code&gt; 和 &lt;code&gt;site.crt&lt;/code&gt; ，然后跳至&amp;ldquo; &lt;a href=&quot;#configure-the-nginx-container&quot;&gt;配置Nginx容器&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="78ae4050a21f6a62216c3c2650fbe099edc0e506" translate="yes" xml:space="preserve">
          <source>Generate a root key.</source>
          <target state="translated">生成一个根密钥。</target>
        </trans-unit>
        <trans-unit id="aa53b2e1470d57aa6cdfcac43ec91067a9ed4acb" translate="yes" xml:space="preserve">
          <source>Generate a second secret for the MySQL &lt;code&gt;root&lt;/code&gt; user. This secret isn&amp;rsquo;t shared with the WordPress service created later. It&amp;rsquo;s only needed to bootstrap the &lt;code&gt;mysql&lt;/code&gt; service.</source>
          <target state="translated">为MySQL &lt;code&gt;root&lt;/code&gt; 用户生成第二个秘密。此秘密不会与以后创建的WordPress服务共享。只需要引导 &lt;code&gt;mysql&lt;/code&gt; 服务。</target>
        </trans-unit>
        <trans-unit id="873c47c8e4481c69e4dbcd631ac3b4d5df889a50" translate="yes" xml:space="preserve">
          <source>Generate a set of certificates (usually with the default, self-signed CA) and configure the daemon to accept connections over TLS.</source>
          <target state="translated">生成一组证书(通常使用默认的、自签名的CA),并配置守护进程接受通过TLS的连接。</target>
        </trans-unit>
        <trans-unit id="48a0cb942ac8b81b9b804324cc06ed025190d3f5" translate="yes" xml:space="preserve">
          <source>Generate and load a signing key-pair</source>
          <target state="translated">生成并加载一个签名密钥对</target>
        </trans-unit>
        <trans-unit id="7c272260b375e1ccab2d817d2cd35ee28b31a83e" translate="yes" xml:space="preserve">
          <source>Generate the site certificate</source>
          <target state="translated">生成网站证书</target>
        </trans-unit>
        <trans-unit id="b3d3a62176dbe0c3246ec4b2d1ced8127390badd" translate="yes" xml:space="preserve">
          <source>Generate the site certificate and sign it with the site key.</source>
          <target state="translated">生成站点证书,并用站点密钥进行签名。</target>
        </trans-unit>
        <trans-unit id="b7fd4895a32470e25e3802e5c3139cbd4b19b392" translate="yes" xml:space="preserve">
          <source>Generate the site key.</source>
          <target state="translated">生成网站密钥。</target>
        </trans-unit>
        <trans-unit id="3e9beae38e2b0f5611eb0548d6198f83dccdb896" translate="yes" xml:space="preserve">
          <source>Generate your own TLS certificate and key as &lt;code&gt;server.crt&lt;/code&gt; and &lt;code&gt;server.key&lt;/code&gt;, and put them in the directory &lt;code&gt;/tmp/server-configdir&lt;/code&gt;.</source>
          <target state="translated">生成自己的TLS证书并将其作为 &lt;code&gt;server.crt&lt;/code&gt; 和 &lt;code&gt;server.key&lt;/code&gt; 并将其放在目录 &lt;code&gt;/tmp/server-configdir&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="b6d4b70624c8f8cb1840cb126b8471f29fbb6e94" translate="yes" xml:space="preserve">
          <source>Generic strings or binary content (up to 500 kb in size)</source>
          <target state="translated">通用字符串或二进制内容(大小不超过500 kb)</target>
        </trans-unit>
        <trans-unit id="84aa5e8b4b4496a613e746991ecd541d212717fe" translate="yes" xml:space="preserve">
          <source>Get &lt;a href=&quot;../../compose/index&quot;&gt;Docker Compose&lt;/a&gt; as described in &lt;a href=&quot;../part3/index#prerequisites&quot;&gt;Part 3 prerequisites&lt;/a&gt;.</source>
          <target state="translated">按照&lt;a href=&quot;../part3/index#prerequisites&quot;&gt;第3部分先决条件中的说明&lt;/a&gt;获取&lt;a href=&quot;../../compose/index&quot;&gt;Docker Compose&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f4c96200d0014e5447cd05ad327821572f12996d" translate="yes" xml:space="preserve">
          <source>Get &lt;a href=&quot;../../compose/index&quot;&gt;Docker Compose&lt;/a&gt;. On &lt;a href=&quot;https://docs.docker.com/docker-for-mac/&quot;&gt;Docker Desktop for Mac&lt;/a&gt; and &lt;a href=&quot;https://docs.docker.com/docker-for-windows/&quot;&gt;Docker Desktop for Windows&lt;/a&gt; it&amp;rsquo;s pre-installed, so you&amp;rsquo;re good-to-go. On Linux systems you need to &lt;a href=&quot;https://github.com/docker/compose/releases&quot;&gt;install it directly&lt;/a&gt;. On pre Windows 10 systems &lt;em&gt;without Hyper-V&lt;/em&gt;, use &lt;a href=&quot;https://docs.docker.com/toolbox/overview/&quot;&gt;Docker Toolbox&lt;/a&gt;.</source>
          <target state="translated">获取&lt;a href=&quot;../../compose/index&quot;&gt;Docker Compose&lt;/a&gt;。在&lt;a href=&quot;https://docs.docker.com/docker-for-mac/&quot;&gt;适用于Mac的&lt;/a&gt;&lt;a href=&quot;https://docs.docker.com/docker-for-windows/&quot;&gt;Docker桌面&lt;/a&gt;和适用于Windows的Docker桌面上，它已预先安装，因此您一路走好。在Linux系统上，您需要&lt;a href=&quot;https://github.com/docker/compose/releases&quot;&gt;直接安装它&lt;/a&gt;。在&lt;em&gt;没有Hyper-V的&lt;/em&gt; Windows 10之前的系统上，使用&lt;a href=&quot;https://docs.docker.com/toolbox/overview/&quot;&gt;Docker Toolbox&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e92e57538757fb219c9b7b5b310c2c4df25876b3" translate="yes" xml:space="preserve">
          <source>Get &lt;a href=&quot;../../machine/overview/index&quot;&gt;Docker Machine&lt;/a&gt; as described in &lt;a href=&quot;../part4/index#prerequisites&quot;&gt;Part 4 prerequisites&lt;/a&gt;.</source>
          <target state="translated">按照&lt;a href=&quot;../part4/index#prerequisites&quot;&gt;第4部分先决条件中&lt;/a&gt;所述获得&lt;a href=&quot;../../machine/overview/index&quot;&gt;Docker Machine&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d848914b918a40e284f9a6c187a2f7524984ea72" translate="yes" xml:space="preserve">
          <source>Get &lt;a href=&quot;../../machine/overview/index&quot;&gt;Docker Machine&lt;/a&gt;, which is pre-installed with &lt;a href=&quot;https://docs.docker.com/docker-for-mac/&quot;&gt;Docker Desktop for Mac&lt;/a&gt; and &lt;a href=&quot;https://docs.docker.com/docker-for-windows/&quot;&gt;Docker Desktop for Windows&lt;/a&gt;, but on Linux systems you need to &lt;a href=&quot;../../machine/install-machine/index#installing-machine-directly&quot;&gt;install it directly&lt;/a&gt;. On pre Windows 10 systems &lt;em&gt;without Hyper-V&lt;/em&gt;, as well as Windows 10 Home, use &lt;a href=&quot;https://docs.docker.com/toolbox/overview/&quot;&gt;Docker Toolbox&lt;/a&gt;.</source>
          <target state="translated">获取&lt;a href=&quot;../../machine/overview/index&quot;&gt;泊坞窗机&lt;/a&gt;，它预装了&lt;a href=&quot;https://docs.docker.com/docker-for-mac/&quot;&gt;码头工人Mac版桌面&lt;/a&gt;和&lt;a href=&quot;https://docs.docker.com/docker-for-windows/&quot;&gt;码头工人Windows版桌面&lt;/a&gt;，但在Linux系统上，你需要&lt;a href=&quot;../../machine/install-machine/index#installing-machine-directly&quot;&gt;直接安装&lt;/a&gt;。在&lt;em&gt;没有Hyper-V的&lt;/em&gt; Windows 10之前的系统以及Windows 10 Home上，使用&lt;a href=&quot;https://docs.docker.com/toolbox/overview/&quot;&gt;Docker Toolbox&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7044ca924f3af77aea0fd427f6d2cd3e3eb6163e" translate="yes" xml:space="preserve">
          <source>Get Docker Desktop for Mac</source>
          <target state="translated">获取Docker Desktop for Mac</target>
        </trans-unit>
        <trans-unit id="36ad2afd445c27d250be201f5062f127fe72e320" translate="yes" xml:space="preserve">
          <source>Get Docker Desktop for Windows</source>
          <target state="translated">获取Docker Desktop for Windows</target>
        </trans-unit>
        <trans-unit id="bd2cb051773a703fdbabd8c09f218722870e6d61" translate="yes" xml:space="preserve">
          <source>Get Started</source>
          <target state="translated">开始吧</target>
        </trans-unit>
        <trans-unit id="e186d37ba9bba6bfe1735621fecd43b938379a65" translate="yes" xml:space="preserve">
          <source>Get Started, Part 1: Orientation and setup</source>
          <target state="translated">开始,第1部分。定位和设置</target>
        </trans-unit>
        <trans-unit id="e04cbebaf151dd7c1cc89c21c716d0a01144a5ff" translate="yes" xml:space="preserve">
          <source>Get Started, Part 2: Containers</source>
          <target state="translated">入门,第二部分:容器</target>
        </trans-unit>
        <trans-unit id="c37a2f65b8f99944cd4afc0f292a8281f1add106" translate="yes" xml:space="preserve">
          <source>Get Started, Part 3: Services</source>
          <target state="translated">开始,第3部分:服务</target>
        </trans-unit>
        <trans-unit id="9a3bb4baee10d77712235d6acac26914abbbb6b5" translate="yes" xml:space="preserve">
          <source>Get Started, Part 4: Swarms</source>
          <target state="translated">入门,第4部分:蜂群</target>
        </trans-unit>
        <trans-unit id="ae746fa3b4aa275a285783491df8edc3a0912cd7" translate="yes" xml:space="preserve">
          <source>Get Started, Part 5: Stacks</source>
          <target state="translated">入门,第5部分:堆栈</target>
        </trans-unit>
        <trans-unit id="4eaade9a3a677a9fbd6e1e6ac364a767b93d4bc9" translate="yes" xml:space="preserve">
          <source>Get Started, Part 6: Deploy your app</source>
          <target state="translated">入门,第6部分:部署您的应用程序</target>
        </trans-unit>
        <trans-unit id="3ede1568d144c700c3e012f506b9d3877efd990d" translate="yes" xml:space="preserve">
          <source>Get a subsection in JSON format</source>
          <target state="translated">以JSON格式获取一个分节</target>
        </trans-unit>
        <trans-unit id="5210929c766ff01492bc1f70a359c42c26050ae4" translate="yes" xml:space="preserve">
          <source>Get an instance&amp;rsquo;s IP address</source>
          <target state="translated">获取实例的IP地址</target>
        </trans-unit>
        <trans-unit id="4c53bc79a4a51c1e5bcbef9d31e14a94056a69d2" translate="yes" xml:space="preserve">
          <source>Get an instance&amp;rsquo;s MAC address</source>
          <target state="translated">获取实例的MAC地址</target>
        </trans-unit>
        <trans-unit id="e7d4d639dd0346ed0aec37d0b1168d53212a7422" translate="yes" xml:space="preserve">
          <source>Get an instance&amp;rsquo;s image name</source>
          <target state="translated">获取实例的图像名称</target>
        </trans-unit>
        <trans-unit id="b9df4a142391513af1cda904bbcc28118ddc05d9" translate="yes" xml:space="preserve">
          <source>Get an instance&amp;rsquo;s log path</source>
          <target state="translated">获取实例的日志路径</target>
        </trans-unit>
        <trans-unit id="a9fd4f840853dcaff47bd510d3bb693667e5c3a3" translate="yes" xml:space="preserve">
          <source>Get details about signatures for a single image tag</source>
          <target state="translated">获取单个图像标签的签名详情。</target>
        </trans-unit>
        <trans-unit id="6ef476727ae5e958231f09957404ec41c8f74005" translate="yes" xml:space="preserve">
          <source>Get details about signatures for all image tags in a repository</source>
          <target state="translated">获取关于资源库中所有图像标签的签名的详细信息。</target>
        </trans-unit>
        <trans-unit id="14402f077a13563c33e5022ae8ca14df73a44f18" translate="yes" xml:space="preserve">
          <source>Get details about signatures for multiple images</source>
          <target state="translated">获取多张图片的签名详情</target>
        </trans-unit>
        <trans-unit id="5d7815759af07d1298af6588ab012f3ed2fac980" translate="yes" xml:space="preserve">
          <source>Get info about &lt;code&gt;volume_name&lt;/code&gt;.</source>
          <target state="translated">获取有关 &lt;code&gt;volume_name&lt;/code&gt; 的信息。</target>
        </trans-unit>
        <trans-unit id="2a19131a48eb6dc17715d33d02e0cc5e8ddec8fd" translate="yes" xml:space="preserve">
          <source>Get low-level details about signatures for a single image tag</source>
          <target state="translated">获取单个图像标签的签名的低级详细信息。</target>
        </trans-unit>
        <trans-unit id="db1ec7a2845e2244df7d5d19d2567d486f85e13f" translate="yes" xml:space="preserve">
          <source>Get real time events from the server</source>
          <target state="translated">从服务器获取实时事件</target>
        </trans-unit>
        <trans-unit id="7a7297b58ab1de2b76a9103dc28b7229a37b8298" translate="yes" xml:space="preserve">
          <source>Get started walkthrough</source>
          <target state="translated">开始演练</target>
        </trans-unit>
        <trans-unit id="1e84ef7f57886512afa70721896cc6c72b9a8842" translate="yes" xml:space="preserve">
          <source>Get started with Django</source>
          <target state="translated">开始使用Django</target>
        </trans-unit>
        <trans-unit id="b8f7d03be1c8fadeb4ffa872f1ab303d57e50bdc" translate="yes" xml:space="preserve">
          <source>Get started with Docker</source>
          <target state="translated">开始使用Docker</target>
        </trans-unit>
        <trans-unit id="c21a67cc0c7acb6f66cc7a8afec9533ad681810a" translate="yes" xml:space="preserve">
          <source>Get started with Docker Compose</source>
          <target state="translated">开始使用Docker Compose</target>
        </trans-unit>
        <trans-unit id="9c94e0f27a1e8c04eacacb0138b7680805b450ca" translate="yes" xml:space="preserve">
          <source>Get started with Docker Machine and a local VM</source>
          <target state="translated">开始使用Docker Machine和本地虚拟机。</target>
        </trans-unit>
        <trans-unit id="0fd9d044ce1c76035c145f8b9255d6bb92d070b8" translate="yes" xml:space="preserve">
          <source>Get started with Docker Notary</source>
          <target state="translated">开始使用Docker公证</target>
        </trans-unit>
        <trans-unit id="66e6c54220742cc2f3ece588945898ae0d67d90d" translate="yes" xml:space="preserve">
          <source>Get started with Rails</source>
          <target state="translated">开始使用Rails</target>
        </trans-unit>
        <trans-unit id="8ec8e9931375e581eed537fe9a88b69298c9782a" translate="yes" xml:space="preserve">
          <source>Get started with WordPress</source>
          <target state="translated">开始使用WordPress</target>
        </trans-unit>
        <trans-unit id="3e060140b673839d23631cc2a74cb3ad3892c240" translate="yes" xml:space="preserve">
          <source>Get started with the &lt;a href=&quot;../swarm-tutorial/index&quot;&gt;swarm mode tutorial&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../swarm-tutorial/index&quot;&gt;群模式教程&lt;/a&gt;入门。</target>
        </trans-unit>
        <trans-unit id="f05a5ddd29eaada4bfe751d1bfb1f7f04e84d3f1" translate="yes" xml:space="preserve">
          <source>Get started with the &lt;a href=&quot;swarm-tutorial/index&quot;&gt;Swarm mode tutorial&lt;/a&gt;.</source>
          <target state="translated">开始使用&lt;a href=&quot;swarm-tutorial/index&quot;&gt;Swarm模式教程&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4c59991c96ccca837a3fa93098b52499f69d90fa" translate="yes" xml:space="preserve">
          <source>Get the ID of the &lt;code&gt;redis&lt;/code&gt; service task container using &lt;code&gt;docker ps&lt;/code&gt; , so that you can use &lt;code&gt;docker container exec&lt;/code&gt; to connect to the container and read the contents of the secret data file, which defaults to being readable by all and has the same name as the name of the secret. The first command below illustrates how to find the container ID, and the second and third commands use shell completion to do this automatically.</source>
          <target state="translated">使用 &lt;code&gt;docker ps&lt;/code&gt; 获取 &lt;code&gt;redis&lt;/code&gt; 服务任务容器的ID ，以便您可以使用 &lt;code&gt;docker container exec&lt;/code&gt; 连接到该容器并读取秘密数据文件的内容，默认情况下，所有人均可读取该文件，并且名称与秘密的名称。下面的第一个命令说明了如何查找容器ID，第二个和第三个命令使用Shell补全功能自动执行此操作。</target>
        </trans-unit>
        <trans-unit id="94f0a3ca30c26a09921bd85ca1284f4f9722c0b4" translate="yes" xml:space="preserve">
          <source>Get the ID of the &lt;code&gt;redis&lt;/code&gt; service task container using &lt;code&gt;docker ps&lt;/code&gt;, so that you can use &lt;code&gt;docker container exec&lt;/code&gt; to connect to the container and read the contents of the config data file, which defaults to being readable by all and has the same name as the name of the config. The first command below illustrates how to find the container ID, and the second and third commands use shell completion to do this automatically.</source>
          <target state="translated">使用 &lt;code&gt;docker ps&lt;/code&gt; 获取 &lt;code&gt;redis&lt;/code&gt; 服务任务容器的ID ，以便您可以使用 &lt;code&gt;docker container exec&lt;/code&gt; 连接到该容器并读取config数据文件的内容，该文件默认为所有人可读，并且名称与配置名称。下面的第一个命令说明了如何查找容器ID，第二个和第三个命令使用Shell补全功能自动执行此操作。</target>
        </trans-unit>
        <trans-unit id="ef0832bef0f49e9019bc95e4605edeb6f049037d" translate="yes" xml:space="preserve">
          <source>Get the IP address of one or more machines.</source>
          <target state="translated">获取一台或多台机器的IP地址。</target>
        </trans-unit>
        <trans-unit id="18eae5bee6ace7ee65360105354f98fba9cfdce8" translate="yes" xml:space="preserve">
          <source>Get the URL of a host</source>
          <target state="translated">获取主机的URL</target>
        </trans-unit>
        <trans-unit id="d1188ef91b1987164fb8cd0052b601fc35081294" translate="yes" xml:space="preserve">
          <source>Get the environment commands for your new VM.</source>
          <target state="translated">获取新虚拟机的环境命令。</target>
        </trans-unit>
        <trans-unit id="2ad4f5d16a2a7ce9e6d16e7fe9e74aa9dcb32c78" translate="yes" xml:space="preserve">
          <source>Get the exit code of the container&amp;rsquo;s command</source>
          <target state="translated">获取容器命令的退出代码</target>
        </trans-unit>
        <trans-unit id="8615625f97a0b98819c91a9b2eca4df0a06f1db4" translate="yes" xml:space="preserve">
          <source>Get the host IP address.</source>
          <target state="translated">获取主机IP地址。</target>
        </trans-unit>
        <trans-unit id="02e2509bb867a569bd388729cd7fed146708cacb" translate="yes" xml:space="preserve">
          <source>Get the list of capabilities the driver supports.</source>
          <target state="translated">获取驱动程序支持的功能列表。</target>
        </trans-unit>
        <trans-unit id="ae90d7ce668b1b8a66a8433bc9835d268c6c4614" translate="yes" xml:space="preserve">
          <source>Get the list of volumes registered with the plugin.</source>
          <target state="translated">获取插件注册的卷列表。</target>
        </trans-unit>
        <trans-unit id="898005b1d4ad39e7ac43ddb5fe734cfecec3d162" translate="yes" xml:space="preserve">
          <source>Get the server version</source>
          <target state="translated">获取服务器版本</target>
        </trans-unit>
        <trans-unit id="5482546719a2f8ff5f248751115473d3e74aec3a" translate="yes" xml:space="preserve">
          <source>Get the service ID for the one service in our application:</source>
          <target state="translated">在我们的应用中获取一个服务的服务ID。</target>
        </trans-unit>
        <trans-unit id="f472550d578ffa0c776aa16121f1cc9378b1bfda" translate="yes" xml:space="preserve">
          <source>Get your API key and API secret key from &lt;a href=&quot;https://portal.exoscale.com/account/api&quot;&gt;API details&lt;/a&gt; and pass them to &lt;code&gt;machine create&lt;/code&gt; with the &lt;code&gt;--exoscale-api-key&lt;/code&gt; and &lt;code&gt;--exoscale-api-secret-key&lt;/code&gt; options.</source>
          <target state="translated">从&lt;a href=&quot;https://portal.exoscale.com/account/api&quot;&gt;API详细信息中&lt;/a&gt;获取API密钥和API秘密密钥，然后使用 &lt;code&gt;--exoscale-api-key&lt;/code&gt; 和 &lt;code&gt;--exoscale-api-secret-key&lt;/code&gt; 选项将它们传递给 &lt;code&gt;machine create&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="010b85ad56b34c34c7c2a3b2436c740e30428ed5" translate="yes" xml:space="preserve">
          <source>Getting Started</source>
          <target state="translated">入门</target>
        </trans-unit>
        <trans-unit id="060f712c74598ce01e86d56802d9344d8ed68bb7" translate="yes" xml:space="preserve">
          <source>Getting help</source>
          <target state="translated">获得帮助</target>
        </trans-unit>
        <trans-unit id="5fee613895554a60e080e31e897ab64e340c7caa" translate="yes" xml:space="preserve">
          <source>Getting started with swarm mode</source>
          <target state="translated">开始使用蜂群模式</target>
        </trans-unit>
        <trans-unit id="3725e116ef7699c247070b569d34e054ac77520a" translate="yes" xml:space="preserve">
          <source>Git URLs accept context configuration in their fragment section, separated by a colon &lt;code&gt;:&lt;/code&gt;. The first part represents the reference that Git will check out, and can be either a branch, a tag, or a remote reference. The second part represents a subdirectory inside the repository that will be used as a build context.</source>
          <target state="translated">GIT中的URL接受他们的片段部分的上下文配置，由冒号分隔 &lt;code&gt;:&lt;/code&gt; 。第一部分代表Git将检出的引用，可以是分支，标签或远程引用。第二部分表示存储库中的子目录，该子目录将用作构建上下文。</target>
        </trans-unit>
        <trans-unit id="d038357ab3d653647d06a0792a301d7cb2c13e16" translate="yes" xml:space="preserve">
          <source>Git repositories</source>
          <target state="translated">Git仓库</target>
        </trans-unit>
        <trans-unit id="b870f36e8909aee8a17fc389e13325ffe873b477" translate="yes" xml:space="preserve">
          <source>Give a service access to volumes or bind mounts</source>
          <target state="translated">赋予服务访问卷或绑定挂载的权限</target>
        </trans-unit>
        <trans-unit id="e6989574f6df79f1942a08bba1b3af685ec95e1f" translate="yes" xml:space="preserve">
          <source>Give extended privileges to the command</source>
          <target state="translated">赋予命令扩展权限</target>
        </trans-unit>
        <trans-unit id="7433491d9f3abb149ebda0f079424ca0a931a71b" translate="yes" xml:space="preserve">
          <source>Give extended privileges to this container</source>
          <target state="translated">赋予该容器扩展权限</target>
        </trans-unit>
        <trans-unit id="a75a3b80364714530a385b4524745d7238ef1701" translate="yes" xml:space="preserve">
          <source>Give it the name &lt;code&gt;myswitch&lt;/code&gt;, and check the box to share your host machine&amp;rsquo;s active network adapter</source>
          <target state="translated">将其命名为 &lt;code&gt;myswitch&lt;/code&gt; ，然后选中该框以共享主机的活动网络适配器</target>
        </trans-unit>
        <trans-unit id="3a9862caca630b85a692de1def5ee3b57f18015d" translate="yes" xml:space="preserve">
          <source>Give the token a descriptive name, make sure the &lt;strong&gt;Write (Optional)&lt;/strong&gt; checkbox is checked, and click &lt;strong&gt;Generate Token&lt;/strong&gt;.</source>
          <target state="translated">为令牌指定一个描述性名称，确保选中了&lt;strong&gt;Write（可选）&lt;/strong&gt;复选框，然后单击&lt;strong&gt;Generate Token&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="876588c1e5c87839f4b0e02744134f58dd07b63b" translate="yes" xml:space="preserve">
          <source>Give your environment a quick test run to make sure you&amp;rsquo;re all set up:</source>
          <target state="translated">快速测试您的环境，以确保所有设置均已完成：</target>
        </trans-unit>
        <trans-unit id="9d73af8828b766ef32cac0eb25567d1e9ba116f1" translate="yes" xml:space="preserve">
          <source>Given an image:</source>
          <target state="translated">给定一个图像:</target>
        </trans-unit>
        <trans-unit id="bee67862de9af89f58518498619f0ef459e35039" translate="yes" xml:space="preserve">
          <source>Globbing Syntax</source>
          <target state="translated">Globbing语法</target>
        </trans-unit>
        <trans-unit id="51665287f81ffa4c55e53b82d779749b7e127ae8" translate="yes" xml:space="preserve">
          <source>GlusterFS plugin</source>
          <target state="translated">GlusterFS插件</target>
        </trans-unit>
        <trans-unit id="0673ed540071b11968320d37b65ee20232768f15" translate="yes" xml:space="preserve">
          <source>Go ahead and write a blog post or two and install a WordPress plugin or theme to verify that WordPress is fully operational and its state is saved across service restarts.</source>
          <target state="translated">去写一两篇博文,并安装一个WordPress插件或主题,以验证WordPress是否可以完全运行,并且其状态会在服务重启时保存。</target>
        </trans-unit>
        <trans-unit id="3b12ed14419e3065935d1ed30aac79858640ed96" translate="yes" xml:space="preserve">
          <source>Go back to your &lt;code&gt;trustsandbox&lt;/code&gt; terminal.</source>
          <target state="translated">返回您的 &lt;code&gt;trustsandbox&lt;/code&gt; 终端。</target>
        </trans-unit>
        <trans-unit id="79f8215efb8d16aacf1e0a78c75b8fc26310ab18" translate="yes" xml:space="preserve">
          <source>Go to &lt;a href=&quot;http://localhost:8080&quot;&gt;localhost:8080&lt;/a&gt; to access your app in a web browser.</source>
          <target state="translated">转到&lt;a href=&quot;http://localhost:8080&quot;&gt;localhost：8080&lt;/a&gt;在Web浏览器中访问您的应用程序。</target>
        </trans-unit>
        <trans-unit id="54b8eba47fb94e0ff52889824712c3de0abeef79" translate="yes" xml:space="preserve">
          <source>Go to &lt;strong&gt;Services -&amp;gt; VPC -&amp;gt; Subnets&lt;/strong&gt;. Examine the &lt;em&gt;Availability Zone&lt;/em&gt; column to verify that zone &lt;code&gt;a&lt;/code&gt; exists and matches your VPC ID. For example, &lt;code&gt;us-east1-a&lt;/code&gt; is in the &lt;code&gt;a&lt;/code&gt; availability zone. If the &lt;code&gt;a&lt;/code&gt; zone is not present, you can create a new subnet in that zone or specify a different zone when you create the machine.</source>
          <target state="translated">转到&lt;strong&gt;服务-&amp;gt; VPC-&amp;gt;子网&lt;/strong&gt;。检查&amp;ldquo; &lt;code&gt;a&lt;/code&gt; &lt;em&gt;区域&amp;rdquo;&lt;/em&gt;列以确认区域a存在并与您的VPC ID匹配。例如， &lt;code&gt;us-east1-a&lt;/code&gt; 是在 &lt;code&gt;a&lt;/code&gt; 可用性区域。如果 &lt;code&gt;a&lt;/code&gt; 区域不存在，您可以创建在该区域新的子网或当您创建计算机指定一个不同的区域。</target>
        </trans-unit>
        <trans-unit id="cb92c8eea2f5637483684d9bc86d74a3c03ab9f4" translate="yes" xml:space="preserve">
          <source>Go to &lt;strong&gt;Services -&amp;gt; VPC -&amp;gt; Your VPCs&lt;/strong&gt;.</source>
          <target state="translated">转到&lt;strong&gt;服务-&amp;gt; VPC-&amp;gt;您的VPC&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="25b3f789dd5db1aa2a5f2957dc9fbac20e1090ee" translate="yes" xml:space="preserve">
          <source>Go to that URL in a web browser to see the display content served up on a web page.</source>
          <target state="translated">在网页浏览器中转到该URL,查看网页上的显示内容。</target>
        </trans-unit>
        <trans-unit id="3dd09d5fb018bca9576f60e0dc9a8d8f40a80350" translate="yes" xml:space="preserve">
          <source>Go to the AWS EC2 Dashboard to view the new instance.</source>
          <target state="translated">转到AWS EC2仪表板查看新实例。</target>
        </trans-unit>
        <trans-unit id="040e3056c8cf0dc8fa50e5ec069563aff7a9edac" translate="yes" xml:space="preserve">
          <source>Go to the DigitalOcean administrator console and click &lt;strong&gt;API&lt;/strong&gt; in the header.</source>
          <target state="translated">转到DigitalOcean管理员控制台，然后单击标题中的&lt;strong&gt;API&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="b009f6740b84b84125c84faf77194c54c608c7fa" translate="yes" xml:space="preserve">
          <source>Go to the DigitalOcean console to view the new Droplet.</source>
          <target state="translated">前往DigitalOcean控制台查看新的Droplet。</target>
        </trans-unit>
        <trans-unit id="13de1abe2b3daaf07f706ccac14f86e87ef9fb92" translate="yes" xml:space="preserve">
          <source>Go&amp;rsquo;s &lt;a href=&quot;http://golang.org/pkg/text/template/&quot;&gt;text/template&lt;/a&gt; package describes all the details of the format.</source>
          <target state="translated">Go的&lt;a href=&quot;http://golang.org/pkg/text/template/&quot;&gt;文本/模板&lt;/a&gt;包描述了格式的所有细节。</target>
        </trans-unit>
        <trans-unit id="64dba342f6f438adc0ed8471f6544dba7deb8072" translate="yes" xml:space="preserve">
          <source>Go&amp;rsquo;s &lt;a href=&quot;https://golang.org/pkg/text/template/&quot;&gt;text/template&lt;/a&gt; package describes all the details of the format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65d44810feafd2c523c653a0858f6ce81d6535da" translate="yes" xml:space="preserve">
          <source>Good places to start working with Docker Machine and swarm mode are these tutorials:</source>
          <target state="translated">开始使用Docker Machine和蜂群模式的好地方是这些教程。</target>
        </trans-unit>
        <trans-unit id="d1f877ebab5e3608eee1d8de6deec710e65ac7e2" translate="yes" xml:space="preserve">
          <source>Google Compute Engine</source>
          <target state="translated">谷歌计算引擎</target>
        </trans-unit>
        <trans-unit id="f66442be901b04e358fdfdd60b4ff5628affd7df" translate="yes" xml:space="preserve">
          <source>Google Compute Engine supports &lt;a href=&quot;https://cloud.google.com/compute/docs/images#image_families&quot;&gt;image families&lt;/a&gt;. An image family is like an image alias that always points to the latest image in the family. To create an instance from an image family, set &lt;code&gt;--google-machine-image&lt;/code&gt; to the family&amp;rsquo;s URL.</source>
          <target state="translated">Google Compute Engine支持&lt;a href=&quot;https://cloud.google.com/compute/docs/images#image_families&quot;&gt;图像系列&lt;/a&gt;。图像系列就像一个图像别名，该别名始终指向该系列中的最新图像。要从图像系列创建实例，请将 &lt;code&gt;--google-machine-image&lt;/code&gt; 设置为图像系列的URL。</target>
        </trans-unit>
        <trans-unit id="4066ae2506fa1adfdab8e5053cdca853bfac7c3b" translate="yes" xml:space="preserve">
          <source>Got a &amp;ldquo;Permission denied&amp;rdquo; error?</source>
          <target state="translated">遇到&amp;ldquo;权限被拒绝&amp;rdquo;错误？</target>
        </trans-unit>
        <trans-unit id="8fd864633a25913d297702dc3500c831db931438" translate="yes" xml:space="preserve">
          <source>Grab (copy to clipboard) the generated big long hex string and store it somewhere safe.</source>
          <target state="translated">抓取(复制到剪贴板)生成的大长十六进制字符串,并将其存储在安全的地方。</target>
        </trans-unit>
        <trans-unit id="fd9b17c8439254dd265aae1ceffe1ae2a6ef5481" translate="yes" xml:space="preserve">
          <source>Grab your subscription ID from the portal, then run &lt;code&gt;docker-machine create&lt;/code&gt; with these details:</source>
          <target state="translated">从门户获取您的订阅ID，然后使用以下详细信息运行 &lt;code&gt;docker-machine create&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="9616efbfa90ef0c39003a46389ac5c069696f704" translate="yes" xml:space="preserve">
          <source>Grant a service access to secrets</source>
          <target state="translated">授予服务访问秘密的权利</target>
        </trans-unit>
        <trans-unit id="ecfac8e8a28f05ddc0d3b89986dc4ef8512223f2" translate="yes" xml:space="preserve">
          <source>Grant access to configs on a per-service basis using the per-service &lt;code&gt;configs&lt;/code&gt; configuration. Two different syntax variants are supported.</source>
          <target state="translated">使用按服务 &lt;code&gt;configs&lt;/code&gt; 配置，按服务授予对配置的访问权限。支持两种不同的语法变体。</target>
        </trans-unit>
        <trans-unit id="b8b79a06a8546379b7fbe5f7a4c7db669716bce5" translate="yes" xml:space="preserve">
          <source>Grant access to secrets on a per-service basis using the per-service &lt;code&gt;secrets&lt;/code&gt; configuration. Two different syntax variants are supported.</source>
          <target state="translated">使用按服务 &lt;code&gt;secrets&lt;/code&gt; 配置，按服务授予对机密的访问权限。支持两种不同的语法变体。</target>
        </trans-unit>
        <trans-unit id="d0231b9eadfacd6a247112b37639e1fa32145988" translate="yes" xml:space="preserve">
          <source>Grant all permissions necessary to run the plugin</source>
          <target state="translated">授予运行该插件所需的所有权限</target>
        </trans-unit>
        <trans-unit id="2bcc14f36a87e86c092e1201e7bf7f29a6d21399" translate="yes" xml:space="preserve">
          <source>Graylog Extended Log Format (GELF) logging driver for Docker. Writes log messages to a GELF endpoint likeGraylog or Logstash.</source>
          <target state="translated">用于Docker的Graylog扩展日志格式(GELF)日志驱动。将日志信息写入Graylog或Logstash等GELF端点。</target>
        </trans-unit>
        <trans-unit id="bb63d1f28fe86f7128721a1b7924f1deaa9aee49" translate="yes" xml:space="preserve">
          <source>Great for modern cloud-based apps, such as web apps, IoT apps, and mobile backends</source>
          <target state="translated">非常适用于现代基于云的应用程序,如Web应用程序、IoT应用程序和移动后台</target>
        </trans-unit>
        <trans-unit id="5b710e16770052f7ebcf2f41f0cf17bdc1c752a6" translate="yes" xml:space="preserve">
          <source>HBM plugin</source>
          <target state="translated">HBM插件</target>
        </trans-unit>
        <trans-unit id="db6e7e402e1777867190b31a1ec0305a7cf5621e" translate="yes" xml:space="preserve">
          <source>HEALTHCHECK</source>
          <target state="translated">HEALTHCHECK</target>
        </trans-unit>
        <trans-unit id="02336c6e968613f3651f7a0b0e98956801ec5ab3" translate="yes" xml:space="preserve">
          <source>HPE 3Par Volume Plugin</source>
          <target state="translated">HPE 3 每卷插件</target>
        </trans-unit>
        <trans-unit id="f40b27d6b8b9a4fc3827264c1da16a04ecf4d094" translate="yes" xml:space="preserve">
          <source>HTTP</source>
          <target state="translated">HTTP</target>
        </trans-unit>
        <trans-unit id="a9c2fd09a4d24e664f72626ea645e59cbde69cb7" translate="yes" xml:space="preserve">
          <source>HTTP client timeout (in seconds)</source>
          <target state="translated">HTTP客户端超时(秒)</target>
        </trans-unit>
        <trans-unit id="cc5eaf888d33fcb382633877f14e39b9070734c2" translate="yes" xml:space="preserve">
          <source>Handling transient errors</source>
          <target state="translated">处理瞬时错误</target>
        </trans-unit>
        <trans-unit id="21e5415e1df07bb12a6bc3ab9d69a439dc136160" translate="yes" xml:space="preserve">
          <source>Handshake API</source>
          <target state="translated">握手API</target>
        </trans-unit>
        <trans-unit id="fe37da07f8dfc25e0b6cf2fd7d1c842f4a7b7c32" translate="yes" xml:space="preserve">
          <source>Hardware storage and signing</source>
          <target state="translated">硬件存储和签署</target>
        </trans-unit>
        <trans-unit id="c1ed7863787063f12356455a8184b2640dd2fdac" translate="yes" xml:space="preserve">
          <source>Has access to the &lt;code&gt;mysql_password&lt;/code&gt; secret, but specifies a different target file name within the container. The WordPress container uses the mount point &lt;code&gt;/run/secrets/wp_db_password&lt;/code&gt;. Also specifies that the secret is not group-or-world-readable, by setting the mode to &lt;code&gt;0400&lt;/code&gt;.</source>
          <target state="translated">可以访问 &lt;code&gt;mysql_password&lt;/code&gt; 密码，但是在容器内指定了另一个目标文件名。WordPress容器使用挂载点 &lt;code&gt;/run/secrets/wp_db_password&lt;/code&gt; 。通过将模式设置为 &lt;code&gt;0400&lt;/code&gt; ，还指定该密码不是组或世界可读的。</target>
        </trans-unit>
        <trans-unit id="ef1491a3661644508c36b0d7d23c4ff24e15cf51" translate="yes" xml:space="preserve">
          <source>Have &lt;a href=&quot;../part5/index#persist-the-data&quot;&gt;the final version of &lt;code&gt;docker-compose.yml&lt;/code&gt; from Part 5&lt;/a&gt; handy.</source>
          <target state="translated">拥有&lt;a href=&quot;../part5/index#persist-the-data&quot;&gt;第5部分中&lt;/a&gt; &lt;code&gt;docker-compose.yml&lt;/code&gt; 的最终版本。</target>
        </trans-unit>
        <trans-unit id="09bc4722141b1ec5aedc45a2ea415bfe8090e584" translate="yes" xml:space="preserve">
          <source>Have Docker Desktop for Windows installed, and running (which requires that virtualization and Hyper-V are enabled, as described in &lt;a href=&quot;https://docs.docker.com/docker-for-windows/install/#what-to-know-before-you-install&quot;&gt;What to know before you install Docker Desktop for Windows&lt;/a&gt;).</source>
          <target state="translated">已安装并运行Windows的Docker桌面（并要求启用虚拟化和Hyper-V，如&lt;a href=&quot;https://docs.docker.com/docker-for-windows/install/#what-to-know-before-you-install&quot;&gt;安装Windows的Docker桌面之前的知识中&lt;/a&gt;所述）。</target>
        </trans-unit>
        <trans-unit id="1e0b821dc3a915c2e03d05bf64e70f05852e72e6" translate="yes" xml:space="preserve">
          <source>Have a copy of your &lt;code&gt;docker-compose.yml&lt;/code&gt; from &lt;a href=&quot;../part3/index&quot;&gt;Part 3&lt;/a&gt; handy.</source>
          <target state="translated">有您的一份 &lt;code&gt;docker-compose.yml&lt;/code&gt; 由&lt;a href=&quot;../part3/index&quot;&gt;3部分&lt;/a&gt;得心应手。</target>
        </trans-unit>
        <trans-unit id="a3386285efc1ceef0ecd4c7ada2a8943827bc33e" translate="yes" xml:space="preserve">
          <source>Have the swarm you created in &lt;a href=&quot;../part4/index&quot;&gt;part 4&lt;/a&gt; running and ready. Run &lt;code&gt;docker-machine ssh myvm1 &quot;docker node ls&quot;&lt;/code&gt; to verify this. If the swarm is up, both nodes report a &lt;code&gt;ready&lt;/code&gt; status. If not, reinitialize the swarm and join the worker as described in &lt;a href=&quot;../part4/index#set-up-your-swarm&quot;&gt;Set up your swarm&lt;/a&gt;.</source>
          <target state="translated">准备好在&lt;a href=&quot;../part4/index&quot;&gt;第4部分中&lt;/a&gt;创建的群集。运行 &lt;code&gt;docker-machine ssh myvm1 &quot;docker node ls&quot;&lt;/code&gt; 进行验证。如果群集已启动，则两个节点都报告 &lt;code&gt;ready&lt;/code&gt; 状态。如果不是，请按照&lt;a href=&quot;../part4/index#set-up-your-swarm&quot;&gt;设置您的群中&lt;/a&gt;所述重新初始化群并加入工作程序。</target>
        </trans-unit>
        <trans-unit id="16de27768464485eca7baed4ed024a40e4ed787e" translate="yes" xml:space="preserve">
          <source>Having any &lt;code&gt;ARG&lt;/code&gt; or &lt;code&gt;ENV&lt;/code&gt; setting in a &lt;code&gt;Dockerfile&lt;/code&gt; evaluates only if there is no Docker Compose entry for &lt;code&gt;environment&lt;/code&gt; or &lt;code&gt;env_file&lt;/code&gt;.</source>
          <target state="translated">有任何 &lt;code&gt;ARG&lt;/code&gt; 或 &lt;code&gt;ENV&lt;/code&gt; 中设置 &lt;code&gt;Dockerfile&lt;/code&gt; 仅评估如果对于没有泊坞撰写进入 &lt;code&gt;environment&lt;/code&gt; 或 &lt;code&gt;env_file&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e5a5f296b206a755b62b27b85d208214380bf627" translate="yes" xml:space="preserve">
          <source>Having connectivity trouble?</source>
          <target state="translated">遇到连接问题?</target>
        </trans-unit>
        <trans-unit id="d57a6933acab2779afec570c23520aa17940df95" translate="yes" xml:space="preserve">
          <source>Having the same consistent state across the cluster means that in case of a failure, any Manager node can pick up the tasks and restore the services to a stable state. For example, if the &lt;em&gt;Leader Manager&lt;/em&gt; which is responsible for scheduling tasks in the cluster dies unexpectedly, any other Manager can pick up the task of scheduling and re-balance tasks to match the desired state.</source>
          <target state="translated">在整个群集中具有相同的一致状态意味着在发生故障的情况下，任何Manager节点都可以接管任务并将服务恢复到稳定状态。例如，如果负责集群中计划任务的&lt;em&gt;领导者管理器&lt;/em&gt;意外死亡，则任何其他管理器都可以接管计划任务并重新平衡任务以匹配所需状态。</target>
        </trans-unit>
        <trans-unit id="4b57f072d4b8b2bf99c146fe81fa8cd33dff3e09" translate="yes" xml:space="preserve">
          <source>Having trouble using SSH? Try the --native-ssh flag</source>
          <target state="translated">使用SSH有问题?尝试使用--native-ssh标志</target>
        </trans-unit>
        <trans-unit id="04d6aa94bf3279a3d0ee296b36a0bb5fad58fc11" translate="yes" xml:space="preserve">
          <source>Here are some commands you might like to run to interact with your swarm and your VMs a bit:</source>
          <target state="translated">下面是一些你可能喜欢运行的命令,以与你的群组和你的虚拟机互动一下。</target>
        </trans-unit>
        <trans-unit id="99bdcb1c2c5082b6ede9f467943ce98e43bf378b" translate="yes" xml:space="preserve">
          <source>Here are some helpful tips for debugging any problems you might be facing with regard to AppArmor.</source>
          <target state="translated">以下是一些有用的提示,用于调试您可能面临的有关 AppArmor 的任何问题。</target>
        </trans-unit>
        <trans-unit id="ecddffb4f5e497bb8fa8e8bdeb858734eab7004a" translate="yes" xml:space="preserve">
          <source>Here in part 4, you deploy this application onto a cluster, running it on multiple machines. Multi-container, multi-machine applications are made possible by joining multiple machines into a &amp;ldquo;Dockerized&amp;rdquo; cluster called a &lt;strong&gt;swarm&lt;/strong&gt;.</source>
          <target state="translated">在第4部分中，您将该应用程序部署到群集上，并在多台计算机上运行。通过将多台机器连接到一个称为&lt;strong&gt;swarm&lt;/strong&gt;的&amp;ldquo; Dockerized&amp;rdquo;集群中，可以实现多容器，多机器的应用程序。</target>
        </trans-unit>
        <trans-unit id="9f31addec83c21d2834a75989acd2414d04370d1" translate="yes" xml:space="preserve">
          <source>Here in part 5, you reach the top of the hierarchy of distributed applications: the &lt;strong&gt;stack&lt;/strong&gt;. A stack is a group of interrelated services that share dependencies, and can be orchestrated and scaled together. A single stack is capable of defining and coordinating the functionality of an entire application (though very complex applications may want to use multiple stacks).</source>
          <target state="translated">在第5部分中，您到达了分布式应用程序层次结构的顶部：&lt;strong&gt;stack&lt;/strong&gt;。堆栈是一组相互依赖的服务，它们共享依赖关系，并且可以一起编排和缩放。单个堆栈能够定义和协调整个应用程序的功能（尽管非常复杂的应用程序可能要使用多个堆栈）。</target>
        </trans-unit>
        <trans-unit id="012876a7a340ca5b1afd429e1c0d91eaaa304fa2" translate="yes" xml:space="preserve">
          <source>Here is a full client configuration file example; click on the top level JSON keys to learn more about the configuration section corresponding to that key:</source>
          <target state="translated">下面是一个完整的客户端配置文件示例,点击顶层的JSON键可以了解该键对应的配置部分。</target>
        </trans-unit>
        <trans-unit id="7934cb19c3918e889329f53cbcc4539c9b7c291a" translate="yes" xml:space="preserve">
          <source>Here is a full server configuration file example; click on the top level JSON keys to learn more about the configuration section corresponding to that key:</source>
          <target state="translated">这里是一个完整的服务器配置文件示例,点击顶层的JSON键可以了解该键对应的配置部分。</target>
        </trans-unit>
        <trans-unit id="55d8059b2e57140a42b334f50b3fb6a67d4378ec" translate="yes" xml:space="preserve">
          <source>Here is a full signer configuration file example; click on the top level JSON keys to learn more about the configuration section corresponding to that key:</source>
          <target state="translated">下面是一个完整的签名器配置文件示例,点击顶层的JSON键可以了解该键对应的配置部分。</target>
        </trans-unit>
        <trans-unit id="8ce4b802d27a7e720ff6deb8c501f5315a463f6f" translate="yes" xml:space="preserve">
          <source>Here is a list of the basic Docker commands from this page, and some related ones if you&amp;rsquo;d like to explore a bit before moving on.</source>
          <target state="translated">这是此页面上的基本Docker命令的列表，以及一些相关的命令（如果您想在继续之前进行一些探索）。</target>
        </trans-unit>
        <trans-unit id="55d655a73f06dc16bfa0632865a0f7f4ca1ede65" translate="yes" xml:space="preserve">
          <source>Here is a sample output for a daemon running on Ubuntu, using the overlay2 storage driver and a node that is part of a 2-node swarm:</source>
          <target state="translated">下面是一个在Ubuntu上运行的守护进程的输出示例,使用overlay2存储驱动和一个2节点群中的节点。</target>
        </trans-unit>
        <trans-unit id="c7954b0b151787613d58a34b0f9121b912e05bce" translate="yes" xml:space="preserve">
          <source>Here is a sample output for a daemon running on Windows Server 2016:</source>
          <target state="translated">下面是运行在Windows Server 2016上的守护进程的输出示例。</target>
        </trans-unit>
        <trans-unit id="a88898c895e3ac08ecadb06044441ba61348ddbb" translate="yes" xml:space="preserve">
          <source>Here is an example &lt;code&gt;.dockerignore&lt;/code&gt; file:</source>
          <target state="translated">这是一个示例 &lt;code&gt;.dockerignore&lt;/code&gt; 文件：</target>
        </trans-unit>
        <trans-unit id="e80d52c3843802fe7c42f5ca5d0541ca26a799b9" translate="yes" xml:space="preserve">
          <source>Here is an example &lt;code&gt;docker-compose.yml&lt;/code&gt; file that limits logging storage:</source>
          <target state="translated">这是一个限制日志存储的示例 &lt;code&gt;docker-compose.yml&lt;/code&gt; 文件：</target>
        </trans-unit>
        <trans-unit id="36f479adec57c169b9c647520b4926c021878e9a" translate="yes" xml:space="preserve">
          <source>Here is an example of configuring a volume as &lt;code&gt;cached&lt;/code&gt;:</source>
          <target state="translated">这是将卷配置为 &lt;code&gt;cached&lt;/code&gt; 的示例：</target>
        </trans-unit>
        <trans-unit id="97c9fbd96289421ab6c378891585175e8eef8be6" translate="yes" xml:space="preserve">
          <source>Here is an example of creating a &lt;code&gt;manager1&lt;/code&gt; node:</source>
          <target state="translated">这是创建一个 &lt;code&gt;manager1&lt;/code&gt; 节点的示例：</target>
        </trans-unit>
        <trans-unit id="c27899e953e5b2b7255f045440c0637ca0d1aa6d" translate="yes" xml:space="preserve">
          <source>Here is an example of creating and pushing a manifest list using a known insecure registry.</source>
          <target state="translated">这里是使用已知的不安全注册表创建和推送清单的一个例子。</target>
        </trans-unit>
        <trans-unit id="440cdc7d803e0dbcc357b3a5ea19529abda92541" translate="yes" xml:space="preserve">
          <source>Here is an example of how to generate a 2048-bit RSA portion key (all RSA keys must be at least 2048 bits):</source>
          <target state="translated">下面是一个如何生成2048位RSA部分密钥的例子(所有RSA密钥必须至少是2048位)。</target>
        </trans-unit>
        <trans-unit id="7bdc9c848647047ed7d2d7fe3829138207944b6d" translate="yes" xml:space="preserve">
          <source>Here is an example of inspecting an image&amp;rsquo;s manifest with the &lt;code&gt;--verbose&lt;/code&gt; flag:</source>
          <target state="translated">这是使用 &lt;code&gt;--verbose&lt;/code&gt; 标志检查图像清单的示例：</target>
        </trans-unit>
        <trans-unit id="07b65c9fe6375351015090eff736c93b63dfe1d1" translate="yes" xml:space="preserve">
          <source>Here is an example of the first case, where a full rebuild is not necessary. Suppose you simply want to change the exposed port on the local host from &lt;code&gt;3000&lt;/code&gt; in our first example to &lt;code&gt;3001&lt;/code&gt;. Make the change to the Compose file to expose port &lt;code&gt;3000&lt;/code&gt; on the container through a new port, &lt;code&gt;3001&lt;/code&gt;, on the host, and save the changes:</source>
          <target state="translated">这是第一种情况的示例，其中不需要完全重建。假设您只想将第一个示例中的本地主机上的公开端口从 &lt;code&gt;3000&lt;/code&gt; 更改为 &lt;code&gt;3001&lt;/code&gt; 。对Compose文件进行更改，以通过主机上的新端口 &lt;code&gt;3001&lt;/code&gt; 暴露容器上的端口 &lt;code&gt;3000&lt;/code&gt; ，并保存更改：</target>
        </trans-unit>
        <trans-unit id="ba49f2c3f1ffc16ecc6a245d0c7583bd659e9a54" translate="yes" xml:space="preserve">
          <source>Here is an example of the output from that command:</source>
          <target state="translated">下面是该命令输出的一个例子。</target>
        </trans-unit>
        <trans-unit id="15e6025132f0a4c10041c40737ddd97da5df8e13" translate="yes" xml:space="preserve">
          <source>Here is an example of using the &lt;code&gt;--virtualbox&lt;/code&gt; driver to create a machine called &lt;code&gt;dev&lt;/code&gt;.</source>
          <target state="translated">这是使用 &lt;code&gt;--virtualbox&lt;/code&gt; 驱动程序创建名为 &lt;code&gt;dev&lt;/code&gt; 的计算机的示例。</target>
        </trans-unit>
        <trans-unit id="16ff1673f1641d410d645595aa0d45e0c6dd1b56" translate="yes" xml:space="preserve">
          <source>Here is example output from this command.</source>
          <target state="translated">以下是该命令的输出示例。</target>
        </trans-unit>
        <trans-unit id="07491c58f4f5a3d57e439662e68c3f55bb138fe4" translate="yes" xml:space="preserve">
          <source>Here is the format of the &lt;code&gt;Dockerfile&lt;/code&gt;:</source>
          <target state="translated">这是 &lt;code&gt;Dockerfile&lt;/code&gt; 的格式：</target>
        </trans-unit>
        <trans-unit id="28728080a5c2f890168c2dd98c7d9c9dc1d05f8b" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s &lt;a href=&quot;https://asciinema.org/a/113837&quot;&gt;a terminal recording of what was covered on this page&lt;/a&gt;:</source>
          <target state="translated">这&lt;a href=&quot;https://asciinema.org/a/113837&quot;&gt;是本页内容的终端记录&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="1f9da5fe71bd0e7e3e60320defdd3e7fbd6b80a2" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s &lt;a href=&quot;https://asciinema.org/a/113840&quot;&gt;a terminal recording of what was covered on this page&lt;/a&gt;:</source>
          <target state="translated">这&lt;a href=&quot;https://asciinema.org/a/113840&quot;&gt;是本页内容的终端记录&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="68f60b76e8ebccba5af3938d805eebbe4d0bdb2a" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s &lt;a href=&quot;https://asciinema.org/a/b5gai4rnflh7r0kie01fx6lip&quot;&gt;a terminal recording of what was covered on this page&lt;/a&gt;:</source>
          <target state="translated">这&lt;a href=&quot;https://asciinema.org/a/b5gai4rnflh7r0kie01fx6lip&quot;&gt;是本页内容的终端记录&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="477271c960ec6590e2772889f54a644af11ed2d0" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s &lt;a href=&quot;https://asciinema.org/a/blkah0l4ds33tbe06y4vkme6g&quot;&gt;a terminal recording of what was covered on this page&lt;/a&gt;:</source>
          <target state="translated">这&lt;a href=&quot;https://asciinema.org/a/blkah0l4ds33tbe06y4vkme6g&quot;&gt;是本页内容的终端记录&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="4a60aafb81a33956550e5d8d73932c7430212d91" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example Compose file defining two custom networks. The &lt;code&gt;proxy&lt;/code&gt; service is isolated from the &lt;code&gt;db&lt;/code&gt; service, because they do not share a network in common - only &lt;code&gt;app&lt;/code&gt; can talk to both.</source>
          <target state="translated">这是一个示例Compose文件，定义了两个自定义网络。该 &lt;code&gt;proxy&lt;/code&gt; 服务从隔离 &lt;code&gt;db&lt;/code&gt; 服务，因为它们不共享一个共同的网络-只有 &lt;code&gt;app&lt;/code&gt; 可以跟两者。</target>
        </trans-unit>
        <trans-unit id="85b112f5a190b366e38d7518baface6ac108a698" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of a repo with two signed tags:</source>
          <target state="translated">这是带有两个签名标签的仓库的示例：</target>
        </trans-unit>
        <trans-unit id="e2055f6e0255723780176607bb54b568a2b8ae05" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of a two-service setup where a database&amp;rsquo;s data directory is shared with another service as a volume so that it can be periodically backed up:</source>
          <target state="translated">这是一个两种服务设置的示例，其中数据库的数据目录与另一个服务作为卷共享，以便可以定期备份它：</target>
        </trans-unit>
        <trans-unit id="88cdc476f3ab52131bfc40dc323a544001123d41" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of using data volumes to share the same data between two CouchDB containers. This could be used for hot upgrades, testing different versions of CouchDB on the same data, etc.</source>
          <target state="translated">这是一个使用数据卷在两个CouchDB容器之间共享相同数据的示例。这可用于热升级，在相同数据上测试CouchDB的不同版本等。</target>
        </trans-unit>
        <trans-unit id="91af00fc7f9bb0964c71855a22e172d5935505c2" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example with signers that are set up by &lt;code&gt;docker trust&lt;/code&gt; commands:</source>
          <target state="translated">这是由 &lt;code&gt;docker trust&lt;/code&gt; 命令设置的签名者的示例：</target>
        </trans-unit>
        <trans-unit id="2b711022bbdbc55a24bd7712dcd9c1fcf0e90f44" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s how it works:</source>
          <target state="translated">运作方式如下：</target>
        </trans-unit>
        <trans-unit id="c740cebd896921b48b41c78db03f5bfa8b754c71" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the full example:</source>
          <target state="translated">这是完整的示例：</target>
        </trans-unit>
        <trans-unit id="d0356d78302bb6e8fb66ba78e3020e8d16c17a79" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;-r&lt;/code&gt; specifies to rotate the key to the remote server.</source>
          <target state="translated">在这里， &lt;code&gt;-r&lt;/code&gt; 指定将密钥旋转到远程服务器。</target>
        </trans-unit>
        <trans-unit id="ffcadc3bbf92f4882971ddc3bc8286e63dfa62c0" translate="yes" xml:space="preserve">
          <source>High Availability</source>
          <target state="translated">高可用性</target>
        </trans-unit>
        <trans-unit id="439b7c90c9fd4f767dce7203b0635ac42a29567a" translate="yes" xml:space="preserve">
          <source>Hit &lt;code&gt;CTRL+C&lt;/code&gt; in your terminal to quit.</source>
          <target state="translated">命中 &lt;code&gt;CTRL+C&lt;/code&gt; 在终端退出。</target>
        </trans-unit>
        <trans-unit id="45edd6c820ea8184641be8c6ffc7e7caedb6173c" translate="yes" xml:space="preserve">
          <source>Horcrux Volume Plugin</source>
          <target state="translated">Horcrux音量插件</target>
        </trans-unit>
        <trans-unit id="aab5eacb530c0786c019f614828a16641a102a70" translate="yes" xml:space="preserve">
          <source>Host bind mounts are non-portable. When you use bind mounts, there is no guarantee that your application runs the same way in development as it does in production.</source>
          <target state="translated">主机绑定挂载是不可移植的。当你使用绑定挂载时,不能保证你的应用程序在开发中的运行方式与在生产中的运行方式相同。</target>
        </trans-unit>
        <trans-unit id="65b2efc41c178618f0bedf23b641c9bcd4c97e2f" translate="yes" xml:space="preserve">
          <source>Host ports and recreating containers</source>
          <target state="translated">主机端口和重新创建集装箱</target>
        </trans-unit>
        <trans-unit id="202ec01f09c75399a78fe08e42800dd93f90bf36" translate="yes" xml:space="preserve">
          <source>HostConfig at API container start</source>
          <target state="translated">API容器启动时的主机配置</target>
        </trans-unit>
        <trans-unit id="637c0912bb07b11e14917a5bfeb1d184bd8ea510" translate="yes" xml:space="preserve">
          <source>Hot logging level reload</source>
          <target state="translated">热记录级别重装</target>
        </trans-unit>
        <trans-unit id="ba1466699cbc973dbd34eef9e410b3dda260263c" translate="yes" xml:space="preserve">
          <source>How Docker manages configs</source>
          <target state="translated">Docker如何管理配置</target>
        </trans-unit>
        <trans-unit id="82832431047da672c6b6e0aa4d743553961bb2b1" translate="yes" xml:space="preserve">
          <source>How Docker manages secrets</source>
          <target state="translated">Docker如何管理秘密</target>
        </trans-unit>
        <trans-unit id="a66c84947c8ea28fef0c53be09e5627880874eaf" translate="yes" xml:space="preserve">
          <source>How do I run multiple copies of a Compose file on the same host?</source>
          <target state="translated">如何在同一台主机上运行多个 Compose 文件的副本?</target>
        </trans-unit>
        <trans-unit id="2a163afa82fce4e6845c7906e025d68a0819e056" translate="yes" xml:space="preserve">
          <source>How mature is the code providing kernel namespaces and private networking? Kernel namespaces were introduced &lt;a href=&quot;http://man7.org/linux/man-pages/man7/namespaces.7.html&quot;&gt;between kernel version 2.6.15 and 2.6.26&lt;/a&gt;. This means that since July 2008 (date of the 2.6.26 release ), namespace code has been exercised and scrutinized on a large number of production systems. And there is more: the design and inspiration for the namespaces code are even older. Namespaces are actually an effort to reimplement the features of &lt;a href=&quot;http://en.wikipedia.org/wiki/OpenVZ&quot;&gt;OpenVZ&lt;/a&gt; in such a way that they could be merged within the mainstream kernel. And OpenVZ was initially released in 2005, so both the design and the implementation are pretty mature.</source>
          <target state="translated">提供内核名称空间和专用网络的代码有多成熟？&lt;a href=&quot;http://man7.org/linux/man-pages/man7/namespaces.7.html&quot;&gt;在内核2.6.15和2.6.26之间&lt;/a&gt;引入了内核名称空间。这意味着自2008年7月（2.6.26版本的发布日期）以来，命名空间代码已在大量生产系统上使用和检查。还有更多：命名空间代码的设计和灵感更老。命名空间实际上是一种重新实现&lt;a href=&quot;http://en.wikipedia.org/wiki/OpenVZ&quot;&gt;OpenVZ&lt;/a&gt;功能的工作，其方式是可以将它们合并到主流内核中。OpenVZ最初于2005年发布，因此设计和实现都相当成熟。</target>
        </trans-unit>
        <trans-unit id="e3030e1443369c6c421a05c5ea6b89daa4a3a7c5" translate="yes" xml:space="preserve">
          <source>How mature is the code providing kernel namespaces and private networking? Kernel namespaces were introduced &lt;a href=&quot;http://man7.org/linux/man-pages/man7/namespaces.7.html&quot;&gt;between kernel version 2.6.15 and 2.6.26&lt;/a&gt;. This means that since July 2008 (date of the 2.6.26 release ), namespace code has been exercised and scrutinized on a large number of production systems. And there is more: the design and inspiration for the namespaces code are even older. Namespaces are actually an effort to reimplement the features of &lt;a href=&quot;https://en.wikipedia.org/wiki/OpenVZ&quot;&gt;OpenVZ&lt;/a&gt; in such a way that they could be merged within the mainstream kernel. And OpenVZ was initially released in 2005, so both the design and the implementation are pretty mature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0410c708959e6513925e2de7870312841cd6bec" translate="yes" xml:space="preserve">
          <source>How nodes work</source>
          <target state="translated">节点如何工作</target>
        </trans-unit>
        <trans-unit id="6291a053d3406b54b13841d59fd826501416c55e" translate="yes" xml:space="preserve">
          <source>How services work</source>
          <target state="translated">服务如何运作</target>
        </trans-unit>
        <trans-unit id="0da23ab51d1ab4795ada6410016178cdc8d9b403" translate="yes" xml:space="preserve">
          <source>How to uninstall Docker Machine</source>
          <target state="translated">如何卸载Docker Machine</target>
        </trans-unit>
        <trans-unit id="91a1b2d44e6a1c5cd7f6b181aab446904c968360" translate="yes" xml:space="preserve">
          <source>However, &lt;a href=&quot;../../engine/swarm/index&quot;&gt;swarm mode&lt;/a&gt;, multi-service applications, and stack files now are fully supported. A stack file is a particular type of &lt;a href=&quot;../compose-file/index&quot;&gt;version 3 Compose file&lt;/a&gt;.</source>
          <target state="translated">但是，现在完全支持&lt;a href=&quot;../../engine/swarm/index&quot;&gt;群集模式&lt;/a&gt;，多服务应用程序和堆栈文件。堆栈文件是&lt;a href=&quot;../compose-file/index&quot;&gt;版本3 Compose文件的&lt;/a&gt;一种特殊类型。</target>
        </trans-unit>
        <trans-unit id="f031193f26ac36c74309aafa88704d719da2d6a2" translate="yes" xml:space="preserve">
          <source>However, because manager nodes use the Raft consensus algorithm to replicate data in a consistent way, they are sensitive to resource starvation. You should isolate managers in your swarm from processes that might block swarm operations like swarm heartbeat or leader elections.</source>
          <target state="translated">然而,由于管理器节点使用 Raft 共识算法以一致的方式复制数据,因此它们对资源饥饿很敏感。您应该将蜂群中的管理器与可能阻止蜂群操作(如蜂群心跳或领导者选举)的进程隔离。</target>
        </trans-unit>
        <trans-unit id="65f57200d36e66f38c273cd3e7dfb95bb769adb2" translate="yes" xml:space="preserve">
          <source>However, for running in production, or if you just want to change those defaults on your development service, you probably want to change those defaults.</source>
          <target state="translated">然而,对于在生产中运行,或者如果你只是想在你的开发服务上改变这些默认值,你可能要改变这些默认值。</target>
        </trans-unit>
        <trans-unit id="cbf5f2495bfd743aa602c4d8b96ea00eaa76401d" translate="yes" xml:space="preserve">
          <source>However, for startup Compose does not wait until a container is &amp;ldquo;ready&amp;rdquo; (whatever that means for your particular application) - only until it&amp;rsquo;s running. There&amp;rsquo;s a good reason for this.</source>
          <target state="translated">但是，对于启动来说，Compose不会等到容器&amp;ldquo;就绪&amp;rdquo;（对于您的特定应用程序意味着什么）后才开始等待-直到它开始运行。这是有充分的理由的。</target>
        </trans-unit>
        <trans-unit id="b3acecaa92b2ee43a0aae52eae9ef58017b4cbe5" translate="yes" xml:space="preserve">
          <source>However, if other tags are signed in the same image repository, &lt;code&gt;docker trust inspect&lt;/code&gt; reports relevant key information.</source>
          <target state="translated">但是，如果其他标签在同一映像存储库中签名，则 &lt;code&gt;docker trust inspect&lt;/code&gt; 报告相关的密钥信息。</target>
        </trans-unit>
        <trans-unit id="ffd46b81539b05de9e468c84ce0730ab95bead1b" translate="yes" xml:space="preserve">
          <source>However, if other tags are signed in the same image repository, &lt;code&gt;docker trust inspect&lt;/code&gt; reports relevant key information:</source>
          <target state="translated">但是，如果其他标签在同一映像存储库中签名，则 &lt;code&gt;docker trust inspect&lt;/code&gt; 报告相关的关键信息：</target>
        </trans-unit>
        <trans-unit id="36b5325b0b79825559cbaba4eae7c2e81dc22ec3" translate="yes" xml:space="preserve">
          <source>However, if you are using negative filtering (testing for the absence of a label or that a label does &lt;em&gt;not&lt;/em&gt; have a specific value), this type of filter does not work with &lt;code&gt;docker image ls&lt;/code&gt; so you cannot easily predict which images will be removed. In addition, the confirmation prompt for &lt;code&gt;docker image prune&lt;/code&gt; always warns that &lt;em&gt;all&lt;/em&gt; dangling images will be removed, even if you are using &lt;code&gt;--filter&lt;/code&gt;.</source>
          <target state="translated">但是，如果使用的是负过滤（测试对于不存在标签的或标签并&lt;em&gt;不&lt;/em&gt;具有特定的值），这种类型的过滤器的不与不工作 &lt;code&gt;docker image ls&lt;/code&gt; 所以不能容易地预测哪些图像将被移除。另外，即使您使用 &lt;code&gt;--filter&lt;/code&gt; ,docker &lt;code&gt;docker image prune&lt;/code&gt; 的确认提示也会始终警告&lt;em&gt;所有&lt;/em&gt;悬空的图像都将被删除。</target>
        </trans-unit>
        <trans-unit id="7918f5f0803cd2dd0e7752acbc665e08d43c2f36" translate="yes" xml:space="preserve">
          <source>However, these variables are deprecated. Use the link alias as a hostname instead.</source>
          <target state="translated">然而,这些变量已被废弃。请使用链接别名作为主机名。</target>
        </trans-unit>
        <trans-unit id="595b50fb2c3c9212f857e0d0b03e5d84a085bdda" translate="yes" xml:space="preserve">
          <source>Hyper-V hypervisor partition-based isolation.</source>
          <target state="translated">Hyper-V管理程序基于分区的隔离。</target>
        </trans-unit>
        <trans-unit id="f70b5ee8b2d415c8f83b1e349fd88c40cc89ed4e" translate="yes" xml:space="preserve">
          <source>Hyper-V is automatically enabled on a Docker Desktop for Windows installation. To enable it manually, see &lt;a href=&quot;https://msdn.microsoft.com/en-us/virtualization/hyperv_on_windows/quick_start/walkthrough_install&quot;&gt;instructions on how to manually enable Hyper-V&lt;/a&gt; on the Microsoft developer network.</source>
          <target state="translated">在Windows平台上的Docker桌面上会自动启用Hyper-V。要手动启用它，请参阅&lt;a href=&quot;https://msdn.microsoft.com/en-us/virtualization/hyperv_on_windows/quick_start/walkthrough_install&quot;&gt;有关如何&lt;/a&gt;在Microsoft开发人员网络上手动启用Hyper-V的说明。</target>
        </trans-unit>
        <trans-unit id="68be18322743fdfe7d234e19622a97818ba2c275" translate="yes" xml:space="preserve">
          <source>Hyper-V must be enabled on your desktop system. Docker Desktop for Windows automatically enables it upon install. See this article on the Microsoft developer network for instructions on &lt;a href=&quot;https://msdn.microsoft.com/en-us/virtualization/hyperv_on_windows/quick_start/walkthrough_install&quot;&gt;how to manually enable Hyper-V&lt;/a&gt;.</source>
          <target state="translated">必须在桌面系统上启用Hyper-V。Docker Desktop for Windows在安装后会自动启用它。请参阅Microsoft开发人员网络上的本文，以获取有关&lt;a href=&quot;https://msdn.microsoft.com/en-us/virtualization/hyperv_on_windows/quick_start/walkthrough_install&quot;&gt;如何手动启用Hyper-V的说明&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="88edcc7de591a470124110111dd4fb258aa34a34" translate="yes" xml:space="preserve">
          <source>IBM Softlayer</source>
          <target state="translated">IBM Softlayer</target>
        </trans-unit>
        <trans-unit id="89f89c02cf47e091e726a4e07b88af0966806897" translate="yes" xml:space="preserve">
          <source>ID</source>
          <target state="translated">ID</target>
        </trans-unit>
        <trans-unit id="15f654452ba0090d5084013c5bcdcd77b073d552" translate="yes" xml:space="preserve">
          <source>IP Address Management Driver</source>
          <target state="translated">IP地址管理驱动程序</target>
        </trans-unit>
        <trans-unit id="04c575095a62156da6b1482b6bf8cba07499f354" translate="yes" xml:space="preserve">
          <source>IP addresses for Docker hosts</source>
          <target state="translated">Docker主机的IP地址</target>
        </trans-unit>
        <trans-unit id="22c6927c6d183895d00724c44e309703e9489733" translate="yes" xml:space="preserve">
          <source>IP masquerading uses address translation to allow containers without a public IP to talk to other machines on the Internet. This may interfere with some network topologies and can be disabled with &lt;code&gt;--ip-masq=false&lt;/code&gt;.</source>
          <target state="translated">IP伪装使用地址转换来允许没有公共IP的容器与Internet上的其他计算机通信。这可能会干扰某些网络拓扑，可以使用 &lt;code&gt;--ip-masq=false&lt;/code&gt; 禁用它。</target>
        </trans-unit>
        <trans-unit id="4e54cdc837e27a9ef9c7a5786aea030d66d36400" translate="yes" xml:space="preserve">
          <source>IPC (POSIX/SysV IPC) namespace provides separation of named shared memory segments, semaphores and message queues.</source>
          <target state="translated">IPC(POSIX/SysV IPC)命名空间提供了命名的共享内存段、信号灯和消息队列的分离。</target>
        </trans-unit>
        <trans-unit id="40c52666d9f14f9e76af9336197b6876ad55d7b8" translate="yes" xml:space="preserve">
          <source>IPC mode to use</source>
          <target state="translated">使用IPC模式</target>
        </trans-unit>
        <trans-unit id="2466e4de9366459f1331b52a642d6ff263d0437d" translate="yes" xml:space="preserve">
          <source>IPC settings (--ipc)</source>
          <target state="translated">IPC设置(--ipc)</target>
        </trans-unit>
        <trans-unit id="db90c7915f34637cc857a2e9c9b0df6e4d64dbea" translate="yes" xml:space="preserve">
          <source>IPC_LOCK</source>
          <target state="translated">IPC_LOCK</target>
        </trans-unit>
        <trans-unit id="f8cd9718aae3aaf817ce7ef407d4f6fa26b3272c" translate="yes" xml:space="preserve">
          <source>IPC_OWNER</source>
          <target state="translated">IPC_OWNER</target>
        </trans-unit>
        <trans-unit id="a413137c336fa9cfc5fb63763ee442f635878b04" translate="yes" xml:space="preserve">
          <source>IPFS Volume Plugin</source>
          <target state="translated">IPFS卷插件</target>
        </trans-unit>
        <trans-unit id="a97c06de54b1c0355f7b7726d09fc57553ddd3e5" translate="yes" xml:space="preserve">
          <source>IPv4 address (e.g., 172.30.100.104)</source>
          <target state="translated">IPv4地址(如:172.30.100.104)</target>
        </trans-unit>
        <trans-unit id="06218b3580cfdd3af453d7fa1c82258d46390c37" translate="yes" xml:space="preserve">
          <source>IPv4 or IPv6 Gateway for the master subnet</source>
          <target state="translated">主子网的IPv4或IPv6网关。</target>
        </trans-unit>
        <trans-unit id="eda5197799acfaeecf77176298726e1ca2e7fcf9" translate="yes" xml:space="preserve">
          <source>IPv6 address (e.g., 2001:db8::33)</source>
          <target state="translated">IPv6地址(例如:2001:db8::33)</target>
        </trans-unit>
        <trans-unit id="f8bd55f1886f390e745c1924f86128a5e48c2dd2" translate="yes" xml:space="preserve">
          <source>Ideally a manifest list is created from images that are identical in function for different os/arch combinations. For this reason, manifest lists are often referred to as &amp;ldquo;multi-arch images&amp;rdquo;. However, a user could create a manifest list that points to two images -- one for windows on amd64, and one for darwin on amd64.</source>
          <target state="translated">理想情况下，清单清单是根据功能不同的os / arch组合的图像创建的。因此，清单清单通常被称为&amp;ldquo;多体系结构图像&amp;rdquo;。但是，用户可以创建一个清单列表，该清单指向两个图像-一个用于amd64上的Windows，一个用于amd64上的darwin。</target>
        </trans-unit>
        <trans-unit id="9f0960fef5b7b3091f4e195e2ac4ecc847605a55" translate="yes" xml:space="preserve">
          <source>Identifier type</source>
          <target state="translated">识别符类型</target>
        </trans-unit>
        <trans-unit id="6b0887047e138c19fdbe87a5581ec8aecbc24b22" translate="yes" xml:space="preserve">
          <source>Identify the trust server.</source>
          <target state="translated">确定信任服务器。</target>
        </trans-unit>
        <trans-unit id="32f7d9150b37267443b1177b2ee3eb025b104ee6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;dest&amp;gt;&lt;/code&gt; does not end with a trailing slash, it will be considered a regular file and the contents of &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; will be written at &lt;code&gt;&amp;lt;dest&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;&amp;lt;dest&amp;gt;&lt;/code&gt; 不以斜杠结尾，它将被视为常规文件，而 &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; 的内容将写入 &lt;code&gt;&amp;lt;dest&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="539c64406ae2fa496fee2c6f29de9649edbfe14a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;dest&amp;gt;&lt;/code&gt; doesn&amp;rsquo;t exist, it is created along with all missing directories in its path.</source>
          <target state="translated">如果 &lt;code&gt;&amp;lt;dest&amp;gt;&lt;/code&gt; 不存在，它将与路径中所有缺少的目录一起创建。</target>
        </trans-unit>
        <trans-unit id="842bab613fc35508eb6b7dcb914be5e7c0d18054" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; is a &lt;em&gt;local&lt;/em&gt; tar archive in a recognized compression format (identity, gzip, bzip2 or xz) then it is unpacked as a directory. Resources from &lt;em&gt;remote&lt;/em&gt; URLs are &lt;strong&gt;not&lt;/strong&gt; decompressed. When a directory is copied or unpacked, it has the same behavior as &lt;code&gt;tar -x&lt;/code&gt;, the result is the union of:</source>
          <target state="translated">如果 &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; 是采用公认压缩格式（身份，gzip，bzip2或xz）的&lt;em&gt;本地&lt;/em&gt; tar存档，则将其解压缩为目录。来自&lt;em&gt;远程&lt;/em&gt; URL的资源&lt;strong&gt;不会被&lt;/strong&gt;解压缩。复制或解压缩目录时，其行为与 &lt;code&gt;tar -x&lt;/code&gt; 相同，结果是以下各项的并集：</target>
        </trans-unit>
        <trans-unit id="9e8767479a2d5e29954fe45ee7268f41c06c1f98" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; is a URL and &lt;code&gt;&amp;lt;dest&amp;gt;&lt;/code&gt; does end with a trailing slash, then the filename is inferred from the URL and the file is downloaded to &lt;code&gt;&amp;lt;dest&amp;gt;/&amp;lt;filename&amp;gt;&lt;/code&gt;. For instance, &lt;code&gt;ADD http://example.com/foobar /&lt;/code&gt; would create the file &lt;code&gt;/foobar&lt;/code&gt;. The URL must have a nontrivial path so that an appropriate filename can be discovered in this case (&lt;code&gt;http://example.com&lt;/code&gt; will not work).</source>
          <target state="translated">如果 &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; 是URL，并且 &lt;code&gt;&amp;lt;dest&amp;gt;&lt;/code&gt; 确实以斜杠结尾，则从URL推断文件名，并将文件下载到 &lt;code&gt;&amp;lt;dest&amp;gt;/&amp;lt;filename&amp;gt;&lt;/code&gt; 。例如， &lt;code&gt;ADD http://example.com/foobar /&lt;/code&gt; 将创建文件 &lt;code&gt;/foobar&lt;/code&gt; 。该URL必须具有不平凡的路径，以便在这种情况下可以找到适当的文件名（ &lt;code&gt;http://example.com&lt;/code&gt; 将不起作用）。</target>
        </trans-unit>
        <trans-unit id="676a783f898e1a6f6cffc90f4643e2cf72864126" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; is a URL and &lt;code&gt;&amp;lt;dest&amp;gt;&lt;/code&gt; does not end with a trailing slash, then a file is downloaded from the URL and copied to &lt;code&gt;&amp;lt;dest&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; 是URL，并且 &lt;code&gt;&amp;lt;dest&amp;gt;&lt;/code&gt; 不以斜杠结尾，则从URL下载文件并将其复制到 &lt;code&gt;&amp;lt;dest&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="68fbdc021c183db50cecc0b5ee1e55448c29a2b2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; is a directory, the entire contents of the directory are copied, including filesystem metadata.</source>
          <target state="translated">如果 &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; 是目录，则将复制目录的整个内容，包括文件系统元数据。</target>
        </trans-unit>
        <trans-unit id="dd5913665cd74adbf26bf555efa691c526c29cf6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; is any other kind of file, it is copied individually along with its metadata. In this case, if &lt;code&gt;&amp;lt;dest&amp;gt;&lt;/code&gt; ends with a trailing slash &lt;code&gt;/&lt;/code&gt;, it will be considered a directory and the contents of &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; will be written at &lt;code&gt;&amp;lt;dest&amp;gt;/base(&amp;lt;src&amp;gt;)&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; 是任何其他类型的文件，则将其与元数据一起单独复制。在这种情况下，如果 &lt;code&gt;&amp;lt;dest&amp;gt;&lt;/code&gt; 以斜杠 &lt;code&gt;/&lt;/code&gt; 结尾，则它将被视为目录，并且 &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; 的内容将写入 &lt;code&gt;&amp;lt;dest&amp;gt;/base(&amp;lt;src&amp;gt;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="39f9a5c964a89ebecc93c25ead12f621739da34f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;/dev&lt;/code&gt; is bind mounted from the host, and allowAllDevices is set to true, the plugin will have &lt;code&gt;rwm&lt;/code&gt; access to all devices on the host.</source>
          <target state="translated">如果 &lt;code&gt;/dev&lt;/code&gt; 是从主机绑定挂载的，并且allowAllDevices设置为true，则该插件将具有对主机上所有设备的 &lt;code&gt;rwm&lt;/code&gt; 访问权限。</target>
        </trans-unit>
        <trans-unit id="21ab4b19972f6f8674f90605d1f4f77ad0a9a4ec" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SIGINT&lt;/code&gt; or &lt;code&gt;SIGTERM&lt;/code&gt; is sent again during this shutdown phase, the running containers are killed, and the exit code is &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">如果在此关闭阶段再次发送 &lt;code&gt;SIGINT&lt;/code&gt; 或 &lt;code&gt;SIGTERM&lt;/code&gt; ,则会终止正在运行的容器，并且退出代码为 &lt;code&gt;2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc71b0837f7450d286a62fbc12b4d86d0fea73a9" translate="yes" xml:space="preserve">
          <source>If Compose detects containers that were created without labels, it refuses to run, so that you don&amp;rsquo;t end up with two sets of them. If you want to keep using your existing containers (for example, because they have data volumes you want to preserve), you can use Compose 1.5.x to migrate them with the following command:</source>
          <target state="translated">如果Compose检测到创建的没有标签的容器，它将拒绝运行，这样您就不会得到两组标签。如果要继续使用现有容器（例如，因为它们具有要保留的数据量），则可以使用Compose 1.5.x通过以下命令迁移它们：</target>
        </trans-unit>
        <trans-unit id="55ee9fd8da42bd7283fda32df5a05d6fbb30bffe" translate="yes" xml:space="preserve">
          <source>If IPv6 addressing is desired, the &lt;code&gt;enable_ipv6&lt;/code&gt; option must be set, and you must use a &lt;a href=&quot;compose-file-v2/index#ipv4_address-ipv6_address&quot;&gt;version 2.x Compose file&lt;/a&gt;. &lt;em&gt;IPv6 options do not currently work in swarm mode&lt;/em&gt;.</source>
          <target state="translated">如果需要IPv6寻址，则必须设置 &lt;code&gt;enable_ipv6&lt;/code&gt; 选项，并且必须使用&lt;a href=&quot;compose-file-v2/index#ipv4_address-ipv6_address&quot;&gt;版本2.x的Compose文件&lt;/a&gt;。&lt;em&gt;IPv6选项当前在群集模式下不起作用&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="7f38117e34f41a3067a78a850264efe0aa2d80f6" translate="yes" xml:space="preserve">
          <source>If TLS is enabled in the &lt;a href=&quot;../../security/https/index&quot;&gt;Docker daemon&lt;/a&gt;, the default user authorization flow extracts the user details from the certificate subject name. That is, the &lt;code&gt;User&lt;/code&gt; field is set to the client certificate subject common name, and the &lt;code&gt;AuthenticationMethod&lt;/code&gt; field is set to &lt;code&gt;TLS&lt;/code&gt;.</source>
          <target state="translated">如果在&lt;a href=&quot;../../security/https/index&quot;&gt;Docker守护程序中&lt;/a&gt;启用了TLS ，则默认用户授权流程将从证书使用者名称中提取用户详细信息。即，&amp;ldquo; &lt;code&gt;User&lt;/code&gt; 字段设置为客户端证书使用者通用名称，而&amp;ldquo; &lt;code&gt;AuthenticationMethod&lt;/code&gt; 字段设置为 &lt;code&gt;TLS&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0e0b2df7e0eb39fb3e67b2d9f59f42df4b471eff" translate="yes" xml:space="preserve">
          <source>If a Notary Service credential compromise is detected, the credentials should be changed immediately.</source>
          <target state="translated">如果发现公证服务凭证泄露,应立即更改凭证。</target>
        </trans-unit>
        <trans-unit id="2dc924422d6a619159d4fa3918f749f84c306533" translate="yes" xml:space="preserve">
          <source>If a client has previously interacted with any trusted collection or has its trust pinned to a specific certificate for the collections, the client immediately detects that the content is malicious and doesn&amp;rsquo;t trust any root, targets, or (maybe) snapshot metadata for these collections.</source>
          <target state="translated">如果客户端以前与任何受信任的集合进行了交互，或者将其信任固定在该集合的特定证书上，则该客户端会立即检测到内容是恶意的，并且不信任这些的任何根，目标或（也许）快照元数据集合。</target>
        </trans-unit>
        <trans-unit id="958f6438da6fac57a98fe1351e6c13626b7de485" translate="yes" xml:space="preserve">
          <source>If a container is connected to the default bridge network and &lt;code&gt;linked&lt;/code&gt; with other containers, then the container&amp;rsquo;s &lt;code&gt;/etc/hosts&lt;/code&gt; file is updated with the linked container&amp;rsquo;s name.</source>
          <target state="translated">如果某个容器已连接到默认网桥网络并与其他容器 &lt;code&gt;linked&lt;/code&gt; ，则该容器的 &lt;code&gt;/etc/hosts&lt;/code&gt; 文件将使用链接的容器的名称进行更新。</target>
        </trans-unit>
        <trans-unit id="cc481d3e0b487db2dad396d771bfb9dd61d5c716" translate="yes" xml:space="preserve">
          <source>If a container is successfully restarted (the container is started and runs for at least 10 seconds), the delay is reset to its default value of 100 ms.</source>
          <target state="translated">如果容器成功重启(容器被启动并至少运行10秒),则延迟被重置为其默认值100毫秒。</target>
        </trans-unit>
        <trans-unit id="5b87282e47d2db54f156eb0641057812050eafcb" translate="yes" xml:space="preserve">
          <source>If a custom security group is provided, you need to ensure that you allow TCP ports 22 and 2376 in an ingress rule.</source>
          <target state="translated">如果提供了自定义安全组,你需要确保在入口规则中允许TCP端口22和2376。</target>
        </trans-unit>
        <trans-unit id="d0a8f48be6c5b9f7f419d0c2cec86d941da1cf53" translate="yes" xml:space="preserve">
          <source>If a delegations key compromise is detected, a higher level key holder must rotate the compromised key, and push a clean set of targets using the new key.</source>
          <target state="translated">如果检测到代表团的密钥泄露,更高级别的密钥持有者必须旋转泄露的密钥,并使用新的密钥推送一组干净的目标。</target>
        </trans-unit>
        <trans-unit id="40dd2361b48af7312e2fe0534a5234e800014638" translate="yes" xml:space="preserve">
          <source>If a format (&lt;code&gt;--format&lt;/code&gt;) is specified, the given template will be executed instead of the default format. Go&amp;rsquo;s &lt;a href=&quot;http://golang.org/pkg/text/template/&quot;&gt;text/template&lt;/a&gt; package describes all the details of the format.</source>
          <target state="translated">如果指定了格式（ &lt;code&gt;--format&lt;/code&gt; ），则将执行给定的模板，而不是默认格式。Go的&lt;a href=&quot;http://golang.org/pkg/text/template/&quot;&gt;文本/模板&lt;/a&gt;包描述了格式的所有细节。</target>
        </trans-unit>
        <trans-unit id="18c922bdabb6c6deeae6774997741b592f60f72a" translate="yes" xml:space="preserve">
          <source>If a format (&lt;code&gt;--format&lt;/code&gt;) is specified, the given template will be executed instead of the default format. Go&amp;rsquo;s &lt;a href=&quot;https://golang.org/pkg/text/template/&quot;&gt;text/template&lt;/a&gt; package describes all the details of the format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="487c4f331d466fc16d579615fbad20b745753f79" translate="yes" xml:space="preserve">
          <source>If a format is set to &lt;code&gt;{{json .}}&lt;/code&gt;, the events are streamed as valid JSON Lines. For information about JSON Lines, please refer to http://jsonlines.org/ .</source>
          <target state="translated">如果格式设置为 &lt;code&gt;{{json .}}&lt;/code&gt; ，则事件将作为有效的JSON行流式传输。有关JSON行的信息，请参阅http://jsonlines.org/。</target>
        </trans-unit>
        <trans-unit id="71d8c1cb064775a9013fe862de96838a016bb606" translate="yes" xml:space="preserve">
          <source>If a format is specified, the given template will be executed instead of the default format. Go&amp;rsquo;s &lt;a href=&quot;http://golang.org/pkg/text/template/&quot;&gt;text/template&lt;/a&gt; package describes all the details of the format.</source>
          <target state="translated">如果指定了格式，则将执行给定的模板，而不是默认格式。Go的&lt;a href=&quot;http://golang.org/pkg/text/template/&quot;&gt;文本/模板&lt;/a&gt;包描述了格式的所有细节。</target>
        </trans-unit>
        <trans-unit id="e131798140f11669373234966760fc1a7065d45f" translate="yes" xml:space="preserve">
          <source>If a format is specified, the given template will be executed instead of the default format. Go&amp;rsquo;s &lt;a href=&quot;https://golang.org/pkg/text/template/&quot;&gt;text/template&lt;/a&gt; package describes all the details of the format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0c55183650774a4ecefb1c40fed2abaf16add49" translate="yes" xml:space="preserve">
          <source>If a line in &lt;code&gt;.dockerignore&lt;/code&gt; file starts with &lt;code&gt;#&lt;/code&gt; in column 1, then this line is considered as a comment and is ignored before interpreted by the CLI.</source>
          <target state="translated">如果 &lt;code&gt;.dockerignore&lt;/code&gt; 文件中的行以 &lt;code&gt;#&lt;/code&gt; 1列中的＃开头，则该行将被视为注释，并且在CLI解释之前将被忽略。</target>
        </trans-unit>
        <trans-unit id="54e21b50df62b95252efcce599fdf69f105434a6" translate="yes" xml:space="preserve">
          <source>If a node loses connectivity to the swarm while it is running a task container with access to a config, the task container still has access to its configs, but cannot receive updates until the node reconnects to the swarm.</source>
          <target state="translated">如果节点在运行访问配置的任务容器时,失去了与群的连接,那么任务容器仍然可以访问其配置,但在节点重新连接到群之前,无法接收更新。</target>
        </trans-unit>
        <trans-unit id="2ac17d39a56beb6186317486915d97fa2c26ee39" translate="yes" xml:space="preserve">
          <source>If a node loses connectivity to the swarm while it is running a task container with access to a secret, the task container still has access to its secrets, but cannot receive updates until the node reconnects to the swarm.</source>
          <target state="translated">如果一个节点在运行具有秘密访问权限的任务容器时,失去了与蜂群的连接,那么任务容器仍然可以访问它的秘密,但在节点重新连接到蜂群之前,无法接收更新。</target>
        </trans-unit>
        <trans-unit id="03b148c22460ef1c7f5b46f6fe96bcc3c84e13b1" translate="yes" xml:space="preserve">
          <source>If a plugin registers itself as a &lt;code&gt;VolumeDriver&lt;/code&gt; when activated, it must provide the Docker Daemon with writeable paths on the host filesystem. The Docker daemon provides these paths to containers to consume. The Docker daemon makes the volumes available by bind-mounting the provided paths into the containers.</source>
          <target state="translated">如果插件在激活时将自己注册为 &lt;code&gt;VolumeDriver&lt;/code&gt; ，则必须在主机文件系统上为Docker Daemon提供可写路径。Docker守护程序提供了这些容器使用路径。Docker守护程序通过将提供的路径绑定安装到容器中来使卷可用。</target>
        </trans-unit>
        <trans-unit id="e4d2844c14128a66cb08799d9e8b6017777b2e75" translate="yes" xml:space="preserve">
          <source>If a publisher loses keys it means losing the ability to sign trusted content for your repositories. If you lose a key, contact &lt;a href=&quot;https://support.docker.com&quot;&gt;Docker Support&lt;/a&gt; (support@docker.com) to reset the repository state.</source>
          <target state="translated">如果发布者丢失了密钥，则意味着失去了为您的存储库签署受信任内容的能力。如果您丢失了密钥，请联系&lt;a href=&quot;https://support.docker.com&quot;&gt;Docker支持&lt;/a&gt;（support@docker.com）以重置存储库状态。</target>
        </trans-unit>
        <trans-unit id="76f78e0f52bfb00cb03583664930b4d480ba9cd5" translate="yes" xml:space="preserve">
          <source>If a root key compromise is detected, the root key holder should contact whomever runs the notary service to manually reverse any malicious changes to the repository, and immediately rotate the root key. This creates a fork of the repository history, and thus break existing clients who have downloaded any of the malicious changes.</source>
          <target state="translated">如果检测到根密钥泄露,根密钥持有者应该联系运行公证服务的人,手动反转存储库的任何恶意更改,并立即旋转根密钥。这将创建一个存储库历史的分叉,从而打破现有的客户端下载任何恶意更改。</target>
        </trans-unit>
        <trans-unit id="a6644eb87a16aa8db9221ace3f57c60c6904dd8b" translate="yes" xml:space="preserve">
          <source>If a service has multiple dependencies of the type which force co-scheduling (see &lt;a href=&quot;index#automatic-scheduling&quot;&gt;Automatic scheduling&lt;/a&gt; below), it&amp;rsquo;s possible that Swarm schedules the dependencies on different nodes, making the dependent service impossible to schedule. For example, here &lt;code&gt;foo&lt;/code&gt; needs to be co-scheduled with &lt;code&gt;bar&lt;/code&gt; and &lt;code&gt;baz&lt;/code&gt;:</source>
          <target state="translated">如果服务具有强制进行联合调度的类型的多个依赖关系（请参阅下面的&lt;a href=&quot;index#automatic-scheduling&quot;&gt;自动调度&lt;/a&gt;），则Swarm可能会在不同节点上调度依赖关系，从而使依赖服务无法进行调度。例如，在这里 &lt;code&gt;foo&lt;/code&gt; 需要与 &lt;code&gt;bar&lt;/code&gt; 和 &lt;code&gt;baz&lt;/code&gt; 共同调度：</target>
        </trans-unit>
        <trans-unit id="376a37c7adc3ab400b1f3f65c1a6690c0e4c03f1" translate="yes" xml:space="preserve">
          <source>If a service is defined in both files, Compose merges the configurations using the rules described in &lt;a href=&quot;index#adding-and-overriding-configuration&quot;&gt;Adding and overriding configuration&lt;/a&gt;.</source>
          <target state="translated">如果在两个文件中都定义了服务，则Compose使用&lt;a href=&quot;index#adding-and-overriding-configuration&quot;&gt;添加和覆盖配置中&lt;/a&gt;描述的规则合并配置。</target>
        </trans-unit>
        <trans-unit id="6099f2a4dd0f6fdd3a9bbc004b0285256c90b3cf" translate="yes" xml:space="preserve">
          <source>If a service maps a port from the host, such as &lt;code&gt;80:8000&lt;/code&gt;, then you may get an error like this when running &lt;code&gt;docker-compose up&lt;/code&gt; on it after the first time:</source>
          <target state="translated">如果服务从主机映射端口，例如 &lt;code&gt;80:8000&lt;/code&gt; ，则在第一次运行 &lt;code&gt;docker-compose up&lt;/code&gt; 时，您可能会收到如下错误：</target>
        </trans-unit>
        <trans-unit id="3990084cc7182339b9a2473de7de5ca3c9e8658c" translate="yes" xml:space="preserve">
          <source>If a single run of the check takes longer than &lt;strong&gt;timeout&lt;/strong&gt; seconds then the check is considered to have failed.</source>
          <target state="translated">如果单次检查花费的时间超过&lt;strong&gt;超时&lt;/strong&gt;秒数，则认为检查失败。</target>
        </trans-unit>
        <trans-unit id="608702a6ea7cd900b0782dfacb3f22957fc109ad" translate="yes" xml:space="preserve">
          <source>If a targets key compromise is detected, the root key holder must rotate the compromised key and push a clean set of targets using the new key.</source>
          <target state="translated">如果检测到目标密钥泄露,根密钥持有者必须旋转泄露的密钥,并使用新密钥推送一组干净的目标。</target>
        </trans-unit>
        <trans-unit id="9901dad8394b5a040a5a7cd1546f7a1f1770b99e" translate="yes" xml:space="preserve">
          <source>If a token was checked-in by accident into a version control system, group chat or accidentally printed to your logs.</source>
          <target state="translated">如果一个令牌不小心被签入了版本控制系统、群聊,或者不小心打印到了你的日志中。</target>
        </trans-unit>
        <trans-unit id="ef241f654d5c1b09ad10dbd0f85fd55773719fa9" translate="yes" xml:space="preserve">
          <source>If a volume with the same &lt;code&gt;&amp;lt;VOLUME-NAME&amp;gt;&lt;/code&gt; does not exist when a task is scheduled to a particular host, then one is created. The default volume driver is &lt;code&gt;local&lt;/code&gt;. To use a different volume driver with this create-on-demand pattern, specify the driver and its options with the &lt;code&gt;--mount&lt;/code&gt; flag:</source>
          <target state="translated">如果在将任务调度到特定主机时不存在具有相同 &lt;code&gt;&amp;lt;VOLUME-NAME&amp;gt;&lt;/code&gt; 的卷，则将创建一个。默认的卷驱动程序是 &lt;code&gt;local&lt;/code&gt; 。要将其他卷驱动程序与按需创建模式一起使用，请使用 &lt;code&gt;--mount&lt;/code&gt; 标志指定驱动程序及其选项：</target>
        </trans-unit>
        <trans-unit id="33708efe6037ab9ca2d0d413d5338889db7f1675" translate="yes" xml:space="preserve">
          <source>If a worker has cached the image at that digest, it uses it.</source>
          <target state="translated">如果一个工作者已经在该摘要处缓存了图像,它就会使用它。</target>
        </trans-unit>
        <trans-unit id="16e254d3a8f6affc68684678a115b11f1bb06e7d" translate="yes" xml:space="preserve">
          <source>If all nodes are paused or drained, and you create a service, it is pending until a node becomes available. In reality, the first node to become available gets all of the tasks, so this is not a good thing to do in a production environment.</source>
          <target state="translated">如果所有节点都被暂停或耗尽,而你创建了一个服务,那么它就会被挂起,直到一个节点变得可用。实际上,第一个变得可用的节点会得到所有的任务,所以在生产环境中,这不是一件好事。</target>
        </trans-unit>
        <trans-unit id="902335c4935811672530d990a1096f1c52965aa1" translate="yes" xml:space="preserve">
          <source>If all&amp;rsquo;s well, you should see some PostgreSQL output.</source>
          <target state="translated">如果一切顺利，您应该会看到一些PostgreSQL输出。</target>
        </trans-unit>
        <trans-unit id="d405d70232bbffced55d081500e6d4a1a81006bb" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;ARG&lt;/code&gt; instruction has a default value and if there is no value passed at build-time, the builder uses the default.</source>
          <target state="translated">如果 &lt;code&gt;ARG&lt;/code&gt; 指令具有默认值，并且在构建时未传递任何值，则构建器将使用默认值。</target>
        </trans-unit>
        <trans-unit id="31d608998308b4be4e37b0a1659b00d89675969a" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;ENV&lt;/code&gt; instruction overrides an &lt;code&gt;ARG&lt;/code&gt; instruction of the same name, like this Dockerfile:</source>
          <target state="translated">如果 &lt;code&gt;ENV&lt;/code&gt; 指令优先于同名的 &lt;code&gt;ARG&lt;/code&gt; 指令，例如Dockerfile：</target>
        </trans-unit>
        <trans-unit id="5278b18308afcca20a2cfcf8059783f3ac6ee68b" translate="yes" xml:space="preserve">
          <source>If an environment variable is not set, Compose substitutes with an empty string. In the example above, if &lt;code&gt;POSTGRES_VERSION&lt;/code&gt; is not set, the value for the &lt;code&gt;image&lt;/code&gt; option is &lt;code&gt;postgres:&lt;/code&gt;.</source>
          <target state="translated">如果未设置环境变量，则Compose替换为空字符串。在上面的例子中，如果 &lt;code&gt;POSTGRES_VERSION&lt;/code&gt; 没有设置，对于该值 &lt;code&gt;image&lt;/code&gt; 的选择是 &lt;code&gt;postgres:&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2d888acaaa172f25a3daa439d41320a4d085913d" translate="yes" xml:space="preserve">
          <source>If an insecure registry is not marked as insecure, &lt;code&gt;docker pull&lt;/code&gt;, &lt;code&gt;docker push&lt;/code&gt;, and &lt;code&gt;docker search&lt;/code&gt; will result in an error message prompting the user to either secure or pass the &lt;code&gt;--insecure-registry&lt;/code&gt; flag to the Docker daemon as described above.</source>
          <target state="translated">如果未将不安全的注册表标记为不安全，则 &lt;code&gt;docker pull&lt;/code&gt; ， &lt;code&gt;docker push&lt;/code&gt; 和 &lt;code&gt;docker search&lt;/code&gt; 将导致错误消息，提示用户 &lt;code&gt;--insecure-registry&lt;/code&gt; 进行安全保护或将--insecure-registry标志传递给Docker守护程序。</target>
        </trans-unit>
        <trans-unit id="b8f06048ef8f8f3fced14b778636758b15cdaf4e" translate="yes" xml:space="preserve">
          <source>If any containers have connections open to the old container, they are closed. It is a container&amp;rsquo;s responsibility to detect this condition, look up the name again and reconnect.</source>
          <target state="translated">如果有任何容器打开了到旧容器的连接，则它们将被关闭。容器有责任检测这种情况，再次查找名称并重新连接。</target>
        </trans-unit>
        <trans-unit id="0dc41fbba4aa693362d15a7cd0a5de64fe05eea4" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;REPOSITORY&lt;/code&gt; and &lt;code&gt;TAG&lt;/code&gt; are provided, only images matching that repository and tag are listed. To find all local images in the &amp;ldquo;java&amp;rdquo; repository with tag &amp;ldquo;8&amp;rdquo; you can use:</source>
          <target state="translated">如果同时提供了 &lt;code&gt;REPOSITORY&lt;/code&gt; 和 &lt;code&gt;TAG&lt;/code&gt; ，则仅列出与该存储库和标签匹配的图像。要在带有标签&amp;ldquo; 8&amp;rdquo;的&amp;ldquo; java&amp;rdquo;存储库中查找所有本地图像，可以使用：</target>
        </trans-unit>
        <trans-unit id="ccfa385733386f0362f253596255d2d504026d71" translate="yes" xml:space="preserve">
          <source>If content trust is enabled, building from a Dockerfile that relies on tag without trust data, causes the build command to fail:</source>
          <target state="translated">如果启用了内容信任,那么从依赖没有信任数据的标签的Dockerfile进行构建,会导致构建命令失败。</target>
        </trans-unit>
        <trans-unit id="15d88cd2e2cfbae36ef86df565e1fccaeaab04bf" translate="yes" xml:space="preserve">
          <source>If everything is right, the history will look like this:</source>
          <target state="translated">如果一切正确,历史将是这样的。</target>
        </trans-unit>
        <trans-unit id="8f42c0af159969ed997a859094792bbd64095de3" translate="yes" xml:space="preserve">
          <source>If found, the client sends its client certificate, so you just need to drop your keys into &lt;code&gt;~/.docker/{ca,cert,key}.pem&lt;/code&gt;. Alternatively, if you want to store your keys in another location, you can specify that location using the environment variable &lt;code&gt;DOCKER_CERT_PATH&lt;/code&gt;.</source>
          <target state="translated">如果找到，客户端将发送其客户端证书，因此您只需将密钥放入 &lt;code&gt;~/.docker/{ca,cert,key}.pem&lt;/code&gt; 。另外，如果要将密钥存储在其他位置，则可以使用环境变量 &lt;code&gt;DOCKER_CERT_PATH&lt;/code&gt; 指定该位置。</target>
        </trans-unit>
        <trans-unit id="c68dc9e61c5f03e5bd182827f73ae2c853f4c07e" translate="yes" xml:space="preserve">
          <source>If it returns output (as shown in the example), you can unset the &lt;code&gt;DOCKER&lt;/code&gt; environment variables.</source>
          <target state="translated">如果它返回输出（如示例中所示），则可以取消设置 &lt;code&gt;DOCKER&lt;/code&gt; 环境变量。</target>
        </trans-unit>
        <trans-unit id="ac295be2e8836bffa5d1f1b4a2fb09bfe0957ca1" translate="yes" xml:space="preserve">
          <source>If it succeeds, the task is deployed using the new image.</source>
          <target state="translated">如果成功,则使用新图像部署任务。</target>
        </trans-unit>
        <trans-unit id="bb66a42fd0ba778cf797db4088ad6a6e96d94872" translate="yes" xml:space="preserve">
          <source>If multiple &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; resources are specified, either directly or due to the use of a wildcard, then &lt;code&gt;&amp;lt;dest&amp;gt;&lt;/code&gt; must be a directory, and it must end with a slash &lt;code&gt;/&lt;/code&gt;.</source>
          <target state="translated">如果直接或由于使用通配符而指定了多个 &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; 资源，则 &lt;code&gt;&amp;lt;dest&amp;gt;&lt;/code&gt; 必须是目录，并且必须以斜杠 &lt;code&gt;/&lt;/code&gt; 结束。</target>
        </trans-unit>
        <trans-unit id="69cb0f2fd38008980f6c51ae91637ef40d6297fe" translate="yes" xml:space="preserve">
          <source>If needed, re-run &lt;code&gt;docker-machine env myvm1&lt;/code&gt;, then run the given command to configure the shell.</source>
          <target state="translated">如果需要，请重新运行 &lt;code&gt;docker-machine env myvm1&lt;/code&gt; ，然后运行给定命令以配置外壳程序。</target>
        </trans-unit>
        <trans-unit id="e2e822076c2e78f6af58688901f2dd81c990be42" translate="yes" xml:space="preserve">
          <source>If neither restarting or rebooting work, you should add another manager node or promote a worker to be a manager node. You also need to cleanly remove the failed node entry from the manager set with &lt;code&gt;docker node demote &amp;lt;NODE&amp;gt;&lt;/code&gt; and &lt;code&gt;docker node rm &amp;lt;id-node&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">如果没有重新启动或重新启动工作，则应添加另一个管理器节点或将辅助服务器提升为管理器节点。您还需要从使用 &lt;code&gt;docker node demote &amp;lt;NODE&amp;gt;&lt;/code&gt; 和 &lt;code&gt;docker node rm &amp;lt;id-node&amp;gt;&lt;/code&gt; 的管理器集中清除失败的节点条目。</target>
        </trans-unit>
        <trans-unit id="06294af90a6964b5850c8b34e73545cd272de1ca" translate="yes" xml:space="preserve">
          <source>If no root key is found, an initial &lt;code&gt;root&lt;/code&gt; key is generated. This key is used as the default root of trust for all your trusted collections.</source>
          <target state="translated">如果找不到根密钥，则会生成一个初始 &lt;code&gt;root&lt;/code&gt; 密钥。该密钥用作所有受信任集合的默认信任根。</target>
        </trans-unit>
        <trans-unit id="f8d5cd38adf1ef06df818390df35318f6418a795" translate="yes" xml:space="preserve">
          <source>If no tag is specified, &lt;code&gt;docker trust inspect&lt;/code&gt; will report details for all signed tags in the repository:</source>
          <target state="translated">如果未指定标签，则 &lt;code&gt;docker trust inspect&lt;/code&gt; 将报告存储库中所有已签名标签的详细信息：</target>
        </trans-unit>
        <trans-unit id="e8fea6c7b10dd295c1bebb32a0d3b431e6a1dcce" translate="yes" xml:space="preserve">
          <source>If not set, the config has world-readable permissions (mode &lt;code&gt;0444&lt;/code&gt;), unless a &lt;code&gt;umask&lt;/code&gt; is set within the container, in which case the mode is impacted by that &lt;code&gt;umask&lt;/code&gt; value.</source>
          <target state="translated">如果未设置，则该配置具有世界可读的权限（模式 &lt;code&gt;0444&lt;/code&gt; ），除非在容器中设置了 &lt;code&gt;umask&lt;/code&gt; ，在这种情况下，该模式会受到该 &lt;code&gt;umask&lt;/code&gt; 值的影响。</target>
        </trans-unit>
        <trans-unit id="943228594ed55248c4b71cd64c967d55a755b19c" translate="yes" xml:space="preserve">
          <source>If not set, the config is owned by the user running the container command (often &lt;code&gt;root&lt;/code&gt;) and that user&amp;rsquo;s default group (also often &lt;code&gt;root&lt;/code&gt;).</source>
          <target state="translated">如果未设置，则配置由运行容器命令的用户（通常为 &lt;code&gt;root&lt;/code&gt; ）和该用户的默认组（通常也为 &lt;code&gt;root&lt;/code&gt; ）拥有。</target>
        </trans-unit>
        <trans-unit id="361398126c8fd9c9da72ac45e2af5408180a3490" translate="yes" xml:space="preserve">
          <source>If not specified, daemon default is used, which can either be &lt;code&gt;&quot;private&quot;&lt;/code&gt; or &lt;code&gt;&quot;shareable&quot;&lt;/code&gt;, depending on the daemon version and configuration.</source>
          <target state="translated">如果未指定，则使用守护程序默认值，它可以是 &lt;code&gt;&quot;private&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;shareable&quot;&lt;/code&gt; ，具体取决于守护程序的版本和配置。</target>
        </trans-unit>
        <trans-unit id="6379eb5f491e40aedc8ee9cd7121ef31da6a4602" translate="yes" xml:space="preserve">
          <source>If not, it attempts to pull the image from Docker Hub or the private registry.</source>
          <target state="translated">如果没有,它就会尝试从Docker Hub或私有注册表中拉取镜像。</target>
        </trans-unit>
        <trans-unit id="574d2c7e970354e0b528941c7c6c3448f43116d3" translate="yes" xml:space="preserve">
          <source>If nothing matches &lt;code&gt;REPOSITORY[:TAG]&lt;/code&gt;, the list is empty.</source>
          <target state="translated">如果没有任何匹配 &lt;code&gt;REPOSITORY[:TAG]&lt;/code&gt; 的列表为空。</target>
        </trans-unit>
        <trans-unit id="6f9c4f5716c8f0b9a0826b05b709119047005df5" translate="yes" xml:space="preserve">
          <source>If provided, the passphrase in &lt;code&gt;NOTARY_DELEGATION_PASSPHRASE&lt;/code&gt; is tried for all delegation roles that notary attempts to sign with.</source>
          <target state="translated">如果提供，则尝试对公证人尝试签名的所有委派角色使用 &lt;code&gt;NOTARY_DELEGATION_PASSPHRASE&lt;/code&gt; 中的密码。</target>
        </trans-unit>
        <trans-unit id="93f9f6e8ab74c84887b3f6ad6d9c36d2c0f5ffcb" translate="yes" xml:space="preserve">
          <source>If set to &amp;ldquo;host&amp;rdquo;, the service&amp;rsquo;s PID mode is the host PID mode. This turns on sharing between container and the host operating system the PID address space. Containers launched with this flag can access and manipulate other containers in the bare-metal machine&amp;rsquo;s namespace and vice versa.</source>
          <target state="translated">如果设置为&amp;ldquo;主机&amp;rdquo;，则服务的PID模式为主机PID模式。这将打开容器和主机操作系统之间的PID地址空间共享。使用此标志启动的容器可以访问和操作裸机名称空间中的其他容器，反之亦然。</target>
        </trans-unit>
        <trans-unit id="31e6a352d11c3660036440f88e8fd8af134491f9" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;true&lt;/code&gt;, specifies that this network has been created outside of Compose. &lt;code&gt;docker-compose up&lt;/code&gt; does not attempt to create it, and raises an error if it doesn&amp;rsquo;t exist.</source>
          <target state="translated">如果设置为 &lt;code&gt;true&lt;/code&gt; ，则指定此网络是在Compose之外创建的。 &lt;code&gt;docker-compose up&lt;/code&gt; 不会尝试创建它，如果不存在，则会引发错误。</target>
        </trans-unit>
        <trans-unit id="b5d2cc629754c5b0991a8a4e6abb36e43b71f11f" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;true&lt;/code&gt;, specifies that this volume has been created outside of Compose. &lt;code&gt;docker-compose up&lt;/code&gt; does not attempt to create it, and raises an error if it doesn&amp;rsquo;t exist.</source>
          <target state="translated">如果设置为 &lt;code&gt;true&lt;/code&gt; ，则指定此卷是在Compose之外创建的。 &lt;code&gt;docker-compose up&lt;/code&gt; 不会尝试创建它，如果不存在，则会引发错误。</target>
        </trans-unit>
        <trans-unit id="27afc180ac268dc4c7f82d663fcb8fa8637ba398" translate="yes" xml:space="preserve">
          <source>If set to one of the following forms: &lt;code&gt;container:&amp;lt;container_name&amp;gt;&lt;/code&gt;, &lt;code&gt;service:&amp;lt;service_name&amp;gt;&lt;/code&gt;, the service shares the PID address space of the designated container or service.</source>
          <target state="translated">如果设置为以下形式之一： &lt;code&gt;container:&amp;lt;container_name&amp;gt;&lt;/code&gt; ， &lt;code&gt;service:&amp;lt;service_name&amp;gt;&lt;/code&gt; ，则该服务共享指定容器或服务的PID地址空间。</target>
        </trans-unit>
        <trans-unit id="9c8669c257f24ea3701376fc32af25ca6e4f8b82" translate="yes" xml:space="preserve">
          <source>If set, Compose doesn&amp;rsquo;t attempt to use the Docker CLI for interactive &lt;code&gt;run&lt;/code&gt; and &lt;code&gt;exec&lt;/code&gt; operations. This option is not available on Windows where the CLI is required for the aforementioned operations. Supported: &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt; to enable, &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt; to disable.</source>
          <target state="translated">如果设置，Compose不会尝试使用Docker CLI进行交互式 &lt;code&gt;run&lt;/code&gt; 和 &lt;code&gt;exec&lt;/code&gt; 操作。在上述操作需要CLI的Windows上，此选项不可用。支持： &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;1&lt;/code&gt; 启用， &lt;code&gt;false&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt; 禁用。</target>
        </trans-unit>
        <trans-unit id="3fb0e20762f663c8c2a52ef125542e3c4d114cc3" translate="yes" xml:space="preserve">
          <source>If set, Compose doesn&amp;rsquo;t try to detect orphaned containers for the project. Supported values: &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt; to enable, &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt; to disable.</source>
          <target state="translated">如果设置，则Compose不会尝试检测项目的孤立容器。支持的值： &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;1&lt;/code&gt; 启用， &lt;code&gt;false&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt; 禁用。</target>
        </trans-unit>
        <trans-unit id="60f1a5f22617601a56fd78c878c5cab8b3ca1e41" translate="yes" xml:space="preserve">
          <source>If set, the value of the &lt;code&gt;COMPOSE_FILE&lt;/code&gt; environment variable is separated using this character as path separator.</source>
          <target state="translated">如果设置，则使用该字符作为路径分隔符来分隔 &lt;code&gt;COMPOSE_FILE&lt;/code&gt; 环境变量的值。</target>
        </trans-unit>
        <trans-unit id="26d05f0ca329019f28ea462e991664250a2b4d49" translate="yes" xml:space="preserve">
          <source>If set, volume declarations using the &lt;a href=&quot;../../compose-file/index#short-syntax-3&quot;&gt;short syntax&lt;/a&gt; are parsed assuming the host path is a Windows path, even if Compose is running on a UNIX-based system. Supported values: &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt; to enable, &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt; to disable.</source>
          <target state="translated">如果设置，使用量声明&lt;a href=&quot;../../compose-file/index#short-syntax-3&quot;&gt;短语法&lt;/a&gt;解析假设主机路径是Windows路径，即使是撰写基于UNIX的系统上运行。支持的值： &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;1&lt;/code&gt; 启用， &lt;code&gt;false&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt; 禁用。</target>
        </trans-unit>
        <trans-unit id="642073a364b487f16e5b836c817fa43dac64dbef" translate="yes" xml:space="preserve">
          <source>If setting up a new metadata pool it is required to be valid. This can be achieved by zeroing the first 4k to indicate empty metadata, like this:</source>
          <target state="translated">如果建立一个新的元数据池,要求它是有效的。这可以通过将前4k归零来表示空元数据来实现,像这样。</target>
        </trans-unit>
        <trans-unit id="ba33702319ae67d8459c2191d11e049a070daa2b" translate="yes" xml:space="preserve">
          <source>If signers are set up for the repository via other &lt;code&gt;docker trust&lt;/code&gt; commands, &lt;code&gt;docker trust inspect --pretty&lt;/code&gt; displays them appropriately as a &lt;code&gt;SIGNER&lt;/code&gt; and specify their &lt;code&gt;KEYS&lt;/code&gt;:</source>
          <target state="translated">如果通过其他 &lt;code&gt;docker trust inspect --pretty&lt;/code&gt; &lt;code&gt;docker trust&lt;/code&gt; 命令为存储库设置了签名者，则docker trust inspect --pretty将它们适当地显示为 &lt;code&gt;SIGNER&lt;/code&gt; 并指定其 &lt;code&gt;KEYS&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="cf23c672e9834372301980726caab060ddf3802e" translate="yes" xml:space="preserve">
          <source>If signers are set up for the repository via other &lt;code&gt;docker trust&lt;/code&gt; commands, &lt;code&gt;docker trust inspect&lt;/code&gt; includes a &lt;code&gt;Signers&lt;/code&gt; key:</source>
          <target state="translated">如果通过其他 &lt;code&gt;docker trust&lt;/code&gt; 命令为存储库设置了签名者，则 &lt;code&gt;docker trust inspect&lt;/code&gt; 将包含一个 &lt;code&gt;Signers&lt;/code&gt; 密钥：</target>
        </trans-unit>
        <trans-unit id="c99e35f88e0e97e0ebfc5b5198ef8926e586ccf0" translate="yes" xml:space="preserve">
          <source>If specified, the container&amp;rsquo;s IP address(es) is reapplied when a stopped container is restarted. If the IP address is no longer available, the container fails to start. One way to guarantee that the IP address is available is to specify an &lt;code&gt;--ip-range&lt;/code&gt; when creating the network, and choose the static IP address(es) from outside that range. This ensures that the IP address is not given to another container while this container is not on the network.</source>
          <target state="translated">如果指定，重新启动已停止的容器时，将重新应用该容器的IP地址。如果IP地址不再可用，则容器无法启动。保证IP地址可用的一种方法是在创建网络时指定 &lt;code&gt;--ip-range&lt;/code&gt; ，然后从该范围之外选择静态IP地址。这样可以确保当该容器不在网络上时，不会将IP地址提供给另一个容器。</target>
        </trans-unit>
        <trans-unit id="7b5d91aed249dd90a975d6b2dca97ecb662b9564" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--from&lt;/code&gt; option is not set, the &lt;code&gt;context&lt;/code&gt; is created from the current context:</source>
          <target state="translated">如果 &lt;code&gt;--from&lt;/code&gt; 未设置选项， &lt;code&gt;context&lt;/code&gt; 是从当前上下文中创建的：</target>
        </trans-unit>
        <trans-unit id="50feb85ec15e4b4841b20845a25e796f15df4796" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;docker-compose.admin.yml&lt;/code&gt; also specifies this same service, any matching fields override the previous file. New values, add to the &lt;code&gt;webapp&lt;/code&gt; service configuration.</source>
          <target state="translated">如果 &lt;code&gt;docker-compose.admin.yml&lt;/code&gt; 也指定了相同的服务，则任何匹配的字段都会覆盖前一个文件。新值添加到 &lt;code&gt;webapp&lt;/code&gt; 服务配置中。</target>
        </trans-unit>
        <trans-unit id="c57ad52626f359e86954ef954b54e345873f00c4" translate="yes" xml:space="preserve">
          <source>If the Docker client loses connection to the daemon, the build is canceled. This happens if you interrupt the Docker client with &lt;code&gt;CTRL-c&lt;/code&gt; or if the Docker client is killed for any reason. If the build initiated a pull which is still running at the time the build is cancelled, the pull is cancelled as well.</source>
          <target state="translated">如果Docker客户端失去与守护程序的连接，构建将被取消。如果您使用 &lt;code&gt;CTRL-c&lt;/code&gt; 中断了Docker客户端，或者由于某种原因而终止了Docker客户端，则会发生这种情况。如果该构建启动了拉动，而该拉动在取消构建时仍在运行，则拉动也将被取消。</target>
        </trans-unit>
        <trans-unit id="043583671601827650f4753f2a28b684229184af" translate="yes" xml:space="preserve">
          <source>If the Docker registry is accessed without a port number, do not add the port to the directory name. The following shows the configuration for a registry on default port 443 which is accessed with &lt;code&gt;docker login my-https.registry.example.com&lt;/code&gt;:</source>
          <target state="translated">如果在没有端口号的情况下访问Docker注册表，请勿将端口添加到目录名称中。以下显示了默认端口443上注册表的配置，该端口可通过 &lt;code&gt;docker login my-https.registry.example.com&lt;/code&gt; 访问：</target>
        </trans-unit>
        <trans-unit id="6191bb5e8b32d7faf4a8ec632cd4e8e1705b4c02" translate="yes" xml:space="preserve">
          <source>If the Notary Service holds the snapshot key and the attacker has Notary Service write credentials, then they don&amp;rsquo;t even need to rotate the snapshot and timestamp keys because the server generates and signs the snapshot and timestamp for them.</source>
          <target state="translated">如果公证服务拥有快照密钥，并且攻击者具有公证服务写入凭据，则它们甚至不需要轮换快照和时间戳密钥，因为服务器会为其生成快照并为其签名并签名。</target>
        </trans-unit>
        <trans-unit id="03f399b6688da34579573adbec2b835addc65e11" translate="yes" xml:space="preserve">
          <source>If the Notary Service holds the snapshot key and the attacker has Notary Service write credentials, then they have effective access to the snapshot and timestamp keys because the server generates and signs the snapshot and timestamp for them.</source>
          <target state="translated">如果公证服务持有快照密钥,而攻击者拥有公证服务的写凭证,那么他们就可以有效地访问快照和时间戳密钥,因为服务器会为他们生成并签署快照和时间戳。</target>
        </trans-unit>
        <trans-unit id="4257c08e5248fc41e0fbc8a7c816ac7d608a5b39" translate="yes" xml:space="preserve">
          <source>If the cgroup has a leading forward slash (&lt;code&gt;/&lt;/code&gt;), the cgroup is created under the root cgroup, otherwise the cgroup is created under the daemon cgroup.</source>
          <target state="translated">如果cgroup的前导斜杠（ &lt;code&gt;/&lt;/code&gt; ），则在根cgroup下创建cgroup，否则在守护程序cgroup下创建cgroup。</target>
        </trans-unit>
        <trans-unit id="af1a51f61d7c7a37fd7b366aa2d9bd99ada47879" translate="yes" xml:space="preserve">
          <source>If the container is paused, then the &lt;code&gt;docker exec&lt;/code&gt; command will fail with an error:</source>
          <target state="translated">如果容器已暂停，则 &lt;code&gt;docker exec&lt;/code&gt; 命令将失败并显示错误：</target>
        </trans-unit>
        <trans-unit id="3b90bec9155bf0c25d791130f89e4be981a2caa9" translate="yes" xml:space="preserve">
          <source>If the container root filesystem does not contain either &lt;code&gt;/etc/passwd&lt;/code&gt; or &lt;code&gt;/etc/group&lt;/code&gt; files and either user or group names are used in the &lt;code&gt;--chown&lt;/code&gt; flag, the build will fail on the &lt;code&gt;ADD&lt;/code&gt; operation. Using numeric IDs requires no lookup and will not depend on container root filesystem content.</source>
          <target state="translated">如果容器根文件系统不包含 &lt;code&gt;/etc/passwd&lt;/code&gt; 或 &lt;code&gt;/etc/group&lt;/code&gt; 文件，并且在 &lt;code&gt;--chown&lt;/code&gt; 标志中使用了用户名或组名，则生成将在 &lt;code&gt;ADD&lt;/code&gt; 操作上失败。使用数字ID不需要查找，并且不依赖于容器根文件系统内容。</target>
        </trans-unit>
        <trans-unit id="e8da81ab61b28765867b27b661e7b4cf2c0bddf0" translate="yes" xml:space="preserve">
          <source>If the container root filesystem does not contain either &lt;code&gt;/etc/passwd&lt;/code&gt; or &lt;code&gt;/etc/group&lt;/code&gt; files and either user or group names are used in the &lt;code&gt;--chown&lt;/code&gt; flag, the build will fail on the &lt;code&gt;COPY&lt;/code&gt; operation. Using numeric IDs requires no lookup and will not depend on container root filesystem content.</source>
          <target state="translated">如果容器根文件系统不包含 &lt;code&gt;/etc/passwd&lt;/code&gt; 或 &lt;code&gt;/etc/group&lt;/code&gt; 文件，并且在 &lt;code&gt;--chown&lt;/code&gt; 标志中使用了用户名或组名，则在 &lt;code&gt;COPY&lt;/code&gt; 操作上构建将失败。使用数字ID不需要查找，并且不依赖于容器根文件系统内容。</target>
        </trans-unit>
        <trans-unit id="d562a7b1b2ff9e69b8c91dbd7ea3c09ebce3ae07" translate="yes" xml:space="preserve">
          <source>If the engine supports specifying the flag multiple times (such as with &lt;code&gt;--label&lt;/code&gt;), then so does Docker Machine.</source>
          <target state="translated">如果引擎支持多次指定标志（例如 &lt;code&gt;--label&lt;/code&gt; ），那么Doc​​ker Machine也支持。</target>
        </trans-unit>
        <trans-unit id="634cbc14ab8d2aec5cde851919c7e0c8562c31c4" translate="yes" xml:space="preserve">
          <source>If the image also specifies an &lt;code&gt;ENTRYPOINT&lt;/code&gt; then the &lt;code&gt;CMD&lt;/code&gt; or &lt;code&gt;COMMAND&lt;/code&gt; get appended as arguments to the &lt;code&gt;ENTRYPOINT&lt;/code&gt;.</source>
          <target state="translated">如果图像还指定了 &lt;code&gt;ENTRYPOINT&lt;/code&gt; ,则将 &lt;code&gt;CMD&lt;/code&gt; 或 &lt;code&gt;COMMAND&lt;/code&gt; 作为参数附加到 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="571755bcdbafceef7bf0a51b6220a2627d4f14c7" translate="yes" xml:space="preserve">
          <source>If the image does not exist, Compose attempts to pull it, unless you have also specified &lt;a href=&quot;#build&quot;&gt;build&lt;/a&gt;, in which case it builds it using the specified options and tags it with the specified tag.</source>
          <target state="translated">如果图像不存在，除非您还指定了&lt;a href=&quot;#build&quot;&gt;build&lt;/a&gt;，否则Compose会尝试拉出它，在这种情况下，它将使用指定的选项来构建它并使用指定的标签对其进行标记。</target>
        </trans-unit>
        <trans-unit id="6d58f64ad6105ef8db49b74720f9e99b8b2eb3e9" translate="yes" xml:space="preserve">
          <source>If the image isn&amp;rsquo;t available locally on the machine, Docker pulls it from the repository.</source>
          <target state="translated">如果映像在计算机上本地不可用，则Docker从存储库中将其提取。</target>
        </trans-unit>
        <trans-unit id="decabeb30cd7d6ef37278274d96d3f3fdcb25cf8" translate="yes" xml:space="preserve">
          <source>If the image tag is unsigned or unavailable, &lt;code&gt;docker trust inspect&lt;/code&gt; does not display any signed tags.</source>
          <target state="translated">如果图像标签未签名或不可用，则 &lt;code&gt;docker trust inspect&lt;/code&gt; 不显示任何已签名标签。</target>
        </trans-unit>
        <trans-unit id="c3985aee8718b743490633c3f5ad2096220a1525" translate="yes" xml:space="preserve">
          <source>If the key has not been rotated since the node left the swarm, and you have a quorum of functional manager nodes in the swarm, you can view the current unlock key using &lt;code&gt;docker swarm unlock-key&lt;/code&gt; without any arguments.</source>
          <target state="translated">如果自节点离开群集以来密钥尚未旋转，并且群集中具有功能管理器节点的法定人数，则可以使用 &lt;code&gt;docker swarm unlock-key&lt;/code&gt; 来查看当前的解锁密钥，而无需任何参数。</target>
        </trans-unit>
        <trans-unit id="dbb038331d8b58a9714f0b2bda53a83abd4d0047" translate="yes" xml:space="preserve">
          <source>If the key was rotated after the swarm node became unavailable and you do not have a record of the previous key, you may need to force the manager to leave the swarm and join it back to the swarm as a new manager.</source>
          <target state="translated">如果密钥在群节点变得不可用后被轮换,并且您没有之前密钥的记录,您可能需要强制管理器离开群,并将其作为新的管理器加入到群中。</target>
        </trans-unit>
        <trans-unit id="db6af6006d76b0437331098b0756917b989a0208" translate="yes" xml:space="preserve">
          <source>If the manager can&amp;rsquo;t resolve the tag to a digest, each worker node is responsible for resolving the tag to a digest, and different nodes may use different versions of the image. If this happens, a warning like the following is logged, substituting the placeholders for real information.</source>
          <target state="translated">如果管理器无法将标签解析为摘要，则每个工作节点都负责将标签解析为摘要，并且不同的节点可能会使用不同版本的映像。如果发生这种情况，则会记录如下警告，用占位符代替真实信息。</target>
        </trans-unit>
        <trans-unit id="468445e93ed0c767355a5be37ae6d3fda16fef16" translate="yes" xml:space="preserve">
          <source>If the manager cannot resolve the tag</source>
          <target state="translated">如果管理者不能解决标签</target>
        </trans-unit>
        <trans-unit id="b046edcb738984fa1d710f1c6d4a01f505bc10fb" translate="yes" xml:space="preserve">
          <source>If the manager resolves the tag</source>
          <target state="translated">如果经理解决了标签</target>
        </trans-unit>
        <trans-unit id="beb9b7081961ba6e8dca2731f78147273a49bd94" translate="yes" xml:space="preserve">
          <source>If the node is a manager node, you receive a warning about maintaining the quorum. To override the warning, pass the &lt;code&gt;--force&lt;/code&gt; flag. If the last manager node leaves the swarm, the swarm becomes unavailable requiring you to take disaster recovery measures.</source>
          <target state="translated">如果该节点是管理者节点，则会收到有关维持仲裁的警告。要覆盖警告，请传递 &lt;code&gt;--force&lt;/code&gt; 标志。如果最后一个管理器节点离开群集，则群集将不可用，需要您采取灾难恢复措施。</target>
        </trans-unit>
        <trans-unit id="20ee3168f225e373e1092f1ce803e4420cb4e017" translate="yes" xml:space="preserve">
          <source>If the node is a manager, it will listen for inbound swarm manager traffic on this address. The default is to listen on 0.0.0.0:2377. It is also possible to specify a network interface to listen on that interface&amp;rsquo;s address; for example &lt;code&gt;--listen-addr eth0:2377&lt;/code&gt;.</source>
          <target state="translated">如果该节点是管理者，它将在该地址上侦听入站群管理器流量。默认值为监听0.0.0.0:2377。还可以指定一个网络接口以监听该接口的地址。例如 &lt;code&gt;--listen-addr eth0:2377&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f3a865e82fafc81c2b06c1df5e4c276e52a047e0" translate="yes" xml:space="preserve">
          <source>If the nodes in one category (for example, those with &lt;code&gt;node.labels.datacenter=south&lt;/code&gt;) can&amp;rsquo;t handle their fair share of tasks due to constraints or resource limitations, the extra tasks will be assigned to other nodes instead, if possible.</source>
          <target state="translated">如果某一类别中的节点（例如，那些具有 &lt;code&gt;node.labels.datacenter=south&lt;/code&gt; 的节点）由于约束或资源限制而无法公平地处理任务，则可能的话，这些额外的任务将分配给其他节点。</target>
        </trans-unit>
        <trans-unit id="413e472cafcc6a59ed4fce1cb2d79a12cc00f095" translate="yes" xml:space="preserve">
          <source>If the operator uses &lt;code&gt;--link&lt;/code&gt; when starting a new client container in the default bridge network, then the client container can access the exposed port via a private networking interface. If &lt;code&gt;--link&lt;/code&gt; is used when starting a container in a user-defined network as described in &lt;a href=&quot;https://docs.docker.com/network/&quot;&gt;&lt;em&gt;Networking overview&lt;/em&gt;&lt;/a&gt;, it will provide a named alias for the container being linked to.</source>
          <target state="translated">如果操作员在默认网桥网络中启动新的客户端容器时使用 &lt;code&gt;--link&lt;/code&gt; ，则客户端容器可以通过专用网络接口访问公开的端口。如&lt;a href=&quot;https://docs.docker.com/network/&quot;&gt;&lt;em&gt;网络概述中&lt;/em&gt;&lt;/a&gt;所述，在用户定义的网络中启动容器时使用 &lt;code&gt;--link&lt;/code&gt; 时，它将为要链接的容器提供命名别名。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cf7efce6af80c4b5053d44e97a1a9971912df7d7" translate="yes" xml:space="preserve">
          <source>If the plugin has a built-in shell, then exec into the plugin can be done as follows:</source>
          <target state="translated">如果插件有内置的shell,那么exec进插件可以按如下方式进行。</target>
        </trans-unit>
        <trans-unit id="a98485c3a9ea9fde530de08d918711046c8203a0" translate="yes" xml:space="preserve">
          <source>If the process encounters an error, the exit code for this command is &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">如果进程遇到错误，则此命令的退出代码为 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2a8a9c15eee7b39cbcd99cc9466a5940c1d9bd0b" translate="yes" xml:space="preserve">
          <source>If the process is interrupted using &lt;code&gt;SIGINT&lt;/code&gt; (&lt;code&gt;ctrl&lt;/code&gt; + &lt;code&gt;C&lt;/code&gt;) or &lt;code&gt;SIGTERM&lt;/code&gt;, the containers are stopped, and the exit code is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">如果使用 &lt;code&gt;SIGINT&lt;/code&gt; （ &lt;code&gt;ctrl&lt;/code&gt; + &lt;code&gt;C&lt;/code&gt; ）或 &lt;code&gt;SIGTERM&lt;/code&gt; 中断了该过程，则容器将停止，并且退出代码为 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d69806468c37d699f0ed9f5ae33c57e2ac750dd0" translate="yes" xml:space="preserve">
          <source>If the registry you are using still supports v2 schema 1, urge their administrators to move to v2 schema 2.</source>
          <target state="translated">如果你使用的注册表仍然支持v2模式1,请敦促他们的管理员转移到v2模式2。</target>
        </trans-unit>
        <trans-unit id="20ea9233d7262932644088fcc2d90071eb652706" translate="yes" xml:space="preserve">
          <source>If the secret being stored is an identity token, the Username should be set to &lt;code&gt;&amp;lt;token&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">如果存储的机密是一个身份令牌，则用户名应设置为 &lt;code&gt;&amp;lt;token&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1f915a53650a9d6786e217f25d7489e1d5cff7f9" translate="yes" xml:space="preserve">
          <source>If the service is &lt;code&gt;replicated&lt;/code&gt; (which is the default), specify the number of containers that should be running at any given time.</source>
          <target state="translated">如果 &lt;code&gt;replicated&lt;/code&gt; 了服务（这是默认设置），请指定在任何给定时间应运行的容器数。</target>
        </trans-unit>
        <trans-unit id="d9ad0bdc1589b59691e1de2ad9fdcffd04093115" translate="yes" xml:space="preserve">
          <source>If the swarm has auto-lock enabled, you need the unlock key to restore the swarm from backup. Retrieve the unlock key if necessary and store it in a safe location. If you are unsure, read &lt;a href=&quot;../swarm_manager_locking/index&quot;&gt;Lock your swarm to protect its encryption key&lt;/a&gt;.</source>
          <target state="translated">如果群集已启用自动锁定，则需要解锁密钥才能从备份中还原群集。如有必要，取回解锁钥匙，并将其存放在安全的地方。如果不确定，请阅读&lt;a href=&quot;../swarm_manager_locking/index&quot;&gt;锁定群以保护其加密密钥&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7f53e0f70e917747f13b79b13405dca39e580b35" translate="yes" xml:space="preserve">
          <source>If the swarm loses the quorum of managers, the swarm cannot perform management tasks. If your swarm has multiple managers, always have more than two. To maintain quorum, a majority of managers must be available. An odd number of managers is recommended, because the next even number does not make the quorum easier to keep. For instance, whether you have 3 or 4 managers, you can still only lose 1 manager and maintain the quorum. If you have 5 or 6 managers, you can still only lose two.</source>
          <target state="translated">如果蜂群失去了管理人员的法定人数,蜂群就无法执行管理任务。如果您的蜂群有多个管理人员,请始终拥有两个以上的管理人员。为了维持法定人数,必须有大多数的管理人员。建议使用奇数的管理人员,因为下一个偶数不会使法定人数更容易保持。例如,无论你有3个或4个经理,你仍然只能失去1个经理并维持法定人数。如果你有5个或6个经理,你仍然只能失去两个经理。</target>
        </trans-unit>
        <trans-unit id="104a7751ceb099a3fc5d1bf05063331b574cd635" translate="yes" xml:space="preserve">
          <source>If the swarm manager can resolve the image tag to a digest, it instructs the worker nodes to redeploy the tasks and use the image at that digest.</source>
          <target state="translated">如果群管理器可以将图像标签解析为摘要,它就会指示工人节点重新部署任务,并使用该摘要下的图像。</target>
        </trans-unit>
        <trans-unit id="3e8ab3bccd74e356b2c88b63b82013b532259485" translate="yes" xml:space="preserve">
          <source>If the swarm manager cannot resolve the image to a digest, all is not lost:</source>
          <target state="translated">如果蜂群管理器无法将图像解析为摘要,那么一切都不会丢失。</target>
        </trans-unit>
        <trans-unit id="59175b569b0c00b695ba3ed4dc983b6f22432393" translate="yes" xml:space="preserve">
          <source>If the update to a task returns &lt;code&gt;RUNNING&lt;/code&gt;, wait for the specified delay period then start the next task.</source>
          <target state="translated">如果对任务的更新返回 &lt;code&gt;RUNNING&lt;/code&gt; ，请等待指定的延迟时间，然后启动下一个任务。</target>
        </trans-unit>
        <trans-unit id="e42f655d55fd8f27ac14326adae883c07ad49ffa" translate="yes" xml:space="preserve">
          <source>If the user specifies arguments to &lt;code&gt;docker run&lt;/code&gt; then they will override the default specified in &lt;code&gt;CMD&lt;/code&gt;.</source>
          <target state="translated">如果用户为 &lt;code&gt;docker run&lt;/code&gt; 指定参数，则它们将覆盖 &lt;code&gt;CMD&lt;/code&gt; 中指定的默认值。</target>
        </trans-unit>
        <trans-unit id="3a0fa08791c4ed71d96ae65d080bc1fca90ffcbb" translate="yes" xml:space="preserve">
          <source>If the whole swarm restarts and every manager node subsequently gets a new IP address, there is no way for any node to contact an existing manager. Therefore the swarm is hung while nodes try to contact one another at their old IP addresses.</source>
          <target state="translated">如果整个蜂群重新启动,并且每个管理器节点随后都获得了一个新的 IP 地址,那么任何节点都无法联系现有的管理器。因此,当节点试图以旧的 IP 地址相互联系时,蜂群会被挂起。</target>
        </trans-unit>
        <trans-unit id="11afd127e56ec4de2ecaa8df449f90768de1ad58" translate="yes" xml:space="preserve">
          <source>If the worker does not have a locally cached image that resolves to the tag, the worker tries to connect to Docker Hub or the private registry to pull the image at that tag.</source>
          <target state="translated">如果worker没有解析到该标记的本地缓存映像,worker会尝试连接到Docker Hub或私有注册表,在该标记处拉取映像。</target>
        </trans-unit>
        <trans-unit id="7eda8315deede58edfc04db3ee3ff1846e345f08" translate="yes" xml:space="preserve">
          <source>If the worker fails to pull the image, the service fails to deploy on that worker node. Docker tries again to deploy the task, possibly on a different worker node.</source>
          <target state="translated">如果worker未能拉取镜像,则服务未能在该worker节点上部署。Docker会再次尝试部署任务,可能会在不同的Worker节点上部署。</target>
        </trans-unit>
        <trans-unit id="1cf8720af15c4dd5395e98f1478e68f1a22a721e" translate="yes" xml:space="preserve">
          <source>If the worker has a locally cached image that resolves to that tag, it uses that image.</source>
          <target state="translated">如果 Worker 有解析到该标记的本地缓存图像,它就会使用该图像。</target>
        </trans-unit>
        <trans-unit id="a700feb94e4d44aff3ca6a45186d8d0be2928174" translate="yes" xml:space="preserve">
          <source>If there are any locations on the Docker host where the unprivileged user needs to write, adjust the permissions of those locations accordingly. This is also true if you want to use the &lt;code&gt;dockremap&lt;/code&gt; user automatically created by Docker, but you can&amp;rsquo;t modify the permissions until after configuring and restarting Docker.</source>
          <target state="translated">如果Docker主机上有任何特权用户需要写入的位置，请相应地调整这些位置的权限。如果要使用由Docker自动创建的 &lt;code&gt;dockremap&lt;/code&gt; 用户，也是如此，但是只有在配置并重新启动Docker之后才能修改权限。</target>
        </trans-unit>
        <trans-unit id="137bf323437a336771da1464ec409f43d5b3d1fb" translate="yes" xml:space="preserve">
          <source>If there are existing containers for a service, and the service&amp;rsquo;s configuration or image was changed after the container&amp;rsquo;s creation, &lt;code&gt;docker-compose up&lt;/code&gt; picks up the changes by stopping and recreating the containers (preserving mounted volumes). To prevent Compose from picking up changes, use the &lt;code&gt;--no-recreate&lt;/code&gt; flag.</source>
          <target state="translated">如果已有用于服务的容器，并且在创建容器后更改了服务的配置或映像，则 &lt;code&gt;docker-compose up&lt;/code&gt; 通过停止并重新创建容器（保留已安装的卷）来获取更改。为防止Compose获取更改，请使用 &lt;code&gt;--no-recreate&lt;/code&gt; 标志。</target>
        </trans-unit>
        <trans-unit id="b731e337d8fb79e4597e6541561c2a17cb1dcfd5" translate="yes" xml:space="preserve">
          <source>If there is 1 CPU, this means the container can get 50% CPU worth of run-time every 50ms.</source>
          <target state="translated">如果有1个CPU,这意味着容器每50ms可以获得50%的CPU运行时间。</target>
        </trans-unit>
        <trans-unit id="45fbc0f76411f03550dc584b50cd862e77dac1b7" translate="yes" xml:space="preserve">
          <source>If there were an error, and the task were failing and repeatedly restarting, you would see something like this:</source>
          <target state="translated">如果出现了错误,任务失败并反复重启,你会看到这样的内容。</target>
        </trans-unit>
        <trans-unit id="9d87a2a6bf2721cd09647c9a549a04fdc51e8fa0" translate="yes" xml:space="preserve">
          <source>If these entries are not present, edit the files as the &lt;code&gt;root&lt;/code&gt; user and assign a starting UID and GID that is the highest-assigned one plus the offset (in this case, &lt;code&gt;65536&lt;/code&gt;). Be careful not to allow any overlap in the ranges.</source>
          <target state="translated">如果不存在这些条目，请以 &lt;code&gt;root&lt;/code&gt; 用户身份编辑文件并分配一个起始UID和GID，该起始UID和GID是分配的最高UID和GID（在本例中为 &lt;code&gt;65536&lt;/code&gt; ）。注意不要在范围内重叠。</target>
        </trans-unit>
        <trans-unit id="019b14090f82f15c5d4dbf548d346a54c93dd3cd" translate="yes" xml:space="preserve">
          <source>If this configuration is used, then you must:</source>
          <target state="translated">如果使用这种配置,那么你必须。</target>
        </trans-unit>
        <trans-unit id="cac9b5138f725d0e9bccf38b6bcdf704d82edd6c" translate="yes" xml:space="preserve">
          <source>If this fails, the task fails to deploy and the manager tries again to deploy the task, possibly on a different worker node.</source>
          <target state="translated">如果失败了,任务就无法部署,管理器会再次尝试部署任务,可能是在不同的工人节点上。</target>
        </trans-unit>
        <trans-unit id="2de7e729b64965f889109416d4b4b89af8489a06" translate="yes" xml:space="preserve">
          <source>If this option is specified for a process-isolated Windows container, &lt;em&gt;all&lt;/em&gt; devices that implement the requested device interface class GUID are made available in the container. For example, the command below makes all COM ports on the host visible in the container.</source>
          <target state="translated">如果为进程隔离的Windows容器指定了此选项，则在容器中可使&lt;em&gt;所有&lt;/em&gt;实现请求的设备接口类GUID的设备可用。例如，以下命令使主机上的所有COM端口在容器中可见。</target>
        </trans-unit>
        <trans-unit id="d21f7d19e853785232042ade6085fb86e0e14022" translate="yes" xml:space="preserve">
          <source>If this pre-create check succeeds, Docker Machine proceeds with the creation as normal. If the pre-create check fails, the Docker Machine process exits with status code 3 to indicate that the source of the non-zero exit was the pre-create check failing.</source>
          <target state="translated">如果这个pre-create检查成功,Docker Machine就会正常进行创建。如果预创建检查失败,Docker Machine进程退出时,状态码为3,表示非零退出的来源是预创建检查失败。</target>
        </trans-unit>
        <trans-unit id="b90ca4905dea53f80682cc379b25bc967338bee0" translate="yes" xml:space="preserve">
          <source>If this succeeds, the worker uses that image.</source>
          <target state="translated">如果成功,工人就会使用该图像。</target>
        </trans-unit>
        <trans-unit id="57510aa5121fe69b3cc9e692c7654854a9b92548" translate="yes" xml:space="preserve">
          <source>If token authentication is enabled on Notary server, then any connecting client that does not have a token is redirected to the authorization server.</source>
          <target state="translated">如果在公证服务器上启用了令牌认证,那么任何没有令牌的连接客户端将被重定向到授权服务器。</target>
        </trans-unit>
        <trans-unit id="540577427f10f2fea72c03e4415b50271633cd0c" translate="yes" xml:space="preserve">
          <source>If unspecified, Compose will use the &lt;code&gt;isolation&lt;/code&gt; value found in the service&amp;rsquo;s definition to determine the value to use for builds.</source>
          <target state="translated">如果未指定，则Compose将使用在服务定义中找到的 &lt;code&gt;isolation&lt;/code&gt; 值来确定用于构建的值。</target>
        </trans-unit>
        <trans-unit id="737a1ade049048b73795f4638e3f21b6bdf6c4a9" translate="yes" xml:space="preserve">
          <source>If used as part of the v2 plugin architecture, mountpoints that are part of paths returned by the plugin must be mounted under the directory specified by &lt;code&gt;PropagatedMount&lt;/code&gt; in the plugin configuration (&lt;a href=&quot;https://github.com/docker/docker/pull/26398&quot;&gt;#26398&lt;/a&gt;)</source>
          <target state="translated">如果用作v2插件体系结构的一部分，则作为插件返回的路径的一部分的挂载点必须安装在插件配置（&lt;a href=&quot;https://github.com/docker/docker/pull/26398&quot;&gt;＃26398&lt;/a&gt;）中由 &lt;code&gt;PropagatedMount&lt;/code&gt; 指定的目录下</target>
        </trans-unit>
        <trans-unit id="f0cfd912ab9f8c53f497a1c10f8752140c7cd467" translate="yes" xml:space="preserve">
          <source>If using a block device for device mapper storage, ideally both &lt;code&gt;datadev&lt;/code&gt; and &lt;code&gt;metadatadev&lt;/code&gt; should be specified to completely avoid using the loopback device.</source>
          <target state="translated">如果使用一个块设备为设备映射存储，理想地既 &lt;code&gt;datadev&lt;/code&gt; 和 &lt;code&gt;metadatadev&lt;/code&gt; 应指定完全避免使用环回装置。</target>
        </trans-unit>
        <trans-unit id="a005a48609dee87fd1dac3f89c36d0b71d857336" translate="yes" xml:space="preserve">
          <source>If using a block device for device mapper storage, it is best to use &lt;code&gt;lvm&lt;/code&gt; to create and manage the thin-pool volume. This volume is then handed to Docker to exclusively create snapshot volumes needed for images and containers.</source>
          <target state="translated">如果将块设备用于设备映射器存储，则最好使用 &lt;code&gt;lvm&lt;/code&gt; 创建和管理精简池卷。然后将该卷交给Docker以专门创建映像和容器所需的快照卷。</target>
        </trans-unit>
        <trans-unit id="94974b330b42ea12c95b5566fd428cdad93c5877" translate="yes" xml:space="preserve">
          <source>If using your own notary server and a self-signed certificate or an internal Certificate Authority, you need to place the certificate at &lt;code&gt;tls/&amp;lt;registry_url&amp;gt;/ca.crt&lt;/code&gt; in your docker config directory.</source>
          <target state="translated">如果使用自己的公证服务器和自签名证书或内部证书颁发机构，则需要将证书放置在 &lt;code&gt;tls/&amp;lt;registry_url&amp;gt;/ca.crt&lt;/code&gt; config目录中的tls / &amp;lt;registry_url&amp;gt; /ca.crt中。</target>
        </trans-unit>
        <trans-unit id="6678911fc6f942d17377f016af8b8f040144de38" translate="yes" xml:space="preserve">
          <source>If you access a node which is not running a service task, the service does not listen on that port. It is possible that nothing is listening, or that a completely different application is listening.</source>
          <target state="translated">如果你访问一个没有运行服务任务的节点,服务就不会在该端口上监听。有可能什么都没有监听,或者有一个完全不同的应用程序在监听。</target>
        </trans-unit>
        <trans-unit id="fbe59e89976ce47b62a926fbbd03c97f550e518c" translate="yes" xml:space="preserve">
          <source>If you are able, modify the application that you&amp;rsquo;re running to add an explicit signal handler for &lt;code&gt;SIGTERM&lt;/code&gt;.</source>
          <target state="translated">如果可以，请修改正在运行的应用程序，以为 &lt;code&gt;SIGTERM&lt;/code&gt; 添加显式信号处理程序。</target>
        </trans-unit>
        <trans-unit id="5395a9bdbe764ed617462377a3719244cd4d2f3c" translate="yes" xml:space="preserve">
          <source>If you are behind an HTTP proxy server, for example in corporate settings, before open a connect to registry, you may need to configure the Docker daemon&amp;rsquo;s proxy settings, using the &lt;code&gt;HTTP_PROXY&lt;/code&gt;, &lt;code&gt;HTTPS_PROXY&lt;/code&gt;, and &lt;code&gt;NO_PROXY&lt;/code&gt; environment variables. To set these environment variables on a host using &lt;code&gt;systemd&lt;/code&gt;, refer to the &lt;a href=&quot;https://docs.docker.com/config/daemon#http-proxy&quot;&gt;control and configure Docker with systemd&lt;/a&gt; for variables configuration.</source>
          <target state="translated">如果在公司设置中位于HTTP代理服务器后面，则在打开连接到注册表之前，您可能需要使用 &lt;code&gt;HTTP_PROXY&lt;/code&gt; ， &lt;code&gt;HTTPS_PROXY&lt;/code&gt; 和 &lt;code&gt;NO_PROXY&lt;/code&gt; 环境变量来配置Docker守护程序的代理设置。要使用 &lt;code&gt;systemd&lt;/code&gt; 在主机上设置这些环境变量，请参考&lt;a href=&quot;https://docs.docker.com/config/daemon#http-proxy&quot;&gt;控件并&lt;/a&gt;使用systemd 配置Docker以进行变量配置。</target>
        </trans-unit>
        <trans-unit id="81bfc0806cc220d9b3fae0277d21e98e02a1e7d0" translate="yes" xml:space="preserve">
          <source>If you are brand new to Docker, see &lt;a href=&quot;../../index&quot;&gt;About Docker Engine&lt;/a&gt;.</source>
          <target state="translated">如果您是Docker的新手，请参阅&lt;a href=&quot;../../index&quot;&gt;关于Docker Engine&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="629ced47685bfe41121a79b42c51c35b0edcae80" translate="yes" xml:space="preserve">
          <source>If you are currently logged in, run &lt;code&gt;docker logout&lt;/code&gt; to remove the credentials from the default store.</source>
          <target state="translated">如果您当前已登录，请运行 &lt;code&gt;docker logout&lt;/code&gt; 从默认存储中删除凭据。</target>
        </trans-unit>
        <trans-unit id="0c8d16c604c6fd8e11bdb9a12ec19bbda7aa8576" translate="yes" xml:space="preserve">
          <source>If you are currently logged in, run &lt;code&gt;docker logout&lt;/code&gt; to remove the credentials from the file and run &lt;code&gt;docker login&lt;/code&gt; again.</source>
          <target state="translated">如果您当前登录，请运行 &lt;code&gt;docker logout&lt;/code&gt; 从文件中删除凭据，然后再次运行 &lt;code&gt;docker login&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8db4fb8e8d6388d60300491c603f17b30db108a7" translate="yes" xml:space="preserve">
          <source>If you are finished using a host for the time being, you can stop it with &lt;code&gt;docker-machine stop&lt;/code&gt; and later start it again with &lt;code&gt;docker-machine start&lt;/code&gt;.</source>
          <target state="translated">如果您暂时完成使用主机，则可以通过 &lt;code&gt;docker-machine stop&lt;/code&gt; 停止它，然后再通过 &lt;code&gt;docker-machine start&lt;/code&gt; 再次启动它。</target>
        </trans-unit>
        <trans-unit id="91e229fd9d790c65ecc4af56e7cc67bf2ac8787b" translate="yes" xml:space="preserve">
          <source>If you are having problems with Docker after loading a plugin, ask the authors of the plugin for help. The Docker team may not be able to assist you.</source>
          <target state="translated">如果你在加载插件后遇到了Docker问题,请向插件的作者寻求帮助。Docker团队可能无法帮助你。</target>
        </trans-unit>
        <trans-unit id="0cb8508ccbd8b2e9b8654e670245fe6b98375ea1" translate="yes" xml:space="preserve">
          <source>If you are interested in writing a plugin for Docker, or seeing how they work under the hood, see the &lt;a href=&quot;../plugin_api/index&quot;&gt;docker plugins reference&lt;/a&gt;.</source>
          <target state="translated">如果您有兴趣为Docker编写插件或了解它们在幕后的工作方式，请参阅Docker &lt;a href=&quot;../plugin_api/index&quot;&gt;插件参考&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="91e910a080c7afa02fe688d8641ca23bf75ab2a5" translate="yes" xml:space="preserve">
          <source>If you are just getting started with Docker and want to learn the best way to deploy multi-service applications, a good place to start is the &lt;a href=&quot;../../get-started/index&quot;&gt;Get Started walkthrough&lt;/a&gt;. This shows you how to define a service configuration in a Compose file, deploy the app, and use the relevant tools and commands.</source>
          <target state="translated">如果您刚刚开始使用Docker，并且想学习部署多服务应用程序的最佳方法，那么&lt;a href=&quot;../../get-started/index&quot;&gt;入门&lt;/a&gt;是一个不错的起点。这显示了如何在Compose文件中定义服务配置，如何部署应用程序以及如何使用相关工具和命令。</target>
        </trans-unit>
        <trans-unit id="2838bc8eaec18e388ed0ec70489c362f2bf9fc03" translate="yes" xml:space="preserve">
          <source>If you are just using trust out-of-the-box you only need your Docker Engine client and access to the Docker Hub. The sandbox mimics a production trust environment, and sets up these additional components.</source>
          <target state="translated">如果你只是使用开箱即用的信任,你只需要你的Docker Engine客户端和对Docker Hub的访问。沙盒模拟生产信任环境,并设置这些附加组件。</target>
        </trans-unit>
        <trans-unit id="449bd5b09cd68c9348c0aee8d36b5bc15bd61f2a" translate="yes" xml:space="preserve">
          <source>If you are looking to configure a service&amp;rsquo;s restart policy, please refer to &lt;a href=&quot;../../compose-file/index#restart&quot;&gt;restart&lt;/a&gt; in Compose file v3 and &lt;a href=&quot;../../compose-file/compose-file-v2/index#restart&quot;&gt;restart&lt;/a&gt; in Compose v2. Note that if you are &lt;a href=&quot;../../../engine/reference/commandline/stack_deploy/index&quot;&gt;deploying a stack in swarm mode&lt;/a&gt;, you should use &lt;a href=&quot;../../compose-file/index#restart&quot;&gt;restart_policy&lt;/a&gt;, instead.</source>
          <target state="translated">如果您正在寻找配置服务的重新启动策略，请参考&lt;a href=&quot;../../compose-file/index#restart&quot;&gt;重启&lt;/a&gt;在撰写文件v3和&lt;a href=&quot;../../compose-file/compose-file-v2/index#restart&quot;&gt;重启&lt;/a&gt;在撰写V2。请注意，如果&lt;a href=&quot;../../../engine/reference/commandline/stack_deploy/index&quot;&gt;以集群模式部署堆栈&lt;/a&gt;，则应改用&lt;a href=&quot;../../compose-file/index#restart&quot;&gt;restart_policy&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4d7706ffb54bbd50f08337edc7055ec69a597e42" translate="yes" xml:space="preserve">
          <source>If you are not already an AWS user, sign up for &lt;a href=&quot;https://aws.amazon.com/&quot;&gt;AWS&lt;/a&gt; to create an account and get root access to EC2 cloud computers.</source>
          <target state="translated">如果您还不是AWS用户，请注册&lt;a href=&quot;https://aws.amazon.com/&quot;&gt;AWS&lt;/a&gt;以创建一个帐户并获得对EC2云计算机的root访问权限。</target>
        </trans-unit>
        <trans-unit id="f605e0935104fbb038aef428a6e8bdecfb4e8f0c" translate="yes" xml:space="preserve">
          <source>If you are not using virtualenv,</source>
          <target state="translated">如果你没有使用virtualenv。</target>
        </trans-unit>
        <trans-unit id="e426a03f3dc82b81b2c16ad7783f7dcb49a06804" translate="yes" xml:space="preserve">
          <source>If you are on Windows and using either PowerShell or &lt;code&gt;cmd.exe&lt;/code&gt;, &lt;code&gt;docker-machine env&lt;/code&gt; Docker Machine should now detect your shell automatically. If the automatic detection does not work, you can still override it using the &lt;code&gt;--shell&lt;/code&gt; flag for &lt;code&gt;docker-machine env&lt;/code&gt;.</source>
          <target state="translated">如果您使用的是Windows并使用PowerShell或 &lt;code&gt;cmd.exe&lt;/code&gt; ，则 &lt;code&gt;docker-machine env&lt;/code&gt; Docker Machine现在应该自动检测您的shell。如果自动检测不起作用，您仍然可以使用 &lt;code&gt;--shell&lt;/code&gt; 标志为docker &lt;code&gt;docker-machine env&lt;/code&gt; 覆盖它。</target>
        </trans-unit>
        <trans-unit id="1e8b7a8c3077ea87de3300f6715a2c92023fe18a" translate="yes" xml:space="preserve">
          <source>If you are running &lt;strong&gt;Linux&lt;/strong&gt;:</source>
          <target state="translated">如果您正在运行&lt;strong&gt;Linux&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="d1a38d6f4970e1e63cbcfa5bc29abcd4e590868a" translate="yes" xml:space="preserve">
          <source>If you are running &lt;strong&gt;Windows&lt;/strong&gt; with &lt;a href=&quot;https://git-for-windows.github.io/&quot;&gt;Git BASH&lt;/a&gt;:</source>
          <target state="translated">如果您使用&lt;a href=&quot;https://git-for-windows.github.io/&quot;&gt;Git BASH&lt;/a&gt;运行&lt;strong&gt;Windows&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="60b7b84c6c5a44b9bfed2910401774f57a8578b3" translate="yes" xml:space="preserve">
          <source>If you are running &lt;strong&gt;macOS&lt;/strong&gt;:</source>
          <target state="translated">如果您正在运行&lt;strong&gt;macOS&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="274bac5ac8b6e1a7be863beec0e78914f6ca4a33" translate="yes" xml:space="preserve">
          <source>If you are running Docker Desktop for Mac, you can run Docker commands to talk to the Docker Engine installed with that app.</source>
          <target state="translated">如果你正在运行Docker Desktop for Mac,你可以运行Docker命令来与该应用安装的Docker引擎对话。</target>
        </trans-unit>
        <trans-unit id="1271a500104947b8c2ef7bbb21aa561d333e172e" translate="yes" xml:space="preserve">
          <source>If you are running Docker on Linux, the files &lt;code&gt;django-admin&lt;/code&gt; created are owned by root. This happens because the container runs as the root user. Change the ownership of the new files.</source>
          <target state="translated">如果您在Linux上运行Docker，则 &lt;code&gt;django-admin&lt;/code&gt; 创建的文件由root拥有。发生这种情况是因为容器以root用户身份运行。更改新文件的所有权。</target>
        </trans-unit>
        <trans-unit id="9bd0326f049b25cac67f5b05f08d6ad832c995e3" translate="yes" xml:space="preserve">
          <source>If you are running Docker on Linux, the files &lt;code&gt;rails new&lt;/code&gt; created are owned by root. This happens because the container runs as the root user. If this is the case, change the ownership of the new files.</source>
          <target state="translated">如果您在Linux上运行Docker，则 &lt;code&gt;rails new&lt;/code&gt; 创建的文件rails由root拥有。发生这种情况是因为容器以root用户身份运行。在这种情况下，请更改新文件的所有权。</target>
        </trans-unit>
        <trans-unit id="aef42acffcb02495ac96edeead57452e94f34c7d" translate="yes" xml:space="preserve">
          <source>If you are running Docker on Mac or Windows, you should already have ownership of all files, including those generated by &lt;code&gt;django-admin&lt;/code&gt;. List the files just to verify this.</source>
          <target state="translated">如果您在Mac或Windows上运行Docker，则应该已经拥有所有文件的所有权，包括 &lt;code&gt;django-admin&lt;/code&gt; 生成的文件。列出文件只是为了验证这一点。</target>
        </trans-unit>
        <trans-unit id="61e1a755b7476e63784d2625ca4a5b782443c09a" translate="yes" xml:space="preserve">
          <source>If you are running Docker on Mac or Windows, you should already have ownership of all files, including those generated by &lt;code&gt;rails new&lt;/code&gt;.</source>
          <target state="translated">如果您在Mac或Windows上运行Docker，则应该已经拥有所有文件的所有权，包括 &lt;code&gt;rails new&lt;/code&gt; 生成的文件。</target>
        </trans-unit>
        <trans-unit id="8060ae59ed75e0b362e43211d5ff52833f627276" translate="yes" xml:space="preserve">
          <source>If you are running a prometheus server you can add this address to your scrape configs to have prometheus collect metrics on Docker. For more information on prometheus you can view the website &lt;a href=&quot;https://prometheus.io/&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">如果您正在运行Prometheus服务器，则可以将此地址添加到您的抓取配置中，以使Prometheus在Docker上收集指标。有关Prometheus的更多信息，您可以在&lt;a href=&quot;https://prometheus.io/&quot;&gt;这里&lt;/a&gt;查看网站。</target>
        </trans-unit>
        <trans-unit id="c984f811e26f09cdccdcc96301034bacc8fd0dd1" translate="yes" xml:space="preserve">
          <source>If you are running the Docker daemon and client directly on Microsoft Windows Server, follow the instructions in the Windows Server tab.</source>
          <target state="translated">如果您直接在Microsoft Windows Server上运行Docker守护进程和客户端,请按照Windows Server选项卡中的说明进行操作。</target>
        </trans-unit>
        <trans-unit id="9ea989c2545d0bda4cacb3881da917239a9b56de" translate="yes" xml:space="preserve">
          <source>If you are using &lt;a href=&quot;../../machine/index&quot;&gt;Docker Machine&lt;/a&gt;, you can run the command &lt;code&gt;docker-machine ip MACHINE_VM&lt;/code&gt; to get the machine address, and then open &lt;code&gt;http://MACHINE_VM_IP:8000&lt;/code&gt; in a web browser.</source>
          <target state="translated">如果使用的是&lt;a href=&quot;../../machine/index&quot;&gt;Docker Machine&lt;/a&gt;，则可以运行命令 &lt;code&gt;docker-machine ip MACHINE_VM&lt;/code&gt; 以获取机器地址，然后在Web浏览器中打开 &lt;code&gt;http://MACHINE_VM_IP:8000&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8bf06f0e609f54cfdf0286937b4230a68a242b14" translate="yes" xml:space="preserve">
          <source>If you are using &lt;a href=&quot;../../machine/overview/index&quot;&gt;Docker Machine&lt;/a&gt;, then &lt;code&gt;docker-machine ip MACHINE_VM&lt;/code&gt; returns the Docker host IP address, to which you can append the port (&lt;code&gt;&amp;lt;Docker-Host-IP&amp;gt;:3000&lt;/code&gt;).</source>
          <target state="translated">如果使用&lt;a href=&quot;../../machine/overview/index&quot;&gt;Docker Machine&lt;/a&gt;，则 &lt;code&gt;docker-machine ip MACHINE_VM&lt;/code&gt; 返回Docker主机IP地址，您可以在该IP地址上附加端口（ &lt;code&gt;&amp;lt;Docker-Host-IP&amp;gt;:3000&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="65f1943dd64b104ca00b2f5f7af5815488299136" translate="yes" xml:space="preserve">
          <source>If you are using &lt;code&gt;fish&lt;/code&gt; and the &lt;code&gt;SHELL&lt;/code&gt; environment variable is correctly set to the path where &lt;code&gt;fish&lt;/code&gt; is located, &lt;code&gt;docker-machine env name&lt;/code&gt; prints out the values in the format which &lt;code&gt;fish&lt;/code&gt; expects:</source>
          <target state="translated">如果您使用的是 &lt;code&gt;fish&lt;/code&gt; 且 &lt;code&gt;SHELL&lt;/code&gt; 环境变量已正确设置为 &lt;code&gt;fish&lt;/code&gt; 所在的路径，则 &lt;code&gt;docker-machine env name&lt;/code&gt; 以 &lt;code&gt;fish&lt;/code&gt; 期望的格式输出值：</target>
        </trans-unit>
        <trans-unit id="a0c6d522e29f05efde106f3729ac8ef710dafe89" translate="yes" xml:space="preserve">
          <source>If you are using DTR and would like to work with a remote UCP&amp;rsquo;s signing policy, you must &lt;a href=&quot;https://docs.docker.com/ee/dtr/user/manage-images/sign-images/trust-with-remote-ucp/#registering-dtr-with-a-remote-universal-control-plane&quot;&gt;register your DTR instance with that remote UCP&lt;/a&gt;. See &lt;a href=&quot;https://docs.docker.com/ee/dtr/user/manage-images/sign-images/trust-with-remote-ucp/&quot;&gt;Using Docker Content Trust with a Remote UCP Cluster&lt;/a&gt; for more details.</source>
          <target state="translated">如果您使用的是DTR，并且希望使用远程UCP的签名策略，则必须&lt;a href=&quot;https://docs.docker.com/ee/dtr/user/manage-images/sign-images/trust-with-remote-ucp/#registering-dtr-with-a-remote-universal-control-plane&quot;&gt;在该远程UCP上注册DTR实例&lt;/a&gt;。有关更多详细信息，请参阅&lt;a href=&quot;https://docs.docker.com/ee/dtr/user/manage-images/sign-images/trust-with-remote-ucp/&quot;&gt;将Docker Content Trust与远程UCP群集一起使用&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f23e83ee2a1be50e774f6a894aabfcf72356f986" translate="yes" xml:space="preserve">
          <source>If you are using Docker Desktop for Mac</source>
          <target state="translated">如果您正在使用Docker Desktop for Mac</target>
        </trans-unit>
        <trans-unit id="4aeb34bddb4bdeb5566474748c20ff61616a94a7" translate="yes" xml:space="preserve">
          <source>If you are using Docker Desktop for Mac or Docker Desktop for Windows, you can use &lt;code&gt;http://localhost&lt;/code&gt; as the IP address, and open &lt;code&gt;http://localhost:8000&lt;/code&gt; in a web browser.</source>
          <target state="translated">如果使用Mac的Docker Desktop或Windows的Docker Desktop，则可以使用 &lt;code&gt;http://localhost&lt;/code&gt; 作为IP地址，并在Web浏览器中打开 &lt;code&gt;http://localhost:8000&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5d7766addc8a1d4fe2974745ee773f217c8cf25d" translate="yes" xml:space="preserve">
          <source>If you are using Docker Desktop for Windows</source>
          <target state="translated">如果您使用的是Windows的Docker Desktop</target>
        </trans-unit>
        <trans-unit id="0fe9adb6aa496fdf96f55cf7560ac6d40c6b9d1a" translate="yes" xml:space="preserve">
          <source>If you are using Docker Machine, you can get the manager IP with either &lt;code&gt;docker-machine ls&lt;/code&gt; or &lt;code&gt;docker-machine ip &amp;lt;MACHINE-NAME&amp;gt;&lt;/code&gt; &amp;mdash; for example, &lt;code&gt;docker-machine ip manager1&lt;/code&gt;.</source>
          <target state="translated">如果使用的是Docker Machine，则可以使用 &lt;code&gt;docker-machine ls&lt;/code&gt; 或 &lt;code&gt;docker-machine ip &amp;lt;MACHINE-NAME&amp;gt;&lt;/code&gt; 获取管理器IP，例如 &lt;code&gt;docker-machine ip manager1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dc6b921149bdbc488eafbd24a5c9d241fbc76133" translate="yes" xml:space="preserve">
          <source>If you are using Docker Toolbox</source>
          <target state="translated">如果您正在使用Docker工具箱</target>
        </trans-unit>
        <trans-unit id="b3d6b6012d17b1e4a8c151c621e2da2363ed6a50" translate="yes" xml:space="preserve">
          <source>If you are using Docker Toolbox on a Windows system that has Hyper-V but cannot run Docker Desktop for Windows (for example Windows 8 Pro), you must use the &lt;code&gt;hyperv&lt;/code&gt; driver to create local machines. (See the &lt;a href=&quot;../drivers/hyper-v/index&quot;&gt;Docker Machine driver for Microsoft Hyper-V&lt;/a&gt;.)</source>
          <target state="translated">如果您在具有Hyper-V的Windows系统上使用Docker Toolbox，但无法运行Windows的Docker Desktop（例如Windows 8 Pro），则必须使用 &lt;code&gt;hyperv&lt;/code&gt; 驱动程序来创建本地计算机。（请参阅&lt;a href=&quot;../drivers/hyper-v/index&quot;&gt;用于Microsoft Hyper-V&lt;/a&gt;的Docker Machine驱动程序。）</target>
        </trans-unit>
        <trans-unit id="6f6dc0518260229841fc1884f8e46539accf8f0d" translate="yes" xml:space="preserve">
          <source>If you are using Docker Toolbox on either Mac or an older version Windows system (without Hyper-V), use the &lt;code&gt;virtualbox&lt;/code&gt; driver to create a local machine based on Oracle &lt;a href=&quot;https://www.virtualbox.org/&quot;&gt;VirtualBox&lt;/a&gt;. (See the &lt;a href=&quot;../drivers/virtualbox/index&quot;&gt;Docker Machine driver for Oracle VirtualBox&lt;/a&gt;.)</source>
          <target state="translated">如果要在Mac或较旧版本的Windows系统（没有Hyper-V）上使用Docker Toolbox，请使用 &lt;code&gt;virtualbox&lt;/code&gt; 驱动程序基于Oracle &lt;a href=&quot;https://www.virtualbox.org/&quot;&gt;VirtualBox&lt;/a&gt;创建本地计算机。（请参阅&lt;a href=&quot;../drivers/virtualbox/index&quot;&gt;适用于Oracle VirtualBox&lt;/a&gt;的Docker Machine驱动程序。）</target>
        </trans-unit>
        <trans-unit id="8443d422f46f76025ba1855c3719e721e90a26fa" translate="yes" xml:space="preserve">
          <source>If you are using Linux based physical computers or cloud-provided computers as hosts, simply follow the &lt;a href=&quot;https://docs.docker.com/install&quot;&gt;Linux install instructions&lt;/a&gt; for your platform. Spin up the three machines, and you are ready. You can test both single-node and multi-node swarm scenarios on Linux machines.</source>
          <target state="translated">如果您使用基于Linux的物理计算机或提供云的计算机作为主机，则只需按照您平台的&lt;a href=&quot;https://docs.docker.com/install&quot;&gt;Linux安装说明&lt;/a&gt;进行操作。旋转三台机器，您就可以准备就绪。您可以在Linux机器上测试单节点和多节点群集方案。</target>
        </trans-unit>
        <trans-unit id="1822fdef618139232f9ae99448fdb174ae6c0c5b" translate="yes" xml:space="preserve">
          <source>If you are using Oracle VirtualBox on an older Windows OS, you might encounter an issue with shared folders as described in this &lt;a href=&quot;https://www.virtualbox.org/ticket/14920&quot;&gt;VB trouble ticket&lt;/a&gt;. Newer Windows systems meet the requirements for &lt;a href=&quot;https://docs.docker.com/docker-for-windows/install/&quot;&gt;Docker Desktop for Windows&lt;/a&gt; and do not need VirtualBox.</source>
          <target state="translated">如果您在较旧的Windows操作系统上使用Oracle VirtualBox，则可能会遇到共享文件夹的问题，如此&lt;a href=&quot;https://www.virtualbox.org/ticket/14920&quot;&gt;VB故障单所述&lt;/a&gt;。较新的Windows系统满足Windows的&lt;a href=&quot;https://docs.docker.com/docker-for-windows/install/&quot;&gt;Docker桌面&lt;/a&gt;的要求，并且不需要VirtualBox。</target>
        </trans-unit>
        <trans-unit id="12a835c73806df72a6cb71d1319e8057784da3d6" translate="yes" xml:space="preserve">
          <source>If you are using Toolbox on Mac, Toolbox on older Windows systems without Hyper-V, or Docker Desktop for Mac, use &lt;code&gt;virtualbox&lt;/code&gt; as the driver, as shown in this example. (The Docker Machine VirtualBox driver reference is &lt;a href=&quot;../drivers/virtualbox/index&quot;&gt;here&lt;/a&gt;.) (See &lt;a href=&quot;index#prerequisite-information&quot;&gt;prerequisites&lt;/a&gt; above to learn more.)</source>
          <target state="translated">如果在Mac上使用Toolbox，在没有Hyper-V的较旧Windows系统上使用Toolbox，或者在Mac上使用Docker Desktop，请使用 &lt;code&gt;virtualbox&lt;/code&gt; 作为驱动程序，如本示例所示。（&lt;a href=&quot;../drivers/virtualbox/index&quot;&gt;此处&lt;/a&gt;是Docker Machine VirtualBox驱动程序参考。）（请参阅上面的&lt;a href=&quot;index#prerequisite-information&quot;&gt;先决条件&lt;/a&gt;以了解更多信息。）</target>
        </trans-unit>
        <trans-unit id="c9b0b1517866a9c5a82dae561f05848a752afef3" translate="yes" xml:space="preserve">
          <source>If you are using positive filtering (testing for the existence of a label or that a label has a specific value), you can use &lt;code&gt;docker image ls&lt;/code&gt; with the same filtering syntax to see which images match your filter.</source>
          <target state="translated">如果使用正过滤（测试标签的存在或标签是否具有特定值），则可以使用具有相同过滤语法的 &lt;code&gt;docker image ls&lt;/code&gt; 来查看哪些图像与您的过滤器匹配。</target>
        </trans-unit>
        <trans-unit id="76e2bb35a43dba1912b56c6273200de74c793ab0" translate="yes" xml:space="preserve">
          <source>If you are using the &amp;ldquo;external&amp;rdquo; SSH type as detailed in the next section, you can include additional arguments to pass through to the &lt;code&gt;ssh&lt;/code&gt; binary in the generated command (unless they conflict with any of the default arguments for the command generated by Docker Machine). For instance, the following command forwards port 8080 from the &lt;code&gt;default&lt;/code&gt; machine to &lt;code&gt;localhost&lt;/code&gt; on your host computer:</source>
          <target state="translated">如果您正在使用下一节中详细介绍的&amp;ldquo;外部&amp;rdquo; SSH类型，则可以在生成的命令中包含其他参数以传递给 &lt;code&gt;ssh&lt;/code&gt; 二进制文件（除非它们与Docker Machine生成的命令的任何默认参数冲突） ）。例如，以下命令将端口8080从 &lt;code&gt;default&lt;/code&gt; 计算机转发到 &lt;code&gt;localhost&lt;/code&gt; 上的localhost：</target>
        </trans-unit>
        <trans-unit id="78cacb8f0970af90e5fbc8587816471552f94dd7" translate="yes" xml:space="preserve">
          <source>If you are using the &lt;code&gt;dockremap&lt;/code&gt; user, verify that Docker created it using the &lt;code&gt;id&lt;/code&gt; command.</source>
          <target state="translated">如果使用的是 &lt;code&gt;dockremap&lt;/code&gt; 用户，请验证Docker是否使用 &lt;code&gt;id&lt;/code&gt; 命令创建了它。</target>
        </trans-unit>
        <trans-unit id="b2b29c737f9d8243c7788a4630f669d6ca78eedb" translate="yes" xml:space="preserve">
          <source>If you are using the Nano &lt;a href=&quot;https://docs.docker.com/docker-for-windows/&quot;&gt;Windows Container&lt;/a&gt; and have not updated to the Windows Creator Update there is a bug affecting how &lt;a href=&quot;https://github.com/Microsoft/Virtualization-Documentation/issues/181#issuecomment-252671828&quot;&gt;Windows 10 talks to Containers via &amp;ldquo;NAT&amp;rdquo;&lt;/a&gt; (Network Address Translation). You must hit the IP of the container directly. You can get the IP address of your container with the following steps:</source>
          <target state="translated">如果您使用的是Nano &lt;a href=&quot;https://docs.docker.com/docker-for-windows/&quot;&gt;Windows容器&lt;/a&gt;，但尚未更新至Windows Creator更新，则存在一个错误会影响&lt;a href=&quot;https://github.com/Microsoft/Virtualization-Documentation/issues/181#issuecomment-252671828&quot;&gt;Windows 10&lt;/a&gt;如何通过&amp;ldquo; NAT&amp;rdquo;（网络地址转换）与容器进行对话。您必须直接点击容器的IP。您可以通过以下步骤获取容器的IP地址：</target>
        </trans-unit>
        <trans-unit id="b7697703344b8bfa4e06ceffe254b759b152c711" translate="yes" xml:space="preserve">
          <source>If you aren&amp;rsquo;t still running the &lt;code&gt;redis&lt;/code&gt; service from the &lt;a href=&quot;../rolling-update/index&quot;&gt;rolling update&lt;/a&gt; tutorial, start it now:</source>
          <target state="translated">如果您仍未从&lt;a href=&quot;../rolling-update/index&quot;&gt;滚动更新&lt;/a&gt;教程中运行 &lt;code&gt;redis&lt;/code&gt; 服务，请立即启动它：</target>
        </trans-unit>
        <trans-unit id="368583aa359f85c71d7ef552cb2bba7c470d7c55" translate="yes" xml:space="preserve">
          <source>If you aren&amp;rsquo;t sure where to begin, see &lt;a href=&quot;../../get-started/index&quot;&gt;Get Started with Docker&lt;/a&gt;, which guides you through a brief end-to-end tutorial on Docker.</source>
          <target state="translated">如果不确定从哪里开始，请参阅&lt;a href=&quot;../../get-started/index&quot;&gt;《 Docker入门》&lt;/a&gt;，它指导您完成有关Docker的简短端到端教程。</target>
        </trans-unit>
        <trans-unit id="677e084a7f52453cacbe4581900a8bed6dde6744" translate="yes" xml:space="preserve">
          <source>If you bind mount a host path into your service&amp;rsquo;s containers, the path must exist on every swarm node. The Docker swarm mode scheduler can schedule containers on any machine that meets resource availability requirements and satisfies all constraints and placement preferences you specify.</source>
          <target state="translated">如果将主机路径绑定安装到服务的容器中，则该路径必须存在于每个群集节点上。Docker群模式调度程序可以在满足资源可用性要求并满足您指定的所有约束和放置首选项的任何机器上调度容器。</target>
        </trans-unit>
        <trans-unit id="7b6deebe1e2047fa17ca4d7d8b24584b16cafcd5" translate="yes" xml:space="preserve">
          <source>If you can&amp;rsquo;t modify the application, wrap the application in a lightweight init system (like &lt;a href=&quot;http://skarnet.org/software/s6/&quot;&gt;s6&lt;/a&gt;) or a signal proxy (like &lt;a href=&quot;https://github.com/Yelp/dumb-init&quot;&gt;dumb-init&lt;/a&gt; or &lt;a href=&quot;https://github.com/krallin/tini&quot;&gt;tini&lt;/a&gt;). Either of these wrappers take care of handling &lt;code&gt;SIGTERM&lt;/code&gt; properly.</source>
          <target state="translated">如果您无法修改应用程序，请将应用程序包装在轻量级的初始化系统（如&lt;a href=&quot;http://skarnet.org/software/s6/&quot;&gt;s6&lt;/a&gt;）或信号代理（如&lt;a href=&quot;https://github.com/Yelp/dumb-init&quot;&gt;dumb-init&lt;/a&gt;或&lt;a href=&quot;https://github.com/krallin/tini&quot;&gt;tini&lt;/a&gt;）中。这些包装器中的任何一个都负责正确处理 &lt;code&gt;SIGTERM&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="02c4e70f5a3eb75d17adc426b1ff53b0d5f52c8e" translate="yes" xml:space="preserve">
          <source>If you change a service&amp;rsquo;s Dockerfile or the contents of its build directory, run &lt;code&gt;docker-compose build&lt;/code&gt; to rebuild it.</source>
          <target state="translated">如果更改服务的Dockerfile或其构建目录的内容，请运行 &lt;code&gt;docker-compose build&lt;/code&gt; 来重建它。</target>
        </trans-unit>
        <trans-unit id="f8b12dcc3d165b1ceb7248d071ff3c281634c921" translate="yes" xml:space="preserve">
          <source>If you change the parent image for a provider, you may also need to change the SSH user. For example, the default Red Hat AMI on EC2 expects the SSH user to be &lt;code&gt;ec2-user&lt;/code&gt;, so you need to specify this with &lt;code&gt;--amazonec2-ssh-user ec2-user&lt;/code&gt;.</source>
          <target state="translated">如果您更改提供程序的父映像，则可能还需要更改SSH用户。例如，EC2上的默认Red Hat AMI期望SSH用户为 &lt;code&gt;ec2-user&lt;/code&gt; ，因此您需要使用 &lt;code&gt;--amazonec2-ssh-user ec2-user&lt;/code&gt; 进行指定。</target>
        </trans-unit>
        <trans-unit id="4ae5a54c0c585b0a1692438e48f55bed24f9e64d" translate="yes" xml:space="preserve">
          <source>If you create a host with Docker Machine, but remove it through the cloud provider console, Machine loses track of the server status. Use the &lt;code&gt;docker-machine rm&lt;/code&gt; command for hosts you create with &lt;code&gt;docker-machine create&lt;/code&gt;.</source>
          <target state="translated">如果使用Docker Machine创建主机，但通过云提供商控制台将其删除，则Machine不会跟踪服务器状态。对通过 &lt;code&gt;docker-machine create&lt;/code&gt; 创建的主机使用 &lt;code&gt;docker-machine rm&lt;/code&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="0ddb8f8f01a1f039f50afb43e83a32148b908250" translate="yes" xml:space="preserve">
          <source>If you define both links and &lt;a href=&quot;#networks&quot;&gt;networks&lt;/a&gt;, services with links between them must share at least one network in common to communicate.</source>
          <target state="translated">如果同时定义链接和&lt;a href=&quot;#networks&quot;&gt;网络&lt;/a&gt;，则它们之间具有链接的服务必须共享至少一个公共网络才能进行通信。</target>
        </trans-unit>
        <trans-unit id="3e4476a0e97f80119a8fa4e29728f09d4d507972" translate="yes" xml:space="preserve">
          <source>If you develop a container that can be deployed as a service and requires sensitive data, such as a credential, as an environment variable, consider adapting your image to take advantage of Docker secrets. One way to do this is to ensure that each parameter you pass to the image when creating the container can also be read from a file.</source>
          <target state="translated">如果你开发了一个可以作为服务部署的容器,并且需要敏感数据(如凭证)作为环境变量,请考虑调整你的镜像以利用Docker秘密。一种方法是确保你在创建容器时传递给镜像的每个参数也可以从文件中读取。</target>
        </trans-unit>
        <trans-unit id="575871ae346b7ca4b69480dc45ec836ca0a477cf" translate="yes" xml:space="preserve">
          <source>If you do block IO in the two containers at the same time, by, for example:</source>
          <target state="translated">如果你在两个容器中同时进行IO阻塞,通过,例如。</target>
        </trans-unit>
        <trans-unit id="ad68409f5cc1b6d48388836f2da83fbcbce47bfc" translate="yes" xml:space="preserve">
          <source>If you do not export this variable in self-hosted environments, you may see errors such as:</source>
          <target state="translated">如果你没有在自我托管的环境中导出这个变量,你可能会看到这样的错误。</target>
        </trans-unit>
        <trans-unit id="d0c0870c394081af7e96cfb9ed1a8f8118d90581" translate="yes" xml:space="preserve">
          <source>If you do not log in, you will see:</source>
          <target state="translated">如果你没有登录,你会看到。</target>
        </trans-unit>
        <trans-unit id="e759bd57a5d5499c4aeaa122b36fe9453f06c102" translate="yes" xml:space="preserve">
          <source>If you do not specify &lt;code&gt;-a&lt;/code&gt; then Docker will &lt;a href=&quot;https://github.com/docker/docker/blob/4118e0c9eebda2412a09ae66e90c34b85fae3275/runconfig/opts/parse.go#L267&quot;&gt;attach to both stdout and stderr &lt;/a&gt;. You can specify to which of the three standard streams (&lt;code&gt;STDIN&lt;/code&gt;, &lt;code&gt;STDOUT&lt;/code&gt;, &lt;code&gt;STDERR&lt;/code&gt;) you&amp;rsquo;d like to connect instead, as in:</source>
          <target state="translated">如果不指定 &lt;code&gt;-a&lt;/code&gt; ,则Docker将同时&lt;a href=&quot;https://github.com/docker/docker/blob/4118e0c9eebda2412a09ae66e90c34b85fae3275/runconfig/opts/parse.go#L267&quot;&gt;附加到stdout和stderr&lt;/a&gt;。您可以指定要连接到三个标准流（ &lt;code&gt;STDIN&lt;/code&gt; ， &lt;code&gt;STDOUT&lt;/code&gt; ， &lt;code&gt;STDERR&lt;/code&gt; ）中的哪一个，如下所示：</target>
        </trans-unit>
        <trans-unit id="476784f24aefd123d2cb435131f1cf88ecf21040" translate="yes" xml:space="preserve">
          <source>If you do not use a host path, you may specify a &lt;code&gt;volume_driver&lt;/code&gt;.</source>
          <target state="translated">如果不使用主机路径，则可以指定 &lt;code&gt;volume_driver&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2269d1903015b14c57c7a26494021cc386473ebd" translate="yes" xml:space="preserve">
          <source>If you do not want the &lt;code&gt;run&lt;/code&gt; command to start linked containers, use the &lt;code&gt;--no-deps&lt;/code&gt; flag:</source>
          <target state="translated">如果您不希望 &lt;code&gt;run&lt;/code&gt; 命令启动链接的容器，请使用 &lt;code&gt;--no-deps&lt;/code&gt; 标志：</target>
        </trans-unit>
        <trans-unit id="d287d7c9376af746a858827f8d67d9315d68426a" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t &lt;a href=&quot;#formatting&quot;&gt;specify a format string using &lt;code&gt;--format&lt;/code&gt;&lt;/a&gt;, the following columns are shown.</source>
          <target state="translated">如果未&lt;a href=&quot;#formatting&quot;&gt;使用 &lt;code&gt;--format&lt;/code&gt; &lt;/a&gt;指定格式字符串，则会显示以下列。</target>
        </trans-unit>
        <trans-unit id="97c3b203c765b267f7eceec41a1189986ca17c67" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t have a Docker account, sign up for one at &lt;a href=&quot;https://hub.docker.com&quot;&gt;hub.docker.com&lt;/a&gt;. Make note of your username.</source>
          <target state="translated">如果您没有Docker帐户，请在&lt;a href=&quot;https://hub.docker.com&quot;&gt;hub.docker.com上&lt;/a&gt;注册一个。记下您的用户名。</target>
        </trans-unit>
        <trans-unit id="e1f8511b6607846f2f14740a4b7e2cebbfecee87" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t have a credentials file, you can use the flags &lt;code&gt;--amazonec2-access-key&lt;/code&gt; and &lt;code&gt;--amazonec2-secret-key&lt;/code&gt; on the command line:</source>
          <target state="translated">如果没有凭据文件，则可以在命令行上使用 &lt;code&gt;--amazonec2-access-key&lt;/code&gt; 和 &lt;code&gt;--amazonec2-secret-key&lt;/code&gt; 标志：</target>
        </trans-unit>
        <trans-unit id="186a5d7235f15d036cee477654f5d9ca373a8af2" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t have the command available, you can run the following command on a manager node to retrieve the join command for a worker:</source>
          <target state="translated">如果没有可用的命令，则可以在管理器节点上运行以下命令以检索工作程序的加入命令：</target>
        </trans-unit>
        <trans-unit id="2a7a5196a1d87d7c58d0e216e7c0f9dc1737deed" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t see your question here, feel free to drop by &lt;code&gt;#docker-compose&lt;/code&gt; on freenode IRC and ask the community.</source>
          <target state="translated">如果您在这里没有看到您的问题，请随时在freenode IRC上 &lt;code&gt;#docker-compose&lt;/code&gt; 并询问社区。</target>
        </trans-unit>
        <trans-unit id="90f9cf27e5ec7a779ebedfcb606fe402ca756713" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t specify a &lt;code&gt;tag&lt;/code&gt;, the &lt;code&gt;latest&lt;/code&gt; tag is used. For example, to filter for containers that use the latest &lt;code&gt;ubuntu&lt;/code&gt; image:</source>
          <target state="translated">如果未指定 &lt;code&gt;tag&lt;/code&gt; ，则使用 &lt;code&gt;latest&lt;/code&gt; 标签。例如，要过滤使用最新 &lt;code&gt;ubuntu&lt;/code&gt; 映像的容器，请执行以下操作：</target>
        </trans-unit>
        <trans-unit id="7e2db7766d9aa0955958ff142a92f9d3065e673c" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t specify a version at all, by convention the image&amp;rsquo;s &lt;code&gt;latest&lt;/code&gt; tag is resolved to a digest. Workers use the image at this digest when creating the service task.</source>
          <target state="translated">如果根本不指定版本，则按照惯例，图像的 &lt;code&gt;latest&lt;/code&gt; 标签将解析为摘要。在创建服务任务时，工作人员会在此摘要中使用映像。</target>
        </trans-unit>
        <trans-unit id="b9f94a0c049d039b02da59313a42d240802217fd" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t specify an advertise address, Docker checks if the system has a single IP address. If so, Docker uses the IP address with the listening port &lt;code&gt;2377&lt;/code&gt; by default. If the system has multiple IP addresses, you must specify the correct &lt;code&gt;--advertise-addr&lt;/code&gt; to enable inter-manager communication and overlay networking:</source>
          <target state="translated">如果您未指定播发地址，则Docker将检查系统是否具有单个IP地址。如果是这样，默认情况下，Docker使用带有侦听端口 &lt;code&gt;2377&lt;/code&gt; 的IP地址。如果系统具有多个IP地址，则必须指定正确的 &lt;code&gt;--advertise-addr&lt;/code&gt; 以启用管理器间通信和覆盖网络：</target>
        </trans-unit>
        <trans-unit id="3aef570b6454b7ea0e31c6e16f44892153fe92d2" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t want to have complete two-way authentication, you can run Docker in various other modes by mixing the flags.</source>
          <target state="translated">如果您不想进行完整的双向身份验证，则可以通过混合标志以其他各种模式运行Docker。</target>
        </trans-unit>
        <trans-unit id="9e1a12a4cf16290ef09f612e3eaf11afdf8d41ce" translate="yes" xml:space="preserve">
          <source>If you enable user namespaces on the daemon, all containers are started with user namespaces enabled by default. In some situations, such as privileged containers, you may need to disable user namespaces for a specific container. See &lt;a href=&quot;#user-namespace-known-restrictions&quot;&gt;user namespace known limitations&lt;/a&gt; for some of these limitations.</source>
          <target state="translated">如果在守护程序上启用用户名称空间，则默认情况下，所有容器都以启用的用户名称空间启动。在某些情况下，例如特权容器，您可能需要禁用特定容器的用户名称空间。有关这些限制中的某些&lt;a href=&quot;#user-namespace-known-restrictions&quot;&gt;限制&lt;/a&gt;，请参见用户名称空间已知限制。</target>
        </trans-unit>
        <trans-unit id="31d701341bbccced849a07cc643cb47aefef082b" translate="yes" xml:space="preserve">
          <source>If you encounter any troubles, activate the debug mode with &lt;code&gt;docker-machine --debug create ...&lt;/code&gt;.</source>
          <target state="translated">如果遇到任何问题，请使用 &lt;code&gt;docker-machine --debug create ...&lt;/code&gt; 激活调试模式。</target>
        </trans-unit>
        <trans-unit id="112b7f8b8599cb8cc231efdf128113ada642d6dc" translate="yes" xml:space="preserve">
          <source>If you expect to run multiple service tasks on each node (such as when you have 5 nodes but run 10 replicas), you cannot specify a static target port. Either allow Docker to assign a random high-numbered port (by leaving off the &lt;code&gt;published&lt;/code&gt;), or ensure that only a single instance of the service runs on a given node, by using a global service rather than a replicated one, or by using placement constraints.</source>
          <target state="translated">如果希望在每个节点上运行多个服务任务（例如，当您有5个节点但运行10个副本时），则不能指定静态目标端口。允许Docker分配一个随机的高编号端口（通过不使用 &lt;code&gt;published&lt;/code&gt; 端口），或者通过使用全局服务而不是复制的服务或通过使用布局来确保仅单个服务实例在给定节点上运行约束。</target>
        </trans-unit>
        <trans-unit id="0a7daaab452426ed2cf511180ebc213bd02bd56f" translate="yes" xml:space="preserve">
          <source>If you forget and use a single dollar sign (&lt;code&gt;$&lt;/code&gt;), Compose interprets the value as an environment variable and warns you:</source>
          <target state="translated">如果忘记并使用单个美元符号（ &lt;code&gt;$&lt;/code&gt; ），则Compose会将值解释为环境变量，并警告您：</target>
        </trans-unit>
        <trans-unit id="5a0595a7809e4ba754d3137ba4f6017c2b6339eb" translate="yes" xml:space="preserve">
          <source>If you forget to add &lt;code&gt;exec&lt;/code&gt; to the beginning of your &lt;code&gt;ENTRYPOINT&lt;/code&gt;:</source>
          <target state="translated">如果您忘记将 &lt;code&gt;exec&lt;/code&gt; 添加到 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 的开头：</target>
        </trans-unit>
        <trans-unit id="fdabe86ef88a25b0fef6bce2a5c26f06f91591bb" translate="yes" xml:space="preserve">
          <source>If you get a &amp;ldquo;Permission denied&amp;rdquo; error using either of the above methods, you probably do not have the proper permissions to remove &lt;code&gt;docker-compose&lt;/code&gt;. To force the removal, prepend &lt;code&gt;sudo&lt;/code&gt; to either of the above commands and run again.</source>
          <target state="translated">如果使用以上两种方法中的任何一种都会出现&amp;ldquo;权限被拒绝&amp;rdquo;错误，则您可能没有删除 &lt;code&gt;docker-compose&lt;/code&gt; 的适当权限。要强制删除，请将 &lt;code&gt;sudo&lt;/code&gt; 放在上述任一命令之前，然后再次运行。</target>
        </trans-unit>
        <trans-unit id="ec431f0597a613ee0d286ae44f8214fdcb018868" translate="yes" xml:space="preserve">
          <source>If you have a &lt;code&gt;package.json&lt;/code&gt; entry for &lt;code&gt;script:start&lt;/code&gt; like &lt;code&gt;NODE_ENV=test node server.js&lt;/code&gt;, then this overrules any setting in your &lt;code&gt;docker-compose.yml&lt;/code&gt; file.</source>
          <target state="translated">如果您有一个用于 &lt;code&gt;script:start&lt;/code&gt; 的 &lt;code&gt;package.json&lt;/code&gt; 条目，例如 &lt;code&gt;NODE_ENV=test node server.js&lt;/code&gt; ，则这将 &lt;code&gt;docker-compose.yml&lt;/code&gt; 您的docker-compose.yml文件中的所有设置。</target>
        </trans-unit>
        <trans-unit id="b8c6561ca760c20f5dcb12a3fc439c1eedd35e1f" translate="yes" xml:space="preserve">
          <source>If you have an Amazon account, you can use it as your root user account.</source>
          <target state="translated">如果你有一个亚马逊账户,你可以用它作为你的根用户账户。</target>
        </trans-unit>
        <trans-unit id="c9580378ea68280b6d09c17970d8810b86a9bec8" translate="yes" xml:space="preserve">
          <source>If you have enabled authentication for your notary server, or are using DTR, you will need to log in before you can push data to the notary server.</source>
          <target state="translated">如果您已经为您的公证服务器启用了身份验证,或者正在使用DTR,您将需要先登录,然后才能将数据推送到公证服务器。</target>
        </trans-unit>
        <trans-unit id="df676371c5819ad05d694e0dbbb415d9904e6ae0" translate="yes" xml:space="preserve">
          <source>If you have not already done so, initialize or join the swarm.</source>
          <target state="translated">如果您还没有这样做,请初始化或加入蜂群。</target>
        </trans-unit>
        <trans-unit id="4e30bacce350f0e702c08acd910918c385b995e2" translate="yes" xml:space="preserve">
          <source>If you have not done so already, go to &lt;a href=&quot;https://digitalocean.com&quot;&gt;DigitalOcean&lt;/a&gt;, create an account, and log in.</source>
          <target state="translated">如果尚未这样做，请转到&lt;a href=&quot;https://digitalocean.com&quot;&gt;DigitalOcean&lt;/a&gt;，创建一个帐户，然后登录。</target>
        </trans-unit>
        <trans-unit id="1d7fa2fe87a8040f995c006f37eda109d7f982bf" translate="yes" xml:space="preserve">
          <source>If you have problems installing with &lt;code&gt;curl&lt;/code&gt;, see &lt;a href=&quot;index#alternative-install-options&quot;&gt;Alternative Install Options&lt;/a&gt; tab above.</source>
          <target state="translated">如果使用 &lt;code&gt;curl&lt;/code&gt; 安装时遇到问题，请参见上方的&amp;ldquo; &lt;a href=&quot;index#alternative-install-options&quot;&gt;其他安装选项&amp;rdquo;&lt;/a&gt;标签。</target>
        </trans-unit>
        <trans-unit id="c0d30bbe3e73c97a181f9b5fb530d8bc16648ce5" translate="yes" xml:space="preserve">
          <source>If you have set the &lt;code&gt;--exec-opt isolation=hyperv&lt;/code&gt; option on the Docker &lt;code&gt;daemon&lt;/code&gt;, or are running against a Windows client-based daemon, these commands are equivalent and result in &lt;code&gt;hyperv&lt;/code&gt; isolation:</source>
          <target state="translated">如果已在Docker &lt;code&gt;daemon&lt;/code&gt; 上设置了 &lt;code&gt;--exec-opt isolation=hyperv&lt;/code&gt; 选项，或者正在针对基于Windows客户端的守护程序运行，则这些命令是等效的，并导致 &lt;code&gt;hyperv&lt;/code&gt; 隔离：</target>
        </trans-unit>
        <trans-unit id="27bc0ab6e19cfb93bab11e15f49e5ec527f5e9d4" translate="yes" xml:space="preserve">
          <source>If you have specified a Compose file with &lt;code&gt;docker-compose -f FILE&lt;/code&gt;, paths in &lt;code&gt;env_file&lt;/code&gt; are relative to the directory that file is in.</source>
          <target state="translated">如果您使用 &lt;code&gt;env_file&lt;/code&gt; &lt;code&gt;docker-compose -f FILE&lt;/code&gt; 指定了Compose文件，则env_file中的路径相对于该文件所在的目录。</target>
        </trans-unit>
        <trans-unit id="4c624b96392eed6cb4a25b48781b927859504beb" translate="yes" xml:space="preserve">
          <source>If you haven&amp;rsquo;t already, open a terminal and ssh into the machine where you run your manager node. For example, the tutorial uses a machine named &lt;code&gt;manager1&lt;/code&gt;.</source>
          <target state="translated">如果还没有，请打开一个终端并SSH到运行管理器节点的计算机中。例如，本教程使用一台名为 &lt;code&gt;manager1&lt;/code&gt; 的计算机。</target>
        </trans-unit>
        <trans-unit id="73230dff0e33a8a35566ac878466b9d94eaacf09" translate="yes" xml:space="preserve">
          <source>If you haven&amp;rsquo;t already, read through the &lt;a href=&quot;../../index&quot;&gt;swarm mode overview&lt;/a&gt; and &lt;a href=&quot;../../key-concepts/index&quot;&gt;key concepts&lt;/a&gt;.</source>
          <target state="translated">如果还没有，请&lt;a href=&quot;../../index&quot;&gt;仔细&lt;/a&gt;阅读群模式概述和&lt;a href=&quot;../../key-concepts/index&quot;&gt;关键概念&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1c35ab7ea35c78a523d674b84dfd6863dfd1809a" translate="yes" xml:space="preserve">
          <source>If you haven&amp;rsquo;t already, read through the &lt;a href=&quot;../key-concepts/index&quot;&gt;swarm mode key concepts&lt;/a&gt; and try the &lt;a href=&quot;../swarm-tutorial/index&quot;&gt;swarm mode tutorial&lt;/a&gt;.</source>
          <target state="translated">如果还没有，请通读&lt;a href=&quot;../key-concepts/index&quot;&gt;Swarm模式的关键概念&lt;/a&gt;并尝试&lt;a href=&quot;../swarm-tutorial/index&quot;&gt;Swarm模式教程&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="44b3c07612b11f7dd33d17db452912ab881d8624" translate="yes" xml:space="preserve">
          <source>If you initialising a repository at the same time as adding a Delegation public key, then you will need to use the local Notary Canonical Root Key&amp;rsquo;s passphrase to create the repositories trust data. If the repository has already been initiated then you only need the repositories passphrase.</source>
          <target state="translated">如果在添加委派公钥的同时初始化存储库，则将需要使用本地公证人规范根密钥的密码来创建存储库信任数据。如果存储库已经启动，则只需要存储库密码。</target>
        </trans-unit>
        <trans-unit id="e63158a6521adef6c04e67e8f222344084eed92b" translate="yes" xml:space="preserve">
          <source>If you lose access to a worker node or need to shut it down because it has been compromised or is not behaving as expected, you can use the &lt;code&gt;--force&lt;/code&gt; option. This may cause transient errors or interruptions, depending on the type of task being run on the node.</source>
          <target state="translated">如果您无法访问工作节点或由于工作节点受到破坏或无法正常工作而将其关闭，则可以使用 &lt;code&gt;--force&lt;/code&gt; 选项。根据节点上正在运行的任务类型，这可能会导致暂时性错误或中断。</target>
        </trans-unit>
        <trans-unit id="ae6a010aba3052de923dc1a0812631822b83748e" translate="yes" xml:space="preserve">
          <source>If you lose the quorum of managers, you cannot administer the swarm. If you have lost the quorum and you attempt to perform any management operation on the swarm, an error occurs:</source>
          <target state="translated">如果您失去了管理人员的法定人数,您就无法管理蜂群。如果您失去了法定人数,并且您试图对蜂群执行任何管理操作,就会发生错误。</target>
        </trans-unit>
        <trans-unit id="2c3618312f0fb948df52713298290856e3c5f9bf" translate="yes" xml:space="preserve">
          <source>If you make a configuration change to a service and run &lt;code&gt;docker-compose up&lt;/code&gt; to update it, the old container is removed and the new one joins the network under a different IP address but the same name. Running containers can look up that name and connect to the new address, but the old address stops working.</source>
          <target state="translated">如果您对服务进行配置更改并运行 &lt;code&gt;docker-compose up&lt;/code&gt; 对其进行更新，则会删除旧容器，而新容器将使用其他IP地址但名称相同的网络加入网络。正在运行的容器可以查找该名称并连接到新地址，但是旧地址会停止工作。</target>
        </trans-unit>
        <trans-unit id="28ca5338e03516d6e85957114569eb9edfecb11f" translate="yes" xml:space="preserve">
          <source>If you make changes to the Gemfile or the Compose file to try out some different configurations, you need to rebuild. Some changes require only &lt;code&gt;docker-compose up --build&lt;/code&gt;, but a full rebuild requires a re-run of &lt;code&gt;docker-compose run web bundle install&lt;/code&gt; to sync changes in the &lt;code&gt;Gemfile.lock&lt;/code&gt; to the host, followed by &lt;code&gt;docker-compose up --build&lt;/code&gt;.</source>
          <target state="translated">如果您对Gemfile或Compose文件进行更改以尝试一些不同的配置，则需要重新构建。某些更改仅需要 &lt;code&gt;docker-compose up --build&lt;/code&gt; ，但是完整的重建需要重新运行 &lt;code&gt;Gemfile.lock&lt;/code&gt; &lt;code&gt;docker-compose run web bundle install&lt;/code&gt; 以将Gemfile.lock中的更改同步到主机，然后进行docker &lt;code&gt;docker-compose up --build&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="511372394806f22d5d413a6d63dab33b33733ec8" translate="yes" xml:space="preserve">
          <source>If you make changes to your &lt;code&gt;docker-compose.yml&lt;/code&gt; configuration these changes are not reflected after running this command.</source>
          <target state="translated">如果您对 &lt;code&gt;docker-compose.yml&lt;/code&gt; 配置进行更改，则在运行此命令后这些更改不会反映出来。</target>
        </trans-unit>
        <trans-unit id="4e1b2d3b6e0287ec3840f8f5d7b6ca6f47e3145b" translate="yes" xml:space="preserve">
          <source>If you monitor the DigitalOcean console while you run these commands, notice that it updates first to reflect that the Droplet was stopped, and then removed.</source>
          <target state="translated">如果您在运行这些命令时监控DigitalOcean控制台,请注意它首先更新以反映Droplet被停止,然后被删除。</target>
        </trans-unit>
        <trans-unit id="d3500e3f935d0491451fee9be69722afb640b71d" translate="yes" xml:space="preserve">
          <source>If you need Docker to be reachable through the network in a safe manner, you can enable TLS by specifying the &lt;code&gt;tlsverify&lt;/code&gt; flag and pointing Docker&amp;rsquo;s &lt;code&gt;tlscacert&lt;/code&gt; flag to a trusted CA certificate.</source>
          <target state="translated">如果您需要以安全的方式通过网络访问Docker，则可以通过指定 &lt;code&gt;tlsverify&lt;/code&gt; 标志并将Docker的 &lt;code&gt;tlscacert&lt;/code&gt; 标志指向受信任的CA证书来启用TLS 。</target>
        </trans-unit>
        <trans-unit id="ee0da37c49a203be0b0c00544fccf8f34e920f37" translate="yes" xml:space="preserve">
          <source>If you need to access the Docker daemon remotely, you need to enable the &lt;code&gt;tcp&lt;/code&gt; Socket. Beware that the default setup provides un-encrypted and un-authenticated direct access to the Docker daemon - and should be secured either using the &lt;a href=&quot;../../../security/https/index&quot;&gt;built in HTTPS encrypted socket&lt;/a&gt;, or by putting a secure web proxy in front of it. You can listen on port &lt;code&gt;2375&lt;/code&gt; on all network interfaces with &lt;code&gt;-H tcp://0.0.0.0:2375&lt;/code&gt;, or on a particular network interface using its IP address: &lt;code&gt;-H tcp://192.168.59.103:2375&lt;/code&gt;. It is conventional to use port &lt;code&gt;2375&lt;/code&gt; for un-encrypted, and port &lt;code&gt;2376&lt;/code&gt; for encrypted communication with the daemon.</source>
          <target state="translated">如果需要远程访问Docker守护程序，则需要启用 &lt;code&gt;tcp&lt;/code&gt; Socket。请注意，默认设置可提供对Docker守护程序的未加密和未经身份验证的直接访问-应该使用&lt;a href=&quot;../../../security/https/index&quot;&gt;内置的HTTPS加密套接字&lt;/a&gt;或在其前面放置安全的Web代理来保护其安全。您可以使用 &lt;code&gt;-H tcp://0.0.0.0:2375&lt;/code&gt; &lt;code&gt;2375&lt;/code&gt; 在所有网络接口上侦听端口2375，或者使用其IP地址 &lt;code&gt;-H tcp://192.168.59.103:2375&lt;/code&gt; 在特定网络接口上侦听。通常将端口 &lt;code&gt;2375&lt;/code&gt; 用于未加密，将端口 &lt;code&gt;2376&lt;/code&gt; 用于与守护程序进行加密通信。</target>
        </trans-unit>
        <trans-unit id="0952059872af3e935d42cc7f6dac3f46092b7fcf" translate="yes" xml:space="preserve">
          <source>If you need to check which profiles are loaded, you can use &lt;code&gt;aa-status&lt;/code&gt;. The output looks like:</source>
          <target state="translated">如果需要检查加载了哪些概要文件，可以使用 &lt;code&gt;aa-status&lt;/code&gt; 。输出如下：</target>
        </trans-unit>
        <trans-unit id="c4889f2d00afd68bf034d55d016d0f18c450fd83" translate="yes" xml:space="preserve">
          <source>If you need to manually generate a private key (either RSA or ECDSA) and a x509 certificate containing the public key, you can use local tools like openssl or cfssl along with a local or company-wide Certificate Authority.</source>
          <target state="translated">如果你需要手动生成私钥(RSA或ECDSA)和包含公钥的x509证书,你可以使用本地工具(如openssl或cfssl)以及本地或公司范围内的证书颁发机构。</target>
        </trans-unit>
        <trans-unit id="d4f9f9f0f0838499c343537a3127971e2ad0133a" translate="yes" xml:space="preserve">
          <source>If you need to override this behaviour then you may do so by adding an &lt;code&gt;ARG&lt;/code&gt; statement in the Dockerfile as follows:</source>
          <target state="translated">如果需要覆盖此行为，则可以通过在Dockerfile中添加 &lt;code&gt;ARG&lt;/code&gt; 语句来做到这一点，如下所示：</target>
        </trans-unit>
        <trans-unit id="e46494b98ed899c05feff50f24f4bdea68dd67d3" translate="yes" xml:space="preserve">
          <source>If you need to remove a delegation, including the contributor keys that are attached to the &lt;code&gt;targets/releases&lt;/code&gt; role, you can use the &lt;code&gt;$ docker trust signer remove&lt;/code&gt; command.</source>
          <target state="translated">如果需要删除委派，包括附加到 &lt;code&gt;targets/releases&lt;/code&gt; 角色的贡献者密钥，则可以使用 &lt;code&gt;$ docker trust signer remove&lt;/code&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="4a6f513d5288ddf988469918598793e3c364b229" translate="yes" xml:space="preserve">
          <source>If you need to write a starter script for a single executable, you can ensure that the final executable receives the Unix signals by using &lt;code&gt;exec&lt;/code&gt; and &lt;code&gt;gosu&lt;/code&gt; commands:</source>
          <target state="translated">如果需要为单个可执行文件编写启动脚本，则可以使用 &lt;code&gt;exec&lt;/code&gt; 和 &lt;code&gt;gosu&lt;/code&gt; 命令确保最终的可执行文件接收Unix信号：</target>
        </trans-unit>
        <trans-unit id="37902edb8f1e3a55f58f04264d82136215da07c2" translate="yes" xml:space="preserve">
          <source>If you omit the &lt;code&gt;--gateway&lt;/code&gt; flag the Engine selects one for you from inside a preferred pool. For &lt;code&gt;overlay&lt;/code&gt; networks and for network driver plugins that support it you can create multiple subnetworks. This example uses two &lt;code&gt;/25&lt;/code&gt; subnet mask to adhere to the current guidance of not having more than 256 IPs in a single overlay network. Each of the subnetworks has 126 usable addresses.</source>
          <target state="translated">如果省略 &lt;code&gt;--gateway&lt;/code&gt; 标志，则引擎将从首选池中为您选择一个。对于 &lt;code&gt;overlay&lt;/code&gt; 网络和支持它的网络驱动程序插件，您可以创建多个子网。本示例使用两个 &lt;code&gt;/25&lt;/code&gt; 子网掩码来遵守当前的指导原则，即单个覆盖网络中的IP不能超过256个。每个子网都有126个可用地址。</target>
        </trans-unit>
        <trans-unit id="a3b78ea5d40070d80f18e7eaf1af0573a49695aa" translate="yes" xml:space="preserve">
          <source>If you omit the &lt;code&gt;file&lt;/code&gt; Compose looks for the service configuration in the current file. The &lt;code&gt;file&lt;/code&gt; value can be an absolute or relative path. If you specify a relative path, Compose treats it as relative to the location of the current file.</source>
          <target state="translated">如果省略 &lt;code&gt;file&lt;/code&gt; Compose，则在当前文件中查找服务配置。该 &lt;code&gt;file&lt;/code&gt; 的值可以是绝对或相对路径。如果指定相对路径，则Compose会将其视为相对于当前文件位置的相对路径。</target>
        </trans-unit>
        <trans-unit id="80d2e44c1f141d5064daaf1f38a829370fdbe955" translate="yes" xml:space="preserve">
          <source>If you pass an URL to a remote tarball, the URL itself is sent to the daemon:</source>
          <target state="translated">如果你把一个 URL 传给远程 tar 包,URL 本身会被发送到守护进程。</target>
        </trans-unit>
        <trans-unit id="3f9c6ae5da03730139ef24fe6677ab9ed991de3e" translate="yes" xml:space="preserve">
          <source>If you plan on creating an overlay network with encryption (&lt;code&gt;--opt encrypted&lt;/code&gt;), you also need to ensure &lt;strong&gt;ip protocol 50&lt;/strong&gt; (&lt;strong&gt;ESP&lt;/strong&gt;) traffic is allowed.</source>
          <target state="translated">如果计划使用加密（ &lt;code&gt;--opt encrypted&lt;/code&gt; ）创建覆盖网络，则还需要确保允许&lt;strong&gt;ip协议50&lt;/strong&gt;（&lt;strong&gt;ESP&lt;/strong&gt;）流量。</target>
        </trans-unit>
        <trans-unit id="72b7ff831e71e67c0ef2cd48dded3a0b6f723cfe" translate="yes" xml:space="preserve">
          <source>If you request a field which is itself a structure containing other fields, by default you get a Go-style dump of the inner values. Docker adds a template function, &lt;code&gt;json&lt;/code&gt;, which can be applied to get results in JSON format.</source>
          <target state="translated">如果您请求的字段本身就是包含其他字段的结构，则默认情况下会获得内部值的Go样式转储。Docker添加了一个模板函数 &lt;code&gt;json&lt;/code&gt; ，该函数可用于获取JSON格式的结果。</target>
        </trans-unit>
        <trans-unit id="04c8c8edebe5a6d5ad0d9b5e6df328d8f16759ea" translate="yes" xml:space="preserve">
          <source>If you run &lt;code&gt;docker-compose pull ServiceName&lt;/code&gt; in the same directory as the &lt;code&gt;docker-compose.yml&lt;/code&gt; file that defines the service, Docker pulls the associated image. For example, to call the &lt;code&gt;postgres&lt;/code&gt; image configured as the &lt;code&gt;db&lt;/code&gt; service in our example, you would run &lt;code&gt;docker-compose pull db&lt;/code&gt;.</source>
          <target state="translated">如果您在定义服务 &lt;code&gt;docker-compose.yml&lt;/code&gt; 文件所在的目录中运行 &lt;code&gt;docker-compose pull ServiceName&lt;/code&gt; ，则Docker将提取关联的映像。例如，要调用在我们的示例中配置为 &lt;code&gt;db&lt;/code&gt; 服务的 &lt;code&gt;postgres&lt;/code&gt; 映像，可以运行 &lt;code&gt;docker-compose pull db&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0c1744d53e996e2ed00f0ad0c01a9c200f6d0c7a" translate="yes" xml:space="preserve">
          <source>If you run into problems running with this set, resolve the mismatch through upgrade and remove this setting to see if your problems resolve before notifying support.</source>
          <target state="translated">如果您在使用这套设备运行时遇到问题,请通过升级解决不匹配的问题,并删除此设置,看看您的问题是否解决后再通知支持。</target>
        </trans-unit>
        <trans-unit id="eae463513aaad946db39f2c9729b2d814bc44de9" translate="yes" xml:space="preserve">
          <source>If you run this image with &lt;code&gt;docker run -it --rm -p 80:80 --name test apache&lt;/code&gt;, you can then examine the container&amp;rsquo;s processes with &lt;code&gt;docker exec&lt;/code&gt;, or &lt;code&gt;docker top&lt;/code&gt;, and then ask the script to stop Apache:</source>
          <target state="translated">如果使用 &lt;code&gt;docker run -it --rm -p 80:80 --name test apache&lt;/code&gt; 运行此映像，则可以使用docker &lt;code&gt;docker exec&lt;/code&gt; 或 &lt;code&gt;docker top&lt;/code&gt; 检查容器的进程，然后要求脚本停止Apache：</target>
        </trans-unit>
        <trans-unit id="28cee36c61bf81b77eafafafc0dd47c3cb44ed47" translate="yes" xml:space="preserve">
          <source>If you set your keys in a credentials file, the command looks like this to create an instance called &lt;code&gt;aws-sandbox&lt;/code&gt;:</source>
          <target state="translated">如果您在凭据文件中设置密钥，该命令将类似于以下命令创建一个名为 &lt;code&gt;aws-sandbox&lt;/code&gt; 的实例：</target>
        </trans-unit>
        <trans-unit id="33f3e6ba427995546432a7456f18192fd3154cf4" translate="yes" xml:space="preserve">
          <source>If you shut down your local host, Docker machines stops running. You can check the status of machines by running &lt;code&gt;docker-machine ls&lt;/code&gt;.</source>
          <target state="translated">如果关闭本地主机，则Docker计算机将停止运行。您可以通过运行 &lt;code&gt;docker-machine ls&lt;/code&gt; 来检查机器的状态。</target>
        </trans-unit>
        <trans-unit id="9d3a58afc4d0f71b9cc36db8de8b193e432fbef4" translate="yes" xml:space="preserve">
          <source>If you specify &lt;code&gt;--build-arg CONT_IMG_VER=&amp;lt;value&amp;gt;&lt;/code&gt; on the command line, in both cases, the specification on line 2 does not cause a cache miss; line 3 does cause a cache miss.&lt;code&gt;ARG CONT_IMG_VER&lt;/code&gt; causes the RUN line to be identified as the same as running &lt;code&gt;CONT_IMG_VER=&amp;lt;value&amp;gt;&lt;/code&gt; echo hello, so if the &lt;code&gt;&amp;lt;value&amp;gt;&lt;/code&gt; changes, we get a cache miss.</source>
          <target state="translated">如果在命令行上指定 &lt;code&gt;--build-arg CONT_IMG_VER=&amp;lt;value&amp;gt;&lt;/code&gt; ，则在两种情况下，第2行上的指定都不会导致高速缓存未命中；这两种情况都不会发生。第3行确实会导致缓存未命中。 &lt;code&gt;ARG CONT_IMG_VER&lt;/code&gt; 导致RUN行被标识为与运行 &lt;code&gt;CONT_IMG_VER=&amp;lt;value&amp;gt;&lt;/code&gt; 相同。echo hello，因此，如果 &lt;code&gt;&amp;lt;value&amp;gt;&lt;/code&gt; 发生更改，则会发生缓存未命中。</target>
        </trans-unit>
        <trans-unit id="887a493d0d4adc3a79b34b457f70f96427965e72" translate="yes" xml:space="preserve">
          <source>If you specify &lt;code&gt;image&lt;/code&gt; as well as &lt;code&gt;build&lt;/code&gt;, then Compose names the built image with the &lt;code&gt;webapp&lt;/code&gt; and optional &lt;code&gt;tag&lt;/code&gt; specified in &lt;code&gt;image&lt;/code&gt;:</source>
          <target state="translated">如果指定 &lt;code&gt;image&lt;/code&gt; ，以及 &lt;code&gt;build&lt;/code&gt; ，然后撰写地名用内置图像 &lt;code&gt;webapp&lt;/code&gt; 和可选 &lt;code&gt;tag&lt;/code&gt; 中指定 &lt;code&gt;image&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="341f514d36fea43ff37252e0fd12a051d52dcadb" translate="yes" xml:space="preserve">
          <source>If you specify a digest directly, that exact version of the image is always used when creating service tasks.</source>
          <target state="translated">如果您直接指定了一个摘要,那么在创建服务任务时将始终使用该图像的确切版本。</target>
        </trans-unit>
        <trans-unit id="3670337c1c9de65875fff0b01b7b13a573d236c8" translate="yes" xml:space="preserve">
          <source>If you specify a security group yourself using the &lt;code&gt;--amazonec2-security-group&lt;/code&gt; flag, the above ports are checked and opened and the security group is modified. If you want more ports to be opened such as application-specific ports, use the AWS console and modify the configuration manually.</source>
          <target state="translated">如果您自己使用 &lt;code&gt;--amazonec2-security-group&lt;/code&gt; 标志指定安全组，则会检查并打开上述端口，并修改安全组。如果您想打开更多端口（例如，特定于应用程序的端口），请使用AWS控制台并手动修改配置。</target>
        </trans-unit>
        <trans-unit id="5e45001f7a36598c1d53c1876f4f1b110474cb06" translate="yes" xml:space="preserve">
          <source>If you specify a tag, the manager (or the Docker client, if you use &lt;a href=&quot;#image_resolution_with_trust&quot;&gt;content trust&lt;/a&gt;) resolves that tag to a digest. When the request to create a container task is received on a worker node, the worker node only sees the digest, not the tag.</source>
          <target state="translated">如果指定标签，则管理器（或Docker客户端，如果使用&lt;a href=&quot;#image_resolution_with_trust&quot;&gt;content trust&lt;/a&gt;）将标签解析为摘要。当在工作节点上收到创建容器任务的请求时，工作节点仅看到摘要，而不看到标签。</target>
        </trans-unit>
        <trans-unit id="930b62bcf49a620028d7a59cbaf58ea4644319dc" translate="yes" xml:space="preserve">
          <source>If you specify a volume name already in use on the current driver, Docker assumes you want to re-use the existing volume and does not return an error.</source>
          <target state="translated">如果您指定了一个已经在当前驱动程序上使用的卷名,Docker会认为您想重新使用现有的卷,并且不会返回错误。</target>
        </trans-unit>
        <trans-unit id="edd4c4b0fee15867f7087395bf8551465100eb52" translate="yes" xml:space="preserve">
          <source>If you specify both the &lt;code&gt;--blkio-weight&lt;/code&gt; and &lt;code&gt;--blkio-weight-device&lt;/code&gt;, Docker uses the &lt;code&gt;--blkio-weight&lt;/code&gt; as the default weight and uses &lt;code&gt;--blkio-weight-device&lt;/code&gt; to override this default with a new value on a specific device. The following example uses a default weight of &lt;code&gt;300&lt;/code&gt; and overrides this default on &lt;code&gt;/dev/sda&lt;/code&gt; setting that weight to &lt;code&gt;200&lt;/code&gt;:</source>
          <target state="translated">如果您同时指定 &lt;code&gt;--blkio-weight&lt;/code&gt; 和 &lt;code&gt;--blkio-weight-device&lt;/code&gt; ，则Docker将使用 &lt;code&gt;--blkio-weight&lt;/code&gt; 作为默认权重，并使用 &lt;code&gt;--blkio-weight-device&lt;/code&gt; 覆盖此默认值，并使用特定设备。以下示例使用默认权重 &lt;code&gt;300&lt;/code&gt; ,并在 &lt;code&gt;/dev/sda&lt;/code&gt; 上将此默认权重设置为 &lt;code&gt;200&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="614a578114b6456d9f0a31d2f74942edf0974d59" translate="yes" xml:space="preserve">
          <source>If you specify multiple placement constraints, the service only deploys onto nodes where they are all met. The following example limits the service to run on all nodes where &lt;code&gt;region&lt;/code&gt; is set to &lt;code&gt;east&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt; is not set to &lt;code&gt;devel&lt;/code&gt;:</source>
          <target state="translated">如果您指定多个放置约束，则该服务仅部署到所有满足它们的节点上。以下示例将服务限制为在将 &lt;code&gt;region&lt;/code&gt; 设置为 &lt;code&gt;east&lt;/code&gt; 且 &lt;code&gt;type&lt;/code&gt; 未设置为 &lt;code&gt;devel&lt;/code&gt; 的所有节点上运行：</target>
        </trans-unit>
        <trans-unit id="5e051a2c523e346652be2d5b22f78a45fda86437" translate="yes" xml:space="preserve">
          <source>If you start a service configured with links, the &lt;code&gt;run&lt;/code&gt; command first checks to see if the linked service is running and starts the service if it is stopped. Once all the linked services are running, the &lt;code&gt;run&lt;/code&gt; executes the command you passed it. For example, you could run:</source>
          <target state="translated">如果启动配置了链接的服务，则 &lt;code&gt;run&lt;/code&gt; 命令首先检查链接的服务是否正在运行，如果停止，则启动该服务。所有链接的服务运行之后， &lt;code&gt;run&lt;/code&gt; 执行您传递的命令。例如，您可以运行：</target>
        </trans-unit>
        <trans-unit id="548ff65d7de1b9416c2fab31f2dbee3f95246fe4" translate="yes" xml:space="preserve">
          <source>If you started Compose with &lt;code&gt;docker-compose up -d&lt;/code&gt;, stop your services once you&amp;rsquo;ve finished with them:</source>
          <target state="translated">如果您使用 &lt;code&gt;docker-compose up -d&lt;/code&gt; 开始Compose，请在完成后停止服务：</target>
        </trans-unit>
        <trans-unit id="54aec9e0cdd1af1102ea068ee0d556ebc297c3b1" translate="yes" xml:space="preserve">
          <source>If you started a container &lt;em&gt;without&lt;/em&gt; kernel memory initialized:</source>
          <target state="translated">如果启动了&lt;em&gt;未&lt;/em&gt;初始化内核内存的容器：</target>
        </trans-unit>
        <trans-unit id="3a617207bbfb87e88a7e7dc4e126d89443b7f883" translate="yes" xml:space="preserve">
          <source>If you suspect a node has been compromised.</source>
          <target state="translated">如果您怀疑某个节点已被破坏。</target>
        </trans-unit>
        <trans-unit id="4747b67dbe25187ec1f8c0d6004f265b17d1c307" translate="yes" xml:space="preserve">
          <source>If you then run &lt;code&gt;docker stop test&lt;/code&gt;, the container will not exit cleanly - the &lt;code&gt;stop&lt;/code&gt; command will be forced to send a &lt;code&gt;SIGKILL&lt;/code&gt; after the timeout:</source>
          <target state="translated">如果随后运行 &lt;code&gt;docker stop test&lt;/code&gt; ，容器将无法干净退出- 超时后，将强制执行 &lt;code&gt;stop&lt;/code&gt; 命令发送 &lt;code&gt;SIGKILL&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="2be24690a58b8fe24bc3f68ad3567ddb397b5306" translate="yes" xml:space="preserve">
          <source>If you think of ways to make docker more secure, we welcome feature requests, pull requests, or comments on the Docker community forums.</source>
          <target state="translated">如果你想到了让docker更安全的方法,我们欢迎在Docker社区论坛上提出功能请求、拉取请求或评论。</target>
        </trans-unit>
        <trans-unit id="b7293b3c64e7be83a8f14e7372c74e792d623182" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;STDIN&lt;/code&gt; or specify a &lt;code&gt;URL&lt;/code&gt; pointing to a plain text file, the system places the contents into a file called &lt;code&gt;Dockerfile&lt;/code&gt;, and any &lt;code&gt;-f&lt;/code&gt;, &lt;code&gt;--file&lt;/code&gt; option is ignored. In this scenario, there is no context.</source>
          <target state="translated">如果使用 &lt;code&gt;STDIN&lt;/code&gt; 或指定指向纯文本文件的 &lt;code&gt;URL&lt;/code&gt; ，则系统会将内容放入名为 &lt;code&gt;Dockerfile&lt;/code&gt; 的文件中，并且 &lt;code&gt;-f&lt;/code&gt; 和 &lt;code&gt;--file&lt;/code&gt; 选项都将被忽略。在这种情况下，没有上下文。</target>
        </trans-unit>
        <trans-unit id="9eb7b35a504e0f0dd9a4abf4884c903eb6746ca7" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;docker-compose&lt;/code&gt; on a Windows machine, see &lt;a href=&quot;reference/envvars/index&quot;&gt;Environment variables&lt;/a&gt; and adjust the necessary environment variables for your specific needs.</source>
          <target state="translated">如果在Windows计算机上使用 &lt;code&gt;docker-compose&lt;/code&gt; ，请参阅&lt;a href=&quot;reference/envvars/index&quot;&gt;环境变量&lt;/a&gt;并根据您的特定需求调整必要的环境变量。</target>
        </trans-unit>
        <trans-unit id="75e617e850a3096c417d8e61aa4696d14a5295e5" translate="yes" xml:space="preserve">
          <source>If you use an earlier version and you want to achieve an even balance of load across workers and don&amp;rsquo;t mind disrupting running tasks, you can force your swarm to re-balance by temporarily scaling the service upward. Use &lt;code&gt;docker service inspect --pretty &amp;lt;servicename&amp;gt;&lt;/code&gt; to see the configured scale of a service. When you use &lt;code&gt;docker service scale&lt;/code&gt;, the nodes with the lowest number of tasks are targeted to receive the new workloads. There may be multiple under-loaded nodes in your swarm. You may need to scale the service up by modest increments a few times to achieve the balance you want across all the nodes.</source>
          <target state="translated">如果您使用的是较早版本，并且希望在各个工作人员之间实现平均负载平衡，并且不介意中断正在运行的任务，则可以通过临时向上扩展服务来强制群重新平衡。使用 &lt;code&gt;docker service inspect --pretty &amp;lt;servicename&amp;gt;&lt;/code&gt; 查看服务的已配置规模。使用 &lt;code&gt;docker service scale&lt;/code&gt; 时，任务数量最少的节点将用于接收新的工作负载。群中可能有多个负载不足的节点。您可能需要几次以适当的增量扩展服务，以在所有节点上实现所需的平衡。</target>
        </trans-unit>
        <trans-unit id="f6e56ea2ca6b9bf3849cbf0d1b9b8e9b44642aaf" translate="yes" xml:space="preserve">
          <source>If you use auto-lock, &lt;a href=&quot;../swarm_manager_locking/index#rotate-the-unlock-key&quot;&gt;rotate the unlock key&lt;/a&gt;.</source>
          <target state="translated">如果您使用自动锁定，请&lt;a href=&quot;../swarm_manager_locking/index#rotate-the-unlock-key&quot;&gt;旋转解锁键&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0264413744ae9e53ed10203da5499c89a9b6294c" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;--ipc=host&lt;/code&gt; option these sysctls will not be allowed.</source>
          <target state="translated">如果使用 &lt;code&gt;--ipc=host&lt;/code&gt; 选项，将不允许使用这些sysctls。</target>
        </trans-unit>
        <trans-unit id="997ccd099af214abbdd622b7c0f39a22547f246d" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;--network=host&lt;/code&gt; option using these sysctls will not be allowed.</source>
          <target state="translated">如果您使用 &lt;code&gt;--network=host&lt;/code&gt; 选项，则不允许使用这些sysctls。</target>
        </trans-unit>
        <trans-unit id="70622e333eb0d1040a0a670c89eb21690b028401" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;-f&lt;/code&gt; flag and specify the image&amp;rsquo;s short or long ID, then this command untags and removes all images that match the specified ID.</source>
          <target state="translated">如果使用 &lt;code&gt;-f&lt;/code&gt; 标志并指定图像的短ID或长ID，则此命令将取消标记并删除所有与指定ID匹配的图像。</target>
        </trans-unit>
        <trans-unit id="cd29cfd1504c5f60a8482a78dd665d9e2d2d9aef" translate="yes" xml:space="preserve">
          <source>If you use the &lt;em&gt;shell&lt;/em&gt; form of the &lt;code&gt;CMD&lt;/code&gt;, then the &lt;code&gt;&amp;lt;command&amp;gt;&lt;/code&gt; will execute in &lt;code&gt;/bin/sh -c&lt;/code&gt;:</source>
          <target state="translated">如果使用 &lt;code&gt;CMD&lt;/code&gt; 的&lt;em&gt;shell&lt;/em&gt;形式，则 &lt;code&gt;&amp;lt;command&amp;gt;&lt;/code&gt; 将在 &lt;code&gt;/bin/sh -c&lt;/code&gt; 中执行：</target>
        </trans-unit>
        <trans-unit id="777d76024619b3f7dd68426f5da7d500e35414fa" translate="yes" xml:space="preserve">
          <source>If you use the flag &lt;code&gt;--amazonec2-private-address-only&lt;/code&gt;, ensure that you can access the new instance from within the internal network of the VPC, such as a corporate VPN to the VPC, a VPN instance inside the VPC, or using &lt;code&gt;docker-machine&lt;/code&gt; from an instance within your VPC.</source>
          <target state="translated">如果使用标志 &lt;code&gt;--amazonec2-private-address-only&lt;/code&gt; ，请确保可以从VPC的内部网络（例如到VPC的公司VPN，VPC内的VPN实例）访问新实例，或者使用VPC中实例的 &lt;code&gt;docker-machine&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="013d73bf841a122d76ef95c3d526a1f09b09728b" translate="yes" xml:space="preserve">
          <source>If you used the Quickstart Terminal to launch your first machine and set your terminal environment to point to it, a default machine was automatically created. If so, you can still follow along with these steps, but create another machine and name it something other than &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="translated">如果您使用快速启动终端启动第一台计算机并设置终端环境指向它，则会自动创建一个默认计算机。如果是这样，您仍然可以按照以下步骤进行操作，但是要创建另一台计算机并将其命名为 &lt;code&gt;default&lt;/code&gt; 以外的名称。</target>
        </trans-unit>
        <trans-unit id="f9ebbfba82709e03e0f17a935545ed76e0bd05e6" translate="yes" xml:space="preserve">
          <source>If you want a subset of information formatted as JSON, you can use the &lt;code&gt;json&lt;/code&gt; function in the template.</source>
          <target state="translated">如果您希望将一部分信息格式化为JSON，则可以在模板中使用 &lt;code&gt;json&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="70ef8feb9b5d6ec959a2197807358b1514287cd4" translate="yes" xml:space="preserve">
          <source>If you want a tighter security policy on the processes within a container, you can specify an alternate type for the container. You could run a container that is only allowed to listen on Apache ports by executing the following command:</source>
          <target state="translated">如果你想对容器内的进程采取更严格的安全策略,你可以为容器指定一个备用类型。您可以通过执行以下命令来运行一个只允许监听Apache端口的容器。</target>
        </trans-unit>
        <trans-unit id="13b4928118fe5b9ef966a4cd387a9bc9d55dfc24" translate="yes" xml:space="preserve">
          <source>If you want more detailed information about a container&amp;rsquo;s resource usage, use the &lt;code&gt;/containers/(id)/stats&lt;/code&gt; API endpoint.</source>
          <target state="translated">如果需要有关容器资源使用情况的更多详细信息，请使用 &lt;code&gt;/containers/(id)/stats&lt;/code&gt; API端点。</target>
        </trans-unit>
        <trans-unit id="1275908d2bcf4a67b48de95532a331ea43b5de3c" translate="yes" xml:space="preserve">
          <source>If you want only Docker Machine, you can install the Machine binaries directly by following the instructions in the next section. You can find the latest versions of the binaries on the &lt;a href=&quot;https://github.com/docker/machine/releases/&quot;&gt;docker/machine release page&lt;/a&gt; on GitHub.</source>
          <target state="translated">如果只需要Docker Machine，则可以按照下一部分中的说明直接安装Machine二进制文件。您可以在GitHub 的&lt;a href=&quot;https://github.com/docker/machine/releases/&quot;&gt;docker / machine release页面&lt;/a&gt;上找到最新版本的二进制文件。</target>
        </trans-unit>
        <trans-unit id="e40792fd5ab1489918de4d5d202a0a7b0470269e" translate="yes" xml:space="preserve">
          <source>If you want to &lt;strong&gt;run your&lt;/strong&gt;&lt;code&gt;&amp;lt;command&amp;gt;&lt;/code&gt;&lt;strong&gt;without a shell&lt;/strong&gt; then you must express the command as a JSON array and give the full path to the executable. &lt;strong&gt;This array form is the preferred format of &lt;code&gt;CMD&lt;/code&gt;.&lt;/strong&gt; Any additional parameters must be individually expressed as strings in the array:</source>
          <target state="translated">如果要在&lt;strong&gt;没有外壳的情况下&lt;/strong&gt;&lt;strong&gt;运行&lt;/strong&gt; &lt;code&gt;&amp;lt;command&amp;gt;&lt;/code&gt; &lt;strong&gt;，&lt;/strong&gt;则必须将命令表示为JSON数组，并提供可执行文件的完整路径。&lt;strong&gt;此数组形式是 &lt;code&gt;CMD&lt;/code&gt; 的首选格式。&lt;/strong&gt;任何其他参数必须在数组中分别表示为字符串：</target>
        </trans-unit>
        <trans-unit id="0fb90e9cb29a23cc953dc488821a5bdbad00a6aa" translate="yes" xml:space="preserve">
          <source>If you want to add a container to a network after the container is already running, use the &lt;code&gt;docker network connect&lt;/code&gt; subcommand.</source>
          <target state="translated">如果要在容器已运行后将其添加到网络，请使用 &lt;code&gt;docker network connect&lt;/code&gt; 子命令。</target>
        </trans-unit>
        <trans-unit id="3331f3c98821ffa4887a7f53d6dc95bc2286283a" translate="yes" xml:space="preserve">
          <source>If you want to add a running container to a network use the &lt;code&gt;docker network connect&lt;/code&gt; subcommand.</source>
          <target state="translated">如果要将运行中的容器添加到网络，请使用 &lt;code&gt;docker network connect&lt;/code&gt; 子命令。</target>
        </trans-unit>
        <trans-unit id="c566b0f2732a4d6b4d596fa74fb317a05efaa1f7" translate="yes" xml:space="preserve">
          <source>If you want to force Compose to stop and recreate all containers, use the &lt;code&gt;--force-recreate&lt;/code&gt; flag.</source>
          <target state="translated">如果要强制Compose停止并重新创建所有容器，请使用 &lt;code&gt;--force-recreate&lt;/code&gt; 标志。</target>
        </trans-unit>
        <trans-unit id="2ac9a1ff015b17bde34c342af0fdee4edd4f9254" translate="yes" xml:space="preserve">
          <source>If you want to limit access to a specific device or devices you can use the &lt;code&gt;--device&lt;/code&gt; flag. It allows you to specify one or more devices that will be accessible within the container.</source>
          <target state="translated">如果要限制对特定设备的访问，可以使用 &lt;code&gt;--device&lt;/code&gt; 标志。它允许您指定一个或多个在容器内可访问的设备。</target>
        </trans-unit>
        <trans-unit id="dc3d3fdf24df6634b0cf82de870cb32fc4946531" translate="yes" xml:space="preserve">
          <source>If you want to login to a self-hosted registry you can specify this by adding the server name.</source>
          <target state="translated">如果你想登录到一个自我托管的注册表,你可以通过添加服务器名称来指定。</target>
        </trans-unit>
        <trans-unit id="8e7cd13feebe3d871e5a68aedb6b04e20260dd8b" translate="yes" xml:space="preserve">
          <source>If you want to prevent your container processes from gaining additional privileges, you can execute the following command:</source>
          <target state="translated">如果你想防止你的容器进程获得额外的权限,你可以执行以下命令。</target>
        </trans-unit>
        <trans-unit id="91f7098f0b180451930bcd4f5883fc9b6433f05e" translate="yes" xml:space="preserve">
          <source>If you want to remove the container after running while overriding the container&amp;rsquo;s restart policy, use the &lt;code&gt;--rm&lt;/code&gt; flag:</source>
          <target state="translated">如果要在覆盖容器的重新启动策略的同时运行后删除该容器，请使用 &lt;code&gt;--rm&lt;/code&gt; 标志：</target>
        </trans-unit>
        <trans-unit id="e4f2d3f2b064e6d64494989c37653ef8f8e6ea1d" translate="yes" xml:space="preserve">
          <source>If you want to run your services in the background, you can pass the &lt;code&gt;-d&lt;/code&gt; flag (for &amp;ldquo;detached&amp;rdquo; mode) to &lt;code&gt;docker-compose up&lt;/code&gt; and use &lt;code&gt;docker-compose ps&lt;/code&gt; to see what is currently running:</source>
          <target state="translated">如果要在后台运行服务，则可以将 &lt;code&gt;-d&lt;/code&gt; 标志（用于&amp;ldquo;分离&amp;rdquo;模式）传递给 &lt;code&gt;docker-compose up&lt;/code&gt; 并使用 &lt;code&gt;docker-compose ps&lt;/code&gt; 来查看当前正在运行的内容：</target>
        </trans-unit>
        <trans-unit id="0686c0bfe4c28fe49ac3e946e0f175adf773873d" translate="yes" xml:space="preserve">
          <source>If you want to secure your Docker client connections by default, you can move the files to the &lt;code&gt;.docker&lt;/code&gt; directory in your home directory --- and set the &lt;code&gt;DOCKER_HOST&lt;/code&gt; and &lt;code&gt;DOCKER_TLS_VERIFY&lt;/code&gt; variables as well (instead of passing &lt;code&gt;-H=tcp://$HOST:2376&lt;/code&gt; and &lt;code&gt;--tlsverify&lt;/code&gt; on every call).</source>
          <target state="translated">如果要默认保护Docker客户端连接的安全性，则可以将文件移动到主目录-。目录中的 &lt;code&gt;.docker&lt;/code&gt; 目录中，并设置 &lt;code&gt;DOCKER_HOST&lt;/code&gt; 和 &lt;code&gt;DOCKER_TLS_VERIFY&lt;/code&gt; 变量（而不是传递 &lt;code&gt;-H=tcp://$HOST:2376&lt;/code&gt; 和 &lt;code&gt;--tlsverify&lt;/code&gt; 每次调用）。</target>
        </trans-unit>
        <trans-unit id="99795c4741a4661849c9d9f7fb1d8920ca13c9f8" translate="yes" xml:space="preserve">
          <source>If you want to see the containers running on other nodes, ssh into those nodes and run the &lt;code&gt;docker ps&lt;/code&gt; command.</source>
          <target state="translated">如果要查看在其他节点上运行的容器，请使用ssh进入这些节点并运行 &lt;code&gt;docker ps&lt;/code&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="12c4b708603275450b96c270f02bb26e17619c5a" translate="yes" xml:space="preserve">
          <source>If you want to start over, you can run &lt;code&gt;docker swarm leave&lt;/code&gt; from each node.</source>
          <target state="translated">如果要重新开始，则可以从每个节点运行 &lt;code&gt;docker swarm leave&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e5deade7031a312eca3e9e800aeae9a04688963a" translate="yes" xml:space="preserve">
          <source>If you want to try the running all of these examples again or just want to clean up after running through them, use these commands to remove the WordPress service, the MySQL container, the &lt;code&gt;mydata&lt;/code&gt; and &lt;code&gt;wpdata&lt;/code&gt; volumes, and the Docker secrets.</source>
          <target state="translated">如果要尝试再次运行所有这些示例，或者只是想在运行它们之后进行清理，请使用以下命令删除WordPress服务，MySQL容器， &lt;code&gt;mydata&lt;/code&gt; 和 &lt;code&gt;wpdata&lt;/code&gt; 卷以及Docker机密。</target>
        </trans-unit>
        <trans-unit id="9e6549a64f297be7133c3e8c6911217713e4fe78" translate="yes" xml:space="preserve">
          <source>If you want to use Compose to scale the service in question to multiple nodes, build the image, push it to a registry such as Docker Hub, and reference it from &lt;code&gt;docker-compose.yml&lt;/code&gt;:</source>
          <target state="translated">如果要使用Compose将相关服务扩展到多个节点，请构建映像，将其推送至Docker Hub等注册表，然后从 &lt;code&gt;docker-compose.yml&lt;/code&gt; 中引用它：</target>
        </trans-unit>
        <trans-unit id="f0dbc37ce1e54d924397277626efa3a3e1ee8ce5" translate="yes" xml:space="preserve">
          <source>If you want to use Notary in production</source>
          <target state="translated">如果你想在生产中使用公证</target>
        </trans-unit>
        <trans-unit id="b6c743b521003fe6450220c17814e043461401ca" translate="yes" xml:space="preserve">
          <source>If you want to use a particular network on a common build, use [network] as mentioned in the second yaml file example.</source>
          <target state="translated">如果你想在一个普通的构建中使用一个特定的网络,请使用第二个yaml文件例子中提到的[网络]。</target>
        </trans-unit>
        <trans-unit id="18b0d4859119a15b2634e361b32880b6fe4b5774" translate="yes" xml:space="preserve">
          <source>If you want to use the &lt;code&gt;dockremap&lt;/code&gt; user automatically created by Docker, check for the &lt;code&gt;dockremap&lt;/code&gt; entry in these files &lt;strong&gt;after&lt;/strong&gt; configuring and restarting Docker.</source>
          <target state="translated">如果要使用Docker自动创建的 &lt;code&gt;dockremap&lt;/code&gt; 用户，请&lt;strong&gt;在&lt;/strong&gt;配置和重新启动Docker &lt;strong&gt;之后&lt;/strong&gt;检查这些文件中的 &lt;code&gt;dockremap&lt;/code&gt; 条目。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="851692af5ab779dce736b1e35716b7b87c43cd77" translate="yes" xml:space="preserve">
          <source>If you want your containers to join a pre-existing network, use the &lt;a href=&quot;../compose-file/compose-file-v2/index#network-configuration-reference&quot;&gt;&lt;code&gt;external&lt;/code&gt; option&lt;/a&gt;:</source>
          <target state="translated">如果您希望容器加入预先存在的网络，请使用&lt;a href=&quot;../compose-file/compose-file-v2/index#network-configuration-reference&quot;&gt; &lt;code&gt;external&lt;/code&gt; 选项&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="eab86fabcc4fef062db463f637d704d679fe3936" translate="yes" xml:space="preserve">
          <source>If you want your data to persist, use a named volume and a volume driver that is multi-host aware, so that the data is accessible from any node. Or, set constraints on the service so that its tasks are deployed on a node that has the volume present.</source>
          <target state="translated">如果你想让你的数据持久化,请使用一个命名的卷和一个能识别多主机的卷驱动,这样就能从任何节点访问数据。或者,在服务上设置约束,使其任务部署在有卷存在的节点上。</target>
        </trans-unit>
        <trans-unit id="7fa55b3aa9ac2103a3831eae6e8432beb1b778c4" translate="yes" xml:space="preserve">
          <source>If you want, you can configure an override the Docker key sequence for detach. This is useful if the Docker default sequence conflicts with key sequence you use for other applications. There are two ways to define your own detach key sequence, as a per-container override or as a configuration property on your entire configuration.</source>
          <target state="translated">如果你愿意,你可以为detach配置一个覆盖Docker密钥序列。如果Docker默认序列与您在其他应用中使用的密钥序列冲突,这很有用。有两种方法可以定义你自己的detach密钥序列,作为每个容器的覆盖或作为整个配置的配置属性。</target>
        </trans-unit>
        <trans-unit id="bcc920d2c2a3e4bebc47347df902beccde2a488b" translate="yes" xml:space="preserve">
          <source>If you were using Boot2Docker previously, you have a pre-existing Docker &lt;code&gt;boot2docker-vm&lt;/code&gt; VM on your local system. To allow Docker Machine to manage this older VM, you must migrate it.</source>
          <target state="translated">如果以前使用的是Boot2Docker，则本地系统上已有一个Docker &lt;code&gt;boot2docker-vm&lt;/code&gt; 虚拟机。要允许Docker Machine管理该较旧的VM，必须对其进行迁移。</target>
        </trans-unit>
        <trans-unit id="f3dfd411d61369127faae4769ebf726d5f0ceca7" translate="yes" xml:space="preserve">
          <source>If you wish to guarantee that no new nodes can join the swarm.</source>
          <target state="translated">如果你想保证没有新的节点可以加入蜂群。</target>
        </trans-unit>
        <trans-unit id="c3a1e979301a98137ace82569a8c1995b08bc57b" translate="yes" xml:space="preserve">
          <source>If you wish to keep the intermediate containers after the build is complete, you must use &lt;code&gt;--rm=false&lt;/code&gt;. This does not affect the build cache.</source>
          <target state="translated">如果希望在构建完成后保留中间容器，则必须使用 &lt;code&gt;--rm=false&lt;/code&gt; 。这不会影响生成缓存。</target>
        </trans-unit>
        <trans-unit id="2c8e6d2e43d4ec934e9a71f8979894e15d9e31b3" translate="yes" xml:space="preserve">
          <source>If you work primarily on an older Mac or Windows laptop or desktop that doesn&amp;rsquo;t meet the requirements for the new &lt;a href=&quot;https://docs.docker.com/docker-for-mac/&quot;&gt;Docker Desktop for Mac&lt;/a&gt; and &lt;a href=&quot;https://docs.docker.com/docker-for-windows/&quot;&gt;Docker Desktop for Windows&lt;/a&gt; apps, then you need Docker Machine to run Docker Engine locally. Installing Docker Machine on a Mac or Windows box with the &lt;a href=&quot;https://docs.docker.com/toolbox/overview/&quot;&gt;Docker Toolbox&lt;/a&gt; installer provisions a local virtual machine with Docker Engine, gives you the ability to connect it, and run &lt;code&gt;docker&lt;/code&gt; commands.</source>
          <target state="translated">如果您使用的是旧的Mac或Windows笔记本电脑或台式机不符合新的要求，主要工作&lt;a href=&quot;https://docs.docker.com/docker-for-mac/&quot;&gt;泊坞Mac版桌面&lt;/a&gt;和&lt;a href=&quot;https://docs.docker.com/docker-for-windows/&quot;&gt;码头工人Windows版桌面&lt;/a&gt;应用程序，那么你需要泊坞窗机在本地运行泊坞引擎。使用&lt;a href=&quot;https://docs.docker.com/toolbox/overview/&quot;&gt;Docker Toolbox&lt;/a&gt;安装程序在Mac或Windows盒子上安装Docker Machine，可使用Docker Engine设置本地虚拟机，使您能够连接它并运行 &lt;code&gt;docker&lt;/code&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="38d61d3c4fa6722d423ec51c89dd750d869f3766" translate="yes" xml:space="preserve">
          <source>If you would like your container to run the same executable every time, then you should consider using &lt;code&gt;ENTRYPOINT&lt;/code&gt; in combination with &lt;code&gt;CMD&lt;/code&gt;. See &lt;a href=&quot;#entrypoint&quot;&gt;&lt;em&gt;ENTRYPOINT&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">如果希望容器每次都运行相同的可执行文件，则应考虑将 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 与 &lt;code&gt;CMD&lt;/code&gt; 结合使用。请参阅&lt;a href=&quot;#entrypoint&quot;&gt;&lt;em&gt;ENTRYPOINT&lt;/em&gt;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="919a1468547e5d70eacc73229fb5d38975122b53" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re interested in trying out a pre-release build, you can download release candidates from the &lt;a href=&quot;https://github.com/docker/compose/releases&quot;&gt;Compose repository release page on GitHub&lt;/a&gt;. Follow the instructions from the link, which involves running the &lt;code&gt;curl&lt;/code&gt; command in your terminal to download the binaries.</source>
          <target state="translated">如果您想试用预发布版本，可以从&lt;a href=&quot;https://github.com/docker/compose/releases&quot;&gt;GitHub上&lt;/a&gt;的Compose存储库发布页面下载候选发布。按照链接中的说明进行操作，其中包括在终端中运行 &lt;code&gt;curl&lt;/code&gt; 命令以下载二进制文件。</target>
        </trans-unit>
        <trans-unit id="1de9f71035aa6b3a6d873d465e98b447596b90d1" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re not sure how to configure these options, it is best to not specify configuration at all. Docker Machine chooses sensible defaults for you and you don&amp;rsquo;t need to worry about it.</source>
          <target state="translated">如果不确定如何配置这些选项，则最好完全不指定配置。Docker Machine为您选择合理的默认值，您无需担心。</target>
        </trans-unit>
        <trans-unit id="ba85e897e59a86ff010c2d5eee9824d8a85c2fdf" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re on Mac or Windows, download the &amp;ldquo;Beta channel&amp;rdquo; version of &lt;a href=&quot;https://docs.docker.com/docker-for-mac/&quot;&gt;Docker Desktop for Mac&lt;/a&gt; or &lt;a href=&quot;https://docs.docker.com/docker-for-windows/&quot;&gt;Docker Desktop for Windows&lt;/a&gt; to install it. If you&amp;rsquo;re on Linux, follow the instructions in the &lt;a href=&quot;https://github.com/docker/cli/blob/master/experimental/README/&quot;&gt;experimental build README&lt;/a&gt;.</source>
          <target state="translated">如果您使用的是Mac或Windows，请下载&lt;a href=&quot;https://docs.docker.com/docker-for-mac/&quot;&gt;适用于Mac的&lt;/a&gt;&lt;a href=&quot;https://docs.docker.com/docker-for-windows/&quot;&gt;Docker桌面&lt;/a&gt;或适用于Windows的Docker桌面的&amp;ldquo;测试版&amp;rdquo;版本。如果您使用的是Linux，请按照&lt;a href=&quot;https://github.com/docker/cli/blob/master/experimental/README/&quot;&gt;实验性版本README中&lt;/a&gt;的说明进行操作。</target>
        </trans-unit>
        <trans-unit id="af3af77f760852207a6a858ff4f4128dcf670f5a" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re upgrading from Compose 1.2 or earlier, remove or migrate your existing containers after upgrading Compose. This is because, as of version 1.3, Compose uses Docker labels to keep track of containers, and your containers need to be recreated to add the labels.</source>
          <target state="translated">如果要从Compose 1.2或更早版本进行升级，请在升级Compose之后删除或迁移现有容器。这是因为从1.3版开始，Compose使用Docker标签来跟踪容器，并且需要重新创建容器以添加标签。</target>
        </trans-unit>
        <trans-unit id="dbce20f8109461e5d572204e84cc2b1ba6e268d6" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using &lt;code&gt;net: &quot;container:[container name/id]&quot;&lt;/code&gt;, the value does not need to change.</source>
          <target state="translated">如果您使用的是 &lt;code&gt;net: &quot;container:[container name/id]&quot;&lt;/code&gt; ，则无需更改该值。</target>
        </trans-unit>
        <trans-unit id="3c4daaf98bd39ce011096ded8af74fa7bc193821" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using &lt;code&gt;net: &quot;container:[service name]&quot;&lt;/code&gt;, you must now use &lt;code&gt;network_mode: &quot;service:[service name]&quot;&lt;/code&gt; instead.</source>
          <target state="translated">如果您使用的是 &lt;code&gt;net: &quot;container:[service name]&quot;&lt;/code&gt; ，则现在必须使用 &lt;code&gt;network_mode: &quot;service:[service name]&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="43285ecd2a59b909da1eba3a10034e2fbcce52a8" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using Docker Machine on a Mac or Windows, use &lt;code&gt;docker-machine ip MACHINE_VM&lt;/code&gt; to get the IP address of your Docker host. Then, open &lt;code&gt;http://MACHINE_VM_IP:5000&lt;/code&gt; in a browser.</source>
          <target state="translated">如果您在Mac或Windows上使用Docker Machine，请使用 &lt;code&gt;docker-machine ip MACHINE_VM&lt;/code&gt; 获取Docker主机的IP地址。然后，在浏览器中打开 &lt;code&gt;http://MACHINE_VM_IP:5000&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5f8ee6625cf8ed3846405d3a5331b054555b441c" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using Docker natively on Linux, Docker Desktop for Mac, or Docker Desktop for Windows, then the web app should now be listening on port 5000 on your Docker daemon host. Point your web browser to http://localhost:5000 to find the &lt;code&gt;Hello World&lt;/code&gt; message. If this doesn&amp;rsquo;t resolve, you can also try http://127.0.0.1:5000.</source>
          <target state="translated">如果您在Linux，Mac上的Docker Desktop或Windows上的Docker Desktop上本地使用Docker，则Web应用程序现在应该在Docker守护程序主机上的端口5000上进行侦听。将您的Web浏览器指向http：// localhost：5000以查找 &lt;code&gt;Hello World&lt;/code&gt; 消息。如果仍然无法解决，您也可以尝试http://127.0.0.1:5000。</target>
        </trans-unit>
        <trans-unit id="0ede5175ab39a5c7ce4a42b5d15e2d9359188a81" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using the &lt;a href=&quot;compose-versioning/index#version-2&quot;&gt;version 2 or above file format&lt;/a&gt;, the externally-created containers must be connected to at least one of the same networks as the service that is linking to them. &lt;a href=&quot;compose-file-v2/index#links&quot;&gt;Links&lt;/a&gt; are a legacy option. We recommend using &lt;a href=&quot;#networks&quot;&gt;networks&lt;/a&gt; instead.</source>
          <target state="translated">如果您使用的是&lt;a href=&quot;compose-versioning/index#version-2&quot;&gt;版本2或更高版本的文件格式&lt;/a&gt;，则外部创建的容器必须至少连接到与链接到它们的服务相同的网络之一。&lt;a href=&quot;compose-file-v2/index#links&quot;&gt;链接&lt;/a&gt;是旧选项。我们建议改为使用&lt;a href=&quot;#networks&quot;&gt;网络&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="80d5a17957dd9f04233a5c250192b2fd1ba876f1" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using version 1 along with &lt;code&gt;links&lt;/code&gt;, your app works, but Swarm schedules all containers on one host, because links between containers do not work across hosts with the old networking system.</source>
          <target state="translated">如果您同时使用版本1和 &lt;code&gt;links&lt;/code&gt; ，则您的应用程序可以运行，但是Swarm将所有容器计划在一个主机上，因为在旧网络系统中，容器之间的链接无法跨主机运行。</target>
        </trans-unit>
        <trans-unit id="c031e9ba1e317901c6af28db65fb30143ae99b9a" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using version 2, your app should work with no changes:</source>
          <target state="translated">如果您使用的是版本2，则您的应用应该可以正常使用：</target>
        </trans-unit>
        <trans-unit id="accee6497f208c5dc8cc9601dfbf48fe08a59bef" translate="yes" xml:space="preserve">
          <source>If your certificates have expired, you&amp;rsquo;ll need to regenerate the client certs as well using the &lt;code&gt;--client-certs&lt;/code&gt; option:</source>
          <target state="translated">如果您的证书已过期，则还需要使用 &lt;code&gt;--client-certs&lt;/code&gt; 选项重新生成客户端证书：</target>
        </trans-unit>
        <trans-unit id="115365c9fe93dca9d6875524fe9a71b13dffeef5" translate="yes" xml:space="preserve">
          <source>If your configuration is split between multiple Compose files, e.g. a base configuration and environment-specific overrides, you can provide multiple &lt;code&gt;--compose-file&lt;/code&gt; flags.</source>
          <target state="translated">如果将配置分为多个Compose文件，例如基本配置和特定于环境的替代，则可以提供多个 &lt;code&gt;--compose-file&lt;/code&gt; 标志。</target>
        </trans-unit>
        <trans-unit id="96ec1ed8dcbcadaa8e8703d203d779700bff0e02" translate="yes" xml:space="preserve">
          <source>If your distribution comes with security model templates for Docker containers, you can use them out of the box. For instance, we ship a template that works with AppArmor and Red Hat comes with SELinux policies for Docker. These templates provide an extra safety net (even though it overlaps greatly with capabilities).</source>
          <target state="translated">如果你的发行版自带Docker容器的安全模型模板,你可以开箱即用。例如,我们发布了一个与AppArmor配合的模板,Red Hat为Docker附带了SELinux策略。这些模板提供了一个额外的安全网(尽管它与能力有很大的重叠)。</target>
        </trans-unit>
        <trans-unit id="aa822e7d5535d48d2169291150c8f0e3165fd360" translate="yes" xml:space="preserve">
          <source>If your engine is unable to communicate to the registry, we can enable DCT to trust cached signature data. This is done through the &lt;code&gt;allow-expired-cached-trust-data&lt;/code&gt; variable.</source>
          <target state="translated">如果您的引擎无法与注册表通信，我们可以启用DCT信任缓存的签名数据。这是通过 &lt;code&gt;allow-expired-cached-trust-data&lt;/code&gt; 变量完成的。</target>
        </trans-unit>
        <trans-unit id="7c78340b12209a3bf2e4298771efc2a4a59f1096" translate="yes" xml:space="preserve">
          <source>If your image is available on a private registry which requires login, use the &lt;code&gt;--with-registry-auth&lt;/code&gt; flag with &lt;code&gt;docker service create&lt;/code&gt;, after logging in. If your image is stored on &lt;code&gt;registry.example.com&lt;/code&gt;, which is a private registry, use a command like the following:</source>
          <target state="translated">如果你的图像提供了有关哪些需要登录的私人注册表，使用 &lt;code&gt;--with-registry-auth&lt;/code&gt; 与标志 &lt;code&gt;docker service create&lt;/code&gt; ，在登录后，如果您的图像存储在 &lt;code&gt;registry.example.com&lt;/code&gt; ，这是一个私人的注册表，使用如下命令：</target>
        </trans-unit>
        <trans-unit id="9d281bdfd7e129dcc755be1f72a3743ece6a5415" translate="yes" xml:space="preserve">
          <source>If your operating system does not enable certain capabilities, you may see warnings such as one of the following, when you run &lt;code&gt;docker info&lt;/code&gt;:</source>
          <target state="translated">如果您的操作系统未启用某些功能，则在运行 &lt;code&gt;docker info&lt;/code&gt; 时可能会看到诸如以下之一的警告：</target>
        </trans-unit>
        <trans-unit id="caee0b8b9ff6969622d524645376851d425c1409" translate="yes" xml:space="preserve">
          <source>If your project is outside of the &lt;code&gt;Users&lt;/code&gt; directory (&lt;code&gt;cd ~&lt;/code&gt;), then you need to share the drive or location of the Dockerfile and volume you are using. If you get runtime errors indicating an application file is not found, a volume mount is denied, or a service cannot start, try enabling file or drive sharing. Volume mounting requires shared drives for projects that live outside of &lt;code&gt;C:\Users&lt;/code&gt; (Windows) or &lt;code&gt;/Users&lt;/code&gt; (Mac), and is required for &lt;em&gt;any&lt;/em&gt; project on Docker Desktop for Windows that uses &lt;a href=&quot;https://docs.docker.com/docker-for-windows/#switch-between-windows-and-linux-containers-beta-feature&quot;&gt;Linux containers&lt;/a&gt;. For more information, see &lt;a href=&quot;https://docs.docker.com/docker-for-windows/#shared-drives&quot;&gt;Shared Drives&lt;/a&gt; on Docker Desktop for Windows, &lt;a href=&quot;https://docs.docker.com/docker-for-mac/#file-sharing&quot;&gt;File sharing&lt;/a&gt; on Docker for Mac, and the general examples on how to &lt;a href=&quot;https://docs.docker.com/storage&quot;&gt;Manage data in containers&lt;/a&gt;.</source>
          <target state="translated">如果你的项目是外部 &lt;code&gt;Users&lt;/code&gt; 目录（ &lt;code&gt;cd ~&lt;/code&gt; ），那么你需要分享你正在使用的Dockerfile的驱动器或位置和数量。如果您收到运行时错误指示未找到应用程序文件，拒绝卷安装或服务无法启动，请尝试启用文件或驱动器共享。卷挂载需要位于 &lt;code&gt;C:\Users&lt;/code&gt; （Windows）或 &lt;code&gt;/Users&lt;/code&gt; （Mac）之外的项目的共享驱动器，并且对于使用&lt;a href=&quot;https://docs.docker.com/docker-for-windows/#switch-between-windows-and-linux-containers-beta-feature&quot;&gt;Linux容器的&lt;/a&gt; Windows Docker Desktop上的&lt;em&gt;任何&lt;/em&gt;项目都是必需的。有关更多信息，请参阅用于Windows的Docker桌面上的&lt;a href=&quot;https://docs.docker.com/docker-for-windows/#shared-drives&quot;&gt;共享驱动器&lt;/a&gt;，&lt;a href=&quot;https://docs.docker.com/docker-for-mac/#file-sharing&quot;&gt;文件共享。&lt;/a&gt;适用于Mac的Docker，以及有关如何&lt;a href=&quot;https://docs.docker.com/storage&quot;&gt;管理容器中数据&lt;/a&gt;的一般示例。</target>
        </trans-unit>
        <trans-unit id="826899ca2686e2a0798d17f8e23a5a226f714554" translate="yes" xml:space="preserve">
          <source>If your service attempts to use more memory than the swarm node has available, you may experience an Out Of Memory Exception (OOME) and a container, or the Docker daemon, might be killed by the kernel OOM killer. To prevent this from happening, ensure that your application runs on hosts with adequate memory and see &lt;a href=&quot;https://docs.docker.com/config/containers#understand-the-risks-of-running-out-of-memory&quot;&gt;Understand the risks of running out of memory&lt;/a&gt;.</source>
          <target state="translated">如果您的服务尝试使用的内存超过了swarm节点可用的内存，那么您可能会遇到内存不足异常（OOME），并且内核OOM杀手可能会杀死容器或Docker守护程序。为防止这种情况的发生，请确保您的应用程序在具有足够内存的主机上运行，​​请参阅&lt;a href=&quot;https://docs.docker.com/config/containers#understand-the-risks-of-running-out-of-memory&quot;&gt;了解&lt;/a&gt;内存不足的风险。</target>
        </trans-unit>
        <trans-unit id="4772e0d7e0ed2d3fe6baf4dd95ed90fccd20b8da" translate="yes" xml:space="preserve">
          <source>If your services or containers attempt to use more memory than the system has available, you may experience an Out Of Memory Exception (OOME) and a container, or the Docker daemon, might be killed by the kernel OOM killer. To prevent this from happening, ensure that your application runs on hosts with adequate memory and see &lt;a href=&quot;https://docs.docker.com/config/containers#understand-the-risks-of-running-out-of-memory&quot;&gt;Understand the risks of running out of memory&lt;/a&gt;.</source>
          <target state="translated">如果您的服务或容器尝试使用的内存超过系统可用的内存，则可能会遇到内存不足异常（OOME），并且容器或Docker守护程序可能会被内核OOM杀手杀死。为防止这种情况的发生，请确保您的应用程序在具有足够内存的主机上运行，​​请参阅&lt;a href=&quot;https://docs.docker.com/config/containers#understand-the-risks-of-running-out-of-memory&quot;&gt;了解&lt;/a&gt;内存不足的风险。</target>
        </trans-unit>
        <trans-unit id="402a915739c0383de60afadf15db2a2629ff47d7" translate="yes" xml:space="preserve">
          <source>If your swarm service relies on one or more &lt;a href=&quot;../../extend/plugin_api/index&quot;&gt;plugins&lt;/a&gt;, these plugins need to be available on every node where the service could potentially be deployed. You can manually install the plugin on each node or script the installation. In Docker 17.07 and higher, you can also deploy the plugin in a similar way as a global service using the Docker API, by specifying a &lt;code&gt;PluginSpec&lt;/code&gt; instead of a &lt;code&gt;ContainerSpec&lt;/code&gt;.</source>
          <target state="translated">如果您的swarm服务依赖一个或多个&lt;a href=&quot;../../extend/plugin_api/index&quot;&gt;插件&lt;/a&gt;，则这些插件需要在可能部署该服务的每个节点上都可用。您可以在每个节点上手动安装插件，也可以脚本化安装。在Docker 17.07及更高版本中，您还可以通过指定 &lt;code&gt;PluginSpec&lt;/code&gt; 而不是 &lt;code&gt;ContainerSpec&lt;/code&gt; ，以与使用Docker API的全局服务相似的方式部署插件。</target>
        </trans-unit>
        <trans-unit id="90f1811c30ff4805d621b4791c8107d9e5e7f201" translate="yes" xml:space="preserve">
          <source>If your system doesn&amp;rsquo;t have support for &lt;code&gt;dirperm1&lt;/code&gt;, the issue describes a workaround.</source>
          <target state="translated">如果您的系统不支持 &lt;code&gt;dirperm1&lt;/code&gt; ，则此问题描述了一种解决方法。</target>
        </trans-unit>
        <trans-unit id="239760bef63476e8180ba21228a84305307aaeb5" translate="yes" xml:space="preserve">
          <source>If, at any time during the update, a task returns &lt;code&gt;FAILED&lt;/code&gt;, pause the update.</source>
          <target state="translated">如果在更新期间的任何时间任务返回 &lt;code&gt;FAILED&lt;/code&gt; ，请暂停更新。</target>
        </trans-unit>
        <trans-unit id="1e65bb4eca2d3c71529c96890a4b735eb7dafeac" translate="yes" xml:space="preserve">
          <source>Ignored.</source>
          <target state="translated">Ignored.</target>
        </trans-unit>
        <trans-unit id="331f1d7091668de6721fd50ce74e69d189f066e0" translate="yes" xml:space="preserve">
          <source>Image (required) &lt;code&gt;string&lt;/code&gt;</source>
          <target state="translated">图片（必填） &lt;code&gt;string&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c93001a35ed219979d993baeb27888011162e925" translate="yes" xml:space="preserve">
          <source>Image ID</source>
          <target state="translated">图片ID</target>
        </trans-unit>
        <trans-unit id="0fd3d8c671f22aaf256379f3be9a7b0ccf6b2e91" translate="yes" xml:space="preserve">
          <source>Image Name</source>
          <target state="translated">图片名称</target>
        </trans-unit>
        <trans-unit id="a022baad71e528f98ec2d3ffbf64a4c9176358e7" translate="yes" xml:space="preserve">
          <source>Image consumers can enable DCT to ensure that images they use were signed. If a consumer enables DCT, they can only pull, run, or build with trusted images. Enabling DCT is a bit like applying a &amp;ldquo;filter&amp;rdquo; to your registry. Consumers &amp;ldquo;see&amp;rdquo; only signed image tags and the less desirable, unsigned image tags are &amp;ldquo;invisible&amp;rdquo; to them.</source>
          <target state="translated">图像使用者可以启用DCT以确保他们使用的图像已签名。如果使用者启用DCT，则他们只能使用受信任的映像进行拉取，运行或构建。启用DCT有点像对注册表应用&amp;ldquo;过滤器&amp;rdquo;。消费者仅&amp;ldquo;看到&amp;rdquo;签名的图像标签，而对他们而言，&amp;ldquo;隐形&amp;rdquo;的是不太希望使用的未签名的图像标签。</target>
        </trans-unit>
        <trans-unit id="fa16e8da25fa7178f0acfa55db5c1c871c3155ac" translate="yes" xml:space="preserve">
          <source>Image description</source>
          <target state="translated">图片说明</target>
        </trans-unit>
        <trans-unit id="2bfe7f4e2544f5a0cf8d4697281f70cc40a8dfc1" translate="yes" xml:space="preserve">
          <source>Image digest</source>
          <target state="translated">图像摘要</target>
        </trans-unit>
        <trans-unit id="25e58e59af4c723934aead1624c4bfa9c35f8b22" translate="yes" xml:space="preserve">
          <source>Image disk size</source>
          <target state="translated">影像磁盘大小</target>
        </trans-unit>
        <trans-unit id="212a9200cdec31540b62a52e7c5956a40c149448" translate="yes" xml:space="preserve">
          <source>Image repository</source>
          <target state="translated">图片库</target>
        </trans-unit>
        <trans-unit id="8888020bb69e3dd54934b4fc64f75c443dc19755" translate="yes" xml:space="preserve">
          <source>Image tag</source>
          <target state="translated">图片标签</target>
        </trans-unit>
        <trans-unit id="ca662c89b95ffdff7c161301523b9ef21e3c1bd0" translate="yes" xml:space="preserve">
          <source>Image tags and DCT</source>
          <target state="translated">图像标签和DCT</target>
        </trans-unit>
        <trans-unit id="1d828fd92bb02d0c07163ca93574414854eb0065" translate="yes" xml:space="preserve">
          <source>Image template name</source>
          <target state="translated">图片模板名称</target>
        </trans-unit>
        <trans-unit id="c86c4f797e197f8d5e2ccf8953f76421e1c60e43" translate="yes" xml:space="preserve">
          <source>Image[:tag]</source>
          <target state="translated">Image[:tag]</target>
        </trans-unit>
        <trans-unit id="34c3ec4679bd678d1b10a72deb1b7ecf57727c10" translate="yes" xml:space="preserve">
          <source>Image[@digest]</source>
          <target state="translated">Image[@digest]</target>
        </trans-unit>
        <trans-unit id="09e871c98fef3b901a775def173e4126aaf73b42" translate="yes" xml:space="preserve">
          <source>Images</source>
          <target state="translated">Images</target>
        </trans-unit>
        <trans-unit id="23847f66fa7574788037843db8acd02a0cd22feb" translate="yes" xml:space="preserve">
          <source>Images and containers</source>
          <target state="translated">图像和容器</target>
        </trans-unit>
        <trans-unit id="b175d4ac3b36d06fdf12a9dde9f428047c335e70" translate="yes" xml:space="preserve">
          <source>Images must have digests stored, which requires interaction with a Docker registry. If digests aren&amp;rsquo;t stored for all images, you can fetch them with &lt;code&gt;docker-compose pull&lt;/code&gt; or &lt;code&gt;docker-compose push&lt;/code&gt;. To push images automatically when bundling, pass &lt;code&gt;--push-images&lt;/code&gt;. Only services with a &lt;code&gt;build&lt;/code&gt; option specified have their images pushed.</source>
          <target state="translated">映像必须存储摘要，这需要与Docker注册表进行交互。如果未存储所有图像的摘要，则可以使用 &lt;code&gt;docker-compose pull&lt;/code&gt; 或 &lt;code&gt;docker-compose push&lt;/code&gt; 来获取摘要。要在捆绑时自动推送图像，请传递 &lt;code&gt;--push-images&lt;/code&gt; 。只有指定了 &lt;code&gt;build&lt;/code&gt; 选项的服务才会推送其映像。</target>
        </trans-unit>
        <trans-unit id="eb068f5848f7d2ec1cea267d2ff67b5bbc9782ea" translate="yes" xml:space="preserve">
          <source>Images that use the v2 or later format have a content-addressable identifier called a &lt;code&gt;digest&lt;/code&gt;. As long as the input used to generate the image is unchanged, the digest value is predictable. To list image digest values, use the &lt;code&gt;--digests&lt;/code&gt; flag:</source>
          <target state="translated">使用v2或更高版本格式的图像具有一个可寻址内容的标识符，称为 &lt;code&gt;digest&lt;/code&gt; 。只要用于生成图像的输入不变，摘要值就可以预测。要列出图像摘要值，请使用 &lt;code&gt;--digests&lt;/code&gt; 标志：</target>
        </trans-unit>
        <trans-unit id="8ccbfaed9a04d9f81720c71308ffbefc15ade787" translate="yes" xml:space="preserve">
          <source>Images to consider as cache sources</source>
          <target state="translated">需要考虑作为缓存源的图片</target>
        </trans-unit>
        <trans-unit id="1e6915883b06acaf7dfd14fe8cec6a54c82b5bb1" translate="yes" xml:space="preserve">
          <source>Images using the v2 or later image format have a content-addressable identifier called a digest. As long as the input used to generate the image is unchanged, the digest value is predictable and referenceable.</source>
          <target state="translated">使用v2或更高版本图像格式的图像有一个称为摘要的内容可寻址标识符。只要用于生成图像的输入不变,摘要值是可预测和可参考的。</target>
        </trans-unit>
        <trans-unit id="88da112012b0c6519d012c8f722e82f59491898b" translate="yes" xml:space="preserve">
          <source>Imagine that you have a 10-node swarm, and you deploy an Nginx service running three tasks on a 10-node swarm:</source>
          <target state="translated">想象一下,你有一个10个节点的蜂群,你部署了一个Nginx服务,在10个节点的蜂群上运行三个任务。</target>
        </trans-unit>
        <trans-unit id="725bbbea09ecf62953c9e0fe4109b91cdf779ec0" translate="yes" xml:space="preserve">
          <source>Immediately restart containers if one fails.</source>
          <target state="translated">如果有一个失败,立即重新启动容器。</target>
        </trans-unit>
        <trans-unit id="476a64df8f5696ecbb97f330bc0fcc59db153f7e" translate="yes" xml:space="preserve">
          <source>Impact on build caching</source>
          <target state="translated">对构建缓存的影响</target>
        </trans-unit>
        <trans-unit id="a77bf51bf2cd35ab35589a4c8125a485391ad650" translate="yes" xml:space="preserve">
          <source>Import a context from a tar or zip file</source>
          <target state="translated">从tar或zip文件导入上下文</target>
        </trans-unit>
        <trans-unit id="59ac246eedb955d8cbd8eaa42c83d9a91ef3eee4" translate="yes" xml:space="preserve">
          <source>Import from a local directory</source>
          <target state="translated">从本地目录导入</target>
        </trans-unit>
        <trans-unit id="b14e2df39550357f9f9caaece37378fbe0eab5df" translate="yes" xml:space="preserve">
          <source>Import from a local directory with new configurations</source>
          <target state="translated">从本地目录导入新配置</target>
        </trans-unit>
        <trans-unit id="af751c541d65e2f9288561c4f6af0588b30ff7da" translate="yes" xml:space="preserve">
          <source>Import from a local file</source>
          <target state="translated">从本地文件导入</target>
        </trans-unit>
        <trans-unit id="8088418b6e9230a6b6c875afc4dda0c0839043f7" translate="yes" xml:space="preserve">
          <source>Import from a remote location</source>
          <target state="translated">从远程位置导入</target>
        </trans-unit>
        <trans-unit id="bb50b41244a26144f7c36378564b7d9d89ac76b3" translate="yes" xml:space="preserve">
          <source>Import the contents from a tarball to create a filesystem image</source>
          <target state="translated">从压缩包中导入内容来创建一个文件系统映像。</target>
        </trans-unit>
        <trans-unit id="917c4e43ed77c48dc0fc6453012e3392ae9ed2ea" translate="yes" xml:space="preserve">
          <source>Import to docker from a local archive.</source>
          <target state="translated">从本地存档导入到docker。</target>
        </trans-unit>
        <trans-unit id="245228a97fb3f0dfeb918b70053769a53c34bb54" translate="yes" xml:space="preserve">
          <source>Import to docker via pipe and &lt;code&gt;STDIN&lt;/code&gt;.</source>
          <target state="translated">通过管道和 &lt;code&gt;STDIN&lt;/code&gt; 导入docker。</target>
        </trans-unit>
        <trans-unit id="f1c1df799aebcc10b5c07ddec95aac1c19effe22" translate="yes" xml:space="preserve">
          <source>Import with a commit message.</source>
          <target state="translated">用提交信息导入。</target>
        </trans-unit>
        <trans-unit id="17a3ca00a774965f843a5871b72dca117f794a31" translate="yes" xml:space="preserve">
          <source>Imports a context previously exported with &lt;code&gt;docker context export&lt;/code&gt;. To import from stdin, use a hyphen (&lt;code&gt;-&lt;/code&gt;) as filename.</source>
          <target state="translated">导入先前使用 &lt;code&gt;docker context export&lt;/code&gt; 导出的上下文。要从stdin导入，请使用连字符（ &lt;code&gt;-&lt;/code&gt; ）作为文件名。</target>
        </trans-unit>
        <trans-unit id="e768cac2146e2098c1afd513559f7160e33f66a6" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../compose-versioning/index#version-1&quot;&gt;version 1 file format&lt;/a&gt;, &lt;code&gt;build&lt;/code&gt; is different in two ways:</source>
          <target state="translated">在&lt;a href=&quot;../compose-versioning/index#version-1&quot;&gt;版本1文件格式中&lt;/a&gt;， &lt;code&gt;build&lt;/code&gt; 在两个方面有所不同：</target>
        </trans-unit>
        <trans-unit id="44d884285fe257a1ad94785af65b08ca526d7a7d" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../compose-versioning/index#version-1&quot;&gt;version 1&lt;/a&gt;, you can use container names without marking them as such:</source>
          <target state="translated">在&lt;a href=&quot;../compose-versioning/index#version-1&quot;&gt;版本1中&lt;/a&gt;，您可以使用容器名称而无需将其标记为：</target>
        </trans-unit>
        <trans-unit id="7d2c106f68ac42ca15c268dc9fe930562c886993" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../https/index&quot;&gt;Running Docker with HTTPS&lt;/a&gt;, you learned that, by default, Docker runs via a non-networked Unix socket and TLS must be enabled in order to have the Docker client and the daemon communicate securely over HTTPS. TLS ensures authenticity of the registry endpoint and that traffic to/from registry is encrypted.</source>
          <target state="translated">在&lt;a href=&quot;../https/index&quot;&gt;使用HTTPS运行Docker中&lt;/a&gt;，您了解到，默认情况下，Docker通过非联网的Unix套接字运行，并且必须启用TLS才能使Docker客户端和守护程序通过HTTPS安全地进行通信。TLS确保注册表端点的真实性，并且对往返注册表的通信进行加密。</target>
        </trans-unit>
        <trans-unit id="cebc4c46df5f015f8475209378cd9a380c12b921" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../part3/index&quot;&gt;part 3&lt;/a&gt;, you took an app you wrote in &lt;a href=&quot;../part2/index&quot;&gt;part 2&lt;/a&gt;, and defined how it should run in production by turning it into a service, scaling it up 5x in the process.</source>
          <target state="translated">在&lt;a href=&quot;../part3/index&quot;&gt;第3部分中&lt;/a&gt;，您使用了在&lt;a href=&quot;../part2/index&quot;&gt;第2部分中&lt;/a&gt;编写的应用程序，并通过将其转变为服务并将其在过程中扩大5倍来定义了该应用程序应如何在生产环境中运行。</target>
        </trans-unit>
        <trans-unit id="ef4d413ec0e89fa3b52adf430f0bcec3dde1939b" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../part4/index&quot;&gt;part 4&lt;/a&gt;, you learned how to set up a swarm, which is a cluster of machines running Docker, and deployed an application to it, with containers running in concert on multiple machines.</source>
          <target state="translated">在&lt;a href=&quot;../part4/index&quot;&gt;第4部分中&lt;/a&gt;，您学习了如何设置群集，群集是运行Docker的计算机集群，并向其中部署了应用程序，容器在多个计算机上协同运行。</target>
        </trans-unit>
        <trans-unit id="44904e78e7d1d56ea6f2891b11cae1785aa0aef2" translate="yes" xml:space="preserve">
          <source>In Compose file format 3.x, you can optionally set the &lt;code&gt;attachable&lt;/code&gt; property to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">在Compose文件格式3.x中，可以选择将 &lt;code&gt;attachable&lt;/code&gt; 属性设置为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb4906830491dcb2e177349cb0dd91e5a7651470" translate="yes" xml:space="preserve">
          <source>In Docker 1.13 and higher, the Raft logs used by swarm managers are encrypted on disk by default. This at-rest encryption protects your service&amp;rsquo;s configuration and data from attackers who gain access to the encrypted Raft logs. One of the reasons this feature was introduced was in support of the new &lt;a href=&quot;../secrets/index&quot;&gt;Docker secrets&lt;/a&gt; feature.</source>
          <target state="translated">在Docker 1.13和更高版本中，默认情况下，群集管理器使用的Raft日志在磁盘上加密。这种静态加密可保护您的服务配置和数据免遭攻击者的攻击，这些攻击者可以访问加密的Raft日志。引入此功能的原因之一是为了支持新的&lt;a href=&quot;../secrets/index&quot;&gt;Docker Secrets&lt;/a&gt;功能。</target>
        </trans-unit>
        <trans-unit id="b5d038a6967c5b86f1a5e5d0d90d098a759d1ac7" translate="yes" xml:space="preserve">
          <source>In Docker 1.13 and higher, you can use the &lt;code&gt;--force&lt;/code&gt; or &lt;code&gt;-f&lt;/code&gt; flag with the &lt;code&gt;docker service update&lt;/code&gt; command to force the service to redistribute its tasks across the available worker nodes. This causes the service tasks to restart. Client applications may be disrupted. If you have configured it, your service uses a &lt;a href=&quot;../swarm-tutorial/rolling-update/index&quot;&gt;rolling update&lt;/a&gt;.</source>
          <target state="translated">在Docker 1.13及更高版本中，您可以在 &lt;code&gt;docker service update&lt;/code&gt; 命令中使用 &lt;code&gt;--force&lt;/code&gt; 或 &lt;code&gt;-f&lt;/code&gt; 标志，以强制服务在可用的工作节点上重新分配其任务。这将导致服务任务重新启动。客户端应用程序可能会中断。如果已配置，则您的服务将使用&lt;a href=&quot;../swarm-tutorial/rolling-update/index&quot;&gt;滚动更新&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0bed4dbfffbdc2ad1e77dd3c05f72b79671ebf29" translate="yes" xml:space="preserve">
          <source>In Docker 17.04 and higher, you can configure a service to roll back automatically if a service update fails to deploy. See &lt;a href=&quot;#automatically-roll-back-if-an-update-fails&quot;&gt;Automatically roll back if an update fails&lt;/a&gt;.</source>
          <target state="translated">在Docker 17.04及更高版本中，您可以将服务配置为在无法部署服务更新时自动回滚。&lt;a href=&quot;#automatically-roll-back-if-an-update-fails&quot;&gt;如果更新失败，&lt;/a&gt;请参阅自动回滚。</target>
        </trans-unit>
        <trans-unit id="c368bba16615dcbbc6ff7260156db7367b0127e5" translate="yes" xml:space="preserve">
          <source>In Docker 17.05 and earlier, secrets are always located within the &lt;code&gt;/run/secrets/&lt;/code&gt; directory. Docker 17.06 and higher allow you to specify a custom location for a secret within the container. The two examples below illustrate the difference. The older version of this command requires you to create a symbolic link to the true location of the &lt;code&gt;site.conf&lt;/code&gt; file so that Nginx can read it, but the newer version does not require this. The older example is preserved so that you can see the difference.</source>
          <target state="translated">在Docker 17.05及更早版本中，机密始终位于 &lt;code&gt;/run/secrets/&lt;/code&gt; 目录中。Docker 17.06及更高版本允许您为容器内的秘密指定自定义位置。下面的两个示例说明了差异。此命令的较旧版本要求您创建指向 &lt;code&gt;site.conf&lt;/code&gt; 文件真实位置的符号链接，以便Nginx可以读取它，但较新版本不需要此链接。保留了较早的示例，以便您可以看到不同之处。</target>
        </trans-unit>
        <trans-unit id="1e2e9f48f49b02a6e2a75caca1b843f6d52ad27d" translate="yes" xml:space="preserve">
          <source>In Docker 17.06 and higher, Docker also tells all nodes to immediately renew their TLS certificates. This process may take several minutes, depending on the number of nodes in the swarm.</source>
          <target state="translated">在Docker 17.06和更高版本中,Docker还告诉所有节点立即更新其TLS证书。这个过程可能需要几分钟,这取决于群中节点的数量。</target>
        </trans-unit>
        <trans-unit id="ae5f457448fc694390bdddfb48512e7fc1888016" translate="yes" xml:space="preserve">
          <source>In Enterprise Edition 3.0, security is improved through the centralized distribution and management of Group Managed Service Account(gMSA) credentials using Docker Config functionality. Swarm now allows using a Docker Config as a gMSA credential spec, which reduces the burden of distributing credential specs to the nodes on which they are used.</source>
          <target state="translated">在企业版3.0中,通过使用Docker Config功能集中分发和管理集团管理服务账户(gMSA)凭证,提高了安全性。Swarm 现在允许使用 Docker Config 作为 gMSA 凭证规范,这减少了将凭证规范分发到使用它们的节点的负担。</target>
        </trans-unit>
        <trans-unit id="a15ea31fb01f46bfd56520155cf023c2cc703f20" translate="yes" xml:space="preserve">
          <source>In PowerShell, since GitHub now requires TLS1.2, run the following:</source>
          <target state="translated">在PowerShell中,因为GitHub现在需要TLS1.2,所以运行以下命令。</target>
        </trans-unit>
        <trans-unit id="2819c465da200bd336241494742d8c6069d7cf4c" translate="yes" xml:space="preserve">
          <source>In a &lt;strong&gt;common.yml&lt;/strong&gt; we define the common configuration:</source>
          <target state="translated">在&lt;strong&gt;common.yml中，&lt;/strong&gt;我们定义公共配置：</target>
        </trans-unit>
        <trans-unit id="a3552d5600b4d9f18898ff597bbcb4a7aeda6134" translate="yes" xml:space="preserve">
          <source>In a &lt;strong&gt;docker-compose.admin.yml&lt;/strong&gt; add a new service to run the database export or backup.</source>
          <target state="translated">在&lt;strong&gt;docker-compose.admin.yml中&lt;/strong&gt;添加新服务以运行数据库导出或备份。</target>
        </trans-unit>
        <trans-unit id="17f66a12f1e191bfac4b15b2b7e82d32b416b4c6" translate="yes" xml:space="preserve">
          <source>In a &lt;strong&gt;docker-compose.yml&lt;/strong&gt; we define the concrete services which use the common configuration:</source>
          <target state="translated">在&lt;strong&gt;docker-compose.yml中，&lt;/strong&gt;我们定义了使用通用配置的具体服务：</target>
        </trans-unit>
        <trans-unit id="533543a7d4c7e79b5cbba450534920c35bc934d9" translate="yes" xml:space="preserve">
          <source>In a distributed application, different pieces of the app are called &amp;ldquo;services&amp;rdquo;. For example, if you imagine a video sharing site, it probably includes a service for storing application data in a database, a service for video transcoding in the background after a user uploads something, a service for the front-end, and so on.</source>
          <target state="translated">在分布式应用程序中，应用程序的不同部分称为&amp;ldquo;服务&amp;rdquo;。例如，如果您想象一个视频共享站点，则它可能包括用于将应用程序数据存储在数据库中的服务，用于在用户上传内容后在后台进行视频转码的服务，用于前端的服务等等。</target>
        </trans-unit>
        <trans-unit id="a22937ba30c717a6507f3d4a9b3677b139196e19" translate="yes" xml:space="preserve">
          <source>In a previous step of the tutorial, you &lt;a href=&quot;../scale-service/index&quot;&gt;scaled&lt;/a&gt; the number of instances of a service. In this part of the tutorial, you deploy a service based on the Redis 3.0.6 container tag. Then you upgrade the service to use the Redis 3.0.7 container image using rolling updates.</source>
          <target state="translated">在本教程的上一步中，您&lt;a href=&quot;../scale-service/index&quot;&gt;缩放&lt;/a&gt;了服务实例的数量。在本部分中，您将基于Redis 3.0.6容器标签部署服务。然后，通过滚动更新将服务升级为使用Redis 3.0.7容器映像。</target>
        </trans-unit>
        <trans-unit id="ca8de6027d14e43307b73994ba172c9eedd57dfe" translate="yes" xml:space="preserve">
          <source>In a swarm of &lt;code&gt;N&lt;/code&gt; managers, a quorum (a majority) of manager nodes must always be available. For example, in a swarm with 5 managers, a minimum of 3 must be operational and in communication with each other. In other words, the swarm can tolerate up to &lt;code&gt;(N-1)/2&lt;/code&gt; permanent failures beyond which requests involving swarm management cannot be processed. These types of failures include data corruption or hardware failures.</source>
          <target state="translated">在 &lt;code&gt;N&lt;/code&gt; 个管理器群中，一定数量（多数）的管理器节点必须始终可用。例如，在拥有5名经理的团队中，至少3名必须是可操作的并且彼此通信。换句话说，群集最多可以容忍 &lt;code&gt;(N-1)/2&lt;/code&gt; 个永久性故障，超过这些永久性故障将无法处理涉及群集管理的请求。这些类型的故障包括数据损坏或硬件故障。</target>
        </trans-unit>
        <trans-unit id="8ef7dcefd146a7eb680d884b8a9d407b66ea5215" translate="yes" xml:space="preserve">
          <source>In a web browser, go to &lt;code&gt;http://&amp;lt;host_ip&amp;gt;:8000&lt;/code&gt; to bring up the webserver home page. You got the &lt;code&gt;&amp;lt;host_ip&amp;gt;&lt;/code&gt; from the output of the &lt;code&gt;docker-machine ip &amp;lt;machine&amp;gt;&lt;/code&gt; command you ran in a previous step. Use the port you exposed in the &lt;code&gt;docker run&lt;/code&gt; command.</source>
          <target state="translated">在Web浏览器中，转到 &lt;code&gt;http://&amp;lt;host_ip&amp;gt;:8000&lt;/code&gt; 以打开Web服务器主页。您从上一步中运行的 &lt;code&gt;&amp;lt;host_ip&amp;gt;&lt;/code&gt; &lt;code&gt;docker-machine ip &amp;lt;machine&amp;gt;&lt;/code&gt; 命令的输出中获得了&amp;lt;host_ip&amp;gt;。使用您在 &lt;code&gt;docker run&lt;/code&gt; 命令中公开的端口。</target>
        </trans-unit>
        <trans-unit id="44321900d1984b4d80f20a0b0284d786d26bc5cd" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;--privileged&lt;/code&gt;, the operator can have fine grain control over the capabilities using &lt;code&gt;--cap-add&lt;/code&gt; and &lt;code&gt;--cap-drop&lt;/code&gt;. By default, Docker has a default list of capabilities that are kept. The following table lists the Linux capability options which are allowed by default and can be dropped.</source>
          <target state="translated">除了 &lt;code&gt;--privileged&lt;/code&gt; ，操作员还可以使用 &lt;code&gt;--cap-add&lt;/code&gt; 和 &lt;code&gt;--cap-drop&lt;/code&gt; 对功能进行精细控制。默认情况下，Docker具有保留的默认功能列表。下表列出了默认情况下允许并可以删除的Linux功能选项。</target>
        </trans-unit>
        <trans-unit id="8dba3d97d1c6e8ce331405e0f7f377b4acd4af30" translate="yes" xml:space="preserve">
          <source>In addition to &lt;em&gt;running&lt;/em&gt; tasks, the output also shows the task history. For example, after updating the service to use the &lt;code&gt;redis:3.0.6&lt;/code&gt; image, the output may look like this:</source>
          <target state="translated">除了&lt;em&gt;正在运行的&lt;/em&gt;任务，输出还显示任务历史记录。例如，将服务更新为使用 &lt;code&gt;redis:3.0.6&lt;/code&gt; 图像后，输出可能如下所示：</target>
        </trans-unit>
        <trans-unit id="02ccf39aee67211d958c18d2958a29ef3c025c35" translate="yes" xml:space="preserve">
          <source>In addition to Compose file format versions shown in the table, the Compose itself is on a release schedule, as shown in &lt;a href=&quot;https://github.com/docker/compose/releases/&quot;&gt;Compose releases&lt;/a&gt;, but file format versions do not necessarily increment with each release. For example, Compose file format 3.0 was first introduced in &lt;a href=&quot;https://github.com/docker/compose/releases/tag/1.10.0&quot;&gt;Compose release 1.10.0&lt;/a&gt;, and versioned gradually in subsequent releases.</source>
          <target state="translated">除了表中显示的Compose文件格式版本外，Compose本身也处于发布计划中，如&lt;a href=&quot;https://github.com/docker/compose/releases/&quot;&gt;Compose releases中&lt;/a&gt;所示，但是文件格式版本不一定随每个发行版增加。例如，Compose文件格式3.0最初是在&lt;a href=&quot;https://github.com/docker/compose/releases/tag/1.10.0&quot;&gt;Compose版本1.10.0中&lt;/a&gt;引入的，并在随后的版本中逐渐版本化。</target>
        </trans-unit>
        <trans-unit id="59ea0f30071c8b9591e5be8c4ad05bcf2d51891d" translate="yes" xml:space="preserve">
          <source>In addition to Docker&amp;rsquo;s standard plugin registration method, each plugin should implement the following two methods:</source>
          <target state="translated">除了Docker的标准插件注册方法外，每个插件还应实现以下两种方法：</target>
        </trans-unit>
        <trans-unit id="f71e4ed1533f9b3144ef50664bca71e29a02f07a" translate="yes" xml:space="preserve">
          <source>In addition to configuring Docker Engine options as listed above, you can use Machine to specify how the created swarm manager is configured. There is a &lt;code&gt;--swarm-strategy&lt;/code&gt; flag, which you can use to specify the &lt;a href=&quot;https://docs.docker.com/swarm/scheduler/strategy/&quot;&gt;scheduling strategy&lt;/a&gt; which Docker Swarm should use (Machine defaults to the &lt;code&gt;spread&lt;/code&gt; strategy). There is also a general purpose &lt;code&gt;--swarm-opt&lt;/code&gt; option which works similar to the aforementioned &lt;code&gt;--engine-opt&lt;/code&gt; option, except that it specifies options for the &lt;code&gt;swarm manage&lt;/code&gt; command (used to boot a master node) instead of the base command. You can use this to configure features that power users might be interested in, such as configuring the heartbeat interval or Swarm&amp;rsquo;s willingness to over-commit resources. There is also the &lt;code&gt;--swarm-experimental&lt;/code&gt; flag, that allows you to access &lt;a href=&quot;https://github.com/docker/swarm/tree/master/experimental&quot;&gt;experimental features&lt;/a&gt; in Docker Swarm.</source>
          <target state="translated">除了配置上面列出的Docker Engine选项之外，您还可以使用Machine指定如何配置创建的swarm管理器。有一个 &lt;code&gt;--swarm-strategy&lt;/code&gt; 标志，可用于指定Docker Swarm应该使用的&lt;a href=&quot;https://docs.docker.com/swarm/scheduler/strategy/&quot;&gt;调度策略&lt;/a&gt;（Machine默认为 &lt;code&gt;spread&lt;/code&gt; 策略）。还有一个通用的 &lt;code&gt;--swarm-opt&lt;/code&gt; 选项，其工作方式与上述的 &lt;code&gt;--engine-opt&lt;/code&gt; 选项相似，不同之处在于它为 &lt;code&gt;swarm manage&lt;/code&gt; 指定了选项命令（用于引导主节点）而不是基本命令。您可以使用它来配置高级用户可能感兴趣的功能，例如配置心跳间隔或Swarm过度使用资源的意愿。还有 &lt;code&gt;--swarm-experimental&lt;/code&gt; 标志，使您可以访问Docker Swarm中的&lt;a href=&quot;https://github.com/docker/swarm/tree/master/experimental&quot;&gt;实验性功能&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b6895df25c17b42df521add4b1b67aa3bc759f81" translate="yes" xml:space="preserve">
          <source>In addition to maintaining an odd number of manager nodes, pay attention to datacenter topology when placing managers. For optimal fault-tolerance, distribute manager nodes across a minimum of 3 availability-zones to support failures of an entire set of machines or common maintenance scenarios. If you suffer a failure in any of those zones, the swarm should maintain the quorum of manager nodes available to process requests and rebalance workloads.</source>
          <target state="translated">除了保持奇数的管理器节点外,在放置管理器时还要注意数据中心的拓扑结构。为了获得最佳的容错性,应将管理器节点分布在至少3个可用性区,以支持整组机器的故障或常见的维护场景。如果您在其中任何一个区域发生故障,蜂群应保持管理节点的法定数量,以处理请求和重新平衡工作负载。</target>
        </trans-unit>
        <trans-unit id="0f7e89d0e5dce1710c0689c1ba441f3f53e1f735" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;text/template&lt;/code&gt; syntax, there are some additional functions, &lt;code&gt;json&lt;/code&gt; and &lt;code&gt;prettyjson&lt;/code&gt;, which can be used to format the output as JSON (documented below).</source>
          <target state="translated">除了 &lt;code&gt;text/template&lt;/code&gt; 语法外，还有一些其他函数 &lt;code&gt;json&lt;/code&gt; 和 &lt;code&gt;prettyjson&lt;/code&gt; ，可用于将输出格式化为JSON（如下所述）。</target>
        </trans-unit>
        <trans-unit id="2f902b77d43826ac29278b237fde653a03979e0c" translate="yes" xml:space="preserve">
          <source>In addition to the configuration file format, see the optional password &lt;a href=&quot;index#environment-variables-optional&quot;&gt;environment variables&lt;/a&gt; that the Notary client can take for ease of use.</source>
          <target state="translated">除了配置文件格式之外，请参阅Notary客户端为便于使用而可以使用的可选密码&lt;a href=&quot;index#environment-variables-optional&quot;&gt;环境变量&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5ab9b294fd7a389232a230d2b62d79af190f9d31" translate="yes" xml:space="preserve">
          <source>In addition to the provider, you have the option of identifying a base operating system. It is an option because Docker Machine has defaults for both local and remote providers. For local providers such as VirtualBox, Fusion, Hyper-V, and so forth, the default base operating system is Boot2Docker. For cloud providers, the base operating system is the latest Ubuntu LTS the provider supports.</source>
          <target state="translated">除了提供者之外,你还可以选择确定一个基础操作系统。这是一个选项,因为Docker Machine对本地和远程提供者都有默认的操作系统。对于本地提供商,如VirtualBox、Fusion、Hyper-V等,默认的基础操作系统是Boot2Docker。对于云提供商,基础操作系统是提供商支持的最新Ubuntu LTS。</target>
        </trans-unit>
        <trans-unit id="a9581556890e7ba33ac4ca96ae34722bbb7032bf" translate="yes" xml:space="preserve">
          <source>In addition to this subset of daemon flags which are directly supported, Docker Machine also supports an additional flag, &lt;code&gt;--engine-opt&lt;/code&gt;, which can be used to specify arbitrary daemon options with the syntax &lt;code&gt;--engine-opt flagname=value&lt;/code&gt;. For example, to specify that the daemon should use &lt;code&gt;8.8.8.8&lt;/code&gt; as the DNS server for all containers, and always use the &lt;code&gt;syslog&lt;/code&gt;&lt;a href=&quot;../../../engine/reference/run/index#logging-drivers-log-driver&quot;&gt;log driver&lt;/a&gt; you could run the following create command:</source>
          <target state="translated">除了直接支持的守护程序标志子集之外，Docker机器还支持附加标志 &lt;code&gt;--engine-opt&lt;/code&gt; ，该标志可用于使用 &lt;code&gt;--engine-opt flagname=value&lt;/code&gt; 语法指定任意守护程序选项。例如，要指定守护程序应将 &lt;code&gt;8.8.8.8&lt;/code&gt; 用作所有容器的DNS服务器，并始​​终使用 &lt;code&gt;syslog&lt;/code&gt; &lt;a href=&quot;../../../engine/reference/run/index#logging-drivers-log-driver&quot;&gt;日志驱动程序&lt;/a&gt;，可以运行以下create命令：</target>
        </trans-unit>
        <trans-unit id="23a85ca75ff4dc883deb3bad37e9915a96ba497b" translate="yes" xml:space="preserve">
          <source>In addition to use &lt;code&gt;--cpu-period&lt;/code&gt; and &lt;code&gt;--cpu-quota&lt;/code&gt; for setting CPU period constraints, it is possible to specify &lt;code&gt;--cpus&lt;/code&gt; with a float number to achieve the same purpose. For example, if there is 1 CPU, then &lt;code&gt;--cpus=0.5&lt;/code&gt; will achieve the same result as setting &lt;code&gt;--cpu-period=50000&lt;/code&gt; and &lt;code&gt;--cpu-quota=25000&lt;/code&gt; (50% CPU).</source>
          <target state="translated">除了使用 &lt;code&gt;--cpu-period&lt;/code&gt; 和 &lt;code&gt;--cpu-quota&lt;/code&gt; 来设置CPU周期约束外，还可以使用浮点数指定 &lt;code&gt;--cpus&lt;/code&gt; 以实现相同的目的。例如，如果有1个CPU，则 &lt;code&gt;--cpus=0.5&lt;/code&gt; 将获得与设置 &lt;code&gt;--cpu-period=50000&lt;/code&gt; 和 &lt;code&gt;--cpu-quota=25000&lt;/code&gt; （50％CPU）相同的结果。</target>
        </trans-unit>
        <trans-unit id="93da1dca83ad692961dd78b94e5a5ed8ba89b038" translate="yes" xml:space="preserve">
          <source>In addition, if you use &lt;code&gt;mode=host&lt;/code&gt; and you do not use the &lt;code&gt;--mode=global&lt;/code&gt; flag on &lt;code&gt;docker service create&lt;/code&gt;, it is difficult to know which nodes are running the service to route work to them.</source>
          <target state="translated">另外，如果您使用 &lt;code&gt;mode=host&lt;/code&gt; 并且未在 &lt;code&gt;--mode=global&lt;/code&gt; &lt;code&gt;docker service create&lt;/code&gt; 上使用--mode = global标志，则很难知道哪些节点正在运行服务以将工作路由到它们。</target>
        </trans-unit>
        <trans-unit id="1f54de1cc9507699e1c7557ff75c9c76ba654718" translate="yes" xml:space="preserve">
          <source>In all cases, &lt;code&gt;word&lt;/code&gt; can be any string, including additional environment variables.</source>
          <target state="translated">在所有情况下， &lt;code&gt;word&lt;/code&gt; 都可以是任何字符串，包括其他环境变量。</target>
        </trans-unit>
        <trans-unit id="8f0294a233b34dce74a03ef32062fef2fc078c1a" translate="yes" xml:space="preserve">
          <source>In another terminal window, list the running Docker processes with the &lt;code&gt;docker container ls&lt;/code&gt; command.</source>
          <target state="translated">在另一个终端窗口中，使用 &lt;code&gt;docker container ls&lt;/code&gt; 命令列出正在运行的Docker进程。</target>
        </trans-unit>
        <trans-unit id="397d4e8e3c9f798330c8497c9ec1be89c0360966" translate="yes" xml:space="preserve">
          <source>In another terminal, stop the first container. The &lt;code&gt;docker wait&lt;/code&gt; command above returns the exit code.</source>
          <target state="translated">在另一个终端，停止第一个容器。上面的 &lt;code&gt;docker wait&lt;/code&gt; 命令返回退出代码。</target>
        </trans-unit>
        <trans-unit id="c8a0d2d64838288d78db9307f8dc6841bd617b6a" translate="yes" xml:space="preserve">
          <source>In case of potential compromise, notary provides a CLI command for rotating keys. You can use the &lt;code&gt;notary key rotate&lt;/code&gt; command to rotate the targets or snapshot keys.</source>
          <target state="translated">万一有潜在的威胁，公证人会提供用于旋转密钥的CLI命令。您可以使用 &lt;code&gt;notary key rotate&lt;/code&gt; 命令来旋转目标或快照键。</target>
        </trans-unit>
        <trans-unit id="b8769bfd86b393555cec09d4c89137492e1d1d22" translate="yes" xml:space="preserve">
          <source>In case the updated version of a service doesn&amp;rsquo;t function as expected, it&amp;rsquo;s possible to manually roll back to the previous version of the service using &lt;code&gt;docker service update&lt;/code&gt;&amp;rsquo;s &lt;code&gt;--rollback&lt;/code&gt; flag. This reverts the service to the configuration that was in place before the most recent &lt;code&gt;docker service update&lt;/code&gt; command.</source>
          <target state="translated">如果服务的更新版本无法正常运行，则可以使用 &lt;code&gt;--rollback&lt;/code&gt; &lt;code&gt;docker service update&lt;/code&gt; 的--rollback标志手动回滚到服务的先前版本。这会将服务还原为最新的 &lt;code&gt;docker service update&lt;/code&gt; 命令之前的配置。</target>
        </trans-unit>
        <trans-unit id="3f3837fe05a8b392362b1ab9412c41f8ece6fba8" translate="yes" xml:space="preserve">
          <source>In certain cases you want your container to share the host&amp;rsquo;s process namespace, basically allowing processes within the container to see all of the processes on the system. For example, you could build a container with debugging tools like &lt;code&gt;strace&lt;/code&gt; or &lt;code&gt;gdb&lt;/code&gt;, but want to use these tools when debugging processes within the container.</source>
          <target state="translated">在某些情况下，您希望容器共享主机的进程名称空间，基本上允许容器内的进程查看系统上的所有进程。例如，您可以使用调试工具（例如 &lt;code&gt;strace&lt;/code&gt; 或 &lt;code&gt;gdb&lt;/code&gt; )来构建容器，但希望在调试容器中的进程时使用这些工具。</target>
        </trans-unit>
        <trans-unit id="c99314a395f4bd66ea01711ce213eb84d4a0b001" translate="yes" xml:space="preserve">
          <source>In earlier steps of the tutorial, all the nodes have been running with &lt;code&gt;ACTIVE&lt;/code&gt; availability. The swarm manager can assign tasks to any &lt;code&gt;ACTIVE&lt;/code&gt; node, so up to now all nodes have been available to receive tasks.</source>
          <target state="translated">在本教程的较早步骤中，所有节点都已经以 &lt;code&gt;ACTIVE&lt;/code&gt; 可用性运行。该群管理员可以将任务分配给任何 &lt;code&gt;ACTIVE&lt;/code&gt; 节点，所以到现在为止所有节点已经可以接收任务。</target>
        </trans-unit>
        <trans-unit id="09d84b033f5532984826b8531fbf6f3992b119f5" translate="yes" xml:space="preserve">
          <source>In effect, the profile is a whitelist which denies access to system calls by default, then whitelists specific system calls. The profile works by defining a &lt;code&gt;defaultAction&lt;/code&gt; of &lt;code&gt;SCMP_ACT_ERRNO&lt;/code&gt; and overriding that action only for specific system calls. The effect of &lt;code&gt;SCMP_ACT_ERRNO&lt;/code&gt; is to cause a &lt;code&gt;Permission Denied&lt;/code&gt; error. Next, the profile defines a specific list of system calls which are fully allowed, because their &lt;code&gt;action&lt;/code&gt; is overridden to be &lt;code&gt;SCMP_ACT_ALLOW&lt;/code&gt;. Finally, some specific rules are for individual system calls such as &lt;code&gt;personality&lt;/code&gt;, &lt;code&gt;socket&lt;/code&gt;, &lt;code&gt;socketcall&lt;/code&gt;, and others, to allow variants of those system calls with specific arguments.</source>
          <target state="translated">实际上，配置文件是白名单，默认情况下拒绝访问系统调用，然后将特定的系统调用列入白名单。配置文件的工作方式定义 &lt;code&gt;defaultAction&lt;/code&gt; 的的 &lt;code&gt;SCMP_ACT_ERRNO&lt;/code&gt; 只有重写这一行动特定系统调用。 &lt;code&gt;SCMP_ACT_ERRNO&lt;/code&gt; 的作用是导致 &lt;code&gt;Permission Denied&lt;/code&gt; 错误。接下来，概要文件定义了完全允许的系统调用的特定列表，因为它们的 &lt;code&gt;action&lt;/code&gt; 被覆盖为 &lt;code&gt;SCMP_ACT_ALLOW&lt;/code&gt; 。最后，一些针对特定系统调用的特定规则，例如 &lt;code&gt;personality&lt;/code&gt; ， &lt;code&gt;socket&lt;/code&gt; ，套接字 &lt;code&gt;socketcall&lt;/code&gt; 和其他，以允许使用特定参数的那些系统调用的变体。</target>
        </trans-unit>
        <trans-unit id="9a2a6e9df49f4dcc603cd9085f8046e515db061b" translate="yes" xml:space="preserve">
          <source>In either case, simply run &lt;code&gt;docker stack deploy&lt;/code&gt; again to deploy these changes.</source>
          <target state="translated">无论哪种情况，只需再次运行 &lt;code&gt;docker stack deploy&lt;/code&gt; 即可部署这些更改。</target>
        </trans-unit>
        <trans-unit id="76fbdb43c4133cf0999946d09f0420d3d642c42c" translate="yes" xml:space="preserve">
          <source>In foreground mode (the default when &lt;code&gt;-d&lt;/code&gt; is not specified), &lt;code&gt;docker run&lt;/code&gt; can start the process in the container and attach the console to the process&amp;rsquo;s standard input, output, and standard error. It can even pretend to be a TTY (this is what most command line executables expect) and pass along signals. All of that is configurable:</source>
          <target state="translated">在前台模式下（未指定 &lt;code&gt;-d&lt;/code&gt; 时的默认设置）， &lt;code&gt;docker run&lt;/code&gt; 可以在容器中启动进程并将控制台附加到进程的标准输入，输出和标准错误。它甚至可以假装为TTY（这是大多数命令行可执行文件所期望的）并传递信号。所有这些都是可配置的：</target>
        </trans-unit>
        <trans-unit id="328c1a9e0fc74c42f8074267c542e443625c2d76" translate="yes" xml:space="preserve">
          <source>In general it should be safe to enable this option by default. It will help when unintentional leaking of mount point happens across multiple mount namespaces.</source>
          <target state="translated">一般来说,默认启用这个选项应该是安全的。当多个挂载命名空间发生挂载点无意泄漏时,这个选项会有帮助。</target>
        </trans-unit>
        <trans-unit id="66943ec59ec0388ba65a3392decd34d106b0475c" translate="yes" xml:space="preserve">
          <source>In kernel x86 real mode virtual machine. Also gated by &lt;code&gt;CAP_SYS_ADMIN&lt;/code&gt;.</source>
          <target state="translated">在内核x86实模式虚拟机中。也由 &lt;code&gt;CAP_SYS_ADMIN&lt;/code&gt; 控制。</target>
        </trans-unit>
        <trans-unit id="2269218bfb4b3b65fa8f1ab01160feef0b7a00ec" translate="yes" xml:space="preserve">
          <source>In most cases, it&amp;rsquo;s best to put each Dockerfile in an empty directory. Then, add to that directory only the files needed for building the Dockerfile. To increase the build&amp;rsquo;s performance, you can exclude files and directories by adding a &lt;code&gt;.dockerignore&lt;/code&gt; file to that directory as well. For information on creating one, see the &lt;a href=&quot;../../builder/index#dockerignore-file&quot;&gt;.dockerignore file&lt;/a&gt;.</source>
          <target state="translated">在大多数情况下，最好将每个Dockerfile放在一个空目录中。然后，仅将构建Dockerfile所需的文件添加到该目录。为了提高构建的性能，您还可以通过 &lt;code&gt;.dockerignore&lt;/code&gt; 目录添加.dockerignore文件来排除文件和目录。有关创建一个的信息，请参见&lt;a href=&quot;../../builder/index#dockerignore-file&quot;&gt;.dockerignore文件&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="378b863cae308a6d28e59bc80ff0e1d272905381" translate="yes" xml:space="preserve">
          <source>In most cases, you should shut down a node before removing it from a swarm with the &lt;code&gt;docker node rm&lt;/code&gt; command. If a node becomes unreachable, unresponsive, or compromised you can forcefully remove the node without shutting it down by passing the &lt;code&gt;--force&lt;/code&gt; flag. For instance, if &lt;code&gt;node9&lt;/code&gt; becomes compromised:</source>
          <target state="translated">在大多数情况下，应该先使用 &lt;code&gt;docker node rm&lt;/code&gt; 命令关闭节点，然后再将其从集群中删除。如果某个节点变得不可访问，无响应或受到威胁，则可以通过传递 &lt;code&gt;--force&lt;/code&gt; 标志来强制删除该节点而无需关闭该节点。例如，如果 &lt;code&gt;node9&lt;/code&gt; 受到威胁：</target>
        </trans-unit>
        <trans-unit id="85c6b654dcba5a7495f7617273a2693372930488" translate="yes" xml:space="preserve">
          <source>In most situations, you do not need to worry about this implementation detail and Docker Machine acts sensibly out of the box. However, if you deliberately want to use the Go native version, you can do so with a global command line flag / environment variable like so:</source>
          <target state="translated">在大多数情况下,你不需要担心这个实现细节,Docker Machine会在开箱后理智地行事。但是,如果你刻意想使用Go原生版本,你可以通过全局命令行标志/环境变量来实现,比如这样。</target>
        </trans-unit>
        <trans-unit id="e386581222ebf4485d1bb8fd4d615a4d6167e328" translate="yes" xml:space="preserve">
          <source>In order to retrieve logs before a specific point in time, run:</source>
          <target state="translated">为了检索特定时间点之前的日志,运行。</target>
        </trans-unit>
        <trans-unit id="a3907efe6e721ea176d26de90bbf285ba22f6516" translate="yes" xml:space="preserve">
          <source>In part 3, we scale our application and enable load-balancing. To do this, we must go one level up in the hierarchy of a distributed application: the &lt;strong&gt;service&lt;/strong&gt;.</source>
          <target state="translated">在第3部分中，我们扩展应用程序并启用负载平衡。为此，我们必须在分布式应用程序的层次结构中上一层：&lt;strong&gt;service&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="d307aa39db6ae926e0502e3bbd4b356cb05892e8" translate="yes" xml:space="preserve">
          <source>In part 4 you learned what a swarm is, how nodes in swarms can be managers or workers, created a swarm, and deployed an application on it. You saw that the core Docker commands didn&amp;rsquo;t change from part 3, they just had to be targeted to run on a swarm master. You also saw the power of Docker&amp;rsquo;s networking in action, which kept load-balancing requests across containers, even though they were running on different machines. Finally, you learned how to iterate and scale your app on a cluster.</source>
          <target state="translated">在第4部分中，您了解了群是什么，群中的节点如何成为管理者或工作者，如何创建群并在其上部署应用程序。您已经看到Docker的核心命令在第3部分中没有变化，只需要针对它们即可在群集主服务器上运行。您还可以看到Docker网络的强大功能，即使在不同的计算机上运行这些容器，也可以在各个容器之间保持负载平衡请求。最后，您学习了如何在集群上迭代和扩展应用程序。</target>
        </trans-unit>
        <trans-unit id="b0f3788d7f0c9322113fa02952b76a42809054fa" translate="yes" xml:space="preserve">
          <source>In previous releases, Docker Machine was used to provision swarm clusters, but this is legacy. &lt;a href=&quot;../../engine/swarm/index&quot;&gt;Swarm mode&lt;/a&gt;, built into Docker Engine, supersedes Machine provisioning of swarm clusters. The topics below show you how to get started with the new swarm mode.</source>
          <target state="translated">在以前的版本中，使用Docker Machine来供应群集集群，但这是很旧的。Docker Engine中内置的&lt;a href=&quot;../../engine/swarm/index&quot;&gt;Swarm模式&lt;/a&gt;取代了群集集群的机器配置。下面的主题向您展示如何开始使用新的群体模式。</target>
        </trans-unit>
        <trans-unit id="a58edf728e9381d2f0646937d62331b45e9db8ef" translate="yes" xml:space="preserve">
          <source>In some cases you don&amp;rsquo;t want images to be updated to newer versions, but prefer to use a fixed version of an image. Docker enables you to pull an image by its &lt;em&gt;digest&lt;/em&gt;. When pulling an image by digest, you specify &lt;em&gt;exactly&lt;/em&gt; which version of an image to pull. Doing so, allows you to &amp;ldquo;pin&amp;rdquo; an image to that version, and guarantee that the image you&amp;rsquo;re using is always the same.</source>
          <target state="translated">在某些情况下，您不希望将图像更新为较新的版本，而是希望使用图像的固定版本。Docker使您能够按其&lt;em&gt;摘要&lt;/em&gt;提取映像。通过摘要提取图像时，您可以&lt;em&gt;精确&lt;/em&gt;指定要提取的图像版本。这样，您可以将图像&amp;ldquo;固定&amp;rdquo;到该版本，并确保所使用的图像始终相同。</target>
        </trans-unit>
        <trans-unit id="ee8d00b4d900b019b2c21facfb3122b1408652f0" translate="yes" xml:space="preserve">
          <source>In terms of Docker Swarm services, a &lt;em&gt;secret&lt;/em&gt; is a blob of data, such as a password, SSH private key, SSL certificate, or another piece of data that should not be transmitted over a network or stored unencrypted in a Dockerfile or in your application&amp;rsquo;s source code. In Docker 1.13 and higher, you can use Docker &lt;em&gt;secrets&lt;/em&gt; to centrally manage this data and securely transmit it to only those containers that need access to it. Secrets are encrypted during transit and at rest in a Docker swarm. A given secret is only accessible to those services which have been granted explicit access to it, and only while those service tasks are running.</source>
          <target state="translated">就Docker Swarm服务而言，&lt;em&gt;秘密&lt;/em&gt;是一堆数据，例如密码，SSH私钥，SSL证书或其他不应通过网络传输或未经加密存储在Dockerfile或应用程序的数据中的数据源代码。在Docker 1.13和更高版本中，您可以使用Docker &lt;em&gt;机密&lt;/em&gt;来集中管理此数据并将其安全地传输到仅需要访问它们的那些容器。秘密在传输过程中以及在Docker群中处于静止状态时都进行了加密。给定的秘密仅对那些已被授予显式访问权限的服务可访问，并且仅在那些服务任务正在运行时才可访问。</target>
        </trans-unit>
        <trans-unit id="507226952435217d9ad5503d958728b43e56de30" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;../compose-versioning/index#version-1&quot;&gt;version 1 file format&lt;/a&gt;, &lt;code&gt;dockerfile&lt;/code&gt; is different from newer versions in two ways:</source>
          <target state="translated">在&lt;a href=&quot;../compose-versioning/index#version-1&quot;&gt;版本1文件格式中&lt;/a&gt;， &lt;code&gt;dockerfile&lt;/code&gt; 与新版本在以下两个方面有所不同：</target>
        </trans-unit>
        <trans-unit id="617c4d86c7c6707dcb58c380e63ae534c6469e0f" translate="yes" xml:space="preserve">
          <source>In the &lt;em&gt;shell&lt;/em&gt; form you can use a &lt;code&gt;\&lt;/code&gt; (backslash) to continue a single RUN instruction onto the next line. For example, consider these two lines:</source>
          <target state="translated">在&lt;em&gt;shell&lt;/em&gt;形式中，可以使用 &lt;code&gt;\&lt;/code&gt; （反斜杠）将一条RUN指令继续到下一行。例如，考虑以下两行：</target>
        </trans-unit>
        <trans-unit id="6e1cd2a54fc03f9bec9112614a8823eae429f7cf" translate="yes" xml:space="preserve">
          <source>In the &lt;strong&gt;replicated services&lt;/strong&gt; model, the swarm manager distributes a specific number of replica tasks among the nodes based upon the scale you set in the desired state.</source>
          <target state="translated">在&lt;strong&gt;复制服务&lt;/strong&gt;模型中，群集管理器根据您设置为所需状态的规模在节点之间分配特定数量的副本任务。</target>
        </trans-unit>
        <trans-unit id="86d260fe838f26c03b73ffb1cd6384d7745e98e0" translate="yes" xml:space="preserve">
          <source>In the above example, Compose waits for the &lt;code&gt;redis&lt;/code&gt; service to be started (legacy behavior) and the &lt;code&gt;db&lt;/code&gt; service to be healthy before starting &lt;code&gt;web&lt;/code&gt;.</source>
          <target state="translated">在上面的示例中，Compose 在启动 &lt;code&gt;web&lt;/code&gt; 之前等待 &lt;code&gt;redis&lt;/code&gt; 服务启动（旧行为）并且 &lt;code&gt;db&lt;/code&gt; 服务运行正常。</target>
        </trans-unit>
        <trans-unit id="8630f97bf74475504907a6046ff76d49b8663460" translate="yes" xml:space="preserve">
          <source>In the above example, you can see &lt;code&gt;profile=/usr/bin/docker&lt;/code&gt;. This means the user has the &lt;code&gt;docker-engine&lt;/code&gt; (Docker Engine Daemon) profile loaded.</source>
          <target state="translated">在上面的示例中，您可以看到 &lt;code&gt;profile=/usr/bin/docker&lt;/code&gt; 。这意味着用户已加载了 &lt;code&gt;docker-engine&lt;/code&gt; （Docker Engine Daemon）配置文件。</target>
        </trans-unit>
        <trans-unit id="d1388cf0b4c63993bf69879f326b2f346a2c870c" translate="yes" xml:space="preserve">
          <source>In the absence of having named volumes with specified sources, Docker creates an anonymous volume for each task backing a service. Anonymous volumes do not persist after the associated containers are removed.</source>
          <target state="translated">在没有指定来源的命名卷的情况下,Docker会为每个支持服务的任务创建一个匿名卷。在相关的容器被移除后,匿名卷不会持续存在。</target>
        </trans-unit>
        <trans-unit id="f3666264801bda2584f25182aad55b37381fde40" translate="yes" xml:space="preserve">
          <source>In the case of &lt;code&gt;build&lt;/code&gt; and &lt;code&gt;image&lt;/code&gt;, when using &lt;a href=&quot;../compose-file/compose-file-v1/index&quot;&gt;version 1 of the Compose file format&lt;/a&gt;, using one option in the local service causes Compose to discard the other option if it was defined in the original service.</source>
          <target state="translated">对于 &lt;code&gt;build&lt;/code&gt; 和 &lt;code&gt;image&lt;/code&gt; 而言，当使用&lt;a href=&quot;../compose-file/compose-file-v1/index&quot;&gt;Compose文件格式的版本1&lt;/a&gt;时，如果本地服务中定义了另一个选项，则在本地服务中使用一个选项会使Compose放弃另一个选项。</target>
        </trans-unit>
        <trans-unit id="3c908a9bc6e29241e4f6989c0dbca5cc7172d063" translate="yes" xml:space="preserve">
          <source>In the case of &lt;code&gt;environment&lt;/code&gt;, &lt;code&gt;labels&lt;/code&gt;, &lt;code&gt;volumes&lt;/code&gt;, and &lt;code&gt;devices&lt;/code&gt;, Compose &amp;ldquo;merges&amp;rdquo; entries together with locally-defined values taking precedence. For &lt;code&gt;environment&lt;/code&gt; and &lt;code&gt;labels&lt;/code&gt;, the environment variable or label name determines which value is used:</source>
          <target state="translated">对于 &lt;code&gt;environment&lt;/code&gt; ， &lt;code&gt;labels&lt;/code&gt; ， &lt;code&gt;volumes&lt;/code&gt; 和 &lt;code&gt;devices&lt;/code&gt; ，将&amp;ldquo;合并&amp;rdquo;条目与本地定义的值优先。对于 &lt;code&gt;environment&lt;/code&gt; 和 &lt;code&gt;labels&lt;/code&gt; ，环境变量或标签名称确定使用哪个值：</target>
        </trans-unit>
        <trans-unit id="056d637af8dd63924b6d7ac728a513f46ff71c60" translate="yes" xml:space="preserve">
          <source>In the case of a swarm with auto-lock enabled, the unlock key is also the same as on the old swarm, and the unlock key is needed to restore the swarm.</source>
          <target state="translated">如果是启用了自动锁定的蜂群,解锁键也是和老蜂群上的一样,恢复蜂群需要解锁键。</target>
        </trans-unit>
        <trans-unit id="7fc0bdad15628feea9a6df5058ced71dea1df4a5" translate="yes" xml:space="preserve">
          <source>In the case of transferring files from machine to machine, they go through the local host&amp;rsquo;s filesystem first (using &lt;code&gt;scp&lt;/code&gt;&amp;rsquo;s &lt;code&gt;-3&lt;/code&gt; flag).</source>
          <target state="translated">如果要在计算机之间传输文件，它们首先要经过本地主机的文件系统（使用 &lt;code&gt;scp&lt;/code&gt; 的 &lt;code&gt;-3&lt;/code&gt; 标志）。</target>
        </trans-unit>
        <trans-unit id="dca635a5cd29a93950b84c34f242179e70411fcd" translate="yes" xml:space="preserve">
          <source>In the case that the timestamp has expired, Notary server would go through the entire sequence where it generates a new timestamp, request Notary signer for a signature, stores the newly signed timestamp in the database. It then sends this new timestamp, along with the rest of the stored metadata, to the requesting client.</source>
          <target state="translated">如果时间戳已经过期,公证服务器将经历整个过程,生成一个新的时间戳,请公证签字人签字,将新签署的时间戳存储在数据库中。然后,它将这个新的时间戳和其他存储的元数据一起发送给请求的客户。</target>
        </trans-unit>
        <trans-unit id="e8faee6b24d09276001dcffa82ee5fbc5a5e07c5" translate="yes" xml:space="preserve">
          <source>In the case where &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; is a remote file URL, the destination will have permissions of 600. If the remote file being retrieved has an HTTP &lt;code&gt;Last-Modified&lt;/code&gt; header, the timestamp from that header will be used to set the &lt;code&gt;mtime&lt;/code&gt; on the destination file. However, like any other file processed during an &lt;code&gt;ADD&lt;/code&gt;, &lt;code&gt;mtime&lt;/code&gt; will not be included in the determination of whether or not the file has changed and the cache should be updated.</source>
          <target state="translated">在 &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; 是远程文件URL 的情况下，目标将具有600的权限。如果要检索的远程文件具有HTTP &lt;code&gt;Last-Modified&lt;/code&gt; 头，则该头的时间戳将用于在目标上设置 &lt;code&gt;mtime&lt;/code&gt; 文件。但是，就像在 &lt;code&gt;ADD&lt;/code&gt; 中处理的任何其他文件一样，在确定文件是否已更改以及是否应更新缓存的确定中，将不包括 &lt;code&gt;mtime&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8298e779355193cf9653abc4e5dcf542c129a056" translate="yes" xml:space="preserve">
          <source>In the current directory, create a new file called &lt;code&gt;site.conf&lt;/code&gt; with the following contents:</source>
          <target state="translated">在当前目录中，创建一个包含以下内容的名为 &lt;code&gt;site.conf&lt;/code&gt; 的新文件：</target>
        </trans-unit>
        <trans-unit id="f13078e3c70b9c6c2fe808659a7b8f6d23c16c10" translate="yes" xml:space="preserve">
          <source>In the daemon mode, it only allows connections from clients authenticated by a certificate signed by that CA. In the client mode, it only connects to servers with a certificate signed by that CA.</source>
          <target state="translated">在守护进程模式下,它只允许通过该CA签署的证书认证的客户端进行连接。在客户端模式下,它只连接到拥有该CA签署的证书的服务器。</target>
        </trans-unit>
        <trans-unit id="e79df26f0e1d382e5807005f023a1896be147523" translate="yes" xml:space="preserve">
          <source>In the diagram, a load balancer routes external traffic to a cluster of Notary server instances. These may make requests to Notary signer instances if either a) signing is required, or b) key generation is required. The requests from a Notary server to a Notary signer cluster are router via an internal load balancer.</source>
          <target state="translated">在图中,负载平衡器将外部流量路由到公证服务器实例的集群。如果a)需要签名,或b)需要生成密钥,这些实例可以向公证签名器实例发出请求。从公证服务器到公证签名器集群的请求是通过内部负载平衡器进行路由的。</target>
        </trans-unit>
        <trans-unit id="203428b275a1dd679990a617c7094b310a197f02" translate="yes" xml:space="preserve">
          <source>In the event of a Notary server compromise, an attacker would have direct access to the metadata stored in the database as well as access to the credentials used to communicate with Notary signer, and therefore, access to arbitrary signing operations with any key the Signer holds.</source>
          <target state="translated">如果公证服务器被入侵,攻击者将可以直接访问数据库中存储的元数据,以及访问用于与公证签名者通信的凭证,因此,可以使用签名者持有的任何密钥进行任意签名操作。</target>
        </trans-unit>
        <trans-unit id="584928d6a70946abedcb4d46cd0ca87b63ecd8f7" translate="yes" xml:space="preserve">
          <source>In the event of a Notary signer compromise, an attacker would have access to all the (timestamp and snapshot) private keys stored in a database. If the keys are stored in an HSM, they would have the ability to sign arbitrary content with, and to delete, the keys in the HSM, but not to exfiltrate the private material.</source>
          <target state="translated">如果公证签字人失密,攻击者将能够获得数据库中存储的所有(时间戳和快照)私人钥匙。如果钥匙储存在健康管理机制中,他们将有能力用健康管理机制中的钥匙签署任意内容,并将其删除,但不能渗出私人材料。</target>
        </trans-unit>
        <trans-unit id="ae477ddd4679f740376181461aeaf86fba22dc34" translate="yes" xml:space="preserve">
          <source>In the event that a cluster CA key or a manager node is compromised, you can rotate the swarm root CA so that none of the nodes trust certificates signed by the old root CA anymore.</source>
          <target state="translated">在群集CA密钥或管理器节点被泄露的情况下,可以轮换群集根CA,让所有节点都不再信任旧根CA签署的证书。</target>
        </trans-unit>
        <trans-unit id="9db1d9b06548381c6b977604d97c79541ef06739" translate="yes" xml:space="preserve">
          <source>In the example above, the first element of the list is the address of your DNS server. The second item is Google&amp;rsquo;s DNS which can be used when the first one is not available.</source>
          <target state="translated">在上面的示例中，列表的第一个元素是您的DNS服务器的地址。第二项是Google的DNS，当第一项不可用时可以使用。</target>
        </trans-unit>
        <trans-unit id="147494a044cf1de1427dc854afcb1df23af2a787" translate="yes" xml:space="preserve">
          <source>In the example below, &lt;code&gt;proxy&lt;/code&gt; is the gateway to the outside world. Instead of attempting to create a network called &lt;code&gt;[projectname]_outside&lt;/code&gt;, Compose looks for an existing network simply called &lt;code&gt;outside&lt;/code&gt; and connect the &lt;code&gt;proxy&lt;/code&gt; service&amp;rsquo;s containers to it.</source>
          <target state="translated">在下面的示例中， &lt;code&gt;proxy&lt;/code&gt; 是通往外部世界的门户。Compose 不会尝试创建一个名为 &lt;code&gt;[projectname]_outside&lt;/code&gt; 的网络，而是寻找一个简单地称为 &lt;code&gt;outside&lt;/code&gt; 的现有网络，并将 &lt;code&gt;proxy&lt;/code&gt; 服务的容器连接到该网络。</target>
        </trans-unit>
        <trans-unit id="6a170437927d9d5f3bae3654145156920ae00944" translate="yes" xml:space="preserve">
          <source>In the example below, instead of attempting to create a volume called &lt;code&gt;[projectname]_data&lt;/code&gt;, Compose looks for an existing volume simply called &lt;code&gt;data&lt;/code&gt; and mount it into the &lt;code&gt;db&lt;/code&gt; service&amp;rsquo;s containers.</source>
          <target state="translated">在下面的示例中，Compose 不会尝试创建一个名为 &lt;code&gt;[projectname]_data&lt;/code&gt; 的卷，而是查找一个简单的名为 &lt;code&gt;data&lt;/code&gt; 的现有卷，并将其装入 &lt;code&gt;db&lt;/code&gt; 服务的容器中。</target>
        </trans-unit>
        <trans-unit id="f311f13a2361ce02003febab38bddb325d7b6618" translate="yes" xml:space="preserve">
          <source>In the example below, three services are provided (&lt;code&gt;web&lt;/code&gt;, &lt;code&gt;worker&lt;/code&gt;, and &lt;code&gt;db&lt;/code&gt;), along with two networks (&lt;code&gt;new&lt;/code&gt; and &lt;code&gt;legacy&lt;/code&gt;). The &lt;code&gt;db&lt;/code&gt; service is reachable at the hostname &lt;code&gt;db&lt;/code&gt; or &lt;code&gt;database&lt;/code&gt; on the &lt;code&gt;new&lt;/code&gt; network, and at &lt;code&gt;db&lt;/code&gt; or &lt;code&gt;mysql&lt;/code&gt; on the &lt;code&gt;legacy&lt;/code&gt; network.</source>
          <target state="translated">在下面的示例中，提供了三个服务（ &lt;code&gt;web&lt;/code&gt; ， &lt;code&gt;worker&lt;/code&gt; 和 &lt;code&gt;db&lt;/code&gt; ）以及两个网络（ &lt;code&gt;new&lt;/code&gt; 和 &lt;code&gt;legacy&lt;/code&gt; ）。该 &lt;code&gt;db&lt;/code&gt; 服务是在主机可达 &lt;code&gt;db&lt;/code&gt; 或 &lt;code&gt;database&lt;/code&gt; 上的 &lt;code&gt;new&lt;/code&gt; 网络，并在 &lt;code&gt;db&lt;/code&gt; 或 &lt;code&gt;mysql&lt;/code&gt; 上 &lt;code&gt;legacy&lt;/code&gt; 网络。</target>
        </trans-unit>
        <trans-unit id="d32dda3d107bb1d450698a419c41f95e8b7cbb8f" translate="yes" xml:space="preserve">
          <source>In the example below, we set the same environment variable on an Environment file, and the Compose file:</source>
          <target state="translated">在下面的例子中,我们在环境文件和编译文件上设置相同的环境变量。</target>
        </trans-unit>
        <trans-unit id="c38d3675cdf10575b32c2936885a42e5a7571c4f" translate="yes" xml:space="preserve">
          <source>In the example service below, the scheduler applies updates to a maximum of 2 replicas at a time. When an updated task returns either &lt;code&gt;RUNNING&lt;/code&gt; or &lt;code&gt;FAILED&lt;/code&gt;, the scheduler waits 10 seconds before stopping the next task to update:</source>
          <target state="translated">在下面的示例服务中，调度程序一次将更新应用于最多2个副本。当更新的任务返回 &lt;code&gt;RUNNING&lt;/code&gt; 或 &lt;code&gt;FAILED&lt;/code&gt; 时，调度程序将等待10秒，然后再停止下一个任务进行更新：</target>
        </trans-unit>
        <trans-unit id="2078037af746f3b5511d54697e143b860fb9ed4b" translate="yes" xml:space="preserve">
          <source>In the following example the desired state is &lt;code&gt;5&lt;/code&gt; replicas, but the current number of &lt;code&gt;RUNNING&lt;/code&gt; tasks is &lt;code&gt;3&lt;/code&gt;:</source>
          <target state="translated">在以下示例中，所需状态为 &lt;code&gt;5&lt;/code&gt; 个副本，但是 &lt;code&gt;RUNNING&lt;/code&gt; 任务的当前数量为 &lt;code&gt;3&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a844e667f5555543f0a22ea7cde32ed9a981daa9" translate="yes" xml:space="preserve">
          <source>In the following example, the &lt;code&gt;app&lt;/code&gt; service connects to &lt;code&gt;app_net_1&lt;/code&gt; first as it has the highest priority. It then connects to &lt;code&gt;app_net_3&lt;/code&gt;, then &lt;code&gt;app_net_2&lt;/code&gt;, which uses the default priority value of &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">在以下示例中，由于 &lt;code&gt;app&lt;/code&gt; 服务具有最高优先级，因此它首先连接到 &lt;code&gt;app_net_1&lt;/code&gt; 。然后它连接到 &lt;code&gt;app_net_3&lt;/code&gt; ，然后 &lt;code&gt;app_net_2&lt;/code&gt; ，它使用的默认优先级值为 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9fdc0122add53ba9a33cbc1a5aa0321850cb0dcd" translate="yes" xml:space="preserve">
          <source>In the following example, you install the &lt;code&gt;sshfs&lt;/code&gt; plugin, verify that it is enabled, and use it to create a volume.</source>
          <target state="translated">在以下示例中，您将安装 &lt;code&gt;sshfs&lt;/code&gt; 插件，确认已启用它，然后使用它来创建卷。</target>
        </trans-unit>
        <trans-unit id="13d30425c671944d6f19dd2632c40dd1bc5f88aa" translate="yes" xml:space="preserve">
          <source>In the majority of cases, moving from version 1 to 2 is a very simple process:</source>
          <target state="translated">在大多数情况下,从1版到2版是一个非常简单的过程。</target>
        </trans-unit>
        <trans-unit id="76ef7b93da79d41a3b4613504221f85f964bb68d" translate="yes" xml:space="preserve">
          <source>In the next section of the tutorial, we &lt;a href=&quot;../add-nodes/index&quot;&gt;add two more nodes&lt;/a&gt; to the cluster.</source>
          <target state="translated">在本教程的下一部分中，我们&lt;a href=&quot;../add-nodes/index&quot;&gt;将另外两个节点添加&lt;/a&gt;到集群中。</target>
        </trans-unit>
        <trans-unit id="10e97313f58911e0d3ece76845a49a34aae95c4e" translate="yes" xml:space="preserve">
          <source>In the next step of the tutorial, you set up a new service and apply a &lt;a href=&quot;../rolling-update/index&quot;&gt;rolling update&lt;/a&gt;.</source>
          <target state="translated">在本教程的下一步中，您将设置一个新服务并应用&lt;a href=&quot;../rolling-update/index&quot;&gt;滚动更新&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e04dbff675eb7be8581333ad553b4879f552834f" translate="yes" xml:space="preserve">
          <source>In the past, if you were to start writing a Python app, your first order of business was to install a Python runtime onto your machine. But, that creates a situation where the environment on your machine needs to be perfect for your app to run as expected, and also needs to match your production environment.</source>
          <target state="translated">在过去,如果你要开始编写一个Python应用,你的首要任务是在你的机器上安装一个Python运行时。但是,这就造成了一种情况,即你的机器上的环境需要完美,才能让你的应用按预期运行,而且还需要与你的生产环境相匹配。</target>
        </trans-unit>
        <trans-unit id="df0651f4ce318c2881695ad1dbdea4f39debd34f" translate="yes" xml:space="preserve">
          <source>In the preceding example, the output message indicates that only the removal was staged. When performing any write operations they are staged into a change list. This list is applied to the latest version of the trust repository the next time a &lt;code&gt;notary publish&lt;/code&gt; is run for that repository.</source>
          <target state="translated">在前面的示例中，输出消息指示仅进行了删除。执行任何写操作时，它们都将进入更改列表。下次为该存储库运行 &lt;code&gt;notary publish&lt;/code&gt; 时，此列表将应用于该信任库的最新版本。</target>
        </trans-unit>
        <trans-unit id="6baf9022b9d9af166711c3e20e9108f81d24bf1d" translate="yes" xml:space="preserve">
          <source>In the preceding example, you add the target &lt;code&gt;delegation/path/target&lt;/code&gt; to collection &lt;code&gt;example/collections&lt;/code&gt; staged for next publish. The file &lt;code&gt;delegation_file.txt&lt;/code&gt; is a target &lt;code&gt;delegation/path/target&lt;/code&gt; using the delegation role &lt;code&gt;targets/releases&lt;/code&gt;. This target&amp;rsquo;s path is valid because it is prefixed by the delegation role&amp;rsquo;s valid path.</source>
          <target state="translated">在前面的示例中，您将目标 &lt;code&gt;delegation/path/target&lt;/code&gt; 到为下一次发布而上演的集合 &lt;code&gt;example/collections&lt;/code&gt; 。文件 &lt;code&gt;delegation_file.txt&lt;/code&gt; 是使用委托角色 &lt;code&gt;targets/releases&lt;/code&gt; 的目标 &lt;code&gt;delegation/path/target&lt;/code&gt; 。该目标的路径是有效的，因为它以委托角色的有效路径为前缀。</target>
        </trans-unit>
        <trans-unit id="2855fcdbca29020ccdc5f7418ce34b4a2e312c8b" translate="yes" xml:space="preserve">
          <source>In the same way that you can use &lt;a href=&quot;../../../compose/index&quot;&gt;Docker Compose&lt;/a&gt; to define and run containers, you can define and run swarm service &lt;a href=&quot;../../../get-started/part5/index&quot;&gt;stacks&lt;/a&gt;.</source>
          <target state="translated">与可以使用&lt;a href=&quot;../../../compose/index&quot;&gt;Docker Compose&lt;/a&gt;定义和运行容器的方式相同，可以定义和运行swarm服务&lt;a href=&quot;../../../get-started/part5/index&quot;&gt;堆栈&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="351aa025091a0cdcd01e6ea8bd674f7fd1f9a939" translate="yes" xml:space="preserve">
          <source>In the tutorial, the following command creates a swarm on the &lt;code&gt;manager1&lt;/code&gt; machine:</source>
          <target state="translated">在本教程中，以下命令在 &lt;code&gt;manager1&lt;/code&gt; 机器上创建一个群：</target>
        </trans-unit>
        <trans-unit id="cbd3501137e7a8a17b04eeebf7fb1330cdbb79c2" translate="yes" xml:space="preserve">
          <source>In this case the swarm manager distributed one task to each node. You may see the tasks distributed differently among the nodes in your environment.</source>
          <target state="translated">在这种情况下,蜂群管理器将一个任务分配给每个节点。您可能会看到任务在环境中的节点之间以不同的方式分布。</target>
        </trans-unit>
        <trans-unit id="885671909abfab36e907973d71986da7b3a89fc5" translate="yes" xml:space="preserve">
          <source>In this case, if you use &lt;code&gt;-P&lt;/code&gt; with &lt;code&gt;docker run&lt;/code&gt;, the port will be exposed once for TCP and once for UDP. Remember that &lt;code&gt;-P&lt;/code&gt; uses an ephemeral high-ordered host port on the host, so the port will not be the same for TCP and UDP.</source>
          <target state="translated">在这种情况下，如果将 &lt;code&gt;-P&lt;/code&gt; 与 &lt;code&gt;docker run&lt;/code&gt; 结合使用，则该端口仅对 TCP公开一次，对于UDP公开一次。请记住， &lt;code&gt;-P&lt;/code&gt; 在主机上使用临时的高阶主机端口，因此该端口对于TCP和UDP将是不同的。</target>
        </trans-unit>
        <trans-unit id="681476db3d02fb5fb9004193c3422e6779b3f23f" translate="yes" xml:space="preserve">
          <source>In this case, port 8080 must be open between the load balancer and the nodes in the swarm. The swarm nodes can reside on a private network that is accessible to the proxy server, but that is not publicly accessible.</source>
          <target state="translated">在这种情况下,负载均衡器和蜂群中的节点之间必须打开8080端口。群节点可以驻留在可以访问代理服务器的私有网络上,但不是公开访问的。</target>
        </trans-unit>
        <trans-unit id="d4bce5c124cacb5eabda1e12fb3fbc378c4803ef" translate="yes" xml:space="preserve">
          <source>In this case, the &lt;code&gt;RUN&lt;/code&gt; instruction uses &lt;code&gt;v1.0.0&lt;/code&gt; instead of the &lt;code&gt;ARG&lt;/code&gt; setting passed by the user:&lt;code&gt;v2.0.1&lt;/code&gt; This behavior is similar to a shell script where a locally scoped variable overrides the variables passed as arguments or inherited from environment, from its point of definition.</source>
          <target state="translated">在这种情况下， &lt;code&gt;RUN&lt;/code&gt; 指令将使用 &lt;code&gt;v1.0.0&lt;/code&gt; 而不是用户传递的 &lt;code&gt;ARG&lt;/code&gt; 设置： &lt;code&gt;v2.0.1&lt;/code&gt; 此行为类似于shell脚本，其中局部作用域的变量会覆盖从其传递来的作为参数或从环境继承的变量。定义点。</target>
        </trans-unit>
        <trans-unit id="04b8f8d7e71a2768e939aebb67d5d123e9d6b5a4" translate="yes" xml:space="preserve">
          <source>In this case, the one instance of the &lt;code&gt;helloworld&lt;/code&gt; service is running on the &lt;code&gt;worker2&lt;/code&gt; node. You may see the service running on your manager node. By default, manager nodes in a swarm can execute tasks just like worker nodes.</source>
          <target state="translated">在这种情况下， &lt;code&gt;helloworld&lt;/code&gt; 服务的一个实例在 &lt;code&gt;worker2&lt;/code&gt; 节点上运行。您可能会看到该服务正在您的管理器节点上运行。默认情况下，集群中的管理器节点可以像工作程序节点一样执行任务。</target>
        </trans-unit>
        <trans-unit id="b042a5859ac6aa3fc44a52b490ab31dabfbe8b7f" translate="yes" xml:space="preserve">
          <source>In this case, the value of the &lt;code&gt;HTTP_PROXY&lt;/code&gt; variable is not available in the &lt;code&gt;docker history&lt;/code&gt; and is not cached. If you were to change location, and your proxy server changed to &lt;code&gt;http://user:pass@proxy.sfo.example.com&lt;/code&gt;, a subsequent build does not result in a cache miss.</source>
          <target state="translated">在这种情况下， &lt;code&gt;HTTP_PROXY&lt;/code&gt; 变量的值在docker &lt;code&gt;docker history&lt;/code&gt; 不可用，也不被缓存。如果要更改位置，并且代理服务器已更改为 &lt;code&gt;http://user:pass@proxy.sfo.example.com&lt;/code&gt; ，则后续的构建不会导致高速缓存未命中。</target>
        </trans-unit>
        <trans-unit id="63a41cf88ca98b159f7ae72d0d8e89186d2f2533" translate="yes" xml:space="preserve">
          <source>In this case, you get exactly the same result as if you wrote &lt;code&gt;docker-compose.yml&lt;/code&gt; with the same &lt;code&gt;build&lt;/code&gt;, &lt;code&gt;ports&lt;/code&gt; and &lt;code&gt;volumes&lt;/code&gt; configuration values defined directly under &lt;code&gt;web&lt;/code&gt;.</source>
          <target state="translated">在这种情况下，您将获得与使用直接在 &lt;code&gt;web&lt;/code&gt; 下定义的相同 &lt;code&gt;build&lt;/code&gt; ， &lt;code&gt;ports&lt;/code&gt; 和 &lt;code&gt;volumes&lt;/code&gt; 配置值编写 &lt;code&gt;docker-compose.yml&lt;/code&gt; 完全相同的结果。</target>
        </trans-unit>
        <trans-unit id="1bf4fa7b247577339bd1aa1ea3fcf49ef5e5ef69" translate="yes" xml:space="preserve">
          <source>In this example the development configuration exposes some ports to the host, mounts our code as a volume, and builds the web image.</source>
          <target state="translated">在这个例子中,开发配置将一些端口暴露给主机,将我们的代码挂载为一个卷,并构建Web镜像。</target>
        </trans-unit>
        <trans-unit id="77f7cabb1f5d68f67a48a2498e604f9ab8a5b519" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;docker network create -d overlay net1&lt;/code&gt; will result in &lt;code&gt;10.20.0.0/26&lt;/code&gt; as the allocated subnet for &lt;code&gt;net1&lt;/code&gt;, and &lt;code&gt;docker network create -d overlay net2&lt;/code&gt; will result in &lt;code&gt;10.20.0.64/26&lt;/code&gt; as the allocated subnet for &lt;code&gt;net2&lt;/code&gt;. This continues until all the subnets are exhausted.</source>
          <target state="translated">在这个例子中， &lt;code&gt;docker network create -d overlay net1&lt;/code&gt; 将导致 &lt;code&gt;10.20.0.0/26&lt;/code&gt; 作为分配子网 &lt;code&gt;net1&lt;/code&gt; ，和 &lt;code&gt;docker network create -d overlay net2&lt;/code&gt; 将导致 &lt;code&gt;10.20.0.64/26&lt;/code&gt; 作为分配子网 &lt;code&gt;net2&lt;/code&gt; 。这一直持续到所有子网都用尽为止。</target>
        </trans-unit>
        <trans-unit id="1a7aa9b0581ea4db874d745eaac8bdb2d12de04e" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;my_first_config&lt;/code&gt; is created (as &lt;code&gt;&amp;lt;stack_name&amp;gt;_my_first_config)&lt;/code&gt;when the stack is deployed, and &lt;code&gt;my_second_config&lt;/code&gt; already exists in Docker.</source>
          <target state="translated">在此示例中，部署堆栈时创建了 &lt;code&gt;my_first_config&lt;/code&gt; （作为 &lt;code&gt;&amp;lt;stack_name&amp;gt;_my_first_config)&lt;/code&gt; ，并且 &lt;code&gt;my_second_config&lt;/code&gt; 已经存在my_second_config。</target>
        </trans-unit>
        <trans-unit id="c6e46cc9d2790dae9bf0dce4483be5182c8915a6" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;my_first_secret&lt;/code&gt; is created as &lt;code&gt;&amp;lt;stack_name&amp;gt;_my_first_secret&lt;/code&gt;when the stack is deployed, and &lt;code&gt;my_second_secret&lt;/code&gt; already exists in Docker.</source>
          <target state="translated">在此示例中，部署堆栈时， &lt;code&gt;my_first_secret&lt;/code&gt; 创建为 &lt;code&gt;&amp;lt;stack_name&amp;gt;_my_first_secret&lt;/code&gt; ，并且 &lt;code&gt;my_second_secret&lt;/code&gt; 已经存在my_second_secret。</target>
        </trans-unit>
        <trans-unit id="3eace086f1ca89f50b54dac824927afa2f9323f2" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;redis&lt;/code&gt; is the hostname of the redis container on the application&amp;rsquo;s network. We use the default port for Redis, &lt;code&gt;6379&lt;/code&gt;.</source>
          <target state="translated">在此示例中， &lt;code&gt;redis&lt;/code&gt; 是应用程序网络上的redis容器的主机名。我们为Redis使用默认端口 &lt;code&gt;6379&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a64f4b6a3a18589a29af7aac8d8c901a16324a7b" translate="yes" xml:space="preserve">
          <source>In this example, no machines have been created yet.</source>
          <target state="translated">在这个例子中,还没有创建任何机器。</target>
        </trans-unit>
        <trans-unit id="16c0e88b2ca9ba5b32edd4b9a8e590e8219b6624" translate="yes" xml:space="preserve">
          <source>In this example, no name (&lt;code&gt;source&lt;/code&gt;) is specified for the volume, so a new volume is created for each task. This guarantees that each task gets its own volume, and volumes are not shared between tasks. Anonymous volumes are removed after the task using them is complete.</source>
          <target state="translated">在此示例中，未为卷指定名称（ &lt;code&gt;source&lt;/code&gt; ），因此将为每个任务创建一个新卷。这样可以确保每个任务都有自己的卷，并且不会在任务之间共享卷。使用匿名卷的任务完成后，将删除它们。</target>
        </trans-unit>
        <trans-unit id="1ae7aee7afc304948b7f799a25e01d795de66f10" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;--force&lt;/code&gt; flag causes the service&amp;rsquo;s tasks to be shut down and replaced with new ones even though none of the other parameters would normally cause that to happen. The &lt;code&gt;--update-parallelism 1&lt;/code&gt; setting ensures that only one task is replaced at a time (this is the default behavior). The &lt;code&gt;--update-delay 30s&lt;/code&gt; setting introduces a 30 second delay between tasks, so that the rolling restart happens gradually.</source>
          <target state="translated">在此示例中，-- &lt;code&gt;--force&lt;/code&gt; 标志导致服务的任务被关闭并用新任务代替，即使其他参数通常不会导致该任务发生也是如此。该 &lt;code&gt;--update-parallelism 1&lt;/code&gt; ，只有一个任务被替换在时间设置确保了（这是默认行为）。所述 &lt;code&gt;--update-delay 30s&lt;/code&gt; 设定介绍任务之间有30秒的延迟，从而使滚动重启逐渐发生。</target>
        </trans-unit>
        <trans-unit id="4a2aae167f8906f5c5dd31f4d7a7a1e24832b8cc" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;-p&lt;/code&gt; option is used to expose port 80 from the &lt;code&gt;nginx&lt;/code&gt; container and make it accessible on port &lt;code&gt;8000&lt;/code&gt; of the &lt;code&gt;aws-sandbox&lt;/code&gt; host:</source>
          <target state="translated">在此示例中， &lt;code&gt;-p&lt;/code&gt; 选项用于从 &lt;code&gt;nginx&lt;/code&gt; 容器公开端口80，并使其在 &lt;code&gt;aws-sandbox&lt;/code&gt; 主机的端口 &lt;code&gt;8000&lt;/code&gt; 上可访问：</target>
        </trans-unit>
        <trans-unit id="fb10920162c6d6f5c2df646d27ac2d85f3e91a9d" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;-p&lt;/code&gt; option is used to expose port 80 from the &lt;code&gt;nginx&lt;/code&gt; container and make it accessible on port &lt;code&gt;8000&lt;/code&gt; of the &lt;code&gt;docker-sandbox&lt;/code&gt; host.</source>
          <target state="translated">在此示例中， &lt;code&gt;-p&lt;/code&gt; 选项用于从 &lt;code&gt;nginx&lt;/code&gt; 容器公开端口80，并使其在 &lt;code&gt;docker-sandbox&lt;/code&gt; 主机的端口 &lt;code&gt;8000&lt;/code&gt; 上可访问。</target>
        </trans-unit>
        <trans-unit id="7a2f6aee03314df6720abb574ea68b1288eba9be" translate="yes" xml:space="preserve">
          <source>In this example, the cache miss occurs on line 3. The miss happens because the variable&amp;rsquo;s value in the &lt;code&gt;ENV&lt;/code&gt; references the &lt;code&gt;ARG&lt;/code&gt; variable and that variable is changed through the command line. In this example, the &lt;code&gt;ENV&lt;/code&gt; command causes the image to include the value.</source>
          <target state="translated">在此示例中，高速缓存未命中发生在第3行。之所以发生未命中，是因为 &lt;code&gt;ENV&lt;/code&gt; 中的变量值引用了 &lt;code&gt;ARG&lt;/code&gt; 变量，并且该变量通过命令行进行了更改。在此示例中， &lt;code&gt;ENV&lt;/code&gt; 命令使图像包含该值。</target>
        </trans-unit>
        <trans-unit id="82c0846c089d798f7a73aa56f8e6fd674b771a54" translate="yes" xml:space="preserve">
          <source>In this example, the volume for &lt;code&gt;/foo&lt;/code&gt; will remain intact, but the volume for &lt;code&gt;/bar&lt;/code&gt; will be removed. The same behavior holds for volumes inherited with &lt;code&gt;--volumes-from&lt;/code&gt;.</source>
          <target state="translated">在此示例中， &lt;code&gt;/foo&lt;/code&gt; 的卷将保持不变，但 &lt;code&gt;/bar&lt;/code&gt; 的卷将被删除。对于使用 &lt;code&gt;--volumes-from&lt;/code&gt; 继承的卷，也具有相同的行为。</target>
        </trans-unit>
        <trans-unit id="d9b3a1700297305cec2686aa0056d2242ac4541c" translate="yes" xml:space="preserve">
          <source>In this example, we are going to set the template of the created containers based on the service&amp;rsquo;s name, the node&amp;rsquo;s ID and hostname where it sits.</source>
          <target state="translated">在此示例中，我们将基于服务的名称，节点的ID和它所在的主机名来设置创建的容器的模板。</target>
        </trans-unit>
        <trans-unit id="793f6048a0a8601a7988fbea6a9c962d11ef9005" translate="yes" xml:space="preserve">
          <source>In this example, with the &lt;code&gt;0.1&lt;/code&gt; value, it returns an empty set because no matches were found.</source>
          <target state="translated">在此示例中，值为 &lt;code&gt;0.1&lt;/code&gt; ，由于未找到匹配项，因此返回空集。</target>
        </trans-unit>
        <trans-unit id="4751cc96481650529711b0f850cbb1809a65d7d7" translate="yes" xml:space="preserve">
          <source>In this example, you create a custom AppArmor profile for Nginx. Below is the custom profile.</source>
          <target state="translated">在这个例子中,您为Nginx创建了一个自定义的AppArmor配置文件。下面是自定义的配置文件。</target>
        </trans-unit>
        <trans-unit id="bc9be972bc2f18d8f6311822a2ad04b8986c88dd" translate="yes" xml:space="preserve">
          <source>In this example, you create a single-node MySQL service with a custom root password, add the credentials as secrets, and create a single-node WordPress service which uses these credentials to connect to MySQL. The &lt;a href=&quot;#example-rotate-a-secret&quot;&gt;next example&lt;/a&gt; builds on this one and shows you how to rotate the MySQL password and update the services so that the WordPress service can still connect to MySQL.</source>
          <target state="translated">在此示例中，您将使用自定义根密码创建一个单节点MySQL服务，将凭据添加为密钥，并创建一个使用这些凭据连接到MySQL的单节点WordPress服务。在&lt;a href=&quot;#example-rotate-a-secret&quot;&gt;下面的例子&lt;/a&gt;建立在这一个，你展示了如何旋转的MySQL密码和更新服务，使WordPress的服务仍然可以连接到MySQL。</target>
        </trans-unit>
        <trans-unit id="3b9a1129d761331ffa104c86be232c76a3c51f4b" translate="yes" xml:space="preserve">
          <source>In this general example, the &lt;code&gt;redis&lt;/code&gt; service is constrained to use no more than 50M of memory and &lt;code&gt;0.50&lt;/code&gt; (50% of a single core) of available processing time (CPU), and has &lt;code&gt;20M&lt;/code&gt; of memory and &lt;code&gt;0.25&lt;/code&gt; CPU time reserved (as always available to it).</source>
          <target state="translated">在此一般示例中， &lt;code&gt;redis&lt;/code&gt; 服务被限制为使用不超过50M的内存和 &lt;code&gt;0.50&lt;/code&gt; （单核的50％）的可用处理时间（CPU），并具有 &lt;code&gt;20M&lt;/code&gt; 的内存和 &lt;code&gt;0.25&lt;/code&gt; 的 CPU时间保留（始终可用）对此）。</target>
        </trans-unit>
        <trans-unit id="a3a5041a3a7ff861db8a633ca654e1d84e7d2466" translate="yes" xml:space="preserve">
          <source>In this section, one can provide specific certificates to pin to, or a CA to pin to as a root of trust for a GUN. Multiple sections can be specified, but the pinned certificates take highest priority for validation, followed by the pinned CA, followed by TOFUS (TOFU over HTTPS). The diagram below describes this validation flow:</source>
          <target state="translated">在本节中,可以提供特定的证书,或者提供一个CA作为GUN的信任根。可以指定多个部分,但被钉定的证书在验证中占据最高优先级,其次是被钉定的CA,然后是TOFUS(TOFU over HTTPS)。下图描述了这个验证流程。</target>
        </trans-unit>
        <trans-unit id="6286f7d93adb2f3bde10ad671f8f4aa75697a866" translate="yes" xml:space="preserve">
          <source>In this section, there are two common use cases for multiple Compose files: changing a Compose app for different environments, and running administrative tasks against a Compose app.</source>
          <target state="translated">在本节中,有两个常见的用例可用于多个 Compose 文件:为不同环境更改 Compose 应用程序,以及针对 Compose 应用程序运行管理任务。</target>
        </trans-unit>
        <trans-unit id="08c5147a96cd0e66029e61313e04531ebbd0bcac" translate="yes" xml:space="preserve">
          <source>In this section, you set up the database connection for Django.</source>
          <target state="translated">在本节中,你为Django设置了数据库连接。</target>
        </trans-unit>
        <trans-unit id="04288368cbc60426fb483634cfbec72223e0ed4b" translate="yes" xml:space="preserve">
          <source>In this section, you use Docker Compose to specify how to set up and link together the &lt;code&gt;trustsandbox&lt;/code&gt; container, the Notary server, and the Registry server.</source>
          <target state="translated">在本节中，您将使用Docker Compose来指定如何设置 &lt;code&gt;trustsandbox&lt;/code&gt; 容器，Notary服务器和Registry服务器并将其链接在一起。</target>
        </trans-unit>
        <trans-unit id="e51af388cdc8f97cb8eb1d08de8500fabebf3d20" translate="yes" xml:space="preserve">
          <source>In this step, you create a Django starter project by building the image from the build context defined in the previous procedure.</source>
          <target state="translated">在这一步中,你通过在前面的过程中定义的构建上下文来创建一个Django启动项目。</target>
        </trans-unit>
        <trans-unit id="1e01432f90c228d152d047aa8deff8a52d211dba" translate="yes" xml:space="preserve">
          <source>In this step, you write a Dockerfile that builds a Docker image. The image contains all the dependencies the Python application requires, including Python itself.</source>
          <target state="translated">在这一步中,你写了一个Docker文件,构建了一个Docker镜像。该镜像包含了Python应用所需的所有依赖项,包括Python本身。</target>
        </trans-unit>
        <trans-unit id="aa2627c39d008ec8a874ad931d1e12f5847d198f" translate="yes" xml:space="preserve">
          <source>In your project directory, create a file named &lt;code&gt;Dockerfile&lt;/code&gt; and paste the following:</source>
          <target state="translated">在您的项目目录中，创建一个名为 &lt;code&gt;Dockerfile&lt;/code&gt; 的文件并粘贴以下内容：</target>
        </trans-unit>
        <trans-unit id="4ff77a321aea72381bf2aa35c530b9fe5bf786ac" translate="yes" xml:space="preserve">
          <source>In your project directory, edit the &lt;code&gt;composeexample/settings.py&lt;/code&gt; file.</source>
          <target state="translated">在您的项目目录中，编辑 &lt;code&gt;composeexample/settings.py&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="0d3d7d9b5cd6a9e000ada483c14290e972973924" translate="yes" xml:space="preserve">
          <source>Include pre-release versions</source>
          <target state="translated">包括发布前的版本</target>
        </trans-unit>
        <trans-unit id="dbffe00393d5fb45712267a38682885f997730f5" translate="yes" xml:space="preserve">
          <source>Include the directory in your &lt;code&gt;$fpath&lt;/code&gt; by adding in &lt;code&gt;~/.zshrc&lt;/code&gt;:</source>
          <target state="translated">通过添加 &lt;code&gt;~/.zshrc&lt;/code&gt; &lt;code&gt;$fpath&lt;/code&gt; 将目录包含在$ fpath中：</target>
        </trans-unit>
        <trans-unit id="526ae408d88f0a68705af2b63511a512551d699e" translate="yes" xml:space="preserve">
          <source>Includes popular directories, such as &lt;code&gt;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&lt;/code&gt;</source>
          <target state="translated">包括流行的目录，例如 &lt;code&gt;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a36a5a753eb20e482d351f30a837bf2ea439031c" translate="yes" xml:space="preserve">
          <source>Incrementally transfer only the changed files in your build context between builds</source>
          <target state="translated">在不同的构建过程中,只增加传输您的构建上下文中的更改文件。</target>
        </trans-unit>
        <trans-unit id="226e10a49cccd3956fbf0378651af38c9d5e2ebf" translate="yes" xml:space="preserve">
          <source>Indent the whole file by one level and put a &lt;code&gt;services:&lt;/code&gt; key at the top.</source>
          <target state="translated">将整个文件缩进一级，然后在顶部放一个 &lt;code&gt;services:&lt;/code&gt; 键。</target>
        </trans-unit>
        <trans-unit id="6d4d32e5969562f6d4c8a1697bb643b1ac1305c2" translate="yes" xml:space="preserve">
          <source>Infinit volume plugin</source>
          <target state="translated">Infinit音量插件</target>
        </trans-unit>
        <trans-unit id="d49276b3775ffb7a604de088984bd3eae9e57c9d" translate="yes" xml:space="preserve">
          <source>Initial support for volume driver plugins (&lt;a href=&quot;https://github.com/docker/docker/pull/14659&quot;&gt;#14659&lt;/a&gt;)</source>
          <target state="translated">初步支持卷驱动程序插件（&lt;a href=&quot;https://github.com/docker/docker/pull/14659&quot;&gt;＃14659&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="7a0cca60332565efa82da0830e70af27255cc059" translate="yes" xml:space="preserve">
          <source>Initialize a Trusted Collection</source>
          <target state="translated">初始化一个可信的集合</target>
        </trans-unit>
        <trans-unit id="11f9ae2749773d8e95314483370b6db75fdc2c07" translate="yes" xml:space="preserve">
          <source>Initialize a swarm</source>
          <target state="translated">初始化一个蜂群</target>
        </trans-unit>
        <trans-unit id="7003ecab6ac4d75e2e8f2e1207a6711b17369313" translate="yes" xml:space="preserve">
          <source>Initialize a swarm with autolocking enabled</source>
          <target state="translated">初始化启用自动上锁的蜂群。</target>
        </trans-unit>
        <trans-unit id="28694b0b3d1f03f7cdae70f994ca9ec65708493d" translate="yes" xml:space="preserve">
          <source>Initialize a swarm. The docker engine targeted by this command becomes a manager in the newly created single-node swarm.</source>
          <target state="translated">初始化一个蜂群。该命令所针对的docker引擎成为新创建的单节点群中的管理器。</target>
        </trans-unit>
        <trans-unit id="69b6ef38c3841824a41327527d835ecc412b9040" translate="yes" xml:space="preserve">
          <source>Initialize the swarm and add nodes</source>
          <target state="translated">初始化蜂群并添加节点</target>
        </trans-unit>
        <trans-unit id="4e3946ff12a229a7dec9c0364f2084edab96d933" translate="yes" xml:space="preserve">
          <source>Initialize volumes</source>
          <target state="translated">初始化卷</target>
        </trans-unit>
        <trans-unit id="aa3480029144fc1747d6781da542a6add4fc7d50" translate="yes" xml:space="preserve">
          <source>Initializing a trusted collection generates the following items; all keys use asymmetric algorithms, but there is no requirement that they all use the &lt;em&gt;same&lt;/em&gt; algorithm:</source>
          <target state="translated">初始化可信集合会生成以下项目；所有密钥都使用非对称算法，但不要求它们都使用&lt;em&gt;相同的&lt;/em&gt;算法：</target>
        </trans-unit>
        <trans-unit id="9802ef4d56e81169ff494ba78267ecf92f7d0789" translate="yes" xml:space="preserve">
          <source>Initiate the root CA rotation, but do not wait for the completion of or display the progress of the rotation.</source>
          <target state="translated">启动根CA旋转,但不要等待完成或显示旋转的进度。</target>
        </trans-unit>
        <trans-unit id="6880f6739c9251b402c6f12118b0fd2683a88281" translate="yes" xml:space="preserve">
          <source>Initiating the Repository</source>
          <target state="translated">启动存储库</target>
        </trans-unit>
        <trans-unit id="058a41f21587dc3bb32900367e4fbdff23554533" translate="yes" xml:space="preserve">
          <source>Insecure registries</source>
          <target state="translated">不安全的登记处</target>
        </trans-unit>
        <trans-unit id="e88687dde18003eb75d76a43b01c7e8bcb628535" translate="yes" xml:space="preserve">
          <source>Inside the container, your app is running on the same port as before &lt;code&gt;3000&lt;/code&gt;, but the Rails Welcome is now available on &lt;code&gt;http://localhost:3001&lt;/code&gt; on your local host.</source>
          <target state="translated">在容器内，您的应用程序与 &lt;code&gt;3000&lt;/code&gt; 之前的端口在同一端口上运行，但是Rails Welcome现在在本地主机上的 &lt;code&gt;http://localhost:3001&lt;/code&gt; 上可用。</target>
        </trans-unit>
        <trans-unit id="9b31429992c34dbc1d09f093f9194acb969c032c" translate="yes" xml:space="preserve">
          <source>Inspect a Docker Hub repository</source>
          <target state="translated">检查Docker Hub仓库</target>
        </trans-unit>
        <trans-unit id="a5f1a49ca40c0afe3626936f9aaa51eaa0bfd77c" translate="yes" xml:space="preserve">
          <source>Inspect a context by name</source>
          <target state="translated">按名称检查上下文</target>
        </trans-unit>
        <trans-unit id="fe9b429e13e53fe0d1fa77df1523f9b49fa49ef3" translate="yes" xml:space="preserve">
          <source>Inspect a manifest list</source>
          <target state="translated">检查清单</target>
        </trans-unit>
        <trans-unit id="420079d24950e1155e772c29d34368ce64e8185b" translate="yes" xml:space="preserve">
          <source>Inspect a node</source>
          <target state="translated">检查节点</target>
        </trans-unit>
        <trans-unit id="a0668f170f8bf043fa3f8e9c766b87398953b408" translate="yes" xml:space="preserve">
          <source>Inspect a secret by name or ID</source>
          <target state="translated">按名称或ID检查秘密</target>
        </trans-unit>
        <trans-unit id="c3ab8a02dd78c3e54271f8a625519657b78b5527" translate="yes" xml:space="preserve">
          <source>Inspect a service by name or ID</source>
          <target state="translated">按名称或ID检查服务</target>
        </trans-unit>
        <trans-unit id="b6436533c672d459a45257fe6f8527b608e7ae09" translate="yes" xml:space="preserve">
          <source>Inspect a service on the swarm</source>
          <target state="translated">检查蜂群的服务</target>
        </trans-unit>
        <trans-unit id="4aeb395d6058823adcf371cb704cfc8ea8e3afd5" translate="yes" xml:space="preserve">
          <source>Inspect an image&amp;rsquo;s manifest and get the os/arch info</source>
          <target state="translated">检查图像的清单并获取操作系统/架构信息</target>
        </trans-unit>
        <trans-unit id="2bf9b13b53ebf817fd46cd1d17e521b1d177c23d" translate="yes" xml:space="preserve">
          <source>Inspect an image&amp;rsquo;s manifest object</source>
          <target state="translated">检查图像的清单对象</target>
        </trans-unit>
        <trans-unit id="ad97e28e2e02a6e39501674e8974efa0608b289e" translate="yes" xml:space="preserve">
          <source>Inspect an individual node</source>
          <target state="translated">检查单个节点</target>
        </trans-unit>
        <trans-unit id="8b35d287031689a9f14229de07991819cc2cd921" translate="yes" xml:space="preserve">
          <source>Inspect changes to files or directories on a container&amp;rsquo;s filesystem</source>
          <target state="translated">检查容器文件系统上文件或目录的更改</target>
        </trans-unit>
        <trans-unit id="a655d5b0d76cddfebf396f57b9b19ca49825f9fc" translate="yes" xml:space="preserve">
          <source>Inspect the &lt;code&gt;redis&lt;/code&gt; service:</source>
          <target state="translated">检查 &lt;code&gt;redis&lt;/code&gt; 服务：</target>
        </trans-unit>
        <trans-unit id="a653c5466994d5d911563050cea4c11201a824db" translate="yes" xml:space="preserve">
          <source>Inspect the changes to an &lt;code&gt;nginx&lt;/code&gt; container:</source>
          <target state="translated">检查对 &lt;code&gt;nginx&lt;/code&gt; 容器的更改：</target>
        </trans-unit>
        <trans-unit id="7604f326e330f861f74039d2f88bd399cb0c1217" translate="yes" xml:space="preserve">
          <source>Inspect the node to check its availability:</source>
          <target state="translated">检查节点以检查其可用性。</target>
        </trans-unit>
        <trans-unit id="7f3c7e6fe9569b48c38ba6582152afc2ba534e36" translate="yes" xml:space="preserve">
          <source>Inspect the node to see the updated state:</source>
          <target state="translated">检查节点以查看更新后的状态。</target>
        </trans-unit>
        <trans-unit id="2a7034b85fb0c0b67f40eb338c1e0691a6c1ecd6" translate="yes" xml:space="preserve">
          <source>Inspect the remote host. For example, &lt;code&gt;docker-machine ip &amp;lt;machine&amp;gt;&lt;/code&gt; returns the host IP address and &lt;code&gt;docker-machine inspect &amp;lt;machine&amp;gt;&lt;/code&gt; lists all the details.</source>
          <target state="translated">检查远程主机。例如， &lt;code&gt;docker-machine ip &amp;lt;machine&amp;gt;&lt;/code&gt; 返回主机IP地址，而 &lt;code&gt;docker-machine inspect &amp;lt;machine&amp;gt;&lt;/code&gt; 列出所有详细信息。</target>
        </trans-unit>
        <trans-unit id="a3e49f0aaf06ae9fd7c32f03cfeac1efd536f26c" translate="yes" xml:space="preserve">
          <source>Inspects one or more contexts.</source>
          <target state="translated">检查一个或多个上下文。</target>
        </trans-unit>
        <trans-unit id="6fb970a9973a0fe3dc49cf82ea5d559d4bda0f4b" translate="yes" xml:space="preserve">
          <source>Inspects the specified secret. This command has to be run targeting a manager node.</source>
          <target state="translated">检查指定的秘密。此命令必须以经理节点为目标运行。</target>
        </trans-unit>
        <trans-unit id="1238ba6a5fa64a99472e560085e32fed40212754" translate="yes" xml:space="preserve">
          <source>Inspects the specified service. This command has to be run targeting a manager node.</source>
          <target state="translated">检查指定的服务。此命令必须以经理节点为目标运行。</target>
        </trans-unit>
        <trans-unit id="fd6c3ebf7befca9f8208f86c76e4d4180303745c" translate="yes" xml:space="preserve">
          <source>Install</source>
          <target state="translated">Install</target>
        </trans-unit>
        <trans-unit id="f87859893d31c71ccf20a186c818ea9a15b8f081" translate="yes" xml:space="preserve">
          <source>Install &lt;a href=&quot;https://docs.docker.com/install&quot;&gt;Docker&lt;/a&gt;.</source>
          <target state="translated">安装&lt;a href=&quot;https://docs.docker.com/install&quot;&gt;Docker&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="87a5e4373b319e131c991d46ae5f29fdc177cb11" translate="yes" xml:space="preserve">
          <source>Install Compose</source>
          <target state="translated">安装Compose</target>
        </trans-unit>
        <trans-unit id="584cfd1e2b63dc02688935546533c373dd8513a0" translate="yes" xml:space="preserve">
          <source>Install Compose on Linux systems</source>
          <target state="translated">在Linux系统上安装Compose</target>
        </trans-unit>
        <trans-unit id="2edbc8b204fb4f77ab5754dbfd816f818b4cba66" translate="yes" xml:space="preserve">
          <source>Install Compose on Windows Server</source>
          <target state="translated">在Windows服务器上安装Compose</target>
        </trans-unit>
        <trans-unit id="4cccd54e0c8de4cf84ed8ce5105dcaf0c6bede12" translate="yes" xml:space="preserve">
          <source>Install Compose on Windows desktop systems</source>
          <target state="translated">在Windows桌面系统上安装Compose</target>
        </trans-unit>
        <trans-unit id="6fddb2f6d2ab5236388e781626450bbb7690bfbd" translate="yes" xml:space="preserve">
          <source>Install Compose on macOS</source>
          <target state="translated">在 macOS 上安装 Compose</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
