<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="docker">
    <body>
      <group id="docker">
        <trans-unit id="60d860189d2158cdf542a9cbb8695de90a38307e" translate="yes" xml:space="preserve">
          <source>Tasks and scheduling</source>
          <target state="translated">任务和时间安排</target>
        </trans-unit>
        <trans-unit id="4724fbe8a48eed671df3989a1d59760d11dc9374" translate="yes" xml:space="preserve">
          <source>Template driver</source>
          <target state="translated">模板驱动</target>
        </trans-unit>
        <trans-unit id="bbc9347d8ea27318520421a57ccb8f8fa6025618" translate="yes" xml:space="preserve">
          <source>Template example</source>
          <target state="translated">模板示例</target>
        </trans-unit>
        <trans-unit id="657b1097533383d1ddb0b93f186763becffe5373" translate="yes" xml:space="preserve">
          <source>Test Docker installation</source>
          <target state="translated">测试Docker安装</target>
        </trans-unit>
        <trans-unit id="7025949d5fc48e86d1eca515546b5ceccd50f755" translate="yes" xml:space="preserve">
          <source>Test Docker version</source>
          <target state="translated">测试Docker版本</target>
        </trans-unit>
        <trans-unit id="655a932ba64b06aacff6652d6aad1b05d8214c81" translate="yes" xml:space="preserve">
          <source>Test some trust operations</source>
          <target state="translated">测试一些信任操作</target>
        </trans-unit>
        <trans-unit id="a34e7038eaa42b7dee344142134b357ad14097cb" translate="yes" xml:space="preserve">
          <source>Test that your installation works by running the simple Docker image, &lt;a href=&quot;https://hub.docker.com/_/hello-world/&quot;&gt;hello-world&lt;/a&gt;:</source>
          <target state="translated">通过运行简单的Docker映像&lt;a href=&quot;https://hub.docker.com/_/hello-world/&quot;&gt;hello-world来&lt;/a&gt;测试安装是否正常：</target>
        </trans-unit>
        <trans-unit id="f0d302792e518eadee3123226b753c97b5e9f48b" translate="yes" xml:space="preserve">
          <source>Test the database</source>
          <target state="translated">测试数据库</target>
        </trans-unit>
        <trans-unit id="2b78370a2b3bb63e40059964522de64d81df33cd" translate="yes" xml:space="preserve">
          <source>Test the image, check for &lt;code&gt;/remove_me&lt;/code&gt; being gone, make sure &lt;code&gt;hello\nworld&lt;/code&gt; is in &lt;code&gt;/hello&lt;/code&gt;, make sure the &lt;code&gt;HELLO&lt;/code&gt; envvar&amp;rsquo;s value is &lt;code&gt;world&lt;/code&gt;.</source>
          <target state="translated">测试映像，检查 &lt;code&gt;/remove_me&lt;/code&gt; 是否消失，确保 &lt;code&gt;hello\nworld&lt;/code&gt; 在 &lt;code&gt;/hello&lt;/code&gt; 中，确保 &lt;code&gt;HELLO&lt;/code&gt; envvar的值为 &lt;code&gt;world&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f54d1554b9c0f1b5ea3dfc1b8000a4189c07cfd0" translate="yes" xml:space="preserve">
          <source>Test the installation.</source>
          <target state="translated">测试安装。</target>
        </trans-unit>
        <trans-unit id="37f76e912a69eb9799e911065d89e4c93378e4e0" translate="yes" xml:space="preserve">
          <source>Test with malicious images</source>
          <target state="translated">用恶意图片测试</target>
        </trans-unit>
        <trans-unit id="0a988a505d4f9bd1f41a57f4c2458a2423baedc7" translate="yes" xml:space="preserve">
          <source>Text files</source>
          <target state="translated">文本文件</target>
        </trans-unit>
        <trans-unit id="48ea8ca4b67a150bf3621e536df06ea9ea7c6131" translate="yes" xml:space="preserve">
          <source>That way, all new keys are encrypted and decrypted using the passphrase &lt;code&gt;mynewfancypassword&lt;/code&gt;, but old keys that were encrypted using the passphrase &lt;code&gt;mypassword&lt;/code&gt; can still be decrypted.</source>
          <target state="translated">这样，所有新密钥都使用密码短语 &lt;code&gt;mynewfancypassword&lt;/code&gt; 进行加密和解密，但仍可以使用密码短语 &lt;code&gt;mypassword&lt;/code&gt; 加密的旧密钥仍被解密。</target>
        </trans-unit>
        <trans-unit id="f44ab494894033becbc4ef28b56d983341a26a48" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;ll put your application code inside an image that builds a container with Ruby, Bundler and all your dependencies inside it. For more information on how to write Dockerfiles, see the &lt;a href=&quot;../../get-started/index#building-an-image-from-a-dockerfile&quot;&gt;Docker user guide&lt;/a&gt; and the &lt;a href=&quot;../../engine/reference/builder/index&quot;&gt;Dockerfile reference&lt;/a&gt;.</source>
          <target state="translated">这会将您的应用程序代码放在一个图像中，该图像使用Ruby，Bundler及其内部的所有依赖项构建一个容器。有关如何编写Dockerfile的更多信息，请参阅《&lt;a href=&quot;../../get-started/index#building-an-image-from-a-dockerfile&quot;&gt;Docker用户指南》&lt;/a&gt;和《&lt;a href=&quot;../../engine/reference/builder/index&quot;&gt;Dockerfile参考》&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="430585eb3dbe6bdbca1532982cb4635d1c03a556" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s all for this page. In the next section, we learn how to scale our application by running this container in a &lt;strong&gt;service&lt;/strong&gt;.</source>
          <target state="translated">仅此页。在下一节中，我们将学习如何通过在&lt;strong&gt;服务中&lt;/strong&gt;运行此容器来扩展应用程序。</target>
        </trans-unit>
        <trans-unit id="127d13646cf25b737700c8acfd62e6ec2061e547" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s it! You don&amp;rsquo;t need Python or anything in &lt;code&gt;requirements.txt&lt;/code&gt; on your system, nor does building or running this image install them on your system. It doesn&amp;rsquo;t seem like you&amp;rsquo;ve really set up an environment with Python and Flask, but you have.</source>
          <target state="translated">而已！你并不需要Python或任何东西 &lt;code&gt;requirements.txt&lt;/code&gt; 您的系统上，也没有建设或运行此图像您的系统上安装它们。似乎您并没有真正使用Python和Flask设置环境，但是已经有了。</target>
        </trans-unit>
        <trans-unit id="c9e7a95197709bea6ecc44d69a12ed465b3c942f" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s it. Your app should now be running on port 3000 on your Docker daemon.</source>
          <target state="translated">而已。您的应用程序现在应该在Docker守护程序的端口3000上运行。</target>
        </trans-unit>
        <trans-unit id="14dbbc8fc7113c6b6607f3c73f3f768d6b74600d" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;.env&amp;rdquo; file</source>
          <target state="translated">&amp;ldquo; .env&amp;rdquo;文件</target>
        </trans-unit>
        <trans-unit id="654f1dc286e9b3f410a2830d4fdbbb483a2a9ef6" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;env_file&amp;rdquo; configuration option</source>
          <target state="translated">&amp;ldquo; env_file&amp;rdquo;配置选项</target>
        </trans-unit>
        <trans-unit id="bb41e99c9aff699c5080b3991e8752ac32858843" translate="yes" xml:space="preserve">
          <source>The 4th container fails and reports &amp;ldquo;[8] System error: resource temporarily unavailable&amp;rdquo; error. This fails because the caller set &lt;code&gt;nproc=3&lt;/code&gt; resulting in the first three containers using up the three processes quota set for the &lt;code&gt;daemon&lt;/code&gt; user.</source>
          <target state="translated">第四个容器失败，并报告&amp;ldquo; [8]系统错误：资源暂时不可用&amp;rdquo;错误。由于调用者设置 &lt;code&gt;nproc=3&lt;/code&gt; 导致前三个容器用完了 &lt;code&gt;daemon&lt;/code&gt; 用户的三个进程配额，因此失败了。</target>
        </trans-unit>
        <trans-unit id="cebd5eb02d39d7497be7af8026f9c48eeca2be59" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#compatibility-matrix&quot;&gt;Compatibility Matrix&lt;/a&gt; shows Compose file versions mapped to Docker Engine releases.</source>
          <target state="translated">在&lt;a href=&quot;#compatibility-matrix&quot;&gt;兼容性矩阵&lt;/a&gt;显示映射到码头工人引擎版本撰写的文件版本。</target>
        </trans-unit>
        <trans-unit id="b7a1f2f65fda41b01612fd40aaaa3de01a0f93ad" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../extend/plugin_api/index#json-specification&quot;&gt;&lt;code&gt;PluginSpec&lt;/code&gt;&lt;/a&gt; is defined by the plugin developer. To add the plugin to all Docker nodes, use the &lt;a href=&quot;https://docs.docker.com/engine/api/v1.31/#operation/ServiceCreate&quot;&gt;&lt;code&gt;service/create&lt;/code&gt;&lt;/a&gt; API, passing the &lt;code&gt;PluginSpec&lt;/code&gt; JSON defined in the &lt;code&gt;TaskTemplate&lt;/code&gt;.</source>
          <target state="translated">该&lt;a href=&quot;../../extend/plugin_api/index#json-specification&quot;&gt; &lt;code&gt;PluginSpec&lt;/code&gt; &lt;/a&gt;由插件开发者定义的。将插件添加到所有节点多克，使用&lt;a href=&quot;https://docs.docker.com/engine/api/v1.31/#operation/ServiceCreate&quot;&gt; &lt;code&gt;service/create&lt;/code&gt; &lt;/a&gt; API，传递 &lt;code&gt;PluginSpec&lt;/code&gt; JSON的定义 &lt;code&gt;TaskTemplate&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="73eeeb2a3c032a0ea6d429f4744721f37565d8f4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../commandline/build/index&quot;&gt;&lt;code&gt;docker build&lt;/code&gt;&lt;/a&gt; command builds an image from a &lt;code&gt;Dockerfile&lt;/code&gt; and a &lt;em&gt;context&lt;/em&gt;. The build&amp;rsquo;s context is the set of files at a specified location &lt;code&gt;PATH&lt;/code&gt; or &lt;code&gt;URL&lt;/code&gt;. The &lt;code&gt;PATH&lt;/code&gt; is a directory on your local filesystem. The &lt;code&gt;URL&lt;/code&gt; is a Git repository location.</source>
          <target state="translated">的&lt;a href=&quot;../commandline/build/index&quot;&gt; &lt;code&gt;docker build&lt;/code&gt; &lt;/a&gt;命令构建从图像 &lt;code&gt;Dockerfile&lt;/code&gt; 和&lt;em&gt;上下文&lt;/em&gt;。构建的上下文是指定位置 &lt;code&gt;PATH&lt;/code&gt; 或 &lt;code&gt;URL&lt;/code&gt; 处的文件集。该 &lt;code&gt;PATH&lt;/code&gt; 是在您的本地文件系统的目录。该 &lt;code&gt;URL&lt;/code&gt; 是一个Git仓库的位置。</target>
        </trans-unit>
        <trans-unit id="c5f4ed1ae5916f39e4823b8399b775c3b2e70409" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../compose-file-v2/index#depends_on&quot;&gt;&lt;code&gt;depends_on&lt;/code&gt;&lt;/a&gt; option can be used in place of links to indicate dependencies between services and startup order.</source>
          <target state="translated">该&lt;a href=&quot;../compose-file-v2/index#depends_on&quot;&gt; &lt;code&gt;depends_on&lt;/code&gt; &lt;/a&gt;选项可替代链接可用于指示的服务和启动顺序之间的依赖关系。</target>
        </trans-unit>
        <trans-unit id="018f7b331a3235cebca4b4072ded7099501dab4f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compose-file/index&quot;&gt;Compose file&lt;/a&gt; provides a way to document and configure all of the application&amp;rsquo;s service dependencies (databases, queues, caches, web service APIs, etc). Using the Compose command line tool you can create and start one or more containers for each dependency with a single command (&lt;code&gt;docker-compose up&lt;/code&gt;).</source>
          <target state="translated">在&lt;a href=&quot;compose-file/index&quot;&gt;撰写文件&lt;/a&gt;提供了一种方法来记录和配置所有应用程序的服务依赖（数据库，队列，高速缓存，Web服务的API，等等）。使用Compose命令行工具，您可以使用单个命令（ &lt;code&gt;docker-compose up&lt;/code&gt; ）为每个依赖项创建和启动一个或多个容器。</target>
        </trans-unit>
        <trans-unit id="87fa9331ae9490bf7870124f14587e5c346d0b78" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://docs.docker.com/install&quot;&gt;installation section&lt;/a&gt; shows you how to install Docker on a variety of platforms.</source>
          <target state="translated">该&lt;a href=&quot;https://docs.docker.com/install&quot;&gt;安装部分&lt;/a&gt;向您展示如何在各种平台上安装多克。</target>
        </trans-unit>
        <trans-unit id="6b33d5ede8e3026d0ca1bc748f5aa28796c41cf8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://docs.docker.com/storage/storagedriver/select-storage-driver/#docker-ce&quot;&gt;default storage driver&lt;/a&gt; may fail on Debian, specifying &lt;code&gt;overlay2&lt;/code&gt; should resolve this issue.</source>
          <target state="translated">在&lt;a href=&quot;https://docs.docker.com/storage/storagedriver/select-storage-driver/#docker-ce&quot;&gt;默认的存储驱动程序&lt;/a&gt;可能无法在Debian，指定 &lt;code&gt;overlay2&lt;/code&gt; 应该解决这个问题。</target>
        </trans-unit>
        <trans-unit id="628b046b134e285847b720a7dd669b6db236e360" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/docker/libnetwork&quot;&gt;LibNetwork&lt;/a&gt; project</source>
          <target state="translated">该&lt;a href=&quot;https://github.com/docker/libnetwork&quot;&gt;LibNetwork&lt;/a&gt;项目</target>
        </trans-unit>
        <trans-unit id="b662250e23d13987f6741fabca2dfda9a8da7838" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/go-sql-driver/mysql&quot;&gt; the Data Source Name used to access the DB.&lt;/a&gt; ( include &lt;code&gt;parseTime=true&lt;/code&gt; as part of the DSN)</source>
          <target state="translated">该&lt;a href=&quot;https://github.com/go-sql-driver/mysql&quot;&gt;数据源名称来访问数据库。&lt;/a&gt;（将 &lt;code&gt;parseTime=true&lt;/code&gt; 包含在DSN中）</target>
        </trans-unit>
        <trans-unit id="fd73d42be4fd177aa9ab1fed999f88e1afe43fbc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/go-sql-driver/mysql&quot;&gt; the Data Source Name used to access the DB.&lt;/a&gt; (include &lt;code&gt;parseTime=true&lt;/code&gt; as part of the DSN)</source>
          <target state="translated">该&lt;a href=&quot;https://github.com/go-sql-driver/mysql&quot;&gt;数据源名称来访问数据库。&lt;/a&gt;（包括 &lt;code&gt;parseTime=true&lt;/code&gt; 作为DSN的一部分）</target>
        </trans-unit>
        <trans-unit id="504f0db06e322e719534c5c4a5a6576e4f23edb4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.exoscale.com/templates/&quot;&gt;VM templates&lt;/a&gt; available at Exoscale are listed on the Portal when adding a new instance.</source>
          <target state="translated">添加新实例时，门户上会列出Exoscale上可用的&lt;a href=&quot;https://www.exoscale.com/templates/&quot;&gt;VM模板&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1e0a8ecc927fdc7e3340ea02fe6771187b8cca0c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;index&quot;&gt;Understanding Docker section&lt;/a&gt; helps you:</source>
          <target state="translated">&amp;ldquo; &lt;a href=&quot;index&quot;&gt;了解Docker&amp;rdquo;部分&lt;/a&gt;可帮助您：</target>
        </trans-unit>
        <trans-unit id="4284d13cb4745a7492b807ffca26395534a811e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;${variable_name}&lt;/code&gt; syntax also supports a few of the standard &lt;code&gt;bash&lt;/code&gt; modifiers as specified below:</source>
          <target state="translated">在 &lt;code&gt;${variable_name}&lt;/code&gt; 语法也支持一些标准的 &lt;code&gt;bash&lt;/code&gt; 的修饰符如下规定：</target>
        </trans-unit>
        <trans-unit id="67a51f2b831d7d69d9eddea8b3cf5f1cc026ce01" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;PUBLISHED-PORT&amp;gt;&lt;/code&gt; is the port where the swarm makes the service available. If you omit it, a random high-numbered port is bound. The &lt;code&gt;&amp;lt;CONTAINER-PORT&amp;gt;&lt;/code&gt; is the port where the container listens. This parameter is required.</source>
          <target state="translated">所述 &lt;code&gt;&amp;lt;PUBLISHED-PORT&amp;gt;&lt;/code&gt; 是在群使得可用的服务的端口。如果您忽略它，则将绑定一个随机的高编号端口。所述 &lt;code&gt;&amp;lt;CONTAINER-PORT&amp;gt;&lt;/code&gt; 是端口的容器，其中侦听。此参数是必需的。</target>
        </trans-unit>
        <trans-unit id="a57f293402afe0c5879e54f7873750bb0d8b3939" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;dest&amp;gt;&lt;/code&gt; is an absolute path, or a path relative to &lt;code&gt;WORKDIR&lt;/code&gt;, into which the source will be copied inside the destination container.</source>
          <target state="translated">所述 &lt;code&gt;&amp;lt;dest&amp;gt;&lt;/code&gt; 是一个绝对路径，或相对于一个路径 &lt;code&gt;WORKDIR&lt;/code&gt; ，到其中的源将在目标容器内进行复制。</target>
        </trans-unit>
        <trans-unit id="f72a134e51f24916887b605c8357253041c38107" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; path must be inside the &lt;em&gt;context&lt;/em&gt; of the build; you cannot &lt;code&gt;ADD ../something /something&lt;/code&gt;, because the first step of a &lt;code&gt;docker build&lt;/code&gt; is to send the context directory (and subdirectories) to the docker daemon.</source>
          <target state="translated">所述 &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; 路径必须是内部&lt;em&gt;上下文&lt;/em&gt;生成的; 您不能 &lt;code&gt;ADD ../something /something&lt;/code&gt; ，因为docker &lt;code&gt;docker build&lt;/code&gt; 第一步是将上下文目录（和子目录）发送到docker守护程序。</target>
        </trans-unit>
        <trans-unit id="dc1afca2b065dd1b6a9740d25d7aa2a3ebf159b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; path must be inside the &lt;em&gt;context&lt;/em&gt; of the build; you cannot &lt;code&gt;COPY ../something /something&lt;/code&gt;, because the first step of a &lt;code&gt;docker build&lt;/code&gt; is to send the context directory (and subdirectories) to the docker daemon.</source>
          <target state="translated">所述 &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; 路径必须是内部&lt;em&gt;上下文&lt;/em&gt;生成的; 您无法 &lt;code&gt;COPY ../something /something&lt;/code&gt; ，因为Docker &lt;code&gt;docker build&lt;/code&gt; 第一步是将上下文目录（和子目录）发送到Docker守护程序。</target>
        </trans-unit>
        <trans-unit id="3a3a213a12552b6e7f649b0b0cdf56d19ec341db" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*&lt;/code&gt; next to the node ID indicates that you&amp;rsquo;re currently connected on this node.</source>
          <target state="translated">节点ID旁边的 &lt;code&gt;*&lt;/code&gt; 表示您当前已连接到该节点。</target>
        </trans-unit>
        <trans-unit id="bb630ccd56d5687939202633b11ad7715a867b16" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--advertise-addr&lt;/code&gt; flag configures the manager node to publish its address as &lt;code&gt;192.168.99.100&lt;/code&gt;. The other nodes in the swarm must be able to access the manager at the IP address.</source>
          <target state="translated">该 &lt;code&gt;--advertise-addr&lt;/code&gt; 标志配置管理器节点来发布自己的地址 &lt;code&gt;192.168.99.100&lt;/code&gt; 。群中的其他节点必须能够访问该IP地址上的管理器。</target>
        </trans-unit>
        <trans-unit id="ec919e6dd21335064b00777c52cd63ecae7ba32d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--blkio-weight-device=&quot;DEVICE_NAME:WEIGHT&quot;&lt;/code&gt; flag sets a specific device weight. The &lt;code&gt;DEVICE_NAME:WEIGHT&lt;/code&gt; is a string containing a colon-separated device name and weight. For example, to set &lt;code&gt;/dev/sda&lt;/code&gt; device weight to &lt;code&gt;200&lt;/code&gt;:</source>
          <target state="translated">所述 &lt;code&gt;--blkio-weight-device=&quot;DEVICE_NAME:WEIGHT&quot;&lt;/code&gt; 标志集的特定的设备的重量。的 &lt;code&gt;DEVICE_NAME:WEIGHT&lt;/code&gt; 是含有冒号分隔的设备名称和重量的字符串。例如，将 &lt;code&gt;/dev/sda&lt;/code&gt; 设备权重设置为 &lt;code&gt;200&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b22bb7e3dc97be5255fb3143973a08918865460c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--blkio-weight&lt;/code&gt; flag can set the weighting to a value between 10 to 1000. For example, the commands below create two containers with different blkio weight:</source>
          <target state="translated">所述 &lt;code&gt;--blkio-weight&lt;/code&gt; 标志可以加权到10之间的值设置为1000。例如，下面的命令创建两个容器具有不同blkio重量：</target>
        </trans-unit>
        <trans-unit id="f42470659caa51ce06fd7bee1e26762683d77671" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--cgroup-parent&lt;/code&gt; option allows you to set the default cgroup parent to use for containers. If this option is not set, it defaults to &lt;code&gt;/docker&lt;/code&gt; for fs cgroup driver and &lt;code&gt;system.slice&lt;/code&gt; for systemd cgroup driver.</source>
          <target state="translated">该 &lt;code&gt;--cgroup-parent&lt;/code&gt; 选项，可以设置默认cgroup的父母使用的容器。如果未设置此选项，则对于fs cgroup驱动程序，默认为 &lt;code&gt;/docker&lt;/code&gt; ；对于systemd cgroup驱动程序，默认为 &lt;code&gt;system.slice&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1826d2db2b75e861af8712525d23a1ed0f1a1ea8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--change&lt;/code&gt; option will apply &lt;code&gt;Dockerfile&lt;/code&gt; instructions to the image that is created. Supported &lt;code&gt;Dockerfile&lt;/code&gt; instructions: &lt;code&gt;CMD&lt;/code&gt;|&lt;code&gt;ENTRYPOINT&lt;/code&gt;|&lt;code&gt;ENV&lt;/code&gt;|&lt;code&gt;EXPOSE&lt;/code&gt;|&lt;code&gt;LABEL&lt;/code&gt;|&lt;code&gt;ONBUILD&lt;/code&gt;|&lt;code&gt;USER&lt;/code&gt;|&lt;code&gt;VOLUME&lt;/code&gt;|&lt;code&gt;WORKDIR&lt;/code&gt;</source>
          <target state="translated">该 &lt;code&gt;--change&lt;/code&gt; 选项将应用于 &lt;code&gt;Dockerfile&lt;/code&gt; 指令所创建的图像。支持的 &lt;code&gt;Dockerfile&lt;/code&gt; 指令： &lt;code&gt;CMD&lt;/code&gt; | &lt;code&gt;ENTRYPOINT&lt;/code&gt; | &lt;code&gt;ENV&lt;/code&gt; | &lt;code&gt;EXPOSE&lt;/code&gt; | &lt;code&gt;LABEL&lt;/code&gt; | &lt;code&gt;ONBUILD&lt;/code&gt; | &lt;code&gt;USER&lt;/code&gt; | &lt;code&gt;VOLUME&lt;/code&gt; | &lt;code&gt;WORKDIR&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="331901ea2d4b659f72eb06d67078bb16233be25a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--change&lt;/code&gt; option will apply &lt;code&gt;Dockerfile&lt;/code&gt; instructions to the image that is created. Supported &lt;code&gt;Dockerfile&lt;/code&gt; instructions: &lt;code&gt;CMD&lt;/code&gt;|&lt;code&gt;ENTRYPOINT&lt;/code&gt;|&lt;code&gt;ENV&lt;/code&gt;|&lt;code&gt;EXPOSE&lt;/code&gt;|&lt;code&gt;ONBUILD&lt;/code&gt;|&lt;code&gt;USER&lt;/code&gt;|&lt;code&gt;VOLUME&lt;/code&gt;|&lt;code&gt;WORKDIR&lt;/code&gt;</source>
          <target state="translated">该 &lt;code&gt;--change&lt;/code&gt; 选项将应用于 &lt;code&gt;Dockerfile&lt;/code&gt; 指令所创建的图像。支持的 &lt;code&gt;Dockerfile&lt;/code&gt; 指令： &lt;code&gt;CMD&lt;/code&gt; | &lt;code&gt;ENTRYPOINT&lt;/code&gt; | &lt;code&gt;ENV&lt;/code&gt; | &lt;code&gt;EXPOSE&lt;/code&gt; | &lt;code&gt;ONBUILD&lt;/code&gt; | &lt;code&gt;USER&lt;/code&gt; | &lt;code&gt;VOLUME&lt;/code&gt; | &lt;code&gt;WORKDIR&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6372b4419938c42b7b941008577f7addb6bf25a6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--cluster-advertise&lt;/code&gt; option specifies the &lt;code&gt;host:port&lt;/code&gt; or &lt;code&gt;interface:port&lt;/code&gt; combination that this particular daemon instance should use when advertising itself to the cluster. The daemon is reached by remote hosts through this value. If you specify an interface, make sure it includes the IP address of the actual Docker host. For Engine installation created through &lt;code&gt;docker-machine&lt;/code&gt;, the interface is typically &lt;code&gt;eth1&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;--cluster-advertise&lt;/code&gt; 选项指定 &lt;code&gt;host:port&lt;/code&gt; 或 &lt;code&gt;interface:port&lt;/code&gt; 组合，广告本身群集时这个特殊的守护程序实例应该使用。通过此值，远程主机可以访问该守护程序。如果指定接口，请确保它包含实际Docker主机的IP地址。对于通过 &lt;code&gt;docker-machine&lt;/code&gt; 创建的Engine安装，接口通常为 &lt;code&gt;eth1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="118bb688281323a5d961497c2a015437d9cc0d17" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--config-file&lt;/code&gt; option allows you to set any configuration option for the daemon in a JSON format. This file uses the same flag names as keys, except for flags that allow several entries, where it uses the plural of the flag name, e.g., &lt;code&gt;labels&lt;/code&gt; for the &lt;code&gt;label&lt;/code&gt; flag.</source>
          <target state="translated">该 &lt;code&gt;--config-file&lt;/code&gt; 选项，可以设置一个JSON格式的守护进程的任何配置选项。该文件使用与键相同的标志名，但允许多个条目的标志除外，该文件使用多个标志名，例如， &lt;code&gt;labels&lt;/code&gt; 标志的 &lt;code&gt;label&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3001b2baac6ad6ca78a42c7dabc4c6fdb80dc832" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--cpu-quota&lt;/code&gt; flag limits the container&amp;rsquo;s CPU usage. The default 0 value allows the container to take 100% of a CPU resource (1 CPU). The CFS (Completely Fair Scheduler) handles resource allocation for executing processes and is default Linux Scheduler used by the kernel. Set this value to 50000 to limit the container to 50% of a CPU resource. For multiple CPUs, adjust the &lt;code&gt;--cpu-quota&lt;/code&gt; as necessary. For more information, see the &lt;a href=&quot;https://www.kernel.org/doc/Documentation/scheduler/sched-bwc.txt&quot;&gt;CFS documentation on bandwidth limiting&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;--cpu-quota&lt;/code&gt; 标志限制容器的CPU使用率。默认0值允许容器占用100％的CPU资源（1个CPU）。CFS（完全公平调度程序）处理用于执行进程的资源分配，并且是内核使用的默认Linux调度程序。将此值设置为50000可将容器限制为CPU资源的50％。对于多个CPU， &lt;code&gt;--cpu-quota&lt;/code&gt; 根据需要调整--cpu-quota。有关更多信息，请参阅&lt;a href=&quot;https://www.kernel.org/doc/Documentation/scheduler/sched-bwc.txt&quot;&gt;有关带宽限制&lt;/a&gt;的CFS文档。</target>
        </trans-unit>
        <trans-unit id="043ce561f5352353cd4aea732d4ed3e377b7df93" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--credential-spec&lt;/code&gt; must be one of the following formats:</source>
          <target state="translated">该 &lt;code&gt;--credential-spec&lt;/code&gt; 必须是下列格式之一：</target>
        </trans-unit>
        <trans-unit id="7645da86ca6a208ce5ac2ceec3ff44fc83723aa7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--device-read-bps&lt;/code&gt; flag limits the read rate (bytes per second) from a device. For example, this command creates a container and limits the read rate to &lt;code&gt;1mb&lt;/code&gt; per second from &lt;code&gt;/dev/sda&lt;/code&gt;:</source>
          <target state="translated">所述 &lt;code&gt;--device-read-bps&lt;/code&gt; 标志限制从一个装置读出速率（每秒字节）。例如，该命令创建一个容器，并且限制了读出速度到 &lt;code&gt;1mb&lt;/code&gt; 从每秒 &lt;code&gt;/dev/sda&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="712e9b14b8091c01098667b0a748389286c56f70" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--device-read-iops&lt;/code&gt; flag limits read rate (IO per second) from a device. For example, this command creates a container and limits the read rate to &lt;code&gt;1000&lt;/code&gt; IO per second from &lt;code&gt;/dev/sda&lt;/code&gt;:</source>
          <target state="translated">所述 &lt;code&gt;--device-read-iops&lt;/code&gt; 标志限制读取从设备速率（每秒IO）。例如，此命令创建一个容器并将每秒从 &lt;code&gt;/dev/sda&lt;/code&gt; 的读取速率限制为 &lt;code&gt;1000&lt;/code&gt; IO ：</target>
        </trans-unit>
        <trans-unit id="fe281068f7ac2e41c30ca85d06921f36e2e2462e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--device-write-bps&lt;/code&gt; flag limits the write rate (bytes per second) to a device. For example, this command creates a container and limits the write rate to &lt;code&gt;1mb&lt;/code&gt; per second for &lt;code&gt;/dev/sda&lt;/code&gt;:</source>
          <target state="translated">所述 &lt;code&gt;--device-write-bps&lt;/code&gt; 标志限制的写速率（每秒字节）的装置。例如，该命令创建一个容器，并限制的写速率到 &lt;code&gt;1mb&lt;/code&gt; 每秒 &lt;code&gt;/dev/sda&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="963edac892eb4f59d48156a5a245122b7ec75c23" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--device-write-iops&lt;/code&gt; flag limits write rate (IO per second) to a device. For example, this command creates a container and limits the write rate to &lt;code&gt;1000&lt;/code&gt; IO per second to &lt;code&gt;/dev/sda&lt;/code&gt;:</source>
          <target state="translated">所述 &lt;code&gt;--device-write-iops&lt;/code&gt; 标志限制写速率（每秒IO）到设备。例如，此命令创建一个容器并将对 &lt;code&gt;/dev/sda&lt;/code&gt; 的写入速率限制为每秒 &lt;code&gt;1000&lt;/code&gt; IO ：</target>
        </trans-unit>
        <trans-unit id="b41e02b0b1c16f6f4b137f3f08c43bb795e2f980" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--disable-legacy-registry&lt;/code&gt; flag was disabled in Docker 17.12 and will print an error when used. For this error to be printed, the flag itself is still present, but hidden. The flag will be removed in Docker 18.03.</source>
          <target state="translated">该 &lt;code&gt;--disable-legacy-registry&lt;/code&gt; 的标志是在泊坞窗17.12禁用，使用时将打印错误。对于要打印的错误，标志本身仍然存在，但被隐藏。该标志将在Docker 18.03中删除。</target>
        </trans-unit>
        <trans-unit id="aa8855c7d7182fcadca1fed0a08f183547580585" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--format&lt;/code&gt; option can be used to obtain specific information about a service. For example, the following command outputs the number of replicas of the &amp;ldquo;redis&amp;rdquo; service.</source>
          <target state="translated">该 &lt;code&gt;--format&lt;/code&gt; 选项可用于获取有关服务的具体信息。例如，以下命令输出&amp;ldquo; redis&amp;rdquo;服务的副本数。</target>
        </trans-unit>
        <trans-unit id="d2691a80d15b06a3fcb43e9cbfb91577d7e5061b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--gpus&amp;shy;&lt;/code&gt; flag allows you to access NVIDIA GPU resources. First you need to install &lt;a href=&quot;https://nvidia.github.io/nvidia-container-runtime/&quot;&gt;nvidia-container-runtime&lt;/a&gt;. Visit &lt;a href=&quot;https://docs.docker.com/config/containers/resource_constraints/&quot;&gt;Specify a container&amp;rsquo;s resources&lt;/a&gt; for more information.</source>
          <target state="translated">使用 &lt;code&gt;--gpus&amp;shy;&lt;/code&gt; 标志可以访问NVIDIA GPU资源。首先，您需要安装&lt;a href=&quot;https://nvidia.github.io/nvidia-container-runtime/&quot;&gt;nvidia-container-runtime&lt;/a&gt;。请访问&lt;a href=&quot;https://docs.docker.com/config/containers/resource_constraints/&quot;&gt;指定容器的资源&lt;/a&gt;以获取更多信息。</target>
        </trans-unit>
        <trans-unit id="7e733ea054c1c1ff7988c93e553e76ceca01093a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--metrics-addr&lt;/code&gt; option takes a tcp address to serve the metrics API. This feature is still experimental, therefore, the daemon must be running in experimental mode for this feature to work.</source>
          <target state="translated">该 &lt;code&gt;--metrics-addr&lt;/code&gt; 选项需要TCP地址，服务指标API。该功能仍处于试验阶段，因此，守护程序必须在试验模式下运行，此功能才能起作用。</target>
        </trans-unit>
        <trans-unit id="55edf7ef0d43cb5742eeaebcc6bc88b518d3096c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--mount-add&lt;/code&gt; flag takes the same parameters as the &lt;code&gt;--mount&lt;/code&gt; flag on &lt;code&gt;service create&lt;/code&gt;. Refer to the &lt;a href=&quot;../service_create/index#volumes-and-bind-mounts-mount&quot;&gt;volumes and bind mounts&lt;/a&gt; section in the &lt;code&gt;service create&lt;/code&gt; reference for details.</source>
          <target state="translated">该 &lt;code&gt;--mount-add&lt;/code&gt; 标志采用相同的参数作为 &lt;code&gt;--mount&lt;/code&gt; 上标志 &lt;code&gt;service create&lt;/code&gt; 。有关详细信息，请参考 &lt;code&gt;service create&lt;/code&gt; 参考中的&amp;ldquo; &lt;a href=&quot;../service_create/index#volumes-and-bind-mounts-mount&quot;&gt;卷和绑定挂载&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="2dcb66c9db4a6af0634718f030b3c6961948aceb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--mount-rm&lt;/code&gt; flag takes the &lt;code&gt;target&lt;/code&gt; path of the mount.</source>
          <target state="translated">该 &lt;code&gt;--mount-rm&lt;/code&gt; 标志取 &lt;code&gt;target&lt;/code&gt; 的装载路径。</target>
        </trans-unit>
        <trans-unit id="02aa3c4cfe092d2907c9c5953f6b842f826fec95" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--mount&lt;/code&gt; flag allows you to mount volumes, host-directories and &lt;code&gt;tmpfs&lt;/code&gt; mounts in a container.</source>
          <target state="translated">该 &lt;code&gt;--mount&lt;/code&gt; 标志允许您安装卷，主机目录和 &lt;code&gt;tmpfs&lt;/code&gt; 的坐骑在容器中。</target>
        </trans-unit>
        <trans-unit id="8750034606c120ce24db3130aa8129649ec8c176" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--mount&lt;/code&gt; flag allows you to specify a volume driver and volume driver options &lt;em&gt;per volume&lt;/em&gt;, without creating the volumes in advance. In contrast, &lt;code&gt;docker run&lt;/code&gt; allows you to specify a single volume driver which is shared by all volumes, using the &lt;code&gt;--volume-driver&lt;/code&gt; flag.</source>
          <target state="translated">该 &lt;code&gt;--mount&lt;/code&gt; 标志允许您指定音量驱动器和音量驱动程序选项&lt;em&gt;每卷&lt;/em&gt;，而无需预先创建的卷。相反， &lt;code&gt;docker run&lt;/code&gt; 允许您使用 &lt;code&gt;--volume-driver&lt;/code&gt; 标志指定所有卷共享的单个卷驱动程序。</target>
        </trans-unit>
        <trans-unit id="36dc4d2874ffe2c6696a361b4631e72a78be9474" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--mount&lt;/code&gt; flag allows you to specify custom metadata (&amp;ldquo;labels&amp;rdquo;) for a volume, before the volume is created.</source>
          <target state="translated">该 &lt;code&gt;--mount&lt;/code&gt; 标志允许您为卷指定自定义元数据（&amp;ldquo;标签&amp;rdquo;），在创建卷之前。</target>
        </trans-unit>
        <trans-unit id="cfadbb2f7c0cefeea1691c7fe0bf1951cbef87e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--mount&lt;/code&gt; flag does not allow you to relabel a volume with &lt;code&gt;Z&lt;/code&gt; or &lt;code&gt;z&lt;/code&gt; flags, which are used for &lt;code&gt;selinux&lt;/code&gt; labeling.</source>
          <target state="translated">该 &lt;code&gt;--mount&lt;/code&gt; 标志不允许重新标记具有音量 &lt;code&gt;Z&lt;/code&gt; 或 &lt;code&gt;z&lt;/code&gt; 标志，其用于 &lt;code&gt;selinux&lt;/code&gt; 标签。</target>
        </trans-unit>
        <trans-unit id="c3ddb7d697487f1f5e66906e8782d710723952e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--mount&lt;/code&gt; flag supports most options that are supported by the &lt;code&gt;-v&lt;/code&gt; or &lt;code&gt;--volume&lt;/code&gt; flag for &lt;code&gt;docker run&lt;/code&gt;, with some important exceptions:</source>
          <target state="translated">该 &lt;code&gt;--mount&lt;/code&gt; 标志支持由支持的大多数选项 &lt;code&gt;-v&lt;/code&gt; 或 &lt;code&gt;--volume&lt;/code&gt; 标志 &lt;code&gt;docker run&lt;/code&gt; ，有一些重要的例外情况：</target>
        </trans-unit>
        <trans-unit id="af06b038fe8b5ee4cf2200adf2410db371b3030b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--mount&lt;/code&gt; flag supports most options that are supported by the &lt;code&gt;-v&lt;/code&gt; or the &lt;code&gt;--volume&lt;/code&gt; flag, but uses a different syntax. For in-depth information on the &lt;code&gt;--mount&lt;/code&gt; flag, and a comparison between &lt;code&gt;--volume&lt;/code&gt; and &lt;code&gt;--mount&lt;/code&gt;, refer to the &lt;a href=&quot;../service_create/index#add-bind-mounts-or-volumes&quot;&gt;service create command reference&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;--mount&lt;/code&gt; 标志支持由支持的大多数选项 &lt;code&gt;-v&lt;/code&gt; 或 &lt;code&gt;--volume&lt;/code&gt; 标志，但使用不同的语法。有关 &lt;code&gt;--mount&lt;/code&gt; 标志的详细信息以及 &lt;code&gt;--volume&lt;/code&gt; 和 &lt;code&gt;--mount&lt;/code&gt; 之间的比较，请参考&lt;a href=&quot;../service_create/index#add-bind-mounts-or-volumes&quot;&gt;service create命令参考&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bed7237ccc0b8ad3437fa30020a578288a4e4483" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--name&lt;/code&gt; flag names the service &lt;code&gt;helloworld&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;--name&lt;/code&gt; 标志名称服务 &lt;code&gt;helloworld&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a853eb9fbc1c99f3f8c76dfce1506f84d6fa4344" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--no-resolve&lt;/code&gt; option shows IDs for task name, without mapping IDs to Names.</source>
          <target state="translated">该 &lt;code&gt;--no-resolve&lt;/code&gt; 任务名称选项显示ID，不会映射到的ID名称。</target>
        </trans-unit>
        <trans-unit id="32826a87c3c4abc30e935b98ecd14f2cca87e51e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--node-generic-resources&lt;/code&gt; option takes a list of key-value pair (&lt;code&gt;key=value&lt;/code&gt;) that allows you to advertise user defined resources in a swarm cluster.</source>
          <target state="translated">该 &lt;code&gt;--node-generic-resources&lt;/code&gt; 选项接受键值对的清单（ &lt;code&gt;key=value&lt;/code&gt; ），可以让你做广告用户定义的资源在群簇。</target>
        </trans-unit>
        <trans-unit id="fe1b46c54563bf68f3d96fa56384895ffc4790ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--privileged&lt;/code&gt; flag gives &lt;em&gt;all&lt;/em&gt; capabilities to the container, and it also lifts all the limitations enforced by the &lt;code&gt;device&lt;/code&gt; cgroup controller. In other words, the container can then do almost everything that the host can do. This flag exists to allow special use-cases, like running Docker within Docker.</source>
          <target state="translated">所述 &lt;code&gt;--privileged&lt;/code&gt; 标志给出&lt;em&gt;所有&lt;/em&gt;功能的容器，它也升降机由实施的所有限制 &lt;code&gt;device&lt;/code&gt; 的cgroup控制器。换句话说，容器可以完成主机可以做的几乎所有事情。存在此标志是为了允许特殊用例，例如在Docker中运行Docker。</target>
        </trans-unit>
        <trans-unit id="bb774c803d079b4a41ab3354f300b230d3e14040" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--replicas&lt;/code&gt; flag specifies the desired state of 1 running instance.</source>
          <target state="translated">所述 &lt;code&gt;--replicas&lt;/code&gt; 标志指定1个正在运行的实例的期望状态。</target>
        </trans-unit>
        <trans-unit id="f83197c97e8759a9b35a0a3cfe176f25ddfffb9d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--rotate&lt;/code&gt; flag does not require any parameters to do a rotation, but you can optionally specify a certificate and key, or a certificate and external CA URL, and those will be used instead of an automatically-generated certificate/key pair.</source>
          <target state="translated">该 &lt;code&gt;--rotate&lt;/code&gt; 标志不需要任何参数做了轮换，但你可以选择指定证书和密钥，或证书和外部CA URL，以及那些将被用来代替自动生成的证书/密钥对。</target>
        </trans-unit>
        <trans-unit id="d093ee6fc107327da7a54146804ca8a627398258" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--since&lt;/code&gt; and &lt;code&gt;--until&lt;/code&gt; parameters can be Unix timestamps, date formatted timestamps, or Go duration strings (e.g. &lt;code&gt;10m&lt;/code&gt;, &lt;code&gt;1h30m&lt;/code&gt;) computed relative to the client machine&amp;rsquo;s time. If you do not provide the &lt;code&gt;--since&lt;/code&gt; option, the command returns only new and/or live events. Supported formats for date formatted time stamps include RFC3339Nano, RFC3339, &lt;code&gt;2006-01-02T15:04:05&lt;/code&gt;, &lt;code&gt;2006-01-02T15:04:05.999999999&lt;/code&gt;, &lt;code&gt;2006-01-02Z07:00&lt;/code&gt;, and &lt;code&gt;2006-01-02&lt;/code&gt;. The local timezone on the client will be used if you do not provide either a &lt;code&gt;Z&lt;/code&gt; or a &lt;code&gt;+-00:00&lt;/code&gt; timezone offset at the end of the timestamp. When providing Unix timestamps enter seconds[.nanoseconds], where seconds is the number of seconds that have elapsed since January 1, 1970 (midnight UTC/GMT), not counting leap seconds (aka Unix epoch or Unix time), and the optional .nanoseconds field is a fraction of a second no more than nine digits long.</source>
          <target state="translated">的 &lt;code&gt;--since&lt;/code&gt; 和 &lt;code&gt;--until&lt;/code&gt; 参数可以是Unix的时间戳，日期格式时间戳，或转到持续时间串（例如 &lt;code&gt;10m&lt;/code&gt; ， &lt;code&gt;1h30m&lt;/code&gt; 相对于客户机的时间计算的）。如果不提供 &lt;code&gt;--since&lt;/code&gt; 选项，则该命令仅返回新事件和/或实时事件。支持的格式为日期格式时间戳包括RFC3339Nano，RFC3339， &lt;code&gt;2006-01-02T15:04:05&lt;/code&gt; ， &lt;code&gt;2006-01-02T15:04:05.999999999&lt;/code&gt; ， &lt;code&gt;2006-01-02Z07:00&lt;/code&gt; ，和 &lt;code&gt;2006-01-02&lt;/code&gt; 。如果您未提供 &lt;code&gt;Z&lt;/code&gt; 或 &lt;code&gt;+-00:00&lt;/code&gt; ,则将使用客户端上的本地时区时间戳记末尾的时区偏移量。提供Unix时间戳时，输入seconds [.nanoseconds]，其中seconds是自1970年1月1日（UTC / GMT午夜）以来经过的秒数，不计算counting秒（又名Unix纪元或Unix时间），以及可选的。纳秒字段是一秒的分数，长度不超过9位数。</target>
        </trans-unit>
        <trans-unit id="652b6615884bf6a1cd485ceedcea4963abfed879" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--since&lt;/code&gt; option shows only the container logs generated after a given date. You can specify the date as an RFC 3339 date, a UNIX timestamp, or a Go duration string (e.g. &lt;code&gt;1m30s&lt;/code&gt;, &lt;code&gt;3h&lt;/code&gt;). Besides RFC3339 date format you may also use RFC3339Nano, &lt;code&gt;2006-01-02T15:04:05&lt;/code&gt;, &lt;code&gt;2006-01-02T15:04:05.999999999&lt;/code&gt;, &lt;code&gt;2006-01-02Z07:00&lt;/code&gt;, and &lt;code&gt;2006-01-02&lt;/code&gt;. The local timezone on the client will be used if you do not provide either a &lt;code&gt;Z&lt;/code&gt; or a &lt;code&gt;+-00:00&lt;/code&gt; timezone offset at the end of the timestamp. When providing Unix timestamps enter seconds[.nanoseconds], where seconds is the number of seconds that have elapsed since January 1, 1970 (midnight UTC/GMT), not counting leap seconds (aka Unix epoch or Unix time), and the optional .nanoseconds field is a fraction of a second no more than nine digits long. You can combine the &lt;code&gt;--since&lt;/code&gt; option with either or both of the &lt;code&gt;--follow&lt;/code&gt; or &lt;code&gt;--tail&lt;/code&gt; options.</source>
          <target state="translated">该 &lt;code&gt;--since&lt;/code&gt; 唯一的选择显示了一个给定的日期后所产生的容器日志。您可以将日期指定为RFC 3339日期，UNIX时间戳或Go持续时间字符串（例如 &lt;code&gt;1m30s&lt;/code&gt; ， &lt;code&gt;3h&lt;/code&gt; ）。除了RFC3339的日期格式，你也可以使用RFC3339Nano， &lt;code&gt;2006-01-02T15:04:05&lt;/code&gt; ， &lt;code&gt;2006-01-02T15:04:05.999999999&lt;/code&gt; ， &lt;code&gt;2006-01-02Z07:00&lt;/code&gt; ，和 &lt;code&gt;2006-01-02&lt;/code&gt; 。如果您未提供 &lt;code&gt;Z&lt;/code&gt; 或 &lt;code&gt;+-00:00&lt;/code&gt; ,则将使用客户端上的本地时区时间戳记末尾的时区偏移量。提供Unix时间戳时，请输入seconds [.nanoseconds]，其中seconds是自1970年1月1日（UTC / GMT午夜）以来经过的秒数，不计算leap秒（又名Unix纪元或Unix时间），以及可选的。纳秒字段是一秒的分数，长度不超过9位数。您可以将 &lt;code&gt;--since&lt;/code&gt; 选项与 &lt;code&gt;--follow&lt;/code&gt; 或 &lt;code&gt;--tail&lt;/code&gt; 选项之一或两者结合使用。</target>
        </trans-unit>
        <trans-unit id="bab01cf2bd689f9a42400bd61c72369e65a07ab2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--since&lt;/code&gt; option shows only the service logs generated after a given date. You can specify the date as an RFC 3339 date, a UNIX timestamp, or a Go duration string (e.g. &lt;code&gt;1m30s&lt;/code&gt;, &lt;code&gt;3h&lt;/code&gt;). Besides RFC3339 date format you may also use RFC3339Nano, &lt;code&gt;2006-01-02T15:04:05&lt;/code&gt;, &lt;code&gt;2006-01-02T15:04:05.999999999&lt;/code&gt;, &lt;code&gt;2006-01-02Z07:00&lt;/code&gt;, and &lt;code&gt;2006-01-02&lt;/code&gt;. The local timezone on the client will be used if you do not provide either a &lt;code&gt;Z&lt;/code&gt; or a &lt;code&gt;+-00:00&lt;/code&gt; timezone offset at the end of the timestamp. When providing Unix timestamps enter seconds[.nanoseconds], where seconds is the number of seconds that have elapsed since January 1, 1970 (midnight UTC/GMT), not counting leap seconds (aka Unix epoch or Unix time), and the optional .nanoseconds field is a fraction of a second no more than nine digits long. You can combine the &lt;code&gt;--since&lt;/code&gt; option with either or both of the &lt;code&gt;--follow&lt;/code&gt; or &lt;code&gt;--tail&lt;/code&gt; options.</source>
          <target state="translated">该 &lt;code&gt;--since&lt;/code&gt; 唯一的选择显示了一个给定的日期后所产生的服务日志。您可以将日期指定为RFC 3339日期，UNIX时间戳或Go持续时间字符串（例如 &lt;code&gt;1m30s&lt;/code&gt; ， &lt;code&gt;3h&lt;/code&gt; ）。除了RFC3339的日期格式，你也可以使用RFC3339Nano， &lt;code&gt;2006-01-02T15:04:05&lt;/code&gt; ， &lt;code&gt;2006-01-02T15:04:05.999999999&lt;/code&gt; ， &lt;code&gt;2006-01-02Z07:00&lt;/code&gt; ，和 &lt;code&gt;2006-01-02&lt;/code&gt; 。如果您未提供 &lt;code&gt;Z&lt;/code&gt; 或 &lt;code&gt;+-00:00&lt;/code&gt; ,则将使用客户端上的本地时区时间戳记末尾的时区偏移量。提供Unix时间戳时，请输入seconds [.nanoseconds]，其中seconds是自1970年1月1日（UTC / GMT午夜）以来经过的秒数，不计算leap秒（又名Unix纪元或Unix时间），以及可选的。纳秒字段是一秒的分数，长度不超过9位数。您可以将 &lt;code&gt;--since&lt;/code&gt; 选项与 &lt;code&gt;--follow&lt;/code&gt; 或 &lt;code&gt;--tail&lt;/code&gt; 选项之一或两者结合使用。</target>
        </trans-unit>
        <trans-unit id="3600edac5452a3667a2c3e6900d550bfe91f655a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--squash&lt;/code&gt; option has a number of known limitations:</source>
          <target state="translated">该 &lt;code&gt;--squash&lt;/code&gt; 选项有一些已知限制：</target>
        </trans-unit>
        <trans-unit id="868df34827a00906506bf1395e46d56e0920fb6f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--squash&lt;/code&gt; option is an experimental feature, and should not be considered stable.</source>
          <target state="translated">该 &lt;code&gt;--squash&lt;/code&gt; 选项是一个实验性的功能，并且不应该被认为是稳定的。</target>
        </trans-unit>
        <trans-unit id="54d86090ae9e58411843350e49a7bf462b0b39ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--stop-signal&lt;/code&gt; flag sets the system call signal that will be sent to the container to exit. This signal can be a valid unsigned number that matches a position in the kernel&amp;rsquo;s syscall table, for instance 9, or a signal name in the format SIGNAME, for instance SIGKILL.</source>
          <target state="translated">该 &lt;code&gt;--stop-signal&lt;/code&gt; 标志设置将被发送到容器退出系统呼叫信号。该信号可以是与内核syscall表中的位置匹配的有效无符号数字（例如9），也可以是格式为SIGNAME的信号名称（例如SIGKILL）。</target>
        </trans-unit>
        <trans-unit id="8846e238508789402dc6ccf956f8dc91d051d006" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--stop-timeout&lt;/code&gt; flag sets the timeout (in seconds) that a pre-defined (see &lt;code&gt;--stop-signal&lt;/code&gt;) system call signal that will be sent to the container to exit. After timeout elapses the container will be killed with SIGKILL.</source>
          <target state="translated">所述 &lt;code&gt;--stop-timeout&lt;/code&gt; 标志设置的超时时间（以秒计）的预定义（参见 &lt;code&gt;--stop-signal&lt;/code&gt; 将被发送到所述容器以出口）系统调用信号。超时后，该容器将被SIGKILL杀死。</target>
        </trans-unit>
        <trans-unit id="5495a7454f1586617a7dc6a7549e59d398007aca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--sysctl&lt;/code&gt; sets namespaced kernel parameters (sysctls) in the container. For example, to turn on IP forwarding in the containers network namespace, run this command:</source>
          <target state="translated">该 &lt;code&gt;--sysctl&lt;/code&gt; 在容器命名空间内核参数（的sysctl）集。例如，要在容器网络名称空间中打开IP转发，请运行以下命令：</target>
        </trans-unit>
        <trans-unit id="854ac408f31454204ac08d0e6423e78b130a7510" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--tmpfs&lt;/code&gt; flag mounts an empty tmpfs into the container with the &lt;code&gt;rw&lt;/code&gt;, &lt;code&gt;noexec&lt;/code&gt;, &lt;code&gt;nosuid&lt;/code&gt;, &lt;code&gt;size=65536k&lt;/code&gt; options.</source>
          <target state="translated">所述 &lt;code&gt;--tmpfs&lt;/code&gt; 标志安装一个空的tmpfs与容器 &lt;code&gt;rw&lt;/code&gt; ， &lt;code&gt;noexec&lt;/code&gt; ， &lt;code&gt;nosuid&lt;/code&gt; ， &lt;code&gt;size=65536k&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="0fa0a35baa2bfba7770838b9ad13455ac8f296b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--update-delay&lt;/code&gt; flag configures the time delay between updates to a service task or sets of tasks. You can describe the time &lt;code&gt;T&lt;/code&gt; as a combination of the number of seconds &lt;code&gt;Ts&lt;/code&gt;, minutes &lt;code&gt;Tm&lt;/code&gt;, or hours &lt;code&gt;Th&lt;/code&gt;. So &lt;code&gt;10m30s&lt;/code&gt; indicates a 10 minute 30 second delay.</source>
          <target state="translated">该 &lt;code&gt;--update-delay&lt;/code&gt; 标志配置更新服务任务或任务集之间的时间延迟。您可以将时间 &lt;code&gt;T&lt;/code&gt; 描述为秒数 &lt;code&gt;Ts&lt;/code&gt; ，分钟 &lt;code&gt;Tm&lt;/code&gt; 或小时 &lt;code&gt;Th&lt;/code&gt; 的组合。因此 &lt;code&gt;10m30s&lt;/code&gt; 表示10分钟30秒的延迟。</target>
        </trans-unit>
        <trans-unit id="934f930ffe6caf2c011d78e9b4448a9de589e06f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--update-max-failure-ratio&lt;/code&gt; flag controls what fraction of tasks can fail during an update before the update as a whole is considered to have failed. For example, with &lt;code&gt;--update-max-failure-ratio 0.1 --update-failure-action pause&lt;/code&gt;, after 10% of the tasks being updated fail, the update is paused.</source>
          <target state="translated">该 &lt;code&gt;--update-max-failure-ratio&lt;/code&gt; 的更新作为一个整体之前更新过程中哪些部分的任务可能会失败标志控制被认为是失败。例如，使用 &lt;code&gt;--update-max-failure-ratio 0.1 --update-failure-action pause&lt;/code&gt; ，在10％的更新任务失败后，更新将暂停。</target>
        </trans-unit>
        <trans-unit id="59ad8b554a390785f6d30eb5a97c2b44cc58fc73" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--virtualbox-boot2docker-url&lt;/code&gt; flag takes a few different forms. By default, if no value is specified for this flag, Machine checks locally for a boot2docker ISO. If one is found, it is used as the ISO for the created machine. If one is not found, the latest ISO release available on &lt;a href=&quot;https://github.com/boot2docker/boot2docker&quot;&gt;boot2docker/boot2docker&lt;/a&gt; is downloaded and stored locally for future use. Therefore, you must run &lt;code&gt;docker-machine upgrade&lt;/code&gt; deliberately on a machine if you wish to update the &amp;ldquo;cached&amp;rdquo; boot2docker ISO.</source>
          <target state="translated">该 &lt;code&gt;--virtualbox-boot2docker-url&lt;/code&gt; 标记需要几个不同的形式。默认情况下，如果没有为此标志指定值，则Machine会在本地检查boot2docker ISO。如果找到一个，则用作创建的计算机的ISO。如果未找到，则会下载&lt;a href=&quot;https://github.com/boot2docker/boot2docker&quot;&gt;boot2docker / boot2docker&lt;/a&gt;上可用的最新ISO版本，并将其存储在本地以供将来使用。因此，如果要更新&amp;ldquo;缓存的&amp;rdquo; boot2docker ISO ，则必须在 &lt;code&gt;docker-machine upgrade&lt;/code&gt; 有意运行docker-machine upgrade。</target>
        </trans-unit>
        <trans-unit id="f4dfe5d38bdec5d1891053f396d04d8f227ea20e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--volume&lt;/code&gt; (or &lt;code&gt;-v&lt;/code&gt;) flag takes a value that is in the format &lt;code&gt;&amp;lt;volume_name&amp;gt;:&amp;lt;mountpoint&amp;gt;&lt;/code&gt;. The two parts of the value are separated by a colon (&lt;code&gt;:&lt;/code&gt;) character.</source>
          <target state="translated">所述 &lt;code&gt;--volume&lt;/code&gt; （或 &lt;code&gt;-v&lt;/code&gt; ）标志取值是在格式 &lt;code&gt;&amp;lt;volume_name&amp;gt;:&amp;lt;mountpoint&amp;gt;&lt;/code&gt; 。（该值的两个部分由冒号分开 &lt;code&gt;:&lt;/code&gt; ）字符。</target>
        </trans-unit>
        <trans-unit id="79c57bd734a2d57c422c7ec0f9b8f3c9c845afa9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--volumes-from&lt;/code&gt; flag mounts all the defined volumes from the referenced containers. Containers can be specified by repetitions of the &lt;code&gt;--volumes-from&lt;/code&gt; argument. The container ID may be optionally suffixed with &lt;code&gt;:ro&lt;/code&gt; or &lt;code&gt;:rw&lt;/code&gt; to mount the volumes in read-only or read-write mode, respectively. By default, the volumes are mounted in the same mode (read write or read only) as the reference container.</source>
          <target state="translated">该 &lt;code&gt;--volumes-from&lt;/code&gt; 标志坐骑都从引用的容器定义卷。可以通过重复 &lt;code&gt;--volumes-from&lt;/code&gt; 参数来指定容器。可以选择在容器ID后缀 &lt;code&gt;:ro&lt;/code&gt; 或 &lt;code&gt;:rw&lt;/code&gt; ,以分别以只读或读写模式安装卷。默认情况下，卷以与引用容器相同的模式（读写或只读）挂载。</target>
        </trans-unit>
        <trans-unit id="a1a5149b5262d073b9c766e953b846fff95d80d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-P&lt;/code&gt; option publishes all the ports to the host interfaces. Docker binds each exposed port to a random port on the host. The range of ports are within an &lt;em&gt;ephemeral port range&lt;/em&gt; defined by &lt;code&gt;/proc/sys/net/ipv4/ip_local_port_range&lt;/code&gt;. Use the &lt;code&gt;-p&lt;/code&gt; flag to explicitly map a single port or range of ports.</source>
          <target state="translated">该 &lt;code&gt;-P&lt;/code&gt; 选项发布的所有端口的主机接口。Docker将每个公开端口绑定到主机上的随机端口。&lt;em&gt;端口范围&lt;/em&gt;在 &lt;code&gt;/proc/sys/net/ipv4/ip_local_port_range&lt;/code&gt; 定义的&lt;em&gt;临时端口范围内&lt;/em&gt;。使用 &lt;code&gt;-p&lt;/code&gt; 标志可以显式映射单个端口或端口范围。</target>
        </trans-unit>
        <trans-unit id="9d187d0c1f780586ccb4a349b371c0d9954d1e7b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-a&lt;/code&gt; flag tells &lt;code&gt;docker run&lt;/code&gt; to bind to the container&amp;rsquo;s &lt;code&gt;STDIN&lt;/code&gt;, &lt;code&gt;STDOUT&lt;/code&gt; or &lt;code&gt;STDERR&lt;/code&gt;. This makes it possible to manipulate the output and input as needed.</source>
          <target state="translated">该 &lt;code&gt;-a&lt;/code&gt; 标志告诉 &lt;code&gt;docker run&lt;/code&gt; 到绑定到容器的 &lt;code&gt;STDIN&lt;/code&gt; ， &lt;code&gt;STDOUT&lt;/code&gt; 或 &lt;code&gt;STDERR&lt;/code&gt; 。这使得可以根据需要操纵输出和输入。</target>
        </trans-unit>
        <trans-unit id="00e78bca83bff0346cfa7bb1929f7a24bd5628d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-b, --bridge=&lt;/code&gt; flag is set to &lt;code&gt;docker0&lt;/code&gt; as default bridge network. It is created automatically when you install Docker. If you are not using the default, you must create and configure the bridge manually or just set it to &amp;lsquo;none&amp;rsquo;: &lt;code&gt;--bridge=none&lt;/code&gt;</source>
          <target state="translated">该 &lt;code&gt;-b, --bridge=&lt;/code&gt; 标志设置为 &lt;code&gt;docker0&lt;/code&gt; 默认桥接网络。它在安装Docker时自动创建。如果未使用默认值，则必须手动创建和配置网桥，或者将其设置为&amp;ldquo; none&amp;rdquo;：-- &lt;code&gt;--bridge=none&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fef31794e25c5885ab349aeec30b37ec9cfb2e31" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-f&lt;/code&gt; flag is optional. If you don&amp;rsquo;t provide this flag on the command line, Compose traverses the working directory and its parent directories looking for a &lt;code&gt;docker-compose.yml&lt;/code&gt; and a &lt;code&gt;docker-compose.override.yml&lt;/code&gt; file. You must supply at least the &lt;code&gt;docker-compose.yml&lt;/code&gt; file. If both files are present on the same directory level, Compose combines the two files into a single configuration.</source>
          <target state="translated">该 &lt;code&gt;-f&lt;/code&gt; 标志是可选的。如果未在命令行上提供此标志，则Compose遍历工作目录及其父目录，以查找 &lt;code&gt;docker-compose.yml&lt;/code&gt; 和 &lt;code&gt;docker-compose.override.yml&lt;/code&gt; 文件。您必须至少 &lt;code&gt;docker-compose.yml&lt;/code&gt; 文件。如果两个文件都位于同一目录级别，则Compose会将两个文件合并为一个配置。</target>
        </trans-unit>
        <trans-unit id="be855a59336774399e3a7b83f1b2b7f1d547f976" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-g&lt;/code&gt; or &lt;code&gt;--graph&lt;/code&gt; flag for the &lt;code&gt;dockerd&lt;/code&gt; or &lt;code&gt;docker daemon&lt;/code&gt; command was used to indicate the directory in which to store persistent data and resource configuration and has been replaced with the more descriptive &lt;code&gt;--data-root&lt;/code&gt; flag.</source>
          <target state="translated">的 &lt;code&gt;-g&lt;/code&gt; 或 &lt;code&gt;--graph&lt;/code&gt; 标志为 &lt;code&gt;dockerd&lt;/code&gt; 或 &lt;code&gt;docker daemon&lt;/code&gt; 使用命令来指示在其中存储持久性数据和资源配置的目录，并已被替换为更具描述 &lt;code&gt;--data-root&lt;/code&gt; 标记。</target>
        </trans-unit>
        <trans-unit id="76c0ec7a2c9ee426e880b46a80e62d861fb434da" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-q&lt;/code&gt; or &lt;code&gt;--quiet&lt;/code&gt; option only shows IDs of the tasks in the stack. This example outputs all task IDs of the &amp;ldquo;voting&amp;rdquo; stack;</source>
          <target state="translated">该 &lt;code&gt;-q&lt;/code&gt; 或 &lt;code&gt;--quiet&lt;/code&gt; 选项只显示在堆栈中的任务标识。此示例输出&amp;ldquo;投票&amp;rdquo;堆栈的所有任务ID；</target>
        </trans-unit>
        <trans-unit id="321f4b5ce4448eb4e35448e4bc0fe2f7c45b6bec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-v&lt;/code&gt; flag mounts the current working directory into the container. The &lt;code&gt;-w&lt;/code&gt; lets the command being executed inside the current working directory, by changing into the directory to the value returned by &lt;code&gt;pwd&lt;/code&gt;. So this combination executes the command using the container, but inside the current working directory.</source>
          <target state="translated">该 &lt;code&gt;-v&lt;/code&gt; 标志安装当前的工作目录到容器中。该 &lt;code&gt;-w&lt;/code&gt; 让当前的工作目录内执行，通过改变进目录中返回的值的命令 &lt;code&gt;pwd&lt;/code&gt; 。因此，此组合使用容器在当前工作目录中执行命令。</target>
        </trans-unit>
        <trans-unit id="6715ad91a3f3e2ea443f1c9685408c8bf699b5f2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-w&lt;/code&gt; lets the command being executed inside directory given, here &lt;code&gt;/path/to/dir/&lt;/code&gt;. If the path does not exist it is created inside the container.</source>
          <target state="translated">该 &lt;code&gt;-w&lt;/code&gt; 让里面给出，这里目录正在执行的命令 &lt;code&gt;/path/to/dir/&lt;/code&gt; 。如果路径不存在，则会在容器内创建该路径。</target>
        </trans-unit>
        <trans-unit id="a07135f67e45c6c5342f6d4af54f3e2573322ad0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.Field&lt;/code&gt; syntax doesn&amp;rsquo;t work when the field name begins with a number, but the template language&amp;rsquo;s &lt;code&gt;index&lt;/code&gt; function does. The &lt;code&gt;.NetworkSettings.Ports&lt;/code&gt; section contains a map of the internal port mappings to a list of external address/port objects. To grab just the numeric public port, you use &lt;code&gt;index&lt;/code&gt; to find the specific port map, and then &lt;code&gt;index&lt;/code&gt; 0 contains the first object inside of that. Then we ask for the &lt;code&gt;HostPort&lt;/code&gt; field to get the public address.</source>
          <target state="translated">该 &lt;code&gt;.Field&lt;/code&gt; 当字段名称以数字开头，但模板语言的语法不起作用 &lt;code&gt;index&lt;/code&gt; 函数的作用。所述 &lt;code&gt;.NetworkSettings.Ports&lt;/code&gt; 部分包含地图内部端口映射到外部地址/端口的对象的列表中。要仅获取数字公共端口，可使用 &lt;code&gt;index&lt;/code&gt; 找到特定的端口映射，然后 &lt;code&gt;index&lt;/code&gt; 0包含其中的第一个对象。然后，我们要求 &lt;code&gt;HostPort&lt;/code&gt; 字段获取公共地址。</target>
        </trans-unit>
        <trans-unit id="b45bcfe28cfbc7bf1e4c9d18f73bcfd15b5b4045" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ADD&lt;/code&gt; instruction copies new files, directories or remote file URLs from &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; and adds them to the filesystem of the image at the path &lt;code&gt;&amp;lt;dest&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;ADD&lt;/code&gt; 指令将新文件，目录或远程文件的URL从 &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; ，并将它们添加到图像的在所述路径中的文件系统 &lt;code&gt;&amp;lt;dest&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fac454db47a7141d94be83ec27a2881ff73c5a77" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ARG&lt;/code&gt; instruction defines a variable that users can pass at build-time to the builder with the &lt;code&gt;docker build&lt;/code&gt; command using the &lt;code&gt;--build-arg &amp;lt;varname&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; flag. If a user specifies a build argument that was not defined in the Dockerfile, the build outputs a warning.</source>
          <target state="translated">所述 &lt;code&gt;ARG&lt;/code&gt; 指令定义的变量，用户可以在生成时传递给构建器与 &lt;code&gt;docker build&lt;/code&gt; 使用命令 &lt;code&gt;--build-arg &amp;lt;varname&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; 标记。如果用户指定了Dockerfile中未定义的构建参数，则该构建会输出警告。</target>
        </trans-unit>
        <trans-unit id="d0ccb62f794462cdcfdf2433ebe70961e4918f85" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;AVAILABILITY&lt;/code&gt; column shows whether or not the scheduler can assign tasks to the node:</source>
          <target state="translated">&amp;ldquo; &lt;code&gt;AVAILABILITY&lt;/code&gt; 列显示调度程序是否可以将任务分配给节点：</target>
        </trans-unit>
        <trans-unit id="417ce49286ee166704f694561cf8b565bdfb59bf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CMD&lt;/code&gt; instruction has three forms:</source>
          <target state="translated">在 &lt;code&gt;CMD&lt;/code&gt; 命令有三种形式：</target>
        </trans-unit>
        <trans-unit id="9a203c026fa9c79445c4b63b7715ada33d208b40" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;COPY&lt;/code&gt; instruction copies new files or directories from &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; and adds them to the filesystem of the container at the path &lt;code&gt;&amp;lt;dest&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;COPY&lt;/code&gt; 从指令将新的文件或目录 &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; ，并将它们添加到容器的文件系统的路径 &lt;code&gt;&amp;lt;dest&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6d9652ade73caed1f5cb10142c1b7360bd4afe13" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Dockerfile&lt;/code&gt; assumes that your application is called &lt;code&gt;aspnetapp&lt;/code&gt;. Change the &lt;code&gt;Dockerfile&lt;/code&gt; to use the DLL file of your project.</source>
          <target state="translated">该 &lt;code&gt;Dockerfile&lt;/code&gt; 假定您的应用程序叫做 &lt;code&gt;aspnetapp&lt;/code&gt; 。将 &lt;code&gt;Dockerfile&lt;/code&gt; 更改为使用项目的DLL文件。</target>
        </trans-unit>
        <trans-unit id="82f6ee7a0e96f694b25ee985575726b6ec82c45b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ENTRYPOINT&lt;/code&gt; of an image is similar to a &lt;code&gt;COMMAND&lt;/code&gt; because it specifies what executable to run when the container starts, but it is (purposely) more difficult to override. The &lt;code&gt;ENTRYPOINT&lt;/code&gt; gives a container its default nature or behavior, so that when you set an &lt;code&gt;ENTRYPOINT&lt;/code&gt; you can run the container &lt;em&gt;as if it were that binary&lt;/em&gt;, complete with default options, and you can pass in more options via the &lt;code&gt;COMMAND&lt;/code&gt;. But, sometimes an operator may want to run something else inside the container, so you can override the default &lt;code&gt;ENTRYPOINT&lt;/code&gt; at runtime by using a string to specify the new &lt;code&gt;ENTRYPOINT&lt;/code&gt;. Here is an example of how to run a shell in a container that has been set up to automatically run something else (like &lt;code&gt;/usr/bin/redis-server&lt;/code&gt;):</source>
          <target state="translated">映像的 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 与 &lt;code&gt;COMMAND&lt;/code&gt; 相似，因为它指定了容器启动时要运行的可执行文件，但是（故意）更难以覆盖。该 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 给出了一个容器它的默认性质或行为，所以，当你设置一个 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 就可以运行容器&lt;em&gt;，就好像它是二进制&lt;/em&gt;，完全使用默认选项，并且可以在通过更多的选择传递 &lt;code&gt;COMMAND&lt;/code&gt; 。但是，有时运营商可能需要运行在容器内别的东西，这样你就可以覆盖默认 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 使用字符串来指定新的在运行时 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 。这是一个如何在已设置为自动运行其他内容（例如 &lt;code&gt;/usr/bin/redis-server&lt;/code&gt; ）的容器中运行Shell的示例：</target>
        </trans-unit>
        <trans-unit id="45551afa7e325e55770cef5ae4c690193b754077" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ENV&lt;/code&gt; instruction has two forms. The first form, &lt;code&gt;ENV &amp;lt;key&amp;gt; &amp;lt;value&amp;gt;&lt;/code&gt;, will set a single variable to a value. The entire string after the first space will be treated as the &lt;code&gt;&amp;lt;value&amp;gt;&lt;/code&gt; - including whitespace characters. The value will be interpreted for other environment variables, so quote characters will be removed if they are not escaped.</source>
          <target state="translated">该 &lt;code&gt;ENV&lt;/code&gt; 指令有两种形式。第一种形式 &lt;code&gt;ENV &amp;lt;key&amp;gt; &amp;lt;value&amp;gt;&lt;/code&gt; 会将单个变量设置为一个值。第一个空格之后的整个字符串将被视为 &lt;code&gt;&amp;lt;value&amp;gt;&lt;/code&gt; -包括空格字符。该值将为其他环境变量解释，因此如果不对引号字符进行转义，则将其删除。</target>
        </trans-unit>
        <trans-unit id="e26b1f9ce0f2c0c2eaf61a3bc6b69242e0d92f5f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ENV&lt;/code&gt; instruction sets the environment variable &lt;code&gt;&amp;lt;key&amp;gt;&lt;/code&gt; to the value &lt;code&gt;&amp;lt;value&amp;gt;&lt;/code&gt;. This value will be in the environment for all subsequent instructions in the build stage and can be &lt;a href=&quot;#environment-replacement&quot;&gt;replaced inline&lt;/a&gt; in many as well.</source>
          <target state="translated">在 &lt;code&gt;ENV&lt;/code&gt; 指令设置环境变量 &lt;code&gt;&amp;lt;key&amp;gt;&lt;/code&gt; 为值 &lt;code&gt;&amp;lt;value&amp;gt;&lt;/code&gt; 。此值将在构建阶段中所有后续指令的环境中使用，并且可以在很多情况下&lt;a href=&quot;#environment-replacement&quot;&gt;内联替换&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7f497b45d5ed2e762023ba2fab7f21dad19db409" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;EXPOSE&lt;/code&gt; instruction does not actually publish the port. It functions as a type of documentation between the person who builds the image and the person who runs the container, about which ports are intended to be published. To actually publish the port when running the container, use the &lt;code&gt;-p&lt;/code&gt; flag on &lt;code&gt;docker run&lt;/code&gt; to publish and map one or more ports, or the &lt;code&gt;-P&lt;/code&gt; flag to publish all exposed ports and map them to high-order ports.</source>
          <target state="translated">该 &lt;code&gt;EXPOSE&lt;/code&gt; 指令实际上没有公布的端口。它充当构建映像的人员和运行容器的人员之间的一种文档类型，有关打算发布哪些端口的信息。要在运行容器时实际发布端口，请在 &lt;code&gt;docker run&lt;/code&gt; 上使用 &lt;code&gt;-p&lt;/code&gt; 标志发布并映射一个或多个端口，或使用 &lt;code&gt;-P&lt;/code&gt; 标志发布所有公开的端口并将其映射到高阶端口。</target>
        </trans-unit>
        <trans-unit id="645f60437d027833327e4b44fb9a229f2bfb6400" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;EXPOSE&lt;/code&gt; instruction informs Docker that the container listens on the specified network ports at runtime. You can specify whether the port listens on TCP or UDP, and the default is TCP if the protocol is not specified.</source>
          <target state="translated">所述 &lt;code&gt;EXPOSE&lt;/code&gt; 指令INFORMS泊坞上在运行时指定的网络端口的容器监听。您可以指定端口是侦听TCP还是UDP，如果未指定协议，则默认值为TCP。</target>
        </trans-unit>
        <trans-unit id="716562e8a5dadfe33cef2e8369dbac6cc00b394f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FROM&lt;/code&gt; instruction initializes a new build stage and sets the &lt;a href=&quot;https://docs.docker.com/engine/reference/glossary/#base-image&quot;&gt;&lt;em&gt;Base Image&lt;/em&gt;&lt;/a&gt; for subsequent instructions. As such, a valid &lt;code&gt;Dockerfile&lt;/code&gt; must start with a &lt;code&gt;FROM&lt;/code&gt; instruction. The image can be any valid image &amp;ndash; it is especially easy to start by &lt;strong&gt;pulling an image&lt;/strong&gt; from the &lt;a href=&quot;../../../get-started/index&quot;&gt;&lt;em&gt;Public Repositories&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;FROM&lt;/code&gt; 指令初始化一个新的构建阶段，并设置&lt;a href=&quot;https://docs.docker.com/engine/reference/glossary/#base-image&quot;&gt;&lt;em&gt;基本映像&lt;/em&gt;&lt;/a&gt;用于随后的指令。因此，有效的 &lt;code&gt;Dockerfile&lt;/code&gt; 必须以 &lt;code&gt;FROM&lt;/code&gt; 指令开头。该图像可以是任何有效图像- 从&lt;a href=&quot;../../../get-started/index&quot;&gt;&lt;em&gt;公共存储库中&lt;/em&gt;&lt;/a&gt;&lt;strong&gt;拉出图像&lt;/strong&gt;特别容易启动。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="42ec5b4969dc13ba5cb34f54cea73cb4d3f05903" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FROM&lt;/code&gt; tag is pulling a signed image. You cannot build an image that has a &lt;code&gt;FROM&lt;/code&gt; that is not either present locally or signed. Given that content trust data exists for the tag &lt;code&gt;latest&lt;/code&gt;, the following build should succeed:</source>
          <target state="translated">在 &lt;code&gt;FROM&lt;/code&gt; 标签拉签署图像。您无法生成具有不在本地显示或未签名的 &lt;code&gt;FROM&lt;/code&gt; 的图像。鉴于对标签内容存在信任数据 &lt;code&gt;latest&lt;/code&gt; ，下面的构建应该成功：</target>
        </trans-unit>
        <trans-unit id="c2e9d22e237ec841e63406770ce97846d2dc59a3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HEALTHCHECK&lt;/code&gt; feature was added in Docker 1.12.</source>
          <target state="translated">该 &lt;code&gt;HEALTHCHECK&lt;/code&gt; 功能在多克1.12加。</target>
        </trans-unit>
        <trans-unit id="8d43fa4cfb4ede6f95d66b190829555714301acf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HEALTHCHECK&lt;/code&gt; instruction has two forms:</source>
          <target state="translated">该 &lt;code&gt;HEALTHCHECK&lt;/code&gt; 指令有两种形式：</target>
        </trans-unit>
        <trans-unit id="ea5519b5379f448f3642a0d47adc25774c5c8041" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HEALTHCHECK&lt;/code&gt; instruction tells Docker how to test a container to check that it is still working. This can detect cases such as a web server that is stuck in an infinite loop and unable to handle new connections, even though the server process is still running.</source>
          <target state="translated">在 &lt;code&gt;HEALTHCHECK&lt;/code&gt; 指令告诉码头工人如何进行测试的容器，以检查它是否仍在工作。这样可以检测到诸如Web服务器陷入无限循环并且无法处理新连接的情况，即使服务器进程仍在运行。</target>
        </trans-unit>
        <trans-unit id="2b7ee116d84bdf3e73f6a2de56ebf95b883e1a00" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LABEL&lt;/code&gt; instruction adds metadata to an image. A &lt;code&gt;LABEL&lt;/code&gt; is a key-value pair. To include spaces within a &lt;code&gt;LABEL&lt;/code&gt; value, use quotes and backslashes as you would in command-line parsing. A few usage examples:</source>
          <target state="translated">该 &lt;code&gt;LABEL&lt;/code&gt; 指令将元数据的图像。甲 &lt;code&gt;LABEL&lt;/code&gt; 是一个键-值对。要在 &lt;code&gt;LABEL&lt;/code&gt; 值中包含空格，请像在命令行分析中一样使用引号和反斜杠。一些用法示例：</target>
        </trans-unit>
        <trans-unit id="67a0a8cc35e4d2e1aa6af5e6fbd62bde27b51ec1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MAINTAINER&lt;/code&gt; instruction sets the &lt;em&gt;Author&lt;/em&gt; field of the generated images. The &lt;code&gt;LABEL&lt;/code&gt; instruction is a much more flexible version of this and you should use it instead, as it enables setting any metadata you require, and can be viewed easily, for example with &lt;code&gt;docker inspect&lt;/code&gt;. To set a label corresponding to the &lt;code&gt;MAINTAINER&lt;/code&gt; field you could use:</source>
          <target state="translated">该 &lt;code&gt;MAINTAINER&lt;/code&gt; 指令集的&lt;em&gt;作者&lt;/em&gt;所生成的图像的领域。 &lt;code&gt;LABEL&lt;/code&gt; 指令是此指令的更灵活的版本，您应该改用它，因为它可以设置所需的任何元数据，并且可以轻松查看，例如使用 &lt;code&gt;docker inspect&lt;/code&gt; 。要设置与 &lt;code&gt;MAINTAINER&lt;/code&gt; 字段相对应的标签，可以使用：</target>
        </trans-unit>
        <trans-unit id="67ebbb70f1473098a5c74c9ab58cb56302be856a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MANAGER STATUS&lt;/code&gt; column shows node participation in the Raft consensus:</source>
          <target state="translated">该 &lt;code&gt;MANAGER STATUS&lt;/code&gt; 在筏共识列显示节点的参与：</target>
        </trans-unit>
        <trans-unit id="f7c7704a78191792a1d8655bea11a83fc3049b98" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MANAGER&lt;/code&gt; column identifies the manager nodes in the swarm. The empty status in this column for &lt;code&gt;worker1&lt;/code&gt; and &lt;code&gt;worker2&lt;/code&gt; identifies them as worker nodes.</source>
          <target state="translated">在 &lt;code&gt;MANAGER&lt;/code&gt; 列标识在群经理节点。 &lt;code&gt;worker1&lt;/code&gt; 和 &lt;code&gt;worker2&lt;/code&gt; 在此列中的空状态将其标识为工作程序节点。</target>
        </trans-unit>
        <trans-unit id="501ef9a7f35fb49486364828614f2e22487de202" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Mountpoint&lt;/code&gt; is the path on the host (v1) or in the plugin (v2) where the volume has been made available.</source>
          <target state="translated">该 &lt;code&gt;Mountpoint&lt;/code&gt; 是在主机（V1），或在音量已经可用的插件（V2）的路径。</target>
        </trans-unit>
        <trans-unit id="f72509df1f3a093ed48e1717dc925c13dc152b72" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ONBUILD&lt;/code&gt; instruction adds to the image a &lt;em&gt;trigger&lt;/em&gt; instruction to be executed at a later time, when the image is used as the base for another build. The trigger will be executed in the context of the downstream build, as if it had been inserted immediately after the &lt;code&gt;FROM&lt;/code&gt; instruction in the downstream &lt;code&gt;Dockerfile&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;ONBUILD&lt;/code&gt; 指令增加了图像的&lt;em&gt;扳机&lt;/em&gt;在稍后的时间将要执行的指令，当图像被用作基地另一个构建。触发器将在下游构建的上下文中执行，就像它已被插入到下游 &lt;code&gt;Dockerfile&lt;/code&gt; 中的 &lt;code&gt;FROM&lt;/code&gt; 指令之后一样。</target>
        </trans-unit>
        <trans-unit id="a097269ed1f1efba8a2d1de1fbc25ad35e65dfc3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PLUGIN_ID&lt;/code&gt; value is either the plugin&amp;rsquo;s name or a path to its specification file. The plugin&amp;rsquo;s implementation determines whether you can specify a name or path. Consult with your Docker administrator to get information about the plugins available to you.</source>
          <target state="translated">该 &lt;code&gt;PLUGIN_ID&lt;/code&gt; 值是插件的名称或它的规范文件的路径。插件的实现确定您是否可以指定名称或路径。请咨询您的Docker管理员以获取有关可用插件的信息。</target>
        </trans-unit>
        <trans-unit id="3340492be3828b9c868ba42851749e55259a3bbe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;REPLICAS&lt;/code&gt; column shows both the &lt;em&gt;actual&lt;/em&gt; and &lt;em&gt;desired&lt;/em&gt; number of tasks for the service.</source>
          <target state="translated">该 &lt;code&gt;REPLICAS&lt;/code&gt; 列显示无论是&lt;em&gt;实际&lt;/em&gt;和&lt;em&gt;所需&lt;/em&gt;的服务任务的数量。</target>
        </trans-unit>
        <trans-unit id="870bd21b88f50c54e7de0b3f963b7fc150117ad9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RUN&lt;/code&gt; instruction will execute any commands in a new layer on top of the current image and commit the results. The resulting committed image will be used for the next step in the &lt;code&gt;Dockerfile&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;RUN&lt;/code&gt; 指令将在当前图像的顶部上的新的层执行任何命令和提交的结果。生成的提交映像将用于 &lt;code&gt;Dockerfile&lt;/code&gt; 中的下一步。</target>
        </trans-unit>
        <trans-unit id="aee97a7ef2f533b4a208999ce506515a16a4128f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SHELL&lt;/code&gt; feature was added in Docker 1.12.</source>
          <target state="translated">该 &lt;code&gt;SHELL&lt;/code&gt; 功能在多克1.12加。</target>
        </trans-unit>
        <trans-unit id="1f46243e9474ba3fbb5fc42070b6a0e810312875" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SHELL&lt;/code&gt; instruction allows the default shell used for the &lt;em&gt;shell&lt;/em&gt; form of commands to be overridden. The default shell on Linux is &lt;code&gt;[&quot;/bin/sh&quot;, &quot;-c&quot;]&lt;/code&gt;, and on Windows is &lt;code&gt;[&quot;cmd&quot;, &quot;/S&quot;, &quot;/C&quot;]&lt;/code&gt;. The &lt;code&gt;SHELL&lt;/code&gt; instruction &lt;em&gt;must&lt;/em&gt; be written in JSON form in a Dockerfile.</source>
          <target state="translated">所述 &lt;code&gt;SHELL&lt;/code&gt; 指令允许用于默认壳&lt;em&gt;壳&lt;/em&gt;命令的形式被重写。在Linux上，默认shell是 &lt;code&gt;[&quot;/bin/sh&quot;, &quot;-c&quot;]&lt;/code&gt; ，在Windows 上，默认shell 是 &lt;code&gt;[&quot;cmd&quot;, &quot;/S&quot;, &quot;/C&quot;]&lt;/code&gt; 。该 &lt;code&gt;SHELL&lt;/code&gt; 指令&lt;em&gt;必须&lt;/em&gt;写成JSON形式在Dockerfile。</target>
        </trans-unit>
        <trans-unit id="1163d8948bca451e34ca883bf4efe7959b615e7e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SHELL&lt;/code&gt; instruction can also be used on Linux should an alternate shell be required such as &lt;code&gt;zsh&lt;/code&gt;, &lt;code&gt;csh&lt;/code&gt;, &lt;code&gt;tcsh&lt;/code&gt; and others.</source>
          <target state="translated">如果需要备用shell（例如 &lt;code&gt;zsh&lt;/code&gt; ， &lt;code&gt;csh&lt;/code&gt; ， &lt;code&gt;tcsh&lt;/code&gt; 等），也可以在Linux上使用 &lt;code&gt;SHELL&lt;/code&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="9402e574cf122018a583eec5b329c405d3666b7b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SHELL&lt;/code&gt; instruction can appear multiple times. Each &lt;code&gt;SHELL&lt;/code&gt; instruction overrides all previous &lt;code&gt;SHELL&lt;/code&gt; instructions, and affects all subsequent instructions. For example:</source>
          <target state="translated">该 &lt;code&gt;SHELL&lt;/code&gt; 指令可以出现多次。每个 &lt;code&gt;SHELL&lt;/code&gt; 指令将覆盖所有先前的 &lt;code&gt;SHELL&lt;/code&gt; 指令，并影响所有后续的指令。例如：</target>
        </trans-unit>
        <trans-unit id="e98590ef0a2096201cca8d93674ffaef975a01dc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SHELL&lt;/code&gt; instruction could also be used to modify the way in which a shell operates. For example, using &lt;code&gt;SHELL cmd /S /C /V:ON|OFF&lt;/code&gt; on Windows, delayed environment variable expansion semantics could be modified.</source>
          <target state="translated">该 &lt;code&gt;SHELL&lt;/code&gt; 指令也可以用来修改其中一个壳的运作方式。例如，在Windows上使用 &lt;code&gt;SHELL cmd /S /C /V:ON|OFF&lt;/code&gt; ，可以修改延迟的环境变量扩展语义。</target>
        </trans-unit>
        <trans-unit id="6298e85aed297aa06c04ef1003db81ec2c7ef26c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SHELL&lt;/code&gt; instruction is particularly useful on Windows where there are two commonly used and quite different native shells: &lt;code&gt;cmd&lt;/code&gt; and &lt;code&gt;powershell&lt;/code&gt;, as well as alternate shells available including &lt;code&gt;sh&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;SHELL&lt;/code&gt; ：其中有两种常用的和完全不同的本机指令壳是在Windows特别有用的 &lt;code&gt;cmd&lt;/code&gt; 和 &lt;code&gt;powershell&lt;/code&gt; ，以及包括可用的备用壳 &lt;code&gt;sh&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="70da59d5f956e683e513e4afc1818bb61971fb54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SIGNED TAG&lt;/code&gt; is the signed image tag with a unique content-addressable &lt;code&gt;DIGEST&lt;/code&gt;. &lt;code&gt;SIGNERS&lt;/code&gt; lists all entities who have signed.</source>
          <target state="translated">在 &lt;code&gt;SIGNED TAG&lt;/code&gt; 是一个独特的内容寻址签名的图像标签 &lt;code&gt;DIGEST&lt;/code&gt; 。 &lt;code&gt;SIGNERS&lt;/code&gt; 列出了所有已签署的实体。</target>
        </trans-unit>
        <trans-unit id="1d1da3c14a5462c93cead1c428e7eedd8878cdc2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SIZE&lt;/code&gt; is the cumulative space taken up by the image and all its parent images. This is also the disk space used by the contents of the Tar file created when you &lt;code&gt;docker save&lt;/code&gt; an image.</source>
          <target state="translated">该 &lt;code&gt;SIZE&lt;/code&gt; 是由图像和所有其父图像所占用的空间累积。这也是 &lt;code&gt;docker save&lt;/code&gt; 映像时创建的Tar文件内容所使用的磁盘空间。</target>
        </trans-unit>
        <trans-unit id="1541d778170a621d3c22bd5b6e13485df9fa5abd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;STOPSIGNAL&lt;/code&gt; instruction sets the system call signal that will be sent to the container to exit. This signal can be a valid unsigned number that matches a position in the kernel&amp;rsquo;s syscall table, for instance 9, or a signal name in the format SIGNAME, for instance SIGKILL.</source>
          <target state="translated">该 &lt;code&gt;STOPSIGNAL&lt;/code&gt; 指令集将被发送到容器退出系统呼叫信号。该信号可以是与内核syscall表中的位置匹配的有效无符号数字（例如9），也可以是格式为SIGNAME的信号名称（例如SIGKILL）。</target>
        </trans-unit>
        <trans-unit id="3510f8e32a94f048c18787c43f116f8b2b1db4b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SignedTags&lt;/code&gt; key will list the &lt;code&gt;SignedTag&lt;/code&gt; name, its &lt;code&gt;Digest&lt;/code&gt;, and the &lt;code&gt;Signers&lt;/code&gt; responsible for the signature.</source>
          <target state="translated">该 &lt;code&gt;SignedTags&lt;/code&gt; 键将列出 &lt;code&gt;SignedTag&lt;/code&gt; 名称， &lt;code&gt;Digest&lt;/code&gt; ，以及 &lt;code&gt;Signers&lt;/code&gt; 负责签名。</target>
        </trans-unit>
        <trans-unit id="0a3f768c13747f5e7ee4e46e620852cfb97cee1b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TLSConfig&lt;/code&gt; field is optional and TLS will only be verified if this configuration is present.</source>
          <target state="translated">所述 &lt;code&gt;TLSConfig&lt;/code&gt; 字段是可选的，并且如果该配置是本TLS将只进行验证。</target>
        </trans-unit>
        <trans-unit id="c93989b2fb4eaed0d00803c2508edabbae9aa2ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;URL&lt;/code&gt; parameter can refer to three kinds of resources: Git repositories, pre-packaged tarball contexts and plain text files.</source>
          <target state="translated">该 &lt;code&gt;URL&lt;/code&gt; 参数是指三种类型的资源：Git仓库，预包装的压缩包上下文和纯文本文件。</target>
        </trans-unit>
        <trans-unit id="995c1b14070453923cd78f9b81be5fac37fc342e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;USER&lt;/code&gt; at line 2 evaluates to &lt;code&gt;some_user&lt;/code&gt; as the &lt;code&gt;user&lt;/code&gt; variable is defined on the subsequent line 3. The &lt;code&gt;USER&lt;/code&gt; at line 4 evaluates to &lt;code&gt;what_user&lt;/code&gt; as &lt;code&gt;user&lt;/code&gt; is defined and the &lt;code&gt;what_user&lt;/code&gt; value was passed on the command line. Prior to its definition by an &lt;code&gt;ARG&lt;/code&gt; instruction, any use of a variable results in an empty string.</source>
          <target state="translated">在 &lt;code&gt;USER&lt;/code&gt; 在第2次的计算结果为 &lt;code&gt;some_user&lt;/code&gt; 作为 &lt;code&gt;user&lt;/code&gt; 变量对后续线3所定义的 &lt;code&gt;USER&lt;/code&gt; 在第4次的计算结果为 &lt;code&gt;what_user&lt;/code&gt; 作为 &lt;code&gt;user&lt;/code&gt; 被定义并且 &lt;code&gt;what_user&lt;/code&gt; 值在命令行上通过。在通过 &lt;code&gt;ARG&lt;/code&gt; 指令对其进行定义之前，对变量的任何使用都会导致一个空字符串。</target>
        </trans-unit>
        <trans-unit id="b2b6c1993ea47bca5c16249690dcc2cdf3b59597" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;USER&lt;/code&gt; instruction sets the user name (or UID) and optionally the user group (or GID) to use when running the image and for any &lt;code&gt;RUN&lt;/code&gt;, &lt;code&gt;CMD&lt;/code&gt; and &lt;code&gt;ENTRYPOINT&lt;/code&gt; instructions that follow it in the &lt;code&gt;Dockerfile&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;USER&lt;/code&gt; 运行图像时和指令集来使用的用户名（或UID）和任选的所述用户组（或GID）对于任何 &lt;code&gt;RUN&lt;/code&gt; ， &lt;code&gt;CMD&lt;/code&gt; 和 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 它后面中的说明 &lt;code&gt;Dockerfile&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d33671ff9ff81e4a1193fb055f7f6d6cbdaea5a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VOLUME&lt;/code&gt; instruction creates a mount point with the specified name and marks it as holding externally mounted volumes from native host or other containers. The value can be a JSON array, &lt;code&gt;VOLUME [&quot;/var/log/&quot;]&lt;/code&gt;, or a plain string with multiple arguments, such as &lt;code&gt;VOLUME /var/log&lt;/code&gt; or &lt;code&gt;VOLUME /var/log /var/db&lt;/code&gt;. For more information/examples and mounting instructions via the Docker client, refer to &lt;a href=&quot;https://docs.docker.com/storage#/mount-a-host-directory-as-a-data-volume&quot;&gt;&lt;em&gt;Share Directories via Volumes&lt;/em&gt;&lt;/a&gt; documentation.</source>
          <target state="translated">的 &lt;code&gt;VOLUME&lt;/code&gt; 指令创建具有指定名称和作为保持外部安装的从天然宿主或其他容器中的卷痕它一个安装点。该值可以是JSON数组 &lt;code&gt;VOLUME [&quot;/var/log/&quot;]&lt;/code&gt; ，也可以是带有多个参数的纯字符串，例如 &lt;code&gt;VOLUME /var/log&lt;/code&gt; 或 &lt;code&gt;VOLUME /var/log /var/db&lt;/code&gt; 。有关通过Docker客户端的更多信息/示例和安装说明，请参阅&lt;a href=&quot;https://docs.docker.com/storage#/mount-a-host-directory-as-a-data-volume&quot;&gt;&lt;em&gt;通过Volumes共享目录&lt;/em&gt;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8e27e606679dcb2a5aacc2d44d5f337f925fc0fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;WORKDIR&lt;/code&gt; instruction can be used multiple times in a &lt;code&gt;Dockerfile&lt;/code&gt;. If a relative path is provided, it will be relative to the path of the previous &lt;code&gt;WORKDIR&lt;/code&gt; instruction. For example:</source>
          <target state="translated">所述 &lt;code&gt;WORKDIR&lt;/code&gt; 指令可在多次使用 &lt;code&gt;Dockerfile&lt;/code&gt; 。如果提供了相对路径，则它将相对于上一个 &lt;code&gt;WORKDIR&lt;/code&gt; 指令的路径。例如：</target>
        </trans-unit>
        <trans-unit id="4a147d370a985d02c05500bdc3abd64abc4f75c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;WORKDIR&lt;/code&gt; instruction can resolve environment variables previously set using &lt;code&gt;ENV&lt;/code&gt;. You can only use environment variables explicitly set in the &lt;code&gt;Dockerfile&lt;/code&gt;. For example:</source>
          <target state="translated">该 &lt;code&gt;WORKDIR&lt;/code&gt; 指令可以解决环境变量之前使用设置 &lt;code&gt;ENV&lt;/code&gt; 。您只能使用在 &lt;code&gt;Dockerfile&lt;/code&gt; 中显式设置的环境变量。例如：</target>
        </trans-unit>
        <trans-unit id="c841bd1ff530bf145434255ac0536325cb79900e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;WORKDIR&lt;/code&gt; instruction sets the working directory for any &lt;code&gt;RUN&lt;/code&gt;, &lt;code&gt;CMD&lt;/code&gt;, &lt;code&gt;ENTRYPOINT&lt;/code&gt;, &lt;code&gt;COPY&lt;/code&gt; and &lt;code&gt;ADD&lt;/code&gt; instructions that follow it in the &lt;code&gt;Dockerfile&lt;/code&gt;. If the &lt;code&gt;WORKDIR&lt;/code&gt; doesn&amp;rsquo;t exist, it will be created even if it&amp;rsquo;s not used in any subsequent &lt;code&gt;Dockerfile&lt;/code&gt; instruction.</source>
          <target state="translated">该 &lt;code&gt;WORKDIR&lt;/code&gt; 指令集的工作目录对任何 &lt;code&gt;RUN&lt;/code&gt; ， &lt;code&gt;CMD&lt;/code&gt; ， &lt;code&gt;ENTRYPOINT&lt;/code&gt; ， &lt;code&gt;COPY&lt;/code&gt; 和 &lt;code&gt;ADD&lt;/code&gt; 它后面的说明 &lt;code&gt;Dockerfile&lt;/code&gt; 。如果 &lt;code&gt;WORKDIR&lt;/code&gt; 不存在，即使以后的 &lt;code&gt;Dockerfile&lt;/code&gt; 指令中未使用它，也将创建它。</target>
        </trans-unit>
        <trans-unit id="2dd0484854b35b2483fd38a2b7dc3bb5dc5ef886" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[REPOSITORY[:TAG]]&lt;/code&gt; value must be an &amp;ldquo;exact match&amp;rdquo;. This means that, for example, &lt;code&gt;docker images jav&lt;/code&gt; does not match the image &lt;code&gt;java&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;[REPOSITORY[:TAG]]&lt;/code&gt; 值必须是一个&amp;ldquo;精确匹配&amp;rdquo;。这意味着，例如， &lt;code&gt;docker images jav&lt;/code&gt; 与映像 &lt;code&gt;java&lt;/code&gt; 不匹配。</target>
        </trans-unit>
        <trans-unit id="13597d6a87d88f87cf53223339f91d85dd2b2aff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ancestor&lt;/code&gt; filter matches containers based on its image or a descendant of it. The filter supports the following image representation:</source>
          <target state="translated">该 &lt;code&gt;ancestor&lt;/code&gt; 过滤器匹配基于它的形象或它的后代在集装箱上。过滤器支持以下图像表示形式：</target>
        </trans-unit>
        <trans-unit id="e2af6f0edf436040d36923f5820566c22d471ac5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;aufs&lt;/code&gt; driver is the oldest, but is based on a Linux kernel patch-set that is unlikely to be merged into the main kernel. These are also known to cause some serious kernel crashes. However &lt;code&gt;aufs&lt;/code&gt; allows containers to share executable and shared library memory, so is a useful choice when running thousands of containers with the same program or libraries.</source>
          <target state="translated">该 &lt;code&gt;aufs&lt;/code&gt; 司机是最古老的，而是基于Linux内核补丁集是不太可能被合并到主内核中。还已知这些会导致严重的内核崩溃。但是 &lt;code&gt;aufs&lt;/code&gt; 允许容器共享可执行文件和共享库的内存，因此在使用相同程序或库运行数千个容器时，这是一个有用的选择。</target>
        </trans-unit>
        <trans-unit id="d21264ed9be94f59b90f635a011c3e1c7dccb1ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;aufs&lt;/code&gt; storage driver facilitates running Docker on distros that have no support for OverlayFS, such as Ubuntu 14.04 LTS, which originally shipped with a 3.14 kernel.</source>
          <target state="translated">该 &lt;code&gt;aufs&lt;/code&gt; 上有OverlayFS不支持，比如Ubuntu 14.04 LTS，原本附带了3.14发行版内核运行多克存储驱动程序便利。</target>
        </trans-unit>
        <trans-unit id="ac5b8e87a209b84e7e37fcdb8a390ec2e2305090" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;aufs&lt;/code&gt; storage driver is deprecated in favor of &lt;code&gt;overlay2&lt;/code&gt;, and will be removed in a future release. Users of the &lt;code&gt;aufs&lt;/code&gt; storage driver are recommended to migrate to a different storage driver, such as &lt;code&gt;overlay2&lt;/code&gt;, which is now the default storage driver.</source>
          <target state="translated">不推荐使用 &lt;code&gt;aufs&lt;/code&gt; 存储驱动程序，而建议使用 &lt;code&gt;overlay2&lt;/code&gt; ，并且在将来的版本中将删除该驱动程序。建议 &lt;code&gt;aufs&lt;/code&gt; 存储驱动程序的用户迁移到其他存储驱动程序，例如 &lt;code&gt;overlay2&lt;/code&gt; ，现在是默认存储驱动程序。</target>
        </trans-unit>
        <trans-unit id="043c98c9bd9cb2795c2de8bf56042b5344260468" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;before&lt;/code&gt; filter shows only containers created before the container with given id or name. For example, having these containers created:</source>
          <target state="translated">该 &lt;code&gt;before&lt;/code&gt; 过滤器只显示容器与给定id或名称容器之前创建的。例如，创建以下容器：</target>
        </trans-unit>
        <trans-unit id="074d496d9037bf300f47a0466f625105ef5ae8c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;before&lt;/code&gt; filter shows only images created before the image with given id or reference. For example, having these images:</source>
          <target state="translated">的 &lt;code&gt;before&lt;/code&gt; 过滤器示出了与给定id或参考图像之前仅创建图像。例如，具有以下图像：</target>
        </trans-unit>
        <trans-unit id="680eea36a92a6d600ce8f2d291b3dabb1fd2b4f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bind-propagation&lt;/code&gt; option defaults to &lt;code&gt;rprivate&lt;/code&gt; for both bind mounts and volume mounts, and is only configurable for bind mounts. In other words, named volumes do not support bind propagation.</source>
          <target state="translated">所述 &lt;code&gt;bind-propagation&lt;/code&gt; 选项默认为 &lt;code&gt;rprivate&lt;/code&gt; 两个绑定安装和卷安装，并且仅用于绑定安装配置。换句话说，命名卷不支持绑定传播。</target>
        </trans-unit>
        <trans-unit id="67f07157a985d84dcd79e8d91f8e6b76da258ccb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;btrfs&lt;/code&gt; driver is very fast for &lt;code&gt;docker build&lt;/code&gt; - but like &lt;code&gt;devicemapper&lt;/code&gt; does not share executable memory between devices. Use &lt;code&gt;dockerd -s btrfs -g /mnt/btrfs_partition&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;btrfs&lt;/code&gt; 驱动程序是非常快的 &lt;code&gt;docker build&lt;/code&gt; -但像 &lt;code&gt;devicemapper&lt;/code&gt; 不会在设备之间共享可执行的内存。使用 &lt;code&gt;dockerd -s btrfs -g /mnt/btrfs_partition&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc0ba098ceac4dd5ea14ad79d5a4ce5bb841ef45" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;capability&lt;/code&gt; filter matches on plugin capabilities. One plugin might have multiple capabilities. Currently &lt;code&gt;volumedriver&lt;/code&gt;, &lt;code&gt;networkdriver&lt;/code&gt;, &lt;code&gt;ipamdriver&lt;/code&gt;, &lt;code&gt;logdriver&lt;/code&gt;, &lt;code&gt;metricscollector&lt;/code&gt;, and &lt;code&gt;authz&lt;/code&gt; are supported capabilities.</source>
          <target state="translated">该 &lt;code&gt;capability&lt;/code&gt; 过滤器上的插件功能相匹配。一个插件可能具有多种功能。目前 &lt;code&gt;volumedriver&lt;/code&gt; ， &lt;code&gt;networkdriver&lt;/code&gt; ， &lt;code&gt;ipamdriver&lt;/code&gt; ， &lt;code&gt;logdriver&lt;/code&gt; ， &lt;code&gt;metricscollector&lt;/code&gt; 和 &lt;code&gt;authz&lt;/code&gt; 支持能力。</target>
        </trans-unit>
        <trans-unit id="fdecbd9da265febad688f0f54cfcc497df8b3feb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;config.json&lt;/code&gt; file describes the plugin. See the &lt;a href=&quot;config/index&quot;&gt;plugins config reference&lt;/a&gt;.</source>
          <target state="translated">在 &lt;code&gt;config.json&lt;/code&gt; 文件描述了插件。请参阅&lt;a href=&quot;config/index&quot;&gt;插件配置参考&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="736cffcd57446baeaf57dc1d916874f3ab44b5a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;config.json&lt;/code&gt; file stores a JSON encoding of several properties:</source>
          <target state="translated">在 &lt;code&gt;config.json&lt;/code&gt; 文件存储几个属性的编码JSON：</target>
        </trans-unit>
        <trans-unit id="2310e282ca831fa888d8ebbe5bcaac153cd3667b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;container-dest&lt;/code&gt; must always be an absolute path such as &lt;code&gt;/src/docs&lt;/code&gt;. The &lt;code&gt;host-src&lt;/code&gt; can either be an absolute path or a &lt;code&gt;name&lt;/code&gt; value. If you supply an absolute path for the &lt;code&gt;host-dir&lt;/code&gt;, Docker bind-mounts to the path you specify. If you supply a &lt;code&gt;name&lt;/code&gt;, Docker creates a named volume by that &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;container-dest&lt;/code&gt; 必须始终是绝对路径如 &lt;code&gt;/src/docs&lt;/code&gt; 。该 &lt;code&gt;host-src&lt;/code&gt; 可以是绝对路径或 &lt;code&gt;name&lt;/code&gt; 值。如果您提供 &lt;code&gt;host-dir&lt;/code&gt; 的绝对路径，则Docker将绑定绑定到您指定的路径。如果提供 &lt;code&gt;name&lt;/code&gt; ，则Docker将使用该 &lt;code&gt;name&lt;/code&gt; 创建一个命名卷。</target>
        </trans-unit>
        <trans-unit id="8630a18f96c819b6fc8d9fb47228d4ec089bb06b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;container:...&lt;/code&gt; formats are only supported in the &lt;a href=&quot;../compose-versioning/index#version-2&quot;&gt;version 2 file format&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;container:...&lt;/code&gt; 格式只在支持的&lt;a href=&quot;../compose-versioning/index#version-2&quot;&gt;版本2的文件格式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fc1a8fdb596af07bb07751edfd381fdce594be84" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;content-trust&lt;/code&gt; flag is based around a &lt;code&gt;mode&lt;/code&gt; variable instructing the engine whether to enforce signed images, and a &lt;code&gt;trust-pinning&lt;/code&gt; variable instructing the engine which sources to trust.</source>
          <target state="translated">所述 &lt;code&gt;content-trust&lt;/code&gt; 标志被基于一个 &lt;code&gt;mode&lt;/code&gt; 变量指示该发动机是否执行签名的图像，和一个 &lt;code&gt;trust-pinning&lt;/code&gt; 变量指示发动机，其来源的信任。</target>
        </trans-unit>
        <trans-unit id="012a8331c2e0e74449f2ab7bb73efed40ea1a1e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cp&lt;/code&gt; command behaves like the Unix &lt;code&gt;cp -a&lt;/code&gt; command in that directories are copied recursively with permissions preserved if possible. Ownership is set to the user and primary group at the destination. For example, files copied to a container are created with &lt;code&gt;UID:GID&lt;/code&gt; of the root user. Files copied to the local machine are created with the &lt;code&gt;UID:GID&lt;/code&gt; of the user which invoked the &lt;code&gt;docker cp&lt;/code&gt; command. However, if you specify the &lt;code&gt;-a&lt;/code&gt; option, &lt;code&gt;docker cp&lt;/code&gt; sets the ownership to the user and primary group at the source. If you specify the &lt;code&gt;-L&lt;/code&gt; option, &lt;code&gt;docker cp&lt;/code&gt; follows any symbolic link in the &lt;code&gt;SRC_PATH&lt;/code&gt;. &lt;code&gt;docker cp&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; create parent directories for &lt;code&gt;DEST_PATH&lt;/code&gt; if they do not exist.</source>
          <target state="translated">在 &lt;code&gt;cp&lt;/code&gt; 命令的行为像Unix &lt;code&gt;cp -a&lt;/code&gt; 在目录命令与可能的话保存权限递归复制。所有权设置为目标用户和主要组。例如，使用根用户的 &lt;code&gt;UID:GID&lt;/code&gt; 创建复制到容器的文件。复制到本地计算机的文件是使用调用 &lt;code&gt;docker cp&lt;/code&gt; 命令的用户的 &lt;code&gt;UID:GID&lt;/code&gt; 创建的。但是，如果您指定 &lt;code&gt;-a&lt;/code&gt; 选项，则 &lt;code&gt;docker cp&lt;/code&gt; 将所有权设置为源处的用户和主要组。如果指定 &lt;code&gt;-L&lt;/code&gt; 选项，则 &lt;code&gt;SRC_PATH&lt;/code&gt; &lt;code&gt;docker cp&lt;/code&gt; 遵循SRC_PATH中的任何符号链接。 &lt;code&gt;docker cp&lt;/code&gt; 并&lt;em&gt;不会&lt;/em&gt;创建父目录 &lt;code&gt;DEST_PATH&lt;/code&gt; 如果他们不存在。</target>
        </trans-unit>
        <trans-unit id="d47ce5d678976a7476b0c18e9222d25c8a694629" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dangling&lt;/code&gt; filter matches on all volumes not referenced by any containers</source>
          <target state="translated">在 &lt;code&gt;dangling&lt;/code&gt; 上没有任何容器所引用的所有卷过滤器匹配</target>
        </trans-unit>
        <trans-unit id="ca501fcadca0fc33fcf1980848e49bf924e5837a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;depends_on&lt;/code&gt; option is ignored when &lt;a href=&quot;../../engine/reference/commandline/stack_deploy/index&quot;&gt;deploying a stack in swarm mode&lt;/a&gt; with a version 3 Compose file.</source>
          <target state="translated">该 &lt;code&gt;depends_on&lt;/code&gt; 当选项被忽略&lt;a href=&quot;../../engine/reference/commandline/stack_deploy/index&quot;&gt;部署在群模式堆栈&lt;/a&gt;与第3版撰写的文件。</target>
        </trans-unit>
        <trans-unit id="a10821048e200222decc18b5caa6ef73360f3e65" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deploy&lt;/code&gt; command supports compose file version &lt;code&gt;3.0&lt;/code&gt; and above.</source>
          <target state="translated">所述 &lt;code&gt;deploy&lt;/code&gt; 命令支持撰写的文件版本 &lt;code&gt;3.0&lt;/code&gt; 和以上。</target>
        </trans-unit>
        <trans-unit id="d97f79dd18614fb6309fc4cb7e75346b229c6a7d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;desired-state&lt;/code&gt; filter can take the values &lt;code&gt;running&lt;/code&gt;, &lt;code&gt;shutdown&lt;/code&gt;, or &lt;code&gt;accepted&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;desired-state&lt;/code&gt; 过滤器可以采取的值 &lt;code&gt;running&lt;/code&gt; ， &lt;code&gt;shutdown&lt;/code&gt; ，或 &lt;code&gt;accepted&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c577e679b95985fa19b5d2c2ba04dd7e2e5beeaf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;devicemapper&lt;/code&gt; driver uses thin provisioning and Copy on Write (CoW) snapshots. For each devicemapper graph location &amp;ndash; typically &lt;code&gt;/var/lib/docker/devicemapper&lt;/code&gt; &amp;ndash; a thin pool is created based on two block devices, one for data and one for metadata. By default, these block devices are created automatically by using loopback mounts of automatically created sparse files. Refer to &lt;a href=&quot;#devicemapper-options&quot;&gt;Devicemapper options&lt;/a&gt; below for a way how to customize this setup. &lt;a href=&quot;http://jpetazzo.github.io/2014/01/29/docker-device-mapper-resize/&quot;&gt;~jpetazzo/Resizing Docker containers with the Device Mapper plugin&lt;/a&gt; article explains how to tune your existing setup without the use of options.</source>
          <target state="translated">该 &lt;code&gt;devicemapper&lt;/code&gt; 驱动程序使用自动精简配置和写时拷贝（全体）的快照。对于每个devicemapper图形位置-通常是 &lt;code&gt;/var/lib/docker/devicemapper&lt;/code&gt; -基于两个块设备创建一个精简池，一个用于数据，另一个用于元数据。默认情况下，这些块设备是通过使用自动创建的稀疏文件的环回安装来自动创建的。有关如何自定义此设置的方法，请参阅下面的&lt;a href=&quot;#devicemapper-options&quot;&gt;Devicemapper选项&lt;/a&gt;。&lt;a href=&quot;http://jpetazzo.github.io/2014/01/29/docker-device-mapper-resize/&quot;&gt;〜jpetazzo /使用Device Mapper插件调整Docker容器大小的&lt;/a&gt;文章介绍了如何在不使用选项的情况下调整现有设置。</target>
        </trans-unit>
        <trans-unit id="941fb0922c6070e3d2140cfe4d235f0c8f11171d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;devicemapper&lt;/code&gt; driver uses thin provisioning and Copy on Write (CoW) snapshots. For each devicemapper graph location &amp;ndash; typically &lt;code&gt;/var/lib/docker/devicemapper&lt;/code&gt; &amp;ndash; a thin pool is created based on two block devices, one for data and one for metadata. By default, these block devices are created automatically by using loopback mounts of automatically created sparse files. Refer to &lt;a href=&quot;#devicemapper-options&quot;&gt;Devicemapper options&lt;/a&gt; below for a way how to customize this setup. &lt;a href=&quot;https://jpetazzo.github.io/2014/01/29/docker-device-mapper-resize/&quot;&gt;~jpetazzo/Resizing Docker containers with the Device Mapper plugin&lt;/a&gt; article explains how to tune your existing setup without the use of options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bccd0195d721f403d76a89afd53f755e0c58494d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;devicemapper&lt;/code&gt; storage driver facilitates running Docker on older (3.x) kernels that have no support for other storage drivers (such as overlay2, or AUFS).</source>
          <target state="translated">该 &lt;code&gt;devicemapper&lt;/code&gt; 上有其他存储驱动程序（如overlay2，或AUFS）不支持较早的（3.X）内核运行多克存储驱动程序便利。</target>
        </trans-unit>
        <trans-unit id="89272b2ed83b2ae8d4a0b79b32cc9955f7c51e27" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;devicemapper&lt;/code&gt; storage driver is deprecated in favor of &lt;code&gt;overlay2&lt;/code&gt;, and will be removed in a future release. Users of the &lt;code&gt;devicemapper&lt;/code&gt; storage driver are recommended to migrate to a different storage driver, such as &lt;code&gt;overlay2&lt;/code&gt;, which is now the default storage driver.</source>
          <target state="translated">该 &lt;code&gt;devicemapper&lt;/code&gt; 存储驱动程序被弃用，取而代之的 &lt;code&gt;overlay2&lt;/code&gt; ，并会在将来的版本中删除。建议 &lt;code&gt;devicemapper&lt;/code&gt; 存储驱动程序的用户迁移到其他存储驱动程序，例如 &lt;code&gt;overlay2&lt;/code&gt; ，现在是默认存储驱动程序。</target>
        </trans-unit>
        <trans-unit id="07ecd732b3bd07e8737e552d0f0bcba3e4908ea3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;disable-legacy-registry&lt;/code&gt; configuration option has been removed and, when used, will produce an error on daemon startup.</source>
          <target state="translated">该 &lt;code&gt;disable-legacy-registry&lt;/code&gt; 配置选项已被删除，并在使用时，会产生对守护进程启动错误。</target>
        </trans-unit>
        <trans-unit id="4a497a0da289a9d8c0ef81082723389a06ffe41a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker build&lt;/code&gt; command builds Docker images from a Dockerfile and a &amp;ldquo;context&amp;rdquo;. A build&amp;rsquo;s context is the set of files located in the specified &lt;code&gt;PATH&lt;/code&gt; or &lt;code&gt;URL&lt;/code&gt;. The build process can refer to any of the files in the context. For example, your build can use a &lt;a href=&quot;../../builder/index#copy&quot;&gt;&lt;em&gt;COPY&lt;/em&gt;&lt;/a&gt; instruction to reference a file in the context.</source>
          <target state="translated">该 &lt;code&gt;docker build&lt;/code&gt; 命令从Dockerfile和&amp;ldquo;上下文&amp;rdquo;建立多克的图像。构建的上下文是位于指定 &lt;code&gt;PATH&lt;/code&gt; 或 &lt;code&gt;URL&lt;/code&gt; 中的文件集。构建过程可以引用上下文中的任何文件。例如，您的构建可以使用&lt;a href=&quot;../../builder/index#copy&quot;&gt;&lt;em&gt;COPY&lt;/em&gt;&lt;/a&gt;指令在上下文中引用文件。</target>
        </trans-unit>
        <trans-unit id="8d00da26adc0934efef97a4a66ba07d087391f9f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker cp&lt;/code&gt; command assumes container paths are relative to the container&amp;rsquo;s &lt;code&gt;/&lt;/code&gt; (root) directory. This means supplying the initial forward slash is optional; The command sees &lt;code&gt;compassionate_darwin:/tmp/foo/myfile.txt&lt;/code&gt; and &lt;code&gt;compassionate_darwin:tmp/foo/myfile.txt&lt;/code&gt; as identical. Local machine paths can be an absolute or relative value. The command interprets a local machine&amp;rsquo;s relative paths as relative to the current working directory where &lt;code&gt;docker cp&lt;/code&gt; is run.</source>
          <target state="translated">的 &lt;code&gt;docker cp&lt;/code&gt; 命令假定容器路径相对于所述容器的 &lt;code&gt;/&lt;/code&gt; （根）目录下。这意味着提供初始正斜杠是可选的。该命令将 &lt;code&gt;compassionate_darwin:/tmp/foo/myfile.txt&lt;/code&gt; 和 &lt;code&gt;compassionate_darwin:tmp/foo/myfile.txt&lt;/code&gt; 视为相同。本地机器路径可以是绝对值或相对值。该命令将本地计算机的相对路径解释为相对于运行 &lt;code&gt;docker cp&lt;/code&gt; 的当前工作目录的相对路径。</target>
        </trans-unit>
        <trans-unit id="f0488fda8ff3401a355142d0109c0774079f4704" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker cp&lt;/code&gt; utility copies the contents of &lt;code&gt;SRC_PATH&lt;/code&gt; to the &lt;code&gt;DEST_PATH&lt;/code&gt;. You can copy from the container&amp;rsquo;s file system to the local machine or the reverse, from the local filesystem to the container. If &lt;code&gt;-&lt;/code&gt; is specified for either the &lt;code&gt;SRC_PATH&lt;/code&gt; or &lt;code&gt;DEST_PATH&lt;/code&gt;, you can also stream a tar archive from &lt;code&gt;STDIN&lt;/code&gt; or to &lt;code&gt;STDOUT&lt;/code&gt;. The &lt;code&gt;CONTAINER&lt;/code&gt; can be a running or stopped container. The &lt;code&gt;SRC_PATH&lt;/code&gt; or &lt;code&gt;DEST_PATH&lt;/code&gt; can be a file or directory.</source>
          <target state="translated">该 &lt;code&gt;docker cp&lt;/code&gt; 程序拷贝的内容 &lt;code&gt;SRC_PATH&lt;/code&gt; 到 &lt;code&gt;DEST_PATH&lt;/code&gt; 。您可以从容器的文件系统复制到本地计算机，也可以从容器的文件系统复制到本地文件系统。如果为 &lt;code&gt;SRC_PATH&lt;/code&gt; 或 &lt;code&gt;DEST_PATH&lt;/code&gt; 指定 &lt;code&gt;-&lt;/code&gt; ，则还可以将tar归档从 &lt;code&gt;STDIN&lt;/code&gt; 或 &lt;code&gt;STDOUT&lt;/code&gt; 流式传输。该 &lt;code&gt;CONTAINER&lt;/code&gt; 可以是运行或停止容器。该 &lt;code&gt;SRC_PATH&lt;/code&gt; 或 &lt;code&gt;DEST_PATH&lt;/code&gt; 可以是文件或目录。</target>
        </trans-unit>
        <trans-unit id="2d84e65b44b0ace486ef052eb68a53a9c7db22eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker create&lt;/code&gt; command creates a writeable container layer over the specified image and prepares it for running the specified command. The container ID is then printed to &lt;code&gt;STDOUT&lt;/code&gt;. This is similar to &lt;code&gt;docker run -d&lt;/code&gt; except the container is never started. You can then use the &lt;code&gt;docker start &amp;lt;container_id&amp;gt;&lt;/code&gt; command to start the container at any point.</source>
          <target state="translated">的 &lt;code&gt;docker create&lt;/code&gt; 命令创建在所述指定的图像的可写容器层并准备将其运行指定的命令。然后将容器ID打印到 &lt;code&gt;STDOUT&lt;/code&gt; 。这与 &lt;code&gt;docker run -d&lt;/code&gt; 相似，除了容器从未启动。然后，您可以随时使用 &lt;code&gt;docker start &amp;lt;container_id&amp;gt;&lt;/code&gt; 命令启动容器。</target>
        </trans-unit>
        <trans-unit id="9e49c5596561af85a1388d3ee7f38cdf68214b18" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker exec&lt;/code&gt; command runs a new command in a running container.</source>
          <target state="translated">该 &lt;code&gt;docker exec&lt;/code&gt; 命令运行在运行中的容器的新命令。</target>
        </trans-unit>
        <trans-unit id="36a4345c685a94da4a4d72493c8dd4b169284353" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker export&lt;/code&gt; command does not export the contents of volumes associated with the container. If a volume is mounted on top of an existing directory in the container, &lt;code&gt;docker export&lt;/code&gt; will export the contents of the &lt;em&gt;underlying&lt;/em&gt; directory, not the contents of the volume.</source>
          <target state="translated">该 &lt;code&gt;docker export&lt;/code&gt; 的命令不导出与容器相关卷的内容。如果将卷安装在容器中现有目录的顶部，则 &lt;code&gt;docker export&lt;/code&gt; 将导出&lt;em&gt;基础&lt;/em&gt;目录的内容，而不是卷的内容。</target>
        </trans-unit>
        <trans-unit id="212faf92123f1bd5dad504ad0c9711f075a2a885" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker images&lt;/code&gt; command takes an optional &lt;code&gt;[REPOSITORY[:TAG]]&lt;/code&gt; argument that restricts the list to images that match the argument. If you specify &lt;code&gt;REPOSITORY&lt;/code&gt;but no &lt;code&gt;TAG&lt;/code&gt;, the &lt;code&gt;docker images&lt;/code&gt; command lists all images in the given repository.</source>
          <target state="translated">的 &lt;code&gt;docker images&lt;/code&gt; 命令有一个可选的 &lt;code&gt;[REPOSITORY[:TAG]]&lt;/code&gt; 限制所述列表相匹配的论点，即图像参数。如果您指定 &lt;code&gt;REPOSITORY&lt;/code&gt; 但未指定 &lt;code&gt;TAG&lt;/code&gt; ，则 &lt;code&gt;docker images&lt;/code&gt; 命令会列出给定存储库中的所有图像。</target>
        </trans-unit>
        <trans-unit id="9cf01d6be8fbd1ded8fffe4de73a77b12d992e6f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker import&lt;/code&gt; command format &lt;code&gt;file|URL|- [REPOSITORY [TAG]]&lt;/code&gt; is deprecated since November 2013. It&amp;rsquo;s no more supported.</source>
          <target state="translated">该 &lt;code&gt;docker import&lt;/code&gt; 命令格式 &lt;code&gt;file|URL|- [REPOSITORY [TAG]]&lt;/code&gt; 自2013年11月，没有更多的支持已被弃用。</target>
        </trans-unit>
        <trans-unit id="dce7f5061f028dd79b6c9199c2e8844396289e6d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker kill&lt;/code&gt; subcommand kills one or more containers. The main process inside the container is sent &lt;code&gt;SIGKILL&lt;/code&gt; signal (default), or the signal that is specified with the &lt;code&gt;--signal&lt;/code&gt; option. You can kill a container using the container&amp;rsquo;s ID, ID-prefix, or name.</source>
          <target state="translated">该 &lt;code&gt;docker kill&lt;/code&gt; 子杀一个或多个容器。容器内的主进程被发送 &lt;code&gt;SIGKILL&lt;/code&gt; 信号（默认），或使用 &lt;code&gt;--signal&lt;/code&gt; 选项指定的信号。您可以使用容器的ID，ID前缀或名称杀死容器。</target>
        </trans-unit>
        <trans-unit id="d43c3096a9a9284aa348945d30f3d5d392ae079e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker logs --details&lt;/code&gt; command will add on extra attributes, such as environment variables and labels, provided to &lt;code&gt;--log-opt&lt;/code&gt; when creating the container.</source>
          <target state="translated">该 &lt;code&gt;docker logs --details&lt;/code&gt; 命令将增加额外的上的属性，如环境变量和标签，提供给 &lt;code&gt;--log-opt&lt;/code&gt; 创建容器时。</target>
        </trans-unit>
        <trans-unit id="e5948949f42d952f60c7708fcce602b9cb6dc943" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker logs --follow&lt;/code&gt; command will continue streaming the new output from the container&amp;rsquo;s &lt;code&gt;STDOUT&lt;/code&gt; and &lt;code&gt;STDERR&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;docker logs --follow&lt;/code&gt; 命令将继续流从容器的新的输出 &lt;code&gt;STDOUT&lt;/code&gt; 和 &lt;code&gt;STDERR&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d8a9ca6208ff085d23a305e8d1993aaa303ef846" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker logs --timestamps&lt;/code&gt; command will add an &lt;a href=&quot;https://golang.org/pkg/time/#pkg-constants&quot;&gt;RFC3339Nano timestamp&lt;/a&gt; , for example &lt;code&gt;2014-09-16T06:17:46.000000000Z&lt;/code&gt;, to each log entry. To ensure that the timestamps are aligned the nano-second part of the timestamp will be padded with zero when necessary.</source>
          <target state="translated">的 &lt;code&gt;docker logs --timestamps&lt;/code&gt; 命令将增加一个&lt;a href=&quot;https://golang.org/pkg/time/#pkg-constants&quot;&gt;RFC3339Nano时间戳&lt;/a&gt;，例如 &lt;code&gt;2014-09-16T06:17:46.000000000Z&lt;/code&gt; ，每个日志条目。为了确保时间戳对齐，必要时将在时间戳的纳秒部分填充零。</target>
        </trans-unit>
        <trans-unit id="f379943afa430ee6b50ed771213d592f53df6cd9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker logs&lt;/code&gt; command batch-retrieves logs present at the time of execution.</source>
          <target state="translated">的 &lt;code&gt;docker logs&lt;/code&gt; 命令分批检索日志在执行时存在。</target>
        </trans-unit>
        <trans-unit id="6b969e0fdf69b61cfacee42a371cb8dcea9a37c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker logs&lt;/code&gt; command is available only for the &lt;code&gt;json-file&lt;/code&gt; and &lt;code&gt;journald&lt;/code&gt; logging drivers. For detailed information on working with logging drivers, see &lt;a href=&quot;https://docs.docker.com/config/containers/logging/configure/&quot;&gt;Configure logging drivers&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;docker logs&lt;/code&gt; 命令只对可 &lt;code&gt;json-file&lt;/code&gt; 和 &lt;code&gt;journald&lt;/code&gt; 记录的驱动程序。有关使用日志记录驱动程序的详细信息，请参阅&amp;ldquo; &lt;a href=&quot;https://docs.docker.com/config/containers/logging/configure/&quot;&gt;配置日志记录驱动程序&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="55752f0f1f17d3b512c98898ce7574796f4e5407" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker manifest inspect&lt;/code&gt; command takes an optional &lt;code&gt;--verbose&lt;/code&gt; flag that gives you the image&amp;rsquo;s name (Ref), and architecture and os (Platform).</source>
          <target state="translated">该 &lt;code&gt;docker manifest inspect&lt;/code&gt; 命令有一个可选的 &lt;code&gt;--verbose&lt;/code&gt; 标志，让你的形象的名称（参考），以及架构和操作系统（平台）。</target>
        </trans-unit>
        <trans-unit id="6c3ad1c2e88a035ec19fe4201ac4b782caf157a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker manifest&lt;/code&gt; command by itself performs no action. In order to operate on a manifest or manifest list, one of the subcommands must be used.</source>
          <target state="translated">该 &lt;code&gt;docker manifest&lt;/code&gt; 命令本身不执行任何操作。为了对清单或清单列表进行操作，必须使用子命令之一。</target>
        </trans-unit>
        <trans-unit id="75c99ddf08d348672ee86f07f42d81770f1637c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker pause&lt;/code&gt; command suspends all processes in the specified containers. On Linux, this uses the cgroups freezer. Traditionally, when suspending a process the &lt;code&gt;SIGSTOP&lt;/code&gt; signal is used, which is observable by the process being suspended. With the cgroups freezer the process is unaware, and unable to capture, that it is being suspended, and subsequently resumed. On Windows, only Hyper-V containers can be paused.</source>
          <target state="translated">的 &lt;code&gt;docker pause&lt;/code&gt; 命令暂停在指定的容器的所有进程。在Linux上，这使用cgroups冷冻机。传统上，在挂起进程时会使用 &lt;code&gt;SIGSTOP&lt;/code&gt; 信号，该信号可以通过挂起的进程观察到。使用cgroups冷冻机时，该过程将不知道并且无法捕获，该过程已被挂起，随后又恢复。在Windows上，只能暂停Hyper-V容器。</target>
        </trans-unit>
        <trans-unit id="d4fcb5e9f179d47f06df5ff0e7c5e4b7f44e31e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker ps --before&lt;/code&gt; and &lt;code&gt;docker ps --since&lt;/code&gt; options are deprecated. Use &lt;code&gt;docker ps --filter=before=...&lt;/code&gt; and &lt;code&gt;docker ps --filter=since=...&lt;/code&gt; instead.</source>
          <target state="translated">由于不推荐使用 &lt;code&gt;docker ps --since&lt;/code&gt; &lt;code&gt;docker ps --before&lt;/code&gt; 和docker ps- 使用 &lt;code&gt;docker ps --filter=before=...&lt;/code&gt; 和 &lt;code&gt;docker ps --filter=since=...&lt;/code&gt; 代替。</target>
        </trans-unit>
        <trans-unit id="c88758404e46e53d12887c5e58b9a83faebb4784" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker ps&lt;/code&gt; command only shows running containers by default. To see all containers, use the &lt;code&gt;-a&lt;/code&gt; (or &lt;code&gt;--all&lt;/code&gt;) flag:</source>
          <target state="translated">该 &lt;code&gt;docker ps&lt;/code&gt; 命令只显示在默认情况下运行的容器。要查看所有容器，请使用 &lt;code&gt;-a&lt;/code&gt; （或 &lt;code&gt;--all&lt;/code&gt; ）标志：</target>
        </trans-unit>
        <trans-unit id="60742f07fa12b395820e597a3d69a0275c37092a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker rename&lt;/code&gt; command renames a container.</source>
          <target state="translated">的 &lt;code&gt;docker rename&lt;/code&gt; 命令重命名的容器。</target>
        </trans-unit>
        <trans-unit id="349b19b1df93f399fb4b343e7c3f1b48014c976d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker run&lt;/code&gt; command can be used in combination with &lt;code&gt;docker commit&lt;/code&gt; to &lt;a href=&quot;../commit/index&quot;&gt;&lt;em&gt;change the command that a container runs&lt;/em&gt;&lt;/a&gt;. There is additional detailed information about &lt;code&gt;docker run&lt;/code&gt; in the &lt;a href=&quot;../../run/index&quot;&gt;Docker run reference&lt;/a&gt;.</source>
          <target state="translated">的 &lt;code&gt;docker run&lt;/code&gt; 命令可以在与组合使用 &lt;code&gt;docker commit&lt;/code&gt; 到&lt;a href=&quot;../commit/index&quot;&gt;&lt;em&gt;更改命令，一个容器中运行&lt;/em&gt;&lt;/a&gt;。&lt;a href=&quot;../../run/index&quot;&gt;Docker运行参考&lt;/a&gt;中提供了有关 &lt;code&gt;docker run&lt;/code&gt; 的其他详细信息。</target>
        </trans-unit>
        <trans-unit id="4cbc062ae7a3f96974d3b09cc48a4d036bab9de4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker run&lt;/code&gt; command first &lt;code&gt;creates&lt;/code&gt; a writeable container layer over the specified image, and then &lt;code&gt;starts&lt;/code&gt; it using the specified command. That is, &lt;code&gt;docker run&lt;/code&gt; is equivalent to the API &lt;code&gt;/containers/create&lt;/code&gt; then &lt;code&gt;/containers/(id)/start&lt;/code&gt;. A stopped container can be restarted with all its previous changes intact using &lt;code&gt;docker start&lt;/code&gt;. See &lt;code&gt;docker ps -a&lt;/code&gt; to view a list of all containers.</source>
          <target state="translated">的 &lt;code&gt;docker run&lt;/code&gt; 命令第一 &lt;code&gt;creates&lt;/code&gt; 在所述指定的图像的可写容器层，然后 &lt;code&gt;starts&lt;/code&gt; 使用指定的命令它。也就是说， &lt;code&gt;docker run&lt;/code&gt; 等效于API &lt;code&gt;/containers/create&lt;/code&gt; then &lt;code&gt;/containers/(id)/start&lt;/code&gt; 。可以使用 &lt;code&gt;docker start&lt;/code&gt; 重新启动已停止的容器，使其之前的所有更改保持不变。请参阅 &lt;code&gt;docker ps -a&lt;/code&gt; 查看所有容器的列表。</target>
        </trans-unit>
        <trans-unit id="a8db5978a7d7f7646bc12237ae6823cb2607d57b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker run&lt;/code&gt; command initializes the newly created volume with any data that exists at the specified location within the base image. For example, consider the following Dockerfile snippet:</source>
          <target state="translated">的 &lt;code&gt;docker run&lt;/code&gt; 命令初始化与存在于基本图像内的指定位置的任何数据新创建的卷。例如，考虑以下Dockerfile片段：</target>
        </trans-unit>
        <trans-unit id="08f6f844a66eaa6760e5fe6294cac62a9f838920" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker run&lt;/code&gt; command must specify an &lt;a href=&quot;https://docs.docker.com/engine/reference/glossary/#image&quot;&gt;&lt;em&gt;IMAGE&lt;/em&gt;&lt;/a&gt; to derive the container from. An image developer can define image defaults related to:</source>
          <target state="translated">该 &lt;code&gt;docker run&lt;/code&gt; 命令必须指定一个&lt;a href=&quot;https://docs.docker.com/engine/reference/glossary/#image&quot;&gt;&lt;em&gt;图像&lt;/em&gt;&lt;/a&gt;导出从容器。图像开发人员可以定义与以下内容有关的图像默认值：</target>
        </trans-unit>
        <trans-unit id="e7e7fcd62d448b7d3efd101f9754749e96cc06f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker search --automated&lt;/code&gt; and &lt;code&gt;docker search --stars&lt;/code&gt; options are deprecated. Use &lt;code&gt;docker search --filter=is-automated=...&lt;/code&gt; and &lt;code&gt;docker search --filter=stars=...&lt;/code&gt; instead.</source>
          <target state="translated">该 &lt;code&gt;docker search --automated&lt;/code&gt; 和 &lt;code&gt;docker search --stars&lt;/code&gt; 选项已被弃用。使用 &lt;code&gt;docker search --filter=is-automated=...&lt;/code&gt; 和 &lt;code&gt;docker search --filter=stars=...&lt;/code&gt; 代替。</target>
        </trans-unit>
        <trans-unit id="4aabab092cfe3cb42af64ee2c599a695b974e3cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker service create&lt;/code&gt; command creates the service.</source>
          <target state="translated">该 &lt;code&gt;docker service create&lt;/code&gt; 命令创建该服务。</target>
        </trans-unit>
        <trans-unit id="5cff7ed0601c6010af07e5b704b1ef7693421a0f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker service logs --details&lt;/code&gt; command will add on extra attributes, such as environment variables and labels, provided to &lt;code&gt;--log-opt&lt;/code&gt; when creating the service.</source>
          <target state="translated">该 &lt;code&gt;docker service logs --details&lt;/code&gt; 命令将增加额外的上的属性，如环境变量和标签，提供给 &lt;code&gt;--log-opt&lt;/code&gt; 创建服务时。</target>
        </trans-unit>
        <trans-unit id="3b1a61f7542a854c2c468b381383555fd4a0e0a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker service logs --follow&lt;/code&gt; command will continue streaming the new output from the service&amp;rsquo;s &lt;code&gt;STDOUT&lt;/code&gt; and &lt;code&gt;STDERR&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;docker service logs --follow&lt;/code&gt; 命令将继续从流媒体服务的新的输出 &lt;code&gt;STDOUT&lt;/code&gt; 和 &lt;code&gt;STDERR&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ec273344485322eeae5f9cae2c1a61b08d484ffb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker service logs --timestamps&lt;/code&gt; command will add an &lt;a href=&quot;https://golang.org/pkg/time/#pkg-constants&quot;&gt;RFC3339Nano timestamp&lt;/a&gt; , for example &lt;code&gt;2014-09-16T06:17:46.000000000Z&lt;/code&gt;, to each log entry. To ensure that the timestamps are aligned the nano-second part of the timestamp will be padded with zero when necessary.</source>
          <target state="translated">该 &lt;code&gt;docker service logs --timestamps&lt;/code&gt; 命令将增加一个&lt;a href=&quot;https://golang.org/pkg/time/#pkg-constants&quot;&gt;RFC3339Nano时间戳&lt;/a&gt;，例如 &lt;code&gt;2014-09-16T06:17:46.000000000Z&lt;/code&gt; ，每个日志条目。为了确保时间戳对齐，必要时将在时间戳的纳秒部分填充零。</target>
        </trans-unit>
        <trans-unit id="10d50fd68ded8731e1e0d64ba1ecf10befcfd427" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker service logs&lt;/code&gt; command batch-retrieves logs present at the time of execution.</source>
          <target state="translated">的 &lt;code&gt;docker service logs&lt;/code&gt; 命令分批检索日志在执行时存在。</target>
        </trans-unit>
        <trans-unit id="640c1ffd784e8f72b9a5490dec23bcb47dfb66cb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker service logs&lt;/code&gt; command can be used with either the name or ID of a service, or with the ID of a task. If a service is passed, it will display logs for all of the containers in that service. If a task is passed, it will only display logs from that particular task.</source>
          <target state="translated">的 &lt;code&gt;docker service logs&lt;/code&gt; 命令可以用名称或ID的服务的，或与任务的ID来使用。如果传递了服务，它将显示该服务中所有容器的日志。如果通过任务，它将仅显示该特定任务的日志。</target>
        </trans-unit>
        <trans-unit id="3d6799e8fd809602d47bbaef1fed0086a066b9cb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker service scale&lt;/code&gt; command allows you to set the desired number of tasks for multiple services at once. The following example scales both the backend and frontend services:</source>
          <target state="translated">该 &lt;code&gt;docker service scale&lt;/code&gt; 命令允许您一次为多个服务任务所需数量。以下示例同时扩展了后端和前端服务：</target>
        </trans-unit>
        <trans-unit id="35f8643610a500188dc8fdf3f7c0514e81a3046b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker stack&lt;/code&gt; command supports defining configs in a Compose file. However, the &lt;code&gt;configs&lt;/code&gt; key is not supported for &lt;code&gt;docker compose&lt;/code&gt;. See &lt;a href=&quot;../../../compose/compose-file/index#configs&quot;&gt;the Compose file reference&lt;/a&gt; for details.</source>
          <target state="translated">的 &lt;code&gt;docker stack&lt;/code&gt; 命令支持限定在撰写文件CONFIGS。但是， &lt;code&gt;docker compose&lt;/code&gt; 不支持 &lt;code&gt;configs&lt;/code&gt; 键。有关详细信息，请参见&lt;a href=&quot;../../../compose/compose-file/index#configs&quot;&gt;撰写文件参考&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e37aaf9ed0cf3abb97c6ae7c0ac113e4a6d55b78" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker stats&lt;/code&gt; command returns a live data stream for running containers. To limit data to one or more specific containers, specify a list of container names or ids separated by a space. You can specify a stopped container but stopped containers do not return any data.</source>
          <target state="translated">该 &lt;code&gt;docker stats&lt;/code&gt; 命令返回运行容器实况数据流。要将数据限制到一个或多个特定容器，请指定一列用空格分隔的容器名称或ID。您可以指定一个停止的容器，但是停止的容器不返回任何数据。</target>
        </trans-unit>
        <trans-unit id="ffa34f440b12b822742a35ad1b0ae9e02c01aede" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker swarm join&lt;/code&gt; command does the following:</source>
          <target state="translated">该 &lt;code&gt;docker swarm join&lt;/code&gt; 命令执行以下操作：</target>
        </trans-unit>
        <trans-unit id="3824f90f3968e4e8230115835228e6aebae8ad0c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker system df&lt;/code&gt; command displays information regarding the amount of disk space used by the docker daemon.</source>
          <target state="translated">的 &lt;code&gt;docker system df&lt;/code&gt; 命令显示信息有关的磁盘空间由搬运工守护进程的用量。</target>
        </trans-unit>
        <trans-unit id="db1650195cef112b49d3648c9d83e1ec42925b18" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker unpause&lt;/code&gt; command un-suspends all processes in the specified containers. On Linux, it does this using the cgroups freezer.</source>
          <target state="translated">在 &lt;code&gt;docker unpause&lt;/code&gt; 命令取消暂停在指定的容器的所有进程。在Linux上，它使用cgroups冷冻机执行此操作。</target>
        </trans-unit>
        <trans-unit id="e36a30f337ce860b63b6680f160a9b4d5546b044" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker update&lt;/code&gt; command dynamically updates container configuration. You can use this command to prevent containers from consuming too many resources from their Docker host. With a single command, you can place limits on a single container or on many. To specify more than one container, provide space-separated list of container names or IDs.</source>
          <target state="translated">的 &lt;code&gt;docker update&lt;/code&gt; 命令动态地更新容器的配置。您可以使用此命令来防止容器从其Docker主机消耗太多资源。使用单个命令，您可以在单个或多个容器上设置限制。要指定多个容器，请提供以空格分隔的容器名称或ID列表。</target>
        </trans-unit>
        <trans-unit id="19196d6f9e4c444a904f2de757b7f6396f216e73" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker-compose run&lt;/code&gt; command allows you to run one-off commands for your services. For example, to see what environment variables are available to the &lt;code&gt;web&lt;/code&gt; service:</source>
          <target state="translated">该 &lt;code&gt;docker-compose run&lt;/code&gt; 命令允许您为您的服务运行一次性的命令。例如，查看哪些环境变量可用于 &lt;code&gt;web&lt;/code&gt; 服务：</target>
        </trans-unit>
        <trans-unit id="a96f0c05b1b67f88be01dc43a967085da416ae02" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker-compose run&lt;/code&gt; command is for running &amp;ldquo;one-off&amp;rdquo; or &amp;ldquo;adhoc&amp;rdquo; tasks. It requires the service name you want to run and only starts containers for services that the running service depends on. Use &lt;code&gt;run&lt;/code&gt; to run tests or perform an administrative task such as removing or adding data to a data volume container. The &lt;code&gt;run&lt;/code&gt; command acts like &lt;code&gt;docker run -ti&lt;/code&gt; in that it opens an interactive terminal to the container and returns an exit status matching the exit status of the process in the container.</source>
          <target state="translated">该 &lt;code&gt;docker-compose run&lt;/code&gt; 命令是运行&amp;ldquo;一次性&amp;rdquo;或&amp;ldquo;即兴&amp;rdquo;的任务。它要求您要运行的服务名称，并且仅启动正在运行的服务所依赖的服务的容器。使用 &lt;code&gt;run&lt;/code&gt; 来运行测试或执行管理任务，例如将数据删除或添加到数据卷容器。的 &lt;code&gt;run&lt;/code&gt; 命令行为像 &lt;code&gt;docker run -ti&lt;/code&gt; 在它打开的交互式终端到容器，并返回一个退出状态匹配在容器中的过程的退出状态。</target>
        </trans-unit>
        <trans-unit id="d7ddb5e3e9d59bef26d3067922a3583ee29c8518" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker-compose start&lt;/code&gt; command is useful only to restart containers that were previously created, but were stopped. It never creates new containers.</source>
          <target state="translated">该 &lt;code&gt;docker-compose start&lt;/code&gt; 命令是有用的，只有到以前创建的，但被停止重启容器。它永远不会创建新的容器。</target>
        </trans-unit>
        <trans-unit id="ae035654bee087f0eea5350f20215eb42ce4f2f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker-compose up&lt;/code&gt; command aggregates the output of each container (essentially running &lt;code&gt;docker-compose logs -f&lt;/code&gt;). When the command exits, all containers are stopped. Running &lt;code&gt;docker-compose up -d&lt;/code&gt; starts the containers in the background and leaves them running.</source>
          <target state="translated">的 &lt;code&gt;docker-compose up&lt;/code&gt; 命令的聚集体的每个容器的输出（基本上运行 &lt;code&gt;docker-compose logs -f&lt;/code&gt; ）。当命令退出时，所有容器都将停止。运行 &lt;code&gt;docker-compose up -d&lt;/code&gt; 将在后台启动容器并使它们继续运行。</target>
        </trans-unit>
        <trans-unit id="43d3c64fa422d8a0abeec4a7dfcfccf738e571a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker-compose.yml&lt;/code&gt; file describes the services that make your app. In this example those services are a web server and database. The compose file also describes which Docker images these services use, how they link together, any volumes they might need mounted inside the containers. Finally, the &lt;code&gt;docker-compose.yml&lt;/code&gt; file describes which ports these services expose. See the &lt;a href=&quot;../compose-file/index&quot;&gt;&lt;code&gt;docker-compose.yml&lt;/code&gt; reference&lt;/a&gt; for more information on how this file works.</source>
          <target state="translated">该 &lt;code&gt;docker-compose.yml&lt;/code&gt; 文件描述，使您的应用程序的服务。在此示例中，这些服务是Web服务器和数据库。撰写文件还描述了这些服务使用的Docker映像，它们如何链接在一起，它们可能需要安装在容器内的任何卷。最后， &lt;code&gt;docker-compose.yml&lt;/code&gt; 文件描述了这些服务公开的端口。有关此文件如何工作的更多信息，请参阅&lt;a href=&quot;../compose-file/index&quot;&gt; &lt;code&gt;docker-compose.yml&lt;/code&gt; 参考&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="42e300efff75e3110759be633a66d0569b3f5b46" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker-compose.yml&lt;/code&gt; file might specify a &lt;code&gt;webapp&lt;/code&gt; service.</source>
          <target state="translated">该 &lt;code&gt;docker-compose.yml&lt;/code&gt; 文件可能会指定一个 &lt;code&gt;webapp&lt;/code&gt; 的服务。</target>
        </trans-unit>
        <trans-unit id="ce23ece18ea650efd0145a4a258ce3fc78e02e6f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker-default&lt;/code&gt; profile for containers lives in &lt;a href=&quot;https://github.com/moby/moby/tree/master/profiles/apparmor&quot;&gt;profiles/apparmor&lt;/a&gt;.</source>
          <target state="translated">容器的 &lt;code&gt;docker-default&lt;/code&gt; 配置文件位于&lt;a href=&quot;https://github.com/moby/moby/tree/master/profiles/apparmor&quot;&gt;profile / apparmor中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e295c8599d28f52be79d6f37991897d2f4101fc7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker-default&lt;/code&gt; profile is the default for running containers. It is moderately protective while providing wide application compatibility. The profile is generated from the following &lt;a href=&quot;https://github.com/moby/moby/blob/master/profiles/apparmor/template.go&quot;&gt;template&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;docker-default&lt;/code&gt; 配置文件是运行容器的默认。它具有适度的保护性，同时提供广泛的应用程序兼容性。该配置文件是从以下&lt;a href=&quot;https://github.com/moby/moby/blob/master/profiles/apparmor/template.go&quot;&gt;模板&lt;/a&gt;生成的。</target>
        </trans-unit>
        <trans-unit id="53293c102800f99d9a3f56ca9a39e8ff9fd8b31f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker-machine create&lt;/code&gt; command has some flags which apply to all drivers. These largely control aspects of Machine&amp;rsquo;s provisioning process (including the creation of Docker Swarm containers) that the user may wish to customize.</source>
          <target state="translated">该 &lt;code&gt;docker-machine create&lt;/code&gt; 命令有一些标志适用于所有的驱动程序。这些可能会很大程度上控制用户可能希望自定义的Machine设置过程（包括创建Docker Swarm容器）的各个方面。</target>
        </trans-unit>
        <trans-unit id="e849ce54b451a6cbfd8103fd5b47b57985f8374f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker-machine create&lt;/code&gt; command typically requires that you specify, at a minimum:</source>
          <target state="translated">该 &lt;code&gt;docker-machine create&lt;/code&gt; 命令通常需要指定，至少包括：</target>
        </trans-unit>
        <trans-unit id="2db3618b71fffeeb2d53ba032a660f3e49b7592b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;docker-machine&lt;/code&gt; subcommands are slightly different than the &lt;code&gt;boot2docker&lt;/code&gt; subcommands. The table below lists the equivalent &lt;code&gt;docker-machine&lt;/code&gt; subcommand and what it does:</source>
          <target state="translated">该 &lt;code&gt;docker-machine&lt;/code&gt; 子比略有不同 &lt;code&gt;boot2docker&lt;/code&gt; 子命令。下表列出了等效的 &lt;code&gt;docker-machine&lt;/code&gt; 子命令及其作用：</target>
        </trans-unit>
        <trans-unit id="a1db1683487e14949bbb78f38e959277a8f5ce96" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dockerd&lt;/code&gt; options that support the &lt;code&gt;overlay&lt;/code&gt; network are:</source>
          <target state="translated">支持 &lt;code&gt;overlay&lt;/code&gt; 网络的 &lt;code&gt;dockerd&lt;/code&gt; 选项包括：</target>
        </trans-unit>
        <trans-unit id="7761e7440db05872e7e8ff271cc30ebcfb8af0e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;driver&lt;/code&gt; filter matches networks based on their driver.</source>
          <target state="translated">该 &lt;code&gt;driver&lt;/code&gt; 过滤器匹配基于其驱动程序的网络。</target>
        </trans-unit>
        <trans-unit id="94879eb9ab387b61bf11d2e1021a2478cd5cb8f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;driver&lt;/code&gt; filter matches volumes based on their driver.</source>
          <target state="translated">该 &lt;code&gt;driver&lt;/code&gt; 过滤器匹配基于其驱动程序的体积。</target>
        </trans-unit>
        <trans-unit id="65484cf66101bd80c3b61d4be6a3893152113f3f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;driver&lt;/code&gt; name specifies a logging driver for the service&amp;rsquo;s containers, as with the &lt;code&gt;--log-driver&lt;/code&gt; option for docker run (&lt;a href=&quot;https://docs.docker.com/config/containers/logging&quot;&gt;documented here&lt;/a&gt;).</source>
          <target state="translated">该 &lt;code&gt;driver&lt;/code&gt; 名称指定服务的容器测井司机，与 &lt;code&gt;--log-driver&lt;/code&gt; 的泊坞窗运行（选项&lt;a href=&quot;https://docs.docker.com/config/containers/logging&quot;&gt;记录在这里&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="5900845392b6117d52a5cf8872beb287865bd83b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;enabled&lt;/code&gt; filter matches on plugins enabled or disabled.</source>
          <target state="translated">在 &lt;code&gt;enabled&lt;/code&gt; 的插件过滤器匹配启用或禁用。</target>
        </trans-unit>
        <trans-unit id="c2307cc28eea42e0d4cfd9d9269b5a168a00b09f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;erase&lt;/code&gt; command can write error messages to &lt;code&gt;STDOUT&lt;/code&gt; that the docker engine will show if there was an issue.</source>
          <target state="translated">该 &lt;code&gt;erase&lt;/code&gt; 命令可以将错误消息写入 &lt;code&gt;STDOUT&lt;/code&gt; 码头工人发动机将显示是否存在这样的问题。</target>
        </trans-unit>
        <trans-unit id="bea1b0179ece69facab7b56689aa14845a2f6b29" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;erase&lt;/code&gt; command takes a string payload from &lt;code&gt;STDIN&lt;/code&gt;. That payload carries the server address that the docker engine wants to remove credentials for. This is an example of that payload: &lt;code&gt;https://index.docker.io/v1&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;erase&lt;/code&gt; 命令从一个串有效负载 &lt;code&gt;STDIN&lt;/code&gt; 。该有效负载带有docker引擎要删除其凭据的服务器地址。这是该负载的示例： &lt;code&gt;https://index.docker.io/v1&lt;/code&gt; : //index.docker.io/v1。</target>
        </trans-unit>
        <trans-unit id="3254cd82ba3134bf8e742dc3c8b67f6c4d144c42" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;escape&lt;/code&gt; directive sets the character used to escape characters in a &lt;code&gt;Dockerfile&lt;/code&gt;. If not specified, the default escape character is &lt;code&gt;\&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;escape&lt;/code&gt; 指令设置用来逃避的字符的字符 &lt;code&gt;Dockerfile&lt;/code&gt; 。如果未指定，则默认转义字符为 &lt;code&gt;\&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4cfc30d9ac969e04f4a3ad1ed08dbd7718761a34" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;exited&lt;/code&gt; filter matches containers by exist status code. For example, to filter for containers that have exited successfully:</source>
          <target state="translated">在 &lt;code&gt;exited&lt;/code&gt; 过滤器匹配的存在状态代码容器。例如，要筛选成功退出的容器：</target>
        </trans-unit>
        <trans-unit id="7f10d4cc68da79397364680c26647bc7ff0e9fdc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;filter&lt;/code&gt; param to filter the list of image by reference (name or name:tag) is now implemented as a regular filter, named &lt;code&gt;reference&lt;/code&gt;.</source>
          <target state="translated">现在，按引用（名称或名称：标签）过滤图像列表的 &lt;code&gt;filter&lt;/code&gt; 参数已实现为名为 &lt;code&gt;reference&lt;/code&gt; 的常规过滤器。</target>
        </trans-unit>
        <trans-unit id="a9bf88f2b1a3cee4d1df04d1341ef1e7a515a38b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;get&lt;/code&gt; command takes a string payload from the standard input. That payload carries the server address that the docker engine needs credentials for. This is an example of that payload: &lt;code&gt;https://index.docker.io/v1&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;get&lt;/code&gt; 命令从标准输入字符串有效载荷。该有效负载带有docker引擎需要凭据的服务器地址。这是该负载的示例： &lt;code&gt;https://index.docker.io/v1&lt;/code&gt; : //index.docker.io/v1。</target>
        </trans-unit>
        <trans-unit id="9f9a5dac63313f2426c581b6b16d66b50692278c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;get&lt;/code&gt; command writes a JSON payload to &lt;code&gt;STDOUT&lt;/code&gt;. Docker reads the user name and password from this payload:</source>
          <target state="translated">该 &lt;code&gt;get&lt;/code&gt; 命令写入一个JSON有效载荷 &lt;code&gt;STDOUT&lt;/code&gt; 。Docker从此负载读取用户名和密码：</target>
        </trans-unit>
        <trans-unit id="2eea40067a6206a0916c6632051f6c874f33f8f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;id&lt;/code&gt; filter matches a task&amp;rsquo;s id.</source>
          <target state="translated">该 &lt;code&gt;id&lt;/code&gt; 过滤器匹配任务的ID。</target>
        </trans-unit>
        <trans-unit id="874d9c20a73081ecc0605f94bd826accf1ed089f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;id&lt;/code&gt; filter matches all or part of a node&amp;rsquo;s id.</source>
          <target state="translated">该 &lt;code&gt;id&lt;/code&gt; 过滤器匹配节点的ID的全部或部分。</target>
        </trans-unit>
        <trans-unit id="062f71d75d6eee0e75a08eb04d77e976398622ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;id&lt;/code&gt; filter matches all or part of a service&amp;rsquo;s id.</source>
          <target state="translated">该 &lt;code&gt;id&lt;/code&gt; 过滤器相匹配的服务的ID的全部或部分。</target>
        </trans-unit>
        <trans-unit id="9e7e6e53805c2ffc518e3b6b0f7c3661959a337d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;id&lt;/code&gt; filter matches all or prefix of a secret&amp;rsquo;s id.</source>
          <target state="translated">该 &lt;code&gt;id&lt;/code&gt; 过滤器匹配一个秘密的id的全部或前缀。</target>
        </trans-unit>
        <trans-unit id="c040b7fd003539442feca73620bd35debb9865f7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;id&lt;/code&gt; filter matches on all or a prefix of a task&amp;rsquo;s ID.</source>
          <target state="translated">该 &lt;code&gt;id&lt;/code&gt; 过滤器上的所有或任务的ID的前缀匹配。</target>
        </trans-unit>
        <trans-unit id="33be488005446a7b9d19d4576733f3cd58f14e22" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;id&lt;/code&gt; filter matches on all or part of a network&amp;rsquo;s ID.</source>
          <target state="translated">该 &lt;code&gt;id&lt;/code&gt; 过滤器上的网络的ID的全部或部分匹配。</target>
        </trans-unit>
        <trans-unit id="1a9cc726ad58a1f48a622098d6bd09b650006d37" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;key=value&lt;/code&gt; must be unique to avoid overwriting the label value. If you specify labels with identical keys but different values, each subsequent value overwrites the previous. Docker uses the last &lt;code&gt;key=value&lt;/code&gt; you supply.</source>
          <target state="translated">该 &lt;code&gt;key=value&lt;/code&gt; 必须是唯一的，以避免覆盖的标签值。如果您指定具有相同键但值不同的标签，则每个后续值都会覆盖前一个值。Docker使用您提供的最后一个 &lt;code&gt;key=value&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5654d9f7d98e717322ea30f463a002b491eb3daa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;label&lt;/code&gt; filter accepts two formats. One is the &lt;code&gt;label=...&lt;/code&gt; (&lt;code&gt;label=&amp;lt;key&amp;gt;&lt;/code&gt; or &lt;code&gt;label=&amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt;), which removes containers with the specified labels. The other format is the &lt;code&gt;label!=...&lt;/code&gt; (&lt;code&gt;label!=&amp;lt;key&amp;gt;&lt;/code&gt; or &lt;code&gt;label!=&amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt;), which removes containers without the specified labels.</source>
          <target state="translated">该 &lt;code&gt;label&lt;/code&gt; 过滤器接受两种格式。一个是 &lt;code&gt;label=...&lt;/code&gt; （ &lt;code&gt;label=&amp;lt;key&amp;gt;&lt;/code&gt; 或 &lt;code&gt;label=&amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; ），它删除具有指定标签的容器。另一种格式是 &lt;code&gt;label!=...&lt;/code&gt; （ &lt;code&gt;label!=&amp;lt;key&amp;gt;&lt;/code&gt; 或 &lt;code&gt;label!=&amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; ），该格式将删除没有指定标签的容器。</target>
        </trans-unit>
        <trans-unit id="be97cd3616a16824993de31a828d5df1d9b52148" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;label&lt;/code&gt; filter accepts two formats. One is the &lt;code&gt;label=...&lt;/code&gt; (&lt;code&gt;label=&amp;lt;key&amp;gt;&lt;/code&gt; or &lt;code&gt;label=&amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt;), which removes containers, images, networks, and volumes with the specified labels. The other format is the &lt;code&gt;label!=...&lt;/code&gt; (&lt;code&gt;label!=&amp;lt;key&amp;gt;&lt;/code&gt; or &lt;code&gt;label!=&amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt;), which removes containers, images, networks, and volumes without the specified labels.</source>
          <target state="translated">该 &lt;code&gt;label&lt;/code&gt; 过滤器接受两种格式。一个是 &lt;code&gt;label=...&lt;/code&gt; （ &lt;code&gt;label=&amp;lt;key&amp;gt;&lt;/code&gt; 或 &lt;code&gt;label=&amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; ），该标签将删除具有指定标签的容器，图像，网络和卷。另一种格式是 &lt;code&gt;label!=...&lt;/code&gt; （ &lt;code&gt;label!=&amp;lt;key&amp;gt;&lt;/code&gt; 或 &lt;code&gt;label!=&amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; ），该格式将删除没有指定标签的容器，图像，网络和卷。</target>
        </trans-unit>
        <trans-unit id="b8a2df36fd4d938bef98a3473bfa58e3dccc1bce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;label&lt;/code&gt; filter accepts two formats. One is the &lt;code&gt;label=...&lt;/code&gt; (&lt;code&gt;label=&amp;lt;key&amp;gt;&lt;/code&gt; or &lt;code&gt;label=&amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt;), which removes images with the specified labels. The other format is the &lt;code&gt;label!=...&lt;/code&gt; (&lt;code&gt;label!=&amp;lt;key&amp;gt;&lt;/code&gt; or &lt;code&gt;label!=&amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt;), which removes images without the specified labels.</source>
          <target state="translated">该 &lt;code&gt;label&lt;/code&gt; 过滤器接受两种格式。一个是 &lt;code&gt;label=...&lt;/code&gt; （ &lt;code&gt;label=&amp;lt;key&amp;gt;&lt;/code&gt; 或 &lt;code&gt;label=&amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; ），该标签将删除具有指定标签的图像。另一种格式是 &lt;code&gt;label!=...&lt;/code&gt; （ &lt;code&gt;label!=&amp;lt;key&amp;gt;&lt;/code&gt; 或 &lt;code&gt;label!=&amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; ），该格式将删除没有指定标签的图像。</target>
        </trans-unit>
        <trans-unit id="52ff0a6b1f787c9e75fb01815b0e6b266ae2a1d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;label&lt;/code&gt; filter accepts two formats. One is the &lt;code&gt;label=...&lt;/code&gt; (&lt;code&gt;label=&amp;lt;key&amp;gt;&lt;/code&gt; or &lt;code&gt;label=&amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt;), which removes networks with the specified labels. The other format is the &lt;code&gt;label!=...&lt;/code&gt; (&lt;code&gt;label!=&amp;lt;key&amp;gt;&lt;/code&gt; or &lt;code&gt;label!=&amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt;), which removes networks without the specified labels.</source>
          <target state="translated">该 &lt;code&gt;label&lt;/code&gt; 过滤器接受两种格式。一个是 &lt;code&gt;label=...&lt;/code&gt; （ &lt;code&gt;label=&amp;lt;key&amp;gt;&lt;/code&gt; 或 &lt;code&gt;label=&amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; ），它删除具有指定标签的网络。另一种格式是 &lt;code&gt;label!=...&lt;/code&gt; （ &lt;code&gt;label!=&amp;lt;key&amp;gt;&lt;/code&gt; 或 &lt;code&gt;label!=&amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; ），该格式将删除没有指定标签的网络。</target>
        </trans-unit>
        <trans-unit id="018de019755b87e20d5872730ae9dd136b302390" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;label&lt;/code&gt; filter matches containers based on the presence of a &lt;code&gt;label&lt;/code&gt; alone or a &lt;code&gt;label&lt;/code&gt; and a value.</source>
          <target state="translated">的 &lt;code&gt;label&lt;/code&gt; 过滤器匹配基础上的存在容器 &lt;code&gt;label&lt;/code&gt; 单独或一个 &lt;code&gt;label&lt;/code&gt; 和一个值。</target>
        </trans-unit>
        <trans-unit id="4d8af22aa6e6d75efc58ea064321d18436b8a10d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;label&lt;/code&gt; filter matches images based on the presence of a &lt;code&gt;label&lt;/code&gt; alone or a &lt;code&gt;label&lt;/code&gt; and a value.</source>
          <target state="translated">的 &lt;code&gt;label&lt;/code&gt; 过滤器匹配基础上的存在的图像 &lt;code&gt;label&lt;/code&gt; 单独或一个 &lt;code&gt;label&lt;/code&gt; 和一个值。</target>
        </trans-unit>
        <trans-unit id="98e6df95904d703aaec7b0207a80452c247789a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;label&lt;/code&gt; filter matches networks based on the presence of a &lt;code&gt;label&lt;/code&gt; alone or a &lt;code&gt;label&lt;/code&gt; and a value.</source>
          <target state="translated">的 &lt;code&gt;label&lt;/code&gt; 过滤器匹配基础上的存在的网络 &lt;code&gt;label&lt;/code&gt; 单独或一个 &lt;code&gt;label&lt;/code&gt; 和一个值。</target>
        </trans-unit>
        <trans-unit id="5e15c96bb92954198ca742ec3d8e8b0984c3f9cb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;label&lt;/code&gt; filter matches nodes based on engine labels and on the presence of a &lt;code&gt;label&lt;/code&gt; alone or a &lt;code&gt;label&lt;/code&gt; and a value. Node labels are currently not used for filtering.</source>
          <target state="translated">的 &lt;code&gt;label&lt;/code&gt; 过滤器相匹配，基于发动机的标签和在存在节点 &lt;code&gt;label&lt;/code&gt; 单独或一个 &lt;code&gt;label&lt;/code&gt; 和一个值。节点标签当前不用于过滤。</target>
        </trans-unit>
        <trans-unit id="d48e63cfaa1dbb7dceb781c12aed418e6036a7cc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;label&lt;/code&gt; filter matches secrets based on the presence of a &lt;code&gt;label&lt;/code&gt; alone or a &lt;code&gt;label&lt;/code&gt; and a value.</source>
          <target state="translated">的 &lt;code&gt;label&lt;/code&gt; 过滤器匹配基础上的存在秘密 &lt;code&gt;label&lt;/code&gt; 单独或一个 &lt;code&gt;label&lt;/code&gt; 和一个值。</target>
        </trans-unit>
        <trans-unit id="4d4f1362ae0c77d72fd3decf3629591112e34b0d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;label&lt;/code&gt; filter matches services based on the presence of a &lt;code&gt;label&lt;/code&gt; alone or a &lt;code&gt;label&lt;/code&gt; and a value.</source>
          <target state="translated">该 &lt;code&gt;label&lt;/code&gt; 过滤器匹配基础上的存在的服务 &lt;code&gt;label&lt;/code&gt; 单独或 &lt;code&gt;label&lt;/code&gt; 和值。</target>
        </trans-unit>
        <trans-unit id="7d6a1563d22c594b3e7762479f46564bf33ef840" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;label&lt;/code&gt; filter matches tasks based on the presence of a &lt;code&gt;label&lt;/code&gt; alone or a &lt;code&gt;label&lt;/code&gt; and a value.</source>
          <target state="translated">该 &lt;code&gt;label&lt;/code&gt; 过滤器匹配基础上的存在的任务 &lt;code&gt;label&lt;/code&gt; 单独或 &lt;code&gt;label&lt;/code&gt; 和值。</target>
        </trans-unit>
        <trans-unit id="af9c4f8bbdf1d60d98233e85dfbc13dc94b96e98" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;label&lt;/code&gt; filter matches volumes based on the presence of a &lt;code&gt;label&lt;/code&gt; alone or a &lt;code&gt;label&lt;/code&gt; and a value.</source>
          <target state="translated">的 &lt;code&gt;label&lt;/code&gt; 过滤器匹配基础上的存在卷 &lt;code&gt;label&lt;/code&gt; 单独或一个 &lt;code&gt;label&lt;/code&gt; 和一个值。</target>
        </trans-unit>
        <trans-unit id="0c2988bf145e8ccc73b38070bfaf3b48226f427f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ls&lt;/code&gt; command tries to reach each host in parallel. If a given host does not answer in less than 10 seconds, the &lt;code&gt;ls&lt;/code&gt; command states that this host is in &lt;code&gt;Timeout&lt;/code&gt; state. In some circumstances (poor connection, high load, or while troubleshooting), you may want to increase or decrease this value. You can use the -t flag for this purpose with a numerical value in seconds.</source>
          <target state="translated">的 &lt;code&gt;ls&lt;/code&gt; 命令试图达到并联每个主机。如果给定的主机在不到10秒钟内没有应答，则 &lt;code&gt;ls&lt;/code&gt; 命令指出该主机处于&amp;ldquo; &lt;code&gt;Timeout&lt;/code&gt; 状态。在某些情况下（连接不良，高负载或在进行故障排除时），您可能希望增加或减少此值。为此，可以将-t标志用于以秒为单位的数值。</target>
        </trans-unit>
        <trans-unit id="5703b34d2ea18e80b932f011cb44b023bff8d66c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;membership&lt;/code&gt; filter matches nodes based on the presence of a &lt;code&gt;membership&lt;/code&gt; and a value &lt;code&gt;accepted&lt;/code&gt; or &lt;code&gt;pending&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;membership&lt;/code&gt; 过滤器匹配基础上的存在节点 &lt;code&gt;membership&lt;/code&gt; 和一个值 &lt;code&gt;accepted&lt;/code&gt; 或 &lt;code&gt;pending&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d8b1c08c13336a840ca4426784eba1b9975c6865" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mode&lt;/code&gt; filter matches on the mode (either &lt;code&gt;replicated&lt;/code&gt; or &lt;code&gt;global&lt;/code&gt;) of a service.</source>
          <target state="translated">的 &lt;code&gt;mode&lt;/code&gt; 滤波器的模式（或者匹配 &lt;code&gt;replicated&lt;/code&gt; 或 &lt;code&gt;global&lt;/code&gt; 的服务的）。</target>
        </trans-unit>
        <trans-unit id="f89ad7e1e240d286b92475de1880259e4179996e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;my-label&lt;/code&gt; key doesn&amp;rsquo;t specify a value so the label defaults to an empty string (&lt;code&gt;&quot;&quot;&lt;/code&gt;). To add multiple labels, repeat the label flag (&lt;code&gt;-l&lt;/code&gt; or &lt;code&gt;--label&lt;/code&gt;).</source>
          <target state="translated">在 &lt;code&gt;my-label&lt;/code&gt; 键没有指定这样的标签，默认的值设置为空字符串（ &lt;code&gt;&quot;&quot;&lt;/code&gt; ）。要添加多个标签，请重复标签标志（ &lt;code&gt;-l&lt;/code&gt; 或 &lt;code&gt;--label&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="082614082d232a3fdd600eb393e84c2b7810814a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mynet&lt;/code&gt; network is now owned by &lt;code&gt;weave&lt;/code&gt;, so subsequent commands referring to that network will be sent to the plugin,</source>
          <target state="translated">现在， &lt;code&gt;mynet&lt;/code&gt; 网络由 &lt;code&gt;weave&lt;/code&gt; 拥有，因此引用该网络的后续命令将发送到插件，</target>
        </trans-unit>
        <trans-unit id="4116f19330146743a5b9ffe7f885dbf991a4c292" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name&lt;/code&gt; filter matches on all or part of a container&amp;rsquo;s name.</source>
          <target state="translated">该 &lt;code&gt;name&lt;/code&gt; 过滤器上的容器的名字的全部或部分匹配。</target>
        </trans-unit>
        <trans-unit id="bdf2c18aa87a750b7d502fbc1168479b6f550ff3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name&lt;/code&gt; filter matches on all or part of a network&amp;rsquo;s name.</source>
          <target state="translated">该 &lt;code&gt;name&lt;/code&gt; 过滤器上的网络名称的全部或部分匹配。</target>
        </trans-unit>
        <trans-unit id="13d14b84aa19afef87897aa55f10ed51ff7376a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name&lt;/code&gt; filter matches on all or part of a node hostname.</source>
          <target state="translated">该 &lt;code&gt;name&lt;/code&gt; 过滤器上的所有或节点的主机名的一部分相匹配。</target>
        </trans-unit>
        <trans-unit id="3c06f079b7410ab5cfcbb6181eb803ec0ef01f81" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name&lt;/code&gt; filter matches on all or part of a service&amp;rsquo;s name.</source>
          <target state="translated">该 &lt;code&gt;name&lt;/code&gt; 过滤器上的服务的名称的全部或部分匹配。</target>
        </trans-unit>
        <trans-unit id="40ee93534c85c37ac235cd07ceadd27279867de7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name&lt;/code&gt; filter matches on all or part of a task&amp;rsquo;s name.</source>
          <target state="translated">该 &lt;code&gt;name&lt;/code&gt; 过滤器上的任务名称的全部或部分匹配。</target>
        </trans-unit>
        <trans-unit id="7b0e1af36ee24c5616ec9fb952dc64e9cdf914ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name&lt;/code&gt; filter matches on all or part of a volume&amp;rsquo;s name.</source>
          <target state="translated">该 &lt;code&gt;name&lt;/code&gt; 过滤器上的卷的名称的全部或部分匹配。</target>
        </trans-unit>
        <trans-unit id="65875118713d9d791bb0a46435277fd73f9d0631" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name&lt;/code&gt; filter matches on all or prefix of a secret&amp;rsquo;s name.</source>
          <target state="translated">该 &lt;code&gt;name&lt;/code&gt; 过滤器上的一个秘密的名字的全部或前缀匹配。</target>
        </trans-unit>
        <trans-unit id="48deeb28be69f5f57a0691024754fc4fcedb79e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name&lt;/code&gt; filter matches on task names.</source>
          <target state="translated">该 &lt;code&gt;name&lt;/code&gt; 过滤器上的任务名称相匹配。</target>
        </trans-unit>
        <trans-unit id="702fb5469953d05950f731252ceb1e71cb5ced6a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;native.cgroupdriver&lt;/code&gt; option specifies the management of the container&amp;rsquo;s cgroups. You can only specify &lt;code&gt;cgroupfs&lt;/code&gt; or &lt;code&gt;systemd&lt;/code&gt;. If you specify &lt;code&gt;systemd&lt;/code&gt; and it is not available, the system errors out. If you omit the &lt;code&gt;native.cgroupdriver&lt;/code&gt; option,&lt;code&gt;cgroupfs&lt;/code&gt; is used.</source>
          <target state="translated">该 &lt;code&gt;native.cgroupdriver&lt;/code&gt; 选项指定容器的cgroup中的管理。您只能指定 &lt;code&gt;cgroupfs&lt;/code&gt; 或 &lt;code&gt;systemd&lt;/code&gt; 。如果指定 &lt;code&gt;systemd&lt;/code&gt; ，但它不可用，则系统将出错。如果省略 &lt;code&gt;native.cgroupdriver&lt;/code&gt; 选项，则使用 &lt;code&gt;cgroupfs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e84716020b3bafa9802a7e4d62c5858b8b46e922" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;network&lt;/code&gt; filter shows only containers that are connected to a network with a given name or id.</source>
          <target state="translated">所述 &lt;code&gt;network&lt;/code&gt; 仅过滤器显示了连接到网络的具有给定名称或ID的容器。</target>
        </trans-unit>
        <trans-unit id="b651cc06a639b090262a5f5c552b2399900192a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;node&lt;/code&gt; filter matches on a node name or a node ID.</source>
          <target state="translated">的 &lt;code&gt;node&lt;/code&gt; 滤波器上的节点名或节点ID相匹配。</target>
        </trans-unit>
        <trans-unit id="4f8e6ad6eb59b8cb6cf3c618793766797bc47785" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;notary list&lt;/code&gt; and &lt;code&gt;notary remove&lt;/code&gt; commands can also take the &lt;code&gt;--roles&lt;/code&gt; flag to specify roles to list or remove targets from. By default, this operates over the base &lt;code&gt;targets&lt;/code&gt; role.</source>
          <target state="translated">该 &lt;code&gt;notary list&lt;/code&gt; 和 &lt;code&gt;notary remove&lt;/code&gt; 命令也可以采取 &lt;code&gt;--roles&lt;/code&gt; 标志从指定角色列表或删除目标。默认情况下，此操作作用于基本 &lt;code&gt;targets&lt;/code&gt; 角色。</target>
        </trans-unit>
        <trans-unit id="b27f7d14334c92b16cec1e9a1b3aed69946a76d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;overlay2&lt;/code&gt; uses the same fast union filesystem but takes advantage of &lt;a href=&quot;https://lkml.org/lkml/2015/2/11/106&quot;&gt;additional features&lt;/a&gt; added in Linux kernel 4.0 to avoid excessive inode consumption. Call &lt;code&gt;dockerd -s overlay2&lt;/code&gt; to use it.</source>
          <target state="translated">该 &lt;code&gt;overlay2&lt;/code&gt; 使用相同的快速工会文件系统，但是利用的&lt;a href=&quot;https://lkml.org/lkml/2015/2/11/106&quot;&gt;附加功能&lt;/a&gt;在Linux内核4.0添加，以避免过多的inode消耗。调用 &lt;code&gt;dockerd -s overlay2&lt;/code&gt; 以使用它。</target>
        </trans-unit>
        <trans-unit id="f62b83b6c6304e6bd37693d3d4d2a3ba5d121dc4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;overlay&lt;/code&gt; driver creates a named network across multiple nodes in a &lt;a href=&quot;../../engine/swarm/index&quot;&gt;swarm&lt;/a&gt;.</source>
          <target state="translated">在 &lt;code&gt;overlay&lt;/code&gt; 驱动程序创建一个跨多个节点命名的网络&lt;a href=&quot;../../engine/swarm/index&quot;&gt;群&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f1095b703bcc7591339e488256d38b8fabfd5f0f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;overlay&lt;/code&gt; is a very fast union filesystem. It is now merged in the main Linux kernel as of &lt;a href=&quot;https://lkml.org/lkml/2014/10/26/137&quot;&gt;3.18.0&lt;/a&gt;. &lt;code&gt;overlay&lt;/code&gt; also supports page cache sharing, this means multiple containers accessing the same file can share a single page cache entry (or entries), it makes &lt;code&gt;overlay&lt;/code&gt; as efficient with memory as &lt;code&gt;aufs&lt;/code&gt; driver. Call &lt;code&gt;dockerd -s overlay&lt;/code&gt; to use it.</source>
          <target state="translated">该 &lt;code&gt;overlay&lt;/code&gt; 是非常快的联合文件系统。从&lt;a href=&quot;https://lkml.org/lkml/2014/10/26/137&quot;&gt;3.18.0开始，&lt;/a&gt;它现在已合并到主要的Linux内核中。 &lt;code&gt;overlay&lt;/code&gt; 还支持页面缓存共享，这意味着访问同一文件的多个容器可以共享一个（或多个）页面缓存条目，这使得 &lt;code&gt;overlay&lt;/code&gt; 与 &lt;code&gt;aufs&lt;/code&gt; 驱动程序一样有效。调用 &lt;code&gt;dockerd -s overlay&lt;/code&gt; 以使用它。</target>
        </trans-unit>
        <trans-unit id="e8add9ee4df5f9e747f7dfaaa7ea17cfd452a7db" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;overlay&lt;/code&gt; storage driver is deprecated in favor of the &lt;code&gt;overlay2&lt;/code&gt; storage driver, which has all the benefits of &lt;code&gt;overlay&lt;/code&gt;, without its limitations (excessive inode consumption). The legacy &lt;code&gt;overlay&lt;/code&gt; storage driver will be removed in a future release. Users of the &lt;code&gt;overlay&lt;/code&gt; storage driver should migrate to the &lt;code&gt;overlay2&lt;/code&gt; storage driver.</source>
          <target state="translated">在 &lt;code&gt;overlay&lt;/code&gt; 存储驱动程序被弃用，取而代之的的 &lt;code&gt;overlay2&lt;/code&gt; 存储驱动器，它具有的所有优势 &lt;code&gt;overlay&lt;/code&gt; ，没有它的局限性（索引节点过多消耗）。旧版 &lt;code&gt;overlay&lt;/code&gt; 存储驱动程序将在将来的版本中删除。 &lt;code&gt;overlay&lt;/code&gt; 存储驱动程序的用户应迁移到 &lt;code&gt;overlay2&lt;/code&gt; 存储驱动程序。</target>
        </trans-unit>
        <trans-unit id="57d6cd43d9cf4064b15d5370549b191804dbe847" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;publish&lt;/code&gt; and &lt;code&gt;expose&lt;/code&gt; filters show only containers that have published or exposed port with a given port number, port range, and/or protocol. The default protocol is &lt;code&gt;tcp&lt;/code&gt; when not specified.</source>
          <target state="translated">在 &lt;code&gt;publish&lt;/code&gt; 和 &lt;code&gt;expose&lt;/code&gt; 的过滤器仅显示已发布或暴露端口与给定的端口号，端口范围，和/或协议的容器。未指定时，默认协议为 &lt;code&gt;tcp&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="32212b2ccd1049c0834c60bdfd798e9765d7db57" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;redis&lt;/code&gt; service uses a public &lt;a href=&quot;https://registry.hub.docker.com/_/redis/&quot;&gt;Redis&lt;/a&gt; image pulled from the Docker Hub registry.</source>
          <target state="translated">在 &lt;code&gt;redis&lt;/code&gt; 服务使用一个公共&lt;a href=&quot;https://registry.hub.docker.com/_/redis/&quot;&gt;的Redis&lt;/a&gt;从泊坞枢纽注册表拉形象。</target>
        </trans-unit>
        <trans-unit id="a10f28df2d9ece01d4995b17a29708fde3933b04" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;reference&lt;/code&gt; filter shows only images whose reference matches the specified pattern.</source>
          <target state="translated">的 &lt;code&gt;reference&lt;/code&gt; 滤波器仅示出其参考与指定模式匹配的图像。</target>
        </trans-unit>
        <trans-unit id="e28bcc91dc3b30ca61505750632dc3ed05692327" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;remote_server&lt;/code&gt; specifies how to connect to a Notary server to download metadata updates and publish metadata changes.</source>
          <target state="translated">该 &lt;code&gt;remote_server&lt;/code&gt; 的指定如何连接到公证服务器下载元数据更新和发布元数据的变化。</target>
        </trans-unit>
        <trans-unit id="f95d30a98fcc537264adac1b069c3de5c624096e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;repository:shortid&lt;/code&gt; syntax for referencing images is very little used, collides with tag references, and can be confused with digest references.</source>
          <target state="translated">用于引用图像的 &lt;code&gt;repository:shortid&lt;/code&gt; 语法很少使用，与标记引用冲突，并且可能与摘要引用混淆。</target>
        </trans-unit>
        <trans-unit id="946a27d27a594272d228a2f9ebd5d23d58f82f9a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;role&lt;/code&gt; filter matches nodes based on the presence of a &lt;code&gt;role&lt;/code&gt; and a value &lt;code&gt;worker&lt;/code&gt; or &lt;code&gt;manager&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;role&lt;/code&gt; 过滤器匹配基础上的存在的节点 &lt;code&gt;role&lt;/code&gt; 和价值 &lt;code&gt;worker&lt;/code&gt; 或 &lt;code&gt;manager&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="19a30e315bc4c8b432b7da06b140919f686444f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;root_keys&lt;/code&gt; subdirectory within &lt;code&gt;private&lt;/code&gt; stores root private keys, while &lt;code&gt;tuf_keys&lt;/code&gt; stores targets, snapshots, and delegations private keys.</source>
          <target state="translated">该 &lt;code&gt;root_keys&lt;/code&gt; 子目录中 &lt;code&gt;private&lt;/code&gt; 商店根私有密钥，而 &lt;code&gt;tuf_keys&lt;/code&gt; 门店的目标，快照和代表团私钥。</target>
        </trans-unit>
        <trans-unit id="6610e72ef34ecc0f23817bc0409ff6cf2dea2b7d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rootfs&lt;/code&gt; directory represents the root filesystem of the plugin. In this example, it was created from a Dockerfile:</source>
          <target state="translated">在 &lt;code&gt;rootfs&lt;/code&gt; 目录代表插件的根文件系统。在此示例中，它是从Dockerfile创建的：</target>
        </trans-unit>
        <trans-unit id="27e15a03c1fef8554bd0e6252de77d87b274d86d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;scope&lt;/code&gt; filter matches networks based on their scope.</source>
          <target state="translated">&lt;code&gt;scope&lt;/code&gt; 过滤器根据网络的范围来匹配网络。</target>
        </trans-unit>
        <trans-unit id="8a091005755a7e40cc57b9186a022197457f724c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;service&lt;/code&gt; file (for example &lt;code&gt;/lib/systemd/system/your-plugin.service&lt;/code&gt;):</source>
          <target state="translated">该 &lt;code&gt;service&lt;/code&gt; （例如文件 &lt;code&gt;/lib/systemd/system/your-plugin.service&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="37491830e511de1d5bb58a0686627f39963dcb6b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;service&lt;/code&gt; the name of the service being extended, for example &lt;code&gt;web&lt;/code&gt; or &lt;code&gt;database&lt;/code&gt;. The &lt;code&gt;file&lt;/code&gt; is the location of a Compose configuration file defining that service.</source>
          <target state="translated">该 &lt;code&gt;service&lt;/code&gt; 的服务的名称被扩展，例如 &lt;code&gt;web&lt;/code&gt; 或 &lt;code&gt;database&lt;/code&gt; 。该 &lt;code&gt;file&lt;/code&gt; 是定义该服务的Compose配置文件的位置。</target>
        </trans-unit>
        <trans-unit id="a360e2cea9622846c780d822d40a24715633debd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;since&lt;/code&gt; filter shows only containers created since the container with given id or name. For example, with the same containers as in &lt;code&gt;before&lt;/code&gt; filter:</source>
          <target state="translated">在 &lt;code&gt;since&lt;/code&gt; 过滤器只显示容器，因为与给定id或名称的容器中创建。例如，使用与 &lt;code&gt;before&lt;/code&gt; 过滤器相同的容器：</target>
        </trans-unit>
        <trans-unit id="84d3e1bb8cb5d26bcfef75759b883a6e402ea173" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;site.csr&lt;/code&gt; and &lt;code&gt;site.cnf&lt;/code&gt; files are not needed by the Nginx service, but you need them if you want to generate a new site certificate. Protect the &lt;code&gt;root-ca.key&lt;/code&gt; file.</source>
          <target state="translated">该 &lt;code&gt;site.csr&lt;/code&gt; 和 &lt;code&gt;site.cnf&lt;/code&gt; 不需要通过Nginx的服务档案，但你需要他们，如果你想生成一个新的站点证书。保护 &lt;code&gt;root-ca.key&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="3977312060c807dab33ea48b26fdaff6022f83de" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;socket&lt;/code&gt; file (for example &lt;code&gt;/lib/systemd/system/your-plugin.socket&lt;/code&gt;):</source>
          <target state="translated">该 &lt;code&gt;socket&lt;/code&gt; 文件（例如 &lt;code&gt;/lib/systemd/system/your-plugin.socket&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="74dddfba7279c1388888439111e559495678ed60" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;status&lt;/code&gt; filter matches containers by status. You can filter using &lt;code&gt;created&lt;/code&gt;, &lt;code&gt;restarting&lt;/code&gt;, &lt;code&gt;running&lt;/code&gt;, &lt;code&gt;removing&lt;/code&gt;, &lt;code&gt;paused&lt;/code&gt;, &lt;code&gt;exited&lt;/code&gt; and &lt;code&gt;dead&lt;/code&gt;. For example, to filter for &lt;code&gt;running&lt;/code&gt; containers:</source>
          <target state="translated">该 &lt;code&gt;status&lt;/code&gt; 过滤器通过状态相匹配的容器。您可以使用过滤器 &lt;code&gt;created&lt;/code&gt; ， &lt;code&gt;restarting&lt;/code&gt; ， &lt;code&gt;running&lt;/code&gt; ， &lt;code&gt;removing&lt;/code&gt; ， &lt;code&gt;paused&lt;/code&gt; ， &lt;code&gt;exited&lt;/code&gt; 和 &lt;code&gt;dead&lt;/code&gt; 。例如，要过滤 &lt;code&gt;running&lt;/code&gt; 容器：</target>
        </trans-unit>
        <trans-unit id="2c2e44a9200bd1d71315631b0c2c98438f27f8ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;store&lt;/code&gt; command can write error messages to &lt;code&gt;STDOUT&lt;/code&gt; that the docker engine will show if there was an issue.</source>
          <target state="translated">该 &lt;code&gt;store&lt;/code&gt; 命令可以将错误消息写入 &lt;code&gt;STDOUT&lt;/code&gt; ，如果有问题的泊坞窗引擎会显示。</target>
        </trans-unit>
        <trans-unit id="201eae4e5d21feaa880c1da9df3662878ff71506" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;store&lt;/code&gt; command takes a JSON payload from the standard input. That payload carries the server address, to identify the credential, the user name, and either a password or an identity token.</source>
          <target state="translated">所述 &lt;code&gt;store&lt;/code&gt; 命令从标准输入一个JSON有效载荷。该有效负载带有服务器地址，以标识凭据，用户名以及密码或身份令牌。</target>
        </trans-unit>
        <trans-unit id="8f8d92702335aa3cf9f7d6e3d0646cb9035f7d39" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tag&lt;/code&gt; or &lt;code&gt;digest&lt;/code&gt; values are optional. If you omit either of them, the builder assumes a &lt;code&gt;latest&lt;/code&gt; tag by default. The builder returns an error if it cannot find the &lt;code&gt;tag&lt;/code&gt; value.</source>
          <target state="translated">该 &lt;code&gt;tag&lt;/code&gt; 或 &lt;code&gt;digest&lt;/code&gt; 值是可选的。如果您忽略其中任何一个，那么缺省情况下构建器将采用 &lt;code&gt;latest&lt;/code&gt; 标签。如果构建器找不到 &lt;code&gt;tag&lt;/code&gt; 值，则返回错误。</target>
        </trans-unit>
        <trans-unit id="acb29c4110ede458e19d89941d169232476d9c7c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;trust_dir&lt;/code&gt; specifies the location (as an absolute path or a path relative to the directory of the configuration file) where the TUF metadata and private keys are stored.</source>
          <target state="translated">所述 &lt;code&gt;trust_dir&lt;/code&gt; 指定的位置（为绝对路径或相对于配置文件的目录的路径），其中TUF元数据和私钥存储。</target>
        </trans-unit>
        <trans-unit id="d567b63c2e261aff2ddbc1c532e24bc856109547" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;trust_pinning&lt;/code&gt; specifies how to bootstrap trust for the root of a Notary client&amp;rsquo;s trusted collection.</source>
          <target state="translated">该 &lt;code&gt;trust_pinning&lt;/code&gt; 指定如何引导信任的公证客户的信任集的根目录。</target>
        </trans-unit>
        <trans-unit id="5c3ba868e5bbc2288271513312680c5aea6e1bc8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type&lt;/code&gt; filter supports two values; &lt;code&gt;builtin&lt;/code&gt; displays predefined networks (&lt;code&gt;bridge&lt;/code&gt;, &lt;code&gt;none&lt;/code&gt;, &lt;code&gt;host&lt;/code&gt;), whereas &lt;code&gt;custom&lt;/code&gt; displays user defined networks.</source>
          <target state="translated">该 &lt;code&gt;type&lt;/code&gt; 过滤器支持两个值; &lt;code&gt;builtin&lt;/code&gt; 显示预定义的网络（ &lt;code&gt;bridge&lt;/code&gt; ， &lt;code&gt;none&lt;/code&gt; ， &lt;code&gt;host&lt;/code&gt; ），而 &lt;code&gt;custom&lt;/code&gt; 显示用户定义的网络。</target>
        </trans-unit>
        <trans-unit id="623dd4366d3e03347278170a9392f26c7b6dca59" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;until&lt;/code&gt; filter can be Unix timestamps, date formatted timestamps, or Go duration strings (e.g. &lt;code&gt;10m&lt;/code&gt;, &lt;code&gt;1h30m&lt;/code&gt;) computed relative to the daemon machine&amp;rsquo;s time. Supported formats for date formatted time stamps include RFC3339Nano, RFC3339, &lt;code&gt;2006-01-02T15:04:05&lt;/code&gt;, &lt;code&gt;2006-01-02T15:04:05.999999999&lt;/code&gt;, &lt;code&gt;2006-01-02Z07:00&lt;/code&gt;, and &lt;code&gt;2006-01-02&lt;/code&gt;. The local timezone on the daemon will be used if you do not provide either a &lt;code&gt;Z&lt;/code&gt; or a &lt;code&gt;+-00:00&lt;/code&gt; timezone offset at the end of the timestamp. When providing Unix timestamps enter seconds[.nanoseconds], where seconds is the number of seconds that have elapsed since January 1, 1970 (midnight UTC/GMT), not counting leap seconds (aka Unix epoch or Unix time), and the optional .nanoseconds field is a fraction of a second no more than nine digits long.</source>
          <target state="translated">该 &lt;code&gt;until&lt;/code&gt; 过滤器可以是Unix的时间戳，日期格式的时间戳，或转到时间字符串（例如， &lt;code&gt;10m&lt;/code&gt; ， &lt;code&gt;1h30m&lt;/code&gt; 相对守护机器的时间计算）。支持的格式为日期格式时间戳包括RFC3339Nano，RFC3339， &lt;code&gt;2006-01-02T15:04:05&lt;/code&gt; ， &lt;code&gt;2006-01-02T15:04:05.999999999&lt;/code&gt; ， &lt;code&gt;2006-01-02Z07:00&lt;/code&gt; ，和 &lt;code&gt;2006-01-02&lt;/code&gt; 。如果您未提供 &lt;code&gt;Z&lt;/code&gt; 或 &lt;code&gt;+-00:00&lt;/code&gt; ,则将使用守护程序上的本地时区时间戳记末尾的时区偏移量。提供Unix时间戳时，输入seconds [.nanoseconds]，其中seconds是自1970年1月1日（UTC / GMT午夜）以来经过的秒数，不计算counting秒（又名Unix纪元或Unix时间），以及可选的。纳秒字段是一秒的分数，长度不超过9位数。</target>
        </trans-unit>
        <trans-unit id="88838fefdaa39b0ba1f163b1d4ed778a4bd3b967" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;volume&lt;/code&gt; filter shows only containers that mount a specific volume or have a volume mounted in a specific path:</source>
          <target state="translated">的 &lt;code&gt;volume&lt;/code&gt; 过滤器只示出了该支架的特定体积或具有安装在一个特定的路径的容积的容器：</target>
        </trans-unit>
        <trans-unit id="fffe874eceb8a6d1dad5be3972e327372c8f22a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;web&lt;/code&gt; service uses an image that&amp;rsquo;s built from the &lt;code&gt;Dockerfile&lt;/code&gt; in the current directory. It then binds the container and the host machine to the exposed port, &lt;code&gt;5000&lt;/code&gt;. This example service uses the default port for the Flask web server, &lt;code&gt;5000&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;web&lt;/code&gt; 服务使用从当前目录中的 &lt;code&gt;Dockerfile&lt;/code&gt; 构建的映像。然后，它将容器和主机绑定到暴露的端口 &lt;code&gt;5000&lt;/code&gt; 。此示例服务使用Flask Web服务器的默认端口 &lt;code&gt;5000&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cfb1cd9971be9ceb83fb0faa1ce31cb35adfc984" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;zfs&lt;/code&gt; driver is probably not as fast as &lt;code&gt;btrfs&lt;/code&gt; but has a longer track record on stability. Thanks to &lt;code&gt;Single Copy ARC&lt;/code&gt; shared blocks between clones will be cached only once. Use &lt;code&gt;dockerd -s zfs&lt;/code&gt;. To select a different zfs filesystem set &lt;code&gt;zfs.fsname&lt;/code&gt; option as described in &lt;a href=&quot;#zfs-options&quot;&gt;ZFS options&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;zfs&lt;/code&gt; 司机可能是不一样快 &lt;code&gt;btrfs&lt;/code&gt; ，但对稳定较长的记录。多亏了 &lt;code&gt;Single Copy ARC&lt;/code&gt; ，克隆之间的共享块将仅被缓存一次。使用 &lt;code&gt;dockerd -s zfs&lt;/code&gt; 。要选择其他zfs文件系统，请按照&lt;a href=&quot;#zfs-options&quot;&gt;ZFS options中&lt;/a&gt;所述设置 &lt;code&gt;zfs.fsname&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="6624f3a95723eb7deecfcb67c0306da23d188f9e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;exec&lt;/em&gt; form makes it possible to avoid shell string munging, and to &lt;code&gt;RUN&lt;/code&gt; commands using a base image that does not contain the specified shell executable.</source>
          <target state="translated">在&lt;em&gt;EXEC&lt;/em&gt;形式使得能够避免壳串改写（munging），以及 &lt;code&gt;RUN&lt;/code&gt; 使用不包含指定壳可执行基本图像的命令。</target>
        </trans-unit>
        <trans-unit id="7658e2cd9f6d19cd1a74039c07d230202a829f8c" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;shell&lt;/em&gt; form prevents any &lt;code&gt;CMD&lt;/code&gt; or &lt;code&gt;run&lt;/code&gt; command line arguments from being used, but has the disadvantage that your &lt;code&gt;ENTRYPOINT&lt;/code&gt; will be started as a subcommand of &lt;code&gt;/bin/sh -c&lt;/code&gt;, which does not pass signals. This means that the executable will not be the container&amp;rsquo;s &lt;code&gt;PID 1&lt;/code&gt; - and will &lt;em&gt;not&lt;/em&gt; receive Unix signals - so your executable will not receive a &lt;code&gt;SIGTERM&lt;/code&gt; from &lt;code&gt;docker stop &amp;lt;container&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">所述&lt;em&gt;壳&lt;/em&gt;形式防止任何 &lt;code&gt;CMD&lt;/code&gt; 或 &lt;code&gt;run&lt;/code&gt; 命令行参数被使用，但是具有的缺点是您的 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 将启动作为一个子命令 &lt;code&gt;/bin/sh -c&lt;/code&gt; ，其不通过信号。这意味着可执行文件将不是容器的 &lt;code&gt;PID 1&lt;/code&gt; ，并且&lt;em&gt;不会&lt;/em&gt;接收Unix信号，因此您的可执行文件将不会从 &lt;code&gt;docker stop &amp;lt;container&amp;gt;&lt;/code&gt; 接收到 &lt;code&gt;SIGTERM&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="58b7b4aa81e7c742e582727ad709a516ccd434f0" translate="yes" xml:space="preserve">
          <source>The API is versioned via an Accept header, which currently is always set to &lt;code&gt;application/vnd.docker.plugins.v1+json&lt;/code&gt;.</source>
          <target state="translated">该API通过Accept标头进行版本控制，该标头当前始终设置为 &lt;code&gt;application/vnd.docker.plugins.v1+json&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9e306793d0c42815f9b23cd928d98f6eb8a992cc" translate="yes" xml:space="preserve">
          <source>The BugSnag API key to use to report errors.</source>
          <target state="translated">用于报告错误的 BugSnag API 密钥。</target>
        </trans-unit>
        <trans-unit id="a5433b4be7d70650a05b6da15569a592be1d2f16" translate="yes" xml:space="preserve">
          <source>The CLI interprets the &lt;code&gt;.dockerignore&lt;/code&gt; file as a newline-separated list of patterns similar to the file globs of Unix shells. For the purposes of matching, the root of the context is considered to be both the working and the root directory. For example, the patterns &lt;code&gt;/foo/bar&lt;/code&gt; and &lt;code&gt;foo/bar&lt;/code&gt; both exclude a file or directory named &lt;code&gt;bar&lt;/code&gt; in the &lt;code&gt;foo&lt;/code&gt; subdirectory of &lt;code&gt;PATH&lt;/code&gt; or in the root of the git repository located at &lt;code&gt;URL&lt;/code&gt;. Neither excludes anything else.</source>
          <target state="translated">CLI将 &lt;code&gt;.dockerignore&lt;/code&gt; 文件解释为以换行符分隔的模式列表，类似于Unix shell的文件组。为了匹配，上下文的根被认为是工作目录和根目录。例如，模式 &lt;code&gt;/foo/bar&lt;/code&gt; 和 &lt;code&gt;foo/bar&lt;/code&gt; 都排除 &lt;code&gt;PATH&lt;/code&gt; 的 &lt;code&gt;foo&lt;/code&gt; 子目录中或位于 &lt;code&gt;URL&lt;/code&gt; 的git信息库根目录中名为 &lt;code&gt;bar&lt;/code&gt; 的文件或目录。都不排除其他任何东西。</target>
        </trans-unit>
        <trans-unit id="8a6904fbb817ebee7ff84f7e6d4354ab155db813" translate="yes" xml:space="preserve">
          <source>The Compose file can also be provided as standard input with &lt;code&gt;--compose-file -&lt;/code&gt;:</source>
          <target state="translated">还可以通过 &lt;code&gt;--compose-file -&lt;/code&gt; 作为标准输入提供Compose文件：</target>
        </trans-unit>
        <trans-unit id="9a8f68cb614e118d7a4b20ace969787816ab48d0" translate="yes" xml:space="preserve">
          <source>The Compose file formats are now described in these references, specific to each version.</source>
          <target state="translated">Compose文件格式现在在这些参考资料中描述,具体到每个版本。</target>
        </trans-unit>
        <trans-unit id="1d29374d8810128ad1904bc2c9e9b744865870f4" translate="yes" xml:space="preserve">
          <source>The Compose file is a &lt;a href=&quot;http://yaml.org/&quot;&gt;YAML&lt;/a&gt; file defining &lt;a href=&quot;#service-configuration-reference&quot;&gt;services&lt;/a&gt;, &lt;a href=&quot;#network-configuration-reference&quot;&gt;networks&lt;/a&gt; and &lt;a href=&quot;#volume-configuration-reference&quot;&gt;volumes&lt;/a&gt;. The default path for a Compose file is &lt;code&gt;./docker-compose.yml&lt;/code&gt;.</source>
          <target state="translated">Compose文件是一个&lt;a href=&quot;http://yaml.org/&quot;&gt;YAML&lt;/a&gt;文件，用于定义&lt;a href=&quot;#service-configuration-reference&quot;&gt;服务&lt;/a&gt;，&lt;a href=&quot;#network-configuration-reference&quot;&gt;网络&lt;/a&gt;和&lt;a href=&quot;#volume-configuration-reference&quot;&gt;卷&lt;/a&gt;。Compose文件的默认路径是 &lt;code&gt;./docker-compose.yml&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3f2e30c63852d32e3d75aa2f8d4ff22ba7d03a09" translate="yes" xml:space="preserve">
          <source>The Compose file is a &lt;a href=&quot;http://yaml.org/&quot;&gt;YAML&lt;/a&gt; file defining services, networks, and volumes for a Docker application.</source>
          <target state="translated">Compose文件是一个&lt;a href=&quot;http://yaml.org/&quot;&gt;YAML&lt;/a&gt;文件，定义了Docker应用程序的服务，网络和卷。</target>
        </trans-unit>
        <trans-unit id="516fc9fe7a027246ddf927cabfb86b10368bf5ea" translate="yes" xml:space="preserve">
          <source>The DigitalOcean driver uses &lt;code&gt;ubuntu-16-04-x64&lt;/code&gt; as the default image.</source>
          <target state="translated">DigitalOcean驱动程序使用 &lt;code&gt;ubuntu-16-04-x64&lt;/code&gt; 作为默认映像。</target>
        </trans-unit>
        <trans-unit id="60e1c1a3e2fc863f910eda1e82acf0df54987727" translate="yes" xml:space="preserve">
          <source>The Docker API only supports requests from clients which report a specific version. If you receive a &lt;code&gt;client and server don't have same version&lt;/code&gt; error using &lt;code&gt;docker-compose&lt;/code&gt;, you can workaround this error by setting this environment variable. Set the version value to match the server version.</source>
          <target state="translated">Docker API仅支持来自报告特定版本的客户端的请求。如果使用 &lt;code&gt;docker-compose&lt;/code&gt; 收到 &lt;code&gt;client and server don't have same version&lt;/code&gt; 错误，则可以通过设置此环境变量来解决此错误。设置版本值以匹配服务器版本。</target>
        </trans-unit>
        <trans-unit id="d1504232c28254b9f9fcec3e6f6770c5273875bb" translate="yes" xml:space="preserve">
          <source>The Docker Engine - our lightweight and powerful open source containerization technology combined with a work flow for building and containerizing your applications.</source>
          <target state="translated">Docker引擎--我们的轻量级和强大的开源容器化技术与构建和容器化应用程序的工作流程相结合。</target>
        </trans-unit>
        <trans-unit id="e981d539da2aad65e18d80315ff72524e7e5303d" translate="yes" xml:space="preserve">
          <source>The Docker Engine can be configured to only run signed images. The Docker Content Trust signature verification feature is built directly into the &lt;code&gt;dockerd&lt;/code&gt; binary.</source>
          <target state="translated">可以将Docker引擎配置为仅运行签名的映像。Docker Content Trust签名验证功能直接内置在 &lt;code&gt;dockerd&lt;/code&gt; 二进制文件中。</target>
        </trans-unit>
        <trans-unit id="769b3a4ec31c20cda0955586d45d677bc3ea572f" translate="yes" xml:space="preserve">
          <source>The Docker Engine can keep user credentials in an external credentials store, such as the native keychain of the operating system. Using an external store is more secure than storing credentials in the Docker configuration file.</source>
          <target state="translated">Docker引擎可以将用户凭证保存在外部凭证存储中,比如操作系统的本机钥匙链。使用外部存储比在Docker配置文件中存储凭证更安全。</target>
        </trans-unit>
        <trans-unit id="a95fdd73bfffcdc36ab59e6eb0861915736278a5" translate="yes" xml:space="preserve">
          <source>The Docker Engine client takes care of these name expansions for you so do not change the names you use with the Engine client or API. This is a requirement only when interacting with the same Docker Hub repositories through the Notary client.</source>
          <target state="translated">Docker Engine客户端会为你处理这些名称扩展,所以不要更改你在Engine客户端或API中使用的名称。这只是在通过Notary客户端与相同的Docker Hub存储库进行交互时的要求。</target>
        </trans-unit>
        <trans-unit id="e5e6b53dfbe1a35edb43e21132908b08612d8d0b" translate="yes" xml:space="preserve">
          <source>The Docker Engine joins the swarm depending on the &lt;strong&gt;join-token&lt;/strong&gt; you provide to the &lt;code&gt;docker swarm join&lt;/code&gt; command. The node only uses the token at join time. If you subsequently rotate the token, it doesn&amp;rsquo;t affect existing swarm nodes. Refer to &lt;a href=&quot;../swarm-mode/index#view-the-join-command-or-update-a-swarm-join-token&quot;&gt;Run Docker Engine in swarm mode&lt;/a&gt;.</source>
          <target state="translated">Docker引擎根据您提供给 &lt;code&gt;docker swarm join&lt;/code&gt; 命令的&lt;strong&gt;连接令牌&lt;/strong&gt;来加入swarm。该节点仅在加入时使用令牌。如果您随后旋转令牌，那么它不会影响现有的群集节点。请参阅以&lt;a href=&quot;../swarm-mode/index#view-the-join-command-or-update-a-swarm-join-token&quot;&gt;群体模式运行Docker Engine&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f02c0b12a5516b4fd13dbbd313dee5b1eda6fe97" translate="yes" xml:space="preserve">
          <source>The Docker Engine returns an error if the driver is not available.</source>
          <target state="translated">如果驱动程序不可用,Docker引擎会返回一个错误。</target>
        </trans-unit>
        <trans-unit id="26a113db9a410ab73f222f9bca15d695db3743ad" translate="yes" xml:space="preserve">
          <source>The Docker client stores the keys in the &lt;code&gt;~/.docker/trust/private&lt;/code&gt; directory. Before backing them up, you should &lt;code&gt;tar&lt;/code&gt; them into an archive:</source>
          <target state="translated">Docker客户端将密钥存储在 &lt;code&gt;~/.docker/trust/private&lt;/code&gt; 目录中。在备份之前，您应该 &lt;code&gt;tar&lt;/code&gt; 他们到存档：</target>
        </trans-unit>
        <trans-unit id="f784453fb940cff3136cf6c4eccf303e18360b96" translate="yes" xml:space="preserve">
          <source>The Docker client will honor the &lt;code&gt;DOCKER_HOST&lt;/code&gt; environment variable to set the &lt;code&gt;-H&lt;/code&gt; flag for the client. Use &lt;strong&gt;one&lt;/strong&gt; of the following commands:</source>
          <target state="translated">Docker客户端将使用 &lt;code&gt;DOCKER_HOST&lt;/code&gt; 环境变量为客户端设置 &lt;code&gt;-H&lt;/code&gt; 标志。使用&lt;strong&gt;一个&lt;/strong&gt;下面的命令：</target>
        </trans-unit>
        <trans-unit id="b9b1e227b06064053804ed860bc5f7814dea3d4e" translate="yes" xml:space="preserve">
          <source>The Docker client will honor the &lt;code&gt;HTTP_PROXY&lt;/code&gt;, &lt;code&gt;HTTPS_PROXY&lt;/code&gt;, and &lt;code&gt;NO_PROXY&lt;/code&gt; environment variables (or the lowercase versions thereof). &lt;code&gt;HTTPS_PROXY&lt;/code&gt; takes precedence over &lt;code&gt;HTTP_PROXY&lt;/code&gt;.</source>
          <target state="translated">Docker客户端将使用 &lt;code&gt;HTTP_PROXY&lt;/code&gt; ， &lt;code&gt;HTTPS_PROXY&lt;/code&gt; 和 &lt;code&gt;NO_PROXY&lt;/code&gt; 环境变量（或其小写版本）。 &lt;code&gt;HTTPS_PROXY&lt;/code&gt; 优先于 &lt;code&gt;HTTP_PROXY&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a5c8f241b1b8d61a93d92c1530c2e12812c43b35" translate="yes" xml:space="preserve">
          <source>The Docker daemon can listen for &lt;a href=&quot;https://docs.docker.com/develop/sdk&quot;&gt;Docker Engine API&lt;/a&gt; requests via three different types of Socket: &lt;code&gt;unix&lt;/code&gt;, &lt;code&gt;tcp&lt;/code&gt;, and &lt;code&gt;fd&lt;/code&gt;.</source>
          <target state="translated">Docker守护程序可以通过三种不同类型的Socket 监听&lt;a href=&quot;https://docs.docker.com/develop/sdk&quot;&gt;Docker Engine API&lt;/a&gt;请求： &lt;code&gt;unix&lt;/code&gt; ， &lt;code&gt;tcp&lt;/code&gt; 和 &lt;code&gt;fd&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b9c9784a3450d3d22b2aa9a2e66a2518f32553f2" translate="yes" xml:space="preserve">
          <source>The Docker daemon interprets &lt;code&gt;.crt&lt;/code&gt; files as CA certificates and &lt;code&gt;.cert&lt;/code&gt; files as client certificates. If a CA certificate is accidentally given the extension &lt;code&gt;.cert&lt;/code&gt; instead of the correct &lt;code&gt;.crt&lt;/code&gt; extension, the Docker daemon logs the following error message:</source>
          <target state="translated">Docker守护程序将 &lt;code&gt;.crt&lt;/code&gt; 文件解释为CA证书，并将 &lt;code&gt;.cert&lt;/code&gt; 文件解释为客户端证书。如果一个CA证书被意外赋予扩展名 &lt;code&gt;.cert&lt;/code&gt; 而不是正确的 &lt;code&gt;.crt&lt;/code&gt; 扩展名，则Docker守护程序会记录以下错误消息：</target>
        </trans-unit>
        <trans-unit id="cb898408cbd90376be8d461674bfc0ca2aa29162" translate="yes" xml:space="preserve">
          <source>The Docker daemon relies on a &lt;a href=&quot;https://github.com/opencontainers/runtime-spec&quot;&gt;OCI&lt;/a&gt; compliant runtime (invoked via the &lt;code&gt;containerd&lt;/code&gt; daemon) as its interface to the Linux kernel &lt;code&gt;namespaces&lt;/code&gt;, &lt;code&gt;cgroups&lt;/code&gt;, and &lt;code&gt;SELinux&lt;/code&gt;.</source>
          <target state="translated">Docker守护程序依赖于&lt;a href=&quot;https://github.com/opencontainers/runtime-spec&quot;&gt;OCI&lt;/a&gt;兼容运行时（通过 &lt;code&gt;containerd&lt;/code&gt; 守护程序调用）作为其与Linux内核 &lt;code&gt;namespaces&lt;/code&gt; ， &lt;code&gt;cgroups&lt;/code&gt; 和 &lt;code&gt;SELinux&lt;/code&gt; 的接口。</target>
        </trans-unit>
        <trans-unit id="6f8b8fe412b9032f49ad4147a38c5684876ea1dd" translate="yes" xml:space="preserve">
          <source>The Docker daemon runs the instructions in the &lt;code&gt;Dockerfile&lt;/code&gt; one-by-one, committing the result of each instruction to a new image if necessary, before finally outputting the ID of your new image. The Docker daemon will automatically clean up the context you sent.</source>
          <target state="translated">Docker守护程序会 &lt;code&gt;Dockerfile&lt;/code&gt; 运行Dockerfile中的指令，并在最终输出新映像的ID之前，将每个指令的结果提交到新映像。Docker守护程序将自动清理您发送的上下文。</target>
        </trans-unit>
        <trans-unit id="b6e1be11d17f40601ae630a15a10dbd070a820fd" translate="yes" xml:space="preserve">
          <source>The Docker swarm mode scheduler may reschedule your running service containers at any time if they become unhealthy or unreachable.</source>
          <target state="translated">Docker群模式调度器可以在任何时候重新安排你正在运行的服务容器,如果它们变得不健康或无法到达。</target>
        </trans-unit>
        <trans-unit id="72310a65dcf93f71664669032c86d03ef6046ea8" translate="yes" xml:space="preserve">
          <source>The Dockerfile defines an application&amp;rsquo;s image content via one or more build commands that configure that image. Once built, you can run the image in a container. For more information on &lt;code&gt;Dockerfile&lt;/code&gt;, see the &lt;a href=&quot;../../get-started/index#building-an-image-from-a-dockerfile&quot;&gt;Docker user guide&lt;/a&gt; and the &lt;a href=&quot;../../engine/reference/builder/index&quot;&gt;Dockerfile reference&lt;/a&gt;.</source>
          <target state="translated">Dockerfile通过一个或多个配置该映像的构建命令来定义应用程序的映像内容。构建完成后，您可以在容器中运行映像。有关 &lt;code&gt;Dockerfile&lt;/code&gt; 的更多信息，请参阅《&lt;a href=&quot;../../get-started/index#building-an-image-from-a-dockerfile&quot;&gt;Docker用户指南》&lt;/a&gt;和《&lt;a href=&quot;../../engine/reference/builder/index&quot;&gt;Dockerfile参考》&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d8db94bec7c2e718a34b45671510f274255de23e" translate="yes" xml:space="preserve">
          <source>The Engine mounts binds and volumes</source>
          <target state="translated">发动机悬置绑定和体积</target>
        </trans-unit>
        <trans-unit id="77a5c1284bd5d29f74b9038bb69295fca9657338" translate="yes" xml:space="preserve">
          <source>The Exoscale driver does an educated guess to pick the correct default SSH user. If left empty, it picks a suitable one following those rules:</source>
          <target state="translated">Exoscale 驱动程序会进行有根据的猜测来选择正确的默认 SSH 用户。如果是空的,它会根据这些规则选择一个合适的用户。</target>
        </trans-unit>
        <trans-unit id="e7776bb7b1feb0cdf6b9d378083948ecee5a364b" translate="yes" xml:space="preserve">
          <source>The GCE driver uses the &lt;code&gt;ubuntu-1604-xenial-v20161130&lt;/code&gt; instance image unless otherwise specified. To obtain a list of image URLs run:</source>
          <target state="translated">除非另有说明，否则GCE驱动程序使用 &lt;code&gt;ubuntu-1604-xenial-v20161130&lt;/code&gt; 实例映像。要获取图像URL的列表，请运行：</target>
        </trans-unit>
        <trans-unit id="3ed225f02abcd916a36da6d5362330e6ef486c76" translate="yes" xml:space="preserve">
          <source>The GRPC port of the remote trust service</source>
          <target state="translated">远程信任服务的GRPC端口</target>
        </trans-unit>
        <trans-unit id="01efbfe017c227f04baa00c60ccb41e0ae379e7a" translate="yes" xml:space="preserve">
          <source>The Google driver uses &lt;a href=&quot;https://developers.google.com/identity/protocols/application-default-credentials&quot;&gt;Application Default Credentials&lt;/a&gt; to get authorization credentials for use in calling Google APIs.</source>
          <target state="translated">Google驱动程序使用&lt;a href=&quot;https://developers.google.com/identity/protocols/application-default-credentials&quot;&gt;应用程序默认凭据&lt;/a&gt;来获取授权凭据，以用于调用Google API。</target>
        </trans-unit>
        <trans-unit id="f4f3efcfd0b9bf004bc8b95386891f6d660ca1c4" translate="yes" xml:space="preserve">
          <source>The HTML output is truncated:</source>
          <target state="translated">HTML输出是截断的。</target>
        </trans-unit>
        <trans-unit id="28915ec304ba22579fc2a14faedd1ca73cf26b2f" translate="yes" xml:space="preserve">
          <source>The HTTP method (GET/DELETE/POST)</source>
          <target state="translated">HTTP方法(GET/DELETE/POST)</target>
        </trans-unit>
        <trans-unit id="2631817e449cb6201d6128453c2b450e67c7f0c6" translate="yes" xml:space="preserve">
          <source>The HTTP request URI including API version (e.g., v.1.17/containers/json)</source>
          <target state="translated">包括API版本的HTTP请求URI(如v.1.17/containers/json)。</target>
        </trans-unit>
        <trans-unit id="f6b4e4056419626a88d045ad2a89f79c6a1828c1" translate="yes" xml:space="preserve">
          <source>The IP address must be assigned to a network interface available to the host operating system. All nodes in the swarm need to connect to the manager at the IP address.</source>
          <target state="translated">IP地址必须分配给主机操作系统可用的网络接口。群中的所有节点都需要通过IP地址连接到管理器。</target>
        </trans-unit>
        <trans-unit id="b59ce3b3c22ba1282f1f27b4d7318e2a6aed4b0a" translate="yes" xml:space="preserve">
          <source>The IP address of the manager machine</source>
          <target state="translated">管理机的IP地址</target>
        </trans-unit>
        <trans-unit id="14e893cc4f0f163841ea538ac2b79f8d8a3b79da" translate="yes" xml:space="preserve">
          <source>The Linode Instance &lt;code&gt;image&lt;/code&gt; which provides the Linux distribution (see &lt;a href=&quot;https://api.linode.com/v4/images&quot;&gt;here&lt;/a&gt;).</source>
          <target state="translated">提供Linux发行版的Linode实例 &lt;code&gt;image&lt;/code&gt; （请参阅&lt;a href=&quot;https://api.linode.com/v4/images&quot;&gt;此处&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="83b7e9cefa7ff387cdd56e7ff68e1a677949aefe" translate="yes" xml:space="preserve">
          <source>The Linode Instance &lt;code&gt;label&lt;/code&gt;, unless overridden this will match the docker-machine name. This &lt;code&gt;label&lt;/code&gt; must be unique on the account.</source>
          <target state="translated">Linode Instance &lt;code&gt;label&lt;/code&gt; ，除非被覆盖，否则它将与docker-machine名称匹配。此 &lt;code&gt;label&lt;/code&gt; 在帐户上必须是唯一的。</target>
        </trans-unit>
        <trans-unit id="bcc9c3a146345291574afc8492f61ed2e65b48d2" translate="yes" xml:space="preserve">
          <source>The Linode Instance &lt;code&gt;region&lt;/code&gt; (see &lt;a href=&quot;https://api.linode.com/v4/regions&quot;&gt;here&lt;/a&gt;)</source>
          <target state="translated">Linode实例 &lt;code&gt;region&lt;/code&gt; （请参阅&lt;a href=&quot;https://api.linode.com/v4/regions&quot;&gt;此处&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="6ae16b541187b536715d8341f613c9b770516823" translate="yes" xml:space="preserve">
          <source>The Linode Instance &lt;code&gt;root_pass&lt;/code&gt; (password assigned to the &lt;code&gt;root&lt;/code&gt; account)</source>
          <target state="translated">Linode实例 &lt;code&gt;root_pass&lt;/code&gt; （分配给 &lt;code&gt;root&lt;/code&gt; 帐户的密码）</target>
        </trans-unit>
        <trans-unit id="5668a87d5f3cb3f0f372b8772fdf1ff3faa88431" translate="yes" xml:space="preserve">
          <source>The Linode Instance &lt;code&gt;type&lt;/code&gt; (see &lt;a href=&quot;https://api.linode.com/v4/linode/types&quot;&gt;here&lt;/a&gt;)</source>
          <target state="translated">Linode实例 &lt;code&gt;type&lt;/code&gt; （请参阅&lt;a href=&quot;https://api.linode.com/v4/linode/types&quot;&gt;此处&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="ab313ad7fbd67b8ea1f71091c8c23d1efc05816d" translate="yes" xml:space="preserve">
          <source>The Linux kernel &lt;a href=&quot;http://man7.org/linux/man-pages/man7/user_namespaces.7.html&quot;&gt;user namespace support&lt;/a&gt; provides additional security by enabling a process, and therefore a container, to have a unique range of user and group IDs which are outside the traditional user and group range utilized by the host system. Potentially the most important security improvement is that, by default, container processes running as the &lt;code&gt;root&lt;/code&gt; user will have expected administrative privilege (with some restrictions) inside the container but will effectively be mapped to an unprivileged &lt;code&gt;uid&lt;/code&gt; on the host.</source>
          <target state="translated">Linux内核&lt;a href=&quot;http://man7.org/linux/man-pages/man7/user_namespaces.7.html&quot;&gt;用户名称空间支持&lt;/a&gt;通过使进程（从而使容器）具有唯一范围的用户和组ID来提供额外的安全性，这些范围在主机系统使用的传统用户和组范围之外。潜在的最重要的安全改进是，默认情况下，以 &lt;code&gt;root&lt;/code&gt; 用户身份运行的容器进程将在容器内部具有预期的管理特权（有一些限制），但将有效地映射到主机上的非特权 &lt;code&gt;uid&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="000c040d8ab5e7c7ac50c8fdd132c54bd647e56f" translate="yes" xml:space="preserve">
          <source>The Machine provisioning process will:</source>
          <target state="translated">机配置过程将。</target>
        </trans-unit>
        <trans-unit id="4cfd5fd9df9bb644721ce760e1a72a350c0aac10" translate="yes" xml:space="preserve">
          <source>The Machine repository supplies several &lt;code&gt;bash&lt;/code&gt; scripts that add features such as:</source>
          <target state="translated">Machine存储库提供了几个 &lt;code&gt;bash&lt;/code&gt; 脚本，这些脚本添加了以下功能：</target>
        </trans-unit>
        <trans-unit id="a6915b8754b576be2fa1f8db4e62a17da6c7cb93" translate="yes" xml:space="preserve">
          <source>The Notary Service always holds the timestamp key. If the attacker has Notary Service write credentials, then they have effective access to the timestamp key because the server generates and signs the timestamp for them.</source>
          <target state="translated">公证处始终持有时间戳密钥。如果攻击者拥有公证处的写入凭证,那么他们就可以有效地获取时间戳密钥,因为服务器会为他们生成和签署时间戳。</target>
        </trans-unit>
        <trans-unit id="f510469dc42e51346acf512073fd66bf115cb369" translate="yes" xml:space="preserve">
          <source>The Notary repository includes sample certificates in the fixtures directory. When you initialize a development service using the provided &lt;code&gt;docker-compose.yml&lt;/code&gt; file, these sample certificates are used to create a more production like environment.</source>
          <target state="translated">公证存储库在fixtures目录中包括样本证书。使用提供 &lt;code&gt;docker-compose.yml&lt;/code&gt; 文件初始化开发服务时，这些示例证书将用于创建更像生产环境的环境。</target>
        </trans-unit>
        <trans-unit id="50de710da14be82d6d655046022a33a82c1ccc49" translate="yes" xml:space="preserve">
          <source>The Notary signer is responsible for:</source>
          <target state="translated">公证人签字人负责:</target>
        </trans-unit>
        <trans-unit id="c7afa7afbcd2ecc33c972605b1ce47bb9ca61017" translate="yes" xml:space="preserve">
          <source>The Plugin API is RPC-style JSON over HTTP, much like webhooks.</source>
          <target state="translated">Plugin API是通过HTTP的RPC式JSON,很像webhooks。</target>
        </trans-unit>
        <trans-unit id="c227709ccd232d5e24a6d93f58178e25df562116" translate="yes" xml:space="preserve">
          <source>The Rackspace driver uses &lt;code&gt;821ba5f4-712d-4ec8-9c65-a3fa4bc500f9&lt;/code&gt; (Ubuntu 16.04 LTS) by default.</source>
          <target state="translated">默认情况下，Rackspace驱动程序使用 &lt;code&gt;821ba5f4-712d-4ec8-9c65-a3fa4bc500f9&lt;/code&gt; （Ubuntu 16.04 LTS）。</target>
        </trans-unit>
        <trans-unit id="82a21a7905a3cbb90eca7f4af732c295bd94e70a" translate="yes" xml:space="preserve">
          <source>The SoftLayer driver uses &lt;code&gt;UBUNTU_LATEST&lt;/code&gt; as the image type by default.</source>
          <target state="translated">默认情况下，SoftLayer驱动程序使用 &lt;code&gt;UBUNTU_LATEST&lt;/code&gt; 作为图像类型。</target>
        </trans-unit>
        <trans-unit id="3bb056935b1763e55e51fba63a4a7934510e7050" translate="yes" xml:space="preserve">
          <source>The TCP address (IP and port) to listen for GRPC traffic. Examples:</source>
          <target state="translated">侦听GRPC流量的TCP地址(IP和端口)。例如:</target>
        </trans-unit>
        <trans-unit id="88b4794d69904fc8e3ffc932b8cfd22da1dd7afc" translate="yes" xml:space="preserve">
          <source>The TCP address (IP and port) to listen for HTTP traffic on. Examples:</source>
          <target state="translated">侦听HTTP流量的TCP地址(IP和端口)。例如:</target>
        </trans-unit>
        <trans-unit id="58f9d4f77b99b0275d71525e448d6600d2ca8f64" translate="yes" xml:space="preserve">
          <source>The TCP address (IP and port) to listen on. Examples:</source>
          <target state="translated">要监听的TCP地址(IP和端口)。例如:</target>
        </trans-unit>
        <trans-unit id="7f378ce0f64115e9ae1db3da7716eb7c2cda8d30" translate="yes" xml:space="preserve">
          <source>The TCP port of the Linode that Docker will be listening on</source>
          <target state="translated">Docker将监听的Linode的TCP端口。</target>
        </trans-unit>
        <trans-unit id="4f34c1c251f453c03bae93c9980a57d4667489ef" translate="yes" xml:space="preserve">
          <source>The UTS namespace is for setting the hostname and the domain that is visible to running processes in that namespace. By default, all containers, including those with &lt;code&gt;--network=host&lt;/code&gt;, have their own UTS namespace. The &lt;code&gt;host&lt;/code&gt; setting will result in the container using the same UTS namespace as the host. Note that &lt;code&gt;--hostname&lt;/code&gt; and &lt;code&gt;--domainname&lt;/code&gt; are invalid in &lt;code&gt;host&lt;/code&gt; UTS mode.</source>
          <target state="translated">UTS名称空间用于设置主机名和对该名称空间中正在运行的进程可见的域。默认情况下，所有容器（包括带有 &lt;code&gt;--network=host&lt;/code&gt; 的容器）都具有自己的UTS命名空间。该 &lt;code&gt;host&lt;/code&gt; 的设置会导致容器使用相同的UTS命名空间的主机。请注意， &lt;code&gt;--hostname&lt;/code&gt; 和 &lt;code&gt;--domainname&lt;/code&gt; 在 &lt;code&gt;host&lt;/code&gt; UTS模式下无效。</target>
        </trans-unit>
        <trans-unit id="9570e3606e8e0207aa0ccc41a7f3d6bbb9a975b3" translate="yes" xml:space="preserve">
          <source>The UUID identifiers come from the Docker daemon. If you do not assign a container name with the &lt;code&gt;--name&lt;/code&gt; option, then the daemon generates a random string name for you. Defining a &lt;code&gt;name&lt;/code&gt; can be a handy way to add meaning to a container. If you specify a &lt;code&gt;name&lt;/code&gt;, you can use it when referencing the container within a Docker network. This works for both background and foreground Docker containers.</source>
          <target state="translated">UUID标识符来自Docker守护程序。如果未使用 &lt;code&gt;--name&lt;/code&gt; 选项分配容器名称，则守护程序将为您生成一个随机字符串名称。定义 &lt;code&gt;name&lt;/code&gt; 是向容器添加含义的便捷方法。如果指定 &lt;code&gt;name&lt;/code&gt; ，则可以在Docker网络中引用容器时使用它。这适用于后台和前台Docker容器。</target>
        </trans-unit>
        <trans-unit id="d79d287da69a4a3f2d788cfe61abfc21d2875db3" translate="yes" xml:space="preserve">
          <source>The VAR_NOT_INTERPOLATED_BY_COMPOSE is not set. Substituting an empty string.</source>
          <target state="translated">VAR_NOT_INTERPOLATED_BY_COMPOSE没有设置。代替一个空字符串。</target>
        </trans-unit>
        <trans-unit id="fd2331cc37261fcbeb226c52aee1f2bad68a2512" translate="yes" xml:space="preserve">
          <source>The VMware Fusion driver uses the latest boot2docker image. See &lt;a href=&quot;https://github.com/boot2docker/boot2docker&quot;&gt;frapposelli/boot2docker&lt;/a&gt;</source>
          <target state="translated">VMware Fusion驱动程序使用最新的boot2docker映像。参见&lt;a href=&quot;https://github.com/boot2docker/boot2docker&quot;&gt;frapposelli / boot2docker&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b92c6a3df559cf9f9bf7e2a377d941da13c2302a" translate="yes" xml:space="preserve">
          <source>The VMware vCloud Air driver uses the &lt;code&gt;Ubuntu Server 12.04 LTS (amd64 20140927)&lt;/code&gt; image by default.</source>
          <target state="translated">默认情况下，VMware vCloud Air驱动程序使用 &lt;code&gt;Ubuntu Server 12.04 LTS (amd64 20140927)&lt;/code&gt; 映像。</target>
        </trans-unit>
        <trans-unit id="1f1f49461b6458d5fa20b8e5eef851e3e1e7567b" translate="yes" xml:space="preserve">
          <source>The VMware vSphere driver uses the latest boot2docker image.</source>
          <target state="translated">VMware vSphere 驱动程序使用最新的 boot2docker 映像。</target>
        </trans-unit>
        <trans-unit id="ac2fd9823008d438c71601d7a5b438706dd53245" translate="yes" xml:space="preserve">
          <source>The Version 1 Compose file is a &lt;a href=&quot;http://yaml.org/&quot;&gt;YAML&lt;/a&gt; file that defines &lt;a href=&quot;#service-configuration-reference&quot;&gt;services&lt;/a&gt;.</source>
          <target state="translated">版本1撰写文件是定义&lt;a href=&quot;#service-configuration-reference&quot;&gt;服务&lt;/a&gt;的&lt;a href=&quot;http://yaml.org/&quot;&gt;YAML&lt;/a&gt;文件。</target>
        </trans-unit>
        <trans-unit id="053bbb5df4e49691e9c5c6aa76dfa2421d6004be" translate="yes" xml:space="preserve">
          <source>The above command sets the &lt;em&gt;desired&lt;/em&gt; number of tasks for the service. Even though the command returns immediately, actual scaling of the service may take some time. The &lt;code&gt;REPLICAS&lt;/code&gt; column shows both the &lt;em&gt;actual&lt;/em&gt; and &lt;em&gt;desired&lt;/em&gt; number of replica tasks for the service.</source>
          <target state="translated">上面的命令为服务设置&lt;em&gt;所需&lt;/em&gt;的任务数。即使命令立即返回，服务的实际扩展也可能需要一些时间。该 &lt;code&gt;REPLICAS&lt;/code&gt; 列显示无论是&lt;em&gt;实际&lt;/em&gt;和&lt;em&gt;所需&lt;/em&gt;数量的服务副本任务。</target>
        </trans-unit>
        <trans-unit id="9d5d9e53c576fe5f14e8462005d5c33d1293b13b" translate="yes" xml:space="preserve">
          <source>The above command will use the current directory as the build context and read a Dockerfile from stdin.</source>
          <target state="translated">上面的命令将使用当前目录作为构建上下文,并从stdin中读取一个Dockerfile。</target>
        </trans-unit>
        <trans-unit id="34faf87ada6f2c49d8b93b6a04fcd4278bb71522" translate="yes" xml:space="preserve">
          <source>The above command works on Windows only if you use a terminal emulator such as &lt;a href=&quot;https://git-for-windows.github.io/&quot;&gt;Git BASH&lt;/a&gt;, which supports Linux commands like &lt;code&gt;chmod&lt;/code&gt;.</source>
          <target state="translated">仅当使用支持&lt;a href=&quot;https://git-for-windows.github.io/&quot;&gt;Git BASH&lt;/a&gt;的终端仿真器（如 &lt;code&gt;chmod&lt;/code&gt; )支持Linux命令时，以上命令才能在Windows上运行。</target>
        </trans-unit>
        <trans-unit id="34ea0c251fca629c07e331bace6e9df9d3f364b9" translate="yes" xml:space="preserve">
          <source>The above commands will build the current build context (as specified by the &lt;code&gt;.&lt;/code&gt;) twice, once using a debug version of a &lt;code&gt;Dockerfile&lt;/code&gt; and once using a production version.</source>
          <target state="translated">上面的命令将两次构建当前的构建上下文（由 &lt;code&gt;.&lt;/code&gt; 指定），一次使用 &lt;code&gt;Dockerfile&lt;/code&gt; 的调试版本，一次使用生产版本。</target>
        </trans-unit>
        <trans-unit id="5179bbf9a5fe4d0559c4202f0c4cdc5b926bb0bd" translate="yes" xml:space="preserve">
          <source>The above example for controlling log files and sizes uses options specific to the &lt;a href=&quot;https://docs.docker.com/config/containers/logging#json-file&quot;&gt;json-file driver&lt;/a&gt;. These particular options are not available on other logging drivers. For a full list of supported logging drivers and their options, see &lt;a href=&quot;https://docs.docker.com/config/containers/logging&quot;&gt;logging drivers&lt;/a&gt;.</source>
          <target state="translated">上面用于控制日志文件和大小的示例使用特定于&lt;a href=&quot;https://docs.docker.com/config/containers/logging#json-file&quot;&gt;json-file driver的&lt;/a&gt;选项。这些特定选项在其他日志记录驱动程序上不可用。有关受支持的日志记录驱动程序及其选项的完整列表，请参阅&lt;a href=&quot;https://docs.docker.com/config/containers/logging&quot;&gt;日志记录驱动程序&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f093a1321de60dc8c82ee545590e3b79fa5f264b" translate="yes" xml:space="preserve">
          <source>The above output shows that the &lt;code&gt;docker-default&lt;/code&gt; profile running on various container PIDs is in &lt;code&gt;enforce&lt;/code&gt; mode. This means AppArmor is actively blocking and auditing in &lt;code&gt;dmesg&lt;/code&gt; anything outside the bounds of the &lt;code&gt;docker-default&lt;/code&gt; profile.</source>
          <target state="translated">上面的输出显示，在各种容器PID上运行的 &lt;code&gt;docker-default&lt;/code&gt; 配置文件处于 &lt;code&gt;enforce&lt;/code&gt; 模式。这意味着AppArmor会主动阻止和审计 &lt;code&gt;dmesg&lt;/code&gt; 中 &lt;code&gt;docker-default&lt;/code&gt; 配置文件范围之外的任何内容。</target>
        </trans-unit>
        <trans-unit id="d200c15742fb2300e685da66c69867efdfe210c9" translate="yes" xml:space="preserve">
          <source>The actual extent of integration depends on which version of the &lt;a href=&quot;../compose-file/index#versioning&quot;&gt;Compose file format&lt;/a&gt; you are using:</source>
          <target state="translated">实际的集成程度取决于您所使用的&lt;a href=&quot;../compose-file/index#versioning&quot;&gt;Compose文件格式的&lt;/a&gt;版本：</target>
        </trans-unit>
        <trans-unit id="c53f12c881a1a893720f7f15ed293fb4da6174a6" translate="yes" xml:space="preserve">
          <source>The administrative keys listed specify the root key of trust, as well as the administrative repository key. These keys are responsible for modifying signers, and rotating keys for the signed repository.</source>
          <target state="translated">列出的管理密钥指定了信任的根密钥,以及管理存储库密钥。这些密钥负责修改签名者,以及轮换签名存储库的密钥。</target>
        </trans-unit>
        <trans-unit id="c79b727478823a0e43b0fc18d5e82dfe0f2c00b1" translate="yes" xml:space="preserve">
          <source>The amount of data the container has read to and written from block devices on the host</source>
          <target state="translated">容器对主机上的块设备读取和写入的数据量。</target>
        </trans-unit>
        <trans-unit id="2bf47d87fbe717e121dd86bd58bd038bd68358c7" translate="yes" xml:space="preserve">
          <source>The amount of data the container has sent and received over its network interface</source>
          <target state="translated">容器通过其网络接口发送和接收的数据量。</target>
        </trans-unit>
        <trans-unit id="590f9091420642ff940715d49d155ce5d6434be6" translate="yes" xml:space="preserve">
          <source>The amount of swap space provisioned on the Linode Instance</source>
          <target state="translated">在 Linode 实例上提供的交换空间的数量。</target>
        </trans-unit>
        <trans-unit id="420b520b189370c5709e162d6da932a4837c8376" translate="yes" xml:space="preserve">
          <source>The app is now bootable, but you&amp;rsquo;re not quite there yet. By default, Rails expects a database to be running on &lt;code&gt;localhost&lt;/code&gt; - so you need to point it at the &lt;code&gt;db&lt;/code&gt; container instead. You also need to change the database and username to align with the defaults set by the &lt;code&gt;postgres&lt;/code&gt; image.</source>
          <target state="translated">该应用程序现在可以启动，但是您还没有启动。默认情况下，Rails希望数据库在 &lt;code&gt;localhost&lt;/code&gt; 上运行-因此您需要将其指向 &lt;code&gt;db&lt;/code&gt; 容器。您还需要更改数据库和用户名，以与 &lt;code&gt;postgres&lt;/code&gt; 图像设置的默认值保持一致。</target>
        </trans-unit>
        <trans-unit id="7be6a30db5c572cf9181942bf629645491a22e50" translate="yes" xml:space="preserve">
          <source>The app itself</source>
          <target state="translated">应用本身</target>
        </trans-unit>
        <trans-unit id="2d56df5fefd85739b353e0b719bdb02818f55645" translate="yes" xml:space="preserve">
          <source>The arguments &lt;code&gt;alpine ping docker.com&lt;/code&gt; define the service as an Alpine Linux container that executes the command &lt;code&gt;ping docker.com&lt;/code&gt;.</source>
          <target state="translated">参数 &lt;code&gt;alpine ping docker.com&lt;/code&gt; 将服务定义为执行命令 &lt;code&gt;ping docker.com&lt;/code&gt; 的Alpine Linux容器。</target>
        </trans-unit>
        <trans-unit id="afa69edabec810d13a65a3dae4b99ff827c93ebf" translate="yes" xml:space="preserve">
          <source>The attacker does not have access to the timestamp key, which is always held by the Notary Service, and cannot set up a malicious mirror.</source>
          <target state="translated">攻击者无法获得时间戳密钥,而时间戳密钥始终由公证处持有,无法建立恶意镜像。</target>
        </trans-unit>
        <trans-unit id="92bc7e040b0ebdfa21b86e8239695e6807bea67a" translate="yes" xml:space="preserve">
          <source>The authentication method used</source>
          <target state="translated">使用的认证方法</target>
        </trans-unit>
        <trans-unit id="ce7c51376025d7fd3f3793a740d0bdaad6f07e17" translate="yes" xml:space="preserve">
          <source>The base command for the Docker CLI.</source>
          <target state="translated">Docker CLI的基本命令。</target>
        </trans-unit>
        <trans-unit id="12915a5aac3b55411ca3d3305b49845def9ac6b6" translate="yes" xml:space="preserve">
          <source>The base device size can be increased at daemon restart which will allow all future images and containers (based on those new images) to be of the new base device size.</source>
          <target state="translated">基本设备的大小可以在守护进程重新启动时增加,这将允许所有未来的映像和容器(基于这些新的映像)是新的基本设备大小。</target>
        </trans-unit>
        <trans-unit id="0703b58e4bf73ac4c5d674ad3512db88784d9285" translate="yes" xml:space="preserve">
          <source>The basic &lt;code&gt;docker run&lt;/code&gt; command takes this form:</source>
          <target state="translated">基本的 &lt;code&gt;docker run&lt;/code&gt; 命令采用以下形式：</target>
        </trans-unit>
        <trans-unit id="575b79f3ef4a8047ed7a1e057b92fbd05da4bf47" translate="yes" xml:space="preserve">
          <source>The best solution is to perform this check in your application code, both at startup and whenever a connection is lost for any reason. However, if you don&amp;rsquo;t need this level of resilience, you can work around the problem with a wrapper script:</source>
          <target state="translated">最好的解决方案是在启动时以及由于某种原因而断开连接时都在应用程序代码中执行此检查。但是，如果不需要此级别的弹性，则可以使用包装器脚本解决此问题：</target>
        </trans-unit>
        <trans-unit id="eda46c8cf09024e246ff7c52fa8ece30868a6e32" translate="yes" xml:space="preserve">
          <source>The best way to prevent privilege-escalation attacks from within a container is to configure your container&amp;rsquo;s applications to run as unprivileged users. For containers whose processes must run as the &lt;code&gt;root&lt;/code&gt; user within the container, you can re-map this user to a less-privileged user on the Docker host. The mapped user is assigned a range of UIDs which function within the namespace as normal UIDs from 0 to 65536, but have no privileges on the host machine itself.</source>
          <target state="translated">防止来自容器内部的特权升级攻击的最佳方法是将容器的应用程序配置为以非特权用户身份运行。对于其进程必须以容器内的 &lt;code&gt;root&lt;/code&gt; 用户身份运行的容器，您可以将该用户重新映射到Docker主机上的特权较低的用户。已为映射的用户分配了一系列UID，这些UID在名称空间中的作用为普通的UID（从0到65536），但对主机本身没有特权。</target>
        </trans-unit>
        <trans-unit id="f1f474ffbfb080d2299496ab85e3b7e63f8b4aa0" translate="yes" xml:space="preserve">
          <source>The best way to recover from losing the quorum is to bring the failed nodes back online. If you can&amp;rsquo;t do that, the only way to recover from this state is to use the &lt;code&gt;--force-new-cluster&lt;/code&gt; action from a manager node. This removes all managers except the manager the command was run from. The quorum is achieved because there is now only one manager. Promote nodes to be managers until you have the desired number of managers.</source>
          <target state="translated">从丢失仲裁中恢复的最佳方法是使发生故障的节点重新联机。如果不能这样做，从此状态恢复的唯一方法是使用管理器节点上的 &lt;code&gt;--force-new-cluster&lt;/code&gt; 操作。这将除去所有运行命令的管理器之外的管理器。之所以达到法定人数，是因为现在只有一名经理。提升节点作为管理员，直到拥有所需数量的管理员为止。</target>
        </trans-unit>
        <trans-unit id="35282ae4886a7519b2b65816e9e41a8dc0bfb991" translate="yes" xml:space="preserve">
          <source>The build is run by the Docker daemon, not by the CLI. The first thing a build process does is send the entire context (recursively) to the daemon. In most cases, it&amp;rsquo;s best to start with an empty directory as context and keep your Dockerfile in that directory. Add only the files needed for building the Dockerfile.</source>
          <target state="translated">构建是由Docker守护程序而不是CLI运行的。生成过程要做的第一件事是将整个上下文（递归）发送到守护程序。在大多数情况下，最好从空目录开始作为上下文，并将Dockerfile保留在该目录中。仅添加构建Dockerfile所需的文件。</target>
        </trans-unit>
        <trans-unit id="bd548e026d0cb7646c6abcf18976b5314a6291ee" translate="yes" xml:space="preserve">
          <source>The built-in &lt;code&gt;local&lt;/code&gt; driver on Linux accepts options similar to the linux &lt;code&gt;mount&lt;/code&gt; command. You can provide multiple options by passing the &lt;code&gt;--opt&lt;/code&gt; flag multiple times. Some &lt;code&gt;mount&lt;/code&gt; options (such as the &lt;code&gt;o&lt;/code&gt; option) can take a comma-separated list of options. Complete list of available mount options can be found &lt;a href=&quot;http://man7.org/linux/man-pages/man8/mount.8.html&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Linux上的内置 &lt;code&gt;local&lt;/code&gt; 驱动程序接受类似于linux &lt;code&gt;mount&lt;/code&gt; 命令的选项。您可以通过多次传递 &lt;code&gt;--opt&lt;/code&gt; 标志来提供多个选项。某些 &lt;code&gt;mount&lt;/code&gt; 选项（例如 &lt;code&gt;o&lt;/code&gt; 选项）可以采用逗号分隔的选项列表。可在&lt;a href=&quot;http://man7.org/linux/man-pages/man8/mount.8.html&quot;&gt;此处&lt;/a&gt;找到可用安装选项的完整列表。</target>
        </trans-unit>
        <trans-unit id="e589f84ba8092374a7adacbfb4c36a6c8dfce2ac" translate="yes" xml:space="preserve">
          <source>The built-in &lt;code&gt;local&lt;/code&gt; driver on Windows does not support any options.</source>
          <target state="translated">Windows上的内置 &lt;code&gt;local&lt;/code&gt; 驱动程序不支持任何选项。</target>
        </trans-unit>
        <trans-unit id="dc6031f34bc45122b3da56b152c8aaed58988503" translate="yes" xml:space="preserve">
          <source>The built-in LXC execution driver, the lxc-conf flag, and API fields have been removed.</source>
          <target state="translated">内置的LXC执行驱动、lxc-conf标志和API字段已被删除。</target>
        </trans-unit>
        <trans-unit id="aaf21ffa56c46051a2828bb0284bd2fce1a4396e" translate="yes" xml:space="preserve">
          <source>The cache for &lt;code&gt;RUN&lt;/code&gt; instructions can be invalidated by &lt;code&gt;ADD&lt;/code&gt; instructions. See &lt;a href=&quot;#add&quot;&gt;below&lt;/a&gt; for details.</source>
          <target state="translated">可以通过 &lt;code&gt;ADD&lt;/code&gt; 指令使 &lt;code&gt;RUN&lt;/code&gt; 指令的高速缓存无效。有关详情，请参见&lt;a href=&quot;#add&quot;&gt;下文&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4e21ac022d083f0dac5c9f4270fdf6df8f9b5274" translate="yes" xml:space="preserve">
          <source>The cache for &lt;code&gt;RUN&lt;/code&gt; instructions isn&amp;rsquo;t invalidated automatically during the next build. The cache for an instruction like &lt;code&gt;RUN apt-get dist-upgrade -y&lt;/code&gt; will be reused during the next build. The cache for &lt;code&gt;RUN&lt;/code&gt; instructions can be invalidated by using the &lt;code&gt;--no-cache&lt;/code&gt; flag, for example &lt;code&gt;docker build --no-cache&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;RUN&lt;/code&gt; 指令的缓存在下一个构建期间不会自动失效。诸如 &lt;code&gt;RUN apt-get dist-upgrade -y&lt;/code&gt; 之类的指令的缓存将在下一次构建中重用。可以使用 &lt;code&gt;--no-cache&lt;/code&gt; 标志使 &lt;code&gt;RUN&lt;/code&gt; 指令的缓存无效，例如 &lt;code&gt;docker build --no-cache&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="387890bfaa5ca05d821fa5a3b5d1ee0a6cfad608" translate="yes" xml:space="preserve">
          <source>The client can now immediately download the latest metadata from the server, using the still-valid bearer token to connect. Notary server only needs to obtain the metadata from the database, since none of the metadata has expired.</source>
          <target state="translated">客户端现在可以立即从服务器下载最新的元数据,使用仍然有效的承载令牌进行连接。公证服务器只需要从数据库中获取元数据,因为没有一个元数据过期。</target>
        </trans-unit>
        <trans-unit id="18d5ec6bc9d750748f1efde7c61a2989b641b66e" translate="yes" xml:space="preserve">
          <source>The client logs in to the authorization server via basic auth over HTTPS, obtain a bearer token, and then present the token to Notary server on future requests.</source>
          <target state="translated">客户端通过HTTPS的基本认证登录到授权服务器,获得一个不记名令牌,然后在以后的请求中向公证服务器出示该令牌。</target>
        </trans-unit>
        <trans-unit id="008a74ce549151e51ed0e972fe5969ff680c6df9" translate="yes" xml:space="preserve">
          <source>The cluster management and orchestration features embedded in the Docker Engine are built using &lt;a href=&quot;https://github.com/docker/swarmkit/&quot;&gt;swarmkit&lt;/a&gt;. Swarmkit is a separate project which implements Docker&amp;rsquo;s orchestration layer and is used directly within Docker.</source>
          <target state="translated">嵌入在Docker引擎中的集群管理和编排功能是使用&lt;a href=&quot;https://github.com/docker/swarmkit/&quot;&gt;swarmkit构建的&lt;/a&gt;。Swarmkit是一个单独的项目，实现了Docker的业务流程层，并直接在Docker中使用。</target>
        </trans-unit>
        <trans-unit id="d9d803a4a4aa2732e3815dd3fec6ac2441d70eb5" translate="yes" xml:space="preserve">
          <source>The command &lt;a href=&quot;../reference/down/index&quot;&gt;&lt;code&gt;docker-compose down&lt;/code&gt;&lt;/a&gt; removes the containers and default network, but preserves your WordPress database.</source>
          <target state="translated">命令&lt;a href=&quot;../reference/down/index&quot;&gt; &lt;code&gt;docker-compose down&lt;/code&gt; &lt;/a&gt;删除容器和默认网络，但保留您的WordPress数据库。</target>
        </trans-unit>
        <trans-unit id="d103dac69f74e6da15998f384bbbf98c322bd326" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;docker-compose down --volumes&lt;/code&gt; removes the containers, default network, and the WordPress database.</source>
          <target state="translated">命令 &lt;code&gt;docker-compose down --volumes&lt;/code&gt; 删除容器，默认网络和WordPress数据库。</target>
        </trans-unit>
        <trans-unit id="a1ded79620e6d1ae5604250cb4f5ac48fde1be04" translate="yes" xml:space="preserve">
          <source>The command after the &lt;code&gt;CMD&lt;/code&gt; keyword can be either a shell command (e.g. &lt;code&gt;HEALTHCHECK CMD /bin/check-running&lt;/code&gt;) or an &lt;em&gt;exec&lt;/em&gt; array (as with other Dockerfile commands; see e.g. &lt;code&gt;ENTRYPOINT&lt;/code&gt; for details).</source>
          <target state="translated">&lt;code&gt;CMD&lt;/code&gt; 关键字后面的命令可以是shell命令（例如 &lt;code&gt;HEALTHCHECK CMD /bin/check-running&lt;/code&gt; ）或&lt;em&gt;exec&lt;/em&gt;数组（与其他Dockerfile命令一样；有关详细信息，请参见例如 &lt;code&gt;ENTRYPOINT&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="a4ad35310c7aa7c67030bd46a3f2c137ecbcce0e" translate="yes" xml:space="preserve">
          <source>The command can also be a list, in a manner similar to &lt;a href=&quot;../../../engine/reference/builder/index#cmd&quot;&gt;dockerfile&lt;/a&gt;:</source>
          <target state="translated">该命令也可以是列表，类似于&lt;a href=&quot;../../../engine/reference/builder/index#cmd&quot;&gt;dockerfile&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="eb23a07d84e630a5e8757111b76c8800f31539ec" translate="yes" xml:space="preserve">
          <source>The command can also be a list, in a manner similar to &lt;a href=&quot;../../engine/reference/builder/index#cmd&quot;&gt;dockerfile&lt;/a&gt;:</source>
          <target state="translated">该命令也可以是列表，类似于&lt;a href=&quot;../../engine/reference/builder/index#cmd&quot;&gt;dockerfile&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="0956efd491b81018147a694d5d0b1c6091fab3ac" translate="yes" xml:space="preserve">
          <source>The command invoked by docker will be:</source>
          <target state="translated">docker调用的命令将是。</target>
        </trans-unit>
        <trans-unit id="dae172cbb22e837995c3df1ccd985a845c6b4d13" translate="yes" xml:space="preserve">
          <source>The command requires &lt;code&gt;SRC_PATH&lt;/code&gt; and &lt;code&gt;DEST_PATH&lt;/code&gt; to exist according to the above rules. If &lt;code&gt;SRC_PATH&lt;/code&gt; is local and is a symbolic link, the symbolic link, not the target, is copied by default. To copy the link target and not the link, specify the &lt;code&gt;-L&lt;/code&gt; option.</source>
          <target state="translated">该命令要求 &lt;code&gt;SRC_PATH&lt;/code&gt; 和 &lt;code&gt;DEST_PATH&lt;/code&gt; 根据上述规则存在。如果 &lt;code&gt;SRC_PATH&lt;/code&gt; 是本地的并且是符号链接，则默认情况下将复制符号链接而不是目标链接。要复制链接目标而不是链接，请指定 &lt;code&gt;-L&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="0d58d57885d29e1a2606150c96168372661b385e" translate="yes" xml:space="preserve">
          <source>The command started using &lt;code&gt;docker exec&lt;/code&gt; only runs while the container&amp;rsquo;s primary process (&lt;code&gt;PID 1&lt;/code&gt;) is running, and it is not restarted if the container is restarted.</source>
          <target state="translated">使用 &lt;code&gt;docker exec&lt;/code&gt; 启动的命令仅在容器的主进程（ &lt;code&gt;PID 1&lt;/code&gt; ）正在运行时运行，如果重新启动容器，则该命令不会重新启动。</target>
        </trans-unit>
        <trans-unit id="f0a72ceb0f35e23bf2d1761717be1222bd1f2b70" translate="yes" xml:space="preserve">
          <source>The command&amp;rsquo;s exit status indicates the health status of the container. The possible values are:</source>
          <target state="translated">命令的退出状态指示容器的健康状态。可能的值为：</target>
        </trans-unit>
        <trans-unit id="d9a93e6beea86e2782016f21845beb9cd6afbccd" translate="yes" xml:space="preserve">
          <source>The commands to configure your shell differ depending on whether you are Mac, Linux, or Windows, so examples of each are shown on the tabs below.</source>
          <target state="translated">配置shell的命令根据你是Mac、Linux还是Windows而不同,所以每个命令的例子都在下面的标签上显示。</target>
        </trans-unit>
        <trans-unit id="1fcf81cd2c19a4aa739ef6f89bede8ea8de9d5ea" translate="yes" xml:space="preserve">
          <source>The commit operation will not include any data contained in volumes mounted inside the container.</source>
          <target state="translated">提交操作将不包括安装在容器内的卷中的任何数据。</target>
        </trans-unit>
        <trans-unit id="83a0a167e28d8f87b6757f8a0015a4c55e5a2769" translate="yes" xml:space="preserve">
          <source>The complete list of deprecated features can be found on the &lt;a href=&quot;deprecated/index&quot;&gt;Deprecated Features page&lt;/a&gt;.</source>
          <target state="translated">可在&amp;ldquo;不赞成&lt;a href=&quot;deprecated/index&quot;&gt;使用的功能&amp;rdquo;页面&lt;/a&gt;上找到不赞成使用的功能的完整列表。</target>
        </trans-unit>
        <trans-unit id="468d9a29501077e3aa8dde888309cbb4c0b42e6a" translate="yes" xml:space="preserve">
          <source>The config.json file</source>
          <target state="translated">配置.json文件</target>
        </trans-unit>
        <trans-unit id="63580fe0751f0a80b7f41e5612dc01cfec484ac4" translate="yes" xml:space="preserve">
          <source>The configuration file for Notary client normally resides at &lt;code&gt;~/.notary/config.json&lt;/code&gt;, but the path to a different configuration file can be specified using the &lt;code&gt;-c&lt;/code&gt; or &lt;code&gt;--configFile&lt;/code&gt; command line flag.</source>
          <target state="translated">&lt;code&gt;~/.notary/config.json&lt;/code&gt; 客户端的配置文件通常位于〜/ .notary / config.json，但是可以使用 &lt;code&gt;-c&lt;/code&gt; 或 &lt;code&gt;--configFile&lt;/code&gt; 命令行标志来指定其他配置文件的路径。</target>
        </trans-unit>
        <trans-unit id="42aecee7e3d42c214cbe47500065d6827ebee111" translate="yes" xml:space="preserve">
          <source>The configuration in the &lt;code&gt;docker-compose.override.yml&lt;/code&gt; file is applied over and in addition to the values in the &lt;code&gt;docker-compose.yml&lt;/code&gt; file.</source>
          <target state="translated">除了 &lt;code&gt;docker-compose.override.yml&lt;/code&gt; 文件中的值外， &lt;code&gt;docker-compose.yml&lt;/code&gt; 文件中的配置。</target>
        </trans-unit>
        <trans-unit id="06a3d484626f8819afe1dc776cba1d83d88a0606" translate="yes" xml:space="preserve">
          <source>The consistency requirements for the mount; one of</source>
          <target state="translated">装的一致性要求;其一</target>
        </trans-unit>
        <trans-unit id="4f609b0747ecf4db5b68bbca89691e8478935849" translate="yes" xml:space="preserve">
          <source>The container can have a different logging driver than the Docker daemon. Use the &lt;code&gt;--log-driver=VALUE&lt;/code&gt; with the &lt;code&gt;docker run&lt;/code&gt; command to configure the container&amp;rsquo;s logging driver. The following options are supported:</source>
          <target state="translated">容器可以具有与Docker守护程序不同的日志记录驱动程序。在 &lt;code&gt;docker run&lt;/code&gt; 命令中使用 &lt;code&gt;--log-driver=VALUE&lt;/code&gt; 来配置容器的日志记录驱动程序。支持以下选项：</target>
        </trans-unit>
        <trans-unit id="1e120a80067063699b6c9309ae85bbe648e64ec8" translate="yes" xml:space="preserve">
          <source>The container can use as much memory as it needs. The memory reservation setting ensures the container doesn&amp;rsquo;t consume too much memory for long time, because every memory reclaim shrinks the container&amp;rsquo;s consumption to the reservation.</source>
          <target state="translated">容器可以使用所需的内存。内存预留设置可确保容器长时间不占用过多内存，因为每次回收内存都会将容器的消耗减少到预留空间。</target>
        </trans-unit>
        <trans-unit id="6c41c4e059c0f6d5b08e701882d43028ba6a1c76" translate="yes" xml:space="preserve">
          <source>The container creation endpoint (&lt;code&gt;/containers/create&lt;/code&gt;) accepts a &lt;code&gt;VolumeDriver&lt;/code&gt; field of type &lt;code&gt;string&lt;/code&gt; allowing to specify the name of the driver. If not specified, it defaults to &lt;code&gt;&quot;local&quot;&lt;/code&gt; (the default driver for local volumes).</source>
          <target state="translated">容器创建端点（ &lt;code&gt;/containers/create&lt;/code&gt; ）接受类型为 &lt;code&gt;string&lt;/code&gt; 的 &lt;code&gt;VolumeDriver&lt;/code&gt; 字段，以允许指定驱动程序的名称。如果未指定，则默认为 &lt;code&gt;&quot;local&quot;&lt;/code&gt; （本地卷的默认驱动程序）。</target>
        </trans-unit>
        <trans-unit id="c5fc2a7434f444d2bf6be0610e195a7bb56b36c4" translate="yes" xml:space="preserve">
          <source>The container has unlimited memory which can cause the host to run out memory and require killing system processes to free memory. The &lt;code&gt;--oom-score-adj&lt;/code&gt; parameter can be changed to select the priority of which containers will be killed when the system is out of memory, with negative scores making them less likely to be killed, and positive scores more likely.</source>
          <target state="translated">容器具有无限的内存，这可能导致主机内存用完，并需要终止系统进程来释放内存。该 &lt;code&gt;--oom-score-adj&lt;/code&gt; 参数是可以改变的选择优先权，容器就会被杀死，当系统内存不足，负得分使他们不太可能被杀害，并积极分数的可能性较大。</target>
        </trans-unit>
        <trans-unit id="333084b3793f80a3fdbaa6d2ac4ef96b2a7ad2c4" translate="yes" xml:space="preserve">
          <source>The contents of the source tree, with conflicts resolved in favor of &amp;ldquo;2.&amp;rdquo; on a file-by-file basis.</source>
          <target state="translated">源代码树的内容，已解决冲突，而选择了&amp;ldquo; 2&amp;rdquo;。在逐个文件的基础上。</target>
        </trans-unit>
        <trans-unit id="cbe1954333dba969dd75128ef1a9d14d906afd02" translate="yes" xml:space="preserve">
          <source>The contents of those fields are ignored by Compose, but they can be inserted in your resource definitions using &lt;a href=&quot;http://www.yaml.org/spec/1.2/spec.html#id2765878&quot;&gt;YAML anchors&lt;/a&gt;. For example, if you want several of your services to use the same logging configuration:</source>
          <target state="translated">这些字段的内容被Compose忽略，但是可以使用&lt;a href=&quot;http://www.yaml.org/spec/1.2/spec.html#id2765878&quot;&gt;YAML锚点&lt;/a&gt;将其插入资源定义中。例如，如果您希望多个服务使用相同的日志记录配置：</target>
        </trans-unit>
        <trans-unit id="55bb6aa9bd31acce0a500a34fa7ad10a92eb38dc" translate="yes" xml:space="preserve">
          <source>The corresponding network configuration in the &lt;a href=&quot;#network-configuration-reference&quot;&gt;top-level networks section&lt;/a&gt; must have an &lt;code&gt;ipam&lt;/code&gt; block with subnet and gateway configurations covering each static address. If IPv6 addressing is desired, the &lt;a href=&quot;#enableipv6&quot;&gt;&lt;code&gt;enable_ipv6&lt;/code&gt;&lt;/a&gt; option must be set.</source>
          <target state="translated">&lt;a href=&quot;#network-configuration-reference&quot;&gt;顶级网络部分中&lt;/a&gt;的相应网络配置必须有一个 &lt;code&gt;ipam&lt;/code&gt; 块，其子网和网关配置覆盖每个静态地址。如果需要IPv6寻址，则必须设置&lt;a href=&quot;#enableipv6&quot;&gt; &lt;code&gt;enable_ipv6&lt;/code&gt; &lt;/a&gt;选项。</target>
        </trans-unit>
        <trans-unit id="586d71b6ade2d35dd85189494da13a3579476751" translate="yes" xml:space="preserve">
          <source>The corresponding network configuration in the &lt;a href=&quot;#network-configuration-reference&quot;&gt;top-level networks section&lt;/a&gt; must have an &lt;code&gt;ipam&lt;/code&gt; block with subnet configurations covering each static address.</source>
          <target state="translated">&lt;a href=&quot;#network-configuration-reference&quot;&gt;顶级网络部分中&lt;/a&gt;的相应网络配置必须具有一个 &lt;code&gt;ipam&lt;/code&gt; 块，其子网配置覆盖每个静态地址。</target>
        </trans-unit>
        <trans-unit id="fad571b286cbf1b134860d78c384eaf61397a5ea" translate="yes" xml:space="preserve">
          <source>The current expected use case is to advertise NVIDIA GPUs so that services requesting &lt;code&gt;NVIDIA-GPU=[0-16]&lt;/code&gt; can land on a node that has enough GPUs for the task to run.</source>
          <target state="translated">当前的预期用例是通告NVIDIA GPU，以便请求 &lt;code&gt;NVIDIA-GPU=[0-16]&lt;/code&gt; 的服务可以降落在具有足以运行任务的GPU的节点上。</target>
        </trans-unit>
        <trans-unit id="bcb1c15d1b89c3f94e8dabe5ed1066e78563ff31" translate="yes" xml:space="preserve">
          <source>The current release stage, such as &lt;code&gt;&quot;production&quot;&lt;/code&gt;. You can use this value to filter errors in the Bugsnag dashboard.</source>
          <target state="translated">当前的发布阶段，例如 &lt;code&gt;&quot;production&quot;&lt;/code&gt; 。您可以使用此值来过滤Bugsnag仪表板中的错误。</target>
        </trans-unit>
        <trans-unit id="3c1993b21d61bb6110c17c440c31c9f2b3c920bb" translate="yes" xml:space="preserve">
          <source>The currently supported cluster store options are:</source>
          <target state="translated">目前支持的集群存储选项有:</target>
        </trans-unit>
        <trans-unit id="8bc214496669aa244b1cc5d85b13d7d6cb05c343" translate="yes" xml:space="preserve">
          <source>The currently supported filters are:</source>
          <target state="translated">目前支持的过滤器有:</target>
        </trans-unit>
        <trans-unit id="d4b2d4d7c5b15f6ba647817c9d9d938449c46c97" translate="yes" xml:space="preserve">
          <source>The daemon is also potentially vulnerable to other inputs, such as image loading from either disk with &lt;code&gt;docker load&lt;/code&gt;, or from the network with &lt;code&gt;docker pull&lt;/code&gt;. As of Docker 1.3.2, images are now extracted in a chrooted subprocess on Linux/Unix platforms, being the first-step in a wider effort toward privilege separation. As of Docker 1.10.0, all images are stored and accessed by the cryptographic checksums of their contents, limiting the possibility of an attacker causing a collision with an existing image.</source>
          <target state="translated">该守护程序还可能容易受到其他输入的攻击，例如从带有 &lt;code&gt;docker load&lt;/code&gt; 的磁盘或带有 &lt;code&gt;docker pull&lt;/code&gt; 的网络加载图像。从Docker 1.3.2开始，现在在Linux / Unix平台上的chroot子进程中提取图像，这是朝着特权分离的更广泛努力的第一步。从Docker 1.10.0开始，所有图像都通过其内容的加密校验和进行存储和访问，从而限制了攻击者与现有图像发生冲突的可能性。</target>
        </trans-unit>
        <trans-unit id="1b40a58c33ae6973207a461d4362662281b137fb" translate="yes" xml:space="preserve">
          <source>The daemon is moved to a separate binary (&lt;code&gt;dockerd&lt;/code&gt;), and should be used instead.</source>
          <target state="translated">守护程序将移至单独的二进制文件（ &lt;code&gt;dockerd&lt;/code&gt; ），应改为使用。</target>
        </trans-unit>
        <trans-unit id="3b7c8c7558a775a2edcd115a970ad32948322ddb" translate="yes" xml:space="preserve">
          <source>The daemon uses &lt;a href=&quot;https://github.com/docker/libkv/&quot;&gt;libkv&lt;/a&gt; to advertise the node within the cluster. Some key-value backends support mutual TLS. To configure the client TLS settings used by the daemon can be configured using the &lt;code&gt;--cluster-store-opt&lt;/code&gt; flag, specifying the paths to PEM encoded files. For example:</source>
          <target state="translated">守护程序使用&lt;a href=&quot;https://github.com/docker/libkv/&quot;&gt;libkv&lt;/a&gt;播发集群中的节点。一些键值后端支持双向TLS。要配置客户端使用的TLS设置，可以使用 &lt;code&gt;--cluster-store-opt&lt;/code&gt; 标志进行配置，并指定PEM编码文件的路径。例如：</target>
        </trans-unit>
        <trans-unit id="10c61591c638186cd78e6bcb2f76d135a645641c" translate="yes" xml:space="preserve">
          <source>The data file is where the images are stored and the metadata file is where the meta data regarding those images are stored. When run for the first time Docker allocates a certain amount of data space and meta data space from the space available on the volume where &lt;code&gt;/var/lib/docker&lt;/code&gt; is mounted.</source>
          <target state="translated">数据文件是存储图像的位置，元数据文件是与这些图像有关的元数据的存储位置。首次运行时，Docker从安装了 &lt;code&gt;/var/lib/docker&lt;/code&gt; 的卷上的可用空间中分配一定数量的数据空间和元数据空间。</target>
        </trans-unit>
        <trans-unit id="6e1b782dc4239cc2ee12f8ada2116b7cec6452c5" translate="yes" xml:space="preserve">
          <source>The db service uses both secrets, and the wordpress is using one.</source>
          <target state="translated">db服务使用两个秘密,而wordpress使用的是一个秘密。</target>
        </trans-unit>
        <trans-unit id="88b708d10b5bb132b812231de52a9a57fd050d57" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;docker images&lt;/code&gt; will show all top level images, their repository and tags, and their size.</source>
          <target state="translated">默认的 &lt;code&gt;docker images&lt;/code&gt; 将显示所有顶级映像，其存储库和标签及其大小。</target>
        </trans-unit>
        <trans-unit id="e751a256a79a508fc6a8dac6bc7ba71dd7cb189a" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;seccomp&lt;/code&gt; profile provides a sane default for running containers with seccomp and disables around 44 system calls out of 300+. It is moderately protective while providing wide application compatibility. The default Docker profile can be found &lt;a href=&quot;https://github.com/moby/moby/blob/master/profiles/seccomp/default.json&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">默认的 &lt;code&gt;seccomp&lt;/code&gt; 配置文件为运行带有seccomp的容器提供了默认的默认设置，并在300多个中禁用了大约44个系统调用。它具有适度的保护性，同时提供广泛的应用程序兼容性。可以在&lt;a href=&quot;https://github.com/moby/moby/blob/master/profiles/seccomp/default.json&quot;&gt;此处&lt;/a&gt;找到默认的Docker配置文件。</target>
        </trans-unit>
        <trans-unit id="02e46ce6640ecc061d7753130fd0e3ce54b962ca" translate="yes" xml:space="preserve">
          <source>The default CPU CFS (Completely Fair Scheduler) period is 100ms. We can use &lt;code&gt;--cpu-period&lt;/code&gt; to set the period of CPUs to limit the container&amp;rsquo;s CPU usage. And usually &lt;code&gt;--cpu-period&lt;/code&gt; should work with &lt;code&gt;--cpu-quota&lt;/code&gt;.</source>
          <target state="translated">默认的CPU CFS（完全公平调度程序）周期为100ms。我们可以使用 &lt;code&gt;--cpu-period&lt;/code&gt; 设置CPU的时间，以限制容器的CPU使用率。通常 &lt;code&gt;--cpu-period&lt;/code&gt; 应该与 &lt;code&gt;--cpu-quota&lt;/code&gt; 一起使用。</target>
        </trans-unit>
        <trans-unit id="835a0981f4ea865680edc5b2da7de4c21a68744c" translate="yes" xml:space="preserve">
          <source>The default SSH username for the default AMIs is &lt;code&gt;ubuntu&lt;/code&gt;.</source>
          <target state="translated">默认AMI的默认SSH用户名是 &lt;code&gt;ubuntu&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="59cdf16cd5e29f0ac54596e99e587be9a13ea86c" translate="yes" xml:space="preserve">
          <source>The default driver &lt;a href=&quot;https://docs.docker.com/config/containers/logging#json-file&quot;&gt;json-file&lt;/a&gt;, has options to limit the amount of logs stored. To do this, use a key-value pair for maximum storage size and maximum number of files:</source>
          <target state="translated">默认驱动程序&lt;a href=&quot;https://docs.docker.com/config/containers/logging#json-file&quot;&gt;json-file&lt;/a&gt;，具有用于限制所存储日志数量的选项。为此，请使用键值对以获取最大存储大小和最大文件数：</target>
        </trans-unit>
        <trans-unit id="ce72086dcefd05b0b3815fadb5d6794a3874059b" translate="yes" xml:space="preserve">
          <source>The default driver depends on how the Docker Engine you&amp;rsquo;re using is configured, but in most instances it is &lt;code&gt;bridge&lt;/code&gt; on a single host and &lt;code&gt;overlay&lt;/code&gt; on a Swarm.</source>
          <target state="translated">默认驱动程序取决于您所使用的Docker引擎的配置方式，但在大多数情况下，它是 &lt;code&gt;bridge&lt;/code&gt; 在单个主机上并 &lt;code&gt;overlay&lt;/code&gt; 在Swarm上。</target>
        </trans-unit>
        <trans-unit id="c7f4b3f884940abe279914db7dec9662f4803c53" translate="yes" xml:space="preserve">
          <source>The default for this option will also be changed accordingly for &lt;code&gt;docker service rollback&lt;/code&gt; and &lt;code&gt;docker service scale&lt;/code&gt; in Docker 17.10.</source>
          <target state="translated">对于Docker 17.10中的docker &lt;code&gt;docker service rollback&lt;/code&gt; 和 &lt;code&gt;docker service scale&lt;/code&gt; ，此选项的默认值也将相应更改。</target>
        </trans-unit>
        <trans-unit id="5a6dfa1d042a5a81b6bf6160ce5c49ad7812c75e" translate="yes" xml:space="preserve">
          <source>The default format is as follows:</source>
          <target state="translated">默认格式如下:</target>
        </trans-unit>
        <trans-unit id="5c1cb315610bf195b7d26211262a21ff2fe2bdfe" translate="yes" xml:space="preserve">
          <source>The default init binary that is used is &lt;a href=&quot;https://github.com/krallin/tini&quot;&gt;Tini&lt;/a&gt;, and is installed in &lt;code&gt;/usr/libexec/docker-init&lt;/code&gt; on the daemon host. You can configure the daemon to use a custom init binary through the &lt;a href=&quot;../../../engine/reference/commandline/dockerd/index#daemon-configuration-file&quot;&gt;&lt;code&gt;init-path&lt;/code&gt; configuration option&lt;/a&gt;.</source>
          <target state="translated">使用的默认初始化二进制文件是&lt;a href=&quot;https://github.com/krallin/tini&quot;&gt;Tini&lt;/a&gt;，并安装在守护程序主机上的 &lt;code&gt;/usr/libexec/docker-init&lt;/code&gt; 中。您可以通过&lt;a href=&quot;../../../engine/reference/commandline/dockerd/index#daemon-configuration-file&quot;&gt; &lt;code&gt;init-path&lt;/code&gt; 配置选项&lt;/a&gt;将守护程序配置为使用自定义init二进制文件。</target>
        </trans-unit>
        <trans-unit id="f3a2403daddc36ae40af72ba1509df0c525c4f7a" translate="yes" xml:space="preserve">
          <source>The default init binary that is used is &lt;a href=&quot;https://github.com/krallin/tini&quot;&gt;Tini&lt;/a&gt;, and is installed in &lt;code&gt;/usr/libexec/docker-init&lt;/code&gt; on the daemon host. You can configure the daemon to use a custom init binary through the &lt;a href=&quot;../../engine/reference/commandline/dockerd/index#daemon-configuration-file&quot;&gt;&lt;code&gt;init-path&lt;/code&gt; configuration option&lt;/a&gt;.</source>
          <target state="translated">使用的默认初始化二进制文件是&lt;a href=&quot;https://github.com/krallin/tini&quot;&gt;Tini&lt;/a&gt;，并安装在守护程序主机上的 &lt;code&gt;/usr/libexec/docker-init&lt;/code&gt; 中。您可以通过&lt;a href=&quot;../../engine/reference/commandline/dockerd/index#daemon-configuration-file&quot;&gt; &lt;code&gt;init-path&lt;/code&gt; 配置选项&lt;/a&gt;将守护程序配置为使用自定义init二进制文件。</target>
        </trans-unit>
        <trans-unit id="6b46500a2cf3200d1811ab7e8c81dc7096ac8b4f" translate="yes" xml:space="preserve">
          <source>The default init process used is the first &lt;code&gt;docker-init&lt;/code&gt; executable found in the system path of the Docker daemon process. This &lt;code&gt;docker-init&lt;/code&gt; binary, included in the default installation, is backed by &lt;a href=&quot;https://github.com/krallin/tini&quot;&gt;tini&lt;/a&gt;.</source>
          <target state="translated">使用的默认初始化进程是在Docker守护进程的系统路径中找到的第一个 &lt;code&gt;docker-init&lt;/code&gt; 可执行文件。默认安装中包含的此 &lt;code&gt;docker-init&lt;/code&gt; 二进制文件由&lt;a href=&quot;https://github.com/krallin/tini&quot;&gt;tini&lt;/a&gt;支持。</target>
        </trans-unit>
        <trans-unit id="2d29444d706667623d7f48549919ccd31c44e5c9" translate="yes" xml:space="preserve">
          <source>The default isolation on Windows server operating systems is &lt;code&gt;process&lt;/code&gt;. The default isolation on Windows client operating systems is &lt;code&gt;hyperv&lt;/code&gt;. An attempt to start a container on a client operating system older than Windows 10 1809 with &lt;code&gt;--isolation process&lt;/code&gt; will fail.</source>
          <target state="translated">Windows服务器操作系统上的默认隔离是 &lt;code&gt;process&lt;/code&gt; 。Windows客户端操作系统上的默认隔离是 &lt;code&gt;hyperv&lt;/code&gt; 。尝试使用 &lt;code&gt;--isolation process&lt;/code&gt; 早于Windows 10 1809的客户端操作系统上启动容器的尝试将失败。</target>
        </trans-unit>
        <trans-unit id="1003ad4f0dfb7841d434646ca9e28a70873641dc" translate="yes" xml:space="preserve">
          <source>The default location of the configuration file on Linux is &lt;code&gt;/etc/docker/daemon.json&lt;/code&gt;. The &lt;code&gt;--config-file&lt;/code&gt; flag can be used to specify a non-default location.</source>
          <target state="translated">Linux上配置文件的默认位置是 &lt;code&gt;/etc/docker/daemon.json&lt;/code&gt; 。该 &lt;code&gt;--config-file&lt;/code&gt; 标志可用于指定一个非默认位置。</target>
        </trans-unit>
        <trans-unit id="946fe86eb52848a137c16603863073ed3192847f" translate="yes" xml:space="preserve">
          <source>The default location of the configuration file on Windows is &lt;code&gt;%programdata%\docker\config\daemon.json&lt;/code&gt;. The &lt;code&gt;--config-file&lt;/code&gt; flag can be used to specify a non-default location.</source>
          <target state="translated">Windows上配置文件的默认位置为 &lt;code&gt;%programdata%\docker\config\daemon.json&lt;/code&gt; 。该 &lt;code&gt;--config-file&lt;/code&gt; 标志可用于指定一个非默认位置。</target>
        </trans-unit>
        <trans-unit id="1d77799e03e62749f4abf25bccc750b066c07d78" translate="yes" xml:space="preserve">
          <source>The default network, if one is used</source>
          <target state="translated">如果使用了默认网络,则为默认网络</target>
        </trans-unit>
        <trans-unit id="098406d500f9e645da44a793a6233d0cd7c06c69" translate="yes" xml:space="preserve">
          <source>The default path for a Compose file is &lt;code&gt;./docker-compose.yml&lt;/code&gt;.</source>
          <target state="translated">Compose文件的默认路径是 &lt;code&gt;./docker-compose.yml&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fb8857f4a0cda00b382ca084d9bef1fbf8561297" translate="yes" xml:space="preserve">
          <source>The default project name is the basename of the project directory. You can set a custom project name by using the &lt;a href=&quot;reference/overview/index&quot;&gt;&lt;code&gt;-p&lt;/code&gt; command line option&lt;/a&gt; or the &lt;a href=&quot;reference/envvars/index#compose-project-name&quot;&gt;&lt;code&gt;COMPOSE_PROJECT_NAME&lt;/code&gt; environment variable&lt;/a&gt;.</source>
          <target state="translated">默认项目名称是项目目录的基本名称。您可以使用&lt;a href=&quot;reference/overview/index&quot;&gt; &lt;code&gt;-p&lt;/code&gt; 命令行选项&lt;/a&gt;或&lt;a href=&quot;reference/envvars/index#compose-project-name&quot;&gt; &lt;code&gt;COMPOSE_PROJECT_NAME&lt;/code&gt; 环境变量&lt;/a&gt;来设置自定义项目名称。</target>
        </trans-unit>
        <trans-unit id="e933c3002f8889546c0ab43e358c6c7eb91f636a" translate="yes" xml:space="preserve">
          <source>The default seccomp profile will adjust to the selected capabilities, in order to allow use of facilities allowed by the capabilities, so you should not have to adjust this, since Docker 1.12. In Docker 1.10 and 1.11 this did not happen and it may be necessary to use a custom seccomp profile or use &lt;code&gt;--security-opt seccomp=unconfined&lt;/code&gt; when adding capabilities.</source>
          <target state="translated">默认的seccomp配置文件将根据所选功能进行调整，以允许使用该功能允许的功能，因此，自Docker 1.12起，您不必对此进行调整。在Docker 1.10和1.11中没有发生这种情况，添加功能时可能有必要使用自定义seccomp配置文件或使用 &lt;code&gt;--security-opt seccomp=unconfined&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1c1e388da7ec0a0a04b987272aedc0229521e525" translate="yes" xml:space="preserve">
          <source>The default shell for the &lt;em&gt;shell&lt;/em&gt; form can be changed using the &lt;code&gt;SHELL&lt;/code&gt; command.</source>
          <target state="translated">可以使用 &lt;code&gt;SHELL&lt;/code&gt; 命令更改&lt;em&gt;shell&lt;/em&gt;形式的默认shell 。</target>
        </trans-unit>
        <trans-unit id="79f1b805588ca93f12c5151f467a7d3172574cbb" translate="yes" xml:space="preserve">
          <source>The default value for &lt;code&gt;--cpus&lt;/code&gt; is &lt;code&gt;0.000&lt;/code&gt;, which means there is no limit.</source>
          <target state="translated">为默认值 &lt;code&gt;--cpus&lt;/code&gt; 是 &lt;code&gt;0.000&lt;/code&gt; ，这意味着没有限制。</target>
        </trans-unit>
        <trans-unit id="e4a3f2aa0f06fe9f002e0533949e71bd65c91612" translate="yes" xml:space="preserve">
          <source>The default value is json-file.</source>
          <target state="translated">默认值是json-file。</target>
        </trans-unit>
        <trans-unit id="43c639c5f9940e65b93aed2edfa229895d878456" translate="yes" xml:space="preserve">
          <source>The default working directory for running binaries within a container is the root directory (&lt;code&gt;/&lt;/code&gt;), but the developer can set a different default with the Dockerfile &lt;code&gt;WORKDIR&lt;/code&gt; command. The operator can override this with:</source>
          <target state="translated">在容器中运行二进制文件的默认工作目录是根目录（ &lt;code&gt;/&lt;/code&gt; ），但是开发人员可以使用Dockerfile &lt;code&gt;WORKDIR&lt;/code&gt; 命令设置其他默认目录。操作员可以使用以下方法覆盖它：</target>
        </trans-unit>
        <trans-unit id="9f08a74fcb0c137793370ee0cf17b818a97b0e38" translate="yes" xml:space="preserve">
          <source>The delegation (an online) key passphrase</source>
          <target state="translated">授权(在线)密钥口令</target>
        </trans-unit>
        <trans-unit id="4b17714a5567df9952e53a2f8facd472db67ca19" translate="yes" xml:space="preserve">
          <source>The developer can set a default user to run the first process with the Dockerfile &lt;code&gt;USER&lt;/code&gt; instruction. When starting a container, the operator can override the &lt;code&gt;USER&lt;/code&gt; instruction by passing the &lt;code&gt;-u&lt;/code&gt; option.</source>
          <target state="translated">开发人员可以使用Dockerfile &lt;code&gt;USER&lt;/code&gt; 指令设置默认用户以运行第一个进程。启动容器时，操作员可以通过传递 &lt;code&gt;-u&lt;/code&gt; 选项来覆盖 &lt;code&gt;USER&lt;/code&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="05147ac693f70511d9e9341898fa849f2c06b771" translate="yes" xml:space="preserve">
          <source>The diagram below illustrates how manager nodes and worker nodes encrypt communications using a minimum of TLS 1.2.</source>
          <target state="translated">下图说明了管理者节点和工作者节点如何使用最低限度的TLS 1.2对通信进行加密。</target>
        </trans-unit>
        <trans-unit id="cb288d1103743acfb8d43d7f42964ab0c718c9e1" translate="yes" xml:space="preserve">
          <source>The diagram below shows a three-service replica in yellow and a global service in gray.</source>
          <target state="translated">下图中黄色为三服副本,灰色为全局服。</target>
        </trans-unit>
        <trans-unit id="d322b7f5d4fe953d4548dff5c94e40c25755e35d" translate="yes" xml:space="preserve">
          <source>The diagram below shows how swarm mode accepts service create requests and schedules tasks to worker nodes.</source>
          <target state="translated">下图显示了蜂群模式如何接受服务创建请求并将任务调度到工作者节点。</target>
        </trans-unit>
        <trans-unit id="a542ef3183b38578e602775ecc5d8ac346cdbbc6" translate="yes" xml:space="preserve">
          <source>The directories which are owned by the remapped user are used instead of the same directories directly beneath &lt;code&gt;/var/lib/docker/&lt;/code&gt; and the unused versions (such as &lt;code&gt;/var/lib/docker/tmp/&lt;/code&gt; in the example here) can be removed. Docker does not use them while &lt;code&gt;userns-remap&lt;/code&gt; is enabled.</source>
          <target state="translated">将使用重新映射的用户拥有的目录，而不是直接在 &lt;code&gt;/var/lib/docker/&lt;/code&gt; 下的相同目录，并且可以删除未使用的版本（例如此处示例中的 &lt;code&gt;/var/lib/docker/tmp/&lt;/code&gt; ）。启用 &lt;code&gt;userns-remap&lt;/code&gt; 时，Docker不使用它们。</target>
        </trans-unit>
        <trans-unit id="ced9b493d368f4aa1a0fe354475a92f041e9fd7a" translate="yes" xml:space="preserve">
          <source>The docker login command is removing the ability to automatically register for an account with the target registry if the given username doesn&amp;rsquo;t exist. Due to this change, the email flag is no longer required, and will be deprecated.</source>
          <target state="translated">如果给定的用户名不存在，则docker login命令将删除在目标注册表中自动注册帐户的功能。由于此更改，不再需要email标志，并且将不推荐使用。</target>
        </trans-unit>
        <trans-unit id="c3f61e1a16f6c08b9e1d558d719854f08c48dd22" translate="yes" xml:space="preserve">
          <source>The docker volume &lt;code&gt;db_data&lt;/code&gt; persists any updates made by WordPress to the database. &lt;a href=&quot;https://docs.docker.com/storage&quot;&gt;Learn more about docker volumes&lt;/a&gt;</source>
          <target state="translated">泊坞窗卷 &lt;code&gt;db_data&lt;/code&gt; 保留WordPress对数据库所做的任何更新。&lt;a href=&quot;https://docs.docker.com/storage&quot;&gt;了解有关Docker卷的更多信息&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1416be20c4d01103caaee715619ae02361dcc4e5" translate="yes" xml:space="preserve">
          <source>The docker-machine create command</source>
          <target state="translated">docker-machine创建命令</target>
        </trans-unit>
        <trans-unit id="2c33c4de05fef67739d59f64c71b01bf34737dbd" translate="yes" xml:space="preserve">
          <source>The download operation will be performed on the host the Docker daemon is running on, which is not necessarily the same host from which the build command is being issued. The Docker daemon will fetch &lt;code&gt;context.tar.gz&lt;/code&gt; and use it as the build context. Tarball contexts must be tar archives conforming to the standard &lt;code&gt;tar&lt;/code&gt; UNIX format and can be compressed with any one of the &amp;lsquo;xz&amp;rsquo;, &amp;lsquo;bzip2&amp;rsquo;, &amp;lsquo;gzip&amp;rsquo; or &amp;lsquo;identity&amp;rsquo; (no compression) formats.</source>
          <target state="translated">下载操作将在运行Docker守护程序的主机上执行，该主机不一定与发出build命令的主机相同。Docker守护程序将获取 &lt;code&gt;context.tar.gz&lt;/code&gt; 并将其用作构建上下文。Tarball上下文必须是符合标准 &lt;code&gt;tar&lt;/code&gt; UNIX格式的tar归档文件，并且可以使用&amp;ldquo; xz&amp;rdquo;，&amp;ldquo; bzip2&amp;rdquo;，&amp;ldquo; gzip&amp;rdquo;或&amp;ldquo; identity&amp;rdquo;（无压缩）格式中的任何一种进行压缩。</target>
        </trans-unit>
        <trans-unit id="7edb9183a839b9915a5a25418cfe38fbb6391bb2" translate="yes" xml:space="preserve">
          <source>The drained node shows &lt;code&gt;Drain&lt;/code&gt; for &lt;code&gt;AVAILABILITY&lt;/code&gt;.</source>
          <target state="translated">耗尽节点显示 &lt;code&gt;Drain&lt;/code&gt; for &lt;code&gt;AVAILABILITY&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="008ecc6d5a62a3ca5a113cadbf298669fecf4eaf" translate="yes" xml:space="preserve">
          <source>The driver is not required to implement &lt;code&gt;Capabilities&lt;/code&gt;. If it is not implemented, the default values are used.</source>
          <target state="translated">不需要驱动程序实现 &lt;code&gt;Capabilities&lt;/code&gt; 。如果未实现，则使用默认值。</target>
        </trans-unit>
        <trans-unit id="45d754e6b3d42d6576d69090d424263def84711c" translate="yes" xml:space="preserve">
          <source>The easiest way to deploy Notary Server is by using Docker Compose. To follow the procedure on this page, you must have already &lt;a href=&quot;../../../../compose/install/index&quot;&gt;installed Docker Compose&lt;/a&gt;.</source>
          <target state="translated">部署Notary Server的最简单方法是使用Docker Compose。要遵循此页面上的过程，您必须已经&lt;a href=&quot;../../../../compose/install/index&quot;&gt;安装了Docker Compose&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cbb3473804a03fd64904744c7f89f506da1b00af" translate="yes" xml:space="preserve">
          <source>The easiest way to deploy an application is to run it on a single server, similar to how you would run your development environment. If you want to scale up your application, you can run Compose apps on a Swarm cluster.</source>
          <target state="translated">部署应用程序的最简单方法是在单一服务器上运行它,类似于你运行开发环境的方式。如果你想扩展你的应用程序,你可以在Swarm集群上运行Compose应用程序。</target>
        </trans-unit>
        <trans-unit id="0f3be48a8a42306450b08c080985765fe25d537c" translate="yes" xml:space="preserve">
          <source>The easiest way to produce a bundle is to generate it using &lt;code&gt;docker-compose&lt;/code&gt; from an existing &lt;code&gt;docker-compose.yml&lt;/code&gt;. Of course, that&amp;rsquo;s just &lt;em&gt;one&lt;/em&gt; possible way to proceed, in the same way that &lt;code&gt;docker build&lt;/code&gt; isn&amp;rsquo;t the only way to produce a Docker image.</source>
          <target state="translated">产生捆绑的最简单方法是使用 &lt;code&gt;docker-compose.yml&lt;/code&gt; &lt;code&gt;docker-compose&lt;/code&gt; 从现有的docker-compose.yml生成捆绑。当然，这只是&lt;em&gt;一种&lt;/em&gt;可行的处理方式，就像 &lt;code&gt;docker build&lt;/code&gt; 不是生成Docker映像的唯一方法一样。</target>
        </trans-unit>
        <trans-unit id="2e21df395f3446d584a4ca9200bc32ed01c54aa7" translate="yes" xml:space="preserve">
          <source>The endpoint &lt;code&gt;/containers/(id or name)/copy&lt;/code&gt; is deprecated in favor of &lt;code&gt;/containers/(id or name)/archive&lt;/code&gt;.</source>
          <target state="translated">不建议使用端点 &lt;code&gt;/containers/(id or name)/copy&lt;/code&gt; 而推荐使用 &lt;code&gt;/containers/(id or name)/archive&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5c08b62b88c6225b00d167dc7e607242e3b89d5e" translate="yes" xml:space="preserve">
          <source>The entrypoint can also be a list, in a manner similar to &lt;a href=&quot;../../../engine/reference/builder/index#entrypoint&quot;&gt;dockerfile&lt;/a&gt;:</source>
          <target state="translated">入口点也可以是列表，类似于&lt;a href=&quot;../../../engine/reference/builder/index#entrypoint&quot;&gt;dockerfile&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="f40c04ee015b92c39817e6ca9d4f62c70b5a83bd" translate="yes" xml:space="preserve">
          <source>The entrypoint can also be a list, in a manner similar to &lt;a href=&quot;../../engine/reference/builder/index#entrypoint&quot;&gt;dockerfile&lt;/a&gt;:</source>
          <target state="translated">入口点也可以是列表，类似于&lt;a href=&quot;../../engine/reference/builder/index#entrypoint&quot;&gt;dockerfile&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="ec2a98ae62a1beccce3cba7cfa61a0b6efb72b90" translate="yes" xml:space="preserve">
          <source>The env command supports a &lt;code&gt;--no-proxy&lt;/code&gt; flag which ensures that the created machine&amp;rsquo;s IP address is added to the &lt;a href=&quot;https://wiki.archlinux.org/index.php/Proxy_settings&quot;&gt;&lt;code&gt;NO_PROXY&lt;/code&gt;/&lt;code&gt;no_proxy&lt;/code&gt; environment variable&lt;/a&gt;.</source>
          <target state="translated">env命令支持 &lt;code&gt;--no-proxy&lt;/code&gt; 标志，可确保将创建的计算机的IP地址添加到&lt;a href=&quot;https://wiki.archlinux.org/index.php/Proxy_settings&quot;&gt; &lt;code&gt;NO_PROXY&lt;/code&gt; / &lt;code&gt;no_proxy&lt;/code&gt; 环境变量中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e1826416e57d3bef2c80c7a035f75c85a4ffee30" translate="yes" xml:space="preserve">
          <source>The environment variables for the older passwords are optional, but Notary Signer cannot decrypt older keys if they are not provided, and attempts to sign data using those keys fail.</source>
          <target state="translated">旧密码的环境变量是可选的,但如果不提供旧密码,公证员就无法解密旧密码,使用这些密码进行签名的尝试就会失败。</target>
        </trans-unit>
        <trans-unit id="a6627fbb8c91d0fc377c2ff347617c288abca678" translate="yes" xml:space="preserve">
          <source>The environment variables set using &lt;code&gt;ENV&lt;/code&gt; will persist when a container is run from the resulting image. You can view the values using &lt;code&gt;docker inspect&lt;/code&gt;, and change them using &lt;code&gt;docker run --env &amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">从结果映像运行容器时，使用 &lt;code&gt;ENV&lt;/code&gt; 设置的环境变量将保留。您可以使用 &lt;code&gt;docker run --env &amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; &lt;code&gt;docker inspect&lt;/code&gt; 查看值，并使用docker run --env &amp;lt;key&amp;gt; = &amp;lt;value&amp;gt;更改它们。</target>
        </trans-unit>
        <trans-unit id="f2d4a06ff2b2c1bb65797bcb34409b040d8f44ca" translate="yes" xml:space="preserve">
          <source>The environment variables you define here are used for &lt;a href=&quot;../compose-file/index#variable-substitution&quot;&gt;variable substitution&lt;/a&gt; in your Compose file, and can also be used to define the following &lt;a href=&quot;../reference/envvars/index&quot;&gt;CLI variables&lt;/a&gt;:</source>
          <target state="translated">您在此处定义的环境变量用于Compose文件中的&lt;a href=&quot;../compose-file/index#variable-substitution&quot;&gt;变量替换&lt;/a&gt;，也可以用于定义以下&lt;a href=&quot;../reference/envvars/index&quot;&gt;CLI变量&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="d428381f478d7b84b477c7df64a8f6a6a9edd161" translate="yes" xml:space="preserve">
          <source>The escape character is used both to escape characters in a line, and to escape a newline. This allows a &lt;code&gt;Dockerfile&lt;/code&gt; instruction to span multiple lines. Note that regardless of whether the &lt;code&gt;escape&lt;/code&gt; parser directive is included in a &lt;code&gt;Dockerfile&lt;/code&gt;, &lt;em&gt;escaping is not performed in a &lt;code&gt;RUN&lt;/code&gt; command, except at the end of a line.&lt;/em&gt;</source>
          <target state="translated">转义字符用于转义一行中的字符和转义换行符。这允许 &lt;code&gt;Dockerfile&lt;/code&gt; 指令跨越多行。请注意，无论 &lt;code&gt;Dockerfile&lt;/code&gt; 中是否包含 &lt;code&gt;escape&lt;/code&gt; 解析器指令&lt;em&gt;，除非在一行的末尾&lt;/em&gt;，&lt;em&gt;转义都不会在&lt;/em&gt;&lt;em&gt; &lt;code&gt;RUN&lt;/code&gt; &lt;/em&gt;&lt;em&gt;命令中&lt;/em&gt;&lt;em&gt;执行&lt;/em&gt;&lt;em&gt;。&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="eeba3b74b0236d42f86530a251ea9e62a35c7995" translate="yes" xml:space="preserve">
          <source>The events that can be received using this can be seen &lt;a href=&quot;../../../engine/reference/commandline/events/index#object-types&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">使用此功能可以接收的事件可以在&lt;a href=&quot;../../../engine/reference/commandline/events/index#object-types&quot;&gt;此处&lt;/a&gt;看到。</target>
        </trans-unit>
        <trans-unit id="1a17988740e39b0620e37d4cec3a97d766137f47" translate="yes" xml:space="preserve">
          <source>The example below demonstrates joining a manager node using a manager token.</source>
          <target state="translated">下面的例子演示了如何使用经理令牌加入经理节点。</target>
        </trans-unit>
        <trans-unit id="25b4970988441b740e2a781fbee1a66aa2b61f5a" translate="yes" xml:space="preserve">
          <source>The example below demonstrates joining a worker node using a worker token.</source>
          <target state="translated">下面的示例演示了如何使用工人标记加入工人节点。</target>
        </trans-unit>
        <trans-unit id="b7a1e5a37682ef20c70bef17964c7684d70c655a" translate="yes" xml:space="preserve">
          <source>The example below exposes the first and third GPUs.</source>
          <target state="translated">下面的例子暴露了第一个和第三个GPU。</target>
        </trans-unit>
        <trans-unit id="136216b3bc39195557bd1003225e277d5f1e1c60" translate="yes" xml:space="preserve">
          <source>The example below illustrates this:</source>
          <target state="translated">下面的例子可以说明这一点。</target>
        </trans-unit>
        <trans-unit id="7ed635a4e298f0a02b5b0d66b8bfc619f56a50cc" translate="yes" xml:space="preserve">
          <source>The example below mounts an empty tmpfs into the container with the &lt;code&gt;rw&lt;/code&gt;, &lt;code&gt;noexec&lt;/code&gt;, &lt;code&gt;nosuid&lt;/code&gt;, and &lt;code&gt;size=65536k&lt;/code&gt; options.</source>
          <target state="translated">下面的示例使用 &lt;code&gt;rw&lt;/code&gt; ， &lt;code&gt;noexec&lt;/code&gt; ， &lt;code&gt;nosuid&lt;/code&gt; 和 &lt;code&gt;size=65536k&lt;/code&gt; 选项将空的tmpfs装入容器。</target>
        </trans-unit>
        <trans-unit id="cd44fcd3927c43527b19df5d70413fafa8dafd56" translate="yes" xml:space="preserve">
          <source>The example below shows the information from a certificate from a worker node:</source>
          <target state="translated">下面的例子显示了来自工人节点的证书信息。</target>
        </trans-unit>
        <trans-unit id="54d8617f0498acb2ab072f389ab875b0bca6e0a6" translate="yes" xml:space="preserve">
          <source>The example below shows the output for a daemon running on Red Hat Enterprise Linux, using the &lt;code&gt;devicemapper&lt;/code&gt; storage driver. As can be seen in the output, additional information about the &lt;code&gt;devicemapper&lt;/code&gt; storage driver is shown:</source>
          <target state="translated">以下示例显示了使用 &lt;code&gt;devicemapper&lt;/code&gt; 存储驱动程序在Red Hat Enterprise Linux上运行的守护程序的输出。从输出中可以看到，显示了有关 &lt;code&gt;devicemapper&lt;/code&gt; 存储驱动程序的其他信息：</target>
        </trans-unit>
        <trans-unit id="029833a3c9a7900068d40d95bb8919839dba6dc3" translate="yes" xml:space="preserve">
          <source>The example on this page is using experimental mode in Docker 1.13.</source>
          <target state="translated">本页的例子是在Docker 1.13中使用实验模式。</target>
        </trans-unit>
        <trans-unit id="d14272aafaddb2ec6f187da9a77f600e86a905b2" translate="yes" xml:space="preserve">
          <source>The example shown above would store log files until they reach a &lt;code&gt;max-size&lt;/code&gt; of 200kB, and then rotate them. The amount of individual log files stored is specified by the &lt;code&gt;max-file&lt;/code&gt; value. As logs grow beyond the max limits, older log files are removed to allow storage of new logs.</source>
          <target state="translated">上面显示的示例将存储日志文件，直到它们达到 &lt;code&gt;max-size&lt;/code&gt; 200kB，然后旋转它们。单个日志文件的存储量由 &lt;code&gt;max-file&lt;/code&gt; 值指定。随着日志超过最大限制，将删除较旧的日志文件以允许存储新日志。</target>
        </trans-unit>
        <trans-unit id="c577259842d61990aced0fbd2f28da4da6a3648f" translate="yes" xml:space="preserve">
          <source>The examples here show how to create and start a machine, run Docker commands, and work with containers.</source>
          <target state="translated">这里的例子展示了如何创建和启动一台机器,运行Docker命令,并与容器一起工作。</target>
        </trans-unit>
        <trans-unit id="0849d6689ed7be80620bb8487fe1dd07e740085a" translate="yes" xml:space="preserve">
          <source>The exit code from &lt;code&gt;docker run&lt;/code&gt; gives information about why the container failed to run or why it exited. When &lt;code&gt;docker run&lt;/code&gt; exits with a non-zero code, the exit codes follow the &lt;code&gt;chroot&lt;/code&gt; standard, see below:</source>
          <target state="translated">&lt;code&gt;docker run&lt;/code&gt; 的退出代码提供有关为何容器无法运行或为何退出的信息。当 &lt;code&gt;docker run&lt;/code&gt; 使用非零代码退出时，退出代码遵循 &lt;code&gt;chroot&lt;/code&gt; 标准，请参见下文：</target>
        </trans-unit>
        <trans-unit id="582264dedcc552f5bc709f56c6bf7ac62d1091c7" translate="yes" xml:space="preserve">
          <source>The experimental channel uses incremental versioning with the major and minor component from the stable channel on the time of the release. For example:</source>
          <target state="translated">实验通道采用增量版本,发布时的主要和次要组件来自稳定通道。例如:</target>
        </trans-unit>
        <trans-unit id="52885d2644998577e6073933e22175a4ebac7538" translate="yes" xml:space="preserve">
          <source>The failure rate to tolerate during a rollback, specified as a floating-point number between 0 and 1. For instance, given 5 tasks, a failure ratio of &lt;code&gt;.2&lt;/code&gt; would tolerate one task failing to roll back. A value of &lt;code&gt;0&lt;/code&gt; means no failure are tolerated, while a value of &lt;code&gt;1&lt;/code&gt; means any number of failure are tolerated.</source>
          <target state="translated">回滚期间可容忍的故障率，指定为0到1之间的浮点数。例如，给定5个任务， &lt;code&gt;.2&lt;/code&gt; 的故障率将容忍一个未能回滚的任务。值 &lt;code&gt;0&lt;/code&gt; 表示不容许任何故障，而值 &lt;code&gt;1&lt;/code&gt; 表示可容许任何数量的故障。</target>
        </trans-unit>
        <trans-unit id="d68f9035a468196dba9c2b9c69d4081509161884" translate="yes" xml:space="preserve">
          <source>The features of Compose that make it effective are:</source>
          <target state="translated">Compose的特点使其有效的是:。</target>
        </trans-unit>
        <trans-unit id="5586c9b78df4bbb7f9f4a597bb211ee31c9db6a9" translate="yes" xml:space="preserve">
          <source>The fields &lt;code&gt;ID&lt;/code&gt;, &lt;code&gt;Status&lt;/code&gt; and &lt;code&gt;From&lt;/code&gt; in the events API have been deprecated in favor of a more rich structure. See the events API documentation for the new format.</source>
          <target state="translated">事件API中的字段 &lt;code&gt;ID&lt;/code&gt; ， &lt;code&gt;Status&lt;/code&gt; 和 &lt;code&gt;From&lt;/code&gt; 已被弃用，以使用更丰富的结构。请参阅事件API文档以获取新格式。</target>
        </trans-unit>
        <trans-unit id="e940422c1fe38ec0a69aaf8826be36a4ebca5660" translate="yes" xml:space="preserve">
          <source>The file doesn&amp;rsquo;t need to have any contents.</source>
          <target state="translated">该文件不需要任何内容​​。</target>
        </trans-unit>
        <trans-unit id="4e1b2e21312a1d047cc07a276a5f08dda69ecae6" translate="yes" xml:space="preserve">
          <source>The file path in this example is not a requirement. In production, you could use another.</source>
          <target state="translated">本例中的文件路径不是要求。在生产中,你可以使用其他的路径。</target>
        </trans-unit>
        <trans-unit id="c5a70924dcb932c02c158eac18cd4f544c78e2d1" translate="yes" xml:space="preserve">
          <source>The files are actually being transferred using &lt;code&gt;sftp&lt;/code&gt; (over an ssh connection), so this program (&amp;ldquo;sftp&amp;rdquo;) needs to be present on the machine - but it usually is.</source>
          <target state="translated">文件实际上是使用 &lt;code&gt;sftp&lt;/code&gt; 传输的（通过ssh连接），因此该程序（&amp;ldquo; sftp&amp;rdquo;）需要存在于计算机上-但通常是这样。</target>
        </trans-unit>
        <trans-unit id="1c30c54a6a3202f383fed47f50a78dfcf095b8ba" translate="yes" xml:space="preserve">
          <source>The filtering flag (&lt;code&gt;--filter&lt;/code&gt;) format is a &lt;code&gt;key=value&lt;/code&gt; pair. If there is more than one filter, then pass multiple flags. For example: &lt;code&gt;--filter &quot;foo=bar&quot; --filter &quot;bif=baz&quot;&lt;/code&gt;</source>
          <target state="translated">过滤标志（ &lt;code&gt;--filter&lt;/code&gt; ）格式为 &lt;code&gt;key=value&lt;/code&gt; 对。如果有多个过滤器，则传递多个标志。例如：-- &lt;code&gt;--filter &quot;foo=bar&quot; --filter &quot;bif=baz&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8f285ce11e5dcd83c24e5bd33204635adf09ba89" translate="yes" xml:space="preserve">
          <source>The filtering flag (&lt;code&gt;--filter&lt;/code&gt;) format is of &amp;ldquo;key=value&amp;rdquo;. If there is more than one filter, then pass multiple flags (e.g., &lt;code&gt;--filter &quot;foo=bar&quot; --filter &quot;bif=baz&quot;&lt;/code&gt;)</source>
          <target state="translated">过滤标志（ &lt;code&gt;--filter&lt;/code&gt; ）格式为&amp;ldquo;键=值&amp;rdquo;。如果有多个过滤器，则传递多个标志（例如 &lt;code&gt;--filter &quot;foo=bar&quot; --filter &quot;bif=baz&quot;&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="17cb4654fb42a49d5cd6d0cc710a22c55ee18d5c" translate="yes" xml:space="preserve">
          <source>The filtering flag (&lt;code&gt;-f&lt;/code&gt; or &lt;code&gt;--filter&lt;/code&gt;) format is a &lt;code&gt;key=value&lt;/code&gt; pair. If there is more than one filter, then pass multiple flags (e.g. &lt;code&gt;--filter &quot;foo=bar&quot; --filter &quot;bif=baz&quot;&lt;/code&gt;)</source>
          <target state="translated">过滤标志（ &lt;code&gt;-f&lt;/code&gt; 或 &lt;code&gt;--filter&lt;/code&gt; ）格式为 &lt;code&gt;key=value&lt;/code&gt; 对。如果有多个过滤器，则传递多个标志（例如 &lt;code&gt;--filter &quot;foo=bar&quot; --filter &quot;bif=baz&quot;&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="426aa2257cf91d00fd6ee5760b570121af7b130b" translate="yes" xml:space="preserve">
          <source>The filtering flag (&lt;code&gt;-f&lt;/code&gt; or &lt;code&gt;--filter&lt;/code&gt;) format is a &lt;code&gt;key=value&lt;/code&gt; pair. If there is more than one filter, then pass multiple flags (e.g. &lt;code&gt;--filter &quot;foo=bar&quot; --filter &quot;bif=baz&quot;&lt;/code&gt;). Multiple filter flags are combined as an &lt;code&gt;OR&lt;/code&gt; filter.</source>
          <target state="translated">过滤标志（ &lt;code&gt;-f&lt;/code&gt; 或 &lt;code&gt;--filter&lt;/code&gt; ）格式为 &lt;code&gt;key=value&lt;/code&gt; 对。如果有多个过滤器，则传递多个标志（例如 &lt;code&gt;--filter &quot;foo=bar&quot; --filter &quot;bif=baz&quot;&lt;/code&gt; ）。多个过滤器标志被组合为 &lt;code&gt;OR&lt;/code&gt; 过滤器。</target>
        </trans-unit>
        <trans-unit id="e8989ebfc2055cad776feeb144c1f803cbdf05ec" translate="yes" xml:space="preserve">
          <source>The filtering flag (&lt;code&gt;-f&lt;/code&gt; or &lt;code&gt;--filter&lt;/code&gt;) format is a &lt;code&gt;key=value&lt;/code&gt; pair. If there is more than one filter, then pass multiple flags (e.g. &lt;code&gt;--filter &quot;foo=bar&quot; --filter &quot;bif=baz&quot;&lt;/code&gt;). Multiple filter flags are combined as an &lt;code&gt;OR&lt;/code&gt; filter. For example, &lt;code&gt;-f name=redis.1 -f name=redis.7&lt;/code&gt; returns both &lt;code&gt;redis.1&lt;/code&gt; and &lt;code&gt;redis.7&lt;/code&gt; tasks.</source>
          <target state="translated">过滤标志（ &lt;code&gt;-f&lt;/code&gt; 或 &lt;code&gt;--filter&lt;/code&gt; ）格式为 &lt;code&gt;key=value&lt;/code&gt; 对。如果有多个过滤器，则传递多个标志（例如 &lt;code&gt;--filter &quot;foo=bar&quot; --filter &quot;bif=baz&quot;&lt;/code&gt; ）。多个过滤器标志被组合为 &lt;code&gt;OR&lt;/code&gt; 过滤器。例如， &lt;code&gt;-f name=redis.1 -f name=redis.7&lt;/code&gt; 返回 &lt;code&gt;redis.1&lt;/code&gt; 和 &lt;code&gt;redis.7&lt;/code&gt; 任务。</target>
        </trans-unit>
        <trans-unit id="6cfeb05ebb258fa8134b6ec40524576b415408df" translate="yes" xml:space="preserve">
          <source>The filtering flag (&lt;code&gt;-f&lt;/code&gt; or &lt;code&gt;--filter&lt;/code&gt;) format is a &lt;code&gt;key=value&lt;/code&gt; pair. If there is more than one filter, then pass multiple flags (e.g. &lt;code&gt;--filter &quot;foo=bar&quot; --filter &quot;bif=baz&quot;&lt;/code&gt;). Multiple filter flags are combined as an &lt;code&gt;OR&lt;/code&gt; filter. For example, &lt;code&gt;-f type=custom -f type=builtin&lt;/code&gt; returns both &lt;code&gt;custom&lt;/code&gt; and &lt;code&gt;builtin&lt;/code&gt; networks.</source>
          <target state="translated">过滤标志（ &lt;code&gt;-f&lt;/code&gt; 或 &lt;code&gt;--filter&lt;/code&gt; ）格式为 &lt;code&gt;key=value&lt;/code&gt; 对。如果有多个过滤器，则传递多个标志（例如 &lt;code&gt;--filter &quot;foo=bar&quot; --filter &quot;bif=baz&quot;&lt;/code&gt; ）。多个过滤器标志被组合为 &lt;code&gt;OR&lt;/code&gt; 过滤器。例如， &lt;code&gt;-f type=custom -f type=builtin&lt;/code&gt; 返回 &lt;code&gt;custom&lt;/code&gt; 和 &lt;code&gt;builtin&lt;/code&gt; 网络。</target>
        </trans-unit>
        <trans-unit id="aa57b9da7a41568c91cc65822e0d547ada31afd2" translate="yes" xml:space="preserve">
          <source>The filtering flag (&lt;code&gt;-f&lt;/code&gt; or &lt;code&gt;--filter&lt;/code&gt;) format is a &lt;code&gt;key=value&lt;/code&gt; pair. If there is more than one filter, then pass multiple flags (e.g., &lt;code&gt;--filter &quot;foo=bar&quot; --filter &quot;bif=baz&quot;&lt;/code&gt;)</source>
          <target state="translated">过滤标志（ &lt;code&gt;-f&lt;/code&gt; 或 &lt;code&gt;--filter&lt;/code&gt; ）格式为 &lt;code&gt;key=value&lt;/code&gt; 对。如果有多个过滤器，则传递多个标志（例如 &lt;code&gt;--filter &quot;foo=bar&quot; --filter &quot;bif=baz&quot;&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="6d153c537e3f437d55503da7c3af5fa8df3281c1" translate="yes" xml:space="preserve">
          <source>The filtering flag (&lt;code&gt;-f&lt;/code&gt; or &lt;code&gt;--filter&lt;/code&gt;) format is of &amp;ldquo;key=value&amp;rdquo;. If there is more than one filter, then pass multiple flags (e.g., &lt;code&gt;--filter &quot;foo=bar&quot; --filter &quot;bif=baz&quot;&lt;/code&gt;)</source>
          <target state="translated">过滤标志（ &lt;code&gt;-f&lt;/code&gt; 或 &lt;code&gt;--filter&lt;/code&gt; ）格式为&amp;ldquo;键=值&amp;rdquo;。如果有多个过滤器，则传递多个标志（例如 &lt;code&gt;--filter &quot;foo=bar&quot; --filter &quot;bif=baz&quot;&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="21c9307216d7ac9e58873bc62de805e595d77fb7" translate="yes" xml:space="preserve">
          <source>The filtering flag (&lt;code&gt;-f&lt;/code&gt; or &lt;code&gt;--filter&lt;/code&gt;) format is of &amp;ldquo;key=value&amp;rdquo;. If you would like to use multiple filters, pass multiple flags (e.g., &lt;code&gt;--filter &quot;foo=bar&quot; --filter &quot;bif=baz&quot;&lt;/code&gt;)</source>
          <target state="translated">过滤标志（ &lt;code&gt;-f&lt;/code&gt; 或 &lt;code&gt;--filter&lt;/code&gt; ）格式为&amp;ldquo;键=值&amp;rdquo;。如果您想使用多个过滤器，请传递多个标志（例如 &lt;code&gt;--filter &quot;foo=bar&quot; --filter &quot;bif=baz&quot;&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="c89d57bdf2df6a04b4fa2b97bdec037616b402af" translate="yes" xml:space="preserve">
          <source>The first example shows both the short and long syntax for secrets, and the second example shows only the short syntax. The short syntax creates files in &lt;code&gt;/run/secrets/&lt;/code&gt; with the same name as the secret. Within the running containers, the following three files now exist:</source>
          <target state="translated">第一个示例显示密钥的短语法和长语法，第二个示例仅显示秘密语法。简短的语法在 &lt;code&gt;/run/secrets/&lt;/code&gt; 创建与密钥同名的文件。在运行的容器中，现在存在以下三个文件：</target>
        </trans-unit>
        <trans-unit id="c1e4c3387577d12532a6e4a3ecfe47ce12c0a55e" translate="yes" xml:space="preserve">
          <source>The first machine acts as the manager, which executes management commands and authenticates workers to join the swarm, and the second is a worker.</source>
          <target state="translated">第一台机器作为管理者,执行管理命令,并认证工人加入蜂群,第二台是工人。</target>
        </trans-unit>
        <trans-unit id="2bba495c3320b897a52b14601599924b407dce11" translate="yes" xml:space="preserve">
          <source>The first time you run this, the docker-in-docker, Notary server, and registry images are downloaded from Docker Hub.</source>
          <target state="translated">第一次运行时,docker-in-docker、Notary服务器和注册表镜像都是从Docker Hub下载的。</target>
        </trans-unit>
        <trans-unit id="c9e3339436cc84f78df58b00f645a3e8f63ffc1d" translate="yes" xml:space="preserve">
          <source>The first time you try to create a machine, Azure driver asks you to authenticate:</source>
          <target state="translated">第一次尝试创建机器时,Azure驱动会要求你进行验证。</target>
        </trans-unit>
        <trans-unit id="cb84cfdbd020c04d119b920f80cb7bc8cfcb5740" translate="yes" xml:space="preserve">
          <source>The flag &lt;code&gt;--api-enable-cors&lt;/code&gt; is deprecated since v1.6.0. Use the flag &lt;code&gt;--api-cors-header&lt;/code&gt; instead.</source>
          <target state="translated">自v1.6.0起不推荐使用 &lt;code&gt;--api-enable-cors&lt;/code&gt; 标志。请改用 &lt;code&gt;--api-cors-header&lt;/code&gt; 标志。</target>
        </trans-unit>
        <trans-unit id="05639fcd64ed17067c7ecbfbfdb1be4d5640f23e" translate="yes" xml:space="preserve">
          <source>The flag &lt;code&gt;--limit&lt;/code&gt; is the maximum number of results returned by a search. This value could be in the range between 1 and 100. The default value of &lt;code&gt;--limit&lt;/code&gt; is 25.</source>
          <target state="translated">标志 &lt;code&gt;--limit&lt;/code&gt; 是搜索返回的最大结果数。此值的范围可以是1到100 &lt;code&gt;--limit&lt;/code&gt; 的默认值是25。</target>
        </trans-unit>
        <trans-unit id="cab2ad76191c73b2c24b2a692e1bc849f354e599" translate="yes" xml:space="preserve">
          <source>The flag &lt;code&gt;--run&lt;/code&gt; of the docker commit (and its short version &lt;code&gt;-run&lt;/code&gt;) were deprecated in favor of the &lt;code&gt;--changes&lt;/code&gt; flag that allows to pass &lt;code&gt;Dockerfile&lt;/code&gt; commands.</source>
          <target state="translated">不推荐使用 &lt;code&gt;Dockerfile&lt;/code&gt; commit的 &lt;code&gt;--run&lt;/code&gt; 标志（及其简短版本 &lt;code&gt;-run&lt;/code&gt; ），而推荐使用 &lt;code&gt;--changes&lt;/code&gt; 标志，该标志允许传递Dockerfile命令。</target>
        </trans-unit>
        <trans-unit id="66b31971db73964ceb63d241b628599ed67bd387" translate="yes" xml:space="preserve">
          <source>The flag &lt;code&gt;--security-opt&lt;/code&gt; doesn&amp;rsquo;t use the colon separator (&lt;code&gt;:&lt;/code&gt;) anymore to divide keys and values, it uses the equal symbol (&lt;code&gt;=&lt;/code&gt;) for consistency with other similar flags, like &lt;code&gt;--storage-opt&lt;/code&gt;.</source>
          <target state="translated">该标志 &lt;code&gt;--security-opt&lt;/code&gt; 不使用冒号分隔符（ &lt;code&gt;:&lt;/code&gt; ）再划分的键和值，它使用等于符号（ &lt;code&gt;=&lt;/code&gt; 用于与其他类似的标志，样稠度） &lt;code&gt;--storage-opt&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8989880255f74df623b434530f23c19d9dd927e2" translate="yes" xml:space="preserve">
          <source>The flag can be used multiple times to allow multiple registries to be marked as insecure.</source>
          <target state="translated">该标志可多次使用,以允许将多个注册表标记为不安全。</target>
        </trans-unit>
        <trans-unit id="211c61f70624ea83298a758a91c7c1645a33a063" translate="yes" xml:space="preserve">
          <source>The flags &lt;code&gt;-d&lt;/code&gt; and &lt;code&gt;--daemon&lt;/code&gt; are deprecated in favor of the &lt;code&gt;daemon&lt;/code&gt; subcommand:</source>
          <target state="translated">不建议使用 &lt;code&gt;-d&lt;/code&gt; 和 &lt;code&gt;--daemon&lt;/code&gt; 标志，而推荐使用 &lt;code&gt;daemon&lt;/code&gt; 子命令：</target>
        </trans-unit>
        <trans-unit id="fe514827a2bc8cfeb3427c13cc2ba47f6aba7300" translate="yes" xml:space="preserve">
          <source>The flags are:</source>
          <target state="translated">旗帜是:</target>
        </trans-unit>
        <trans-unit id="2fec17d2ea0cac008bfab4ea63128760ff0394bf" translate="yes" xml:space="preserve">
          <source>The flags you pass to &lt;code&gt;ip addr show&lt;/code&gt; depend on whether you are using IPv4 or IPv6 networking in your containers. Use the following flags for IPv4 address retrieval for a network device named &lt;code&gt;eth0&lt;/code&gt;:</source>
          <target state="translated">传递给 &lt;code&gt;ip addr show&lt;/code&gt; 的标志取决于您在容器中使用的是IPv4还是IPv6网络。将以下标志用于名为 &lt;code&gt;eth0&lt;/code&gt; 的网络设备的IPv4地址检索：</target>
        </trans-unit>
        <trans-unit id="71648dc68d5b64d785048324356509378e05cbab" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;ARG&lt;/code&gt; variables are set automatically:</source>
          <target state="translated">自动设置以下 &lt;code&gt;ARG&lt;/code&gt; 变量：</target>
        </trans-unit>
        <trans-unit id="30e40704f73a0a3a123810462ea6e8146a6cf011" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;Dockerfile&lt;/code&gt; shows using the &lt;code&gt;ENTRYPOINT&lt;/code&gt; to run Apache in the foreground (i.e., as &lt;code&gt;PID 1&lt;/code&gt;):</source>
          <target state="translated">以下 &lt;code&gt;Dockerfile&lt;/code&gt; 显示了使用 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 在前台运行Apache（即，作为 &lt;code&gt;PID 1&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="37f735ff00a071c2cf805f826830d3b8e2b5d95b" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;run&lt;/code&gt; command options work with container networking:</source>
          <target state="translated">以下 &lt;code&gt;run&lt;/code&gt; 命令选项可用于容器网络：</target>
        </trans-unit>
        <trans-unit id="2dd8971bea651d99e456deec000fc508c3c98507" translate="yes" xml:space="preserve">
          <source>The following arguments can be passed to &lt;code&gt;docker network create&lt;/code&gt; for any network driver, again with their approximate equivalents to &lt;code&gt;docker daemon&lt;/code&gt;.</source>
          <target state="translated">可以将以下参数传递给任何网络驱动程序的 &lt;code&gt;docker network create&lt;/code&gt; ，再次将它们传递给 &lt;code&gt;docker daemon&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b23a60a2303821537dcbfdf274039df8c3b54583" translate="yes" xml:space="preserve">
          <source>The following assumptions are made:</source>
          <target state="translated">作出以下假设:</target>
        </trans-unit>
        <trans-unit id="8c8e4bd61d1bff8edef1e67a6084184b1eb9a3d0" translate="yes" xml:space="preserve">
          <source>The following command creates a global service:</source>
          <target state="translated">下面的命令可以创建一个全局服务。</target>
        </trans-unit>
        <trans-unit id="3f41dfd8129fa7163b1fcd0686727a3dff3ac419" translate="yes" xml:space="preserve">
          <source>The following command creates a service with three replicas with an anonymous volume on &lt;code&gt;/path/in/container&lt;/code&gt;:</source>
          <target state="translated">以下命令创建一个具有三个副本的服务，该副本在 &lt;code&gt;/path/in/container&lt;/code&gt; 上具有一个匿名卷：</target>
        </trans-unit>
        <trans-unit id="29c23ead74fe204bf41fa629c5ab8b6b4b70e8a5" translate="yes" xml:space="preserve">
          <source>The following command pulls the &lt;code&gt;testing/test-image&lt;/code&gt; image from a local registry listening on port 5000 (&lt;code&gt;myregistry.local:5000&lt;/code&gt;):</source>
          <target state="translated">以下命令从侦听端口5000（ &lt;code&gt;myregistry.local:5000&lt;/code&gt; ）的本地注册表中提取 &lt;code&gt;testing/test-image&lt;/code&gt; 映像：</target>
        </trans-unit>
        <trans-unit id="7e7782423be2ee9e2d32ef7fe59037eb232cd112" translate="yes" xml:space="preserve">
          <source>The following command scales the &amp;ldquo;frontend&amp;rdquo; service to 50 tasks.</source>
          <target state="translated">以下命令将&amp;ldquo;前端&amp;rdquo;服务扩展到50个任务。</target>
        </trans-unit>
        <trans-unit id="e98a7778ab952d2730fb21ff8b3b5a2385a04618" translate="yes" xml:space="preserve">
          <source>The following command shows all services in the &lt;code&gt;myapp&lt;/code&gt; stack:</source>
          <target state="translated">以下命令显示 &lt;code&gt;myapp&lt;/code&gt; 堆栈中的所有服务：</target>
        </trans-unit>
        <trans-unit id="f6737e57d5cb6dbd975d1866fc4b37937d8fb0ea" translate="yes" xml:space="preserve">
          <source>The following command shows all stacks and some additional information:</source>
          <target state="translated">以下命令显示了所有堆栈和一些附加信息。</target>
        </trans-unit>
        <trans-unit id="d5faa074805d759eea82bbf46ff2134e3cf5cf46" translate="yes" xml:space="preserve">
          <source>The following command shows all the tasks that are part of the &lt;code&gt;redis&lt;/code&gt; service:</source>
          <target state="translated">以下命令显示了 &lt;code&gt;redis&lt;/code&gt; 服务中的所有任务：</target>
        </trans-unit>
        <trans-unit id="7366e9c16d47b415ad53ada639d3d553801f6fcb" translate="yes" xml:space="preserve">
          <source>The following command shows all the tasks that are part of the &lt;code&gt;voting&lt;/code&gt; stack:</source>
          <target state="translated">以下命令显示了 &lt;code&gt;voting&lt;/code&gt; 堆栈中的所有任务：</target>
        </trans-unit>
        <trans-unit id="33aa1c0ff959003ae5db74897da312b568866247" translate="yes" xml:space="preserve">
          <source>The following command shows both the &lt;code&gt;web&lt;/code&gt; and &lt;code&gt;db&lt;/code&gt; services:</source>
          <target state="translated">以下命令显示了 &lt;code&gt;web&lt;/code&gt; 服务和 &lt;code&gt;db&lt;/code&gt; 服务：</target>
        </trans-unit>
        <trans-unit id="cc1df223fe15bc104674c09a48d71feaab974d1f" translate="yes" xml:space="preserve">
          <source>The following command shows images and which family they belong to (if any):</source>
          <target state="translated">下面的命令显示图像和它们所属的家族(如果有的话)。</target>
        </trans-unit>
        <trans-unit id="f3237696ef19d83021d5a836b6a1e9cef0f6a8c6" translate="yes" xml:space="preserve">
          <source>The following command tries to scale a global service to 10 tasks and returns an error.</source>
          <target state="translated">下面的命令试图将一个全局服务扩展到10个任务,并返回一个错误。</target>
        </trans-unit>
        <trans-unit id="743253aea145f2b6b290ac340121787c9e892dbc" translate="yes" xml:space="preserve">
          <source>The following commands show several different ways to filter the &lt;code&gt;docker event&lt;/code&gt; output.</source>
          <target state="translated">以下命令显示了几种过滤 &lt;code&gt;docker event&lt;/code&gt; 输出的方法。</target>
        </trans-unit>
        <trans-unit id="b6298983a47ff8b831614b53250bab44a457c001" translate="yes" xml:space="preserve">
          <source>The following daemon options must be configured for each daemon:</source>
          <target state="translated">必须为每个守护进程配置以下守护进程选项。</target>
        </trans-unit>
        <trans-unit id="0e1249ef154b913b7dd2bbe55b18194abec49cea" translate="yes" xml:space="preserve">
          <source>The following diagram illustrates the interactions between the Notary client, server, and signer:</source>
          <target state="translated">下图说明了公证客户端、服务器和签字人之间的交互。</target>
        </trans-unit>
        <trans-unit id="073116ed512a6960c0757670bc051f3d85c14ca2" translate="yes" xml:space="preserve">
          <source>The following double-dash options are deprecated and have no replacement:</source>
          <target state="translated">以下双斜线选项已被废弃,没有替代选项。</target>
        </trans-unit>
        <trans-unit id="7553e37733080d989c32cbc7394667475874c240" translate="yes" xml:space="preserve">
          <source>The following environment variables are set for Linux containers:</source>
          <target state="translated">以下是为Linux容器设置的环境变量。</target>
        </trans-unit>
        <trans-unit id="1cf7dac8f25b3b64ccb5f54f340c992264a83cea" translate="yes" xml:space="preserve">
          <source>The following environment variables containing signing key passphrases can be used to facilitate &lt;a href=&quot;../../advanced_usage/index&quot;&gt;Notary client CLI interaction&lt;/a&gt;. If provided, these passwords are used initially to sign TUF metadata. If the passphrase is incorrect, you are prompted to enter the correct passphrase.</source>
          <target state="translated">以下包含签名密钥密码短语的环境变量可用于促进&lt;a href=&quot;../../advanced_usage/index&quot;&gt;Notary客户端CLI的交互&lt;/a&gt;。如果提供了这些密码，则最初会使用它们来签署TUF元数据。如果密码不正确，系统将提示您输入正确的密码。</target>
        </trans-unit>
        <trans-unit id="330e46b20430cd7e0f80c1c374963e5118293212" translate="yes" xml:space="preserve">
          <source>The following example adds a new alias name to an existing service already connected to network my-network:</source>
          <target state="translated">下面的例子为已经连接到网络my-network的现有服务添加了一个新的别名。</target>
        </trans-unit>
        <trans-unit id="bfce6b526de13780562727784926aed9ee9477cf" translate="yes" xml:space="preserve">
          <source>The following example adds a published service port to an existing service.</source>
          <target state="translated">下面的示例为现有服务添加了一个已发布的服务端口。</target>
        </trans-unit>
        <trans-unit id="cdac32ddb3bc500f52a2c4a75021fc5f7dc815f7" translate="yes" xml:space="preserve">
          <source>The following example adds a secret named &lt;code&gt;ssh-2&lt;/code&gt; and removes &lt;code&gt;ssh-1&lt;/code&gt;:</source>
          <target state="translated">以下示例添加了一个名为 &lt;code&gt;ssh-2&lt;/code&gt; 的密钥，并删除了 &lt;code&gt;ssh-1&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ed35b68636be0f973b90873b9a9b7655e381e216" translate="yes" xml:space="preserve">
          <source>The following example assumes a gMSA and its credential spec (called credspec.json) already exists, and that the nodes being deployed to are correctly configured for the gMSA.</source>
          <target state="translated">下面的例子假设gMSA及其凭证规范(称为credspec.json)已经存在,并且被部署到的节点已经为gMSA正确配置。</target>
        </trans-unit>
        <trans-unit id="58de12602d90215b83000afdccd448ef3bc54d9f" translate="yes" xml:space="preserve">
          <source>The following example bind-mounts a host directory at &lt;code&gt;/path/in/container&lt;/code&gt; in the containers backing the service:</source>
          <target state="translated">以下示例在支持服务的 &lt;code&gt;/path/in/container&lt;/code&gt; 中将主机目录绑定安装在/ path / in / container中：</target>
        </trans-unit>
        <trans-unit id="345356612044ec35634acb958647f9ee76b8ead7" translate="yes" xml:space="preserve">
          <source>The following example change the env variable &lt;code&gt;DEBUG&lt;/code&gt; on the &lt;code&gt;sample-volume-plugin&lt;/code&gt; plugin.</source>
          <target state="translated">下面的示例更改 &lt;code&gt;sample-volume-plugin&lt;/code&gt; 插件上的env变量 &lt;code&gt;DEBUG&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1b9d6b0fdf70b163165b0fcce02f13448db748ce" translate="yes" xml:space="preserve">
          <source>The following example change the path of the &lt;code&gt;mydevice&lt;/code&gt; device on the &lt;code&gt;myplugin&lt;/code&gt; plugin.</source>
          <target state="translated">以下示例更改 &lt;code&gt;myplugin&lt;/code&gt; 插件上 &lt;code&gt;mydevice&lt;/code&gt; 设备的路径。</target>
        </trans-unit>
        <trans-unit id="37a4c9d8a660383f462090e521ec2df16b8718d3" translate="yes" xml:space="preserve">
          <source>The following example change the source of the &lt;code&gt;mymount&lt;/code&gt; mount on the &lt;code&gt;myplugin&lt;/code&gt; plugin.</source>
          <target state="translated">以下示例更改了 &lt;code&gt;myplugin&lt;/code&gt; 插件上的 &lt;code&gt;mymount&lt;/code&gt; 挂载的源。</target>
        </trans-unit>
        <trans-unit id="f8267ab2e1a38cb0d0220942e495dc3d366efa5a" translate="yes" xml:space="preserve">
          <source>The following example change the value of the args on the &lt;code&gt;myplugin&lt;/code&gt; plugin.</source>
          <target state="translated">以下示例更改 &lt;code&gt;myplugin&lt;/code&gt; 插件上args的值。</target>
        </trans-unit>
        <trans-unit id="f650868197d937aea99d7e6f5a9ab9219f7b7e10" translate="yes" xml:space="preserve">
          <source>The following example configures a &lt;code&gt;redis&lt;/code&gt; service to roll back automatically if a &lt;code&gt;docker service update&lt;/code&gt; fails to deploy. Two tasks can be rolled back in parallel. Tasks are monitored for 20 seconds after rollback to be sure they do not exit, and a maximum failure ratio of 20% is tolerated. Default values are used for &lt;code&gt;--rollback-delay&lt;/code&gt; and &lt;code&gt;--rollback-failure-action&lt;/code&gt;.</source>
          <target state="translated">以下示例将 &lt;code&gt;redis&lt;/code&gt; 服务配置为在 &lt;code&gt;docker service update&lt;/code&gt; 无法部署时自动回滚。可以并行回滚两个任务。回滚后会监视任务20秒钟，以确保它们不会退出，并且最大失败率为20％。默认值用于 &lt;code&gt;--rollback-delay&lt;/code&gt; 和 &lt;code&gt;--rollback-failure-action&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dfc6ef49320e217eb5c253c2ac24897dc4371265" translate="yes" xml:space="preserve">
          <source>The following example creates a network using the built-in &lt;code&gt;bridge&lt;/code&gt; network driver and running a container in the created network</source>
          <target state="translated">以下示例使用内置 &lt;code&gt;bridge&lt;/code&gt; 网络驱动程序并在创建的网络中运行容器来创建网络</target>
        </trans-unit>
        <trans-unit id="6f15ed186e216c41ccf590a70e61097dd40b3081" translate="yes" xml:space="preserve">
          <source>The following example creates a service that uses a named volume:</source>
          <target state="translated">以下示例创建了一个使用命名卷的服务。</target>
        </trans-unit>
        <trans-unit id="be9175ed1d5e994edd6a5d5d4d2a3f9572676d39" translate="yes" xml:space="preserve">
          <source>The following example creates a service which mounts the &lt;code&gt;test-data&lt;/code&gt; volume to &lt;code&gt;/somewhere&lt;/code&gt;. The next step updates the service to also mount the &lt;code&gt;other-volume&lt;/code&gt; volume to &lt;code&gt;/somewhere-else&lt;/code&gt;volume, The last step unmounts the &lt;code&gt;/somewhere&lt;/code&gt; mount point, effectively removing the &lt;code&gt;test-data&lt;/code&gt; volume. Each command returns the service name.</source>
          <target state="translated">以下示例创建一个将 &lt;code&gt;test-data&lt;/code&gt; 卷安装到 &lt;code&gt;/somewhere&lt;/code&gt; 的服务。下一步将更新服务，以将 &lt;code&gt;other-volume&lt;/code&gt; 卷也挂载到 &lt;code&gt;/somewhere-else&lt;/code&gt; 卷，最后一步将挂载 &lt;code&gt;/somewhere&lt;/code&gt; 挂载点，从而有效地删除 &lt;code&gt;test-data&lt;/code&gt; 卷。每个命令都返回服务名称。</target>
        </trans-unit>
        <trans-unit id="f8c7341d24e14d740d2f93a0ba945ff8e13e5984" translate="yes" xml:space="preserve">
          <source>The following example creates a service with a single replica, updates the service to use three replicas, and then rolls back the service to the previous version, having one replica.</source>
          <target state="translated">以下示例创建了一个只有一个副本的服务,更新服务以使用三个副本,然后将服务回滚到之前的版本,拥有一个副本。</target>
        </trans-unit>
        <trans-unit id="29fd998771d5f61ae99690e05c2da76e000b7f1e" translate="yes" xml:space="preserve">
          <source>The following example disables and removes the &lt;code&gt;sample-volume-plugin:latest&lt;/code&gt; plugin:</source>
          <target state="translated">以下示例禁用并删除了 &lt;code&gt;sample-volume-plugin:latest&lt;/code&gt; 插件：</target>
        </trans-unit>
        <trans-unit id="58414d829baf96224b330e04ddc456870ac303da" translate="yes" xml:space="preserve">
          <source>The following example filter matches volumes with the &lt;code&gt;is-timelord&lt;/code&gt; label regardless of its value.</source>
          <target state="translated">以下示例过滤器将卷与 &lt;code&gt;is-timelord&lt;/code&gt; 标签匹配，而不管其值如何。</target>
        </trans-unit>
        <trans-unit id="a9825e605f4ae30ab10a0382379dec35cdfaaa78" translate="yes" xml:space="preserve">
          <source>The following example installs &lt;code&gt;vieus/sshfs&lt;/code&gt; plugin and &lt;a href=&quot;../plugin_set/index&quot;&gt;sets&lt;/a&gt; its &lt;code&gt;DEBUG&lt;/code&gt; environment variable to &lt;code&gt;1&lt;/code&gt;. To install, &lt;code&gt;pull&lt;/code&gt; the plugin from Docker Hub and prompt the user to accept the list of privileges that the plugin needs, set the plugin&amp;rsquo;s parameters and enable the plugin.</source>
          <target state="translated">以下示例将安装 &lt;code&gt;vieus/sshfs&lt;/code&gt; 插件，&lt;a href=&quot;../plugin_set/index&quot;&gt;并将&lt;/a&gt;其 &lt;code&gt;DEBUG&lt;/code&gt; 环境变量设置为 &lt;code&gt;1&lt;/code&gt; 。要进行安装，请从Docker Hub中 &lt;code&gt;pull&lt;/code&gt; 插件，并提示用户接受该插件所需的特权列表，设置插件的参数并启用该插件。</target>
        </trans-unit>
        <trans-unit id="813d16401bf2f9114259b05a74110ed1120c1ce5" translate="yes" xml:space="preserve">
          <source>The following example installs &lt;code&gt;vieus/sshfs&lt;/code&gt; plugin, uses it to create and use a volume, then upgrades the plugin.</source>
          <target state="translated">以下示例安装 &lt;code&gt;vieus/sshfs&lt;/code&gt; 插件，使用它创建和使用卷，然后升级该插件。</target>
        </trans-unit>
        <trans-unit id="488f39c6669e0e91254e7cfb402fee79b9fa2d8b" translate="yes" xml:space="preserve">
          <source>The following example is a common pattern found on Windows which can be streamlined by using the &lt;code&gt;SHELL&lt;/code&gt; instruction:</source>
          <target state="translated">以下示例是Windows上常见的模式，可以使用 &lt;code&gt;SHELL&lt;/code&gt; 指令进行精简：</target>
        </trans-unit>
        <trans-unit id="7f9a9efded9b244dee8aabd2a087f9e89c5da7e9" translate="yes" xml:space="preserve">
          <source>The following example limits the memory (&lt;code&gt;-m&lt;/code&gt;) to 500M and sets the memory reservation to 200M.</source>
          <target state="translated">以下示例将内存（ &lt;code&gt;-m&lt;/code&gt; ）限制为500M，并将内存预留设置为200M。</target>
        </trans-unit>
        <trans-unit id="c98bc0fde049889c7f7676fa21cfc061612b3f91" translate="yes" xml:space="preserve">
          <source>The following example limits the memory to 100M and disables the OOM killer for this container:</source>
          <target state="translated">下面的示例将内存限制为100M,并为这个容器禁用OOM杀手。</target>
        </trans-unit>
        <trans-unit id="61de1584870695125b4a74e826905894c3c68353" translate="yes" xml:space="preserve">
          <source>The following example load the credential spec from a value named &lt;code&gt;my-credential-spec&lt;/code&gt; in the registry:</source>
          <target state="translated">以下示例从注册表中名为 &lt;code&gt;my-credential-spec&lt;/code&gt; 的值加载凭据规范：</target>
        </trans-unit>
        <trans-unit id="f31dcebd5640e4ee3430345cde44ce122416adb9" translate="yes" xml:space="preserve">
          <source>The following example matches networks with the &lt;code&gt;bridge&lt;/code&gt; driver:</source>
          <target state="translated">以下示例将网络与 &lt;code&gt;bridge&lt;/code&gt; 驱动程序进行匹配：</target>
        </trans-unit>
        <trans-unit id="b727cd30c474b02b8830e2bceade1108e4fb2687" translate="yes" xml:space="preserve">
          <source>The following example matches networks with the &lt;code&gt;local&lt;/code&gt; scope:</source>
          <target state="translated">以下示例将网络与 &lt;code&gt;local&lt;/code&gt; 范围相匹配：</target>
        </trans-unit>
        <trans-unit id="991d737d7f20b84a74e6a617d5dc2116e8fd9fc0" translate="yes" xml:space="preserve">
          <source>The following example matches networks with the &lt;code&gt;swarm&lt;/code&gt; scope:</source>
          <target state="translated">以下示例将网络与 &lt;code&gt;swarm&lt;/code&gt; 范围匹配：</target>
        </trans-unit>
        <trans-unit id="85f19a1b28b0c4b4d423eed2db6c9916310c58bd" translate="yes" xml:space="preserve">
          <source>The following example matches volumes that are created with the &lt;code&gt;local&lt;/code&gt; driver:</source>
          <target state="translated">以下示例匹配使用 &lt;code&gt;local&lt;/code&gt; 驱动程序创建的卷：</target>
        </trans-unit>
        <trans-unit id="09cb8c4ce1df308900b83a52d7298b2ae3ac003f" translate="yes" xml:space="preserve">
          <source>The following example reads a password from a file, and passes it to the &lt;code&gt;docker login&lt;/code&gt; command using &lt;code&gt;STDIN&lt;/code&gt;:</source>
          <target state="translated">以下示例从文件读取密码，然后使用 &lt;code&gt;STDIN&lt;/code&gt; 将其传递给 &lt;code&gt;docker login&lt;/code&gt; 命令：</target>
        </trans-unit>
        <trans-unit id="e0ddfae23ebd183f0203154109919119f0be6ff1" translate="yes" xml:space="preserve">
          <source>The following example removes images with the label &lt;code&gt;deprecated&lt;/code&gt;:</source>
          <target state="translated">以下示例删除标签 &lt;code&gt;deprecated&lt;/code&gt; 图像：</target>
        </trans-unit>
        <trans-unit id="8f4b6e6ce6615def6425c69da97cb6c9e5ff166a" translate="yes" xml:space="preserve">
          <source>The following example removes images with the label &lt;code&gt;maintainer&lt;/code&gt; set to &lt;code&gt;john&lt;/code&gt;:</source>
          <target state="translated">以下示例删除标签 &lt;code&gt;maintainer&lt;/code&gt; 设置为 &lt;code&gt;john&lt;/code&gt; 的图像：</target>
        </trans-unit>
        <trans-unit id="b71aef8df0c62b67fdb13f10edccc0071e581b90" translate="yes" xml:space="preserve">
          <source>The following example runs a container from the &lt;code&gt;alpine&lt;/code&gt; image with the &lt;code&gt;sha256:9cacb71397b640eca97488cf08582ae4e4068513101088e9f96c9814bfda95e0&lt;/code&gt; digest:</source>
          <target state="translated">下面的示例使用 &lt;code&gt;sha256:9cacb71397b640eca97488cf08582ae4e4068513101088e9f96c9814bfda95e0&lt;/code&gt; 摘要运行来自 &lt;code&gt;alpine&lt;/code&gt; 图像的容器：</target>
        </trans-unit>
        <trans-unit id="14bc07f818ef5b8e3874b5e3f0cede09acf315cf" translate="yes" xml:space="preserve">
          <source>The following example runs nginx as a service on each node in your swarm and exposes nginx port locally on each swarm node.</source>
          <target state="translated">下面的例子是在群中的每个节点上以服务的形式运行nginx,并在每个群节点上本地暴露nginx端口。</target>
        </trans-unit>
        <trans-unit id="3c1ee6b9dcdd5a62ce81941fd4fd7e8bb580e939" translate="yes" xml:space="preserve">
          <source>The following example sends a &lt;code&gt;SIGHUP&lt;/code&gt; signal to the container named &lt;code&gt;my_container&lt;/code&gt;:</source>
          <target state="translated">以下示例将 &lt;code&gt;SIGHUP&lt;/code&gt; 信号发送到名为 &lt;code&gt;my_container&lt;/code&gt; 的容器：</target>
        </trans-unit>
        <trans-unit id="b046c8d9a9d59e70ba785c2fa43e3ae60f63c35d" translate="yes" xml:space="preserve">
          <source>The following example sends the default &lt;code&gt;KILL&lt;/code&gt; signal to the container named &lt;code&gt;my_container&lt;/code&gt;:</source>
          <target state="translated">以下示例将默认的 &lt;code&gt;KILL&lt;/code&gt; 信号发送到名为 &lt;code&gt;my_container&lt;/code&gt; 的容器：</target>
        </trans-unit>
        <trans-unit id="2124a458e14880a140fd9d2f4cfa3b4d4cdf3eb7" translate="yes" xml:space="preserve">
          <source>The following example set memory reservation to 1G without a hard memory limit.</source>
          <target state="translated">下面的例子将内存预留设置为1G,没有硬性内存限制。</target>
        </trans-unit>
        <trans-unit id="db08df032a2de4d6f23e749dae8e6565966b669b" translate="yes" xml:space="preserve">
          <source>The following example sets a preference to spread the deployment across nodes based on the value of the &lt;code&gt;datacenter&lt;/code&gt; label. If some nodes have &lt;code&gt;datacenter=us-east&lt;/code&gt; and others have &lt;code&gt;datacenter=us-west&lt;/code&gt;, the service is deployed as evenly as possible across the two sets of nodes.</source>
          <target state="translated">以下示例根据 &lt;code&gt;datacenter&lt;/code&gt; 标签的值设置首选项以在节点之间分布部署。如果某些节点具有 &lt;code&gt;datacenter=us-east&lt;/code&gt; ,而其他节点具有datacenter = us- &lt;code&gt;datacenter=us-west&lt;/code&gt; ，则将服务尽可能均匀地部署在两组节点之间。</target>
        </trans-unit>
        <trans-unit id="8230dd1220dd706cf8566dbee10e4dc1ad1c9d4a" translate="yes" xml:space="preserve">
          <source>The following example sets name of the &lt;code&gt;my_secret&lt;/code&gt; to &lt;code&gt;redis_secret&lt;/code&gt; within the container, sets the mode to &lt;code&gt;0440&lt;/code&gt; (group-readable) and sets the user and group to &lt;code&gt;103&lt;/code&gt;. The &lt;code&gt;redis&lt;/code&gt; service does not have access to the &lt;code&gt;my_other_secret&lt;/code&gt; secret.</source>
          <target state="translated">以下示例在容器内将 &lt;code&gt;my_secret&lt;/code&gt; 的名称设置为 &lt;code&gt;redis_secret&lt;/code&gt; ，将模式设置为 &lt;code&gt;0440&lt;/code&gt; （组可读取），并将用户和组设置为 &lt;code&gt;103&lt;/code&gt; 。在 &lt;code&gt;redis&lt;/code&gt; 服务没有访问 &lt;code&gt;my_other_secret&lt;/code&gt; 秘密。</target>
        </trans-unit>
        <trans-unit id="1e0837645e3fcc573d29accac038d64c469ddaf8" translate="yes" xml:space="preserve">
          <source>The following example sets the name of &lt;code&gt;my_config&lt;/code&gt; to &lt;code&gt;redis_config&lt;/code&gt; within the container, sets the mode to &lt;code&gt;0440&lt;/code&gt; (group-readable) and sets the user and group to &lt;code&gt;103&lt;/code&gt;. The &lt;code&gt;redis&lt;/code&gt; service does not have access to the &lt;code&gt;my_other_config&lt;/code&gt; config.</source>
          <target state="translated">以下示例在容器内将 &lt;code&gt;my_config&lt;/code&gt; 的名称设置为 &lt;code&gt;redis_config&lt;/code&gt; ，将模式设置为 &lt;code&gt;0440&lt;/code&gt; （组可读），并将用户和组设置为 &lt;code&gt;103&lt;/code&gt; 。在 &lt;code&gt;redis&lt;/code&gt; 服务没有访问 &lt;code&gt;my_other_config&lt;/code&gt; 配置。</target>
        </trans-unit>
        <trans-unit id="e6c9ffb891e37aec1140f9e04c47f3d25c956b59" translate="yes" xml:space="preserve">
          <source>The following example sets up a service with multiple placement preferences. Tasks are spread first over the various datacenters, and then over racks (as indicated by the respective labels):</source>
          <target state="translated">下面的例子设置了一个具有多种放置偏好的服务。任务首先分布在各个数据中心,然后分布在机架上(如各自的标签所示)。</target>
        </trans-unit>
        <trans-unit id="ddc395cc2f65ffce110b409fbfb09d97f9609f3a" translate="yes" xml:space="preserve">
          <source>The following example shows how to create a sample &lt;code&gt;plugin&lt;/code&gt;.</source>
          <target state="translated">以下示例显示了如何创建示例 &lt;code&gt;plugin&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7ae3957799f337692f9bc9b28a6e2e2c634ffcc0" translate="yes" xml:space="preserve">
          <source>The following example shows how to push a sample &lt;code&gt;user/plugin&lt;/code&gt;.</source>
          <target state="translated">以下示例显示了如何推送示例 &lt;code&gt;user/plugin&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f81ed1c286e21dc1188ff9a6fb0987668305135a" translate="yes" xml:space="preserve">
          <source>The following example shows that the &lt;code&gt;sample-volume-plugin&lt;/code&gt; plugin is installed and enabled:</source>
          <target state="translated">以下示例显示已安装并启用了 &lt;code&gt;sample-volume-plugin&lt;/code&gt; 插件：</target>
        </trans-unit>
        <trans-unit id="5852f4e870d19346460239d94051ab30d075af83" translate="yes" xml:space="preserve">
          <source>The following example shows that the &lt;code&gt;sample-volume-plugin&lt;/code&gt; plugin is installed, but disabled:</source>
          <target state="translated">以下示例显示了 &lt;code&gt;sample-volume-plugin&lt;/code&gt; 插件已安装但已禁用：</target>
        </trans-unit>
        <trans-unit id="884f0bedd2eaaa130232ed33769aceea522058d0" translate="yes" xml:space="preserve">
          <source>The following example updates the number of replicas for the service from 4 to 5, and then rolls back to the previous configuration.</source>
          <target state="translated">以下示例将服务的副本数量从 4 更新为 5,然后回滚到之前的配置。</target>
        </trans-unit>
        <trans-unit id="99a95c61d8e93bc7cab02ddeaaf85dc7ad465b73" translate="yes" xml:space="preserve">
          <source>The following example uses a template without headers and outputs the &lt;code&gt;Container&lt;/code&gt; and &lt;code&gt;CPUPerc&lt;/code&gt; entries separated by a colon for all images:</source>
          <target state="translated">以下示例使用不带标题的模板，并为所有图像输出用冒号分隔的 &lt;code&gt;Container&lt;/code&gt; 和 &lt;code&gt;CPUPerc&lt;/code&gt; 条目：</target>
        </trans-unit>
        <trans-unit id="2a792120d0b9a1a451b8375e49426da3fb636d7a" translate="yes" xml:space="preserve">
          <source>The following example uses a template without headers and outputs the &lt;code&gt;ID&lt;/code&gt; and &lt;code&gt;Command&lt;/code&gt; entries separated by a colon for all running containers:</source>
          <target state="translated">以下示例使用不带标题的模板，并为所有正在运行的容器输出 &lt;code&gt;ID&lt;/code&gt; 和 &lt;code&gt;Command&lt;/code&gt; 条目，并用冒号分隔：</target>
        </trans-unit>
        <trans-unit id="c34a9ca7aa8333d80688cb47f375496e30fb62a3" translate="yes" xml:space="preserve">
          <source>The following example uses a template without headers and outputs the &lt;code&gt;ID&lt;/code&gt; and &lt;code&gt;CreatedSince&lt;/code&gt; entries separated by a colon for the &lt;code&gt;busybox&lt;/code&gt; image:</source>
          <target state="translated">下面的示例使用的模板没有报头，并输出 &lt;code&gt;ID&lt;/code&gt; 和 &lt;code&gt;CreatedSince&lt;/code&gt; 条目分离由用于冒号 &lt;code&gt;busybox&lt;/code&gt; 的图像：</target>
        </trans-unit>
        <trans-unit id="9053190ef7a8482789c99b20dbfb533dfc395e2b" translate="yes" xml:space="preserve">
          <source>The following example uses a template without headers and outputs the &lt;code&gt;ID&lt;/code&gt; and &lt;code&gt;Driver&lt;/code&gt; entries separated by a colon for all networks:</source>
          <target state="translated">以下示例使用不带标题的模板，并为所有网络输出用冒号分隔的 &lt;code&gt;ID&lt;/code&gt; 和 &lt;code&gt;Driver&lt;/code&gt; 条目：</target>
        </trans-unit>
        <trans-unit id="0d3c21214705e5d6c9f771dca55ab75a5d739cda" translate="yes" xml:space="preserve">
          <source>The following example uses a template without headers and outputs the &lt;code&gt;ID&lt;/code&gt; and &lt;code&gt;Name&lt;/code&gt; entries separated by a colon for all images:</source>
          <target state="translated">以下示例使用没有标题的模板，并为所有图像输出用冒号分隔的 &lt;code&gt;ID&lt;/code&gt; 和 &lt;code&gt;Name&lt;/code&gt; 条目：</target>
        </trans-unit>
        <trans-unit id="a79d89630514bb61b7a4ec4ec9fdc9ffefd497f7" translate="yes" xml:space="preserve">
          <source>The following example uses a template without headers and outputs the &lt;code&gt;ID&lt;/code&gt; and &lt;code&gt;Name&lt;/code&gt; entries separated by a colon for all plugins:</source>
          <target state="translated">以下示例使用没有标题的模板，并为所有插件输出以冒号分隔的 &lt;code&gt;ID&lt;/code&gt; 和 &lt;code&gt;Name&lt;/code&gt; 条目：</target>
        </trans-unit>
        <trans-unit id="804de291801d65c46987d10d9722e8e1597a61c7" translate="yes" xml:space="preserve">
          <source>The following example uses a template without headers and outputs the &lt;code&gt;ID&lt;/code&gt; and &lt;code&gt;Repository&lt;/code&gt; entries separated by a colon for all images:</source>
          <target state="translated">以下示例使用不带标题的模板，并为所有图像输出用冒号分隔的 &lt;code&gt;ID&lt;/code&gt; 和 &lt;code&gt;Repository&lt;/code&gt; 条目：</target>
        </trans-unit>
        <trans-unit id="4f0930ce338dadf5495c9cc22ea15ee538bd074c" translate="yes" xml:space="preserve">
          <source>The following example uses a template without headers and outputs the &lt;code&gt;ID&lt;/code&gt;, &lt;code&gt;Hostname&lt;/code&gt;, and &lt;code&gt;TLS Status&lt;/code&gt; entries separated by a colon for all nodes:</source>
          <target state="translated">以下示例使用不带标题的模板，并输出 &lt;code&gt;ID&lt;/code&gt; ， &lt;code&gt;Hostname&lt;/code&gt; 和 &lt;code&gt;TLS Status&lt;/code&gt; 条目，并用冒号分隔所有节点：</target>
        </trans-unit>
        <trans-unit id="f139db89194cb2e0f5218bff4781bbaf174f7a38" translate="yes" xml:space="preserve">
          <source>The following example uses a template without headers and outputs the &lt;code&gt;ID&lt;/code&gt;, &lt;code&gt;Mode&lt;/code&gt;, and &lt;code&gt;Replicas&lt;/code&gt; entries separated by a colon for all services:</source>
          <target state="translated">以下示例使用不带标题的模板，并为所有服务输出以冒号分隔的 &lt;code&gt;ID&lt;/code&gt; ， &lt;code&gt;Mode&lt;/code&gt; 和 &lt;code&gt;Replicas&lt;/code&gt; 条目：</target>
        </trans-unit>
        <trans-unit id="b8665cdaa79b1fbb23875fb4872bb3265da68042" translate="yes" xml:space="preserve">
          <source>The following example uses a template without headers and outputs the &lt;code&gt;Name&lt;/code&gt; and &lt;code&gt;Driver&lt;/code&gt; entries separated by a colon for all running machines:</source>
          <target state="translated">以下示例使用不带标题的模板，并为所有正在运行的计算机输出 &lt;code&gt;Name&lt;/code&gt; 和 &lt;code&gt;Driver&lt;/code&gt; 条目，并用冒号分隔：</target>
        </trans-unit>
        <trans-unit id="72fecd4b8a0d3a98296aa22d178ffd98c1a2ed29" translate="yes" xml:space="preserve">
          <source>The following example uses a template without headers and outputs the &lt;code&gt;Name&lt;/code&gt; and &lt;code&gt;Driver&lt;/code&gt; entries separated by a colon for all volumes:</source>
          <target state="translated">以下示例使用不带标题的模板，并为所有卷输出用冒号分隔的 &lt;code&gt;Name&lt;/code&gt; 和 &lt;code&gt;Driver&lt;/code&gt; 条目：</target>
        </trans-unit>
        <trans-unit id="eedefcafa867fc51893471b85cafbed225dd74ee" translate="yes" xml:space="preserve">
          <source>The following example uses a template without headers and outputs the &lt;code&gt;Name&lt;/code&gt; and &lt;code&gt;Image&lt;/code&gt; entries separated by a colon for all tasks:</source>
          <target state="translated">以下示例使用没有标题的模板，并为所有任务输出用冒号分隔的 &lt;code&gt;Name&lt;/code&gt; 和 &lt;code&gt;Image&lt;/code&gt; 条目：</target>
        </trans-unit>
        <trans-unit id="a607ab10c65e128911094483d04501824e7a3c19" translate="yes" xml:space="preserve">
          <source>The following example uses a template without headers and outputs the &lt;code&gt;Name&lt;/code&gt; and &lt;code&gt;Services&lt;/code&gt; entries separated by a colon for all stacks:</source>
          <target state="translated">以下示例使用不带标题的模板，并为所有堆栈输出用冒号分隔的 &lt;code&gt;Name&lt;/code&gt; 和 &lt;code&gt;Services&lt;/code&gt; 条目：</target>
        </trans-unit>
        <trans-unit id="27840da3b3c26b130c2393ce1a25742a883dfebd" translate="yes" xml:space="preserve">
          <source>The following example uses a template without headers and outputs the &lt;code&gt;Name&lt;/code&gt; and &lt;code&gt;StarCount&lt;/code&gt; entries separated by a colon for all images:</source>
          <target state="translated">以下示例使用不带标题的模板，并为所有图像输出用冒号分隔的 &lt;code&gt;Name&lt;/code&gt; 和 &lt;code&gt;StarCount&lt;/code&gt; 条目：</target>
        </trans-unit>
        <trans-unit id="5097e4e285bcb4f61bbb1c5261ad561df449bf75" translate="yes" xml:space="preserve">
          <source>The following example uses the short syntax to grant the &lt;code&gt;redis&lt;/code&gt; service access to the &lt;code&gt;my_config&lt;/code&gt; and &lt;code&gt;my_other_config&lt;/code&gt; configs. The value of &lt;code&gt;my_config&lt;/code&gt; is set to the contents of the file &lt;code&gt;./my_config.txt&lt;/code&gt;, and &lt;code&gt;my_other_config&lt;/code&gt; is defined as an external resource, which means that it has already been defined in Docker, either by running the &lt;code&gt;docker config create&lt;/code&gt; command or by another stack deployment. If the external config does not exist, the stack deployment fails with a &lt;code&gt;config not found&lt;/code&gt; error.</source>
          <target state="translated">以下示例使用 &lt;code&gt;my_config&lt;/code&gt; 向 &lt;code&gt;redis&lt;/code&gt; 服务授予对my_config和 &lt;code&gt;my_other_config&lt;/code&gt; 配置的访问权限。 &lt;code&gt;my_config&lt;/code&gt; 的值设置为文件 &lt;code&gt;./my_config.txt&lt;/code&gt; 的内容，并且 &lt;code&gt;my_other_config&lt;/code&gt; 定义为外部资源，这意味着它已经在Docker中定义，可以通过运行 &lt;code&gt;docker config create&lt;/code&gt; 命令或其他堆栈进行定义部署。如果外部配置不存在，则堆栈部署将失败， &lt;code&gt;config not found&lt;/code&gt; 错误。</target>
        </trans-unit>
        <trans-unit id="edbdc0dd7768c9a4ffab0a305de18d34860216cf" translate="yes" xml:space="preserve">
          <source>The following example uses the short syntax to grant the &lt;code&gt;redis&lt;/code&gt; service access to the &lt;code&gt;my_secret&lt;/code&gt; and &lt;code&gt;my_other_secret&lt;/code&gt; secrets. The value of &lt;code&gt;my_secret&lt;/code&gt; is set to the contents of the file &lt;code&gt;./my_secret.txt&lt;/code&gt;, and &lt;code&gt;my_other_secret&lt;/code&gt; is defined as an external resource, which means that it has already been defined in Docker, either by running the &lt;code&gt;docker secret create&lt;/code&gt; command or by another stack deployment. If the external secret does not exist, the stack deployment fails with a &lt;code&gt;secret not found&lt;/code&gt; error.</source>
          <target state="translated">以下示例使用 &lt;code&gt;my_secret&lt;/code&gt; 向 &lt;code&gt;redis&lt;/code&gt; 服务授予对my_secret和 &lt;code&gt;my_other_secret&lt;/code&gt; 机密的访问权限。 &lt;code&gt;my_secret&lt;/code&gt; 的值设置为文件 &lt;code&gt;./my_secret.txt&lt;/code&gt; 的内容，并且 &lt;code&gt;my_other_secret&lt;/code&gt; 定义为外部资源，这意味着它已经在Docker中定义，可以通过运行 &lt;code&gt;docker secret create&lt;/code&gt; 命令或其他堆栈来定义。部署。如果外部机密不存在，则堆栈部署将失败，并显示&amp;ldquo; &lt;code&gt;secret not found&lt;/code&gt; 错误。</target>
        </trans-unit>
        <trans-unit id="700f7f72c505a0cd991e4670f83883bf1ce0e178" translate="yes" xml:space="preserve">
          <source>The following example, illustrates a dangerous way to use the flag:</source>
          <target state="translated">下面的例子,说明了使用旗帜的危险方式。</target>
        </trans-unit>
        <trans-unit id="89c0412b4e8637f46684214f9bcf2b4a30f4e274" translate="yes" xml:space="preserve">
          <source>The following examples show bind mount syntax:</source>
          <target state="translated">下面的例子显示了绑定挂载的语法。</target>
        </trans-unit>
        <trans-unit id="1e7cc6f5f98f421cfe718405a306f6462cbf3f4c" translate="yes" xml:space="preserve">
          <source>The following examples will fail when using Windows-based containers, as the destination of a volume or bind mount inside the container must be one of: a non-existing or empty directory; or a drive other than C:. Further, the source of a bind mount must be a local directory, not a file.</source>
          <target state="translated">当使用基于 Windows 的容器时,以下示例将失败,因为容器内的卷或绑定挂载的目标必须是以下之一:不存在或空的目录;或 C:以外的驱动器。此外,绑定挂载的源必须是本地目录,而不是文件。</target>
        </trans-unit>
        <trans-unit id="7f19f64e11cd93069667bbfd55960c6a2ddbbdd1" translate="yes" xml:space="preserve">
          <source>The following filter matches all containers that are connected to a network with a name containing &lt;code&gt;net1&lt;/code&gt;.</source>
          <target state="translated">以下过滤器匹配名称为 &lt;code&gt;net1&lt;/code&gt; 的所有连接到网络的容器。</target>
        </trans-unit>
        <trans-unit id="800e886868cfa732f164d0182de8422c8e649e13" translate="yes" xml:space="preserve">
          <source>The following filter matches all containers that have exposed TCP port in the range of &lt;code&gt;8000-8080&lt;/code&gt;:</source>
          <target state="translated">以下过滤器匹配所有暴露了 &lt;code&gt;8000-8080&lt;/code&gt; 范围内的TCP端口的容器：</target>
        </trans-unit>
        <trans-unit id="07ea30f7ec788e0e5ca1c99051771631a91c5e82" translate="yes" xml:space="preserve">
          <source>The following filter matches all containers that have exposed UDP port &lt;code&gt;80&lt;/code&gt;:</source>
          <target state="translated">以下过滤器匹配暴露了UDP端口 &lt;code&gt;80&lt;/code&gt; 的所有容器：</target>
        </trans-unit>
        <trans-unit id="15fd706a88462118bd357b932c54f13e0615f52c" translate="yes" xml:space="preserve">
          <source>The following filter matches all containers that have published port of 80:</source>
          <target state="translated">下面的过滤器匹配所有发布端口为80的容器。</target>
        </trans-unit>
        <trans-unit id="1e4d3cb6490f16b07bc00af218867d1488effaf6" translate="yes" xml:space="preserve">
          <source>The following filter matches all containers with a name containing the &lt;code&gt;nostalgic_stallman&lt;/code&gt; string.</source>
          <target state="translated">以下过滤器将所有包含名称包含 &lt;code&gt;nostalgic_stallman&lt;/code&gt; 字符串的容器进行匹配。</target>
        </trans-unit>
        <trans-unit id="25cb2d40a8b8244e76b46bc97aff980f8b372f1a" translate="yes" xml:space="preserve">
          <source>The following filter matches all networks with a name containing the &lt;code&gt;foobar&lt;/code&gt; string.</source>
          <target state="translated">以下过滤器将匹配名称包含 &lt;code&gt;foobar&lt;/code&gt; 字符串的所有网络。</target>
        </trans-unit>
        <trans-unit id="74560278c6c44f13fcb3eaaf5e9b566f270ef9d7" translate="yes" xml:space="preserve">
          <source>The following filter matches all networks with an ID containing the &lt;code&gt;63d1ff1f77b0...&lt;/code&gt; string.</source>
          <target state="translated">以下过滤器将匹配ID包含 &lt;code&gt;63d1ff1f77b0...&lt;/code&gt; 字符串的所有网络。</target>
        </trans-unit>
        <trans-unit id="b664a6dc08d148cd14a3d5a10883f3f6253a5b12" translate="yes" xml:space="preserve">
          <source>The following filter matches all secrets with a &lt;code&gt;project&lt;/code&gt; label regardless of its value:</source>
          <target state="translated">以下过滤器将所有秘密与 &lt;code&gt;project&lt;/code&gt; 标签匹配，无论其值如何：</target>
        </trans-unit>
        <trans-unit id="6bf325e14afdfeb070566c7cb8408f19be850830" translate="yes" xml:space="preserve">
          <source>The following filter matches all services with a &lt;code&gt;project&lt;/code&gt; label regardless of its value:</source>
          <target state="translated">以下过滤器将所有服务与 &lt;code&gt;project&lt;/code&gt; 标签匹配，无论其值如何：</target>
        </trans-unit>
        <trans-unit id="377c5cebf1a800ec740bab4e255ece52bcd5502c" translate="yes" xml:space="preserve">
          <source>The following filter matches all tasks with a name containing the &lt;code&gt;redis&lt;/code&gt; string.</source>
          <target state="translated">以下过滤器将所有任务与名称包含 &lt;code&gt;redis&lt;/code&gt; 字符串的匹配。</target>
        </trans-unit>
        <trans-unit id="f6adbe9e7302ddb4e65fe46ef26fc7737fa9efc6" translate="yes" xml:space="preserve">
          <source>The following filter matches all user defined networks:</source>
          <target state="translated">以下过滤器匹配所有用户定义的网络。</target>
        </trans-unit>
        <trans-unit id="e0e789cbca67054d34bb67e75d18c65067c0090f" translate="yes" xml:space="preserve">
          <source>The following filter matches all volumes with a name containing the &lt;code&gt;rose&lt;/code&gt; string.</source>
          <target state="translated">以下过滤器将所有卷与包含 &lt;code&gt;rose&lt;/code&gt; 字符串的名称匹配。</target>
        </trans-unit>
        <trans-unit id="333929673e07bb3910786d16dc8890e7af897ae5" translate="yes" xml:space="preserve">
          <source>The following filter matches containers with the &lt;code&gt;color&lt;/code&gt; label regardless of its value.</source>
          <target state="translated">以下过滤器将容器与 &lt;code&gt;color&lt;/code&gt; 标签匹配，无论其值如何。</target>
        </trans-unit>
        <trans-unit id="287065c5f990a604ba29bf8f28ec863ce71f474a" translate="yes" xml:space="preserve">
          <source>The following filter matches containers with the &lt;code&gt;color&lt;/code&gt; label with the &lt;code&gt;blue&lt;/code&gt; value.</source>
          <target state="translated">以下过滤器将容器与带有 &lt;code&gt;blue&lt;/code&gt; 值的 &lt;code&gt;color&lt;/code&gt; 标签匹配。</target>
        </trans-unit>
        <trans-unit id="a55d9b8aa17bf7ea4bcc95ca05e971410dd1c999" translate="yes" xml:space="preserve">
          <source>The following filter matches images with the &lt;code&gt;com.example.version&lt;/code&gt; label regardless of its value.</source>
          <target state="translated">以下过滤器将匹配带有 &lt;code&gt;com.example.version&lt;/code&gt; 标签的图像，而不管其值如何。</target>
        </trans-unit>
        <trans-unit id="9308f1b2567a263989225a707e87d9f43669990b" translate="yes" xml:space="preserve">
          <source>The following filter matches images with the &lt;code&gt;com.example.version&lt;/code&gt; label with the &lt;code&gt;1.0&lt;/code&gt; value.</source>
          <target state="translated">以下过滤器将 &lt;code&gt;com.example.version&lt;/code&gt; 标签与 &lt;code&gt;1.0&lt;/code&gt; 值的图像进行匹配。</target>
        </trans-unit>
        <trans-unit id="81c15752312e03a6c5a55cd6e5284d7d5de8e547" translate="yes" xml:space="preserve">
          <source>The following filter matches networks with the &lt;code&gt;usage&lt;/code&gt; label regardless of its value.</source>
          <target state="translated">以下过滤器将网络与 &lt;code&gt;usage&lt;/code&gt; 标签进行匹配，无论其值如何。</target>
        </trans-unit>
        <trans-unit id="342327877e58e3c8eafe26ccb4de7e7111b5b529" translate="yes" xml:space="preserve">
          <source>The following filter matches networks with the &lt;code&gt;usage&lt;/code&gt; label with the &lt;code&gt;prod&lt;/code&gt; value.</source>
          <target state="translated">以下过滤器将网络与 &lt;code&gt;usage&lt;/code&gt; 标签和 &lt;code&gt;prod&lt;/code&gt; 值匹配。</target>
        </trans-unit>
        <trans-unit id="1bfe9f9a5aba90f02fb92c52e07d997aad516d99" translate="yes" xml:space="preserve">
          <source>The following filter matches nodes with the &lt;code&gt;foo&lt;/code&gt; label regardless of its value.</source>
          <target state="translated">以下过滤器将匹配带有 &lt;code&gt;foo&lt;/code&gt; 标签的节点，而不管其值如何。</target>
        </trans-unit>
        <trans-unit id="831f1c4b12005720b96b4a2eca523b0715c5f7cf" translate="yes" xml:space="preserve">
          <source>The following filter matches nodes with the &lt;code&gt;manager&lt;/code&gt; role.</source>
          <target state="translated">以下过滤器将节点与 &lt;code&gt;manager&lt;/code&gt; 角色进行匹配。</target>
        </trans-unit>
        <trans-unit id="5d5928dc77f9ac8f51a5bf3a491007d5cb959aa9" translate="yes" xml:space="preserve">
          <source>The following filter matches nodes with the &lt;code&gt;membership&lt;/code&gt; of &lt;code&gt;accepted&lt;/code&gt;.</source>
          <target state="translated">以下过滤器将节点与 &lt;code&gt;accepted&lt;/code&gt; 的 &lt;code&gt;membership&lt;/code&gt; 进行匹配。</target>
        </trans-unit>
        <trans-unit id="cae334a9403125be8e105d77b121e928b810cb0d" translate="yes" xml:space="preserve">
          <source>The following filter matches only &lt;code&gt;global&lt;/code&gt; services.</source>
          <target state="translated">以下过滤器仅匹配 &lt;code&gt;global&lt;/code&gt; 服务。</target>
        </trans-unit>
        <trans-unit id="71b96abf9c912452dccc5fc2d078ff7d724074bf" translate="yes" xml:space="preserve">
          <source>The following filter matches only services with the &lt;code&gt;project&lt;/code&gt; label with the &lt;code&gt;project-a&lt;/code&gt; value.</source>
          <target state="translated">以下过滤器仅匹配带有 &lt;code&gt;project-a&lt;/code&gt; 值的 &lt;code&gt;project&lt;/code&gt; 标签的服务。</target>
        </trans-unit>
        <trans-unit id="d589708b36e77b120b1eb37f5b3855633a489266" translate="yes" xml:space="preserve">
          <source>The following filter matches secret with a name containing a prefix of &lt;code&gt;test&lt;/code&gt;.</source>
          <target state="translated">以下过滤器将secret与包含 &lt;code&gt;test&lt;/code&gt; 前缀的名称进行匹配。</target>
        </trans-unit>
        <trans-unit id="51f41d32e59f1be3db1713960110b6924fa71193" translate="yes" xml:space="preserve">
          <source>The following filter matches services with a name containing &lt;code&gt;redis&lt;/code&gt;.</source>
          <target state="translated">以下过滤器将匹配名称为 &lt;code&gt;redis&lt;/code&gt; 的服务。</target>
        </trans-unit>
        <trans-unit id="d06c94f037f10c7f3edd2ff9c61b81881e819a03" translate="yes" xml:space="preserve">
          <source>The following filter matches tasks with the &lt;code&gt;usage&lt;/code&gt; label regardless of its value.</source>
          <target state="translated">以下过滤器将任务与 &lt;code&gt;usage&lt;/code&gt; 标签匹配，无论其值如何。</target>
        </trans-unit>
        <trans-unit id="af809a75960cb0ab861cb2b30735a0d65c64aa88" translate="yes" xml:space="preserve">
          <source>The following filter matches the nodes with a name equal to &lt;code&gt;swarm-master&lt;/code&gt; string.</source>
          <target state="translated">以下过滤器匹配名称等于 &lt;code&gt;swarm-master&lt;/code&gt; 字符串的节点。</target>
        </trans-unit>
        <trans-unit id="2791d823738fc796e3aff5cac56fe1c0dc58c276" translate="yes" xml:space="preserve">
          <source>The following flags are supported:</source>
          <target state="translated">支持以下标志:</target>
        </trans-unit>
        <trans-unit id="1ba2ceab8147a44173e52004a7d49f0cf956ab1a" translate="yes" xml:space="preserve">
          <source>The following illustrates a configuration with custom certificates:</source>
          <target state="translated">以下是一个使用自定义证书的配置示例。</target>
        </trans-unit>
        <trans-unit id="cdd40803f742cb5b009b755a1dfe76bf10cfc698" translate="yes" xml:space="preserve">
          <source>The following image depicts the various signing keys and their relationships:</source>
          <target state="translated">下图描述了各种签名密钥及其关系。</target>
        </trans-unit>
        <trans-unit id="352e506ead5abd1cae6bbdfa70483c6c355b9774" translate="yes" xml:space="preserve">
          <source>The following instructions can be affected by the &lt;code&gt;SHELL&lt;/code&gt; instruction when the &lt;em&gt;shell&lt;/em&gt; form of them is used in a Dockerfile: &lt;code&gt;RUN&lt;/code&gt;, &lt;code&gt;CMD&lt;/code&gt; and &lt;code&gt;ENTRYPOINT&lt;/code&gt;.</source>
          <target state="translated">在Dockerfile中使用它们的&lt;em&gt;外壳&lt;/em&gt;形式时，以下指令可能会受到 &lt;code&gt;SHELL&lt;/code&gt; 指令的影响： &lt;code&gt;RUN&lt;/code&gt; ， &lt;code&gt;CMD&lt;/code&gt; 和 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1530583c09c98f904de912a6701d7304d51b5c33" translate="yes" xml:space="preserve">
          <source>The following is an example adding 2 runtimes via the configuration:</source>
          <target state="translated">下面是一个通过配置增加2个运行时的例子。</target>
        </trans-unit>
        <trans-unit id="90af25db82c012aee8c9941342b7fd06be7e8128" translate="yes" xml:space="preserve">
          <source>The following is an example of docker build with &lt;code&gt;--squash&lt;/code&gt; argument</source>
          <target state="translated">以下是使用 &lt;code&gt;--squash&lt;/code&gt; 参数的Docker构建示例</target>
        </trans-unit>
        <trans-unit id="ddd205b6626f4c3147db765c896821f29986b142" translate="yes" xml:space="preserve">
          <source>The following is an example usage:</source>
          <target state="translated">以下是一个使用实例。</target>
        </trans-unit>
        <trans-unit id="679caa8ac3b309f79951e6369db67f2ba236eef1" translate="yes" xml:space="preserve">
          <source>The following list of features are deprecated in Engine. To learn more about Docker Engine&amp;rsquo;s deprecation policy, see &lt;a href=&quot;../index#feature-deprecation-policy&quot;&gt;Feature Deprecation Policy&lt;/a&gt;.</source>
          <target state="translated">以下功能列表在Engine中已弃用。要了解有关Docker Engine的弃用策略的更多信息，请参阅&lt;a href=&quot;../index#feature-deprecation-policy&quot;&gt;Feature Deprecation Policy&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="64c0fd6330bb4fe27c1e99d4cbe6591be24268cc" translate="yes" xml:space="preserve">
          <source>The following matches containers based on the layer &lt;code&gt;d0e008c6cf02&lt;/code&gt; or an image that have this layer in its layer stack.</source>
          <target state="translated">以下内容基于层 &lt;code&gt;d0e008c6cf02&lt;/code&gt; 或在其层堆栈中具有该层的图像来匹配容器。</target>
        </trans-unit>
        <trans-unit id="bd05d4ce6012ea3e96f3277ce3e558e06a24423a" translate="yes" xml:space="preserve">
          <source>The following options can only be used for bind mounts (&lt;code&gt;type=bind&lt;/code&gt;):</source>
          <target state="translated">以下选项只能用于绑定安装（ &lt;code&gt;type=bind&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="cea3dc98beed9105761d1cfaaea9c4b21e0e47cf" translate="yes" xml:space="preserve">
          <source>The following options can only be used for named volumes (&lt;code&gt;type=volume&lt;/code&gt;):</source>
          <target state="translated">以下选项只能用于命名卷（ &lt;code&gt;type=volume&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="39bd07dcb7784b47d42d9d00b3b6828077c80e7a" translate="yes" xml:space="preserve">
          <source>The following options can only be used for tmpfs mounts (&lt;code&gt;type=tmpfs&lt;/code&gt;);</source>
          <target state="translated">以下选项仅可用于tmpfs挂载（ &lt;code&gt;type=tmpfs&lt;/code&gt; ）;</target>
        </trans-unit>
        <trans-unit id="fd1b04f078db2f9a2a6553fdded57f5727f9750d" translate="yes" xml:space="preserve">
          <source>The following pages describe the usage information for the &lt;a href=&quot;overview/index&quot;&gt;docker-compose&lt;/a&gt; subcommands. You can also see this information by running &lt;code&gt;docker-compose [SUBCOMMAND] --help&lt;/code&gt; from the command line.</source>
          <target state="translated">以下页面描述了&lt;a href=&quot;overview/index&quot;&gt;docker-compose&lt;/a&gt;子命令的用法信息。您还可以通过 &lt;code&gt;docker-compose [SUBCOMMAND] --help&lt;/code&gt; 运行docker-compose [SUBCOMMAND] --help来查看此信息。</target>
        </trans-unit>
        <trans-unit id="dc364422c59019db7e4caaa1bcce2d190b0a4ced" translate="yes" xml:space="preserve">
          <source>The following parser directives are supported:</source>
          <target state="translated">支持以下解析器指令。</target>
        </trans-unit>
        <trans-unit id="ee1ca432f62944696342ff92fbc385c17290cb85" translate="yes" xml:space="preserve">
          <source>The following ports must be available. On some systems, these ports are open by default.</source>
          <target state="translated">以下端口必须是可用的。在某些系统中,这些端口默认是开放的。</target>
        </trans-unit>
        <trans-unit id="5a06f0ecc09621b84e84a7621d8f9b7b0ea89d01" translate="yes" xml:space="preserve">
          <source>The following removes containers created before &lt;code&gt;2017-01-04T13:10:00&lt;/code&gt;:</source>
          <target state="translated">以下内容将删除在 &lt;code&gt;2017-01-04T13:10:00&lt;/code&gt; 之前创建的容器：</target>
        </trans-unit>
        <trans-unit id="a5383a9d9670f9fdcac5ef218e29b45584acf08d" translate="yes" xml:space="preserve">
          <source>The following removes containers created more than 5 minutes ago:</source>
          <target state="translated">以下是删除5分钟前创建的容器。</target>
        </trans-unit>
        <trans-unit id="202bf18e4819e0fe8e3548e75a0fa6fea50dae22" translate="yes" xml:space="preserve">
          <source>The following removes images created before &lt;code&gt;2017-01-04T00:00:00&lt;/code&gt;:</source>
          <target state="translated">以下内容将删除在 &lt;code&gt;2017-01-04T00:00:00&lt;/code&gt; 之前创建的图像：</target>
        </trans-unit>
        <trans-unit id="01bf49080ffa5c29f8ac4d7b93c3575d2fc4a323" translate="yes" xml:space="preserve">
          <source>The following removes images created more than 10 days (&lt;code&gt;240h&lt;/code&gt;) ago:</source>
          <target state="translated">以下内容将删除创建超过10天（ &lt;code&gt;240h&lt;/code&gt; ）之前的图像：</target>
        </trans-unit>
        <trans-unit id="d46d20f52659f2d385980b8dc19d20edf5adca1a" translate="yes" xml:space="preserve">
          <source>The following removes networks created more than 5 minutes ago. Note that system networks such as &lt;code&gt;bridge&lt;/code&gt;, &lt;code&gt;host&lt;/code&gt;, and &lt;code&gt;none&lt;/code&gt; will never be pruned:</source>
          <target state="translated">以下内容将删除5分钟前创建的网络。注意，诸如 &lt;code&gt;bridge&lt;/code&gt; ， &lt;code&gt;host&lt;/code&gt; 和 &lt;code&gt;none&lt;/code&gt; 之类的系统网络将永远不会被修剪：</target>
        </trans-unit>
        <trans-unit id="b7021eb31e260a4ca6fc6f6f26bc884d3533e40f" translate="yes" xml:space="preserve">
          <source>The following sections illustrate ways to use this command.</source>
          <target state="translated">下面的章节介绍了使用该命令的方法。</target>
        </trans-unit>
        <trans-unit id="afdb57289147fd04a4ba308a16d159524fbc3492" translate="yes" xml:space="preserve">
          <source>The following sections provide details about service configuration. This topic does not cover every flag or scenario. In almost every instance where you can define a configuration at service creation, you can also update an existing service&amp;rsquo;s configuration in a similar way.</source>
          <target state="translated">以下各节提供有关服务配置的详细信息。本主题并不涵盖所有标志或方案。在几乎每个可以在创建服务时定义配置的情况下，都可以以类似的方式更新现有服务的配置。</target>
        </trans-unit>
        <trans-unit id="edb72a975dadb1beb00c0c5a8ab9b701acb1be71" translate="yes" xml:space="preserve">
          <source>The following service&amp;rsquo;s containers have an environment variable &lt;code&gt;$MYVAR&lt;/code&gt; set to &lt;code&gt;myvalue&lt;/code&gt;, run from the &lt;code&gt;/tmp/&lt;/code&gt; directory, and run as the &lt;code&gt;my_user&lt;/code&gt; user.</source>
          <target state="translated">以下服务的容器的环境变量 &lt;code&gt;$MYVAR&lt;/code&gt; 设置为 &lt;code&gt;myvalue&lt;/code&gt; ，从 &lt;code&gt;/tmp/&lt;/code&gt; 目录运行，并以 &lt;code&gt;my_user&lt;/code&gt; 用户身份运行。</target>
        </trans-unit>
        <trans-unit id="0ab0d241a851d150a626e3f1ab1b7b1212496ed2" translate="yes" xml:space="preserve">
          <source>The following simple example retrieves the gMSA name and JSON contents from your Active Directory (AD) instance:</source>
          <target state="translated">下面的简单示例从您的活动目录(AD)实例中检索gMSA名称和JSON内容。</target>
        </trans-unit>
        <trans-unit id="38079e33d70456cc78ac6a52b32f01a2f427e7f7" translate="yes" xml:space="preserve">
          <source>The following single-dash (&lt;code&gt;-opt&lt;/code&gt;) variant of certain command line options are deprecated and replaced with double-dash options (&lt;code&gt;--opt&lt;/code&gt;):</source>
          <target state="translated">以下某些命令行选项的单破折号（ &lt;code&gt;--opt&lt;/code&gt; ）已弃用， &lt;code&gt;-opt&lt;/code&gt; 双破折号选项（--opt）代替：</target>
        </trans-unit>
        <trans-unit id="0a9d899e8a7c4ecbad3f9d3cdace6b7d2cb28d82" translate="yes" xml:space="preserve">
          <source>The following standard Docker features are incompatible with running a Docker daemon with user namespaces enabled:</source>
          <target state="translated">以下标准的Docker功能与启用用户命名空间的Docker守护进程的运行不兼容。</target>
        </trans-unit>
        <trans-unit id="ceab97b073bdd541ffd2040b147c10ea3c77a29f" translate="yes" xml:space="preserve">
          <source>The following sub-options (supported for &lt;code&gt;docker-compose up&lt;/code&gt; and &lt;code&gt;docker-compose run&lt;/code&gt;) are &lt;em&gt;not supported&lt;/em&gt; for &lt;code&gt;docker stack deploy&lt;/code&gt; or the &lt;code&gt;deploy&lt;/code&gt; key.</source>
          <target state="translated">下面的子选项（支持 &lt;code&gt;docker-compose up&lt;/code&gt; 和 &lt;code&gt;docker-compose run&lt;/code&gt; ）是&lt;em&gt;不支持&lt;/em&gt;的 &lt;code&gt;docker stack deploy&lt;/code&gt; 或 &lt;code&gt;deploy&lt;/code&gt; 的关键。</target>
        </trans-unit>
        <trans-unit id="a512515c3c3198b7df3ff59809648ff2c8837053" translate="yes" xml:space="preserve">
          <source>The following table describes options which apply to both bind mounts and named volumes in a service:</source>
          <target state="translated">下表描述了适用于服务中绑定挂载和命名卷的选项。</target>
        </trans-unit>
        <trans-unit id="97af8835fb1b0d42baf566cddbcbd484b22e0273" translate="yes" xml:space="preserve">
          <source>The following table represents all the valid suffixes with their build contexts:</source>
          <target state="translated">下表表示所有有效的后缀及其构建上下文。</target>
        </trans-unit>
        <trans-unit id="50973c531dcf0fca5d800927b2bb86570dc6d0d2" translate="yes" xml:space="preserve">
          <source>The following topics are available:</source>
          <target state="translated">有以下专题:</target>
        </trans-unit>
        <trans-unit id="c92203c1f68f879df757bddd6ad2f3fdfa59c581" translate="yes" xml:space="preserve">
          <source>The following values are accepted:</source>
          <target state="translated">可接受以下数值:</target>
        </trans-unit>
        <trans-unit id="d23ee3675fec03d4201ad5d2868adb69fbb5b7cc" translate="yes" xml:space="preserve">
          <source>The format of the command is:</source>
          <target state="translated">命令的格式是:</target>
        </trans-unit>
        <trans-unit id="0b9473095568a70fbc515fca5a0c0de6d7b7304b" translate="yes" xml:space="preserve">
          <source>The formatting option (&lt;code&gt;--format&lt;/code&gt;) pretty prints container output using a Go template.</source>
          <target state="translated">格式化选项（ &lt;code&gt;--format&lt;/code&gt; ）使用Go模板漂亮地打印容器输出。</target>
        </trans-unit>
        <trans-unit id="c90b205d5d057562cc93124ef1fb067815c006a8" translate="yes" xml:space="preserve">
          <source>The formatting option (&lt;code&gt;--format&lt;/code&gt;) pretty prints secrets output using a Go template.</source>
          <target state="translated">格式化选项（ &lt;code&gt;--format&lt;/code&gt; ）漂亮地打印使用Go模板输出的密码。</target>
        </trans-unit>
        <trans-unit id="1e5fb6599ab24fd4faffd8e8e434811f64c4a751" translate="yes" xml:space="preserve">
          <source>The formatting option (&lt;code&gt;--format&lt;/code&gt;) pretty-prints container output using a Go template.</source>
          <target state="translated">格式化选项（ &lt;code&gt;--format&lt;/code&gt; ）使用Go模板漂亮地打印容器输出。</target>
        </trans-unit>
        <trans-unit id="1e114329ca4f7454a532ed757c39d973cba22e9d" translate="yes" xml:space="preserve">
          <source>The formatting option (&lt;code&gt;--format&lt;/code&gt;) pretty-prints machines using a Go template.</source>
          <target state="translated">格式化选项（ &lt;code&gt;--format&lt;/code&gt; ）使用Go模板漂亮地打印机器。</target>
        </trans-unit>
        <trans-unit id="4cecb8823d0ae5d7ce668900da8f03c68d247526" translate="yes" xml:space="preserve">
          <source>The formatting option (&lt;code&gt;--format&lt;/code&gt;) pretty-prints search output using a Go template.</source>
          <target state="translated">格式化选项（ &lt;code&gt;--format&lt;/code&gt; ）使用Go模板漂亮地打印搜索输出。</target>
        </trans-unit>
        <trans-unit id="9a7c2de2b27bbeda9fbf4be2fff41c1c922774e7" translate="yes" xml:space="preserve">
          <source>The formatting option (&lt;code&gt;--format&lt;/code&gt;) pretty-prints stacks using a Go template.</source>
          <target state="translated">格式化选项（ &lt;code&gt;--format&lt;/code&gt; ）使用Go模板漂亮地打印堆栈。</target>
        </trans-unit>
        <trans-unit id="48e15b8c4939c370c3bb6974bca1dc0fcff7af41" translate="yes" xml:space="preserve">
          <source>The formatting option (&lt;code&gt;--format&lt;/code&gt;) will pretty print container output using a Go template.</source>
          <target state="translated">格式化选项（ &lt;code&gt;--format&lt;/code&gt; ）将使用Go模板漂亮地打印容器输出。</target>
        </trans-unit>
        <trans-unit id="6132c3a006eb8cedb324f2bffedcbf9e0fcc1405" translate="yes" xml:space="preserve">
          <source>The formatting option (&lt;code&gt;--format&lt;/code&gt;) will pretty-prints history output using a Go template.</source>
          <target state="translated">格式化选项（ &lt;code&gt;--format&lt;/code&gt; ）将使用Go模板漂亮地打印历史记录输出。</target>
        </trans-unit>
        <trans-unit id="24b5cac13ad3ca9432388011779d2d67c8c0d7ff" translate="yes" xml:space="preserve">
          <source>The formatting options (&lt;code&gt;--format&lt;/code&gt;) pretty-prints networks output using a Go template.</source>
          <target state="translated">格式化选项（ &lt;code&gt;--format&lt;/code&gt; ）使用Go模板漂亮地打印网络输出。</target>
        </trans-unit>
        <trans-unit id="f383ba453be785051b7c5611493a2ff002cfda87" translate="yes" xml:space="preserve">
          <source>The formatting options (&lt;code&gt;--format&lt;/code&gt;) pretty-prints nodes output using a Go template.</source>
          <target state="translated">格式化选项（ &lt;code&gt;--format&lt;/code&gt; ）漂亮地打印使用Go模板输出的节点。</target>
        </trans-unit>
        <trans-unit id="4fac954b380cf768ad87c1f69c92adba5a56b9ee" translate="yes" xml:space="preserve">
          <source>The formatting options (&lt;code&gt;--format&lt;/code&gt;) pretty-prints plugins output using a Go template.</source>
          <target state="translated">格式化选项（ &lt;code&gt;--format&lt;/code&gt; ）使用Go模板输出漂亮的插件输出。</target>
        </trans-unit>
        <trans-unit id="a5b662551ceb72817b0d9d973a68e9e4c8e129c8" translate="yes" xml:space="preserve">
          <source>The formatting options (&lt;code&gt;--format&lt;/code&gt;) pretty-prints services output using a Go template.</source>
          <target state="translated">格式化选项（ &lt;code&gt;--format&lt;/code&gt; ）使用Go模板漂亮地打印服务输出。</target>
        </trans-unit>
        <trans-unit id="67076d11d977bc7a1dcefe49045e4eae2c6c8f21" translate="yes" xml:space="preserve">
          <source>The formatting options (&lt;code&gt;--format&lt;/code&gt;) pretty-prints tasks output using a Go template.</source>
          <target state="translated">格式化选项（ &lt;code&gt;--format&lt;/code&gt; ）漂亮地打印使用Go模板输出的任务。</target>
        </trans-unit>
        <trans-unit id="a63922a8194d1ad1d264b55c3eca84dfc755a202" translate="yes" xml:space="preserve">
          <source>The formatting options (&lt;code&gt;--format&lt;/code&gt;) pretty-prints volumes output using a Go template.</source>
          <target state="translated">格式化选项（ &lt;code&gt;--format&lt;/code&gt; ）使用Go模板漂亮地打印卷输出。</target>
        </trans-unit>
        <trans-unit id="2478ba4d66a52065d825d802915cb3a4ef902b9b" translate="yes" xml:space="preserve">
          <source>The functionality described on this page is marked as Experimental, and as such, may change before it becomes generally available.</source>
          <target state="translated">本页所描述的功能被标记为实验性的,因此,在它成为普遍可用之前,可能会改变。</target>
        </trans-unit>
        <trans-unit id="53df056b93586ddb8659e1d397c9782f60693b8e" translate="yes" xml:space="preserve">
          <source>The general format is shown here.</source>
          <target state="translated">一般格式如图所示。</target>
        </trans-unit>
        <trans-unit id="275c8aaaaa26e22f95d5301cc3b55ac3cdec446d" translate="yes" xml:space="preserve">
          <source>The global &lt;code&gt;-D&lt;/code&gt; option causes all &lt;code&gt;docker&lt;/code&gt; commands to output debug information.</source>
          <target state="translated">全局 &lt;code&gt;-D&lt;/code&gt; 选项使所有 &lt;code&gt;docker&lt;/code&gt; 命令输出调试信息。</target>
        </trans-unit>
        <trans-unit id="6ad7d09f09c6ebab4bee47e20efdb157b4305cec" translate="yes" xml:space="preserve">
          <source>The hard part is over. Now you just repeat the process you used in &lt;a href=&quot;../part3/index&quot;&gt;part 3&lt;/a&gt; to deploy on your new swarm. Just remember that only swarm managers like &lt;code&gt;myvm1&lt;/code&gt; execute Docker commands; workers are just for capacity.</source>
          <target state="translated">困难的部分结束了。现在，您只需重复第&lt;a href=&quot;../part3/index&quot;&gt;3部分中&lt;/a&gt;使用的过程即可在新的集群上进行部署。只需记住，只有像 &lt;code&gt;myvm1&lt;/code&gt; 这样的集群管理器才能执行Docker命令。工人只是为了能力。</target>
        </trans-unit>
        <trans-unit id="7a17f01abd893e1c6c4a0f1c0bf80ec053a99aa9" translate="yes" xml:space="preserve">
          <source>The health check will first run &lt;strong&gt;interval&lt;/strong&gt; seconds after the container is started, and then again &lt;strong&gt;interval&lt;/strong&gt; seconds after each previous check completes.</source>
          <target state="translated">运行状况检查将首先在启动容器后&lt;strong&gt;间隔&lt;/strong&gt;几秒钟运行一次，然后在每次之前的检查完成后&lt;strong&gt;间隔&lt;/strong&gt;几秒钟再次&lt;strong&gt;运行&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="50587757d59b1045d03cb2b55f5bd32ec2daecbc" translate="yes" xml:space="preserve">
          <source>The health status is also displayed in the &lt;code&gt;docker ps&lt;/code&gt; output.</source>
          <target state="translated">健康状态也会显示在 &lt;code&gt;docker ps&lt;/code&gt; 输出中。</target>
        </trans-unit>
        <trans-unit id="a44e290ddaf714a047442f22669818b2b8934cc6" translate="yes" xml:space="preserve">
          <source>The helpers always use the first argument in the command to identify the action. There are only three possible values for that argument: &lt;code&gt;store&lt;/code&gt;, &lt;code&gt;get&lt;/code&gt;, and &lt;code&gt;erase&lt;/code&gt;.</source>
          <target state="translated">帮助程序始终使用命令中的第一个参数来标识操作。该参数只有三个可能的值： &lt;code&gt;store&lt;/code&gt; ， &lt;code&gt;get&lt;/code&gt; 和 &lt;code&gt;erase&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="49e3d75f86bffa0f3dc84c1b532153407879db50" translate="yes" xml:space="preserve">
          <source>The hostname associated with the container</source>
          <target state="translated">与容器相关联的主机名</target>
        </trans-unit>
        <trans-unit id="24b249127db194475ad1fa29636e81e19aba196a" translate="yes" xml:space="preserve">
          <source>The hostname of the remote trust service</source>
          <target state="translated">远程信任服务的主机名</target>
        </trans-unit>
        <trans-unit id="bc8d4004d9c5c0b1afc9e1c0ff064322235cdc74" translate="yes" xml:space="preserve">
          <source>The image manifest &lt;a href=&quot;https://github.com/docker/distribution/blob/fda42e5ef908bdba722d435ff1f330d40dfcd56c/docs/spec/manifest-v2-1/&quot;&gt;v2 schema 1&lt;/a&gt; format is deprecated in favor of the &lt;a href=&quot;https://github.com/docker/distribution/blob/fda42e5ef908bdba722d435ff1f330d40dfcd56c/docs/spec/manifest-v2-2/&quot;&gt;v2 schema 2&lt;/a&gt; format.</source>
          <target state="translated">不推荐使用图像清单&lt;a href=&quot;https://github.com/docker/distribution/blob/fda42e5ef908bdba722d435ff1f330d40dfcd56c/docs/spec/manifest-v2-1/&quot;&gt;v2模式1&lt;/a&gt;格式，而推荐使用&lt;a href=&quot;https://github.com/docker/distribution/blob/fda42e5ef908bdba722d435ff1f330d40dfcd56c/docs/spec/manifest-v2-2/&quot;&gt;v2模式2&lt;/a&gt;格式。</target>
        </trans-unit>
        <trans-unit id="95437efa4b2f4d528cee5344d23a48586427b1cb" translate="yes" xml:space="preserve">
          <source>The image that the service runs. Docker images should be referenced with full content hash to fully specify the deployment artifact for the service. Example: &lt;code&gt;postgres@sha256:e0a230a9f5b4e1b8b03bb3e8cf7322b0e42b7838c5c87f4545edb48f5eb8f077&lt;/code&gt;</source>
          <target state="translated">服务运行的图像。Docker映像应使用完整的内容散列进行引用，以完全指定服务的部署工件。示例： &lt;code&gt;postgres@sha256:e0a230a9f5b4e1b8b03bb3e8cf7322b0e42b7838c5c87f4545edb48f5eb8f077&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8c2247e031dafb7acba700a626e657e0cfe4cdcf" translate="yes" xml:space="preserve">
          <source>The implementation of the consensus algorithm in swarm mode means it features the properties inherent to distributed systems:</source>
          <target state="translated">在蜂群模式下实现共识算法意味着它具有分布式系统固有的特性。</target>
        </trans-unit>
        <trans-unit id="9c31e09abe96c3782c39594f852fa5e18a0ad156" translate="yes" xml:space="preserve">
          <source>The instruction is not case-sensitive. However, convention is for them to be UPPERCASE to distinguish them from arguments more easily.</source>
          <target state="translated">该指令不区分大小写。但是,约定俗成的是,为了更容易地将它们与参数区分开来,应该采用大写。</target>
        </trans-unit>
        <trans-unit id="432ac2568e57f2999351cf4730fe1a622e719e5b" translate="yes" xml:space="preserve">
          <source>The instructions below outline installation of the current stable release (&lt;strong&gt;v1.24.1&lt;/strong&gt;) of Compose. To install a different version of Compose, replace the given release number with the one that you want. Compose releases are also listed and available for direct download on the &lt;a href=&quot;https://github.com/docker/compose/releases&quot;&gt;Compose repository release page on GitHub&lt;/a&gt;. To install a &lt;strong&gt;pre-release&lt;/strong&gt; of Compose, refer to the &lt;a href=&quot;#install-pre-release-builds&quot;&gt;install pre-release builds&lt;/a&gt; section.</source>
          <target state="translated">以下说明概述了Compose 当前稳定版本（&lt;strong&gt;v1.24.1&lt;/strong&gt;）的安装。要安装其他版本的Compose，请用所需的版本号替换给定的发行号。还列出了Compose版本，可以&lt;a href=&quot;https://github.com/docker/compose/releases&quot;&gt;在GitHub&lt;/a&gt;上的Compose存储库版本页面上直接下载。要安装Compose 的&lt;strong&gt;预发布版本&lt;/strong&gt;，请参阅&amp;ldquo; &lt;a href=&quot;#install-pre-release-builds&quot;&gt;安装预发布内部版本&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="a728e9ba163d13c002fa9cbc101bd55bb3117d98" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;secrets:&lt;/code&gt; defines two secrets &lt;code&gt;db_password:&lt;/code&gt; and &lt;code&gt;db_root_password:&lt;/code&gt;.</source>
          <target state="translated">关键字 &lt;code&gt;secrets:&lt;/code&gt; 定义了两个秘密 &lt;code&gt;db_password:&lt;/code&gt; 和 &lt;code&gt;db_root_password:&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f38f01c9dd04c1cf0aaafe08aeddca4be0e7e775" translate="yes" xml:space="preserve">
          <source>The label-file format is similar to the format for loading environment variables. (Unlike environment variables, labels are not visible to processes running inside a container.) The following example illustrates a label-file format:</source>
          <target state="translated">标签文件的格式与加载环境变量的格式类似。与环境变量不同的是,标签对于在容器内运行的进程是不可见的)。下面的例子说明了标签文件的格式。</target>
        </trans-unit>
        <trans-unit id="b061ec279352905ba71ef5544860362f98c44798" translate="yes" xml:space="preserve">
          <source>The labels you set for nodes using &lt;code&gt;docker node update&lt;/code&gt; apply only to the node entity within the swarm. Do not confuse them with the docker daemon labels for &lt;a href=&quot;https://docs.docker.com/config#daemon-labels&quot;&gt;dockerd&lt;/a&gt;.</source>
          <target state="translated">您使用 &lt;code&gt;docker node update&lt;/code&gt; 为节点设置的标签仅适用于群集内的节点实体。不要将它们与&lt;a href=&quot;https://docs.docker.com/config#daemon-labels&quot;&gt;dockerd的docker&lt;/a&gt; daemon标签混淆。</target>
        </trans-unit>
        <trans-unit id="00c354608645937cfbba945cdf048bbd0c24872e" translate="yes" xml:space="preserve">
          <source>The labels you set for nodes using docker node update apply only to the node entity within the swarm. Do not confuse them with the docker daemon labels for &lt;a href=&quot;https://docs.docker.com/config#daemon-labels&quot;&gt;dockerd&lt;/a&gt;.</source>
          <target state="translated">您使用docker node update为节点设置的标签仅适用于群集内的节点实体。不要将它们与&lt;a href=&quot;https://docs.docker.com/config#daemon-labels&quot;&gt;dockerd的docker&lt;/a&gt; daemon标签混淆。</target>
        </trans-unit>
        <trans-unit id="a43092dff37282e5d580b06cc9c9a241636d4555" translate="yes" xml:space="preserve">
          <source>The last argument is set to &lt;code&gt;-&lt;/code&gt;, which indicates that the input is read from standard input.</source>
          <target state="translated">最后一个参数设置为 &lt;code&gt;-&lt;/code&gt; ，指示从标准输入中读取输入。</target>
        </trans-unit>
        <trans-unit id="f88ec5c1efa88b85aa9dbdbf3b9ef1192d7e39a6" translate="yes" xml:space="preserve">
          <source>The legacy &lt;code&gt;overlay&lt;/code&gt; storage driver allowed using overlayFS-backed filesystems on pre 4.x kernels. Now that all supported distributions are able to run &lt;code&gt;overlay2&lt;/code&gt; (as they are either on kernel 4.x, or have support for multiple lowerdirs backported), there is no reason to keep maintaining the &lt;code&gt;overlay&lt;/code&gt; storage driver.</source>
          <target state="translated">旧版 &lt;code&gt;overlay&lt;/code&gt; 存储驱动程序允许在4.x之前的内核上使用由overlayFS支持的文件系统。现在，所有受支持的发行版都可以运行 &lt;code&gt;overlay2&lt;/code&gt; （因为它们位于内核4.x上，或者支持反向移植多个lowerdirs），因此没有理由继续维护 &lt;code&gt;overlay&lt;/code&gt; 存储驱动程序。</target>
        </trans-unit>
        <trans-unit id="72ca0136842dab10471332313be4ade3373c948b" translate="yes" xml:space="preserve">
          <source>The list of currently supported feature options:</source>
          <target state="translated">当前支持的功能选项列表。</target>
        </trans-unit>
        <trans-unit id="d3c8c2e1de66029817dafcb63fc75fe2dc499fd0" translate="yes" xml:space="preserve">
          <source>The list of currently supported options that can be reconfigured is this:</source>
          <target state="translated">目前支持的可以重新配置的选项列表是这样的。</target>
        </trans-unit>
        <trans-unit id="0e98a52d303448e87f626daa2e157f85abb30be2" translate="yes" xml:space="preserve">
          <source>The logging and bug reporting configuration options for both Notary server and Notary signer have the same keys and format. The following sections provide further detail.</source>
          <target state="translated">公证服务器和公证签字器的日志和错误报告配置选项具有相同的键和格式。下面的章节将提供进一步的细节。</target>
        </trans-unit>
        <trans-unit id="86bd991ac2f1db82855964d5b14b4bce6e93bce7" translate="yes" xml:space="preserve">
          <source>The logging section sets the log level of the server. If it is not provided, the signer/server defaults to an ERROR logging level. However if an explicit value was provided, it must be a valid value.</source>
          <target state="translated">日志部分设置服务器的日志级别。如果没有提供,签字人/服务器默认为ERROR日志级别。但是,如果提供了一个明确的值,它必须是一个有效的值。</target>
        </trans-unit>
        <trans-unit id="9e762c03589c3d17a47706808801d159143b4877" translate="yes" xml:space="preserve">
          <source>The long form syntax allows the configuration of additional fields that can&amp;rsquo;t be expressed in the short form.</source>
          <target state="translated">长格式语法允许配置其他不能以短格式表示的字段。</target>
        </trans-unit>
        <trans-unit id="b98877d748e2beaa689b50122d97e4a10950df00" translate="yes" xml:space="preserve">
          <source>The long syntax provides more granularity in how the config is created within the service&amp;rsquo;s task containers.</source>
          <target state="translated">长语法提供了在服务的任务容器中如何创建配置的更多粒度。</target>
        </trans-unit>
        <trans-unit id="ab4ed053560438068d3b26d30072e5bb12d4735d" translate="yes" xml:space="preserve">
          <source>The long syntax provides more granularity in how the secret is created within the service&amp;rsquo;s task containers.</source>
          <target state="translated">长语法提供了在服务的任务容器中如何创建机密的更多粒度。</target>
        </trans-unit>
        <trans-unit id="e55fd2f0d1c7aad656123b72a8eaa4423c80f42a" translate="yes" xml:space="preserve">
          <source>The machine IP addresses returned by &lt;code&gt;docker-machine ls&lt;/code&gt; include port 2376, which is the Docker daemon port. Do not use this port or &lt;a href=&quot;https://forums.docker.com/t/docker-swarm-join-with-virtualbox-connection-error-13-bad-certificate/31392/2&quot;&gt;you may experience errors&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;docker-machine ls&lt;/code&gt; 返回的机器IP地址包括端口2376，这是Docker守护程序端口。不要使用此端口，否则&lt;a href=&quot;https://forums.docker.com/t/docker-swarm-join-with-virtualbox-connection-error-13-bad-certificate/31392/2&quot;&gt;您可能会遇到错误&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b1e4cfbe37efbd898032e44dbda616a3d3379c37" translate="yes" xml:space="preserve">
          <source>The main process inside the container referenced under the link &lt;code&gt;redis&lt;/code&gt; will receive &lt;code&gt;SIGKILL&lt;/code&gt;, then the container will be removed.</source>
          <target state="translated">在链接 &lt;code&gt;redis&lt;/code&gt; 下引用的容器内部的主进程将收到 &lt;code&gt;SIGKILL&lt;/code&gt; ，然后将容器删除。</target>
        </trans-unit>
        <trans-unit id="6387957ec493a472590c3ca3e7ac1366b4edd047" translate="yes" xml:space="preserve">
          <source>The main process inside the container will receive &lt;code&gt;SIGTERM&lt;/code&gt;, and after a grace period, &lt;code&gt;SIGKILL&lt;/code&gt;.</source>
          <target state="translated">容器内的主进程将收到 &lt;code&gt;SIGTERM&lt;/code&gt; ，宽限期之后将收到 &lt;code&gt;SIGKILL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ee7fca0430379bc3c92a18b854c9921ca0e85f66" translate="yes" xml:space="preserve">
          <source>The manager instructs the worker nodes to redeploy the tasks using the image at that tag.</source>
          <target state="translated">管理员指示工人节点使用该标记处的图像重新部署任务。</target>
        </trans-unit>
        <trans-unit id="710695523bad549ff83605c3df401f525b183c0d" translate="yes" xml:space="preserve">
          <source>The manager node also generates two tokens to use when you join additional nodes to the swarm: one &lt;strong&gt;worker token&lt;/strong&gt; and one &lt;strong&gt;manager token&lt;/strong&gt;. Each token includes the digest of the root CA&amp;rsquo;s certificate and a randomly generated secret. When a node joins the swarm, the joining node uses the digest to validate the root CA certificate from the remote manager. The remote manager uses the secret to ensure the joining node is an approved node.</source>
          <target state="translated">当您将其他节点加入集群时，manager节点还会生成两个令牌：一个&lt;strong&gt;worker令牌&lt;/strong&gt;和一个&lt;strong&gt;manager令牌&lt;/strong&gt;。每个令牌都包括根CA证书的摘要和随机生成的秘密。当节点加入群集时，加入的节点使用摘要来验证来自远程管理器的根CA证书。远程管理器使用机密来确保加入节点是批准的节点。</target>
        </trans-unit>
        <trans-unit id="6fe7ef87a2896b45c763e7b46ac2607a814197d3" translate="yes" xml:space="preserve">
          <source>The manifest command interacts solely with a Docker registry. Because of this, it has no way to query the engine for the list of allowed insecure registries. To allow the CLI to interact with an insecure registry, some &lt;code&gt;docker manifest&lt;/code&gt; commands have an &lt;code&gt;--insecure&lt;/code&gt; flag. For each transaction, such as a &lt;code&gt;create&lt;/code&gt;, which queries a registry, the &lt;code&gt;--insecure&lt;/code&gt; flag must be specified. This flag tells the CLI that this registry call may ignore security concerns like missing or self-signed certificates. Likewise, on a &lt;code&gt;manifest push&lt;/code&gt; to an insecure registry, the &lt;code&gt;--insecure&lt;/code&gt; flag must be specified. If this is not used with an insecure registry, the manifest command fails to find a registry that meets the default requirements.</source>
          <target state="translated">manifest命令仅与Docker注册表交互。因此，它无法查询引擎以获取允许的不安全注册表列表。为了允许CLI与不安全的注册表进行交互，某些 &lt;code&gt;--insecure&lt;/code&gt; &lt;code&gt;docker manifest&lt;/code&gt; 命令具有--insecure标志。对于每个事务，例如查询注册表的 &lt;code&gt;create&lt;/code&gt; ，必须指定 &lt;code&gt;--insecure&lt;/code&gt; 标志。该标志告诉CLI，此注册表调用可能会忽略安全性问题，例如丢失或自签名证书。同样，在 &lt;code&gt;manifest push&lt;/code&gt; 送到不安全的注册表时，-- &lt;code&gt;--insecure&lt;/code&gt; 必须指定标志。如果不与不安全的注册表一起使用，清单命令将找不到符合默认要求的注册表。</target>
        </trans-unit>
        <trans-unit id="9ffd76b694c7c7a6e6da7a3f6166050339325636" translate="yes" xml:space="preserve">
          <source>The max age, in seconds, for caching services to cache the latest metadata for a role and the metadata by checksum for a role. This value is set on the cache control headers for GET-ting metadata. `must-revalidate` is also set on the cache control headers for current metadata, as current metadata may change whenever new metadata is signed into a repo. Consistent metadata should never change, although it may be deleted, so the max age can be a higher value.</source>
          <target state="translated">缓存服务缓存角色的最新元数据和元数据校验的最大年龄,以秒为单位。这个值是在GET-ting元数据的缓存控制头上设置的。`must-revalidate`也设置在当前元数据的缓存控制头上,因为每当新的元数据被签入repo时,当前元数据可能会改变。一致的元数据应该永远不会改变,尽管它可能被删除,所以最大年龄可以是一个较高的值。</target>
        </trans-unit>
        <trans-unit id="58a5cf58f71249302a3075f943ef43b227012536" translate="yes" xml:space="preserve">
          <source>The maximum number of tasks to roll back in parallel. By default, one task is rolled back at a time. A value of &lt;code&gt;0&lt;/code&gt; causes all tasks to be rolled back in parallel.</source>
          <target state="translated">并行回滚的最大任务数。默认情况下，一次回滚一个任务。值为 &lt;code&gt;0&lt;/code&gt; 会使所有任务并行回滚。</target>
        </trans-unit>
        <trans-unit id="a35c3e7a9e4e6e95678b28327ea178f97e6c0685" translate="yes" xml:space="preserve">
          <source>The means of installing and running a network driver plugin depend on the particular plugin. So, be sure to install your plugin according to the instructions obtained from the plugin developer.</source>
          <target state="translated">安装和运行网络驱动插件的方法取决于特定的插件。所以,一定要根据从插件开发者那里获得的说明来安装你的插件。</target>
        </trans-unit>
        <trans-unit id="4a2d84181923d3b2758ab234bc6aa9a8b22fc07a" translate="yes" xml:space="preserve">
          <source>The minimum Docker Engine version you must be running</source>
          <target state="translated">你必须运行的最低Docker引擎版本。</target>
        </trans-unit>
        <trans-unit id="b01ded6c0b3d82f55e3f46535073246347104b21" translate="yes" xml:space="preserve">
          <source>The mode to use for binding the port, either</source>
          <target state="translated">用于绑定端口的模式,可以是</target>
        </trans-unit>
        <trans-unit id="db6f7022b8d25772c7d891f36408220c2990344a" translate="yes" xml:space="preserve">
          <source>The most basic operation is listing the available signed tags in a repository. The Notary client used in isolation does not know where the trust repositories are located. So, you must provide the &lt;code&gt;-s&lt;/code&gt; (or long form &lt;code&gt;--server&lt;/code&gt;) flag to tell the client which repository server it should communicate with.</source>
          <target state="translated">最基本的操作是在存储库中列出可用的已签名标签。孤立使用的公证人客户端不知道信任库的位置。因此，您必须提供 &lt;code&gt;-s&lt;/code&gt; （或长格式 &lt;code&gt;--server&lt;/code&gt; ）标志，以告知客户端应与之通信的存储库服务器。</target>
        </trans-unit>
        <trans-unit id="e3c0616a28189d339564bcd3117d8057f5d15956" translate="yes" xml:space="preserve">
          <source>The most important delegation within Docker Content Trust is &lt;code&gt;targets/releases&lt;/code&gt;. This is seen as the canonical source of a trusted image tag, and without a contributor&amp;rsquo;s key being under this delegation, they will be unable to sign a tag.</source>
          <target state="translated">Docker Content Trust中最重要的委托是 &lt;code&gt;targets/releases&lt;/code&gt; 。这被视为可信任图像标签的规范来源，并且如果在此委托下没有贡献者的密钥，他们将无法签名标签。</target>
        </trans-unit>
        <trans-unit id="1963cac251482ce51e0f0c9b512493c59a096c5c" translate="yes" xml:space="preserve">
          <source>The mount is created inside the container&amp;rsquo;s &lt;code&gt;/world&lt;/code&gt; directory. Docker does not support relative paths for mount points inside the container.</source>
          <target state="translated">挂载在容器的 &lt;code&gt;/world&lt;/code&gt; 目录中创建。Docker不支持容器内安装点的相对路径。</target>
        </trans-unit>
        <trans-unit id="f65ec1cc00b9bb1818ddcdd9dc95e9ae4db3f15d" translate="yes" xml:space="preserve">
          <source>The mount point of the volume on the host</source>
          <target state="translated">主机上卷的挂载点</target>
        </trans-unit>
        <trans-unit id="5c2ff1f321223719bfae08a21a2ef3fe1dad75a7" translate="yes" xml:space="preserve">
          <source>The name of the file (excluding the extension) determines the plugin name.</source>
          <target state="translated">文件名(不包括扩展名)决定了插件的名称。</target>
        </trans-unit>
        <trans-unit id="2c2d2aa17023ec6fcc56386e68b98696ac0b646e" translate="yes" xml:space="preserve">
          <source>The namespaces &lt;code&gt;com.docker.*&lt;/code&gt;, &lt;code&gt;io.docker.*&lt;/code&gt;, and &lt;code&gt;org.dockerproject.*&lt;/code&gt; in engine labels were always documented to be reserved, but there was never any enforcement.</source>
          <target state="translated">引擎标签中的命名空间 &lt;code&gt;com.docker.*&lt;/code&gt; ， &lt;code&gt;io.docker.*&lt;/code&gt; 和 &lt;code&gt;org.dockerproject.*&lt;/code&gt; 始终被记录为保留的，但从未执行过。</target>
        </trans-unit>
        <trans-unit id="4db72238fc7d78007b167442cf07bb6fabacfd9e" translate="yes" xml:space="preserve">
          <source>The network driver protocol, in addition to the plugin activation call, is documented as part of libnetwork: &lt;a href=&quot;https://github.com/docker/libnetwork/blob/master/docs/remote/&quot;&gt;https://github.com/docker/libnetwork/blob/master/docs/remote.md&lt;/a&gt;.</source>
          <target state="translated">除插件激活调用外，网络驱动程序协议还作为libnetwork的一部分记录在文档中：&lt;a href=&quot;https://github.com/docker/libnetwork/blob/master/docs/remote/&quot;&gt;https&lt;/a&gt; : //github.com/docker/libnetwork/blob/master/docs/remote.md。</target>
        </trans-unit>
        <trans-unit id="6d8b041ac43e25f9c65ebc52b5baf0e82a00ee6a" translate="yes" xml:space="preserve">
          <source>The network filter matches on both the network&amp;rsquo;s name and id. The following example shows all containers that are attached to the &lt;code&gt;net1&lt;/code&gt; network, using the network id as a filter;</source>
          <target state="translated">网络过滤器会同时匹配网络的名称和ID。下面的示例使用网络ID作为过滤器，显示连接到 &lt;code&gt;net1&lt;/code&gt; 网络的所有容器。</target>
        </trans-unit>
        <trans-unit id="29a642482c30f96a4033899c0fdaea9ec3beee25" translate="yes" xml:space="preserve">
          <source>The network from which copying the configuration</source>
          <target state="translated">复制配置的网络</target>
        </trans-unit>
        <trans-unit id="efe659c7cfe7d28e40435e0deeb5154cf1b4363e" translate="yes" xml:space="preserve">
          <source>The network you created is shared between them and load-balancing. Run &lt;code&gt;docker-machine ls&lt;/code&gt; to get your VMs&amp;rsquo; IP addresses and visit either of them on a browser on port 4000, hitting refresh (or just &lt;code&gt;curl&lt;/code&gt; them).</source>
          <target state="translated">您创建的网络在它们和负载平衡之间共享。运行 &lt;code&gt;docker-machine ls&lt;/code&gt; 来获取您的VM的IP地址，并在端口4000上的浏览器中访问它们中的任何一个，以刷新（或只是 &lt;code&gt;curl&lt;/code&gt; 它们）。</target>
        </trans-unit>
        <trans-unit id="87723d2ef8e1904797dd36ac4993e2ae45bad90e" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;aws-sandbox&lt;/code&gt; instance is running and is the active host as indicated by the asterisk (*). When you create a new machine, your command shell automatically connects to it. You can also check active status by running &lt;code&gt;docker-machine active&lt;/code&gt;.</source>
          <target state="translated">新的 &lt;code&gt;aws-sandbox&lt;/code&gt; 实例正在运行，并且是活动主机，如星号（*）所示。创建新计算机时，命令外壳会自动连接到该计算机。您还可以通过运行 &lt;code&gt;docker-machine active&lt;/code&gt; 来检查活动状态。</target>
        </trans-unit>
        <trans-unit id="183db4b8d88e39dbe104cc52c7ad0b7baded2ed7" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;docker-sandbox&lt;/code&gt; machine is running, and it is the active host as indicated by the asterisk (*). When you create a new machine, your command shell automatically connects to it. If for some reason your new machine is not the active host, run &lt;code&gt;docker-machine env docker-sandbox&lt;/code&gt;, followed by &lt;code&gt;eval $(docker-machine env docker-sandbox)&lt;/code&gt; to connect to it.</source>
          <target state="translated">新的 &lt;code&gt;docker-sandbox&lt;/code&gt; 机器正在运行，并且是星号（*）指示的活动主机。创建新计算机时，命令外壳会自动连接到该计算机。如果由于某种原因您的新计算机不是活动主机，请运行 &lt;code&gt;docker-machine env docker-sandbox&lt;/code&gt; ，然后运行 &lt;code&gt;eval $(docker-machine env docker-sandbox)&lt;/code&gt; 进行连接。</target>
        </trans-unit>
        <trans-unit id="0d5eeb3e8799d63324d4a44f2b2fa61c3e46867c" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;volumes&lt;/code&gt; key mounts the project directory (current directory) on the host to &lt;code&gt;/code&lt;/code&gt; inside the container, allowing you to modify the code on the fly, without having to rebuild the image. The &lt;code&gt;environment&lt;/code&gt; key sets the &lt;code&gt;FLASK_ENV&lt;/code&gt; environment variable, which tells &lt;code&gt;flask run&lt;/code&gt; to run in development mode and reload the code on change. This mode should only be used in development.</source>
          <target state="translated">新的 &lt;code&gt;volumes&lt;/code&gt; 键将主机上的项目目录（当前目录）挂载到容器内的 &lt;code&gt;/code&lt;/code&gt; ，从而使您可以即时修改代码，而不必重建映像。该 &lt;code&gt;environment&lt;/code&gt; 键设置 &lt;code&gt;FLASK_ENV&lt;/code&gt; 环境变量，它告诉 &lt;code&gt;flask run&lt;/code&gt; 在开发模式下运行，并重新加载更改代码。此模式只能在开发中使用。</target>
        </trans-unit>
        <trans-unit id="3e404d1970236a5dc75cedbe336754c764fa97e2" translate="yes" xml:space="preserve">
          <source>The new solutions come with their own native virtualization solutions rather than Oracle VirtualBox, so keep the following considerations in mind when using Machine to create local VMs.</source>
          <target state="translated">新的解决方案带有自己的本地虚拟化解决方案,而不是Oracle VirtualBox,因此在使用Machine创建本地虚拟机时,请记住以下注意事项。</target>
        </trans-unit>
        <trans-unit id="b234c0b19a2b37103809d22b0044e00398b27483" translate="yes" xml:space="preserve">
          <source>The newly created configuration file contains information about the location of your local Docker trust data and the notary server URL.</source>
          <target state="translated">新创建的配置文件包含了关于本地Docker信任数据的位置和公证服务器URL的信息。</target>
        </trans-unit>
        <trans-unit id="bc5727abee1ac6e471930402f1f4be87dab74892" translate="yes" xml:space="preserve">
          <source>The next table shows the capabilities which are not granted by default and may be added.</source>
          <target state="translated">下表显示了默认情况下不授予的功能,可以添加。</target>
        </trans-unit>
        <trans-unit id="f3fa21b777fd584afc62cf8b69c40e4fffcc5ba1" translate="yes" xml:space="preserve">
          <source>The node listens for inbound swarm manager traffic on this address. The default is to listen on 0.0.0.0:2377. It is also possible to specify a network interface to listen on that interface&amp;rsquo;s address; for example &lt;code&gt;--listen-addr eth0:2377&lt;/code&gt;.</source>
          <target state="translated">节点在此地址上侦听入站群管理器流量。默认值为监听0.0.0.0:2377。还可以指定一个网络接口以监听该接口的地址。例如 &lt;code&gt;--listen-addr eth0:2377&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fb2efabd37befde6cddb78b91ecab1ab217a31a9" translate="yes" xml:space="preserve">
          <source>The node will still appear in the node list, and marked as &lt;code&gt;down&lt;/code&gt;. It no longer affects swarm operation, but a long list of &lt;code&gt;down&lt;/code&gt; nodes can clutter the node list. To remove an inactive node from the list, use the &lt;a href=&quot;../node_rm/index&quot;&gt;&lt;code&gt;node rm&lt;/code&gt;&lt;/a&gt; command.</source>
          <target state="translated">该节点仍将出现在节点列表中，并标记为 &lt;code&gt;down&lt;/code&gt; 。它不再影响群集操作，但是一长串的 &lt;code&gt;down&lt;/code&gt; 节点会使节点列表混乱。要从列表中删除非活动节点，请使用&lt;a href=&quot;../node_rm/index&quot;&gt; &lt;code&gt;node rm&lt;/code&gt; &lt;/a&gt;命令。</target>
        </trans-unit>
        <trans-unit id="92a57b3a23013f31bf5b08572bd51664bc7950ef" translate="yes" xml:space="preserve">
          <source>The notary server credentials: &lt;code&gt;&amp;lt;username&amp;gt;:&amp;lt;password&amp;gt;&lt;/code&gt; encoded in base64</source>
          <target state="translated">公证服务器凭据： &lt;code&gt;&amp;lt;username&amp;gt;:&amp;lt;password&amp;gt;&lt;/code&gt; 编码为base64</target>
        </trans-unit>
        <trans-unit id="14bfe3d31f5f78a4f822b4d8e315b4ba8ca678ee" translate="yes" xml:space="preserve">
          <source>The notary server is always responsible for managing the timestamp key. However, it is possible for the notary server to manage the snapshot key, if the snapshot key is rotated from the notary client to server, as described in the following subsection.</source>
          <target state="translated">公证服务器始终负责管理时间戳密钥。但是,如果快照钥匙从公证客户机轮换到服务器,则公证服务器有可能管理快照钥匙,如下小节所述。</target>
        </trans-unit>
        <trans-unit id="b336f656d8197e0632577208cd876d6d20c4b84c" translate="yes" xml:space="preserve">
          <source>The notation for associating a local image with a repository on a registry is &lt;code&gt;username/repository:tag&lt;/code&gt;. The tag is optional, but recommended, since it is the mechanism that registries use to give Docker images a version. Give the repository and tag meaningful names for the context, such as &lt;code&gt;get-started:part2&lt;/code&gt;. This puts the image in the &lt;code&gt;get-started&lt;/code&gt; repository and tags it as &lt;code&gt;part2&lt;/code&gt;.</source>
          <target state="translated">用于将本地映像与注册表上的存储库关联的表示法是 &lt;code&gt;username/repository:tag&lt;/code&gt; 。该标签是可选的，但值得推荐，因为它是注册管理机构用来给Docker映像提供版本的机制。给存储库命名并为上下文标记有意义的名称，例如 &lt;code&gt;get-started:part2&lt;/code&gt; 。这会将图像放入 &lt;code&gt;get-started&lt;/code&gt; 存储库中，并将其标记为 &lt;code&gt;part2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b69ac60cbd9e75489828f500df16f2177a96db75" translate="yes" xml:space="preserve">
          <source>The notation is &lt;code&gt;machinename:/path/to/dir&lt;/code&gt; for the argument; you can also supply an alternative mount point (default is the same dir path).</source>
          <target state="translated">参数的表示法是 &lt;code&gt;machinename:/path/to/dir&lt;/code&gt; ；您还可以提供备用安装点（默认为相同的目录路径）。</target>
        </trans-unit>
        <trans-unit id="d11c5e1162367e795a70983b83cfdf3d1ee3ac48" translate="yes" xml:space="preserve">
          <source>The notation is &lt;code&gt;machinename:/path/to/files&lt;/code&gt; for the arguments; in the host machine&amp;rsquo;s case, you don&amp;rsquo;t need to specify the name, just the path.</source>
          <target state="translated">参数的名称是 &lt;code&gt;machinename:/path/to/files&lt;/code&gt; ；在主机的情况下，您无需指定名称，只需指定路径即可。</target>
        </trans-unit>
        <trans-unit id="917f866a3c931d8ef3e0b7a32449c7405bbd0d26" translate="yes" xml:space="preserve">
          <source>The number of items in the task history is determined by the &lt;code&gt;--task-history-limit&lt;/code&gt; option that was set when initializing the swarm. You can change the task history retention limit using the &lt;a href=&quot;../swarm_update/index&quot;&gt;&lt;code&gt;docker swarm update&lt;/code&gt;&lt;/a&gt; command.</source>
          <target state="translated">任务历史记录中的项目数由初始化群组时设置的 &lt;code&gt;--task-history-limit&lt;/code&gt; 选项确定。您可以使用&lt;a href=&quot;../swarm_update/index&quot;&gt; &lt;code&gt;docker swarm update&lt;/code&gt; &lt;/a&gt;命令更改任务历史记录保留限制。</target>
        </trans-unit>
        <trans-unit id="f44ace853eedd4d2b3d52b4a07c2863c83910a2d" translate="yes" xml:space="preserve">
          <source>The number should increment.</source>
          <target state="translated">这个数字应该是递增的。</target>
        </trans-unit>
        <trans-unit id="2335d7fb127df2a4cdc6970180f0ce850a983406" translate="yes" xml:space="preserve">
          <source>The official Docker Hub Notary servers are located at &lt;code&gt;https://notary.docker.io&lt;/code&gt;. If you would like to use your own Notary server, it is important to use the same or a newer &lt;a href=&quot;https://github.com/docker/notary/releases&quot;&gt;Notary version&lt;/a&gt;, as the client for feature compatibility (ex: client version 0.2, server/signer version &amp;gt;= 0.2). Additionally, Notary stores your own signing keys, and a cache of previously downloaded trust metadata in a directory, provided with the &lt;code&gt;-d&lt;/code&gt; flag. When interacting with Docker Hub repositories, you must instruct the client to use the associated trust directory, which by default is found at &lt;code&gt;.docker/trust&lt;/code&gt; within the calling user&amp;rsquo;s home directory (failing to use this directory may result in errors when publishing updates to your trust data):</source>
          <target state="translated">官方Docker Hub公证服务器位于 &lt;code&gt;https://notary.docker.io&lt;/code&gt; 。如果要使用自己的Notary服务器，则使用相同或较新的&lt;a href=&quot;https://github.com/docker/notary/releases&quot;&gt;Notary版本&lt;/a&gt;作为客户端，以实现功能兼容性（例如：客户端版本0.2，服务器/签名者版本&amp;gt; = 0.2），这一点很重要。此外，Notary将您自己的签名密钥以及以前下载的信任元数据的高速缓存存储在目录中，并带有 &lt;code&gt;-d&lt;/code&gt; 标志。与Docker Hub存储库进行交互时，您必须指示客户端使用关联的信任目录，默认情况下该目录位于调用用户主目录的 &lt;code&gt;.docker/trust&lt;/code&gt; 中（如果无法使用此目录，可能会在发布更新到您的目录时导致错误信任数据）：</target>
        </trans-unit>
        <trans-unit id="22218babb42765a654a32765cf74fbd5b2200f1a" translate="yes" xml:space="preserve">
          <source>The only thing new here is the peer service to &lt;code&gt;web&lt;/code&gt;, named &lt;code&gt;visualizer&lt;/code&gt;. Notice two new things here: a &lt;code&gt;volumes&lt;/code&gt; key, giving the visualizer access to the host&amp;rsquo;s socket file for Docker, and a &lt;code&gt;placement&lt;/code&gt; key, ensuring that this service only ever runs on a swarm manager -- never a worker. That&amp;rsquo;s because this container, built from &lt;a href=&quot;https://github.com/ManoMarks/docker-swarm-visualizer&quot;&gt;an open source project created by Docker&lt;/a&gt;, displays Docker services running on a swarm in a diagram.</source>
          <target state="translated">这里唯一的新功能是 &lt;code&gt;web&lt;/code&gt; 的对等服务，名为 &lt;code&gt;visualizer&lt;/code&gt; 。请注意此处的两件事： &lt;code&gt;volumes&lt;/code&gt; 键（使可视化程序可以访问Docker的主机套接字文件）和 &lt;code&gt;placement&lt;/code&gt; 键，以确保此服务仅在群集管理器上运行，而不是工人。这是因为此容器&lt;a href=&quot;https://github.com/ManoMarks/docker-swarm-visualizer&quot;&gt;是由Docker创建的开源项目&lt;/a&gt;构建的，在图中显示了在大量集群上运行的Docker服务。</target>
        </trans-unit>
        <trans-unit id="89730a2ade1b5abddc9347ab148e5d119931f020" translate="yes" xml:space="preserve">
          <source>The operator can also adjust the performance parameters of the container:</source>
          <target state="translated">操作者还可以调整容器的性能参数。</target>
        </trans-unit>
        <trans-unit id="41382989315f8c3ee9e303ef492c566711e626ec" translate="yes" xml:space="preserve">
          <source>The operator can identify a container in three ways:</source>
          <target state="translated">操作者可以通过三种方式识别一个容器。</target>
        </trans-unit>
        <trans-unit id="c7367fe1cca6b073f6f2a1faf3da852281eae9d5" translate="yes" xml:space="preserve">
          <source>The optional field &lt;code&gt;features&lt;/code&gt; in &lt;code&gt;daemon.json&lt;/code&gt; allows users to enable or disable specific daemon features. For example, &lt;code&gt;{&quot;features&quot;:{&quot;buildkit&quot;: true}}&lt;/code&gt; enables &lt;code&gt;buildkit&lt;/code&gt; as the default docker image builder.</source>
          <target state="translated">可选字段 &lt;code&gt;features&lt;/code&gt; 在 &lt;code&gt;daemon.json&lt;/code&gt; 允许用户启用或禁用特定守护功能。例如， &lt;code&gt;{&quot;features&quot;:{&quot;buildkit&quot;: true}}&lt;/code&gt; 启用 &lt;code&gt;buildkit&lt;/code&gt; 作为默认的Docker映像生成器。</target>
        </trans-unit>
        <trans-unit id="e28c99503cf59797f397d36b1752165612aec9cc" translate="yes" xml:space="preserve">
          <source>The options described here are specific to the &lt;code&gt;deploy&lt;/code&gt; key and swarm mode. If you want to set resource constraints on non swarm deployments, use &lt;a href=&quot;compose-file-v2/index#cpu-and-other-resources&quot;&gt;Compose file format version 2 CPU, memory, and other resource options&lt;/a&gt;. If you have further questions, refer to the discussion on the GitHub issue &lt;a href=&quot;https://github.com/docker/compose/issues/4513&quot;&gt;docker/compose/4513&lt;/a&gt;.</source>
          <target state="translated">此处描述的选项特定于 &lt;code&gt;deploy&lt;/code&gt; 密钥和群集模式。如果要在非群集部署中设置资源限制，请使用&lt;a href=&quot;compose-file-v2/index#cpu-and-other-resources&quot;&gt;Compose文件格式版本2 CPU，内存和其他资源选项&lt;/a&gt;。如果您还有其他问题，请参阅有关GitHub问题&lt;a href=&quot;https://github.com/docker/compose/issues/4513&quot;&gt;docker / compose / 4513&lt;/a&gt;的讨论。</target>
        </trans-unit>
        <trans-unit id="be781eb9a4261dfa7130c6d663bb44e808306180" translate="yes" xml:space="preserve">
          <source>The options for &lt;code&gt;endpoint_mode&lt;/code&gt; also work as flags on the swarm mode CLI command &lt;a href=&quot;../../engine/reference/commandline/service_create/index&quot;&gt;docker service create&lt;/a&gt;. For a quick list of all swarm related &lt;code&gt;docker&lt;/code&gt; commands, see &lt;a href=&quot;../../engine/swarm/index#swarm-mode-key-concepts-and-tutorial&quot;&gt;Swarm mode CLI commands&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;endpoint_mode&lt;/code&gt; 的选项在群集模式CLI命令&lt;a href=&quot;../../engine/reference/commandline/service_create/index&quot;&gt;docker service create&lt;/a&gt;上也用作标志。有关所有与swarm相关的 &lt;code&gt;docker&lt;/code&gt; 命令的快速列表，请参阅&lt;a href=&quot;../../engine/swarm/index#swarm-mode-key-concepts-and-tutorial&quot;&gt;Swarm模式CLI命令&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="de59387120196b30f85a7b76e5242eebb18bcb72" translate="yes" xml:space="preserve">
          <source>The options for token auth. See &lt;a href=&quot;https://github.com/docker/distribution/blob/master/docs/configuration/#token&quot;&gt; the registry token configuration documentation&lt;/a&gt; for the parameter details.</source>
          <target state="translated">令牌认证的选项。有关参数的详细信息，请参阅&lt;a href=&quot;https://github.com/docker/distribution/blob/master/docs/configuration/#token&quot;&gt;注册表令牌配置文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7412839711afce147b5113fb7e29aef802049f6a" translate="yes" xml:space="preserve">
          <source>The options set in the configuration file must not conflict with options set via flags. The docker daemon fails to start if an option is duplicated between the file and the flags, regardless their value. We do this to avoid silently ignore changes introduced in configuration reloads. For example, the daemon fails to start if you set daemon labels in the configuration file and also set daemon labels via the &lt;code&gt;--label&lt;/code&gt; flag. Options that are not present in the file are ignored when the daemon starts.</source>
          <target state="translated">配置文件中设置的选项不得与通过标志设置的选项冲突。如果在文件和标志之间复制选项，则无论其值如何，docker守护程序均无法启动。我们这样做是为了避免无提示地忽略配置重载中引入的更改。例如，如果您在配置文件中设置了守护程序标签，并且还通过 &lt;code&gt;--label&lt;/code&gt; 标志设置了守护程序标签，则守护程序无法启动。启动守护程序时，文件中不存在的选项将被忽略。</target>
        </trans-unit>
        <trans-unit id="887339b939d9bd41483f880117e295c27a275ba5" translate="yes" xml:space="preserve">
          <source>The options that can appear before &lt;code&gt;CMD&lt;/code&gt; are:</source>
          <target state="translated">在 &lt;code&gt;CMD&lt;/code&gt; 之前可以显示的选项是：</target>
        </trans-unit>
        <trans-unit id="15025a31073c4bf6ead7579cba512726377f05f7" translate="yes" xml:space="preserve">
          <source>The options you can specify are:</source>
          <target state="translated">您可以指定的选项有:</target>
        </trans-unit>
        <trans-unit id="be530e2255560ffe12f81210b54801ad89713238" translate="yes" xml:space="preserve">
          <source>The output above also shows the &lt;code&gt;/usr/bin/docker&lt;/code&gt; (Docker Engine daemon) profile is running in &lt;code&gt;complain&lt;/code&gt; mode. This means AppArmor &lt;em&gt;only&lt;/em&gt; logs to &lt;code&gt;dmesg&lt;/code&gt; activity outside the bounds of the profile. (Except in the case of Ubuntu Trusty, where some interesting behaviors are enforced.)</source>
          <target state="translated">上面的输出还显示了 &lt;code&gt;/usr/bin/docker&lt;/code&gt; （Docker引擎守护程序）配置文件正在 &lt;code&gt;complain&lt;/code&gt; 模式下运行。这意味着AppArmor &lt;em&gt;仅&lt;/em&gt;记录到配置文件范围之外的 &lt;code&gt;dmesg&lt;/code&gt; 活动。 （除了Ubuntu Trusty，其中强制执行了一些有趣的行为。）</target>
        </trans-unit>
        <trans-unit id="2355a5f85cf53a441cc11d2d8bdc79e7dae6c672" translate="yes" xml:space="preserve">
          <source>The output described above is intended for the shells &lt;code&gt;bash&lt;/code&gt; and &lt;code&gt;zsh&lt;/code&gt; (if you&amp;rsquo;re not sure which shell you&amp;rsquo;re using, there&amp;rsquo;s a very good possibility that it&amp;rsquo;s &lt;code&gt;bash&lt;/code&gt;). However, these are not the only shells which Docker Machine supports. Docker Machine detects the shells available in your environment and lists them. Docker supports &lt;code&gt;bash&lt;/code&gt;, &lt;code&gt;cmd&lt;/code&gt;, &lt;code&gt;powershell&lt;/code&gt;, and &lt;code&gt;emacs&lt;/code&gt;.</source>
          <target state="translated">上面描述的输出用于 &lt;code&gt;bash&lt;/code&gt; 和 &lt;code&gt;zsh&lt;/code&gt; 外壳程序（如果不确定使用的外壳程序，则很有可能是 &lt;code&gt;bash&lt;/code&gt; ）。但是，这些并不是Docker Machine支持的唯一外壳。Docker Machine检测到您环境中可用的外壳并列出它们。Docker支持 &lt;code&gt;bash&lt;/code&gt; ， &lt;code&gt;cmd&lt;/code&gt; ， &lt;code&gt;powershell&lt;/code&gt; 和 &lt;code&gt;emacs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a45c5a07cae9a3fc556e42c151f1b595b59af9be" translate="yes" xml:space="preserve">
          <source>The output for &lt;code&gt;docker swarm init&lt;/code&gt; provides the connection command to use when you join new worker nodes to the swarm:</source>
          <target state="translated">&lt;code&gt;docker swarm init&lt;/code&gt; 的输出提供了将新工作节点加入到swarm时使用的连接命令：</target>
        </trans-unit>
        <trans-unit id="bd47af0af4efb7be690f1343bf0a5ed1d3833bd4" translate="yes" xml:space="preserve">
          <source>The output includes the commands to join new nodes to the swarm. Nodes will join as managers or workers depending on the value for the &lt;code&gt;--token&lt;/code&gt; flag.</source>
          <target state="translated">输出包括将新节点加入群集的命令。节点将根据 &lt;code&gt;--token&lt;/code&gt; 标志的值作为管理者或工作者加入。</target>
        </trans-unit>
        <trans-unit id="640437e1ea9cf751f8f36635ede5392a77849e3d" translate="yes" xml:space="preserve">
          <source>The output of &lt;code&gt;service inspect&lt;/code&gt; shows if your update paused due to failure:</source>
          <target state="translated">&lt;code&gt;service inspect&lt;/code&gt; 的输出显示更新是否由于失败而暂停：</target>
        </trans-unit>
        <trans-unit id="cce7e1017043a07f1dba87713af3ef3207ceec71" translate="yes" xml:space="preserve">
          <source>The output of the final &lt;code&gt;pwd&lt;/code&gt; command in this &lt;code&gt;Dockerfile&lt;/code&gt; would be &lt;code&gt;/a/b/c&lt;/code&gt;.</source>
          <target state="translated">最终的输出 &lt;code&gt;pwd&lt;/code&gt; 命令在这个 &lt;code&gt;Dockerfile&lt;/code&gt; 将是 &lt;code&gt;/a/b/c&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b5b0809469381a9d3d38b296dd33b48f8cf206a7" translate="yes" xml:space="preserve">
          <source>The output of the final &lt;code&gt;pwd&lt;/code&gt; command in this &lt;code&gt;Dockerfile&lt;/code&gt; would be &lt;code&gt;/path/$DIRNAME&lt;/code&gt;</source>
          <target state="translated">最终的输出 &lt;code&gt;pwd&lt;/code&gt; 命令在此 &lt;code&gt;Dockerfile&lt;/code&gt; 会 &lt;code&gt;/path/$DIRNAME&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="773e939704075237973f7c14690a3cee57cf3927" translate="yes" xml:space="preserve">
          <source>The output shows the &lt;code&gt;&amp;lt;CONTAINER-PORT&amp;gt;&lt;/code&gt; (labeled &lt;code&gt;TargetPort&lt;/code&gt;) from the containers and the &lt;code&gt;&amp;lt;PUBLISHED-PORT&amp;gt;&lt;/code&gt; (labeled &lt;code&gt;PublishedPort&lt;/code&gt;) where nodes listen for requests for the service.</source>
          <target state="translated">输出显示 &lt;code&gt;&amp;lt;CONTAINER-PORT&amp;gt;&lt;/code&gt; 中的&amp;lt;CONTAINER-PORT&amp;gt;（标记为 &lt;code&gt;TargetPort&lt;/code&gt; ）和 &lt;code&gt;&amp;lt;PUBLISHED-PORT&amp;gt;&lt;/code&gt; （标记为 &lt;code&gt;PublishedPort&lt;/code&gt; ），其中节点侦听服务请求。</target>
        </trans-unit>
        <trans-unit id="7b45be3f9ca95cc06eaa63157a9914673b94e68f" translate="yes" xml:space="preserve">
          <source>The output shows us the names of the tags available, the hex encoded sha256 digest of the image manifest associated with that tag, the size of the manifest, and the Notary role that signed this tag into the repository. The &amp;ldquo;targets&amp;rdquo; role is the most common role in a simple repository. When a repository has (or expects) to have collaborators, you may see other &amp;ldquo;delegated&amp;rdquo; roles listed as signers, based on the choice of the administrator as to how they organize their collaborators.</source>
          <target state="translated">输出结果显示了可用标签的名称，与该标签关联的图像清单的十六进制编码sha256摘要，清单的大小以及将该标签签名到存储库中的Notary角色。&amp;ldquo;目标&amp;rdquo;角色是简单存储库中最常见的角色。当存储库中有（或希望有）协作者时，您可能会根据管理员对协作者的组织方式的选择，看到其他&amp;ldquo;委派&amp;rdquo;角色被列为签名者。</target>
        </trans-unit>
        <trans-unit id="3a20f79e9ea92e3d5d042b3749d55e9fb231dda1" translate="yes" xml:space="preserve">
          <source>The overlay and overlay2 storage driver does not work as expected if the backing filesystem does not support &lt;code&gt;d_type&lt;/code&gt;. For example, XFS does not support &lt;code&gt;d_type&lt;/code&gt; if it is formatted with the &lt;code&gt;ftype=0&lt;/code&gt; option.</source>
          <target state="translated">如果后备文件系统不支持 &lt;code&gt;d_type&lt;/code&gt; ，则overlay和overlay2存储驱动程序将无法正常工作。例如，如果XFS 使用 &lt;code&gt;ftype=0&lt;/code&gt; 选项格式化，则不支持 &lt;code&gt;d_type&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6772401b9f59c7d3631574fc262b4cfd5c6fae97" translate="yes" xml:space="preserve">
          <source>The passphrases you chose for both the root key and your repository key should be randomly generated and stored in a password manager. Having the repository key allows users to sign image tags on a repository. Passphrases are used to encrypt your keys at rest and ensure that a lost laptop or an unintended backup doesn&amp;rsquo;t put the private key material at risk.</source>
          <target state="translated">您为根密钥和存储库密钥选择的密码短语应随机生成并存储在密码管理器中。拥有存储库密钥可以使用户在存储库上签名图像标签。密码短语用于加密您的静态密钥，并确保丢失的笔记本电脑或意外备份不会使私钥材料受到威胁。</target>
        </trans-unit>
        <trans-unit id="7921733af36283370ff2c7a3bafa55d215831e2e" translate="yes" xml:space="preserve">
          <source>The path to the certificate to use for HTTPS. Must be provided together with &lt;code&gt;tls_key_file&lt;/code&gt;, or not at all. If neither are provided, the server uses HTTP instead of HTTPS. The path is relative to the directory of the configuration file.</source>
          <target state="translated">用于HTTPS的证书的路径。必须与 &lt;code&gt;tls_key_file&lt;/code&gt; 一起提供，或完全不提供。如果两者均未提供，则服务器使用HTTP而不是HTTPS。该路径相对于配置文件的目录。</target>
        </trans-unit>
        <trans-unit id="d49a7cbb3325ee43f3655cca35361be16fa0ce11" translate="yes" xml:space="preserve">
          <source>The path to the certificate to use for HTTPS. The path is relative to the directory of the configuration file.</source>
          <target state="translated">用于HTTPS的证书的路径。该路径是相对于配置文件的目录。</target>
        </trans-unit>
        <trans-unit id="cc6fea9e413138463ad3caf57d146a91b37f385c" translate="yes" xml:space="preserve">
          <source>The path to the certificate to use for TLS mutual authentication. This must be provided together with &lt;code&gt;tls_client_key&lt;/code&gt; or not at all. The path is relative to the directory of the configuration file.</source>
          <target state="translated">用于TLS相互身份验证的证书的路径。这必须与 &lt;code&gt;tls_client_key&lt;/code&gt; 一起提供或完全不提供。该路径相对于配置文件的目录。</target>
        </trans-unit>
        <trans-unit id="a02fb0c3c553eaad6af5d8d6ce2860686b40be67" translate="yes" xml:space="preserve">
          <source>The path to the client certificate to use for mutual TLS with the Notary server. Must be provided along with &lt;code&gt;tls_client_key&lt;/code&gt; or not provided at all. The path is relative to the directory of the configuration file.</source>
          <target state="translated">与公证服务器相互TLS使用的客户端证书的路径。必须与 &lt;code&gt;tls_client_key&lt;/code&gt; 一起提供，或者根本不提供。该路径相对于配置文件的目录。</target>
        </trans-unit>
        <trans-unit id="02b50f36283fa77547334520ace19ee4dfcc4135" translate="yes" xml:space="preserve">
          <source>The path to the client key to use for mutual TLS with the Notary server. Must be provided along with &lt;code&gt;tls_client_cert&lt;/code&gt; or not provided at all. The path is relative to the directory of the configuration file.</source>
          <target state="translated">客户端密钥的路径，用于与公证服务器进行双向TLS。必须与 &lt;code&gt;tls_client_cert&lt;/code&gt; 一起提供，或者根本不提供。该路径相对于配置文件的目录。</target>
        </trans-unit>
        <trans-unit id="66ff566fdcbbd6d71352430ce6eeffddb0779a2d" translate="yes" xml:space="preserve">
          <source>The path to the file containing the root CA with which to verify the TLS certificate of the Notary server, for example if it is self-signed. The path is relative to the directory of the configuration file.</source>
          <target state="translated">包含根CA的文件的路径,用来验证公证服务器的TLS证书,例如,如果它是自签名的,那么这个文件的路径是相对于配置文件的目录。该路径是相对于配置文件的目录。</target>
        </trans-unit>
        <trans-unit id="8aaf5e7edd9c8cbc20272f7e43807aef90359eee" translate="yes" xml:space="preserve">
          <source>The path to the private key to use for HTTPS. Must be provided together with &lt;code&gt;tls_cert_file&lt;/code&gt;, or not at all. If neither are provided, the server uses HTTP instead of HTTPS. The path is relative to the directory of the configuration file.</source>
          <target state="translated">用于HTTPS的私钥的路径。必须与 &lt;code&gt;tls_cert_file&lt;/code&gt; 一起提供，或完全不提供。如果两者均未提供，则服务器使用HTTP而不是HTTPS。该路径相对于配置文件的目录。</target>
        </trans-unit>
        <trans-unit id="0e3be96cfe128a246a5170eecbbf92354b61abc2" translate="yes" xml:space="preserve">
          <source>The path to the private key to use for HTTPS. The path is relative to the directory of the configuration file.</source>
          <target state="translated">用于HTTPS的私钥的路径。该路径是相对于配置文件的目录。</target>
        </trans-unit>
        <trans-unit id="b1a4d713e0460af37af02f395caffe48a13e027a" translate="yes" xml:space="preserve">
          <source>The path to the private key to use for TLS mutual authentication. This must be provided together with &lt;code&gt;tls_client_cert&lt;/code&gt; or not at all. The path is relative to the directory of the configuration file.</source>
          <target state="translated">用于TLS相互认证的私钥的路径。必须与 &lt;code&gt;tls_client_cert&lt;/code&gt; 一起提供或完全不提供。该路径相对于配置文件的目录。</target>
        </trans-unit>
        <trans-unit id="6ecca1195ce455667b656022d75de39ecdf3c877" translate="yes" xml:space="preserve">
          <source>The path to the root CA that signed the TLS certificate of the remote service. This parameter must be provided if said root CA is not in the system's default trust roots. The path is relative to the directory of the configuration file.</source>
          <target state="translated">签署远程服务TLS证书的根CA的路径。如果根CA不在系统默认的信任根目录中,则必须提供该参数。该路径是相对于配置文件的目录。</target>
        </trans-unit>
        <trans-unit id="012c2ffec87ed472da3d4617f62f9c1d29fe053d" translate="yes" xml:space="preserve">
          <source>The placement constraint you put on the Redis service, ensuring that it always uses the same host.</source>
          <target state="translated">你在Redis服务上设置的位置约束,确保它始终使用同一个主机。</target>
        </trans-unit>
        <trans-unit id="cf5772e3d94707e32a722854b385febbff079284" translate="yes" xml:space="preserve">
          <source>The placement of &lt;code&gt;!&lt;/code&gt; exception rules influences the behavior: the last line of the &lt;code&gt;.dockerignore&lt;/code&gt; that matches a particular file determines whether it is included or excluded. Consider the following example:</source>
          <target state="translated">的位置 &lt;code&gt;!&lt;/code&gt; 异常规则会影响行为： &lt;code&gt;.dockerignore&lt;/code&gt; 的与特定文件匹配的最后一行确定是包含还是排除该文件。考虑以下示例：</target>
        </trans-unit>
        <trans-unit id="c7b6aeb70321b0532d875f81f564375bb56ed249" translate="yes" xml:space="preserve">
          <source>The plugin can subsequently be enabled for local use or pushed to the public registry.</source>
          <target state="translated">随后可以启用插件,供本地使用或推送到公共注册表。</target>
        </trans-unit>
        <trans-unit id="5681b06ba81b98e56e671eda1bf016a361f78c9c" translate="yes" xml:space="preserve">
          <source>The plugin must support two authorization messages formats, one from the daemon to the plugin and then from the plugin to the daemon. The tables below detail the content expected in each message.</source>
          <target state="translated">插件必须支持两种授权消息格式,一种是从守护进程到插件,然后从插件到守护进程。下表详细说明了每条消息中的预期内容。</target>
        </trans-unit>
        <trans-unit id="bf479528d3c864f40b34e6e8a8b256f60574b3aa" translate="yes" xml:space="preserve">
          <source>The plugin requests 2 privileges:</source>
          <target state="translated">该插件请求2个权限。</target>
        </trans-unit>
        <trans-unit id="20591766ace52f6ea09ec3a0f14b31599830c93a" translate="yes" xml:space="preserve">
          <source>The port number inside the container (where the service listens) does not need to match the port number exposed on the outside of the container (where clients connect). For example, inside the container an HTTP service is listening on port 80 (and so the image developer specifies &lt;code&gt;EXPOSE 80&lt;/code&gt; in the Dockerfile). At runtime, the port might be bound to 42800 on the host. To find the mapping between the host ports and the exposed ports, use &lt;code&gt;docker port&lt;/code&gt;.</source>
          <target state="translated">容器内部（服务在其中进行侦听的端口）的端口号无需与容器外部（客户端在其中进行连接）的外部端口号匹配。例如，在容器内，HTTP服务正在端口80上侦听（因此映像开发人员在Dockerfile中指定 &lt;code&gt;EXPOSE 80&lt;/code&gt; ）。在运行时，端口可能绑定到主机上的42800。要查找主机端口和公开端口之间的映射，请使用 &lt;code&gt;docker port&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="04ec18e0ed519d31508f51c1d0dad20602cec320" translate="yes" xml:space="preserve">
          <source>The port that SSH is running on, needed for Docker Machine to provision the Linode.</source>
          <target state="translated">SSH运行的端口,是Docker Machine配置Linode所需要的。</target>
        </trans-unit>
        <trans-unit id="fe1e329bc037c6d750a15b68d6244ffce06f9b6a" translate="yes" xml:space="preserve">
          <source>The preceding example illustrates a request to add the delegation &lt;code&gt;targets/releases&lt;/code&gt; to the GUN &lt;code&gt;example.com/collection&lt;/code&gt;. The delegation name must be prefixed by &lt;code&gt;targets/&lt;/code&gt; to be valid, since all delegations are restricted versions of the target role. The command adds the public key contained in the x509 cert &lt;code&gt;cert.pem&lt;/code&gt; to the &lt;code&gt;targets/releases&lt;/code&gt; delegation.</source>
          <target state="translated">前面的示例说明了将委托 &lt;code&gt;targets/releases&lt;/code&gt; 添加到GUN &lt;code&gt;example.com/collection&lt;/code&gt; 的请求。委托名称必须以 &lt;code&gt;targets/&lt;/code&gt; 为前缀，以使其有效，因为所有委托都是目标角色的受限版本。该命令将x509 cert &lt;code&gt;cert.pem&lt;/code&gt; 中包含的公钥添加到 &lt;code&gt;targets/releases&lt;/code&gt; 委托。</target>
        </trans-unit>
        <trans-unit id="2cf6cb209a774a788b51f43415e140aebd8f49cb" translate="yes" xml:space="preserve">
          <source>The preceding example is operating-system specific and is for illustrative purposes only. You should consult your operating system documentation for creating an os-provided bundled certificate chain.</source>
          <target state="translated">前面的例子是特定于操作系统的,仅作说明用途。你应该查阅你的操作系统文档来创建 os 提供的捆绑证书链。</target>
        </trans-unit>
        <trans-unit id="75050ce3b960d53c3dbe585963f55bbcb50f66d5" translate="yes" xml:space="preserve">
          <source>The prerequisites are:</source>
          <target state="translated">先决条件是:</target>
        </trans-unit>
        <trans-unit id="d512ca933bd80757c1dfdd90d2ebb6e19763954d" translate="yes" xml:space="preserve">
          <source>The presence of one or more &lt;code&gt;&amp;lt;filename&amp;gt;.key/cert&lt;/code&gt; pairs indicates to Docker that there are custom certificates required for access to the desired repository.</source>
          <target state="translated">一个或多个 &lt;code&gt;&amp;lt;filename&amp;gt;.key/cert&lt;/code&gt; 对的存在向Docker指示需要访问所需存储库的自定义证书。</target>
        </trans-unit>
        <trans-unit id="64d88377cebbf31910a31e90c8d322de508c55c5" translate="yes" xml:space="preserve">
          <source>The problem is that Swarm might first schedule &lt;code&gt;bar&lt;/code&gt; and &lt;code&gt;baz&lt;/code&gt; on different nodes (since they&amp;rsquo;re not dependent on one another), making it impossible to pick an appropriate node for &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">问题在于Swarm可能会首先在不同的节点上调度 &lt;code&gt;bar&lt;/code&gt; 和 &lt;code&gt;baz&lt;/code&gt; （因为它们彼此不依赖），从而无法为 &lt;code&gt;foo&lt;/code&gt; 选择合适的节点。</target>
        </trans-unit>
        <trans-unit id="b8b8984e1b09d38e20dadc2233b45e65257a854a" translate="yes" xml:space="preserve">
          <source>The problem of waiting for a database (for example) to be ready is really just a subset of a much larger problem of distributed systems. In production, your database could become unavailable or move hosts at any time. Your application needs to be resilient to these types of failures.</source>
          <target state="translated">等待数据库(例如)准备好的问题其实只是分布式系统一个更大问题的子集。在生产中,你的数据库随时可能变得不可用或移动主机。你的应用程序需要对这些类型的故障具有弹性。</target>
        </trans-unit>
        <trans-unit id="bfe05733ac9969fdef95ebcf6c7d8018f77d417f" translate="yes" xml:space="preserve">
          <source>The property &lt;code&gt;HttpHeaders&lt;/code&gt; specifies a set of headers to include in all messages sent from the Docker client to the daemon. Docker does not try to interpret or understand these header; it simply puts them into the messages. Docker does not allow these headers to change any headers it sets for itself.</source>
          <target state="translated">&lt;code&gt;HttpHeaders&lt;/code&gt; 属性指定一组标头，以包含在从Docker客户端发送到守护程序的所有消息中。Docker不会尝试解释或理解这些标头。它只是将它们放入消息中。Docker不允许这些标头更改其为其设置的任何标头。</target>
        </trans-unit>
        <trans-unit id="f899e49371710fd9560f2e9b26b6c551e9faa588" translate="yes" xml:space="preserve">
          <source>The property &lt;code&gt;configFormat&lt;/code&gt; specifies the default format for &lt;code&gt;docker config ls&lt;/code&gt; output. When the &lt;code&gt;--format&lt;/code&gt; flag is not provided with the &lt;code&gt;docker config ls&lt;/code&gt; command, Docker&amp;rsquo;s client uses this property. If this property is not set, the client falls back to the default table format. For a list of supported formatting directives, see &lt;a href=&quot;../config_ls/index&quot;&gt;&lt;strong&gt;Formatting&lt;/strong&gt; section in the &lt;code&gt;docker config ls&lt;/code&gt; documentation&lt;/a&gt;</source>
          <target state="translated">属性 &lt;code&gt;configFormat&lt;/code&gt; 指定docker &lt;code&gt;docker config ls&lt;/code&gt; 输出的默认格式。如果 &lt;code&gt;--format&lt;/code&gt; &lt;code&gt;docker config ls&lt;/code&gt; 命令未提供--format标志，则Docker的客户端使用此属性。如果未设置此属性，则客户端将回退到默认表格式。有关受支持的格式指令的列表，请参阅&lt;a href=&quot;../config_ls/index&quot;&gt; &lt;code&gt;docker config ls&lt;/code&gt; &lt;/a&gt;文档中的&amp;ldquo; &lt;strong&gt;格式&amp;rdquo;&lt;/strong&gt;部分。</target>
        </trans-unit>
        <trans-unit id="ff2c161f1c8c1f61a5754a04ce5dff50f47e7bde" translate="yes" xml:space="preserve">
          <source>The property &lt;code&gt;credHelpers&lt;/code&gt; specifies a set of credential helpers to use preferentially over &lt;code&gt;credsStore&lt;/code&gt; or &lt;code&gt;auths&lt;/code&gt; when storing and retrieving credentials for specific registries. If this property is set, the binary &lt;code&gt;docker-credential-&amp;lt;value&amp;gt;&lt;/code&gt; will be used when storing or retrieving credentials for a specific registry. For more information, see the &lt;a href=&quot;../login/index#credential-helpers&quot;&gt;&lt;strong&gt;Credential helpers&lt;/strong&gt; section in the &lt;code&gt;docker login&lt;/code&gt; documentation&lt;/a&gt;</source>
          <target state="translated">属性 &lt;code&gt;credHelpers&lt;/code&gt; 指定了一组凭据助手，在存储和检索特定注册表的凭据时，它们优先于 &lt;code&gt;credsStore&lt;/code&gt; 或 &lt;code&gt;auths&lt;/code&gt; 使用。如果设置了此属性，则在存储或检索特定注册表的凭据时将使用二进制 &lt;code&gt;docker-credential-&amp;lt;value&amp;gt;&lt;/code&gt; 。有关更多信息，请参阅&lt;a href=&quot;../login/index#credential-helpers&quot;&gt; &lt;code&gt;docker login&lt;/code&gt; &lt;/a&gt;文档中的 &amp;ldquo; &lt;strong&gt;凭据帮助器&amp;rdquo;&lt;/strong&gt;部分。</target>
        </trans-unit>
        <trans-unit id="885b94cb03ea1c65dc63a5fec3733d6e66bdee06" translate="yes" xml:space="preserve">
          <source>The property &lt;code&gt;credsStore&lt;/code&gt; specifies an external binary to serve as the default credential store. When this property is set, &lt;code&gt;docker login&lt;/code&gt; will attempt to store credentials in the binary specified by &lt;code&gt;docker-credential-&amp;lt;value&amp;gt;&lt;/code&gt; which is visible on &lt;code&gt;$PATH&lt;/code&gt;. If this property is not set, credentials will be stored in the &lt;code&gt;auths&lt;/code&gt; property of the config. For more information, see the &lt;a href=&quot;../login/index#credentials-store&quot;&gt;&lt;strong&gt;Credentials store&lt;/strong&gt; section in the &lt;code&gt;docker login&lt;/code&gt; documentation&lt;/a&gt;</source>
          <target state="translated">属性 &lt;code&gt;credsStore&lt;/code&gt; 指定一个外部二进制文件作为默认凭据存储。设置此属性后， &lt;code&gt;docker login&lt;/code&gt; 将尝试将凭据存储在 &lt;code&gt;$PATH&lt;/code&gt; 上可见的 &lt;code&gt;docker-credential-&amp;lt;value&amp;gt;&lt;/code&gt; 指定的二进制文件中。如果未设置此属性，则凭据将存储在配置的 &lt;code&gt;auths&lt;/code&gt; 属性中。有关更多信息，请参阅&lt;a href=&quot;../login/index#credentials-store&quot;&gt; &lt;code&gt;docker login&lt;/code&gt; &lt;/a&gt;文档中的 &amp;ldquo; &lt;strong&gt;凭据存储&amp;rdquo;&lt;/strong&gt;部分。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="032d9de0808ce12e78a3473ef97c2fc00382a217" translate="yes" xml:space="preserve">
          <source>The property &lt;code&gt;imagesFormat&lt;/code&gt; specifies the default format for &lt;code&gt;docker images&lt;/code&gt; output. When the &lt;code&gt;--format&lt;/code&gt; flag is not provided with the &lt;code&gt;docker images&lt;/code&gt; command, Docker&amp;rsquo;s client uses this property. If this property is not set, the client falls back to the default table format. For a list of supported formatting directives, see the &lt;a href=&quot;../images/index&quot;&gt;&lt;strong&gt;Formatting&lt;/strong&gt; section in the &lt;code&gt;docker images&lt;/code&gt; documentation&lt;/a&gt;</source>
          <target state="translated">属性 &lt;code&gt;imagesFormat&lt;/code&gt; 指定docker &lt;code&gt;docker images&lt;/code&gt; 输出的默认格式。如果 &lt;code&gt;--format&lt;/code&gt; &lt;code&gt;docker images&lt;/code&gt; 命令未提供--format标志，则Docker的客户端使用此属性。如果未设置此属性，则客户端将回退到默认表格式。有关受支持的格式设置指令的列表，请参阅&lt;a href=&quot;../images/index&quot;&gt; &lt;code&gt;docker images&lt;/code&gt; &lt;/a&gt;文档中的 &amp;ldquo; &lt;strong&gt;格式设置&amp;rdquo;&lt;/strong&gt;部分。</target>
        </trans-unit>
        <trans-unit id="f9762ebf835e6bb935778d6f32521ace476e942d" translate="yes" xml:space="preserve">
          <source>The property &lt;code&gt;nodesFormat&lt;/code&gt; specifies the default format for &lt;code&gt;docker node ls&lt;/code&gt; output. When the &lt;code&gt;--format&lt;/code&gt; flag is not provided with the &lt;code&gt;docker node ls&lt;/code&gt; command, Docker&amp;rsquo;s client uses the value of &lt;code&gt;nodesFormat&lt;/code&gt;. If the value of &lt;code&gt;nodesFormat&lt;/code&gt; is not set, the client uses the default table format. For a list of supported formatting directives, see the &lt;a href=&quot;../node_ls/index&quot;&gt;&lt;strong&gt;Formatting&lt;/strong&gt; section in the &lt;code&gt;docker node ls&lt;/code&gt; documentation&lt;/a&gt;</source>
          <target state="translated">属性 &lt;code&gt;nodesFormat&lt;/code&gt; 指定docker &lt;code&gt;docker node ls&lt;/code&gt; 输出的默认格式。当 &lt;code&gt;nodesFormat&lt;/code&gt; &lt;code&gt;docker node ls&lt;/code&gt; 命令未提供 &lt;code&gt;--format&lt;/code&gt; 标志时，Docker的客户端使用nodeFormat的值。如果未设置 &lt;code&gt;nodesFormat&lt;/code&gt; 的值，则客户端将使用默认表格式。有关受支持的格式指令的列表，请参阅&lt;a href=&quot;../node_ls/index&quot;&gt; &lt;code&gt;docker node ls&lt;/code&gt; &lt;/a&gt;文档中的 &amp;ldquo; &lt;strong&gt;格式&amp;rdquo;&lt;/strong&gt;部分。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="674252cd16d5395c7c486b5e598ef4d29bd15baf" translate="yes" xml:space="preserve">
          <source>The property &lt;code&gt;plugins&lt;/code&gt; contains settings specific to CLI plugins. The key is the plugin name, while the value is a further map of options, which are specific to that plugin.</source>
          <target state="translated">属性 &lt;code&gt;plugins&lt;/code&gt; 包含特定于CLI插件的设置。关键是插件名称，而值是该插件特有的选项的进一步映射。</target>
        </trans-unit>
        <trans-unit id="16b6f754562d22b95673706648cf3297c4642803" translate="yes" xml:space="preserve">
          <source>The property &lt;code&gt;pluginsFormat&lt;/code&gt; specifies the default format for &lt;code&gt;docker plugin ls&lt;/code&gt; output. When the &lt;code&gt;--format&lt;/code&gt; flag is not provided with the &lt;code&gt;docker plugin ls&lt;/code&gt; command, Docker&amp;rsquo;s client uses this property. If this property is not set, the client falls back to the default table format. For a list of supported formatting directives, see the &lt;a href=&quot;../plugin_ls/index&quot;&gt;&lt;strong&gt;Formatting&lt;/strong&gt; section in the &lt;code&gt;docker plugin ls&lt;/code&gt; documentation&lt;/a&gt;</source>
          <target state="translated">属性 &lt;code&gt;pluginsFormat&lt;/code&gt; 指定docker &lt;code&gt;docker plugin ls&lt;/code&gt; 输出的默认格式。如果 &lt;code&gt;--format&lt;/code&gt; &lt;code&gt;docker plugin ls&lt;/code&gt; 命令未提供--format标志，则Docker的客户端使用此属性。如果未设置此属性，则客户端将回退到默认表格式。有关受支持的格式指令的列表，请参阅&lt;a href=&quot;../plugin_ls/index&quot;&gt; &lt;code&gt;docker plugin ls&lt;/code&gt; &lt;/a&gt;文档中的 &amp;ldquo; &lt;strong&gt;格式&amp;rdquo;&lt;/strong&gt;部分。</target>
        </trans-unit>
        <trans-unit id="0d665772e5032d12e09e20305b4804b9de1d1bb7" translate="yes" xml:space="preserve">
          <source>The property &lt;code&gt;psFormat&lt;/code&gt; specifies the default format for &lt;code&gt;docker ps&lt;/code&gt; output. When the &lt;code&gt;--format&lt;/code&gt; flag is not provided with the &lt;code&gt;docker ps&lt;/code&gt; command, Docker&amp;rsquo;s client uses this property. If this property is not set, the client falls back to the default table format. For a list of supported formatting directives, see the &lt;a href=&quot;../ps/index&quot;&gt;&lt;strong&gt;Formatting&lt;/strong&gt; section in the &lt;code&gt;docker ps&lt;/code&gt; documentation&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;psFormat&lt;/code&gt; 属性指定docker &lt;code&gt;docker ps&lt;/code&gt; 输出的默认格式。如果 &lt;code&gt;--format&lt;/code&gt; &lt;code&gt;docker ps&lt;/code&gt; 命令未提供--format标志，则Docker的客户端使用此属性。如果未设置此属性，则客户端将回退到默认表格式。有关受支持的格式指令的列表，请参阅&lt;a href=&quot;../ps/index&quot;&gt; &lt;code&gt;docker ps&lt;/code&gt; &lt;/a&gt;文档中的 &amp;ldquo; &lt;strong&gt;格式&amp;rdquo;&lt;/strong&gt;部分。</target>
        </trans-unit>
        <trans-unit id="9c29241435344425768990fdbce634092e6914be" translate="yes" xml:space="preserve">
          <source>The property &lt;code&gt;secretFormat&lt;/code&gt; specifies the default format for &lt;code&gt;docker secret ls&lt;/code&gt; output. When the &lt;code&gt;--format&lt;/code&gt; flag is not provided with the &lt;code&gt;docker secret ls&lt;/code&gt; command, Docker&amp;rsquo;s client uses this property. If this property is not set, the client falls back to the default table format. For a list of supported formatting directives, see &lt;a href=&quot;../secret_ls/index&quot;&gt;&lt;strong&gt;Formatting&lt;/strong&gt; section in the &lt;code&gt;docker secret ls&lt;/code&gt; documentation&lt;/a&gt;</source>
          <target state="translated">属性 &lt;code&gt;secretFormat&lt;/code&gt; 指定docker &lt;code&gt;docker secret ls&lt;/code&gt; 输出的默认格式。如果 &lt;code&gt;--format&lt;/code&gt; &lt;code&gt;docker secret ls&lt;/code&gt; 命令未提供--format标志，则Docker的客户端使用此属性。如果未设置此属性，则客户端将回退到默认表格式。有关受支持的格式设置指令的列表，请参阅&lt;a href=&quot;../secret_ls/index&quot;&gt; &lt;code&gt;docker secret ls&lt;/code&gt; &lt;/a&gt;文档中的&amp;ldquo; &lt;strong&gt;格式设置&amp;rdquo;&lt;/strong&gt;部分</target>
        </trans-unit>
        <trans-unit id="15f10e024d87a5aa3c77ccceee942e55fd612be9" translate="yes" xml:space="preserve">
          <source>The property &lt;code&gt;serviceInspectFormat&lt;/code&gt; specifies the default format for &lt;code&gt;docker service inspect&lt;/code&gt; output. When the &lt;code&gt;--format&lt;/code&gt; flag is not provided with the &lt;code&gt;docker service inspect&lt;/code&gt; command, Docker&amp;rsquo;s client uses this property. If this property is not set, the client falls back to the default json format. For a list of supported formatting directives, see the &lt;a href=&quot;../service_inspect/index&quot;&gt;&lt;strong&gt;Formatting&lt;/strong&gt; section in the &lt;code&gt;docker service inspect&lt;/code&gt; documentation&lt;/a&gt;</source>
          <target state="translated">属性 &lt;code&gt;serviceInspectFormat&lt;/code&gt; 指定 &lt;code&gt;docker service inspect&lt;/code&gt; 输出的默认格式。如果 &lt;code&gt;--format&lt;/code&gt; &lt;code&gt;docker service inspect&lt;/code&gt; 命令未提供--format标志，则Docker的客户端使用此属性。如果未设置此属性，则客户端将使用默认的json格式。有关受支持的格式设置指令的列表，请参阅&lt;a href=&quot;../service_inspect/index&quot;&gt; &lt;code&gt;docker service inspect&lt;/code&gt; &lt;/a&gt;文档中的 &amp;ldquo; &lt;strong&gt;格式设置&amp;rdquo;&lt;/strong&gt;部分。</target>
        </trans-unit>
        <trans-unit id="cbcbb8f8b6af8aebd036d17bda4cead916d2fab7" translate="yes" xml:space="preserve">
          <source>The property &lt;code&gt;servicesFormat&lt;/code&gt; specifies the default format for &lt;code&gt;docker service ls&lt;/code&gt; output. When the &lt;code&gt;--format&lt;/code&gt; flag is not provided with the &lt;code&gt;docker service ls&lt;/code&gt; command, Docker&amp;rsquo;s client uses this property. If this property is not set, the client falls back to the default json format. For a list of supported formatting directives, see the &lt;a href=&quot;../service_ls/index&quot;&gt;&lt;strong&gt;Formatting&lt;/strong&gt; section in the &lt;code&gt;docker service ls&lt;/code&gt; documentation&lt;/a&gt;</source>
          <target state="translated">属性 &lt;code&gt;servicesFormat&lt;/code&gt; 指定 &lt;code&gt;docker service ls&lt;/code&gt; 输出的默认格式。如果 &lt;code&gt;--format&lt;/code&gt; &lt;code&gt;docker service ls&lt;/code&gt; 命令未提供--format标志，则Docker的客户端使用此属性。如果未设置此属性，则客户端将使用默认的json格式。有关受支持的格式指令的列表，请参阅&lt;a href=&quot;../service_ls/index&quot;&gt; &lt;code&gt;docker service ls&lt;/code&gt; &lt;/a&gt;文档中的 &amp;ldquo; &lt;strong&gt;格式&amp;rdquo;&lt;/strong&gt;部分。</target>
        </trans-unit>
        <trans-unit id="29f7b59bf05268406aa48e6182f276000bba09a6" translate="yes" xml:space="preserve">
          <source>The property &lt;code&gt;stackOrchestrator&lt;/code&gt; specifies the default orchestrator to use when running &lt;code&gt;docker stack&lt;/code&gt; management commands. Valid values are &lt;code&gt;&quot;swarm&quot;&lt;/code&gt;, &lt;code&gt;&quot;kubernetes&quot;&lt;/code&gt;, and &lt;code&gt;&quot;all&quot;&lt;/code&gt;. This property can be overridden with the &lt;code&gt;DOCKER_STACK_ORCHESTRATOR&lt;/code&gt; environment variable, or the &lt;code&gt;--orchestrator&lt;/code&gt; flag.</source>
          <target state="translated">属性 &lt;code&gt;stackOrchestrator&lt;/code&gt; 指定运行docker &lt;code&gt;docker stack&lt;/code&gt; management命令时要使用的默认协调器。有效值为 &lt;code&gt;&quot;swarm&quot;&lt;/code&gt; ， &lt;code&gt;&quot;kubernetes&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;all&quot;&lt;/code&gt; 。可以使用 &lt;code&gt;DOCKER_STACK_ORCHESTRATOR&lt;/code&gt; 环境变量或 &lt;code&gt;--orchestrator&lt;/code&gt; 标志覆盖此属性。</target>
        </trans-unit>
        <trans-unit id="89096068ab98f54e8022d62790125f24ecea93c3" translate="yes" xml:space="preserve">
          <source>The property &lt;code&gt;statsFormat&lt;/code&gt; specifies the default format for &lt;code&gt;docker stats&lt;/code&gt; output. When the &lt;code&gt;--format&lt;/code&gt; flag is not provided with the &lt;code&gt;docker stats&lt;/code&gt; command, Docker&amp;rsquo;s client uses this property. If this property is not set, the client falls back to the default table format. For a list of supported formatting directives, see &lt;a href=&quot;../stats/index&quot;&gt;&lt;strong&gt;Formatting&lt;/strong&gt; section in the &lt;code&gt;docker stats&lt;/code&gt; documentation&lt;/a&gt;</source>
          <target state="translated">属性 &lt;code&gt;statsFormat&lt;/code&gt; 指定docker &lt;code&gt;docker stats&lt;/code&gt; 输出的默认格式。如果 &lt;code&gt;--format&lt;/code&gt; &lt;code&gt;docker stats&lt;/code&gt; 命令未提供--format标志，则Docker的客户端使用此属性。如果未设置此属性，则客户端将回退到默认表格式。有关受支持的格式设置指令的列表，请参阅&lt;a href=&quot;../stats/index&quot;&gt; &lt;code&gt;docker stats&lt;/code&gt; &lt;/a&gt;文档中的&amp;ldquo; &lt;strong&gt;格式设置&amp;rdquo;&lt;/strong&gt;部分</target>
        </trans-unit>
        <trans-unit id="7e8d8488bd5aeca71220fc57ade98ba0396970b3" translate="yes" xml:space="preserve">
          <source>The proportion will only apply when CPU-intensive processes are running. When tasks in one container are idle, other containers can use the left-over CPU time. The actual amount of CPU time will vary depending on the number of containers running on the system.</source>
          <target state="translated">该比例仅在CPU密集型进程运行时适用。当一个容器中的任务处于空闲状态时,其他容器可以使用剩余的CPU时间。实际的CPU时间将根据系统上运行的容器数量而变化。</target>
        </trans-unit>
        <trans-unit id="29dd043bdbec42216466734cc457a5eb41e7e1d3" translate="yes" xml:space="preserve">
          <source>The protocol to use,</source>
          <target state="translated">要使用的协议;</target>
        </trans-unit>
        <trans-unit id="dd4801f0adeb0b0c444ff1a77d62156fc4876952" translate="yes" xml:space="preserve">
          <source>The pull did not complete because the trust system couldn&amp;rsquo;t verify the image.</source>
          <target state="translated">由于信任系统无法验证映像，因此拉动未完成。</target>
        </trans-unit>
        <trans-unit id="05fbaf65a8c8a13a9ab566a2ba1e79a9e9e03a05" translate="yes" xml:space="preserve">
          <source>The quickest way to spin up a full Notary service for testing and development purposes is to use the Docker compose file in the &lt;a href=&quot;https://github.com/docker/notary&quot;&gt;Notary project&lt;/a&gt;.</source>
          <target state="translated">为测试和开发目的启动完整的Notary服务的最快方法是在&lt;a href=&quot;https://github.com/docker/notary&quot;&gt;Notary项目中&lt;/a&gt;使用Docker compose文件。</target>
        </trans-unit>
        <trans-unit id="03aafb92ef99d26e58b4c2893ae4d7e8464a53d1" translate="yes" xml:space="preserve">
          <source>The rate, parallelism, and other parameters of a rollback operation are determined by the values passed with the following flags:</source>
          <target state="translated">回滚操作的速率、并行度和其他参数由以下标志传递的值决定。</target>
        </trans-unit>
        <trans-unit id="b246231e5b5b3d634a215da1c5bd509904d947a5" translate="yes" xml:space="preserve">
          <source>The reason both IP addresses work is that nodes in a swarm participate in an ingress &lt;strong&gt;routing mesh&lt;/strong&gt;. This ensures that a service deployed at a certain port within your swarm always has that port reserved to itself, no matter what node is actually running the container. Here&amp;rsquo;s a diagram of how a routing mesh for a service called &lt;code&gt;my-web&lt;/code&gt; published at port &lt;code&gt;8080&lt;/code&gt; on a three-node swarm would look:</source>
          <target state="translated">这两个IP地址都起作用的原因是，群集中的节点参与了入口&lt;strong&gt;路由网格&lt;/strong&gt;。这样可以确保在群集内某个端口上部署的服务始终为其保留该端口，而不管容器实际上在运行哪个节点。这是一个在三节点 &lt;code&gt;8080&lt;/code&gt; 上的端口8080上发布的名为 &lt;code&gt;my-web&lt;/code&gt; 的服务的路由网格的外观图：</target>
        </trans-unit>
        <trans-unit id="9ca58fbbf0c45fb062cd8ba7663e5e2b086da215" translate="yes" xml:space="preserve">
          <source>The reason why &lt;em&gt;Docker swarm mode&lt;/em&gt; is using a consensus algorithm is to make sure that all the manager nodes that are in charge of managing and scheduling tasks in the cluster, are storing the same consistent state.</source>
          <target state="translated">为什么原因&lt;em&gt;泊坞窗群模式&lt;/em&gt;是使用一个共识算法，以确保那些负责在集群中的管理和调度任务的所有经理节点，都存储相同一致的状态。</target>
        </trans-unit>
        <trans-unit id="2a7ec2d9119bc0f68a55c5feb705fb7e586a2482" translate="yes" xml:space="preserve">
          <source>The reference used to push/pull from a registry</source>
          <target state="translated">用于从登记册中推/拉的参考资料</target>
        </trans-unit>
        <trans-unit id="7569bc34bfdbd4a5889b6033671a33e7ec2584e5" translate="yes" xml:space="preserve">
          <source>The remaining steps in the tutorial don&amp;rsquo;t use the &lt;code&gt;helloworld&lt;/code&gt; service, so now you can delete the service from the swarm.</source>
          <target state="translated">本教程中的其余步骤不使用 &lt;code&gt;helloworld&lt;/code&gt; 服务，因此现在您可以从群中删除该服务。</target>
        </trans-unit>
        <trans-unit id="7ab5290c1463fb3de227a57f2d281e7f50e898ee" translate="yes" xml:space="preserve">
          <source>The remapping itself is handled by two files: &lt;code&gt;/etc/subuid&lt;/code&gt; and &lt;code&gt;/etc/subgid&lt;/code&gt;. Each file works the same, but one is concerned with the user ID range, and the other with the group ID range. Consider the following entry in &lt;code&gt;/etc/subuid&lt;/code&gt;:</source>
          <target state="translated">重新映射本身由两个文件处理： &lt;code&gt;/etc/subuid&lt;/code&gt; 和 &lt;code&gt;/etc/subgid&lt;/code&gt; 。每个文件的工作原理相同，但一个文件与用户ID范围有关，另一个文件与组ID范围有关。考虑 &lt;code&gt;/etc/subuid&lt;/code&gt; 中的以下条目：</target>
        </trans-unit>
        <trans-unit id="5bf3a365f9776118fbc56e14043d665fdcb36273" translate="yes" xml:space="preserve">
          <source>The reporting section contains any configuration for useful for running the service, such as reporting errors. Currently, Notary only supports reporting errors to &lt;a href=&quot;https://bugsnag.com&quot;&gt;Bugsnag&lt;/a&gt;.</source>
          <target state="translated">报告部分包含对运行服务有用的任何配置，例如报告错误。目前，&lt;a href=&quot;https://bugsnag.com&quot;&gt;Notary&lt;/a&gt;仅支持向Bugsnag报告错误。</target>
        </trans-unit>
        <trans-unit id="c88d2ba2ed2816515b29f747a56198118252a7d7" translate="yes" xml:space="preserve">
          <source>The root CA rotation will not be completed until all registered nodes have rotated their TLS certificates. If the rotation is not completing within a reasonable amount of time, try running &lt;code&gt;docker node ls --format '{{.ID}} {{.Hostname}} {{.Status}} {{.TLSStatus}}'&lt;/code&gt; to see if any nodes are down or otherwise unable to rotate TLS certificates.</source>
          <target state="translated">直到所有注册的节点都旋转了其TLS证书后，根CA的旋转才会完成。如果轮换未在合理的时间内完成，请尝试运行 &lt;code&gt;docker node ls --format '{{.ID}} {{.Hostname}} {{.Status}} {{.TLSStatus}}'&lt;/code&gt; 以查看是否任何节点都已关闭或无法旋转TLS证书。</target>
        </trans-unit>
        <trans-unit id="465cc3be871925b74afbbcaa771fbc172146cce6" translate="yes" xml:space="preserve">
          <source>The root and targets key are generated and stored locally client-side.</source>
          <target state="translated">根密钥和目标密钥在客户端本地生成并存储。</target>
        </trans-unit>
        <trans-unit id="eb3fbf76706a263fc41ee7f0e5b3732ad52454f6" translate="yes" xml:space="preserve">
          <source>The root certificate to trust for mutual authentication. If provided, any clients connecting to Notary signer need a client certificate signed by this root. If not provided, mutual authentication is not required. The path is relative to the directory of the configuration file.</source>
          <target state="translated">用于相互认证的根证书。如果提供,任何连接到公证签名人的客户端都需要由该根证书签署的客户端证书。如果没有提供,则不需要相互认证。这个路径是相对于配置文件的目录而言的。</target>
        </trans-unit>
        <trans-unit id="b91ee6325038098e40965654c5b58f973a1c04a0" translate="yes" xml:space="preserve">
          <source>The root key is the root of all trust. It signs the &lt;a href=&quot;https://github.com/theupdateframework/tuf/blob/1bed3e09a478c2c918ffbff10b9118f6e52ee129/docs/tuf-spec.txt#L489&quot;&gt;root metadata file&lt;/a&gt;, which lists the IDs of the root, targets, snapshot, and timestamp public keys. Clients use these public keys to verify the signatures on all the metadata files in the repository. This key is held by a collection owner, and should be kept offline and safe, more so than any other key.</source>
          <target state="translated">根密钥是所有信任的根。它签署了&lt;a href=&quot;https://github.com/theupdateframework/tuf/blob/1bed3e09a478c2c918ffbff10b9118f6e52ee129/docs/tuf-spec.txt#L489&quot;&gt;根元数据文件&lt;/a&gt;，该文件列出了根，目标，快照和时间戳公共密钥的ID。客户端使用这些公共密钥来验证存储库中所有元数据文件上的签名。该密钥由馆藏所有者持有，并且应保持离线状态和安全性，比其他任何密钥都要重要。</target>
        </trans-unit>
        <trans-unit id="b295f881568376eb1d80d57cee88cfe5b7c2bfe9" translate="yes" xml:space="preserve">
          <source>The root/offline key passphrase</source>
          <target state="translated">根/离线密钥口令</target>
        </trans-unit>
        <trans-unit id="8102a636a624047ab10c86d269bc0df4dae6624a" translate="yes" xml:space="preserve">
          <source>The rootfs directory</source>
          <target state="translated">rootfs目录</target>
        </trans-unit>
        <trans-unit id="a8adc27400fa9d16cf99f74a14e6a34821d755bf" translate="yes" xml:space="preserve">
          <source>The routing mesh listens on the published port for any IP address assigned to the node. For externally routable IP addresses, the port is available from outside the host. For all other IP addresses the access is only available from within the host.</source>
          <target state="translated">路由网在发布的端口上监听分配给节点的任何IP地址。对于外部可路由的IP地址,该端口可从主机外部访问。对于所有其他IP地址,只能从主机内部访问。</target>
        </trans-unit>
        <trans-unit id="651ea2301cb30ccac05c14bcc4f8596b34135c1e" translate="yes" xml:space="preserve">
          <source>The sample private key files in the Notary repository are obviously public knowledge and using them in a production deployment is highly insecure.</source>
          <target state="translated">Notary存储库中的样本私钥文件显然是公共知识,在生产部署中使用它们是非常不安全的。</target>
        </trans-unit>
        <trans-unit id="0680e84ec3606b9b2a28ebd30c137017045206d7" translate="yes" xml:space="preserve">
          <source>The scale command enables you to scale one or more replicated services either up or down to the desired number of replicas. This command cannot be applied on services which are global mode. The command will return immediately, but the actual scaling of the service may take some time. To stop all replicas of a service while keeping the service active in the swarm you can set the scale to 0.</source>
          <target state="translated">通过scale命令,您可以将一个或多个复制的服务向上或向下扩展到所需的复制数量。此命令不能应用于全局模式的服务。该命令将立即返回,但服务的实际缩放可能需要一些时间。要停止服务的所有复制,同时保持服务在群中的活动状态,您可以将比例设置为 0。</target>
        </trans-unit>
        <trans-unit id="fd5e3a3daf8f3af35f3576952165a75efca3c43f" translate="yes" xml:space="preserve">
          <source>The scheduler applies rolling updates as follows by default:</source>
          <target state="translated">调度器默认应用滚动更新如下。</target>
        </trans-unit>
        <trans-unit id="7fdad0e461a858285fc18d11169e3855ceaafd78" translate="yes" xml:space="preserve">
          <source>The second difference is that the &lt;code&gt;docker-compose run&lt;/code&gt; command does not create any of the ports specified in the service configuration. This prevents port collisions with already-open ports. If you &lt;em&gt;do want&lt;/em&gt; the service&amp;rsquo;s ports to be created and mapped to the host, specify the &lt;code&gt;--service-ports&lt;/code&gt; flag:</source>
          <target state="translated">第二个区别是 &lt;code&gt;docker-compose run&lt;/code&gt; 命令不会创建服务配置中指定的任何端口。这样可以防止端口与已经打开的端口发生冲突。如果&lt;em&gt;确实要&lt;/em&gt;创建服务的端口并将其映射到主机，请指定 &lt;code&gt;--service-ports&lt;/code&gt; 标志：</target>
        </trans-unit>
        <trans-unit id="1369662f4279d3737e3689ad5061118d736eaf00" translate="yes" xml:space="preserve">
          <source>The second form, &lt;code&gt;ENV &amp;lt;key&amp;gt;=&amp;lt;value&amp;gt; ...&lt;/code&gt;, allows for multiple variables to be set at one time. Notice that the second form uses the equals sign (=) in the syntax, while the first form does not. Like command line parsing, quotes and backslashes can be used to include spaces within values.</source>
          <target state="translated">第二种形式 &lt;code&gt;ENV &amp;lt;key&amp;gt;=&amp;lt;value&amp;gt; ...&lt;/code&gt; ，允许一次设置多个变量。请注意，第二种形式在语法中使用等号（=），而第一种形式则不使用等号（=）。与命令行分析一样，引号和反斜杠可用于在值中包含空格。</target>
        </trans-unit>
        <trans-unit id="a18b471e24f517ee24f17b02f1944454e7b27901" translate="yes" xml:space="preserve">
          <source>The secrets are each mounted in a &lt;code&gt;tmpfs&lt;/code&gt; filesystem at &lt;code&gt;/run/secrets/mysql_password&lt;/code&gt; and &lt;code&gt;/run/secrets/mysql_root_password&lt;/code&gt;. They are never exposed as environment variables, nor can they be committed to an image if the &lt;code&gt;docker commit&lt;/code&gt; command is run. The &lt;code&gt;mysql_password&lt;/code&gt; secret is the one used by the non-privileged WordPress container to connect to MySQL.</source>
          <target state="translated">每个秘密都安装在 &lt;code&gt;/run/secrets/mysql_password&lt;/code&gt; 和 &lt;code&gt;/run/secrets/mysql_root_password&lt;/code&gt; 的 &lt;code&gt;tmpfs&lt;/code&gt; 文件系统中。如果运行 &lt;code&gt;docker commit&lt;/code&gt; 命令，则永远不会将它们公开为环境变量，也不能将它们提交给映像。该 &lt;code&gt;mysql_password&lt;/code&gt; 秘诀是使用非特权WordPress的容器连接到MySQL的一个。</target>
        </trans-unit>
        <trans-unit id="f092993aa746c14f11973e92473a80799b7c5cdb" translate="yes" xml:space="preserve">
          <source>The secrets are stored in the encrypted Raft logs for the swarm.</source>
          <target state="translated">秘密存储在群的加密Raft日志中。</target>
        </trans-unit>
        <trans-unit id="a950b0ba4b36dfaab8fd235063e02e8ae56ebb64" translate="yes" xml:space="preserve">
          <source>The sections below provide an inexhaustive overview of available plugins.</source>
          <target state="translated">下面的部分提供了可用插件的详尽概述。</target>
        </trans-unit>
        <trans-unit id="ed44fc39d73da3d657ea6e32cb6e540bcc7e237b" translate="yes" xml:space="preserve">
          <source>The security of keys held and administered by users depends on measures taken by the users. If the Notary Client CLI was used to create them, then they are password protected and the Notary CLI does not provide options to export them in plaintext.</source>
          <target state="translated">用户持有和管理的钥匙的安全性取决于用户采取的措施。如果使用公证客户端CLI来创建钥匙,那么这些钥匙受密码保护,而且公证CLI不提供以明文形式导出钥匙的选项。</target>
        </trans-unit>
        <trans-unit id="cc6046dbe345edbe3a9289f0ffe25429820506bd" translate="yes" xml:space="preserve">
          <source>The self-signed certificate&amp;rsquo;s subject name and subject alternative names are &lt;code&gt;notary-server&lt;/code&gt;, &lt;code&gt;notaryserver&lt;/code&gt;, and &lt;code&gt;localhost&lt;/code&gt;, so if your Docker host is not on &lt;code&gt;localhost&lt;/code&gt; (for example if you are using Docker Machine), update your hosts file such that the name &lt;code&gt;notary-server&lt;/code&gt; is associated with the IP address of your Docker host.</source>
          <target state="translated">自签名证书的 &lt;code&gt;notaryserver&lt;/code&gt; 名称和使用者备用名称是 &lt;code&gt;notary-server&lt;/code&gt; ，notaryserver和 &lt;code&gt;localhost&lt;/code&gt; ，因此，如果您的Docker主机不在 &lt;code&gt;localhost&lt;/code&gt; 上（例如，如果您使用Docker Machine），请更新主机文件，以使名称为 &lt;code&gt;notary-server&lt;/code&gt; 与您的Docker主机的IP地址相关联。</target>
        </trans-unit>
        <trans-unit id="05fc316e8da00fa94322c414c61e50be43f29aa2" translate="yes" xml:space="preserve">
          <source>The sequence diagrams below depict an allow and deny authorization flow:</source>
          <target state="translated">下面的序列图描述了一个允许和拒绝授权的流程。</target>
        </trans-unit>
        <trans-unit id="cfda3a75597b63ea614d8b5f992985ded0fd10f1" translate="yes" xml:space="preserve">
          <source>The server and signer each require a database. These should be separate databases with different users. The users should be limited in their permissions. We recommend giving the following MySQL (or equivalent) permissions to the users restricted to only their own databases:</source>
          <target state="translated">服务器和签字人各自需要一个数据库。这些数据库应该是不同的用户的独立数据库。用户的权限应该是有限的。我们建议给以下MySQL(或同等的)权限的用户只限于他们自己的数据库。</target>
        </trans-unit>
        <trans-unit id="a1d5383055ec3d5ebeeb1ca8d9b08a8b9065d399" translate="yes" xml:space="preserve">
          <source>The service is scheduled on an available node. To confirm that the service was created and started successfully, use the &lt;code&gt;docker service ls&lt;/code&gt; command:</source>
          <target state="translated">该服务是在可用节点上调度的。要确认服务已创建并成功启动，请使用 &lt;code&gt;docker service ls&lt;/code&gt; 命令：</target>
        </trans-unit>
        <trans-unit id="5355f89c4a23e588939caf6ab76b28c21f8b64ba" translate="yes" xml:space="preserve">
          <source>The service mode determines whether this is a &lt;em&gt;replicated&lt;/em&gt; service or a &lt;em&gt;global&lt;/em&gt; service. A replicated service runs as many tasks as specified, while a global service runs on each active node in the swarm.</source>
          <target state="translated">服务模式确定这是&lt;em&gt;复制&lt;/em&gt;服务还是&lt;em&gt;全局&lt;/em&gt;服务。复制的服务运行指定数量的任务，而全局服务在群集中的每个活动节点上运行。</target>
        </trans-unit>
        <trans-unit id="82c2d6c046e79fb08237072b087819e985e2f1f6" translate="yes" xml:space="preserve">
          <source>The service that does all the heavy-lifting of managing trust</source>
          <target state="translated">承担管理信任的所有重任的服务。</target>
        </trans-unit>
        <trans-unit id="188371eb2e278b2bcaa57e5e84f1de91dd45b6f9" translate="yes" xml:space="preserve">
          <source>The settings currently supported are:</source>
          <target state="translated">目前支持的设置有:</target>
        </trans-unit>
        <trans-unit id="5e9f71dbad06279098210209165a53aa91ebb9a3" translate="yes" xml:space="preserve">
          <source>The severity of the compromise of a trust collection owner/administrator&amp;rsquo;s decrypted key depends on the type and combination of keys compromised. For example, were the snapshot and targets key both compromised, or just the targets key?</source>
          <target state="translated">信任集合所有者/管理员的解密密钥受到破坏的严重性取决于受到破坏的密钥的类型和组合。例如，快照和目标密钥是否都受到威胁，或者仅仅是目标密钥？</target>
        </trans-unit>
        <trans-unit id="5e285e5fc1c5c5b83b6e6ae21945064a554d6911" translate="yes" xml:space="preserve">
          <source>The short syntax uses the generic &lt;code&gt;[SOURCE:]TARGET[:MODE]&lt;/code&gt; format, where &lt;code&gt;SOURCE&lt;/code&gt; can be either a host path or volume name. &lt;code&gt;TARGET&lt;/code&gt; is the container path where the volume is mounted. Standard modes are &lt;code&gt;ro&lt;/code&gt; for read-only and &lt;code&gt;rw&lt;/code&gt; for read-write (default).</source>
          <target state="translated">短语法使用通用的 &lt;code&gt;[SOURCE:]TARGET[:MODE]&lt;/code&gt; 格式，其中 &lt;code&gt;SOURCE&lt;/code&gt; 可以是主机路径或卷名。 &lt;code&gt;TARGET&lt;/code&gt; 是装入卷的容器路径。标准模式是 &lt;code&gt;ro&lt;/code&gt; （只读）和 &lt;code&gt;rw&lt;/code&gt; （读写）（默认）。</target>
        </trans-unit>
        <trans-unit id="479ecea93938657188a1718269a0502002d14409" translate="yes" xml:space="preserve">
          <source>The short syntax variant only specifies the config name. This grants the container access to the config and mounts it at &lt;code&gt;/&amp;lt;config_name&amp;gt;&lt;/code&gt; within the container. The source name and destination mountpoint are both set to the config name.</source>
          <target state="translated">简短的语法变体仅指定配置名称。这将授予容器对配置的访问权限，并将其安装在容器内的 &lt;code&gt;/&amp;lt;config_name&amp;gt;&lt;/code&gt; 上。源名称和目标安装点都设置为配置名称。</target>
        </trans-unit>
        <trans-unit id="cfba78e508fa6569fb674621ccb1b91714d1e973" translate="yes" xml:space="preserve">
          <source>The short syntax variant only specifies the secret name. This grants the container access to the secret and mounts it at &lt;code&gt;/run/secrets/&amp;lt;secret_name&amp;gt;&lt;/code&gt; within the container. The source name and destination mountpoint are both set to the secret name.</source>
          <target state="translated">简短的语法变体仅指定秘密名称。这将授予容器访问密钥的权限，并将其安装在容器内的 &lt;code&gt;/run/secrets/&amp;lt;secret_name&amp;gt;&lt;/code&gt; 上。源名称和目标安装点都设置为机密名称。</target>
        </trans-unit>
        <trans-unit id="1da25af45d12b0e226e934e1363a91d8c769594b" translate="yes" xml:space="preserve">
          <source>The shorthand (&lt;code&gt;-h&lt;/code&gt;) is less common than &lt;code&gt;--help&lt;/code&gt; on Linux and cannot be used on all subcommands (due to it conflicting with, e.g. &lt;code&gt;-h&lt;/code&gt; / &lt;code&gt;--hostname&lt;/code&gt; on &lt;code&gt;docker create&lt;/code&gt;). For this reason, the &lt;code&gt;-h&lt;/code&gt; shorthand was not printed in the &amp;ldquo;usage&amp;rdquo; output of subcommands, nor documented, and is now marked &amp;ldquo;deprecated&amp;rdquo;.</source>
          <target state="translated">速记（ &lt;code&gt;-h&lt;/code&gt; ）是小于普通 &lt;code&gt;--help&lt;/code&gt; 在Linux和不能在所有子命令用于（由于它与例如冲突的 &lt;code&gt;-h&lt;/code&gt; / &lt;code&gt;--hostname&lt;/code&gt; 上 &lt;code&gt;docker create&lt;/code&gt; ）。因此， &lt;code&gt;-h&lt;/code&gt; 速记没有打印在子命令的&amp;ldquo;用法&amp;rdquo;输出中，也没有记录在案，而是被标记为&amp;ldquo;已弃用&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="b1823de424eca78e8cd4261e1adb302d80224200" translate="yes" xml:space="preserve">
          <source>The single copy of &lt;code&gt;visualizer&lt;/code&gt; is running on the manager as you expect, and the 5 instances of &lt;code&gt;web&lt;/code&gt; are spread out across the swarm. You can corroborate this visualization by running &lt;code&gt;docker stack ps &amp;lt;stack&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;visualizer&lt;/code&gt; 的单个副本按预期在管理器上运行，并且 &lt;code&gt;web&lt;/code&gt; 的5个实例分布在整个群集中。您可以通过运行 &lt;code&gt;docker stack ps &amp;lt;stack&amp;gt;&lt;/code&gt; 来证实这种可视化效果：</target>
        </trans-unit>
        <trans-unit id="8cd0880463635b8e67d1ef02c532e8c3032cbe66" translate="yes" xml:space="preserve">
          <source>The single-dash (&lt;code&gt;-help&lt;/code&gt;) was removed, in favor of the double-dash &lt;code&gt;--help&lt;/code&gt;</source>
          <target state="translated">删除了单破折号（ &lt;code&gt;-help&lt;/code&gt; ），转而使用双破折号 &lt;code&gt;--help&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="34a4291305962d962a0ae36d42891028cba295a8" translate="yes" xml:space="preserve">
          <source>The size of the VM&amp;rsquo;s disk can be configured this way:</source>
          <target state="translated">可以通过以下方式配置VM磁盘的大小：</target>
        </trans-unit>
        <trans-unit id="b72510ced0d790516e0ce0a66a581ebc5933ec3f" translate="yes" xml:space="preserve">
          <source>The snapshot (an online) key passphrase</source>
          <target state="translated">快照(在线)密钥口令</target>
        </trans-unit>
        <trans-unit id="64a63b8afef04c5fd245cceea8bf9d95936bf43a" translate="yes" xml:space="preserve">
          <source>The snapshot key signs the &lt;a href=&quot;https://github.com/theupdateframework/tuf/blob/1bed3e09a478c2c918ffbff10b9118f6e52ee129/docs/tuf-spec.txt#L604&quot;&gt;snapshot metadata file&lt;/a&gt;, which enumerates the filenames, sizes, and hashes of the root, targets, and delegation metadata files for the collection. This file is used to verify the integrity of the other metadata files. The snapshot key is held by either a collection owner/administrator, or held by the Notary service to facilitate &lt;a href=&quot;../advanced_usage/index#working-with-delegation-roles&quot;&gt;signing by multiple collaborators via delegation roles&lt;/a&gt;.</source>
          <target state="translated">快照密钥对&lt;a href=&quot;https://github.com/theupdateframework/tuf/blob/1bed3e09a478c2c918ffbff10b9118f6e52ee129/docs/tuf-spec.txt#L604&quot;&gt;快照元数据文件进行&lt;/a&gt;签名，该文件枚举集合的根，目标和委托元数据文件的文件名，大小和哈希。该文件用于验证其他元数据文件的完整性。快照密钥由集合所有者/管理员持有，或者由公证服务持有，以促进&lt;a href=&quot;../advanced_usage/index#working-with-delegation-roles&quot;&gt;多个协作者通过委派角色进行签名&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e3009e949c1d5550b7288bb677530e0a0ba478ba" translate="yes" xml:space="preserve">
          <source>The solution is to use &lt;code&gt;ONBUILD&lt;/code&gt; to register advance instructions to run later, during the next build stage.</source>
          <target state="translated">解决方案是使用 &lt;code&gt;ONBUILD&lt;/code&gt; 注册预先的指令，以便在下一个构建阶段中稍后运行。</target>
        </trans-unit>
        <trans-unit id="5b8f682785a6e43ae0cbbde58fcc4f0b5598edd1" translate="yes" xml:space="preserve">
          <source>The storage section specifies which storage backend the server should use to store TUF metadata. Only MySQL or an in-memory store is supported.</source>
          <target state="translated">存储部分指定了服务器应使用哪个存储后端来存储TUF元数据。仅支持MySQL或内存存储。</target>
        </trans-unit>
        <trans-unit id="7071e38fef942da46e433f01278d254227287231" translate="yes" xml:space="preserve">
          <source>The structure and permitted configuration keys</source>
          <target state="translated">结构和允许的配置键</target>
        </trans-unit>
        <trans-unit id="ea12639961c26144f02d08ab564148f99bd4aa3b" translate="yes" xml:space="preserve">
          <source>The subnet range comes from the &lt;code&gt;--default-addr-pool&lt;/code&gt;, (such as &lt;code&gt;10.10.0.0/16&lt;/code&gt;). The size of 16 there represents the number of networks one can create within that &lt;code&gt;default-addr-pool&lt;/code&gt; range. The &lt;code&gt;--default-address-pool&lt;/code&gt; option may occur multiple times with each option providing additional addresses for docker to use for overlay subnets.</source>
          <target state="translated">子网范围来自 &lt;code&gt;--default-addr-pool&lt;/code&gt; （例如 &lt;code&gt;10.10.0.0/16&lt;/code&gt; ）。此处的大小为16，表示一个用户可以在该 &lt;code&gt;default-addr-pool&lt;/code&gt; 范围内创建的网络数。该 &lt;code&gt;--default-address-pool&lt;/code&gt; 选项可以与每个选项泊坞窗以使用提供更多的地址覆盖子网中多次出现。</target>
        </trans-unit>
        <trans-unit id="9f4fcc17f1c191d796a33a3a9af64120d639fd0d" translate="yes" xml:space="preserve">
          <source>The subordinate UID and GID ranges must be associated with an existing user, even though the association is an implementation detail. The user owns the namespaced storage directories under &lt;code&gt;/var/lib/docker/&lt;/code&gt;. If you don&amp;rsquo;t want to use an existing user, Docker can create one for you and use that. If you want to use an existing username or user ID, it must already exist. Typically, this means that the relevant entries need to be in &lt;code&gt;/etc/passwd&lt;/code&gt; and &lt;code&gt;/etc/group&lt;/code&gt;, but if you are using a different authentication back-end, this requirement may translate differently.</source>
          <target state="translated">从属UID和GID范围必须与现有用户相关联，即使该关联是实现细节。用户拥有 &lt;code&gt;/var/lib/docker/&lt;/code&gt; 下的命名空间存储目录。如果您不想使用现有用户，Docker可以为您创建一个并使用它。如果要使用现有的用户名或用户ID，则它必须已经存在。通常，这意味着相关条目必须位于 &lt;code&gt;/etc/passwd&lt;/code&gt; 和 &lt;code&gt;/etc/group&lt;/code&gt; 中，但是如果您使用其他身份验证后端，则此要求可能有所不同。</target>
        </trans-unit>
        <trans-unit id="41d38596a5c2344ff17e02b039500f02d18f800e" translate="yes" xml:space="preserve">
          <source>The supported flags are as follows:</source>
          <target state="translated">支持的标志如下:</target>
        </trans-unit>
        <trans-unit id="53bda3a84f325c0d6fe257e495edda6f4f91eef8" translate="yes" xml:space="preserve">
          <source>The supported flags are the following :</source>
          <target state="translated">支持的标志如下。</target>
        </trans-unit>
        <trans-unit id="21892ba3c3ab5a265fafe92a1d86c39ed241c3d6" translate="yes" xml:space="preserve">
          <source>The supported units are &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;k&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt; and &lt;code&gt;g&lt;/code&gt;, and their alternative notation &lt;code&gt;kb&lt;/code&gt;, &lt;code&gt;mb&lt;/code&gt; and &lt;code&gt;gb&lt;/code&gt;. Decimal values are not supported at this time.</source>
          <target state="translated">支持的单位是 &lt;code&gt;b&lt;/code&gt; ， &lt;code&gt;k&lt;/code&gt; ， &lt;code&gt;m&lt;/code&gt; 和 &lt;code&gt;g&lt;/code&gt; ，以及它们的备用表示法 &lt;code&gt;kb&lt;/code&gt; ， &lt;code&gt;mb&lt;/code&gt; 和 &lt;code&gt;gb&lt;/code&gt; 。目前不支持十进制值。</target>
        </trans-unit>
        <trans-unit id="807cd4896b900c1b59b5b7d890258f1331a14b7c" translate="yes" xml:space="preserve">
          <source>The supported units are &lt;code&gt;us&lt;/code&gt;, &lt;code&gt;ms&lt;/code&gt;, &lt;code&gt;s&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt; and &lt;code&gt;h&lt;/code&gt;.</source>
          <target state="translated">支持的单位是 &lt;code&gt;us&lt;/code&gt; ， &lt;code&gt;ms&lt;/code&gt; ， &lt;code&gt;s&lt;/code&gt; ， &lt;code&gt;m&lt;/code&gt; 和 &lt;code&gt;h&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ee7b3ee3acebd9009344f2838f9b5ae0e30b16d9" translate="yes" xml:space="preserve">
          <source>The swarm extends &lt;code&gt;my-network&lt;/code&gt; to each node running the service.</source>
          <target state="translated">群将 &lt;code&gt;my-network&lt;/code&gt; 扩展到运行该服务的每个节点。</target>
        </trans-unit>
        <trans-unit id="e8db2ff14bf4c80ac8a86419be635fcf751e90ef" translate="yes" xml:space="preserve">
          <source>The swarm extends my-network to each node running the service.</source>
          <target state="translated">蜂群将my-network扩展到每个运行服务的节点。</target>
        </trans-unit>
        <trans-unit id="2bf9f6bd81f0a82dc7b12293d79dee778c3d6d05" translate="yes" xml:space="preserve">
          <source>The swarm manager maintains the desired state by ending the task on a node with &lt;code&gt;Drain&lt;/code&gt; availability and creating a new task on a node with &lt;code&gt;Active&lt;/code&gt; availability.</source>
          <target state="translated">集群管理器通过在具有 &lt;code&gt;Drain&lt;/code&gt; 可用性的节点上结束任务并在具有 &lt;code&gt;Active&lt;/code&gt; 可用性的节点上创建新任务来维护所需状态。</target>
        </trans-unit>
        <trans-unit id="65790f3186fe670370e99c3c01ba5d4fbd93871e" translate="yes" xml:space="preserve">
          <source>The swarm manager uses &lt;strong&gt;ingress load balancing&lt;/strong&gt; to expose the services you want to make available externally to the swarm. The swarm manager can automatically assign the service a &lt;strong&gt;PublishedPort&lt;/strong&gt; or you can configure a PublishedPort for the service. You can specify any unused port. If you do not specify a port, the swarm manager assigns the service a port in the 30000-32767 range.</source>
          <target state="translated">群集管理器使用&lt;strong&gt;入口负载平衡&lt;/strong&gt;将要从群集外部获取的服务公开给群集。群管理器可以自动为服务分配一个已&lt;strong&gt;发布&lt;/strong&gt;端口，也可以为该服务配置一个已发布端口。您可以指定任何未使用的端口。如果您未指定端口，则群管理器会为服务分配30000-32767范围内的端口。</target>
        </trans-unit>
        <trans-unit id="56909f0d7f17f9e0bbe59c5689143779666dbf5a" translate="yes" xml:space="preserve">
          <source>The swarm mode public key infrastructure (PKI) system built into Docker makes it simple to securely deploy a container orchestration system. The nodes in a swarm use mutual Transport Layer Security (TLS) to authenticate, authorize, and encrypt the communications with other nodes in the swarm.</source>
          <target state="translated">Docker内置的蜂群模式公钥基础设施(PKI)系统使安全部署容器编排系统变得简单。蜂群中的节点使用相互的传输层安全(TLS)来验证、授权和加密与蜂群中其他节点的通信。</target>
        </trans-unit>
        <trans-unit id="177825a6c20f4575a9a1b1e5fdac44315634cd55" translate="yes" xml:space="preserve">
          <source>The syntax directive defines the location of the Dockerfile builder that is used for building the current Dockerfile. The BuildKit backend allows to seamlessly use external implementations of builders that are distributed as Docker images and execute inside a container sandbox environment.</source>
          <target state="translated">语法指令定义了用于构建当前Dockerfile的Dockerfile构建器的位置。BuildKit后端允许无缝使用外部实现的构建器,这些构建器以Docker镜像的形式发布,并在容器沙箱环境中执行。</target>
        </trans-unit>
        <trans-unit id="0e83e8c32440b639e2870f007f94e67fbe95cc31" translate="yes" xml:space="preserve">
          <source>The syntax for file globbing in AppArmor is a bit different than some other globbing implementations. It is highly suggested you take a look at some of the below resources with regard to AppArmor profile syntax.</source>
          <target state="translated">在 AppArmor 中,文件 globbing 的语法与其他一些 globbing 实现有些不同。强烈建议您查看以下关于 AppArmor 配置文件语法的一些资源。</target>
        </trans-unit>
        <trans-unit id="9b7bd5feec5d7731585bce13eb511ccb98f70714" translate="yes" xml:space="preserve">
          <source>The syntax for using built-in networks such as &lt;code&gt;host&lt;/code&gt; and &lt;code&gt;none&lt;/code&gt; is a little different. Define an external network with the name &lt;code&gt;host&lt;/code&gt; or &lt;code&gt;none&lt;/code&gt; (that Docker has already created automatically) and an alias that Compose can use (&lt;code&gt;hostnet&lt;/code&gt; or &lt;code&gt;nonet&lt;/code&gt; in the following examples), then grant the service access to that network using the alias.</source>
          <target state="translated">使用内置网络（例如 &lt;code&gt;host&lt;/code&gt; 和 &lt;code&gt;none&lt;/code&gt; 使用主机网络）的语法略有不同。定义与名称的外部网络 &lt;code&gt;host&lt;/code&gt; 或 &lt;code&gt;none&lt;/code&gt; （即泊坞已经自动创建的）和别名撰写可以使用（ &lt;code&gt;hostnet&lt;/code&gt; 或 &lt;code&gt;nonet&lt;/code&gt; 在下面的实施例），则授予使用别名该网络的服务访问。</target>
        </trans-unit>
        <trans-unit id="f0ff47db46947fd89be3900e6662eb377c24199a" translate="yes" xml:space="preserve">
          <source>The systemd cgroup driver has different rules for &lt;code&gt;--cgroup-parent&lt;/code&gt;. Systemd represents hierarchy by slice and the name of the slice encodes the location in the tree. So &lt;code&gt;--cgroup-parent&lt;/code&gt; for systemd cgroups should be a slice name. A name can consist of a dash-separated series of names, which describes the path to the slice from the root slice. For example, &lt;code&gt;--cgroup-parent=user-a-b.slice&lt;/code&gt; means the memory cgroup for the container is created in &lt;code&gt;/sys/fs/cgroup/memory/user.slice/user-a.slice/user-a-b.slice/docker-&amp;lt;id&amp;gt;.scope&lt;/code&gt;.</source>
          <target state="translated">systemd cgroup驱动程序对 &lt;code&gt;--cgroup-parent&lt;/code&gt; 具有不同的规则。Systemd按切片表示层次结构，切片的名称对树中的位置进行编码。因此，systemd cgroup的 &lt;code&gt;--cgroup-parent&lt;/code&gt; 应该是切片名称。名称可以包含一系列用短划线分隔的名称，这些名称描述了从根切片到切片的路径。例如，-- &lt;code&gt;--cgroup-parent=user-a-b.slice&lt;/code&gt; 表示在 &lt;code&gt;/sys/fs/cgroup/memory/user.slice/user-a.slice/user-a-b.slice/docker-&amp;lt;id&amp;gt;.scope&lt;/code&gt; 创建容器的内存cgroup - &amp;lt;ID&amp;gt; .scope。</target>
        </trans-unit>
        <trans-unit id="0533656b4b74c590cc6513549d259075f037f41c" translate="yes" xml:space="preserve">
          <source>The table below shows what command is executed for different &lt;code&gt;ENTRYPOINT&lt;/code&gt; / &lt;code&gt;CMD&lt;/code&gt; combinations:</source>
          <target state="translated">下表显示了针对不同的 &lt;code&gt;ENTRYPOINT&lt;/code&gt; / &lt;code&gt;CMD&lt;/code&gt; 组合执行的命令：</target>
        </trans-unit>
        <trans-unit id="0185173a349942562bd58274872dd22dc8f0e29c" translate="yes" xml:space="preserve">
          <source>The target port within the container and the port to map it to on the nodes, using the routing mesh (</source>
          <target state="translated">容器内的目标端口和节点上要映射到的端口,使用路由网状结构(</target>
        </trans-unit>
        <trans-unit id="01f09d14eb7d87e9c346afdcc156ecf97088e58b" translate="yes" xml:space="preserve">
          <source>The targets (an online) key passphrase</source>
          <target state="translated">目标(在线)关键口令</target>
        </trans-unit>
        <trans-unit id="69ce8dd4214ab3a54dcd700601b8837bbda45bf0" translate="yes" xml:space="preserve">
          <source>The targets key must be locally managed - to rotate the targets key, for instance in case of compromise, use the &lt;code&gt;notary key rotate targets&lt;/code&gt; command without the &lt;code&gt;-r&lt;/code&gt; flag.</source>
          <target state="translated">必须对目标密钥进行本地管理-要旋转目标密钥，例如，在折衷的情况下，请使用不带 &lt;code&gt;-r&lt;/code&gt; 标志的 &lt;code&gt;notary key rotate targets&lt;/code&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="097f73b93a96add7eae69c74428e99d8d28480db" translate="yes" xml:space="preserve">
          <source>The targets key signs the &lt;a href=&quot;ttps://github.com/theupdateframework/tuf/blob/1bed3e09a478c2c918ffbff10b9118f6e52ee129/docs/tuf-spec.txt#L678&quot;&gt;targets metadata file&lt;/a&gt;, which lists filenames in the collection, and their sizes and respective &lt;a href=&quot;https://en.wikipedia.org/wiki/Cryptographic_hash_function&quot;&gt;hashes&lt;/a&gt;. This file is used to verify the integrity of some or all of the actual contents of the repository. It is also used to &lt;a href=&quot;../advanced_usage/index#working-with-delegation-roles&quot;&gt;delegate trust to other collaborators via delegation roles&lt;/a&gt;. The targets key is held by the collection owner or administrator.</source>
          <target state="translated">target键对&lt;a href=&quot;ttps://github.com/theupdateframework/tuf/blob/1bed3e09a478c2c918ffbff10b9118f6e52ee129/docs/tuf-spec.txt#L678&quot;&gt;目标元数据文件进行&lt;/a&gt;签名，该文件列出了集合中的文件名及其大小和相应的&lt;a href=&quot;https://en.wikipedia.org/wiki/Cryptographic_hash_function&quot;&gt;哈希值&lt;/a&gt;。该文件用于验证存储库中某些或所有实际内容的完整性。它还&lt;a href=&quot;../advanced_usage/index#working-with-delegation-roles&quot;&gt;通过委托角色将信任委托给其他协作者&lt;/a&gt;。目标键由集合所有者或管理员持有。</target>
        </trans-unit>
        <trans-unit id="8e03566e6e6cb3a1a03671d36368093bc50beb83" translate="yes" xml:space="preserve">
          <source>The timestamp and snapshot keys are safely generated and stored in a signing server that is deployed alongside the Docker registry. These keys are generated in a backend service that isn&amp;rsquo;t directly exposed to the internet and are encrypted at rest.</source>
          <target state="translated">时间戳和快照密钥是安全生成的，并存储在与Docker注册表一起部署的签名服务器中。这些密钥是在后端服务中生成的，该服务不会直接暴露给Internet，而是在静止状态下进行加密。</target>
        </trans-unit>
        <trans-unit id="3d18b09fad96c7637380585b8bee68a93fdbc75f" translate="yes" xml:space="preserve">
          <source>The timestamp key signs the &lt;a href=&quot;https://github.com/theupdateframework/tuf/blob/1bed3e09a478c2c918ffbff10b9118f6e52ee129/docs/tuf-spec.txt#L827&quot;&gt;timestamp metadata file&lt;/a&gt;, which provides freshness guarantees for the collection by having the shortest expiry time of any particular piece of metadata and by specifying the filename, size, and hash of the most recent snapshot for the collection. It is used to verify the integrity of the snapshot file. The timestamp key is held by the Notary service so the timestamp can be automatically re-generated when it is requested from the server, rather than require that a collection owner come online before each timestamp expiry.</source>
          <target state="translated">时间戳记密钥对&lt;a href=&quot;https://github.com/theupdateframework/tuf/blob/1bed3e09a478c2c918ffbff10b9118f6e52ee129/docs/tuf-spec.txt#L827&quot;&gt;时间戳记元数据文件进行&lt;/a&gt;签名，该时间戳记元数据文件具有任何特定元数据的最短到期时间，并通过指定该集合的最新快照的文件名，大小和哈希来为集合提供新鲜度保证。它用于验证快照文件的完整性。时间戳记密钥由Notary服务持有，因此可以在从服务器请求时间戳记时自动重新生成时间戳记，而不是要求集合所有者在每个时间戳记到期之前都联机。</target>
        </trans-unit>
        <trans-unit id="704394fd5b8493bd6e289ef12138c69f8e714fdb" translate="yes" xml:space="preserve">
          <source>The top-level &lt;code&gt;configs&lt;/code&gt; declaration defines or references &lt;a href=&quot;../../engine/swarm/configs/index&quot;&gt;configs&lt;/a&gt; that can be granted to the services in this stack. The source of the config is either &lt;code&gt;file&lt;/code&gt; or &lt;code&gt;external&lt;/code&gt;.</source>
          <target state="translated">顶级 &lt;code&gt;configs&lt;/code&gt; 声明定义或引用可以授予此堆栈中的服务的&lt;a href=&quot;../../engine/swarm/configs/index&quot;&gt;配置&lt;/a&gt;。配置的来源是 &lt;code&gt;file&lt;/code&gt; 或 &lt;code&gt;external&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="06c35a757b239c69a0548e919ffccda1b64e9cb1" translate="yes" xml:space="preserve">
          <source>The top-level &lt;code&gt;networks&lt;/code&gt; key lets you specify networks to be created.</source>
          <target state="translated">顶级 &lt;code&gt;networks&lt;/code&gt; 键可让您指定要创建的网络。</target>
        </trans-unit>
        <trans-unit id="7414ff9907a0e9a522d26984ac446fdfa9604491" translate="yes" xml:space="preserve">
          <source>The top-level &lt;code&gt;networks&lt;/code&gt; key lets you specify networks to be created. For a full explanation of Compose&amp;rsquo;s use of Docker networking features, see the &lt;a href=&quot;../../networking/index&quot;&gt;Networking guide&lt;/a&gt;.</source>
          <target state="translated">顶级 &lt;code&gt;networks&lt;/code&gt; 键可让您指定要创建的网络。有关Compose使用Docker网络功能的完整说明，请参阅《&lt;a href=&quot;../../networking/index&quot;&gt;网络指南》&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0390c92b705085454360c5f24d96c5340fcc7036" translate="yes" xml:space="preserve">
          <source>The top-level &lt;code&gt;secrets&lt;/code&gt; declaration defines or references &lt;a href=&quot;../../engine/swarm/secrets/index&quot;&gt;secrets&lt;/a&gt; that can be granted to the services in this stack. The source of the secret is either &lt;code&gt;file&lt;/code&gt; or &lt;code&gt;external&lt;/code&gt;.</source>
          <target state="translated">顶级 &lt;code&gt;secrets&lt;/code&gt; 声明定义或引用可以授予此堆栈中的服务的&lt;a href=&quot;../../engine/swarm/secrets/index&quot;&gt;机密&lt;/a&gt;。机密的来源是 &lt;code&gt;file&lt;/code&gt; 或 &lt;code&gt;external&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="322e63c416ba6a457d865d372c3db8990b527d11" translate="yes" xml:space="preserve">
          <source>The topics below describe available options to set resource constraints on services or containers in a swarm.</source>
          <target state="translated">下面的主题描述了对蜂群中的服务或容器设置资源约束的可用选项。</target>
        </trans-unit>
        <trans-unit id="54cf08ae091cd1246737172b45300405441fa449" translate="yes" xml:space="preserve">
          <source>The topics below explain the differences among the versions, Docker Engine compatibility, and &lt;a href=&quot;#upgrading&quot;&gt;how to upgrade&lt;/a&gt;.</source>
          <target state="translated">以下主题说明了版本之间的差异，Docker Engine兼容性以及&lt;a href=&quot;#upgrading&quot;&gt;升级方法&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6ed6348d39665453e5afbba76aa26e4b42d3aec5" translate="yes" xml:space="preserve">
          <source>The topics on this reference page are organized alphabetically by top-level key to reflect the structure of the Compose file itself. Top-level keys that define a section in the configuration file such as &lt;code&gt;build&lt;/code&gt;, &lt;code&gt;deploy&lt;/code&gt;, &lt;code&gt;depends_on&lt;/code&gt;, &lt;code&gt;networks&lt;/code&gt;, and so on, are listed with the options that support them as sub-topics. This maps to the &lt;code&gt;&amp;lt;key&amp;gt;: &amp;lt;option&amp;gt;: &amp;lt;value&amp;gt;&lt;/code&gt; indent structure of the Compose file.</source>
          <target state="translated">此参考页上的主题按顶级键按字母顺序组织，以反映Compose文件本身的结构。列出了在配置文件中定义部分的顶级键，例如 &lt;code&gt;build&lt;/code&gt; ， &lt;code&gt;deploy&lt;/code&gt; ， &lt;code&gt;depends_on&lt;/code&gt; ， &lt;code&gt;networks&lt;/code&gt; 等，并带有支持它们的选项作为子主题。这映射到Compose文件的 &lt;code&gt;&amp;lt;key&amp;gt;: &amp;lt;option&amp;gt;: &amp;lt;value&amp;gt;&lt;/code&gt; 缩进结构。</target>
        </trans-unit>
        <trans-unit id="6c53132ec117df95bc0650452a0b9339edb16b37" translate="yes" xml:space="preserve">
          <source>The transfer of context from the local machine to the Docker daemon is what the &lt;code&gt;docker&lt;/code&gt; client means when you see the &amp;ldquo;Sending build context&amp;rdquo; message.</source>
          <target state="translated">当您看到&amp;ldquo;正在发送构建上下文&amp;rdquo;消息时， &lt;code&gt;docker&lt;/code&gt; 客户端将上下文从本地计算机传输到Docker守护程序。</target>
        </trans-unit>
        <trans-unit id="95f5b0e2ba8bddb684a7c26a00396d9830eeafb5" translate="yes" xml:space="preserve">
          <source>The tutorial guides you through the following activities:</source>
          <target state="translated">本教程指导您完成以下活动。</target>
        </trans-unit>
        <trans-unit id="6b5befa58d03f8a29b0c139f5cc34961087af58e" translate="yes" xml:space="preserve">
          <source>The tutorial uses &lt;code&gt;manager1&lt;/code&gt; : &lt;code&gt;192.168.99.100&lt;/code&gt;.</source>
          <target state="translated">本教程使用 &lt;code&gt;manager1&lt;/code&gt; ： &lt;code&gt;192.168.99.100&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e7c05446c0a238cd4c756284cf18fb1555be975d" translate="yes" xml:space="preserve">
          <source>The type of mount, can be either</source>
          <target state="translated">安装的类型,可以是</target>
        </trans-unit>
        <trans-unit id="808a955c835bc826a78db93a8f283cb1de51c319" translate="yes" xml:space="preserve">
          <source>The underlying logic of Docker swarm mode is a general purpose scheduler and orchestrator. The service and task abstractions themselves are unaware of the containers they implement. Hypothetically, you could implement other types of tasks such as virtual machine tasks or non-containerized process tasks. The scheduler and orchestrator are agnostic about the type of task. However, the current version of Docker only supports container tasks.</source>
          <target state="translated">Docker swarm模式的底层逻辑是一个通用的调度器和编排器。服务和任务抽象本身是不知道它们实现的容器的。假设你可以实现其他类型的任务,比如虚拟机任务或非容器化的进程任务。调度器和编排器对任务的类型是不可知的。然而,当前版本的Docker只支持容器任务。</target>
        </trans-unit>
        <trans-unit id="077b2070cdc00a73a64fa6daed16da1a2d09e083" translate="yes" xml:space="preserve">
          <source>The unknown directive is treated as a comment due to not being recognized. In addition, the known directive is treated as a comment due to appearing after a comment which is not a parser directive.</source>
          <target state="translated">未知指令由于未被识别而被作为注释处理。此外,已知指令由于出现在不是解析器指令的注释之后,也被视为注释。</target>
        </trans-unit>
        <trans-unit id="813604c1f616eff640341fd47c3ef347077481ed" translate="yes" xml:space="preserve">
          <source>The user as which docker-machine should log in to the Linode instance to install Docker. This user must have passwordless sudo.</source>
          <target state="translated">作为docker-machine登录Linode实例安装Docker的用户。这个用户必须有无密码的 sudo。</target>
        </trans-unit>
        <trans-unit id="9576dab363bda69179f31e7cb6a084eeae7e6f30" translate="yes" xml:space="preserve">
          <source>The user identification</source>
          <target state="translated">用户识别</target>
        </trans-unit>
        <trans-unit id="950b799dd4aed77dfb0676c4acc74f28e973ee02" translate="yes" xml:space="preserve">
          <source>The usual cause of this error is that the container has a volume (defined either in its image or in the Compose file) without an explicit mapping, and so in order to preserve its data, Compose has directed Swarm to schedule the new container on the same node as the old container. This results in a port clash.</source>
          <target state="translated">导致这种错误的通常原因是容器有一个没有显式映射的卷(在其映像中或在 Compose 文件中定义),因此为了保存其数据,Compose 指示 Swarm 将新容器调度在与旧容器相同的节点上。这就导致了端口冲突。</target>
        </trans-unit>
        <trans-unit id="5a787679f2f02da5f6dce687df16d0ad2de650af" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;VAL&lt;/code&gt; is used as is and not modified at all. For example if the value is surrounded by quotes (as is often the case of shell variables), the quotes are included in the value passed to Compose.</source>
          <target state="translated">&lt;code&gt;VAL&lt;/code&gt; 的值按原样使用，根本没有修改。例如，如果该值用引号引起来（通常是shell变量），则引号包含在传递给Compose的值中。</target>
        </trans-unit>
        <trans-unit id="61609f3bd2f21ab04e9d50f0aa0ad5208715c1ba" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;DEBUG&lt;/code&gt; variable in the container is taken from the value for the same variable in the shell in which Compose is run.</source>
          <target state="translated">所述的值 &lt;code&gt;DEBUG&lt;/code&gt; 在容器变量是从值取为在其中撰写运行在壳中的相同变量。</target>
        </trans-unit>
        <trans-unit id="746c6ac6a23b8454770142b20f0126d7ade6f0e5" translate="yes" xml:space="preserve">
          <source>The value returned is not the password, but the ID of the secret. In the remainder of this tutorial, the ID output is omitted.</source>
          <target state="translated">返回的值不是密码,而是秘密的ID。在本教程的其余部分,省略了ID的输出。</target>
        </trans-unit>
        <trans-unit id="1889542e56eda59f3d3d8ea98417148b9aec534d" translate="yes" xml:space="preserve">
          <source>The values are sent to the appropriate &lt;code&gt;syscall&lt;/code&gt; as they are set. Docker doesn&amp;rsquo;t perform any byte conversion. Take this into account when setting the values.</source>
          <target state="translated">这些值将在设置后发送到适当的 &lt;code&gt;syscall&lt;/code&gt; 。Docker不执行任何字节转换。设置值时要考虑到这一点。</target>
        </trans-unit>
        <trans-unit id="50d5528070cdcdf314e138aa479cb9727774525f" translate="yes" xml:space="preserve">
          <source>The variable expansion technique in this example allows you to pass arguments from the command line and persist them in the final image by leveraging the &lt;code&gt;ENV&lt;/code&gt; instruction. Variable expansion is only supported for &lt;a href=&quot;#environment-replacement&quot;&gt;a limited set of Dockerfile instructions.&lt;/a&gt;</source>
          <target state="translated">在此示例中，变量扩展技术使您可以从命令行传递参数，并利用 &lt;code&gt;ENV&lt;/code&gt; 指令将其保留在最终映像中。仅&lt;a href=&quot;#environment-replacement&quot;&gt;有限的一组Dockerfile指令&lt;/a&gt;支持变量扩展。</target>
        </trans-unit>
        <trans-unit id="ad9e412128cae9e2070e957151f854e8924ad398" translate="yes" xml:space="preserve">
          <source>The visualizer is a standalone service that can run in any app that includes it in the stack. It doesn&amp;rsquo;t depend on anything else. Now let&amp;rsquo;s create a service that &lt;em&gt;does&lt;/em&gt; have a dependency: the Redis service that provides a visitor counter.</source>
          <target state="translated">可视化工具是一项独立的服务，可以在将其包含在堆栈中的任何应用中运行。它不依赖其他任何东西。现在让我们创建一个服务&lt;em&gt;不会&lt;/em&gt;有依赖性：Redis的服务，提供访客计数器。</target>
        </trans-unit>
        <trans-unit id="984e84f6857002353b6ddc22dd16cfaabdf532de" translate="yes" xml:space="preserve">
          <source>The volume name is a human-readable name for the volume, and cannot begin with a &lt;code&gt;/&lt;/code&gt; character. It is referred to as &lt;code&gt;volume_name&lt;/code&gt; in the rest of this topic.</source>
          <target state="translated">卷名是该卷的人类可读名称，不能以 &lt;code&gt;/&lt;/code&gt; 字符开头。在本主题的其余部分中，它称为 &lt;code&gt;volume_name&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0783572785fa9651cdf59fe05a1291f10567dced" translate="yes" xml:space="preserve">
          <source>The volume you created that lets the container access &lt;code&gt;./data&lt;/code&gt; (on the host) as &lt;code&gt;/data&lt;/code&gt; (inside the Redis container). While containers come and go, the files stored on &lt;code&gt;./data&lt;/code&gt; on the specified host persists, enabling continuity.</source>
          <target state="translated">您创建的允许容器以 &lt;code&gt;/data&lt;/code&gt; （在Redis容器内部）访问 &lt;code&gt;./data&lt;/code&gt; （在主机上）的卷。容器 &lt;code&gt;./data&lt;/code&gt; ，存储在指定主机上的./data上的文件将保留，从而实现连续性。</target>
        </trans-unit>
        <trans-unit id="4942b66d1eb91033003011fbf6eb332e419dd45c" translate="yes" xml:space="preserve">
          <source>The volumes commands are complex enough to have their own documentation in section &lt;a href=&quot;https://docs.docker.com/storage/volumes/&quot;&gt;&lt;em&gt;Use volumes&lt;/em&gt;&lt;/a&gt;. A developer can define one or more &lt;code&gt;VOLUME&lt;/code&gt;&amp;rsquo;s associated with an image, but only the operator can give access from one container to another (or from a container to a volume mounted on the host).</source>
          <target state="translated">卷命令非常复杂，在&lt;a href=&quot;https://docs.docker.com/storage/volumes/&quot;&gt;&lt;em&gt;使用卷一&lt;/em&gt;&lt;/a&gt;节中有其自己的文档。开发人员可以定义与图像关联的一个或多个 &lt;code&gt;VOLUME&lt;/code&gt; ，但是只有操作员才能授予从一个容器到另一个容器（或从容器到主机上安装的卷）的访问权限。</target>
        </trans-unit>
        <trans-unit id="cde13cc54c1b745deadeca881f546b49d1ec0604" translate="yes" xml:space="preserve">
          <source>The way the namespace remapping is handled on the host is using two files, &lt;code&gt;/etc/subuid&lt;/code&gt; and &lt;code&gt;/etc/subgid&lt;/code&gt;. These files are typically managed automatically when you add or remove users or groups, but on a few distributions such as RHEL and CentOS 7.3, you may need to manage these files manually.</source>
          <target state="translated">在主机上处理名称空间重映射的方式是使用 &lt;code&gt;/etc/subuid&lt;/code&gt; 和 &lt;code&gt;/etc/subgid&lt;/code&gt; 这两个文件。这些文件通常在添加或删除用户或组时自动进行管理，但是在一些发行版（例如RHEL和CentOS 7.3）上，可能需要手动管理这些文件。</target>
        </trans-unit>
        <trans-unit id="e45b1f6108a82bf67b71c85d0639d5979f14f7ca" translate="yes" xml:space="preserve">
          <source>Then make sure the experimental flag is enabled:</source>
          <target state="translated">然后确保实验性标志被启用。</target>
        </trans-unit>
        <trans-unit id="f0f9379ccf766a586a4628c88e3a02475ae34742" translate="yes" xml:space="preserve">
          <source>Then reload your shell:</source>
          <target state="translated">然后重新加载你的外壳。</target>
        </trans-unit>
        <trans-unit id="16ac1788505b466a3f21ddb8e7fff258927db3f1" translate="yes" xml:space="preserve">
          <source>Then run it, mapping the exposed port to one on the host</source>
          <target state="translated">然后运行它,将暴露的端口映射到主机上的一个端口上</target>
        </trans-unit>
        <trans-unit id="ba0f97060d2e1000948b0ee70a4d723aaa8a3cc9" translate="yes" xml:space="preserve">
          <source>Then run the following command to download the current stable release of Compose (v1.24.1):</source>
          <target state="translated">然后运行以下命令下载当前稳定版的 Compose(v1.24.1)。</target>
        </trans-unit>
        <trans-unit id="228d7d3092c1d2d33a29a03d6afceb9497d2f340" translate="yes" xml:space="preserve">
          <source>Then specify the arguments under the &lt;code&gt;build&lt;/code&gt; key. You can pass a mapping or a list:</source>
          <target state="translated">然后在 &lt;code&gt;build&lt;/code&gt; 键下指定参数。您可以传递映射或列表：</target>
        </trans-unit>
        <trans-unit id="f619b0978d2bfc96e064c4f4798aa4408b70e708" translate="yes" xml:space="preserve">
          <source>Then start your Docker daemon with &lt;code&gt;HTTPS_PROXY=http://username:password@proxy:port/ dockerd&lt;/code&gt;. The &lt;code&gt;username:&lt;/code&gt; and &lt;code&gt;password@&lt;/code&gt; are optional - and are only needed if your proxy is set up to require authentication.</source>
          <target state="translated">然后使用 &lt;code&gt;HTTPS_PROXY=http://username:password@proxy:port/ dockerd&lt;/code&gt; 启动您的Docker守护程序。该 &lt;code&gt;username:&lt;/code&gt; 和 &lt;code&gt;password@&lt;/code&gt; 是可选的-如果你的代理服务器设置为需要身份验证时，才需要。</target>
        </trans-unit>
        <trans-unit id="c079d6aea55289143434dbc5a465fbbf83112617" translate="yes" xml:space="preserve">
          <source>Then they can send it to whichever CA you trust to sign certificates, or they can self-sign the certificate (in this example, creating a certificate that is valid for 1 year):</source>
          <target state="translated">然后他们可以将其发送给你信任的任何一个CA来签署证书,或者他们可以自我签署证书(在这个例子中,创建一个有效期为1年的证书)。</target>
        </trans-unit>
        <trans-unit id="67b4998ea0be4fba5d41e8c39a43342f50125aea" translate="yes" xml:space="preserve">
          <source>Then they need to generate an x509 certificate containing the public key, which is what you need from them. Here is the command to generate a CSR (certificate signing request):</source>
          <target state="translated">然后他们需要生成一个包含公钥的x509证书,这就是你需要他们提供的。下面是生成CSR(证书签署请求)的命令。</target>
        </trans-unit>
        <trans-unit id="f98543252d0cf2bd1bc0835d978d514dcdabc924" translate="yes" xml:space="preserve">
          <source>Then they need to give you &lt;code&gt;delegation.crt&lt;/code&gt;, whether it is self-signed or signed by a CA.</source>
          <target state="translated">然后，无论是自签名的还是由CA签名的，他们都需要给您 &lt;code&gt;delegation.crt&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7f0f2bd70f5c8bbac6125eb7ed05e5ef0b2fdf49" translate="yes" xml:space="preserve">
          <source>Then write a docker-compose file that bind mounts it in:</source>
          <target state="translated">然后写一个docker-compose文件,绑定将其挂载进去。</target>
        </trans-unit>
        <trans-unit id="2f8d9774582e7502132f5270ffce97532f11b56e" translate="yes" xml:space="preserve">
          <source>Then you can set:</source>
          <target state="translated">然后你可以设置。</target>
        </trans-unit>
        <trans-unit id="571bfb0a1edc1b50bdfe5e978fd0ae01ac16b272" translate="yes" xml:space="preserve">
          <source>Then you need to run &lt;code&gt;source /etc/bash_completion.d/docker-machine-prompt.bash&lt;/code&gt; in your bash terminal to tell your setup where it can find the file &lt;code&gt;docker-machine-prompt.bash&lt;/code&gt; that you previously downloaded.</source>
          <target state="translated">然后，您需要在bash终端中运行 &lt;code&gt;source /etc/bash_completion.d/docker-machine-prompt.bash&lt;/code&gt; ，以告诉您的设置在哪里可以找到您先前下载 &lt;code&gt;docker-machine-prompt.bash&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="da78cfe7ed5b6cb10ab0b2174b36663e652c5c77" translate="yes" xml:space="preserve">
          <source>Then you provide account verification, security credentials, and configuration options for the providers as flags to &lt;code&gt;docker-machine create&lt;/code&gt;. The flags are unique for each cloud-specific driver. For instance, to pass a DigitalOcean access token you use the &lt;code&gt;--digitalocean-access-token&lt;/code&gt; flag. Take a look at the examples below for DigitalOcean and AWS.</source>
          <target state="translated">然后为提供者提供帐户验证，安全凭证和配置选项，作为 &lt;code&gt;docker-machine create&lt;/code&gt; 的标志。这些标志对于每个特定于云的驱动程序都是唯一的。例如，要传递DigitalOcean访问令牌，可以使用 &lt;code&gt;--digitalocean-access-token&lt;/code&gt; 标志。查看下面的DigitalOcean和AWS示例。</target>
        </trans-unit>
        <trans-unit id="199f762f8c8d3029eb46e8f8b8d9f5acda2921b7" translate="yes" xml:space="preserve">
          <source>Then, a user could ask &lt;code&gt;udev&lt;/code&gt; to execute a script that would &lt;code&gt;docker exec my-container mknod newDevX c 42 &amp;lt;minor&amp;gt;&lt;/code&gt; the required device when it is added.</source>
          <target state="translated">然后，用户可以要求 &lt;code&gt;udev&lt;/code&gt; 执行一个脚本，该脚本将在添加设备时 &lt;code&gt;docker exec my-container mknod newDevX c 42 &amp;lt;minor&amp;gt;&lt;/code&gt; 所需的设备。</target>
        </trans-unit>
        <trans-unit id="2854e1d7f0e6d6eec93f6eab6fe27b1c48cc1487" translate="yes" xml:space="preserve">
          <source>Then, assume this image is built with this command:</source>
          <target state="translated">然后,假设这个图像是用这个命令建立的。</target>
        </trans-unit>
        <trans-unit id="e6079812a1f2778a6a21c1d63667ecca6da677c8" translate="yes" xml:space="preserve">
          <source>Then, install the latest release of the Linode machine driver for your environment from the &lt;a href=&quot;https://github.com/linode/docker-machine-driver-linode/releases&quot;&gt;releases list&lt;/a&gt;.</source>
          <target state="translated">然后，从&lt;a href=&quot;https://github.com/linode/docker-machine-driver-linode/releases&quot;&gt;发行列表中&lt;/a&gt;为您的环境安装Linode机器驱动程序的最新版本。</target>
        </trans-unit>
        <trans-unit id="6806394a7c9ad960785738687166412a97ca5e1a" translate="yes" xml:space="preserve">
          <source>Then, run the custom profile with &lt;code&gt;--security-opt&lt;/code&gt; like so:</source>
          <target state="translated">然后，使用 &lt;code&gt;--security-opt&lt;/code&gt; 运行自定义配置文件，如下所示：</target>
        </trans-unit>
        <trans-unit id="b73e331846444f80e366e7040fb663466a3470e0" translate="yes" xml:space="preserve">
          <source>There are &lt;a href=&quot;https://github.com/search?q=in%3Apath+docker-compose.yml+extension%3Ayml&amp;amp;type=Code&quot;&gt;many examples of Compose files on github&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/search?q=in%3Apath+docker-compose.yml+extension%3Ayml&amp;amp;type=Code&quot;&gt;github上&lt;/a&gt;有很多Compose文件的示例。</target>
        </trans-unit>
        <trans-unit id="b7814cd8379144950605ca794127eccce00dcde3" translate="yes" xml:space="preserve">
          <source>There are currently three versions of the Compose file format:</source>
          <target state="translated">目前Compose文件格式有三个版本。</target>
        </trans-unit>
        <trans-unit id="7940b6f7dad82d1a9e956120f2b7089211bf1646" translate="yes" xml:space="preserve">
          <source>There are five possible container IDs all cycling by randomly, demonstrating the load-balancing.</source>
          <target state="translated">有五个可能的容器ID都是随机循环的,展示了负载均衡。</target>
        </trans-unit>
        <trans-unit id="0c0de849851d22b43f8ffa512bd662db77eca8ad" translate="yes" xml:space="preserve">
          <source>There are four major areas to consider when reviewing Docker security:</source>
          <target state="translated">在审查Docker安全时,主要有四个方面需要考虑。</target>
        </trans-unit>
        <trans-unit id="3d778b5b15fe825c32888587cbc69d4f27f45b66" translate="yes" xml:space="preserve">
          <source>There are multiple parts of Compose that deal with environment variables in one sense or another. This page should help you find the information you need.</source>
          <target state="translated">Compose 中有多个部分在某种意义上处理环境变量。本页应该可以帮助你找到你需要的信息。</target>
        </trans-unit>
        <trans-unit id="aeda8a40ea312e9777dda9667b4da9b34a9d0320" translate="yes" xml:space="preserve">
          <source>There are several cases where the user might want to set options for the created Docker engine (also known as the Docker &lt;em&gt;daemon&lt;/em&gt;) themselves. For example, they may want to allow connection to a &lt;a href=&quot;https://docs.docker.com/registry/&quot;&gt;registry&lt;/a&gt; that they are running themselves using the &lt;code&gt;--insecure-registry&lt;/code&gt; flag for the daemon. Docker Machine supports the configuration of such options for the created engines via the &lt;code&gt;create&lt;/code&gt; command flags which begin with &lt;code&gt;--engine&lt;/code&gt;.</source>
          <target state="translated">在某些情况下，用户可能希望自己为创建的Docker引擎（也称为Docker &lt;em&gt;守护程序&lt;/em&gt;）设置选项。例如，他们可能要允许连接到&lt;a href=&quot;https://docs.docker.com/registry/&quot;&gt;注册表中&lt;/a&gt;，他们使用的是自身运行 &lt;code&gt;--insecure-registry&lt;/code&gt; 标志守护进程。Docker Machine通过以 &lt;code&gt;--engine&lt;/code&gt; 开头的 &lt;code&gt;create&lt;/code&gt; 命令标志支持为已创建的引擎配置此类选项。</target>
        </trans-unit>
        <trans-unit id="97ca57e34878d9d455f58028c76cb939649ff43d" translate="yes" xml:space="preserve">
          <source>There are several things to be aware of when using &lt;code&gt;depends_on&lt;/code&gt;:</source>
          <target state="translated">使用 &lt;code&gt;depends_on&lt;/code&gt; 时需要注意以下几点：</target>
        </trans-unit>
        <trans-unit id="91711ed59c8022626f780ec2fbf3eb54e0f15adc" translate="yes" xml:space="preserve">
          <source>There are several things to note, depending on which &lt;a href=&quot;../compose-versioning/index#versioning&quot;&gt;Compose file version&lt;/a&gt; you&amp;rsquo;re using:</source>
          <target state="translated">根据您使用的&lt;a href=&quot;../compose-versioning/index#versioning&quot;&gt;Compose文件版本&lt;/a&gt;，有几件事需要注意：</target>
        </trans-unit>
        <trans-unit id="0187ca342f3a08a30c681cab0c7791034bfb8706" translate="yes" xml:space="preserve">
          <source>There are several versions of the Compose file format &amp;ndash; 1, 2, 2.x, and 3.x</source>
          <target state="translated">有多种版本的Compose文件格式&amp;ndash; 1，2，2.x和3.x</target>
        </trans-unit>
        <trans-unit id="25125d555c6868815e8ee9d7df65db55c5d2807c" translate="yes" xml:space="preserve">
          <source>There are several versions of the Compose file format &amp;ndash; 1, 2, 2.x, and 3.x The table below is a quick look. For full details on what each version includes and how to upgrade, see &lt;strong&gt;&lt;a href=&quot;../compose-versioning/index&quot;&gt;About versions and upgrading&lt;/a&gt;&lt;/strong&gt;.</source>
          <target state="translated">有多种版本的Compose文件格式&amp;ndash; 1，2，2.x和3.x下表是快速查看。有关每个版本包括什么以及如何升级的完整详细信息，请参阅&lt;strong&gt;&lt;a href=&quot;../compose-versioning/index&quot;&gt;关于版本和升级&lt;/a&gt;&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="40bc0cbdfa8ca5327db23d0dec4ef03b9664c4f2" translate="yes" xml:space="preserve">
          <source>There are several versions of the Compose file format &amp;ndash; 1, 2, 2.x, and 3.x. The table below is a quick look. For full details on what each version includes and how to upgrade, see &lt;strong&gt;&lt;a href=&quot;compose-versioning/index&quot;&gt;About versions and upgrading&lt;/a&gt;&lt;/strong&gt;.</source>
          <target state="translated">有多种版本的Compose文件格式&amp;ndash; 1，2，2.x和3.x。下表是快速浏览。有关每个版本包括什么以及如何升级的完整详细信息，请参阅&lt;strong&gt;&lt;a href=&quot;compose-versioning/index&quot;&gt;关于版本和升级&lt;/a&gt;&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="741d63007545485e619b16d848df8c7aff45bdf3" translate="yes" xml:space="preserve">
          <source>There are some variations in behavior between the two methods, so report any issues or inconsistencies if you come across them.</source>
          <target state="translated">两种方法之间的行为有一些差异,如果遇到任何问题或不一致的地方,请报告。</target>
        </trans-unit>
        <trans-unit id="e78ebb7a2059162d806fa2029f73ae7c6fcfa1b2" translate="yes" xml:space="preserve">
          <source>There are three types of files which can be put in the plugin directory.</source>
          <target state="translated">有三种类型的文件可以放在插件目录中。</target>
        </trans-unit>
        <trans-unit id="9cf0c0eaad237b6c73a28f6dd75f35d7f472776e" translate="yes" xml:space="preserve">
          <source>There are two options for trust pinning user-signed images:</source>
          <target state="translated">信任钉住用户签名的图片有两种选择。</target>
        </trans-unit>
        <trans-unit id="6ecf6e9b95eb4c02baccc868b92d4665fe217696" translate="yes" xml:space="preserve">
          <source>There are two types of nodes: &lt;a href=&quot;#manager-nodes&quot;&gt;&lt;strong&gt;managers&lt;/strong&gt;&lt;/a&gt; and &lt;a href=&quot;#worker-nodes&quot;&gt;&lt;strong&gt;workers&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">有两种类型的节点：&lt;a href=&quot;#manager-nodes&quot;&gt;&lt;strong&gt;管理者&lt;/strong&gt;&lt;/a&gt;和&lt;a href=&quot;#worker-nodes&quot;&gt;&lt;strong&gt;工人&lt;/strong&gt;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fc09e07084850510543084daf1f91c42a9f17fe3" translate="yes" xml:space="preserve">
          <source>There are two types of service deployments, replicated and global.</source>
          <target state="translated">服务部署有两种类型,复制式和全局式。</target>
        </trans-unit>
        <trans-unit id="45b1371ce6228c69ca79895526ca065b03babbe6" translate="yes" xml:space="preserve">
          <source>There are two viable workarounds for this problem:</source>
          <target state="translated">对于这个问题,有两种可行的变通办法。</target>
        </trans-unit>
        <trans-unit id="dbd4f77633783e3c8d534038973dd23605b9f89f" translate="yes" xml:space="preserve">
          <source>There are two ways to connect to the PostgreSQL server. We can use &lt;a href=&quot;https://docs.docker.com/network&quot;&gt;&lt;em&gt;Link Containers&lt;/em&gt;&lt;/a&gt;, or we can access it from our host (or the network).</source>
          <target state="translated">有两种连接到PostgreSQL服务器的方法。我们可以使用&lt;a href=&quot;https://docs.docker.com/network&quot;&gt;&lt;em&gt;链接容器&lt;/em&gt;&lt;/a&gt;，也可以从主机（或网络）访问它。</target>
        </trans-unit>
        <trans-unit id="2a9bea40f116e961dedc24c36590df75bee7e1ef" translate="yes" xml:space="preserve">
          <source>There are two ways to run the Engine in swarm mode:</source>
          <target state="translated">在蜂群模式下运行引擎有两种方式。</target>
        </trans-unit>
        <trans-unit id="f54c1303cdfa771953ec88e0bfab370d1cdc3de0" translate="yes" xml:space="preserve">
          <source>There can only be one &lt;code&gt;CMD&lt;/code&gt; instruction in a &lt;code&gt;Dockerfile&lt;/code&gt;. If you list more than one &lt;code&gt;CMD&lt;/code&gt; then only the last &lt;code&gt;CMD&lt;/code&gt; will take effect.</source>
          <target state="translated">&lt;code&gt;Dockerfile&lt;/code&gt; 中只能有一个 &lt;code&gt;CMD&lt;/code&gt; 指令。如果您列出多个 &lt;code&gt;CMD&lt;/code&gt; ,则只有最后一个 &lt;code&gt;CMD&lt;/code&gt; 才会生效。</target>
        </trans-unit>
        <trans-unit id="550d578e017477c6594796ed69856a32f3fde0d2" translate="yes" xml:space="preserve">
          <source>There can only be one &lt;code&gt;HEALTHCHECK&lt;/code&gt; instruction in a Dockerfile. If you list more than one then only the last &lt;code&gt;HEALTHCHECK&lt;/code&gt; will take effect.</source>
          <target state="translated">&lt;code&gt;HEALTHCHECK&lt;/code&gt; 只能有一条HEALTHCHECK指令。如果您列出多个，则只有最后一个&amp;ldquo; &lt;code&gt;HEALTHCHECK&lt;/code&gt; 才会生效。</target>
        </trans-unit>
        <trans-unit id="0df320a875323d0c7c7d6a4f46cd3776c2f98030" translate="yes" xml:space="preserve">
          <source>There has already been a lot written about this problem of &lt;a href=&quot;https://medium.com/@gchudnov/trapping-signals-in-docker-containers-7a57fdda7d86&quot;&gt;processes handling signals&lt;/a&gt; in containers.</source>
          <target state="translated">关于&lt;a href=&quot;https://medium.com/@gchudnov/trapping-signals-in-docker-containers-7a57fdda7d86&quot;&gt;处理&lt;/a&gt;容器中信号的过程的问题已经有很多文章了。</target>
        </trans-unit>
        <trans-unit id="77d469c7c182850a6574b09d72ba3863433df44e" translate="yes" xml:space="preserve">
          <source>There is a limit to the number of machines that an anti-affinity group can have. This can be worked around by specifying an additional anti-affinity group using &lt;code&gt;--exoscale-affinity-group=docker-machineX&lt;/code&gt;</source>
          <target state="translated">反关联组可以拥有的计算机数量是有限的。可以通过使用 &lt;code&gt;--exoscale-affinity-group=docker-machineX&lt;/code&gt; 指定其他反亲和力组来解决此问题</target>
        </trans-unit>
        <trans-unit id="a003cd7737f7589bad419544346f832d93be43fc" translate="yes" xml:space="preserve">
          <source>There is a side effect when using this flag: user remapping will not be enabled for that container but, because the read-only (image) layers are shared between containers, ownership of the the containers filesystem will still be remapped.</source>
          <target state="translated">使用此标志时有一个副作用:不会为该容器启用用户重映射,但由于容器之间共享只读(映像)层,容器文件系统的所有权仍将被重映射。</target>
        </trans-unit>
        <trans-unit id="807fe7b30bf42d01a6f7b614c0c1e3e2cf015de6" translate="yes" xml:space="preserve">
          <source>There is also a long format, which is easier to read and allows you to specify more options. The long format is preferred. You cannot specify the service&amp;rsquo;s mode when using the short format. Here is an example of using the long format for the same service as above:</source>
          <target state="translated">还有一个长格式，它更易于阅读，并允许您指定更多选项。长格式是首选。使用短格式时，无法指定服务的模式。这是对上述相同服务使用长格式的示例：</target>
        </trans-unit>
        <trans-unit id="7159817725d7d3f10517f75ce07ddcc5d62ded9f" translate="yes" xml:space="preserve">
          <source>There is much more to the Docker platform than what was covered here, but you have a good idea of the basics of containers, images, services, swarms, stacks, scaling, load-balancing, volumes, and placement constraints.</source>
          <target state="translated">Docker平台的内容比这里介绍的要多得多,但你对容器、映像、服务、群集、堆栈、扩展、负载平衡、卷和放置约束等基础知识已经有了很好的了解。</target>
        </trans-unit>
        <trans-unit id="8ea1f9e166a0f3ace0e8c4e2faba71437003d220" translate="yes" xml:space="preserve">
          <source>There is no limit on the number of manager nodes. The decision about how many manager nodes to implement is a trade-off between performance and fault-tolerance. Adding manager nodes to a swarm makes the swarm more fault-tolerant. However, additional manager nodes reduce write performance because more nodes must acknowledge proposals to update the swarm state. This means more network round-trip traffic.</source>
          <target state="translated">管理节点的数量没有限制。关于实现多少个管理节点的决定是在性能和容错性之间的权衡。将管理节点添加到蜂群中会使蜂群更加容错。然而,额外的管理节点会降低写入性能,因为更多的节点必须确认更新蜂群状态的提议。这意味着更多的网络往返流量。</target>
        </trans-unit>
        <trans-unit id="c46ae2b51f093b4d567a20743cf894773a9d4341" translate="yes" xml:space="preserve">
          <source>There is no memory limit for the container. The container can use as much memory as needed.</source>
          <target state="translated">容器没有内存限制。容器可以根据需要使用多少内存。</target>
        </trans-unit>
        <trans-unit id="54df66a39d52c7bcabb4266fa44bd074305be26b" translate="yes" xml:space="preserve">
          <source>There is no special handling of quotation marks. This means that &lt;strong&gt;they are part of the VAL&lt;/strong&gt;.</source>
          <target state="translated">引号没有特殊处理。这意味着&lt;strong&gt;它们是VAL的一部分&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="bc8488fc468fa3d5bf59b15f4d91a3229dc387f4" translate="yes" xml:space="preserve">
          <source>There may be cases where you want to use both. You can have the image include the code using a &lt;code&gt;COPY&lt;/code&gt;, and use a &lt;code&gt;volume&lt;/code&gt; in your Compose file to include the code from the host during development. The volume overrides the directory contents of the image.</source>
          <target state="translated">在某些情况下，您可能要同时使用两者。您可以使用 &lt;code&gt;COPY&lt;/code&gt; 使映像包含代码，并在开发过程中使用Compose文件中的 &lt;code&gt;volume&lt;/code&gt; 包含来自主机的代码。该卷将覆盖映像的目录内容。</target>
        </trans-unit>
        <trans-unit id="9151a652d582569b556b13188766c2cd2a43286b" translate="yes" xml:space="preserve">
          <source>Therefore, node labels can be used to limit critical tasks to nodes that meet certain requirements. For example, schedule only on machines where special workloads should be run, such as machines that meet &lt;a href=&quot;https://www.pcisecuritystandards.org/&quot;&gt;PCI-SS compliance&lt;/a&gt;.</source>
          <target state="translated">因此，节点标签可用于将关键任务限制为满足某些要求的节点。例如，仅在应运行特殊工作负载的计算机（例如符合&lt;a href=&quot;https://www.pcisecuritystandards.org/&quot;&gt;PCI-SS法规要求的计算机）上计划&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="311428cc61f122ac8f0ff1fe39f6b93b94ca88a8" translate="yes" xml:space="preserve">
          <source>These &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;ctrl-a&lt;/code&gt;, &lt;code&gt;X&lt;/code&gt;, or &lt;code&gt;ctrl-\\&lt;/code&gt; values are all examples of valid key sequences. To configure a different configuration default key sequence for all containers, see &lt;a href=&quot;../cli/index#configuration-files&quot;&gt;&lt;strong&gt;Configuration file&lt;/strong&gt; section&lt;/a&gt;.</source>
          <target state="translated">这些 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;ctrl-a&lt;/code&gt; ， &lt;code&gt;X&lt;/code&gt; 或 &lt;code&gt;ctrl-\\&lt;/code&gt; 值都是有效键序列的示例。要为所有容器配置不同的配置默认键序列，请参阅&amp;ldquo; &lt;a href=&quot;../cli/index#configuration-files&quot;&gt;&lt;strong&gt;配置文件&amp;rdquo;&lt;/strong&gt;部分&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="64b5474c1794485b2d40653c9e2e09081765ab8a" translate="yes" xml:space="preserve">
          <source>These Go environment variables are case-insensitive. See the &lt;a href=&quot;http://golang.org/pkg/net/http/&quot;&gt;Go specification&lt;/a&gt; for details on these variables.</source>
          <target state="translated">这些Go环境变量不区分大小写。有关这些变量的详细信息，请参见&lt;a href=&quot;http://golang.org/pkg/net/http/&quot;&gt;Go规范&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8ba86a5d568343c9da0766df96e235161cf63bc5" translate="yes" xml:space="preserve">
          <source>These Go environment variables are case-insensitive. See the &lt;a href=&quot;https://golang.org/pkg/net/http/&quot;&gt;Go specification&lt;/a&gt; for details on these variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31caaf6623b9c633e6c1073eb9040be966d639aa" translate="yes" xml:space="preserve">
          <source>These are created once when the first machine is created and reused afterwards. Although they are free resources, driver does a best effort to clean them up after the last machine using these resources is removed.</source>
          <target state="translated">这些资源会在创建第一台机器时创建一次,并在之后重复使用。虽然它们是免费的资源,但在最后一台使用这些资源的机器被删除后,驱动程序会尽力清理它们。</target>
        </trans-unit>
        <trans-unit id="39fe1e5ad586d0e7cf7856a65e7b6669576d3d25" translate="yes" xml:space="preserve">
          <source>These are the ports you need to expose for each service:</source>
          <target state="translated">这些是您需要为每个服务公开的端口。</target>
        </trans-unit>
        <trans-unit id="bac967147ac9fac7063b2796ffd0dbb09be399f8" translate="yes" xml:space="preserve">
          <source>These arguments are defined in the global scope so are not automatically available inside build stages or for your &lt;code&gt;RUN&lt;/code&gt; commands. To expose one of these arguments inside the build stage redefine it without value.</source>
          <target state="translated">这些参数在全局范围内定义，因此在构建阶段或 &lt;code&gt;RUN&lt;/code&gt; 命令中不会自动提供。为了在构建阶段公开这些参数之一，请重新定义它而没有价值。</target>
        </trans-unit>
        <trans-unit id="584b62ca74acc41372cd2036de01d6464c923b50" translate="yes" xml:space="preserve">
          <source>These command examples shows a Bash shell. For a different shell, such as C Shell, the same commands are the same except where noted.</source>
          <target state="translated">这些命令示例显示的是一个Bash shell。对于不同的shell,如C Shell,除了在某些地方注明外,相同的命令是相同的。</target>
        </trans-unit>
        <trans-unit id="e74c851f71498e84ce39a15acf42934d7c72f3de" translate="yes" xml:space="preserve">
          <source>These differences are explained below.</source>
          <target state="translated">下文将对这些区别进行解释。</target>
        </trans-unit>
        <trans-unit id="7246908a42dc07a518a78b2cabf07f47d70b301a" translate="yes" xml:space="preserve">
          <source>These flags were added before Docker 1.0, so will not be &lt;em&gt;removed&lt;/em&gt;, only &lt;em&gt;hidden&lt;/em&gt;, to discourage their use.</source>
          <target state="translated">这些标志是在Docker 1.0之前添加的，因此不会被&lt;em&gt;删除&lt;/em&gt;，只会被&lt;em&gt;隐藏&lt;/em&gt;，以阻止使用。</target>
        </trans-unit>
        <trans-unit id="c2b20459caa4cc0cc4428337ecd3dbaee5eb97fb" translate="yes" xml:space="preserve">
          <source>These instructions assume you are running in Linux or macOS. You can run this sandbox on a local machine or on a virtual machine. You need to have privileges to run docker commands on your local machine or in the VM.</source>
          <target state="translated">这些说明假设您在Linux或macOS中运行。您可以在本地机器或虚拟机上运行此沙箱。您需要拥有在本地机器或虚拟机中运行docker命令的权限。</target>
        </trans-unit>
        <trans-unit id="4d8c56cad2f39c4a7b2f668100d9da8dd6631ef4" translate="yes" xml:space="preserve">
          <source>These instructions assume you have installed the Docker Engine 1.12 or later on a machine to serve as a manager node in your swarm.</source>
          <target state="translated">这些说明假设您已经在一台机器上安装了Docker Engine 1.12或更高版本,以作为群中的管理节点。</target>
        </trans-unit>
        <trans-unit id="84e044fa18790282168ffba099e31deab2a0f085" translate="yes" xml:space="preserve">
          <source>These options are passed directly to the volume driver. Options for different volume drivers may do different things (or nothing at all).</source>
          <target state="translated">这些选项会直接传递给音量驱动。不同的音量驱动的选项可能有不同的作用(或者根本没有作用)。</target>
        </trans-unit>
        <trans-unit id="230271f219630a6dfecde6978e6f7c8484085c31" translate="yes" xml:space="preserve">
          <source>These parameters always set an upper limit on the memory available to the container. On Linux, this is set on the cgroup and applications in a container can query it at &lt;code&gt;/sys/fs/cgroup/memory/memory.limit_in_bytes&lt;/code&gt;.</source>
          <target state="translated">这些参数始终为容器可用的内存设置上限。在Linux上，这是在cgroup上设置的，容器中的应用程序可以在 &lt;code&gt;/sys/fs/cgroup/memory/memory.limit_in_bytes&lt;/code&gt; 处对其进行查询。</target>
        </trans-unit>
        <trans-unit id="bb1e65e28097900a5e6798cdcb5c67d92ccb7612" translate="yes" xml:space="preserve">
          <source>These portable images are defined by something called a &lt;code&gt;Dockerfile&lt;/code&gt;.</source>
          <target state="translated">这些可移植映像由称为 &lt;code&gt;Dockerfile&lt;/code&gt; 的东西定义。</target>
        </trans-unit>
        <trans-unit id="c44349d63c8f29613ee6fa93097acd99df2851dd" translate="yes" xml:space="preserve">
          <source>These properties are deprecated in favor of per-network properties in &lt;code&gt;NetworkSettings.Networks&lt;/code&gt;. These properties were already &amp;ldquo;deprecated&amp;rdquo; in docker 1.9, but kept around for backward compatibility.</source>
          <target state="translated">不推荐使用这些属性，而推荐使用 &lt;code&gt;NetworkSettings.Networks&lt;/code&gt; 中的每个网络属性。这些属性已在Docker 1.9中&amp;ldquo;弃用&amp;rdquo;，但为了向后兼容而保留。</target>
        </trans-unit>
        <trans-unit id="95ad3420806ce4f7e45f02368e5d74ee7259066d" translate="yes" xml:space="preserve">
          <source>These settings are determined by the &lt;a href=&quot;https://hub.docker.com/images/postgres&quot;&gt;postgres&lt;/a&gt; Docker image specified in &lt;code&gt;docker-compose.yml&lt;/code&gt;.</source>
          <target state="translated">这些设置由 &lt;code&gt;docker-compose.yml&lt;/code&gt; 中指定的&lt;a href=&quot;https://hub.docker.com/images/postgres&quot;&gt;postgres&lt;/a&gt; Docker映像确定。</target>
        </trans-unit>
        <trans-unit id="0006a01688ee5bb8760e82efcaab62e7a7b452cd" translate="yes" xml:space="preserve">
          <source>These syntax rules apply to the &lt;code&gt;.env&lt;/code&gt; file:</source>
          <target state="translated">这些语法规则适用于 &lt;code&gt;.env&lt;/code&gt; 文件：</target>
        </trans-unit>
        <trans-unit id="0c4632832f247dcfe72ed61367b13859852ff268" translate="yes" xml:space="preserve">
          <source>These topics describe version 1 of the Compose file format. This is the oldest version.</source>
          <target state="translated">这些主题描述了 Compose 文件格式的第 1 版。这是最老的版本。</target>
        </trans-unit>
        <trans-unit id="37e57e0e52a34f096be81802356245c57ce84aec" translate="yes" xml:space="preserve">
          <source>These topics describe version 2 of the Compose file format.</source>
          <target state="translated">这些主题描述了 Compose 文件格式的第 2 版。</target>
        </trans-unit>
        <trans-unit id="239f599300fe3779fc761e4efc4bdc384fbe57be" translate="yes" xml:space="preserve">
          <source>These topics describe version 3 of the Compose file format. This is the newest version.</source>
          <target state="translated">这些主题描述了 Compose 文件格式的第 3 版。这是最新的版本。</target>
        </trans-unit>
        <trans-unit id="9bf35be4d7ca6fb7048d753152c839ba29757169" translate="yes" xml:space="preserve">
          <source>These two &lt;code&gt;docker build&lt;/code&gt; commands do the exact same thing. They both use the contents of the &lt;code&gt;debug&lt;/code&gt; file instead of looking for a &lt;code&gt;Dockerfile&lt;/code&gt; and will use &lt;code&gt;/home/me/myapp&lt;/code&gt; as the root of the build context. Note that &lt;code&gt;debug&lt;/code&gt; is in the directory structure of the build context, regardless of how you refer to it on the command line.</source>
          <target state="translated">这两个 &lt;code&gt;docker build&lt;/code&gt; 命令执行的操作完全相同。他们都使用 &lt;code&gt;debug&lt;/code&gt; 文件的内容而不是寻找 &lt;code&gt;Dockerfile&lt;/code&gt; ，并将使用 &lt;code&gt;/home/me/myapp&lt;/code&gt; 作为构建上下文的根。请注意，无论您在命令行中如何引用 &lt;code&gt;debug&lt;/code&gt; ，调试都位于构建上下文的目录结构中。</target>
        </trans-unit>
        <trans-unit id="3bc9ec20c6ba6550b3916f42f42debaecc83c305" translate="yes" xml:space="preserve">
          <source>They should keep &lt;code&gt;delegation.key&lt;/code&gt; private because it is used to sign tags.</source>
          <target state="translated">他们应该将 &lt;code&gt;delegation.key&lt;/code&gt; 设为私有，因为它用于标记标签。</target>
        </trans-unit>
        <trans-unit id="f8bb7a76c170c136f81e1e0fbc79c555341c4e8c" translate="yes" xml:space="preserve">
          <source>This (size) will allow to set the container rootfs size to 120G at creation time. This option is only available for the &lt;code&gt;devicemapper&lt;/code&gt;, &lt;code&gt;btrfs&lt;/code&gt;, &lt;code&gt;overlay2&lt;/code&gt;, &lt;code&gt;windowsfilter&lt;/code&gt; and &lt;code&gt;zfs&lt;/code&gt; graph drivers. For the &lt;code&gt;devicemapper&lt;/code&gt;, &lt;code&gt;btrfs&lt;/code&gt;, &lt;code&gt;windowsfilter&lt;/code&gt; and &lt;code&gt;zfs&lt;/code&gt; graph drivers, user cannot pass a size less than the Default BaseFS Size. For the &lt;code&gt;overlay2&lt;/code&gt; storage driver, the size option is only available if the backing fs is &lt;code&gt;xfs&lt;/code&gt; and mounted with the &lt;code&gt;pquota&lt;/code&gt; mount option. Under these conditions, user can pass any size less than the backing fs size.</source>
          <target state="translated">此（大小）将允许在创建时将容器rootfs大小设置为120G。此选项仅适用于 &lt;code&gt;devicemapper&lt;/code&gt; ， &lt;code&gt;btrfs&lt;/code&gt; ， &lt;code&gt;overlay2&lt;/code&gt; ， &lt;code&gt;windowsfilter&lt;/code&gt; 和 &lt;code&gt;zfs&lt;/code&gt; 图驱动程序。对于 &lt;code&gt;devicemapper&lt;/code&gt; ， &lt;code&gt;btrfs&lt;/code&gt; ， &lt;code&gt;windowsfilter&lt;/code&gt; 和 &lt;code&gt;zfs&lt;/code&gt; 图驱动程序，用户不能传递的大小小于Default BaseFS Size的大小。对于 &lt;code&gt;overlay2&lt;/code&gt; 存储驱动程序，仅当背衬fs为 &lt;code&gt;xfs&lt;/code&gt; 并使用 &lt;code&gt;pquota&lt;/code&gt; 挂载选项挂载时，size选项才可用。在这种情况下，用户可以传递小于背衬fs尺寸的任何尺寸。</target>
        </trans-unit>
        <trans-unit id="0f57ef99877faf08ed983654bb76f051727a7a4a" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;Dockerfile&lt;/code&gt; refers to a couple of files we haven&amp;rsquo;t created yet, namely &lt;code&gt;app.py&lt;/code&gt; and &lt;code&gt;requirements.txt&lt;/code&gt;. Let&amp;rsquo;s create those next.</source>
          <target state="translated">该 &lt;code&gt;Dockerfile&lt;/code&gt; 引用了我们尚未创建的几个文件，即 &lt;code&gt;app.py&lt;/code&gt; 和 &lt;code&gt;requirements.txt&lt;/code&gt; 。接下来创建它们。</target>
        </trans-unit>
        <trans-unit id="47b5a932b8b87db6fd83585f80ce51e69d78bd4d" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;Dockerfile&lt;/code&gt; starts with a &lt;a href=&quot;https://hub.docker.com/r/library/python/tags/3/&quot;&gt;Python 3 parent image&lt;/a&gt;. The parent image is modified by adding a new &lt;code&gt;code&lt;/code&gt; directory. The parent image is further modified by installing the Python requirements defined in the &lt;code&gt;requirements.txt&lt;/code&gt; file.</source>
          <target state="translated">该 &lt;code&gt;Dockerfile&lt;/code&gt; 以&lt;a href=&quot;https://hub.docker.com/r/library/python/tags/3/&quot;&gt;Python 3父映像&lt;/a&gt;开头。通过添加新的 &lt;code&gt;code&lt;/code&gt; 目录来修改父映像。父图像是通过安装在限定了Python要求进一步修改 &lt;code&gt;requirements.txt&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="fcc11cd71fd30d08d07edb398a96dbfeeb5387c9" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;docker-compose.yml&lt;/code&gt; file tells Docker to do the following:</source>
          <target state="translated">该 &lt;code&gt;docker-compose.yml&lt;/code&gt; 文件告诉Docker执行以下操作：</target>
        </trans-unit>
        <trans-unit id="42b222153a9a1c425f836be3f93bd24f5404188e" translate="yes" xml:space="preserve">
          <source>This Compose file defines two services: &lt;code&gt;web&lt;/code&gt; and &lt;code&gt;redis&lt;/code&gt;.</source>
          <target state="translated">该Compose文件定义了两个服务： &lt;code&gt;web&lt;/code&gt; 和 &lt;code&gt;redis&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="358fc9bba91271cbe664fce4a5159a52599bd1b3" translate="yes" xml:space="preserve">
          <source>This Dockerfile results in an image that causes &lt;code&gt;docker run&lt;/code&gt; to create a new mount point at &lt;code&gt;/myvol&lt;/code&gt; and copy the &lt;code&gt;greeting&lt;/code&gt; file into the newly created volume.</source>
          <target state="translated">该Dockerfile生成一个映像，该映像使docker &lt;code&gt;docker run&lt;/code&gt; 在 &lt;code&gt;/myvol&lt;/code&gt; 创建一个新的挂载点并将 &lt;code&gt;greeting&lt;/code&gt; 文件复制到新创建的卷中。</target>
        </trans-unit>
        <trans-unit id="75674b77be279ff4516a3e04e754ff23ee2f1790" translate="yes" xml:space="preserve">
          <source>This Quickstart guide shows you how to use Docker Compose to set up and run a Rails/PostgreSQL app. Before starting, &lt;a href=&quot;../install/index&quot;&gt;install Compose&lt;/a&gt;.</source>
          <target state="translated">本快速入门指南介绍了如何使用Docker Compose设置和运行Rails / PostgreSQL应用程序。在开始之前，&lt;a href=&quot;../install/index&quot;&gt;请安装Compose&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f01905754800cfb79fe2f86a2616a78f01578a67" translate="yes" xml:space="preserve">
          <source>This adds the local file &lt;code&gt;my_file.txt&lt;/code&gt; (which must exist relative to the current working directory), under the target name &lt;code&gt;v1&lt;/code&gt;, to the &lt;code&gt;example.com/collection&lt;/code&gt; collection we set up. The contents of the local file are not actually added to the collection - a &amp;ldquo;target&amp;rdquo; consists of the file path and one or more checksums of the contents.</source>
          <target state="translated">这会将目标名称 &lt;code&gt;v1&lt;/code&gt; 下的本地文件 &lt;code&gt;my_file.txt&lt;/code&gt; （必须相对于当前工作目录存在）添加到我们设置的 &lt;code&gt;example.com/collection&lt;/code&gt; 集合中。本地文件的内容实际上并未添加到集合中-&amp;ldquo;目标&amp;rdquo;由文件路径和内容的一个或多个校验和组成。</target>
        </trans-unit>
        <trans-unit id="df4a4d34e6996802cfe8fa551770ac282cbd2296" translate="yes" xml:space="preserve">
          <source>This also causes a change in the swarm&amp;rsquo;s join tokens. The previous join tokens are no longer valid.</source>
          <target state="translated">这也会导致群集的连接令牌发生变化。先前的连接令牌不再有效。</target>
        </trans-unit>
        <trans-unit id="86a0e1e2e2d988ec765aa8086c19c406f4640726" translate="yes" xml:space="preserve">
          <source>This article demonstrates how to ensure the traffic between the Docker registry server and the Docker daemon (a client of the registry server) is encrypted and properly authenticated using &lt;em&gt;certificate-based client-server authentication&lt;/em&gt;.</source>
          <target state="translated">本文演示了如何确保Docker注册表服务器和Docker守护程序（注册表服务器的客户端）之间的流量经过加密，并使用&lt;em&gt;基于证书的客户端服务器身份&lt;/em&gt;验证进行了正确身份&lt;em&gt;验证&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="9d38d1f1f6a9a807fd73d238aabfdc22a2067cc2" translate="yes" xml:space="preserve">
          <source>This behavior illustrates that the requirements and configuration of your tasks are not tightly tied to the current state of the swarm. As the administrator of a swarm, you declare the desired state of your swarm, and the manager works with the nodes in the swarm to create that state. You do not need to micro-manage the tasks on the swarm.</source>
          <target state="translated">这种行为说明,你的任务的需求和配置并不与蜂群的当前状态紧密相连。作为虫群的管理员,您声明您的虫群所需的状态,管理员与虫群中的节点一起工作以创建该状态。您不需要对蜂群上的任务进行微观管理。</target>
        </trans-unit>
        <trans-unit id="e1c412d460861eab1e7925494ef21e2f85862ad8" translate="yes" xml:space="preserve">
          <source>This binds port &lt;code&gt;8080&lt;/code&gt; of the container to TCP port &lt;code&gt;80&lt;/code&gt; on &lt;code&gt;127.0.0.1&lt;/code&gt; of the host machine. You can also specify &lt;code&gt;udp&lt;/code&gt; and &lt;code&gt;sctp&lt;/code&gt; ports. The &lt;a href=&quot;https://docs.docker.com/network&quot;&gt;Docker User Guide&lt;/a&gt; explains in detail how to manipulate ports in Docker.</source>
          <target state="translated">这个绑定端口 &lt;code&gt;8080&lt;/code&gt; 的容器以TCP端口 &lt;code&gt;80&lt;/code&gt; 上 &lt;code&gt;127.0.0.1&lt;/code&gt; 主机的。您还可以指定 &lt;code&gt;udp&lt;/code&gt; 和 &lt;code&gt;sctp&lt;/code&gt; 端口。《&lt;a href=&quot;https://docs.docker.com/network&quot;&gt;Docker用户指南》&lt;/a&gt;详细解释了如何在Docker中操作端口。</target>
        </trans-unit>
        <trans-unit id="f1d02d4b2ae7965df9c4265d0e3adff2cc9369f8" translate="yes" xml:space="preserve">
          <source>This builds the development Notary server and Notary signer images, and start up containers for the Notary server, Notary signer, and the MySQL database that both of them share. The MySQL data is stored in a volume.</source>
          <target state="translated">这构建了开发公证服务器和公证签名器的镜像,以及公证服务器、公证签名器和它们两者共享的MySQL数据库的启动容器。MySQL数据存储在一个卷中。</target>
        </trans-unit>
        <trans-unit id="97f761181ab7632d59e26ed008632c00f572855e" translate="yes" xml:space="preserve">
          <source>This can be used to create a context out of an existing &lt;code&gt;DOCKER_HOST&lt;/code&gt; based script:</source>
          <target state="translated">这可用于从现有的基于 &lt;code&gt;DOCKER_HOST&lt;/code&gt; 的脚本中创建上下文：</target>
        </trans-unit>
        <trans-unit id="edce6ba04bb5661e80ee7609a1990a5b26a9e5aa" translate="yes" xml:space="preserve">
          <source>This causes problems when using a web server such as Nginx to serve static files from a shared volume. For development environments, a good workaround is to disable sendfile in your server configuration.</source>
          <target state="translated">当使用诸如Nginx这样的Web服务器从共享卷中提供静态文件时,这会导致问题。对于开发环境,一个很好的解决方法是在服务器配置中禁用sendfile。</target>
        </trans-unit>
        <trans-unit id="0af2aba4a2db980cbd2853a408306d57c1c6a1c8" translate="yes" xml:space="preserve">
          <source>This command displays system wide information regarding the Docker installation. Information displayed includes the kernel version, number of containers and images. The number of images shown is the number of unique images. The same image tagged under different names is counted only once.</source>
          <target state="translated">该命令显示系统范围内有关Docker安装的信息。显示的信息包括内核版本、容器数量和镜像数量。显示的映像数量是指唯一的映像数量。以不同名称标记的同一镜像只计算一次。</target>
        </trans-unit>
        <trans-unit id="240ca2085f5947e49de738600c8da8f441afca27" translate="yes" xml:space="preserve">
          <source>This command downloads a lightweight Linux distribution (&lt;a href=&quot;https://github.com/boot2docker/boot2docker&quot;&gt;boot2docker&lt;/a&gt;) with the Docker daemon installed, and creates and starts a VirtualBox VM with Docker running.</source>
          <target state="translated">此命令下载安装了Docker守护程序的轻量级Linux发行版（&lt;a href=&quot;https://github.com/boot2docker/boot2docker&quot;&gt;boot2docker&lt;/a&gt;），并在运行Docker的情况下创建并启动VirtualBox VM。</target>
        </trans-unit>
        <trans-unit id="35184527810629c1311c56b69a8f765cc48c694d" translate="yes" xml:space="preserve">
          <source>This command is experimental on the Docker client. It should not be used in production environments. To enable experimental features in the Docker CLI, edit the &lt;a href=&quot;../cli/index#configuration-files&quot;&gt;config.json&lt;/a&gt; and set &lt;code&gt;experimental&lt;/code&gt; to &lt;code&gt;enabled&lt;/code&gt;.</source>
          <target state="translated">该命令在Docker客户端上是实验性的。它不应在生产环境中使用。要在Docker CLI中启用实验性功能，请编辑&lt;a href=&quot;../cli/index#configuration-files&quot;&gt;config.json&lt;/a&gt;并将 &lt;code&gt;experimental&lt;/code&gt; 设置为 &lt;code&gt;enabled&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="df32b930eb31af34fe2b76612ef1e6f0009304a3" translate="yes" xml:space="preserve">
          <source>This command is experimental on the Docker daemon. It should not be used in production environments. To enable experimental features on the Docker daemon, edit the &lt;a href=&quot;../dockerd/index#daemon-configuration-file&quot;&gt;daemon.json&lt;/a&gt; and set &lt;code&gt;experimental&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">该命令在Docker守护程序上是实验性的。它不应在生产环境中使用。要在Docker守护程序上启用实验性功能，请编辑&lt;a href=&quot;../dockerd/index#daemon-configuration-file&quot;&gt;daemon.json&lt;/a&gt;并将 &lt;code&gt;experimental&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b4fad7e4f212ad30b2c2846839873bab6f4ae67d" translate="yes" xml:space="preserve">
          <source>This command is experimental.</source>
          <target state="translated">这个命令是试验性的。</target>
        </trans-unit>
        <trans-unit id="e3a6d53a3cf2ebcf1bd54d7f955d415d822847a8" translate="yes" xml:space="preserve">
          <source>This command is optional because the person who created the &lt;code&gt;IMAGE&lt;/code&gt; may have already provided a default &lt;code&gt;COMMAND&lt;/code&gt; using the Dockerfile &lt;code&gt;CMD&lt;/code&gt; instruction. As the operator (the person running a container from the image), you can override that &lt;code&gt;CMD&lt;/code&gt; instruction just by specifying a new &lt;code&gt;COMMAND&lt;/code&gt;.</source>
          <target state="translated">该命令是可选的，因为创建 &lt;code&gt;IMAGE&lt;/code&gt; 的人员可能已经使用Dockerfile &lt;code&gt;CMD&lt;/code&gt; 指令提供了默认 &lt;code&gt;COMMAND&lt;/code&gt; 。作为操作员（从图像运行容器的人员），您只需指定新的 &lt;code&gt;COMMAND&lt;/code&gt; 即可覆盖该 &lt;code&gt;CMD&lt;/code&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="e297bdb9616106c472adc915c5da37860a04aa4e" translate="yes" xml:space="preserve">
          <source>This command pulls all images from the &lt;code&gt;fedora&lt;/code&gt; repository:</source>
          <target state="translated">此命令从 &lt;code&gt;fedora&lt;/code&gt; 存储库中提取所有图像：</target>
        </trans-unit>
        <trans-unit id="365f6a7147122b686375358bdf74e35f3d587264" translate="yes" xml:space="preserve">
          <source>This command when run targeting a manager, lists services are running in the swarm.</source>
          <target state="translated">该命令以管理器为目标运行时,会列出群中正在运行的服务。</target>
        </trans-unit>
        <trans-unit id="ddf782cc635d52ac46f7c8308682cd36d0868308" translate="yes" xml:space="preserve">
          <source>This command will delete all stopped containers. The command &lt;code&gt;docker ps -a -q&lt;/code&gt; will return all existing container IDs and pass them to the &lt;code&gt;rm&lt;/code&gt; command which will delete them. Any running containers will not be deleted.</source>
          <target state="translated">此命令将删除所有停止的容器。命令 &lt;code&gt;docker ps -a -q&lt;/code&gt; 将返回所有现有的容器ID，并将其传递给 &lt;code&gt;rm&lt;/code&gt; 命令，该命令将删除它们。任何正在运行的容器都不会被删除。</target>
        </trans-unit>
        <trans-unit id="a22c94088bd64bc47d90d7a2bf3e8f1ae563b3ae" translate="yes" xml:space="preserve">
          <source>This command will force-remove a running container.</source>
          <target state="translated">该命令将强制删除正在运行的容器。</target>
        </trans-unit>
        <trans-unit id="24bca651c57768c2cbbc0f8a0064b563ef57bafa" translate="yes" xml:space="preserve">
          <source>This command will remove the container and any volumes associated with it. Note that if a volume was specified with a name, it will not be removed.</source>
          <target state="translated">此命令将删除该容器和与之相关的任何卷。请注意,如果指定了卷的名称,它将不会被删除。</target>
        </trans-unit>
        <trans-unit id="7a907da2bfe0f1e4e51ceded4cd12d4f72da28ae" translate="yes" xml:space="preserve">
          <source>This configuration option can overridden with the command line flag `--tlscacert`, which would specify a path relative to the current working directory where the Notary client is invoked.</source>
          <target state="translated">这个配置选项可以用命令行标志`--tlscacert`覆盖,它将指定一个相对于当前工作目录的路径,在那里调用公证客户端。</target>
        </trans-unit>
        <trans-unit id="f3dac2903a9e3b3bcb2b9748cb607af7325f6ae4" translate="yes" xml:space="preserve">
          <source>This configuration option can overridden with the command line flag `--tlscert`, which would specify a path relative to the current working directory where the Notary client is invoked.</source>
          <target state="translated">这个配置选项可以用命令行标志&quot;--tlscert &quot;覆盖,它将指定一个相对于调用公证客户端的当前工作目录的路径。</target>
        </trans-unit>
        <trans-unit id="e323c3dfc61399ca682bdcd3c5130865f67656b5" translate="yes" xml:space="preserve">
          <source>This configuration option can overridden with the command line flag `--tlskey`, which would specify a path relative to the current working directory where the Notary client is invoked.</source>
          <target state="translated">这个配置选项可以用命令行标志&quot;--tlskey &quot;覆盖,它将指定一个相对于当前工作目录的路径,在那里调用公证客户端。</target>
        </trans-unit>
        <trans-unit id="709ff60d32f8c4d39b9a6e28d1237a9155af5e63" translate="yes" xml:space="preserve">
          <source>This creates a virtual machine running locally in VirtualBox which uses the &lt;code&gt;overlay&lt;/code&gt; storage backend, has the key-value pairs &lt;code&gt;foo=bar&lt;/code&gt; and &lt;code&gt;spam=eggs&lt;/code&gt; as labels on the engine, and allows pushing / pulling from the insecure registry located at &lt;code&gt;registry.myco.com&lt;/code&gt;. You can verify much of this by inspecting the output of &lt;code&gt;docker info&lt;/code&gt;:</source>
          <target state="translated">这将创建一个在VirtualBox中本地运行的虚拟机，该虚拟机使用 &lt;code&gt;overlay&lt;/code&gt; 存储后端，并在引擎上将键值对 &lt;code&gt;foo=bar&lt;/code&gt; 和 &lt;code&gt;spam=eggs&lt;/code&gt; 作为标签，并允许从位于 &lt;code&gt;registry.myco.com&lt;/code&gt; 不安全的注册表中推送/拉取。 com。您可以通过检查 &lt;code&gt;docker info&lt;/code&gt; 的输出来验证其中的大部分内容：</target>
        </trans-unit>
        <trans-unit id="41a11612feac37d243bc29270cc7b6836505ff66" translate="yes" xml:space="preserve">
          <source>This deploys all three services using the configuration in &lt;code&gt;docker-compose.yml&lt;/code&gt; and &lt;code&gt;docker-compose.prod.yml&lt;/code&gt; (but not the dev configuration in &lt;code&gt;docker-compose.override.yml&lt;/code&gt;).</source>
          <target state="translated">该部署使用配置中的所有三个服务 &lt;code&gt;docker-compose.yml&lt;/code&gt; 和 &lt;code&gt;docker-compose.prod.yml&lt;/code&gt; （而不是在开发配置 &lt;code&gt;docker-compose.override.yml&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="2ac8d354c9ba0ef9da4ef3101bd1948b3180a500" translate="yes" xml:space="preserve">
          <source>This diagram illustrates how placement preferences work:</source>
          <target state="translated">这张图说明了安置偏好的工作原理。</target>
        </trans-unit>
        <trans-unit id="d1bc61090cecad38ab7e1afe84b40d5a2df3de11" translate="yes" xml:space="preserve">
          <source>This disconnects the shell from &lt;code&gt;docker-machine&lt;/code&gt; created virtual machines, and allows you to continue working in the same shell, now using native &lt;code&gt;docker&lt;/code&gt; commands (for example, on Docker Desktop for Mac or Docker Desktop for Windows). To learn more, see the &lt;a href=&quot;../../machine/get-started/index#unset-environment-variables-in-the-current-shell&quot;&gt;Machine topic on unsetting environment variables&lt;/a&gt;.</source>
          <target state="translated">这会断开外壳与 &lt;code&gt;docker-machine&lt;/code&gt; 创建的虚拟机的连接，并允许您现在使用本地 &lt;code&gt;docker&lt;/code&gt; 命令（例如，在Mac的Docker Desktop或Windows的Docker Desktop上）在同一外壳中继续工作。要了解更多信息，请参阅&lt;a href=&quot;../../machine/get-started/index#unset-environment-variables-in-the-current-shell&quot;&gt;关于设置环境变量&lt;/a&gt;的Machine主题。</target>
        </trans-unit>
        <trans-unit id="9d2f8bae28c2c9e880782a4809b0b4ebefad7b1c" translate="yes" xml:space="preserve">
          <source>This document assumes familiarity with &lt;a href=&quot;https://www.theupdateframework.com/&quot;&gt;The Update Framework&lt;/a&gt;, but here is a brief recap of the TUF roles and corresponding key hierarchy:</source>
          <target state="translated">本文档假定您熟悉&lt;a href=&quot;https://www.theupdateframework.com/&quot;&gt;The Update Framework&lt;/a&gt;，但是这里是TUF角色和相应的密钥层次的简要概述：</target>
        </trans-unit>
        <trans-unit id="f3db2d513e02b85d3f9b2621224278858e2df00d" translate="yes" xml:space="preserve">
          <source>This document describes Docker Engine network driver plugins generally available in Docker Engine. To view information on plugins managed by Docker Engine, refer to &lt;a href=&quot;../index&quot;&gt;Docker Engine plugin system&lt;/a&gt;.</source>
          <target state="translated">本文档介绍了Docker Engine中通常可用的Docker Engine网络驱动程序插件。要查看有关由Docker Engine管理的插件的信息，请参阅&lt;a href=&quot;../index&quot;&gt;Docker Engine插件系统&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f6e7554c11c0d25f0bdedde0eaf7221ec3abe7f5" translate="yes" xml:space="preserve">
          <source>This document describes basic use of the Notary CLI as a tool supporting Docker Content Trust. For more advanced use cases, you must &lt;a href=&quot;../running_a_service/index&quot;&gt;run your own Notary service&lt;/a&gt;. Read the &lt;a href=&quot;../advanced_usage/index&quot;&gt;use the Notary client for advanced users&lt;/a&gt; documentation.</source>
          <target state="translated">本文档介绍了Notary CLI作为支持Docker Content Trust的工具的基本用法。对于更高级的用例，您必须&lt;a href=&quot;../running_a_service/index&quot;&gt;运行自己的公证服务&lt;/a&gt;。阅读&lt;a href=&quot;../advanced_usage/index&quot;&gt;使用Notary Client for Advanced Users&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="0fa42b8f27f63672e035019dbb27d49c75249850" translate="yes" xml:space="preserve">
          <source>This document describes the Docker Engine plugin API. To view information on plugins managed by Docker Engine, refer to &lt;a href=&quot;../index&quot;&gt;Docker Engine plugin system&lt;/a&gt;.</source>
          <target state="translated">本文档介绍了Docker Engine插件API。要查看有关由Docker Engine管理的插件的信息，请参阅&lt;a href=&quot;../index&quot;&gt;Docker Engine插件系统&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="92a5e71cde0d41862aadd7efb2569e87955944e7" translate="yes" xml:space="preserve">
          <source>This document describes the Docker Engine plugins generally available in Docker Engine. To view information on plugins managed by Docker Engine, refer to &lt;a href=&quot;../index&quot;&gt;Docker Engine plugin system&lt;/a&gt;.</source>
          <target state="translated">本文档介绍了Docker Engine中通常可用的Docker Engine插件。要查看有关由Docker Engine管理的插件的信息，请参阅&lt;a href=&quot;../index&quot;&gt;Docker Engine插件系统&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="977a9aa369ad0a7c94c5def3b85e5184449f8f22" translate="yes" xml:space="preserve">
          <source>This document describes the Docker Engine plugins generally available in Docker Engine. To view information on plugins managed by Docker, refer to &lt;a href=&quot;../index&quot;&gt;Docker Engine plugin system&lt;/a&gt;.</source>
          <target state="translated">本文档介绍了Docker Engine中通常可用的Docker Engine插件。要查看有关Docker管理的插件的信息，请参阅&lt;a href=&quot;../index&quot;&gt;Docker Engine插件系统&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3a6bfc98e4ea8d246879d5a991655ac15af82d7d" translate="yes" xml:space="preserve">
          <source>This document is for anyone who wants to run their own Notary service (such as those who want to use Notary with a private Docker registry). Running a Notary service requires that you are already familiar with using &lt;a href=&quot;https://docs.docker.com/config/daemon&quot;&gt;Docker Engine&lt;/a&gt; and &lt;a href=&quot;../../compose/index&quot;&gt;Docker Compose&lt;/a&gt;.</source>
          <target state="translated">本文档适用于任何想要运行自己的公证服务的人（例如那些想要将Notary与私有Docker注册表一起使用的人）。运行公证服务要求您已经熟悉&lt;a href=&quot;https://docs.docker.com/config/daemon&quot;&gt;Docker Engine&lt;/a&gt;和&lt;a href=&quot;../../compose/index&quot;&gt;Docker Compose的使用&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="667ba7c5086cd3f9086bb97fe691713d68d06fdf" translate="yes" xml:space="preserve">
          <source>This document is for power users of the &lt;a href=&quot;../../advanced_usage/index&quot;&gt;Notary client&lt;/a&gt; who want to facilitate CLI interaction or specify custom options.</source>
          <target state="translated">本文档适用于希望促进CLI交互或指定自定义选项的&lt;a href=&quot;../../advanced_usage/index&quot;&gt;Notary客户端的&lt;/a&gt;高级用户。</target>
        </trans-unit>
        <trans-unit id="d14334b6cf15bb6366cf71f20d5f69c1e4bdd6ea" translate="yes" xml:space="preserve">
          <source>This document is for power users of the &lt;a href=&quot;../advanced_usage/index&quot;&gt;notary client&lt;/a&gt;, or for those who are &lt;a href=&quot;../running_a_service/index&quot;&gt;running their own service&lt;/a&gt; who want to facilitate CLI interaction or specify custom options.</source>
          <target state="translated">本文档适用于&lt;a href=&quot;../advanced_usage/index&quot;&gt;公证客户端的&lt;/a&gt;高级用户，或正在&lt;a href=&quot;../running_a_service/index&quot;&gt;运行自己的服务&lt;/a&gt;以促进CLI交互或指定自定义选项的用户。</target>
        </trans-unit>
        <trans-unit id="336585c13b95433518135a03992347242015d28d" translate="yes" xml:space="preserve">
          <source>This document is for those who are &lt;a href=&quot;../../running_a_service/index&quot;&gt;running their own Notary service&lt;/a&gt; who want to specify custom options.</source>
          <target state="translated">本文档适用于那些&lt;a href=&quot;../../running_a_service/index&quot;&gt;运行自己的公证服务&lt;/a&gt;并希望指定自定义选项的用户。</target>
        </trans-unit>
        <trans-unit id="a3523a80f4fb22175f1197cab78624b412918813" translate="yes" xml:space="preserve">
          <source>This document outlines the format of the V0 plugin configuration. The plugin config described herein was introduced in the Docker daemon in the &lt;a href=&quot;https://github.com/docker/docker/commit/f37117045c5398fd3dca8016ea8ca0cb47e7312b&quot;&gt;v1.12.0 release&lt;/a&gt;.</source>
          <target state="translated">本文档概述了V0插件配置的格式。本文所述的插件配置已在&lt;a href=&quot;https://github.com/docker/docker/commit/f37117045c5398fd3dca8016ea8ca0cb47e7312b&quot;&gt;v1.12.0版本&lt;/a&gt;的Docker守护程序中引入。</target>
        </trans-unit>
        <trans-unit id="88801665323f52ce7e37ca0d98754639e1876f23" translate="yes" xml:space="preserve">
          <source>This document&amp;rsquo;s command examples omit the &lt;code&gt;-s&lt;/code&gt; and &lt;code&gt;-d&lt;/code&gt; flags. If you do not know what these options do, read the &lt;a href=&quot;../getting_started/index&quot;&gt;Getting Started&lt;/a&gt; docs or run &lt;code&gt;notary --help&lt;/code&gt; before continuing. Once you understand what these flags do, you must provide your own values for these options while following this document. You can also configure these options, see &lt;a href=&quot;../reference/index&quot;&gt;advanced configuration options&lt;/a&gt; for more information.</source>
          <target state="translated">本文档的命令示例省略了 &lt;code&gt;-s&lt;/code&gt; 和 &lt;code&gt;-d&lt;/code&gt; 标志。如果您不知道这些选项的作用，请先阅读《&lt;a href=&quot;../getting_started/index&quot;&gt;入门指南》&lt;/a&gt;文档或运行 &lt;code&gt;notary --help&lt;/code&gt; 。一旦了解了这些标志的作用，就必须在遵循本文档的同时为这些选项提供自己的值。您也可以配置这些选项，有关更多信息，请参见&lt;a href=&quot;../reference/index&quot;&gt;高级配置选项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9ca6ae0c176ba4178b4b3258f721cfed1ca466f8" translate="yes" xml:space="preserve">
          <source>This does not remove images from a registry. You cannot remove an image of a running container unless you use the &lt;code&gt;-f&lt;/code&gt; option. To see all images on a host use the &lt;a href=&quot;../images/index&quot;&gt;&lt;code&gt;docker image ls&lt;/code&gt;&lt;/a&gt; command.</source>
          <target state="translated">这不会从注册表中删除图像。除非使用 &lt;code&gt;-f&lt;/code&gt; 选项，否则无法删除正在运行的容器的映像。要查看主机上的所有映像，请使用&lt;a href=&quot;../images/index&quot;&gt; &lt;code&gt;docker image ls&lt;/code&gt; &lt;/a&gt;命令。</target>
        </trans-unit>
        <trans-unit id="29c95833fd291c916b66a22ef975e69524fe0812" translate="yes" xml:space="preserve">
          <source>This doesn&amp;rsquo;t affect regular web apps, but reduces the vectors of attack by malicious users considerably. By default Docker drops all capabilities except &lt;a href=&quot;https://github.com/moby/moby/blob/master/oci/defaults.go#L14-L30&quot;&gt;those needed&lt;/a&gt;, a whitelist instead of a blacklist approach. You can see a full list of available capabilities in &lt;a href=&quot;http://man7.org/linux/man-pages/man7/capabilities.7.html&quot;&gt;Linux manpages&lt;/a&gt;.</source>
          <target state="translated">这不会影响常规的Web应用程序，但会大大减少恶意用户的攻击媒介。默认情况下，Docker会丢弃所有&lt;a href=&quot;https://github.com/moby/moby/blob/master/oci/defaults.go#L14-L30&quot;&gt;需要的&lt;/a&gt;功能（白名单而非黑名单）。您可以在&lt;a href=&quot;http://man7.org/linux/man-pages/man7/capabilities.7.html&quot;&gt;Linux联机帮助页中&lt;/a&gt;看到可用功能的完整列表。</target>
        </trans-unit>
        <trans-unit id="a43a9520de487587d0fbcc7ec2262af5285678e1" translate="yes" xml:space="preserve">
          <source>This entire section is optional. However, if you would like authentication for your server, then you need the required parameters below to configure it.</source>
          <target state="translated">这整个部分是可选的。然而,如果你想为你的服务器进行身份验证,那么你需要下面的必要参数来配置它。</target>
        </trans-unit>
        <trans-unit id="3a433067a0a5e5fcc3e2fd416075fa3c8f721f5e" translate="yes" xml:space="preserve">
          <source>This entire section is optional. However, if you would like to specify a different log level, then you need the required parameters below to configure it.</source>
          <target state="translated">这整个部分是可选的。但是,如果你想指定不同的日志级别,那么你需要下面所需的参数来配置它。</target>
        </trans-unit>
        <trans-unit id="8ea48ec9b38860daa76dd08decddeba0cb452ba2" translate="yes" xml:space="preserve">
          <source>This entire section is optional. If you want to report errors to Bugsnag, then you need to include a &lt;code&gt;bugsnag&lt;/code&gt; subsection, along with the required parameters below, to configure it.</source>
          <target state="translated">这整个部分是可选的。如果要将错误报告给Bugsnag，则需要包括一个 &lt;code&gt;bugsnag&lt;/code&gt; 小节以及下面的必需参数来进行配置。</target>
        </trans-unit>
        <trans-unit id="2f77a7d533cc24ee410fe3e4b950ec5a19938c5e" translate="yes" xml:space="preserve">
          <source>This example assumes that you have PowerShell installed.</source>
          <target state="translated">这个例子假设你已经安装了PowerShell。</target>
        </trans-unit>
        <trans-unit id="579d25d3fa42da9cf3b7765d1ba3889e8d54df66" translate="yes" xml:space="preserve">
          <source>This example assumes the VPC ID was found in the &lt;code&gt;a&lt;/code&gt; availability zone. Use the&lt;code&gt;--amazonec2-zone&lt;/code&gt; flag to specify a zone other than the &lt;code&gt;a&lt;/code&gt; zone. For example, &lt;code&gt;--amazonec2-zone c&lt;/code&gt; signifies &lt;code&gt;us-east1-c&lt;/code&gt;.</source>
          <target state="translated">这个例子假设VPC ID是在发现 &lt;code&gt;a&lt;/code&gt; 可用性区域。使用 &lt;code&gt;--amazonec2-zone&lt;/code&gt; 标志来指定比其他区域 &lt;code&gt;a&lt;/code&gt; 区域。例如，-- &lt;code&gt;--amazonec2-zone c&lt;/code&gt; 表示 &lt;code&gt;us-east1-c&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c7dabe53e43b79614d8438010395bf2de91947e2" translate="yes" xml:space="preserve">
          <source>This example assumes you already have an ASP.NET Core app on your machine. If you are new to ASP.NET you can follow a &lt;a href=&quot;https://www.asp.net/get-started&quot;&gt;simple tutorial&lt;/a&gt; to initialize a project or clone our &lt;a href=&quot;https://github.com/dotnet/dotnet-docker/tree/master/samples/aspnetapp&quot;&gt;ASP.NET Docker Sample&lt;/a&gt;.</source>
          <target state="translated">本示例假定您的计算机上已经有一个ASP.NET Core应用程序。如果您不熟悉ASP.NET，则可以按照&lt;a href=&quot;https://www.asp.net/get-started&quot;&gt;简单的教程&lt;/a&gt;来初始化项目或克隆我们的&lt;a href=&quot;https://github.com/dotnet/dotnet-docker/tree/master/samples/aspnetapp&quot;&gt;ASP.NET Docker Sample&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b072eb53d731dbe872bf5499fc8375a6c9b49d0a" translate="yes" xml:space="preserve">
          <source>This example builds upon the previous one. In this scenario, you create a new secret with a new MySQL password, update the &lt;code&gt;mysql&lt;/code&gt; and &lt;code&gt;wordpress&lt;/code&gt; services to use it, then remove the old secret.</source>
          <target state="translated">这个例子建立在前一个例子的基础上。在这种情况下，您将使用新的MySQL密码创建一个新机密，更新 &lt;code&gt;mysql&lt;/code&gt; 和 &lt;code&gt;wordpress&lt;/code&gt; 服务以使用它，然后删除旧机密。</target>
        </trans-unit>
        <trans-unit id="634e957efa7945da265880d09e1c009341ec0d3f" translate="yes" xml:space="preserve">
          <source>This example creates a simple WordPress site using two secrets in a compose file.</source>
          <target state="translated">这个例子使用编译文件中的两个秘密创建了一个简单的WordPress网站。</target>
        </trans-unit>
        <trans-unit id="c0c1d508a75d41b428bb130225b60f1d0a96206d" translate="yes" xml:space="preserve">
          <source>This example demonstrates how to dockerize an ASP.NET Core application.</source>
          <target state="translated">这个例子演示了如何将ASP.NET Core应用程序docker化。</target>
        </trans-unit>
        <trans-unit id="cb3e7c67c57703593b3796456e5ef4778a541b6f" translate="yes" xml:space="preserve">
          <source>This example displays images with a name containing &amp;lsquo;busybox&amp;rsquo; and are automated builds:</source>
          <target state="translated">本示例显示名称包含&amp;ldquo; busybox&amp;rdquo;的图像，并且它们是自动构建的：</target>
        </trans-unit>
        <trans-unit id="d437f7cb185e6f0f539ce5261b7757395e2fb234" translate="yes" xml:space="preserve">
          <source>This example displays images with a name containing &amp;lsquo;busybox&amp;rsquo; and at least 3 stars:</source>
          <target state="translated">本示例显示名称包含&amp;ldquo; busybox&amp;rdquo;且至少三颗星的图像：</target>
        </trans-unit>
        <trans-unit id="089c84ed40f5a74f086ac6569d6bd88f3bdc3419" translate="yes" xml:space="preserve">
          <source>This example displays images with a name containing &amp;lsquo;busybox&amp;rsquo;, at least 3 stars and are official builds:</source>
          <target state="translated">本示例显示名称包含&amp;ldquo; busybox&amp;rdquo;，至少3星且为官方版本的图像：</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
