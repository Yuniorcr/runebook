<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="c">
    <body>
      <group id="c">
        <trans-unit id="37261588294ca7ee356026691cb04fa11731147e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;​0​&lt;/code&gt; if &lt;code&gt;ps&lt;/code&gt; is not a null pointer and does not represent the initial conversion state, nonzero value otherwise.</source>
          <target state="translated">&lt;code&gt;​0​&lt;/code&gt; 如果 &lt;code&gt;ps&lt;/code&gt; 的是不是一个空指针，并且不以其他方式表示的初始转换状态，非零值。</target>
        </trans-unit>
        <trans-unit id="bd5296046e4ff3776a2227cc99562246c76cdc42" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;​0​&lt;/code&gt; if all &lt;code&gt;count&lt;/code&gt; wide characters of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; are equal.</source>
          <target state="translated">&lt;code&gt;​0​&lt;/code&gt; 如果所有 &lt;code&gt;count&lt;/code&gt; 的宽字符 &lt;code&gt;lhs&lt;/code&gt; 和 &lt;code&gt;rhs&lt;/code&gt; 是相等的。</target>
        </trans-unit>
        <trans-unit id="ecb59e53e0ccb63dfdfbc44bcb505e617e783dc3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;​0​&lt;/code&gt; if all indicated exceptions were successfully cleared or if &lt;code&gt;excepts&lt;/code&gt; is zero. Returns a non-zero value on error.</source>
          <target state="translated">&lt;code&gt;​0​&lt;/code&gt; 如果所有指定的异常被成功清除，或者 &lt;code&gt;excepts&lt;/code&gt; 为零。返回错误时的非零值。</target>
        </trans-unit>
        <trans-unit id="0a914abe33320a923cd695193c20cc7bf085ab6d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;​0​&lt;/code&gt; if all listed exceptions were raised, non-zero value otherwise.</source>
          <target state="translated">&lt;code&gt;​0​&lt;/code&gt; 如果所有列出的异常曾引起，非零值，否则。</target>
        </trans-unit>
        <trans-unit id="ece37d70924447cb2e2181b2d01b748688ca04fd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;​0​&lt;/code&gt; if the character converted from &lt;code&gt;s&lt;/code&gt; (and stored in &lt;code&gt;*pc16&lt;/code&gt; if non-null) was the null character</source>
          <target state="translated">&lt;code&gt;​0​&lt;/code&gt; 如果从转换的字符 &lt;code&gt;s&lt;/code&gt; （并存储在 &lt;code&gt;*pc16&lt;/code&gt; 如果非空）为空字符</target>
        </trans-unit>
        <trans-unit id="5c7020d6c04aeffb6b059d1c341b3ba094b22d54" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;​0​&lt;/code&gt; if the character converted from &lt;code&gt;s&lt;/code&gt; (and stored in &lt;code&gt;*pc32&lt;/code&gt; if non-null) was the null character</source>
          <target state="translated">&lt;code&gt;​0​&lt;/code&gt; 如果从转换的字符 &lt;code&gt;s&lt;/code&gt; （并存储在 &lt;code&gt;*pc32&lt;/code&gt; 如果非空）为空字符</target>
        </trans-unit>
        <trans-unit id="47033aa3b25969c000aba5cf85e6545ef1dce198" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;​0​&lt;/code&gt; if the character converted from &lt;code&gt;s&lt;/code&gt; (and stored in &lt;code&gt;pwc&lt;/code&gt; if non-null) was the null character</source>
          <target state="translated">&lt;code&gt;​0​&lt;/code&gt; 如果从转换的字符 &lt;code&gt;s&lt;/code&gt; （并存储在 &lt;code&gt;pwc&lt;/code&gt; 如果非空）为空字符</target>
        </trans-unit>
        <trans-unit id="b4c8fb680806e009c8d40bf36b65357dea663124" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;​0​&lt;/code&gt; if the macro was called by the original code and the execution context was saved to &lt;code&gt;env&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;​0​&lt;/code&gt; 如果宏是由原始代码和执行上下文称为已保存到 &lt;code&gt;env&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="07392d7a4314d69c8bc79f069492147a5e87e91d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;​0​&lt;/code&gt; if the next &lt;code&gt;n&lt;/code&gt; or fewer bytes complete the null character or if &lt;code&gt;s&lt;/code&gt; is a null pointer. Both cases reset the conversion state.</source>
          <target state="translated">&lt;code&gt;​0​&lt;/code&gt; 如果下一个 &lt;code&gt;n&lt;/code&gt; 或更少的字节完成空字符，或者如果 &lt;code&gt;s&lt;/code&gt; 是空指针。两种情况都将重置转换状态。</target>
        </trans-unit>
        <trans-unit id="fb8fec550067ccb4777a2711c5e8cf6af313a5a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;​0​&lt;/code&gt; if the registration succeeds, nonzero value otherwise.</source>
          <target state="translated">&lt;code&gt;​0​&lt;/code&gt; 如果注册成功，非零值否则。</target>
        </trans-unit>
        <trans-unit id="7a17fc6e51794f5aed7876fde1e62d146f44ab53" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;​0​&lt;/code&gt; on success or nonzero on failure.</source>
          <target state="translated">&lt;code&gt;​0​&lt;/code&gt; 上失败成功还是非零。</target>
        </trans-unit>
        <trans-unit id="a594edc4f7ffdc549e885890ddf04b466f312762" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;​0​&lt;/code&gt; on success, &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;​0​&lt;/code&gt; 成功， &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; 否则。</target>
        </trans-unit>
        <trans-unit id="12b3574ac232ea1e748f9706cbe8074b413f87af" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;​0​&lt;/code&gt; on success, non-zero otherwise.</source>
          <target state="translated">&lt;code&gt;​0​&lt;/code&gt; 成功，否则返回非零值。</target>
        </trans-unit>
        <trans-unit id="f620f4915559aec9eae9385d12da2657eb94274a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;​0​&lt;/code&gt; on successful sleep, &lt;code&gt;-1&lt;/code&gt; if a signal occurred, other negative value if an error occurred.</source>
          <target state="translated">&lt;code&gt;​0​&lt;/code&gt; 上成功的睡眠， &lt;code&gt;-1&lt;/code&gt; 是否发生，其他负值的信号，如果出现了错误。</target>
        </trans-unit>
        <trans-unit id="087c0288e3e5dcd9422b80d2b28fc2c457be72ec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;​0​&lt;/code&gt; upon success or non-zero value on error.</source>
          <target state="translated">&lt;code&gt;​0​&lt;/code&gt; 在上错误成功或非零值。</target>
        </trans-unit>
        <trans-unit id="5d5882faeb3b6aa8692d1cecc132bbb371a9ca6b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;​0​&lt;/code&gt; upon success, non-zero value on failure.</source>
          <target state="translated">&lt;code&gt;​0​&lt;/code&gt; 在上失败的成功，非零值。</target>
        </trans-unit>
        <trans-unit id="50828e4f1a6516607804a376eecf2f160873f527" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;​0​&lt;/code&gt; upon success, nonzero value otherwise.</source>
          <target state="translated">&lt;code&gt;​0​&lt;/code&gt; 成功时，非零值否则。</target>
        </trans-unit>
        <trans-unit id="244fac49da12f30cab81e40b1dbe093b51717eea" translate="yes" xml:space="preserve">
          <source>&lt;small&gt;(See also &lt;a href=&quot;arithmetic_types&quot;&gt;arithmetic types&lt;/a&gt; for the details on most built-in types and &lt;a href=&quot;../types&quot;&gt; the list of type-related utilities&lt;/a&gt; that are provided by the C library)&lt;/small&gt;.</source>
          <target state="translated">&lt;small&gt;（有关大多数内置&lt;a href=&quot;arithmetic_types&quot;&gt;类型&lt;/a&gt;的详细信息以及C库提供&lt;a href=&quot;../types&quot;&gt;的与类型相关的实用程序的列表，&lt;/a&gt;另请参见算术类型）&lt;/small&gt;。</target>
        </trans-unit>
        <trans-unit id="d7a482458296985ff4f643e0ceb3ed670f5a2049" translate="yes" xml:space="preserve">
          <source>&lt;small&gt;(See also &lt;a href=&quot;compatible_type&quot;&gt;type&lt;/a&gt; for type system overview and &lt;a href=&quot;../types&quot;&gt; the list of type-related utilities&lt;/a&gt; that are provided by the C library)&lt;/small&gt;.</source>
          <target state="translated">&lt;small&gt;（有关类型系统概述，另请参见&lt;a href=&quot;compatible_type&quot;&gt;type&lt;/a&gt;以及C库提供&lt;a href=&quot;../types&quot;&gt;的与类型相关的实用程序的列表&lt;/a&gt;）&lt;/small&gt;。</target>
        </trans-unit>
        <trans-unit id="aad2e997d2d0a61a8a4b7bb9a6bb901008f0dd2f" translate="yes" xml:space="preserve">
          <source>&lt;small&gt;FE_DIVBYZERO, FE_INEXACT, FE_INVALID, FE_OVERFLOW, FE_UNDERFLOW, FE_ALL_EXCEPT&lt;/small&gt;</source>
          <target state="translated">&lt;small&gt;FE_DIVBYZERO，FE_INEXACT，FE_INVALID，FE_OVERFLOW，FE_UNDERFLOW，FE_ALL_EXCEPT&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="6ba38749c5e6b67dd9354f5c899f43f42a91d903" translate="yes" xml:space="preserve">
          <source>&lt;small&gt;FE_DOWNWARD, FE_TONEAREST, FE_TOWARDZERO, FE_UPWARD&lt;/small&gt;</source>
          <target state="translated">&lt;small&gt;FE_DOWNWARD，FE_TONEAREST，FE_TOWARDZERO，FE_UPWARD&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="1ee96709da677b917693b6fb5d00a73fb2ed0dce" translate="yes" xml:space="preserve">
          <source>&lt;small&gt;LC_ALL, LC_COLLATE, LC_CTYPE, LC_MONETARY, LC_NUMERIC, LC_TIME&lt;/small&gt;</source>
          <target state="translated">&lt;small&gt;LC_ALL，LC_COLLATE，LC_CTYPE，LC_MONETARY，LC_NUMERIC，LC_TIME&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="5ae52889b7d8f6d01e7e58d29b1ffaad898ad8fc" translate="yes" xml:space="preserve">
          <source>&lt;small&gt;N/A&lt;/small&gt;</source>
          <target state="translated">&lt;small&gt;N/A&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="10efdd3c2d7049538022820f79e0e37bd094fe06" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt; arithmetic&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; arithmetic&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e19ff83b6ec415b70737af40a6ed2c2d6b27413e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt; assignment&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; assignment&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5c375dfd990bd58d5c9dcb8640e80b7e6cea53f9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt; comparison&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; comparison&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ec766f8c27808b6ffc35e0a36b2b84225aa5a5e1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt; fputws&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; fputws&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="00c59ef536a9cebe544605a2173393bc418fbbcb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt; increment&lt;br/&gt;decrement&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; increment&lt;br/&gt;decrement&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="26a0d3cc3592706ee85cb536674e68e9cdde3e1d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt; logical&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; logical&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0dc3c883f0aa139e7be93514b09f8dc375a287f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt; member&lt;br/&gt;access&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; member&lt;br/&gt;access&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="46bf7c32b091bac31f177b6538a857bc4f99a593" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt; other&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; other&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="537b1d1edf82aeba0b417c8ba71838968c5a62b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;isalnum&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;isalnum&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9f9eb092cbcfe95bdcd0259dd8a630d5021ccbbe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;isalpha&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;isalpha&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f9ce04988731330541a991eb5e7d06dccb14ef08" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;isblank&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;isblank&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3a1eaa994d3269906b2a47c32a8e547fa6acd48b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;iscntrl&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;iscntrl&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c6c38fada3181e93f98fd6a5cc64d639bb008f4f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;isdigit&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;isdigit&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9ee2ff1dcd24794fdc2eeb658a043d3eddab9f4c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;isgraph&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;isgraph&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cc805695234d5269f3894979b9d4d5055e0e4e03" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;islower&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;islower&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7d368a53b3e50cbe2b60f751d23c615e71f69a2f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;isprint&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;isprint&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="edf5be6051afddc9d51019cf62964a443b980d31" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;ispunct&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;ispunct&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0dab79137a8c3f41f95cb2fdba1f4f613fc1cba2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;isspace&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;isspace&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2547b4f8a0a99767af9245458421d60678dfee26" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;isupper&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;isupper&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="92651ef970d99cc14c98cd615af602f9a84c504b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;iswalnum&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;iswalnum&lt;/code&gt;&lt;/strong&gt;.</target>
        </trans-unit>
        <trans-unit id="a9721c714438e2959a6b2dd93edc8f3f8d158f25" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;iswalpha&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;iswalpha&lt;/code&gt;&lt;/strong&gt;.</target>
        </trans-unit>
        <trans-unit id="63cf242f16b8eed04f50e80e12b7fe53c7b60e96" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;iswblank&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;iswblank&lt;/code&gt;&lt;/strong&gt;.</target>
        </trans-unit>
        <trans-unit id="ef1646ab343b83d122b0efbf0b1327ad179544ae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;iswcntrl&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;iswcntrl&lt;/code&gt;&lt;/strong&gt;.</target>
        </trans-unit>
        <trans-unit id="57132c82e4d7dd23822d5e2b00c1360c20c46cad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;iswdigit&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;iswdigit&lt;/code&gt;&lt;/strong&gt;.</target>
        </trans-unit>
        <trans-unit id="eaaeeeb6bf702b4f78258a052af4452dc2690218" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;iswgraph&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;iswgraph&lt;/code&gt;&lt;/strong&gt;.</target>
        </trans-unit>
        <trans-unit id="eef504bf43cd6c27be30cb125fbc497a56a78de2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;iswlower&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;iswlower&lt;/code&gt;&lt;/strong&gt;.</target>
        </trans-unit>
        <trans-unit id="de60e8e30084fb3e157dd6de773b4737e7169d88" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;iswprint&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;iswprint&lt;/code&gt;&lt;/strong&gt;.</target>
        </trans-unit>
        <trans-unit id="4615b2011e8d972dea535045f94bc13827ee65bc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;iswpunct&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;iswpunct&lt;/code&gt;&lt;/strong&gt;.</target>
        </trans-unit>
        <trans-unit id="c5fdebcc026d6a68db49f4b74165ce7f0d912453" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;iswspace&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;iswspace&lt;/code&gt;&lt;/strong&gt;.</target>
        </trans-unit>
        <trans-unit id="20e51610dd3a8beabcd2f164c21da31478eafe74" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;iswupper&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;iswupper&lt;/code&gt;&lt;/strong&gt;.</target>
        </trans-unit>
        <trans-unit id="375e0bd774ab74de342f79f6cb82415b12d14f35" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;iswxdigit&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;iswxdigit&lt;/code&gt;&lt;/strong&gt;.</target>
        </trans-unit>
        <trans-unit id="d84d8f51eeb0c0fa8768438cbf4a31a1157bc640" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;isxdigit&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;isxdigit&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="81c351228e8e2cb7718bc5af2c6012b6ddb15f26" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;-t2&lt;br/&gt;&lt;/sup&gt;d</source>
          <target state="translated">&lt;sup&gt;-t2&lt;br/&gt;&lt;/sup&gt;d</target>
        </trans-unit>
        <trans-unit id="06084185252914fb80c48390ac42871dd29d6c0a" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;-t&lt;/sup&gt; d</source>
          <target state="translated">&lt;sup&gt;-t&lt;/sup&gt; d</target>
        </trans-unit>
        <trans-unit id="ecb9d9cc5013291f759497f08cec925224751c83" translate="yes" xml:space="preserve">
          <source>=arg.</source>
          <target state="translated">=arg.</target>
        </trans-unit>
        <trans-unit id="6dcd4ce23d88e2ee9568ba546c007c63d9131c1b" translate="yes" xml:space="preserve">
          <source>A</source>
          <target state="translated">A</target>
        </trans-unit>
        <trans-unit id="2e3f231a0c0c357ef29a27a75e01c5f0f830c0dc" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt; of an object may provide its initial value through the process known as</source>
          <target state="translated">对象的&lt;a href=&quot;declarations&quot;&gt;声明&lt;/a&gt;可以通过以下过程提供其初始值：</target>
        </trans-unit>
        <trans-unit id="9f3a3af6eca5ee659c499270442d0bea16af329c" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;statements#Labels&quot;&gt;label (and only a label)&lt;/a&gt; declared inside a function is in scope everywhere in that function, in all nested blocks, before and after its own declaration. Note: a label is declared implicitly, by using an otherwise unused identifier before the colon character before any statement.</source>
          <target state="translated">一个&lt;a href=&quot;statements#Labels&quot;&gt;标签（只有一个标签）&lt;/a&gt;的函数内声明的范围是无处不在的功能，在所有嵌套块，之前和自己的声明之后。注意：通过在任何语句之前的冒号之前使用否则未使用的标识符，可以隐式声明标签。</target>
        </trans-unit>
        <trans-unit id="603d648e12123df5062789b6c9b530a246514f04" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;##&lt;/code&gt; operator between any two successive identifiers in the replacement-list runs parameter replacement on the two identifiers and then concatenates the result. This operation is called &quot;concatenation&quot; or &quot;token pasting&quot;. Only tokens that form a valid token together may be pasted: identifiers that form a longer identifier, digits that form a number, or operators &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;=&lt;/code&gt; that form a &lt;code&gt;+=&lt;/code&gt;. A comment cannot be created by pasting &lt;code&gt;/&lt;/code&gt; and &lt;code&gt;*&lt;/code&gt; because comments are removed from text before macro substitution is considered. If the result of concatenation is not a valid token, the behavior is undefined.</source>
          <target state="translated">替换列表中任意两个连续标识符之间的 &lt;code&gt;##&lt;/code&gt; 运算符对两个标识符运行参数替换，然后将结果串联起来。此操作称为&amp;ldquo;串联&amp;rdquo;或&amp;ldquo;令牌粘贴&amp;rdquo;。仅令牌形式有效令牌一起可以被粘贴：形成一个较长的标识符，数字构成的数，或运营商标识符 &lt;code&gt;+&lt;/code&gt; 和 &lt;code&gt;=&lt;/code&gt; 该形式的 &lt;code&gt;+=&lt;/code&gt; 。无法通过粘贴 &lt;code&gt;/&lt;/code&gt; 和 &lt;code&gt;*&lt;/code&gt; 创建评论，因为在考虑使用宏替换之前，已从文本中删除了评论。如果串联的结果不是有效的标记，则行为未定义。</target>
        </trans-unit>
        <trans-unit id="f47fde5c22af25ab0ffba150ed15a83e7199e428" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;do-while&lt;/code&gt; statement causes the statement (also called</source>
          <target state="translated">一个 &lt;code&gt;do-while&lt;/code&gt; 语句使语句（也称为</target>
        </trans-unit>
        <trans-unit id="3f288f6fc591d96442bb174583cfa9db05dbe91d" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;while&lt;/code&gt; statement causes the statement (also called</source>
          <target state="translated">一个 &lt;code&gt;while&lt;/code&gt; 语句导致语句（也称为</target>
        </trans-unit>
        <trans-unit id="b3f6ff76b0a886129453c93b5f0c76da0cfdd30b" translate="yes" xml:space="preserve">
          <source>A C program is a sequence of text files (typically header and source files) that contain &lt;a href=&quot;declarations&quot;&gt;declarations&lt;/a&gt;. They undergo &lt;a href=&quot;translation_phases&quot;&gt;translation&lt;/a&gt; to become an executable program, which is executed when the OS calls its &lt;a href=&quot;main_function&quot;&gt;main function&lt;/a&gt; (unless it is itself the OS or another</source>
          <target state="translated">AC程序是一系列包含&lt;a href=&quot;declarations&quot;&gt;声明&lt;/a&gt;的文本文件（通常是头文件和源文件）。它们经过&lt;a href=&quot;translation_phases&quot;&gt;翻译&lt;/a&gt;后变成可执行程序，当操作系统调用其&lt;a href=&quot;main_function&quot;&gt;主要功能&lt;/a&gt;时执行该程序（除非它本身是操作系统或其他操作系统）</target>
        </trans-unit>
        <trans-unit id="8feba51dfd70e75bb34dad80e127aae9226924af" translate="yes" xml:space="preserve">
          <source>A C++-style comment may appear within a C-style comment; this is a mechanism for excluding a small block of source code:</source>
          <target state="translated">一个C++风格的注释可以出现在一个C风格的注释中;这是一种排除小块源代码的机制。</target>
        </trans-unit>
        <trans-unit id="361abe056c46779921476d60896b385658ec3cd3" translate="yes" xml:space="preserve">
          <source>A C-style comment may appear within a C++-style comment:</source>
          <target state="translated">C-风格的注释可以出现在C++风格的注释中。</target>
        </trans-unit>
        <trans-unit id="c38d4f0fff6ac9b2c2295060922485f792b04682" translate="yes" xml:space="preserve">
          <source>A bit field declaration is a &lt;a href=&quot;struct&quot;&gt;struct&lt;/a&gt; or &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt; member declaration which uses the following &lt;a href=&quot;declarations&quot;&gt;declarator&lt;/a&gt;:</source>
          <target state="translated">位字段声明是使用以下&lt;a href=&quot;declarations&quot;&gt;声明&lt;/a&gt;&lt;a href=&quot;struct&quot;&gt;符的结构&lt;/a&gt;或&lt;a href=&quot;union&quot;&gt;联合&lt;/a&gt;成员声明：</target>
        </trans-unit>
        <trans-unit id="ecea6dbeee94545ded8e32b6cbfdc17fbe02cdaf" translate="yes" xml:space="preserve">
          <source>A block scope restrict-qualified pointer makes an aliasing assertion that is limited to its block. It allows local assertions that apply only to important blocks, such as tight loops. It also makes it possible to convert a function that takes restrict-qualified pointers into a macro:</source>
          <target state="translated">块作用域限制性限定指针做出的别名断言,仅限于其块。它允许只适用于重要块的局部断言,如紧缩循环。它还可以将一个采取限制性限定指针的函数转换为宏。</target>
        </trans-unit>
        <trans-unit id="e25a945c48cf6f76f2a11977d7e5d96d55161783" translate="yes" xml:space="preserve">
          <source>A break statement cannot be used to break out of multiple nested loops. The &lt;a href=&quot;goto&quot;&gt;goto statement&lt;/a&gt; may be used for this purpose.</source>
          <target state="translated">break语句不能用于打破多个嵌套循环。该&lt;a href=&quot;goto&quot;&gt;goto语句&lt;/a&gt;可以被用于此目的。</target>
        </trans-unit>
        <trans-unit id="a7a8603933603ca5102eeb32e317c1c1d5b2f58d" translate="yes" xml:space="preserve">
          <source>A call to &lt;code&gt;free&lt;/code&gt; that deallocates a region of memory</source>
          <target state="translated">要在通话 &lt;code&gt;free&lt;/code&gt; 这将释放的内存区域</target>
        </trans-unit>
        <trans-unit id="8c457728c5c90222ee97d0a5a9c7631536f84aa6" translate="yes" xml:space="preserve">
          <source>A call to &lt;code&gt;tss_create&lt;/code&gt; from within a thread-specific storage destructor results in undefined behavior.</source>
          <target state="translated">在特定于线程的存储析构函数中对 &lt;code&gt;tss_create&lt;/code&gt; 的调用导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="fcaf9a5650cbd2811245352e71e1d893dc23de9d" translate="yes" xml:space="preserve">
          <source>A cast of a non-volatile value to a volatile type has no effect. To access a non-volatile object using volatile semantics, its address must be cast to a pointer-to-volatile and then the access must be made through that pointer.</source>
          <target state="translated">将一个非易失性的值投向易失性类型是没有效果的。要使用volatile语义访问一个非易失性对象,必须将它的地址转为一个指向volatile的指针,然后通过该指针进行访问。</target>
        </trans-unit>
        <trans-unit id="266435bc7e1c5eddbff33669084fc6a3cc68bc0f" translate="yes" xml:space="preserve">
          <source>A collection of operators that do not fit into any of the other major categories.</source>
          <target state="translated">不符合任何其他主要类别的经营者的集合。</target>
        </trans-unit>
        <trans-unit id="a0e39b90a6cb653ffa38cbd92a158bb59c3fe2b6" translate="yes" xml:space="preserve">
          <source>A common error is setting the buffer of stdin or stdout to an array whose lifetime ends before the program terminates:</source>
          <target state="translated">一个常见的错误是将stdin或stdout的缓冲区设置为一个数组,该数组的寿命在程序终止前就结束了。</target>
        </trans-unit>
        <trans-unit id="043e96d2c063cdcc5eb90afe38b71a1e2aa56a23" translate="yes" xml:space="preserve">
          <source>A common implementation-defined form of main is &lt;code&gt;int main(int argc, char *argv[], char *envp[])&lt;/code&gt;, where a third argument, of type &lt;code&gt;char*[]&lt;/code&gt;, points at &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/exec.html&quot;&gt;an array of pointers to the host environment variables&lt;/a&gt;.</source>
          <target state="translated">的主要的共同实现定义形式是 &lt;code&gt;int main(int argc, char *argv[], char *envp[])&lt;/code&gt; ，其中，第三个参数的类型， &lt;code&gt;char*[]&lt;/code&gt; ，点&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/exec.html&quot;&gt;指针数组到主机环境变量&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="10427a39ea9b074032ff1694be3e266e2f8f4b5f" translate="yes" xml:space="preserve">
          <source>A common implementation-defined form of main is &lt;code&gt;int main(int argc, char *argv[], char *envp[])&lt;/code&gt;, where a third argument, of type &lt;code&gt;char*[]&lt;/code&gt;, points at &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/exec.html&quot;&gt;an array of pointers to the host environment variables&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfa9c8d2b42454344333fc69a8715babdf4fa1d7" translate="yes" xml:space="preserve">
          <source>A compiler that defines &lt;code&gt;__STDC_IEC_559_COMPLEX__&lt;/code&gt; is not required to support imaginary numbers. POSIX recommends checking if the macro &lt;code&gt;&lt;a href=&quot;imaginary_i&quot;&gt;_Imaginary_I&lt;/a&gt;&lt;/code&gt; is defined to identify imaginary number support.</source>
          <target state="translated">不需要定义 &lt;code&gt;__STDC_IEC_559_COMPLEX__&lt;/code&gt; 的编译器来支持虚数。POSIX建议检查是否已定义宏 &lt;code&gt;&lt;a href=&quot;imaginary_i&quot;&gt;_Imaginary_I&lt;/a&gt;&lt;/code&gt; 以标识虚数支持。</target>
        </trans-unit>
        <trans-unit id="081399ac6b5e4a28bc7390d1cdebdd865a0f239c" translate="yes" xml:space="preserve">
          <source>A compiler that defines &lt;code&gt;__STDC_IEC_559_COMPLEX__&lt;/code&gt; is not required to support imaginary numbers. POSIX recommends checking if the macro &lt;code&gt;_Imaginary_I&lt;/code&gt; is defined to identify imaginary number support.</source>
          <target state="translated">不需要定义 &lt;code&gt;__STDC_IEC_559_COMPLEX__&lt;/code&gt; 的编译器来支持虚数。POSIX建议检查是否已定义宏 &lt;code&gt;_Imaginary_I&lt;/code&gt; 以标识虚数支持。</target>
        </trans-unit>
        <trans-unit id="e7d53908cdda0d9e9b4f6a93e7e463f1fefd5fad" translate="yes" xml:space="preserve">
          <source>A compiler that defines &lt;code&gt;__STDC_IEC_559_COMPLEX__&lt;/code&gt; is recommended, but not required to support imaginary numbers. POSIX recommends checking if the macro &lt;code&gt;&lt;a href=&quot;../numeric/complex/imaginary_i&quot;&gt;_Imaginary_I&lt;/a&gt;&lt;/code&gt; is defined to identify imaginary number support.</source>
          <target state="translated">建议使用定义 &lt;code&gt;__STDC_IEC_559_COMPLEX__&lt;/code&gt; 的编译器，但不要求它支持虚数。POSIX建议检查是否已定义宏 &lt;code&gt;&lt;a href=&quot;../numeric/complex/imaginary_i&quot;&gt;_Imaginary_I&lt;/a&gt;&lt;/code&gt; 以标识虚数支持。</target>
        </trans-unit>
        <trans-unit id="4402e6f9ef027c378a2aa72fb2a92313d0d247bd" translate="yes" xml:space="preserve">
          <source>A compiler that defines &lt;code&gt;__STDC_IEC_559_COMPLEX__&lt;/code&gt; is recommended, but not required to support imaginary numbers. POSIX recommends checking if the macro &lt;code&gt;&lt;a href=&quot;complex/imaginary_i&quot;&gt;_Imaginary_I&lt;/a&gt;&lt;/code&gt; is defined to identify imaginary number support.</source>
          <target state="translated">建议使用定义 &lt;code&gt;__STDC_IEC_559_COMPLEX__&lt;/code&gt; 的编译器，但不要求它支持虚数。POSIX建议检查是否已定义宏 &lt;code&gt;&lt;a href=&quot;complex/imaginary_i&quot;&gt;_Imaginary_I&lt;/a&gt;&lt;/code&gt; 以标识虚数支持。</target>
        </trans-unit>
        <trans-unit id="ea77b12b7e2407a17d07af2cbebb15373a1a510a" translate="yes" xml:space="preserve">
          <source>A complex number composed of &lt;code&gt;real&lt;/code&gt; and &lt;code&gt;imag&lt;/code&gt; as the real and imaginary parts.</source>
          <target state="translated">构成的复数 &lt;code&gt;real&lt;/code&gt; 和 &lt;code&gt;imag&lt;/code&gt; 作为实部和虚部。</target>
        </trans-unit>
        <trans-unit id="e64cb23c6cd4a39b1bb7384aaf3e5f0fc40dfca2" translate="yes" xml:space="preserve">
          <source>A complex or imaginary number is a zero if both components are positive or negative zeroes.</source>
          <target state="translated">如果复数或虚数的两个分量都是正零或负零,就是一个零。</target>
        </trans-unit>
        <trans-unit id="dce1f09c28a8705473a0f7651c9a4b9f78234952" translate="yes" xml:space="preserve">
          <source>A complex or imaginary number is finite if both components are neither infinities nor NaNs.</source>
          <target state="translated">如果复数或虚数的两部分既不是无穷大,也不是NaNs,则复数或虚数是有限的。</target>
        </trans-unit>
        <trans-unit id="652b9c238709c7d35d2b6d1f52d70d79d08c5684" translate="yes" xml:space="preserve">
          <source>A complex or imaginary number is infinite if one of its components is infinite, even if the other component is NaN.</source>
          <target state="translated">一个复数或虚数如果其中一个分量是无限的,即使另一个分量是NaN,也是无限的。</target>
        </trans-unit>
        <trans-unit id="dfd35d143007cd2afa97becb2a970fcb61fba85f" translate="yes" xml:space="preserve">
          <source>A composite type can be constructed from two types that are compatible; it is a type that is compatible with both of the two types and satisfies the following conditions:</source>
          <target state="translated">一个复合类型可以由两个兼容的类型构造而成,它是一个与两个类型都兼容的类型,并且满足以下条件。</target>
        </trans-unit>
        <trans-unit id="7840d5c37ff1db5e5e182c7d433c55ae950c092a" translate="yes" xml:space="preserve">
          <source>A compound statement, or</source>
          <target state="translated">复合声明,或</target>
        </trans-unit>
        <trans-unit id="fd3c6deaad4f149d8821441e3aeb7cf41936bcd5" translate="yes" xml:space="preserve">
          <source>A copy of the returned string along with the category used in this call to &lt;code&gt;setlocale&lt;/code&gt; may be used later in the program to restore the locale back to the state at the end of this call.</source>
          <target state="translated">返回的字符串的副本以及此调用 &lt;code&gt;setlocale&lt;/code&gt; 中使用的类别，可以稍后在程序中使用，以将语言环境恢复到此调用结束时的状态。</target>
        </trans-unit>
        <trans-unit id="80b81ef2621bd9443a4bf04efe123ee3d6ed6faf" translate="yes" xml:space="preserve">
          <source>A declaration cannot introduce an identifier if another declaration for the same identifier in the same &lt;a href=&quot;scope&quot;&gt;scope&lt;/a&gt; appears earlier, except that.</source>
          <target state="translated">如果之前在同一&lt;a href=&quot;scope&quot;&gt;范围内&lt;/a&gt;出现了同一标识符的另一个声明，则声明不能引入标识符。</target>
        </trans-unit>
        <trans-unit id="3c1639813cef172042dde9fb318ca556d46fc2fb" translate="yes" xml:space="preserve">
          <source>A declaration of the following form.</source>
          <target state="translated">以下形式的声明:</target>
        </trans-unit>
        <trans-unit id="a960e4e1d8427b6d3fda100fb6c241d0a214d14b" translate="yes" xml:space="preserve">
          <source>A designator causes the following initializer to initialize of the array element described by the designator. Initialization then continues forward in order, beginning with the next element after the one described by the designator.</source>
          <target state="translated">一个代号会使下面的初始化器对代号所描述的数组元素进行初始化。然后按顺序继续向前初始化,从代号所描述的元素之后的下一个元素开始。</target>
        </trans-unit>
        <trans-unit id="4da5ccc11d8af999bc9357c8da2a60aea20aab2d" translate="yes" xml:space="preserve">
          <source>A designator causes the following initializer to initialize the struct member described by the designator. Initialization then continues forward in order of declaration, beginning with the next element declared after the one described by the designator.</source>
          <target state="translated">一个代号会使下面的初始化器初始化该代号所描述的结构成员。然后按照声明的顺序继续向前初始化,从指定符所描述的结构成员之后声明的下一个元素开始。</target>
        </trans-unit>
        <trans-unit id="089c028655f5931200be1bc3ff6ad58ddd4abdfd" translate="yes" xml:space="preserve">
          <source>A domain error or range error may occur if &lt;code&gt;arg&lt;/code&gt; is zero, infinite, or NaN.</source>
          <target state="translated">如果 &lt;code&gt;arg&lt;/code&gt; 为零，无穷大或NaN，则可能会发生域错误或范围错误。</target>
        </trans-unit>
        <trans-unit id="0004144516b9e50c31b57af7a9296890e6e2c03c" translate="yes" xml:space="preserve">
          <source>A file-scope restrict-qualified pointer has to point into a single array object for the duration of the program. That array object may not be referenced both through the restricted pointer and through either its declared name (if it has one) or another restricted pointer.</source>
          <target state="translated">一个文件范围的限制性指针在程序的持续时间内必须指向一个单一的数组对象,这个数组对象既不能通过限制性指针,也不能通过其声明的名称(如果有的话)或另一个限制性指针来引用。这个数组对象既不能通过限制性指针引用,也不能通过它的声明名称(如果有的话)或另一个限制性指针引用。</target>
        </trans-unit>
        <trans-unit id="976825cd6143668bd0fe398a656fa05a307069b2" translate="yes" xml:space="preserve">
          <source>A finite value of any real floating type can be implicitly converted to any integer type. Except where covered by boolean conversion above, the rules are:</source>
          <target state="translated">任何实数浮动类型的有限值都可以隐式转换为任何整数类型。除了上面布尔转换所涉及的地方,规则是:</target>
        </trans-unit>
        <trans-unit id="0ed079bc5d103eb53c8e9924fed905c90fdd8aab" translate="yes" xml:space="preserve">
          <source>A floating constant is a &lt;a href=&quot;value_category&quot;&gt;non-lvalue&lt;/a&gt; expression having the form:</source>
          <target state="translated">浮点常量是具有以下形式的&lt;a href=&quot;value_category&quot;&gt;非左值&lt;/a&gt;表达式：</target>
        </trans-unit>
        <trans-unit id="377954a1c6c62bc023f38ea913ffa855f5cdcee9" translate="yes" xml:space="preserve">
          <source>A function call expression where expression consists entirely of an identifier and that identifier is undeclared acts as though the identifier is declared as.</source>
          <target state="translated">一个函数调用表达式,如果表达式完全由一个标识符组成,并且该标识符未被声明,则该标识符的行为就像被声明为。</target>
        </trans-unit>
        <trans-unit id="602a406df52d4cd1f2b9ef189b37d9f3edc65dbd" translate="yes" xml:space="preserve">
          <source>A function declaration introduces an &lt;a href=&quot;identifier&quot;&gt;identifier&lt;/a&gt; that designates a function and, optionally, specifies the types of the function parameters (the</source>
          <target state="translated">函数声明引入了一个&lt;a href=&quot;identifier&quot;&gt;标识符&lt;/a&gt;，该标识符指定一个函数，并可选地指定函数参数的类型（</target>
        </trans-unit>
        <trans-unit id="ec213a1d70975b73f03ef6fb6555f8cf9ab8d93a" translate="yes" xml:space="preserve">
          <source>A function definition associates the function body (a sequence of declarations and statements) with the function name and parameter list. Unlike &lt;a href=&quot;function_declaration&quot;&gt;function declaration&lt;/a&gt;, function definitions are allowed at file scope only (there are no nested functions).</source>
          <target state="translated">函数定义将函数主体（声明和声明的序列）与函数名称和参数列表相关联。与&lt;a href=&quot;function_declaration&quot;&gt;函数声明&lt;/a&gt;不同，函数定义仅在文件范围内被允许（没有嵌套函数）。</target>
        </trans-unit>
        <trans-unit id="3703acc891d3a7d6dbd5125eb673a5d5f0dab4f4" translate="yes" xml:space="preserve">
          <source>A function designator (the identifier introduced by a &lt;a href=&quot;function_declaration&quot;&gt;function declaration&lt;/a&gt;) is an expression of function type. When used in any context other than the address-of operator, &lt;a href=&quot;sizeof&quot;&gt;sizeof&lt;/a&gt;, and &lt;a href=&quot;alignof&quot;&gt;_Alignof&lt;/a&gt; (the last two generate compile errors when applied to functions), the function designator is always converted to a non-lvalue pointer to function. Note that the function-call operator is defined for pointers to functions and not for function designators themselves.</source>
          <target state="translated">函数标志符（&lt;a href=&quot;function_declaration&quot;&gt;函数声明&lt;/a&gt;引入的标识符）是函数类型的表达式。当在除address-of运算符，&lt;a href=&quot;sizeof&quot;&gt;sizeof&lt;/a&gt;和&lt;a href=&quot;alignof&quot;&gt;_Alignof&lt;/a&gt;之外的任何上下文中使用时（当将最后两个应用于函数时，它们会产生编译错误），函数指示符始终会转换为函数的非左值指针。注意，函数调用操作符是为函数的指针而不是函数指示符本身定义的。</target>
        </trans-unit>
        <trans-unit id="2865a2d6eb5df117f629cdfeaf9bd05dfbbfb70e" translate="yes" xml:space="preserve">
          <source>A function is a C language construct that associates a &lt;a href=&quot;statements#Compound_statements&quot;&gt;compound statement&lt;/a&gt; (the function body) with an &lt;a href=&quot;identifier&quot;&gt;identifier&lt;/a&gt; (the function name). Every C program begins execution from the &lt;a href=&quot;main_function&quot;&gt;main function&lt;/a&gt;, which either terminates, or invokes other, user-defined or library functions.</source>
          <target state="translated">函数是将&lt;a href=&quot;statements#Compound_statements&quot;&gt;复合语句&lt;/a&gt;（函数主体）与&lt;a href=&quot;identifier&quot;&gt;标识符&lt;/a&gt;（函数名称）相关联的C语言构造。每个C程序都从&lt;a href=&quot;main_function&quot;&gt;main函数&lt;/a&gt;开始执行，main函数可以终止或调用其他用户定义的函数或库函数。</target>
        </trans-unit>
        <trans-unit id="8751c52383848fc3922df72d6d9844aebc4d6beb" translate="yes" xml:space="preserve">
          <source>A label is an identifier followed by a colon (:) and a statement. Labels are the only identifiers that have</source>
          <target state="translated">标签是一个标识符,后面跟着一个冒号(:)和一个语句。标签是唯一具有</target>
        </trans-unit>
        <trans-unit id="970388d0171fba77b4f60c1b13ea5429bb78c066" translate="yes" xml:space="preserve">
          <source>A load operation with this memory order performs a</source>
          <target state="translated">对这个内存顺序的加载操作会执行一个</target>
        </trans-unit>
        <trans-unit id="04adb94f807f9fc41a4b16df95c597991972fc35" translate="yes" xml:space="preserve">
          <source>A load operation with this memory order performs an</source>
          <target state="translated">使用该内存顺序的加载操作会执行一个</target>
        </trans-unit>
        <trans-unit id="3b21ef2a1cadb419bb1ba1c86579963e83c28347" translate="yes" xml:space="preserve">
          <source>A load operation with this memory order performs the</source>
          <target state="translated">用这个内存顺序进行加载操作,会执行</target>
        </trans-unit>
        <trans-unit id="1abbd3840931ab83b239511b97b8e829d4c22039" translate="yes" xml:space="preserve">
          <source>A member of a const-qualified structure or union type acquires the qualification of the type it belongs to (both when accessed using the &lt;code&gt;.&lt;/code&gt; operator or the &lt;code&gt;-&amp;gt;&lt;/code&gt; operator).</source>
          <target state="translated">const限定结构或并集类型的成员将获取其所属类型的限定符（均使用 &lt;code&gt;.&lt;/code&gt; 运算符或 &lt;code&gt;-&amp;gt;&lt;/code&gt; 运算符访问）。</target>
        </trans-unit>
        <trans-unit id="264b98c249a9fc7f51bdfe1129cff98f9c148f21" translate="yes" xml:space="preserve">
          <source>A member of a volatile-qualified structure or union type acquires the qualification of the type it belongs to (both when accessed using the &lt;code&gt;.&lt;/code&gt; operator or the &lt;code&gt;-&amp;gt;&lt;/code&gt; operator):</source>
          <target state="translated">volatile限定结构或联合类型的成员将获得其所属类型的限定（均使用 &lt;code&gt;.&lt;/code&gt; 运算符或 &lt;code&gt;-&amp;gt;&lt;/code&gt; 运算符访问）：</target>
        </trans-unit>
        <trans-unit id="01857fa2944d04e325044693ba2bf63f5a8cbfe2" translate="yes" xml:space="preserve">
          <source>A multibyte character string is layout-compatible with &lt;a href=&quot;byte&quot;&gt;null-terminated byte string&lt;/a&gt; (NTBS), that is, can be stored, copied, and examined using the same facilities, except for calculating the number of characters. If the correct locale is in effect, I/O functions also handle multibyte strings. Multibyte strings can be converted to and from wide strings using the following locale-dependent conversion functions:</source>
          <target state="translated">多字节字符串在布局上与&lt;a href=&quot;byte&quot;&gt;空终止字节字符串&lt;/a&gt;（NTBS）兼容，也就是说，除了计算字符数外，还可以使用相同的功能进行存储，复制和检查。如果正确的语言环境生效，则I / O函数还将处理多字节字符串。使用以下依赖于语言环境的转换函数，可以将多字节字符串与宽字符串进行来回转换：</target>
        </trans-unit>
        <trans-unit id="c2f7608097bdd67a3d19cac0cace329c7258c084" translate="yes" xml:space="preserve">
          <source>A negative value of &lt;code&gt;time-&amp;gt;tm_isdst&lt;/code&gt; causes &lt;code&gt;mktime&lt;/code&gt; to attempt to determine if Daylight Saving Time was in effect in the specified time.</source>
          <target state="translated">的负值 &lt;code&gt;time-&amp;gt;tm_isdst&lt;/code&gt; 使 &lt;code&gt;mktime&lt;/code&gt; 试图确定是否夏令时是在规定的时间的效果。</target>
        </trans-unit>
        <trans-unit id="d9811e282e7ba765c54d3daa670df15207f42b43" translate="yes" xml:space="preserve">
          <source>A newly opened stream has no orientation. The first call to &lt;code&gt;fwide&lt;/code&gt; or to any I/O function establishes the orientation: a wide I/O function makes the stream wide-oriented, a narrow I/O function makes the stream narrow-oriented. Once set, the orientation can only be changed with &lt;code&gt;&lt;a href=&quot;io/freopen&quot;&gt;freopen&lt;/a&gt;&lt;/code&gt;. Narrow I/O functions cannot be called on a wide-oriented stream; wide I/O functions cannot be called on a narrow-oriented stream. Wide I/O functions convert between wide and multibyte characters as if by calling &lt;code&gt;&lt;a href=&quot;string/multibyte/mbrtowc&quot;&gt;mbrtowc&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;string/multibyte/wcrtomb&quot;&gt;wcrtomb&lt;/a&gt;&lt;/code&gt;. Unlike the multibyte character strings that are valid in a program, multibyte character sequences in the file may contain embedded nulls and do not have to begin or end in the initial shift state.</source>
          <target state="translated">新打开的流没有方向。对 &lt;code&gt;fwide&lt;/code&gt; 或对任何I / O函数的第一个调用确定了方向：宽I / O功能使流面向宽，窄I / O功能使流面向窄。设置后，只能使用 &lt;code&gt;&lt;a href=&quot;io/freopen&quot;&gt;freopen&lt;/a&gt;&lt;/code&gt; 更改方向。窄I / O功能不能在面向广泛的流上调用；不能在狭窄的流上调用广泛的I / O功能。宽I / O功能就像在调用 &lt;code&gt;&lt;a href=&quot;string/multibyte/mbrtowc&quot;&gt;mbrtowc&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;string/multibyte/wcrtomb&quot;&gt;wcrtomb&lt;/a&gt;&lt;/code&gt; 一样，在宽和多字节字符之间进行转换。与程序中有效的多字节字符串不同，文件中的多字节字符串可以包含嵌入的null，而不必在初始移位状态下开始或结束。</target>
        </trans-unit>
        <trans-unit id="f93966d91f05c405ffd7170387e12fc185074d8c" translate="yes" xml:space="preserve">
          <source>A non-static inline function cannot define a non-const function-local static and cannot refer to a file-scope static.</source>
          <target state="translated">一个非静态内联函数不能定义一个非const函数的局部静态,也不能引用一个文件范围的静态。</target>
        </trans-unit>
        <trans-unit id="98bb6fdcc52028ba6a8a94a78329f5f014ffb21e" translate="yes" xml:space="preserve">
          <source>A null pointer constant may be &lt;a href=&quot;../language/conversion#Pointer_conversions&quot;&gt;converted&lt;/a&gt; to any pointer type; such conversion results in the null pointer value of that type.</source>
          <target state="translated">空指针常量可以&lt;a href=&quot;../language/conversion#Pointer_conversions&quot;&gt;转换&lt;/a&gt;为任何指针类型。这样的转换将导致该类型的空指针值。</target>
        </trans-unit>
        <trans-unit id="406f28c4d8ce54f26f886b6cecc24c77951f4ac6" translate="yes" xml:space="preserve">
          <source>A null-terminated byte string (NTBS) is a sequence of nonzero bytes followed by a byte with value zero (the terminating null character). Each byte in a byte string encodes one character of some character set. For example, the character array &lt;code&gt;{'\x63','\x61','\x74','\0'&lt;/code&gt;} is an NTBS holding the string &lt;code&gt;&quot;cat&quot;&lt;/code&gt; in ASCII encoding.</source>
          <target state="translated">空终止的字节字符串（NTBS）是一个非零字节序列，后跟一个值为零的字节（终止的空字符）。字节字符串中的每个字节编码某个字符集的一个字符。例如，字符数组 &lt;code&gt;{'\x63','\x61','\x74','\0'&lt;/code&gt; }是一个NTBS，它以ASCII编码保存字符串 &lt;code&gt;&quot;cat&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3b3fe15454343ce4cbfa8b2d64edd72623154c83" translate="yes" xml:space="preserve">
          <source>A null-terminated multibyte string (NTMBS), or &quot;multibyte string&quot;, is a sequence of nonzero bytes followed by a byte with value zero (the terminating null character).</source>
          <target state="translated">空尾多字节字符串(NTMBS),或 &quot;多字节字符串&quot;,是一个非零字节的序列,后面是一个值为零的字节(终止的空字符)。</target>
        </trans-unit>
        <trans-unit id="0ff0edea7748873d38d10264d61ada446ff85e77" translate="yes" xml:space="preserve">
          <source>A null-terminated wide string is a sequence of valid wide characters, ending with a null-character.</source>
          <target state="translated">空尾宽字符串是指以空字符结束的有效宽字符序列。</target>
        </trans-unit>
        <trans-unit id="cd957d3196cf2aa0f452a3d6985d383e4ba9d369" translate="yes" xml:space="preserve">
          <source>A pointer to &lt;code&gt;void&lt;/code&gt; can be implicitly converted to and from any pointer to object type with the following semantics:</source>
          <target state="translated">可以使用以下语义将指向 &lt;code&gt;void&lt;/code&gt; 的指针隐式转换为对象类型的任何指针：</target>
        </trans-unit>
        <trans-unit id="de2d527f4dc091dd493b9a8f9868ef42f64eef36" translate="yes" xml:space="preserve">
          <source>A pointer to a non-volatile type can be implicitly converted to a pointer to the volatile-qualified version of the same or &lt;a href=&quot;compatible_type&quot;&gt;compatible type&lt;/a&gt;. The reverse conversion can be performed with a cast expression.</source>
          <target state="translated">指向非易失性类型的指针可以隐式转换为指向相同或&lt;a href=&quot;compatible_type&quot;&gt;兼容类型&lt;/a&gt;的volatile限定版本的指针。可以使用强制转换表达式执行反向转换。</target>
        </trans-unit>
        <trans-unit id="8c1876354dd24b2af7bddabb8049a8d468d3ce0c" translate="yes" xml:space="preserve">
          <source>A pointer to a union can be cast to a pointer to each of its members (if a union has bit field members, the pointer to a union can be cast to the pointer to the bit field's underlying type). Likewise, a pointer to any member of a union can be cast to a pointer to the enclosing union.</source>
          <target state="translated">一个联合体的指针可以投向它的每一个成员的指针(如果一个联合体有位字段成员,那么投向联合体的指针可以投向位字段底层类型的指针)。同样,指向一个联合体的任何成员的指针也可以投向一个指向包围联合体的指针。</target>
        </trans-unit>
        <trans-unit id="268a4e779dda486b15b5e5f3b72d38b0d1eaba3e" translate="yes" xml:space="preserve">
          <source>A pointer to an non-const type can be implicitly converted to a pointer to const-qualified version of the same or &lt;a href=&quot;compatible_type&quot;&gt;compatible type&lt;/a&gt;. The reverse conversion can be performed with a cast expression.</source>
          <target state="translated">指向非const类型的指针可以隐式转换为指向相同或&lt;a href=&quot;compatible_type&quot;&gt;兼容类型的&lt;/a&gt; const限定版本的指针。可以使用强制转换表达式执行反向转换。</target>
        </trans-unit>
        <trans-unit id="82585af59f0bb594a7902f0e32b95152542a8077" translate="yes" xml:space="preserve">
          <source>A pointer to an object (or one past the object) whose lifetime ended has indeterminate value.</source>
          <target state="translated">一个指向寿命结束的对象(或过去的对象)的指针具有不确定的价值。</target>
        </trans-unit>
        <trans-unit id="bf50860af56aa1252b085a89c9df0b2ec34aa52c" translate="yes" xml:space="preserve">
          <source>A pointer to an unqualified type may be implicitly converted to the pointer to qualified version of that type (in other words, &lt;a href=&quot;const&quot;&gt;const&lt;/a&gt;, &lt;a href=&quot;volatile&quot;&gt;volatile&lt;/a&gt;, and &lt;a href=&quot;restrict&quot;&gt;restrict&lt;/a&gt; qualifiers can be added. The original pointer and the result compare equal.</source>
          <target state="translated">指向非限定类型的指针可以隐式转换为该类型的限定版本的指针（换句话说，可以添加&lt;a href=&quot;const&quot;&gt;const&lt;/a&gt;，&lt;a href=&quot;volatile&quot;&gt;volatile&lt;/a&gt;和&lt;a href=&quot;restrict&quot;&gt;strict&lt;/a&gt;限定符。原始指针和结果比较相等。</target>
        </trans-unit>
        <trans-unit id="a75bb699e6da13526f0dc68a72d5b021bc5756cb" translate="yes" xml:space="preserve">
          <source>A pointer to function can be initialized with an address of a function. Because of the &lt;a href=&quot;conversion&quot;&gt;function-to-pointer&lt;/a&gt; conversion, the address-of operator is optional:</source>
          <target state="translated">可以使用函数的地址来初始化指向函数的指针。由于&lt;a href=&quot;conversion&quot;&gt;函数到指针的&lt;/a&gt;转换，address-of运算符是可选的：</target>
        </trans-unit>
        <trans-unit id="9a672c3a635d605d46cb900dc367b14fe6337810" translate="yes" xml:space="preserve">
          <source>A pointer to function can be used on the left-hand side of the &lt;a href=&quot;operator_other#Function_call&quot;&gt;function call operator&lt;/a&gt;; this invokes the pointed-to function:</source>
          <target state="translated">可以在&lt;a href=&quot;operator_other#Function_call&quot;&gt;函数调用操作符&lt;/a&gt;的左侧使用指向函数的指针。这将调用指向的函数：</target>
        </trans-unit>
        <trans-unit id="bbc12ed44a0708299938681bbc78649632564ce2" translate="yes" xml:space="preserve">
          <source>A pointer to object can be initialized with the result of the &lt;a href=&quot;operator_member_access&quot;&gt;address-of operator&lt;/a&gt; applied to an expression of object type (which may be incomplete):</source>
          <target state="translated">可以使用应用于对象类型表达式（可能不完整）的&lt;a href=&quot;operator_member_access&quot;&gt;address-of运算符&lt;/a&gt;的结果来初始化指向对象的指针：</target>
        </trans-unit>
        <trans-unit id="e75b4fd545bf145657eb8864911b4552c5e00b3f" translate="yes" xml:space="preserve">
          <source>A pointer to the previously-installed runtime constraints handler. (note: this pointer is never a null pointer because calling &lt;code&gt;set_constraint_handler_s(&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;)&lt;/code&gt; sets up the system default handler).</source>
          <target state="translated">指向先前安装的运行时约束处理程序的指针。（注意：此指针绝不能为空指针，因为调用 &lt;code&gt;set_constraint_handler_s(&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;)&lt;/code&gt; 会设置系统默认处理程序）。</target>
        </trans-unit>
        <trans-unit id="1e0960972641b3c0a03c6a7b75123a8d844b3797" translate="yes" xml:space="preserve">
          <source>A pointer to this function can be passed to &lt;a href=&quot;set_constraint_handler_s&quot;&gt;set_constraint_handler_s&lt;/a&gt; to establish a runtime constraints violation handler that does nothing.  As with all bounds-checked functions, &lt;code&gt;ignore_handler_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant &lt;code&gt;1&lt;/code&gt; before including &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">可以将此函数的指针传递给&lt;a href=&quot;set_constraint_handler_s&quot;&gt;set_constraint_handler_s，&lt;/a&gt;以建立不执行任何操作的运行时约束违反处理程序。如同所有的边界检查功能， &lt;code&gt;ignore_handler_s&lt;/code&gt; 只保证是如果可用 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 被实现，并且如果所述用户定义定义 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 为整数常数 &lt;code&gt;1&lt;/code&gt; 包括前 &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="93cf80347c7d11084a2a6667157a9584d0768c8f" translate="yes" xml:space="preserve">
          <source>A pointer to this function can be passed to &lt;a href=&quot;set_constraint_handler_s&quot;&gt;set_constraint_handler_s&lt;/a&gt; to establish a runtime constraints violation handler.  As with all bounds-checked functions, &lt;code&gt;abort_handler_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant &lt;code&gt;1&lt;/code&gt; before including &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">可以将此函数的指针传递给&lt;a href=&quot;set_constraint_handler_s&quot;&gt;set_constraint_handler_s，&lt;/a&gt;以建立运行时约束违反处理程序。如同所有的边界检查功能， &lt;code&gt;abort_handler_s&lt;/code&gt; 只保证是如果可用 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 被实现，并且如果所述用户定义定义 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 为整数常数 &lt;code&gt;1&lt;/code&gt; 包括前 &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="dc6f29c561783d3fd50e7713005eb570a71543db" translate="yes" xml:space="preserve">
          <source>A post-C11 defect report DR 427 changes the semantics of preparing function parameters when calling a function with a prototype from assignment to initialization from their corresponding arguments, in order to allow parameters of const-qualified type (which are</source>
          <target state="translated">C11后的缺陷报告DR 427改变了在调用具有原型的函数时准备函数参数的语义,从其对应的参数从赋值到初始化,以便允许const-限定类型的参数(这些参数为</target>
        </trans-unit>
        <trans-unit id="306aa42e0fc0f9009433757fb90b670651e295cb" translate="yes" xml:space="preserve">
          <source>A previous call to &lt;code&gt;&lt;a href=&quot;free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt; that deallocates a region of memory</source>
          <target state="translated">先前对 &lt;code&gt;&lt;a href=&quot;free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt; 的调用会释放内存区域</target>
        </trans-unit>
        <trans-unit id="13ef2ca779cb61f44381f5a039956356e16db10c" translate="yes" xml:space="preserve">
          <source>A previous call to &lt;code&gt;&lt;a href=&quot;free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;realloc&lt;/code&gt; that deallocates a region of memory</source>
          <target state="translated">先前对 &lt;code&gt;&lt;a href=&quot;free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;realloc&lt;/code&gt; 的调用会释放内存区域</target>
        </trans-unit>
        <trans-unit id="369395da987013876caff2dc1e6f3dc1c78f2dfd" translate="yes" xml:space="preserve">
          <source>A program may undefine and perhaps then redefine the &lt;code&gt;complex&lt;/code&gt; macro.</source>
          <target state="translated">程序可能会取消定义，然后可能会重新定义 &lt;code&gt;complex&lt;/code&gt; 宏。</target>
        </trans-unit>
        <trans-unit id="dfbb31de52784bd58fab9c555b2dcef326c6957c" translate="yes" xml:space="preserve">
          <source>A program may undefine and perhaps then redefine the macro &lt;code&gt;I&lt;/code&gt;.</source>
          <target state="translated">程序可以取消定义，也许再重新定义宏 &lt;code&gt;I&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="673ac82817b0262ffc8e60c6ab8111db0abf125a" translate="yes" xml:space="preserve">
          <source>A program may undefine and perhaps then redefine the macros &lt;code&gt;bool&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">程序可以取消定义，也许再重新定义宏 &lt;code&gt;bool&lt;/code&gt; 的， &lt;code&gt;true&lt;/code&gt; 和 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b4493cdd2ed11153441d87177f02ce56356d9390" translate="yes" xml:space="preserve">
          <source>A program with an endless loop has undefined behavior if the loop has no observable behavior (I/O, volatile accesses, atomic or synchronization operation) in any part of its cond_expression, iteration_expression or loop_statement. This allows the compilers to optimize out all unobservable loops without proving that they terminate. The only exceptions are the loops where cond_expression is omitted or is a constant expression; &lt;code&gt;for(;;)&lt;/code&gt; is always an endless loop.</source>
          <target state="translated">如果循环在其cond_expression，迭代_表达式或loop_statement的任何部分中都没有可观察到的行为（I / O，易失性访问，原子或同步操作），则具有无限循环的程序将具有未定义的行为。这使编译器可以优化所有无法观察到的循环，而无需证明它们会终止。唯一的例外是省略cond_expression或为常量表达式的循环。 &lt;code&gt;for(;;)&lt;/code&gt; 始终是一个无限循环。</target>
        </trans-unit>
        <trans-unit id="d4dba07d0b12ec49c823d74b635737a662d716b7" translate="yes" xml:space="preserve">
          <source>A program with an endless loop has undefined behavior if the loop has no observable behavior (I/O, volatile accesses, atomic or synchronization operation) in any part of its statement or expression. This allows the compilers to optimize out all unobservable loops without proving that they terminate. The only exceptions are the loops where expression is a constant expression; &lt;code&gt;do {...} while(true);&lt;/code&gt; is always an endless loop.</source>
          <target state="translated">如果循环在其语句或表达式的任何部分中都没有可观察到的行为（I / O，易失性访问，原子或同步操作），则具有无限循环的程序将具有未定义的行为。这使编译器可以优化所有无法观察到的循环，而无需证明它们会终止。唯一的例外是表达式为常量表达式的循环。 &lt;code&gt;do {...} while(true);&lt;/code&gt; 永远是一个无休止的循环。</target>
        </trans-unit>
        <trans-unit id="d9fe083c28287027ff137fe873714315c88575d5" translate="yes" xml:space="preserve">
          <source>A program with an endless loop has undefined behavior if the loop has no observable behavior (I/O, volatile accesses, atomic or synchronization operation) in any part of its statement or expression. This allows the compilers to optimize out all unobservable loops without proving that they terminate. The only exceptions are the loops where expression is a constant expression; &lt;code&gt;while(true)&lt;/code&gt; is always an endless loop.</source>
          <target state="translated">如果循环在其语句或表达式的任何部分中都没有可观察到的行为（I / O，易失性访问，原子或同步操作），则具有无限循环的程序将具有未定义的行为。这使编译器可以优化所有无法观察到的循环，而无需证明它们会终止。唯一的例外是其中expression是常量表达式的循环。 &lt;code&gt;while(true)&lt;/code&gt; 始终是一个无限循环。</target>
        </trans-unit>
        <trans-unit id="a987fe5116d16dac6c986d15e44866f1f2950023" translate="yes" xml:space="preserve">
          <source>A read-modify-write operation with this memory order is both an</source>
          <target state="translated">这种内存顺序的读改写操作既是一个</target>
        </trans-unit>
        <trans-unit id="78127daba885f04d8c232a3a0e396aee55e69e02" translate="yes" xml:space="preserve">
          <source>A store operation with this memory order performs the</source>
          <target state="translated">用这个存储顺序进行存储操作,会执行</target>
        </trans-unit>
        <trans-unit id="e387542d0812c72e59ffd89517785f1df0b879db" translate="yes" xml:space="preserve">
          <source>A string literal is not necessarily a string; if a string literal has embedded null characters, it represents an array which contains more than one string:</source>
          <target state="translated">字符串不一定是一个字符串;如果一个字符串字符串有嵌入的空字符,它代表一个包含多个字符串的数组。</target>
        </trans-unit>
        <trans-unit id="b83731486e3b698aa10bc6f537bc54d6e1c7fe80" translate="yes" xml:space="preserve">
          <source>A struct is a type consisting of a sequence of members whose storage is allocated in an ordered sequence (as opposed to union, which is a type consisting of a sequence of members whose storage overlaps).</source>
          <target state="translated">结构体是一个由成员序列组成的类型,其存储空间是按顺序分配的(与联合相反,联合是一个由成员序列组成的类型,其存储空间是重叠的)。</target>
        </trans-unit>
        <trans-unit id="62857b5de9b7091adab212bbe55a64fe6f96c3d8" translate="yes" xml:space="preserve">
          <source>A successful call to &lt;code&gt;ungetc&lt;/code&gt; clears the end of file status flag &lt;code&gt;&lt;a href=&quot;feof&quot;&gt;feof&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">成功调用 &lt;code&gt;ungetc&lt;/code&gt; 会清除文件状态标志 &lt;code&gt;&lt;a href=&quot;feof&quot;&gt;feof&lt;/a&gt;&lt;/code&gt; 的结尾。</target>
        </trans-unit>
        <trans-unit id="2f18b9828e8cbe5f820c7f00f14018c93e63c261" translate="yes" xml:space="preserve">
          <source>A successful call to &lt;code&gt;ungetc&lt;/code&gt; on a binary stream decrements the stream position indicator by one (the behavior is indeterminate if the stream position indicator was zero).</source>
          <target state="translated">在二进制流上成功调用 &lt;code&gt;ungetc&lt;/code&gt; 会使流位置指示符减一（如果流位置指示符为零，则行为不确定）。</target>
        </trans-unit>
        <trans-unit id="ca4337b8d12737a6a022afbf7eb03368caa77b5b" translate="yes" xml:space="preserve">
          <source>A successful call to &lt;code&gt;ungetc&lt;/code&gt; on a text stream modifies the stream position indicator in unspecified manner but guarantees that after all pushed-back characters are retrieved with a read operation, the stream position indicator is equal to its value before &lt;code&gt;ungetc&lt;/code&gt;.</source>
          <target state="translated">在文本流上成功调用 &lt;code&gt;ungetc&lt;/code&gt; 会以未指定的方式修改流位置指示符，但可以保证在通过读取操作检索到所有推回字符后，流位置指示符等于其在 &lt;code&gt;ungetc&lt;/code&gt; 之前的值。</target>
        </trans-unit>
        <trans-unit id="ac874b9b5964dc5760d3a6f5c96e7d5268fa82e0" translate="yes" xml:space="preserve">
          <source>A successful call to &lt;code&gt;ungetwc&lt;/code&gt; clears the end of file status flag &lt;code&gt;&lt;a href=&quot;feof&quot;&gt;feof&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">成功调用 &lt;code&gt;ungetwc&lt;/code&gt; 会清除文件状态标志 &lt;code&gt;&lt;a href=&quot;feof&quot;&gt;feof&lt;/a&gt;&lt;/code&gt; 的结尾。</target>
        </trans-unit>
        <trans-unit id="96bde972d314cd8969488c09d04edcb68d3e8cec" translate="yes" xml:space="preserve">
          <source>A successful call to &lt;code&gt;ungetwc&lt;/code&gt; on a stream (whether text or binary) modifies the stream position indicator in unspecified manner but guarantees that after all pushed-back wide characters are retrieved with a read operation, the stream position indicator is equal to its value before &lt;code&gt;ungetwc&lt;/code&gt;.</source>
          <target state="translated">在流（无论是文本还是二进制）上对 &lt;code&gt;ungetwc&lt;/code&gt; 的成功调用将以未指定的方式修改流位置指示符，但保证在通过读取操作检索到所有推回的宽字符之后，流位置指示符等于其在 &lt;code&gt;ungetwc&lt;/code&gt; 之前的值。</target>
        </trans-unit>
        <trans-unit id="ae28ba5e02f8f525383bb9b4fdd4379afafef790" translate="yes" xml:space="preserve">
          <source>A tentative definition with internal linkage must have complete type.</source>
          <target state="translated">有内部联系的暂定定义必须有完整的类型。</target>
        </trans-unit>
        <trans-unit id="734b0e8555885421cd88b9f937f8a5a91f954a94" translate="yes" xml:space="preserve">
          <source>A thread of execution is a flow of control within a program that begins with the invocation of a top-level function by &lt;code&gt;&lt;a href=&quot;../thread/thrd_create&quot;&gt;thrd_create&lt;/a&gt;&lt;/code&gt; or other means.</source>
          <target state="translated">执行线程是程序中的控制流，该控制流以通过 &lt;code&gt;&lt;a href=&quot;../thread/thrd_create&quot;&gt;thrd_create&lt;/a&gt;&lt;/code&gt; 或其他方式调用顶级函数开始。</target>
        </trans-unit>
        <trans-unit id="83494c42dbcc847aa1ff217c1fe7f8283385dd00" translate="yes" xml:space="preserve">
          <source>A type may have to be named in context other than the &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt;. In these situations,</source>
          <target state="translated">类型可能必须在&lt;a href=&quot;declarations&quot;&gt;声明&lt;/a&gt;之外的上下文中命名。在这些情况下，</target>
        </trans-unit>
        <trans-unit id="89da242d1eea5250f1f3146f1bc7040bd1b23fbb" translate="yes" xml:space="preserve">
          <source>A type name may introduce a new type:</source>
          <target state="translated">类型名称可以引入一个新的类型。</target>
        </trans-unit>
        <trans-unit id="0ded4b2c0ade545ee92678f87004b8c5310458e0" translate="yes" xml:space="preserve">
          <source>A typedef for a VLA can only appear at block scope. The length of the array is evaluated each time the flow of control passes over the typedef declaration, as opposed to the declaration of the array itself:</source>
          <target state="translated">VLA的typedef只能在块作用域出现。数组的长度是在每次控制流经过 typedef 声明时进行评估的,而不是数组本身的声明。</target>
        </trans-unit>
        <trans-unit id="ea6b56408c3f67fe3e4cd9bb8c98bda8cd2227a2" translate="yes" xml:space="preserve">
          <source>A typical cause of failure for &lt;code&gt;puts&lt;/code&gt; is running out of space on the file system, when stdout is redirected to a file.</source>
          <target state="translated">当stdout重定向到文件时， &lt;code&gt;puts&lt;/code&gt; 失败的典型原因是文件系统上的空间不足。</target>
        </trans-unit>
        <trans-unit id="6f0adfae1100114c8248488bd9e46306cf3169dd" translate="yes" xml:space="preserve">
          <source>A union is a type consisting of a sequence of members whose storage overlaps (as opposed to struct, which is a type consisting of a sequence of members whose storage is allocated in an ordered sequence). The value of at most one of the members can be stored in a union at any one time.</source>
          <target state="translated">un union是一个由一系列成员组成的类型,它们的存储是重叠的(与struct相反,struct是一个由一系列成员组成的类型,它们的存储是按顺序分配的)。在任何时候,联盟中最多只能存储一个成员的值。</target>
        </trans-unit>
        <trans-unit id="b72fa34edde9b7a760e2ca9a63cea91e1b555145" translate="yes" xml:space="preserve">
          <source>A universal character name in a narrow string literal or a 16-bit string literal may map to more than one character, e.g. &lt;code&gt;\U0001f34c&lt;/code&gt; is 4 &lt;code&gt;char&lt;/code&gt; code units in UTF-8 (&lt;code&gt;\xF0\x9F\x8D\x8C&lt;/code&gt;) and 2 &lt;code&gt;char16_t&lt;/code&gt; code units in UTF-16 (&lt;code&gt;\uD83C\uDF4C&lt;/code&gt;).</source>
          <target state="translated">窄字符串文字或16位字符串文字中的通用字符名称可以映射到多个字符，例如 &lt;code&gt;\U0001f34c&lt;/code&gt; 是UTF-8中的4个 &lt;code&gt;char&lt;/code&gt; 代码单位（ &lt;code&gt;\xF0\x9F\x8D\x8C&lt;/code&gt; ）和2个 &lt;code&gt;char16_t&lt;/code&gt; 代码单位为UTF-16（ &lt;code&gt;\uD83C\uDF4C&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="15de7dbea993ba11f5f4400e4c3b5596b766e0df" translate="yes" xml:space="preserve">
          <source>A valid C program must not depend on whether the inline version or the external version of a function is called.</source>
          <target state="translated">一个有效的C程序必须不取决于是调用函数的内联版本还是外部版本。</target>
        </trans-unit>
        <trans-unit id="d626b3d232c881f5c4b8b1ea2e9f96008808e88d" translate="yes" xml:space="preserve">
          <source>A value of any complex type can be implicitly converted to any imaginary type.</source>
          <target state="translated">任何复杂类型的值都可以隐式地转换为任何虚类型。</target>
        </trans-unit>
        <trans-unit id="5c88d24cc4ec994d46157d83290ad8af83a11e69" translate="yes" xml:space="preserve">
          <source>A value of any complex type can be implicitly converted to any other complex type. The real part and the imaginary part individually follow the conversion rules for the real floating types.</source>
          <target state="translated">任何复数类型的值都可以隐式转换为其他任何复数类型。实部和虚部分别遵循实浮类型的转换规则。</target>
        </trans-unit>
        <trans-unit id="045b19c719d2ce31e6c3fc2dbb610a034ab82f27" translate="yes" xml:space="preserve">
          <source>A value of any complex type can be implicitly converted to any real floating type.</source>
          <target state="translated">任何复杂类型的值都可以隐含地转换为任何实际浮动类型。</target>
        </trans-unit>
        <trans-unit id="523b4bcf3df5def7bdb173f6da2f1c669d5ffd10" translate="yes" xml:space="preserve">
          <source>A value of any imaginary type can be implicitly converted to any complex type.</source>
          <target state="translated">任何虚型的值都可以隐含地转换为任何复型。</target>
        </trans-unit>
        <trans-unit id="a4bba57f46ad248ddc356b6653b3a832c38ef932" translate="yes" xml:space="preserve">
          <source>A value of any imaginary type can be implicitly converted to any other imaginary type. The imaginary part follows the conversion rules for the real floating types.</source>
          <target state="translated">任何虚型的值都可以隐式转换为其他任何虚型。虚型部分遵循实型浮动类型的转换规则。</target>
        </trans-unit>
        <trans-unit id="3eeda2e376d925bd595e8ae9c46012cbc5e846d4" translate="yes" xml:space="preserve">
          <source>A value of any imaginary type can be implicitly converted to any real type (integer or floating-point). The result is always a positive (or unsigned) zero, except when the target type is _Bool, in which case boolean conversion rules apply.</source>
          <target state="translated">任何虚型的值都可以隐式地转换为任何实型(整数或浮点数)。结果总是一个正数(或无符号)零,除非目标类型是_Bool,在这种情况下,布尔转换规则适用。</target>
        </trans-unit>
        <trans-unit id="b1043e27727b5859c73d6368abb56140d9c8c4df" translate="yes" xml:space="preserve">
          <source>A value of any integer type can be implicitly converted to any other integer type. Except where covered by promotions and boolean conversions above, the rules are:</source>
          <target state="translated">任何整数类型的值都可以隐式转换为任何其他整数类型。除了上述推广和布尔转换所涉及的地方,规则是:</target>
        </trans-unit>
        <trans-unit id="d48506c225a6b698b81ca8310a86f4f65be3e2ca" translate="yes" xml:space="preserve">
          <source>A value of any integer type can be implicitly converted to any real floating type.</source>
          <target state="translated">任何整数类型的值都可以隐含地转换为任何实际浮动类型。</target>
        </trans-unit>
        <trans-unit id="026d85487a9bfd120f0733b4a332d6f7183d4b83" translate="yes" xml:space="preserve">
          <source>A value of any real floating type can be implicitly converted to any complex type.</source>
          <target state="translated">任何实型浮动类型的值都可以隐式转换为任何复杂类型。</target>
        </trans-unit>
        <trans-unit id="1850c152b30508607de5e5ce9465d153d7482b90" translate="yes" xml:space="preserve">
          <source>A value of any real floating type can be implicitly converted to any other real floating type.</source>
          <target state="translated">任何实心浮动类型的值都可以隐式转换为任何其他实心浮动类型。</target>
        </trans-unit>
        <trans-unit id="4ddbeeb9abdb8bf97e248ee8a8c3ed50c8646e45" translate="yes" xml:space="preserve">
          <source>A value of any real type can be implicitly converted to any imaginary type. The result is always a positive imaginary zero.</source>
          <target state="translated">任何实型的值都可以隐式转换为任何虚型。结果总是一个正的虚数零。</target>
        </trans-unit>
        <trans-unit id="542b0b974643a87f82bdfb9069328ad0a228dd34" translate="yes" xml:space="preserve">
          <source>A value of any scalar type can be implicitly converted to _Bool. The values that compare equal to zero are converted to &lt;code&gt;​0​&lt;/code&gt;, all other values are converted to &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">任何标量类型的值都可以隐式转换为_Bool。该比较等于零的值被转换为 &lt;code&gt;​0​&lt;/code&gt; ，所有其他值被转换为 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fa3584dfc017c837cf1f146d7c3bfa22f920a495" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;void (*)(int)&lt;/code&gt;. When returned by &lt;code&gt;&lt;a href=&quot;signal&quot;&gt;signal&lt;/a&gt;&lt;/code&gt;, indicates that an error has occurred.</source>
          <target state="translated">类型 &lt;code&gt;void (*)(int)&lt;/code&gt; 。当通过 &lt;code&gt;&lt;a href=&quot;signal&quot;&gt;signal&lt;/a&gt;&lt;/code&gt; 返回时，表明发生了错误。</target>
        </trans-unit>
        <trans-unit id="e43f5b4e5dab83ce22f20cdda8ca8c5befbdfb54" translate="yes" xml:space="preserve">
          <source>A well-known example of the same identifier being used across two name spaces is the identifier &lt;code&gt;stat&lt;/code&gt; from the POSIX header &lt;code&gt;sys/stat.h&lt;/code&gt;. It &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/&quot;&gt;names a function&lt;/a&gt; when used as an ordinary identifier and &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;indicates a struct&lt;/a&gt; when used as a tag.</source>
          <target state="translated">在两个名称空间中使用相同标识符的一个众所周知的示例是POSIX标头 &lt;code&gt;sys/stat.h&lt;/code&gt; 中的标识符 &lt;code&gt;stat&lt;/code&gt; 。当用作普通标识符时，它&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/&quot;&gt;为函数命名&lt;/a&gt;，而用作标记时，则&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;表示结构&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="252604e65d1755596aaf50baece602312c996647" translate="yes" xml:space="preserve">
          <source>A well-known example of the same identifier being used across two name spaces is the identifier &lt;code&gt;stat&lt;/code&gt; from the POSIX header &lt;code&gt;sys/stat.h&lt;/code&gt;. It &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/&quot;&gt;names a function&lt;/a&gt; when used as an ordinary identifier and &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;indicates a struct&lt;/a&gt; when used as a tag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47e9ca7eeeecd01f720a4c3ebefa8b5b579f496b" translate="yes" xml:space="preserve">
          <source>A.1.2.1 Expressions</source>
          <target state="translated">A.1.2.1 表达式</target>
        </trans-unit>
        <trans-unit id="9fa96a046c7129ab706b3906b3b75c43d0b3b41e" translate="yes" xml:space="preserve">
          <source>A.2.1 Expressions</source>
          <target state="translated">A.2.1 表达式</target>
        </trans-unit>
        <trans-unit id="187459c12cbce645deb52d74f3d6152a7a9a17fc" translate="yes" xml:space="preserve">
          <source>ASCII Chart</source>
          <target state="translated">ASCII图表</target>
        </trans-unit>
        <trans-unit id="6b85275355e86325dde0c35693852c2d7820c750" translate="yes" xml:space="preserve">
          <source>ASCII chart</source>
          <target state="translated">ASCII图</target>
        </trans-unit>
        <trans-unit id="6ff2c765d8c7f7f1624b70244d10913facb7ae0b" translate="yes" xml:space="preserve">
          <source>ASCII values</source>
          <target state="translated">ASCII值</target>
        </trans-unit>
        <trans-unit id="741d25da837c7eedcbdbd90d0d949bbad6187038" translate="yes" xml:space="preserve">
          <source>ATOMIC_*_LOCK_FREE</source>
          <target state="translated">ATOMIC_*_LOCK_FREE</target>
        </trans-unit>
        <trans-unit id="1120084929ffa752eeda2469d9c594dc3612e485" translate="yes" xml:space="preserve">
          <source>ATOMIC_BOOL_LOCK_FREEATOMIC_CHAR_LOCK_FREEATOMIC_CHAR16_T_LOCK_FREEATOMIC_CHAR32_T_LOCK_FREEATOMIC_WCHAR_T_LOCK_FREEATOMIC_SHORT_LOCK_FREEATOMIC_INT_LOCK_FREEATOMIC_LONG_LOCK_FREEATOMIC_LLONG_LOCK_FREEATOMIC_POINTER_LOCK_FREE</source>
          <target state="translated">ATOMIC_BOOL_LOCK_FREEATOMIC_CHAR_LOCK_FREEATOMIC_CHAR16_T_LOCK_FREEATOMIC_CHAR32_T_LOCK_FREEATOMIC_WCHAR_T_LOCK_FREEATOMIC_SHORT_LOCK_FREEATOMIC_INT_LOCK_FREEATOMIC_LONG_LOCK_FREEATOMIC_LLONG_LOCK_FREEATOMIC_POINTER_LOCK_FREE</target>
        </trans-unit>
        <trans-unit id="63e21a0c9c10fbf518b0166eb437a67f1ed962cd" translate="yes" xml:space="preserve">
          <source>ATOMIC_FLAG_INIT</source>
          <target state="translated">ATOMIC_FLAG_INIT</target>
        </trans-unit>
        <trans-unit id="0b0620452fea1cd6ef04952a1260146f273e310f" translate="yes" xml:space="preserve">
          <source>ATOMIC_VAR_INIT</source>
          <target state="translated">ATOMIC_VAR_INIT</target>
        </trans-unit>
        <trans-unit id="9de67dfb6d06413cdc219824a0f3f88445b9f32c" translate="yes" xml:space="preserve">
          <source>Access out of bounds</source>
          <target state="translated">出界访问</target>
        </trans-unit>
        <trans-unit id="1632238dd01e0d2949d4e0ad89257742628b773a" translate="yes" xml:space="preserve">
          <source>Access to pointer passed to realloc</source>
          <target state="translated">访问传递给realloc的指针。</target>
        </trans-unit>
        <trans-unit id="c14ddd2129de76c2ada1aa7e78baf410f83de4be" translate="yes" xml:space="preserve">
          <source>Accessing a member of an atomic struct/union is undefined behavior.</source>
          <target state="translated">访问原子结构/union的成员是未定义的行为。</target>
        </trans-unit>
        <trans-unit id="f576e8c8e33a749329570e7a77b007df382e969e" translate="yes" xml:space="preserve">
          <source>Accessing an object outside of its lifetime is undefined behavior.</source>
          <target state="translated">在对象的生命周期之外访问对象是未定义的行为。</target>
        </trans-unit>
        <trans-unit id="b720069db01e986b09ea45ae4ab2aa8008f5f98c" translate="yes" xml:space="preserve">
          <source>Accessing the variadic arguments from the function body uses the following library facilities:</source>
          <target state="translated">从函数体中访问变量参数时,使用了以下库设施。</target>
        </trans-unit>
        <trans-unit id="894e0d0ca601136dd7488a48cc4e246850d2e574" translate="yes" xml:space="preserve">
          <source>Action if file</source>
          <target state="translated">行动,如果文件</target>
        </trans-unit>
        <trans-unit id="48911a7386b2baa20a76ef9e342562ca04e9c341" translate="yes" xml:space="preserve">
          <source>Addition and subtraction</source>
          <target state="translated">加法和减法</target>
        </trans-unit>
        <trans-unit id="283ec445be98c579864590d0e92c5442ed90be08" translate="yes" xml:space="preserve">
          <source>Additional basic types and convenience macros</source>
          <target state="translated">额外的基本类型和方便的宏</target>
        </trans-unit>
        <trans-unit id="c33da322e780907896acfdbb397c70d360f6b9ec" translate="yes" xml:space="preserve">
          <source>Additional implementation-defined types may be acceptable. It is also implementation-defined whether a bit field may have &lt;a href=&quot;atomic&quot;&gt;atomic&lt;/a&gt; type.(since C11) The number of bits in a bit field (width) sets the limit to the range of values it can hold:</source>
          <target state="translated">其他实现定义的类型也可以接受。同样由实现定义，位字段是否可以具有&lt;a href=&quot;atomic&quot;&gt;原子&lt;/a&gt;类型。（自C11起）位字段中的位数（宽度）将限制设置为其可容纳的值的范围：</target>
        </trans-unit>
        <trans-unit id="0d1029ad60405084db977e479c06f25f269c8a36" translate="yes" xml:space="preserve">
          <source>Additional macro constants, with names that begin with &lt;code&gt;LC_&lt;/code&gt; followed by at least one uppercase letter, may be defined in &lt;code&gt;locale.h&lt;/code&gt;. For example, the POSIX specification requires LC_MESSAGES (which controls, among other things, &lt;code&gt;&lt;a href=&quot;../io/perror&quot;&gt;perror&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../string/byte/strerror&quot;&gt;strerror&lt;/a&gt;&lt;/code&gt;), ISO/IEC 30112:2014 (&lt;a href=&quot;http://www.open-std.org/JTC1/SC35/WG5/docs/30112d10.pdf&quot;&gt;2014 draft&lt;/a&gt;) additionally defines LC_IDENTIFICATION, LC_XLITERATE, LC_NAME, LC_ADDRESS, LC_TELEPHONE, LC_PAPER, LC_MEASUREMENT, and LC_KEYBOARD, which are supported by the GNU C library (except for LC_XLITERATE).</source>
          <target state="translated">可以在 &lt;code&gt;locale.h&lt;/code&gt; 中定义其他宏常量，其名称以 &lt;code&gt;LC_&lt;/code&gt; 开头，后跟至少一个大写字母。例如，POSIX规范要求LC_MESSAGES（其控制，除其他外， &lt;code&gt;&lt;a href=&quot;../io/perror&quot;&gt;perror&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../string/byte/strerror&quot;&gt;strerror&lt;/a&gt;&lt;/code&gt; ），ISO / IEC 30112：2014（&lt;a href=&quot;http://www.open-std.org/JTC1/SC35/WG5/docs/30112d10.pdf&quot;&gt;2014草案&lt;/a&gt;）另外限定LC_IDENTIFICATION，LC_XLITERATE，LC_NAME，LC_ADDRESS，LC_TELEPHONE，LC_PAPER，LC_MEASUREMENT，和LC_KEYBOARD，由GNU C库支持（LC_XLITERATE除外）。</target>
        </trans-unit>
        <trans-unit id="764a28584542378b58ffc1460c2f5cd3c32d60ca" translate="yes" xml:space="preserve">
          <source>Additional macros that begin with &lt;code&gt;FE_&lt;/code&gt; followed by uppercase letters, and have the type &lt;code&gt;const fenv_t*&lt;/code&gt;, may be supported by an implementation.</source>
          <target state="translated">一个实现可能支持以 &lt;code&gt;FE_&lt;/code&gt; 开头，后跟大写字母，类型为 &lt;code&gt;const fenv_t*&lt;/code&gt; 其他宏。</target>
        </trans-unit>
        <trans-unit id="ef3d826dd03b81e684d86b842e89e92269929ee7" translate="yes" xml:space="preserve">
          <source>Additional numeric formats may be accepted by the currently installed C &lt;code&gt;&lt;a href=&quot;../../locale/setlocale&quot;&gt;locale&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">当前安装的C &lt;code&gt;&lt;a href=&quot;../../locale/setlocale&quot;&gt;locale&lt;/a&gt;&lt;/code&gt; 可能接受其他数字格式。</target>
        </trans-unit>
        <trans-unit id="e8146529cfa6fa203e23e61b37cbdf2d37d4634b" translate="yes" xml:space="preserve">
          <source>Additional rounding modes may be supported by an implementation.</source>
          <target state="translated">实施例可以支持其他的四舍五入模式。</target>
        </trans-unit>
        <trans-unit id="bb9fec43e4640236adc94f7a637b3f0160e148fc" translate="yes" xml:space="preserve">
          <source>Additionally, for every parameter of &lt;a href=&quot;array&quot;&gt;array type&lt;/a&gt; that uses the keyword &lt;code&gt;static&lt;/code&gt; between &lt;code&gt;[&lt;/code&gt; and &lt;code&gt;]&lt;/code&gt;, the argument expression must designate a pointer to the element of an array with at least that many elements as specified in the size expression of the parameter.</source>
          <target state="translated">另外，对于在 &lt;code&gt;[&lt;/code&gt; 和 &lt;code&gt;]&lt;/code&gt; 之间使用关键字 &lt;code&gt;static&lt;/code&gt; 的&lt;a href=&quot;array&quot;&gt;数组类型的&lt;/a&gt;每个参数，参数表达式必须指定一个指向数组元素的指针，该数组的元素至少具有该参数的size表达式中指定的数量。</target>
        </trans-unit>
        <trans-unit id="76be74594d0a3f6f1c23004ef8fbefa453574daa" translate="yes" xml:space="preserve">
          <source>Additive operators</source>
          <target state="translated">加法运算符</target>
        </trans-unit>
        <trans-unit id="576276822a153883d3d9699e768d5b4ee811a461" translate="yes" xml:space="preserve">
          <source>Address of</source>
          <target state="translated">地址</target>
        </trans-unit>
        <trans-unit id="9377e4719dc070a5dfa0119a44583c6b5ae07578" translate="yes" xml:space="preserve">
          <source>Address-of</source>
          <target state="translated">Address-of</target>
        </trans-unit>
        <trans-unit id="458e4498a6e12a40a95f335b3f81898cfd748b12" translate="yes" xml:space="preserve">
          <source>Adjacent &lt;a href=&quot;string_literal&quot;&gt;string literals&lt;/a&gt; are concatenated.</source>
          <target state="translated">相邻的&lt;a href=&quot;string_literal&quot;&gt;字符串文字&lt;/a&gt;是串联在一起的。</target>
        </trans-unit>
        <trans-unit id="1fb3e0e585b7b35a447a3da6d3ae0da5248da92b" translate="yes" xml:space="preserve">
          <source>After encountering the &lt;code&gt;#error&lt;/code&gt; directive, an implementation displays the diagnostic message error_message and renders the program ill-formed (the compilation stops).</source>
          <target state="translated">遇到 &lt;code&gt;#error&lt;/code&gt; 指令后，实现将显示诊断消息error_message并使程序格式错误（编译停止）。</target>
        </trans-unit>
        <trans-unit id="37697aac1a5eff809b30503e048e426d91ee09c0" translate="yes" xml:space="preserve">
          <source>After seeking to a non-end position in a wide stream, the next call to any output function may render the remainder of the file undefined, e.g. by outputting a multibyte sequence of a different length.</source>
          <target state="translated">在寻求到宽流中的非结束位置后,下一次对任何输出函数的调用可能会使文件的剩余部分未被定义,例如通过输出不同长度的多字节序列。</target>
        </trans-unit>
        <trans-unit id="8942a31efdd7fa2a68a933b01b212ddbca06e0f0" translate="yes" xml:space="preserve">
          <source>After this statement the control is transferred to the statement or declaration immediately following the enclosing loop or switch, as if by &lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;.</source>
          <target state="translated">在此语句之后，控制将紧随封闭循环或切换之后立即转移到语句或声明，就像通过&lt;a href=&quot;goto&quot;&gt;goto一样&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="67e15eb99dc0e473c962d6a494d00e048e9f6fc6" translate="yes" xml:space="preserve">
          <source>Algorithms</source>
          <target state="translated">Algorithms</target>
        </trans-unit>
        <trans-unit id="d72f31b2f308ee63f6def08b39a4b92ac993f430" translate="yes" xml:space="preserve">
          <source>Alignas specifier only needs to appear on the &lt;a href=&quot;declarations#Definitions&quot;&gt;definition&lt;/a&gt; of an object, but if any declaration uses alignas, it must specify the same alignment as the alignas on the definition. The behavior is undefined if different translation units specify different alignments for the same object.</source>
          <target state="translated">Alignas说明符仅需要出现在对象的&lt;a href=&quot;declarations#Definitions&quot;&gt;定义&lt;/a&gt;上，但是如果任何声明使用alignas，则它必须在定义上指定与alignas相同的对齐方式。如果不同的翻译单元为同一对象指定了不同的对齐方式，则该行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="7f8c5176c3f03b97659161923f2b6492f7de7e73" translate="yes" xml:space="preserve">
          <source>Alignment</source>
          <target state="translated">Alignment</target>
        </trans-unit>
        <trans-unit id="998eaf2c199d6e6c5ec4ea687761747f4ea20894" translate="yes" xml:space="preserve">
          <source>Alignment of the allocation unit that holds a bit field</source>
          <target state="translated">持有位字段的分配单元的对齐方式</target>
        </trans-unit>
        <trans-unit id="6a874fb4ad2b87c17e904b10d9366720c6d119fa" translate="yes" xml:space="preserve">
          <source>Alignment requirement(C11)</source>
          <target state="translated">路线要求(C11)</target>
        </trans-unit>
        <trans-unit id="60417779e7300dcc151a6eb620dfb95350289093" translate="yes" xml:space="preserve">
          <source>All &lt;a href=&quot;value_category&quot;&gt;value categories&lt;/a&gt;, including function designators and void expressions, are allowed as expressions in a generic selection, and if selected, the generic selection itself has the same value category.</source>
          <target state="translated">所有&lt;a href=&quot;value_category&quot;&gt;值类别&lt;/a&gt;（包括函数指定符和void表达式）都可以用作通用选择中的表达式，如果选择，则通用选择本身具有相同的值类别。</target>
        </trans-unit>
        <trans-unit id="4f9ee5d352b4270a148f5665caeb9006b6fbb7b5" translate="yes" xml:space="preserve">
          <source>All array elements that are not initialized explicitly are &lt;a href=&quot;initialization&quot;&gt;initialized implicitly&lt;/a&gt; the same way as objects that have static storage duration.</source>
          <target state="translated">所有未显式&lt;a href=&quot;initialization&quot;&gt;初始化的&lt;/a&gt;数组元素都将隐式初始化，其方式与具有静态存储持续时间的对象相同。</target>
        </trans-unit>
        <trans-unit id="4c15cf3f5d785f05b074208b892da42654f696fb" translate="yes" xml:space="preserve">
          <source>All comments are removed from the program at &lt;a href=&quot;language/translation_phases&quot;&gt;translation phase 3&lt;/a&gt; by replacing each comment with a single whitespace character.</source>
          <target state="translated">通过将每个注释替换为单个空格字符，可以在&lt;a href=&quot;language/translation_phases&quot;&gt;翻译阶段3&lt;/a&gt;将所有注释从程序中删除。</target>
        </trans-unit>
        <trans-unit id="a33a0daa0c6f810f1da4bed7e4f886f7a3fa028a" translate="yes" xml:space="preserve">
          <source>All conversion specifiers other than &lt;code&gt;[&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;, and &lt;code&gt;n&lt;/code&gt; consume and discard all leading whitespace characters (determined as if by calling &lt;a href=&quot;../string/byte/isspace&quot;&gt;&lt;code&gt;isspace&lt;/code&gt;&lt;/a&gt;) before attempting to parse the input. These consumed characters do not count towards the specified maximum field width.</source>
          <target state="translated">在尝试解析输入之前，除 &lt;code&gt;[&lt;/code&gt; ， &lt;code&gt;c&lt;/code&gt; 和 &lt;code&gt;n&lt;/code&gt; 之外的所有转换说明符都会消耗并丢弃所有前导空白字符（就像通过调用&lt;a href=&quot;../string/byte/isspace&quot;&gt; &lt;code&gt;isspace&lt;/code&gt; &lt;/a&gt;来确定）。这些消耗的字符不计入指定的最大字段宽度。</target>
        </trans-unit>
        <trans-unit id="e7cb57b66d2139c6b332fa6e8e17ae9b77fdde8b" translate="yes" xml:space="preserve">
          <source>All conversion specifiers other than &lt;code&gt;[&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;, and &lt;code&gt;n&lt;/code&gt; consume and discard all leading whitespace characters (determined as if by calling &lt;a href=&quot;../string/wide/iswspace&quot;&gt;&lt;code&gt;iswspace&lt;/code&gt;&lt;/a&gt;) before attempting to parse the input. These consumed characters do not count towards the specified maximum field width.</source>
          <target state="translated">在尝试解析输入之前，除 &lt;code&gt;[&lt;/code&gt; ， &lt;code&gt;c&lt;/code&gt; 和 &lt;code&gt;n&lt;/code&gt; 以外的所有转换说明符都会消耗并丢弃所有前导空白字符（好像通过调用&lt;a href=&quot;../string/wide/iswspace&quot;&gt; &lt;code&gt;iswspace&lt;/code&gt; &lt;/a&gt;来确定）。这些消耗的字符不计入指定的最大字段宽度。</target>
        </trans-unit>
        <trans-unit id="170e9e40346b4676af2c9543c1315fbdba1de3af" translate="yes" xml:space="preserve">
          <source>All members that are not initialized explicitly are &lt;a href=&quot;initialization#Implicit_initialization&quot;&gt;initialized implicitly&lt;/a&gt; the same way as objects that have static storage duration.</source>
          <target state="translated">所有未显式&lt;a href=&quot;initialization#Implicit_initialization&quot;&gt;初始化的&lt;/a&gt;成员都与具有静态存储持续时间的对象一样隐式地初始化。</target>
        </trans-unit>
        <trans-unit id="237d36367069e4b8c7a44d2afc03a5597429cd9e" translate="yes" xml:space="preserve">
          <source>All other identifiers are available, with no fear of unexpected collisions when moving programs from one compiler and library to another.</source>
          <target state="translated">其他标识符都可以使用,当程序从一个编译器和库转移到另一个编译器和库时,不用担心意外碰撞。</target>
        </trans-unit>
        <trans-unit id="1fbacfcbc3bb83e6594a5426d07a776d016ded8e" translate="yes" xml:space="preserve">
          <source>All these functions invoke &lt;code&gt;va_arg&lt;/code&gt; at least once, the value of &lt;code&gt;arg&lt;/code&gt; is indeterminate after the return. These functions do not invoke &lt;code&gt;va_end&lt;/code&gt;, and it must be done by the caller.</source>
          <target state="translated">所有这些函数至少调用一次 &lt;code&gt;va_arg&lt;/code&gt; ，返回后 &lt;code&gt;arg&lt;/code&gt; 的值不确定。这些函数不会调用 &lt;code&gt;va_end&lt;/code&gt; ，并且必须由调用方完成。</target>
        </trans-unit>
        <trans-unit id="11b370485f04e9782b3074994340dd54b2c413b7" translate="yes" xml:space="preserve">
          <source>All these functions invoke &lt;code&gt;va_arg&lt;/code&gt; at least once, the value of &lt;code&gt;arg&lt;/code&gt; is indeterminate after the return. These functions to not invoke &lt;code&gt;va_end&lt;/code&gt;, and it must be done by the caller.</source>
          <target state="translated">所有这些函数至少调用一次 &lt;code&gt;va_arg&lt;/code&gt; ，返回后 &lt;code&gt;arg&lt;/code&gt; 的值不确定。这些函数不会调用 &lt;code&gt;va_end&lt;/code&gt; ，并且必须由调用方完成。</target>
        </trans-unit>
        <trans-unit id="35959593fb331ed044f2bd60520abb9932e2098b" translate="yes" xml:space="preserve">
          <source>All these functions may invoke &lt;code&gt;va_arg&lt;/code&gt;, the value of &lt;code&gt;arg&lt;/code&gt; is indeterminate after the return. These functions to not invoke &lt;code&gt;va_end&lt;/code&gt;, and it must be done by the caller.</source>
          <target state="translated">所有这些函数都可以调用 &lt;code&gt;va_arg&lt;/code&gt; ，返回后 &lt;code&gt;arg&lt;/code&gt; 的值不确定。这些函数不会调用 &lt;code&gt;va_end&lt;/code&gt; ，并且必须由调用方完成。</target>
        </trans-unit>
        <trans-unit id="b0490d0cb63a327b1645f25c31bcc6482c7608ed" translate="yes" xml:space="preserve">
          <source>All these macro constants (except &lt;code&gt;FE_ALL_EXCEPT&lt;/code&gt;) expand to integer constant expressions that are distinct powers of 2, which uniquely identify all supported floating-point exceptions. Each macro is only defined if it is supported.</source>
          <target state="translated">所有这些宏常量（ &lt;code&gt;FE_ALL_EXCEPT&lt;/code&gt; 除外）都扩展为具有2的幂的整数常量表达式，它们可唯一标识所有受支持的浮点异常。仅在支持的情况下定义每个宏。</target>
        </trans-unit>
        <trans-unit id="4b26e5fb8ce8c48af69f0f82512b4e4d3a9cb87e" translate="yes" xml:space="preserve">
          <source>All thread-specific storage values (see &lt;code&gt;&lt;a href=&quot;tss_create&quot;&gt;tss_create&lt;/a&gt;&lt;/code&gt;) are initialized to &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">所有特定于线程的存储值（请参阅 &lt;code&gt;&lt;a href=&quot;tss_create&quot;&gt;tss_create&lt;/a&gt;&lt;/code&gt; ）都初始化为 &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb8fdb32122bd65cf5d7c325d5377fe22c226fe9" translate="yes" xml:space="preserve">
          <source>All undefined behavior not listed as critical is bounded, including</source>
          <target state="translated">所有未被列为关键行为的未定义行为都是有边界的,包括</target>
        </trans-unit>
        <trans-unit id="7b8e5641e2d8cbf1a2bdfdaf4f5a52ae7c538b20" translate="yes" xml:space="preserve">
          <source>Allocate &lt;code&gt;size&lt;/code&gt; bytes of uninitialized storage whose alignment is specified by &lt;code&gt;alignment&lt;/code&gt;. The &lt;code&gt;size&lt;/code&gt; parameter must be an integral multiple of &lt;code&gt;alignment&lt;/code&gt;.</source>
          <target state="translated">分配未对齐存储的 &lt;code&gt;size&lt;/code&gt; 字节，未对齐存储的对齐方式由 &lt;code&gt;alignment&lt;/code&gt; 指定。的 &lt;code&gt;size&lt;/code&gt; 参数必须是的整数倍 &lt;code&gt;alignment&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="575bf26e9df794dbd1383b334ef663788e920b7e" translate="yes" xml:space="preserve">
          <source>Allocates &lt;code&gt;size&lt;/code&gt; bytes of uninitialized storage.</source>
          <target state="translated">分配未初始化存储的 &lt;code&gt;size&lt;/code&gt; 字节。</target>
        </trans-unit>
        <trans-unit id="eaf6e4d87daf82411e96d7b40d5b5e9337ffd24d" translate="yes" xml:space="preserve">
          <source>Allocates memory for an array of &lt;code&gt;num&lt;/code&gt; objects of size &lt;code&gt;size&lt;/code&gt; and initializes all bytes in the allocated storage to zero.</source>
          <target state="translated">用于阵列中分配内存 &lt;code&gt;num&lt;/code&gt; 尺寸的对象 &lt;code&gt;size&lt;/code&gt; 和初始化在该分配的存储到零所有的字节。</target>
        </trans-unit>
        <trans-unit id="dfab2da001a1d62544447fa5f9f2ca3eaeb8861b" translate="yes" xml:space="preserve">
          <source>Allows values of floating type to be used directly in expressions.</source>
          <target state="translated">允许在表达式中直接使用浮动类型的值。</target>
        </trans-unit>
        <trans-unit id="ccb54e9be1a4c6bc9837fefd7cc02f1997a12f3c" translate="yes" xml:space="preserve">
          <source>Allows values of integer type to be used in expressions directly.</source>
          <target state="translated">允许在表达式中直接使用整数类型的值。</target>
        </trans-unit>
        <trans-unit id="c630eed84e53f9bda6e9f3acef1d7440aafcdd63" translate="yes" xml:space="preserve">
          <source>Also, each name that begins with a double underscore __ or an underscore followed by an uppercase letter is reserved: see &lt;a href=&quot;language/identifier#Reserved_identifiers&quot;&gt;identifier&lt;/a&gt; for details.</source>
          <target state="translated">同样，每个以双下划线__或下划线后跟大写字母开头的名称均被保留：有关详细信息，请参见&lt;a href=&quot;language/identifier#Reserved_identifiers&quot;&gt;标识符&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7d26d9b99ae9e352859532e801512a8d171f666b" translate="yes" xml:space="preserve">
          <source>Also, in C89, functions returning &lt;code&gt;int&lt;/code&gt; may be implicitly declared by the &lt;a href=&quot;operator_other#Function_call&quot;&gt;function call operator&lt;/a&gt; and function parameters of type &lt;code&gt;int&lt;/code&gt; do not have to be declared when using old-style &lt;a href=&quot;function_definition&quot;&gt;function definitions&lt;/a&gt;.</source>
          <target state="translated">同样，在C89中，返回 &lt;code&gt;int&lt;/code&gt; 的函数可以由&lt;a href=&quot;operator_other#Function_call&quot;&gt;函数调用运算符&lt;/a&gt;隐式声明，并且在使用旧式&lt;a href=&quot;function_definition&quot;&gt;函数定义&lt;/a&gt;时不必声明 &lt;code&gt;int&lt;/code&gt; 类型的函数参数。</target>
        </trans-unit>
        <trans-unit id="3b74e96e489cf616e54374e5e92ff3290101f441" translate="yes" xml:space="preserve">
          <source>Alternative</source>
          <target state="translated">Alternative</target>
        </trans-unit>
        <trans-unit id="3c2e302cecd8e724ebefc4430def999e1f422931" translate="yes" xml:space="preserve">
          <source>Alternative operator spellings</source>
          <target state="translated">其他运算符拼法</target>
        </trans-unit>
        <trans-unit id="29b586a7316da5dd137563369a7689b456379b04" translate="yes" xml:space="preserve">
          <source>Alternative operators and tokens</source>
          <target state="translated">替代运营商和代币</target>
        </trans-unit>
        <trans-unit id="4169be2060a4f8c4d585658039b95f12303e8c2e" translate="yes" xml:space="preserve">
          <source>Alternative tokens(C95)</source>
          <target state="translated">替代代币(C95)</target>
        </trans-unit>
        <trans-unit id="a40e532bb9001ffd6cd51359a18af099b40b59fc" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;pow&lt;/code&gt; cannot be used to obtain a root of a negative number, &lt;code&gt;&lt;a href=&quot;cbrt&quot;&gt;cbrt&lt;/a&gt;&lt;/code&gt; is provided for the common case where &lt;code&gt;exponent&lt;/code&gt; is 1/3.</source>
          <target state="translated">尽管不能使用 &lt;code&gt;pow&lt;/code&gt; 来获得负数的根，但是对于 &lt;code&gt;exponent&lt;/code&gt; 为1/3 的常见情况，会提供 &lt;code&gt;&lt;a href=&quot;cbrt&quot;&gt;cbrt&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2d8e94ab087764ac5aa30f64f41b3a370e564193" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;scalbn&lt;/code&gt; and &lt;code&gt;scalbln&lt;/code&gt; are specified to perform the operation efficiently, on many implementations they are less efficient than multiplication or division by a power of two using arithmetic operators.</source>
          <target state="translated">尽管 &lt;code&gt;scalbn&lt;/code&gt; 和 &lt;code&gt;scalbln&lt;/code&gt; 被指定为有效执行操作，但是在许多实现中，它们的效率不如使用算术运算符乘以2的幂。</target>
        </trans-unit>
        <trans-unit id="0137da8668a196cbd69268350977f203b3e7ba1a" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;strcat_s&lt;/code&gt; prohibits truncation due to potential security risks, it's possible to truncate a string using bounds-checked &lt;code&gt;&lt;a href=&quot;strncat&quot;&gt;strncat_s&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">尽管由于潜在的安全风险， &lt;code&gt;strcat_s&lt;/code&gt; 禁止截断，但是可以使用边界检查的 &lt;code&gt;&lt;a href=&quot;strncat&quot;&gt;strncat_s&lt;/a&gt;&lt;/code&gt; 截断字符串。</target>
        </trans-unit>
        <trans-unit id="01379ffb327aca2e2965c17285601b164531b9d3" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;strcpy_s&lt;/code&gt; prohibits truncation due to potential security risks, it's possible to truncate a string using bounds-checked &lt;code&gt;&lt;a href=&quot;strncpy&quot;&gt;strncpy_s&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">尽管由于潜在的安全风险， &lt;code&gt;strcpy_s&lt;/code&gt; 禁止截断，但是可以使用边界检查的 &lt;code&gt;&lt;a href=&quot;strncpy&quot;&gt;strncpy_s&lt;/a&gt;&lt;/code&gt; 截断字符串。</target>
        </trans-unit>
        <trans-unit id="c5b70b90ff2e7a517d78bb25ef1bb2546d9ba464" translate="yes" xml:space="preserve">
          <source>Although a zero-initialized &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;mbstate_t&lt;/a&gt;&lt;/code&gt; always represents the initial conversion state, there may be other values of &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;mbstate_t&lt;/a&gt;&lt;/code&gt; that also represent the initial conversion state.</source>
          <target state="translated">尽管零初始化的 &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;mbstate_t&lt;/a&gt;&lt;/code&gt; 始终表示初始转换状态，但可能还有 &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;mbstate_t&lt;/a&gt;&lt;/code&gt; 的其他值也代表初始转换状态。</target>
        </trans-unit>
        <trans-unit id="521f97be29caaa78fcaf410bee9ae92c160ecbf8" translate="yes" xml:space="preserve">
          <source>Although any non-initialized subobjects are initialized implicitly, implicit initialization of a subobject never overrides explicit initialization of the same subobject if it appeared earlier in the initializer list:</source>
          <target state="translated">虽然任何非初始化的子对象都是隐式初始化的,但子对象的隐式初始化永远不会覆盖同一子对象的显式初始化,如果它在初始化器列表中较早出现。</target>
        </trans-unit>
        <trans-unit id="9f867aad644439954e9498b489992312dc0bfdc5" translate="yes" xml:space="preserve">
          <source>Although any pointer to object &lt;a href=&quot;cast&quot;&gt;can be cast&lt;/a&gt; to pointer to object of a different type, dereferencing a pointer to the type different from the declared type of the object is almost always undefined behavior. See &lt;a href=&quot;object#Strict_aliasing&quot;&gt;strict aliasing&lt;/a&gt; for details.</source>
          <target state="translated">尽管任何指向对象的指针&lt;a href=&quot;cast&quot;&gt;都可以转换&lt;/a&gt;为指向不同类型的对象的指针，但是取消引用与该对象的声明类型不同的类型的指针几乎总是未定义的行为。有关详细信息，请参见&lt;a href=&quot;object#Strict_aliasing&quot;&gt;严格别名&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="782db2506e8b16f17d55cc92953bb6895f994beb" translate="yes" xml:space="preserve">
          <source>Although arrays are not assignable, an array wrapped in a struct is assignable to another object of the same (or compatible) struct type.</source>
          <target state="translated">虽然数组是不可分配的,但是包裹在结构中的数组可以分配给另一个相同(或兼容)结构类型的对象。</target>
        </trans-unit>
        <trans-unit id="430fe03afb1283d4323b38c44acf81ba027f8497" translate="yes" xml:space="preserve">
          <source>Although function call is only defined for pointers to functions, it works with function designators due to the &lt;a href=&quot;conversion#Function_to_pointer_conversion&quot;&gt;function-to-pointer implicit conversion&lt;/a&gt;.</source>
          <target state="translated">尽管仅针对函数指针定义了函数调用，但由于&lt;a href=&quot;conversion#Function_to_pointer_conversion&quot;&gt;函数到指针的隐式转换&lt;/a&gt;，它可与函数指定符一起使用。</target>
        </trans-unit>
        <trans-unit id="f95c1167e4e765bd871f83860e20dc43744490fd" translate="yes" xml:space="preserve">
          <source>Although most implementations do not allow trap representations, padding bits, or multiple representations for integer types, there are exceptions; for example a value of an integer type on Itanium &lt;a href=&quot;https://blogs.msdn.microsoft.com/oldnewthing/20040119-00/?p=41003&quot;&gt;may be a trap representation&lt;/a&gt;.</source>
          <target state="translated">尽管大多数实现不允许整数类型的陷阱表示，填充位或多个表示，但也有例外。例如Itanium上的整数类型的值&lt;a href=&quot;https://blogs.msdn.microsoft.com/oldnewthing/20040119-00/?p=41003&quot;&gt;可能是陷阱表示&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ee0f85d5b5f4455a1b40b55fabe7b08d4d7be13b" translate="yes" xml:space="preserve">
          <source>Although not defined by the C standard, this is almost always an integral value holding the number of seconds (not counting leap seconds) since 00:00, Jan 1 1970 UTC, corresponding to &lt;a href=&quot;https://en.wikipedia.org/wiki/Unix_time&quot;&gt; POSIX time&lt;/a&gt;.</source>
          <target state="translated">尽管未由C标准定义，但几乎始终是一个整数值，该值包含自1970年1月1日UTC的00:00开始的秒数（不计算leap秒），对应于&lt;a href=&quot;https://en.wikipedia.org/wiki/Unix_time&quot;&gt;POSIX时间&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a46ea2cf03738e87c00f27d14c8aeeab6336c94e" translate="yes" xml:space="preserve">
          <source>Although old-style (prototype-less) &lt;a href=&quot;function_declaration&quot;&gt;function declarations&lt;/a&gt; allow the subsequent function calls to use any number of arguments, they are not allowed to be variadic (as of C89). The definition of such function must specify a fixed number of parameters and cannot use the &lt;code&gt;stdarg.h&lt;/code&gt; macros.</source>
          <target state="translated">尽管旧式（无原型）&lt;a href=&quot;function_declaration&quot;&gt;函数声明&lt;/a&gt;允许后续函数调用使用任意数量的参数，但不允许它们是可变参数的（从C89开始）。此类函数的定义必须指定固定数量的参数，并且不能使用 &lt;code&gt;stdarg.h&lt;/code&gt; 宏。</target>
        </trans-unit>
        <trans-unit id="183d193e98a51645be957397dbe1157096e4898e" translate="yes" xml:space="preserve">
          <source>Although signed integer overflow in any arithmetic operator is undefined behavior, overflowing a signed integer type in an integer conversion is merely unspecified behavior.</source>
          <target state="translated">虽然在任何算术运算符中的符号整数溢出都是未定义的行为,但在整数转换中的符号整数类型溢出只是未定义的行为。</target>
        </trans-unit>
        <trans-unit id="c610559acf57d5e13360168218d35087e3133418" translate="yes" xml:space="preserve">
          <source>Although the C standard names the inverse hyperbolics with &quot;complex arc hyperbolic sine&quot; etc., the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct names are &quot;complex inverse hyperbolic sine&quot; etc. Some authors use &quot;complex area hyperbolic sine&quot; etc.</source>
          <target state="translated">虽然C标准用 &quot;复弧双曲正弦 &quot;等来命名反双曲函数,但双曲函数的反函数是面积函数。它们的参数是双曲扇形的面积,而不是弧形的面积。正确的名称是 &quot;复数反双曲正弦 &quot;等。有的作者用 &quot;复面积双曲正弦 &quot;等。</target>
        </trans-unit>
        <trans-unit id="53eb2f193d1ece133e78496ed9e6ccf150600d5c" translate="yes" xml:space="preserve">
          <source>Although the C standard names this function &quot;arc hyperbolic cosine&quot;, the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is &quot;inverse hyperbolic cosine&quot; (used by POSIX) or &quot;area hyperbolic cosine&quot;.</source>
          <target state="translated">虽然C标准将这个函数命名为 &quot;弧双曲余弦&quot;,但双曲函数的反函数是面积函数。它们的参数是双曲扇形的面积,而不是弧形。正确的名称是 &quot;反双曲余弦&quot;(POSIX使用)或 &quot;面积双曲余弦&quot;。</target>
        </trans-unit>
        <trans-unit id="9cc69d890735ff86a139ac61024682374f6710b3" translate="yes" xml:space="preserve">
          <source>Although the C standard names this function &quot;arc hyperbolic sine&quot;, the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is &quot;inverse hyperbolic sine&quot; (used by POSIX) or &quot;area hyperbolic sine&quot;.</source>
          <target state="translated">虽然C标准将这个函数命名为 &quot;弧形双曲正弦&quot;,但双曲函数的反函数是面积函数。它们的参数是双曲扇形的面积,而不是弧形。正确的名称是 &quot;反双曲正弦&quot;(POSIX使用)或 &quot;面积双曲正弦&quot;。</target>
        </trans-unit>
        <trans-unit id="1c9639606a887095dbb5eeca1ccea8904ebf0979" translate="yes" xml:space="preserve">
          <source>Although the C standard names this function &quot;arc hyperbolic tangent&quot;, the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is &quot;inverse hyperbolic tangent&quot; (used by POSIX) or &quot;area hyperbolic tangent&quot;.</source>
          <target state="translated">虽然C标准将这个函数命名为 &quot;弧双曲正切&quot;,但双曲函数的反函数是面积函数。它们的参数是双曲扇形的面积,而不是弧形。正确的名称是 &quot;反双曲正切&quot;(POSIX使用)或 &quot;面积双曲正切&quot;。</target>
        </trans-unit>
        <trans-unit id="a42f4b1a642341cb7f5490a130fadc09495ae219" translate="yes" xml:space="preserve">
          <source>Although the C standard names this function &quot;complex arc hyperbolic cosine&quot;, the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is &quot;complex inverse hyperbolic cosine&quot;, and, less common, &quot;complex area hyperbolic cosine&quot;.</source>
          <target state="translated">虽然C标准将这个函数命名为 &quot;复圆弧双曲余弦&quot;,但双曲函数的反函数是面积函数。它们的参数是双曲扇形的面积,而不是弧形的面积。正确的名称是 &quot;复反双曲余弦&quot;,不常用的是 &quot;复面积双曲余弦&quot;。</target>
        </trans-unit>
        <trans-unit id="627b752f245ff7b1c7740db9d2b8d3d303af20f5" translate="yes" xml:space="preserve">
          <source>Although the C standard names this function &quot;complex arc hyperbolic sine&quot;, the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is &quot;complex inverse hyperbolic sine&quot;, and, less common, &quot;complex area hyperbolic sine&quot;.</source>
          <target state="translated">虽然C标准将这个函数命名为 &quot;复弧双曲正弦&quot;,但双曲函数的反函数是面积函数。它们的参数是双曲扇形的面积,而不是弧形的面积。正确的名称是 &quot;复反双曲正弦&quot;,不常用的是 &quot;复面积双曲正弦&quot;。</target>
        </trans-unit>
        <trans-unit id="36d2388b219b1a45a5fcef0d0ad2e1d71bd9c5f1" translate="yes" xml:space="preserve">
          <source>Although the C standard names this function &quot;complex arc hyperbolic tangent&quot;, the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is &quot;complex inverse hyperbolic tangent&quot;, and, less common, &quot;complex area hyperbolic tangent&quot;.</source>
          <target state="translated">虽然C标准将这个函数命名为 &quot;复弧双曲正切&quot;,但双曲函数的反函数是面积函数。它们的参数是双曲扇形的面积,而不是弧形的面积。正确的名称是 &quot;复反双曲正切&quot;,不常用的是 &quot;复面积双曲正切&quot;。</target>
        </trans-unit>
        <trans-unit id="e55c4c08037504cff68121796bbc9e46b8ee6db3" translate="yes" xml:space="preserve">
          <source>Although the names generated by &lt;code&gt;tmpnam&lt;/code&gt; are difficult to guess, it is possible that a file with that name is created by another process between the moment &lt;code&gt;tmpnam&lt;/code&gt; returns and the moment this program attempts to use the returned name to create a file. The standard function &lt;code&gt;&lt;a href=&quot;tmpfile&quot;&gt;tmpfile&lt;/a&gt;&lt;/code&gt; and the POSIX function &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/mkdtemp.html&quot;&gt;mkstemp&lt;/a&gt; do not have this problem (creating a unique directory using only the standard C library still requires the use of &lt;code&gt;tmpnam&lt;/code&gt;).</source>
          <target state="translated">尽管 &lt;code&gt;tmpnam&lt;/code&gt; 生成的名称很难猜测，但是在 &lt;code&gt;tmpnam&lt;/code&gt; 返回到此程序尝试使用返回的名称来创建文件之间，可能会由另一个进程创建具有该名称的文件。标准函数 &lt;code&gt;&lt;a href=&quot;tmpfile&quot;&gt;tmpfile&lt;/a&gt;&lt;/code&gt; 和POSIX函数&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/mkdtemp.html&quot;&gt;mkstemp&lt;/a&gt;不存在此问题（仅使用标准C库创建唯一目录仍需要使用 &lt;code&gt;tmpnam&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d97d1de0fa8aae159d75543bb9e42e7f7b35623f" translate="yes" xml:space="preserve">
          <source>Although the names generated by &lt;code&gt;tmpnam&lt;/code&gt; are difficult to guess, it is possible that a file with that name is created by another process between the moment &lt;code&gt;tmpnam&lt;/code&gt; returns and the moment this program attempts to use the returned name to create a file. The standard function &lt;code&gt;&lt;a href=&quot;tmpfile&quot;&gt;tmpfile&lt;/a&gt;&lt;/code&gt; and the POSIX function &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/mkdtemp.html&quot;&gt;mkstemp&lt;/a&gt; do not have this problem (creating a unique directory using only the standard C library still requires the use of &lt;code&gt;tmpnam&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8a747e33a10c6fa21c941b73f1438fc704b6283" translate="yes" xml:space="preserve">
          <source>Although the return type is &lt;code&gt;char*&lt;/code&gt;, modifying the pointed-to characters is undefined behavior.</source>
          <target state="translated">尽管返回类型为 &lt;code&gt;char*&lt;/code&gt; ，但修改指向的字符是未定义的行为。</target>
        </trans-unit>
        <trans-unit id="5d77d3b4837e50c32db090517b15b7c3f0e6e611" translate="yes" xml:space="preserve">
          <source>Although the standard specification is ambiguous in the case where &lt;code&gt;count==1&lt;/code&gt;, common implementations read no characters, store zero in &lt;code&gt;str[0]&lt;/code&gt;, and report success (return &lt;code&gt;str&lt;/code&gt;).</source>
          <target state="translated">尽管在 &lt;code&gt;count==1&lt;/code&gt; 的情况下标准规范是模棱两可的，但是常见的实现不读取任何字符，在 &lt;code&gt;str[0]&lt;/code&gt; 存储零，并报告成功（返回 &lt;code&gt;str&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="643daeb4adeff0fcce44a0450dc2ccf13dec660b" translate="yes" xml:space="preserve">
          <source>Although the syntax of a compound literal is similar to a &lt;a href=&quot;cast&quot;&gt;cast&lt;/a&gt;, the important distinction is that a cast is a non-lvalue expression while a compound literal is an lvalue.</source>
          <target state="translated">尽管复合文字的语法类似于&lt;a href=&quot;cast&quot;&gt;强制转换&lt;/a&gt;，但重要的区别是强制转换是非左值表达式，而复合文字是左值。</target>
        </trans-unit>
        <trans-unit id="524b5a64840b79d1a2de79e908e1ff895523c4a5" translate="yes" xml:space="preserve">
          <source>Although truncation to fit the destination buffer is a security risk and therefore a runtime constraints violation for &lt;code&gt;strncat_s&lt;/code&gt;, it is possible to get the truncating behavior by specifying &lt;code&gt;count&lt;/code&gt; equal to the size of the destination array minus one: it will copy the first &lt;code&gt;count&lt;/code&gt; bytes and append the null terminator as always: &lt;code&gt;strncat_s(dst, sizeof dst, src, (sizeof dst)-strnlen_s(dst, sizeof dst)-1);&lt;/code&gt;</source>
          <target state="translated">尽管截断以适合目标缓冲区是安全风险，因此违反了 &lt;code&gt;strncat_s&lt;/code&gt; 的运行时约束，但可以通过指定 &lt;code&gt;count&lt;/code&gt; 等于目标数组的大小减去1 来获得截断行为：它将复制第一个 &lt;code&gt;count&lt;/code&gt; 字节并像往常一样追加空终止符： &lt;code&gt;strncat_s(dst, sizeof dst, src, (sizeof dst)-strnlen_s(dst, sizeof dst)-1);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="31058475f488e9122376b4823fdbfa19cec13f95" translate="yes" xml:space="preserve">
          <source>Although truncation to fit the destination buffer is a security risk and therefore a runtime constraints violation for &lt;code&gt;strncpy_s&lt;/code&gt;, it is possible to get the truncating behavior by specifying &lt;code&gt;count&lt;/code&gt; equal to the size of the destination array minus one: it will copy the first &lt;code&gt;count&lt;/code&gt; bytes and append the null terminator as always: &lt;code&gt;strncpy_s(dst, sizeof dst, src, (sizeof dst)-1);&lt;/code&gt;</source>
          <target state="translated">尽管截断以适合目标缓冲区是安全风险，因此违反了 &lt;code&gt;strncpy_s&lt;/code&gt; 的运行时约束，但可以通过指定 &lt;code&gt;count&lt;/code&gt; 等于目标数组的大小减去1 来获得截断行为：它将复制第一个 &lt;code&gt;count&lt;/code&gt; 字节并像往常一样追加空终止符： &lt;code&gt;strncpy_s(dst, sizeof dst, src, (sizeof dst)-1);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ed3455470f39d87a62eebd7b7029aa61541270b7" translate="yes" xml:space="preserve">
          <source>Although truncation to fit the destination buffer is a security risk and therefore a runtime constraints violation for &lt;code&gt;wcsncat_s&lt;/code&gt;, it is possible to get the truncating behavior by specifying &lt;code&gt;count&lt;/code&gt; equal to the size of the destination array minus one: it will copy the first &lt;code&gt;count&lt;/code&gt; wide characters and append the null terminator as always: &lt;code&gt;wcsncat_s(dst, sizeof dst/sizeof *dst, src, (sizeof dst/sizeof *dst)-wcsnlen_s(dst, sizeof dst/sizeof *dst)-1);&lt;/code&gt;</source>
          <target state="translated">尽管截断以适合目标缓冲区是安全风险，因此违反了 &lt;code&gt;wcsncat_s&lt;/code&gt; 的运行时约束，但可以通过指定 &lt;code&gt;count&lt;/code&gt; 等于目标数组的大小减去1 来获得截断行为：它将复制第一个 &lt;code&gt;count&lt;/code&gt; 宽字符并一如既往地附加空终止符： &lt;code&gt;wcsncat_s(dst, sizeof dst/sizeof *dst, src, (sizeof dst/sizeof *dst)-wcsnlen_s(dst, sizeof dst/sizeof *dst)-1);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="91cbd8326b7ebc58c195548dc89d276533889261" translate="yes" xml:space="preserve">
          <source>Although truncation to fit the destination buffer is a security risk and therefore a runtime constraints violation for &lt;code&gt;wcsncpy_s&lt;/code&gt;, it is possible to get the truncating behavior by specifying &lt;code&gt;count&lt;/code&gt; equal to the size of the destination array minus one: it will copy the first &lt;code&gt;count&lt;/code&gt; wide characters and append the null wide terminator as always: &lt;code&gt;wcsncpy_s(dst, sizeof dst / sizeof *dst, src, (sizeof dst / sizeof *dst)-1);&lt;/code&gt;</source>
          <target state="translated">尽管截断以适合目标缓冲区是安全隐患，因此会违反 &lt;code&gt;wcsncpy_s&lt;/code&gt; 的运行时约束，但可以通过指定 &lt;code&gt;count&lt;/code&gt; 等于目标数组的大小减去1 来获得截断行为：它将复制第一个 &lt;code&gt;count&lt;/code&gt; 宽字符并像往常一样追加null宽终止符： &lt;code&gt;wcsncpy_s(dst, sizeof dst / sizeof *dst, src, (sizeof dst / sizeof *dst)-1);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="99690d58d4abd10cd0938a7adcb56ded08ef66ad" translate="yes" xml:space="preserve">
          <source>An</source>
          <target state="translated">An</target>
        </trans-unit>
        <trans-unit id="e95121f45a467fe30f9e9b9421b8414b5dc9b5a8" translate="yes" xml:space="preserve">
          <source>An exception to the above rule is the &lt;code&gt;fabs&lt;/code&gt; macro (see the table below).</source>
          <target state="translated">上面的规则是 &lt;code&gt;fabs&lt;/code&gt; 宏的一个例外（请参见下表）。</target>
        </trans-unit>
        <trans-unit id="34f74cee143d788f51fcc25acc797aea92c197b8" translate="yes" xml:space="preserve">
          <source>An expression followed by a semicolon is a statement.</source>
          <target state="translated">分号后的表达式是一个语句。</target>
        </trans-unit>
        <trans-unit id="c5756e59953f27f7802c2879dfb5bf8b2ef537aa" translate="yes" xml:space="preserve">
          <source>An expression is a sequence of</source>
          <target state="translated">表达式是一系列的</target>
        </trans-unit>
        <trans-unit id="8582e3c88de4617441467faab5ff600afdf1bfb6" translate="yes" xml:space="preserve">
          <source>An expression statement without an expression is called a</source>
          <target state="translated">没有表达式的表达式语句称为</target>
        </trans-unit>
        <trans-unit id="e88ff614d33ada21febd8f65027f3a4ddd6534c8" translate="yes" xml:space="preserve">
          <source>An incomplete type is an object type that lacks sufficient information to determine the size of the objects of that type. An incomplete type may be completed at some point in the translation unit.</source>
          <target state="translated">不完整类型是一种缺乏足够信息来确定该类型对象大小的对象类型。不完整类型可能在翻译单元的某个点完成。</target>
        </trans-unit>
        <trans-unit id="922cdb3f2c9cb3526b3e2d10c81d2dfe51f98e18" translate="yes" xml:space="preserve">
          <source>An integer constant expression is an expression that consists only of.</source>
          <target state="translated">整数常数表达式是指只由以下内容组成的表达式。</target>
        </trans-unit>
        <trans-unit id="f10b2455ca40601e84b6c671226ded817e8d0567" translate="yes" xml:space="preserve">
          <source>An integer constant is a &lt;a href=&quot;value_category&quot;&gt;non-lvalue&lt;/a&gt; expression of the form.</source>
          <target state="translated">整数常量是形式的&lt;a href=&quot;value_category&quot;&gt;非左值&lt;/a&gt;表达式。</target>
        </trans-unit>
        <trans-unit id="4fbb0b241c865dd210a0103cf5d2af8c3a3e8a71" translate="yes" xml:space="preserve">
          <source>An integer greater than zero if the stream is wide-oriented after this call, less than zero if the stream is byte-oriented after this call, and zero if the stream has no orientation.</source>
          <target state="translated">大于零的整数,如果这次调用后的流是面向宽的,小于零,如果这次调用后的流是面向字节的,零,如果流没有面向。</target>
        </trans-unit>
        <trans-unit id="22296b3029f90df1ec990b3a781242c55d5beaa6" translate="yes" xml:space="preserve">
          <source>An integer type which can be accessed as an atomic entity even in the presence of asynchronous interrupts made by signals.</source>
          <target state="translated">一个整数类型,它可以作为一个原子实体被访问,即使是在信号进行异步中断的情况下。</target>
        </trans-unit>
        <trans-unit id="509428cacc9180cadada492e5a97d331536c77bb" translate="yes" xml:space="preserve">
          <source>An object whose identifier is declared with the storage-class specifier &lt;code&gt;_Thread_local&lt;/code&gt;(since C11) has thread storage duration. Its lifetime is the entire execution of the thread for which it is created, and its stored value is initialized when the thread is started. There is a distinct object per thread, and use of the declared name in an expression refers to the object associated with the thread evaluating the expression. The result of attempting to indirectly access an object with thread storage duration from a thread other than the one with which the object is associated is implementation-defined.</source>
          <target state="translated">使用存储类说明符 &lt;code&gt;_Thread_local&lt;/code&gt; 声明其标识符的对象（自C11起）具有线程存储持续时间。它的生存期是为其创建线程的整个执行过程，并在启动线程时初始化其存储的值。每个线程有一个不同的对象，并且在表达式中使用声明的名称是指与评估表达式的线程关联的对象。尝试从与对象关联的线程之外的线程间接访问具有线程存储持续时间的对象的结果是实现定义的。</target>
        </trans-unit>
        <trans-unit id="ca6829296f71df282c1b4376c48afbb797f79121" translate="yes" xml:space="preserve">
          <source>An object whose identifier is declared without the storage-class specifier &lt;code&gt;_Thread_local&lt;/code&gt;, and either with external or internal &lt;a href=&quot;storage_duration#Linkage&quot;&gt;linkage&lt;/a&gt; or with the storage-class specifier &lt;code&gt;static&lt;/code&gt;, has static storage duration. Its lifetime is the entire execution of the program and its stored value is initialized only once, prior to program startup.</source>
          <target state="translated">声明其标识符时没有存储类说明符 &lt;code&gt;_Thread_local&lt;/code&gt; 且具有外部或内部&lt;a href=&quot;storage_duration#Linkage&quot;&gt;链接&lt;/a&gt;或具有存储类说明符 &lt;code&gt;static&lt;/code&gt; 的对象，其存储持续时间为静态。它的生命周期是程序的整个执行过程，并且在程序启动之前，其存储值仅初始化一次。</target>
        </trans-unit>
        <trans-unit id="ac3869f4a5a82462e5b3c6903ccb04495bd9eeec" translate="yes" xml:space="preserve">
          <source>An object, in C, is region of &lt;a href=&quot;memory_model&quot;&gt;data storage&lt;/a&gt; in the execution environment, the contents of which can represent</source>
          <target state="translated">C中的对象是执行环境中&lt;a href=&quot;memory_model&quot;&gt;数据存储的&lt;/a&gt;区域，其内容可以表示</target>
        </trans-unit>
        <trans-unit id="78ade4e82af0b35312ea1cf340af57aa22d18fa0" translate="yes" xml:space="preserve">
          <source>An unsuffixed floating constant has type &lt;code&gt;double&lt;/code&gt;. If suffix is the letter &lt;code&gt;f&lt;/code&gt; or &lt;code&gt;F&lt;/code&gt;, the floating constant has type &lt;code&gt;float&lt;/code&gt;. If suffix is the letter &lt;code&gt;l&lt;/code&gt; or &lt;code&gt;L&lt;/code&gt;, the floating constant has type &lt;code&gt;long double&lt;/code&gt;.</source>
          <target state="translated">无后缀的浮点常量的类型为 &lt;code&gt;double&lt;/code&gt; 。如果后缀是字母 &lt;code&gt;f&lt;/code&gt; 或 &lt;code&gt;F&lt;/code&gt; ，则浮点常量的类型为 &lt;code&gt;float&lt;/code&gt; 。如果后缀是字母 &lt;code&gt;l&lt;/code&gt; 或 &lt;code&gt;L&lt;/code&gt; ，则浮点常量的类型为 &lt;code&gt;long double&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6af0fd01a43835edcca93cfea6189ce121e3b7bc" translate="yes" xml:space="preserve">
          <source>Analyzability</source>
          <target state="translated">Analyzability</target>
        </trans-unit>
        <trans-unit id="1224aba20bea722a32d03ea6e039ef1fe32002ee" translate="yes" xml:space="preserve">
          <source>Analyzability extension permits, as a form of implementation-defined behavior, for the &lt;a href=&quot;../error/set_constraint_handler_s&quot;&gt;runtime constraint handler&lt;/a&gt; to be invoked when a trap occurs.</source>
          <target state="translated">作为实现定义的行为的一种形式，可分析性扩展允许在发生陷阱时调用&lt;a href=&quot;../error/set_constraint_handler_s&quot;&gt;运行时约束处理程序&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="88fad02460e9c399ee6de569a0dbe485d36f0c20" translate="yes" xml:space="preserve">
          <source>Annex G (informative) IEC 60559-compatible complex arithmetic (p: 467-480)</source>
          <target state="translated">附件G(信息)IEC 60559兼容的复数算术(第467-480页)</target>
        </trans-unit>
        <trans-unit id="363c4a1ac12e80d5822b10c88a28ccf2c8e5db57" translate="yes" xml:space="preserve">
          <source>Annex G (normative) IEC 60559-compatible complex arithmetic (p: 532-545)</source>
          <target state="translated">附件G(规范性)IEC 60559兼容的复数算术(第532-545页)</target>
        </trans-unit>
        <trans-unit id="b05eeba32030c7db8c4ce96b39a5db85c6475ff5" translate="yes" xml:space="preserve">
          <source>Annex L Analyzability (p: 652-653)</source>
          <target state="translated">附件L 可分析性(第652-653页)</target>
        </trans-unit>
        <trans-unit id="899d67ebfae429b08b8eebcf8e8c9e086747304a" translate="yes" xml:space="preserve">
          <source>Another way to test if a floating-point value is NaN is to compare it with itself: &lt;code&gt;bool is_nan(double x) { return x != x; }&lt;/code&gt;</source>
          <target state="translated">测试浮点值是否为NaN的另一种方法是将其与自身进行比较： &lt;code&gt;bool is_nan(double x) { return x != x; }&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9ce38c932d44d15a1b772dcde23f9e877b670097" translate="yes" xml:space="preserve">
          <source>Any &lt;a href=&quot;value_category&quot;&gt;lvalue expression&lt;/a&gt; of &lt;a href=&quot;array&quot;&gt;array type&lt;/a&gt;, when used in any context other than.</source>
          <target state="translated">任何&lt;a href=&quot;value_category&quot;&gt;左值表达式&lt;/a&gt;的&lt;a href=&quot;array&quot;&gt;阵列型&lt;/a&gt;，比其他任何上下文中使用时。</target>
        </trans-unit>
        <trans-unit id="3ada2b7aff782859a1770ce5c125b8fc47b51105" translate="yes" xml:space="preserve">
          <source>Any &lt;a href=&quot;value_category&quot;&gt;lvalue expression&lt;/a&gt; of any non-array type, when used in any context other than.</source>
          <target state="translated">在非上下文中使用时，任何非数组类型的任何&lt;a href=&quot;value_category&quot;&gt;左值表达式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b32b22200862e7a1d98c59831163dac931baf00f" translate="yes" xml:space="preserve">
          <source>Any &lt;a href=&quot;value_category&quot;&gt;lvalue expression&lt;/a&gt; of array type, when used in any context other than.</source>
          <target state="translated">在非上下文中使用时，数组类型的任何&lt;a href=&quot;value_category&quot;&gt;左值表达式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f119a4c0c577a8422656ad60e3f009df6812696f" translate="yes" xml:space="preserve">
          <source>Any attempt to modify an object whose type is const-qualified results in undefined behavior.</source>
          <target state="translated">任何修改类型为const-qualified的对象的尝试都会导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="866f91766b87953ad8edd681c9682a8e938a7503" translate="yes" xml:space="preserve">
          <source>Any attempt to modify an object with temporary lifetime results in undefined behavior.</source>
          <target state="translated">任何试图修改一个具有临时寿命的对象的行为都会导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="8749d31d9b04cec89cefa681f64da614302dca60" translate="yes" xml:space="preserve">
          <source>Any attempt to read or write to an object whose type is volatile-qualified through a non-volatile lvalue results in undefined behavior:</source>
          <target state="translated">任何通过非易失性的l值来读取或写入一个类型为易失性限定的对象的尝试都会导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="6de4873dedcbff8007c22dcc38d613721f09e7f5" translate="yes" xml:space="preserve">
          <source>Any declaration with internal linkage that appears in a header file results in a separate and distinct object in each translation unit that includes that file.</source>
          <target state="translated">任何出现在头文件中的带有内部链接的声明,在包括该文件的每个翻译单元中都会产生一个单独的、不同的对象。</target>
        </trans-unit>
        <trans-unit id="bd4ac1ef0bc8d5c87b738bd4653ebf9c1c653d80" translate="yes" xml:space="preserve">
          <source>Any expression in parentheses is also classified as a primary expression: this guarantees that the parentheses have higher precedence than any operator.</source>
          <target state="translated">括号中的任何表达式也被归为主表达式:这保证了括号的优先级高于任何运算符。</target>
        </trans-unit>
        <trans-unit id="dfcadc42c0ec036402e088068ff0c3bc13ca677e" translate="yes" xml:space="preserve">
          <source>Any function designator expression, when used in any context other than.</source>
          <target state="translated">任何函数代号表达式,在任何情况下使用时,除了:</target>
        </trans-unit>
        <trans-unit id="4a02555a36d9834685af7a35630f001d24e0aeb2" translate="yes" xml:space="preserve">
          <source>Any function with internal linkage may be declared &lt;code&gt;static inline&lt;/code&gt; with no other restrictions.</source>
          <target state="translated">具有内部链接的任何函数都可以声明为 &lt;code&gt;static inline&lt;/code&gt; ，而没有其他限制。</target>
        </trans-unit>
        <trans-unit id="f085377b18d48b26df1584fd15c220308ad01b5c" translate="yes" xml:space="preserve">
          <source>Any integer &lt;a href=&quot;constant_expression&quot;&gt;constant expression&lt;/a&gt; with value &lt;code&gt;​0​&lt;/code&gt; as well as integer pointer expression with value zero cast to the type &lt;code&gt;void*&lt;/code&gt; can be implicitly converted to any pointer type (both pointer to object and pointer to function). The result is the null pointer value of its type, guaranteed to compare unequal to any non-null pointer value of that type. This integer or void* expression is known as</source>
          <target state="translated">任意整数&lt;a href=&quot;constant_expression&quot;&gt;常量表达式&lt;/a&gt;与值 &lt;code&gt;​0​&lt;/code&gt; 以及整数指针表达式值为零浇铸到该类型的 &lt;code&gt;void*&lt;/code&gt; 可以隐式转换到任何指针类型（两个指针对象和指针功能）。结果是其类型的空指针值，保证与该类型的任何非空指针值比较不相等。此整数或void *表达式称为</target>
        </trans-unit>
        <trans-unit id="f6aa9cfe41886fda825befd70140c82f188e05c0" translate="yes" xml:space="preserve">
          <source>Any integer can be cast to any pointer type. Except for the null pointer constants such as &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; (which &lt;a href=&quot;conversion&quot;&gt;doesn't need a cast&lt;/a&gt;), the result is implementation-defined, may not be correctly aligned, may not point to an object of the referenced type, and may be a &lt;a href=&quot;object&quot;&gt;trap representation&lt;/a&gt;.</source>
          <target state="translated">任何整数都可以转换为任何指针类型。除了诸如 &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; 之类的空指针常量（&lt;a href=&quot;conversion&quot;&gt;不需要强制转换&lt;/a&gt;）外，结果是实现定义的，可能未正确对齐，可能未指向引用类型的对象，并且可能是&lt;a href=&quot;object&quot;&gt;陷阱表示&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d27e4acb04a2d9fbbd446c13740539aaa280d88f" translate="yes" xml:space="preserve">
          <source>Any other access to the object with no declared type, the effective type is the type of the lvalue used for the access.</source>
          <target state="translated">任何其他对对象的访问,没有声明类型,有效类型是用于访问的lvalue的类型。</target>
        </trans-unit>
        <trans-unit id="1fce6ca708ece38a43d4cfdb4978f4ad32568af6" translate="yes" xml:space="preserve">
          <source>Any pointer to function can be cast to a pointer to any other function type. If the resulting pointer is converted back to the original type, it compares equal to the original value. If the converted pointer is used to make a function call, the behavior is undefined (unless the function types are &lt;a href=&quot;compatible_type#Compatible_types&quot;&gt;compatible&lt;/a&gt;)</source>
          <target state="translated">任何指向函数的指针都可以转换为指向任何其他函数类型的指针。如果将结果指针转换回原始类型，则它等于原始值。如果使用转换后的指针进行函数调用，则行为是不确定的（除非函数类型&lt;a href=&quot;compatible_type#Compatible_types&quot;&gt;兼容&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="b5144273b9cff24a19477ce9d36d363c89d3f02e" translate="yes" xml:space="preserve">
          <source>Any pointer to object can be cast to any other pointer to object. If the value is not correctly aligned for the target type, the behavior is undefined. Otherwise, if the value is converted back to the original type, it compares equal to the original value. If a pointer to object is cast to pointer to any character type, the result points at the lowest byte of the object and may be incremented up to sizeof the target type (in other words, can be used to examine &lt;a href=&quot;object&quot;&gt;object representation&lt;/a&gt; or to make a copy via &lt;code&gt;&lt;a href=&quot;../string/byte/memcpy&quot;&gt;memcpy&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;memmove&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">指向对象的任何指针都可以转换为指向对象的任何其他指针。如果该值未针对目标类型正确对齐，则行为未定义。否则，如果将值转换回原始类型，则它将与原始值进行比较。如果将指向对象的指针强制转换为指向任何字符类型的指针，则结果指向对象的最低字节，并且可以递增到目标类型的大小（换句话说，可用于检查&lt;a href=&quot;object&quot;&gt;对象表示&lt;/a&gt;或使对象通过 &lt;code&gt;&lt;a href=&quot;../string/byte/memcpy&quot;&gt;memcpy&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;memmove&lt;/a&gt;&lt;/code&gt; 复制）。</target>
        </trans-unit>
        <trans-unit id="53b27419880a23d059eebd1b3c848f2b6b494f5f" translate="yes" xml:space="preserve">
          <source>Any pointer type can be cast to any integer type. The result is implementation-defined, even for null pointer values (they do not necessarily result in the value zero). If the result cannot be represented in the target type, the behavior is undefined (unsigned integers do not implement modulo arithmetic on a cast from pointer)</source>
          <target state="translated">任何指针类型都可以被转换为任何整数类型。其结果是执行定义的,即使是空指针值也是如此(它们不一定导致值为零)。如果结果不能用目标类型来表示,那么行为是未定义的(无符号整数在从指针投射的过程中不能实现模数运算)。</target>
        </trans-unit>
        <trans-unit id="52919eaf1eb62c0854fdd694ccfd8a6c2a0705b3" translate="yes" xml:space="preserve">
          <source>Any preprocessing tokens (macro constants or expressions) are permitted as arguments to &lt;code&gt;#line&lt;/code&gt; as long as they expand to a valid decimal integer optionally following a valid character string.</source>
          <target state="translated">任何预处理标记（宏常量或表达式）都可以用作 &lt;code&gt;#line&lt;/code&gt; 的参数，只要它们扩展为有效的十进制整数（可以选择在有效字符串之后）即可。</target>
        </trans-unit>
        <trans-unit id="9f4fa7ee728ee63a75e7d354408e9febd14b9e02" translate="yes" xml:space="preserve">
          <source>Any statement (but not a declaration) may be preceded by any number of</source>
          <target state="translated">任何声明(但不是声明)前面可以有任何数量的</target>
        </trans-unit>
        <trans-unit id="594a9e7004e035507b2faafb30d5238be37f382a" translate="yes" xml:space="preserve">
          <source>Any statement can be</source>
          <target state="translated">任何声明都可以是</target>
        </trans-unit>
        <trans-unit id="9d8ddff307f484a3b8ee7169c75629627b1b6b4a" translate="yes" xml:space="preserve">
          <source>Any thread can potentially access any object in the program (objects with automatic and thread-local &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt; may still be accessed by another thread through a pointer).</source>
          <target state="translated">任何线程都可以潜在地访问程序中的任何对象（具有自动和线程本地&lt;a href=&quot;storage_duration&quot;&gt;存储持续时间的&lt;/a&gt;对象仍可以由另一个线程通过指针访问）。</target>
        </trans-unit>
        <trans-unit id="1ecdb25ac5e949980efec1665ec8ea0a080e3051" translate="yes" xml:space="preserve">
          <source>Appears in the &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt; syntax as one of the type specifiers to modify the &lt;a href=&quot;object#Alignment&quot;&gt;alignment requirement&lt;/a&gt; of the object being declared.</source>
          <target state="translated">在&lt;a href=&quot;declarations&quot;&gt;声明&lt;/a&gt;语法中显示为类型说明符之一，以修改要声明的对象的&lt;a href=&quot;object#Alignment&quot;&gt;对齐要求&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8469bf011f6ccd77c6945c6cf345649aa9cff6e9" translate="yes" xml:space="preserve">
          <source>Appears only within the statement of a loop body (&lt;a href=&quot;while&quot;&gt;while&lt;/a&gt;, &lt;a href=&quot;do&quot;&gt;do&lt;/a&gt;, &lt;a href=&quot;for&quot;&gt;for&lt;/a&gt;) or within the statement of a &lt;a href=&quot;switch&quot;&gt;switch&lt;/a&gt;.</source>
          <target state="translated">仅出现在循环体的语句中（&lt;a href=&quot;while&quot;&gt;while&lt;/a&gt;，&lt;a href=&quot;do&quot;&gt;do&lt;/a&gt;，&lt;a href=&quot;for&quot;&gt;for&lt;/a&gt;）或&lt;a href=&quot;switch&quot;&gt;开关&lt;/a&gt;的语句中。</target>
        </trans-unit>
        <trans-unit id="1f41b36bd2867522723d540cbaf10ea09210fdf2" translate="yes" xml:space="preserve">
          <source>Append to a file</source>
          <target state="translated">添加到文件中</target>
        </trans-unit>
        <trans-unit id="10adbbd3a7c36a43cb9fa85a79d28613edb0183c" translate="yes" xml:space="preserve">
          <source>Application code:</source>
          <target state="translated">申请代码:</target>
        </trans-unit>
        <trans-unit id="4da3e84107ea6402ad05595526acce55c364845f" translate="yes" xml:space="preserve">
          <source>Approximate</source>
          <target state="translated">Approximate</target>
        </trans-unit>
        <trans-unit id="ce5e5792e97fe5c7861d6ae9b29cf5a25cc0e70a" translate="yes" xml:space="preserve">
          <source>Argument</source>
          <target state="translated">Argument</target>
        </trans-unit>
        <trans-unit id="def2bf62b424e602e225d5df7086bbc94649ceb1" translate="yes" xml:space="preserve">
          <source>Argument type</source>
          <target state="translated">参数类型</target>
        </trans-unit>
        <trans-unit id="7dfad58bef64485ffe28abdf14805afc5997a006" translate="yes" xml:space="preserve">
          <source>Arithmetic addition and subtraction</source>
          <target state="translated">算术加法和减法</target>
        </trans-unit>
        <trans-unit id="86e9c4d92306ef176b1e643c9083d4f239172d17" translate="yes" xml:space="preserve">
          <source>Arithmetic constant expressions of floating-point types that are not used in static initializers are always evaluated as-if during run-time and are affected by the &lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;current rounding&lt;/a&gt; (if &lt;a href=&quot;../preprocessor/impl&quot;&gt;FENV_ACCESS&lt;/a&gt; is on) and report errors as specified in &lt;a href=&quot;../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;.</source>
          <target state="translated">静态初始值设定项中未使用的浮点类型的算术常数表达式始终在运行时被视作评估，并受&lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;当前舍入&lt;/a&gt;（如果&lt;a href=&quot;../preprocessor/impl&quot;&gt;FENV_ACCESS&lt;/a&gt;为on）的影响，并报告&lt;a href=&quot;../numeric/math/math_errhandling&quot;&gt;math_errhandling中&lt;/a&gt;指定的错误。</target>
        </trans-unit>
        <trans-unit id="d077356b7b5076ff62409f2fbd19527762e29c71" translate="yes" xml:space="preserve">
          <source>Arithmetic operators</source>
          <target state="translated">算术运算符</target>
        </trans-unit>
        <trans-unit id="fcb531b953dd45da5064b2d52a06c231157ccecd" translate="yes" xml:space="preserve">
          <source>Arithmetic operators apply standard mathematical operations to their operands.</source>
          <target state="translated">算术运算符将标准的数学运算应用到它们的操作数上。</target>
        </trans-unit>
        <trans-unit id="3a96c27ea8acc41f84ccf2e2e957611cc9d4cd07" translate="yes" xml:space="preserve">
          <source>Arithmetic types</source>
          <target state="translated">算术类型</target>
        </trans-unit>
        <trans-unit id="8de00b1bedff8647aff0425d6be471519b1d3a5a" translate="yes" xml:space="preserve">
          <source>Arithmetic(until C11)Real(since C11) type capable of representing the processor time used by a process. It has implementation-defined range and precision.</source>
          <target state="translated">算术型(C11之前)实型(C11之后),能够表示一个进程所使用的处理器时间。它的范围和精度都是由实现定义的。</target>
        </trans-unit>
        <trans-unit id="ba5ba905dbea6b631aa488beea4ac4accbaf54e2" translate="yes" xml:space="preserve">
          <source>Arithmetic(until C11)Real(since C11) type capable of representing times.</source>
          <target state="translated">算术型(C11以前)实型(C11以后),能够表示时间。</target>
        </trans-unit>
        <trans-unit id="107004472b7ba4e5e31f3082ee1fb5a1239eec61" translate="yes" xml:space="preserve">
          <source>Array</source>
          <target state="translated">Array</target>
        </trans-unit>
        <trans-unit id="3fb125cc9e54d7ed417b90f1b586cad673b24cc3" translate="yes" xml:space="preserve">
          <source>Array declaration</source>
          <target state="translated">阵列声明</target>
        </trans-unit>
        <trans-unit id="9c4ba2b7b1b1387eaf59bf743fda8372525a2456" translate="yes" xml:space="preserve">
          <source>Array designators may be nested; the bracketed constant expression for nested arrays follows the bracketed constant expression for the outer array:</source>
          <target state="translated">数组代号可以嵌套,嵌套数组的括号内常数表达式跟随外数组的括号内常数表达式。</target>
        </trans-unit>
        <trans-unit id="26c32b01062e2317d553f15f1ba72bc158531ca8" translate="yes" xml:space="preserve">
          <source>Array initialization</source>
          <target state="translated">阵列初始化</target>
        </trans-unit>
        <trans-unit id="bfd2acbfa3c1379c40dc654a37044a389ab75f2a" translate="yes" xml:space="preserve">
          <source>Array is a type consisting of a contiguously allocated nonempty sequence of objects with a particular</source>
          <target state="translated">数组是一个由连续分配的非空对象序列组成的类型,具有特定的</target>
        </trans-unit>
        <trans-unit id="d09c1ccc6ebe2f642530d449ea6ccaeedb110eac" translate="yes" xml:space="preserve">
          <source>Array subscripting</source>
          <target state="translated">阵列下标</target>
        </trans-unit>
        <trans-unit id="66b8cc3bf902fd9199bad14788d8e22184391a03" translate="yes" xml:space="preserve">
          <source>Array to pointer conversion</source>
          <target state="translated">阵列到指针的转换</target>
        </trans-unit>
        <trans-unit id="6a7e5d35200e14f310ad5bf8188982d14b575993" translate="yes" xml:space="preserve">
          <source>Arrays of constant known size</source>
          <target state="translated">已知尺寸恒定的数组</target>
        </trans-unit>
        <trans-unit id="8adb4effb7772ea8daa524a9b231c7b9d3f96d17" translate="yes" xml:space="preserve">
          <source>Arrays of constant known size can use &lt;a href=&quot;array_initialization&quot;&gt;array initializers&lt;/a&gt; to provide their initial values:</source>
          <target state="translated">已知大小恒定的数组可以使用&lt;a href=&quot;array_initialization&quot;&gt;数组初始化&lt;/a&gt;程序提供其初始值：</target>
        </trans-unit>
        <trans-unit id="c16aa1d8479c8c45ec23435b290a59e102e675bf" translate="yes" xml:space="preserve">
          <source>Arrays of known size and arrays of unknown size may be initialized, but not VLAs.(since C99).</source>
          <target state="translated">已知大小的数组和未知大小的数组可以被初始化,但VLA不能被初始化(从C99开始)。</target>
        </trans-unit>
        <trans-unit id="b3b90eb627e1832afbdc43f763aa56429f97f87e" translate="yes" xml:space="preserve">
          <source>Arrays of unknown size</source>
          <target state="translated">大小不明的数组</target>
        </trans-unit>
        <trans-unit id="52d93df12c32edd74ceb73ae81bde3e78921ac55" translate="yes" xml:space="preserve">
          <source>As a special case, expressions of type &lt;code&gt;void&lt;/code&gt; are assumed to be non-lvalue object expressions that yield a value which has no representation and requires no storage.</source>
          <target state="translated">作为一种特殊情况， &lt;code&gt;void&lt;/code&gt; 类型的表达式被假定为非左值对象表达式，其产生的值不具有表示形式且不需要存储。</target>
        </trans-unit>
        <trans-unit id="44cd20de173d4164462fd0aaa64643a2d830c5e9" translate="yes" xml:space="preserve">
          <source>As a special case, the scope of a &lt;a href=&quot;compatible_type&quot;&gt;type name&lt;/a&gt; that is not a declaration of an identifier is considered to begin just after the place within the type name where the identifier would appear were it not omitted.</source>
          <target state="translated">作为一种特殊情况，如果不是省略标识符，则认为不是标识符声明的&lt;a href=&quot;compatible_type&quot;&gt;类型名称&lt;/a&gt;的范围就从该类型名称中出现标识符的位置之后开始。</target>
        </trans-unit>
        <trans-unit id="8798ee2306ff028fd41c00f00bf32102a67a4ded" translate="yes" xml:space="preserve">
          <source>As all bounds-checked functions, &lt;code&gt;wcstok_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant &lt;code&gt;1&lt;/code&gt; before including &lt;code&gt;wchar.h&lt;/code&gt;.</source>
          <target state="translated">由于所有的边界检查功能， &lt;code&gt;wcstok_s&lt;/code&gt; 如果仅保证可供 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 被实现，并且如果所述用户定义定义 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 为整数常数 &lt;code&gt;1&lt;/code&gt; 包括前 &lt;code&gt;wchar.h&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="70096e3d69911704a0669dccced895bd18198eb0" translate="yes" xml:space="preserve">
          <source>As all bounds-checked functions, &lt;code&gt;wscanf_s&lt;/code&gt;, &lt;code&gt;fwscanf_s&lt;/code&gt;, and &lt;code&gt;swscanf_s&lt;/code&gt; are only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant &lt;code&gt;1&lt;/code&gt; before including &lt;code&gt;&amp;lt;wchar.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">由于所有的边界检查功能， &lt;code&gt;wscanf_s&lt;/code&gt; ， &lt;code&gt;fwscanf_s&lt;/code&gt; ，和 &lt;code&gt;swscanf_s&lt;/code&gt; 如果仅保证可供 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 被实现，并且如果所述用户定义定义 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 为整数常数 &lt;code&gt;1&lt;/code&gt; 包括前 &lt;code&gt;&amp;lt;wchar.h&amp;gt;&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="4a59d494eef6850f05e5c90b41b98a771ff1630a" translate="yes" xml:space="preserve">
          <source>As always, the result of a floating-point operator may have greater range and precision than is indicated by its type (see &lt;code&gt;&lt;a href=&quot;../types/limits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">与往常一样，浮点运算符的结果可能比其类型所指示的结果具有更大的范围和精度（请参见 &lt;code&gt;&lt;a href=&quot;../types/limits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="49ef5aefbc07c5fe187539b0875fc885f8b4e782" translate="yes" xml:space="preserve">
          <source>As an example of the &quot;supported by the implementation&quot; requirement, POSIX function &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_memalign.html&quot;&gt;posix_memalign&lt;/a&gt; accepts any &lt;code&gt;alignment&lt;/code&gt; that is a power of two and a multiple of &lt;code&gt;sizeof(void *)&lt;/code&gt;, and POSIX-based implementations of &lt;code&gt;aligned_alloc&lt;/code&gt; inherit this requirements.</source>
          <target state="translated">作为&amp;ldquo;实现支持&amp;rdquo;需求的一个示例，POSIX函数&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_memalign.html&quot;&gt;posix_memalign&lt;/a&gt;接受由2 &lt;code&gt;aligned_alloc&lt;/code&gt; &lt;code&gt;sizeof(void *)&lt;/code&gt; 的倍数的任何 &lt;code&gt;alignment&lt;/code&gt; ，并且基于POSIX的aligned_alloc实现继承了此需求。</target>
        </trans-unit>
        <trans-unit id="6db77bdad7734ec4ea015b574e74cd57d2d6eff5" translate="yes" xml:space="preserve">
          <source>As an example of the &quot;supported by the implementation&quot; requirement, POSIX function &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_memalign.html&quot;&gt;posix_memalign&lt;/a&gt; accepts any &lt;code&gt;alignment&lt;/code&gt; that is a power of two and a multiple of &lt;code&gt;sizeof(void *)&lt;/code&gt;, and POSIX-based implementations of &lt;code&gt;aligned_alloc&lt;/code&gt; inherit this requirements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99f5ca70997618b72580ada00f15b0f1727adfd5" translate="yes" xml:space="preserve">
          <source>As corrected by the post-C11 DR 468, &lt;code&gt;strncpy_s&lt;/code&gt;, unlike &lt;code&gt;&lt;a href=&quot;strcpy&quot;&gt;strcpy_s&lt;/a&gt;&lt;/code&gt;, is only allowed to clobber the remainder of the destination array if an error occurs.</source>
          <target state="translated">正如post-C11 DR 468所纠正的那样，与 &lt;code&gt;&lt;a href=&quot;strcpy&quot;&gt;strcpy_s&lt;/a&gt;&lt;/code&gt; 不同， &lt;code&gt;strncpy_s&lt;/code&gt; 仅在发生错误时才破坏目标数组的其余部分。</target>
        </trans-unit>
        <trans-unit id="e771c5a735f9e7c913c11ab6dfc5e9daf44f9f28" translate="yes" xml:space="preserve">
          <source>As initially published, C11 does not allow alignas specifiers in structure and union members; this was corrected by DR 444.</source>
          <target state="translated">正如最初发布的那样,C11不允许在结构和联盟成员中使用alignas指定符;DR 444对此进行了纠正。</target>
        </trans-unit>
        <trans-unit id="0f24a8d064b195b6edf9eee27733591a5c27bd20" translate="yes" xml:space="preserve">
          <source>As specified in &lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; may be (but isn't required to be on non-IEEE floating-point platforms) raised by &lt;code&gt;rint&lt;/code&gt; when rounding a non-integer finite value.</source>
          <target state="translated">如&lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling中&lt;/a&gt;指定的那样，当舍入一个非整数有限值时， &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; 可能由 &lt;code&gt;rint&lt;/code&gt; 引发（但不是必须在非IEEE浮点平台上）。</target>
        </trans-unit>
        <trans-unit id="a33a2a6a1dbc72097e5ee50f7c236b5234435165" translate="yes" xml:space="preserve">
          <source>As well as the prefix form:</source>
          <target state="translated">以及前缀形式。</target>
        </trans-unit>
        <trans-unit id="cf5967493a41546d32b0ca92f03818e35ddbf753" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;function_declaration&quot;&gt;function declarations&lt;/a&gt;, if the return type would be cvr-qualified, it is adjusted to its unqualified version for the purpose of constructing the function type.</source>
          <target state="translated">与&lt;a href=&quot;function_declaration&quot;&gt;函数声明一样&lt;/a&gt;，如果返回类型是cvr限定的，则出于构造函数类型的目的，会将其调整为非限定版本。</target>
        </trans-unit>
        <trans-unit id="3a13d3a1b158eacc4ae78930d86fe860ceec91a1" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;function_declaration&quot;&gt;function declarations&lt;/a&gt;, the return type of the function, determined by the type specifier in specifiers-and-qualifiers and possibly modified by the declarator as usual in &lt;a href=&quot;declarations&quot;&gt;declarations&lt;/a&gt;, must be a complete non-array object type or the type &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">与&lt;a href=&quot;function_declaration&quot;&gt;函数声明一样&lt;/a&gt;，该函数的返回类型必须是完整的非数组对象类型，或者是 &lt;code&gt;void&lt;/code&gt; 类型，该函数的返回类型由specifiers-and-qualifier中的类型说明符确定，并且可能由声明者照常在&lt;a href=&quot;declarations&quot;&gt;声明中进行&lt;/a&gt;修改。</target>
        </trans-unit>
        <trans-unit id="931b6f6952da18dd1c23c7c06b62eafdf4a75919" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;function_declaration&quot;&gt;function declarations&lt;/a&gt;, the types of the parameters are adjusted from functions to pointers and from arrays to pointers for the purpose of constructing the function type and the top-level cvr-qualifiers of all parameter types are ignored for the purpose of determining &lt;a href=&quot;compatible_type#Compatible_types&quot;&gt;compatible function type&lt;/a&gt;.</source>
          <target state="translated">与&lt;a href=&quot;function_declaration&quot;&gt;函数声明一样&lt;/a&gt;，为了构造函数类型，从函数到指针，从数组到指针，对参数的类型进行调整，并且为了确定&lt;a href=&quot;compatible_type#Compatible_types&quot;&gt;兼容函数，&lt;/a&gt;将忽略所有参数类型的顶级cvr限定符类型。</target>
        </trans-unit>
        <trans-unit id="79ccd71b90196278405a314330eeaa2631ba1185" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;struct&quot;&gt;struct&lt;/a&gt; or &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt;, a declaration that introduced an enumerated type and one or more enumeration constants may also declare one or more objects of that type or type derived from it.</source>
          <target state="translated">与&lt;a href=&quot;struct&quot;&gt;struct&lt;/a&gt;或&lt;a href=&quot;union&quot;&gt;union一样&lt;/a&gt;，引入枚举类型和一个或多个枚举常量的声明也可以声明该类型或从其派生的一个或多个对象。</target>
        </trans-unit>
        <trans-unit id="437ed49708f86a6f35c86cdb9207ea49adcc2e2c" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;asctime_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;time.h&lt;/code&gt;.</source>
          <target state="translated">如同所有的边界检查功能， &lt;code&gt;asctime_s&lt;/code&gt; 如果仅保证可供 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 被实现，并且如果所述用户定义定义 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 包括之前为整数常数1 &lt;code&gt;time.h&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="7466d344d3f71775f4c9996f0aefd336b865cd97" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;bsearch_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;stdlib.h&lt;/code&gt;.</source>
          <target state="translated">如同所有的边界检查功能， &lt;code&gt;bsearch_s&lt;/code&gt; 只保证是如果可用 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 被实现，并且如果所述用户定义定义 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 为整数常数1包括前 &lt;code&gt;stdlib.h&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="4fc791ea25b5ba32faad862e9c23a50a7c997e69" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;ctime_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;time.h&lt;/code&gt;.</source>
          <target state="translated">如同所有的边界检查功能， &lt;code&gt;ctime_s&lt;/code&gt; 只保证是如果可用 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 被实现，并且如果所述用户定义定义 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 为整数常数1包括前 &lt;code&gt;time.h&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="68c3240515eb99689624b2605905ba8bc7986315" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;fopen_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;stdio.h&lt;/code&gt;.</source>
          <target state="translated">如同所有的边界检查功能， &lt;code&gt;fopen_s&lt;/code&gt; 只保证是如果可用 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 被实现，并且如果所述用户定义定义 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 为整数常数1包括前 &lt;code&gt;stdio.h&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="5a2b6b4c82c23c016f116aa791f39d37f445e46a" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;freopen_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;stdio.h&lt;/code&gt;.</source>
          <target state="translated">如同所有的边界检查功能， &lt;code&gt;freopen_s&lt;/code&gt; 只保证是如果可用 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 被实现，并且如果所述用户定义定义 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 为整数常数1包括前 &lt;code&gt;stdio.h&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="36d2edb3de2b41575170995e94495de51af70c2c" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;getenv_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;stdlib.h&lt;/code&gt;.</source>
          <target state="translated">如同所有的边界检查功能， &lt;code&gt;getenv_s&lt;/code&gt; 只保证是如果可用 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 被实现，并且如果所述用户定义定义 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 为整数常数1包括前 &lt;code&gt;stdlib.h&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="91dfec9c8791e4208d084cc59b7b36777275f675" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;gets_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;stdio.h&lt;/code&gt;.</source>
          <target state="translated">如同所有的边界检查功能， &lt;code&gt;gets_s&lt;/code&gt; 只保证是如果可用 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 被实现，并且如果所述用户定义定义 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 为整数常数1包括前 &lt;code&gt;stdio.h&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="b587147fa6c4a23c653092469c541f0564737fd7" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;gmtime_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;time.h&lt;/code&gt;.</source>
          <target state="translated">如同所有的边界检查功能， &lt;code&gt;gmtime_s&lt;/code&gt; 只保证是如果可用 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 被实现，并且如果所述用户定义定义 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 为整数常数1包括前 &lt;code&gt;time.h&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="1a3089753e59df348badd488426b5efcd28f163e" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;localtime_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;time.h&lt;/code&gt;.</source>
          <target state="translated">如同所有的边界检查功能， &lt;code&gt;localtime_s&lt;/code&gt; 只保证是如果可用 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 被实现，并且如果所述用户定义定义 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 为整数常数1包括前 &lt;code&gt;time.h&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="6ddab0b0f139e7b59eefb4230266da1ed9d87056" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;mbsrtowcs_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;wchar.h&lt;/code&gt;.</source>
          <target state="translated">如同所有的边界检查功能， &lt;code&gt;mbsrtowcs_s&lt;/code&gt; 只保证是如果可用 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 被实现，并且如果所述用户定义定义 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 为整数常数1包括前 &lt;code&gt;wchar.h&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="37428501d369894f1c0e8fe3487182869130402b" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;mbstowcs_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;stdlib.h&lt;/code&gt;.</source>
          <target state="translated">如同所有的边界检查功能， &lt;code&gt;mbstowcs_s&lt;/code&gt; 只保证是如果可用 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 被实现，并且如果所述用户定义定义 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 为整数常数1包括前 &lt;code&gt;stdlib.h&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="484ec756538b4c4710eb92aa17bd6c656a7c5da9" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;printf_s&lt;/code&gt; , &lt;code&gt;fprintf_s&lt;/code&gt;, &lt;code&gt;sprintf_s&lt;/code&gt;, and &lt;code&gt;snprintf_s&lt;/code&gt; are only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;stdio.h&lt;/code&gt;.</source>
          <target state="translated">如同所有的边界检查功能， &lt;code&gt;printf_s&lt;/code&gt; ， &lt;code&gt;fprintf_s&lt;/code&gt; ， &lt;code&gt;sprintf_s&lt;/code&gt; ，和 &lt;code&gt;snprintf_s&lt;/code&gt; 如果仅保证可供 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 被实现，并且如果所述用户定义定义 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 包括之前为整数常数1 &lt;code&gt;stdio.h&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="abea34893c8e6d78d3a467d161201fce0dcd31ca" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;qsort_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;stdlib.h&lt;/code&gt;.</source>
          <target state="translated">如同所有的边界检查功能， &lt;code&gt;qsort_s&lt;/code&gt; 只保证是如果可用 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 被实现，并且如果所述用户定义定义 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 为整数常数1包括前 &lt;code&gt;stdlib.h&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="cfaac44b328f0d9ecaecc16c135720ab79c8b975" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;scanf_s&lt;/code&gt; , &lt;code&gt;fscanf_s&lt;/code&gt;, and &lt;code&gt;sscanf_s&lt;/code&gt; are only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;stdio.h&lt;/code&gt;.</source>
          <target state="translated">如同所有的边界检查功能， &lt;code&gt;scanf_s&lt;/code&gt; ， &lt;code&gt;fscanf_s&lt;/code&gt; ，和 &lt;code&gt;sscanf_s&lt;/code&gt; 如果仅保证可供 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 被实现，并且如果所述用户定义定义 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 包括之前为整数常数1 &lt;code&gt;stdio.h&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="d7a73a8def345c13bbf6d30289221e860585c258" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;tmpnam_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;stdio.h&lt;/code&gt;.</source>
          <target state="translated">如同所有的边界检查功能， &lt;code&gt;tmpnam_s&lt;/code&gt; 如果仅保证可供 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 被实现，并且如果所述用户定义定义 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 为整数常数1包括前 &lt;code&gt;stdio.h&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="918e04c9c4c5035b488768dc881c956dc6d6fce9" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;vprintf_s&lt;/code&gt; , &lt;code&gt;vfprintf_s&lt;/code&gt;, &lt;code&gt;vsprintf_s&lt;/code&gt;, and &lt;code&gt;vsnprintf_s&lt;/code&gt; are only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;stdio.h&lt;/code&gt;.</source>
          <target state="translated">如同所有的边界检查功能， &lt;code&gt;vprintf_s&lt;/code&gt; ， &lt;code&gt;vfprintf_s&lt;/code&gt; ， &lt;code&gt;vsprintf_s&lt;/code&gt; ，和 &lt;code&gt;vsnprintf_s&lt;/code&gt; 如果仅保证可供 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 被实现，并且如果所述用户定义定义 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 为整数常数1包括前 &lt;code&gt;stdio.h&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="073801d18c716edf19a5d56736c3e0cfe5310c1a" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;vscanf_s&lt;/code&gt; , &lt;code&gt;vfscanf_s&lt;/code&gt;, and &lt;code&gt;vsscanf_s&lt;/code&gt; are only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;stdio.h&lt;/code&gt;.</source>
          <target state="translated">如同所有的边界检查功能， &lt;code&gt;vscanf_s&lt;/code&gt; ， &lt;code&gt;vfscanf_s&lt;/code&gt; ，和 &lt;code&gt;vsscanf_s&lt;/code&gt; 如果仅保证可供 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 被实现，并且如果所述用户定义定义 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 包括之前为整数常数1 &lt;code&gt;stdio.h&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="859462c768d6d2e1180f63c1e98789651af7d933" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;vwscanf_s&lt;/code&gt; , &lt;code&gt;vfwscanf_s&lt;/code&gt;, and &lt;code&gt;vswscanf_s&lt;/code&gt; are only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;stdio.h&lt;/code&gt;.</source>
          <target state="translated">如同所有的边界检查功能， &lt;code&gt;vwscanf_s&lt;/code&gt; ， &lt;code&gt;vfwscanf_s&lt;/code&gt; ，和 &lt;code&gt;vswscanf_s&lt;/code&gt; 如果仅保证可供 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 被实现，并且如果所述用户定义定义 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 包括之前为整数常数1 &lt;code&gt;stdio.h&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="f4160e65b4073508722290e386b7ac737418adee" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;wcrtomb_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;wchar.h&lt;/code&gt;.</source>
          <target state="translated">如同所有的边界检查功能， &lt;code&gt;wcrtomb_s&lt;/code&gt; 只保证是如果可用 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 被实现，并且如果所述用户定义定义 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 为整数常数1包括前 &lt;code&gt;wchar.h&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8852dd0c727422973b312a38cfafc412436b854a" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;wcscat_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;wchar.h&lt;/code&gt;.</source>
          <target state="translated">如同所有的边界检查功能， &lt;code&gt;wcscat_s&lt;/code&gt; 只保证是如果可用 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 被实现，并且如果所述用户定义定义 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 为整数常数1包括前 &lt;code&gt;wchar.h&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="94da776eb17b12e2e76b744201263fafce234bf0" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;wcscpy_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;wchar.h&lt;/code&gt;.</source>
          <target state="translated">如同所有的边界检查功能， &lt;code&gt;wcscpy_s&lt;/code&gt; 只保证是如果可用 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 被实现，并且如果所述用户定义定义 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 为整数常数1包括前 &lt;code&gt;wchar.h&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="602e2723ae28915ea4b6c0d0d485677759ec2846" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;wcsncat_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;wchar.h&lt;/code&gt;.</source>
          <target state="translated">如同所有的边界检查功能， &lt;code&gt;wcsncat_s&lt;/code&gt; 只保证是如果可用 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 被实现，并且如果所述用户定义定义 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 为整数常数1包括前 &lt;code&gt;wchar.h&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eb04e05d2e03a1529216895dcf8b417f85fadc7d" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;wcsncpy_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;wchar.h&lt;/code&gt;.</source>
          <target state="translated">如同所有的边界检查功能， &lt;code&gt;wcsncpy_s&lt;/code&gt; 只保证是如果可用 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 被实现，并且如果所述用户定义定义 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 为整数常数1包括前 &lt;code&gt;wchar.h&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="59166256df368db6ea11d9dcca1c76c58f684e8f" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;wcsrtombs_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant &lt;code&gt;1&lt;/code&gt; before including &lt;code&gt;wchar.h&lt;/code&gt;.</source>
          <target state="translated">如同所有的边界检查功能， &lt;code&gt;wcsrtombs_s&lt;/code&gt; 只保证是如果可用 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 被实现，并且如果所述用户定义定义 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 为整数常数 &lt;code&gt;1&lt;/code&gt; 包括前 &lt;code&gt;wchar.h&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="10f1e3f209cb87b74ba077e0b12ebc217f85756f" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;wcstombs_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;stdlib.h&lt;/code&gt;.</source>
          <target state="translated">如同所有的边界检查功能， &lt;code&gt;wcstombs_s&lt;/code&gt; 只保证是如果可用 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 被实现，并且如果所述用户定义定义 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 为整数常数1包括前 &lt;code&gt;stdlib.h&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="197a0ff717c052db762139e2134727533937a435" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;wctomb_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;stdlib.h&lt;/code&gt;.</source>
          <target state="translated">如同所有的边界检查功能， &lt;code&gt;wctomb_s&lt;/code&gt; 只保证是如果可用 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 被实现，并且如果所述用户定义定义 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 为整数常数1包括前 &lt;code&gt;stdlib.h&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="8de73d3e3aed35fe5e7155d1d6d37204911c0756" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;wmemcpy_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;wchar.h&lt;/code&gt;.</source>
          <target state="translated">如同所有的边界检查功能， &lt;code&gt;wmemcpy_s&lt;/code&gt; 只保证是如果可用 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 被实现，并且如果所述用户定义定义 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 为整数常数1包括前 &lt;code&gt;wchar.h&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="78f5af5ac1a7ed15c5c5e17dc8795818a3aa33e2" translate="yes" xml:space="preserve">
          <source>As with all floating-point expressions, the expression &lt;code&gt;(x*y) + z&lt;/code&gt; may be compiled as a fused mutiply-add unless the &lt;a href=&quot;../../preprocessor/impl&quot;&gt;#pragma&lt;/a&gt;&lt;code&gt;STDC FP_CONTRACT&lt;/code&gt; is off.</source>
          <target state="translated">与所有浮点表达式一样，除非关闭&lt;a href=&quot;../../preprocessor/impl&quot;&gt;#pragma &lt;/a&gt; &lt;code&gt;STDC FP_CONTRACT&lt;/code&gt; ,否则可以将表达式 &lt;code&gt;(x*y) + z&lt;/code&gt; 编译为融合多加。</target>
        </trans-unit>
        <trans-unit id="325da3015b4ad8b300bd2748d36c41a38bb66f31" translate="yes" xml:space="preserve">
          <source>As with all other &lt;a href=&quot;initialization&quot;&gt;initialization&lt;/a&gt;, every expression in the initializer list must be a &lt;a href=&quot;constant_expression&quot;&gt;constant expression&lt;/a&gt; when initializing aggregates of static or thread-local(since C11)&lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt;:</source>
          <target state="translated">与所有其他&lt;a href=&quot;initialization&quot;&gt;初始化一样&lt;/a&gt;，初始化静态或线程本地（自C11起）&lt;a href=&quot;storage_duration&quot;&gt;存储持续时间的&lt;/a&gt;集合时，初始化器列表中的每个表达式都必须是一个&lt;a href=&quot;constant_expression&quot;&gt;常量表达式&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="c4829062a1808034ce1d2399df876ce3ea658359" translate="yes" xml:space="preserve">
          <source>As with all other &lt;a href=&quot;initialization&quot;&gt;initialization&lt;/a&gt;, every expression in the initializer list must be a &lt;a href=&quot;constant_expression&quot;&gt;constant expression&lt;/a&gt; when initializing arrays of static or thread-local &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt;:</source>
          <target state="translated">与所有其他&lt;a href=&quot;initialization&quot;&gt;初始化一样&lt;/a&gt;，初始化静态或线程本地&lt;a href=&quot;storage_duration&quot;&gt;存储持续时间&lt;/a&gt;数组时，初始化器列表中的每个表达式都必须是一个&lt;a href=&quot;constant_expression&quot;&gt;常量表达式&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="3d74ed1ea6e40942992fbfb06d0ee0b9763fc886" translate="yes" xml:space="preserve">
          <source>As with all other initializations, expression must be a &lt;a href=&quot;constant_expression&quot;&gt;constant expression&lt;/a&gt; when initializing objects of static or thread-local &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt;.</source>
          <target state="translated">与所有其他初始化一样，在初始化静态或线程本地&lt;a href=&quot;storage_duration&quot;&gt;存储duration的&lt;/a&gt;对象时，expression必须是一个&lt;a href=&quot;constant_expression&quot;&gt;常量表达式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e555bf0a6d0cba4d524cadbdf2533b3abff34b33" translate="yes" xml:space="preserve">
          <source>As with all other selection and iteration statements, the do-while statement establishes &lt;a href=&quot;scope&quot;&gt;block scope&lt;/a&gt;: any identifier introduced in the expression goes out of scope after the statement.</source>
          <target state="translated">与所有其他选择和迭代语句一样，do-while语句建立&lt;a href=&quot;scope&quot;&gt;块作用域&lt;/a&gt;：表达式中引入的任何标识符在该语句之后都超出作用域。</target>
        </trans-unit>
        <trans-unit id="f545ee7b22d4db083dbeb46229553bde0b39d74f" translate="yes" xml:space="preserve">
          <source>As with all other selection and iteration statements, the entire if-statement has its own block scope:</source>
          <target state="translated">与所有其他选择和迭代语句一样,整个if语句有自己的块范围。</target>
        </trans-unit>
        <trans-unit id="e7bfa427f06539b7b10237b67a6680af8d74b410" translate="yes" xml:space="preserve">
          <source>As with all other selection and iteration statements, the for statement establishes &lt;a href=&quot;scope&quot;&gt;block scope&lt;/a&gt;: any identifier introduced in the init_clause, cond_expression, or iteration_expression goes out of scope after the loop_statement.</source>
          <target state="translated">与所有其他选择和迭代语句一样，for语句建立&lt;a href=&quot;scope&quot;&gt;块范围&lt;/a&gt;：在loop_statement之后，init_clause，cond_expression或eration_expression中引入的任何标识符都超出范围。</target>
        </trans-unit>
        <trans-unit id="7c3290e5179ae7df55fad67d5932bc9569640162" translate="yes" xml:space="preserve">
          <source>As with all other selection and iteration statements, the switch statement establishes &lt;a href=&quot;scope&quot;&gt;block scope&lt;/a&gt;: any identifier introduced in the expression goes out of scope after the statement.</source>
          <target state="translated">与所有其他选择和迭代语句一样，switch语句建立&lt;a href=&quot;scope&quot;&gt;块作用域&lt;/a&gt;：表达式中引入的任何标识符在该语句后都超出作用域。</target>
        </trans-unit>
        <trans-unit id="bf1b641a79fe3bd85fdc3087658eae1ee87d7b5c" translate="yes" xml:space="preserve">
          <source>As with all other selection and iteration statements, the while statement establishes &lt;a href=&quot;scope&quot;&gt;block scope&lt;/a&gt;: any identifier introduced in the expression goes out of scope after the statement.</source>
          <target state="translated">与所有其他选择和迭代语句一样，while语句建立&lt;a href=&quot;scope&quot;&gt;块作用域&lt;/a&gt;：表达式中引入的任何标识符在语句之后都超出作用域。</target>
        </trans-unit>
        <trans-unit id="a3219f037624b3a59d32f19972411fe565f772da" translate="yes" xml:space="preserve">
          <source>As with any &lt;a href=&quot;../fenv&quot;&gt;floating-point environment&lt;/a&gt; functionality, rounding is only guaranteed if &lt;code&gt;#pragma STDC FENV_ACCESS ON&lt;/code&gt; is set.</source>
          <target state="translated">与任何&lt;a href=&quot;../fenv&quot;&gt;浮点环境&lt;/a&gt;功能一样，只有在设置了 &lt;code&gt;#pragma STDC FENV_ACCESS ON&lt;/code&gt; 的情况下，才能保证舍入。</target>
        </trans-unit>
        <trans-unit id="6c92fb474ab2bb51f893b5f74babbd3f0c831976" translate="yes" xml:space="preserve">
          <source>As with any pure imaginary number support in C, this macro is only defined if the imaginary numbers are supported.</source>
          <target state="translated">与C语言中的任何纯虚数支持一样,这个宏只有在虚数得到支持的情况下才会被定义。</target>
        </trans-unit>
        <trans-unit id="79bc029ba48a0820eb9af6de0ebd1ea7e6ea9789" translate="yes" xml:space="preserve">
          <source>As-if rule</source>
          <target state="translated">如果规则</target>
        </trans-unit>
        <trans-unit id="49bf55dc112eb3597726ba8ecf785a4fae4cbce0" translate="yes" xml:space="preserve">
          <source>Assertions</source>
          <target state="translated">Assertions</target>
        </trans-unit>
        <trans-unit id="e55df441e8955746182110c3946288f381520e83" translate="yes" xml:space="preserve">
          <source>Assignment</source>
          <target state="translated">Assignment</target>
        </trans-unit>
        <trans-unit id="18d0c3fe9dc939e8b90006e867d3849538ad2f89" translate="yes" xml:space="preserve">
          <source>Assignment also returns the same value as what was stored in &lt;code&gt;lhs&lt;/code&gt; (so that expressions such as &lt;code&gt;a = b = c&lt;/code&gt; are possible). The &lt;a href=&quot;value_category&quot;&gt;value category&lt;/a&gt; of the assignment operator is non-lvalue (so that expressions such as &lt;code&gt;(a=b)=c&lt;/code&gt; are invalid).</source>
          <target state="translated">赋值还返回与 &lt;code&gt;lhs&lt;/code&gt; 中存储的值相同的值（以便可以使用诸如 &lt;code&gt;a = b = c&lt;/code&gt; 表达式）。赋值运算符的&lt;a href=&quot;value_category&quot;&gt;值类别&lt;/a&gt;为非左值（因此 &lt;code&gt;(a=b)=c&lt;/code&gt; 之类的表达式无效）。</target>
        </trans-unit>
        <trans-unit id="a5b50d74ba4665e5019dfafa81c1cee577573309" translate="yes" xml:space="preserve">
          <source>Assignment and compound assignment operators are binary operators that modify the variable to their left using the value to their right.</source>
          <target state="translated">赋值和复合赋值运算符是二元运算符,利用其右边的值修改其左边的变量。</target>
        </trans-unit>
        <trans-unit id="fc3a7306a4dbd9aaf7c8e7df511d8c165f52fd3d" translate="yes" xml:space="preserve">
          <source>Assignment by bitwise AND, XOR, and OR</source>
          <target state="translated">按位 AND、XOR 和 OR 进行分配。</target>
        </trans-unit>
        <trans-unit id="e5c86c40b5df7019866344018e45e57f50e118be" translate="yes" xml:space="preserve">
          <source>Assignment by bitwise left shift and right shift</source>
          <target state="translated">按位左移和右移进行赋值</target>
        </trans-unit>
        <trans-unit id="bea5586663c5a711fbc4d3e72c59f91bc6283914" translate="yes" xml:space="preserve">
          <source>Assignment by product, quotient, and remainder</source>
          <target state="translated">按积、商和余数进行分配</target>
        </trans-unit>
        <trans-unit id="bc417bc1271d1dd6a46931fd1dfa61093c858524" translate="yes" xml:space="preserve">
          <source>Assignment by sum and difference</source>
          <target state="translated">按总和和差额分配</target>
        </trans-unit>
        <trans-unit id="171497ff060aefbcfe056d741c42de9e42533588" translate="yes" xml:space="preserve">
          <source>Assignment from one restricted pointer to another is undefined behavior, except when assigning from a pointer to an object in some outer block to a pointer in some inner block (including using a restricted pointer argument when calling a function with a restricted pointer parameter) or when returning from a function (and otherwise when the block of the from-pointer ended):</source>
          <target state="translated">从一个受限指针赋值到另一个受限指针是未定义的行为,除非从某个外块中的对象的指针赋值到某个内块中的指针(包括在调用具有受限指针参数的函数时使用受限指针参数)或从函数返回时(否则当from-pointer的块结束时)。</target>
        </trans-unit>
        <trans-unit id="aa098245c1ec6b3b4a9cec4ec49f68bc2b3dc905" translate="yes" xml:space="preserve">
          <source>Assignment operators</source>
          <target state="translated">赋值运算符</target>
        </trans-unit>
        <trans-unit id="83ac53a63cca418f24852c024f95f35335391074" translate="yes" xml:space="preserve">
          <source>Assignment operators' left operands must be unary (level-2 non-cast) expressions. This rule grammatically forbids some expressions that would be semantically invalid anyway. Many compilers ignore this rule and detect the invalidity semantically. For example, &lt;code&gt;e = a &amp;lt; d ? a++ : a = d&lt;/code&gt; is an expression that cannot be parsed because of this rule. However, many compilers ignore this rule and parse it as &lt;code&gt;e = ( ((a &amp;lt; d) ? (a++) : a) = d )&lt;/code&gt;, and then give an error because it is semantically invalid.</source>
          <target state="translated">赋值运算符的左操作数必须是一元（二级非强制）表达式。该规则在语法上禁止某些在语义上仍然无效的表达式。许多编译器会忽略此规则，并从语义上检测无效性。例如， &lt;code&gt;e = a &amp;lt; d ? a++ : a = d&lt;/code&gt; 是由于该规则而无法解析的表达式。但是，许多编译器会忽略此规则，并将其解析为 &lt;code&gt;e = ( ((a &amp;lt; d) ? (a++) : a) = d )&lt;/code&gt; ，然后给出错误，因为它在语义上无效。</target>
        </trans-unit>
        <trans-unit id="77dd21d24ad4cb9c785289515583c49d1df5693e" translate="yes" xml:space="preserve">
          <source>Assignment performs &lt;a href=&quot;conversion&quot;&gt;implicit conversion&lt;/a&gt; from the value of rhs to the type of rhs and then replaces the value in the object designated by lhs with the converted value of rhs.</source>
          <target state="translated">赋值执行从rhs的值到rhs类型的&lt;a href=&quot;conversion&quot;&gt;隐式转换&lt;/a&gt;，然后用转换后的rhs值替换lhs指定的对象中的值。</target>
        </trans-unit>
        <trans-unit id="269f718e42738bd37518148d39e5b7196b62a1ed" translate="yes" xml:space="preserve">
          <source>Assignment strips extra range and precision from floating-point expressions (see &lt;code&gt;&lt;a href=&quot;../types/limits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">赋值会从浮点表达式中 &lt;code&gt;&lt;a href=&quot;../types/limits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt; 额外的范围和精度（请参见FLT_EVAL_METHOD）。</target>
        </trans-unit>
        <trans-unit id="d20b5a26a1cdf631954b50a5206246dff93d9c8a" translate="yes" xml:space="preserve">
          <source>Associativity</source>
          <target state="translated">Associativity</target>
        </trans-unit>
        <trans-unit id="f4d8655658394fa66d40386dc42cf98fdf4372dd" translate="yes" xml:space="preserve">
          <source>Associativity specification is redundant for unary operators and is only shown for completeness: unary prefix operators always associate right-to-left (&lt;code&gt;sizeof ++*p&lt;/code&gt; is &lt;code&gt;sizeof(++(*p))&lt;/code&gt;) and unary postfix operators always associate left-to-right (&lt;code&gt;a[1][2]++&lt;/code&gt; is &lt;code&gt;((a[1])[2])++&lt;/code&gt;). Note that the associativity is meaningful for member access operators, even though they are grouped with unary postfix operators: &lt;code&gt;a.b++&lt;/code&gt; is parsed &lt;code&gt;(a.b)++&lt;/code&gt; and not &lt;code&gt;a.(b++)&lt;/code&gt;.</source>
          <target state="translated">关联性规范对于一元运算符来说是多余的，并且仅出于完整性目的而显示：一元前缀运算符始终从右到左关联（ &lt;code&gt;sizeof ++*p&lt;/code&gt; 是 &lt;code&gt;sizeof(++(*p))&lt;/code&gt; ），一元后缀运算符总是从左到左关联。 -right（ &lt;code&gt;a[1][2]++&lt;/code&gt; 是 &lt;code&gt;((a[1])[2])++&lt;/code&gt; ）。请注意，即使成员访问运算符与一元后缀运算符组合在一起，关联性也很有意义： &lt;code&gt;a.b++&lt;/code&gt; 被解析为 &lt;code&gt;(a.b)++&lt;/code&gt; 而不是 &lt;code&gt;a.(b++)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4154e96428077efddaaf47a2b96af21e7a346bb0" translate="yes" xml:space="preserve">
          <source>At the &lt;a href=&quot;operator_other#Function_call&quot;&gt;function call&lt;/a&gt;, each argument that is a part of the variable argument list undergoes special implicit conversions known as &lt;a href=&quot;conversion#Default_argument_promotions&quot;&gt;default argument promotions&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;operator_other#Function_call&quot;&gt;函数调用时&lt;/a&gt;，作为变量参数列表一部分的每个参数都经过特殊的隐式转换，称为&lt;a href=&quot;conversion#Default_argument_promotions&quot;&gt;默认参数提升&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6a4ba3822726fee4dc63d69beec4022ac36809bf" translate="yes" xml:space="preserve">
          <source>At the point of lookup, the name space of an identifier is determined by the manner in which it is used:</source>
          <target state="translated">在查询时,标识符的名称空间是由其使用方式决定的。</target>
        </trans-unit>
        <trans-unit id="78f6940e1dbc39015dcd262184b3438c2502859e" translate="yes" xml:space="preserve">
          <source>At the top level of a &lt;a href=&quot;translation_phases&quot;&gt;translation unit&lt;/a&gt; (that is, a source file with all the #includes after the preprocessor), every C program is a sequence of &lt;a href=&quot;declarations&quot;&gt;declarations&lt;/a&gt;, which declare functions and objects with &lt;a href=&quot;storage_duration&quot;&gt;external linkage&lt;/a&gt;. These declarations are known as</source>
          <target state="translated">在&lt;a href=&quot;translation_phases&quot;&gt;翻译单元&lt;/a&gt;的顶层（即在预处理程序之后带有所有#include的源文件），每个C程序都是一系列&lt;a href=&quot;declarations&quot;&gt;声明&lt;/a&gt;，这些声明使用&lt;a href=&quot;storage_duration&quot;&gt;外部链接&lt;/a&gt;声明函数和对象。这些声明称为</target>
        </trans-unit>
        <trans-unit id="fb34ad6782840b3609292d56d50524837de11852" translate="yes" xml:space="preserve">
          <source>Atomic operations</source>
          <target state="translated">原子操作</target>
        </trans-unit>
        <trans-unit id="ec45a74e461d6d1f9a6d6860119c9137a6fed5b2" translate="yes" xml:space="preserve">
          <source>Atomic operations library</source>
          <target state="translated">原子运算库</target>
        </trans-unit>
        <trans-unit id="ac1cfc02a52dba8b178a48b4597760d28fb77ccd" translate="yes" xml:space="preserve">
          <source>Atomic operations tagged &lt;code&gt;memory_order_relaxed&lt;/code&gt; are not synchronization operations; they do not impose an order among concurrent memory accesses. They only guarantee atomicity and modification order consistency.</source>
          <target state="translated">标记为 &lt;code&gt;memory_order_relaxed&lt;/code&gt; 的原子操作不是同步操作。它们不会在并发内存访问之间强加顺序。它们仅保证原子性和修改顺序的一致性。</target>
        </trans-unit>
        <trans-unit id="4f6d4f2c68a571824e3f43d98c75cbda9d541c52" translate="yes" xml:space="preserve">
          <source>Atomic operations tagged &lt;code&gt;memory_order_seq_cst&lt;/code&gt; not only order memory the same way as release/acquire ordering (everything that</source>
          <target state="translated">标记为 &lt;code&gt;memory_order_seq_cst&lt;/code&gt; 的原子操作不仅以与发布/获取排序相同的方式对内存进行排序（</target>
        </trans-unit>
        <trans-unit id="e93772d4bf7c4f3b7583aab6a0265189369c6fdd" translate="yes" xml:space="preserve">
          <source>Atomic properties are only meaningful for &lt;a href=&quot;value_category&quot;&gt;lvalue expressions&lt;/a&gt;. Lvalue-to-rvalue conversion (which models a memory read from an atomic location to a CPU register) strips atomicity along with other qualifiers.</source>
          <target state="translated">原子属性仅对&lt;a href=&quot;value_category&quot;&gt;左值表达式&lt;/a&gt;有意义。左值到右值转换（模拟从原子位置到CPU寄存器的内存读取）将原子性与其他限定符一起剥夺。</target>
        </trans-unit>
        <trans-unit id="6bd53298c2672a3d3501c1b3d668970f3f55e051" translate="yes" xml:space="preserve">
          <source>Atomic types</source>
          <target state="translated">原子类型</target>
        </trans-unit>
        <trans-unit id="389fbb07de335e1a903a5217f5d069d302e09807" translate="yes" xml:space="preserve">
          <source>Atomically changes the state of a &lt;code&gt;atomic_flag&lt;/code&gt; pointed to by &lt;code&gt;obj&lt;/code&gt; to clear (&lt;code&gt;false&lt;/code&gt;). The first version orders memory accesses according to &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt;, the second version orders memory accesses according to &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">以原子方式将 &lt;code&gt;obj&lt;/code&gt; 指向的 &lt;code&gt;atomic_flag&lt;/code&gt; 的状态更改为clear（ &lt;code&gt;false&lt;/code&gt; ）。第一个版本根据 &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt; 对内存访问进行排序，第二个版本根据 &lt;code&gt;order&lt;/code&gt; 对内存访问进行排序。</target>
        </trans-unit>
        <trans-unit id="c3718979e2b9ad32f9d807868c9664bc02a4706d" translate="yes" xml:space="preserve">
          <source>Atomically changes the state of a &lt;code&gt;atomic_flag&lt;/code&gt; pointed to by &lt;code&gt;obj&lt;/code&gt; to set (&lt;code&gt;true&lt;/code&gt;) and returns the previous value. The first version orders memory accesses according to &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt;, the second version orders memory accesses according to &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">以原子方式将 &lt;code&gt;obj&lt;/code&gt; 指向的 &lt;code&gt;atomic_flag&lt;/code&gt; 的状态更改为set（ &lt;code&gt;true&lt;/code&gt; ），并返回先前的值。第一个版本根据 &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt; 对内存访问进行排序，第二个版本根据 &lt;code&gt;order&lt;/code&gt; 对内存访问进行排序。</target>
        </trans-unit>
        <trans-unit id="685cd023c278ffbba93acf26685c796a80ffd6b1" translate="yes" xml:space="preserve">
          <source>Atomically compares the contents of memory pointed to by &lt;code&gt;obj&lt;/code&gt; with the contents of memory pointed to by &lt;code&gt;expected&lt;/code&gt;, and if those are bitwise equal, replaces the former with &lt;code&gt;desired&lt;/code&gt; (performs read-modify-write operation). Otherwise, loads the actual contents of memory pointed to by &lt;code&gt;obj&lt;/code&gt; into &lt;code&gt;*expected&lt;/code&gt; (performs load operation).</source>
          <target state="translated">原子进行比较的存储器中的内容所指向的 &lt;code&gt;obj&lt;/code&gt; 与存储器所指向的内容的 &lt;code&gt;expected&lt;/code&gt; ，如果这些是按位相等，替换前者 &lt;code&gt;desired&lt;/code&gt; （执行读-修改-写操作）。否则，将 &lt;code&gt;obj&lt;/code&gt; 指向的内存的实际内容加载到 &lt;code&gt;*expected&lt;/code&gt; 中（执行加载操作）。</target>
        </trans-unit>
        <trans-unit id="df0174a476c2f8736237beae3e21b905656296c6" translate="yes" xml:space="preserve">
          <source>Atomically loads and returns the current value of the atomic variable pointed to by &lt;code&gt;obj&lt;/code&gt;. The operation is atomic read operation.</source>
          <target state="translated">以原子方式加载并返回 &lt;code&gt;obj&lt;/code&gt; 指向的原子变量的当前值。该操作是原子读取操作。</target>
        </trans-unit>
        <trans-unit id="4dc9ad67c097c1b7227ead6a0ab401fe229b6c4e" translate="yes" xml:space="preserve">
          <source>Atomically replaces the value of the atomic variable pointed to by &lt;code&gt;obj&lt;/code&gt; with &lt;code&gt;desired&lt;/code&gt;. The operation is atomic write operation.</source>
          <target state="translated">原子取代由指向的原子变量的值 &lt;code&gt;obj&lt;/code&gt; 与 &lt;code&gt;desired&lt;/code&gt; 。该操作是原子写操作。</target>
        </trans-unit>
        <trans-unit id="e9a886ccb54785d3678b91318357ed8aa2ecb513" translate="yes" xml:space="preserve">
          <source>Atomically replaces the value pointed by &lt;code&gt;obj&lt;/code&gt; with &lt;code&gt;desired&lt;/code&gt; and returns the value &lt;code&gt;obj&lt;/code&gt; held previously. The operation is read-modify-write operation. The first version orders memory accesses according to &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt;, the second version orders memory accesses according to &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">以原子取代了价值指向的 &lt;code&gt;obj&lt;/code&gt; 与 &lt;code&gt;desired&lt;/code&gt; ，并返回值 &lt;code&gt;obj&lt;/code&gt; 之前举行。该操作是读-修改-写操作。第一个版本根据 &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt; 对内存访问进行排序，第二个版本根据 &lt;code&gt;order&lt;/code&gt; 对内存访问进行排序。</target>
        </trans-unit>
        <trans-unit id="0d0a6f30b29e80519fc1b75f03c103695e80bc2f" translate="yes" xml:space="preserve">
          <source>Atomically replaces the value pointed by &lt;code&gt;obj&lt;/code&gt; with the result of addition of &lt;code&gt;arg&lt;/code&gt; to the old value of &lt;code&gt;obj&lt;/code&gt;, and returns the value &lt;code&gt;obj&lt;/code&gt; held previously. The operation is read-modify-write operation. The first version orders memory accesses according to &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt;, the second version orders memory accesses according to &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">原子取代的价值指向的 &lt;code&gt;obj&lt;/code&gt; 与另外的结果 &lt;code&gt;arg&lt;/code&gt; 来的旧值 &lt;code&gt;obj&lt;/code&gt; ，并返回值 &lt;code&gt;obj&lt;/code&gt; 之前举行。该操作是读-修改-写操作。第一个版本根据 &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt; 对内存访问进行排序，第二个版本根据 &lt;code&gt;order&lt;/code&gt; 对内存访问进行排序。</target>
        </trans-unit>
        <trans-unit id="720b64c8705ff9f12adca3f0ac1074a4d0557da4" translate="yes" xml:space="preserve">
          <source>Atomically replaces the value pointed by &lt;code&gt;obj&lt;/code&gt; with the result of bitwise AND between the old value of &lt;code&gt;obj&lt;/code&gt; and &lt;code&gt;arg&lt;/code&gt;, and returns the value &lt;code&gt;obj&lt;/code&gt; held previously. The operation is read-modify-write operation. The first version orders memory accesses according to &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt;, the second version orders memory accesses according to &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">原子取代的价值指向的 &lt;code&gt;obj&lt;/code&gt; 按位的结果和旧值之间 &lt;code&gt;obj&lt;/code&gt; 和 &lt;code&gt;arg&lt;/code&gt; ，和值返回 &lt;code&gt;obj&lt;/code&gt; 之前举行。该操作是读-修改-写操作。第一个版本根据 &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt; 对内存访问进行排序，第二个版本根据 &lt;code&gt;order&lt;/code&gt; 对内存访问进行排序。</target>
        </trans-unit>
        <trans-unit id="783b0416c25a72626756ad2801575cf30aa6b7c4" translate="yes" xml:space="preserve">
          <source>Atomically replaces the value pointed by &lt;code&gt;obj&lt;/code&gt; with the result of bitwise OR between the old value of &lt;code&gt;obj&lt;/code&gt; and &lt;code&gt;arg&lt;/code&gt;, and returns the value &lt;code&gt;obj&lt;/code&gt; held previously. The operation is read-modify-write operation. The first version orders memory accesses according to &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt;, the second version orders memory accesses according to &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">原子取代的价值指向的 &lt;code&gt;obj&lt;/code&gt; 按位或的结果的旧值之间 &lt;code&gt;obj&lt;/code&gt; 和 &lt;code&gt;arg&lt;/code&gt; ，和值返回 &lt;code&gt;obj&lt;/code&gt; 之前举行。该操作是读-修改-写操作。第一个版本根据 &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt; 对内存访问进行排序，第二个版本根据 &lt;code&gt;order&lt;/code&gt; 对内存访问进行排序。</target>
        </trans-unit>
        <trans-unit id="bdda98d653801da68179d56534d72790cd58233c" translate="yes" xml:space="preserve">
          <source>Atomically replaces the value pointed by &lt;code&gt;obj&lt;/code&gt; with the result of bitwise XOR between the old value of &lt;code&gt;obj&lt;/code&gt; and &lt;code&gt;arg&lt;/code&gt;, and returns the value &lt;code&gt;obj&lt;/code&gt; held previously. The operation is read-modify-write operation. The first version orders memory accesses according to &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt;, the second version orders memory accesses according to &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">用 &lt;code&gt;obj&lt;/code&gt; 的旧值与 &lt;code&gt;obj&lt;/code&gt; 的旧值和 &lt;code&gt;arg&lt;/code&gt; 之间的按位XOR结果原子替换obj指向的值，并返回先前保存的 &lt;code&gt;obj&lt;/code&gt; 值。该操作是读-修改-写操作。第一个版本根据 &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt; 对内存访问进行排序，第二个版本根据 &lt;code&gt;order&lt;/code&gt; 对内存访问进行排序。</target>
        </trans-unit>
        <trans-unit id="7460f1e114e6e22f0145a7afeb4678b75fefd6c5" translate="yes" xml:space="preserve">
          <source>Atomically replaces the value pointed by &lt;code&gt;obj&lt;/code&gt; with the result of subtraction of &lt;code&gt;arg&lt;/code&gt; from the old value of &lt;code&gt;obj&lt;/code&gt;, and returns the value &lt;code&gt;obj&lt;/code&gt; held previously. The operation is read-modify-write operation. The first version orders memory accesses according to &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt;, the second version orders memory accesses according to &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">原子取代的价值指向的 &lt;code&gt;obj&lt;/code&gt; 与减法的结果 &lt;code&gt;arg&lt;/code&gt; 从旧值 &lt;code&gt;obj&lt;/code&gt; ，并返回值 &lt;code&gt;obj&lt;/code&gt; 之前举行。该操作是读-修改-写操作。第一个版本根据 &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt; 对内存访问进行排序，第二个版本根据 &lt;code&gt;order&lt;/code&gt; 对内存访问进行排序。</target>
        </trans-unit>
        <trans-unit id="a07f5da57143cfac7db707b777023caeb735d1c3" translate="yes" xml:space="preserve">
          <source>Atomically unlocks the mutex pointed to by &lt;code&gt;mutex&lt;/code&gt; and blocks on the condition variable pointed to by &lt;code&gt;cond&lt;/code&gt; until the thread is signalled by &lt;code&gt;&lt;a href=&quot;cnd_signal&quot;&gt;cnd_signal&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;cnd_broadcast&quot;&gt;cnd_broadcast&lt;/a&gt;&lt;/code&gt;, or until a spurious wake-up occurs. The mutex is locked again before the function returns.</source>
          <target state="translated">以原子方式解锁互斥锁所指向的 &lt;code&gt;mutex&lt;/code&gt; 并在 &lt;code&gt;cond&lt;/code&gt; 所指向的条件变量上进行阻塞，直到线程由 &lt;code&gt;&lt;a href=&quot;cnd_signal&quot;&gt;cnd_signal&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;cnd_broadcast&quot;&gt;cnd_broadcast&lt;/a&gt;&lt;/code&gt; 发出信号，或者直到发生虚假唤醒为止。该互斥锁在函数返回之前再次被锁定。</target>
        </trans-unit>
        <trans-unit id="ddabf926a852b8875d5dc026bfa320aee942ddb7" translate="yes" xml:space="preserve">
          <source>Atomically unlocks the mutex pointed to by &lt;code&gt;mutex&lt;/code&gt; and blocks on the condition variable pointed to by &lt;code&gt;cond&lt;/code&gt; until the thread is signalled by &lt;code&gt;&lt;a href=&quot;cnd_signal&quot;&gt;cnd_signal&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;cnd_broadcast&quot;&gt;cnd_broadcast&lt;/a&gt;&lt;/code&gt;, or until the &lt;code&gt;TIME_UTC&lt;/code&gt; based time point pointed to by &lt;code&gt;time_point&lt;/code&gt; has been reached, or until a spurious wake-up occurs. The mutex is locked again before the function returns.</source>
          <target state="translated">原子解锁互斥量指向的 &lt;code&gt;mutex&lt;/code&gt; 和块上的条件变量指向 &lt;code&gt;cond&lt;/code&gt; 直到线程是通过用信号通知 &lt;code&gt;&lt;a href=&quot;cnd_signal&quot;&gt;cnd_signal&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;cnd_broadcast&quot;&gt;cnd_broadcast&lt;/a&gt;&lt;/code&gt; ，或直到 &lt;code&gt;TIME_UTC&lt;/code&gt; 基于时间点指向 &lt;code&gt;time_point&lt;/code&gt; 已经到达，或者直到虚假唤醒发生。该互斥锁在函数返回之前再次被锁定。</target>
        </trans-unit>
        <trans-unit id="baca3810d2cde4b7e1025b84062248c5223beff5" translate="yes" xml:space="preserve">
          <source>Attempts to clear the floating-point exceptions that are listed in the bitmask argument &lt;code&gt;excepts&lt;/code&gt;, which is a bitwise OR of the &lt;a href=&quot;fe_exceptions&quot;&gt;floating point exception macros&lt;/a&gt;.</source>
          <target state="translated">尝试以清除在掩码参数中列出的浮点异常 &lt;code&gt;excepts&lt;/code&gt; ，这是一个按位的OR &lt;a href=&quot;fe_exceptions&quot;&gt;浮点异常宏&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="80ba342b8785a08804a333bbfedec341d6d1c9c0" translate="yes" xml:space="preserve">
          <source>Attempts to raise all floating point exceptions listed in &lt;code&gt;excepts&lt;/code&gt; (a bitwise OR of the &lt;a href=&quot;fe_exceptions&quot;&gt;floating point exception macros&lt;/a&gt;). If one of the exceptions is &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_OVERFLOW&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_UNDERFLOW&lt;/a&gt;&lt;/code&gt;, this function may additionally raise &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt;. The order in which the exceptions are raised is unspecified, except that &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_OVERFLOW&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_UNDERFLOW&lt;/a&gt;&lt;/code&gt; are always raised before &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">试养中列出的所有浮点异常 &lt;code&gt;excepts&lt;/code&gt; （或按位&lt;a href=&quot;fe_exceptions&quot;&gt;浮点异常宏&lt;/a&gt;）。如果异常之一是 &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_OVERFLOW&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_UNDERFLOW&lt;/a&gt;&lt;/code&gt; ，则此函数可能会另外引发 &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; 。其中异常升高的顺序是不确定的，不同之处在于 &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_OVERFLOW&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_UNDERFLOW&lt;/a&gt;&lt;/code&gt; 之前总是提出 &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fc28f53619db61ee68c4c2b6467d93002c47863a" translate="yes" xml:space="preserve">
          <source>B and A appears before Y in the Single Total Order</source>
          <target state="translated">B和A出现在单项总排序中的Y之前。</target>
        </trans-unit>
        <trans-unit id="403422f66cba2adadb0da593596292864fb30e29" translate="yes" xml:space="preserve">
          <source>B within thread 1 and C is</source>
          <target state="translated">B在螺纹1内,C是</target>
        </trans-unit>
        <trans-unit id="4e54499211164f4b65d4e8324b3d4ca2593386d6" translate="yes" xml:space="preserve">
          <source>B, and X appears before Y in the Single Total Order, then B observes either:</source>
          <target state="translated">B,且X出现在Y之前的单总顺序中,那么B观察到任何一个。</target>
        </trans-unit>
        <trans-unit id="45e5662cbbb3c35284b81863cd8050953ac79093" translate="yes" xml:space="preserve">
          <source>B, and X appears before Y in the Single Total Order.</source>
          <target state="translated">B,单总顺序中X出现在Y之前。</target>
        </trans-unit>
        <trans-unit id="b23fad0d216b95f70509ee04aeb30c3631070eb7" translate="yes" xml:space="preserve">
          <source>B, then B observes one of the following:</source>
          <target state="translated">B,则B观察到下列情况之一。</target>
        </trans-unit>
        <trans-unit id="b5eb64aad8ea6fe11cd7f656c010af32479eca9f" translate="yes" xml:space="preserve">
          <source>B.2 Complex &amp;lt;complex.h&amp;gt; (p: 419-420)</source>
          <target state="translated">B.2复合物&amp;lt;complex.h&amp;gt;（p：419-420）</target>
        </trans-unit>
        <trans-unit id="24529c2b713b938df14dfb7e1f8995742508e674" translate="yes" xml:space="preserve">
          <source>B.2 Complex &amp;lt;complex.h&amp;gt; (p: 475-477)</source>
          <target state="translated">B.2复合物&amp;lt;complex.h&amp;gt;（p：475-477）</target>
        </trans-unit>
        <trans-unit id="6909406a48bd13f476c9416147defba89909eee5" translate="yes" xml:space="preserve">
          <source>BUFSIZ</source>
          <target state="translated">BUFSIZ</target>
        </trans-unit>
        <trans-unit id="e4e7ae591b0abd861a75d3fa39a7cab907d2a5c8" translate="yes" xml:space="preserve">
          <source>Basic concepts</source>
          <target state="translated">基本概念</target>
        </trans-unit>
        <trans-unit id="beb8cd5e0f8e7a06f8d36dc83c4364f7f79078fa" translate="yes" xml:space="preserve">
          <source>Basic operations</source>
          <target state="translated">基本操作</target>
        </trans-unit>
        <trans-unit id="3fc431b29bb2c2516db706b2f480a558166eba6d" translate="yes" xml:space="preserve">
          <source>Basic types</source>
          <target state="translated">基本类型</target>
        </trans-unit>
        <trans-unit id="72e7594e1a0833654a97aa88a5c1fd93e77d5daa" translate="yes" xml:space="preserve">
          <source>Because &lt;a href=&quot;compatible_type#Compatible_types&quot;&gt;compatibility of function types&lt;/a&gt; ignores top-level qualifiers of the function parameters, pointers to functions whose parameters only differ in their top-level qualifiers are interchangeable:</source>
          <target state="translated">由于&lt;a href=&quot;compatible_type#Compatible_types&quot;&gt;函数类型的兼容性会&lt;/a&gt;忽略函数参数的顶级限定符，因此其参数仅在其顶级限定符中不同的函数的指针可以互换：</target>
        </trans-unit>
        <trans-unit id="a4b1b6fcc1d9042bd28e210a0d53c1bd7a9ab8da" translate="yes" xml:space="preserve">
          <source>Because &lt;a href=&quot;const&quot;&gt;const&lt;/a&gt;, &lt;a href=&quot;volatile&quot;&gt;volatile&lt;/a&gt;, &lt;a href=&quot;restrict&quot;&gt;restrict&lt;/a&gt;, and &lt;a href=&quot;atomic&quot;&gt;atomic&lt;/a&gt; qualifiers have effect on &lt;a href=&quot;value_category&quot;&gt;lvalues only&lt;/a&gt;, a cast to a cvr-qualified or atomic type is exactly equivalent to the cast to the corresponding unqualified type.</source>
          <target state="translated">因为&lt;a href=&quot;const&quot;&gt;常量&lt;/a&gt;，&lt;a href=&quot;volatile&quot;&gt;易失性&lt;/a&gt;，&lt;a href=&quot;restrict&quot;&gt;限制&lt;/a&gt;，和&lt;a href=&quot;atomic&quot;&gt;原子&lt;/a&gt;限定符对效果&lt;a href=&quot;value_category&quot;&gt;的左值只&lt;/a&gt;，流延到一个CVR-合格或原子类型是完全等同于铸造成相应的非限定类型。</target>
        </trans-unit>
        <trans-unit id="09d7dc408004444ec94c2fabf4134d0cd224a49d" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;setlocale&lt;/code&gt; modifies global state which affects execution of locale-dependent functions, it is undefined behavior to call it from one thread, while another thread is executing any of the following functions: &lt;code&gt;&lt;a href=&quot;../io/fprintf&quot;&gt;fprintf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/isprint&quot;&gt;isprint&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswdigit&quot;&gt;iswdigit&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;localeconv&quot;&gt;localeconv&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/tolower&quot;&gt;tolower&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../io/fscanf&quot;&gt;fscanf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/ispunct&quot;&gt;ispunct&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswgraph&quot;&gt;iswgraph&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/multibyte/mblen&quot;&gt;mblen&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/toupper&quot;&gt;toupper&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/isalnum&quot;&gt;isalnum&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/isspace&quot;&gt;isspace&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswlower&quot;&gt;iswlower&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/multibyte/mbstowcs&quot;&gt;mbstowcs&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/towlower&quot;&gt;towlower&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/isalpha&quot;&gt;isalpha&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/isupper&quot;&gt;isupper&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswprint&quot;&gt;iswprint&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/multibyte/mbtowc&quot;&gt;mbtowc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/towupper&quot;&gt;towupper&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/isblank&quot;&gt;isblank&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswalnum&quot;&gt;iswalnum&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswpunct&quot;&gt;iswpunct&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;setlocale&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/wcscoll&quot;&gt;wcscoll&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/iscntrl&quot;&gt;iscntrl&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswalpha&quot;&gt;iswalpha&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswspace&quot;&gt;iswspace&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/strcoll&quot;&gt;strcoll&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/wcstof&quot;&gt;wcstod&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/isdigit&quot;&gt;isdigit&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswblank&quot;&gt;iswblank&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswupper&quot;&gt;iswupper&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/strerror&quot;&gt;strerror&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/multibyte/wcstombs&quot;&gt;wcstombs&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/isgraph&quot;&gt;isgraph&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswcntrl&quot;&gt;iswcntrl&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswxdigit&quot;&gt;iswxdigit&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/strtof&quot;&gt;strtod&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/wcsxfrm&quot;&gt;wcsxfrm&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/islower&quot;&gt;islower&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswctype&quot;&gt;iswctype&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/isxdigit&quot;&gt;isxdigit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">因为 &lt;code&gt;setlocale&lt;/code&gt; 会修改全局状态，这会影响与语言环境相关的函数的执行，所以从一个线程调用它是未定义的行为，而另一个线程正在执行以下任何函数： &lt;code&gt;&lt;a href=&quot;../io/fprintf&quot;&gt;fprintf&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../string/byte/isprint&quot;&gt;isprint&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../string/wide/iswdigit&quot;&gt;iswdigit&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;localeconv&quot;&gt;localeconv&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../string/byte/tolower&quot;&gt;tolower&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../io/fscanf&quot;&gt;fscanf&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../string/byte/ispunct&quot;&gt;ispunct&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../string/wide/iswgraph&quot;&gt;iswgraph&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../string/multibyte/mblen&quot;&gt;mblen&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../string/byte/toupper&quot;&gt;toupper&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../string/byte/isalnum&quot;&gt;isalnum&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../string/byte/isspace&quot;&gt;isspace&lt;/a&gt;&lt;/code&gt; 为， &lt;code&gt;&lt;a href=&quot;../string/wide/iswlower&quot;&gt;iswlower&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../string/multibyte/mbstowcs&quot;&gt;mbstowcs&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../string/wide/towlower&quot;&gt;towlower&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../string/byte/isalpha&quot;&gt;isalpha&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../string/byte/isupper&quot;&gt;isupper&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../string/wide/iswprint&quot;&gt;iswprint&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../string/multibyte/mbtowc&quot;&gt;mbtowc&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../string/wide/towupper&quot;&gt;towupper&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../string/byte/isblank&quot;&gt;isblank&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../string/wide/iswalnum&quot;&gt;iswalnum&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../string/wide/iswpunct&quot;&gt;iswpunct&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;setlocale&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../string/wide/wcscoll&quot;&gt;wcscoll&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../string/byte/iscntrl&quot;&gt;iscntrl&lt;/a&gt;&lt;/code&gt; 判断， &lt;code&gt;&lt;a href=&quot;../string/wide/iswalpha&quot;&gt;iswalpha&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../string/wide/iswspace&quot;&gt;iswspace&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../string/byte/strcoll&quot;&gt;strcoll&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../string/wide/wcstof&quot;&gt;wcstod&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../string/byte/isdigit&quot;&gt;isdigit&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../string/wide/iswblank&quot;&gt;iswblank&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../string/wide/iswupper&quot;&gt;iswupper&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../string/byte/strerror&quot;&gt;strerror&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../string/multibyte/wcstombs&quot;&gt;wcstombs&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../string/byte/isgraph&quot;&gt;isgraph&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../string/wide/iswcntrl&quot;&gt;iswcntrl&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../string/wide/iswxdigit&quot;&gt;iswxdigit&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../string/byte/strtof&quot;&gt;strtod&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../string/wide/wcsxfrm&quot;&gt;wcsxfrm&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../string/byte/islower&quot;&gt;islower&lt;/a&gt;&lt;/code&gt; 判断， &lt;code&gt;&lt;a href=&quot;../string/wide/iswctype&quot;&gt;iswctype&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../string/byte/isxdigit&quot;&gt;isxdigit&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="677c92c867af65c403f0e0b4ec228f7d426c2613" translate="yes" xml:space="preserve">
          <source>Because a struct declaration does not establish &lt;a href=&quot;scope&quot;&gt;scope&lt;/a&gt;, nested types, enumerations and enumerators introduced by declarations within struct-declaration-list are visible in the surrounding scope where the struct is defined.</source>
          <target state="translated">由于struct声明未建立&lt;a href=&quot;scope&quot;&gt;scope&lt;/a&gt;，因此在struct定义的周围范围内，由struct-declaration-list中的声明引入的嵌套类型，枚举和枚举数可见。</target>
        </trans-unit>
        <trans-unit id="80a31a1dd2f3b7679f827332e33a29fac7702466" translate="yes" xml:space="preserve">
          <source>Because bit fields do not necessarily begin at the beginning of a byte, address of a bit field cannot be taken. Pointers to bit fields are not possible. Bit fields cannot be used with &lt;a href=&quot;sizeof&quot;&gt;sizeof&lt;/a&gt;and &lt;a href=&quot;alignas&quot;&gt;alignas&lt;/a&gt;(since C11).</source>
          <target state="translated">因为位字段不一定在字节的开头开始，所以不能获取位字段的地址。指向位字段的指针是不可能的。位字段不能与&lt;a href=&quot;sizeof&quot;&gt;sizeof&lt;/a&gt;和&lt;a href=&quot;alignas&quot;&gt;alignas&lt;/a&gt;一起使用（自C11起）。</target>
        </trans-unit>
        <trans-unit id="b5ebf1a72c58aab22e302945eaa39d0cb80ef7c4" translate="yes" xml:space="preserve">
          <source>Because comments &lt;a href=&quot;language/translation_phases&quot;&gt;are removed&lt;/a&gt; before the preprocessor stage, a macro cannot be used to form a comment and an unterminated C-style comment doesn't spill over from an #include'd file.</source>
          <target state="translated">由于注释&lt;a href=&quot;language/translation_phases&quot;&gt;是&lt;/a&gt;在预处理程序阶段之前删除的，因此无法使用宏来形成注释，并且未终止的C样式注释不会从#include的文件中溢出。</target>
        </trans-unit>
        <trans-unit id="1e0e557c9045c92f011c14de73fcb46d729716ba" translate="yes" xml:space="preserve">
          <source>Because compound literals are unnamed, a compound literal cannot reference itself (a named struct can include a pointer to itself).</source>
          <target state="translated">因为复合字元是未命名的,所以复合字元不能引用自己(一个命名的结构可以包含一个指向自己的指针)。</target>
        </trans-unit>
        <trans-unit id="d0f24847824ec8fc762ee7f7da8ed9ef3192123c" translate="yes" xml:space="preserve">
          <source>Because correct C programs are free of undefined behavior, compilers may produce unexpected results when a program that actually has UB is compiled with optimization enabled:</source>
          <target state="translated">由于正确的C程序没有未定义的行为,所以当一个实际具有UB的程序在启用优化后编译时,编译器可能会产生意外的结果。</target>
        </trans-unit>
        <trans-unit id="75a3b82067fe04c5e544992bcd1de5079a905d52" translate="yes" xml:space="preserve">
          <source>Because declarations are not statements, a label before a declaration must use a null statement (a semicolon immediately after the colon). Same applies to a label before the end of a block.</source>
          <target state="translated">因为声明不是语句,所以声明前的标签必须使用null语句(在冒号后紧接着一个分号)。同样的道理也适用于代码块结束前的标签。</target>
        </trans-unit>
        <trans-unit id="1c99db21460e6186678ebd629bae9336a41554f4" translate="yes" xml:space="preserve">
          <source>Because in C, any &lt;a href=&quot;arithmetic_types&quot;&gt;complex value&lt;/a&gt; with at least one infinite part as an infinity even if its other part is a NaN, the usual arithmetic rules do not apply to complex-complex division. Other combinations of floating operands follow the following table:</source>
          <target state="translated">因为在C中，任何具有至少一个无穷大部分作为无穷大的&lt;a href=&quot;arithmetic_types&quot;&gt;复数值&lt;/a&gt;，即使其另一部分是NaN也是如此，所以通常的算术规则不适用于复数复数除法。浮动操作数的其他组合如下表：</target>
        </trans-unit>
        <trans-unit id="c3eb0806ea4c877ddbfd4e6e05950c4f3566ab2f" translate="yes" xml:space="preserve">
          <source>Because in C, any &lt;a href=&quot;arithmetic_types&quot;&gt;complex value&lt;/a&gt; with at least one infinite part as an infinity even if its other part is a NaN, the usual arithmetic rules do not apply to complex-complex multiplication. Other combinations of floating operands follow the following table:</source>
          <target state="translated">因为在C中，任何具有至少一个无穷大部分作为无穷大的&lt;a href=&quot;arithmetic_types&quot;&gt;复数值&lt;/a&gt;，即使其另一部分是NaN也是如此，所以通常的算术规则不适用于复复数乘法。浮动操作数的其他组合如下表：</target>
        </trans-unit>
        <trans-unit id="224dd2f76f1fe545b11d30d1241dfab1984d9c00" translate="yes" xml:space="preserve">
          <source>Because members of incomplete type are not allowed, and a struct type is not complete until the end of the definition, a struct cannot have a member of its own type. A pointer to its own type is allowed, and is commonly used to implement nodes in linked lists or trees.</source>
          <target state="translated">因为不完整类型的成员是不允许的,一个结构类型在定义结束前是不完整的,所以一个结构不能有自己类型的成员。允许有一个指向自己类型的指针,通常用于实现链接列表或树中的节点。</target>
        </trans-unit>
        <trans-unit id="bad967f19eac295089f2fac67901872b755b210a" translate="yes" xml:space="preserve">
          <source>Because most conversion specifiers first consume all consecutive whitespace, code such as.</source>
          <target state="translated">因为大多数转换指定符首先消耗所有连续的空格,所以代码如:。</target>
        </trans-unit>
        <trans-unit id="39db9801ee2b85598d8ae1a1a46079d1e8fc3c5a" translate="yes" xml:space="preserve">
          <source>Because of the &lt;a href=&quot;array&quot;&gt;array-to-pointer&lt;/a&gt; implicit conversion, pointer to the first element of an array can be initialized with an expression of array type:</source>
          <target state="translated">由于&lt;a href=&quot;array&quot;&gt;数组到指针的&lt;/a&gt;隐式转换，可以使用数组类型的表达式初始化指向数组第一个元素的指针：</target>
        </trans-unit>
        <trans-unit id="0ef3d7a594c0b241d8f8e7bcd0f19c06711e02ca" translate="yes" xml:space="preserve">
          <source>Because of the lvalue conversions, &lt;code&gt;&quot;abc&quot;&lt;/code&gt; matches &lt;code&gt;char*&lt;/code&gt; and not &lt;code&gt;char[4]&lt;/code&gt; and &lt;code&gt;(int const){0}&lt;/code&gt; matches &lt;code&gt;int&lt;/code&gt;, and not &lt;code&gt;const int&lt;/code&gt;. This was specified by the C17 DR 481 (which applies retroactively to C11).</source>
          <target state="translated">由于是左值转换，因此 &lt;code&gt;&quot;abc&quot;&lt;/code&gt; 匹配 &lt;code&gt;char*&lt;/code&gt; 而不匹配char &lt;code&gt;char[4]&lt;/code&gt; 并且 &lt;code&gt;(int const){0}&lt;/code&gt; 匹配 &lt;code&gt;int&lt;/code&gt; ，而不匹配 &lt;code&gt;const int&lt;/code&gt; 。这由C17 DR 481（追溯适用于C11）指定。</target>
        </trans-unit>
        <trans-unit id="921ed4a61ba3faaabd04a1761190de01805d8c37" translate="yes" xml:space="preserve">
          <source>Because of the rules that apply to conversions as if by assignment, &lt;a href=&quot;const&quot;&gt;const&lt;/a&gt; and &lt;a href=&quot;volatile&quot;&gt;volatile&lt;/a&gt; qualifiers on the declared type are ignored when determining which type to convert the expression to.</source>
          <target state="translated">由于适用于转换的规则（就像通过赋值一样），因此在确定将表达式转换为哪种类型时，将忽略声明的类型上的&lt;a href=&quot;const&quot;&gt;const&lt;/a&gt;和&lt;a href=&quot;volatile&quot;&gt;volatile&lt;/a&gt;限定符。</target>
        </trans-unit>
        <trans-unit id="e4778b72ab7bad66e8f08db4718675bdd369485f" translate="yes" xml:space="preserve">
          <source>Because of the side-effects involved, increment and decrement operators must be used with care to avoid undefined behavior due to violations of &lt;a href=&quot;eval_order&quot;&gt;sequencing rules&lt;/a&gt;.</source>
          <target state="translated">由于涉及副作用，因此必须谨慎使用递增和递减运算符，以避免由于违反&lt;a href=&quot;eval_order&quot;&gt;排序规则&lt;/a&gt;而导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="7dd28ff65248ebaad3755cb5b7e5ed66cc093d74" translate="yes" xml:space="preserve">
          <source>Because pointer comparison works with pointers to void, the macro &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; may be defined as &lt;code&gt;(void*)0&lt;/code&gt; in C, although that would be invalid in C++ where void pointers do not implicitly convert to typed pointers.</source>
          <target state="translated">因为指针比较与指向void的指针一起工作，所以宏 &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; 可以在C中定义为 &lt;code&gt;(void*)0&lt;/code&gt; ，尽管在C ++中，void指针不会隐式转换为类型化指针，这将是无效的。</target>
        </trans-unit>
        <trans-unit id="61e9e83dfb4480f034d0715c389293dc26f2bd68" translate="yes" xml:space="preserve">
          <source>Because trigraphs are processed early, a comment such as &lt;code&gt;// Will the next line be executed?????/&lt;/code&gt; will effectively comment out the following line, and the string literal such as &lt;code&gt;&quot;What's going on??!&quot;&lt;/code&gt; is parsed as &lt;code&gt;&quot;What's going on|&quot;&lt;/code&gt;.</source>
          <target state="translated">因为三部曲是较早处理的，所以注释，例如 &lt;code&gt;// Will the next line be executed?????/&lt;/code&gt; 会有效地注释掉下一行，以及字符串文字，例如 &lt;code&gt;&quot;What's going on??!&quot;&lt;/code&gt; 被解析为 &lt;code&gt;&quot;What's going on|&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b3a49bfbe489269815a0377a9238ed94b4143cdf" translate="yes" xml:space="preserve">
          <source>Before C99, floating-point exceptions were not specified, &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;EDOM&lt;/a&gt;&lt;/code&gt; was required for any domain error, &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;ERANGE&lt;/a&gt;&lt;/code&gt; was required for overflows and implementation-defined for underflows.</source>
          <target state="translated">在C99之前，未指定浮点异常，任何域错误都需要 &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;EDOM&lt;/a&gt;&lt;/code&gt; ，上溢需要 &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;ERANGE&lt;/a&gt;&lt;/code&gt; ，下溢则需要实现定义。</target>
        </trans-unit>
        <trans-unit id="9b5450db704d0d2728817fd478cd80ea4e486aaf" translate="yes" xml:space="preserve">
          <source>Behaves as follows:</source>
          <target state="translated">行为如下:</target>
        </trans-unit>
        <trans-unit id="bc3469b596bd7c770cc8387fa1d5a39905eb53ce" translate="yes" xml:space="preserve">
          <source>Besides &lt;code&gt;abort&lt;/code&gt; and &lt;code&gt;raise&lt;/code&gt;, POSIX specifies that &lt;code&gt;kill&lt;/code&gt;, &lt;code&gt;pthread_kill&lt;/code&gt;, and &lt;code&gt;sigqueue&lt;/code&gt; generate synchronous signals.</source>
          <target state="translated">除了 &lt;code&gt;abort&lt;/code&gt; 和 &lt;code&gt;raise&lt;/code&gt; ，POSIX还指定 &lt;code&gt;kill&lt;/code&gt; ， &lt;code&gt;pthread_kill&lt;/code&gt; 和 &lt;code&gt;sigqueue&lt;/code&gt; 生成同步信号。</target>
        </trans-unit>
        <trans-unit id="eabc9a356af19096008509b653054fc8a10ae1b7" translate="yes" xml:space="preserve">
          <source>Besides commenting out, other mechanisms used for source code exclusion are:</source>
          <target state="translated">除了注释外,其他用于源码排除的机制还有:。</target>
        </trans-unit>
        <trans-unit id="55b4de0c95564ebdd3f273d704de6fbc4cc33b7a" translate="yes" xml:space="preserve">
          <source>Besides establishing new parse state and position, a call to this function undoes the effects of &lt;code&gt;&lt;a href=&quot;ungetc&quot;&gt;ungetc&lt;/a&gt;&lt;/code&gt; and clears the end-of-file state, if it is set.</source>
          <target state="translated">除了建立新的解析状态和位置之外，对该函数的调用还可以消除 &lt;code&gt;&lt;a href=&quot;ungetc&quot;&gt;ungetc&lt;/a&gt;&lt;/code&gt; 的影响并清除文件结束状态（如果已设置）。</target>
        </trans-unit>
        <trans-unit id="93b85166ca8a42b63bd840ea2f796b2c221ddb71" translate="yes" xml:space="preserve">
          <source>Besides infinity handling, complex division is not allowed to overflow intermediate results, except when &lt;a href=&quot;../preprocessor/impl&quot;&gt;&lt;code&gt; #pragma STDC CX_LIMITED_RANGE&lt;/code&gt;&lt;/a&gt; is set to &lt;code&gt;ON&lt;/code&gt;, in which case the value may be calculated as if by (x+iy)/(u+iv) = [(xu+yv)+i(yu-xv)]/(u2</source>
          <target state="translated">除了无穷大处理之外，不允许复杂除法溢出中间结果，除非将&lt;a href=&quot;../preprocessor/impl&quot;&gt; &lt;code&gt; #pragma STDC CX_LIMITED_RANGE&lt;/code&gt; &lt;/a&gt;设置为 &lt;code&gt;ON&lt;/code&gt; ，在这种情况下，该值的计算方式可能类似于（x + iy）/（u + iv）= [ xu + yv）+ i（yu-xv）] /（u2</target>
        </trans-unit>
        <trans-unit id="e3c4ad2940bc363a4f3c8811d9bf42503eadc813" translate="yes" xml:space="preserve">
          <source>Besides infinity handling, complex multiplication is not allowed to overflow intermediate results, except when &lt;a href=&quot;../preprocessor/impl&quot;&gt;&lt;code&gt; #pragma STDC CX_LIMITED_RANGE&lt;/code&gt;&lt;/a&gt; is set to &lt;code&gt;ON&lt;/code&gt;, in which case the value may be calculated as if by (x+iy)&amp;times;(u+iv) = (xu-yv)+i(yu+xv), as the programmer assumes the responsibility of limiting the range of the operands and dealing with the infinities.</source>
          <target state="translated">除了无穷大处理之外，不允许复杂的乘法运算溢出中间结果，除非将&lt;a href=&quot;../preprocessor/impl&quot;&gt; &lt;code&gt; #pragma STDC CX_LIMITED_RANGE&lt;/code&gt; &lt;/a&gt;设置为 &lt;code&gt;ON&lt;/code&gt; ，在这种情况下，该值的计算方式类似于（x + iy）&amp;times;（u + iv）=（xu -yv）+ i（yu + xv），因为程序员承担了限制操作数范围和处理无穷大的责任。</target>
        </trans-unit>
        <trans-unit id="94e54a4d4ecea696ecc0d61df156f5a02b183b99" translate="yes" xml:space="preserve">
          <source>Besides the minimal bit counts, the C Standard guarantees that  &lt;code&gt;1 == sizeof(char) &amp;lt;= sizeof(short) &amp;lt;= sizeof(int) &amp;lt;= sizeof(long) &amp;lt;= sizeof(long long)&lt;/code&gt;.</source>
          <target state="translated">除了最小位数，C标准还保证 &lt;code&gt;1 == sizeof(char) &amp;lt;= sizeof(short) &amp;lt;= sizeof(int) &amp;lt;= sizeof(long) &amp;lt;= sizeof(long long)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0f9b2ba53360a3d77f0974e715c014901e8f2e24" translate="yes" xml:space="preserve">
          <source>Besides the system-specific information necessary to access the device (e.g. a POSIX file descriptor), each stream object holds the following:</source>
          <target state="translated">除了访问设备所需的系统特定信息(如POSIX文件描述符),每个流对象还拥有以下内容。</target>
        </trans-unit>
        <trans-unit id="c460d3f926dfc813742e2a51770def855d27f159" translate="yes" xml:space="preserve">
          <source>Binary and text modes</source>
          <target state="translated">二进制和文本模式</target>
        </trans-unit>
        <trans-unit id="b045376f837c7f5b36378c8f4a5c40a869f8ef92" translate="yes" xml:space="preserve">
          <source>Bit fields</source>
          <target state="translated">位领域</target>
        </trans-unit>
        <trans-unit id="f0ec1f622a02737f146bdf2f91db5413c9e7432c" translate="yes" xml:space="preserve">
          <source>Bit fields can have only one of four types (possibly &lt;a href=&quot;const&quot;&gt;const&lt;/a&gt; or &lt;a href=&quot;volatile&quot;&gt;volatile&lt;/a&gt; qualified):</source>
          <target state="translated">位字段只能具有以下四种类型之一（可能是&lt;a href=&quot;const&quot;&gt;const&lt;/a&gt;或&lt;a href=&quot;volatile&quot;&gt;volatile&lt;/a&gt;限定）：</target>
        </trans-unit>
        <trans-unit id="17e80e5f71e9b85954b350f117d4dfeb3c5cf70a" translate="yes" xml:space="preserve">
          <source>Bitwise AND</source>
          <target state="translated">位元 AND</target>
        </trans-unit>
        <trans-unit id="fbb0e5521fb64d3242c180ccb874fe7d8cabed01" translate="yes" xml:space="preserve">
          <source>Bitwise OR (inclusive or)</source>
          <target state="translated">位式OR(包含或</target>
        </trans-unit>
        <trans-unit id="306fd7520aac5bd6625750560fd55f52696ffa54" translate="yes" xml:space="preserve">
          <source>Bitwise OR of the floating-point exception macros that are both included in &lt;code&gt;excepts&lt;/code&gt; and correspond to floating-point exceptions currently set.</source>
          <target state="translated">浮点异常宏的按位&amp;ldquo;或&amp;rdquo;都包含在 &lt;code&gt;excepts&lt;/code&gt; 并且与当前设置的浮点异常相对应。</target>
        </trans-unit>
        <trans-unit id="8d05bc7de5edbe8f8035db15389ae0302c380410" translate="yes" xml:space="preserve">
          <source>Bitwise XOR (exclusive or)</source>
          <target state="translated">位向XOR(独占或</target>
        </trans-unit>
        <trans-unit id="fabd2c95e5b0d98f2f600ccc655473c06c0c3640" translate="yes" xml:space="preserve">
          <source>Bitwise left shift and right shift</source>
          <target state="translated">左移位和右移位</target>
        </trans-unit>
        <trans-unit id="8ff25d34bc5859088f94cfed2068dfc1ae2009f5" translate="yes" xml:space="preserve">
          <source>Bitwise logic</source>
          <target state="translated">位元逻辑</target>
        </trans-unit>
        <trans-unit id="e681513340338ab189ae37b3a82732813788fc1e" translate="yes" xml:space="preserve">
          <source>Block scope</source>
          <target state="translated">区块范围</target>
        </trans-unit>
        <trans-unit id="fd7d7dbe313bf74de7d4c75ebe6415d2612deaec" translate="yes" xml:space="preserve">
          <source>Block-scope variables have &lt;a href=&quot;storage_duration&quot;&gt;no linkage&lt;/a&gt; and &lt;a href=&quot;storage_duration&quot;&gt;automatic storage duration&lt;/a&gt; by default. Note that storage duration for non-VLA local variables begins when the block is entered, but until the declaration is seen, the variable is not in scope and cannot be accessed.</source>
          <target state="translated">默认情况下，块范围变量&lt;a href=&quot;storage_duration&quot;&gt;没有链接，&lt;/a&gt;并且&lt;a href=&quot;storage_duration&quot;&gt;自动存储持续时间&lt;/a&gt;。请注意，非VLA局部变量的存储期限从输入该块时开始，但是直到看到声明为止，该变量不在范围内并且无法访问。</target>
        </trans-unit>
        <trans-unit id="60cac622b229066c1c92084b1e1084cffd5fba0c" translate="yes" xml:space="preserve">
          <source>Blocks the current thread until the mutex pointed to by &lt;code&gt;mutex&lt;/code&gt; is locked or until the &lt;code&gt;TIME_UTC&lt;/code&gt; based time point pointed to by &lt;code&gt;time_point&lt;/code&gt; has been reached.</source>
          <target state="translated">块当前线程，直到互斥指出 &lt;code&gt;mutex&lt;/code&gt; 被锁定或者直到 &lt;code&gt;TIME_UTC&lt;/code&gt; 基于时间点指向 &lt;code&gt;time_point&lt;/code&gt; 已经达到。</target>
        </trans-unit>
        <trans-unit id="66bacdd3e696d27ee3c9031e8264d87687cb2c86" translate="yes" xml:space="preserve">
          <source>Blocks the current thread until the mutex pointed to by &lt;code&gt;mutex&lt;/code&gt; is locked.</source>
          <target state="translated">阻塞当前线程，直到互斥对象指向的 &lt;code&gt;mutex&lt;/code&gt; 被锁定为止。</target>
        </trans-unit>
        <trans-unit id="f10a288344857812105308b56f4f2cba321e7a11" translate="yes" xml:space="preserve">
          <source>Blocks the current thread until the thread identified by &lt;code&gt;thr&lt;/code&gt; finishes execution.</source>
          <target state="translated">阻塞当前线程，直到 &lt;code&gt;thr&lt;/code&gt; 所标识的线程执行完毕。</target>
        </trans-unit>
        <trans-unit id="6e00d4fd15cea4053d3d66470eca6ff8a4eb81f0" translate="yes" xml:space="preserve">
          <source>Blocks the execution of the current thread for</source>
          <target state="translated">阻止执行当前线程的</target>
        </trans-unit>
        <trans-unit id="c40226a362762d0bc6ce1da464fd4cab15481c00" translate="yes" xml:space="preserve">
          <source>Boolean and pointer expressions are often used as loop controlling expressions. The boolean value &lt;code&gt;false&lt;/code&gt; and the null pointer value of any pointer type compare equal to zero.</source>
          <target state="translated">布尔和指针表达式通常用作循环控制表达式。布尔值 &lt;code&gt;false&lt;/code&gt; 和任何指针类型的空指针值都等于零。</target>
        </trans-unit>
        <trans-unit id="0764deddbcf93612e5cc2cfe340f015993c796ea" translate="yes" xml:space="preserve">
          <source>Boolean conversion</source>
          <target state="translated">布尔转换</target>
        </trans-unit>
        <trans-unit id="49f29c844f200eead7503c6d10737135d242ba2b" translate="yes" xml:space="preserve">
          <source>Boolean type</source>
          <target state="translated">布尔型</target>
        </trans-unit>
        <trans-unit id="89e600a56a479c724d49fe8d5ef9759ca18de8f7" translate="yes" xml:space="preserve">
          <source>Boolean type support library</source>
          <target state="translated">布尔类型支持库</target>
        </trans-unit>
        <trans-unit id="e7015f95fbaa798e33d1af7e54e15189c43d90fc" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; and the value zero indicate successful program execution status (see &lt;code&gt;&lt;a href=&quot;exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt;), although it is not required that &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; equals zero.</source>
          <target state="translated">无论 &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; 和零值表示成功方案的执行状态（见 &lt;code&gt;&lt;a href=&quot;exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; ），尽管它不要求 &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; 等于零。</target>
        </trans-unit>
        <trans-unit id="5406302f58397cc6547f5253fa2bd90d63f7aaf4" translate="yes" xml:space="preserve">
          <source>Both unary plus and unary minus first apply &lt;a href=&quot;conversion&quot;&gt;integral promotions&lt;/a&gt; to their operand, and then.</source>
          <target state="translated">一元加号和一元减号都首先对它们的操作数应用&lt;a href=&quot;conversion&quot;&gt;整数提升&lt;/a&gt;，然后再对其进行运算。</target>
        </trans-unit>
        <trans-unit id="f61c46711ac1d50bd575498533838ae1e8abac1d" translate="yes" xml:space="preserve">
          <source>Both versions return a value of type &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;size_t&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这两个版本都返回一个 &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;size_t&lt;/a&gt;&lt;/code&gt; 类型的值。</target>
        </trans-unit>
        <trans-unit id="97a1527874168667ead2b1d8d5b5b282f24fe01a" translate="yes" xml:space="preserve">
          <source>Bounded UB is undefined behavior that cannot perform an illegal memory write, although it may trap and may produce or store indeterminate values.</source>
          <target state="translated">Bounded UB是未定义的行为,它不能执行非法的内存写入,尽管它可能陷阱,可能产生或存储不确定的值。</target>
        </trans-unit>
        <trans-unit id="79873d72bb63ec6416a942c808c710c67586e841" translate="yes" xml:space="preserve">
          <source>Bounded undefined behavior</source>
          <target state="translated">绑定的未定义行为</target>
        </trans-unit>
        <trans-unit id="4f10d11dd9987b9a9fd4e790ba2d77d5cde0dc75" translate="yes" xml:space="preserve">
          <source>Bounded undefined behavior disables certain optimizations: compilation with analyzability enabled preserves source-code causality, which &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=c/language/as_if&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;may be violated&lt;/a&gt; by undefined behavior otherwise.</source>
          <target state="translated">受限制的未定义行为会禁用某些优化：启用可分析性的编译会保留源代码因果关系，否则，未定义行为&lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=c/language/as_if&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;可能会违反&lt;/a&gt;该因果关系。</target>
        </trans-unit>
        <trans-unit id="008db50859187c03368a21b5b9915c65cb9f1ec8" translate="yes" xml:space="preserve">
          <source>Bounds checking</source>
          <target state="translated">边界检查</target>
        </trans-unit>
        <trans-unit id="400d9c7e5fe4086bae3b1862358d354ae9938c57" translate="yes" xml:space="preserve">
          <source>Built-in &lt;a href=&quot;operator_incdec&quot;&gt;increment and decrement operators&lt;/a&gt; and &lt;a href=&quot;operator_assignment&quot;&gt;compound assignment&lt;/a&gt; are read-modify-write atomic operations with total sequentially consistent ordering (as if using &lt;code&gt;&lt;a href=&quot;../atomic/memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt;). If less strict synchronization semantics are desired, the &lt;a href=&quot;../atomic&quot;&gt;standard library functions&lt;/a&gt; may be used instead.</source>
          <target state="translated">内置的&lt;a href=&quot;operator_incdec&quot;&gt;递增和递减运算符&lt;/a&gt;以及&lt;a href=&quot;operator_assignment&quot;&gt;复合赋值&lt;/a&gt;是具有总顺序一致顺序的读-修改-写原子操作（就像使用 &lt;code&gt;&lt;a href=&quot;../atomic/memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt; 一样）。如果需要不太严格的同步语义，则可以改用&lt;a href=&quot;../atomic&quot;&gt;标准库函数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f96307b93964d75b23f02f58a7c3a35fcfb5fa45" translate="yes" xml:space="preserve">
          <source>By definition, the subscript operator &lt;code&gt;E1[E2]&lt;/code&gt; is exactly identical to &lt;code&gt;*((E1)+(E2))&lt;/code&gt;. If pointer-expression is an array expression, it undergoes &lt;a href=&quot;conversion&quot;&gt;lvalue-to-rvalue conversion&lt;/a&gt; and becomes a pointer to the first element of the array.</source>
          <target state="translated">根据定义，下标运算符 &lt;code&gt;E1[E2]&lt;/code&gt; 与 &lt;code&gt;*((E1)+(E2))&lt;/code&gt; 完全相同。如果pointer-expression是数组表达式，则它将进行&lt;a href=&quot;conversion&quot;&gt;左值到右值转换，&lt;/a&gt;并成为指向数组第一个元素的指针。</target>
        </trans-unit>
        <trans-unit id="7803ee252527503b67d1eeb0deb252622746cebd" translate="yes" xml:space="preserve">
          <source>Byte</source>
          <target state="translated">Byte</target>
        </trans-unit>
        <trans-unit id="32096c2e0eff33d844ee6d675407ace18289357d" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>
        </trans-unit>
        <trans-unit id="c58c36c53f42fd7c600c76110fd52d5783cea7d0" translate="yes" xml:space="preserve">
          <source>C Operator Precedence</source>
          <target state="translated">C 操作员优先</target>
        </trans-unit>
        <trans-unit id="eb6caef1589eb4b1a6590767aba0af5ac987e71a" translate="yes" xml:space="preserve">
          <source>C Programming Language</source>
          <target state="translated">C语言</target>
        </trans-unit>
        <trans-unit id="c94ec5437a5532816a0317782c7e7642602f22e2" translate="yes" xml:space="preserve">
          <source>C adopted the</source>
          <target state="translated">C通过了</target>
        </trans-unit>
        <trans-unit id="5ca10313f99c78244c06862b7b8b7d340b4225b4" translate="yes" xml:space="preserve">
          <source>C also treats multiple infinities so as to preserve directional information where possible, despite the inherent limitations of the Cartesian representation:</source>
          <target state="translated">尽管笛卡尔表示法有其固有的局限性,但C也会对多个无穷大进行处理,从而尽可能地保留方向性信息。</target>
        </trans-unit>
        <trans-unit id="3ba06175a7b6689b39e35ea5131adbda2127a365" translate="yes" xml:space="preserve">
          <source>C has four kinds of scopes:</source>
          <target state="translated">C有四种范围。</target>
        </trans-unit>
        <trans-unit id="fba12a9f5cc269fdeb5b6fbe79b42205d52cb74c" translate="yes" xml:space="preserve">
          <source>C has three types for representing real floating-point values:</source>
          <target state="translated">C有三种类型来表示实数浮点值。</target>
        </trans-unit>
        <trans-unit id="5206547c9adf534ccbc26e9a7e7f81e1243117db" translate="yes" xml:space="preserve">
          <source>C keywords</source>
          <target state="translated">C关键词</target>
        </trans-unit>
        <trans-unit id="d3aabd7f1f341fa399600a1b2214223083e8c94a" translate="yes" xml:space="preserve">
          <source>C keywords: _Alignas (since C11)</source>
          <target state="translated">C级关键词。_Alignas(自C11起)</target>
        </trans-unit>
        <trans-unit id="944615bbeed64b2d9fae2675cefd548984ef900c" translate="yes" xml:space="preserve">
          <source>C keywords: _Alignof (since C11)</source>
          <target state="translated">C级关键词。_Alignof (自C11起)</target>
        </trans-unit>
        <trans-unit id="84b2eb329e4d92e0a4d384006f50861ce715cae6" translate="yes" xml:space="preserve">
          <source>C keywords: _Atomic</source>
          <target state="translated">C关键字。_原子</target>
        </trans-unit>
        <trans-unit id="8a05296f252eb2181406137c31f219059b31c674" translate="yes" xml:space="preserve">
          <source>C keywords: _Bool</source>
          <target state="translated">C关键字。_Bool</target>
        </trans-unit>
        <trans-unit id="1e0909bfead1f9cc1a889db650a2c563f189037c" translate="yes" xml:space="preserve">
          <source>C keywords: _Complex</source>
          <target state="translated">C关键词。_Complex</target>
        </trans-unit>
        <trans-unit id="b56eb0a972eae24c452dd3dcde43c102fa3f07b4" translate="yes" xml:space="preserve">
          <source>C keywords: _Generic</source>
          <target state="translated">C关键词。_Generic</target>
        </trans-unit>
        <trans-unit id="9ba2ce8143036dcefc339b168b7b9fdbf87a205e" translate="yes" xml:space="preserve">
          <source>C keywords: _Imaginary</source>
          <target state="translated">C关键词。_Imaginary</target>
        </trans-unit>
        <trans-unit id="c11f113e7aff3dde192c1e959a04c03b4117ed2d" translate="yes" xml:space="preserve">
          <source>C keywords: _Noreturn (since C11)</source>
          <target state="translated">C关键字。_Noreturn (自C11起)</target>
        </trans-unit>
        <trans-unit id="8155ee80a4c48fc49f561116f5e6c2e3aa9d145d" translate="yes" xml:space="preserve">
          <source>C keywords: _Static_assert</source>
          <target state="translated">C关键字:_Static_assert</target>
        </trans-unit>
        <trans-unit id="aa7ef9b71b6ab728b88e72b4e10aa644b34019fe" translate="yes" xml:space="preserve">
          <source>C keywords: _Thread_local (since C11)</source>
          <target state="translated">C关键字。_Thread_local (自C11起)</target>
        </trans-unit>
        <trans-unit id="49dc63ea16b8f8707b9b0e51cbd56a1d901d7ac4" translate="yes" xml:space="preserve">
          <source>C keywords: auto</source>
          <target state="translated">C关键词:汽车</target>
        </trans-unit>
        <trans-unit id="6de6b71cc705dbd2d56a38c0c394178db20754eb" translate="yes" xml:space="preserve">
          <source>C keywords: break</source>
          <target state="translated">C关键词:突破</target>
        </trans-unit>
        <trans-unit id="fb048e1990277a1b5c4c58f92576121302524116" translate="yes" xml:space="preserve">
          <source>C keywords: case</source>
          <target state="translated">C关键词:案例</target>
        </trans-unit>
        <trans-unit id="6f8e3ab600fea3b9d2310e503fc9d7066ff7e26b" translate="yes" xml:space="preserve">
          <source>C keywords: char</source>
          <target state="translated">C关键字:char</target>
        </trans-unit>
        <trans-unit id="4b30efaadabace2d9f3caf304fb5da46109165d9" translate="yes" xml:space="preserve">
          <source>C keywords: const</source>
          <target state="translated">C关键字:const</target>
        </trans-unit>
        <trans-unit id="838724dbf3de5ca09bb9955c0ee37433b11370c3" translate="yes" xml:space="preserve">
          <source>C keywords: continue</source>
          <target state="translated">C关键词:继续</target>
        </trans-unit>
        <trans-unit id="f798b0c0f90f69264c05dbb4746eb22431241a29" translate="yes" xml:space="preserve">
          <source>C keywords: default</source>
          <target state="translated">C关键字:默认</target>
        </trans-unit>
        <trans-unit id="c3d42e0deed9be4fc77cafc32457174fa359ea25" translate="yes" xml:space="preserve">
          <source>C keywords: do</source>
          <target state="translated">C关键词:做</target>
        </trans-unit>
        <trans-unit id="a9d0b771025dc99314e2f0637bddf7cbf7602aac" translate="yes" xml:space="preserve">
          <source>C keywords: double</source>
          <target state="translated">C关键字:双</target>
        </trans-unit>
        <trans-unit id="3a6a0ba8f0aed6dd0bdbf1e28ba0cd8d4c096062" translate="yes" xml:space="preserve">
          <source>C keywords: else</source>
          <target state="translated">C关键词:其他</target>
        </trans-unit>
        <trans-unit id="0d59e8885a30cf2c404b067251a56a9686c4680a" translate="yes" xml:space="preserve">
          <source>C keywords: enum</source>
          <target state="translated">C关键字:枚举</target>
        </trans-unit>
        <trans-unit id="7312b6a2fe886db62c316f52372b66d28c823610" translate="yes" xml:space="preserve">
          <source>C keywords: extern</source>
          <target state="translated">C关键字:外部</target>
        </trans-unit>
        <trans-unit id="bc94431cf882574a779c0aec755a45a2f7b530c7" translate="yes" xml:space="preserve">
          <source>C keywords: float</source>
          <target state="translated">C关键字:float</target>
        </trans-unit>
        <trans-unit id="6fc96909e96bd7935bb3a7616bd5d016d59c942f" translate="yes" xml:space="preserve">
          <source>C keywords: for</source>
          <target state="translated">C关键词:为</target>
        </trans-unit>
        <trans-unit id="ff6a74f8e86fbd66745ead6b6ba3ebe93f43ac4b" translate="yes" xml:space="preserve">
          <source>C keywords: fortran</source>
          <target state="translated">C关键字:Fortran</target>
        </trans-unit>
        <trans-unit id="c574828ab89e283f89de7b5bc3bbf68c09a59fb5" translate="yes" xml:space="preserve">
          <source>C keywords: goto</source>
          <target state="translated">C关键字:goto</target>
        </trans-unit>
        <trans-unit id="62c420a3462399a2cdf4f878f761c8b8c278f61a" translate="yes" xml:space="preserve">
          <source>C keywords: if</source>
          <target state="translated">C关键词:如果</target>
        </trans-unit>
        <trans-unit id="a97f823dd318fa21c2e97fe8be7e1dc7baed6dc0" translate="yes" xml:space="preserve">
          <source>C keywords: inline (since C99)</source>
          <target state="translated">C语言关键词:内联</target>
        </trans-unit>
        <trans-unit id="8df78b5fefdedc92ad106a538884aa77670d7509" translate="yes" xml:space="preserve">
          <source>C keywords: int</source>
          <target state="translated">C关键字:int</target>
        </trans-unit>
        <trans-unit id="4767637f37a0721fc583dd82533e0558b32fb5b6" translate="yes" xml:space="preserve">
          <source>C keywords: long</source>
          <target state="translated">C关键词:长</target>
        </trans-unit>
        <trans-unit id="4572d75f6a5ebfe96ce22c33079dc976094359ee" translate="yes" xml:space="preserve">
          <source>C keywords: register</source>
          <target state="translated">C关键字:注册</target>
        </trans-unit>
        <trans-unit id="79764e4605e47e7f696421a4847119c754498c27" translate="yes" xml:space="preserve">
          <source>C keywords: restrict</source>
          <target state="translated">C关键字:限制</target>
        </trans-unit>
        <trans-unit id="b36253fa50e39d05465466d0a6c51414fdedd520" translate="yes" xml:space="preserve">
          <source>C keywords: return</source>
          <target state="translated">C关键字:返回</target>
        </trans-unit>
        <trans-unit id="117fc03fbbb1cd95e26ffade247dccfa551447f3" translate="yes" xml:space="preserve">
          <source>C keywords: short</source>
          <target state="translated">C关键词:短</target>
        </trans-unit>
        <trans-unit id="4b9aae1b69e8290c6dcab6888c6d586ef3ea3599" translate="yes" xml:space="preserve">
          <source>C keywords: signed</source>
          <target state="translated">C关键字:签名</target>
        </trans-unit>
        <trans-unit id="f2bb9a6bd3b2fbdbf5168937c43676fb31e1477d" translate="yes" xml:space="preserve">
          <source>C keywords: sizeof</source>
          <target state="translated">C关键字:sizeof</target>
        </trans-unit>
        <trans-unit id="8880827f2b81e7d64ed4a6fc04f86f9143bbd556" translate="yes" xml:space="preserve">
          <source>C keywords: static</source>
          <target state="translated">C关键字:静态</target>
        </trans-unit>
        <trans-unit id="9d9e13c529fbaad7b136eeb51c9b93b5db4d574c" translate="yes" xml:space="preserve">
          <source>C keywords: struct</source>
          <target state="translated">C关键字:结构</target>
        </trans-unit>
        <trans-unit id="dafb3dc8cd252155d1d8f47dca6de15d26cd2a22" translate="yes" xml:space="preserve">
          <source>C keywords: switch</source>
          <target state="translated">C关键词:开关</target>
        </trans-unit>
        <trans-unit id="087358aba6a590b2ab90404b3247ed15247ce47f" translate="yes" xml:space="preserve">
          <source>C keywords: typedef</source>
          <target state="translated">C关键字:typedef</target>
        </trans-unit>
        <trans-unit id="1e04d799c3d9b84d0ec0266cbc6e1aa14a3ba94d" translate="yes" xml:space="preserve">
          <source>C keywords: union</source>
          <target state="translated">C关键词:联盟</target>
        </trans-unit>
        <trans-unit id="fb99b9e2646fbf1e9d1fbfa9d08bfe0a806de934" translate="yes" xml:space="preserve">
          <source>C keywords: unsigned</source>
          <target state="translated">C关键字:无符号</target>
        </trans-unit>
        <trans-unit id="195c0ae7f588efea965831acf345c1c17ac39c63" translate="yes" xml:space="preserve">
          <source>C keywords: void</source>
          <target state="translated">C关键字:无效</target>
        </trans-unit>
        <trans-unit id="8e4da6553c62486c5c52bbab3dee8e34b64fee5d" translate="yes" xml:space="preserve">
          <source>C keywords: volatile</source>
          <target state="translated">C关键字:挥发性</target>
        </trans-unit>
        <trans-unit id="b6c53e021f376fc8c0be266bf6434bd53837c1ce" translate="yes" xml:space="preserve">
          <source>C keywords: while</source>
          <target state="translated">C关键词:而</target>
        </trans-unit>
        <trans-unit id="91b79becc58238099e37212d187dd35b169ba357" translate="yes" xml:space="preserve">
          <source>C language</source>
          <target state="translated">C语言</target>
        </trans-unit>
        <trans-unit id="f247a737aad973565e0ba61f676327ab62c8b7fc" translate="yes" xml:space="preserve">
          <source>C memory management library</source>
          <target state="translated">C内存管理库</target>
        </trans-unit>
        <trans-unit id="f546b4aa9a28fb61a154855a5ca4c09f150dc10e" translate="yes" xml:space="preserve">
          <source>C programs create, destroy, access, and manipulate objects.</source>
          <target state="translated">C程序创建、销毁、访问和操作对象。</target>
        </trans-unit>
        <trans-unit id="577cba1265a06af20d2b556740cf4e6f66296754" translate="yes" xml:space="preserve">
          <source>C source code may be written in any 8-bit character set that includes the &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_646&quot;&gt;ISO 646:1983&lt;/a&gt; invariant character set, even non-ASCII ones. However, several C operators and punctuators require characters that are outside of the ISO 646 codeset: &lt;code&gt;{, }, [, ], #, \, ^, |, ~&lt;/code&gt;. To be able to use character encodings where some or all of these symbols do not exist (such as the German &lt;a href=&quot;http://de.wikipedia.org/wiki/DIN_66003&quot;&gt;DIN 66003&lt;/a&gt;), there are two possibilities: alternative spellings of operators that use these characters or special combinations of two or three ISO 646 compatible characters that are interpreted as if they were a single non-ISO 646 character.</source>
          <target state="translated">可以使用任何8位字符集（包括&lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_646&quot;&gt;ISO 646：1983&lt;/a&gt;不变字符集，甚至是非ASCII字符集）编写C源代码。但是，一些C运算符和标点符号要求使用ISO 646代码集之外的字符： &lt;code&gt;{, }, [, ], #, \, ^, |, ~&lt;/code&gt; 。为了能够在不存在某些或所有这些符号的情况下使用字符编码（例如，德国&lt;a href=&quot;http://de.wikipedia.org/wiki/DIN_66003&quot;&gt;DIN 66003&lt;/a&gt;），有两种可能性：使用这些字符的操作员的替代拼写或两个或三个与ISO 646兼容的字符的特殊组合解释为好像是一个非ISO 646字符。</target>
        </trans-unit>
        <trans-unit id="3fbf1fb8e0097341c0cc901e6d09a40c4cf46ba8" translate="yes" xml:space="preserve">
          <source>C source code may be written in any 8-bit character set that includes the &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_646&quot;&gt;ISO 646:1983&lt;/a&gt; invariant character set, even non-ASCII ones. However, several C operators and punctuators require characters that are outside of the ISO 646 codeset: &lt;code&gt;{, }, [, ], #, \, ^, |, ~&lt;/code&gt;. To be able to use character encodings where some or all of these symbols do not exist (such as the German &lt;a href=&quot;https://de.wikipedia.org/wiki/DIN_66003&quot;&gt;DIN 66003&lt;/a&gt;), there are two possibilities: alternative spellings of operators that use these characters or special combinations of two or three ISO 646 compatible characters that are interpreted as if they were a single non-ISO 646 character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d88a29df1d30dee79bf5cbde0b208d4dfe6c6510" translate="yes" xml:space="preserve">
          <source>C standard</source>
          <target state="translated">C标准</target>
        </trans-unit>
        <trans-unit id="79c384f1ba053ea6a78d8c958d790e56d9052ca1" translate="yes" xml:space="preserve">
          <source>C string holding the name of the desired category</source>
          <target state="translated">C 字符串,包含所需类别的名称</target>
        </trans-unit>
        <trans-unit id="437c617752c611b36293355138fcbc5720307f88" translate="yes" xml:space="preserve">
          <source>C string holding the name of the desired mapping.</source>
          <target state="translated">C 字符串,包含所需映射的名称。</target>
        </trans-unit>
        <trans-unit id="2426cb4ee79941311c0b2e401e3e16727f45af56" translate="yes" xml:space="preserve">
          <source>C supports two different forms of function definitions:</source>
          <target state="translated">C语言支持两种不同形式的函数定义。</target>
        </trans-unit>
        <trans-unit id="ed49d634ae356d7361bc64d793e6736fa4d6bcfc" translate="yes" xml:space="preserve">
          <source>C++ imposes additional limitations on the &lt;code&gt;goto&lt;/code&gt; statement, but allows labels before declarations (which are statements in C++).</source>
          <target state="translated">C ++对 &lt;code&gt;goto&lt;/code&gt; 语句施加了其他限制，但允许在声明（在C ++中的语句）之前使用标签。</target>
        </trans-unit>
        <trans-unit id="27007198c75e9f26b239199b91632e30ae50d365" translate="yes" xml:space="preserve">
          <source>C++ pragmas in Visual Studio 2010</source>
          <target state="translated">Visual Studio 2010中的C++实用程序</target>
        </trans-unit>
        <trans-unit id="59267432adf8c9336c020edab8c6d1687c5a8555" translate="yes" xml:space="preserve">
          <source>C++-style</source>
          <target state="translated">C++-style</target>
        </trans-unit>
        <trans-unit id="3c67bb4ebdd2ba43c17681cb6c05aab34159eee9" translate="yes" xml:space="preserve">
          <source>C++-style comments are usually used to comment single lines of text or code; however, they can be placed together to form multi-line comments. To insert text as a C++-style comment, simply precede the text with &lt;code&gt;//&lt;/code&gt; and follow the text with the new line character. C++-style comments tell the compiler to ignore all content between &lt;code&gt;//&lt;/code&gt; and a new line.</source>
          <target state="translated">C ++样式的注释通常用于注释一行文本或代码。但是，可以将它们放在一起形成多行注释。要将文本插入为C ++样式的注释，只需在文本前加上 &lt;code&gt;//&lt;/code&gt; ,然后在文本后加上换行符即可。 C ++样式的注释告诉编译器忽略 &lt;code&gt;//&lt;/code&gt; 和新行之间的所有内容。</target>
        </trans-unit>
        <trans-unit id="bd39761895022d52ef2184edffb0689497519cb3" translate="yes" xml:space="preserve">
          <source>C-style</source>
          <target state="translated">C-style</target>
        </trans-unit>
        <trans-unit id="0b9b1d01ffcd7c91aa5db3dfba413b80ea8d1087" translate="yes" xml:space="preserve">
          <source>C-style comments are usually used to comment large blocks of text or small fragments of code; however, they can be used to comment single lines. To insert text as a C-style comment, simply surround the text with &lt;code&gt;/*&lt;/code&gt; and &lt;code&gt;*/&lt;/code&gt;. C-style comments tell the compiler to ignore all content between &lt;code&gt;/*&lt;/code&gt; and &lt;code&gt;*/&lt;/code&gt;. Although it is not part of the C standard, &lt;code&gt;/**&lt;/code&gt; and &lt;code&gt;*/&lt;/code&gt; are often used to indicate documentation blocks; this is legal because the second asterisk is simply treated as part of the comment.</source>
          <target state="translated">C样式注释通常用于注释大块文本或小段代码；但是，它们可以用于注释单行。要将文本插入为C样式的注释，只需将文本用 &lt;code&gt;/*&lt;/code&gt; 和 &lt;code&gt;*/&lt;/code&gt; 括起来即可。C风格的注释告诉编译器忽略 &lt;code&gt;/*&lt;/code&gt; 和 &lt;code&gt;*/&lt;/code&gt; 之间的所有内容。尽管它不是C标准的一部分，但 &lt;code&gt;/**&lt;/code&gt; 和 &lt;code&gt;*/&lt;/code&gt; 通常用于指示文档块；这是合法的，因为第二个星号只是作为注释的一部分。</target>
        </trans-unit>
        <trans-unit id="261d0f1299c6d923d77533902d4aaab0184c41c8" translate="yes" xml:space="preserve">
          <source>C11 standard (ISO/IEC 9899:2011):</source>
          <target state="translated">C11标准(ISO/IEC 9899:2011)。</target>
        </trans-unit>
        <trans-unit id="9cd19e0c483895b4c4dca1dfee6e5ff438628642" translate="yes" xml:space="preserve">
          <source>C11, as published, specified that this function is per-object, not per-type. This was corrected by DR 465.</source>
          <target state="translated">公布的 C11 规定该功能是按对象而不是按类型的。DR 465对此进行了纠正。</target>
        </trans-unit>
        <trans-unit id="dc6cecb4527f2e14095c486e78d7793077fa54f6" translate="yes" xml:space="preserve">
          <source>C17 standard (ISO/IEC 9899:2018):</source>
          <target state="translated">C17标准(ISO/IEC 9899:2018)。</target>
        </trans-unit>
        <trans-unit id="65819a01f96020ce9b84e3f226d24b0b43cc98ec" translate="yes" xml:space="preserve">
          <source>C89/C90 standard (ISO/IEC 9899:1990):</source>
          <target state="translated">C89/C90标准(ISO/IEC 9899:1990);</target>
        </trans-unit>
        <trans-unit id="4950e31032ac031befcea4756381cc9748081edb" translate="yes" xml:space="preserve">
          <source>C99 standard (ISO/IEC 9899:1999):</source>
          <target state="translated">C99标准(ISO/IEC 9899:1999);</target>
        </trans-unit>
        <trans-unit id="24fc58ea2f98cd20a27008421ec7f7e3dfc35435" translate="yes" xml:space="preserve">
          <source>CHAR_BIT</source>
          <target state="translated">CHAR_BIT</target>
        </trans-unit>
        <trans-unit id="725f72738449b33d5ed2db35158ace2f646b043c" translate="yes" xml:space="preserve">
          <source>CHAR_MAX</source>
          <target state="translated">CHAR_MAX</target>
        </trans-unit>
        <trans-unit id="b30c9342a5465cef0a56934460b3bfa4e2e74c49" translate="yes" xml:space="preserve">
          <source>CHAR_MIN</source>
          <target state="translated">CHAR_MIN</target>
        </trans-unit>
        <trans-unit id="789b032a45d264e7a02138bff69b47aacb370fca" translate="yes" xml:space="preserve">
          <source>CLOCKS_PER_SEC</source>
          <target state="translated">CLOCKS_PER_SEC</target>
        </trans-unit>
        <trans-unit id="d03fa4788d162e10e0a9157c0182737d266d25dd" translate="yes" xml:space="preserve">
          <source>CMPLXCMPLXFCMPLXL</source>
          <target state="translated">CMPLXCMPLXFCMPLXL</target>
        </trans-unit>
        <trans-unit id="33cd69fa90839e408dab31b3614bbcdf87603f0c" translate="yes" xml:space="preserve">
          <source>CMPLXF, CMPLX, CMPLXL</source>
          <target state="translated">CMPLXF,CMPLX,CMPXLL</target>
        </trans-unit>
        <trans-unit id="b31dcd4d9874928426f6c96cb8a45435ad4f4f43" translate="yes" xml:space="preserve">
          <source>CMPLXL</source>
          <target state="translated">CMPLXL</target>
        </trans-unit>
        <trans-unit id="77ea7aa743c8ae5ceebe6476bf7df6ad49a72839" translate="yes" xml:space="preserve">
          <source>Call once</source>
          <target state="translated">呼叫一次</target>
        </trans-unit>
        <trans-unit id="4880a798b93c1b0de51af512420e2ef8cc83ab95" translate="yes" xml:space="preserve">
          <source>Call to a function with a prototype</source>
          <target state="translated">调用一个有原型的函数</target>
        </trans-unit>
        <trans-unit id="3901637e234ca0b63b4410c0ce6911729acd8c78" translate="yes" xml:space="preserve">
          <source>Call to a function without a prototype</source>
          <target state="translated">调用一个没有原型的函数</target>
        </trans-unit>
        <trans-unit id="f514aa0539c8746a97d9256b1f83110e75de13e4" translate="yes" xml:space="preserve">
          <source>Call, Comma, Ternary</source>
          <target state="translated">呼叫、逗号、三元</target>
        </trans-unit>
        <trans-unit id="ddde78f62d1b14d42265185475cdd0f871ebd9eb" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;snprintf&lt;/code&gt; with zero &lt;code&gt;bufsz&lt;/code&gt; and null pointer for &lt;code&gt;buffer&lt;/code&gt; is useful to determine the necessary buffer size to contain the output:</source>
          <target state="translated">用零 &lt;code&gt;bufsz&lt;/code&gt; 和null指针作为 &lt;code&gt;buffer&lt;/code&gt; 调用 &lt;code&gt;snprintf&lt;/code&gt; 对于确定包含输出的必要缓冲区大小很有用：</target>
        </trans-unit>
        <trans-unit id="1590423ec88dccd74976d9c0b4a15cd539e5de0f" translate="yes" xml:space="preserve">
          <source>Calling the function from several threads does not induce a data race. The implementation shall support the registration of at least &lt;code&gt;32&lt;/code&gt; functions.</source>
          <target state="translated">从多个线程调用该函数不会引起数据争用。该实现应支持至少 &lt;code&gt;32&lt;/code&gt; 个功能的注册。</target>
        </trans-unit>
        <trans-unit id="69c9c5c35564ca07b6ae1737d8a6eff19ce6279f" translate="yes" xml:space="preserve">
          <source>Calls the host environment's command processor with the parameter &lt;code&gt;command&lt;/code&gt;. Returns an implementation-defined value (usually the value that the invoked program returns).</source>
          <target state="translated">使用参数 &lt;code&gt;command&lt;/code&gt; 调用主机环境的命令处理器。返回实现定义的值（通常是被调用程序返回的值）。</target>
        </trans-unit>
        <trans-unit id="ca09c54bff74a82bae543ebe259f7452ee8c5293" translate="yes" xml:space="preserve">
          <source>Capabilities</source>
          <target state="translated">Capabilities</target>
        </trans-unit>
        <trans-unit id="6ccd1e19a995de897833876a1022c105f3fdec2a" translate="yes" xml:space="preserve">
          <source>Care must be taken when comparing floating-point values for equality, because the results of many operations cannot be represented exactly and must be rounded. In practice, floating-point numbers are usually compared allowing for the difference of one or more units of the last place.</source>
          <target state="translated">在比较浮点值是否相等时,必须小心,因为许多运算的结果不能精确地表示,必须四舍五入。在实际操作中,浮点数的比较通常会允许最后一位的一个或多个单位之差。</target>
        </trans-unit>
        <trans-unit id="74473f63620ac45f2911b86a7f11c6501a7660cd" translate="yes" xml:space="preserve">
          <source>Cast and assignment strip away any extraneous range and precision: this models the action of storing a value from an extended-precision FPU register into a standard-sized memory location.</source>
          <target state="translated">铸造和赋值去除任何无关的范围和精度:这是将一个值从一个扩展精度的FPU寄存器存储到一个标准大小的内存位置的动作模型。</target>
        </trans-unit>
        <trans-unit id="97ba68fc56a3efba444f7c6353ffce14d1fabcb2" translate="yes" xml:space="preserve">
          <source>Cast operator</source>
          <target state="translated">铸造操作员</target>
        </trans-unit>
        <trans-unit id="97fa7d1aa53dee3582d247166c0630bb95546ab9" translate="yes" xml:space="preserve">
          <source>Cast operators</source>
          <target state="translated">铸造操作员</target>
        </trans-unit>
        <trans-unit id="65d75a1f3269b2efa27b067212f26c8863bd9bf8" translate="yes" xml:space="preserve">
          <source>Categorizes floating point value &lt;code&gt;arg&lt;/code&gt; into the following categories: zero, subnormal, normal, infinite, NAN, or implementation-defined category. The macro returns an integral value.</source>
          <target state="translated">将浮点值 &lt;code&gt;arg&lt;/code&gt; 归类为以下类别：零，次正态，正态，无限，NAN或实现定义的类别。宏返回一个整数值。</target>
        </trans-unit>
        <trans-unit id="1e425fda009fc1318071c020b813ea73240be6c9" translate="yes" xml:space="preserve">
          <source>Causes abnormal program termination unless &lt;code&gt;&lt;a href=&quot;sig_types&quot;&gt;SIGABRT&lt;/a&gt;&lt;/code&gt; is being caught by a signal handler passed to signal and the handler does not return.</source>
          <target state="translated">导致异常程序终止，除非 &lt;code&gt;&lt;a href=&quot;sig_types&quot;&gt;SIGABRT&lt;/a&gt;&lt;/code&gt; 被传递给signal的信号处理程序捕获，并且该处理程序不返回。</target>
        </trans-unit>
        <trans-unit id="a5fc98a179eaefefc7383473561adf59469b047c" translate="yes" xml:space="preserve">
          <source>Causes normal program termination to occur without completely cleaning the resources.</source>
          <target state="translated">导致在没有完全清理资源的情况下,程序正常终止。</target>
        </trans-unit>
        <trans-unit id="03d84237d77c18a1ea9454f00c0d5a2c4def6e6a" translate="yes" xml:space="preserve">
          <source>Causes normal program termination to occur.</source>
          <target state="translated">导致程序正常终止。</target>
        </trans-unit>
        <trans-unit id="405fa0979a11ab8b89968a0b69245a9c1cfe58b8" translate="yes" xml:space="preserve">
          <source>Causes the enclosing &lt;a href=&quot;for&quot;&gt;for&lt;/a&gt;, &lt;a href=&quot;while&quot;&gt;while&lt;/a&gt; or &lt;a href=&quot;do&quot;&gt;do-while&lt;/a&gt; loop or &lt;a href=&quot;switch&quot;&gt; switch statement&lt;/a&gt; to terminate.</source>
          <target state="translated">使封闭的&lt;a href=&quot;for&quot;&gt;for&lt;/a&gt;，&lt;a href=&quot;while&quot;&gt;while&lt;/a&gt;或&lt;a href=&quot;do&quot;&gt;do-while&lt;/a&gt;循环或&lt;a href=&quot;switch&quot;&gt;switch语句&lt;/a&gt;终止。</target>
        </trans-unit>
        <trans-unit id="aac02b11ecaab94b12608001eae57b3a907465aa" translate="yes" xml:space="preserve">
          <source>Causes the remaining portion of the enclosing &lt;a href=&quot;for&quot;&gt;for&lt;/a&gt;, &lt;a href=&quot;while&quot;&gt;while&lt;/a&gt; or &lt;a href=&quot;do&quot;&gt; do-while&lt;/a&gt; loop body to be skipped.</source>
          <target state="translated">使封闭的剩余部分&lt;a href=&quot;for&quot;&gt;为&lt;/a&gt;，&lt;a href=&quot;while&quot;&gt;同时&lt;/a&gt;或&lt;a href=&quot;do&quot;&gt;做-而&lt;/a&gt;要跳过循环体。</target>
        </trans-unit>
        <trans-unit id="580812cfd060f7d050c66b73bd05ae797afde816" translate="yes" xml:space="preserve">
          <source>Certain &lt;a href=&quot;operator_arithmetic&quot;&gt;addition, subtraction&lt;/a&gt;, &lt;a href=&quot;operator_assignment&quot;&gt;compound assignment&lt;/a&gt;, &lt;a href=&quot;operator_incdec&quot;&gt;increment, and decrement&lt;/a&gt; operators are defined for pointers to elements of arrays.</source>
          <target state="translated">为指向数组元素的指针定义了某些&lt;a href=&quot;operator_arithmetic&quot;&gt;加法，减法&lt;/a&gt;，&lt;a href=&quot;operator_assignment&quot;&gt;复合赋值&lt;/a&gt;，&lt;a href=&quot;operator_incdec&quot;&gt;增量和减量&lt;/a&gt;运算符。</target>
        </trans-unit>
        <trans-unit id="f422128bf228bfdfc5c9bb732010edf878de2dd7" translate="yes" xml:space="preserve">
          <source>Certain words in a C program have special meaning, they are &lt;a href=&quot;../keyword&quot;&gt;keywords&lt;/a&gt;. Others can be used as &lt;a href=&quot;identifier&quot;&gt;identifiers&lt;/a&gt;, which may be used to identify &lt;a href=&quot;object&quot;&gt;objects&lt;/a&gt;, &lt;a href=&quot;functions&quot;&gt;functions&lt;/a&gt;, &lt;a href=&quot;struct&quot;&gt;struct&lt;/a&gt;, &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt;, or &lt;a href=&quot;enum&quot;&gt;enumeration&lt;/a&gt; tags, their members, &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; names, &lt;a href=&quot;statements#Labels&quot;&gt;labels&lt;/a&gt;, or &lt;a href=&quot;../preprocessor/replace&quot;&gt;macros&lt;/a&gt;.</source>
          <target state="translated">C程序中的某些单词具有特殊含义，它们是&lt;a href=&quot;../keyword&quot;&gt;关键字&lt;/a&gt;。其他可以用作&lt;a href=&quot;identifier&quot;&gt;标识符&lt;/a&gt;，可以用来标识&lt;a href=&quot;object&quot;&gt;对象&lt;/a&gt;，&lt;a href=&quot;functions&quot;&gt;函数&lt;/a&gt;，&lt;a href=&quot;struct&quot;&gt;struct&lt;/a&gt;，&lt;a href=&quot;union&quot;&gt;union&lt;/a&gt;或&lt;a href=&quot;enum&quot;&gt;枚举&lt;/a&gt;标签，它们的成员，&lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt;名称，&lt;a href=&quot;statements#Labels&quot;&gt;标签&lt;/a&gt;或&lt;a href=&quot;../preprocessor/replace&quot;&gt;宏&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a3614333e503e3f84b18d0f8a9ccba18b5aa755e" translate="yes" xml:space="preserve">
          <source>Changes the current line number and file name in the preprocessor.</source>
          <target state="translated">更改预处理器中的当前行号和文件名。</target>
        </trans-unit>
        <trans-unit id="bcd3bc7bc25f117f48576a1067f3eab87dc09962" translate="yes" xml:space="preserve">
          <source>Changes the filename of a file. The file is identified by character string pointed to by &lt;code&gt;old_filename&lt;/code&gt;. The new filename is identified by character string pointed to by &lt;code&gt;new_filename&lt;/code&gt;.</source>
          <target state="translated">更改文件名。该文件由 &lt;code&gt;old_filename&lt;/code&gt; 指向的字符串标识。新文件名由 &lt;code&gt;new_filename&lt;/code&gt; 指向的字符串标识。</target>
        </trans-unit>
        <trans-unit id="9f1702f311546e930d8f583ff60c5b7dafb56f91" translate="yes" xml:space="preserve">
          <source>Changes the the buffering mode of the given file stream &lt;code&gt;stream&lt;/code&gt; as indicated by the argument &lt;code&gt;mode&lt;/code&gt;. In addition,</source>
          <target state="translated">改变给定的文件流的缓冲模式 &lt;code&gt;stream&lt;/code&gt; 由参数所指示的 &lt;code&gt;mode&lt;/code&gt; 。此外，</target>
        </trans-unit>
        <trans-unit id="6512adfeb2b6b71a8085a0b4569a9025105f6ea1" translate="yes" xml:space="preserve">
          <source>Character array manipulation</source>
          <target state="translated">字符阵列操作</target>
        </trans-unit>
        <trans-unit id="11a965778572465b297760373bc0ab9a5fe50dd4" translate="yes" xml:space="preserve">
          <source>Character classification</source>
          <target state="translated">角色分类</target>
        </trans-unit>
        <trans-unit id="fb797cfcfb3f8dadf93dcc6665528c24781954df" translate="yes" xml:space="preserve">
          <source>Character constants</source>
          <target state="translated">字符常数</target>
        </trans-unit>
        <trans-unit id="34a7ab398acc718f6548cdc2f8cf73c1cb95496f" translate="yes" xml:space="preserve">
          <source>Character constants, when evaluated in &lt;code&gt;#if&lt;/code&gt;-expressions, may be interpreted in the source character set, the execution character set, or some other implementation-defined character set.</source>
          <target state="translated">在 &lt;code&gt;#if&lt;/code&gt; -expressions中求值时，字符常量可以在源字符集，执行字符集或某些其他实现定义的字符集中解释。</target>
        </trans-unit>
        <trans-unit id="71abf6f6cdd425368811b306d03c5406b82396a5" translate="yes" xml:space="preserve">
          <source>Character manipulation</source>
          <target state="translated">角色操纵</target>
        </trans-unit>
        <trans-unit id="ce6ddaa694e2a7b4942fbc87cf18e8f64d26f9b2" translate="yes" xml:space="preserve">
          <source>Character types</source>
          <target state="translated">字符类型</target>
        </trans-unit>
        <trans-unit id="7583a23f352a0114e03ecd5b421ac82f127e76d4" translate="yes" xml:space="preserve">
          <source>Checks if the end of the given file stream has been reached.</source>
          <target state="translated">检查是否已经到达指定文件流的终点。</target>
        </trans-unit>
        <trans-unit id="a80411bf63939bb5325e4f8c8df73adae4f03bdc" translate="yes" xml:space="preserve">
          <source>Checks if the given character can be printed, i.e. it is either a number (&lt;code&gt;0123456789&lt;/code&gt;), an uppercase letter (&lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt;), a lowercase letter (&lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt;), a punctuation character(&lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt;), or space, or any character classified as printable by the current C locale.</source>
          <target state="translated">检查给定字符是否可以打印，即它是一个数字（ &lt;code&gt;0123456789&lt;/code&gt; ），一个大写字母（ &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; ），一个小写字母（ &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; ），一个标点符号（ &lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt; ）或空格，或由当前C语言环境分类为可打印的任何字符。</target>
        </trans-unit>
        <trans-unit id="5cd50516db04d878a383e0474cbd44271fb0cbcd" translate="yes" xml:space="preserve">
          <source>Checks if the given character has a graphical representation, i.e. it is either a number (&lt;code&gt;0123456789&lt;/code&gt;), an uppercase letter (&lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt;), a lowercase letter (&lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt;), or a punctuation character(&lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt;), or any graphical character specific to the current C locale.</source>
          <target state="translated">检查给定字符是否具有图形表示，即它是数字（ &lt;code&gt;0123456789&lt;/code&gt; ），大写字母（ &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; ），小写字母（ &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; ）还是标点符号（ &lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt; ），或特定于当前C语言环境的任何图形字符。</target>
        </trans-unit>
        <trans-unit id="a9eb05afb3b38c63c5335df9e7e4ec728a94a143" translate="yes" xml:space="preserve">
          <source>Checks if the given character is a blank character in the current C locale. In the default C locale, only space (&lt;code&gt;0x20&lt;/code&gt;) and horizontal tab (&lt;code&gt;0x09&lt;/code&gt;) are classified as blank.</source>
          <target state="translated">检查给定字符在当前C语言环境中是否为空白字符。在默认的C语言环境中，仅空格（ &lt;code&gt;0x20&lt;/code&gt; ）和水平制表符（ &lt;code&gt;0x09&lt;/code&gt; ）被分类为空白。</target>
        </trans-unit>
        <trans-unit id="33fe2d2ab596854468dce386087d212e312337e6" translate="yes" xml:space="preserve">
          <source>Checks if the given character is a control character, i.e. codes &lt;code&gt;0x00-0x1F&lt;/code&gt; and &lt;code&gt;0x7F&lt;/code&gt;.</source>
          <target state="translated">检查给定字符是否为控制字符，即代码 &lt;code&gt;0x00-0x1F&lt;/code&gt; 和 &lt;code&gt;0x7F&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b81bc3069e91e958c3b48b56b856e7a064d982cb" translate="yes" xml:space="preserve">
          <source>Checks if the given character is a hexadecimal numeric character (&lt;code&gt;0123456789abcdefABCDEF&lt;/code&gt;) or is classified as a hexadecimal character.</source>
          <target state="translated">检查给定字符是十六进制数字字符（ &lt;code&gt;0123456789abcdefABCDEF&lt;/code&gt; ）还是被分类为十六进制字符。</target>
        </trans-unit>
        <trans-unit id="5ca278746bc9e114b2661e67e9d27426ef8645a2" translate="yes" xml:space="preserve">
          <source>Checks if the given character is a numeric character (&lt;code&gt;0123456789&lt;/code&gt;).</source>
          <target state="translated">检查给定字符是否为数字字符（ &lt;code&gt;0123456789&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="837e27bbd4c4f9b720edba791bc0a1c76ee5a46e" translate="yes" xml:space="preserve">
          <source>Checks if the given character is a punctuation character in the current C locale. The default C locale classifies the characters &lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt; as punctuation.</source>
          <target state="translated">检查给定字符在当前C语言环境中是否为标点符号。默认的C语言环境将字符 &lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt; 为标点符号。</target>
        </trans-unit>
        <trans-unit id="175dc8fef53c9b8998a48bfa272af43d8ca70a35" translate="yes" xml:space="preserve">
          <source>Checks if the given character is a whitespace character, i.e. either space (&lt;code&gt;0x20&lt;/code&gt;), form feed (&lt;code&gt;0x0c&lt;/code&gt;), line feed (&lt;code&gt;0x0a&lt;/code&gt;), carriage return (&lt;code&gt;0x0d&lt;/code&gt;), horizontal tab (&lt;code&gt;0x09&lt;/code&gt;) or vertical tab (&lt;code&gt;0x0b&lt;/code&gt;).</source>
          <target state="translated">检查给定字符是否为空格字符，即空格（ &lt;code&gt;0x20&lt;/code&gt; ），换页 &lt;code&gt;0x0c&lt;/code&gt; （0x0c），换行符（ &lt;code&gt;0x0a&lt;/code&gt; ），回车符（ &lt;code&gt;0x0d&lt;/code&gt; ），水平制表符（ &lt;code&gt;0x09&lt;/code&gt; ）或垂直制表符（ &lt;code&gt;0x0b&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="707e4e9ff428a06747d7018e5e02fddc801826d0" translate="yes" xml:space="preserve">
          <source>Checks if the given character is an alphabetic character, i.e. either an uppercase letter (&lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt;), or a lowercase letter (&lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt;).</source>
          <target state="translated">检查给定字符是否为字母字符，即大写字母（ &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; ）或小写字母（ &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="8460053f4f6257cbef25ff160120cc6c7e959e75" translate="yes" xml:space="preserve">
          <source>Checks if the given character is an alphanumeric character as classified by the current C locale. In the default locale, the following characters are alphanumeric:</source>
          <target state="translated">检查给定的字符是否是当前C语言环境下的字母数字字符。在默认的locale中,以下字符是字母数字字符。</target>
        </trans-unit>
        <trans-unit id="72a25eda93d278cea5691863e59bd4331e5ca8e4" translate="yes" xml:space="preserve">
          <source>Checks if the given character is an uppercase character according to the current C locale. In the default &quot;C&quot; locale, &lt;code&gt;isupper&lt;/code&gt; returns true only for the uppercase letters (&lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt;).</source>
          <target state="translated">根据当前C语言环境检查给定字符是否为大写字符。在默认的&amp;ldquo; C&amp;rdquo;语言环境中， &lt;code&gt;isupper&lt;/code&gt; 仅对大写字母（ &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; ）返回true 。</target>
        </trans-unit>
        <trans-unit id="9fe61f7d08ea23e640364b8edb24f7095af3e4b6" translate="yes" xml:space="preserve">
          <source>Checks if the given character is classified as a lowercase character according to the current C locale. In the default &quot;C&quot; locale, &lt;code&gt;islower&lt;/code&gt; returns true only for the lowercase letters (&lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt;).</source>
          <target state="translated">检查给定字符是否根据当前C语言环境被分类为小写字符。在默认的&amp;ldquo; C&amp;rdquo;语言环境中， &lt;code&gt;islower&lt;/code&gt; 仅对小写字母（ &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; ）返回true 。</target>
        </trans-unit>
        <trans-unit id="86e15e5f001ace8d5ed732d67f679b17b8027345" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character can be printed, i.e. it is either a number (&lt;code&gt;0123456789&lt;/code&gt;), an uppercase letter (&lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt;), a lowercase letter (&lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt;), a punctuation character(&lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt;), space or any printable character specific to the current C locale.</source>
          <target state="translated">检查是否可以打印给定的宽字符，即它是一个数字（ &lt;code&gt;0123456789&lt;/code&gt; ），一个大写字母（ &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; ），一个小写字母（ &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; ），一个标点符号（ &lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt; ），空格或当前C语言环境特定的任何可打印字符。</target>
        </trans-unit>
        <trans-unit id="6ddf1d4606203515c454d3cbf72c353c2b7a5550" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character corresponds (if narrowed) to a hexadecimal numeric character, i.e. one of &lt;code&gt;0123456789abcdefABCDEF&lt;/code&gt;.</source>
          <target state="translated">检查给定的宽字符是否与十六进制数字字符相对应（如果变窄），即 &lt;code&gt;0123456789abcdefABCDEF&lt;/code&gt; 之一。</target>
        </trans-unit>
        <trans-unit id="d54601d6790c54f44a419455b6b691579d6df40d" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character corresponds (if narrowed) to one of the ten decimal digit characters 0123456789.</source>
          <target state="translated">检查给定的宽字符是否与十位数字符0123456789中的一个对应(如果缩小了)。</target>
        </trans-unit>
        <trans-unit id="901c321d30a4b9e0c1bb0f4ce4f0b7f3fc5086ff" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character has a graphical representation, i.e. it is either a number (&lt;code&gt;0123456789&lt;/code&gt;), an uppercase letter (&lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt;), a lowercase letter (&lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt;), a punctuation character(&lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt;) or any graphical character specific to the current C locale.</source>
          <target state="translated">检查给定的宽字符是否具有图形表示，即它是数字（ &lt;code&gt;0123456789&lt;/code&gt; ），大写字母（ &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; ），小写字母（ &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; ），标点字符（ &lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt; ）或当前C语言环境特定的任何图形字符。</target>
        </trans-unit>
        <trans-unit id="69347e858d3166f00f30fe95f9dd5f5ae37bc816" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is a control character, i.e. codes &lt;code&gt;0x00-0x1F&lt;/code&gt; and &lt;code&gt;0x7F&lt;/code&gt; and any control characters specific to the current locale.</source>
          <target state="translated">检查给定的宽字符是否是控制字符，即代码 &lt;code&gt;0x00-0x1F&lt;/code&gt; 和 &lt;code&gt;0x7F&lt;/code&gt; 以及当前语言环境特定的任何控制字符。</target>
        </trans-unit>
        <trans-unit id="f75e93760224f49060fa9daae484b93562cec26c" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is a lowercase letter, i.e. one of &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; or any lowercase letter specific to the current locale.</source>
          <target state="translated">检查给定的宽字符是否为小写字母，即 &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; 或特定于当前语言环境的任何小写字母之一。</target>
        </trans-unit>
        <trans-unit id="d3bc1df8c65e55dc36b4066a3cfbf00b5eb6d139" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is a punctuation character, i.e. it is one of &lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt; or any punctuation character specific to the current locale.</source>
          <target state="translated">检查给定宽字符是标点字符，即，它是一个 &lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt; 或者任何特定于当前语言环境的标点符号。</target>
        </trans-unit>
        <trans-unit id="298e43db40ce5c6ddedf760c6d9d06385fec714f" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is a whitespace character, i.e. either space (&lt;code&gt;0x20&lt;/code&gt;), form feed (&lt;code&gt;0x0c&lt;/code&gt;), line feed (&lt;code&gt;0x0a&lt;/code&gt;), carriage return (&lt;code&gt;0x0d&lt;/code&gt;), horizontal tab (&lt;code&gt;0x09&lt;/code&gt;), vertical tab (&lt;code&gt;0x0b&lt;/code&gt;) or any whitespace character specific to the current locale.</source>
          <target state="translated">检查给定的宽字符是否为空格字符，即空格（ &lt;code&gt;0x20&lt;/code&gt; ），换页 &lt;code&gt;0x0c&lt;/code&gt; （0x0c），换行符（ &lt;code&gt;0x0a&lt;/code&gt; ），回车符（ &lt;code&gt;0x0d&lt;/code&gt; ），水平制表符（ &lt;code&gt;0x09&lt;/code&gt; ），垂直制表符（ &lt;code&gt;0x0b&lt;/code&gt; ）或任何空格特定于当前语言环境的字符。</target>
        </trans-unit>
        <trans-unit id="ecee395d873139c5f79bbced8e5ab2094298ef99" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is an alphabetic character, i.e. either an uppercase letter (&lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt;), a lowercase letter (&lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt;) or any alphabetic character specific to the current locale.</source>
          <target state="translated">检查给定的宽字符是否为字母字符，即大写字母（ &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; ），小写字母（ &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; ）或特定于当前语言环境的任何字母字符。</target>
        </trans-unit>
        <trans-unit id="5467527cb982943f926960fa171baeacafcc85de" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is an alphanumeric character, i.e. either a number (&lt;code&gt;0123456789&lt;/code&gt;), an uppercase letter (&lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt;), a lowercase letter (&lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt;) or any alphanumeric character specific to the current locale.</source>
          <target state="translated">检查给定的宽字符是否为字母数字字符，即数字（ &lt;code&gt;0123456789&lt;/code&gt; ），大写字母（ &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; ），小写字母（ &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; ）或特定于当前语言环境的任何字母数字字符。</target>
        </trans-unit>
        <trans-unit id="43c33322c3d3cfbcbf8bd68f060fd927a3eb782d" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is an uppercase letter, i.e. one of &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; or any uppercase letter specific to the current locale.</source>
          <target state="translated">检查给定的宽字符是否为大写字母，即 &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; 或当前语言环境特定的任何大写字母之一。</target>
        </trans-unit>
        <trans-unit id="1541b6076382859c29bdb454303ad0411f5bf188" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is classified as blank character (that is, a whitespace character used to separate words in a sentence) by the current C locale. In the default C locale, only space (&lt;code&gt;0x20&lt;/code&gt;) and horizontal tab (&lt;code&gt;0x09&lt;/code&gt;) are blank characters.</source>
          <target state="translated">检查当前C语言环境是否将给定的宽字符分类为空白字符（即，用于分隔句子中单词的空白字符）。在默认的C语言环境中，只有空格（ &lt;code&gt;0x20&lt;/code&gt; ）和水平制表符（ &lt;code&gt;0x09&lt;/code&gt; ）是空白字符。</target>
        </trans-unit>
        <trans-unit id="25148b32afeb099d72b04e72e49e95c2dd911646" translate="yes" xml:space="preserve">
          <source>Checks if the identifier was defined using &lt;a href=&quot;replace&quot;&gt;&lt;code&gt; #define&lt;/code&gt;&lt;/a&gt; directive.</source>
          <target state="translated">检查标识符是否使用&lt;a href=&quot;replace&quot;&gt; &lt;code&gt; #define&lt;/code&gt; &lt;/a&gt;指令定义。</target>
        </trans-unit>
        <trans-unit id="587976447f530aa6d25584b121ecdd151dbddd88" translate="yes" xml:space="preserve">
          <source>Checks the given stream for errors.</source>
          <target state="translated">检查给定的流是否有错误。</target>
        </trans-unit>
        <trans-unit id="2941dd6b2ef28d38e387c7f18e6f1d84f133699d" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; refer to the same thread.</source>
          <target state="translated">检查 &lt;code&gt;lhs&lt;/code&gt; 和 &lt;code&gt;rhs&lt;/code&gt; 是否引用同一线程。</target>
        </trans-unit>
        <trans-unit id="34eb3f9df1785987205174d978835deeb45e94ad" translate="yes" xml:space="preserve">
          <source>Choose clang to observe the output shown.</source>
          <target state="translated">选择clang观察显示的输出。</target>
        </trans-unit>
        <trans-unit id="94c2a3189e7f7885455350c4c7a8df2d0d6ad1d1" translate="yes" xml:space="preserve">
          <source>Classification</source>
          <target state="translated">Classification</target>
        </trans-unit>
        <trans-unit id="86c73ff296a69ebbcae03a6a87d277af954ca095" translate="yes" xml:space="preserve">
          <source>Classification and comparison</source>
          <target state="translated">分类和比较</target>
        </trans-unit>
        <trans-unit id="678a1418d0dca4dfa7d114655cc6c809563626e4" translate="yes" xml:space="preserve">
          <source>Classifies the wide character &lt;code&gt;wc&lt;/code&gt; using the current C locale's LC_CTYPE category identified by &lt;code&gt;desc&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;desc&lt;/code&gt; 标识的当前C语言环境的LC_CTYPE类别对宽字符 &lt;code&gt;wc&lt;/code&gt; 进行分类。</target>
        </trans-unit>
        <trans-unit id="4f846d9e8e5a959a36bfa1fbc2c8184ff034cead" translate="yes" xml:space="preserve">
          <source>Closes the given file stream. Any unwritten buffered data are flushed to the OS. Any unread buffered data are discarded.</source>
          <target state="translated">关闭给定的文件流。任何未写入的缓冲数据都会被刷新到OS中。任何未读的缓冲数据都会被丢弃。</target>
        </trans-unit>
        <trans-unit id="60ce571e9fd40583067484c63f2febcaa5424e29" translate="yes" xml:space="preserve">
          <source>Collation order is the dictionary order: the position of the letter in the national alphabet (its</source>
          <target state="translated">整理顺序是指字典顺序:字母在民族字母表中的位置(它的</target>
        </trans-unit>
        <trans-unit id="9f9c3302a6454b216eade45c792066892cae6eab" translate="yes" xml:space="preserve">
          <source>Colloquially known as</source>
          <target state="translated">俗称</target>
        </trans-unit>
        <trans-unit id="b9ee3deaae2695cf53cbcebec20aed5fb9b594e3" translate="yes" xml:space="preserve">
          <source>Comma</source>
          <target state="translated">Comma</target>
        </trans-unit>
        <trans-unit id="b506b24efb6525b0ee356cf0162e2de834afe47c" translate="yes" xml:space="preserve">
          <source>Comma operator</source>
          <target state="translated">逗号运算符</target>
        </trans-unit>
        <trans-unit id="f9d837147551d84676f75bd72ce6ad24312cb2bd" translate="yes" xml:space="preserve">
          <source>Comma operator is not allowed in &lt;a href=&quot;constant_expression&quot;&gt;constant expressions&lt;/a&gt;, regardless of whether it's on the top level or not.</source>
          <target state="translated">&lt;a href=&quot;constant_expression&quot;&gt;常量表达式中&lt;/a&gt;不允许使用逗号运算符，无论它是否在顶层。</target>
        </trans-unit>
        <trans-unit id="fce06e20e5f7f74aacccab40b59b75a56c8f7305" translate="yes" xml:space="preserve">
          <source>Comments</source>
          <target state="translated">Comments</target>
        </trans-unit>
        <trans-unit id="77dc6eb02cb1c62d942bb34b9b074bf78c09d78f" translate="yes" xml:space="preserve">
          <source>Comments serve as a sort of in-code documentation. When inserted into a program, they are effectively ignored by the compiler; they are solely intended to be used as notes by the humans that read source code.</source>
          <target state="translated">注释作为一种代码内的文档,当插入到程序中时,它们实际上被编译器忽略了;它们只是作为阅读源代码的人的注释。当插入到程序中时,它们被编译器有效地忽略了;它们的唯一目的是被阅读源代码的人用作注释。</target>
        </trans-unit>
        <trans-unit id="3058ce23e65f21dc5cbd24c26f57bcb910e0857c" translate="yes" xml:space="preserve">
          <source>Common macro definitions</source>
          <target state="translated">常见的宏定义</target>
        </trans-unit>
        <trans-unit id="300b7ca7537f6f7e544d83703decea74261de072" translate="yes" xml:space="preserve">
          <source>Common mathematical functions</source>
          <target state="translated">常用数学函数</target>
        </trans-unit>
        <trans-unit id="d05b85b9373c028c966baf6f72eacf6afdf95cd7" translate="yes" xml:space="preserve">
          <source>Common mathematics functions</source>
          <target state="translated">常用数学函数</target>
        </trans-unit>
        <trans-unit id="044d38e8939c8f6fc027ea1c90729d6aca7109d3" translate="yes" xml:space="preserve">
          <source>Common operators</source>
          <target state="translated">常用运算符</target>
        </trans-unit>
        <trans-unit id="ed62bc28035976769130c4128738e35c18c296a6" translate="yes" xml:space="preserve">
          <source>Communicating with the environment</source>
          <target state="translated">与环境的沟通</target>
        </trans-unit>
        <trans-unit id="35e8aa2bb22045b3aaa2abc8b9c19086e5217942" translate="yes" xml:space="preserve">
          <source>Compares at most &lt;code&gt;count&lt;/code&gt; characters of two possibly null-terminated arrays. The comparison is done lexicographically.</source>
          <target state="translated">比较最多两个可能为空终止的数组的 &lt;code&gt;count&lt;/code&gt; 字符。比较是按字典顺序进行的。</target>
        </trans-unit>
        <trans-unit id="0727eb4b9d940361cfe3eeafe56df0bb6ceff1b1" translate="yes" xml:space="preserve">
          <source>Compares at most &lt;code&gt;count&lt;/code&gt; wide characters of two null-terminated wide strings. The comparison is done lexicographically.</source>
          <target state="translated">比较最多 &lt;code&gt;count&lt;/code&gt; 两个以null终止的宽字符串的宽字符。比较是按字典顺序进行的。</target>
        </trans-unit>
        <trans-unit id="a146ec971b1d93c0eca122d627ff96be93cae780" translate="yes" xml:space="preserve">
          <source>Compares different floating-point decomposition functions.</source>
          <target state="translated">比较不同的浮点分解函数。</target>
        </trans-unit>
        <trans-unit id="505981e95799fb74b00a3bcd6545a539962db24a" translate="yes" xml:space="preserve">
          <source>Compares the first &lt;code&gt;count&lt;/code&gt; characters of the objects pointed to by &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. The comparison is done lexicographically.</source>
          <target state="translated">比较 &lt;code&gt;lhs&lt;/code&gt; 和 &lt;code&gt;rhs&lt;/code&gt; 指向的对象的第一个 &lt;code&gt;count&lt;/code&gt; 字符。比较是按字典顺序进行的。</target>
        </trans-unit>
        <trans-unit id="8081695a2902e2182377570f6d2fb36eb8232444" translate="yes" xml:space="preserve">
          <source>Compares the first &lt;code&gt;count&lt;/code&gt; wide characters of the wide character (or compatible integer type) arrays pointed to by &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. The comparison is done lexicographically.</source>
          <target state="translated">比较 &lt;code&gt;lhs&lt;/code&gt; 和 &lt;code&gt;rhs&lt;/code&gt; 指向的宽字符（或兼容整数类型）数组的第一个 &lt;code&gt;count&lt;/code&gt; 宽字符。比较是按字典顺序进行的。</target>
        </trans-unit>
        <trans-unit id="0e00c63c41d94e64efbb2ed0a1eb306b8443cef2" translate="yes" xml:space="preserve">
          <source>Compares two null-terminated byte strings according to the current locale as defined by the &lt;code&gt;&lt;a href=&quot;../../locale/lc_categories&quot;&gt;LC_COLLATE&lt;/a&gt;&lt;/code&gt; category.</source>
          <target state="translated">根据 &lt;code&gt;&lt;a href=&quot;../../locale/lc_categories&quot;&gt;LC_COLLATE&lt;/a&gt;&lt;/code&gt; 类别所定义的当前语言环境比较两个以空值结尾的字节字符串。</target>
        </trans-unit>
        <trans-unit id="3d96fd82bc5cfecc84e4ec5ba54d1dce1db99f1b" translate="yes" xml:space="preserve">
          <source>Compares two null-terminated byte strings lexicographically.</source>
          <target state="translated">对两个空端字节字符串进行词法上的比较。</target>
        </trans-unit>
        <trans-unit id="15950bd77b78269b905c3c5c5ba78145e13631f4" translate="yes" xml:space="preserve">
          <source>Compares two null-terminated wide strings according to the collation order defined by the &lt;code&gt;&lt;a href=&quot;../../locale/lc_categories&quot;&gt;LC_COLLATE&lt;/a&gt;&lt;/code&gt; category of the currently installed locale.</source>
          <target state="translated">根据由当前安装的语言环境的 &lt;code&gt;&lt;a href=&quot;../../locale/lc_categories&quot;&gt;LC_COLLATE&lt;/a&gt;&lt;/code&gt; 类别定义的归类顺序比较两个以空值终止的宽字符串。</target>
        </trans-unit>
        <trans-unit id="425c0ed5bb7057b86419e94b1e93f2ea4b7b2de1" translate="yes" xml:space="preserve">
          <source>Compares two null-terminated wide strings lexicographically.</source>
          <target state="translated">对两个空端宽字符串进行词法比较。</target>
        </trans-unit>
        <trans-unit id="9461d4c9f916ad7df5538225ed552fb6e7e3284b" translate="yes" xml:space="preserve">
          <source>Comparison operators</source>
          <target state="translated">比较运算符</target>
        </trans-unit>
        <trans-unit id="181e8d4d8e85dc949aeb0b7a2e7684136d886553" translate="yes" xml:space="preserve">
          <source>Comparison operators are binary operators that test a condition and return &lt;b&gt;1&lt;/b&gt; if that condition is logically &lt;b&gt;true&lt;/b&gt; and &lt;b&gt;0&lt;/b&gt; if that condition is &lt;b&gt;false&lt;/b&gt;.</source>
          <target state="translated">比较运算符是二进制运算符，用于测试条件，如果条件在逻辑上为&lt;b&gt;true&lt;/b&gt;，则返回&lt;b&gt;1；&lt;/b&gt;如果条件为&lt;b&gt;false&lt;/b&gt;，则返回&lt;b&gt;0&lt;/b&gt;。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="580eefdb317ca1980517ce814ac757d8de1a082e" translate="yes" xml:space="preserve">
          <source>Compatible types</source>
          <target state="translated">兼容类型</target>
        </trans-unit>
        <trans-unit id="6e5b2b0dca46a4ad21f4296d9b1bc8179a4d98ec" translate="yes" xml:space="preserve">
          <source>Compilation takes place: the tokens are syntactically and semantically analyzed and translated as a translation unit.</source>
          <target state="translated">编译进行:对标记进行句法和语义分析,并作为翻译单元进行翻译。</target>
        </trans-unit>
        <trans-unit id="3b17b76f2f8c8bd9e9381ee9ce3fb90ff874e220" translate="yes" xml:space="preserve">
          <source>Complex and imaginary addition and subtraction are defined as follows (note the result type is imaginary if both operands are imaginary and complex if one operand is real and the other imaginary, as specified by the usual arithmetic conversions):</source>
          <target state="translated">复式和虚式加减法的定义如下(注意,如果两个操作数都是虚式,则结果类型为虚式,如果一个操作数是实式,另一个是虚式,则结果类型为复式,由通常的算术转换规定)。</target>
        </trans-unit>
        <trans-unit id="44dd33fc6270732559d77c0f49e48c52d2052437" translate="yes" xml:space="preserve">
          <source>Complex floating types</source>
          <target state="translated">复杂的浮动类型</target>
        </trans-unit>
        <trans-unit id="9abb4134e20e54cbe39b6d903f1af3c82407a19d" translate="yes" xml:space="preserve">
          <source>Complex floating types model the mathematical &lt;a href=&quot;https://en.wikipedia.org/wiki/Complex_number&quot;&gt;complex numbers&lt;/a&gt;, that is the numbers that can be written as a sum of a real number and a real number multiplied by the imaginary unit: a + bi.</source>
          <target state="translated">复数浮点类型为数学&lt;a href=&quot;https://en.wikipedia.org/wiki/Complex_number&quot;&gt;复数&lt;/a&gt;建模，即可以写为实数和实数之和乘以虚数单位：a + bi的数字。</target>
        </trans-unit>
        <trans-unit id="4dbbf2b2a08a0bd32712455c3831413cb3be33b6" translate="yes" xml:space="preserve">
          <source>Complex function</source>
          <target state="translated">复合函数</target>
        </trans-unit>
        <trans-unit id="588968aece6ec2967902b0c8debd814af1beab35" translate="yes" xml:space="preserve">
          <source>Complex number arithmetic</source>
          <target state="translated">复数算术</target>
        </trans-unit>
        <trans-unit id="c33f3e884f8ee47e82b79abb3d7ac7ecc6d16cf0" translate="yes" xml:space="preserve">
          <source>Complex numbers may be used with &lt;a href=&quot;operator_arithmetic&quot;&gt;arithmetic operators&lt;/a&gt; + - * and /, possibly mixed with imaginary and real numbers. There are many mathematical functions defined for complex numbers in &lt;a href=&quot;../numeric/complex&quot;&gt;complex.h&lt;/a&gt;. Both built-in operators and library functions may raise floating-point exceptions and set &lt;code&gt;&lt;a href=&quot;../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; as described in &lt;a href=&quot;../numeric/math/math_errhandling&quot;&gt;&lt;code&gt;math_errhandling&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">复数可以与&lt;a href=&quot;operator_arithmetic&quot;&gt;算术运算符&lt;/a&gt; +-*和/ 一起使用，并且可能与虚数和实数混合。在&lt;a href=&quot;../numeric/complex&quot;&gt;complex.h中&lt;/a&gt;为复数定义了许多数学函数。内置运算符和库函数都可能引发浮点异常并按照&lt;a href=&quot;../numeric/math/math_errhandling&quot;&gt; &lt;code&gt;math_errhandling&lt;/code&gt; 中的说明&lt;/a&gt;设置 &lt;code&gt;&lt;a href=&quot;../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="986de770a77674f7fac27990f9489f0625e4e838" translate="yes" xml:space="preserve">
          <source>Complex type conversions</source>
          <target state="translated">复杂类型转换</target>
        </trans-unit>
        <trans-unit id="c03daa5c814cb456a3684f1ad69e17b36c0d48db" translate="yes" xml:space="preserve">
          <source>Complex-imaginary conversions</source>
          <target state="translated">复数-虚数转换</target>
        </trans-unit>
        <trans-unit id="5881b1c904d7b7259dd04943175ea48e1e428f2b" translate="yes" xml:space="preserve">
          <source>Complex-only functions</source>
          <target state="translated">仅限复杂功能</target>
        </trans-unit>
        <trans-unit id="c2380af577316c38820427372c14161206c8131e" translate="yes" xml:space="preserve">
          <source>Complex/real type-generic macros</source>
          <target state="translated">复杂/实型-通用宏</target>
        </trans-unit>
        <trans-unit id="537187710d8643593965aef2a7a923121f09907a" translate="yes" xml:space="preserve">
          <source>Composite types</source>
          <target state="translated">复合型</target>
        </trans-unit>
        <trans-unit id="f1378b286398f88adfddc67ea372070620098f37" translate="yes" xml:space="preserve">
          <source>Compound assignment</source>
          <target state="translated">复式转让</target>
        </trans-unit>
        <trans-unit id="1f90e942ffc2b35ee9b3e4218cfd0172a5f1958a" translate="yes" xml:space="preserve">
          <source>Compound literal(C99)</source>
          <target state="translated">复合文字(C99)</target>
        </trans-unit>
        <trans-unit id="9d48e2cbfc2e7a620861605b5a2d55bac9d2711b" translate="yes" xml:space="preserve">
          <source>Compound literals of const-qualified character or wide character array types may share storage with &lt;a href=&quot;string_literal&quot;&gt;string literals&lt;/a&gt;.</source>
          <target state="translated">const限定字符或宽字符数组类型的复合文字可以与&lt;a href=&quot;string_literal&quot;&gt;字符串文字&lt;/a&gt;共享存储。</target>
        </trans-unit>
        <trans-unit id="557ac2424c5366dd0727ffe7e7cd646b1ea065fd" translate="yes" xml:space="preserve">
          <source>Compound statements</source>
          <target state="translated">复合声明</target>
        </trans-unit>
        <trans-unit id="181b2c5fdb89e27a6008d489d216495b9acd968b" translate="yes" xml:space="preserve">
          <source>Computes both the quotient and the remainder of the division of the numerator &lt;code&gt;x&lt;/code&gt; by the denominator &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">计算分子 &lt;code&gt;x&lt;/code&gt; 除以分母 &lt;code&gt;y&lt;/code&gt; 的商和余数。</target>
        </trans-unit>
        <trans-unit id="e9444ce94d568a16c9c8dae23ae1d2d6125ac8fc" translate="yes" xml:space="preserve">
          <source>Computes difference between two calendar times as &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;time_t&lt;/a&gt;&lt;/code&gt; objects (&lt;code&gt;time_end - time_beg&lt;/code&gt;) in seconds. If &lt;code&gt;time_end&lt;/code&gt; refers to time point before &lt;code&gt;time_beg&lt;/code&gt; then the result is negative.</source>
          <target state="translated">计算两个日历时间之间的 &lt;code&gt;time_end - time_beg&lt;/code&gt; 以秒为单位的 &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;time_t&lt;/a&gt;&lt;/code&gt; 对象（time_end-time_beg）。如果 &lt;code&gt;time_end&lt;/code&gt; 指向 &lt;code&gt;time_beg&lt;/code&gt; 之前的时间点，则结果为负。</target>
        </trans-unit>
        <trans-unit id="509eb0b7cc06400c9a23de5f72ecc0de165b85e5" translate="yes" xml:space="preserve">
          <source>Computes quotient and remainder simultaneously. The quotient is the algebraic quotient with any fractional part discarded (truncated towards zero). The remainder is such that &lt;code&gt;quot * y + rem == x&lt;/code&gt;.</source>
          <target state="translated">同时计算商和余数。商是舍弃任何小数部分（截断为零）的代数商。余数是 &lt;code&gt;quot * y + rem == x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fada816f8d77fb81d9ff5b692bd2596860aa718e" translate="yes" xml:space="preserve">
          <source>Computes the absolute value of an integer number. The behavior is undefined if the result cannot be represented by the return type.</source>
          <target state="translated">计算一个整数的绝对值。如果结果不能用返回类型表示,则该行为未定义。</target>
        </trans-unit>
        <trans-unit id="dca8bdeece135120987218c0e8c574bf0369c8f5" translate="yes" xml:space="preserve">
          <source>Computes the quotient (the result of the expression &lt;code&gt;x/y&lt;/code&gt;) and remainder (the result of the expression &lt;code&gt;x%y&lt;/code&gt;) simultaneously.</source>
          <target state="translated">同时计算商（表达式 &lt;code&gt;x/y&lt;/code&gt; 的结果）和余数（表达式 &lt;code&gt;x%y&lt;/code&gt; 的结果）。</target>
        </trans-unit>
        <trans-unit id="2f4979324e03e4571b1d7eba701226670c2ee2da" translate="yes" xml:space="preserve">
          <source>Condition</source>
          <target state="translated">Condition</target>
        </trans-unit>
        <trans-unit id="c9310d3b540cdb7701ecb54cf6be827f8499b99f" translate="yes" xml:space="preserve">
          <source>Condition variables</source>
          <target state="translated">条件变量</target>
        </trans-unit>
        <trans-unit id="6df92750a0f9ea5c7e0fdf367810b34c51dfc8b0" translate="yes" xml:space="preserve">
          <source>Conditional evaluation</source>
          <target state="translated">有条件的评价</target>
        </trans-unit>
        <trans-unit id="ae382767cc8004ef63f077e5c30b8fcc609af876" translate="yes" xml:space="preserve">
          <source>Conditional inclusion</source>
          <target state="translated">有条件的纳入</target>
        </trans-unit>
        <trans-unit id="86d8c4f438a64027d9c179cbd6cac7228180ae16" translate="yes" xml:space="preserve">
          <source>Conditional operator</source>
          <target state="translated">条件运算符</target>
        </trans-unit>
        <trans-unit id="f0e3da472ae92d2102d21d061ce57f244b5a5c0e" translate="yes" xml:space="preserve">
          <source>Conditional operator has right-to-left associativity, which allows chaining.</source>
          <target state="translated">条件运算符具有从右到左的关联性,可以进行链式运算。</target>
        </trans-unit>
        <trans-unit id="a5c5b712f5b77396fc4520f5a9049d95172e4471" translate="yes" xml:space="preserve">
          <source>Conditionally compiled macro that compares its argument to zero</source>
          <target state="translated">有条件地编译宏,将其参数比较为零。</target>
        </trans-unit>
        <trans-unit id="1ce1caed837c07a48f6a88d0ea42bd39f49a6272" translate="yes" xml:space="preserve">
          <source>Conditionally executes code.</source>
          <target state="translated">有条件地执行代码。</target>
        </trans-unit>
        <trans-unit id="5829addbd65734c4f2d8dad3852c632235ce06d4" translate="yes" xml:space="preserve">
          <source>Configures the handler to be called by all &lt;a href=&quot;../error#Bounds_checking&quot;&gt;bounds-checked functions&lt;/a&gt; on a runtime constraint violation or restores the default handler (if &lt;code&gt;handler&lt;/code&gt; is a null pointer).</source>
          <target state="translated">将处理程序配置为在违反运行时约束时由所有经过&lt;a href=&quot;../error#Bounds_checking&quot;&gt;边界检查的函数&lt;/a&gt;调用，或恢复默认处理程序（如果 &lt;code&gt;handler&lt;/code&gt; 为空指针）。</target>
        </trans-unit>
        <trans-unit id="24dbea7a3dbb1c93c581fc08dcbaae936c7b5b98" translate="yes" xml:space="preserve">
          <source>Conformance</source>
          <target state="translated">Conformance</target>
        </trans-unit>
        <trans-unit id="733fd2b4c4e1bca4c7d0e3c2e1c341bcd1d34269" translate="yes" xml:space="preserve">
          <source>Constant</source>
          <target state="translated">Constant</target>
        </trans-unit>
        <trans-unit id="01f3d0f48081336b622122d8a98fa589e08cae6c" translate="yes" xml:space="preserve">
          <source>Constant expressions</source>
          <target state="translated">常量表达式</target>
        </trans-unit>
        <trans-unit id="b1b91cf185f43f995ea5e1bbd7b583d233b1e42c" translate="yes" xml:space="preserve">
          <source>Constant values of certain types may be embedded in the source code of a C program using specialized expressions known as literals (for lvalue expressions) and constants (for non-lvalue expressions).</source>
          <target state="translated">某些类型的常量值可以使用专门的表达式,即 literals(对于 lvalue 表达式)和常量(对于非 lvalue 表达式)嵌入 C 程序的源代码中。</target>
        </trans-unit>
        <trans-unit id="0f386d7e7881b32fa39cb7b62bdb15c0f3a4c0e1" translate="yes" xml:space="preserve">
          <source>Constants</source>
          <target state="translated">Constants</target>
        </trans-unit>
        <trans-unit id="87c4159a742ed8e414ffd5bae72f84a5d574be41" translate="yes" xml:space="preserve">
          <source>Constants and literals</source>
          <target state="translated">常量和字数</target>
        </trans-unit>
        <trans-unit id="625f65880cedb4712e1d5945dc325c138ae5abe2" translate="yes" xml:space="preserve">
          <source>Constructs a value of type &lt;code&gt;wctrans_t&lt;/code&gt; that describes a LC_CTYPE category of wide character mapping. It may be one of the standard mappings, or a locale-specific mapping, such as &lt;code&gt;&quot;tojhira&quot;&lt;/code&gt; or &lt;code&gt;&quot;tojkana&quot;&lt;/code&gt;.</source>
          <target state="translated">构造一个类型为 &lt;code&gt;wctrans_t&lt;/code&gt; 的值，该值描述了宽字符映射的LC_CTYPE类别。它可以是标准映射之一，也可以是特定于语言环境的映射，例如 &lt;code&gt;&quot;tojhira&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;tojkana&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ccc1814324121e43fbfd9c7fd0178bbe7dcfb1f9" translate="yes" xml:space="preserve">
          <source>Constructs a value of type &lt;code&gt;wctype_t&lt;/code&gt; that describes a LC_CTYPE category of wide character classification. It may be one of the standard classification categories, or a locale-specific category, such as &lt;code&gt;&quot;jkanji&quot;&lt;/code&gt;.</source>
          <target state="translated">构造一个类型为 &lt;code&gt;wctype_t&lt;/code&gt; 的值，该值描述了宽字符分类的LC_CTYPE类别。它可以是标准分类类别之一，也可以是特定于语言环境的类别，例如 &lt;code&gt;&quot;jkanji&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e0c8168c0cfbada2990dd2ad8b3fe0fafbfb373f" translate="yes" xml:space="preserve">
          <source>Constructs an unnamed object of specified character array type in-place, used when a character string needs to be embedded in source code.</source>
          <target state="translated">就地构造一个指定字符数组类型的未命名对象,当需要在源代码中嵌入字符字符串时使用。</target>
        </trans-unit>
        <trans-unit id="7144d435c6f6eed65fdfb01892ed2517b9a5f780" translate="yes" xml:space="preserve">
          <source>Constructs an unnamed object of specified type in-place, used when a variable of array, struct, or union type would be needed only once.</source>
          <target state="translated">在原地构造一个指定类型的未命名对象,当一个数组、结构体或联合体类型的变量只需要一次时使用。</target>
        </trans-unit>
        <trans-unit id="94ba0441a632d1d40b442b189f4d839da4c6f833" translate="yes" xml:space="preserve">
          <source>Convenience macro which can be used to specify that an object has &lt;a href=&quot;../language/storage_duration&quot;&gt;thread-local storage duration&lt;/a&gt;.</source>
          <target state="translated">便利宏，可用于指定对象的&lt;a href=&quot;../language/storage_duration&quot;&gt;线程本地存储期限&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9151f8433f795cb0f0b5b6743aeb7de77ec49f00" translate="yes" xml:space="preserve">
          <source>Conversion</source>
          <target state="translated">Conversion</target>
        </trans-unit>
        <trans-unit id="c984c12517b0136cf8b6803f48a375cfb48f60b5" translate="yes" xml:space="preserve">
          <source>Conversion as if by assignment</source>
          <target state="translated">视同转让而转换</target>
        </trans-unit>
        <trans-unit id="5980eba8f0b4f2f1cc9d2b0ed71af9f29a9903b9" translate="yes" xml:space="preserve">
          <source>Conversion of a value of any type to any &lt;a href=&quot;types#Compatible_types&quot;&gt;compatible type&lt;/a&gt; is always a no-op and does not change the representation.</source>
          <target state="translated">将任何类型的值转换为任何&lt;a href=&quot;types#Compatible_types&quot;&gt;兼容类型&lt;/a&gt;始终是禁止操作，并且不会更改表示形式。</target>
        </trans-unit>
        <trans-unit id="b08eaadf77cfdba7944ddcaf69eee5a983b74af3" translate="yes" xml:space="preserve">
          <source>Conversions</source>
          <target state="translated">Conversions</target>
        </trans-unit>
        <trans-unit id="78181f4b075c67c1b93d70dd04f6600b3ede87c6" translate="yes" xml:space="preserve">
          <source>Conversions between pointers and integers (except from pointer to _Bool and from integer constant expression with the value zero to pointer), between pointers to objects (except where either to or from is a pointer to void) and conversions between pointers to functions (except when the functions have compatible types) are never implicit and require a &lt;a href=&quot;cast&quot;&gt;cast operator&lt;/a&gt;.</source>
          <target state="translated">指针与整数之间的转换（从指向_Bool的指针和从值为零的整数常量表达式到指针的转换除外），在对象的指针之间的转换（除非to或from是指向void的指针）以及指针在函数之间的转换（除非当函数具有兼容的类型）永远不会隐式并且需要强制转换&lt;a href=&quot;cast&quot;&gt;运算符&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="82a308da2fa6926a6b6c6dd2f205fd8788bcad75" translate="yes" xml:space="preserve">
          <source>Conversions take place in the following situations:</source>
          <target state="translated">在下列情况下进行转换:</target>
        </trans-unit>
        <trans-unit id="b33060b95c6156e56397175f292d4d45c6d6b5b4" translate="yes" xml:space="preserve">
          <source>Conversions to numeric formats</source>
          <target state="translated">转换为数字格式</target>
        </trans-unit>
        <trans-unit id="69cac274e6b28bb335c35746d6cf8b2fc73bbb4f" translate="yes" xml:space="preserve">
          <source>Converts a multibyte character whose first byte is pointed to by &lt;code&gt;s&lt;/code&gt; to a wide character, written to &lt;code&gt;*pwc&lt;/code&gt; if &lt;code&gt;pwc&lt;/code&gt; is not null.</source>
          <target state="translated">将第一个字节由 &lt;code&gt;s&lt;/code&gt; 指向的多字节字符转换为宽字符，如果 &lt;code&gt;pwc&lt;/code&gt; 不为null，则将其写入 &lt;code&gt;*pwc&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f7e9a446c5b84278a0ced9cb286227ee420c1a0a" translate="yes" xml:space="preserve">
          <source>Converts a narrow multibyte character to its wide character representation.</source>
          <target state="translated">将一个窄的多字节字符转换为其宽的字符表示。</target>
        </trans-unit>
        <trans-unit id="7438601c837acb2baa4f7b08761be638767a0fb4" translate="yes" xml:space="preserve">
          <source>Converts a single code point from its narrow multibyte character representation to its variable-length 16-bit wide character representation (typically, UTF-16).</source>
          <target state="translated">将单个码点从狭义的多字节字符表示法转换为可变长度的16位宽字符表示法(通常为UTF-16)。</target>
        </trans-unit>
        <trans-unit id="0ffd99b88e90d43a9dbbf14daf8d8252d500de2c" translate="yes" xml:space="preserve">
          <source>Converts a single code point from its narrow multibyte character representation to its variable-length 32-bit wide character representation (but typically, UTF-32).</source>
          <target state="translated">将单个码点从窄的多字节字符表示法转换为可变长度的32位宽字符表示法(但通常是UTF-32)。</target>
        </trans-unit>
        <trans-unit id="cb96eb234a6e56a369a809859f2f3dd01677ca1d" translate="yes" xml:space="preserve">
          <source>Converts a single code point from its variable-length 16-bit wide character representation (typically, UTF-16) to its narrow multibyte character representation.</source>
          <target state="translated">将单个码点从可变长度的16位宽字符表示法(通常为UTF-16)转换为窄的多字节字符表示法。</target>
        </trans-unit>
        <trans-unit id="d96f0b90ea4f0c064b3c16639100cb4890c75aa0" translate="yes" xml:space="preserve">
          <source>Converts a single code point from its variable-length 32-bit wide character representation (but typically, UTF-32) to its narrow multibyte character representation.</source>
          <target state="translated">将单个码点从可变长度的32位宽字符表示法(但通常是UTF-32)转换为窄的多字节字符表示法。</target>
        </trans-unit>
        <trans-unit id="712188da508186849026fb3c8bd4c53083239bd2" translate="yes" xml:space="preserve">
          <source>Converts a wide character to its narrow multibyte representation.</source>
          <target state="translated">将宽字符转换为窄的多字节表示。</target>
        </trans-unit>
        <trans-unit id="20aba8933b1ce3e51b50d19af2bb5cd6151f383b" translate="yes" xml:space="preserve">
          <source>Converts the date and time information from a given calendar time &lt;code&gt;time&lt;/code&gt; to a null-terminated multibyte character string &lt;code&gt;str&lt;/code&gt; according to format string &lt;code&gt;format&lt;/code&gt;. Up to &lt;code&gt;count&lt;/code&gt; bytes are written.</source>
          <target state="translated">从给定的日历时间的日期和时间信息转换 &lt;code&gt;time&lt;/code&gt; 到一个空终止多字节字符的字符串 &lt;code&gt;str&lt;/code&gt; 根据格式字符串 &lt;code&gt;format&lt;/code&gt; 。最多 &lt;code&gt;count&lt;/code&gt; 个字节写入。</target>
        </trans-unit>
        <trans-unit id="84c9055ae6194fffb1394c02ee65a491c7f3c9ac" translate="yes" xml:space="preserve">
          <source>Converts the date and time information from a given calendar time &lt;code&gt;time&lt;/code&gt; to a null-terminated wide character string &lt;code&gt;str&lt;/code&gt; according to format string &lt;code&gt;format&lt;/code&gt;. Up to &lt;code&gt;count&lt;/code&gt; bytes are written.</source>
          <target state="translated">从给定的日历时间的日期和时间信息转换 &lt;code&gt;time&lt;/code&gt; 到一个空终止宽字符串 &lt;code&gt;str&lt;/code&gt; 根据格式字符串 &lt;code&gt;format&lt;/code&gt; 。最多 &lt;code&gt;count&lt;/code&gt; 个字节写入。</target>
        </trans-unit>
        <trans-unit id="519b80c3038fd902484f3879ce4d6e40b47a488a" translate="yes" xml:space="preserve">
          <source>Converts the given character to lowercase according to the character conversion rules defined by the currently installed C locale.</source>
          <target state="translated">根据当前安装的C语言环境定义的字符转换规则,将给定字符转换为小写。</target>
        </trans-unit>
        <trans-unit id="f569145b51d5c5bd1a8f3f9cda6c230ee4a033fa" translate="yes" xml:space="preserve">
          <source>Converts the given character to uppercase according to the character conversion rules defined by the currently installed C locale.</source>
          <target state="translated">根据当前安装的C语言环境定义的字符转换规则,将给定字符转换为大写字母。</target>
        </trans-unit>
        <trans-unit id="4e2c2190b4ebc6c640c23909d4015a7b7c92b75c" translate="yes" xml:space="preserve">
          <source>Converts the given wide character to lowercase, if possible.</source>
          <target state="translated">如果可能的话,将给定的宽字符转换为小写。</target>
        </trans-unit>
        <trans-unit id="9a302cdd09a562f6faf8a71da6652ad5c7071026" translate="yes" xml:space="preserve">
          <source>Converts the given wide character to uppercase, if possible.</source>
          <target state="translated">如果可能的话,将给定的宽字符转换为大写字母。</target>
        </trans-unit>
        <trans-unit id="379c410318b1052040824f4b78e1f453a2e061b8" translate="yes" xml:space="preserve">
          <source>Converts the implementation-defined character string &lt;code&gt;arg&lt;/code&gt; into the corresponding quiet NaN value, as if by calling &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;strtof&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;strtod&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;strtold&lt;/a&gt;&lt;/code&gt;, respectively, as follows:</source>
          <target state="translated">将实现定义的字符串 &lt;code&gt;arg&lt;/code&gt; 转换为相应的安静NaN值，就像分别通过分别调用 &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;strtof&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;strtod&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;strtold&lt;/a&gt;&lt;/code&gt; 一样，如下所示：</target>
        </trans-unit>
        <trans-unit id="d3125c64cd58a8e8c4a1e00a8a7f5cca65c1f3db" translate="yes" xml:space="preserve">
          <source>Copies the wide character &lt;code&gt;ch&lt;/code&gt; into each of the first &lt;code&gt;count&lt;/code&gt; wide characters of the wide character array (or integer array of compatible type) pointed to by &lt;code&gt;dest&lt;/code&gt;.</source>
          <target state="translated">将宽字符 &lt;code&gt;ch&lt;/code&gt; 复制到 &lt;code&gt;dest&lt;/code&gt; 所指向的宽字符数组（或兼容类型的整数数组）的每个第一个 &lt;code&gt;count&lt;/code&gt; 宽字符中。</target>
        </trans-unit>
        <trans-unit id="a1a972dceff401c8f705084b99291771aca6d4f0" translate="yes" xml:space="preserve">
          <source>Corresponding bit fields must have the same widths.</source>
          <target state="translated">相应的位字段必须有相同的宽度。</target>
        </trans-unit>
        <trans-unit id="c7655b56c64b8e8974eef2a42e2f7caf3220ca70" translate="yes" xml:space="preserve">
          <source>Corresponding members must be declared in the same order (structures only)</source>
          <target state="translated">对应的成员必须以相同的顺序声明(仅结构)。</target>
        </trans-unit>
        <trans-unit id="6ee0a78dc7e88cdbfe34cb24cb35cc308d3ce55a" translate="yes" xml:space="preserve">
          <source>Create a file for read/write</source>
          <target state="translated">创建一个读/写文件</target>
        </trans-unit>
        <trans-unit id="3f00954c254e5e03c34d4c5d0355138a84dcbd5e" translate="yes" xml:space="preserve">
          <source>Create a file for writing</source>
          <target state="translated">创建一个文件,用于书写</target>
        </trans-unit>
        <trans-unit id="d7fab829ef004b63b0ae817164eec26b76e27830" translate="yes" xml:space="preserve">
          <source>Creates a new mutex object with &lt;code&gt;type&lt;/code&gt;. The object pointed to by &lt;code&gt;mutex&lt;/code&gt; is set to an identifier of the newly created mutex.</source>
          <target state="translated">创建一个 &lt;code&gt;type&lt;/code&gt; 为的新互斥对象。 &lt;code&gt;mutex&lt;/code&gt; 指向的对象设置为新创建的互斥锁的标识符。</target>
        </trans-unit>
        <trans-unit id="9b06bf69a45cd02d25cf20b979aa35310bf22a78" translate="yes" xml:space="preserve">
          <source>Creates a new thread executing the function &lt;code&gt;func&lt;/code&gt;. The function is invoked as &lt;code&gt;func(arg)&lt;/code&gt;.</source>
          <target state="translated">创建一个执行功能 &lt;code&gt;func&lt;/code&gt; 的新线程。该函数作为 &lt;code&gt;func(arg)&lt;/code&gt; 调用。</target>
        </trans-unit>
        <trans-unit id="571e4e2856d60889cd6291a7b577569ac1fb4093" translate="yes" xml:space="preserve">
          <source>Creates new thread-specific storage key and stores it in the object pointed to by &lt;code&gt;tss_key&lt;/code&gt;. Although the same key value may be used by different threads, the values bound to the key by &lt;code&gt;&lt;a href=&quot;tss_set&quot;&gt;tss_set&lt;/a&gt;&lt;/code&gt; are maintained on a per-thread basis and persist for the life of the calling thread.</source>
          <target state="translated">创建新的特定于线程的存储密钥，并将其存储在 &lt;code&gt;tss_key&lt;/code&gt; 指向的对象中。尽管相同的键值可由不同的线程使用，但 &lt;code&gt;&lt;a href=&quot;tss_set&quot;&gt;tss_set&lt;/a&gt;&lt;/code&gt; 绑定到键的值是在每个线程的基础上维护的，并且在调用线程的生命周期内一直存在。</target>
        </trans-unit>
        <trans-unit id="b3301d9d8a5f4cade27f8ed51c3e2eb33faf2bb3" translate="yes" xml:space="preserve">
          <source>Critical UB is undefined behavior that might perform a memory write or a volatile memory read out of bounds of any object. A program that has critical undefined behavior may be susceptible to security exploits.</source>
          <target state="translated">临界UB是未定义行为,可能会执行内存写入或易失性内存读出任何对象的边界。一个程序如果有关键的未定义行为,可能会受到安全漏洞的影响。</target>
        </trans-unit>
        <trans-unit id="48d3d0e79fd065ba50641549dc0f31bdbbbabe14" translate="yes" xml:space="preserve">
          <source>Critical undefined behavior</source>
          <target state="translated">关键的未定义行为</target>
        </trans-unit>
        <trans-unit id="cde75a84c505736a639dce4f3db8eb94d6550d9e" translate="yes" xml:space="preserve">
          <source>Current calendar time encoded as &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;time_t&lt;/a&gt;&lt;/code&gt; object on success, &lt;code&gt;(&lt;a href=&quot;time_t&quot;&gt;time_t&lt;/a&gt;)(-1)&lt;/code&gt; on error. If &lt;code&gt;arg&lt;/code&gt; is not a null pointer, the return value is also stored in the object pointed to by &lt;code&gt;arg&lt;/code&gt;.</source>
          <target state="translated">成功时将当前日历时间编码为 &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;time_t&lt;/a&gt;&lt;/code&gt; 对象，错误时将编码为 &lt;code&gt;(&lt;a href=&quot;time_t&quot;&gt;time_t&lt;/a&gt;)(-1)&lt;/code&gt; 。如果 &lt;code&gt;arg&lt;/code&gt; 不是空指针，则返回值也存储在 &lt;code&gt;arg&lt;/code&gt; 指向的对象中。</target>
        </trans-unit>
        <trans-unit id="d1a550d08342a0a1a6248c5f115bf82d6658049a" translate="yes" xml:space="preserve">
          <source>D within thread 2, nothing prevents D from appearing before A in the modification order of y, and B from appearing before C in the modification order of x. The side-effect of D on y could be visible to the load A in thread 1 while the side effect of B on x could be visible to the load C in thread 2. In particular, this may occur if D is completed before C in thread 2, either due to compiler reordering or at runtime.</source>
          <target state="translated">线程2内的D,没有什么可以阻止D出现在A之前的y的修改顺序,也没有什么可以阻止B出现在C之前的x的修改顺序,D对y的副作用可能对线程1中的负载A可见,而B对x的副作用可能对线程2中的负载C可见。特别是,如果D在线程2中先于C完成,可能会出现这种情况,这可能是由于编译器重新排序或在运行时造成的。</target>
        </trans-unit>
        <trans-unit id="12130df9add30c0ad6c8facc749f7941f22cb5a0" translate="yes" xml:space="preserve">
          <source>DECIMAL_DIG</source>
          <target state="translated">DECIMAL_DIG</target>
        </trans-unit>
        <trans-unit id="2d1df1e76038d57ea00e3dd0686a5e2fe8b90691" translate="yes" xml:space="preserve">
          <source>Data models</source>
          <target state="translated">数据模型</target>
        </trans-unit>
        <trans-unit id="cedc7364b9c54060c8937af16ca1f7f300c926d1" translate="yes" xml:space="preserve">
          <source>Data read in from a text stream is guaranteed to compare equal to the data that were earlier written out to that stream only if all of the following is true:</source>
          <target state="translated">只有当以下所有条件为真时,才能保证从文本流中读入的数据与之前写入该流的数据进行相同的比较。</target>
        </trans-unit>
        <trans-unit id="07c9c3a5e0d97aef72f69b7e5ba94a6765f2a6d3" translate="yes" xml:space="preserve">
          <source>Date and time</source>
          <target state="translated">日期和时间</target>
        </trans-unit>
        <trans-unit id="5b0b556cd60211a5522983788620b6746c7543cf" translate="yes" xml:space="preserve">
          <source>Date and time utilities</source>
          <target state="translated">公用事业的日期和时间</target>
        </trans-unit>
        <trans-unit id="a2dfedeffd1ead187411349e305b1fe627303452" translate="yes" xml:space="preserve">
          <source>Day of the week</source>
          <target state="translated">一周中的一天</target>
        </trans-unit>
        <trans-unit id="1efe459545896a080ea552260e3ba2caa4f8d75e" translate="yes" xml:space="preserve">
          <source>Day of the year/month</source>
          <target state="translated">年月日</target>
        </trans-unit>
        <trans-unit id="8fa7848b2be3ca4b1659ed978010f39a06d41489" translate="yes" xml:space="preserve">
          <source>Daylight Saving Time flag. The value is positive if DST is in effect, zero if not and negative if no information is available</source>
          <target state="translated">日光节约时间标志。如果DST生效,则该值为正,如果不生效则为零,如果没有信息则为负。</target>
        </trans-unit>
        <trans-unit id="d3e6f22a4ad377eca5934960c8545c3f833b1707" translate="yes" xml:space="preserve">
          <source>Deallocates the space previously allocated by &lt;code&gt;&lt;a href=&quot;malloc&quot;&gt;malloc()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;calloc&quot;&gt;calloc()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;aligned_alloc&lt;/code&gt;,(since C11) or &lt;code&gt;&lt;a href=&quot;realloc&quot;&gt;realloc()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">取消分配先前由 &lt;code&gt;&lt;a href=&quot;malloc&quot;&gt;malloc()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;calloc&quot;&gt;calloc()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;aligned_alloc&lt;/code&gt; ，（自C11起）或 &lt;code&gt;&lt;a href=&quot;realloc&quot;&gt;realloc()&lt;/a&gt;&lt;/code&gt; 分配的空间。</target>
        </trans-unit>
        <trans-unit id="b9b846963186dedc9a34aab11fab9a0a092e2d1b" translate="yes" xml:space="preserve">
          <source>Declarations</source>
          <target state="translated">Declarations</target>
        </trans-unit>
        <trans-unit id="749ccabedd0701c0c9714d9c1cdd4f12526e6e72" translate="yes" xml:space="preserve">
          <source>Declarations may appear in any scope. Each declaration ends with a semicolon (just like &lt;a href=&quot;statements&quot;&gt;a statement&lt;/a&gt;) and consists of two distinct parts:</source>
          <target state="translated">声明可以出现在任何范围内。每个声明以分号结尾（就像&lt;a href=&quot;statements&quot;&gt;statement一样&lt;/a&gt;），并且由两个不同的部分组成：</target>
        </trans-unit>
        <trans-unit id="498a79c2f403d3ef0ef459653265dbe039de60f8" translate="yes" xml:space="preserve">
          <source>Declarations of any variably-modified types may appear only at &lt;a href=&quot;scope&quot;&gt;block scope&lt;/a&gt; or function prototype scope and cannot be members of structs or unions. Although &lt;a href=&quot;array&quot;&gt;VLA&lt;/a&gt; can only have automatic &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt;, a VM type such as a pointer to a VLA may be static. There are other restrictions on the use of VM types, see &lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;, &lt;a href=&quot;switch&quot;&gt;switch&lt;/a&gt;. &lt;code&gt;&lt;a href=&quot;../program/longjmp&quot;&gt;longjmp&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">任何可变修改类型的声明只能出现在&lt;a href=&quot;scope&quot;&gt;块作用域&lt;/a&gt;或函数原型作用域中，而不能是结构或联合的成员。尽管&lt;a href=&quot;array&quot;&gt;VLA&lt;/a&gt;只能具有自动&lt;a href=&quot;storage_duration&quot;&gt;存储期限&lt;/a&gt;，但是VM类型（例如指向VLA的指针）可能是静态的。VM类型的使用还有其他限制，请参阅&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;，&lt;a href=&quot;switch&quot;&gt;switch&lt;/a&gt;。 &lt;code&gt;&lt;a href=&quot;../program/longjmp&quot;&gt;longjmp&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="65fb5fdee4b95dce48f2a6be467d4b66c9cfaed7" translate="yes" xml:space="preserve">
          <source>Declarations of objects &lt;a href=&quot;storage_duration&quot;&gt;with linkage&lt;/a&gt; (external or internal) can be repeated:</source>
          <target state="translated">&lt;a href=&quot;storage_duration&quot;&gt;具有链接&lt;/a&gt;的对象（外部或内部）的声明可以重复：</target>
        </trans-unit>
        <trans-unit id="50dd433317470a03afe915a58adaf99026617f03" translate="yes" xml:space="preserve">
          <source>Declarations with external linkage are commonly made available in header files so that all translation units that &lt;a href=&quot;../preprocessor/include&quot;&gt;#include&lt;/a&gt; the file may refer to the same identifier that are defined elsewhere.</source>
          <target state="translated">具有外部链接声明通常由在头文件中可用，这样，所有的翻译单元&lt;a href=&quot;../preprocessor/include&quot;&gt;＃包括&lt;/a&gt;该文件可能指的是其它地方定义的相同的标识符。</target>
        </trans-unit>
        <trans-unit id="2487e41670058d63f8493da3e66e37364b0bb53c" translate="yes" xml:space="preserve">
          <source>Declarators</source>
          <target state="translated">Declarators</target>
        </trans-unit>
        <trans-unit id="a438543b4e82bf4692dd52fa11185961f695d7cf" translate="yes" xml:space="preserve">
          <source>Declares a member with explicit width, in bits. Adjacent bit field members may be packed to share and straddle the individual bytes.</source>
          <target state="translated">声明一个具有显式宽度的成员,以比特为单位。相邻的位字段成员可以被打包,以共享和跨越单个字节。</target>
        </trans-unit>
        <trans-unit id="b76d52d6a4f58b1756dbf7dc7ed7c25dc32036e0" translate="yes" xml:space="preserve">
          <source>Declares an &lt;a href=&quot;https://en.wikipedia.org/wiki/inline_function&quot;&gt;inline function&lt;/a&gt;.</source>
          <target state="translated">声明一个&lt;a href=&quot;https://en.wikipedia.org/wiki/inline_function&quot;&gt;内联函数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="479af35b0f110787bdde80cea52483776eb082c3" translate="yes" xml:space="preserve">
          <source>Default &lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;rounding direction&lt;/a&gt; and &lt;a href=&quot;../types/limits/flt_eval_method&quot;&gt;precision&lt;/a&gt; are in effect when the floating constants are converted into internal representations, and &lt;a href=&quot;../numeric/fenv/fe_exceptions&quot;&gt;floating-point exceptions&lt;/a&gt; are not raised even if &lt;a href=&quot;../preprocessor/impl&quot;&gt;&lt;code&gt; #pragma STDC FENV_ACCESS&lt;/code&gt;&lt;/a&gt; is in effect (for execution-time conversion of character strings, &lt;code&gt;&lt;a href=&quot;../string/byte/strtof&quot;&gt;strtod&lt;/a&gt;&lt;/code&gt; can be used). Note that this differs from &lt;a href=&quot;constant_expression&quot;&gt;arithmetic constant expressions&lt;/a&gt; of floating type.</source>
          <target state="translated">当浮点常量转换为内部表示形式时，默认的&lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;舍入方向&lt;/a&gt;和&lt;a href=&quot;../types/limits/flt_eval_method&quot;&gt;精度&lt;/a&gt;有效，即使&lt;a href=&quot;../preprocessor/impl&quot;&gt; &lt;code&gt; #pragma STDC FENV_ACCESS&lt;/code&gt; &lt;/a&gt;有效，也不会引发&lt;a href=&quot;../numeric/fenv/fe_exceptions&quot;&gt;浮点异常&lt;/a&gt;（对于字符串的执行时转换，可以使用 &lt;code&gt;&lt;a href=&quot;../string/byte/strtof&quot;&gt;strtod&lt;/a&gt;&lt;/code&gt; ） 。注意，这与浮点型的&lt;a href=&quot;constant_expression&quot;&gt;算术常数表达式&lt;/a&gt;不同。</target>
        </trans-unit>
        <trans-unit id="21463b49a73f80192975053d7c51b6766c28139a" translate="yes" xml:space="preserve">
          <source>Default argument promotions</source>
          <target state="translated">默认参数促销</target>
        </trans-unit>
        <trans-unit id="d51786c7e25b0e6dca93c44db2e6620c91b5706f" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;assert.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">定义于头文件 &lt;code&gt;&amp;lt;assert.h&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="53b12cc0a64e5997f555f4552d8c0f5a1798ae66" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">定义于头文件 &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="90f2a795c1a351609a312fd95460d08cf184bd87" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;ctype.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">定义于头文件 &lt;code&gt;&amp;lt;ctype.h&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b76614d13fbb267406c567200d837b24b3fde09b" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;errno.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">定义于头文件 &lt;code&gt;&amp;lt;errno.h&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="80bf26c3624bf6ce9697ecba933de914daf63a5a" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;fenv.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">定义于头文件 &lt;code&gt;&amp;lt;fenv.h&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cd9bc4c7f48e74e44b5198fbf6ade033d2ef3214" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;float.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">定义于头文件 &lt;code&gt;&amp;lt;float.h&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f9c7c1c3d49935948c03fc2e9d9fd5cb0acf7b6e" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;inttypes.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">定义于头文件 &lt;code&gt;&amp;lt;inttypes.h&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c5df25381e8feefe92fdd8b28465b19ae2f4972c" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">定义于头文件 &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4ad2bbe9040c61764f1bfc89807c753f787521d0" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;limits.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">定义于头文件 &lt;code&gt;&amp;lt;limits.h&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="acbd16aaad15089951f12b998aa7ea0853e93e93" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;locale.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">定义于头文件 &lt;code&gt;&amp;lt;locale.h&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7025b36c2c07b19a8d8e66c935fb4f80ce6c1685" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;math.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">定义于头文件 &lt;code&gt;&amp;lt;math.h&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="705fca3e55ebf8cbefec135f8a856278153e2ce5" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;setjmp.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">定义于头文件 &lt;code&gt;&amp;lt;setjmp.h&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ecd6850fd735cc0f8846abbf1075afdf10ec94f2" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;signal.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">定义于头文件 &lt;code&gt;&amp;lt;signal.h&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="53031c947e0190bfa35551ccad1808f03a3dc551" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;stdalign.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">定义于头文件 &lt;code&gt;&amp;lt;stdalign.h&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="245dc9819128f99f4333f72f1e35680c85852dbb" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;stdarg.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">定义于头文件 &lt;code&gt;&amp;lt;stdarg.h&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e2f62efdddd63721d81b871af155dbbf79a1a53" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;stdatomic.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">定义于头文件 &lt;code&gt;&amp;lt;stdatomic.h&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2bd2583ed48877fab6813145157134c03b0da7df" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">定义于头文件 &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b70a61b2efac85d947d63495a0dbd17f5e7eb999" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;stdint.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">定义于头文件 &lt;code&gt;&amp;lt;stdint.h&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7b92b8bfeac671700e767b6a63a2a1467e903324" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;stdio.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">定义于头文件 &lt;code&gt;&amp;lt;stdio.h&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8f4d9d59d3d7d5aef5cc1ea4c46ea799408a374d" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">定义于头文件 &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="521fccfa0e87c453cf2e8f167e2684f7ed7209d0" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;stdnoreturn.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">定义于头文件 &lt;code&gt;&amp;lt;stdnoreturn.h&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f5fa73f7f3a4335015f1f23a0732c950803d482b" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;string.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">定义于头文件 &lt;code&gt;&amp;lt;string.h&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1bbdc0981bd66c81cf104210dcd830723ba381c4" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">定义于头文件 &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="555423c73974a949e00ecd09ae4522ff177b6ba3" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;threads.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">定义于头文件 &lt;code&gt;&amp;lt;threads.h&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4048cff46ea43962575dde93962f1b588433080f" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;time.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">定义于头文件 &lt;code&gt;&amp;lt;time.h&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6dfcc0c8bd903cf2bdcde1e66a702128ff94fbfa" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;uchar.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">定义于头文件 &lt;code&gt;&amp;lt;uchar.h&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ecb0715cadd781ce84b451ce8e4acdd4dc7d0232" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;wchar.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">定义于头文件 &lt;code&gt;&amp;lt;wchar.h&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eb6e4f42471d8124c8cf9d17dd195e977e3849ff" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;wctype.h&amp;gt;&lt;/code&gt;</source>
          <target state="translated">定义于头文件 &lt;code&gt;&amp;lt;wctype.h&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ab42660565c96e634b99d6325eb1b11da87c3efc" translate="yes" xml:space="preserve">
          <source>Defines the semantics of computer memory storage for the purpose of the C abstract machine.</source>
          <target state="translated">为C抽象机的目的定义了计算机内存存储的语义。</target>
        </trans-unit>
        <trans-unit id="bf1be2b7ad07bae2fe92475d10173eb638774def" translate="yes" xml:space="preserve">
          <source>Definition</source>
          <target state="translated">Definition</target>
        </trans-unit>
        <trans-unit id="15225baac48fc3d689cb2b0f74b936eff4339ff7" translate="yes" xml:space="preserve">
          <source>Definitions</source>
          <target state="translated">Definitions</target>
        </trans-unit>
        <trans-unit id="b9f352ac1857e844fd93783413696f5ee3b91411" translate="yes" xml:space="preserve">
          <source>Definitions of functions include sequences of &lt;a href=&quot;statements&quot;&gt;statements&lt;/a&gt; and &lt;a href=&quot;declarations&quot;&gt;declarations&lt;/a&gt;, some of which include &lt;a href=&quot;expressions&quot;&gt;expressions&lt;/a&gt;, which specify the computations to be performed by the program.</source>
          <target state="translated">函数的定义包括&lt;a href=&quot;statements&quot;&gt;语句&lt;/a&gt;和&lt;a href=&quot;declarations&quot;&gt;声明的&lt;/a&gt;序列，其中一些包括&lt;a href=&quot;expressions&quot;&gt;表达式&lt;/a&gt;，这些表达式指定程序要执行的计算。</target>
        </trans-unit>
        <trans-unit id="d5c2f3b1691c162974666c6b32fe851f22334bf1" translate="yes" xml:space="preserve">
          <source>Deletes the file identified by character string pointed to by &lt;code&gt;fname&lt;/code&gt;.</source>
          <target state="translated">删除由 &lt;code&gt;fname&lt;/code&gt; 指向的字符串标识的文件。</target>
        </trans-unit>
        <trans-unit id="6821f0c7515e1af2b09d1caee8e7ee8be55d23ff" translate="yes" xml:space="preserve">
          <source>Demonstrates how to inform a program about where to find its input and where to write its results. Invocation: ./a.out indatafile outdatafile.</source>
          <target state="translated">演示如何通知程序在哪里找到它的输入和在哪里写入它的结果。调用:./a.out indatafile outdatafile。</target>
        </trans-unit>
        <trans-unit id="107363e042b2a4793f67270f98d3c7305ba956f9" translate="yes" xml:space="preserve">
          <source>Demonstrates the use of isalnum() with different locales (OS-specific).</source>
          <target state="translated">演示在不同的语言环境下使用isalnum()(操作系统专用)。</target>
        </trans-unit>
        <trans-unit id="8bec99b36261ae64217d042ec118a2c264d9ce33" translate="yes" xml:space="preserve">
          <source>Demonstrates the use of isalpha() with different locales (OS-specific).</source>
          <target state="translated">展示isalpha()在不同语言环境下的使用(操作系统专用)。</target>
        </trans-unit>
        <trans-unit id="7b2ffabd65a5c6d55404aee122640dc7ff1e1395" translate="yes" xml:space="preserve">
          <source>Depending on the computer architecture, a &lt;a href=&quot;https://en.wikipedia.org/wiki/Byte&quot;&gt;byte&lt;/a&gt; may consist of 8 or more bits, the exact number provided as &lt;code&gt;&lt;a href=&quot;../types/limits&quot;&gt;CHAR_BIT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">根据计算机的体系结构，一个&lt;a href=&quot;https://en.wikipedia.org/wiki/Byte&quot;&gt;字节&lt;/a&gt;可以由8个或更多位组成，确切的数字为 &lt;code&gt;&lt;a href=&quot;../types/limits&quot;&gt;CHAR_BIT&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dec3b6d46e827cc481476ff03cd71af78767baf0" translate="yes" xml:space="preserve">
          <source>Dereference</source>
          <target state="translated">Dereference</target>
        </trans-unit>
        <trans-unit id="b61f3c0aeb3cddcd6eafde1041344977a1b7e38d" translate="yes" xml:space="preserve">
          <source>Dereferencing a function pointer yields the function designator for the pointed-to function:</source>
          <target state="translated">Dereferencing a function pointer 产生指向函数的函数代号。</target>
        </trans-unit>
        <trans-unit id="443e0815b33ce17780b995cb60837ff3ec40c823" translate="yes" xml:space="preserve">
          <source>Dereferencing a null pointer, a pointer to an object outside of its lifetime (a dangling pointer), a misaligned pointer, or a pointer with indeterminate value is undefined behavior, except when the dereference operator is nullified by applying the address-of operator to its result, as in &lt;code&gt;&amp;amp;*E&lt;/code&gt;.</source>
          <target state="translated">取消引用空指针，指向其生命周期之外的对象的指针（悬空指针），未对齐的指针或具有不确定值的指针是未定义的行为，除非通过将address-of运算符应用于其取消引用运算符使其无效结果，如 &lt;code&gt;&amp;amp;*E&lt;/code&gt; 所示。</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="d6ebeef73eef6a80573532642182d125a4f29dce" translate="yes" xml:space="preserve">
          <source>Despite being specified &quot;as if&quot; a temporary buffer is used, actual implementations of this function do not incur the overhead or double copying or extra memory. A common approach (glibc and bsd libc) is to copy bytes forwards from the beginning of the buffer if the destination starts before the source, and backwards from the end otherwise, with a fall back to the more efficient &lt;code&gt;&lt;a href=&quot;memcpy&quot;&gt;memcpy&lt;/a&gt;&lt;/code&gt; when there is no overlap at all.</source>
          <target state="translated">尽管已指定&amp;ldquo;好像&amp;rdquo;使用了临时缓冲区，但此功能的实际实现不会产生开销，重复复制或额外的内存。一种通用的方法（glibc和bsd libc）是：如果目标在源之前开始，则从缓冲区的开始向前复制字节，否则从末端向后复制字节，而当没有重叠时回退到更有效的 &lt;code&gt;&lt;a href=&quot;memcpy&quot;&gt;memcpy&lt;/a&gt;&lt;/code&gt; 。所有。</target>
        </trans-unit>
        <trans-unit id="c5fec379b7553188ac34cec8b46773b82ab3ed04" translate="yes" xml:space="preserve">
          <source>Despite disallowing undue overflow, complex division may raise spurious floating-point exceptions (otherwise it is prohibitively difficult to implement non-overflowing versions).</source>
          <target state="translated">尽管不允许不适当的溢出,但复杂的除法可能会引起虚假的浮点异常(否则很难实现非溢出版本)。</target>
        </trans-unit>
        <trans-unit id="15633e8db8c39a0171fc7ddfc24df220b416124e" translate="yes" xml:space="preserve">
          <source>Despite disallowing undue overflow, complex multiplication may raise spurious floating-point exceptions (otherwise it is prohibitively difficult to implement non-overflowing versions).</source>
          <target state="translated">尽管不允许不适当的溢出,但复杂的乘法可能会引起虚假的浮点异常(否则实现非溢出版本就会非常困难)。</target>
        </trans-unit>
        <trans-unit id="855ca2056b63174a0ddd49fc8dda9ca42caba924" translate="yes" xml:space="preserve">
          <source>Despite the name, neither C nor POSIX standards require this function to be implemented using &lt;a href=&quot;https://en.wikipedia.org/wiki/Quicksort&quot;&gt;quicksort&lt;/a&gt; or make any complexity or stability guarantees.</source>
          <target state="translated">尽管有名称，但C和POSIX标准都不需要使用&lt;a href=&quot;https://en.wikipedia.org/wiki/Quicksort&quot;&gt;quicksort&lt;/a&gt;来实现此功能，也不保证任何复杂性或稳定性。</target>
        </trans-unit>
        <trans-unit id="b78d139cdf486e1acc85058934b061d098dfdcab" translate="yes" xml:space="preserve">
          <source>Despite the name, neither C nor POSIX standards require this function to be implemented using binary search or make any complexity guarantees.</source>
          <target state="translated">尽管名字很好听,但C和POSIX标准都不要求这个函数使用二进制搜索来实现,也不要求做任何复杂度保证。</target>
        </trans-unit>
        <trans-unit id="e759a1fb34e3f73a71f0a598c5a332119a8f59d1" translate="yes" xml:space="preserve">
          <source>Destroys the condition variable pointed to by &lt;code&gt;cond&lt;/code&gt;.</source>
          <target state="translated">销毁 &lt;code&gt;cond&lt;/code&gt; 指向的条件变量。</target>
        </trans-unit>
        <trans-unit id="30db72753f6da400421d2bf7435f8d3d3aff73f5" translate="yes" xml:space="preserve">
          <source>Destroys the mutex pointed to by &lt;code&gt;mutex&lt;/code&gt;.</source>
          <target state="translated">销毁互斥对象指向的 &lt;code&gt;mutex&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1d86774c24e1a6900373ea2ea0eabca1cef9aefb" translate="yes" xml:space="preserve">
          <source>Destroys the thread-specific storage identified by &lt;code&gt;tss_id&lt;/code&gt;.</source>
          <target state="translated">销毁 &lt;code&gt;tss_id&lt;/code&gt; 标识的特定于线程的存储。</target>
        </trans-unit>
        <trans-unit id="e8ac19debfbe59f4081df2e1735171ca5f3762c9" translate="yes" xml:space="preserve">
          <source>Detaches the thread identified by &lt;code&gt;thr&lt;/code&gt; from the current environment. The resources held by the thread will be freed automatically once the thread exits.</source>
          <target state="translated">从当前环境中分离由 &lt;code&gt;thr&lt;/code&gt; 标识的线程。线程退出后，线程所拥有的资源将自动释放。</target>
        </trans-unit>
        <trans-unit id="c3457bc8babb6145a4d1a3fb89cd5528841f3468" translate="yes" xml:space="preserve">
          <source>Determines if the atomic operations on all objects of the type &lt;code&gt;A&lt;/code&gt; (the type of the object pointed to by &lt;code&gt;obj&lt;/code&gt;) are lock-free. In any given program execution, the result of calling &lt;code&gt;atomic_is_lock_free&lt;/code&gt; is the same for all pointers of the same type.</source>
          <target state="translated">确定对所有类型为 &lt;code&gt;A&lt;/code&gt; 的对象（由 &lt;code&gt;obj&lt;/code&gt; 指向的对象的类型）的原子操作是否无锁。在任何给定的程序执行中，对于相同类型的所有指针，调用 &lt;code&gt;atomic_is_lock_free&lt;/code&gt; 的结果都是相同的。</target>
        </trans-unit>
        <trans-unit id="42961033930dd9b0cb31b3f60a0b7da407759c76" translate="yes" xml:space="preserve">
          <source>Determines if the floating point number &lt;code&gt;x&lt;/code&gt; is greater than or equal to the floating-point number &lt;code&gt;y&lt;/code&gt;, without setting floating-point exceptions.</source>
          <target state="translated">确定浮点数 &lt;code&gt;x&lt;/code&gt; 是否大于或等于浮点数 &lt;code&gt;y&lt;/code&gt; ，而不设置浮点异常。</target>
        </trans-unit>
        <trans-unit id="06ba39a9361411a3c82420f68b56c98e752e8285" translate="yes" xml:space="preserve">
          <source>Determines if the floating point number &lt;code&gt;x&lt;/code&gt; is greater than the floating-point number (&lt;code&gt;y&lt;/code&gt;), without setting floating-point exceptions.</source>
          <target state="translated">确定浮点数 &lt;code&gt;x&lt;/code&gt; 是否大于浮点数（ &lt;code&gt;y&lt;/code&gt; ），而不设置浮点异常。</target>
        </trans-unit>
        <trans-unit id="8f2c82d270fa552f3d9599b39ceefe0ab66e42be" translate="yes" xml:space="preserve">
          <source>Determines if the floating point number &lt;code&gt;x&lt;/code&gt; is less than or equal to the floating-point number &lt;code&gt;y&lt;/code&gt;, without setting floating-point exceptions.</source>
          <target state="translated">确定浮点数 &lt;code&gt;x&lt;/code&gt; 是否小于或等于浮点数 &lt;code&gt;y&lt;/code&gt; ，而不设置浮点异常。</target>
        </trans-unit>
        <trans-unit id="61cc741f2ceb8f899fe8f8a8102fd65dfe1cdb1b" translate="yes" xml:space="preserve">
          <source>Determines if the floating point number &lt;code&gt;x&lt;/code&gt; is less than or greater than the floating-point number &lt;code&gt;y&lt;/code&gt;, without setting floating-point exceptions.</source>
          <target state="translated">确定浮点数 &lt;code&gt;x&lt;/code&gt; 是否小于或大于浮点数 &lt;code&gt;y&lt;/code&gt; ，而不设置浮点异常。</target>
        </trans-unit>
        <trans-unit id="cc4f23eed57a50e680bbd714ba24c1ae9b04715c" translate="yes" xml:space="preserve">
          <source>Determines if the floating point number &lt;code&gt;x&lt;/code&gt; is less than the floating-point number &lt;code&gt;y&lt;/code&gt;, without setting floating-point exceptions.</source>
          <target state="translated">确定浮点数 &lt;code&gt;x&lt;/code&gt; 是否小于浮点数 &lt;code&gt;y&lt;/code&gt; ，而不设置浮点异常。</target>
        </trans-unit>
        <trans-unit id="12a023deb0e25da717685baee738b5001df78e3a" translate="yes" xml:space="preserve">
          <source>Determines if the floating point numbers &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are unordered, that is, one or both are NaN and thus cannot be meaningfully compared with each other.</source>
          <target state="translated">确定浮点数 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 是否为无序，即一个或两个均为NaN，因此无法进行有意义的比较。</target>
        </trans-unit>
        <trans-unit id="1673883c418a37012138fdc6e721d284c1d37177" translate="yes" xml:space="preserve">
          <source>Determines if the given floating point number &lt;code&gt;arg&lt;/code&gt; has finite value i.e. it is normal, subnormal or zero, but not infinite or NaN. The macro returns an integral value.</source>
          <target state="translated">确定给定的浮点数 &lt;code&gt;arg&lt;/code&gt; 是否具有有限值，即它是正常，次正规或零，但不是无限或NaN。宏返回一个整数值。</target>
        </trans-unit>
        <trans-unit id="f01a2032ba2b4ae13adc4724b8eac8696393ffb1" translate="yes" xml:space="preserve">
          <source>Determines if the given floating point number &lt;code&gt;arg&lt;/code&gt; is a not-a-number (NaN) value. The macro returns an integral value.</source>
          <target state="translated">确定给定的浮点数 &lt;code&gt;arg&lt;/code&gt; 是否为非数字（NaN）值。宏返回一个整数值。</target>
        </trans-unit>
        <trans-unit id="7ab9c686b97ad7bf5476551370095e04426a01d8" translate="yes" xml:space="preserve">
          <source>Determines if the given floating point number &lt;code&gt;arg&lt;/code&gt; is negative. The macro returns an integral value.</source>
          <target state="translated">确定给定的浮点数 &lt;code&gt;arg&lt;/code&gt; 是否为负。宏返回一个整数值。</target>
        </trans-unit>
        <trans-unit id="c71330c3e714777dd145b0fec831b8fa8ff04aa4" translate="yes" xml:space="preserve">
          <source>Determines if the given floating point number &lt;code&gt;arg&lt;/code&gt; is normal, i.e. is neither zero, subnormal, infinite, nor &lt;code&gt;NaN&lt;/code&gt;. The macro returns an integral value.</source>
          <target state="translated">确定给定的浮点数 &lt;code&gt;arg&lt;/code&gt; 是否正常，即既不是零，次正规，无穷也不是 &lt;code&gt;NaN&lt;/code&gt; 。宏返回一个整数值。</target>
        </trans-unit>
        <trans-unit id="42bececa62b5cdaaf1bea284ccc4761215f18797" translate="yes" xml:space="preserve">
          <source>Determines if the given floating point number &lt;code&gt;arg&lt;/code&gt; is positive or negative infinity. The macro returns an integral value.</source>
          <target state="translated">确定给定的浮点数 &lt;code&gt;arg&lt;/code&gt; 是正无穷大还是负无穷大。宏返回一个整数值。</target>
        </trans-unit>
        <trans-unit id="d9abcfdbe740f7564155ea43385bb7b128ce45b2" translate="yes" xml:space="preserve">
          <source>Determines the size, in bytes, of the multibyte character whose first byte is pointed to by &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">确定第一个字节由 &lt;code&gt;s&lt;/code&gt; 指向的多字节字符的大小（以字节为单位）。</target>
        </trans-unit>
        <trans-unit id="4507028cacf93c00d5ae52796f91e29ec21b8e82" translate="yes" xml:space="preserve">
          <source>Determines the size, in bytes, of the representation of a multibyte character.</source>
          <target state="translated">确定多字节字符表示的大小,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="c69c802d70e0e3f6788cfc1779895445bfc77a31" translate="yes" xml:space="preserve">
          <source>Determines which of the specified subset of the floating point exceptions are currently set. The argument &lt;code&gt;excepts&lt;/code&gt; is a bitwise OR of the &lt;a href=&quot;fe_exceptions&quot;&gt;floating point exception macros&lt;/a&gt;.</source>
          <target state="translated">确定当前设置了浮点异常的哪个指定子集。参数 &lt;code&gt;excepts&lt;/code&gt; 是&lt;a href=&quot;fe_exceptions&quot;&gt;浮点异常宏&lt;/a&gt;的按位或。</target>
        </trans-unit>
        <trans-unit id="0d3a3771d727fe204d2df32971206ca839fb6ce3" translate="yes" xml:space="preserve">
          <source>Difference between two times in seconds.</source>
          <target state="translated">以秒为单位的两个时间之差。</target>
        </trans-unit>
        <trans-unit id="6170f244847af7dbbce945574fb4f39ec9c7c16b" translate="yes" xml:space="preserve">
          <source>Different implementations return different non-negative numbers: some return the last character written, some return the number of characters written (or INT_MAX if the string was longer than that), some simply return a non-negative constant such as zero.</source>
          <target state="translated">不同的实现返回不同的非负数:有的返回最后写入的字符数,有的返回写入的字符数(如果字符串长于此数,则返回INT_MAX),有的干脆返回一个非负数常数,如零。</target>
        </trans-unit>
        <trans-unit id="d3663230bcd568fa0f0bc0c99c9ad42d7948fb50" translate="yes" xml:space="preserve">
          <source>Different implementations return different non-negative numbers: some return the last character written, some return the number of characters written (or INT_MAX if the string was longer than that), some simply return a non-negative constant.</source>
          <target state="translated">不同的实现返回不同的非负数:有的返回最后写入的字符数,有的返回写入的字符数(如果字符串长于此数,则返回INT_MAX),有的只是返回一个非负数常数。</target>
        </trans-unit>
        <trans-unit id="4cec1e48ed8268246c17cdf0e9f5b5116725afd5" translate="yes" xml:space="preserve">
          <source>Different threads of execution are always allowed to access (read and modify) different</source>
          <target state="translated">不同的执行线程总是被允许访问(读取和修改)不同的</target>
        </trans-unit>
        <trans-unit id="f347c23fb94afe99ca29d2298bd820db7bf1c6f2" translate="yes" xml:space="preserve">
          <source>Direct input/output</source>
          <target state="translated">直接输入/输出</target>
        </trans-unit>
        <trans-unit id="28c82071e940360118b0611d5c912a71c32a0100" translate="yes" xml:space="preserve">
          <source>Directives</source>
          <target state="translated">Directives</target>
        </trans-unit>
        <trans-unit id="2df36c679013c753c1824914229ac0e9ed0ef85a" translate="yes" xml:space="preserve">
          <source>Discards any whitespace characters (as identified by calling &lt;code&gt;isspace()&lt;/code&gt;) until the first non-whitespace character is found, then takes as many characters as possible to form a valid</source>
          <target state="translated">丢弃所有空白字符（通过调用 &lt;code&gt;isspace()&lt;/code&gt; 进行标识），直到找到第一个非空白字符为止，然后使用尽可能多的字符来形成有效的</target>
        </trans-unit>
        <trans-unit id="3f47e884dde353c0a64ae183f652592cd28d42e5" translate="yes" xml:space="preserve">
          <source>Discards any whitespace characters until the first non-whitespace character is found, then takes as many characters as possible to form a valid integer number representation and converts them to an integer value. The valid integer value consists of the following parts:</source>
          <target state="translated">丢弃任何空格字符,直到找到第一个非空格字符,然后取尽可能多的字符形成一个有效的整数表示,并将它们转换为一个整数值。有效的整数值由以下部分组成。</target>
        </trans-unit>
        <trans-unit id="2b95cdc5966f0cb8891c7e9e0d564b397089da15" translate="yes" xml:space="preserve">
          <source>Dividing 0.0 by 0.0 gives NaN and &lt;code&gt;&lt;a href=&quot;../numeric/fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">通过0.0除以0.0给楠 &lt;code&gt;&lt;a href=&quot;../numeric/fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 升高</target>
        </trans-unit>
        <trans-unit id="b155ca10158e241e3d1fad0c3aba4fd35761c88e" translate="yes" xml:space="preserve">
          <source>Dividing a non-zero number by &amp;plusmn;0.0 gives the correctly-signed infinity and &lt;code&gt;&lt;a href=&quot;../numeric/fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">将非零数字除以&amp;plusmn;0.0可获得正确签名的无穷大，并且提高了 &lt;code&gt;&lt;a href=&quot;../numeric/fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bbbec44416269797757a1579d0b1247911acd066" translate="yes" xml:space="preserve">
          <source>Division</source>
          <target state="translated">Division</target>
        </trans-unit>
        <trans-unit id="26c986c0b2a8c981af75cc9b323e96898b596d78" translate="yes" xml:space="preserve">
          <source>Domain error</source>
          <target state="translated">域名错误</target>
        </trans-unit>
        <trans-unit id="683ae4a82c0162283d391c1cde234ae848eeb039" translate="yes" xml:space="preserve">
          <source>Domain error may occur if &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are both zero.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 均为零，则可能会发生域错误。</target>
        </trans-unit>
        <trans-unit id="209a993b5d06ebc1189ef12bc6140d9643c1f5b5" translate="yes" xml:space="preserve">
          <source>Domain error may occur if &lt;code&gt;y&lt;/code&gt; is zero.</source>
          <target state="translated">如果 &lt;code&gt;y&lt;/code&gt; 为零，则可能会发生域错误。</target>
        </trans-unit>
        <trans-unit id="f953ae32bdac16ba6277a0e47315c5bfadd7dae5" translate="yes" xml:space="preserve">
          <source>Domain error occurs if &lt;code&gt;arg&lt;/code&gt; is less than -1.</source>
          <target state="translated">如果 &lt;code&gt;arg&lt;/code&gt; 小于-1，则会发生域错误。</target>
        </trans-unit>
        <trans-unit id="1b2c79d3977fa1e82c68257e4ee3be3430c9d49f" translate="yes" xml:space="preserve">
          <source>Domain error occurs if &lt;code&gt;arg&lt;/code&gt; is less than zero.</source>
          <target state="translated">如果 &lt;code&gt;arg&lt;/code&gt; 小于零，则会发生域错误。</target>
        </trans-unit>
        <trans-unit id="206bd3375d61b90cec57754711bf77b10e8308ff" translate="yes" xml:space="preserve">
          <source>Domain error occurs if &lt;code&gt;arg&lt;/code&gt; is outside the range &lt;code&gt;[-1.0; 1.0]&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;arg&lt;/code&gt; 超出 &lt;code&gt;[-1.0; 1.0]&lt;/code&gt; 范围，则会发生域错误。1.0]。</target>
        </trans-unit>
        <trans-unit id="30b1970ca78476223062c512a821c8789e06506b" translate="yes" xml:space="preserve">
          <source>Domain or range error may occur if &lt;code&gt;arg&lt;/code&gt; is zero.</source>
          <target state="translated">如果 &lt;code&gt;arg&lt;/code&gt; 为零，则可能会发生域或范围错误。</target>
        </trans-unit>
        <trans-unit id="b1ca39980d3cc90251635580f9d046def1437b32" translate="yes" xml:space="preserve">
          <source>Due to &lt;a href=&quot;translation_phases#maximal_munch&quot;&gt;maximal munch&lt;/a&gt;, hexadecimal integer constants ending in &lt;code&gt;e&lt;/code&gt; and &lt;code&gt;E&lt;/code&gt;, when followed by the operators &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt;, must be separated from the operator with whitespace or parentheses in the source:</source>
          <target state="translated">由于具有&lt;a href=&quot;translation_phases#maximal_munch&quot;&gt;最大的munch值&lt;/a&gt;，因此以 &lt;code&gt;e&lt;/code&gt; 和 &lt;code&gt;E&lt;/code&gt; 结尾的十六进制整数常数（在其后跟 &lt;code&gt;+&lt;/code&gt; 或 &lt;code&gt;-&lt;/code&gt; 运算符）必须与源中带有空格或括号的运算符分隔开：</target>
        </trans-unit>
        <trans-unit id="fbad71c32e999acfe150dcd28476b81eeb49a324" translate="yes" xml:space="preserve">
          <source>Due to its infinite intermediate precision, &lt;code&gt;fma&lt;/code&gt; is a common building block of other correctly-rounded mathematical operations, such as &lt;code&gt;&lt;a href=&quot;sqrt&quot;&gt;sqrt&lt;/a&gt;&lt;/code&gt; or even the division (where not provided by the CPU, e.g. Itanium).</source>
          <target state="translated">由于其无限的中间精度， &lt;code&gt;fma&lt;/code&gt; 是其他正确舍入的数学运算（例如 &lt;code&gt;&lt;a href=&quot;sqrt&quot;&gt;sqrt&lt;/a&gt;&lt;/code&gt; 或除法（在CPU未提供的情况下，例如Itanium））的常见构造块。</target>
        </trans-unit>
        <trans-unit id="a8edf7aed52e22273ca006dc7586e6c5a889a81c" translate="yes" xml:space="preserve">
          <source>Due to the alignment requirements, the number of allocated bytes is not necessarily equal to &lt;code&gt;num*size&lt;/code&gt;.</source>
          <target state="translated">由于对齐要求，分配的字节数不一定等于 &lt;code&gt;num*size&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1ada3669ea0e73f0cca2ed0c6e2ffff046545a5e" translate="yes" xml:space="preserve">
          <source>Due to the definition of the &lt;a href=&quot;operator_arithmetic&quot;&gt;addition between a pointer and an integer&lt;/a&gt;, the result is the element of the array with the index equal to the result of integer-expression (or, if pointer-expression was pointing at ith element of some array, the index of the result is i plus the result of integer-expression).</source>
          <target state="translated">由于定义&lt;a href=&quot;operator_arithmetic&quot;&gt;了指针和整数之间的加法&lt;/a&gt;，因此结果是索引等于整数表达式结果的数组元素（或者，如果指针表达式指向某个数组的第i个元素，则结果为结果的索引是i加上integer-expression的结果）。</target>
        </trans-unit>
        <trans-unit id="6ca450ab66cc4bceeefc245e894ea6b43911af90" translate="yes" xml:space="preserve">
          <source>During each execution of a block in which a restricted pointer &lt;code&gt;P&lt;/code&gt; is declared (typically each execution of a function body in which &lt;code&gt;P&lt;/code&gt; is a function parameter), if some object that is accessible through &lt;code&gt;P&lt;/code&gt; (directly or indirectly) is modified, by any means, then all accesses to that object (both reads and writes) in that block must occur through &lt;code&gt;P&lt;/code&gt; (directly or indirectly), otherwise the behavior is undefined:</source>
          <target state="translated">在声明了受限指针 &lt;code&gt;P&lt;/code&gt; 的块的每次执行过程中（通常，每次执行其中 &lt;code&gt;P&lt;/code&gt; 是函数参数的函数体），如果通过 &lt;code&gt;P&lt;/code&gt; （直接或间接）访问的某些对象被修改，则可以通过任何方式进行，那么该块中对该对象的所有访问（读写）都必须通过 &lt;code&gt;P&lt;/code&gt; （直接或间接）进行，否则行为是不确定的：</target>
        </trans-unit>
        <trans-unit id="07293fea74c54774179ebe1157890c6ede5445d9" translate="yes" xml:space="preserve">
          <source>During program startup, the equivalent of &lt;code&gt;setlocale(&lt;a href=&quot;lc_categories&quot;&gt;LC_ALL&lt;/a&gt;, &quot;C&quot;);&lt;/code&gt; is executed before any user code is run.</source>
          <target state="translated">在程序启动期间，等效于 &lt;code&gt;setlocale(&lt;a href=&quot;lc_categories&quot;&gt;LC_ALL&lt;/a&gt;, &quot;C&quot;);&lt;/code&gt; 在运行任何用户代码之前执行。</target>
        </trans-unit>
        <trans-unit id="27eaec4864e4b466246e5081a68f0b07f10aafac" translate="yes" xml:space="preserve">
          <source>Dynamic memory management</source>
          <target state="translated">动态内存管理</target>
        </trans-unit>
        <trans-unit id="7c3cba5cfb875c54a838f8fb7c062f2ab636df56" translate="yes" xml:space="preserve">
          <source>E2BIG, EACCES, ..., EXDEV</source>
          <target state="translated">E2BIG、EACCES、...、EXDEV。</target>
        </trans-unit>
        <trans-unit id="4a50ae31fdb1876dd49f36fd10696a265ad4f349" translate="yes" xml:space="preserve">
          <source>EDOM</source>
          <target state="translated">EDOM</target>
        </trans-unit>
        <trans-unit id="bafb9dc439b47e39a5166a169171eda5a0ccd069" translate="yes" xml:space="preserve">
          <source>EILSEQ</source>
          <target state="translated">EILSEQ</target>
        </trans-unit>
        <trans-unit id="cda4aab5bcbd0ed38717196ad5a3684cd59490a3" translate="yes" xml:space="preserve">
          <source>EOF</source>
          <target state="translated">EOF</target>
        </trans-unit>
        <trans-unit id="027a5d6bd60d44a140b125f5e6c684b7bb796a30" translate="yes" xml:space="preserve">
          <source>ERANGE</source>
          <target state="translated">ERANGE</target>
        </trans-unit>
        <trans-unit id="c1f146ea81ae03fae7db256856fdde169c5d5e44" translate="yes" xml:space="preserve">
          <source>EXIT_SUCCESS</source>
          <target state="translated">EXIT_SUCCESS</target>
        </trans-unit>
        <trans-unit id="5c2b8a61f8fe437d39117db5b2fb0b332818fd1a" translate="yes" xml:space="preserve">
          <source>EXIT_SUCCESS, EXIT_FAILURE</source>
          <target state="translated">EXIT_SUCCESS,EXIT_FAILURE。</target>
        </trans-unit>
        <trans-unit id="69fa19d78ab53209ccdb3bf9ac261f7db68a9cbc" translate="yes" xml:space="preserve">
          <source>EXIT_SUCCESSEXIT_FAILURE</source>
          <target state="translated">EXIT_SUCCESSEXIT_FAILURE</target>
        </trans-unit>
        <trans-unit id="c354b3028bd8c5a1179ea67b0fa0ac0c52287a14" translate="yes" xml:space="preserve">
          <source>Each &lt;a href=&quot;expressions&quot;&gt;expression&lt;/a&gt; in C (an operator with its arguments, a function call, a constant, a variable name, etc) is characterized by two independent properties: a &lt;a href=&quot;compatible_type#Type&quot;&gt;type&lt;/a&gt; and a &lt;a href=&quot;expressions#General&quot;&gt;value category&lt;/a&gt;.</source>
          <target state="translated">C语言中的每个&lt;a href=&quot;expressions&quot;&gt;表达式&lt;/a&gt;（带有参数，函数调用，常量，变量名等的运算符）都具有两个独立的属性：&lt;a href=&quot;compatible_type#Type&quot;&gt;类型&lt;/a&gt;和&lt;a href=&quot;expressions#General&quot;&gt;值类别&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1f85f8ed086a86eb382bf3f36ce72b1f255a1a54" translate="yes" xml:space="preserve">
          <source>Each &lt;a href=&quot;identifier&quot;&gt;identifier&lt;/a&gt; that appears in a C program is</source>
          <target state="translated">C程序中出现的每个&lt;a href=&quot;identifier&quot;&gt;标识符&lt;/a&gt;是</target>
        </trans-unit>
        <trans-unit id="034551eb33d55611bebf58f023be8399816d5832" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;memory_order_seq_cst&lt;/code&gt; operation B that loads from atomic variable M, observes one of the following:</source>
          <target state="translated">从原子变量M加载的每个 &lt;code&gt;memory_order_seq_cst&lt;/code&gt; 操作B 都遵循以下条件之一：</target>
        </trans-unit>
        <trans-unit id="50ed6669658b1fc844a09041da527dd57c316058" translate="yes" xml:space="preserve">
          <source>Each argument of integer type undergoes</source>
          <target state="translated">整数类型的每个参数都要经过</target>
        </trans-unit>
        <trans-unit id="9ebf5b751176ac260f746f693298237e7da46d0e" translate="yes" xml:space="preserve">
          <source>Each atomic object has its own associated</source>
          <target state="translated">每个原子对象都有自己相关的</target>
        </trans-unit>
        <trans-unit id="df6cd15388cf4a32a59a55dc9d5c90813f45174a" translate="yes" xml:space="preserve">
          <source>Each call to &lt;code&gt;mblen&lt;/code&gt; updates the internal global conversion state (a static object of type &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;mbstate_t&lt;/a&gt;&lt;/code&gt;, only known to this function). If the multibyte encoding uses shift states, care must be taken to avoid backtracking or multiple scans. In any case, multiple threads should not call &lt;code&gt;mblen&lt;/code&gt; without synchronization: &lt;code&gt;&lt;a href=&quot;mbrlen&quot;&gt;mbrlen&lt;/a&gt;&lt;/code&gt; may be used instead.</source>
          <target state="translated">每次调用 &lt;code&gt;mblen&lt;/code&gt; 都会更新内部全局转换状态（仅此功能已知的 &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;mbstate_t&lt;/a&gt;&lt;/code&gt; 类型的静态对象）。如果多字节编码使用移位状态，则必须注意避免回溯或多次扫描。在任何情况下，多个线程都不应在没有同步的情况下调用 &lt;code&gt;mblen&lt;/code&gt; ：可以改用 &lt;code&gt;&lt;a href=&quot;mbrlen&quot;&gt;mbrlen&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="73d303af5fb3c8b993bba7231f1a0f5f58ccb4f1" translate="yes" xml:space="preserve">
          <source>Each call to &lt;code&gt;mbtowc&lt;/code&gt; updates the internal global conversion state (a static object of type &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;mbstate_t&lt;/a&gt;&lt;/code&gt;, known only to this function). If the multibyte encoding uses shift states, care must be taken to avoid backtracking or multiple scans. In any case, multiple threads should not call &lt;code&gt;mbtowc&lt;/code&gt; without synchronization: &lt;code&gt;&lt;a href=&quot;mbrtowc&quot;&gt;mbrtowc&lt;/a&gt;&lt;/code&gt; may be used instead.</source>
          <target state="translated">每次调用 &lt;code&gt;mbtowc&lt;/code&gt; 都会更新内部全局转换状态（仅此功能已知的 &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;mbstate_t&lt;/a&gt;&lt;/code&gt; 类型的静态对象）。如果多字节编码使用移位状态，则必须注意避免回溯或多次扫描。在任何情况下，多个线程都不应在没有同步的情况下调用 &lt;code&gt;mbtowc&lt;/code&gt; ：可以使用 &lt;code&gt;&lt;a href=&quot;mbrtowc&quot;&gt;mbrtowc&lt;/a&gt;&lt;/code&gt; 代替。</target>
        </trans-unit>
        <trans-unit id="3a26487bbc956d044f713cce85b0df2b15bb37d5" translate="yes" xml:space="preserve">
          <source>Each call to &lt;code&gt;strtok&lt;/code&gt; modifies a static variable: is not thread safe.</source>
          <target state="translated">每次对 &lt;code&gt;strtok&lt;/code&gt; 的调用都会修改一个静态变量：不是线程安全的。</target>
        </trans-unit>
        <trans-unit id="dbb07f43c006809f998028ea3a3213eba702b907" translate="yes" xml:space="preserve">
          <source>Each call to &lt;code&gt;wctomb&lt;/code&gt; updates the internal global conversion state (a static object of type &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;mbstate_t&lt;/a&gt;&lt;/code&gt;, known only to this function). If the multibyte encoding uses shift states, this function is not reentrant. In any case, multiple threads should not call &lt;code&gt;wctomb&lt;/code&gt; without synchronization: &lt;code&gt;&lt;a href=&quot;wcrtomb&quot;&gt;wcrtomb&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;wctomb_s&lt;/code&gt; may be used instead.</source>
          <target state="translated">每次调用 &lt;code&gt;wctomb&lt;/code&gt; 都会更新内部全局转换状态（仅此函数已知的 &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;mbstate_t&lt;/a&gt;&lt;/code&gt; 类型的静态对象）。如果多字节编码使用移位状态，则此函数不可重入。无论如何，多个线程不应在没有同步的情况下调用 &lt;code&gt;wctomb&lt;/code&gt; ：可以使用 &lt;code&gt;&lt;a href=&quot;wcrtomb&quot;&gt;wcrtomb&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;wctomb_s&lt;/code&gt; 代替。</target>
        </trans-unit>
        <trans-unit id="10c116fe99e7e4c63d5874a29e18cc77b07208ef" translate="yes" xml:space="preserve">
          <source>Each character is converted as if by a call to &lt;code&gt;&lt;a href=&quot;mbtowc&quot;&gt;mbtowc&lt;/a&gt;&lt;/code&gt;, except that the mbtowc conversion state is unaffected. The conversion stops if:</source>
          <target state="translated">每个字符由一个呼叫转换仿佛 &lt;code&gt;&lt;a href=&quot;mbtowc&quot;&gt;mbtowc&lt;/a&gt;&lt;/code&gt; ，除了mbtowc转换状态不受影响。如果发生以下情况，转换将停止：</target>
        </trans-unit>
        <trans-unit id="8fdcfb8ea34567f6c07db16c3fdb8c247a630ac9" translate="yes" xml:space="preserve">
          <source>Each character is converted as if by a call to &lt;code&gt;&lt;a href=&quot;wcrtomb&quot;&gt;wcrtomb&lt;/a&gt;&lt;/code&gt;. The conversion stops if:</source>
          <target state="translated">每个字符都像调用 &lt;code&gt;&lt;a href=&quot;wcrtomb&quot;&gt;wcrtomb&lt;/a&gt;&lt;/code&gt; 那样转换。如果发生以下情况，转换将停止：</target>
        </trans-unit>
        <trans-unit id="b6a6b4bfe71a06eb1a9c2dcd04975303c04aa0c0" translate="yes" xml:space="preserve">
          <source>Each character is converted as if by a call to &lt;code&gt;&lt;a href=&quot;wctomb&quot;&gt;wctomb&lt;/a&gt;&lt;/code&gt;, except that the wctomb's conversion state is unaffected. The conversion stops if:</source>
          <target state="translated">每个字符由一个呼叫转换仿佛 &lt;code&gt;&lt;a href=&quot;wctomb&quot;&gt;wctomb&lt;/a&gt;&lt;/code&gt; ，除了wctomb的转换状态不受影响。如果发生以下情况，转换将停止：</target>
        </trans-unit>
        <trans-unit id="139407327b9bb5d3c3d7c2958d54f12ce1b02006" translate="yes" xml:space="preserve">
          <source>Each character stored in the string may occupy more than one byte. The encoding used to represent characters in a multibyte character string is locale-specific: it may be UTF-8, GB18030, EUC-JP, Shift-JIS, etc. For example, the char array &lt;code&gt;{'\xe4','\xbd','\xa0','\xe5','\xa5','\xbd','\0'&lt;/code&gt;} is an NTMBS holding the string &lt;code&gt;&quot;你好&quot;&lt;/code&gt; in UTF-8 multibyte encoding: the first three bytes encode the character 你, the next three bytes encode the character 好. The same string encoded in GB18030 is the char array &lt;code&gt;{'\xc4', '\xe3', '\xba', '\xc3', '\0'&lt;/code&gt;}, where each of the two characters is encoded as a two-byte sequence.</source>
          <target state="translated">字符串中存储的每个字符可能占用一个以上的字节。用于表示多字节字符串中的字符的编码是特定于语言环境的：它可以是UTF-8，GB18030，EUC-JP，Shift-JIS等。例如，char数组 &lt;code&gt;{'\xe4','\xbd','\xa0','\xe5','\xa5','\xbd','\0'&lt;/code&gt; }是一个NTMBS ，采用UTF-8多字节编码保存字符串 &lt;code&gt;&quot;你好&quot;&lt;/code&gt; ：前三个字节对字符你，接下来的三个字节编码字符好。 GB18030中编码的相同字符串是char数组 &lt;code&gt;{'\xc4', '\xe3', '\xba', '\xc3', '\0'&lt;/code&gt; }，其中两个字符均被编码为两个字节序列。</target>
        </trans-unit>
        <trans-unit id="68890a6b98ff2345efa51a151d230b6d6d04308c" translate="yes" xml:space="preserve">
          <source>Each complex type has the same &lt;a href=&quot;object&quot;&gt;object representation&lt;/a&gt; and &lt;a href=&quot;object&quot;&gt;alignment requirements&lt;/a&gt; as an &lt;a href=&quot;array&quot;&gt;array&lt;/a&gt; of two elements of the corresponding real type (&lt;code&gt;float&lt;/code&gt; for &lt;code&gt;float &lt;a href=&quot;../numeric/complex/complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt; for &lt;code&gt;double &lt;a href=&quot;../numeric/complex/complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;long double&lt;/code&gt; for &lt;code&gt;long double &lt;a href=&quot;../numeric/complex/complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;). The first element of the array holds the real part, and the second element of the array holds the imaginary component.</source>
          <target state="translated">每个复杂类型具有与对应的实类型的两个元素组成的&lt;a href=&quot;array&quot;&gt;数组&lt;/a&gt;相同的&lt;a href=&quot;object&quot;&gt;对象表示&lt;/a&gt;和&lt;a href=&quot;object&quot;&gt;对齐要求&lt;/a&gt;（ &lt;code&gt;float&lt;/code&gt; 表示 &lt;code&gt;float &lt;a href=&quot;../numeric/complex/complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;../numeric/complex/complex&quot;&gt;复数&lt;/a&gt;， &lt;code&gt;double&lt;/code&gt; 表示 &lt;code&gt;double &lt;a href=&quot;../numeric/complex/complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;../numeric/complex/complex&quot;&gt;复数&lt;/a&gt;， &lt;code&gt;long double&lt;/code&gt; 表示 &lt;code&gt;long double &lt;a href=&quot;../numeric/complex/complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;../numeric/complex/complex&quot;&gt;复数&lt;/a&gt;）。数组的第一个元素保存实部，数组的第二个元素保存虚部。</target>
        </trans-unit>
        <trans-unit id="137efba0894a7ebae4cd21d84f7d4f31559eb6c4" translate="yes" xml:space="preserve">
          <source>Each compound literal creates only a single object in its scope:</source>
          <target state="translated">每个复合文字都只在其范围内创建一个对象。</target>
        </trans-unit>
        <trans-unit id="a9df8d8eee431c451d6fc1af48d35c03f7433a26" translate="yes" xml:space="preserve">
          <source>Each compound statement introduces its own &lt;a href=&quot;scope&quot;&gt;block scope&lt;/a&gt;.</source>
          <target state="translated">每个复合语句都有自己的&lt;a href=&quot;scope&quot;&gt;块范围&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d9b8fc8e52076ec7b7c61bffc9ddc3474662c826" translate="yes" xml:space="preserve">
          <source>Each declarator is one of the following:</source>
          <target state="translated">每个申报者都是以下几种情况之一。</target>
        </trans-unit>
        <trans-unit id="79a901de123f9c94830f0127ef29a5f9dcf4d060" translate="yes" xml:space="preserve">
          <source>Each enumerated type is &lt;a href=&quot;compatible_type#Compatible_types&quot;&gt;compatible&lt;/a&gt; with one of: &lt;code&gt;char&lt;/code&gt;, a signed integer type, or an unsigned integer type. It is implementation-defined which type is compatible with any given enumerated type, but whatever it is, it must be capable of representing all enumerator values of that enumeration.</source>
          <target state="translated">每种枚举类型都与以下其中一种&lt;a href=&quot;compatible_type#Compatible_types&quot;&gt;兼容&lt;/a&gt;： &lt;code&gt;char&lt;/code&gt; ，有符号整数类型或无符号整数类型。由实现定义，哪种类型与任何给定的枚举类型兼容，但是无论哪种类型，它都必须能够表示该枚举的所有枚举值。</target>
        </trans-unit>
        <trans-unit id="e20b07c2f013df7b88017bc74253d151a6997995" translate="yes" xml:space="preserve">
          <source>Each enumerator that appears in the body of an enumeration specifier becomes an &lt;a href=&quot;constant_expression&quot;&gt;integer constant&lt;/a&gt; with type &lt;code&gt;int&lt;/code&gt; in the enclosing scope and can be used whenever integer constants are required (e.g. as a case label or as a non-VLA array size).</source>
          <target state="translated">出现在枚举说明符主体中的每个枚举器将成为封闭范围内 &lt;code&gt;int&lt;/code&gt; 类型的&lt;a href=&quot;constant_expression&quot;&gt;整数常量&lt;/a&gt;，并且可以在需要整数常量的任何时候使用（例如，用作大小写标签或非VLA数组大小）。</target>
        </trans-unit>
        <trans-unit id="b14993a86ee9276479d81f8deeff73026cd0493b" translate="yes" xml:space="preserve">
          <source>Each identifier (other than macro) is only valid within a part of the program called its &lt;a href=&quot;scope&quot;&gt;scope&lt;/a&gt; and belongs to one of four kinds of &lt;a href=&quot;name_space&quot;&gt;name spaces&lt;/a&gt;. Some identifiers have &lt;a href=&quot;storage_duration&quot;&gt;linkage&lt;/a&gt; which makes them refer to the same entities when they appear in different scopes or translation units.</source>
          <target state="translated">每个标识符（宏除外）仅在程序的一部分（称为&lt;a href=&quot;scope&quot;&gt;范围&lt;/a&gt;）内有效，并且属于四种&lt;a href=&quot;name_space&quot;&gt;名称空间之一&lt;/a&gt;。一些标识符具有&lt;a href=&quot;storage_duration&quot;&gt;链接&lt;/a&gt;，当它们出现在不同的作用域或翻译单位中时，它们使它们引用相同的实体。</target>
        </trans-unit>
        <trans-unit id="ad4634fb5579a12854af07426a363d2ae6653fef" translate="yes" xml:space="preserve">
          <source>Each individual type in the C &lt;a href=&quot;compatible_type&quot;&gt;type system&lt;/a&gt; has several</source>
          <target state="translated">C &lt;a href=&quot;compatible_type&quot;&gt;类型系统&lt;/a&gt;中的每种类型都有几种</target>
        </trans-unit>
        <trans-unit id="b778434a270ebe1a3642fbd59833ce5e585f867f" translate="yes" xml:space="preserve">
          <source>Each member is allocated as if it were the only member of the union, which is why &lt;code&gt;s.c&lt;/code&gt; in the example above aliases the first byte of &lt;code&gt;s.s[0]&lt;/code&gt;.</source>
          <target state="translated">每个成员的分配就好像它是联合的唯一成员一样，这就是为什么上面的示例中的 &lt;code&gt;s.c&lt;/code&gt; 别名 &lt;code&gt;s.s[0]&lt;/code&gt; 的第一个字节。</target>
        </trans-unit>
        <trans-unit id="1b6ef3be237b3fe7d1168941fc3d1dec86cd9c78" translate="yes" xml:space="preserve">
          <source>Each object type imposes its alignment requirement on every object of that type. The strictest (largest) fundamental alignment of any type is the alignment of &lt;code&gt;&lt;a href=&quot;../types/max_align_t&quot;&gt;max_align_t&lt;/a&gt;&lt;/code&gt;. The weakest (smallest) alignment is the alignment of the types &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;signed char&lt;/code&gt;, and &lt;code&gt;unsigned char&lt;/code&gt;, and equals 1.</source>
          <target state="translated">每种对象类型都将其对齐要求强加于该类型的每个对象上。任何类型中最严格（最大）的基本对齐方式是 &lt;code&gt;&lt;a href=&quot;../types/max_align_t&quot;&gt;max_align_t&lt;/a&gt;&lt;/code&gt; 的对齐方式。最弱（最小）的对齐方式是 &lt;code&gt;char&lt;/code&gt; ， &lt;code&gt;signed char&lt;/code&gt; 和 &lt;code&gt;unsigned char&lt;/code&gt; 类型的对齐方式，等于1。</target>
        </trans-unit>
        <trans-unit id="3bce51722d6b62312c671c879d5a6de1f802d8fe" translate="yes" xml:space="preserve">
          <source>Each of &lt;code&gt;#if&lt;/code&gt;, &lt;code&gt;#elif&lt;/code&gt;, &lt;code&gt;#else&lt;/code&gt;, &lt;code&gt;#ifdef&lt;/code&gt; and &lt;code&gt;#ifndef&lt;/code&gt; directives control a code block until the first &lt;code&gt;#elif&lt;/code&gt;, &lt;code&gt;#else&lt;/code&gt;, &lt;code&gt;#endif&lt;/code&gt; directive not belonging to any inner conditional preprocessing blocks.</source>
          <target state="translated">每个 &lt;code&gt;#if&lt;/code&gt; ， &lt;code&gt;#elif&lt;/code&gt; 指令， &lt;code&gt;#else&lt;/code&gt; 伪， &lt;code&gt;#ifdef&lt;/code&gt; 和 &lt;code&gt;#ifndef&lt;/code&gt; 指令控制一个代码块，直到第一 &lt;code&gt;#elif&lt;/code&gt; 指令， &lt;code&gt;#else&lt;/code&gt; 伪， &lt;code&gt;#endif&lt;/code&gt; 指令不属于任何内条件预处理块。</target>
        </trans-unit>
        <trans-unit id="13255e60126e8e8da26f8a162427af0c4a34405d" translate="yes" xml:space="preserve">
          <source>Each of the above macro constants expand to integer constant expressions with distinct values that are suitable for use as the first argument of &lt;code&gt;&lt;a href=&quot;setlocale&quot;&gt;setlocale&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">上面的每个宏常量都扩展为具有不同值的整数常量表达式，这些值适合用作 &lt;code&gt;&lt;a href=&quot;setlocale&quot;&gt;setlocale&lt;/a&gt;&lt;/code&gt; 的第一个参数。</target>
        </trans-unit>
        <trans-unit id="47dec134a6d556ab62aff5d62d028d693acc8498" translate="yes" xml:space="preserve">
          <source>Each of the above macro constants expands to an integer constant expression with distinct values, which represent different signals sent to the program.</source>
          <target state="translated">上述每个宏常数都展开为一个整数常数表达式,其数值不同,代表着发送给程序的不同信号。</target>
        </trans-unit>
        <trans-unit id="f6863b3780b12fcd68451d2943aa34bb1600f54a" translate="yes" xml:space="preserve">
          <source>Each of the macros defined in &lt;code&gt;&amp;lt;errno.h&amp;gt;&lt;/code&gt; expands to an integer constant expression with type &lt;code&gt;int&lt;/code&gt; and with a unique positive value. The following constants are defined by ISO C. The implementation may define more, as long as they begin with &lt;code&gt;'E'&lt;/code&gt; followed by digits or uppercase letters.</source>
          <target state="translated">&lt;code&gt;&amp;lt;errno.h&amp;gt;&lt;/code&gt; 中定义的每个宏都扩展为一个整数常量表达式，其类型为 &lt;code&gt;int&lt;/code&gt; 且具有唯一的正值。以下常量由ISO C定义。实现可以定义更多，只要它们以 &lt;code&gt;'E'&lt;/code&gt; 开头，后跟数字或大写字母即可。</target>
        </trans-unit>
        <trans-unit id="72f1807990ff12b536de30461fba27cc15d7e01f" translate="yes" xml:space="preserve">
          <source>Each of the three imaginary types has the same &lt;a href=&quot;object&quot;&gt;object representation&lt;/a&gt; and &lt;a href=&quot;object&quot;&gt;alignment requirement&lt;/a&gt; as its</source>
          <target state="translated">每三个假想类型的具有相同的&lt;a href=&quot;object&quot;&gt;对象表示&lt;/a&gt;和&lt;a href=&quot;object&quot;&gt;对齐要求&lt;/a&gt;作为其</target>
        </trans-unit>
        <trans-unit id="0edc9c873627a243af8d00da93f274ccae0173ff" translate="yes" xml:space="preserve">
          <source>Each of these macro constants expands to a nonnegative integer constant expression, which can be used with &lt;code&gt;&lt;a href=&quot;feround&quot;&gt;fesetround&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;feround&quot;&gt;fegetround&lt;/a&gt;&lt;/code&gt; to indicate one of the supported floating-point rounding modes. The implementation may define additional rounding mode constants in &lt;code&gt;&amp;lt;fenv.h&amp;gt;&lt;/code&gt;, which should all begin with &lt;code&gt;FE_&lt;/code&gt; followed by at least one uppercase letter. Each macro is only defined if it is supported.</source>
          <target state="translated">这些宏常量中的每一个都扩展为一个非负整数常量表达式，该表达式可以与 &lt;code&gt;&lt;a href=&quot;feround&quot;&gt;fesetround&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;feround&quot;&gt;fegetround&lt;/a&gt;&lt;/code&gt; 一起使用以指示受支持的浮点舍入模式之一。该实现可以在 &lt;code&gt;&amp;lt;fenv.h&amp;gt;&lt;/code&gt; 中定义其他舍入模式常量，所有常量都应以 &lt;code&gt;FE_&lt;/code&gt; 开头，后跟至少一个大写字母。仅在支持的情况下定义每个宏。</target>
        </trans-unit>
        <trans-unit id="c91547b3a6ee45d95762b25dda3cd9d3dac5ed28" translate="yes" xml:space="preserve">
          <source>Each of these macros expands to an expression that evaluates to the value of the specified complex type, with the real part having the value of &lt;code&gt;real&lt;/code&gt; (converted to the specified argument type) and the imaginary part having the value of &lt;code&gt;imag&lt;/code&gt; (converted to the specified argument type).</source>
          <target state="translated">这些宏中的每一个都扩展为一个表达式，该表达式的计算结果为指定的复杂类型的值，其中实部的值为 &lt;code&gt;real&lt;/code&gt; （转换为指定的参数类型），虚部的值为 &lt;code&gt;imag&lt;/code&gt; （转换为指定的值）参数类型）。</target>
        </trans-unit>
        <trans-unit id="daa18891fe69c786653bbe8101a0ff0d31ff1a44" translate="yes" xml:space="preserve">
          <source>Each parameter in a parameter-list is a &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt; that introduced a single variable, with the following additional properties:</source>
          <target state="translated">参数列表中的每个参数都是一个引入了单个变量的&lt;a href=&quot;declarations&quot;&gt;声明&lt;/a&gt;，具有以下附加属性：</target>
        </trans-unit>
        <trans-unit id="7b2f6db2798b2b2d64fe6857e20c316d195be57c" translate="yes" xml:space="preserve">
          <source>Each time &lt;code&gt;rand()&lt;/code&gt; is seeded with the same &lt;code&gt;seed&lt;/code&gt;, it must produce the same sequence of values.</source>
          <target state="translated">每次 &lt;code&gt;rand()&lt;/code&gt; 用相同的 &lt;code&gt;seed&lt;/code&gt; ，它必须产生相同的值序列。</target>
        </trans-unit>
        <trans-unit id="8c7893661e60dbd1dacc8ed252ed6eaf9b8c2f87" translate="yes" xml:space="preserve">
          <source>Each time the flow of control passes over the declaration, expression is evaluated (and it must always evaluate to a value greater than zero), and the array is allocated (correspondingly, &lt;a href=&quot;lifetime&quot;&gt;lifetime&lt;/a&gt; of a VLA ends when the declaration goes out of scope). The size of each VLA instance does not change during its lifetime, but on another pass over the same code, it may be allocated with a different size.</source>
          <target state="translated">每次控制流经过该声明时，都会对expression进行求值（并且必须始终将其求值为大于零的值），并分配该数组（相应地，当声明超出范围时，VLA的&lt;a href=&quot;lifetime&quot;&gt;生存&lt;/a&gt;期将结束）。每个VLA实例的大小在其生存期内不会更改，但是在同一代码的另一遍处理中，可能会分配不同的大小。</target>
        </trans-unit>
        <trans-unit id="9d2d2ec1c54af1bd7f51aa9bb54b8cab4a5b8234" translate="yes" xml:space="preserve">
          <source>Each translation unit may have zero or one external definition of every identifier with &lt;a href=&quot;storage_duration&quot;&gt;internal linkage&lt;/a&gt; (a &lt;code&gt;static&lt;/code&gt; global).</source>
          <target state="translated">每个翻译单元可能具有&lt;a href=&quot;storage_duration&quot;&gt;内部链接&lt;/a&gt;（ &lt;code&gt;static&lt;/code&gt; 全局）的每个标识符的零个或一个外部定义。</target>
        </trans-unit>
        <trans-unit id="720b5dbc53190f0e13902f7885ccaf43bb9991de" translate="yes" xml:space="preserve">
          <source>Effect</source>
          <target state="translated">Effect</target>
        </trans-unit>
        <trans-unit id="e462a3162644e49e48fa52678a61c2c86777646c" translate="yes" xml:space="preserve">
          <source>Effective type</source>
          <target state="translated">有效类型</target>
        </trans-unit>
        <trans-unit id="7e8faa87b0aa2cac770e9abb0f6c2733e6104d24" translate="yes" xml:space="preserve">
          <source>Empty declarators are prohibited; a declaration must be a &lt;a href=&quot;static_assert&quot;&gt;static_assert&lt;/a&gt; declaration or (since C11) have at least one declarator or declare at least one struct/union/enum tag, or introduce at least one enumeration constant.</source>
          <target state="translated">禁止使用空的声明符；声明必须是&lt;a href=&quot;static_assert&quot;&gt;static_assert&lt;/a&gt;声明，或者（自C11起）至少具有一个声明器，或者声明至少一个struct / union / enum标记，或者引入至少一个枚举常量。</target>
        </trans-unit>
        <trans-unit id="8354d856832ccb717132df4747df0b697bdada66" translate="yes" xml:space="preserve">
          <source>Entering the scope of a non-variably modified variable is permitted:</source>
          <target state="translated">允许进入一个不可变的修改变量的范围。</target>
        </trans-unit>
        <trans-unit id="cce45ab49aa862f3c61dbc001925b96425c01c53" translate="yes" xml:space="preserve">
          <source>Enumerated type is declared using the following</source>
          <target state="translated">枚举类型的声明如下</target>
        </trans-unit>
        <trans-unit id="b85c029cc85bf41632bef2658cfd560e45013841" translate="yes" xml:space="preserve">
          <source>Enumerated types are integer types, and as such can be used anywhere other integer types can, including in &lt;a href=&quot;conversion&quot;&gt;implicit conversions&lt;/a&gt; and &lt;a href=&quot;operator_arithmetic&quot;&gt;arithmetic operators&lt;/a&gt;.</source>
          <target state="translated">枚举类型是整数类型，因此可以在其他整数类型可以使用的任何地方使用，包括&lt;a href=&quot;conversion&quot;&gt;隐式转换&lt;/a&gt;和&lt;a href=&quot;operator_arithmetic&quot;&gt;算术运算符&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="413e9110db4f37157b581483ed8d7133f5021d89" translate="yes" xml:space="preserve">
          <source>Enumerations</source>
          <target state="translated">Enumerations</target>
        </trans-unit>
        <trans-unit id="f88783e04a87a739f9d3e33a3937c9a19a386846" translate="yes" xml:space="preserve">
          <source>Enumerations permit the declaration of named constants in a more convenient and structured fashion than does &lt;code&gt;#define&lt;/code&gt;; they are visible in the debugger, obey scope rules, and participate in the type system.</source>
          <target state="translated">与 &lt;code&gt;#define&lt;/code&gt; 相比，枚举允许以更方便和结构化的方式声明命名的常量；它们在调试器中可见，服从作用域规则，并参与类型系统。</target>
        </trans-unit>
        <trans-unit id="2a6aa35f8013684cff4ad26bb51395662e2921e2" translate="yes" xml:space="preserve">
          <source>Equality operators</source>
          <target state="translated">平等运算符</target>
        </trans-unit>
        <trans-unit id="1f55cac8623bcd3e718c002528aa20c26ca69289" translate="yes" xml:space="preserve">
          <source>Equivalent</source>
          <target state="translated">Equivalent</target>
        </trans-unit>
        <trans-unit id="c0c4f8d56bcbf00282cc105e43dd3c5e2278f8e5" translate="yes" xml:space="preserve">
          <source>Equivalent of</source>
          <target state="translated">相当于</target>
        </trans-unit>
        <trans-unit id="0d5a1140e6675b099ff86f62e1a9eab77af23453" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;fgetc&quot;&gt;getc&lt;/a&gt;(&lt;a href=&quot;../io&quot;&gt;stdin&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">等效于 &lt;code&gt;&lt;a href=&quot;fgetc&quot;&gt;getc&lt;/a&gt;(&lt;a href=&quot;../io&quot;&gt;stdin&lt;/a&gt;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c4437d42fc6fd03749f5eff27c4e2e72ba49870e" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;fmax&quot;&gt;fmax&lt;/a&gt;(x-y, 0)&lt;/code&gt; except for the NaN handling requirements.</source>
          <target state="translated">除NaN处理要求外，等效于 &lt;code&gt;&lt;a href=&quot;fmax&quot;&gt;fmax&lt;/a&gt;(x-y, 0)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="04012d0d49a9a54dad1dc682a3e125bd8fa3f90a" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;fputc&quot;&gt;putc&lt;/a&gt;(ch, &lt;a href=&quot;../io&quot;&gt;stdout&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">等效于 &lt;code&gt;&lt;a href=&quot;fputc&quot;&gt;putc&lt;/a&gt;(ch, &lt;a href=&quot;../io&quot;&gt;stdout&lt;/a&gt;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3afb8f001e247060377e8e5e40c5712afc040c31" translate="yes" xml:space="preserve">
          <source>Equivalent type</source>
          <target state="translated">等效类型</target>
        </trans-unit>
        <trans-unit id="9fc37eb09ee0018dcccc12a37a104dbad90d4bbf" translate="yes" xml:space="preserve">
          <source>Error and gamma functions</source>
          <target state="translated">误差和伽马函数</target>
        </trans-unit>
        <trans-unit id="5343729b1e8d28fc4392758181e1915608251253" translate="yes" xml:space="preserve">
          <source>Error directive</source>
          <target state="translated">错误指令</target>
        </trans-unit>
        <trans-unit id="73631d7f0356fdbdeaa36f8e5dbad89c6aa15dc4" translate="yes" xml:space="preserve">
          <source>Error handling</source>
          <target state="translated">错误处理</target>
        </trans-unit>
        <trans-unit id="f9c4c6711618f251c4a454ba58410243568d56b8" translate="yes" xml:space="preserve">
          <source>Error handling and special values</source>
          <target state="translated">错误处理和特殊值</target>
        </trans-unit>
        <trans-unit id="a70dcd4b1cc80d9067639e0fc5853ef1c8bcd9a3" translate="yes" xml:space="preserve">
          <source>Error numbers</source>
          <target state="translated">错误数</target>
        </trans-unit>
        <trans-unit id="9b7991b8ea4ab2716507d16d0d5014effed9479c" translate="yes" xml:space="preserve">
          <source>Errors and special cases are handled as if the function is implemented as &lt;code&gt;&lt;a href=&quot;../math/atan2&quot;&gt;atan2&lt;/a&gt;(&lt;a href=&quot;cimag&quot;&gt;cimag&lt;/a&gt;(z), &lt;a href=&quot;creal&quot;&gt;creal&lt;/a&gt;(z))&lt;/code&gt;.</source>
          <target state="translated">处理错误和特殊情况时，就像将函数实现为 &lt;code&gt;&lt;a href=&quot;../math/atan2&quot;&gt;atan2&lt;/a&gt;(&lt;a href=&quot;cimag&quot;&gt;cimag&lt;/a&gt;(z), &lt;a href=&quot;creal&quot;&gt;creal&lt;/a&gt;(z))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="29f3fbec0914aad4f195e9f22c13389761f4eda3" translate="yes" xml:space="preserve">
          <source>Errors and special cases are handled as if the function is implemented as &lt;code&gt;&lt;a href=&quot;../math/hypot&quot;&gt;hypot&lt;/a&gt;(&lt;a href=&quot;creal&quot;&gt;creal&lt;/a&gt;(z), &lt;a href=&quot;cimag&quot;&gt;cimag&lt;/a&gt;(z))&lt;/code&gt;.</source>
          <target state="translated">仿佛功能作为实现错误和特殊情况处理 &lt;code&gt;&lt;a href=&quot;../math/hypot&quot;&gt;hypot&lt;/a&gt;(&lt;a href=&quot;creal&quot;&gt;creal&lt;/a&gt;(z), &lt;a href=&quot;cimag&quot;&gt;cimag&lt;/a&gt;(z))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9f8ce90616fde10146b8dfeb4286e7484aadd29d" translate="yes" xml:space="preserve">
          <source>Errors and special cases are handled as if the operation is implemented by &lt;code&gt;-I * &lt;a href=&quot;casinh&quot;&gt;casinh&lt;/a&gt;(I*z)&lt;/code&gt;.</source>
          <target state="translated">错误和特殊情况的处理就像是由 &lt;code&gt;-I * &lt;a href=&quot;casinh&quot;&gt;casinh&lt;/a&gt;(I*z)&lt;/code&gt; 实现的操作一样。</target>
        </trans-unit>
        <trans-unit id="c2ad0fbbd2e9144d24b0206f35348f9eb15a8311" translate="yes" xml:space="preserve">
          <source>Errors and special cases are handled as if the operation is implemented by &lt;code&gt;-I * &lt;a href=&quot;catanh&quot;&gt;catanh&lt;/a&gt;(I*z)&lt;/code&gt;.</source>
          <target state="translated">错误和特殊情况的处理就像是由 &lt;code&gt;-I * &lt;a href=&quot;catanh&quot;&gt;catanh&lt;/a&gt;(I*z)&lt;/code&gt; 实现的操作一样。</target>
        </trans-unit>
        <trans-unit id="6535634d0df324c4614ac7796d64c3f99bbff78e" translate="yes" xml:space="preserve">
          <source>Errors and special cases are handled as if the operation is implemented by &lt;code&gt;-I * &lt;a href=&quot;csinh&quot;&gt;csinh&lt;/a&gt;(I*z)&lt;/code&gt;.</source>
          <target state="translated">错误和特殊情况的处理就像是由 &lt;code&gt;-I * &lt;a href=&quot;csinh&quot;&gt;csinh&lt;/a&gt;(I*z)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="48bd51bf26820b80bd7f413a44a3c11a3b8a5518" translate="yes" xml:space="preserve">
          <source>Errors and special cases are handled as if the operation is implemented by &lt;code&gt;-i * &lt;a href=&quot;ctanh&quot;&gt;ctanh&lt;/a&gt;(i*z)&lt;/code&gt;, where &lt;code&gt;i&lt;/code&gt; is the imaginary unit.</source>
          <target state="translated">处理错误和特殊情况时，就像该操作是通过 &lt;code&gt;-i * &lt;a href=&quot;ctanh&quot;&gt;ctanh&lt;/a&gt;(i*z)&lt;/code&gt; ，其中 &lt;code&gt;i&lt;/code&gt; 是虚数单位。</target>
        </trans-unit>
        <trans-unit id="ddccf748db358f35c8fb537b8295656e86fda50d" translate="yes" xml:space="preserve">
          <source>Errors and special cases are handled as if the operation is implemented by &lt;code&gt;&lt;a href=&quot;ccosh&quot;&gt;ccosh&lt;/a&gt;(I*z)&lt;/code&gt;.</source>
          <target state="translated">错误和特殊情况的处理就像是由 &lt;code&gt;&lt;a href=&quot;ccosh&quot;&gt;ccosh&lt;/a&gt;(I*z)&lt;/code&gt; 实现的操作一样。</target>
        </trans-unit>
        <trans-unit id="015370df3b3d878085ca7e1b0df922c105e8a2f7" translate="yes" xml:space="preserve">
          <source>Errors and special cases are handled as if the operation is implemented by &lt;code&gt;&lt;a href=&quot;cexp&quot;&gt;cexp&lt;/a&gt;(y*&lt;a href=&quot;clog&quot;&gt;clog&lt;/a&gt;(x))&lt;/code&gt;, except that the implementation is allowed to treat special cases more carefully.</source>
          <target state="translated">错误和特殊情况的处理就像是由 &lt;code&gt;&lt;a href=&quot;cexp&quot;&gt;cexp&lt;/a&gt;(y*&lt;a href=&quot;clog&quot;&gt;clog&lt;/a&gt;(x))&lt;/code&gt; 实现的操作一样，只是允许该实施更仔细地处理特殊情况。</target>
        </trans-unit>
        <trans-unit id="5664fd51a61bce212813ac45ba91c49cd919c4bb" translate="yes" xml:space="preserve">
          <source>Errors are reported as specified in &lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;.</source>
          <target state="translated">将按照&lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling中&lt;/a&gt;指定的方式报告错误。</target>
        </trans-unit>
        <trans-unit id="7331ffbc406cc972b5f70c046e3dc2cb4171b6f9" translate="yes" xml:space="preserve">
          <source>Errors are reported consistent with &lt;a href=&quot;../math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;.</source>
          <target state="translated">报告的错误与&lt;a href=&quot;../math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;一致。</target>
        </trans-unit>
        <trans-unit id="b4cfe1f435f06beaae8e7d7c6d43e5dddbe640bb" translate="yes" xml:space="preserve">
          <source>Escape</source>
          <target state="translated">Escape</target>
        </trans-unit>
        <trans-unit id="aa094bf265d4ea86b5f894d7a380cedfb2baed9e" translate="yes" xml:space="preserve">
          <source>Escape sequences</source>
          <target state="translated">逃逸序列</target>
        </trans-unit>
        <trans-unit id="85839c11b208637a83e2015db29c3b0304d083b7" translate="yes" xml:space="preserve">
          <source>Escape sequences are used to represent certain special characters within &lt;a href=&quot;string_literal&quot;&gt;string literals&lt;/a&gt; and &lt;a href=&quot;character_constant&quot;&gt;character constants&lt;/a&gt;.</source>
          <target state="translated">转义序列用于表示&lt;a href=&quot;string_literal&quot;&gt;字符串文字&lt;/a&gt;和&lt;a href=&quot;character_constant&quot;&gt;字符常量中的&lt;/a&gt;某些特殊字符。</target>
        </trans-unit>
        <trans-unit id="47781613c9e738b50e8ae9c4be68dba24be3e79d" translate="yes" xml:space="preserve">
          <source>Establishes memory synchronization ordering of non-atomic and relaxed atomic accesses, as instructed by &lt;code&gt;order&lt;/code&gt;, between a thread and a signal handler executed on the same thread. This is equivalent to &lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;atomic_thread_fence&lt;/a&gt;&lt;/code&gt;, except no CPU instructions for memory ordering are issued. Only reordering of the instructions by the compiler is suppressed as &lt;code&gt;order&lt;/code&gt; instructs. For example, a fence with release semantics prevents reads or writes from being moved past subsequent writes and a fence with acquire semantics prevents reads or writes from being moved ahead of preceding reads.</source>
          <target state="translated">按照 &lt;code&gt;order&lt;/code&gt; 的指示，在线程和在同一线程上执行的信号处理程序之间建立非原子访问和宽松原子访问的内存同步排序。这等效于 &lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;atomic_thread_fence&lt;/a&gt;&lt;/code&gt; ，除了没有发出用于内存排序的CPU指令。只有重新排序的编译器指令被抑制 &lt;code&gt;order&lt;/code&gt; 指示。例如，具有释放语义的篱笆可防止将读取或写入移动到后续写入之后，而具有获取语义的篱笆可防止将读取或写入移动到先前读取之前。</target>
        </trans-unit>
        <trans-unit id="048318643abdfe7a81cc91065c11083e88436879" translate="yes" xml:space="preserve">
          <source>Establishes memory synchronization ordering of non-atomic and relaxed atomic accesses, as instructed by &lt;code&gt;order&lt;/code&gt;, without an associated atomic operation. For example, all non-atomic and relaxed atomic stores that happen before a &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_release&lt;/a&gt;&lt;/code&gt; fence in thread A will be synchronized with non-atomic and relaxed atomic loads from the same locations made in thread B after an &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_acquire&lt;/a&gt;&lt;/code&gt; fence.</source>
          <target state="translated">按照 &lt;code&gt;order&lt;/code&gt; 的指示，建立非原子访问和宽松原子访问的内存同步排序，而没有相关的原子操作。例如，发生在线程A中的 &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_release&lt;/a&gt;&lt;/code&gt; 栅栏之前的所有非原子和弛豫原子存储将与在 &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_acquire&lt;/a&gt;&lt;/code&gt; 栅栏之后来自线程B中相同位置的非原子和弛豫原子负载同步。</target>
        </trans-unit>
        <trans-unit id="da7594d31984baf99a077013f0aee618827920d2" translate="yes" xml:space="preserve">
          <source>Evaluation order and sequencing</source>
          <target state="translated">评价顺序和排序</target>
        </trans-unit>
        <trans-unit id="88a2bca2793ae8a8d628ac99dc40807e8857f907" translate="yes" xml:space="preserve">
          <source>Evaluations</source>
          <target state="translated">Evaluations</target>
        </trans-unit>
        <trans-unit id="36ee6d82a71221af57f6cb7a03ba7685ffbfddc0" translate="yes" xml:space="preserve">
          <source>Even if the struct is declared at file scope, when the identifier used to access the struct has block scope, the aliasing assertions in the struct also have block scope; the aliasing assertions are only in effect within a block execution or a function call, depending on how the object of this struct type was created:</source>
          <target state="translated">即使结构体是在文件作用域声明的,当用于访问结构体的标识符具有块作用域时,结构体中的别名断言也具有块作用域;别名断言只在块执行或函数调用内有效,这取决于该结构体类型的对象是如何创建的。</target>
        </trans-unit>
        <trans-unit id="4d9633b8291e518788e5b04c3307f8044e23b7cb" translate="yes" xml:space="preserve">
          <source>Even though &lt;code&gt;%c&lt;/code&gt; expects &lt;code&gt;int&lt;/code&gt; argument, it is safe to pass a &lt;code&gt;char&lt;/code&gt; because of the integer promotion that takes place when a variadic function is called.</source>
          <target state="translated">即使 &lt;code&gt;%c&lt;/code&gt; 期望使用 &lt;code&gt;int&lt;/code&gt; 参数，也可以安全地传递 &lt;code&gt;char&lt;/code&gt; ,因为调用可变参数函数时会发生整数提升。</target>
        </trans-unit>
        <trans-unit id="5b93cdea25ae5893703b1e0c9f4bb48b32e72ce3" translate="yes" xml:space="preserve">
          <source>Even though the number of bits in the object representation of &lt;code&gt;_Bool&lt;/code&gt; is at least &lt;code&gt;&lt;a href=&quot;../types/limits&quot;&gt;CHAR_BIT&lt;/a&gt;&lt;/code&gt;, the width of the bit field of type &lt;code&gt;_Bool&lt;/code&gt; cannot be greater than 1.</source>
          <target state="translated">即使 &lt;code&gt;_Bool&lt;/code&gt; 的对象表示形式中的位数至少为 &lt;code&gt;&lt;a href=&quot;../types/limits&quot;&gt;CHAR_BIT&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;_Bool&lt;/code&gt; 类型的位字段的宽度也不能大于1。</target>
        </trans-unit>
        <trans-unit id="10fd3c8aba749cc32d306face2dcaddfb71e36f1" translate="yes" xml:space="preserve">
          <source>Even though there is no specific limit on the length of identifiers, early compilers had limits on the number of significant initial characters in identifiers and the linkers imposed stricter limits on the names with &lt;a href=&quot;storage_duration&quot;&gt;external linkage&lt;/a&gt;. C requires that at least the following limits are supported by any standard-compliant implementation:</source>
          <target state="translated">即使标识符的长度没有具体限制，早期的编译器也对标识符中有效的初始字符数进行了限制，并且链接器对具有&lt;a href=&quot;storage_duration&quot;&gt;外部链接&lt;/a&gt;的名称施加了更严格的限制。C要求任何符合标准的实现都至少支持以下限制：</target>
        </trans-unit>
        <trans-unit id="34f56d64ef5c3ff1c58a58a3f028aec046f7ad01" translate="yes" xml:space="preserve">
          <source>Every &lt;a href=&quot;conversion&quot;&gt;implicit conversion as if by assignment&lt;/a&gt; is allowed.</source>
          <target state="translated">允许每个&lt;a href=&quot;conversion&quot;&gt;隐式转换（就像通过赋值一样&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="0552d54ca99d47b5775e0a8174d152fba75dddd0" translate="yes" xml:space="preserve">
          <source>Every &lt;a href=&quot;object&quot;&gt;object&lt;/a&gt; has a property called</source>
          <target state="translated">每个&lt;a href=&quot;object&quot;&gt;对象&lt;/a&gt;都有一个称为</target>
        </trans-unit>
        <trans-unit id="79fb7987aac6f001bd1913612f374a0a305f404f" translate="yes" xml:space="preserve">
          <source>Every &lt;a href=&quot;object&quot;&gt;object&lt;/a&gt; in C exists, has a constant address, retains its last-stored value (except when the value is indeterminate), and, for VLA, retains its size(since C99) over a portion of program execution known as this object's</source>
          <target state="translated">C中的每个&lt;a href=&quot;object&quot;&gt;对象&lt;/a&gt;都存在，具有恒定的地址，保留其最后存储的值（值不确定时除外），并且对于VLA，在程序执行的一部分（称为C99）中保留其大小（自C99起）。</target>
        </trans-unit>
        <trans-unit id="d8cff106094b582cf23eb28cf52ff54b75ae2920" translate="yes" xml:space="preserve">
          <source>Every C program coded to run in a hosted execution environment contains the definition (not the prototype) of a function called &lt;code&gt;main&lt;/code&gt;, which is the designated start of the program.</source>
          <target state="translated">每个编码为在托管执行环境中运行的C程序都包含一个名为 &lt;code&gt;main&lt;/code&gt; 的函数的定义（而不是原型），该函数是程序的指定开始。</target>
        </trans-unit>
        <trans-unit id="cae676f55ead9bfd321ee42d49211710fc97d787" translate="yes" xml:space="preserve">
          <source>Every access (both read and write) made through an lvalue expression of volatile-qualified type is considered an observable side effect for the purpose of optimization and is evaluated strictly according to the rules of the abstract machine (that is, all writes are completed at some time before the next sequence point). This means that within a single thread of execution, a volatile access cannot be optimized out or reordered relative to another visible side effect that is separated by a &lt;a href=&quot;eval_order&quot;&gt;sequence point&lt;/a&gt; from the volatile access.</source>
          <target state="translated">通过volatile限定类型的左值表达式进行的每次访问（读和写）都被认为是可观察到的副作用，用于优化目的，并且严格按照抽象机的规则进行评估（也就是说，所有写操作均在以下位置完成）在下一个序列点之前的某个时间）。这意味着，在单个执行线程中，相对于由&lt;a href=&quot;eval_order&quot;&gt;序列点&lt;/a&gt;与易失性访问分隔开的另一个可见副作用，易失性访问无法优化或重新排序。</target>
        </trans-unit>
        <trans-unit id="df1932660c52d52e2e26dcedc3c43bd56fad8d39" translate="yes" xml:space="preserve">
          <source>Every complete &lt;a href=&quot;types#Type_groups&quot;&gt;object type&lt;/a&gt; has a property called</source>
          <target state="translated">每个完整的&lt;a href=&quot;types#Type_groups&quot;&gt;对象类型&lt;/a&gt;都有一个称为</target>
        </trans-unit>
        <trans-unit id="e8fde6683e1cba2eec62200fcab6dfb05315c256" translate="yes" xml:space="preserve">
          <source>Every declaration of an &lt;a href=&quot;enum&quot;&gt;enum&lt;/a&gt; or a &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; is a definition.</source>
          <target state="translated">&lt;a href=&quot;enum&quot;&gt;枚举&lt;/a&gt;或&lt;a href=&quot;typedef&quot;&gt;typedef的&lt;/a&gt;每个声明都是一个定义。</target>
        </trans-unit>
        <trans-unit id="b050826ffcdfc3e1e44f6fc0d20279eecea1e997" translate="yes" xml:space="preserve">
          <source>Every expression belongs to one of three value categories: lvalue, non-lvalue object (rvalue), and function designator.</source>
          <target state="translated">每一个表达式都属于三个值类别中的一个:l值、非值对象(r值)和函数代号。</target>
        </trans-unit>
        <trans-unit id="5d22a5219034805f8cbb9d13ebb2c2aa525868ea" translate="yes" xml:space="preserve">
          <source>Every expression in the initializer list must be a &lt;a href=&quot;constant_expression&quot;&gt;constant expression&lt;/a&gt; when initializing aggregates of any storage duration.</source>
          <target state="translated">初始化任何存储持续时间的聚合时，初始化器列表中的每个表达式都必须是一个&lt;a href=&quot;constant_expression&quot;&gt;常量表达式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8061fc72228b0f11d8e5fe2acd66cf7973c92c06" translate="yes" xml:space="preserve">
          <source>Every identifier other than macro name or macro parameter name has &lt;a href=&quot;scope&quot;&gt;scope&lt;/a&gt;, belongs to a &lt;a href=&quot;name_space&quot;&gt;name space&lt;/a&gt;, and may have &lt;a href=&quot;storage_duration&quot;&gt;linkage&lt;/a&gt;. The same identifier can denote different entities at different points in the program, or may denote different entities at the same point if the entities are in different name spaces.</source>
          <target state="translated">除宏名称或宏参数名称以外的每个标识符都有&lt;a href=&quot;scope&quot;&gt;作用域&lt;/a&gt;，属于一个&lt;a href=&quot;name_space&quot;&gt;名称空间&lt;/a&gt;，并且可以具有&lt;a href=&quot;storage_duration&quot;&gt;链接&lt;/a&gt;。相同的标识符可以表示程序中不同点的不同实体，或者如果实体在不同的名称空间中，则可以在同一点表示不同的实体。</target>
        </trans-unit>
        <trans-unit id="28bf02b780b942d327d4765f8dca30714c80b2c2" translate="yes" xml:space="preserve">
          <source>Every object has an</source>
          <target state="translated">每个对象都有一个</target>
        </trans-unit>
        <trans-unit id="2cb5903e11e24e79124c7b84f8abc476a4f4997a" translate="yes" xml:space="preserve">
          <source>Every object has.</source>
          <target state="translated">每个物体都有:</target>
        </trans-unit>
        <trans-unit id="0cae74747ce921ce4dc2761826efeaa22990fc6f" translate="yes" xml:space="preserve">
          <source>Exact</source>
          <target state="translated">Exact</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="0846421fa4d44dac1b26a7842a49c3943013e9ff" translate="yes" xml:space="preserve">
          <source>Except for &lt;a href=&quot;bit_field&quot;&gt;bit fields&lt;/a&gt;, objects are composed of contiguous sequences of one or more bytes, each consisting of &lt;code&gt;&lt;a href=&quot;../types/limits&quot;&gt;CHAR_BIT&lt;/a&gt;&lt;/code&gt; bits, and can be copied with &lt;code&gt;&lt;a href=&quot;../string/byte/memcpy&quot;&gt;memcpy&lt;/a&gt;&lt;/code&gt; into an object of type &lt;code&gt;unsigned char[n]&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the size of the object. The contents of the resulting array are known as</source>
          <target state="translated">除&lt;a href=&quot;bit_field&quot;&gt;位字段外&lt;/a&gt;，对象由一个或多个字节的连续序列组成，每个序列由 &lt;code&gt;&lt;a href=&quot;../types/limits&quot;&gt;CHAR_BIT&lt;/a&gt;&lt;/code&gt; 位组成，并且可以通过 &lt;code&gt;&lt;a href=&quot;../string/byte/memcpy&quot;&gt;memcpy&lt;/a&gt;&lt;/code&gt; 复制到 &lt;code&gt;unsigned char[n]&lt;/code&gt; 类型的对象中，其中 &lt;code&gt;n&lt;/code&gt; 是对象的大小。结果数组的内容称为</target>
        </trans-unit>
        <trans-unit id="a4c65a0cba6faa6401c55873ee72909d9d343ce9" translate="yes" xml:space="preserve">
          <source>Except if the type of expression is a &lt;a href=&quot;array&quot;&gt;VLA&lt;/a&gt;, (since C99)expression is not evaluated and the &lt;code&gt;sizeof&lt;/code&gt; operator may be used in an integer &lt;a href=&quot;constant_expression&quot;&gt;constant expression&lt;/a&gt;.</source>
          <target state="translated">除非表达式的类型是&lt;a href=&quot;array&quot;&gt;VLA&lt;/a&gt;，否则不评估（自C99起）表达式，并且可以在整数&lt;a href=&quot;constant_expression&quot;&gt;常量表达式中&lt;/a&gt;使用 &lt;code&gt;sizeof&lt;/code&gt; 运算符。</target>
        </trans-unit>
        <trans-unit id="c82c4955ac4c657fe3c1c1a33c42f14589789f17" translate="yes" xml:space="preserve">
          <source>Except the redundant parentheses around the identifier are meaningful in a type-name and represent &quot;function with no parameter specification&quot;:</source>
          <target state="translated">除了标识符周围的冗余括号在类型名中是有意义的,代表 &quot;没有参数规范的函数&quot;。</target>
        </trans-unit>
        <trans-unit id="c39d3a34e7546d37d567982f43f1e3ec730f1f22" translate="yes" xml:space="preserve">
          <source>Except within a &lt;a href=&quot;language/character_constant&quot;&gt;character constant&lt;/a&gt;, a &lt;a href=&quot;language/string_literal&quot;&gt;string literal&lt;/a&gt;, or a comment, the characters &lt;code&gt;/*&lt;/code&gt; introduce a comment. The contents of such a comment are examined only to identify multibyte characters and to find the characters &lt;code&gt;*/&lt;/code&gt; that terminate the comment. C-style comments cannot be nested.</source>
          <target state="translated">除了&lt;a href=&quot;language/character_constant&quot;&gt;字符常量&lt;/a&gt;，&lt;a href=&quot;language/string_literal&quot;&gt;字符串文字&lt;/a&gt;或注释内，字符 &lt;code&gt;/*&lt;/code&gt; 会引入注释。仅检查此类注释的内容以识别多字节字符并找到终止注释的字符 &lt;code&gt;*/&lt;/code&gt; 。C样式的注释不能嵌套。</target>
        </trans-unit>
        <trans-unit id="bddc2538ec8959f0494f56c6df15dc6c8b6728c6" translate="yes" xml:space="preserve">
          <source>Except within a &lt;a href=&quot;language/character_constant&quot;&gt;character constant&lt;/a&gt;, a &lt;a href=&quot;language/string_literal&quot;&gt;string literal&lt;/a&gt;, or a comment, the characters &lt;code&gt;//&lt;/code&gt; introduce a comment that includes all multibyte characters up to, but not including, the next new-line character. The contents of such a comment are examined only to identify multibyte characters and to find the new-line character that terminates the comment. C++-style comments can be nested:</source>
          <target state="translated">除了&lt;a href=&quot;language/character_constant&quot;&gt;字符常量&lt;/a&gt;，&lt;a href=&quot;language/string_literal&quot;&gt;字符串文字&lt;/a&gt;或注释内，字符 &lt;code&gt;//&lt;/code&gt; 会引入注释，该注释包括所有多字节字符，直到（但不包括）下一个换行符。仅检查此类注释的内容，以识别多字节字符并找到终止注释的换行符。可以嵌套C ++样式的注释：</target>
        </trans-unit>
        <trans-unit id="3f8a730b7e50f87ea67dec5244562816a07b3aaa" translate="yes" xml:space="preserve">
          <source>Executes a loop.</source>
          <target state="translated">执行一个循环。</target>
        </trans-unit>
        <trans-unit id="2134926c41a5af01a113605847abc27742273c7e" translate="yes" xml:space="preserve">
          <source>Executes a statement repeatedly until the value of condition becomes false. The test takes place after each iteration.</source>
          <target state="translated">反复执行一个语句,直到条件值变成false。每次迭代后都会进行测试。</target>
        </trans-unit>
        <trans-unit id="11f93f9b195c7cd21096794e98c03a7027da2f79" translate="yes" xml:space="preserve">
          <source>Executes a statement repeatedly, until the value of expression becomes equal to zero. The test takes place before each iteration.</source>
          <target state="translated">反复执行一条语句,直到表达式的值等于零。每次迭代前都要进行测试。</target>
        </trans-unit>
        <trans-unit id="85e7dec4537bfae2058cca4e9884515a8b83fb5b" translate="yes" xml:space="preserve">
          <source>Executes code according to the value of an integral argument.</source>
          <target state="translated">根据积分参数的值执行代码。</target>
        </trans-unit>
        <trans-unit id="27cfa9eee3e7ceef3b1e500e47b1e1610a8c97f4" translate="yes" xml:space="preserve">
          <source>Executing the &lt;code&gt;return&lt;/code&gt; statement in a &lt;a href=&quot;_noreturn&quot;&gt;no-return function&lt;/a&gt; is undefined behavior.</source>
          <target state="translated">在&lt;a href=&quot;_noreturn&quot;&gt;不返回函数中&lt;/a&gt;执行 &lt;code&gt;return&lt;/code&gt; 语句是未定义的行为。</target>
        </trans-unit>
        <trans-unit id="28c764ed1d6222630406c5783a2aaab97f66bd88" translate="yes" xml:space="preserve">
          <source>Expanded value</source>
          <target state="translated">扩大的价值</target>
        </trans-unit>
        <trans-unit id="2c1bd25ffde3db50385bd1702ced6f7b127db28b" translate="yes" xml:space="preserve">
          <source>Expands to</source>
          <target state="translated">扩大到</target>
        </trans-unit>
        <trans-unit id="8faacdf8b7af79664977eafc89be9750aba9f6d1" translate="yes" xml:space="preserve">
          <source>Expands to &lt;a href=&quot;../language/constant_expression&quot;&gt;preprocessor constant expressions&lt;/a&gt; that evaluate to either &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt;, or &lt;code&gt;2&lt;/code&gt; which indicate the lock-free property of the corresponding &lt;a href=&quot;../atomic&quot;&gt;atomic types&lt;/a&gt; (both signed and unsigned).</source>
          <target state="translated">膨胀到&lt;a href=&quot;../language/constant_expression&quot;&gt;预处理器常量表达式&lt;/a&gt;计算结果为任一 &lt;code&gt;0&lt;/code&gt; ， &lt;code&gt;1&lt;/code&gt; ，或 &lt;code&gt;2&lt;/code&gt; ，其指示相应的无锁属性&lt;a href=&quot;../atomic&quot;&gt;原子类型&lt;/a&gt;（有符号和无符号的）。</target>
        </trans-unit>
        <trans-unit id="4945de103990c828d28d11116d17a1455abd773d" translate="yes" xml:space="preserve">
          <source>Expands to a positive integral &lt;a href=&quot;../language/constant_expression&quot;&gt;constant expression&lt;/a&gt; defining the maximum number of times a destructor for thread-local storage pointer will be called by &lt;code&gt;&lt;a href=&quot;thrd_exit&quot;&gt;thrd_exit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">扩展为正整数&lt;a href=&quot;../language/constant_expression&quot;&gt;常量表达式，&lt;/a&gt;该表达式定义 &lt;code&gt;&lt;a href=&quot;thrd_exit&quot;&gt;thrd_exit&lt;/a&gt;&lt;/code&gt; 调用线程本地存储指针的析构函数的最大次数。</target>
        </trans-unit>
        <trans-unit id="6ac04c5b090acc87427f403a76810b032235784c" translate="yes" xml:space="preserve">
          <source>Expands to an expression (not necessarily a compile-time constant) of type &lt;code&gt;&lt;a href=&quot;clock_t&quot;&gt;clock_t&lt;/a&gt;&lt;/code&gt; equal to the number of clock ticks per second, as returned by &lt;code&gt;&lt;a href=&quot;clock&quot;&gt;clock()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">扩展为 &lt;code&gt;&lt;a href=&quot;clock_t&quot;&gt;clock_t&lt;/a&gt;&lt;/code&gt; 类型的表达式（不一定是编译时常量），该表达式等于 &lt;code&gt;&lt;a href=&quot;clock&quot;&gt;clock()&lt;/a&gt;&lt;/code&gt; 返回的每秒的时钟滴答数。</target>
        </trans-unit>
        <trans-unit id="63f947b1d73753094d1ae7232094c3d68be133d1" translate="yes" xml:space="preserve">
          <source>Expands to an expression that can be used to initialize &lt;code&gt;&lt;a href=&quot;atomic_flag&quot;&gt;atomic_flag&lt;/a&gt;&lt;/code&gt; type. The value &lt;code&gt;atomic_flag&lt;/code&gt; that is not initialized using this macro is undefined.</source>
          <target state="translated">扩展为可用于初始化 &lt;code&gt;&lt;a href=&quot;atomic_flag&quot;&gt;atomic_flag&lt;/a&gt;&lt;/code&gt; 类型的表达式。未使用此宏初始化的值 &lt;code&gt;atomic_flag&lt;/code&gt; 未定义。</target>
        </trans-unit>
        <trans-unit id="6e54e6049cc9eea669bc3e5a4c9bc5a1dfc7508f" translate="yes" xml:space="preserve">
          <source>Expands to an expression that can be used to initialize an atomic variable of the same type as &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">扩展为可用于初始化与 &lt;code&gt;value&lt;/code&gt; 类型相同的原子变量的表达式。</target>
        </trans-unit>
        <trans-unit id="8db16a62cd0eecafad46f2d6c4cb160336ba4375" translate="yes" xml:space="preserve">
          <source>Expands to an integer constant expression equal to the maximum value returned by the function &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt;. This value is implementation dependent. It's guaranteed that this value is at least &lt;code&gt;32767&lt;/code&gt;.</source>
          <target state="translated">扩展为等于函数 &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; 返回的最大值的整数常量表达式。此值取决于实现。确保该值至少为 &lt;code&gt;32767&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b74a3f6f88cbf8779ab38cebe0c4e5a1aa35bcc5" translate="yes" xml:space="preserve">
          <source>Expands to positive &lt;code&gt;double&lt;/code&gt; expression that indicates overflow, not necessarily representable as a &lt;code&gt;float&lt;/code&gt;</source>
          <target state="translated">扩展为表示溢出的正 &lt;code&gt;double&lt;/code&gt; 表达式，不一定表示为 &lt;code&gt;float&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f5ccabdc1716ee0f1f6ba421bfe7a3cb18e19e27" translate="yes" xml:space="preserve">
          <source>Expands to positive &lt;code&gt;float&lt;/code&gt; expression that indicates overflow</source>
          <target state="translated">扩展为表示溢出的正 &lt;code&gt;float&lt;/code&gt; 表达式</target>
        </trans-unit>
        <trans-unit id="1517f254032c8417e8afa57de1c3cc258d11f6c4" translate="yes" xml:space="preserve">
          <source>Expands to positive &lt;code&gt;long double&lt;/code&gt; expression that indicates overflow, not necessarily representable as a &lt;code&gt;float&lt;/code&gt; or &lt;code&gt;double&lt;/code&gt;</source>
          <target state="translated">扩展为表示溢出的正 &lt;code&gt;long double&lt;/code&gt; &lt;code&gt;float&lt;/code&gt; 表达式，不一定表示为float或 &lt;code&gt;double&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b32ef340ea4702fd5f41dbe4001671d76174ef71" translate="yes" xml:space="preserve">
          <source>Explanation</source>
          <target state="translated">Explanation</target>
        </trans-unit>
        <trans-unit id="9871eb9d9db410b188224356bf06656bc0125776" translate="yes" xml:space="preserve">
          <source>Explicit initialization</source>
          <target state="translated">明确的初始化</target>
        </trans-unit>
        <trans-unit id="dd8bfe3fdab8ac97b580b2a4aef0404f178b5ac1" translate="yes" xml:space="preserve">
          <source>Exponential functions</source>
          <target state="translated">指数函数</target>
        </trans-unit>
        <trans-unit id="af1ce2aaa5c978ee528dbd127a42e4189e15865d" translate="yes" xml:space="preserve">
          <source>Expression evaluation may produce a result (e.g., evaluation of &lt;code&gt;2+2&lt;/code&gt; produces the result &lt;code&gt;4&lt;/code&gt;), may generate side-effects (e.g. evaluation of &lt;code&gt;&lt;a href=&quot;../io/fprintf&quot;&gt;printf&lt;/a&gt;(&quot;%d&quot;,4)&lt;/code&gt; sends the character &lt;code&gt;'4'&lt;/code&gt; to the standard output stream), and may designate objects or functions.</source>
          <target state="translated">表达式评估可能会产生结果（例如 &lt;code&gt;2+2&lt;/code&gt; 会产生结果 &lt;code&gt;4&lt;/code&gt; ），可能会产生副作用（例如 &lt;code&gt;&lt;a href=&quot;../io/fprintf&quot;&gt;printf&lt;/a&gt;(&quot;%d&quot;,4)&lt;/code&gt; 评估会将字符 &lt;code&gt;'4'&lt;/code&gt; 发送到标准输出流） ，并可以指定对象或功能。</target>
        </trans-unit>
        <trans-unit id="0a7a6ba0d7d2af3106edf9d912c2fc5a47512f54" translate="yes" xml:space="preserve">
          <source>Expression statements</source>
          <target state="translated">表达式语句</target>
        </trans-unit>
        <trans-unit id="ae5fccd8dcd8fc317f8edfc8259af86cd2967a29" translate="yes" xml:space="preserve">
          <source>Expressions</source>
          <target state="translated">Expressions</target>
        </trans-unit>
        <trans-unit id="f353e8f82ea2aa488317fc7d8263ec638f8988ee" translate="yes" xml:space="preserve">
          <source>Expressions that are used in the &lt;a href=&quot;initialization&quot;&gt;initializers&lt;/a&gt; of objects with static and thread_local &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt; must be expressions that may be one of the following.</source>
          <target state="translated">具有静态和thread_local &lt;a href=&quot;storage_duration&quot;&gt;存储持续时间&lt;/a&gt;的对象的&lt;a href=&quot;initialization&quot;&gt;初始化程序&lt;/a&gt;中使用的表达式必须是下列表达式之一。</target>
        </trans-unit>
        <trans-unit id="73a249c29d63b610061072ac728997168ac1fe92" translate="yes" xml:space="preserve">
          <source>Extended multibyte and wide character utilities</source>
          <target state="translated">扩展的多字节和宽字符实用程序</target>
        </trans-unit>
        <trans-unit id="29449f104db7b7f4060421a59f2c8652fcaf7414" translate="yes" xml:space="preserve">
          <source>External and tentative definitions</source>
          <target state="translated">外部定义和暂定定义</target>
        </trans-unit>
        <trans-unit id="f92e601eb8d663033dca3851ad6f1616d1966aa7" translate="yes" xml:space="preserve">
          <source>External links</source>
          <target state="translated">外部链接</target>
        </trans-unit>
        <trans-unit id="77c407388266a4e5e937fe92a0ce467e4d5cf334" translate="yes" xml:space="preserve">
          <source>F.10.1.1 The acos functions (p: 518)</source>
          <target state="translated">F.10.1.1 acos功能(第518页)</target>
        </trans-unit>
        <trans-unit id="cad3287a73936ba75ca64c1f05a0a540c8022d26" translate="yes" xml:space="preserve">
          <source>F.10.1.2 The asin functions (p: 518)</source>
          <target state="translated">F.10.1.2 Asin函数(第518页)</target>
        </trans-unit>
        <trans-unit id="9ef85f92ec5474ff35787d85c82c58bf7b470d4a" translate="yes" xml:space="preserve">
          <source>F.10.1.3 The atan functions (p: 519)</source>
          <target state="translated">F.10.1.3 阿坦函数(第519页)</target>
        </trans-unit>
        <trans-unit id="61654a10c29f6924e433f111ed48191ac88a2ce3" translate="yes" xml:space="preserve">
          <source>F.10.1.4 The atan2 functions (p: 519)</source>
          <target state="translated">F.10.1.4 atan2函数(第519页)</target>
        </trans-unit>
        <trans-unit id="6b87bded088091f390f6ffad328a772e7e512e59" translate="yes" xml:space="preserve">
          <source>F.10.1.5 The cos functions (p: 519)</source>
          <target state="translated">F.10.1.5 余弦函数 (p:519)</target>
        </trans-unit>
        <trans-unit id="d91aaea4c9d5123a333ed526b7019e6fe8161791" translate="yes" xml:space="preserve">
          <source>F.10.1.6 The sin functions (p: 519)</source>
          <target state="translated">F.10.1.6 正弦函数 (p:519)</target>
        </trans-unit>
        <trans-unit id="037480d4008aac1c2ced1847c0d6506eaff99f02" translate="yes" xml:space="preserve">
          <source>F.10.1.7 The tan functions (p: 519)</source>
          <target state="translated">F.10.1.7 tan函数(第519页)</target>
        </trans-unit>
        <trans-unit id="39ece3e4b919950cc9aef1f79b7ea2b485b2f749" translate="yes" xml:space="preserve">
          <source>F.10.10.1 The fma functions (p: 530)</source>
          <target state="translated">F.10.10.1 fma函数(第530页)</target>
        </trans-unit>
        <trans-unit id="d4f406e24acff82500d3f53854f757aefe80a88b" translate="yes" xml:space="preserve">
          <source>F.10.11 Comparison macros (p: 531)</source>
          <target state="translated">F.10.11 比较宏(p:531)</target>
        </trans-unit>
        <trans-unit id="9b3f0ad6a5d5f3bdc88332446b21be594cf5b850" translate="yes" xml:space="preserve">
          <source>F.10.2.1 The acosh functions (p: 520)</source>
          <target state="translated">F.10.2.1 acosh功能(第520页)</target>
        </trans-unit>
        <trans-unit id="e8a5915d0ff8e75d37c89114700efa34fcb3655c" translate="yes" xml:space="preserve">
          <source>F.10.2.2 The asinh functions (p: 520)</source>
          <target state="translated">F.10.2.2 Asinh函数(第520页)</target>
        </trans-unit>
        <trans-unit id="38d01d22054b31ca110c70ecab03b46da04ddbde" translate="yes" xml:space="preserve">
          <source>F.10.2.3 The atanh functions (p: 520)</source>
          <target state="translated">F.10.2.3 atanh函数(第520页)</target>
        </trans-unit>
        <trans-unit id="6d1dcd9f7c26773cd7824edef93f2bc153fcedd1" translate="yes" xml:space="preserve">
          <source>F.10.2.4 The cosh functions (p: 520)</source>
          <target state="translated">F.10.2.4 cosh函数(p:520)</target>
        </trans-unit>
        <trans-unit id="958c262e658f94cec62537f399da067e4b2a3687" translate="yes" xml:space="preserve">
          <source>F.10.2.5 The sinh functions (p: 520)</source>
          <target state="translated">F.10.2.5 正弦函数(第520页)</target>
        </trans-unit>
        <trans-unit id="89846dc268c67d448208698d5fb48751a4fa3ee7" translate="yes" xml:space="preserve">
          <source>F.10.2.6 The tanh functions (p: 520)</source>
          <target state="translated">F.10.2.6 tanh函数(第520页)</target>
        </trans-unit>
        <trans-unit id="087ba78251d8a6578f4172770ba9fb671bdc2930" translate="yes" xml:space="preserve">
          <source>F.10.3.1 The exp functions (p: 520)</source>
          <target state="translated">F.10.3.1指数函数(第520页)</target>
        </trans-unit>
        <trans-unit id="d2f1b4b78961c78fd097a3f2e3d5c95ac97b0697" translate="yes" xml:space="preserve">
          <source>F.10.3.10 The log2 functions (p: 522)</source>
          <target state="translated">F.10.3.10 对数2函数(第522页)</target>
        </trans-unit>
        <trans-unit id="794d0f6de81eceae99a02eae8075568628225b13" translate="yes" xml:space="preserve">
          <source>F.10.3.11 The logb functions (p: 522)</source>
          <target state="translated">F.10.3.11 logb函数(第522页)</target>
        </trans-unit>
        <trans-unit id="359790e2c483d46f6d5fa87180647464c9ffd494" translate="yes" xml:space="preserve">
          <source>F.10.3.12 The modf functions (p: 523)</source>
          <target state="translated">F.10.3.12 modf函数(p:523)</target>
        </trans-unit>
        <trans-unit id="26231b94cbb9b4ccc5abf2b75e7483700a200573" translate="yes" xml:space="preserve">
          <source>F.10.3.13 The scalbn functions (p: 523)</source>
          <target state="translated">F.10.3.13 scalbn函数(第523页)</target>
        </trans-unit>
        <trans-unit id="c4c4e3a6535940d3ad6a58b578ff6b3f648cea5c" translate="yes" xml:space="preserve">
          <source>F.10.3.2 The exp2 functions (p: 521)</source>
          <target state="translated">F.10.3.2 exp2函数(第521页)</target>
        </trans-unit>
        <trans-unit id="2ea743c028232e6944fba4cc2a23ead42a73967b" translate="yes" xml:space="preserve">
          <source>F.10.3.3 The expm1 functions (p: 521)</source>
          <target state="translated">F.10.3.3 expm1函数(第521页)</target>
        </trans-unit>
        <trans-unit id="8b40b0a0ad12eacc6381e986766eb2e5616397d0" translate="yes" xml:space="preserve">
          <source>F.10.3.4 The frexp functions (p: 521)</source>
          <target state="translated">F.10.3.4 frexp函数 (p:521)</target>
        </trans-unit>
        <trans-unit id="a0911a9469e43f63891c8efa1bec7f36ad8c8abc" translate="yes" xml:space="preserve">
          <source>F.10.3.5 The ilogb functions (p: 521)</source>
          <target state="translated">F.10.3.5 ilogb函数(第521页)</target>
        </trans-unit>
        <trans-unit id="75a2fa7eb5b40194e1e37e5ef123f250b756926a" translate="yes" xml:space="preserve">
          <source>F.10.3.6 The ldexp functions (p: 522)</source>
          <target state="translated">F.10.3.6 ldexp函数 (p:522)</target>
        </trans-unit>
        <trans-unit id="6f56427ef5bda97f9bd0f1abdca0f2d6c6ff57e8" translate="yes" xml:space="preserve">
          <source>F.10.3.7 The log functions (p: 522)</source>
          <target state="translated">F.10.3.7 对数函数(第522页)</target>
        </trans-unit>
        <trans-unit id="f594a7472fd58a9aac605b75beccc17bd59b8dd5" translate="yes" xml:space="preserve">
          <source>F.10.3.8 The log10 functions (p: 522)</source>
          <target state="translated">F.10.3.8 log10函数(第522页)</target>
        </trans-unit>
        <trans-unit id="a48a20da2597afea4f32bc8128a961f30186bb43" translate="yes" xml:space="preserve">
          <source>F.10.3.9 The log1p functions (p: 522)</source>
          <target state="translated">F.10.3.9 log1p函数(第522页)</target>
        </trans-unit>
        <trans-unit id="7e9241bf052c178aa5d7679b82aa2fb1f5f3429f" translate="yes" xml:space="preserve">
          <source>F.10.4.1 The cbrt functions (p: 524)</source>
          <target state="translated">F.10.4.1计算机辅助记录功能(第524页)</target>
        </trans-unit>
        <trans-unit id="17febc2a8e0db50799bb968259ec83e250637ecf" translate="yes" xml:space="preserve">
          <source>F.10.4.3 The hypot functions (p: 524)</source>
          <target state="translated">F.10.4.3 下肢功能(第524页)</target>
        </trans-unit>
        <trans-unit id="625f08597fe348094478d4ebb805e20b1dc18589" translate="yes" xml:space="preserve">
          <source>F.10.4.4 The pow functions (p: 524-525)</source>
          <target state="translated">F.10.4.4 pow函数(第524-525页)</target>
        </trans-unit>
        <trans-unit id="25725da8bd22d2591488c89637aeec539180512b" translate="yes" xml:space="preserve">
          <source>F.10.4.5 The sqrt functions (p: 525)</source>
          <target state="translated">F.10.4.5 sqrt函数(p:525)</target>
        </trans-unit>
        <trans-unit id="16f4c89fcc73a73762071c025286f4c826a965e3" translate="yes" xml:space="preserve">
          <source>F.10.5.1 The erf functions (p: 525)</source>
          <target state="translated">F.10.5.1 erf函数(第525页)</target>
        </trans-unit>
        <trans-unit id="206fe7eceb3eeb950c8c0e350ab59cd90863fff1" translate="yes" xml:space="preserve">
          <source>F.10.5.2 The erfc functions (p: 525)</source>
          <target state="translated">F.10.5.2 erfc函数(第525页)</target>
        </trans-unit>
        <trans-unit id="6d9ef222b026d1552a6e019e7cec89f1462b487f" translate="yes" xml:space="preserve">
          <source>F.10.5.3 The lgamma functions (p: 525)</source>
          <target state="translated">F.10.5.3 lgamma函数(第525页)</target>
        </trans-unit>
        <trans-unit id="f246fcb4689fd18925ec623bbfcc71a41b0465c4" translate="yes" xml:space="preserve">
          <source>F.10.5.4 The tgamma functions (p: 525)</source>
          <target state="translated">F.10.5.4 tgamma函数(第525页)</target>
        </trans-unit>
        <trans-unit id="cb2de2da7dae0b99044effe02f5a47bdaadc48af" translate="yes" xml:space="preserve">
          <source>F.10.6.1 The ceil functions (p: 526)</source>
          <target state="translated">F.10.6.1 上限函数(第526页)</target>
        </trans-unit>
        <trans-unit id="1b33b3f7cf068beaaa2da5d9ab8c39148105a3cc" translate="yes" xml:space="preserve">
          <source>F.10.6.2 The floor functions (p: 526)</source>
          <target state="translated">F.10.6.2 底限函数(第526页)</target>
        </trans-unit>
        <trans-unit id="f6ebb7d3b865f6734b8512e6179d7dfe39d6858d" translate="yes" xml:space="preserve">
          <source>F.10.6.3 The nearbyint functions (p: 526)</source>
          <target state="translated">F.10.6.3 邻近函数(p:526)</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
