<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="vuex">
    <body>
      <group id="vuex">
        <trans-unit id="74ae1a27792287a53f632864ec413cb560452e7e" translate="yes" xml:space="preserve">
          <source>&quot;createLogger&quot; function is exported from the core module</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9b529393c3179a77a9306c183468564863d0ff0" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2015&amp;ndash;present Evan You</source>
          <target state="translated">&amp;copy;2015年至今Evan You</target>
        </trans-unit>
        <trans-unit id="3dbca386b3bf4c0c03ea3c64d065f726c26a64b7" translate="yes" xml:space="preserve">
          <source>1. Installation</source>
          <target state="translated">1.安装</target>
        </trans-unit>
        <trans-unit id="7644d763c0c7ace9ff19d36e4552b445a389efe0" translate="yes" xml:space="preserve">
          <source>10. Strict Mode</source>
          <target state="translated">10.严格模式</target>
        </trans-unit>
        <trans-unit id="290258555d6677c0ac84626e214aa009f8a85e64" translate="yes" xml:space="preserve">
          <source>11. Form Handling</source>
          <target state="translated">11.表格处理</target>
        </trans-unit>
        <trans-unit id="4129c08ad5f758bb8883f75f714cc03d6b8724d7" translate="yes" xml:space="preserve">
          <source>12. Testing</source>
          <target state="translated">第十二次测试</target>
        </trans-unit>
        <trans-unit id="528a3b9b2d03ca80ea557ac5c60aa567789512ff" translate="yes" xml:space="preserve">
          <source>13. Hot Reloading</source>
          <target state="translated">13.热重装</target>
        </trans-unit>
        <trans-unit id="dbc8b357691409e9c4daf2c6428dbe68446dc47c" translate="yes" xml:space="preserve">
          <source>2. Getting Started</source>
          <target state="translated">2.入门</target>
        </trans-unit>
        <trans-unit id="999bcc9c65f419d4177fbc85fb43d8d53350ea26" translate="yes" xml:space="preserve">
          <source>3. State</source>
          <target state="translated">3.3.国家</target>
        </trans-unit>
        <trans-unit id="86901adbf99889e89f6fb5664ba644ee179d5895" translate="yes" xml:space="preserve">
          <source>4. Getters</source>
          <target state="translated">4.获取者</target>
        </trans-unit>
        <trans-unit id="f5dd21d6df4b83ebbdd0d793bd18c24ecafd3d6a" translate="yes" xml:space="preserve">
          <source>5. Mutations</source>
          <target state="translated">5.变异</target>
        </trans-unit>
        <trans-unit id="d2db7e791345bd3756bb20faaf9a14d8b1ca6e1d" translate="yes" xml:space="preserve">
          <source>6. Actions</source>
          <target state="translated">6.6.行动</target>
        </trans-unit>
        <trans-unit id="311b202ab670d27bdcb3786803bee13f6ac0dd04" translate="yes" xml:space="preserve">
          <source>7. Modules</source>
          <target state="translated">7.模块</target>
        </trans-unit>
        <trans-unit id="5b2c110974e654cf654a583f99f4466b77ffad4a" translate="yes" xml:space="preserve">
          <source>8. Application Structure</source>
          <target state="translated">8.应用结构</target>
        </trans-unit>
        <trans-unit id="35fca60c7ce35ec44954758baa9845c6764c93f3" translate="yes" xml:space="preserve">
          <source>9. Plugins</source>
          <target state="translated">9.插件</target>
        </trans-unit>
        <trans-unit id="e491a21fa71516f2b26e081f14ece268b038b5c2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://unpkg.com&quot;&gt;Unpkg.com&lt;/a&gt; provides NPM-based CDN links. The above link will always point to the latest release on NPM. You can also use a specific version/tag via URLs like &lt;code&gt;https://unpkg.com/vuex@2.0.0&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://unpkg.com&quot;&gt;Unpkg.com&lt;/a&gt;提供基于NPM的CDN链接。上面的链接将始终指向NPM的最新版本。您也可以通过 &lt;code&gt;https://unpkg.com/vuex@2.0.0&lt;/code&gt; 之类的 URL使用特定的版本/标签。</target>
        </trans-unit>
        <trans-unit id="c0ab7dbdd7961ea625457c4f71c2a103e97577e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;createLogger&lt;/code&gt; function is exported from the core module</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="140249cc0098c39ea9eee2f348b83aec84aeaea9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;options&lt;/code&gt; can have &lt;code&gt;preserveState: true&lt;/code&gt; that allows to preserve the previous state. Useful with Server Side Rendering.</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; 可以具有 &lt;code&gt;preserveState: true&lt;/code&gt; ，以保留以前的状态。与服务器端渲染一起使用。</target>
        </trans-unit>
        <trans-unit id="1d43392242421ea5926dd1b8219417091c58e5ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;subscribeAction&lt;/code&gt; can also specify an &lt;code&gt;error&lt;/code&gt; handler to catch an error thrown when an action is dispatched. The function will receive an &lt;code&gt;error&lt;/code&gt; object as the third argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efda1a76b4931ed64f56c475099103b6b342e77a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;subscribeAction&lt;/code&gt; can also specify whether the subscribe handler should be called &lt;em&gt;before&lt;/em&gt; or &lt;em&gt;after&lt;/em&gt; an action dispatch (the default behavior is &lt;em&gt;before&lt;/em&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93bc29b6324b7d1ed0dc681c2aa882c85b026c76" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Do not enable strict mode when deploying for production!&lt;/strong&gt; Strict mode runs a synchronous deep watcher on the state tree for detecting inappropriate mutations, and it can be quite expensive when you make large amount of mutations to the state. Make sure to turn it off in production to avoid the performance cost.</source>
          <target state="translated">&lt;strong&gt;部署生产时请勿启用严格模式！&lt;/strong&gt;严格模式在状态树上运行同步深度监视程序，以检测不适当的突变，当您对该状态进行大量突变时，这可能会非常昂贵。确保在生产中将其关闭以避免性能成本。</target>
        </trans-unit>
        <trans-unit id="9f9016c15f9b85d16a456b0a8fed9e60d27f0c18" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE:&lt;/strong&gt; We will be using ES2015 syntax for code examples for the rest of the docs. If you haven't picked it up, &lt;a href=&quot;https://babeljs.io/docs/learn-es2015/&quot;&gt;you should&lt;/a&gt;!</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;我们将使用ES2015语法作为其余文档的代码示例。如果您还没有捡起它，&lt;a href=&quot;https://babeljs.io/docs/learn-es2015/&quot;&gt;那么应该&lt;/a&gt;！</target>
        </trans-unit>
        <trans-unit id="543738af7550fb2b326fb4aec1d84822e5d85d47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Plugins that take state snapshots should be used only during development.&lt;/strong&gt; When using webpack or Browserify, we can let our build tools handle that for us:</source>
          <target state="translated">&lt;strong&gt;带有状态快照的插件应仅在开发期间使用。&lt;/strong&gt;使用webpack或Browserify时，我们可以让构建工具为我们处理：</target>
        </trans-unit>
        <trans-unit id="152494aaef0de9abdd755c1e397ccd919faab73b" translate="yes" xml:space="preserve">
          <source>A more practical example of real-world actions would be an action to checkout a shopping cart, which involves &lt;strong&gt;calling an async API&lt;/strong&gt; and &lt;strong&gt;committing multiple mutations&lt;/strong&gt;:</source>
          <target state="translated">实际操作的一个更实际的示例是结帐购物车的操作，该操作涉及&lt;strong&gt;调用异步API&lt;/strong&gt;并&lt;strong&gt;提交多个突变&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="b276f94cd8d0e74a21de6e5939b8c10ca9a975d6" translate="yes" xml:space="preserve">
          <source>API Reference</source>
          <target state="translated">API参考</target>
        </trans-unit>
        <trans-unit id="5f613656881e083dfef9e6ff61f4361ce0a8891f" translate="yes" xml:space="preserve">
          <source>Accessing Global Assets in Namespaced Modules</source>
          <target state="translated">在命名间隔模块中访问全局资产。</target>
        </trans-unit>
        <trans-unit id="a6ab98e7c5d9fe16cce79fc5b58d4c6a0bb97528" translate="yes" xml:space="preserve">
          <source>Accessing Mutations and Actions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18d2c21a5e764fa3068b12a662b48a445b54e874" translate="yes" xml:space="preserve">
          <source>Accessing State and Getters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d5c235f81dfbc7a38598e493ee1ecf48d2948cf" translate="yes" xml:space="preserve">
          <source>Action handlers receive a context object which exposes the same set of methods/properties on the store instance, so you can call &lt;code&gt;context.commit&lt;/code&gt; to commit a mutation, or access the state and getters via &lt;code&gt;context.state&lt;/code&gt; and &lt;code&gt;context.getters&lt;/code&gt;. We can even call other actions with &lt;code&gt;context.dispatch&lt;/code&gt;. We will see why this context object is not the store instance itself when we introduce &lt;a href=&quot;modules&quot;&gt;Modules&lt;/a&gt; later.</source>
          <target state="translated">动作处理程序会收到一个上下文对象，该对象在商店实例上公开相同的方法/属性集，因此您可以调用 &lt;code&gt;context.commit&lt;/code&gt; 进行更改，或通过 &lt;code&gt;context.state&lt;/code&gt; 和 &lt;code&gt;context.getters&lt;/code&gt; 访问状态和获取方法。我们甚至可以使用 &lt;code&gt;context.dispatch&lt;/code&gt; 调用其他动作。稍后介绍&lt;a href=&quot;modules&quot;&gt;模块&lt;/a&gt;时，我们将看到为什么此上下文对象不是商店实例本身。</target>
        </trans-unit>
        <trans-unit id="c3cd636a585b20c40ac2df5ffb403e83cb2eef51" translate="yes" xml:space="preserve">
          <source>Actions</source>
          <target state="translated">Actions</target>
        </trans-unit>
        <trans-unit id="fd2b38844159f4c8bd1a540f724142f21bcb2783" translate="yes" xml:space="preserve">
          <source>Actions are often asynchronous, so how do we know when an action is done? And more importantly, how can we compose multiple actions together to handle more complex async flows?</source>
          <target state="translated">动作通常是异步的,那么我们如何知道一个动作何时完成?而更重要的是,我们如何将多个动作组合在一起,以处理更复杂的异步流?</target>
        </trans-unit>
        <trans-unit id="eebbe3f939d0e7eb5a702bddfd2a09d58662a331" translate="yes" xml:space="preserve">
          <source>Actions are similar to mutations, the differences being that:</source>
          <target state="translated">作用类似于突变,不同的是。</target>
        </trans-unit>
        <trans-unit id="2fb7f3eefbb910c724298c1fe2f73e2dd2775642" translate="yes" xml:space="preserve">
          <source>Actions are triggered with the &lt;code&gt;store.dispatch&lt;/code&gt; method:</source>
          <target state="translated">使用 &lt;code&gt;store.dispatch&lt;/code&gt; 方法触发操作：</target>
        </trans-unit>
        <trans-unit id="e0710bf63012535b6c8d8716b3dcac5cf1237306" translate="yes" xml:space="preserve">
          <source>Actions can be a bit more tricky because they may call out to external APIs. When testing actions, we usually need to do some level of mocking - for example, we can abstract the API calls into a service and mock that service inside our tests. In order to easily mock dependencies, we can use webpack and &lt;a href=&quot;https://github.com/plasticine/inject-loader&quot;&gt;inject-loader&lt;/a&gt; to bundle our test files.</source>
          <target state="translated">动作可能会更加棘手，因为它们可能会调用外部API。在测试动作时，我们通常需要进行某种程度的模拟-例如，我们可以将API调用抽象到服务中，并在测试中模拟该服务。为了轻松模拟依赖关系，我们可以使用webpack和&lt;a href=&quot;https://github.com/plasticine/inject-loader&quot;&gt;inject-loader&lt;/a&gt;捆绑测试文件。</target>
        </trans-unit>
        <trans-unit id="5b7eca18a813d34c8aa01e8ef07ee7519aaf8e37" translate="yes" xml:space="preserve">
          <source>Actions can contain arbitrary asynchronous operations.</source>
          <target state="translated">动作可以包含任意的异步操作。</target>
        </trans-unit>
        <trans-unit id="20c41c87b2101245945eb4d510d08709af6ca47f" translate="yes" xml:space="preserve">
          <source>Actions from different views may need to mutate the same piece of state.</source>
          <target state="translated">不同观点的行动可能需要突变同一块状态。</target>
        </trans-unit>
        <trans-unit id="cc658d581fafc63b17159bbd703e4b6ae9e6654d" translate="yes" xml:space="preserve">
          <source>Actions support the same payload format and object-style dispatch:</source>
          <target state="translated">Actions支持相同的有效载荷格式和对象式调度。</target>
        </trans-unit>
        <trans-unit id="e6f1f5e24996a891b4012e435efadfe597fd76af" translate="yes" xml:space="preserve">
          <source>Admittedly, the above is quite a bit more verbose than &lt;code&gt;v-model&lt;/code&gt; + local state, and we lose some of the useful features from &lt;code&gt;v-model&lt;/code&gt; as well. An alternative approach is using a two-way computed property with a setter:</source>
          <target state="translated">诚然，上面的内容比 &lt;code&gt;v-model&lt;/code&gt; +局部状态更为冗长，并且我们也失去了 &lt;code&gt;v-model&lt;/code&gt; 的一些有用功能。一种替代方法是使用带有setter的双向计算属性：</target>
        </trans-unit>
        <trans-unit id="1202f0740ed7d8ae90a711fe902caaa8f08e09b3" translate="yes" xml:space="preserve">
          <source>After &lt;a href=&quot;../installation&quot;&gt;installing&lt;/a&gt; Vuex, let's create a store. It is pretty straightforward - just provide an initial state object, and some mutations:</source>
          <target state="translated">后&lt;a href=&quot;../installation&quot;&gt;安装&lt;/a&gt; Vuex，让我们创建一个商店。这非常简单-只需提供一个初始状态对象和一些突变即可：</target>
        </trans-unit>
        <trans-unit id="a38a6afdb72dbde1dead2d25ed43a801e44eeba7" translate="yes" xml:space="preserve">
          <source>Again, the reason we are committing a mutation instead of changing &lt;code&gt;store.state.count&lt;/code&gt; directly, is because we want to explicitly track it. This simple convention makes your intention more explicit, so that you can reason about state changes in your app better when reading the code. In addition, this gives us the opportunity to implement tools that can log every mutation, take state snapshots, or even perform time travel debugging.</source>
          <target state="translated">同样，我们提交突变而不是直接更改 &lt;code&gt;store.state.count&lt;/code&gt; 的原因是因为我们要显式跟踪它。这个简单的约定使您的意图更加明确，以便您在阅读代码时可以更好地推断应用程序中的状态更改。此外，这使我们有机会实现可以记录每个突变，拍摄状态快照甚至执行时间旅行调试的工具。</target>
        </trans-unit>
        <trans-unit id="eab081c4e733f3e8e7fc4113e3a4c3e9822d6e7f" translate="yes" xml:space="preserve">
          <source>Almost all Vuex 4 APIs have remained unchanged from Vuex 3. However, there are still a few breaking changes that you must fix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="321cdc14e97d2ee50f5d65dc4d313dcb119e79c0" translate="yes" xml:space="preserve">
          <source>Also, inside module getters, the root state will be exposed as their 3rd argument:</source>
          <target state="translated">另外,在模块获取器里面,根状态将作为它们的第3个参数暴露出来。</target>
        </trans-unit>
        <trans-unit id="2eee5b4fbbc1f54a27e6412f36e8fc0250ed0ca4" translate="yes" xml:space="preserve">
          <source>An alternative way to commit a mutation is by directly using an object that has a &lt;code&gt;type&lt;/code&gt; property:</source>
          <target state="translated">提交突变的另一种方法是直接使用具有 &lt;code&gt;type&lt;/code&gt; 属性的对象：</target>
        </trans-unit>
        <trans-unit id="c5bfc0baa5cb6ec7b1c1c279caffbe5d5b8218a2" translate="yes" xml:space="preserve">
          <source>An array of plugin functions to be applied to the store. The plugin simply receives the store as the only argument and can either listen to mutations (for outbound data persistence, logging, or debugging) or dispatch mutations (for inbound data e.g. websockets or observables).</source>
          <target state="translated">要应用到存储的插件函数数组。插件简单地接收存储作为唯一的参数,并且可以监听突变(用于出站数据的持久化、日志或调试)或调度突变(用于入站数据,如websockets或observables)。</target>
        </trans-unit>
        <trans-unit id="6b626f3c447742f2fad682725d05b28250d88b5f" translate="yes" xml:space="preserve">
          <source>An object containing sub modules to be merged into the store, in the shape of:</source>
          <target state="translated">一个包含要合并到商店的子模块的对象,形状为:。</target>
        </trans-unit>
        <trans-unit id="dc46a43c367676022711c845ac16cc5387d782f6" translate="yes" xml:space="preserve">
          <source>And also in another action:</source>
          <target state="translated">还在另一个行动中。</target>
        </trans-unit>
        <trans-unit id="4db792123502a659fd37a4ca852f43e15ee1ef57" translate="yes" xml:space="preserve">
          <source>And also receives a second &lt;code&gt;payload&lt;/code&gt; argument if there is one.</source>
          <target state="translated">并且如果存在，还将接收第二个 &lt;code&gt;payload&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="6eb1eaafd8f229821b275541a054f723a80d42bf" translate="yes" xml:space="preserve">
          <source>And can be used like this:</source>
          <target state="translated">而且可以这样使用。</target>
        </trans-unit>
        <trans-unit id="fe2969186d8cff2f758236d5c540ae4e48a2d751" translate="yes" xml:space="preserve">
          <source>And here's the mutation handler:</source>
          <target state="translated">这里是突变处理程序。</target>
        </trans-unit>
        <trans-unit id="d71de8152541f4a1b7fda48b87f3fe315656e14c" translate="yes" xml:space="preserve">
          <source>Application Structure</source>
          <target state="translated">应用结构</target>
        </trans-unit>
        <trans-unit id="2ba5dece67f8efdf3c81bb9be56daf28e8655190" translate="yes" xml:space="preserve">
          <source>Application-level state is centralized in the store.</source>
          <target state="translated">应用级的状态集中在商店里。</target>
        </trans-unit>
        <trans-unit id="710522a05d77912ddae3e734e0a2d1d370529418" translate="yes" xml:space="preserve">
          <source>As a reference, check out the &lt;a href=&quot;https://github.com/vuejs/vuex/tree/4.0/examples/classic/shopping-cart&quot;&gt;Shopping Cart Example&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84a169df16a0c175be12b4d7b1cd59df717591a1" translate="yes" xml:space="preserve">
          <source>As a reference, check out the &lt;a href=&quot;https://github.com/vuejs/vuex/tree/dev/examples/shopping-cart&quot;&gt;Shopping Cart Example&lt;/a&gt;.</source>
          <target state="translated">作为参考，请查看&lt;a href=&quot;https://github.com/vuejs/vuex/tree/dev/examples/shopping-cart&quot;&gt;购物车示例&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="90a44e426a7e60755b1c84d1d390da1cb4f500d2" translate="yes" xml:space="preserve">
          <source>As long as you follow these rules, it's up to you how to structure your project. If your store file gets too big, simply start splitting the actions, mutations and getters into separate files.</source>
          <target state="translated">只要你遵循这些规则,如何架构你的项目就由你决定了。如果你的存储文件变得太大了,只需开始将动作、突变和获取器分割成单独的文件。</target>
        </trans-unit>
        <trans-unit id="fc6ed90023b96fb6043edbdf30e42cf5dd8527fd" translate="yes" xml:space="preserve">
          <source>As of Vue 3.0, the getter's result is &lt;strong&gt;not cached&lt;/strong&gt; as the computed property does. This is a known issue that requires Vue 3.1 to be released. You can learn more at &lt;a href=&quot;https://github.com/vuejs/vuex/pull/1883&quot;&gt;PR #1878&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dfd062060191d75d85aa467d9473a70ac205ad2" translate="yes" xml:space="preserve">
          <source>Assuming &lt;code&gt;obj&lt;/code&gt; is a computed property that returns an Object from the store, the &lt;code&gt;v-model&lt;/code&gt; here will attempt to directly mutate &lt;code&gt;obj.message&lt;/code&gt; when the user types in the input. In strict mode, this will result in an error because the mutation is not performed inside an explicit Vuex mutation handler.</source>
          <target state="translated">假设 &lt;code&gt;obj&lt;/code&gt; 是一个从商店返回Object的计算属性， &lt;code&gt;obj.message&lt;/code&gt; 当用户输入输入内容时，此处的 &lt;code&gt;v-model&lt;/code&gt; 将尝试直接使obj.message突变。在严格模式下，这将导致错误，因为未在显式的Vuex变异处理程序内执行变异。</target>
        </trans-unit>
        <trans-unit id="6d84d9b230182d02f5132507784662fee81bd183" translate="yes" xml:space="preserve">
          <source>Asynchronicity combined with state mutation can make your program very hard to reason about. For example, when you call two methods both with async callbacks that mutate the state, how do you know when they are called and which callback was called first? This is exactly why we want to separate the two concepts. In Vuex, &lt;strong&gt;mutations are synchronous transactions&lt;/strong&gt;:</source>
          <target state="translated">异步与状态突变相结合会使您的程序难以推理。例如，当您同时使用两个使状态发生变化的异步回调来调用两个方法时，您如何知道何时调用它们以及首先调用哪个回调？这正是我们要将两个概念分开的原因。在Vuex中，&lt;strong&gt;变异是同步交易&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="b626c6a5b4f21b273497b11b0696d3709db0b3b9" translate="yes" xml:space="preserve">
          <source>Asynchronous logic should be encapsulated in, and can be composed with &lt;strong&gt;actions&lt;/strong&gt;.</source>
          <target state="translated">异步逻辑应封装在其中，并可以由&lt;strong&gt;action&lt;/strong&gt;组成。</target>
        </trans-unit>
        <trans-unit id="b24ba5aae3b57ed131c31fce3d9e7c01ee0a8934" translate="yes" xml:space="preserve">
          <source>At the center of every Vuex application is the &lt;strong&gt;store&lt;/strong&gt;. A &quot;store&quot; is basically a container that holds your application &lt;strong&gt;state&lt;/strong&gt;. There are two things that make a Vuex store different from a plain global object:</source>
          <target state="translated">每个Vuex应用程序的中心都是&lt;strong&gt;商店&lt;/strong&gt;。&amp;ldquo;商店&amp;rdquo;基本上是一个保存应用程序&lt;strong&gt;状态&lt;/strong&gt;的容器。有两件事使Vuex存储与普通的全局对象不同：</target>
        </trans-unit>
        <trans-unit id="c7d1a78232de1c9a47af6445001c58c1d1a7ff3f" translate="yes" xml:space="preserve">
          <source>Binding Helpers with Namespace</source>
          <target state="translated">用命名空间绑定助手</target>
        </trans-unit>
        <trans-unit id="8f6f50fe6a684e36f2680d1b1f0d995148104f1b" translate="yes" xml:space="preserve">
          <source>Breaking Changes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b82d0b3ff29a71b23bd07d252bf2496be796144" translate="yes" xml:space="preserve">
          <source>Built-in Logger Plugin</source>
          <target state="translated">内置记录器插件</target>
        </trans-unit>
        <trans-unit id="308a059e768af3165c20d5c89a88a895db34b5d3" translate="yes" xml:space="preserve">
          <source>Bundles are now aligned with Vue 3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b63c58271c9e6140433eb13c24cac57c216ef45" translate="yes" xml:space="preserve">
          <source>By committing mutations, a plugin can be used to sync a data source to the store. For example, to sync a websocket data source to the store (this is just a contrived example, in reality the &lt;code&gt;createWebSocketPlugin&lt;/code&gt; function can take some additional options for more complex tasks):</source>
          <target state="translated">通过提交突变，可以使用插件将数据源同步到商店。例如，要将websocket数据源同步到商店（这只是一个人为的示例，实际上 &lt;code&gt;createWebSocketPlugin&lt;/code&gt; 函数可以采用一些其他选项来执行更复杂的任务）：</target>
        </trans-unit>
        <trans-unit id="54e6c17c9d96ae95deebc44ddbbdf708643bcdb6" translate="yes" xml:space="preserve">
          <source>By default, actions and mutations are still registered under the &lt;strong&gt;global namespace&lt;/strong&gt; - this allows multiple modules to react to the same action/mutation type. Getters are also registered in the global namespace by default. However, this currently has no functional purpose (it's as is to avoid breaking changes). You must be careful not to define two getters with the same name in different, non-namespaced modules, resulting in an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6129d443ac8169bdc5fb7a33f1a6e3a49e6acbc" translate="yes" xml:space="preserve">
          <source>By default, actions, mutations and getters inside modules are still registered under the &lt;strong&gt;global namespace&lt;/strong&gt; - this allows multiple modules to react to the same mutation/action type.</source>
          <target state="translated">默认情况下，模块内的动作，变异和吸气剂仍会注册在&lt;strong&gt;全局名称空间下&lt;/strong&gt; -这允许多个模块对相同的变异/动作类型做出反应。</target>
        </trans-unit>
        <trans-unit id="e5c047ce83c6997dc7276f84aba1f5edb7e54735" translate="yes" xml:space="preserve">
          <source>By default, new handler is added to the end of the chain, so it will be executed after other handlers that were added before. This can be overridden by adding &lt;code&gt;prepend: true&lt;/code&gt; to &lt;code&gt;options&lt;/code&gt;, which will add the handler to the beginning of the chain.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51ce5306c9b50098f499e2c37705e5ca375897a5" translate="yes" xml:space="preserve">
          <source>By defining and separating the concepts involved in state management and enforcing rules that maintain independence between views and states, we give our code more structure and maintainability.</source>
          <target state="translated">通过定义和分离状态管理中涉及的概念,并执行保持视图和状态之间独立性的规则,我们给我们的代码提供了更多的结构和可维护性。</target>
        </trans-unit>
        <trans-unit id="5f057ce6f76c7748c97610c88355154f282ad2c0" translate="yes" xml:space="preserve">
          <source>By providing the &lt;code&gt;store&lt;/code&gt; option to the root instance, the store will be injected into all child components of the root and will be available on them as &lt;code&gt;this.$store&lt;/code&gt;. Let's update our &lt;code&gt;Counter&lt;/code&gt; implementation:</source>
          <target state="translated">通过为根实例提供 &lt;code&gt;store&lt;/code&gt; 选项，该存储将被注入到根的所有子组件中，并将以 &lt;code&gt;this.$store&lt;/code&gt; 在其上可用。让我们更新我们的 &lt;code&gt;Counter&lt;/code&gt; 实现：</target>
        </trans-unit>
        <trans-unit id="afbfca3e9562078c83014d5d713ed214293086dc" translate="yes" xml:space="preserve">
          <source>Caveat for Plugin Developers</source>
          <target state="translated">插件开发人员的注意事项</target>
        </trans-unit>
        <trans-unit id="b802f993bec634c517b9f6ea60df4c1f6d0862f1" translate="yes" xml:space="preserve">
          <source>Change the &lt;code&gt;entry&lt;/code&gt; from the webpack config above to &lt;code&gt;'mocha-loader!babel-loader!./test.js'&lt;/code&gt;.</source>
          <target state="translated">将上面的webpack配置中的 &lt;code&gt;entry&lt;/code&gt; 更改为 &lt;code&gt;'mocha-loader!babel-loader!./test.js'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ad552703e8fdce0a6e99ce76eff171c7cb0b2e6e" translate="yes" xml:space="preserve">
          <source>Check if the module with the given name is already registered. &lt;a href=&quot;../guide/modules#dynamic-module-registration&quot;&gt;Details&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74a64ba9ebedb4fb168b3e805adfe8c5b4531bcc" translate="yes" xml:space="preserve">
          <source>Check out the &lt;a href=&quot;https://github.com/vuejs/vuex/tree/4.0/examples/composition&quot;&gt;Composition API example&lt;/a&gt; to see example applications utilising Vuex and Vue's Composition API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dce2cc7e2a5aca96dce40c7472c844313c6128f9" translate="yes" xml:space="preserve">
          <source>Checkout the &lt;a href=&quot;https://github.com/vuejs/vuex/tree/dev/examples/counter-hot&quot;&gt;counter-hot example&lt;/a&gt; to play with hot-reload.</source>
          <target state="translated">查看&lt;a href=&quot;https://github.com/vuejs/vuex/tree/dev/examples/counter-hot&quot;&gt;反热点示例&lt;/a&gt;以进行热重载。</target>
        </trans-unit>
        <trans-unit id="4fa10bacb249d780150d867ebb85a6f26364c8f3" translate="yes" xml:space="preserve">
          <source>Commit a mutation. &lt;code&gt;options&lt;/code&gt; can have &lt;code&gt;root: true&lt;/code&gt; that allows to commit root mutations in &lt;a href=&quot;../guide/modules#namespacing&quot;&gt;namespaced modules&lt;/a&gt;. &lt;a href=&quot;../guide/mutations&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">提交突变。 &lt;code&gt;options&lt;/code&gt; 可以具有 &lt;code&gt;root: true&lt;/code&gt; ，以允许在&lt;a href=&quot;../guide/modules#namespacing&quot;&gt;命名空间模块中&lt;/a&gt;提交根突变。&lt;a href=&quot;../guide/mutations&quot;&gt;细节&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="abb9b61bf1bcc0d24bf3814462346ec637d49ab2" translate="yes" xml:space="preserve">
          <source>Commit with Payload</source>
          <target state="translated">承诺与有效载荷</target>
        </trans-unit>
        <trans-unit id="ed6c4a7e621ba1c9ba60ff20a8e8dcf01877ef46" translate="yes" xml:space="preserve">
          <source>Committing Mutations Inside Plugins</source>
          <target state="translated">在插件内进行突变</target>
        </trans-unit>
        <trans-unit id="ace0d08016e7028b4da846721e8e8ac868a1df57" translate="yes" xml:space="preserve">
          <source>Committing Mutations in Components</source>
          <target state="translated">在组件中进行突变</target>
        </trans-unit>
        <trans-unit id="1f6dc35fce777380808e0419957ee6d4ef776d2a" translate="yes" xml:space="preserve">
          <source>Component Binding Helpers</source>
          <target state="translated">组件绑定助手</target>
        </trans-unit>
        <trans-unit id="4d8cf2331522b00be9ba0f265b611e2039ac37bf" translate="yes" xml:space="preserve">
          <source>Components Can Still Have Local State</source>
          <target state="translated">组件仍然可以有当地的国家</target>
        </trans-unit>
        <trans-unit id="c21ad08c0baf7033efdd17f3b90986ad6f2a3b53" translate="yes" xml:space="preserve">
          <source>Composable Functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b15cc8250e54a4e4e49adf02d259f1fa59279242" translate="yes" xml:space="preserve">
          <source>Composing Actions</source>
          <target state="translated">组成行动</target>
        </trans-unit>
        <trans-unit id="612f6427c9092a5834602047d990b4384c86915b" translate="yes" xml:space="preserve">
          <source>Composition API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ede404da36f4056ccf7af05d460f44cb9c43066f" translate="yes" xml:space="preserve">
          <source>Consult the setup in &lt;a href=&quot;https://vue-loader.vuejs.org/en/workflow/testing.html&quot;&gt;vue-loader documentation&lt;/a&gt;.</source>
          <target state="translated">请查阅&lt;a href=&quot;https://vue-loader.vuejs.org/en/workflow/testing.html&quot;&gt;vue-loader文档中&lt;/a&gt;的设置。</target>
        </trans-unit>
        <trans-unit id="fdf30dd4ea6fdb8cb2d048ae6de2346d62859fba" translate="yes" xml:space="preserve">
          <source>Contains hard-coded prod/dev branches and the prod build is pre-minified. Use the &lt;code&gt;.prod.js&lt;/code&gt; files for production.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da10239b688b761162ce39505c1fb91b8a0f2cff" translate="yes" xml:space="preserve">
          <source>Create component computed options that return the evaluated value of a getter. &lt;a href=&quot;../guide/getters#the-mapgetters-helper&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">创建组件计算的选项，这些选项返回获取器的评估值。&lt;a href=&quot;../guide/getters#the-mapgetters-helper&quot;&gt;细节&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="31bb75db599ebdfdee4a1705ea2cde4fc02ae7e9" translate="yes" xml:space="preserve">
          <source>Create component computed options that return the sub tree of the Vuex store. &lt;a href=&quot;../guide/state#the-mapstate-helper&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">创建组件计算的选项，这些选项返回Vuex存储的子树。&lt;a href=&quot;../guide/state#the-mapstate-helper&quot;&gt;细节&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3dbfc6c00c0be1ce1d1c67ae2ab7ad29e56233ee" translate="yes" xml:space="preserve">
          <source>Create component methods options that commit a mutation. &lt;a href=&quot;../guide/mutations#committing-mutations-in-components&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">创建提交突变的组件方法选项。&lt;a href=&quot;../guide/mutations#committing-mutations-in-components&quot;&gt;细节&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="abafed37072bae96880b76a80729da6f20135f55" translate="yes" xml:space="preserve">
          <source>Create component methods options that dispatch an action. &lt;a href=&quot;../guide/actions#dispatching-actions-in-components&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">创建分派动作的组件方法选项。&lt;a href=&quot;../guide/actions#dispatching-actions-in-components&quot;&gt;细节&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9e2d6b72bf5a70877397f0095b2d65aff35b1892" translate="yes" xml:space="preserve">
          <source>Create namespaced component binding helpers. The returned object contains &lt;code&gt;mapState&lt;/code&gt;, &lt;code&gt;mapGetters&lt;/code&gt;, &lt;code&gt;mapActions&lt;/code&gt; and &lt;code&gt;mapMutations&lt;/code&gt; that are bound with the given namespace. &lt;a href=&quot;../guide/modules#binding-helpers-with-namespace&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">创建命名空间的组件绑定助手。返回的对象包含与给定名称空间绑定的 &lt;code&gt;mapState&lt;/code&gt; ， &lt;code&gt;mapGetters&lt;/code&gt; ， &lt;code&gt;mapActions&lt;/code&gt; 和 &lt;code&gt;mapMutations&lt;/code&gt; 。&lt;a href=&quot;../guide/modules#binding-helpers-with-namespace&quot;&gt;细节&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e9ad68aa689b0ae8f0f0130cf5684aa9556b2ca9" translate="yes" xml:space="preserve">
          <source>Create the following webpack config (together with proper &lt;a href=&quot;https://babeljs.io/docs/usage/babelrc/&quot;&gt;&lt;code&gt;.babelrc&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">创建以下webpack配置（以及正确的&lt;a href=&quot;https://babeljs.io/docs/usage/babelrc/&quot;&gt; &lt;code&gt;.babelrc&lt;/code&gt; &lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="6d783b874c20d56d3f40a248f291e37048c0af28" translate="yes" xml:space="preserve">
          <source>Creates a new store.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9105fc825a43c6d4845f7a03ee377cd299c7a10e" translate="yes" xml:space="preserve">
          <source>Creating multiple stores that use the same module (e.g. To &lt;a href=&quot;https://ssr.vuejs.org/en/structure.html#avoid-stateful-singletons&quot;&gt;avoid stateful singletons in the SSR&lt;/a&gt; when the &lt;code&gt;runInNewContext&lt;/code&gt; option is &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;'once'&lt;/code&gt;);</source>
          <target state="translated">创建使用同一模块的多个存储（例如&lt;a href=&quot;https://ssr.vuejs.org/en/structure.html#avoid-stateful-singletons&quot;&gt;，&lt;/a&gt;当 &lt;code&gt;runInNewContext&lt;/code&gt; 选项为 &lt;code&gt;false&lt;/code&gt; 或 &lt;code&gt;'once'&lt;/code&gt; 时，避免SSR中的有状态单例）；</target>
        </trans-unit>
        <trans-unit id="21eac18e2c98912ec301de36518dcca3257d3520" translate="yes" xml:space="preserve">
          <source>Define the typed &lt;code&gt;InjectionKey&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc3decbb93847518f1a049dcf49d0d7c6560bcc6" translate="yes" xml:space="preserve">
          <source>Details</source>
          <target state="translated">Details</target>
        </trans-unit>
        <trans-unit id="40d9b9f619dbd27ad649a2fb2ed512704a8498dc" translate="yes" xml:space="preserve">
          <source>Dev Build</source>
          <target state="translated">开发建设</target>
        </trans-unit>
        <trans-unit id="500633464b5e072d2c92585f64d2a894aa70607e" translate="yes" xml:space="preserve">
          <source>Development vs. Production</source>
          <target state="translated">开发与生产</target>
        </trans-unit>
        <trans-unit id="3802d9202faed1ee478163e33ce9ddf939795ae9" translate="yes" xml:space="preserve">
          <source>Direct Download / CDN</source>
          <target state="translated">直接下载/CDN</target>
        </trans-unit>
        <trans-unit id="ea82e3864abf2011a82f27aa87646711a6dde792" translate="yes" xml:space="preserve">
          <source>Dispatch an action. &lt;code&gt;options&lt;/code&gt; can have &lt;code&gt;root: true&lt;/code&gt; that allows to dispatch root actions in &lt;a href=&quot;../guide/modules#namespacing&quot;&gt;namespaced modules&lt;/a&gt;. Returns a Promise that resolves all triggered action handlers. &lt;a href=&quot;../guide/actions&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">调度一个动作。 &lt;code&gt;options&lt;/code&gt; 可以具有 &lt;code&gt;root: true&lt;/code&gt; ，它允许在&lt;a href=&quot;../guide/modules#namespacing&quot;&gt;命名空间模块中&lt;/a&gt;分派root操作。返回一个Promise，用于解决所有触发的动作处理程序。&lt;a href=&quot;../guide/actions&quot;&gt;细节&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c5de1b3bf84cda5dd071c256e4397b905445d1ed" translate="yes" xml:space="preserve">
          <source>Dispatching Actions</source>
          <target state="translated">派遣行动</target>
        </trans-unit>
        <trans-unit id="7bbf007bb6622957664e35e62427c33b4787bbb3" translate="yes" xml:space="preserve">
          <source>Dispatching Actions in Components</source>
          <target state="translated">在组件中调度动作</target>
        </trans-unit>
        <trans-unit id="e84816ed7caab86d4177979788d92260896d7646" translate="yes" xml:space="preserve">
          <source>Does not ship minified builds (to be done together with the rest of the code after bundling).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18d9131cd512bae245202d7fdc5bab5cceca6887" translate="yes" xml:space="preserve">
          <source>Due to using a single state tree, all state of our application is contained inside one big object. However, as our application grows in scale, the store can get really bloated.</source>
          <target state="translated">由于使用单一的状态树,我们应用程序的所有状态都包含在一个大对象中。然而,随着我们的应用规模的增长,存储会变得非常臃肿。</target>
        </trans-unit>
        <trans-unit id="e37126c9ff488c45faa7f6c167a21e521222db0b" translate="yes" xml:space="preserve">
          <source>Due to using a single state tree, all states of our application are contained inside one big object. However, as our application grows in scale, the store can get really bloated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e38587c029f9616f99732e5fadca02a9d8f2a6d2" translate="yes" xml:space="preserve">
          <source>Dynamic Module Registration</source>
          <target state="translated">动态模块注册</target>
        </trans-unit>
        <trans-unit id="cc0be31613baaad452c149bb9c4e8586cb8a8114" translate="yes" xml:space="preserve">
          <source>Dynamic module hot reloading</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2eff12ca8da9deedbd39f6bb9fd354742d118c9c" translate="yes" xml:space="preserve">
          <source>Dynamic module registration makes it possible for other Vue plugins to also leverage Vuex for state management by attaching a module to the application's store. For example, the &lt;a href=&quot;https://github.com/vuejs/vuex-router-sync&quot;&gt;&lt;code&gt;vuex-router-sync&lt;/code&gt;&lt;/a&gt; library integrates vue-router with vuex by managing the application's route state in a dynamically attached module.</source>
          <target state="translated">动态模块注册使其他Vue插件也可以通过将模块附加到应用程序商店来利用Vuex进行状态管理。例如，&lt;a href=&quot;https://github.com/vuejs/vuex-router-sync&quot;&gt; &lt;code&gt;vuex-router-sync&lt;/code&gt; &lt;/a&gt;库通过在动态连接的模块中管理应用程序的路由状态，将vue-router与vuex集成在一起。</target>
        </trans-unit>
        <trans-unit id="9e3580cb8f8917bfac5059a2f1b0b379d39800d4" translate="yes" xml:space="preserve">
          <source>Each module can contain &lt;code&gt;state&lt;/code&gt; and &lt;code&gt;mutations&lt;/code&gt; similar to the root options. A module's state will be attached to the store's root state using the module's key. A module's mutations and getters will only receives the module's local state as the first argument instead of the root state, and module actions' &lt;code&gt;context.state&lt;/code&gt; will also point to the local state.</source>
          <target state="translated">每个模块可以包含类似于根选项的 &lt;code&gt;state&lt;/code&gt; 和 &lt;code&gt;mutations&lt;/code&gt; 。使用模块的密钥，模块的状态将附加到商店的根状态。模块的变异和获取器将仅接收模块的本地状态作为第一个参数，而不是根状态，并且模块操作的 &lt;code&gt;context.state&lt;/code&gt; 。状态也将指向本地状态。</target>
        </trans-unit>
        <trans-unit id="f41155bdc10bb27f60f1da2c63993929e366cfa2" translate="yes" xml:space="preserve">
          <source>Edit this page on GitHub</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6af0b4fa90bb496d791139a634a4d2d65a25408" translate="yes" xml:space="preserve">
          <source>Example testing a getter:</source>
          <target state="translated">例如测试一个getter。</target>
        </trans-unit>
        <trans-unit id="dd8e6bd0108987b857bb2a736cd9e6e1f11f7746" translate="yes" xml:space="preserve">
          <source>Example testing a mutation using Mocha + Chai (you can use any framework/assertion libraries you like):</source>
          <target state="translated">使用Mocha+Chai测试突变的例子(你可以使用任何你喜欢的框架/assertion库)。</target>
        </trans-unit>
        <trans-unit id="4dadb731f14e104d4245f8a4e7627c9bb1d8c139" translate="yes" xml:space="preserve">
          <source>Example testing an async action:</source>
          <target state="translated">测试一个异步操作的例子。</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="cd172f61d02f40968010ccf686bd62765d497609" translate="yes" xml:space="preserve">
          <source>Exposes registered getters. Read only.</source>
          <target state="translated">暴露注册的获取者。只读。</target>
        </trans-unit>
        <trans-unit id="6a0705ebf0c44ae72129e31b63faf83cc8385e86" translate="yes" xml:space="preserve">
          <source>Fetches the injected store when called inside the &lt;code&gt;setup&lt;/code&gt; hook. When using the Composition API, you can retrieve the store by calling this method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7e1190595d9109275e6d9d5c10a089a3981a13d" translate="yes" xml:space="preserve">
          <source>Finally, if we make use of &lt;a href=&quot;https://tc39.github.io/ecmascript-asyncawait/&quot;&gt;async / await&lt;/a&gt;, we can compose our actions like this:</source>
          <target state="translated">最后，如果我们使用&lt;a href=&quot;https://tc39.github.io/ecmascript-asyncawait/&quot;&gt;async / await&lt;/a&gt;，我们可以像这样编写动作：</target>
        </trans-unit>
        <trans-unit id="ecf5f38fd7c4dac49ef3d463f17a75ccd2d813ac" translate="yes" xml:space="preserve">
          <source>Finally, you can pass the key to the &lt;code&gt;useStore&lt;/code&gt; method to retrieve the typed store instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9fcf80576ac0f89837fff4eaee1452a5292cce8" translate="yes" xml:space="preserve">
          <source>Finally, you can pass the key to the &lt;code&gt;useStore&lt;/code&gt; method to retrieve the typed store.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0760cb8d91e6272575ced160dd4e33845f64e540" translate="yes" xml:space="preserve">
          <source>First, declare the injection key using Vue's &lt;code&gt;InjectionKey&lt;/code&gt; interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="841c8a4f0fbdf7bd78d33837ca0ec3734ac74a01" translate="yes" xml:space="preserve">
          <source>Flux libraries are like glasses: you&amp;rsquo;ll know when you need them.</source>
          <target state="translated">助焊剂库就像眼镜：您会在需要时知道它们。</target>
        </trans-unit>
        <trans-unit id="38238c24d7f78b5d636a16e313302582a752f404" translate="yes" xml:space="preserve">
          <source>For any non-trivial app, we will likely need to leverage modules. Here's an example project structure:</source>
          <target state="translated">对于任何非平凡的应用,我们很可能需要利用模块。下面是一个示例项目结构。</target>
        </trans-unit>
        <trans-unit id="a300dd270b0c9c1a922b569511c43841912d4bc3" translate="yes" xml:space="preserve">
          <source>For direct use with &lt;code&gt;&amp;lt;script src=&quot;...&quot;&amp;gt;&lt;/code&gt; in the browser. Exposes the Vuex global.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="033826f9380de6f34a8b452670d3506eb71f91c9" translate="yes" xml:space="preserve">
          <source>For mutations and modules, you need to use the &lt;code&gt;store.hotUpdate()&lt;/code&gt; API method:</source>
          <target state="translated">对于变异和模块，您需要使用 &lt;code&gt;store.hotUpdate()&lt;/code&gt; API方法：</target>
        </trans-unit>
        <trans-unit id="52511d0a336b3eb2bef841ae607141d7cff1fb7f" translate="yes" xml:space="preserve">
          <source>For problem one, passing props can be tedious for deeply nested components, and simply doesn't work for sibling components. For problem two, we often find ourselves resorting to solutions such as reaching for direct parent/child instance references or trying to mutate and synchronize multiple copies of the state via events. Both of these patterns are brittle and quickly lead to unmaintainable code.</source>
          <target state="translated">对于问题一,对于深层嵌套的组件来说,传递道具可能会很繁琐,对于同级组件来说,根本就不起作用。对于问题二,我们经常发现自己求助于一些解决方案,比如直接达成父/子实例引用,或者试图通过事件突变和同步状态的多个副本。这两种模式都很脆弱,很快就会导致代码无法维护。</target>
        </trans-unit>
        <trans-unit id="2a82f8d5ce145c881352007d801685ce832abbc7" translate="yes" xml:space="preserve">
          <source>For use in Node.js server-side rendering with &lt;code&gt;require()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="424e49071bb58b22df700b0f0b42bc3fdfc8d652" translate="yes" xml:space="preserve">
          <source>For use with bundlers such as &lt;code&gt;webpack&lt;/code&gt;, &lt;code&gt;rollup&lt;/code&gt; and &lt;code&gt;parcel&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd780fa7ac6288608638eda9123dd968783ffa71" translate="yes" xml:space="preserve">
          <source>For use with native ES module imports (including module supporting browsers via &lt;code&gt;&amp;lt;script type=&quot;module&quot;&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bea63837c28f9e496db300536e9f97becac0fe11" translate="yes" xml:space="preserve">
          <source>Force the Vuex store into strict mode. In strict mode any mutations to Vuex state outside of mutation handlers will throw an Error.</source>
          <target state="translated">强制Vuex存储进入严格模式。在严格模式下,任何在突变处理程序之外对Vuex状态的突变都会抛出一个错误。</target>
        </trans-unit>
        <trans-unit id="320e36f6db4da7afda899f2251cea1a84a74c2fd" translate="yes" xml:space="preserve">
          <source>Form Handling</source>
          <target state="translated">模具处理</target>
        </trans-unit>
        <trans-unit id="8f92675b7ffe5ac821405fab6ddb6dee755e7a33" translate="yes" xml:space="preserve">
          <source>Furthermore, add the below line into anywhere in your code before using Vuex:</source>
          <target state="translated">此外,在使用Vuex之前,请在您的代码中的任何地方添加以下一行。</target>
        </trans-unit>
        <trans-unit id="e156a94f2c9e52e0ddb1f3009ed07dd2abf8f227" translate="yes" xml:space="preserve">
          <source>Furthermore, you can create namespaced helpers by using &lt;code&gt;createNamespacedHelpers&lt;/code&gt;. It returns an object having new component binding helpers that are bound with the given namespace value:</source>
          <target state="translated">此外，您可以使用 &lt;code&gt;createNamespacedHelpers&lt;/code&gt; 创建命名空间的帮助器。它返回一个对象，该对象具有与给定名称空间值绑定的新的组件绑定助手：</target>
        </trans-unit>
        <trans-unit id="3bbbe89e1bf4029f9a507d85d668e0d1d5478d40" translate="yes" xml:space="preserve">
          <source>Getters</source>
          <target state="translated">Getters</target>
        </trans-unit>
        <trans-unit id="a2c7b1aaac2b0cd5b5c8cf82e9116fb532a36719" translate="yes" xml:space="preserve">
          <source>Getters will also receive other getters as the 2nd argument:</source>
          <target state="translated">Getter还将接收其他getter作为第2个参数。</target>
        </trans-unit>
        <trans-unit id="d5976d58530e9ba51288bd1c3ba468cfba584344" translate="yes" xml:space="preserve">
          <source>Getters will receive the state as their 1st argument:</source>
          <target state="translated">得到者将得到国家作为他们的第1个论据。</target>
        </trans-unit>
        <trans-unit id="010b85ad56b34c34c7c2a3b2436c740e30428ed5" translate="yes" xml:space="preserve">
          <source>Getting Started</source>
          <target state="translated">入门</target>
        </trans-unit>
        <trans-unit id="fca659dd312a705a6e05d1f829f26c05b73a3925" translate="yes" xml:space="preserve">
          <source>Getting Vuex State into Vue Components</source>
          <target state="translated">让Vuex状态进入Vue组件</target>
        </trans-unit>
        <trans-unit id="4277a56d46a56f9393fef01ea88a4610c015a3f2" translate="yes" xml:space="preserve">
          <source>Global build is built as IIFE, and not UMD, and is only meant for direct use with &lt;code&gt;&amp;lt;script src=&quot;...&quot;&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="722346bbd4db03c1c92c2a13e486f0e957996d98" translate="yes" xml:space="preserve">
          <source>Go to &lt;code&gt;localhost:8080/webpack-dev-server/test-bundle&lt;/code&gt;.</source>
          <target state="translated">转到 &lt;code&gt;localhost:8080/webpack-dev-server/test-bundle&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bf073fae640ded81eeb7a4cee70faff4a623c16c" translate="yes" xml:space="preserve">
          <source>Guide</source>
          <target state="translated">Guide</target>
        </trans-unit>
        <trans-unit id="f6642ec74afc236ede9f28e965753353dfeeed2c" translate="yes" xml:space="preserve">
          <source>Having to import &lt;code&gt;InjectionKey&lt;/code&gt; and passing it to &lt;code&gt;useStore&lt;/code&gt; everywhere it's used can quickly become a repetitive task. To simplify matters, you can define your own composable function to retrieve a typed store:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45a02043733710be9556d86b3bc87f17a5cbb0c2" translate="yes" xml:space="preserve">
          <source>Here's an example of the &lt;a href=&quot;https://jsfiddle.net/n9jmu5v7/1269/&quot;&gt;most basic Vuex counter app&lt;/a&gt;.</source>
          <target state="translated">这是&lt;a href=&quot;https://jsfiddle.net/n9jmu5v7/1269/&quot;&gt;最基本的Vuex计数器应用程序&lt;/a&gt;的示例。</target>
        </trans-unit>
        <trans-unit id="7e74485fd2af89802a7ce36b6ae42c0bfcc32ed2" translate="yes" xml:space="preserve">
          <source>Hot Reloading</source>
          <target state="translated">热装弹</target>
        </trans-unit>
        <trans-unit id="c75202151698b65793216f709dd23fa91c67ca82" translate="yes" xml:space="preserve">
          <source>Hot swap new actions and mutations. &lt;a href=&quot;../guide/hot-reload&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">热插拔新动作和突变。&lt;a href=&quot;../guide/hot-reload&quot;&gt;细节&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="adbb8bac10b93929c10b60c23f56b5f8139a3463" translate="yes" xml:space="preserve">
          <source>However, if you're writing your Vue components in TypeScript, there're a few steps to follow that require for you to correctly provide typings for a store.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a9fe831345a6e109e78580913b99472521a13a7" translate="yes" xml:space="preserve">
          <source>However, the simplicity quickly breaks down when we have &lt;strong&gt;multiple components that share a common state&lt;/strong&gt;:</source>
          <target state="translated">但是，当我们有&lt;strong&gt;多个共享同一状态的组件&lt;/strong&gt;时，简单性很快就会崩溃：</target>
        </trans-unit>
        <trans-unit id="c5371d6ce87417e1b9eefdc865251be6386c405f" translate="yes" xml:space="preserve">
          <source>However, this pattern causes the component to rely on the global store singleton. When using a module system, it requires importing the store in every component that uses store state, and also requires mocking when testing the component.</source>
          <target state="translated">但是,这种模式会导致组件依赖全局存储单体。在使用模块系统时,需要在每个使用store状态的组件中导入store,在测试组件时也需要进行嘲讽。</target>
        </trans-unit>
        <trans-unit id="b36b5bee1a64a661bc0d45de384b9124cbd72bfe" translate="yes" xml:space="preserve">
          <source>If more than one component needs to make use of this, we have to either duplicate the function, or extract it into a shared helper and import it in multiple places - both are less than ideal.</source>
          <target state="translated">如果不止一个组件需要使用这个功能,我们必须重复这个功能,或者将其提取到一个共享的帮助程序中,然后在多个地方导入--这两种情况都不太理想。</target>
        </trans-unit>
        <trans-unit id="bcd403966a8c64a6cc2f12e14145c0930fd23c8f" translate="yes" xml:space="preserve">
          <source>If we use a plain object to declare the state of the module, then that state object will be shared by reference and cause cross store/module state pollution when it's mutated.</source>
          <target state="translated">如果我们使用一个普通对象来声明模块的状态,那么这个状态对象就会被引用共享,并在突变时造成跨存储/模块状态污染。</target>
        </trans-unit>
        <trans-unit id="b7ec52a51a8cf587b9d439ecdf520d3332d63b46" translate="yes" xml:space="preserve">
          <source>If you are using &lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;vue-devtools&lt;/a&gt; you probably don't need this.</source>
          <target state="translated">如果您使用的是&lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;vue-devtools&lt;/a&gt;，则可能不需要。</target>
        </trans-unit>
        <trans-unit id="cee9eac37fcab09966f32a737634f82881a4edd4" translate="yes" xml:space="preserve">
          <source>If you have spies available in your testing environment (for example via &lt;a href=&quot;http://sinonjs.org/&quot;&gt;Sinon.JS&lt;/a&gt;), you can use them instead of the &lt;code&gt;testAction&lt;/code&gt; helper:</source>
          <target state="translated">如果您的测试环境中有间谍（例如通过&lt;a href=&quot;http://sinonjs.org/&quot;&gt;Sinon.JS&lt;/a&gt;），则可以使用它们代替 &lt;code&gt;testAction&lt;/code&gt; 帮助器：</target>
        </trans-unit>
        <trans-unit id="99253187df56aff1e087c7f8349702f7e584c5c0" translate="yes" xml:space="preserve">
          <source>If you pass a function that returns an object, the returned object is used as the root state. This is useful when you want to reuse the state object especially for module reuse. &lt;a href=&quot;../guide/modules#module-reuse&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">如果传递返回对象的函数，则返回的对象将用作根状态。当您要重用状态对象（尤其是模块重用）时，这很有用。&lt;a href=&quot;../guide/modules#module-reuse&quot;&gt;细节&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="09433d887f39cc66b122d2113ece04bd4c9edb90" translate="yes" xml:space="preserve">
          <source>If you prefer using a package manager such as NPM or Yarn, install it with the following commands:</source>
          <target state="translated">如果你喜欢使用包管理器,如NPM或Yarn,请使用以下命令安装它。</target>
        </trans-unit>
        <trans-unit id="c818e621900aa5c6ea1f6dea69d53344a7ed6a02" translate="yes" xml:space="preserve">
          <source>If you use modules exclusively, you can use &lt;code&gt;require.context&lt;/code&gt; to load and hot reload all modules dynamically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3c23688fd4c0302fe8a3ccf68a85702b829cacd" translate="yes" xml:space="preserve">
          <source>If you want to learn Vuex in an interactive way you can check out this &lt;a href=&quot;https://scrimba.com/g/gvuex&quot;&gt;Vuex course on Scrimba&lt;/a&gt;, which gives you a mix of screencast and code playground that you can pause and play around with anytime.</source>
          <target state="translated">如果您想以交互方式学习Vuex，可以&lt;a href=&quot;https://scrimba.com/g/gvuex&quot;&gt;在Scrimba上&lt;/a&gt;查看此Vuex课程，该课程为您提供了一系列的截屏视频和代码操场，您可以随时暂停播放。</target>
        </trans-unit>
        <trans-unit id="f3eb7c190d4d6d7796c724c80957f823f5be66cc" translate="yes" xml:space="preserve">
          <source>If you want to map a getter to a different name, use an object:</source>
          <target state="translated">如果你想把一个getter映射到不同的名称,请使用一个对象。</target>
        </trans-unit>
        <trans-unit id="20e00848ec8ade0a6824f9de7344231d1bfc9ba4" translate="yes" xml:space="preserve">
          <source>If you want to register global actions in namespaced modules, you can mark it with &lt;code&gt;root: true&lt;/code&gt; and place the action definition to function &lt;code&gt;handler&lt;/code&gt;. For example:</source>
          <target state="translated">如果要在命名空间模块中注册全局动作，则可以将其标记为 &lt;code&gt;root: true&lt;/code&gt; 并将动作定义放置到函数 &lt;code&gt;handler&lt;/code&gt; 中。例如：</target>
        </trans-unit>
        <trans-unit id="4f4b8e63a24cc27e082d0c2aea79d7dec7762531" translate="yes" xml:space="preserve">
          <source>If you want to use global state and getters, &lt;code&gt;rootState&lt;/code&gt; and &lt;code&gt;rootGetters&lt;/code&gt; are passed as the 3rd and 4th arguments to getter functions, and also exposed as properties on the &lt;code&gt;context&lt;/code&gt; object passed to action functions.</source>
          <target state="translated">如果要使用全局状态和getter，则 &lt;code&gt;rootState&lt;/code&gt; 和 &lt;code&gt;rootGetters&lt;/code&gt; 作为第3和第4个参数传递给getter函数，并且还作为传递给动作函数的 &lt;code&gt;context&lt;/code&gt; 对象的属性公开。</target>
        </trans-unit>
        <trans-unit id="6fcf9a3ab85ce67825ec590efb360c383d7dfca6" translate="yes" xml:space="preserve">
          <source>If you want your modules to be more self-contained or reusable, you can mark it as namespaced with &lt;code&gt;namespaced: true&lt;/code&gt;. When the module is registered, all of its getters, actions and mutations will be automatically namespaced based on the path the module is registered at. For example:</source>
          <target state="translated">如果您希望模块更加独立或可重用，则可以使用 &lt;code&gt;namespaced: true&lt;/code&gt; 将其标记为命名空间。注册模块后，将根据模块在其上注册的路径自动为其所有的获取，操作和突变命名空间。例如：</target>
        </trans-unit>
        <trans-unit id="09a871b493d3905657b3f74ae734baad18e2aaf1" translate="yes" xml:space="preserve">
          <source>If you've never built a large-scale SPA and jump right into Vuex, it may feel verbose and daunting. That's perfectly normal - if your app is simple, you will most likely be fine without Vuex. A simple &lt;a href=&quot;https://v3.vuejs.org/guide/state-management.html#simple-state-management-from-scratch&quot;&gt;store pattern&lt;/a&gt; may be all you need. But if you are building a medium-to-large-scale SPA, chances are you have run into situations that make you think about how to better handle state outside of your Vue components, and Vuex will be the natural next step for you. There's a good quote from Dan Abramov, the author of Redux:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5c0c63467aaecb0aa7b51168b383f900b5a513b" translate="yes" xml:space="preserve">
          <source>If you've never built a large-scale SPA and jump right into Vuex, it may feel verbose and daunting. That's perfectly normal - if your app is simple, you will most likely be fine without Vuex. A simple &lt;a href=&quot;https://vuejs.org/v2/guide/state-management.html#Simple-State-Management-from-Scratch&quot;&gt;store pattern&lt;/a&gt; may be all you need. But if you are building a medium-to-large-scale SPA, chances are you have run into situations that make you think about how to better handle state outside of your Vue components, and Vuex will be the natural next step for you. There's a good quote from Dan Abramov, the author of Redux:</source>
          <target state="translated">如果您从未构建过大型SPA并直接进入Vuex，则可能会感到冗长而艰巨。这是完全正常的-如果您的应用程序很简单，那么没有Vuex，您很可能会满意。一个简单的&lt;a href=&quot;https://vuejs.org/v2/guide/state-management.html#Simple-State-Management-from-Scratch&quot;&gt;存储模式&lt;/a&gt;可能就是您所需要的。但是，如果您要构建中型到大型的SPA，您很可能遇到了使您思考如何更好地处理Vue组件外部状态的情况，而Vuex将是​​您自然的下一步。 Redux的作者Dan Abramov给出了一个很好的报价：</target>
        </trans-unit>
        <trans-unit id="c6537ddc12952ad16232d8a921be6b7d5a76a6d6" translate="yes" xml:space="preserve">
          <source>If your getters have complicated computation, it is worth testing them. Getters are also very straightforward to test for the same reason as mutations.</source>
          <target state="translated">如果你的getter有复杂的计算,值得测试。获取器的测试也非常简单,原因和突变一样。</target>
        </trans-unit>
        <trans-unit id="4de758dad2a92aec248785ac4d6dbc0ff778d9aa" translate="yes" xml:space="preserve">
          <source>If your mutations and actions are written properly, the tests should have no direct dependency on Browser APIs after proper mocking. Thus you can simply bundle the tests with webpack and run it directly in Node. Alternatively, you can use &lt;code&gt;mocha-loader&lt;/code&gt; or Karma + &lt;code&gt;karma-webpack&lt;/code&gt; to run the tests in real browsers.</source>
          <target state="translated">如果正确编写了变异和操作，则在正确模拟后，测试不应直接依赖于浏览器API。因此，您可以将测试与webpack捆绑在一起，然后直接在Node中运行。另外，您可以使用 &lt;code&gt;mocha-loader&lt;/code&gt; 或Karma + &lt;code&gt;karma-webpack&lt;/code&gt; 在真实的浏览器中运行测试。</target>
        </trans-unit>
        <trans-unit id="6ee31c41647a54af22ae141a98d0fec5c96154f7" translate="yes" xml:space="preserve">
          <source>In Vuex 3, &lt;code&gt;createLogger&lt;/code&gt; function was exported from &lt;code&gt;vuex/dist/logger&lt;/code&gt; but it's now included in the core package. The function should be imported directly from the &lt;code&gt;vuex&lt;/code&gt; package.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a410e66d911dd3ae0a50e7b80b34a4ce49f0e9c" translate="yes" xml:space="preserve">
          <source>In a Vue component, you can access the store as &lt;code&gt;this.$store&lt;/code&gt;. Now we can commit a mutation using a component method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b21dc6e7af159e44f13e61d052a381cc5930fcfa" translate="yes" xml:space="preserve">
          <source>In most cases, the payload should be an object so that it can contain multiple fields, and the recorded mutation will also be more descriptive:</source>
          <target state="translated">在大多数情况下,有效载荷应该是一个对象,这样就可以包含多个字段,记录的突变也会更具描述性。</target>
        </trans-unit>
        <trans-unit id="c8e693418938cacbff5b768a895b5e05008f1bcd" translate="yes" xml:space="preserve">
          <source>In order to access state and getters, you will want to create &lt;code&gt;computed&lt;/code&gt; references to retain reactivity. This is the equivalent of creating computed properties using the Option API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b379a9de19b6c2947713c2e819c098b0d0414341" translate="yes" xml:space="preserve">
          <source>In practice, we often use ES2015 &lt;a href=&quot;https://github.com/lukehoban/es6features#destructuring&quot;&gt;argument destructuring&lt;/a&gt; to simplify the code a bit (especially when we need to call &lt;code&gt;commit&lt;/code&gt; multiple times):</source>
          <target state="translated">在实践中，我们经常使用ES2015 &lt;a href=&quot;https://github.com/lukehoban/es6features#destructuring&quot;&gt;参数解构&lt;/a&gt;来简化代码（特别是当我们需要多次调用 &lt;code&gt;commit&lt;/code&gt; 时）：</target>
        </trans-unit>
        <trans-unit id="3857e213dc0f7b8c7391de2df6fe7f4ad9600a0c" translate="yes" xml:space="preserve">
          <source>In strict mode, whenever Vuex state is mutated outside of mutation handlers, an error will be thrown. This ensures that all state mutations can be explicitly tracked by debugging tools.</source>
          <target state="translated">在严格模式下,只要Vuex状态在突变处理程序之外发生突变,就会抛出一个错误。这确保了所有的状态突变都能被调试工具明确地跟踪。</target>
        </trans-unit>
        <trans-unit id="f605f46f5b670a253f694d77a6479a46bf60c051" translate="yes" xml:space="preserve">
          <source>In such cases, you can pass the module namespace string as the first argument to the helpers so that all bindings are done using that module as the context. The above can be simplified to:</source>
          <target state="translated">在这种情况下,你可以把模块名称空间字符串作为第一个参数传递给helpers,这样所有的绑定都是以该模块作为上下文来完成的。上面的内容可以简化为</target>
        </trans-unit>
        <trans-unit id="fb4ca597574fefd3c18365a4df91a07d3925f51b" translate="yes" xml:space="preserve">
          <source>Include &lt;code&gt;vuex&lt;/code&gt; after Vue and it will install itself automatically:</source>
          <target state="translated">在Vue之后包含 &lt;code&gt;vuex&lt;/code&gt; ，它将自动安装自身：</target>
        </trans-unit>
        <trans-unit id="4edd5883cfc0f50d6093450192a5526d804c388e" translate="yes" xml:space="preserve">
          <source>Inside a module's mutations and getters, the first argument received will be &lt;strong&gt;the module's local state&lt;/strong&gt;.</source>
          <target state="translated">在模块的变量和获取器内部，收到的第一个参数将是&lt;strong&gt;模块的本地状态&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="457ba19288441fafbf211b7b6c88681a0845bc6a" translate="yes" xml:space="preserve">
          <source>Install &lt;code&gt;mocha-loader&lt;/code&gt;.</source>
          <target state="translated">安装 &lt;code&gt;mocha-loader&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="cddc92ee3266aa27b7cb36a384142725c9edaa5f" translate="yes" xml:space="preserve">
          <source>Installation process</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d0fe35d22060e945e08d2b96b5abfd85eb87e88" translate="yes" xml:space="preserve">
          <source>Instead of mutating the state, actions commit mutations.</source>
          <target state="translated">行动不是突变状态,而是进行突变。</target>
        </trans-unit>
        <trans-unit id="fb1e51da35f8b4fc5e80bad74fa44c9f09edf0fe" translate="yes" xml:space="preserve">
          <source>It is a commonly seen pattern to use constants for mutation types in various Flux implementations. This allows the code to take advantage of tooling like linters, and putting all constants in a single file allows your collaborators to get an at-a-glance view of what mutations are possible in the entire application:</source>
          <target state="translated">在各种Flux实现中,使用常量来处理突变类型是一种常见的模式。这使得代码可以利用像linters这样的工具,并且把所有的常量放在一个文件中,让你的合作者可以一目了然地了解整个应用程序中可以进行哪些突变。</target>
        </trans-unit>
        <trans-unit id="b3f113c6b42082f72c3757fb134ac642d34ef542" translate="yes" xml:space="preserve">
          <source>It is a self-contained app with the following parts:</source>
          <target state="translated">它是一个独立的应用程序,包含以下部分。</target>
        </trans-unit>
        <trans-unit id="3ed4288f050eb852b800df4047f36461f3b17cbb" translate="yes" xml:space="preserve">
          <source>It may be likely that you want to preserve the previous state when registering a new module, such as preserving state from a Server Side Rendered app. You can achieve this with &lt;code&gt;preserveState&lt;/code&gt; option: &lt;code&gt;store.registerModule('a', module, { preserveState: true })&lt;/code&gt;</source>
          <target state="translated">注册新模块时，您可能想保留以前的状态，例如从服务器端渲染的应用程序保留状态。你可以做到这一点 &lt;code&gt;preserveState&lt;/code&gt; 选项： &lt;code&gt;store.registerModule('a', module, { preserveState: true })&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="35dface9e340cb4e3bddcda3e4f2453cf5b8832e" translate="yes" xml:space="preserve">
          <source>It's possible for a &lt;code&gt;store.dispatch&lt;/code&gt; to trigger multiple action handlers in different modules. In such a case the returned value will be a Promise that resolves when all triggered handlers have been resolved.</source>
          <target state="translated">&lt;code&gt;store.dispatch&lt;/code&gt; 可能在不同模块中触发多个动作处理程序。在这种情况下，返回的值将是一个Promise，它在所有触发的处理程序都已解决时会解决。</target>
        </trans-unit>
        <trans-unit id="c26d954c51975d2534551b78c8a2337962fddd24" translate="yes" xml:space="preserve">
          <source>Last Updated:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fad0c3d2dd4948e1dc7eca7ef59267b9baf27c8d" translate="yes" xml:space="preserve">
          <source>Leaves prod/dev branches with &lt;code&gt;process.env.NODE_ENV&lt;/code&gt; guards (must be replaced by bundler).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9285043eca58d77420a4ea528c9c0140b7f99e5" translate="yes" xml:space="preserve">
          <source>Let's register a simple action:</source>
          <target state="translated">让我们注册一个简单的动作。</target>
        </trans-unit>
        <trans-unit id="e58183fe873032e36b18fd13feeb2f3de6adac51" translate="yes" xml:space="preserve">
          <source>Let's start with a simple Vue counter app:</source>
          <target state="translated">我们先来看看一个简单的Vue计数器应用。</target>
        </trans-unit>
        <trans-unit id="c7d28df54f0ee7bb49a6c375079257b9e2ce533e" translate="yes" xml:space="preserve">
          <source>Let's tackle this step by step. First, define the key using Vue's &lt;code&gt;InjectionKey&lt;/code&gt; interface along with your own store typing definition:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">根据麻省理工学院许可证授权。</target>
        </trans-unit>
        <trans-unit id="3c4e2ff1708a0052c627ff0c7963ae29daba2c37" translate="yes" xml:space="preserve">
          <source>Method-Style Access</source>
          <target state="translated">方法式访问</target>
        </trans-unit>
        <trans-unit id="c2e90d9f7d5710359410a2feb78df1c412eb56ec" translate="yes" xml:space="preserve">
          <source>Migrating to 4.0 from 3.x</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64f4a0ce2e411202b8f65d464a7de482b8f37081" translate="yes" xml:space="preserve">
          <source>Module Local State</source>
          <target state="translated">地方国家模块</target>
        </trans-unit>
        <trans-unit id="da07abb5f2f59744fb9d34a53f63697e0f2d1603" translate="yes" xml:space="preserve">
          <source>Module Reuse</source>
          <target state="translated">模块再利用</target>
        </trans-unit>
        <trans-unit id="04e9462c0ff02bb9032b92abd45881a3c7e15fb7" translate="yes" xml:space="preserve">
          <source>Modules</source>
          <target state="translated">Modules</target>
        </trans-unit>
        <trans-unit id="f4e46025da22a7ac6c15f6c0d760b1ec96373a5b" translate="yes" xml:space="preserve">
          <source>Most commonly used in plugins. &lt;a href=&quot;../guide/plugins&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">最常用于插件中。&lt;a href=&quot;../guide/plugins&quot;&gt;细节&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="415ace164c00364e28e4d1cc0b1dea319d4e4fe4" translate="yes" xml:space="preserve">
          <source>Multiple views may depend on the same piece of state.</source>
          <target state="translated">多个观点可能取决于同一块状态。</target>
        </trans-unit>
        <trans-unit id="00a7fb731451c41a484b7591ece27f55c474ec0e" translate="yes" xml:space="preserve">
          <source>Mutations</source>
          <target state="translated">Mutations</target>
        </trans-unit>
        <trans-unit id="104200b8a17f6d972a707d856a1247d4c7c79f01" translate="yes" xml:space="preserve">
          <source>Mutations Follow Vue's Reactivity Rules</source>
          <target state="translated">突变遵循Vue的反应性规则。</target>
        </trans-unit>
        <trans-unit id="1c4ca77f8cfecf119f2abce71ca721d4bcfe55b6" translate="yes" xml:space="preserve">
          <source>Mutations Must Be Synchronous</source>
          <target state="translated">突变必须是同步的</target>
        </trans-unit>
        <trans-unit id="654ac141ada51cc2648d26957205d691ce5cdaec" translate="yes" xml:space="preserve">
          <source>Mutations are very straightforward to test, because they are just functions that completely rely on their arguments. One trick is that if you are using ES2015 modules and put your mutations inside your &lt;code&gt;store.js&lt;/code&gt; file, in addition to the default export, you should also export the mutations as a named export:</source>
          <target state="translated">突变非常容易测试，因为它们只是完全依赖其参数的函数。一种技巧是，如果您正在使用ES2015模块并将变异存储在 &lt;code&gt;store.js&lt;/code&gt; 文件中，则除了默认导出外，还应将变异导出为命名导出：</target>
        </trans-unit>
        <trans-unit id="a8ad860c15810cce0e7beac1c91da3ab2cb22c47" translate="yes" xml:space="preserve">
          <source>NOTE</source>
          <target state="translated">NOTE</target>
        </trans-unit>
        <trans-unit id="7d94ebbf07f5417771d7c7fd06f208703494bf50" translate="yes" xml:space="preserve">
          <source>NPM</source>
          <target state="translated">NPM</target>
        </trans-unit>
        <trans-unit id="f0146eaf3d75ae19152beec5a891e0df9b9d3793" translate="yes" xml:space="preserve">
          <source>Namespaced getters and actions will receive localized &lt;code&gt;getters&lt;/code&gt;, &lt;code&gt;dispatch&lt;/code&gt; and &lt;code&gt;commit&lt;/code&gt;. In other words, you can use the module assets without writing prefix in the same module. Toggling between namespaced or not does not affect the code inside the module.</source>
          <target state="translated">命名空间的getter和action将接收本地化的 &lt;code&gt;getters&lt;/code&gt; ，进行 &lt;code&gt;dispatch&lt;/code&gt; 和 &lt;code&gt;commit&lt;/code&gt; 。换句话说，您可以使用模块资产而无需在同一模块中写入前缀。在命名空间与非命名空间之间切换不会影响模块内部的代码。</target>
        </trans-unit>
        <trans-unit id="362b423baafd1e7b201b94eb4694146a945d2f27" translate="yes" xml:space="preserve">
          <source>Namespacing</source>
          <target state="translated">Namespacing</target>
        </trans-unit>
        <trans-unit id="156e3db7d7ff24a58bfd4733460906ddcf9c82d6" translate="yes" xml:space="preserve">
          <source>New &quot;useStore&quot; composition function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a71d5762c0258836841ff5df622a89af0d09ccba" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;useStore&lt;/code&gt; composition function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="025519ea3f483eb11a3c8608b8a731eee0947b1b" translate="yes" xml:space="preserve">
          <source>New Features</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4820b6a8eaff4049273790823038a2d97641ee6b" translate="yes" xml:space="preserve">
          <source>New in 2.5.0</source>
          <target state="translated">2.5.0中的新功能</target>
        </trans-unit>
        <trans-unit id="ee5b92286bff361e6506cbde70ab9d79b67f9e22" translate="yes" xml:space="preserve">
          <source>New in 3.1.0</source>
          <target state="translated">3.1.0中的新功能</target>
        </trans-unit>
        <trans-unit id="f603edae1429a95385a9e96dce7eed555212b05b" translate="yes" xml:space="preserve">
          <source>Next, pass the defined injection key when installing the store to the Vue app:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94cbec932a3607b921845482469e8e3e43a2cef8" translate="yes" xml:space="preserve">
          <source>Next, we will discuss each core concept in much finer details, starting with &lt;a href=&quot;state&quot;&gt;State&lt;/a&gt;.</source>
          <target state="translated">接下来，我们将从&lt;a href=&quot;state&quot;&gt;State&lt;/a&gt;开始更详细地讨论每个核心概念。</target>
        </trans-unit>
        <trans-unit id="8a19151987fbe02547ee0f70513d32dd282c4ac0" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;mapState&lt;/code&gt; returns an object. How do we use it in combination with other local computed properties? Normally, we'd have to use a utility to merge multiple objects into one so that we can pass the final object to &lt;code&gt;computed&lt;/code&gt;. However with the &lt;a href=&quot;https://github.com/sebmarkbage/ecmascript-rest-spread&quot;&gt;object spread operator&lt;/a&gt; (which is a stage-4 ECMAScript proposal), we can greatly simplify the syntax:</source>
          <target state="translated">请注意， &lt;code&gt;mapState&lt;/code&gt; 返回一个对象。我们如何将其与其他本地计算属性结合使用？通常，我们必须使用一种实用程序将多个对象合并为一个，以便可以将最终对象传递给 &lt;code&gt;computed&lt;/code&gt; 。但是，使用&lt;a href=&quot;https://github.com/sebmarkbage/ecmascript-rest-spread&quot;&gt;对象散布运算符&lt;/a&gt;（这是ECMAScript的第4阶段建议），我们可以大大简化语法：</target>
        </trans-unit>
        <trans-unit id="8fdd2db4fff8fb671f8b5b5304c69fa03718c6bb" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;mapState&lt;/code&gt; returns an object. How do we use it in combination with other local computed properties? Normally, we'd have to use a utility to merge multiple objects into one so that we can pass the final object to &lt;code&gt;computed&lt;/code&gt;. However with the &lt;a href=&quot;https://github.com/tc39/proposal-object-rest-spread&quot;&gt;object spread operator&lt;/a&gt;, we can greatly simplify the syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="383f040aea7fdc521540d519355364a1d7f735a8" translate="yes" xml:space="preserve">
          <source>Note that getters accessed as properties are cached as part of Vue's reactivity system.</source>
          <target state="translated">请注意,作为属性访问的getter是作为Vue的反应系统的一部分进行缓存的。</target>
        </trans-unit>
        <trans-unit id="ee0bf46abe7c412da05c2c7e1afee2ada212118c" translate="yes" xml:space="preserve">
          <source>Note that getters accessed via methods will run each time you call them, and the result is not cached.</source>
          <target state="translated">请注意,通过方法访问的getter会在每次调用时运行,结果不会被缓存。</target>
        </trans-unit>
        <trans-unit id="d5717e27426eb7a2d5c1747c90156711ec9ef26a" translate="yes" xml:space="preserve">
          <source>Note that you may check if the module is already registered to the store or not via &lt;code&gt;store.hasModule(moduleName)&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93fca34876045ca8e7715e28c6d04cb4373157ba" translate="yes" xml:space="preserve">
          <source>Note the logger plugin takes state snapshots, so use it only during development.</source>
          <target state="translated">注意记录器插件会进行状态快照,所以只在开发过程中使用。</target>
        </trans-unit>
        <trans-unit id="11f45dfd75b6d4fbcfd55b7ac788bd4b130224b1" translate="yes" xml:space="preserve">
          <source>Note we are performing a flow of asynchronous operations, and recording the side effects (state mutations) of the action by committing them.</source>
          <target state="translated">注意,我们是在执行一个异步操作流,并通过提交来记录动作的副作用(状态突变)。</target>
        </trans-unit>
        <trans-unit id="ab293ff1751dac6b50aacc1c946da9ff9bd12a5a" translate="yes" xml:space="preserve">
          <source>Now imagine we are debugging the app and looking at the devtool's mutation logs. For every mutation logged, the devtool will need to capture a &quot;before&quot; and &quot;after&quot; snapshots of the state. However, the asynchronous callback inside the example mutation above makes that impossible: the callback is not called yet when the mutation is committed, and there's no way for the devtool to know when the callback will actually be called - any state mutation performed in the callback is essentially un-trackable!</source>
          <target state="translated">现在想象一下,我们正在调试应用程序并查看devtool的突变日志。对于每一次记录的突变,devtool都需要捕获 &quot;之前 &quot;和 &quot;之后 &quot;的状态快照。然而,上面例子中的异步回调使得这一点变得不可能:当突变提交时,回调还没有被调用,而且devtool也无法知道回调何时会被真正调用--任何在回调中执行的状态突变基本上都是无法跟踪的。</target>
        </trans-unit>
        <trans-unit id="93b9e7a0a6529c120d308e3a9afc60556aa4685a" translate="yes" xml:space="preserve">
          <source>Now you can do:</source>
          <target state="translated">现在你可以做。</target>
        </trans-unit>
        <trans-unit id="a5bc280bd65d97298b6a537bbd98ca0fca61ada2" translate="yes" xml:space="preserve">
          <source>Now, by importing your own composable function, you can retrieve the typed store &lt;strong&gt;without&lt;/strong&gt; having to provide the injection key and it's typing:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cab930ccc32a830cf1b2daffb710e302771e1ccf" translate="yes" xml:space="preserve">
          <source>Now, you can access the state object as &lt;code&gt;store.state&lt;/code&gt;, and trigger a state change with the &lt;code&gt;store.commit&lt;/code&gt; method:</source>
          <target state="translated">现在，您可以访问状态对象 &lt;code&gt;store.state&lt;/code&gt; ，并触发与状态变化 &lt;code&gt;store.commit&lt;/code&gt; 方法：</target>
        </trans-unit>
        <trans-unit id="ace4a2b4fe085d950494ad9721a19fbdb4b869ed" translate="yes" xml:space="preserve">
          <source>Object Spread Operator</source>
          <target state="translated">对象展布运算符</target>
        </trans-unit>
        <trans-unit id="4e55a0d58d5e1d3dd2c370978eeab3967aadea55" translate="yes" xml:space="preserve">
          <source>Object-Style Commit</source>
          <target state="translated">对象式承诺</target>
        </trans-unit>
        <trans-unit id="af6888b6f45f7db98c78eb748575fc0a520bf758" translate="yes" xml:space="preserve">
          <source>On to Actions</source>
          <target state="translated">关于行动</target>
        </trans-unit>
        <trans-unit id="be28144bfe8196f5de9245ef24f38b80c1795631" translate="yes" xml:space="preserve">
          <source>One important rule to remember is that &lt;strong&gt;mutation handler functions must be synchronous&lt;/strong&gt;. Why? Consider the following example:</source>
          <target state="translated">要记住的一个重要规则是，&lt;strong&gt;变异处理函数必须是同步的&lt;/strong&gt;。为什么？考虑以下示例：</target>
        </trans-unit>
        <trans-unit id="0a517ce6f632f361387aae43f330fac6b9ff2fb5" translate="yes" xml:space="preserve">
          <source>Pass the typed &lt;code&gt;InjectionKey&lt;/code&gt; to the &lt;code&gt;useStore&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2228a15359ec1787af59c5da6ce5e371da06846" translate="yes" xml:space="preserve">
          <source>Place the following code in your project to allow &lt;code&gt;this.$store&lt;/code&gt; to be typed correctly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab2e26dd8b8868a3969cb3321e0c983c0d9d67d4" translate="yes" xml:space="preserve">
          <source>Plugins</source>
          <target state="translated">Plugins</target>
        </trans-unit>
        <trans-unit id="22f632f9f25219b387e3b3f91a16935bbf27d29a" translate="yes" xml:space="preserve">
          <source>Plugins are not allowed to directly mutate state - similar to your components, they can only trigger changes by committing mutations.</source>
          <target state="translated">插件不允许直接突变状态--与你的组件类似,它们只能通过提交突变来触发变化。</target>
        </trans-unit>
        <trans-unit id="184f9c5d6a512ea46935550bc3405af620cc2aa9" translate="yes" xml:space="preserve">
          <source>Prefer initializing your store's initial state with all desired fields upfront.</source>
          <target state="translated">首选在前期用所有需要的字段来初始化你店铺的初始状态。</target>
        </trans-unit>
        <trans-unit id="e7e706a353f493baa85f48336645f1af9ce6a62b" translate="yes" xml:space="preserve">
          <source>Preserving state</source>
          <target state="translated">维护国家</target>
        </trans-unit>
        <trans-unit id="fe5671922bc7f67cfabfa60ab97a9542ac21f39f" translate="yes" xml:space="preserve">
          <source>Promise</source>
          <target state="translated">Promise</target>
        </trans-unit>
        <trans-unit id="8dc7952272c26facc9a2c5604edbd77344108471" translate="yes" xml:space="preserve">
          <source>Property-Style Access</source>
          <target state="translated">物业式访问</target>
        </trans-unit>
        <trans-unit id="f3080b3597ce40f7b3c7da14211527d0235807a1" translate="yes" xml:space="preserve">
          <source>Provide the typed &lt;code&gt;InjectionKey&lt;/code&gt; when installing a store to the Vue app.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fffd76e54cabe19ee1677cc2622cd23e6e275e9" translate="yes" xml:space="preserve">
          <source>Reactively watch &lt;code&gt;fn&lt;/code&gt;'s return value, and call the callback when the value changes. &lt;code&gt;fn&lt;/code&gt; receives the store's state as the first argument, and getters as the second argument. Accepts an optional options object that takes the same options as &lt;a href=&quot;https://vuejs.org/v2/api/#vm-watch&quot;&gt;Vue's &lt;code&gt;vm.$watch&lt;/code&gt; method&lt;/a&gt;.</source>
          <target state="translated">反应性地观察 &lt;code&gt;fn&lt;/code&gt; 的返回值，并在值更改时调用回调。 &lt;code&gt;fn&lt;/code&gt; 接收商店的状态作为第一个参数，而getters作为第二个参数。接受一个可选的options对象，该对象采用与&lt;a href=&quot;https://vuejs.org/v2/api/#vm-watch&quot;&gt;Vue的 &lt;code&gt;vm.$watch&lt;/code&gt; 方法&lt;/a&gt;相同的选项。</target>
        </trans-unit>
        <trans-unit id="75e4ab33b7b5dc7455e9eadf2e7119121508fb6e" translate="yes" xml:space="preserve">
          <source>Register Global Action in Namespaced Modules</source>
          <target state="translated">在命名间隔模块中注册全局行动</target>
        </trans-unit>
        <trans-unit id="de6210ec05f575ccd3825af5410dca87db3c1a7e" translate="yes" xml:space="preserve">
          <source>Register a dynamic module. &lt;a href=&quot;../guide/modules#dynamic-module-registration&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">注册动态模块。&lt;a href=&quot;../guide/modules#dynamic-module-registration&quot;&gt;细节&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ad2bb0219d3b7cad70e9aeaf8b370461d8c5f459" translate="yes" xml:space="preserve">
          <source>Register actions on the store. The handler function receives a &lt;code&gt;context&lt;/code&gt; object that exposes the following properties:</source>
          <target state="translated">在商店上注册操作。处理程序函数接收一个 &lt;code&gt;context&lt;/code&gt; 对象，该对象公开以下属性：</target>
        </trans-unit>
        <trans-unit id="0c3c4cb0360b08ab239d9d6ce7ef5979c7bd75c9" translate="yes" xml:space="preserve">
          <source>Register getters on the store. The getter function receives the following arguments:</source>
          <target state="translated">在商店上注册getter。getter函数接收以下参数。</target>
        </trans-unit>
        <trans-unit id="b656445541eada906150dd7ca28e7277b3f8ac2d" translate="yes" xml:space="preserve">
          <source>Register mutations on the store. The handler function always receives &lt;code&gt;state&lt;/code&gt; as the first argument (will be module local state if defined in a module), and receives a second &lt;code&gt;payload&lt;/code&gt; argument if there is one.</source>
          <target state="translated">在商店中注册突变。处理程序函数始终将 &lt;code&gt;state&lt;/code&gt; 作为第一个参数接收（如果在模块中定义，则将是模块本地状态），如果有，则接收第二个 &lt;code&gt;payload&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="17a6292e850aa27ddd8a69f3670d7bf427ff4201" translate="yes" xml:space="preserve">
          <source>Register the same module multiple times in the same store.</source>
          <target state="translated">在同一店铺中多次注册同一模块。</target>
        </trans-unit>
        <trans-unit id="9adccc4f4e3ee229d76671c447375a4b4430cf1a" translate="yes" xml:space="preserve">
          <source>Registered getters are exposed on &lt;code&gt;store.getters&lt;/code&gt;.</source>
          <target state="translated">注册的吸气剂在 &lt;code&gt;store.getters&lt;/code&gt; 上公开。</target>
        </trans-unit>
        <trans-unit id="e74661ca249919f9eff75810910ad50f600b9f27" translate="yes" xml:space="preserve">
          <source>Replace that Object with a fresh one. For example, using the &lt;a href=&quot;https://github.com/sebmarkbage/ecmascript-rest-spread&quot;&gt;object spread syntax&lt;/a&gt; we can write it like this:</source>
          <target state="translated">用一个新的对象替换该对象。例如，使用&lt;a href=&quot;https://github.com/sebmarkbage/ecmascript-rest-spread&quot;&gt;对象传播语法，&lt;/a&gt;我们可以这样编写：</target>
        </trans-unit>
        <trans-unit id="cfc7d1d9a1abac11e07fd8298b3033a2dd367be4" translate="yes" xml:space="preserve">
          <source>Replace the store's root state. Use this only for state hydration / time-travel purposes.</source>
          <target state="translated">替换商店的根状态。仅用于状态补水/时空穿越目的。</target>
        </trans-unit>
        <trans-unit id="7ec9eede60ad8e8637510a86e616531533ada02f" translate="yes" xml:space="preserve">
          <source>Running Tests</source>
          <target state="translated">运行测试</target>
        </trans-unit>
        <trans-unit id="11b20f83f47c6fa0a2ecb66cf17c37a8bf3312ce" translate="yes" xml:space="preserve">
          <source>Running in Browser</source>
          <target state="translated">在浏览器中运行</target>
        </trans-unit>
        <trans-unit id="27b89784a5a88ae4dea9d0fe0a57d6ac83db22be" translate="yes" xml:space="preserve">
          <source>Running in Browser with Karma + karma-webpack</source>
          <target state="translated">在浏览器中使用Karma+karma-webpack运行</target>
        </trans-unit>
        <trans-unit id="cbd1c1641d5f61fff635a6b95f6786707cdb60a6" translate="yes" xml:space="preserve">
          <source>Running in Node</source>
          <target state="translated">在Node中运行</target>
        </trans-unit>
        <trans-unit id="b7a73f532334578b3a16beb74895158fa37aca37" translate="yes" xml:space="preserve">
          <source>Similar to plugins, we can let the build tools handle that:</source>
          <target state="translated">类似于插件,我们可以让构建工具来处理。</target>
        </trans-unit>
        <trans-unit id="6440404824fd3c3690de22244c1449cd72882e79" translate="yes" xml:space="preserve">
          <source>Similarly, inside module actions, &lt;code&gt;context.state&lt;/code&gt; will expose the local state, and root state will be exposed as &lt;code&gt;context.rootState&lt;/code&gt;:</source>
          <target state="translated">类似地，在模块动作中， &lt;code&gt;context.state&lt;/code&gt; 将公开本地状态，而根状态将公开为 &lt;code&gt;context.rootState&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ca9c5e520923e6214e6e652479441ba757527ff7" translate="yes" xml:space="preserve">
          <source>Simplifying &lt;code&gt;useStore&lt;/code&gt; usage</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="025e718449a36bec79871ddaaf94c1265848b2f1" translate="yes" xml:space="preserve">
          <source>Since 3.1.0, &lt;code&gt;subscribeAction&lt;/code&gt; can also specify whether the subscribe handler should be called &lt;em&gt;before&lt;/em&gt; or &lt;em&gt;after&lt;/em&gt; an action dispatch (the default behavior is &lt;em&gt;before&lt;/em&gt;):</source>
          <target state="translated">从3.1.0版本开始， &lt;code&gt;subscribeAction&lt;/code&gt; 还可以指定是在动作分派&lt;em&gt;之前&lt;/em&gt;还是&lt;em&gt;之后&lt;/em&gt;调用订阅处理程序（默认行为是&lt;em&gt;before&lt;/em&gt;）：</target>
        </trans-unit>
        <trans-unit id="f3fd68e0c5995c6798e0356b50e929c10917b3a4" translate="yes" xml:space="preserve">
          <source>Since a Vuex store's state is made reactive by Vue, when we mutate the state, Vue components observing the state will update automatically. This also means Vuex mutations are subject to the same reactivity caveats when working with plain Vue:</source>
          <target state="translated">由于Vuex商店的状态是由Vue做出反应性的,所以当我们突变状态时,观察该状态的Vue组件将自动更新。这也意味着Vuex突变在使用普通Vue时,也会受到同样的反应性的约束。</target>
        </trans-unit>
        <trans-unit id="92041cc87d58be0a729eade29063235fe14b3c9c" translate="yes" xml:space="preserve">
          <source>Single State Tree</source>
          <target state="translated">单一状态树</target>
        </trans-unit>
        <trans-unit id="5f6ffb7192daf8fe93bcac0572129c5101463336" translate="yes" xml:space="preserve">
          <source>So how do we display state inside the store in our Vue components? Since Vuex stores are reactive, the simplest way to &quot;retrieve&quot; state from it is simply returning some store state from within a &lt;a href=&quot;https://vuejs.org/guide/computed.html&quot;&gt;computed property&lt;/a&gt;:</source>
          <target state="translated">那么，我们如何在Vue组件的商店内部显示状态？由于Vuex商店是反应式的，因此从其中&amp;ldquo;获取&amp;rdquo;状态的最简单方法就是从&lt;a href=&quot;https://vuejs.org/guide/computed.html&quot;&gt;计算属性&lt;/a&gt;内返回一些商店状态：</target>
        </trans-unit>
        <trans-unit id="54d205729e342259f235761f9ebec2b225fe9abb" translate="yes" xml:space="preserve">
          <source>So why don't we extract the shared state out of the components, and manage it in a global singleton? With this, our component tree becomes a big &quot;view&quot;, and any component can access the state or trigger actions, no matter where they are in the tree!</source>
          <target state="translated">那么,为什么我们不把共享状态从组件中提取出来,用一个全局的单子来管理它呢?这样一来,我们的组件树就变成了一个大的 &quot;视图&quot;,任何组件都可以访问状态或触发动作,无论它们在树上的哪个位置。</target>
        </trans-unit>
        <trans-unit id="f9f500529b87d6c41aa1c9ce2a53ab85b0f73f09" translate="yes" xml:space="preserve">
          <source>Sometimes a plugin may want to receive &quot;snapshots&quot; of the state, and also compare the post-mutation state with pre-mutation state. To achieve that, you will need to perform a deep-copy on the state object:</source>
          <target state="translated">有时,插件可能想要接收状态的 &quot;快照&quot;,同时也要将修改后的状态与修改前的状态进行比较。为了达到这个目的,你需要对状态对象进行深度复制。</target>
        </trans-unit>
        <trans-unit id="ae8a5bdac2cd3270ab81602ae7fc6131bdbc35db" translate="yes" xml:space="preserve">
          <source>Sometimes we may need to compute derived state based on store state, for example filtering through a list of items and counting them:</source>
          <target state="translated">有时候,我们可能需要根据存储状态来计算派生状态,比如在一个物品列表中进行筛选和计数。</target>
        </trans-unit>
        <trans-unit id="35ae76006ac7e393b8d6ac1ac6f19a1ddefd3da2" translate="yes" xml:space="preserve">
          <source>Sometimes we may need to create multiple instances of a module, for example:</source>
          <target state="translated">有时,我们可能需要创建一个模块的多个实例,例如。</target>
        </trans-unit>
        <trans-unit id="13e4487543b6d8b06a46672cfa73442042e5fe18" translate="yes" xml:space="preserve">
          <source>Specific when defined in a module</source>
          <target state="translated">在模块中定义的具体内容</target>
        </trans-unit>
        <trans-unit id="aabf420288f022d987bce3f9558b9c31ba749e69" translate="yes" xml:space="preserve">
          <source>Start &lt;code&gt;webpack-dev-server&lt;/code&gt; using the config.</source>
          <target state="translated">使用配置启动 &lt;code&gt;webpack-dev-server&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a72502067518684f9deeec70cf119fd26326cd33" translate="yes" xml:space="preserve">
          <source>State</source>
          <target state="translated">State</target>
        </trans-unit>
        <trans-unit id="0d8a7046c8d39d9cbd86abcdfb704b161a601f9e" translate="yes" xml:space="preserve">
          <source>Store</source>
          <target state="translated">Store</target>
        </trans-unit>
        <trans-unit id="cc646793e5a188b7dfed3c624e7ab770f511a330" translate="yes" xml:space="preserve">
          <source>Store Constructor Options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f3918202b47796e149a1504576be44f9c797b67" translate="yes" xml:space="preserve">
          <source>Store Instance Methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78960d483bd318512b15157254083d90ec1e70bb" translate="yes" xml:space="preserve">
          <source>Store Instance Properties</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e2f83ae922aab27ffe541f2875e43e6786c6d9f" translate="yes" xml:space="preserve">
          <source>StoreOptions.actions</source>
          <target state="translated">StoreOptions.actions</target>
        </trans-unit>
        <trans-unit id="7c2fb974fe6ac37076408fe6492caf0b5a840a6c" translate="yes" xml:space="preserve">
          <source>StoreOptions.devtools</source>
          <target state="translated">StoreOptions.devtools</target>
        </trans-unit>
        <trans-unit id="27bc45330a80e26b40635dc4a8b8fc17abc36877" translate="yes" xml:space="preserve">
          <source>StoreOptions.getters</source>
          <target state="translated">StoreOptions.getters</target>
        </trans-unit>
        <trans-unit id="13d89889e279cf3f4db38944cc0e1b9022ac7e5b" translate="yes" xml:space="preserve">
          <source>StoreOptions.modules</source>
          <target state="translated">StoreOptions.modules</target>
        </trans-unit>
        <trans-unit id="f35c2bfcf842e192031830ea98d80cec6e137cc2" translate="yes" xml:space="preserve">
          <source>StoreOptions.mutations</source>
          <target state="translated">StoreOptions.mutations</target>
        </trans-unit>
        <trans-unit id="9b08c590c8720def20c8cc4d49a23a43f356dabe" translate="yes" xml:space="preserve">
          <source>StoreOptions.plugins</source>
          <target state="translated">StoreOptions.plugins</target>
        </trans-unit>
        <trans-unit id="249ab110bf5289e564529ec006774bd6849ef3fa" translate="yes" xml:space="preserve">
          <source>StoreOptions.state</source>
          <target state="translated">StoreOptions.state</target>
        </trans-unit>
        <trans-unit id="057f939fdf0b4897b3dea09feff450cb50fdf3a3" translate="yes" xml:space="preserve">
          <source>StoreOptions.strict</source>
          <target state="translated">StoreOptions.strict</target>
        </trans-unit>
        <trans-unit id="7c183131363f4251f89993f5090afc10d8f0caad" translate="yes" xml:space="preserve">
          <source>Strict Mode</source>
          <target state="translated">严格模式</target>
        </trans-unit>
        <trans-unit id="cf363d0f2bd89c65219cc88d7452d61570ae39f4" translate="yes" xml:space="preserve">
          <source>Subscribe to store actions. The &lt;code&gt;handler&lt;/code&gt; is called for every dispatched action and receives the action descriptor and current store state as arguments. The &lt;code&gt;subscribe&lt;/code&gt; method will return an &lt;code&gt;unsubscribe&lt;/code&gt; function, which should be called when the subscription is no longer needed. For example, when unregistering a Vuex module or before destroying a Vue component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb4be8ac142fac6db9e88ed567eba8eb3225184f" translate="yes" xml:space="preserve">
          <source>Subscribe to store actions. The &lt;code&gt;handler&lt;/code&gt; is called for every dispatched action and receives the action descriptor and current store state as arguments:</source>
          <target state="translated">订阅存储操作。对于每个分派的操作，将调用该 &lt;code&gt;handler&lt;/code&gt; ，并接收操作描述符和当前存储状态作为参数：</target>
        </trans-unit>
        <trans-unit id="120d63b068274dc6942d114c566d657d42c319d8" translate="yes" xml:space="preserve">
          <source>Subscribe to store mutations. The &lt;code&gt;handler&lt;/code&gt; is called after every mutation and receives the mutation descriptor and post-mutation state as arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf1e862a182cd71e72218de4a57d6428ba414773" translate="yes" xml:space="preserve">
          <source>Subscribe to store mutations. The &lt;code&gt;handler&lt;/code&gt; is called after every mutation and receives the mutation descriptor and post-mutation state as arguments:</source>
          <target state="translated">订阅存储突变。该 &lt;code&gt;handler&lt;/code&gt; 每突变后调用并接收突变描述符和突变后状态参数：</target>
        </trans-unit>
        <trans-unit id="4a190c880575f8d6d89a23b4172d04f0a311e4e6" translate="yes" xml:space="preserve">
          <source>Taking State Snapshots</source>
          <target state="translated">拍摄国家快照</target>
        </trans-unit>
        <trans-unit id="0820b32b206b7352858e8903a838ed14319acdfd" translate="yes" xml:space="preserve">
          <source>Testing</source>
          <target state="translated">Testing</target>
        </trans-unit>
        <trans-unit id="c59410bf3ca2f20fd8b0393728deccf2dc47f93a" translate="yes" xml:space="preserve">
          <source>Testing Actions</source>
          <target state="translated">测试行动</target>
        </trans-unit>
        <trans-unit id="34e8d11332da2e378672d0a243a1d14c5129d499" translate="yes" xml:space="preserve">
          <source>Testing Getters</source>
          <target state="translated">测试获得者</target>
        </trans-unit>
        <trans-unit id="97aad71ba2619e15a2576f93a06f963d9f14710f" translate="yes" xml:space="preserve">
          <source>Testing Mutations</source>
          <target state="translated">测试突变</target>
        </trans-unit>
        <trans-unit id="9c06adb3a316efc06559622690345fb618cbaf08" translate="yes" xml:space="preserve">
          <source>The &quot;Vuex way&quot; to deal with it is binding the &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;'s value and call a method on the &lt;code&gt;input&lt;/code&gt; or &lt;code&gt;change&lt;/code&gt; event:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75a5f0cdaf9e2b8de2bd8a7b0367c1b182465746" translate="yes" xml:space="preserve">
          <source>The &quot;Vuex way&quot; to deal with it is binding the &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;'s value and call an action on the &lt;code&gt;input&lt;/code&gt; or &lt;code&gt;change&lt;/code&gt; event:</source>
          <target state="translated">处理它的&amp;ldquo; Vuex方法&amp;rdquo;是绑定 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 的值，并在 &lt;code&gt;input&lt;/code&gt; 或 &lt;code&gt;change&lt;/code&gt; 事件上调用一个操作：</target>
        </trans-unit>
        <trans-unit id="7f04c49ca29bd705949d5268ee1592e8506b75b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;createLogger&lt;/code&gt; function takes a few options:</source>
          <target state="translated">该 &lt;code&gt;createLogger&lt;/code&gt; 功能需要几个选项：</target>
        </trans-unit>
        <trans-unit id="7f82a0b0f64bd49ff203795584f21da841843a62" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mapGetters&lt;/code&gt; Helper</source>
          <target state="translated">该 &lt;code&gt;mapGetters&lt;/code&gt; 助手</target>
        </trans-unit>
        <trans-unit id="98e2bb1175bd22373105493a5a1bff66a0f61906" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mapGetters&lt;/code&gt; helper simply maps store getters to local computed properties:</source>
          <target state="translated">&lt;code&gt;mapGetters&lt;/code&gt; 帮助器只是将商店的获取方法映射到本地计算的属性：</target>
        </trans-unit>
        <trans-unit id="1c64da128ff2a5fa70401dea47d5ef1a1c1ebe06" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mapState&lt;/code&gt; Helper</source>
          <target state="translated">该 &lt;code&gt;mapState&lt;/code&gt; 助手</target>
        </trans-unit>
        <trans-unit id="4ed23a0b581ae30af2dc1a6fb0ab9dd6e2a32e58" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;subscribe&lt;/code&gt; method will return an &lt;code&gt;unsubscribe&lt;/code&gt; function, which should be called when the subscription is no longer needed. For example, you might subscribe to a Vuex Module and unsubscribe when you unregister the module. Or you might call &lt;code&gt;subscribe&lt;/code&gt; from inside a Vue Component and then destroy the component later. In these cases, you should remember to unsubscribe the subscription manually.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d697d8557ee6fc852c1e6a6fc7993902dd98d06b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;subscribeAction&lt;/code&gt; method is most commonly used in plugins. &lt;a href=&quot;../guide/plugins&quot;&gt;Details&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b142924d441d0b8c053ee3a0c60776db52d2668" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;subscribeAction&lt;/code&gt; method will return an &lt;code&gt;unsubscribe&lt;/code&gt; function, which should be called when the subscription is no longer needed. For example, you might subscribe to a Vuex Module and unsubscribe when you unregister the module. Or you might call &lt;code&gt;subscribeAction&lt;/code&gt; from inside a Vue Component and then destroy the component later. In these cases, you should remember to unsubscribe the subscription manually.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="536ee7b8ae92c527384d1572270e55ace22c2cdd" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;actions&lt;/strong&gt;, the possible ways the state could change in reaction to user inputs from the &lt;strong&gt;view&lt;/strong&gt;.</source>
          <target state="translated">状态&lt;strong&gt;视图&lt;/strong&gt;响应用户输入的&lt;strong&gt;动作&lt;/strong&gt;，状态可能改变的&lt;strong&gt;方式&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="44d7e5a292944a9b8f0f212a5769200231c994ce" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;state&lt;/strong&gt;, the source of truth that drives our app;</source>
          <target state="translated">的&lt;strong&gt;状态&lt;/strong&gt;，真理，推动我们的应用程序的来源;</target>
        </trans-unit>
        <trans-unit id="c7a29052af8d9c9885446ea356702c7246ba9728" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;view&lt;/strong&gt;, a declarative mapping of the &lt;strong&gt;state&lt;/strong&gt;;</source>
          <target state="translated">的&lt;strong&gt;视图&lt;/strong&gt;，所述的声明性映射&lt;strong&gt;状态&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="6efff60c6e384f46bfee8d934ae7afa0e3123d5a" translate="yes" xml:space="preserve">
          <source>The Simplest Store</source>
          <target state="translated">最简单的商店</target>
        </trans-unit>
        <trans-unit id="65dc52e6fb3379afbda779041f713e48286fc0aa" translate="yes" xml:space="preserve">
          <source>The data you store in Vuex follows the same rules as the &lt;code&gt;data&lt;/code&gt; in a Vue instance, ie the state object must be plain. &lt;strong&gt;See also:&lt;/strong&gt;&lt;a href=&quot;https://v3.vuejs.org/api/options-data.html#data-2&quot;&gt;Vue#data&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bad57ff3f59fd1cdbd6a9c2eb4f3c380f8789e16" translate="yes" xml:space="preserve">
          <source>The data you store in Vuex follows the same rules as the &lt;code&gt;data&lt;/code&gt; in a Vue instance, ie the state object must be plain. &lt;strong&gt;See also:&lt;/strong&gt;&lt;a href=&quot;https://vuejs.org/v2/api/#data&quot;&gt;Vue#data&lt;/a&gt;.</source>
          <target state="translated">您存储在Vuex中的数据遵循与Vue实例中的 &lt;code&gt;data&lt;/code&gt; 相同的规则，即状态对象必须是纯文本。&lt;strong&gt;另请参阅：&lt;/strong&gt;&lt;a href=&quot;https://vuejs.org/v2/api/#data&quot;&gt;Vue＃data&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2b279e03c4074677e1ff56b9ff66e460fb14fa89" translate="yes" xml:space="preserve">
          <source>The first argument can optionally be a namespace string. &lt;a href=&quot;../guide/modules#binding-helpers-with-namespace&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">第一个参数可以选择是名称空间字符串。&lt;a href=&quot;../guide/modules#binding-helpers-with-namespace&quot;&gt;细节&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3bcb1f41246213850c11b36c10d1fea79e5d77bc" translate="yes" xml:space="preserve">
          <source>The first thing to know is that &lt;code&gt;store.dispatch&lt;/code&gt; can handle Promise returned by the triggered action handler and it also returns Promise:</source>
          <target state="translated">首先要知道的是 &lt;code&gt;store.dispatch&lt;/code&gt; 可以处理由触发的操作处理程序返回的Promise，并且还返回Promise：</target>
        </trans-unit>
        <trans-unit id="dcebb29ecfe7deb0999fa8e584b599cd2758454e" translate="yes" xml:space="preserve">
          <source>The following bundles are generated to align with Vue 3 bundles:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33d9183239b6fa2ab9370efe48b42def65630f59" translate="yes" xml:space="preserve">
          <source>The getters will be exposed on the &lt;code&gt;store.getters&lt;/code&gt; object, and you access values as properties:</source>
          <target state="translated">吸气剂将显示在 &lt;code&gt;store.getters&lt;/code&gt; 对象上，您可以将值作为属性访问：</target>
        </trans-unit>
        <trans-unit id="188d06901f5c54b49ca05463c758d45fe516d6f3" translate="yes" xml:space="preserve">
          <source>The logger file can also be included directly via a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag, and will expose the &lt;code&gt;createVuexLogger&lt;/code&gt; function globally.</source>
          <target state="translated">记录器文件也可以直接通过 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 标记包括在内，并将在全局范围内公开 &lt;code&gt;createVuexLogger&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="7f53ab8729ac1f593a9e9d471a3a3f15e2c84ca7" translate="yes" xml:space="preserve">
          <source>The main parts we want to unit test in Vuex are mutations and actions.</source>
          <target state="translated">我们要在Vuex中进行单元测试的主要部分是突变和动作。</target>
        </trans-unit>
        <trans-unit id="5f7f524307005481f2e4aca2c93d29527f99f1e2" translate="yes" xml:space="preserve">
          <source>The module's state will be exposed as &lt;code&gt;store.state.myModule&lt;/code&gt; and &lt;code&gt;store.state.nested.myModule&lt;/code&gt;.</source>
          <target state="translated">模块的状态将显示为 &lt;code&gt;store.state.myModule&lt;/code&gt; 和 &lt;code&gt;store.state.nested.myModule&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fbed472d8720aba4f0e28e8c80ccedb98ce30b99" translate="yes" xml:space="preserve">
          <source>The only way to actually change state in a Vuex store is by committing a mutation. Vuex mutations are very similar to events: each mutation has a string &lt;strong&gt;type&lt;/strong&gt; and a &lt;strong&gt;handler&lt;/strong&gt;. The handler function is where we perform actual state modifications, and it will receive the state as the first argument:</source>
          <target state="translated">实际更改Vuex存储中状态的唯一方法是提交一个突变。Vuex变异与事件非常相似：每个变异都有一个字符串&lt;strong&gt;类型&lt;/strong&gt;和一个&lt;strong&gt;handler&lt;/strong&gt;。处理函数是我们执行实际状态修改的地方，它将接收状态作为第一个参数：</target>
        </trans-unit>
        <trans-unit id="a6a0b4e8e1721ea8c21549fafae87877e2734097" translate="yes" xml:space="preserve">
          <source>The only way to mutate the state is by committing &lt;strong&gt;mutations&lt;/strong&gt;, which are synchronous transactions.</source>
          <target state="translated">改变状态的唯一方法是提交&lt;strong&gt;突变&lt;/strong&gt;，这是同步事务。</target>
        </trans-unit>
        <trans-unit id="46e235aa33469d6967a6809446c33b1593819a40" translate="yes" xml:space="preserve">
          <source>The plugin will be used by default. For production, you will need &lt;a href=&quot;https://webpack.js.org/plugins/define-plugin/&quot;&gt;DefinePlugin&lt;/a&gt; for webpack or &lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;envify&lt;/a&gt; for Browserify to convert the value of &lt;code&gt;process.env.NODE_ENV !== 'production'&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt; for the final build.</source>
          <target state="translated">该插件将默认使用。对于生产，您将需要&lt;a href=&quot;https://webpack.js.org/plugins/define-plugin/&quot;&gt;Webpack&lt;/a&gt;的DefinePlugin或&lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;Browserify&lt;/a&gt;的envify才能将 &lt;code&gt;process.env.NODE_ENV !== 'production'&lt;/code&gt; 的值转换为 &lt;code&gt;false&lt;/code&gt; 以进行最终构建。</target>
        </trans-unit>
        <trans-unit id="f01042e3fecd699c90149ef1ee5ae1c35a436639" translate="yes" xml:space="preserve">
          <source>The root state object for the Vuex store. &lt;a href=&quot;../guide/state&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">Vuex存储的根状态对象。&lt;a href=&quot;../guide/state&quot;&gt;细节&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0280fc5ea89ec8da31027d69c613be9a3c9680dc" translate="yes" xml:space="preserve">
          <source>The root state. Read only.</source>
          <target state="translated">根状态。只读。</target>
        </trans-unit>
        <trans-unit id="2c3de3def96fcc05fedc5eb419a984266aa2428b" translate="yes" xml:space="preserve">
          <source>The second object argument's members can be a function. &lt;code&gt;function(commit: function, ...args: any[])&lt;/code&gt;</source>
          <target state="translated">第二个对象参数的成员可以是一个函数。 &lt;code&gt;function(commit: function, ...args: any[])&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="26cd7f1bcabc21254ac5b9199d279b0ef8555a89" translate="yes" xml:space="preserve">
          <source>The second object argument's members can be a function. &lt;code&gt;function(dispatch: function, ...args: any[])&lt;/code&gt;</source>
          <target state="translated">第二个对象参数的成员可以是一个函数。 &lt;code&gt;function(dispatch: function, ...args: any[])&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7fdcb9da7768a075ddd1fe33f0287a0514029824" translate="yes" xml:space="preserve">
          <source>The second object argument's members can be a function. &lt;code&gt;function(state: any)&lt;/code&gt;</source>
          <target state="translated">第二个对象参数的成员可以是一个函数。 &lt;code&gt;function(state: any)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="038cb5b264feb5642de1de9d5ce3def91138027b" translate="yes" xml:space="preserve">
          <source>The single state tree does not conflict with modularity - in later chapters we will discuss how to split your state and mutations into sub modules.</source>
          <target state="translated">单一状态树与模块化并不冲突--在后面的章节中,我们将讨论如何将你的状态和突变分成子模块。</target>
        </trans-unit>
        <trans-unit id="b7e90dfde3eb455667e93149720981dac77b8e85" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;window.Promise&lt;/code&gt; will be available automatically.</source>
          <target state="translated">然后 &lt;code&gt;window.Promise&lt;/code&gt; 将自动可用。</target>
        </trans-unit>
        <trans-unit id="3b8439ab3ba17300e601fb8e0cd832d27c3875b1" translate="yes" xml:space="preserve">
          <source>Then, pass the defined key as the second argument for the &lt;code&gt;app.use&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2304d640a16ae9bfebc931161006126d186e787e" translate="yes" xml:space="preserve">
          <source>Then:</source>
          <target state="translated">Then:</target>
        </trans-unit>
        <trans-unit id="66d594b0f1f59f13c4f1fb32be8056b70d5a1027" translate="yes" xml:space="preserve">
          <source>This is a simple representation of the concept of &quot;one-way data flow&quot;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5b6185e9c9c13a311c71ea345f0a1bcffe543f2" translate="yes" xml:space="preserve">
          <source>This is actually the exact same problem with &lt;code&gt;data&lt;/code&gt; inside Vue components. So the solution is also the same - use a function for declaring module state (supported in 2.3.0+):</source>
          <target state="translated">对于Vue组件内部的 &lt;code&gt;data&lt;/code&gt; 这实际上是完全相同的问题。因此解决方案也是相同的-使用声明模块状态的函数（在2.3.0+中受支持）：</target>
        </trans-unit>
        <trans-unit id="32e874b1aade463ecb43dfd8a24212e0197c777b" translate="yes" xml:space="preserve">
          <source>This is an simple representation of the concept of &quot;one-way data flow&quot;:</source>
          <target state="translated">这是对 &quot;单向数据流 &quot;概念的简单表述。</target>
        </trans-unit>
        <trans-unit id="4784799e1632043ab612568498af4698285efa24" translate="yes" xml:space="preserve">
          <source>This is the basic idea behind Vuex, inspired by &lt;a href=&quot;https://facebook.github.io/flux/docs/overview&quot;&gt;Flux&lt;/a&gt;, &lt;a href=&quot;http://redux.js.org/&quot;&gt;Redux&lt;/a&gt; and &lt;a href=&quot;https://guide.elm-lang.org/architecture/&quot;&gt;The Elm Architecture&lt;/a&gt;. Unlike the other patterns, Vuex is also a library implementation tailored specifically for Vue.js to take advantage of its granular reactivity system for efficient updates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4ae803eb94d79146b96a33ead3a2a7574ab90f7" translate="yes" xml:space="preserve">
          <source>This is the basic idea behind Vuex, inspired by &lt;a href=&quot;https://facebook.github.io/flux/docs/overview.html&quot;&gt;Flux&lt;/a&gt;, &lt;a href=&quot;http://redux.js.org/&quot;&gt;Redux&lt;/a&gt; and &lt;a href=&quot;https://guide.elm-lang.org/architecture/&quot;&gt;The Elm Architecture&lt;/a&gt;. Unlike the other patterns, Vuex is also a library implementation tailored specifically for Vue.js to take advantage of its granular reactivity system for efficient updates.</source>
          <target state="translated">这是Vuex背后的基本思想，灵感来自&lt;a href=&quot;https://facebook.github.io/flux/docs/overview.html&quot;&gt;Flux&lt;/a&gt;，&lt;a href=&quot;http://redux.js.org/&quot;&gt;Redux&lt;/a&gt;和&lt;a href=&quot;https://guide.elm-lang.org/architecture/&quot;&gt;The Elm Architecture&lt;/a&gt;。与其他模式不同，Vuex还是专门为Vue.js量身定制的库实现，以利用其细粒度的反应性系统进行高效更新。</target>
        </trans-unit>
        <trans-unit id="01d82844153a1e06b9ed0ac7a7deee86d8194f29" translate="yes" xml:space="preserve">
          <source>This is the docs for Vuex 4, which works with Vue 3. If you're looking for docs for Vuex 3, which works with Vue 2, &lt;a href=&quot;https://vuex.vuejs.org/&quot;&gt;please check it out here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6765e94633afe8dfabe4c196fd106659f3711625" translate="yes" xml:space="preserve">
          <source>This may look silly at first sight: if we want to increment the count, why don't we just call &lt;code&gt;store.commit('increment')&lt;/code&gt; directly? Remember that &lt;strong&gt;mutations have to be synchronous&lt;/strong&gt;. Actions don't. We can perform &lt;strong&gt;asynchronous&lt;/strong&gt; operations inside an action:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ac43b405b6b649d36442b0894b012509c8256f1" translate="yes" xml:space="preserve">
          <source>This may look silly at first sight: if we want to increment the count, why don't we just call &lt;code&gt;store.commit('increment')&lt;/code&gt; directly? Remember that &lt;strong&gt;mutations have to be synchronous&lt;/strong&gt;? Actions don't. We can perform &lt;strong&gt;asynchronous&lt;/strong&gt; operations inside an action:</source>
          <target state="translated">乍一看，这可能看起来很愚蠢：如果我们想增加计数，为什么不直接调用 &lt;code&gt;store.commit('increment')&lt;/code&gt; ？还记得&lt;strong&gt;突变必须是同步的&lt;/strong&gt;吗？动作不行。我们可以在一个动作中执行&lt;strong&gt;异步&lt;/strong&gt;操作：</target>
        </trans-unit>
        <trans-unit id="0e6ac10721f7dad6b0d54424ccab8e328eca8722" translate="yes" xml:space="preserve">
          <source>To access the store within the &lt;code&gt;setup&lt;/code&gt; hook, you can call the &lt;code&gt;useStore&lt;/code&gt; function. This is the equivalent of retrieving &lt;code&gt;this.$store&lt;/code&gt; within a component using the Option API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cdbc54a1defb978e6cf0175dfb530c6313ce51a" translate="yes" xml:space="preserve">
          <source>To align with the new Vue 3 initialization process, the installation process of Vuex has changed. To create a new store, users are now encouraged to use the newly introduced createStore function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fad06b8194c84f29399e28d3869f1cd5156e9bf" translate="yes" xml:space="preserve">
          <source>To dispatch actions or commit mutations in the global namespace, pass &lt;code&gt;{ root: true }&lt;/code&gt; as the 3rd argument to &lt;code&gt;dispatch&lt;/code&gt; and &lt;code&gt;commit&lt;/code&gt;.</source>
          <target state="translated">要在全局名称空间中分派动作或提交突变，请将 &lt;code&gt;{ root: true }&lt;/code&gt; 作为第三个参数传递给 &lt;code&gt;dispatch&lt;/code&gt; 和 &lt;code&gt;commit&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8c0e5afb99acb54f27fa2c4dc5de58b64ac70359" translate="yes" xml:space="preserve">
          <source>To do so, declare custom typings for Vue's &lt;code&gt;ComponentCustomProperties&lt;/code&gt; by adding a declaration file in your project folder:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9a17f7fd54b6a036cf2a11b136e992ee23b897e" translate="yes" xml:space="preserve">
          <source>To enable strict mode, simply pass in &lt;code&gt;strict: true&lt;/code&gt; when creating a Vuex store:</source>
          <target state="translated">要启用严格模式，只需在创建Vuex存储时传入 &lt;code&gt;strict: true&lt;/code&gt; 即可：</target>
        </trans-unit>
        <trans-unit id="b4555cdaed64feb01f23395f68a87fbe45b67dce" translate="yes" xml:space="preserve">
          <source>To handle asynchronous operations, let's introduce &lt;a href=&quot;actions&quot;&gt;Actions&lt;/a&gt;.</source>
          <target state="translated">为了处理异步操作，让我们介绍&lt;a href=&quot;actions&quot;&gt;Actions&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4195b1d72692d3750d2a410e7d9981a761f2d655" translate="yes" xml:space="preserve">
          <source>To help with that, Vuex allows us to divide our store into &lt;strong&gt;modules&lt;/strong&gt;. Each module can contain its own state, mutations, actions, getters, and even nested modules - it's fractal all the way down:</source>
          <target state="translated">为了解决这个问题，Vuex允许我们将商店划分为&lt;strong&gt;模块&lt;/strong&gt;。每个模块都可以包含其自己的状态，变异，动作，获取器，甚至是嵌套模块-一直到整个过程都是分形的：</target>
        </trans-unit>
        <trans-unit id="69ba8fbdd0f126138d738eba7ba3e25ab721058c" translate="yes" xml:space="preserve">
          <source>To install Vuex to a Vue instance, pass the &lt;code&gt;store&lt;/code&gt; instead of Vuex.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47c12dedfc5d2ae19c1382030d2827746c9b159b" translate="yes" xml:space="preserve">
          <source>To stop subscribing, call the returned unsubscribe function.</source>
          <target state="translated">要停止订阅,调用返回的退订函数。</target>
        </trans-unit>
        <trans-unit id="b38919feb133ed92197ba6b4d1ca2851ce856830" translate="yes" xml:space="preserve">
          <source>To stop watching, call the returned unwatch function.</source>
          <target state="translated">要停止观看,调用返回的unwatch函数。</target>
        </trans-unit>
        <trans-unit id="d01a4f9ab1ff7fae7cb3dedf5ed58a422558aa71" translate="yes" xml:space="preserve">
          <source>Try this lesson on Scrimba</source>
          <target state="translated">试试这个关于Scrimba的课程</target>
        </trans-unit>
        <trans-unit id="812241cb367543e758bb2d6b8d6eb7df0bca334e" translate="yes" xml:space="preserve">
          <source>Turn the devtools on or off for a particular Vuex instance. For instance, passing &lt;code&gt;false&lt;/code&gt; tells the Vuex store to not subscribe to devtools plugin. Useful when you have multiple stores on a single page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb9df75c2e4aa99920a38d6895f257e82c103c0e" translate="yes" xml:space="preserve">
          <source>Turn the devtools on or off for a particular vuex instance. For instance passing false tells the Vuex store to not subscribe to devtools plugin. Useful for if you have multiple stores on a single page.</source>
          <target state="translated">开启或关闭特定vuex实例的devtools。例如,通过false告诉Vuex商店不订阅devtools插件。如果您在一个页面上有多个商店,这很有用。</target>
        </trans-unit>
        <trans-unit id="6d53cb5abedd0ebe3cd4c7395842755f71c30dbc" translate="yes" xml:space="preserve">
          <source>Two-way Computed Property</source>
          <target state="translated">双向计算属性</target>
        </trans-unit>
        <trans-unit id="aec373f2c6104f4e0717f76308cbda4cbd9ffa55" translate="yes" xml:space="preserve">
          <source>TypeScript Support</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdea23efbec9c8bf6ee85ec63b78ab2e12f528cd" translate="yes" xml:space="preserve">
          <source>TypeScript support</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50d095b72c23ae6ff8f64d6304776100771251da" translate="yes" xml:space="preserve">
          <source>TypeScript users can use an injection key to retrieve a typed store. In order for this to work, you must define the injection key and pass it along with the store when installing the store instance to the Vue app.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a035bd5d610b0e0f578980487f3e136c53e9a2df" translate="yes" xml:space="preserve">
          <source>Typing &lt;code&gt;$store&lt;/code&gt; Property in Vue Component</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f301538ed68fe96d60ca381f974527cc0892825" translate="yes" xml:space="preserve">
          <source>Typing &lt;code&gt;useStore&lt;/code&gt; Composition Function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88625f6fb2e47a984fc469839b246cc1bbd39a3d" translate="yes" xml:space="preserve">
          <source>Under the hood, Vuex installs the store to the Vue app using Vue's &lt;a href=&quot;https://v3.vuejs.org/api/composition-api.html#provide-inject&quot;&gt;Provide/Inject&lt;/a&gt; feature which is why the injection key is an important factor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58a34f2bdebff21a52c61f411732c8009ceffd74" translate="yes" xml:space="preserve">
          <source>Unregister a dynamic module. &lt;a href=&quot;../guide/modules#dynamic-module-registration&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">注销动态模块。&lt;a href=&quot;../guide/modules#dynamic-module-registration&quot;&gt;细节&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0e189823fb0c39c232d21cb4f56d5d5263ffa4a9" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;Vue.set(obj, 'newProp', 123)&lt;/code&gt;, or</source>
          <target state="translated">使用 &lt;code&gt;Vue.set(obj, 'newProp', 123)&lt;/code&gt; 或</target>
        </trans-unit>
        <trans-unit id="b49c80c66c6311a904333a467355c7e6bf1e59e1" translate="yes" xml:space="preserve">
          <source>Using Constants for Mutation Types</source>
          <target state="translated">使用突变类型的常量</target>
        </trans-unit>
        <trans-unit id="2a3ef6422ba574dc83a7da5c0294678dde94d811" translate="yes" xml:space="preserve">
          <source>Using Vuex doesn't mean you should put &lt;strong&gt;all&lt;/strong&gt; the state in Vuex. Although putting more state into Vuex makes your state mutations more explicit and debuggable, sometimes it could also make the code more verbose and indirect. If a piece of state strictly belongs to a single component, it could be just fine leaving it as local state. You should weigh the trade-offs and make decisions that fit the development needs of your app.</source>
          <target state="translated">使用Vuex并不意味着您应该将&lt;strong&gt;所有&lt;/strong&gt;状态都放入Vuex。尽管将更多状态添加到Vuex中可以使您的状态突变更明确和可调试，但有时也可以使代码更冗长和间接。如果一个状态严格地属于单个组件，那么将其保留为本地状态就可以了。您应该权衡取舍，并做出适合您应用程序开发需求的决策。</target>
        </trans-unit>
        <trans-unit id="0c1ee6f0263ee019fc5e3fcd7fa266eb225b6cc7" translate="yes" xml:space="preserve">
          <source>Using store state in a component simply involves returning the state within a computed property, because the store state is reactive. Triggering changes simply means committing mutations in component methods.</source>
          <target state="translated">在组件中使用存储状态只是涉及返回计算属性中的状态,因为存储状态是被动的。触发变化只是意味着在组件方法中提交突变。</target>
        </trans-unit>
        <trans-unit id="de0b33121be26507e3433bd94203e17aa9b5f222" translate="yes" xml:space="preserve">
          <source>Vuex</source>
          <target state="translated">Vuex</target>
        </trans-unit>
        <trans-unit id="03cbaaf12cf9de839a6ef24add75f70804c3bd36" translate="yes" xml:space="preserve">
          <source>Vuex &quot;injects&quot; the store into all child components from the root component through Vue's plugin system, and will be available on them as &lt;code&gt;this.$store&lt;/code&gt;. Let's update our &lt;code&gt;Counter&lt;/code&gt; implementation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b8cd4f61d900f72acb2af9c3655c9d0d3121feb" translate="yes" xml:space="preserve">
          <source>Vuex 4 introduces a new API to interact with the store in Composition API. You can use the &lt;code&gt;useStore&lt;/code&gt; composition function to retrieve the store within the component &lt;code&gt;setup&lt;/code&gt; hook.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa60c01f6f8d53bbb571c7cc4c0e43d605867024" translate="yes" xml:space="preserve">
          <source>Vuex 4 removes its global typings for &lt;code&gt;this.$store&lt;/code&gt; within a Vue component to solve &lt;a href=&quot;https://github.com/vuejs/vuex/issues/994&quot;&gt;issue #994&lt;/a&gt;. When used with TypeScript, you must declare your own module augmentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5043b9867f4c1f3c2a241e7e15f0309bf2b67e5" translate="yes" xml:space="preserve">
          <source>Vuex allows us to define &quot;getters&quot; in the store. You can think of them as computed properties for stores.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0d6f301a857638a6008e626f1c08e4b841279dd" translate="yes" xml:space="preserve">
          <source>Vuex allows us to define &quot;getters&quot; in the store. You can think of them as computed properties for stores. Like computed properties, a getter's result is cached based on its dependencies, and will only re-evaluate when some of its dependencies have changed.</source>
          <target state="translated">Vuex允许我们在商店中定义 &quot;getter&quot;。你可以把它们看作是存储的计算属性。和计算属性一样,getter的结果也是基于它的依赖关系进行缓存的,只有当它的一些依赖关系发生变化时才会重新评估。</target>
        </trans-unit>
        <trans-unit id="0e2cd15820316b9d525f31489d6930bdf8394d91" translate="yes" xml:space="preserve">
          <source>Vuex comes with a logger plugin for common debugging usage:</source>
          <target state="translated">Vuex自带了一个记录器插件,用于常见的调试用途。</target>
        </trans-unit>
        <trans-unit id="7a50b771f48dfa484820de4fbf6edb422dbc1306" translate="yes" xml:space="preserve">
          <source>Vuex doesn't provide typings for &lt;code&gt;this.$store&lt;/code&gt; property out of the box. When used with TypeScript, you must declare your own module augmentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97c7149a09097949a0cfcc2fbe94537dc69fb1ce" translate="yes" xml:space="preserve">
          <source>Vuex doesn't really restrict how you structure your code. Rather, it enforces a set of high-level principles:</source>
          <target state="translated">Vuex并没有真正限制你如何构建你的代码。相反,它实施了一系列高级原则。</target>
        </trans-unit>
        <trans-unit id="d17df34d062fc479eb107a94c88abf9ec059beae" translate="yes" xml:space="preserve">
          <source>Vuex helps us deal with shared state management with the cost of more concepts and boilerplate. It's a trade-off between short term and long term productivity.</source>
          <target state="translated">Vuex帮助我们以更多的概念和模板为代价来处理共享状态管理。这是一个短期和长期生产力之间的权衡。</target>
        </trans-unit>
        <trans-unit id="685c1dd978a181fa797afacac4d6f9601b7d5fda" translate="yes" xml:space="preserve">
          <source>Vuex is a &lt;strong&gt;state management pattern + library&lt;/strong&gt; for Vue.js applications. It serves as a centralized store for all the components in an application, with rules ensuring that the state can only be mutated in a predictable fashion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4865c12b8c32edd994472010e09de64c7196db52" translate="yes" xml:space="preserve">
          <source>Vuex is a &lt;strong&gt;state management pattern + library&lt;/strong&gt; for Vue.js applications. It serves as a centralized store for all the components in an application, with rules ensuring that the state can only be mutated in a predictable fashion. It also integrates with Vue's official &lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;devtools extension&lt;/a&gt; to provide advanced features such as zero-config time-travel debugging and state snapshot export / import.</source>
          <target state="translated">Vuex是Vue.js应用程序的&lt;strong&gt;状态管理模式+库&lt;/strong&gt;。它充当应用程序中所有组件的集中存储，其规则确保状态只能以可预测的方式进行更改。它还与Vue的官方&lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;devtools扩展&lt;/a&gt;集成，以提供高级功能，例如零配置时间旅行调试和状态快照导出/导入。</target>
        </trans-unit>
        <trans-unit id="0ab5b1ceae85cef3c7070700973eed24ddceb3f1" translate="yes" xml:space="preserve">
          <source>Vuex provides a mechanism to &quot;inject&quot; the store into all child components from the root component with the &lt;code&gt;store&lt;/code&gt; option (enabled by &lt;code&gt;Vue.use(Vuex)&lt;/code&gt;):</source>
          <target state="translated">Vuex提供了一种使用 &lt;code&gt;store&lt;/code&gt; 选项（由 &lt;code&gt;Vue.use(Vuex)&lt;/code&gt; 启用）将存储从根组件&amp;ldquo;注入&amp;rdquo;到所有子组件的机制：</target>
        </trans-unit>
        <trans-unit id="13c8b9558d25a74364d073902412ab0e29b9c7d8" translate="yes" xml:space="preserve">
          <source>Vuex provides its typings so you can use TypeScript to write a store definition. You don't need any special TypeScript configuration for Vuex. Please follow &lt;a href=&quot;https://v3.vuejs.org/guide/typescript-support.html&quot;&gt;Vue's basic TypeScript setup&lt;/a&gt; to configure your project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29e6083d0ea2da692697abc408390a78b3fbb6a1" translate="yes" xml:space="preserve">
          <source>Vuex requires &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises&quot;&gt;Promise&lt;/a&gt;. If your supporting browsers do not implement Promise (e.g. IE), you can use a polyfill library, such as &lt;a href=&quot;https://github.com/stefanpenner/es6-promise&quot;&gt;es6-promise&lt;/a&gt;.</source>
          <target state="translated">Vuex需要&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises&quot;&gt;Promise&lt;/a&gt;。如果支持的浏览器未实现Promise（例如IE），则可以使用&lt;a href=&quot;https://github.com/stefanpenner/es6-promise&quot;&gt;polyfill&lt;/a&gt;库，例如es6-promise。</target>
        </trans-unit>
        <trans-unit id="a7c44a44a893f704da779f2a6753cb99fdabc86c" translate="yes" xml:space="preserve">
          <source>Vuex stores accept the &lt;code&gt;plugins&lt;/code&gt; option that exposes hooks for each mutation. A Vuex plugin is simply a function that receives the store as the only argument:</source>
          <target state="translated">Vuex商店接受 &lt;code&gt;plugins&lt;/code&gt; 选项，该选项公开每个突变的钩子。Vuex插件只是一个将商店作为唯一参数的函数：</target>
        </trans-unit>
        <trans-unit id="f9de6b1a8f9893aec2c24f2eb638d08f8c27963a" translate="yes" xml:space="preserve">
          <source>Vuex stores are reactive. When Vue components retrieve state from it, they will reactively and efficiently update if the store's state changes.</source>
          <target state="translated">Vuex存储是反应式的。当Vue组件从它那里检索状态时,如果商店的状态发生变化,它们将反应性地高效更新。</target>
        </trans-unit>
        <trans-unit id="d1005b8dfed9f5da523d44fa0408fb96e863b48e" translate="yes" xml:space="preserve">
          <source>Vuex supports hot-reloading mutations, modules, actions and getters during development, using webpack's &lt;a href=&quot;https://webpack.js.org/guides/hot-module-replacement/&quot;&gt;Hot Module Replacement API&lt;/a&gt;. You can also use it in Browserify with the &lt;a href=&quot;https://github.com/AgentME/browserify-hmr/&quot;&gt;browserify-hmr&lt;/a&gt; plugin.</source>
          <target state="translated">Vuex使用webpack的&lt;a href=&quot;https://webpack.js.org/guides/hot-module-replacement/&quot;&gt;Hot Module Replacement API&lt;/a&gt;支持在开发过程中热重载突变，模块，操作和获取方法。您也可以通过browserify &lt;a href=&quot;https://github.com/AgentME/browserify-hmr/&quot;&gt;-hmr&lt;/a&gt;插件在Browserify中使用它。</target>
        </trans-unit>
        <trans-unit id="1c91ec10df2bcecd2b18c0eb4c34783559fcaf6b" translate="yes" xml:space="preserve">
          <source>Vuex uses a &lt;strong&gt;single state tree&lt;/strong&gt; - that is, this single object contains all your application level state and serves as the &quot;single source of truth&quot;. This also means usually you will have only one store for each application. A single state tree makes it straightforward to locate a specific piece of state, and allows us to easily take snapshots of the current app state for debugging purposes.</source>
          <target state="translated">Vuex使用&lt;strong&gt;单个状态树&lt;/strong&gt; -即，该单个对象包含您所有应用程序级别的状态，并充当&amp;ldquo;真理的单一来源&amp;rdquo;。这也意味着通常每个应用程序只有一个商店。单个状态树使查找特定状态变得简单明了，并允许我们轻松地为调试目的获取当前应用程序状态的快照。</target>
        </trans-unit>
        <trans-unit id="38d7ee9ea99de16acff8c72ca2947db3c8964cfb" translate="yes" xml:space="preserve">
          <source>Vuex uses a &lt;strong&gt;single state tree&lt;/strong&gt; - that is, this single object contains all your application level state and serves as the &quot;single source of truth.&quot; This also means usually you will have only one store for each application. A single state tree makes it straightforward to locate a specific piece of state, and allows us to easily take snapshots of the current app state for debugging purposes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daddb132dbb693223d1a8285c450a768b5e90526" translate="yes" xml:space="preserve">
          <source>Vuex.Store</source>
          <target state="translated">Vuex.Store</target>
        </trans-unit>
        <trans-unit id="e27d6d35e937e025eb96c09b1248e5c2676afd99" translate="yes" xml:space="preserve">
          <source>Vuex.Store Constructor Options</source>
          <target state="translated">Vuex.Store构造函数选项</target>
        </trans-unit>
        <trans-unit id="a12ddea81e37a47b9cf92721a2c3b3dce724518b" translate="yes" xml:space="preserve">
          <source>Vuex.Store Instance Methods</source>
          <target state="translated">Vuex.Store实例方法</target>
        </trans-unit>
        <trans-unit id="bf2e5bd997aabdf6407575808a7810ae806bc168" translate="yes" xml:space="preserve">
          <source>Vuex.Store Instance Properties</source>
          <target state="translated">Vuex.Store实例属性</target>
        </trans-unit>
        <trans-unit id="f9f831a5e0694e0c14522dd98fa88137c445d453" translate="yes" xml:space="preserve">
          <source>Vuex.Store.commit()</source>
          <target state="translated">Vuex.Store.commit()</target>
        </trans-unit>
        <trans-unit id="6525945e6ceed925f1b32505317c836dca657a7b" translate="yes" xml:space="preserve">
          <source>Vuex.Store.dispatch()</source>
          <target state="translated">Vuex.Store.dispatch()</target>
        </trans-unit>
        <trans-unit id="875eca0d2c435721934d6e21026feaf2c458121e" translate="yes" xml:space="preserve">
          <source>Vuex.Store.getters</source>
          <target state="translated">Vuex.Store.getters</target>
        </trans-unit>
        <trans-unit id="36f6be1d986b4f405099f5f30b602d52e9e30867" translate="yes" xml:space="preserve">
          <source>Vuex.Store.hotUpdate()</source>
          <target state="translated">Vuex.Store.hotUpdate()</target>
        </trans-unit>
        <trans-unit id="da4335e82262f6f8d6790534c7ad0926cc4745e2" translate="yes" xml:space="preserve">
          <source>Vuex.Store.registerModule()</source>
          <target state="translated">Vuex.Store.registerModule()</target>
        </trans-unit>
        <trans-unit id="94ac4b985f66595cf0a6092e1a82c5ad38bbb16b" translate="yes" xml:space="preserve">
          <source>Vuex.Store.replaceState()</source>
          <target state="translated">Vuex.Store.replaceState()</target>
        </trans-unit>
        <trans-unit id="4f304b4fdb3bf5548021e12438f19b8a3c837429" translate="yes" xml:space="preserve">
          <source>Vuex.Store.state</source>
          <target state="translated">Vuex.Store.state</target>
        </trans-unit>
        <trans-unit id="646d93a6768d3e6602cdefd17248482210916c01" translate="yes" xml:space="preserve">
          <source>Vuex.Store.subscribe()</source>
          <target state="translated">Vuex.Store.subscribe()</target>
        </trans-unit>
        <trans-unit id="f3e660b4b4bcbf28c208b2cb1849c08db1e4a864" translate="yes" xml:space="preserve">
          <source>Vuex.Store.subscribeAction()</source>
          <target state="translated">Vuex.Store.subscribeAction()</target>
        </trans-unit>
        <trans-unit id="ae9d201aeec49d5494691627724de63760974852" translate="yes" xml:space="preserve">
          <source>Vuex.Store.unregisterModule()</source>
          <target state="translated">Vuex.Store.unregisterModule()</target>
        </trans-unit>
        <trans-unit id="a78a21d356c3413617b93e60de03e3c4c85613bf" translate="yes" xml:space="preserve">
          <source>Vuex.Store.watch()</source>
          <target state="translated">Vuex.Store.watch()</target>
        </trans-unit>
        <trans-unit id="fd3edc641024a335a508fdacefb5f51ded5905cc" translate="yes" xml:space="preserve">
          <source>WARNING</source>
          <target state="translated">WARNING</target>
        </trans-unit>
        <trans-unit id="972f097fe8de7d9024e0cac7324df8bc2bd5d8a7" translate="yes" xml:space="preserve">
          <source>We can also pass a string array to &lt;code&gt;mapState&lt;/code&gt; when the name of a mapped computed property is the same as a state sub tree name.</source>
          <target state="translated">当映射的计算属性的名称与状态子树名称相同时，我们还可以将字符串数组传递给 &lt;code&gt;mapState&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="62a0d6990ce81e2c8fb572ac1e1a0f61bc100c86" translate="yes" xml:space="preserve">
          <source>We can now easily make use of it inside any component:</source>
          <target state="translated">现在,我们可以轻松地在任何组件内使用它。</target>
        </trans-unit>
        <trans-unit id="8745c67924f31017daab7ed40bb8f21170388cd9" translate="yes" xml:space="preserve">
          <source>We will be using ES2015 syntax for code examples for the rest of the docs. If you haven't picked it up, &lt;a href=&quot;https://babeljs.io/docs/learn-es2015/&quot;&gt;you should&lt;/a&gt;!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e679c86924ed36ac40c73653131acb30c335823" translate="yes" xml:space="preserve">
          <source>What is Vuex?</source>
          <target state="translated">什么是Vuex?</target>
        </trans-unit>
        <trans-unit id="4f7cb23fbc792a907900b6c227a08a9ce44bbb08" translate="yes" xml:space="preserve">
          <source>What is a &quot;State Management Pattern&quot;?</source>
          <target state="translated">什么是 &quot;国家管理模式&quot;?</target>
        </trans-unit>
        <trans-unit id="bfb57f97eebc790fb0f996df58cf05c904d765fe" translate="yes" xml:space="preserve">
          <source>When Should I Use It?</source>
          <target state="translated">什么时候应该使用?</target>
        </trans-unit>
        <trans-unit id="7049f8d400f975057b510f35754e4b4a55b8a447" translate="yes" xml:space="preserve">
          <source>When a component needs to make use of multiple store state properties or getters, declaring all these computed properties can get repetitive and verbose. To deal with this we can make use of the &lt;code&gt;mapState&lt;/code&gt; helper which generates computed getter functions for us, saving us some keystrokes:</source>
          <target state="translated">当组件需要使用多个存储状态属性或getter时，声明所有这些计算的属性会变得重复和冗长。为了解决这个问题，我们可以使用 &lt;code&gt;mapState&lt;/code&gt; 帮助器，该帮助器为我们生成计算的getter函数，从而节省了一些击键：</target>
        </trans-unit>
        <trans-unit id="b0e91b1a6d070c61fac000b9d3b95342ccf2db46" translate="yes" xml:space="preserve">
          <source>When accessing mutations and actions, you can simply provide the &lt;code&gt;commit&lt;/code&gt; and &lt;code&gt;dispatch&lt;/code&gt; function inside the &lt;code&gt;setup&lt;/code&gt; hook.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c17e29a6e47a7d53eb7540fe5f43fd3c7ec25ef4" translate="yes" xml:space="preserve">
          <source>When adding new properties to an Object, you should either:</source>
          <target state="translated">当向对象添加新的属性时,你应该或者。</target>
        </trans-unit>
        <trans-unit id="efff342070587a8120ff0a0f2a1a6c593581e9da" translate="yes" xml:space="preserve">
          <source>When binding a namespaced module to components with the &lt;code&gt;mapState&lt;/code&gt;, &lt;code&gt;mapGetters&lt;/code&gt;, &lt;code&gt;mapActions&lt;/code&gt; and &lt;code&gt;mapMutations&lt;/code&gt; helpers, it can get a bit verbose:</source>
          <target state="translated">当使用 &lt;code&gt;mapState&lt;/code&gt; ， &lt;code&gt;mapGetters&lt;/code&gt; ， &lt;code&gt;mapActions&lt;/code&gt; 和 &lt;code&gt;mapMutations&lt;/code&gt; 帮助器将命名空间模块绑定到组件时，它会变得很冗长：</target>
        </trans-unit>
        <trans-unit id="99195dc5710842be6bed30d96a1def16fb32d71c" translate="yes" xml:space="preserve">
          <source>When used with a module system, you must explicitly install Vuex via &lt;code&gt;Vue.use()&lt;/code&gt;:</source>
          <target state="translated">与模块系统一起使用时，必须通过 &lt;code&gt;Vue.use()&lt;/code&gt; 显式安装Vuex ：</target>
        </trans-unit>
        <trans-unit id="77c1ff3694c93e3a5898ebf5b137f7620c5e12dd" translate="yes" xml:space="preserve">
          <source>When using Vuex in strict mode, it could be a bit tricky to use &lt;code&gt;v-model&lt;/code&gt; on a piece of state that belongs to Vuex:</source>
          <target state="translated">在严格模式下使用Vuex时，在属于Vuex的状态下使用 &lt;code&gt;v-model&lt;/code&gt; 可能会有些棘手：</target>
        </trans-unit>
        <trans-unit id="fd5fb9660a82033a1f5e0bdd5e988d5fee11ea79" translate="yes" xml:space="preserve">
          <source>When using object-style commit, the entire object will be passed as the payload to mutation handlers, so the handler remains the same:</source>
          <target state="translated">当使用对象式提交时,整个对象将作为有效载荷传递给突变处理程序,所以处理程序保持不变。</target>
        </trans-unit>
        <trans-unit id="4c9c007e95ce7e90fdef65d514914f8a48ea50fc" translate="yes" xml:space="preserve">
          <source>When you set &lt;code&gt;preserveState: true&lt;/code&gt;, the module is registered, actions, mutations and getters are added to the store, but the state is not. It's assumed that your store state already contains state for that module and you don't want to overwrite it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64b97d35575f008d89a5abcf758506366a1df6c9" translate="yes" xml:space="preserve">
          <source>When you set &lt;code&gt;preserveState: true&lt;/code&gt;, the module is registered, actions, mutations and getters are added to the store, but the state not. It's assumed that your store state already contains state for that module and you don't want to overwrite it.</source>
          <target state="translated">当您设置 &lt;code&gt;preserveState: true&lt;/code&gt; ，将注册该模块，将操作，变异和获取方法添加到存储中，但不添加状态。假设您的存储状态已经包含该模块的状态，并且您不想覆盖它。</target>
        </trans-unit>
        <trans-unit id="b67645573519bd6745c7692e115ca001bffedc35" translate="yes" xml:space="preserve">
          <source>When you're writing your Vue component in Composition API, you will most likely want &lt;code&gt;useStore&lt;/code&gt; to return the typed store. For &lt;code&gt;useStore&lt;/code&gt; to correctly return the typed store, you must:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0672c57fbbf8e8ecf0e7b63699f5a7c92edcd4d" translate="yes" xml:space="preserve">
          <source>Whenever &lt;code&gt;store.state.count&lt;/code&gt; changes, it will cause the computed property to re-evaluate, and trigger associated DOM updates.</source>
          <target state="translated">每当 &lt;code&gt;store.state.count&lt;/code&gt; 更改时，它将导致重新计算计算的属性，并触发关联的DOM更新。</target>
        </trans-unit>
        <trans-unit id="a085ea0f1aa78bea832392da9c502369be0887a2" translate="yes" xml:space="preserve">
          <source>Whether to use constants is largely a preference - it can be helpful in large projects with many developers, but it's totally optional if you don't like them.</source>
          <target state="translated">是否使用常量很大程度上是一种偏好--在有许多开发人员的大型项目中,它可能会很有帮助,但如果你不喜欢常量,完全可以选择。</target>
        </trans-unit>
        <trans-unit id="4c08b16ee1dc63cbfb31d2273bccaca063856191" translate="yes" xml:space="preserve">
          <source>Whilst this is not technically a breaking change, you may still use the &lt;code&gt;new Store(...)&lt;/code&gt; syntax, we recommend this approach to align with Vue 3 and Vue Router Next.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4de67a4d313139fb2f1d0ad9d2c13d0921ddb131" translate="yes" xml:space="preserve">
          <source>Yarn</source>
          <target state="translated">Yarn</target>
        </trans-unit>
        <trans-unit id="63134a6d55a8d86ebefa1d7e28dd4e4938a617f5" translate="yes" xml:space="preserve">
          <source>You can also pass arguments to getters by returning a function. This is particularly useful when you want to query an array in the store:</source>
          <target state="translated">你也可以通过返回一个函数来传递参数给getter。当你想查询存储中的数组时,这一点特别有用。</target>
        </trans-unit>
        <trans-unit id="23de97b968754adb5c8071394c94800b27c8ebc7" translate="yes" xml:space="preserve">
          <source>You can also remove a dynamically registered module with &lt;code&gt;store.unregisterModule(moduleName)&lt;/code&gt;. Note you cannot remove static modules (declared at store creation) with this method.</source>
          <target state="translated">您还可以使用 &lt;code&gt;store.unregisterModule(moduleName)&lt;/code&gt; 删除动态注册的模块。请注意，您无法使用此方法删除静态模块（在商店创建时声明）。</target>
        </trans-unit>
        <trans-unit id="d29c54157aed563d47280cf164e51dba16933038" translate="yes" xml:space="preserve">
          <source>You can commit mutations in components with &lt;code&gt;this.$store.commit('xxx')&lt;/code&gt;, or use the &lt;code&gt;mapMutations&lt;/code&gt; helper which maps component methods to &lt;code&gt;store.commit&lt;/code&gt; calls (requires root &lt;code&gt;store&lt;/code&gt; injection):</source>
          <target state="translated">您可以使用 &lt;code&gt;this.$store.commit('xxx')&lt;/code&gt; 来提交组件中的突变，或者使用 &lt;code&gt;mapMutations&lt;/code&gt; 帮助器将组件方法映射到 &lt;code&gt;store.commit&lt;/code&gt; 调用（需要根 &lt;code&gt;store&lt;/code&gt; 注入）：</target>
        </trans-unit>
        <trans-unit id="1215721038a305c2ecee17f52181bc37f1909ea8" translate="yes" xml:space="preserve">
          <source>You can dispatch actions in components with &lt;code&gt;this.$store.dispatch('xxx')&lt;/code&gt;, or use the &lt;code&gt;mapActions&lt;/code&gt; helper which maps component methods to &lt;code&gt;store.dispatch&lt;/code&gt; calls (requires root &lt;code&gt;store&lt;/code&gt; injection):</source>
          <target state="translated">您可以使用 &lt;code&gt;this.$store.dispatch('xxx')&lt;/code&gt; 调度组件中的动作，或使用 &lt;code&gt;mapActions&lt;/code&gt; 帮助器将组件方法映射到 &lt;code&gt;store.dispatch&lt;/code&gt; 调用（需要进行根 &lt;code&gt;store&lt;/code&gt; 注入）：</target>
        </trans-unit>
        <trans-unit id="8881848045fd86241cc9c9d7d92edbe765adb62d" translate="yes" xml:space="preserve">
          <source>You can include it via CDN:</source>
          <target state="translated">你可以通过CDN收录。</target>
        </trans-unit>
        <trans-unit id="5ad1656a1ce03c34ec4d07184a92309aa7cbeafd" translate="yes" xml:space="preserve">
          <source>You can learn more in the &lt;a href=&quot;composition-api&quot;&gt;Composition API&lt;/a&gt; section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fc0fa46dba60197b55bd958d17dd6ccb01559a1" translate="yes" xml:space="preserve">
          <source>You can learn more in the &lt;a href=&quot;typescript-support&quot;&gt;TypeScript Support&lt;/a&gt; section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25c0fe7b987a059291687c75ef24f147484cb473" translate="yes" xml:space="preserve">
          <source>You can pass an additional argument to &lt;code&gt;store.commit&lt;/code&gt;, which is called the &lt;strong&gt;payload&lt;/strong&gt; for the mutation:</source>
          <target state="translated">您可以将另一个参数传递给 &lt;code&gt;store.commit&lt;/code&gt; ，称为变体的&lt;strong&gt;有效负载&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="3669fc0f4547fc417e6184797578f0ae3a315436" translate="yes" xml:space="preserve">
          <source>You can register a module &lt;strong&gt;after&lt;/strong&gt; the store has been created with the &lt;code&gt;store.registerModule&lt;/code&gt; method:</source>
          <target state="translated">您可以使用 &lt;code&gt;store.registerModule&lt;/code&gt; 方法创建商店&lt;strong&gt;后&lt;/strong&gt;注册模块：</target>
        </trans-unit>
        <trans-unit id="535a2512801117d140454c6e5cb378ba940f4b23" translate="yes" xml:space="preserve">
          <source>You cannot directly call a mutation handler. Think of it more like event registration: &quot;When a mutation with type &lt;code&gt;increment&lt;/code&gt; is triggered, call this handler.&quot; To invoke a mutation handler, you need to call &lt;code&gt;store.commit&lt;/code&gt; with its type:</source>
          <target state="translated">您不能直接调用变异处理程序。可以将其更像是事件注册：&amp;ldquo;当触发类型 &lt;code&gt;increment&lt;/code&gt; 的突变时，请调用此处理程序。&amp;rdquo; 要调用变异处理程序，您需要使用其类型调用 &lt;code&gt;store.commit&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="daa96a4f6ba2541961bc6b0ba61ad44c19c2cd8d" translate="yes" xml:space="preserve">
          <source>You cannot directly mutate the store's state. The only way to change a store's state is by explicitly &lt;strong&gt;committing mutations&lt;/strong&gt;. This ensures every state change leaves a track-able record, and enables tooling that helps us better understand our applications.</source>
          <target state="translated">您不能直接更改商店的状态。更改商店状态的唯一方法是显式地&lt;strong&gt;提交突变&lt;/strong&gt;。这可以确保每个状态更改都留下可跟踪的记录，并启用有助于我们更好地了解我们的应用程序的工具。</target>
        </trans-unit>
        <trans-unit id="360fc60f946b0e1fb46441c21ec094cefc382a47" translate="yes" xml:space="preserve">
          <source>You don't need to do this when using global script tags.</source>
          <target state="translated">当使用全局脚本标签时,你不需要这样做。</target>
        </trans-unit>
        <trans-unit id="c70f3011e5bb2100175201538c23d3b8d06c1f46" translate="yes" xml:space="preserve">
          <source>You may care about unpredictable namespacing for your modules when you create a &lt;a href=&quot;plugins&quot;&gt;plugin&lt;/a&gt; that provides the modules and let users add them to a Vuex store. Your modules will be also namespaced if the plugin users add your modules under a namespaced module. To adapt this situation, you may need to receive a namespace value via your plugin option:</source>
          <target state="translated">当您创建提供模块并允许用户将其添加到Vuex存储的&lt;a href=&quot;plugins&quot;&gt;插件时&lt;/a&gt;，您可能会担心模块的命名空间无法预测。如果插件用户将您的模块添加到命名空间模块下，则您的模块也将被命名空间。为了适应这种情况，您可能需要通过插件选项接收名称空间值：</target>
        </trans-unit>
        <trans-unit id="3f63bbd45ca0e396d20716f1a9faff811b1810cb" translate="yes" xml:space="preserve">
          <source>You will have to clone directly from GitHub and build &lt;code&gt;vuex&lt;/code&gt; yourself if you want to use the latest dev build.</source>
          <target state="translated">如果要使用最新的开发版本，则必须直接从GitHub克隆并 &lt;code&gt;vuex&lt;/code&gt; 构建vuex。</target>
        </trans-unit>
        <trans-unit id="326b426f9ac7a96ed6baf62f8838565416d27df8" translate="yes" xml:space="preserve">
          <source>actions</source>
          <target state="translated">actions</target>
        </trans-unit>
        <trans-unit id="4015b57a143aec5156fd1444a017a32137a3fd0f" translate="yes" xml:space="preserve">
          <source>commit</source>
          <target state="translated">commit</target>
        </trans-unit>
        <trans-unit id="c0b7cc8520ca125ff38dd308c300837ea02ab867" translate="yes" xml:space="preserve">
          <source>createNamespacedHelpers</source>
          <target state="translated">createNamespacedHelpers</target>
        </trans-unit>
        <trans-unit id="59211592ba313c330272b3b02e6654aaf2030698" translate="yes" xml:space="preserve">
          <source>createNamespacedHelpers()</source>
          <target state="translated">createNamespacedHelpers()</target>
        </trans-unit>
        <trans-unit id="d2d86ff5a0cd4d9837f7acff55b3a7cd9d364ab3" translate="yes" xml:space="preserve">
          <source>createStore</source>
          <target state="translated">createStore</target>
        </trans-unit>
        <trans-unit id="b853518a7253a67751993712323af2afe8d26a75" translate="yes" xml:space="preserve">
          <source>default: &lt;code&gt;false&lt;/code&gt;</source>
          <target state="translated">默认值： &lt;code&gt;false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="154cfec6bb116856227577921ae39f8885428eb2" translate="yes" xml:space="preserve">
          <source>devtools</source>
          <target state="translated">devtools</target>
        </trans-unit>
        <trans-unit id="05b145cfb6fbc24d08a8e01155c0aa2bf8460c87" translate="yes" xml:space="preserve">
          <source>dispatch</source>
          <target state="translated">dispatch</target>
        </trans-unit>
        <trans-unit id="6ec8d967f553282c8a0b78d6540dfc8d420a3ef0" translate="yes" xml:space="preserve">
          <source>getters</source>
          <target state="translated">getters</target>
        </trans-unit>
        <trans-unit id="7035b5cff18dc8c3847faa85107fdff08894d5e1" translate="yes" xml:space="preserve">
          <source>hasModule</source>
          <target state="translated">hasModule</target>
        </trans-unit>
        <trans-unit id="191d360d6e9259ceda69018c10b131806a257339" translate="yes" xml:space="preserve">
          <source>hotUpdate</source>
          <target state="translated">hotUpdate</target>
        </trans-unit>
        <trans-unit id="7f3c4da8402c9feb0a967e99e24a689f07ad9538" translate="yes" xml:space="preserve">
          <source>mapActions</source>
          <target state="translated">mapActions</target>
        </trans-unit>
        <trans-unit id="1c9faade8425f6bc337e39a55a39ae4126bc894c" translate="yes" xml:space="preserve">
          <source>mapActions()</source>
          <target state="translated">mapActions()</target>
        </trans-unit>
        <trans-unit id="c5092a452ac716aa7395be56d5a3e111411ab603" translate="yes" xml:space="preserve">
          <source>mapGetters</source>
          <target state="translated">mapGetters</target>
        </trans-unit>
        <trans-unit id="4bed8eb971d49de14d01396cd2061d4908c28770" translate="yes" xml:space="preserve">
          <source>mapGetters()</source>
          <target state="translated">mapGetters()</target>
        </trans-unit>
        <trans-unit id="a837f5acfc97cfd8166f5f0c59fcbb7dfc666465" translate="yes" xml:space="preserve">
          <source>mapMutations</source>
          <target state="translated">mapMutations</target>
        </trans-unit>
        <trans-unit id="80e0f1f5c3583f0fd0d207c7f3df5c3aba3bd7ec" translate="yes" xml:space="preserve">
          <source>mapMutations()</source>
          <target state="translated">mapMutations()</target>
        </trans-unit>
        <trans-unit id="e5461d7d29007a5a5aa44df5c418d146a0695054" translate="yes" xml:space="preserve">
          <source>mapState</source>
          <target state="translated">mapState</target>
        </trans-unit>
        <trans-unit id="2d1ce243674082e4c821c3525927a44e71d4d016" translate="yes" xml:space="preserve">
          <source>mapState()</source>
          <target state="translated">mapState()</target>
        </trans-unit>
        <trans-unit id="4580485d482a9037af94f68af98adf23819cbdf4" translate="yes" xml:space="preserve">
          <source>modules</source>
          <target state="translated">modules</target>
        </trans-unit>
        <trans-unit id="3db5c1d36e4a153d7b5cda1e2d65b175222ccf09" translate="yes" xml:space="preserve">
          <source>mutations</source>
          <target state="translated">mutations</target>
        </trans-unit>
        <trans-unit id="440c3339cb056522cd1edf391e616ceb636e1a08" translate="yes" xml:space="preserve">
          <source>plugins</source>
          <target state="translated">plugins</target>
        </trans-unit>
        <trans-unit id="3f170c2be21627360e728ba4b0f15e0c20cc0126" translate="yes" xml:space="preserve">
          <source>registerModule</source>
          <target state="translated">registerModule</target>
        </trans-unit>
        <trans-unit id="eb49199248380da5116beeb5a5bdf9606ac21f82" translate="yes" xml:space="preserve">
          <source>replaceState</source>
          <target state="translated">replaceState</target>
        </trans-unit>
        <trans-unit id="aa4a5f8125f234182e2dea92805afdfb747a86be" translate="yes" xml:space="preserve">
          <source>state</source>
          <target state="translated">state</target>
        </trans-unit>
        <trans-unit id="41eaab877ca3a0e3aa14f5a4b7981f590e3c2bd6" translate="yes" xml:space="preserve">
          <source>strict</source>
          <target state="translated">strict</target>
        </trans-unit>
        <trans-unit id="4c91330c57b1f26f16a92bbcb0653bc2a60a5b88" translate="yes" xml:space="preserve">
          <source>subscribe</source>
          <target state="translated">subscribe</target>
        </trans-unit>
        <trans-unit id="c8be9eb77e0a063aa55220d426f0169f12707d24" translate="yes" xml:space="preserve">
          <source>subscribeAction</source>
          <target state="translated">subscribeAction</target>
        </trans-unit>
        <trans-unit id="575fade49b23c513149d6cbd60de79f6715e014d" translate="yes" xml:space="preserve">
          <source>type: &lt;code&gt;Array&amp;lt;Function&amp;gt;&lt;/code&gt;</source>
          <target state="translated">类型： &lt;code&gt;Array&amp;lt;Function&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="501ad78bfb628eb307d521b862f9d31d47e25be6" translate="yes" xml:space="preserve">
          <source>type: &lt;code&gt;Boolean&lt;/code&gt;</source>
          <target state="translated">类型： &lt;code&gt;Boolean&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7f896effac2d60505acabced97b30bbb769a74db" translate="yes" xml:space="preserve">
          <source>type: &lt;code&gt;Object | Function&lt;/code&gt;</source>
          <target state="translated">类型： &lt;code&gt;Object | Function&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="459de9ab6bbb747b424aa86431b8923f3e3cebed" translate="yes" xml:space="preserve">
          <source>type: &lt;code&gt;Object&lt;/code&gt;</source>
          <target state="translated">类型： &lt;code&gt;Object&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e0800374f05dce7addc4f97d5a68d2e7b35b3ef4" translate="yes" xml:space="preserve">
          <source>type: &lt;code&gt;boolean&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0adf6137f83fccfe39fef3d4143300d0f0d7953d" translate="yes" xml:space="preserve">
          <source>type: &lt;code&gt;{ [key: string]: Function }&lt;/code&gt;</source>
          <target state="translated">类型： &lt;code&gt;{ [key: string]: Function }&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="116a5df420232cc247b1f0bf6bbbec8667db410b" translate="yes" xml:space="preserve">
          <source>type: &lt;code&gt;{ [type: string]: Function }&lt;/code&gt;</source>
          <target state="translated">类型： &lt;code&gt;{ [type: string]: Function }&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3a69e7241a5b047759b4617f9a2bc7130db75edc" translate="yes" xml:space="preserve">
          <source>unregisterModule</source>
          <target state="translated">unregisterModule</target>
        </trans-unit>
        <trans-unit id="53c05e9fd370dfe1efd890820e99c7a18b9c5414" translate="yes" xml:space="preserve">
          <source>useStore</source>
          <target state="translated">useStore</target>
        </trans-unit>
        <trans-unit id="292b0901993f7e9d9a0d9b80542f9e59505ba5be" translate="yes" xml:space="preserve">
          <source>watch</source>
          <target state="translated">watch</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
