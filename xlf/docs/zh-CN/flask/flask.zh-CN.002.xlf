<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="flask">
    <body>
      <group id="flask">
        <trans-unit id="d7e21d6ebab2ed8663ed77de77729a5e3e97389e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;conditional=True&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt; is provided, this method will try to upgrade the response stream to support range requests. This will allow the request to be answered with partial content response.</source>
          <target state="translated">如果提供了 &lt;code&gt;conditional=True&lt;/code&gt; 和 &lt;code&gt;filename&lt;/code&gt; ，则此方法将尝试升级响应流以支持范围请求。这将允许使用部分内容响应来回答请求。</target>
        </trans-unit>
        <trans-unit id="9f3eb188fdafeeab45c51425dd4a77c032f8217c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;session.permanent&lt;/code&gt; is true, the cookie&amp;rsquo;s expiration will be set this number of seconds in the future. Can either be a &lt;a href=&quot;https://docs.python.org/3/library/datetime.html#datetime.timedelta&quot;&gt;&lt;code&gt;datetime.timedelta&lt;/code&gt;&lt;/a&gt; or an &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;session.permanent&lt;/code&gt; 为true，则cookie的到期时间将在将来设置为此秒数。可以是&lt;a href=&quot;https://docs.python.org/3/library/datetime.html#datetime.timedelta&quot;&gt; &lt;code&gt;datetime.timedelta&lt;/code&gt; &lt;/a&gt;或 &lt;code&gt;int&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8977e0fce52b1d98fc1b15de8a69a734b6449640" translate="yes" xml:space="preserve">
          <source>If a URL contains a default value, it will be redirected to its simpler form with a 301 redirect. In the above example, &lt;code&gt;/users/page/1&lt;/code&gt; will be redirected to &lt;code&gt;/users/&lt;/code&gt;. If your route handles &lt;code&gt;GET&lt;/code&gt; and &lt;code&gt;POST&lt;/code&gt; requests, make sure the default route only handles &lt;code&gt;GET&lt;/code&gt;, as redirects can&amp;rsquo;t preserve form data.</source>
          <target state="translated">如果网址包含默认值，则会使用301重定向将其重定向为更简单的形式。在上面的示例中， &lt;code&gt;/users/page/1&lt;/code&gt; 将被重定向到 &lt;code&gt;/users/&lt;/code&gt; 。如果您的路由处理 &lt;code&gt;GET&lt;/code&gt; 和 &lt;code&gt;POST&lt;/code&gt; 请求，请确保默认路由仅处理 &lt;code&gt;GET&lt;/code&gt; ，因为重定向无法保留表单数据。</target>
        </trans-unit>
        <trans-unit id="1262624b9501345e95c1dc463bf830a26c6dea0e" translate="yes" xml:space="preserve">
          <source>If a factory function is used in a &lt;code&gt;__init__.py&lt;/code&gt; file, then the function should be imported:</source>
          <target state="translated">如果在 &lt;code&gt;__init__.py&lt;/code&gt; 文件中使用了工厂函数，则应导入该函数：</target>
        </trans-unit>
        <trans-unit id="cb2017347d400731bfc3ae058ddf88241bc611f5" translate="yes" xml:space="preserve">
          <source>If a forwarded header exists this is a list of all ip addresses from the client ip to the last proxy server.</source>
          <target state="translated">如果存在转发头,这是一个从客户端ip到最后一个代理服务器的所有ip地址的列表。</target>
        </trans-unit>
        <trans-unit id="5363528fcdc14c65e82d050951b1935f613fea7a" translate="yes" xml:space="preserve">
          <source>If a response object of the correct type is returned it&amp;rsquo;s directly returned from the view.</source>
          <target state="translated">如果返回正确类型的响应对象，则直接从视图中返回它。</target>
        </trans-unit>
        <trans-unit id="362448c3b7b11cceb926b27c224be09f1d7e8eee" translate="yes" xml:space="preserve">
          <source>If a rule does not end with a trailing slash and the user requests the page with a trailing slash, a 404 not found is raised.</source>
          <target state="translated">如果一条规则不以尾部的斜线结尾,而用户请求的页面又带有尾部的斜线,就会出现404 not found。</target>
        </trans-unit>
        <trans-unit id="098be003e1d2a365d0deca6f1ecacd273ea117c4" translate="yes" xml:space="preserve">
          <source>If a rule ends with a slash and is requested without a slash by the user, the user is automatically redirected to the same page with a trailing slash attached.</source>
          <target state="translated">如果一条规则以斜线结尾,而用户请求时又没有斜线,那么用户会被自动重定向到带有尾部斜线的同一页面。</target>
        </trans-unit>
        <trans-unit id="b7e740e0a7f493379b75ddc302e222e6abee1147" translate="yes" xml:space="preserve">
          <source>If a secret key is set, cryptographic components can use this to sign cookies and other things. Set this to a complex random value when you want to use the secure cookie for instance.</source>
          <target state="translated">如果设置了一个秘密密钥,加密组件就可以用它来签署cookie和其他东西。例如当你想使用安全cookie时,将其设置为一个复杂的随机值。</target>
        </trans-unit>
        <trans-unit id="a197226271fe81f7dade0b72531879b4bb656e0f" translate="yes" xml:space="preserve">
          <source>If a status code is given, it will be looked up in the list of exceptions and will raise that exception. If passed a WSGI application, it will wrap it in a proxy WSGI exception and raise that:</source>
          <target state="translated">如果给定一个状态码,将在异常列表中查找并引发该异常。如果传递了一个WSGI应用程序,它将把它包裹在一个代理WSGI异常中并引发该异常。</target>
        </trans-unit>
        <trans-unit id="811a219b0b920ecc25633cfec19ba0d12a1b3905" translate="yes" xml:space="preserve">
          <source>If a tuple is returned the items in the tuple can provide extra information. Such tuples have to be in the form &lt;code&gt;(response, status)&lt;/code&gt;, &lt;code&gt;(response, headers)&lt;/code&gt;, or &lt;code&gt;(response, status, headers)&lt;/code&gt;. The &lt;code&gt;status&lt;/code&gt; value will override the status code and &lt;code&gt;headers&lt;/code&gt; can be a list or dictionary of additional header values.</source>
          <target state="translated">如果返回一个元组，则该元组中的项目可以提供额外的信息。这样的元组必须采用 &lt;code&gt;(response, status)&lt;/code&gt; ， &lt;code&gt;(response, headers)&lt;/code&gt; 或 &lt;code&gt;(response, status, headers)&lt;/code&gt; 。的 &lt;code&gt;status&lt;/code&gt; 值将覆盖状态码和 &lt;code&gt;headers&lt;/code&gt; 可以是附加报头的值的列表或字典。</target>
        </trans-unit>
        <trans-unit id="e2f0a7e664683abbb44f74b6933f82b8e8f7ed20" translate="yes" xml:space="preserve">
          <source>If all other deployment methods do not work, CGI will work for sure. CGI is supported by all major servers but usually has a sub-optimal performance.</source>
          <target state="translated">如果其他部署方式都不行,CGI肯定能行。CGI是所有主流服务器都支持的,但通常性能不理想。</target>
        </trans-unit>
        <trans-unit id="a8a0412ae878692c775cf37c2ed6866a1771d8c9" translate="yes" xml:space="preserve">
          <source>If an env var is already set it is not overwritten, so earlier files in the list are preferred over later files.</source>
          <target state="translated">如果一个env var已经被设置,它不会被覆盖,所以列表中较早的文件比较晚的文件更受欢迎。</target>
        </trans-unit>
        <trans-unit id="c27f252290e9df37fc629715bb9d38769a004879" translate="yes" xml:space="preserve">
          <source>If an error handler is registered for &lt;code&gt;InternalServerError&lt;/code&gt; or &lt;code&gt;500&lt;/code&gt;, it will be used. For consistency, the handler will always receive the &lt;code&gt;InternalServerError&lt;/code&gt;. The original unhandled exception is available as &lt;code&gt;e.original_exception&lt;/code&gt;.</source>
          <target state="translated">如果为 &lt;code&gt;InternalServerError&lt;/code&gt; 或 &lt;code&gt;500&lt;/code&gt; 注册了错误处理程序，则将使用该错误处理程序。为了保持一致，处理程序将始终收到 &lt;code&gt;InternalServerError&lt;/code&gt; 。原始未处理的异常可以作为 &lt;code&gt;e.original_exception&lt;/code&gt; 获得。</target>
        </trans-unit>
        <trans-unit id="271901036e671e9299b7dee3367f20ac84a3807f" translate="yes" xml:space="preserve">
          <source>If an exception is raised before the teardown functions, Flask tries to match it with an &lt;a href=&quot;../api/index#flask.Flask.errorhandler&quot;&gt;&lt;code&gt;errorhandler()&lt;/code&gt;&lt;/a&gt; function to handle the exception and return a response. If no error handler is found, or the handler itself raises an exception, Flask returns a generic &lt;code&gt;500 Internal Server Error&lt;/code&gt; response. The teardown functions are still called, and are passed the exception object.</source>
          <target state="translated">如果在拆解函数之前引发了异常，则Flask尝试将其与&lt;a href=&quot;../api/index#flask.Flask.errorhandler&quot;&gt; &lt;code&gt;errorhandler()&lt;/code&gt; &lt;/a&gt;函数进行匹配以处理该异常并返回响应。如果未找到错误处理程序，或者处理程序本身引发异常，则Flask返回通用的 &lt;code&gt;500 Internal Server Error&lt;/code&gt; 响应。拆解函数仍被调用，并传递给异常对象。</target>
        </trans-unit>
        <trans-unit id="86044d9203fdf679f47ed9460d9f817fa746a3a1" translate="yes" xml:space="preserve">
          <source>If any &lt;a href=&quot;#flask.Flask.before_request&quot;&gt;&lt;code&gt;before_request()&lt;/code&gt;&lt;/a&gt; handler returns a non-None value, the value is handled as if it was the return value from the view, and further request handling is stopped.</source>
          <target state="translated">如果有任何&lt;a href=&quot;#flask.Flask.before_request&quot;&gt; &lt;code&gt;before_request()&lt;/code&gt; &lt;/a&gt;处理函数返回一个Non-None值，则该值的处理就好像它是视图中的返回值一样，并且进一步的请求处理将停止。</target>
        </trans-unit>
        <trans-unit id="4edf008ad77108738069061779ca0f14505c0e6b" translate="yes" xml:space="preserve">
          <source>If debug mode is enabled, unhandled exceptions are not converted to a &lt;code&gt;500&lt;/code&gt; response and instead are propagated to the WSGI server. This allows the development server to present the interactive debugger with the traceback.</source>
          <target state="translated">如果启用了调试模式，则未处理的异常不会转换为 &lt;code&gt;500&lt;/code&gt; 响应，而是传播到WSGI服务器。这允许开发服务器向交互式调试器提供回溯。</target>
        </trans-unit>
        <trans-unit id="8d1dd12d46f8c2ce715d5225e349b0c3b5e5f779" translate="yes" xml:space="preserve">
          <source>If it was not configured during init, it is derived from &lt;a href=&quot;#flask.Blueprint.static_folder&quot;&gt;&lt;code&gt;static_folder&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果未在初始化期间配置它，则它是从&lt;a href=&quot;#flask.Blueprint.static_folder&quot;&gt; &lt;code&gt;static_folder&lt;/code&gt; &lt;/a&gt;派生的。</target>
        </trans-unit>
        <trans-unit id="dbd36c4a495ba02f2039cce3610ab9b63230ac02" translate="yes" xml:space="preserve">
          <source>If it was not configured during init, it is derived from &lt;a href=&quot;#flask.Flask.static_folder&quot;&gt;&lt;code&gt;static_folder&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果未在初始化期间配置它，则它是从&lt;a href=&quot;#flask.Flask.static_folder&quot;&gt; &lt;code&gt;static_folder&lt;/code&gt; &lt;/a&gt;派生的。</target>
        </trans-unit>
        <trans-unit id="2b197edc03614f76973e11b341f78e5d72827f55" translate="yes" xml:space="preserve">
          <source>If it&amp;rsquo;s a dict, a response object is created using &lt;code&gt;jsonify&lt;/code&gt;.</source>
          <target state="translated">如果是字典，则使用 &lt;code&gt;jsonify&lt;/code&gt; 创建响应对象。</target>
        </trans-unit>
        <trans-unit id="e8153f5e7e27bbbcbfc820b9ef16ad054d6b1fd8" translate="yes" xml:space="preserve">
          <source>If it&amp;rsquo;s a string, a response object is created with that data and the default parameters.</source>
          <target state="translated">如果是字符串，则使用该数据和默认参数创建一个响应对象。</target>
        </trans-unit>
        <trans-unit id="97535ccf0fae37869429f42e09190f0d7ca74a0a" translate="yes" xml:space="preserve">
          <source>If matching the URL failed, this is the exception that will be raised / was raised as part of the request handling. This is usually a &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/exceptions/#werkzeug.exceptions.NotFound&quot;&gt;&lt;code&gt;NotFound&lt;/code&gt;&lt;/a&gt; exception or something similar.</source>
          <target state="translated">如果匹配URL失败，这是将在请求处理过程中引发/引发的异常。这通常是一个&lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/exceptions/#werkzeug.exceptions.NotFound&quot;&gt; &lt;code&gt;NotFound&lt;/code&gt; &lt;/a&gt;异常或类似的东西。</target>
        </trans-unit>
        <trans-unit id="455443f35bc921610f1ee98cb38fc1713cadccec" translate="yes" xml:space="preserve">
          <source>If none of that works, Flask will assume the return value is a valid WSGI application and convert that into a response object.</source>
          <target state="translated">如果这些都不行,Flask会认为返回值是一个有效的WSGI应用程序,并将其转换为响应对象。</target>
        </trans-unit>
        <trans-unit id="fb823776e840a60b65ffdcf1b2bad6eca74fa44c" translate="yes" xml:space="preserve">
          <source>If none of the above options work, fork Flask. The majority of code of Flask is within Werkzeug and Jinja2. These libraries do the majority of the work. Flask is just the paste that glues those together. For every project there is the point where the underlying framework gets in the way (due to assumptions the original developers had). This is natural because if this would not be the case, the framework would be a very complex system to begin with which causes a steep learning curve and a lot of user frustration.</source>
          <target state="translated">如果以上选项都不行,就fork Flask。Flask的大部分代码都在Werkzeug和Jinja2中。这些库做了大部分的工作。Flask只是将这些粘合在一起的粘贴。对于每个项目来说,都会有底层框架碍事的地方(由于原始开发者的假设)。这是很自然的,因为如果不是这样,框架一开始就会是一个非常复杂的系统,这会导致陡峭的学习曲线和很多用户的挫折感。</target>
        </trans-unit>
        <trans-unit id="f60aacb59359e8a3f79db39203d409541c35d0db" translate="yes" xml:space="preserve">
          <source>If parsing fails, &lt;a href=&quot;#flask.Request.on_json_loading_failed&quot;&gt;&lt;code&gt;on_json_loading_failed()&lt;/code&gt;&lt;/a&gt; is called and its return value is used as the return value.</source>
          <target state="translated">如果解析失败，&lt;a href=&quot;#flask.Request.on_json_loading_failed&quot;&gt; &lt;code&gt;on_json_loading_failed()&lt;/code&gt; &lt;/a&gt;调用on_json_loading_failed（）并将其返回值用作返回值。</target>
        </trans-unit>
        <trans-unit id="8fbaddfe1e802279ece5f2df2ebebcb1ddb10c2e" translate="yes" xml:space="preserve">
          <source>If parsing fails, &lt;code&gt;on_json_loading_failed()&lt;/code&gt; is called and its return value is used as the return value.</source>
          <target state="translated">如果解析失败， &lt;code&gt;on_json_loading_failed()&lt;/code&gt; 调用on_json_loading_failed（）并将其返回值用作返回值。</target>
        </trans-unit>
        <trans-unit id="a6098d721ea7f62f2a87aedb01dbe744b3c79b80" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;True&lt;/code&gt; the session lives for &lt;a href=&quot;#flask.Flask.permanent_session_lifetime&quot;&gt;&lt;code&gt;permanent_session_lifetime&lt;/code&gt;&lt;/a&gt; seconds. The default is 31 days. If set to &lt;code&gt;False&lt;/code&gt; (which is the default) the session will be deleted when the user closes the browser.</source>
          <target state="translated">如果设置为&amp;ldquo; &lt;code&gt;True&lt;/code&gt; &amp;rdquo;,则该会话将存活&lt;a href=&quot;#flask.Flask.permanent_session_lifetime&quot;&gt; &lt;code&gt;permanent_session_lifetime&lt;/code&gt; &lt;/a&gt;秒。默认值为31天。如果设置为 &lt;code&gt;False&lt;/code&gt; （默认设置），则当用户关闭浏览器时，会话将被删除。</target>
        </trans-unit>
        <trans-unit id="24a3fe6824009d76bc94ebe114d682738be9c349" translate="yes" xml:space="preserve">
          <source>If set, &lt;code&gt;url_for&lt;/code&gt; can generate external URLs with only an application context instead of a request context.</source>
          <target state="translated">如果设置，则 &lt;code&gt;url_for&lt;/code&gt; 可以仅使用应用程序上下文而不是请求上下文来生成外部URL。</target>
        </trans-unit>
        <trans-unit id="e78a2edf6e0ffc40cf0af3b8d97fd7c2590ee609" translate="yes" xml:space="preserve">
          <source>If set, the &lt;code id=&quot;index-1&quot;&gt;FLASK_ENV&lt;/code&gt; and &lt;code id=&quot;index-2&quot;&gt;FLASK_DEBUG&lt;/code&gt; environment variables will override &lt;a href=&quot;#flask.Flask.env&quot;&gt;&lt;code&gt;env&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#flask.Flask.debug&quot;&gt;&lt;code&gt;debug&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果设置，则 &lt;code id=&quot;index-1&quot;&gt;FLASK_ENV&lt;/code&gt; 和 &lt;code id=&quot;index-2&quot;&gt;FLASK_DEBUG&lt;/code&gt; 环境变量将覆盖&lt;a href=&quot;#flask.Flask.env&quot;&gt; &lt;code&gt;env&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#flask.Flask.debug&quot;&gt; &lt;code&gt;debug&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="573ab45ae15ac5c98147b70031f4c340dfef180a" translate="yes" xml:space="preserve">
          <source>If set, will be used for the session cookie domain if &lt;a href=&quot;#SESSION_COOKIE_DOMAIN&quot;&gt;&lt;code&gt;SESSION_COOKIE_DOMAIN&lt;/code&gt;&lt;/a&gt; is not set. Modern web browsers will not allow setting cookies for domains without a dot. To use a domain locally, add any names that should route to the app to your &lt;code&gt;hosts&lt;/code&gt; file.</source>
          <target state="translated">如果设置，则在未设置&lt;a href=&quot;#SESSION_COOKIE_DOMAIN&quot;&gt; &lt;code&gt;SESSION_COOKIE_DOMAIN&lt;/code&gt; 的&lt;/a&gt;情况下将用于会话cookie域。现代网络浏览器不允许为没有点的域设置Cookie。要在本地使用域，请将应路由到该应用程序的所有名称添加到您的 &lt;code&gt;hosts&lt;/code&gt; 文件中。</target>
        </trans-unit>
        <trans-unit id="6e9c72b2a5c65bba0f51ed29269a52a00a8b39b3" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#flask.Flask.debug&quot;&gt;&lt;code&gt;debug&lt;/code&gt;&lt;/a&gt; flag is set the server will automatically reload for code changes and show a debugger in case an exception happened.</source>
          <target state="translated">如果设置了&lt;a href=&quot;#flask.Flask.debug&quot;&gt; &lt;code&gt;debug&lt;/code&gt; &lt;/a&gt;标志，则服务器将自动重新加载代码以进行更改，并在发生异常的情况下显示调试器。</target>
        </trans-unit>
        <trans-unit id="9dcfdf03101f0d9ef646b9f5723e944d4ea8beac" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../api/index#flask.Flask.before_request&quot;&gt;&lt;code&gt;before_request()&lt;/code&gt;&lt;/a&gt; functions did not return a response, the view function for the matched route is called and returns a response.</source>
          <target state="translated">如果&lt;a href=&quot;../api/index#flask.Flask.before_request&quot;&gt; &lt;code&gt;before_request()&lt;/code&gt; &lt;/a&gt;函数未返回响应，则将调用匹配路由的view函数并返回响应。</target>
        </trans-unit>
        <trans-unit id="4bfc7b51429cbbf3af4f6592e77339906951b422" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;instance_path&lt;/code&gt; parameter is not provided the following default locations are used:</source>
          <target state="translated">如果未提供 &lt;code&gt;instance_path&lt;/code&gt; 参数，则使用以下默认位置：</target>
        </trans-unit>
        <trans-unit id="e89e7992d9d5b6ad19de9bbfcb5b66060aba31e9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;obj&lt;/code&gt; argument is not given, passes an instance of &lt;a href=&quot;#flask.cli.ScriptInfo&quot;&gt;&lt;code&gt;ScriptInfo&lt;/code&gt;&lt;/a&gt; that knows how to load the Flask app being tested.</source>
          <target state="translated">如果未提供 &lt;code&gt;obj&lt;/code&gt; 参数，则传递一个&lt;a href=&quot;#flask.cli.ScriptInfo&quot;&gt; &lt;code&gt;ScriptInfo&lt;/code&gt; &lt;/a&gt;实例，该实例知道如何加载正在测试的Flask应用程序。</target>
        </trans-unit>
        <trans-unit id="0c62cdc72623797ea2c51a060613d64db540a2ab" translate="yes" xml:space="preserve">
          <source>If the document has nested fields, use &lt;code&gt;EmbeddedDocument&lt;/code&gt; to defined the fields of the embedded document and &lt;code&gt;EmbeddedDocumentField&lt;/code&gt; to declare it on the parent document.</source>
          <target state="translated">如果文档具有嵌套字段，请使用 &lt;code&gt;EmbeddedDocument&lt;/code&gt; 定义嵌入式文档的字段，并使用 &lt;code&gt;EmbeddedDocumentField&lt;/code&gt; 在父文档上对其进行声明。</target>
        </trans-unit>
        <trans-unit id="f208d93512a3c36cce9cfad0d183a9be0e418863" translate="yes" xml:space="preserve">
          <source>If the env is set to &lt;code&gt;development&lt;/code&gt;, the &lt;code&gt;flask&lt;/code&gt; command will enable debug mode and &lt;code&gt;flask run&lt;/code&gt; will enable the interactive debugger and reloader.</source>
          <target state="translated">如果将env设置为 &lt;code&gt;development&lt;/code&gt; ，则 &lt;code&gt;flask&lt;/code&gt; 命令将启用调试模式，而 &lt;code&gt;flask run&lt;/code&gt; 将启用交互式调试器和重新加载器。</target>
        </trans-unit>
        <trans-unit id="1cb511238db84d87636eb801e45bfa855f233c05" translate="yes" xml:space="preserve">
          <source>If the incoming form data was not encoded with a known mimetype the data is stored unmodified in this stream for consumption. Most of the time it is a better idea to use &lt;a href=&quot;#flask.Request.data&quot;&gt;&lt;code&gt;data&lt;/code&gt;&lt;/a&gt; which will give you that data as a string. The stream only returns the data once.</source>
          <target state="translated">如果传入的表单数据未使用已知的模仿类型编码，则将数据未经修改地存储在此流中以供使用。大多数时候，它是一个更好的主意，使用&lt;a href=&quot;#flask.Request.data&quot;&gt; &lt;code&gt;data&lt;/code&gt; &lt;/a&gt;，这将给你的数据作为一个字符串。流仅返回一次数据。</target>
        </trans-unit>
        <trans-unit id="bf9af3b8adb5cd22024b1ffc584ad3ac59787436" translate="yes" xml:space="preserve">
          <source>If the mimetype does not indicate JSON (&lt;em&gt;application/json&lt;/em&gt;, see &lt;a href=&quot;#flask.Request.is_json&quot;&gt;&lt;code&gt;is_json()&lt;/code&gt;&lt;/a&gt;), this returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">如果mimetype不表示JSON（&lt;em&gt;application / json&lt;/em&gt;，请参见&lt;a href=&quot;#flask.Request.is_json&quot;&gt; &lt;code&gt;is_json()&lt;/code&gt; &lt;/a&gt;），则返回 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f3bc0ed5ed2ad64bee01b8e8847b50f7d9ed76fe" translate="yes" xml:space="preserve">
          <source>If the mimetype does not indicate JSON (&lt;em&gt;application/json&lt;/em&gt;, see &lt;a href=&quot;#flask.Response.is_json&quot;&gt;&lt;code&gt;is_json()&lt;/code&gt;&lt;/a&gt;), this returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">如果mimetype不表示JSON（&lt;em&gt;application / json&lt;/em&gt;，请参见&lt;a href=&quot;#flask.Response.is_json&quot;&gt; &lt;code&gt;is_json()&lt;/code&gt; &lt;/a&gt;），则返回 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="189f531ed92f7cd88bf7da7df370d310c8dfb19d" translate="yes" xml:space="preserve">
          <source>If the server supports user authentication, and the script is protected, this attribute contains the username the user has authenticated as.</source>
          <target state="translated">如果服务器支持用户认证,并且脚本是受保护的,那么这个属性就包含了用户所认证的用户名。</target>
        </trans-unit>
        <trans-unit id="601242725df94b3d5e18b7ad45163cefb98455a9" translate="yes" xml:space="preserve">
          <source>If the view_func is not provided you will need to connect the endpoint to a view function like so:</source>
          <target state="translated">如果没有提供view_func,你将需要将端点连接到一个视图函数,就像这样。</target>
        </trans-unit>
        <trans-unit id="72236bb2102156620d3395f856178c30024f2ccf" translate="yes" xml:space="preserve">
          <source>If there are no handlers configured, a default handler will be added. See &lt;a href=&quot;../logging/index&quot;&gt;Logging&lt;/a&gt; for more information.</source>
          <target state="translated">如果未配置任何处理程序，则将添加默认处理程序。有关更多信息，请参见&lt;a href=&quot;../logging/index&quot;&gt;记录&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="697df3b18402ec73b9f52fb22cc43f3828ae9849" translate="yes" xml:space="preserve">
          <source>If there is an error handler registered for &lt;code&gt;InternalServerError&lt;/code&gt;, this will be invoked. As of Flask 1.1.0, this error handler will always be passed an instance of &lt;code&gt;InternalServerError&lt;/code&gt;, not the original unhandled error. The original error is available as &lt;code&gt;e.original_exception&lt;/code&gt;. Until Werkzeug 1.0.0, this attribute will only exist during unhandled errors, use &lt;code&gt;getattr&lt;/code&gt; to get access it for compatibility.</source>
          <target state="translated">如果有一个为 &lt;code&gt;InternalServerError&lt;/code&gt; 注册的错误处理程序，则将调用该错误处理程序。从Flask 1.1.0开始，该错误处理程序将始终传递 &lt;code&gt;InternalServerError&lt;/code&gt; 的实例，而不是原始未处理的错误。原始错误可通过 &lt;code&gt;e.original_exception&lt;/code&gt; 获得。在Werkzeug 1.0.0之前，此属性仅在未处理的错误期间存在，请使用 &lt;code&gt;getattr&lt;/code&gt; 进行访问以获得兼容性。</target>
        </trans-unit>
        <trans-unit id="695c7480e177f85afdceabb05be0a4955c6f19f8" translate="yes" xml:space="preserve">
          <source>If there is no handler for an &lt;code&gt;HTTPException&lt;/code&gt;-type exception, re-raise it to be handled by the interactive debugger instead of returning it as a simple error response.</source>
          <target state="translated">如果没有用于 &lt;code&gt;HTTPException&lt;/code&gt; 类型异常的处理程序，则将其重新引发以由交互式调试器处理，而不是将其作为简单的错误响应返回。</target>
        </trans-unit>
        <trans-unit id="bc1bf66c82514a07ce7cb27385b3a5cd3fe7da99" translate="yes" xml:space="preserve">
          <source>If this is enabled and PROPAGATE_EXCEPTIONS is not changed from the default it&amp;rsquo;s implicitly enabled.</source>
          <target state="translated">如果启用了此功能，并且未更改PROPAGATE_EXCEPTIONS的默认设置，则会隐式启用它。</target>
        </trans-unit>
        <trans-unit id="637ffc7dcf5d7c170093f0182a2338ffd9ee922f" translate="yes" xml:space="preserve">
          <source>If view looked like this and you want to add a new header:</source>
          <target state="translated">如果视图看起来像这样,你想添加一个新的头。</target>
        </trans-unit>
        <trans-unit id="bf852760d4b255742bf05b5f38f96c7d24e111ac" translate="yes" xml:space="preserve">
          <source>If we now run the test suite, we should see the following output:</source>
          <target state="translated">如果我们现在运行测试套件,我们应该看到以下输出。</target>
        </trans-unit>
        <trans-unit id="e30866c4910964f20c90b721ea59f670f3b20710" translate="yes" xml:space="preserve">
          <source>If you are already using packages and blueprints for your application (&lt;a href=&quot;../../blueprints/index#blueprints&quot;&gt;Modular Applications with Blueprints&lt;/a&gt;) there are a couple of really nice ways to further improve the experience. A common pattern is creating the application object when the blueprint is imported. But if you move the creation of this object into a function, you can then create multiple instances of this app later.</source>
          <target state="translated">如果您已经为应用程序使用了程序包和蓝图（&lt;a href=&quot;../../blueprints/index#blueprints&quot;&gt;带有蓝图的模块化应用程序&lt;/a&gt;），则有两种非常好的方法可以进一步改善体验。导入蓝图时，一种常见的模式是创建应用程序对象。但是，如果将此对象的创建移到一个函数中，则可以稍后再创建该应用程序的多个实例。</target>
        </trans-unit>
        <trans-unit id="166c4afd266136b07cd6b8776adb3ad7e96f5228" translate="yes" xml:space="preserve">
          <source>If you are curious why Flask does certain things the way it does and not differently, this section is for you. This should give you an idea about some of the design decisions that may appear arbitrary and surprising at first, especially in direct comparison with other frameworks.</source>
          <target state="translated">如果你很好奇为什么Flask做某些事情的方式,而不是不同的,本节就是为你准备的。这应该会让您了解一些设计决定,这些决定可能会在第一时间显得很随意和令人惊讶,特别是在与其他框架的直接比较中。</target>
        </trans-unit>
        <trans-unit id="db52d79a81c84a82fe31507028f159be54d7cd70" translate="yes" xml:space="preserve">
          <source>If you are developing on the package and also want the requirements to be installed, you can use the &lt;code&gt;develop&lt;/code&gt; command instead:</source>
          <target state="translated">如果您正在开发软件包，并且还希望安装要求，则可以改用 &lt;code&gt;develop&lt;/code&gt; 命令：</target>
        </trans-unit>
        <trans-unit id="17583259a2da820e09c42054e8563c2f67493bd6" translate="yes" xml:space="preserve">
          <source>If you are looking for information on a specific function, class or method, this part of the documentation is for you.</source>
          <target state="translated">如果你正在寻找一个特定函数、类或方法的信息,这部分文档就是为你准备的。</target>
        </trans-unit>
        <trans-unit id="ccf2c255267eaab45b5164cf2440ffd447e1934b" translate="yes" xml:space="preserve">
          <source>If you are on Mac OS X or Windows, download &lt;a href=&quot;https://bootstrap.pypa.io/get-pip.py&quot;&gt;get-pip.py&lt;/a&gt;, then:</source>
          <target state="translated">如果您使用的是Mac OS X或Windows，请下载&lt;a href=&quot;https://bootstrap.pypa.io/get-pip.py&quot;&gt;get-pip.py&lt;/a&gt;，然后：</target>
        </trans-unit>
        <trans-unit id="74de3dd73836ceac17931a0def5ed2a61c51549c" translate="yes" xml:space="preserve">
          <source>If you are on Windows, the environment variable syntax depends on command line interpreter. On Command Prompt:</source>
          <target state="translated">如果你是在Windows上,环境变量的语法取决于命令行解释器。在命令提示符下。</target>
        </trans-unit>
        <trans-unit id="999bb36fa9b41e7cc422e6f148d41cc08e06da17" translate="yes" xml:space="preserve">
          <source>If you are outside of the project directory make sure to provide the exact path to your application directory. Similarly you can turn on the development features like this:</source>
          <target state="translated">如果你在项目目录之外,请确保提供你的应用程序目录的准确路径。同样你也可以像这样开启开发功能。</target>
        </trans-unit>
        <trans-unit id="d114e9ce90fac8b8fd44242a2c53247a0b4184a1" translate="yes" xml:space="preserve">
          <source>If you are talking with a filesystem or something that is not really based on Unicode you will have to ensure that you decode properly when working with Unicode interface. So for example if you want to load a file on the filesystem and embed it into a Jinja2 template you will have to decode it from the encoding of that file. Here the old problem that text files do not specify their encoding comes into play. So do yourself a favour and limit yourself to UTF-8 for text files as well.</source>
          <target state="translated">如果你使用的是一个文件系统或者不是真正基于Unicode的东西,你必须确保在使用Unicode接口时正确解码,所以如果你想在文件系统上加载一个文件,并嵌入到一个Jinja2模板中,你必须对该文件的编码进行解码。例如,如果你想在文件系统中加载一个文件,并将其嵌入到Jinja2模板中,你就必须根据该文件的编码进行解码。这里就出现了一个老问题,即文本文件不指定其编码。所以帮你自己一个忙,把文本文件也限制在UTF-8上。</target>
        </trans-unit>
        <trans-unit id="9f2d8858736b6c4f0ce7e7bd1b81503104895794" translate="yes" xml:space="preserve">
          <source>If you are using Python 2, the venv module is not available. Instead, install &lt;a href=&quot;https://virtualenv.pypa.io/&quot;&gt;virtualenv&lt;/a&gt;.</source>
          <target state="translated">如果您使用的是Python 2，则venv模块不可用。而是安装&lt;a href=&quot;https://virtualenv.pypa.io/&quot;&gt;virtualenv&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="48e4909dffb6a902e22e6c3b5a70fbf8cf6efa1c" translate="yes" xml:space="preserve">
          <source>If you are using Ubuntu/Debian you can apt-get it and activate it as follows:</source>
          <target state="translated">如果你使用的是Ubuntu/Debian,你可以通过apt-get来激活它,如下所示。</target>
        </trans-unit>
        <trans-unit id="4b36ca967cfa9b460140aff96671de743d466f23" translate="yes" xml:space="preserve">
          <source>If you are using a yum based distribution (Fedora, OpenSUSE, etc..) you can install it as follows:</source>
          <target state="translated">如果你使用的是基于yum的发行版(Fedora、OpenSUSE等),你可以按以下方式安装。</target>
        </trans-unit>
        <trans-unit id="dc83f48447e952b93c0c98317102a19a7fa08797" translate="yes" xml:space="preserve">
          <source>If you are using pkgsrc you can install &lt;code&gt;mod_wsgi&lt;/code&gt; by compiling the &lt;code&gt;www/ap2-wsgi&lt;/code&gt; package.</source>
          <target state="translated">如果您使用的是pkgsrc，则可以通过编译 &lt;code&gt;www/ap2-wsgi&lt;/code&gt; 软件包来安装 &lt;code&gt;mod_wsgi&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0e376fa038e0c803c8275548cc9ae5f12cc10a75" translate="yes" xml:space="preserve">
          <source>If you are using the &lt;a href=&quot;https://httpd.apache.org/&quot;&gt;Apache&lt;/a&gt; webserver, consider using &lt;a href=&quot;https://github.com/GrahamDumpleton/mod_wsgi&quot;&gt;mod_wsgi&lt;/a&gt;.</source>
          <target state="translated">如果您使用的是&lt;a href=&quot;https://httpd.apache.org/&quot;&gt;Apache&lt;/a&gt; Web服务器，请考虑使用&lt;a href=&quot;https://github.com/GrahamDumpleton/mod_wsgi&quot;&gt;mod_wsgi&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f3f58b6d97b25c753d9a6cb03bdc6094bc7a147c" translate="yes" xml:space="preserve">
          <source>If you are writing a Flask extension and you want to gracefully degrade for missing blinker installations, you can do so by using the &lt;a href=&quot;../api/index#flask.signals.Namespace&quot;&gt;&lt;code&gt;flask.signals.Namespace&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">如果您正在编写Flask扩展名，并且希望&lt;a href=&quot;../api/index#flask.signals.Namespace&quot;&gt; &lt;code&gt;flask.signals.Namespace&lt;/code&gt; &lt;/a&gt;地降级以减少缺少的方向指示灯安装，则可以使用flask.signals.Namespace类来实现。</target>
        </trans-unit>
        <trans-unit id="553e5056f4833a84f2d74533c13e80af22ab329f" translate="yes" xml:space="preserve">
          <source>If you cannot set ScriptAlias, for example on a shared web host, you can use WSGI middleware to remove yourapplication.fcgi from the URLs. Set .htaccess:</source>
          <target state="translated">如果你不能设置ScriptAlias,例如在共享主机上,你可以使用WSGI中间件从URLs中删除youpprapplication.fcgi。设置.htaccess:</target>
        </trans-unit>
        <trans-unit id="9585482ccb19af109e2e6895fcaacb4025065b15" translate="yes" xml:space="preserve">
          <source>If you check the rules registered on the application, you will find these:</source>
          <target state="translated">如果你查看申请书上登记的规则,你会发现这些。</target>
        </trans-unit>
        <trans-unit id="9cdfb7adca6df23b58ffb2b290a17de455ff40fa" translate="yes" xml:space="preserve">
          <source>If you configured logging after accessing &lt;a href=&quot;../api/index#flask.Flask.logger&quot;&gt;&lt;code&gt;app.logger&lt;/code&gt;&lt;/a&gt;, and need to remove the default handler, you can import and remove it:</source>
          <target state="translated">如果您在访问&lt;a href=&quot;../api/index#flask.Flask.logger&quot;&gt; &lt;code&gt;app.logger&lt;/code&gt; &lt;/a&gt;之后配置了日志记录，并且需要删除默认处理程序，则可以导入和删除它：</target>
        </trans-unit>
        <trans-unit id="bdc1fc64526325d5a34b205d12e7b303d844d3c1" translate="yes" xml:space="preserve">
          <source>If you deploy your application using one of these servers behind an HTTP proxy you will need to rewrite a few headers in order for the application to work. The two problematic values in the WSGI environment usually are &lt;code&gt;REMOTE_ADDR&lt;/code&gt; and &lt;code&gt;HTTP_HOST&lt;/code&gt;. You can configure your httpd to pass these headers, or you can fix them in middleware. Werkzeug ships a fixer that will solve some common setups, but you might want to write your own WSGI middleware for specific setups.</source>
          <target state="translated">如果使用HTTP代理后面的这些服务器之一部署应用程序，则需要重写一些标头才能使应用程序正常工作。 WSGI环境中的两个有问题的值通常是 &lt;code&gt;REMOTE_ADDR&lt;/code&gt; 和 &lt;code&gt;HTTP_HOST&lt;/code&gt; 。您可以将httpd配置为传递这些标头，也可以在中间件中对其进行修复。 Werkzeug附带了一个修复程序，可以解决一些常见的设置，但是您可能想为特定的设置编写自己的WSGI中间件。</target>
        </trans-unit>
        <trans-unit id="c9650994caa19e47753164022096ca4462a7e155" translate="yes" xml:space="preserve">
          <source>If you do not configure logging yourself, Flask will add a &lt;a href=&quot;https://docs.python.org/3/library/logging.handlers.html#logging.StreamHandler&quot;&gt;&lt;code&gt;StreamHandler&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;../api/index#flask.Flask.logger&quot;&gt;&lt;code&gt;app.logger&lt;/code&gt;&lt;/a&gt; automatically. During requests, it will write to the stream specified by the WSGI server in &lt;code&gt;environ['wsgi.errors']&lt;/code&gt; (which is usually &lt;a href=&quot;https://docs.python.org/3/library/sys.html#sys.stderr&quot;&gt;&lt;code&gt;sys.stderr&lt;/code&gt;&lt;/a&gt;). Outside a request, it will log to &lt;a href=&quot;https://docs.python.org/3/library/sys.html#sys.stderr&quot;&gt;&lt;code&gt;sys.stderr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果您未自行配置日志记录，Flask将自动将&lt;a href=&quot;https://docs.python.org/3/library/logging.handlers.html#logging.StreamHandler&quot;&gt; &lt;code&gt;StreamHandler&lt;/code&gt; &lt;/a&gt;添加到&lt;a href=&quot;../api/index#flask.Flask.logger&quot;&gt; &lt;code&gt;app.logger&lt;/code&gt; &lt;/a&gt;。在请求期间，它将写入WSGI服务器在 &lt;code&gt;environ['wsgi.errors']&lt;/code&gt; （通常是&lt;a href=&quot;https://docs.python.org/3/library/sys.html#sys.stderr&quot;&gt; &lt;code&gt;sys.stderr&lt;/code&gt; &lt;/a&gt;）中指定的流。在请求之外，它将记录到&lt;a href=&quot;https://docs.python.org/3/library/sys.html#sys.stderr&quot;&gt; &lt;code&gt;sys.stderr&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="42800215d402d6ad6f4fb87857a824994cd43902" translate="yes" xml:space="preserve">
          <source>If you do not want to install dotenv support, you can still set environment variables by adding them to the end of the virtualenv&amp;rsquo;s &lt;code&gt;activate&lt;/code&gt; script. Activating the virtualenv will set the variables.</source>
          <target state="translated">如果您不想安装dotenv支持，仍然可以通过将环境变量添加到virtualenv的 &lt;code&gt;activate&lt;/code&gt; 脚本的末尾来设置环境变量。激活virtualenv将设置变量。</target>
        </trans-unit>
        <trans-unit id="cc3c79a4c9c9b5c10b4ce8f80d9e628b409d1613" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t have &lt;code&gt;mod_wsgi&lt;/code&gt; installed yet you have to either install it using a package manager or compile it yourself. The mod_wsgi &lt;a href=&quot;https://modwsgi.readthedocs.io/en/develop/installation.html&quot;&gt;installation instructions&lt;/a&gt; cover source installations on UNIX systems.</source>
          <target state="translated">如果尚未安装 &lt;code&gt;mod_wsgi&lt;/code&gt; ，则必须使用程序包管理器进行安装或自行编译。mod_wsgi&lt;a href=&quot;https://modwsgi.readthedocs.io/en/develop/installation.html&quot;&gt;安装说明&lt;/a&gt;涵盖了UNIX系统上的源代码安装。</target>
        </trans-unit>
        <trans-unit id="93adc1acab49b259cd32ddebada6e47f2af38a4a" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t have a factory function for application creation but a singleton instance you can directly import that one as &lt;code&gt;application&lt;/code&gt;.</source>
          <target state="translated">如果您没有用于创建应用程序的工厂功能，而是一个单例实例，则可以直接将其作为 &lt;code&gt;application&lt;/code&gt; 导入。</target>
        </trans-unit>
        <trans-unit id="307e23c151f057568c502436acc39ac4abd781bc" translate="yes" xml:space="preserve">
          <source>If you encounter segfaulting child processes after the first apache reload you can safely ignore them. Just restart the server.</source>
          <target state="translated">如果你在第一次apache重载后遇到segfaulting子进程,你可以安全地忽略它们。只要重启服务器即可。</target>
        </trans-unit>
        <trans-unit id="8c75217263989dfcd00cfc4e4a9621444cf3ce67" translate="yes" xml:space="preserve">
          <source>If you expect users to copy and paste untrusted code from your site, such as from comments posted by users on a technical blog, consider applying extra filtering, such as replacing all &lt;code&gt;\b&lt;/code&gt; characters.</source>
          <target state="translated">如果您希望用户从您的站点复制和粘贴不受信任的代码（例如，从用户在技术博客上发布的评论中），请考虑应用额外的过滤器，例如替换所有 &lt;code&gt;\b&lt;/code&gt; 字符。</target>
        </trans-unit>
        <trans-unit id="cdfb3be234cb5e5650da02e1573931d74ccb3b54" translate="yes" xml:space="preserve">
          <source>If you have Python 2 (&amp;gt;=2.7.9) or Python 3 (&amp;gt;=3.4) installed from python.org, you will already have pip and setuptools on your system. Otherwise, you will need to install them yourself.</source>
          <target state="translated">如果您从python.org安装了Python 2（&amp;gt; = 2.7.9）或Python 3（&amp;gt; = 3.4），则系统上已经具有pip和setuptools。否则，您将需要自己安装它们。</target>
        </trans-unit>
        <trans-unit id="88ed623ec3ed65faf22ecb0d543e474e24ad8192" translate="yes" xml:space="preserve">
          <source>If you have a lot of APIs that look similar you can refactor that registration code:</source>
          <target state="translated">如果你有很多看起来相似的API,你可以重构该注册代码。</target>
        </trans-unit>
        <trans-unit id="f7e31bb4f57d466a15129c019f314e329325344a" translate="yes" xml:space="preserve">
          <source>If you have code that wants to test if a request context is there or not this function can be used. For instance, you may want to take advantage of request information if the request object is available, but fail silently if it is unavailable.</source>
          <target state="translated">如果你有代码想测试请求上下文是否存在,可以使用这个函数。例如,如果请求对象可用,你可能想利用请求信息,但如果不可用,则默默失败。</target>
        </trans-unit>
        <trans-unit id="1dafb2bf56c64d419d8e7631b6bd92c13ea7bf23" translate="yes" xml:space="preserve">
          <source>If you have entirely separated applications and you want them to work next to each other in the same Python interpreter process you can take advantage of the &lt;code&gt;werkzeug.wsgi.DispatcherMiddleware&lt;/code&gt;. The idea here is that each Flask application is a valid WSGI application and they are combined by the dispatcher middleware into a larger one that is dispatched based on prefix.</source>
          <target state="translated">如果您具有完全独立的应用程序，并且希望它们在同一Python解释器过程中彼此相邻工作，则可以利用 &lt;code&gt;werkzeug.wsgi.DispatcherMiddleware&lt;/code&gt; 。这里的想法是，每个Flask应用程序都是有效的WSGI应用程序，并且它们由调度程序中间件组合成一个更大的，基于前缀进行调度的中间件。</target>
        </trans-unit>
        <trans-unit id="476fdcd8b823b06bac47338f95c8703da0e03ae7" translate="yes" xml:space="preserve">
          <source>If you have installed your project as a package in your virtualenv, you may untick the &lt;em&gt;PYTHONPATH&lt;/em&gt; options (&lt;strong&gt;E&lt;/strong&gt;). This will more accurately match how you deploy the app later.</source>
          <target state="translated">如果您将项目作为软件包安装在virtualenv中，则可以取消选中&lt;em&gt;PYTHONPATH&lt;/em&gt;选项（&lt;strong&gt;E&lt;/strong&gt;）。这将更准确地匹配您以后部署应用程序的方式。</target>
        </trans-unit>
        <trans-unit id="e1653eb5ec96c1e8635e8651ec817c540d1a67dd" translate="yes" xml:space="preserve">
          <source>If you have larger applications it&amp;rsquo;s recommended to divide them into smaller groups where each group is implemented with the help of a blueprint. For a gentle introduction into this topic refer to the &lt;a href=&quot;../../blueprints/index#blueprints&quot;&gt;Modular Applications with Blueprints&lt;/a&gt; chapter of the documentation.</source>
          <target state="translated">如果您有较大的应用程序，建议将它们分成较小的组，其中每个组都借助蓝图来实现。有关此主题的简要介绍，请参阅文档的&amp;ldquo;&lt;a href=&quot;../../blueprints/index#blueprints&quot;&gt;带有蓝图&lt;/a&gt;的模块化应用程序&amp;rdquo;一章。</target>
        </trans-unit>
        <trans-unit id="6651c3a3875b773378ad04562b73593e3cee14ff" translate="yes" xml:space="preserve">
          <source>If you have set &lt;a href=&quot;#flask.Flask.secret_key&quot;&gt;&lt;code&gt;Flask.secret_key&lt;/code&gt;&lt;/a&gt; (or configured it from &lt;a href=&quot;../config/index#SECRET_KEY&quot;&gt;&lt;code&gt;SECRET_KEY&lt;/code&gt;&lt;/a&gt;) you can use sessions in Flask applications. A session makes it possible to remember information from one request to another. The way Flask does this is by using a signed cookie. The user can look at the session contents, but can&amp;rsquo;t modify it unless they know the secret key, so make sure to set that to something complex and unguessable.</source>
          <target state="translated">如果已设置&lt;a href=&quot;#flask.Flask.secret_key&quot;&gt; &lt;code&gt;Flask.secret_key&lt;/code&gt; &lt;/a&gt;（或从&lt;a href=&quot;../config/index#SECRET_KEY&quot;&gt; &lt;code&gt;SECRET_KEY&lt;/code&gt; &lt;/a&gt;对其进行配置），则可以在Flask应用程序中使用会话。会话可以记住从一个请求到另一个请求的信息。Flask这样做的方法是使用签名的Cookie。用户可以查看会话的内容，但除非知道密钥，否则无法对其进行修改，因此请确保将其设置为复杂且不可猜测的内容。</target>
        </trans-unit>
        <trans-unit id="fe0442ba81679eb326d885d32676b0d88221f3d4" translate="yes" xml:space="preserve">
          <source>If you have some kind of access control on your website, you will have to send a 403 code for disallowed resources. So make sure the user is not lost when they try to access a forbidden resource.</source>
          <target state="translated">如果你的网站上有某种访问控制,你将不得不为不允许的资源发送403代码。所以要确保用户在试图访问一个被禁止的资源时不会丢失。</target>
        </trans-unit>
        <trans-unit id="f8237ece87c90acb957451dd7d2ad3aba03ce6fc" translate="yes" xml:space="preserve">
          <source>If you have the debugger disabled or trust the users on your network, you can make the server publicly available simply by adding &lt;code&gt;--host=0.0.0.0&lt;/code&gt; to the command line:</source>
          <target state="translated">如果禁用了调试器或信任网络上的用户，则只需在命令行中添加 &lt;code&gt;--host=0.0.0.0&lt;/code&gt; ，即可使服务器公开可用：</target>
        </trans-unit>
        <trans-unit id="249980b516ada72dffc8e39ca9c73f55c7281f27" translate="yes" xml:space="preserve">
          <source>If you jumped in and already executed the above code you will be disappointed to learn that &lt;code&gt;.wait()&lt;/code&gt; will never actually return. That&amp;rsquo;s because you also need to run a Celery worker to receive and execute the task.</source>
          <target state="translated">如果您跳入并已经执行了上面的代码，您将会失望地得知 &lt;code&gt;.wait()&lt;/code&gt; 永远不会真正返回。那是因为您还需要运行Celery worker来接收和执行任务。</target>
        </trans-unit>
        <trans-unit id="e17aad03294930c5140831c228fd7197c0d43813" translate="yes" xml:space="preserve">
          <source>If you just want to use the database system (and SQL) abstraction layer you basically only need the engine:</source>
          <target state="translated">如果你只是想使用数据库系统(和SQL)抽象层,你基本上只需要引擎。</target>
        </trans-unit>
        <trans-unit id="fc606ff9e7aacfa08c04fa0cc3ea7bf283b96a15" translate="yes" xml:space="preserve">
          <source>If you like the idea of experimenting in a shell, create yourself a module with stuff you want to star import into your interactive session. There you could also define some more helper methods for common things such as initializing the database, dropping tables etc.</source>
          <target state="translated">如果你喜欢在shell中做实验,可以给自己创建一个模块,把你想导入到交互式会话中的东西。在那里,你还可以为一些常见的东西定义更多的帮助方法,如初始化数据库,删除表等。</target>
        </trans-unit>
        <trans-unit id="81d2e43c4dcde8f9dadce345b61944837c543b0f" translate="yes" xml:space="preserve">
          <source>If you need to access the underlying object that is proxied, use the &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/local/#werkzeug.local.LocalProxy._get_current_object&quot;&gt;&lt;code&gt;_get_current_object()&lt;/code&gt;&lt;/a&gt; method:</source>
          <target state="translated">如果需要访问代理的基础对象，请使用&lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/local/#werkzeug.local.LocalProxy._get_current_object&quot;&gt; &lt;code&gt;_get_current_object()&lt;/code&gt; &lt;/a&gt;方法：</target>
        </trans-unit>
        <trans-unit id="f8ef25fedb0b44627be8cf2392c6bac0af65e086" translate="yes" xml:space="preserve">
          <source>If you needed to install virtualenv because you are using Python 2, use the following command instead:</source>
          <target state="translated">如果你因为使用Python 2而需要安装virtualenv,请使用以下命令。</target>
        </trans-unit>
        <trans-unit id="f33ac8c6fc2ecc57036b02266964caff8c301760" translate="yes" xml:space="preserve">
          <source>If you now run the application everything should work as expected.</source>
          <target state="translated">如果你现在运行该应用程序,一切都应按预期工作。</target>
        </trans-unit>
        <trans-unit id="6d829b2cf50cf1501eb55932e0d6e22491fe29f1" translate="yes" xml:space="preserve">
          <source>If you run the server you will notice that the server is only accessible from your own computer, not from any other in the network. This is the default because in debugging mode a user of the application can execute arbitrary Python code on your computer.</source>
          <target state="translated">如果你运行服务器,你会注意到服务器只能从你自己的计算机上访问,而不能从网络中的任何其他计算机上访问。这是默认的,因为在调试模式下,应用程序的用户可以在您的计算机上执行任意的 Python 代码。</target>
        </trans-unit>
        <trans-unit id="43928e81f417368cb76267b933247924027eab84" translate="yes" xml:space="preserve">
          <source>If you see that error somewhere else in your code not related to configuring the application, it most likely indicates that you should move that code into a view function or CLI command.</source>
          <target state="translated">如果你在你的代码中其他与配置应用程序无关的地方看到这个错误,它很可能表明你应该将该代码移到视图函数或CLI命令中。</target>
        </trans-unit>
        <trans-unit id="a7de48bf64fc228c6fa81458e4091d199f3c216a" translate="yes" xml:space="preserve">
          <source>If you see that error somewhere else in your code not related to testing, it most likely indicates that you should move that code into a view function.</source>
          <target state="translated">如果你在你的代码中其他与测试无关的地方看到了这个错误,很可能说明你应该把这个代码移到一个视图函数中。</target>
        </trans-unit>
        <trans-unit id="3ee901b3302c6ea14fdc06685ef3fd455827da3d" translate="yes" xml:space="preserve">
          <source>If you see that error while configuring your application, such as when initializing an extension, you can push a context manually since you have direct access to the &lt;code&gt;app&lt;/code&gt;. Use &lt;a href=&quot;../api/index#flask.Flask.app_context&quot;&gt;&lt;code&gt;app_context()&lt;/code&gt;&lt;/a&gt; in a &lt;code&gt;with&lt;/code&gt; block, and everything that runs in the block will have access to &lt;a href=&quot;../api/index#flask.current_app&quot;&gt;&lt;code&gt;current_app&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果在配置应用程序时（例如在初始化扩展程序时）看到该错误，则可以直接推送上下文，因为您可以直接访问该 &lt;code&gt;app&lt;/code&gt; 。在 &lt;code&gt;with&lt;/code&gt; 块中使用&lt;a href=&quot;../api/index#flask.Flask.app_context&quot;&gt; &lt;code&gt;app_context()&lt;/code&gt; &lt;/a&gt;，该块中运行的所有内容都可以访问&lt;a href=&quot;../api/index#flask.current_app&quot;&gt; &lt;code&gt;current_app&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c19211113a809a6218f269f2bc321b205e480fcf" translate="yes" xml:space="preserve">
          <source>If you try to access &lt;a href=&quot;../api/index#flask.current_app&quot;&gt;&lt;code&gt;current_app&lt;/code&gt;&lt;/a&gt;, or anything that uses it, outside an application context, you&amp;rsquo;ll get this error message:</source>
          <target state="translated">如果您尝试在应用程序上下文之外访问&lt;a href=&quot;../api/index#flask.current_app&quot;&gt; &lt;code&gt;current_app&lt;/code&gt; &lt;/a&gt;或使用current_app的任何内容，则会收到以下错误消息：</target>
        </trans-unit>
        <trans-unit id="951ac7d580116b322955b44977c7c126d2cc117b" translate="yes" xml:space="preserve">
          <source>If you try to access &lt;a href=&quot;../api/index#flask.request&quot;&gt;&lt;code&gt;request&lt;/code&gt;&lt;/a&gt;, or anything that uses it, outside a request context, you&amp;rsquo;ll get this error message:</source>
          <target state="translated">如果您尝试在请求上下文之外访问&lt;a href=&quot;../api/index#flask.request&quot;&gt; &lt;code&gt;request&lt;/code&gt; &lt;/a&gt;或使用该请求的任何内容，则会收到以下错误消息：</target>
        </trans-unit>
        <trans-unit id="6054e5badf3fc594e148836d03a3a0bf5da7fb52" translate="yes" xml:space="preserve">
          <source>If you try to install the package you just created, you will notice that folders like &lt;code&gt;static&lt;/code&gt; or &lt;code&gt;templates&lt;/code&gt; are not installed for you. The reason for this is that setuptools does not know which files to add for you. What you should do, is to create a &lt;code&gt;MANIFEST.in&lt;/code&gt; file next to your &lt;code&gt;setup.py&lt;/code&gt; file. This file lists all the files that should be added to your tarball:</source>
          <target state="translated">如果尝试安装刚刚创建的软件包，则会注意到没有为您安装 &lt;code&gt;static&lt;/code&gt; 文件夹或 &lt;code&gt;templates&lt;/code&gt; 文件夹。这样做的原因是setuptools不知道要为您添加哪些文件。您应该做的是在 &lt;code&gt;setup.py&lt;/code&gt; 文件旁边创建一个 &lt;code&gt;MANIFEST.in&lt;/code&gt; 文件。此文件列出了应添加到压缩包中的所有文件：</target>
        </trans-unit>
        <trans-unit id="2a140984b273518611179beb6e590d938b4854fd" translate="yes" xml:space="preserve">
          <source>If you want the blueprint to expose templates you can do that by providing the &lt;code&gt;template_folder&lt;/code&gt; parameter to the &lt;a href=&quot;../api/index#flask.Blueprint&quot;&gt;&lt;code&gt;Blueprint&lt;/code&gt;&lt;/a&gt; constructor:</source>
          <target state="translated">如果希望蓝图公开模板，则可以通过向&lt;a href=&quot;../api/index#flask.Blueprint&quot;&gt; &lt;code&gt;Blueprint&lt;/code&gt; &lt;/a&gt;构造函数提供 &lt;code&gt;template_folder&lt;/code&gt; 参数来实现：</target>
        </trans-unit>
        <trans-unit id="5652697cea75cf4c5422d8950a8746ef87e8debe" translate="yes" xml:space="preserve">
          <source>If you want to call the &lt;a href=&quot;../api/index#flask.Flask.after_request&quot;&gt;&lt;code&gt;after_request()&lt;/code&gt;&lt;/a&gt; functions you need to call into &lt;a href=&quot;../api/index#flask.Flask.process_response&quot;&gt;&lt;code&gt;process_response()&lt;/code&gt;&lt;/a&gt; which however requires that you pass it a response object:</source>
          <target state="translated">如果要调用&lt;a href=&quot;../api/index#flask.Flask.after_request&quot;&gt; &lt;code&gt;after_request()&lt;/code&gt; &lt;/a&gt;函数，则需要调用&lt;a href=&quot;../api/index#flask.Flask.process_response&quot;&gt; &lt;code&gt;process_response()&lt;/code&gt; &lt;/a&gt;，但这需要您向其传递一个响应对象：</target>
        </trans-unit>
        <trans-unit id="7a758a07c4bf8a253787c4ccbe67cf9509c26024" translate="yes" xml:space="preserve">
          <source>If you want to deploy your Flask application to a WSGI server not listed here, look up the server documentation about how to use a WSGI app with it. Just remember that your &lt;code&gt;Flask&lt;/code&gt; application object is the actual WSGI application.</source>
          <target state="translated">如果要将Flask应用程序部署到此处未列出的WSGI服务器，请查找有关如何将WSGI应用程序与其一起使用的服务器文档。只要记住您的 &lt;code&gt;Flask&lt;/code&gt; 应用程序对象就是实际的WSGI应用程序即可。</target>
        </trans-unit>
        <trans-unit id="bb83979c74569ff78bd1dbc50256e8073ffa9b52" translate="yes" xml:space="preserve">
          <source>If you want to deploy your flask application inside of a virtual environment, you need to also add &lt;code&gt;--virtualenv /path/to/virtual/environment&lt;/code&gt;. You might also need to add &lt;code&gt;--plugin python&lt;/code&gt; or &lt;code&gt;--plugin python3&lt;/code&gt; depending on which python version you use for your project.</source>
          <target state="translated">如果要在虚拟环境中部署 &lt;code&gt;--virtualenv /path/to/virtual/environment&lt;/code&gt; 应用程序，则还需要添加--virtualenv / path / to / virtual / environment。您可能还需要添加 &lt;code&gt;--plugin python&lt;/code&gt; 或 &lt;code&gt;--plugin python3&lt;/code&gt; ,具体取决于您用于项目的python版本。</target>
        </trans-unit>
        <trans-unit id="266081d732e8ddad2d7b5eb73b5d7c542ed250dc" translate="yes" xml:space="preserve">
          <source>If you want to emit a signal, you can do so by calling the &lt;a href=&quot;https://pythonhosted.org/blinker/index.html#blinker.base.Signal.send&quot;&gt;&lt;code&gt;send()&lt;/code&gt;&lt;/a&gt; method. It accepts a sender as first argument and optionally some keyword arguments that are forwarded to the signal subscribers:</source>
          <target state="translated">如果要发出信号，可以通过调用&lt;a href=&quot;https://pythonhosted.org/blinker/index.html#blinker.base.Signal.send&quot;&gt; &lt;code&gt;send()&lt;/code&gt; &lt;/a&gt;方法来发出。它接受发送方作为第一个参数，还可以选择将某些关键字参数转发给信号订阅者：</target>
        </trans-unit>
        <trans-unit id="4f389484c0af76dadf7be481884c5b23cdff3205" translate="yes" xml:space="preserve">
          <source>If you want to get hold of the resulting response object inside the view you can use the &lt;a href=&quot;../api/index#flask.make_response&quot;&gt;&lt;code&gt;make_response()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">如果要在视图中保留结果响应对象，可以使用&lt;a href=&quot;../api/index#flask.make_response&quot;&gt; &lt;code&gt;make_response()&lt;/code&gt; &lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="ea5d120c1f26054cc66fe7b9c27635f172637c5e" translate="yes" xml:space="preserve">
          <source>If you want to know how the file was named on the client before it was uploaded to your application, you can access the &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.FileStorage.filename&quot;&gt;&lt;code&gt;filename&lt;/code&gt;&lt;/a&gt; attribute. However please keep in mind that this value can be forged so never ever trust that value. If you want to use the filename of the client to store the file on the server, pass it through the &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/utils/#werkzeug.utils.secure_filename&quot;&gt;&lt;code&gt;secure_filename()&lt;/code&gt;&lt;/a&gt; function that Werkzeug provides for you:</source>
          <target state="translated">如果您想知道文件在上传到应用程序之前是如何在客户端上命名的，则可以访问&lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.FileStorage.filename&quot;&gt; &lt;code&gt;filename&lt;/code&gt; &lt;/a&gt;属性。但是，请记住，可以伪造该价值，所以永远不要相信该价值。如果要使用客户端的文件&lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/utils/#werkzeug.utils.secure_filename&quot;&gt; &lt;code&gt;secure_filename()&lt;/code&gt; &lt;/a&gt;文件存储在服务器上，请通过Werkzeug为您提供的secure_filename（）函数传递该文件：</target>
        </trans-unit>
        <trans-unit id="57091f57d493a9a887301eab5ca0e16299c0bc94" translate="yes" xml:space="preserve">
          <source>If you want to link from one page to another you can use the &lt;a href=&quot;../api/index#flask.url_for&quot;&gt;&lt;code&gt;url_for()&lt;/code&gt;&lt;/a&gt; function just like you normally would do just that you prefix the URL endpoint with the name of the blueprint and a dot (&lt;code&gt;.&lt;/code&gt;):</source>
          <target state="translated">如果要从一个页面链接到另一页面，则可以像通常那样使用&lt;a href=&quot;../api/index#flask.url_for&quot;&gt; &lt;code&gt;url_for()&lt;/code&gt; &lt;/a&gt;函数，只是在URL端点之前加上蓝图的名称和点（ &lt;code&gt;.&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="ae9ca687ddc6af9f356cb0011bd9ba7d7accbc34" translate="yes" xml:space="preserve">
          <source>If you want to open the &lt;code&gt;schema.sql&lt;/code&gt; file you would do the following:</source>
          <target state="translated">如果要打开 &lt;code&gt;schema.sql&lt;/code&gt; 文件，请执行以下操作：</target>
        </trans-unit>
        <trans-unit id="dd3f233355c8a49daaeb5108efa180a2b3574b0e" translate="yes" xml:space="preserve">
          <source>If you want to register your own filters in Jinja2 you have two ways to do that. You can either put them by hand into the &lt;a href=&quot;../api/index#flask.Flask.jinja_env&quot;&gt;&lt;code&gt;jinja_env&lt;/code&gt;&lt;/a&gt; of the application or use the &lt;a href=&quot;../api/index#flask.Flask.template_filter&quot;&gt;&lt;code&gt;template_filter()&lt;/code&gt;&lt;/a&gt; decorator.</source>
          <target state="translated">如果要在Jinja2中注册自己的过滤器，则有两种方法可以执行此操作。您可以将它们手动放入应用程序的&lt;a href=&quot;../api/index#flask.Flask.jinja_env&quot;&gt; &lt;code&gt;jinja_env&lt;/code&gt; &lt;/a&gt;中，也可以使用&lt;a href=&quot;../api/index#flask.Flask.template_filter&quot;&gt; &lt;code&gt;template_filter()&lt;/code&gt; &lt;/a&gt;装饰器。</target>
        </trans-unit>
        <trans-unit id="3a95307c3ad42d63881837086b31152e65b7d4b5" translate="yes" xml:space="preserve">
          <source>If you want to replace the response object used you can subclass this and set &lt;a href=&quot;#flask.Flask.response_class&quot;&gt;&lt;code&gt;response_class&lt;/code&gt;&lt;/a&gt; to your subclass.</source>
          <target state="translated">如果要替换使用的响应对象，则可以对此子类化，并将&lt;a href=&quot;#flask.Flask.response_class&quot;&gt; &lt;code&gt;response_class&lt;/code&gt; &lt;/a&gt;设置为子类。</target>
        </trans-unit>
        <trans-unit id="c03a001b7d5eed01bb42fd0ba181ada334f466ed" translate="yes" xml:space="preserve">
          <source>If you want to rewrite the headers from another header, you might want to use a fixer like this:</source>
          <target state="translated">如果你想从另一个头部重写头部,你可能会想使用这样的固定器。</target>
        </trans-unit>
        <trans-unit id="2c1bc28a4e905e59f5d770c96f991f9c6f2554b1" translate="yes" xml:space="preserve">
          <source>If you want to run the application in debug mode, but disable the code execution on the interactive debugger, you can pass &lt;code&gt;use_evalex=False&lt;/code&gt; as parameter. This will keep the debugger&amp;rsquo;s traceback screen active, but disable code execution.</source>
          <target state="translated">如果要在调试模式下运行应用程序，但在交互式调试器上禁用代码执行，则可以传递 &lt;code&gt;use_evalex=False&lt;/code&gt; 作为参数。这将使调试器的&amp;ldquo;回溯&amp;rdquo;屏幕保持活动状态，但会禁用代码执行。</target>
        </trans-unit>
        <trans-unit id="b28b1962dd4894c90266ce17ca0de37acd772613" translate="yes" xml:space="preserve">
          <source>If you want to save the extra redirect request you can also write a view using &lt;a href=&quot;../../api/index#flask.send_from_directory&quot;&gt;&lt;code&gt;send_from_directory()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">如果要保存额外的重定向请求，还可以使用&lt;a href=&quot;../../api/index#flask.send_from_directory&quot;&gt; &lt;code&gt;send_from_directory()&lt;/code&gt; &lt;/a&gt;编写视图：</target>
        </trans-unit>
        <trans-unit id="6f614f397083cd0433465bf767f66fba7c023eb3" translate="yes" xml:space="preserve">
          <source>If you want to test how your command parses parameters, without running the command, use its &lt;a href=&quot;https://click.palletsprojects.com/en/7.x/api/#click.BaseCommand.make_context&quot;&gt;&lt;code&gt;make_context()&lt;/code&gt;&lt;/a&gt; method. This is useful for testing complex validation rules and custom types.</source>
          <target state="translated">如果要测试命令如何解析参数，而不运行命令，请使用其&lt;a href=&quot;https://click.palletsprojects.com/en/7.x/api/#click.BaseCommand.make_context&quot;&gt; &lt;code&gt;make_context()&lt;/code&gt; &lt;/a&gt;方法。这对于测试复杂的验证规则和自定义类型很有用。</target>
        </trans-unit>
        <trans-unit id="3a69b23ca1863fb3bb57ffcb51d80f4edc10b1d9" translate="yes" xml:space="preserve">
          <source>If you want to test your application with different configurations and there does not seem to be a good way to do that, consider switching to application factories (see &lt;a href=&quot;../patterns/appfactories/index#app-factories&quot;&gt;Application Factories&lt;/a&gt;).</source>
          <target state="translated">如果您想使用不同的配置来测试您的应用程序，并且似乎没有一个很好的方法，请考虑切换到应用程序工厂（请参阅&lt;a href=&quot;../patterns/appfactories/index#app-factories&quot;&gt;Application Factories&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="989be5c812c5bfb4e6ce2a64a5bad8f15da23918" translate="yes" xml:space="preserve">
          <source>If you want to understand how that works and how you can implement tests with context locals, read this section, otherwise just skip it.</source>
          <target state="translated">如果你想了解它是如何工作的,以及如何用上下文locals实现测试,请阅读本节,否则直接跳过它。</target>
        </trans-unit>
        <trans-unit id="dd1ae53b74aa02f5556f98bc0abcbe935fced296" translate="yes" xml:space="preserve">
          <source>If you want to use signals in your own application, you can use the blinker library directly. The most common use case are named signals in a custom &lt;a href=&quot;https://pythonhosted.org/blinker/index.html#blinker.base.Namespace&quot;&gt;&lt;code&gt;Namespace&lt;/code&gt;&lt;/a&gt;.. This is what is recommended most of the time:</source>
          <target state="translated">如果要在自己的应用程序中使用信号，则可以直接使用信号灯库。最常见的用例是自定义&lt;a href=&quot;https://pythonhosted.org/blinker/index.html#blinker.base.Namespace&quot;&gt; &lt;code&gt;Namespace&lt;/code&gt; &lt;/a&gt;中的命名信号..多数时候建议这样做：</target>
        </trans-unit>
        <trans-unit id="e4d42ef867df69e137a44ba4b2679138e302c40e" translate="yes" xml:space="preserve">
          <source>If you want to work with the latest Flask code before it&amp;rsquo;s released, install or update the code from the master branch:</source>
          <target state="translated">如果要在发布之前使用最新的Flask代码，请从master分支安装或更新代码：</target>
        </trans-unit>
        <trans-unit id="0cfbbef4408be03ee6b7586f8c791aa0d8da0799" translate="yes" xml:space="preserve">
          <source>If you were to use just the &lt;a href=&quot;../api/index#flask.Flask.test_client&quot;&gt;&lt;code&gt;test_client()&lt;/code&gt;&lt;/a&gt; without the &lt;code&gt;with&lt;/code&gt; block, the &lt;code&gt;assert&lt;/code&gt; would fail with an error because &lt;code&gt;request&lt;/code&gt; is no longer available (because you are trying to use it outside of the actual request).</source>
          <target state="translated">如果您仅使用不 &lt;code&gt;with&lt;/code&gt; 块的&lt;a href=&quot;../api/index#flask.Flask.test_client&quot;&gt; &lt;code&gt;test_client()&lt;/code&gt; &lt;/a&gt;，则 &lt;code&gt;assert&lt;/code&gt; 将失败并显示错误，因为 &lt;code&gt;request&lt;/code&gt; 不再可用（因为您尝试在实际请求之外使用它）。</target>
        </trans-unit>
        <trans-unit id="16ecce3d5e3b8937b15a7b52156486d8ae60bd7f" translate="yes" xml:space="preserve">
          <source>If you write a web application, you are probably allowing users to register and leave their data on your server. The users are entrusting you with data. And even if you are the only user that might leave data in your application, you still want that data to be stored securely.</source>
          <target state="translated">如果你写了一个Web应用程序,你可能允许用户注册并将他们的数据留在你的服务器上。用户将数据委托给你。即使你是唯一一个可能在你的应用程序中留下数据的用户,你仍然希望这些数据能够安全地存储。</target>
        </trans-unit>
        <trans-unit id="1c7fdda2be55b609021b1c88a23501a501c53dda" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re sure a command doesn&amp;rsquo;t need the context, you can disable it:</source>
          <target state="translated">如果确定命令不需要上下文，则可以将其禁用：</target>
        </trans-unit>
        <trans-unit id="6a4352e0a01e2fd8539ca434fb09c91e01ec7715" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using Python 2, see &lt;a href=&quot;#install-install-virtualenv&quot;&gt;Install virtualenv&lt;/a&gt; first.</source>
          <target state="translated">如果您使用的是Python 2，请参阅先&lt;a href=&quot;#install-install-virtualenv&quot;&gt;安装virtualenv&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="404d8c1065fa5ee6b0eb42367ed216d47476da77" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re writing an extension, &lt;a href=&quot;../api/index#flask.g&quot;&gt;&lt;code&gt;g&lt;/code&gt;&lt;/a&gt; should be reserved for user code. You may store internal data on the context itself, but be sure to use a sufficiently unique name. The current context is accessed with &lt;a href=&quot;../api/index#flask._app_ctx_stack&quot;&gt;&lt;code&gt;_app_ctx_stack.top&lt;/code&gt;&lt;/a&gt;. For more information see &lt;a href=&quot;https://flask.palletsprojects.com/en/1.1.x/extensiondev/&quot;&gt;Flask Extension Development&lt;/a&gt;.</source>
          <target state="translated">如果要编写扩展名，则&lt;a href=&quot;../api/index#flask.g&quot;&gt; &lt;code&gt;g&lt;/code&gt; &lt;/a&gt;应该保留给用户代码。您可以在上下文本身上存储内部数据，但是请确保使用足够唯一的名称。当前上下文是通过&lt;a href=&quot;../api/index#flask._app_ctx_stack&quot;&gt; &lt;code&gt;_app_ctx_stack.top&lt;/code&gt; &lt;/a&gt;访问的。有关更多信息，请参见&lt;a href=&quot;https://flask.palletsprojects.com/en/1.1.x/extensiondev/&quot;&gt;Flask Extension开发&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6ad131b940cea2ffb3f6e383c7667fd61c14d608" translate="yes" xml:space="preserve">
          <source>If your application does not run, follow this guide to troubleshoot:</source>
          <target state="translated">如果您的应用程序无法运行,请按照本指南进行故障排除。</target>
        </trans-unit>
        <trans-unit id="028b976df40bbe620fd765be745d6deb46dd24bc" translate="yes" xml:space="preserve">
          <source>If your application has a long running task, such as processing some uploaded data or sending email, you don&amp;rsquo;t want to wait for it to finish during a request. Instead, use a task queue to send the necessary data to another process that will run the task in the background while the request returns immediately.</source>
          <target state="translated">如果您的应用程序具有长期运行的任务，例如处理一些上载的数据或发送电子邮件，则您不希望在请求期间等待它完成。而是使用任务队列将必要的数据发送到另一个进程，该进程将在请求立即返回时在后台运行任务。</target>
        </trans-unit>
        <trans-unit id="91646c604aaf61cd274d49d5c350384ddfcfc816" translate="yes" xml:space="preserve">
          <source>If your application is placed outside the URL root, for example, in &lt;code&gt;/myapplication&lt;/code&gt; instead of &lt;code&gt;/&lt;/code&gt;, &lt;a href=&quot;../api/index#flask.url_for&quot;&gt;&lt;code&gt;url_for()&lt;/code&gt;&lt;/a&gt; properly handles that for you.</source>
          <target state="translated">如果您的应用程序放置在URL根目录之外，例如，在 &lt;code&gt;/myapplication&lt;/code&gt; 而不是 &lt;code&gt;/&lt;/code&gt; 中，则&lt;a href=&quot;../api/index#flask.url_for&quot;&gt; &lt;code&gt;url_for()&lt;/code&gt; &lt;/a&gt;会为您正确处理。</target>
        </trans-unit>
        <trans-unit id="4921ca0697900eeb749b9076609831e9b98fdc87" translate="yes" xml:space="preserve">
          <source>If your application uses blueprints, you can optionally register CLI commands directly onto them. When your blueprint is registered onto your application, the associated commands will be available to the &lt;code&gt;flask&lt;/code&gt; command. By default, those commands will be nested in a group matching the name of the blueprint.</source>
          <target state="translated">如果您的应用程序使用蓝图，则可以选择将CLI命令直接注册到蓝图上。当将蓝图注册到应用程序时，关联的命令将对 &lt;code&gt;flask&lt;/code&gt; 命令可用。默认情况下，这些命令将嵌套在与蓝图名称匹配的组中。</target>
        </trans-unit>
        <trans-unit id="d1a57896007ffdb723f20550d45492283a4d7b00" translate="yes" xml:space="preserve">
          <source>If your authentication information is stored in cookies, you have implicit state management. The state of &amp;ldquo;being logged in&amp;rdquo; is controlled by a cookie, and that cookie is sent with each request to a page. Unfortunately that includes requests triggered by 3rd party sites. If you don&amp;rsquo;t keep that in mind, some people might be able to trick your application&amp;rsquo;s users with social engineering to do stupid things without them knowing.</source>
          <target state="translated">如果您的身份验证信息存储在cookie中，则您具有隐式状态管理。&amp;ldquo;正在登录&amp;rdquo;的状态由cookie控制，并且该cookie与每个请求一起发送到页面。不幸的是，其中包括由第三方网站触发的请求。如果您不注意这一点，那么有些人可能会利用社交工程欺骗您的应用程序用户，以在他们不知情的情况下做一些愚蠢的事情。</target>
        </trans-unit>
        <trans-unit id="8f2466412cb839c4d7eb2512ff967ac43dd9ceb9" translate="yes" xml:space="preserve">
          <source>If your httpd is not providing these headers, the most common setup invokes the host being set from &lt;code&gt;X-Forwarded-Host&lt;/code&gt; and the remote address from &lt;code&gt;X-Forwarded-For&lt;/code&gt;:</source>
          <target state="translated">如果您的httpd没有提供这些标头，则最常见的设置是从 &lt;code&gt;X-Forwarded-Host&lt;/code&gt; 调用正在设置的主机，并从 &lt;code&gt;X-Forwarded-For&lt;/code&gt; 调用远程地址：</target>
        </trans-unit>
        <trans-unit id="b1005382f6dd634a8bcd5186bf880f16e628964c" translate="yes" xml:space="preserve">
          <source>Imagine a simple flask application structure that looks like this:</source>
          <target state="translated">想象一下,一个简单的烧瓶应用结构是这样的。</target>
        </trans-unit>
        <trans-unit id="c5987b63360b1505af1f6f644b071b7324631601" translate="yes" xml:space="preserve">
          <source>Imagine the context being the handling thread. A request comes in and the web server decides to spawn a new thread (or something else, the underlying object is capable of dealing with concurrency systems other than threads). When Flask starts its internal request handling it figures out that the current thread is the active context and binds the current application and the WSGI environments to that context (thread). It does that in an intelligent way so that one application can invoke another application without breaking.</source>
          <target state="translated">想象一下,上下文是处理线程。一个请求进来,Web服务器决定催生一个新的线程(或者其他东西,底层对象能够处理线程以外的并发系统)。当Flask启动其内部请求处理时,它发现当前线程是活动的上下文,并将当前应用程序和WSGI环境绑定到该上下文(线程)。它以一种智能的方式做到这一点,因此一个应用程序可以调用另一个应用程序而不会中断。</target>
        </trans-unit>
        <trans-unit id="8ee29fac1da44d1534db670c1308d623c0d21722" translate="yes" xml:space="preserve">
          <source>Imagine the current application looks somewhat like this:</source>
          <target state="translated">想象一下,当前的应用程序看起来有点像这样。</target>
        </trans-unit>
        <trans-unit id="6cb396aab14e2db2a72b02ec8e4fa59c156d0341" translate="yes" xml:space="preserve">
          <source>Imagine you have a view function that does an expensive calculation and because of that you would like to cache the generated results for a certain amount of time. A decorator would be nice for that. We&amp;rsquo;re assuming you have set up a cache like mentioned in &lt;a href=&quot;../caching/index#caching-pattern&quot;&gt;Caching&lt;/a&gt;.</source>
          <target state="translated">想象一下，您有一个视图函数进行了昂贵的计算，因此您希望将生成的结果缓存一定的时间。一个装饰器将是很好的。我们假设您已经建立了如&lt;a href=&quot;../caching/index#caching-pattern&quot;&gt;Caching中&lt;/a&gt;提到的缓存。</target>
        </trans-unit>
        <trans-unit id="4898404cca5d33b8c20842217a5897be983c4254" translate="yes" xml:space="preserve">
          <source>Imagine you have a view like this:</source>
          <target state="translated">想象一下,你有这样的景色。</target>
        </trans-unit>
        <trans-unit id="1bf2322d08f9f1a8a802891a6c6d8e95780b6e4c" translate="yes" xml:space="preserve">
          <source>Imagine you were to run Facebook with millions of concurrent users and someone would send out links to images of little kittens. When users would go to that page, their profiles would get deleted while they are looking at images of fluffy cats.</source>
          <target state="translated">想象一下,你要运营拥有数百万并发用户的Facebook,有人会发送小猫咪图片的链接。当用户进入该页面时,他们的个人资料会被删除,而他们正在看毛茸茸的猫咪图片。</target>
        </trans-unit>
        <trans-unit id="e39c13bd818be5be95bbe5c6321b207111707057" translate="yes" xml:space="preserve">
          <source>Implement this method in a subclass such that it returns a serializable object for &lt;code&gt;o&lt;/code&gt;, or calls the base implementation (to raise a &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">在子类中实现此方法，以使其返回 &lt;code&gt;o&lt;/code&gt; 的可序列化对象，或调用基本实现（引发&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="29edfa5feaf01dc70cef75173aade05bbda715da" translate="yes" xml:space="preserve">
          <source>Implementing API Exceptions</source>
          <target state="translated">实现API异常</target>
        </trans-unit>
        <trans-unit id="3340741ffcca69efa8da5e67f80805db1ebc7b03" translate="yes" xml:space="preserve">
          <source>Importing with context looks like this:</source>
          <target state="translated">用上下文导入是这样的。</target>
        </trans-unit>
        <trans-unit id="d5693fbdaabe4b3eb48a8cfeec42cd9cd25f647f" translate="yes" xml:space="preserve">
          <source>Imports the path &lt;code&gt;hello.web&lt;/code&gt;.</source>
          <target state="translated">导入路径 &lt;code&gt;hello.web&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1ca3057eb13793583ad86a26e84b8dfab5e186d5" translate="yes" xml:space="preserve">
          <source>Improving Uploads</source>
          <target state="translated">改善上传</target>
        </trans-unit>
        <trans-unit id="76d971a77762e631106de52538629e73404b0811" translate="yes" xml:space="preserve">
          <source>In 2007, the specification was adopted as the basis of a new HTML specification under the umbrella of the W3C, known as HTML5. Currently, it appears that XHTML is losing traction, as the XHTML 2 working group has been disbanded and HTML5 is being implemented by all major browser vendors.</source>
          <target state="translated">2007年,该规范被采纳为W3C旗下新的HTML规范的基础,即HTML5。目前,XHTML似乎正在失去牵引力,因为XHTML 2工作组已经解散,所有主要的浏览器供应商都在实施HTML5。</target>
        </trans-unit>
        <trans-unit id="e6a5ea37263b944a61e38640d617b8d1b66fb8a4" translate="yes" xml:space="preserve">
          <source>In Apache for example you can put something like this into the config:</source>
          <target state="translated">例如,在Apache中,你可以在配置中加入这样的内容。</target>
        </trans-unit>
        <trans-unit id="a4b92aed630ee32e223c62767fad2a2585e26be3" translate="yes" xml:space="preserve">
          <source>In Code</source>
          <target state="translated">在代码中</target>
        </trans-unit>
        <trans-unit id="64da8065588a62619e2c9d25d6166cc5ee467bf6" translate="yes" xml:space="preserve">
          <source>In Flask 0.10 and lower, &lt;code&gt;jsonify()&lt;/code&gt; did not serialize top-level arrays to JSON. This was because of a security vulnerability in ECMAScript 4.</source>
          <target state="translated">在Flask 0.10及更低版本中， &lt;code&gt;jsonify()&lt;/code&gt; 并未将顶级数组序列化为JSON。这是因为ECMAScript 4中存在一个安全漏洞。</target>
        </trans-unit>
        <trans-unit id="b8c4c5e3277662f83d8d8fafb814418f055a6c78" translate="yes" xml:space="preserve">
          <source>In Flask 0.10 it goes a step further and escapes all HTML tags with unicode escapes. This makes it possible for Flask to automatically mark the result as HTML safe.</source>
          <target state="translated">在Flask 0.10中,它更进一步,用unicode转义符转义所有的HTML标签。这使得Flask可以自动将结果标记为HTML安全。</target>
        </trans-unit>
        <trans-unit id="3c1d2bc024a0018745a91e7f9fa42d1c5bfd31b2" translate="yes" xml:space="preserve">
          <source>In Flask you can easily implement the opening of database connections on demand and closing them when the context dies (usually at the end of the request).</source>
          <target state="translated">在Flask中,您可以轻松实现按需打开数据库连接,并在上下文死亡时关闭它们(通常在请求结束时)。</target>
        </trans-unit>
        <trans-unit id="dd5f821cbda2746da9b6dc609f7eb2386d3dabd0" translate="yes" xml:space="preserve">
          <source>In HTML the &lt;code&gt;script&lt;/code&gt; tag is declared &lt;code&gt;CDATA&lt;/code&gt; which means that entities will not be parsed. Everything until &lt;code&gt;&amp;lt;/script&amp;gt;&lt;/code&gt; is handled as script. This also means that there must never be any &lt;code&gt;&amp;lt;/&lt;/code&gt; between the script tags. &lt;code&gt;|tojson&lt;/code&gt; is kind enough to do the right thing here and escape slashes for you (&lt;code&gt;{{ &quot;&amp;lt;/script&amp;gt;&quot;|tojson|safe }}&lt;/code&gt; is rendered as &lt;code&gt;&quot;&amp;lt;\/script&amp;gt;&quot;&lt;/code&gt;).</source>
          <target state="translated">在HTML中， &lt;code&gt;script&lt;/code&gt; 标记被声明为 &lt;code&gt;CDATA&lt;/code&gt; ，这意味着将不解析实体。 &lt;code&gt;&amp;lt;/script&amp;gt;&lt;/code&gt; 之前的所有内容均作为脚本处理。这也意味着脚本标记之间绝不能有任何 &lt;code&gt;&amp;lt;/&lt;/code&gt; 。 &lt;code&gt;|tojson&lt;/code&gt; 足以在这里做正确的事，并为您转义斜线（ &lt;code&gt;{{ &quot;&amp;lt;/script&amp;gt;&quot;|tojson|safe }}&lt;/code&gt; 表示为 &lt;code&gt;&quot;&amp;lt;\/script&amp;gt;&quot;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="b3710f20fda1f1712c313fd42589a3325136a2aa" translate="yes" xml:space="preserve">
          <source>In PyCharm, with your project open, click on &lt;em&gt;Run&lt;/em&gt; from the menu bar and go to &lt;em&gt;Edit Configurations&lt;/em&gt;. You&amp;rsquo;ll be greeted by a screen similar to this:</source>
          <target state="translated">在PyCharm中，在打开项目的情况下，从菜单栏中单击&amp;ldquo;&lt;em&gt;运行&amp;rdquo;&lt;/em&gt;，然后转到&amp;ldquo;&lt;em&gt;编辑配置&amp;rdquo;&lt;/em&gt;。类似于以下内容的屏幕将为您打招呼：</target>
        </trans-unit>
        <trans-unit id="3ef6b7d83cb2b366625b0bd768ca79a0cdc4b5e7" translate="yes" xml:space="preserve">
          <source>In addition to pointing to configuration files using environment variables, you may find it useful (or necessary) to control your configuration values directly from the environment.</source>
          <target state="translated">除了使用环境变量指向配置文件外,您可能会发现直接从环境中控制您的配置值是有用的(或必要的)。</target>
        </trans-unit>
        <trans-unit id="5a6f5ff62a81ca40ae92b393e7501a72dffcc7d0" translate="yes" xml:space="preserve">
          <source>In addition to the request object there is also a second object called &lt;a href=&quot;../api/index#flask.session&quot;&gt;&lt;code&gt;session&lt;/code&gt;&lt;/a&gt; which allows you to store information specific to a user from one request to the next. This is implemented on top of cookies for you and signs the cookies cryptographically. What this means is that the user could look at the contents of your cookie but not modify it, unless they know the secret key used for signing.</source>
          <target state="translated">除了请求对象外，还有一个名为&lt;a href=&quot;../api/index#flask.session&quot;&gt; &lt;code&gt;session&lt;/code&gt; &lt;/a&gt;的第二个对象，它使您可以存储从一个请求到下一个请求的特定于用户的信息。这是在您的Cookie之上实现的，并以加密方式对Cookie进行签名。这意味着用户可以查看您的cookie的内容，但不能对其进行修改，除非他们知道用于签名的密钥。</target>
        </trans-unit>
        <trans-unit id="cf994c7870e56c26a07146b72312390bb9386ce6" translate="yes" xml:space="preserve">
          <source>In both cases (loading from any Python file or loading from modules), only uppercase keys are added to the config. This makes it possible to use lowercase values in the config file for temporary values that are not added to the config or to define the config keys in the same file that implements the application.</source>
          <target state="translated">在这两种情况下 (从任何 Python 文件加载或从模块加载),只有大写键被添加到 config 中。这使得我们可以在配置文件中使用小写值来表示没有添加到config中的临时值,或者在实现应用程序的同一个文件中定义config键。</target>
        </trans-unit>
        <trans-unit id="ec9b4bffe2f7c4eedec5e2af6e4cf8b6b0e5e26b" translate="yes" xml:space="preserve">
          <source>In case of the decorator the argument is optional if you want to use the function name as name of the filter. Once registered, you can use the filter in your templates in the same way as Jinja2&amp;rsquo;s builtin filters, for example if you have a Python list in context called &lt;code&gt;mylist&lt;/code&gt;:</source>
          <target state="translated">对于装饰器，如果要使用函数名称作为过滤器名称，则参数是可选的。注册后，您可以按照与Jinja2内置过滤器相同的方式在模板中使用过滤器，例如，如果在上下文中有一个名为 &lt;code&gt;mylist&lt;/code&gt; 的Python列表：</target>
        </trans-unit>
        <trans-unit id="caa16cdd7b75478fbf75ba0d5bf015388dd11de3" translate="yes" xml:space="preserve">
          <source>In case the &lt;strong&gt;python -m flask&lt;/strong&gt; fails or &lt;strong&gt;flask&lt;/strong&gt; does not exist, there are multiple reasons this might be the case. First of all you need to look at the error message.</source>
          <target state="translated">如果&lt;strong&gt;python -m flask&lt;/strong&gt;失败或&lt;strong&gt;flask&lt;/strong&gt;不存在，则可能有多种原因。首先，您需要查看错误消息。</target>
        </trans-unit>
        <trans-unit id="cd20fce08bc8cc93a2886e83c531d580ada22567" translate="yes" xml:space="preserve">
          <source>In debug mode Flask will not tear down a request on an exception immediately. Instead it will keep it alive so that the interactive debugger can still access it. This behavior can be controlled by the &lt;code&gt;PRESERVE_CONTEXT_ON_EXCEPTION&lt;/code&gt; configuration variable.</source>
          <target state="translated">在调试模式下，Flask不会立即取消对异常的请求。相反，它将保持活动状态，以便交互式调试器仍然可以访问它。可以通过 &lt;code&gt;PRESERVE_CONTEXT_ON_EXCEPTION&lt;/code&gt; 配置变量来控制此行为。</target>
        </trans-unit>
        <trans-unit id="3d8e1458f47f44b33ff0d77f2d8221d090ecccf0" translate="yes" xml:space="preserve">
          <source>In debug mode, the logger&amp;rsquo;s &lt;code&gt;level&lt;/code&gt; will be set to &lt;code&gt;DEBUG&lt;/code&gt;.</source>
          <target state="translated">在调试模式下，记录器的 &lt;code&gt;level&lt;/code&gt; 将设置为 &lt;code&gt;DEBUG&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="602af0968d1857a032ea8176a2db906c367ed7d0" translate="yes" xml:space="preserve">
          <source>In order to install and run the application you need to issue the following commands:</source>
          <target state="translated">为了安装和运行应用程序,你需要发出以下命令。</target>
        </trans-unit>
        <trans-unit id="290558bf434b70765d9c5f4132ac8f4dbe3b778d" translate="yes" xml:space="preserve">
          <source>In order to run the application you need to export an environment variable that tells Flask where to find the application instance:</source>
          <target state="translated">为了运行应用程序,你需要导出一个环境变量,告诉Flask在哪里可以找到应用程序实例。</target>
        </trans-unit>
        <trans-unit id="bb509dc231fae84894ea79c9cf43c03e7976ec36" translate="yes" xml:space="preserve">
          <source>In order to support more data types, override the &lt;a href=&quot;#flask.json.JSONEncoder.default&quot;&gt;&lt;code&gt;default()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">为了支持更多数据类型，请重写&lt;a href=&quot;#flask.json.JSONEncoder.default&quot;&gt; &lt;code&gt;default()&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="0ecbeb90f6d07088367189c8ce15826d6a80d143" translate="yes" xml:space="preserve">
          <source>In order to use jQuery, you have to download it first and place it in the static folder of your application and then ensure it&amp;rsquo;s loaded. Ideally you have a layout template that is used for all pages where you just have to add a script statement to the bottom of your &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; to load jQuery:</source>
          <target state="translated">为了使用jQuery，您必须先下载它并将其放置在应用程序的静态文件夹中，然后确保已加载它。理想情况下，您有一个用于所有页面的布局模板，您只需在 &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; 的底部添加一个脚本语句来加载jQuery：</target>
        </trans-unit>
        <trans-unit id="7711ea9cee5fd6f50199c6c95e44a0f30ae0fe81" translate="yes" xml:space="preserve">
          <source>In order to use sessions you have to set a secret key. Here is how sessions work:</source>
          <target state="translated">为了使用会话,你必须设置一个秘密密钥。下面是会话的工作原理。</target>
        </trans-unit>
        <trans-unit id="5d6fb0022401ccf92f02195d6652a7165075147d" translate="yes" xml:space="preserve">
          <source>In order to use the interactive debugger, debugging must be enabled both on the application and the simple server. Here is the &amp;ldquo;hello world&amp;rdquo; example with debugging and &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/serving/#werkzeug.serving.run_simple&quot;&gt;&lt;code&gt;run_simple&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">为了使用交互式调试器，必须在应用程序和简单服务器上都启用调试。这是带有调试和&lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/serving/#werkzeug.serving.run_simple&quot;&gt; &lt;code&gt;run_simple&lt;/code&gt; &lt;/a&gt;的&amp;ldquo; hello world&amp;rdquo;示例：</target>
        </trans-unit>
        <trans-unit id="0d4d13ff3c7840d8d95050603ca940756d170ebb" translate="yes" xml:space="preserve">
          <source>In the Python code, wrap the HTML string in a &lt;a href=&quot;../api/index#flask.Markup&quot;&gt;&lt;code&gt;Markup&lt;/code&gt;&lt;/a&gt; object before passing it to the template. This is in general the recommended way.</source>
          <target state="translated">在Python代码中，将HTML字符串包装到&lt;a href=&quot;../api/index#flask.Markup&quot;&gt; &lt;code&gt;Markup&lt;/code&gt; &lt;/a&gt;对象中，然后再将其传递给模板。通常，这是推荐的方式。</target>
        </trans-unit>
        <trans-unit id="4f09494a38078ecc5ea5426eab15f37fd6a33ab4" translate="yes" xml:space="preserve">
          <source>In the View</source>
          <target state="translated">在 &quot;视图 &quot;中</target>
        </trans-unit>
        <trans-unit id="21453880be2ded013eda4ccf65e971b96adfebd3" translate="yes" xml:space="preserve">
          <source>In the example above, invoking the command by name is useful because it verifies that the command was correctly registered with the app.</source>
          <target state="translated">在上面的例子中,通过名称调用命令是很有用的,因为它可以验证该命令是否正确地在应用程序中注册。</target>
        </trans-unit>
        <trans-unit id="fa206bafa8b35a7bc39993f5a97f8b334f92724f" translate="yes" xml:space="preserve">
          <source>In the following example we are using &lt;code&gt;mod_wsgi&lt;/code&gt; for the remote servers. You can of course use your own favourite server there, but for this example we chose Apache + &lt;code&gt;mod_wsgi&lt;/code&gt; because it&amp;rsquo;s very easy to setup and has a simple way to reload applications without root access.</source>
          <target state="translated">在以下示例中，我们将 &lt;code&gt;mod_wsgi&lt;/code&gt; 用于远程服务器。您当然可以在这里使用自己喜欢的服务器，但是在此示例中，我们选择了Apache + &lt;code&gt;mod_wsgi&lt;/code&gt; ,因为它非常易于设置，并且具有无需root访问即可重新加载应用程序的简单方法。</target>
        </trans-unit>
        <trans-unit id="384512f1aa42159224bc97ed483f61353788fb7e" translate="yes" xml:space="preserve">
          <source>In the view function, the usage of this form looks like this:</source>
          <target state="translated">在视图功能中,这个表单的用法是这样的。</target>
        </trans-unit>
        <trans-unit id="725d6f893441bdd63204b4a52a55a7c55b279ee8" translate="yes" xml:space="preserve">
          <source>In this case before launching the application you have to set this environment variable to the file you want to use. On Linux and OS X use the export statement:</source>
          <target state="translated">在这种情况下,在启动应用程序之前,你必须将这个环境变量设置为你要使用的文件。在Linux和OS X上,使用导出语句。</target>
        </trans-unit>
        <trans-unit id="e7b440104f90df9d116fde6374a12a85ced9cae9" translate="yes" xml:space="preserve">
          <source>In this case the error seems to be &amp;ldquo;yourapplication&amp;rdquo; not being on the python path. Common problems are:</source>
          <target state="translated">在这种情况下，错误似乎是&amp;ldquo;您的应用程序&amp;rdquo;不在python路径上。常见的问题是：</target>
        </trans-unit>
        <trans-unit id="de0ffd04d6fcfa19c0f2088a2430e0a0b2107b38" translate="yes" xml:space="preserve">
          <source>In this case the values of the above mentioned attributes would be the following:</source>
          <target state="translated">在这种情况下,上述属性的值如下:</target>
        </trans-unit>
        <trans-unit id="6c2136b1725ea978561b3bf16668334173a6ea6a" translate="yes" xml:space="preserve">
          <source>In this case we assume your application is called &lt;code&gt;yourapplication.py&lt;/code&gt; and you are not using a module, but a &lt;a href=&quot;../packages/index#larger-applications&quot;&gt;package&lt;/a&gt;. If you have not yet converted your application into a package, head over to the &lt;a href=&quot;../packages/index#larger-applications&quot;&gt;Larger Applications&lt;/a&gt; pattern to see how this can be done.</source>
          <target state="translated">在这种情况下，我们假设您的应用程序名为 &lt;code&gt;yourapplication.py&lt;/code&gt; ,并且您没有使用模块，而是使用&lt;a href=&quot;../packages/index#larger-applications&quot;&gt;package&lt;/a&gt;。如果尚未将应用程序转换为程序包，请转至&amp;ldquo;&lt;a href=&quot;../packages/index#larger-applications&quot;&gt;较大的应用程序&amp;rdquo;&lt;/a&gt;模式，以了解如何完成此操作。</target>
        </trans-unit>
        <trans-unit id="f76928cc811a913fd8718bee1c2f03fc411b5951" translate="yes" xml:space="preserve">
          <source>In this case you have to put jQuery into your static folder as a fallback, but it will first try to load it directly from Google. This has the advantage that your website will probably load faster for users if they went to at least one other website before using the same jQuery version from Google because it will already be in the browser cache.</source>
          <target state="translated">在这种情况下,你必须把jQuery放到你的静态文件夹中作为后备,但它会首先尝试直接从Google加载它。這樣做的好處是,如果使用者在使用Google的jQuery版本之前,至少先到過一個其他的網站,那麼你的網站可能會加載得更快,因為它已經在瀏覽器的快取中了。</target>
        </trans-unit>
        <trans-unit id="774f8d6ee5a924357358d0317dde71c9a23553d2" translate="yes" xml:space="preserve">
          <source>In this documentation we will use the &lt;a href=&quot;https://docs.pytest.org/&quot;&gt;pytest&lt;/a&gt; package as the base framework for our tests. You can install it with &lt;code&gt;pip&lt;/code&gt;, like so:</source>
          <target state="translated">在本文档中，我们将使用&lt;a href=&quot;https://docs.pytest.org/&quot;&gt;pytest&lt;/a&gt;包作为测试的基本框架。您可以使用 &lt;code&gt;pip&lt;/code&gt; 安装它，如下所示：</target>
        </trans-unit>
        <trans-unit id="80716837e942aaddd02b353c712146a662ffbb9b" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;{% block %}&lt;/code&gt; tags define four blocks that child templates can fill in. All the &lt;code&gt;block&lt;/code&gt; tag does is tell the template engine that a child template may override those portions of the template.</source>
          <target state="translated">在此示例中， &lt;code&gt;{% block %}&lt;/code&gt; 标签定义了子模板可以填充的四个块。所有 &lt;code&gt;block&lt;/code&gt; 标签所做的是告诉模板引擎子模板可以覆盖模板的那些部分。</target>
        </trans-unit>
        <trans-unit id="e9ffef4615476ea6fd43a3426fe714c56091098d" translate="yes" xml:space="preserve">
          <source>Incoming Request Data</source>
          <target state="translated">收到的请求数据</target>
        </trans-unit>
        <trans-unit id="083e45fe0afd6159d9c67533047a31302293e4a0" translate="yes" xml:space="preserve">
          <source>Independent of how you load your config, there is a config object available which holds the loaded configuration values: The &lt;a href=&quot;../api/index#flask.Flask.config&quot;&gt;&lt;code&gt;config&lt;/code&gt;&lt;/a&gt; attribute of the &lt;a href=&quot;../api/index#flask.Flask&quot;&gt;&lt;code&gt;Flask&lt;/code&gt;&lt;/a&gt; object. This is the place where Flask itself puts certain configuration values and also where extensions can put their configuration values. But this is also where you can have your own configuration.</source>
          <target state="translated">与如何加载配置无关，有一个可用的配置对象保存已加载的配置值：&lt;a href=&quot;../api/index#flask.Flask&quot;&gt; &lt;code&gt;Flask&lt;/code&gt; &lt;/a&gt;对象的&lt;a href=&quot;../api/index#flask.Flask.config&quot;&gt; &lt;code&gt;config&lt;/code&gt; &lt;/a&gt;属性。这是Flask自己放置某些配置值的地方，也是扩展可以放置其配置值的地方。但这也是您可以拥有自己的配置的地方。</target>
        </trans-unit>
        <trans-unit id="1b6d15bf5d3795e3d6d5b2b493f3f8493b1325a0" translate="yes" xml:space="preserve">
          <source>Inform the application what host and port it is bound to. Required for subdomain route matching support.</source>
          <target state="translated">告知应用程序绑定的主机和端口。子域路由匹配支持时需要。</target>
        </trans-unit>
        <trans-unit id="f6c4cda1893e644e5f5670aac22d98cc2aa85d05" translate="yes" xml:space="preserve">
          <source>Inform the application what path it is mounted under by the application / web server. This is used for generating URLs outside the context of a request (inside a request, the dispatcher is responsible for setting &lt;code&gt;SCRIPT_NAME&lt;/code&gt; instead; see &lt;a href=&quot;../patterns/appdispatch/index#app-dispatch&quot;&gt;Application Dispatching&lt;/a&gt; for examples of dispatch configuration).</source>
          <target state="translated">通知应用程序应用程序/ Web服务器将其安装在什么路径下。这用于在请求上下文之外生成URL（在请求内部，调度程序负责设置 &lt;code&gt;SCRIPT_NAME&lt;/code&gt; ；有关调度配置的示例，请参阅&lt;a href=&quot;../patterns/appdispatch/index#app-dispatch&quot;&gt;应用程序调度&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="7a9bc2d5ae8c25475000217837a3bd2eef4f0fd7" translate="yes" xml:space="preserve">
          <source>Information for Pros</source>
          <target state="translated">专业人员信息</target>
        </trans-unit>
        <trans-unit id="bd39f63695fa6dde7dd6a609b5d4bf8f2da8c5f2" translate="yes" xml:space="preserve">
          <source>Information for the Pros</source>
          <target state="translated">给专业人员的信息</target>
        </trans-unit>
        <trans-unit id="a6771eb5340e4896b0c269f726da71141c6a72d6" translate="yes" xml:space="preserve">
          <source>Initial Schemas</source>
          <target state="translated">初始方案</target>
        </trans-unit>
        <trans-unit id="19257003832d3064bbc7adc96792753e8b7e163f" translate="yes" xml:space="preserve">
          <source>Initializing Extensions</source>
          <target state="translated">初始化扩展部分</target>
        </trans-unit>
        <trans-unit id="8dd1a4e146ef81147cbf6775548ccfe5c43af44d" translate="yes" xml:space="preserve">
          <source>Injecting Request Information</source>
          <target state="translated">注入请求信息</target>
        </trans-unit>
        <trans-unit id="0ecf3d6e21d678f1f9fcfd40e62e01c20292dc0c" translate="yes" xml:space="preserve">
          <source>Injects the URL defaults for the given endpoint directly into the values dictionary passed. This is used internally and automatically called on URL building.</source>
          <target state="translated">将给定端点的URL默认值直接注入到传递的值字典中。这在内部使用,并在建立URL时自动调用。</target>
        </trans-unit>
        <trans-unit id="8ed5c42958a5eb3e21db23b51bab9244cbe1cbc4" translate="yes" xml:space="preserve">
          <source>Insert key with a value of default if key is not in the dictionary.</source>
          <target state="translated">如果键不在字典中,则插入默认值的键。</target>
        </trans-unit>
        <trans-unit id="86c85d9f63e1f3d6c8c4fdba58d6deb8d7ef1748" translate="yes" xml:space="preserve">
          <source>Inside &lt;code&gt;flask_my_extension/commands.py&lt;/code&gt; you can then export a Click object:</source>
          <target state="translated">然后在 &lt;code&gt;flask_my_extension/commands.py&lt;/code&gt; 中,您可以导出一个Click对象：</target>
        </trans-unit>
        <trans-unit id="90efacdb261f6032e16de84250880468c14ddb2d" translate="yes" xml:space="preserve">
          <source>Inside templates you also have access to the &lt;a href=&quot;../api/index#flask.request&quot;&gt;&lt;code&gt;request&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../api/index#flask.session&quot;&gt;&lt;code&gt;session&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../api/index#flask.g&quot;&gt;&lt;code&gt;g&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;#id5&quot; id=&quot;id4&quot;&gt;1&lt;/a&gt; objects as well as the &lt;a href=&quot;../api/index#flask.get_flashed_messages&quot;&gt;&lt;code&gt;get_flashed_messages()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">在模板内部，您还可以访问&lt;a href=&quot;../api/index#flask.request&quot;&gt; &lt;code&gt;request&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../api/index#flask.session&quot;&gt; &lt;code&gt;session&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../api/index#flask.g&quot;&gt; &lt;code&gt;g&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#id5&quot; id=&quot;id4&quot;&gt; 1&lt;/a&gt;对象以及&lt;a href=&quot;../api/index#flask.get_flashed_messages&quot;&gt; &lt;code&gt;get_flashed_messages()&lt;/code&gt; &lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="df46ed03b5dfb5043098433889b12aa06c38cda9" translate="yes" xml:space="preserve">
          <source>Inside the template you then have to tell the &lt;a href=&quot;../../api/index#flask.get_flashed_messages&quot;&gt;&lt;code&gt;get_flashed_messages()&lt;/code&gt;&lt;/a&gt; function to also return the categories. The loop looks slightly different in that situation then:</source>
          <target state="translated">然后，在模板内部，您必须告诉&lt;a href=&quot;../../api/index#flask.get_flashed_messages&quot;&gt; &lt;code&gt;get_flashed_messages()&lt;/code&gt; &lt;/a&gt;函数还返回类别。在这种情况下，循环看起来略有不同：</target>
        </trans-unit>
        <trans-unit id="cc51c02e2bcdda7ebeeec9f8a41220b9b0687570" translate="yes" xml:space="preserve">
          <source>Inside the template, use the &lt;code&gt;|safe&lt;/code&gt; filter to explicitly mark a string as safe HTML (&lt;code&gt;{{ myvariable|safe }}&lt;/code&gt;)</source>
          <target state="translated">在模板内部，使用 &lt;code&gt;|safe&lt;/code&gt; 过滤器将字符串显式标记为安全HTML（ &lt;code&gt;{{ myvariable|safe }}&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="c6265f4aa030cd344624e7a468ce47fc17bb0c32" translate="yes" xml:space="preserve">
          <source>Insider Information</source>
          <target state="translated">内幕信息</target>
        </trans-unit>
        <trans-unit id="fd6c3ebf7befca9f8208f86c76e4d4180303745c" translate="yes" xml:space="preserve">
          <source>Install</source>
          <target state="translated">Install</target>
        </trans-unit>
        <trans-unit id="3125c49ab590a59594013be02c9df3bbf3985cef" translate="yes" xml:space="preserve">
          <source>Install Flask</source>
          <target state="translated">安装Flask</target>
        </trans-unit>
        <trans-unit id="065942daacc01a87e9295913aaf0dc959dace993" translate="yes" xml:space="preserve">
          <source>Install the application in the virtualenv in editable mode and the custom script is available. Note that you don&amp;rsquo;t need to set &lt;code&gt;FLASK_APP&lt;/code&gt;.</source>
          <target state="translated">以可编辑模式在virtualenv中安装应用程序，并且自定义脚本可用。请注意，您不需要设置 &lt;code&gt;FLASK_APP&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="50a2fe893379aaaec5ddffb5993f865752d22f2d" translate="yes" xml:space="preserve">
          <source>Install virtualenv</source>
          <target state="translated">安装virtualenv</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="9e4a021374f72cbdd7588636d70e27df03e54d7c" translate="yes" xml:space="preserve">
          <source>Installed module or package:</source>
          <target state="translated">已安装的模块或包件。</target>
        </trans-unit>
        <trans-unit id="b7adf3d1c525960539e4921912f21b92ab13f9d6" translate="yes" xml:space="preserve">
          <source>Installing / Developing</source>
          <target state="translated">安装/开发</target>
        </trans-unit>
        <trans-unit id="b28f439e75dbd5a89b725b68fbf81a16ed5ed4b2" translate="yes" xml:space="preserve">
          <source>Installing &lt;code&gt;mod_wsgi&lt;/code&gt;</source>
          <target state="translated">安装 &lt;code&gt;mod_wsgi&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="43eac72802c867b9850b0ca25f49c05834d50522" translate="yes" xml:space="preserve">
          <source>Installing FastCGI applications on nginx is a bit different because by default no FastCGI parameters are forwarded.</source>
          <target state="translated">在nginx上安装FastCGI应用程序有点不同,因为默认情况下没有转发FastCGI参数。</target>
        </trans-unit>
        <trans-unit id="2c41b4d0908a867288f97c139bd4fabe1766a3c3" translate="yes" xml:space="preserve">
          <source>Installing Flask installs the &lt;code&gt;flask&lt;/code&gt; script, a &lt;a href=&quot;https://click.palletsprojects.com/&quot;&gt;Click&lt;/a&gt; command line interface, in your virtualenv. Executed from the terminal, this script gives access to built-in, extension, and application-defined commands. The &lt;code&gt;--help&lt;/code&gt; option will give more information about any commands and options.</source>
          <target state="translated">安装Flask会在您的virtualenv &lt;code&gt;flask&lt;/code&gt; 安装flask脚本（一个&lt;a href=&quot;https://click.palletsprojects.com/&quot;&gt;Click&lt;/a&gt;命令行界面）。该脚本从终端执行，可访问内置，扩展和应用程序定义的命令。该 &lt;code&gt;--help&lt;/code&gt; 选项将提供有关任何命令和选项的详细信息。</target>
        </trans-unit>
        <trans-unit id="5a6b9509551353e48ed3af67a2e52f0a639b5c4e" translate="yes" xml:space="preserve">
          <source>Instance Folders</source>
          <target state="translated">实例文件夹</target>
        </trans-unit>
        <trans-unit id="6b6e85c0ad53d89aa24fd8dcdf6194bab76fcab2" translate="yes" xml:space="preserve">
          <source>Instantiate your document class with keyword arguments for the fields. You can also assign values to the field attributes after instantiation. Then call &lt;code&gt;doc.save()&lt;/code&gt;.</source>
          <target state="translated">使用字段的关键字参数实例化您的文档类。您还可以在实例化之后为字段属性分配值。然后调用 &lt;code&gt;doc.save()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="75dc28145724d47f3bfe99cd1621ef9cb541996b" translate="yes" xml:space="preserve">
          <source>Instantiating the configuration object allows you to use &lt;code&gt;@property&lt;/code&gt; in your configuration classes:</source>
          <target state="translated">实例化配置对象使您可以在配置类中使用 &lt;code&gt;@property&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="93f259615fac6b5455874b97ef10bf0f7897889f" translate="yes" xml:space="preserve">
          <source>Internally &lt;a href=&quot;#flask.Flask.route&quot;&gt;&lt;code&gt;route()&lt;/code&gt;&lt;/a&gt; invokes &lt;a href=&quot;#flask.Flask.add_url_rule&quot;&gt;&lt;code&gt;add_url_rule()&lt;/code&gt;&lt;/a&gt; so if you want to customize the behavior via subclassing you only need to change this method.</source>
          <target state="translated">在内部，&lt;a href=&quot;#flask.Flask.route&quot;&gt; &lt;code&gt;route()&lt;/code&gt; 会&lt;/a&gt;调用&lt;a href=&quot;#flask.Flask.add_url_rule&quot;&gt; &lt;code&gt;add_url_rule()&lt;/code&gt; ,&lt;/a&gt;因此，如果要通过子类自定义行为，则只需更改此方法。</target>
        </trans-unit>
        <trans-unit id="800600197165ab2c793b8481f79f46c469f3a99c" translate="yes" xml:space="preserve">
          <source>Internally this function does the following things:</source>
          <target state="translated">在内部,这个函数做以下事情。</target>
        </trans-unit>
        <trans-unit id="5906f90ed808a17efca8f518145c7b2a50e067c4" translate="yes" xml:space="preserve">
          <source>Internally this is implemented by going through a temporary test request context and since session handling could depend on request variables this function accepts the same arguments as &lt;a href=&quot;#flask.Flask.test_request_context&quot;&gt;&lt;code&gt;test_request_context()&lt;/code&gt;&lt;/a&gt; which are directly passed through.</source>
          <target state="translated">在内部，这是通过临时测试请求上下文来实现的，并且由于会话处理可能取决于请求变量，因此该函数接受与直接传递的&lt;a href=&quot;#flask.Flask.test_request_context&quot;&gt; &lt;code&gt;test_request_context()&lt;/code&gt; &lt;/a&gt;相同的参数。</target>
        </trans-unit>
        <trans-unit id="2aef40718c9b0427e056267a868f53688d152670" translate="yes" xml:space="preserve">
          <source>Internationalized Application URLs</source>
          <target state="translated">国际化应用URL</target>
        </trans-unit>
        <trans-unit id="95c1b2ff61a0e942a24732f026a59be53265d24d" translate="yes" xml:space="preserve">
          <source>Internationalized Blueprint URLs</source>
          <target state="translated">国际化的蓝图URL</target>
        </trans-unit>
        <trans-unit id="04d2b78bdccf6916e48eca1195495ec59302dc09" translate="yes" xml:space="preserve">
          <source>Internet Explorer (which, sadly, currently leads in market share) has poor support for XHTML.</source>
          <target state="translated">Internet Explorer(很遗憾,目前在市场占有率上处于领先地位)对XHTML的支持很差。</target>
        </trans-unit>
        <trans-unit id="d136bff1d83a8536fe65be3a045178668a86063f" translate="yes" xml:space="preserve">
          <source>Invalid Import Name</source>
          <target state="translated">无效的进口名称</target>
        </trans-unit>
        <trans-unit id="ef4416883d6f24f3538f5b1fdd508b5db1b9ddd5" translate="yes" xml:space="preserve">
          <source>Invokes a CLI command in an isolated environment. See &lt;a href=&quot;https://click.palletsprojects.com/en/7.x/api/#click.testing.CliRunner.invoke&quot;&gt;&lt;code&gt;CliRunner.invoke&lt;/code&gt;&lt;/a&gt; for full method documentation. See &lt;a href=&quot;../testing/index#testing-cli&quot;&gt;Testing CLI Commands&lt;/a&gt; for examples.</source>
          <target state="translated">在隔离的环境中调用CLI命令。有关完整的方法文档，请参见&lt;a href=&quot;https://click.palletsprojects.com/en/7.x/api/#click.testing.CliRunner.invoke&quot;&gt; &lt;code&gt;CliRunner.invoke&lt;/code&gt; &lt;/a&gt;。有关示例，请参见&lt;a href=&quot;../testing/index#testing-cli&quot;&gt;测试CLI命令&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="540b138b1f1a7297f07a52985c2472bdde1387f1" translate="yes" xml:space="preserve">
          <source>Is equivalent to the following:</source>
          <target state="translated">相当于以下内容:</target>
        </trans-unit>
        <trans-unit id="8ff4fc18cf6060ded7465e5c1e399be31b40f7a6" translate="yes" xml:space="preserve">
          <source>It basically behaves like a standard file object you know from Python, with the difference that it also has a &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.FileStorage.save&quot;&gt;&lt;code&gt;save()&lt;/code&gt;&lt;/a&gt; function that can store the file on the filesystem.</source>
          <target state="translated">它的行为基本上就像您从Python知道的标准文件对象一样，不同之处在于它还具有可以将文件存储在文件系统上的&lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.FileStorage.save&quot;&gt; &lt;code&gt;save()&lt;/code&gt; &lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="48b0deef2bc1faf9cc9df124d032408e98a07240" translate="yes" xml:space="preserve">
          <source>It has the support of most browser vendors behind it.</source>
          <target state="translated">它背后有大多数浏览器厂商的支持。</target>
        </trans-unit>
        <trans-unit id="37996744376862f385382b8f6354cffe68f9b33e" translate="yes" xml:space="preserve">
          <source>It is also possible to provide categories when flashing a message. The default category if nothing is provided is &lt;code&gt;'message'&lt;/code&gt;. Alternative categories can be used to give the user better feedback. For example error messages could be displayed with a red background.</source>
          <target state="translated">闪烁消息时也可以提供类别。如果未提供任何内容，则默认类别为 &lt;code&gt;'message'&lt;/code&gt; 。可以使用替代类别为用户提供更好的反馈。例如，错误消息可能显示为红色背景。</target>
        </trans-unit>
        <trans-unit id="8987d11ea8b2547b5b9508ce1875ded7d338723c" translate="yes" xml:space="preserve">
          <source>It is also recommended to use the Unix newline format, you can select it in the same panel but this is not a requirement.</source>
          <target state="translated">另外,建议使用Unix的换行格式,你可以在同一个面板中选择,但这不是要求。</target>
        </trans-unit>
        <trans-unit id="3f2a18a83c2ec4ff3af6547a61a3f95887c8e0aa" translate="yes" xml:space="preserve">
          <source>It is also safe to use the output of &lt;code&gt;|tojson&lt;/code&gt; in a &lt;em&gt;single-quoted&lt;/em&gt; HTML attribute:</source>
          <target state="translated">在&lt;em&gt;单引号&lt;/em&gt;HTML属性中使用 &lt;code&gt;|tojson&lt;/code&gt; 的输出也是安全的：&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2aa964d4d55d77ffe9dcfd4c20f864138479488b" translate="yes" xml:space="preserve">
          <source>It is however still a perfectly valid method for invoking a non automatic reloading application.</source>
          <target state="translated">然而,它仍然是一个完全有效的方法来调用一个非自动重装应用程序。</target>
        </trans-unit>
        <trans-unit id="7739e24a1ce6faaebad66cf3213dec378ae5ffff" translate="yes" xml:space="preserve">
          <source>It is much easier to write, and more compact.</source>
          <target state="translated">写起来更方便,也更紧凑。</target>
        </trans-unit>
        <trans-unit id="c83c4068f3434be56b542db9430062ca4530d52a" translate="yes" xml:space="preserve">
          <source>It is not recommended to use this function for development with automatic reloading as this is badly supported. Instead you should be using the &lt;strong&gt;flask&lt;/strong&gt; command line script&amp;rsquo;s &lt;code&gt;run&lt;/code&gt; support.</source>
          <target state="translated">不建议将此功能用于自动重载的开发，因为对此功能的支持很差。相反，您应该使用&lt;strong&gt;flask&lt;/strong&gt;命令行脚本的 &lt;code&gt;run&lt;/code&gt; 支持。</target>
        </trans-unit>
        <trans-unit id="355751a7f6236d6da1d034ea643dac11960b49b2" translate="yes" xml:space="preserve">
          <source>It is possible to register error handlers for very generic base classes such as &lt;code&gt;HTTPException&lt;/code&gt; or even &lt;code&gt;Exception&lt;/code&gt;. However, be aware that these will catch more than you might expect.</source>
          <target state="translated">可以为非常通用的基类（例如 &lt;code&gt;HTTPException&lt;/code&gt; 或 &lt;code&gt;Exception&lt;/code&gt; )注册错误处理程序。但是，请注意，它们将捕获比您预期的更多的东西。</target>
        </trans-unit>
        <trans-unit id="da011b41b4f6c0c687d66c16f0c385c7fe3ccfcd" translate="yes" xml:space="preserve">
          <source>It is preferred to use dotenv support over this, since &lt;code&gt;.flaskenv&lt;/code&gt; can be committed to the repository so that it works automatically wherever the project is checked out.</source>
          <target state="translated">最好在此基础上使用dotenv支持，因为 &lt;code&gt;.flaskenv&lt;/code&gt; 可以提交到存储库，以便它在检出项目的任何地方都可以自动运行。</target>
        </trans-unit>
        <trans-unit id="17cafbe30d6025f5751f8604a83d65da6b957a78" translate="yes" xml:space="preserve">
          <source>It is strongly recommended to activate either &lt;code&gt;X-Sendfile&lt;/code&gt; support in your webserver or (if no authentication happens) to tell the webserver to serve files for the given path on its own without calling into the web application for improved performance.</source>
          <target state="translated">强烈建议激活Web服务器中的 &lt;code&gt;X-Sendfile&lt;/code&gt; 支持或（如果未进行身份验证）告诉Web服务器自行为给定路径提供文件，而无需调用Web应用程序以提高性能。</target>
        </trans-unit>
        <trans-unit id="0b9aaa5b0bb967b5bd206b620e98ab0cf567da83" translate="yes" xml:space="preserve">
          <source>It is useful to distinguish between release and development builds. Add a &lt;code&gt;setup.cfg&lt;/code&gt; file to configure these options.</source>
          <target state="translated">区分发行版和开发版是很有用的。添加 &lt;code&gt;setup.cfg&lt;/code&gt; 文件以配置这些选项。</target>
        </trans-unit>
        <trans-unit id="0b1d8809d23dfe9d75d678b485f1cc45f096a311" translate="yes" xml:space="preserve">
          <source>It is what ends up as &lt;a href=&quot;#flask.request&quot;&gt;&lt;code&gt;request&lt;/code&gt;&lt;/a&gt;. If you want to replace the request object used you can subclass this and set &lt;a href=&quot;#flask.Flask.request_class&quot;&gt;&lt;code&gt;request_class&lt;/code&gt;&lt;/a&gt; to your subclass.</source>
          <target state="translated">这就是最终的&lt;a href=&quot;#flask.request&quot;&gt; &lt;code&gt;request&lt;/code&gt; &lt;/a&gt;。如果要替换使用的请求对象，则可以将此子类化，并将&lt;a href=&quot;#flask.Flask.request_class&quot;&gt; &lt;code&gt;request_class&lt;/code&gt; &lt;/a&gt;设置为子类。</target>
        </trans-unit>
        <trans-unit id="45f05221396a82de00bb89d9cf2b7c58e8d447b0" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s a better idea to do this instead:</source>
          <target state="translated">最好这样做：</target>
        </trans-unit>
        <trans-unit id="32b40c154de209b33ca42349cf51a33a276fa715" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s preferable to create your extensions and app factories so that the extension object does not initially get bound to the application.</source>
          <target state="translated">最好创建扩展和应用程序工厂，以便扩展对象最初不会绑定到应用程序。</target>
        </trans-unit>
        <trans-unit id="3fc4e0ad53baa7048bed5b944dedba835ddf9878" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s very common to implement RESTful APIs on top of Flask. One of the first things that developers run into is the realization that the builtin exceptions are not expressive enough for APIs and that the content type of &lt;em&gt;text/html&lt;/em&gt; they are emitting is not very useful for API consumers.</source>
          <target state="translated">在Flask之上实现RESTful API是很常见的。开发人员遇到的第一件事是认识到内置异常对API的表达不足，并且它们发出的&lt;em&gt;text / html&lt;/em&gt;的内容类型对API使用者不是很有用。</target>
        </trans-unit>
        <trans-unit id="b22b3685005ae5af64f2cecb9be54f970b6d39ba" translate="yes" xml:space="preserve">
          <source>Iterates over all blueprints by the order they were registered.</source>
          <target state="translated">按注册顺序对所有蓝图进行迭代。</target>
        </trans-unit>
        <trans-unit id="8beaf90e1de8975715df985c7e4cdc0f7976564b" translate="yes" xml:space="preserve">
          <source>JSON Security</source>
          <target state="translated">JSON安全</target>
        </trans-unit>
        <trans-unit id="1114fd2fa1563b0e7c0ea4575817f5bce882c202" translate="yes" xml:space="preserve">
          <source>JSON Support</source>
          <target state="translated">JSON支持</target>
        </trans-unit>
        <trans-unit id="82c5947bc714d27c55141fdaf2d03e2188f72cc4" translate="yes" xml:space="preserve">
          <source>JSON View Functions</source>
          <target state="translated">JSON视图功能</target>
        </trans-unit>
        <trans-unit id="5c727194c1d15f208a0d8ddd32904d945c3659ed" translate="yes" xml:space="preserve">
          <source>JSON itself is a very lightweight transport format, very similar to how Python primitives (numbers, strings, dicts and lists) look like which is widely supported and very easy to parse. It became popular a few years ago and quickly replaced XML as transport format in web applications.</source>
          <target state="translated">JSON本身是一种非常轻量级的传输格式,非常类似于Python基元(数字、字符串、字典和列表)的样子,它得到了广泛的支持,并且非常容易解析。它在几年前开始流行,并迅速取代XML成为Web应用中的传输格式。</target>
        </trans-unit>
        <trans-unit id="ef76bef84128d374bbbae32fb383e613b6da0e66" translate="yes" xml:space="preserve">
          <source>Jinja Setup</source>
          <target state="translated">Jinja设置</target>
        </trans-unit>
        <trans-unit id="a137c8c9ad50c57c7a88cbeb506d7b2a251fdc26" translate="yes" xml:space="preserve">
          <source>Jinja documentation</source>
          <target state="translated">Jinja文件</target>
        </trans-unit>
        <trans-unit id="a5599eee959cb522aaf4d8f8934a7fe45332ca28" translate="yes" xml:space="preserve">
          <source>Jinja is configured to decode the template files from UTF-8. So make sure to tell your editor to save the file as UTF-8 there as well.</source>
          <target state="translated">Jinja配置为从UTF-8解码模板文件。所以一定要告诉你的编辑器把文件也保存为UTF-8。</target>
        </trans-unit>
        <trans-unit id="12c000b752274a052225e864ff552b401fb72995" translate="yes" xml:space="preserve">
          <source>Just put them into a module (like &lt;code&gt;shelltools&lt;/code&gt;) and import from there:</source>
          <target state="translated">只需将它们放入模块（如 &lt;code&gt;shelltools&lt;/code&gt; ）中，然后从那里导入：</target>
        </trans-unit>
        <trans-unit id="94d85c0d7d33e59ccabb9ef17714b235ea788226" translate="yes" xml:space="preserve">
          <source>Just save it as &lt;code&gt;hello.py&lt;/code&gt; or something similar. Make sure to not call your application &lt;code&gt;flask.py&lt;/code&gt; because this would conflict with Flask itself.</source>
          <target state="translated">只需将其另存为 &lt;code&gt;hello.py&lt;/code&gt; 或类似名称即可。确保不调用您的应用程序 &lt;code&gt;flask.py&lt;/code&gt; ,因为这将与Flask本身发生冲突。</target>
        </trans-unit>
        <trans-unit id="83f55e8e91ffa716353eb467f02161a793fd02f0" translate="yes" xml:space="preserve">
          <source>Just the host including the port if available. See also: &lt;code&gt;trusted_hosts&lt;/code&gt;.</source>
          <target state="translated">仅主机（包括端口）（如果有）。另请参阅： &lt;code&gt;trusted_hosts&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="91bbea70f9e68929a79e08ecadc33c71c8ac482c" translate="yes" xml:space="preserve">
          <source>Just the host with scheme as IRI. See also: &lt;code&gt;trusted_hosts&lt;/code&gt;.</source>
          <target state="translated">只是计划为IRI的主机。另请参阅： &lt;code&gt;trusted_hosts&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b6d741dbeb38cf222d1e26a90aa371da2d1a5b1" translate="yes" xml:space="preserve">
          <source>Keep Developing!</source>
          <target state="translated">继续发展!</target>
        </trans-unit>
        <trans-unit id="8964a40c6b284371a4d86e1d2b1391a1e8d6d130" translate="yes" xml:space="preserve">
          <source>Keep a default configuration in version control. Either populate the config with this default configuration or import it in your own configuration files before overriding values.</source>
          <target state="translated">在版本控制中保留一个默认配置。在覆盖值之前,要么用这个默认配置填充配置,要么在你自己的配置文件中导入它。</target>
        </trans-unit>
        <trans-unit id="69b73c1df546261214c234c8ac8e210918d70f86" translate="yes" xml:space="preserve">
          <source>Keep in Mind</source>
          <target state="translated">牢记</target>
        </trans-unit>
        <trans-unit id="027be940710bc84594be1792860348af446c8af2" translate="yes" xml:space="preserve">
          <source>Keep in mind that mod_wsgi disallows doing anything with &lt;a href=&quot;https://docs.python.org/3/library/sys.html#sys.stdout&quot;&gt;&lt;code&gt;sys.stdout&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3/library/sys.html#sys.stderr&quot;&gt;&lt;code&gt;sys.stderr&lt;/code&gt;&lt;/a&gt;. You can disable this protection from the config by setting the &lt;code&gt;WSGIRestrictStdout&lt;/code&gt; to &lt;code&gt;off&lt;/code&gt;:</source>
          <target state="translated">请记住，mod_wsgi不允许对&lt;a href=&quot;https://docs.python.org/3/library/sys.html#sys.stdout&quot;&gt; &lt;code&gt;sys.stdout&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://docs.python.org/3/library/sys.html#sys.stderr&quot;&gt; &lt;code&gt;sys.stderr&lt;/code&gt; &lt;/a&gt;进行任何操作。您可以通过设置禁用此保护从配置 &lt;code&gt;WSGIRestrictStdout&lt;/code&gt; 至 &lt;code&gt;off&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="dceeb17a037581e20259a56a29d96c10b46ef1a4" translate="yes" xml:space="preserve">
          <source>Keep in mind that the &lt;a href=&quot;../api/index#flask.Flask.preprocess_request&quot;&gt;&lt;code&gt;preprocess_request()&lt;/code&gt;&lt;/a&gt; function might return a response object, in that case just ignore it.</source>
          <target state="translated">请记住，&lt;a href=&quot;../api/index#flask.Flask.preprocess_request&quot;&gt; &lt;code&gt;preprocess_request()&lt;/code&gt; &lt;/a&gt;函数可能会返回响应对象，在这种情况下，只需忽略它即可。</target>
        </trans-unit>
        <trans-unit id="a60c206443af75c639c3013b98795fdad97e01ee" translate="yes" xml:space="preserve">
          <source>Keeping the Context Around</source>
          <target state="translated">保持周围的环境</target>
        </trans-unit>
        <trans-unit id="1d94bd0dbb23d3ecd26d17eb1d621b96f6ce5973" translate="yes" xml:space="preserve">
          <source>Larger Applications</source>
          <target state="translated">大型应用</target>
        </trans-unit>
        <trans-unit id="2aaee8d4254314737d112cc1f0e910e9b80a7253" translate="yes" xml:space="preserve">
          <source>Lazily Loading Views</source>
          <target state="translated">懒洋洋地加载意见</target>
        </trans-unit>
        <trans-unit id="ea26987ee59dbc87ca0c5e0c0ae78ab2c20b31e4" translate="yes" xml:space="preserve">
          <source>Learn from Others</source>
          <target state="translated">向他人学习</target>
        </trans-unit>
        <trans-unit id="12efa23eea5b5ab005ca52aa97ee6289bb8c3cd2" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s assume for the moment the view would look like this:</source>
          <target state="translated">让我们暂时假设视图如下所示：</target>
        </trans-unit>
        <trans-unit id="ff3be2e6477ada2b9112ef28bdcf9e23b9ff3a76" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s seen an example that adds support for &lt;a href=&quot;https://docs.python.org/3/library/collections.html#collections.OrderedDict&quot;&gt;&lt;code&gt;OrderedDict&lt;/code&gt;&lt;/a&gt;. Dicts don&amp;rsquo;t have an order in Python or JSON, so to handle this we will dump the items as a list of &lt;code&gt;[key, value]&lt;/code&gt; pairs. Subclass &lt;a href=&quot;#flask.json.tag.JSONTag&quot;&gt;&lt;code&gt;JSONTag&lt;/code&gt;&lt;/a&gt; and give it the new key &lt;code&gt;' od'&lt;/code&gt; to identify the type. The session serializer processes dicts first, so insert the new tag at the front of the order since &lt;code&gt;OrderedDict&lt;/code&gt; must be processed before &lt;code&gt;dict&lt;/code&gt;.</source>
          <target state="translated">让我们看一个示例，该示例添加了对&lt;a href=&quot;https://docs.python.org/3/library/collections.html#collections.OrderedDict&quot;&gt; &lt;code&gt;OrderedDict&lt;/code&gt; 的&lt;/a&gt;支持。字典在Python或JSON中没有顺序，因此要处理此问题，我们将把这些项作为 &lt;code&gt;[key, value]&lt;/code&gt; 对的列表进行转储。子类化&lt;a href=&quot;#flask.json.tag.JSONTag&quot;&gt; &lt;code&gt;JSONTag&lt;/code&gt; &lt;/a&gt;并为其赋予新的键 &lt;code&gt;' od'&lt;/code&gt; 以标识类型。会话序列化程序首先处理 &lt;code&gt;dict&lt;/code&gt; ，因此在订单前面插入新标签，因为必须在dict之前处理 &lt;code&gt;OrderedDict&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="964b66ad44b9ceef78b68c7b3a4f56e3160a347c" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start with a very basic application that uploads a file to a specific upload folder and displays a file to the user. Let&amp;rsquo;s look at the bootstrapping code for our application:</source>
          <target state="translated">让我们从一个非常基本的应用程序开始，该应用程序将文件上传到特定的上传文件夹并向用户显示文件。让我们看一下应用程序的引导代码：</target>
        </trans-unit>
        <trans-unit id="0685f65275d730a656b5b00c811f14ee6a5c3444" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s write a task that adds two numbers together and returns the result. We configure Celery&amp;rsquo;s broker and backend to use Redis, create a &lt;code&gt;celery&lt;/code&gt; application using the factor from above, and then use it to define the task.</source>
          <target state="translated">让我们编写一个将两个数字相加并返回结果的任务。我们将Celery的代理和后端配置为使用Redis，使用上述因素创建一个 &lt;code&gt;celery&lt;/code&gt; 应用程序，然后使用它来定义任务。</target>
        </trans-unit>
        <trans-unit id="3229609e15436ec51bcf00818a69a84dbc58a0c2" translate="yes" xml:space="preserve">
          <source>License</source>
          <target state="translated">License</target>
        </trans-unit>
        <trans-unit id="9fc9c5a7d8326df046caa8d770d0b0dc0dbc12f4" translate="yes" xml:space="preserve">
          <source>Licensed under the BSD 3-clause License.</source>
          <target state="translated">采用BSD 3-clause授权许可。</target>
        </trans-unit>
        <trans-unit id="a5c055341f3340bf61ddd1eeb62d9c152fff0419" translate="yes" xml:space="preserve">
          <source>Lifetime of the Context</source>
          <target state="translated">语境的寿命</target>
        </trans-unit>
        <trans-unit id="e00af6d6d57a7fcd2c1cd116b044b4eef5bb65e9" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#flask.Flask.add_url_rule&quot;&gt;&lt;code&gt;Flask.add_url_rule()&lt;/code&gt;&lt;/a&gt; but for a blueprint. The endpoint for the &lt;a href=&quot;#flask.url_for&quot;&gt;&lt;code&gt;url_for()&lt;/code&gt;&lt;/a&gt; function is prefixed with the name of the blueprint.</source>
          <target state="translated">像&lt;a href=&quot;#flask.Flask.add_url_rule&quot;&gt; &lt;code&gt;Flask.add_url_rule()&lt;/code&gt; &lt;/a&gt;一样，但要提供蓝图。&lt;a href=&quot;#flask.url_for&quot;&gt; &lt;code&gt;url_for()&lt;/code&gt; &lt;/a&gt;函数的端点以蓝图的名称为前缀。</target>
        </trans-unit>
        <trans-unit id="163e5e38e82e713c68c7c97cbb443606fab5a580" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#flask.Flask.after_request&quot;&gt;&lt;code&gt;Flask.after_request()&lt;/code&gt;&lt;/a&gt; but for a blueprint. Such a function is executed after each request, even if outside of the blueprint.</source>
          <target state="translated">像&lt;a href=&quot;#flask.Flask.after_request&quot;&gt; &lt;code&gt;Flask.after_request()&lt;/code&gt; &lt;/a&gt;一样，但是有一个蓝图。即使在蓝图之外，在每个请求之后也会执行这样的功能。</target>
        </trans-unit>
        <trans-unit id="559110cef3a2a879ab2dfb4e453cd9ad4d352ee4" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#flask.Flask.after_request&quot;&gt;&lt;code&gt;Flask.after_request()&lt;/code&gt;&lt;/a&gt; but for a blueprint. This function is only executed after each request that is handled by a function of that blueprint.</source>
          <target state="translated">像&lt;a href=&quot;#flask.Flask.after_request&quot;&gt; &lt;code&gt;Flask.after_request()&lt;/code&gt; &lt;/a&gt;一样，但是有一个蓝图。仅在该蓝图功能处理的每个请求之后才执行该功能。</target>
        </trans-unit>
        <trans-unit id="1aa30dd4194a69bdc3bed662171f4fed81ef396c" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#flask.Flask.before_first_request&quot;&gt;&lt;code&gt;Flask.before_first_request()&lt;/code&gt;&lt;/a&gt;. Such a function is executed before the first request to the application.</source>
          <target state="translated">就像&lt;a href=&quot;#flask.Flask.before_first_request&quot;&gt; &lt;code&gt;Flask.before_first_request()&lt;/code&gt; 一样&lt;/a&gt;。此类功能在对应用程序的第一个请求之前执行。</target>
        </trans-unit>
        <trans-unit id="124af8f5306e815c266d0e6ec96eec81e6435894" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#flask.Flask.before_request&quot;&gt;&lt;code&gt;Flask.before_request()&lt;/code&gt;&lt;/a&gt; but for a blueprint. This function is only executed before each request that is handled by a function of that blueprint.</source>
          <target state="translated">像&lt;a href=&quot;#flask.Flask.before_request&quot;&gt; &lt;code&gt;Flask.before_request()&lt;/code&gt; &lt;/a&gt;一样，但是要有一个蓝图。该功能仅在该蓝图功能处理的每个请求之前执行。</target>
        </trans-unit>
        <trans-unit id="ff24a3de98cf55ef6670a35ea16072bd7051ef5e" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#flask.Flask.before_request&quot;&gt;&lt;code&gt;Flask.before_request()&lt;/code&gt;&lt;/a&gt;. Such a function is executed before each request, even if outside of a blueprint.</source>
          <target state="translated">就像&lt;a href=&quot;#flask.Flask.before_request&quot;&gt; &lt;code&gt;Flask.before_request()&lt;/code&gt; 一样&lt;/a&gt;。即使在蓝图之外，也会在每次请求之前执行此类功能。</target>
        </trans-unit>
        <trans-unit id="21d235f2b0541907a67169be47c50d5110940d03" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#flask.Flask.context_processor&quot;&gt;&lt;code&gt;Flask.context_processor()&lt;/code&gt;&lt;/a&gt; but for a blueprint. Such a function is executed each request, even if outside of the blueprint.</source>
          <target state="translated">像&lt;a href=&quot;#flask.Flask.context_processor&quot;&gt; &lt;code&gt;Flask.context_processor()&lt;/code&gt; &lt;/a&gt;一样，但是要有一个蓝图。即使在蓝图之外，每个请求也会执行这样的功能。</target>
        </trans-unit>
        <trans-unit id="7cbca6ea636b86b2c2eff330144da0255575467d" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#flask.Flask.context_processor&quot;&gt;&lt;code&gt;Flask.context_processor()&lt;/code&gt;&lt;/a&gt; but for a blueprint. This function is only executed for requests handled by a blueprint.</source>
          <target state="translated">像&lt;a href=&quot;#flask.Flask.context_processor&quot;&gt; &lt;code&gt;Flask.context_processor()&lt;/code&gt; &lt;/a&gt;一样，但是要有一个蓝图。仅对由蓝图处理的请求执行此功能。</target>
        </trans-unit>
        <trans-unit id="1a82eb8db4586b2ed561b51e5123275531916dcb" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#flask.Flask.endpoint&quot;&gt;&lt;code&gt;Flask.endpoint()&lt;/code&gt;&lt;/a&gt; but for a blueprint. This does not prefix the endpoint with the blueprint name, this has to be done explicitly by the user of this method. If the endpoint is prefixed with a &lt;code&gt;.&lt;/code&gt; it will be registered to the current blueprint, otherwise it&amp;rsquo;s an application independent endpoint.</source>
          <target state="translated">就像&lt;a href=&quot;#flask.Flask.endpoint&quot;&gt; &lt;code&gt;Flask.endpoint()&lt;/code&gt; &lt;/a&gt;一样，但是要有一个蓝图。这不会为端点添加蓝图名称前缀，这必须由此方法的用户显式完成。如果端点以开头 &lt;code&gt;.&lt;/code&gt; 它会被注册到当前的蓝图，否则它是一个与应用程序无关的端点。</target>
        </trans-unit>
        <trans-unit id="2ff03bb8441f8bec6efbb19777731e234a89df53" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#flask.Flask.errorhandler&quot;&gt;&lt;code&gt;Flask.errorhandler()&lt;/code&gt;&lt;/a&gt; but for a blueprint. This handler is used for all requests, even if outside of the blueprint.</source>
          <target state="translated">像&lt;a href=&quot;#flask.Flask.errorhandler&quot;&gt; &lt;code&gt;Flask.errorhandler()&lt;/code&gt; &lt;/a&gt;一样，但是有一个蓝图。该处理程序用于所有请求，即使在蓝图之外也是如此。</target>
        </trans-unit>
        <trans-unit id="1937008de0b0a7b7e22f8783449e42fd83e25ca0" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#flask.Flask.route&quot;&gt;&lt;code&gt;Flask.route()&lt;/code&gt;&lt;/a&gt; but for a blueprint. The endpoint for the &lt;a href=&quot;#flask.url_for&quot;&gt;&lt;code&gt;url_for()&lt;/code&gt;&lt;/a&gt; function is prefixed with the name of the blueprint.</source>
          <target state="translated">类似于&lt;a href=&quot;#flask.Flask.route&quot;&gt; &lt;code&gt;Flask.route()&lt;/code&gt; ,&lt;/a&gt;但需要一个蓝图。&lt;a href=&quot;#flask.url_for&quot;&gt; &lt;code&gt;url_for()&lt;/code&gt; &lt;/a&gt;函数的端点以蓝图的名称为前缀。</target>
        </trans-unit>
        <trans-unit id="563adf9d604a757d9225a0fe9bf5470581d6757c" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#flask.Flask.teardown_request&quot;&gt;&lt;code&gt;Flask.teardown_request()&lt;/code&gt;&lt;/a&gt; but for a blueprint. Such a function is executed when tearing down each request, even if outside of the blueprint.</source>
          <target state="translated">像&lt;a href=&quot;#flask.Flask.teardown_request&quot;&gt; &lt;code&gt;Flask.teardown_request()&lt;/code&gt; &lt;/a&gt;一样，但是要有一个蓝图。即使拆除了蓝图，在拆解每个请求时也会执行这样的功能。</target>
        </trans-unit>
        <trans-unit id="e832da40b0c64dcf9018e69cbc2a93ffe473e6f3" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#flask.Flask.teardown_request&quot;&gt;&lt;code&gt;Flask.teardown_request()&lt;/code&gt;&lt;/a&gt; but for a blueprint. This function is only executed when tearing down requests handled by a function of that blueprint. Teardown request functions are executed when the request context is popped, even when no actual request was performed.</source>
          <target state="translated">像&lt;a href=&quot;#flask.Flask.teardown_request&quot;&gt; &lt;code&gt;Flask.teardown_request()&lt;/code&gt; &lt;/a&gt;一样，但是要有一个蓝图。仅当拆除由该蓝图的功能处理的请求时，才执行此功能。当弹出请求上下文时，即使没有执行任何实际请求，也会执行拆解请求功能。</target>
        </trans-unit>
        <trans-unit id="b502aedccaec1e098b7700bd2445485d9553528a" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#flask.Request.content_type&quot;&gt;&lt;code&gt;content_type&lt;/code&gt;&lt;/a&gt;, but without parameters (eg, without charset, type etc.) and always lowercase. For example if the content type is &lt;code&gt;text/HTML; charset=utf-8&lt;/code&gt; the mimetype would be &lt;code&gt;'text/html'&lt;/code&gt;.</source>
          <target state="translated">类似于&lt;a href=&quot;#flask.Request.content_type&quot;&gt; &lt;code&gt;content_type&lt;/code&gt; &lt;/a&gt;，但没有参数（例如，没有字符集，类型等），并且总是小写。例如，如果内容类型为 &lt;code&gt;text/HTML; charset=utf-8&lt;/code&gt; 则为false。charset = utf-8，模仿类型为 &lt;code&gt;'text/html'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a03de61a406d829d5b95856930feda93ca885174" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#flask.Request.url&quot;&gt;&lt;code&gt;url&lt;/code&gt;&lt;/a&gt; but without the querystring See also: &lt;code&gt;trusted_hosts&lt;/code&gt;.</source>
          <target state="translated">与&lt;a href=&quot;#flask.Request.url&quot;&gt; &lt;code&gt;url&lt;/code&gt; &lt;/a&gt;类似，但没有querystring参见： &lt;code&gt;trusted_hosts&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="894fdebcc9d122f8db2662c5a8689bc55f2a9d25" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#flask.json.dumps&quot;&gt;&lt;code&gt;dumps()&lt;/code&gt;&lt;/a&gt; but writes into a file object.</source>
          <target state="translated">类似于&lt;a href=&quot;#flask.json.dumps&quot;&gt; &lt;code&gt;dumps()&lt;/code&gt; ,&lt;/a&gt;但写入文件对象。</target>
        </trans-unit>
        <trans-unit id="dcba4261dd5445fc5739de2a111205ee21ab5af3" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#flask.json.loads&quot;&gt;&lt;code&gt;loads()&lt;/code&gt;&lt;/a&gt; but reads from a file object.</source>
          <target state="translated">类似于&lt;a href=&quot;#flask.json.loads&quot;&gt; &lt;code&gt;loads()&lt;/code&gt; &lt;/a&gt;但从文件对象读取。</target>
        </trans-unit>
        <trans-unit id="49d1193e424049804525ff4e1b5b4ddf27867dda" translate="yes" xml:space="preserve">
          <source>Like for regular applications, blueprints are considered to be contained in a folder. While multiple blueprints can originate from the same folder, it does not have to be the case and it&amp;rsquo;s usually not recommended.</source>
          <target state="translated">像常规应用程序一样，蓝图被认为包含在文件夹中。尽管多个蓝图可以源自同一文件夹，但不一定非要这样，通常不建议这样做。</target>
        </trans-unit>
        <trans-unit id="0efdffb22a262726c5f9ad8c7baa245a293fd67d" translate="yes" xml:space="preserve">
          <source>List of charsets this client supports as &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.CharsetAccept&quot;&gt;&lt;code&gt;CharsetAccept&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">此客户端支持的字符集列表，作为&lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.CharsetAccept&quot;&gt; &lt;code&gt;CharsetAccept&lt;/code&gt; &lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="71959995e146ecc63c2d323d87e44c167a734f3d" translate="yes" xml:space="preserve">
          <source>List of encodings this client accepts. Encodings in a HTTP term are compression encodings such as gzip. For charsets have a look at &lt;code&gt;accept_charset&lt;/code&gt;.</source>
          <target state="translated">该客户端接受的编码列表。HTTP术语中的编码是压缩编码，例如gzip。对于字符集，请查看 &lt;code&gt;accept_charset&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="40095a4ecb5118cf06d0d4bc315c862893fe1811" translate="yes" xml:space="preserve">
          <source>List of languages this client accepts as &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.LanguageAccept&quot;&gt;&lt;code&gt;LanguageAccept&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">此客户端接受的语言列表，作为&lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.LanguageAccept&quot;&gt; &lt;code&gt;LanguageAccept&lt;/code&gt; &lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="ced62f14ccc99d9775f0faaeb5a0c09cb1456c19" translate="yes" xml:space="preserve">
          <source>List of mimetypes this client supports as &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.MIMEAccept&quot;&gt;&lt;code&gt;MIMEAccept&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">此客户端作为&lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.MIMEAccept&quot;&gt; &lt;code&gt;MIMEAccept&lt;/code&gt; &lt;/a&gt;对象支持的mimetypes列表。</target>
        </trans-unit>
        <trans-unit id="57c42222720e5f496a8df0809680b4294f03d281" translate="yes" xml:space="preserve">
          <source>Living on the edge</source>
          <target state="translated">生活在边缘</target>
        </trans-unit>
        <trans-unit id="509a27ce7201740ebcbec2fab3157350370ee391" translate="yes" xml:space="preserve">
          <source>Load &amp;ldquo;dotenv&amp;rdquo; files in order of precedence to set environment variables.</source>
          <target state="translated">按优先顺序加载&amp;ldquo; dotenv&amp;rdquo;文件以设置环境变量。</target>
        </trans-unit>
        <trans-unit id="8ee65bbf1913f982748c74b5bb58e4408e373bfb" translate="yes" xml:space="preserve">
          <source>Load data from a JSON string and deserialized any tagged objects.</source>
          <target state="translated">从JSON字符串加载数据,并反序列化任何标记对象。</target>
        </trans-unit>
        <trans-unit id="00ca75836ab03b65a191db83a2160b45d281b77f" translate="yes" xml:space="preserve">
          <source>Loading Late</source>
          <target state="translated">逾期加载</target>
        </trans-unit>
        <trans-unit id="1f105c0dd2246607c163745f37e4f2e9692b1289" translate="yes" xml:space="preserve">
          <source>Loading jQuery</source>
          <target state="translated">加载jQuery</target>
        </trans-unit>
        <trans-unit id="3d6aab706b81ef111755fa36999cddd18aec0f45" translate="yes" xml:space="preserve">
          <source>Loads a configuration from an environment variable pointing to a configuration file. This is basically just a shortcut with nicer error messages for this line of code:</source>
          <target state="translated">从指向配置文件的环境变量中加载配置。基本上,这只是一个带有更好的错误信息的快捷方式。</target>
        </trans-unit>
        <trans-unit id="782a16995edb8c26975d0f3a99be7c45d3baa211" translate="yes" xml:space="preserve">
          <source>Loads a macro (or variable) a template exports. This can be used to invoke a macro from within Python code. If you for example have a template named &lt;code&gt;_cider.html&lt;/code&gt; with the following contents:</source>
          <target state="translated">加载模板导出的宏（或变量）。这可用于在Python代码中调用宏。例如，如果您有一个名为 &lt;code&gt;_cider.html&lt;/code&gt; 的模板，其中包含以下内容：</target>
        </trans-unit>
        <trans-unit id="87d6c59fd98e184f2f059a132803229023bfea87" translate="yes" xml:space="preserve">
          <source>Loads the Flask app (if not yet loaded) and returns it. Calling this multiple times will just result in the already loaded app to be returned.</source>
          <target state="translated">加载Flask应用(如果尚未加载)并返回它。多次调用此函数只会导致已经加载的应用程序被返回。</target>
        </trans-unit>
        <trans-unit id="86993bc92c57e56f70290aecc5dc41792ac7267c" translate="yes" xml:space="preserve">
          <source>Location of the template files to be added to the template lookup. &lt;code&gt;None&lt;/code&gt; if templates should not be added.</source>
          <target state="translated">要添加到模板查找中的模板文件的位置。如果不应该添加模板，则为 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="27cab6e36e344801b7394e4cfd641de8ee87819b" translate="yes" xml:space="preserve">
          <source>Log debugging information tracing how a template file was loaded. This can be useful to figure out why a template was not loaded or the wrong file appears to be loaded.</source>
          <target state="translated">记录调试信息,追踪模板文件如何被加载。这对于找出为什么没有加载模板或加载了错误的文件很有用。</target>
        </trans-unit>
        <trans-unit id="57003616863fe634c645e342ee9080681e419c5f" translate="yes" xml:space="preserve">
          <source>Logging</source>
          <target state="translated">Logging</target>
        </trans-unit>
        <trans-unit id="6a543e080861b6d0712158de1beb36d8dbbba741" translate="yes" xml:space="preserve">
          <source>Logging In and Out</source>
          <target state="translated">登录和退出</target>
        </trans-unit>
        <trans-unit id="5a59c2f097d08b74507d6aefd3d4ddcf3116c85d" translate="yes" xml:space="preserve">
          <source>Login Required Decorator</source>
          <target state="translated">需要登录的装修公司</target>
        </trans-unit>
        <trans-unit id="3bee5394d842ecec06060046720c3146be040967" translate="yes" xml:space="preserve">
          <source>Logs an exception. This is called by &lt;a href=&quot;#flask.Flask.handle_exception&quot;&gt;&lt;code&gt;handle_exception()&lt;/code&gt;&lt;/a&gt; if debugging is disabled and right before the handler is called. The default implementation logs the exception as error on the &lt;a href=&quot;#flask.Flask.logger&quot;&gt;&lt;code&gt;logger&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">记录异常。如果禁用了调试，并且在调用处理程序之前，则由&lt;a href=&quot;#flask.Flask.handle_exception&quot;&gt; &lt;code&gt;handle_exception()&lt;/code&gt; &lt;/a&gt;调用此方法。默认实现将异常&lt;a href=&quot;#flask.Flask.logger&quot;&gt; &lt;code&gt;logger&lt;/code&gt; &lt;/a&gt;为错误记录在记录器上。</target>
        </trans-unit>
        <trans-unit id="f64741bd7c5b85973150b29753a5a39d428afc32" translate="yes" xml:space="preserve">
          <source>Make it possible to pass in configuration values for unit tests so that you don&amp;rsquo;t have to create config files on the filesystem.</source>
          <target state="translated">使传递单元测试的配置值成为可能，这样您就不必在文件系统上创建配置文件。</target>
        </trans-unit>
        <trans-unit id="9065c7e7086f40e8f2ff11750080375070825887" translate="yes" xml:space="preserve">
          <source>Make sure that page has a directory listing and the links on the page are pointing to the actual tarballs with their correct filenames as this is how setuptools will find the files. If you have an internal company server that contains the packages, provide the URL to that server.</source>
          <target state="translated">确保该页面有一个目录列表,并且页面上的链接指向具有正确文件名的实际 tarballs,因为这是 setuptools 查找文件的方式。如果您有一个包含软件包的公司内部服务器,请提供该服务器的 URL。</target>
        </trans-unit>
        <trans-unit id="646270467286f1e32671aecc01686a18b45dceaf" translate="yes" xml:space="preserve">
          <source>Make sure to apply it only if you are mounting the application the URL root. Also, see the Lighty docs for more information on &lt;a href=&quot;https://redmine.lighttpd.net/projects/lighttpd/wiki/Docs_ModFastCGI&quot;&gt;FastCGI and Python&lt;/a&gt; (note that explicitly passing a socket to run() is no longer necessary).</source>
          <target state="translated">确保仅在将应用程序安装到URL根目录时才应用它。另外，请参阅Lighty文档以获取有关&lt;a href=&quot;https://redmine.lighttpd.net/projects/lighttpd/wiki/Docs_ModFastCGI&quot;&gt;FastCGI和Python的&lt;/a&gt;更多信息（请注意，不再需要将套接字显式传递给run（））。</target>
        </trans-unit>
        <trans-unit id="e88bc8c5536c44d79ac577682f2de98f1de27d8b" translate="yes" xml:space="preserve">
          <source>Make sure to load the configuration very early on, so that extensions have the ability to access the configuration when starting up. There are other methods on the config object as well to load from individual files. For a complete reference, read the &lt;a href=&quot;../api/index#flask.Config&quot;&gt;&lt;code&gt;Config&lt;/code&gt;&lt;/a&gt; class documentation.</source>
          <target state="translated">确保尽早加载配置，以使扩展程序能够在启动时访问配置。config对象上还有其他方法可以从单个文件中加载。有关完整的参考，请阅读&lt;a href=&quot;../api/index#flask.Config&quot;&gt; &lt;code&gt;Config&lt;/code&gt; &lt;/a&gt;类文档。</target>
        </trans-unit>
        <trans-unit id="3b3b07442e55294f4367fad83ae4b7ffba992c67" translate="yes" xml:space="preserve">
          <source>Make sure to load the configuration very early on, so that extensions have the ability to access the configuration when starting up. There are other methods on the config object as well to load from individual files. For a complete reference, read the &lt;a href=&quot;../api/index#flask.Config&quot;&gt;&lt;code&gt;Config&lt;/code&gt;&lt;/a&gt; object&amp;rsquo;s documentation.</source>
          <target state="translated">确保尽早加载配置，以使扩展程序能够在启动时访问配置。config对象上还有其他方法可以从单个文件中加载。有关完整的参考，请阅读&lt;a href=&quot;../api/index#flask.Config&quot;&gt; &lt;code&gt;Config&lt;/code&gt; &lt;/a&gt;对象的文档。</target>
        </trans-unit>
        <trans-unit id="2fbc71c8b6a1ac43172e23bcfb47a09d8623abc0" translate="yes" xml:space="preserve">
          <source>Make sure to set the executable bit on that file so that the servers can execute it:</source>
          <target state="translated">一定要在该文件上设置可执行位,这样服务器才能执行。</target>
        </trans-unit>
        <trans-unit id="5fb7163dd4bfa6e0f07425cf906f8ee4689ceabb" translate="yes" xml:space="preserve">
          <source>Make sure to subscribe with an extra &lt;code&gt;**extra&lt;/code&gt; argument so that your calls don&amp;rsquo;t fail if Flask introduces new arguments to the signals.</source>
          <target state="translated">确保订阅一个额外的 &lt;code&gt;**extra&lt;/code&gt; 参数，这样，如果Flask在信号中引入新参数，您的调用就不会失败。</target>
        </trans-unit>
        <trans-unit id="6032c9e25f0eb479b2d31e4eefabcacd7259d5b4" translate="yes" xml:space="preserve">
          <source>Make the Project Installable</source>
          <target state="translated">使项目可以安装</target>
        </trans-unit>
        <trans-unit id="ed3248adea7154ab4f6abde34a329d5dc1eb8af4" translate="yes" xml:space="preserve">
          <source>Manual Object Relational Mapping</source>
          <target state="translated">手动对象关系映射</target>
        </trans-unit>
        <trans-unit id="689b1841672c3c369419ed0e54c188a2711107cb" translate="yes" xml:space="preserve">
          <source>Manual object relational mapping has a few upsides and a few downsides versus the declarative approach from above. The main difference is that you define tables and classes separately and map them together. It&amp;rsquo;s more flexible but a little more to type. In general it works like the declarative approach, so make sure to also split up your application into multiple modules in a package.</source>
          <target state="translated">与上面的声明式方法相比，手动对象关系映射具有一些优点和缺点。主要区别在于您分别定义表和类并将它们映射在一起。它更灵活，但需要键入更多内容。通常，它的工作方式类似于声明性方法，因此请确保还将您的应用程序拆分为一个包中的多个模块。</target>
        </trans-unit>
        <trans-unit id="bde702583906b21c3e3e014cd6a6345b2ac18e8c" translate="yes" xml:space="preserve">
          <source>Manually Push a Context</source>
          <target state="translated">手动推送上下文</target>
        </trans-unit>
        <trans-unit id="9957b01d5ea9cb3110e9a80f7cc1b653dfbd7840" translate="yes" xml:space="preserve">
          <source>Many JavaScript libraries also do not support XHTML, due to the more complicated namespacing API it requires.</source>
          <target state="translated">许多JavaScript库也不支持XHTML,因为它需要更复杂的命名间隔API。</target>
        </trans-unit>
        <trans-unit id="da6bd5f2912665489c0cb42e832dc18ac30c83a0" translate="yes" xml:space="preserve">
          <source>Many other features have been added, as well. A good guide to new features in HTML5 is Mark Pilgrim&amp;rsquo;s soon-to-be-published book, &lt;a href=&quot;https://diveintohtml5.info/&quot;&gt;Dive Into HTML5&lt;/a&gt;. Not all of them are supported in browsers yet, however, so use caution.</source>
          <target state="translated">也添加了许多其他功能。Mark Pilgrim即将出版的《&lt;a href=&quot;https://diveintohtml5.info/&quot;&gt;Dive Into HTML5》&lt;/a&gt;是有关HTML5新功能的很好指南。但是，浏览器尚不支持所有这些功能，因此请谨慎使用。</target>
        </trans-unit>
        <trans-unit id="41b342e9cbd04177e4344be8b04ffb93b11e8744" translate="yes" xml:space="preserve">
          <source>Many people prefer &lt;a href=&quot;https://www.sqlalchemy.org/&quot;&gt;SQLAlchemy&lt;/a&gt; for database access. In this case it&amp;rsquo;s encouraged to use a package instead of a module for your flask application and drop the models into a separate module (&lt;a href=&quot;../packages/index#larger-applications&quot;&gt;Larger Applications&lt;/a&gt;). While that is not necessary, it makes a lot of sense.</source>
          <target state="translated">许多人更喜欢使用&lt;a href=&quot;https://www.sqlalchemy.org/&quot;&gt;SQLAlchemy&lt;/a&gt;进行数据库访问。在这种情况下，建议您为烧瓶应用程序使用包而不是模块，并将模型放入单独的模块（&lt;a href=&quot;../packages/index#larger-applications&quot;&gt;大型应用程序&lt;/a&gt;）中。虽然这不是必需的，但很有意义。</target>
        </trans-unit>
        <trans-unit id="90ad3b6e332be4f779398c3e608f8b2edbf5b8ec" translate="yes" xml:space="preserve">
          <source>Mapping Documents</source>
          <target state="translated">映射文件</target>
        </trans-unit>
        <trans-unit id="2a9a70c8dcc46d9e9a980c57324a5bd5838ed9ae" translate="yes" xml:space="preserve">
          <source>Marks a function so that an instance of &lt;a href=&quot;#flask.cli.ScriptInfo&quot;&gt;&lt;code&gt;ScriptInfo&lt;/code&gt;&lt;/a&gt; is passed as first argument to the click callback.</source>
          <target state="translated">标记一个函数，以便将&lt;a href=&quot;#flask.cli.ScriptInfo&quot;&gt; &lt;code&gt;ScriptInfo&lt;/code&gt; &lt;/a&gt;的实例作为第一个参数传递给click回调。</target>
        </trans-unit>
        <trans-unit id="7e1a44d18ed847f8c889dcd45272019b7d37b2c4" translate="yes" xml:space="preserve">
          <source>Message Flashing</source>
          <target state="translated">信息闪烁</target>
        </trans-unit>
        <trans-unit id="88306943fea7e76f9cd57cae0ea6d8b32d2e8434" translate="yes" xml:space="preserve">
          <source>Method</source>
          <target state="translated">Method</target>
        </trans-unit>
        <trans-unit id="0e860a3cce8dcfbcb87b1231bf02fc0c7514a336" translate="yes" xml:space="preserve">
          <source>Method Based Dispatching</source>
          <target state="translated">基于方法的调度</target>
        </trans-unit>
        <trans-unit id="18dee5ab18c805d1c275f6d602abd461caadb880" translate="yes" xml:space="preserve">
          <source>Method Hints</source>
          <target state="translated">方法提示</target>
        </trans-unit>
        <trans-unit id="d13a46cb01094ece7b1c20bbb4b7b2978fdef1c3" translate="yes" xml:space="preserve">
          <source>Method Views for APIs</source>
          <target state="translated">API的方法视图</target>
        </trans-unit>
        <trans-unit id="080e203bc1aa1972bf13ffdd47a3ff4088e1c6c2" translate="yes" xml:space="preserve">
          <source>Micro with Dependencies</source>
          <target state="translated">微观与依赖性</target>
        </trans-unit>
        <trans-unit id="b41630f65f15dd7bef2578275e453990c676f821" translate="yes" xml:space="preserve">
          <source>Modern web applications use meaningful URLs to help users. Users are more likely to like a page and come back if the page uses a meaningful URL they can remember and use to directly visit a page.</source>
          <target state="translated">现代网络应用使用有意义的URL来帮助用户。如果页面使用有意义的URL,用户可以记住并用于直接访问页面,那么用户就更有可能喜欢一个页面并回来。</target>
        </trans-unit>
        <trans-unit id="ad2166d65a2bca78f011c265f1465da5ded24dd0" translate="yes" xml:space="preserve">
          <source>Modular Applications with Blueprints</source>
          <target state="translated">模块化应用与蓝图</target>
        </trans-unit>
        <trans-unit id="0920697dfc3afdd2a76863c207eb888587b34aba" translate="yes" xml:space="preserve">
          <source>MongoDB with MongoEngine</source>
          <target state="translated">MongoDB与MongoEngine</target>
        </trans-unit>
        <trans-unit id="93f06cc9dc37c5b45e521024a37163f625a195a6" translate="yes" xml:space="preserve">
          <source>More information on error handling see &lt;a href=&quot;../patterns/errorpages/index#errorpages&quot;&gt;Custom Error Pages&lt;/a&gt;.</source>
          <target state="translated">有关错误处理的更多信息，请参见&amp;ldquo;&lt;a href=&quot;../patterns/errorpages/index#errorpages&quot;&gt;自定义错误页面&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4d9a5965cc3d95cc9fa0794943ec75626816d3d1" translate="yes" xml:space="preserve">
          <source>More information on using the debugger can be found in the &lt;a href=&quot;https://werkzeug.palletsprojects.com/debug/#using-the-debugger&quot;&gt;Werkzeug documentation&lt;/a&gt;.</source>
          <target state="translated">有关使用调试器的更多信息，请参见&lt;a href=&quot;https://werkzeug.palletsprojects.com/debug/#using-the-debugger&quot;&gt;Werkzeug文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c71404b4630a1c5e87cc84f96876ee0d15b4d2e3" translate="yes" xml:space="preserve">
          <source>Most applications need more than one configuration. There should be at least separate configurations for the production server and the one used during development. The easiest way to handle this is to use a default configuration that is always loaded and part of the version control, and a separate configuration that overrides the values as necessary as mentioned in the example above:</source>
          <target state="translated">大多数应用程序需要一个以上的配置。至少应该为生产服务器和开发过程中使用的服务器分别配置。最简单的处理方法是使用一个默认的配置,它总是被加载并成为版本控制的一部分,同时使用一个单独的配置,根据需要覆盖上面例子中提到的值。</target>
        </trans-unit>
        <trans-unit id="77b71f2a44602e57c67bf1634d3a5e7aa9b74a10" translate="yes" xml:space="preserve">
          <source>Most editors save as UTF-8 by default nowadays but in case your editor is not configured to do this you have to change it. Here some common ways to set your editor to store as UTF-8:</source>
          <target state="translated">现在大多数编辑器都默认保存为UTF-8,但如果你的编辑器没有配置为UTF-8,你必须改变它。这里有一些常见的方法来设置你的编辑器为UTF-8。</target>
        </trans-unit>
        <trans-unit id="dbd2ffae20892559dc947f7b36c53e9f27373d15" translate="yes" xml:space="preserve">
          <source>Most errorhandlers will simply work as expected; however, there is a caveat concerning handlers for 404 and 405 exceptions. These errorhandlers are only invoked from an appropriate &lt;code&gt;raise&lt;/code&gt; statement or a call to &lt;code&gt;abort&lt;/code&gt; in another of the blueprint&amp;rsquo;s view functions; they are not invoked by, e.g., an invalid URL access. This is because the blueprint does not &amp;ldquo;own&amp;rdquo; a certain URL space, so the application instance has no way of knowing which blueprint error handler it should run if given an invalid URL. If you would like to execute different handling strategies for these errors based on URL prefixes, they may be defined at the application level using the &lt;code&gt;request&lt;/code&gt; proxy object:</source>
          <target state="translated">大多数错误处理程序将按预期工作。但是，有一个关于404和405异常处理程序的警告。这些错误处理程序只能从适当的 &lt;code&gt;raise&lt;/code&gt; 语句或在蓝图的另一个视图函数中 &lt;code&gt;abort&lt;/code&gt; 的调用中调用。例如，无效的URL访问不会调用它们。这是因为该蓝图不&amp;ldquo;拥有&amp;rdquo;某个URL空间，因此应用程序实例无法知道如果给出无效的URL应该运行哪个蓝图错误处理程序。如果您想基于URL前缀对这些错误执行不同的处理策略，则可以在应用程序级别使用 &lt;code&gt;request&lt;/code&gt; 代理对象定义这些错误：</target>
        </trans-unit>
        <trans-unit id="eb484e72d047fe4c4545951c3202e52bfda58450" translate="yes" xml:space="preserve">
          <source>Most modern terminals will warn about and remove hidden characters when pasting, so this isn&amp;rsquo;t strictly necessary. It&amp;rsquo;s also possible to craft dangerous commands in other ways that aren&amp;rsquo;t possible to filter. Depending on your site&amp;rsquo;s use case, it may be good to show a warning about copying code in general.</source>
          <target state="translated">大多数现代终端会在粘贴时发出警告并删除隐藏的字符，因此这并不是绝对必要的。还可以用其他无法过滤的方式来设计危险的命令。根据您网站的用例，通常最好显示有关复制代码的警告。</target>
        </trans-unit>
        <trans-unit id="ba791e12b3f4017c9221840c7e568c78c267fb69" translate="yes" xml:space="preserve">
          <source>Most notably, the syntax for directory permissions has changed from httpd 2.2</source>
          <target state="translated">最值得注意的是,从httpd 2.2开始,目录权限的语法发生了变化。</target>
        </trans-unit>
        <trans-unit id="ac3335dc28b89f898189f9b890ad2becbb76af8c" translate="yes" xml:space="preserve">
          <source>Most of the time you don&amp;rsquo;t have to care about that, but there are some exceptions where it is good to know that this object is actually a proxy:</source>
          <target state="translated">大多数时候，您不必关心这一点，但是在某些例外情况下，很高兴知道此对象实际上是代理：</target>
        </trans-unit>
        <trans-unit id="f5dfdba36e382aaf9131bfe3dabd6a731fd3df19" translate="yes" xml:space="preserve">
          <source>Most parameters to the &lt;code&gt;setup&lt;/code&gt; function should be self explanatory, &lt;code&gt;include_package_data&lt;/code&gt; and &lt;code&gt;zip_safe&lt;/code&gt; might not be. &lt;code&gt;include_package_data&lt;/code&gt; tells setuptools to look for a &lt;code&gt;MANIFEST.in&lt;/code&gt; file and install all the entries that match as package data. We will use this to distribute the static files and templates along with the Python module (see &lt;a href=&quot;#distributing-resources&quot;&gt;Distributing Resources&lt;/a&gt;). The &lt;code&gt;zip_safe&lt;/code&gt; flag can be used to force or prevent zip Archive creation. In general you probably don&amp;rsquo;t want your packages to be installed as zip files because some tools do not support them and they make debugging a lot harder.</source>
          <target state="translated">&lt;code&gt;setup&lt;/code&gt; 功能的大多数参数应该是自我解释的， &lt;code&gt;include_package_data&lt;/code&gt; 和 &lt;code&gt;zip_safe&lt;/code&gt; 可能不是。 &lt;code&gt;include_package_data&lt;/code&gt; 告诉setuptools在文件 &lt;code&gt;MANIFEST.in&lt;/code&gt; 中查找并安装所有与软件包数据匹配的条目。我们将使用它来分发静态文件和模板以及Python模块（请参阅&amp;ldquo;&lt;a href=&quot;#distributing-resources&quot;&gt;分发资源&amp;rdquo;&lt;/a&gt;）。该 &lt;code&gt;zip_safe&lt;/code&gt; 标志可用于强制或防止拉链封存建立。通常，您可能不希望将软件包安装为zip文件，因为某些工具不支持它们，并且调试变得更加困难。</target>
        </trans-unit>
        <trans-unit id="3eb9b5236e296458cccdca81aeeef7acd97a6931" translate="yes" xml:space="preserve">
          <source>Multiple arguments: Converted to an array before being passed to &lt;a href=&quot;#flask.json.dumps&quot;&gt;&lt;code&gt;dumps()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">多个参数：在传递给&lt;a href=&quot;#flask.json.dumps&quot;&gt; &lt;code&gt;dumps()&lt;/code&gt; &lt;/a&gt;之前转换为数组。</target>
        </trans-unit>
        <trans-unit id="28cb69c73d41571be5f4ab3a7c1098f0c40bbf37" translate="yes" xml:space="preserve">
          <source>Multiple instances. Imagine you want to run different versions of the same application. Of course you could have multiple instances with different configs set up in your webserver, but if you use factories, you can have multiple instances of the same application running in the same application process which can be handy.</source>
          <target state="translated">多个实例。想象一下,你想运行同一个应用程序的不同版本。当然,你可以在web服务器中设置不同配置的多个实例,但如果你使用工厂,你可以在同一个应用程序进程中运行同一个应用程序的多个实例,这可以很方便。</target>
        </trans-unit>
        <trans-unit id="5d6b5aa420346dd4e18c950a40d2fa3cfc54f28c" translate="yes" xml:space="preserve">
          <source>Multiple keyword arguments: Converted to a dict before being passed to &lt;a href=&quot;#flask.json.dumps&quot;&gt;&lt;code&gt;dumps()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">多个关键字参数：在传递给&lt;a href=&quot;#flask.json.dumps&quot;&gt; &lt;code&gt;dumps()&lt;/code&gt; &lt;/a&gt;之前转换为dict 。</target>
        </trans-unit>
        <trans-unit id="57680ef2e5779c63dbeacb8326a54a2cec4c69e2" translate="yes" xml:space="preserve">
          <source>My First Blueprint</source>
          <target state="translated">我的第一张蓝图</target>
        </trans-unit>
        <trans-unit id="8af56df8a9cb35f56b67edd6d269d4e86defc0d0" translate="yes" xml:space="preserve">
          <source>Naming Conventions</source>
          <target state="translated">命名惯例</target>
        </trans-unit>
        <trans-unit id="41066e0da3e06ae98b07c231bf5a9722f4555a7b" translate="yes" xml:space="preserve">
          <source>Never pass &lt;a href=&quot;../api/index#flask.current_app&quot;&gt;&lt;code&gt;current_app&lt;/code&gt;&lt;/a&gt; as sender to a signal. Use &lt;code&gt;current_app._get_current_object()&lt;/code&gt; instead. The reason for this is that &lt;a href=&quot;../api/index#flask.current_app&quot;&gt;&lt;code&gt;current_app&lt;/code&gt;&lt;/a&gt; is a proxy and not the real application object.</source>
          <target state="translated">切勿将&lt;a href=&quot;../api/index#flask.current_app&quot;&gt; &lt;code&gt;current_app&lt;/code&gt; &lt;/a&gt;作为发送者传递给信号。请改用 &lt;code&gt;current_app._get_current_object()&lt;/code&gt; 。原因是&lt;a href=&quot;../api/index#flask.current_app&quot;&gt; &lt;code&gt;current_app&lt;/code&gt; &lt;/a&gt;是代理，而不是实际的应用程序对象。</target>
        </trans-unit>
        <trans-unit id="ce92f017a193591ede765207cb83ee98ed6a065c" translate="yes" xml:space="preserve">
          <source>New form control types like &lt;code&gt;&amp;lt;input type=&quot;date&quot;&amp;gt;&lt;/code&gt; that allow user agents to make entering and validating values easier.</source>
          <target state="translated">像 &lt;code&gt;&amp;lt;input type=&quot;date&quot;&amp;gt;&lt;/code&gt; 这样的新表单控件类型，它们使用户代理可以更轻松地输入和验证值。</target>
        </trans-unit>
        <trans-unit id="2dcde8ec0560b6129ac7ceb94e6b76437cebda2e" translate="yes" xml:space="preserve">
          <source>New in version 0.10.</source>
          <target state="translated">0.10版本的新内容。</target>
        </trans-unit>
        <trans-unit id="d77768ffa2697b58e99430802d63a488ca8f1862" translate="yes" xml:space="preserve">
          <source>New in version 0.10: &lt;code&gt;JSON_AS_ASCII&lt;/code&gt;, &lt;code&gt;JSON_SORT_KEYS&lt;/code&gt;, &lt;code&gt;JSONIFY_PRETTYPRINT_REGULAR&lt;/code&gt;</source>
          <target state="translated">版本0.10中的新功能： &lt;code&gt;JSON_AS_ASCII&lt;/code&gt; ， &lt;code&gt;JSON_SORT_KEYS&lt;/code&gt; ， &lt;code&gt;JSONIFY_PRETTYPRINT_REGULAR&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="015f2bcb0825334ffc779dbaf1cf4865c2f38130" translate="yes" xml:space="preserve">
          <source>New in version 0.10: The &lt;code&gt;_scheme&lt;/code&gt; parameter was added.</source>
          <target state="translated">版本0.10中的新功能：添加了 &lt;code&gt;_scheme&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="66ee92bb81502405c10e37afde172f538939d0dd" translate="yes" xml:space="preserve">
          <source>New in version 0.10: The class used for the Response object can now be passed in.</source>
          <target state="translated">0.10版本的新内容:现在可以传递用于响应对象的类。</target>
        </trans-unit>
        <trans-unit id="d901f06ab6924e2df9f3cb2ea900186360f06a13" translate="yes" xml:space="preserve">
          <source>New in version 0.11.</source>
          <target state="translated">0.11版本的新内容。</target>
        </trans-unit>
        <trans-unit id="6e3edabb1529850f9b2486c7eeb5d60be12eacbd" translate="yes" xml:space="preserve">
          <source>New in version 0.11: &lt;code&gt;SESSION_REFRESH_EACH_REQUEST&lt;/code&gt;, &lt;code&gt;TEMPLATES_AUTO_RELOAD&lt;/code&gt;, &lt;code&gt;LOGGER_HANDLER_POLICY&lt;/code&gt;, &lt;code&gt;EXPLAIN_TEMPLATE_LOADING&lt;/code&gt;</source>
          <target state="translated">版本0.11中的新功能： &lt;code&gt;SESSION_REFRESH_EACH_REQUEST&lt;/code&gt; ， &lt;code&gt;TEMPLATES_AUTO_RELOAD&lt;/code&gt; ， &lt;code&gt;LOGGER_HANDLER_POLICY&lt;/code&gt; ， &lt;code&gt;EXPLAIN_TEMPLATE_LOADING&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3c51e13c84c4659a09ece303bfb0020a45f42402" translate="yes" xml:space="preserve">
          <source>New in version 0.11: The &lt;code&gt;root_path&lt;/code&gt; parameter was added.</source>
          <target state="translated">版本0.11中的新增功能：添加了 &lt;code&gt;root_path&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="3db82b71db4f119cb146d025cfbcb50c42cb64ab" translate="yes" xml:space="preserve">
          <source>New in version 0.2.</source>
          <target state="translated">0.2版本的新内容。</target>
        </trans-unit>
        <trans-unit id="c2d8a3cd01edb316aa730a0d83e51852e17b4df1" translate="yes" xml:space="preserve">
          <source>New in version 0.3.</source>
          <target state="translated">0.3版本的新内容。</target>
        </trans-unit>
        <trans-unit id="6639d5c5a695f841ab58c77838e47057b1874567" translate="yes" xml:space="preserve">
          <source>New in version 0.4.</source>
          <target state="translated">0.4版本的新内容。</target>
        </trans-unit>
        <trans-unit id="7030d01990ec68a640d28b65918196e5df66192a" translate="yes" xml:space="preserve">
          <source>New in version 0.4: &lt;code&gt;LOGGER_NAME&lt;/code&gt;</source>
          <target state="translated">0.4版的新功能： &lt;code&gt;LOGGER_NAME&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1c41c95cafce09fc00bdb02d31fa4b185ade21eb" translate="yes" xml:space="preserve">
          <source>New in version 0.5.</source>
          <target state="translated">0.5版本的新内容。</target>
        </trans-unit>
        <trans-unit id="bb0035bb0dfeed92380da4c5420ad81fb79d1339" translate="yes" xml:space="preserve">
          <source>New in version 0.5: &lt;code&gt;SERVER_NAME&lt;/code&gt;</source>
          <target state="translated">版本0.5中的新功能： &lt;code&gt;SERVER_NAME&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="60dcdaf889c98975f9b444a895165bdfe86caa3d" translate="yes" xml:space="preserve">
          <source>New in version 0.5: The &lt;code&gt;add_etags&lt;/code&gt;, &lt;code&gt;cache_timeout&lt;/code&gt; and &lt;code&gt;conditional&lt;/code&gt; parameters were added. The default behavior is now to attach etags.</source>
          <target state="translated">版本0.5中的新功能：添加了 &lt;code&gt;add_etags&lt;/code&gt; ， &lt;code&gt;cache_timeout&lt;/code&gt; 和 &lt;code&gt;conditional&lt;/code&gt; 参数。现在，默认行为是附加etags。</target>
        </trans-unit>
        <trans-unit id="4f33d48a116e87598f363ffc066b970e1a01cbfa" translate="yes" xml:space="preserve">
          <source>New in version 0.6.</source>
          <target state="translated">0.6版本的新内容。</target>
        </trans-unit>
        <trans-unit id="b47405ba63a93bde7dbee895944e5529056abb71" translate="yes" xml:space="preserve">
          <source>New in version 0.6: &lt;code&gt;MAX_CONTENT_LENGTH&lt;/code&gt;</source>
          <target state="translated">0.6版的新功能： &lt;code&gt;MAX_CONTENT_LENGTH&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2dcc1ba7fc59a7f4d73841ce91852405e1848933" translate="yes" xml:space="preserve">
          <source>New in version 0.6: The location can now be a unicode string that is encoded using the &lt;code&gt;iri_to_uri()&lt;/code&gt; function.</source>
          <target state="translated">0.6版中的新增功能：该位置现在可以是使用 &lt;code&gt;iri_to_uri()&lt;/code&gt; 函数进行编码的unicode字符串。</target>
        </trans-unit>
        <trans-unit id="14ad4031ecfa25c70438a769924a97f361e055c3" translate="yes" xml:space="preserve">
          <source>New in version 0.7.</source>
          <target state="translated">0.7版本的新内容。</target>
        </trans-unit>
        <trans-unit id="2ee5cf04c7eacc6b3d5797b6b481e71558eee01f" translate="yes" xml:space="preserve">
          <source>New in version 0.7: &lt;code&gt;PROPAGATE_EXCEPTIONS&lt;/code&gt;, &lt;code&gt;PRESERVE_CONTEXT_ON_EXCEPTION&lt;/code&gt;</source>
          <target state="translated">0.7版的新功能： &lt;code&gt;PROPAGATE_EXCEPTIONS&lt;/code&gt; ， &lt;code&gt;PRESERVE_CONTEXT_ON_EXCEPTION&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ac734f6e1b27801e91a0de604e4974622e90bdd4" translate="yes" xml:space="preserve">
          <source>New in version 0.7: &lt;code&gt;silent&lt;/code&gt; parameter.</source>
          <target state="translated">0.7版中的新功能： &lt;code&gt;silent&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="36dddd6984c165960ba720e58c8664406e6fd9ed" translate="yes" xml:space="preserve">
          <source>New in version 0.7: One can now additionally also register custom exception types that do not necessarily have to be a subclass of the &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/exceptions/#werkzeug.exceptions.HTTPException&quot;&gt;&lt;code&gt;HTTPException&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">0.7版的新增功能：现在，用户还可以注册自定义异常类型，这些类型不必一定是&lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/exceptions/#werkzeug.exceptions.HTTPException&quot;&gt; &lt;code&gt;HTTPException&lt;/code&gt; &lt;/a&gt;类的子类。</target>
        </trans-unit>
        <trans-unit id="1b97580d55c9f1893e4d172e44b765b80d5cd337" translate="yes" xml:space="preserve">
          <source>New in version 0.7: The &lt;code&gt;static_url_path&lt;/code&gt;, &lt;code&gt;static_folder&lt;/code&gt;, and &lt;code&gt;template_folder&lt;/code&gt; parameters were added.</source>
          <target state="translated">0.7版中的新功能：添加了 &lt;code&gt;static_url_path&lt;/code&gt; ， &lt;code&gt;static_folder&lt;/code&gt; 和 &lt;code&gt;template_folder&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="13b19e397c12332037933fb38a32aa7db4acaad4" translate="yes" xml:space="preserve">
          <source>New in version 0.7: The &lt;code&gt;use_cookies&lt;/code&gt; parameter was added as well as the ability to override the client to be used by setting the &lt;a href=&quot;#flask.Flask.test_client_class&quot;&gt;&lt;code&gt;test_client_class&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">0.7版中的新增功能：添加了 &lt;code&gt;use_cookies&lt;/code&gt; 参数，并具有通过设置&lt;a href=&quot;#flask.Flask.test_client_class&quot;&gt; &lt;code&gt;test_client_class&lt;/code&gt; &lt;/a&gt;属性来覆盖要使用的客户端的功能。</target>
        </trans-unit>
        <trans-unit id="66daad19803df88d78f81af68d7567a2063bfd57" translate="yes" xml:space="preserve">
          <source>New in version 0.7: Use &lt;a href=&quot;#flask.Flask.register_error_handler&quot;&gt;&lt;code&gt;register_error_handler()&lt;/code&gt;&lt;/a&gt; instead of modifying &lt;a href=&quot;#flask.Flask.error_handler_spec&quot;&gt;&lt;code&gt;error_handler_spec&lt;/code&gt;&lt;/a&gt; directly, for application wide error handlers.</source>
          <target state="translated">0.7版中的新增功能：对于应用程序范围的错误处理程序，请使用&lt;a href=&quot;#flask.Flask.register_error_handler&quot;&gt; &lt;code&gt;register_error_handler()&lt;/code&gt; &lt;/a&gt;而不是直接修改&lt;a href=&quot;#flask.Flask.error_handler_spec&quot;&gt; &lt;code&gt;error_handler_spec&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="48e2833e629833b7582fc86a591171cccb4a2aa1" translate="yes" xml:space="preserve">
          <source>New in version 0.8.</source>
          <target state="translated">0.8版本的新内容。</target>
        </trans-unit>
        <trans-unit id="952a31c4a3afec4d61dbbbd84b4bcba4164fe691" translate="yes" xml:space="preserve">
          <source>New in version 0.8: &lt;code&gt;TRAP_BAD_REQUEST_ERRORS&lt;/code&gt;, &lt;code&gt;TRAP_HTTP_EXCEPTIONS&lt;/code&gt;, &lt;code&gt;APPLICATION_ROOT&lt;/code&gt;, &lt;code&gt;SESSION_COOKIE_DOMAIN&lt;/code&gt;, &lt;code&gt;SESSION_COOKIE_PATH&lt;/code&gt;, &lt;code&gt;SESSION_COOKIE_HTTPONLY&lt;/code&gt;, &lt;code&gt;SESSION_COOKIE_SECURE&lt;/code&gt;</source>
          <target state="translated">0.8版中的新功能： &lt;code&gt;TRAP_BAD_REQUEST_ERRORS&lt;/code&gt; ， &lt;code&gt;TRAP_HTTP_EXCEPTIONS&lt;/code&gt; ， &lt;code&gt;APPLICATION_ROOT&lt;/code&gt; ， &lt;code&gt;SESSION_COOKIE_DOMAIN&lt;/code&gt; ， &lt;code&gt;SESSION_COOKIE_PATH&lt;/code&gt; ， &lt;code&gt;SESSION_COOKIE_HTTPONLY&lt;/code&gt; ， &lt;code&gt;SESSION_COOKIE_SECURE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="08f54f21de13750c860ceb1f3a5096c261fa0b34" translate="yes" xml:space="preserve">
          <source>New in version 0.8: The &lt;code&gt;instance_path&lt;/code&gt; and &lt;code&gt;instance_relative_config&lt;/code&gt; parameters were added.</source>
          <target state="translated">0.8版中的新功能：添加了 &lt;code&gt;instance_path&lt;/code&gt; 和 &lt;code&gt;instance_relative_config&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="7d31454bfa9197a873474db6c79e1620356882c1" translate="yes" xml:space="preserve">
          <source>New in version 0.8: The &lt;code&gt;provide_automatic_options&lt;/code&gt; functionality was added.</source>
          <target state="translated">0.8版中的 &lt;code&gt;provide_automatic_options&lt;/code&gt; 功能：添加了Provide_automatic_options功能。</target>
        </trans-unit>
        <trans-unit id="e0798e2f31cc8f6f05534a395874ff516c037ea2" translate="yes" xml:space="preserve">
          <source>New in version 0.9.</source>
          <target state="translated">0.9版本的新内容。</target>
        </trans-unit>
        <trans-unit id="2a3006614e8fd06c4b23bec9e33409dbfb343193" translate="yes" xml:space="preserve">
          <source>New in version 0.9: &lt;code&gt;PREFERRED_URL_SCHEME&lt;/code&gt;</source>
          <target state="translated">0.9版的新功能： &lt;code&gt;PREFERRED_URL_SCHEME&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ef0d27b56992c3ed82de0e958be209b9327393f8" translate="yes" xml:space="preserve">
          <source>New in version 0.9: Calls &lt;code&gt;Flask.handle_build_error()&lt;/code&gt; on &lt;code&gt;BuildError&lt;/code&gt;.</source>
          <target state="translated">0.9版的新功能：在 &lt;code&gt;BuildError&lt;/code&gt; 上调用 &lt;code&gt;Flask.handle_build_error()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ad5475e0d1b38b69d4f93eb159ff10139726c054" translate="yes" xml:space="preserve">
          <source>New in version 0.9: The &lt;code&gt;_anchor&lt;/code&gt; and &lt;code&gt;_method&lt;/code&gt; parameters were added.</source>
          <target state="translated">0.9版中的新功能：添加了 &lt;code&gt;_anchor&lt;/code&gt; 和 &lt;code&gt;_method&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="8b2f96e51721073c2329a19baf189725a5445aae" translate="yes" xml:space="preserve">
          <source>New in version 1.0.</source>
          <target state="translated">在1.0版本中新增。</target>
        </trans-unit>
        <trans-unit id="aa9acf540d02f88f0831060de8fc025d185993ba" translate="yes" xml:space="preserve">
          <source>New in version 1.0: The &lt;code&gt;host_matching&lt;/code&gt; and &lt;code&gt;static_host&lt;/code&gt; parameters were added.</source>
          <target state="translated">1.0版中的新功能：添加了 &lt;code&gt;host_matching&lt;/code&gt; 和 &lt;code&gt;static_host&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="52151da4054cb1e82efba0810cedbfdecef8677d" translate="yes" xml:space="preserve">
          <source>New in version 1.0: The &lt;code&gt;subdomain_matching&lt;/code&gt; parameter was added. Subdomain matching needs to be enabled manually now. Setting &lt;a href=&quot;../config/index#SERVER_NAME&quot;&gt;&lt;code&gt;SERVER_NAME&lt;/code&gt;&lt;/a&gt; does not implicitly enable it.</source>
          <target state="translated">1.0版中的新增功能：添加了 &lt;code&gt;subdomain_matching&lt;/code&gt; 参数。现在需要手动启用子域匹配。设置&lt;a href=&quot;../config/index#SERVER_NAME&quot;&gt; &lt;code&gt;SERVER_NAME&lt;/code&gt; &lt;/a&gt;不会隐式启用它。</target>
        </trans-unit>
        <trans-unit id="d684ecad683ae61e9733e1e6a9bdc5d7760139ec" translate="yes" xml:space="preserve">
          <source>New in version 1.0: This property was added but the underlying config and behavior already existed.</source>
          <target state="translated">在1.0版本中新增。增加了这个属性,但底层配置和行为已经存在。</target>
        </trans-unit>
        <trans-unit id="daec5bda660dbd887ca359b8282c54881c1e5659" translate="yes" xml:space="preserve">
          <source>New in version 1.1: Partial content supports &lt;a href=&quot;https://docs.python.org/3/library/io.html#io.BytesIO&quot;&gt;&lt;code&gt;BytesIO&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">版本1.1中的新增功能：部分内容支持&lt;a href=&quot;https://docs.python.org/3/library/io.html#io.BytesIO&quot;&gt; &lt;code&gt;BytesIO&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="21e6a095b4d0c42472aa09874995cbaab6eae980" translate="yes" xml:space="preserve">
          <source>New in version 3.0: Added the &lt;code&gt;standalone_mode&lt;/code&gt; flag to control the standalone mode.</source>
          <target state="translated">3.0版中的新增功能：添加了 &lt;code&gt;standalone_mode&lt;/code&gt; 标志来控制独立模式。</target>
        </trans-unit>
        <trans-unit id="ff8e54e05165be2150ade11c6cc300149be7a090" translate="yes" xml:space="preserve">
          <source>New semantic tags like &lt;code&gt;&amp;lt;article&amp;gt;&lt;/code&gt;</source>
          <target state="translated">新的语义标签，例如 &lt;code&gt;&amp;lt;article&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d2363e9126e517a113094c045418a3529ff4f416" translate="yes" xml:space="preserve">
          <source>New technologies in HTML5</source>
          <target state="translated">HTML5中的新技术</target>
        </trans-unit>
        <trans-unit id="3f170caead65df254d786032a409a6f6d204bca6" translate="yes" xml:space="preserve">
          <source>Next Steps</source>
          <target state="translated">下一步工作</target>
        </trans-unit>
        <trans-unit id="902b84c59e79daac015dac07c9d5096f423d7b2a" translate="yes" xml:space="preserve">
          <source>Next the functions that check if an extension is valid and that uploads the file and redirects the user to the URL for the uploaded file:</source>
          <target state="translated">接下来是检查扩展名是否有效、上传文件并将用户重定向到上传文件的URL的函数。</target>
        </trans-unit>
        <trans-unit id="779bc860ad90624cb74a5272deafc3ae5b9ba507" translate="yes" xml:space="preserve">
          <source>Next we create an instance of this class. The first argument is the name of the application&amp;rsquo;s module or package. If you are using a single module (as in this example), you should use &lt;code&gt;__name__&lt;/code&gt; because depending on if it&amp;rsquo;s started as application or imported as module the name will be different (&lt;code&gt;'__main__'&lt;/code&gt; versus the actual import name). This is needed so that Flask knows where to look for templates, static files, and so on. For more information have a look at the &lt;a href=&quot;../api/index#flask.Flask&quot;&gt;&lt;code&gt;Flask&lt;/code&gt;&lt;/a&gt; documentation.</source>
          <target state="translated">接下来，我们创建此类的实例。第一个参数是应用程序的模块或软件包的名称。如果使用的是单个模块（如本例所示），则应使用 &lt;code&gt;__name__&lt;/code&gt; ,因为根据它是作为应用程序启动还是作为模块导入，其名称将有所不同（ &lt;code&gt;'__main__'&lt;/code&gt; 与实际的导入名称）。这是必需的，以便Flask知道在哪里可以找到模板，静态文件等。有关更多信息，请参阅&lt;a href=&quot;../api/index#flask.Flask&quot;&gt; &lt;code&gt;Flask&lt;/code&gt; &lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="4d04645e35f735c3bf66c21955a983c80aeb5cc8" translate="yes" xml:space="preserve">
          <source>Next we need to set the working directory (&lt;strong&gt;D&lt;/strong&gt;) to be the folder where our application resides.</source>
          <target state="translated">接下来，我们需要将工作目录（&lt;strong&gt;D&lt;/strong&gt;）设置为应用程序所在的文件夹。</target>
        </trans-unit>
        <trans-unit id="5c28327d8892ad1639775dc84bed4baa3901a45b" translate="yes" xml:space="preserve">
          <source>Next, we create a &lt;a href=&quot;https://docs.pytest.org/en/latest/fixture.html&quot;&gt;pytest fixture&lt;/a&gt; called &lt;code&gt;client()&lt;/code&gt; that configures the application for testing and initializes a new database:</source>
          <target state="translated">接下来，我们创建一个名为 &lt;code&gt;client()&lt;/code&gt; 的&lt;a href=&quot;https://docs.pytest.org/en/latest/fixture.html&quot;&gt;pytest固定装置&lt;/a&gt;，用于配置应用程序进行测试并初始化新数据库：</target>
        </trans-unit>
        <trans-unit id="ba1007a80d33694e0bd0ff2d9170c49b79224d97" translate="yes" xml:space="preserve">
          <source>Non-decorator version of the &lt;a href=&quot;#flask.Blueprint.errorhandler&quot;&gt;&lt;code&gt;errorhandler()&lt;/code&gt;&lt;/a&gt; error attach function, akin to the &lt;a href=&quot;#flask.Flask.register_error_handler&quot;&gt;&lt;code&gt;register_error_handler()&lt;/code&gt;&lt;/a&gt; application-wide function of the &lt;a href=&quot;#flask.Flask&quot;&gt;&lt;code&gt;Flask&lt;/code&gt;&lt;/a&gt; object but for error handlers limited to this blueprint.</source>
          <target state="translated">在非装饰版本&lt;a href=&quot;#flask.Blueprint.errorhandler&quot;&gt; &lt;code&gt;errorhandler()&lt;/code&gt; &lt;/a&gt;的错误连接功能，如同对&lt;a href=&quot;#flask.Flask.register_error_handler&quot;&gt; &lt;code&gt;register_error_handler()&lt;/code&gt; &lt;/a&gt;中的应用程序范围内功能&lt;a href=&quot;#flask.Flask&quot;&gt; &lt;code&gt;Flask&lt;/code&gt; &lt;/a&gt;对象但限于此蓝图错误处理程序。</target>
        </trans-unit>
        <trans-unit id="79350364ca96a8840d72d7498e54fb798adfa0ef" translate="yes" xml:space="preserve">
          <source>Non-standard HTTP codes cannot be registered by code because they are not known by Werkzeug. Instead, define a subclass of &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/exceptions/#werkzeug.exceptions.HTTPException&quot;&gt;&lt;code&gt;HTTPException&lt;/code&gt;&lt;/a&gt; with the appropriate code and register and raise that exception class.</source>
          <target state="translated">非标准HTTP代码无法通过代码注册，因为Werkzeug不知道它们。而是使用适当的代码定义&lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/exceptions/#werkzeug.exceptions.HTTPException&quot;&gt; &lt;code&gt;HTTPException&lt;/code&gt; &lt;/a&gt;的子类，然后注册并引发该异常类。</target>
        </trans-unit>
        <trans-unit id="e43b44b9d976e2fb4aa4082c2f203e431b89e69a" translate="yes" xml:space="preserve">
          <source>Normally you would use the &lt;code&gt;with&lt;/code&gt; statement to make this request object active, but in the shell it&amp;rsquo;s easier to use the &lt;a href=&quot;../api/index#flask.ctx.RequestContext.push&quot;&gt;&lt;code&gt;push()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../api/index#flask.ctx.RequestContext.pop&quot;&gt;&lt;code&gt;pop()&lt;/code&gt;&lt;/a&gt; methods by hand:</source>
          <target state="translated">通常，您将使用 &lt;code&gt;with&lt;/code&gt; 语句来使此请求对象处于活动状态，但是在外壳中，手动使用&lt;a href=&quot;../api/index#flask.ctx.RequestContext.push&quot;&gt; &lt;code&gt;push()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../api/index#flask.ctx.RequestContext.pop&quot;&gt; &lt;code&gt;pop()&lt;/code&gt; &lt;/a&gt;方法会更容易：</target>
        </trans-unit>
        <trans-unit id="7e67316f4622234d858559bf70fe2fa97eaa5ea3" translate="yes" xml:space="preserve">
          <source>Not to be confused with &lt;a href=&quot;#flask.cli.FlaskGroup&quot;&gt;&lt;code&gt;FlaskGroup&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">不要与&lt;a href=&quot;#flask.cli.FlaskGroup&quot;&gt; &lt;code&gt;FlaskGroup&lt;/code&gt; &lt;/a&gt;混淆。</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="fdc249587f2ab1c2cc4ed72a136aee14a1e4d384" translate="yes" xml:space="preserve">
          <source>Note however that if you are using a test request context, the &lt;a href=&quot;../api/index#flask.Flask.before_request&quot;&gt;&lt;code&gt;before_request()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../api/index#flask.Flask.after_request&quot;&gt;&lt;code&gt;after_request()&lt;/code&gt;&lt;/a&gt; functions are not called automatically. However &lt;a href=&quot;../api/index#flask.Flask.teardown_request&quot;&gt;&lt;code&gt;teardown_request()&lt;/code&gt;&lt;/a&gt; functions are indeed executed when the test request context leaves the &lt;code&gt;with&lt;/code&gt; block. If you do want the &lt;a href=&quot;../api/index#flask.Flask.before_request&quot;&gt;&lt;code&gt;before_request()&lt;/code&gt;&lt;/a&gt; functions to be called as well, you need to call &lt;a href=&quot;../api/index#flask.Flask.preprocess_request&quot;&gt;&lt;code&gt;preprocess_request()&lt;/code&gt;&lt;/a&gt; yourself:</source>
          <target state="translated">但是请注意，如果使用测试请求上下文，则不会自动调用&lt;a href=&quot;../api/index#flask.Flask.before_request&quot;&gt; &lt;code&gt;before_request()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../api/index#flask.Flask.after_request&quot;&gt; &lt;code&gt;after_request()&lt;/code&gt; &lt;/a&gt;函数。但是，当测试请求上下文离开 &lt;code&gt;with&lt;/code&gt; 块时，确实会执行&lt;a href=&quot;../api/index#flask.Flask.teardown_request&quot;&gt; &lt;code&gt;teardown_request()&lt;/code&gt; &lt;/a&gt;函数。如果确实希望也&lt;a href=&quot;../api/index#flask.Flask.before_request&quot;&gt; &lt;code&gt;before_request()&lt;/code&gt; &lt;/a&gt;函数，则需要自己调用&lt;a href=&quot;../api/index#flask.Flask.preprocess_request&quot;&gt; &lt;code&gt;preprocess_request()&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="cf9a5887b6f23ec7b4cde7c7f1f9b5d3890bf88f" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#flask.Request.files&quot;&gt;&lt;code&gt;files&lt;/code&gt;&lt;/a&gt; will only contain data if the request method was POST, PUT or PATCH and the &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; that posted to the request had &lt;code&gt;enctype=&quot;multipart/form-data&quot;&lt;/code&gt;. It will be empty otherwise.</source>
          <target state="translated">请注意，仅当请求方法是POST，PUT或PATCH并且发布到请求的 &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; 具有 &lt;code&gt;enctype=&quot;multipart/form-data&quot;&lt;/code&gt; ，&lt;a href=&quot;#flask.Request.files&quot;&gt; &lt;code&gt;files&lt;/code&gt; &lt;/a&gt;才会包含数据。否则将为空。</target>
        </trans-unit>
        <trans-unit id="d83a45eb0378fcf48e190dcb50f0b835f46247ff" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;../api/index#flask.Config.from_object&quot;&gt;&lt;code&gt;from_object()&lt;/code&gt;&lt;/a&gt; does not instantiate the class object. If you need to instantiate the class, such as to access a property, then you must do so before calling &lt;a href=&quot;../api/index#flask.Config.from_object&quot;&gt;&lt;code&gt;from_object()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">注意&lt;a href=&quot;../api/index#flask.Config.from_object&quot;&gt; &lt;code&gt;from_object()&lt;/code&gt; &lt;/a&gt;不会实例化类对象。如果您需要实例化类（例如访问属性），则必须在调用&lt;a href=&quot;../api/index#flask.Config.from_object&quot;&gt; &lt;code&gt;from_object()&lt;/code&gt; &lt;/a&gt;之前进行实例化：</target>
        </trans-unit>
        <trans-unit id="e82e3f6f8864514339f260fa67ffdce51fe96cfc" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/serving/#werkzeug.serving.run_simple&quot;&gt;&lt;code&gt;run_simple&lt;/code&gt;&lt;/a&gt; is not intended for use in production. Use a &lt;a href=&quot;../../deploying/index#deployment&quot;&gt;full-blown WSGI server&lt;/a&gt;.</source>
          <target state="translated">请注意，&lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/serving/#werkzeug.serving.run_simple&quot;&gt; &lt;code&gt;run_simple&lt;/code&gt; &lt;/a&gt;不适用于生产。使用功能完善的&lt;a href=&quot;../../deploying/index#deployment&quot;&gt;WSGI服务器&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="20c4d46c1b0b814b92a8b03f8333ae3e49351446" translate="yes" xml:space="preserve">
          <source>Note that cookies are set on response objects. Since you normally just return strings from the view functions Flask will convert them into response objects for you. If you explicitly want to do that you can use the &lt;a href=&quot;../api/index#flask.make_response&quot;&gt;&lt;code&gt;make_response()&lt;/code&gt;&lt;/a&gt; function and then modify it.</source>
          <target state="translated">请注意，cookie是在响应对象上设置的。由于通常只从视图函数返回字符串，因此Flask会为您将它们转换为响应对象。如果您明确想要这样做，则可以使用&lt;a href=&quot;../api/index#flask.make_response&quot;&gt; &lt;code&gt;make_response()&lt;/code&gt; &lt;/a&gt;函数，然后对其进行修改。</target>
        </trans-unit>
        <trans-unit id="fa0c39cc4f72e142ab4db635d855de230d0405b2" translate="yes" xml:space="preserve">
          <source>Note that if the form data was already parsed this method will not return anything as form data parsing does not cache the data like this method does. To implicitly invoke form data parsing function set &lt;code&gt;parse_form_data&lt;/code&gt; to &lt;code&gt;True&lt;/code&gt;. When this is done the return value of this method will be an empty string if the form parser handles the data. This generally is not necessary as if the whole data is cached (which is the default) the form parser will used the cached data to parse the form data. Please be generally aware of checking the content length first in any case before calling this method to avoid exhausting server memory.</source>
          <target state="translated">请注意，如果已经解析了表单数据，则此方法将不返回任何内容，因为表单数据解析不会像该方法那样缓存数据。要隐式调用表单数据解析函数，请将 &lt;code&gt;parse_form_data&lt;/code&gt; 设置为 &lt;code&gt;True&lt;/code&gt; 。完成此操作后，如果表单解析器处理数据，则此方法的返回值将为空字符串。通常不需要这样做，因为好像整个数据都被缓存了（这是默认设置）一样，表单解析器将使用缓存的数据来解析表单数据。通常，在任何情况下，请务必先检查内容长度，然后再调用此方法，以免耗尽服务器内存。</target>
        </trans-unit>
        <trans-unit id="65241cd74822585bd52a418e60b7a2989ad717e0" translate="yes" xml:space="preserve">
          <source>Note that if you are testing for assertions or exceptions in your application code, you must set &lt;code&gt;app.testing = True&lt;/code&gt; in order for the exceptions to propagate to the test client. Otherwise, the exception will be handled by the application (not visible to the test client) and the only indication of an AssertionError or other exception will be a 500 status code response to the test client. See the &lt;a href=&quot;#flask.Flask.testing&quot;&gt;&lt;code&gt;testing&lt;/code&gt;&lt;/a&gt; attribute. For example:</source>
          <target state="translated">请注意，如果要在应用程序代码中测试断言或异常，则必须将 &lt;code&gt;app.testing = True&lt;/code&gt; 设置为使异常传播到测试客户端。否则，异常将由应用程序处理（测试客户端不可见），并且AssertionError或其他异常的唯一指示将是对测试客户端的500状态代码响应。请参阅&lt;a href=&quot;#flask.Flask.testing&quot;&gt; &lt;code&gt;testing&lt;/code&gt; &lt;/a&gt;属性。例如：</target>
        </trans-unit>
        <trans-unit id="624c597d49766445ff09254c50f079d8d708e00d" translate="yes" xml:space="preserve">
          <source>Note that in this case you have to use the &lt;code&gt;sess&lt;/code&gt; object instead of the &lt;a href=&quot;../api/index#flask.session&quot;&gt;&lt;code&gt;flask.session&lt;/code&gt;&lt;/a&gt; proxy. The object however itself will provide the same interface.</source>
          <target state="translated">请注意，在这种情况下，您必须使用 &lt;code&gt;sess&lt;/code&gt; 对象而不是&lt;a href=&quot;../api/index#flask.session&quot;&gt; &lt;code&gt;flask.session&lt;/code&gt; &lt;/a&gt;代理。但是对象本身将提供相同的接口。</target>
        </trans-unit>
        <trans-unit id="2f9ec59b5e462aa61b36c5a8d48671890ef99463" translate="yes" xml:space="preserve">
          <source>Note that in versions of Flask prior to 0.10, if using the output of &lt;code&gt;|tojson&lt;/code&gt; inside &lt;code&gt;script&lt;/code&gt;, make sure to disable escaping with &lt;code&gt;|safe&lt;/code&gt;. In Flask 0.10 and above, this happens automatically.</source>
          <target state="translated">注意，在0.10之前的Flask版本中，如果在 &lt;code&gt;script&lt;/code&gt; 使用 &lt;code&gt;|tojson&lt;/code&gt; 的输出，请确保使用 &lt;code&gt;|safe&lt;/code&gt; 禁用转义。在Flask 0.10及更高版本中，这会自动发生。</target>
        </trans-unit>
        <trans-unit id="b4b5f335bd3158e1c203afdf0d58816209d97e20" translate="yes" xml:space="preserve">
          <source>Note that we are using the &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.MultiDict.get&quot;&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt; method here which will never fail. If the key is missing a default value (here &lt;code&gt;0&lt;/code&gt;) is returned. Furthermore it can convert values to a specific type (like in our case &lt;code&gt;int&lt;/code&gt;). This is especially handy for code that is triggered by a script (APIs, JavaScript etc.) because you don&amp;rsquo;t need special error reporting in that case.</source>
          <target state="translated">注意，我们在这里使用的是&lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.MultiDict.get&quot;&gt; &lt;code&gt;get()&lt;/code&gt; &lt;/a&gt;方法，它永远不会失败。如果缺少键，则返回默认值（此处为 &lt;code&gt;0&lt;/code&gt; ）。此外，它可以将值转换为特定类型（例如我们的 &lt;code&gt;int&lt;/code&gt; ）。这对于由脚本（API，JavaScript等）触发的代码特别方便，因为在这种情况下，您不需要特殊的错误报告。</target>
        </trans-unit>
        <trans-unit id="da0cee05b6f70a477e99161bb9e4661b7577cb41" translate="yes" xml:space="preserve">
          <source>Note that when you stream data, the request context is already gone the moment the function executes. Flask 0.9 provides you with a helper that can keep the request context around during the execution of the generator:</source>
          <target state="translated">请注意,当你流式传输数据时,请求上下文在函数执行的那一刻已经消失了。Flask 0.9为您提供了一个助手,它可以在生成器的执行过程中保持请求上下文。</target>
        </trans-unit>
        <trans-unit id="4e70995c7780e0603dde04e2a5c06118192893f5" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;404&lt;/code&gt; after the &lt;a href=&quot;../api/index#flask.render_template&quot;&gt;&lt;code&gt;render_template()&lt;/code&gt;&lt;/a&gt; call. This tells Flask that the status code of that page should be 404 which means not found. By default 200 is assumed which translates to: all went well.</source>
          <target state="translated">请注意&lt;a href=&quot;../api/index#flask.render_template&quot;&gt; &lt;code&gt;render_template()&lt;/code&gt; &lt;/a&gt;调用之后的 &lt;code&gt;404&lt;/code&gt; 。这告诉Flask该页面的状态码应为404，表示找不到。默认情况下，假设200表示：一切顺利。</target>
        </trans-unit>
        <trans-unit id="9922d0aa9ac9e3a62ef6827aba0e5a5c1795580c" translate="yes" xml:space="preserve">
          <source>Note: There have been some changes in access control configuration for &lt;a href=&quot;https://httpd.apache.org/docs/trunk/upgrading.html&quot;&gt;Apache 2.4&lt;/a&gt;.</source>
          <target state="translated">注意：&lt;a href=&quot;https://httpd.apache.org/docs/trunk/upgrading.html&quot;&gt;Apache 2.4的&lt;/a&gt;访问控制配置已进行了一些更改。</target>
        </trans-unit>
        <trans-unit id="df34bacb83f56c87d92dea7f13e223503f4ddd7a" translate="yes" xml:space="preserve">
          <source>Note: WSGIDaemonProcess isn&amp;rsquo;t implemented in Windows and Apache will refuse to run with the above configuration. On a Windows system, eliminate those lines:</source>
          <target state="translated">注意：Windows中未实现WSGIDaemonProcess，Apache将拒绝使用上述配置运行。在Windows系统上，消除这些行：</target>
        </trans-unit>
        <trans-unit id="ec6a2aec162b448d027604180fb477a5cdd36de6" translate="yes" xml:space="preserve">
          <source>Note: if you use Flask 0.9 or older you need to use &lt;code&gt;flask._app_ctx_stack.top&lt;/code&gt; instead of &lt;code&gt;g&lt;/code&gt; as the &lt;a href=&quot;../../api/index#flask.g&quot;&gt;&lt;code&gt;flask.g&lt;/code&gt;&lt;/a&gt; object was bound to the request and not application context.</source>
          <target state="translated">注意：如果使用Flask 0.9或更早版本，则需要使用 &lt;code&gt;flask._app_ctx_stack.top&lt;/code&gt; 而不是 &lt;code&gt;g&lt;/code&gt; ,因为&lt;a href=&quot;../../api/index#flask.g&quot;&gt; &lt;code&gt;flask.g&lt;/code&gt; &lt;/a&gt;对象绑定到请求而非应用程序上下文。</target>
        </trans-unit>
        <trans-unit id="9e3878f78d0551869681b3587b7958ab94057466" translate="yes" xml:space="preserve">
          <source>Notepad++:</source>
          <target state="translated">Notepad++:</target>
        </trans-unit>
        <trans-unit id="96cac5eec82b15742f19cf270419524da6925265" translate="yes" xml:space="preserve">
          <source>Notes On Proxies</source>
          <target state="translated">代理人须知</target>
        </trans-unit>
        <trans-unit id="26bc263dab2fcc90f0703da86db8fbe672904b98" translate="yes" xml:space="preserve">
          <source>Nothing is done to the object before loading. If the object is a class and has &lt;code&gt;@property&lt;/code&gt; attributes, it needs to be instantiated before being passed to this method.</source>
          <target state="translated">加载之前对对象不做任何事情。如果该对象是一个类并具有 &lt;code&gt;@property&lt;/code&gt; 属性，则需要先实例化该对象，然后再将其传递给此方法。</target>
        </trans-unit>
        <trans-unit id="5256fffffb868a37e07fc3a3a770a754b7273025" translate="yes" xml:space="preserve">
          <source>Notice</source>
          <target state="translated">Notice</target>
        </trans-unit>
        <trans-unit id="202bbd5b41c7838e46229412a4c4de1c75963b08" translate="yes" xml:space="preserve">
          <source>Notice that any value besides an empty string will be interpreted as a boolean &lt;code&gt;True&lt;/code&gt; value in Python, which requires care if an environment explicitly sets values intended to be &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">请注意，在Python中，除空字符串外的任何值都将解释为布尔 &lt;code&gt;True&lt;/code&gt; 值，如果环境明确将旨在设置为 &lt;code&gt;False&lt;/code&gt; 的值，则需要特别注意。</target>
        </trans-unit>
        <trans-unit id="f6a288f93f6208acba5695b202a0daa351109727" translate="yes" xml:space="preserve">
          <source>Notice that disabling key sorting can cause issues when using content based HTTP caches and Python&amp;rsquo;s hash randomization feature.</source>
          <target state="translated">请注意，在使用基于内容的HTTP缓存和Python的哈希随机化功能时，禁用键排序会导致问题。</target>
        </trans-unit>
        <trans-unit id="9bbc60e138434fec8e34ec769e88c261098fb0c2" translate="yes" xml:space="preserve">
          <source>Notice that our test functions begin with the word &lt;code&gt;test&lt;/code&gt;; this allows &lt;a href=&quot;https://docs.pytest.org/&quot;&gt;pytest&lt;/a&gt; to automatically identify the function as a test to run.</source>
          <target state="translated">请注意，我们的测试功能以单词 &lt;code&gt;test&lt;/code&gt; 开头；这使&lt;a href=&quot;https://docs.pytest.org/&quot;&gt;pytest&lt;/a&gt;可以自动将功能识别为要运行的测试。</target>
        </trans-unit>
        <trans-unit id="9afd290d370b6c2aaf445c303c3a05109b2148f4" translate="yes" xml:space="preserve">
          <source>Notice that this assumes an instantiated &lt;code&gt;cache&lt;/code&gt; object is available, see &lt;a href=&quot;../caching/index#caching-pattern&quot;&gt;Caching&lt;/a&gt; for more information.</source>
          <target state="translated">请注意，这假设已实例化的 &lt;code&gt;cache&lt;/code&gt; 对象可用，有关更多信息，请参见&lt;a href=&quot;../caching/index#caching-pattern&quot;&gt;缓存&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="848811439189edb2a2e8fa00e81dc0be00239ae4" translate="yes" xml:space="preserve">
          <source>Notice we&amp;rsquo;re implying that the view is using SQLAlchemy here (&lt;a href=&quot;../sqlalchemy/index#sqlalchemy-pattern&quot;&gt;SQLAlchemy in Flask&lt;/a&gt;), but that&amp;rsquo;s not a requirement, of course. Adapt the code as necessary.</source>
          <target state="translated">注意，我们在这里暗示该视图正在使用SQLAlchemy（&lt;a href=&quot;../sqlalchemy/index#sqlalchemy-pattern&quot;&gt;Flask中的SQLAlchemy&lt;/a&gt;），但这当然不是必需的。根据需要修改代码。</target>
        </trans-unit>
        <trans-unit id="a4b779bfa5e41ca75c0ce93487a8a63554fce016" translate="yes" xml:space="preserve">
          <source>Now as mentioned above, the application will find the correct configuration file by looking up the &lt;code&gt;YOURAPPLICATION_CONFIG&lt;/code&gt; environment variable. So we have to put the configuration in a place where the application will able to find it. Configuration files have the unfriendly quality of being different on all computers, so you do not version them usually.</source>
          <target state="translated">现在，如上所述，应用程序将通过查找 &lt;code&gt;YOURAPPLICATION_CONFIG&lt;/code&gt; 环境变量来找到正确的配置文件。因此，我们必须将配置放在应用程序可以找到它的地方。配置文件具有在所有计算机上都不同的不友好特性，因此通常不对它们进行版本控制。</target>
        </trans-unit>
        <trans-unit id="847dec1fdc65f1bc9b48bf67d38aa2e210557c76" translate="yes" xml:space="preserve">
          <source>Now head over to &lt;a href=&quot;http://127.0.0.1:5000/&quot;&gt;http://127.0.0.1:5000/&lt;/a&gt;, and you should see your hello world greeting.</source>
          <target state="translated">现在转到&lt;a href=&quot;http://127.0.0.1:5000/&quot;&gt;http://127.0.0.1:5000/&lt;/a&gt;，您应该看到问候世界的问候。</target>
        </trans-unit>
        <trans-unit id="05d35aca474d83d1f874b9f7cd83a25f63adedaa" translate="yes" xml:space="preserve">
          <source>Now how do you execute that fabfile? You use the &lt;code&gt;fab&lt;/code&gt; command. To deploy the current version of the code on the remote server you would use this command:</source>
          <target state="translated">现在如何执行该fabfile？您使用 &lt;code&gt;fab&lt;/code&gt; 命令。要在远程服务器上部署代码的当前版本，请使用以下命令：</target>
        </trans-unit>
        <trans-unit id="d8d707b7f0b551b0b2a124bf2bca93ab9ac578a9" translate="yes" xml:space="preserve">
          <source>Now in each request handling function you can access &lt;code&gt;get_db()&lt;/code&gt; to get the current open database connection. To simplify working with SQLite, a row factory function is useful. It is executed for every result returned from the database to convert the result. For instance, in order to get dictionaries instead of tuples, this could be inserted into the &lt;code&gt;get_db&lt;/code&gt; function we created above:</source>
          <target state="translated">现在，在每个请求处理函数中，您都可以访问 &lt;code&gt;get_db()&lt;/code&gt; 以获取当前打开的数据库连接。为了简化使用SQLite的工作，行工厂功能很有用。对数据库返回的每个结果执行该命令以转换结果。例如，为了获取字典而不是元组，可以将其插入我们上面创建的 &lt;code&gt;get_db&lt;/code&gt; 函数中：</target>
        </trans-unit>
        <trans-unit id="17359332b1d64a4d3da323565f7adf13a66c87dc" translate="yes" xml:space="preserve">
          <source>Now it&amp;rsquo;s time to start testing the functionality of the application. Let&amp;rsquo;s check that the application shows &amp;ldquo;No entries here so far&amp;rdquo; if we access the root of the application (&lt;code&gt;/&lt;/code&gt;). To do this, we add a new test function to &lt;code&gt;test_flaskr.py&lt;/code&gt;, like this:</source>
          <target state="translated">现在是时候开始测试应用程序的功能了。如果我们访问应用程序的根目录（ &lt;code&gt;/&lt;/code&gt; ），请检查该应用程序是否显示&amp;ldquo;到目前为止没有条目&amp;rdquo; 。为此，我们向 &lt;code&gt;test_flaskr.py&lt;/code&gt; 添加一个新的测试函数，如下所示：</target>
        </trans-unit>
        <trans-unit id="4c669e2dd35c418ceda009dd53d7f1f9ce37c911" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s create a server side function that accepts two URL arguments of numbers which should be added together and then sent back to the application in a JSON object. This is a really ridiculous example and is something you usually would do on the client side alone, but a simple example that shows how you would use jQuery and Flask nonetheless:</source>
          <target state="translated">现在，让我们创建一个服务器端函数，该函数接受两个数字的URL参数，这些参数应加在一起，然后以JSON对象的形式发送回应用程序。这是一个非常荒谬的示例，通常只在客户端上执行，但是一个简单的示例显示了如何使用jQuery和Flask：</target>
        </trans-unit>
        <trans-unit id="c3a8702810479eb8cdaafa30bdba2105b907d0e9" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s look how that function works:</source>
          <target state="translated">现在让我们看一下该函数的工作原理：</target>
        </trans-unit>
        <trans-unit id="7b6b29bac668e8ba3feb3824fdfba3b630dd7191" translate="yes" xml:space="preserve">
          <source>Now one last thing is missing: the serving of the uploaded files. In the &lt;code&gt;upload_file()&lt;/code&gt; we redirect the user to &lt;code&gt;url_for('uploaded_file', filename=filename)&lt;/code&gt;, that is, &lt;code&gt;/uploads/filename&lt;/code&gt;. So we write the &lt;code&gt;uploaded_file()&lt;/code&gt; function to return the file of that name. As of Flask 0.5 we can use a function that does that for us:</source>
          <target state="translated">现在缺少最后一件事：提供上载的文件。在 &lt;code&gt;upload_file()&lt;/code&gt; 中,我们将用户重定向到 &lt;code&gt;url_for('uploaded_file', filename=filename)&lt;/code&gt; ，即 &lt;code&gt;/uploads/filename&lt;/code&gt; 。因此，我们编写了 &lt;code&gt;uploaded_file()&lt;/code&gt; 函数以返回该名称的文件。从Flask 0.5开始，我们可以使用一个为我们做到这一点的函数：</target>
        </trans-unit>
        <trans-unit id="bb6b3351ce791020330d5da9f7e85891f854b03d" translate="yes" xml:space="preserve">
          <source>Now that the worker is running, &lt;code&gt;wait&lt;/code&gt; will return the result once the task is finished.</source>
          <target state="translated">现在工作程序正在运行，一旦任务完成， &lt;code&gt;wait&lt;/code&gt; 将返回结果。</target>
        </trans-unit>
        <trans-unit id="e99f767c6e0db6b4af9ce45e80178831381852a5" translate="yes" xml:space="preserve">
          <source>Now that we have a configuration which runs &lt;code&gt;flask run&lt;/code&gt; from within PyCharm, we can copy that configuration and alter the &lt;em&gt;Script&lt;/em&gt; argument to run a different CLI command, e.g. &lt;code&gt;flask shell&lt;/code&gt;.</source>
          <target state="translated">现在我们有了一个可以在PyCharm内部运行 &lt;code&gt;flask run&lt;/code&gt; 的配置，我们可以复制该配置并更改&lt;em&gt;Script&lt;/em&gt;参数以运行另一个CLI命令，例如 &lt;code&gt;flask shell&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f1579c042f2830ae10f96a80dbb9f261f2fed388" translate="yes" xml:space="preserve">
          <source>Now there are better solutions that work faster and are more reliable. There are JavaScript libraries like &lt;a href=&quot;https://jquery.com/&quot;&gt;jQuery&lt;/a&gt; that have form plugins to ease the construction of progress bar.</source>
          <target state="translated">现在，有更好的解决方案可以更快，更可靠地工作。有像&lt;a href=&quot;https://jquery.com/&quot;&gt;jQuery&lt;/a&gt;这样的JavaScript库，它们具有表单插件以简化进度栏的构造。</target>
        </trans-unit>
        <trans-unit id="d8e8eb2c44f7d8eb3e00acda21f5364a30ab98ca" translate="yes" xml:space="preserve">
          <source>Now to the template side. When you pass the form to the templates, you can easily render them there. Look at the following example template to see how easy this is. WTForms does half the form generation for us already. To make it even nicer, we can write a macro that renders a field with label and a list of errors if there are any.</source>
          <target state="translated">现在到了模板方面。当你把表单传递给模板时,你可以很容易地在那里渲染它们。看看下面的模板示例就知道这有多简单了。WTForms已经为我们完成了一半的表单生成工作。为了让它更完美,我们可以写一个宏,在字段中显示标签和错误列表。</target>
        </trans-unit>
        <trans-unit id="02005fb3e893847f43c52a7fdba14cdd668c95c0" translate="yes" xml:space="preserve">
          <source>Now we can do our first deployment. We have set up the servers so that they have their virtual environments and activated apache configs. Now we can pack up the application and deploy it:</source>
          <target state="translated">现在我们可以进行第一次部署了。我们已经设置好了服务器,使它们有自己的虚拟环境,并激活了apache配置。现在我们可以打包并部署应用程序了。</target>
        </trans-unit>
        <trans-unit id="9839d02b04cbb447f351b42455826c9cd60f8275" translate="yes" xml:space="preserve">
          <source>Now we can easily test that logging in and out works and that it fails with invalid credentials. Add this new test function:</source>
          <target state="translated">现在,我们可以很容易地测试登录和退出是否有效,以及无效凭证是否失败。添加这个新的测试函数。</target>
        </trans-unit>
        <trans-unit id="827d0571b13b3f5724fd3a2529fc4f903a1ec1ef" translate="yes" xml:space="preserve">
          <source>Now you can create new signals like this:</source>
          <target state="translated">现在你可以创建这样的新信号。</target>
        </trans-unit>
        <trans-unit id="32f173126548d66c02035c6f36e3509f10ce07bd" translate="yes" xml:space="preserve">
          <source>Now you can return above and &lt;a href=&quot;#install-create-env&quot;&gt;Create an environment&lt;/a&gt;.</source>
          <target state="translated">现在，您可以返回上方并&lt;a href=&quot;#install-create-env&quot;&gt;创建环境&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c2b1343dec780f3fdbdb976f307a1543d7fbefe0" translate="yes" xml:space="preserve">
          <source>Now, to get browsers to find your icon, the correct way is to add a link tag in your HTML. So, for example:</source>
          <target state="translated">现在,要让浏览器找到你的图标,正确的方法是在你的HTML中添加一个链接标签。所以,举个例子</target>
        </trans-unit>
        <trans-unit id="552f3caf547b79565f439cc1900051f88342fee0" translate="yes" xml:space="preserve">
          <source>Now, to use the database, the application must either have an active application context (which is always true if there is a request in flight) or create an application context itself. At that point the &lt;code&gt;get_db&lt;/code&gt; function can be used to get the current database connection. Whenever the context is destroyed the database connection will be terminated.</source>
          <target state="translated">现在，要使用数据库，应用程序必须具有活动的应用程序上下文（如果正在处理请求，则始终为true）或自己创建应用程序上下文。那时，可以使用 &lt;code&gt;get_db&lt;/code&gt; 函数获取当前的数据库连接。每当上下文被破坏时，数据库连接都会终止。</target>
        </trans-unit>
        <trans-unit id="342ab4e80946aa45770ffc1278b62f2f84f20693" translate="yes" xml:space="preserve">
          <source>Objects are usually either modules or classes. &lt;a href=&quot;#flask.Config.from_object&quot;&gt;&lt;code&gt;from_object()&lt;/code&gt;&lt;/a&gt; loads only the uppercase attributes of the module/class. A &lt;code&gt;dict&lt;/code&gt; object will not work with &lt;a href=&quot;#flask.Config.from_object&quot;&gt;&lt;code&gt;from_object()&lt;/code&gt;&lt;/a&gt; because the keys of a &lt;code&gt;dict&lt;/code&gt; are not attributes of the &lt;code&gt;dict&lt;/code&gt; class.</source>
          <target state="translated">对象通常是模块或类。&lt;a href=&quot;#flask.Config.from_object&quot;&gt; &lt;code&gt;from_object()&lt;/code&gt; &lt;/a&gt;仅加载模块/类的大写属性。一个 &lt;code&gt;dict&lt;/code&gt; 对象不会一起工作&lt;a href=&quot;#flask.Config.from_object&quot;&gt; &lt;code&gt;from_object()&lt;/code&gt; &lt;/a&gt;，因为一个的按键 &lt;code&gt;dict&lt;/code&gt; 不是属性 &lt;code&gt;dict&lt;/code&gt; 类。</target>
        </trans-unit>
        <trans-unit id="46ede8fe33aea49aa50c1a6f0c0250c02b4327e0" translate="yes" xml:space="preserve">
          <source>Old Version of Flask</source>
          <target state="translated">旧版的Flask</target>
        </trans-unit>
        <trans-unit id="4837353972f268f9ba4abfc902240e5f4ac85f34" translate="yes" xml:space="preserve">
          <source>On FreeBSD install &lt;code&gt;mod_wsgi&lt;/code&gt; by compiling the &lt;code&gt;www/mod_wsgi&lt;/code&gt; port or by using pkg_add:</source>
          <target state="translated">在FreeBSD上，通过编译 &lt;code&gt;www/mod_wsgi&lt;/code&gt; 端口或使用pkg_add安装 &lt;code&gt;mod_wsgi&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="bfa5971ae042ceae06c62ade85603875b16d6e90" translate="yes" xml:space="preserve">
          <source>On Linux, virtualenv is provided by your package manager:</source>
          <target state="translated">在Linux上,virtualenv由你的软件包管理器提供。</target>
        </trans-unit>
        <trans-unit id="220f16d5aff1c7977766a19a6dbf68a8d90b86c0" translate="yes" xml:space="preserve">
          <source>On Windows systems use the &lt;code&gt;set&lt;/code&gt; builtin instead:</source>
          <target state="translated">在Windows系统上，请使用内置的 &lt;code&gt;set&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="f4c7dbe2053d75aa8f86ca6e7ee0378cb6995ed7" translate="yes" xml:space="preserve">
          <source>On Windows, as an administrator:</source>
          <target state="translated">在Windows上,以管理员身份。</target>
        </trans-unit>
        <trans-unit id="55b56364276b5f7e47e7f031287b139fc5b947d5" translate="yes" xml:space="preserve">
          <source>On Windows:</source>
          <target state="translated">在Windows上。</target>
        </trans-unit>
        <trans-unit id="069256f018cd0a75400c52076d277549a7f35470" translate="yes" xml:space="preserve">
          <source>On shared webhosting, though, you might not have access to your Apache config. In this case, a file called &lt;code&gt;.htaccess&lt;/code&gt;, sitting in the public directory you want your app to be available, works too but the &lt;code&gt;ScriptAlias&lt;/code&gt; directive won&amp;rsquo;t work in that case:</source>
          <target state="translated">但是，在共享虚拟主机上，您可能无权访问Apache配置。在这种情况下，位于您希望您的应用程序可用的公共目录中的名为 &lt;code&gt;.htaccess&lt;/code&gt; 的文件也可以工作，但是 &lt;code&gt;ScriptAlias&lt;/code&gt; 指令在这种情况下不起作用：</target>
        </trans-unit>
        <trans-unit id="48af95fcc69faabf05adcce2f876db9a92dc6bc4" translate="yes" xml:space="preserve">
          <source>On top of that you can register blueprints multiple times though not every blueprint might respond properly to that. In fact it depends on how the blueprint is implemented if it can be mounted more than once.</source>
          <target state="translated">除此之外,你可以多次注册蓝图,尽管不是每个蓝图都能正确响应。事实上,这取决于蓝图的实现方式,如果它可以被挂载一次以上。</target>
        </trans-unit>
        <trans-unit id="4658d0e7140ee7be4ef893587c864affbffbbc54" translate="yes" xml:space="preserve">
          <source>On windows use &lt;code&gt;set&lt;/code&gt; instead.</source>
          <target state="translated">在Windows上使用 &lt;code&gt;set&lt;/code&gt; 代替。</target>
        </trans-unit>
        <trans-unit id="39fae18b63d9f377989fa63b01ddd49dd7b3da7b" translate="yes" xml:space="preserve">
          <source>Once detected (or if not set at all), &lt;code&gt;SESSION_COOKIE_DOMAIN&lt;/code&gt; is updated to avoid re-running the logic.</source>
          <target state="translated">一旦检测到（或根本没有设置），将更新 &lt;code&gt;SESSION_COOKIE_DOMAIN&lt;/code&gt; ，以避免重新运行逻辑。</target>
        </trans-unit>
        <trans-unit id="f9adb645b2f37575463585929e4d6e08b1898771" translate="yes" xml:space="preserve">
          <source>Once that package is installed in the same virtualenv as your Flask project, you can run &lt;code&gt;flask my-command&lt;/code&gt; to invoke the command.</source>
          <target state="translated">一旦将该软件包安装在与Flask项目相同的virtualenv中，就可以运行 &lt;code&gt;flask my-command&lt;/code&gt; 来调用该命令。</target>
        </trans-unit>
        <trans-unit id="4e95a0603fc77714b496e775926bc1bb83f9aedd" translate="yes" xml:space="preserve">
          <source>Once you have Flask up and running, you&amp;rsquo;ll find a variety of extensions available in the community to integrate your project for production. The Flask core team reviews extensions and ensures approved extensions do not break with future releases.</source>
          <target state="translated">一旦Flask启动并运行，您将在社区中找到各种扩展来集成您的项目以进行生产。Flask核心团队会审核扩展，并确保批准的扩展不会与将来的发行版保持一致。</target>
        </trans-unit>
        <trans-unit id="5df130bcfc8580368686e71d1f167270ac75d98c" translate="yes" xml:space="preserve">
          <source>One Template Engine</source>
          <target state="translated">一个模板引擎</target>
        </trans-unit>
        <trans-unit id="d41f07c06ebadb5e6560b0b4628ffabecbdf2111" translate="yes" xml:space="preserve">
          <source>One of the design decisions in Flask was that simple tasks should be simple; they should not take a lot of code and yet they should not limit you. Because of that, Flask has a few design choices that some people might find surprising or unorthodox. For example, Flask uses thread-local objects internally so that you don&amp;rsquo;t have to pass objects around from function to function within a request in order to stay threadsafe. This approach is convenient, but requires a valid request context for dependency injection or when attempting to reuse code which uses a value pegged to the request. The Flask project is honest about thread-locals, does not hide them, and calls out in the code and documentation where they are used.</source>
          <target state="translated">Flask的设计决策之一是，简单的任务应该很简单。他们不应使用大量代码，但也不应限制您。因此，Flask有一些设计选择，有些人可能会感到惊讶或不合常规。例如，Flask在内部使用线程局部对象，这样您就不必为了保持线程安全而在请求中的函数之间传递对象。这种方法很方便，但是需要一个有效的请求上下文来进行依赖项注入，或者在尝试重用使用与请求挂钩的值的代码时。 Flask项目对线程局部语言很诚实，不会隐藏它们，并在使用它们的代码和文档中进行了标注。</target>
        </trans-unit>
        <trans-unit id="698d9095618e9f064877d60a6a001ef1afb5c4a9" translate="yes" xml:space="preserve">
          <source>One of the design principles of Flask is that response objects are created and passed down a chain of potential callbacks that can modify them or replace them. When the request handling starts, there is no response object yet. It is created as necessary either by a view function or by some other component in the system.</source>
          <target state="translated">Flask的设计原则之一是,响应对象被创建,并向下传递一个潜在的回调链,这些回调可以修改它们或替换它们。当请求处理开始时,还没有响应对象。它是根据需要由视图函数或系统中的其他组件创建的。</target>
        </trans-unit>
        <trans-unit id="aeba341878b437d6eff95d185434a985ed8d9fdf" translate="yes" xml:space="preserve">
          <source>One of the most important causes of pain is XML&amp;rsquo;s draconian (strict and ruthless) error handling. When an XML parsing error is encountered, the browser is supposed to show the user an ugly error message, instead of attempting to recover from the error and display what it can. Most of the (X)HTML generation on the web is based on non-XML template engines (such as Jinja, the one used in Flask) which do not protect you from accidentally creating invalid XHTML. There are XML based template engines, such as Kid and the popular Genshi, but they often come with a larger runtime overhead and are not as straightforward to use because they have to obey XML rules.</source>
          <target state="translated">造成痛苦的最重要原因之一是XML的严厉（严格而无情的）错误处理。当遇到XML解析错误时，浏览器应该向用户显示一个丑陋的错误消息，而不是尝试从错误中恢复并显示其内容。 Web上的大多数（X）HTML生成都是基于非XML模板引擎（例如Jinja，在Flask中使用的一种），它们不能保护您避免意外创建无效的XHTML。有基于XML的模板引擎，例如Kid和流行的Genshi，但它们通常带有较大的运行时开销，并且由于必须遵守XML规则而使用起来不那么直接。</target>
        </trans-unit>
        <trans-unit id="93c0376fc36047de3b61e8b85878c46c971c0eb4" translate="yes" xml:space="preserve">
          <source>One of the reasons everybody loves Python is the interactive shell. It basically allows you to execute Python commands in real time and immediately get results back. Flask itself does not come with an interactive shell, because it does not require any specific setup upfront, just import your application and start playing around.</source>
          <target state="translated">大家喜欢Python的原因之一就是交互式shell。它基本上可以让你实时执行Python命令,并立即得到结果。Flask本身并没有自带交互式shell,因为它前期不需要任何特定的设置,只要导入你的应用程序就可以开始玩了。</target>
        </trans-unit>
        <trans-unit id="13cca6840aca9c9b66400b9cdf376b3ed1244d17" translate="yes" xml:space="preserve">
          <source>One thing to keep in mind is that before and after request handlers have to be in a file that is imported upfront to work properly on the first request. The same goes for any kind of remaining decorator.</source>
          <target state="translated">有一点需要注意的是,前后的请求处理程序必须在一个文件中,前期导入,才能在第一个请求中正常工作。其余任何一种装饰器也是如此。</target>
        </trans-unit>
        <trans-unit id="4dc3815bbb66b85815a3660296e321fdeec09308" translate="yes" xml:space="preserve">
          <source>One way is to avoid the situation. Very often that is possible. For instance you can try to move that logic into a &lt;a href=&quot;../../api/index#flask.Flask.after_request&quot;&gt;&lt;code&gt;after_request()&lt;/code&gt;&lt;/a&gt; callback instead. However, sometimes moving code there makes it more more complicated or awkward to reason about.</source>
          <target state="translated">一种方法是避免这种情况。很多时候这是可能的。例如，您可以尝试将逻辑移到&lt;a href=&quot;../../api/index#flask.Flask.after_request&quot;&gt; &lt;code&gt;after_request()&lt;/code&gt; &lt;/a&gt;回调中。但是，有时将代码移到那里会使推理变得更加复杂或尴尬。</target>
        </trans-unit>
        <trans-unit id="62f3deacdc5ae436da14b4705b4e04ca0e66be4f" translate="yes" xml:space="preserve">
          <source>Open a Shell</source>
          <target state="translated">打开一个外壳</target>
        </trans-unit>
        <trans-unit id="631bee767c0ba0ac012227bf1e9cb91206cfa890" translate="yes" xml:space="preserve">
          <source>Opens a resource from the application&amp;rsquo;s instance folder (&lt;a href=&quot;#flask.Flask.instance_path&quot;&gt;&lt;code&gt;instance_path&lt;/code&gt;&lt;/a&gt;). Otherwise works like &lt;a href=&quot;#flask.Flask.open_resource&quot;&gt;&lt;code&gt;open_resource()&lt;/code&gt;&lt;/a&gt;. Instance resources can also be opened for writing.</source>
          <target state="translated">从应用程序的实例文件夹（&lt;a href=&quot;#flask.Flask.instance_path&quot;&gt; &lt;code&gt;instance_path&lt;/code&gt; &lt;/a&gt;）中打开资源。否则像&lt;a href=&quot;#flask.Flask.open_resource&quot;&gt; &lt;code&gt;open_resource()&lt;/code&gt; 一样工作&lt;/a&gt;。实例资源也可以打开进行写入。</target>
        </trans-unit>
        <trans-unit id="ab7769c2cffb6e15875a3240bf00cea53a0f3b6e" translate="yes" xml:space="preserve">
          <source>Opens a resource from the application&amp;rsquo;s resource folder. To see how this works, consider the following folder structure:</source>
          <target state="translated">从应用程序的资源文件夹中打开资源。若要查看其工作原理，请考虑以下文件夹结构：</target>
        </trans-unit>
        <trans-unit id="7346e4d45825ec177eaaa77f3cf50927846f5271" translate="yes" xml:space="preserve">
          <source>Optional dependencies</source>
          <target state="translated">可选依赖性</target>
        </trans-unit>
        <trans-unit id="5490cb737bb4383a035b0b4ea965012e5fde15a8" translate="yes" xml:space="preserve">
          <source>Optionally a function that is passed the script info to create the instance of the application.</source>
          <target state="translated">可以选择一个函数,该函数通过脚本信息来创建应用程序的实例。</target>
        </trans-unit>
        <trans-unit id="c74e828a27da6474ef48aad4ee5c87e8f9617c27" translate="yes" xml:space="preserve">
          <source>Optionally the import path for the Flask application.</source>
          <target state="translated">可选择Flask应用程序的导入路径。</target>
        </trans-unit>
        <trans-unit id="7cffd5a60dd17e3142a93fe5d1bd60150b6ef656" translate="yes" xml:space="preserve">
          <source>Optionally you can pass a list of categories which filters the results of &lt;a href=&quot;../../api/index#flask.get_flashed_messages&quot;&gt;&lt;code&gt;get_flashed_messages()&lt;/code&gt;&lt;/a&gt;. This is useful if you wish to render each category in a separate block.</source>
          <target state="translated">（可选）您可以传递类别列表，以过滤&lt;a href=&quot;../../api/index#flask.get_flashed_messages&quot;&gt; &lt;code&gt;get_flashed_messages()&lt;/code&gt; &lt;/a&gt;的结果。如果您希望在单独的块中呈现每个类别，这将很有用。</target>
        </trans-unit>
        <trans-unit id="da320320fff46e2e7fa1228b91dc9e9bbc4dec54" translate="yes" xml:space="preserve">
          <source>Options that are passed to the Jinja environment in &lt;a href=&quot;#flask.Flask.create_jinja_environment&quot;&gt;&lt;code&gt;create_jinja_environment()&lt;/code&gt;&lt;/a&gt;. Changing these options after the environment is created (accessing &lt;a href=&quot;#flask.Flask.jinja_env&quot;&gt;&lt;code&gt;jinja_env&lt;/code&gt;&lt;/a&gt;) will have no effect.</source>
          <target state="translated">在&lt;a href=&quot;#flask.Flask.create_jinja_environment&quot;&gt; &lt;code&gt;create_jinja_environment()&lt;/code&gt; &lt;/a&gt;中传递给Jinja环境的选项。创建环境后更改这些选项（访问&lt;a href=&quot;#flask.Flask.jinja_env&quot;&gt; &lt;code&gt;jinja_env&lt;/code&gt; &lt;/a&gt;）将无效。</target>
        </trans-unit>
        <trans-unit id="d6f546bca8f33a2c1db53c498a3ffbfbeccdef32" translate="yes" xml:space="preserve">
          <source>Or alternatively you can define the configuration options in the module that calls &lt;a href=&quot;#flask.Config.from_object&quot;&gt;&lt;code&gt;from_object()&lt;/code&gt;&lt;/a&gt; or provide an import path to a module that should be loaded. It is also possible to tell it to use the same module and with that provide the configuration values just before the call:</source>
          <target state="translated">或者，您也可以在调用&lt;a href=&quot;#flask.Config.from_object&quot;&gt; &lt;code&gt;from_object()&lt;/code&gt; &lt;/a&gt;的模块中定义配置选项，或提供指向应加载模块的导入路径。也可以告诉它使用相同的模块，并在调用之前使用该模块提供配置值：</target>
        </trans-unit>
        <trans-unit id="7a2e2f81709aebada246fc946973660931123e6e" translate="yes" xml:space="preserve">
          <source>Or if you just want a single result:</source>
          <target state="translated">或者如果你只是想要一个单一的结果。</target>
        </trans-unit>
        <trans-unit id="7ae0339c52cbaa78c22f6e61ad040364b33f131f" translate="yes" xml:space="preserve">
          <source>Other Libraries</source>
          <target state="translated">其他图书馆</target>
        </trans-unit>
        <trans-unit id="e2ca4b6ed5420ff6fc34dff0c645e96111cf52b7" translate="yes" xml:space="preserve">
          <source>Other Testing Tricks</source>
          <target state="translated">其他测试技巧</target>
        </trans-unit>
        <trans-unit id="8b90cd4f38bdb971ae3103ce09245a68c5a3f37e" translate="yes" xml:space="preserve">
          <source>Other libraries may use logging extensively, and you want to see relevant messages from those logs too. The simplest way to do this is to add handlers to the root logger instead of only the app logger.</source>
          <target state="translated">其他库可能会广泛使用日志记录,而你也希望从这些日志中看到相关的消息。最简单的方法是将处理程序添加到根日志记录器中,而不是只添加到应用程序日志记录器中。</target>
        </trans-unit>
        <trans-unit id="6b9f29efa349812cb8dda3637226057cf6c3c617" translate="yes" xml:space="preserve">
          <source>Otherwise works as the &lt;a href=&quot;#flask.Flask.errorhandler&quot;&gt;&lt;code&gt;errorhandler()&lt;/code&gt;&lt;/a&gt; decorator of the &lt;a href=&quot;#flask.Flask&quot;&gt;&lt;code&gt;Flask&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">否则，将&lt;a href=&quot;#flask.Flask.errorhandler&quot;&gt; &lt;code&gt;errorhandler()&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#flask.Flask&quot;&gt; &lt;code&gt;Flask&lt;/code&gt; &lt;/a&gt;对象的errorhandler（）装饰器。</target>
        </trans-unit>
        <trans-unit id="0f332eeefd007bb0043ccb46738196508c6a602b" translate="yes" xml:space="preserve">
          <source>Param</source>
          <target state="translated">Param</target>
        </trans-unit>
        <trans-unit id="a975eea30db9fa05003e3b5097688bd49ec7e01b" translate="yes" xml:space="preserve">
          <source>Parameters</source>
          <target state="translated">Parameters</target>
        </trans-unit>
        <trans-unit id="8b10069eff4ea686afc6bd769af6b31c58d3ee5a" translate="yes" xml:space="preserve">
          <source>Parse &lt;a href=&quot;#flask.Request.data&quot;&gt;&lt;code&gt;data&lt;/code&gt;&lt;/a&gt; as JSON.</source>
          <target state="translated">将&lt;a href=&quot;#flask.Request.data&quot;&gt; &lt;code&gt;data&lt;/code&gt; &lt;/a&gt;解析为JSON。</target>
        </trans-unit>
        <trans-unit id="a0d0e0f54147d14542b339bc283a5839caf9d6d1" translate="yes" xml:space="preserve">
          <source>Parse &lt;a href=&quot;#flask.Response.data&quot;&gt;&lt;code&gt;data&lt;/code&gt;&lt;/a&gt; as JSON.</source>
          <target state="translated">将&lt;a href=&quot;#flask.Response.data&quot;&gt; &lt;code&gt;data&lt;/code&gt; &lt;/a&gt;解析为JSON。</target>
        </trans-unit>
        <trans-unit id="ac1fe8da0c049bec0ba903642b1ff705129c8774" translate="yes" xml:space="preserve">
          <source>Passing Proxies as Senders</source>
          <target state="translated">将代理传递给发送者</target>
        </trans-unit>
        <trans-unit id="4d3a9cfd1e01e3ec76f2e3ed8770f06615dd3534" translate="yes" xml:space="preserve">
          <source>Passing an object to the constructor converts it to text and wraps it to mark it safe without escaping. To escape the text, use the &lt;a href=&quot;#flask.escape&quot;&gt;&lt;code&gt;escape()&lt;/code&gt;&lt;/a&gt; class method instead.</source>
          <target state="translated">将对象传递给构造函数会将其转换为文本，并对其进行包装以将其标记为安全而不进行转义。要转义文本，请改用&lt;a href=&quot;#flask.escape&quot;&gt; &lt;code&gt;escape()&lt;/code&gt; &lt;/a&gt;类方法。</target>
        </trans-unit>
        <trans-unit id="b2661f2aebb11160230ca8902147ee8bf67e4e15" translate="yes" xml:space="preserve">
          <source>Passing the &lt;code&gt;json&lt;/code&gt; argument in the test client methods sets the request data to the JSON-serialized object and sets the content type to &lt;code&gt;application/json&lt;/code&gt;. You can get the JSON data from the request or response with &lt;code&gt;get_json&lt;/code&gt;.</source>
          <target state="translated">在测试客户端方法中传递 &lt;code&gt;json&lt;/code&gt; 参数会将请求数据设置为JSON序列化的对象，并将内容类型设置为 &lt;code&gt;application/json&lt;/code&gt; 。您可以使用 &lt;code&gt;get_json&lt;/code&gt; 从请求或响应中获取JSON数据。</target>
        </trans-unit>
        <trans-unit id="3fe7add935b2826bc56c36fa385bb91c7bea7e34" translate="yes" xml:space="preserve">
          <source>Patterns for Flask</source>
          <target state="translated">烧瓶的模式</target>
        </trans-unit>
        <trans-unit id="7193c9e10b34c029f2c9e283980a5900229c95f7" translate="yes" xml:space="preserve">
          <source>Please keep in mind that file uploads will not end up here, but instead in the &lt;a href=&quot;#flask.Request.files&quot;&gt;&lt;code&gt;files&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">请记住，文件上传不会在此处结束，而是在&lt;a href=&quot;#flask.Request.files&quot;&gt; &lt;code&gt;files&lt;/code&gt; &lt;/a&gt;属性中结束。</target>
        </trans-unit>
        <trans-unit id="f363a40d0e5a941961a5e0372032a7179f8cf6ff" translate="yes" xml:space="preserve">
          <source>Please keep in mind that it is a security issue to use such a middleware in a non-proxy setup because it will blindly trust the incoming headers which might be forged by malicious clients.</source>
          <target state="translated">请记住,在非代理设置中使用这样的中间件是一个安全问题,因为它将盲目地信任传入的头文件,而这些头文件可能是由恶意客户伪造的。</target>
        </trans-unit>
        <trans-unit id="f3725c7ab29c6205da0fa14507509f5c5809bfe4" translate="yes" xml:space="preserve">
          <source>Please keep in mind that the teardown request and appcontext functions are always executed, even if a before-request handler failed or was never executed. Because of this we have to make sure here that the database is there before we close it.</source>
          <target state="translated">请记住,即使之前的请求处理程序失败或从未执行过,拆机请求和appcontext函数也会一直执行。正因为如此,我们在关闭数据库之前,必须在这里确保数据库是存在的。</target>
        </trans-unit>
        <trans-unit id="bf3bb130d413d3cbd44f2c82da3807560f820cbc" translate="yes" xml:space="preserve">
          <source>Please keep in mind that this path &lt;em&gt;must&lt;/em&gt; be absolute when provided.</source>
          <target state="translated">请记住，提供时此路径&lt;em&gt;必须&lt;/em&gt;是绝对路径。</target>
        </trans-unit>
        <trans-unit id="6e30cd18d76f457a4ac5102e8080d32895ce87ee" translate="yes" xml:space="preserve">
          <source>Please keep in mind that you have to list subpackages explicitly. If you want setuptools to lookup the packages for you automatically, you can use the &lt;code&gt;find_packages&lt;/code&gt; function:</source>
          <target state="translated">请记住，您必须明确列出子软件包。如果希望setuptools自动为您查找软件包，则可以使用 &lt;code&gt;find_packages&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="62fee4a693a3208c0f31f7c63ba0de72840f000c" translate="yes" xml:space="preserve">
          <source>Please make sure in advance that any &lt;code&gt;app.run()&lt;/code&gt; calls you might have in your application file are inside an &lt;code&gt;if __name__ ==
'__main__':&lt;/code&gt; block or moved to a separate file. Just make sure it&amp;rsquo;s not called because this will always start a local WSGI server which we do not want if we deploy that application to CGI / app engine.</source>
          <target state="translated">请事先确保您在应用程序文件中可能进行的所有 &lt;code&gt;app.run()&lt;/code&gt; 调用都在 &lt;code&gt;if __name__ == '__main__':&lt;/code&gt; 内部：阻止或移至单独的文件中。只需确保未调用它即可，因为这将始终启动本地WSGI服务器，如果我们将该应用程序部署到CGI / app引擎，我们将不希望这样做。</target>
        </trans-unit>
        <trans-unit id="4b15838b0cb523679f7f05e081c577aa2ef91921" translate="yes" xml:space="preserve">
          <source>Please make sure in advance that any &lt;code&gt;app.run()&lt;/code&gt; calls you might have in your application file are inside an &lt;code&gt;if __name__ ==
'__main__':&lt;/code&gt; block or moved to a separate file. Just make sure it&amp;rsquo;s not called because this will always start a local WSGI server which we do not want if we deploy that application to FastCGI.</source>
          <target state="translated">请事先确保您在应用程序文件中可能进行的所有 &lt;code&gt;app.run()&lt;/code&gt; 调用都在 &lt;code&gt;if __name__ == '__main__':&lt;/code&gt; 内部：阻止或移至单独的文件中。只需确保未调用它即可，因为这将始终启动本地WSGI服务器，如果我们将该应用程序部署到FastCGI则不希望这样做。</target>
        </trans-unit>
        <trans-unit id="f718a55f54576383c88bc32f71a33ffdefe33f14" translate="yes" xml:space="preserve">
          <source>Please make sure in advance that any &lt;code&gt;app.run()&lt;/code&gt; calls you might have in your application file are inside an &lt;code&gt;if __name__ ==
'__main__':&lt;/code&gt; block or moved to a separate file. Just make sure it&amp;rsquo;s not called because this will always start a local WSGI server which we do not want if we deploy that application to mod_wsgi.</source>
          <target state="translated">请事先确保您在应用程序文件中可能进行的所有 &lt;code&gt;app.run()&lt;/code&gt; 调用都在 &lt;code&gt;if __name__ == '__main__':&lt;/code&gt; 内部：阻止或移至单独的文件中。只需确保未调用它即可，因为这将始终启动本地WSGI服务器，如果我们将该应用程序部署到mod_wsgi，则不会使用该服务器。</target>
        </trans-unit>
        <trans-unit id="ceb923c253b41788db2664bc90c1f8c922b07f4f" translate="yes" xml:space="preserve">
          <source>Please make sure in advance that any &lt;code&gt;app.run()&lt;/code&gt; calls you might have in your application file are inside an &lt;code&gt;if __name__ ==
'__main__':&lt;/code&gt; block or moved to a separate file. Just make sure it&amp;rsquo;s not called because this will always start a local WSGI server which we do not want if we deploy that application to uWSGI.</source>
          <target state="translated">请事先确保您在应用程序文件中可能进行的所有 &lt;code&gt;app.run()&lt;/code&gt; 调用都在 &lt;code&gt;if __name__ == '__main__':&lt;/code&gt; 内部：阻止或移至单独的文件中。只需确保未调用它即可，因为这将始终启动本地WSGI服务器，如果我们将该应用程序部署到uWSGI，则不会使用该服务器。</target>
        </trans-unit>
        <trans-unit id="27ba4a5a55c050dc5a49ef54bc2aa40e11779957" translate="yes" xml:space="preserve">
          <source>Please never pass filenames to this function from user sources; you should use &lt;a href=&quot;#flask.send_from_directory&quot;&gt;&lt;code&gt;send_from_directory()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">请切勿从用户来源将文件名传递给此函数；您应该改为使用&lt;a href=&quot;#flask.send_from_directory&quot;&gt; &lt;code&gt;send_from_directory()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2eb3a18aab35e51f8230e445580a45d651165bf5" translate="yes" xml:space="preserve">
          <source>Pluggable Views</source>
          <target state="translated">可插拔式视图</target>
        </trans-unit>
        <trans-unit id="c8c7f94fb8bdebd1d476d111d09ca2d7fc3a190d" translate="yes" xml:space="preserve">
          <source>Pluggable views are attached to the application like a regular function by either using &lt;a href=&quot;../api/index#flask.Flask.route&quot;&gt;&lt;code&gt;route()&lt;/code&gt;&lt;/a&gt; or better &lt;a href=&quot;../api/index#flask.Flask.add_url_rule&quot;&gt;&lt;code&gt;add_url_rule()&lt;/code&gt;&lt;/a&gt;. That however also means that you would have to provide the names of the HTTP methods the view supports when you attach this. In order to move that information to the class you can provide a &lt;a href=&quot;../api/index#flask.views.View.methods&quot;&gt;&lt;code&gt;methods&lt;/code&gt;&lt;/a&gt; attribute that has this information:</source>
          <target state="translated">可插拔视图通过使用&lt;a href=&quot;../api/index#flask.Flask.route&quot;&gt; &lt;code&gt;route()&lt;/code&gt; &lt;/a&gt;或更好的&lt;a href=&quot;../api/index#flask.Flask.add_url_rule&quot;&gt; &lt;code&gt;add_url_rule()&lt;/code&gt; &lt;/a&gt;像常规函数一样附加到应用程序。但是，这也意味着您必须在附加此视图时提供视图支持的HTTP方法的名称。为了将该信息移至类，您可以提供具有以下信息的&lt;a href=&quot;../api/index#flask.views.View.methods&quot;&gt; &lt;code&gt;methods&lt;/code&gt; &lt;/a&gt;属性：</target>
        </trans-unit>
        <trans-unit id="ab2e26dd8b8868a3969cb3321e0c983c0d9d67d4" translate="yes" xml:space="preserve">
          <source>Plugins</source>
          <target state="translated">Plugins</target>
        </trans-unit>
        <trans-unit id="7acbe5e64c08eafe740b3eefe19e4332a092e411" translate="yes" xml:space="preserve">
          <source>Pocoo Styleguide</source>
          <target state="translated">宝酷风格指南</target>
        </trans-unit>
        <trans-unit id="9708b4b868355cb4dfc715097f9eea1a83dd9818" translate="yes" xml:space="preserve">
          <source>Pops the app context.</source>
          <target state="translated">弹出应用上下文。</target>
        </trans-unit>
        <trans-unit id="3d6d1c3dbba4e02c74d9c65bf844ac97f4e0272b" translate="yes" xml:space="preserve">
          <source>Pops the request context and unbinds it by doing that. This will also trigger the execution of functions registered by the &lt;a href=&quot;#flask.Flask.teardown_request&quot;&gt;&lt;code&gt;teardown_request()&lt;/code&gt;&lt;/a&gt; decorator.</source>
          <target state="translated">弹出请求上下文，然后解除绑定。这也将触发&lt;a href=&quot;#flask.Flask.teardown_request&quot;&gt; &lt;code&gt;teardown_request()&lt;/code&gt; &lt;/a&gt;装饰器注册的功能的执行。</target>
        </trans-unit>
        <trans-unit id="689d9f759000df604a1e9e27c36e2c78a35644dd" translate="yes" xml:space="preserve">
          <source>Prevents external sites from embedding your site in an &lt;code&gt;iframe&lt;/code&gt;. This prevents a class of attacks where clicks in the outer frame can be translated invisibly to clicks on your page&amp;rsquo;s elements. This is also known as &amp;ldquo;clickjacking&amp;rdquo;.</source>
          <target state="translated">防止外部网站将您的网站嵌入到 &lt;code&gt;iframe&lt;/code&gt; 中。这样可以防止发生一类攻击，其中外框的单击可能被不可见地转换为页面元素上的单击。这也称为&amp;ldquo;点击劫持&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="d0b9f9c1a797ea3ff41e558d4815402a8a29dac4" translate="yes" xml:space="preserve">
          <source>Prior to Flask 1.0 the &lt;code id=&quot;index-0&quot;&gt;FLASK_ENV&lt;/code&gt; environment variable was not supported and you needed to enable debug mode by exporting &lt;code&gt;FLASK_DEBUG=1&lt;/code&gt;. This can still be used to control debug mode, but you should prefer setting the development environment as shown above.</source>
          <target state="translated">在Flask 1.0之前，不支持 &lt;code id=&quot;index-0&quot;&gt;FLASK_ENV&lt;/code&gt; 环境变量，您需要通过导出 &lt;code&gt;FLASK_DEBUG=1&lt;/code&gt; 来启用调试模式。仍然可以使用它来控制调试模式，但是您应该更喜欢如上所示设置开发环境。</target>
        </trans-unit>
        <trans-unit id="bec16249f5252d7c66d569de153aaf134532c83e" translate="yes" xml:space="preserve">
          <source>Prior to Werkzeug 1.0.0, &lt;code&gt;InternalServerError&lt;/code&gt; will not always have an &lt;code&gt;original_exception&lt;/code&gt; attribute. Use &lt;code&gt;getattr(e, &quot;original_exception&quot;, None)&lt;/code&gt; to simulate the behavior for compatibility.</source>
          <target state="translated">在Werkzeug 1.0.0之前， &lt;code&gt;InternalServerError&lt;/code&gt; 并不总是具有 &lt;code&gt;original_exception&lt;/code&gt; 属性。使用 &lt;code&gt;getattr(e, &quot;original_exception&quot;, None)&lt;/code&gt; 模拟兼容性行为。</target>
        </trans-unit>
        <trans-unit id="510d558d478504b1883a316cb83f332ff65cc057" translate="yes" xml:space="preserve">
          <source>Probably caused by your application running as the wrong user. Make sure the folders the application needs access to have the proper privileges set and the application runs as the correct user (&lt;code&gt;user&lt;/code&gt; and &lt;code&gt;group&lt;/code&gt; parameter to the &lt;code&gt;WSGIDaemonProcess&lt;/code&gt; directive)</source>
          <target state="translated">可能是因为您的应用程序以错误的用户身份运行。确保应用程序需要访问的文件夹具有正确的权限设置，并且应用程序以正确的用户身份运行（ &lt;code&gt;WSGIDaemonProcess&lt;/code&gt; 指令的 &lt;code&gt;user&lt;/code&gt; 和 &lt;code&gt;group&lt;/code&gt; 参数）</target>
        </trans-unit>
        <trans-unit id="1e452b273a31bad7a63db24213fcd3d5c4c22bd7" translate="yes" xml:space="preserve">
          <source>Probably the most interesting way to load configurations is from an environment variable pointing to a file:</source>
          <target state="translated">也许最有趣的加载配置的方式是通过指向一个文件的环境变量。</target>
        </trans-unit>
        <trans-unit id="33e9bf0cbcdd31e29d7129531ea16920e4db1831" translate="yes" xml:space="preserve">
          <source>Project Layout</source>
          <target state="translated">项目布局</target>
        </trans-unit>
        <trans-unit id="e8183ca7dcc51bd46e9fc217027e13a12ea27d85" translate="yes" xml:space="preserve">
          <source>Provide template filters, static files, templates, and other utilities through blueprints. A blueprint does not have to implement applications or view functions.</source>
          <target state="translated">通过蓝图提供模板过滤器、静态文件、模板和其他实用程序。一个蓝图不一定要实现应用程序或视图功能。</target>
        </trans-unit>
        <trans-unit id="1c4ea3bed388c0e70dec7a3ebcbc6c5d6882f83b" translate="yes" xml:space="preserve">
          <source>Provides default cache_timeout for the &lt;a href=&quot;#flask.send_file&quot;&gt;&lt;code&gt;send_file()&lt;/code&gt;&lt;/a&gt; functions.</source>
          <target state="translated">为&lt;a href=&quot;#flask.send_file&quot;&gt; &lt;code&gt;send_file()&lt;/code&gt; &lt;/a&gt;函数提供默认的cache_timeout 。</target>
        </trans-unit>
        <trans-unit id="5b0be8476d208ad91944cf418484e2ed898764e1" translate="yes" xml:space="preserve">
          <source>Provides different ways to look at the current &lt;a href=&quot;https://tools.ietf.org/html/rfc3987.html&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;RFC 3987&lt;/strong&gt;&lt;/a&gt;. Imagine your application is listening on the following application root:</source>
          <target state="translated">提供了查看当前&lt;a href=&quot;https://tools.ietf.org/html/rfc3987.html&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;RFC 3987的&lt;/strong&gt;&lt;/a&gt;不同方法。假设您的应用程序正在以下应用程序根目录上侦听：</target>
        </trans-unit>
        <trans-unit id="2a99d4e86afa7d1265ea2257fd343aeacb0952d6" translate="yes" xml:space="preserve">
          <source>Proxy Setups</source>
          <target state="translated">代理设置</target>
        </trans-unit>
        <trans-unit id="45071c8ede678a742c625109b41db4b9fc102080" translate="yes" xml:space="preserve">
          <source>Pulls all flashed messages from the session and returns them. Further calls in the same request to the function will return the same messages. By default just the messages are returned, but when &lt;code&gt;with_categories&lt;/code&gt; is set to &lt;code&gt;True&lt;/code&gt;, the return value will be a list of tuples in the form &lt;code&gt;(category, message)&lt;/code&gt; instead.</source>
          <target state="translated">从会话中拉出所有闪烁的消息并返回它们。在同一请求中对该函数的进一步调用将返回相同的消息。默认情况下，仅返回消息，但是当 &lt;code&gt;with_categories&lt;/code&gt; 设置为 &lt;code&gt;True&lt;/code&gt; 时，返回值将改为以 &lt;code&gt;(category, message)&lt;/code&gt; 形式的元组列表。</target>
        </trans-unit>
        <trans-unit id="46ed7cfcd3417be03fd529ac80ba62809fe623fe" translate="yes" xml:space="preserve">
          <source>Purpose of the Context</source>
          <target state="translated">背景的目的</target>
        </trans-unit>
        <trans-unit id="c1da6796de9f5fe4c17ae734e33dc177c92cdf41" translate="yes" xml:space="preserve">
          <source>Put configuration files into a separate version control repository and symlink the active configs into place.</source>
          <target state="translated">将配置文件放到单独的版本控制仓库中,并将活动的配置符号链接到位。</target>
        </trans-unit>
        <trans-unit id="f4aa1d3f60abdff52aebd90df134c8642bc115d6" translate="yes" xml:space="preserve">
          <source>PyCharm Integration</source>
          <target state="translated">PyCharm集成</target>
        </trans-unit>
        <trans-unit id="86f94ef3ef9aec8e512e999815c5f3e4030c6e62" translate="yes" xml:space="preserve">
          <source>PyCharm Professional provides a special Flask run configuration. For the Community Edition, we need to configure it to call the &lt;code&gt;flask run&lt;/code&gt; CLI command with the correct environment variables. These instructions should be similar for any other IDE you might want to use.</source>
          <target state="translated">PyCharm Professional提供了一种特殊的Flask运行配置。对于Community Edition，我们需要对其进行配置，以使用正确的环境变量来调用 &lt;code&gt;flask run&lt;/code&gt; CLI命令。对于您可能要使用的任何其他IDE，这些说明应该相似。</target>
        </trans-unit>
        <trans-unit id="a54b6675d323337243a044e049646e596641d9d8" translate="yes" xml:space="preserve">
          <source>Python 3 comes bundled with the &lt;a href=&quot;https://docs.python.org/3/library/venv.html#module-venv&quot;&gt;&lt;code&gt;venv&lt;/code&gt;&lt;/a&gt; module to create virtual environments. If you&amp;rsquo;re using a modern version of Python, you can continue on to the next section.</source>
          <target state="translated">Python 3与&lt;a href=&quot;https://docs.python.org/3/library/venv.html#module-venv&quot;&gt; &lt;code&gt;venv&lt;/code&gt; &lt;/a&gt;模块捆绑在一起以创建虚拟环境。如果您使用的是现代版本的Python，则可以继续下一节。</target>
        </trans-unit>
        <trans-unit id="e67dd06503d322ddb37aa204244ecbcc12419ca8" translate="yes" xml:space="preserve">
          <source>Python Version</source>
          <target state="translated">Python版本</target>
        </trans-unit>
        <trans-unit id="b7b1b9ac2308619d964a8f88c0d28a5dfd79f847" translate="yes" xml:space="preserve">
          <source>Python has a really interesting feature called function decorators. This allows some really neat things for web applications. Because each view in Flask is a function, decorators can be used to inject additional functionality to one or more functions. The &lt;a href=&quot;../../api/index#flask.Flask.route&quot;&gt;&lt;code&gt;route()&lt;/code&gt;&lt;/a&gt; decorator is the one you probably used already. But there are use cases for implementing your own decorator. For instance, imagine you have a view that should only be used by people that are logged in. If a user goes to the site and is not logged in, they should be redirected to the login page. This is a good example of a use case where a decorator is an excellent solution.</source>
          <target state="translated">Python有一个非常有趣的功能，称为函数装饰器。这为Web应用程序提供了一些非常整洁的东西。因为Flask中的每个视图都是一个函数，所以可以使用装饰器将附加功能注入一个或多个函数。该&lt;a href=&quot;../../api/index#flask.Flask.route&quot;&gt; &lt;code&gt;route()&lt;/code&gt; &lt;/a&gt;装饰是你可能已经使用了一个。但是有一些实现自己的装饰器的用例。例如，假设您有一个视图，该视图仅应由已登录的人员使用。如果用户访问该站点但未登录，则应将其重定向到登录页面。这是一个很好的示例，其中装饰器是一个很好的解决方案。</target>
        </trans-unit>
        <trans-unit id="2644b7d942f174a4bbf0bc8675c1badf9352393e" translate="yes" xml:space="preserve">
          <source>Queries</source>
          <target state="translated">Queries</target>
        </trans-unit>
        <trans-unit id="0f1331a4c529e279e27433af5d2fd9538ba5f1f0" translate="yes" xml:space="preserve">
          <source>Query operators may be used by concatenating them with the field name using a double-underscore. &lt;code&gt;objects&lt;/code&gt;, and queries returned by calling it, are iterable.</source>
          <target state="translated">通过使用双下划线将查询运算符与字段名称连接起来，可以使用查询运算符。 &lt;code&gt;objects&lt;/code&gt; 和通过调用返回的查询都是可迭代的。</target>
        </trans-unit>
        <trans-unit id="f349a3391e26f3f1d75f808bd956512ec2f846b1" translate="yes" xml:space="preserve">
          <source>Querying and inserting works exactly the same as in the example above.</source>
          <target state="translated">查询和插入的工作原理和上面的例子完全一样。</target>
        </trans-unit>
        <trans-unit id="d28cf100bba18e2bac048313e1b0fd9243c69120" translate="yes" xml:space="preserve">
          <source>Querying is simple as well:</source>
          <target state="translated">查询也很简单。</target>
        </trans-unit>
        <trans-unit id="d07133c8504b6a0e98371a1b9afe2ca2855a7270" translate="yes" xml:space="preserve">
          <source>Quickstart</source>
          <target state="translated">Quickstart</target>
        </trans-unit>
        <trans-unit id="5ef0ac2bf15040bbfc46020872e2d1e70385f27e" translate="yes" xml:space="preserve">
          <source>Quoting attributes, so long as they contain no whitespace or special characters (like &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;'&lt;/code&gt;, or &lt;code&gt;&quot;&lt;/code&gt;).</source>
          <target state="translated">引用属性，只要它们不包含空格或特殊字符（如 &lt;code&gt;&amp;lt;&lt;/code&gt; ， &lt;code&gt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;'&lt;/code&gt; 或 &lt;code&gt;&quot;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="c36d9458e0d1baae7403b5ce642a78b09e4acc7f" translate="yes" xml:space="preserve">
          <source>Raises</source>
          <target state="translated">Raises</target>
        </trans-unit>
        <trans-unit id="e20360f40b9a6e1b17ce7e92a7707469d50d13e7" translate="yes" xml:space="preserve">
          <source>Raises an &lt;code&gt;HTTPException&lt;/code&gt; for the given status code or WSGI application.</source>
          <target state="translated">为给定的状态码或WSGI应用程序引发 &lt;code&gt;HTTPException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9bc79afeeb0a6a10fec56d5632921479af6d03cf" translate="yes" xml:space="preserve">
          <source>Rather than setting &lt;code&gt;FLASK_APP&lt;/code&gt; each time you open a new terminal, you can use Flask&amp;rsquo;s dotenv support to set environment variables automatically.</source>
          <target state="translated">您可以使用Flask的dotenv支持自动设置环境变量，而 &lt;code&gt;FLASK_APP&lt;/code&gt; 每次打开新终端时都设置FLASK_APP。</target>
        </trans-unit>
        <trans-unit id="2e487088ccdb15ae9d71e89f6f07a2076ed186aa" translate="yes" xml:space="preserve">
          <source>Read more on &lt;a href=&quot;../errorhandling/index#application-errors&quot;&gt;Application Errors&lt;/a&gt;.</source>
          <target state="translated">阅读有关&lt;a href=&quot;../errorhandling/index#application-errors&quot;&gt;应用程序错误的&lt;/a&gt;更多信息。</target>
        </trans-unit>
        <trans-unit id="2338770b68e4f66c50390253f9010d8dd8bd04fa" translate="yes" xml:space="preserve">
          <source>Read the Source.</source>
          <target state="translated">阅读来源。</target>
        </trans-unit>
        <trans-unit id="3235d8629365fac138bff776881e5d62b89a3b3e" translate="yes" xml:space="preserve">
          <source>Read this before you get started with Flask. This hopefully answers some questions about the purpose and goals of the project, and when you should or should not be using it.</source>
          <target state="translated">在你开始使用Flask之前,请先阅读这个。这希望能回答一些关于项目的目的和目标的问题,以及何时应该或不应该使用它。</target>
        </trans-unit>
        <trans-unit id="1d6edb0db3e37ebc083ed806c5b22c6f1b17ac32" translate="yes" xml:space="preserve">
          <source>Read-only view of the &lt;a href=&quot;../config/index#MAX_COOKIE_SIZE&quot;&gt;&lt;code&gt;MAX_COOKIE_SIZE&lt;/code&gt;&lt;/a&gt; config key.</source>
          <target state="translated">&lt;a href=&quot;../config/index#MAX_COOKIE_SIZE&quot;&gt; &lt;code&gt;MAX_COOKIE_SIZE&lt;/code&gt; &lt;/a&gt;配置键的只读视图。</target>
        </trans-unit>
        <trans-unit id="baffcb6ff4aca05407f4834143c357c0518f4ed6" translate="yes" xml:space="preserve">
          <source>Read-only view of the &lt;code&gt;MAX_CONTENT_LENGTH&lt;/code&gt; config key.</source>
          <target state="translated">&lt;code&gt;MAX_CONTENT_LENGTH&lt;/code&gt; 配置键的只读视图。</target>
        </trans-unit>
        <trans-unit id="19c8b642b923524967f5d9e02726b0d972b6b4c6" translate="yes" xml:space="preserve">
          <source>Reading cookies:</source>
          <target state="translated">阅读饼干。</target>
        </trans-unit>
        <trans-unit id="2a243f21a4168cf140cce74ec8287ad9ec07202a" translate="yes" xml:space="preserve">
          <source>Ready to deploy your new Flask app? Go to &lt;a href=&quot;../deploying/index#deployment&quot;&gt;Deployment Options&lt;/a&gt;.</source>
          <target state="translated">准备部署新的Flask应用程序了吗？转到&amp;ldquo;&lt;a href=&quot;../deploying/index#deployment&quot;&gt;部署选项&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="35bc6fe43f082f583cf718b9faa514bfe42c017f" translate="yes" xml:space="preserve">
          <source>Redirects and Errors</source>
          <target state="translated">重定向和错误</target>
        </trans-unit>
        <trans-unit id="eb17e6c5187c908476e13f541f7bae23a4b89396" translate="yes" xml:space="preserve">
          <source>Register a &lt;a href=&quot;#flask.Blueprint&quot;&gt;&lt;code&gt;Blueprint&lt;/code&gt;&lt;/a&gt; on the application. Keyword arguments passed to this method will override the defaults set on the blueprint.</source>
          <target state="translated">在应用程序上注册一个&lt;a href=&quot;#flask.Blueprint&quot;&gt; &lt;code&gt;Blueprint&lt;/code&gt; &lt;/a&gt;。传递给此方法的关键字参数将覆盖在蓝图上设置的默认值。</target>
        </trans-unit>
        <trans-unit id="0fa6eae7145e69546c574f4e059a2e4d9975991f" translate="yes" xml:space="preserve">
          <source>Register a URL value preprocessor function for all view functions in the application. These functions will be called before the &lt;a href=&quot;#flask.Flask.before_request&quot;&gt;&lt;code&gt;before_request()&lt;/code&gt;&lt;/a&gt; functions.</source>
          <target state="translated">为应用程序中的所有视图功能注册URL值预处理器功能。这些函数将在&lt;a href=&quot;#flask.Flask.before_request&quot;&gt; &lt;code&gt;before_request()&lt;/code&gt; &lt;/a&gt;函数之前调用。</target>
        </trans-unit>
        <trans-unit id="8747d45e2edc4b688597fdef2090ba468d70f9a3" translate="yes" xml:space="preserve">
          <source>Register a blueprint multiple times on an application with different URL rules.</source>
          <target state="translated">在一个应用程序上用不同的URL规则多次注册一个蓝图。</target>
        </trans-unit>
        <trans-unit id="17ead44f4288b9f95ed9476ca5afdaeb0fc4f3e9" translate="yes" xml:space="preserve">
          <source>Register a blueprint on an application at a URL prefix and/or subdomain. Parameters in the URL prefix/subdomain become common view arguments (with defaults) across all view functions in the blueprint.</source>
          <target state="translated">在应用程序的URL前缀和/或子域上注册一个蓝图,URL前缀和/或子域中的参数成为蓝图中所有视图函数的通用视图参数(有默认值)。URL前缀/子域中的参数成为蓝图中所有视图函数的通用视图参数(带默认值)。</target>
        </trans-unit>
        <trans-unit id="f8badd4f8424a29916945dd3c3a10f92577b3ad3" translate="yes" xml:space="preserve">
          <source>Register a blueprint on an application for any of these cases when initializing a Flask extension.</source>
          <target state="translated">在初始化Flask扩展时,为这些情况中的任何一种在应用程序上注册一个蓝图。</target>
        </trans-unit>
        <trans-unit id="eef68946fae8f2536a6cf14314889420edf55459" translate="yes" xml:space="preserve">
          <source>Register a custom template filter, available application wide. Like &lt;a href=&quot;#flask.Flask.add_template_filter&quot;&gt;&lt;code&gt;Flask.add_template_filter()&lt;/code&gt;&lt;/a&gt; but for a blueprint. Works exactly like the &lt;a href=&quot;#flask.Blueprint.app_template_filter&quot;&gt;&lt;code&gt;app_template_filter()&lt;/code&gt;&lt;/a&gt; decorator.</source>
          <target state="translated">注册自定义模板过滤器，适用于整个应用程序。像&lt;a href=&quot;#flask.Flask.add_template_filter&quot;&gt; &lt;code&gt;Flask.add_template_filter()&lt;/code&gt; &lt;/a&gt;一样，但是要有一个蓝图。就像&lt;a href=&quot;#flask.Blueprint.app_template_filter&quot;&gt; &lt;code&gt;app_template_filter()&lt;/code&gt; &lt;/a&gt;装饰器一样工作。</target>
        </trans-unit>
        <trans-unit id="9053c73527234bb7a3d8c50546b729208f8450f1" translate="yes" xml:space="preserve">
          <source>Register a custom template filter, available application wide. Like &lt;a href=&quot;#flask.Flask.template_filter&quot;&gt;&lt;code&gt;Flask.template_filter()&lt;/code&gt;&lt;/a&gt; but for a blueprint.</source>
          <target state="translated">注册自定义模板过滤器，适用于整个应用程序。就像&lt;a href=&quot;#flask.Flask.template_filter&quot;&gt; &lt;code&gt;Flask.template_filter()&lt;/code&gt; &lt;/a&gt;一样，但是要有一个蓝图。</target>
        </trans-unit>
        <trans-unit id="2eb65eab51ccef149ccbdf0aa535e8599027d9c5" translate="yes" xml:space="preserve">
          <source>Register a custom template filter. Works exactly like the &lt;a href=&quot;#flask.Flask.template_filter&quot;&gt;&lt;code&gt;template_filter()&lt;/code&gt;&lt;/a&gt; decorator.</source>
          <target state="translated">注册自定义模板过滤器。完全类似于&lt;a href=&quot;#flask.Flask.template_filter&quot;&gt; &lt;code&gt;template_filter()&lt;/code&gt; &lt;/a&gt;装饰器。</target>
        </trans-unit>
        <trans-unit id="1c38b4539b3182886d6583790966fe68fbba8df3" translate="yes" xml:space="preserve">
          <source>Register a custom template global function. Works exactly like the &lt;a href=&quot;#flask.Flask.template_global&quot;&gt;&lt;code&gt;template_global()&lt;/code&gt;&lt;/a&gt; decorator.</source>
          <target state="translated">注册自定义模板全局功能。完全类似于&lt;a href=&quot;#flask.Flask.template_global&quot;&gt; &lt;code&gt;template_global()&lt;/code&gt; &lt;/a&gt;装饰器。</target>
        </trans-unit>
        <trans-unit id="64bc8e4606186f8104343e29c3819f4a92442d5b" translate="yes" xml:space="preserve">
          <source>Register a custom template global, available application wide. Like &lt;a href=&quot;#flask.Flask.add_template_global&quot;&gt;&lt;code&gt;Flask.add_template_global()&lt;/code&gt;&lt;/a&gt; but for a blueprint. Works exactly like the &lt;a href=&quot;#flask.Blueprint.app_template_global&quot;&gt;&lt;code&gt;app_template_global()&lt;/code&gt;&lt;/a&gt; decorator.</source>
          <target state="translated">在全球范围内注册一个可用的自定义模板。像&lt;a href=&quot;#flask.Flask.add_template_global&quot;&gt; &lt;code&gt;Flask.add_template_global()&lt;/code&gt; &lt;/a&gt;一样，但是要有一个蓝图。就像&lt;a href=&quot;#flask.Blueprint.app_template_global&quot;&gt; &lt;code&gt;app_template_global()&lt;/code&gt; &lt;/a&gt;装饰器一样工作。</target>
        </trans-unit>
        <trans-unit id="5b082354877a75bacecb16f6c90d759533ed76a6" translate="yes" xml:space="preserve">
          <source>Register a custom template global, available application wide. Like &lt;a href=&quot;#flask.Flask.template_global&quot;&gt;&lt;code&gt;Flask.template_global()&lt;/code&gt;&lt;/a&gt; but for a blueprint.</source>
          <target state="translated">在全球范围内注册一个可用的自定义模板。就像&lt;a href=&quot;#flask.Flask.template_global&quot;&gt; &lt;code&gt;Flask.template_global()&lt;/code&gt; &lt;/a&gt;一样，但要有一个蓝图。</target>
        </trans-unit>
        <trans-unit id="e19ca8bc125d79d1c786cb6c2a003284bb09c7fc" translate="yes" xml:space="preserve">
          <source>Register a custom template test, available application wide. Like &lt;a href=&quot;#flask.Flask.add_template_test&quot;&gt;&lt;code&gt;Flask.add_template_test()&lt;/code&gt;&lt;/a&gt; but for a blueprint. Works exactly like the &lt;a href=&quot;#flask.Blueprint.app_template_test&quot;&gt;&lt;code&gt;app_template_test()&lt;/code&gt;&lt;/a&gt; decorator.</source>
          <target state="translated">注册自定义模板测试，适用于整个应用程序。就像&lt;a href=&quot;#flask.Flask.add_template_test&quot;&gt; &lt;code&gt;Flask.add_template_test()&lt;/code&gt; &lt;/a&gt;一样，但是要有一个蓝图。就像&lt;a href=&quot;#flask.Blueprint.app_template_test&quot;&gt; &lt;code&gt;app_template_test()&lt;/code&gt; &lt;/a&gt;装饰器一样工作。</target>
        </trans-unit>
        <trans-unit id="20cdb59984f9f1f1a5afe246467af4c662061997" translate="yes" xml:space="preserve">
          <source>Register a custom template test, available application wide. Like &lt;a href=&quot;#flask.Flask.template_test&quot;&gt;&lt;code&gt;Flask.template_test()&lt;/code&gt;&lt;/a&gt; but for a blueprint.</source>
          <target state="translated">注册自定义模板测试，适用于整个应用程序。就像&lt;a href=&quot;#flask.Flask.template_test&quot;&gt; &lt;code&gt;Flask.template_test()&lt;/code&gt; &lt;/a&gt;一样，但是要有一个蓝图。</target>
        </trans-unit>
        <trans-unit id="f89b7ca97751e941367185eecdebf09d0d4a3088" translate="yes" xml:space="preserve">
          <source>Register a custom template test. Works exactly like the &lt;a href=&quot;#flask.Flask.template_test&quot;&gt;&lt;code&gt;template_test()&lt;/code&gt;&lt;/a&gt; decorator.</source>
          <target state="translated">注册自定义模板测试。完全类似于&lt;a href=&quot;#flask.Flask.template_test&quot;&gt; &lt;code&gt;template_test()&lt;/code&gt; &lt;/a&gt;装饰器。</target>
        </trans-unit>
        <trans-unit id="786ba206b445388807d0dee766251ec7a3c161f7" translate="yes" xml:space="preserve">
          <source>Register a function to be run after each request.</source>
          <target state="translated">注册一个函数,在每次请求后运行。</target>
        </trans-unit>
        <trans-unit id="1922b3d9aba69644150720a374d297e7275e789b" translate="yes" xml:space="preserve">
          <source>Register a function to be run at the end of each request, regardless of whether there was an exception or not. These functions are executed when the request context is popped, even if not an actual request was performed.</source>
          <target state="translated">注册一个函数,在每个请求结束时运行,无论是否有异常。当请求上下文被弹出时,即使没有实际执行请求,这些函数也会被执行。</target>
        </trans-unit>
        <trans-unit id="f1d6d97dfe34bdd6512b4c1f929f1ec536faa17f" translate="yes" xml:space="preserve">
          <source>Register a function to handle errors by code or exception class.</source>
          <target state="translated">按代码或异常类注册一个处理错误的函数。</target>
        </trans-unit>
        <trans-unit id="f9606d247af2ee78d058bd363a9be1eb608fbef7" translate="yes" xml:space="preserve">
          <source>Register a new tag with this serializer.</source>
          <target state="translated">用这个序列器注册一个新标签。</target>
        </trans-unit>
        <trans-unit id="973f33d061c60d591fe63ae2061b038f1bd01154" translate="yes" xml:space="preserve">
          <source>Register handlers by decorating a function with &lt;a href=&quot;../api/index#flask.Flask.errorhandler&quot;&gt;&lt;code&gt;errorhandler()&lt;/code&gt;&lt;/a&gt;. Or use &lt;a href=&quot;../api/index#flask.Flask.register_error_handler&quot;&gt;&lt;code&gt;register_error_handler()&lt;/code&gt;&lt;/a&gt; to register the function later. Remember to set the error code when returning the response.</source>
          <target state="translated">通过使用&lt;a href=&quot;../api/index#flask.Flask.errorhandler&quot;&gt; &lt;code&gt;errorhandler()&lt;/code&gt; &lt;/a&gt;装饰函数来注册处理程序。或使用&lt;a href=&quot;../api/index#flask.Flask.register_error_handler&quot;&gt; &lt;code&gt;register_error_handler()&lt;/code&gt; &lt;/a&gt;稍后注册该函数。返回响应时，请记住设置错误代码。</target>
        </trans-unit>
        <trans-unit id="a6fcf65105245b98be60c2b8d51e605c7ddb9184" translate="yes" xml:space="preserve">
          <source>Registering</source>
          <target state="translated">Registering</target>
        </trans-unit>
        <trans-unit id="2562cfd5f7d0202a4079f368f92b0eba38a1a46a" translate="yes" xml:space="preserve">
          <source>Registering Blueprints</source>
          <target state="translated">注册蓝图</target>
        </trans-unit>
        <trans-unit id="363e0a395b064f2d2305dd5417dc21df39a99b53" translate="yes" xml:space="preserve">
          <source>Registering Commands with Blueprints</source>
          <target state="translated">用蓝图注册命令</target>
        </trans-unit>
        <trans-unit id="a0102105598c43210b5d0e5cd6c58fdd350dd7aa" translate="yes" xml:space="preserve">
          <source>Registering Filters</source>
          <target state="translated">注册过滤器</target>
        </trans-unit>
        <trans-unit id="9a17bb397ab016136b27157bd2404596ab0fecfa" translate="yes" xml:space="preserve">
          <source>Registering an Error Handler</source>
          <target state="translated">注册一个错误处理程序</target>
        </trans-unit>
        <trans-unit id="4e5d0e9a1c26ad6e2db8188e4e95f15f0bd89ed6" translate="yes" xml:space="preserve">
          <source>Registers a function as URL value preprocessor for this blueprint. It&amp;rsquo;s called before the view functions are called and can modify the url values provided.</source>
          <target state="translated">注册一个函数作为此蓝图的URL值预处理器。在调用视图函数之前先调用它，并且可以修改提供的url值。</target>
        </trans-unit>
        <trans-unit id="3d702634d1d9c98ef60a67dcdd51565af6ffe7a4" translate="yes" xml:space="preserve">
          <source>Registers a function that is called when the blueprint is registered on the application. This function is called with the state as argument as returned by the &lt;a href=&quot;#flask.Blueprint.make_setup_state&quot;&gt;&lt;code&gt;make_setup_state()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">注册在应用程序中注册蓝图时调用的函数。通过&lt;a href=&quot;#flask.Blueprint.make_setup_state&quot;&gt; &lt;code&gt;make_setup_state()&lt;/code&gt; &lt;/a&gt;方法返回的状态作为参数来调用此函数。</target>
        </trans-unit>
        <trans-unit id="d2a52834cac1991fb7857fd3d3b94f52da71efd4" translate="yes" xml:space="preserve">
          <source>Registers a function to be called when the application context ends. These functions are typically also called when the request context is popped.</source>
          <target state="translated">注册一个在应用上下文结束时调用的函数。这些函数通常也会在请求上下文被弹出时被调用。</target>
        </trans-unit>
        <trans-unit id="50145a55e49e5e9c1dc06ebb865e6eb4a5e70e76" translate="yes" xml:space="preserve">
          <source>Registers a function to be run before the first request to this instance of the application.</source>
          <target state="translated">注册一个函数,以便在对该应用程序实例的第一个请求之前运行。</target>
        </trans-unit>
        <trans-unit id="4e92656ed6edcf75e884a2554402101095404360" translate="yes" xml:space="preserve">
          <source>Registers a function to run before each request.</source>
          <target state="translated">注册一个函数,在每次请求前运行。</target>
        </trans-unit>
        <trans-unit id="c206f5584d9be3f897902d753abd9c0ca035960c" translate="yes" xml:space="preserve">
          <source>Registers a shell context processor function.</source>
          <target state="translated">注册一个shell上下文处理器函数。</target>
        </trans-unit>
        <trans-unit id="f08b58e4a62bbc4ed12a565c202f69408c86678b" translate="yes" xml:space="preserve">
          <source>Registers a template context processor function.</source>
          <target state="translated">注册一个模板上下文处理函数。</target>
        </trans-unit>
        <trans-unit id="2d9a190d55a56f5e826005f2a09445dcba6f4f19" translate="yes" xml:space="preserve">
          <source>Registers an error handler that becomes active for this blueprint only. Please be aware that routing does not happen local to a blueprint so an error handler for 404 usually is not handled by a blueprint unless it is caused inside a view function. Another special case is the 500 internal server error which is always looked up from the application.</source>
          <target state="translated">注册一个错误处理程序,这个错误处理程序只对这个蓝图有效。请注意,路由不会发生在蓝图的本地,所以404的错误处理程序通常不会被蓝图处理,除非它是在视图函数中引起的。另一种特殊情况是500内部服务器错误,它总是从应用程序中查找。</target>
        </trans-unit>
        <trans-unit id="9ef64cc6bb1fbd4c2866f82bed807d0ab27370b8" translate="yes" xml:space="preserve">
          <source>Relational databases need schemas, so applications often ship a &lt;code&gt;schema.sql&lt;/code&gt; file that creates the database. It&amp;rsquo;s a good idea to provide a function that creates the database based on that schema. This function can do that for you:</source>
          <target state="translated">关系数据库需要模式，因此应用程序通常会 &lt;code&gt;schema.sql&lt;/code&gt; 一个用于创建数据库的schema.sql文件。提供一个基于该架构创建数据库的功能是一个好主意。此功能可以为您做到这一点：</target>
        </trans-unit>
        <trans-unit id="e7d482b5615ce49cc910bfa3446f36543262f2bc" translate="yes" xml:space="preserve">
          <source>Relative paths being used. Don&amp;rsquo;t rely on the current working directory.</source>
          <target state="translated">使用的相对路径。不要依赖当前的工作目录。</target>
        </trans-unit>
        <trans-unit id="2a1eb31abfbd5be7e172b7bdddd4da8ac00178d4" translate="yes" xml:space="preserve">
          <source>Reload templates when they are changed. If not set, it will be enabled in debug mode.</source>
          <target state="translated">当模板被更改时,重新加载模板。如果没有设置,将在调试模式下启用。</target>
        </trans-unit>
        <trans-unit id="dbb65020b7743789ba3df640c3a8a815be93a537" translate="yes" xml:space="preserve">
          <source>Reload templates when they are changed. Used by &lt;a href=&quot;#flask.Flask.create_jinja_environment&quot;&gt;&lt;code&gt;create_jinja_environment()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">更改模板后重新加载。由&lt;a href=&quot;#flask.Flask.create_jinja_environment&quot;&gt; &lt;code&gt;create_jinja_environment()&lt;/code&gt; 使用&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dc1d7b8595bd98dd36abe190fbf26207854c0e3b" translate="yes" xml:space="preserve">
          <source>Remember to enable the FastCGI, alias and rewrite modules. This configuration binds the application to &lt;code&gt;/yourapplication&lt;/code&gt;. If you want the application to work in the URL root you have to work around a lighttpd bug with the &lt;code&gt;LighttpdCGIRootFix&lt;/code&gt; middleware.</source>
          <target state="translated">记住要启用FastCGI，别名和重写模块。此配置将应用程序绑定到 &lt;code&gt;/yourapplication&lt;/code&gt; 。如果要使应用程序在URL根目录中运行，则必须使用 &lt;code&gt;LighttpdCGIRootFix&lt;/code&gt; 中间件来解决lighttpd错误。</target>
        </trans-unit>
        <trans-unit id="f4678284fd9b7a1983bdf1b69dac500c1d68f344" translate="yes" xml:space="preserve">
          <source>Removing the Default Handler</source>
          <target state="translated">移除默认处理程序</target>
        </trans-unit>
        <trans-unit id="99bd1e34cd164e21963997294779599c4962042e" translate="yes" xml:space="preserve">
          <source>Rendering Templates</source>
          <target state="translated">渲染模板</target>
        </trans-unit>
        <trans-unit id="b7238a65cc779bc86501d983b405824f537c25e0" translate="yes" xml:space="preserve">
          <source>Renders a template from the given template source string with the given context. Template variables will be autoescaped.</source>
          <target state="translated">从给定的模板源字符串和给定的上下文中渲染一个模板。模板变量将被自动转码。</target>
        </trans-unit>
        <trans-unit id="7056facc50a42e1bbb7aafb2075b5a679dd7aaed" translate="yes" xml:space="preserve">
          <source>Renders a template from the template folder with the given context.</source>
          <target state="translated">渲染模板文件夹中给定上下文的模板。</target>
        </trans-unit>
        <trans-unit id="74e1774d5cfe2468a846eb350a7ae7cc14b51788" translate="yes" xml:space="preserve">
          <source>Reporting issues</source>
          <target state="translated">报告问题</target>
        </trans-unit>
        <trans-unit id="b84b46b22009620d91e06386c00d9723126f02b7" translate="yes" xml:space="preserve">
          <source>Represents a blueprint, a collection of routes and other app-related functions that can be registered on a real application later.</source>
          <target state="translated">代表一个蓝图,一个路线和其他应用相关功能的集合,以后可以在真实应用上注册。</target>
        </trans-unit>
        <trans-unit id="44eedf6a2cc259a54e1f169e1282a4ed09263c43" translate="yes" xml:space="preserve">
          <source>Request Content Checksums</source>
          <target state="translated">请求内容校验和</target>
        </trans-unit>
        <trans-unit id="96d785b31d927a492771f3da3845c9ce8081ae51" translate="yes" xml:space="preserve">
          <source>Request contexts disappear when the response is started on the server. This is done for efficiency reasons and to make it less likely to encounter memory leaks with badly written WSGI middlewares. The downside is that if you are using streamed responses, the generator cannot access request bound information any more.</source>
          <target state="translated">当服务器上启动响应时,请求上下文会消失。这样做是出于效率的考虑,也是为了减少在WSGI中间件写得不好的情况下遇到内存泄漏的可能性。缺点是,如果你使用流式响应,生成器不能再访问请求绑定的信息。</target>
        </trans-unit>
        <trans-unit id="1a46061f42dd431466606615561bbfa9fb04a7a7" translate="yes" xml:space="preserve">
          <source>Requested path as unicode, including the query string.</source>
          <target state="translated">要求的路径为unicode,包括查询字符串。</target>
        </trans-unit>
        <trans-unit id="2c6d9da7639fc3274b858872a4f7716fdfcca3c1" translate="yes" xml:space="preserve">
          <source>Requested path as unicode. This works a bit like the regular path info in the WSGI environment but will always include a leading slash, even if the URL root is accessed.</source>
          <target state="translated">要求的路径为unicode。这有点像WSGI环境中的常规路径信息,但总是包含一个前导斜线,即使访问的是URL根。</target>
        </trans-unit>
        <trans-unit id="6c4ce63ec03061e43d242c3a8cce1731d75de69a" translate="yes" xml:space="preserve">
          <source>Requiring boolean attributes to have a value.</source>
          <target state="translated">要求布尔属性有一个值。</target>
        </trans-unit>
        <trans-unit id="f003d35e4131a41424a1edfbb53ccfb4138d412f" translate="yes" xml:space="preserve">
          <source>Response Objects</source>
          <target state="translated">响应对象</target>
        </trans-unit>
        <trans-unit id="c12d669aa0f6dfedba8d8fd91ab1f8b825805513" translate="yes" xml:space="preserve">
          <source>Restrict how cookies are sent with requests from external sites. Can be set to &lt;code&gt;'Lax'&lt;/code&gt; (recommended) or &lt;code&gt;'Strict'&lt;/code&gt;. See &lt;a href=&quot;../security/index#security-cookie&quot;&gt;Set-Cookie options&lt;/a&gt;.</source>
          <target state="translated">限制如何通过外部站点的请求发送cookie。可以设置为 &lt;code&gt;'Lax'&lt;/code&gt; （推荐）或 &lt;code&gt;'Strict'&lt;/code&gt; 。请参阅&lt;a href=&quot;../security/index#security-cookie&quot;&gt;Set-Cookie选项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bc0f3f6b8203dea5570811797798b085a5428caf" translate="yes" xml:space="preserve">
          <source>Return &lt;code&gt;'Strict'&lt;/code&gt; or &lt;code&gt;'Lax'&lt;/code&gt; if the cookie should use the &lt;code&gt;SameSite&lt;/code&gt; attribute. This currently just returns the value of the &lt;a href=&quot;../config/index#SESSION_COOKIE_SAMESITE&quot;&gt;&lt;code&gt;SESSION_COOKIE_SAMESITE&lt;/code&gt;&lt;/a&gt; setting.</source>
          <target state="translated">如果cookie应该使用 &lt;code&gt;SameSite&lt;/code&gt; 属性，则返回 &lt;code&gt;'Strict'&lt;/code&gt; 或 &lt;code&gt;'Lax'&lt;/code&gt; 。当前，这仅返回&lt;a href=&quot;../config/index#SESSION_COOKIE_SAMESITE&quot;&gt; &lt;code&gt;SESSION_COOKIE_SAMESITE&lt;/code&gt; &lt;/a&gt;设置的值。</target>
        </trans-unit>
        <trans-unit id="efc16add0b10829542292bffe46208a2bd5eb2d8" translate="yes" xml:space="preserve">
          <source>Return an iterator over the attribute names.</source>
          <target state="translated">返回属性名的迭代器。</target>
        </trans-unit>
        <trans-unit id="a144b11d9dac5475617f23c5f9961f701567ad7e" translate="yes" xml:space="preserve">
          <source>Return the value for key if key is in the dictionary, else default.</source>
          <target state="translated">如果key在字典中,返回key的值,否则为默认值。</target>
        </trans-unit>
        <trans-unit id="41b1fb407b7fa442b77381701968fb175362cf78" translate="yes" xml:space="preserve">
          <source>Return type</source>
          <target state="translated">返回类型</target>
        </trans-unit>
        <trans-unit id="671367e804d177368e584fbd155b16e09e60db4a" translate="yes" xml:space="preserve">
          <source>Returning API errors as JSON</source>
          <target state="translated">以JSON格式返回API错误</target>
        </trans-unit>
        <trans-unit id="9582a02f141fc4b345b2936eba691cd0654efebc" translate="yes" xml:space="preserve">
          <source>Returns</source>
          <target state="translated">Returns</target>
        </trans-unit>
        <trans-unit id="7c6de22fc0b97648e32d83f378c61f49d0161d83" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;True&lt;/code&gt; if autoescaping should be active for the given template name. If no template name is given, returns &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">如果给定模板名称的自动转义应处于活动状态，则返回 &lt;code&gt;True&lt;/code&gt; 。如果未提供模板名称，则返回 &lt;code&gt;True&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5701205ff69e1fb20dcaec383fc1417e34e029c0" translate="yes" xml:space="preserve">
          <source>Returns True if the cookie should be secure. This currently just returns the value of the &lt;code&gt;SESSION_COOKIE_SECURE&lt;/code&gt; setting.</source>
          <target state="translated">如果cookie应该是安全的，则返回True。当前，这仅返回 &lt;code&gt;SESSION_COOKIE_SECURE&lt;/code&gt; 设置的值。</target>
        </trans-unit>
        <trans-unit id="404fdedc6fa993516185ed17656214c3c95b0490" translate="yes" xml:space="preserve">
          <source>Returns True if the request method carries content. As of Werkzeug 0.9 this will be the case if a content type is transmitted.</source>
          <target state="translated">如果请求方法携带内容,则返回True。从Werkzeug 0.9开始,如果传输的是内容类型,则会是这样。</target>
        </trans-unit>
        <trans-unit id="e27935af18d9af8c6f96ff1463b958dce57447c6" translate="yes" xml:space="preserve">
          <source>Returns True if the session cookie should be httponly. This currently just returns the value of the &lt;code&gt;SESSION_COOKIE_HTTPONLY&lt;/code&gt; config var.</source>
          <target state="translated">如果会话cookie应该是httponly，则返回True。当前，这仅返回 &lt;code&gt;SESSION_COOKIE_HTTPONLY&lt;/code&gt; 配置变量的值。</target>
        </trans-unit>
        <trans-unit id="56583440f34114f334f7f98549cbf3680f1c76fe" translate="yes" xml:space="preserve">
          <source>Returns a dictionary containing a subset of configuration options that match the specified namespace/prefix. Example usage:</source>
          <target state="translated">返回一个包含与指定命名空间/前缀匹配的配置选项子集的字典。使用示例。</target>
        </trans-unit>
        <trans-unit id="7560e9a69e0612d2f3a8894a4f7c6666072d1f8e" translate="yes" xml:space="preserve">
          <source>Returns a list of subcommand names in the order they should appear.</source>
          <target state="translated">返回子命令名称的列表,按其出现的顺序排列。</target>
        </trans-unit>
        <trans-unit id="1c21bc97327d9cc271f4211f8901f8ed8faa7bc1" translate="yes" xml:space="preserve">
          <source>Returns a response object (a WSGI application) that, if called, redirects the client to the target location. Supported codes are 301, 302, 303, 305, 307, and 308. 300 is not supported because it&amp;rsquo;s not a real redirect and 304 because it&amp;rsquo;s the answer for a request with a request with defined If-Modified-Since headers.</source>
          <target state="translated">返回一个响应对象（WSGI应用程序），如果调用该对象，会将客户端重定向到目标位置。支持的代码为301、302、303、305、307和308。不支持300，因为它不是真正的重定向；而由于它是带定义的If-Modified-Since标头的请求的响应，因此不支持304。</target>
        </trans-unit>
        <trans-unit id="2815bbd130c15f7afcfca2916826df0bd2206402" translate="yes" xml:space="preserve">
          <source>Returns an instance of &lt;a href=&quot;#flask.Flask.test_cli_runner_class&quot;&gt;&lt;code&gt;test_cli_runner_class&lt;/code&gt;&lt;/a&gt;, by default &lt;a href=&quot;#flask.testing.FlaskCliRunner&quot;&gt;&lt;code&gt;FlaskCliRunner&lt;/code&gt;&lt;/a&gt;. The Flask app object is passed as the first argument.</source>
          <target state="translated">返回&lt;a href=&quot;#flask.Flask.test_cli_runner_class&quot;&gt; &lt;code&gt;test_cli_runner_class&lt;/code&gt; &lt;/a&gt;的实例，默认情况下为&lt;a href=&quot;#flask.testing.FlaskCliRunner&quot;&gt; &lt;code&gt;FlaskCliRunner&lt;/code&gt; &lt;/a&gt;。Flask应用程序对象作为第一个参数传递。</target>
        </trans-unit>
        <trans-unit id="25ed0db89932b4b7bae25ef3265b379bace9126f" translate="yes" xml:space="preserve">
          <source>Returns the domain that should be set for the session cookie.</source>
          <target state="translated">返回应该为session cookie设置的域名。</target>
        </trans-unit>
        <trans-unit id="72fb3861561869cadba235cf1f8cb833ce46418d" translate="yes" xml:space="preserve">
          <source>Returns the path for which the cookie should be valid. The default implementation uses the value from the &lt;code&gt;SESSION_COOKIE_PATH&lt;/code&gt; config var if it&amp;rsquo;s set, and falls back to &lt;code&gt;APPLICATION_ROOT&lt;/code&gt; or uses &lt;code&gt;/&lt;/code&gt; if it&amp;rsquo;s &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">返回cookie应该有效的路径。默认实现从使用值 &lt;code&gt;SESSION_COOKIE_PATH&lt;/code&gt; 配置变种，如果它的设置，并回落到 &lt;code&gt;APPLICATION_ROOT&lt;/code&gt; 或使用 &lt;code&gt;/&lt;/code&gt; ，如果是 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a47c612739b4b116ef3f5d11fc6e19122d91b0cc" translate="yes" xml:space="preserve">
          <source>Returns the shell context for an interactive shell for this application. This runs all the registered shell context processors.</source>
          <target state="translated">返回此应用程序的交互式shell上下文。这将运行所有注册的shell上下文处理器。</target>
        </trans-unit>
        <trans-unit id="6e97dac97319b90275a283e4c44f679cebe7621a" translate="yes" xml:space="preserve">
          <source>Returns the value of the &lt;code&gt;PRESERVE_CONTEXT_ON_EXCEPTION&lt;/code&gt; configuration value in case it&amp;rsquo;s set, otherwise a sensible default is returned.</source>
          <target state="translated">如果已设置，则返回 &lt;code&gt;PRESERVE_CONTEXT_ON_EXCEPTION&lt;/code&gt; 配置值的值，否则返回合理的默认值。</target>
        </trans-unit>
        <trans-unit id="3c5372cf7b75e4cd24140a49721969a972f61092" translate="yes" xml:space="preserve">
          <source>Returns the value of the &lt;code&gt;PROPAGATE_EXCEPTIONS&lt;/code&gt; configuration value in case it&amp;rsquo;s set, otherwise a sensible default is returned.</source>
          <target state="translated">如果已设置，则返回 &lt;code&gt;PROPAGATE_EXCEPTIONS&lt;/code&gt; 配置值的值，否则返回合理的默认值。</target>
        </trans-unit>
        <trans-unit id="993ef97f326322cb4112954722a8530a9e9af585" translate="yes" xml:space="preserve">
          <source>Reversing is often more descriptive than hard-coding the URLs.</source>
          <target state="translated">反转往往比硬编码的URL更具有描述性。</target>
        </trans-unit>
        <trans-unit id="7d15dd1bec2e055c5b177c9f869305ae6c54c9bb" translate="yes" xml:space="preserve">
          <source>Routing</source>
          <target state="translated">Routing</target>
        </trans-unit>
        <trans-unit id="977f345919f63d6fb867264a96ca21a23b59e99a" translate="yes" xml:space="preserve">
          <source>Run a local development server.</source>
          <target state="translated">运行本地开发服务器。</target>
        </trans-unit>
        <trans-unit id="863e7ecb3d555e92cf3fe837e6c86b3380f7a9a3" translate="yes" xml:space="preserve">
          <source>Run a worker</source>
          <target state="translated">运行一个工人</target>
        </trans-unit>
        <trans-unit id="b8732ef11b3c44103fb0610722026273e7cd67ed" translate="yes" xml:space="preserve">
          <source>Run an interactive Python shell in the context of a given Flask application. The application will populate the default namespace of this shell according to it&amp;rsquo;s configuration.</source>
          <target state="translated">在给定的Flask应用程序上下文中运行交互式Python Shell。应用程序将根据其配置填充此Shell的默认名称空间。</target>
        </trans-unit>
        <trans-unit id="e6d1bcfded07ebaf27886fb78ab8effbf6a8b2ba" translate="yes" xml:space="preserve">
          <source>Run it again and you should see one passing test:</source>
          <target state="translated">再运行一次,你应该会看到一个通过测试。</target>
        </trans-unit>
        <trans-unit id="d38c9b271f8a29d219b23a6dea1fa8204bbea7d7" translate="yes" xml:space="preserve">
          <source>Run the Development Server</source>
          <target state="translated">运行开发服务器</target>
        </trans-unit>
        <trans-unit id="bfd97901038a77367b442db2ffbd179a3137b42c" translate="yes" xml:space="preserve">
          <source>Running &lt;a href=&quot;https://uwsgi-docs.readthedocs.io/en/latest/HTTP.html#the-uwsgi-http-https-router&quot;&gt;uWSGI HTTP Router&lt;/a&gt;:</source>
          <target state="translated">运行&lt;a href=&quot;https://uwsgi-docs.readthedocs.io/en/latest/HTTP.html#the-uwsgi-http-https-router&quot;&gt;uWSGI HTTP Router&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="a5ed6e0297f79b8ec233c4729cd9611f52e499ea" translate="yes" xml:space="preserve">
          <source>Running &lt;code&gt;python setup.py sdist&lt;/code&gt; will create a development package with &amp;ldquo;.dev&amp;rdquo; and the current date appended: &lt;code&gt;flaskr-1.0.dev20160314.tar.gz&lt;/code&gt;. Running &lt;code&gt;python setup.py release sdist&lt;/code&gt; will create a release package with only the version: &lt;code&gt;flaskr-1.0.tar.gz&lt;/code&gt;.</source>
          <target state="translated">运行 &lt;code&gt;python setup.py sdist&lt;/code&gt; 将创建一个带有&amp;ldquo; .dev&amp;rdquo;的开发包，并附加当前日期： &lt;code&gt;flaskr-1.0.dev20160314.tar.gz&lt;/code&gt; 。运行 &lt;code&gt;python setup.py release sdist&lt;/code&gt; 将创建一个仅包含以下版本的发行包： &lt;code&gt;flaskr-1.0.tar.gz&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a481f5e82ca820158890efacbad28bdeab57d638" translate="yes" xml:space="preserve">
          <source>Running Fabfiles</source>
          <target state="translated">运行Fabfiles</target>
        </trans-unit>
        <trans-unit id="ca09dbe52f47cf825b758cf5dd8b86b9f39b7520" translate="yes" xml:space="preserve">
          <source>Running FastCGI Processes</source>
          <target state="translated">运行FastCGI进程</target>
        </trans-unit>
        <trans-unit id="6da4751f0e6e30c57a9ef763da16a7965bbfab62" translate="yes" xml:space="preserve">
          <source>Running that should now give us three passing tests:</source>
          <target state="translated">运行,现在应该给我们三个合格的测试。</target>
        </trans-unit>
        <trans-unit id="01defe8c68cac94767eb27be94f91e9090c30db0" translate="yes" xml:space="preserve">
          <source>Runs the application on a local development server.</source>
          <target state="translated">在本地开发服务器上运行应用程序。</target>
        </trans-unit>
        <trans-unit id="7f6dd15f671b4a38d038721c5f7cb35c81830073" translate="yes" xml:space="preserve">
          <source>SQL Abstraction Layer</source>
          <target state="translated">SQL抽象层</target>
        </trans-unit>
        <trans-unit id="9dec366055e050901425a1ce712b9c13469996ec" translate="yes" xml:space="preserve">
          <source>SQLAlchemy in Flask</source>
          <target state="translated">Flask中的SQLAlchemy</target>
        </trans-unit>
        <trans-unit id="5bf9caf3c8b407cf690e2a0b21e425c06317822e" translate="yes" xml:space="preserve">
          <source>SQLAlchemy will automatically commit for us.</source>
          <target state="translated">SQLAlchemy会自动为我们提交。</target>
        </trans-unit>
        <trans-unit id="386dfe56f5a29d601f8470f615bec41a2da58492" translate="yes" xml:space="preserve">
          <source>Safely join &lt;code&gt;directory&lt;/code&gt; and zero or more untrusted &lt;code&gt;pathnames&lt;/code&gt; components.</source>
          <target state="translated">安全地加入 &lt;code&gt;directory&lt;/code&gt; 和零个或多个不受信任的 &lt;code&gt;pathnames&lt;/code&gt; 组件。</target>
        </trans-unit>
        <trans-unit id="bc92571d912b39b8b6a4730291a2fd4b1f5b8be5" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;#flask.Blueprint.url_defaults&quot;&gt;&lt;code&gt;url_defaults()&lt;/code&gt;&lt;/a&gt; but application wide.</source>
          <target state="translated">与&lt;a href=&quot;#flask.Blueprint.url_defaults&quot;&gt; &lt;code&gt;url_defaults()&lt;/code&gt; &lt;/a&gt;相同，但适用于整个应用程序。</target>
        </trans-unit>
        <trans-unit id="846ae4147630839b9d0d70107ed4a42404ba4937" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;#flask.Blueprint.url_value_preprocessor&quot;&gt;&lt;code&gt;url_value_preprocessor()&lt;/code&gt;&lt;/a&gt; but application wide.</source>
          <target state="translated">与&lt;a href=&quot;#flask.Blueprint.url_value_preprocessor&quot;&gt; &lt;code&gt;url_value_preprocessor()&lt;/code&gt; &lt;/a&gt;相同，但适用于整个应用程序。</target>
        </trans-unit>
        <trans-unit id="4c7d041175b4b1046a1ccdd337efbdad58026552" translate="yes" xml:space="preserve">
          <source>Save the &lt;code&gt;yourapplication.fcgi&lt;/code&gt; file somewhere you will find it again. It makes sense to have that in &lt;code&gt;/var/www/yourapplication&lt;/code&gt; or something similar.</source>
          <target state="translated">将 &lt;code&gt;yourapplication.fcgi&lt;/code&gt; 文件保存在可以再次找到的位置。在 &lt;code&gt;/var/www/yourapplication&lt;/code&gt; 或类似文件中包含它是很有意义的。</target>
        </trans-unit>
        <trans-unit id="b18fa6e75aaa4eb597f7dd544161cf36711aaab4" translate="yes" xml:space="preserve">
          <source>Saves the session if it needs updates. For the default implementation, check &lt;a href=&quot;#flask.Flask.open_session&quot;&gt;&lt;code&gt;open_session()&lt;/code&gt;&lt;/a&gt;. Instead of overriding this method we recommend replacing the &lt;a href=&quot;#flask.Flask.session_interface&quot;&gt;&lt;code&gt;session_interface&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果需要更新，则保存会话。对于默认实现，请检查&lt;a href=&quot;#flask.Flask.open_session&quot;&gt; &lt;code&gt;open_session()&lt;/code&gt; &lt;/a&gt;。建议不要替换&lt;a href=&quot;#flask.Flask.session_interface&quot;&gt; &lt;code&gt;session_interface&lt;/code&gt; ,&lt;/a&gt;而不是覆盖此方法。</target>
        </trans-unit>
        <trans-unit id="584f173229fdc70ad5ec9ea7552c57d69fb58f92" translate="yes" xml:space="preserve">
          <source>Say you have a specific URL that, when you sent &lt;code&gt;POST&lt;/code&gt; requests to will delete a user&amp;rsquo;s profile (say &lt;code&gt;http://example.com/user/delete&lt;/code&gt;). If an attacker now creates a page that sends a post request to that page with some JavaScript they just have to trick some users to load that page and their profiles will end up being deleted.</source>
          <target state="translated">假设您有一个特定的URL，当您向其发送 &lt;code&gt;POST&lt;/code&gt; 请求时，该URL将删除用户的个人资料（例如 &lt;code&gt;http://example.com/user/delete&lt;/code&gt; ）。如果攻击者现在创建了一个页面，该页面使用一些JavaScript向该页面发送了发布请求，则他们只需要欺骗某些用户以加载该页面，其个人资料最终将被删除。</target>
        </trans-unit>
        <trans-unit id="0092ac5220f5348a23d587a664e9a6eb6f2941ed" translate="yes" xml:space="preserve">
          <source>Scale like a pro.</source>
          <target state="translated">规模像专业。</target>
        </trans-unit>
        <trans-unit id="734e6e68dddd9faf97d685b92ff6886b890010d6" translate="yes" xml:space="preserve">
          <source>Scaling well means for example that if you double the amount of servers you get about twice the performance. Scaling bad means that if you add a new server the application won&amp;rsquo;t perform any better or would not even support a second server.</source>
          <target state="translated">良好的扩展意味着，例如，如果服务器数量增加一倍，性能将提高一倍左右。扩展不良意味着，如果添加新服务器，该应用程序将无法获得更好的性能，甚至无法支持第二台服务器。</target>
        </trans-unit>
        <trans-unit id="42c4890b51660e4b8ccb35b996f42b9815eb68a2" translate="yes" xml:space="preserve">
          <source>Screenshot of the debugger in action:</source>
          <target state="translated">调试器工作的截图。</target>
        </trans-unit>
        <trans-unit id="402cc3b6686cd294cb10dd3f5bccbebd0edd8a9b" translate="yes" xml:space="preserve">
          <source>Security Considerations</source>
          <target state="translated">安全考虑因素</target>
        </trans-unit>
        <trans-unit id="1cb1995baea297f9ee9b9fd0957af8e2b5c7b68c" translate="yes" xml:space="preserve">
          <source>Security Headers</source>
          <target state="translated">安全标题</target>
        </trans-unit>
        <trans-unit id="545dbfbfd20bd8905b13ad498089d9b5e57260f3" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#flask.testing.FlaskClient&quot;&gt;&lt;code&gt;FlaskClient&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;#flask.testing.FlaskClient&quot;&gt; &lt;code&gt;FlaskClient&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0aceb4e0d5454c525870c83ad401a5a71a412fa5" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../appcontext/index&quot;&gt;The Application Context&lt;/a&gt;.</source>
          <target state="translated">请参阅&lt;a href=&quot;../appcontext/index&quot;&gt;应用程序上下文&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="619bfd87f573476a6233acf8e7e09bd657158a7b" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../blueprints/index#blueprints&quot;&gt;Modular Applications with Blueprints&lt;/a&gt; for more information.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;../blueprints/index#blueprints&quot;&gt;带有蓝图的模块化应用程序&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4f6ec1195a4d13946f5b8765fe3809f12904a936" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../config/index#config-dev-prod&quot;&gt;Development / Production&lt;/a&gt; for an example of class-based configuration using &lt;a href=&quot;#flask.Config.from_object&quot;&gt;&lt;code&gt;from_object()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关使用&lt;a href=&quot;#flask.Config.from_object&quot;&gt; &lt;code&gt;from_object()&lt;/code&gt; &lt;/a&gt;的基于类的配置的示例，请参见&lt;a href=&quot;../config/index#config-dev-prod&quot;&gt;开发/生产&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="401730cd47293b7077f5a328dd11387ca0f3f2dc" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../errorhandling/index#error-handlers&quot;&gt;Error handlers&lt;/a&gt; for more details.</source>
          <target state="translated">有关更多详细信息，请参见&lt;a href=&quot;../errorhandling/index#error-handlers&quot;&gt;错误处理程序&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="019a70718116747837986f597b284d3d38b9a899" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../logging/index&quot;&gt;Logging&lt;/a&gt; for information on how to log exceptions, such as by emailing them to admins.</source>
          <target state="translated">请参阅&lt;a href=&quot;../logging/index&quot;&gt;日志&lt;/a&gt;以获取有关如何记录异常的信息，例如通过电子邮件将异常发送给管理员。</target>
        </trans-unit>
        <trans-unit id="b604f19afeddab33600efc5ab907de66a4b96ab6" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../patterns/flashing/index#message-flashing-pattern&quot;&gt;Message Flashing&lt;/a&gt; for examples.</source>
          <target state="translated">有关示例，请参见&lt;a href=&quot;../patterns/flashing/index#message-flashing-pattern&quot;&gt;消息闪烁&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="02ca48b561892191cad15c3075cd1b8959ea486d" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../reqcontext/index&quot;&gt;The Request Context&lt;/a&gt; for more information about how the contexts work and the full life cycle of a request.</source>
          <target state="translated">有关&lt;a href=&quot;../reqcontext/index&quot;&gt;上下文&lt;/a&gt;如何工作以及请求的整个生命周期的更多信息，请参见请求上下文。</target>
        </trans-unit>
        <trans-unit id="ec1facab84177d5279a7238ae00520093740a10a" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../reqcontext/index&quot;&gt;The Request Context&lt;/a&gt;.</source>
          <target state="translated">请参阅&lt;a href=&quot;../reqcontext/index&quot;&gt;请求上下文&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2d8f1972d051f5e158dcd35c6b1372abbdfd4763" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../testing/index#testing-cli&quot;&gt;Testing CLI Commands&lt;/a&gt; for an overview of how to test your custom commands.</source>
          <target state="translated">有关如何测试自定义命令的概述，请参见&lt;a href=&quot;../testing/index#testing-cli&quot;&gt;测试CLI&lt;/a&gt;命令。</target>
        </trans-unit>
        <trans-unit id="e06f8c98acd8762bb5f13aaa3186af67f6a2dce1" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/wrappers/#werkzeug.wrappers.BaseResponse.max_cookie_size&quot;&gt;&lt;code&gt;max_cookie_size&lt;/code&gt;&lt;/a&gt; in Werkzeug&amp;rsquo;s docs.</source>
          <target state="translated">请参阅Werkzeug的文档中的&lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/wrappers/#werkzeug.wrappers.BaseResponse.max_cookie_size&quot;&gt; &lt;code&gt;max_cookie_size&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2d8243a2c0e464492c9d563c4f92c56ae3421bcc" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">另见</target>
        </trans-unit>
        <trans-unit id="beccf48f4d860035b107e920cc5e5092ce8ca2e6" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.MultiDict&quot;&gt;&lt;code&gt;MultiDict&lt;/code&gt;&lt;/a&gt; / &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.FileStorage&quot;&gt;&lt;code&gt;FileStorage&lt;/code&gt;&lt;/a&gt; documentation for more details about the used data structure.</source>
          <target state="translated">有关使用的数据结构的更多详细信息，请参见&lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.MultiDict&quot;&gt; &lt;code&gt;MultiDict&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.FileStorage&quot;&gt; &lt;code&gt;FileStorage&lt;/code&gt; &lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="a3ec675500772f10a8c2508ecd215e8ac678e9ef" translate="yes" xml:space="preserve">
          <source>Seeing more information about the request, such as the IP address, may help debugging some errors. You can subclass &lt;a href=&quot;https://docs.python.org/3/library/logging.html#logging.Formatter&quot;&gt;&lt;code&gt;logging.Formatter&lt;/code&gt;&lt;/a&gt; to inject your own fields that can be used in messages. You can change the formatter for Flask&amp;rsquo;s default handler, the mail handler defined above, or any other handler.</source>
          <target state="translated">查看有关请求的更多信息（例如IP地址）可能有助于调试一些错误。您可以将&lt;a href=&quot;https://docs.python.org/3/library/logging.html#logging.Formatter&quot;&gt; &lt;code&gt;logging.Formatter&lt;/code&gt; &lt;/a&gt;子类化以注入您自己的字段，这些字段可以在消息中使用。您可以更改Flask的默认处理程序，上面定义的邮件处理程序或任何其他处理程序的格式化程序。</target>
        </trans-unit>
        <trans-unit id="fb039d334b93ca0c3ffc6cce779d5732d43c95d8" translate="yes" xml:space="preserve">
          <source>Select &amp;ldquo;UTF-8 without BOM&amp;rdquo; as encoding</source>
          <target state="translated">选择&amp;ldquo;不带BOM的UTF-8&amp;rdquo;作为编码</target>
        </trans-unit>
        <trans-unit id="ac5aecb76822ebc080aad976860d90f2bc596ccd" translate="yes" xml:space="preserve">
          <source>Select &lt;em&gt;Module name&lt;/em&gt; from the dropdown (&lt;strong&gt;A&lt;/strong&gt;) then input &lt;code&gt;flask&lt;/code&gt;.</source>
          <target state="translated">从下拉菜单（&lt;strong&gt;A&lt;/strong&gt;）中选择&lt;em&gt;模块名称&lt;/em&gt;，然后输入 &lt;code&gt;flask&lt;/code&gt; 。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="601b6ca538178dea468ddf84324efd3422f09334" translate="yes" xml:space="preserve">
          <source>Select the &amp;ldquo;New Document/Default Directory&amp;rdquo; tab</source>
          <target state="translated">选择&amp;ldquo;新文档/默认目录&amp;rdquo;选项卡</target>
        </trans-unit>
        <trans-unit id="65c73e72195d0079ee5064ed9acf50733eb7958f" translate="yes" xml:space="preserve">
          <source>Self-hosted options</source>
          <target state="translated">自我托管选项</target>
        </trans-unit>
        <trans-unit id="aef8544650a7f314758e77079fda591222bca156" translate="yes" xml:space="preserve">
          <source>Semantic elements like &lt;code&gt;&amp;lt;article&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;header&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;nav&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;time&amp;gt;&lt;/code&gt; that make content easier to understand.</source>
          <target state="translated">诸如 &lt;code&gt;&amp;lt;article&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;header&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;nav&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;time&amp;gt;&lt;/code&gt; 之类的语义元素使内容更易于理解。</target>
        </trans-unit>
        <trans-unit id="9451e11f7df1bab12919a1293236189ac072ae82" translate="yes" xml:space="preserve">
          <source>Send a file from a given directory with &lt;a href=&quot;#flask.send_file&quot;&gt;&lt;code&gt;send_file()&lt;/code&gt;&lt;/a&gt;. This is a secure way to quickly expose static files from an upload folder or something similar.</source>
          <target state="translated">使用&lt;a href=&quot;#flask.send_file&quot;&gt; &lt;code&gt;send_file()&lt;/code&gt; &lt;/a&gt;从给定目录发送文件。这是从公开文件夹或类似文件中快速公开静态文件的安全方法。</target>
        </trans-unit>
        <trans-unit id="1823f9c020c2ec85d315d506b2e71f75cab7349c" translate="yes" xml:space="preserve">
          <source>Sending Signals</source>
          <target state="translated">发送信号</target>
        </trans-unit>
        <trans-unit id="27bcaa8e0aa73f3f4de8b59d41e444849888dca3" translate="yes" xml:space="preserve">
          <source>Sending error mails, even if just for critical ones, can become overwhelming if enough users are hitting the error and log files are typically never looked at. This is why we recommend using &lt;a href=&quot;https://sentry.io/&quot;&gt;Sentry&lt;/a&gt; for dealing with application errors. It&amp;rsquo;s available as an Open Source project &lt;a href=&quot;https://github.com/getsentry/sentry&quot;&gt;on GitHub&lt;/a&gt; and is also available as a &lt;a href=&quot;https://sentry.io/signup/&quot;&gt;hosted version&lt;/a&gt; which you can try for free. Sentry aggregates duplicate errors, captures the full stack trace and local variables for debugging, and sends you mails based on new errors or frequency thresholds.</source>
          <target state="translated">如果有足够多的用户遇到该错误，并且通常从不查看日志文件，那么即使只是发送关键邮件，也可能发送大量错误邮件。这就是为什么我们建议使用&lt;a href=&quot;https://sentry.io/&quot;&gt;Sentry&lt;/a&gt;处理应用程序错误的原因。它可以作为&lt;a href=&quot;https://github.com/getsentry/sentry&quot;&gt;GitHub上的&lt;/a&gt;开源项目获得，也可以作为&lt;a href=&quot;https://sentry.io/signup/&quot;&gt;托管版本获得&lt;/a&gt;，您可以免费试用。Sentry会汇总重复的错误，捕获完整的堆栈跟踪信息和本地变量以进行调试，然后根据新的错误或频率阈值向您发送邮件。</target>
        </trans-unit>
        <trans-unit id="788f80ed33ebaedf90d1f0212f0c69622714700d" translate="yes" xml:space="preserve">
          <source>Sending files and Performance</source>
          <target state="translated">发送文件和性能</target>
        </trans-unit>
        <trans-unit id="f1caa9b4f06070b148565b595fe5cd543659df9d" translate="yes" xml:space="preserve">
          <source>Sends the contents of a file to the client. This will use the most efficient method available and configured. By default it will try to use the WSGI server&amp;rsquo;s file_wrapper support. Alternatively you can set the application&amp;rsquo;s &lt;a href=&quot;#flask.Flask.use_x_sendfile&quot;&gt;&lt;code&gt;use_x_sendfile&lt;/code&gt;&lt;/a&gt; attribute to &lt;code&gt;True&lt;/code&gt; to directly emit an &lt;code&gt;X-Sendfile&lt;/code&gt; header. This however requires support of the underlying webserver for &lt;code&gt;X-Sendfile&lt;/code&gt;.</source>
          <target state="translated">将文件的内容发送到客户端。这将使用可用和配置的最有效的方法。默认情况下，它将尝试使用WSGI服务器的file_wrapper支持。另外，您可以将应用程序的&lt;a href=&quot;#flask.Flask.use_x_sendfile&quot;&gt; &lt;code&gt;use_x_sendfile&lt;/code&gt; &lt;/a&gt;属性设置为 &lt;code&gt;True&lt;/code&gt; ,以直接发出 &lt;code&gt;X-Sendfile&lt;/code&gt; 标头。但是，这需要 &lt;code&gt;X-Sendfile&lt;/code&gt; 的基础Web服务器的支持。</target>
        </trans-unit>
        <trans-unit id="04dec62d1acbb56bc207d3fe2cc4ca7ee763d728" translate="yes" xml:space="preserve">
          <source>Sent with a preflight request to indicate which headers will be sent with the cross origin request. Set &lt;code&gt;access_control_allow_headers&lt;/code&gt; on the response to indicate which headers are allowed.</source>
          <target state="translated">与预检请求一起发送，以指示将与交叉原点请求一起发送的标头。在响应上设置 &lt;code&gt;access_control_allow_headers&lt;/code&gt; 以指示允许哪些标头。</target>
        </trans-unit>
        <trans-unit id="5d346df48e16de0f83637ff063bf3a9c8e6ca4c8" translate="yes" xml:space="preserve">
          <source>Sent with a preflight request to indicate which method will be used for the cross origin request. Set &lt;code&gt;access_control_allow_methods&lt;/code&gt; on the response to indicate which methods are allowed.</source>
          <target state="translated">与预检请求一起发送，以指示将哪种方法用于跨源请求。在响应上设置 &lt;code&gt;access_control_allow_methods&lt;/code&gt; ，以指示允许使用哪些方法。</target>
        </trans-unit>
        <trans-unit id="81dbdb5a6614b8a3348d47b5325be789cfb8abb1" translate="yes" xml:space="preserve">
          <source>Sentry also supports catching errors from your worker queue (RQ, Celery) in a similar fashion. See the &lt;a href=&quot;https://docs.sentry.io/platforms/python/&quot;&gt;Python SDK docs&lt;/a&gt; for more information.</source>
          <target state="translated">Sentry还以类似的方式支持从您的工作人员队列（RQ，Celery）中捕获错误。有关更多信息，请参见&lt;a href=&quot;https://docs.sentry.io/platforms/python/&quot;&gt;Python SDK文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0120a7cc2b0e79af859af0a915e1d9482287f80a" translate="yes" xml:space="preserve">
          <source>Serialize &lt;code&gt;obj&lt;/code&gt; to a JSON-formatted string. If there is an app context pushed, use the current app&amp;rsquo;s configured encoder (&lt;a href=&quot;#flask.Flask.json_encoder&quot;&gt;&lt;code&gt;json_encoder&lt;/code&gt;&lt;/a&gt;), or fall back to the default &lt;a href=&quot;#flask.json.JSONEncoder&quot;&gt;&lt;code&gt;JSONEncoder&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">将 &lt;code&gt;obj&lt;/code&gt; 序列化为JSON格式的字符串。如果推送了应用程序上下文，请使用当前应用程序配置的编码器（&lt;a href=&quot;#flask.Flask.json_encoder&quot;&gt; &lt;code&gt;json_encoder&lt;/code&gt; &lt;/a&gt;），或使用默认的&lt;a href=&quot;#flask.json.JSONEncoder&quot;&gt; &lt;code&gt;JSONEncoder&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2242817cb2f6b94ccd803e6caf5e836a050c6dd9" translate="yes" xml:space="preserve">
          <source>Serialize objects to ASCII-encoded JSON. If this is disabled, the JSON will be returned as a Unicode string, or encoded as &lt;code&gt;UTF-8&lt;/code&gt; by &lt;code&gt;jsonify&lt;/code&gt;. This has security implications when rendering the JSON into JavaScript in templates, and should typically remain enabled.</source>
          <target state="translated">将对象序列化为ASCII编码的JSON。如果禁用此选项，则JSON将作为Unicode字符串返回，或由 &lt;code&gt;jsonify&lt;/code&gt; 编码为 &lt;code&gt;UTF-8&lt;/code&gt; 。将JSON渲染到模板中的JavaScript中时，这具有安全性，通常应保持启用状态。</target>
        </trans-unit>
        <trans-unit id="1e16319a7f42b5bcbd2c341a21db8320a3aeb1c4" translate="yes" xml:space="preserve">
          <source>Serializer that uses a tag system to compactly represent objects that are not JSON types. Passed as the intermediate serializer to &lt;code&gt;itsdangerous.Serializer&lt;/code&gt;.</source>
          <target state="translated">使用标签系统的序列化程序紧凑地表示非JSON类型的对象。作为中间的序列化器传递给它的 &lt;code&gt;itsdangerous.Serializer&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3db10d807fcb34bf91aa208e73318fb2a9472d8b" translate="yes" xml:space="preserve">
          <source>Server Setup</source>
          <target state="translated">服务器设置</target>
        </trans-unit>
        <trans-unit id="12dee3fa0dd4870f9b1370288f459903535bcd83" translate="yes" xml:space="preserve">
          <source>Session Interface</source>
          <target state="translated">会话接口</target>
        </trans-unit>
        <trans-unit id="e11e37a9253b34ff1c7224447e143fabca1be9fd" translate="yes" xml:space="preserve">
          <source>Sessions</source>
          <target state="translated">Sessions</target>
        </trans-unit>
        <trans-unit id="79dbcb97a8ced78bfbfbc2c393794437a7d34227" translate="yes" xml:space="preserve">
          <source>Set yourapplication.fcgi:</source>
          <target state="translated">设置 yourapplication.fcgi:</target>
        </trans-unit>
        <trans-unit id="f577866e8b3e8692c9d1f8b6535a1b7989a6cafe" translate="yes" xml:space="preserve">
          <source>Set-Cookie options</source>
          <target state="translated">设置-Cookie选项</target>
        </trans-unit>
        <trans-unit id="f43b0d5cda683750fe658098c735682abc3dc2dd" translate="yes" xml:space="preserve">
          <source>Sets a cookie. The parameters are the same as in the cookie &lt;code&gt;Morsel&lt;/code&gt; object in the Python standard library but it accepts unicode data, too.</source>
          <target state="translated">设置一个cookie。参数与Python标准库中的cookie &lt;code&gt;Morsel&lt;/code&gt; 对象中的参数相同，但它也接受unicode数据。</target>
        </trans-unit>
        <trans-unit id="0984046b50cf92a8bfefb5930c66dd255723049e" translate="yes" xml:space="preserve">
          <source>Sets the current working directory to &lt;code&gt;src&lt;/code&gt; then imports &lt;code&gt;hello&lt;/code&gt;.</source>
          <target state="translated">将当前工作目录设置为 &lt;code&gt;src&lt;/code&gt; ,然后导入 &lt;code&gt;hello&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e32926d79a3be43092c877ede3cd3a3dc699e862" translate="yes" xml:space="preserve">
          <source>Setting &lt;code id=&quot;index-1&quot;&gt;FLASK_ENV&lt;/code&gt; to &lt;code&gt;development&lt;/code&gt; will enable debug mode. &lt;code&gt;flask run&lt;/code&gt; will use the interactive debugger and reloader by default in debug mode. To control this separately from the environment, use the &lt;code id=&quot;index-2&quot;&gt;FLASK_DEBUG&lt;/code&gt; flag.</source>
          <target state="translated">将 &lt;code id=&quot;index-1&quot;&gt;FLASK_ENV&lt;/code&gt; 设置为 &lt;code&gt;development&lt;/code&gt; 将启用调试模式。在调试模式下，默认情况下， &lt;code&gt;flask run&lt;/code&gt; 将使用交互式调试器和重新加载器。若要与环境分开控制，请使用 &lt;code id=&quot;index-2&quot;&gt;FLASK_DEBUG&lt;/code&gt; 标志。</target>
        </trans-unit>
        <trans-unit id="f5d0c4a9c57ad4c2520645b3ec17c6fb819a02b3" translate="yes" xml:space="preserve">
          <source>Setting Command Options</source>
          <target state="translated">设置命令选项</target>
        </trans-unit>
        <trans-unit id="8515b46d7f2bf41ea8a4ee9e0b39eb6f957974b7" translate="yes" xml:space="preserve">
          <source>Setting this disables or force-enables the automatic options handling.</source>
          <target state="translated">设置此选项可以禁用或强制启用自动选项处理功能。</target>
        </trans-unit>
        <trans-unit id="6b096ca15f2e983e71630130f159fd070d2f4844" translate="yes" xml:space="preserve">
          <source>Shows a single user</source>
          <target state="translated">显示单个用户</target>
        </trans-unit>
        <trans-unit id="2346a18ea3002ff04eca3a130c7f40e65c56f0c9" translate="yes" xml:space="preserve">
          <source>Signals</source>
          <target state="translated">Signals</target>
        </trans-unit>
        <trans-unit id="40abe016bbaaa3b3e5930e54755f1ef4d4b4df15" translate="yes" xml:space="preserve">
          <source>Signals and Flask&amp;rsquo;s Request Context</source>
          <target state="translated">信号和烧瓶的请求上下文</target>
        </trans-unit>
        <trans-unit id="3dda279a6077a8b7a86500da7b91ea72b13dea92" translate="yes" xml:space="preserve">
          <source>Signals fully support &lt;a href=&quot;../reqcontext/index#request-context&quot;&gt;The Request Context&lt;/a&gt; when receiving signals. Context-local variables are consistently available between &lt;a href=&quot;../api/index#flask.request_started&quot;&gt;&lt;code&gt;request_started&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../api/index#flask.request_finished&quot;&gt;&lt;code&gt;request_finished&lt;/code&gt;&lt;/a&gt;, so you can rely on &lt;a href=&quot;../api/index#flask.g&quot;&gt;&lt;code&gt;flask.g&lt;/code&gt;&lt;/a&gt; and others as needed. Note the limitations described in &lt;a href=&quot;#signals-sending&quot;&gt;Sending Signals&lt;/a&gt; and the &lt;a href=&quot;../api/index#flask.request_tearing_down&quot;&gt;&lt;code&gt;request_tearing_down&lt;/code&gt;&lt;/a&gt; signal.</source>
          <target state="translated">接收信号时，信号完全支持&lt;a href=&quot;../reqcontext/index#request-context&quot;&gt;请求上下文&lt;/a&gt;。在&lt;a href=&quot;../api/index#flask.request_started&quot;&gt; &lt;code&gt;request_started&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../api/index#flask.request_finished&quot;&gt; &lt;code&gt;request_finished&lt;/code&gt; &lt;/a&gt;之间始终可以使用上下文局部变量，因此您可以根据需要依赖&lt;a href=&quot;../api/index#flask.g&quot;&gt; &lt;code&gt;flask.g&lt;/code&gt; &lt;/a&gt;和其他变量。请注意&lt;a href=&quot;#signals-sending&quot;&gt;发送信号&lt;/a&gt;和&lt;a href=&quot;../api/index#flask.request_tearing_down&quot;&gt; &lt;code&gt;request_tearing_down&lt;/code&gt; &lt;/a&gt;信号中描述的限制。</target>
        </trans-unit>
        <trans-unit id="8a688333b08ebbd8347b8c059cf8db875c141414" translate="yes" xml:space="preserve">
          <source>Simple Exception Class</source>
          <target state="translated">简单异常类</target>
        </trans-unit>
        <trans-unit id="a89bb18f992c27f173118c338bce4423dd55f824" translate="yes" xml:space="preserve">
          <source>Simple Flashing</source>
          <target state="translated">简单闪光</target>
        </trans-unit>
        <trans-unit id="b7c4ee84c7494dc0b5a61967837078512ea0e072" translate="yes" xml:space="preserve">
          <source>Simple Packages</source>
          <target state="translated">简单套餐</target>
        </trans-unit>
        <trans-unit id="212ac3b94b3d461861179a12c3944241460388de" translate="yes" xml:space="preserve">
          <source>Since a request context typically also manages an application context it would also be called when you pop a request context.</source>
          <target state="translated">由于请求上下文通常也管理一个应用上下文,所以当你弹出一个请求上下文时,它也会被调用。</target>
        </trans-unit>
        <trans-unit id="eb181e1b174c980a6352184cf41aa587cd5c93e7" translate="yes" xml:space="preserve">
          <source>Since nginx and others do not load FastCGI apps, you have to do it by yourself. &lt;a href=&quot;http://supervisord.org/configuration.html#fcgi-program-x-section-settings&quot;&gt;Supervisor can manage FastCGI processes.&lt;/a&gt; You can look around for other FastCGI process managers or write a script to run your &lt;code&gt;.fcgi&lt;/code&gt; file at boot, e.g. using a SysV &lt;code&gt;init.d&lt;/code&gt; script. For a temporary solution, you can always run the &lt;code&gt;.fcgi&lt;/code&gt; script inside GNU screen. See &lt;code&gt;man screen&lt;/code&gt; for details, and note that this is a manual solution which does not persist across system restart:</source>
          <target state="translated">由于nginx和其他应用程序无法加载FastCGI应用程序，因此您必须自己完成操作。&lt;a href=&quot;http://supervisord.org/configuration.html#fcgi-program-x-section-settings&quot;&gt;主管可以管理FastCGI进程。&lt;/a&gt;您可以四处寻找其他FastCGI流程管理器，也可以编写脚本以在启动时运行 &lt;code&gt;.fcgi&lt;/code&gt; 文件，例如，使用SysV &lt;code&gt;init.d&lt;/code&gt; 脚本。对于临时解决方案，您始终可以在GNU屏幕上运行 &lt;code&gt;.fcgi&lt;/code&gt; 脚本。有关详细信息，请参见手动 &lt;code&gt;man screen&lt;/code&gt; ，并且请注意，这是一个手动解决方案，在系统重启后不会持续存在：</target>
        </trans-unit>
        <trans-unit id="7835c4dc7046cd71edb74135df4279e2bf33db33" translate="yes" xml:space="preserve">
          <source>Since the config object provided loading of configuration files from relative filenames we made it possible to change the loading via filenames to be relative to the instance path if wanted. The behavior of relative paths in config files can be flipped between &amp;ldquo;relative to the application root&amp;rdquo; (the default) to &amp;ldquo;relative to instance folder&amp;rdquo; via the &lt;code&gt;instance_relative_config&lt;/code&gt; switch to the application constructor:</source>
          <target state="translated">由于config对象提供了从相对文件名加载配置文件的功能，因此我们可以通过文件名将加载更改为相对于实例路径（如果需要）。配置文件中相对路径的行为可以在&amp;ldquo;相对于应用程序根目录&amp;rdquo;（默认）与&amp;ldquo;相对于实例文件夹&amp;rdquo;之间切换，方法是通过 &lt;code&gt;instance_relative_config&lt;/code&gt; 切换到应用程序构造函数：</target>
        </trans-unit>
        <trans-unit id="1426d43814172514e7c7650ba98a72feb871cea8" translate="yes" xml:space="preserve">
          <source>Since the view class itself is not the view function that is added to the routing system it does not make much sense to decorate the class itself. Instead you either have to decorate the return value of &lt;a href=&quot;../api/index#flask.views.View.as_view&quot;&gt;&lt;code&gt;as_view()&lt;/code&gt;&lt;/a&gt; by hand:</source>
          <target state="translated">由于视图类本身不是添加到路由系统中的视图函数，因此装饰类本身没有多大意义。相反，您必须手工修饰&lt;a href=&quot;../api/index#flask.views.View.as_view&quot;&gt; &lt;code&gt;as_view()&lt;/code&gt; &lt;/a&gt;的返回值：</target>
        </trans-unit>
        <trans-unit id="8444db3cd3bd6f13a593947078bb89c82130f9d7" translate="yes" xml:space="preserve">
          <source>Single argument: Passed straight through to &lt;a href=&quot;#flask.json.dumps&quot;&gt;&lt;code&gt;dumps()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">单个参数：直接传递给&lt;a href=&quot;#flask.json.dumps&quot;&gt; &lt;code&gt;dumps()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a4853f03097a329eb5da40b859c0545e90fac2ca" translate="yes" xml:space="preserve">
          <source>Single-Page Applications</source>
          <target state="translated">单页应用</target>
        </trans-unit>
        <trans-unit id="6b45129557901ff80bc77e26291f9883cba668a7" translate="yes" xml:space="preserve">
          <source>So a common pattern is this:</source>
          <target state="translated">所以常见的模式是这样的。</target>
        </trans-unit>
        <trans-unit id="b43197bf3139bd685cbe5ac8be4ea00759c638f0" translate="yes" xml:space="preserve">
          <source>So far we only split up the views and the routing, but the module is still loaded upfront. The trick is to actually load the view function as needed. This can be accomplished with a helper class that behaves just like a function but internally imports the real function on first use:</source>
          <target state="translated">到目前为止,我们只拆分了视图和路由,但前期还是加载了模块。诀窍是根据需要实际加载视图函数。这可以通过一个帮助类来实现,它的行为就像一个函数,但在第一次使用时内部导入真正的函数。</target>
        </trans-unit>
        <trans-unit id="f2037d6656daabf56f05dab9948dd28e061f1b34" translate="yes" xml:space="preserve">
          <source>So first we need a couple of imports. Most should be straightforward, the &lt;code&gt;werkzeug.secure_filename()&lt;/code&gt; is explained a little bit later. The &lt;code&gt;UPLOAD_FOLDER&lt;/code&gt; is where we will store the uploaded files and the &lt;code&gt;ALLOWED_EXTENSIONS&lt;/code&gt; is the set of allowed file extensions.</source>
          <target state="translated">所以首先我们需要几个进口。大多数应该很简单， &lt;code&gt;werkzeug.secure_filename()&lt;/code&gt; 会解释werkzeug.secure_filename（）。该 &lt;code&gt;UPLOAD_FOLDER&lt;/code&gt; 是我们将存储上传的文件和 &lt;code&gt;ALLOWED_EXTENSIONS&lt;/code&gt; 是一组允许的文件扩展名。</target>
        </trans-unit>
        <trans-unit id="40fe8eb2225a85246e9f7fc3dfa614ae5dff30b4" translate="yes" xml:space="preserve">
          <source>So for starters instead of doing:</source>
          <target state="translated">所以对于初学者来说,而不是做。</target>
        </trans-unit>
        <trans-unit id="7fa8bc304d494afc5206c6e07a0117df1bde1721" translate="yes" xml:space="preserve">
          <source>So here is a full example:</source>
          <target state="translated">所以这里有一个完整的例子。</target>
        </trans-unit>
        <trans-unit id="4dcce9e821c43d37f84726d79600d7e96a41316a" translate="yes" xml:space="preserve">
          <source>So how do we hook this up with the routing system? By adding two rules and explicitly mentioning the methods for each:</source>
          <target state="translated">那么我们如何将其与路由系统挂钩呢?通过添加两个规则,并明确提到每个规则的方法。</target>
        </trans-unit>
        <trans-unit id="1ad80911f520cb2748221d1af1e963f360435acf" translate="yes" xml:space="preserve">
          <source>So how do you register that blueprint? Like this:</source>
          <target state="translated">那么如何注册这个蓝图呢?像这样</target>
        </trans-unit>
        <trans-unit id="a9d392e3d4df97270738374de02cf82d3acfaf77" translate="yes" xml:space="preserve">
          <source>So how exactly does Flask handle uploads? Well it will store them in the webserver&amp;rsquo;s memory if the files are reasonable small otherwise in a temporary location (as returned by &lt;a href=&quot;https://docs.python.org/3/library/tempfile.html#tempfile.gettempdir&quot;&gt;&lt;code&gt;tempfile.gettempdir()&lt;/code&gt;&lt;/a&gt;). But how do you specify the maximum file size after which an upload is aborted? By default Flask will happily accept file uploads to an unlimited amount of memory, but you can limit that by setting the &lt;code&gt;MAX_CONTENT_LENGTH&lt;/code&gt; config key:</source>
          <target state="translated">那么Flask如何精确地处理上传内容？好吧，如果文件足够小，它将把它们存储在Web服务器的内存中，否则将它们存储在一个临时位置（由&lt;a href=&quot;https://docs.python.org/3/library/tempfile.html#tempfile.gettempdir&quot;&gt; &lt;code&gt;tempfile.gettempdir()&lt;/code&gt; &lt;/a&gt;返回）。但是，您如何指定最大文件大小，之后上传将被中止？默认情况下，Flask将愉快地接受文件上传到无限量的内存，但是您可以通过设置 &lt;code&gt;MAX_CONTENT_LENGTH&lt;/code&gt; 配置键来限制它：</target>
        </trans-unit>
        <trans-unit id="1cc67550df0757ec0e8477748b6b74a55f6ded2e" translate="yes" xml:space="preserve">
          <source>So how would you go about doing that with the &lt;a href=&quot;../api/index#flask.views.MethodView&quot;&gt;&lt;code&gt;MethodView&lt;/code&gt;&lt;/a&gt;? The trick is to take advantage of the fact that you can provide multiple rules to the same view.</source>
          <target state="translated">那么，您将如何使用&lt;a href=&quot;../api/index#flask.views.MethodView&quot;&gt; &lt;code&gt;MethodView&lt;/code&gt; 进行操作&lt;/a&gt;呢？诀窍是利用可以为同一视图提供多个规则的事实。</target>
        </trans-unit>
        <trans-unit id="c4af56f2d7f30b8b96be0e62104b21919b5ba232" translate="yes" xml:space="preserve">
          <source>So how would you then actually implement that?</source>
          <target state="translated">那么,你又会如何实际执行呢?</target>
        </trans-unit>
        <trans-unit id="03060d815b7246849d8c582a07b838679e414443" translate="yes" xml:space="preserve">
          <source>So if you have a blueprint in the folder &lt;code&gt;yourapplication/admin&lt;/code&gt; and you want to render the template &lt;code&gt;'admin/index.html'&lt;/code&gt; and you have provided &lt;code&gt;templates&lt;/code&gt; as a &lt;code&gt;template_folder&lt;/code&gt; you will have to create a file like this: &lt;code&gt;yourapplication/admin/templates/admin/index.html&lt;/code&gt;. The reason for the extra &lt;code&gt;admin&lt;/code&gt; folder is to avoid getting our template overridden by a template named &lt;code&gt;index.html&lt;/code&gt; in the actual application template folder.</source>
          <target state="translated">因此，如果您的 &lt;code&gt;yourapplication/admin&lt;/code&gt; 文件夹中有一个蓝图，并且您想呈现模板 &lt;code&gt;'admin/index.html'&lt;/code&gt; ,并且已将 &lt;code&gt;templates&lt;/code&gt; 作为 &lt;code&gt;template_folder&lt;/code&gt; 提供，则必须创建一个如下文件： &lt;code&gt;yourapplication/admin/templates/admin/index.html&lt;/code&gt; 。使用额外的 &lt;code&gt;admin&lt;/code&gt; 文件夹的原因是为了避免在实际的应用程序模板文件夹中将我们的模板替换为名为 &lt;code&gt;index.html&lt;/code&gt; 的模板。</target>
        </trans-unit>
        <trans-unit id="a34cb5e0b76e35634a69c88d6407f3a46e8be07a" translate="yes" xml:space="preserve">
          <source>So it&amp;rsquo;s important what you provide there. If you are using a single module, &lt;code&gt;__name__&lt;/code&gt; is always the correct value. If you however are using a package, it&amp;rsquo;s usually recommended to hardcode the name of your package there.</source>
          <target state="translated">因此，重要的是您在这里提供什么。如果使用单个模块，则 &lt;code&gt;__name__&lt;/code&gt; 始终是正确的值。但是，如果您使用的是软件包，通常建议在此处对软件包的名称进行硬编码。</target>
        </trans-unit>
        <trans-unit id="524760df747c08fca0b7517012a5898226bc1164" translate="yes" xml:space="preserve">
          <source>So let&amp;rsquo;s implement such a decorator. A decorator is a function that wraps and replaces another function. Since the original function is replaced, you need to remember to copy the original function&amp;rsquo;s information to the new function. Use &lt;a href=&quot;https://docs.python.org/3/library/functools.html#functools.wraps&quot;&gt;&lt;code&gt;functools.wraps()&lt;/code&gt;&lt;/a&gt; to handle this for you.</source>
          <target state="translated">因此，让我们实现这样的装饰器。装饰器是一个包装和替换另一个函数的函数。由于原始功能已被替换，因此您需要记住将原始功能的信息复制到新功能。使用&lt;a href=&quot;https://docs.python.org/3/library/functools.html#functools.wraps&quot;&gt; &lt;code&gt;functools.wraps()&lt;/code&gt; &lt;/a&gt;为您处理此问题。</target>
        </trans-unit>
        <trans-unit id="929e48d0c77810461627bf381df37bd1fd20bade" translate="yes" xml:space="preserve">
          <source>So now the question is, where do the &lt;code&gt;application.wsgi&lt;/code&gt; and &lt;code&gt;application.cfg&lt;/code&gt; files come from?</source>
          <target state="translated">所以现在的问题是， &lt;code&gt;application.wsgi&lt;/code&gt; 和 &lt;code&gt;application.cfg&lt;/code&gt; 文件从哪里来？</target>
        </trans-unit>
        <trans-unit id="13349c6741934df240479cfd27285825ac553fb8" translate="yes" xml:space="preserve">
          <source>So the rule of thumb: if you are not dealing with binary data, work with Unicode. What does working with Unicode in Python 2.x mean?</source>
          <target state="translated">所以经验法则是:如果您不处理二进制数据,就使用 Unicode。在Python 2.x中使用Unicode意味着什么?</target>
        </trans-unit>
        <trans-unit id="4c3f1a91d7c90c96c494a2ddf7190a40bd1adfb6" translate="yes" xml:space="preserve">
          <source>So what did that code do?</source>
          <target state="translated">那么这段代码是怎么做的呢?</target>
        </trans-unit>
        <trans-unit id="fcf0288e7d833db5599ba838e081bbe3a02463a1" translate="yes" xml:space="preserve">
          <source>So what does that &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/utils/#werkzeug.utils.secure_filename&quot;&gt;&lt;code&gt;secure_filename()&lt;/code&gt;&lt;/a&gt; function actually do? Now the problem is that there is that principle called &amp;ldquo;never trust user input&amp;rdquo;. This is also true for the filename of an uploaded file. All submitted form data can be forged, and filenames can be dangerous. For the moment just remember: always use that function to secure a filename before storing it directly on the filesystem.</source>
          <target state="translated">那么那个&lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/utils/#werkzeug.utils.secure_filename&quot;&gt; &lt;code&gt;secure_filename()&lt;/code&gt; &lt;/a&gt;函数实际上是做什么的呢？现在的问题是，存在称为&amp;ldquo;永不信任用户输入&amp;rdquo;的原则。对于上载文件的文件名也是如此。可以伪造所有提交的表单数据，并且文件名可能很危险。目前，请记住：在直接将文件名存储在文件系统上之前，请始终使用该函数来保护文件名。</target>
        </trans-unit>
        <trans-unit id="d42fbde643973850bc2968b0977850adf2d3d68c" translate="yes" xml:space="preserve">
          <source>So what does this mean to you?</source>
          <target state="translated">那么,这对你意味着什么呢?</target>
        </trans-unit>
        <trans-unit id="8716c5987c2c64db244af078eb1e1fff6ebb3be9" translate="yes" xml:space="preserve">
          <source>So what does this mean to you? Basically you can completely ignore that this is the case unless you are doing something like unit testing. You will notice that code which depends on a request object will suddenly break because there is no request object. The solution is creating a request object yourself and binding it to the context. The easiest solution for unit testing is to use the &lt;a href=&quot;../api/index#flask.Flask.test_request_context&quot;&gt;&lt;code&gt;test_request_context()&lt;/code&gt;&lt;/a&gt; context manager. In combination with the &lt;code&gt;with&lt;/code&gt; statement it will bind a test request so that you can interact with it. Here is an example:</source>
          <target state="translated">那么，这对您意味着什么呢？基本上，您可以完全忽略这种情况，除非您正在执行单元测试之类的工作。您会注意到，依赖于请求对象的代码会突然中断，因为没有请求对象。解决方案是自己创建一个请求对象，并将其绑定到上下文。单元测试最简单的解决方案是使用&lt;a href=&quot;../api/index#flask.Flask.test_request_context&quot;&gt; &lt;code&gt;test_request_context()&lt;/code&gt; &lt;/a&gt;上下文管理器。与 &lt;code&gt;with&lt;/code&gt; 语句结合使用，它将绑定测试请求，以便您可以与之交互。这是一个例子：</target>
        </trans-unit>
        <trans-unit id="b890cc2280b24c1cdcb48d72d1266b3d612f5266" translate="yes" xml:space="preserve">
          <source>So why would you want to do this?</source>
          <target state="translated">那你为什么要这样做呢?</target>
        </trans-unit>
        <trans-unit id="6fbe1a4fc2c068ea0e80e5cef69999a6ef132a5b" translate="yes" xml:space="preserve">
          <source>So you&amp;rsquo;re interested in what that &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/utils/#werkzeug.utils.secure_filename&quot;&gt;&lt;code&gt;secure_filename()&lt;/code&gt;&lt;/a&gt; function does and what the problem is if you&amp;rsquo;re not using it? So just imagine someone would send the following information as &lt;code&gt;filename&lt;/code&gt; to your application:</source>
          <target state="translated">因此，您对&lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/utils/#werkzeug.utils.secure_filename&quot;&gt; &lt;code&gt;secure_filename()&lt;/code&gt; &lt;/a&gt;函数的作用以及是否不使用它会产生什么问题感兴趣？因此，假设有人将以下信息作为 &lt;code&gt;filename&lt;/code&gt; 发送到您的应用程序：</target>
        </trans-unit>
        <trans-unit id="0753e93dd262534f3c8cfd63856bfebf961611af" translate="yes" xml:space="preserve">
          <source>Some HTTP proxies do not support arbitrary HTTP methods or newer HTTP methods (such as PATCH). In that case it&amp;rsquo;s possible to &amp;ldquo;proxy&amp;rdquo; HTTP methods through another HTTP method in total violation of the protocol.</source>
          <target state="translated">某些HTTP代理不支持任意HTTP方法或更新的HTTP方法（例如PATCH）。在这种情况下，有可能通过完全违反协议的另一种HTTP方法来&amp;ldquo;代理&amp;rdquo; HTTP方法。</target>
        </trans-unit>
        <trans-unit id="108994bfe405925f39f6482a61036315a0987611" translate="yes" xml:space="preserve">
          <source>Some implementations can detect changes to the session and set this when that happens. The mixin default is hard coded to &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">一些实现可以检测到会话的更改，并在发生这种情况时进行设置。默认的mixin硬编码为 &lt;code&gt;True&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="626141ce28204b71b30290721b7d82baf4ed724e" translate="yes" xml:space="preserve">
          <source>Some implementations can detect when session data is read or written and set this when that happens. The mixin default is hard coded to &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">一些实现可以检测何时读取或写入会话数据，并在发生这种情况时进行设置。默认情况下，mixin硬编码为 &lt;code&gt;True&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="07c03ed659422a93debbb08cfe790be239d7681c" translate="yes" xml:space="preserve">
          <source>Some of the objects provided by Flask are proxies to other objects. The proxies are accessed in the same way for each worker thread, but point to the unique object bound to each worker behind the scenes as described on this page.</source>
          <target state="translated">Flask提供的一些对象是其他对象的代理。对于每个worker线程来说,这些代理以同样的方式进行访问,但如本页所述,它们指向幕后绑定到每个worker的唯一对象。</target>
        </trans-unit>
        <trans-unit id="837dc8608b6342d3924e6501ec44e12d367cf43b" translate="yes" xml:space="preserve">
          <source>Some of these work because of the lenient error handling most browsers use when they encounter a markup error, others are actually specified. The following constructs are optional in HTML5 by standard, but have to be supported by browsers:</source>
          <target state="translated">其中一些工作是因为大多数浏览器在遇到标记错误时使用了宽松的错误处理方式,其他的实际上是指定的。以下构造在HTML5中按标准是可选的,但必须得到浏览器的支持。</target>
        </trans-unit>
        <trans-unit id="d87d8ee5d4c645b5d956ae1ae9a522754e7656b2" translate="yes" xml:space="preserve">
          <source>Sometimes however you will need to disable autoescaping in templates. This can be the case if you want to explicitly inject HTML into pages, for example if they come from a system that generates secure HTML like a markdown to HTML converter.</source>
          <target state="translated">然而,有时您需要禁用模板中的自动调整功能。如果您想明确地将HTML注入到页面中,例如,如果它们来自一个生成安全HTML的系统,如markdown到HTML转换器,就会出现这种情况。</target>
        </trans-unit>
        <trans-unit id="ef034e4e2e4792fe1a0983fd8f010268c517749d" translate="yes" xml:space="preserve">
          <source>Sometimes it can be very helpful to access or modify the sessions from the test client. Generally there are two ways for this. If you just want to ensure that a session has certain keys set to certain values you can just keep the context around and access &lt;a href=&quot;../api/index#flask.session&quot;&gt;&lt;code&gt;flask.session&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">有时从测试客户端访问或修改会话可能非常有帮助。通常有两种方法可以做到这一点。如果只想确保会话将某些键设置为某些值，则可以保留上下文并访问&lt;a href=&quot;../api/index#flask.session&quot;&gt; &lt;code&gt;flask.session&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="835251e3737f581b1c48ab4db21ab1ac7825bd8a" translate="yes" xml:space="preserve">
          <source>Sometimes it is helpful to trigger a regular request but still keep the context around for a little longer so that additional introspection can happen. With Flask 0.4 this is possible by using the &lt;a href=&quot;../api/index#flask.Flask.test_client&quot;&gt;&lt;code&gt;test_client()&lt;/code&gt;&lt;/a&gt; with a &lt;code&gt;with&lt;/code&gt; block:</source>
          <target state="translated">有时触发常规请求会有所帮助，但仍然可以使上下文保持更长时间，以便进行更多的自省。在Flask 0.4中，可以通过将&lt;a href=&quot;../api/index#flask.Flask.test_client&quot;&gt; &lt;code&gt;test_client()&lt;/code&gt; &lt;/a&gt;与 &lt;code&gt;with&lt;/code&gt; 块一起使用来实现：</target>
        </trans-unit>
        <trans-unit id="5da82088ec2c2d44b4e5bbbbaeb4d02eae80caa9" translate="yes" xml:space="preserve">
          <source>Sometimes it is necessary to set additional headers in a view. Because views do not have to return response objects but can return a value that is converted into a response object by Flask itself, it becomes tricky to add headers to it. This function can be called instead of using a return and you will get a response object which you can use to attach headers.</source>
          <target state="translated">有时需要在视图中设置额外的头信息。因为视图不必返回响应对象,但可以返回一个由Flask本身转换为响应对象的值,所以为它添加头信息就变得很棘手。可以调用这个函数来代替使用返回,你会得到一个响应对象,你可以用它来附加头标。</target>
        </trans-unit>
        <trans-unit id="c42ea3f7b7a64983b2642cf374c334570bf3cc9f" translate="yes" xml:space="preserve">
          <source>Sometimes you might be in a situation where you deal with data that should be correct, but actually is not. For example you may have some client-side code that sends an HTTP request to the server but it&amp;rsquo;s obviously malformed. This might be caused by a user tampering with the data, or the client code failing. Most of the time it&amp;rsquo;s okay to reply with &lt;code&gt;400 Bad Request&lt;/code&gt; in that situation, but sometimes that won&amp;rsquo;t do and the code has to continue working.</source>
          <target state="translated">有时您可能处在处理应该正确但实际上不正确的数据的情况。例如，您可能有一些客户端代码将HTTP请求发送到服务器，但显然格式错误。这可能是由于用户篡改数据或客户端代码失败引起的。在大多数情况下，可以在这种情况下以 &lt;code&gt;400 Bad Request&lt;/code&gt; 进行回复，但有时这样做不会，并且代码必须继续工作。</target>
        </trans-unit>
        <trans-unit id="933e18efe24eecb7d902939f6cc942182e2baffc" translate="yes" xml:space="preserve">
          <source>Sometimes you might want to set a cookie at a point where the response object does not exist yet. This is possible by utilizing the &lt;a href=&quot;../patterns/deferredcallbacks/index#deferred-callbacks&quot;&gt;Deferred Request Callbacks&lt;/a&gt; pattern.</source>
          <target state="translated">有时您可能想在响应对象尚不存在的位置设置一个cookie。这可以通过利用&lt;a href=&quot;../patterns/deferredcallbacks/index#deferred-callbacks&quot;&gt;Deferred Request Callbacks&lt;/a&gt;模式来实现。</target>
        </trans-unit>
        <trans-unit id="c99a002c9dd13e6a5da8b3daed527678795761eb" translate="yes" xml:space="preserve">
          <source>Sometimes you might want to use multiple instances of the same application with different configurations. Assuming the application is created inside a function and you can call that function to instantiate it, that is really easy to implement. In order to develop your application to support creating new instances in functions have a look at the &lt;a href=&quot;../appfactories/index#app-factories&quot;&gt;Application Factories&lt;/a&gt; pattern.</source>
          <target state="translated">有时，您可能希望使用具有不同配置的同一应用程序的多个实例。假设应用程序是在一个函数内部创建的，那么您可以调用该函数以实例化它，这确实很容易实现。为了开发您的应用程序以支持在函数中创建新实例，请查看&amp;ldquo;&lt;a href=&quot;../appfactories/index#app-factories&quot;&gt;应用程序工厂&amp;rdquo;&lt;/a&gt;模式。</target>
        </trans-unit>
        <trans-unit id="c6a5992ff75489f65cdcbd05aec286b8f47bf211" translate="yes" xml:space="preserve">
          <source>Sometimes you want to send an enormous amount of data to the client, much more than you want to keep in memory. When you are generating the data on the fly though, how do you send that back to the client without the roundtrip to the filesystem?</source>
          <target state="translated">有时你想向客户端发送大量的数据,比你想保存在内存中的数据要多得多。但当你在飞行中生成数据时,如何在不需要往返文件系统的情况下将数据发送回客户端?</target>
        </trans-unit>
        <trans-unit id="4786696b32ca351c499f41f423e807abe962464a" translate="yes" xml:space="preserve">
          <source>Sort the keys of JSON objects alphabetically. This is useful for caching because it ensures the data is serialized the same way no matter what Python&amp;rsquo;s hash seed is. While not recommended, you can disable this for a possible performance improvement at the cost of caching.</source>
          <target state="translated">按字母顺序对JSON对象的键进行排序。这对于缓存很有用，因为它确保无论Python的哈希种子是什么，都以相同的方式序列化数据。虽然不建议这样做，但您可以禁用此功能以提高性能，但要以缓存为代价。</target>
        </trans-unit>
        <trans-unit id="d22360f4eb53e527c0efb166ced558e4cb8014da" translate="yes" xml:space="preserve">
          <source>Sounds complicated but is very basic. It&amp;rsquo;s easiest to understand it by starting with an example.</source>
          <target state="translated">听起来很复杂，但是非常基础。从一个示例开始，最容易理解它。</target>
        </trans-unit>
        <trans-unit id="4be4fbee023b4668266d7e1b161875147e46c632" translate="yes" xml:space="preserve">
          <source>Source License</source>
          <target state="translated">源许可证</target>
        </trans-unit>
        <trans-unit id="afd943682c2087b568ec22d19cfbd9497630735a" translate="yes" xml:space="preserve">
          <source>Special subclass of the &lt;a href=&quot;#flask.cli.AppGroup&quot;&gt;&lt;code&gt;AppGroup&lt;/code&gt;&lt;/a&gt; group that supports loading more commands from the configured Flask app. Normally a developer does not have to interface with this class but there are some very advanced use cases for which it makes sense to create an instance of this.</source>
          <target state="translated">&lt;a href=&quot;#flask.cli.AppGroup&quot;&gt; &lt;code&gt;AppGroup&lt;/code&gt; &lt;/a&gt;组的特殊子类，支持从已配置的Flask应用程序加载更多命令。通常，开发人员不必与此类进行交互，但是在某些非常高级的用例中，有意义的是创建此类的实例。</target>
        </trans-unit>
        <trans-unit id="028f2a26a3608facefcc544a7b1499ad649f8ac3" translate="yes" xml:space="preserve">
          <source>Specifying &lt;code&gt;Expires&lt;/code&gt; or &lt;code&gt;Max-Age&lt;/code&gt; options, will remove the cookie after the given time, or the current time plus the age, respectively. If neither option is set, the cookie will be removed when the browser is closed.</source>
          <target state="translated">指定 &lt;code&gt;Expires&lt;/code&gt; 或 &lt;code&gt;Max-Age&lt;/code&gt; 选项，将分别在给定时间或当前时间加上年龄之后删除cookie。如果两个选项均未设置，则在关闭浏览器时将删除cookie。</target>
        </trans-unit>
        <trans-unit id="b9271bdb341d5b09c8c4dd1823cf0411f66d5bc7" translate="yes" xml:space="preserve">
          <source>Specifying &lt;code&gt;cli_group=None&lt;/code&gt; will remove the nesting and merge the commands directly to the application&amp;rsquo;s level:</source>
          <target state="translated">指定 &lt;code&gt;cli_group=None&lt;/code&gt; 将删除嵌套并将命令直接合并到应用程序级别：</target>
        </trans-unit>
        <trans-unit id="6c029d6d34ee63f864e4ecf8e7d0119d78119e58" translate="yes" xml:space="preserve">
          <source>Standalone WSGI Containers</source>
          <target state="translated">独立的WSGI容器</target>
        </trans-unit>
        <trans-unit id="7a3d3539231f5d7f6d9184f6b45c93588d3c0e37" translate="yes" xml:space="preserve">
          <source>Standard Context</source>
          <target state="translated">标准语境</target>
        </trans-unit>
        <trans-unit id="e7a5c380c1c8a1cdef98ff95fe55425c6b7d34f8" translate="yes" xml:space="preserve">
          <source>Standard Filters</source>
          <target state="translated">标准过滤器</target>
        </trans-unit>
        <trans-unit id="383169071df9d40a0498818921ed3a7a82edb910" translate="yes" xml:space="preserve">
          <source>Standard disclaimer applies: &lt;a href=&quot;https://click.palletsprojects.com/en/7.x/quickstart/#virtualenv&quot;&gt;you better use a virtualenv&lt;/a&gt;.</source>
          <target state="translated">适用标准免责声明：&lt;a href=&quot;https://click.palletsprojects.com/en/7.x/quickstart/#virtualenv&quot;&gt;您最好使用virtualenv&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="da8c28e1cea07d23bc2cb9e149d136b1a1788dee" translate="yes" xml:space="preserve">
          <source>Starting with Flask 0.11 the recommended way to work with the shell is the &lt;code&gt;flask shell&lt;/code&gt; command which does a lot of this automatically for you. For instance the shell is automatically initialized with a loaded application context.</source>
          <target state="translated">从Flask 0.11开始，推荐的使用Shell的方法是 &lt;code&gt;flask shell&lt;/code&gt; 命令，它会自动为您执行很多操作。例如，shell是使用加载的应用程序上下文自动初始化的。</target>
        </trans-unit>
        <trans-unit id="a92556654eebb63311641b9298b5cac42733110d" translate="yes" xml:space="preserve">
          <source>Starting with Flask 0.11 there are multiple built-in ways to run a development server. The best one is the &lt;strong&gt;flask&lt;/strong&gt; command line utility but you can also continue using the &lt;a href=&quot;../api/index#flask.Flask.run&quot;&gt;&lt;code&gt;Flask.run()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">从Flask 0.11开始，有多种内置方法来运行开发服务器。最好的一个是&lt;strong&gt;flask&lt;/strong&gt;命令行实用程序，但是您也可以继续使用&lt;a href=&quot;../api/index#flask.Flask.run&quot;&gt; &lt;code&gt;Flask.run()&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="fe9d378b9352eb58122f07bff8ff5bfde37d6f23" translate="yes" xml:space="preserve">
          <source>Starting with Flask 0.6, there is integrated support for signalling in Flask. This support is provided by the excellent &lt;a href=&quot;https://pypi.org/project/blinker/&quot;&gt;blinker&lt;/a&gt; library and will gracefully fall back if it is not available.</source>
          <target state="translated">从Flask 0.6开始，Flask中集成了对信令的支持。此支持由出色的&lt;a href=&quot;https://pypi.org/project/blinker/&quot;&gt;眨眼程序&lt;/a&gt;库提供，如果不可用，将优雅地回退。</target>
        </trans-unit>
        <trans-unit id="1d38e7210e42a6c886f7c31f4b5a92a5b5aebe2c" translate="yes" xml:space="preserve">
          <source>Starting with Flask 0.8 there is also an alternative way where you can specify a list of decorators to apply in the class declaration:</source>
          <target state="translated">从Flask 0.8开始,还有另一种方式,你可以在类声明中指定要应用的装饰器列表。</target>
        </trans-unit>
        <trans-unit id="bccd78557a2161cb4a9b3a633c184b265bf0f320" translate="yes" xml:space="preserve">
          <source>Starting your app with uwsgi</source>
          <target state="translated">使用uwsgi启动您的应用程序</target>
        </trans-unit>
        <trans-unit id="a1c031153c642e8130ab037b056c28c991496c45" translate="yes" xml:space="preserve">
          <source>Static Files</source>
          <target state="translated">静态文件</target>
        </trans-unit>
        <trans-unit id="fb53f6960ec8c2ca2033b0341ff3aa81922ac887" translate="yes" xml:space="preserve">
          <source>Static file functions such as &lt;a href=&quot;#flask.send_from_directory&quot;&gt;&lt;code&gt;send_from_directory()&lt;/code&gt;&lt;/a&gt; use this function, and &lt;a href=&quot;#flask.send_file&quot;&gt;&lt;code&gt;send_file()&lt;/code&gt;&lt;/a&gt; calls this function on &lt;a href=&quot;#flask.current_app&quot;&gt;&lt;code&gt;current_app&lt;/code&gt;&lt;/a&gt; when the given cache_timeout is &lt;code&gt;None&lt;/code&gt;. If a cache_timeout is given in &lt;a href=&quot;#flask.send_file&quot;&gt;&lt;code&gt;send_file()&lt;/code&gt;&lt;/a&gt;, that timeout is used; otherwise, this method is called.</source>
          <target state="translated">静态文件函数（例如&lt;a href=&quot;#flask.send_from_directory&quot;&gt; &lt;code&gt;send_from_directory()&lt;/code&gt; )&lt;/a&gt;使用此函数，并且当给定的cache_timeout为 &lt;code&gt;None&lt;/code&gt; 时，&lt;a href=&quot;#flask.send_file&quot;&gt; &lt;code&gt;send_file()&lt;/code&gt; &lt;/a&gt;在&lt;a href=&quot;#flask.current_app&quot;&gt; &lt;code&gt;current_app&lt;/code&gt; &lt;/a&gt;上调用此函数。如果在&lt;a href=&quot;#flask.send_file&quot;&gt; &lt;code&gt;send_file()&lt;/code&gt; 中&lt;/a&gt;提供了cache_timeout ，则使用该超时；否则，将使用该超时。否则，将调用此方法。</target>
        </trans-unit>
        <trans-unit id="a613ad425efbf5ae42d680469b69f0c3362ed0df" translate="yes" xml:space="preserve">
          <source>Store that file somewhere that you will find it again (e.g.: &lt;code&gt;/var/www/yourapplication&lt;/code&gt;) and make sure that &lt;code&gt;yourapplication&lt;/code&gt; and all the libraries that are in use are on the python load path. If you don&amp;rsquo;t want to install it system wide consider using a &lt;a href=&quot;https://pypi.org/project/virtualenv/&quot;&gt;virtual python&lt;/a&gt; instance. Keep in mind that you will have to actually install your application into the virtualenv as well. Alternatively there is the option to just patch the path in the &lt;code&gt;.wsgi&lt;/code&gt; file before the import:</source>
          <target state="translated">存储文件的地方，你会再次找到它（例如： &lt;code&gt;/var/www/yourapplication&lt;/code&gt; ），并确保 &lt;code&gt;yourapplication&lt;/code&gt; 和所有正在使用的库蟒蛇负载路径上。如果您不想在系统范围内安装它，请考虑使用&lt;a href=&quot;https://pypi.org/project/virtualenv/&quot;&gt;虚拟python&lt;/a&gt;实例。请记住，您还必须将应用程序实际安装到virtualenv中。另外，也可以选择在导入之前修补 &lt;code&gt;.wsgi&lt;/code&gt; 文件中的路径：</target>
        </trans-unit>
        <trans-unit id="5058d23d7b4c6c3dae4bcb5cbf5c3fdf33f9c0ed" translate="yes" xml:space="preserve">
          <source>Storing Data</source>
          <target state="translated">存储数据</target>
        </trans-unit>
        <trans-unit id="05843d32b9793a1f8d919f95361081a52897ef46" translate="yes" xml:space="preserve">
          <source>Storing cookies:</source>
          <target state="translated">储存饼干。</target>
        </trans-unit>
        <trans-unit id="28e7dcc8092f3442077fd8136484012f66a17fe3" translate="yes" xml:space="preserve">
          <source>Stream Helpers</source>
          <target state="translated">溪流助手</target>
        </trans-unit>
        <trans-unit id="3396963fb98ea70ab936a271d4c2ce34955c7e06" translate="yes" xml:space="preserve">
          <source>Streaming Contents</source>
          <target state="translated">流媒体内容</target>
        </trans-unit>
        <trans-unit id="dea3981c41ac54eccf795e49d155c9f8d6280666" translate="yes" xml:space="preserve">
          <source>Streaming from Templates</source>
          <target state="translated">从模板流</target>
        </trans-unit>
        <trans-unit id="11fc8f904f359921eaf1c261ddda1ddab4d76074" translate="yes" xml:space="preserve">
          <source>Streaming with Context</source>
          <target state="translated">流媒体与上下文</target>
        </trans-unit>
        <trans-unit id="3b5e6979b4d11b97cdf124e50b3f31cdba3f60dc" translate="yes" xml:space="preserve">
          <source>Subclass.</source>
          <target state="translated">Subclass.</target>
        </trans-unit>
        <trans-unit id="cf3764067dce7c691959cf3216d8cff12021292c" translate="yes" xml:space="preserve">
          <source>Subclasses have to override this method to implement the actual view function code. This method is called with all the arguments from the URL rule.</source>
          <target state="translated">子类必须重写这个方法来实现实际的视图功能代码。该方法调用的是URL规则的所有参数。</target>
        </trans-unit>
        <trans-unit id="11ddad73c5e94c7776637e4806549f5e1849d957" translate="yes" xml:space="preserve">
          <source>Subclassing Flask</source>
          <target state="translated">Flask的子类</target>
        </trans-unit>
        <trans-unit id="740057b8189ca179a92f1c0babad5e8319eb10b8" translate="yes" xml:space="preserve">
          <source>Submitting patches</source>
          <target state="translated">提交补丁</target>
        </trans-unit>
        <trans-unit id="120265489f46cb7782aca0908e79e7af5d6b5bcc" translate="yes" xml:space="preserve">
          <source>Subscribing to Signals</source>
          <target state="translated">订阅信号</target>
        </trans-unit>
        <trans-unit id="a5269c1e53e03f7ae90c246ec2391d3c6c452069" translate="yes" xml:space="preserve">
          <source>Support for Automatic Reloading</source>
          <target state="translated">支持自动重装</target>
        </trans-unit>
        <trans-unit id="690ecb48d7eae6464396e64f7743a60c8c6db126" translate="yes" xml:space="preserve">
          <source>Support questions</source>
          <target state="translated">支持问题</target>
        </trans-unit>
        <trans-unit id="c53e383a8f5515a6b6c39fe54aa87be49f88e6d6" translate="yes" xml:space="preserve">
          <source>Tag classes to bind when creating the serializer. Other tags can be added later using &lt;a href=&quot;#flask.json.tag.TaggedJSONSerializer.register&quot;&gt;&lt;code&gt;register()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在创建序列化程序时要绑定的标签类。稍后可以使用&lt;a href=&quot;#flask.json.tag.TaggedJSONSerializer.register&quot;&gt; &lt;code&gt;register()&lt;/code&gt; &lt;/a&gt;添加其他标签。</target>
        </trans-unit>
        <trans-unit id="f86ff17d85179c51830ff4b59c0dbf7325faa65d" translate="yes" xml:space="preserve">
          <source>Tag the value and dump it to a compact JSON string.</source>
          <target state="translated">给该值打上标签,并将其转储为一个紧凑的JSON字符串。</target>
        </trans-unit>
        <trans-unit id="96c0f4e1ac60a52d98bf6c4b1503ec7e057c3357" translate="yes" xml:space="preserve">
          <source>Tagged JSON</source>
          <target state="translated">标签:JSON</target>
        </trans-unit>
        <trans-unit id="da75bc2cdf1679e8e7fa60eef27138ce6b100afa" translate="yes" xml:space="preserve">
          <source>Tagging Builds</source>
          <target state="translated">标签建设</target>
        </trans-unit>
        <trans-unit id="c987aa4e8e2ae7c4c94a99d5857937a94a8a7dfd" translate="yes" xml:space="preserve">
          <source>Take a look at &lt;a href=&quot;../api/index#core-signals-list&quot;&gt;Signals&lt;/a&gt; for a list of all builtin signals.</source>
          <target state="translated">查看&lt;a href=&quot;../api/index#core-signals-list&quot;&gt;Signals&lt;/a&gt;以获取所有内置信号的列表。</target>
        </trans-unit>
        <trans-unit id="b22ea732a4a2a83b088f04051ebcc5ea247ffc13" translate="yes" xml:space="preserve">
          <source>Takes the same arguments as Werkzeug&amp;rsquo;s &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/test/#werkzeug.test.EnvironBuilder&quot;&gt;&lt;code&gt;EnvironBuilder&lt;/code&gt;&lt;/a&gt;, with some defaults from the application. See the linked Werkzeug docs for most of the available arguments. Flask-specific behavior is listed here.</source>
          <target state="translated">接受与Werkzeug的&lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/test/#werkzeug.test.EnvironBuilder&quot;&gt; &lt;code&gt;EnvironBuilder&lt;/code&gt; &lt;/a&gt;相同的参数，并且应用程序中有一些默认值。有关大多数可用参数，请参阅链接的Werkzeug文档。烧瓶特定的行为在此处列出。</target>
        </trans-unit>
        <trans-unit id="d22bbbfaa2bb8ee680aaaa1b16a7ec956bd3a8ff" translate="yes" xml:space="preserve">
          <source>Takes the same arguments as the &lt;code&gt;EnvironBuilder&lt;/code&gt; class with some additions: You can provide a &lt;code&gt;EnvironBuilder&lt;/code&gt; or a WSGI environment as only argument instead of the &lt;code&gt;EnvironBuilder&lt;/code&gt; arguments and two optional keyword arguments (&lt;code&gt;as_tuple&lt;/code&gt;, &lt;code&gt;buffered&lt;/code&gt;) that change the type of the return value or the way the application is executed.</source>
          <target state="translated">接受与 &lt;code&gt;EnvironBuilder&lt;/code&gt; 类相同的参数，但有一些补充：您可以提供一个 &lt;code&gt;EnvironBuilder&lt;/code&gt; 或WSGI环境作为唯一参数，而不是 &lt;code&gt;EnvironBuilder&lt;/code&gt; 参数和两个可选的关键字参数（ &lt;code&gt;as_tuple&lt;/code&gt; ， &lt;code&gt;buffered&lt;/code&gt; ）来更改返回值的类型或方式该应用程序被执行。</target>
        </trans-unit>
        <trans-unit id="5f28097933616fb28ba7311a99d6631dcaab7f34" translate="yes" xml:space="preserve">
          <source>Takes the same arguments as the built-in &lt;a href=&quot;https://docs.python.org/3/library/json.html#json.dumps&quot;&gt;&lt;code&gt;json.dumps()&lt;/code&gt;&lt;/a&gt;, and does some extra configuration based on the application. If the simplejson package is installed, it is preferred.</source>
          <target state="translated">采用与内置&lt;a href=&quot;https://docs.python.org/3/library/json.html#json.dumps&quot;&gt; &lt;code&gt;json.dumps()&lt;/code&gt; &lt;/a&gt;相同的参数，并根据应用程序进行一些额外的配置。如果安装了simplejson软件包，则首选。</target>
        </trans-unit>
        <trans-unit id="fa8572195c6e10efbacebd949564a7a974b82a1a" translate="yes" xml:space="preserve">
          <source>Takes the same arguments as the built-in &lt;a href=&quot;https://docs.python.org/3/library/json.html#json.loads&quot;&gt;&lt;code&gt;json.loads()&lt;/code&gt;&lt;/a&gt;, and does some extra configuration based on the application. If the simplejson package is installed, it is preferred.</source>
          <target state="translated">采用与内置&lt;a href=&quot;https://docs.python.org/3/library/json.html#json.loads&quot;&gt; &lt;code&gt;json.loads()&lt;/code&gt; &lt;/a&gt;相同的参数，并根据应用程序进行一些额外的配置。如果安装了simplejson软件包，则首选。</target>
        </trans-unit>
        <trans-unit id="b3ffc1a7f43c5e9dc71da5ec7ff9fb5cc99025a7" translate="yes" xml:space="preserve">
          <source>Teardown Callbacks</source>
          <target state="translated">拆卸回调</target>
        </trans-unit>
        <trans-unit id="834e568d70197add4b1a5c3b676077a86ae7cf02" translate="yes" xml:space="preserve">
          <source>Tell the browser where it can load various types of resource from. This header should be used whenever possible, but requires some work to define the correct policy for your site. A very strict policy would be:</source>
          <target state="translated">告诉浏览器可以从哪里加载各种类型的资源。这个头应该尽可能地使用,但需要做一些工作来为你的网站定义正确的策略。一个非常严格的策略是</target>
        </trans-unit>
        <trans-unit id="97db2cc75b189bccffd1a15615e2e9c0ed4c343b" translate="yes" xml:space="preserve">
          <source>Tells the browser to convert all HTTP requests to HTTPS, preventing man-in-the-middle (MITM) attacks.</source>
          <target state="translated">告诉浏览器将所有HTTP请求转换为HTTPS,防止中间人(MITM)攻击。</target>
        </trans-unit>
        <trans-unit id="d6b6bb3a1a939adefc8ad08e7880baf39f4c9d7b" translate="yes" xml:space="preserve">
          <source>Template Inheritance</source>
          <target state="translated">模板继承</target>
        </trans-unit>
        <trans-unit id="7d98da836ffd500e13f5643f48de5aa5ded22265" translate="yes" xml:space="preserve">
          <source>Template Rendering</source>
          <target state="translated">模板渲染</target>
        </trans-unit>
        <trans-unit id="1eb867dd354038978b9b620fe41c51fa315fe9b7" translate="yes" xml:space="preserve">
          <source>Template engines are like programming languages and each of those engines has a certain understanding about how things work. On the surface they all work the same: you tell the engine to evaluate a template with a set of variables and take the return value as string.</source>
          <target state="translated">模板引擎就像编程语言一样,每一个引擎都对事物的工作原理有一定的理解。从表面上看,它们的工作原理都是一样的:你告诉引擎用一组变量来评估一个模板,并将返回值作为字符串。</target>
        </trans-unit>
        <trans-unit id="f25b700ed9f092123a43acb205a6869342cf9dd6" translate="yes" xml:space="preserve">
          <source>Templates</source>
          <target state="translated">Templates</target>
        </trans-unit>
        <trans-unit id="ffc941c03dc811113dbc0dbee2b64af746f03bff" translate="yes" xml:space="preserve">
          <source>Templates are especially useful if inheritance is used. If you want to know how that works, head over to the &lt;a href=&quot;../patterns/templateinheritance/index#template-inheritance&quot;&gt;Template Inheritance&lt;/a&gt; pattern documentation. Basically template inheritance makes it possible to keep certain elements on each page (like header, navigation and footer).</source>
          <target state="translated">如果使用继承，则模板特别有用。如果您想知道它是如何工作的，请转到&amp;ldquo;&lt;a href=&quot;../patterns/templateinheritance/index#template-inheritance&quot;&gt;模板继承&amp;rdquo;&lt;/a&gt;模式文档。基本上，模板继承可以在每个页面上保留某些元素（例如页眉，导航和页脚）。</target>
        </trans-unit>
        <trans-unit id="ba7c29532b26ba4de39cd276153d22e52418588f" translate="yes" xml:space="preserve">
          <source>Templating Decorator</source>
          <target state="translated">模板装饰剂</target>
        </trans-unit>
        <trans-unit id="0ce64fb26a80b011b3990f1decd549ab4b29e615" translate="yes" xml:space="preserve">
          <source>Temporarily disable the autoescape system altogether.</source>
          <target state="translated">暂时完全关闭自动回避系统。</target>
        </trans-unit>
        <trans-unit id="c61ff99727b46a971ff247c8481216c3a099131c" translate="yes" xml:space="preserve">
          <source>Temporary holder object for registering a blueprint with the application. An instance of this class is created by the &lt;a href=&quot;#flask.Blueprint.make_setup_state&quot;&gt;&lt;code&gt;make_setup_state()&lt;/code&gt;&lt;/a&gt; method and later passed to all register callback functions.</source>
          <target state="translated">临时持有人对象，用于向应用程序注册蓝图。此类的实例由&lt;a href=&quot;#flask.Blueprint.make_setup_state&quot;&gt; &lt;code&gt;make_setup_state()&lt;/code&gt; &lt;/a&gt;方法创建，然后传递给所有寄存器回调函数。</target>
        </trans-unit>
        <trans-unit id="1c90eba86e36c270502ca19ff95a2742487b93b1" translate="yes" xml:space="preserve">
          <source>Test Adding Messages</source>
          <target state="translated">测试添加信息</target>
        </trans-unit>
        <trans-unit id="200e9a09a0d5830543e0d796adf19d11873f302f" translate="yes" xml:space="preserve">
          <source>Test CLI Runner</source>
          <target state="translated">测试CLI运行器</target>
        </trans-unit>
        <trans-unit id="da46c4c7a01d6b3feb25b1296ca02e656c4baade" translate="yes" xml:space="preserve">
          <source>Test Client</source>
          <target state="translated">测试客户端</target>
        </trans-unit>
        <trans-unit id="a89b0dbcd302d4f9ba9ec7aca5a0f8a1ccc06a1a" translate="yes" xml:space="preserve">
          <source>Test Coverage</source>
          <target state="translated">测试范围</target>
        </trans-unit>
        <trans-unit id="82a67436aa4dff192f7fe141b578e3cc5c14a9cf" translate="yes" xml:space="preserve">
          <source>Testing CLI Commands</source>
          <target state="translated">测试CLI命令</target>
        </trans-unit>
        <trans-unit id="f883a1023218a59e6d0ad5ca9839bfc7b6761974" translate="yes" xml:space="preserve">
          <source>Testing Flask Applications</source>
          <target state="translated">测试Flask应用</target>
        </trans-unit>
        <trans-unit id="fa31943361576078387ad6fafbf1ee34e4c8e0bd" translate="yes" xml:space="preserve">
          <source>Testing JSON APIs</source>
          <target state="translated">测试JSON APIs</target>
        </trans-unit>
        <trans-unit id="4fcb82af5c1cc15cee3fbbc67d12760b7a2114b9" translate="yes" xml:space="preserve">
          <source>Testing. You can have instances of the application with different settings to test every case.</source>
          <target state="translated">测试。你可以有不同设置的应用程序实例来测试每个案例。</target>
        </trans-unit>
        <trans-unit id="49e3ea092f8e1d6cd44d64c751d143a32de24ff4" translate="yes" xml:space="preserve">
          <source>That way you also don&amp;rsquo;t have to provide the &lt;a href=&quot;../api/index#flask.views.View.methods&quot;&gt;&lt;code&gt;methods&lt;/code&gt;&lt;/a&gt; attribute. It&amp;rsquo;s automatically set based on the methods defined in the class.</source>
          <target state="translated">这样，您也不必提供&lt;a href=&quot;../api/index#flask.views.View.methods&quot;&gt; &lt;code&gt;methods&lt;/code&gt; &lt;/a&gt;属性。它是根据类中定义的方法自动设置的。</target>
        </trans-unit>
        <trans-unit id="e7a546fceb15863ef07fa0b83762555c209a206f" translate="yes" xml:space="preserve">
          <source>That way you no longer have to do the &lt;code&gt;lang_code&lt;/code&gt; assignment to &lt;a href=&quot;../../api/index#flask.g&quot;&gt;&lt;code&gt;g&lt;/code&gt;&lt;/a&gt; in every function. You can further improve that by writing your own decorator that prefixes URLs with the language code, but the more beautiful solution is using a blueprint. Once the &lt;code&gt;'lang_code'&lt;/code&gt; is popped from the values dictionary and it will no longer be forwarded to the view function reducing the code to this:</source>
          <target state="translated">这样，您就不再需要在每个函数中对&lt;a href=&quot;../../api/index#flask.g&quot;&gt; &lt;code&gt;g&lt;/code&gt; &lt;/a&gt;进行 &lt;code&gt;lang_code&lt;/code&gt; 分配。您可以通过编写自己的装饰器为URL加上语言代码作为前缀来进一步改善这一点，但是更漂亮的解决方案是使用蓝图。一旦从值字典中弹出 &lt;code&gt;'lang_code'&lt;/code&gt; ，它将不再转发到视图函数，从而将代码缩减为：</target>
        </trans-unit>
        <trans-unit id="f27e60ecbac86ce92ede80621ddb5f6e2c8b5d36" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s all you need for most browsers, however some really old ones do not support this standard. The old de-facto standard is to serve this file, with this name, at the website root. If your application is not mounted at the root path of the domain you either need to configure the web server to serve the icon at the root or if you can&amp;rsquo;t do that you&amp;rsquo;re out of luck. If however your application is the root you can simply route a redirect:</source>
          <target state="translated">这是大多数浏览器所需的全部，但是某些真正的旧浏览器不支持此标准。旧的事实上的标准是在网站根目录下使用此名称提供此文件。如果您的应用程序未安装在域的根路径下，则需要配置Web服务器以在根目录处提供图标，或者如果您不能这样做，那么您将很不走运。但是，如果您的应用程序是根目录，则可以简单地路由重定向：</target>
        </trans-unit>
        <trans-unit id="d8271c725a9d4d3a19887c2e57654d09ea3e66de" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ENV&quot;&gt;&lt;code&gt;ENV&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#DEBUG&quot;&gt;&lt;code&gt;DEBUG&lt;/code&gt;&lt;/a&gt; config values are special because they may behave inconsistently if changed after the app has begun setting up. In order to set the environment and debug mode reliably, Flask uses environment variables.</source>
          <target state="translated">在&lt;a href=&quot;#ENV&quot;&gt; &lt;code&gt;ENV&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#DEBUG&quot;&gt; &lt;code&gt;DEBUG&lt;/code&gt; &lt;/a&gt;配置值是特殊的，因为他们的行为可能不一致，如果改变了应用程序已开始建立之后。为了可靠地设置环境和调试模式，Flask使用了环境变量。</target>
        </trans-unit>
        <trans-unit id="e3e048b96edcfc5bd27f622e9f280c56e02b6844" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../api/index#flask.Flask&quot;&gt;&lt;code&gt;Flask&lt;/code&gt;&lt;/a&gt; class is designed for subclassing.</source>
          <target state="translated">该&lt;a href=&quot;../../api/index#flask.Flask&quot;&gt; &lt;code&gt;Flask&lt;/code&gt; &lt;/a&gt;类是专为继承。</target>
        </trans-unit>
        <trans-unit id="934563488d8cb041b67083b5a2daad8001b11349" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../api/index#api&quot;&gt;API&lt;/a&gt; docs are full of available overrides, hook points, and &lt;a href=&quot;../signals/index#signals&quot;&gt;Signals&lt;/a&gt;. You can provide custom classes for things like the request and response objects. Dig deeper on the APIs you use, and look for the customizations which are available out of the box in a Flask release. Look for ways in which your project can be refactored into a collection of utilities and Flask extensions. Explore the many &lt;a href=&quot;../extensions/index&quot;&gt;Extensions&lt;/a&gt; in the community, and look for patterns to build your own extensions if you do not find the tools you need.</source>
          <target state="translated">该&lt;a href=&quot;../api/index#api&quot;&gt;API&lt;/a&gt;文档是全部可用覆盖，挂钩点，和&lt;a href=&quot;../signals/index#signals&quot;&gt;信号&lt;/a&gt;。您可以为诸如请求和响应对象之类的事物提供自定义类。深入了解您使用的API，并在Flask版本中查找可立即使用的自定义项。寻找将项目重构为实用程序和Flask扩展的集合的方法。探索社区中的许多&lt;a href=&quot;../extensions/index&quot;&gt;扩展&lt;/a&gt;，如果找不到所需的工具，则寻找用于构建自己的扩展的模式。</target>
        </trans-unit>
        <trans-unit id="56a2bbe9b28d3a2db99c6f713429c77157ffa1d1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../api/index#flask.Flask&quot;&gt;&lt;code&gt;Flask&lt;/code&gt;&lt;/a&gt; application object has attributes, such as &lt;a href=&quot;../api/index#flask.Flask.config&quot;&gt;&lt;code&gt;config&lt;/code&gt;&lt;/a&gt;, that are useful to access within views and &lt;a href=&quot;../cli/index&quot;&gt;CLI commands&lt;/a&gt;. However, importing the &lt;code&gt;app&lt;/code&gt; instance within the modules in your project is prone to circular import issues. When using the &lt;a href=&quot;../patterns/appfactories/index&quot;&gt;app factory pattern&lt;/a&gt; or writing reusable &lt;a href=&quot;../blueprints/index&quot;&gt;blueprints&lt;/a&gt; or &lt;a href=&quot;../extensions/index&quot;&gt;extensions&lt;/a&gt; there won&amp;rsquo;t be an &lt;code&gt;app&lt;/code&gt; instance to import at all.</source>
          <target state="translated">所述&lt;a href=&quot;../api/index#flask.Flask&quot;&gt; &lt;code&gt;Flask&lt;/code&gt; &lt;/a&gt;应用程序对象具有的属性，例如&lt;a href=&quot;../api/index#flask.Flask.config&quot;&gt; &lt;code&gt;config&lt;/code&gt; &lt;/a&gt;，即是视图和内访问有用&lt;a href=&quot;../cli/index&quot;&gt;CLI命令&lt;/a&gt;。但是，在项目的模块内导入 &lt;code&gt;app&lt;/code&gt; 实例容易出现循环导入问题。使用&lt;a href=&quot;../patterns/appfactories/index&quot;&gt;应用程序工厂模式&lt;/a&gt;或编写可重用的&lt;a href=&quot;../blueprints/index&quot;&gt;蓝图&lt;/a&gt;或&lt;a href=&quot;../extensions/index&quot;&gt;扩展名时&lt;/a&gt;，根本不会导入任何 &lt;code&gt;app&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="5bc42c62f5c6b81a8eaf45e0836757a57cb2d3da" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../api/index#flask.Flask&quot;&gt;&lt;code&gt;Flask&lt;/code&gt;&lt;/a&gt; class has many methods designed for subclassing. You can quickly add or customize behavior by subclassing &lt;a href=&quot;../api/index#flask.Flask&quot;&gt;&lt;code&gt;Flask&lt;/code&gt;&lt;/a&gt; (see the linked method docs) and using that subclass wherever you instantiate an application class. This works well with &lt;a href=&quot;../patterns/appfactories/index#app-factories&quot;&gt;Application Factories&lt;/a&gt;. See &lt;a href=&quot;../patterns/subclassing/index&quot;&gt;Subclassing Flask&lt;/a&gt; for an example.</source>
          <target state="translated">该&lt;a href=&quot;../api/index#flask.Flask&quot;&gt; &lt;code&gt;Flask&lt;/code&gt; &lt;/a&gt;类有许多方法设计的子类。您可以通过将&lt;a href=&quot;../api/index#flask.Flask&quot;&gt; &lt;code&gt;Flask&lt;/code&gt; &lt;/a&gt;子类化（请参见链接的方法文档）并在实例化应用程序类的任何地方使用该子类来快速添加或自定义行为。这与&lt;a href=&quot;../patterns/appfactories/index#app-factories&quot;&gt;应用程序工厂&lt;/a&gt;很好地配合。有关示例，请参见&lt;a href=&quot;../patterns/subclassing/index&quot;&gt;子类化Flask&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dded8094d82a0a7ca82fe6d42f8576d18a16a115" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../api/index#flask.Flask.config&quot;&gt;&lt;code&gt;config&lt;/code&gt;&lt;/a&gt; is actually a subclass of a dictionary and can be modified just like any dictionary:</source>
          <target state="translated">该&lt;a href=&quot;../api/index#flask.Flask.config&quot;&gt; &lt;code&gt;config&lt;/code&gt; &lt;/a&gt;实际上是一本字典的一个子类，并可以修改，就像任何词典：</target>
        </trans-unit>
        <trans-unit id="3c0d24e2c75a60e936e2c5fb5053b4b692ad047e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../api/index#flask.Flask.wsgi_app&quot;&gt;&lt;code&gt;Flask.wsgi_app()&lt;/code&gt;&lt;/a&gt; method is called to handle each request. It manages the contexts during the request. Internally, the request and application contexts work as stacks, &lt;a href=&quot;../api/index#flask._request_ctx_stack&quot;&gt;&lt;code&gt;_request_ctx_stack&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../api/index#flask._app_ctx_stack&quot;&gt;&lt;code&gt;_app_ctx_stack&lt;/code&gt;&lt;/a&gt;. When contexts are pushed onto the stack, the proxies that depend on them are available and point at information from the top context on the stack.</source>
          <target state="translated">所述&lt;a href=&quot;../api/index#flask.Flask.wsgi_app&quot;&gt; &lt;code&gt;Flask.wsgi_app()&lt;/code&gt; &lt;/a&gt;方法被调用来处理每个请求。它在请求期间管理上下文。在内部，请求和应用程序上下文作为堆栈&lt;a href=&quot;../api/index#flask._request_ctx_stack&quot;&gt; &lt;code&gt;_request_ctx_stack&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../api/index#flask._app_ctx_stack&quot;&gt; &lt;code&gt;_app_ctx_stack&lt;/code&gt; 起作用&lt;/a&gt;。将上下文推入堆栈时，依赖于上下文的代理将可用，并指向来自堆栈顶部上下文的信息。</target>
        </trans-unit>
        <trans-unit id="7fd79ace1843b3132e77f1fef1e9c81b825483dc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../api/index#flask.cli.run_command&quot;&gt;&lt;code&gt;run&lt;/code&gt;&lt;/a&gt; command will start the development server. It replaces the &lt;a href=&quot;../api/index#flask.Flask.run&quot;&gt;&lt;code&gt;Flask.run()&lt;/code&gt;&lt;/a&gt; method in most cases.</source>
          <target state="translated">在&lt;a href=&quot;../api/index#flask.cli.run_command&quot;&gt; &lt;code&gt;run&lt;/code&gt; &lt;/a&gt;命令将启动开发服务器。在大多数情况下，它将替换&lt;a href=&quot;../api/index#flask.Flask.run&quot;&gt; &lt;code&gt;Flask.run()&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="15493c255df67ab8ff09ea1f5c6be0caf80b888e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../api/index#flask.escape&quot;&gt;&lt;code&gt;escape()&lt;/code&gt;&lt;/a&gt; mentioned here does escaping for you if you are not using the template engine (as in this example).</source>
          <target state="translated">如果您不使用模板引擎，则此处提到的&lt;a href=&quot;../api/index#flask.escape&quot;&gt; &lt;code&gt;escape()&lt;/code&gt; &lt;/a&gt;会为您进行转义（如本例所示）。</target>
        </trans-unit>
        <trans-unit id="c00a611697086121d2c799a27403a49d2f5a21b0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../api/index#flask.get_flashed_messages&quot;&gt;&lt;code&gt;flask.get_flashed_messages()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">所述&lt;a href=&quot;../api/index#flask.get_flashed_messages&quot;&gt; &lt;code&gt;flask.get_flashed_messages()&lt;/code&gt; &lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="df20bcfd18a65f0d873241a1cb441d088a9df6c3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../api/index#flask.url_for&quot;&gt;&lt;code&gt;flask.url_for()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">所述&lt;a href=&quot;../api/index#flask.url_for&quot;&gt; &lt;code&gt;flask.url_for()&lt;/code&gt; &lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="ce527570438295acb807e2f394025aa282ebd86c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../patterns/appdispatch/index#app-dispatch&quot;&gt;Application Dispatching&lt;/a&gt; chapter shows in detail how to apply middleware. You can introduce WSGI middleware to wrap your Flask instances and introduce fixes and changes at the layer between your Flask application and your HTTP server. Werkzeug includes several &lt;a href=&quot;https://werkzeug.palletsprojects.com/middleware/&quot;&gt;middlewares&lt;/a&gt;.</source>
          <target state="translated">&amp;ldquo;&lt;a href=&quot;../patterns/appdispatch/index#app-dispatch&quot;&gt;应用程序调度&amp;rdquo;&lt;/a&gt;一章详细显示了如何应用中间件。您可以引入WSGI中间件来包装Flask实例，并在Flask应用程序和HTTP服务器之间的层上引入修复和更改。Werkzeug包括几种&lt;a href=&quot;https://werkzeug.palletsprojects.com/middleware/&quot;&gt;中间件&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="73c70ab290fb4349a04a4ca33499a21806e1643f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://click.palletsprojects.com/en/7.x/api/#click.testing.CliRunner&quot;&gt;&lt;code&gt;CliRunner&lt;/code&gt;&lt;/a&gt; subclass, by default &lt;a href=&quot;#flask.testing.FlaskCliRunner&quot;&gt;&lt;code&gt;FlaskCliRunner&lt;/code&gt;&lt;/a&gt; that is used by &lt;a href=&quot;#flask.Flask.test_cli_runner&quot;&gt;&lt;code&gt;test_cli_runner()&lt;/code&gt;&lt;/a&gt;. Its &lt;code&gt;__init__&lt;/code&gt; method should take a Flask app object as the first argument.</source>
          <target state="translated">的&lt;a href=&quot;https://click.palletsprojects.com/en/7.x/api/#click.testing.CliRunner&quot;&gt; &lt;code&gt;CliRunner&lt;/code&gt; &lt;/a&gt;亚类中，通过默认&lt;a href=&quot;#flask.testing.FlaskCliRunner&quot;&gt; &lt;code&gt;FlaskCliRunner&lt;/code&gt; &lt;/a&gt;所使用&lt;a href=&quot;#flask.Flask.test_cli_runner&quot;&gt; &lt;code&gt;test_cli_runner()&lt;/code&gt; &lt;/a&gt;。它的 &lt;code&gt;__init__&lt;/code&gt; 方法应将Flask应用程序对象作为第一个参数。</target>
        </trans-unit>
        <trans-unit id="aee5450c61b01696282f52b22fe653c847033f90" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://en.wikipedia.org/wiki/Favicon&quot;&gt;Favicon&lt;/a&gt; article on Wikipedia</source>
          <target state="translated">维基百科上的&lt;a href=&quot;https://en.wikipedia.org/wiki/Favicon&quot;&gt;Favicon&lt;/a&gt;文章</target>
        </trans-unit>
        <trans-unit id="619f8f29c43eeb631eddc5c86fb1b2a4e0eae2ce" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://flask-wtf.readthedocs.io/en/stable/&quot;&gt;Flask-WTF&lt;/a&gt; extension expands on this pattern and adds a few little helpers that make working with forms and Flask more fun. You can get it from &lt;a href=&quot;https://pypi.org/project/Flask-WTF/&quot;&gt;PyPI&lt;/a&gt;.</source>
          <target state="translated">该&lt;a href=&quot;https://flask-wtf.readthedocs.io/en/stable/&quot;&gt;瓶-WTF&lt;/a&gt;在这种模式延伸扩张和增加了一些小帮手，使表单和瓶更有趣的工作。您可以从&lt;a href=&quot;https://pypi.org/project/Flask-WTF/&quot;&gt;PyPI&lt;/a&gt;获得它。</target>
        </trans-unit>
        <trans-unit id="8cb2d43a62d9dac580264ec37de83f22f6296578" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://pythonhosted.org/blinker/index.html#blinker.base.Signal.connected_to&quot;&gt;&lt;code&gt;connected_to()&lt;/code&gt;&lt;/a&gt; method arrived in Blinker with version 1.1.</source>
          <target state="translated">该&lt;a href=&quot;https://pythonhosted.org/blinker/index.html#blinker.base.Signal.connected_to&quot;&gt; &lt;code&gt;connected_to()&lt;/code&gt; &lt;/a&gt;方法布林克抵用1.1版本。</target>
        </trans-unit>
        <trans-unit id="012fb2d289ff0b251ad6b40d923d440e15e6da95" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/routing/#werkzeug.routing.Map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; for this instance. You can use this to change the routing converters after the class was created but before any routes are connected. Example:</source>
          <target state="translated">此实例的&lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/routing/#werkzeug.routing.Map&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt;。您可以在创建类之后但在连接任何路由之前使用此方法更改路由转换器。例子：</target>
        </trans-unit>
        <trans-unit id="7ddff6f546b657cbad43c62cc3fae7a3ad2b98c4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; tags provide a way to embed audio and video without complicated add-ons like QuickTime or Flash.</source>
          <target state="translated">在 &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; 标签提供了一种嵌入音频和视频，而无需复杂的附加件，如QuickTime或Flash中。</target>
        </trans-unit>
        <trans-unit id="9284002f0a972ad71394a02a769cae9cc166f343" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt; tag, which supports a powerful drawing API, reducing the need for server-generated images to present data graphically.</source>
          <target state="translated">所述 &lt;code&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt; 标记，它支持强大的绘图API，减少了图形服务器生成的图像，以本发明的数据的需要。</target>
        </trans-unit>
        <trans-unit id="4c4da8d133c76b505d4f6e0a49f78746c3435033" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--manage-script-name&lt;/code&gt; will move the handling of &lt;code&gt;SCRIPT_NAME&lt;/code&gt; to uwsgi, since it is smarter about that. It is used together with the &lt;code&gt;--mount&lt;/code&gt; directive which will make requests to &lt;code&gt;/yourapplication&lt;/code&gt; be directed to &lt;code&gt;myapp:app&lt;/code&gt;. If your application is accessible at root level, you can use a single &lt;code&gt;/&lt;/code&gt; instead of &lt;code&gt;/yourapplication&lt;/code&gt;. &lt;code&gt;myapp&lt;/code&gt; refers to the name of the file of your flask application (without extension) or the module which provides &lt;code&gt;app&lt;/code&gt;. &lt;code&gt;app&lt;/code&gt; is the callable inside of your application (usually the line reads &lt;code&gt;app = Flask(__name__)&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;--manage-script-name&lt;/code&gt; 将在处理移动 &lt;code&gt;SCRIPT_NAME&lt;/code&gt; 到uwsgi，因为它是关于聪明。它与 &lt;code&gt;--mount&lt;/code&gt; 指令一起使用，它将对 &lt;code&gt;/yourapplication&lt;/code&gt; 的请求定向到 &lt;code&gt;myapp:app&lt;/code&gt; 。如果您的应用程序可以在根级别访问，则可以使用单个 &lt;code&gt;/&lt;/code&gt; 代替 &lt;code&gt;/yourapplication&lt;/code&gt; 。 &lt;code&gt;myapp&lt;/code&gt; 是指flask应用程序的文件名（不带扩展名）或提供 &lt;code&gt;app&lt;/code&gt; 的模块的名称。 &lt;code&gt;app&lt;/code&gt; 是应用程序内部的可调用对象（通常该行显示为 &lt;code&gt;app = Flask(__name__)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="00a7c67795c40d848822d799fca9d24a793f93f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Authorization&lt;/code&gt; object in parsed form.</source>
          <target state="translated">解析形式的 &lt;code&gt;Authorization&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="796cc011894a7ed7941a5698bf972280305630e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FLASK_APP&lt;/code&gt; environment variable is the name of the module to import at &lt;strong&gt;flask run&lt;/strong&gt;. In case that module is incorrectly named you will get an import error upon start (or if debug is enabled when you navigate to the application). It will tell you what it tried to import and why it failed.</source>
          <target state="translated">该 &lt;code&gt;FLASK_APP&lt;/code&gt; 环境变量是模块进口处的名称&lt;strong&gt;烧瓶运行&lt;/strong&gt;。如果模块的名称不正确，则启动时会出现导入错误（或者在导航至应用程序时启用了调试）。它将告诉您尝试导入的内容以及失败的原因。</target>
        </trans-unit>
        <trans-unit id="82b3fbc027109cd3071cc38876fa08092497509d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PERMANENT_SESSION_LIFETIME&lt;/code&gt; config key can also be an integer starting with Flask 0.8. Either catch this down yourself or use the &lt;a href=&quot;#flask.Flask.permanent_session_lifetime&quot;&gt;&lt;code&gt;permanent_session_lifetime&lt;/code&gt;&lt;/a&gt; attribute on the app which converts the result to an integer automatically.</source>
          <target state="translated">所述 &lt;code&gt;PERMANENT_SESSION_LIFETIME&lt;/code&gt; 配置键也可以是一个整数开始从Flask 0.8。您可以自己解决这个问题，也可以在应用程序上使用&lt;a href=&quot;#flask.Flask.permanent_session_lifetime&quot;&gt; &lt;code&gt;permanent_session_lifetime&lt;/code&gt; &lt;/a&gt;属性，该属性会自动将结果转换为整数。</target>
        </trans-unit>
        <trans-unit id="43af1ec5f4de12a0fce461b1cc05c951accb2a6a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;YOUR_DSN_HERE&lt;/code&gt; value needs to be replaced with the DSN value you get from your Sentry installation.</source>
          <target state="translated">该 &lt;code&gt;YOUR_DSN_HERE&lt;/code&gt; 值需要与你从你的哨兵安装得到DSN值代替。</target>
        </trans-unit>
        <trans-unit id="40331467ce1c7eea794a054270139e5240b94c8b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;create_app&lt;/code&gt; factory in &lt;code&gt;hello&lt;/code&gt; is called with the string &lt;code&gt;'dev'&lt;/code&gt; as the argument.</source>
          <target state="translated">&lt;code&gt;hello&lt;/code&gt; 中的 &lt;code&gt;create_app&lt;/code&gt; 工厂以字符串 &lt;code&gt;'dev'&lt;/code&gt; 作为参数调用。</target>
        </trans-unit>
        <trans-unit id="0a9466b28125c9ff792aa3961f37568e615f9633" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flask&lt;/code&gt; command is implemented using &lt;a href=&quot;https://click.palletsprojects.com/&quot;&gt;Click&lt;/a&gt;. See that project&amp;rsquo;s documentation for full information about writing commands.</source>
          <target state="translated">该 &lt;code&gt;flask&lt;/code&gt; 命令使用实现&lt;a href=&quot;https://click.palletsprojects.com/&quot;&gt;点击&lt;/a&gt;。有关编写命令的完整信息，请参见该项目的文档。</target>
        </trans-unit>
        <trans-unit id="957bc84b42bb3b151eded48af17982b3cd1047da" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flask&lt;/code&gt; command is installed by Flask, not your application; it must be told where to find your application in order to use it. The &lt;code&gt;FLASK_APP&lt;/code&gt; environment variable is used to specify how to load the application.</source>
          <target state="translated">该 &lt;code&gt;flask&lt;/code&gt; 命令是由瓶，不是你的应用程序安装的; 必须告诉它在哪里可以找到您的应用程序才能使用它。该 &lt;code&gt;FLASK_APP&lt;/code&gt; 环境变量用于指定如何加载应用程序。</target>
        </trans-unit>
        <trans-unit id="cdea8349411bc76f6bfb74411c77888e4be9c302" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flask&lt;/code&gt; command will show a message if it detects dotenv files but python-dotenv is not installed.</source>
          <target state="translated">该 &lt;code&gt;flask&lt;/code&gt; 如果它检测到dotenv文件，但没有安装的python-dotenv命令将显示一条消息。</target>
        </trans-unit>
        <trans-unit id="9964fe5f3732d4868da6dc3e4a360d9d75d1a5d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flask&lt;/code&gt; command, being separate from your code, does not have this issue and is recommended in most cases.</source>
          <target state="translated">与您的代码分开的 &lt;code&gt;flask&lt;/code&gt; 命令没有此问题，在大多数情况下建议使用。</target>
        </trans-unit>
        <trans-unit id="2eb3d8a3ae9f13d587846c5ea7bbc32f12d9b29b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;follow_redirects&lt;/code&gt; parameter was added to &lt;a href=&quot;#flask.testing.FlaskClient.open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;follow_redirects&lt;/code&gt; 参数添加到&lt;a href=&quot;#flask.testing.FlaskClient.open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d324d9ae8323e8091b3e6f8ecaf6135ebd0bfd97" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;g&lt;/code&gt; name stands for &amp;ldquo;global&amp;rdquo;, but that is referring to the data being global &lt;em&gt;within a context&lt;/em&gt;. The data on &lt;code&gt;g&lt;/code&gt; is lost after the context ends, and it is not an appropriate place to store data between requests. Use the &lt;a href=&quot;../api/index#flask.session&quot;&gt;&lt;code&gt;session&lt;/code&gt;&lt;/a&gt; or a database to store data across requests.</source>
          <target state="translated">该 &lt;code&gt;g&lt;/code&gt; 名代表&amp;ldquo;全球性&amp;rdquo;，但指的是数据是全球的&lt;em&gt;一个范围内&lt;/em&gt;。上下文结束后， &lt;code&gt;g&lt;/code&gt; 上的数据会丢失，因此不适合在请求之间存储数据。使用&lt;a href=&quot;../api/index#flask.session&quot;&gt; &lt;code&gt;session&lt;/code&gt; &lt;/a&gt;或数据库来存储跨请求的数据。</target>
        </trans-unit>
        <trans-unit id="7df769e9aab69d441c27554f8156c509339cdd1d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gunicorn&lt;/code&gt; command expects the names of your application module or package and the application instance within the module. If you use the application factory pattern, you can pass a call to that:</source>
          <target state="translated">该 &lt;code&gt;gunicorn&lt;/code&gt; 命令需要您的应用程序模块或组件和模块内的应用实例的名称。如果您使用应用程序工厂模式，则可以将调用传递给该工厂模式：</target>
        </trans-unit>
        <trans-unit id="5b7278b0077e6c6d8f3ed4464d43f4ae51ed6d52" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;htmlsafe_dumps()&lt;/code&gt; function of this json module is also available as a filter called &lt;code&gt;|tojson&lt;/code&gt; in Jinja2. Note that in versions of Flask prior to Flask 0.10, you must disable escaping with &lt;code&gt;|safe&lt;/code&gt; if you intend to use &lt;code&gt;|tojson&lt;/code&gt; output inside &lt;code&gt;script&lt;/code&gt; tags. In Flask 0.10 and above, this happens automatically (but it&amp;rsquo;s harmless to include &lt;code&gt;|safe&lt;/code&gt; anyway).</source>
          <target state="translated">此json模块的 &lt;code&gt;htmlsafe_dumps()&lt;/code&gt; 函数也可以作为Jinja2中称为 &lt;code&gt;|tojson&lt;/code&gt; 的过滤器使用。请注意，在Flask 0.10之前的Flask版本中，如果打算在 &lt;code&gt;script&lt;/code&gt; 标记内使用 &lt;code&gt;|tojson&lt;/code&gt; 输出，则必须使用 &lt;code&gt;|safe&lt;/code&gt; 禁用转义。在Flask 0.10及更高版本中，这是自动发生的（但是无论如何包含 &lt;code&gt;|safe&lt;/code&gt; 无害的）。</target>
        </trans-unit>
        <trans-unit id="e90a3dda5b106d92820db4d4fd314fa6eb5c5e74" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;next&lt;/code&gt; value will exist in &lt;code&gt;request.args&lt;/code&gt; after a &lt;code&gt;GET&lt;/code&gt; request for the login page. You&amp;rsquo;ll have to pass it along when sending the &lt;code&gt;POST&lt;/code&gt; request from the login form. You can do this with a hidden input tag, then retrieve it from &lt;code&gt;request.form&lt;/code&gt; when logging the user in.</source>
          <target state="translated">在 &lt;code&gt;next&lt;/code&gt; 值会存在 &lt;code&gt;request.args&lt;/code&gt; 中一后 &lt;code&gt;GET&lt;/code&gt; 登录页面的请求。从登录表单发送 &lt;code&gt;POST&lt;/code&gt; 请求时，您必须将其传递。您可以使用隐藏的输入标签来执行此操作，然后在登录用户时从 &lt;code&gt;request.form&lt;/code&gt; 检索它。</target>
        </trans-unit>
        <trans-unit id="a2a54a3e7c04a09c0163166e4bd5826ebafa2cf6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;your_application&lt;/code&gt; string has to point to your application&amp;rsquo;s package or module that creates the &lt;code&gt;celery&lt;/code&gt; object.</source>
          <target state="translated">该 &lt;code&gt;your_application&lt;/code&gt; 字符串必须指向你的应用程序包或模块创建 &lt;code&gt;celery&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="b93850e1e982157409fb47ebcda066f282098e08" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{% extends %}&lt;/code&gt; tag is the key here. It tells the template engine that this template &amp;ldquo;extends&amp;rdquo; another template. When the template system evaluates this template, first it locates the parent. The extends tag must be the first tag in the template. To render the contents of a block defined in the parent template, use &lt;code&gt;{{ super() }}&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;{% extends %}&lt;/code&gt; 标签是这里的关键。它告诉模板引擎该模板&amp;ldquo;扩展&amp;rdquo;了另一个模板。模板系统评估此模板时，首先会找到父模板。extend标签必须是模板中的第一个标签。要呈现父模板中定义的块的内容，请使用 &lt;code&gt;{{ super() }}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="af17fd896774af79fa0c34caea740b31193ce6e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;|safe&lt;/code&gt; is necessary in Flask before 0.10 so that Jinja does not escape the JSON encoded string with HTML rules. Usually this would be necessary, but we are inside a &lt;code&gt;script&lt;/code&gt; block here where different rules apply.</source>
          <target state="translated">在0.10之前的Flask中， &lt;code&gt;|safe&lt;/code&gt; 是必需的，因此Jinja不会使用HTML规则转义JSON编码的字符串。通常这是必要的，但我们在此处适用不同规则的 &lt;code&gt;script&lt;/code&gt; 块中。</target>
        </trans-unit>
        <trans-unit id="1408d0b2bbe8b9c12ea2a83885ea1f6fe484694f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;Parameters&lt;/em&gt; field (&lt;strong&gt;B&lt;/strong&gt;) is set to the CLI command to execute (with any arguments). In this example we use &lt;code&gt;run&lt;/code&gt;, which will run the development server.</source>
          <target state="translated">的&lt;em&gt;参数&lt;/em&gt;字段（&lt;strong&gt;乙&lt;/strong&gt;）被设置到CLI命令来执行（与任何参数）。在此示例中，我们使用 &lt;code&gt;run&lt;/code&gt; ，它将运行开发服务器。</target>
        </trans-unit>
        <trans-unit id="63bfe716070cd2f85402e9dfb19f62bbd1823ffb" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;flask&lt;/strong&gt; command line script (&lt;a href=&quot;../cli/index#cli&quot;&gt;Command Line Interface&lt;/a&gt;) is strongly recommended for development because it provides a superior reload experience due to how it loads the application. The basic usage is like this:</source>
          <target state="translated">强烈建议使用&lt;strong&gt;flask&lt;/strong&gt;命令行脚本（&lt;a href=&quot;../cli/index#cli&quot;&gt;Command Line Interface&lt;/a&gt;）进行开发，因为由于其加载应用程序的方式，它提供了卓越的重新加载体验。基本用法是这样的：</target>
        </trans-unit>
        <trans-unit id="34fb97a0c3a2b4ca42e03bd84ade64dbb4cf1a79" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;flask&lt;/strong&gt; script is nice to start a local development server, but you would have to restart it manually after each change to your code. That is not very nice and Flask can do better. If you enable debug support the server will reload itself on code changes, and it will also provide you with a helpful debugger if things go wrong.</source>
          <target state="translated">该&lt;strong&gt;瓶&lt;/strong&gt;脚本是好的启动本地开发服务器，但你必须给每个改变了代码后手动重新启动它。那不是很好，Flask可以做得更好。如果启用调试支持，则服务器将在代码更改时重新加载自身，如果出现问题，它还将为您提供有用的调试器。</target>
        </trans-unit>
        <trans-unit id="1d490a8a1059daba5888b91c9edfe86ef998ed84" translate="yes" xml:space="preserve">
          <source>The Application</source>
          <target state="translated">应用</target>
        </trans-unit>
        <trans-unit id="f12486bb318cd887136c742016977b2bf2eb2d1f" translate="yes" xml:space="preserve">
          <source>The Application Context</source>
          <target state="translated">应用上下文</target>
        </trans-unit>
        <trans-unit id="67b0e95011d6255ab934c85f27879fb8e8cfafc9" translate="yes" xml:space="preserve">
          <source>The Concept of Blueprints</source>
          <target state="translated">蓝图的概念</target>
        </trans-unit>
        <trans-unit id="1aebbb26bd2f649e62a57f9768ee410483844a2f" translate="yes" xml:space="preserve">
          <source>The Configuration File</source>
          <target state="translated">配置文件</target>
        </trans-unit>
        <trans-unit id="dec50acd29d2736ad423db2e82324ad88ed1003b" translate="yes" xml:space="preserve">
          <source>The Content-Encoding entity-header field is used as a modifier to the media-type. When present, its value indicates what additional content codings have been applied to the entity-body, and thus what decoding mechanisms must be applied in order to obtain the media-type referenced by the Content-Type header field.</source>
          <target state="translated">Content-Encoding实体头字段被用作媒体类型的修饰符。如果存在,它的值表示对实体主体应用了哪些额外的内容编码,因此必须应用哪些解码机制才能获得Content-Type头字段所引用的媒体类型。</target>
        </trans-unit>
        <trans-unit id="97caa4b0f397680c8eeefda38dc644ffc4d7d96a" translate="yes" xml:space="preserve">
          <source>The Content-Length entity-header field indicates the size of the entity-body in bytes or, in the case of the HEAD method, the size of the entity-body that would have been sent had the request been a GET.</source>
          <target state="translated">Content-Length实体头字段以字节为单位表示实体主体的大小,或者,在HEAD方法的情况下,表示如果请求是GET,将被发送的实体主体的大小。</target>
        </trans-unit>
        <trans-unit id="a4703ab6700703c677f880928f854b7a8be748ad" translate="yes" xml:space="preserve">
          <source>The Content-MD5 entity-header field, as defined in RFC 1864, is an MD5 digest of the entity-body for the purpose of providing an end-to-end message integrity check (MIC) of the entity-body. (Note: a MIC is good for detecting accidental modification of the entity-body in transit, but is not proof against malicious attacks.)</source>
          <target state="translated">RFC 1864中定义的Content-MD5实体头字段是实体主体的MD5摘要,目的是提供实体主体的端到端消息完整性检查(MIC)。(注意:MIC有利于检测实体主体在传输过程中的意外修改,但不能证明可以防止恶意攻击)。</target>
        </trans-unit>
        <trans-unit id="0b7cfc0dba145ac8031fb0855e7e3468b5963b6d" translate="yes" xml:space="preserve">
          <source>The Content-Type entity-header field indicates the media type of the entity-body sent to the recipient or, in the case of the HEAD method, the media type that would have been sent had the request been a GET.</source>
          <target state="translated">Content-Type实体头字段表示发送给接收者的实体主体的媒体类型,或者,在HEAD方法的情况下,如果请求是GET,则会发送的媒体类型。</target>
        </trans-unit>
        <trans-unit id="8c86e72d6d75652eda14adb1731029981017d99c" translate="yes" xml:space="preserve">
          <source>The Date general-header field represents the date and time at which the message was originated, having the same semantics as orig-date in RFC 822.</source>
          <target state="translated">Date总头字段表示消息发起的日期和时间,与RFC 822中的orig-date语义相同。</target>
        </trans-unit>
        <trans-unit id="36d28052c95f8f155c1ada5ac877f44df3bb6e51" translate="yes" xml:space="preserve">
          <source>The Explicit Application Object</source>
          <target state="translated">显式应用对象</target>
        </trans-unit>
        <trans-unit id="0b2ad8555c94a28e5d08779d5509cb9af280071d" translate="yes" xml:space="preserve">
          <source>The Extension Code</source>
          <target state="translated">扩展码</target>
        </trans-unit>
        <trans-unit id="58ca7a1f3297d149bb64fb85cba26fbd9ab2a6db" translate="yes" xml:space="preserve">
          <source>The First Test</source>
          <target state="translated">第一次测试</target>
        </trans-unit>
        <trans-unit id="f6fd3d3e7278c2d47928fc9be918ff49aafc0da6" translate="yes" xml:space="preserve">
          <source>The Flask developers keep the framework accessible to users with codebases big and small. If you find an obstacle in your way, caused by Flask, don&amp;rsquo;t hesitate to contact the developers on the mailing list or Discord server. The best way for the Flask and Flask extension developers to improve the tools for larger applications is getting feedback from users.</source>
          <target state="translated">Flask开发人员使用大小不同的代码库，使用户可以访问该框架。如果您发现由Flask造成的障碍，请随时与邮件列表或Discord服务器上的开发人员联系。Flask和Flask扩展开发人员改善大型应用程序工具的最佳方法是从用户那里获得反馈。</target>
        </trans-unit>
        <trans-unit id="dd2c22256565f85146005f7e5cf1f1f57c7f4c79" translate="yes" xml:space="preserve">
          <source>The Flask documentation and example applications are using HTML5. You may notice that in many situations, when end tags are optional they are not used, so that the HTML is cleaner and faster to load. Because there is much confusion about HTML and XHTML among developers, this document tries to answer some of the major questions.</source>
          <target state="translated">Flask文档和示例应用程序使用的是HTML5。您可能会注意到,在许多情况下,当结束标签是可选的时,它们不会被使用,这样HTML会更干净,加载速度更快。由于开发人员对HTML和XHTML有很多困惑,本文档试图回答一些主要问题。</target>
        </trans-unit>
        <trans-unit id="527b8895baf9947c67764ae5550fc37e6d739a03" translate="yes" xml:space="preserve">
          <source>The Forms</source>
          <target state="translated">表格</target>
        </trans-unit>
        <trans-unit id="1bd6bcd9b53323f11ffdb117b44ce6eabb0339a8" translate="yes" xml:space="preserve">
          <source>The Golden Rule</source>
          <target state="translated">黄金法则</target>
        </trans-unit>
        <trans-unit id="bd34ad3e2da2c4a3b49d9733d22a04b865b144c5" translate="yes" xml:space="preserve">
          <source>The HTML</source>
          <target state="translated">HTML</target>
        </trans-unit>
        <trans-unit id="73979a341cfc9090c5debdd08f7a260c4f575eb3" translate="yes" xml:space="preserve">
          <source>The Jinja Context Behavior</source>
          <target state="translated">金家语境行为</target>
        </trans-unit>
        <trans-unit id="63c699c67a54daf802e28fdee5e637f2ecaf83b4" translate="yes" xml:space="preserve">
          <source>The Jinja environment used to load templates.</source>
          <target state="translated">用于加载模板的Jinja环境。</target>
        </trans-unit>
        <trans-unit id="221259db9efb3501c3a95d414b2e85b277d60807" translate="yes" xml:space="preserve">
          <source>The Jinja loader for this package bound object.</source>
          <target state="translated">这个包绑定对象的Jinja加载器。</target>
        </trans-unit>
        <trans-unit id="af6b3f47a2d8ac940b1ebc02423377a3ccef5042" translate="yes" xml:space="preserve">
          <source>The Jinja2 template engine also supports rendering templates piece by piece. This functionality is not directly exposed by Flask because it is quite uncommon, but you can easily do it yourself:</source>
          <target state="translated">Jinja2模板引擎还支持逐块渲染模板。这个功能因为很不常见,所以Flask并没有直接暴露出来,但是你可以很容易的自己完成。</target>
        </trans-unit>
        <trans-unit id="798020449f134f80412accf053749b8a15def0d0" translate="yes" xml:space="preserve">
          <source>The Max-Forwards request-header field provides a mechanism with the TRACE and OPTIONS methods to limit the number of proxies or gateways that can forward the request to the next inbound server.</source>
          <target state="translated">最大转发请求头字段与TRACE和OPTIONS方法一起提供了一种机制,以限制可以将请求转发到下一个入站服务器的代理或网关的数量。</target>
        </trans-unit>
        <trans-unit id="e4c08664a343ce23990542efa9cee3c2e4895255" translate="yes" xml:space="preserve">
          <source>The Pragma general-header field is used to include implementation-specific directives that might apply to any recipient along the request/response chain. All pragma directives specify optional behavior from the viewpoint of the protocol; however, some systems MAY require that behavior be consistent with the directives.</source>
          <target state="translated">Pragma总头字段用于包含可能适用于请求/响应链上任何接收者的特定实施指令。所有pragma指令都从协议的角度指定了可选的行为;然而,一些系统可能要求行为与指令一致。</target>
        </trans-unit>
        <trans-unit id="fe93415c606912dff738740b9170779ef15371f7" translate="yes" xml:space="preserve">
          <source>The Referer[sic] request-header field allows the client to specify, for the server&amp;rsquo;s benefit, the address (URI) of the resource from which the Request-URI was obtained (the &amp;ldquo;referrer&amp;rdquo;, although the header field is misspelled).</source>
          <target state="translated">Referer [sic] request-header字段允许客户端为服务器的利益指定从中获取Request-URI的资源的地址（URI）（&amp;ldquo; referrer&amp;rdquo;，尽管该标题字段拼写错误）。</target>
        </trans-unit>
        <trans-unit id="323c0560d73e4d10ab8e196ea97bf18454f64681" translate="yes" xml:space="preserve">
          <source>The Request Context</source>
          <target state="translated">请求上下文</target>
        </trans-unit>
        <trans-unit id="1a125dacc4a120b926c360f0779ef82e15913b92" translate="yes" xml:space="preserve">
          <source>The Request Object</source>
          <target state="translated">请求对象</target>
        </trans-unit>
        <trans-unit id="e510e168af4c6fad2e81024da262fe395459b90d" translate="yes" xml:space="preserve">
          <source>The Routing System</source>
          <target state="translated">路由系统</target>
        </trans-unit>
        <trans-unit id="1b3141dce1e0cd3fe4e0914ed0d2bd5c5f984839" translate="yes" xml:space="preserve">
          <source>The Testing Skeleton</source>
          <target state="translated">测试骨架</target>
        </trans-unit>
        <trans-unit id="62df2008444856eb510873fe9ffbb945bc0f1bb0" translate="yes" xml:space="preserve">
          <source>The URL parameters as raw bytestring.</source>
          <target state="translated">URL参数为原始字节码。</target>
        </trans-unit>
        <trans-unit id="487e8868132966726ce7cb5c128e228c3b7bbfb8" translate="yes" xml:space="preserve">
          <source>The URL prefix that the static route will be accessible from.</source>
          <target state="translated">静态路由的URL前缀。</target>
        </trans-unit>
        <trans-unit id="70cd570ce7a9d582f40ee5a862bafb3881ff1af1" translate="yes" xml:space="preserve">
          <source>The WSGI File</source>
          <target state="translated">WSGI文件</target>
        </trans-unit>
        <trans-unit id="955782dd4c895699af298ed109fe7ae90f73049f" translate="yes" xml:space="preserve">
          <source>The WSGI file has to import the application and also to set an environment variable so that the application knows where to look for the config. This is a short example that does exactly that:</source>
          <target state="translated">WSGI文件必须导入应用程序,同时还要设置一个环境变量,以便应用程序知道在哪里寻找config。这是个简短的例子,正是这样做的。</target>
        </trans-unit>
        <trans-unit id="3e9731a60f3384414c5704ec04e647b53a7f2706" translate="yes" xml:space="preserve">
          <source>The above will serve the icon via your application and if possible it&amp;rsquo;s better to configure your dedicated web server to serve it; refer to the web server&amp;rsquo;s documentation.</source>
          <target state="translated">上面的代码将通过您的应用程序提供图标，如果可能的话，最好配置专用的Web服务器来提供图标；请参阅Web服务器的文档。</target>
        </trans-unit>
        <trans-unit id="f43591db42c68d2de10ed9acf975d1382100f758" translate="yes" xml:space="preserve">
          <source>The absolute path to the configured static folder.</source>
          <target state="translated">配置的静态文件夹的绝对路径。</target>
        </trans-unit>
        <trans-unit id="c9a5bed2976d752ec92670bddb2868a54c411e1a" translate="yes" xml:space="preserve">
          <source>The actual WSGI application. This is not implemented in &lt;code&gt;__call__()&lt;/code&gt; so that middlewares can be applied without losing a reference to the app object. Instead of doing this:</source>
          <target state="translated">实际的WSGI应用程序。这不是在 &lt;code&gt;__call__()&lt;/code&gt; 实现的，因此可以在不丢失对应用程序对象的引用的情况下应用中间件。而不是这样做：</target>
        </trans-unit>
        <trans-unit id="709b9007c8420cd50aefece3158abfa039dffa6d" translate="yes" xml:space="preserve">
          <source>The alternative way to start the application is through the &lt;a href=&quot;../api/index#flask.Flask.run&quot;&gt;&lt;code&gt;Flask.run()&lt;/code&gt;&lt;/a&gt; method. This will immediately launch a local server exactly the same way the &lt;strong&gt;flask&lt;/strong&gt; script does.</source>
          <target state="translated">启动应用程序的另一种方法是通过&lt;a href=&quot;../api/index#flask.Flask.run&quot;&gt; &lt;code&gt;Flask.run()&lt;/code&gt; &lt;/a&gt;方法。这将立即与&lt;strong&gt;flask&lt;/strong&gt;脚本相同的方式启动本地服务器。</target>
        </trans-unit>
        <trans-unit id="217c14f441e1493787e68e395380a07f0245f9ac" translate="yes" xml:space="preserve">
          <source>The answer is by using generators and direct responses.</source>
          <target state="translated">答案是通过使用生成器和直接反应。</target>
        </trans-unit>
        <trans-unit id="8d7c06be37d6514c040b04498fe6dec9f30eb6f8" translate="yes" xml:space="preserve">
          <source>The application accesses the file from the &lt;code&gt;files&lt;/code&gt; dictionary on the request object.</source>
          <target state="translated">应用程序从请求对象上的 &lt;code&gt;files&lt;/code&gt; 字典访问文件。</target>
        </trans-unit>
        <trans-unit id="67f3e86de8f29b28db0c96cca7939c968e7a85b7" translate="yes" xml:space="preserve">
          <source>The application already has to be a package and requires a working &lt;code&gt;setup.py&lt;/code&gt; file (&lt;a href=&quot;../distribute/index#distribute-deployment&quot;&gt;Deploying with Setuptools&lt;/a&gt;).</source>
          <target state="translated">该应用程序必须已经是一个软件包，并且需要一个有效的 &lt;code&gt;setup.py&lt;/code&gt; 文件（&lt;a href=&quot;../distribute/index#distribute-deployment&quot;&gt;使用Setuptools进行部署&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="c6f2aa299ec34b19a2399dca5effd4be8c0017ba" translate="yes" xml:space="preserve">
          <source>The application context binds an application object implicitly to the current thread or greenlet, similar to how the &lt;a href=&quot;#flask.ctx.RequestContext&quot;&gt;&lt;code&gt;RequestContext&lt;/code&gt;&lt;/a&gt; binds request information. The application context is also implicitly created if a request context is created but the application is not on top of the individual application context.</source>
          <target state="translated">应用上下文隐式绑定的应用对象到当前线程或greenlet，类似于如何&lt;a href=&quot;#flask.ctx.RequestContext&quot;&gt; &lt;code&gt;RequestContext&lt;/code&gt; &lt;/a&gt;结合请求信息。如果创建了请求上下文，但该应用程序不在单个应用程序上下文的顶部，则也会隐式创建应用程序上下文。</target>
        </trans-unit>
        <trans-unit id="ff27c12dc44f7f97ad8fd8ea226efacdad577459" translate="yes" xml:space="preserve">
          <source>The application context is a good place to store common data during a request or CLI command. Flask provides the &lt;a href=&quot;../api/index#flask.g&quot;&gt;&lt;code&gt;g object&lt;/code&gt;&lt;/a&gt; for this purpose. It is a simple namespace object that has the same lifetime as an application context.</source>
          <target state="translated">应用程序上下文是在请求或CLI命令期间存储公用数据的好地方。Flask为此提供了&lt;a href=&quot;../api/index#flask.g&quot;&gt; &lt;code&gt;g object&lt;/code&gt; &lt;/a&gt;。它是一个简单的名称空间对象，与应用程序上下文具有相同的生存期。</target>
        </trans-unit>
        <trans-unit id="e5015a9b1db8e7dc107c47faf7d3f571e080c570" translate="yes" xml:space="preserve">
          <source>The application context is created and destroyed as necessary. When a Flask application begins handling a request, it pushes an application context and a &lt;a href=&quot;../reqcontext/index&quot;&gt;request context&lt;/a&gt;. When the request ends it pops the request context then the application context. Typically, an application context will have the same lifetime as a request.</source>
          <target state="translated">应用程序上下文会根据需要创建和销毁。当Flask应用程序开始处理请求时，它将推送应用程序上下文和&lt;a href=&quot;../reqcontext/index&quot;&gt;请求上下文&lt;/a&gt;。当请求结束时，它会弹出请求上下文，然后弹出应用程序上下文。通常，应用程序上下文将与请求具有相同的生存期。</target>
        </trans-unit>
        <trans-unit id="aedc5f8038f3c4a23ca2b32f9b4732cebe3905d1" translate="yes" xml:space="preserve">
          <source>The application context keeps track of the application-level data during a request, CLI command, or other activity. Rather than passing the application around to each function, the &lt;a href=&quot;../api/index#flask.current_app&quot;&gt;&lt;code&gt;current_app&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../api/index#flask.g&quot;&gt;&lt;code&gt;g&lt;/code&gt;&lt;/a&gt; proxies are accessed instead.</source>
          <target state="translated">在请求，CLI命令或其他活动期间，应用程序上下文会跟踪应用程序级别的数据。而不是将应用程序传递给每个函数，而是访问&lt;a href=&quot;../api/index#flask.current_app&quot;&gt; &lt;code&gt;current_app&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../api/index#flask.g&quot;&gt; &lt;code&gt;g&lt;/code&gt; &lt;/a&gt;代理。</target>
        </trans-unit>
        <trans-unit id="abf31a5ec85c1c0680fe3e6700cfab4d8d09149a" translate="yes" xml:space="preserve">
          <source>The application itself then has to initialize itself like this to look for the config at that environment variable:</source>
          <target state="translated">然后,应用程序本身要像这样初始化自己,在该环境变量处查找配置。</target>
        </trans-unit>
        <trans-unit id="f735e9da0f3cd4d0b086a89cf2943c4655c0fe40" translate="yes" xml:space="preserve">
          <source>The application will call functions registered with &lt;a href=&quot;../api/index#flask.Flask.teardown_appcontext&quot;&gt;&lt;code&gt;teardown_appcontext()&lt;/code&gt;&lt;/a&gt; when the application context is popped.</source>
          <target state="translated">弹出应用程序上下文时，应用程序将调用在&lt;a href=&quot;../api/index#flask.Flask.teardown_appcontext&quot;&gt; &lt;code&gt;teardown_appcontext()&lt;/code&gt; 中&lt;/a&gt;注册的函数。</target>
        </trans-unit>
        <trans-unit id="b7b752d64a25dcf529eca9ac7aea39b655b4eb6c" translate="yes" xml:space="preserve">
          <source>The arguments passed to &lt;a href=&quot;#flask.views.View.as_view&quot;&gt;&lt;code&gt;as_view()&lt;/code&gt;&lt;/a&gt; are forwarded to the constructor of the class.</source>
          <target state="translated">传递给&lt;a href=&quot;#flask.views.View.as_view&quot;&gt; &lt;code&gt;as_view()&lt;/code&gt; &lt;/a&gt;的参数将转发给该类的构造函数。</target>
        </trans-unit>
        <trans-unit id="a6625cc9a7f49dfcff7f90c71c0e34188e1781ae" translate="yes" xml:space="preserve">
          <source>The attached &lt;a href=&quot;../api/index#flask.Flask.logger&quot;&gt;&lt;code&gt;logger&lt;/code&gt;&lt;/a&gt; is a standard logging &lt;a href=&quot;https://docs.python.org/3/library/logging.html#logging.Logger&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt;, so head over to the official &lt;a href=&quot;https://docs.python.org/3/library/logging.html#module-logging&quot;&gt;&lt;code&gt;logging&lt;/code&gt;&lt;/a&gt; docs for more information.</source>
          <target state="translated">随附的&lt;a href=&quot;../api/index#flask.Flask.logger&quot;&gt; &lt;code&gt;logger&lt;/code&gt; &lt;/a&gt;是标准的Logging &lt;a href=&quot;https://docs.python.org/3/library/logging.html#logging.Logger&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt;，因此请访问官方的&lt;a href=&quot;https://docs.python.org/3/library/logging.html#module-logging&quot;&gt; &lt;code&gt;logging&lt;/code&gt; &lt;/a&gt;文档以获取更多信息。</target>
        </trans-unit>
        <trans-unit id="e62d325725d818b241af8195de04f38c8d171590" translate="yes" xml:space="preserve">
          <source>The basic concept of blueprints is that they record operations to execute when registered on an application. Flask associates view functions with blueprints when dispatching requests and generating URLs from one endpoint to another.</source>
          <target state="translated">蓝图的基本概念是,它们记录了在应用程序上注册时要执行的操作。Flask在调度请求和从一个端点到另一个端点生成URL时,将视图函数与蓝图关联起来。</target>
        </trans-unit>
        <trans-unit id="802685c9de191e4764287fc3a4e4229e3c4f3ff2" translate="yes" xml:space="preserve">
          <source>The basic idea is to introduce a new exception that can take a proper human readable message, a status code for the error and some optional payload to give more context for the error.</source>
          <target state="translated">基本的想法是引入一个新的异常,它可以采取一个适当的人类可读的消息,一个错误的状态代码和一些可选的有效载荷,为错误提供更多的上下文。</target>
        </trans-unit>
        <trans-unit id="cb8b72649ffbcf7897d911700ab070e2bccaff05" translate="yes" xml:space="preserve">
          <source>The basic interface you have to implement in order to replace the default session interface which uses werkzeug&amp;rsquo;s securecookie implementation. The only methods you have to implement are &lt;a href=&quot;#flask.sessions.SessionInterface.open_session&quot;&gt;&lt;code&gt;open_session()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#flask.sessions.SessionInterface.save_session&quot;&gt;&lt;code&gt;save_session()&lt;/code&gt;&lt;/a&gt;, the others have useful defaults which you don&amp;rsquo;t need to change.</source>
          <target state="translated">您必须实现基本接口才能替换使用werkzeug的securecookie实现的默认会话接口。您唯一需要实现的方法是&lt;a href=&quot;#flask.sessions.SessionInterface.open_session&quot;&gt; &lt;code&gt;open_session()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#flask.sessions.SessionInterface.save_session&quot;&gt; &lt;code&gt;save_session()&lt;/code&gt; &lt;/a&gt;，其他方法都具有有用的默认值，您无需更改它们。</target>
        </trans-unit>
        <trans-unit id="eba0c9b1b0b76d4cea731590114b559f17148389" translate="yes" xml:space="preserve">
          <source>The better solution than using &lt;code&gt;abort&lt;/code&gt; to signal errors for invalid API usage is to implement your own exception type and install an error handler for it that produces the errors in the format the user is expecting.</source>
          <target state="translated">与使用 &lt;code&gt;abort&lt;/code&gt; 来指示错误使用无效的API相比，更好的解决方案是实现自己的异常类型并为其安装错误处理程序，该错误处理程序以用户期望的格式产生错误。</target>
        </trans-unit>
        <trans-unit id="492b7977821b97e7d5e5be04af402f9cd44885be" translate="yes" xml:space="preserve">
          <source>The big advantage of signals over handlers is that you can safely subscribe to them for just a split second. These temporary subscriptions are helpful for unit testing for example. Say you want to know what templates were rendered as part of a request: signals allow you to do exactly that.</source>
          <target state="translated">与处理程序相比,信号的最大优势在于,你可以安全地订阅它们,只需一瞬间。例如,这些临时订阅对单元测试很有帮助。比如说你想知道作为请求的一部分渲染了哪些模板:信号允许你这样做。</target>
        </trans-unit>
        <trans-unit id="b59854ed109338566dff6c5bc4d3a15e8cf4e8f6" translate="yes" xml:space="preserve">
          <source>The big difference between this and the subdomain one is that this one falls back to another application if the creator function returns &lt;code&gt;None&lt;/code&gt;:</source>
          <target state="translated">此子域与子域之间的最大区别是，如果创建者函数返回 &lt;code&gt;None&lt;/code&gt; ，则该域将退回到另一应用程序：</target>
        </trans-unit>
        <trans-unit id="fe1c777fdc4b522c6eb716f87467267a0eb2b332" translate="yes" xml:space="preserve">
          <source>The browser will try to prevent reflected XSS attacks by not loading the page if the request contains something that looks like JavaScript and the response contains the same data.</source>
          <target state="translated">如果请求中包含类似JavaScript的内容,且响应中包含相同的数据,浏览器将尝试通过不加载页面来防止反射XSS攻击。</target>
        </trans-unit>
        <trans-unit id="6b4209d8b1baf7e97f728cfa111110e3bd7e0966" translate="yes" xml:space="preserve">
          <source>The canonical URL for the &lt;code&gt;about&lt;/code&gt; endpoint does not have a trailing slash. It&amp;rsquo;s similar to the pathname of a file. Accessing the URL with a trailing slash produces a 404 &amp;ldquo;Not Found&amp;rdquo; error. This helps keep URLs unique for these resources, which helps search engines avoid indexing the same page twice.</source>
          <target state="translated">&lt;code&gt;about&lt;/code&gt; 端点的规范URL不带斜杠。它类似于文件的路径名。使用斜杠访问URL会产生404&amp;ldquo;未找到&amp;rdquo;错误。这有助于使这些资源的URL保持唯一，从而有助于搜索引擎避免对同一页面进行两次索引。</target>
        </trans-unit>
        <trans-unit id="5461b8241cf734ebb20363498eb8c7d0fed0989c" translate="yes" xml:space="preserve">
          <source>The canonical URL for the &lt;code&gt;projects&lt;/code&gt; endpoint has a trailing slash. It&amp;rsquo;s similar to a folder in a file system. If you access the URL without a trailing slash, Flask redirects you to the canonical URL with the trailing slash.</source>
          <target state="translated">&lt;code&gt;projects&lt;/code&gt; 终结点的规范URL带有斜杠。它类似于文件系统中的文件夹。如果您访问的URL不带斜杠，Flask会将您重定向到带斜杠的规范URL。</target>
        </trans-unit>
        <trans-unit id="28acb08216d29211f7078c1fc06051ab01515f1a" translate="yes" xml:space="preserve">
          <source>The canonical way to decorate class-based views is to decorate the return value of as_view(). However since this moves parts of the logic from the class declaration to the place where it&amp;rsquo;s hooked into the routing system.</source>
          <target state="translated">装饰基于类的视图的规范方法是装饰as_view（）的返回值。但是，由于这会将逻辑的一部分从类声明移到钩接到路由系统的地方。</target>
        </trans-unit>
        <trans-unit id="f2f6de6ecf2a03d25db85259f88cafe727cb8dc2" translate="yes" xml:space="preserve">
          <source>The charset that is assumed for URLs. Defaults to the value of &lt;code&gt;charset&lt;/code&gt;.</source>
          <target state="translated">URL假定的字符集。默认为 &lt;code&gt;charset&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="209ebd3248735054a2bd8cc848a89b192dc4ff72" translate="yes" xml:space="preserve">
          <source>The code above will limit the maximum allowed payload to 16 megabytes. If a larger file is transmitted, Flask will raise a &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/exceptions/#werkzeug.exceptions.RequestEntityTooLarge&quot;&gt;&lt;code&gt;RequestEntityTooLarge&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">上面的代码将允许的最大有效负载限制为16 MB。如果传输了更大的文件，Flask将引发&lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/exceptions/#werkzeug.exceptions.RequestEntityTooLarge&quot;&gt; &lt;code&gt;RequestEntityTooLarge&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="e27c5f6151f5f6084ef153195d7e0f51734969a9" translate="yes" xml:space="preserve">
          <source>The code depending on environment variables that are not set by the web server.</source>
          <target state="translated">取决于环境变量的代码,这些环境变量不是由Web服务器设置的。</target>
        </trans-unit>
        <trans-unit id="15898d8e282ca3c771b1fcc67d06449dcc46266f" translate="yes" xml:space="preserve">
          <source>The configuration dictionary as &lt;a href=&quot;#flask.Config&quot;&gt;&lt;code&gt;Config&lt;/code&gt;&lt;/a&gt;. This behaves exactly like a regular dictionary but supports additional methods to load a config from files.</source>
          <target state="translated">配置字典为&lt;a href=&quot;#flask.Config&quot;&gt; &lt;code&gt;Config&lt;/code&gt; &lt;/a&gt;。这的行为与常规字典完全相同，但支持从文件加载配置的其他方法。</target>
        </trans-unit>
        <trans-unit id="f420d2cc131cf703aabfcc0c5e48c7769667be8d" translate="yes" xml:space="preserve">
          <source>The configuration files themselves are actual Python files. Only values in uppercase are actually stored in the config object later on. So make sure to use uppercase letters for your config keys.</source>
          <target state="translated">配置文件本身是实际的Python文件。只有大写字母的值才会在后面的config对象中实际存储。所以一定要用大写字母来表示你的配置键。</target>
        </trans-unit>
        <trans-unit id="4a85d70ccdfdb7841e3227d75ea03396cc478685" translate="yes" xml:space="preserve">
          <source>The configuration variable &lt;code&gt;JSON_SORT_KEYS&lt;/code&gt; (&lt;a href=&quot;../config/index#config&quot;&gt;Configuration Handling&lt;/a&gt;) can be set to false to stop Flask from auto-sorting keys. By default sorting is enabled and outside of the app context sorting is turned on.</source>
          <target state="translated">可以将配置变量 &lt;code&gt;JSON_SORT_KEYS&lt;/code&gt; （&lt;a href=&quot;../config/index#config&quot;&gt;Configuration Handling&lt;/a&gt;）设置为false，以阻止Flask自动排序键。默认情况下，排序是启用的，并且在应用程序上下文之外排序是打开的。</target>
        </trans-unit>
        <trans-unit id="c12973cf5ad7304ca5250297140737d6f815d14e" translate="yes" xml:space="preserve">
          <source>The context is unique to each thread (or other worker type). &lt;a href=&quot;../api/index#flask.request&quot;&gt;&lt;code&gt;request&lt;/code&gt;&lt;/a&gt; cannot be passed to another thread, the other thread will have a different context stack and will not know about the request the parent thread was pointing to.</source>
          <target state="translated">上下文对于每个线程（或其他工作程序类型）都是唯一的。无法将&lt;a href=&quot;../api/index#flask.request&quot;&gt; &lt;code&gt;request&lt;/code&gt; &lt;/a&gt;传递给另一个线程，另一个线程将具有不同的上下文堆栈，并且将不知道父线程指向的请求。</target>
        </trans-unit>
        <trans-unit id="a7f36dcb481b4d6580a283c7b62afc2793dbc30c" translate="yes" xml:space="preserve">
          <source>The context processor above makes a variable called &lt;code&gt;user&lt;/code&gt; available in the template with the value of &lt;code&gt;g.user&lt;/code&gt;. This example is not very interesting because &lt;code&gt;g&lt;/code&gt; is available in templates anyways, but it gives an idea how this works.</source>
          <target state="translated">上面的上下文处理器在模板中提供一个名为 &lt;code&gt;user&lt;/code&gt; 的变量，其值为 &lt;code&gt;g.user&lt;/code&gt; 。这个示例不是很有趣，因为 &lt;code&gt;g&lt;/code&gt; 仍然可以在模板中使用，但是它给出了一个工作原理。</target>
        </trans-unit>
        <trans-unit id="66f417309e5be3c1390fe2383e0b67e6a6b0f4ce" translate="yes" xml:space="preserve">
          <source>The context processor above makes the &lt;code&gt;format_price&lt;/code&gt; function available to all templates:</source>
          <target state="translated">上面的上下文处理器使 &lt;code&gt;format_price&lt;/code&gt; 函数可用于所有模板：</target>
        </trans-unit>
        <trans-unit id="3dace1e82899f46ee509c9b9a7f9124d5fd1621a" translate="yes" xml:space="preserve">
          <source>The current configuration object (&lt;code&gt;flask.config&lt;/code&gt;)</source>
          <target state="translated">当前的配置对象（ &lt;code&gt;flask.config&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="ba2e9cf90ce1cfdf368b6a767b16411b40f6ca90" translate="yes" xml:space="preserve">
          <source>The current request method is available by using the &lt;a href=&quot;../api/index#flask.Request.method&quot;&gt;&lt;code&gt;method&lt;/code&gt;&lt;/a&gt; attribute. To access form data (data transmitted in a &lt;code&gt;POST&lt;/code&gt; or &lt;code&gt;PUT&lt;/code&gt; request) you can use the &lt;a href=&quot;../api/index#flask.Request.form&quot;&gt;&lt;code&gt;form&lt;/code&gt;&lt;/a&gt; attribute. Here is a full example of the two attributes mentioned above:</source>
          <target state="translated">通过使用&lt;a href=&quot;../api/index#flask.Request.method&quot;&gt; &lt;code&gt;method&lt;/code&gt; &lt;/a&gt;属性可以使用当前请求方法。要访问表单数据（在 &lt;code&gt;POST&lt;/code&gt; 或 &lt;code&gt;PUT&lt;/code&gt; 请求中传输的数据），可以使用&lt;a href=&quot;../api/index#flask.Request.form&quot;&gt; &lt;code&gt;form&lt;/code&gt; &lt;/a&gt;属性。这是上述两个属性的完整示例：</target>
        </trans-unit>
        <trans-unit id="fc79b1dac0155c59e0792df410b1718faab8ad9d" translate="yes" xml:space="preserve">
          <source>The current request object (&lt;a href=&quot;../api/index#flask.request&quot;&gt;&lt;code&gt;flask.request&lt;/code&gt;&lt;/a&gt;). This variable is unavailable if the template was rendered without an active request context.</source>
          <target state="translated">当前的请求对象（&lt;a href=&quot;../api/index#flask.request&quot;&gt; &lt;code&gt;flask.request&lt;/code&gt; &lt;/a&gt;）。如果模板是在没有活动请求上下文的情况下呈现的，则此变量不可用。</target>
        </trans-unit>
        <trans-unit id="622dc4b0a1a062ed65ca3ee3b6393e291cd7f178" translate="yes" xml:space="preserve">
          <source>The current session object (&lt;a href=&quot;../api/index#flask.session&quot;&gt;&lt;code&gt;flask.session&lt;/code&gt;&lt;/a&gt;). This variable is unavailable if the template was rendered without an active request context.</source>
          <target state="translated">当前会话对象（&lt;a href=&quot;../api/index#flask.session&quot;&gt; &lt;code&gt;flask.session&lt;/code&gt; &lt;/a&gt;）。如果模板是在没有活动请求上下文的情况下呈现的，则此变量不可用。</target>
        </trans-unit>
        <trans-unit id="fe4a59077ef21ef6cc9cc7a52610cafdf0edd51a" translate="yes" xml:space="preserve">
          <source>The current user agent.</source>
          <target state="translated">当前用户代理。</target>
        </trans-unit>
        <trans-unit id="b0fc206135e129e862b86b5922e8173d13535296" translate="yes" xml:space="preserve">
          <source>The declarative extension in SQLAlchemy is the most recent method of using SQLAlchemy. It allows you to define tables and models in one go, similar to how Django works. In addition to the following text I recommend the official documentation on the &lt;a href=&quot;https://docs.sqlalchemy.org/en/latest/orm/extensions/declarative/&quot;&gt;declarative&lt;/a&gt; extension.</source>
          <target state="translated">SQLAlchemy中的声明性扩展是使用SQLAlchemy的最新方法。它允许您一次定义表和模型，类似于Django的工作方式。除了以下文本，我还建议您使用&lt;a href=&quot;https://docs.sqlalchemy.org/en/latest/orm/extensions/declarative/&quot;&gt;声明性&lt;/a&gt;扩展的正式文档。</target>
        </trans-unit>
        <trans-unit id="eb9cc4ad08078620488b9e0fa83bab57c0d91756" translate="yes" xml:space="preserve">
          <source>The decorated function will then work as follows</source>
          <target state="translated">然后,装饰功能将工作如下</target>
        </trans-unit>
        <trans-unit id="c0fb2c5540bdd7a017c97c21a13f1f58216eb842" translate="yes" xml:space="preserve">
          <source>The decorators stored in the decorators list are applied one after another when the view function is created. Note that you can &lt;em&gt;not&lt;/em&gt; use the class based decorators since those would decorate the view class and not the generated view function!</source>
          <target state="translated">创建视图功能时，将依次应用存储在装饰器列表中的装饰器。请注意，您&lt;em&gt;不能&lt;/em&gt;使用基于类的装饰器，因为它们将装饰视图类而不是装饰的视图函数！</target>
        </trans-unit>
        <trans-unit id="858cafbe390d25c2d75dcd5237b4265a5778cf3e" translate="yes" xml:space="preserve">
          <source>The default Flask JSON encoder. This one extends the default encoder by also supporting &lt;code&gt;datetime&lt;/code&gt;, &lt;code&gt;UUID&lt;/code&gt;, &lt;code&gt;dataclasses&lt;/code&gt;, and &lt;code&gt;Markup&lt;/code&gt; objects.</source>
          <target state="translated">默认的Flask JSON编码器。这也通过支持 &lt;code&gt;datetime&lt;/code&gt; ， &lt;code&gt;UUID&lt;/code&gt; ， &lt;code&gt;dataclasses&lt;/code&gt; 和 &lt;code&gt;Markup&lt;/code&gt; 对象扩展了默认编码器。</target>
        </trans-unit>
        <trans-unit id="3a1e9bc5e5353017ebe5f90175c35c4dbffe292a" translate="yes" xml:space="preserve">
          <source>The default JSON decoder. This one does not change the behavior from the default simplejson decoder. Consult the &lt;a href=&quot;https://docs.python.org/3/library/json.html#module-json&quot;&gt;&lt;code&gt;json&lt;/code&gt;&lt;/a&gt; documentation for more information. This decoder is not only used for the load functions of this module but also &lt;a href=&quot;#flask.Request&quot;&gt;&lt;code&gt;Request&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">默认的JSON解码器。这不会改变默认的simplejson解码器的行为。请参阅&lt;a href=&quot;https://docs.python.org/3/library/json.html#module-json&quot;&gt; &lt;code&gt;json&lt;/code&gt; &lt;/a&gt;文档以获取更多信息。该解码器不仅用于此模块的加载功能，而且还&lt;a href=&quot;#flask.Request&quot;&gt; &lt;code&gt;Request&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="26e371e8dea847f44687fa3ccea99e352bdad795" translate="yes" xml:space="preserve">
          <source>The default session interface that stores sessions in signed cookies through the &lt;code&gt;itsdangerous&lt;/code&gt; module.</source>
          <target state="translated">通过 &lt;code&gt;itsdangerous&lt;/code&gt; 模块将会话存储在已签名的Cookie中的默认会话接口。</target>
        </trans-unit>
        <trans-unit id="85b300ca2ec11b0bff038985a8431cf40826901e" translate="yes" xml:space="preserve">
          <source>The documentation will warn you about aspects of web development that require attention to security. Some of these security concerns are far more complex than one might think, and we all sometimes underestimate the likelihood that a vulnerability will be exploited - until a clever attacker figures out a way to exploit our applications. And don&amp;rsquo;t think that your application is not important enough to attract an attacker. Depending on the kind of attack, chances are that automated bots are probing for ways to fill your database with spam, links to malicious software, and the like.</source>
          <target state="translated">该文档将警告您有关Web开发方面需要注意安全性的方面。其中一些安全隐患比人们想象的要复杂得多，而且我们所有人有时都低估了利用漏洞的可能性-直到聪明的攻击者找到了一种利用我们的应用程序的方式。并且不要认为您的应用程序不够重要，不足以吸引攻击者。根据攻击的类型，自动机器人很可能正在探索用垃圾邮件，指向恶意软件的链接等填充数据库的方法。</target>
        </trans-unit>
        <trans-unit id="3e59288df4873e48f5cc8f144f30357b19723890" translate="yes" xml:space="preserve">
          <source>The domain match rule that the session cookie will be valid for. If not set, the cookie will be valid for all subdomains of &lt;a href=&quot;#SERVER_NAME&quot;&gt;&lt;code&gt;SERVER_NAME&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;False&lt;/code&gt;, the cookie&amp;rsquo;s domain will not be set.</source>
          <target state="translated">会话cookie将对其有效的域匹配规则。如果未设置，则cookie对&lt;a href=&quot;#SERVER_NAME&quot;&gt; &lt;code&gt;SERVER_NAME&lt;/code&gt; 的&lt;/a&gt;所有子域均有效。如果为 &lt;code&gt;False&lt;/code&gt; ，则不会设置cookie的域。</target>
        </trans-unit>
        <trans-unit id="11af5e46e819ded7fb8bab4e6d1a96158229e760" translate="yes" xml:space="preserve">
          <source>The downside is that you cannot use the application object in the blueprints at import time. You can however use it from within a request. How do you get access to the application with the config? Use &lt;a href=&quot;../../api/index#flask.current_app&quot;&gt;&lt;code&gt;current_app&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">缺点是您不能在导入时使用蓝图中的应用程序对象。但是，您可以在请求中使用它。如何通过配置访问应用程序？使用&lt;a href=&quot;../../api/index#flask.current_app&quot;&gt; &lt;code&gt;current_app&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="bd1fd946059e5e4d03daa74bd40f4cc6fa6d57d5" translate="yes" xml:space="preserve">
          <source>The downside of forking is of course that Flask extensions will most likely break because the new framework has a different import name. Furthermore integrating upstream changes can be a complex process, depending on the number of changes. Because of that, forking should be the very last resort.</source>
          <target state="translated">当然,分叉的缺点是Flask扩展很可能会被破坏,因为新的框架有不同的导入名称。此外,整合上游变化可能是一个复杂的过程,这取决于变化的数量。正因为如此,分叉应该是最后的手段。</target>
        </trans-unit>
        <trans-unit id="922f3d975e258566667671ffa999987dadc71c1e" translate="yes" xml:space="preserve">
          <source>The downside with the approach mentioned earlier is that it makes testing a little harder. There is no single 100% solution for this problem in general, but there are a couple of things you can keep in mind to improve that experience:</source>
          <target state="translated">前面提到的方法的缺点是,它让测试变得更难。一般来说,这个问题没有一个100%的解决方案,但有几件事你可以牢记,以改善这种体验。</target>
        </trans-unit>
        <trans-unit id="78d3f165392b63972543bbd26b477c7337095800" translate="yes" xml:space="preserve">
          <source>The easiest way to create a proper request context from the shell is by using the &lt;a href=&quot;../api/index#flask.Flask.test_request_context&quot;&gt;&lt;code&gt;test_request_context&lt;/code&gt;&lt;/a&gt; method which creates us a &lt;a href=&quot;../api/index#flask.ctx.RequestContext&quot;&gt;&lt;code&gt;RequestContext&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">从外壳创建正确的请求上下文的最简单方法是使用&lt;a href=&quot;../api/index#flask.Flask.test_request_context&quot;&gt; &lt;code&gt;test_request_context&lt;/code&gt; &lt;/a&gt;方法，该方法为我们创建一个&lt;a href=&quot;../api/index#flask.ctx.RequestContext&quot;&gt; &lt;code&gt;RequestContext&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="7e93fbad4a5ad4737eb9cc441af1a63e16e60fd9" translate="yes" xml:space="preserve">
          <source>The endpoint is named &lt;code&gt;blueprint_name.static&lt;/code&gt;. You can generate URLs to it with &lt;a href=&quot;../api/index#flask.url_for&quot;&gt;&lt;code&gt;url_for()&lt;/code&gt;&lt;/a&gt; like you would with the static folder of the application:</source>
          <target state="translated">该端点名为 &lt;code&gt;blueprint_name.static&lt;/code&gt; 。您可以使用&lt;a href=&quot;../api/index#flask.url_for&quot;&gt; &lt;code&gt;url_for()&lt;/code&gt; &lt;/a&gt;为其生成URL，就像使用应用程序的静态文件夹一样：</target>
        </trans-unit>
        <trans-unit id="b38c785f33e7d34d6b99bea0e630beef10a0e1b9" translate="yes" xml:space="preserve">
          <source>The endpoint that matched the request. This in combination with &lt;a href=&quot;#flask.Request.view_args&quot;&gt;&lt;code&gt;view_args&lt;/code&gt;&lt;/a&gt; can be used to reconstruct the same or a modified URL. If an exception happened when matching, this will be &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">匹配请求的端点。结合&lt;a href=&quot;#flask.Request.view_args&quot;&gt; &lt;code&gt;view_args&lt;/code&gt; &lt;/a&gt;可以用于重建相同或修改的URL。如果匹配时发生异常，则为 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5a605a1722a19de50b814971b88eb61ff129755b" translate="yes" xml:space="preserve">
          <source>The environment in which the Flask app runs is set by the &lt;code id=&quot;index-0&quot;&gt;FLASK_ENV&lt;/code&gt; environment variable. If not set it defaults to &lt;code&gt;production&lt;/code&gt;. The other recognized environment is &lt;code&gt;development&lt;/code&gt;. Flask and extensions may choose to enable behaviors based on the environment.</source>
          <target state="translated">Flask应用程序运行的环境由 &lt;code id=&quot;index-0&quot;&gt;FLASK_ENV&lt;/code&gt; 环境变量设置。如果未设置，则默认为 &lt;code&gt;production&lt;/code&gt; 。另一个公认的环境是 &lt;code&gt;development&lt;/code&gt; 。Flask和扩展程序可以选择启用基于环境的行为。</target>
        </trans-unit>
        <trans-unit id="d0b4beadb6e65866f58164a47244b14c9e4b8697" translate="yes" xml:space="preserve">
          <source>The environment is created the first time this property is accessed. Changing &lt;a href=&quot;#flask.Flask.jinja_options&quot;&gt;&lt;code&gt;jinja_options&lt;/code&gt;&lt;/a&gt; after that will have no effect.</source>
          <target state="translated">首次访问此属性时将创建环境。在那之后更改&lt;a href=&quot;#flask.Flask.jinja_options&quot;&gt; &lt;code&gt;jinja_options&lt;/code&gt; &lt;/a&gt;将不起作用。</target>
        </trans-unit>
        <trans-unit id="7315c86dde38ca0726337d05547327cb00a22692" translate="yes" xml:space="preserve">
          <source>The environment is used to indicate to Flask, extensions, and other programs, like Sentry, what context Flask is running in. It is controlled with the &lt;code id=&quot;index-0&quot;&gt;FLASK_ENV&lt;/code&gt; environment variable and defaults to &lt;code&gt;production&lt;/code&gt;.</source>
          <target state="translated">该环境用于向Flask，扩展程序和其他程序（例如Sentry）指示Flask正在运行的上下文。它由 &lt;code id=&quot;index-0&quot;&gt;FLASK_ENV&lt;/code&gt; 环境变量控制，默认为 &lt;code&gt;production&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6fc510e47ba78fd6938bfcd347367f5b5a515f68" translate="yes" xml:space="preserve">
          <source>The example above is good enough for a basic Apache deployment but your &lt;code&gt;.fcgi&lt;/code&gt; file will appear in your application URL e.g. &lt;code&gt;example.com/yourapplication.fcgi/news/&lt;/code&gt;. There are few ways to configure your application so that yourapplication.fcgi does not appear in the URL. A preferable way is to use the ScriptAlias and SetHandler configuration directives to route requests to the FastCGI server. The following example uses FastCgiServer to start 5 instances of the application which will handle all incoming requests:</source>
          <target state="translated">上面的示例对于基本的Apache部署已经足够了，但是您的 &lt;code&gt;.fcgi&lt;/code&gt; 文件将出现在应用程序URL中，例如 &lt;code&gt;example.com/yourapplication.fcgi/news/&lt;/code&gt; 。有几种方法可以配置您的应用程序，以使yourapplication.fcgi不会出现在URL中。一种更好的方法是使用ScriptAlias和SetHandler配置指令将请求路由到FastCGI服务器。下面的示例使用FastCgiServer启动应用程序的5个实例，这些实例将处理所有传入的请求：</target>
        </trans-unit>
        <trans-unit id="ef01fb107800d792a5d9a6538320e0d723af2366" translate="yes" xml:space="preserve">
          <source>The example above would then look like this:</source>
          <target state="translated">那么上面的例子就会是这样的。</target>
        </trans-unit>
        <trans-unit id="ab450bd50babc2d822ab0143cc317effacdd1fa2" translate="yes" xml:space="preserve">
          <source>The factory function above is not very clever, but you can improve it. The following changes are straightforward to implement:</source>
          <target state="translated">上面的工厂功能不是很巧妙,但你可以改进它。下面的改动就可以直接实现。</target>
        </trans-unit>
        <trans-unit id="0cc4b4d816b0530df186130ae0c37cd9cc7de620" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;wsgi.py&lt;/code&gt; is imported, automatically detecting an app (&lt;code&gt;app&lt;/code&gt;). This provides an easy way to create an app from a factory with extra arguments.</source>
          <target state="translated">导入文件 &lt;code&gt;wsgi.py&lt;/code&gt; ，自动检测一个应用程序（ &lt;code&gt;app&lt;/code&gt; ）。这提供了一种从工厂创建带有附加参数的应用程序的简便方法。</target>
        </trans-unit>
        <trans-unit id="0be8b5002d0d39834db635960ba37533f0a10aa3" translate="yes" xml:space="preserve">
          <source>The file has to be stored on the filesystem as &lt;code&gt;static/style.css&lt;/code&gt;.</source>
          <target state="translated">该文件必须以 &lt;code&gt;static/style.css&lt;/code&gt; 的形式存储在文件系统中。</target>
        </trans-unit>
        <trans-unit id="3cc1afa1dad88f12b4520e49a7f0c6e36cc906e3" translate="yes" xml:space="preserve">
          <source>The files are only loaded by the &lt;code&gt;flask&lt;/code&gt; command or calling &lt;a href=&quot;../api/index#flask.Flask.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt;. If you would like to load these files when running in production, you should call &lt;a href=&quot;../api/index#flask.cli.load_dotenv&quot;&gt;&lt;code&gt;load_dotenv()&lt;/code&gt;&lt;/a&gt; manually.</source>
          <target state="translated">仅通过 &lt;code&gt;flask&lt;/code&gt; 命令或调用&lt;a href=&quot;../api/index#flask.Flask.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt;加载文件。如果要在生产环境中运行时加载这些文件，则应手动调用&lt;a href=&quot;../api/index#flask.cli.load_dotenv&quot;&gt; &lt;code&gt;load_dotenv()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ec0f6af133185c7252f926a9dab35a045d36afcb" translate="yes" xml:space="preserve">
          <source>The first one is obviously from the application itself for the static files. The other two are for the &lt;code&gt;show&lt;/code&gt; function of the &lt;code&gt;simple_page&lt;/code&gt; blueprint. As you can see, they are also prefixed with the name of the blueprint and separated by a dot (&lt;code&gt;.&lt;/code&gt;).</source>
          <target state="translated">第一个显然来自应用程序本身的静态文件。另外两个是用于 &lt;code&gt;simple_page&lt;/code&gt; 蓝图的 &lt;code&gt;show&lt;/code&gt; 功能。如您所见，它们还以蓝图的名称作为前缀，并以点（ &lt;code&gt;.&lt;/code&gt; ）分隔。</target>
        </trans-unit>
        <trans-unit id="9b544223cf3117111f51a6c665d7d1e40759ca57" translate="yes" xml:space="preserve">
          <source>The first thing you need is a Celery instance, this is called the celery application. It serves the same purpose as the &lt;a href=&quot;../../api/index#flask.Flask&quot;&gt;&lt;code&gt;Flask&lt;/code&gt;&lt;/a&gt; object in Flask, just for Celery. Since this instance is used as the entry-point for everything you want to do in Celery, like creating tasks and managing workers, it must be possible for other modules to import it.</source>
          <target state="translated">您需要的第一件事是Celery实例，这称为celery应用程序。它的功能与&lt;a href=&quot;../../api/index#flask.Flask&quot;&gt; &lt;code&gt;Flask&lt;/code&gt; &lt;/a&gt;中的Flask对象相同，仅用于芹菜。由于此实例用作您要在Celery中执行的所有操作（例如创建任务和管理工作人员）的切入点，因此其他模块必须可以导入它。</target>
        </trans-unit>
        <trans-unit id="e97621ef715374370e72da9959db9d846df7c1e7" translate="yes" xml:space="preserve">
          <source>The flask object implements a WSGI application and acts as the central object. It is passed the name of the module or package of the application. Once it is created it will act as a central registry for the view functions, the URL rules, template configuration and much more.</source>
          <target state="translated">flask对象实现了一个WSGI应用程序并作为中心对象。它被传递给应用程序的模块或包的名称。一旦它被创建,它将作为视图功能、URL规则、模板配置等的中心注册表。</target>
        </trans-unit>
        <trans-unit id="a1347e18b217e25fb7ac9165ce1049a375fc2ecd" translate="yes" xml:space="preserve">
          <source>The folder is inferred from the second argument to &lt;a href=&quot;../api/index#flask.Blueprint&quot;&gt;&lt;code&gt;Blueprint&lt;/code&gt;&lt;/a&gt; which is usually &lt;code&gt;__name__&lt;/code&gt;. This argument specifies what logical Python module or package corresponds to the blueprint. If it points to an actual Python package that package (which is a folder on the filesystem) is the resource folder. If it&amp;rsquo;s a module, the package the module is contained in will be the resource folder. You can access the &lt;a href=&quot;../api/index#flask.Blueprint.root_path&quot;&gt;&lt;code&gt;Blueprint.root_path&lt;/code&gt;&lt;/a&gt; property to see what the resource folder is:</source>
          <target state="translated">该文件夹是从第二个参数推断为&lt;a href=&quot;../api/index#flask.Blueprint&quot;&gt; &lt;code&gt;Blueprint&lt;/code&gt; 的&lt;/a&gt;，通常是 &lt;code&gt;__name__&lt;/code&gt; 。此参数指定与该蓝图相对应的逻辑Python模块或软件包。如果它指向实际的Python包，则该包（文件系统上的文件夹）就是资源文件夹。如果是模块，则模块所在的包将是资源文件夹。您可以访问&lt;a href=&quot;../api/index#flask.Blueprint.root_path&quot;&gt; &lt;code&gt;Blueprint.root_path&lt;/code&gt; &lt;/a&gt;属性以查看资源文件夹是什么：</target>
        </trans-unit>
        <trans-unit id="2d57adeacfc211dd12f2747b81ef55fd9b5cd946" translate="yes" xml:space="preserve">
          <source>The following attributes are always present on each layer of the stack:</source>
          <target state="translated">以下属性始终存在于堆栈的每一层。</target>
        </trans-unit>
        <trans-unit id="45856bb887c02aa06db92abf26bfdda871695cb6" translate="yes" xml:space="preserve">
          <source>The following attributes are interesting:</source>
          <target state="translated">以下属性很有意思:</target>
        </trans-unit>
        <trans-unit id="0fdf470798dd067e3a70bbc370b546bdead95fdf" translate="yes" xml:space="preserve">
          <source>The following configuration values are used internally by Flask:</source>
          <target state="translated">Flask内部使用以下配置值。</target>
        </trans-unit>
        <trans-unit id="e30c24180eb62e306d5de97c97fbdd506fa73d17" translate="yes" xml:space="preserve">
          <source>The following converters are available:</source>
          <target state="translated">以下是可用的转换器:</target>
        </trans-unit>
        <trans-unit id="71f1e0a0b9d4dddf6053f2c87aa0de1347cbb0e6" translate="yes" xml:space="preserve">
          <source>The following error codes are some that are often displayed to the user, even if the application behaves correctly:</source>
          <target state="translated">以下是一些经常显示给用户的错误代码,即使应用程序表现正确。</target>
        </trans-unit>
        <trans-unit id="3739d10ad4374292340fd3d40ac991daa79d1053" translate="yes" xml:space="preserve">
          <source>The following example calculates the SHA1 checksum of the incoming data as it gets read and stores it in the WSGI environment:</source>
          <target state="translated">下面的例子是在读取传入数据时计算它的SHA1校验和,并将其存储在WSGI环境中。</target>
        </trans-unit>
        <trans-unit id="8ff2ee225d4f005ca48753b82e42c7f2080cea16" translate="yes" xml:space="preserve">
          <source>The following example demonstrates how to serve an SPA along with an API:</source>
          <target state="translated">下面的例子演示了如何通过API来服务SPA。</target>
        </trans-unit>
        <trans-unit id="d67e089c993b5c08f84daf61b9dd084ccfa4262e" translate="yes" xml:space="preserve">
          <source>The following extra types are supported:</source>
          <target state="translated">支持以下额外类型:</target>
        </trans-unit>
        <trans-unit id="e717c02928363141e3eaf56793f9e9b01fb2fa4e" translate="yes" xml:space="preserve">
          <source>The following global variables are available within Jinja2 templates by default:</source>
          <target state="translated">以下全局变量默认在Jinja2模板中可用。</target>
        </trans-unit>
        <trans-unit id="f3854fb9d0510864c58a6b4b81f672cc0a81e855" translate="yes" xml:space="preserve">
          <source>The following signals exist in Flask:</source>
          <target state="translated">Flask中存在以下信号。</target>
        </trans-unit>
        <trans-unit id="dd2b2530cb2aaeddbe8bc8bf16da1fa40f1f0373" translate="yes" xml:space="preserve">
          <source>The following table gives you a quick overview of features available in HTML 4.01, XHTML 1.1 and HTML5. (XHTML 1.0 is not included, as it was superseded by XHTML 1.1 and the barely-used XHTML5.)</source>
          <target state="translated">下表是HTML 4.01、XHTML 1.1和HTML5中可用功能的快速概览。(XHTML 1.0不包括在内,因为它已被XHTML 1.1和几乎没有使用的XHTML5所取代。)</target>
        </trans-unit>
        <trans-unit id="ac9e6ccb4f55a75eafa70f95d4008a7e98433dc4" translate="yes" xml:space="preserve">
          <source>The following two rules differ in their use of a trailing slash.</source>
          <target state="translated">以下两条规则在使用尾部斜杠方面有所不同。</target>
        </trans-unit>
        <trans-unit id="2cb381b5f80ddb93e2061703265fd31c14ddef85" translate="yes" xml:space="preserve">
          <source>The form parameters. By default an &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.ImmutableMultiDict&quot;&gt;&lt;code&gt;ImmutableMultiDict&lt;/code&gt;&lt;/a&gt; is returned from this function. This can be changed by setting &lt;a href=&quot;#flask.Request.parameter_storage_class&quot;&gt;&lt;code&gt;parameter_storage_class&lt;/code&gt;&lt;/a&gt; to a different type. This might be necessary if the order of the form data is important.</source>
          <target state="translated">表单参数。默认情况下，此函数返回&lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.ImmutableMultiDict&quot;&gt; &lt;code&gt;ImmutableMultiDict&lt;/code&gt; &lt;/a&gt;。可以通过将&lt;a href=&quot;#flask.Request.parameter_storage_class&quot;&gt; &lt;code&gt;parameter_storage_class&lt;/code&gt; &lt;/a&gt;设置为其他类型来进行更改。如果表单数据的顺序很重要，则可能有必要。</target>
        </trans-unit>
        <trans-unit id="f800d669d3177a75b11a3c718ef892afa97a5425" translate="yes" xml:space="preserve">
          <source>The full URL root (with hostname), this is the application root as IRI. See also: &lt;code&gt;trusted_hosts&lt;/code&gt;.</source>
          <target state="translated">完整的URL根目录（带有主机名），这是应用程序的根目录（作为IRI）。另请参阅： &lt;code&gt;trusted_hosts&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="acfea3641ea12f0c33492ed286db0fb5a3f8d97c" translate="yes" xml:space="preserve">
          <source>The function can modify the values captured from the matched url before they are passed to the view. For example, this can be used to pop a common language code value and place it in &lt;code&gt;g&lt;/code&gt; rather than pass it to every view.</source>
          <target state="translated">该函数可以修改从匹配的url捕获的值，然后再将其传递到视图。例如，可以将其用于弹出公共语言代码值并将其放入 &lt;code&gt;g&lt;/code&gt; 中,而不是将其传递给每个视图。</target>
        </trans-unit>
        <trans-unit id="987202a4812ae7726b2918a0d5ba64208f67c2fd" translate="yes" xml:space="preserve">
          <source>The function creates a new Celery object, configures it with the broker from the application config, updates the rest of the Celery config from the Flask config and then creates a subclass of the task that wraps the task execution in an application context.</source>
          <target state="translated">该函数创建一个新的Celery对象,用应用程序配置中的broker配置它,从Flask配置中更新Celery配置的其余部分,然后创建一个任务的子类,将任务执行包装在应用程序上下文中。</target>
        </trans-unit>
        <trans-unit id="c3e06fc3fcea61300a2f1686bca6a2797370a649" translate="yes" xml:space="preserve">
          <source>The function is called as a WSGI application. The result is used to create a response object.</source>
          <target state="translated">该函数作为WSGI应用程序被调用。结果用于创建响应对象。</target>
        </trans-unit>
        <trans-unit id="c28c5b80cc442d5fc2067e7ee74f405fb099d4c2" translate="yes" xml:space="preserve">
          <source>The function is given a name which is also used to generate URLs for that particular function, and returns the message we want to display in the user&amp;rsquo;s browser.</source>
          <target state="translated">该函数具有一个名称，该名称也用于生成该特定函数的URL，并返回我们要在用户浏览器中显示的消息。</target>
        </trans-unit>
        <trans-unit id="c61e3bf08eb47596681103b94142530252dff689" translate="yes" xml:space="preserve">
          <source>The function is passed the endpoint name and values dict. The return value is ignored.</source>
          <target state="translated">该函数传递的是端点名和值dict。返回值将被忽略。</target>
        </trans-unit>
        <trans-unit id="744a0d254075b746f7ea06d323422c1edb64cb7d" translate="yes" xml:space="preserve">
          <source>The function will be called without any arguments and its return value is ignored.</source>
          <target state="translated">该函数将在没有任何参数的情况下被调用,其返回值将被忽略。</target>
        </trans-unit>
        <trans-unit id="0db58d1f44eec3557667e52f36f9b4e2b1b42d81" translate="yes" xml:space="preserve">
          <source>The function will be called without any arguments. If it returns a non-None value, the value is handled as if it was the return value from the view, and further request handling is stopped.</source>
          <target state="translated">该函数将在没有任何参数的情况下被调用。如果返回一个非None的值,该值将被当作视图的返回值来处理,并停止进一步的请求处理。</target>
        </trans-unit>
        <trans-unit id="a8745a806f30ca42b1d74392a73dac3edaf44d74" translate="yes" xml:space="preserve">
          <source>The functions registered as &lt;a href=&quot;../api/index#flask.Flask.teardown_request&quot;&gt;&lt;code&gt;teardown_request()&lt;/code&gt;&lt;/a&gt; are automatically called when the context is popped. So this is the perfect place to automatically tear down resources that were needed by the request context (such as database connections).</source>
          <target state="translated">弹出上下文时，将自动调用注册为&lt;a href=&quot;../api/index#flask.Flask.teardown_request&quot;&gt; &lt;code&gt;teardown_request()&lt;/code&gt; &lt;/a&gt;的函数。因此，这是自动删除请求上下文所需要的资源（例如数据库连接）的理想场所。</target>
        </trans-unit>
        <trans-unit id="b9c1a03c4294196aa99df7c04a14fd21edbb06de" translate="yes" xml:space="preserve">
          <source>The fundamental difference from the &lt;a href=&quot;../packages/index#larger-applications&quot;&gt;module approach&lt;/a&gt; is that in this case you are running the same or different Flask applications that are entirely isolated from each other. They run different configurations and are dispatched on the WSGI level.</source>
          <target state="translated">与&lt;a href=&quot;../packages/index#larger-applications&quot;&gt;模块方法&lt;/a&gt;的根本区别在于，在这种情况下，您将运行完全彼此隔离的相同或不同的Flask应用程序。它们运行不同的配置，并在WSGI级别上调度。</target>
        </trans-unit>
        <trans-unit id="6dc887b860605903226d9ee4df30a6b1d65d6cd1" translate="yes" xml:space="preserve">
          <source>The generated paths are always absolute, avoiding unexpected behavior of relative paths in browsers.</source>
          <target state="translated">生成的路径总是绝对的,避免了浏览器中相对路径的意外行为。</target>
        </trans-unit>
        <trans-unit id="1c336e15c4d79847228dfc48a3c060140965c655" translate="yes" xml:space="preserve">
          <source>The global loader dispatches between the loaders of the application and the individual blueprints.</source>
          <target state="translated">全局加载器在应用程序的加载器和各个蓝图之间进行调度。</target>
        </trans-unit>
        <trans-unit id="7f3419ff614ffd0fc40a6a1ac778afe27daceb5a" translate="yes" xml:space="preserve">
          <source>The good old &amp;ldquo;chap, you made a mistake typing that URL&amp;rdquo; message. So common that even novices to the internet know that 404 means: damn, the thing I was looking for is not there. It&amp;rsquo;s a very good idea to make sure there is actually something useful on a 404 page, at least a link back to the index.</source>
          <target state="translated">老式的&amp;ldquo;打招呼，您输入该URL时出错&amp;rdquo;消息。如此普遍，以至于互联网新手都知道404的意思是：该死，我要找的东西不在那儿。确保404页上确实有一些有用的东西，至少是指向索引的链接是一个非常好的主意。</target>
        </trans-unit>
        <trans-unit id="26c3bea68f21e606e3fd467d19f04af6813e55c5" translate="yes" xml:space="preserve">
          <source>The headers from the WSGI environ as immutable &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.EnvironHeaders&quot;&gt;&lt;code&gt;EnvironHeaders&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">WSGI环境中的标头为不可变的&lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.EnvironHeaders&quot;&gt; &lt;code&gt;EnvironHeaders&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ce06632cdaceed71bd97c88118c5cc956bb34384" translate="yes" xml:space="preserve">
          <source>The host that the request originated from. Set &lt;code&gt;access_control_allow_origin&lt;/code&gt; on the response to indicate which origins are allowed.</source>
          <target state="translated">请求所源自的主机。在响应上设置 &lt;code&gt;access_control_allow_origin&lt;/code&gt; 以指示允许哪些起源。</target>
        </trans-unit>
        <trans-unit id="6ab22e5342af494b10ae7a66c038f7892ba5313b" translate="yes" xml:space="preserve">
          <source>The idea is to set up the application in a function. Like this:</source>
          <target state="translated">我们的想法是在一个函数中设置应用程序。像这样。</target>
        </trans-unit>
        <trans-unit id="84a681a3876e958589311c1a8225928653dc2fc1" translate="yes" xml:space="preserve">
          <source>The idea of Flask is to build a good foundation for all applications. Everything else is up to you or extensions.</source>
          <target state="translated">Flask的理念是为所有的应用建立一个良好的基础。其他的一切都取决于你或扩展。</target>
        </trans-unit>
        <trans-unit id="37334d361ab6704aa6afd76d05501cbf6428f742" translate="yes" xml:space="preserve">
          <source>The idea of the first parameter is to give Flask an idea of what belongs to your application. This name is used to find resources on the filesystem, can be used by extensions to improve debugging information and a lot more.</source>
          <target state="translated">第一个参数的想法是让Flask知道什么属于你的应用程序。这个名字是用来查找文件系统上的资源,可以被扩展程序用来改善调试信息等等。</target>
        </trans-unit>
        <trans-unit id="f8df049ce73b972bc9f01308d525921a931ced93" translate="yes" xml:space="preserve">
          <source>The individual features of the server can be controlled by passing more arguments to the &lt;code&gt;run&lt;/code&gt; option. For instance the reloader can be disabled:</source>
          <target state="translated">可以通过将更多参数传递给 &lt;code&gt;run&lt;/code&gt; 选项来控制服务器的各个功能。例如，可以禁用重新加载器：</target>
        </trans-unit>
        <trans-unit id="0bc08fedf08bcfe38b276685da39f147af7869ea" translate="yes" xml:space="preserve">
          <source>The internal &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/local/#werkzeug.local.LocalStack&quot;&gt;&lt;code&gt;LocalStack&lt;/code&gt;&lt;/a&gt; that holds &lt;a href=&quot;#flask.ctx.AppContext&quot;&gt;&lt;code&gt;AppContext&lt;/code&gt;&lt;/a&gt; instances. Typically, the &lt;a href=&quot;#flask.current_app&quot;&gt;&lt;code&gt;current_app&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#flask.g&quot;&gt;&lt;code&gt;g&lt;/code&gt;&lt;/a&gt; proxies should be accessed instead of the stack. Extensions can access the contexts on the stack as a namespace to store data.</source>
          <target state="translated">内部的&lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/local/#werkzeug.local.LocalStack&quot;&gt; &lt;code&gt;LocalStack&lt;/code&gt; &lt;/a&gt;包含&lt;a href=&quot;#flask.ctx.AppContext&quot;&gt; &lt;code&gt;AppContext&lt;/code&gt; &lt;/a&gt;实例。通常，应访问&lt;a href=&quot;#flask.current_app&quot;&gt; &lt;code&gt;current_app&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#flask.g&quot;&gt; &lt;code&gt;g&lt;/code&gt; &lt;/a&gt;代理而不是堆栈。扩展可以访问堆栈上的上下文作为存储数据的名称空间。</target>
        </trans-unit>
        <trans-unit id="bb5d03486a6b4a0f30c5950512d7dd6c9b9b856f" translate="yes" xml:space="preserve">
          <source>The internal &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/local/#werkzeug.local.LocalStack&quot;&gt;&lt;code&gt;LocalStack&lt;/code&gt;&lt;/a&gt; that holds &lt;a href=&quot;#flask.ctx.RequestContext&quot;&gt;&lt;code&gt;RequestContext&lt;/code&gt;&lt;/a&gt; instances. Typically, the &lt;a href=&quot;#flask.request&quot;&gt;&lt;code&gt;request&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#flask.session&quot;&gt;&lt;code&gt;session&lt;/code&gt;&lt;/a&gt; proxies should be accessed instead of the stack. It may be useful to access the stack in extension code.</source>
          <target state="translated">内部&lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/local/#werkzeug.local.LocalStack&quot;&gt; &lt;code&gt;LocalStack&lt;/code&gt; &lt;/a&gt;持有&lt;a href=&quot;#flask.ctx.RequestContext&quot;&gt; &lt;code&gt;RequestContext&lt;/code&gt; &lt;/a&gt;实例。通常，应该访问&lt;a href=&quot;#flask.request&quot;&gt; &lt;code&gt;request&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#flask.session&quot;&gt; &lt;code&gt;session&lt;/code&gt; &lt;/a&gt;代理而不是堆栈。以扩展代码访问堆栈可能很有用。</target>
        </trans-unit>
        <trans-unit id="37ab61ea14f34e2749462ac1e486acc939cabf55" translate="yes" xml:space="preserve">
          <source>The internal URL rule that matched the request. This can be useful to inspect which methods are allowed for the URL from a before/after handler (&lt;code&gt;request.url_rule.methods&lt;/code&gt;) etc. Though if the request&amp;rsquo;s method was invalid for the URL rule, the valid list is available in &lt;code&gt;routing_exception.valid_methods&lt;/code&gt; instead (an attribute of the Werkzeug exception &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/exceptions/#werkzeug.exceptions.MethodNotAllowed&quot;&gt;&lt;code&gt;MethodNotAllowed&lt;/code&gt;&lt;/a&gt;) because the request was never internally bound.</source>
          <target state="translated">与请求匹配的内部URL规则。这对于检查之前/之后处理程序（ &lt;code&gt;request.url_rule.methods&lt;/code&gt; ）等中允许使用URL的方法很有用。尽管如果请求的方法对于URL规则无效，则有效列表可在 &lt;code&gt;routing_exception.valid_methods&lt;/code&gt; 中使用（Werkzeug异常&lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/exceptions/#werkzeug.exceptions.MethodNotAllowed&quot;&gt; &lt;code&gt;MethodNotAllowed&lt;/code&gt; &lt;/a&gt;的属性），因为该请求从未在内部进行绑定。</target>
        </trans-unit>
        <trans-unit id="74b1e898bbeb4c9a3a1dc77f36345a1ecbf025e0" translate="yes" xml:space="preserve">
          <source>The key must match the name of the extension module. For example in case of a &amp;ldquo;Flask-Foo&amp;rdquo; extension in &lt;code&gt;flask_foo&lt;/code&gt;, the key would be &lt;code&gt;'foo'&lt;/code&gt;.</source>
          <target state="translated">密钥必须与扩展模块的名称匹配。例如，在 &lt;code&gt;flask_foo&lt;/code&gt; 中使用&amp;ldquo; Flask-Foo&amp;rdquo;扩展名时，键将为 &lt;code&gt;'foo'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0f9a1dbabe3b01b3c38d2fbd438b7868158e0c44" translate="yes" xml:space="preserve">
          <source>The last thing you have to do is to create an Apache configuration file for your application. In this example we are telling &lt;code&gt;mod_wsgi&lt;/code&gt; to execute the application under a different user for security reasons:</source>
          <target state="translated">您要做的最后一件事是为您的应用程序创建一个Apache配置文件。在此示例中，出于安全原因，我们告诉 &lt;code&gt;mod_wsgi&lt;/code&gt; 在其他用户下执行应用程序：</target>
        </trans-unit>
        <trans-unit id="0b6f9d49453a140d6438f8bdd634cada945c0a63" translate="yes" xml:space="preserve">
          <source>The majority of the functionality of our application is only available for the administrative user, so we need a way to log our test client in and out of the application. To do this, we fire some requests to the login and logout pages with the required form data (username and password). And because the login and logout pages redirect, we tell the client to &lt;code&gt;follow_redirects&lt;/code&gt;.</source>
          <target state="translated">我们应用程序的大多数功能仅适用于管理用户，因此我们需要一种方法来将测试客户端登录到应用程序中和从应用程序中注销。为此，我们用所需的表单数据（用户名和密码）向登录和注销页面发出一些请求。并且由于登录页面和注销页面重定向，因此我们告诉客户端要 &lt;code&gt;follow_redirects&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b9de4301bd35a3b2857564b94cda2de76879c5dd" translate="yes" xml:space="preserve">
          <source>The majority of users, however, assumed they were properly using XHTML. They wrote an XHTML doctype at the top of the document and self-closed all the necessary tags (&lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt; becomes &lt;code&gt;&amp;lt;br/&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;&lt;/code&gt; in XHTML). However, even if the document properly validates as XHTML, what really determines XHTML/HTML processing in browsers is the MIME type, which as said before is often not set properly. So the valid XHTML was being treated as invalid HTML.</source>
          <target state="translated">但是，大多数用户都认为他们正确使用了XHTML。他们在文档顶部编写了一个XHTML文档类型，并自动关闭了所有必需的标记（在XHTML中 &lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt; 变为 &lt;code&gt;&amp;lt;br/&amp;gt;&lt;/code&gt; 或 &lt;code&gt;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;&lt;/code&gt; ）。但是，即使文档正确地验证为XHTML，真正决定浏览器中XHTML / HTML处理的还是MIME类型，如前所述，MIME类型通常设置不正确。因此，有效的XHTML被视为无效的HTML。</target>
        </trans-unit>
        <trans-unit id="12b3412d278608bd7a7a20aee90683aa3e0be5e5" translate="yes" xml:space="preserve">
          <source>The method &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/routing/#werkzeug.routing.Map.is_endpoint_expecting&quot;&gt;&lt;code&gt;is_endpoint_expecting()&lt;/code&gt;&lt;/a&gt; of the URL map can be used to figure out if it would make sense to provide a language code for the given endpoint.</source>
          <target state="translated">URL映射的&lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/routing/#werkzeug.routing.Map.is_endpoint_expecting&quot;&gt; &lt;code&gt;is_endpoint_expecting()&lt;/code&gt; &lt;/a&gt;方法可用于确定为给定端点提供语言代码是否有意义。</target>
        </trans-unit>
        <trans-unit id="d2d1595ecab1897f01531801d8e88b52231a39f9" translate="yes" xml:space="preserve">
          <source>The mimetype (content type without charset etc.)</source>
          <target state="translated">Mimetype(不含字符集的内容类型等)</target>
        </trans-unit>
        <trans-unit id="6f5ab242247b3a3237c2537e5451ac6522b46121" translate="yes" xml:space="preserve">
          <source>The mimetype of &lt;code&gt;jsonify&lt;/code&gt; responses.</source>
          <target state="translated">&lt;code&gt;jsonify&lt;/code&gt; 响应的模仿类型。</target>
        </trans-unit>
        <trans-unit id="6dee94b7edc7c1366f6de5c62f1871e3b40afbe3" translate="yes" xml:space="preserve">
          <source>The mimetype parameters as dict. For example if the content type is &lt;code&gt;text/html; charset=utf-8&lt;/code&gt; the params would be &lt;code&gt;{'charset': 'utf-8'}&lt;/code&gt;.</source>
          <target state="translated">mimetype参数为dict。例如，如果内容类型为 &lt;code&gt;text/html; charset=utf-8&lt;/code&gt; 参数将为 &lt;code&gt;{'charset': 'utf-8'}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="894b9fe9d143fca2772979fa9a785788338d5b74" translate="yes" xml:space="preserve">
          <source>The most common reason is a typo or because you did not actually create an &lt;code&gt;app&lt;/code&gt; object.</source>
          <target state="translated">最常见的原因是输入错误，或者是您实际上没有创建 &lt;code&gt;app&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="88a2b45e49eaf3571ef997fa30099f3decb466b8" translate="yes" xml:space="preserve">
          <source>The most popular uWSGI server is &lt;a href=&quot;https://uwsgi-docs.readthedocs.io/en/latest/&quot;&gt;uwsgi&lt;/a&gt;, which we will use for this guide. Make sure to have it installed to follow along.</source>
          <target state="translated">最流行的uWSGI服务器是&lt;a href=&quot;https://uwsgi-docs.readthedocs.io/en/latest/&quot;&gt;uwsgi&lt;/a&gt;，我们将使用本指南。请确保已安装它以进行后续操作。</target>
        </trans-unit>
        <trans-unit id="9831b642b4a7dbda4200272804a99e23253a74b8" translate="yes" xml:space="preserve">
          <source>The most powerful part of Jinja is template inheritance. Template inheritance allows you to build a base &amp;ldquo;skeleton&amp;rdquo; template that contains all the common elements of your site and defines &lt;strong&gt;blocks&lt;/strong&gt; that child templates can override.</source>
          <target state="translated">Jinja最强大的部分是模板继承。模板继承使您可以构建基本的&amp;ldquo;骨架&amp;rdquo;模板，该模板包含站点的所有常见元素，并定义子模板可以覆盖的&lt;strong&gt;块&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="434d866addcf5e109b7cfe6c77d489e2967a5f8e" translate="yes" xml:space="preserve">
          <source>The name for the signal here makes it unique and also simplifies debugging. You can access the name of the signal with the &lt;a href=&quot;https://pythonhosted.org/blinker/index.html#blinker.base.NamedSignal.name&quot;&gt;&lt;code&gt;name&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">此处的信号名称使其具有唯一性，并简化了调试。您可以使用&lt;a href=&quot;https://pythonhosted.org/blinker/index.html#blinker.base.NamedSignal.name&quot;&gt; &lt;code&gt;name&lt;/code&gt; &lt;/a&gt;属性访问信号的名称。</target>
        </trans-unit>
        <trans-unit id="4592ffe5aab5fb29297a71a871f5be69fc6261e2" translate="yes" xml:space="preserve">
          <source>The name is imported, automatically detecting an app (&lt;code&gt;app&lt;/code&gt;) or factory (&lt;code&gt;create_app&lt;/code&gt;).</source>
          <target state="translated">名称已导入，将自动检测应用程序（ &lt;code&gt;app&lt;/code&gt; ）或工厂（ &lt;code&gt;create_app&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="a30ad45645f260b9af68a4e06f5cb6be21514be7" translate="yes" xml:space="preserve">
          <source>The name of the application. This is usually the import name with the difference that it&amp;rsquo;s guessed from the run file if the import name is main. This name is used as a display name when Flask needs the name of the application. It can be set and overridden to change the value.</source>
          <target state="translated">应用程序的名称。这通常是导入名称，如果导入名称为main，则与从运行文件中猜测的名称不同。当Flask需要应用程序名称时，此名称用作显示名称。可以设置和覆盖它以更改值。</target>
        </trans-unit>
        <trans-unit id="2a4adc8811d69689381056620a36660489737232" translate="yes" xml:space="preserve">
          <source>The name of the current blueprint</source>
          <target state="translated">当前蓝图的名称</target>
        </trans-unit>
        <trans-unit id="8da332f674821c1215a6cdf0239c462a4471546e" translate="yes" xml:space="preserve">
          <source>The name of the package is used to resolve resources from inside the package or the folder the module is contained in depending on if the package parameter resolves to an actual python package (a folder with an &lt;code&gt;__init__.py&lt;/code&gt; file inside) or a standard module (just a &lt;code&gt;.py&lt;/code&gt; file).</source>
          <target state="translated">软件包的名称用于从软件包内部或模块所在的文件夹中解析资源，具体取决于package参数是解析为实际的python软件包（内部带有 &lt;code&gt;__init__.py&lt;/code&gt; 文件的文件夹）还是标准模块（只是一个 &lt;code&gt;.py&lt;/code&gt; 文件）。</target>
        </trans-unit>
        <trans-unit id="8a983c0e01c96f261250f945a210fadb7a35ab17" translate="yes" xml:space="preserve">
          <source>The name of the package or module that this app belongs to. Do not change this once it is set by the constructor.</source>
          <target state="translated">这个应用程序所属的包或模块的名称。一旦被构造函数设置,就不要更改。</target>
        </trans-unit>
        <trans-unit id="f8903e2af7ae6986959042b6d2adaa14e4106abf" translate="yes" xml:space="preserve">
          <source>The name of the session cookie. Can be changed in case you already have a cookie with the same name.</source>
          <target state="translated">会话cookie的名称。如果你已经有一个相同名称的cookie,可以更改。</target>
        </trans-unit>
        <trans-unit id="b1bbfeba179266d592223973f58b34f742272e1a" translate="yes" xml:space="preserve">
          <source>The object is coerced to &lt;a href=&quot;#flask.Flask.response_class&quot;&gt;&lt;code&gt;response_class&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该对象被强制为&lt;a href=&quot;#flask.Flask.response_class&quot;&gt; &lt;code&gt;response_class&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f37360476efe6c4e49d1ad860eaa5fe628fedfc4" translate="yes" xml:space="preserve">
          <source>The object is returned unchanged.</source>
          <target state="translated">返回的对象没有变化。</target>
        </trans-unit>
        <trans-unit id="f85743fe58eaef22ad4871925b646035fdec3985" translate="yes" xml:space="preserve">
          <source>The origin of this quote is unknown and while it is not entirely correct, it is also not far from the truth. Untested applications make it hard to improve existing code and developers of untested applications tend to become pretty paranoid. If an application has automated tests, you can safely make changes and instantly know if anything breaks.</source>
          <target state="translated">这句话的出处不详,虽然不完全正确,但也离真理不远。未经测试的应用程序使现有的代码很难改进,未经测试的应用程序的开发人员往往会变得非常偏执。如果一个应用程序有自动测试,你可以安全地进行更改,并立即知道是否有任何破坏。</target>
        </trans-unit>
        <trans-unit id="4c65b930fbadd017497ace65f784ecc4b23f2455" translate="yes" xml:space="preserve">
          <source>The other possibility is passing a whole WSGI environment to the &lt;a href=&quot;../api/index#flask.Flask.request_context&quot;&gt;&lt;code&gt;request_context()&lt;/code&gt;&lt;/a&gt; method:</source>
          <target state="translated">另一种可能性是将整个WSGI环境传递给&lt;a href=&quot;../api/index#flask.Flask.request_context&quot;&gt; &lt;code&gt;request_context()&lt;/code&gt; &lt;/a&gt;方法：</target>
        </trans-unit>
        <trans-unit id="52fc4072704923f694f5f8510c2aa4edd3b9c832" translate="yes" xml:space="preserve">
          <source>The other use case of this function is to force the return value of a view function into a response which is helpful with view decorators:</source>
          <target state="translated">该函数的另一个用例是将视图函数的返回值强制到响应中,这对视图装饰器很有帮助。</target>
        </trans-unit>
        <trans-unit id="bfa181bdba63919c44b79e5bb02556ab0dc1cdff" translate="yes" xml:space="preserve">
          <source>The parsed &lt;code&gt;If-Modified-Since&lt;/code&gt; header as datetime object.</source>
          <target state="translated">解析的 &lt;code&gt;If-Modified-Since&lt;/code&gt; 标头作为日期时间对象。</target>
        </trans-unit>
        <trans-unit id="8739d5c7f64ef5719eab7b5dedf1b90baa24c1aa" translate="yes" xml:space="preserve">
          <source>The parsed &lt;code&gt;If-Range&lt;/code&gt; header.</source>
          <target state="translated">解析的 &lt;code&gt;If-Range&lt;/code&gt; 标头。</target>
        </trans-unit>
        <trans-unit id="3dd555ab87dfb8cae5b9fd670c133cacee687c36" translate="yes" xml:space="preserve">
          <source>The parsed &lt;code&gt;If-Unmodified-Since&lt;/code&gt; header as datetime object.</source>
          <target state="translated">解析的 &lt;code&gt;If-Unmodified-Since&lt;/code&gt; 标头作为日期时间对象。</target>
        </trans-unit>
        <trans-unit id="32ab2ece10dfafd46a8022fc23dd5751fe18aa56" translate="yes" xml:space="preserve">
          <source>The parsed &lt;code&gt;Range&lt;/code&gt; header.</source>
          <target state="translated">解析的 &lt;code&gt;Range&lt;/code&gt; 标头。</target>
        </trans-unit>
        <trans-unit id="aa8414dc14d5a78e679762493908b0234ebb0344" translate="yes" xml:space="preserve">
          <source>The parsed JSON data if &lt;a href=&quot;#flask.Request.mimetype&quot;&gt;&lt;code&gt;mimetype&lt;/code&gt;&lt;/a&gt; indicates JSON (&lt;em&gt;application/json&lt;/em&gt;, see &lt;a href=&quot;#flask.Request.is_json&quot;&gt;&lt;code&gt;is_json()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">如果&lt;a href=&quot;#flask.Request.mimetype&quot;&gt; &lt;code&gt;mimetype&lt;/code&gt; &lt;/a&gt;表示JSON，则解析的JSON数据（&lt;em&gt;application / json&lt;/em&gt;，请参见&lt;a href=&quot;#flask.Request.is_json&quot;&gt; &lt;code&gt;is_json()&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="2c3172fd9289fe9cb9d1b0764c4ce5521a4a2943" translate="yes" xml:space="preserve">
          <source>The parsed URL parameters (the part in the URL after the question mark).</source>
          <target state="translated">解析后的URL参数(URL中问号后的部分)。</target>
        </trans-unit>
        <trans-unit id="0508e436ad46cdb981bded5950ac71fd7e8f52bb" translate="yes" xml:space="preserve">
          <source>The path has to be the exact same path you define in the server config.</source>
          <target state="translated">路径必须与你在服务器配置中定义的路径完全相同。</target>
        </trans-unit>
        <trans-unit id="df681cb6252c73bf9b8da83938ad8133aa44b7a0" translate="yes" xml:space="preserve">
          <source>The path that the session cookie will be valid for. If not set, the cookie will be valid underneath &lt;code&gt;APPLICATION_ROOT&lt;/code&gt; or &lt;code&gt;/&lt;/code&gt; if that is not set.</source>
          <target state="translated">会话cookie将对其有效的路径。如果未设置，则该cookie将在 &lt;code&gt;APPLICATION_ROOT&lt;/code&gt; 下有效，或者在 &lt;code&gt;/&lt;/code&gt; 之下有效（如果未设置）。</target>
        </trans-unit>
        <trans-unit id="54ab13f7cd1d9e9e60441e680ada74a6f698a53e" translate="yes" xml:space="preserve">
          <source>The path to the instance folder can be found via the &lt;code&gt;Flask.instance_path&lt;/code&gt;. Flask also provides a shortcut to open a file from the instance folder with &lt;code&gt;Flask.open_instance_resource()&lt;/code&gt;.</source>
          <target state="translated">可以通过 &lt;code&gt;Flask.instance_path&lt;/code&gt; 找到实例文件夹的路径。Flask还提供了使用 &lt;code&gt;Flask.open_instance_resource()&lt;/code&gt; 从实例文件夹中打开文件的快捷方式。</target>
        </trans-unit>
        <trans-unit id="95951538922d2b0f804e4f42aceb85453023155f" translate="yes" xml:space="preserve">
          <source>The perfect level for abstraction in that regard is the WSGI layer. You write your own WSGI application that looks at the request that comes and delegates it to your Flask application. If that application does not exist yet, it is dynamically created and remembered:</source>
          <target state="translated">在这方面,抽象的完美层次是WSGI层。你写了自己的WSGI应用程序,它可以查看到来的请求并将其委托给你的Flask应用程序。如果这个应用程序还不存在,它就会被动态地创建和记忆。</target>
        </trans-unit>
        <trans-unit id="0132824b8ea930f12751f50a9d133542a24e83db" translate="yes" xml:space="preserve">
          <source>The prefix that should be used for all URLs defined on the blueprint.</source>
          <target state="translated">用于蓝图上定义的所有URL的前缀。</target>
        </trans-unit>
        <trans-unit id="0eb7662e5a58d135874ddf9cf5434788f83dacd8" translate="yes" xml:space="preserve">
          <source>The proxy objects cannot fake their type as the actual object types. If you want to perform instance checks, you have to do that on the object being proxied.</source>
          <target state="translated">代理对象不能伪造自己的类型作为实际对象的类型。如果要进行实例检查,必须对被代理的对象进行检查。</target>
        </trans-unit>
        <trans-unit id="24b4eab6430b4484800336ef86d5ea69a1229945" translate="yes" xml:space="preserve">
          <source>The reason for this is that for non-installed packages, the module filename is used to locate the resources and for symlinks the wrong filename is picked up.</source>
          <target state="translated">原因是对于未安装的包,模块的文件名是用来定位资源的,而对于符号链接,则会取到错误的文件名。</target>
        </trans-unit>
        <trans-unit id="b23839e8cd753a632f3342b567080611c6ad4759" translate="yes" xml:space="preserve">
          <source>The reconstructed current URL as IRI. See also: &lt;code&gt;trusted_hosts&lt;/code&gt;.</source>
          <target state="translated">重建的当前URL为IRI。另请参阅： &lt;code&gt;trusted_hosts&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8a2ded1485d2b5c28d8c659946a38e6fb9aa7423" translate="yes" xml:space="preserve">
          <source>The reference to the proxied object is needed in some situations, such as sending &lt;a href=&quot;../signals/index#signals&quot;&gt;Signals&lt;/a&gt; or passing data to a background thread.</source>
          <target state="translated">在某些情况下（例如发送&lt;a href=&quot;../signals/index#signals&quot;&gt;信号&lt;/a&gt;或将数据传递到后台线程），需要对代理对象的引用。</target>
        </trans-unit>
        <trans-unit id="d22fd9541f273e3f18577d3c9e1ac71ac610e7ce" translate="yes" xml:space="preserve">
          <source>The reloader and debugger are enabled by default if FLASK_ENV=development or FLASK_DEBUG=1.</source>
          <target state="translated">如果FLASK_ENV=development或FLASK_DEBUG=1,则默认启用重载器和调试器。</target>
        </trans-unit>
        <trans-unit id="5da4df5bfad1333922a47403bf537575f86f1786" translate="yes" xml:space="preserve">
          <source>The remote address of the client.</source>
          <target state="translated">客户端的远程地址。</target>
        </trans-unit>
        <trans-unit id="4e258a487af06cc1c7dd45c364b912d3494a99e1" translate="yes" xml:space="preserve">
          <source>The request context contains all request relevant information. It is created at the beginning of the request and pushed to the &lt;code&gt;_request_ctx_stack&lt;/code&gt; and removed at the end of it. It will create the URL adapter and request object for the WSGI environment provided.</source>
          <target state="translated">请求上下文包含所有与请求相关的信息。它是在请求的开始处创建的，并被推送到 &lt;code&gt;_request_ctx_stack&lt;/code&gt; 并在请求的末尾被删除。它将为提供的WSGI环境创建URL适配器和请求对象。</target>
        </trans-unit>
        <trans-unit id="5643355a5bc0bc60a281e7e5905b6d53104e1316" translate="yes" xml:space="preserve">
          <source>The request context is automatically popped at the end of the request for you. In debug mode the request context is kept around if exceptions happen so that interactive debuggers have a chance to introspect the data. With 0.4 this can also be forced for requests that did not fail and outside of &lt;code&gt;DEBUG&lt;/code&gt; mode. By setting &lt;code&gt;'flask._preserve_context'&lt;/code&gt; to &lt;code&gt;True&lt;/code&gt; on the WSGI environment the context will not pop itself at the end of the request. This is used by the &lt;a href=&quot;#flask.Flask.test_client&quot;&gt;&lt;code&gt;test_client()&lt;/code&gt;&lt;/a&gt; for example to implement the deferred cleanup functionality.</source>
          <target state="translated">在请求结束时，将自动弹出请求上下文。在调试模式下，如果发生异常，请求上下文将保持不变，以便交互式调试器有机会对数据进行内部检查。使用0.4时，也可以强制未失败且处于 &lt;code&gt;DEBUG&lt;/code&gt; 模式之外的请求。通过在WSGI环境上将 &lt;code&gt;'flask._preserve_context'&lt;/code&gt; 设置为 &lt;code&gt;True&lt;/code&gt; ，上下文将不会在请求结束时自行弹出。这是用来通过&lt;a href=&quot;#flask.Flask.test_client&quot;&gt; &lt;code&gt;test_client()&lt;/code&gt; &lt;/a&gt;例如以实现推迟清理功能。</target>
        </trans-unit>
        <trans-unit id="68140554c1a3f74fbcc231975e2c22d4e4dbfbc4" translate="yes" xml:space="preserve">
          <source>The request context keeps track of the request-level data during a request. Rather than passing the request object to each function that runs during a request, the &lt;a href=&quot;../api/index#flask.request&quot;&gt;&lt;code&gt;request&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../api/index#flask.session&quot;&gt;&lt;code&gt;session&lt;/code&gt;&lt;/a&gt; proxies are accessed instead.</source>
          <target state="translated">请求上下文在请求期间跟踪请求级别的数据。不是将请求对象传递给在请求期间运行的每个函数，而是访问&lt;a href=&quot;../api/index#flask.request&quot;&gt; &lt;code&gt;request&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../api/index#flask.session&quot;&gt; &lt;code&gt;session&lt;/code&gt; &lt;/a&gt;代理。</target>
        </trans-unit>
        <trans-unit id="e55fcb9a9798124bfad500f8ab946b75221ba339" translate="yes" xml:space="preserve">
          <source>The request method. (For example &lt;code&gt;'GET'&lt;/code&gt; or &lt;code&gt;'POST'&lt;/code&gt;).</source>
          <target state="translated">请求方法。（例如 &lt;code&gt;'GET'&lt;/code&gt; 或 &lt;code&gt;'POST'&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e9b57f22c8347674c21183a25ddfe062c6f2008f" translate="yes" xml:space="preserve">
          <source>The request object is a &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/wrappers/#werkzeug.wrappers.Request&quot;&gt;&lt;code&gt;Request&lt;/code&gt;&lt;/a&gt; subclass and provides all of the attributes Werkzeug defines plus a few Flask specific ones.</source>
          <target state="translated">request对象是&lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/wrappers/#werkzeug.wrappers.Request&quot;&gt; &lt;code&gt;Request&lt;/code&gt; &lt;/a&gt;子类，提供Werkzeug定义的所有属性以及一些Flask特定的属性。</target>
        </trans-unit>
        <trans-unit id="85fef113fdf709d32e7bf3411dfd326882867243" translate="yes" xml:space="preserve">
          <source>The request object is an instance of a &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/wrappers/#werkzeug.wrappers.Request&quot;&gt;&lt;code&gt;Request&lt;/code&gt;&lt;/a&gt; subclass and provides all of the attributes Werkzeug defines. This just shows a quick overview of the most important ones.</source>
          <target state="translated">request对象是&lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/wrappers/#werkzeug.wrappers.Request&quot;&gt; &lt;code&gt;Request&lt;/code&gt; &lt;/a&gt;子类的实例，并提供Werkzeug定义的所有属性。这只是最重要的部分的快速概述。</target>
        </trans-unit>
        <trans-unit id="3be4e475120f38ef9c1199f5a19c264fec6091b3" translate="yes" xml:space="preserve">
          <source>The request object is documented in the API section and we will not cover it here in detail (see &lt;a href=&quot;../api/index#flask.Request&quot;&gt;&lt;code&gt;Request&lt;/code&gt;&lt;/a&gt;). Here is a broad overview of some of the most common operations. First of all you have to import it from the &lt;code&gt;flask&lt;/code&gt; module:</source>
          <target state="translated">该请求对象已在API部分中进行了记录，在此我们将不对其进行详细介绍（请参阅&lt;a href=&quot;../api/index#flask.Request&quot;&gt; &lt;code&gt;Request&lt;/code&gt; &lt;/a&gt;）。这里是一些最常见操作的概述。首先，您必须从 &lt;code&gt;flask&lt;/code&gt; 模块导入它：</target>
        </trans-unit>
        <trans-unit id="3abf9e8b3dc82c97a1931a4b2834967948455d23" translate="yes" xml:space="preserve">
          <source>The request object used by default in Flask. Remembers the matched endpoint and view arguments.</source>
          <target state="translated">Flask中默认使用的请求对象。记住匹配的端点和视图参数。</target>
        </trans-unit>
        <trans-unit id="fa9cb536e76c729788223a11bc19a1a5a7b473f4" translate="yes" xml:space="preserve">
          <source>The request-bound object for global variables (&lt;a href=&quot;../api/index#flask.g&quot;&gt;&lt;code&gt;flask.g&lt;/code&gt;&lt;/a&gt;). This variable is unavailable if the template was rendered without an active request context.</source>
          <target state="translated">全局变量的请求绑定对象（&lt;a href=&quot;../api/index#flask.g&quot;&gt; &lt;code&gt;flask.g&lt;/code&gt; &lt;/a&gt;）。如果模板是在没有活动请求上下文的情况下呈现的，则此变量不可用。</target>
        </trans-unit>
        <trans-unit id="47f39485b96d2313aab336c4827486beb33b348f" translate="yes" xml:space="preserve">
          <source>The response object that is used by default in Flask. Works like the response object from Werkzeug but is set to have an HTML mimetype by default. Quite often you don&amp;rsquo;t have to create this object yourself because &lt;a href=&quot;#flask.Flask.make_response&quot;&gt;&lt;code&gt;make_response()&lt;/code&gt;&lt;/a&gt; will take care of that for you.</source>
          <target state="translated">Flask中默认使用的响应对象。就像来自Werkzeug的响应对象一样工作，但默认情况下将其设置为具有HTML mimetype。通常，您不必自己创建该对象，因为&lt;a href=&quot;#flask.Flask.make_response&quot;&gt; &lt;code&gt;make_response()&lt;/code&gt; &lt;/a&gt;会为您解决这个问题。</target>
        </trans-unit>
        <trans-unit id="c72591567569955a0df5b01d278b50547fb936ad" translate="yes" xml:space="preserve">
          <source>The response status as integer.</source>
          <target state="translated">响应状态为整数。</target>
        </trans-unit>
        <trans-unit id="9d19838713d76391b773130bb9ad89fb992cbc4b" translate="yes" xml:space="preserve">
          <source>The resulting dictionary &lt;code&gt;image_store_config&lt;/code&gt; would look like:</source>
          <target state="translated">生成的字典 &lt;code&gt;image_store_config&lt;/code&gt; 如下所示：</target>
        </trans-unit>
        <trans-unit id="56330a4802f18e72ece875ba2f5f62f84121787c" translate="yes" xml:space="preserve">
          <source>The return value from a view function is automatically converted into a response object for you. If the return value is a string it&amp;rsquo;s converted into a response object with the string as response body, a &lt;code&gt;200 OK&lt;/code&gt; status code and a &lt;em&gt;text/html&lt;/em&gt; mimetype. If the return value is a dict, &lt;code&gt;jsonify()&lt;/code&gt; is called to produce a response. The logic that Flask applies to converting return values into response objects is as follows:</source>
          <target state="translated">视图函数的返回值将自动转换为您的响应对象。如果返回值为字符串，则将其转换为带有字符串作为响应正文， &lt;code&gt;200 OK&lt;/code&gt; 状态代码和&lt;em&gt;text / html&lt;/em&gt; mimetype的响应对象。如果返回值为dict，则调用 &lt;code&gt;jsonify()&lt;/code&gt; 来生成响应。Flask应用于将返回值转换为响应对象的逻辑如下：</target>
        </trans-unit>
        <trans-unit id="fa48c8d5f479e6191afc8ff59ad189fcff097957" translate="yes" xml:space="preserve">
          <source>The return value of the view is converted into an actual response object and passed to the &lt;a href=&quot;../api/index#flask.Flask.after_request&quot;&gt;&lt;code&gt;after_request()&lt;/code&gt;&lt;/a&gt; functions. Each function returns a modified or new response object.</source>
          <target state="translated">视图的返回值将转换为实际的响应对象，并传递给&lt;a href=&quot;../api/index#flask.Flask.after_request&quot;&gt; &lt;code&gt;after_request()&lt;/code&gt; &lt;/a&gt;函数。每个函数都返回一个修改后的或新的响应对象。</target>
        </trans-unit>
        <trans-unit id="8edcd078400a26657ff2bd174bcfd8e3699687be" translate="yes" xml:space="preserve">
          <source>The return values of teardown functions are ignored.</source>
          <target state="translated">拆分函数的返回值会被忽略。</target>
        </trans-unit>
        <trans-unit id="2ac93b54faf273e18d8a4399ddd49e3c338e8c8b" translate="yes" xml:space="preserve">
          <source>The reverse of that function are &lt;a href=&quot;../../api/index#flask.Flask.url_value_preprocessor&quot;&gt;&lt;code&gt;url_value_preprocessor()&lt;/code&gt;&lt;/a&gt;s. They are executed right after the request was matched and can execute code based on the URL values. The idea is that they pull information out of the values dictionary and put it somewhere else:</source>
          <target state="translated">该函数的反向是&lt;a href=&quot;../../api/index#flask.Flask.url_value_preprocessor&quot;&gt; &lt;code&gt;url_value_preprocessor()&lt;/code&gt; &lt;/a&gt;。它们在请求匹配后立即执行，并且可以基于URL值执行代码。这个想法是他们将信息从值字典中拉出来，然后放在其他地方：</target>
        </trans-unit>
        <trans-unit id="ab1257fa3c510579e7f36cad8219503b6686df11" translate="yes" xml:space="preserve">
          <source>The root path of the script without the trailing slash.</source>
          <target state="translated">脚本的根路径,没有尾部的斜杠。</target>
        </trans-unit>
        <trans-unit id="22fe86c201290de21368fa079f7295b4233310f6" translate="yes" xml:space="preserve">
          <source>The same is true if you are talking to databases with the help of SQLAlchemy or a similar ORM system. Some databases have a protocol that already transmits Unicode and if they do not, SQLAlchemy or your other ORM should take care of that.</source>
          <target state="translated">如果你是在SQLAlchemy或类似的ORM系统的帮助下与数据库对话,情况也是如此。有些数据库有一个已经传输Unicode的协议,如果它们没有,SQLAlchemy或你的其他ORM应该会处理这个问题。</target>
        </trans-unit>
        <trans-unit id="bd1832d925fe18306b21c34350fef00792f624e3" translate="yes" xml:space="preserve">
          <source>The secure cookie uses this for the name of the session cookie.</source>
          <target state="translated">安全cookie使用这个作为会话cookie的名称。</target>
        </trans-unit>
        <trans-unit id="309cdc4566fe7de742bcea7de8d78333a18c4469" translate="yes" xml:space="preserve">
          <source>The session interface provides a simple way to replace the session implementation that Flask is using.</source>
          <target state="translated">会话接口提供了一种简单的方式来替换Flask正在使用的会话实现。</target>
        </trans-unit>
        <trans-unit id="5ea55beb90b9d2a46e5bf17c769d23a6ed3c54ae" translate="yes" xml:space="preserve">
          <source>The session object returned by the &lt;a href=&quot;#flask.sessions.SessionInterface.open_session&quot;&gt;&lt;code&gt;open_session()&lt;/code&gt;&lt;/a&gt; method has to provide a dictionary like interface plus the properties and methods from the &lt;a href=&quot;#flask.sessions.SessionMixin&quot;&gt;&lt;code&gt;SessionMixin&lt;/code&gt;&lt;/a&gt;. We recommend just subclassing a dict and adding that mixin:</source>
          <target state="translated">&lt;a href=&quot;#flask.sessions.SessionInterface.open_session&quot;&gt; &lt;code&gt;open_session()&lt;/code&gt; &lt;/a&gt;方法返回的会话对象必须提供字典，例如接口，以及&lt;a href=&quot;#flask.sessions.SessionMixin&quot;&gt; &lt;code&gt;SessionMixin&lt;/code&gt; &lt;/a&gt;的属性和方法。我们建议仅将dict子类化并添加该mixin：</target>
        </trans-unit>
        <trans-unit id="47bede1b92545a4e0bde295f046775841887cf89" translate="yes" xml:space="preserve">
          <source>The session object works pretty much like an ordinary dict, with the difference that it keeps track of modifications.</source>
          <target state="translated">会话对象的工作方式和普通的dict差不多,不同的是它会跟踪修改情况。</target>
        </trans-unit>
        <trans-unit id="068e52043d121c4c3455aeb55dae88e2ae1cfb41" translate="yes" xml:space="preserve">
          <source>The status code of the response will not be set to the handler&amp;rsquo;s code. Make sure to provide the appropriate HTTP status code when returning a response from a handler.</source>
          <target state="translated">响应的状态代码将不会设置为处理程序的代码。从处理程序返回响应时，请确保提供适当的HTTP状态代码。</target>
        </trans-unit>
        <trans-unit id="4976cfd650368c3f40c63d7a37d2fabec326cbc2" translate="yes" xml:space="preserve">
          <source>The subdomain that the blueprint should be active for, &lt;code&gt;None&lt;/code&gt; otherwise.</source>
          <target state="translated">蓝图应处于活动状态的子域，否则为 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e3603692624d29c09240a8bbdc2b9c6fc13b7abd" translate="yes" xml:space="preserve">
          <source>The system that enables having a central URL map is the &lt;a href=&quot;../../api/index#flask.Flask.add_url_rule&quot;&gt;&lt;code&gt;add_url_rule()&lt;/code&gt;&lt;/a&gt; function. Instead of using decorators, you have a file that sets up the application with all URLs.</source>
          <target state="translated">启用具有中央URL映射的系统是&lt;a href=&quot;../../api/index#flask.Flask.add_url_rule&quot;&gt; &lt;code&gt;add_url_rule()&lt;/code&gt; &lt;/a&gt;函数。您无需使用装饰器，而拥有一个使用所有URL设置应用程序的文件。</target>
        </trans-unit>
        <trans-unit id="871a5e66ef891cfa3612af6842d6a64a7c178ccb" translate="yes" xml:space="preserve">
          <source>The tag to mark the serialized object with. If &lt;code&gt;None&lt;/code&gt;, this tag is only used as an intermediate step during tagging.</source>
          <target state="translated">用于标记序列化对象的标签。如果为 &lt;code&gt;None&lt;/code&gt; ，则此标记仅用作标记期间的中间步骤。</target>
        </trans-unit>
        <trans-unit id="012096456ae82631e4763c61fa19a6235f506f6d" translate="yes" xml:space="preserve">
          <source>The teardown callbacks are independent of the request dispatch, and are instead called by the contexts when they are popped. The functions are called even if there is an unhandled exception during dispatch, and for manually pushed contexts. This means there is no guarantee that any other parts of the request dispatch have run first. Be sure to write these functions in a way that does not depend on other callbacks and will not fail.</source>
          <target state="translated">teardown回调是独立于请求派遣的,而是在上下文被弹出时被调用。即使在调度过程中出现了未处理的异常,这些函数也会被调用,对于手动推送的上下文也是如此。这意味着不能保证请求调度的任何其他部分已经先运行。一定要把这些函数写成不依赖其他回调的方式,不会失败。</target>
        </trans-unit>
        <trans-unit id="ee419b7541927cb6b4126f8a35979c11c1a90faa" translate="yes" xml:space="preserve">
          <source>The template folder is added to the search path of templates but with a lower priority than the actual application&amp;rsquo;s template folder. That way you can easily override templates that a blueprint provides in the actual application. This also means that if you don&amp;rsquo;t want a blueprint template to be accidentally overridden, make sure that no other blueprint or actual application template has the same relative path. When multiple blueprints provide the same relative template path the first blueprint registered takes precedence over the others.</source>
          <target state="translated">模板文件夹被添加到模板的搜索路径，但其优先级低于实际应用程序的模板文件夹。这样，您可以轻松覆盖蓝图在实际应用程序中提供的模板。这也意味着，如果您不希望蓝图模板被意外覆盖，请确保没有其他蓝图或实际应用程序模板具有相同的相对路径。当多个蓝图提供相同的相对模板路径时，第一个注册的蓝图优先于其他蓝图。</target>
        </trans-unit>
        <trans-unit id="29685d16878d312adeec67636c19db67f2324596" translate="yes" xml:space="preserve">
          <source>The test client can be used in a &lt;code&gt;with&lt;/code&gt; block to defer the closing down of the context until the end of the &lt;code&gt;with&lt;/code&gt; block. This is useful if you want to access the context locals for testing:</source>
          <target state="translated">可以在 &lt;code&gt;with&lt;/code&gt; 块中使用测试客户端，以将上下文的关闭推迟到 &lt;code&gt;with&lt;/code&gt; 块结束时。如果要访问上下文本地进行测试，这将很有用：</target>
        </trans-unit>
        <trans-unit id="986cbd00e5fa47dd03de99845f6f12f4008827b6" translate="yes" xml:space="preserve">
          <source>The testing flag. Set this to &lt;code&gt;True&lt;/code&gt; to enable the test mode of Flask extensions (and in the future probably also Flask itself). For example this might activate test helpers that have an additional runtime cost which should not be enabled by default.</source>
          <target state="translated">测试标志。将此设置为 &lt;code&gt;True&lt;/code&gt; 以启用Flask扩展的测试模式（将来可能还会包括Flask本身）。例如，这可能会激活具有额外运行时成本的测试助手，默认情况下不应启用这些运行时成本。</target>
        </trans-unit>
        <trans-unit id="8a85c8166a5e5f2a4fb58cc4c684246d8eae80bf" translate="yes" xml:space="preserve">
          <source>The third reason is &amp;ldquo;explicit is better than implicit&amp;rdquo;. That object is your WSGI application, you don&amp;rsquo;t have to remember anything else. If you want to apply a WSGI middleware, just wrap it and you&amp;rsquo;re done (though there are better ways to do that so that you do not lose the reference to the application object &lt;a href=&quot;../api/index#flask.Flask.wsgi_app&quot;&gt;&lt;code&gt;wsgi_app()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">第三个原因是&amp;ldquo;明确胜于隐含&amp;rdquo;。该对象是您的WSGI应用程序，您无需记住其他任何内容。如果您想应用WSGI中间件，只需将其包装就可以了（尽管有更好的方法可以做到这一点，以免丢失对应用程序对象&lt;a href=&quot;../api/index#flask.Flask.wsgi_app&quot;&gt; &lt;code&gt;wsgi_app()&lt;/code&gt; &lt;/a&gt;的引用）。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
