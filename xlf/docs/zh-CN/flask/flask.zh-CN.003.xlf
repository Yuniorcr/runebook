<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="flask">
    <body>
      <group id="flask">
        <trans-unit id="321b3650948ac8831655e280eaf2cb55a9f3ee98" translate="yes" xml:space="preserve">
          <source>The trick here is to get the template object from the Jinja2 environment on the application and to call &lt;a href=&quot;https://jinja.palletsprojects.com/en/2.11.x/api/#jinja2.Template.stream&quot;&gt;&lt;code&gt;stream()&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;https://jinja.palletsprojects.com/en/2.11.x/api/#jinja2.Template.render&quot;&gt;&lt;code&gt;render()&lt;/code&gt;&lt;/a&gt; which returns a stream object instead of a string. Since we&amp;rsquo;re bypassing the Flask template render functions and using the template object itself we have to make sure to update the render context ourselves by calling &lt;a href=&quot;../../api/index#flask.Flask.update_template_context&quot;&gt;&lt;code&gt;update_template_context()&lt;/code&gt;&lt;/a&gt;. The template is then evaluated as the stream is iterated over. Since each time you do a yield the server will flush the content to the client you might want to buffer up a few items in the template which you can do with &lt;code&gt;rv.enable_buffering(size)&lt;/code&gt;. &lt;code&gt;5&lt;/code&gt; is a sane default.</source>
          <target state="translated">这里的技巧是从应用程序的Jinja2环境中获取模板对象，并调用&lt;a href=&quot;https://jinja.palletsprojects.com/en/2.11.x/api/#jinja2.Template.stream&quot;&gt; &lt;code&gt;stream()&lt;/code&gt; &lt;/a&gt;而不是&lt;a href=&quot;https://jinja.palletsprojects.com/en/2.11.x/api/#jinja2.Template.render&quot;&gt; &lt;code&gt;render()&lt;/code&gt; &lt;/a&gt;，后者返回一个流对象而不是字符串。由于我们绕过了Flask模板渲染函数并使用了模板对象本身，因此我们必须确保通过调用&lt;a href=&quot;../../api/index#flask.Flask.update_template_context&quot;&gt; &lt;code&gt;update_template_context()&lt;/code&gt; &lt;/a&gt;来自行更新渲染上下文。然后在迭代流时评估模板。由于每次生成文件时，服务器都会将内容刷新到客户端，因此您可能希望在模板中缓冲一些项目，而您可以使用 &lt;code&gt;rv.enable_buffering(size)&lt;/code&gt; 进行处理。 &lt;code&gt;5&lt;/code&gt; 是理智的默认值。</target>
        </trans-unit>
        <trans-unit id="20ea639ec0667a7a3b220eab0f8dd66f08181b21" translate="yes" xml:space="preserve">
          <source>The two following examples work the same and both reverse an object:</source>
          <target state="translated">下面两个例子的工作原理是一样的,都是反转一个对象。</target>
        </trans-unit>
        <trans-unit id="d9fcc990d6599d2d6adb3a5b14b618e8528fdd1d" translate="yes" xml:space="preserve">
          <source>The underlying WSGI environment.</source>
          <target state="translated">WSGI的基础环境。</target>
        </trans-unit>
        <trans-unit id="537b4935e3367592afab1eae9f2141c7cd4601e7" translate="yes" xml:space="preserve">
          <source>The upside of this approach (connecting on first use) is that this will only open the connection if truly necessary. If you want to use this code outside a request context you can use it in a Python shell by opening the application context by hand:</source>
          <target state="translated">这种方法(第一次使用就连接)的好处是,只有在真正需要的时候才会打开连接。如果你想在请求上下文之外使用这段代码,你可以在Python shell中通过手动打开应用程序上下文来使用它。</target>
        </trans-unit>
        <trans-unit id="3b3aaa9460c11fe5351084c66f73bb024d869f2d" translate="yes" xml:space="preserve">
          <source>The way Flask is designed usually requires the configuration to be available when the application starts up. You can hard code the configuration in the code, which for many small applications is not actually that bad, but there are better ways.</source>
          <target state="translated">Flask的设计方式通常要求在应用程序启动时,配置必须是可用的。你可以在代码中硬编码配置,对于很多小程序来说,其实并没有那么糟糕,但是有更好的方法。</target>
        </trans-unit>
        <trans-unit id="3654d59a4128e3439eda626c3c65d729fcf239be" translate="yes" xml:space="preserve">
          <source>The way this works is by letting the client do an HTTP POST request and set the &lt;code&gt;X-HTTP-Method-Override&lt;/code&gt; header. Then the method is replaced with the header value before being passed to Flask.</source>
          <target state="translated">这种工作方式是让客户端执行HTTP POST请求并设置 &lt;code&gt;X-HTTP-Method-Override&lt;/code&gt; 标头。然后，在将方法传递给Flask之前，将其替换为标头值。</target>
        </trans-unit>
        <trans-unit id="bf47bc15260487d4b0ab18941315bb211a355f52" translate="yes" xml:space="preserve">
          <source>Then the &lt;code&gt;create_app&lt;/code&gt; factory in &lt;code&gt;myapp&lt;/code&gt; is called with the string &lt;code&gt;'dev'&lt;/code&gt; as the argument. See &lt;a href=&quot;../../cli/index&quot;&gt;Command Line Interface&lt;/a&gt; for more detail.</source>
          <target state="translated">然后以字符串 &lt;code&gt;'dev'&lt;/code&gt; 作为参数调用 &lt;code&gt;myapp&lt;/code&gt; 中的 &lt;code&gt;create_app&lt;/code&gt; 工厂。有关更多详细信息，请参见&lt;a href=&quot;../../cli/index&quot;&gt;命令行界面&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2b18db475760288f2b455d0b5f405a9f302f85ca" translate="yes" xml:space="preserve">
          <source>Then you can define your central place to combine the views like this:</source>
          <target state="translated">然后,你可以定义你的中心位置,像这样结合观点。</target>
        </trans-unit>
        <trans-unit id="8d03dcf4c35736174cd9b7d74bec6f051b55e1d0" translate="yes" xml:space="preserve">
          <source>Then you can either declare the tables in your code like in the examples above, or automatically load them:</source>
          <target state="translated">然后,你可以像上面的例子一样在你的代码中声明表格,或者自动加载它们。</target>
        </trans-unit>
        <trans-unit id="daec0a62173c4e0a469a18d74aa20df51a68a78a" translate="yes" xml:space="preserve">
          <source>Then you just have to add a separate &lt;code&gt;config.py&lt;/code&gt; file and export &lt;code&gt;YOURAPPLICATION_SETTINGS=/path/to/config.py&lt;/code&gt; and you are done. However there are alternative ways as well. For example you could use imports or subclassing.</source>
          <target state="translated">然后，您只需要添加一个单独的 &lt;code&gt;config.py&lt;/code&gt; 文件并导出 &lt;code&gt;YOURAPPLICATION_SETTINGS=/path/to/config.py&lt;/code&gt; 就可以了。但是，还有其他方法。例如，您可以使用导入或子类化。</target>
        </trans-unit>
        <trans-unit id="9589a37c12b59e56b807d74432ef16cb2859ed1a" translate="yes" xml:space="preserve">
          <source>Then you still have the original application object around and can continue to call methods on it.</source>
          <target state="translated">那么你仍然有原来的应用对象在身边,可以继续对它调用方法。</target>
        </trans-unit>
        <trans-unit id="09ad95fe308e16d1fbef8a9aa708b10443608c06" translate="yes" xml:space="preserve">
          <source>Then, with the centralized approach you would have one file with the views (&lt;code&gt;views.py&lt;/code&gt;) but without any decorator:</source>
          <target state="translated">然后，采用集中式方法，您将拥有一个包含视图的文件（ &lt;code&gt;views.py&lt;/code&gt; ），但没有任何装饰器：</target>
        </trans-unit>
        <trans-unit id="472eacc74a9f0d6593fc850c37ed65a338647890" translate="yes" xml:space="preserve">
          <source>There are four very common ways to use SQLAlchemy. I will outline each of them here:</source>
          <target state="translated">使用SQLAlchemy有四种非常常见的方法。我将在这里逐一概述。</target>
        </trans-unit>
        <trans-unit id="71e898a483ad3580ae10e846efe9e8b850777f96" translate="yes" xml:space="preserve">
          <source>There are however some handy helpers to make playing around in the shell a more pleasant experience. The main issue with interactive console sessions is that you&amp;rsquo;re not triggering a request like a browser does which means that &lt;a href=&quot;../api/index#flask.g&quot;&gt;&lt;code&gt;g&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../api/index#flask.request&quot;&gt;&lt;code&gt;request&lt;/code&gt;&lt;/a&gt; and others are not available. But the code you want to test might depend on them, so what can you do?</source>
          <target state="translated">但是，有一些方便的助手可以使您在外壳中玩耍更加愉快。交互式控制台会话的主要问题是您不会像浏览器那样触发请求，这意味着&lt;a href=&quot;../api/index#flask.g&quot;&gt; &lt;code&gt;g&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../api/index#flask.request&quot;&gt; &lt;code&gt;request&lt;/code&gt; &lt;/a&gt;和其他不可用。但是您要测试的代码可能取决于它们，那么您该怎么办？</target>
        </trans-unit>
        <trans-unit id="7fded1f4fb1cfe9ac220017de27a35fbdb9cb1eb" translate="yes" xml:space="preserve">
          <source>There are many different ways and it&amp;rsquo;s up to you how you want to manage your configuration files. However here a list of good recommendations:</source>
          <target state="translated">有很多不同的方法，取决于您如何管理配置文件。但是，这里列出了一些不错的建议：</target>
        </trans-unit>
        <trans-unit id="da96bc2de1277b8591d8d2bcf01d23096d9c88eb" translate="yes" xml:space="preserve">
          <source>There are many more ways to define and query documents with MongoEngine. For more information, check out the &lt;a href=&quot;http://mongoengine.org&quot;&gt;official documentation&lt;/a&gt;.</source>
          <target state="translated">还有更多使用MongoEngine定义和查询文档的方法。有关更多信息，请查阅&lt;a href=&quot;http://mongoengine.org&quot;&gt;官方文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9a2e6264017a6edd0235b922fdb00233ee18c526" translate="yes" xml:space="preserve">
          <source>There are more parameters that are explained in the &lt;a href=&quot;../server/index#server&quot;&gt;Development Server&lt;/a&gt; docs.</source>
          <target state="translated">&lt;a href=&quot;../server/index#server&quot;&gt;开发服务器&lt;/a&gt;文档中介绍了更多参数。</target>
        </trans-unit>
        <trans-unit id="5898775a2c63e8590f3b9e33a65778d8d0a352aa" translate="yes" xml:space="preserve">
          <source>There are popular servers written in Python that contain WSGI applications and serve HTTP. These servers stand alone when they run; you can proxy to them from your web server. Note the section on &lt;a href=&quot;#deploying-proxy-setups&quot;&gt;Proxy Setups&lt;/a&gt; if you run into issues.</source>
          <target state="translated">有一些用Python编写的流行服务器，其中包含WSGI应用程序并提供HTTP服务。这些服务器在运行时是独立的。您可以从Web服务器代理它们。如果遇到问题，请注意&amp;ldquo;&lt;a href=&quot;#deploying-proxy-setups&quot;&gt;代理设置&lt;/a&gt;&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="928ecf304db8ea6d6fa56d3b9b51260430f1de46" translate="yes" xml:space="preserve">
          <source>There are still some problems with that approach but if you want to use decorators there is no way around that. Check out the &lt;a href=&quot;../../becomingbig/index#becomingbig&quot;&gt;Becoming Big&lt;/a&gt; section for some inspiration how to deal with that.</source>
          <target state="translated">这种方法仍然存在一些问题，但是如果您要使用装饰器，则无法解决。请查看&amp;ldquo;&lt;a href=&quot;../../becomingbig/index#becomingbig&quot;&gt;成为大人物&amp;rdquo;&lt;/a&gt;部分，以获取一些有关如何解决该问题的灵感。</target>
        </trans-unit>
        <trans-unit id="15e96a27ee4082ad0311662e2a39dd9fd3f40168" translate="yes" xml:space="preserve">
          <source>There are three major reasons for this. The most important one is that implicit application objects require that there may only be one instance at the time. There are ways to fake multiple applications with a single application object, like maintaining a stack of applications, but this causes some problems I won&amp;rsquo;t outline here in detail. Now the question is: when does a microframework need more than one application at the same time? A good example for this is unit testing. When you want to test something it can be very helpful to create a minimal application to test specific behavior. When the application object is deleted everything it allocated will be freed again.</source>
          <target state="translated">这样做的主要原因有三个。最重要的是，隐式应用程序对象要求此时只能有一个实例。有多种方法可以使用单个应用程序对象来伪造多个应用程序，例如维护一堆应用程序，但这会导致一些问题，在此不再赘述。现在的问题是：微框架何时同时需要多个应用程序？一个很好的例子就是单元测试。当您要测试某些东西时，创建一个最小的应用程序来测试特定行为可能会非常有帮助。删除应用程序对象后，分配给它的所有内容都将再次释放。</target>
        </trans-unit>
        <trans-unit id="d6faad00ba8c341e9b40b3f7db4c5ea5520d4cbb" translate="yes" xml:space="preserve">
          <source>There are three ways to accomplish that:</source>
          <target state="translated">有三种方法可以达到这个目的。</target>
        </trans-unit>
        <trans-unit id="1c9c5c28e806eb842806889bd3af7ae28e6215bb" translate="yes" xml:space="preserve">
          <source>There is one class of XSS issues that Jinja&amp;rsquo;s escaping does not protect against. The &lt;code&gt;a&lt;/code&gt; tag&amp;rsquo;s &lt;code&gt;href&lt;/code&gt; attribute can contain a &lt;code&gt;javascript:&lt;/code&gt; URI, which the browser will execute when clicked if not secured properly.</source>
          <target state="translated">Jinja的转义无法防范一类XSS问题。在 &lt;code&gt;a&lt;/code&gt; 标签的 &lt;code&gt;href&lt;/code&gt; 属性可以包含 &lt;code&gt;javascript:&lt;/code&gt; URI，点击它时，如果没有适当的安全浏览器将执行。</target>
        </trans-unit>
        <trans-unit id="c7c00687affa82f91d7111a12efc15fe808a7f0c" translate="yes" xml:space="preserve">
          <source>There is only one limiting factor regarding scaling in Flask which are the context local proxies. They depend on context which in Flask is defined as being either a thread, process or greenlet. If your server uses some kind of concurrency that is not based on threads or greenlets, Flask will no longer be able to support these global proxies. However the majority of servers are using either threads, greenlets or separate processes to achieve concurrency which are all methods well supported by the underlying Werkzeug library.</source>
          <target state="translated">在Flask中只有一个限制因素,那就是上下文本地代理。它们依赖于上下文,而上下文在Flask中被定义为线程、进程或greenlet。如果你的服务器使用某种不基于线程或greenlet的并发,Flask将不再能够支持这些全局代理。然而大多数服务器都是使用线程、greenlet或者独立的进程来实现并发,这些方法都是底层的Werkzeug库所支持的。</target>
        </trans-unit>
        <trans-unit id="9c3884cf380a23933fa4502691cf2361b8e81b98" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s quite a few options to change, but once we&amp;rsquo;ve done it for one command, we can easily copy the entire configuration and make a single tweak to give us access to other commands, including any custom ones you may implement yourself.</source>
          <target state="translated">更改的选项很多，但是一旦完成一个命令，我们就可以轻松复制整个配置并进行一次调整，使我们能够访问其他命令，包括您可以自己实现的任何自定义命令。</target>
        </trans-unit>
        <trans-unit id="35835fa75ed9020125850c44ceab56114f95b1f4" translate="yes" xml:space="preserve">
          <source>These can be added to the &lt;code&gt;.flaskenv&lt;/code&gt; file just like &lt;code&gt;FLASK_APP&lt;/code&gt; to control default command options.</source>
          <target state="translated">它们可以像 &lt;code&gt;FLASK_APP&lt;/code&gt; 一样添加到 &lt;code&gt;.flaskenv&lt;/code&gt; 文件中，以控制默认命令选项。</target>
        </trans-unit>
        <trans-unit id="3a09cd827fffcec8212a890c079cd0551e75f1e7" translate="yes" xml:space="preserve">
          <source>These distributions will be installed automatically when installing Flask.</source>
          <target state="translated">这些发行版将在安装Flask时自动安装。</target>
        </trans-unit>
        <trans-unit id="29d64fd15b4970cdfba96a6647045f8c7097f977" translate="yes" xml:space="preserve">
          <source>These distributions will not be installed automatically. Flask will detect and use them if you install them.</source>
          <target state="translated">这些发行版不会被自动安装。如果您安装了这些发行版,Flask将检测并使用它们。</target>
        </trans-unit>
        <trans-unit id="48d2d208ca1e3d8126722d439eafac881a1103e5" translate="yes" xml:space="preserve">
          <source>These options can be added to a &lt;code&gt;Set-Cookie&lt;/code&gt; header to improve their security. Flask has configuration options to set these on the session cookie. They can be set on other cookies too.</source>
          <target state="translated">可以将这些选项添加到 &lt;code&gt;Set-Cookie&lt;/code&gt; 标头中，以提高其安全性。Flask具有配置选项，可在会话Cookie上进行设置。也可以将它们设置在其他cookie上。</target>
        </trans-unit>
        <trans-unit id="134b21b8282573374e68bc59df1e0bbfa4d8e714" translate="yes" xml:space="preserve">
          <source>These processes will be managed by Apache. If you&amp;rsquo;re using a standalone FastCGI server, you can use the FastCgiExternalServer directive instead. Note that in the following the path is not real, it&amp;rsquo;s simply used as an identifier to other directives such as AliasMatch:</source>
          <target state="translated">这些过程将由Apache管理。如果您使用的是独立的FastCGI服务器，则可以使用FastCgiExternalServer指令。请注意，以下路径不是真实的，它只是用作其他指令（例如AliasMatch）的标识符：</target>
        </trans-unit>
        <trans-unit id="dbf05e019d39bb46213a7d05f2b3c2772d8ba685" translate="yes" xml:space="preserve">
          <source>These results are also dict-like tuples:</source>
          <target state="translated">这些结果也是类似dict的tuple。</target>
        </trans-unit>
        <trans-unit id="858f8f2bc57fff1a6d23326726e5ee5dfcfd7d80" translate="yes" xml:space="preserve">
          <source>These types of patterns may be a bit outside the scope of Flask itself, but Flask makes it easy to implement them. Some common patterns are collected in the following pages.</source>
          <target state="translated">这些类型的模式可能有点超出Flask本身的范围,但Flask使其易于实现。下面的页面中收集了一些常见的模式。</target>
        </trans-unit>
        <trans-unit id="3ce013ab8e968381e9cf7d34f24ab30caf79bf3d" translate="yes" xml:space="preserve">
          <source>These variables are added to the context of variables, they are not global variables. The difference is that by default these will not show up in the context of imported templates. This is partially caused by performance considerations, partially to keep things explicit.</source>
          <target state="translated">这些变量被添加到变量的上下文中,它们不是全局变量。不同的是,默认情况下,这些不会显示在导入模板的上下文中。这部分是出于性能考虑,部分是为了保持明确性。</target>
        </trans-unit>
        <trans-unit id="d02efca86e66ddac497e623f13ad84f059c26ada" translate="yes" xml:space="preserve">
          <source>Things to remember:</source>
          <target state="translated">要记住的事情。</target>
        </trans-unit>
        <trans-unit id="9162813227931fe8d990673b898b0b235811b1de" translate="yes" xml:space="preserve">
          <source>This accepts the same options as the &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/test/#werkzeug.test.EnvironBuilder&quot;&gt;&lt;code&gt;EnvironBuilder&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这接受与&lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/test/#werkzeug.test.EnvironBuilder&quot;&gt; &lt;code&gt;EnvironBuilder&lt;/code&gt; &lt;/a&gt;相同的选项。</target>
        </trans-unit>
        <trans-unit id="dc7c127cfd36f7c9a5636e65dc46def80fe46ca3" translate="yes" xml:space="preserve">
          <source>This allows subclasses to change the behavior when sending files based on the filename. For example, to set the cache timeout for .js files to 60 seconds:</source>
          <target state="translated">这允许子类根据文件名来改变发送文件时的行为。例如,将.js文件的缓存超时设置为60秒。</target>
        </trans-unit>
        <trans-unit id="6a875a3e4b070b9429d7cd3fe3ab0b39962bb0f8" translate="yes" xml:space="preserve">
          <source>This approach is explained in detail in the &lt;a href=&quot;../../config/index#config&quot;&gt;Configuration Handling&lt;/a&gt; section of the documentation.</source>
          <target state="translated">在文档的&amp;ldquo;&lt;a href=&quot;../../config/index#config&quot;&gt;配置处理&amp;rdquo;&lt;/a&gt;部分中详细说明了此方法。</target>
        </trans-unit>
        <trans-unit id="804fc35c2d664df58f4558921552568d52bf51fd" translate="yes" xml:space="preserve">
          <source>This attribute can also be configured from the config with the &lt;a href=&quot;../config/index#SECRET_KEY&quot;&gt;&lt;code&gt;SECRET_KEY&lt;/code&gt;&lt;/a&gt; configuration key. Defaults to &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">也可以使用&lt;a href=&quot;../config/index#SECRET_KEY&quot;&gt; &lt;code&gt;SECRET_KEY&lt;/code&gt; &lt;/a&gt;配置密钥从配置中配置此属性。默认为 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c14ba1a484a4372f0ddfd5c528d2b89bea6dce02" translate="yes" xml:space="preserve">
          <source>This attribute can also be configured from the config with the &lt;code&gt;PERMANENT_SESSION_LIFETIME&lt;/code&gt; configuration key. Defaults to &lt;code&gt;timedelta(days=31)&lt;/code&gt;</source>
          <target state="translated">也可以使用 &lt;code&gt;PERMANENT_SESSION_LIFETIME&lt;/code&gt; 配置键从配置中配置此属性。默认为 &lt;code&gt;timedelta(days=31)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ee1b0634c22ecf7528db41462ccae50eda62c4bd" translate="yes" xml:space="preserve">
          <source>This attribute can also be configured from the config with the &lt;code&gt;SEND_FILE_MAX_AGE_DEFAULT&lt;/code&gt; configuration key. This configuration variable can also be set with an integer value used as seconds. Defaults to &lt;code&gt;timedelta(hours=12)&lt;/code&gt;</source>
          <target state="translated">也可以使用 &lt;code&gt;SEND_FILE_MAX_AGE_DEFAULT&lt;/code&gt; 配置键从配置中配置此属性。也可以使用整数值（以秒为单位）设置此配置变量。默认为 &lt;code&gt;timedelta(hours=12)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="13dd8d3fce11a07385f0308479a9b1d2ab1e432e" translate="yes" xml:space="preserve">
          <source>This attribute can also be configured from the config with the &lt;code&gt;SESSION_COOKIE_NAME&lt;/code&gt; configuration key. Defaults to &lt;code&gt;'session'&lt;/code&gt;</source>
          <target state="translated">也可以使用 &lt;code&gt;SESSION_COOKIE_NAME&lt;/code&gt; 配置密钥从配置中配置此属性。默认为 &lt;code&gt;'session'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="30f40dd48468931411ebedba547d4a02062370c7" translate="yes" xml:space="preserve">
          <source>This attribute can also be configured from the config with the &lt;code&gt;TESTING&lt;/code&gt; configuration key. Defaults to &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">也可以使用 &lt;code&gt;TESTING&lt;/code&gt; 配置键从配置中配置此属性。默认为 &lt;code&gt;False&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ddb27d3c8d3d1616f3a14c012b99110fce2ce8fa" translate="yes" xml:space="preserve">
          <source>This attribute can also be configured from the config with the &lt;code&gt;USE_X_SENDFILE&lt;/code&gt; configuration key. Defaults to &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">也可以使用 &lt;code&gt;USE_X_SENDFILE&lt;/code&gt; 配置密钥从配置中配置此属性。默认为 &lt;code&gt;False&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8a77842201b2dc95e38106579423d0ecc80ebc21" translate="yes" xml:space="preserve">
          <source>This attribute can be configured with &lt;a href=&quot;../config/index#TEMPLATES_AUTO_RELOAD&quot;&gt;&lt;code&gt;TEMPLATES_AUTO_RELOAD&lt;/code&gt;&lt;/a&gt;. If not set, it will be enabled in debug mode.</source>
          <target state="translated">可以使用&lt;a href=&quot;../config/index#TEMPLATES_AUTO_RELOAD&quot;&gt; &lt;code&gt;TEMPLATES_AUTO_RELOAD&lt;/code&gt; &lt;/a&gt;来配置此属性。如果未设置，它将在调试模式下启用。</target>
        </trans-unit>
        <trans-unit id="93f1355d94a62d3dcc34ca90ecdf621370445f30" translate="yes" xml:space="preserve">
          <source>This attribute is set to &lt;code&gt;True&lt;/code&gt; if the application started handling the first request.</source>
          <target state="translated">如果应用程序开始处理第一个请求，则此属性设置为 &lt;code&gt;True&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="47c31973616f3cefb86bc251826d632ace30be60" translate="yes" xml:space="preserve">
          <source>This behavior can be controlled with the &lt;a href=&quot;../config/index#PRESERVE_CONTEXT_ON_EXCEPTION&quot;&gt;&lt;code&gt;PRESERVE_CONTEXT_ON_EXCEPTION&lt;/code&gt;&lt;/a&gt; config. As described above, it defaults to &lt;code&gt;True&lt;/code&gt; in the development environment.</source>
          <target state="translated">可以使用&lt;a href=&quot;../config/index#PRESERVE_CONTEXT_ON_EXCEPTION&quot;&gt; &lt;code&gt;PRESERVE_CONTEXT_ON_EXCEPTION&lt;/code&gt; &lt;/a&gt;配置控制此行为。如上所述，在开发环境中默认为 &lt;code&gt;True&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="44d1d6597dfd8a5eacaee7c2854ab9392c0bf744" translate="yes" xml:space="preserve">
          <source>This calls all functions decorated with &lt;a href=&quot;#flask.Flask.teardown_appcontext&quot;&gt;&lt;code&gt;teardown_appcontext()&lt;/code&gt;&lt;/a&gt;. Then the &lt;a href=&quot;#flask.appcontext_tearing_down&quot;&gt;&lt;code&gt;appcontext_tearing_down&lt;/code&gt;&lt;/a&gt; signal is sent.</source>
          <target state="translated">这将调用所有以&lt;a href=&quot;#flask.Flask.teardown_appcontext&quot;&gt; &lt;code&gt;teardown_appcontext()&lt;/code&gt; &lt;/a&gt;装饰的函数。然后发送&lt;a href=&quot;#flask.appcontext_tearing_down&quot;&gt; &lt;code&gt;appcontext_tearing_down&lt;/code&gt; &lt;/a&gt;信号。</target>
        </trans-unit>
        <trans-unit id="85d062da99b51b692d776f88345dfb31cbf16f69" translate="yes" xml:space="preserve">
          <source>This calls all functions decorated with &lt;a href=&quot;#flask.Flask.teardown_request&quot;&gt;&lt;code&gt;teardown_request()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#flask.Blueprint.teardown_request&quot;&gt;&lt;code&gt;Blueprint.teardown_request()&lt;/code&gt;&lt;/a&gt; if a blueprint handled the request. Finally, the &lt;a href=&quot;#flask.request_tearing_down&quot;&gt;&lt;code&gt;request_tearing_down&lt;/code&gt;&lt;/a&gt; signal is sent.</source>
          <target state="translated">如果蓝图处理了请求，则此方法将调用所有装饰有&lt;a href=&quot;#flask.Flask.teardown_request&quot;&gt; &lt;code&gt;teardown_request()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#flask.Blueprint.teardown_request&quot;&gt; &lt;code&gt;Blueprint.teardown_request()&lt;/code&gt; 的&lt;/a&gt;函数。最后，发送&lt;a href=&quot;#flask.request_tearing_down&quot;&gt; &lt;code&gt;request_tearing_down&lt;/code&gt; &lt;/a&gt;信号。</target>
        </trans-unit>
        <trans-unit id="12d85f9a8204975d20437b4f139f4f382330c8d3" translate="yes" xml:space="preserve">
          <source>This can be a problem if your application has to import quick. It might have to do that on systems like Google&amp;rsquo;s App Engine or other systems. So if you suddenly notice that your application outgrows this approach you can fall back to a centralized URL mapping.</source>
          <target state="translated">如果您的应用程序必须快速导入，则可能会出现问题。它可能必须在Google的App Engine或其他系统上执行此操作。因此，如果您突然发现应用程序不再适合这种方法，则可以使用集中式URL映射。</target>
        </trans-unit>
        <trans-unit id="455ece4693060f7c6e43193844070f1932581a01" translate="yes" xml:space="preserve">
          <source>This can be accomplished with an HTTP middleware:</source>
          <target state="translated">这可以通过一个HTTP中间件来实现。</target>
        </trans-unit>
        <trans-unit id="c0c0dd21e69d0a8a798a621d9bc8ff4a9841cbd7" translate="yes" xml:space="preserve">
          <source>This can be necessary to open database connections or something similar depending on how your application was designed.</source>
          <target state="translated">这可能是打开数据库连接或类似的东西所必需的,这取决于你的应用程序是如何设计的。</target>
        </trans-unit>
        <trans-unit id="f376e8b728e1d3a7d77a33e5ed80767b6ee59ead" translate="yes" xml:space="preserve">
          <source>This can now easily be paired with a test client:</source>
          <target state="translated">现在,这可以很容易地与测试客户端配对。</target>
        </trans-unit>
        <trans-unit id="4e3a6b916130c10b66b2e43aab3914b4c0640b93" translate="yes" xml:space="preserve">
          <source>This check is usually skipped if the session was deleted.</source>
          <target state="translated">如果会话被删除,通常会跳过这项检查。</target>
        </trans-unit>
        <trans-unit id="afa6d452e4abff29640ff00bcd2267f10d8de51a" translate="yes" xml:space="preserve">
          <source>This checks if the object is an instance of &lt;a href=&quot;#flask.sessions.SessionInterface.null_session_class&quot;&gt;&lt;code&gt;null_session_class&lt;/code&gt;&lt;/a&gt; by default.</source>
          <target state="translated">默认情况下，这将检查对象是否为&lt;a href=&quot;#flask.sessions.SessionInterface.null_session_class&quot;&gt; &lt;code&gt;null_session_class&lt;/code&gt; &lt;/a&gt;的实例。</target>
        </trans-unit>
        <trans-unit id="730a4146b3fdf2a11277d63dc15bebc83bd17dfe" translate="yes" xml:space="preserve">
          <source>This client fixture will be called by each individual test. It gives us a simple interface to the application, where we can trigger test requests to the application. The client will also keep track of cookies for us.</source>
          <target state="translated">这个客户端夹具将被每个单独的测试所调用。它为我们提供了一个简单的应用程序接口,我们可以触发对应用程序的测试请求。客户端还将为我们跟踪cookies。</target>
        </trans-unit>
        <trans-unit id="335d39c4ec67765057fa66ec21f6f1010b5650d7" translate="yes" xml:space="preserve">
          <source>This configuration binds the application to &lt;code&gt;/yourapplication&lt;/code&gt;. If you want to have it in the URL root it&amp;rsquo;s a bit simpler because you don&amp;rsquo;t have to figure out how to calculate &lt;code&gt;PATH_INFO&lt;/code&gt; and &lt;code&gt;SCRIPT_NAME&lt;/code&gt;:</source>
          <target state="translated">此配置将应用程序绑定到 &lt;code&gt;/yourapplication&lt;/code&gt; 。如果要在URL根目录中添加它， &lt;code&gt;SCRIPT_NAME&lt;/code&gt; 简单一些，因为您不必弄清楚如何计算 &lt;code&gt;PATH_INFO&lt;/code&gt; 和SCRIPT_NAME：</target>
        </trans-unit>
        <trans-unit id="7bd999f74182b278e30e7d8447d9cd71a92772ae" translate="yes" xml:space="preserve">
          <source>This configuration binds the application to &lt;code&gt;/yourapplication&lt;/code&gt;. If you want to have it in the URL root its a bit simpler:</source>
          <target state="translated">此配置将应用程序绑定到 &lt;code&gt;/yourapplication&lt;/code&gt; 。如果要在URL根目录中添加它，则要简单一些：</target>
        </trans-unit>
        <trans-unit id="1d6a76c6c818fd4fcb0ca0f5afdbdd7643bc6fc3" translate="yes" xml:space="preserve">
          <source>This creates an instance of &lt;a href=&quot;#flask.sessions.SessionInterface.null_session_class&quot;&gt;&lt;code&gt;null_session_class&lt;/code&gt;&lt;/a&gt; by default.</source>
          <target state="translated">默认情况下，这将创建&lt;a href=&quot;#flask.sessions.SessionInterface.null_session_class&quot;&gt; &lt;code&gt;null_session_class&lt;/code&gt; &lt;/a&gt;的实例。</target>
        </trans-unit>
        <trans-unit id="c3a00ac514ae27d7a421f076066c74db3d510a43" translate="yes" xml:space="preserve">
          <source>This dispatcher can then be used like this:</source>
          <target state="translated">这个调度器就可以这样使用。</target>
        </trans-unit>
        <trans-unit id="71b5d1f44dfc118ba731271d0278017136ca6711" translate="yes" xml:space="preserve">
          <source>This does the following things:</source>
          <target state="translated">这样做有以下作用:</target>
        </trans-unit>
        <trans-unit id="d25e537830a08f59356a72a2248d40060f19ac8b" translate="yes" xml:space="preserve">
          <source>This enables the development environment, including the interactive debugger and reloader, and then starts the server on &lt;em&gt;http://localhost:5000/&lt;/em&gt;.</source>
          <target state="translated">这将启用包括交互式调试器和重新加载器的开发环境，然后在&lt;em&gt;http：// localhost：5000 /&lt;/em&gt;上启动服务器。</target>
        </trans-unit>
        <trans-unit id="d0c2ade2b72b6546273b4c212a19aefe3247b955" translate="yes" xml:space="preserve">
          <source>This example adds the command &lt;code&gt;create-user&lt;/code&gt; that takes the argument &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">本示例添加了带有参数 &lt;code&gt;name&lt;/code&gt; 的命令 &lt;code&gt;create-user&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="de849750f32cffa06ab924f2ed604d03a611bbe8" translate="yes" xml:space="preserve">
          <source>This example adds the same command, but as &lt;code&gt;user create&lt;/code&gt;, a command in a group. This is useful if you want to organize multiple related commands.</source>
          <target state="translated">本示例添加了相同的命令，但是作为 &lt;code&gt;user create&lt;/code&gt; ，将其添加为组中的命令。如果要组织多个相关命令，这将很有用。</target>
        </trans-unit>
        <trans-unit id="53eb57f385f61f99404d1b82afc101ef669d207f" translate="yes" xml:space="preserve">
          <source>This example assumes that the login page is called &lt;code&gt;'login'&lt;/code&gt; and that the current user is stored in &lt;code&gt;g.user&lt;/code&gt; and is &lt;code&gt;None&lt;/code&gt; if there is no-one logged in.</source>
          <target state="translated">此示例假定登录页面称为 &lt;code&gt;'login'&lt;/code&gt; ，并且当前用户存储在 &lt;code&gt;g.user&lt;/code&gt; 中，如果没有一个登录者，则该用户为 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a843d35be9f7ac67abc22b06ca404c1c0e6cf06c" translate="yes" xml:space="preserve">
          <source>This example assumes your application is called &lt;code&gt;application.fcgi&lt;/code&gt; and that your web server user is &lt;code&gt;www-data&lt;/code&gt;:</source>
          <target state="translated">此示例假定您的应用程序名为 &lt;code&gt;application.fcgi&lt;/code&gt; ，并且您的Web服务器用户为 &lt;code&gt;www-data&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="92bea2ee7419e83ce35e916efc02ce6605f0b02e" translate="yes" xml:space="preserve">
          <source>This example uses &lt;a href=&quot;https://docs.python.org/3/library/logging.config.html#logging.config.dictConfig&quot;&gt;&lt;code&gt;dictConfig()&lt;/code&gt;&lt;/a&gt; to create a logging configuration similar to Flask&amp;rsquo;s default, except for all logs:</source>
          <target state="translated">此示例使用&lt;a href=&quot;https://docs.python.org/3/library/logging.config.html#logging.config.dictConfig&quot;&gt; &lt;code&gt;dictConfig()&lt;/code&gt; &lt;/a&gt;创建类似于Flask的默认日志记录配置，但所有日志除外：</target>
        </trans-unit>
        <trans-unit id="868633009eb64678813d2196ce60e646fa6bc37c" translate="yes" xml:space="preserve">
          <source>This example will run a Flask application called &lt;code&gt;app&lt;/code&gt; from a module named &lt;code&gt;myproject&lt;/code&gt;.</source>
          <target state="translated">此示例将从名为 &lt;code&gt;myproject&lt;/code&gt; 的模块中运行一个名为 &lt;code&gt;app&lt;/code&gt; 的Flask应用程序。</target>
        </trans-unit>
        <trans-unit id="6dc0d95707083419da80a27283400cfeba0441bf" translate="yes" xml:space="preserve">
          <source>This feature was added in Flask 0.6 but can be achieved in older versions as well by subclassing the request object. For more information on that consult the Werkzeug documentation on file handling.</source>
          <target state="translated">这个功能是在Flask 0.6中加入的,但在旧版本中也可以通过子类化请求对象来实现。更多信息请参考Werkzeug关于文件处理的文档。</target>
        </trans-unit>
        <trans-unit id="c51dcdf50421641b399abea56e11fa9fdb760755" translate="yes" xml:space="preserve">
          <source>This first loads the configuration from the &lt;code&gt;yourapplication.default_settings&lt;/code&gt; module and then overrides the values with the contents of the file the &lt;code id=&quot;index-7&quot;&gt;YOURAPPLICATION_SETTINGS&lt;/code&gt; environment variable points to. This environment variable can be set on Linux or OS X with the export command in the shell before starting the server:</source>
          <target state="translated">这首先从 &lt;code&gt;yourapplication.default_settings&lt;/code&gt; 模块加载配置，然后用 &lt;code id=&quot;index-7&quot;&gt;YOURAPPLICATION_SETTINGS&lt;/code&gt; 环境变量指向的文件的内容覆盖这些值。在启动服务器之前，可以在外壳中使用export命令在Linux或OS X上设置此环境变量：</target>
        </trans-unit>
        <trans-unit id="93a061c53a6a1f7322f4b0c0db48c51cb2839390" translate="yes" xml:space="preserve">
          <source>This function accepts the very same arguments you can return from a view function. This for example creates a response with a 404 error code:</source>
          <target state="translated">这个函数接受与视图函数返回的参数相同的参数。例如,这将创建一个带有404错误代码的响应。</target>
        </trans-unit>
        <trans-unit id="2080b6a130b94d25e7f0dd83fa3d5df340b0169a" translate="yes" xml:space="preserve">
          <source>This function converts the given object into JSON representation. This is for example very helpful if you try to generate JavaScript on the fly.</source>
          <target state="translated">这个函数将给定的对象转换为JSON表示。例如,当你试图在飞行中生成JavaScript时,这非常有用。</target>
        </trans-unit>
        <trans-unit id="a7a0b8273f4be29272636fe85cacb7d0671fd4b3" translate="yes" xml:space="preserve">
          <source>This function however can help you keep the context around for longer:</source>
          <target state="translated">不过,这个功能可以帮助你把上下文保留得更久。</target>
        </trans-unit>
        <trans-unit id="e69cc0c0a2456c84caa837cbacfc20a90b5032a6" translate="yes" xml:space="preserve">
          <source>This function wraps &lt;a href=&quot;#flask.json.dumps&quot;&gt;&lt;code&gt;dumps()&lt;/code&gt;&lt;/a&gt; to add a few enhancements that make life easier. It turns the JSON output into a &lt;a href=&quot;#flask.Response&quot;&gt;&lt;code&gt;Response&lt;/code&gt;&lt;/a&gt; object with the &lt;em&gt;application/json&lt;/em&gt; mimetype. For convenience, it also converts multiple arguments into an array or multiple keyword arguments into a dict. This means that both &lt;code&gt;jsonify(1,2,3)&lt;/code&gt; and &lt;code&gt;jsonify([1,2,3])&lt;/code&gt; serialize to &lt;code&gt;[1,2,3]&lt;/code&gt;.</source>
          <target state="translated">此函数包装&lt;a href=&quot;#flask.json.dumps&quot;&gt; &lt;code&gt;dumps()&lt;/code&gt; &lt;/a&gt;来添加一些增强功能，使生活更轻松。它将JSON输出转换为具有&lt;em&gt;application / json&lt;/em&gt; mimetype的&lt;a href=&quot;#flask.Response&quot;&gt; &lt;code&gt;Response&lt;/code&gt; &lt;/a&gt;对象。为了方便起见，它还将多个参数转换为数组，或将多个关键字参数转换为dict。这意味着 &lt;code&gt;jsonify(1,2,3)&lt;/code&gt; 和 &lt;code&gt;jsonify([1,2,3])&lt;/code&gt; 都序列化为 &lt;code&gt;[1,2,3]&lt;/code&gt; 。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="79d2a3ea0351f5548eb71bf7129f4e01a7f9ada3" translate="yes" xml:space="preserve">
          <source>This function&amp;rsquo;s response will be pretty printed if the &lt;code&gt;JSONIFY_PRETTYPRINT_REGULAR&lt;/code&gt; config parameter is set to True or the Flask app is running in debug mode. Compressed (not pretty) formatting currently means no indents and no spaces after separators.</source>
          <target state="translated">如果 &lt;code&gt;JSONIFY_PRETTYPRINT_REGULAR&lt;/code&gt; 配置参数设置为True或Flask应用程序在调试模式下运行，则该函数的响应将很漂亮地打印出来。压缩（不太漂亮）格式当前表示分隔符后没有缩进和空格。</target>
        </trans-unit>
        <trans-unit id="e35115eb5260b1850b74a2e84ba968ba59bfcd27" translate="yes" xml:space="preserve">
          <source>This handy little function, in combination with a row factory, makes working with the database much more pleasant than it is by just using the raw cursor and connection objects.</source>
          <target state="translated">这个方便的小功能,与行工厂相结合,使数据库的工作比仅仅使用原始游标和连接对象要愉快得多。</target>
        </trans-unit>
        <trans-unit id="8018d23ab92b8722785a664ab85f7b3ef277bded" translate="yes" xml:space="preserve">
          <source>This has the advantage of just installing a link to the site-packages folder instead of copying the data over. You can then continue to work on the code without having to run &lt;code&gt;install&lt;/code&gt; again after each change.</source>
          <target state="translated">这样做的好处是，只需安装指向site-packages文件夹的链接，而不是复制数据即可。然后，您可以继续处理代码，而不必在每次更改后再次运行 &lt;code&gt;install&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c2be3b218ec4671cb9e0aeffe4a987808599e9e6" translate="yes" xml:space="preserve">
          <source>This however can easily be done yourself. Just call &lt;a href=&quot;../api/index#flask.Flask.preprocess_request&quot;&gt;&lt;code&gt;preprocess_request()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">但是，这可以轻松地自己完成。只需调用&lt;a href=&quot;../api/index#flask.Flask.preprocess_request&quot;&gt; &lt;code&gt;preprocess_request()&lt;/code&gt; 即可&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="5691d6a04305258f7635e3ef8ce85f0fa05b7a81" translate="yes" xml:space="preserve">
          <source>This however does not make it possible to also modify the session or to access the session before a request was fired. Starting with Flask 0.8 we provide a so called &amp;ldquo;session transaction&amp;rdquo; which simulates the appropriate calls to open a session in the context of the test client and to modify it. At the end of the transaction the session is stored and ready to be used by the test client. This works independently of the session backend used:</source>
          <target state="translated">然而，这使得不可能在触发请求之前也修改会话或访问会话。从Flask 0.8开始，我们提供了一个所谓的&amp;ldquo;会话事务&amp;rdquo;，它可以模拟适当的调用以在测试客户端的上下文中打开会话并进行修改。在事务结束时，会话将被存储并准备好供测试客户端使用。这与所使用的会话后端无关：</target>
        </trans-unit>
        <trans-unit id="7117c6a3dcd2866f4c938cbc4ba178ac19db3a23" translate="yes" xml:space="preserve">
          <source>This implements the &lt;code&gt;__html__()&lt;/code&gt; interface that some frameworks use. Passing an object that implements &lt;code&gt;__html__()&lt;/code&gt; will wrap the output of that method, marking it safe.</source>
          <target state="translated">这实现了某些框架使用的 &lt;code&gt;__html__()&lt;/code&gt; 接口。传递实现 &lt;code&gt;__html__()&lt;/code&gt; 的对象将包装该方法的输出，并将其标记为安全。</target>
        </trans-unit>
        <trans-unit id="7ad573f36373ed94556684aac3b301523702cd53" translate="yes" xml:space="preserve">
          <source>This in general is less useful because at that point you can directly start using the test client.</source>
          <target state="translated">一般来说,这个用处不大,因为这时你可以直接开始使用测试客户端。</target>
        </trans-unit>
        <trans-unit id="3d95231a701c4ba1d1cfc52722e39c7371c5fc47" translate="yes" xml:space="preserve">
          <source>This is &lt;code&gt;True&lt;/code&gt; if the package bound object&amp;rsquo;s container has a folder for static files.</source>
          <target state="translated">如果包绑定对象的容器具有用于静态文件的文件夹，则为 &lt;code&gt;True&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2d4967d8fe1a5097eb7a73f5a9ab1048d814108a" translate="yes" xml:space="preserve">
          <source>This is a basic first example that has the ability to upload the current source code to the server and install it into a pre-existing virtual environment:</source>
          <target state="translated">这是一个基本的第一个例子,它有能力将当前的源代码上传到服务器,并将其安装到预先存在的虚拟环境中。</target>
        </trans-unit>
        <trans-unit id="1a9744c7f7ae4309f914377a3bd10e2310ba8a75" translate="yes" xml:space="preserve">
          <source>This is a basic view function that generates a lot of CSV data on the fly. The trick is to have an inner function that uses a generator to generate data and to then invoke that function and pass it to a response object:</source>
          <target state="translated">这是一个基本的视图函数,可以在飞行中生成大量的CSV数据。诀窍是有一个内部函数,使用生成器来生成数据,然后调用该函数并将其传递给响应对象。</target>
        </trans-unit>
        <trans-unit id="6f43712ca948bc7c2c3c303592e601b39bdf98cb" translate="yes" xml:space="preserve">
          <source>This is a good place to store resources during a request. During testing, you can use the &lt;a href=&quot;../testing/index#faking-resources&quot;&gt;Faking Resources and Context&lt;/a&gt; pattern to pre-configure such resources.</source>
          <target state="translated">这是在请求期间存储资源的好地方。在测试期间，您可以使用&amp;ldquo;&lt;a href=&quot;../testing/index#faking-resources&quot;&gt;伪造资源和上下文&amp;rdquo;&lt;/a&gt;模式来预先配置此类资源。</target>
        </trans-unit>
        <trans-unit id="406dab1677f6a99e2f21a491c09196ff930e32b6" translate="yes" xml:space="preserve">
          <source>This is a no-op if &lt;a href=&quot;https://github.com/theskumar/python-dotenv#readme&quot;&gt;python-dotenv&lt;/a&gt; is not installed.</source>
          <target state="translated">如果未安装&lt;a href=&quot;https://github.com/theskumar/python-dotenv#readme&quot;&gt;python-dotenv，&lt;/a&gt;则为空操作。</target>
        </trans-unit>
        <trans-unit id="5a89540d15c0128066ffd467328875d183143de8" translate="yes" xml:space="preserve">
          <source>This is a proxy. See &lt;a href=&quot;../reqcontext/index#notes-on-proxies&quot;&gt;Notes On Proxies&lt;/a&gt; for more information.</source>
          <target state="translated">这是一个代理。有关更多信息，请参见&lt;a href=&quot;../reqcontext/index#notes-on-proxies&quot;&gt;代理&lt;/a&gt;说明。</target>
        </trans-unit>
        <trans-unit id="04991e67d423d17308d3fad8e905743b1218a127" translate="yes" xml:space="preserve">
          <source>This is a rather pointless example because a user will be redirected from the index to a page they cannot access (401 means access denied) but it shows how that works.</source>
          <target state="translated">这是一个相当无意义的例子,因为用户将从索引重定向到一个他们无法访问的页面(401意味着访问被拒绝),但它显示了如何工作。</target>
        </trans-unit>
        <trans-unit id="7b17e1e6cdd25360c33b96a51ecebcdb598bc6f3" translate="yes" xml:space="preserve">
          <source>This is a simple example:</source>
          <target state="translated">这是一个简单的例子。</target>
        </trans-unit>
        <trans-unit id="7d2893e07954b65e2f755bd7e378c7d1ebc3f5c1" translate="yes" xml:space="preserve">
          <source>This is a subclass of the text type (&lt;code&gt;str&lt;/code&gt; in Python 3, &lt;code&gt;unicode&lt;/code&gt; in Python 2). It has the same methods as that type, but all methods escape their arguments and return a &lt;code&gt;Markup&lt;/code&gt; instance.</source>
          <target state="translated">这是文本类型的子类（Python 3中为 &lt;code&gt;str&lt;/code&gt; ，Python 2中为 &lt;code&gt;unicode&lt;/code&gt; ）。它具有与该类型相同的方法，但是所有方法都转义其参数并返回 &lt;code&gt;Markup&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="11de1a39a894debac70bde810ca5d91378bec443" translate="yes" xml:space="preserve">
          <source>This is all that is necessary to properly integrate Celery with Flask:</source>
          <target state="translated">这就是将Celery与Flask正确集成所需的全部内容。</target>
        </trans-unit>
        <trans-unit id="9e06d505bfc76629ae867309e258c944c796935c" translate="yes" xml:space="preserve">
          <source>This is also the way you can use a Flask application on Google&amp;rsquo;s &lt;a href=&quot;https://cloud.google.com/appengine/docs/&quot;&gt;App Engine&lt;/a&gt;, where execution happens in a CGI-like environment.</source>
          <target state="translated">这也是在Google &lt;a href=&quot;https://cloud.google.com/appengine/docs/&quot;&gt;App Engine&lt;/a&gt;上使用Flask应用程序的方式，在类似CGI的环境中执行操作。</target>
        </trans-unit>
        <trans-unit id="6899f8a640681b1ea207c43caef3c33f1bc6b70b" translate="yes" xml:space="preserve">
          <source>This is an awful lot of repetition as you have to handle the language code setting on the &lt;a href=&quot;../../api/index#flask.g&quot;&gt;&lt;code&gt;g&lt;/code&gt;&lt;/a&gt; object yourself in every single function. Sure, a decorator could be used to simplify this, but if you want to generate URLs from one function to another you would have to still provide the language code explicitly which can be annoying.</source>
          <target state="translated">这是很多重复的操作，因为您必须在每个函数中亲自处理&lt;a href=&quot;../../api/index#flask.g&quot;&gt; &lt;code&gt;g&lt;/code&gt; &lt;/a&gt;对象上的语言代码设置。当然，可以使用装饰器来简化此过程，但是如果要从一个函数生成另一个函数的URL，则仍必须显式提供可能令人讨厌的语言代码。</target>
        </trans-unit>
        <trans-unit id="e4a329b37f616542b0a8ece21c3ec7d1a16be968" translate="yes" xml:space="preserve">
          <source>This is an example form for a typical registration page:</source>
          <target state="translated">这是一个典型的注册页面的例子。</target>
        </trans-unit>
        <trans-unit id="0018a869c40ef0a3e25a09c44f2e50ee3503172b" translate="yes" xml:space="preserve">
          <source>This is an obscure feature inherited from SGML. It is usually not supported by browsers, for reasons detailed above.</source>
          <target state="translated">这是一个从SGML中继承的隐晦功能。浏览器通常不支持这个功能,原因详见上文。</target>
        </trans-unit>
        <trans-unit id="0832a770d929c0bc1c49acfb7ec467f594f73cac" translate="yes" xml:space="preserve">
          <source>This is called by &lt;a href=&quot;#flask.ctx.AppContext.pop&quot;&gt;&lt;code&gt;AppContext.pop()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这由&lt;a href=&quot;#flask.ctx.AppContext.pop&quot;&gt; &lt;code&gt;AppContext.pop()&lt;/code&gt; &lt;/a&gt;调用。</target>
        </trans-unit>
        <trans-unit id="749036b6d5970b4554ef8800a254e4aed729e006" translate="yes" xml:space="preserve">
          <source>This is called by &lt;a href=&quot;#flask.ctx.RequestContext.pop&quot;&gt;&lt;code&gt;RequestContext.pop()&lt;/code&gt;&lt;/a&gt;, which may be delayed during testing to maintain access to resources.</source>
          <target state="translated">这由&lt;a href=&quot;#flask.ctx.RequestContext.pop&quot;&gt; &lt;code&gt;RequestContext.pop()&lt;/code&gt; &lt;/a&gt;调用，在测试过程中可能会延迟以保持对资源的访问。</target>
        </trans-unit>
        <trans-unit id="25a19177e9fead1dc9c7e88220893e3ce7cdfb21" translate="yes" xml:space="preserve">
          <source>This is called for actual sessions returned by &lt;a href=&quot;#flask.sessions.SecureCookieSessionInterface.open_session&quot;&gt;&lt;code&gt;open_session()&lt;/code&gt;&lt;/a&gt; at the end of the request. This is still called during a request context so if you absolutely need access to the request you can do that.</source>
          <target state="translated">对于在请求结束时由&lt;a href=&quot;#flask.sessions.SecureCookieSessionInterface.open_session&quot;&gt; &lt;code&gt;open_session()&lt;/code&gt; &lt;/a&gt;返回的实际会话，将调用此方法。在请求上下文中仍会调用此方法，因此，如果您绝对需要访问该请求，则可以执行此操作。</target>
        </trans-unit>
        <trans-unit id="2ee7deb8ede6b2dddf03427ee56f596d3c595e7f" translate="yes" xml:space="preserve">
          <source>This is called for actual sessions returned by &lt;a href=&quot;#flask.sessions.SessionInterface.open_session&quot;&gt;&lt;code&gt;open_session()&lt;/code&gt;&lt;/a&gt; at the end of the request. This is still called during a request context so if you absolutely need access to the request you can do that.</source>
          <target state="translated">对于在请求结束时由&lt;a href=&quot;#flask.sessions.SessionInterface.open_session&quot;&gt; &lt;code&gt;open_session()&lt;/code&gt; &lt;/a&gt;返回的实际会话，将调用此方法。在请求上下文中仍会调用此方法，因此，如果您绝对需要访问该请求，则可以执行此操作。</target>
        </trans-unit>
        <trans-unit id="8f50e39c8418ad62af7e3eb9129e991de42066d1" translate="yes" xml:space="preserve">
          <source>This is called for all HTTP exceptions raised by a view function. If it returns &lt;code&gt;True&lt;/code&gt; for any exception the error handler for this exception is not called and it shows up as regular exception in the traceback. This is helpful for debugging implicitly raised HTTP exceptions.</source>
          <target state="translated">对于由视图函数引发的所有HTTP异常，将调用此方法。如果针对任何异常返回 &lt;code&gt;True&lt;/code&gt; ，则不会调用该异常的错误处理程序，并且在回溯中将其显示为常规异常。这对于调试隐式引发的HTTP异常很有帮助。</target>
        </trans-unit>
        <trans-unit id="399bbe1dc073334d3ef5342ad07290b8905cb6a0" translate="yes" xml:space="preserve">
          <source>This is called to figure out if an error should be ignored or not as far as the teardown system is concerned. If this function returns &lt;code&gt;True&lt;/code&gt; then the teardown handlers will not be passed the error.</source>
          <target state="translated">调用此方法可以确定是否应该忽略拆解系统中的错误。如果此函数返回 &lt;code&gt;True&lt;/code&gt; ,则不会传递拆卸处理程序错误。</target>
        </trans-unit>
        <trans-unit id="5fc02267b47b562f013ae64d2cb483ffdf64aba1" translate="yes" xml:space="preserve">
          <source>This is consistent with how web servers deal with static files. This also makes it possible to use relative link targets safely.</source>
          <target state="translated">这与Web服务器处理静态文件的方式是一致的。这也使得安全使用相对链接目标成为可能。</target>
        </trans-unit>
        <trans-unit id="7362e74b32b4ea2cdf1bf8a5aead79ccca7056d0" translate="yes" xml:space="preserve">
          <source>This is enough for Apache to work, however nginx and older versions of lighttpd need a socket to be explicitly passed to communicate with the FastCGI server. For that to work you need to pass the path to the socket to the &lt;code&gt;WSGIServer&lt;/code&gt;:</source>
          <target state="translated">这足以使Apache正常工作，但是nginx和较早版本的lighttpd需要显式传递一个套接字才能与FastCGI服务器通信。为此，您需要将套接字的路径传递给 &lt;code&gt;WSGIServer&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="28f568388aa2f7a11b2f8c90b81642f71002249c" translate="yes" xml:space="preserve">
          <source>This is for compatibility with server code that generates XHTML for tags such as &lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt;. It should not be used in new code.</source>
          <target state="translated">这是为了与为诸如 &lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt; 之类的标记生成XHTML的服务器代码兼容。不应在新代码中使用它。</target>
        </trans-unit>
        <trans-unit id="6c18944170282f8c3549748409b58c2a7235d7a7" translate="yes" xml:space="preserve">
          <source>This is just one example of how to render these flashed messages. One might also use the category to add a prefix such as &lt;code&gt;&amp;lt;strong&amp;gt;Error:&amp;lt;/strong&amp;gt;&lt;/code&gt; to the message.</source>
          <target state="translated">这只是如何呈现这些闪烁消息的一个示例。可能还会使用该类别在邮件中添加诸如 &lt;code&gt;&amp;lt;strong&amp;gt;Error:&amp;lt;/strong&amp;gt;&lt;/code&gt; 之类的前缀。</target>
        </trans-unit>
        <trans-unit id="97e58fe407e3962722431677e369c51c27425d17" translate="yes" xml:space="preserve">
          <source>This is more useful if a function other than the view function wants to modify a response. For instance think of a decorator that wants to add some headers without converting the return value into a response object.</source>
          <target state="translated">如果一个非视图函数的函数想要修改响应,这个功能就比较有用。例如,考虑到一个装饰者想要添加一些头信息,而不将返回值转换为响应对象。</target>
        </trans-unit>
        <trans-unit id="aa420fdcaab1e763e3afd355b66cc8c992c104f0" translate="yes" xml:space="preserve">
          <source>This is not unique to Flask. Many people use patched and modified versions of their framework to counter shortcomings. This idea is also reflected in the license of Flask. You don&amp;rsquo;t have to contribute any changes back if you decide to modify the framework.</source>
          <target state="translated">这不是Flask独有的。许多人使用其框架的修补和修改版本来弥补缺点。这个想法也反映在Flask的许可中。如果您决定修改框架，则无需退回任何更改。</target>
        </trans-unit>
        <trans-unit id="b30c688e010cf67471b7a00c77af144feb450a08" translate="yes" xml:space="preserve">
          <source>This is often useful when configuration options map directly to keyword arguments in functions or class constructors.</source>
          <target state="translated">当配置选项直接映射到函数或类构造函数中的关键字参数时,这通常是有用的。</target>
        </trans-unit>
        <trans-unit id="266f8af16ea4522a6df0e9570795d35f6a7fdc38" translate="yes" xml:space="preserve">
          <source>This is only available when an &lt;a href=&quot;../appcontext/index&quot;&gt;application context&lt;/a&gt; is pushed. This happens automatically during requests and CLI commands. It can be controlled manually with &lt;a href=&quot;#flask.Flask.app_context&quot;&gt;&lt;code&gt;app_context()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">仅当推送&lt;a href=&quot;../appcontext/index&quot;&gt;应用程序上下文&lt;/a&gt;时才可用。这在请求和CLI命令期间自动发生。可以使用&lt;a href=&quot;#flask.Flask.app_context&quot;&gt; &lt;code&gt;app_context()&lt;/code&gt; &lt;/a&gt;进行手动控制。</target>
        </trans-unit>
        <trans-unit id="50a07b1a7e2fed61143d19358431950d58c53b28" translate="yes" xml:space="preserve">
          <source>This is similar to the &lt;a href=&quot;../appcontext/index&quot;&gt;The Application Context&lt;/a&gt;, which keeps track of the application-level data independent of a request. A corresponding application context is pushed when a request context is pushed.</source>
          <target state="translated">这类似于&lt;a href=&quot;../appcontext/index&quot;&gt;The Application Context&lt;/a&gt;，它可以独立于请求地跟踪应用程序级数据。当请求上下文被推送时，相应的应用程序上下文也被推送。</target>
        </trans-unit>
        <trans-unit id="f1ec20c59c3ad8750fe8e0e9b913a7e19dbc0e72" translate="yes" xml:space="preserve">
          <source>This is similar to the &lt;a href=&quot;../reqcontext/index&quot;&gt;The Request Context&lt;/a&gt;, which keeps track of request-level data during a request. A corresponding application context is pushed when a request context is pushed.</source>
          <target state="translated">这类似于&lt;a href=&quot;../reqcontext/index&quot;&gt;The Request Context&lt;/a&gt;，它在请求期间跟踪请求级别的数据。当请求上下文被推送时，相应的应用程序上下文也被推送。</target>
        </trans-unit>
        <trans-unit id="2c3c79a2614f389c7648b70b313e742568fbb652" translate="yes" xml:space="preserve">
          <source>This is simple and flexible, but if you want to provide this view in a generic fashion that can be adapted to other models and templates as well you might want more flexibility. This is where pluggable class-based views come into place. As the first step to convert this into a class based view you would do this:</source>
          <target state="translated">这是简单而灵活的,但如果你想以一种通用的方式提供这种视图,并能适应其他模型和模板,你可能需要更多的灵活性。这就是可插拔的基于类的视图的地方。作为将其转换为基于类的视图的第一步,您可以这样做。</target>
        </trans-unit>
        <trans-unit id="f0e4c3d37fb2cc0272478b8ac349962dbe2d8e79" translate="yes" xml:space="preserve">
          <source>This is the recommended approach for overriding or augmenting Flask&amp;rsquo;s internal functionality.</source>
          <target state="translated">这是覆盖或增强Flask内部功能的推荐方法。</target>
        </trans-unit>
        <trans-unit id="baafc5bbf292d550e9090df3ef8edc09b6c35429" translate="yes" xml:space="preserve">
          <source>This is the way to invoke a script with all the bells and whistles as a command line application. This will always terminate the application after a call. If this is not wanted, &lt;code&gt;SystemExit&lt;/code&gt; needs to be caught.</source>
          <target state="translated">这是一种调用所有脚本的脚本作为命令行应用程序的方式。这将始终在调用后终止应用程序。如果不希望这样做，则需要捕获 &lt;code&gt;SystemExit&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bc013b5ff0c5cb5b144ee886b8c94f110d06f83c" translate="yes" xml:space="preserve">
          <source>This is useful for executing small snippets of management code without having to manually configure the application.</source>
          <target state="translated">这对于执行小段管理代码很有用,无需手动配置应用程序。</target>
        </trans-unit>
        <trans-unit id="7d03112cbe505ffcd573533b559001fe8f8bb114" translate="yes" xml:space="preserve">
          <source>This is what a very basic blueprint looks like. In this case we want to implement a blueprint that does simple rendering of static templates:</source>
          <target state="translated">这就是一个非常基本的蓝图的样子。在本例中,我们想实现一个对静态模板进行简单渲染的蓝图。</target>
        </trans-unit>
        <trans-unit id="8bde888d98ec80618c69e86986c8c5b6dc5e136c" translate="yes" xml:space="preserve">
          <source>This is where some helper functions come in handy. Keep in mind however that these functions are not only there for interactive shell usage, but also for unit testing and other situations that require a faked request context.</source>
          <target state="translated">这时,一些帮助函数就派上用场了。但是请记住,这些函数不仅是为了交互式的shell使用,也是为了单元测试和其他需要伪造请求上下文的情况。</target>
        </trans-unit>
        <trans-unit id="c7e6f33f620e775ba946d8b7003fd7687dba593b" translate="yes" xml:space="preserve">
          <source>This launches a very simple builtin server, which is good enough for testing but probably not what you want to use in production. For deployment options see &lt;a href=&quot;../deploying/index#deployment&quot;&gt;Deployment Options&lt;/a&gt;.</source>
          <target state="translated">这将启动一个非常简单的内置服务器，该服务器足以进行测试，但可能不是您要在生产中使用的服务器。有关部署选项，请参阅&amp;ldquo;&lt;a href=&quot;../deploying/index#deployment&quot;&gt;部署选项&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e9a6b2a87ac23327a94bfc0bbb9ae6b337c0e1bc" translate="yes" xml:space="preserve">
          <source>This macro accepts a couple of keyword arguments that are forwarded to WTForm&amp;rsquo;s field function, which renders the field for us. The keyword arguments will be inserted as HTML attributes. So, for example, you can call &lt;code&gt;render_field(form.username, class='username')&lt;/code&gt; to add a class to the input element. Note that WTForms returns standard Python unicode strings, so we have to tell Jinja2 that this data is already HTML-escaped with the &lt;code&gt;|safe&lt;/code&gt; filter.</source>
          <target state="translated">此宏接受几个关键字参数，这些关键字参数转发给WTForm的field函数，该函数为我们呈现该字段。关键字参数将作为HTML属性插入。因此，例如，您可以调用 &lt;code&gt;render_field(form.username, class='username')&lt;/code&gt; 将一个类添加到输入元素中。注意，WTForms返回标准的Python unicode字符串，因此我们必须告诉Jinja2该数据已经使用 &lt;code&gt;|safe&lt;/code&gt; 过滤器进行了HTML转义。</target>
        </trans-unit>
        <trans-unit id="148961bbaa188d129234e09d949f0ab77206d08b" translate="yes" xml:space="preserve">
          <source>This means the following page in HTML5 is perfectly valid:</source>
          <target state="translated">这意味着下面这个HTML5的页面是完全有效的。</target>
        </trans-unit>
        <trans-unit id="d0c14628b051dd87ce257c5b36a216b0f016fe6f" translate="yes" xml:space="preserve">
          <source>This method has to be implemented and must either return &lt;code&gt;None&lt;/code&gt; in case the loading failed because of a configuration error or an instance of a session object which implements a dictionary like interface + the methods and attributes on &lt;a href=&quot;#flask.sessions.SessionMixin&quot;&gt;&lt;code&gt;SessionMixin&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此方法必须实现，并且如果由于配置错误而导致加载失败，则必须返回 &lt;code&gt;None&lt;/code&gt; ，或者必须实现会话对象的实例，该实例实现像interface + &lt;a href=&quot;#flask.sessions.SessionMixin&quot;&gt; &lt;code&gt;SessionMixin&lt;/code&gt; &lt;/a&gt;上的字典和方法和属性。</target>
        </trans-unit>
        <trans-unit id="51abe9bd4cf4df621c7d3cbc4f700835d5fb3a46" translate="yes" xml:space="preserve">
          <source>This method is also available by directly calling the instance of a &lt;code&gt;Command&lt;/code&gt;.</source>
          <target state="translated">也可以通过直接调用 &lt;code&gt;Command&lt;/code&gt; 的实例来使用此方法。</target>
        </trans-unit>
        <trans-unit id="ce1af51351825fc103cbb8249c0d00a090d5430b" translate="yes" xml:space="preserve">
          <source>This method is called to create the default &lt;code&gt;OPTIONS&lt;/code&gt; response. This can be changed through subclassing to change the default behavior of &lt;code&gt;OPTIONS&lt;/code&gt; responses.</source>
          <target state="translated">调用此方法以创建默认的 &lt;code&gt;OPTIONS&lt;/code&gt; 响应。这可以通过子类化来更改，以更改 &lt;code&gt;OPTIONS&lt;/code&gt; 响应的默认行为。</target>
        </trans-unit>
        <trans-unit id="6e38f0adf010a505599147af043f0577667266e1" translate="yes" xml:space="preserve">
          <source>This method is called whenever an exception occurs that should be handled. A special case is &lt;code&gt;HTTPException&lt;/code&gt; which is forwarded to the &lt;a href=&quot;#flask.Flask.handle_http_exception&quot;&gt;&lt;code&gt;handle_http_exception()&lt;/code&gt;&lt;/a&gt; method. This function will either return a response value or reraise the exception with the same traceback.</source>
          <target state="translated">每当发生异常时应调用此方法。 &lt;code&gt;HTTPException&lt;/code&gt; 是一种特殊情况，它会转发到&lt;a href=&quot;#flask.Flask.handle_http_exception&quot;&gt; &lt;code&gt;handle_http_exception()&lt;/code&gt; &lt;/a&gt;方法。此函数将返回一个响应值或使用相同的回溯引发异常。</target>
        </trans-unit>
        <trans-unit id="bb88f88821b6bb4a97c0268d99ef3bd91c6dd6f3" translate="yes" xml:space="preserve">
          <source>This now depends on the number of servers we want to set up. If we just have one application server (which the majority of applications will have), creating a command in the fabfile for this is overkill. But obviously you can do that. In that case you would probably call it &lt;code&gt;setup&lt;/code&gt; or &lt;code&gt;bootstrap&lt;/code&gt; and then pass the servername explicitly on the command line:</source>
          <target state="translated">现在，这取决于我们要设置的服务器数量。如果我们只有一台应用程序服务器（大多数应用程序都将拥有），则在fabfile中为此创建命令是过分的。但是显然您可以做到。在这种情况下，您可能会称其为 &lt;code&gt;setup&lt;/code&gt; 或 &lt;code&gt;bootstrap&lt;/code&gt; ，然后在命令行上显式传递服务器名：</target>
        </trans-unit>
        <trans-unit id="ace9fe73304dbcfa089f71562dc9d47be23596d7" translate="yes" xml:space="preserve">
          <source>This of course is not that helpful for such a small example, but it&amp;rsquo;s good enough to explain the basic principle. When you have a class-based view the question comes up what &lt;code&gt;self&lt;/code&gt; points to. The way this works is that whenever the request is dispatched a new instance of the class is created and the &lt;a href=&quot;../api/index#flask.views.View.dispatch_request&quot;&gt;&lt;code&gt;dispatch_request()&lt;/code&gt;&lt;/a&gt; method is called with the parameters from the URL rule. The class itself is instantiated with the parameters passed to the &lt;a href=&quot;../api/index#flask.views.View.as_view&quot;&gt;&lt;code&gt;as_view()&lt;/code&gt;&lt;/a&gt; function. For instance you can write a class like this:</source>
          <target state="translated">对于这么小的例子，这当然没有帮助，但是足以解释基本原理。当您拥有基于类的视图时，就会出现 &lt;code&gt;self&lt;/code&gt; 指向的问题。这种工作方式是，无论何时分派请求，都会创建该类的新实例，并使用URL规则中的参数调用&lt;a href=&quot;../api/index#flask.views.View.dispatch_request&quot;&gt; &lt;code&gt;dispatch_request()&lt;/code&gt; &lt;/a&gt;方法。类本身是使用传递给&lt;a href=&quot;../api/index#flask.views.View.as_view&quot;&gt; &lt;code&gt;as_view()&lt;/code&gt; &lt;/a&gt;函数的参数实例化的。例如，您可以编写这样的类：</target>
        </trans-unit>
        <trans-unit id="fa46890d0628d16b5ee8a4d93210b9108ba9baaa" translate="yes" xml:space="preserve">
          <source>This part of the documentation covers all the interfaces of Flask. For parts where Flask depends on external libraries, we document the most important right here and provide links to the canonical documentation.</source>
          <target state="translated">这部分文档涵盖了Flask的所有接口。对于Flask依赖外部库的部分,我们将最重要的部分记录在这里,并提供链接到规范文档。</target>
        </trans-unit>
        <trans-unit id="6d84cc3f7287a2ee2e5c3046eb982091e418d2d9" translate="yes" xml:space="preserve">
          <source>This part of the documentation, which is mostly prose, begins with some background information about Flask, then focuses on step-by-step instructions for web development with Flask.</source>
          <target state="translated">这部分文档主要是散文,首先介绍了Flask的一些背景信息,然后重点介绍了使用Flask进行Web开发的步骤说明。</target>
        </trans-unit>
        <trans-unit id="a0443f4192ba55338acf65e28bc1d0911a821ac2" translate="yes" xml:space="preserve">
          <source>This reads the buffered incoming data from the client into one bytestring. By default this is cached but that behavior can be changed by setting &lt;code&gt;cache&lt;/code&gt; to &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">这将从客户端读取缓冲的传入数据读取为一个字节字符串。默认情况下，将其缓存，但是可以通过将 &lt;code&gt;cache&lt;/code&gt; 设置为 &lt;code&gt;False&lt;/code&gt; 来更改该行为。</target>
        </trans-unit>
        <trans-unit id="a2d066ef0e30256a871174ab278fbc4ffe61eae7" translate="yes" xml:space="preserve">
          <source>This reflects the &lt;code&gt;'_permanent'&lt;/code&gt; key in the dict.</source>
          <target state="translated">这反映了字典中的 &lt;code&gt;'_permanent'&lt;/code&gt; 键。</target>
        </trans-unit>
        <trans-unit id="0bf1b89d694c89fcbad9aec8321f2d4db2744ef7" translate="yes" xml:space="preserve">
          <source>This requires that you have an SMTP server set up on the same server. See the Python docs for more information about configuring the handler.</source>
          <target state="translated">这需要您在同一台服务器上设置一个 SMTP 服务器。更多关于配置处理程序的信息,请参见 Python 文档。</target>
        </trans-unit>
        <trans-unit id="270175471e4ec857589b8873458b82d851e98c01" translate="yes" xml:space="preserve">
          <source>This section only gives a very quick introduction into how Jinja2 is integrated into Flask. If you want information on the template engine&amp;rsquo;s syntax itself, head over to the official &lt;a href=&quot;http://jinja.pocoo.org/docs/templates/&quot;&gt;Jinja2 Template Documentation&lt;/a&gt; for more information.</source>
          <target state="translated">本节仅简要介绍Jinja2如何集成到Flask中。如果您想要有关模板引擎语法本身的信息，请转到官方的&lt;a href=&quot;http://jinja.pocoo.org/docs/templates/&quot;&gt;Jinja2模板文档&lt;/a&gt;以获取更多信息。</target>
        </trans-unit>
        <trans-unit id="f25b81ad93936c67288b7d1f65590fdff1c733a8" translate="yes" xml:space="preserve">
          <source>This server is for development purposes only. It does not provide the stability, security, or performance of production WSGI servers.</source>
          <target state="translated">此服务器仅用于开发目的。它不提供生产WSGI服务器的稳定性、安全性或性能。</target>
        </trans-unit>
        <trans-unit id="9a9df7f5dbbbee76e4a132df811890b1541f2b7b" translate="yes" xml:space="preserve">
          <source>This session backend will set the &lt;a href=&quot;#flask.sessions.SecureCookieSession.modified&quot;&gt;&lt;code&gt;modified&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#flask.sessions.SecureCookieSession.accessed&quot;&gt;&lt;code&gt;accessed&lt;/code&gt;&lt;/a&gt; attributes. It cannot reliably track whether a session is new (vs. empty), so &lt;code&gt;new&lt;/code&gt; remains hard coded to &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">该会话后端将设置&lt;a href=&quot;#flask.sessions.SecureCookieSession.modified&quot;&gt; &lt;code&gt;modified&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#flask.sessions.SecureCookieSession.accessed&quot;&gt; &lt;code&gt;accessed&lt;/code&gt; &lt;/a&gt;属性。它不能可靠地跟踪会话是否为新会话（相对于空会话），因此 &lt;code&gt;new&lt;/code&gt; 仍被硬编码为 &lt;code&gt;False&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d4f1608ec67c25daab64236040db8f15506c4cac" translate="yes" xml:space="preserve">
          <source>This sets up the load paths according to the settings of the virtual environment. Keep in mind that the path has to be absolute.</source>
          <target state="translated">这将根据虚拟环境的设置来设置加载路径。请记住,路径必须是绝对的。</target>
        </trans-unit>
        <trans-unit id="6308cf351995eb1f37faf1ec06a37f9ce49f3300" translate="yes" xml:space="preserve">
          <source>This should typically only happen when testing code that expects an active request. One option is to use the &lt;a href=&quot;../api/index#flask.Flask.test_client&quot;&gt;&lt;code&gt;test client&lt;/code&gt;&lt;/a&gt; to simulate a full request. Or you can use &lt;a href=&quot;../api/index#flask.Flask.test_request_context&quot;&gt;&lt;code&gt;test_request_context()&lt;/code&gt;&lt;/a&gt; in a &lt;code&gt;with&lt;/code&gt; block, and everything that runs in the block will have access to &lt;a href=&quot;../api/index#flask.request&quot;&gt;&lt;code&gt;request&lt;/code&gt;&lt;/a&gt;, populated with your test data.</source>
          <target state="translated">通常仅在测试期望活动请求的代码时才发生这种情况。一种选择是使用&lt;a href=&quot;../api/index#flask.Flask.test_client&quot;&gt; &lt;code&gt;test client&lt;/code&gt; &lt;/a&gt;来模拟完整的请求。或者，您可以在 &lt;code&gt;with&lt;/code&gt; 块中使用&lt;a href=&quot;../api/index#flask.Flask.test_request_context&quot;&gt; &lt;code&gt;test_request_context()&lt;/code&gt; &lt;/a&gt;，并且在该块中运行的所有内容都可以访问&lt;a href=&quot;../api/index#flask.request&quot;&gt; &lt;code&gt;request&lt;/code&gt; &lt;/a&gt;，并填充您的测试数据。</target>
        </trans-unit>
        <trans-unit id="f384bb732cce9a51c8f13cf90e053742c6f8c76d" translate="yes" xml:space="preserve">
          <source>This signal is sent before template rendering process. The signal is invoked with the instance of the template as &lt;code&gt;template&lt;/code&gt; and the context as dictionary (named &lt;code&gt;context&lt;/code&gt;).</source>
          <target state="translated">该信号在模板渲染过程之前发送。使用模板实例作为 &lt;code&gt;template&lt;/code&gt; ，上下文作为字典（命名为 &lt;code&gt;context&lt;/code&gt; ）来调用信号。</target>
        </trans-unit>
        <trans-unit id="30321d60bd10e50962b2db78a34f560a5109a0aa" translate="yes" xml:space="preserve">
          <source>This signal is sent right before the response is sent to the client. It is passed the response to be sent named &lt;code&gt;response&lt;/code&gt;.</source>
          <target state="translated">该信号是在响应发送到客户端之前发送的。它传递的响应将被发送给名为 &lt;code&gt;response&lt;/code&gt; 的响应。</target>
        </trans-unit>
        <trans-unit id="3cf67b9ba49e71aaf5208f3b0f80cd853995270e" translate="yes" xml:space="preserve">
          <source>This signal is sent when a template was successfully rendered. The signal is invoked with the instance of the template as &lt;code&gt;template&lt;/code&gt; and the context as dictionary (named &lt;code&gt;context&lt;/code&gt;).</source>
          <target state="translated">成功渲染模板后发送此信号。使用模板实例作为 &lt;code&gt;template&lt;/code&gt; ，上下文作为字典（命名为 &lt;code&gt;context&lt;/code&gt; ）来调用信号。</target>
        </trans-unit>
        <trans-unit id="63814476c7961e9203086ab2baf64d53d935aee6" translate="yes" xml:space="preserve">
          <source>This signal is sent when an application context is popped. The sender is the application. This usually falls in line with the &lt;a href=&quot;#flask.appcontext_tearing_down&quot;&gt;&lt;code&gt;appcontext_tearing_down&lt;/code&gt;&lt;/a&gt; signal.</source>
          <target state="translated">弹出应用程序上下文时发送此信号。发送者是应用程序。这通常与&lt;a href=&quot;#flask.appcontext_tearing_down&quot;&gt; &lt;code&gt;appcontext_tearing_down&lt;/code&gt; &lt;/a&gt;信号一致。</target>
        </trans-unit>
        <trans-unit id="af983ab8cec24e5ec060b24622d536d0e1d76eb2" translate="yes" xml:space="preserve">
          <source>This signal is sent when an application context is pushed. The sender is the application. This is usually useful for unittests in order to temporarily hook in information. For instance it can be used to set a resource early onto the &lt;code&gt;g&lt;/code&gt; object.</source>
          <target state="translated">当推送应用程序上下文时发送此信号。发送者是应用程序。这通常对于单元测试很有用，以便暂时获取信息。例如，它可用于将资源尽早设置到 &lt;code&gt;g&lt;/code&gt; 对象上。</target>
        </trans-unit>
        <trans-unit id="21f1c7f8803d66330d20c50b6b29e110b5593d9b" translate="yes" xml:space="preserve">
          <source>This signal is sent when an exception happens during request processing. It is sent &lt;em&gt;before&lt;/em&gt; the standard exception handling kicks in and even in debug mode, where no exception handling happens. The exception itself is passed to the subscriber as &lt;code&gt;exception&lt;/code&gt;.</source>
          <target state="translated">在请求处理期间发生异常时发送此信号。它是&lt;em&gt;在&lt;/em&gt;标准异常处理开始&lt;em&gt;之前&lt;/em&gt;甚至在调试模式下发送的，在调试模式下不会发生异常处理。异常本身作为 &lt;code&gt;exception&lt;/code&gt; 传递给订户。</target>
        </trans-unit>
        <trans-unit id="f3a56ac4353921050fea906e63a972f356f7dae0" translate="yes" xml:space="preserve">
          <source>This signal is sent when the app context is tearing down. This is always called, even if an exception is caused. Currently functions listening to this signal are called after the regular teardown handlers, but this is not something you can rely on.</source>
          <target state="translated">这个信号是在应用上下文撕毁的时候发出的。即使引起异常,这个信号也会被调用。目前监听这个信号的函数会在常规的撕毁处理程序之后被调用,但这不是你可以依赖的。</target>
        </trans-unit>
        <trans-unit id="b438296180226526fadefc3339f0a37f8ad2af4f" translate="yes" xml:space="preserve">
          <source>This signal is sent when the application is flashing a message. The messages is sent as &lt;code&gt;message&lt;/code&gt; keyword argument and the category as &lt;code&gt;category&lt;/code&gt;.</source>
          <target state="translated">当应用程序闪烁消息时发送此信号。消息作为 &lt;code&gt;message&lt;/code&gt; 关键字参数发送，类别作为 &lt;code&gt;category&lt;/code&gt; 发送。</target>
        </trans-unit>
        <trans-unit id="de256fd131d5644204d31a34a6a11c561c14bf32" translate="yes" xml:space="preserve">
          <source>This signal is sent when the request context is set up, before any request processing happens. Because the request context is already bound, the subscriber can access the request with the standard global proxies such as &lt;a href=&quot;#flask.request&quot;&gt;&lt;code&gt;request&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在建立请求上下文之前，在进行任何请求处理之前，都会发送此信号。因为请求上下文已经绑定，所以订户可以使用标准全局代理（例如&lt;a href=&quot;#flask.request&quot;&gt; &lt;code&gt;request&lt;/code&gt; )&lt;/a&gt;访问请求。</target>
        </trans-unit>
        <trans-unit id="23d5b96fc0abcd08d44e898fb889962e7b3f74d6" translate="yes" xml:space="preserve">
          <source>This signal is sent when the request is tearing down. This is always called, even if an exception is caused. Currently functions listening to this signal are called after the regular teardown handlers, but this is not something you can rely on.</source>
          <target state="translated">这个信号是在请求被撕毁的时候发出的。即使引起异常,这个信号也会被调用。目前监听这个信号的函数会在常规的撕毁处理程序之后被调用,但这不是你可以依赖的。</target>
        </trans-unit>
        <trans-unit id="a62c8c1db62dcb425205260e56527fe973908037" translate="yes" xml:space="preserve">
          <source>This specifies that &lt;code&gt;/users/&lt;/code&gt; will be the URL for page one and &lt;code&gt;/users/page/N&lt;/code&gt; will be the URL for page &lt;code&gt;N&lt;/code&gt;.</source>
          <target state="translated">这指定 &lt;code&gt;/users/&lt;/code&gt; 将是第一页的URL，而 &lt;code&gt;/users/page/N&lt;/code&gt; 将是第 &lt;code&gt;N&lt;/code&gt; 页的URL 。</target>
        </trans-unit>
        <trans-unit id="0c3d8be9b8127c58bfe70c563eaca0d5dfe04a94" translate="yes" xml:space="preserve">
          <source>This task can now be called in the background:</source>
          <target state="translated">现在可以在后台调用这个任务。</target>
        </trans-unit>
        <trans-unit id="88f6d2188dc461b9d34ced5bc64ba2378724ea3d" translate="yes" xml:space="preserve">
          <source>This tells the browser to authenticate with the server using only the specific certificate key to prevent MITM attacks.</source>
          <target state="translated">这告诉浏览器只使用特定的证书密钥与服务器进行认证,以防止MITM攻击。</target>
        </trans-unit>
        <trans-unit id="a606d3b373d852c1393f5ec1fe858bcbc42622a5" translate="yes" xml:space="preserve">
          <source>This tells your operating system to listen on all public IPs.</source>
          <target state="translated">这告诉你的操作系统要监听所有的公共IP。</target>
        </trans-unit>
        <trans-unit id="685903a0d50b3526f1b9a69870d1c25209077857" translate="yes" xml:space="preserve">
          <source>This template, which we&amp;rsquo;ll call &lt;code&gt;layout.html&lt;/code&gt;, defines a simple HTML skeleton document that you might use for a simple two-column page. It&amp;rsquo;s the job of &amp;ldquo;child&amp;rdquo; templates to fill the empty blocks with content:</source>
          <target state="translated">这个模板，我们称为 &lt;code&gt;layout.html&lt;/code&gt; ，定义了一个简单的HTML框架文档，您可以将其用于一个简单的两列页面。&amp;ldquo;子&amp;rdquo;模板的工作是用内容填充空白块：</target>
        </trans-unit>
        <trans-unit id="4f53c0131c2542f9612c58c664e5bfbf76081646" translate="yes" xml:space="preserve">
          <source>This will also be passed an &lt;code&gt;exc&lt;/code&gt; keyword argument that has a reference to the exception that caused the teardown if there was one.</source>
          <target state="translated">这也将传递一个 &lt;code&gt;exc&lt;/code&gt; 关键字参数，该参数引用了导致拆解的异常（如果有的话）。</target>
        </trans-unit>
        <trans-unit id="740681369b3b41339095a45f318c35cfcae5001f" translate="yes" xml:space="preserve">
          <source>This will link to &lt;code&gt;admin.index&lt;/code&gt; for instance in case the current request was dispatched to any other admin blueprint endpoint.</source>
          <target state="translated">例如，这将链接到 &lt;code&gt;admin.index&lt;/code&gt; ，以防当前请求被分派到任何其他管理蓝图端点。</target>
        </trans-unit>
        <trans-unit id="b71ce56b62b4a6141ff4e1c6fcbf7fbb8d64661a" translate="yes" xml:space="preserve">
          <source>This will make the sqlite3 module return dicts for this database connection, which are much nicer to deal with. Even more simply, we could place this in &lt;code&gt;get_db&lt;/code&gt; instead:</source>
          <target state="translated">这将使sqlite3模块返回此数据库连接的命令，这要好得多。更简单地说，我们可以将其放在 &lt;code&gt;get_db&lt;/code&gt; 中：</target>
        </trans-unit>
        <trans-unit id="6b99a42484154d682991f9a2ddea852601c52a17" translate="yes" xml:space="preserve">
          <source>This will reference the index function local to the current blueprint:</source>
          <target state="translated">这将引用当前蓝图的本地索引函数。</target>
        </trans-unit>
        <trans-unit id="ba22a9098184804f2bbe59f5971c4cc7d7929d78" translate="yes" xml:space="preserve">
          <source>This will send a JSON response like this to the browser:</source>
          <target state="translated">这将向浏览器发送这样的JSON响应。</target>
        </trans-unit>
        <trans-unit id="df7d29e076fb2490907c4627fc46c19e9ded6279" translate="yes" xml:space="preserve">
          <source>This works exactly like the method of the same name on a regular &lt;a href=&quot;https://click.palletsprojects.com/en/7.x/api/#click.Group&quot;&gt;&lt;code&gt;click.Group&lt;/code&gt;&lt;/a&gt; but it defaults the group class to &lt;a href=&quot;#flask.cli.AppGroup&quot;&gt;&lt;code&gt;AppGroup&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这与常规&lt;a href=&quot;https://click.palletsprojects.com/en/7.x/api/#click.Group&quot;&gt; &lt;code&gt;click.Group&lt;/code&gt; &lt;/a&gt;上具有相同名称的方法完全一样，但是默认将组类设置为&lt;a href=&quot;#flask.cli.AppGroup&quot;&gt; &lt;code&gt;AppGroup&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c5b1bd25ca66eaefccf4709595523bed248e70ca" translate="yes" xml:space="preserve">
          <source>This works exactly like the method of the same name on a regular &lt;a href=&quot;https://click.palletsprojects.com/en/7.x/api/#click.Group&quot;&gt;&lt;code&gt;click.Group&lt;/code&gt;&lt;/a&gt; but it wraps callbacks in &lt;a href=&quot;#flask.cli.with_appcontext&quot;&gt;&lt;code&gt;with_appcontext()&lt;/code&gt;&lt;/a&gt; unless it&amp;rsquo;s disabled by passing &lt;code&gt;with_appcontext=False&lt;/code&gt;.</source>
          <target state="translated">这与常规&lt;a href=&quot;https://click.palletsprojects.com/en/7.x/api/#click.Group&quot;&gt; &lt;code&gt;click.Group&lt;/code&gt; &lt;/a&gt;上具有相同名称的方法完全一样，但是它将回调包装在&lt;a href=&quot;#flask.cli.with_appcontext&quot;&gt; &lt;code&gt;with_appcontext()&lt;/code&gt; 中,&lt;/a&gt;除非通过传递 &lt;code&gt;with_appcontext=False&lt;/code&gt; 将其禁用。</target>
        </trans-unit>
        <trans-unit id="048bbc4ef88d4696e23cbb8f5215851a6a04fee9" translate="yes" xml:space="preserve">
          <source>This works similar to a regular click &lt;a href=&quot;https://click.palletsprojects.com/en/7.x/api/#click.Group&quot;&gt;&lt;code&gt;Group&lt;/code&gt;&lt;/a&gt; but it changes the behavior of the &lt;a href=&quot;#flask.cli.AppGroup.command&quot;&gt;&lt;code&gt;command()&lt;/code&gt;&lt;/a&gt; decorator so that it automatically wraps the functions in &lt;a href=&quot;#flask.cli.with_appcontext&quot;&gt;&lt;code&gt;with_appcontext()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这类似于常规单击&lt;a href=&quot;https://click.palletsprojects.com/en/7.x/api/#click.Group&quot;&gt; &lt;code&gt;Group&lt;/code&gt; &lt;/a&gt;但是它更改了&lt;a href=&quot;#flask.cli.AppGroup.command&quot;&gt; &lt;code&gt;command()&lt;/code&gt; &lt;/a&gt;装饰器的行为，以便自动将函数包装在&lt;a href=&quot;#flask.cli.with_appcontext&quot;&gt; &lt;code&gt;with_appcontext()&lt;/code&gt; 中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="04d82ffa704bf546ce29907b084ecf32cbf71088" translate="yes" xml:space="preserve">
          <source>This works well for the common case but it does not work well for development which is why from Flask 0.11 onwards the &lt;strong&gt;flask&lt;/strong&gt; method is recommended. The reason for this is that due to how the reload mechanism works there are some bizarre side-effects (like executing certain code twice, sometimes crashing without message or dying when a syntax or import error happens).</source>
          <target state="translated">这在通常情况下效果很好，但在开发中效果不佳，这就是为什么从Flask 0.11开始推荐使用&lt;strong&gt;flask&lt;/strong&gt;方法的原因。这样做的原因是，由于重载机制的工作方式，所以有一些怪异的副作用（例如两次执行某些代码，有时崩溃而没有消息，或者在发生语法错误或导入错误时死亡）。</target>
        </trans-unit>
        <trans-unit id="a8d246cb8dba4b5b2505bbf5e67242d645dc7790" translate="yes" xml:space="preserve">
          <source>This would use Row objects rather than dicts to return the results of queries. These are &lt;code&gt;namedtuple&lt;/code&gt; s, so we can access them either by index or by key. For example, assuming we have a &lt;code&gt;sqlite3.Row&lt;/code&gt; called &lt;code&gt;r&lt;/code&gt; for the rows &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;FirstName&lt;/code&gt;, &lt;code&gt;LastName&lt;/code&gt;, and &lt;code&gt;MiddleInitial&lt;/code&gt;:</source>
          <target state="translated">这将使用Row对象而不是dict返回查询结果。这些是 &lt;code&gt;namedtuple&lt;/code&gt; ，因此我们可以通过索引或键来访问它们。例如，假设我们有一个 &lt;code&gt;sqlite3.Row&lt;/code&gt; 称为 &lt;code&gt;r&lt;/code&gt; 为行 &lt;code&gt;id&lt;/code&gt; ， &lt;code&gt;FirstName&lt;/code&gt; ， &lt;code&gt;LastName&lt;/code&gt; ，和 &lt;code&gt;MiddleInitial&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c4c878a67ee574af9969b64cc6b404d8760885ff" translate="yes" xml:space="preserve">
          <source>Thread Locals</source>
          <target state="translated">螺纹本地人</target>
        </trans-unit>
        <trans-unit id="4f13d81133b998892b6e7fb45730343862ff8863" translate="yes" xml:space="preserve">
          <source>Thread-Locals in Flask</source>
          <target state="translated">线程-Flask中的定位</target>
        </trans-unit>
        <trans-unit id="a05b908e90b584ff0a2935d00857fc4cef6f217f" translate="yes" xml:space="preserve">
          <source>Threaded mode is enabled by default.</source>
          <target state="translated">线程模式默认为启用。</target>
        </trans-unit>
        <trans-unit id="bd1ed9d20cc0d2af2d08a4ca307a4057dede220c" translate="yes" xml:space="preserve">
          <source>To access cookies you can use the &lt;a href=&quot;../api/index#flask.Request.cookies&quot;&gt;&lt;code&gt;cookies&lt;/code&gt;&lt;/a&gt; attribute. To set cookies you can use the &lt;a href=&quot;../api/index#flask.Response.set_cookie&quot;&gt;&lt;code&gt;set_cookie&lt;/code&gt;&lt;/a&gt; method of response objects. The &lt;a href=&quot;../api/index#flask.Request.cookies&quot;&gt;&lt;code&gt;cookies&lt;/code&gt;&lt;/a&gt; attribute of request objects is a dictionary with all the cookies the client transmits. If you want to use sessions, do not use the cookies directly but instead use the &lt;a href=&quot;#sessions&quot;&gt;Sessions&lt;/a&gt; in Flask that add some security on top of cookies for you.</source>
          <target state="translated">要访问cookie，您可以使用&lt;a href=&quot;../api/index#flask.Request.cookies&quot;&gt; &lt;code&gt;cookies&lt;/code&gt; &lt;/a&gt;属性。要设置cookie，可以使用响应对象的&lt;a href=&quot;../api/index#flask.Response.set_cookie&quot;&gt; &lt;code&gt;set_cookie&lt;/code&gt; &lt;/a&gt;方法。请求对象的&lt;a href=&quot;../api/index#flask.Request.cookies&quot;&gt; &lt;code&gt;cookies&lt;/code&gt; &lt;/a&gt;属性是一个字典，其中包含客户端传输的所有cookie。如果要使用会话，请不要直接使用cookie，而应使用Flask中的&lt;a href=&quot;#sessions&quot;&gt;Session&lt;/a&gt;，这些会话会为cookie增添一些安全性。</target>
        </trans-unit>
        <trans-unit id="e4b26d9eb9fc845c05b903282d2f8d57ec058f32" translate="yes" xml:space="preserve">
          <source>To access incoming request data, you can use the global &lt;code&gt;request&lt;/code&gt; object. Flask parses incoming request data for you and gives you access to it through that global object. Internally Flask makes sure that you always get the correct data for the active thread if you are in a multithreaded environment.</source>
          <target state="translated">要访问传入的请求数据，可以使用全局 &lt;code&gt;request&lt;/code&gt; 对象。Flask为您解析传入的请求数据，并允许您通过该全局对象对其进行访问。如果您在多线程环境中，则Flask的内部功能可确保始终为活动线程获取正确的数据。</target>
        </trans-unit>
        <trans-unit id="93c907be4da14da2a5091dcce3d29a18de7bd6f2" translate="yes" xml:space="preserve">
          <source>To access parameters submitted in the URL (&lt;code&gt;?key=value&lt;/code&gt;) you can use the &lt;a href=&quot;../api/index#flask.Request.args&quot;&gt;&lt;code&gt;args&lt;/code&gt;&lt;/a&gt; attribute:</source>
          <target state="translated">要访问通过URL（ &lt;code&gt;?key=value&lt;/code&gt; ）提交的参数，可以使用&lt;a href=&quot;../api/index#flask.Request.args&quot;&gt; &lt;code&gt;args&lt;/code&gt; &lt;/a&gt;属性：</target>
        </trans-unit>
        <trans-unit id="621dac882c1e3b180fff49e6a7618de84a783c99" translate="yes" xml:space="preserve">
          <source>To access the current session you can use the &lt;a href=&quot;#flask.session&quot;&gt;&lt;code&gt;session&lt;/code&gt;&lt;/a&gt; object:</source>
          <target state="translated">要访问当前会话，可以使用&lt;a href=&quot;#flask.session&quot;&gt; &lt;code&gt;session&lt;/code&gt; &lt;/a&gt;对象：</target>
        </trans-unit>
        <trans-unit id="b812da36595883e5eeb8dca68fb7852151f5157d" translate="yes" xml:space="preserve">
          <source>To add WSGI middleware to your Flask application, wrap the application&amp;rsquo;s &lt;code&gt;wsgi_app&lt;/code&gt; attribute. For example, to apply Werkzeug&amp;rsquo;s &lt;code&gt;ProxyFix&lt;/code&gt; middleware for running behind Nginx:</source>
          <target state="translated">要将WSGI中间件添加到Flask应用程序中，请包装应用程序的 &lt;code&gt;wsgi_app&lt;/code&gt; 属性。例如，要应用Werkzeug的 &lt;code&gt;ProxyFix&lt;/code&gt; 中间件在Nginx后面运行：</target>
        </trans-unit>
        <trans-unit id="9d505128b82e741413f1b28090a73abdb720e6e7" translate="yes" xml:space="preserve">
          <source>To be proactive about discovering and fixing bugs, you can configure a &lt;a href=&quot;https://docs.python.org/3/library/logging.handlers.html#logging.handlers.SMTPHandler&quot;&gt;&lt;code&gt;logging.handlers.SMTPHandler&lt;/code&gt;&lt;/a&gt; to send an email when errors and higher are logged.</source>
          <target state="translated">要主动发现和修复错误，可以配置&lt;a href=&quot;https://docs.python.org/3/library/logging.handlers.html#logging.handlers.SMTPHandler&quot;&gt; &lt;code&gt;logging.handlers.SMTPHandler&lt;/code&gt; &lt;/a&gt;在记录错误或更高级别时发送电子邮件。</target>
        </trans-unit>
        <trans-unit id="fe76da13b091b052b5b37287489d80f8715fec52" translate="yes" xml:space="preserve">
          <source>To build a URL to a specific function, use the &lt;a href=&quot;../api/index#flask.url_for&quot;&gt;&lt;code&gt;url_for()&lt;/code&gt;&lt;/a&gt; function. It accepts the name of the function as its first argument and any number of keyword arguments, each corresponding to a variable part of the URL rule. Unknown variable parts are appended to the URL as query parameters.</source>
          <target state="translated">要构建指向特定函数的URL，请使用&lt;a href=&quot;../api/index#flask.url_for&quot;&gt; &lt;code&gt;url_for()&lt;/code&gt; &lt;/a&gt;函数。它接受函数名称作为其第一个参数以及任意数量的关键字参数，每个参数对应于URL规则的可变部分。未知变量部分作为查询参数附加到URL。</target>
        </trans-unit>
        <trans-unit id="a12458096d7a344e2bd4a39b0d6031b1cc8ac1d0" translate="yes" xml:space="preserve">
          <source>To convert that into a larger one, just create a new folder &lt;code&gt;yourapplication&lt;/code&gt; inside the existing one and move everything below it. Then rename &lt;code&gt;yourapplication.py&lt;/code&gt; to &lt;code&gt;__init__.py&lt;/code&gt;. (Make sure to delete all &lt;code&gt;.pyc&lt;/code&gt; files first, otherwise things would most likely break)</source>
          <target state="translated">要将其转换为更大的文件夹，只需在现有文件夹中创建一个新的文件夹 &lt;code&gt;yourapplication&lt;/code&gt; 并将所有内容移动到它下面。然后将 &lt;code&gt;yourapplication.py&lt;/code&gt; 重命名为 &lt;code&gt;__init__.py&lt;/code&gt; 。（请务必先删除所有 &lt;code&gt;.pyc&lt;/code&gt; 文件，否则事情很可能会中断）</target>
        </trans-unit>
        <trans-unit id="7351c32491e91781aa14cc64a3439677be49d792" translate="yes" xml:space="preserve">
          <source>To create the database you can use the &lt;code&gt;init_db&lt;/code&gt; function:</source>
          <target state="translated">要创建数据库，可以使用 &lt;code&gt;init_db&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="1552e2ef44bcdc258f0dff07f8e9456e2cc247b0" translate="yes" xml:space="preserve">
          <source>To declare a model that represents a Mongo document, create a class that inherits from &lt;code&gt;Document&lt;/code&gt; and declare each of the fields.</source>
          <target state="translated">要声明代表Mongo文档的模型，请创建一个继承自 &lt;code&gt;Document&lt;/code&gt; 的类并声明每个字段。</target>
        </trans-unit>
        <trans-unit id="a04e8278e482f23a25aa11a2f56acbbbe8f14a13" translate="yes" xml:space="preserve">
          <source>To define your models, just subclass the &lt;code&gt;Base&lt;/code&gt; class that was created by the code above. If you are wondering why we don&amp;rsquo;t have to care about threads here (like we did in the SQLite3 example above with the &lt;a href=&quot;../../api/index#flask.g&quot;&gt;&lt;code&gt;g&lt;/code&gt;&lt;/a&gt; object): that&amp;rsquo;s because SQLAlchemy does that for us already with the &lt;code&gt;scoped_session&lt;/code&gt;.</source>
          <target state="translated">要定义模型，只需将上面代码创建的 &lt;code&gt;Base&lt;/code&gt; 类子类化即可。如果您想知道为什么我们不必在这里关心线程（就像我们在上面的SQLite3示例中使用&lt;a href=&quot;../../api/index#flask.g&quot;&gt; &lt;code&gt;g&lt;/code&gt; &lt;/a&gt;对象所做的那样）：那是因为SQLAlchemy已经使用 &lt;code&gt;scoped_session&lt;/code&gt; 为我们做到了。</target>
        </trans-unit>
        <trans-unit id="617eb7f710ae3aabc70b2828e96591e69a824e91" translate="yes" xml:space="preserve">
          <source>To delete the database after the test, the fixture closes the file and removes it from the filesystem.</source>
          <target state="translated">要在测试后删除数据库,夹具会关闭文件,并将其从文件系统中删除。</target>
        </trans-unit>
        <trans-unit id="edbc05132eafa778a9a8f96fbc79cd1475a1d140" translate="yes" xml:space="preserve">
          <source>To disable the autoescape system in templates, you can use the &lt;code&gt;{%
autoescape %}&lt;/code&gt; block:</source>
          <target state="translated">要在模板中禁用自动转义系统，可以使用 &lt;code&gt;{% autoescape %}&lt;/code&gt; 块：</target>
        </trans-unit>
        <trans-unit id="ecfe7763079667f035480f2de104909cbbd3b532" translate="yes" xml:space="preserve">
          <source>To enable all development features (including debug mode) you can export the &lt;code&gt;FLASK_ENV&lt;/code&gt; environment variable and set it to &lt;code&gt;development&lt;/code&gt; before running the server:</source>
          <target state="translated">要启用所有开发功能（包括调试模式），可以在运行服务器之前导出 &lt;code&gt;FLASK_ENV&lt;/code&gt; 环境变量并将其设置为 &lt;code&gt;development&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e9938f0fdba64d198c72d3f8de75439aef9a04c7" translate="yes" xml:space="preserve">
          <source>To enable such a config you just have to call into &lt;a href=&quot;../api/index#flask.Config.from_object&quot;&gt;&lt;code&gt;from_object()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">要启用这样的配置，您只需要调用&lt;a href=&quot;../api/index#flask.Config.from_object&quot;&gt; &lt;code&gt;from_object()&lt;/code&gt; 即可&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="f8c7eb28a8a3cd82785800c49ac2c8451234880a" translate="yes" xml:space="preserve">
          <source>To explore the data in your application, you can start an interactive Python shell with the &lt;a href=&quot;../api/index#flask.cli.shell_command&quot;&gt;&lt;code&gt;shell&lt;/code&gt;&lt;/a&gt; command. An application context will be active, and the app instance will be imported.</source>
          <target state="translated">要浏览应用程序中的数据，可以使用&lt;a href=&quot;../api/index#flask.cli.shell_command&quot;&gt; &lt;code&gt;shell&lt;/code&gt; &lt;/a&gt;命令启动交互式Python shell 。应用程序上下文将处于活动状态，并且将导入应用程序实例。</target>
        </trans-unit>
        <trans-unit id="0fd3592a9cca63dcac7681c39222688a86c62178" translate="yes" xml:space="preserve">
          <source>To flash a message use the &lt;a href=&quot;../api/index#flask.flash&quot;&gt;&lt;code&gt;flash()&lt;/code&gt;&lt;/a&gt; method, to get hold of the messages you can use &lt;a href=&quot;../api/index#flask.get_flashed_messages&quot;&gt;&lt;code&gt;get_flashed_messages()&lt;/code&gt;&lt;/a&gt; which is also available in the templates. Check out the &lt;a href=&quot;../patterns/flashing/index#message-flashing-pattern&quot;&gt;Message Flashing&lt;/a&gt; for a full example.</source>
          <target state="translated">要刷新消息，请使用&lt;a href=&quot;../api/index#flask.flash&quot;&gt; &lt;code&gt;flash()&lt;/code&gt; &lt;/a&gt;方法，可以使用模板中也提供的&lt;a href=&quot;../api/index#flask.get_flashed_messages&quot;&gt; &lt;code&gt;get_flashed_messages()&lt;/code&gt; &lt;/a&gt;来保留消息。请查看&lt;a href=&quot;../patterns/flashing/index#message-flashing-pattern&quot;&gt;消息闪烁&lt;/a&gt;以获取完整示例。</target>
        </trans-unit>
        <trans-unit id="4b816b46d33ad0b0902d2c4af5ecc92e61b6e91d" translate="yes" xml:space="preserve">
          <source>To flash a message with a different category, just use the second argument to the &lt;a href=&quot;../../api/index#flask.flash&quot;&gt;&lt;code&gt;flash()&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">要刷新其他类别的消息，只需使用&lt;a href=&quot;../../api/index#flask.flash&quot;&gt; &lt;code&gt;flash()&lt;/code&gt; &lt;/a&gt;函数的第二个参数：</target>
        </trans-unit>
        <trans-unit id="d35a98cf4f1cac2dc6eaa5449354434f06345604" translate="yes" xml:space="preserve">
          <source>To further reiterate this: if you have a blueprint named &lt;code&gt;admin&lt;/code&gt; and you want to render a template called &lt;code&gt;index.html&lt;/code&gt; which is specific to this blueprint, the best idea is to lay out your templates like this:</source>
          <target state="translated">要进一步重申这一点：如果您有一个名为 &lt;code&gt;admin&lt;/code&gt; 的蓝图，并且想要呈现一个名为 &lt;code&gt;index.html&lt;/code&gt; 的模板，该模板特定于该蓝图，则最好的想法是按照以下方式布置您的模板：</target>
        </trans-unit>
        <trans-unit id="a42f41d321a27499f22140ca4956aa12e4b31ba2" translate="yes" xml:space="preserve">
          <source>To generate URLs for static files, use the special &lt;code&gt;'static'&lt;/code&gt; endpoint name:</source>
          <target state="translated">要为静态文件生成URL，请使用特殊的 &lt;code&gt;'static'&lt;/code&gt; 端点名称：</target>
        </trans-unit>
        <trans-unit id="7766aaf6770c2635d1f681195492db0d16d070c0" translate="yes" xml:space="preserve">
          <source>To go from Unicode into a specific charset such as UTF-8 you can use the &lt;code&gt;unicode.encode()&lt;/code&gt; method:</source>
          <target state="translated">要从Unicode转换为特定字符集（例如UTF-8），可以使用 &lt;code&gt;unicode.encode()&lt;/code&gt; 方法：</target>
        </trans-unit>
        <trans-unit id="86d26dae4df8fae537e133954dc773bbd4f2c469" translate="yes" xml:space="preserve">
          <source>To help deployment tools you can activate support for automatic reloading. Whenever something changes the &lt;code&gt;.wsgi&lt;/code&gt; file, &lt;code&gt;mod_wsgi&lt;/code&gt; will reload all the daemon processes for us.</source>
          <target state="translated">为了帮助部署工具，您可以激活对自动重新加载的支持。只要 &lt;code&gt;.wsgi&lt;/code&gt; 文件发生更改， &lt;code&gt;mod_wsgi&lt;/code&gt; 就会为我们重新加载所有守护进程。</target>
        </trans-unit>
        <trans-unit id="c65e52cfad61d22c99212ea16b3007ad1db7cbb4" translate="yes" xml:space="preserve">
          <source>To inject new variables automatically into the context of a template, context processors exist in Flask. Context processors run before the template is rendered and have the ability to inject new values into the template context. A context processor is a function that returns a dictionary. The keys and values of this dictionary are then merged with the template context, for all templates in the app:</source>
          <target state="translated">为了将新变量自动注入到模板的上下文中,Flask中存在上下文处理器。上下文处理器在模板渲染之前运行,并且有能力将新的值注入到模板上下文中。上下文处理器是一个返回一个字典的函数。然后,该字典的键和值将与模板上下文合并,适用于应用程序中的所有模板。</target>
        </trans-unit>
        <trans-unit id="a822b2a4eba7f3d869b6903c17c94bd84d3e9cda" translate="yes" xml:space="preserve">
          <source>To insert data you can use the &lt;code&gt;insert&lt;/code&gt; method. We have to get a connection first so that we can use a transaction:</source>
          <target state="translated">要插入数据，可以使用 &lt;code&gt;insert&lt;/code&gt; 方法。我们必须首先获得连接，以便我们可以使用事务：</target>
        </trans-unit>
        <trans-unit id="befca72bc129b7178d70685483257779431b3651" translate="yes" xml:space="preserve">
          <source>To install your application (ideally into a virtualenv) just run the &lt;code&gt;setup.py&lt;/code&gt; script with the &lt;code&gt;install&lt;/code&gt; parameter. It will install your application into the virtualenv&amp;rsquo;s site-packages folder and also download and install all dependencies:</source>
          <target state="translated">要安装您的应用程序（理想情况下是安装到virtualenv中），只需运行带有 &lt;code&gt;install&lt;/code&gt; 参数的 &lt;code&gt;setup.py&lt;/code&gt; 脚本即可。它将把您的应用程序安装到virtualenv的site-packages文件夹中，并下载并安装所有依赖项：</target>
        </trans-unit>
        <trans-unit id="484c14f1d3c0d76fcc5a407bed7bf241a6e99829" translate="yes" xml:space="preserve">
          <source>To integrate applications, &lt;a href=&quot;#flask.Flask&quot;&gt;&lt;code&gt;Flask&lt;/code&gt;&lt;/a&gt; has a hook to intercept URL build errors through &lt;a href=&quot;#flask.Flask.url_build_error_handlers&quot;&gt;&lt;code&gt;Flask.url_build_error_handlers&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;url_for&lt;/code&gt; function results in a &lt;code&gt;BuildError&lt;/code&gt; when the current app does not have a URL for the given endpoint and values. When it does, the &lt;a href=&quot;#flask.current_app&quot;&gt;&lt;code&gt;current_app&lt;/code&gt;&lt;/a&gt; calls its &lt;a href=&quot;#flask.Flask.url_build_error_handlers&quot;&gt;&lt;code&gt;url_build_error_handlers&lt;/code&gt;&lt;/a&gt; if it is not &lt;code&gt;None&lt;/code&gt;, which can return a string to use as the result of &lt;code&gt;url_for&lt;/code&gt; (instead of &lt;code&gt;url_for&lt;/code&gt;&amp;rsquo;s default to raise the &lt;code&gt;BuildError&lt;/code&gt; exception) or re-raise the exception. An example:</source>
          <target state="translated">为了集成应用程序，&lt;a href=&quot;#flask.Flask&quot;&gt; &lt;code&gt;Flask&lt;/code&gt; &lt;/a&gt;有一个钩子，可以通过&lt;a href=&quot;#flask.Flask.url_build_error_handlers&quot;&gt; &lt;code&gt;Flask.url_build_error_handlers&lt;/code&gt; &lt;/a&gt;拦截URL构建错误。该 &lt;code&gt;url_for&lt;/code&gt; 函数中的结果 &lt;code&gt;BuildError&lt;/code&gt; 在当前的应用程序没有对给定端点和值的URL。&lt;a href=&quot;#flask.Flask.url_build_error_handlers&quot;&gt; &lt;code&gt;url_build_error_handlers&lt;/code&gt; &lt;/a&gt;如果&lt;a href=&quot;#flask.current_app&quot;&gt; &lt;code&gt;current_app&lt;/code&gt; &lt;/a&gt;不是 &lt;code&gt;None&lt;/code&gt; ，则current_app调用其url_build_error_handlers，它可以返回一个字符串以用作 &lt;code&gt;url_for&lt;/code&gt; 的结果（而不是 &lt;code&gt;url_for&lt;/code&gt; 的默认值引发 &lt;code&gt;BuildError&lt;/code&gt; 异常）或重新引发该异常。一个例子：</target>
        </trans-unit>
        <trans-unit id="cf6214cd7590455bcab5a6a311902e638580fd66" translate="yes" xml:space="preserve">
          <source>To pass variable parts to the SQL statement, use a question mark in the statement and pass in the arguments as a list. Never directly add them to the SQL statement with string formatting because this makes it possible to attack the application using &lt;a href=&quot;https://en.wikipedia.org/wiki/SQL_injection&quot;&gt;SQL Injections&lt;/a&gt;.</source>
          <target state="translated">要将变量部分传递给SQL语句，请在语句中使用问号，然后将参数作为列表传递。切勿将它们直接以字符串格式添加到SQL语句中，因为这样可以使用&lt;a href=&quot;https://en.wikipedia.org/wiki/SQL_injection&quot;&gt;SQL Injections&lt;/a&gt;攻击应用程序。</target>
        </trans-unit>
        <trans-unit id="ec5a5f74702dd95d4e7a845702eba953e569ee84" translate="yes" xml:space="preserve">
          <source>To prevent this, you&amp;rsquo;ll need to set the &lt;a href=&quot;#security-csp&quot;&gt;Content Security Policy (CSP)&lt;/a&gt; response header.</source>
          <target state="translated">为防止这种情况，您需要设置&lt;a href=&quot;#security-csp&quot;&gt;内容安全策略（CSP）&lt;/a&gt;响应标头。</target>
        </trans-unit>
        <trans-unit id="3119d63c0272400ae0b58e3bd2e8d1d9ce954eb3" translate="yes" xml:space="preserve">
          <source>To query your database, you use the engine directly or use a connection:</source>
          <target state="translated">要查询数据库,直接使用引擎或使用连接。</target>
        </trans-unit>
        <trans-unit id="704e2160429f4da487552c86de50b136105bb4f8" translate="yes" xml:space="preserve">
          <source>To quickly open sources from this folder you can use the &lt;a href=&quot;../api/index#flask.Blueprint.open_resource&quot;&gt;&lt;code&gt;open_resource()&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">要从此文件夹快速打开源，可以使用&lt;a href=&quot;../api/index#flask.Blueprint.open_resource&quot;&gt; &lt;code&gt;open_resource()&lt;/code&gt; &lt;/a&gt;函数：</target>
        </trans-unit>
        <trans-unit id="ce37f0fb86710f94c114ddfaf1395b5873e7e9c4" translate="yes" xml:space="preserve">
          <source>To redirect a user to another endpoint, use the &lt;a href=&quot;../api/index#flask.redirect&quot;&gt;&lt;code&gt;redirect()&lt;/code&gt;&lt;/a&gt; function; to abort a request early with an error code, use the &lt;a href=&quot;../api/index#flask.abort&quot;&gt;&lt;code&gt;abort()&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">要将用户重定向到另一个端点，请使用&lt;a href=&quot;../api/index#flask.redirect&quot;&gt; &lt;code&gt;redirect()&lt;/code&gt; &lt;/a&gt;函数；要使用错误代码提前中止请求，请使用&lt;a href=&quot;../api/index#flask.abort&quot;&gt; &lt;code&gt;abort()&lt;/code&gt; &lt;/a&gt;函数：</target>
        </trans-unit>
        <trans-unit id="11df7bdb0ab8dab0067f6e4b9634162320857669" translate="yes" xml:space="preserve">
          <source>To register an error handler, use the &lt;a href=&quot;#flask.Flask.errorhandler&quot;&gt;&lt;code&gt;errorhandler()&lt;/code&gt;&lt;/a&gt; decorator.</source>
          <target state="translated">要注册错误处理程序，请使用&lt;a href=&quot;#flask.Flask.errorhandler&quot;&gt; &lt;code&gt;errorhandler()&lt;/code&gt; &lt;/a&gt;装饰器。</target>
        </trans-unit>
        <trans-unit id="55db3e9d5a71adf8cb2a37301e4f64c447cada25" translate="yes" xml:space="preserve">
          <source>To render a template you can use the &lt;a href=&quot;../api/index#flask.render_template&quot;&gt;&lt;code&gt;render_template()&lt;/code&gt;&lt;/a&gt; method. All you have to do is provide the name of the template and the variables you want to pass to the template engine as keyword arguments. Here&amp;rsquo;s a simple example of how to render a template:</source>
          <target state="translated">要渲染模板，可以使用&lt;a href=&quot;../api/index#flask.render_template&quot;&gt; &lt;code&gt;render_template()&lt;/code&gt; &lt;/a&gt;方法。您所要做的就是提供模板的名称以及要作为关键字参数传递给模板引擎的变量。这是有关如何渲染模板的简单示例：</target>
        </trans-unit>
        <trans-unit id="89852e42ea0dd6de7cefcf4d3a7ff383decef7e2" translate="yes" xml:space="preserve">
          <source>To replace the session interface on an application all you have to do is to assign &lt;a href=&quot;#flask.Flask.session_interface&quot;&gt;&lt;code&gt;flask.Flask.session_interface&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">要替换应用程序上的会话接口，您所要做的就是分配&lt;a href=&quot;#flask.Flask.session_interface&quot;&gt; &lt;code&gt;flask.Flask.session_interface&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="88ddea77b1adaf28c6fc2c7cc07594c546ee3c5e" translate="yes" xml:space="preserve">
          <source>To run such an application, you can use the &lt;strong&gt;flask&lt;/strong&gt; command:</source>
          <target state="translated">要运行这样的应用程序，可以使用&lt;strong&gt;flask&lt;/strong&gt;命令：</target>
        </trans-unit>
        <trans-unit id="c292b2cfd2f5284d0e125ad58099be01c7125d0d" translate="yes" xml:space="preserve">
          <source>To run the application you can either use the &lt;strong&gt;flask&lt;/strong&gt; command or python&amp;rsquo;s &lt;code&gt;-m&lt;/code&gt; switch with Flask. Before you can do that you need to tell your terminal the application to work with by exporting the &lt;code&gt;FLASK_APP&lt;/code&gt; environment variable:</source>
          <target state="translated">要运行该应用程序，您可以使用&lt;strong&gt;flask&lt;/strong&gt;命令或将Flask与python的 &lt;code&gt;-m&lt;/code&gt; 开关一起使用。在执行此操作之前，您需要通过导出 &lt;code&gt;FLASK_APP&lt;/code&gt; 环境变量来告诉终端应用程序可以使用：</target>
        </trans-unit>
        <trans-unit id="2c86414bed10fbdff55ce3b53f322730faff1038" translate="yes" xml:space="preserve">
          <source>To run your application you need a &lt;code&gt;yourapplication.wsgi&lt;/code&gt; file. This file contains the code &lt;code&gt;mod_wsgi&lt;/code&gt; is executing on startup to get the application object. The object called &lt;code&gt;application&lt;/code&gt; in that file is then used as application.</source>
          <target state="translated">要运行您的应用程序，您需要一个 &lt;code&gt;yourapplication.wsgi&lt;/code&gt; 文件。该文件包含代码 &lt;code&gt;mod_wsgi&lt;/code&gt; 在启动时正在执行以获取应用程序对象。然后将该文件中称为 &lt;code&gt;application&lt;/code&gt; 的对象用作应用程序。</target>
        </trans-unit>
        <trans-unit id="6eb5820888b69629537c0389aab12263c5f14443" translate="yes" xml:space="preserve">
          <source>To setup a new server you would roughly do these steps:</source>
          <target state="translated">要设置一个新的服务器,你大概要做这些步骤。</target>
        </trans-unit>
        <trans-unit id="f9ef209a6b01aa558f49d827a62a2a159258935f" translate="yes" xml:space="preserve">
          <source>To share data that is valid for one request only from one function to another, a global variable is not good enough because it would break in threaded environments. Flask provides you with a special object that ensures it is only valid for the active request and that will return different values for each request. In a nutshell: it does the right thing, like it does for &lt;a href=&quot;#flask.request&quot;&gt;&lt;code&gt;request&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#flask.session&quot;&gt;&lt;code&gt;session&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要仅对一个函数的一个请求与另一个函数共享有效的数据，全局变量不够好，因为它会在线程环境中中断。Flask为您提供了一个特殊的对象，以确保它仅对活动请求有效，并且将为每个请求返回不同的值。简而言之：它做正确的事情，就像对&lt;a href=&quot;#flask.request&quot;&gt; &lt;code&gt;request&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#flask.session&quot;&gt; &lt;code&gt;session&lt;/code&gt; 一样&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b92d75b4d5a6e5c6a7dd4ffc865e69b2b1f22b46" translate="yes" xml:space="preserve">
          <source>To shutdown a request, you need to trick a bit before the after request functions (triggered by &lt;a href=&quot;../api/index#flask.Flask.process_response&quot;&gt;&lt;code&gt;process_response()&lt;/code&gt;&lt;/a&gt;) operate on a response object:</source>
          <target state="translated">要关闭请求，您需要在after请求函数（由&lt;a href=&quot;../api/index#flask.Flask.process_response&quot;&gt; &lt;code&gt;process_response()&lt;/code&gt; &lt;/a&gt;触发）操作之前进行一些技巧：</target>
        </trans-unit>
        <trans-unit id="be13ab9ab1cb83c668628ec6ddb741e0e3e2506f" translate="yes" xml:space="preserve">
          <source>To subscribe to a signal, you can use the &lt;a href=&quot;https://pythonhosted.org/blinker/index.html#blinker.base.Signal.connect&quot;&gt;&lt;code&gt;connect()&lt;/code&gt;&lt;/a&gt; method of a signal. The first argument is the function that should be called when the signal is emitted, the optional second argument specifies a sender. To unsubscribe from a signal, you can use the &lt;a href=&quot;https://pythonhosted.org/blinker/index.html#blinker.base.Signal.disconnect&quot;&gt;&lt;code&gt;disconnect()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">要订阅信号，可以使用信号的&lt;a href=&quot;https://pythonhosted.org/blinker/index.html#blinker.base.Signal.connect&quot;&gt; &lt;code&gt;connect()&lt;/code&gt; &lt;/a&gt;方法。第一个参数是发出信号时应调用的函数，可选的第二个参数指定发送方。要取消订阅信号，可以使用&lt;a href=&quot;https://pythonhosted.org/blinker/index.html#blinker.base.Signal.disconnect&quot;&gt; &lt;code&gt;disconnect()&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="2bec3dbd348720352fd046a06c9618afaa811067" translate="yes" xml:space="preserve">
          <source>To switch Flask to the development environment and enable debug mode, set &lt;code id=&quot;index-4&quot;&gt;FLASK_ENV&lt;/code&gt;:</source>
          <target state="translated">要将Flask切换到开发环境并启用调试模式，请设置 &lt;code id=&quot;index-4&quot;&gt;FLASK_ENV&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ed842eff799c3ef4a6df84ac92bedcb63ead05b7" translate="yes" xml:space="preserve">
          <source>To update multiple keys at once you can use the &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#dict.update&quot;&gt;&lt;code&gt;dict.update()&lt;/code&gt;&lt;/a&gt; method:</source>
          <target state="translated">要一次更新多个键，可以使用&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#dict.update&quot;&gt; &lt;code&gt;dict.update()&lt;/code&gt; &lt;/a&gt;方法：</target>
        </trans-unit>
        <trans-unit id="fce4f4f3c6ccfcc68d89b4b50d8c2835231a5012" translate="yes" xml:space="preserve">
          <source>To use SQLAlchemy in a declarative way with your application, you just have to put the following code into your application module. Flask will automatically remove database sessions at the end of the request or when the application shuts down:</source>
          <target state="translated">要在应用程序中以声明的方式使用SQLAlchemy,您只需将以下代码放入您的应用程序模块中。Flask将在请求结束或应用程序关闭时自动删除数据库会话。</target>
        </trans-unit>
        <trans-unit id="f3de54306a7a8c4c4ce40732e1b9c320a5fc9873" translate="yes" xml:space="preserve">
          <source>To use Sentry you need to install the &lt;code&gt;sentry-sdk&lt;/code&gt; client with extra &lt;code&gt;flask&lt;/code&gt; dependencies:</source>
          <target state="translated">要使用Sentry，您需要安装带有额外 &lt;code&gt;flask&lt;/code&gt; 依赖项的 &lt;code&gt;sentry-sdk&lt;/code&gt; 客户端：</target>
        </trans-unit>
        <trans-unit id="5a85b68d89c59e497538c13d04e2859d992ab11d" translate="yes" xml:space="preserve">
          <source>To use the decorator, apply it as innermost decorator to a view function. When applying further decorators, always remember that the &lt;a href=&quot;../../api/index#flask.Flask.route&quot;&gt;&lt;code&gt;route()&lt;/code&gt;&lt;/a&gt; decorator is the outermost.</source>
          <target state="translated">要使用装饰器，请将其作为最里面的装饰器应用到视图功能。当应用其他装饰器时，请始终记住&lt;a href=&quot;../../api/index#flask.Flask.route&quot;&gt; &lt;code&gt;route()&lt;/code&gt; &lt;/a&gt;装饰器是最外面的。</target>
        </trans-unit>
        <trans-unit id="c51bb9aa951ba13a62b3530e77baa79bf4d5ae32" translate="yes" xml:space="preserve">
          <source>To use this with Flask, wrap the app object with the middleware:</source>
          <target state="translated">要想在Flask中使用这个功能,请用中间件包装应用对象。</target>
        </trans-unit>
        <trans-unit id="130a013fc92ef6fe552ebe43fb5089da049d2a21" translate="yes" xml:space="preserve">
          <source>To use this, all you need to do is to hook the calculating stream in before the request starts consuming data. (Eg: be careful accessing &lt;code&gt;request.form&lt;/code&gt; or anything of that nature. &lt;code&gt;before_request_handlers&lt;/code&gt; for instance should be careful not to access it).</source>
          <target state="translated">要使用此功能，您需要做的就是在请求开始使用数据之前挂接计算流。（例如：小心访问 &lt;code&gt;request.form&lt;/code&gt; 或任何类似性质的东西。例如 &lt;code&gt;before_request_handlers&lt;/code&gt; 应该小心不要访问它）。</target>
        </trans-unit>
        <trans-unit id="cb1070677e443d2c3f2643dcfeaed5987d6da4f1" translate="yes" xml:space="preserve">
          <source>Tries to locate the instance path if it was not provided to the constructor of the application class. It will basically calculate the path to a folder named &lt;code&gt;instance&lt;/code&gt; next to your main file or the package.</source>
          <target state="translated">尝试查找实例路径（如果未提供给应用程序类的构造函数）。基本上，它将计算主文件或包旁边的名为 &lt;code&gt;instance&lt;/code&gt; 的文件夹的路径。</target>
        </trans-unit>
        <trans-unit id="285ec850c11d78bac10f6bfa31b69a37f1b257c9" translate="yes" xml:space="preserve">
          <source>Troubleshooting</source>
          <target state="translated">Troubleshooting</target>
        </trans-unit>
        <trans-unit id="064ec595836541fdcd69d60534f2d709b5723b20" translate="yes" xml:space="preserve">
          <source>Trusting Headers</source>
          <target state="translated">信任标题</target>
        </trans-unit>
        <trans-unit id="2e15aea469fb18f944108235f06c502c3941d7d8" translate="yes" xml:space="preserve">
          <source>Try to always pick a good sender. If you have a class that is emitting a signal, pass &lt;code&gt;self&lt;/code&gt; as sender. If you are emitting a signal from a random function, you can pass &lt;code&gt;current_app._get_current_object()&lt;/code&gt; as sender.</source>
          <target state="translated">尝试始终选择一个好的发件人。如果您有一个正在发出信号的类，请通过 &lt;code&gt;self&lt;/code&gt; 作为发送者。如果要从随机函数发出信号，则可以将 &lt;code&gt;current_app._get_current_object()&lt;/code&gt; 作为发送者传递。</target>
        </trans-unit>
        <trans-unit id="90d52a00458514c0d16ade46588691374f96864b" translate="yes" xml:space="preserve">
          <source>Trying to access a key that doesn&amp;rsquo;t exist from request dicts like &lt;code&gt;args&lt;/code&gt; and &lt;code&gt;form&lt;/code&gt; will return a 400 Bad Request error page. Enable this to treat the error as an unhandled exception instead so that you get the interactive debugger. This is a more specific version of &lt;code&gt;TRAP_HTTP_EXCEPTIONS&lt;/code&gt;. If unset, it is enabled in debug mode.</source>
          <target state="translated">尝试访问 &lt;code&gt;args&lt;/code&gt; 和 &lt;code&gt;form&lt;/code&gt; 之类的请求字典中不存在的键将返回400 Bad Request错误页面。启用此选项可将错误视为未处理的异常，以便获得交互式调试器。这是 &lt;code&gt;TRAP_HTTP_EXCEPTIONS&lt;/code&gt; 的一个更特定的版本。如果未设置，则在调试模式下启用。</target>
        </trans-unit>
        <trans-unit id="2701a94c0eb55cbd958a87dff3e959673ff1bf53" translate="yes" xml:space="preserve">
          <source>Tutorial</source>
          <target state="translated">Tutorial</target>
        </trans-unit>
        <trans-unit id="e042bdec66ef8705a7dc314bf4bd08b69778589f" translate="yes" xml:space="preserve">
          <source>Twisted Web</source>
          <target state="translated">扭曲的网络</target>
        </trans-unit>
        <trans-unit id="69ac9ef86066ef724082e99927f52d684fa3c3f1" translate="yes" xml:space="preserve">
          <source>Twisted Web supports many flags and options, and the &lt;code&gt;twistd&lt;/code&gt; utility does as well; see &lt;code&gt;twistd -h&lt;/code&gt; and &lt;code&gt;twistd web -h&lt;/code&gt; for more information. For example, to run a Twisted Web server in the foreground, on port 8080, with an application from &lt;code&gt;myproject&lt;/code&gt;:</source>
          <target state="translated">Twisted Web支持许多标志和选项， &lt;code&gt;twistd&lt;/code&gt; 实用程序也支持。有关更多信息，请参见 &lt;code&gt;twistd -h&lt;/code&gt; 和 &lt;code&gt;twistd web -h&lt;/code&gt; 。例如，使用来自 &lt;code&gt;myproject&lt;/code&gt; 的应用程序在前台8080端口上运行Twisted Web服务器：</target>
        </trans-unit>
        <trans-unit id="38ba707fd47e085f2d36a672c4b56ef31fb0e967" translate="yes" xml:space="preserve">
          <source>Typically you should not call this from your own code. A request context is automatically pushed by the &lt;a href=&quot;#flask.Flask.wsgi_app&quot;&gt;&lt;code&gt;wsgi_app()&lt;/code&gt;&lt;/a&gt; when handling a request. Use &lt;a href=&quot;#flask.Flask.test_request_context&quot;&gt;&lt;code&gt;test_request_context()&lt;/code&gt;&lt;/a&gt; to create an environment and context instead of this method.</source>
          <target state="translated">通常，您不应从自己的代码中调用它。处理请求时，&lt;a href=&quot;#flask.Flask.wsgi_app&quot;&gt; &lt;code&gt;wsgi_app()&lt;/code&gt; &lt;/a&gt;会自动推送请求上下文。使用&lt;a href=&quot;#flask.Flask.test_request_context&quot;&gt; &lt;code&gt;test_request_context()&lt;/code&gt; &lt;/a&gt;代替此方法来创建环境和上下文。</target>
        </trans-unit>
        <trans-unit id="0e2d9b0777a485c1276de0803c12a7d76fbc5c39" translate="yes" xml:space="preserve">
          <source>URL</source>
          <target state="translated">URL</target>
        </trans-unit>
        <trans-unit id="13b5d05532b07faf15d5bc8d6e70fc16c37d4210" translate="yes" xml:space="preserve">
          <source>URL Building</source>
          <target state="translated">构建URL</target>
        </trans-unit>
        <trans-unit id="6cfae7b9ef1be2e28c39d07fa02ec884c76b0aae" translate="yes" xml:space="preserve">
          <source>URL Route Registrations</source>
          <target state="translated">URL路线注册</target>
        </trans-unit>
        <trans-unit id="9c343fe26c823573d689b5e40d4a78b69116bc2a" translate="yes" xml:space="preserve">
          <source>URL building handles escaping of special characters and Unicode data transparently.</source>
          <target state="translated">构建URL可以透明地处理特殊字符和Unicode数据的转义。</target>
        </trans-unit>
        <trans-unit id="6598668044de3dea678621d0a802a16e2b0c07cc" translate="yes" xml:space="preserve">
          <source>URL processors are especially helpful when combined with blueprints. We will handle both application specific URL processors here as well as blueprint specifics.</source>
          <target state="translated">URL处理器在与蓝图结合时特别有用。我们将在这里处理特定应用的URL处理器以及蓝图的具体内容。</target>
        </trans-unit>
        <trans-unit id="00a7c4c398f08b618e6a7ccdfe4d69a79b0e20e8" translate="yes" xml:space="preserve">
          <source>URL scheme (http or https).</source>
          <target state="translated">URL方案(http或https)。</target>
        </trans-unit>
        <trans-unit id="69365c9980b58a3de2323899e7b2f4ac1597aae4" translate="yes" xml:space="preserve">
          <source>Unfortunately, there are many ways the security of a web application can be compromised. Flask protects you against one of the most common security problems of modern web applications: cross-site scripting (XSS). Unless you deliberately mark insecure HTML as secure, Flask and the underlying Jinja2 template engine have you covered. But there are many more ways to cause security problems.</source>
          <target state="translated">不幸的是,网络应用程序的安全性有许多种可能受到损害的方式。Flask 可以保护您免受现代 Web 应用程序中最常见的安全问题之一:跨站脚本 (XSS)。除非您故意将不安全的 HTML 标记为安全的,否则 Flask 和底层的 Jinja2 模板引擎会保护您。但是,还有更多的方法会导致安全问题。</target>
        </trans-unit>
        <trans-unit id="70041289ff0f2ea5e6c0475984bb067b7f0b8190" translate="yes" xml:space="preserve">
          <source>Unhandled Exceptions</source>
          <target state="translated">未处理的例外情况</target>
        </trans-unit>
        <trans-unit id="05af273276f2dfb2aaa6b648d23c61ed363494f6" translate="yes" xml:space="preserve">
          <source>Unicode in Flask</source>
          <target state="translated">Flask中的Unicode</target>
        </trans-unit>
        <trans-unit id="30106e63de01ae03ae4faf05cd18ee64e950a1bb" translate="yes" xml:space="preserve">
          <source>Uninstalled module:</source>
          <target state="translated">未安装的模块。</target>
        </trans-unit>
        <trans-unit id="023fc67bbfa08f8441012160fe5863ef8a339e26" translate="yes" xml:space="preserve">
          <source>Uninstalled package:</source>
          <target state="translated">卸载软件包。</target>
        </trans-unit>
        <trans-unit id="1e16c081c54d2cfa3e5302be199e16e680ddd1ff" translate="yes" xml:space="preserve">
          <source>Unique URLs / Redirection Behavior</source>
          <target state="translated">独特的URL/重定向行为</target>
        </trans-unit>
        <trans-unit id="e63c6a8059140dd4c872231e2c32dcf2c6762269" translate="yes" xml:space="preserve">
          <source>Unix Bash (Linux, Mac, etc.):</source>
          <target state="translated">Unix Bash(Linux、Mac等)。</target>
        </trans-unit>
        <trans-unit id="65d328122e54afef38b44beac4b291d86385f25e" translate="yes" xml:space="preserve">
          <source>Unix Bash, &lt;code&gt;venv/bin/activate&lt;/code&gt;:</source>
          <target state="translated">Unix Bash, &lt;code&gt;venv/bin/activate&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="d6556a94edb141c3dd2a3f95f1c09e23d76d9d1f" translate="yes" xml:space="preserve">
          <source>Unless customized, Jinja2 is configured by Flask as follows:</source>
          <target state="translated">除非自定义,否则Jinja2由Flask配置如下。</target>
        </trans-unit>
        <trans-unit id="8892faedefb1b4483300dec78974e0f4a4b9caeb" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;input_stream&lt;/code&gt; this stream is properly guarded that you can&amp;rsquo;t accidentally read past the length of the input. Werkzeug will internally always refer to this stream to read data which makes it possible to wrap this object with a stream that does filtering.</source>
          <target state="translated">与 &lt;code&gt;input_stream&lt;/code&gt; 不同，此流得到适当的保护，以确保您不会意外读取超出输入长度的内容。Werkzeug将始终在内部引用此流以读取数据，从而可以使用进行过滤的流来包装此对象。</target>
        </trans-unit>
        <trans-unit id="ff09f86459eb75462db6bc0d8857a8d0a8c27945" translate="yes" xml:space="preserve">
          <source>Unsure what that &lt;a href=&quot;../api/index#flask.g&quot;&gt;&lt;code&gt;g&lt;/code&gt;&lt;/a&gt; object is? It&amp;rsquo;s something in which you can store information for your own needs, check the documentation of that object (&lt;a href=&quot;../api/index#flask.g&quot;&gt;&lt;code&gt;g&lt;/code&gt;&lt;/a&gt;) and the &lt;a href=&quot;../patterns/sqlite3/index#sqlite3&quot;&gt;Using SQLite 3 with Flask&lt;/a&gt; for more information.</source>
          <target state="translated">不确定&lt;a href=&quot;../api/index#flask.g&quot;&gt; &lt;code&gt;g&lt;/code&gt; &lt;/a&gt;对象是什么？您可以在其中存储满足自己需要的信息，查看该对象的文档（&lt;a href=&quot;../api/index#flask.g&quot;&gt; &lt;code&gt;g&lt;/code&gt; &lt;/a&gt;）以及将&lt;a href=&quot;../patterns/sqlite3/index#sqlite3&quot;&gt;SQLite 3与Flask结合使用以&lt;/a&gt;获取更多信息。</target>
        </trans-unit>
        <trans-unit id="e63bd9653bea617f92b8ec34e72d810c6c75b909" translate="yes" xml:space="preserve">
          <source>Update the template context with some commonly used variables. This injects request, session, config and g into the template context as well as everything template context processors want to inject. Note that the as of Flask 0.6, the original values in the context will not be overridden if a context processor decides to return a value with the same key.</source>
          <target state="translated">用一些常用的变量更新模板上下文。这将把request、session、config和g注入到模板上下文中,以及一切模板上下文处理器想要注入的内容。请注意,从Flask 0.6开始,如果上下文处理器决定返回一个具有相同键的值,上下文中的原始值将不会被覆盖。</target>
        </trans-unit>
        <trans-unit id="f6cff59697edfb27029babcd747574af5e98c198" translate="yes" xml:space="preserve">
          <source>Updates a single user</source>
          <target state="translated">更新单个用户</target>
        </trans-unit>
        <trans-unit id="dedaad5adeb05d2c5ca2960618f1cfd3ec1be5ac" translate="yes" xml:space="preserve">
          <source>Updates the config like &lt;code&gt;update()&lt;/code&gt; ignoring items with non-upper keys.</source>
          <target state="translated">像 &lt;code&gt;update()&lt;/code&gt; 这样更新配置，忽略带有非上键的项目。</target>
        </trans-unit>
        <trans-unit id="cf76c75ba18ce13a14e013ebc65243cff6fdd377" translate="yes" xml:space="preserve">
          <source>Updates the values from the given object. An object can be of one of the following two types:</source>
          <target state="translated">更新给定对象的值。对象可以是以下两种类型之一。</target>
        </trans-unit>
        <trans-unit id="d5b529d89e45de502bf3f072f4116830049480c8" translate="yes" xml:space="preserve">
          <source>Updates the values in the config from a JSON file. This function behaves as if the JSON object was a dictionary and passed to the &lt;a href=&quot;#flask.Config.from_mapping&quot;&gt;&lt;code&gt;from_mapping()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">从JSON文件更新配置中的值。该函数的行为就好像JSON对象是一个字典并传递给&lt;a href=&quot;#flask.Config.from_mapping&quot;&gt; &lt;code&gt;from_mapping()&lt;/code&gt; &lt;/a&gt;函数一样。</target>
        </trans-unit>
        <trans-unit id="5d4ed68ff32f747c1cd8385a4f8eb1ee0640e590" translate="yes" xml:space="preserve">
          <source>Updates the values in the config from a Python file. This function behaves as if the file was imported as module with the &lt;a href=&quot;#flask.Config.from_object&quot;&gt;&lt;code&gt;from_object()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">从Python文件更新配置中的值。该函数的行为就像使用&lt;a href=&quot;#flask.Config.from_object&quot;&gt; &lt;code&gt;from_object()&lt;/code&gt; &lt;/a&gt;函数将文件作为模块导入一样。</target>
        </trans-unit>
        <trans-unit id="2605a6749654fbaf5ef309b0bae9ea3d105db9e4" translate="yes" xml:space="preserve">
          <source>Upgrading to Newer Releases</source>
          <target state="translated">升级到较新版本</target>
        </trans-unit>
        <trans-unit id="76c1699688a1d4877c098b406b7d0feb8e4c64d9" translate="yes" xml:space="preserve">
          <source>Upload Progress Bars</source>
          <target state="translated">上传进度条</target>
        </trans-unit>
        <trans-unit id="4d3c89ffcc90ad2ed133dab31e32cb6194549ac0" translate="yes" xml:space="preserve">
          <source>Upload a new &lt;code&gt;application.wsgi&lt;/code&gt; file to the server and the configuration file for the application (eg: &lt;code&gt;application.cfg&lt;/code&gt;)</source>
          <target state="translated">将新的 &lt;code&gt;application.wsgi&lt;/code&gt; 文件上传到服务器和该应用程序的配置文件（例如： &lt;code&gt;application.cfg&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="065bd038e566243f5546d7980c58a2be8219ade5" translate="yes" xml:space="preserve">
          <source>Uploaded files are stored in memory or at a temporary location on the filesystem. You can access those files by looking at the &lt;code&gt;files&lt;/code&gt; attribute on the request object. Each uploaded file is stored in that dictionary. It behaves just like a standard Python &lt;code&gt;file&lt;/code&gt; object, but it also has a &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.FileStorage.save&quot;&gt;&lt;code&gt;save()&lt;/code&gt;&lt;/a&gt; method that allows you to store that file on the filesystem of the server. Here is a simple example showing how that works:</source>
          <target state="translated">上载的文件存储在内存中或文件系统上的临时位置。您可以通过查看请求对象上的 &lt;code&gt;files&lt;/code&gt; 属性来访问这些文件。每个上载的文件都存储在该词典中。它的行为就像一个标准的Python &lt;code&gt;file&lt;/code&gt; 对象，但是它也具有&lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.FileStorage.save&quot;&gt; &lt;code&gt;save()&lt;/code&gt; &lt;/a&gt;方法，该方法可让您将该文件存储在服务器的文件系统中。这是一个简单的示例，说明其工作方式：</target>
        </trans-unit>
        <trans-unit id="943e26649b772824ba55708d2fd502f15bc84dd0" translate="yes" xml:space="preserve">
          <source>Uploading Files</source>
          <target state="translated">上传文件</target>
        </trans-unit>
        <trans-unit id="a4dc156f1123229f489136c1b679228a7e504a57" translate="yes" xml:space="preserve">
          <source>Usage in Views</source>
          <target state="translated">观点中的用法</target>
        </trans-unit>
        <trans-unit id="ff391bd34c07e4e0118919461472326cec1fdff6" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;../api/index#flask.Flask.shell_context_processor&quot;&gt;&lt;code&gt;shell_context_processor()&lt;/code&gt;&lt;/a&gt; to add other automatic imports.</source>
          <target state="translated">使用&lt;a href=&quot;../api/index#flask.Flask.shell_context_processor&quot;&gt; &lt;code&gt;shell_context_processor()&lt;/code&gt; &lt;/a&gt;添加其他自动导入。</target>
        </trans-unit>
        <trans-unit id="4932654a1f49f282baa9773400511de8d3b4e599" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;itsdangerous.TimedSerializer&lt;/code&gt; to sign and validate other cookie values (or any values that need secure signatures).</source>
          <target state="translated">使用 &lt;code&gt;itsdangerous.TimedSerializer&lt;/code&gt; 签名并验证其他cookie值（或需要安全签名的任何值）。</target>
        </trans-unit>
        <trans-unit id="9adcbc78a5d7f9ce777a41b5671c32e5ca319b93" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;with&lt;/code&gt; block to push the context, which will make &lt;a href=&quot;#flask.request&quot;&gt;&lt;code&gt;request&lt;/code&gt;&lt;/a&gt; point at the request for the created environment.</source>
          <target state="translated">使用 &lt;code&gt;with&lt;/code&gt; 块来推送上下文，这将使&lt;a href=&quot;#flask.request&quot;&gt; &lt;code&gt;request&lt;/code&gt; &lt;/a&gt;指向针对所创建环境的请求。</target>
        </trans-unit>
        <trans-unit id="4d2c0bbc423e751c6a1d36bb16286aa4a14756df" translate="yes" xml:space="preserve">
          <source>Use a tool like &lt;a href=&quot;https://www.fabfile.org/&quot;&gt;fabric&lt;/a&gt; in production to push code and configurations separately to the production server(s). For some details about how to do that, head over to the &lt;a href=&quot;../patterns/fabric/index#fabric-deployment&quot;&gt;Deploying with Fabric&lt;/a&gt; pattern.</source>
          <target state="translated">在生产中使用诸如&lt;a href=&quot;https://www.fabfile.org/&quot;&gt;Fabric之&lt;/a&gt;类的工具将代码和配置分别推送到生产服务器。有关如何执行此操作的一些详细信息，请转到&amp;ldquo;&lt;a href=&quot;../patterns/fabric/index#fabric-deployment&quot;&gt;使用结构部署&amp;rdquo;&lt;/a&gt;模式。</target>
        </trans-unit>
        <trans-unit id="953a7fc5851c23d07844eae60c7f119f3a233621" translate="yes" xml:space="preserve">
          <source>Use a virtual environment to manage the dependencies for your project, both in development and in production.</source>
          <target state="translated">使用虚拟环境来管理项目的依赖关系,无论是在开发中还是在生产中。</target>
        </trans-unit>
        <trans-unit id="9d056cf2bffbd094bc5cf3578463f963f5ee511d" translate="yes" xml:space="preserve">
          <source>Use an environment variable to switch between the configurations. This can be done from outside the Python interpreter and makes development and deployment much easier because you can quickly and easily switch between different configs without having to touch the code at all. If you are working often on different projects you can even create your own script for sourcing that activates a virtualenv and exports the development configuration for you.</source>
          <target state="translated">使用环境变量来切换配置。这可以从Python解释器外部完成,并且使开发和部署变得更加容易,因为你可以在不同的配置之间快速轻松地切换,而完全不用接触代码。如果你经常在不同的项目上工作,你甚至可以创建自己的脚本进行sourcing,激活virtualenv并为你导出开发配置。</target>
        </trans-unit>
        <trans-unit id="8804ea444a85e8d948b803f1d1d33e53900a14d9" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;../api/index#flask.Flask.route&quot;&gt;&lt;code&gt;route()&lt;/code&gt;&lt;/a&gt; decorator to bind a function to a URL.</source>
          <target state="translated">使用&lt;a href=&quot;../api/index#flask.Flask.route&quot;&gt; &lt;code&gt;route()&lt;/code&gt; &lt;/a&gt;装饰器将函数绑定到URL。</target>
        </trans-unit>
        <trans-unit id="5d0a34f0054bbd84451285011a5f14f90064ed8f" translate="yes" xml:space="preserve">
          <source>Use the class &lt;code&gt;objects&lt;/code&gt; attribute to make queries. A keyword argument looks for an equal value on the field.</source>
          <target state="translated">使用类 &lt;code&gt;objects&lt;/code&gt; 属性进行查询。关键字参数在字段上寻找相等的值。</target>
        </trans-unit>
        <trans-unit id="394dfd225f6710f4b932b0a967a9da46bf13c16d" translate="yes" xml:space="preserve">
          <source>Use this scheme for generating external URLs when not in a request context.</source>
          <target state="translated">当不在请求上下文中时,使用此方案生成外部URL。</target>
        </trans-unit>
        <trans-unit id="bbf8d7f6eaaa5f4d198daab7f63993733ff2d0ce" translate="yes" xml:space="preserve">
          <source>Used by session backends to determine if a &lt;code&gt;Set-Cookie&lt;/code&gt; header should be set for this session cookie for this response. If the session has been modified, the cookie is set. If the session is permanent and the &lt;code&gt;SESSION_REFRESH_EACH_REQUEST&lt;/code&gt; config is true, the cookie is always set.</source>
          <target state="translated">会话后端使用它来确定是否应为此响应的此会话cookie &lt;code&gt;Set-Cookie&lt;/code&gt; 标头。如果会话已被修改，则设置cookie。如果会话是永久会话，并且 &lt;code&gt;SESSION_REFRESH_EACH_REQUEST&lt;/code&gt; 配置为true，则始终设置cookie。</target>
        </trans-unit>
        <trans-unit id="fa1c92c5ba844472ba11e0f24b92c62160cfe538" translate="yes" xml:space="preserve">
          <source>Used to create the config attribute by the Flask constructor. The &lt;code&gt;instance_relative&lt;/code&gt; parameter is passed in from the constructor of Flask (there named &lt;code&gt;instance_relative_config&lt;/code&gt;) and indicates if the config should be relative to the instance path or the root path of the application.</source>
          <target state="translated">用于由Flask构造函数创建config属性。所述 &lt;code&gt;instance_relative&lt;/code&gt; 参数在从瓶（有命名的传入构造 &lt;code&gt;instance_relative_config&lt;/code&gt; ）和指示是否配置应该是相对于实例路径或应用程序的根路径。</target>
        </trans-unit>
        <trans-unit id="55d94821286572aa212d68fcce4d7f8a4c368304" translate="yes" xml:space="preserve">
          <source>Useful Functions and Classes</source>
          <target state="translated">有用的函数和类</target>
        </trans-unit>
        <trans-unit id="ea3159ece1b30f0a353cbfdd4607304374d1ab0d" translate="yes" xml:space="preserve">
          <source>Useful Internals</source>
          <target state="translated">有用的内部结构</target>
        </trans-unit>
        <trans-unit id="cdbcc85b59e2fa3bd5873c0d45ca407de2a4f1a5" translate="yes" xml:space="preserve">
          <source>User&amp;rsquo;s Guide</source>
          <target state="translated">用户手册</target>
        </trans-unit>
        <trans-unit id="c3f04f1f0861787d5cf121bd553081654560b497" translate="yes" xml:space="preserve">
          <source>Uses &lt;code&gt;SESSION_COOKIE_DOMAIN&lt;/code&gt; if it is configured, otherwise falls back to detecting the domain based on &lt;code&gt;SERVER_NAME&lt;/code&gt;.</source>
          <target state="translated">如果已配置，则使用 &lt;code&gt;SESSION_COOKIE_DOMAIN&lt;/code&gt; ，否则将退回以检测基于 &lt;code&gt;SERVER_NAME&lt;/code&gt; 的域。</target>
        </trans-unit>
        <trans-unit id="6d77efc15638aea2259c996f3e70e71b3ca59abd" translate="yes" xml:space="preserve">
          <source>Uses the &lt;code&gt;app2&lt;/code&gt; Flask instance in &lt;code&gt;hello&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;hello&lt;/code&gt; 中使用 &lt;code&gt;app2&lt;/code&gt; Flask实例。</target>
        </trans-unit>
        <trans-unit id="e690d0122228c9ccc000118916dfe735e74c8003" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;https://flask-sqlalchemy.palletsprojects.com/&quot;&gt;Flask-SQLAlchemy&lt;/a&gt;, as an example, you should not do something along those lines:</source>
          <target state="translated">以&lt;a href=&quot;https://flask-sqlalchemy.palletsprojects.com/&quot;&gt;Flask-SQLAlchemy&lt;/a&gt;为例，您不应遵循以下原则：</target>
        </trans-unit>
        <trans-unit id="aa651d27cac34cfd9ddfaaedf3f7be0d6a42bffc" translate="yes" xml:space="preserve">
          <source>Using Applications</source>
          <target state="translated">使用应用程序</target>
        </trans-unit>
        <trans-unit id="fa10774d0e271ce1daa32ba7d67741dff0dd4dd8" translate="yes" xml:space="preserve">
          <source>Using Extensions</source>
          <target state="translated">使用扩展部分</target>
        </trans-unit>
        <trans-unit id="8f3a39bf26744b168a92a9dec95f273aa851d694" translate="yes" xml:space="preserve">
          <source>Using Flask Extensions</source>
          <target state="translated">使用Flask扩展</target>
        </trans-unit>
        <trans-unit id="59171ad1690c758aab10d7ffbe8f77353f558b43" translate="yes" xml:space="preserve">
          <source>Using SQLite 3 with Flask</source>
          <target state="translated">在Flask中使用SQLite 3</target>
        </trans-unit>
        <trans-unit id="ab50f5e5004a55f81f6c1cc33064027f3f663005" translate="yes" xml:space="preserve">
          <source>Using URL Processors</source>
          <target state="translated">使用URL处理器</target>
        </trans-unit>
        <trans-unit id="68523b2455f2cfaa75da6c1dfdcffe84f7651754" translate="yes" xml:space="preserve">
          <source>Using _app_ctx_stack</source>
          <target state="translated">使用_app_ctx_stack</target>
        </trans-unit>
        <trans-unit id="54d0a04af554f5c6e119de6afe0d933caca31c6a" translate="yes" xml:space="preserve">
          <source>Using a document database like MongoDB is a common alternative to relational SQL databases. This pattern shows how to use &lt;a href=&quot;http://mongoengine.org&quot;&gt;MongoEngine&lt;/a&gt;, a document mapper library, to integrate with MongoDB.</source>
          <target state="translated">使用像MongoDB这样的文档数据库是关系SQL数据库的一种常见替代选择。此模式显示如何使用文档映射器库&lt;a href=&quot;http://mongoengine.org&quot;&gt;MongoEngine&lt;/a&gt;与MongoDB集成。</target>
        </trans-unit>
        <trans-unit id="a72a4a0d027f04806694ac19f72ac5da3ad06de2" translate="yes" xml:space="preserve">
          <source>Using the environment variables as described above is recommended. While it is possible to set &lt;a href=&quot;#ENV&quot;&gt;&lt;code&gt;ENV&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#DEBUG&quot;&gt;&lt;code&gt;DEBUG&lt;/code&gt;&lt;/a&gt; in your config or code, this is strongly discouraged. They can&amp;rsquo;t be read early by the &lt;code&gt;flask&lt;/code&gt; command, and some systems or extensions may have already configured themselves based on a previous value.</source>
          <target state="translated">建议使用如上所述的环境变量。虽然可以在配置或代码中设置&lt;a href=&quot;#ENV&quot;&gt; &lt;code&gt;ENV&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#DEBUG&quot;&gt; &lt;code&gt;DEBUG&lt;/code&gt; &lt;/a&gt;，但强烈建议不要这样做。 &lt;code&gt;flask&lt;/code&gt; 命令无法尽早读取它们，并且某些系统或扩展可能已经基于先前的值进行了配置。</target>
        </trans-unit>
        <trans-unit id="92a20b90af7e10a8cb54c4e913cfe44df2dc002e" translate="yes" xml:space="preserve">
          <source>Using this design pattern, no application-specific state is stored on the extension object, so one extension object can be used for multiple apps. For more information about the design of extensions refer to &lt;a href=&quot;https://flask.palletsprojects.com/en/1.1.x/extensiondev/&quot;&gt;Flask Extension Development&lt;/a&gt;.</source>
          <target state="translated">使用这种设计模式，扩展对象上没有存储特定于应用程序的状态，因此一个扩展对象可以用于多个应用程序。有关扩展设计的更多信息，请参见&lt;a href=&quot;https://flask.palletsprojects.com/en/1.1.x/extensiondev/&quot;&gt;Flask扩展开发&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bc1c502b56fb7ed2173d741dc07017b93a3f4930" translate="yes" xml:space="preserve">
          <source>Usually happens on programming errors or if the server is overloaded. A terribly good idea is to have a nice page there, because your application &lt;em&gt;will&lt;/em&gt; fail sooner or later (see also: &lt;a href=&quot;../../errorhandling/index#application-errors&quot;&gt;Application Errors&lt;/a&gt;).</source>
          <target state="translated">通常在编程错误或服务器过载时发生。一个非常好的主意是在那里有一个漂亮的页面，因为您的应用程序迟早&lt;em&gt;会&lt;/em&gt;失败（另请参见：&lt;a href=&quot;../../errorhandling/index#application-errors&quot;&gt;Application Errors&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="0f68bf97c736657b510dc0525880f20b4e753ec0" translate="yes" xml:space="preserve">
          <source>Usually it&amp;rsquo;s a bad idea to call this method without checking the content length first as a client could send dozens of megabytes or more to cause memory problems on the server.</source>
          <target state="translated">通常，在不首先检查内容长度的情况下调用此方法是一个坏主意，因为客户端可能会发送数十兆字节或更多兆字节，从而导致服务器上出现内存问题。</target>
        </trans-unit>
        <trans-unit id="ee3573f7a3179c375fa029a209dd8e1fd304efdd" translate="yes" xml:space="preserve">
          <source>Usually there are two ways to configure the server. Either just copy the &lt;code&gt;.cgi&lt;/code&gt; into a &lt;code&gt;cgi-bin&lt;/code&gt; (and use &lt;code&gt;mod_rewrite&lt;/code&gt; or something similar to rewrite the URL) or let the server point to the file directly.</source>
          <target state="translated">通常，有两种方法可以配置服务器。只需将 &lt;code&gt;.cgi&lt;/code&gt; 复制到 &lt;code&gt;cgi-bin&lt;/code&gt; 中（并使用 &lt;code&gt;mod_rewrite&lt;/code&gt; 或类似的方法重写URL），或者让服务器直接指向该文件。</target>
        </trans-unit>
        <trans-unit id="6c9db0f33e8df86a9e2fd4170047aa601d973ffc" translate="yes" xml:space="preserve">
          <source>Usually you create a &lt;a href=&quot;#flask.Flask&quot;&gt;&lt;code&gt;Flask&lt;/code&gt;&lt;/a&gt; instance in your main module or in the &lt;code&gt;__init__.py&lt;/code&gt; file of your package like this:</source>
          <target state="translated">通常，您可以在主模块或包的 &lt;code&gt;__init__.py&lt;/code&gt; 文件中创建&lt;a href=&quot;#flask.Flask&quot;&gt; &lt;code&gt;Flask&lt;/code&gt; &lt;/a&gt;实例，如下所示：</target>
        </trans-unit>
        <trans-unit id="1a254ac2d222d900e45034142431497e6c61b13b" translate="yes" xml:space="preserve">
          <source>Variable Rules</source>
          <target state="translated">可变规则</target>
        </trans-unit>
        <trans-unit id="b6b9c9cce79cbad858deab2deb4dde87f6d49c08" translate="yes" xml:space="preserve">
          <source>Variable arguments that are unknown to the target endpoint are appended to the generated URL as query arguments. If the value of a query argument is &lt;code&gt;None&lt;/code&gt;, the whole pair is skipped. In case blueprints are active you can shortcut references to the same blueprint by prefixing the local endpoint with a dot (&lt;code&gt;.&lt;/code&gt;).</source>
          <target state="translated">目标端点未知的变量参数将作为查询参数附加到生成的URL。如果查询参数的值为 &lt;code&gt;None&lt;/code&gt; ，那么将跳过整个对。如果蓝图处于活动状态，则可以通过在本地终结点前加点（ &lt;code&gt;.&lt;/code&gt; ）作为前缀来快速引用同一蓝图。</target>
        </trans-unit>
        <trans-unit id="4f7a411624b18078c29244d7d1ba19714505c9fc" translate="yes" xml:space="preserve">
          <source>Variable parts are passed to the view function as keyword arguments.</source>
          <target state="translated">变量部分作为关键字参数传递给视图函数。</target>
        </trans-unit>
        <trans-unit id="94fb3451dd394e4d83a6168ec1c8f7ea90fe2357" translate="yes" xml:space="preserve">
          <source>Variable parts in the route can be specified with angular brackets (&lt;code&gt;/user/&amp;lt;username&amp;gt;&lt;/code&gt;). By default a variable part in the URL accepts any string without a slash however a different converter can be specified as well by using &lt;code&gt;&amp;lt;converter:name&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">路径中的可变部分可以用尖括号（ &lt;code&gt;/user/&amp;lt;username&amp;gt;&lt;/code&gt; ）指定。默认情况下，URL中的可变部分接受不带斜杠的任何字符串，但是也可以使用 &lt;code&gt;&amp;lt;converter:name&amp;gt;&lt;/code&gt; 指定其他转换器。</target>
        </trans-unit>
        <trans-unit id="4081d2758e2b78ac5f9108f1b3c58568ba1f532e" translate="yes" xml:space="preserve">
          <source>Variables are not limited to values; a context processor can also make functions available to templates (since Python allows passing around functions):</source>
          <target state="translated">变量并不局限于值,上下文处理器也可以将函数提供给模板(因为Python允许传递函数)。</target>
        </trans-unit>
        <trans-unit id="a05176f61235d3c969d9c9934bdb3aec954de530" translate="yes" xml:space="preserve">
          <source>Variables set on the command line are used over those set in &lt;code&gt;.env&lt;/code&gt;, which are used over those set in &lt;code&gt;.flaskenv&lt;/code&gt;. &lt;code&gt;.flaskenv&lt;/code&gt; should be used for public variables, such as &lt;code&gt;FLASK_APP&lt;/code&gt;, while &lt;code&gt;.env&lt;/code&gt; should not be committed to your repository so that it can set private variables.</source>
          <target state="translated">在命令行上设置的变量被用来在这些集 &lt;code&gt;.env&lt;/code&gt; ，其中使用过的那些集 &lt;code&gt;.flaskenv&lt;/code&gt; 。 &lt;code&gt;.flaskenv&lt;/code&gt; 应该用于公共变量，例如 &lt;code&gt;FLASK_APP&lt;/code&gt; ，而 &lt;code&gt;.env&lt;/code&gt; 不应提交给您的存储库，以便它可以设置私有变量。</target>
        </trans-unit>
        <trans-unit id="b801ef48bde4544f0c6bc3b66af26f71700fc254" translate="yes" xml:space="preserve">
          <source>Various pieces of code can consume the request data and preprocess it. For instance JSON data ends up on the request object already read and processed, form data ends up there as well but goes through a different code path. This seems inconvenient when you want to calculate the checksum of the incoming request data. This is necessary sometimes for some APIs.</source>
          <target state="translated">各种代码可以消耗请求数据,并对其进行预处理。例如JSON数据最终会出现在已经被读取和处理的请求对象上,表单数据最终也会出现在那里,但要经过不同的代码路径。当你想计算传入请求数据的校验和时,这似乎很不方便。对于一些API来说,这有时是必要的。</target>
        </trans-unit>
        <trans-unit id="e3d0872296106e3000cffa85fb872e5af669a0e5" translate="yes" xml:space="preserve">
          <source>Version 0.1</source>
          <target state="translated">0.1版</target>
        </trans-unit>
        <trans-unit id="164ecd0042d125b561c75b19302a2c4b6d04645a" translate="yes" xml:space="preserve">
          <source>Version 0.10</source>
          <target state="translated">0.10版本</target>
        </trans-unit>
        <trans-unit id="fa2e2ff37b4ee75634af1d71a64a7181860dfb27" translate="yes" xml:space="preserve">
          <source>Version 0.10.1</source>
          <target state="translated">0.10.1版本</target>
        </trans-unit>
        <trans-unit id="d0b0f515ad64ca357140d4d452724c6892bbe084" translate="yes" xml:space="preserve">
          <source>Version 0.11</source>
          <target state="translated">0.11版本</target>
        </trans-unit>
        <trans-unit id="753aec77a66df488af72cbb036b532c40217773f" translate="yes" xml:space="preserve">
          <source>Version 0.11.1</source>
          <target state="translated">0.11.1版本</target>
        </trans-unit>
        <trans-unit id="4f4478af417dc964c1b38d03dea6990e6b59337d" translate="yes" xml:space="preserve">
          <source>Version 0.12</source>
          <target state="translated">0.12版本</target>
        </trans-unit>
        <trans-unit id="00294dfe7244c1c8a6ae8954ef35804a4f8f3d5c" translate="yes" xml:space="preserve">
          <source>Version 0.12.1</source>
          <target state="translated">0.12.1版本</target>
        </trans-unit>
        <trans-unit id="0426376b735575754e18cb94472bd40428064299" translate="yes" xml:space="preserve">
          <source>Version 0.12.2</source>
          <target state="translated">0.12.2版本</target>
        </trans-unit>
        <trans-unit id="ae08f6f45f11cde8465017f7bdc6358df900b06e" translate="yes" xml:space="preserve">
          <source>Version 0.12.3</source>
          <target state="translated">0.12.3版本</target>
        </trans-unit>
        <trans-unit id="ad89dbfb3304e3dff8542a4558fe1c6d6c78522f" translate="yes" xml:space="preserve">
          <source>Version 0.12.4</source>
          <target state="translated">0.12.4版本</target>
        </trans-unit>
        <trans-unit id="f1fd67cdc7fe9aecb65a0b4336efb55efbfe8a6e" translate="yes" xml:space="preserve">
          <source>Version 0.12.5</source>
          <target state="translated">0.12.5版本</target>
        </trans-unit>
        <trans-unit id="4c2611dcd833d75b55bc4f279b6d5537b8078f6e" translate="yes" xml:space="preserve">
          <source>Version 0.2</source>
          <target state="translated">0.2版本</target>
        </trans-unit>
        <trans-unit id="bd19664b1e20352cc8967604f9641063bf46ee3c" translate="yes" xml:space="preserve">
          <source>Version 0.3</source>
          <target state="translated">0.3版本</target>
        </trans-unit>
        <trans-unit id="c60fb31f26ed760097b45e6923562b1bdca9fee7" translate="yes" xml:space="preserve">
          <source>Version 0.3.1</source>
          <target state="translated">0.3.1版本</target>
        </trans-unit>
        <trans-unit id="d9478ca0c30be3f7ddcc6a3d34473ce1d43d002a" translate="yes" xml:space="preserve">
          <source>Version 0.4</source>
          <target state="translated">0.4版本</target>
        </trans-unit>
        <trans-unit id="5d2d8d5e17454d27c1958a6163d0f5311b955848" translate="yes" xml:space="preserve">
          <source>Version 0.5</source>
          <target state="translated">0.5版本</target>
        </trans-unit>
        <trans-unit id="4d89d286db5b379e1bb6d168b02f880eb33b6e5e" translate="yes" xml:space="preserve">
          <source>Version 0.5.1</source>
          <target state="translated">0.5.1版本</target>
        </trans-unit>
        <trans-unit id="729dcc0b43dc9aa3f192d5feba417eb1fdc7befd" translate="yes" xml:space="preserve">
          <source>Version 0.5.2</source>
          <target state="translated">0.5.2版本</target>
        </trans-unit>
        <trans-unit id="13469640a1fe1773fa321106c2212786331ada92" translate="yes" xml:space="preserve">
          <source>Version 0.6</source>
          <target state="translated">0.6版本</target>
        </trans-unit>
        <trans-unit id="235d0a7098aaa1f18850e8ba6bad0e8cc2d9951e" translate="yes" xml:space="preserve">
          <source>Version 0.6.1</source>
          <target state="translated">0.6.1版本</target>
        </trans-unit>
        <trans-unit id="207feffb493fb78e452158045a56535661eeb035" translate="yes" xml:space="preserve">
          <source>Version 0.7</source>
          <target state="translated">0.7版本</target>
        </trans-unit>
        <trans-unit id="67e76e75fb41fae561d77cc18f14d2ecd9eacddb" translate="yes" xml:space="preserve">
          <source>Version 0.7.1</source>
          <target state="translated">0.7.1版本</target>
        </trans-unit>
        <trans-unit id="74c92ba64e880fb8f1afdbaf1cd19da3e2022233" translate="yes" xml:space="preserve">
          <source>Version 0.7.2</source>
          <target state="translated">0.7.2版本</target>
        </trans-unit>
        <trans-unit id="9dd5ffb2f943217a769996eec5354793a3427344" translate="yes" xml:space="preserve">
          <source>Version 0.8</source>
          <target state="translated">0.8版本</target>
        </trans-unit>
        <trans-unit id="4a6ec3c768cfa78b196ed4d3a0018ca950193a31" translate="yes" xml:space="preserve">
          <source>Version 0.8.1</source>
          <target state="translated">0.8.1版本</target>
        </trans-unit>
        <trans-unit id="55985e570c95697b91d8cafbaae783a9f9588693" translate="yes" xml:space="preserve">
          <source>Version 0.9</source>
          <target state="translated">0.9版本</target>
        </trans-unit>
        <trans-unit id="084e67410714ed45209c2fc1829d3b5161821488" translate="yes" xml:space="preserve">
          <source>Version 1.0</source>
          <target state="translated">1.0版本</target>
        </trans-unit>
        <trans-unit id="afc7a8db48b4af8c0902573c671a14cb065e54bc" translate="yes" xml:space="preserve">
          <source>Version 1.0.1</source>
          <target state="translated">1.0.1版本</target>
        </trans-unit>
        <trans-unit id="4641cda3030bb07e688577979dc28ccecd7d91ff" translate="yes" xml:space="preserve">
          <source>Version 1.0.2</source>
          <target state="translated">1.0.2版本</target>
        </trans-unit>
        <trans-unit id="e90f48a372608ce366a5303d82f97d5851ec2fde" translate="yes" xml:space="preserve">
          <source>Version 1.0.3</source>
          <target state="translated">1.0.3版本</target>
        </trans-unit>
        <trans-unit id="af770758b7da72f3fa1cb83fa78633e916b2b798" translate="yes" xml:space="preserve">
          <source>Version 1.0.4</source>
          <target state="translated">1.0.4版本</target>
        </trans-unit>
        <trans-unit id="cc5415d679d743c1f626a7010ea6e9a819bfe776" translate="yes" xml:space="preserve">
          <source>Version 1.1.0</source>
          <target state="translated">1.1.0版本</target>
        </trans-unit>
        <trans-unit id="35b11926e0f83c641c3f635b76f318ee712f5b9c" translate="yes" xml:space="preserve">
          <source>Version 1.1.1</source>
          <target state="translated">1.1.1版本</target>
        </trans-unit>
        <trans-unit id="85375768918903e3572b17aa529198b1c65b5726" translate="yes" xml:space="preserve">
          <source>Version 1.1.2</source>
          <target state="translated">1.1.2版本</target>
        </trans-unit>
        <trans-unit id="05a0f0046d66eda8feb53e6944b9778e51c342fa" translate="yes" xml:space="preserve">
          <source>Version 1.1.x</source>
          <target state="translated">1.1.x版本</target>
        </trans-unit>
        <trans-unit id="afa179baae45b80856738215ce8eb1ee41f8da3b" translate="yes" xml:space="preserve">
          <source>Versions of Flask older than 0.11 used to have different ways to start the application. In short, the &lt;strong&gt;flask&lt;/strong&gt; command did not exist, and neither did &lt;strong&gt;python -m flask&lt;/strong&gt;. In that case you have two options: either upgrade to newer Flask versions or have a look at the &lt;a href=&quot;../server/index#server&quot;&gt;Development Server&lt;/a&gt; docs to see the alternative method for running a server.</source>
          <target state="translated">低于0.11的Flask版本过去曾以不同的方式启动应用程序。简而言之，&lt;strong&gt;flask&lt;/strong&gt;命令不存在，&lt;strong&gt;python -m flask&lt;/strong&gt;也不存在。在这种情况下，您有两个选择：升级到较新的Flask版本或查看&lt;a href=&quot;../server/index#server&quot;&gt;Development Server&lt;/a&gt;文档，以查看运行服务器的替代方法。</target>
        </trans-unit>
        <trans-unit id="a7c64b82a2412fa0f94a98767e1c4169eab860be" translate="yes" xml:space="preserve">
          <source>View Decorators</source>
          <target state="translated">查看装饰公司</target>
        </trans-unit>
        <trans-unit id="7c1c6b2905acb0b1e45734d020245d65938c5558" translate="yes" xml:space="preserve">
          <source>View Function Options</source>
          <target state="translated">查看功能选项</target>
        </trans-unit>
        <trans-unit id="2bb2e23c022063c95b22ddfed2740c9b08a4b03f" translate="yes" xml:space="preserve">
          <source>Vim: put &lt;code&gt;set enc=utf-8&lt;/code&gt; to your &lt;code&gt;.vimrc&lt;/code&gt; file.</source>
          <target state="translated">Vim：将 &lt;code&gt;set enc=utf-8&lt;/code&gt; 放入您的 &lt;code&gt;.vimrc&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="6f746bf843c7ebd4981d768101e7250eddd98ac6" translate="yes" xml:space="preserve">
          <source>Virtual environments</source>
          <target state="translated">虚拟环境</target>
        </trans-unit>
        <trans-unit id="8a94c4f48d0fc6f98d4e011608e99f0d9b58d791" translate="yes" xml:space="preserve">
          <source>Virtual environments are independent groups of Python libraries, one for each project. Packages installed for one project will not affect other projects or the operating system&amp;rsquo;s packages.</source>
          <target state="translated">虚拟环境是Python库的独立组，每个项目一组。为一个项目安装的软件包不会影响其他项目或操作系统的软件包。</target>
        </trans-unit>
        <trans-unit id="f15fa5845396d80011966aef2c45d5e0eb991ec8" translate="yes" xml:space="preserve">
          <source>Virtual environments have the advantage that they never install the required dependencies system wide so you have a better control over what is used where. If you want to use a virtual environment with mod_wsgi you have to modify your &lt;code&gt;.wsgi&lt;/code&gt; file slightly.</source>
          <target state="translated">虚拟环境的优势在于它们永远不会在整个系统上安装所需的依赖项，因此您可以更好地控制在何处使用了什么。如果要将虚拟环境与mod_wsgi一起使用，则必须稍微修改 &lt;code&gt;.wsgi&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="78aaa591cd24917ca6698492c64305ef7d62a886" translate="yes" xml:space="preserve">
          <source>Warn if cookie headers are larger than this many bytes. Defaults to &lt;code&gt;4093&lt;/code&gt;. Larger cookies may be silently ignored by browsers. Set to &lt;code&gt;0&lt;/code&gt; to disable the warning.</source>
          <target state="translated">如果cookie标头大于此字节数，则发出警告。默认为 &lt;code&gt;4093&lt;/code&gt; 。较大的cookie可能会被浏览器默默忽略。设置为 &lt;code&gt;0&lt;/code&gt; 以禁用警告。</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="2988833d3cf2aef3ff8b9e9f464e37662ffb04ee" translate="yes" xml:space="preserve">
          <source>Watch Extra Files with the Reloader</source>
          <target state="translated">用重装机观看额外的文件</target>
        </trans-unit>
        <trans-unit id="8685d8c928bed9e5c568a36068031b763aa68707" translate="yes" xml:space="preserve">
          <source>Watch Out</source>
          <target state="translated">小心点</target>
        </trans-unit>
        <trans-unit id="6f3b59c116abfcdbfb8d99f316f0fbe89662fda3" translate="yes" xml:space="preserve">
          <source>We begin by adding a tests directory under the application root. Then create a Python file to store our tests (&lt;code&gt;test_flaskr.py&lt;/code&gt;). When we format the filename like &lt;code&gt;test_*.py&lt;/code&gt;, it will be auto-discoverable by pytest.</source>
          <target state="translated">我们首先在应用程序根目录下添加一个tests目录。然后创建一个Python文件来存储我们的测试（ &lt;code&gt;test_flaskr.py&lt;/code&gt; ）。当我们像 &lt;code&gt;test_*.py&lt;/code&gt; 。py这样格式化文件名时，pytest会自动发现它。</target>
        </trans-unit>
        <trans-unit id="4b10601842ee67f4dca19afa4e98a24271f434f6" translate="yes" xml:space="preserve">
          <source>We can leave out the explicit mimetype and it will be guessed, but we may as well specify it to avoid the extra guessing, as it will always be the same.</source>
          <target state="translated">我们可以不使用显式的mimetype,它会被猜到,但我们不妨指定它,以避免额外的猜测,因为它总是一样的。</target>
        </trans-unit>
        <trans-unit id="8de3606754ff0c187695b35fc0dd6e228c76e67d" translate="yes" xml:space="preserve">
          <source>We recommend accessing URL parameters with &lt;code&gt;get&lt;/code&gt; or by catching the &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyError&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; because users might change the URL and presenting them a 400 bad request page in that case is not user friendly.</source>
          <target state="translated">我们建议您使用 &lt;code&gt;get&lt;/code&gt; 或捕获&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyError&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; 来&lt;/a&gt;访问URL参数，因为用户可能会更改URL并向他们显示400错误的请求页面，这种情况下用户不友好。</target>
        </trans-unit>
        <trans-unit id="528117f7383c0abb1248d2d81f9eb889a6b611c0" translate="yes" xml:space="preserve">
          <source>We recommend using the latest version of Python 3. Flask supports Python 3.5 and newer, Python 2.7, and PyPy.</source>
          <target state="translated">我们建议使用最新版本的Python 3。Flask支持Python 3.5和更新版本,Python 2.7和PyPy。</target>
        </trans-unit>
        <trans-unit id="b1ef0d837e5ffb749ddec2d5ba2103e141a7ac43" translate="yes" xml:space="preserve">
          <source>We should also test that adding messages works. Add a new test function like this:</source>
          <target state="translated">我们还应该测试添加消息是否有效。添加一个新的测试函数,像这样。</target>
        </trans-unit>
        <trans-unit id="926c5dab40b0fcc69f6e1f83fb9d6997d771be34" translate="yes" xml:space="preserve">
          <source>We then use the &lt;a href=&quot;../api/index#flask.Flask.route&quot;&gt;&lt;code&gt;route()&lt;/code&gt;&lt;/a&gt; decorator to tell Flask what URL should trigger our function.</source>
          <target state="translated">然后，我们使用&lt;a href=&quot;../api/index#flask.Flask.route&quot;&gt; &lt;code&gt;route()&lt;/code&gt; &lt;/a&gt;装饰器告诉Flask哪个URL应该触发我们的函数。</target>
        </trans-unit>
        <trans-unit id="f3bd4d70f70c09ab7a8affa842636aed131b2e58" translate="yes" xml:space="preserve">
          <source>Web APIs are often working very closely with HTTP verbs so it makes a lot of sense to implement such an API based on the &lt;a href=&quot;../api/index#flask.views.MethodView&quot;&gt;&lt;code&gt;MethodView&lt;/code&gt;&lt;/a&gt;. That said, you will notice that the API will require different URL rules that go to the same method view most of the time. For instance consider that you are exposing a user object on the web:</source>
          <target state="translated">Web API通常与HTTP动词紧密配合，因此在&lt;a href=&quot;../api/index#flask.views.MethodView&quot;&gt; &lt;code&gt;MethodView&lt;/code&gt; 的&lt;/a&gt;基础上实现这样的API非常有意义。就是说，您会注意到API将需要不同的URL规则，这些URL规则大多数时候都进入相同的方法视图。例如，假设您要在网络上公开一个用户对象：</target>
        </trans-unit>
        <trans-unit id="ae3e635e8da96ed44d6d3f4f2134f5d110192f88" translate="yes" xml:space="preserve">
          <source>Web applications use different HTTP methods when accessing URLs. You should familiarize yourself with the HTTP methods as you work with Flask. By default, a route only answers to &lt;code&gt;GET&lt;/code&gt; requests. You can use the &lt;code&gt;methods&lt;/code&gt; argument of the &lt;a href=&quot;../api/index#flask.Flask.route&quot;&gt;&lt;code&gt;route()&lt;/code&gt;&lt;/a&gt; decorator to handle different HTTP methods.</source>
          <target state="translated">Web应用程序在访问URL时使用不同的HTTP方法。在使用Flask时，您应该熟悉HTTP方法。默认情况下，路由仅响应 &lt;code&gt;GET&lt;/code&gt; 请求。您可以使用&lt;a href=&quot;../api/index#flask.Flask.route&quot;&gt; &lt;code&gt;route()&lt;/code&gt; &lt;/a&gt;装饰器的 &lt;code&gt;methods&lt;/code&gt; 参数来处理不同的HTTP方法。</target>
        </trans-unit>
        <trans-unit id="01d4c08a27b0f4434d689f0c5a387519db91702b" translate="yes" xml:space="preserve">
          <source>Web applications usually face all kinds of security problems and it&amp;rsquo;s very hard to get everything right. Flask tries to solve a few of these things for you, but there are a couple more you have to take care of yourself.</source>
          <target state="translated">Web应用程序通常会遇到各种安全问题，很难正确解决所有问题。Flask会尝试为您解决其中的一些问题，但是您还需要照顾好自己。</target>
        </trans-unit>
        <trans-unit id="dd705fd9d6238c9288757a4cd3c55bec155ca90f" translate="yes" xml:space="preserve">
          <source>Welcome to Flask</source>
          <target state="translated">欢迎来到Flask</target>
        </trans-unit>
        <trans-unit id="884756b6fe3af804f25191c3cb6413ffd4e35ea4" translate="yes" xml:space="preserve">
          <source>Welcome to Flask&amp;rsquo;s documentation. Get started with &lt;a href=&quot;installation/index#installation&quot;&gt;Installation&lt;/a&gt; and then get an overview with the &lt;a href=&quot;quickstart/index#quickstart&quot;&gt;Quickstart&lt;/a&gt;. There is also a more detailed &lt;a href=&quot;https://flask.palletsprojects.com/en/1.1.x/tutorial/#tutorial&quot;&gt;Tutorial&lt;/a&gt; that shows how to create a small but complete application with Flask. Common patterns are described in the &lt;a href=&quot;patterns/index#patterns&quot;&gt;Patterns for Flask&lt;/a&gt; section. The rest of the docs describe each component of Flask in detail, with a full reference in the &lt;a href=&quot;api/index#api&quot;&gt;API&lt;/a&gt; section.</source>
          <target state="translated">欢迎使用Flask的文档。开始&lt;a href=&quot;installation/index#installation&quot;&gt;安装&lt;/a&gt;，然后使用&lt;a href=&quot;quickstart/index#quickstart&quot;&gt;快速入门&lt;/a&gt;进行概述。还有一个更详细的&lt;a href=&quot;https://flask.palletsprojects.com/en/1.1.x/tutorial/#tutorial&quot;&gt;教程&lt;/a&gt;，显示了如何使用Flask创建一个小而完整的应用程序。常见的模式在&amp;ldquo;&lt;a href=&quot;patterns/index#patterns&quot;&gt;烧瓶&lt;/a&gt;的模式&amp;rdquo;部分中进行了描述。其余文档详细描述了Flask的每个组件，并在&lt;a href=&quot;api/index#api&quot;&gt;API&lt;/a&gt;部分中提供了完整参考。</target>
        </trans-unit>
        <trans-unit id="dfa660bfef7f591b7517f18760d971917ecae5b5" translate="yes" xml:space="preserve">
          <source>Werkzeug</source>
          <target state="translated">Werkzeug</target>
        </trans-unit>
        <trans-unit id="634b3fe7f14ea67e329b5f26cc3087fcd651862e" translate="yes" xml:space="preserve">
          <source>Werkzeug documentation</source>
          <target state="translated">工具文件</target>
        </trans-unit>
        <trans-unit id="575c73b8eee979fa1e1115330178dff49867d45a" translate="yes" xml:space="preserve">
          <source>Werkzeug logs basic request/response information to the &lt;code&gt;'werkzeug'&lt;/code&gt; logger. If the root logger has no handlers configured, Werkzeug adds a &lt;a href=&quot;https://docs.python.org/3/library/logging.handlers.html#logging.StreamHandler&quot;&gt;&lt;code&gt;StreamHandler&lt;/code&gt;&lt;/a&gt; to its logger.</source>
          <target state="translated">Werkzeug将基本的请求/响应信息记录到 &lt;code&gt;'werkzeug'&lt;/code&gt; 记录器中。如果根记录器未配置任何处理程序，则Werkzeug将&lt;a href=&quot;https://docs.python.org/3/library/logging.handlers.html#logging.StreamHandler&quot;&gt; &lt;code&gt;StreamHandler&lt;/code&gt; &lt;/a&gt;添加到其记录器中。</target>
        </trans-unit>
        <trans-unit id="5c2ad382fdcac2d37e83dd6d7afea777fe527b03" translate="yes" xml:space="preserve">
          <source>What Flask is, What Flask is Not</source>
          <target state="translated">什么是Flask,什么不是Flask?</target>
        </trans-unit>
        <trans-unit id="a993d0df079902f1680cbe816d0d863c1aa505a5" translate="yes" xml:space="preserve">
          <source>What are signals? Signals help you decouple applications by sending notifications when actions occur elsewhere in the core framework or another Flask extensions. In short, signals allow certain senders to notify subscribers that something happened.</source>
          <target state="translated">什么是信号?当核心框架或其他 Flask 扩展中的其他地方发生动作时,信号通过发送通知帮助您解耦应用程序。简而言之,信号允许某些发送者通知订阅者发生了什么。</target>
        </trans-unit>
        <trans-unit id="045f9ba546b476d3b53fb9ccf7cf2bce7bcd3a69" translate="yes" xml:space="preserve">
          <source>What did we gain from this? Now we can restructure the application a bit into multiple modules. The only thing you have to remember is the following quick checklist:</source>
          <target state="translated">我们从中获得了什么?现在,我们可以将应用程序重组一下,变成多个模块。你唯一要记住的是下面的快速检查表。</target>
        </trans-unit>
        <trans-unit id="3bc6248c3f391b2bec2b67a4e4a3d36d4afe4a64" translate="yes" xml:space="preserve">
          <source>What does &amp;ldquo;micro&amp;rdquo; mean?</source>
          <target state="translated">&amp;ldquo;微&amp;rdquo;是什么意思？</target>
        </trans-unit>
        <trans-unit id="fd82fce5e00af1121754a6b181ab0e8514c89b7c" translate="yes" xml:space="preserve">
          <source>What does &amp;ldquo;strict&amp;rdquo; mean?</source>
          <target state="translated">&amp;ldquo;严格&amp;rdquo;是什么意思？</target>
        </trans-unit>
        <trans-unit id="7bc7cc52960852df2d37be00de9570bf0ff3ecfc" translate="yes" xml:space="preserve">
          <source>What does this mean for you? If you have a macro you want to import, that needs to access the request object you have two possibilities:</source>
          <target state="translated">这对你意味着什么?如果你有一个你想导入的宏,需要访问请求对象,你有两种可能。</target>
        </trans-unit>
        <trans-unit id="64d455b67b4ac38c1aa7206eea4f18cdab1c8c95" translate="yes" xml:space="preserve">
          <source>What environment the app is running in. Flask and extensions may enable behaviors based on the environment, such as enabling debug mode. The &lt;a href=&quot;../api/index#flask.Flask.env&quot;&gt;&lt;code&gt;env&lt;/code&gt;&lt;/a&gt; attribute maps to this config key. This is set by the &lt;code id=&quot;index-5&quot;&gt;FLASK_ENV&lt;/code&gt; environment variable and may not behave as expected if set in code.</source>
          <target state="translated">应用程序在什么环境中运行。Flask和扩展程序可能会根据环境启用行为，例如启用调试模式。该&lt;a href=&quot;../api/index#flask.Flask.env&quot;&gt; &lt;code&gt;env&lt;/code&gt; &lt;/a&gt;属性映射到这个配置的关键。这是由 &lt;code id=&quot;index-5&quot;&gt;FLASK_ENV&lt;/code&gt; 环境变量设置的，如果在代码中进行设置，则可能无法按预期方式运行。</target>
        </trans-unit>
        <trans-unit id="786bbf029ba7cc03bad69f95f9eda65970237493" translate="yes" xml:space="preserve">
          <source>What environment the app is running in. Flask and extensions may enable behaviors based on the environment, such as enabling debug mode. This maps to the &lt;a href=&quot;../config/index#ENV&quot;&gt;&lt;code&gt;ENV&lt;/code&gt;&lt;/a&gt; config key. This is set by the &lt;code id=&quot;index-0&quot;&gt;FLASK_ENV&lt;/code&gt; environment variable and may not behave as expected if set in code.</source>
          <target state="translated">应用程序在什么环境中运行。Flask和扩展程序可能会根据环境启用行为，例如启用调试模式。这映射到&lt;a href=&quot;../config/index#ENV&quot;&gt; &lt;code&gt;ENV&lt;/code&gt; &lt;/a&gt;配置键。这是由 &lt;code id=&quot;index-0&quot;&gt;FLASK_ENV&lt;/code&gt; 环境变量设置的，如果在代码中进行设置，则可能无法按预期方式运行。</target>
        </trans-unit>
        <trans-unit id="4ddbbecf0cf7d796fb1916c11312610804fe7f8e" translate="yes" xml:space="preserve">
          <source>What happens if the key does not exist in the &lt;code&gt;form&lt;/code&gt; attribute? In that case a special &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyError&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; is raised. You can catch it like a standard &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyError&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; but if you don&amp;rsquo;t do that, a HTTP 400 Bad Request error page is shown instead. So for many situations you don&amp;rsquo;t have to deal with that problem.</source>
          <target state="translated">如果该键不存在于 &lt;code&gt;form&lt;/code&gt; 属性中，该怎么办？在这种情况下，会引发特殊的&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyError&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; &lt;/a&gt;。您可以像标准&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyError&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; &lt;/a&gt;一样捕获它，但如果不这样做，则会显示HTTP 400 Bad Request错误页面。因此，在许多情况下，您不必处理该问题。</target>
        </trans-unit>
        <trans-unit id="f799ff46e731165b67fccc952dd8e58a2d01d96e" translate="yes" xml:space="preserve">
          <source>What happens if you want to modify the response at a point where the response does not exist yet? A common example for that would be a &lt;a href=&quot;../../api/index#flask.Flask.before_request&quot;&gt;&lt;code&gt;before_request()&lt;/code&gt;&lt;/a&gt; callback that wants to set a cookie on the response object.</source>
          <target state="translated">如果您要在尚不存在响应的位置修改响应，该怎么办？一个常见的示例是&lt;a href=&quot;../../api/index#flask.Flask.before_request&quot;&gt; &lt;code&gt;before_request()&lt;/code&gt; &lt;/a&gt;回调，该回调要在响应对象上设置cookie。</target>
        </trans-unit>
        <trans-unit id="ef34bd40210e7c78bf7dd9459e679f6fd77a1418" translate="yes" xml:space="preserve">
          <source>What is very popular in the Django world is to make the import explicit in the config file by adding &lt;code&gt;from yourapplication.default_settings
import *&lt;/code&gt; to the top of the file and then overriding the changes by hand. You could also inspect an environment variable like &lt;code&gt;YOURAPPLICATION_MODE&lt;/code&gt; and set that to &lt;code&gt;production&lt;/code&gt;, &lt;code&gt;development&lt;/code&gt; etc and import different hard-coded files based on that.</source>
          <target state="translated">在Django世界中，非常流行的是通过 &lt;code&gt;from yourapplication.default_settings import *&lt;/code&gt; 添加到文件顶部，然后手动覆盖所做的更改来使导入在配置文件中显式。您还可以检查环境变量（例如 &lt;code&gt;YOURAPPLICATION_MODE&lt;/code&gt; )并将其设置为 &lt;code&gt;production&lt;/code&gt; ， &lt;code&gt;development&lt;/code&gt; 等，并根据该变量导入不同的硬编码文件。</target>
        </trans-unit>
        <trans-unit id="3adae2193d51366a5aedd1ef9204593ef9e14d07" translate="yes" xml:space="preserve">
          <source>What problem does a virtual environment solve? The more Python projects you have, the more likely it is that you need to work with different versions of Python libraries, or even Python itself. Newer versions of libraries for one project can break compatibility in another project.</source>
          <target state="translated">虚拟环境能解决什么问题?你的Python项目越多,你就越有可能需要使用不同版本的Python库,甚至Python本身。一个项目的新版本库可能会破坏另一个项目的兼容性。</target>
        </trans-unit>
        <trans-unit id="dc8f062d14647fc9ca8040ce266b9e9356704932" translate="yes" xml:space="preserve">
          <source>What should be used?</source>
          <target state="translated">应该用什么?</target>
        </trans-unit>
        <trans-unit id="c91c3c01668a3837994712b84720447b327a76c8" translate="yes" xml:space="preserve">
          <source>What to do if the Server does not Start</source>
          <target state="translated">如果服务器无法启动该怎么办</target>
        </trans-unit>
        <trans-unit id="69878fc09a7386f79c2e427381836112d91587d9" translate="yes" xml:space="preserve">
          <source>What&amp;rsquo;s important here is is that &lt;code&gt;__module__&lt;/code&gt; and &lt;code&gt;__name__&lt;/code&gt; are properly set. This is used by Flask internally to figure out how to name the URL rules in case you don&amp;rsquo;t provide a name for the rule yourself.</source>
          <target state="translated">这里重要的是正确设置了 &lt;code&gt;__module__&lt;/code&gt; 和 &lt;code&gt;__name__&lt;/code&gt; 。Flask在内部使用它来弄清楚如何命名URL规则，以防您自己未提供规则名称的情况。</target>
        </trans-unit>
        <trans-unit id="51da398a77747873e16493c2bd3f1d127173785c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;ctx.pop()&lt;/code&gt; is executed in the above example, the teardown functions are called just before the app context moves from the stack of active contexts. This becomes relevant if you are using such constructs in tests.</source>
          <target state="translated">当 &lt;code&gt;ctx.pop()&lt;/code&gt; 在上面的例子中被执行时，拆卸功能刚刚从有效上下文的堆栈中的应用程序上下文动作前调用。如果您在测试中使用此类构造，则这将变得很重要。</target>
        </trans-unit>
        <trans-unit id="2f3f8338954d6124db4f9ce27d351b75068a3b9d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;ctx.pop()&lt;/code&gt; is executed in the above example, the teardown functions are called just before the request context moves from the stack of active contexts. This becomes relevant if you are using such constructs in tests.</source>
          <target state="translated">当 &lt;code&gt;ctx.pop()&lt;/code&gt; 在上面的例子中被执行时，拆卸功能刚刚从有效上下文的堆栈中的请求上下文移动之前调用。如果您在测试中使用此类构造，则这将变得很重要。</target>
        </trans-unit>
        <trans-unit id="7220c06f573a7a83a77b73f3b5239b51d394689e" translate="yes" xml:space="preserve">
          <source>When a Flask application begins handling a request, it pushes a request context, which also pushes an &lt;a href=&quot;../appcontext/index&quot;&gt;The Application Context&lt;/a&gt;. When the request ends it pops the request context then the application context.</source>
          <target state="translated">当Flask应用程序开始处理请求时，它会推送一个请求上下文，这也会推送一个&lt;a href=&quot;../appcontext/index&quot;&gt;The Application Context&lt;/a&gt;。当请求结束时，它会弹出请求上下文，然后弹出应用程序上下文。</target>
        </trans-unit>
        <trans-unit id="305dba4e121167b6f41e362fa7726df729eaa541" translate="yes" xml:space="preserve">
          <source>When a teardown function was called because of an exception it will be passed an error object.</source>
          <target state="translated">当一个拆分函数因为异常而被调用时,它将被传递一个错误对象。</target>
        </trans-unit>
        <trans-unit id="f08c489eb6af656bb1498c12342bf4f2c7271f36" translate="yes" xml:space="preserve">
          <source>When a teardown function was called because of an unhandled exception it will be passed an error object. If an &lt;a href=&quot;#flask.Flask.errorhandler&quot;&gt;&lt;code&gt;errorhandler()&lt;/code&gt;&lt;/a&gt; is registered, it will handle the exception and the teardown will not receive it.</source>
          <target state="translated">当由于未处理的异常而调用了拆解函数时，它将被传递一个错误对象。如果注册了&lt;a href=&quot;#flask.Flask.errorhandler&quot;&gt; &lt;code&gt;errorhandler()&lt;/code&gt; &lt;/a&gt;，它将处理该异常，而拆解将不会收到该异常。</target>
        </trans-unit>
        <trans-unit id="d46c1cd4ca4c6228133ce107516406cfd6cfbd50" translate="yes" xml:space="preserve">
          <source>When an exception is caught by Flask while handling a request, it is first looked up by code. If no handler is registered for the code, it is looked up by its class hierarchy; the most specific handler is chosen. If no handler is registered, &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/exceptions/#werkzeug.exceptions.HTTPException&quot;&gt;&lt;code&gt;HTTPException&lt;/code&gt;&lt;/a&gt; subclasses show a generic message about their code, while other exceptions are converted to a generic 500 Internal Server Error.</source>
          <target state="translated">当Flask在处理请求时捕获到异常时，首先将通过代码对其进行查找。如果没有为该代码注册处理程序，则按其类层次结构查找该处理程序。选择最具体的处理程序。如果未注册任何处理程序，则&lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/exceptions/#werkzeug.exceptions.HTTPException&quot;&gt; &lt;code&gt;HTTPException&lt;/code&gt; &lt;/a&gt;子类将显示有关其代码的通用消息，而其他异常将转换为通用500 Internal Server Error。</target>
        </trans-unit>
        <trans-unit id="73bbe6a85029094e364cf88273d8175952c1ac75" translate="yes" xml:space="preserve">
          <source>When calling an application factory, if the factory takes an argument named &lt;code&gt;script_info&lt;/code&gt;, then the &lt;a href=&quot;../api/index#flask.cli.ScriptInfo&quot;&gt;&lt;code&gt;ScriptInfo&lt;/code&gt;&lt;/a&gt; instance is passed as a keyword argument. If the application factory takes only one argument and no parentheses follow the factory name, the &lt;a href=&quot;../api/index#flask.cli.ScriptInfo&quot;&gt;&lt;code&gt;ScriptInfo&lt;/code&gt;&lt;/a&gt; instance is passed as a positional argument. If parentheses follow the factory name, their contents are parsed as Python literals and passes as arguments to the function. This means that strings must still be in quotes.</source>
          <target state="translated">调用应用程序工厂时，如果工厂采用名为 &lt;code&gt;script_info&lt;/code&gt; 的参数，则&lt;a href=&quot;../api/index#flask.cli.ScriptInfo&quot;&gt; &lt;code&gt;ScriptInfo&lt;/code&gt; &lt;/a&gt;实例将作为关键字参数传递。如果应用程序工厂仅接受一个参数，并且工厂名称后没有括号，则&lt;a href=&quot;../api/index#flask.cli.ScriptInfo&quot;&gt; &lt;code&gt;ScriptInfo&lt;/code&gt; &lt;/a&gt;实例将作为位置参数传递。如果括号跟随工厂名称，则其内容将解析为Python文字并将其作为参数传递给该函数。这意味着字符串必须仍然用引号引起来。</target>
        </trans-unit>
        <trans-unit id="1fbee1cd7d8e91959210444b6c7cf1ffd6ad35b6" translate="yes" xml:space="preserve">
          <source>When data is changed, this is set to &lt;code&gt;True&lt;/code&gt;. Only the session dictionary itself is tracked; if the session contains mutable data (for example a nested dict) then this must be set to &lt;code&gt;True&lt;/code&gt; manually when modifying that data. The session cookie will only be written to the response if this is &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">更改数据后，将其设置为 &lt;code&gt;True&lt;/code&gt; 。仅跟踪会话字典本身；如果会话包含可变数据（例如嵌套字典），则在修改该数据时必须将其手动设置为 &lt;code&gt;True&lt;/code&gt; 。如果为 &lt;code&gt;True&lt;/code&gt; ,则仅将会话cookie写入响应。</target>
        </trans-unit>
        <trans-unit id="eb684fd2f73217d4e0fcb89d9d4cbddadfdd0f4b" translate="yes" xml:space="preserve">
          <source>When handling a request, the application context is popped after the request context. See &lt;a href=&quot;#flask.Flask.do_teardown_request&quot;&gt;&lt;code&gt;do_teardown_request()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">处理请求时，在请求上下文之后弹出应用程序上下文。参见&lt;a href=&quot;#flask.Flask.do_teardown_request&quot;&gt; &lt;code&gt;do_teardown_request()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c27b7e4685a13b92c05481524906313b57e4ee31" translate="yes" xml:space="preserve">
          <source>When in Doubt, Run Manually</source>
          <target state="translated">疑惑时,请手动运行</target>
        </trans-unit>
        <trans-unit id="06a42a02f9638b807bbf1e063932e1f28e1d2a94" translate="yes" xml:space="preserve">
          <source>When it comes to connecting a template engine with an application or framework there is more than just rendering templates. For instance, Flask uses Jinja2&amp;rsquo;s extensive autoescaping support. Also it provides ways to access macros from Jinja2 templates.</source>
          <target state="translated">在将模板引擎与应用程序或框架连接时，不仅仅是渲染模板。例如，Flask使用Jinja2的广泛的自动转义支持。它还提供了从Jinja2模板访问宏的方法。</target>
        </trans-unit>
        <trans-unit id="8238a66d94dec84e7f35758961f6dd77232b7462" translate="yes" xml:space="preserve">
          <source>When running the application on a remote server for production, you probably won&amp;rsquo;t be looking at the log messages very often. The WSGI server will probably send log messages to a file, and you&amp;rsquo;ll only check that file if a user tells you something went wrong.</source>
          <target state="translated">在用于生产的远程服务器上运行应用程序时，您可能不会经常查看日志消息。WSGI服务器可能会将日志消息发送到一个文件，并且只有在用户告诉您出了什么问题时，您才检查该文件。</target>
        </trans-unit>
        <trans-unit id="2a00678214872af6bc61ee5b93852bad37e06926" translate="yes" xml:space="preserve">
          <source>When serving files, set the &lt;code&gt;X-Sendfile&lt;/code&gt; header instead of serving the data with Flask. Some web servers, such as Apache, recognize this and serve the data more efficiently. This only makes sense when using such a server.</source>
          <target state="translated">提供文件时，请设置 &lt;code&gt;X-Sendfile&lt;/code&gt; 标头，而不要使用Flask提供数据。某些Web服务器（例如Apache）可以识别出这种情况并更有效地提供数据。仅在使用此类服务​​器时才有意义。</target>
        </trans-unit>
        <trans-unit id="5d32404dba314b02f2819112bc7559a4b773d6ce" translate="yes" xml:space="preserve">
          <source>When serving files, set the cache control max age to this number of seconds. Can either be a &lt;a href=&quot;https://docs.python.org/3/library/datetime.html#datetime.timedelta&quot;&gt;&lt;code&gt;datetime.timedelta&lt;/code&gt;&lt;/a&gt; or an &lt;code&gt;int&lt;/code&gt;. Override this value on a per-file basis using &lt;a href=&quot;../api/index#flask.Flask.get_send_file_max_age&quot;&gt;&lt;code&gt;get_send_file_max_age()&lt;/code&gt;&lt;/a&gt; on the application or blueprint.</source>
          <target state="translated">提供文件时，将高速缓存控件的最大使用期限设置为该秒数。可以是&lt;a href=&quot;https://docs.python.org/3/library/datetime.html#datetime.timedelta&quot;&gt; &lt;code&gt;datetime.timedelta&lt;/code&gt; &lt;/a&gt;或 &lt;code&gt;int&lt;/code&gt; 。使用应用程序或蓝图上的&lt;a href=&quot;../api/index#flask.Flask.get_send_file_max_age&quot;&gt; &lt;code&gt;get_send_file_max_age()&lt;/code&gt; 逐个&lt;/a&gt;文件覆盖此值。</target>
        </trans-unit>
        <trans-unit id="7fd91765b27cdfadd4433d4db1da78ed28b926e6" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;../api/index#flask.Flask&quot;&gt;&lt;code&gt;Flask&lt;/code&gt;&lt;/a&gt; application handles a request, it creates a &lt;a href=&quot;../api/index#flask.Request&quot;&gt;&lt;code&gt;Request&lt;/code&gt;&lt;/a&gt; object based on the environment it received from the WSGI server. Because a &lt;em&gt;worker&lt;/em&gt; (thread, process, or coroutine depending on the server) handles only one request at a time, the request data can be considered global to that worker during that request. Flask uses the term &lt;em&gt;context local&lt;/em&gt; for this.</source>
          <target state="translated">当&lt;a href=&quot;../api/index#flask.Flask&quot;&gt; &lt;code&gt;Flask&lt;/code&gt; &lt;/a&gt;应用程序处理请求时，它会根据从WSGI服务器接收到的环境创建一个&lt;a href=&quot;../api/index#flask.Request&quot;&gt; &lt;code&gt;Request&lt;/code&gt; &lt;/a&gt;对象。因为一个&lt;em&gt;工作程序&lt;/em&gt;（线程，进程或协程，取决于服务器）一次仅处理一个请求，所以在该请求期间，该工作人员可以将请求数据视为全局数据。Flask为此使用术语&lt;em&gt;本地上下文&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="3103d134c4aeb275f63815ba62e9c5696777521e" translate="yes" xml:space="preserve">
          <source>When the development server is running in development mode (the &lt;code&gt;FLASK_ENV&lt;/code&gt; environment variable is set to &lt;code&gt;'development'&lt;/code&gt;), the error and data will be preserved and shown in the interactive debugger.</source>
          <target state="translated">当开发服务器在开发模式下运行时（ &lt;code&gt;FLASK_ENV&lt;/code&gt; 环境变量设置为 &lt;code&gt;'development'&lt;/code&gt; ），错误和数据将被保留并显示在交互式调试器中。</target>
        </trans-unit>
        <trans-unit id="1e55c75b73bc6dd6de03a65abce273358e363777" translate="yes" xml:space="preserve">
          <source>When the request context is popped, it will evaluate all the functions registered on the application for teardown execution (&lt;a href=&quot;#flask.Flask.teardown_request&quot;&gt;&lt;code&gt;teardown_request()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">弹出请求上下文时，它将评估在应用程序上注册的所有函数以进行拆卸执行（&lt;a href=&quot;#flask.Flask.teardown_request&quot;&gt; &lt;code&gt;teardown_request()&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="8dd7f654f135d993f0fb9d6a4491c29bafee37b6" translate="yes" xml:space="preserve">
          <source>When the request starts, a &lt;a href=&quot;../api/index#flask.ctx.RequestContext&quot;&gt;&lt;code&gt;RequestContext&lt;/code&gt;&lt;/a&gt; is created and pushed, which creates and pushes an &lt;a href=&quot;../api/index#flask.ctx.AppContext&quot;&gt;&lt;code&gt;AppContext&lt;/code&gt;&lt;/a&gt; first if a context for that application is not already the top context. While these contexts are pushed, the &lt;a href=&quot;../api/index#flask.current_app&quot;&gt;&lt;code&gt;current_app&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../api/index#flask.g&quot;&gt;&lt;code&gt;g&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../api/index#flask.request&quot;&gt;&lt;code&gt;request&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../api/index#flask.session&quot;&gt;&lt;code&gt;session&lt;/code&gt;&lt;/a&gt; proxies are available to the original thread handling the request.</source>
          <target state="translated">当请求开始时，一个&lt;a href=&quot;../api/index#flask.ctx.RequestContext&quot;&gt; &lt;code&gt;RequestContext&lt;/code&gt; &lt;/a&gt;被创建并推动时，它创建并且推动一个&lt;a href=&quot;../api/index#flask.ctx.AppContext&quot;&gt; &lt;code&gt;AppContext&lt;/code&gt; &lt;/a&gt;第一，如果用于该应用程序的上下文是不是已经顶端上下文。在推送这些上下文时，&lt;a href=&quot;../api/index#flask.current_app&quot;&gt; &lt;code&gt;current_app&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../api/index#flask.g&quot;&gt; &lt;code&gt;g&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../api/index#flask.request&quot;&gt; &lt;code&gt;request&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../api/index#flask.session&quot;&gt; &lt;code&gt;session&lt;/code&gt; &lt;/a&gt;代理可用于处理请求的原始线程。</target>
        </trans-unit>
        <trans-unit id="435a763e1c90a1b6384f01e02165782cf98540c0" translate="yes" xml:space="preserve">
          <source>When the user would then move with the mouse over the input, the cookie would be presented to the user in an alert window. But instead of showing the cookie to the user, a good attacker might also execute any other JavaScript code. In combination with CSS injections the attacker might even make the element fill out the entire page so that the user would just have to have the mouse anywhere on the page to trigger the attack.</source>
          <target state="translated">当用户将鼠标移动到输入上时,cookie就会在一个警报窗口中显示给用户。但是,一个好的攻击者可能也会执行任何其他的JavaScript代码,而不是向用户展示cookie。结合CSS注入,攻击者甚至可能会让这个元素填满整个页面,这样用户只需要将鼠标放在页面的任何位置就可以触发攻击。</target>
        </trans-unit>
        <trans-unit id="0467b7acdfba3a7eb8f631c45c8ef6ce0f4234c5" translate="yes" xml:space="preserve">
          <source>When there is no error handler registered for an exception, a 500 Internal Server Error will be returned instead. See &lt;a href=&quot;../api/index#flask.Flask.handle_exception&quot;&gt;&lt;code&gt;flask.Flask.handle_exception()&lt;/code&gt;&lt;/a&gt; for information about this behavior.</source>
          <target state="translated">如果没有为异常注册的错误处理程序，则将返回500 Internal Server Error。有关此行为的信息，请参见&lt;a href=&quot;../api/index#flask.Flask.handle_exception&quot;&gt; &lt;code&gt;flask.Flask.handle_exception()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8778dd974cd267f31d5c376567b1d22a2d99d395" translate="yes" xml:space="preserve">
          <source>When used in combination with a &lt;code&gt;with&lt;/code&gt; statement this opens a session transaction. This can be used to modify the session that the test client uses. Once the &lt;code&gt;with&lt;/code&gt; block is left the session is stored back.</source>
          <target state="translated">与 &lt;code&gt;with&lt;/code&gt; 语句结合使用时，这将打开会话事务。这可用于修改测试客户端使用的会话。一旦 &lt;code&gt;with&lt;/code&gt; 块留在会话存储回。</target>
        </trans-unit>
        <trans-unit id="d2d0ec0ea78ea1936f21e2b02b0acc0a2ec073da" translate="yes" xml:space="preserve">
          <source>When using Flask for web APIs, you can use the same techniques as above to return JSON responses to API errors. &lt;a href=&quot;../../api/index#flask.abort&quot;&gt;&lt;code&gt;abort()&lt;/code&gt;&lt;/a&gt; is called with a &lt;code&gt;description&lt;/code&gt; parameter. The &lt;code&gt;errorhandler()&lt;/code&gt; will use that as the JSON error message, and set the status code to 404.</source>
          <target state="translated">将Flask用于Web API时，可以使用与上述相同的技术来返回对API错误的JSON响应。使用 &lt;code&gt;description&lt;/code&gt; 参数调用&lt;a href=&quot;../../api/index#flask.abort&quot;&gt; &lt;code&gt;abort()&lt;/code&gt; &lt;/a&gt;。所述 &lt;code&gt;errorhandler()&lt;/code&gt; 将使用它作为JSON错误消息，并且该状态代码设置为404。</target>
        </trans-unit>
        <trans-unit id="bd49cfeb453fd5bf186d266b02fe67d1d413e8b6" translate="yes" xml:space="preserve">
          <source>When using a custom script, if you introduce an error in your module-level code, the reloader will fail because it can no longer load the entry point.</source>
          <target state="translated">当使用自定义脚本时,如果在模块级代码中引入错误,重载器将失败,因为它无法再加载入口点。</target>
        </trans-unit>
        <trans-unit id="453110846042107e1d8711c3a7dce570e47fd01a" translate="yes" xml:space="preserve">
          <source>When using development mode, the reloader will trigger whenever your Python code or imported modules change. The reloader can watch additional files with the &lt;code&gt;--extra-files&lt;/code&gt; option, or the &lt;code&gt;FLASK_RUN_EXTRA_FILES&lt;/code&gt; environment variable. Multiple paths are separated with &lt;code&gt;:&lt;/code&gt;, or &lt;code&gt;;&lt;/code&gt; on Windows.</source>
          <target state="translated">使用开发模式时，只要您的Python代码或导入的模块发生更改，重新加载器就会触发。重新加载程序可以使用 &lt;code&gt;--extra-files&lt;/code&gt; 选项或 &lt;code&gt;FLASK_RUN_EXTRA_FILES&lt;/code&gt; 环境变量监视其他文件。多个路径用 &lt;code&gt;:&lt;/code&gt; 或 &lt;code&gt;;&lt;/code&gt; 分隔。在Windows上。</target>
        </trans-unit>
        <trans-unit id="b2239df8391dc993ac72ed2e640392eb94eb7909" translate="yes" xml:space="preserve">
          <source>When using the &lt;a href=&quot;../appfactories/index#app-factories&quot;&gt;application factory pattern&lt;/a&gt;:</source>
          <target state="translated">使用&lt;a href=&quot;../appfactories/index#app-factories&quot;&gt;应用程序工厂模式时&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="a405ff8856d1d2bb6f33781f21256ab263ac1b03" translate="yes" xml:space="preserve">
          <source>When using the local development server, you may get a connection reset error instead of a 413 response. You will get the correct status response when running the app with a production WSGI server.</source>
          <target state="translated">当使用本地开发服务器时,您可能会得到一个连接重置错误,而不是413响应。当您使用生产WSGI服务器运行应用程序时,您将获得正确的状态响应。</target>
        </trans-unit>
        <trans-unit id="fe3529efc2fe6aa70c5cbe6159c0ab217237cec4" translate="yes" xml:space="preserve">
          <source>When using the shell, it may be easier to push and pop the context manually to avoid indentation.</source>
          <target state="translated">在使用shell的时候,为了避免压痕,可能更容易手动推送和弹出上下文。</target>
        </trans-unit>
        <trans-unit id="202b8d0ed31dbf31e58dcc9f53bba3835a804155" translate="yes" xml:space="preserve">
          <source>When you are using the app factory pattern, it may be more convenient to define your own Click script. Instead of using &lt;code&gt;FLASK_APP&lt;/code&gt; and letting Flask load your application, you can create your own Click object and export it as a &lt;a href=&quot;https://packaging.python.org/tutorials/packaging-projects/#console-scripts&quot;&gt;console script&lt;/a&gt; entry point.</source>
          <target state="translated">使用应用程序工厂模式时，定义自己的Click脚本可能更方便。您可以创建自己的Click对象并将其导出为&lt;a href=&quot;https://packaging.python.org/tutorials/packaging-projects/#console-scripts&quot;&gt;控制台脚本&lt;/a&gt;入口点，而不是使用 &lt;code&gt;FLASK_APP&lt;/code&gt; 并让Flask加载应用程序。</target>
        </trans-unit>
        <trans-unit id="d2959a7d1a2d78202afd13f0201890d8adbe0038" translate="yes" xml:space="preserve">
          <source>When you are working with WTForms you have to define your forms as classes first. I recommend breaking up the application into multiple modules (&lt;a href=&quot;../packages/index#larger-applications&quot;&gt;Larger Applications&lt;/a&gt;) for that and adding a separate module for the forms.</source>
          <target state="translated">使用WTForms时，必须首先将表单定义为类。我建议为此将应用程序分成多个模块（&lt;a href=&quot;../packages/index#larger-applications&quot;&gt;Large Applications&lt;/a&gt;），并为表单添加一个单独的模块。</target>
        </trans-unit>
        <trans-unit id="3c57429f094e6f244e6c6e23c4b635a6519ba190" translate="yes" xml:space="preserve">
          <source>When you bind a function with the help of the &lt;code&gt;@simple_page.route&lt;/code&gt; decorator, the blueprint will record the intention of registering the function &lt;code&gt;show&lt;/code&gt; on the application when it&amp;rsquo;s later registered. Additionally it will prefix the endpoint of the function with the name of the blueprint which was given to the &lt;a href=&quot;../api/index#flask.Blueprint&quot;&gt;&lt;code&gt;Blueprint&lt;/code&gt;&lt;/a&gt; constructor (in this case also &lt;code&gt;simple_page&lt;/code&gt;). The blueprint&amp;rsquo;s name does not modify the URL, only the endpoint.</source>
          <target state="translated">当您在 &lt;code&gt;@simple_page.route&lt;/code&gt; 装饰器的帮助下绑定功能时，蓝图将记录在以后注册应用程序时在应用程序上 &lt;code&gt;show&lt;/code&gt; 功能的意图。另外，它将在函数的端点之前添加给&lt;a href=&quot;../api/index#flask.Blueprint&quot;&gt; &lt;code&gt;Blueprint&lt;/code&gt; &lt;/a&gt;构造函数的蓝图名称（在本例中也是 &lt;code&gt;simple_page&lt;/code&gt; ）。蓝图的名称不会修改URL，只会修改端点。</target>
        </trans-unit>
        <trans-unit id="73b8e09128004281e69fc88b02a77e6f3b0d1507" translate="yes" xml:space="preserve">
          <source>When you have to work with form data submitted by a browser view, code quickly becomes very hard to read. There are libraries out there designed to make this process easier to manage. One of them is &lt;a href=&quot;https://wtforms.readthedocs.io/&quot;&gt;WTForms&lt;/a&gt; which we will handle here. If you find yourself in the situation of having many forms, you might want to give it a try.</source>
          <target state="translated">当您必须使用浏览器视图提交的表单数据时，代码很快变得很难阅读。有一些库旨在使此过程更易于管理。其中之一是&lt;a href=&quot;https://wtforms.readthedocs.io/&quot;&gt;WTForms&lt;/a&gt;，我们将在此处处理。如果您发现自己处于多种形式的情况，则可能需要尝试一下。</target>
        </trans-unit>
        <trans-unit id="e124bcfd21c7a0a58e753e33350e12e8f3015b2f" translate="yes" xml:space="preserve">
          <source>When you want to configure logging for your project, you should do it as soon as possible when the program starts. If &lt;a href=&quot;../api/index#flask.Flask.logger&quot;&gt;&lt;code&gt;app.logger&lt;/code&gt;&lt;/a&gt; is accessed before logging is configured, it will add a default handler. If possible, configure logging before creating the application object.</source>
          <target state="translated">当您要为项目配置日志记录时，应在程序启动时尽快进行记录。如果在配置日志记录之前访问了&lt;a href=&quot;../api/index#flask.Flask.logger&quot;&gt; &lt;code&gt;app.logger&lt;/code&gt; &lt;/a&gt;，它将添加一个默认处理程序。如果可能，请在创建应用程序对象之前配置日志记录。</target>
        </trans-unit>
        <trans-unit id="30dc6f270b8a620923d2dfdcdb2f1311fcb381f6" translate="yes" xml:space="preserve">
          <source>When you want to decorate a pluggable view you will have to either do that when the view function is created (by wrapping the return value of &lt;a href=&quot;#flask.views.View.as_view&quot;&gt;&lt;code&gt;as_view()&lt;/code&gt;&lt;/a&gt;) or you can use the &lt;a href=&quot;#flask.views.View.decorators&quot;&gt;&lt;code&gt;decorators&lt;/code&gt;&lt;/a&gt; attribute:</source>
          <target state="translated">当您要装饰可插拔视图时，必须在创建视图函数时执行此操作（通过包装&lt;a href=&quot;#flask.views.View.as_view&quot;&gt; &lt;code&gt;as_view()&lt;/code&gt; &lt;/a&gt;的返回值），或者可以使用&lt;a href=&quot;#flask.views.View.decorators&quot;&gt; &lt;code&gt;decorators&lt;/code&gt; &lt;/a&gt;属性：</target>
        </trans-unit>
        <trans-unit id="ed96f5e04c45ceb58d7163959ca69f2ff4bd80f7" translate="yes" xml:space="preserve">
          <source>When you want to use the werkzeug routing system for more flexibility you need to map the endpoint as defined in the &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/routing/#werkzeug.routing.Rule&quot;&gt;&lt;code&gt;Rule&lt;/code&gt;&lt;/a&gt; to a view function. This is possible with this decorator. For example:</source>
          <target state="translated">当您想使用werkzeug路由系统获得更大的灵活性时，需要将&lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/routing/#werkzeug.routing.Rule&quot;&gt; &lt;code&gt;Rule&lt;/code&gt; 中&lt;/a&gt;定义的端点映射到视图函数。使用此装饰器可以做到这一点。例如：</target>
        </trans-unit>
        <trans-unit id="80d878683e23024c3da2342716a6191b5bd1ae64" translate="yes" xml:space="preserve">
          <source>When your application runs slow, throw some caches in. Well, at least it&amp;rsquo;s the easiest way to speed up things. What does a cache do? Say you have a function that takes some time to complete but the results would still be good enough if they were 5 minutes old. So then the idea is that you actually put the result of that calculation into a cache for some time.</source>
          <target state="translated">当您的应用程序运行缓慢时，请放入一些缓存。嗯，至少这是加快处理速度的最简单方法。缓存有什么作用？假设您有一个需要花费一些时间才能完成的功能，但是如果仅使用5分钟，结果仍然足够好。因此，您的想法是实际上将计算结果放入缓存中一段时间​​。</target>
        </trans-unit>
        <trans-unit id="24852195225c09c2edf347e2b71ca7539c5984a0" translate="yes" xml:space="preserve">
          <source>Whenever you do this, please be very cautious about the variables you are using in this block.</source>
          <target state="translated">每当你这样做的时候,请非常谨慎地对待你在这个块中使用的变量。</target>
        </trans-unit>
        <trans-unit id="36f39dfb0af7dbae67d14debecc78ff94595daf2" translate="yes" xml:space="preserve">
          <source>Where is My Site?</source>
          <target state="translated">我的网站在哪里?</target>
        </trans-unit>
        <trans-unit id="c12a31a0fe38466ad8f8474f9ad58ac9b6e84905" translate="yes" xml:space="preserve">
          <source>Whether debug mode is enabled. When using &lt;code&gt;flask run&lt;/code&gt; to start the development server, an interactive debugger will be shown for unhandled exceptions, and the server will be reloaded when code changes. The &lt;a href=&quot;../api/index#flask.Flask.debug&quot;&gt;&lt;code&gt;debug&lt;/code&gt;&lt;/a&gt; attribute maps to this config key. This is enabled when &lt;a href=&quot;#ENV&quot;&gt;&lt;code&gt;ENV&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;'development'&lt;/code&gt; and is overridden by the &lt;code&gt;FLASK_DEBUG&lt;/code&gt; environment variable. It may not behave as expected if set in code.</source>
          <target state="translated">是否启用调试模式。当使用 &lt;code&gt;flask run&lt;/code&gt; 启动开发服务器时，将显示一个交互式调试器来处理未处理的异常，并且在代码更改时将重新加载服务器。在&lt;a href=&quot;../api/index#flask.Flask.debug&quot;&gt; &lt;code&gt;debug&lt;/code&gt; &lt;/a&gt;属性映射到这个配置的关键。当&lt;a href=&quot;#ENV&quot;&gt; &lt;code&gt;ENV&lt;/code&gt; &lt;/a&gt;为 &lt;code&gt;'development'&lt;/code&gt; 时被启用，并被 &lt;code&gt;FLASK_DEBUG&lt;/code&gt; 环境变量覆盖。如果在代码中设置，它的行为可能不符合预期。</target>
        </trans-unit>
        <trans-unit id="14f9a14ac1faf7d967445c7b976063b3d9532148" translate="yes" xml:space="preserve">
          <source>Whether debug mode is enabled. When using &lt;code&gt;flask run&lt;/code&gt; to start the development server, an interactive debugger will be shown for unhandled exceptions, and the server will be reloaded when code changes. This maps to the &lt;a href=&quot;../config/index#DEBUG&quot;&gt;&lt;code&gt;DEBUG&lt;/code&gt;&lt;/a&gt; config key. This is enabled when &lt;a href=&quot;#flask.Flask.env&quot;&gt;&lt;code&gt;env&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;'development'&lt;/code&gt; and is overridden by the &lt;code&gt;FLASK_DEBUG&lt;/code&gt; environment variable. It may not behave as expected if set in code.</source>
          <target state="translated">是否启用调试模式。当使用 &lt;code&gt;flask run&lt;/code&gt; 启动开发服务器时，将显示一个交互式调试器来处理未处理的异常，并且在代码更改时将重新加载服务器。这映射到&lt;a href=&quot;../config/index#DEBUG&quot;&gt; &lt;code&gt;DEBUG&lt;/code&gt; &lt;/a&gt;配置键。当&lt;a href=&quot;#flask.Flask.env&quot;&gt; &lt;code&gt;env&lt;/code&gt; &lt;/a&gt;为 &lt;code&gt;'development'&lt;/code&gt; 时被启用，并且被 &lt;code&gt;FLASK_DEBUG&lt;/code&gt; 环境变量覆盖。如果在代码中设置，它的行为可能不符合预期。</target>
        </trans-unit>
        <trans-unit id="0b45717b316c6a3080d74b5ba1017480da127881" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;FLASK_APP&lt;/code&gt; supports a variety of options for specifying your application, most use cases should be simple. Here are the typical values:</source>
          <target state="translated">尽管 &lt;code&gt;FLASK_APP&lt;/code&gt; 支持多种用于指定您的应用程序的选项，但是大多数用例应该很简单。以下是典型值：</target>
        </trans-unit>
        <trans-unit id="81c2db9e41d064c933605ca9f1efd8b050ea385e" translate="yes" xml:space="preserve">
          <source>While lightweight and easy to use, &lt;strong&gt;Flask&amp;rsquo;s built-in server is not suitable for production&lt;/strong&gt; as it doesn&amp;rsquo;t scale well. Some of the options available for properly running Flask in production are documented here.</source>
          <target state="translated">虽然轻巧易用，但&lt;strong&gt;Flask的内置服务器&lt;/strong&gt;不能很好地扩展规模，因此不&lt;strong&gt;适合生产&lt;/strong&gt;。此处记录了一些可在生产环境中正确运行Flask的选项。</target>
        </trans-unit>
        <trans-unit id="d07d2de19ae3b2a6b9ab804781d083894fe2d51e" translate="yes" xml:space="preserve">
          <source>While the &lt;a href=&quot;https://pypi.org/search/?c=Framework+%3A%3A+Flask&quot;&gt;PyPI&lt;/a&gt; contains many Flask extensions, you may not find an extension that fits your need. If this is the case, you can create your own. Read &lt;a href=&quot;https://flask.palletsprojects.com/en/1.1.x/extensiondev/&quot;&gt;Flask Extension Development&lt;/a&gt; to develop your own Flask extension.</source>
          <target state="translated">虽然&lt;a href=&quot;https://pypi.org/search/?c=Framework+%3A%3A+Flask&quot;&gt;PyPI&lt;/a&gt;包含许多Flask扩展名，但您可能找不到适合您需要的扩展名。在这种情况下，您可以创建自己的。阅读&lt;a href=&quot;https://flask.palletsprojects.com/en/1.1.x/extensiondev/&quot;&gt;Flask Extension开发&lt;/a&gt;以开发自己的Flask扩展。</target>
        </trans-unit>
        <trans-unit id="02679d3c3fe3c6f7c158317557829dd0576fd671" translate="yes" xml:space="preserve">
          <source>While this approach is straightforward to use, it is important to remember that environment variables are strings &amp;ndash; they are not automatically deserialized into Python types.</source>
          <target state="translated">尽管这种方法易于使用，但重要的是要记住，环境变量是字符串&amp;ndash;它们不会自动反序列化为Python类型。</target>
        </trans-unit>
        <trans-unit id="03da2a6cf735a3ba4eab16a5c1690117a76827b3" translate="yes" xml:space="preserve">
          <source>While this is fine for small applications, for larger applications it&amp;rsquo;s a good idea to use a package instead of a module. The &lt;a href=&quot;https://flask.palletsprojects.com/en/1.1.x/tutorial/#tutorial&quot;&gt;tutorial&lt;/a&gt; is structured to use the package pattern, see the &lt;a href=&quot;https://github.com/pallets/flask/tree/1.1.2/examples/tutorial&quot;&gt;example code&lt;/a&gt;.</source>
          <target state="translated">尽管这对于小型应用程序来说很好，但是对于大型应用程序，最好使用软件包而不是模块。本&lt;a href=&quot;https://flask.palletsprojects.com/en/1.1.x/tutorial/#tutorial&quot;&gt;教程&lt;/a&gt;使用了打包模式，请参见&lt;a href=&quot;https://github.com/pallets/flask/tree/1.1.2/examples/tutorial&quot;&gt;示例代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="98386f17d4cb4e1aaaca5cdf5e27ab3dfdff2169" translate="yes" xml:space="preserve">
          <source>Why Blueprints?</source>
          <target state="translated">为什么是蓝图?</target>
        </trans-unit>
        <trans-unit id="f194a70ddaebaa73a44954e0eeb520b55d695a16" translate="yes" xml:space="preserve">
          <source>Why do we limit the extensions that are allowed? You probably don&amp;rsquo;t want your users to be able to upload everything there if the server is directly sending out the data to the client. That way you can make sure that users are not able to upload HTML files that would cause XSS problems (see &lt;a href=&quot;../../security/index#xss&quot;&gt;Cross-Site Scripting (XSS)&lt;/a&gt;). Also make sure to disallow &lt;code&gt;.php&lt;/code&gt; files if the server executes them, but who has PHP installed on their server, right? :)</source>
          <target state="translated">为什么我们限制允许的扩展名？如果服务器直接将数据发送到客户端，则您可能不希望用户能够将所有内容上传到那里。这样，您可以确保用户无法上载会导致XSS问题的HTML文件（请参阅&lt;a href=&quot;../../security/index#xss&quot;&gt;跨站点脚本（XSS）&lt;/a&gt;）。另外，如果服务器执行了 &lt;code&gt;.php&lt;/code&gt; 文件，也要确保不允许这样做，但是谁在服务器上安装了PHP，对吗？:)</target>
        </trans-unit>
        <trans-unit id="a891bc4d84ab79562769f837680612b2cabc5301" translate="yes" xml:space="preserve">
          <source>Why does Flask call itself a microframework and yet it depends on two libraries (namely Werkzeug and Jinja2). Why shouldn&amp;rsquo;t it? If we look over to the Ruby side of web development there we have a protocol very similar to WSGI. Just that it&amp;rsquo;s called Rack there, but besides that it looks very much like a WSGI rendition for Ruby. But nearly all applications in Ruby land do not work with Rack directly, but on top of a library with the same name. This Rack library has two equivalents in Python: WebOb (formerly Paste) and Werkzeug. Paste is still around but from my understanding it&amp;rsquo;s sort of deprecated in favour of WebOb. The development of WebOb and Werkzeug started side by side with similar ideas in mind: be a good implementation of WSGI for other applications to take advantage.</source>
          <target state="translated">Flask为什么称自​​己为微框架，却依赖于两个库（即Werkzeug和Jinja2）。为什么不呢？如果我们研究Web开发的Ruby方面，那么我们有一个非常类似于WSGI的协议。只是在那里被称为Rack，但除此之外，它看起来非常像Ruby的WSGI格式。但是，几乎在Ruby领域中的所有应用程序都不能直接与Rack一起使用，而是在具有相同名称的库之上使用。这个Rack库在Python中有两个等效项：WebOb（以前称为Paste）和Werkzeug。粘贴仍然存在，但是据我了解，它已经过时了，转而支持WebOb。 WebOb和Werkzeug的开发是从相似的想法开始的：最好地实现WSGI，以使其他应用程序受益。</target>
        </trans-unit>
        <trans-unit id="1e947cc8d1476a1a5c0754ed8528b8fbc9bf733d" translate="yes" xml:space="preserve">
          <source>Why does Flask not do that for you? The ideal place for this to happen is the form validation framework, which does not exist in Flask.</source>
          <target state="translated">为什么Flask不为你做这些?最理想的地方是表单验证框架,但Flask中并不存在。</target>
        </trans-unit>
        <trans-unit id="a450869eb0a7c72b90aca6748427f275b0b43873" translate="yes" xml:space="preserve">
          <source>Why is that? The application will work even with &lt;code&gt;__name__&lt;/code&gt;, thanks to how resources are looked up. However it will make debugging more painful. Certain extensions can make assumptions based on the import name of your application. For example the Flask-SQLAlchemy extension will look for the code in your application that triggered an SQL query in debug mode. If the import name is not properly set up, that debugging information is lost. (For example it would only pick up SQL queries in &lt;code&gt;yourapplication.app&lt;/code&gt; and not &lt;code&gt;yourapplication.views.frontend&lt;/code&gt;)</source>
          <target state="translated">这是为什么？由于如何查找资源，该应用程序甚至可以与 &lt;code&gt;__name__&lt;/code&gt; 一起使用。但是，这会使调试更加痛苦。某些扩展可以根据您的应用程序的导入名称进行假设。例如，Flask-SQLAlchemy扩展将在您的应用程序中查找在调试模式下触发SQL查询的代码。如果导入名称设置不正确，则该调试信息将丢失。（例如，它将仅在 &lt;code&gt;yourapplication.app&lt;/code&gt; 中而不是 &lt;code&gt;yourapplication.views.frontend&lt;/code&gt; 中拾取SQL查询）</target>
        </trans-unit>
        <trans-unit id="4681cdb6e9e01e1e10c7820d390f76fe2e1a7e8b" translate="yes" xml:space="preserve">
          <source>Why is this necessary? Because if you would not be doing that, an attacker could easily inject custom JavaScript handlers. For example an attacker could inject this piece of HTML+JavaScript:</source>
          <target state="translated">为什么要这样做呢?因为如果你不这样做,攻击者可以很容易地注入自定义的JavaScript处理程序。例如,攻击者可以注入这段HTML+JavaScript。</target>
        </trans-unit>
        <trans-unit id="3c4eee296c48eb4cdd05301ab2d560574507089d" translate="yes" xml:space="preserve">
          <source>Why is this the case? Because people have different preferences and requirements and Flask could not meet those if it would force any of this into the core. The majority of web applications will need a template engine in some sort. However not every application needs a SQL database.</source>
          <target state="translated">为什么会出现这种情况呢?因为人们有不同的喜好和要求,如果Flask会把这些强加到核心中,就无法满足这些要求。大多数的网络应用都需要某种形式的模板引擎。然而并不是每个应用都需要SQL数据库。</target>
        </trans-unit>
        <trans-unit id="97f00272d21ad51c5b8a40e2a7111d5b291d8db6" translate="yes" xml:space="preserve">
          <source>Why would you want to build URLs using the URL reversing function &lt;a href=&quot;../api/index#flask.url_for&quot;&gt;&lt;code&gt;url_for()&lt;/code&gt;&lt;/a&gt; instead of hard-coding them into your templates?</source>
          <target state="translated">为什么要使用URL反转函数&lt;a href=&quot;../api/index#flask.url_for&quot;&gt; &lt;code&gt;url_for()&lt;/code&gt; &lt;/a&gt;来构建URL，而不是将其硬编码到模板中？</target>
        </trans-unit>
        <trans-unit id="a397bf775e16587aa5e8208e6a96c9178b091928" translate="yes" xml:space="preserve">
          <source>Will be used for the session cookie path if &lt;code&gt;SESSION_COOKIE_PATH&lt;/code&gt; is not set.</source>
          <target state="translated">如果未设置 &lt;code&gt;SESSION_COOKIE_PATH&lt;/code&gt; ,将用于会话cookie路径。</target>
        </trans-unit>
        <trans-unit id="f3edee93e1605bff216d9b2854ee9508e7ccca23" translate="yes" xml:space="preserve">
          <source>Windows CMD, &lt;code&gt;venv\Scripts\activate.bat&lt;/code&gt;:</source>
          <target state="translated">Windows CMD, &lt;code&gt;venv\Scripts\activate.bat&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="34bbe867e973001f4b07ccf1a35edb30be3bd482" translate="yes" xml:space="preserve">
          <source>Windows CMD:</source>
          <target state="translated">Windows CMD。</target>
        </trans-unit>
        <trans-unit id="e35f0573f4fc191914534f505ab1d46e2f50a916" translate="yes" xml:space="preserve">
          <source>Windows PowerShell:</source>
          <target state="translated">Windows PowerShell。</target>
        </trans-unit>
        <trans-unit id="5029e0c2b03b9f2c262221dbd5b5bd90e8899da0" translate="yes" xml:space="preserve">
          <source>With Blinker 1.1 you can also easily subscribe to signals by using the new &lt;code&gt;connect_via()&lt;/code&gt; decorator:</source>
          <target state="translated">使用Blinker 1.1，您还可以使用新的 &lt;code&gt;connect_via()&lt;/code&gt; 装饰器轻松订阅信号：</target>
        </trans-unit>
        <trans-unit id="9ea1dbfb2b35223e6cae63e931f186e0a336e4e7" translate="yes" xml:space="preserve">
          <source>With CGI, you will also have to make sure that your code does not contain any &lt;code&gt;print&lt;/code&gt; statements, or that &lt;code&gt;sys.stdout&lt;/code&gt; is overridden by something that doesn&amp;rsquo;t write into the HTTP response.</source>
          <target state="translated">使用CGI，您还必须确保您的代码不包含任何 &lt;code&gt;print&lt;/code&gt; 语句，或者 &lt;code&gt;sys.stdout&lt;/code&gt; 被未写入HTTP响应的内容覆盖。</target>
        </trans-unit>
        <trans-unit id="0051dded9ef7854e2e91003b8a9cd19576810dc4" translate="yes" xml:space="preserve">
          <source>With Flask 0.8 a new attribute was introduced: &lt;code&gt;Flask.instance_path&lt;/code&gt;. It refers to a new concept called the &amp;ldquo;instance folder&amp;rdquo;. The instance folder is designed to not be under version control and be deployment specific. It&amp;rsquo;s the perfect place to drop things that either change at runtime or configuration files.</source>
          <target state="translated">在Flask 0.8中引入了一个新属性： &lt;code&gt;Flask.instance_path&lt;/code&gt; 。它指的是一个称为&amp;ldquo;实例文件夹&amp;rdquo;的新概念。实例文件夹被设计为不受版本控制并且特定于部署。这是删除运行时或配置文件中发生更改的内容的理想场所。</target>
        </trans-unit>
        <trans-unit id="5fc1194f30d57b98a20e902b58db54a5ef167375" translate="yes" xml:space="preserve">
          <source>Within the activated environment, use the following command to install Flask:</source>
          <target state="translated">在激活的环境中,使用以下命令安装Flask。</target>
        </trans-unit>
        <trans-unit id="5cf10057ee349ea81d4a2c30fb8f6b3e1f3dba10" translate="yes" xml:space="preserve">
          <source>Within the given import, the command looks for an application instance named &lt;code&gt;app&lt;/code&gt; or &lt;code&gt;application&lt;/code&gt;, then any application instance. If no instance is found, the command looks for a factory function named &lt;code&gt;create_app&lt;/code&gt; or &lt;code&gt;make_app&lt;/code&gt; that returns an instance.</source>
          <target state="translated">在给定的导入中，该命令将查找名为 &lt;code&gt;app&lt;/code&gt; 或 &lt;code&gt;application&lt;/code&gt; 的应用程序实例，然后是任何应用程序实例。如果未找到任何实例，该命令将查找一个名为 &lt;code&gt;create_app&lt;/code&gt; 或 &lt;code&gt;make_app&lt;/code&gt; 的工厂函数，该函数将返回一个实例。</target>
        </trans-unit>
        <trans-unit id="2edfb5fdcbb446c6233ab769a480e6a1eb85d46b" translate="yes" xml:space="preserve">
          <source>Without such an explicit application object the following code:</source>
          <target state="translated">如果没有这样一个明确的应用对象,下面的代码。</target>
        </trans-unit>
        <trans-unit id="ded186b0185fad2c663e992ba2b819e1d95a9cc7" translate="yes" xml:space="preserve">
          <source>Without the &lt;a href=&quot;../../api/index#flask.stream_with_context&quot;&gt;&lt;code&gt;stream_with_context()&lt;/code&gt;&lt;/a&gt; function you would get a &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; at that point.</source>
          <target state="translated">没有&lt;a href=&quot;../../api/index#flask.stream_with_context&quot;&gt; &lt;code&gt;stream_with_context()&lt;/code&gt; &lt;/a&gt;函数，您将在此时获取&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="82022f415aa2304fa555c4874534511aebb29b09" translate="yes" xml:space="preserve">
          <source>Working with Blueprints</source>
          <target state="translated">使用蓝图</target>
        </trans-unit>
        <trans-unit id="174dfaa3b837fd42113fd4b450ec06ae175bd24c" translate="yes" xml:space="preserve">
          <source>Working with Debuggers</source>
          <target state="translated">使用调试器</target>
        </trans-unit>
        <trans-unit id="8e91ae4e49f91300d85f9ba8895465dc940a2f4f" translate="yes" xml:space="preserve">
          <source>Working with Fabric is fun and you will notice that it&amp;rsquo;s quite magical to type &lt;code&gt;fab deploy&lt;/code&gt; and see your application being deployed automatically to one or more remote servers.</source>
          <target state="translated">使用Fabric很有意思，您会发现键入 &lt;code&gt;fab deploy&lt;/code&gt; 并查看将您的应用程序自动部署到一台或多台远程服务器是非常神奇的。</target>
        </trans-unit>
        <trans-unit id="5c7ec70627234962f0a47ddb780aaca80066a4d5" translate="yes" xml:space="preserve">
          <source>Working with Virtual Environments</source>
          <target state="translated">在虚拟环境中工作</target>
        </trans-unit>
        <trans-unit id="5962457b820c4c6e261a2c144cd8a01a0d9e31ec" translate="yes" xml:space="preserve">
          <source>Working with the Shell</source>
          <target state="translated">与壳牌合作</target>
        </trans-unit>
        <trans-unit id="aa95b4eb1753a08bb133e2cb9411a34b99fac635" translate="yes" xml:space="preserve">
          <source>Working with this Document</source>
          <target state="translated">使用本文件</target>
        </trans-unit>
        <trans-unit id="ea7207f47a6cecde08b584e2bc317e220ad1a6bd" translate="yes" xml:space="preserve">
          <source>Works exactly like a dict but provides ways to fill it from files or special dictionaries. There are two common patterns to populate the config.</source>
          <target state="translated">与dict完全一样,但提供了从文件或特殊字典中填充的方法。有两种常见的模式来填充配置。</target>
        </trans-unit>
        <trans-unit id="4abba765ed12c340a7b3f93bc430769734fb1cde" translate="yes" xml:space="preserve">
          <source>Works like &lt;a href=&quot;#flask.Blueprint.record&quot;&gt;&lt;code&gt;record()&lt;/code&gt;&lt;/a&gt; but wraps the function in another function that will ensure the function is only called once. If the blueprint is registered a second time on the application, the function passed is not called.</source>
          <target state="translated">像&lt;a href=&quot;#flask.Blueprint.record&quot;&gt; &lt;code&gt;record()&lt;/code&gt; 一样工作,&lt;/a&gt;但是将函数包装在另一个函数中，这将确保该函数仅被调用一次。如果在应用程序上第二次注册了该蓝图，则不会调用传递的函数。</target>
        </trans-unit>
        <trans-unit id="af16180fe9c836cb3c8620984015754fd76bd557" translate="yes" xml:space="preserve">
          <source>Works like &lt;a href=&quot;#flask.has_request_context&quot;&gt;&lt;code&gt;has_request_context()&lt;/code&gt;&lt;/a&gt; but for the application context. You can also just do a boolean check on the &lt;a href=&quot;#flask.current_app&quot;&gt;&lt;code&gt;current_app&lt;/code&gt;&lt;/a&gt; object instead.</source>
          <target state="translated">与&lt;a href=&quot;#flask.has_request_context&quot;&gt; &lt;code&gt;has_request_context()&lt;/code&gt; &lt;/a&gt;类似，但适用于应用程序上下文。您也可以只对&lt;a href=&quot;#flask.current_app&quot;&gt; &lt;code&gt;current_app&lt;/code&gt; &lt;/a&gt;对象进行布尔检查。</target>
        </trans-unit>
        <trans-unit id="7b7d2b65bd7a2ebb1ffea7d8ba55adb9788a66b1" translate="yes" xml:space="preserve">
          <source>Works like a regular Werkzeug test client but has some knowledge about how Flask works to defer the cleanup of the request context stack to the end of a &lt;code&gt;with&lt;/code&gt; body when used in a &lt;code&gt;with&lt;/code&gt; statement. For general information about how to use this class refer to &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/test/#werkzeug.test.Client&quot;&gt;&lt;code&gt;werkzeug.test.Client&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">像常规的Werkzeug测试客户端一样工作，但对Flask如何在 &lt;code&gt;with&lt;/code&gt; 语句中使用时如何将请求上下文堆栈的清理推迟到 &lt;code&gt;with&lt;/code&gt; 主体的末尾有一些了解。有关如何使用此类的一般信息，请参阅&lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/test/#werkzeug.test.Client&quot;&gt; &lt;code&gt;werkzeug.test.Client&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="658a4eab006ab7fa193f4ca8097129fa50591b9f" translate="yes" xml:space="preserve">
          <source>Would look like this instead:</source>
          <target state="translated">会像这样代替。</target>
        </trans-unit>
        <trans-unit id="b61966a6eb8b4a6698bc9475263ea8c711f2b9d9" translate="yes" xml:space="preserve">
          <source>Wrap with middleware.</source>
          <target state="translated">用中间件进行包装。</target>
        </trans-unit>
        <trans-unit id="740e3b31cb73b82925495c4bf9da460f8228f3a8" translate="yes" xml:space="preserve">
          <source>Wrapping &lt;code&gt;app.wsgi_app&lt;/code&gt; instead of &lt;code&gt;app&lt;/code&gt; means that &lt;code&gt;app&lt;/code&gt; still points at your Flask application, not at the middleware, so you can continue to use and configure &lt;code&gt;app&lt;/code&gt; directly.</source>
          <target state="translated">包装 &lt;code&gt;app.wsgi_app&lt;/code&gt; 而不是 &lt;code&gt;app&lt;/code&gt; 意味着该 &lt;code&gt;app&lt;/code&gt; 仍指向Flask应用程序，而不是中间件，因此您可以继续直接使用和配置该 &lt;code&gt;app&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0f51226c51b17263badab9df2106d7cff82896c0" translate="yes" xml:space="preserve">
          <source>Wrapping header elements in &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; or the body elements in &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;</source>
          <target state="translated">包装 &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; 中的标头元素或 &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; 中的body元素</target>
        </trans-unit>
        <trans-unit id="1f81513709adf5d23b6dade29c1709cf60afacea" translate="yes" xml:space="preserve">
          <source>Wrapping the document in an &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; tag</source>
          <target state="translated">将文档包装在 &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; 标记中</target>
        </trans-unit>
        <trans-unit id="08243519171e58eb5620942b8910f8f357da7888" translate="yes" xml:space="preserve">
          <source>Wraps a callback so that it&amp;rsquo;s guaranteed to be executed with the script&amp;rsquo;s application context. If callbacks are registered directly to the &lt;code&gt;app.cli&lt;/code&gt; object then they are wrapped with this function by default unless it&amp;rsquo;s disabled.</source>
          <target state="translated">包装一个回调，以便保证可以与脚本的应用程序上下文一起执行。如果回调直接注册到 &lt;code&gt;app.cli&lt;/code&gt; 对象，则默认情况下将使用此函数包装回调，除非已将其禁用。</target>
        </trans-unit>
        <trans-unit id="b1d3f473c48021046e7ba3468f5cf21e1b0e7ddd" translate="yes" xml:space="preserve">
          <source>X-Content-Type-Options</source>
          <target state="translated">X-Content-Type-Options</target>
        </trans-unit>
        <trans-unit id="06d18ff7a6daa0422e0cad3f72e863617cee9d06" translate="yes" xml:space="preserve">
          <source>X-Frame-Options</source>
          <target state="translated">X-Frame-Options</target>
        </trans-unit>
        <trans-unit id="c7215a317b6dd9b4629392c1b06074727d0d0713" translate="yes" xml:space="preserve">
          <source>X-XSS-Protection</source>
          <target state="translated">X-XSS-Protection</target>
        </trans-unit>
        <trans-unit id="a6a5d99b17036813c63f08d13c7714df3b475074" translate="yes" xml:space="preserve">
          <source>XHTML 1.0 is the last XHTML standard that allows to be served as &lt;code&gt;text/html&lt;/code&gt; for backwards compatibility reasons.</source>
          <target state="translated">XHTML 1.0是最后一个XHTML标准，出于向后兼容的原因，该标准允许用作 &lt;code&gt;text/html&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bda24e4e25235f523a1e01a6e41ad928b404f09d" translate="yes" xml:space="preserve">
          <source>XHTML also changed the way JavaScript is used. To properly work with XHTML, programmers have to use the namespaced DOM interface with the XHTML namespace to query for HTML elements.</source>
          <target state="translated">XHTML还改变了JavaScript的使用方式。为了正确使用XHTML,程序员必须使用带有XHTML命名空间的命名间隔DOM接口来查询HTML元素。</target>
        </trans-unit>
        <trans-unit id="39bd3f4531a613bddcbdda33a96b21dae6406a84" translate="yes" xml:space="preserve">
          <source>XHTML1.1</source>
          <target state="translated">XHTML1.1</target>
        </trans-unit>
        <trans-unit id="d4d7254077087144effdb1513a82294c56883462" translate="yes" xml:space="preserve">
          <source>Yes it is usually not such a bright idea to use thread locals. They cause troubles for servers that are not based on the concept of threads and make large applications harder to maintain. However Flask is just not designed for large applications or asynchronous servers. Flask wants to make it quick and easy to write a traditional web application.</source>
          <target state="translated">是的,使用线程定位通常不是一个明智的想法,它们会给那些不是基于线程概念的服务器带来麻烦,并使大型应用程序难以维护。它们会给不是基于线程概念的服务器带来麻烦,并使大型应用程序难以维护。然而Flask并不是为大型应用或异步服务器设计的。Flask希望能让你快速、轻松地编写一个传统的Web应用程序。</target>
        </trans-unit>
        <trans-unit id="1f3136380e3ce32df5b6cde5bb51ed47e0e4277b" translate="yes" xml:space="preserve">
          <source>You can access this from Python code like this:</source>
          <target state="translated">你可以通过这样的Python代码来访问它。</target>
        </trans-unit>
        <trans-unit id="09586c1075eecf1c5e26ddb7ff9daf06bf262694" translate="yes" xml:space="preserve">
          <source>You can add variable sections to a URL by marking sections with &lt;code&gt;&amp;lt;variable_name&amp;gt;&lt;/code&gt;. Your function then receives the &lt;code&gt;&amp;lt;variable_name&amp;gt;&lt;/code&gt; as a keyword argument. Optionally, you can use a converter to specify the type of the argument like &lt;code&gt;&amp;lt;converter:variable_name&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">您可以通过使用 &lt;code&gt;&amp;lt;variable_name&amp;gt;&lt;/code&gt; 标记部分来将变量部分添加到URL 。然后，您的函数将 &lt;code&gt;&amp;lt;variable_name&amp;gt;&lt;/code&gt; 接收为关键字参数。（可选）您可以使用转换器来指定参数的类型，例如 &lt;code&gt;&amp;lt;converter:variable_name&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="13a798184000342bdc31c2a5d39aa34d03700383" translate="yes" xml:space="preserve">
          <source>You can also control debug mode separately from the environment by exporting &lt;code&gt;FLASK_DEBUG=1&lt;/code&gt;.</source>
          <target state="translated">您还可以通过导出 &lt;code&gt;FLASK_DEBUG=1&lt;/code&gt; 与环境分开控制调试模式。</target>
        </trans-unit>
        <trans-unit id="735c2a045909269887c922feb75c408a35900aed" translate="yes" xml:space="preserve">
          <source>You can also define multiple rules for the same function. They have to be unique however. Defaults can also be specified. Here for example is a definition for a URL that accepts an optional page:</source>
          <target state="translated">你也可以为同一个函数定义多个规则。但它们必须是唯一的。也可以指定默认值。例如,这里是一个接受可选页面的URL的定义。</target>
        </trans-unit>
        <trans-unit id="c07d08db159eb42de824b9b610a9aa3c991453bc" translate="yes" xml:space="preserve">
          <source>You can also pass strings of SQL statements to the &lt;code&gt;execute()&lt;/code&gt; method:</source>
          <target state="translated">您还可以将SQL语句的字符串传递给 &lt;code&gt;execute()&lt;/code&gt; 方法：</target>
        </trans-unit>
        <trans-unit id="54ed7476202f966af3321d87dd224a1e7c1875f4" translate="yes" xml:space="preserve">
          <source>You can also register handlers for arbitrary exceptions:</source>
          <target state="translated">你也可以为任意异常注册处理程序。</target>
        </trans-unit>
        <trans-unit id="2d214d9a4e07beaff0c04d1de76e20e5640f7609" translate="yes" xml:space="preserve">
          <source>You can alter the group name by specifying the &lt;code&gt;cli_group&lt;/code&gt; parameter when creating the &lt;a href=&quot;../api/index#flask.Blueprint&quot;&gt;&lt;code&gt;Blueprint&lt;/code&gt;&lt;/a&gt; object, or later with &lt;a href=&quot;../api/index#flask.Flask.register_blueprint&quot;&gt;&lt;code&gt;app.register_blueprint(bp, cli_group='...')&lt;/code&gt;&lt;/a&gt;. The following are equivalent:</source>
          <target state="translated">您可以通过在创建&lt;a href=&quot;../api/index#flask.Blueprint&quot;&gt; &lt;code&gt;Blueprint&lt;/code&gt; &lt;/a&gt;对象时指定 &lt;code&gt;cli_group&lt;/code&gt; 参数来更改组名，或者稍后使用&lt;a href=&quot;../api/index#flask.Flask.register_blueprint&quot;&gt; &lt;code&gt;app.register_blueprint(bp, cli_group='...')&lt;/code&gt; &lt;/a&gt;来更改组名。以下是等效的：</target>
        </trans-unit>
        <trans-unit id="7bc1d29b17b575666e4a90412225f097a550cd2b" translate="yes" xml:space="preserve">
          <source>You can change your URLs in one go instead of needing to remember to manually change hard-coded URLs.</source>
          <target state="translated">您可以一次性更改您的URL,而不是需要记住手动更改硬编码的URL。</target>
        </trans-unit>
        <trans-unit id="5ffc15f46b9fc31451c1c483533ea6a89df66fd3" translate="yes" xml:space="preserve">
          <source>You can directly access the underlying Werkzeug routing system which is exposed as &lt;a href=&quot;#flask.Flask.url_map&quot;&gt;&lt;code&gt;flask.Flask.url_map&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">您可以直接访问底层的Werkzeug路由系统，该系统公开为&lt;a href=&quot;#flask.Flask.url_map&quot;&gt; &lt;code&gt;flask.Flask.url_map&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="984bdc98632cae814fe71e5886652cb89c6f02a5" translate="yes" xml:space="preserve">
          <source>You can do more! You can make parts of the URL dynamic and attach multiple rules to a function.</source>
          <target state="translated">你可以做得更多 你可以将URL的部分内容变成动态的,并将多个规则附加到一个函数中。</target>
        </trans-unit>
        <trans-unit id="2e8721c2666e9d94927a964e4bfa0d0fd1c1b0a2" translate="yes" xml:space="preserve">
          <source>You can download &lt;a href=&quot;https://flask-sqlalchemy.palletsprojects.com/&quot;&gt;Flask-SQLAlchemy&lt;/a&gt; from &lt;a href=&quot;https://pypi.org/project/Flask-SQLAlchemy/&quot;&gt;PyPI&lt;/a&gt;.</source>
          <target state="translated">您可以从&lt;a href=&quot;https://pypi.org/project/Flask-SQLAlchemy/&quot;&gt;PyPI&lt;/a&gt;下载&lt;a href=&quot;https://flask-sqlalchemy.palletsprojects.com/&quot;&gt;Flask-SQLAlchemy&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1841a7437382f970ce54e43474bd5546830e026a" translate="yes" xml:space="preserve">
          <source>You can either explicitly provide the path of the instance folder when creating the Flask application or you can let Flask autodetect the instance folder. For explicit configuration use the &lt;code&gt;instance_path&lt;/code&gt; parameter:</source>
          <target state="translated">您可以在创建Flask应用程序时显式提供实例文件夹的路径，也可以让Flask自动检测实例文件夹。对于显式配置，请使用 &lt;code&gt;instance_path&lt;/code&gt; 参数：</target>
        </trans-unit>
        <trans-unit id="c2c612caac21987cc43757018ba10328146f3bed" translate="yes" xml:space="preserve">
          <source>You can further optimize this in terms of amount of keystrokes needed to write this by having a function that calls into &lt;a href=&quot;../../api/index#flask.Flask.add_url_rule&quot;&gt;&lt;code&gt;add_url_rule()&lt;/code&gt;&lt;/a&gt; by prefixing a string with the project name and a dot, and by wrapping &lt;code&gt;view_func&lt;/code&gt; in a &lt;code&gt;LazyView&lt;/code&gt; as needed.</source>
          <target state="translated">您可以通过编写具有&lt;a href=&quot;../../api/index#flask.Flask.add_url_rule&quot;&gt; &lt;code&gt;add_url_rule()&lt;/code&gt; &lt;/a&gt;的函数，在字符串前加上项目名称和点作为前缀，并根据需要将 &lt;code&gt;view_func&lt;/code&gt; 包装在 &lt;code&gt;LazyView&lt;/code&gt; 中，从而根据编写此脚本所需的击键次数进一步优化此功能。</target>
        </trans-unit>
        <trans-unit id="7fc74331c51a31cc667477b55c84860ef9ff5efa" translate="yes" xml:space="preserve">
          <source>You can handle uploaded files with Flask easily. Just make sure not to forget to set the &lt;code&gt;enctype=&quot;multipart/form-data&quot;&lt;/code&gt; attribute on your HTML form, otherwise the browser will not transmit your files at all.</source>
          <target state="translated">您可以使用Flask轻松处理上传的文件。只要确保不要忘记在HTML表单上设置 &lt;code&gt;enctype=&quot;multipart/form-data&quot;&lt;/code&gt; 属性，否则浏览器将根本不会传输您的文件。</target>
        </trans-unit>
        <trans-unit id="cd9da2c829c808ae14ff97b60dd99fcb9a6b4883" translate="yes" xml:space="preserve">
          <source>You can insert entries into the database like this:</source>
          <target state="translated">你可以像这样在数据库中插入条目。</target>
        </trans-unit>
        <trans-unit id="1f1d53f100f52d39105a86264c6559de894d8334" translate="yes" xml:space="preserve">
          <source>You can instead just do this:</source>
          <target state="translated">你倒是可以直接这样做。</target>
        </trans-unit>
        <trans-unit id="4f7f86adef7d97a12c6e377396fd8ca61a55243a" translate="yes" xml:space="preserve">
          <source>You can now do something like this:</source>
          <target state="translated">你现在可以做这样的事情。</target>
        </trans-unit>
        <trans-unit id="0a2c49b664210fffc70a580adc0af1ac23349ed7" translate="yes" xml:space="preserve">
          <source>You can place one or more decorators in this list and whenever the view function is created the result is automatically decorated.</source>
          <target state="translated">您可以在这个列表中放置一个或多个装饰器,每当创建视图函数时,结果就会自动装饰。</target>
        </trans-unit>
        <trans-unit id="1da6800140a00549a2a623ca1a3a17260035bf50" translate="yes" xml:space="preserve">
          <source>You can skip this next step if you&amp;rsquo;re using &lt;a href=&quot;#dotenv&quot;&gt;Environment Variables From dotenv&lt;/a&gt;. We need to add an environment variable (&lt;strong&gt;C&lt;/strong&gt;) to identify our application. Click on the browse button and add an entry with &lt;code&gt;FLASK_APP&lt;/code&gt; on the left and the Python import or file on the right (&lt;code&gt;hello&lt;/code&gt; for example). Add an entry with &lt;code&gt;FLASK_ENV&lt;/code&gt; and set it to &lt;code&gt;development&lt;/code&gt;.</source>
          <target state="translated">如果您正在使用&lt;a href=&quot;#dotenv&quot;&gt;来自dotenv的环境变量，&lt;/a&gt;则可以跳过此下一步。我们需要添加一个环境变量（&lt;strong&gt;C&lt;/strong&gt;）来标识我们的应用程序。单击浏览按钮，然后添加一个条目，其左侧为 &lt;code&gt;FLASK_APP&lt;/code&gt; ，右侧为Python导入或文件（例如， &lt;code&gt;hello&lt;/code&gt; ）。用 &lt;code&gt;FLASK_ENV&lt;/code&gt; 添加一个条目并将其设置为 &lt;code&gt;development&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6483d3813ab3e4bbce930c0177fee5b4b04ae4c2" translate="yes" xml:space="preserve">
          <source>You can tell Flask not to load dotenv files even when python-dotenv is installed by setting the &lt;code&gt;FLASK_SKIP_DOTENV&lt;/code&gt; environment variable. This can be useful if you want to load them manually, or if you&amp;rsquo;re using a project runner that loads them already. Keep in mind that the environment variables must be set before the app loads or it won&amp;rsquo;t configure as expected.</source>
          <target state="translated">您可以通过设置 &lt;code&gt;FLASK_SKIP_DOTENV&lt;/code&gt; 环境变量来告诉Flask即使安装了python-dotenv也不要加载dotenv文件。如果您想手动加载它们，或者正在使用已经加载它们的项目运行器，这将很有用。请记住，必须在应用加载之前设置环境变量，否则将无法按预期配置。</target>
        </trans-unit>
        <trans-unit id="360d91d2ad0114d0798c198d383101249bada607" translate="yes" xml:space="preserve">
          <source>You can then create such a database from the Python shell:</source>
          <target state="translated">然后你可以从Python shell中创建这样一个数据库。</target>
        </trans-unit>
        <trans-unit id="08695aa15a5b055d73bcc0d2bca100ad13902124" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/local/#werkzeug.local.LocalProxy&quot;&gt;&lt;code&gt;LocalProxy&lt;/code&gt;&lt;/a&gt; to make a new context local from &lt;code&gt;get_db()&lt;/code&gt;:</source>
          <target state="translated">您可以使用&lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/local/#werkzeug.local.LocalProxy&quot;&gt; &lt;code&gt;LocalProxy&lt;/code&gt; &lt;/a&gt;从 &lt;code&gt;get_db()&lt;/code&gt; 使本地成为新上下文：</target>
        </trans-unit>
        <trans-unit id="47f8c607be57c7e02cb9fab7cb7b0024d86b7c09" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;#flask.Flask.add_url_rule&quot;&gt;&lt;code&gt;flask.Flask.add_url_rule()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">您可以使用&lt;a href=&quot;#flask.Flask.add_url_rule&quot;&gt; &lt;code&gt;flask.Flask.add_url_rule()&lt;/code&gt; &lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="a0033b8cf3589b920481f85c256e584b5e0fcaf7" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;#flask.Flask.route&quot;&gt;&lt;code&gt;flask.Flask.route()&lt;/code&gt;&lt;/a&gt; decorator.</source>
          <target state="translated">您可以使用&lt;a href=&quot;#flask.Flask.route&quot;&gt; &lt;code&gt;flask.Flask.route()&lt;/code&gt; &lt;/a&gt;装饰器。</target>
        </trans-unit>
        <trans-unit id="26aa41ee25e6511c598ffd1f66556225da3cc416" translate="yes" xml:space="preserve">
          <source>You could also build &lt;code&gt;format_price&lt;/code&gt; as a template filter (see &lt;a href=&quot;#registering-filters&quot;&gt;Registering Filters&lt;/a&gt;), but this demonstrates how to pass functions in a context processor.</source>
          <target state="translated">您还可以将 &lt;code&gt;format_price&lt;/code&gt; 构建为模板过滤器（请参阅&lt;a href=&quot;#registering-filters&quot;&gt;注册过滤器&lt;/a&gt;），但这演示了如何在上下文处理器中传递函数。</target>
        </trans-unit>
        <trans-unit id="06e519ae82314491880a1655b2f4854bdd260692" translate="yes" xml:space="preserve">
          <source>You could also put your application code into a repository and check out the latest version on the server and then install. That way you can also easily go back to older versions.</source>
          <target state="translated">你也可以把你的应用程序代码放到一个仓库里,在服务器上查看最新的版本,然后安装。这样你也可以轻松地回到旧版本。</target>
        </trans-unit>
        <trans-unit id="2e4bce016fc9ebac48214337e2a1de5a11069c45" translate="yes" xml:space="preserve">
          <source>You have an &lt;code&gt;app.run()&lt;/code&gt; call in your application file that is not guarded by an &lt;code&gt;if __name__ == '__main__':&lt;/code&gt; condition. Either remove that &lt;a href=&quot;../../api/index#flask.Flask.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt; call from the file and move it into a separate &lt;code&gt;run.py&lt;/code&gt; file or put it into such an if block.</source>
          <target state="translated">您的应用程序文件中有一个 &lt;code&gt;app.run()&lt;/code&gt; 调用，该调用不受 &lt;code&gt;if __name__ == '__main__':&lt;/code&gt; 条件的保护。从文件中删除该&lt;a href=&quot;../../api/index#flask.Flask.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt;调用，然后将其移动到单独的 &lt;code&gt;run.py&lt;/code&gt; 文件中，或将其放入这样的if块中。</target>
        </trans-unit>
        <trans-unit id="c9aef93067b1b7feb6791fe058c941f0937284cd" translate="yes" xml:space="preserve">
          <source>You just need to wrap the return expression with &lt;a href=&quot;../api/index#flask.make_response&quot;&gt;&lt;code&gt;make_response()&lt;/code&gt;&lt;/a&gt; and get the response object to modify it, then return it:</source>
          <target state="translated">您只需要用&lt;a href=&quot;../api/index#flask.make_response&quot;&gt; &lt;code&gt;make_response()&lt;/code&gt; &lt;/a&gt;包装返回表达式，并获取响应对象以对其进行修改，然后将其返回：</target>
        </trans-unit>
        <trans-unit id="ccb316b6f984e4a0d0734c1e9d3210e73911985c" translate="yes" xml:space="preserve">
          <source>You may still want to log that something fishy happened. This is where loggers come in handy. As of Flask 0.3 a logger is preconfigured for you to use.</source>
          <target state="translated">你可能还是想记录下发生了什么蹊跷的事情。这时记录器就派上用场了。从Flask 0.3开始,就有一个预配置的记录器供你使用。</target>
        </trans-unit>
        <trans-unit id="131a474e8d2db7a2ce99cea260c961a79a516952" translate="yes" xml:space="preserve">
          <source>You might find this helpful for unittests where you need the information from the context local around for a little longer. Make sure to properly &lt;code&gt;pop()&lt;/code&gt; the stack yourself in that situation, otherwise your unittests will leak memory.</source>
          <target state="translated">您可能会发现这对于单元测试很有用，因为在这种情况下，您需要从本地上下文中获取信息的时间更长一些。在这种情况下，请确保自己正确 &lt;code&gt;pop()&lt;/code&gt; 堆栈，否则单元测试将泄漏内存。</target>
        </trans-unit>
        <trans-unit id="4087f0e14a4fc2025a17cd9f490cadae80a8e78b" translate="yes" xml:space="preserve">
          <source>You might want to show custom error pages to the user when an error occurs. This can be done by registering error handlers.</source>
          <target state="translated">当发生错误时,您可能希望向用户显示自定义错误页面。这可以通过注册错误处理程序来实现。</target>
        </trans-unit>
        <trans-unit id="6c387a2ea009900c09409376e8f474b91f18a442" translate="yes" xml:space="preserve">
          <source>You should not use this function to load the actual configuration but rather configuration defaults. The actual config should be loaded with &lt;a href=&quot;#flask.Config.from_pyfile&quot;&gt;&lt;code&gt;from_pyfile()&lt;/code&gt;&lt;/a&gt; and ideally from a location not within the package because the package might be installed system wide.</source>
          <target state="translated">您不应使用此功能加载实际配置，而应使用配置默认值。实际的配置应该使用&lt;a href=&quot;#flask.Config.from_pyfile&quot;&gt; &lt;code&gt;from_pyfile()&lt;/code&gt; &lt;/a&gt;加载，并且理想情况下应从软件包之外的位置加载，因为软件包可能会在系统范围内安装。</target>
        </trans-unit>
        <trans-unit id="afed527d7fe63d12afd6f537cf3ead38ff61b4bc" translate="yes" xml:space="preserve">
          <source>You should then end up with something like that:</source>
          <target state="translated">那么你应该会有这样的结局。</target>
        </trans-unit>
        <trans-unit id="ca217b5e5b4a7e2a4079ec329762d36dfbd58657" translate="yes" xml:space="preserve">
          <source>Your application probably is a single .py file you symlinked into the site-packages folder. Please be aware that this does not work, instead you either have to put the folder into the pythonpath the file is stored in, or convert your application into a package.</source>
          <target state="translated">你的应用程序可能是一个单一的.py文件,你把它链接到site-packages文件夹中。请注意,这样做是行不通的,你必须把这个文件夹放到文件所在的python路径中,或者把你的应用程序转换成一个包。</target>
        </trans-unit>
        <trans-unit id="793e39ae6efa6796aa3799fc56e6e5b36f9bcd06" translate="yes" xml:space="preserve">
          <source>Your function must take one parameter, an instance of &lt;a href=&quot;#flask.Flask.response_class&quot;&gt;&lt;code&gt;response_class&lt;/code&gt;&lt;/a&gt; and return a new response object or the same (see &lt;a href=&quot;#flask.Flask.process_response&quot;&gt;&lt;code&gt;process_response()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">您的函数必须采用一个参数，即&lt;a href=&quot;#flask.Flask.response_class&quot;&gt; &lt;code&gt;response_class&lt;/code&gt; &lt;/a&gt;的实例，并返回一个新的响应对象或相同的对象（请参见&lt;a href=&quot;#flask.Flask.process_response&quot;&gt; &lt;code&gt;process_response()&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="3aa5c2fe53f1c07b3ac2fdcbca7b97d864161297" translate="yes" xml:space="preserve">
          <source>Your index.html template either has to extend a &lt;code&gt;layout.html&lt;/code&gt; template with jQuery loaded and the &lt;code&gt;$SCRIPT_ROOT&lt;/code&gt; variable set, or do that on the top. Here&amp;rsquo;s the HTML code needed for our little application (&lt;code&gt;index.html&lt;/code&gt;). Notice that we also drop the script directly into the HTML here. It is usually a better idea to have that in a separate script file:</source>
          <target state="translated">您的index.html模板要么必须扩展一个 &lt;code&gt;layout.html&lt;/code&gt; 了jQuery并设置了 &lt;code&gt;$SCRIPT_ROOT&lt;/code&gt; 变量的layout.html模板，要么在顶部执行此操作。这是我们的小应用程序（ &lt;code&gt;index.html&lt;/code&gt; ）所需的HTML代码。请注意，我们还在此处将脚本直接拖放到HTML中。通常最好将其放在单独的脚本文件中：</target>
        </trans-unit>
        <trans-unit id="9f0da206cf401eaf4f08889caadd9b50cfcd7e96" translate="yes" xml:space="preserve">
          <source>Your setup code always goes into a file named &lt;code&gt;setup.py&lt;/code&gt; next to your application. The name of the file is only convention, but because everybody will look for a file with that name, you better not change it.</source>
          <target state="translated">您的设置代码总是进入应用程序旁边的名为 &lt;code&gt;setup.py&lt;/code&gt; 的文件中。该文件的名称仅是约定俗成的名称，但是由于每个人都将使用该名称查找文件，因此最好不要更改它。</target>
        </trans-unit>
        <trans-unit id="56ddffc04b417958566e4f6b3cd5b2756a0b2d24" translate="yes" xml:space="preserve">
          <source>Your shell prompt will change to show the name of the activated environment.</source>
          <target state="translated">你的shell提示符将改变为显示激活环境的名称。</target>
        </trans-unit>
        <trans-unit id="00d6c9fb75aaf9f3bd3e1c0e3bc9ef2fba03017f" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;https://click.palletsprojects.com/en/7.x/api/#click.testing.Result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">一个&lt;a href=&quot;https://click.palletsprojects.com/en/7.x/api/#click.testing.Result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="2450b54b8a547a6079ccd10a7df3d2f50aefe2c1" translate="yes" xml:space="preserve">
          <source>a backend server overloaded</source>
          <target state="translated">后台服务器超载</target>
        </trans-unit>
        <trans-unit id="8b54e3e39c211c1d2ed964bb67b3ce7615ba831f" translate="yes" xml:space="preserve">
          <source>a dictionary with all options that were passed to the &lt;a href=&quot;#flask.Flask.register_blueprint&quot;&gt;&lt;code&gt;register_blueprint()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">具有传递给&lt;a href=&quot;#flask.Flask.register_blueprint&quot;&gt; &lt;code&gt;register_blueprint()&lt;/code&gt; &lt;/a&gt;方法的所有选项的字典。</target>
        </trans-unit>
        <trans-unit id="dc884e9bb787bf47ef4edbab4e6fa2e77f432c05" translate="yes" xml:space="preserve">
          <source>a filesystem is full</source>
          <target state="translated">满档</target>
        </trans-unit>
        <trans-unit id="b6cb00de8b8b56e0903b4feb0e38730544748a4c" translate="yes" xml:space="preserve">
          <source>a harddrive crashed</source>
          <target state="translated">硬盘死机</target>
        </trans-unit>
        <trans-unit id="65bbce0e91382b668dfe4edd6c02e9b88f6a133d" translate="yes" xml:space="preserve">
          <source>a new WSGI callable</source>
          <target state="translated">一个新的WSGI可调用</target>
        </trans-unit>
        <trans-unit id="4671c349c92f6e9fdad6ee703f94caae27ee6da4" translate="yes" xml:space="preserve">
          <source>a new response object or the same, has to be an instance of &lt;a href=&quot;#flask.Flask.response_class&quot;&gt;&lt;code&gt;response_class&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">新的响应对象或相同对象必须是&lt;a href=&quot;#flask.Flask.response_class&quot;&gt; &lt;code&gt;response_class&lt;/code&gt; &lt;/a&gt;的实例。</target>
        </trans-unit>
        <trans-unit id="e7673ad4b36808b0f7db947f79d48ddd260aa6fa" translate="yes" xml:space="preserve">
          <source>a place where extensions can store application specific state. For example this is where an extension could store database engines and similar things. For backwards compatibility extensions should register themselves like this:</source>
          <target state="translated">一个扩展可以存储应用程序特定状态的地方。例如,这是一个扩展可以存储数据库引擎和类似东西的地方。为了向后兼容,扩展应该像这样注册自己。</target>
        </trans-unit>
        <trans-unit id="0f14a3f9a798fcf78cff84703b5bb18e6a7c9473" translate="yes" xml:space="preserve">
          <source>a programming error in a library you are using</source>
          <target state="translated">您正在使用的库中出现了编程错误</target>
        </trans-unit>
        <trans-unit id="1e615b318ad6d9a03cb112c79943b5bdbdf834e1" translate="yes" xml:space="preserve">
          <source>a reference to the blueprint that created this setup state.</source>
          <target state="translated">对创建该设置状态的蓝图的引用。</target>
        </trans-unit>
        <trans-unit id="58d3625eb6247ee9032d7d40f1d9803825e9f0b9" translate="yes" xml:space="preserve">
          <source>a reference to the current application</source>
          <target state="translated">对当前申请的引用</target>
        </trans-unit>
        <trans-unit id="67cfe3f11b03b091a7c1b1d270b829fcfec74ce1" translate="yes" xml:space="preserve">
          <source>a string: in this case the object with that name will be imported</source>
          <target state="translated">一个字符串:在这种情况下,将导入带有该名称的对象。</target>
        </trans-unit>
        <trans-unit id="16108f3b3b62f856e8b62b403c6463f1dd1665de" translate="yes" xml:space="preserve">
          <source>a template has the ability to opt in/out autoescaping with the &lt;code&gt;{% autoescape %}&lt;/code&gt; tag.</source>
          <target state="translated">模板可以使用 &lt;code&gt;{% autoescape %}&lt;/code&gt; 标签选择启用/退出自动转义。</target>
        </trans-unit>
        <trans-unit id="dc89470cf6ccba89f0885c9b9c825819a09c012f" translate="yes" xml:space="preserve">
          <source>accepts UUID strings</source>
          <target state="translated">接受UUID字符串</target>
        </trans-unit>
        <trans-unit id="73920f8fabb6e4df93d4e0c0fb0007d5917c26c4" translate="yes" xml:space="preserve">
          <source>accepts any text without a slash (the default)</source>
          <target state="translated">接受任何没有斜线的文本(默认)。</target>
        </trans-unit>
        <trans-unit id="6aac90ae348c2df71fe04c7e2412a63945a41c85" translate="yes" xml:space="preserve">
          <source>accepts integers</source>
          <target state="translated">接受整数</target>
        </trans-unit>
        <trans-unit id="9fd792ff5273d01b2ec1a20e9ab350d77a4b393f" translate="yes" xml:space="preserve">
          <source>accepts positive floating point values</source>
          <target state="translated">接受正浮点值</target>
        </trans-unit>
        <trans-unit id="8c872cecc579af8eff46d4c028a80edc0a46c6d2" translate="yes" xml:space="preserve">
          <source>accepts positive integers</source>
          <target state="translated">接受正整数</target>
        </trans-unit>
        <trans-unit id="c4989e7b489e0e12580f117ad3fc69849ac688f4" translate="yes" xml:space="preserve">
          <source>alias of &lt;a href=&quot;#flask.ctx._AppCtxGlobals&quot;&gt;&lt;code&gt;flask.ctx._AppCtxGlobals&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#flask.ctx._AppCtxGlobals&quot;&gt; &lt;code&gt;flask.ctx._AppCtxGlobals&lt;/code&gt; 的&lt;/a&gt;别名</target>
        </trans-unit>
        <trans-unit id="cb35c19247ab4bad6b6e062619e8b816ffc02d6e" translate="yes" xml:space="preserve">
          <source>alias of &lt;a href=&quot;#flask.json.JSONDecoder&quot;&gt;&lt;code&gt;flask.json.JSONDecoder&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#flask.json.JSONDecoder&quot;&gt; &lt;code&gt;flask.json.JSONDecoder&lt;/code&gt; 的&lt;/a&gt;别名</target>
        </trans-unit>
        <trans-unit id="66651beedc7e81d8e380d4fcd15453801383a5a9" translate="yes" xml:space="preserve">
          <source>alias of &lt;a href=&quot;#flask.json.JSONEncoder&quot;&gt;&lt;code&gt;flask.json.JSONEncoder&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#flask.json.JSONEncoder&quot;&gt; &lt;code&gt;flask.json.JSONEncoder&lt;/code&gt; 的&lt;/a&gt;别名</target>
        </trans-unit>
        <trans-unit id="690767bb0c2669b4ca83625b253dc199e64911cc" translate="yes" xml:space="preserve">
          <source>alias of &lt;a href=&quot;#flask.sessions.NullSession&quot;&gt;&lt;code&gt;NullSession&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#flask.sessions.NullSession&quot;&gt; &lt;code&gt;NullSession&lt;/code&gt; 的&lt;/a&gt;别名</target>
        </trans-unit>
        <trans-unit id="09fa8da242d22107a8cfa434a0016e8a0bf9c7c3" translate="yes" xml:space="preserve">
          <source>alias of &lt;a href=&quot;#flask.sessions.SecureCookieSession&quot;&gt;&lt;code&gt;SecureCookieSession&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#flask.sessions.SecureCookieSession&quot;&gt; &lt;code&gt;SecureCookieSession&lt;/code&gt; 的&lt;/a&gt;别名</target>
        </trans-unit>
        <trans-unit id="a73b23479970f8c02dcbabd2cdd2419665a96c53" translate="yes" xml:space="preserve">
          <source>alias of &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.ImmutableList&quot;&gt;&lt;code&gt;werkzeug.datastructures.ImmutableList&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.ImmutableList&quot;&gt; &lt;code&gt;werkzeug.datastructures.ImmutableList&lt;/code&gt; 的&lt;/a&gt;别名</target>
        </trans-unit>
        <trans-unit id="66290f21838c7a15b714447f70aeef154dd517b4" translate="yes" xml:space="preserve">
          <source>alias of &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.ImmutableMultiDict&quot;&gt;&lt;code&gt;werkzeug.datastructures.ImmutableMultiDict&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.ImmutableMultiDict&quot;&gt; &lt;code&gt;werkzeug.datastructures.ImmutableMultiDict&lt;/code&gt; 的&lt;/a&gt;别名</target>
        </trans-unit>
        <trans-unit id="5281cc7d496c8f6ed91ea46c7f60bb89553290d2" translate="yes" xml:space="preserve">
          <source>alias of &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/http/#werkzeug.formparser.FormDataParser&quot;&gt;&lt;code&gt;werkzeug.formparser.FormDataParser&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/http/#werkzeug.formparser.FormDataParser&quot;&gt; &lt;code&gt;werkzeug.formparser.FormDataParser&lt;/code&gt; 的&lt;/a&gt;别名</target>
        </trans-unit>
        <trans-unit id="b053a6ac812a7c13e3ebf7e90705179dec419313" translate="yes" xml:space="preserve">
          <source>alias of &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/routing/#werkzeug.routing.Map&quot;&gt;&lt;code&gt;werkzeug.routing.Map&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/routing/#werkzeug.routing.Map&quot;&gt; &lt;code&gt;werkzeug.routing.Map&lt;/code&gt; 的&lt;/a&gt;别名</target>
        </trans-unit>
        <trans-unit id="cb0bbd02b31d9fed8c14bd74cf6ba51e71f570a6" translate="yes" xml:space="preserve">
          <source>alias of &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/routing/#werkzeug.routing.Rule&quot;&gt;&lt;code&gt;werkzeug.routing.Rule&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/routing/#werkzeug.routing.Rule&quot;&gt; &lt;code&gt;werkzeug.routing.Rule&lt;/code&gt; 的&lt;/a&gt;别名</target>
        </trans-unit>
        <trans-unit id="a073ce2245881b33c56658f828d261f7ec2651fc" translate="yes" xml:space="preserve">
          <source>alias of &lt;code&gt;flask.config.Config&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;flask.config.Config&lt;/code&gt; 的别名</target>
        </trans-unit>
        <trans-unit id="b5989ba4cef40c68a626cc81b29649588b8386ff" translate="yes" xml:space="preserve">
          <source>alias of &lt;code&gt;flask.templating.Environment&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;flask.templating.Environment&lt;/code&gt; 的别名</target>
        </trans-unit>
        <trans-unit id="33cf8b355af41b59f7b04114c18afec2353245b0" translate="yes" xml:space="preserve">
          <source>alias of &lt;code&gt;flask.wrappers.Request&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;flask.wrappers.Request&lt;/code&gt; 的别名</target>
        </trans-unit>
        <trans-unit id="2e4522e9eb3fd7d67055fefd7c35ad6ad1e6bff7" translate="yes" xml:space="preserve">
          <source>alias of &lt;code&gt;flask.wrappers.Response&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;flask.wrappers.Response&lt;/code&gt; 的别名</target>
        </trans-unit>
        <trans-unit id="5cab9c937ecf5c576b0fe8ca35ffd141b06af830" translate="yes" xml:space="preserve">
          <source>all the attached blueprints in a dictionary by name. Blueprints can be attached multiple times so this dictionary does not tell you how often they got attached.</source>
          <target state="translated">在字典中按名称显示所有附加的蓝图。蓝图可以被附加多次,所以这个字典不会告诉你它们被附加的频率。</target>
        </trans-unit>
        <trans-unit id="410160aaf22d9d2f8eb4888d810b9db5407aeaec" translate="yes" xml:space="preserve">
          <source>all the view functions (the ones with a &lt;a href=&quot;../../api/index#flask.Flask.route&quot;&gt;&lt;code&gt;route()&lt;/code&gt;&lt;/a&gt; decorator on top) have to be imported in the &lt;code&gt;__init__.py&lt;/code&gt; file. Not the object itself, but the module it is in. Import the view module &lt;strong&gt;after the application object is created&lt;/strong&gt;.</source>
          <target state="translated">所有视图函数（顶部带有&lt;a href=&quot;../../api/index#flask.Flask.route&quot;&gt; &lt;code&gt;route()&lt;/code&gt; &lt;/a&gt;装饰器的视图函数）都必须导入 &lt;code&gt;__init__.py&lt;/code&gt; 文件中。不是对象本身，而是对象所在的模块。&lt;strong&gt;在创建应用程序对象之后，&lt;/strong&gt;导入视图模块。</target>
        </trans-unit>
        <trans-unit id="49181a2e1d08486dbf83e366d4338f6ecd662c9e" translate="yes" xml:space="preserve">
          <source>an actual object reference: that object is used directly</source>
          <target state="translated">一个实际的对象引用:该对象被直接使用。</target>
        </trans-unit>
        <trans-unit id="9515b16847e6846c43ea51cc397430476b986fed" translate="yes" xml:space="preserve">
          <source>an internal cache for the flashed messages.</source>
          <target state="translated">一个内部缓存,用于存放闪过的信息。</target>
        </trans-unit>
        <trans-unit id="37e07b0c4e95ecdc752b79ffe45ae2bb1efa4a05" translate="yes" xml:space="preserve">
          <source>an object with all the attributes of the &lt;a href=&quot;#flask.g&quot;&gt;&lt;code&gt;flask.g&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">具有&lt;a href=&quot;#flask.g&quot;&gt; &lt;code&gt;flask.g&lt;/code&gt; &lt;/a&gt;对象的所有属性的对象。</target>
        </trans-unit>
        <trans-unit id="c7cfaa36598717cf613a98e5fdba5a094250b7df" translate="yes" xml:space="preserve">
          <source>and in your application.py (or equivalent):</source>
          <target state="translated">并在你的application.py(或等价物)中。</target>
        </trans-unit>
        <trans-unit id="8bf0d292878e774684dbb3719239f003be573ceb" translate="yes" xml:space="preserve">
          <source>as blueprints can be registered multiple times with the application and not everything wants to be registered multiple times on it, this attribute can be used to figure out if the blueprint was registered in the past already.</source>
          <target state="translated">由于蓝图可以在应用程序中注册多次,而不是所有的东西都想在上面注册多次,所以这个属性可以用来计算蓝图是否已经在过去注册过。</target>
        </trans-unit>
        <trans-unit id="8223feff2f9a7f1ef9e4349b456a5122ac32b65c" translate="yes" xml:space="preserve">
          <source>as long as you are using ASCII code points only (basically numbers, some special characters of Latin letters without umlauts or anything fancy) you can use regular string literals (&lt;code&gt;'Hello World'&lt;/code&gt;).</source>
          <target state="translated">只要您仅使用ASCII码点（基本上是数字，一些没有变音符号的拉丁字母的特殊字符或任何花哨的字符），就可以使用常规的字符串文字（ &lt;code&gt;'Hello World'&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e86120103ff7602f5f66345524e7915c16237124" translate="yes" xml:space="preserve">
          <source>autoescaping is enabled for all strings when using &lt;code&gt;render_template_string()&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;render_template_string()&lt;/code&gt; 时，会为所有字符串启用自动转义。</target>
        </trans-unit>
        <trans-unit id="182887cf6ecfdf4ef002369893829b23ee92ca32" translate="yes" xml:space="preserve">
          <source>autoescaping is enabled for all templates ending in &lt;code&gt;.html&lt;/code&gt;, &lt;code&gt;.htm&lt;/code&gt;, &lt;code&gt;.xml&lt;/code&gt; as well as &lt;code&gt;.xhtml&lt;/code&gt; when using &lt;code&gt;render_template()&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;render_template()&lt;/code&gt; 时，所有以 &lt;code&gt;.html&lt;/code&gt; ， &lt;code&gt;.htm&lt;/code&gt; ， &lt;code&gt;.xml&lt;/code&gt; 以及 &lt;code&gt;.xhtml&lt;/code&gt; 结尾的模板都启用了自动转义。</target>
        </trans-unit>
        <trans-unit id="f39411275ad23ada80267103f4b8daa8e988fdfe" translate="yes" xml:space="preserve">
          <source>bool. &lt;code&gt;True&lt;/code&gt; if able to load config, &lt;code&gt;False&lt;/code&gt; otherwise.</source>
          <target state="translated">布尔 如果能够加载配置，则为 &lt;code&gt;True&lt;/code&gt; ，否则为 &lt;code&gt;False&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0f39a7887e076551ace4670d7fe95e8998e83f6c" translate="yes" xml:space="preserve">
          <source>boolean that is &lt;code&gt;True&lt;/code&gt; if the application is served by a WSGI server that spawns multiple processes.</source>
          <target state="translated">如果应用程序由产生多个进程的WSGI服务器提供服务，则为 &lt;code&gt;True&lt;/code&gt; 的布尔值。</target>
        </trans-unit>
        <trans-unit id="2e6a184add8b1bccdad2e1862952a5a2b8016d2d" translate="yes" xml:space="preserve">
          <source>boolean that is &lt;code&gt;True&lt;/code&gt; if the application is served by a multithreaded WSGI server.</source>
          <target state="translated">如果应用程序由多线程WSGI服务器提供服务，则为 &lt;code&gt;True&lt;/code&gt; 的布尔值。</target>
        </trans-unit>
        <trans-unit id="f2b73ab96a72da4e8962bbd797c1f18d2b381964" translate="yes" xml:space="preserve">
          <source>boolean that is &lt;code&gt;True&lt;/code&gt; if the application will be executed only once in a process lifetime. This is the case for CGI for example, but it&amp;rsquo;s not guaranteed that the execution only happens one time.</source>
          <target state="translated">布尔值，如果应用程序在进程生命周期中仅执行一次，则为 &lt;code&gt;True&lt;/code&gt; 。例如，对于CGI就是这种情况，但不能保证执行仅发生一次。</target>
        </trans-unit>
        <trans-unit id="362782f1ef7f7ace335abfa298fd729c16783522" translate="yes" xml:space="preserve">
          <source>calling &lt;a href=&quot;../api/index#flask.Markup&quot;&gt;&lt;code&gt;Markup&lt;/code&gt;&lt;/a&gt; on data submitted by users</source>
          <target state="translated">在用户提交的数据上调用&lt;a href=&quot;../api/index#flask.Markup&quot;&gt; &lt;code&gt;Markup&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c5a3472f438c362a06e8293e2f245c81093c2143" translate="yes" xml:space="preserve">
          <source>create the form from the request &lt;code&gt;form&lt;/code&gt; value if the data is submitted via the HTTP &lt;code&gt;POST&lt;/code&gt; method and &lt;code&gt;args&lt;/code&gt; if the data is submitted as &lt;code&gt;GET&lt;/code&gt;.</source>
          <target state="translated">如果数据通过HTTP &lt;code&gt;POST&lt;/code&gt; 方法提交，则从请求 &lt;code&gt;form&lt;/code&gt; 值创建表单；如果数据以 &lt;code&gt;GET&lt;/code&gt; 提交，则从 &lt;code&gt;args&lt;/code&gt; 创建表单。</target>
        </trans-unit>
        <trans-unit id="b663758ff91fad1073f3728ff1e8a01b521d5831" translate="yes" xml:space="preserve">
          <source>default: Value to set and return if the attribute is not present.</source>
          <target state="translated">默认值。设置的值,如果属性不存在,则返回。</target>
        </trans-unit>
        <trans-unit id="8dad931d1e8bcc914af754ed12df94e2d4869138" translate="yes" xml:space="preserve">
          <source>encoding and decoding happens whenever you are talking over a protocol that requires bytes to be transmitted.</source>
          <target state="translated">只要你在需要传输字节的协议上交谈,就会发生编码和解码。</target>
        </trans-unit>
        <trans-unit id="6ac4ed31f78fb56c3738cfa3f8b4930eb281d8e4" translate="yes" xml:space="preserve">
          <source>generating HTML without the help of Jinja2</source>
          <target state="translated">在没有Jinja2帮助的情况下生成HTML</target>
        </trans-unit>
        <trans-unit id="a89dffe8101396723763af2159ebf1baae75cd12" translate="yes" xml:space="preserve">
          <source>get the unique cache key for the current request based on the current path.</source>
          <target state="translated">根据当前路径获取当前请求的唯一缓存密钥。</target>
        </trans-unit>
        <trans-unit id="feba9a44c7eacc6396c7902226b22869b66381e9" translate="yes" xml:space="preserve">
          <source>get the value for that key from the cache. If the cache returned something we will return that value.</source>
          <target state="translated">从缓存中获取该键的值。如果缓存返回了什么,我们将返回该值。</target>
        </trans-unit>
        <trans-unit id="535358cd1b423cdd42aef419fc6e36ef1e7acd71" translate="yes" xml:space="preserve">
          <source>header, which allows caching proxies to cache different pages for different users.</source>
          <target state="translated">头,允许缓存代理为不同的用户缓存不同的页面。</target>
        </trans-unit>
        <trans-unit id="d902eba506e195d6edc2f3d81eabe797b17e974b" translate="yes" xml:space="preserve">
          <source>hook in testing functionality so that you can deploy to an external server and run the test suite.</source>
          <target state="translated">测试功能中的钩子,以便您可以部署到外部服务器并运行测试套件。</target>
        </trans-unit>
        <trans-unit id="eb33e6cc47b061ed77bc263f202bed926cf18725" translate="yes" xml:space="preserve">
          <source>if more than one argument is passed, the arguments are passed to the &lt;a href=&quot;#flask.Flask.make_response&quot;&gt;&lt;code&gt;flask.Flask.make_response()&lt;/code&gt;&lt;/a&gt; function as tuple.</source>
          <target state="translated">如果传递了多个参数，则将这些参数作为元组传递给&lt;a href=&quot;#flask.Flask.make_response&quot;&gt; &lt;code&gt;flask.Flask.make_response()&lt;/code&gt; &lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="f76d1c9d9a5811fae8d97454c6ef3710e00b5e6f" translate="yes" xml:space="preserve">
          <source>if no arguments are passed, it creates a new response argument</source>
          <target state="translated">如果没有传递任何参数,它将创建一个新的响应参数。</target>
        </trans-unit>
        <trans-unit id="62e1874b111ae27261c412adc1ad2f49a1ff858a" translate="yes" xml:space="preserve">
          <source>if one argument is passed, &lt;a href=&quot;#flask.Flask.make_response&quot;&gt;&lt;code&gt;flask.Flask.make_response()&lt;/code&gt;&lt;/a&gt; is invoked with it.</source>
          <target state="translated">如果传递了一个参数，&lt;a href=&quot;#flask.Flask.make_response&quot;&gt; &lt;code&gt;flask.Flask.make_response()&lt;/code&gt; &lt;/a&gt;进行调用。</target>
        </trans-unit>
        <trans-unit id="417a342084b4091981d8749717e8ff0d5f0ef08c" translate="yes" xml:space="preserve">
          <source>if you are using non-Unicode characters in your Python files you have to tell Python which encoding your file uses. Again, I recommend UTF-8 for this purpose. To tell the interpreter your encoding you can put the &lt;code&gt;# -*- coding: utf-8 -*-&lt;/code&gt; into the first or second line of your Python source file.</source>
          <target state="translated">如果您在Python文件中使用非Unicode字符，则必须告诉Python文件使用哪种编码。再次，我建议为此目的使用UTF-8。要告诉解释器您的编码，您可以将 &lt;code&gt;# -*- coding: utf-8 -*-&lt;/code&gt; 放入Python源文件的第一行或第二行。</target>
        </trans-unit>
        <trans-unit id="1afc33da71707b0f0464cbc99720f3ee65ce0238" translate="yes" xml:space="preserve">
          <source>if you need anything else than ASCII in a string you have to mark this string as Unicode string by prefixing it with a lowercase &lt;code&gt;u&lt;/code&gt;. (like &lt;code&gt;u'H&amp;auml;nsel und Gretel'&lt;/code&gt;)</source>
          <target state="translated">如果字符串中除了ASCII以外还需要其他任何内容，则必须通过在其前面加上小写 &lt;code&gt;u&lt;/code&gt; 来将该字符串标记为Unicode字符串。（例如 &lt;code&gt;u'H&amp;auml;nsel und Gretel'&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="d65e5d5f8dec2384b8e97081da1cbfeb9d1c3094" translate="yes" xml:space="preserve">
          <source>inline MathML</source>
          <target state="translated">内嵌式MathML</target>
        </trans-unit>
        <trans-unit id="b6a430671d0a9588c117dd38b07d7158402b4b9e" translate="yes" xml:space="preserve">
          <source>inline SVG</source>
          <target state="translated">内嵌式SVG</target>
        </trans-unit>
        <trans-unit id="1456b45d5164c8075b3ef02a6029d6cc9194bce1" translate="yes" xml:space="preserve">
          <source>internally you will always use Unicode exclusively for text except for literal strings with only ASCII character points.</source>
          <target state="translated">在内部,除了只有ASCII字符点的文字字符串外,你将始终只使用Unicode来处理文本。</target>
        </trans-unit>
        <trans-unit id="e520ac39dfbeea0b1dcead65fd3537317fc76b94" translate="yes" xml:space="preserve">
          <source>it activates the automatic reloader</source>
          <target state="translated">它激活了自动重装器</target>
        </trans-unit>
        <trans-unit id="23826120fd321590f8403714453f3f7a4b0a2d08" translate="yes" xml:space="preserve">
          <source>it activates the debugger</source>
          <target state="translated">它激活了调试器</target>
        </trans-unit>
        <trans-unit id="3e12d260df8328be968a7e89a55d3cac7b7ae638" translate="yes" xml:space="preserve">
          <source>it enables the debug mode on the Flask application.</source>
          <target state="translated">它启用了Flask应用程序的调试模式。</target>
        </trans-unit>
        <trans-unit id="c27b409c0058ca262c00d4bc5b311b17467a5275" translate="yes" xml:space="preserve">
          <source>like &lt;code&gt;int&lt;/code&gt; but for floating point values</source>
          <target state="translated">像 &lt;code&gt;int&lt;/code&gt; 一样，但是对于浮点值</target>
        </trans-unit>
        <trans-unit id="f0d5190a8041319df229e98046658c7c08b2c0e6" translate="yes" xml:space="preserve">
          <source>like &lt;code&gt;string&lt;/code&gt; but also accepts slashes</source>
          <target state="translated">像 &lt;code&gt;string&lt;/code&gt; 但也接受斜线</target>
        </trans-unit>
        <trans-unit id="efce8c9011a808bb6bf9de1b830f8e261eb89c78" translate="yes" xml:space="preserve">
          <source>like the default but also accepts slashes</source>
          <target state="translated">和默认值一样,也接受斜线</target>
        </trans-unit>
        <trans-unit id="9a528abb653db79506821c6e058d0fee2b671cb1" translate="yes" xml:space="preserve">
          <source>matches one of the items provided</source>
          <target state="translated">符合所提供的项目之一</target>
        </trans-unit>
        <trans-unit id="deac6525f100db1c8ece6f318bb1f7313f8d8291" translate="yes" xml:space="preserve">
          <source>mod_wsgi (Apache)</source>
          <target state="translated">mod_wsgi (Apache)</target>
        </trans-unit>
        <trans-unit id="ab895fb15ede50af7ed7785e5743ecb4fef78106" translate="yes" xml:space="preserve">
          <source>network connection of the server to another system failed</source>
          <target state="translated">服务器与其他系统的网络连接失败</target>
        </trans-unit>
        <trans-unit id="b71754b52dc5a29619add8e188a3b2f8622750e6" translate="yes" xml:space="preserve">
          <source>otherwise the original function is called and the return value is stored in the cache for the timeout provided (by default 5 minutes).</source>
          <target state="translated">否则会调用原来的函数,并将返回值按规定的超时时间(默认为5分钟)存储在缓存中。</target>
        </trans-unit>
        <trans-unit id="829aff059e8c8831f8ffeab4ef912013147f6dc9" translate="yes" xml:space="preserve">
          <source>request object</source>
          <target state="translated">申请对象</target>
        </trans-unit>
        <trans-unit id="d09b53ab8c818d54dfe8427f21aede4595b31668" translate="yes" xml:space="preserve">
          <source>sending out HTML from uploaded files, never do that, use the &lt;code&gt;Content-Disposition: attachment&lt;/code&gt; header to prevent that problem.</source>
          <target state="translated">从上载的文件中发送HTML，但绝对不要这样做，请使用 &lt;code&gt;Content-Disposition: attachment&lt;/code&gt; 标头来防止该问题。</target>
        </trans-unit>
        <trans-unit id="ef88fe04c86583c8d352796166d79a400ea7aaf7" translate="yes" xml:space="preserve">
          <source>sending out textfiles from uploaded files. Some browsers are using content-type guessing based on the first few bytes so users could trick a browser to execute HTML.</source>
          <target state="translated">从上传的文件中发送文本文件。一些浏览器正在使用基于前几个字节的内容类型猜测,因此用户可以欺骗浏览器执行HTML。</target>
        </trans-unit>
        <trans-unit id="d250c538e374f94a199010467ed426bfdd515f38" translate="yes" xml:space="preserve">
          <source>should be served as &lt;code&gt;application/xhtml+xml&lt;/code&gt;</source>
          <target state="translated">应该作为 &lt;code&gt;application/xhtml+xml&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e0c6b34129d5ea370904f8e0b5557494ec05cd78" translate="yes" xml:space="preserve">
          <source>should be served as &lt;code&gt;text/html&lt;/code&gt;</source>
          <target state="translated">应该作为 &lt;code&gt;text/html&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a6c98c7baadee2946da9e6affe75e118bb0e9f49" translate="yes" xml:space="preserve">
          <source>specifies the rule for the subdomain in case subdomain matching is in use. If not specified the default subdomain is assumed.</source>
          <target state="translated">指定子域的规则,以备子域匹配时使用。如果没有指定,则假定为默认子域。</target>
        </trans-unit>
        <trans-unit id="ce6c00135f1bdc72b86079d54a87495e6bbdcb09" translate="yes" xml:space="preserve">
          <source>strict error handling</source>
          <target state="translated">严格的错误处理</target>
        </trans-unit>
        <trans-unit id="4ad0e1b83e7a464a4bb7b7665eadcf5823558111" translate="yes" xml:space="preserve">
          <source>the &lt;code&gt;Flask&lt;/code&gt; application object creation has to be in the &lt;code&gt;__init__.py&lt;/code&gt; file. That way each module can import it safely and the &lt;code&gt;__name__&lt;/code&gt; variable will resolve to the correct package.</source>
          <target state="translated">该 &lt;code&gt;Flask&lt;/code&gt; 的应用对象的创建必须在 &lt;code&gt;__init__.py&lt;/code&gt; 文件。这样，每个模块都可以安全地导入它，并且 &lt;code&gt;__name__&lt;/code&gt; 变量将解析为正确的包。</target>
        </trans-unit>
        <trans-unit id="0073219b5af8f0052a1b0b4675d5fdd8ca8e7adf" translate="yes" xml:space="preserve">
          <source>the URL adapter that was used to match the request.</source>
          <target state="translated">用于匹配请求的URL适配器。</target>
        </trans-unit>
        <trans-unit id="08af32314d28d8bb46aa1326c9ed906721f73187" translate="yes" xml:space="preserve">
          <source>the URL rule as string</source>
          <target state="translated">URL规则为字符串</target>
        </trans-unit>
        <trans-unit id="64113f45da91ceda3658fdd669c8b1def46ff802" translate="yes" xml:space="preserve">
          <source>the active Flask application.</source>
          <target state="translated">活动的Flask应用程序。</target>
        </trans-unit>
        <trans-unit id="a2cb4fcdc91c5610d90aff1aab70ff2b23f23575" translate="yes" xml:space="preserve">
          <source>the active session object.</source>
          <target state="translated">活动会话对象。</target>
        </trans-unit>
        <trans-unit id="963ff94953ee748c0917675522a8c9c7a8adc5da" translate="yes" xml:space="preserve">
          <source>the client terminated the request early and the application was still reading from the incoming data</source>
          <target state="translated">客户端提前终止请求,而应用程序仍在读取输入的数据。</target>
        </trans-unit>
        <trans-unit id="0bf35c8ee9bd6070016a1d57d69d358ef00d3ea0" translate="yes" xml:space="preserve">
          <source>the current request object.</source>
          <target state="translated">当前的请求对象。</target>
        </trans-unit>
        <trans-unit id="310e66995d61a1787a8ad1128858c9030822c7cb" translate="yes" xml:space="preserve">
          <source>the database server was overloaded and could not handle the query</source>
          <target state="translated">数据库服务器超载,无法处理查询。</target>
        </trans-unit>
        <trans-unit id="63489725fe632565a9f3b6b78724d1e49463af3a" translate="yes" xml:space="preserve">
          <source>the encoding for text on your website is UTF-8</source>
          <target state="translated">您网站上的文字编码为UTF-8。</target>
        </trans-unit>
        <trans-unit id="9073e0170afa49209bb1b656f622001db6580bd5" translate="yes" xml:space="preserve">
          <source>the endpoint for the registered URL rule. Flask itself assumes that the name of the view function is the name of the endpoint if not explicitly stated.</source>
          <target state="translated">注册URL规则的端点。如果没有明确说明,Flask本身假定视图函数的名称是端点的名称。</target>
        </trans-unit>
        <trans-unit id="b6fc3644392cebe10d467090e7649b5ea6a2430e" translate="yes" xml:space="preserve">
          <source>the function to call when serving a request to the provided endpoint. If this is not provided one can specify the function later by storing it in the &lt;a href=&quot;#flask.Flask.view_functions&quot;&gt;&lt;code&gt;view_functions&lt;/code&gt;&lt;/a&gt; dictionary with the endpoint as key.</source>
          <target state="translated">向提供的端点提供请求时调用的函数。如果未提供此功能，则可以稍后以端点为键将其存储在&lt;a href=&quot;#flask.Flask.view_functions&quot;&gt; &lt;code&gt;view_functions&lt;/code&gt; &lt;/a&gt;字典中来指定该功能。</target>
        </trans-unit>
        <trans-unit id="29ce9a6c8520d124b40219bafe921d69241783b5" translate="yes" xml:space="preserve">
          <source>the hash function to use for the signature. The default is sha1</source>
          <target state="translated">用于签名的哈希函数。默认为sha1</target>
        </trans-unit>
        <trans-unit id="c8391f181c288eadeca0aab6fa21c429a0b39b8b" translate="yes" xml:space="preserve">
          <source>the name of the itsdangerous supported key derivation. The default is hmac.</source>
          <target state="translated">itdangerous支持的密钥派生的名称,默认为hmac。默认为hmac。</target>
        </trans-unit>
        <trans-unit id="ec3bdab824e3eb590fac4319e902c2eae8721f99" translate="yes" xml:space="preserve">
          <source>the options to be forwarded to the underlying &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/routing/#werkzeug.routing.Rule&quot;&gt;&lt;code&gt;Rule&lt;/code&gt;&lt;/a&gt; object. A change to Werkzeug is handling of method options. methods is a list of methods this rule should be limited to (&lt;code&gt;GET&lt;/code&gt;, &lt;code&gt;POST&lt;/code&gt; etc.). By default a rule just listens for &lt;code&gt;GET&lt;/code&gt; (and implicitly &lt;code&gt;HEAD&lt;/code&gt;). Starting with Flask 0.6, &lt;code&gt;OPTIONS&lt;/code&gt; is implicitly added and handled by the standard request handling. They have to be specified as keyword arguments.</source>
          <target state="translated">要转发到基础&lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/routing/#werkzeug.routing.Rule&quot;&gt; &lt;code&gt;Rule&lt;/code&gt; &lt;/a&gt;对象的选项。对Werkzeug的更改是对方法选项的处理。方法是此规则应限制的方法列表（ &lt;code&gt;GET&lt;/code&gt; ， &lt;code&gt;POST&lt;/code&gt; 等）。默认情况下，一条规则仅侦听 &lt;code&gt;GET&lt;/code&gt; （隐式为 &lt;code&gt;HEAD&lt;/code&gt; ）。从Flask 0.6开始， &lt;code&gt;OPTIONS&lt;/code&gt; 由标准请求处理隐式添加和处理。必须将它们指定为关键字参数。</target>
        </trans-unit>
        <trans-unit id="bc9dd0effeaac7f439fc8993ec7630ae431c32ac" translate="yes" xml:space="preserve">
          <source>the return value from the view function. The view function must return a response. Returning &lt;code&gt;None&lt;/code&gt;, or the view ending without returning, is not allowed. The following types are allowed for &lt;code&gt;view_rv&lt;/code&gt;:</source>
          <target state="translated">视图函数的返回值。视图函数必须返回响应。不允许返回 &lt;code&gt;None&lt;/code&gt; ，或者视图不返回就结束。 &lt;code&gt;view_rv&lt;/code&gt; 允许以下类型：</target>
        </trans-unit>
        <trans-unit id="87770d3126b9858a2b1363aef7784412afb6ec28" translate="yes" xml:space="preserve">
          <source>the salt that should be applied on top of the secret key for the signing of cookie based sessions.</source>
          <target state="translated">用于签署基于cookie的会话的秘钥之上的盐。</target>
        </trans-unit>
        <trans-unit id="97a2093cc3750a62d3495b04049b131c0408ecac" translate="yes" xml:space="preserve">
          <source>the session interface to use. By default an instance of &lt;a href=&quot;#flask.sessions.SecureCookieSessionInterface&quot;&gt;&lt;code&gt;SecureCookieSessionInterface&lt;/code&gt;&lt;/a&gt; is used here.</source>
          <target state="translated">要使用的会话接口。默认情况下，此处使用&lt;a href=&quot;#flask.sessions.SecureCookieSessionInterface&quot;&gt; &lt;code&gt;SecureCookieSessionInterface&lt;/code&gt; &lt;/a&gt;的实例。</target>
        </trans-unit>
        <trans-unit id="627ebf7f4ac1a73c30ca2ba6fbdc47e9b0c01e1d" translate="yes" xml:space="preserve">
          <source>the test client that is used with when &lt;code&gt;test_client&lt;/code&gt; is used.</source>
          <target state="translated">使用 &lt;code&gt;test_client&lt;/code&gt; 时与之一起使用的测试客户端。</target>
        </trans-unit>
        <trans-unit id="2ec328b21f21f581a15283dc372ce0119a31529e" translate="yes" xml:space="preserve">
          <source>to access individual values from the form, access &lt;code&gt;form.&amp;lt;NAME&amp;gt;.data&lt;/code&gt;.</source>
          <target state="translated">要访问表单中的各个值，请访问 &lt;code&gt;form.&amp;lt;NAME&amp;gt;.data&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9dba151e97e915b82075cb812abc29b962582c25" translate="yes" xml:space="preserve">
          <source>to httpd 2.4 syntax</source>
          <target state="translated">到httpd 2.4语法</target>
        </trans-unit>
        <trans-unit id="99e1a478ed987013c90ad73a60f613f19fb46353" translate="yes" xml:space="preserve">
          <source>to validate the data, call the &lt;code&gt;validate()&lt;/code&gt; method, which will return &lt;code&gt;True&lt;/code&gt; if the data validates, &lt;code&gt;False&lt;/code&gt; otherwise.</source>
          <target state="translated">要验证数据，请调用 &lt;code&gt;validate()&lt;/code&gt; 方法，如果数据验证，该方法将返回 &lt;code&gt;True&lt;/code&gt; ，否则返回 &lt;code&gt;False&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4bb64abee6ddffb1dec2cea2a56e4250cbee775a" translate="yes" xml:space="preserve">
          <source>uWSGI</source>
          <target state="translated">uWSGI</target>
        </trans-unit>
        <trans-unit id="65b89a169808c59d7a3e2afadbdcb4a1c28c90a1" translate="yes" xml:space="preserve">
          <source>uWSGI is a deployment option on servers like &lt;a href=&quot;https://nginx.org/&quot;&gt;nginx&lt;/a&gt;, &lt;a href=&quot;https://www.lighttpd.net/&quot;&gt;lighttpd&lt;/a&gt;, and &lt;a href=&quot;http://cherokee-project.com/&quot;&gt;cherokee&lt;/a&gt;; see &lt;a href=&quot;../fastcgi/index&quot;&gt;FastCGI&lt;/a&gt; and &lt;a href=&quot;../wsgi-standalone/index&quot;&gt;Standalone WSGI Containers&lt;/a&gt; for other options. To use your WSGI application with uWSGI protocol you will need a uWSGI server first. uWSGI is both a protocol and an application server; the application server can serve uWSGI, FastCGI, and HTTP protocols.</source>
          <target state="translated">uWSGI是&lt;a href=&quot;https://nginx.org/&quot;&gt;nginx&lt;/a&gt;，&lt;a href=&quot;https://www.lighttpd.net/&quot;&gt;lighttpd&lt;/a&gt;和&lt;a href=&quot;http://cherokee-project.com/&quot;&gt;切诺基&lt;/a&gt;等服务器上的部署选项; 有关其他选项，请参见&lt;a href=&quot;../fastcgi/index&quot;&gt;FastCGI&lt;/a&gt;和&lt;a href=&quot;../wsgi-standalone/index&quot;&gt;独立WSGI容器&lt;/a&gt;。要将WSGI应用程序与uWSGI协议一起使用，您首先需要一台uWSGI服务器。uWSGI既是协议又是应用程序服务器；应用程序服务器可以服务uWSGI，FastCGI和HTTP协议。</target>
        </trans-unit>
        <trans-unit id="015e89d43f5824651d95ba9192a510412b0f886a" translate="yes" xml:space="preserve">
          <source>use the &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.FileStorage.save&quot;&gt;&lt;code&gt;save()&lt;/code&gt;&lt;/a&gt; method of the file to save the file permanently somewhere on the filesystem.</source>
          <target state="translated">使用文件的&lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.FileStorage.save&quot;&gt; &lt;code&gt;save()&lt;/code&gt; &lt;/a&gt;方法将文件永久保存在文件系统中的某个位置。</target>
        </trans-unit>
        <trans-unit id="5968b1444db31c860615aae7aabae156567a5e7d" translate="yes" xml:space="preserve">
          <source>you explicitly pass the request to the macro as parameter, or the attribute of the request object you are interested in.</source>
          <target state="translated">你明确地将请求作为参数传递给宏,或者你感兴趣的请求对象的属性。</target>
        </trans-unit>
        <trans-unit id="053e201b4099f3c3b39a0dce48070c615aa744a2" translate="yes" xml:space="preserve">
          <source>you import the macro &amp;ldquo;with context&amp;rdquo;.</source>
          <target state="translated">您可以&amp;ldquo;带上下文&amp;rdquo;导入宏。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
