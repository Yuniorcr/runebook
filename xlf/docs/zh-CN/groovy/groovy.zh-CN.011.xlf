<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="groovy">
    <body>
      <group id="groovy">
        <trans-unit id="2d5155e1d848b12837180c9ed5786b5553ee6024" translate="yes" xml:space="preserve">
          <source>Formats this date/time with the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_LOCAL_DATE&quot;&gt;DateTimeFormatter.ISO_LOCAL_DATE&lt;/a&gt; formatter.</source>
          <target state="translated">使用&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_LOCAL_DATE&quot;&gt;DateTimeFormatter.ISO_LOCAL_DATE&lt;/a&gt;格式化程序格式化此日期/时间。</target>
        </trans-unit>
        <trans-unit id="dcb18d0a72961b19aafa6592bb18fb33f43d50b0" translate="yes" xml:space="preserve">
          <source>Formats this date/time with the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_LOCAL_DATE_TIME&quot;&gt;DateTimeFormatter.ISO_LOCAL_DATE_TIME&lt;/a&gt; formatter and appends the zone's short name, e.g.</source>
          <target state="translated">使用&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_LOCAL_DATE_TIME&quot;&gt;DateTimeFormatter.ISO_LOCAL_DATE_TIME&lt;/a&gt;格式化程序格式化此日期/时间，并附加区域的简称，例如</target>
        </trans-unit>
        <trans-unit id="47c49966d4682db6282ea83b016dc27f813bd958" translate="yes" xml:space="preserve">
          <source>Formats this date/time with the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_LOCAL_DATE_TIME&quot;&gt;DateTimeFormatter.ISO_LOCAL_DATE_TIME&lt;/a&gt; formatter and appends the zone's short name, e.g. &lt;code&gt;2018-03-10T14:34:55.144EST&lt;/code&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_LOCAL_DATE_TIME&quot;&gt;DateTimeFormatter.ISO_LOCAL_DATE_TIME&lt;/a&gt;格式化程序格式化此日期/时间，并附加区域的简称，例如 &lt;code&gt;2018-03-10T14:34:55.144EST&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="21e35797c7a10f344df96d773b6510b90c4920c7" translate="yes" xml:space="preserve">
          <source>Formats this date/time with the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_LOCAL_DATE_TIME&quot;&gt;DateTimeFormatter.ISO_LOCAL_DATE_TIME&lt;/a&gt; formatter.</source>
          <target state="translated">使用&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_LOCAL_DATE_TIME&quot;&gt;DateTimeFormatter.ISO_LOCAL_DATE_TIME&lt;/a&gt;格式化程序格式化此日期/时间。</target>
        </trans-unit>
        <trans-unit id="a23cfaa0cfe4cc6a0902357e3781935c4e605ff1" translate="yes" xml:space="preserve">
          <source>Formats this date/time with the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_LOCAL_TIME&quot;&gt;DateTimeFormatter.ISO_LOCAL_TIME&lt;/a&gt; formatter and appends the zone's short name, e.g.</source>
          <target state="translated">使用&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_LOCAL_TIME&quot;&gt;DateTimeFormatter.ISO_LOCAL_TIME&lt;/a&gt;格式化程序格式化此日期/时间，并附加区域的简称，例如</target>
        </trans-unit>
        <trans-unit id="68802783f9245a52165e444d6c038c263a27567d" translate="yes" xml:space="preserve">
          <source>Formats this date/time with the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_LOCAL_TIME&quot;&gt;DateTimeFormatter.ISO_LOCAL_TIME&lt;/a&gt; formatter and appends the zone's short name, e.g. &lt;code&gt;14:34:55.144EST&lt;/code&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_LOCAL_TIME&quot;&gt;DateTimeFormatter.ISO_LOCAL_TIME&lt;/a&gt;格式化程序格式化此日期/时间，并附加区域的短名称，例如 &lt;code&gt;14:34:55.144EST&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="83978ecadf8bb78f4527632f55fe0ef2ace70e82" translate="yes" xml:space="preserve">
          <source>Formats this date/time with the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_LOCAL_TIME&quot;&gt;DateTimeFormatter.ISO_LOCAL_TIME&lt;/a&gt; formatter.</source>
          <target state="translated">使用&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_LOCAL_TIME&quot;&gt;DateTimeFormatter.ISO_LOCAL_TIME&lt;/a&gt;格式化程序格式化此日期/时间。</target>
        </trans-unit>
        <trans-unit id="69577d874e2cedc0f624db7318842f367d04da50" translate="yes" xml:space="preserve">
          <source>Formats this date/time with the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_OFFSET_DATE&quot;&gt;DateTimeFormatter.ISO_OFFSET_DATE&lt;/a&gt; formatter.</source>
          <target state="translated">使用&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_OFFSET_DATE&quot;&gt;DateTimeFormatter.ISO_OFFSET_DATE&lt;/a&gt;格式化程序格式化此日期/时间。</target>
        </trans-unit>
        <trans-unit id="5503fec537cc67c1f5028e5f9dfc8ffc542ca8a4" translate="yes" xml:space="preserve">
          <source>Formats this date/time with the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_OFFSET_DATE_TIME&quot;&gt;DateTimeFormatter.ISO_OFFSET_DATE_TIME&lt;/a&gt; formatter.</source>
          <target state="translated">使用&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_OFFSET_DATE_TIME&quot;&gt;DateTimeFormatter.ISO_OFFSET_DATE_TIME&lt;/a&gt;格式化程序格式化此日期/时间。</target>
        </trans-unit>
        <trans-unit id="c01303182af42901e8fe2ebadeab7c8d4ecb855c" translate="yes" xml:space="preserve">
          <source>Formats this date/time with the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_OFFSET_TIME&quot;&gt;DateTimeFormatter.ISO_OFFSET_TIME&lt;/a&gt; formatter.</source>
          <target state="translated">使用&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_OFFSET_TIME&quot;&gt;DateTimeFormatter.ISO_OFFSET_TIME&lt;/a&gt;格式化程序格式化此日期/时间。</target>
        </trans-unit>
        <trans-unit id="63e40e62983dd4196a9387976e4cefd73347f94c" translate="yes" xml:space="preserve">
          <source>Formats this date/time with the provided &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html&quot;&gt;DateTimeFormatter&lt;/a&gt; pattern.</source>
          <target state="translated">使用提供的&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html&quot;&gt;DateTimeFormatter&lt;/a&gt;模式格式化此日期/时间。</target>
        </trans-unit>
        <trans-unit id="bb48c806858158ddfff2a615ca300cde1a531541" translate="yes" xml:space="preserve">
          <source>Formats this time in the provided, localized &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/format/FormatStyle.html&quot;&gt;FormatStyle&lt;/a&gt;.</source>
          <target state="translated">这次使用提供的本地化&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/format/FormatStyle.html&quot;&gt;FormatStyle&lt;/a&gt;格式化。</target>
        </trans-unit>
        <trans-unit id="75a9c372983aa75d0db3b6c611d87f11d93689b3" translate="yes" xml:space="preserve">
          <source>Formats this time with the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_LOCAL_TIME&quot;&gt;DateTimeFormatter.ISO_LOCAL_TIME&lt;/a&gt; formatter.</source>
          <target state="translated">使用&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_LOCAL_TIME&quot;&gt;DateTimeFormatter.ISO_LOCAL_TIME&lt;/a&gt;格式化程序对此时间进行格式化。</target>
        </trans-unit>
        <trans-unit id="c8cc63241ea1b0fc65dec3af20598f7d9596fa27" translate="yes" xml:space="preserve">
          <source>Formats this time with the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_OFFSET_TIME&quot;&gt;DateTimeFormatter.ISO_OFFSET_TIME&lt;/a&gt; formatter.</source>
          <target state="translated">使用&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_OFFSET_TIME&quot;&gt;DateTimeFormatter.ISO_OFFSET_TIME&lt;/a&gt;格式化程序对此时间进行格式化。</target>
        </trans-unit>
        <trans-unit id="06f2a28eabe8db822bf046ca223ea1432692091a" translate="yes" xml:space="preserve">
          <source>Formats this time with the provided &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html&quot;&gt;DateTimeFormatter&lt;/a&gt; pattern.</source>
          <target state="translated">使用提供的&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html&quot;&gt;DateTimeFormatter&lt;/a&gt;模式格式化此时间。</target>
        </trans-unit>
        <trans-unit id="c8558b262bb2513543d91aec81a4aba697a8007f" translate="yes" xml:space="preserve">
          <source>Forms a list by stepping through the range by the indicated interval.</source>
          <target state="translated">形成一个列表,按指定的区间步进。</target>
        </trans-unit>
        <trans-unit id="f921758c6f5d5d30ee122ca8d0a7a6b9249ac182" translate="yes" xml:space="preserve">
          <source>Frequently, the template source will be in a file but here is a simple example providing the template as a string:</source>
          <target state="translated">通常情况下,模板源会在一个文件中,但这里有一个简单的例子,将模板作为一个字符串提供。</target>
        </trans-unit>
        <trans-unit id="21c869f40d73b68873b496793a70ef98b32c2949" translate="yes" xml:space="preserve">
          <source>FullBinding</source>
          <target state="translated">FullBinding</target>
        </trans-unit>
        <trans-unit id="f1e410ad1472b42cb42cc98962428637290b6706" translate="yes" xml:space="preserve">
          <source>Function</source>
          <target state="translated">Function</target>
        </trans-unit>
        <trans-unit id="5af2e61f4e542848a1e205f04337780f90f5b19c" translate="yes" xml:space="preserve">
          <source>Further information about customising grape behavior can be found on the Grape documentation page: &lt;a href=&quot;http://groovy-lang.org/grape.html&quot;&gt;http://groovy-lang.org/grape.html&lt;/a&gt;.</source>
          <target state="translated">有关自定义葡萄行为的更多信息，可以在Grape文档页面上找到：&lt;a href=&quot;http://groovy-lang.org/grape.html&quot;&gt;http&lt;/a&gt; : //groovy-lang.org/grape.html。</target>
        </trans-unit>
        <trans-unit id="e4798acec31b0c3138672afd9b48b537642d4082" translate="yes" xml:space="preserve">
          <source>Further information such as where artifacts are downloaded to, how to add additional resolvers, how to customise artifact resolution etc., can be found on the Grape documentation page: &lt;a href=&quot;http://groovy-lang.org/grape.html&quot;&gt;http://groovy-lang.org/grape.html&lt;/a&gt;.</source>
          <target state="translated">可以在Grape文档页面上找到更多信息，例如将工件下载到何处，如何添加其他解析器，如何自定义工件分辨率等，&lt;a href=&quot;http://groovy-lang.org/grape.html&quot;&gt;网址为&lt;/a&gt;：http : //groovy-lang.org/grape.html。</target>
        </trans-unit>
        <trans-unit id="0e8ffacc18eeaeb14cdd131d9cfb7198eb2d95e2" translate="yes" xml:space="preserve">
          <source>Further references on cloning:</source>
          <target state="translated">关于克隆的进一步参考资料。</target>
        </trans-unit>
        <trans-unit id="695111bf9ef1e680e21b1b0dc1726142c189faa6" translate="yes" xml:space="preserve">
          <source>GPathResult</source>
          <target state="translated">GPathResult</target>
        </trans-unit>
        <trans-unit id="80a99901216803700307ff510ed2ed2e60c3ddef" translate="yes" xml:space="preserve">
          <source>GRECLIPSE-805 Support for unicode escape sequences</source>
          <target state="translated">GRECLIPSE-805 支持unicode转义序列。</target>
        </trans-unit>
        <trans-unit id="d1077d035ea72a8ca64ab3abf345cfdd9b6efabf" translate="yes" xml:space="preserve">
          <source>GROOVY-7812</source>
          <target state="translated">GROOVY-7812</target>
        </trans-unit>
        <trans-unit id="2898cbe631c883f4ae3d2f80bf074997c12fe26e" translate="yes" xml:space="preserve">
          <source>GString</source>
          <target state="translated">GString</target>
        </trans-unit>
        <trans-unit id="d2451dceaea4a831c850bdb76b5281615b8a87d8" translate="yes" xml:space="preserve">
          <source>Gary Gregory</source>
          <target state="translated">Gary Gregory</target>
        </trans-unit>
        <trans-unit id="d93ba4949c406141711a0c8bf2c4a084c36fc3e6" translate="yes" xml:space="preserve">
          <source>Generally, it adds (if needed) a PropertyChangeSupport field and the needed add/removePropertyChangeListener methods to support the listeners.</source>
          <target state="translated">一般来说,它增加了(如果需要的话)一个PropertyChangeSupport字段和需要的add/removePropertyChangeListener方法来支持监听器。</target>
        </trans-unit>
        <trans-unit id="9028656a86bc52b2c84982ccf8bd24d211388cfa" translate="yes" xml:space="preserve">
          <source>Generally, it adds (if needed) a VetoableChangeSupport field and the needed add/removeVetoableChangeListener methods to support the listeners.</source>
          <target state="translated">一般来说,它增加了(如果需要的话)一个VetoableChangeSupport字段和需要的add/removeVetoableChangeListener方法来支持监听器。</target>
        </trans-unit>
        <trans-unit id="2e0f187b3bb439d387a964c0dd6bbe97d9517e09" translate="yes" xml:space="preserve">
          <source>Generally, it adds the needed add&amp;lt;Listener&amp;gt;, remove&amp;lt;Listener&amp;gt; and get&amp;lt;Listener&amp;gt;s methods to support the Java Beans API.</source>
          <target state="translated">通常，它将添加所需的add &amp;lt;Listener&amp;gt;，remove &amp;lt;Listener&amp;gt;和get &amp;lt;Listener&amp;gt; s方法以支持Java Beans API。</target>
        </trans-unit>
        <trans-unit id="4df52511d49e0202881d10aee5ea3bb1a6b5ccdb" translate="yes" xml:space="preserve">
          <source>Generate a call to the delegate object.</source>
          <target state="translated">生成对委托对象的调用。</target>
        </trans-unit>
        <trans-unit id="e3d3be670b873e01da15ad4c8acc448c6c336640" translate="yes" xml:space="preserve">
          <source>Generate a canEqual method to be used by equals.</source>
          <target state="translated">生成一个canEqual方法,供equals使用。</target>
        </trans-unit>
        <trans-unit id="dea1181f5a64c0f51095d026765ca752138190e5" translate="yes" xml:space="preserve">
          <source>Generate builder methods for properties from super classes.</source>
          <target state="translated">从超级类中为属性生成构建方法。</target>
        </trans-unit>
        <trans-unit id="b37047b3892e54b9f839d6df4dbc2da092e591e3" translate="yes" xml:space="preserve">
          <source>Generate documentation about the methods provided by the Groovy Development Kit that enhance the standard JDK classes.</source>
          <target state="translated">生成关于Groovy开发工具包提供的方法的文档,这些方法增强了标准JDK类。</target>
        </trans-unit>
        <trans-unit id="3fb9021398ae78c285eb929a7195d822500fd690" translate="yes" xml:space="preserve">
          <source>Generate next permutation (algorithm from Rosen p. 284)</source>
          <target state="translated">生成下一个排列组合(Rosen的算法,第284页)</target>
        </trans-unit>
        <trans-unit id="e5ddb635593b9309ede197a216bf07a43ec7e701" translate="yes" xml:space="preserve">
          <source>Generated key values can be accessed using array notation. For example, to return the second auto-generated column value of the third row, use &lt;code&gt;keys[3][1]&lt;/code&gt;. The method is designed to be used with SQL INSERT statements, but is not limited to them.</source>
          <target state="translated">可以使用数组符号访问生成的键值。例如，要返回第三行的第二个自动生成的列值，请使用 &lt;code&gt;keys[3][1]&lt;/code&gt; 。该方法旨在与SQL INSERT语句一起使用，但不仅限于此。</target>
        </trans-unit>
        <trans-unit id="7aa755fe4488d0c137c72563ce0db1751157d545" translate="yes" xml:space="preserve">
          <source>Generates JSON from objects. The Options builder can be used to configure an instance of a JsonGenerator.</source>
          <target state="translated">从对象生成JSON。选项生成器可以用来配置JsonGenerator的实例。</target>
        </trans-unit>
        <trans-unit id="f543455f9f4db5b5ddcc30b5a2acb7e5f2b94b45" translate="yes" xml:space="preserve">
          <source>Generates Java class versions of Groovy classes using ASM.</source>
          <target state="translated">使用ASM生成Groovy类的Java类版本。</target>
        </trans-unit>
        <trans-unit id="07d947963d9898fad05a5dd28eb21eb0156d379b" translate="yes" xml:space="preserve">
          <source>Generates Java classes for Groovy classes using ASM.</source>
          <target state="translated">使用ASM为Groovy类生成Java类。</target>
        </trans-unit>
        <trans-unit id="75ad1da4cc803fe95bbc8e20b98cd077f12db4fa" translate="yes" xml:space="preserve">
          <source>Generates Java stubs from Groovy sources.</source>
          <target state="translated">从Groovy源生成Java存根。</target>
        </trans-unit>
        <trans-unit id="32f4449f035e1908c1eef2b7ff9439ec51557126" translate="yes" xml:space="preserve">
          <source>Generates a Meta Object Protocol method, that is used to call a non public method, or to make a call to super.</source>
          <target state="translated">生成一个元对象协议方法,用于调用一个非公共方法,或者调用super。</target>
        </trans-unit>
        <trans-unit id="8163ae3f375c68cb95c1510bee3fb56f40402ed0" translate="yes" xml:space="preserve">
          <source>Generates a ModelMBeanOperationInfo object from a meta map provided.</source>
          <target state="translated">从提供的元映射中生成一个ModelMBeanOperationInfo对象。</target>
        </trans-unit>
        <trans-unit id="23e7111152a123c2389f56dee855e72994a68c78" translate="yes" xml:space="preserve">
          <source>Generates a detailed dump string of an object showing its class, hashCode and fields.</source>
          <target state="translated">生成一个对象的详细转储字符串,显示它的类、哈希码和字段。</target>
        </trans-unit>
        <trans-unit id="4d17f3df95f88479ac4ed99ff491e8587f06337a" translate="yes" xml:space="preserve">
          <source>Generates a list of ModelMBeanAttributeInfo from a list meta data Maps.</source>
          <target state="translated">从列表元数据Maps中生成ModelMBeanAttributeInfo列表。</target>
        </trans-unit>
        <trans-unit id="5d0419ea876c9ae44422e922c3a5dad4b750c17d" translate="yes" xml:space="preserve">
          <source>Generates a wildcard generic type in order to be used for checks against class nodes.</source>
          <target state="translated">生成一个通配符通用类型,以便用于对类节点进行检查。</target>
        </trans-unit>
        <trans-unit id="3f038ea51cd6d347579d0cb27ac1396b63f18d32" translate="yes" xml:space="preserve">
          <source>Generates a wildcard generic type in order to be used for checks against class nodes. See GenericsType#isCompatibleWith(org.codehaus.groovy.ast.ClassNode).</source>
          <target state="translated">生成一个通配符通用类型,以便用于对类节点进行检查。参见GenericsType#isCompatibleWith(org.codehaus.groovy.ast.ClassNode)。</target>
        </trans-unit>
        <trans-unit id="002cf0fb59b278467b84e3e6ec4529362e1c44ed" translate="yes" xml:space="preserve">
          <source>Generates an AST from the CST.</source>
          <target state="translated">从CST生成一个AST。</target>
        </trans-unit>
        <trans-unit id="88333a9a84d8b80c8d8b378d315c05405923f4be" translate="yes" xml:space="preserve">
          <source>Generates an AST from the CST. You can retrieve it with getAST().</source>
          <target state="translated">从CST中生成一个AST。你可以用getAST()来检索它。</target>
        </trans-unit>
        <trans-unit id="4e13f66b2b6ba9debb9330713b2f61762acab8e2" translate="yes" xml:space="preserve">
          <source>Generates byte code for constants.</source>
          <target state="translated">生成常量的字节码。</target>
        </trans-unit>
        <trans-unit id="dfca3f70f403c1c95f85aff59d606d21352f134f" translate="yes" xml:space="preserve">
          <source>Generates code for the &lt;code&gt;@AutoImplement&lt;/code&gt; annotation.</source>
          <target state="translated">为 &lt;code&gt;@AutoImplement&lt;/code&gt; 注释生成代码。</target>
        </trans-unit>
        <trans-unit id="8ce5319e11b768d812c335d1f38d900f0ab464a2" translate="yes" xml:space="preserve">
          <source>Generates code for the &lt;code&gt;@NotYetImplemented&lt;/code&gt; annotation.</source>
          <target state="translated">为 &lt;code&gt;@NotYetImplemented&lt;/code&gt; 注释生成代码。</target>
        </trans-unit>
        <trans-unit id="009cb95c5e7ceb5978b60d5e83e5993adc3f23c3" translate="yes" xml:space="preserve">
          <source>Generates code for the legacy &lt;code&gt;@NotYetImplemented&lt;/code&gt; annotation.</source>
          <target state="translated">为旧的 &lt;code&gt;@NotYetImplemented&lt;/code&gt; 注释生成代码。</target>
        </trans-unit>
        <trans-unit id="8d3c1543e4946f7f60b1982d788386b44dcf6dcc" translate="yes" xml:space="preserve">
          <source>Generates the bytecode to autobox the current value on the stack.</source>
          <target state="translated">在堆栈上生成自动装箱的字节码。</target>
        </trans-unit>
        <trans-unit id="7d2f9f2ce2448409dfbf2d083413e150437a18fb" translate="yes" xml:space="preserve">
          <source>Generates the bytecode to unbox the current value on the stack.</source>
          <target state="translated">生成字节码来解开堆栈上的当前值。</target>
        </trans-unit>
        <trans-unit id="aac85dbd510d776c34a55b34e0b5a72262a4a6d0" translate="yes" xml:space="preserve">
          <source>Get GroovydocHolder instance</source>
          <target state="translated">获取GroovydocHolder实例</target>
        </trans-unit>
        <trans-unit id="9370983ebdf1abc6391e3fba1f24eea19897f7d7" translate="yes" xml:space="preserve">
          <source>Get Quote to use when printing attributes.</source>
          <target state="translated">打印属性时要使用报价。</target>
        </trans-unit>
        <trans-unit id="74051e61fdc9c5bb32924d0936b390411e7d4e0e" translate="yes" xml:space="preserve">
          <source>Get a new GroovyCodeSource for a script which may be given as a location (isScript is true) or as text (isScript is false).</source>
          <target state="translated">为一个脚本获取一个新的GroovyCodeSource,这个新的GroovyCodeSource可以是一个位置(isScript is true),也可以是一个文本(isScript is false)。</target>
        </trans-unit>
        <trans-unit id="27071b9bb62c6e456992027b07274256b487711a" translate="yes" xml:space="preserve">
          <source>Get a particular initializer expression</source>
          <target state="translated">获取一个特定的初始化表达式</target>
        </trans-unit>
        <trans-unit id="f266159d3fb8547deff45a891e24194c5bff5231" translate="yes" xml:space="preserve">
          <source>Get a raw message from the resource bundles using the given code.</source>
          <target state="translated">使用给定的代码从资源包中获取原始信息。</target>
        </trans-unit>
        <trans-unit id="b140a66f6815f458db898f4e17ea444c9e5b6a37" translate="yes" xml:space="preserve">
          <source>Get a resource connection as a &lt;code&gt;URLConnection&lt;/code&gt; to retrieve a script from the &lt;code&gt;ResourceConnector&lt;/code&gt;.</source>
          <target state="translated">获取资源连接作为 &lt;code&gt;URLConnection&lt;/code&gt; ,以从 &lt;code&gt;ResourceConnector&lt;/code&gt; 检索脚本。</target>
        </trans-unit>
        <trans-unit id="334e383d6f091144c23f2de22cac5f87d49a3b04" translate="yes" xml:space="preserve">
          <source>Get all cached values</source>
          <target state="translated">获取所有缓存值</target>
        </trans-unit>
        <trans-unit id="c31c935318101542259d82a3e86199f207e5d4b4" translate="yes" xml:space="preserve">
          <source>Get all keys associated to cached values</source>
          <target state="translated">获取与缓存值相关联的所有键</target>
        </trans-unit>
        <trans-unit id="df8fa0fdbd699e3ac4cb2ea5b3a180a0c6f59c24" translate="yes" xml:space="preserve">
          <source>Get all properties including JavaBean pseudo properties matching JavaBean getter or setter conventions.</source>
          <target state="translated">获取所有属性,包括与JavaBean约定的getter或setter匹配的JavaBean伪属性。</target>
        </trans-unit>
        <trans-unit id="a19e894625d0e4fce2e1c8b505c6a9ff98b338e7" translate="yes" xml:space="preserve">
          <source>Get all properties including JavaBean pseudo properties matching getter conventions.</source>
          <target state="translated">获取所有属性,包括与getter约定相匹配的JavaBean伪属性。</target>
        </trans-unit>
        <trans-unit id="a9cd4a74570cd9d56cede687def413eedd0ad7ee" translate="yes" xml:space="preserve">
          <source>Get info about Properties (Java and Groovy alike).</source>
          <target state="translated">获取关于Properties的信息(Java和Groovy一样)。</target>
        </trans-unit>
        <trans-unit id="b2af1b04d202579346035eb98fa603547978ff7b" translate="yes" xml:space="preserve">
          <source>Get info about instance and class Methods that are dynamically added through Groovy.</source>
          <target state="translated">获取通过Groovy动态添加的实例和类方法的信息。</target>
        </trans-unit>
        <trans-unit id="020dba2a0a6e75a7042a14ff4cd3652f6fbbc6e0" translate="yes" xml:space="preserve">
          <source>Get info about usual Java instance and class Methods as well as Constructors.</source>
          <target state="translated">获取通常的Java实例和类方法以及构造函数的信息。</target>
        </trans-unit>
        <trans-unit id="5e31b6bf5645d2f0c2a9feda4f9b40ffd16a479c" translate="yes" xml:space="preserve">
          <source>Get info about usual Java public fields incl. constants.</source>
          <target state="translated">获取通常的Java公共字段的信息,包括常量。</target>
        </trans-unit>
        <trans-unit id="bba170575173e201113f2d9c37bdda5bff1f2f5d" translate="yes" xml:space="preserve">
          <source>Get property invocation type</source>
          <target state="translated">获取属性调用类型</target>
        </trans-unit>
        <trans-unit id="832448a5a8bf06852441522d42651e35a6ad8206" translate="yes" xml:space="preserve">
          <source>Get ref to table; the reference and the cells it accesses will be at least as fresh as from last use of barrierLock</source>
          <target state="translated">获取表格的引用;引用和它所访问的单元格将至少与上次使用 barrierLock 时一样新鲜。</target>
        </trans-unit>
        <trans-unit id="03943a19a768c28dc5271a4b3a4363213ee2eeb7" translate="yes" xml:space="preserve">
          <source>Get runtime groovydoc</source>
          <target state="translated">获取运行时groovydoc</target>
        </trans-unit>
        <trans-unit id="3e48aed1056b2d45025f0da6d94d1a0e80dac4f8" translate="yes" xml:space="preserve">
          <source>Get the &lt;code&gt;ClassLoader&lt;/code&gt; that will serve as the parent ClassLoader of the &lt;a href=&quot;../lang/groovyclassloader&quot;&gt;GroovyClassLoader&lt;/a&gt; in which scripts will be executed.</source>
          <target state="translated">获取 &lt;code&gt;ClassLoader&lt;/code&gt; ，将作为的父ClassLoader &lt;a href=&quot;../lang/groovyclassloader&quot;&gt;GroovyClassLoader&lt;/a&gt;其中的脚本将被执行。</target>
        </trans-unit>
        <trans-unit id="0b67d2e8632c203bedcb981f9f3192ecc4db075e" translate="yes" xml:space="preserve">
          <source>Get the &lt;code&gt;ClassLoader&lt;/code&gt; that will serve as the parent ClassLoader of the &lt;a href=&quot;../lang/groovyclassloader&quot;&gt;GroovyClassLoader&lt;/a&gt; in which scripts will be executed. By default, this is the ClassLoader that loaded the &lt;code&gt;GroovyScriptEngine&lt;/code&gt; class.</source>
          <target state="translated">获取 &lt;code&gt;ClassLoader&lt;/code&gt; ，将作为的父ClassLoader &lt;a href=&quot;../lang/groovyclassloader&quot;&gt;GroovyClassLoader&lt;/a&gt;其中的脚本将被执行。默认情况下，这是加载 &lt;code&gt;GroovyScriptEngine&lt;/code&gt; 类的ClassLoader 。</target>
        </trans-unit>
        <trans-unit id="2cea2344f567332cb6a2eb33db4e297b762fd782" translate="yes" xml:space="preserve">
          <source>Get the Class Properties of the object under inspection.</source>
          <target state="translated">获取被检测对象的类属性。</target>
        </trans-unit>
        <trans-unit id="3374cbf90727319305bf8f812be535b034644efa" translate="yes" xml:space="preserve">
          <source>Get the DST offset (if any) for the default locale and the given date.</source>
          <target state="translated">获取DST偏移量(如果有的话),用于默认地域和给定日期。</target>
        </trans-unit>
        <trans-unit id="74d296a1e331196ca618588055d2d62c08d3eca9" translate="yes" xml:space="preserve">
          <source>Get the GroovyClasses generated by compile().</source>
          <target state="translated">获取由compile()生成的GroovyClasses。</target>
        </trans-unit>
        <trans-unit id="b1dd989ff329bbd3f7ff645f18a810849737a70f" translate="yes" xml:space="preserve">
          <source>Get the JDBC datatype for this parameter.</source>
          <target state="translated">获取此参数的JDBC数据类型。</target>
        </trans-unit>
        <trans-unit id="269e41430b407c654555e63d3a44998124893830" translate="yes" xml:space="preserve">
          <source>Get the MetaClassRegistry that originates this change</source>
          <target state="translated">获取发起此次变更的MetaClassRegistry。</target>
        </trans-unit>
        <trans-unit id="fcc88f14e872552a34ca292cf09a2bde529fa28d" translate="yes" xml:space="preserve">
          <source>Get the absolute value</source>
          <target state="translated">获取绝对值</target>
        </trans-unit>
        <trans-unit id="4a9e99852664f474673ec12a2ba9d88576c299b6" translate="yes" xml:space="preserve">
          <source>Get the base script class name for the scripts (must derive from Script)</source>
          <target state="translated">获取脚本的基础脚本类名(必须源自脚本)</target>
        </trans-unit>
        <trans-unit id="15957a6df3b3e3334bcc8192ab3897f9d7257b20" translate="yes" xml:space="preserve">
          <source>Get the cached methodhandle. if the related methodhandle is not found in the inline cache, cache and return it.</source>
          <target state="translated">获取缓存的方法柄,如果在内联缓存中没有找到相关的方法柄,则缓存并返回。</target>
        </trans-unit>
        <trans-unit id="d912526e15b80c7a43d7ab29000114619b4c5f9d" translate="yes" xml:space="preserve">
          <source>Get the class of the scriptName in question, so that you can instantiate Groovy objects with caching and reloading.</source>
          <target state="translated">获取相关scriptName的类,这样就可以通过缓存和重载来实例化Groovy对象。</target>
        </trans-unit>
        <trans-unit id="2141297fde7787ad135c65d02cbec97e354b5d35" translate="yes" xml:space="preserve">
          <source>Get the class that is updated.</source>
          <target state="translated">获取更新的类。</target>
        </trans-unit>
        <trans-unit id="761f5b238f2d0ba8c3554ed462f76bca256cc88d" translate="yes" xml:space="preserve">
          <source>Get the configuration file used to customize the compilation configuration.</source>
          <target state="translated">获取用于自定义编译配置的配置文件。</target>
        </trans-unit>
        <trans-unit id="ad0c41e332296e5007c1c0c94a979cef356646af" translate="yes" xml:space="preserve">
          <source>Get the content of groovydoc</source>
          <target state="translated">获取groovydoc的内容</target>
        </trans-unit>
        <trans-unit id="a5b9b44b78dd9819c8c77e001a1c8fd523414d9c" translate="yes" xml:space="preserve">
          <source>Get the current time in seconds</source>
          <target state="translated">获取当前时间(秒)。</target>
        </trans-unit>
        <trans-unit id="a298712e3ad9b3db327d97448c0f6c9a510ce224" translate="yes" xml:space="preserve">
          <source>Get the description of the specified operation.</source>
          <target state="translated">获取指定操作的描述。</target>
        </trans-unit>
        <trans-unit id="227c616f5c467750613839bfd9eb8582b19f116b" translate="yes" xml:space="preserve">
          <source>Get the description of the specified operation. This returns a Collection since operations can be overloaded and one operationName can have multiple forms.</source>
          <target state="translated">获取指定操作的描述。这将返回一个集合,因为操作可以被重载,而且一个操作名可以有多种形式。</target>
        </trans-unit>
        <trans-unit id="94d34457e5289e64087ea868c055cb85690b64a3" translate="yes" xml:space="preserve">
          <source>Get the detail information of &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Throwable.html&quot;&gt;Throwable&lt;/a&gt; instance's stack trace</source>
          <target state="translated">获取&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Throwable.html&quot;&gt;Throwable&lt;/a&gt;实例的堆栈跟踪的详细信息</target>
        </trans-unit>
        <trans-unit id="363ee065d565d188d16f82a6e185fe9da6501691" translate="yes" xml:space="preserve">
          <source>Get the extension to use when searching for Groovy source files.</source>
          <target state="translated">获取搜索Groovy源文件时使用的扩展。</target>
        </trans-unit>
        <trans-unit id="b483bd4439128888c8e227a1f3280557ab4008bb" translate="yes" xml:space="preserve">
          <source>Get the getter method.</source>
          <target state="translated">得到的方法。</target>
        </trans-unit>
        <trans-unit id="16f04a5ab410c4dd194e4cfec8985f0f95a7b01a" translate="yes" xml:space="preserve">
          <source>Get the groovydoc</source>
          <target state="translated">获取groovydoc</target>
        </trans-unit>
        <trans-unit id="5513af0c3767d346ebc53d1917b2fe3ba801151e" translate="yes" xml:space="preserve">
          <source>Get the holder of the groovydoc</source>
          <target state="translated">获取groovydoc的持有人</target>
        </trans-unit>
        <trans-unit id="776b66943c9b9cd541588160f8e176ff054cd2fa" translate="yes" xml:space="preserve">
          <source>Get the href attribute.</source>
          <target state="translated">获取href属性。</target>
        </trans-unit>
        <trans-unit id="ddac83d941e9e50a2fa3365dc2c8237c5123c640" translate="yes" xml:space="preserve">
          <source>Get the initializer expressions</source>
          <target state="translated">获取初始化表达式</target>
        </trans-unit>
        <trans-unit id="95b52ad30078a6eec7f70c8354fb4741eded7273" translate="yes" xml:space="preserve">
          <source>Get the last hidden matcher that the system used to do a match.</source>
          <target state="translated">获取系统用来做匹配的最后一个隐藏匹配器。</target>
        </trans-unit>
        <trans-unit id="6e54817185acf09c6e10aa19d7d469d06ac2b3dd" translate="yes" xml:space="preserve">
          <source>Get the listfiles flag.</source>
          <target state="translated">获取列表文件标志。</target>
        </trans-unit>
        <trans-unit id="e6e816034e6da4736188bfcdaf919d01b5a381ae" translate="yes" xml:space="preserve">
          <source>Get the maximum number of rows to return in the ResultSet</source>
          <target state="translated">获取ResultSet中要返回的最大行数。</target>
        </trans-unit>
        <trans-unit id="ec4d1d94581114438e38b6b3b15c9e97c9ad5a9b" translate="yes" xml:space="preserve">
          <source>Get the new MetaClass</source>
          <target state="translated">获取新的MetaClass</target>
        </trans-unit>
        <trans-unit id="d543216820bf88afe0d59bf351eb2da29f1a1368" translate="yes" xml:space="preserve">
          <source>Get the old MetaClass</source>
          <target state="translated">获取旧的MetaClass</target>
        </trans-unit>
        <trans-unit id="21fcb9eeb90a1fb8314ef1210f368496e9f4c93f" translate="yes" xml:space="preserve">
          <source>Get the packages attribute.</source>
          <target state="translated">获取package属性。</target>
        </trans-unit>
        <trans-unit id="9bb72f72f1ccadda06402da42aa985230f8c198d" translate="yes" xml:space="preserve">
          <source>Get the parameterized type by searching the whole class hierarchy according to generics class and actual receiver.</source>
          <target state="translated">根据属类和实际接收方,通过搜索整个类的层次结构来获取参数化类型。</target>
        </trans-unit>
        <trans-unit id="ba1f560e0bbe4bc9879a2c5081f8215dd3cf7351" translate="yes" xml:space="preserve">
          <source>Get the parameterized type by searching the whole class hierarchy according to generics class and actual receiver. &lt;a href=&quot;#findParameterizedTypeFromCache(org.codehaus.groovy.ast.ClassNode,%20org.codehaus.groovy.ast.ClassNode,%20boolean)&quot;&gt;findParameterizedTypeFromCache(ClassNode, ClassNode, boolean)&lt;/a&gt; is strongly recommended for better performance.</source>
          <target state="translated">通过根据泛型类和实际接收者搜索整个类层次结构来获取参数化类型。强烈建议使用&lt;a href=&quot;#findParameterizedTypeFromCache(org.codehaus.groovy.ast.ClassNode,%20org.codehaus.groovy.ast.ClassNode,%20boolean)&quot;&gt;findParameterizedTypeFromCache（ClassNode，ClassNode，boolean），&lt;/a&gt;以获得更好的性能。</target>
        </trans-unit>
        <trans-unit id="4f34fa76b9b34aa526710ed4ffd4f551a8a2cf94" translate="yes" xml:space="preserve">
          <source>Get the property of the given object.</source>
          <target state="translated">获取给定对象的属性。</target>
        </trans-unit>
        <trans-unit id="b9dfd429130c9f32215eeb5fee433e316dfd0609" translate="yes" xml:space="preserve">
          <source>Get the result of the groovyc task (success or failure).</source>
          <target state="translated">获取groovyc任务的结果(成功或失败)。</target>
        </trans-unit>
        <trans-unit id="95f7e7b05569ef2ec0376c232ec22d7d0a04defd" translate="yes" xml:space="preserve">
          <source>Get the root cause of an exception and sanitize it for display to the user</source>
          <target state="translated">获取异常的根本原因,并对其进行处理,以便显示给用户。</target>
        </trans-unit>
        <trans-unit id="e49235ee2bcd5fb9e65d84b0b690d0bbe99303a7" translate="yes" xml:space="preserve">
          <source>Get the root node for lexing the document.</source>
          <target state="translated">获取用于解读文档的根节点。</target>
        </trans-unit>
        <trans-unit id="b9ac70f64ef0ab31c02282edb3aa22ad3e2cf7eb" translate="yes" xml:space="preserve">
          <source>Get the root node for lexing the document. Children can be added such that matching patterns can be further parsed if required.</source>
          <target state="translated">获取用于解析文档的根节点。可以添加子节点,以便在需要时进一步解析匹配的模式。</target>
        </trans-unit>
        <trans-unit id="7dec756fb3e1f399914b5c15a45f7f62d300dcce" translate="yes" xml:space="preserve">
          <source>Get the setter method.</source>
          <target state="translated">获取设定器方法。</target>
        </trans-unit>
        <trans-unit id="c266ee0f7b7eea700bfa23e48503e9ff7e73fe60" translate="yes" xml:space="preserve">
          <source>Get the size of the cache</source>
          <target state="translated">获取缓存的大小</target>
        </trans-unit>
        <trans-unit id="8bb90ea053a21098bf682c76efc3dbb9f1e50d9e" translate="yes" xml:space="preserve">
          <source>Get the strings of this GString.</source>
          <target state="translated">获取这个GString的字符串。</target>
        </trans-unit>
        <trans-unit id="e3f03a60c555c735fc9a37209d913769b45eb7fc" translate="yes" xml:space="preserve">
          <source>Get the text of the Groovy script at the given location.</source>
          <target state="translated">获取给定位置的Groovy脚本文本。</target>
        </trans-unit>
        <trans-unit id="2a662dcb99c228f8084e6b21bca0a84bdc74aa87" translate="yes" xml:space="preserve">
          <source>Get the text of the Groovy script at the given location. If the location is a file path and it does not exist as given, then &lt;a href=&quot;groovymain#huntForTheScriptFile(java.lang.String)&quot;&gt;GroovyMain.huntForTheScriptFile&lt;/a&gt; is called to try with some Groovy extensions appended. This method is not used to process scripts and is retained for backward compatibility. If you want to modify how GroovyMain processes scripts then use &lt;a href=&quot;groovymain#getScriptSource(boolean,%20java.lang.String)&quot;&gt;GroovyMain.getScriptSource&lt;/a&gt;.</source>
          <target state="translated">在给定位置获取Groovy脚本的文本。如果该位置是文件路径并且不存在给定的路径，则将&lt;a href=&quot;groovymain#huntForTheScriptFile(java.lang.String)&quot;&gt;调用GroovyMain.huntForTheScriptFile&lt;/a&gt;尝试附加一些Groovy扩展名。此方法不用于处理脚本，保留该方法是为了向后兼容。如果要修改GroovyMain处理脚本的方式，请使用&lt;a href=&quot;groovymain#getScriptSource(boolean,%20java.lang.String)&quot;&gt;GroovyMain.getScriptSource&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2862c981b26ee93bf7058decb2187081ceeaca7d" translate="yes" xml:space="preserve">
          <source>Get the type of array elements</source>
          <target state="translated">获取数组元素的类型</target>
        </trans-unit>
        <trans-unit id="ef642fee27b0acc6895f00a64c2958db95d13eca" translate="yes" xml:space="preserve">
          <source>Get the type of array elements by the dimension</source>
          <target state="translated">通过维度获取数组元素的类型。</target>
        </trans-unit>
        <trans-unit id="2959a19fa8b781df067c3752d0304e12d78fd30b" translate="yes" xml:space="preserve">
          <source>Get the value of the includeDestClasses property.</source>
          <target state="translated">获取includeDestClasses属性的值。</target>
        </trans-unit>
        <trans-unit id="e4749f6a54a66023614c3891ee35d369bf616043" translate="yes" xml:space="preserve">
          <source>Get the value of the indy flag.</source>
          <target state="translated">获取indy标志的值。</target>
        </trans-unit>
        <trans-unit id="ca995dc0e0c98abdc2659ca1b630c70158bf180f" translate="yes" xml:space="preserve">
          <source>Get the value.</source>
          <target state="translated">获取数值。</target>
        </trans-unit>
        <trans-unit id="342a45f0f35f5f622ed3aea2ca6550ad7ebc5050" translate="yes" xml:space="preserve">
          <source>Get the value. Note: In an entrySet or entrySet.iterator, unless the set or iterator is used under synchronization of the table as a whole (or you can otherwise guarantee lack of concurrent modification),</source>
          <target state="translated">获取值。注意:在一个 entrySet 或 entrySet.iterator 中,除非集或迭代器是在整个表的同步下使用的(或者你可以以其他方式保证缺乏并发修改)。</target>
        </trans-unit>
        <trans-unit id="de4d5ecc4fdcc604c6bb0a614e86956e6f3ce4e8" translate="yes" xml:space="preserve">
          <source>Get this property from the given object.</source>
          <target state="translated">从给定对象中获取此属性。</target>
        </trans-unit>
        <trans-unit id="5515e96eb2b467250658c15c7e46ee9c0cfdc70c" translate="yes" xml:space="preserve">
          <source>Get wrapper class for a given class.</source>
          <target state="translated">获取给定类的封装类。</target>
        </trans-unit>
        <trans-unit id="b0a9eee6b08d523f73ca33b715a2906856c416d9" translate="yes" xml:space="preserve">
          <source>Get wrapper class for a given class. If the class is for a primitive number type, then the wrapper class will be returned. If it is no primitive number type, we return the class itself.</source>
          <target state="translated">获取给定类的封装类。如果该类是一个基数类型,那么将返回封装类。如果不是基数类型的类,则返回类本身。</target>
        </trans-unit>
        <trans-unit id="e101234c81ab2a2dd35eacff0ea996cc079adad0" translate="yes" xml:space="preserve">
          <source>Gets a &lt;code&gt;BufferedReader&lt;/code&gt; (indeed a &lt;code&gt;LineNumberReader&lt;/code&gt;) from the &lt;code&gt;File&lt;/code&gt; specified in the constructor of &lt;code&gt;CharsetToolkit&lt;/code&gt; using the charset discovered or the default charset if an 8-bit &lt;code&gt;Charset&lt;/code&gt; is encountered.</source>
          <target state="translated">使用发现的字符集或默认的字符集（如果遇到8位 &lt;code&gt;Charset&lt;/code&gt; 集）从 &lt;code&gt;CharsetToolkit&lt;/code&gt; 构造函数中指定的 &lt;code&gt;File&lt;/code&gt; 中获取 &lt;code&gt;BufferedReader&lt;/code&gt; （实际上是 &lt;code&gt;LineNumberReader&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d19202feb825d4293d03514cb1e6a6703a1b1389" translate="yes" xml:space="preserve">
          <source>Gets a handle internally used to create MetaClass implementations WARNING: experimental code, likely to change soon</source>
          <target state="translated">获取内部用于创建MetaClass实现的句柄 WARNING:experimental code,likely to change soon.</target>
        </trans-unit>
        <trans-unit id="ed9a45a0d2401676dfd3a0a650d7156480734870" translate="yes" xml:space="preserve">
          <source>Gets a map containing the class variables referenced by this scope.</source>
          <target state="translated">获取一个包含这个作用域所引用的类变量的映射。</target>
        </trans-unit>
        <trans-unit id="461ce90cc4b30273d139131bf0afa95682d96591" translate="yes" xml:space="preserve">
          <source>Gets a map containing the class variables referenced by this scope. This not can not be modified.</source>
          <target state="translated">获取一个包含这个作用域引用的类变量的映射。这个映射不能被修改。</target>
        </trans-unit>
        <trans-unit id="447941a83625dc1f6773d3372425bb8bd5ddc369" translate="yes" xml:space="preserve">
          <source>Gets a map containing the variables declared in this scope.</source>
          <target state="translated">获取一个包含在此作用域中声明的变量的映射。</target>
        </trans-unit>
        <trans-unit id="1cd6efd2a44d2433da2320cbd1f91dbacdbad30a" translate="yes" xml:space="preserve">
          <source>Gets a map containing the variables declared in this scope. This map cannot be modified.</source>
          <target state="translated">获取一个包含在此作用域中声明的变量的映射。这个映射不能被修改。</target>
        </trans-unit>
        <trans-unit id="58f572b458c7e59316a38dfb6b62d5b88e4b8cf1" translate="yes" xml:space="preserve">
          <source>Gets a proxy instance that can be used as GroovyResultSet.</source>
          <target state="translated">获取一个可以作为GroovyResultSet使用的代理实例。</target>
        </trans-unit>
        <trans-unit id="fae8aef49db790ba5ba616babc04ff9b0b7653d2" translate="yes" xml:space="preserve">
          <source>Gets a snapshot of the current constant meta classes and returns it as Iterator.</source>
          <target state="translated">获取当前常量元类的快照,并将其作为Iterator返回。</target>
        </trans-unit>
        <trans-unit id="672c35978ea9ec826db7354a0f5ab2e225e787b2" translate="yes" xml:space="preserve">
          <source>Gets a snapshot of the current constant meta classes and returns it as Iterator. Modifications done using this Iterator will not cause a ConcurrentModificationException. If a MetaClass is removed using this Iterator, then the MetaClass will only be removed if the MetaClass was not replaced by another MetaClass in the meantime. If a MetaClass is added while using this Iterator, then it will be part of the Iteration. If a MetaClass replaces another constant meta class, then the Iteration might show two meta classes for the same class.</source>
          <target state="translated">获取当前常量元类的快照,并以Iterator的形式返回。使用该Iterator进行的修改不会引起并发ModificationException。如果使用这个Iterator删除一个MetaClass,那么只有当MetaClass在此期间没有被另一个MetaClass替换时,该MetaClass才会被删除。如果在使用这个迭代器时添加了一个MetaClass,那么它将成为迭代的一部分。如果一个MetaClass替换了另一个常量元类,那么Iteration可能会显示同一个类的两个元类。</target>
        </trans-unit>
        <trans-unit id="dabf05b8bcadba7fead40a74904efdb6a8be546e" translate="yes" xml:space="preserve">
          <source>Gets a value from the cache</source>
          <target state="translated">从缓存中获取一个值</target>
        </trans-unit>
        <trans-unit id="3e79a874af365c90715fef997f42731f419d81a9" translate="yes" xml:space="preserve">
          <source>Gets an array of all registered ConstantMetaClassListener instances.</source>
          <target state="translated">获取所有注册的ConstantMetaClassListener实例的数组。</target>
        </trans-unit>
        <trans-unit id="9ba842bb4f288262abc22d40a593955a62f2ccb4" translate="yes" xml:space="preserve">
          <source>Gets an iterator for the declared class variables.</source>
          <target state="translated">获取声明类变量的迭代器。</target>
        </trans-unit>
        <trans-unit id="4ae285e82aeaf5c74d54bbe97796a11cd5b7936d" translate="yes" xml:space="preserve">
          <source>Gets an iterator for the declared class variables. The remove operation is not supported.</source>
          <target state="translated">获取声明类变量的迭代器。不支持删除操作。</target>
        </trans-unit>
        <trans-unit id="734c6bf4e7a34d19c4d767cdcdf814d57bc576d5" translate="yes" xml:space="preserve">
          <source>Gets an iterator for the referenced class variables.</source>
          <target state="translated">获取引用的类变量的迭代器。</target>
        </trans-unit>
        <trans-unit id="1af62305fd3e2c92174a02a0abf044da2e8bf4b1" translate="yes" xml:space="preserve">
          <source>Gets an iterator for the referenced class variables. The remove operation is not supported.</source>
          <target state="translated">获取引用的类变量的迭代器。不支持删除操作。</target>
        </trans-unit>
        <trans-unit id="ea1201620c2bc2fe510ac6737cd4ec02b5595136" translate="yes" xml:space="preserve">
          <source>Gets an iterator for the referenced local variables.</source>
          <target state="translated">获取引用的局部变量的迭代器。</target>
        </trans-unit>
        <trans-unit id="a3b2b057b8d36d4ea51d05c0a6f41e1b74afe63c" translate="yes" xml:space="preserve">
          <source>Gets an iterator for the referenced local variables. The remove operation *is* supported.</source>
          <target state="translated">获取引用的局部变量的迭代器。支持删除操作。</target>
        </trans-unit>
        <trans-unit id="bf22ba9eab5c70c61361cf7ad823933295e9c59a" translate="yes" xml:space="preserve">
          <source>Gets methods from all interfaces.</source>
          <target state="translated">从所有接口中获取方法。</target>
        </trans-unit>
        <trans-unit id="07fce511989b09f089ae3f977f4505418dddfee2" translate="yes" xml:space="preserve">
          <source>Gets methods from all interfaces. Methods from interfaces visited early take precedence over later ones.</source>
          <target state="translated">获取所有接口的方法。早期访问过的接口的方法优先于后期的接口。</target>
        </trans-unit>
        <trans-unit id="48885f73c7cd5277e765456b73f0d3883a8ab484" translate="yes" xml:space="preserve">
          <source>Gets the 'from' value as a primitive integer.</source>
          <target state="translated">获取'from'值的原始整数。</target>
        </trans-unit>
        <trans-unit id="db961e9512d0136214b0466a55d7719592170d01" translate="yes" xml:space="preserve">
          <source>Gets the 'to' value as a primitive integer.</source>
          <target state="translated">获取'to'的值,作为一个原始整数。</target>
        </trans-unit>
        <trans-unit id="4a54a6e90aa93b2db8db2b3e3027dc055cec3591" translate="yes" xml:space="preserve">
          <source>Gets the CompilerConfiguration for this ProcessingUnit.</source>
          <target state="translated">获取此ProcessingUnit的CompilerConfiguration。</target>
        </trans-unit>
        <trans-unit id="a51f501f7eee681f5c42b1bd912d40af3f79f14b" translate="yes" xml:space="preserve">
          <source>Gets the Local part for this QName</source>
          <target state="translated">获取该QName的本地部分。</target>
        </trans-unit>
        <trans-unit id="bf84ed3fe07222fa128a8eb2fd1778a583215102" translate="yes" xml:space="preserve">
          <source>Gets the Namespace URI for this QName</source>
          <target state="translated">获取该QName的命名空间URI。</target>
        </trans-unit>
        <trans-unit id="bf61e99800d3da13722db2c6bb5d513653b1e6c4" translate="yes" xml:space="preserve">
          <source>Gets the Prefix for this QName</source>
          <target state="translated">获取该QName的前缀。</target>
        </trans-unit>
        <trans-unit id="2ae27ea487b28cc67e951a75a15cd5900b8d7941" translate="yes" xml:space="preserve">
          <source>Gets the actual type according to the placeholder name.</source>
          <target state="translated">根据占位符名称获取实际类型。</target>
        </trans-unit>
        <trans-unit id="69d552cee4320e2a5f5fe0216b2a2d5f7676ebca" translate="yes" xml:space="preserve">
          <source>Gets the called that is matchLevel stack frames before the call, ignoring MOP frames and desired exclude packages.</source>
          <target state="translated">获取被调用前的matchLevel栈帧,忽略MOP帧和所需的exclude包。</target>
        </trans-unit>
        <trans-unit id="d743c93d2966c3622d74ebea76b1ffc1f2d4747d" translate="yes" xml:space="preserve">
          <source>Gets the called that is matchLevel stack frames before the call, ignoring MOP frames.</source>
          <target state="translated">获取被调用前的matchLevel栈帧,忽略MOP帧。</target>
        </trans-unit>
        <trans-unit id="1f7d5770c14b91c352af3d836fb022900e312839" translate="yes" xml:space="preserve">
          <source>Gets the class where this method is declared</source>
          <target state="translated">获取声明此方法的类</target>
        </trans-unit>
        <trans-unit id="be9cbdb61ea46bf0b1b358396ea826987fbf3256" translate="yes" xml:space="preserve">
          <source>Gets the classpath to be used for this compilation.</source>
          <target state="translated">获取这次编译要使用的classpath。</target>
        </trans-unit>
        <trans-unit id="4d37389f4715b6d66a90fabeeb6ad1b825704bbe" translate="yes" xml:space="preserve">
          <source>Gets the classpath.</source>
          <target state="translated">获取classpath。</target>
        </trans-unit>
        <trans-unit id="4d828ab9b9870125204b889166e819c87ee5fc9c" translate="yes" xml:space="preserve">
          <source>Gets the code for a method (or constructor) as a block.</source>
          <target state="translated">以块的形式获取一个方法(或构造函数)的代码。</target>
        </trans-unit>
        <trans-unit id="32b8ba8b7f8385b790dba265d6598c64ff08dd82" translate="yes" xml:space="preserve">
          <source>Gets the code for a method (or constructor) as a block. If no code is found, an empty block will be returned. If a single non-block statement is found, a block containing that statement will be returned. Otherwise the existing block statement will be returned. The original &lt;code&gt;node&lt;/code&gt; is not modified.</source>
          <target state="translated">以块的形式获取方法（或构造函数）的代码。如果找不到代码，将返回一个空块。如果找到单个非阻塞语句，则将返回包含该语句的语句块。否则，将返回现有的block语句。原始 &lt;code&gt;node&lt;/code&gt; 未修改。</target>
        </trans-unit>
        <trans-unit id="447bfae08075f7e91f4b54089a6afd84ca09c4e5" translate="yes" xml:space="preserve">
          <source>Gets the current generated expression.</source>
          <target state="translated">获取当前生成的表达式。</target>
        </trans-unit>
        <trans-unit id="8eb70e8252422eaf25b0edd8a0283d018219761c" translate="yes" xml:space="preserve">
          <source>Gets the current result set.</source>
          <target state="translated">获取当前的结果集。</target>
        </trans-unit>
        <trans-unit id="ea8d1a625233675215ee88bafbc573eae5d6adbd" translate="yes" xml:space="preserve">
          <source>Gets the currently configured output writer.</source>
          <target state="translated">获取当前配置的输出写入器。</target>
        </trans-unit>
        <trans-unit id="438438682d0c675e3ce0f50d650a1b641aec7afc" translate="yes" xml:space="preserve">
          <source>Gets the currently configured source file encoding.</source>
          <target state="translated">获取当前配置的源文件编码。</target>
        </trans-unit>
        <trans-unit id="7e4736157c0b263cd0a1e595d17a1ba4cfae74fd" translate="yes" xml:space="preserve">
          <source>Gets the currently configured warning level.</source>
          <target state="translated">获取当前配置的警告级别。</target>
        </trans-unit>
        <trans-unit id="bc1b8f8272739056803e18109addea54fb76b95a" translate="yes" xml:space="preserve">
          <source>Gets the currently configured warning level. See &lt;a href=&quot;messages/warningmessage&quot;&gt;WarningMessage&lt;/a&gt; for level details.</source>
          <target state="translated">获取当前配置的警告级别。有关级别的详细信息，请参见&lt;a href=&quot;messages/warningmessage&quot;&gt;WarningMessage&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="47ef02e6c62d2360f8402078ab9c1162c83501c3" translate="yes" xml:space="preserve">
          <source>Gets the description for the specified type.</source>
          <target state="translated">获取指定类型的描述。</target>
        </trans-unit>
        <trans-unit id="08fc27cee42cfc8260206cd09ecedd8fca697adf" translate="yes" xml:space="preserve">
          <source>Gets the destination directory into which the java source files should be compiled.</source>
          <target state="translated">获取java源文件应该被编译到的目标目录。</target>
        </trans-unit>
        <trans-unit id="2078dbb3d275582998b637a13bc10fb5971ec78c" translate="yes" xml:space="preserve">
          <source>Gets the enforce8Bit flag, in case we do not want to ever get a US-ASCII encoding.</source>
          <target state="translated">获取execute8Bit标志,以防我们不想得到US-ASCII编码。</target>
        </trans-unit>
        <trans-unit id="f0d03484bdf2609310c7245d3b2e32b3ef564ac7" translate="yes" xml:space="preserve">
          <source>Gets the error stream from a process and reads it to keep the process from blocking due to a full buffer.</source>
          <target state="translated">从进程中获取错误流并读取它,以防止进程因缓冲区满而阻塞。</target>
        </trans-unit>
        <trans-unit id="2792b8762e4675c893ff8cf9a88309aa15ea06b2" translate="yes" xml:space="preserve">
          <source>Gets the error stream from a process and reads it to keep the process from blocking due to a full buffer. The processed stream data is appended to the supplied Appendable. A new Thread is started, so this method will return immediately.</source>
          <target state="translated">从进程中获取错误流并读取它,以防止进程因缓冲区满而阻塞。处理后的流数据被追加到提供的Appendable中。一个新的线程被启动,所以这个方法将立即返回。</target>
        </trans-unit>
        <trans-unit id="04c412f1cb8c3543650b95e1d7a460c9f82ecd98" translate="yes" xml:space="preserve">
          <source>Gets the error stream from a process and reads it to keep the process from blocking due to a full buffer. The processed stream data is appended to the supplied OutputStream. A new Thread is started, so this method will return immediately.</source>
          <target state="translated">从进程中获取错误流并读取它,以防止进程因缓冲区满而阻塞。处理后的流数据被追加到提供的OutputStream中。一个新的线程被启动,所以本方法将立即返回。</target>
        </trans-unit>
        <trans-unit id="f7fea4a98122dfa8631595c2bf2766320d9e7848" translate="yes" xml:space="preserve">
          <source>Gets the failonerror flag.</source>
          <target state="translated">获取failonerror标志。</target>
        </trans-unit>
        <trans-unit id="76d8021ffe7589327d076067b4c6d1c7b05c807a" translate="yes" xml:space="preserve">
          <source>Gets the field of this property</source>
          <target state="translated">获取该属性的字段</target>
        </trans-unit>
        <trans-unit id="99e440e184bc9d4b910244799606b344acb3f7cb" translate="yes" xml:space="preserve">
          <source>Gets the forceLookupUnnamedFiles flag.</source>
          <target state="translated">获取ForceLookupUnnamedFiles标志。</target>
        </trans-unit>
        <trans-unit id="417d83b74c72e6c8f3821910db9816dd54ce7cf5" translate="yes" xml:space="preserve">
          <source>Gets the immediate calling class, ignoring MOP frames.</source>
          <target state="translated">获取即时调用类,忽略MOP帧。</target>
        </trans-unit>
        <trans-unit id="89ecbd5a971c69519db9c46c16c0a07c214bb602" translate="yes" xml:space="preserve">
          <source>Gets the item by key from the mapping.</source>
          <target state="translated">从映射中按键获取项目。</target>
        </trans-unit>
        <trans-unit id="1d80a56b3a70dd92447f5eb2049c7c9764edcdee" translate="yes" xml:space="preserve">
          <source>Gets the joint compilation options for this configuration.</source>
          <target state="translated">获取此配置的联合编译选项。</target>
        </trans-unit>
        <trans-unit id="0c08f54464ae4c4853d3b8f19d25d1d47083774f" translate="yes" xml:space="preserve">
          <source>Gets the keepStubs flag.</source>
          <target state="translated">获取keepStubs标志。</target>
        </trans-unit>
        <trans-unit id="10b9365fcf14aaac85e8b5549a409df0c5844991" translate="yes" xml:space="preserve">
          <source>Gets the list of files to be compiled.</source>
          <target state="translated">获取要编译的文件列表。</target>
        </trans-unit>
        <trans-unit id="3531073bc19423a114fcd4780a31b1716ccd2d9b" translate="yes" xml:space="preserve">
          <source>Gets the loop block.</source>
          <target state="translated">获取循环块。</target>
        </trans-unit>
        <trans-unit id="d54defafd6dd831cade960fa9ebfc0f15674e550" translate="yes" xml:space="preserve">
          <source>Gets the memoryInitialSize flag.</source>
          <target state="translated">获取memoryInitialSize标志。</target>
        </trans-unit>
        <trans-unit id="05e083a013f1034fd3ecfe17345e0877af8b0770" translate="yes" xml:space="preserve">
          <source>Gets the memoryMaximumSize flag.</source>
          <target state="translated">获取memoryMaximumSize标志。</target>
        </trans-unit>
        <trans-unit id="2dbcab46c5e06bdc01e190c821e347f58006a38b" translate="yes" xml:space="preserve">
          <source>Gets the name for the getter for this property</source>
          <target state="translated">获取此属性的getter名称。</target>
        </trans-unit>
        <trans-unit id="81a59811fa5ef53cab9edcb76401c876dacde35c" translate="yes" xml:space="preserve">
          <source>Gets the name of the base class for scripts.</source>
          <target state="translated">获取脚本的基类名称。</target>
        </trans-unit>
        <trans-unit id="083f8ea768901551c57424813cdc8a3add079d12" translate="yes" xml:space="preserve">
          <source>Gets the name of the base class for scripts. It must be a subclass of Script.</source>
          <target state="translated">获取脚本的基类的名称。它必须是Script的一个子类。</target>
        </trans-unit>
        <trans-unit id="57da8864a5ce3f5da6a4ca408f353aaa642a7059" translate="yes" xml:space="preserve">
          <source>Gets the next character from the underlying reader, translating escapes as required.</source>
          <target state="translated">从底层读卡器中获取下一个字符,根据需要翻译逃逸。</target>
        </trans-unit>
        <trans-unit id="72e27b2813540a3357db31d152eeeb44ba1205ee" translate="yes" xml:space="preserve">
          <source>Gets the node meta data.</source>
          <target state="translated">获取节点元数据。</target>
        </trans-unit>
        <trans-unit id="2781095fa9a8b815e39cda34e4dac98d0d50a565" translate="yes" xml:space="preserve">
          <source>Gets the object being inspected.</source>
          <target state="translated">获取被检查的对象。</target>
        </trans-unit>
        <trans-unit id="fcc324cda60145f129228516391d90f077d05e8d" translate="yes" xml:space="preserve">
          <source>Gets the optimization options for this configuration.</source>
          <target state="translated">获取此配置的优化选项。</target>
        </trans-unit>
        <trans-unit id="a37e18c9e89dbf46d0008f96e21cde2e03116dee" translate="yes" xml:space="preserve">
          <source>Gets the output and error streams from a process and reads them to keep the process from blocking due to a full output buffer.</source>
          <target state="translated">从进程中获取输出流和错误流并读取它们,以防止进程因输出缓冲区满而阻塞。</target>
        </trans-unit>
        <trans-unit id="7c0e7f64a4dc9fefcd76afe51eabb4359c6a8088" translate="yes" xml:space="preserve">
          <source>Gets the output and error streams from a process and reads them to keep the process from blocking due to a full output buffer. The processed stream data is appended to the supplied Appendable. For this, two Threads are started, but join()ed, so we wait. As implied by the waitFor... name, we also wait until we finish as well. Finally, the input, output and error streams are closed.</source>
          <target state="translated">从进程中获取输出流和错误流,并读取它们以防止进程因输出缓冲区满而阻塞。处理后的流数据被追加到提供的Appendable中。为此,启动了两个Threads,但join()ed,所以我们要等待。正如waitFor...名称所暗示的那样,我们也会等待,直到完成。最后,输入、输出和错误流被关闭。</target>
        </trans-unit>
        <trans-unit id="d601d252f9556ca5d6ea70ebe79bce9ac3036242" translate="yes" xml:space="preserve">
          <source>Gets the output and error streams from a process and reads them to keep the process from blocking due to a full output buffer. The processed stream data is appended to the supplied Appendable. For this, two Threads are started, so this method will return immediately. The threads will not be join()ed, even if waitFor() is called. To wait for the output to be fully consumed call waitForProcessOutput().</source>
          <target state="translated">从进程中获取输出流和错误流,并读取它们以防止进程因输出缓冲区满而阻塞。处理后的流数据被追加到提供的Appendable中。为此,启动了两个线程,所以这个方法会立即返回。即使调用waitFor(),线程也不会被join()ed。如果要等待输出完全消耗,则调用waitForProcessOutput()。</target>
        </trans-unit>
        <trans-unit id="59bb4f0d7ad17b4cc7b8d5949162028ea56a1abc" translate="yes" xml:space="preserve">
          <source>Gets the output and error streams from a process and reads them to keep the process from blocking due to a full output buffer. The processed stream data is appended to the supplied OutputStream. For this, two Threads are started, but join()ed, so we wait. As implied by the waitFor... name, we also wait until we finish as well. Finally, the input, output and error streams are closed.</source>
          <target state="translated">从进程中获取输出流和错误流,并读取它们以防止进程因输出缓冲区满而阻塞。处理后的流数据被追加到提供的OutputStream中。为此,启动了两个Threads,但join()ed,所以我们要等待。正如waitFor...名称所暗示的那样,我们也会等待,直到完成。最后,输入、输出和错误流被关闭。</target>
        </trans-unit>
        <trans-unit id="ab8339b59e7e7f991731b7b86cf42412c380dd0e" translate="yes" xml:space="preserve">
          <source>Gets the output and error streams from a process and reads them to keep the process from blocking due to a full output buffer. The processed stream data is appended to the supplied OutputStream. For this, two Threads are started, so this method will return immediately. The threads will not be join()ed, even if waitFor() is called. To wait for the output to be fully consumed call waitForProcessOutput().</source>
          <target state="translated">从进程中获取输出流和错误流,并读取它们以防止进程因输出缓冲区满而阻塞。处理后的流数据被追加到提供的OutputStream中。为此,启动了两个线程,所以这个方法会立即返回。即使调用waitFor(),线程也不会被join()ed。如果要等待输出完全消耗,则调用waitForProcessOutput()。</target>
        </trans-unit>
        <trans-unit id="17c83ab5c7e67bfed9d6deb050577c4abbcf873a" translate="yes" xml:space="preserve">
          <source>Gets the output and error streams from a process and reads them to keep the process from blocking due to a full output buffer. The stream data is thrown away but blocking due to a full output buffer is avoided. Use this method if you don't care about the standard or error output and just want the process to run silently - use carefully however, because since the stream data is thrown away, it might be difficult to track down when something goes wrong. For this, two Threads are started, but join()ed, so we wait. As implied by the waitFor... name, we also wait until we finish as well. Finally, the output and error streams are closed.</source>
          <target state="translated">从进程中获取输出流和错误流,并读取它们以防止进程因输出缓冲区满而阻塞。流数据会被扔掉,但可以避免因输出缓冲区满而阻塞。如果你不关心标准或错误输出,而只是想让进程静静地运行,可以使用这个方法--但是要小心使用,因为由于流数据被扔掉了,所以当出现问题时可能很难追踪。为此,启动了两个Threads,但join()ed,所以我们要等待。正如waitFor...的名字所暗示的那样,我们也会等待,直到完成。最后,输出和错误流被关闭。</target>
        </trans-unit>
        <trans-unit id="53826823be7d7af657d063a3ae9fe9974e932086" translate="yes" xml:space="preserve">
          <source>Gets the output and error streams from a process and reads them to keep the process from blocking due to a full output buffer. The stream data is thrown away but blocking due to a full output buffer is avoided. Use this method if you don't care about the standard or error output and just want the process to run silently - use carefully however, because since the stream data is thrown away, it might be difficult to track down when something goes wrong. For this, two Threads are started, so this method will return immediately.</source>
          <target state="translated">从进程中获取输出流和错误流,并读取它们以防止进程因输出缓冲区满而阻塞。流数据会被扔掉,但可以避免因输出缓冲区满而阻塞。如果你不关心标准或错误输出,而只是想让进程静静地运行,可以使用这个方法--但是要小心使用,因为由于流数据被扔掉了,所以当出现问题时可能很难追踪。为此,要启动两个Threads,所以这个方法会立即返回。</target>
        </trans-unit>
        <trans-unit id="675a71a605f6c44e31b6838e849232e273f163bc" translate="yes" xml:space="preserve">
          <source>Gets the output stream from a process and reads it to keep the process from blocking due to a full output buffer.</source>
          <target state="translated">从进程中获取输出流并读取它,以防止进程因输出缓冲区满而阻塞。</target>
        </trans-unit>
        <trans-unit id="ca8b0c8be22a06052055685ac1fa9f8468c53644" translate="yes" xml:space="preserve">
          <source>Gets the output stream from a process and reads it to keep the process from blocking due to a full output buffer. The processed stream data is appended to the supplied Appendable. A new Thread is started, so this method will return immediately.</source>
          <target state="translated">从进程中获取输出流并读取它,以防止进程因输出缓冲区满而阻塞。处理后的流数据被追加到提供的Appendable中。一个新的线程被启动,所以这个方法会立即返回。</target>
        </trans-unit>
        <trans-unit id="8fc81f57151278912a7a37a9442c0a09ee0b2072" translate="yes" xml:space="preserve">
          <source>Gets the output stream from a process and reads it to keep the process from blocking due to a full output buffer. The processed stream data is appended to the supplied OutputStream. A new Thread is started, so this method will return immediately.</source>
          <target state="translated">从进程中获取输出流并读取它,以防止进程因输出缓冲区满而阻塞。处理后的流数据被追加到提供的OutputStream中。一个新的线程被启动,所以这个方法将立即返回。</target>
        </trans-unit>
        <trans-unit id="1ee646235cacb2a4855075bcd0f51c5f062c925f" translate="yes" xml:space="preserve">
          <source>Gets the parameter and return types of the abstract method of SAM.</source>
          <target state="translated">获取SAM的抽象方法的参数和返回类型。</target>
        </trans-unit>
        <trans-unit id="146d40bfa134ca57e5a065babe4c3ad868d61f68" translate="yes" xml:space="preserve">
          <source>Gets the parameter and return types of the abstract method of SAM. If the abstract method is not parameterized, we will get generics placeholders, e.g. T, U For example, the abstract method of &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html&quot;&gt;Function&lt;/a&gt; is</source>
          <target state="translated">获取SAM抽象方法的参数和返回类型。如果未对抽象方法进行参数化，则将获得泛型占位符，例如T，U。例如，&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html&quot;&gt;Function&lt;/a&gt;的抽象方法为</target>
        </trans-unit>
        <trans-unit id="624a2f5a45cf2e99efcc8e5b23c3029a38648026" translate="yes" xml:space="preserve">
          <source>Gets the resultSetConcurrency for statements created using the connection.</source>
          <target state="translated">获取使用该连接创建的语句的resultSetConcurrency。</target>
        </trans-unit>
        <trans-unit id="ae4069be742634979087e6ff7365c7cd0d81349f" translate="yes" xml:space="preserve">
          <source>Gets the resultSetHoldability for statements created using the connection.</source>
          <target state="translated">Gets the resultSetHoldability for statements created using the connection.</target>
        </trans-unit>
        <trans-unit id="20e785689c7fa21d183fc77eb491cc63a4434bea" translate="yes" xml:space="preserve">
          <source>Gets the resultSetType for statements created using the connection.</source>
          <target state="translated">获取使用该连接创建的语句的结果集类型。</target>
        </trans-unit>
        <trans-unit id="338c7b5308418f6b13557d6d79948e3e76f4638c" translate="yes" xml:space="preserve">
          <source>Gets the setter for the getter for this property.</source>
          <target state="translated">获取此属性的getter的设置器。</target>
        </trans-unit>
        <trans-unit id="bfc1fbae4f3c4eb931eb8a05f9416c9f9fdc58d5" translate="yes" xml:space="preserve">
          <source>Gets the source dirs to find the source java files.</source>
          <target state="translated">获取源文件目录,以找到源java文件。</target>
        </trans-unit>
        <trans-unit id="223548b295dc81218ca159e15b3a61ec0d3c6c9a" translate="yes" xml:space="preserve">
          <source>Gets the sourcepath to be used for this compilation.</source>
          <target state="translated">获取本次编译要使用的源路径。</target>
        </trans-unit>
        <trans-unit id="86ad9859676e01d4664377485673406626356191" translate="yes" xml:space="preserve">
          <source>Gets the strategy which the closure uses to resolve methods and properties</source>
          <target state="translated">获取闭包用来解析方法和属性的策略。</target>
        </trans-unit>
        <trans-unit id="f7f19a8458b29450f901a7417b5631e619815969" translate="yes" xml:space="preserve">
          <source>Gets the stub directory into which the Java source stub files should be generated</source>
          <target state="translated">获取生成Java源码存根文件的存根目录。</target>
        </trans-unit>
        <trans-unit id="81b3e3cd445397b02248adfce0b162a512eb00d8" translate="yes" xml:space="preserve">
          <source>Gets the target directory for writing classes.</source>
          <target state="translated">获取编写类的目标目录。</target>
        </trans-unit>
        <trans-unit id="50d71c4ef104bbc7a19f09342c3f3fb2489454e2" translate="yes" xml:space="preserve">
          <source>Gets the template created by the underlying engine parsing the request.</source>
          <target state="translated">获取由解析请求的底层引擎创建的模板。</target>
        </trans-unit>
        <trans-unit id="a6d33e0debf4fcf88cb0d1d9b8ab97eb6aa7cd0c" translate="yes" xml:space="preserve">
          <source>Gets the url of the jar file/source file containing the specified class</source>
          <target state="translated">获取包含指定类的jar文件/源文件的url。</target>
        </trans-unit>
        <trans-unit id="157b6627534d8fbd65d7ff73f4d2b8631087d685" translate="yes" xml:space="preserve">
          <source>Gets the value of the designated column in the current row as an &lt;code&gt;Object&lt;/code&gt;.</source>
          <target state="translated">以 &lt;code&gt;Object&lt;/code&gt; 的形式获取当前行中指定列的值。</target>
        </trans-unit>
        <trans-unit id="0c28937a34d3519743f8de3e98a0259c86b3c74a" translate="yes" xml:space="preserve">
          <source>Gets the value of the designated column in the current row of as an &lt;code&gt;Object&lt;/code&gt;.</source>
          <target state="translated">以 &lt;code&gt;Object&lt;/code&gt; 的形式获取当前行中指定列的值。</target>
        </trans-unit>
        <trans-unit id="a356fec98f7549642a09e764b7e1164c6885af0a" translate="yes" xml:space="preserve">
          <source>Gets the verbose flag.</source>
          <target state="translated">获取verbose标志。</target>
        </trans-unit>
        <trans-unit id="1676c78da5aa4adae01d99abc161a39ffeb04853" translate="yes" xml:space="preserve">
          <source>Gets the visibility modifiers for the property as defined by the getter and setter methods.</source>
          <target state="translated">获取由getter和setter方法定义的属性的可见性修改器。</target>
        </trans-unit>
        <trans-unit id="5558add982dc955038f5dca3de1fa4a12b4c9f0d" translate="yes" xml:space="preserve">
          <source>Gets the xml context of Ant used while creating tasks</source>
          <target state="translated">获取创建任务时使用的Ant的xml上下文。</target>
        </trans-unit>
        <trans-unit id="5c45b293bcd3b8efb2364f3f94cb4435c0128395" translate="yes" xml:space="preserve">
          <source>Gets whether or not the ant classpath is to be included in the classpath.</source>
          <target state="translated">获取是否将蚂蚁classpath包含在classpath中。</target>
        </trans-unit>
        <trans-unit id="253f413ee0891991955c14a7feb52f4725291154" translate="yes" xml:space="preserve">
          <source>Gets whether or not the java runtime should be included in this task's classpath.</source>
          <target state="translated">获取java运行时是否应该包含在这个任务的classpath中。</target>
        </trans-unit>
        <trans-unit id="58e642bacdb6fab75020ba47ea6aa134d2d7d9ab" translate="yes" xml:space="preserve">
          <source>Getter - returns event thrown by emitter.</source>
          <target state="translated">Getter-返回发射器抛出的事件。</target>
        </trans-unit>
        <trans-unit id="3b30b6e8527e64a306adbf0f7b01d70fa77544b1" translate="yes" xml:space="preserve">
          <source>Give me the items in the map without hydrating the map.</source>
          <target state="translated">给我地图中的物品,不给地图补充水分。</target>
        </trans-unit>
        <trans-unit id="bda17da048264e5f1fa60e57950b380b176d3cb8" translate="yes" xml:space="preserve">
          <source>Give me the items in the map without hydrating the map. Realize that the array is likely larger than the length so array items can be null.</source>
          <target state="translated">给我地图中的项目,不给地图注水。要知道,数组很可能大于长度,所以数组项目可以为空。</target>
        </trans-unit>
        <trans-unit id="473df60d368716f835e4d68e03b08fc66e186263" translate="yes" xml:space="preserve">
          <source>Given a class node, if this class node implements a trait, then generate all the appropriate code which delegates calls to the trait.</source>
          <target state="translated">给定一个类节点,如果这个类节点实现了一个特质,那么就生成所有适当的代码,这些代码委托给特质调用。</target>
        </trans-unit>
        <trans-unit id="2b19d2d6c568ded549fd63b10c0f3e6accdfeda0" translate="yes" xml:space="preserve">
          <source>Given a class node, if this class node implements a trait, then generate all the appropriate code which delegates calls to the trait. It is safe to call this method on a class node which does not implement a trait.</source>
          <target state="translated">给定一个类节点,如果这个类节点实现了一个特质,那么就生成所有适当的代码来委托调用这个特质。在一个没有实现特质的类节点上调用这个方法是安全的。</target>
        </trans-unit>
        <trans-unit id="e8277e079d32e3c6e49e9a7580fe3d173ac05505" translate="yes" xml:space="preserve">
          <source>Given a generics type representing SomeClass&amp;lt;T,V&amp;gt; and a resolved placeholder map, returns a new generics type for which placeholders are resolved recursively.</source>
          <target state="translated">给定表示SomeClass &amp;lt;T，V&amp;gt;的泛型类型和已解析的占位符映射，返回递归解析占位符的新泛型类型。</target>
        </trans-unit>
        <trans-unit id="f2df1e43bd5e2cdf8622dbef77626c1a181fba52" translate="yes" xml:space="preserve">
          <source>Given a list of class nodes, returns the first common supertype.</source>
          <target state="translated">给定一个类节点列表,返回第一个共同的超类型。</target>
        </trans-unit>
        <trans-unit id="79fb9bd425ff008261b95c0584c61584c28ec13c" translate="yes" xml:space="preserve">
          <source>Given a list of class nodes, returns the first common supertype. For example, Double and Float would return Number, while Set and String would return Object.</source>
          <target state="translated">给定一个类节点列表,返回第一个共同的超类型。例如,Double和Float将返回Number,而Set和String将返回Object。</target>
        </trans-unit>
        <trans-unit id="74e7f3760cf5fb4b45ed12c840f9e6ccdef052e7" translate="yes" xml:space="preserve">
          <source>Given a list of constants, transform each item in the list.</source>
          <target state="translated">给定一个常量列表,对列表中的每个项目进行变换。</target>
        </trans-unit>
        <trans-unit id="e125046cc5fc11d4668bb8c1b81ac1e61a167648" translate="yes" xml:space="preserve">
          <source>Given a loop collection type, returns the inferred type of the loop element.</source>
          <target state="translated">给定一个循环集合类型,返回循环元素的推断类型。</target>
        </trans-unit>
        <trans-unit id="a83010e02641b74369aaedc079c35fcf44c25ad0" translate="yes" xml:space="preserve">
          <source>Given a loop collection type, returns the inferred type of the loop element. Used, for example, to infer the element type of a (for e in list) loop.</source>
          <target state="translated">给定一个循环集合类型,返回循环元素的推断类型。例如,用于推断(for e in list)循环的元素类型。</target>
        </trans-unit>
        <trans-unit id="42c01da58e5a57be4e6c75a5c0dcb052bab691c1" translate="yes" xml:space="preserve">
          <source>Given a matcher that matches a string against a pattern, returns true when the string matches the pattern or if a longer string, could match the pattern.</source>
          <target state="translated">给定一个匹配器,将一个字符串与一个模式进行匹配,当字符串与模式匹配时,返回true,或者如果一个较长的字符串,可能与模式匹配。</target>
        </trans-unit>
        <trans-unit id="221eab182b06a49bf72e2b6f909b7b4265139c26" translate="yes" xml:space="preserve">
          <source>Given a matcher that matches a string against a pattern, returns true when the string matches the pattern or if a longer string, could match the pattern. For example:</source>
          <target state="translated">给定一个匹配器,将一个字符串与一个模式进行匹配,当字符串与模式匹配时,返回true,或者如果一个较长的字符串,可能与模式匹配。例如,如果一个较长的字符串与模式相匹配,则返回true。</target>
        </trans-unit>
        <trans-unit id="2ef6ce3771c3ff7e986f9bbd4ab17c6a3af43527" translate="yes" xml:space="preserve">
          <source>Given a method call, checks if it's a static method call and if it is, tells if the receiver matches the one supplied as an argument.</source>
          <target state="translated">给定一个方法调用,检查它是否是静态方法调用,如果是,则告诉接收方是否与作为参数提供的方法匹配。</target>
        </trans-unit>
        <trans-unit id="8eeb099a86f15595e186f12066b285d20873cdad" translate="yes" xml:space="preserve">
          <source>Given a method call, first checks that it's a static method call, and if it is, returns the class node for the receiver.</source>
          <target state="translated">给定一个方法调用,首先检查是否是静态方法调用,如果是,则返回接收器的类节点。</target>
        </trans-unit>
        <trans-unit id="da89d749b19055ba5a405adb3d88c0e850d2ebb8" translate="yes" xml:space="preserve">
          <source>Given a method call, first checks that it's a static method call, and if it is, returns the class node for the receiver. For example, with the following code: Person.findAll { ... }, it would return the class node for</source>
          <target state="translated">给定一个方法调用,首先检查是否是静态方法调用,如果是,则返回接收方的类节点。例如,用下面的代码。Person.findAll{...},它将返回类节点为</target>
        </trans-unit>
        <trans-unit id="cc58dbd3d1c0312db7138b9deb56b32b0fa6879d" translate="yes" xml:space="preserve">
          <source>Given a method name and a prefix, returns the name of the property that should be looked up, following the java beans rules.</source>
          <target state="translated">给定一个方法名和前缀,按照java beans规则,返回应该查询的属性名。</target>
        </trans-unit>
        <trans-unit id="9ac49770c79e8583e8197ed8be797afb62fc2e69" translate="yes" xml:space="preserve">
          <source>Given a method name and a prefix, returns the name of the property that should be looked up, following the java beans rules. For example, &quot;getName&quot; would return &quot;name&quot;, while &quot;getFullName&quot; would return &quot;fullName&quot;. If the prefix is not found, returns null.</source>
          <target state="translated">给定一个方法名和前缀,按照java beans规则,返回应该查询的属性名。例如,&quot;getName &quot;将返回 &quot;name&quot;,而 &quot;getFullName &quot;将返回 &quot;fullName&quot;。如果没有找到前缀,返回null。</target>
        </trans-unit>
        <trans-unit id="93f7fd421827ab9ac86046f901f6577ea7ab4ffa" translate="yes" xml:space="preserve">
          <source>Given a parameterized type and a generic type information, aligns actual type parameters.</source>
          <target state="translated">给定一个参数化类型和一个通用类型信息,对齐实际类型参数。</target>
        </trans-unit>
        <trans-unit id="f4373a1df048e756f221e60ba73836a61c840d69" translate="yes" xml:space="preserve">
          <source>Given a parameterized type and a generic type information, aligns actual type parameters. For example, if a class uses generic type</source>
          <target state="translated">给定一个参数化类型和一个通用类型信息,对齐实际的类型参数。例如,如果一个类使用通用类型</target>
        </trans-unit>
        <trans-unit id="c24f38fe5e524c14ab8b1cca6fc68b2f01cc57f3" translate="yes" xml:space="preserve">
          <source>Given a primitive number type (byte, integer, short, ...), generates bytecode to convert it to a wrapped number (Integer, Long, Double) using calls to [WrappedType].valueOf</source>
          <target state="translated">给定一个基数类型(字节,整数,短,......),使用对[WrappedType].valueOf的调用,生成字节码,将其转换为封装数(Integer,Long,Double)。</target>
        </trans-unit>
        <trans-unit id="95f9ccff544fa9b43fb69d1292f712d6d2974907" translate="yes" xml:space="preserve">
          <source>Given a receiver and a method node, parameterize the method arguments using available generic type information.</source>
          <target state="translated">给定一个接收器和方法节点,使用可用的通用类型信息对方法参数进行参数化。</target>
        </trans-unit>
        <trans-unit id="1689c01d451d4ba8a37facef6c8f6fea0ab0bfd1" translate="yes" xml:space="preserve">
          <source>Given a variable expression, returns the ultimately accessed variable.</source>
          <target state="translated">给定一个变量表达式,返回最终访问的变量。</target>
        </trans-unit>
        <trans-unit id="14b5759c60a5cb478c68d5dd54e2207586a2ab70" translate="yes" xml:space="preserve">
          <source>Given a wrapped number type (Byte, Integer, Short, ...), generates bytecode to convert it to a primitive number (int, long, double) using calls to wrapped.</source>
          <target state="translated">给定一个封装的数字类型(Byte,Integer,Short,...),使用对wrapped的调用生成字节码,将其转换为基数(int,long,double)。</target>
        </trans-unit>
        <trans-unit id="cad502e0c3b725480cc8450bc5bdd6ddfbacd33d" translate="yes" xml:space="preserve">
          <source>Given a wrapped number type (Byte, Integer, Short, ...), generates bytecode to convert it to a primitive number (int, long, double) using calls to wrapped.[targetType]Value()</source>
          <target state="translated">给定一个封装的数字类型(Byte,Integer,Short,...),使用调用wrapped.[targetType]Value()生成字节码,将其转换为基数(int,long,double)。</target>
        </trans-unit>
        <trans-unit id="0792f859c10ffa9901b6e1d974f2f6b4d0643c18" translate="yes" xml:space="preserve">
          <source>Given an instance containing members with annotations, derive the options specification.</source>
          <target state="translated">给定一个包含有注解的成员的实例,推导出选项规范。</target>
        </trans-unit>
        <trans-unit id="cba6158e26275162edad128828c2acd7b9ab5175" translate="yes" xml:space="preserve">
          <source>Given an interface containing members with annotations, derive the options specification.</source>
          <target state="translated">给定一个包含带有注解的成员的接口,推导出选项规范。</target>
        </trans-unit>
        <trans-unit id="ce469f450db7f0f1310bcda7e588ab42c0a6acd5" translate="yes" xml:space="preserve">
          <source>Given an object expression (a receiver expression), generate the list of potential receiver types.</source>
          <target state="translated">给定一个对象表达式(接收器表达式),生成潜在的接收器类型列表。</target>
        </trans-unit>
        <trans-unit id="b7ac8764e49e76cfcb0fc291652f2bc5bdf4a0eb" translate="yes" xml:space="preserve">
          <source>Given the following example:</source>
          <target state="translated">鉴于以下例子:</target>
        </trans-unit>
        <trans-unit id="e306275a914ff063a5ce84d88f36a0346f8334c1" translate="yes" xml:space="preserve">
          <source>Given two class nodes, returns the first common supertype, or the class itself if there are equal.</source>
          <target state="translated">给定两个类节点,返回第一个共同的超类型,如果有相等,则返回类本身。</target>
        </trans-unit>
        <trans-unit id="10ca78073d312acc7604fedd0e5c099383f5961e" translate="yes" xml:space="preserve">
          <source>Given two class nodes, returns the first common supertype, or the class itself if there are equal. For example, Double and Float would return Number, while Set and String would return Object. This method is not guaranteed to return a class node which corresponds to a real type. For example, if two types have more than one interface in common and are not in the same hierarchy branch, then the returned type will be a virtual type implementing all those interfaces. Calls to this method are supposed to be made with resolved generics. This means that you can have wildcards, but no placeholder.</source>
          <target state="translated">给定两个类节点,返回第一个共同的超类型,如果有相等的超类型,则返回类本身。例如,Double和Float将返回Number,而Set和String将返回Object。这个方法不能保证返回一个与实类型对应的类节点。例如,如果两个类型有一个以上的共同接口,并且不在同一个层次分支中,那么返回的类型将是实现所有这些接口的虚拟类型。对这个方法的调用应该是用解析的属类来进行的。这意味着你可以有通配符,但不能有占位符。</target>
        </trans-unit>
        <trans-unit id="3067b811b7e412fa28feea7beb5dc21d43578edf" translate="yes" xml:space="preserve">
          <source>Given two types, returns true if the first can be viewed as the second.</source>
          <target state="translated">给定两个类型,如果第一个类型可以看作是第二个类型,则返回true。</target>
        </trans-unit>
        <trans-unit id="353cbbc4ee4b035c7adec3e8bcfd15dd5459e6b8" translate="yes" xml:space="preserve">
          <source>Given two types, returns true if the first can be viewed as the second. NOTE that &lt;code&gt;canMean()&lt;/code&gt; is orthogonal to &lt;code&gt;ofType()&lt;/code&gt;.</source>
          <target state="translated">给定两种类型，如果第一种可以看作第二种，则返回true。注意 &lt;code&gt;canMean()&lt;/code&gt; 与 &lt;code&gt;ofType()&lt;/code&gt; 正交。</target>
        </trans-unit>
        <trans-unit id="b4ae4c9e83c4b1751ebb67f4f6e0739505e8f245" translate="yes" xml:space="preserve">
          <source>Given two types, returns true if the second describes the first.</source>
          <target state="translated">给定两个类型,如果第二个类型描述第一个类型,则返回true。</target>
        </trans-unit>
        <trans-unit id="aa855f5abc36f64c7dcf83099fca709ee191e871" translate="yes" xml:space="preserve">
          <source>Gives the version the plugin is made for</source>
          <target state="translated">提供插件的版本</target>
        </trans-unit>
        <trans-unit id="e6d4ca34c7adc483587eddcaff4344bc2f890cf1" translate="yes" xml:space="preserve">
          <source>Global flag to ignore checksums.</source>
          <target state="translated">忽略校验和的全局标志。</target>
        </trans-unit>
        <trans-unit id="c524ea45510fe17507e48968b5bcbbeeb4be8ef0" translate="yes" xml:space="preserve">
          <source>Global flag to ignore checksums. By default it is set to false.</source>
          <target state="translated">忽略校验和的全局标志。默认情况下,它被设置为false。</target>
        </trans-unit>
        <trans-unit id="cfd0a10ab6170584d12c124ccb4d59ef440419cb" translate="yes" xml:space="preserve">
          <source>GrapeEngine</source>
          <target state="translated">GrapeEngine</target>
        </trans-unit>
        <trans-unit id="7d304625e165197beb2bccab248c07169784fd2e" translate="yes" xml:space="preserve">
          <source>Groovy 1.1</source>
          <target state="translated">Groovy 1.1</target>
        </trans-unit>
        <trans-unit id="2dd2483190eb968467f6deea92867ef94dce0fad" translate="yes" xml:space="preserve">
          <source>Groovy 1.5</source>
          <target state="translated">Groovy 1.5</target>
        </trans-unit>
        <trans-unit id="ee16be405efbf469b25bf7ec4f0c81d99b02b262" translate="yes" xml:space="preserve">
          <source>Groovy 1.6</source>
          <target state="translated">Groovy 1.6</target>
        </trans-unit>
        <trans-unit id="8c9e6cf0de0e2559ce510e55896d11fb72c33597" translate="yes" xml:space="preserve">
          <source>Groovy 1.6.4</source>
          <target state="translated">Groovy 1.6.4</target>
        </trans-unit>
        <trans-unit id="cde148fec60bf40091a56cd99759077cfb69b1cc" translate="yes" xml:space="preserve">
          <source>Groovy 1.7.5</source>
          <target state="translated">Groovy 1.7.5</target>
        </trans-unit>
        <trans-unit id="40881484fa282ed537d9b6aeec6a84e2a8fad89e" translate="yes" xml:space="preserve">
          <source>Groovy 1.8.7</source>
          <target state="translated">Groovy 1.8.7</target>
        </trans-unit>
        <trans-unit id="84a415b4e7f61319279b8532ebb699773dce0c41" translate="yes" xml:space="preserve">
          <source>Groovy 2.1.0</source>
          <target state="translated">Groovy 2.1.0</target>
        </trans-unit>
        <trans-unit id="9542efae9ceccb3f7dc5e8d89175c0f0f8c2e556" translate="yes" xml:space="preserve">
          <source>Groovy AST nodes for the syntax of the language</source>
          <target state="translated">语言语法的Groovy AST节点。</target>
        </trans-unit>
        <trans-unit id="a0ece1eef080274582c47d722e8ce4961069c38e" translate="yes" xml:space="preserve">
          <source>Groovy Language for the JVM</source>
          <target state="translated">JVM中的Groovy语言</target>
        </trans-unit>
        <trans-unit id="b8c640c6eb7c65205993f299b0b44529b1bf1c76" translate="yes" xml:space="preserve">
          <source>Groovy Source Encoding Parameter</source>
          <target state="translated">Groovy源编码参数</target>
        </trans-unit>
        <trans-unit id="dd2a91a83d5562f2a3af5c21f787a4ed6ac69c23" translate="yes" xml:space="preserve">
          <source>Groovy Swing console. Adds Groovy Grape feedback (via an Ivy listener).</source>
          <target state="translated">Groovy Swing控制台。添加Groovy葡萄反馈(通过Ivy监听器)。</target>
        </trans-unit>
        <trans-unit id="5ed8ea8afbadbd6a11d90569c148c9228b30fc6b" translate="yes" xml:space="preserve">
          <source>Groovy Swing console. Allows user to interactively enter and execute Groovy.</source>
          <target state="translated">Groovy Swing控制台。允许用户交互式地输入和执行Groovy。</target>
        </trans-unit>
        <trans-unit id="a16ac519ddcbb512f68945837383ace3d89f4f4e" translate="yes" xml:space="preserve">
          <source>Groovy XML Dom processing classes.</source>
          <target state="translated">Groovy XML Dom处理类。</target>
        </trans-unit>
        <trans-unit id="cbb9af026fdc1a626404a1c5984b935a49d010da" translate="yes" xml:space="preserve">
          <source>Groovy allows instances of Closures to be called in a short form. For example:</source>
          <target state="translated">Groovy允许用简写形式调用Closures的实例。例如</target>
        </trans-unit>
        <trans-unit id="117590ae9191afe48c11d67445d6d83ac32ea146" translate="yes" xml:space="preserve">
          <source>Groovy categories are the original mechanism used by Groovy when augmenting classes with new methods. Writing categories required using a class writing style where all methods were static and an additional self parameter was defined. The self parameter and static nature of the methods disappeared once applied by Groovy's metaclass framework but some regarded the writing style as a little noisy. This transformation allows you to write your categories without the &quot;apparent noise&quot; but adds it back in during compilation so that the classes appear as normal categories.</source>
          <target state="translated">Groovy类别是Groovy在给类增加新方法时使用的原始机制。编写类别需要使用一种类的编写风格,即所有方法都是静态的,并定义了一个额外的自参数。一旦被Groovy的元类框架应用,自参数和方法的静态性质就消失了,但有些人认为这种写法有点吵。这种转变可以让你在写分类时没有 &quot;明显的噪音&quot;,但在编译时又把它加了回来,这样类就会以正常的分类出现。</target>
        </trans-unit>
        <trans-unit id="3c8091e1e1466e9b4ae72591578eed081941a515" translate="yes" xml:space="preserve">
          <source>Groovy helper classes for working with SQL data as Groovy objects</source>
          <target state="translated">用Groovy对象处理SQL数据的Groovy辅助类。</target>
        </trans-unit>
        <trans-unit id="9518540b052ca27d2203e2095ee4f8b6ad92cff6" translate="yes" xml:space="preserve">
          <source>Groovy markup builder classes for working with SAX and W3C DOM and Groovy markup.</source>
          <target state="translated">Groovy标记构建类,用于SAX和W3C DOM以及Groovy标记。</target>
        </trans-unit>
        <trans-unit id="2ca53dab53ef5e1ac0df436c4ae950a6dea2bbae" translate="yes" xml:space="preserve">
          <source>Groovy supports named-arguments for classes with a no-arg constructor or a constructor with a Map as the first argument. This is compatible with the default kind of constructor(s) that &lt;code&gt;@TupleConstructor&lt;/code&gt; produces.</source>
          <target state="translated">Groovy支持使用无参数构造函数或以Map作为第一个参数的构造函数的类的命名参数。这与 &lt;code&gt;@TupleConstructor&lt;/code&gt; 生成的默认构造函数类型兼容。</target>
        </trans-unit>
        <trans-unit id="b1dcbe931f868b3725ecdfcabffaa73750075ec3" translate="yes" xml:space="preserve">
          <source>Groovy test case, which recreates internal GroovyShell in each setUp()</source>
          <target state="translated">Groovy测试用例,它在每次setUp()中都会重新创建内部GroovyShell。</target>
        </trans-unit>
        <trans-unit id="05ce2b496f679664f244baa22f5fddf5316bcd09" translate="yes" xml:space="preserve">
          <source>Groovy truth will be used to determine true and false, null is excluded from defaulting to false here. If all tests have been executed and all of them skipped, then the groovy standard filtering will take place.</source>
          <target state="translated">Groovy truth将用来判断真假,null被排除在这里默认为false。如果所有的测试都已经执行,并且全部跳过,那么将进行groovy标准过滤。</target>
        </trans-unit>
        <trans-unit id="3c87d72b713743eae530deca37d3559c789f0634" translate="yes" xml:space="preserve">
          <source>Groovy wrapper classes for primitive types.</source>
          <target state="translated">基元类型的Groovy封装类。</target>
        </trans-unit>
        <trans-unit id="2c5d41a0c244e2e987cf31024aeea4d1f183558d" translate="yes" xml:space="preserve">
          <source>Groovy's normal map-style naming conventions will not be available if the first property has type &lt;code&gt;LinkedHashMap&lt;/code&gt; or if there is a single Map, AbstractMap or HashMap property.</source>
          <target state="translated">如果第一个属性的类型为 &lt;code&gt;LinkedHashMap&lt;/code&gt; ,或者只有一个Map，AbstractMap或HashMap属性，则Groovy的常规地图样式命名约定将不可用。</target>
        </trans-unit>
        <trans-unit id="cc9d7826dcc1d56d4e6ec1ea736961d76b5a2fe2" translate="yes" xml:space="preserve">
          <source>GroovyASTTransformation</source>
          <target state="translated">GroovyASTTransformation</target>
        </trans-unit>
        <trans-unit id="2afd993fb1e2d0df4bd1b8cb664c3fdb21c87502" translate="yes" xml:space="preserve">
          <source>GroovyAnnotationRef</source>
          <target state="translated">GroovyAnnotationRef</target>
        </trans-unit>
        <trans-unit id="9e5eea705af2b82930e663814660163f3ed83c96" translate="yes" xml:space="preserve">
          <source>GroovyAssert</source>
          <target state="translated">GroovyAssert</target>
        </trans-unit>
        <trans-unit id="b6a07cea4a691ad46855daee25a89c34f1a0b150" translate="yes" xml:space="preserve">
          <source>GroovyBugError if key is null</source>
          <target state="translated">如果key为null,则GroovyBugError错误。</target>
        </trans-unit>
        <trans-unit id="a6df8c4cb64c22d9fb8ea68c9d32277565a39e06" translate="yes" xml:space="preserve">
          <source>GroovyBugError if key is null or there is already meta data under that key</source>
          <target state="translated">如果键为空或该键下已经有元数据,则GroovyBugError。</target>
        </trans-unit>
        <trans-unit id="ae7a870c6ac20d06e2700557f13097585eb6ff3d" translate="yes" xml:space="preserve">
          <source>GroovyBugError if the key is null</source>
          <target state="translated">如果key为null,则GroovyBugError错误。</target>
        </trans-unit>
        <trans-unit id="aca4932a2a323e34d6cf12112863407d92061988" translate="yes" xml:space="preserve">
          <source>GroovyClassDoc</source>
          <target state="translated">GroovyClassDoc</target>
        </trans-unit>
        <trans-unit id="6c8e00730a5c2f8a4fd0c7bd761d3aced8c738d1" translate="yes" xml:space="preserve">
          <source>GroovyClassValue</source>
          <target state="translated">GroovyClassValue</target>
        </trans-unit>
        <trans-unit id="2b6cd96c988ab5b02f081123f5307905aac08704" translate="yes" xml:space="preserve">
          <source>GroovyClassValue implementaion that simply delegates to Java 7's java.lang.ClassValue</source>
          <target state="translated">GroovyClassValue的实现,它只是简单地委托给Java 7的java.lang.ClassValue。</target>
        </trans-unit>
        <trans-unit id="cda9be8a1c7cd33e2bbaef50c50588612650e92b" translate="yes" xml:space="preserve">
          <source>GroovyClassVisitor</source>
          <target state="translated">GroovyClassVisitor</target>
        </trans-unit>
        <trans-unit id="fbef2a047cf58f2ee6619bd5d13c9ca7ddc517e0" translate="yes" xml:space="preserve">
          <source>GroovyCodeVisitor</source>
          <target state="translated">GroovyCodeVisitor</target>
        </trans-unit>
        <trans-unit id="2f223df186fcc142fec326a290fe5b7eb43872cf" translate="yes" xml:space="preserve">
          <source>GroovyCollections.combinations</source>
          <target state="translated">GroovyCollections.combinations</target>
        </trans-unit>
        <trans-unit id="2a4cbe8dae8ee1016dc4ee01f02847667eaf9fca" translate="yes" xml:space="preserve">
          <source>GroovyCollections.max</source>
          <target state="translated">GroovyCollections.max</target>
        </trans-unit>
        <trans-unit id="8b4ed724bc4f42d512ae8b76bbc70375efaeeea4" translate="yes" xml:space="preserve">
          <source>GroovyCollections.min</source>
          <target state="translated">GroovyCollections.min</target>
        </trans-unit>
        <trans-unit id="a96c8014198854d83379dcbf65f30611eb1c4c83" translate="yes" xml:space="preserve">
          <source>GroovyCollections.transpose</source>
          <target state="translated">GroovyCollections.transpose</target>
        </trans-unit>
        <trans-unit id="d7e975ace7efbdb2d8431935b97b606ed7a79fae" translate="yes" xml:space="preserve">
          <source>GroovyConstructorDoc</source>
          <target state="translated">GroovyConstructorDoc</target>
        </trans-unit>
        <trans-unit id="7446dee6d30c52d65a238bea4ee89b27265918cb" translate="yes" xml:space="preserve">
          <source>GroovyDoc</source>
          <target state="translated">GroovyDoc</target>
        </trans-unit>
        <trans-unit id="17ffd3e55899b729d8b529182aac90b8ead7aa57" translate="yes" xml:space="preserve">
          <source>GroovyDoc internal classes.</source>
          <target state="translated">GroovyDoc内部类。</target>
        </trans-unit>
        <trans-unit id="fe7bff80f2b7289c2ab26bfa742e19becdd4511b" translate="yes" xml:space="preserve">
          <source>GroovyDoc tool.</source>
          <target state="translated">GroovyDoc工具。</target>
        </trans-unit>
        <trans-unit id="87b1c86cedbd3ddf75f76ce7f8caccb7aa04ae22" translate="yes" xml:space="preserve">
          <source>GroovyDocParserI</source>
          <target state="translated">GroovyDocParserI</target>
        </trans-unit>
        <trans-unit id="82cf4f54a4f767db6088d95169f043583f98bc63" translate="yes" xml:space="preserve">
          <source>GroovyExceptionInterface</source>
          <target state="translated">GroovyExceptionInterface</target>
        </trans-unit>
        <trans-unit id="b884ba6297fef7d04ed665e9f01e02dfdb594b65" translate="yes" xml:space="preserve">
          <source>GroovyExecutableMemberDoc</source>
          <target state="translated">GroovyExecutableMemberDoc</target>
        </trans-unit>
        <trans-unit id="a6004d7e059e6f9e4138adf52fea151b9c153bda" translate="yes" xml:space="preserve">
          <source>GroovyFieldDoc</source>
          <target state="translated">GroovyFieldDoc</target>
        </trans-unit>
        <trans-unit id="91f473dc20ffcb4eb98f16bdeb7cdee55c9cd15b" translate="yes" xml:space="preserve">
          <source>GroovyInterceptable</source>
          <target state="translated">GroovyInterceptable</target>
        </trans-unit>
        <trans-unit id="9115a4d409b747597eb61c1ab4e67585c818fc45" translate="yes" xml:space="preserve">
          <source>GroovyLogTestCaseTest</source>
          <target state="translated">GroovyLogTestCaseTest</target>
        </trans-unit>
        <trans-unit id="511f9f82ae50d00faf241064f44ee7cd338beed8" translate="yes" xml:space="preserve">
          <source>GroovyMain.searchForGroovyScriptFile</source>
          <target state="translated">GroovyMain.searchForGroovyScriptFile</target>
        </trans-unit>
        <trans-unit id="8d7f7c1abfae5fe754e59f216687d90b7a1ee37f" translate="yes" xml:space="preserve">
          <source>GroovyMemberDoc</source>
          <target state="translated">GroovyMemberDoc</target>
        </trans-unit>
        <trans-unit id="328297455b281decac51105ae6bfed8920da4d2e" translate="yes" xml:space="preserve">
          <source>GroovyMethodDoc</source>
          <target state="translated">GroovyMethodDoc</target>
        </trans-unit>
        <trans-unit id="36d5dd230cb67e70140cd94cb2ca26f6bc6ec74b" translate="yes" xml:space="preserve">
          <source>GroovyObject</source>
          <target state="translated">GroovyObject</target>
        </trans-unit>
        <trans-unit id="f3e84b6cfaa953ebc4c38e0828d7577b12d97abb" translate="yes" xml:space="preserve">
          <source>GroovyObject.getProperty</source>
          <target state="translated">GroovyObject.getProperty</target>
        </trans-unit>
        <trans-unit id="787bf38f89c2c0ed8ca3fa68d3937e60396d4868" translate="yes" xml:space="preserve">
          <source>GroovyObject.setProperty</source>
          <target state="translated">GroovyObject.setProperty</target>
        </trans-unit>
        <trans-unit id="097ad01784ee583de407d5d7b1ff203eb56da4e6" translate="yes" xml:space="preserve">
          <source>GroovyPackageDoc</source>
          <target state="translated">GroovyPackageDoc</target>
        </trans-unit>
        <trans-unit id="8044fc03b0a9a0bd44e5bf541bb47677673d5fec" translate="yes" xml:space="preserve">
          <source>GroovyParameter</source>
          <target state="translated">GroovyParameter</target>
        </trans-unit>
        <trans-unit id="fa285db82b09f89fc71c4dbc6de6fddc1c74c0c1" translate="yes" xml:space="preserve">
          <source>GroovyParserVisitor</source>
          <target state="translated">GroovyParserVisitor</target>
        </trans-unit>
        <trans-unit id="32cb593dbf054684e076cf672564461ebfa98869" translate="yes" xml:space="preserve">
          <source>GroovyProgramElementDoc</source>
          <target state="translated">GroovyProgramElementDoc</target>
        </trans-unit>
        <trans-unit id="0ca646239c949b198c8d5fbc6b9483c290ad999a" translate="yes" xml:space="preserve">
          <source>GroovyResultSet</source>
          <target state="translated">GroovyResultSet</target>
        </trans-unit>
        <trans-unit id="f1693b04c21a4fdb349dc3f4e800616af9d9e0ad" translate="yes" xml:space="preserve">
          <source>GroovyResultSetExtension</source>
          <target state="translated">GroovyResultSetExtension</target>
        </trans-unit>
        <trans-unit id="d178673fbe6490a586f2d6bfdc4ae2470daee8b9" translate="yes" xml:space="preserve">
          <source>GroovyResultSetExtension implements additional logic for ResultSet. Due to the version incompatibility between java6 and java5 this methods are moved here from the original GroovyResultSet class. The methods in this class are used by the proxy GroovyResultSetProxy, which will try to invoke methods on this class before invoking it on ResultSet.</source>
          <target state="translated">GroovyResultSetExtension实现了ResultSet的附加逻辑。由于java6和java5的版本不兼容,这个方法从原来的GroovyResultSet类中移到了这里。这个类中的方法被代理GroovyResultSetProxy使用,它将在调用ResultSet之前尝试调用这个类的方法。</target>
        </trans-unit>
        <trans-unit id="6b1d43238dcfb570a374cd22aebbfa544d282030" translate="yes" xml:space="preserve">
          <source>GroovyResultSetProxy</source>
          <target state="translated">GroovyResultSetProxy</target>
        </trans-unit>
        <trans-unit id="d92ea15a593765c587496f6d28f6cb7773873c1b" translate="yes" xml:space="preserve">
          <source>GroovyResultSetProxy is used to create a proxy for GroovyResultSet. Due to the version incompatibility between java 6 and older versions methods with additional logic were moved into an extension class. When getting properties or calling methods, the runtime will try to first execute these on the extension and then on the ResultSet itself. This way it is possible to replace and add methods. To overload methods from ResultSet all methods have to be implemented on the extension class.</source>
          <target state="translated">GroovyResultSetProxy用于创建GroovyResultSet的代理。由于java 6和旧版本之间的版本不兼容,带有附加逻辑的方法被移到了扩展类中。当获取属性或调用方法时,运行时将首先尝试在扩展类上执行这些方法,然后在ResultSet本身上执行。这样就可以替换和添加方法。要从ResultSet中重载方法,所有方法都必须在扩展类上实现。</target>
        </trans-unit>
        <trans-unit id="eeee447b9b05a7dce86048ab68e97651dc7022db" translate="yes" xml:space="preserve">
          <source>GroovyRootDoc</source>
          <target state="translated">GroovyRootDoc</target>
        </trans-unit>
        <trans-unit id="7facf7f939f3b2d444ac4aab44a52d79952cc313" translate="yes" xml:space="preserve">
          <source>GroovyRunner</source>
          <target state="translated">GroovyRunner</target>
        </trans-unit>
        <trans-unit id="cc6b53d7a423aabeb074136bae05efda8e8ee1ef" translate="yes" xml:space="preserve">
          <source>GroovyRuntimeException if &lt;code&gt;to&lt;/code&gt; is a different type than this</source>
          <target state="translated">GroovyRuntimeException如果 &lt;code&gt;to&lt;/code&gt; 与此类型不同</target>
        </trans-unit>
        <trans-unit id="fb185414c6d23b6e80a938d6881072059bb3c160" translate="yes" xml:space="preserve">
          <source>GroovyRuntimeException if the metaclass can't be set for this class</source>
          <target state="translated">如果不能为该类设置元类,则出现GroovyRuntimeException。</target>
        </trans-unit>
        <trans-unit id="9bf4f3386ef89baf0507b3cdca9f5f4d574db461" translate="yes" xml:space="preserve">
          <source>GroovyRuntimeException if the metaclass can't be set for this object</source>
          <target state="translated">如果不能为该对象设置元类,则出现GroovyRuntimeException。</target>
        </trans-unit>
        <trans-unit id="eb9b40350dc114a111d4e6373de77248a23fe69b" translate="yes" xml:space="preserve">
          <source>GroovyRuntimeException if there is more than one matching method</source>
          <target state="translated">如果有多个匹配方法,则出现GroovyRuntimeException。</target>
        </trans-unit>
        <trans-unit id="4b7514ad3ad67dc72e04d600d714c052745f90cb" translate="yes" xml:space="preserve">
          <source>GroovyRuntimeException if this value is earlier than &lt;code&gt;to&lt;/code&gt;</source>
          <target state="translated">GroovyRuntimeException如果该值早于 &lt;code&gt;to&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="80b13b035428fd1df311a8836cfc774cba545bf7" translate="yes" xml:space="preserve">
          <source>GroovyRuntimeException if this value is later than &lt;code&gt;to&lt;/code&gt;</source>
          <target state="translated">GroovyRuntimeException如果这个值是迟 &lt;code&gt;to&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="975ff748035963bc3eb24b3c978553ed4f5fe466" translate="yes" xml:space="preserve">
          <source>GroovyTag</source>
          <target state="translated">GroovyTag</target>
        </trans-unit>
        <trans-unit id="3d17fb4bfc5f7b9f8096836bcaa1be8d4edc4572" translate="yes" xml:space="preserve">
          <source>GroovyTestCase</source>
          <target state="translated">GroovyTestCase</target>
        </trans-unit>
        <trans-unit id="b126ad56079de624094d8eaa63b23161a420067a" translate="yes" xml:space="preserve">
          <source>GroovyTokenTypes</source>
          <target state="translated">GroovyTokenTypes</target>
        </trans-unit>
        <trans-unit id="02c9d06b762475c86234c9e5de9f41a031e5b20d" translate="yes" xml:space="preserve">
          <source>GroovyType</source>
          <target state="translated">GroovyType</target>
        </trans-unit>
        <trans-unit id="a3cc99081e70d470e34d40eb0f6bb538e67a21f7" translate="yes" xml:space="preserve">
          <source>GroovydocHolder</source>
          <target state="translated">GroovydocHolder</target>
        </trans-unit>
        <trans-unit id="b0f853f111837418b4143bce5f21b51b55e5abce" translate="yes" xml:space="preserve">
          <source>GroovydocHolder instance</source>
          <target state="translated">GroovydocHolder实例</target>
        </trans-unit>
        <trans-unit id="f1ac5abd425ed6bfdafe74b1e85f316c7eb1d184" translate="yes" xml:space="preserve">
          <source>Groups all map entries into groups determined by the supplied mapping closure.</source>
          <target state="translated">将所有的地图条目归入由所提供的映射闭包决定的组。</target>
        </trans-unit>
        <trans-unit id="09655079a5e2dd6ee708a5f45de7d07f92338a8a" translate="yes" xml:space="preserve">
          <source>Groups all map entries into groups determined by the supplied mapping closure. The closure will be passed a Map.Entry or key and value (depending on the number of parameters the closure accepts) and should return the key that each item should be grouped under. The resulting map will have an entry for each 'group' key returned by the closure, with values being the list of map entries that belong to each group. (If instead of a list of map entries, you want an actual map use {code}groupBy{code}.)</source>
          <target state="translated">将所有地图条目归入由所提供的映射闭包确定的组。闭包将被传递一个 Map.条目或 key 和 value (取决于闭包接受的参数数量),并应返回每个条目应被分组的 key。结果的地图将为闭包返回的每个 &quot;组 &quot;键有一个条目,值是属于每个组的地图条目列表。(如果您不想要地图条目列表,而是想要一个实际的地图,请使用{code}groupBy{code}。)</target>
        </trans-unit>
        <trans-unit id="88b18e09cf949cd690fba987c8af14b5246fc9df" translate="yes" xml:space="preserve">
          <source>Groups the current element according to the value</source>
          <target state="translated">根据值对当前元素进行分组</target>
        </trans-unit>
        <trans-unit id="01b2fdc285a04fa0ca016d21ee921a28e7e7de0b" translate="yes" xml:space="preserve">
          <source>Groups the members of a map into groups determined by the supplied mapping closure and counts the frequency of the created groups.</source>
          <target state="translated">将地图上的成员按所提供的映射闭合信息进行分组,并计算所创建的分组的频率。</target>
        </trans-unit>
        <trans-unit id="d2a9c5650904cb345632b4f758fb7a5f772e1c5b" translate="yes" xml:space="preserve">
          <source>Groups the members of a map into groups determined by the supplied mapping closure and counts the frequency of the created groups. The closure will be passed a Map.Entry or key and value (depending on the number of parameters the closure accepts) and should return the key that each item should be grouped under. The resulting map will have an entry for each 'group' key returned by the closure, with values being the frequency counts for that 'group'.</source>
          <target state="translated">将地图中的成员分成由所提供的映射闭包决定的组,并计算所创建组的频率。闭包将被传递一个Map.Entry或key和value(取决于闭包接受的参数数量),并且应该返回每个项目应该被分组的key。结果的地图将为闭包返回的每个 &quot;组 &quot;键有一个条目,值是该 &quot;组 &quot;的频率计数。</target>
        </trans-unit>
        <trans-unit id="183befa5dc4c657bed738c0e388eaa2df8a78963" translate="yes" xml:space="preserve">
          <source>Groups the members of a map into sub maps determined by the supplied mapping closure.</source>
          <target state="translated">根据所提供的映射闭包,将地图的成员分为子地图。</target>
        </trans-unit>
        <trans-unit id="94a47cfefa3baaba2b3cc6703a094fc6ce819246" translate="yes" xml:space="preserve">
          <source>Groups the members of a map into sub maps determined by the supplied mapping closure. The closure will be passed a Map.Entry or key and value (depending on the number of parameters the closure accepts) and should return the key that each item should be grouped under. The resulting map will have an entry for each 'group' key returned by the closure, with values being the map members from the original map that belong to each group. (If instead of a map, you want a list of map entries use {code}groupEntriesBy{code}.)</source>
          <target state="translated">将地图的成员分组到由提供的映射闭包决定的子地图中。闭包将被传递一个 Map.Entry 或 key 和 value (取决于闭包接受的参数数量),并应返回每个项目应被分组的 key。最终的地图将为闭包返回的每个 &quot;组 &quot;键有一个条目,值是原始地图中属于每个组的地图成员。(如果您不想要地图,而是想要一个地图条目列表,请使用 {code}groupEntriesBy{code}。)</target>
        </trans-unit>
        <trans-unit id="f1c68bce79200c96e7db364c9c2031817f417188" translate="yes" xml:space="preserve">
          <source>Groups the members of a map into sub maps determined by the supplied mapping closures.</source>
          <target state="translated">根据所提供的贴图封闭,将地图的成员划分为子地图。</target>
        </trans-unit>
        <trans-unit id="a26c193798fbf51cee7c3242dddf6857eb0f25dd" translate="yes" xml:space="preserve">
          <source>Groups the members of a map into sub maps determined by the supplied mapping closures. Each closure will be passed a Map.Entry or key and value (depending on the number of parameters the closure accepts) and should return the key that each item should be grouped under. The resulting map will have an entry for each 'group path' returned by all closures, with values being the map members from the original map that belong to each such 'group path'. If the &lt;code&gt;self&lt;/code&gt; map is one of TreeMap, Hashtable, or Properties, the returned Map will preserve that type, otherwise a LinkedHashMap will be returned.</source>
          <target state="translated">将映射的成员分组为由提供的映射闭包确定的子映射。每个闭包都将传递一个Map.Entry或键和值（取决于该闭包接受的参数数量），并且应返回应将每个项目归为一组的键。生成的映射将为所有闭包返回的每个&amp;ldquo;组路径&amp;rdquo;都有一个条目，其值是原始映射中属于每个此类&amp;ldquo;组路径&amp;rdquo;的映射成员。如果 &lt;code&gt;self&lt;/code&gt; 映射是TreeMap，Hashtable或Properties之一，则返回的Map将保留该类型，否则将返回LinkedHashMap。</target>
        </trans-unit>
        <trans-unit id="bd2db70b4e4fad2a4d49adb0c1f7c8c211363837" translate="yes" xml:space="preserve">
          <source>Guard for enumConstants.</source>
          <target state="translated">enumConstants的卫士。</target>
        </trans-unit>
        <trans-unit id="766e38b5d12444c5c31d2c3164396cb67e80f61d" translate="yes" xml:space="preserve">
          <source>Guard to check if the argument is null.</source>
          <target state="translated">守卫检查参数是否为空。</target>
        </trans-unit>
        <trans-unit id="52c516d5ccb99d1c1df7d58c0328f00f7e828fc8" translate="yes" xml:space="preserve">
          <source>Guard to check if the argument is null. This method is called by the handle to check if the provided argument is null.</source>
          <target state="translated">Guard来检查参数是否为空。本方法由句柄调用,用于检查所提供的参数是否为空。</target>
        </trans-unit>
        <trans-unit id="bced2de10fd5d2185edf3cd79006b4648d852bf2" translate="yes" xml:space="preserve">
          <source>Guard to check if the provided Object has the same class as the provided Class.</source>
          <target state="translated">Guard,用于检查所提供的Object是否与所提供的Class具有相同的类。</target>
        </trans-unit>
        <trans-unit id="52598061917ec2d780a5ff8f549b7776e96d599d" translate="yes" xml:space="preserve">
          <source>Guard to check if the provided Object has the same class as the provided Class. This method will return false if the Object is null.</source>
          <target state="translated">用于检查Object是否与Class具有相同的类。如果对象为空,本方法将返回false。</target>
        </trans-unit>
        <trans-unit id="370f989db787a30bd2ca3f95cd006148a598f8cb" translate="yes" xml:space="preserve">
          <source>Handle for all information we want to keep about the class</source>
          <target state="translated">我们想保存的关于该类的所有信息的处理方式。</target>
        </trans-unit>
        <trans-unit id="7673739d3ffab9615c0b7891330a0d603e4fcb48" translate="yes" xml:space="preserve">
          <source>Handle web requests to the GroovyServlet</source>
          <target state="translated">处理对GroovyServlet的网络请求。</target>
        </trans-unit>
        <trans-unit id="e8f86f0609353c5818d375ffa4ddb4121f458854" translate="yes" xml:space="preserve">
          <source>Handles converting a given type.</source>
          <target state="translated">处理给定类型的转换。</target>
        </trans-unit>
        <trans-unit id="63017fe046d1633ceef71a72ad5f7001a3776e67" translate="yes" xml:space="preserve">
          <source>Handles generation of code for the</source>
          <target state="translated">处理生成代码的</target>
        </trans-unit>
        <trans-unit id="b148571474b1e2a23fcbab31eeca3c4f26a90e68" translate="yes" xml:space="preserve">
          <source>Handles generation of code for the &lt;a href=&quot;../../../../groovy/transform/autofinal&quot;&gt;AutoFinal&lt;/a&gt; annotation.</source>
          <target state="translated">处理&lt;a href=&quot;../../../../groovy/transform/autofinal&quot;&gt;AutoFinal&lt;/a&gt;批注的代码生成。</target>
        </trans-unit>
        <trans-unit id="cab01b5b7331c83f3e664a0e348738c855d91b70" translate="yes" xml:space="preserve">
          <source>Handles generation of code for the &lt;a href=&quot;../../../../groovy/transform/builder/builder&quot;&gt;Builder&lt;/a&gt; annotation.</source>
          <target state="translated">处理生成&lt;a href=&quot;../../../../groovy/transform/builder/builder&quot;&gt;器&lt;/a&gt;注释的代码生成。</target>
        </trans-unit>
        <trans-unit id="0f5f7eae912148cd38675727f83b3881cdfcd01c" translate="yes" xml:space="preserve">
          <source>Handles generation of code for the &lt;a href=&quot;../../../../groovy/transform/memoized&quot;&gt;Memoized&lt;/a&gt; annotation.</source>
          <target state="translated">处理&amp;ldquo;&lt;a href=&quot;../../../../groovy/transform/memoized&quot;&gt;备注&amp;rdquo;&lt;/a&gt;注释的代码生成。</target>
        </trans-unit>
        <trans-unit id="7f0766989a4ba4ae7585e4a141b2eb58f1ddb948" translate="yes" xml:space="preserve">
          <source>Handles generation of code for the &lt;code&gt;@&lt;/code&gt;IndexedProperty annotation.</source>
          <target state="translated">处理 &lt;code&gt;@&lt;/code&gt; IndexedProperty批注的代码生成。</target>
        </trans-unit>
        <trans-unit id="ec9da99344f66be574642d2aab49e85f09e3ee42" translate="yes" xml:space="preserve">
          <source>Handles generation of code for the &lt;code&gt;@&lt;/code&gt;InheritConstructors annotation.</source>
          <target state="translated">处理 &lt;code&gt;@&lt;/code&gt; InheritConstructors批注的代码生成。</target>
        </trans-unit>
        <trans-unit id="dd96af09ee65ff66f77dfb539ecc37ffd4bb9cb7" translate="yes" xml:space="preserve">
          <source>Handles generation of code for the &lt;code&gt;@&lt;/code&gt;WithReadLock and &lt;code&gt;@&lt;/code&gt;WithWriteLock annotation.</source>
          <target state="translated">手柄一代的代码 &lt;code&gt;@&lt;/code&gt; WithReadLock和 &lt;code&gt;@&lt;/code&gt; WithWriteLock注解。</target>
        </trans-unit>
        <trans-unit id="2a93c3d5cb76830d15346e214fa8f06c53ce9c65" translate="yes" xml:space="preserve">
          <source>Handles generation of code for the &lt;code&gt;@Bindable&lt;/code&gt; annotation when &lt;code&gt;@Vetoable&lt;/code&gt; is not present.</source>
          <target state="translated">当 &lt;code&gt;@Vetoable&lt;/code&gt; 不存在时，处理 &lt;code&gt;@Bindable&lt;/code&gt; 批注的代码生成。</target>
        </trans-unit>
        <trans-unit id="dd4f04cf99fa4f2f2e1e711a12532b5613fdcaca" translate="yes" xml:space="preserve">
          <source>Handles generation of code for the &lt;code&gt;@Delegate&lt;/code&gt; annotation</source>
          <target state="translated">处理 &lt;code&gt;@Delegate&lt;/code&gt; 批注的代码生成</target>
        </trans-unit>
        <trans-unit id="76a764b281a7afb386be57901cbdf50f7f99cc0b" translate="yes" xml:space="preserve">
          <source>Handles generation of code for the &lt;code&gt;@ListenerList&lt;/code&gt; annotation.</source>
          <target state="translated">处理 &lt;code&gt;@ListenerList&lt;/code&gt; 批注的代码生成。</target>
        </trans-unit>
        <trans-unit id="0d3449dd7e62c6bca50515cde6799d54864d14b9" translate="yes" xml:space="preserve">
          <source>Handles generation of code for the &lt;code&gt;@Newify&lt;/code&gt; AST transform.</source>
          <target state="translated">处理 &lt;code&gt;@Newify&lt;/code&gt; AST转换的代码生成。</target>
        </trans-unit>
        <trans-unit id="aa2c8dd83e998e114ea2e5885b579a14fd5c0c61" translate="yes" xml:space="preserve">
          <source>Handles generation of code for the &lt;code&gt;@Synchronized&lt;/code&gt; annotation.</source>
          <target state="translated">处理 &lt;code&gt;@Synchronized&lt;/code&gt; 批注的代码生成。</target>
        </trans-unit>
        <trans-unit id="16186c3464ed4dbd8a101d50d16972ea506dc5c8" translate="yes" xml:space="preserve">
          <source>Handles generation of code for the &lt;code&gt;@Vetoable&lt;/code&gt; annotation, and &lt;code&gt;@Bindable&lt;/code&gt; if also present.</source>
          <target state="translated">处理 &lt;code&gt;@Vetoable&lt;/code&gt; 批注和 &lt;code&gt;@Bindable&lt;/code&gt; (如果也存在）的代码生成。</target>
        </trans-unit>
        <trans-unit id="2a9a5a453b05ee71f20fb5e3ccc34cd094e66425" translate="yes" xml:space="preserve">
          <source>Handles generation of code for the traits (trait keyword is equivalent to using the</source>
          <target state="translated">处理性状代码的生成(性状关键字等同于使用</target>
        </trans-unit>
        <trans-unit id="22fca81025384c0695509f53fe84cd506499bc4d" translate="yes" xml:space="preserve">
          <source>Handles parsing the properties from the closure into values that can be referenced. This object is very stateful and not threadsafe. It accumulates expressions in the 'expression' field as they are found and executed within the DSL. Note: this class consists of many one-line method calls. A better implementation might be to take a declarative approach and replace the one-liners with map entries.</source>
          <target state="translated">处理将闭包中的属性解析为可引用的值。这个对象是非常有状态的,不是线程安全的。它在'expression'字段中积累表达式,因为它们是在DSL中被发现和执行的。注意:这个类由许多单行方法调用组成。更好的实现可能是采用声明式的方法,用映射项代替单行方法。</target>
        </trans-unit>
        <trans-unit id="3f224549ab8c4ac68785278d9096a7f7a84aa8f2" translate="yes" xml:space="preserve">
          <source>Handles the ability to use the left shift operator to append new constructors</source>
          <target state="translated">处理使用左移操作符附加新构造体的能力。</target>
        </trans-unit>
        <trans-unit id="171bf06b66b227ead8c64690b15df83980dc0f5f" translate="yes" xml:space="preserve">
          <source>Handles the bulk of the processing, mostly delegating to other methods.</source>
          <target state="translated">处理大部分的处理工作,主要是委托给其他方法。</target>
        </trans-unit>
        <trans-unit id="2b6a35795ddb333ae2d06686dccff230ae24456a" translate="yes" xml:space="preserve">
          <source>Handles the common English regular plurals with the following rules.</source>
          <target state="translated">处理常见的英语常规复数,其规则如下。</target>
        </trans-unit>
        <trans-unit id="9839a05bdf7620236de90b57403ab1c43cf45a0d" translate="yes" xml:space="preserve">
          <source>Handles the implementation of the &lt;a href=&quot;../../../../../groovy/transform/compilestatic&quot;&gt;CompileStatic&lt;/a&gt; transformation.</source>
          <target state="translated">处理&lt;a href=&quot;../../../../../groovy/transform/compilestatic&quot;&gt;CompileStatic&lt;/a&gt;转换的实现。</target>
        </trans-unit>
        <trans-unit id="d4b26877c095f64376c2519959785e9fa9f00cdc" translate="yes" xml:space="preserve">
          <source>Handles the implementation of the &lt;a href=&quot;../../../../groovy/transform/typechecked&quot;&gt;TypeChecked&lt;/a&gt; transformation.</source>
          <target state="translated">处理&lt;a href=&quot;../../../../groovy/transform/typechecked&quot;&gt;TypeChecked&lt;/a&gt;转换的实现。</target>
        </trans-unit>
        <trans-unit id="a6423168480ca75b03dba862f57b95cb373502fb" translate="yes" xml:space="preserve">
          <source>Handles transformation for the</source>
          <target state="translated">处理转换为</target>
        </trans-unit>
        <trans-unit id="9c8a7367b9d4a1c79102ee0cdcd4823b3f4b340f" translate="yes" xml:space="preserve">
          <source>Handy methods when working with Closure AST data structures.</source>
          <target state="translated">在处理Closure AST数据结构时的方便方法。</target>
        </trans-unit>
        <trans-unit id="7a352ce8944eff9832d06ab3ecec09d4030ba856" translate="yes" xml:space="preserve">
          <source>Handy methods when working with the Groovy AST</source>
          <target state="translated">使用Groovy AST时的方便方法</target>
        </trans-unit>
        <trans-unit id="80cde5069513321577e0d32fdd1071d4724fdf1b" translate="yes" xml:space="preserve">
          <source>Has a Byte Order Marker for UTF-16 Big Endian (utf-16 and ucs-2).</source>
          <target state="translated">具有UTF-16大 Endian(utf-16和ucs-2)的字节顺序标记。</target>
        </trans-unit>
        <trans-unit id="a464c8513b4ee4e8634933af87baa6d1e293dec1" translate="yes" xml:space="preserve">
          <source>Has a Byte Order Marker for UTF-16 Low Endian (ucs-2le, ucs-4le, and ucs-16le).</source>
          <target state="translated">有一个UTF-16低端码(ucs-2le、ucs-4le和ucs-16le)的字节顺序标记。</target>
        </trans-unit>
        <trans-unit id="aa1333e11683bd96448abfaf10d321f8464c2959" translate="yes" xml:space="preserve">
          <source>Has a Byte Order Marker for UTF-8 (Used by Microsoft's Notepad and other editors).</source>
          <target state="translated">有一个UTF-8的字节顺序标记(由微软的记事本和其他编辑器使用)。</target>
        </trans-unit>
        <trans-unit id="8eb201973ca6bcf454f9ba929cec40bc77b20837" translate="yes" xml:space="preserve">
          <source>Has the map been hydrated.</source>
          <target state="translated">地图是否已经被水化。</target>
        </trans-unit>
        <trans-unit id="aadc1ed9913446b6e4b297b982d95d23e3a9d49c" translate="yes" xml:space="preserve">
          <source>HasCleanup</source>
          <target state="translated">HasCleanup</target>
        </trans-unit>
        <trans-unit id="3ffb3d2c87f9f756a0b7aa1358d05c9efbd64a8a" translate="yes" xml:space="preserve">
          <source>HashCodeHelper</source>
          <target state="translated">HashCodeHelper</target>
        </trans-unit>
        <trans-unit id="b3df19275465f143523f93f2137a466098ac211c" translate="yes" xml:space="preserve">
          <source>Helge Tesgaard</source>
          <target state="translated">Helge Tesgaard</target>
        </trans-unit>
        <trans-unit id="2f141a9e74c34e6283e928532521b7b84b7412b8" translate="yes" xml:space="preserve">
          <source>Helper Class for Antlr AST traversal and visitation.</source>
          <target state="translated">Antlr AST遍历和访问的助手类。</target>
        </trans-unit>
        <trans-unit id="dbb908a6bf3d3972eb47c850d92e7652ce1eabbb" translate="yes" xml:space="preserve">
          <source>Helper base class used for lazy updates.</source>
          <target state="translated">用于懒惰更新的助手基类。</target>
        </trans-unit>
        <trans-unit id="91414c5a35fe62bd78161153831afa6dfb9941a2" translate="yes" xml:space="preserve">
          <source>Helper class for converting AST into text.</source>
          <target state="translated">用于将AST转换为文本的辅助类。</target>
        </trans-unit>
        <trans-unit id="c9da9d1164858d7fbe88433c9e311ee6348ae871" translate="yes" xml:space="preserve">
          <source>Helper class for internal use only. This allows to call a &lt;a href=&quot;../../../../../groovy/lang/closure&quot;&gt;Closure&lt;/a&gt; and convert the result to a boolean. It will do this by caching the possible &quot;doCall&quot; as well as the &quot;asBoolean&quot; in CallSiteArray fashion. &quot;asBoolean&quot; will not be called if the result is null or a Boolean. In case of null we return false and in case of a Boolean we simply unbox. This logic is designed after the one present in &lt;a href=&quot;../typehandling/defaulttypetransformation#castToBoolean(Object)&quot;&gt;DefaultTypeTransformation.castToBoolean&lt;/a&gt;. The purpose of this class is to avoid the slow &quot;asBoolean&quot; call in that method. &lt;a href=&quot;booleanreturningmethodinvoker&quot;&gt;BooleanReturningMethodInvoker&lt;/a&gt; is used for caching.</source>
          <target state="translated">辅助类，仅供内部使用。这允许调用&lt;a href=&quot;../../../../../groovy/lang/closure&quot;&gt;Closure&lt;/a&gt;并将结果转换为布尔值。它将通过以CallSiteArray方式缓存可能的&amp;ldquo; doCall&amp;rdquo;和&amp;ldquo; asBoolean&amp;rdquo;来实现此目的。如果结果为null或布尔值，则不会调用&amp;ldquo; asBoolean&amp;rdquo;。在null的情况下，我们返回false；在Boolean的情况下，我们只是取消装箱。此逻辑是在&lt;a href=&quot;../typehandling/defaulttypetransformation#castToBoolean(Object)&quot;&gt;DefaultTypeTransformation.castToBoolean中&lt;/a&gt;提供的逻辑之后设计的。此类的目的是避免该方法中缓慢的&amp;ldquo; asBoolean&amp;rdquo;调用。&lt;a href=&quot;booleanreturningmethodinvoker&quot;&gt;BooleanReturningMethodInvoker&lt;/a&gt;用于缓存。</target>
        </trans-unit>
        <trans-unit id="08c361ccc9bc9397bb13e503ede19620762f439b" translate="yes" xml:space="preserve">
          <source>Helper class for internal use only. This allows to call a given method and convert the result to a boolean. It will do this by caching the method call as well as the &quot;asBoolean&quot; in &lt;a href=&quot;callsitearray&quot;&gt;CallSiteArray&lt;/a&gt; fashion. &quot;asBoolean&quot; will not be called if the result is null or a Boolean. In case of null we return false and in case of a Boolean we simply unbox. This logic is designed after the one present in &lt;a href=&quot;../typehandling/defaulttypetransformation#castToBoolean(Object)&quot;&gt;DefaultTypeTransformation.castToBoolean&lt;/a&gt;. The purpose of this class is to avoid the slow &quot;asBoolean&quot; call in that method. The nature of this class allows a per instance caching instead of a per class caching like the normal &lt;a href=&quot;callsitearray&quot;&gt;CallSiteArray&lt;/a&gt; logic.</source>
          <target state="translated">辅助类，仅供内部使用。这允许调用给定的方法并将结果转换为布尔值。它将通过以&lt;a href=&quot;callsitearray&quot;&gt;CallSiteArray&lt;/a&gt;方式缓存方法调用以及&amp;ldquo; asBoolean&amp;rdquo;来实现此目的。如果结果为null或布尔值，则不会调用&amp;ldquo; asBoolean&amp;rdquo;。在null的情况下，我们返回false；在Boolean的情况下，我们只是取消装箱。此逻辑是在&lt;a href=&quot;../typehandling/defaulttypetransformation#castToBoolean(Object)&quot;&gt;DefaultTypeTransformation.castToBoolean中&lt;/a&gt;提供的逻辑之后设计的。此类的目的是避免该方法中缓慢的&amp;ldquo; asBoolean&amp;rdquo;调用。此类的性质允许按实例进行缓存，而不是像常规的&lt;a href=&quot;callsitearray&quot;&gt;CallSiteArray&lt;/a&gt;逻辑那样按类进行缓存。</target>
        </trans-unit>
        <trans-unit id="4baf31f3e44f4a830ae84e62e91fa29839c3bc4e" translate="yes" xml:space="preserve">
          <source>Helper class for iterating through nodes.</source>
          <target state="translated">迭代节点的辅助类。</target>
        </trans-unit>
        <trans-unit id="c16a67305d226f8fa576f15de1446959523529ca" translate="yes" xml:space="preserve">
          <source>Helper class for processing Groovy numeric literals.</source>
          <target state="translated">用于处理Groovy数字文字的辅助类。</target>
        </trans-unit>
        <trans-unit id="dfd49f9e7e9b2005f84911ed3928de78ca798405" translate="yes" xml:space="preserve">
          <source>Helper class that crawls all items of the classpath for packages. Retrieves from those sources the list of subpackages and classes on demand.</source>
          <target state="translated">帮助类,用于抓取classpath中所有的包项目。根据需求从这些资源中检索子包和类的列表。</target>
        </trans-unit>
        <trans-unit id="fd1ee99af0c02e3fd76feee055e40bb7996b9cce" translate="yes" xml:space="preserve">
          <source>Helper class that takes an Expression and if visited will load it normally, storing the result in a helper variable, which then can be requested after the visit is completed. A copy of the variable will stay on the stack. Subsequent visits will load the stored value instead of visiting the expression again</source>
          <target state="translated">帮助类,它接受一个Expression,如果访问它,将正常加载它,将结果存储在一个帮助变量中,然后在访问完成后可以请求它。变量的副本将保留在堆栈中。随后的访问将加载存储的值,而不是再次访问该表达式。</target>
        </trans-unit>
        <trans-unit id="222371186cb84c4fb4be9eb7c786f23dfdaeb514" translate="yes" xml:space="preserve">
          <source>Helper class to initialize the Groovy runtime.</source>
          <target state="translated">用于初始化Groovy运行时的辅助类。</target>
        </trans-unit>
        <trans-unit id="474424728aacf125d196bf34f1bacc278655ecd0" translate="yes" xml:space="preserve">
          <source>Helper class to return either a SourceUnit or ClassNode.</source>
          <target state="translated">返回SourceUnit或ClassNode的辅助类。</target>
        </trans-unit>
        <trans-unit id="d036448a18b3739d08f3a35a24b369031627dfcc" translate="yes" xml:space="preserve">
          <source>Helper class to spoof log entries as produced by calling arbitrary code. This allows non-intrusive testing of dependent objects without explicitly using Mock objects as long as those dependent objects do some proper logging. As a measure of last resort, it can be used on MetaClass to spoof it's log entries on 'invokeMethod'.</source>
          <target state="translated">辅助类,用于伪造调用任意代码产生的日志条目。这允许在不明确使用Mock对象的情况下对依赖对象进行非侵入式测试,只要这些依赖对象做了一些适当的日志记录。作为最后的手段,它可以被用于MetaClass,以欺骗它在 &quot;invokeMethod &quot;上的日志条目。</target>
        </trans-unit>
        <trans-unit id="76ce062e1bdc329b2f4b0f1cd94c1f54ee8a656f" translate="yes" xml:space="preserve">
          <source>Helper classes for ASMClassGenerator.</source>
          <target state="translated">ASMClassGenerator的辅助类。</target>
        </trans-unit>
        <trans-unit id="2115bb0332348e91e3e9790d4742e98b48fa2ca0" translate="yes" xml:space="preserve">
          <source>Helper classes for XmlSlurper.</source>
          <target state="translated">XmlSlurper的辅助类。</target>
        </trans-unit>
        <trans-unit id="bb90d95811652d84b518f4c440b739ae26aebcdd" translate="yes" xml:space="preserve">
          <source>Helper for &lt;a href=&quot;classnode&quot;&gt;ClassNode&lt;/a&gt; and classes handling them. Contains a set of pre-defined instances for the most used types and some code for cached node creation and basic handling.</source>
          <target state="translated">&lt;a href=&quot;classnode&quot;&gt;ClassNode的&lt;/a&gt;助手以及处理它们的类。包含一组最常用类型的预定义实例，以及一些用于缓存节点创建和基本处理的代码。</target>
        </trans-unit>
        <trans-unit id="bf0d1deeff1b5753649fd2172b2369e656744689" translate="yes" xml:space="preserve">
          <source>Helper method for entrySet.remove</source>
          <target state="translated">entrySet.remove的辅助方法</target>
        </trans-unit>
        <trans-unit id="8780a8781cd21ff397475f874842eba52a14a01c" translate="yes" xml:space="preserve">
          <source>Helper method to add a new method to a ClassNode.</source>
          <target state="translated">为ClassNode添加新方法的辅助方法。</target>
        </trans-unit>
        <trans-unit id="baec945aec7421962e43545ae29bdceaec7b2835" translate="yes" xml:space="preserve">
          <source>Helper method to add a new method to a ClassNode. Depending on the shouldBeSynthetic flag the call will either be made to ClassNode.addSyntheticMethod() or ClassNode.addMethod(). If a non-synthetic method is to be added the ACC_SYNTHETIC modifier is removed if it has been accidentally supplied.</source>
          <target state="translated">用于向ClassNode添加新方法的辅助方法。根据shouldBeSynthetic标志,将调用ClassNode.addSyntheticMethod()或ClassNode.addMethod()。如果要添加一个非合成方法,如果不小心提供了ACC_SYNTHETIC修饰符,则会被删除。</target>
        </trans-unit>
        <trans-unit id="17ae30764c6e13a8bf759f1780d91286fb15ebe8" translate="yes" xml:space="preserve">
          <source>Helper method to create a buffered writer for a file without writing a BOM.</source>
          <target state="translated">帮助方法为文件创建一个缓冲写入器,而不写入BOM。</target>
        </trans-unit>
        <trans-unit id="83a7ed2116a070d909bc0288a109cd7ad3e14c2a" translate="yes" xml:space="preserve">
          <source>Helper method to create a buffered writer for a file.</source>
          <target state="translated">为文件创建缓冲写入器的辅助方法。</target>
        </trans-unit>
        <trans-unit id="d38fe5dce4fe3f1dc6edf6bee6ac1ac7a655b54c" translate="yes" xml:space="preserve">
          <source>Helper method to create a buffered writer for a file. If the given charset is &quot;UTF-16BE&quot; or &quot;UTF-16LE&quot; (or an equivalent alias), the requisite byte order mark is written to the stream before the writer is returned.</source>
          <target state="translated">为文件创建缓冲写入器的辅助方法。如果给定的字符集是 &quot;UTF-16BE &quot;或 &quot;UTF-16LE&quot;(或等价的别名),则在返回写入器之前,将必要的字节顺序标记写入流中。</target>
        </trans-unit>
        <trans-unit id="e74e748cfd1ed2b35140e469f70143636896d8b9" translate="yes" xml:space="preserve">
          <source>Helper method to create a new BufferedReader for a URL and then passes it to the closure.</source>
          <target state="translated">帮助方法为一个URL创建一个新的BufferedReader,然后将其传递给闭包。</target>
        </trans-unit>
        <trans-unit id="3679675f0dccc348f9339e2febdee69791ff1ef8" translate="yes" xml:space="preserve">
          <source>Helper method to create a new BufferedReader for a URL and then passes it to the closure. The reader is closed after the closure returns.</source>
          <target state="translated">帮助方法为一个URL创建一个新的BufferedReader,然后把它传递给闭包。封闭返回后,阅读器被关闭。</target>
        </trans-unit>
        <trans-unit id="6d09c2f8aeac0318953bb0a3b9058e887329ce4a" translate="yes" xml:space="preserve">
          <source>Helper method to create a new Reader for a URL and then passes it to the closure.</source>
          <target state="translated">帮助方法为一个URL创建一个新的Reader,然后把它传递给关闭。</target>
        </trans-unit>
        <trans-unit id="a97b5bbe8932dabb9f134afe20c57f3152efbc96" translate="yes" xml:space="preserve">
          <source>Helper method to create a new Reader for a URL and then passes it to the closure. The reader is closed after the closure returns.</source>
          <target state="translated">帮助方法为一个URL创建一个新的Reader,然后把它传递给闭包。阅读器在闭包返回后被关闭。</target>
        </trans-unit>
        <trans-unit id="d8238fd0fcd178ae816fac8a807fcac14406dc49" translate="yes" xml:space="preserve">
          <source>Helper method to create a new Reader for a stream and then passes it into the closure.</source>
          <target state="translated">帮助方法为一个流创建一个新的Reader,然后将其传递到闭包中。</target>
        </trans-unit>
        <trans-unit id="89ef2114cacd774335be5aae86bfa79611c81527" translate="yes" xml:space="preserve">
          <source>Helper method to create a new Reader for a stream and then passes it into the closure. The reader (and this stream) is closed after the closure returns.</source>
          <target state="translated">帮助方法为一个流创建一个新的Reader,然后把它传递到闭包中。闭包返回后,阅读器(和这个流)被关闭。</target>
        </trans-unit>
        <trans-unit id="f4a4cd09f4fcf149047c5a4beded7930c7603fc6" translate="yes" xml:space="preserve">
          <source>Helper method to handle object hashes for possibly null values</source>
          <target state="translated">处理对象哈希值可能为空的辅助方法。</target>
        </trans-unit>
        <trans-unit id="c2c30161459e74d0c7a6c3c528c912daa7b7dde6" translate="yes" xml:space="preserve">
          <source>Helper object to support convenience &quot;ignore.methodName&quot; notation similar to demand notation. Can't be used with methods within &lt;code&gt;java.lang.Object&lt;/code&gt;.</source>
          <target state="translated">支持方便性的Helper对象&amp;ldquo; ignore.methodName&amp;rdquo;表示法类似于需求表示法。不能与 &lt;code&gt;java.lang.Object&lt;/code&gt; 中的方法一起使用。</target>
        </trans-unit>
        <trans-unit id="793b42d8f5d0c0e6d39696aa8be4bdc070eb1fb2" translate="yes" xml:space="preserve">
          <source>Helper to construct a new instance from the given arguments.</source>
          <target state="translated">帮助我们从给定的参数中构建一个新的实例。</target>
        </trans-unit>
        <trans-unit id="7d910d66f2efb7b0c69346a1b0c4fc52ba45c0bb" translate="yes" xml:space="preserve">
          <source>Helper to construct a new instance from the given arguments. The constructor is called based on the number and types in the args array. Use &lt;code&gt;newInstance(null)&lt;/code&gt; or simply &lt;code&gt;newInstance()&lt;/code&gt; for the default (no-arg) constructor.</source>
          <target state="translated">帮手根据给定的参数构造一个新实例。根据args数组中的数量和类型调用构造函数。使用 &lt;code&gt;newInstance(null)&lt;/code&gt; 或仅将 &lt;code&gt;newInstance()&lt;/code&gt; 用作默认（无参数）构造函数。</target>
        </trans-unit>
        <trans-unit id="1b398a14d7f2f9c7efa941461f22a964a6ba84d6" translate="yes" xml:space="preserve">
          <source>Helper to interpret a source buffer.</source>
          <target state="translated">帮助解释源缓冲区。</target>
        </trans-unit>
        <trans-unit id="1062b2b2a06a74947e8272b47dd4a66468522e2d" translate="yes" xml:space="preserve">
          <source>Helper to make logging from Ant easier.</source>
          <target state="translated">帮助你更容易地从Ant登录。</target>
        </trans-unit>
        <trans-unit id="b33925cefc1ea4dbe82eb4352788d7f5451ce913" translate="yes" xml:space="preserve">
          <source>Helper to turn a list with an even number of elements into a Map.</source>
          <target state="translated">帮助将一个包含偶数元素的列表变成一个Map。</target>
        </trans-unit>
        <trans-unit id="bb284d4f5c4e1ae6821a5a81024fe1f60ab0567a" translate="yes" xml:space="preserve">
          <source>Helping to create a few standard AST constructs</source>
          <target state="translated">帮助创建一些标准的AST结构。</target>
        </trans-unit>
        <trans-unit id="562d2542948855096edf020dcbb8bd2f628504c5" translate="yes" xml:space="preserve">
          <source>Here is a simple example of how to annotate a class with Vetoable:</source>
          <target state="translated">下面是一个简单的例子,说明如何用Vetoable注释一个类。</target>
        </trans-unit>
        <trans-unit id="b8440ce9750ed4d2b8950578a72b1a0b0979f598" translate="yes" xml:space="preserve">
          <source>Here is an example of how to use this class to open a listening socket on the server, listen for incoming data, and then echo the data back to the client in reverse order:</source>
          <target state="translated">下面是一个例子,说明如何使用这个类在服务器上打开一个监听套接字,监听传入的数据,然后以相反的顺序将数据回传给客户端。</target>
        </trans-unit>
        <trans-unit id="e65f2082d5bfef68a65771c010804c8af3022fe6" translate="yes" xml:space="preserve">
          <source>Here is an example of usage. We will create a groovy classloader which only supports arithmetic operations and imports the &lt;code&gt;java.lang.Math&lt;/code&gt; classes by default.</source>
          <target state="translated">这是用法示例。我们将创建一个仅支持算术运算的groovy类加载器，并默认情况下导入 &lt;code&gt;java.lang.Math&lt;/code&gt; 类。</target>
        </trans-unit>
        <trans-unit id="7496207acd98e443ba54028307f06f17d35bf210" translate="yes" xml:space="preserve">
          <source>Here is an example using a delegate parameter.</source>
          <target state="translated">下面是一个使用委托参数的例子。</target>
        </trans-unit>
        <trans-unit id="a62bd4799dde46dc9b70cc58f103089cf2d3419d" translate="yes" xml:space="preserve">
          <source>Here is an example which converts the vowels in a word from lower to uppercase:</source>
          <target state="translated">下面是一个将单词中的元音从小写转换为大写的例子。</target>
        </trans-unit>
        <trans-unit id="e62d07e8cad545a0f1595d3dbff0bf70ec979010" translate="yes" xml:space="preserve">
          <source>Here is an example, which only logs the class name during compilation:</source>
          <target state="translated">下面是一个例子,在编译时只记录类名。</target>
        </trans-unit>
        <trans-unit id="540ee2aaf7182c6dfc449b18e5accb694e3b0894" translate="yes" xml:space="preserve">
          <source>Here is an example:</source>
          <target state="translated">下面是一个例子。</target>
        </trans-unit>
        <trans-unit id="275a6e48f4b65805932d0d641a91ddc6693d6d56" translate="yes" xml:space="preserve">
          <source>Here name is a place holder for info, debug, warning, error, etc. If the expression exp is a constant or only a variable access the method call will not be transformed. But this will still cause a call on the injected logger.</source>
          <target state="translated">这里name是信息、debug、警告、错误等的占位符。如果表达式exp是一个常量或只是一个变量访问,方法调用将不会被转换。但这仍然会引起注入的记录器的调用。</target>
        </trans-unit>
        <trans-unit id="93e39c3309b18b1afd9c198b704b1e229b623994" translate="yes" xml:space="preserve">
          <source>Here name is a place holder for info, fine, finer, finest, config, warning, severe. NAME is name transformed to upper case. if anything else is used it will result in an exception at runtime. If the expression exp is a constant or only a variable access the method call will not be transformed. But this will still cause a call on the injected logger.</source>
          <target state="translated">这里name是info、fine、fineer、fineer、config、warning、severe的占位符。name是名字转换为大写.如果使用其他任何东西,将导致运行时的异常。如果表达式exp是一个常量或只是一个变量访问,方法调用将不会被转换。但这仍然会导致对注入的记录器的调用。</target>
        </trans-unit>
        <trans-unit id="33eebf2412447da05840a6c8eb96fd539ce96dee" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;Family&lt;/code&gt; is our class under test and &lt;code&gt;Person&lt;/code&gt; is the collaborator. We are using normal Groovy property semantics here; hence the statement &lt;code&gt;father.first&lt;/code&gt; causes a call to &lt;code&gt;father.getFirst()&lt;/code&gt; to occur. For a complete list of features, see: &lt;a href=&quot;mockfor&quot;&gt;MockFor&lt;/a&gt;.</source>
          <target state="translated">在这里， &lt;code&gt;Family&lt;/code&gt; 是我们正在接受测试的班级，而 &lt;code&gt;Person&lt;/code&gt; 是合作者。我们在这里使用常规的Groovy属性语义；因此，语句 &lt;code&gt;father.first&lt;/code&gt; 导致对 &lt;code&gt;father.getFirst()&lt;/code&gt; 的调用发生。有关功能的完整列表，请参见：&lt;a href=&quot;mockfor&quot;&gt;MockFor&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0068249f4298ba4b8cb950944bb5666562f37a15" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;Family&lt;/code&gt; is our class under test and &lt;code&gt;Person&lt;/code&gt; is the collaborator. We are using normal Groovy property semantics here; hence the statement &lt;code&gt;mother.last&lt;/code&gt; causes a call to &lt;code&gt;mother.getLast()&lt;/code&gt; to occur. The following features are supported:</source>
          <target state="translated">在这里， &lt;code&gt;Family&lt;/code&gt; 是我们正在接受测试的班级，而 &lt;code&gt;Person&lt;/code&gt; 是合作者。我们在这里使用常规的Groovy属性语义；因此，语句 &lt;code&gt;mother.last&lt;/code&gt; 导致对 &lt;code&gt;mother.getLast()&lt;/code&gt; 的调用发生。支持以下功能：</target>
        </trans-unit>
        <trans-unit id="3a750735f9dd5059970987198f4e24adb1303b69" translate="yes" xml:space="preserve">
          <source>Hook method to setup the GroovyScriptEngine to use.</source>
          <target state="translated">用于设置GroovyScriptEngine的Hook方法。</target>
        </trans-unit>
        <trans-unit id="557bb37db36ea1b9f3e09f6142ba1c0c6ef48cf7" translate="yes" xml:space="preserve">
          <source>Hook to allow derived classes to access the log</source>
          <target state="translated">允许派生类访问日志的钩子</target>
        </trans-unit>
        <trans-unit id="42aa6177be434867ae51a0ddcdbd339e7c150075" translate="yes" xml:space="preserve">
          <source>Hook to allow derived classes to override behavior associated with extracting params from a GString.</source>
          <target state="translated">钩子,允许派生类覆盖与从GString提取参数相关的行为。</target>
        </trans-unit>
        <trans-unit id="d0f5ce21a0465fc3ed72d68900c5c2583bd65750" translate="yes" xml:space="preserve">
          <source>Hook to allow derived classes to override behavior associated with setting params for a prepared statement.</source>
          <target state="translated">钩子,允许派生类覆盖与为准备好的语句设置参数相关的行为。</target>
        </trans-unit>
        <trans-unit id="163b9f2daeb8ed52a6a7c24ecac6c960628e1076" translate="yes" xml:space="preserve">
          <source>Hook to allow derived classes to override behavior associated with setting params for a prepared statement. Default behavior is to append the parameters to the given statement using &lt;code&gt;setObject&lt;/code&gt;.</source>
          <target state="translated">挂钩允许派生类重写与为准备好的语句设置参数相关的行为。默认行为是使用 &lt;code&gt;setObject&lt;/code&gt; 将参数附加到给定语句。</target>
        </trans-unit>
        <trans-unit id="8abb605b91bf3dd645006899f7cb959678a216e0" translate="yes" xml:space="preserve">
          <source>Hook to allow derived classes to override behavior associated with the parsing and indexing of parameters from a given sql statement.</source>
          <target state="translated">钩子允许派生类覆盖与给定sql语句的参数解析和索引相关的行为。</target>
        </trans-unit>
        <trans-unit id="03c964c7bb8028d6ec12d052e6f3f38c90d760ef" translate="yes" xml:space="preserve">
          <source>Hook to allow derived classes to override list of result collection behavior.</source>
          <target state="translated">钩子允许派生类覆盖结果收集行为的列表。</target>
        </trans-unit>
        <trans-unit id="47385c1ef384fe6d7b6374027599713cf51dd26e" translate="yes" xml:space="preserve">
          <source>Hook to allow derived classes to override list of result collection behavior. The default behavior is to return a list of GroovyRowResult objects corresponding to each row in the ResultSet.</source>
          <target state="translated">钩子,允许派生类覆盖结果收集行为的列表,默认行为是返回ResultSet中每行对应的GroovyRowResult对象列表。默认的行为是返回ResultSet中每条记录对应的GroovyRowResult对象列表。</target>
        </trans-unit>
        <trans-unit id="3c170ec8c359e27ae40b22929c8c6d4ca2cca184" translate="yes" xml:space="preserve">
          <source>Hook to allow derived classes to override null handling.</source>
          <target state="translated">钩子,允许派生类覆盖null处理。</target>
        </trans-unit>
        <trans-unit id="5af345513ecc35c6b880bdad5fb15f4dbe46262a" translate="yes" xml:space="preserve">
          <source>Hook to allow derived classes to override null handling. Default behavior is to replace ?'&quot;? references with NULLish</source>
          <target state="translated">钩子,允许派生类覆盖null处理。默认的行为是用NULLish来代替?'&quot;?引用。</target>
        </trans-unit>
        <trans-unit id="deeeed053368e20a57e4b6d96719bdebf30fa4ee" translate="yes" xml:space="preserve">
          <source>Hook to allow derived classes to override sql generation from GStrings.</source>
          <target state="translated">钩子允许派生类覆盖GStrings的sql生成。</target>
        </trans-unit>
        <trans-unit id="bfdfe397f860cdbc770460591d51b50488bdb138" translate="yes" xml:space="preserve">
          <source>Hook to allow derived classes to override where clause sniffing.</source>
          <target state="translated">允许派生类覆盖where子句嗅探的钩子。</target>
        </trans-unit>
        <trans-unit id="957bb3dd3871ddf1a6ca5aaf6951df7947fa1727" translate="yes" xml:space="preserve">
          <source>Hook to allow derived classes to override where clause sniffing. Default behavior is to find the first 'where' keyword in the sql doing simple avoidance of the word 'where' within quotes.</source>
          <target state="translated">钩子允许派生类覆盖where子句嗅探。默认的行为是在sql中找到第一个'where'关键字,简单的避开引号内的'where'一词。</target>
        </trans-unit>
        <trans-unit id="bc8be380ed7c5196400ccbece94ca34ab1d0e1d5" translate="yes" xml:space="preserve">
          <source>How it works: The decorated list intercepts all calls to &lt;code&gt;getAt(index)&lt;/code&gt; and &lt;code&gt;get(index)&lt;/code&gt;. If an index greater than or equal to the current &lt;code&gt;size()&lt;/code&gt; is used, the list will grow automatically up to the specified index. Gaps will be filled by &lt;code&gt;null&lt;/code&gt;. If a default value should also be used to fill gaps instead of &lt;code&gt;null&lt;/code&gt;, use &lt;code&gt;withEagerDefault&lt;/code&gt;. If &lt;code&gt;getAt(index)&lt;/code&gt; or &lt;code&gt;get(index)&lt;/code&gt; are called and a null value is found, it is assumed that the null value was a consequence of an earlier grow list operation and the &lt;code&gt;init&lt;/code&gt; Closure is called to populate the value.</source>
          <target state="translated">工作原理：修饰后的列表拦截对 &lt;code&gt;getAt(index)&lt;/code&gt; 和 &lt;code&gt;get(index)&lt;/code&gt; 的所有调用。如果使用大于或等于当前 &lt;code&gt;size()&lt;/code&gt; 的索引，则列表将自动增长到指定的索引。间隙将由 &lt;code&gt;null&lt;/code&gt; 填充。如果还应使用默认值而不是 &lt;code&gt;null&lt;/code&gt; 来填补空白，请使用 &lt;code&gt;withEagerDefault&lt;/code&gt; 。如果调用了 &lt;code&gt;getAt(index)&lt;/code&gt; 或 &lt;code&gt;get(index)&lt;/code&gt; 并找到了空值，则假定该空值是较早的增长列表操作的结果，并且调用了 &lt;code&gt;init&lt;/code&gt; Closure来填充该值。</target>
        </trans-unit>
        <trans-unit id="a6265ad045882bcf65ad36de46a5365ec0c9beea" translate="yes" xml:space="preserve">
          <source>How it works: The decorated list intercepts all calls to &lt;code&gt;getAt(index)&lt;/code&gt; and &lt;code&gt;get(index)&lt;/code&gt;. If an index greater than or equal to the current &lt;code&gt;size()&lt;/code&gt; is used, the list will grow automatically up to the specified index. Gaps will be filled by calling the &lt;code&gt;init&lt;/code&gt; Closure. If generating a default value is a costly operation consider using &lt;code&gt;withLazyDefault&lt;/code&gt;.</source>
          <target state="translated">工作原理：修饰后的列表拦截对 &lt;code&gt;getAt(index)&lt;/code&gt; 和 &lt;code&gt;get(index)&lt;/code&gt; 的所有调用。如果使用大于或等于当前 &lt;code&gt;size()&lt;/code&gt; 的索引，则列表将自动增长到指定的索引。差距将通过调用 &lt;code&gt;init&lt;/code&gt; Closure来填补。如果生成默认值是一项昂贵的操作，请考虑使用 &lt;code&gt;withLazyDefault&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="49e5f8dc37e91a0bbba74cf26874f8074a84e393" translate="yes" xml:space="preserve">
          <source>How many arguments this option has represented as a String.</source>
          <target state="translated">这个选项有多少个参数用一个字符串表示。</target>
        </trans-unit>
        <trans-unit id="6083750120522c896c288699d5774a52f6d7a729" translate="yes" xml:space="preserve">
          <source>How many arguments this option has represented as a String. Only allowed for array-typed arguments. Overrides &lt;code&gt;numberOfArguments&lt;/code&gt; if set. The special values of '+' means one or more and '*' as 0 or more.</source>
          <target state="translated">此选项以一个字符串表示的参数数量。仅允许用于数组类型的参数。如果设置，则覆盖 &lt;code&gt;numberOfArguments&lt;/code&gt; 。特殊值&amp;ldquo; +&amp;rdquo;表示一个或多个，&amp;ldquo; *&amp;rdquo;表示0或多个。</target>
        </trans-unit>
        <trans-unit id="9e0576c47d83f1ed4a8fd87be8e6dc45b05f06e1" translate="yes" xml:space="preserve">
          <source>How many arguments this option has.</source>
          <target state="translated">这个选项有多少个参数。</target>
        </trans-unit>
        <trans-unit id="92f83d4d2c6d023193b71d61aa6ce36f53260c9a" translate="yes" xml:space="preserve">
          <source>How many arguments this option has. A value greater than 1 is only allowed for array-typed arguments. Ignored for boolean options which are assumed to have a default of 0 or if &lt;code&gt;numberOfArgumentsString&lt;/code&gt; is set.</source>
          <target state="translated">该选项有多少个参数。仅对于数组类型的参数，允许使用大于1的值。忽略默认值为0或设置了 &lt;code&gt;numberOfArgumentsString&lt;/code&gt; 的布尔选项。</target>
        </trans-unit>
        <trans-unit id="5fd94ef08224c6200790e4a482e323959218c820" translate="yes" xml:space="preserve">
          <source>Hunt for the script file by calling searchForGroovyScriptFile(String).</source>
          <target state="translated">通过调用searchForGroovyScriptFile(String)来寻找脚本文件。</target>
        </trans-unit>
        <trans-unit id="2530c52218b9f3255d7229299c3a4da99546fd74" translate="yes" xml:space="preserve">
          <source>Hyphens at the start or end of sourceSet or replacementSet are treated as normal hyphens and are not considered to be part of a range specification. Similarly, a hyphen immediately after an earlier range is treated as a normal hyphen. So, '-x', 'x-' have no ranges while 'a-c-e' has the range 'a-c' plus the '-' character plus the 'e' character.</source>
          <target state="translated">源集(sourceSet)或替换集(replacementSet)开头或结尾的连字符被视为正常的连字符,不被视为范围规格的一部分。同样,紧接在早期范围之后的连字符也被视为正常的连字符。因此,'-x'、'x-'没有范围,而'a-c-e'的范围是'a-c'加上'-'字符再加上'e'字符。</target>
        </trans-unit>
        <trans-unit id="481bdbd566bdb153feaaee549ccd93b273c12162" translate="yes" xml:space="preserve">
          <source>I don't know how many days in a month unless I know the name of the month (and if it's a leap year if the month is February)</source>
          <target state="translated">我不知道一个月有多少天,除非我知道月份的名称(如果是闰年,如果月份是二月,我就不知道)。</target>
        </trans-unit>
        <trans-unit id="570097fca9261245d59a01adc60556e3f605688c" translate="yes" xml:space="preserve">
          <source>I don't know how many days in a year unless I know if it's a leap year or not.</source>
          <target state="translated">我不知道一年有多少天,除非我知道是不是闰年。</target>
        </trans-unit>
        <trans-unit id="fa6df889286973cac5d2338ddc245bc54677f4c8" translate="yes" xml:space="preserve">
          <source>I've split out constructors separately; we could maybe integrate back into variableDefinitions later on if we maybe simplified 'def' to be a type declaration?</source>
          <target state="translated">我把构造函数单独拆出来了,如果我们也许把'def'简化为类型声明,也许以后可以整合回variableDefinitions?</target>
        </trans-unit>
        <trans-unit id="c6a18dbdcb7e3f9a93fd907dc091279b10c4053f" translate="yes" xml:space="preserve">
          <source>IFileNameFinder</source>
          <target state="translated">IFileNameFinder</target>
        </trans-unit>
        <trans-unit id="f7784d0b19464062418f9e2df5195aafadaec560" translate="yes" xml:space="preserve">
          <source>IGroovyClassOperation</source>
          <target state="translated">IGroovyClassOperation</target>
        </trans-unit>
        <trans-unit id="319a21ad8b671794467e4935946062d4d1e04338" translate="yes" xml:space="preserve">
          <source>IOException</source>
          <target state="translated">IOException</target>
        </trans-unit>
        <trans-unit id="af8054e60e63cbcd7d22e3588e999c473d5170a9" translate="yes" xml:space="preserve">
          <source>IOException An IO exception from the parser, possibly from a byte stream or character stream supplied by the application.</source>
          <target state="translated">IOException 来自解析器的 IO 异常,可能来自应用程序提供的字节流或字符流。</target>
        </trans-unit>
        <trans-unit id="bb2c57248f1cfda0851f69e8fda8bc55cd3f3e29" translate="yes" xml:space="preserve">
          <source>IOException if &lt;code&gt;self&lt;/code&gt; is not readable</source>
          <target state="translated">IOException如果 &lt;code&gt;self&lt;/code&gt; 不可读</target>
        </trans-unit>
        <trans-unit id="2de304c02aef07d80da93a49a0bb0b0a56210596" translate="yes" xml:space="preserve">
          <source>IOException if File object specified does not exist</source>
          <target state="translated">如果指定的文件对象不存在,则出现IOException。</target>
        </trans-unit>
        <trans-unit id="a81a2a9bd97d43eeee50fdea2622f599f4c7a152" translate="yes" xml:space="preserve">
          <source>IOException if an I/O error occurs while creating the input stream</source>
          <target state="translated">如果在创建输入流时发生I/O错误,则出现IOException。</target>
        </trans-unit>
        <trans-unit id="9016029862d523792a41e66df49e2ab478b5beb0" translate="yes" xml:space="preserve">
          <source>IOException if an I/O error occurs.</source>
          <target state="translated">如果发生I/O错误,则出现IOException。</target>
        </trans-unit>
        <trans-unit id="31c78d56260fb2549a59806c9e8d30df48cfbdad" translate="yes" xml:space="preserve">
          <source>IOException if an IO error occurs</source>
          <target state="translated">如果发生IO错误,则出现IOException</target>
        </trans-unit>
        <trans-unit id="6444994a22d683c483d26f44cfdf4cdc6ce94f4f" translate="yes" xml:space="preserve">
          <source>IOException if an IO exception occurs</source>
          <target state="translated">IOException,如果发生IO异常</target>
        </trans-unit>
        <trans-unit id="21a2996f1dac7f11c748670809e38bad18c3069c" translate="yes" xml:space="preserve">
          <source>IOException if an IOException occurs</source>
          <target state="translated">如果发生IOException,则发生IOException</target>
        </trans-unit>
        <trans-unit id="5e444b0e26e3aba34793725e201cd9d8eb37db4a" translate="yes" xml:space="preserve">
          <source>IOException if an IOException occurs.</source>
          <target state="translated">如果发生IOException,则发生IOException。</target>
        </trans-unit>
        <trans-unit id="dbc7c2323635b7481a19aefcc6c5256274cfba52" translate="yes" xml:space="preserve">
          <source>IOException if an error occurred while outputting data to the writer</source>
          <target state="translated">如果向写入器输出数据时发生错误,出现IOException。</target>
        </trans-unit>
        <trans-unit id="729ef0a896110411f741eaeaa0a2769d504db348" translate="yes" xml:space="preserve">
          <source>IOException if an input or output error occurs while the servlet is handling the HTTP request</source>
          <target state="translated">如果在servlet处理HTTP请求时发生输入或输出错误,则出现IOException。</target>
        </trans-unit>
        <trans-unit id="dc4439fe60d7bc5dd5de80cf57c6a82362585a0f" translate="yes" xml:space="preserve">
          <source>IOException if an issue arises opening and reading the file.</source>
          <target state="translated">如果在打开和读取文件时出现问题,出现IOException。</target>
        </trans-unit>
        <trans-unit id="1680b390bb0c479ca9c55f76eadc59d42776874c" translate="yes" xml:space="preserve">
          <source>IOException if error occurs on underlying Writer</source>
          <target state="translated">如果在底层写入器上发生错误,则出现IOException。</target>
        </trans-unit>
        <trans-unit id="c947d9d7075c4f149fcfe8a57576790ab82f7a45" translate="yes" xml:space="preserve">
          <source>IOException if it is not possible to open an connection for the given source</source>
          <target state="translated">如果无法为给定的源打开连接,则出现IOException。</target>
        </trans-unit>
        <trans-unit id="7123874a45a1a13b1ae5e467d117664c46c51e1b" translate="yes" xml:space="preserve">
          <source>IOException if reading from this URL is impossible</source>
          <target state="translated">如果无法从这个URL读取,则出现IOException。</target>
        </trans-unit>
        <trans-unit id="b585f7da4f232edb9e98b39e191378a9d1d76e98" translate="yes" xml:space="preserve">
          <source>IOException if reading or parsing the contents of the stream fails</source>
          <target state="translated">如果读取或解析流的内容失败,则出现IOException。</target>
        </trans-unit>
        <trans-unit id="33be085d88045ec9ac6f9d5cc14527305e5aea00" translate="yes" xml:space="preserve">
          <source>IOException if the source is not readable</source>
          <target state="translated">如果源不可读,则出现IOException。</target>
        </trans-unit>
        <trans-unit id="ab872db00b9a76825c74e6082492bc47a0181dcd" translate="yes" xml:space="preserve">
          <source>IOGroovyMethods#withStream(java.io.OutputStream, groovy.lang.Closure)</source>
          <target state="translated">IOGroovyMethods#withStream(java.io.OutputStream,groovy.lang.Closure)</target>
        </trans-unit>
        <trans-unit id="604450c0f1409c4b9caad0f89e5807db8562f55a" translate="yes" xml:space="preserve">
          <source>IOGroovyMethods.eachByte</source>
          <target state="translated">IOGroovyMethods.eachByte</target>
        </trans-unit>
        <trans-unit id="a07051d03eb862cd30fc8c0560d57db6c0cedf47" translate="yes" xml:space="preserve">
          <source>IOGroovyMethods.eachLine</source>
          <target state="translated">IOGroovyMethods.eachLine</target>
        </trans-unit>
        <trans-unit id="28bfb1c375b3df59599ceec0e64dc33dd8d595bb" translate="yes" xml:space="preserve">
          <source>IOGroovyMethods.eachObject</source>
          <target state="translated">IOGroovyMethods.eachObject</target>
        </trans-unit>
        <trans-unit id="cd1456866b84be01465b2b25381128c10253020d" translate="yes" xml:space="preserve">
          <source>IOGroovyMethods.filterLine</source>
          <target state="translated">IOGroovyMethods.filterLine</target>
        </trans-unit>
        <trans-unit id="f9717f16f5b1ce0118028237ae24db896fd16fd9" translate="yes" xml:space="preserve">
          <source>IOGroovyMethods.readLines</source>
          <target state="translated">IOGroovyMethods.readLines</target>
        </trans-unit>
        <trans-unit id="747c7db6469155967248b0032590fc6fcc6b2145" translate="yes" xml:space="preserve">
          <source>IOGroovyMethods.splitEachLine</source>
          <target state="translated">IOGroovyMethods.splitEachLine</target>
        </trans-unit>
        <trans-unit id="5e5c82ef0ddae99974ce6622b22b0d4c673965fd" translate="yes" xml:space="preserve">
          <source>IOGroovyMethods.withCloseable</source>
          <target state="translated">IOGroovyMethods.withCloseable</target>
        </trans-unit>
        <trans-unit id="324ef6ca8f847b85eb566ed00d45b5ff9ef4355b" translate="yes" xml:space="preserve">
          <source>IOGroovyMethods.withStream</source>
          <target state="translated">IOGroovyMethods.withStream</target>
        </trans-unit>
        <trans-unit id="8c6dbbfd6a7457dbf30c41d9430ab586ca61ce98" translate="yes" xml:space="preserve">
          <source>IOW, if self is before then the result is a negative value.</source>
          <target state="translated">即,如果self在前,那么结果就是一个负值。</target>
        </trans-unit>
        <trans-unit id="13ae91c047948d58175eeed72436686a416a2bd8" translate="yes" xml:space="preserve">
          <source>IPrimaryClassNodeOperation</source>
          <target state="translated">IPrimaryClassNodeOperation</target>
        </trans-unit>
        <trans-unit id="2827acacda25593d432db89f7d10b6faf7781d28" translate="yes" xml:space="preserve">
          <source>ISourceUnitOperation</source>
          <target state="translated">ISourceUnitOperation</target>
        </trans-unit>
        <trans-unit id="62c939e74447ccafb2c3d7f88939b78b1a4282a5" translate="yes" xml:space="preserve">
          <source>Idea copied from HtmlUnit (many thanks to Marc Guillemot). Future versions maybe available in the JUnit distribution.</source>
          <target state="translated">这个想法抄袭自HtmlUnit(非常感谢Marc Guillemot)。未来的版本也许可以在JUnit发行版中使用。</target>
        </trans-unit>
        <trans-unit id="7bdf629e3211995680b7bd6208e387293f7b3fb1" translate="yes" xml:space="preserve">
          <source>IdentifierCompleter</source>
          <target state="translated">IdentifierCompleter</target>
        </trans-unit>
        <trans-unit id="809445acd133835bb504c0b08ac65317699dbd33" translate="yes" xml:space="preserve">
          <source>IdentifierCompletor</source>
          <target state="translated">IdentifierCompletor</target>
        </trans-unit>
        <trans-unit id="0ee8e3fbc3a91775dc8cee1e4c47932adcf00b19" translate="yes" xml:space="preserve">
          <source>Identifies a variable to be expanded into the sql string rather than representing a placeholder.</source>
          <target state="translated">识别一个要扩展到sql字符串中的变量,而不是代表一个占位符。</target>
        </trans-unit>
        <trans-unit id="db86701ab5e0f8cefca1421dc5eaecdd6b8fdcd5" translate="yes" xml:space="preserve">
          <source>Identifies the Closure where the mocked collaborator behavior will be applied and verified.</source>
          <target state="translated">确定将应用和验证模拟合作者行为的Closure。</target>
        </trans-unit>
        <trans-unit id="7f4016481c56c661eb920356ab533024815a03de" translate="yes" xml:space="preserve">
          <source>Identity check.</source>
          <target state="translated">检查身份;</target>
        </trans-unit>
        <trans-unit id="e5b0f605cfd3b1809f02d214d14b90d0976b5360" translate="yes" xml:space="preserve">
          <source>Identity check. Since == is overridden in Groovy with the meaning of equality we need some fallback to check for object identity. Invoke using the 'is' method, like so: &lt;code&gt;def same = this.is(that)&lt;/code&gt;</source>
          <target state="translated">身份检查。由于==在Groovy中具有相等的含义被覆盖，因此我们需要进行一些后备检查以检查对象身份。使用'is'方法调用，如下所示： &lt;code&gt;def same = this.is(that)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ac6e6d9ec43d8b050b412fdbec16bdabc675ddc0" translate="yes" xml:space="preserve">
          <source>Identity conversion which returns Boolean.TRUE for a true Boolean and Boolean.FALSE for a false Boolean.</source>
          <target state="translated">身份转换,对于真布尔值返回Boolean.TRUE,对于假布尔值返回Boolean.FALSE。</target>
        </trans-unit>
        <trans-unit id="b0bbc17f5eb8f149cb15a19c0c9cc72f83203dc9" translate="yes" xml:space="preserve">
          <source>If '&lt;code&gt;properties&lt;/code&gt;' is supplied, neither '&lt;code&gt;user&lt;/code&gt;' nor '&lt;code&gt;password&lt;/code&gt;' should be supplied.</source>
          <target state="translated">如果提供&amp;ldquo; &lt;code&gt;properties&lt;/code&gt; &amp;rdquo;，则不应提供&amp;ldquo; &lt;code&gt;user&lt;/code&gt; &amp;rdquo;或&amp;ldquo; &lt;code&gt;password&lt;/code&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="fbe4d1ccad1b32966f8eee3ebafa4fc5886d6403" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;autoDelegate&lt;/code&gt; is false (the default), all parameters are treated as if they were named parameters</source>
          <target state="translated">如果 &lt;code&gt;autoDelegate&lt;/code&gt; 为false（默认值），则将所有参数视为已命名为参数</target>
        </trans-unit>
        <trans-unit id="9641390fd88b1b5f45e1aa68e88a69ce90e1ff9f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;autoDelegate&lt;/code&gt; is true, the first parameters is treated as if it was a delegate parameter</source>
          <target state="translated">如果 &lt;code&gt;autoDelegate&lt;/code&gt; 为true，则第一个参数将被视为委托参数。</target>
        </trans-unit>
        <trans-unit id="1be8e0e64157a1559562c09edb701f59adcaba00" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;builder&lt;/code&gt; is null a new instance with default capacity will be created.</source>
          <target state="translated">如果 &lt;code&gt;builder&lt;/code&gt; 为null，则将创建具有默认容量的新实例。</target>
        </trans-unit>
        <trans-unit id="2cb00889bfb942130788ad9b678e16c2e1e3546a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;exception&lt;/code&gt; is defined, &lt;code&gt;message&lt;/code&gt; can be used to specify the exception message.</source>
          <target state="translated">如果定义了 &lt;code&gt;exception&lt;/code&gt; ，则 &lt;code&gt;message&lt;/code&gt; 可用于指定异常消息。</target>
        </trans-unit>
        <trans-unit id="c88f2bd0beac01bd9b32c898a716a52b9f331226" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;exception&lt;/code&gt; is defined, &lt;code&gt;message&lt;/code&gt; can be used to specify the exception message. Will be ignored if &lt;code&gt;code&lt;/code&gt; is defined or &lt;code&gt;exception&lt;/code&gt; isn't defined.</source>
          <target state="translated">如果定义了 &lt;code&gt;exception&lt;/code&gt; ，则 &lt;code&gt;message&lt;/code&gt; 可用于指定异常消息。如果定义了 &lt;code&gt;code&lt;/code&gt; 或未定义 &lt;code&gt;exception&lt;/code&gt; 则将被忽略。</target>
        </trans-unit>
        <trans-unit id="68878c4d6a62426875bab1f5c5b269b867215d25" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;lazyDefaultValues&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; any gaps when growing the list are filled with nulls. Subsequent attempts to retrieve items from the list from those gap index values will, upon finding null, call the &lt;code&gt;initClosure&lt;/code&gt; to populate the list for the given list value. Hence, when in this mode, nulls cannot be stored in this list. If &lt;code&gt;lazyDefaultValues&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; any gaps when growing the list are filled eagerly by calling the &lt;code&gt;initClosure&lt;/code&gt; for all gap indexes during list growth. No calls to &lt;code&gt;initClosure&lt;/code&gt; are made except during list growth and it is ok to store null values in the list when in this mode.</source>
          <target state="translated">如果 &lt;code&gt;lazyDefaultValues&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ,则在增长列表时的所有空白都将填充为null。后续尝试从这些间隙索引值中检索列表中的项目时，发现空值时，将调用 &lt;code&gt;initClosure&lt;/code&gt; 为给定列表值填充列表。因此，在此模式下，不能在该列表中存储空值。如果 &lt;code&gt;lazyDefaultValues&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; ，则通过在列表增长过程中为所有差距索引调用 &lt;code&gt;initClosure&lt;/code&gt; 来迅速填充列表增长时的所有差距。除在列表增长期间外， &lt;code&gt;initClosure&lt;/code&gt; 进行任何调用，并且在此模式下，可以在列表中存储空值。</target>
        </trans-unit>
        <trans-unit id="e6dcd9d8c8040a9c5af1f0fecd12a54adeb027a0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;mustExist&lt;/code&gt; is true and the normal variable doesn't exist, then this method will throw a GroovyBugError. It is not the intention of this method to let this happen! And the exception should not be used for flow control - it is just acting as an assertion. If the exception is thrown then it indicates a bug in the class using CompileStack. This method can also not be used to return a temporary variable. Temporary variables are not normal variables.</source>
          <target state="translated">如果 &lt;code&gt;mustExist&lt;/code&gt; 为true并且普通变量不存在，则此方法将引发GroovyBugError。这种方法的目的不是让这种情况发生！并且异常不应用于流控制-它仅充当断言。如果抛出异常，则表明使用CompileStack的类中存在错误。此方法也不能用于返回临时变量。临时变量不是普通变量。</target>
        </trans-unit>
        <trans-unit id="aaa89ce9d01303c26c9df2683b05b4b22d3a0dfb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;optionalArg=true&lt;/code&gt;, then &lt;code&gt;args=3&lt;/code&gt; is the equivalent of &lt;code&gt;arity=&quot;0..3&quot;&lt;/code&gt; in picocli. When &lt;code&gt;optionalArg=true&lt;/code&gt;, &lt;code&gt;args='+'&lt;/code&gt; is equivalent to &lt;code&gt;arity=&quot;0..*&quot;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;optionalArg=true&lt;/code&gt; ，则 &lt;code&gt;args=3&lt;/code&gt; 等于picocli中的 &lt;code&gt;arity=&quot;0..3&quot;&lt;/code&gt; 。当 &lt;code&gt;optionalArg=true&lt;/code&gt; 时， &lt;code&gt;args='+'&lt;/code&gt; 等效于 &lt;code&gt;arity=&quot;0..*&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cd46b28e6ad8a2e6b9b5b8ec1f915585316dafca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;response.getWriter()&lt;/code&gt; is called directly (without using out), then a write method call on 'sout' will not cause the &lt;code&gt;IllegalStateException&lt;/code&gt;, but it will still be invalid. It is the responsibility of the user of this class, to not to mix these different usage styles. The same applies to calling &lt;code&gt;response.getOutputStream()&lt;/code&gt; and using 'out' or 'html'.</source>
          <target state="translated">如果直接（不使用out）调用 &lt;code&gt;response.getWriter()&lt;/code&gt; ，则对'sout'的write方法调用不会导致 &lt;code&gt;IllegalStateException&lt;/code&gt; ，但仍然无效。此类用户的责任是不要混用这些不同的用法样式。这同样适用于调用 &lt;code&gt;response.getOutputStream()&lt;/code&gt; 并使用'out'或'html'。</target>
        </trans-unit>
        <trans-unit id="940189632ab709388054fed597b891395031b506" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, this adds a method &lt;code&gt;copyWith&lt;/code&gt; which takes a Map of new property values and returns a new instance of the Immutable class with these values set.</source>
          <target state="translated">如果为 &lt;code&gt;true&lt;/code&gt; ，则添加一个方法 &lt;code&gt;copyWith&lt;/code&gt; ，该方法采用新属性值的Map并返回设置了这些值的Immutable类的新实例。</target>
        </trans-unit>
        <trans-unit id="629e0634b773d0b4eaa623c6a0e1247f18871be4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, this adds a method &lt;code&gt;copyWith&lt;/code&gt; which takes a Map of new property values and returns a new instance of the Immutable class with these values set. Example:</source>
          <target state="translated">如果为 &lt;code&gt;true&lt;/code&gt; ，则添加一个方法 &lt;code&gt;copyWith&lt;/code&gt; ，该方法采用新属性值的Map并返回设置了这些值的Immutable类的新实例。例子：</target>
        </trans-unit>
        <trans-unit id="d5cf85387dfd98e168be29f06d68dbea93608d91" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, this option must be specified on the command line, or an exception is thrown.</source>
          <target state="translated">如果为 &lt;code&gt;true&lt;/code&gt; ，则必须在命令行上指定此选项，否则将引发异常。</target>
        </trans-unit>
        <trans-unit id="493c10ab345693291a4f685ee3d8ac2b7eaf7829" translate="yes" xml:space="preserve">
          <source>If US-ASCII is recognized, enforce to return the default encoding, rather than US-ASCII.</source>
          <target state="translated">如果识别US-ASCII,则执行返回默认编码,而不是US-ASCII。</target>
        </trans-unit>
        <trans-unit id="78368e20d6221f338d8e9f6469d0e719dba5429c" translate="yes" xml:space="preserve">
          <source>If US-ASCII is recognized, enforce to return the default encoding, rather than US-ASCII. It might be a file without any special character in the range 128-255, but that may be or become a file encoded with the default &lt;code&gt;charset&lt;/code&gt; rather than US-ASCII.</source>
          <target state="translated">如果识别出US-ASCII，则强制返回默认编码，而不是US-ASCII。它可能是一个没有任何特殊字符的文件，范围在128-255之间，但是可能是或成为使用默认 &lt;code&gt;charset&lt;/code&gt; 而不是US-ASCII编码的文件。</target>
        </trans-unit>
        <trans-unit id="ee40f66bc8eef2ff3bbab44b379b11be2ac312f6" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;bindable&quot;&gt;Bindable&lt;/a&gt; annotation is detected it also adds support similar to what &lt;a href=&quot;bindableasttransformation&quot;&gt;BindableASTTransformation&lt;/a&gt; would do.</source>
          <target state="translated">如果检测到&lt;a href=&quot;bindable&quot;&gt;Bindable&lt;/a&gt;批注，则还会添加与&lt;a href=&quot;bindableasttransformation&quot;&gt;BindableASTTransformation&lt;/a&gt;相似的支持。</target>
        </trans-unit>
        <trans-unit id="00e7d1b673d879df7d885dfa5637d643507faec6" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;vetoable&quot;&gt;Vetoable&lt;/a&gt; annotation is detected it does nothing and lets the &lt;a href=&quot;vetoableasttransformation&quot;&gt;VetoableASTTransformation&lt;/a&gt; handle all the changes.</source>
          <target state="translated">如果检测到&lt;a href=&quot;vetoable&quot;&gt;Vetoable&lt;/a&gt;批注，&lt;a href=&quot;vetoableasttransformation&quot;&gt;则不&lt;/a&gt;执行任何操作，并让VetoableASTTransformation处理所有更改。</target>
        </trans-unit>
        <trans-unit id="d5c69f733688abdc090d4f2396adbb581e5bd455" translate="yes" xml:space="preserve">
          <source>If a capture group is optional, and doesn't match, then the corresponding value for that capture group passed to the closure will be null as illustrated here:</source>
          <target state="translated">如果一个捕获组是可选的,并且不匹配,那么传递给闭包的该捕获组的对应值将为空,如这里所示。</target>
        </trans-unit>
        <trans-unit id="90b770581b40db979b640a8dd650ff56c15547bf" translate="yes" xml:space="preserve">
          <source>If a dot is followed by a parenthesized or quoted expression, the member is computed dynamically, and the member selection is done only at runtime.</source>
          <target state="translated">如果点后面是小括号或引号表达式,则成员是动态计算的,成员选择只在运行时进行。</target>
        </trans-unit>
        <trans-unit id="f4503683c4aae2db746405121221f531a66a727b" translate="yes" xml:space="preserve">
          <source>If a dot is followed by a parenthesized or quoted expression, the member is computed dynamically, and the member selection is done only at runtime. This forces a statically unchecked member access.</source>
          <target state="translated">如果点后面是小括号或引号表达式,则成员是动态计算的,成员选择只在运行时进行。这样就会强制静态地不选中成员访问。</target>
        </trans-unit>
        <trans-unit id="3b41f55c2946e3637ea992f39e08a252a7adb4e4" translate="yes" xml:space="preserve">
          <source>If a match is found the error message associated with the matching exception is returned. If no match was found the method will fail.</source>
          <target state="translated">如果找到了匹配,则返回与匹配异常相关的错误信息。如果没有找到匹配信息,方法将失败。</target>
        </trans-unit>
        <trans-unit id="6586d27c39a3152cb046c7bbf3ad5494dc9e8c80" translate="yes" xml:space="preserve">
          <source>If a match is found, the matching exception is returned otherwise the method will fail.</source>
          <target state="translated">如果找到了匹配,则返回匹配异常,否则该方法将失败。</target>
        </trans-unit>
        <trans-unit id="bb7e2e1b63f36bbc6d69bc624993c88bcba256bd" translate="yes" xml:space="preserve">
          <source>If a method call returns a parameterized type, then we can perform additional inference on the return type, so that the type gets actual type parameters.</source>
          <target state="translated">如果一个方法调用返回的是一个参数化的类型,那么我们可以对返回类型进行额外的推理,从而使该类型得到实际的类型参数。</target>
        </trans-unit>
        <trans-unit id="e4563bd31d34a89cfef32b95992399a15e933223" translate="yes" xml:space="preserve">
          <source>If a method call returns a parameterized type, then we can perform additional inference on the return type, so that the type gets actual type parameters. For example, the method Arrays.asList(T...) is generified with type T which can be deduced from actual type arguments.</source>
          <target state="translated">如果一个方法调用返回的是一个参数化的类型,那么我们可以对返回类型进行额外的推理,从而使该类型得到实际的类型参数。例如,方法Arrays.asList(T......)的类型是由T生成的,它可以从实际的类型参数中推导出来。</target>
        </trans-unit>
        <trans-unit id="87b9c05cf2362f9aae014be5a15cfca3ab208d2c" translate="yes" xml:space="preserve">
          <source>If a method with the given name and parameters is already defined then it is returned otherwise the given method is added to this node.</source>
          <target state="translated">如果给定名称和参数的方法已经被定义,那么它将被返回,否则给定的方法将被添加到这个节点。</target>
        </trans-unit>
        <trans-unit id="d724b42c340749475f71a55e82c0df0cee2cc938" translate="yes" xml:space="preserve">
          <source>If a method with the given name and parameters is already defined then it is returned otherwise the given method is added to this node. This method is useful for default method adding like getProperty() or invokeMethod() where there may already be a method defined in a class and so the default implementations should not be added if already present.</source>
          <target state="translated">如果一个给定名称和参数的方法已经被定义,那么它将被返回,否则给定的方法将被添加到这个节点。这个方法对于默认方法的添加很有用,比如getProperty()或invokeMethod(),在这些类中可能已经定义了一个方法,所以如果已经存在,就不应该添加默认的实现。</target>
        </trans-unit>
        <trans-unit id="8cc5e5d09a808408d257fb7d6a4e83a2d943c79c" translate="yes" xml:space="preserve">
          <source>If a property with a user defined setter method is annotated the code block is wrapped with the needed code to fire off the event.</source>
          <target state="translated">如果一个带有用户定义的setter方法的属性被注解,代码块就会被所需的代码包裹起来,以启动事件。</target>
        </trans-unit>
        <trans-unit id="74b17e55582302b1fb390bc11397777dfd6afe3d" translate="yes" xml:space="preserve">
          <source>If a value is present in the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html&quot;&gt;Optional&lt;/a&gt;, returns a &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html&quot;&gt;Stream&lt;/a&gt; with the value as its source or else an empty stream.</source>
          <target state="translated">如果&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html&quot;&gt;Optional中&lt;/a&gt;存在一个值，则返回一个以该值作为源的&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html&quot;&gt;Stream&lt;/a&gt;，否则返回一个空流。</target>
        </trans-unit>
        <trans-unit id="ab8bb890b0e9914e1e0b2838b7f3d03cda85ed1b" translate="yes" xml:space="preserve">
          <source>If a value is present in the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/OptionalDouble.html&quot;&gt;OptionalDouble&lt;/a&gt;, returns a &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/stream/DoubleStream.html&quot;&gt;DoubleStream&lt;/a&gt; with the value as its source or else an empty stream.</source>
          <target state="translated">如果&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/OptionalDouble.html&quot;&gt;OptionalDouble中&lt;/a&gt;存在一个值，则返回一个以该值作为源的&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/stream/DoubleStream.html&quot;&gt;DoubleStream&lt;/a&gt;，否则返回一个空流。</target>
        </trans-unit>
        <trans-unit id="6f85fc39b5b8281b592e05f35c750a34edc95c8f" translate="yes" xml:space="preserve">
          <source>If a value is present in the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/OptionalInt.html&quot;&gt;OptionalInt&lt;/a&gt;, returns an &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/stream/IntStream.html&quot;&gt;IntStream&lt;/a&gt; with the value as its source or else an empty stream.</source>
          <target state="translated">如果&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/OptionalInt.html&quot;&gt;OptionalInt中&lt;/a&gt;存在一个值，则返回一个以该值作为源的&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/stream/IntStream.html&quot;&gt;IntStream&lt;/a&gt;，否则返回一个空流。</target>
        </trans-unit>
        <trans-unit id="554eb4fd4592493a71ca79163c940e2fd95f916a" translate="yes" xml:space="preserve">
          <source>If a value is present in the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/OptionalLong.html&quot;&gt;OptionalLong&lt;/a&gt;, returns a &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/stream/LongStream.html&quot;&gt;LongStream&lt;/a&gt; with the value as its source or else an empty stream.</source>
          <target state="translated">如果&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/OptionalLong.html&quot;&gt;OptionalLong中&lt;/a&gt;存在值，则返回以该值作为源的&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/stream/LongStream.html&quot;&gt;LongStream&lt;/a&gt;，否则返回空流。</target>
        </trans-unit>
        <trans-unit id="47ac1fcf84d1d229cb530849c7c8be6fbf268318" translate="yes" xml:space="preserve">
          <source>If a value is present in the &lt;code&gt;OptionalDouble&lt;/code&gt;, returns an &lt;code&gt;Optional&lt;/code&gt; consisting of the result of applying the given function to the value or else empty.</source>
          <target state="translated">如果 &lt;code&gt;OptionalDouble&lt;/code&gt; 中存在一个值，则返回一个 &lt;code&gt;Optional&lt;/code&gt; ,其中包括将给定函数应用于该值的结果，否则为空。</target>
        </trans-unit>
        <trans-unit id="6642e96a6015fdcad698486be3721a989ddfc435" translate="yes" xml:space="preserve">
          <source>If a value is present in the &lt;code&gt;OptionalDouble&lt;/code&gt;, returns an &lt;code&gt;OptionalDouble&lt;/code&gt; consisting of the result of applying the given function to the value or else empty.</source>
          <target state="translated">如果 &lt;code&gt;OptionalDouble&lt;/code&gt; 中存在一个值，则返回一个 &lt;code&gt;OptionalDouble&lt;/code&gt; ,其中包括将给定函数应用于该值的结果，否则为空。</target>
        </trans-unit>
        <trans-unit id="d925f75ac160186f59c30c0d35aa24060b8d4b13" translate="yes" xml:space="preserve">
          <source>If a value is present in the &lt;code&gt;OptionalDouble&lt;/code&gt;, returns the value, otherwise throws &lt;code&gt;NoSuchElementException&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;OptionalDouble&lt;/code&gt; 中存在一个值，则返回该值，否则抛出 &lt;code&gt;NoSuchElementException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9c58cb62508a55f624764f60308d12b50d4fa3ac" translate="yes" xml:space="preserve">
          <source>If a value is present in the &lt;code&gt;OptionalDouble&lt;/code&gt;, tests the value using the given predicate and returns the optional if the test returns true or empty otherwise.</source>
          <target state="translated">如果 &lt;code&gt;OptionalDouble&lt;/code&gt; 中存在一个值，则使用给定的谓词测试该值，如果测试返回true或为空，则返回可选值。</target>
        </trans-unit>
        <trans-unit id="f18ec045602967791a57464fbc92701e4d51c03c" translate="yes" xml:space="preserve">
          <source>If a value is present in the &lt;code&gt;OptionalInt&lt;/code&gt;, returns an &lt;code&gt;Optional&lt;/code&gt; consisting of the result of applying the given function to the value or else empty.</source>
          <target state="translated">如果 &lt;code&gt;OptionalInt&lt;/code&gt; 中存在一个值，则返回一个 &lt;code&gt;Optional&lt;/code&gt; ,其中包括将给定函数应用于该值的结果，否则为空。</target>
        </trans-unit>
        <trans-unit id="8ffdd5aabe94d577312183db4007bc6ae08a62bb" translate="yes" xml:space="preserve">
          <source>If a value is present in the &lt;code&gt;OptionalInt&lt;/code&gt;, returns an &lt;code&gt;OptionalInt&lt;/code&gt; consisting of the result of applying the given function to the value or else empty.</source>
          <target state="translated">如果 &lt;code&gt;OptionalInt&lt;/code&gt; 中存在一个值，则返回一个 &lt;code&gt;OptionalInt&lt;/code&gt; ，该值由将给定函数应用于该值的结果组成，否则为空。</target>
        </trans-unit>
        <trans-unit id="cad88c260ee3091e553632cb67e5df0a9019d118" translate="yes" xml:space="preserve">
          <source>If a value is present in the &lt;code&gt;OptionalInt&lt;/code&gt;, returns the value, otherwise throws &lt;code&gt;NoSuchElementException&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;OptionalInt&lt;/code&gt; 中存在一个值，则返回该值，否则抛出 &lt;code&gt;NoSuchElementException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2515b6c54728bda755889c35d240edc614e7cd70" translate="yes" xml:space="preserve">
          <source>If a value is present in the &lt;code&gt;OptionalInt&lt;/code&gt;, tests the value using the given predicate and returns the optional if the test returns true or else empty.</source>
          <target state="translated">如果 &lt;code&gt;OptionalInt&lt;/code&gt; 中存在值，则使用给定的谓词测试该值，如果测试返回true或为空，则返回可选值。</target>
        </trans-unit>
        <trans-unit id="5e778153562a7960fe4b94cd4f349b185c3e6389" translate="yes" xml:space="preserve">
          <source>If a value is present in the &lt;code&gt;OptionalLong&lt;/code&gt;, returns an &lt;code&gt;Optional&lt;/code&gt; consisting of the result of applying the given function to the value or else empty.</source>
          <target state="translated">如果 &lt;code&gt;OptionalLong&lt;/code&gt; 中存在一个值，则返回一个 &lt;code&gt;Optional&lt;/code&gt; ,其中包括将给定函数应用于该值的结果，否则为空。</target>
        </trans-unit>
        <trans-unit id="fd3a9e174d76e3b6caf9283ab38ba95719928fec" translate="yes" xml:space="preserve">
          <source>If a value is present in the &lt;code&gt;OptionalLong&lt;/code&gt;, returns an &lt;code&gt;OptionalLong&lt;/code&gt; consisting of the result of applying the given function to the value or else empty.</source>
          <target state="translated">如果 &lt;code&gt;OptionalLong&lt;/code&gt; 中存在一个值，则返回一个 &lt;code&gt;OptionalLong&lt;/code&gt; ,其中包括将给定函数应用于该值的结果，否则为空。</target>
        </trans-unit>
        <trans-unit id="ed875f95a3f792f3e9be667cd5d8237b2136a8e5" translate="yes" xml:space="preserve">
          <source>If a value is present in the &lt;code&gt;OptionalLong&lt;/code&gt;, returns the value, otherwise throws &lt;code&gt;NoSuchElementException&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;OptionalLong&lt;/code&gt; 中存在一个值，则返回该值，否则抛出 &lt;code&gt;NoSuchElementException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6f9aa35ab2c32f9b3efa287fb5846a62f29941f7" translate="yes" xml:space="preserve">
          <source>If a value is present in the &lt;code&gt;OptionalLong&lt;/code&gt;, tests the value using the given predicate and returns the optional if the test returns true or else empty.</source>
          <target state="translated">如果 &lt;code&gt;OptionalLong&lt;/code&gt; 中存在值，则使用给定的谓词测试该值，如果测试返回true或为空，则返回可选值。</target>
        </trans-unit>
        <trans-unit id="8424474eba6ceede86c0c9f12185ad235946a871" translate="yes" xml:space="preserve">
          <source>If an &quot;underscore&quot; version of the respective method already exists, then no default implementation is provided.</source>
          <target state="translated">如果相应方法的 &quot;下划线 &quot;版本已经存在,则不提供默认实现。</target>
        </trans-unit>
        <trans-unit id="d1b01e2032148a80322e31f501f355face136765" translate="yes" xml:space="preserve">
          <source>If an empty array of closures is supplied the IDENTITY Closure will be used.</source>
          <target state="translated">如果提供了一个空的闭包数组,将使用IDENTITY闭包。</target>
        </trans-unit>
        <trans-unit id="82bc73f47d5c7c8ab2288c6ff44b6e3abff67e77" translate="yes" xml:space="preserve">
          <source>If an empty list of closures is supplied the IDENTITY Closure will be used.</source>
          <target state="translated">如果提供了一个空的闭包列表,将使用IDENTITY闭包。</target>
        </trans-unit>
        <trans-unit id="2f2abf56f90259914f21658fd286a4fcc0166c1e" translate="yes" xml:space="preserve">
          <source>If an input stream is open for the current row, a call to the method &lt;code&gt;next&lt;/code&gt; will implicitly close it. A &lt;code&gt;getResultSet()&lt;/code&gt; object's warning chain is cleared when a new row is read.</source>
          <target state="translated">如果为当前行打开了输入流，则对 &lt;code&gt;next&lt;/code&gt; 方法的调用将隐式将其关闭。一 &lt;code&gt;getResultSet()&lt;/code&gt; 当读取一个新的行对象的警告链被清除。</target>
        </trans-unit>
        <trans-unit id="938cfb2384e5104f7870bf4ab3b12bddb7621ef3" translate="yes" xml:space="preserve">
          <source>If any other type is given, the call is delegated to &lt;a href=&quot;defaultgroovymethods#asType(Object,Class)&quot;&gt;DefaultGroovyMethods.asType&lt;/a&gt;.</source>
          <target state="translated">如果给出任何其他类型，则将调用委派给&lt;a href=&quot;defaultgroovymethods#asType(Object,Class)&quot;&gt;DefaultGroovyMethods.asType&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2f8c408d39a6843dcec1b731c7750661cde099c1" translate="yes" xml:space="preserve">
          <source>If c is a primitive class this method returns a boxed version otherwise c is returned.</source>
          <target state="translated">如果c是一个基元类,本方法将返回一个盒装版本,否则将返回c。</target>
        </trans-unit>
        <trans-unit id="c764d8652ff416fa1e7baeaf3f12e364c65c4b5d" translate="yes" xml:space="preserve">
          <source>If c is a primitive class this method returns a boxed version otherwise c is returned. In java 1.5 this can be simplified thanks to the Type class.</source>
          <target state="translated">如果c是一个基元类,这个方法就会返回一个框定的版本,否则就会返回c。在java 1.5中,由于Type类的存在,这个方法可以被简化。</target>
        </trans-unit>
        <trans-unit id="7f63ee4f7d9f0f19b14ca42df6d2be25504632c8" translate="yes" xml:space="preserve">
          <source>If cache is enabled, then templates are compiled once for each source (URL or File).</source>
          <target state="translated">如果启用了缓存,那么每个源(URL或文件)都会编译一次模板。</target>
        </trans-unit>
        <trans-unit id="3709a4d48b18f71236cadae06fa18d54c5fde6c1" translate="yes" xml:space="preserve">
          <source>If cache is enabled, then templates are compiled once for each source (URL or File). It is recommended to keep this flag to true unless you are in development mode and want automatic reloading of templates.</source>
          <target state="translated">如果启用了缓存,那么对每个源(URL或文件)都会编译一次模板。建议将该标志保持为true,除非你在开发模式下想要自动重新加载模板。</target>
        </trans-unit>
        <trans-unit id="deed72fd6f71ccb2c5890d7ad59e444b77351190" translate="yes" xml:space="preserve">
          <source>If calling inside a process and you don't want the JVM to exit on an error call commandLineCompile(String[]), which this method simply wraps</source>
          <target state="translated">如果在进程内部调用,并且你不想让JVM在出错时退出,则调用commandLineCompile(String[]),这个方法只是简单地包装了一下。</target>
        </trans-unit>
        <trans-unit id="dbc6bcf60cbf4e01b252725b8bfc70a47f8c0ff8" translate="yes" xml:space="preserve">
          <source>If childName ends in {consonant}y, replace 'y' with &quot;ies&quot;. For example, allergy to allergies.</source>
          <target state="translated">如果childName以{辅音}y结尾,则用 &quot;ies &quot;代替'y'。例如,对过敏症过敏。</target>
        </trans-unit>
        <trans-unit id="442162ce9da751d1028aa15f7629d60b3edd6fda" translate="yes" xml:space="preserve">
          <source>If defined, all unimplemented methods will execute the code found within the supplied closure.</source>
          <target state="translated">如果定义了,所有未实现的方法将执行在提供的闭包中找到的代码。</target>
        </trans-unit>
        <trans-unit id="a51304925607198ae5f1730335c0a539fd38435b" translate="yes" xml:space="preserve">
          <source>If defined, all unimplemented methods will throw this exception.</source>
          <target state="translated">如果定义了,所有未实现的方法都会抛出这个异常。</target>
        </trans-unit>
        <trans-unit id="91827f1613a3e6da280972c7905478aec02dfdf6" translate="yes" xml:space="preserve">
          <source>If defined, all unimplemented methods will throw this exception. Will be ignored if &lt;code&gt;code&lt;/code&gt; is defined.</source>
          <target state="translated">如果定义，则所有未实现的方法都将引发此异常。如果定义了 &lt;code&gt;code&lt;/code&gt; 将被忽略。</target>
        </trans-unit>
        <trans-unit id="fe37eadc9109834730a2d52eb286970b06c229b6" translate="yes" xml:space="preserve">
          <source>If defined, tests which unexpectedly pass will throw this exception.</source>
          <target state="translated">如果定义了,意外通过的测试会抛出这个异常。</target>
        </trans-unit>
        <trans-unit id="f7326377b23cdeec0e3181b39a51722bcc2eeda2" translate="yes" xml:space="preserve">
          <source>If defined, tests which unexpectedly pass will throw this exception. The supplied exception class should have a constructor variant accepting a single String error message.</source>
          <target state="translated">如果定义了,意外通过的测试将抛出这个异常。提供的异常类应该有一个构造函数变体,接受一个单一的字符串错误信息。</target>
        </trans-unit>
        <trans-unit id="6a3362bc449e5167ee76c5f945fad34ec24267b4" translate="yes" xml:space="preserve">
          <source>If for example you look at x = 1 + 2l we have the first category applying to the number 1 being int, since the 1 is an int. The 2l is a long, therefore the int category will not apply and the result type can't be int. The next category in the list is long, and since both apply to long, the result type is a long.</source>
          <target state="translated">例如,如果你看x=1+2l,我们有第一个类别适用于数字1是int,因为1是一个int。2l是一个long,因此int类别将不适用,结果类型不能是int。下一个类别是long,由于这两个类别都适用于long,所以结果类型是long。</target>
        </trans-unit>
        <trans-unit id="5eb9ed5b52ba9968e515b1e701325429d2c239df" translate="yes" xml:space="preserve">
          <source>If instead of &lt;code&gt;newInstance&lt;/code&gt; you use &lt;code&gt;withInstance&lt;/code&gt;, then &lt;code&gt;close()&lt;/code&gt; will be called automatically for you.</source>
          <target state="translated">如果您使用 &lt;code&gt;withInstance&lt;/code&gt; 而不是 &lt;code&gt;newInstance&lt;/code&gt; ，那么将自动为您调用 &lt;code&gt;close()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e5c42a3a46a9788c409281ad777f2993948e1836" translate="yes" xml:space="preserve">
          <source>If it does match and we don't have any capture groups in our regex, there is a single parameter on the closure that the match gets passed to:</source>
          <target state="translated">如果它确实匹配,而且我们的regex中没有任何捕获组,那么匹配的结果会被传递给一个单一的参数。</target>
        </trans-unit>
        <trans-unit id="f494722999ef5b864350f74a802a230ba3628e7d" translate="yes" xml:space="preserve">
          <source>If it does match, we get the matching string back:</source>
          <target state="translated">如果确实匹配,我们就会得到匹配的字符串回来。</target>
        </trans-unit>
        <trans-unit id="c70187db616b55fcfd2e4cbb5e558f94a51267fc" translate="yes" xml:space="preserve">
          <source>If it is set to false, only previously downloaded grapes will be used. This may cause failure in the grape call if the library has not yet been downloaded</source>
          <target state="translated">如果将其设置为false,则只使用之前下载的葡萄。如果库尚未下载,这可能会导致葡萄调用失败。</target>
        </trans-unit>
        <trans-unit id="4d17a8467eb80d6bf1779114bbec378e2beef877" translate="yes" xml:space="preserve">
          <source>If it is set to false, only previously downloaded grapes will be used. This may cause failure in the grape call if the library has not yet been downloaded.</source>
          <target state="translated">如果将其设置为false,则只使用之前下载的葡萄。如果葡萄库尚未下载,这可能会导致葡萄调用失败。</target>
        </trans-unit>
        <trans-unit id="fef1fc4b5245b8af08268f2c5f998421ab97143f" translate="yes" xml:space="preserve">
          <source>If it is set to true, then any jars not already downloaded will automatically be downloaded. Also, any versions expressed as a range will be checked for new versions and downloaded (with dependencies) if found.</source>
          <target state="translated">如果设置为true,那么任何尚未下载的jar都会被自动下载。此外,任何以范围表示的版本都会被检查是否有新的版本,如果发现有新的版本就会下载(包括依赖关系)。</target>
        </trans-unit>
        <trans-unit id="fd9149e8db335357ba07493f34e072fd0e558b1b" translate="yes" xml:space="preserve">
          <source>If it is set to true, then any jars not already downloaded will automatically be downloaded. Also, any versions expressed as a range will be checked for new versions and downloaded (with dependencies) if found. By default it is set to true.</source>
          <target state="translated">如果设置为true,那么任何尚未下载的jar都会被自动下载。此外,任何以范围表示的版本都会被检查是否有新的版本,如果发现有新的版本就会下载(包括依赖关系)。默认情况下,它被设置为 &quot;true&quot;。</target>
        </trans-unit>
        <trans-unit id="10d50a4c77df253055e12c2ecc9fe6a0ebd5e4a2" translate="yes" xml:space="preserve">
          <source>If manual verification is required</source>
          <target state="translated">如果需要人工核查</target>
        </trans-unit>
        <trans-unit id="b5772fc42f893708d53daa7dae28dcc657980bc8" translate="yes" xml:space="preserve">
          <source>If multiple candidate signatures are found after applying type hints, a conflict resolver can attempt to resolve the ambiguity.</source>
          <target state="translated">如果在应用类型提示后发现多个候选签名,冲突解决器可以尝试解决歧义。</target>
        </trans-unit>
        <trans-unit id="b8d933645aa015006414f8185e275306ad8ab117" translate="yes" xml:space="preserve">
          <source>If multiple delegation targets are used and the same method signature occurs in more than one of the respective delegate types, then the delegate will be made to the first defined target having that signature. If this does occur, it might be regarded as a smell (or at least poor style) and it might be clearer to do the delegation by long hand.</source>
          <target state="translated">如果使用了多个委托目标,并且相同的方法签名出现在各自的委托类型中的一个以上,那么将向具有该签名的第一个定义目标进行委托。如果确实发生了这种情况,可能会被认为是一种气味(至少是风格不佳),用长手做委托可能会更清楚。</target>
        </trans-unit>
        <trans-unit id="133211e7628ba98c4009bf6c6b276dd90f91f446" translate="yes" xml:space="preserve">
          <source>If neither an allowed list nor a disallowed list is set, then everything is permitted.</source>
          <target state="translated">如果既没有设置允许的列表,也没有设置不允许的列表,那么所有的东西都是允许的。</target>
        </trans-unit>
        <trans-unit id="37e2e3564b496b9412d2345b26f5ec66f936a149" translate="yes" xml:space="preserve">
          <source>If no further options are specified, this is the default style for &lt;code&gt;@Canonical&lt;/code&gt; and &lt;code&gt;@EqualsAndHashCode&lt;/code&gt; annotated classes. The advantage of this style is that it allows inheritance to be used in limited cases where its purpose is for overriding implementation details rather than creating a derived type with different behavior. This is useful when using JPA Proxies for example or as shown in the following examples:</source>
          <target state="translated">如果未指定其他选项，则这是 &lt;code&gt;@Canonical&lt;/code&gt; 和 &lt;code&gt;@EqualsAndHashCode&lt;/code&gt; 注释类的默认样式。这种样式的优点是，它允许在有限的情况下使用继承，在这种情况下，继承的目的是重写实现细节，而不是创建具有不同行为的派生类型。例如，在使用JPA代理或如以下示例所示时，这很有用：</target>
        </trans-unit>
        <trans-unit id="11449d785cedd736a5372a0f44e9f579638c992e" translate="yes" xml:space="preserve">
          <source>If no parameters with &lt;code&gt;@NamedParam&lt;/code&gt; or &lt;code&gt;@NamedDelegate&lt;/code&gt; annotations are found then:</source>
          <target state="translated">如果找不到带有 &lt;code&gt;@NamedParam&lt;/code&gt; 或 &lt;code&gt;@NamedDelegate&lt;/code&gt; 批注的参数，则：</target>
        </trans-unit>
        <trans-unit id="0b37698cada5bd14814c9002b94be59a00c96d8c" translate="yes" xml:space="preserve">
          <source>If one of '&lt;code&gt;user&lt;/code&gt;' or '&lt;code&gt;password&lt;/code&gt;' is supplied, both should be supplied.</source>
          <target state="translated">如果提供了&amp;ldquo; &lt;code&gt;user&lt;/code&gt; &amp;rdquo;或&amp;ldquo; &lt;code&gt;password&lt;/code&gt; &amp;rdquo;之一，则应同时提供两者。</target>
        </trans-unit>
        <trans-unit id="ac9be1ea585ef9f7ce15dfdcffd2675eb85665c8" translate="yes" xml:space="preserve">
          <source>If one of your properties contains an object that doesn't support cloning or attempts deep copying of a data structure containing an object that doesn't support cloning, then a &lt;code&gt;CloneNotSupportedException&lt;/code&gt; may occur at runtime.</source>
          <target state="translated">如果您的一个属性包含一个不支持克隆的对象，或者尝试深度复制包含一个不支持克隆的对象的数据结构，则在运行时可能会发生 &lt;code&gt;CloneNotSupportedException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5b37d7a7e4bc5d1b1e83c2d07eb9b7d99aac35c6" translate="yes" xml:space="preserve">
          <source>If parent.propertyName is a Collection it will try to add child to the collection.</source>
          <target state="translated">如果parent.propertyName是一个集合,它将尝试将子集添加到集合中。</target>
        </trans-unit>
        <trans-unit id="cb272e13d27c9faf4899d07f6b14b988964664e9" translate="yes" xml:space="preserve">
          <source>If replacementSet is smaller than sourceSet, then the last character from replacementSet is used as the replacement for all remaining source characters as shown here:</source>
          <target state="translated">如果replacementSet小于sourceSet,那么就用replacementSet中的最后一个字符替代所有剩余的源字符,如这里所示。</target>
        </trans-unit>
        <trans-unit id="8a22ac35379c7ad7fca1ce931140aa8529326844" translate="yes" xml:space="preserve">
          <source>If set to false, 'public static void main' method will not be displayed.</source>
          <target state="translated">如果设置为false,'public static void main'方法将不显示。</target>
        </trans-unit>
        <trans-unit id="b282ceba11a7e31eba4fa20c872d35d39d73dcc1" translate="yes" xml:space="preserve">
          <source>If set to false, 'public static void main' method will not be displayed. Defaults to true. Ignored when not processing Scripts.</source>
          <target state="translated">如果设置为false,'public static void main'方法将不显示。默认值为true。不处理Scripts时忽略。</target>
        </trans-unit>
        <trans-unit id="af803be21af00b873e4d3c29708c59ee09776510" translate="yes" xml:space="preserve">
          <source>If set to false, Scripts will not be processed.</source>
          <target state="translated">如果设置为false,则不会处理Scripts。</target>
        </trans-unit>
        <trans-unit id="945f77a1c6631a03dcbc6ccce6cc47971e413b1f" translate="yes" xml:space="preserve">
          <source>If set to false, Scripts will not be processed. Defaults to true.</source>
          <target state="translated">如果设置为false,则不处理Scripts。默认为 &quot;true&quot;。</target>
        </trans-unit>
        <trans-unit id="ee8488aea8ff0eb53a3233d06958c245621da42d" translate="yes" xml:space="preserve">
          <source>If set to false, author will not be displayed.</source>
          <target state="translated">如果设置为 &quot;false&quot;,将不显示作者。</target>
        </trans-unit>
        <trans-unit id="d7fe65d0541733888c0c7a5c3edecaccd62fb873" translate="yes" xml:space="preserve">
          <source>If set to false, author will not be displayed. Currently not used.</source>
          <target state="translated">如果设置为false,将不显示作者。目前不使用。</target>
        </trans-unit>
        <trans-unit id="924596b8eab3a7c90b36d314eb99b21495e09929" translate="yes" xml:space="preserve">
          <source>If set to true, hidden timestamp will not appear within generated HTML.</source>
          <target state="translated">如果设置为 &quot;true&quot;,则在生成的HTML中不会出现隐藏的时间戳。</target>
        </trans-unit>
        <trans-unit id="1290c5f8f6a3fd9fd698ec47d1cffb3e0a894ba7" translate="yes" xml:space="preserve">
          <source>If set to true, hidden version stamp will not appear within generated HTML.</source>
          <target state="translated">如果设置为 &quot;true&quot;,则在生成的HTML中不会出现隐藏的版本标记。</target>
        </trans-unit>
        <trans-unit id="bb28fa8fc2c0dd16a2b735e12b187aa2e8dacef7" translate="yes" xml:space="preserve">
          <source>If sourceSet contains repeated characters, the last specified replacement is used as shown here:</source>
          <target state="translated">如果sourceSet包含重复的字符,则使用最后一个指定的替换,如这里所示。</target>
        </trans-unit>
        <trans-unit id="0f62e029dec1e453ee6dc6c5bb1c2c89305032ba" translate="yes" xml:space="preserve">
          <source>If specified, must match the &quot;id&quot; attribute in a VisibilityOptions annotation to enable a custom visibility.</source>
          <target state="translated">如果指定,必须匹配VisibilityOptions注解中的 &quot;id &quot;属性以启用自定义可见性。</target>
        </trans-unit>
        <trans-unit id="9c893c222de9039ded36f868dd74389bfcca897f" translate="yes" xml:space="preserve">
          <source>If specified, must match the optional &quot;id&quot; attribute in an applicable &lt;code&gt;VisibilityOptions&lt;/code&gt; annotation.</source>
          <target state="translated">如果指定，则必须与适用的 &lt;code&gt;VisibilityOptions&lt;/code&gt; 批注中的可选&amp;ldquo; id&amp;rdquo;属性匹配。</target>
        </trans-unit>
        <trans-unit id="5b329502c5afbf78007fcf1795a382005f0dee9a" translate="yes" xml:space="preserve">
          <source>If strict mode is true, then when the compiler generates a cast, it will disable Groovy casts and rely on a strict cast (CHECKCAST).</source>
          <target state="translated">如果strict模式为true,那么当编译器生成一个cast时,它将禁用Groovy casts,而依靠严格的cast(CHECKCAST)。</target>
        </trans-unit>
        <trans-unit id="42fc83ab5a0db551349bb6e6708c97a9ac857534" translate="yes" xml:space="preserve">
          <source>If supported, Causes the values to be propagated from the target to the source, If not supported, an exception may be thrown</source>
          <target state="translated">如果支持,使值从目标传播到源,如果不支持,可能会抛出异常。</target>
        </trans-unit>
        <trans-unit id="3d9b7696c9777c3fdef5f5f1690ef14ee23382d9" translate="yes" xml:space="preserve">
          <source>If the</source>
          <target state="translated">如果</target>
        </trans-unit>
        <trans-unit id="9261f103249815b5548b32356b7dfbcdd640649a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;defaults&lt;/code&gt; annotation attribute is set to &lt;code&gt;false&lt;/code&gt;, and no other map-based constructor are added then named-argument processing will not be available.</source>
          <target state="translated">如果将 &lt;code&gt;defaults&lt;/code&gt; 批注属性设置为 &lt;code&gt;false&lt;/code&gt; ，并且未添加任何其他基于地图的构造函数，则命名参数处理将不可用。</target>
        </trans-unit>
        <trans-unit id="9dc24cecb215bbbe513abec5e10b149eaeb892bb" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;self&lt;/code&gt; map is one of TreeMap, Hashtable or Properties, the returned Map will preserve that type, otherwise a LinkedHashMap will be returned.</source>
          <target state="translated">如果 &lt;code&gt;self&lt;/code&gt; 映射是TreeMap，Hashtable或Properties之一，则返回的Map将保留该类型，否则将返回LinkedHashMap。</target>
        </trans-unit>
        <trans-unit id="635a189513bc69306a1cc6affd125e5131643403" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;self&lt;/code&gt; map is one of TreeMap, LinkedHashMap, Hashtable or Properties, the returned Map will preserve that type, otherwise a HashMap will be returned.</source>
          <target state="translated">如果 &lt;code&gt;self&lt;/code&gt; 映射是TreeMap，LinkedHashMap，Hashtable或Properties中的一种，则返回的Map将保留该类型，否则将返回HashMap。</target>
        </trans-unit>
        <trans-unit id="82617162a84e01e4040b6310e580d5bed577d186" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;soft&lt;/code&gt; flag for the annotation is not set but the field is static, then the &lt;a href=&quot;http://en.wikipedia.org/wiki/Initialization_on_demand_holder_idiom&quot;&gt;initialization on demand holder idiom&lt;/a&gt; is used as follows:</source>
          <target state="translated">如果未设置注释的 &lt;code&gt;soft&lt;/code&gt; 标志，但该字段是静态的，则&lt;a href=&quot;http://en.wikipedia.org/wiki/Initialization_on_demand_holder_idiom&quot;&gt;按需初始化持有人惯用语的用法&lt;/a&gt;如下：</target>
        </trans-unit>
        <trans-unit id="d027af9f64ad3592999ed82297eb666e12959a3f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;soft&lt;/code&gt; flag for the annotation is not set but the field is static, then the &lt;a href=&quot;https://en.wikipedia.org/wiki/Initialization_on_demand_holder_idiom&quot;&gt;initialization on demand holder idiom&lt;/a&gt; is used as follows:</source>
          <target state="translated">如果未设置注释的 &lt;code&gt;soft&lt;/code&gt; 标志，但该字段是静态的，则&lt;a href=&quot;https://en.wikipedia.org/wiki/Initialization_on_demand_holder_idiom&quot;&gt;按需初始化持有人惯用语的用法&lt;/a&gt;如下：</target>
        </trans-unit>
        <trans-unit id="385febdfa7ef07a1b28cace87e29028ac6d6ba97" translate="yes" xml:space="preserve">
          <source>If the Closure has two parameters it is used like a traditional Comparator. I.e. it should compare its two parameters for order, returning a negative integer, zero, or a positive integer when the first parameter is less than, equal to, or greater than the second respectively. Otherwise, the Closure is assumed to take a single parameter and return a Comparable (typically an Integer) which is then used for further comparison.</source>
          <target state="translated">如果Closure有两个参数,它就像传统的比较器一样使用。也就是说,它应该比较两个参数的顺序,当第一个参数分别小于、等于或大于第二个参数时,返回一个负整数、零或一个正整数。否则,Closure被假定为只取一个参数,并返回一个可比较参数(通常是一个整数),然后用于进一步比较。</target>
        </trans-unit>
        <trans-unit id="8a3df9e7547ec4b6d738373bb90d2531b788d4d9" translate="yes" xml:space="preserve">
          <source>If the String is already the same size or bigger than the target &lt;code&gt;numberOfChars&lt;/code&gt;, then the original String is returned. An example:</source>
          <target state="translated">如果String已经是相同大小或大于目标 &lt;code&gt;numberOfChars&lt;/code&gt; ，则返回原始String。一个例子：</target>
        </trans-unit>
        <trans-unit id="fec170b2d985ec59b1ec3aec64163e5690dce806" translate="yes" xml:space="preserve">
          <source>If the closure has two parameters it is used like a traditional Comparator. I.e. it should compare its two entry parameters for order, returning a negative integer, zero, or a positive integer when the first parameter is less than, equal to, or greater than the second respectively. Otherwise, the Closure is assumed to take a single entry parameter and return a Comparable (typically an Integer) which is then used for further comparison.</source>
          <target state="translated">如果闭包有两个参数,它就像传统的比较器一样使用。也就是说,它应该比较两个输入参数的顺序,当第一个参数分别小于、等于或大于第二个参数时,返回一个负整数、零或一个正整数。否则,Closure被假定为接受一个单一的入口参数,并返回一个可比较参数(通常是一个整数),然后用于进一步比较。</target>
        </trans-unit>
        <trans-unit id="ae862b3fcc741884eff9dce9a4c1d186e853a84f" translate="yes" xml:space="preserve">
          <source>If the closure has two parameters it is used like a traditional Comparator. I.e. it should compare its two parameters for order, returning a negative integer, zero, or a positive integer when the first parameter is less than, equal to, or greater than the second respectively. Otherwise, the Closure is assumed to take a single parameter and return a Comparable (typically an Integer) which is then used for further comparison.</source>
          <target state="translated">如果闭包有两个参数,它就像传统的比较器一样使用。也就是说,它应该比较两个参数的顺序,当第一个参数分别小于、等于或大于第二个参数时,返回一个负整数、零或正整数。否则,Closure被假定为只取一个参数,并返回一个可比较参数(通常是一个整数),然后用于进一步比较。</target>
        </trans-unit>
        <trans-unit id="d18963ec46721d8a0c427332570d7221425c0b7c" translate="yes" xml:space="preserve">
          <source>If the closure has two parameters it is used like a traditional Comparator. I.e. it should compare its two parameters for order, returning a negative integer, zero, or a positive integer when the first parameter is less than, equal to, or greater than the second respectively. Otherwise, the Closure is assumed to take a single parameter and return a Comparable (typically an Integer) which is then used for further comparison. An example:</source>
          <target state="translated">如果闭包有两个参数,它就像传统的比较器一样使用。也就是说,它应该比较两个参数的顺序,当第一个参数分别小于、等于或大于第二个参数时,返回一个负整数、零或正整数。否则,Closure被假定为只取一个参数并返回一个可比较的参数(通常是一个整数),然后用于进一步比较。一个例子。</target>
        </trans-unit>
        <trans-unit id="0932623fb5eb340752020104e642ff30e170d5dc" translate="yes" xml:space="preserve">
          <source>If the closure takes a single parameter, each element from the Collection will be passed to the closure. The closure should return a value used for comparison (either using &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html#compareTo(java.lang.Object)&quot;&gt;Comparable.compareTo&lt;/a&gt; or &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#equals(java.lang.Object)&quot;&gt;Object.equals&lt;/a&gt;). If the closure takes two parameters, two items from the collection will be passed as arguments, and the closure should return an int value (with 0 indicating the items are not unique).</source>
          <target state="translated">如果闭包采用单个参数，则Collection中的每个元素都将传递给闭包。闭包应该返回一个用于比较的值（使用&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html#compareTo(java.lang.Object)&quot;&gt;Comparable.compareTo&lt;/a&gt;或&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#equals(java.lang.Object)&quot;&gt;Object.equals&lt;/a&gt;）。如果闭包使用两个参数，则将传递集合中的两个项目作为参数，并且闭包应返回一个int值（0表示这些项目不是唯一的）。</target>
        </trans-unit>
        <trans-unit id="160eb3d3c15e5f3ed499c00e99d25dc873827b50" translate="yes" xml:space="preserve">
          <source>If the closure takes a single parameter, each element from the Iterable will be passed to the closure. The closure should return a value used for comparison (either using &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html#compareTo(java.lang.Object)&quot;&gt;Comparable.compareTo&lt;/a&gt; or &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#equals(java.lang.Object)&quot;&gt;Object.equals&lt;/a&gt;). If the closure takes two parameters, two items from the Iterable will be passed as arguments, and the closure should return an int value (with 0 indicating the items are not unique).</source>
          <target state="translated">如果闭包采用单个参数，则Iterable中的每个元素都将传递给闭包。闭包应该返回一个用于比较的值（使用&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html#compareTo(java.lang.Object)&quot;&gt;Comparable.compareTo&lt;/a&gt;或&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#equals(java.lang.Object)&quot;&gt;Object.equals&lt;/a&gt;）。如果闭包采用两个参数，则Iterable中的两个项目将作为参数传递，并且闭包应返回一个int值（0表示这些项目不是唯一的）。</target>
        </trans-unit>
        <trans-unit id="c1f2f98db7f3cd8cd1966ae04f614e6bc273ea7e" translate="yes" xml:space="preserve">
          <source>If the closure takes a single parameter, each element from the List will be passed to the closure. The closure should return a value used for comparison (either using &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html#compareTo(java.lang.Object)&quot;&gt;Comparable.compareTo&lt;/a&gt; or &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#equals(java.lang.Object)&quot;&gt;Object.equals&lt;/a&gt;). If the closure takes two parameters, two items from the collection will be passed as arguments, and the closure should return an int value (with 0 indicating the items are not unique).</source>
          <target state="translated">如果闭包采用单个参数，则列表中的每个元素都将传递给闭包。闭包应该返回一个用于比较的值（使用&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html#compareTo(java.lang.Object)&quot;&gt;Comparable.compareTo&lt;/a&gt;或&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#equals(java.lang.Object)&quot;&gt;Object.equals&lt;/a&gt;）。如果闭包使用两个参数，则将传递集合中的两个项目作为参数，并且闭包应返回一个int值（0表示这些项目不是唯一的）。</target>
        </trans-unit>
        <trans-unit id="c80fbf9d484f1727998638148a2bf1f1929aedd6" translate="yes" xml:space="preserve">
          <source>If the closure takes a single parameter, the argument passed will be each element, and the closure should return a value used for comparison (either using &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html#compareTo(java.lang.Object)&quot;&gt;Comparable.compareTo&lt;/a&gt; or &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#equals(java.lang.Object)&quot;&gt;Object.equals&lt;/a&gt;). If the closure takes two parameters, two items from the Iterator will be passed as arguments, and the closure should return an int value (with 0 indicating the items are not unique).</source>
          <target state="translated">如果闭包采用单个参数，则传递的参数将是每个元素，并且闭包应返回用于比较的值（使用&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html#compareTo(java.lang.Object)&quot;&gt;Comparable.compareTo&lt;/a&gt;或&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#equals(java.lang.Object)&quot;&gt;Object.equals&lt;/a&gt;）。如果闭包采用两个参数，则将来自Iterator的两个项目作为参数传递，并且闭包应返回一个int值（0表示这些项目不是唯一的）。</target>
        </trans-unit>
        <trans-unit id="1ed2ec1e03cb68f98b720593353f0b57872161bd" translate="yes" xml:space="preserve">
          <source>If the closure takes a single parameter, the argument passed will be each element, and the closure should return a value used for comparison (either using &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html#compareTo(java.lang.Object)&quot;&gt;Comparable.compareTo&lt;/a&gt; or &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#equals(java.lang.Object)&quot;&gt;Object.equals&lt;/a&gt;). If the closure takes two parameters, two items from the List will be passed as arguments, and the closure should return an int value (with 0 indicating the items are not unique).</source>
          <target state="translated">如果闭包采用单个参数，则传递的参数将是每个元素，并且闭包应返回用于比较的值（使用&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html#compareTo(java.lang.Object)&quot;&gt;Comparable.compareTo&lt;/a&gt;或&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#equals(java.lang.Object)&quot;&gt;Object.equals&lt;/a&gt;）。如果闭包采用两个参数，则列表中的两个项目将作为参数传递，并且闭包应返回一个int值（0表示这些项目不是唯一的）。</target>
        </trans-unit>
        <trans-unit id="f54b771a68545b41e8ca80f90b0b38cf12a27779" translate="yes" xml:space="preserve">
          <source>If the closure takes a single parameter, the argument passed will be each element, and the closure should return a value used for comparison (either using &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html#compareTo(java.lang.Object)&quot;&gt;Comparable.compareTo&lt;/a&gt; or &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#equals(java.lang.Object)&quot;&gt;Object.equals&lt;/a&gt;). If the closure takes two parameters, two items from the collection will be passed as arguments, and the closure should return an int value (with 0 indicating the items are not unique).</source>
          <target state="translated">如果闭包采用单个参数，则传递的参数将是每个元素，并且闭包应返回用于比较的值（使用&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html#compareTo(java.lang.Object)&quot;&gt;Comparable.compareTo&lt;/a&gt;或&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#equals(java.lang.Object)&quot;&gt;Object.equals&lt;/a&gt;）。如果闭包使用两个参数，则将传递集合中的两个项目作为参数，并且闭包应返回一个int值（0表示这些项目不是唯一的）。</target>
        </trans-unit>
        <trans-unit id="8d3d646e6aaa70a0f22b744eb08d721f2569fd2f" translate="yes" xml:space="preserve">
          <source>If the field is declared volatile then initialization will be synchronized using the &lt;a href=&quot;http://en.wikipedia.org/wiki/Double-checked_locking&quot;&gt;double-checked locking&lt;/a&gt; pattern as shown here:</source>
          <target state="translated">如果将该字段声明为volatile，则将使用&lt;a href=&quot;http://en.wikipedia.org/wiki/Double-checked_locking&quot;&gt;双重检查的锁定&lt;/a&gt;模式来同步初始化，如下所示：</target>
        </trans-unit>
        <trans-unit id="e793ba92d27cc0c47a76e7002bfd20581ffbd370" translate="yes" xml:space="preserve">
          <source>If the field is declared volatile then initialization will be synchronized using the &lt;a href=&quot;https://en.wikipedia.org/wiki/Double-checked_locking&quot;&gt;double-checked locking&lt;/a&gt; pattern as shown here:</source>
          <target state="translated">如果将该字段声明为volatile，则将使用&lt;a href=&quot;https://en.wikipedia.org/wiki/Double-checked_locking&quot;&gt;双重检查的锁定&lt;/a&gt;模式来同步初始化，如下所示：</target>
        </trans-unit>
        <trans-unit id="1a1205800ae2de1ec9038017b14a79d924446a55" translate="yes" xml:space="preserve">
          <source>If the filename will be placed inside a single/double quoted String we must escape backslash when on e.g.</source>
          <target state="translated">如果文件名将被放置在一个单引号/双引号的字符串中,我们必须用反斜杠转义,例如</target>
        </trans-unit>
        <trans-unit id="243f568e6bf6818ee3d25e256bc650bc948cab0b" translate="yes" xml:space="preserve">
          <source>If the filename will be placed inside a single/double quoted String we must escape backslash when on e.g. Windows.</source>
          <target state="translated">如果文件名被放置在一个单引号/双引号的字符串中,我们必须在Windows等系统中转义反斜杠。</target>
        </trans-unit>
        <trans-unit id="551b89fe0a437419189c6f8c839918d7eea11cde" translate="yes" xml:space="preserve">
          <source>If the first property (or field) has type &lt;code&gt;LinkedHashMap&lt;/code&gt; or if there is a single Object, AbstractMap, Map or HashMap property (or field), then no additional constructor will be added and Groovy's normal map-style naming conventions will not be available.</source>
          <target state="translated">如果第一个属性（或字段）的类型为 &lt;code&gt;LinkedHashMap&lt;/code&gt; ,或者只有一个Object，AbstractMap，Map或HashMap属性（或字段），则不会添加其他构造函数，并且Groovy的常规地图样式命名约定将不可用。</target>
        </trans-unit>
        <trans-unit id="6666ea272dc6a58d7be8367dca451786ca411ade" translate="yes" xml:space="preserve">
          <source>If the given object is not a QName or String equivalent or is null then this method returns</source>
          <target state="translated">如果给定的对象不是QName或String等价物,或者是null,那么本方法返回</target>
        </trans-unit>
        <trans-unit id="78a3adf1234ea781998047f66a3ced12d5a100f0" translate="yes" xml:space="preserve">
          <source>If the includePackage flag is &lt;code&gt;true&lt;/code&gt; (the default), then the output will be:</source>
          <target state="translated">如果includePackage标志为 &lt;code&gt;true&lt;/code&gt; （默认设置），则输出为：</target>
        </trans-unit>
        <trans-unit id="8a209b730ddb00a7bf1c46539ce71c3f830a135a" translate="yes" xml:space="preserve">
          <source>If the map instance does not have ordered keys, then this function could appear to drop random entries. Groovy by default uses LinkedHashMap, so this shouldn't be an issue in the main.</source>
          <target state="translated">如果地图实例没有有序键,那么这个函数可能会出现随机丢弃条目。Groovy默认使用LinkedHashMap,所以这应该不是主问题。</target>
        </trans-unit>
        <trans-unit id="2411a5928d0e4edf31e665b4568b866427899251" translate="yes" xml:space="preserve">
          <source>If the map instance does not have ordered keys, then this function could appear to take random entries. Groovy by default uses LinkedHashMap, so this shouldn't be an issue in the main.</source>
          <target state="translated">如果地图实例没有有序的键,那么这个函数可能会出现随机的条目。Groovy默认使用LinkedHashMap,所以这应该不是一个主问题。</target>
        </trans-unit>
        <trans-unit id="2a16459dd5caf99fc1cc625be428a47da3b0a22b" translate="yes" xml:space="preserve">
          <source>If the map instance does not have ordered keys, then this function could drop a random &lt;code&gt;num&lt;/code&gt; entries. Groovy by default uses LinkedHashMap, so this shouldn't be an issue in the main.</source>
          <target state="translated">如果地图实例没有排序键，则此函数可能会删除随机的 &lt;code&gt;num&lt;/code&gt; 条目。Groovy默认情况下使用LinkedHashMap，因此这在主要方面不应该成为问题。</target>
        </trans-unit>
        <trans-unit id="9adc0af7234a7f7dddf303a1f63b8a38c2f148ea" translate="yes" xml:space="preserve">
          <source>If the methodCallArgs are absent, it is a property reference. If there is no property, it is treated as a field reference, but never a method reference.</source>
          <target state="translated">如果 methodCallArgs 不存在,它是一个属性引用。如果没有属性,它被视为字段引用,但绝不是方法引用。</target>
        </trans-unit>
        <trans-unit id="b08a5b8915893a4d84d527e562180f850967d380" translate="yes" xml:space="preserve">
          <source>If the offset's total seconds are negative, a negative value will be returned.</source>
          <target state="translated">如果偏移量的总秒数为负值,将返回负值。</target>
        </trans-unit>
        <trans-unit id="48d60872cf9e840dd2c8ef946bbccf55f54207e9" translate="yes" xml:space="preserve">
          <source>If the optional contains a value, returns an optional containing the transformed value obtained using the &lt;code&gt;transform&lt;/code&gt; closure or otherwise an empty optional.</source>
          <target state="translated">如果可选变量包含一个值，则返回一个可选变量，该可选变量包含使用 &lt;code&gt;transform&lt;/code&gt; 闭包获得的转换后的值，否则返回一个空的可选变量。</target>
        </trans-unit>
        <trans-unit id="3ace9d4a8c1b6f5ffc5497f185f9d10c05faf2b5" translate="yes" xml:space="preserve">
          <source>If the parameter is no primitive type, the redirected ClassNode will be returned</source>
          <target state="translated">如果参数不是基元类型,将返回重定向的ClassNode</target>
        </trans-unit>
        <trans-unit id="34c92379090ff518dcd552d20613d5ed106e37fa" translate="yes" xml:space="preserve">
          <source>If the property does not exist then it will return childName unchanged.</source>
          <target state="translated">如果该属性不存在,那么它将不变地返回childName。</target>
        </trans-unit>
        <trans-unit id="6107b4d5266bf408264e8a734eb446c3449b2b14" translate="yes" xml:space="preserve">
          <source>If the specified key is not already associated with a value, attempts to compute its value using the given mapping function and enters it into this map unless &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">如果指定的键尚未与值相关联，则尝试使用给定的映射函数计算其值，除非 &lt;code&gt;null&lt;/code&gt; ,否则将其输入到此映射中。</target>
        </trans-unit>
        <trans-unit id="551c906c1bb44aa217c725bb3e6835b67419ea34" translate="yes" xml:space="preserve">
          <source>If the specified key is not already associated with a value, attempts to compute its value using the given mapping function and enters it into this map unless &lt;code&gt;null&lt;/code&gt;. The entire method invocation is performed atomically, so the function is applied at most once per key. Some attempted update operations on this map by other threads may be blocked while computation is in progress, so the computation should be short and simple, and must not attempt to update any other mappings of this map.</source>
          <target state="translated">如果指定的键尚未与值相关联，则尝试使用给定的映射函数计算其值，除非 &lt;code&gt;null&lt;/code&gt; ,否则将其输入到此映射中。整个方法调用是原子执行的，因此每个键最多可应用一次该功能。在进行计算时，可能会阻止其他线程在此映射上进行的某些尝试的更新操作，因此计算应简短而简单，并且不得尝试更新此映射的任何其他映射。</target>
        </trans-unit>
        <trans-unit id="743038d9cfc4ae8b0289cd027cb2db92c1f9fd53" translate="yes" xml:space="preserve">
          <source>If the supplied Closure takes a single parameter, the argument passed will be each element, and the closure should return a value used for comparison (either using &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html#compareTo(java.lang.Object)&quot;&gt;Comparable.compareTo&lt;/a&gt; or &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#equals(java.lang.Object)&quot;&gt;Object.equals&lt;/a&gt;). If the closure takes two parameters, two items from the Iterator will be passed as arguments, and the closure should return an int value (with 0 indicating the items are not unique).</source>
          <target state="translated">如果提供的Closure使用单个参数，则传递的参数将是每个元素，并且Closure应该返回一个用于比较的值（使用&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html#compareTo(java.lang.Object)&quot;&gt;Comparable.compareTo&lt;/a&gt;或&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#equals(java.lang.Object)&quot;&gt;Object.equals&lt;/a&gt;）。如果闭包采用两个参数，则将来自Iterator的两个项目作为参数传递，并且闭包应返回一个int值（0表示这些项目不是唯一的）。</target>
        </trans-unit>
        <trans-unit id="88dd583fef354911284306e4281f94d0de49aa53" translate="yes" xml:space="preserve">
          <source>If the transform is associated with a single annotation, returns a name suitable for displaying in error messages.</source>
          <target state="translated">如果变换与单个注解相关联,则返回一个适合在错误信息中显示的名称。</target>
        </trans-unit>
        <trans-unit id="c703c20b00fea5a8d7acfa056c400e06876f5279" translate="yes" xml:space="preserve">
          <source>If the unit is too large to iterate to the second Temporal exactly, such as iterating from two LocalDateTimes that are seconds apart using &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/temporal/ChronoUnit.html#DAYS&quot;&gt;ChronoUnit.DAYS&lt;/a&gt; as the unit, the iteration will cease as soon as the current value of the iteration is earlier than the second Temporal argument. The closure will not be called with any value earlier than the &lt;code&gt;to&lt;/code&gt; value.</source>
          <target state="translated">如果单位太大而无法精确地迭代到第二个Temporal，例如使用&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/temporal/ChronoUnit.html#DAYS&quot;&gt;ChronoUnit.DAYS&lt;/a&gt;作为单位从相隔数秒的两个LocalDateTimes进行迭代，则该迭代将在迭代的当前值早于第二个时立即停止。时间论证。不会使用 &lt;code&gt;to&lt;/code&gt; 值之前的任何值调用该闭包。</target>
        </trans-unit>
        <trans-unit id="b4174e6520e84cd5dc569c5b02e90212b12e6b44" translate="yes" xml:space="preserve">
          <source>If the unit is too large to iterate to the second Temporal exactly, such as iterating from two LocalDateTimes that are seconds apart using &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/temporal/ChronoUnit.html#DAYS&quot;&gt;ChronoUnit.DAYS&lt;/a&gt; as the unit, the iteration will cease as soon as the current value of the iteration is later than the second Temporal argument. The closure will not be called with any value later than the &lt;code&gt;to&lt;/code&gt; value.</source>
          <target state="translated">如果单位太大而无法精确地迭代到第二个Temporal，例如使用&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/temporal/ChronoUnit.html#DAYS&quot;&gt;ChronoUnit.DAYS&lt;/a&gt;作为单位从相隔数秒的两个LocalDateTimes进行迭代，则迭代将在迭代的当前值晚于第二个时立即停止。时间论证。不会使用 &lt;code&gt;to&lt;/code&gt; 值之后的任何值调用该闭包。</target>
        </trans-unit>
        <trans-unit id="f55b91ace44131b6a02cbb4d50c69c844c42f9f6" translate="yes" xml:space="preserve">
          <source>If there are capture groups, the first parameter will be the match followed by one parameter for each capture group:</source>
          <target state="translated">如果有捕获组,第一个参数将是匹配,然后是每个捕获组的一个参数。</target>
        </trans-unit>
        <trans-unit id="f7433ccb7f792490e503bc92811e7797292fa5bf" translate="yes" xml:space="preserve">
          <source>If there are no matches, the closure will not be called, and an empty List will be returned.</source>
          <target state="translated">如果没有匹配的对象,将不会被调用关闭,并返回一个空的List。</target>
        </trans-unit>
        <trans-unit id="313e74861b90bc8486f13c4249d5e33002d10138" translate="yes" xml:space="preserve">
          <source>If there is more than one included property (and/or field) and the first property (or field) has type Object, AbstractMap, Map or HashMap, then a special &lt;code&gt;LinkedHashMap&lt;/code&gt; constructor will be created in addition to the tuple constructor to support named parameters in the normal way. This won't be created if the class is already annotated with &lt;code&gt;@MapConstructor&lt;/code&gt; or if the &lt;code&gt;defaults&lt;/code&gt; annotation attribute is set to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果包含多个属性（和/或字段），并且第一个属性（或字段）的类型为Object，AbstractMap，Map或HashMap，则除了元组构造函数之外，还将创建特殊的 &lt;code&gt;LinkedHashMap&lt;/code&gt; 构造函数以支持命名参数以通常的方式。如果该类已经使用 &lt;code&gt;@MapConstructor&lt;/code&gt; 进行注释，或者 &lt;code&gt;defaults&lt;/code&gt; 注释属性设置为 &lt;code&gt;false&lt;/code&gt; ,则不会创建该属性。</target>
        </trans-unit>
        <trans-unit id="34557aeb28967e4173c76474dc3c1c26e8004a32" translate="yes" xml:space="preserve">
          <source>If this SQL object was created with a Connection then this method closes the connection.</source>
          <target state="translated">如果这个SQL对象是用Connection创建的,那么这个方法将关闭连接。</target>
        </trans-unit>
        <trans-unit id="a4e914ad3c22b6d8f38df01a52a0a4a8f400f9ee" translate="yes" xml:space="preserve">
          <source>If this SQL object was created with a Connection then this method closes the connection. If this SQL object was created from a DataSource then this method only frees any cached objects (statements in particular).</source>
          <target state="translated">如果这个SQL对象是通过Connection创建的,那么这个方法将关闭连接。如果这个SQL对象是从DataSource创建的,那么这个方法只释放任何缓存的对象(特别是语句)。</target>
        </trans-unit>
        <trans-unit id="80f1087cf128253592eb01d3329359ea84971471" translate="yes" xml:space="preserve">
          <source>If this SQL object was created with a Connection then this method commits the connection.</source>
          <target state="translated">如果这个SQL对象是用Connection创建的,那么这个方法就会提交这个连接。</target>
        </trans-unit>
        <trans-unit id="754d73a1be3c48b9a219df6177bc784abf10e825" translate="yes" xml:space="preserve">
          <source>If this SQL object was created with a Connection then this method commits the connection. If this SQL object was created from a DataSource then this method does nothing.</source>
          <target state="translated">如果这个SQL对象是通过Connection创建的,那么这个方法就会提交连接。如果这个SQL对象是通过DataSource创建的,那么这个方法什么都不做。</target>
        </trans-unit>
        <trans-unit id="49f5e16329c067f10c1d3522e8f9bf2c55b78c04" translate="yes" xml:space="preserve">
          <source>If this SQL object was created with a Connection then this method rolls back the connection.</source>
          <target state="translated">如果这个SQL对象是用Connection创建的,那么这个方法就会回滚连接。</target>
        </trans-unit>
        <trans-unit id="25557c1bbccedf4372beb3200a77ed591d02e948" translate="yes" xml:space="preserve">
          <source>If this SQL object was created with a Connection then this method rolls back the connection. If this SQL object was created from a DataSource then this method does nothing.</source>
          <target state="translated">如果这个SQL对象是通过Connection创建的,那么这个方法就会回滚连接。如果这个SQL对象是通过DataSource创建的,那么这个方法就不做任何事情。</target>
        </trans-unit>
        <trans-unit id="b98b14eb1aa561c54ac7fdbec4de0c697a5b9cb4" translate="yes" xml:space="preserve">
          <source>If this instance was created with a single Connection then the connection is returned.</source>
          <target state="translated">如果这个实例是用单个Connection创建的,那么就会返回连接。</target>
        </trans-unit>
        <trans-unit id="d80d163fb13021ac33ad8b849d2ec36ab0e6a956" translate="yes" xml:space="preserve">
          <source>If this instance was created with a single Connection then the connection is returned. Otherwise if this instance was created with a DataSource then this method returns null</source>
          <target state="translated">如果这个实例是用一个单一的Connection创建的,那么将返回连接。否则,如果这个实例是用一个DataSource创建的,那么这个方法将返回null。</target>
        </trans-unit>
        <trans-unit id="530823b483057fc27e8d70b4ea2614facbe9f9a0" translate="yes" xml:space="preserve">
          <source>If this method throws an exception, then the expression cannot be evaluated on its own.</source>
          <target state="translated">如果这个方法抛出一个异常,那么表达式就不能单独评估。</target>
        </trans-unit>
        <trans-unit id="662272f21b42eaf89c3e4ef2b09ce7ba2fa614de" translate="yes" xml:space="preserve">
          <source>If true forks the Groovy compiler.</source>
          <target state="translated">如果为真,则分叉Groovy编译器。</target>
        </trans-unit>
        <trans-unit id="918ff30ae4b9ebdaf99e850f651586cf4ad90cbb" translate="yes" xml:space="preserve">
          <source>If true forks the Groovy compiler. Default is false.</source>
          <target state="translated">如果为true,则分叉Groovy编译器。默认为false。</target>
        </trans-unit>
        <trans-unit id="c2d184e8bab4da6de50e7ba285f1a32d6c033a81" translate="yes" xml:space="preserve">
          <source>If true, add an implicit</source>
          <target state="translated">如果为真,则添加一个隐含的</target>
        </trans-unit>
        <trans-unit id="6c3567a288f7acafdac2a5a4706c9ca197110580" translate="yes" xml:space="preserve">
          <source>If true, change the type of the map constructor argument from Map to LinkedHashMap only for the case where the class has a single property (or field) with a Map-like type.</source>
          <target state="translated">如果为真,仅在类有一个类似Map类型的单一属性(或字段)的情况下,将map构造函数参数的类型从Map改为LinkedHashMap。</target>
        </trans-unit>
        <trans-unit id="e17887876f5bf178aeca16840c1bc8351abefcfa" translate="yes" xml:space="preserve">
          <source>If true, change the type of the map constructor argument from Map to LinkedHashMap only for the case where the class has a single property (or field) with a Map-like type. This allows both a map and a tuple constructor to be used side-by-side so long as care is taken about the types used when calling.</source>
          <target state="translated">如果为真,仅在类有一个类似Map类型的单一属性(或字段)的情况下,将map构造函数参数的类型从Map改为LinkedHashMap。这使得map和元组构造函数可以同时使用,只要在调用时注意使用的类型即可。</target>
        </trans-unit>
        <trans-unit id="72d4dff7f3e6baf20cb9e25613e460d69a5619c7" translate="yes" xml:space="preserve">
          <source>If true, enable preview Java features (JEP 12) (jdk12+ only).</source>
          <target state="translated">如果为真,则启用预览Java功能(JEP 12)(仅限jdk12+)。</target>
        </trans-unit>
        <trans-unit id="dc4e6667db22120bb70083ebedf13fa88275e875" translate="yes" xml:space="preserve">
          <source>If true, generates metadata for reflection on method parameter names (jdk8+ only).</source>
          <target state="translated">如果为真,则生成元数据用于反思方法参数名(仅jdk8+)。</target>
        </trans-unit>
        <trans-unit id="bceab3e330a8ad18725513359ff5ee5b6aaf34d1" translate="yes" xml:space="preserve">
          <source>If true, generates metadata for reflection on method parameter names (jdk8+ only). Defaults to false.</source>
          <target state="translated">如果为true,生成元数据以反映方法参数名(仅jdk8+)。默认值为false。</target>
        </trans-unit>
        <trans-unit id="3e78e9f11c63cc0854ae4d5aeed706a2dae1119e" translate="yes" xml:space="preserve">
          <source>If true, includes Ant's own classpath in the classpath.</source>
          <target state="translated">如果为真,将蚂蚁自己的classpath包含在classpath中。</target>
        </trans-unit>
        <trans-unit id="3f3161fc492230ca00ea7c2dd55dfe5056395e20" translate="yes" xml:space="preserve">
          <source>If true, includes Ant's own classpath in the classpath. Default is true. If setting to false and using groovyc in conjunction with AntBuilder you might need to explicitly add the Groovy jar(s) to the groovyc classpath using a nested classpath task.</source>
          <target state="translated">如果为真,在classpath中包含Ant自己的classpath。默认为true。如果设置为false,并且与AntBuilder一起使用groovyc,你可能需要使用嵌套的classpath任务将Groovy jar明确地添加到groovyc classpath中。</target>
        </trans-unit>
        <trans-unit id="13f9970075f664ff6b4cd009c403c7d806a8ce42" translate="yes" xml:space="preserve">
          <source>If true, includes the Java runtime libraries in the classpath.</source>
          <target state="translated">如果为真,则在classpath中包含Java运行时库。</target>
        </trans-unit>
        <trans-unit id="b81196dc2edbf2d4cefa21fcbc512a80a5c045d4" translate="yes" xml:space="preserve">
          <source>If true, includes the Java runtime libraries in the classpath. Default is false.</source>
          <target state="translated">如果为true,在classpath中包含Java运行时库。默认为false。</target>
        </trans-unit>
        <trans-unit id="0ba44a73e6e4775c0aa822cc3dc52bd7a344700b" translate="yes" xml:space="preserve">
          <source>If true, list the source files being handed off to the compiler.</source>
          <target state="translated">如果为真,列出交给编译器的源文件。</target>
        </trans-unit>
        <trans-unit id="a97c39b3265bed869865762e1a16c293d1d0a633" translate="yes" xml:space="preserve">
          <source>If true, list the source files being handed off to the compiler. Default is false.</source>
          <target state="translated">如果为true,列出交给编译器的源文件。默认为false。</target>
        </trans-unit>
        <trans-unit id="ba92c67d424716707ce7d8b849384cf2d6835cdb" translate="yes" xml:space="preserve">
          <source>If true, will use &lt;code&gt;as&lt;/code&gt; to convert map parameter to required class</source>
          <target state="translated">如果为true，将用 &lt;code&gt;as&lt;/code&gt; 转换地图参数所需的类</target>
        </trans-unit>
        <trans-unit id="f7a6cc857a9ef98bc6cf563f9533273e18b7f98e" translate="yes" xml:space="preserve">
          <source>If two or more closures are registered for the exact same type the last closure based on the order they were specified will be used. When serializing an object its type is compared to the list of registered types in the order the were given and the closure for the first suitable type will be called. Therefore, it is important to register more specific types first.</source>
          <target state="translated">如果有两个或更多的闭包被注册为完全相同的类型,将使用基于它们被指定的顺序的最后一个闭包。当序列化一个对象时,它的类型会按照给定的顺序与已注册的类型列表进行比较,第一个合适类型的闭包将被调用。因此,首先注册更多的特定类型是很重要的。</target>
        </trans-unit>
        <trans-unit id="98ba7a0356d56339bb54adadd182a0c5ffd2670f" translate="yes" xml:space="preserve">
          <source>If two statements are separated by newline (not SEMI), the second had better not look like the latter half of an expression.</source>
          <target state="translated">如果两个语句之间用换行(不是SEMI)隔开,第二个语句最好不要像表达式的后半部分。</target>
        </trans-unit>
        <trans-unit id="f6f0b0d7e0b7072f6ed34101c6d05aaaee512503" translate="yes" xml:space="preserve">
          <source>If two statements are separated by newline (not SEMI), the second had better not look like the latter half of an expression. If it does, issue a warning.</source>
          <target state="translated">如果两个语句之间用换行(不是SEMI)隔开,第二个语句最好不要看起来像表达式的后半部分。如果看起来像,就发出警告。</target>
        </trans-unit>
        <trans-unit id="18c952d88ede564c8979d3148b210c652d1f9036" translate="yes" xml:space="preserve">
          <source>If we are using a DataSource and we haven't enabled statement caching, then strictly speaking the final &lt;code&gt;close()&lt;/code&gt; method isn't required - as all connection handling is performed transparently on our behalf; however, it doesn't hurt to have it there as it will return silently in that case.</source>
          <target state="translated">如果我们使用的是数据源，并且尚未启用语句缓存，那么严格来说，不需要最终的 &lt;code&gt;close()&lt;/code&gt; 方法-因为所有连接处理都是以我们的名义透明执行的；但是，将其保留在那里并不会造成伤害，因为在这种情况下它将以静默方式返回。</target>
        </trans-unit>
        <trans-unit id="41559bac1ce5d79fb92f7b7644937c027d085018" translate="yes" xml:space="preserve">
          <source>If we didn't want to assume that callers of our &lt;code&gt;EmptyStringIterator&lt;/code&gt; correctly followed the &lt;code&gt;Iterator&lt;/code&gt; contract, then we might want to guard against inappropriate calls to &lt;code&gt;next&lt;/code&gt;. Rather than just returning &lt;code&gt;null&lt;/code&gt;, we might want to throw an exception. This is easily done using the &lt;code&gt;exception&lt;/code&gt; annotation attribute as shown below:</source>
          <target state="translated">如果我们不想假设 &lt;code&gt;EmptyStringIterator&lt;/code&gt; 的调用者正确遵循了 &lt;code&gt;Iterator&lt;/code&gt; 合同，那么我们可能想防止对 &lt;code&gt;next&lt;/code&gt; 的不适当调用。我们可能要抛出一个异常，而不是仅仅返回 &lt;code&gt;null&lt;/code&gt; 。使用 &lt;code&gt;exception&lt;/code&gt; 注释属性可以很容易地做到这一点，如下所示：</target>
        </trans-unit>
        <trans-unit id="90c5b1a9c3f8af72c752d5f6b93a1576464dee8c" translate="yes" xml:space="preserve">
          <source>If we have capture groups in our expression, and our closure has one parameter, the closure will be passed an array with the first element corresponding to the whole match, followed by an element for each of the capture groups:</source>
          <target state="translated">如果我们的表达式中有捕获组,而我们的闭包有一个参数,那么闭包将被传递一个数组,第一个元素对应整个匹配,后面是每个捕获组的元素。</target>
        </trans-unit>
        <trans-unit id="8a2fdfe997821cf5f70e068da54d119cd3697be4" translate="yes" xml:space="preserve">
          <source>If we have capture groups in our expression, our closure has one parameter for the match, followed by one for each of the capture groups:</source>
          <target state="translated">如果我们的表达式中有捕获组,我们的闭包就有一个匹配的参数,然后是每个捕获组的参数。</target>
        </trans-unit>
        <trans-unit id="c89b749c39731f93bcdd95c740a8962c1d69adb4" translate="yes" xml:space="preserve">
          <source>If we have capture groups in our expression, the groups are ignored and we get back the full match:</source>
          <target state="translated">如果我们的表达式中有捕获组,组就会被忽略,我们得到的是完整的匹配。</target>
        </trans-unit>
        <trans-unit id="afb6429f36b2279a75a4aa1e047d8ece3063b406" translate="yes" xml:space="preserve">
          <source>If we have capture groups in our expression, we still get back the full match</source>
          <target state="translated">如果我们的表达式中有捕获组,我们仍然会得到完整的匹配信息</target>
        </trans-unit>
        <trans-unit id="5af16e5cb7a1ee17375d9f00e0ebd120bb82be7b" translate="yes" xml:space="preserve">
          <source>If you ask Duration to convert itself to milliseconds then it will work on the basis of 24 hours in a day. If you add or subtract it from a date it will take daylight saving into account.</source>
          <target state="translated">如果你要求持续时间转换为毫秒,那么它将以一天24小时为基础进行工作。如果你从日期中添加或减去它,它将考虑到夏令时。</target>
        </trans-unit>
        <trans-unit id="6a6a0913fc66ae450d7e6b2ed6bc058dad4ff313" translate="yes" xml:space="preserve">
          <source>If you create Groovy constructors with optional arguments this leads to multiple constructors created in the byte code. The expansion to multiple constructors occurs in a later phase to this AST transformation. This means that you can't override (i.e. not inherit) the constructors with signatures that Groovy adds later. If you get it wrong you will get a compile-time error about the duplication.</source>
          <target state="translated">如果你用可选的参数创建Groovy构造函数,就会导致在字节代码中创建多个构造函数。对多个构造函数的扩展发生在这个AST转换的后期阶段。这意味着你不能覆盖(即不能继承)Groovy后来添加的带有签名的构造函数。如果你弄错了,你会得到一个关于重复的编译时错误。</target>
        </trans-unit>
        <trans-unit id="4213eaa1d31200e4a312d01c8724ee287522ee2e" translate="yes" xml:space="preserve">
          <source>If you don't initialise some of the properties, your code won't compile, e.g. if the method body above was changed to this:</source>
          <target state="translated">如果你不初始化一些属性,你的代码就不会被编译,比如上面的方法体被改成了这样。</target>
        </trans-unit>
        <trans-unit id="431a708cccb1f7814cc82700f344d1e30a36690c" translate="yes" xml:space="preserve">
          <source>If you don't need all of the functionality of &lt;code&gt;@Canonical&lt;/code&gt;, you can simply directly use one or more of the individual annotations which &lt;code&gt;@Canonical&lt;/code&gt; aggregates. In addition, you can use &lt;code&gt;@Canonical&lt;/code&gt; in combination with explicit use one or more of the individual annotations in cases where you need to further customize the annotation attributes. Any applicable annotation attributes from &lt;code&gt;@Canonical&lt;/code&gt; missing from the explicit annotation will be merged but any existing annotation attributes within the explicit annotation take precedence. So, for example in this case here:</source>
          <target state="translated">如果不需要 &lt;code&gt;@Canonical&lt;/code&gt; 的所有功能，则可以直接使用 &lt;code&gt;@Canonical&lt;/code&gt; 聚合的一个或多个单个注释。此外，在需要进一步自定义注释属性的情况下，可以将 &lt;code&gt;@Canonical&lt;/code&gt; 与显式使用一个或多个单个注释结合使用。 &lt;code&gt;@Canonical&lt;/code&gt; 显式注释中缺少的所有适用注释属性都将被合并，但显式注释中的任何现有注释属性都将优先。因此，例如在这种情况下：</target>
        </trans-unit>
        <trans-unit id="e47dc22a75fb142df4d2e60d0e6474640fddf067" translate="yes" xml:space="preserve">
          <source>If you experience class-loading-troubles with Tomcat 4 (or higher) or any other servlet container using custom class loader setups, you can fallback to use (slower) reflection in Groovy's MetaClass implementation. Please contact the dev team with your problem! Thanks. The servlet init parameter name is:</source>
          <target state="translated">如果你在Tomcat 4(或更高版本)或任何其他使用自定义类加载器设置的servlet容器中遇到类加载问题,你可以回退到使用Groovy的MetaClass实现中的(较慢的)反射。请联系开发团队解决你的问题! 谢谢。servlet init参数名称为</target>
        </trans-unit>
        <trans-unit id="ec7c04f3855370a00c76ca51211656f5250db797" translate="yes" xml:space="preserve">
          <source>If you find yourself creating queries based on any kind of input from the user or a 3rd party application you might wish to avoid the pure string method variants in this class. While this is safe: &lt;code&gt;sql.firstRow('select * from PersonTable')&lt;/code&gt; This example is potentially at risk of SQL injection: &lt;code&gt;sql.firstRow('select * from PersonTable where SurnameColumn = ' + userInput)&lt;/code&gt; This in turn will be fine if '&lt;code&gt;userInput&lt;/code&gt;' is something like 'Smith' but maybe not so fine if '&lt;code&gt;userInput&lt;/code&gt;' is something like 'Smith; DROP table PersonTable'. Instead, use one of the variants with parameters and placeholders: &lt;code&gt;sql.firstRow(&quot;select * from PersonTable where SurnameColumn = ?&quot;, [userInput])&lt;/code&gt; or the GString variants which will be converted to the placeholder variants under the covers: &lt;code&gt;sql.firstRow(&quot;select * from PersonTable where SurnameColumn = $userInput&quot;)&lt;/code&gt; or the named parameter variants discussed next.</source>
          <target state="translated">如果您发现自己根据用户或第三方应用程序的任何输入来创建查询，则可能希望避免此类中的纯字符串方法变体。这样做很安全： &lt;code&gt;sql.firstRow('select * from PersonTable')&lt;/code&gt; 此示例可能会受到SQL注入的风险： &lt;code&gt;sql.firstRow('select * from PersonTable where SurnameColumn = ' + userInput)&lt;/code&gt; 如果' &lt;code&gt;userInput&lt;/code&gt; '是类似于'Smith'的东西，但是如果' &lt;code&gt;userInput&lt;/code&gt; '是'Smith'的话可能不是很好。 DROP表PersonTable&amp;rdquo;。而是使用带有参数和占位符的变体之一： &lt;code&gt;sql.firstRow(&quot;select * from PersonTable where SurnameColumn = ?&quot;, [userInput])&lt;/code&gt; 或将在 &lt;code&gt;sql.firstRow(&quot;select * from PersonTable where SurnameColumn = $userInput&quot;)&lt;/code&gt; 转换为占位符变体的GString变体：sql.firstRow（&amp;ldquo; select * from PersonTable，其中SurnameColumn = $ userInput&amp;rdquo;）或接下来讨论的命名参数变体。</target>
        </trans-unit>
        <trans-unit id="b01d03c69a42d04f3addad05e42162f7aab566b7" translate="yes" xml:space="preserve">
          <source>If you have this example:</source>
          <target state="translated">如果你有这个例子。</target>
        </trans-unit>
        <trans-unit id="6c0ea2c55af269dd868616b975c117bca2599f18" translate="yes" xml:space="preserve">
          <source>If you need to work with capture groups, then use the closure version of this method or use Groovy's matcher operators or use &lt;code&gt;eachMatch&lt;/code&gt;.</source>
          <target state="translated">如果需要使用捕获组，请使用此方法的闭包版本或使用Groovy的matcher运算符或使用 &lt;code&gt;eachMatch&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="93b38ca6db99b463b3090b6a2cc47a70e094987e" translate="yes" xml:space="preserve">
          <source>If you use named arguments and a closure as last argument, the key/value pairs of the map (as named arguments) and the key/value pairs represented in the closure will be merged together &amp;mdash; the closure properties overriding the map key/values in case the same key is used.</source>
          <target state="translated">如果您使用命名参数和闭包作为最后一个参数，则映射的键/值对（作为命名参数）和闭包中表示的键/值对将合并在一起-闭包中的属性覆盖了地图中的键/值如果使用相同的密钥。</target>
        </trans-unit>
        <trans-unit id="26b278538945be0eb3581b3b0ef10654c411f95d" translate="yes" xml:space="preserve">
          <source>If you use this style on a child class, the parent class must also have a copy constructor (created using this annotation or by hand). This approach can be slightly slower than the traditional cloning approach but the &lt;code&gt;Cloneable&lt;/code&gt; fields of your class can be final. When using the copy constructor style, you can provide your own custom constructor by hand if you wish. If you do so, it is up to you to correctly copy, clone or deep clone the properties of your class.</source>
          <target state="translated">如果在子类上使用此样式，则父类还必须具有一个复制构造函数（使用此批注或手动创建）。这种方法可能比传统的克隆方法要慢一些，但是您的类的 &lt;code&gt;Cloneable&lt;/code&gt; 字段可以是最终的。使用复制构造函数样式时，可以根据需要手动提供自己的自定义构造函数。如果这样做，则由您自己来正确地复制，克隆或深克隆类的属性。</target>
        </trans-unit>
        <trans-unit id="60952ca33ec3b238f9c2aa322a94359a2e5200a0" translate="yes" xml:space="preserve">
          <source>If you want similar functionality to what this annotation provides but also require immutability, see the &lt;code&gt;@&lt;/code&gt;&lt;a href=&quot;immutable&quot;&gt;Immutable&lt;/a&gt; annotation.</source>
          <target state="translated">如果您想要与此注释提供的功能相似但又需要不可变性，请参见 &lt;code&gt;@&lt;/code&gt; &lt;a href=&quot;immutable&quot;&gt;不可变&lt;/a&gt;注释。</target>
        </trans-unit>
        <trans-unit id="a8437cb6e58c0942451e3d747d9e5f80fe50a1d4" translate="yes" xml:space="preserve">
          <source>If you want to omit fields or properties referring to</source>
          <target state="translated">如果您想省略指向</target>
        </trans-unit>
        <trans-unit id="a84f817570293665d02520c9e81e898fc5c6dda0" translate="yes" xml:space="preserve">
          <source>If you want, you can create these locks yourself. The &lt;code&gt;$lock&lt;/code&gt; and &lt;code&gt;$LOCK&lt;/code&gt; fields will not be generated if you create them yourself. You can also choose to lock on another field, by specifying its name as parameter to the &lt;code&gt;@Synchronized&lt;/code&gt; annotation. In this usage variant, the lock field will not be created automatically, and you must explicitly create it yourself.</source>
          <target state="translated">如果需要，可以自己创建这些锁。在 &lt;code&gt;$lock&lt;/code&gt; 和 &lt;code&gt;$LOCK&lt;/code&gt; 如果你自己创建这些字段将不会产生。您还可以通过将其名称指定为 &lt;code&gt;@Synchronized&lt;/code&gt; 批注的参数来选择锁定另一个字段。在此用法变型中，不会自动创建锁定字段，而您必须自己明确创建它。</target>
        </trans-unit>
        <trans-unit id="7701fc78ed9aff5d4c09977427ccf64d8c9fb50e" translate="yes" xml:space="preserve">
          <source>If you wish to automatically apply the annotation to all classes of a project, consider using &lt;code&gt;groovyc --configscript&lt;/code&gt;. Google &quot;Customising The Groovy Compiler&quot;, or see &lt;a href=&quot;../../org/codehaus/groovy/control/compilerconfiguration&quot;&gt;CompilerConfiguration&lt;/a&gt; for further details. This will ensure that all arguments will automatically be final, completely eliminating the need to clutter the code with final keywords in any parameter list.</source>
          <target state="translated">如果希望将注释自动应用于项目的所有类，请考虑使用 &lt;code&gt;groovyc --configscript&lt;/code&gt; 。Google&amp;ldquo;自定义Groovy编译器&amp;rdquo;，或查看&lt;a href=&quot;../../org/codehaus/groovy/control/compilerconfiguration&quot;&gt;CompilerConfiguration&lt;/a&gt;了解更多详细信息。这将确保所有参数都将自动为最终参数，从而完全消除了在任何参数列表中使用最终关键字将代码弄乱的需求。</target>
        </trans-unit>
        <trans-unit id="c0c9b0de7502e4c349b1699e62eb7a692029d7e8" translate="yes" xml:space="preserve">
          <source>If your classes require deep cloning, it is up to you to provide the appropriate deep cloning logic in the respective &lt;code&gt;clone()&lt;/code&gt; method for your class.</source>
          <target state="translated">如果您的类需要深度克隆，则由您自己决定在类的相应 &lt;code&gt;clone()&lt;/code&gt; 方法中提供适当的深度克隆逻辑。</target>
        </trans-unit>
        <trans-unit id="c71e13f2d44cbcf22f7a1abb8b6d4ceeb5d6fa6f" translate="yes" xml:space="preserve">
          <source>If your database returns scalar functions as ResultSets, you can also use firstRow to gain access to stored procedure results, e.g. using hsqldb 1.9 RC4:</source>
          <target state="translated">如果你的数据库以ResultSets的形式返回标量函数,你也可以使用firstRow来获取存储过程的结果,例如使用sqldb 1.9 RC4。</target>
        </trans-unit>
        <trans-unit id="dd91bcefa6284f552972a0be97fee45225f084db" translate="yes" xml:space="preserve">
          <source>IllegalAccessException</source>
          <target state="translated">IllegalAccessException</target>
        </trans-unit>
        <trans-unit id="df060f033243ef3e529950ac651d65d5bb658e94" translate="yes" xml:space="preserve">
          <source>IllegalAccessException if the instance can't be created due to a security violation</source>
          <target state="translated">如果由于安全违规而无法创建实例,则出现IllegalAccessException。</target>
        </trans-unit>
        <trans-unit id="9470a464366a48c841abcce34b92408b4cdb642a" translate="yes" xml:space="preserve">
          <source>IllegalArgumentException if &lt;code&gt;from&lt;/code&gt; is greater than &lt;code&gt;to&lt;/code&gt;.</source>
          <target state="translated">IllegalArgumentException如果 &lt;code&gt;from&lt;/code&gt; 从大于到 &lt;code&gt;to&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c8f3c5dc485395e82d262b0feaaf2f34ec4bfac3" translate="yes" xml:space="preserve">
          <source>IllegalArgumentException if nameValue is null</source>
          <target state="translated">如果nameValue为null,则出现IllegalArgumentException。</target>
        </trans-unit>
        <trans-unit id="6ff24b3b5e8b2c5b7b81d950d45ba2d18e705265" translate="yes" xml:space="preserve">
          <source>IllegalArgumentException if object is not an array</source>
          <target state="translated">如果对象不是数组,则出现IllegalArgumentException。</target>
        </trans-unit>
        <trans-unit id="9294d057aa692cca37ecbab7d2085fac81e44d3b" translate="yes" xml:space="preserve">
          <source>IllegalArgumentException if source is null or empty</source>
          <target state="translated">如果源为空或空,则出现IllegalArgumentException。</target>
        </trans-unit>
        <trans-unit id="86ea2f8a2286b63107713eaaede22f19946aaa09" translate="yes" xml:space="preserve">
          <source>IllegalArgumentException if the Writer is &lt;code&gt;null&lt;/code&gt;</source>
          <target state="translated">如果Writer为 &lt;code&gt;null&lt;/code&gt; ,则抛出IllegalArgumentException</target>
        </trans-unit>
        <trans-unit id="cdd5f1147ceb772fb77499be9d319020d957b3f4" translate="yes" xml:space="preserve">
          <source>IllegalArgumentException if the capacity is negative</source>
          <target state="translated">如果容量为负值,则出现IllegalArgumentException。</target>
        </trans-unit>
        <trans-unit id="7b8289dc3e59f86aad73cd7ff7bcb625bc959bbc" translate="yes" xml:space="preserve">
          <source>IllegalArgumentException if the concurrencyLevel is less than or equal to zero</source>
          <target state="translated">IllegalArgumentException if the concurrencyLevel is less than or equal to zero.</target>
        </trans-unit>
        <trans-unit id="c6e4654217af54bd70af816ed88a002fca576abd" translate="yes" xml:space="preserve">
          <source>IllegalArgumentException if the given closure does not accept a parameter of the given type</source>
          <target state="translated">如果给定的闭包不接受给定类型的参数,则出现IllegalArgumentException。</target>
        </trans-unit>
        <trans-unit id="67661783811bbe6d4df32243b7cc35b091bbd8bf" translate="yes" xml:space="preserve">
          <source>IllegalArgumentException if the given delegate is null</source>
          <target state="translated">如果给定的委托人为null,则出现IllegalArgumentException。</target>
        </trans-unit>
        <trans-unit id="60badf536647c3f3f67ce90015aa8a96b9ee7823" translate="yes" xml:space="preserve">
          <source>IllegalArgumentException if the given pattern is invalid</source>
          <target state="translated">如果给定的模式无效,则出现IllegalArgumentException。</target>
        </trans-unit>
        <trans-unit id="3ab53b540cc008215c9d994c3a8b2ca99220b174" translate="yes" xml:space="preserve">
          <source>IllegalArgumentException if the initial maximum number of elements is less than zero, or if the load factor is non-positive.</source>
          <target state="translated">IllegalArgumentException如果初始最大元素数小于零,或者负载因子是非正值。</target>
        </trans-unit>
        <trans-unit id="0013d03312c48b52ddfa1b44ca089b3e1e963bc9" translate="yes" xml:space="preserve">
          <source>IllegalArgumentException if the initial maximum number of elements is less than zero.</source>
          <target state="translated">如果初始最大元素数小于0,则出现IllegalArgumentException。</target>
        </trans-unit>
        <trans-unit id="071385e94c06c7df8fef81cd5cfe157a215f180c" translate="yes" xml:space="preserve">
          <source>IllegalArgumentException if the initialCapacity is negative</source>
          <target state="translated">如果初始容量为负值,则出现IllegalArgumentException。</target>
        </trans-unit>
        <trans-unit id="d651f8f3e9190248932c4cca9396a54f2e2b69a5" translate="yes" xml:space="preserve">
          <source>IllegalArgumentException if the limit is negative</source>
          <target state="translated">如果限制为负值,则出现IllegalArgumentException。</target>
        </trans-unit>
        <trans-unit id="929c1adbfb817ce84250f7eec8a9b1e03d66c782" translate="yes" xml:space="preserve">
          <source>IllegalArgumentException if the maximumWeightedCapacity is negative</source>
          <target state="translated">如果maximumWeightedCapacity为负值,则出现IllegalArgumentException。</target>
        </trans-unit>
        <trans-unit id="ecf36c08fcecd4ff420ca507c7c9148183f9db17" translate="yes" xml:space="preserve">
          <source>IllegalArgumentException if the number of repetitions is &amp;lt; 0</source>
          <target state="translated">如果重复次数小于0，则抛出IllegalArgumentException</target>
        </trans-unit>
        <trans-unit id="08175de67da4cd91e33b20427c00dcc5ff506bd5" translate="yes" xml:space="preserve">
          <source>IllegalArgumentException if the options are null</source>
          <target state="translated">如果选项为空,则出现IllegalArgumentException。</target>
        </trans-unit>
        <trans-unit id="c0ba29c618866ec7128e13a68cbf0e2c342f9d00" translate="yes" xml:space="preserve">
          <source>IllegalArgumentException if the parameters are not valid</source>
          <target state="translated">如果参数无效,则出现IllegalArgumentException。</target>
        </trans-unit>
        <trans-unit id="990c30e2e54bdf0c824bfc1347c8614edfe9bce6" translate="yes" xml:space="preserve">
          <source>IllegalArgumentException if the provided File object does not represent a directory</source>
          <target state="translated">如果提供的文件对象不代表目录,则出现IllegalArgumentException。</target>
        </trans-unit>
        <trans-unit id="70463272c77eae3c0c6912b8e0c96b0c5e4de45d" translate="yes" xml:space="preserve">
          <source>IllegalArgumentException if the provided File object does not represent a directory or illegal filter combinations are supplied</source>
          <target state="translated">如果提供的文件对象不代表目录或提供了非法的过滤器组合,则出现IllegalArgumentException。</target>
        </trans-unit>
        <trans-unit id="5f94a88312115100be59b27f9153db721ffae9a9" translate="yes" xml:space="preserve">
          <source>IllegalArgumentException if the provided Path object does not represent a directory</source>
          <target state="translated">如果提供的Path对象不代表目录,则出现IllegalArgumentException。</target>
        </trans-unit>
        <trans-unit id="7f64a10a518582832c0bfdf8c8e0c0b0c65bd37d" translate="yes" xml:space="preserve">
          <source>IllegalArgumentException if the provided Path object does not represent a directory or illegal filter combinations are supplied</source>
          <target state="translated">如果提供的Path对象不代表目录或提供了非法的过滤器组合,则会出现IllegalArgumentException。</target>
        </trans-unit>
        <trans-unit id="7f67a8bc93676719434f61569eff2968b821ecbe" translate="yes" xml:space="preserve">
          <source>IllegalArgumentException if the range would contain more than &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#MAX_VALUE&quot;&gt;Integer.MAX_VALUE&lt;/a&gt; values.</source>
          <target state="translated">IllegalArgumentException-如果范围将包含多个&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#MAX_VALUE&quot;&gt;Integer.MAX_VALUE&lt;/a&gt;值。</target>
        </trans-unit>
        <trans-unit id="d46104b04c559e00a3e5ba8d9ebb30c77fc291c7" translate="yes" xml:space="preserve">
          <source>IllegalArgumentException if the step is zero.</source>
          <target state="translated">如果步长为零,则出现IllegalArgumentException。</target>
        </trans-unit>
        <trans-unit id="26425ec5177f693a81710a97723421a2ffe11e2d" translate="yes" xml:space="preserve">
          <source>IllegalStateException if the computation detectably attempts a recursive update to this map that would otherwise never complete</source>
          <target state="translated">如果检测到计算试图对这个地图进行递归更新,否则永远不会完成,则出现IllegalStateException。</target>
        </trans-unit>
        <trans-unit id="9258bb692eaf68ff11b8313150e35bb75a82b34f" translate="yes" xml:space="preserve">
          <source>IllegalStateException if the maximum weighted capacity was not set</source>
          <target state="translated">如果没有设置最大加权容量,则出现IllegalStateException。</target>
        </trans-unit>
        <trans-unit id="80af9be8bbbc0f1890cc19171639de9e63869563" translate="yes" xml:space="preserve">
          <source>IllegalStateException this method may not be invoked at runtime. It works via a compile-time transformation of the closure source code into a String, which is sent to the &lt;a href=&quot;astbuilder#buildFromString(org.codehaus.groovy.control.CompilePhase,%20boolean,%20java.lang.String)&quot;&gt;AstBuilder.buildFromString&lt;/a&gt; method. The buildFromCode() method must be invoked against a strongly typed AstBuilder.</source>
          <target state="translated">IllegalStateException此方法不能在运行时调用。它通过将闭包源代码编译为String的编译时工作，将其发送到&lt;a href=&quot;astbuilder#buildFromString(org.codehaus.groovy.control.CompilePhase,%20boolean,%20java.lang.String)&quot;&gt;AstBuilder.buildFromString&lt;/a&gt;方法。必须针对强类型的AstBuilder调用buildFromCode（）方法。</target>
        </trans-unit>
        <trans-unit id="6e5a32a1bd41d5b21404f176ae361427aff05142" translate="yes" xml:space="preserve">
          <source>Immutable</source>
          <target state="translated">Immutable</target>
        </trans-unit>
        <trans-unit id="2e3839da4308a55b2d905190c12abe4986a65270" translate="yes" xml:space="preserve">
          <source>Immutable classes are particularly useful for functional and concurrent styles of programming and for use as key values within maps. If you want similar functionality to what this annotation provides but don't need immutability then consider using &lt;code&gt;@Canonical&lt;/code&gt;.</source>
          <target state="translated">不可变的类对于功能性和并发性编程风格以及用作映射内的键值特别有用。如果您想要与此注释提供的功能类似但不需要不变性，请考虑使用 &lt;code&gt;@Canonical&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cd72d86d41558d3f9974137a9eafb50fa818e9d3" translate="yes" xml:space="preserve">
          <source>Immutable singleton that is recommended for use when source range or any other occurrence-specific metadata is not needed.</source>
          <target state="translated">不可更改的单子,建议在不需要源范围或任何其他特定发生元数据时使用。</target>
        </trans-unit>
        <trans-unit id="8c8566035184b0abeec02cf77bfe0810137a9b25" translate="yes" xml:space="preserve">
          <source>ImmutableBase</source>
          <target state="translated">ImmutableBase</target>
        </trans-unit>
        <trans-unit id="54769b65bb63b8a979acb6c30a0c9bc9f29d9897" translate="yes" xml:space="preserve">
          <source>ImmutableOptions</source>
          <target state="translated">ImmutableOptions</target>
        </trans-unit>
        <trans-unit id="3a4b87af21a5cceca314e63d8f0cf69189a62150" translate="yes" xml:space="preserve">
          <source>ImmutablePropertyHandler</source>
          <target state="translated">ImmutablePropertyHandler</target>
        </trans-unit>
        <trans-unit id="d3f08b4a9088d68620bccf675f3e49ef763afc8a" translate="yes" xml:space="preserve">
          <source>Implement this method in order to be notified whenever a return statement is generated.</source>
          <target state="translated">实现这个方法,以便在产生返回语句时通知你。</target>
        </trans-unit>
        <trans-unit id="0c545f498c78adc1a627407c181e2bcf91837bd2" translate="yes" xml:space="preserve">
          <source>Implementation classes for SwingBuilder</source>
          <target state="translated">SwingBuilder的实现类</target>
        </trans-unit>
        <trans-unit id="40651c9b75650f4bf4e71f571b83bf813400630d" translate="yes" xml:space="preserve">
          <source>Implementation method of the alias annotation processor.</source>
          <target state="translated">别名注释处理器的实现方法。</target>
        </trans-unit>
        <trans-unit id="935e9ddadc5d308d635ed21a2869f1b5a87d5208" translate="yes" xml:space="preserve">
          <source>Implementation method of the alias annotation processor. This method will get the list of annotations we aliased from the collector and adds it to aliasAnnotationUsage. The method will also map all members from aliasAnnotationUsage to the aliased nodes. Should a member stay unmapped, we will ad an error. Further processing of those members is done by the annotations.</source>
          <target state="translated">别名注解处理器的实现方法。该方法将从收集器中获取我们别名的注解列表,并将其添加到aliasAnnotationUsage中。该方法还将把aliasAnnotationUsage中的所有成员映射到别名节点上。如果有成员没有被映射,我们会发出一个错误信息。这些成员的进一步处理是由注解完成的。</target>
        </trans-unit>
        <trans-unit id="344fd948f994fa7bce1c7d72483a6f65795c5e9b" translate="yes" xml:space="preserve">
          <source>Implementation note: A slightly faster implementation of this class will be possible once planned Java Memory Model revisions are in place.</source>
          <target state="translated">实现说明:一旦计划中的Java内存模型修订到位,该类的实现速度会稍快。</target>
        </trans-unit>
        <trans-unit id="9ddda46891b614d48be20ca4b97c58973b9a1ac6" translate="yes" xml:space="preserve">
          <source>Implementation of the left shift operator for integral types.</source>
          <target state="translated">积分类型的左移运算符的实现。</target>
        </trans-unit>
        <trans-unit id="7741648627b95263d7debece80a8a1e5178acba1" translate="yes" xml:space="preserve">
          <source>Implementation of the left shift operator for integral types. Non integral Number types throw UnsupportedOperationException.</source>
          <target state="translated">积分类型左移操作符的实现。非积分Number类型抛出UnsupportedOperationException。</target>
        </trans-unit>
        <trans-unit id="77d7ad4620d5f69ebebaa1e72482294dfb93a19e" translate="yes" xml:space="preserve">
          <source>Implementation of the right shift (unsigned) operator for integral types.</source>
          <target state="translated">积分类型右移(无符号)运算符的实现。</target>
        </trans-unit>
        <trans-unit id="4659d10637094d24fbc49cb1b9e39b91e059255c" translate="yes" xml:space="preserve">
          <source>Implementation of the right shift (unsigned) operator for integral types. Non integral Number types throw UnsupportedOperationException.</source>
          <target state="translated">对积分类型的右移(无符号)运算符的实现。非积分Number类型抛出UnsupportedOperationException。</target>
        </trans-unit>
        <trans-unit id="aceccfe1bbe5e98b8ec1e701c20153afbbaac662" translate="yes" xml:space="preserve">
          <source>Implementation of the right shift operator for integral types.</source>
          <target state="translated">积分类型右移运算符的实现。</target>
        </trans-unit>
        <trans-unit id="1a21aa3ac770a4191038a7964f3bb94579deac31" translate="yes" xml:space="preserve">
          <source>Implementation of the right shift operator for integral types. Non integral Number types throw UnsupportedOperationException.</source>
          <target state="translated">积分类型右移运算符的实现。非积分Number类型抛出UnsupportedOperationException。</target>
        </trans-unit>
        <trans-unit id="0ed455879e3d12fa31d560f7dfc070659d901ff8" translate="yes" xml:space="preserve">
          <source>Implementation supporting &lt;code&gt;@Grape&lt;/code&gt; and &lt;code&gt;@Grab&lt;/code&gt; annotations based on Ivy.</source>
          <target state="translated">支持基于Ivy的 &lt;code&gt;@Grape&lt;/code&gt; 和 &lt;code&gt;@Grab&lt;/code&gt; 批注的实现。</target>
        </trans-unit>
        <trans-unit id="e1d650ce3925a95081925332ee5c62799056e369" translate="yes" xml:space="preserve">
          <source>Implemented here to check package access prior to returning an already loaded class.</source>
          <target state="translated">在这里实现在返回一个已经加载的类之前检查包的访问。</target>
        </trans-unit>
        <trans-unit id="dbcded04c2cf17f9e1c72930594d83adac97c7ae" translate="yes" xml:space="preserve">
          <source>Implementers of this interface can be registered in the ProxyMetaClass for notifications about method calls for objects managed by the ProxyMetaClass. See groovy/lang/InterceptorTest.groovy for details.</source>
          <target state="translated">这个接口的实现者可以在ProxyMetaClass中注册,以获得关于ProxyMetaClass管理的对象的方法调用的通知。详情请参见 groovy/lang/InterceptorTest.groovy。</target>
        </trans-unit>
        <trans-unit id="9372245eacbc048f03913a09687b99f042a1f1cb" translate="yes" xml:space="preserve">
          <source>Implements memoize for Closures. It is supposed to be used by the Closure class itself to implement the memoize() family of methods.</source>
          <target state="translated">为Closure实现memoize。它应该被Closure类本身用来实现memoize()系列方法。</target>
        </trans-unit>
        <trans-unit id="fb178f2f627f60411afc815962ca61b85784dccd" translate="yes" xml:space="preserve">
          <source>Implements the Completer interface to provide completions for GroovyShell by tokenizing the buffer and invoking other classes depending on the tokens found.</source>
          <target state="translated">实现Completer接口,通过将缓冲区标记化,并根据找到的标记调用其他类,为GroovyShell提供完成。</target>
        </trans-unit>
        <trans-unit id="c0d276793046cde44fe17f8078e69b751fcc36fc" translate="yes" xml:space="preserve">
          <source>Implements the Completor interface to provide competions for GroovyShell by tokenizing the buffer and invoking other classes depending on the tokens found.</source>
          <target state="translated">实现Completor接口,通过标记缓冲区并根据找到的标记调用其他类,为GroovyShell提供竞争。</target>
        </trans-unit>
        <trans-unit id="f554bc2402284c53c488749e649be13a0354b39e" translate="yes" xml:space="preserve">
          <source>Implements the getAt(Collection) method for primitive type arrays.</source>
          <target state="translated">为基元类型数组实现getAt(Collection)方法。</target>
        </trans-unit>
        <trans-unit id="b49316ed55bda0281f8f3e716d309cfa20fe369b" translate="yes" xml:space="preserve">
          <source>Implements the getAt(Collection) method for primitive type arrays. Each value in the collection argument is assumed to be a valid array index. The value at each index is then added to a list which is returned.</source>
          <target state="translated">为基元类型数组实现getAt(Collection)方法。集合参数中的每个值都被认为是一个有效的数组索引。然后将每个索引的值添加到返回的列表中。</target>
        </trans-unit>
        <trans-unit id="53b8deeabfb15b9951d234e28c38666dc312c769" translate="yes" xml:space="preserve">
          <source>Implements the getAt(Range) method for primitive type arrays.</source>
          <target state="translated">实现基元类型数组的getAt(Range)方法。</target>
        </trans-unit>
        <trans-unit id="d312b00ce0dcc4d626573529bde2c1c7f8cfbbb1" translate="yes" xml:space="preserve">
          <source>Implements the getAt(int) method for primitive type arrays.</source>
          <target state="translated">实现基元类型数组的getAt(int)方法。</target>
        </trans-unit>
        <trans-unit id="cfc6d3ba1e1abaa97cb63bbadea3f58f41bd9663" translate="yes" xml:space="preserve">
          <source>Implements the setAt(int idx) method for primitive type arrays.</source>
          <target state="translated">为基元类型数组实现setAt(int idx)方法。</target>
        </trans-unit>
        <trans-unit id="7c994187cd760dda0ca4f18c3bc32ae0e7519d20" translate="yes" xml:space="preserve">
          <source>Imports a template and renders it using the specified model, allowing fine grained composition of templates and layouting.</source>
          <target state="translated">导入模板并使用指定的模型进行渲染,允许模板的细粒度组成和布局。</target>
        </trans-unit>
        <trans-unit id="eab5e71f5c06bb46d575e93e649dc06eba10288e" translate="yes" xml:space="preserve">
          <source>Imports a template and renders it using the specified model, allowing fine grained composition of templates and layouting. This works similarily to a template include but allows a distinct model to be used. If the layout inherits from the parent model, a new model is created, with the values from the parent model, eventually overridden with those provided specifically for this layout.</source>
          <target state="translated">导入一个模板并使用指定的模型进行渲染,允许模板的精细组合和布局。它的工作原理类似于模板包含,但允许使用不同的模型。如果布局继承自父模型,则创建一个新的模型,并使用父模型的值,最终用专门为该布局提供的值覆盖。</target>
        </trans-unit>
        <trans-unit id="c75b32a393c287efb68c3e671a6dd2e068e6daf3" translate="yes" xml:space="preserve">
          <source>Imports a template and renders it using the specified model, allowing fine grained composition of templates and layouting. This works similarily to a template include but allows a distinct model to be used. This version doesn't inherit the model from the parent. If you need model inheritance, see &lt;a href=&quot;#layout(java.util.Map,%20java.lang.String,%20boolean)&quot;&gt;layout(java.util.Map, String, boolean)&lt;/a&gt;.</source>
          <target state="translated">导入模板并使用指定的模型对其进行渲染，从而可以对模板和布局进行细粒度的组合。这与模板包含类似地工作，但是允许使用不同的模型。此版本不从父级继承模型。如果需要模型继承，请参见&lt;a href=&quot;#layout(java.util.Map,%20java.lang.String,%20boolean)&quot;&gt;layout（java.util.Map，String，boolean）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="48c1330801d4dccc5ea8a4a4f2bd39dfe7e6714d" translate="yes" xml:space="preserve">
          <source>In Groovy, return, break, continue, throw, and assert can be used in a parenthesized expression context.</source>
          <target state="translated">在Groovy中,return、break、continue、throw和assert可以在括号内的表达式上下文中使用。</target>
        </trans-unit>
        <trans-unit id="7bc9e5f8cf5f647c49af8253387a44211f0eba36" translate="yes" xml:space="preserve">
          <source>In Groovy, return, break, continue, throw, and assert can be used in a parenthesized expression context. Example: println (x || (return)); println assert x, &quot;won't print a false value!&quot; If an optional expression is missing, its value is void (this coerces to null when a value is required).</source>
          <target state="translated">在Groovy中,return、break、continue、throw和assert可以在括号内的表达式上下文中使用。例子:println (x || (return));println assert x,&quot;不会打印一个错误的值!&quot;。如果缺少一个可选的表达式,它的值是空的(当需要值时,这个胁迫为null)。</target>
        </trans-unit>
        <trans-unit id="0e738126f8c85f5c570a8505f3ef087f65262374" translate="yes" xml:space="preserve">
          <source>In Java, &quot;if&quot;, &quot;while&quot;, and &quot;for&quot; statements can take random, non-braced statements as their bodies.</source>
          <target state="translated">在Java中,&quot;if&quot;、&quot;while &quot;和 &quot;for &quot;语句可以采用随机的、非括号的语句作为主体。</target>
        </trans-unit>
        <trans-unit id="1b516f0fc02b5f1b453bc01a427a29507de351c5" translate="yes" xml:space="preserve">
          <source>In Java, &quot;if&quot;, &quot;while&quot;, and &quot;for&quot; statements can take random, non-braced statements as their bodies. Support this practice, even though it isn't very Groovy.</source>
          <target state="translated">在Java中,&quot;if&quot;、&quot;while &quot;和 &quot;for &quot;语句可以采用随机的、非braced语句作为主体。支持这种做法,尽管它不是很Groovy。</target>
        </trans-unit>
        <trans-unit id="f7d1a7aea3eb56854c467b12c9c106c619d631a8" translate="yes" xml:space="preserve">
          <source>In a chain of data manipulators some behaviour is common. TableMap provides most of this behaviour and can be subclassed by filters that only need to override a handful of specific methods. TableMap implements TableModel by routing all requests to its model, and TableModelListener by routing all events to its listeners. Inserting a TableMap which has not been subclassed into a chain of table filters should have no effect.</source>
          <target state="translated">在数据操作器的链条中,一些行为是常见的。TableMap提供了大部分的这种行为,并且可以被过滤器子类化,只需要覆盖少数特定方法。TableMap通过将所有请求路由到其模型来实现TableModel,通过将所有事件路由到其监听器来实现TableModelListener。插入一个没有被子类化到表过滤器链中的TableMap应该没有影响。</target>
        </trans-unit>
        <trans-unit id="ac8898ab55e87cf3747b265d8a0bbe0cc8803f6b" translate="yes" xml:space="preserve">
          <source>In addition to internal caches this method also clears any previously set MetaClass information for the given set of classes being removed.</source>
          <target state="translated">除了内部缓存外,该方法还可以清除任何先前设置的给定类集的MetaClass信息。</target>
        </trans-unit>
        <trans-unit id="a5d8d159a911a775ded0353a2d395078754090cb" translate="yes" xml:space="preserve">
          <source>In addition to the map constructor, provide a no-arg constructor which calls the map constructor with an empty map.</source>
          <target state="translated">除了map构造函数外,还提供了一个无参数构造函数,它用一个空的map调用map构造函数。</target>
        </trans-unit>
        <trans-unit id="560ee3b74fabd40d5a818607c3c7362dd571394e" translate="yes" xml:space="preserve">
          <source>In addition, the &lt;code&gt;metaClosure&lt;/code&gt; will be called once passing in the &lt;code&gt;ResultSetMetaData&lt;/code&gt; as argument.</source>
          <target state="translated">另外，一旦传入 &lt;code&gt;ResultSetMetaData&lt;/code&gt; 作为参数，就会调用 &lt;code&gt;metaClosure&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="78cb48f324910a1a5154fd739a7750443a3c2ed8" translate="yes" xml:space="preserve">
          <source>In addition, the &lt;code&gt;metaClosure&lt;/code&gt; will be called once passing in the &lt;code&gt;ResultSetMetaData&lt;/code&gt; as argument. The query may contain GString expressions.</source>
          <target state="translated">另外，一旦传入 &lt;code&gt;ResultSetMetaData&lt;/code&gt; 作为参数，就会调用 &lt;code&gt;metaClosure&lt;/code&gt; 。该查询可能包含GString表达式。</target>
        </trans-unit>
        <trans-unit id="d89b7fde6e771767e533b9acead2af3b0ea98651" translate="yes" xml:space="preserve">
          <source>In addition, the &lt;code&gt;metaClosure&lt;/code&gt; will be called once passing in the &lt;code&gt;ResultSetMetaData&lt;/code&gt; as argument. The query may contain placeholder question marks which match the given list of parameters.</source>
          <target state="translated">另外，一旦传入 &lt;code&gt;ResultSetMetaData&lt;/code&gt; 作为参数，就会调用 &lt;code&gt;metaClosure&lt;/code&gt; 。该查询可能包含与给定参数列表匹配的占位符问号。</target>
        </trans-unit>
        <trans-unit id="391f1a755656a8aebdd61842ad7313b3e1d04856" translate="yes" xml:space="preserve">
          <source>In addition, you can add any valid Ivy attributes at the end of your string value using semi-colon separated name = value pairs, e.g.:</source>
          <target state="translated">此外,您可以使用分号分隔的name=value对在字符串值的末尾添加任何有效的常春藤属性,例如。</target>
        </trans-unit>
        <trans-unit id="661369e292c2c2ef57b20567d0751eec05cbf599" translate="yes" xml:space="preserve">
          <source>In cases when there are multiple &lt;code&gt;@DelegatesTo.Target&lt;/code&gt; annotated parameters, this member should be set to the DelegatesTo.Target#value() of the correct target.</source>
          <target state="translated">如果有多个 &lt;code&gt;@DelegatesTo.Target&lt;/code&gt; 注释的参数，则此成员应设置为正确目标的DelegatesTo.Target＃value（）。</target>
        </trans-unit>
        <trans-unit id="4efa70c8b0d453566afda894e9eacf0dc41e6fcf" translate="yes" xml:space="preserve">
          <source>In essence we start with a closure on the form:</source>
          <target state="translated">实质上,我们从形式上的封闭开始。</target>
        </trans-unit>
        <trans-unit id="7826837060358c204ea0f1d5c344aa69c88bd9bb" translate="yes" xml:space="preserve">
          <source>In general, the order in which the map contents are processed cannot be guaranteed. In practise, specialized forms of Map, e.g. a TreeMap will have its contents processed according to the natural ordering of the map.</source>
          <target state="translated">一般来说,地图内容的处理顺序是无法保证的。在实践中,特殊形式的Map,如TreeMap将按照地图的自然顺序处理其内容。</target>
        </trans-unit>
        <trans-unit id="ddad056e2794ccb282e28f4c5b21a2897193e2fd" translate="yes" xml:space="preserve">
          <source>In many scenarios, it is better to overwrite the invokeCustom method where the core Object related methods are filtered out.</source>
          <target state="translated">在很多场景下,最好覆盖invokeCustom方法,核心的Object相关方法被过滤掉。</target>
        </trans-unit>
        <trans-unit id="a45ee100b9cdac2bc1d12748aad07f149d7a6dc7" translate="yes" xml:space="preserve">
          <source>In order to modify JLine Behavior, we need to wrap the IO streams so we can hack into them This allows autoindent and redisplaying the chars typed so far after exceptions during completion</source>
          <target state="translated">为了修改JLine Behavior,我们需要对IO流进行包装,这样我们就可以对它们进行黑客攻击,这样就可以在完成过程中自动缩进和重新显示到目前为止输入的字符。</target>
        </trans-unit>
        <trans-unit id="14ad66ba5554bcc9cee69aad54f7f268a92e9f04" translate="yes" xml:space="preserve">
          <source>In order to support class-loading-troubles-debugging with Tomcat 4 or higher, you can log the class loader responsible for loading some classes. See &lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-861&quot;&gt;GROOVY-861&lt;/a&gt; for details. The servlet init parameter name is:</source>
          <target state="translated">为了支持Tomcat 4或更高版本的类加载问题调试，您可以登录负责加载某些类的类加载器。有关详细信息，请参见&lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-861&quot;&gt;GROOVY-861&lt;/a&gt;。Servlet初始化参数名称为：</target>
        </trans-unit>
        <trans-unit id="e5ad142c70af59aa4d257bbc55331a8aa6fbc22c" translate="yes" xml:space="preserve">
          <source>In previous Groovy versions, such methods could only be defined in a single class called &lt;a href=&quot;../defaultgroovymethods&quot;&gt;DefaultGroovyMethods&lt;/a&gt; for instance methods, and &lt;a href=&quot;../defaultgroovystaticmethods&quot;&gt;DefaultGroovyStaticMethods&lt;/a&gt; for static methods.</source>
          <target state="translated">在以前的Groovy版本中，这种方法只能在被称为一个类中定义&lt;a href=&quot;../defaultgroovymethods&quot;&gt;DefaultGroovyMethods&lt;/a&gt;实例方法，并&lt;a href=&quot;../defaultgroovystaticmethods&quot;&gt;DefaultGroovyStaticMethods&lt;/a&gt;静态方法。</target>
        </trans-unit>
        <trans-unit id="45a0d1c9d551c89c05e8dffb936ada3cd37caa10" translate="yes" xml:space="preserve">
          <source>In the above example, &lt;code&gt;super.clone()&lt;/code&gt; is called which in this case calls &lt;code&gt;clone()&lt;/code&gt; from &lt;code&gt;java.lang.Object&lt;/code&gt;. This does a bit-wise copy of all the properties (references and primitive values). Properties like &lt;code&gt;first&lt;/code&gt; has type &lt;code&gt;String&lt;/code&gt; which is not &lt;code&gt;Cloneable&lt;/code&gt; so it is left as the bit-wise copy. Both &lt;code&gt;Date&lt;/code&gt; and &lt;code&gt;ArrayList&lt;/code&gt; are &lt;code&gt;Cloneable&lt;/code&gt; so the &lt;code&gt;clone()&lt;/code&gt; method on each of those properties will be called. For the list, a shallow copy is made during its &lt;code&gt;clone()&lt;/code&gt; method.</source>
          <target state="translated">在上面的示例中， &lt;code&gt;super.clone()&lt;/code&gt; ，在这种情况下，该调用从 &lt;code&gt;java.lang.Object&lt;/code&gt; 调用 &lt;code&gt;clone()&lt;/code&gt; 。这会按位复制所有属性（引用和原始值）。像 &lt;code&gt;first&lt;/code&gt; 这样的属性具有 &lt;code&gt;String&lt;/code&gt; 类型，该类型是不可 &lt;code&gt;Cloneable&lt;/code&gt; 因此将其保留为按位复制。两个 &lt;code&gt;Date&lt;/code&gt; 和 &lt;code&gt;ArrayList&lt;/code&gt; 的是 &lt;code&gt;Cloneable&lt;/code&gt; 的所以 &lt;code&gt;clone()&lt;/code&gt; 在每个这些属性的方法将被调用。对于列表，将在其 &lt;code&gt;clone()&lt;/code&gt; 方法期间进行浅表复制。</target>
        </trans-unit>
        <trans-unit id="c961f595aa1b66614bf543f7a3520b53429152b2" translate="yes" xml:space="preserve">
          <source>In the above example, since &lt;code&gt;hasNext&lt;/code&gt; returns false, the &lt;code&gt;next&lt;/code&gt; method should never be called, so any dummy implementation would do for &lt;code&gt;next&lt;/code&gt;. The &quot;empty&quot; implementation provided by default when using &lt;code&gt;@AutoImplement&lt;/code&gt; will suffice - which effectively returns &lt;code&gt;null&lt;/code&gt; in Groovy for non-void, non-primitive methods. As a point of interest, the default implementation for methods returning primitive types is to return the default value (which incidentally never satisfies Groovy truth). For &lt;code&gt;boolean&lt;/code&gt; this means returning &lt;code&gt;false&lt;/code&gt;, so for the above example we could have (albeit perhaps less instructive of our intent) by just using:</source>
          <target state="translated">在上面的示例中，由于 &lt;code&gt;hasNext&lt;/code&gt; 返回false，所以决不要调用 &lt;code&gt;next&lt;/code&gt; 方法，因此任何虚拟实现都可以对 &lt;code&gt;next&lt;/code&gt; 进行处理。默认情况下，使用 &lt;code&gt;@AutoImplement&lt;/code&gt; 时提供的&amp;ldquo;空&amp;rdquo;实现就足够了-对于非void，非原始方法，它在Groovy中有效地返回 &lt;code&gt;null&lt;/code&gt; 。有意思的是，返回原始类型的方法的默认实现是返回默认值（顺便说一句，它永远不会满足Groovy真理）。对于 &lt;code&gt;boolean&lt;/code&gt; 这意味着返回 &lt;code&gt;false&lt;/code&gt; ，因此对于上面的示例，我们可以使用（尽管可能对我们的意图没有多大用处）：</target>
        </trans-unit>
        <trans-unit id="76b2bf06ad75750d4e298c5d4bd3ee4673aeab78" translate="yes" xml:space="preserve">
          <source>In the above example.</source>
          <target state="translated">在上面的例子中。</target>
        </trans-unit>
        <trans-unit id="398d527bbb278129aa090563201fa72f4322ea64" translate="yes" xml:space="preserve">
          <source>In the case of a &lt;em&gt;Object.with { ... }&lt;/em&gt; call, this method is supposed to retrieve the inferred closure return type.</source>
          <target state="translated">如果使用&lt;em&gt;Object.with {...}&lt;/em&gt;调用，则此方法应检索推断的闭包返回类型。</target>
        </trans-unit>
        <trans-unit id="c71c1c9300505d5197cbeae407764360330a2b06" translate="yes" xml:space="preserve">
          <source>In the example above we have Alias as the alias annotation and an argument excludes which will be mapped to ToString and EqualsAndHashCode. Immutable doesn't have excludes, thus nothing will be done there.</source>
          <target state="translated">在上面的例子中,我们有Alias作为别名注解和一个参数excludes,它将被映射到ToString和EqualsAndHashCode。Immutable没有excludes,因此不会在那里做任何事情。</target>
        </trans-unit>
        <trans-unit id="b4319a417d236b315c3ddb01cf87a1373fda4b86" translate="yes" xml:space="preserve">
          <source>In the example above we have again Alias as the alias annotation, but this time the argument is part of the alias. Instead of mapping excludes to ToString as well as EqualsAndHashCode, only ToString will have the excludes. Again the alias can have an argument excludes, which would overwrite the excludes given in from the definition and be mapped to ToString as well as EqualsAndHashCode. If both ways are combined, then the list overwrites annotation usage. NOTE: The aliasing does not support aliasing of aliased annotations.</source>
          <target state="translated">在上面的例子中,我们又以Alias作为别名注解,但这次的参数是别名的一部分。与其将excludes映射到ToString以及EqualsAndHashCode,不如说只有ToString会有excludes。同样,别名也可以有一个参数excludes,它将覆盖从定义中给出的excludes,并映射到ToString以及EqualsAndHashCode。如果两种方式结合起来,那么列表就会覆盖注释的用法。注意:别名不支持别名注释的别名。</target>
        </trans-unit>
        <trans-unit id="2804ef58cc247133102f1dfbd63188258d7e32e8" translate="yes" xml:space="preserve">
          <source>In the presence of method overloading and method overriding you might run into situations where a call is considered recursive although it really is not.</source>
          <target state="translated">在存在方法重载和方法重载的情况下,你可能会遇到这样的情况,即一个调用被认为是递归的,但实际上不是。</target>
        </trans-unit>
        <trans-unit id="3d9b11dbffee5a4b8c9412d03ea2ceda7b10e5c1" translate="yes" xml:space="preserve">
          <source>In this case, the parameter(s) for the constructor or static method become the properties available in the builder. For the case of a static method, the return type of the static method becomes the class of the instance being created. For static factory methods, this is normally the class containing the static method but in general it can be any class. Note: if using more than one &lt;code&gt;@Builder&lt;/code&gt; annotation, which is only possible when using static method or constructor variants, it is up to you to ensure that any generated helper classes or builder methods have unique names. E.g. we can modify the previous example to have three builders. At least two of the builders in our case will need to set the 'builderClassName' and 'builderMethodName' annotation attributes to ensure we have unique names. This is shown in the following example:</source>
          <target state="translated">在这种情况下，构造函数或静态方法的参数将成为构建器中可用的属性。对于静态方法，静态方法的返回类型将成为正在创建的实例的类。对于静态工厂方法，这通常是包含静态方法的类，但通常可以是任何类。注意：如果使用多个 &lt;code&gt;@Builder&lt;/code&gt; 注解，仅在使用静态方法或构造函数变体时才可行，这取决于您确保任何生成的帮助程序类或构建器方法具有唯一的名称。例如，我们可以修改前面的示例以包含三个构建器。在我们的案例中，至少有两个构建器需要设置'builderClassName'和'builderMethodName'注释属性，以确保我们具有唯一的名称。在下面的示例中显示：</target>
        </trans-unit>
        <trans-unit id="bc3739dbec9e244b09e9db80740990dfb0930ab5" translate="yes" xml:space="preserve">
          <source>In this case, your template source file should be HTML with the appropriate embedded placeholders.</source>
          <target state="translated">在这种情况下,你的模板源文件应该是带有适当嵌入占位符的HTML。</target>
        </trans-unit>
        <trans-unit id="de44e3e9cd5cbc81afe2b348cd97a03de868714d" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;Event&lt;/code&gt; class will have a method called &lt;code&gt;before(Date otherDate)&lt;/code&gt; as well as other public methods of the &lt;code&gt;Date&lt;/code&gt; class. The implementation of the &lt;code&gt;before()&lt;/code&gt; method will look like this:</source>
          <target state="translated">在此示例中， &lt;code&gt;Event&lt;/code&gt; 类将具有一个称为 &lt;code&gt;before(Date otherDate)&lt;/code&gt; 的方法，以及 &lt;code&gt;Date&lt;/code&gt; 类的其他公共方法。在实施 &lt;code&gt;before()&lt;/code&gt; 方法如下所示：</target>
        </trans-unit>
        <trans-unit id="c3b54a6ae1487664290ae93480a2f6026f492088" translate="yes" xml:space="preserve">
          <source>In this example, the base script of the current script will be changed to &lt;code&gt;CustomScript&lt;/code&gt; allowing usage of &lt;code&gt;getTheMeaningOfLife()&lt;/code&gt; method. &lt;code&gt;baseScript&lt;/code&gt; variable will become typed shortcut for &lt;code&gt;this&lt;/code&gt; object which enables better IDE support.</source>
          <target state="translated">在此示例中，当前脚本的基本脚本将更改为 &lt;code&gt;CustomScript&lt;/code&gt; ,从而允许使用 &lt;code&gt;getTheMeaningOfLife()&lt;/code&gt; 方法。 &lt;code&gt;baseScript&lt;/code&gt; 变量将成为 &lt;code&gt;this&lt;/code&gt; 对象的键入快捷方式，从而可以提供更好的IDE支持。</target>
        </trans-unit>
        <trans-unit id="c4d023660251369695912411539ddc1e95f260aa" translate="yes" xml:space="preserve">
          <source>In this example, without the annotation, variable &lt;code&gt;awe&lt;/code&gt; would be a local script variable (technically speaking it will be a local variable within the &lt;code&gt;run&lt;/code&gt; method of the script class). Such a local variable would not be visible inside the &lt;code&gt;awesum&lt;/code&gt; method. With the annotation, &lt;code&gt;awe&lt;/code&gt; becomes a private List field in the script class and is visible within the &lt;code&gt;awesum&lt;/code&gt; method.</source>
          <target state="translated">在此示例中，没有注释，变量 &lt;code&gt;awe&lt;/code&gt; 将是本地脚本变量（从技术上讲，它将是脚本类的 &lt;code&gt;run&lt;/code&gt; 方法中的本地变量）。这样的局部变量在 &lt;code&gt;awesum&lt;/code&gt; 方法内部不可见。通过注释， &lt;code&gt;awe&lt;/code&gt; 成为脚本类中的私有List字段，并且在 &lt;code&gt;awesum&lt;/code&gt; 方法中可见。</target>
        </trans-unit>
        <trans-unit id="c39b7e0b217eb469e199200ed5b1a95c137d92d6" translate="yes" xml:space="preserve">
          <source>In this method, you are given a ClassNode, a field name and a category name, and you must add a new Field onto the class.</source>
          <target state="translated">在这个方法中,你会得到一个ClassNode,一个字段名和一个类别名,你必须在类中添加一个新的字段。</target>
        </trans-unit>
        <trans-unit id="6665bad8119f1bd7f2518f89949adca37cd36bbc" translate="yes" xml:space="preserve">
          <source>In this method, you are given a ClassNode, a field name and a category name, and you must add a new Field onto the class. Return the result of the ClassNode.addField operations.</source>
          <target state="translated">在这个方法中,给你一个ClassNode,一个字段名和一个类别名,你必须向类中添加一个新的Field。返回ClassNode.addField操作的结果。</target>
        </trans-unit>
        <trans-unit id="1ae4ccb76f0db2cdb3f0c74d0410c8f11a15c277" translate="yes" xml:space="preserve">
          <source>Include fields as well as properties in equals and hashCode calculations.</source>
          <target state="translated">在等价和哈希码计算中包括字段以及属性。</target>
        </trans-unit>
        <trans-unit id="c828a1230ccbee289e6dea690133fb83c0b90210" translate="yes" xml:space="preserve">
          <source>Include fields as well as properties in the generated toString.</source>
          <target state="translated">在生成的toString中包含字段以及属性。</target>
        </trans-unit>
        <trans-unit id="d073a3a7d666cfeda89e25193e056818e167c36e" translate="yes" xml:space="preserve">
          <source>Include fields as well as properties in the generated toString. Fields come after any properties.</source>
          <target state="translated">在生成的toString中包含字段和属性。字段位于任何属性之后。</target>
        </trans-unit>
        <trans-unit id="c64c570555f732f9916d71dc427343992febc276" translate="yes" xml:space="preserve">
          <source>Include fields as well as properties when cloning.</source>
          <target state="translated">克隆时包括字段以及属性。</target>
        </trans-unit>
        <trans-unit id="7860a567b2da95da693eab6763b3d1241859e8f2" translate="yes" xml:space="preserve">
          <source>Include fields as well as properties when externalizing.</source>
          <target state="translated">在外部化时,包括字段以及属性。</target>
        </trans-unit>
        <trans-unit id="dc1ea7b64049e095cf8d9133182c579185333bb6" translate="yes" xml:space="preserve">
          <source>Include fields as well as properties when verifying externalization properties.</source>
          <target state="translated">在验证外部化属性时,既包括字段,也包括属性。</target>
        </trans-unit>
        <trans-unit id="9d5722b5ace7ec1e35c8f2b30fb4c4411fc92d12" translate="yes" xml:space="preserve">
          <source>Include fields from super classes in the constructor.</source>
          <target state="translated">在构造函数中包含超级类的字段。</target>
        </trans-unit>
        <trans-unit id="09ad9eb1f2e997d37ca654a1b8c0557fd88bc9e9" translate="yes" xml:space="preserve">
          <source>Include fields from super classes in the constructor. Groovy properties, JavaBean properties and fields (in that order) from superclasses come before the members from a subclass (unless 'includes' is used to determine the order).</source>
          <target state="translated">在构造函数中包含来自超级类的字段。来自超级类的Groovy属性、JavaBean属性和字段(按顺序)排在来自子类的成员之前(除非使用'includes'来确定顺序)。</target>
        </trans-unit>
        <trans-unit id="50bfc4af25ee043a076484cd1b5a91e929b8bfd5" translate="yes" xml:space="preserve">
          <source>Include fields in the constructor.</source>
          <target state="translated">在构造函数中包含字段。</target>
        </trans-unit>
        <trans-unit id="f469808a26a6bbb0467d23661d335f208326a081" translate="yes" xml:space="preserve">
          <source>Include fields in the constructor. Fields come after any properties.</source>
          <target state="translated">在构造函数中包含字段。字段位于任何属性之后。</target>
        </trans-unit>
        <trans-unit id="f2b8d5528f4b0b7bbae4e0f9a674154c2990c5c5" translate="yes" xml:space="preserve">
          <source>Include properties from super classes in the constructor.</source>
          <target state="translated">在构造函数中包含超级类的属性。</target>
        </trans-unit>
        <trans-unit id="400a8891d3f031e65f5e2aa3e1e6df8635428dab" translate="yes" xml:space="preserve">
          <source>Include properties from super classes in the constructor. Groovy properties, JavaBean properties and fields (in that order) from superclasses come before the members from a subclass (unless 'includes' is used to determine the order).</source>
          <target state="translated">在构造函数中包含来自超级类的属性。来自超级类的Groovy属性、JavaBean属性和字段(按顺序)排在来自子类的成员之前(除非使用 &quot;includes &quot;来确定顺序)。</target>
        </trans-unit>
        <trans-unit id="15996bc60c75db626a50053404bf46a781426e15" translate="yes" xml:space="preserve">
          <source>Include properties in the constructor.</source>
          <target state="translated">在构造函数中包含属性。</target>
        </trans-unit>
        <trans-unit id="345b73a890e8c3e03f6651ad3bcad29be1a9dff5" translate="yes" xml:space="preserve">
          <source>Include super fields in the generated toString.</source>
          <target state="translated">在生成的toString中包含超级字段。</target>
        </trans-unit>
        <trans-unit id="8d599a640b7926068fb069414072f67dda1f3c61" translate="yes" xml:space="preserve">
          <source>Include super fields in the generated toString. Groovy properties, JavaBean properties and fields (in that order) from superclasses come after the members from a subclass (unless 'includes' is used to determine the order).</source>
          <target state="translated">在生成的toString中包含超级字段。来自超级类的Groovy属性、JavaBean属性和字段(按顺序)排在子类成员之后(除非使用'includes'来确定顺序)。</target>
        </trans-unit>
        <trans-unit id="ea5774487b882678a03293876f43087c3f8af6b9" translate="yes" xml:space="preserve">
          <source>Include visible fields from super classes in the constructor.</source>
          <target state="translated">在构造函数中包含超级类的可见字段。</target>
        </trans-unit>
        <trans-unit id="8356a7c79eed62ee5b3c0381729058e4135d0f60" translate="yes" xml:space="preserve">
          <source>Include visible fields from super classes in the constructor. Groovy properties, JavaBean properties and fields (in that order) from superclasses come before the members from a subclass (unless 'includes' is used to determine the order).</source>
          <target state="translated">在构造函数中包含来自超级类的可见字段。来自超级类的Groovy属性、JavaBean属性和字段(按顺序)排在来自子类的成员之前(除非使用'includes'来确定顺序)。</target>
        </trans-unit>
        <trans-unit id="6cbcf96558c836bf857abb1a76a392639ccd39e0" translate="yes" xml:space="preserve">
          <source>Include whitespace tokens.</source>
          <target state="translated">包括空白代币。</target>
        </trans-unit>
        <trans-unit id="36b0cee182e9b536cbd58dc99bcca24daea7018e" translate="yes" xml:space="preserve">
          <source>Include whitespace tokens. Note that this breaks the parser.</source>
          <target state="translated">包括空白标记。注意,这将破坏解析器。</target>
        </trans-unit>
        <trans-unit id="f675b35064da76cf0f99afe3d1232be006ab091e" translate="yes" xml:space="preserve">
          <source>Included enum types in this package.</source>
          <target state="translated">本包中包含的枚举类型。</target>
        </trans-unit>
        <trans-unit id="ad8101fdfa12bd2afd7603a3769d1bd20f15c337" translate="yes" xml:space="preserve">
          <source>Included errors in this package.</source>
          <target state="translated">本包中包含的错误。</target>
        </trans-unit>
        <trans-unit id="3536d6b2571bd5e2da3d7b13a5ad28c3e43e7e2c" translate="yes" xml:space="preserve">
          <source>Included exceptions in this package.</source>
          <target state="translated">在这个包中包括了例外。</target>
        </trans-unit>
        <trans-unit id="a31e9e05626ce9bc6bd56c0f66c3968378e47823" translate="yes" xml:space="preserve">
          <source>Included interfaces in this package.</source>
          <target state="translated">本包中包含的接口。</target>
        </trans-unit>
        <trans-unit id="9b4de5d26b79350fd3a2d84ab681c4b93524558b" translate="yes" xml:space="preserve">
          <source>Included ordinary classes in this package.</source>
          <target state="translated">在这个包中包含了普通类。</target>
        </trans-unit>
        <trans-unit id="9ce93040f2bbde2501f5743d59fd52bfedd4c57f" translate="yes" xml:space="preserve">
          <source>Includes another template inside this template.</source>
          <target state="translated">包括这个模板里面的另一个模板。</target>
        </trans-unit>
        <trans-unit id="04c446d4b2f7da094a7aa2938d636b9a4aafe411" translate="yes" xml:space="preserve">
          <source>Includes contents of another file, not as a template but as escaped text.</source>
          <target state="translated">包括另一个文件的内容,不是作为模板而是作为转义文本。</target>
        </trans-unit>
        <trans-unit id="9e1e28ba5bf4463b6673389c543d4bdea0a07d1c" translate="yes" xml:space="preserve">
          <source>Includes contents of another file, not as a template but as unescaped text.</source>
          <target state="translated">包括另一个文件的内容,不是作为模板,而是作为未封装的文本。</target>
        </trans-unit>
        <trans-unit id="0de98a6813b057074479b8a095aa9aaa5efa9199" translate="yes" xml:space="preserve">
          <source>Incorrect class or method access modifiers</source>
          <target state="translated">错误的类或方法访问修饰符</target>
        </trans-unit>
        <trans-unit id="5e4e8fabf3def3ed3aa13d0b146a1bcb1e81bd3c" translate="yes" xml:space="preserve">
          <source>Increment a Calendar by one day.</source>
          <target state="translated">将一个日历递增一天。</target>
        </trans-unit>
        <trans-unit id="2130f07cf98313196621bf7eb03f08d4372f5e48" translate="yes" xml:space="preserve">
          <source>Increment a Character by one.</source>
          <target state="translated">将一个字符递增一个。</target>
        </trans-unit>
        <trans-unit id="18baeff2e56c096a42f9d7fa3562b117d6bdcb34" translate="yes" xml:space="preserve">
          <source>Increment a Date by one day.</source>
          <target state="translated">将日期递增一天。</target>
        </trans-unit>
        <trans-unit id="e676450834683edb9bca6cb9bd67640d33572c28" translate="yes" xml:space="preserve">
          <source>Increment a Number by one.</source>
          <target state="translated">将一个数字递增一。</target>
        </trans-unit>
        <trans-unit id="7e666c2e9c4eca966b4e7f4f22713640172b0012" translate="yes" xml:space="preserve">
          <source>Increment a java.sql.Date by one day.</source>
          <target state="translated">将java.sql.Date递增一天。</target>
        </trans-unit>
        <trans-unit id="8f4438848e5dcdbecd68e2ee08cdc58548f3283e" translate="yes" xml:space="preserve">
          <source>Increments batch count (after addBatch(..) has been called) and execute &lt;code&gt;delegate.executeBatch()&lt;/code&gt; if batchSize has been reached.</source>
          <target state="translated">递增批计数（在调用addBatch（..）之后 &lt;code&gt;delegate.executeBatch()&lt;/code&gt; 如果达到batchSize ，则执行委托.executeBatch （）。</target>
        </trans-unit>
        <trans-unit id="8df654d78d1e52f736e37daa71a518bea8977a19" translate="yes" xml:space="preserve">
          <source>Increments by one</source>
          <target state="translated">增加一个</target>
        </trans-unit>
        <trans-unit id="340e104d8c94c234cc284d3169443867ddb5a757" translate="yes" xml:space="preserve">
          <source>IndentPrinter(Writer, String)</source>
          <target state="translated">IndentPrinter(Writer,String)</target>
        </trans-unit>
        <trans-unit id="4c09b0da1e60181c4f58437e4da7193acba519e6" translate="yes" xml:space="preserve">
          <source>IndentPrinter(Writer, String, boolean)</source>
          <target state="translated">IndentPrinter(Writer,String,boolean)</target>
        </trans-unit>
        <trans-unit id="011c729e05413a2d998282aedce187ab410703d1" translate="yes" xml:space="preserve">
          <source>IndentPrinter.IndentPrinter</source>
          <target state="translated">IndentPrinter.IndentPrinter</target>
        </trans-unit>
        <trans-unit id="33531defa11460112257e84636254d0ce04bd6e3" translate="yes" xml:space="preserve">
          <source>Indention by default is 2 characters but can be changed by passing a different value as a constructor argument.</source>
          <target state="translated">默认的缩进值是2个字符,但可以通过传递一个不同的值作为构造参数来改变。</target>
        </trans-unit>
        <trans-unit id="bfd2a4ef244c8714c3075fce5a24010de2edf97d" translate="yes" xml:space="preserve">
          <source>Index overlay parsers (INDEX_OVERLAY and LAX) are the fastest JSON parsers. However they are not the default for a good reason. Index overlay parsers has pointers (indexes really) to original char buffer. Care must be used if putting parsed maps into a long term cache as members of map maybe index overlay objects pointing to original buffer. You can mitigate these risks by using chop and lazy chop properties.  Chop eagerly dices up the buffer so each Value element points to a small copy of the original buffer.  Lazy Chop dices up the buffer when a list get or map get is called so if an GPath expression or such is applied.  You do not need chop or lazy chop if you are NOT putting the map into a long term cache. You do not need chop or lazy chop if you are doing object de-serialization. Recommendation is to use INDEX_OVERLAY for JSON buffers under 2MB. The maxSizeForInMemory is set to 2MB and any file over 2MB will use a parser designed for large files, which is slower than the INDEX_OVERLAY, LAX, and CHAR_BUFFER parsers, but faster than most commonly used JSON parsers on the JVM for most use cases circa January 2014.  To enable the INDEX_OVERLAY parser do this: &lt;code&gt;&lt;pre&gt;
             parser = new JsonSlurper().setType(JsonParserType.INDEX_OVERLAY);
 &lt;/pre&gt;&lt;/code&gt;</source>
          <target state="translated">索引覆盖解析器（INDEX_OVERLAY和LAX）是最快的JSON解析器。但是，由于种种原因，它们不是默认值。索引覆盖解析器具有指向原始char缓冲区的指针（实际上是索引）。如果将已解析的地图放入长期缓存中，则必须格外小心，因为地图的成员可能会索引指向原始缓冲区的覆盖对象。您可以通过使用印章和惰性印章属性来减轻这些风险。 Chop急切地将缓冲区切成小块，因此每个Value元素都指向原始缓冲区的一小部分副本。当调用列表get或map get时，Lazy Chop将缓冲区切成小块，因此，如果应用了GPath表达式等。如果不将地图放入长期缓存中，则不需要印章或惰性印章。如果要进行对象反序列化，则不需要印章或惰性印章。建议对2MB以下的JSON缓冲区使用INDEX_OVERLAY。maxSizeForInMemory设置为2MB，超过2MB的任何文件都将使用专为大文件设计的解析器，该解析器比INDEX_OVERLAY，LAX和CHAR_BUFFER解析器要慢，但在大约1月的大多数使用情况下，比JVM上最常用的JSON解析器要快。 2014。要启用INDEX_OVERLAY解析器，请执行以下操作： &lt;code&gt;&lt;pre&gt; parser = new JsonSlurper().setType(JsonParserType.INDEX_OVERLAY); &lt;/pre&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f2c01dbbbb93eac9e56f88d11cd5d2fdc42f86cc" translate="yes" xml:space="preserve">
          <source>IndexOutOfBoundsException always</source>
          <target state="translated">IndexOutOfBoundsException总是</target>
        </trans-unit>
        <trans-unit id="28983c206f9625cd64307149e8ffcc6117e018a5" translate="yes" xml:space="preserve">
          <source>Indicate whether all classes and members are to be included in the scope processed.</source>
          <target state="translated">指明是否所有的类和成员都要包含在处理的范围内。</target>
        </trans-unit>
        <trans-unit id="37af5eb3c5984103d16acba2b6b6e435cc858a38" translate="yes" xml:space="preserve">
          <source>Indicate whether only package, protected and public classes and members are to be included in the scope processed.</source>
          <target state="translated">表示是否只将包、受保护的和公共的类和成员包含在处理的范围内。</target>
        </trans-unit>
        <trans-unit id="9a2c50887984f6ea1fbd250c291f305766fb59fd" translate="yes" xml:space="preserve">
          <source>Indicate whether only package, protected and public classes and members are to be included in the scope processed. Package scoped access is ignored for fields of Groovy classes where they correspond to properties.</source>
          <target state="translated">指定是否只将包、受保护的和公共的类和成员包含在处理的作用域中。对于Groovy类中与属性相对应的字段,包的作用域访问会被忽略。</target>
        </trans-unit>
        <trans-unit id="9151450e9695b288e940eaed4e5ff9ae64d32e8e" translate="yes" xml:space="preserve">
          <source>Indicate whether only protected and public classes and members are to be included in the scope processed.</source>
          <target state="translated">指明是否只将受保护的和公共的类和成员包含在处理的范围内。</target>
        </trans-unit>
        <trans-unit id="04f2fdf68956d6b9287c18a8527bb90561cc4767" translate="yes" xml:space="preserve">
          <source>Indicate whether only public classes and members are to be included in the scope processed.</source>
          <target state="translated">表示是否只将公有类和成员包含在处理的范围内。</target>
        </trans-unit>
        <trans-unit id="797adb5c89ad5f0756111cbca64e4e4490b284aa" translate="yes" xml:space="preserve">
          <source>Indicates if a class is recompilable.</source>
          <target state="translated">表示一个类是否可以重新编译。</target>
        </trans-unit>
        <trans-unit id="136ff849ce9296a31b281d1dec2754d21f36c8fd" translate="yes" xml:space="preserve">
          <source>Indicates if a class is recompilable. Recompilable means, that the classloader will try to locate a groovy source file for this class and then compile it again, adding the resulting class as entry to the cache. Giving null as class is like a recompilation, so the method should always return true here. Only classes that are implementing GroovyObject are compilable and only if the timestamp in the class is lower than Long.MAX_VALUE.</source>
          <target state="translated">表示一个类是否可重新编译。可重编译的意思是,classloader会尝试为这个类找到一个groovy的源文件,然后再次编译,并将编译后的类作为条目添加到缓存中。给出null作为类就像重新编译一样,所以这里的方法应该总是返回true。只有实现了GroovyObject的类才可以编译,而且只有当类中的时间戳小于Long.MAX_VALUE时才可以编译。</target>
        </trans-unit>
        <trans-unit id="630a1fdbc53509cab6a90707dcdcd82177e722f5" translate="yes" xml:space="preserve">
          <source>Indicates if this node was added by the compiler.</source>
          <target state="translated">表示该节点是否由编译器添加。</target>
        </trans-unit>
        <trans-unit id="4044b1721ebebee783d419b3ad05dc384e34d734" translate="yes" xml:space="preserve">
          <source>Indicates that a method or property can be used to set a CLI option.</source>
          <target state="translated">表示可以用一个方法或属性来设置CLI选项。</target>
        </trans-unit>
        <trans-unit id="111ec9e52a672f298dada3e2c35de7ed8d6e1a02" translate="yes" xml:space="preserve">
          <source>Indicates that a method or property will contain the remaining arguments.</source>
          <target state="translated">表示一个方法或属性将包含剩余的参数。</target>
        </trans-unit>
        <trans-unit id="688d661e02c805465235986d525218a481a44928" translate="yes" xml:space="preserve">
          <source>Indicates that a power assertion has failed.</source>
          <target state="translated">表示权力断言失败。</target>
        </trans-unit>
        <trans-unit id="5c74b8b9377b918c22b16e2e0536d37a2ea0f40f" translate="yes" xml:space="preserve">
          <source>Indicates that adding final to parameters should not be applied on this node.</source>
          <target state="translated">表示在此节点上不应将final添加到参数中。</target>
        </trans-unit>
        <trans-unit id="515d2853261830b17f6d9ee3c4649a17e78f6bfa" translate="yes" xml:space="preserve">
          <source>Indicates that option processing should continue for all arguments even if arguments not recognized as options are encountered (default true).</source>
          <target state="translated">表示即使遇到未被识别为选项的参数,也应继续对所有参数进行选项处理(默认为true)。</target>
        </trans-unit>
        <trans-unit id="16c5983aaf38d489ce1e9e09a931fa86402bd34b" translate="yes" xml:space="preserve">
          <source>Indicates that the source text for an assertion statement is not available.</source>
          <target state="translated">表示没有断言声明的源文本。</target>
        </trans-unit>
        <trans-unit id="505880517a15e270bf9ada478e0c993af67b4028" translate="yes" xml:space="preserve">
          <source>Indicates that this class has been &quot;promoted&quot; to public by Groovy when in fact there was no public modifier explicitly in the source code.</source>
          <target state="translated">表示这个类已经被Groovy &quot;推广 &quot;为public,而事实上在源代码中并没有明确的public修改器。</target>
        </trans-unit>
        <trans-unit id="3b0dd73c5b0268fc6174fc78a27c5ce0f408284e" translate="yes" xml:space="preserve">
          <source>Indicates that this class has been &quot;promoted&quot; to public by Groovy when in fact there was no public modifier explicitly in the source code. That is, it remembers that it has applied Groovy's &quot;public classes by default&quot; rule. This property is typically only of interest to AST transform writers.</source>
          <target state="translated">表示这个类已经被Groovy &quot;推广 &quot;为public,而事实上在源代码中并没有明确的public修改器。也就是说,它记住了它已经应用了Groovy的 &quot;默认的公共类 &quot;规则。这个属性通常只对AST变换编写者感兴趣。</target>
        </trans-unit>
        <trans-unit id="1dbf181544581165a2aafe84fc8700dad185c075" translate="yes" xml:space="preserve">
          <source>Indicates that this method has been &quot;promoted&quot; to public by Groovy when in fact there was no public modifier explicitly in the source code.</source>
          <target state="translated">表示该方法已被Groovy &quot;推广 &quot;为公共方法,而事实上在源代码中并没有明确的公共修改器。</target>
        </trans-unit>
        <trans-unit id="a7ce180a91783f1049e3f844f88313e87c2d6a12" translate="yes" xml:space="preserve">
          <source>Indicates that this method has been &quot;promoted&quot; to public by Groovy when in fact there was no public modifier explicitly in the source code. I.e. it remembers that it has applied Groovy's &quot;public methods by default&quot; rule. This property is typically only of interest to AST transform writers.</source>
          <target state="translated">表示该方法已被Groovy &quot;推广 &quot;为公共方法,而事实上在源代码中并没有明确的公共修饰符。即它记得它已经应用了Groovy的 &quot;默认的公共方法 &quot;规则。这个属性通常只对AST变换编写者感兴趣。</target>
        </trans-unit>
        <trans-unit id="9e91399ce962d879d1a90977bd497afa41e07f1b" translate="yes" xml:space="preserve">
          <source>Indicates that we save stdin, stdout, stderr and replace them while AntBuilder is executing tasks with streams that funnel the normal streams into Ant's logs.</source>
          <target state="translated">表示我们保存stdin、stdout、stderr,并在AntBuilder执行任务时用流来替换,将正常的流漏入Ant的日志。</target>
        </trans-unit>
        <trans-unit id="d2c0574153cb32a84757b41d5b5bba3b0874ad6f" translate="yes" xml:space="preserve">
          <source>Indicates the access mode or scope of interest: one of public, protected, package, or private.</source>
          <target state="translated">表示访问模式或感兴趣的范围:公共的、受保护的、一揽子的或私有的之一。</target>
        </trans-unit>
        <trans-unit id="e34e836702855ff2a38ad110c1b2d865f4e281ec" translate="yes" xml:space="preserve">
          <source>Indicates the access mode or scope of interest: one of public, protected, package, or private. Package scoped access is ignored for fields of Groovy classes where they correspond to properties.</source>
          <target state="translated">表示访问模式或感兴趣的范围:公共、保护、包或私有。对于Groovy类中与属性相对应的字段,包范围的访问被忽略。</target>
        </trans-unit>
        <trans-unit id="bf09860494a25745ac4146d1ec679d4964be79ce" translate="yes" xml:space="preserve">
          <source>Indicates the visibility of a node.</source>
          <target state="translated">表示节点的可见性。</target>
        </trans-unit>
        <trans-unit id="54ff3cf4cc8a0eadcb739383275700fcba97fefc" translate="yes" xml:space="preserve">
          <source>Indicates whether a method in a trait interface has a default implementation.</source>
          <target state="translated">表示特质接口中的方法是否有默认实现。</target>
        </trans-unit>
        <trans-unit id="c1fedeb686d6f6dffb0b910cbefc0072bb08a324" translate="yes" xml:space="preserve">
          <source>Indicates whether an object is greater than or equal to the &lt;code&gt;from&lt;/code&gt; value for the range and less than or equal to the &lt;code&gt;to&lt;/code&gt; value.</source>
          <target state="translated">指示对象是否大于或等于范围的 &lt;code&gt;from&lt;/code&gt; 值并且小于或等于 &lt;code&gt;to&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="3d7ca37b34bf0b4c07aa13e30e0972d68ab74459" translate="yes" xml:space="preserve">
          <source>Indicates whether some other object is &quot;equal to&quot; this one.</source>
          <target state="translated">表示是否有其他对象 &quot;等于 &quot;这个对象。</target>
        </trans-unit>
        <trans-unit id="ad12be725e3b21db9d70cc068cec9d3b12569235" translate="yes" xml:space="preserve">
          <source>Indicates whether some other object is &quot;equal to&quot; this one. The delegate is used if the class of the parameter and the current class are equal. In other cases the method will return false. The exact class is here used, if inheritance is needed, this method must be overwritten.</source>
          <target state="translated">表示其他对象是否 &quot;等于 &quot;这个对象。如果参数的类和当前的类相等,则使用委托。在其他情况下,该方法将返回false。这里使用的是确切的类,如果需要继承,必须覆盖这个方法。</target>
        </trans-unit>
        <trans-unit id="e2d97fc712ad2782088acd2ed361fc5abb4e5319" translate="yes" xml:space="preserve">
          <source>Indicates whether the build will continue even if there are compilation errors; defaults to true.</source>
          <target state="translated">表示即使存在编译错误,是否也会继续编译;默认为true。</target>
        </trans-unit>
        <trans-unit id="7e3c6405066426e5e0b860c3e6ec74708b52de06" translate="yes" xml:space="preserve">
          <source>Indicates whether the given type should be excluded from the generated output.</source>
          <target state="translated">表示是否应从生成的输出中排除给定类型。</target>
        </trans-unit>
        <trans-unit id="6f693dd64de275122519ea98317b05d94048404b" translate="yes" xml:space="preserve">
          <source>Indicates whether this JsonGenerator is configured to exclude fields by the given name.</source>
          <target state="translated">表示该JsonGenerator是否被配置为通过给定名称排除字段。</target>
        </trans-unit>
        <trans-unit id="125f3f9c7ccd5bb1ff4d8f7ab5f44c458b443e72" translate="yes" xml:space="preserve">
          <source>Indicates whether this JsonGenerator is configured to exclude values of the given object (may be &lt;code&gt;null&lt;/code&gt;).</source>
          <target state="translated">指示此JsonGenerator是否配置为排除给定对象的值（可以为 &lt;code&gt;null&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="32d8d3f4878eb89f5a96e339cf2002b26c78e2b0" translate="yes" xml:space="preserve">
          <source>Indicates whether this is a reverse range which iterates backwards starting from the to value and ending on the from value</source>
          <target state="translated">表示这是否是一个反向的范围,从到值开始向后迭代,在从值结束。</target>
        </trans-unit>
        <trans-unit id="e2bbd100b61c132a1d1fa306cfb83c47ce1cc49f" translate="yes" xml:space="preserve">
          <source>Inherited Methods</source>
          <target state="translated">继承方法</target>
        </trans-unit>
        <trans-unit id="525b08441bb8c0644d7c96c43785500201217653" translate="yes" xml:space="preserve">
          <source>Inherited Methods Summary</source>
          <target state="translated">继承方法总结</target>
        </trans-unit>
        <trans-unit id="1113923ba75acdf59f5f11ac7135267eb1a45ab4" translate="yes" xml:space="preserve">
          <source>Inherited fields</source>
          <target state="translated">继承领域</target>
        </trans-unit>
        <trans-unit id="eb878c6f16903697157c351e3e8ebe115fc5dfe9" translate="yes" xml:space="preserve">
          <source>Initialize the ErrorReporter.</source>
          <target state="translated">初始化ErrorReporter。</target>
        </trans-unit>
        <trans-unit id="59b83c798f78c0a1d3f60fe765e592bc94b7a685" translate="yes" xml:space="preserve">
          <source>Initialize the GroovyServlet.</source>
          <target state="translated">初始化GroovyServlet。</target>
        </trans-unit>
        <trans-unit id="a6fb58cc9802092bf3a3cc95b8853dd5b3d66a1b" translate="yes" xml:space="preserve">
          <source>Initialize the engine.</source>
          <target state="translated">初始化发动机。</target>
        </trans-unit>
        <trans-unit id="b8e78616cee764a31e917e99d83ea2d947192c4b" translate="yes" xml:space="preserve">
          <source>InitializerStrategy</source>
          <target state="translated">InitializerStrategy</target>
        </trans-unit>
        <trans-unit id="d4a147d3a58f6a93b03ce020cbbebc024da5094d" translate="yes" xml:space="preserve">
          <source>Initializes a servlet binding.</source>
          <target state="translated">初始化一个servlet绑定。</target>
        </trans-unit>
        <trans-unit id="018fdbe1ea47775a5cef23b1aac0fed048fd86c0" translate="yes" xml:space="preserve">
          <source>Initializes all fields with default values.</source>
          <target state="translated">用默认值初始化所有字段。</target>
        </trans-unit>
        <trans-unit id="7e13e98506ee6c263f6387e3abf33c8d3b1b1d65" translate="yes" xml:space="preserve">
          <source>Initializes the &lt;code&gt;Reduction&lt;/code&gt; with the specified root.</source>
          <target state="translated">用指定的根初始化 &lt;code&gt;Reduction&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4d29e8b13f98f3fc521b8b5f6372148290314c00" translate="yes" xml:space="preserve">
          <source>Initializes the CompilationUnit with a CodeSource for controlling security stuff and a class loader for loading classes.</source>
          <target state="translated">初始化CompilationUnit,其中有一个用于控制安全东西的CodeSource和一个用于加载类的class loader。</target>
        </trans-unit>
        <trans-unit id="21cefd573af25261c92ef632e7a0db6749a64236" translate="yes" xml:space="preserve">
          <source>Initializes the CompilationUnit with a CodeSource for controlling security stuff, a class loader for loading classes, and a class loader for loading AST transformations.</source>
          <target state="translated">初始化编译单元(CompilationUnit),其中包含一个用于控制安全性的CodeSource,一个用于加载类的类加载器,以及一个用于加载AST转换的类加载器。</target>
        </trans-unit>
        <trans-unit id="95dbb5f188b9328589a14e7d7d8f4780c516eba1" translate="yes" xml:space="preserve">
          <source>Initializes the CompilationUnit with defaults except for class loader.</source>
          <target state="translated">除了类加载器之外,用默认值初始化CompilationUnit。</target>
        </trans-unit>
        <trans-unit id="b4102b04129b7ed5a876d7ae367d015ee87f881b" translate="yes" xml:space="preserve">
          <source>Initializes the CompilationUnit with defaults.</source>
          <target state="translated">用默认值初始化CompilationUnit。</target>
        </trans-unit>
        <trans-unit id="b3179075e8e32f7cbfffbc996362f312d1d9a5bd" translate="yes" xml:space="preserve">
          <source>Initializes the CompilationUnit with no security considerations.</source>
          <target state="translated">初始化CompilationUnit,不考虑安全性。</target>
        </trans-unit>
        <trans-unit id="ca52279e8fb4897719c0575a2e97960ed7463938" translate="yes" xml:space="preserve">
          <source>Initializes the Compiler with default configuration.</source>
          <target state="translated">用默认配置初始化编译器。</target>
        </trans-unit>
        <trans-unit id="263d4a4bea61da7144e7e58d47cd89a846921d8f" translate="yes" xml:space="preserve">
          <source>Initializes the Compiler with the specified configuration.</source>
          <target state="translated">用指定的配置初始化编译器。</target>
        </trans-unit>
        <trans-unit id="15af0111cf2f4d615f2c5de582b344aee5d306e0" translate="yes" xml:space="preserve">
          <source>Initializes the ProcessingUnit to the empty state.</source>
          <target state="translated">将ProcessingUnit初始化为空状态。</target>
        </trans-unit>
        <trans-unit id="51f2c812f742acf60d43647d4095c3863bd6e218" translate="yes" xml:space="preserve">
          <source>Initializes the SourceUnit for a string of source.</source>
          <target state="translated">初始化SourceUnit的源字符串。</target>
        </trans-unit>
        <trans-unit id="9f46ea457ddbfaa478187081ddc94608b1d9cc45" translate="yes" xml:space="preserve">
          <source>Initializes the SourceUnit from existing machinery.</source>
          <target state="translated">从现有机械中初始化SourceUnit。</target>
        </trans-unit>
        <trans-unit id="7f13c83fe940838e90743fbe7fe5f5fc6c100744" translate="yes" xml:space="preserve">
          <source>Initializes the SourceUnit from the specified URL.</source>
          <target state="translated">从指定的URL中初始化SourceUnit。</target>
        </trans-unit>
        <trans-unit id="9921c0f2eaf5788735b382aa7b73b2ab8fdf6e63" translate="yes" xml:space="preserve">
          <source>Initializes the SourceUnit from the specified file.</source>
          <target state="translated">从指定的文件中初始化SourceUnit。</target>
        </trans-unit>
        <trans-unit id="8e3df46aaae75466f4bacb9ca62e36f0fa90d610" translate="yes" xml:space="preserve">
          <source>Initializes the Token with the specified information.</source>
          <target state="translated">用指定的信息初始化 Token。</target>
        </trans-unit>
        <trans-unit id="5ccaf4086cb4983e387ee64edfd34030f12e5429" translate="yes" xml:space="preserve">
          <source>Initializes the exception from a cause exception.</source>
          <target state="translated">从原因异常初始化异常。</target>
        </trans-unit>
        <trans-unit id="5193595db809d1ca78357bf43059222e32a48ebe" translate="yes" xml:space="preserve">
          <source>Initializes the exception with just a message.</source>
          <target state="translated">初始化异常,只留下一条消息。</target>
        </trans-unit>
        <trans-unit id="2f90639a807d84eed531876e842e56bdff997141" translate="yes" xml:space="preserve">
          <source>Initializes the servlet from hints the container passes.</source>
          <target state="translated">根据容器传递的提示初始化servlet。</target>
        </trans-unit>
        <trans-unit id="3351595f5d922e5915dde2489705b78f804beefd" translate="yes" xml:space="preserve">
          <source>Initializes the variable scopes for an AST.</source>
          <target state="translated">初始化AST的变量范围。</target>
        </trans-unit>
        <trans-unit id="79ec6f67ff66e011adab964b5ec89eb42717fb37" translate="yes" xml:space="preserve">
          <source>Injects a set of Comparators and sort methods.</source>
          <target state="translated">注入一组比较器和排序方法。</target>
        </trans-unit>
        <trans-unit id="5ca42c5b7e7077d99eaf0259c9e2d36ecd218191" translate="yes" xml:space="preserve">
          <source>InputStreamReader</source>
          <target state="translated">InputStreamReader</target>
        </trans-unit>
        <trans-unit id="974925732faa25666ea3a7a61450acd786571d50" translate="yes" xml:space="preserve">
          <source>Insert a string into the document, and then parse it if the parser has been set.</source>
          <target state="translated">在文档中插入一个字符串,如果设置了解析器,则对其进行解析。</target>
        </trans-unit>
        <trans-unit id="f60a39dc2a4544292380f685df34a712cb4bfece" translate="yes" xml:space="preserve">
          <source>Inspects returns the String that matches what would be typed into a terminal to create this object.</source>
          <target state="translated">Inspects 返回与在终端中输入的内容相匹配的字符串,以创建该对象。</target>
        </trans-unit>
        <trans-unit id="f71de9d0e1b97507aa3a1c35f7d679019aa7c00c" translate="yes" xml:space="preserve">
          <source>Instance logger for the command, initialized late to include the command name.</source>
          <target state="translated">命令的实例记录器,后期初始化,包括命令名称。</target>
        </trans-unit>
        <trans-unit id="8f2a045c48beddae4470c8eb9f88775f2874e35d" translate="yes" xml:space="preserve">
          <source>Instances of this class are returned when using the &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; left shift operator.</source>
          <target state="translated">使用 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 左移运算符时，将返回此类的实例。</target>
        </trans-unit>
        <trans-unit id="cbb5cb56dfcc372628a3ae1a595518bc9f517323" translate="yes" xml:space="preserve">
          <source>Instances of this class may be either inclusive aware or non-inclusive aware. See the relevant constructors for creating each type. Inclusive aware IntRange instances are suitable for use with Groovy's range indexing - in particular if the from or to values might be negative. This normally happens underneath the covers but is worth keeping in mind if creating these ranges yourself explicitly.</source>
          <target state="translated">这个类的实例可以是包容意识的,也可以是非包容意识的。请参阅相关构造函数来创建每种类型。包容性的IntRange实例适用于Groovy的范围索引--特别是当from或to的值可能是负值时。这通常发生在掩盖之下,但如果你自己显式创建这些范围,值得注意。</target>
        </trans-unit>
        <trans-unit id="fe9045c39f61d602eb927eacd5ccf37b7715969d" translate="yes" xml:space="preserve">
          <source>Instantiates a JSON builder with a configured generator.</source>
          <target state="translated">用配置的生成器实例化JSON生成器。</target>
        </trans-unit>
        <trans-unit id="ab1655ecd6e379b69ade58c6fb0256dda6df8f3a" translate="yes" xml:space="preserve">
          <source>Instantiates a JSON builder with some existing data structure and a configured generator.</source>
          <target state="translated">用一些现有的数据结构和配置的生成器实例化一个JSON生成器。</target>
        </trans-unit>
        <trans-unit id="024cd6f45ac7dec6052f5ded44708bd82874aa05" translate="yes" xml:space="preserve">
          <source>Instantiates a JSON builder with some existing data structure.</source>
          <target state="translated">用一些现有的数据结构实例化一个JSON生成器。</target>
        </trans-unit>
        <trans-unit id="42f1b5fbc27acba496786d41004ae62ba205bf32" translate="yes" xml:space="preserve">
          <source>Instantiates a JSON builder with the given generator.</source>
          <target state="translated">用给定的生成器实例化一个JSON生成器。</target>
        </trans-unit>
        <trans-unit id="54c96df382f08472d6631bb6e772a12405602377" translate="yes" xml:space="preserve">
          <source>Instantiates a JSON builder, possibly with some existing data structure and the given generator.</source>
          <target state="translated">实例化一个JSON生成器,可能使用一些现有的数据结构和给定的生成器。</target>
        </trans-unit>
        <trans-unit id="141cef8318094b1983ce9fa1c2a4d869be71804c" translate="yes" xml:space="preserve">
          <source>Instantiates a JSON builder, possibly with some existing data structure.</source>
          <target state="translated">实例化一个JSON生成器,可能有一些现有的数据结构。</target>
        </trans-unit>
        <trans-unit id="5dd21d8c79e7150205d021fc437e3e0ae133c9d9" translate="yes" xml:space="preserve">
          <source>Instantiates a JSON builder.</source>
          <target state="translated">实例化JSON生成器。</target>
        </trans-unit>
        <trans-unit id="699fb02e1fced90c275177b0d7a711a57517e3f9" translate="yes" xml:space="preserve">
          <source>Instantiates a lexer with a reader from which to read JSON tokens.</source>
          <target state="translated">实例化一个带有读取器的lexer,用来读取JSON标记。</target>
        </trans-unit>
        <trans-unit id="a2aaa2aa5c8a8c74c12672eb9fe39641af9e0252" translate="yes" xml:space="preserve">
          <source>Instantiates a lexer with a reader from which to read JSON tokens. Under the hood, the reader is wrapped in a &lt;code&gt;LineColumnReader&lt;/code&gt;, for line and column information, unless it's already an instance of that class.</source>
          <target state="translated">用阅读器实例化词法分析器，从中读取JSON令牌。在 &lt;code&gt;LineColumnReader&lt;/code&gt; ，阅读器被包装在LineColumnReader中，以获取行和列信息，除非它已经是该类的实例。</target>
        </trans-unit>
        <trans-unit id="ef10dd1a9b12de51bbd9401d757f87db07d5d41d" translate="yes" xml:space="preserve">
          <source>InstantiationException</source>
          <target state="translated">InstantiationException</target>
        </trans-unit>
        <trans-unit id="66148a5f176a715cb6a8fa060b2bb31495aa640b" translate="yes" xml:space="preserve">
          <source>InstantiationException if attempting to instantiate an interface or abstract class</source>
          <target state="translated">如果试图实例化一个接口或抽象类,则出现实例化异常。</target>
        </trans-unit>
        <trans-unit id="f49d92979e6adf342140051a68886e26c421fe1e" translate="yes" xml:space="preserve">
          <source>Instead, if the values are intended to be the same in each case, just take advantage of the fact that put returns null if the key was not previously present:</source>
          <target state="translated">相反,如果打算在每种情况下的值都是一样的,只需利用put返回null的事实,如果键之前不存在。</target>
        </trans-unit>
        <trans-unit id="d0ef219554460ea946d899d3af957e808033169c" translate="yes" xml:space="preserve">
          <source>Instead, the class should be used as:</source>
          <target state="translated">相反,该类应作为。</target>
        </trans-unit>
        <trans-unit id="10190743fb8223eeb16d7c0324c2fe8937eedbbf" translate="yes" xml:space="preserve">
          <source>Instructs &lt;code&gt;ProxyGenerator&lt;/code&gt; to dump generated Groovy source code to standard output during construction.</source>
          <target state="translated">指示 &lt;code&gt;ProxyGenerator&lt;/code&gt; 在构造期间将生成的Groovy源代码转储到标准输出中。</target>
        </trans-unit>
        <trans-unit id="5c0d68a404938ba3c9b64f06287a8bf217ec1265" translate="yes" xml:space="preserve">
          <source>Instructs &lt;code&gt;ProxyGenerator&lt;/code&gt; to dump generated Groovy source code to standard output during construction. This is useful for debugging purposes but should be turned off in production.</source>
          <target state="translated">指示 &lt;code&gt;ProxyGenerator&lt;/code&gt; 在构造期间将生成的Groovy源代码转储到标准输出中。这对于调试目的很有用，但应在生产中关闭。</target>
        </trans-unit>
        <trans-unit id="44a47af36c3357cb073689cf5c5aee4bbe200cdd" translate="yes" xml:space="preserve">
          <source>Instructs the type checker that a property access is dynamic, returning an instance of an Object.</source>
          <target state="translated">指示类型检查器一个属性访问是动态的,返回一个Object的实例。</target>
        </trans-unit>
        <trans-unit id="696b76462a7efaa66fa4555536e507c9c7cb8d8d" translate="yes" xml:space="preserve">
          <source>Instructs the type checker that a property access is dynamic, returning an instance of an Object. Calling this method automatically sets the handled flag to true.</source>
          <target state="translated">指示类型检查器一个属性访问是动态的,返回一个对象的实例。调用此方法会自动将handled标志设置为true。</target>
        </trans-unit>
        <trans-unit id="f5783076db2d8bc8f6e05b71aff1a725bda33e17" translate="yes" xml:space="preserve">
          <source>Instructs the type checker that a property access is dynamic.</source>
          <target state="translated">指示类型检查器,一个属性访问是动态的。</target>
        </trans-unit>
        <trans-unit id="13a35877ee250e0b95f32df7c7142282003c22c4" translate="yes" xml:space="preserve">
          <source>Instructs the type checker that a property access is dynamic. Calling this method automatically sets the handled flag to true.</source>
          <target state="translated">指示类型检查器,一个属性访问是动态的。调用此方法会自动将handled标志设置为true。</target>
        </trans-unit>
        <trans-unit id="3fb090cda925adff9cab9618ac57d782c45f9af2" translate="yes" xml:space="preserve">
          <source>Instructs the type checker that an unresolved variable is a dynamic variable of type Object.</source>
          <target state="translated">指示类型检查器,一个未解析的变量是一个类型为Object的动态变量。</target>
        </trans-unit>
        <trans-unit id="5e645caee01bf36ede65b503f18ae7e451cf5a93" translate="yes" xml:space="preserve">
          <source>Instructs the type checker that an unresolved variable is a dynamic variable of type Object. Calling this method automatically sets the handled flag to true.</source>
          <target state="translated">指示类型检查器,一个未解析的变量是一个类型为Object的动态变量。调用本方法会自动将handled标志设置为true。</target>
        </trans-unit>
        <trans-unit id="9d14d5ec662e09e05e2a351f2e33645a5e0b7711" translate="yes" xml:space="preserve">
          <source>Instructs the type checker that an unresolved variable is a dynamic variable.</source>
          <target state="translated">指示类型检查器,一个未解析的变量是一个动态变量。</target>
        </trans-unit>
        <trans-unit id="1ecd34c101b616e04032d5f18915a529dbf2c1ba" translate="yes" xml:space="preserve">
          <source>IntRange</source>
          <target state="translated">IntRange</target>
        </trans-unit>
        <trans-unit id="9edcffff4461c9083fbff857f8dcee0f0769cbd4" translate="yes" xml:space="preserve">
          <source>Integer</source>
          <target state="translated">Integer</target>
        </trans-unit>
        <trans-unit id="282bee276f291473af31dcfb27b04e885aa9e464" translate="yes" xml:space="preserve">
          <source>Integer Divide a Character by a Number.</source>
          <target state="translated">整数 把一个字符除以一个数字。</target>
        </trans-unit>
        <trans-unit id="523de5b1efc3884facd85bd7960b60820cc80e38" translate="yes" xml:space="preserve">
          <source>Integer Divide a Character by a Number. The ordinal value of the Character is used in the division (the ordinal value is the unicode value which for simple character sets is the ASCII value).</source>
          <target state="translated">整数 将一个字符除以一个数字。字符的序数值用于除法(序数值是unicode值,对于简单的字符集是ASCII值)。</target>
        </trans-unit>
        <trans-unit id="af9bcd985439abcaa482fdc61d2aeb35e354049d" translate="yes" xml:space="preserve">
          <source>Integer Divide a Number by a Character.</source>
          <target state="translated">整数 把一个数字除以一个字符。</target>
        </trans-unit>
        <trans-unit id="e7e5ff13a9c79a559ce3c6d980b890b987919c24" translate="yes" xml:space="preserve">
          <source>Integer Divide a Number by a Character. The ordinal value of the Character is used in the division (the ordinal value is the unicode value which for simple character sets is the ASCII value).</source>
          <target state="translated">Integer 用一个字符除以一个数字。在除法中使用字符的序数值(序数值是unicode值,对于简单的字符集是ASCII值)。</target>
        </trans-unit>
        <trans-unit id="8dbb3c4f6a5c7e8ea9df752a169f767916a19496" translate="yes" xml:space="preserve">
          <source>Integer Divide two Characters.</source>
          <target state="translated">整数 除以两个字符。</target>
        </trans-unit>
        <trans-unit id="d2ce5e4524d2deba8d2495c765a494d3f9d4f417" translate="yes" xml:space="preserve">
          <source>Integer Divide two Characters. The ordinal values of the Characters are used in the division (the ordinal value is the unicode value which for simple character sets is the ASCII value).</source>
          <target state="translated">整数 将两个字符进行分割。在除法中使用了字符的序数值(序数值是unicode值,对于简单的字符集是ASCII值)。</target>
        </trans-unit>
        <trans-unit id="769a8fc3a15f9677e4479913a38cada19a7d6a3d" translate="yes" xml:space="preserve">
          <source>Integer Divide two Numbers.</source>
          <target state="translated">整数 除以两个数。</target>
        </trans-unit>
        <trans-unit id="a1a5a5ffc5b09ed1348c99c2c5f25a7060b93321" translate="yes" xml:space="preserve">
          <source>Integer NumberMath operations</source>
          <target state="translated">Integer NumberMath运算</target>
        </trans-unit>
        <trans-unit id="b160768b4b5f9616a76c29f6c42dc462b87234a7" translate="yes" xml:space="preserve">
          <source>Integer.toHexString</source>
          <target state="translated">Integer.toHexString</target>
        </trans-unit>
        <trans-unit id="da2005159ca4c8d71ba85e9ff00b443dbdd809d8" translate="yes" xml:space="preserve">
          <source>Integer.valueOf</source>
          <target state="translated">Integer.valueOf</target>
        </trans-unit>
        <trans-unit id="af4e92c3977d25a130dec0d64c4d9a879aa6518d" translate="yes" xml:space="preserve">
          <source>Integration code for running JUnit5 tests in Groovy.</source>
          <target state="translated">在Groovy中运行JUnit5测试的集成代码。</target>
        </trans-unit>
        <trans-unit id="ed5c6ff87ae992b7bc738f80f9d81d8125f0c5e0" translate="yes" xml:space="preserve">
          <source>Integration code for running TestNG tests in Groovy.</source>
          <target state="translated">在Groovy中运行TestNG测试的集成代码。</target>
        </trans-unit>
        <trans-unit id="dd3eaab4334570b25633ba2d249f4195f42ade7e" translate="yes" xml:space="preserve">
          <source>Intended style to use for cloning when using the &lt;code&gt;@&lt;/code&gt;AutoClone annotation.</source>
          <target state="translated">使用 &lt;code&gt;@&lt;/code&gt; AutoClone注释时用于克隆的目标样式。</target>
        </trans-unit>
        <trans-unit id="4e271243406cc97bddb89bda451e1ef2a0fd931f" translate="yes" xml:space="preserve">
          <source>Intended target when &lt;code&gt;@&lt;/code&gt;PackageScope is placed at the class level.</source>
          <target state="translated">将 &lt;code&gt;@&lt;/code&gt; PackageScope放置在类级别时的预期目标。</target>
        </trans-unit>
        <trans-unit id="69cad189c01e0d81e121559b26c93fff2c5b42e1" translate="yes" xml:space="preserve">
          <source>Intercepting calls to the collaborating object and notify the expectation object.</source>
          <target state="translated">拦截对协作对象的调用,并通知期望对象。</target>
        </trans-unit>
        <trans-unit id="25e97337ebc803a40ea4ba33c2ef4895c55ad558" translate="yes" xml:space="preserve">
          <source>Interceptor</source>
          <target state="translated">Interceptor</target>
        </trans-unit>
        <trans-unit id="3711158676504254123b7d5710e4044213a5ebef" translate="yes" xml:space="preserve">
          <source>Interceptor that registers the timestamp of each method call before and after invocation. The timestamps are stored internally and can be retrieved through the with the</source>
          <target state="translated">拦截器,在调用前和调用后记录每个方法调用的时间戳。时间戳在内部存储,并可通过与</target>
        </trans-unit>
        <trans-unit id="d35a22de69f97431f7c956a90af66e1a51c95720" translate="yes" xml:space="preserve">
          <source>Interceptors the call to a property setter if a PropertyAccessInterceptor is available</source>
          <target state="translated">拦截器 如果有属性访问拦截器,则对属性设置器的调用。</target>
        </trans-unit>
        <trans-unit id="7e40b6f8124f11fd093aa8257c34718368004c9b" translate="yes" xml:space="preserve">
          <source>Interceptors the call to getProperty if a PropertyAccessInterceptor is available</source>
          <target state="translated">如果有PropertyAccessInterceptor,则调用getProperty的拦截器。</target>
        </trans-unit>
        <trans-unit id="2b11688434243ec948303820617069cce4c61836" translate="yes" xml:space="preserve">
          <source>Intercepts System.out/System.err. Implementation helper for Console.groovy.</source>
          <target state="translated">拦截System.out/System.err.Console.groovy的实现帮助程序。Console.groovy.的实现帮助程序。</target>
        </trans-unit>
        <trans-unit id="7e267a27738cb944d4bd1469e2c7850c9179052e" translate="yes" xml:space="preserve">
          <source>Intercepts a getXXX call and returns a result.</source>
          <target state="translated">拦截getXXX调用并返回结果。</target>
        </trans-unit>
        <trans-unit id="92d9cb1faa3a1dcad3e87d033070745c5236e603" translate="yes" xml:space="preserve">
          <source>Intercepts a getXXX call and returns a result. The result is replaced by the real value if doGet() return false</source>
          <target state="translated">拦截getXXX调用并返回结果。如果doGet()返回false,结果将被实际值替换。</target>
        </trans-unit>
        <trans-unit id="c79ef7c67d23201013fdd8798f24bf77148ea15e" translate="yes" xml:space="preserve">
          <source>Intercepts a setXXX call</source>
          <target state="translated">拦截一个setXXX呼叫</target>
        </trans-unit>
        <trans-unit id="9484648b0e9aa989c8e367b5ade3bf15e19dd6ce" translate="yes" xml:space="preserve">
          <source>Intercepts calls for setting a key and value for a JSON object</source>
          <target state="translated">拦截为JSON对象设置键和值的调用。</target>
        </trans-unit>
        <trans-unit id="70f9887b1d1d30067762a751d4454610a113b3fd" translate="yes" xml:space="preserve">
          <source>Intercepts output - more common case of byte[]</source>
          <target state="translated">拦截输出--更常见的是字节[]的情况。</target>
        </trans-unit>
        <trans-unit id="c80f5668deda45ae6800ab7d9462acf81d202fc4" translate="yes" xml:space="preserve">
          <source>Intercepts output - single characters</source>
          <target state="translated">拦截输出--单字符</target>
        </trans-unit>
        <trans-unit id="02afcdec53dc1afddc018f7c53dc9dc63d29d958" translate="yes" xml:space="preserve">
          <source>Interface class nodes retrieved from &lt;a href=&quot;../classnode#getInterfaces()&quot;&gt;ClassNode.getInterfaces&lt;/a&gt; or &lt;a href=&quot;../classnode#getAllInterfaces()&quot;&gt;ClassNode.getAllInterfaces&lt;/a&gt; are returned with generic type arguments.</source>
          <target state="translated">从&lt;a href=&quot;../classnode#getInterfaces()&quot;&gt;ClassNode.getInterfaces&lt;/a&gt;或&lt;a href=&quot;../classnode#getAllInterfaces()&quot;&gt;ClassNode.getAllInterfaces&lt;/a&gt;中检索到的接口类节点将使用泛型类型参数返回。</target>
        </trans-unit>
        <trans-unit id="5dd6272f6e8b0a4e6096ab1d7d51794d5ace55fb" translate="yes" xml:space="preserve">
          <source>Interface class nodes retrieved from &lt;a href=&quot;../classnode#getInterfaces()&quot;&gt;ClassNode.getInterfaces&lt;/a&gt; or &lt;a href=&quot;../classnode#getAllInterfaces()&quot;&gt;ClassNode.getAllInterfaces&lt;/a&gt; are returned with generic type arguments. This method allows returning a parameterized interface given the parameterized class node which implements this interface.</source>
          <target state="translated">从&lt;a href=&quot;../classnode#getInterfaces()&quot;&gt;ClassNode.getInterfaces&lt;/a&gt;或&lt;a href=&quot;../classnode#getAllInterfaces()&quot;&gt;ClassNode.getAllInterfaces&lt;/a&gt;中检索到的接口类节点将使用泛型类型参数返回。给定实现该接口的参数化类节点，此方法允许返回参数化接口。</target>
        </trans-unit>
        <trans-unit id="2d2b3bd657d3e455e63b4f1dbaa48e1a539ac68b" translate="yes" xml:space="preserve">
          <source>Interface defining common methods for method calls.</source>
          <target state="translated">定义方法调用的常用方法的接口。</target>
        </trans-unit>
        <trans-unit id="b0550a33e5759508a1cb87c787a671cfd46f93e8" translate="yes" xml:space="preserve">
          <source>Interface for classes that complete identifier tokens within a groovy Statement (Class, variable, keyword, method, ...) Similar to JLine Completer, but adapted for usage in GroovySyntaxCompleter</source>
          <target state="translated">用于在groovy语句中完成标识符标记的类的接口(类、变量、关键字、方法......)类似于JLine Completer,但适应于GroovySyntaxCompleter的使用。</target>
        </trans-unit>
        <trans-unit id="8eee19345a1303f341fe86a44b3b1bff16e60373" translate="yes" xml:space="preserve">
          <source>Interface for classes that complete identifier tokens within a groovy Statement (Class, variable, keyword, method, ...) Similar to JLine Completor, but adapted for usage in GroovySyntaxCompletor</source>
          <target state="translated">用于在groovy语句中完成标识符标记的类的接口(类、变量、关键字、方法......)类似于JLine Completor,但适应于GroovySyntaxCompletor的使用。</target>
        </trans-unit>
        <trans-unit id="b37a6843d15d14dc949d5868c628724093b2a300" translate="yes" xml:space="preserve">
          <source>Interface for modules which are capable of resolving the type of an expression. Several implementations are available, depending on whether you are in a dynamic or static compilation mode.</source>
          <target state="translated">能够解析表达式类型的模块的接口。根据你是在动态还是静态编译模式下,有几种实现方式。</target>
        </trans-unit>
        <trans-unit id="d6e682184f1a6740708c8da252dc09b57ba9c67f" translate="yes" xml:space="preserve">
          <source>Interface for template resolvers, which, given a template identifier, return an URL where the template can be loaded.</source>
          <target state="translated">模板解析器的接口,给定一个模板标识符,返回一个可以加载模板的URL。</target>
        </trans-unit>
        <trans-unit id="60123c6e55da44275a760bd643979e93651e4d37" translate="yes" xml:space="preserve">
          <source>Interface method for ResourceContainer.</source>
          <target state="translated">ResourceContainer的接口方法。</target>
        </trans-unit>
        <trans-unit id="fb4311e90e0dc166b0e0e647d2a1608b232b2fa3" translate="yes" xml:space="preserve">
          <source>Interface method for ResourceContainer. This is used by the GroovyScriptEngine.</source>
          <target state="translated">ResourceContainer的接口方法。这是由GroovyScriptEngine使用的。</target>
        </trans-unit>
        <trans-unit id="2876141e98e65cc67dd95091b911a391f510a33f" translate="yes" xml:space="preserve">
          <source>Interface to access VM version based actions. This interface is for internal use only!</source>
          <target state="translated">用于访问基于虚拟机版本的操作的接口。此接口仅供内部使用</target>
        </trans-unit>
        <trans-unit id="579791cafbfcd6393e3192a05ca26926bd6b0bcb" translate="yes" xml:space="preserve">
          <source>Internal annotation used to indicate that a method is a bridge method to a trait default implementation.</source>
          <target state="translated">内部注解,用来表示一个方法是一个特质默认实现的桥接方法。</target>
        </trans-unit>
        <trans-unit id="c2fd45abfe2594f4e9d1291f9f433e59a95a7827" translate="yes" xml:space="preserve">
          <source>Internal annotation used to indicate which methods in a trait interface have a default implementation.</source>
          <target state="translated">内部注解,用于指示一个特质接口中的哪些方法有一个默认实现。</target>
        </trans-unit>
        <trans-unit id="b20c242f02b17111d0adc998b51f64ec5af233c3" translate="yes" xml:space="preserve">
          <source>Internal class for fast processing of Strings during JSON parsing</source>
          <target state="translated">在JSON解析过程中快速处理字符串的内部类。</target>
        </trans-unit>
        <trans-unit id="15f67d5ef1b2b2111ad63d01cef82b566d79aa92" translate="yes" xml:space="preserve">
          <source>Internal class for fast processing of Strings during JSON parsing - default version</source>
          <target state="translated">用于在JSON解析过程中快速处理Strings的内部类--默认版本。</target>
        </trans-unit>
        <trans-unit id="17bd43b68c581b9ad663869131187544604ffc26" translate="yes" xml:space="preserve">
          <source>Internal classes for Groovier Input/Output.</source>
          <target state="translated">Groovier输入/输出的内部类。</target>
        </trans-unit>
        <trans-unit id="678abdec88ee14a8aac84f1ed2283bf4c03e47a2" translate="yes" xml:space="preserve">
          <source>Internal classes for assisting with reflection.</source>
          <target state="translated">协助反省的内部班级。</target>
        </trans-unit>
        <trans-unit id="086a028ffc5b48301eaeca6a6fb1a84ca6461e66" translate="yes" xml:space="preserve">
          <source>Internal classes related to Groovy's metaclass implementation.</source>
          <target state="translated">与Groovy的元类实现相关的内部类。</target>
        </trans-unit>
        <trans-unit id="0a7b0b1753578ca410d14ddd40a3be855c75937e" translate="yes" xml:space="preserve">
          <source>Internal data structure mapping option names to their associated &lt;a href=&quot;../typedoption&quot;&gt;TypedOption&lt;/a&gt; object.</source>
          <target state="translated">内部数据结构将选项名称映射到其关联的&lt;a href=&quot;../typedoption&quot;&gt;TypedOption&lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="e69b395ac69df7a253c99003270262009c017220" translate="yes" xml:space="preserve">
          <source>Internal data structure mapping option names to their associated TypedOption object.</source>
          <target state="translated">内部数据结构将选项名称映射到其关联的TypedOption对象。</target>
        </trans-unit>
        <trans-unit id="1b873ff79602fd0c61ebe5db004502946ac92a42" translate="yes" xml:space="preserve">
          <source>Internal helper used to indicate a cache hit for a class that does not exist.</source>
          <target state="translated">内部帮助程序,用于指示一个不存在的类的缓存命中。</target>
        </trans-unit>
        <trans-unit id="27f007db952ef82246476699eef2f602fd6e7434" translate="yes" xml:space="preserve">
          <source>Internal helper used to indicate a cache hit for a class that does not exist. This way further lookups through a slow &lt;a href=&quot;#findClassNode(java.lang.String,%20org.codehaus.groovy.control.CompilationUnit)&quot;&gt;findClassNode(String, CompilationUnit)&lt;/a&gt; path can be avoided. WARNING: This class is not to be used outside of ClassNodeResolver.</source>
          <target state="translated">内部帮助程序，用于指示不存在的类的高速缓存命中。这样可以避免通过缓慢的&lt;a href=&quot;#findClassNode(java.lang.String,%20org.codehaus.groovy.control.CompilationUnit)&quot;&gt;findClassNode（String，CompilationUnit）&lt;/a&gt;路径进行进一步查找。警告：此类不得在ClassNodeResolver之外使用。</target>
        </trans-unit>
        <trans-unit id="8b12a17f5c68de50c6154bf9822d966199ba50e6" translate="yes" xml:space="preserve">
          <source>Internal method to support Groovy runtime.</source>
          <target state="translated">支持Groovy运行时的内部方法。</target>
        </trans-unit>
        <trans-unit id="3ee5e1540f58516c29ca30aff61d40136d65647f" translate="yes" xml:space="preserve">
          <source>Internal method to support Groovy runtime. Not for client usage.</source>
          <target state="translated">支持Groovy运行时的内部方法。不供客户端使用。</target>
        </trans-unit>
        <trans-unit id="6c3bad9f008c89ec54bf4b8b1f6f9424ac52451c" translate="yes" xml:space="preserve">
          <source>Internal method: Detect option specification method calls.</source>
          <target state="translated">内部方法。检测选项规格方法调用。</target>
        </trans-unit>
        <trans-unit id="d487f885c7031ddd96573dc4e771af0c5061ee07" translate="yes" xml:space="preserve">
          <source>Internal method: How to create an OptionSpec from the specification.</source>
          <target state="translated">内部方法。如何从规范中创建一个 OptionSpec。</target>
        </trans-unit>
        <trans-unit id="d01c2756261815414033ee7c1d345a7a229adf2b" translate="yes" xml:space="preserve">
          <source>Internal method: How to create an option from the specification.</source>
          <target state="translated">内部方法。如何从规范中创建一个选项。</target>
        </trans-unit>
        <trans-unit id="6610f1924bc8bb6290aa900fb2751ff511df5d97" translate="yes" xml:space="preserve">
          <source>Internal phantom type used by the &lt;code&gt;InitializerStrategy&lt;/code&gt; to indicate that a property has been set.</source>
          <target state="translated">&lt;code&gt;InitializerStrategy&lt;/code&gt; 使用的内部幻像类型指示已设置属性。</target>
        </trans-unit>
        <trans-unit id="0241f0d9f01367948a331f2c058594f9bbe99a66" translate="yes" xml:space="preserve">
          <source>Internal phantom type used by the &lt;code&gt;InitializerStrategy&lt;/code&gt; to indicate that a property has been set. It is used in conjunction with the generated parameterized type helper class.</source>
          <target state="translated">&lt;code&gt;InitializerStrategy&lt;/code&gt; 使用的内部幻像类型指示已设置属性。它与生成的参数化类型帮助器类结合使用。</target>
        </trans-unit>
        <trans-unit id="fa18545c686f7663b08f5d72ff1d01d74910941b" translate="yes" xml:space="preserve">
          <source>Internal phantom type used by the &lt;code&gt;InitializerStrategy&lt;/code&gt; to indicate that a property remains unset.</source>
          <target state="translated">&lt;code&gt;InitializerStrategy&lt;/code&gt; 使用的内部幻像类型指示属性保持未设置状态。</target>
        </trans-unit>
        <trans-unit id="8a9ef78b250c604234a17d70b3ade63aeed81d73" translate="yes" xml:space="preserve">
          <source>Internal phantom type used by the &lt;code&gt;InitializerStrategy&lt;/code&gt; to indicate that a property remains unset. It is used in conjunction with the generated parameterized type helper class.</source>
          <target state="translated">&lt;code&gt;InitializerStrategy&lt;/code&gt; 使用的内部幻像类型指示属性保持未设置状态。它与生成的参数化类型帮助器类结合使用。</target>
        </trans-unit>
        <trans-unit id="a8565dfbaacc2588737133c997d5453f79b70458" translate="yes" xml:space="preserve">
          <source>Invalid attempts to override final members</source>
          <target state="translated">覆盖最终成员的无效尝试。</target>
        </trans-unit>
        <trans-unit id="b3f05295aaa27209884b6774e0ab796cba868a55" translate="yes" xml:space="preserve">
          <source>InvocationHandler</source>
          <target state="translated">InvocationHandler</target>
        </trans-unit>
        <trans-unit id="e0e9e3e48ce64e3bb5db98882dbc294634d3d6af" translate="yes" xml:space="preserve">
          <source>InvocationHandler#invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[])</source>
          <target state="translated">InvocationHandler#invoke(java.lang.Object,java.lang.reflect.Method,java.lang.Object[])</target>
        </trans-unit>
        <trans-unit id="1b01aacb93f4e2e05ab6d459bc968160ffe794a2" translate="yes" xml:space="preserve">
          <source>InvocationHandler.invoke</source>
          <target state="translated">InvocationHandler.invoke</target>
        </trans-unit>
        <trans-unit id="1b5d6ea19b68566cefe69467c14317d9ea7ab0fa" translate="yes" xml:space="preserve">
          <source>Invoke a method (or closure in the binding) defined.</source>
          <target state="translated">调用定义的方法(或绑定中的封闭)。</target>
        </trans-unit>
        <trans-unit id="a01f8c205d54490bbc8d6e01c74d1205e4a52d5c" translate="yes" xml:space="preserve">
          <source>Invoke a method through reflection.</source>
          <target state="translated">通过反思引出一种方法。</target>
        </trans-unit>
        <trans-unit id="feb578098e3da0ffbf1b2622a6dff20dbf09d212" translate="yes" xml:space="preserve">
          <source>Invoke a method through reflection. Falls through to using the Invoker to call the method in case the reflection call fails..</source>
          <target state="translated">通过反射调用一个方法。如果反射调用失败,则通过使用Invoker调用方法。</target>
        </trans-unit>
        <trans-unit id="ad55840213cb71230d7b3cf4372abfaa4088e15c" translate="yes" xml:space="preserve">
          <source>Invoke this method</source>
          <target state="translated">调用此方法</target>
        </trans-unit>
        <trans-unit id="87c8522dff577f897b2fb84758c7717fce7e2f6d" translate="yes" xml:space="preserve">
          <source>Invoked by calling &lt;code&gt;mkp.comment&lt;/code&gt;</source>
          <target state="translated">通过调用 &lt;code&gt;mkp.comment&lt;/code&gt; 调用</target>
        </trans-unit>
        <trans-unit id="bbc360e546f1ad2be3533812128683c7aba4ba42" translate="yes" xml:space="preserve">
          <source>Invoked by calling &lt;code&gt;mkp.pi&lt;/code&gt;</source>
          <target state="translated">通过调用 &lt;code&gt;mkp.pi&lt;/code&gt; 调用</target>
        </trans-unit>
        <trans-unit id="8d737cb4dcea4dfccbe1ccf4e9f77866e6f4c6ce" translate="yes" xml:space="preserve">
          <source>Invoked by calling &lt;code&gt;mkp.xmlDeclaration&lt;/code&gt;</source>
          <target state="translated">通过调用 &lt;code&gt;mkp.xmlDeclaration&lt;/code&gt; 调用</target>
        </trans-unit>
        <trans-unit id="de1ccdd1e48ee335b763678d22decaaca881304d" translate="yes" xml:space="preserve">
          <source>Invoked by calling &lt;code&gt;mkp.yield&lt;/code&gt;.</source>
          <target state="translated">通过调用 &lt;code&gt;mkp.yield&lt;/code&gt; 调用。</target>
        </trans-unit>
        <trans-unit id="cf01423799ce850bda36d9d9a132af3d91ab8337" translate="yes" xml:space="preserve">
          <source>Invoked by calling &lt;code&gt;mkp.yield&lt;/code&gt;. Used to render text to the output stream. Any XML reserved characters will be escaped to ensure well-formedness.</source>
          <target state="translated">通过调用 &lt;code&gt;mkp.yield&lt;/code&gt; 调用。用于将文本呈现到输出流。任何XML保留字符都将转义以确保格式正确。</target>
        </trans-unit>
        <trans-unit id="620451f6d9802ea4954d01008df05584cac753ed" translate="yes" xml:space="preserve">
          <source>Invoked by calling &lt;code&gt;mkp.yieldUnescaped&lt;/code&gt;.</source>
          <target state="translated">通过调用 &lt;code&gt;mkp.yieldUnescaped&lt;/code&gt; 调用。</target>
        </trans-unit>
        <trans-unit id="f08a437d7b1d380c29159fc329e6bfa7b404b1cf" translate="yes" xml:space="preserve">
          <source>Invoked by calling &lt;code&gt;mkp.yieldUnescaped&lt;/code&gt;. Used to render literal text or markup to the output stream. No escaping is done on the output.</source>
          <target state="translated">通过调用 &lt;code&gt;mkp.yieldUnescaped&lt;/code&gt; 调用。用于将文字文本或标记呈现到输出流。没有对输出进行转义。</target>
        </trans-unit>
        <trans-unit id="17eedd25556954e9508e709deca5f965e209f486" translate="yes" xml:space="preserve">
          <source>Invoked when some of the held SoftReferences have been evicted by the garbage collector and so should be removed from the cache.</source>
          <target state="translated">当一些持有的SoftReferences已经被垃圾收集器驱逐,因此应该从缓存中移除时,调用该函数。</target>
        </trans-unit>
        <trans-unit id="250a45959d8bb6b436d04c0390b07f869e5bd151" translate="yes" xml:space="preserve">
          <source>Invoked when some of the held SoftReferences have been evicted by the garbage collector and so should be removed from the cache. The implementation must ensure that concurrent invocations of all methods on the cache may occur from other threads and thus should protect any shared resources.</source>
          <target state="translated">当一些持有的SoftReferences已经被垃圾回收器驱逐,因此应该从缓存中移除时调用。实现必须确保缓存上的所有方法的并发调用可能来自其他线程,因此应该保护任何共享资源。</target>
        </trans-unit>
        <trans-unit id="f5906ff9f6da77bf0687b834bde52a63a81638f9" translate="yes" xml:space="preserve">
          <source>Invokes a Closure that uses a Formatter taking care of resource handling.</source>
          <target state="translated">调用一个Closure,使用Formatter来处理资源。</target>
        </trans-unit>
        <trans-unit id="3e696c0b35cea8bf0aa52ba02659ae276c962aa1" translate="yes" xml:space="preserve">
          <source>Invokes a Closure that uses a Formatter taking care of resource handling. A Formatter is created and passed to the Closure as its argument. After the Closure executes, the Formatter is flushed and closed releasing any associated resources.</source>
          <target state="translated">调用一个使用Formatter处理资源的Closure。Formatter被创建并作为参数传递给Closure。在Closure执行后,Formatter被刷新并关闭,释放所有相关资源。</target>
        </trans-unit>
        <trans-unit id="3dd1860038d751c5dd53ab446b48724e469af3ba" translate="yes" xml:space="preserve">
          <source>Invokes a Closure that uses a Formatter taking care of resource handling. A Formatter is created using the given Locale and passed to the Closure as its argument. After the Closure executes, the Formatter is flushed and closed releasing any associated resources.</source>
          <target state="translated">调用一个使用Formatter处理资源的Closure。Formatter是使用给定的Locale创建的,并作为其参数传递给Closure。在Closure执行后,Formatter会被刷新并关闭,释放所有相关资源。</target>
        </trans-unit>
        <trans-unit id="9cce2eb1b481934e56e9a76e82ad8a2fa8aa2d48" translate="yes" xml:space="preserve">
          <source>Invokes a closure passing it a new Sql instance created from the given JDBC connection URL and properties.</source>
          <target state="translated">调用一个闭包,向它传递一个从给定的JDBC连接URL和属性创建的新Sql实例。</target>
        </trans-unit>
        <trans-unit id="4fff5443aec8845f0d081181901a1a6083963541" translate="yes" xml:space="preserve">
          <source>Invokes a closure passing it a new Sql instance created from the given JDBC connection URL and properties. The created connection will be closed if required.</source>
          <target state="translated">调用一个闭包,通过给定的JDBC连接URL和属性创建一个新的Sql实例。如果需要,创建的连接将被关闭。</target>
        </trans-unit>
        <trans-unit id="92e11ff0d25263520e9aa507010ae867bfa1d18b" translate="yes" xml:space="preserve">
          <source>Invokes a closure passing it a new Sql instance created from the given JDBC connection URL, properties and driver classname.</source>
          <target state="translated">调用一个闭包,向它传递一个从给定的JDBC连接URL、属性和驱动程序类名创建的新Sql实例。</target>
        </trans-unit>
        <trans-unit id="5ccec9dca12c446cbf8014bb784d6a3eeb6d59c3" translate="yes" xml:space="preserve">
          <source>Invokes a closure passing it a new Sql instance created from the given JDBC connection URL, properties and driver classname. The created connection will be closed if required.</source>
          <target state="translated">调用一个闭包,通过给定的JDBC连接URL、属性和驱动类名创建一个新的Sql实例。如果需要,创建的连接将被关闭。</target>
        </trans-unit>
        <trans-unit id="94b557171553e899ef2644e6c7de7a2309a26ad3" translate="yes" xml:space="preserve">
          <source>Invokes a closure passing it a new Sql instance created from the given JDBC connection URL, user and password.</source>
          <target state="translated">调用一个闭包,通过给定的JDBC连接URL、用户和密码创建一个新的Sql实例。</target>
        </trans-unit>
        <trans-unit id="31b625dd20e521a7eb6b106d50c48f7d55149dad" translate="yes" xml:space="preserve">
          <source>Invokes a closure passing it a new Sql instance created from the given JDBC connection URL, user and password. The created connection will be closed if required.</source>
          <target state="translated">调用一个闭包,通过给定的JDBC连接URL、用户和密码创建一个新的Sql实例。如果需要,创建的连接将被关闭。</target>
        </trans-unit>
        <trans-unit id="4c2bda0179ff1222fbb26d425b1fbf21feca66ed" translate="yes" xml:space="preserve">
          <source>Invokes a closure passing it a new Sql instance created from the given JDBC connection URL.</source>
          <target state="translated">调用一个闭包,向它传递一个从给定的JDBC连接URL创建的新Sql实例。</target>
        </trans-unit>
        <trans-unit id="f955fbf3e8d1a4f37177dba0fb1ff9c71d58ed7b" translate="yes" xml:space="preserve">
          <source>Invokes a closure passing it a new Sql instance created from the given JDBC connection URL. The created connection will be closed if required.</source>
          <target state="translated">调用一个闭包,通过给定的JDBC连接URL创建一个新的Sql实例。如果需要,创建的连接将被关闭。</target>
        </trans-unit>
        <trans-unit id="395275ffb9967a1c145b5493778159a8a6ae2ed6" translate="yes" xml:space="preserve">
          <source>Invokes a closure passing it a new Sql instance created from the given map of arguments.</source>
          <target state="translated">调用一个闭包,向它传递一个从给定的参数映射中创建的新Sql实例。</target>
        </trans-unit>
        <trans-unit id="de106f964e8b0a4a44d6e508d303a3a726d5ab83" translate="yes" xml:space="preserve">
          <source>Invokes a closure passing it a new Sql instance created from the given map of arguments. The created connection will be closed if required.</source>
          <target state="translated">调用一个闭包,通过给定的参数映射创建一个新的Sql实例。如果需要,创建的连接将被关闭。</target>
        </trans-unit>
        <trans-unit id="751ae69bb3c4a727e0a73a4377a088cfa8b7e0ed" translate="yes" xml:space="preserve">
          <source>Invokes a constructor for the given arguments.</source>
          <target state="translated">调用给定参数的构造函数。</target>
        </trans-unit>
        <trans-unit id="e869c12b4385bca09066459ddd8ffa1bbebec06b" translate="yes" xml:space="preserve">
          <source>Invokes a constructor for the given arguments. The MetaClass will attempt to pick the best argument which matches the types of the objects passed within the arguments array</source>
          <target state="translated">调用给定参数的构造函数。MetaClass将尝试选择与参数数组中传递的对象类型相匹配的最佳参数。</target>
        </trans-unit>
        <trans-unit id="31bd129052b70e1eb10388ae68cb416dfc1bb5d8" translate="yes" xml:space="preserve">
          <source>Invokes a handle produced by #getInvokeSpecialdHandle</source>
          <target state="translated">调用由#getInvokeSpecialdHandle产生的句柄。</target>
        </trans-unit>
        <trans-unit id="b869776d247c322cafc82c46a70f683ef453ef90" translate="yes" xml:space="preserve">
          <source>Invokes a method for the GroovyResultSet.</source>
          <target state="translated">调用GroovyResultSet的方法。</target>
        </trans-unit>
        <trans-unit id="131b75064d3bbc248839e654bafb0f5fe086a67d" translate="yes" xml:space="preserve">
          <source>Invokes a method for the GroovyResultSet. This will try to invoke the given method first on the extension and then on the result set given as proxy parameter.</source>
          <target state="translated">调用GroovyResultSet的方法。该方法将首先在扩展上调用给定的方法,然后在作为代理参数的结果集上调用。</target>
        </trans-unit>
        <trans-unit id="4536aeb0a0e4240d65c9a5c7f7d2e6e38a9d4116" translate="yes" xml:space="preserve">
          <source>Invokes a method on the given Object with the given name and arguments.</source>
          <target state="translated">在给定的对象上调用一个具有给定名称和参数的方法。</target>
        </trans-unit>
        <trans-unit id="eecc05dda5aa85d3bdeed2fd2f004c3e5f847cef" translate="yes" xml:space="preserve">
          <source>Invokes a method on the given Object with the given name and arguments. The MetaClass will attempt to pick the best method for the given name and arguments. If a method cannot be invoked a MissingMethodException will be thrown.</source>
          <target state="translated">在给定的对象上调用一个具有给定名称和参数的方法。MetaClass将尝试为给定的名称和参数选择最佳的方法,如果一个方法不能被调用,将抛出MissingMethodException。如果一个方法不能被调用,将抛出MissingMethodException。</target>
        </trans-unit>
        <trans-unit id="f3610230cdefc7f8df225464429b3a3302de5686" translate="yes" xml:space="preserve">
          <source>Invokes a method on the given object, with the given name and single argument.</source>
          <target state="translated">调用给定对象的方法,使用给定的名称和单个参数。</target>
        </trans-unit>
        <trans-unit id="f56c8023197c89da7dc5515bc1561d796a979161" translate="yes" xml:space="preserve">
          <source>Invokes a method on the given receiver for the specified arguments. The sender is the class that invoked the method on the object. The MetaClass will attempt to establish the method to invoke based on the name and arguments provided.</source>
          <target state="translated">为指定的参数在给定的接收器上调用一个方法。发送方是在对象上调用方法的类,MetaClass将根据提供的名称和参数尝试建立要调用的方法。MetaClass将尝试根据所提供的名称和参数建立要调用的方法。</target>
        </trans-unit>
        <trans-unit id="e15f12f58d6467c0d2e5025e2e555da17217b48d" translate="yes" xml:space="preserve">
          <source>Invokes a static method on the given Object with the given name and arguments.</source>
          <target state="translated">用给定的名称和参数在给定的对象上调用一个静态方法。</target>
        </trans-unit>
        <trans-unit id="45eef663687ac9d0041d8a7df5794bb9d664ad85" translate="yes" xml:space="preserve">
          <source>Invokes the closure for each 'child' file in this 'parent' folder/directory.</source>
          <target state="translated">调用该 &quot;父 &quot;文件夹/目录中每个 &quot;子 &quot;文件的关闭。</target>
        </trans-unit>
        <trans-unit id="fbc16179b33b27a2d59f2c7081939cd62610db4e" translate="yes" xml:space="preserve">
          <source>Invokes the closure for each 'child' file in this 'parent' folder/directory. Both regular files and subfolders/subdirectories are processed.</source>
          <target state="translated">调用该 &quot;父 &quot;文件夹/目录中每个 &quot;子 &quot;文件的关闭。常规文件和子文件夹/子目录都会被处理。</target>
        </trans-unit>
        <trans-unit id="91ad5cf347256d0e340502c93ff3e64c59174d52" translate="yes" xml:space="preserve">
          <source>Invokes the closure for each 'child' file in this 'parent' folder/directory. Both regular files and subfolders/subdirectories can be processed depending on the fileType enum value.</source>
          <target state="translated">调用该 &quot;父 &quot;文件夹/目录中每个 &quot;子 &quot;文件的关闭。根据fileType枚举值,普通文件和子文件夹/子目录都可以被处理。</target>
        </trans-unit>
        <trans-unit id="54c59ab9c10a30c72e6e450ba2ba3b7308898998" translate="yes" xml:space="preserve">
          <source>Invokes the closure for each file whose name (file.name) matches the given nameFilter in the given directory - calling the &lt;a href=&quot;../../../../codehaus/groovy/runtime/defaultgroovymethods#isCase(Object,%20Object)&quot;&gt;DefaultGroovyMethods.isCase&lt;/a&gt; method to determine if a match occurs.</source>
          <target state="translated">为每个名称（file.name）与给定目录中的给定nameFilter匹配的文件调用闭包-调用&lt;a href=&quot;../../../../codehaus/groovy/runtime/defaultgroovymethods#isCase(Object,%20Object)&quot;&gt;DefaultGroovyMethods.isCase&lt;/a&gt;方法以确定是否发生匹配。</target>
        </trans-unit>
        <trans-unit id="84d4e7cf060e5e75c1053d46d6e6d3dd2ff5f06b" translate="yes" xml:space="preserve">
          <source>Invokes the closure for each file whose name (file.name) matches the given nameFilter in the given directory - calling the &lt;a href=&quot;../../../../codehaus/groovy/runtime/defaultgroovymethods#isCase(Object,%20Object)&quot;&gt;DefaultGroovyMethods.isCase&lt;/a&gt; method to determine if a match occurs. This method can be used with different kinds of filters like regular expressions, classes, ranges etc. Both regular files and subdirectories are matched.</source>
          <target state="translated">为每个名称（file.name）与给定目录中的给定nameFilter匹配的文件调用闭包-调用&lt;a href=&quot;../../../../codehaus/groovy/runtime/defaultgroovymethods#isCase(Object,%20Object)&quot;&gt;DefaultGroovyMethods.isCase&lt;/a&gt;方法以确定是否发生匹配。此方法可以与不同类型的过滤器一起使用，例如正则表达式，类，范围等。正则文件和子目录都匹配。</target>
        </trans-unit>
        <trans-unit id="ea09e6ac983b8f6254c3e7d2be64c1a519311368" translate="yes" xml:space="preserve">
          <source>Invokes the closure for each file whose name (file.name) matches the given nameFilter in the given directory - calling the &lt;a href=&quot;../../../../codehaus/groovy/runtime/defaultgroovymethods#isCase(Object,%20Object)&quot;&gt;DefaultGroovyMethods.isCase&lt;/a&gt; method to determine if a match occurs. This method can be used with different kinds of filters like regular expressions, classes, ranges etc. Both regular files and subdirectories may be candidates for matching depending on the value of fileType.</source>
          <target state="translated">为每个名称（file.name）与给定目录中的给定nameFilter匹配的文件调用闭包-调用&lt;a href=&quot;../../../../codehaus/groovy/runtime/defaultgroovymethods#isCase(Object,%20Object)&quot;&gt;DefaultGroovyMethods.isCase&lt;/a&gt;方法以确定是否发生匹配。此方法可以与正则表达式，类，范围等不同类型的过滤器一起使用。取决于fileType的值，正则文件和子目录都可以作为匹配的候选对象。</target>
        </trans-unit>
        <trans-unit id="538f5d9f69fbfe9fb4894172854e85f6d95fd4ca" translate="yes" xml:space="preserve">
          <source>Invokes the closure for each file whose name (file.name) matches the given nameFilter in the given directory - calling the &lt;a href=&quot;defaultgroovymethods#isCase(Object,%20Object)&quot;&gt;DefaultGroovyMethods.isCase&lt;/a&gt; method to determine if a match occurs.</source>
          <target state="translated">为每个名称（file.name）与给定目录中的给定nameFilter匹配的文件调用闭包-调用&lt;a href=&quot;defaultgroovymethods#isCase(Object,%20Object)&quot;&gt;DefaultGroovyMethods.isCase&lt;/a&gt;方法以确定是否发生匹配。</target>
        </trans-unit>
        <trans-unit id="ebd83da05db26da4f03fa7aa86ede89d76304a9c" translate="yes" xml:space="preserve">
          <source>Invokes the closure for each file whose name (file.name) matches the given nameFilter in the given directory - calling the &lt;a href=&quot;defaultgroovymethods#isCase(Object,%20Object)&quot;&gt;DefaultGroovyMethods.isCase&lt;/a&gt; method to determine if a match occurs. This method can be used with different kinds of filters like regular expressions, classes, ranges etc. Both regular files and subdirectories are matched.</source>
          <target state="translated">为每个名称（file.name）与给定目录中的给定nameFilter匹配的文件调用闭包-调用&lt;a href=&quot;defaultgroovymethods#isCase(Object,%20Object)&quot;&gt;DefaultGroovyMethods.isCase&lt;/a&gt;方法以确定是否发生匹配。此方法可以与不同类型的过滤器一起使用，例如正则表达式，类，范围等。正则文件和子目录都匹配。</target>
        </trans-unit>
        <trans-unit id="3dd1718dd885eda866406dcd448c8fe56fdd4157" translate="yes" xml:space="preserve">
          <source>Invokes the closure for each file whose name (file.name) matches the given nameFilter in the given directory - calling the &lt;a href=&quot;defaultgroovymethods#isCase(Object,%20Object)&quot;&gt;DefaultGroovyMethods.isCase&lt;/a&gt; method to determine if a match occurs. This method can be used with different kinds of filters like regular expressions, classes, ranges etc. Both regular files and subdirectories may be candidates for matching depending on the value of fileType.</source>
          <target state="translated">为每个名称（file.name）与给定目录中的给定nameFilter匹配的文件调用闭包-调用&lt;a href=&quot;defaultgroovymethods#isCase(Object,%20Object)&quot;&gt;DefaultGroovyMethods.isCase&lt;/a&gt;方法以确定是否发生匹配。此方法可以与正则表达式，类，范围等不同类型的过滤器一起使用。取决于fileType的值，正则文件和子目录都可以作为匹配的候选对象。</target>
        </trans-unit>
        <trans-unit id="12a49c0c1df5dc8d98463707bb0dabb1bb99c4a5" translate="yes" xml:space="preserve">
          <source>Invokes the closure for each file whose name (file.name) matches the given nameFilter in the given directory - calling the &lt;a href=&quot;defaultgroovymethods#isCase(java.lang.Object,%20java.lang.Object)&quot;&gt;DefaultGroovyMethods.isCase&lt;/a&gt; method to determine if a match occurs.</source>
          <target state="translated">为每个名称（file.name）与给定目录中的给定nameFilter匹配的文件调用闭包-调用&lt;a href=&quot;defaultgroovymethods#isCase(java.lang.Object,%20java.lang.Object)&quot;&gt;DefaultGroovyMethods.isCase&lt;/a&gt;方法以确定是否发生匹配。</target>
        </trans-unit>
        <trans-unit id="a5566b1f45b69cb7cf3eb6a2c5f60572270eaccd" translate="yes" xml:space="preserve">
          <source>Invokes the closure for each file whose name (file.name) matches the given nameFilter in the given directory - calling the &lt;a href=&quot;defaultgroovymethods#isCase(java.lang.Object,%20java.lang.Object)&quot;&gt;DefaultGroovyMethods.isCase&lt;/a&gt; method to determine if a match occurs. This method can be used with different kinds of filters like regular expressions, classes, ranges etc. Both regular files and subdirectories are matched.</source>
          <target state="translated">为每个名称（file.name）与给定目录中的给定nameFilter匹配的文件调用闭包-调用&lt;a href=&quot;defaultgroovymethods#isCase(java.lang.Object,%20java.lang.Object)&quot;&gt;DefaultGroovyMethods.isCase&lt;/a&gt;方法以确定是否发生匹配。此方法可以与不同类型的过滤器一起使用，例如正则表达式，类，范围等。正则文件和子目录都匹配。</target>
        </trans-unit>
        <trans-unit id="78253573a5ba0033fd11eaa72b690f99eb2be821" translate="yes" xml:space="preserve">
          <source>Invokes the closure for each file whose name (file.name) matches the given nameFilter in the given directory - calling the &lt;a href=&quot;defaultgroovymethods#isCase(java.lang.Object,%20java.lang.Object)&quot;&gt;DefaultGroovyMethods.isCase&lt;/a&gt; method to determine if a match occurs. This method can be used with different kinds of filters like regular expressions, classes, ranges etc. Both regular files and subdirectories may be candidates for matching depending on the value of fileType.</source>
          <target state="translated">为每个名称（file.name）与给定目录中的给定nameFilter匹配的文件调用闭包-调用&lt;a href=&quot;defaultgroovymethods#isCase(java.lang.Object,%20java.lang.Object)&quot;&gt;DefaultGroovyMethods.isCase&lt;/a&gt;方法以确定是否发生匹配。此方法可以与正则表达式，类，范围等不同类型的过滤器一起使用。取决于fileType的值，正则文件和子目录都可以作为匹配的候选对象。</target>
        </trans-unit>
        <trans-unit id="0eefd49616ba93ed49495f1ed1baa92128411910" translate="yes" xml:space="preserve">
          <source>Invokes the closure for each subdirectory in this directory, ignoring regular files.</source>
          <target state="translated">调用该目录中每个子目录的关闭,忽略常规文件。</target>
        </trans-unit>
        <trans-unit id="eadda88ea7e4ba8993a63f2a13684720b0176da3" translate="yes" xml:space="preserve">
          <source>Invokes the closure for each subdirectory whose name (dir.name) matches the given nameFilter in the given directory - calling the &lt;a href=&quot;defaultgroovymethods#isCase(java.lang.Object,%20java.lang.Object)&quot;&gt;DefaultGroovyMethods.isCase&lt;/a&gt; method to determine if a match occurs.</source>
          <target state="translated">为每个名称（dir.name）与给定目录中的给定nameFilter匹配的子目录调用闭包-调用&lt;a href=&quot;defaultgroovymethods#isCase(java.lang.Object,%20java.lang.Object)&quot;&gt;DefaultGroovyMethods.isCase&lt;/a&gt;方法以确定是否发生匹配。</target>
        </trans-unit>
        <trans-unit id="5780c5a1ab042cc566cd280f5a47a3954176171c" translate="yes" xml:space="preserve">
          <source>Invokes the closure for each subdirectory whose name (dir.name) matches the given nameFilter in the given directory - calling the &lt;a href=&quot;defaultgroovymethods#isCase(java.lang.Object,%20java.lang.Object)&quot;&gt;DefaultGroovyMethods.isCase&lt;/a&gt; method to determine if a match occurs. This method can be used with different kinds of filters like regular expressions, classes, ranges etc. Only subdirectories are matched; regular files are ignored.</source>
          <target state="translated">为每个名称（dir.name）与给定目录中的给定nameFilter匹配的子目录调用闭包-调用&lt;a href=&quot;defaultgroovymethods#isCase(java.lang.Object,%20java.lang.Object)&quot;&gt;DefaultGroovyMethods.isCase&lt;/a&gt;方法以确定是否发生匹配。该方法可以与不同类型的过滤器一起使用，例如正则表达式，类，范围等。常规文件将被忽略。</target>
        </trans-unit>
        <trans-unit id="8cb60a5ecea6112c8f9a8853a4908f93069305a8" translate="yes" xml:space="preserve">
          <source>Invokes the closure for each subdirectory whose name (dir.name) matches the given nameFilter in the given directory - calling the DefaultGroovyMethods#isCase(java.lang.Object, java.lang.Object) method to determine if a match occurs.</source>
          <target state="translated">对给定目录中名称(dir.name)与给定nameFilter匹配的每个子目录调用闭包--调用DefaultGroovyMethods#isCase(java.lang.Object,java.lang.Object)方法来确定是否发生匹配。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
