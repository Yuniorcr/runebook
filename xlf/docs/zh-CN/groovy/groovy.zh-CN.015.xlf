<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="groovy">
    <body>
      <group id="groovy">
        <trans-unit id="fe589363e4ac259adc89164a4b30d2637d7f2bd4" translate="yes" xml:space="preserve">
          <source>Subclasses may override this method to provide a custom engine.</source>
          <target state="translated">子类可以重写这个方法来提供一个自定义的引擎。</target>
        </trans-unit>
        <trans-unit id="8e4429e4082fc721ed49174a4f731ca437e45c64" translate="yes" xml:space="preserve">
          <source>Subclasses of Enum</source>
          <target state="translated">Enum的子类</target>
        </trans-unit>
        <trans-unit id="2a8000e224c8f10020019ec44e2314b8edeb0829" translate="yes" xml:space="preserve">
          <source>Subclasses should implement this method if they need to perform additional checks after the type checker has finished its work.</source>
          <target state="translated">如果子类在类型检查器完成工作后需要执行额外的检查,就应该实现这个方法。</target>
        </trans-unit>
        <trans-unit id="241010c606b0131238cd4b19c9eaa38d72946400" translate="yes" xml:space="preserve">
          <source>Subclasses should implement this method if they need to perform additional checks after the type checker has finished its work. This is particularly useful for situations where you need multiple passes. Some checks in that case may be deferred to the end, using this method.</source>
          <target state="translated">如果子类在类型检查器完成工作后还需要执行额外的检查,就应该实现这个方法。这对于需要多次传递的情况特别有用。在这种情况下,一些检查可能会被推迟到最后,使用这个方法。</target>
        </trans-unit>
        <trans-unit id="4e8a758e14e042fd44d1644b7c03d56755c84835" translate="yes" xml:space="preserve">
          <source>Subclasses should implement this method to provide good error resolution.</source>
          <target state="translated">子类应该实现这个方法来提供良好的错误解决方法。</target>
        </trans-unit>
        <trans-unit id="48a548d0b5d2d73bb19fdf6f69c4cddfc9e8f4c9" translate="yes" xml:space="preserve">
          <source>Subclasses should implement this method to set the condition of the interruption statement</source>
          <target state="translated">子类应该实现这个方法来设置中断语句的条件</target>
        </trans-unit>
        <trans-unit id="32ab562220ed81620ccefa3948d1a774f1feaa20" translate="yes" xml:space="preserve">
          <source>Subclasses should implement this method whenever they need to perform special checks before the type checker starts working.</source>
          <target state="translated">每当子类需要在类型检查器开始工作之前执行特殊检查时,都应该实现这个方法。</target>
        </trans-unit>
        <trans-unit id="c68b5b9b049084fab1d00a3f47d9b682f70fb6da" translate="yes" xml:space="preserve">
          <source>Subclasses should implement this method, which returns the list of accepted closure signatures.</source>
          <target state="translated">子类应该实现这个方法,该方法返回接受的关闭签名列表。</target>
        </trans-unit>
        <trans-unit id="fa849d16a1883f2b020174ca4e3bb9a8a963f828" translate="yes" xml:space="preserve">
          <source>Subtract a Character from a Number.</source>
          <target state="translated">从一个数字中减去一个字符。</target>
        </trans-unit>
        <trans-unit id="7d501390aa64bdf2c9ae78827d17293277d1d079" translate="yes" xml:space="preserve">
          <source>Subtract a Character from a Number. The ordinal value of the Character is used in the subtraction (the ordinal value is the unicode value which for simple character sets is the ASCII value).</source>
          <target state="translated">从一个数字中减去一个字符。在减法中使用字符的序数值(序数值是unicode值,对于简单的字符集是ASCII值)。</target>
        </trans-unit>
        <trans-unit id="80739b5b536f0252ee4bb49d1cf80dec2291730b" translate="yes" xml:space="preserve">
          <source>Subtract a Number from a Character.</source>
          <target state="translated">从一个字符中减去一个数字。</target>
        </trans-unit>
        <trans-unit id="2829709b208cdecbc2effaee1c43f216d0c4a2cd" translate="yes" xml:space="preserve">
          <source>Subtract a Number from a Character. The ordinal value of the Character is used in the subtraction (the ordinal value is the unicode value which for simple character sets is the ASCII value).</source>
          <target state="translated">从一个字符中减去一个数字。在减法中使用字符的序数值(序数值是unicode值,对于简单的字符集是ASCII值)。</target>
        </trans-unit>
        <trans-unit id="383c4da009f675500b7dc7ae0296938c1e09b8bf" translate="yes" xml:space="preserve">
          <source>Subtract a number of days from this Timestamp and returns the new Timestamp object.</source>
          <target state="translated">从该时间戳中减去天数,并返回新的时间戳对象。</target>
        </trans-unit>
        <trans-unit id="73d746887164b2f5e92e086f6b38e7a5028ad395" translate="yes" xml:space="preserve">
          <source>Subtract a number of days from this date and returns the new date.</source>
          <target state="translated">从该日期中减去若干天数,并返回新的日期。</target>
        </trans-unit>
        <trans-unit id="d1b908a2b53a9eda97aea98291d46913fec1a195" translate="yes" xml:space="preserve">
          <source>Subtract another Date from this one and return the number of days of the difference.</source>
          <target state="translated">从这个日期中减去另一个日期,并返回差额的天数。</target>
        </trans-unit>
        <trans-unit id="90df6944beb186ade6e01024eae5a9be3b4868ce" translate="yes" xml:space="preserve">
          <source>Subtract another date from this one and return the number of days of the difference.</source>
          <target state="translated">从这个日期中减去另一个日期,并返回差额的天数。</target>
        </trans-unit>
        <trans-unit id="b1d58f1e1cf47da6c54dce03b400e8ead47438d0" translate="yes" xml:space="preserve">
          <source>Subtract one Character from another.</source>
          <target state="translated">从一个字符减去另一个字符。</target>
        </trans-unit>
        <trans-unit id="670e4318f1084845e7f32b29745478fef01a079c" translate="yes" xml:space="preserve">
          <source>Subtract one Character from another. The ordinal values of the Characters is used in the comparison (the ordinal value is the unicode value which for simple character sets is the ASCII value).</source>
          <target state="translated">从一个字符减去另一个字符。比较时使用字符的序数值(序数值是unicode值,对于简单的字符集是ASCII值)。</target>
        </trans-unit>
        <trans-unit id="8458189362e1f0efadb179882bea2588a89dea40" translate="yes" xml:space="preserve">
          <source>Subtract one date from the other.</source>
          <target state="translated">从一个日期减去另一个日期。</target>
        </trans-unit>
        <trans-unit id="703b3f4be66eeba14f12112eb0178f45c56b038b" translate="yes" xml:space="preserve">
          <source>Subtraction of two Numbers.</source>
          <target state="translated">两个数字的减法。</target>
        </trans-unit>
        <trans-unit id="ea77f38e191237c8467b9bbbbfa7a3c905eb071f" translate="yes" xml:space="preserve">
          <source>Successful retrievals using get(key) and containsKey(key) usually run without locking. Unsuccessful ones (i.e., when the key is not present) do involve brief synchronization (locking). Also, the size and isEmpty methods are always synchronized.</source>
          <target state="translated">使用get(key)和containsKey(key)的成功检索通常不会锁定。不成功的检索(例如,当key不存在时)确实涉及到短暂的同步(锁定)。另外,size和isEmpty方法总是同步的。</target>
        </trans-unit>
        <trans-unit id="31de501c849ff7913e8233a72f933ee4b40759b9" translate="yes" xml:space="preserve">
          <source>Sums all the given items.</source>
          <target state="translated">将所有给定项目相加。</target>
        </trans-unit>
        <trans-unit id="a6906f65d4bdfb623c3779437b880666d674473e" translate="yes" xml:space="preserve">
          <source>Sums all the items from an array of items.</source>
          <target state="translated">将所有项目从一个项目数组中求和。</target>
        </trans-unit>
        <trans-unit id="4b759da08d81e2982b18ab18cfecdb92173bfcad" translate="yes" xml:space="preserve">
          <source>Sums the items from an Iterator, adding the result to some initial value.</source>
          <target state="translated">对一个迭代器中的项目进行求和,将结果加到某个初始值上。</target>
        </trans-unit>
        <trans-unit id="3292936c4cef8a406dd185feb7f5e9f5ad4bb035" translate="yes" xml:space="preserve">
          <source>Sums the items from an Iterator, adding the result to some initial value. This is equivalent to invoking the &quot;plus&quot; method on all items from the Iterator. The iterator will become exhausted of elements after determining the sum value.</source>
          <target state="translated">对迭代器中的项目进行求和,将结果加到某个初始值上。这相当于对迭代器中的所有项目调用 &quot;加 &quot;方法。在确定和值后,迭代器中的元素将耗尽。</target>
        </trans-unit>
        <trans-unit id="44a8d4cb71f1a9055409cd78474fa859d6e1b627" translate="yes" xml:space="preserve">
          <source>Sums the items from an Iterator.</source>
          <target state="translated">对一个迭代器中的项目进行求和。</target>
        </trans-unit>
        <trans-unit id="7b0828ab8c0d5a6291096701a8058ed787770aa4" translate="yes" xml:space="preserve">
          <source>Sums the items from an Iterator. This is equivalent to invoking the &quot;plus&quot; method on all items from the Iterator. The iterator will become exhausted of elements after determining the sum value.</source>
          <target state="translated">对一个迭代器中的项目进行求和。这相当于对迭代器中的所有项目调用 &quot;加 &quot;方法。在确定和值后,迭代器中的元素将耗尽。</target>
        </trans-unit>
        <trans-unit id="0f21ed49c9b3729a874e6b6213a3aec5f55f4984" translate="yes" xml:space="preserve">
          <source>Sums the items in an Iterable, adding the result to some initial value.</source>
          <target state="translated">对一个Iterable中的项目进行求和,将结果加到某个初始值上。</target>
        </trans-unit>
        <trans-unit id="938cc031c32a0a74fedcea0fa2ea03bca7774e36" translate="yes" xml:space="preserve">
          <source>Sums the items in an Iterable.</source>
          <target state="translated">对Iterable中的项目进行求和。</target>
        </trans-unit>
        <trans-unit id="05846c3dab4dc24635cdc7e83333eed6761385f2" translate="yes" xml:space="preserve">
          <source>Sums the items in an Iterable. This is equivalent to invoking the &quot;plus&quot; method on all items in the Iterable.</source>
          <target state="translated">对Iterable中的项目进行求和。这相当于在Iterable中的所有项目上调用 &quot;plus &quot;方法。</target>
        </trans-unit>
        <trans-unit id="5f97a9c084454b475824ce176a76670de5bc0260" translate="yes" xml:space="preserve">
          <source>Sums the items in an array, adding the result to some initial value.</source>
          <target state="translated">对一个数组中的项目进行求和,将结果加到某个初始值上。</target>
        </trans-unit>
        <trans-unit id="8e6bc758df7e10d60725d5fd562f4cb6320501f3" translate="yes" xml:space="preserve">
          <source>Sums the items in an array.</source>
          <target state="translated">对一个数组中的项目进行求和。</target>
        </trans-unit>
        <trans-unit id="f12f8dae3d9539e78ab7a3595c0ec92646ea4e58" translate="yes" xml:space="preserve">
          <source>Sums the items in an array. This is equivalent to invoking the &quot;plus&quot; method on all items in the array.</source>
          <target state="translated">对数组中的项目进行求和。这相当于对数组中的所有项目调用 &quot;加 &quot;方法。</target>
        </trans-unit>
        <trans-unit id="ef7fec05c6f7a205563842bf6c760293ede2e021" translate="yes" xml:space="preserve">
          <source>Sums the result of applying a closure to each item of an Iterable to some initial value.</source>
          <target state="translated">将一个Iterable的每个项目的闭包结果求和到某个初始值。</target>
        </trans-unit>
        <trans-unit id="2c34756e7df8dbbbdc5ad7ddd3d79525b4cabde0" translate="yes" xml:space="preserve">
          <source>Sums the result of applying a closure to each item of an Iterable to some initial value. &lt;code&gt;iter.sum(initVal, closure)&lt;/code&gt; is equivalent to: &lt;code&gt;iter.collect(closure).sum(initVal)&lt;/code&gt;.</source>
          <target state="translated">将对Iterable的每个项目应用闭包的结果汇总为某个初始值。 &lt;code&gt;iter.sum(initVal, closure)&lt;/code&gt; 等效于： &lt;code&gt;iter.collect(closure).sum(initVal)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a22f8d5b1e322146f614b91be417a32eb8dcd5b5" translate="yes" xml:space="preserve">
          <source>Sums the result of applying a closure to each item of an Iterable.</source>
          <target state="translated">对一个Iterable的每个项目进行闭包的结果求和。</target>
        </trans-unit>
        <trans-unit id="a9cded5e8db4a11cbc31f73eebe70a9d23e9f6e6" translate="yes" xml:space="preserve">
          <source>Sums the result of applying a closure to each item of an Iterable. &lt;code&gt;coll.sum(closure)&lt;/code&gt; is equivalent to: &lt;code&gt;coll.collect(closure).sum()&lt;/code&gt;.</source>
          <target state="translated">总结对Iterable的每个项目应用闭包的结果。 &lt;code&gt;coll.sum(closure)&lt;/code&gt; 等效于： &lt;code&gt;coll.collect(closure).sum()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a2d6eeefd666db6fd3abb4f06450eaebc3703a21" translate="yes" xml:space="preserve">
          <source>Sums the result of applying a closure to each item of an Iterator to some initial value.</source>
          <target state="translated">将一个Iterator的每个项目的闭包结果求和到某个初始值。</target>
        </trans-unit>
        <trans-unit id="138bf57a714ba157c5f8f2140c7144fec48bbd4d" translate="yes" xml:space="preserve">
          <source>Sums the result of applying a closure to each item of an Iterator to some initial value. &lt;code&gt;iter.sum(initVal, closure)&lt;/code&gt; is equivalent to: &lt;code&gt;iter.collect(closure).sum(initVal)&lt;/code&gt;. The iterator will become exhausted of elements after determining the sum value.</source>
          <target state="translated">将对一个迭代器的每个项目应用闭包的结果汇总为某个初始值。 &lt;code&gt;iter.sum(initVal, closure)&lt;/code&gt; 等效于： &lt;code&gt;iter.collect(closure).sum(initVal)&lt;/code&gt; 。确定总和后，迭代器将耗尽元素。</target>
        </trans-unit>
        <trans-unit id="c0cb69a7faef35e6438266153f8981b96cdb6d92" translate="yes" xml:space="preserve">
          <source>Sums the result of applying a closure to each item of an array to some initial value.</source>
          <target state="translated">将一个数组中的每个项目的闭包结果求和到某个初始值。</target>
        </trans-unit>
        <trans-unit id="45852392f7090c69aedbeec4ac994c8caed08176" translate="yes" xml:space="preserve">
          <source>Sums the result of applying a closure to each item of an array to some initial value. &lt;code&gt;array.sum(initVal, closure)&lt;/code&gt; is equivalent to: &lt;code&gt;array.collect(closure).sum(initVal)&lt;/code&gt;.</source>
          <target state="translated">将对数组的每个项目应用闭包的结果汇总为某个初始值。 &lt;code&gt;array.sum(initVal, closure)&lt;/code&gt; 等效于： &lt;code&gt;array.collect(closure).sum(initVal)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="46427b8197456a69d06f32a8b3afb429409c9174" translate="yes" xml:space="preserve">
          <source>Sums the result of applying a closure to each item of an array.</source>
          <target state="translated">对数组中的每个项目进行封闭求和。</target>
        </trans-unit>
        <trans-unit id="b46103f8e5006bdeea7f9c154e982c8ee536abd8" translate="yes" xml:space="preserve">
          <source>Sums the result of applying a closure to each item of an array. &lt;code&gt;array.sum(closure)&lt;/code&gt; is equivalent to: &lt;code&gt;array.collect(closure).sum()&lt;/code&gt;.</source>
          <target state="translated">总结对数组的每个项目应用闭包的结果。 &lt;code&gt;array.sum(closure)&lt;/code&gt; 等效于： &lt;code&gt;array.collect(closure).sum()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dac66fb8810c157cd97e770e86c48d44f88a2152" translate="yes" xml:space="preserve">
          <source>Sums the result of applying a closure to each item returned from an iterator.</source>
          <target state="translated">对迭代器返回的每个项目应用闭包的结果进行求和。</target>
        </trans-unit>
        <trans-unit id="377052f5b33eac246887eb27e6c100d565eca611" translate="yes" xml:space="preserve">
          <source>Sums the result of applying a closure to each item returned from an iterator. &lt;code&gt;iter.sum(closure)&lt;/code&gt; is equivalent to: &lt;code&gt;iter.collect(closure).sum()&lt;/code&gt;. The iterator will become exhausted of elements after determining the sum value.</source>
          <target state="translated">对对迭代器返回的每个项目应用闭包的求和结果。 &lt;code&gt;iter.sum(closure)&lt;/code&gt; 等效于： &lt;code&gt;iter.collect(closure).sum()&lt;/code&gt; 。确定总和后，迭代器将耗尽元素。</target>
        </trans-unit>
        <trans-unit id="998c35057b1e937535f109c7111919f1f21ea66a" translate="yes" xml:space="preserve">
          <source>Support a 'least surprising' math model to scripting language users. This means that exact, or decimal math should be used for default calculations. This scheme assumes that by default, groovy literals with decimal points are instantiated as BigDecimal objects rather than binary floating points (Float, Double).</source>
          <target state="translated">支持脚本语言用户的 &quot;最小惊喜 &quot;数学模型。这意味着在默认的计算中应该使用精确的,或十进制数学。这个方案假设默认情况下,带有小数点的groovy字元被实例化为BigDecimal对象,而不是二进制浮点数(Float,Double)。</target>
        </trans-unit>
        <trans-unit id="300e75d2f3f2ad069bf75f6db0f8b032d657028b" translate="yes" xml:space="preserve">
          <source>Support assigning a range of values with a single assignment statement.</source>
          <target state="translated">支持用一个赋值语句赋值一个范围的值。</target>
        </trans-unit>
        <trans-unit id="eb0573add916ac521520ae7e1a7edb406cc686a3" translate="yes" xml:space="preserve">
          <source>Support class for creating XML Factories</source>
          <target state="translated">支持创建XML Factories的类</target>
        </trans-unit>
        <trans-unit id="a0ac0e736b440225051252fb545f21a87af58be3" translate="yes" xml:space="preserve">
          <source>Support creating a new Date having similar properties to an existing Date (which remains unaltered) but with some fields updated according to a Map of changes.</source>
          <target state="translated">支持创建一个新的Date,其属性与现有的Date相似(现有的Date保持不变),但部分字段根据变化的地图进行更新。</target>
        </trans-unit>
        <trans-unit id="578fcb6595097c58dd9c3c70598121040321a782" translate="yes" xml:space="preserve">
          <source>Support for &lt;a href=&quot;command&quot;&gt;Command&lt;/a&gt; instances.</source>
          <target state="translated">支持&lt;a href=&quot;command&quot;&gt;命令&lt;/a&gt;实例。</target>
        </trans-unit>
        <trans-unit id="27e429f7d79185fd5fa7dcfde4e209338be3fe84" translate="yes" xml:space="preserve">
          <source>Support for Closure &quot;right&quot; currying.</source>
          <target state="translated">支持Closure &quot;对 &quot;咖 。</target>
        </trans-unit>
        <trans-unit id="bd9aff9c96085971df147f0319c92592cb9998b5" translate="yes" xml:space="preserve">
          <source>Support for Closure &quot;right&quot; currying. Parameters are supplied on the right rather than left as per the normal curry() method. Typical usage:</source>
          <target state="translated">支持Closure &quot;右侧 &quot;咖喱。按照正常的curry()方法,参数是在右边而不是左边提供的。典型用法。</target>
        </trans-unit>
        <trans-unit id="07d27c73edc627e408cf52788f3cd8c2cee9798e" translate="yes" xml:space="preserve">
          <source>Support for Closure currying at a given index.</source>
          <target state="translated">支持在给定指数下的Closure Currying。</target>
        </trans-unit>
        <trans-unit id="77c240308ae9d403e4fdeb9fade24bf133f052c6" translate="yes" xml:space="preserve">
          <source>Support for Closure currying at a given index. Parameters are supplied from index position &quot;n&quot;. Typical usage:</source>
          <target state="translated">在给定的索引上支持Closure Currying。参数从索引位置 &quot;n &quot;开始提供。典型用法。</target>
        </trans-unit>
        <trans-unit id="86fbafb2c6a6ef08ae544def5ecd2f5d1a459fde" translate="yes" xml:space="preserve">
          <source>Support for Closure currying.</source>
          <target state="translated">支持Closure咖 。</target>
        </trans-unit>
        <trans-unit id="b6701c883c98ccd374b2032b56f3cdf62e6bdcb1" translate="yes" xml:space="preserve">
          <source>Support for Closure forward composition.</source>
          <target state="translated">支持Closure前行构成。</target>
        </trans-unit>
        <trans-unit id="95c9b5d31f5a9af4bcb77590911799ff25e785f9" translate="yes" xml:space="preserve">
          <source>Support for Closure reverse composition.</source>
          <target state="translated">支持Closure反向构成。</target>
        </trans-unit>
        <trans-unit id="0cd464c7aa84c67ca4cf28f95af944bd7e5c8ae1" translate="yes" xml:space="preserve">
          <source>Support for Groovlets which are Servlets written as a simple Groovy script.</source>
          <target state="translated">支持Groovlets,它是以简单的Groovy脚本编写的Servlet。</target>
        </trans-unit>
        <trans-unit id="971f277b26127bb2b96f438a43258b36036a9c6e" translate="yes" xml:space="preserve">
          <source>Support for compilation related tasks.</source>
          <target state="translated">支持编译相关任务。</target>
        </trans-unit>
        <trans-unit id="2712721bdf08058a3c0b6d90d89d52194d9c6991" translate="yes" xml:space="preserve">
          <source>Support for more complex commands.</source>
          <target state="translated">支持更复杂的命令。</target>
        </trans-unit>
        <trans-unit id="c398c8c180a493660e7da708b15d770393473fcc" translate="yes" xml:space="preserve">
          <source>Support for running a &lt;a href=&quot;shell&quot;&gt;Shell&lt;/a&gt; interactively using the JLine library.</source>
          <target state="translated">支持使用JLine库以交互方式运行&lt;a href=&quot;shell&quot;&gt;Shell&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e7bd721822c04eca7566037be0ea0c447ce0bb1f" translate="yes" xml:space="preserve">
          <source>Support for running a &lt;a href=&quot;shell&quot;&gt;Shell&lt;/a&gt;.</source>
          <target state="translated">支持运行&lt;a href=&quot;shell&quot;&gt;Shell&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e838211f110950da21190e2b4cd394331c2cfaad" translate="yes" xml:space="preserve">
          <source>Support for simple completers.</source>
          <target state="translated">支持简单的完成人。</target>
        </trans-unit>
        <trans-unit id="b1847ef28b474109bae86b9ff6f88f30c6d1cb1e" translate="yes" xml:space="preserve">
          <source>Support for simple completors.</source>
          <target state="translated">支持简单的完成人。</target>
        </trans-unit>
        <trans-unit id="a4cd4262c16597d35c917b71e4dacdb860118533" translate="yes" xml:space="preserve">
          <source>Support methods for &lt;a href=&quot;statictypecheckingvisitor&quot;&gt;StaticTypeCheckingVisitor&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;statictypecheckingvisitor&quot;&gt;StaticTypeCheckingVisitor的&lt;/a&gt;支持方法。</target>
        </trans-unit>
        <trans-unit id="b334e44ba370eeb1a9fcce805d296237600394b7" translate="yes" xml:space="preserve">
          <source>Support methods for DefaultGroovyMethods and PluginDefaultMethods.</source>
          <target state="translated">支持DefaultGroovyMethods和PluginDefaultMethods的方法。</target>
        </trans-unit>
        <trans-unit id="40274db933b81a98b5c697affa7d5c7f16fa92d3" translate="yes" xml:space="preserve">
          <source>Support methods for Groovy category usage</source>
          <target state="translated">支持Groovy类别使用方法</target>
        </trans-unit>
        <trans-unit id="588dfb8cd9cca2180f8096de40629699cecfce75" translate="yes" xml:space="preserve">
          <source>Support mutating a Calendar with a Map.</source>
          <target state="translated">支持用地图变异日历。</target>
        </trans-unit>
        <trans-unit id="606b6da19d3862e2b1d54033b51c6a674ad9524f" translate="yes" xml:space="preserve">
          <source>Support mutating a Date with a Map.</source>
          <target state="translated">支持用地图突变一个日期。</target>
        </trans-unit>
        <trans-unit id="0065fbb73dfe423e4f2b0b788b77b810d1895bf4" translate="yes" xml:space="preserve">
          <source>Support retrieving a subset of a BitSet using a Range</source>
          <target state="translated">支持使用Range检索一个BitSet的子集。</target>
        </trans-unit>
        <trans-unit id="cefe376baa46053e6ee5cd1185a7ec7bd5de75a2" translate="yes" xml:space="preserve">
          <source>Support subscript operator for list access.</source>
          <target state="translated">支持列表访问的下标运算符。</target>
        </trans-unit>
        <trans-unit id="0ce8c0aa36043dde1f96ca757bfc9ca258b03f47" translate="yes" xml:space="preserve">
          <source>Support subscript operator for list modification.</source>
          <target state="translated">支持下标操作符进行列表修改。</target>
        </trans-unit>
        <trans-unit id="948555c5f9bb59c7e564313dae8e9e5e33359ef5" translate="yes" xml:space="preserve">
          <source>Support subscript-style assignment for a BitSet.</source>
          <target state="translated">支持BitSet的下标式赋值。</target>
        </trans-unit>
        <trans-unit id="277c0c9a0992135998848b12d1623638750f1db0" translate="yes" xml:space="preserve">
          <source>Support the range subscript operator for StringBuilder.</source>
          <target state="translated">支持StringBuilder的范围下标运算符。</target>
        </trans-unit>
        <trans-unit id="09c4c0a5e355d7aa584752cfc33a252f0a73e60e" translate="yes" xml:space="preserve">
          <source>Support the range subscript operator for StringBuilder. Index values are treated as characters within the builder.</source>
          <target state="translated">支持StringBuilder的范围下标操作符。索引值在构建器中被视为字符。</target>
        </trans-unit>
        <trans-unit id="acd26eb8b1a16f0820319830f663499ae85c68f8" translate="yes" xml:space="preserve">
          <source>Support the range subscript operator for a List.</source>
          <target state="translated">支持List的范围下标运算符。</target>
        </trans-unit>
        <trans-unit id="930099686e74d43336ccb036b84c0e5da6eec9e3" translate="yes" xml:space="preserve">
          <source>Support the range subscript operator for an Array</source>
          <target state="translated">支持阵列的范围下标运算符</target>
        </trans-unit>
        <trans-unit id="b999effc2096576e1c862e817448092036970953" translate="yes" xml:space="preserve">
          <source>Support the range subscript operator for an eager or lazy List.</source>
          <target state="translated">支持急切或懒惰的List的范围下标操作符。</target>
        </trans-unit>
        <trans-unit id="8024a4e87a055ac0bfbf3a79248d3db4e937f9ff" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for ButtonGroup.</source>
          <target state="translated">支持ButtonGroup的下标操作。</target>
        </trans-unit>
        <trans-unit id="8883233fb47d8a916e31ae51ad0682c85c140a3e" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for Collection.</source>
          <target state="translated">支持收藏的下标运算符。</target>
        </trans-unit>
        <trans-unit id="137e043d5266d133be830bee498a61305b08656b" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for Container.</source>
          <target state="translated">支持容器的下标操作符。</target>
        </trans-unit>
        <trans-unit id="07b736f7865baa83c1f6bc649704d426a52a785a" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for JComboBox.</source>
          <target state="translated">支持JComboBox的下标操作符。</target>
        </trans-unit>
        <trans-unit id="31a8136fdf49a95aaa951ea4ed67ec07e9acc80a" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for JMenu.</source>
          <target state="translated">支持JMenu的下标运算符。</target>
        </trans-unit>
        <trans-unit id="a6bfb46585e8e0eabd4032848ef55c15306e4cd5" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for JMenuBar.</source>
          <target state="translated">支持JMenuBar的下标操作。</target>
        </trans-unit>
        <trans-unit id="a0c882c6cd60c5c1b40d2bd576e5c94a555b1c4a" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for JTabbedPane.</source>
          <target state="translated">支持JTabbedPane的下标操作。</target>
        </trans-unit>
        <trans-unit id="67f5eb23bb29271d8db04f6cc3958a10877bd86b" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for JToolBar.</source>
          <target state="translated">支持JToolBar的下标操作符。</target>
        </trans-unit>
        <trans-unit id="3edb03f1dbd6dbc567ef944a1323b4462a95935b" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for ListModel.</source>
          <target state="translated">支持ListModel的下标操作符。</target>
        </trans-unit>
        <trans-unit id="d2b5237de01694410633b548a0f924fa610af129" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for TableColumnModel.</source>
          <target state="translated">支持TableColumnModel的下标操作符。</target>
        </trans-unit>
        <trans-unit id="f26d8833306b343dfe6bb5e4ffca867bd20aad7e" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for TableModel.</source>
          <target state="translated">支持TableModel的下标运算符。</target>
        </trans-unit>
        <trans-unit id="f63e2cb744c1c451ecc2c5de29107932d57249e8" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for TreeNode.</source>
          <target state="translated">支持TreeNode的下标操作符。</target>
        </trans-unit>
        <trans-unit id="46b3703b70c5b77bb85b2a093946ef0c0693b3c5" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for TreePath.</source>
          <target state="translated">支持TreePath的下标操作符。</target>
        </trans-unit>
        <trans-unit id="82ca1dcdc1480532f560c6be7abbec186ccf6ee7" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for a Bitset</source>
          <target state="translated">支持Bitset的下标运算符。</target>
        </trans-unit>
        <trans-unit id="a337c06c56778b26331f5a920f766882be3b0493" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for a Calendar.</source>
          <target state="translated">支持日历的下标运算符。</target>
        </trans-unit>
        <trans-unit id="77f7a0636dc8671f55b6f4130764c09c166c7835" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for a Date.</source>
          <target state="translated">支持Date的下标运算符。</target>
        </trans-unit>
        <trans-unit id="b96b77d4e05609bf5ebac837d1ea604f4bd48580" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for a List.</source>
          <target state="translated">支持列表的下标运算符。</target>
        </trans-unit>
        <trans-unit id="18104f39e920408c5dbd3d2de4a52926a170a585" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for a Map.</source>
          <target state="translated">支持地图的下标运算符。</target>
        </trans-unit>
        <trans-unit id="b7d5a370e14d88ca3b733df074745e512491e1b8" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for an Iterable.</source>
          <target state="translated">支持Iterable的下标操作符。</target>
        </trans-unit>
        <trans-unit id="da54421b2475020061b3a47e604a37ada578e23a" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for an Iterable. Typical usage:</source>
          <target state="translated">支持Iterable的下标操作符。典型用法。</target>
        </trans-unit>
        <trans-unit id="b136f29e517965b9fab5e959f6e4c99faa02cbad" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for an Iterator.</source>
          <target state="translated">支持迭代器的下标操作符。</target>
        </trans-unit>
        <trans-unit id="712e012634442f739e8d9439273ee6c5469514b8" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for an Iterator. The iterator will be partially exhausted up until the idx entry after returning if a +ve or 0 idx is used, or fully exhausted if a -ve idx is used or no corresponding entry was found. Typical usage:</source>
          <target state="translated">支持迭代器的下标操作符。如果使用了+ve或0的idx,迭代器将部分耗尽,直到返回后的idx条目,如果使用了-ve的idx或没有找到相应的条目,则完全耗尽。典型的用法。</target>
        </trans-unit>
        <trans-unit id="05e1c675a16d28913679eb9bf33a6f3849996840" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for mutating a Calendar.</source>
          <target state="translated">支持下标操作符来突变一个日历。</target>
        </trans-unit>
        <trans-unit id="e3005a57b2f65de8b8ee3c9e383470c171c93a51" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for mutating a Calendar. Example usage:</source>
          <target state="translated">支持用下标操作符对日历进行突变。使用示例。</target>
        </trans-unit>
        <trans-unit id="0832f9dcf462ade3391f384e44f33f1d4a5d9801" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for mutating a Date.</source>
          <target state="translated">支持下标操作符,用于突变日期。</target>
        </trans-unit>
        <trans-unit id="dcdaffd8f1f395b917d10a9f7899c51471d965d2" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a collection for a boolean array</source>
          <target state="translated">支持布尔数组的下标操作符与集合。</target>
        </trans-unit>
        <trans-unit id="38960d85e9835053606b584f60047fc89487b81f" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a collection for a byte array</source>
          <target state="translated">支持下标操作符与字节数组的集合。</target>
        </trans-unit>
        <trans-unit id="bfdd8cbe5169c3fba3ea647b156633a848266f23" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a collection for a char array</source>
          <target state="translated">支持带集合的下标操作符,用于字符数组。</target>
        </trans-unit>
        <trans-unit id="90742627dc6eb2f9b4d8227c151fad8d57423b85" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a collection for a double array</source>
          <target state="translated">支持下标操作符与双数组的集合。</target>
        </trans-unit>
        <trans-unit id="39150a8bf39dcd107e1c51ddc573ad89d6269053" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a collection for a float array</source>
          <target state="translated">支持下标操作符与浮动数组的集合。</target>
        </trans-unit>
        <trans-unit id="4e129074b798751ecffc90e0fd782beeab070ad2" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a collection for a long array</source>
          <target state="translated">支持长数组的下标操作符与集合。</target>
        </trans-unit>
        <trans-unit id="7d242b1c1771299e2b79691a29aaefc7f993eb38" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a collection for a short array</source>
          <target state="translated">支持下标操作符与短数组的集合。</target>
        </trans-unit>
        <trans-unit id="449fc6a9aae0653fc2a2dd933669712b98794a67" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a collection for an int array</source>
          <target state="translated">支持下标操作符与一个int数组的集合。</target>
        </trans-unit>
        <trans-unit id="406c3c4313afad025dc0f000a9d36af8c01ef6dc" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a range for a boolean array</source>
          <target state="translated">支持布尔数组的下标运算符与范围。</target>
        </trans-unit>
        <trans-unit id="eb5575ed4428458ede0b0ffe18053e0022f2c8b6" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a range for a byte array</source>
          <target state="translated">支持下标运算符,对字节数组进行范围运算</target>
        </trans-unit>
        <trans-unit id="e061d0f5fcf78a949d304e48051b333e3509a09b" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a range for a char array</source>
          <target state="translated">支持带范围的下标操作符,用于字符数组。</target>
        </trans-unit>
        <trans-unit id="d56f743158eb5c5d9a114b722ab2b8aa764c4884" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a range for a double array</source>
          <target state="translated">支持双数组的下标运算符与范围。</target>
        </trans-unit>
        <trans-unit id="dc6bb5f77572817a5a2d27996636a61f948630a5" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a range for a float array</source>
          <target state="translated">支持浮动数组的下标运算符与范围。</target>
        </trans-unit>
        <trans-unit id="ad8c10b070d78470ed959ae01f3a4b6165c06ea0" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a range for a long array</source>
          <target state="translated">支持长数组的下标运算符与范围。</target>
        </trans-unit>
        <trans-unit id="ee52af5b564b8bd5b211088bca646f5f8706167a" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a range for a short array</source>
          <target state="translated">支持短数组的下标操作符与范围。</target>
        </trans-unit>
        <trans-unit id="1fae014c47830c0263f0c70591acd2cb75401882" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a range for an int array</source>
          <target state="translated">支持对一个int数组进行下标操作,并提供一个范围。</target>
        </trans-unit>
        <trans-unit id="51b1c738fc5421c1900cbcf82f77be491419f636" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with an IntRange for a boolean array</source>
          <target state="translated">支持布尔数组的下标操作符与IntRange。</target>
        </trans-unit>
        <trans-unit id="737a9dafe198558df1a051d1b235f28a914614a9" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with an IntRange for a byte array</source>
          <target state="translated">支持用IntRange操作符对字节数组进行下标操作。</target>
        </trans-unit>
        <trans-unit id="b2e85416ac1bef6482c8defff54899a74c630bad" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with an IntRange for a char array</source>
          <target state="translated">支持用IntRange操作符对char数组进行下标操作。</target>
        </trans-unit>
        <trans-unit id="308844e7ffcdb4e852e6200501bf93b50edd1146" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with an IntRange for a double array</source>
          <target state="translated">支持双数组的下标运算符与IntRange。</target>
        </trans-unit>
        <trans-unit id="e8172d0a1db9a00b56b31db2555af86194397bdf" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with an IntRange for a float array</source>
          <target state="translated">支持用IntRange操作符对浮动数组进行下标操作。</target>
        </trans-unit>
        <trans-unit id="1d9f1a77baa8f3f7c7be70b2868cc3da8cbd873b" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with an IntRange for a long array</source>
          <target state="translated">支持长数组的下标操作符与IntRange。</target>
        </trans-unit>
        <trans-unit id="846540f6464f33fa68fb5a18a1bdda484d94be1a" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with an IntRange for a short array</source>
          <target state="translated">支持短数组的下标操作符与IntRange。</target>
        </trans-unit>
        <trans-unit id="86d49e4722c5856590c8457389b79e367a48336b" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with an IntRange for an int array</source>
          <target state="translated">支持用IntRange操作符对一个int数组进行下标操作。</target>
        </trans-unit>
        <trans-unit id="135d071ce0e747dd6c86c1f1ea6ff0bd031e49c8" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with an ObjectRange for a byte array</source>
          <target state="translated">支持用ObjectRange操作符对字节数组进行下标操作。</target>
        </trans-unit>
        <trans-unit id="494432a9314d4c872a0569f09c6de99b5dacc87a" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with an ObjectRange for a char array</source>
          <target state="translated">支持用ObjectRange操作符对char数组进行下标操作。</target>
        </trans-unit>
        <trans-unit id="2efca516ac0e519470608b925ed538b8fb748e45" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with an ObjectRange for a double array</source>
          <target state="translated">支持在双数组中使用ObjectRange的下标运算符。</target>
        </trans-unit>
        <trans-unit id="a688426210c62de688f8dcf07f4c2ab964d91970" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with an ObjectRange for a float array</source>
          <target state="translated">支持在浮动数组中使用ObjectRange的下标运算符。</target>
        </trans-unit>
        <trans-unit id="2ee30662b569f7f70c6b555a7b4769ca93dd7017" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with an ObjectRange for a long array</source>
          <target state="translated">支持长数组的ObjectRange的下标运算符。</target>
        </trans-unit>
        <trans-unit id="92bb07165d787ba1a31571dfaf457860dd156cc3" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with an ObjectRange for a short array</source>
          <target state="translated">支持在短数组中使用ObjectRange的下标操作符。</target>
        </trans-unit>
        <trans-unit id="0d8f69636a462dfdae8f77c74465fe081dcc0144" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with an ObjectRange for an int array</source>
          <target state="translated">支持对一个int数组用ObjectRange进行下标操作。</target>
        </trans-unit>
        <trans-unit id="e81c22dfff611d4ce5af5cc7d3ba8e087782c019" translate="yes" xml:space="preserve">
          <source>Supported syntax:</source>
          <target state="translated">支持的语法:</target>
        </trans-unit>
        <trans-unit id="29082ca330fc6abf963f95d250bbb9faa7ada8ea" translate="yes" xml:space="preserve">
          <source>Supports integer based subscript operators for accessing at numbered columns starting at zero.</source>
          <target state="translated">支持基于整数的下标操作符,用于访问从零开始的数字列。</target>
        </trans-unit>
        <trans-unit id="685b4ee9fceb194e1bba657c003c3d9058d640a0" translate="yes" xml:space="preserve">
          <source>Supports integer based subscript operators for accessing at numbered columns starting at zero. Negative indices are supported, they will count from the last column backwards.</source>
          <target state="translated">支持基于整数的下标操作符,用于访问从零开始的数字列。支持负指数,它们将从最后一列开始向后计算。</target>
        </trans-unit>
        <trans-unit id="d8a1dffb79c3a58bf51ad444252e384308031a1f" translate="yes" xml:space="preserve">
          <source>Supports integer based subscript operators for updating the values of numbered columns starting at zero.</source>
          <target state="translated">支持基于整数的下标运算符,用于更新从零开始的数字列的值。</target>
        </trans-unit>
        <trans-unit id="b9040372ef64134ed11c8ca3980f52a75c335178" translate="yes" xml:space="preserve">
          <source>Supports integer based subscript operators for updating the values of numbered columns starting at zero. Negative indices are supported, they will count from the last column backwards.</source>
          <target state="translated">支持基于整数的下标运算符,用于更新从零开始的数字列的值。支持负指数,它们将从最后一列开始向后计算。</target>
        </trans-unit>
        <trans-unit id="e121e3a40b35411dcbf80ace25a2cab09c6a9d81" translate="yes" xml:space="preserve">
          <source>Supports integer-based subscript operators for accessing at numbered columns starting at zero.</source>
          <target state="translated">支持基于整数的下标运算符,用于访问从零开始的数字列。</target>
        </trans-unit>
        <trans-unit id="6650b1b6bbaec3d498660928194e1e004714a8ee" translate="yes" xml:space="preserve">
          <source>Supports integer-based subscript operators for accessing at numbered columns starting at zero. Negative indices are supported, they will count from the last column backwards.</source>
          <target state="translated">支持基于整数的下标操作符,用于访问从零开始的数字列。支持负指数,它们将从最后一列开始向后计算。</target>
        </trans-unit>
        <trans-unit id="f6892c78c1164bf275bea2cf843d7c79de2a8d05" translate="yes" xml:space="preserve">
          <source>Supports only the five basic XML entities (gt, lt, quot, amp, apos)</source>
          <target state="translated">只支持五个基本的XML实体(gt、lt、quot、amp、apos)。</target>
        </trans-unit>
        <trans-unit id="272482f4c74fef3dcf775ef6e04d38a838b4eddf" translate="yes" xml:space="preserve">
          <source>Supports the division operator; equivalent to calling the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html#dividedBy(long)&quot;&gt;Duration.dividedBy&lt;/a&gt; method.</source>
          <target state="translated">支持部门运营商；等效于调用&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html#dividedBy(long)&quot;&gt;Duration.dividedBy&lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="6e3256613e913c27b4d30572865fb8f14dba9d45" translate="yes" xml:space="preserve">
          <source>Supports the getAt operator; equivalent to calling the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/ZoneOffset.html#getLong(java.time.temporal.TemporalField)&quot;&gt;ZoneOffset.getLong&lt;/a&gt; method.</source>
          <target state="translated">支持getAt运算符；等效于调用&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/ZoneOffset.html#getLong(java.time.temporal.TemporalField)&quot;&gt;ZoneOffset.getLong&lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="3d1b992b51a3b320adfa7435877250915682a88b" translate="yes" xml:space="preserve">
          <source>Supports the getAt operator; equivalent to calling the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalAccessor.html#getLong(java.time.temporal.TemporalField)&quot;&gt;TemporalAccessor.getLong&lt;/a&gt; method.</source>
          <target state="translated">支持getAt运算符；等效于调用&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalAccessor.html#getLong(java.time.temporal.TemporalField)&quot;&gt;TemporalAccessor.getLong&lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="45b564a7490c0cfc9ab37fb49992105cbdffd741" translate="yes" xml:space="preserve">
          <source>Supports the getAt operator; equivalent to calling the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalAmount.html#get(TemporalUnit)&quot;&gt;TemporalAmount.get&lt;/a&gt; method.</source>
          <target state="translated">支持getAt运算符；等效于调用&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalAmount.html#get(TemporalUnit)&quot;&gt;TemporalAmount.get&lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="9fbf8412864ed83f47c19fb2de0ad38b4c2d88bb" translate="yes" xml:space="preserve">
          <source>Supports the multiplication operator; equivalent to calling the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html#multipliedBy(long)&quot;&gt;Duration.multipliedBy&lt;/a&gt; method.</source>
          <target state="translated">支持乘法运算符；等效于调用&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html#multipliedBy(long)&quot;&gt;Duration.multipliedBy&lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="9c58b6034a8cda0cb4caab3bc1a085313bf5131d" translate="yes" xml:space="preserve">
          <source>Supports the multiply operator; equivalent to calling the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/Period.html#multipliedBy(int)&quot;&gt;Period.multipliedBy&lt;/a&gt; method.</source>
          <target state="translated">支持乘法运算符；等效于调用&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/Period.html#multipliedBy(int)&quot;&gt;Period.multipliedBy&lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="1f12770c32aa35e5994877bee4b25b602e3e93f3" translate="yes" xml:space="preserve">
          <source>Supports the range subscript operator for CharSequence or StringBuffer with EmptyRange</source>
          <target state="translated">支持CharSequence或StringBuffer的EmptyRange的范围下标操作符。</target>
        </trans-unit>
        <trans-unit id="c2d8232579b8962a2f78045b849d8783bfeba70b" translate="yes" xml:space="preserve">
          <source>Supports the range subscript operator for CharSequence with IntRange.</source>
          <target state="translated">支持带有IntRange的CharSequence的范围下标操作符。</target>
        </trans-unit>
        <trans-unit id="734ac83eea03aa14f6f645cbb62c57d5ebc7a7cb" translate="yes" xml:space="preserve">
          <source>Supports the range subscript operator for CharSequence.</source>
          <target state="translated">支持CharSequence的范围下标运算符。</target>
        </trans-unit>
        <trans-unit id="1c17ccd565eec637aeb61b93388e26907f417969" translate="yes" xml:space="preserve">
          <source>Supports the range subscript operator for GString with IntRange.</source>
          <target state="translated">支持使用IntRange的GString的范围下标操作符。</target>
        </trans-unit>
        <trans-unit id="2de30284c9a0e8fcec0804002be4e2ae2ec22240" translate="yes" xml:space="preserve">
          <source>Supports the range subscript operator for GString.</source>
          <target state="translated">支持GString的范围下标运算符。</target>
        </trans-unit>
        <trans-unit id="c21234956f0cebc724e038773b6489ec986cabd2" translate="yes" xml:space="preserve">
          <source>Supports the range subscript operator for String with IntRange.</source>
          <target state="translated">支持IntRange字符串的范围下标运算符。</target>
        </trans-unit>
        <trans-unit id="30590a771f8986708ccb6659f99345ce35751d79" translate="yes" xml:space="preserve">
          <source>Supports the range subscript operator for String.</source>
          <target state="translated">支持字符串的范围下标运算符。</target>
        </trans-unit>
        <trans-unit id="87567806977a560b8169c7b6d539bc7ee1adcfbc" translate="yes" xml:space="preserve">
          <source>Supports the range subscript operator for StringBuffer.</source>
          <target state="translated">支持StringBuffer的范围下标操作符。</target>
        </trans-unit>
        <trans-unit id="e5b5e33b1e927360d37b9e7aff1c489178f6ab28" translate="yes" xml:space="preserve">
          <source>Supports the range subscript operator for StringBuffer. Index values are treated as characters within the buffer.</source>
          <target state="translated">支持StringBuffer的范围下标操作符。索引值被视为缓冲区内的字符。</target>
        </trans-unit>
        <trans-unit id="603e946fa86fe6630cb7e4e41deba0896a06b13b" translate="yes" xml:space="preserve">
          <source>Supports the range subscript operator for StringBuilder.</source>
          <target state="translated">支持StringBuilder的范围下标操作符。</target>
        </trans-unit>
        <trans-unit id="76f1d48bcdcf4c5ad55799e7efb5332d2c727357" translate="yes" xml:space="preserve">
          <source>Supports the range subscript operator for StringBuilder. Index values are treated as characters within the builder.</source>
          <target state="translated">支持StringBuilder的范围下标操作符。索引值在构建器中被视为字符。</target>
        </trans-unit>
        <trans-unit id="b3868e5ccdf1c52b1bcae61cb67a1658a621b670" translate="yes" xml:space="preserve">
          <source>Supports the range subscript operator for a GPathResult.</source>
          <target state="translated">支持GPathResult的范围下标运算符。</target>
        </trans-unit>
        <trans-unit id="847373efea045010884a5921e02aeb3939071729" translate="yes" xml:space="preserve">
          <source>Supports the subscript operator for CharSequence.</source>
          <target state="translated">支持CharSequence的下标运算符。</target>
        </trans-unit>
        <trans-unit id="643bb4275fc8f901b11dbe657ab42dacee233538" translate="yes" xml:space="preserve">
          <source>Supports the subscript operator for GString.</source>
          <target state="translated">支持GString的下标运算符。</target>
        </trans-unit>
        <trans-unit id="c14c15e33602a664d9d6717e5a114f93eff3f995" translate="yes" xml:space="preserve">
          <source>Supports the subscript operator for String.</source>
          <target state="translated">支持字符串的下标运算符。</target>
        </trans-unit>
        <trans-unit id="1eeaf121a846e73418ed8bb3f658e4d50c2b1ac6" translate="yes" xml:space="preserve">
          <source>Supports the subscript operator for a GPathResult.</source>
          <target state="translated">支持GPathResult的下标操作符。</target>
        </trans-unit>
        <trans-unit id="a5e7d8728bc31a020c837e7346295444cfb639ed" translate="yes" xml:space="preserve">
          <source>Supports the subscript operator, e.g.</source>
          <target state="translated">支持下标运算符,如</target>
        </trans-unit>
        <trans-unit id="63d6e6526a6efcf42b637b3fee8333d2c42dfe8a" translate="yes" xml:space="preserve">
          <source>Supports the subscript operator, e.g. &lt;code&gt;matcher[index]&lt;/code&gt;, for a &lt;code&gt;Matcher&lt;/code&gt;.</source>
          <target state="translated">支持标操作符，例如 &lt;code&gt;matcher[index]&lt;/code&gt; ，对于 &lt;code&gt;Matcher&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b24a8e67655e2d3680c8d291f8d695bc52b8deef" translate="yes" xml:space="preserve">
          <source>Supports the unary minus operator; equivalent to calling the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html#negated()&quot;&gt;Duration.negated&lt;/a&gt; method.</source>
          <target state="translated">支持一元减号运算符；等效于调用&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html#negated()&quot;&gt;Duration.negated&lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="ef16973534d92d25c8ba950c50ef216e3d129c99" translate="yes" xml:space="preserve">
          <source>Supports the unary minus operator; equivalent to calling the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/Period.html#negated()&quot;&gt;Period.negated&lt;/a&gt; method.</source>
          <target state="translated">支持一元减号运算符；等效于调用&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/Period.html#negated()&quot;&gt;Period.negated&lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="ca1984ff7448bd1530fcb00a669677ddf234ba06" translate="yes" xml:space="preserve">
          <source>Supports the unary plus operator; equivalent to calling the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html#abs()&quot;&gt;Duration.abs&lt;/a&gt; method.</source>
          <target state="translated">支持一元加运算符；等效于调用&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html#abs()&quot;&gt;Duration.abs&lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="9671c499c2b0eccb12ed3d9fb0e71ffb8f89feef" translate="yes" xml:space="preserve">
          <source>Supports the unary plus operator; returns a &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/Period.html&quot;&gt;Period&lt;/a&gt; with all unit values positive.</source>
          <target state="translated">支持一元加运算符；返回一个&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/Period.html&quot;&gt;周期&lt;/a&gt;，所有单位值为正。</target>
        </trans-unit>
        <trans-unit id="f2b3726eac67d7b17290df48a691ab6648c417ac" translate="yes" xml:space="preserve">
          <source>Supports the unary plus operator; returns a &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/Period.html&quot;&gt;Period&lt;/a&gt; with all unit values positive. For example, a period of &quot;2 years, -3 months, and -4 days&quot; would result in a period of &quot;2 years, 3 months, and 4 days.&quot; No normalization is performed.</source>
          <target state="translated">支持一元加运算符；返回一个&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/Period.html&quot;&gt;周期&lt;/a&gt;，所有单位值为正。例如，期限为&amp;ldquo; 2年，-3个月和-4天&amp;rdquo;将导致期限为&amp;ldquo; 2年，3个月和4天&amp;rdquo;。不执行标准化。</target>
        </trans-unit>
        <trans-unit id="444b203ece3ce0e7f35d5c0aef68426d9b0d431c" translate="yes" xml:space="preserve">
          <source>Swaps two elements at the specified positions.</source>
          <target state="translated">在指定位置交换两个元素。</target>
        </trans-unit>
        <trans-unit id="11d786b4e23376ea3dc79c4c0a88541bba21feca" translate="yes" xml:space="preserve">
          <source>Swing application to graphically display the tokens produced by the lexer.</source>
          <target state="translated">Swing应用程序,以图形化的方式显示词典产生的标记。</target>
        </trans-unit>
        <trans-unit id="a505d05672b9c632c10baf50232815e236897342" translate="yes" xml:space="preserve">
          <source>SwingBuilder helper classes for creating components</source>
          <target state="translated">用于创建组件的SwingBuilder帮助类</target>
        </trans-unit>
        <trans-unit id="b4d5fef0fd56423d2005b5f23fc72bafc05788b9" translate="yes" xml:space="preserve">
          <source>Switches the builder's proxyBuilder during the execution of a closure.</source>
          <target state="translated">在执行闭包的过程中,切换Builder的proxyBuilder。</target>
        </trans-unit>
        <trans-unit id="1d654f8f369be41ce70e791e599030be1914b8e6" translate="yes" xml:space="preserve">
          <source>Synonym for &lt;a href=&quot;#toSpreadMap(java.util.Map)&quot;&gt;toSpreadMap(java.util.Map)&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#toSpreadMap(java.util.Map)&quot;&gt;toSpreadMap（java.util.Map）的&lt;/a&gt;同义词。</target>
        </trans-unit>
        <trans-unit id="8bf9b65aa3eb7662090be9b911189d54f126ea4c" translate="yes" xml:space="preserve">
          <source>Synonym for &lt;code&gt;compile(Phases.ALL)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;compile(Phases.ALL)&lt;/code&gt; 同义词。</target>
        </trans-unit>
        <trans-unit id="f7e7d4ec9c98e022a28f28595845ab382d8e7b30" translate="yes" xml:space="preserve">
          <source>Synonym for full compilation</source>
          <target state="translated">全面汇编的同义词</target>
        </trans-unit>
        <trans-unit id="922c2e5f4ef255d4058e512453e827f08ec07983" translate="yes" xml:space="preserve">
          <source>Synonym for write(text) allowing file.text = 'foo'.</source>
          <target state="translated">write(text)的同义词,允许file.text='foo'。</target>
        </trans-unit>
        <trans-unit id="c6f6827d49ab5f403cdd18485a48da06676e323d" translate="yes" xml:space="preserve">
          <source>Synonym for write(text, charset) allowing:</source>
          <target state="translated">write(text,charset)允许的同义词。</target>
        </trans-unit>
        <trans-unit id="38259ff21e4eb435a46c701dcdd29b24d58b4a78" translate="yes" xml:space="preserve">
          <source>Syntax supported:</source>
          <target state="translated">支持的语法。</target>
        </trans-unit>
        <trans-unit id="1de8dba368e7754dc199c99b017f5c51265ee8dc" translate="yes" xml:space="preserve">
          <source>Syntax:</source>
          <target state="translated">Syntax:</target>
        </trans-unit>
        <trans-unit id="92f3ec2c7d54e41b31652ea8927f4cb0fe0d53b2" translate="yes" xml:space="preserve">
          <source>SyntaxErrorReportable</source>
          <target state="translated">SyntaxErrorReportable</target>
        </trans-unit>
        <trans-unit id="989982c92d7d7b069cc494d871290c6c79dd1bea" translate="yes" xml:space="preserve">
          <source>System.currentTimeMillis</source>
          <target state="translated">System.currentTimeMillis</target>
        </trans-unit>
        <trans-unit id="52f9440d82aa136e8330aac61d5581f83dc6cf89" translate="yes" xml:space="preserve">
          <source>Systematically generate permutations. Adapted from Java Code by Michael Gilleland (released with no restrictions) using an algorithm described here: Kenneth H. Rosen, Discrete Mathematics and Its Applications, 2nd edition (NY: McGraw-Hill, 1991), pp. 282-284</source>
          <target state="translated">系统地生成排列组合。改编自Michael Gilleland的Java代码(无限制发布),使用这里描述的算法。Kenneth H.Rosen,Discrete Mathematics and Its Applications,2nd edition (NY:McGraw-Hill,1991),pp.282-284</target>
        </trans-unit>
        <trans-unit id="dab1fd1e591a63e3e5e200ee8fa3c5a14d2c00db" translate="yes" xml:space="preserve">
          <source>T foo(){}</source>
          <target state="translated">T foo(){}</target>
        </trans-unit>
        <trans-unit id="8fe6d0b31eb59e6ac337f0b92f98cb3ad502463c" translate="yes" xml:space="preserve">
          <source>TODO Get list of groovydoc tags</source>
          <target state="translated">TODO 获取groovydoc标签列表</target>
        </trans-unit>
        <trans-unit id="921b6844ab03e31995729bfc75953f8eac7378a3" translate="yes" xml:space="preserve">
          <source>TODO parse groovydoc to get tag content</source>
          <target state="translated">TODO解析groovydoc以获得标签内容。</target>
        </trans-unit>
        <trans-unit id="a4ba86ffe7ca973bae787f6414c279df51d0ddf5" translate="yes" xml:space="preserve">
          <source>TODO: Should return the URI for this source, but we can't know what it is here.</source>
          <target state="translated">TODO:应该返回这个源的URI,但我们无法知道这里是什么。</target>
        </trans-unit>
        <trans-unit id="cf93c98946db5510058c27414ea744e90e3279d8" translate="yes" xml:space="preserve">
          <source>TODO: experimental!</source>
          <target state="translated">所有:实验性的!</target>
        </trans-unit>
        <trans-unit id="3657c9335058621e4530f335028b3958464c5aa9" translate="yes" xml:space="preserve">
          <source>TODO: experimental! Annotates an AST node with matching contraints. This method should be called on an AST intended to be used as a pattern only. It will put node metadata on the AST node allowing customized behavior in pattern matching.</source>
          <target state="translated">TODO:experimental! 用匹配的约束条件来注释一个AST节点。这个方法应该被调用在一个AST节点上,这个AST节点只打算作为一个模式使用。它将把节点元数据放在AST节点上,允许在模式匹配中自定义行为。</target>
        </trans-unit>
        <trans-unit id="b1c7a681e02f969b203ba3592fa54d2c692bbb52" translate="yes" xml:space="preserve">
          <source>TableCellEditor</source>
          <target state="translated">TableCellEditor</target>
        </trans-unit>
        <trans-unit id="57561c4bfa715cb5f4cf7c5dbfce29a5881d0950" translate="yes" xml:space="preserve">
          <source>TableModelListener</source>
          <target state="translated">TableModelListener</target>
        </trans-unit>
        <trans-unit id="5d7cbdd762e595f129150b280be1165c581c52dc" translate="yes" xml:space="preserve">
          <source>Takes a statement and wraps it into a block statement which first element is the interruption check statement.</source>
          <target state="translated">将一个语句包装成一个块状语句,其中第一个元素是中断检查语句。</target>
        </trans-unit>
        <trans-unit id="354438b5f2c2435d85aef9e5e1d521b569efa655" translate="yes" xml:space="preserve">
          <source>Takes a zero based index and convert it into an SQL based 1 based index.</source>
          <target state="translated">将一个基于零的索引转换成一个基于SQL的1索引。</target>
        </trans-unit>
        <trans-unit id="041aa4646c123f7952eaab5d26bd55d6a7709b46" translate="yes" xml:space="preserve">
          <source>Takes a zero based index and convert it into an SQL based 1 based index. A negative index will count backwards from the last column.</source>
          <target state="translated">将一个基于零的索引转换成一个基于SQL的1索引。负数索引将从最后一列开始倒数。</target>
        </trans-unit>
        <trans-unit id="72e15a873cff2714be38f04fe3477dcbcb571d1e" translate="yes" xml:space="preserve">
          <source>Takes the characters between nth (specified by occurrence) pair of &lt;code&gt;enclosure&lt;/code&gt; strings.</source>
          <target state="translated">在第n个（按出现次数指定） &lt;code&gt;enclosure&lt;/code&gt; 字符串对之间获取字符。</target>
        </trans-unit>
        <trans-unit id="4fdd5b94d50723024ee61c7a3f2a6df16695a3b8" translate="yes" xml:space="preserve">
          <source>Takes the characters between the first occurrence of the two subsequent &lt;code&gt;enclosure&lt;/code&gt; strings.</source>
          <target state="translated">在两个后续 &lt;code&gt;enclosure&lt;/code&gt; 字符串的第一个匹配项之间获取字符。</target>
        </trans-unit>
        <trans-unit id="8f5401efdd15336ecf28fb95881261864d11cc09" translate="yes" xml:space="preserve">
          <source>Takes the last ?</source>
          <target state="translated">采取最后的?</target>
        </trans-unit>
        <trans-unit id="5ad0f94b3f2dd848f00aba4d7d9abd45a61b5b02" translate="yes" xml:space="preserve">
          <source>Takes the last ? tokens of the list that form a simple expression, evaluates it and returns a result. &quot;Simple&quot; means evaluation is known to be side-effect free.</source>
          <target state="translated">取列表中最后一个构成简单表达式的? tokens,对其进行评估并返回结果。&quot;简单 &quot;表示已知评价是无副作用的。</target>
        </trans-unit>
        <trans-unit id="c304b15ae8ce0d2e4f76ba2ec779635f48eea681" translate="yes" xml:space="preserve">
          <source>Target.class</source>
          <target state="translated">Target.class</target>
        </trans-unit>
        <trans-unit id="7a099fd78212cd2ae28a2ff9a08f499c9dc92e4d" translate="yes" xml:space="preserve">
          <source>TargetBinding</source>
          <target state="translated">TargetBinding</target>
        </trans-unit>
        <trans-unit id="da5a824ba0bd242c7a60e17970f2791dec54d4ab" translate="yes" xml:space="preserve">
          <source>Tells if a class is one of the &quot;accept all&quot; classes as the left hand side of an assignment.</source>
          <target state="translated">显示一个班级是否属于 &quot;接受所有 &quot;的班级,作为任务的左手。</target>
        </trans-unit>
        <trans-unit id="0e09ff464218acfb2c73af0f0dc15dbca113a8c2" translate="yes" xml:space="preserve">
          <source>Tells if a class node is candidate for class literal bytecode optimization.</source>
          <target state="translated">说明一个类节点是否是类文字字节码优化的候选者。</target>
        </trans-unit>
        <trans-unit id="05493540c669c245f9637bf19d526e8d21f77a68" translate="yes" xml:space="preserve">
          <source>Tells if a class node is candidate for class literal bytecode optimization. If so, bytecode may use LDC instructions instead of static constant Class fields to retrieve class literals.</source>
          <target state="translated">说明一个类节点是否是类字元字节码优化的候选者。如果是,字节码可以使用LDC指令代替静态常量Class字段来检索类文字。</target>
        </trans-unit>
        <trans-unit id="d1d9bbbc3e04be119c70847b1f19b96ddd5a0d78" translate="yes" xml:space="preserve">
          <source>Tells if an input string matches a token.</source>
          <target state="translated">判断输入的字串是否符合标记。</target>
        </trans-unit>
        <trans-unit id="fd4940f1c01e2547dee0d64e72579a3db1df3a96" translate="yes" xml:space="preserve">
          <source>Tells if the given string is a valid Java identifier.</source>
          <target state="translated">说明给定的字符串是否是一个有效的Java标识符。</target>
        </trans-unit>
        <trans-unit id="2bf831a8ad75f4c75e56aee27a3bdb1640b165c2" translate="yes" xml:space="preserve">
          <source>Tells if this variable or the accessed variable is used in a closure context, like in the following example :</source>
          <target state="translated">说明这个变量或访问的变量是否在闭合上下文中使用,就像下面的例子。</target>
        </trans-unit>
        <trans-unit id="a5816f31fd183aa07200a002c77102dff5452d37" translate="yes" xml:space="preserve">
          <source>Template engine configuration</source>
          <target state="translated">模板引擎配置</target>
        </trans-unit>
        <trans-unit id="e12b935685180af8ae3137efb7001cba2cd17832" translate="yes" xml:space="preserve">
          <source>Template engine for use in templating scenarios where both the template source and the expected output are intended to be XML.</source>
          <target state="translated">模板引擎用于模板源和预期输出都是XML的情况下的模板方案。</target>
        </trans-unit>
        <trans-unit id="ef204f5f3596e2d30194001a07b4928b1a3949d3" translate="yes" xml:space="preserve">
          <source>TemplateEngine.createTemplate</source>
          <target state="translated">TemplateEngine.createTemplate</target>
        </trans-unit>
        <trans-unit id="dbf0ac726f3831ef2074d859816b327c66ed2b43" translate="yes" xml:space="preserve">
          <source>TemplateResolver</source>
          <target state="translated">TemplateResolver</target>
        </trans-unit>
        <trans-unit id="4436c0fa899dfbc2356893b025763c65d2d5384e" translate="yes" xml:space="preserve">
          <source>TemplateServlet.initTemplateEngine</source>
          <target state="translated">TemplateServlet.initTemplateEngine</target>
        </trans-unit>
        <trans-unit id="e593dd8801cfc67b3cac7df9ad54ee66fd2a486b" translate="yes" xml:space="preserve">
          <source>TemplateServlet.setVariables</source>
          <target state="translated">TemplateServlet.setVariables</target>
        </trans-unit>
        <trans-unit id="891b3675d27a4138af5360bd35bb314e25b67789" translate="yes" xml:space="preserve">
          <source>Templates may use the normal '${expression}' and '$variable' notations to insert an arbitrary expression into the template. In addition, support is also provided for special tags: &amp;lt;gsp:scriptlet&amp;gt; (for inserting code fragments) and &amp;lt;gsp:expression&amp;gt; (for code fragments which produce output).</source>
          <target state="translated">模板可以使用普通的&amp;ldquo; $ {expression}&amp;rdquo;和&amp;ldquo; $ variable&amp;rdquo;符号在模板中插入任意表达式。此外，还支持特殊标记：&amp;lt;gsp：scriptlet&amp;gt;（用于插入代码片段）和&amp;lt;gsp：expression&amp;gt;（用于产生输出的代码片段）。</target>
        </trans-unit>
        <trans-unit id="00122ac4f85694e5831e7199490968568e2ab42e" translate="yes" xml:space="preserve">
          <source>Terence Parr parrt@magelang.com John Lilley jlilley@empathy.com Scott Stanchfield thetick@magelang.com Markus Mohnen mohnen@informatik.rwth-aachen.de Peter Williams pete.williams@sun.com Allan Jacobs Allan.Jacobs@eng.sun.com Steve Messick messick@redhills.com James Strachan jstrachan@protique.com John Pybus john@pybus.org John Rose rose00@mac.com Jeremy Rayner groovy@ross-rayner.com Alex Popescu the.mindstorm@gmail.com Martin Kempf mkempf@hsr.ch Reto Kleeb rkleeb@hsr.ch Version 1.00 December 9, 1997 -- initial release Version 1.01 December 10, 1997 fixed bug in octal def (0..7 not 0..8) Version 1.10 August 1998 (parrt) added tree construction fixed definition of WS,comments for mac,pc,unix newlines added unary plus Version 1.11 (Nov 20, 1998) Added &quot;shutup&quot; option to turn off last ambig warning. Fixed inner class def to allow named class defs as statements synchronized requires compound not simple statement add [] after builtInType DOT class in primaryExpression &quot;const&quot; is reserved but not valid..removed from modifiers Version 1.12 (Feb 2, 1999) Changed LITERAL_xxx to xxx in tree grammar. Updated java.g to use tokens {...} now for 2.6.0 (new feature). Version 1.13 (Apr 23, 1999) Didn't have (stat)? for else clause in tree parser. Didn't gen ASTs for interface extends. Updated tree parser too. Updated to 2.6.0. Version 1.14 (Jun 20, 1999) Allowed final/abstract on local classes. Removed local interfaces from methods Put instanceof precedence where it belongs...in relationalExpr It also had expr not type as arg; fixed it. Missing ! on SEMI in classBlock fixed: (expr) + &quot;string&quot; was parsed incorrectly (+ as unary plus). fixed: didn't like Object[].class in parser or tree parser Version 1.15 (Jun 26, 1999) Screwed up rule with instanceof in it. :( Fixed. Tree parser didn't like (expr).something; fixed. Allowed multiple inheritance in tree grammar. oops. Version 1.16 (August 22, 1999) Extending an interface built a wacky tree: had extra EXTENDS. Tree grammar didn't allow multiple superinterfaces. Tree grammar didn't allow empty var initializer: {} Version 1.17 (October 12, 1999) ESC lexer rule allowed 399 max not 377 max. java.tree.g didn't handle the expression of synchronized statements. Version 1.18 (August 12, 2001) Terence updated to Java 2 Version 1.3 by observing/combining work of Allan Jacobs and Steve Messick. Handles 1.3 src. Summary: o primary didn't include boolean.class kind of thing o constructor calls parsed explicitly now: see explicitConstructorInvocation o add strictfp modifier o missing objBlock after new expression in tree grammar o merged local class definition alternatives, moved after declaration o fixed problem with ClassName.super.field o reordered some alternatives to make things more efficient o long and double constants were not differentiated from int/float o whitespace rule was inefficient: matched only one char o add an examples directory with some nasty 1.3 cases o made Main.java use buffered IO and a Reader for Unicode support o supports UNICODE? Using Unicode charVocabulary makes code file big, but only in the bitsets at the end. I need to make ANTLR generate unicode bitsets more efficiently. Version 1.19 (April 25, 2002) Terence added in nice fixes by John Pybus concerning floating constants and problems with super() calls. John did a nice reorg of the primary/postfix expression stuff to read better and makes f.g.super() parse properly (it was METHOD_CALL not a SUPER_CTOR_CALL). Also: o &quot;finally&quot; clause was a root...made it a child of &quot;try&quot; o Added stuff for asserts too for Java 1.4, but *commented out* as it is not backward compatible. Version 1.20 (October 27, 2002) Terence ended up reorging John Pybus' stuff to remove some nondeterminisms and some syntactic predicates. Note that the grammar is stricter now; e.g., this(...) must be the first statement. Trinary ?: operator wasn't working as array name: (isBig ? bigDigits : digits)[i]; Checked parser/tree parser on source for Resin-2.0.5, jive-2.1.1, jdk 1.3.1, Lucene, antlr 2.7.2a4, and the 110k-line jGuru server source. Version 1.21 (October 17, 2003) Fixed lots of problems including: Ray Waldin: add typeDefinition to interfaceBlock in java.tree.g He found a problem/fix with floating point that start with 0 Ray also fixed problem that (int.class) was not recognized. Thorsten van Ellen noticed that \n are allowed incorrectly in strings. TJP fixed CHAR_LITERAL analogously. Version 1.21.2 (March, 2003) Changes by Matt Quail to support generics (as per JDK1.5/JSR14) Notes: o We only allow the &quot;extends&quot; keyword and not the &quot;implements&quot; keyword, since that's what JSR14 seems to imply. o Thanks to Monty Zukowski for his help on the antlr-interest mail list. o Thanks to Alan Eliasen for testing the grammar over his Fink source base Version 1.22 (July, 2004) Changes by Michael Studman to support Java 1.5 language extensions Notes: o Added support for annotations types o Finished off Matt Quail's generics enhancements to support bound type arguments o Added support for new for statement syntax o Added support for static import syntax o Added support for enum types o Tested against JDK 1.5 source base and source base of jdigraph project o Thanks to Matt Quail for doing the hard part by doing most of the generics work Version 1.22.1 (July 28, 2004) Bug/omission fixes for Java 1.5 language support o Fixed tree structure bug with classOrInterface - thanks to Pieter Vangorpto for spotting this o Fixed bug where incorrect handling of SR and BSR tokens would cause type parameters to be recognised as type arguments. o Enabled type parameters on constructors, annotations on enum constants and package definitions o Fixed problems when parsing if ((char.class.equals(c))) {} - solution by Matt Quail at Cenqua Version 1.22.2 (July 28, 2004) Slight refactoring of Java 1.5 language support o Refactored for/&quot;foreach&quot; productions so that original literal &quot;for&quot; literal is still used but the for sub-clauses vary by token type o Fixed bug where type parameter was not included in generic constructor's branch of AST Version 1.22.3 (August 26, 2004) Bug fixes as identified by Michael Stahl; clean up of tabs/spaces and other refactorings o Fixed typeParameters omission in identPrimary and newStatement o Replaced GT reconcilliation code with simple semantic predicate o Adapted enum/assert keyword checking support from Michael Stahl's java15 grammar o Refactored typeDefinition production and field productions to reduce duplication Version 1.22.4 (October 21, 2004) Small bux fixes o Added typeArguments to explicitConstructorInvocation, e.g. new</source>
          <target state="translated">Terence Parr parrt@magelang.com John Lilley jlilley@empathy.com Scott Stanchfield thetick@magelang.com Markus Mohnen mohnen@informatik.rwth-aachen.de Peter Williams pete.williams@sun.com Allan Jacobs Allan.Jacobs@eng.sun.com Steve Messick messick@redhills.com James Strachan jstrachan@protique.com John Pybus john@pybus.org John Rose rose00@mac.com Jeremy Rayner groovy@ross-rayner.com Alex Popescu the.mindstorm@gmail.com Martin Kempf mkempf@hsr.ch Reto Kleeb rkleeb@hsr.ch 版本1.00 1997年12月9日 --初始版本 1.01 1997年12月10日 修正了八进制定义中的错误(0..7而不是0..8)1998年8月版本1.10 (parrt)增加了树形结构,修正了WS的定义,对mac,pc,unix的注释 增加了unary plus版本1.11 (1998年11月20日)增加了 &quot;shutup &quot;选项以关闭最后的歧义警告。修正了内类def,允许命名的类def作为语句同步,需要复合而不是简单的语句,在primaryExpression中的buildInType DOT类后添加[],&quot;const &quot;是保留的,但不是有效的......从修饰符中删除 版本1.12 (1999年2月2日)将树语法中的LITERAL_xxx改为xxx。更新java.g,使其在2.6.0中使用标记{...}(新特性)。1.13版本 (1999年4月23日)在树形分析器中没有为 else 子句设置 (stat)? 没有为接口扩展生成ASTs。也更新了树形分析器。更新到2.6.0。1.14版本 (1999年6月20日)允许本地类使用final/abstract。删除了方法中的局部接口,把instanceof的优先权放在它所属的地方......在relationalExpr中,它也有expr不以类型为arg的情况,已经修正了。修正了classBlock中SEMI上缺失的! (expr)+&quot;string &quot;解析错误(+为单利加号)。修正:在解析器或树解析器中不喜欢Object[].class 1.15版(1999年6月26日)把instanceof的规则搞乱了。树分析器不喜欢(expr).something;修正。允许树语法中的多重继承。1.16版本(1999年8月22日)扩展一个接口建立了一个古怪的树:有额外的EXTENDS。树型语法不允许多个超级接口。树语法不允许使用空的 var initializer。{}版本1.17 (1999年10月12日)ESC词法规则允许399个最大值而不是377个最大值。java.tree.g没有处理同步语句的表达。1.18版本(2001年8月12日)Terence通过观察/综合Allan Jacobs和Steve Messick的工作,更新到Java 2 1.3版本。处理1.3版本的src。摘要:o primary没有包含boolean.class那种东西 o构造函数调用现在明确地解析了:见 explicitConstructorInvocation o增加了strictfp修饰符 o树语法中新表达式后缺少了objBlock o合并了本地类定义的备选方案,移到了声明之后 o修正了ClassName.super.字段的问题。 o 重新安排了一些备选方案的顺序,使事情变得更有效率 o 长常量和双常量没有与 int/float 区分开来 o 白空格规则效率低下:只匹配了一个字符 o 增加了一个例子目录,其中有一些令人讨厌的 1.3 情况 o 使 Main.java 使用缓冲 IO 和一个阅读器来支持 Unicode o 支持 UNICODE? 使用Unicode charVocabulary会使代码文件变大,但只是在最后的位集。我需要让ANTLR更有效地生成unicode位集。1.19版本(2002年4月25日)Terence加入了John Pybus对浮动常量和super()调用问题的修正。John对primary/postfix表达式做了一个很好的重构,使其读起来更顺畅,并使f.g.super()的解析正确(它是METHOD_CALL而不是SUPER_CTOR_CALL)。另外:o &quot;finally &quot;子句是一个根...把它变成了 &quot;try &quot;的一个子句 o 为Java 1.4添加了断言的东西,但由于不向后兼容,被*删掉了。1.20版本(2002年10月27日)Terence最后重新整理了John Pybus的东西,删除了一些非确定性和一些语法谓词。请注意,现在的语法更严格了,例如,this(...)必须是第一条语句。三进制?:操作符不能作为数组名使用:(isBig ? bigDigits:digits)[i];检查了Resin-2.0.5、jive-2.1.1、jdk 1.3.1、Lucene、antlr 2.7.2a4和110k行jGuru服务器源码上的解析器/树解析器。1.21版本(2003年10月17日)修正了很多问题,包括。Ray Waldin:在java.tree.g中的interfaceBlock中添加typeDefinition,他发现了一个以0开头的浮点数的问题,并进行了修正。 Ray还修正了(int.class)不被识别的问题。Thorsten van Ellen注意到字符串中不允许使用\n的问题。TJP 类似地修正了 CHAR_LITERAL。版本1.21.2 (2003年3月)Matt Quail为支持generics所做的修改(根据JDK1.5/JSR14)注意:o 我们只允许使用 &quot;extends &quot;关键字,而不允许使用 &quot;improments &quot;关键字,因为JSR14似乎暗示了这一点。o 感谢Alan Eliasen在他的Fink源码上测试语法 1.22版(2004年7月)Michael Studman为支持Java 1.5语言扩展所做的修改 注释:o 增加了对注释类型的支持 o 完成了Matt Quail对绑定类型的增强。</target>
        </trans-unit>
        <trans-unit id="48a1454ddc5de44915d242d03aefb2a12bcfe0fe" translate="yes" xml:space="preserve">
          <source>Terence Parr parrt@magelang.com John Lilley jlilley@empathy.com Scott Stanchfield thetick@magelang.com Markus Mohnen mohnen@informatik.rwth-aachen.de Peter Williams pete.williams@sun.com Allan Jacobs Allan.Jacobs@eng.sun.com Steve Messick messick@redhills.com John Pybus john@pybus.org Version 1.00 December 9, 1997 -- initial release Version 1.01 December 10, 1997 fixed bug in octal def (0..7 not 0..8) Version 1.10 August 1998 (parrt) added tree construction fixed definition of WS,comments for mac,pc,unix newlines added unary plus Version 1.11 (Nov 20, 1998) Added &quot;shutup&quot; option to turn off last ambig warning. Fixed inner class def to allow named class defs as statements synchronized requires compound not simple statement add [] after builtInType DOT class in primaryExpression &quot;const&quot; is reserved but not valid..removed from modifiers Version 1.12 (Feb 2, 1999) Changed LITERAL_xxx to xxx in tree grammar. Updated java.g to use tokens {...} now for 2.6.0 (new feature). Version 1.13 (Apr 23, 1999) Didn't have (stat)? for else clause in tree parser. Didn't gen ASTs for interface extends. Updated tree parser too. Updated to 2.6.0. Version 1.14 (Jun 20, 1999) Allowed final/abstract on local classes. Removed local interfaces from methods Put instanceof precedence where it belongs...in relationalExpr It also had expr not type as arg; fixed it. Missing ! on SEMI in classBlock fixed: (expr) + &quot;string&quot; was parsed incorrectly (+ as unary plus). fixed: didn't like Object[].class in parser or tree parser Version 1.15 (Jun 26, 1999) Screwed up rule with instanceof in it. :( Fixed. Tree parser didn't like (expr).something; fixed. Allowed multiple inheritance in tree grammar. oops. Version 1.16 (August 22, 1999) Extending an interface built a wacky tree: had extra EXTENDS. Tree grammar didn't allow multiple superinterfaces. Tree grammar didn't allow empty var initializer: {} Version 1.17 (October 12, 1999) ESC lexer rule allowed 399 max not 377 max. java.tree.g didn't handle the expression of synchronized statements. Version 1.18 (August 12, 2001) Terence updated to Java 2 Version 1.3 by observing/combining work of Allan Jacobs and Steve Messick. Handles 1.3 src. Summary: o primary didn't include boolean.class kind of thing o constructor calls parsed explicitly now: see explicitConstructorInvocation o add strictfp modifier o missing objBlock after new expression in tree grammar o merged local class definition alternatives, moved after declaration o fixed problem with ClassName.super.field o reordered some alternatives to make things more efficient o long and double constants were not differentiated from int/float o whitespace rule was inefficient: matched only one char o add an examples directory with some nasty 1.3 cases o made Main.java use buffered IO and a Reader for Unicode support o supports UNICODE? Using Unicode charVocabulay makes code file big, but only in the bitsets at the end. I need to make ANTLR generate unicode bitsets more efficiently. Version 1.19 (April 25, 2002) Terence added in nice fixes by John Pybus concerning floating constants and problems with super() calls. John did a nice reorg of the primary/postfix expression stuff to read better and makes f.g.super() parse properly (it was METHOD_CALL not a SUPER_CTOR_CALL). Also: o &quot;finally&quot; clause was a root...made it a child of &quot;try&quot; o Added stuff for asserts too for Java 1.4, but *commented out* as it is not backward compatible. Version 1.20 (October 27, 2002) Terence ended up reorging John Pybus' stuff to remove some nondeterminisms and some syntactic predicates. Note that the grammar is stricter now; e.g., this(...) must be the first statement. Ternary ?: operator wasn't working as array name: (isBig ? bigDigits : digits)[i]; Checked parser/tree parser on source for Resin-2.0.5, jive-2.1.1, jdk 1.3.1, Lucene, antlr 2.7.2a4, and the 110k-line jGuru server source. Version 1.21 (October 17, 2003) Fixed lots of problems including: Ray Waldin: add typeDefinition to interfaceBlock in java.tree.g He found a problem/fix with floating point that start with 0 Ray also fixed problem that (int.class) was not recognized. Thorsten van Ellen noticed that \n are allowed incorrectly in strings. TJP fixed CHAR_LITERAL analogously. Version 1.21.2 (March, 2003) Changes by Matt Quail to support generics (as per JDK1.5/JSR14) Notes: o We only allow the &quot;extends&quot; keyword and not the &quot;implements&quot; keyword, since that's what JSR14 seems to imply. o Thanks to Monty Zukowski for his help on the antlr-interest mail list. o Thanks to Alan Eliasen for testing the grammar over his Fink source base Version 1.22 (July, 2004) Changes by Michael Studman to support Java 1.5 language extensions Notes: o Added support for annotations types o Finished off Matt Quail's generics enhancements to support bound type arguments o Added support for new for statement syntax o Added support for static import syntax o Added support for enum types o Tested against JDK 1.5 source base and source base of jdigraph project o Thanks to Matt Quail for doing the hard part by doing most of the generics work Version 1.22.1 (July 28, 2004) Bug/omission fixes for Java 1.5 language support o Fixed tree structure bug with classOrInterface - thanks to Pieter Vangorpto for spotting this o Fixed bug where incorrect handling of SR and BSR tokens would cause type parameters to be recognised as type arguments. o Enabled type parameters on constructors, annotations on enum constants and package definitions o Fixed problems when parsing if ((char.class.equals(c))) {} - solution by Matt Quail at Cenqua Version 1.22.2 (July 28, 2004) Slight refactoring of Java 1.5 language support o Refactored for/&quot;foreach&quot; productions so that original literal &quot;for&quot; literal is still used but the for sub-clauses vary by token type o Fixed bug where type parameter was not included in generic constructor's branch of AST Version 1.22.3 (August 26, 2004) Bug fixes as identified by Michael Stahl; clean up of tabs/spaces and other refactorings o Fixed typeParameters omission in identPrimary and newStatement o Replaced GT reconciliation code with simple semantic predicate o Adapted enum/assert keyword checking support from Michael Stahl's java15 grammar o Refactored typeDefinition production and field productions to reduce duplication Version 1.22.4 (October 21, 2004) Small bux fixes o Added typeArguments to explicitConstructorInvocation, e.g. new</source>
          <target state="translated">Terence Parr parrt@magelang.com John Lilley jlilley@empathy.com Scott Stanchfield thetick@magelang.com Markus Mohnen mohnen@informatik.rwth-aachen.de Peter Williams pete.williams@sun.com Allan Jacobs Allan.Jacobs@eng.sun.com Steve Messick messick@redhills.com John Pybus john@pybus.org 版本1.00 1997年12月9日 --初始版本 1.01 1997年12月10日 修正了八进制def的bug (0..7而不是0..8)1998年8月版本1.10 (parrt)增加了树形结构,修正了WS的定义,mac,pc,unix的注释,增加了unary plus版本1.11 (1998年11月20日)增加了 &quot;shutup &quot;选项以关闭最后的歧义警告。修正了内类def,允许命名的类def作为语句同步,需要复合而不是简单的语句,在primaryExpression中的buildInType DOT类后添加[],&quot;const &quot;是保留的,但不是有效的......从修饰符中删除 版本1.12 (1999年2月2日)将树语法中的LITERAL_xxx改为xxx。更新java.g,使其在2.6.0中使用标记{...}(新特性)。1.13版本 (1999年4月23日)在树形分析器中没有为 else 子句设置 (stat)? 没有为接口扩展生成ASTs。也更新了树形分析器。更新到2.6.0。1.14版本 (1999年6月20日)允许本地类使用final/abstract。删除了方法中的局部接口,把instanceof的优先权放在它所属的地方......在relationalExpr中,它也有expr不以类型为arg的情况,已经修正了。修正了classBlock中SEMI上缺失的! (expr)+&quot;string &quot;解析错误(+为单利加号)。修正:在解析器或树解析器中不喜欢Object[].class 1.15版(1999年6月26日)把instanceof的规则搞乱了。树分析器不喜欢(expr).something;修正。允许树语法中的多重继承。1.16版本(1999年8月22日)扩展一个接口建立了一个古怪的树:有额外的EXTENDS。树型语法不允许多个超级接口。树语法不允许使用空的 var initializer。{}版本1.17 (1999年10月12日)ESC词法规则允许399个最大值而不是377个最大值。java.tree.g没有处理同步语句的表达。1.18版本(2001年8月12日)Terence通过观察/综合Allan Jacobs和Steve Messick的工作,更新到Java 2 1.3版本。处理1.3版本的src。摘要:o primary没有包含boolean.class那种东西 o构造函数调用现在明确地解析了:见 explicitConstructorInvocation o增加了strictfp修饰符 o树语法中新表达式后缺少了objBlock o合并了本地类定义的备选方案,移到了声明之后 o修正了ClassName.super.字段的问题。 o 重新安排了一些备选方案的顺序,以提高工作效率 o 长常量和双常量没有与 int/float 区分开来 o 白空格规则效率低下:只匹配了一个字符 o 增加了一个例子目录,其中有一些令人讨厌的 1.3 情况 o 使 Main.java 使用缓冲 IO 和一个阅读器来支持 Unicode o 支持 UNICODE? 使用Unicode charVocabulay会使代码文件变大,但只是在最后的位集。我需要让ANTLR更有效地生成Unicode位集。1.19版本 (2002年4月25日)Terence加入了John Pybus对浮动常量和super()调用问题的修正。John对primary/postfix表达式做了一个很好的重构,使其读起来更顺畅,并使f.g.super()的解析正确(它是METHOD_CALL而不是SUPER_CTOR_CALL)。另外:o &quot;finally &quot;子句是一个根...把它变成了 &quot;try &quot;的一个子句 o 为Java 1.4添加了断言的东西,但由于不向后兼容,被*删掉了。1.20版本(2002年10月27日)Terence最后重新整理了John Pybus的东西,删除了一些非确定性和一些语法谓词。请注意,现在的语法更严格了,例如,this(...)必须是第一条语句。Ternary ?:operator wasn't working as array name:(isBig ? bigDigits:digits)[i];Checked parser/tree parser on source for Resin-2.0.5,jive-2.1.1,jdk 1.3.1,Lucene,antlr 2.7.2a4,and the 110k-line jGuru server source.1.21版本(2003年10月17日)修正了很多问题,包括。Ray Waldin:在java.tree.g中的interfaceBlock中加入typeDefinition,他发现了一个以0开头的浮点数的问题,并进行了修正。 Ray还修正了(int.class)不被识别的问题。Thorsten van Ellen注意到字符串中不允许使用\n的问题。TJP 类似地修正了 CHAR_LITERAL。版本1.21.2 (2003年3月)由Matt Quail修改,以支持generics (根据JDK1.5/JSR14)注释:o 我们只允许使用 &quot;extends &quot;关键字,而不允许使用 &quot;improments &quot;关键字,因为JSR14似乎暗示了这一点。 22 (2004年7月)Michael Studman为支持Java 1.5语言扩展所做的修改 注释:o 增加了对注释类型的支持 o 完成了Matt Quail的generics增强,以支持绑定类型参数 o 增加了对new的语句语法的支持 o 增加了对静态导入语法的支持 o 增加了对枚举类型的支持 o 对JDK 1.5源码和jd的源码进行了测试。</target>
        </trans-unit>
        <trans-unit id="640ab2bae07bedc4c163f679a746f7ab7fb5d1fa" translate="yes" xml:space="preserve">
          <source>Test</source>
          <target state="translated">Test</target>
        </trans-unit>
        <trans-unit id="22d23f24cd32f09242a53db536a945808560295a" translate="yes" xml:space="preserve">
          <source>Test if a method call is recursive if called within a given method node. Handles static calls as well. Currently known simplifications:</source>
          <target state="translated">测试在给定的方法节点内调用的方法调用是否是递归的。也可以处理静态调用。目前已知的简化。</target>
        </trans-unit>
        <trans-unit id="8ceac294319c34b3b08934255a2a46a704ab7aeb" translate="yes" xml:space="preserve">
          <source>Test to determine if a ClassNode is a primitive type.</source>
          <target state="translated">测试确定一个ClassNode是否为基元类型。</target>
        </trans-unit>
        <trans-unit id="9403cb8e3b09787aa434a66b33f9f48728feb7eb" translate="yes" xml:space="preserve">
          <source>Test to determine if a ClassNode is a primitive type. Note: this only works for ClassNodes created using a predefined ClassNode</source>
          <target state="translated">测试确定一个ClassNode是否是基元类型。注意:这只适用于使用预定义的ClassNode创建的ClassNode。</target>
        </trans-unit>
        <trans-unit id="efcab8f5a7c0064e3a92f17428182ce215e6823b" translate="yes" xml:space="preserve">
          <source>Test to determine if a ClassNode is a type belongs to the list of types which are allowed to initialize constants directly in bytecode instead of using &amp;lt;cinit&amp;gt;</source>
          <target state="translated">测试以确定ClassNode是否为类型，该类型属于允许直接在字节码中初始化常量而不是使用&amp;lt;cinit&amp;gt;的类型列表</target>
        </trans-unit>
        <trans-unit id="317d6297ac6952a296eb2ddc257fdae5db4c3acc" translate="yes" xml:space="preserve">
          <source>Tests given value against specified type and changes generics of result.</source>
          <target state="translated">根据指定的类型对给定值进行测试,并改变结果的类型。</target>
        </trans-unit>
        <trans-unit id="063eb35b9befe3464dd713e416056ece4259e856" translate="yes" xml:space="preserve">
          <source>Tests given value against specified type and changes generics of result. This is equivalent to: &lt;code&gt;self.filter(it -&amp;gt; it instanceof Type).map(it -&amp;gt; (Type) it)&lt;/code&gt;</source>
          <target state="translated">针对指定类型测试给定值，并更改结果的泛型。这等效于： &lt;code&gt;self.filter(it -&amp;gt; it instanceof Type).map(it -&amp;gt; (Type) it)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="297a33c2b3cbe7da16caded2f3d349714f069bd6" translate="yes" xml:space="preserve">
          <source>Tests if a node is an inner class node, and if it is, then checks if the enclosing method is skipped.</source>
          <target state="translated">测试一个节点是否是内类节点,如果是,则检查是否跳过外层方法。</target>
        </trans-unit>
        <trans-unit id="328ba89482a1987881d000e13d7f357f23c9b1d6" translate="yes" xml:space="preserve">
          <source>Tests if groovydoc is present</source>
          <target state="translated">测试groovydoc是否存在</target>
        </trans-unit>
        <trans-unit id="5fb815736873e34454c94811223e0a4810394010" translate="yes" xml:space="preserve">
          <source>Tests if some key maps into the specified value in this table.</source>
          <target state="translated">测试某些键是否映射到本表的指定值中。</target>
        </trans-unit>
        <trans-unit id="add0ba96e90c01761791705826395fed0f349dba" translate="yes" xml:space="preserve">
          <source>Tests if some key maps into the specified value in this table. This operation is more expensive than the &lt;code&gt;containsKey&lt;/code&gt; method.</source>
          <target state="translated">测试某些键是否映射到该表中的指定值。该操作比 &lt;code&gt;containsKey&lt;/code&gt; 方法更昂贵。</target>
        </trans-unit>
        <trans-unit id="1e5b79dd75c69804ac69d0b591a74c9eee88301c" translate="yes" xml:space="preserve">
          <source>Tests if the specified object is a key in this table.</source>
          <target state="translated">测试指定的对象是否是本表的键。</target>
        </trans-unit>
        <trans-unit id="5a3838caffb4fd461c7b1a0ac5808c7ae0ee8b59" translate="yes" xml:space="preserve">
          <source>Tests if this CharSequence ends with any specified suffixes.</source>
          <target state="translated">测试该CharSequence是否以任何指定的后缀结束。</target>
        </trans-unit>
        <trans-unit id="dea9b3965b823036214967b36b37dd1a8b716789" translate="yes" xml:space="preserve">
          <source>Tests if this CharSequence is blank.</source>
          <target state="translated">测试该CharSequence是否为空白。</target>
        </trans-unit>
        <trans-unit id="49212f1b5b77fc1ba50dd42e242f061373833989" translate="yes" xml:space="preserve">
          <source>Tests if this CharSequence starts with any specified prefixes.</source>
          <target state="translated">测试这个CharSequence是否以任何指定的前缀开始。</target>
        </trans-unit>
        <trans-unit id="86c27bae4e49a7c791a1aae1f78c196c87814064" translate="yes" xml:space="preserve">
          <source>Tests if this QName matches another object.</source>
          <target state="translated">测试该QName是否与其他对象匹配。</target>
        </trans-unit>
        <trans-unit id="0ac416154eaf4d481cc125feddea58871c1256c2" translate="yes" xml:space="preserve">
          <source>Tests this QName for equality with another object.</source>
          <target state="translated">测试这个QName是否与另一个对象相等。</target>
        </trans-unit>
        <trans-unit id="a9cf2cef79fdf0aa5b76a94b1b479b909d61f565" translate="yes" xml:space="preserve">
          <source>Tests whether the provided class implements MBean.</source>
          <target state="translated">测试所提供的类是否实现了MBean。</target>
        </trans-unit>
        <trans-unit id="5c0a04fe736541754976f6a02d03fdc39f9ee64b" translate="yes" xml:space="preserve">
          <source>Tests whether the provided class implements MBean. It uses the following runes</source>
          <target state="translated">测试所提供的类是否实现了MBean。它使用以下符文</target>
        </trans-unit>
        <trans-unit id="04001d250c417c421d5d967c360fc90b35f68b2e" translate="yes" xml:space="preserve">
          <source>Text processing helpers for the interactive command line terminal.</source>
          <target state="translated">用于交互式命令行终端的文本处理助手。</target>
        </trans-unit>
        <trans-unit id="bb34f30402043e44ae32896d840ce387a4b09777" translate="yes" xml:space="preserve">
          <source>That will produce the following output:</source>
          <target state="translated">这将产生以下输出。</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">The</target>
        </trans-unit>
        <trans-unit id="ff58e4d37ea3d39dfbb57350dad837205a5b260f" translate="yes" xml:space="preserve">
          <source>The &quot;Ruby-style&quot; new conversions occur automatically unless the 'auto=false' flag is given when using the annotation. You might do this if you create a new method using meta programming.</source>
          <target state="translated">除非在使用注解时给出'auto=false'标志,否则 &quot;Ruby风格 &quot;的新转换会自动发生。如果你使用元编程创建一个新方法,你可能会这样做。</target>
        </trans-unit>
        <trans-unit id="abaf21fddf45033ab2c9f43f7104088d40814a57" translate="yes" xml:space="preserve">
          <source>The &quot;load&quot; command will add the given file or path to the classpath in this configuration object. If the path does not exist, the path will be ignored.</source>
          <target state="translated">load &quot;命令将把给定的文件或路径添加到这个配置对象的classpath中。如果路径不存在,则会忽略该路径。</target>
        </trans-unit>
        <trans-unit id="c60ab597093e621854305c3505f5719eaec2ffc7" translate="yes" xml:space="preserve">
          <source>The &quot;main is&quot; part may only be once in the file. The String afterwards is the name of a class with a main method.</source>
          <target state="translated">&quot;main is &quot;部分在文件中只能有一次。后面的字符串是一个有main方法的类的名称。</target>
        </trans-unit>
        <trans-unit id="12e2ad9f4f40932144714a1460d03531ba22986d" translate="yes" xml:space="preserve">
          <source>The &quot;str&quot; variable is closure shared.</source>
          <target state="translated">&quot;str &quot;变量是封闭共享的。</target>
        </trans-unit>
        <trans-unit id="c847cbc1e1b5981b8a03d4b15cf1bf15d40091e2" translate="yes" xml:space="preserve">
          <source>The &quot;str&quot; variable is closure shared. The variable expression inside the closure references an accessed variable &quot;str&quot; which must have the closure shared flag set.</source>
          <target state="translated">str &quot;变量是闭包共享的。闭包中的变量表达式引用了一个被访问的变量 &quot;str&quot;,这个变量必须设置了闭包共享的标志。</target>
        </trans-unit>
        <trans-unit id="39940fc40491b10b14c8b07773b7fb0c04450a6e" translate="yes" xml:space="preserve">
          <source>The &quot;~&quot; character can be used to represent the user's home directory. It cannot fully complete to other users' homes in all operating systems, since java does not provide any way of determining that easily, but it will attempt a simplistic approach.</source>
          <target state="translated">&quot;~&quot;字符可以用来代表用户的主目录。在所有的操作系统中,它不能完全完成到其他用户的主目录,因为java并没有提供任何容易确定的方法,但它会尝试一种简单的方法。</target>
        </trans-unit>
        <trans-unit id="a052786f73a4f92e76bad5f0c863ba3cd193790a" translate="yes" xml:space="preserve">
          <source>The 'alias' command.</source>
          <target state="translated">'别名'命令。</target>
        </trans-unit>
        <trans-unit id="40024a2623baca4354e986fca884b143a6cc6c9f" translate="yes" xml:space="preserve">
          <source>The 'clear' command.</source>
          <target state="translated">'清除'命令。</target>
        </trans-unit>
        <trans-unit id="3b1cbc87993f31ce6273cefc6205a16b17b91a61" translate="yes" xml:space="preserve">
          <source>The 'display' command. Displays the current buffer (e.g. while method declaration was not finished).</source>
          <target state="translated">显示 &quot;命令。显示当前的缓冲区(比如方法声明未完成时)。</target>
        </trans-unit>
        <trans-unit id="49f40f12151358c7d843d53687ed095e487a154e" translate="yes" xml:space="preserve">
          <source>The 'doc' command.</source>
          <target state="translated">'doc'命令。</target>
        </trans-unit>
        <trans-unit id="bc3ffba03d00f8c7b85d7091a061031e0b1eb2b0" translate="yes" xml:space="preserve">
          <source>The 'edit' command. Opens Editor to write into the current Buffer.</source>
          <target state="translated">编辑 &quot;命令。打开编辑器,向当前Buffer中写入内容。</target>
        </trans-unit>
        <trans-unit id="f3f7c1cec23633cc0cfaa9cb09f02911a1e9d149" translate="yes" xml:space="preserve">
          <source>The 'exit' command.</source>
          <target state="translated">'退出'命令。</target>
        </trans-unit>
        <trans-unit id="046ba041acd9691591b162277d1a0f7106c9bb51" translate="yes" xml:space="preserve">
          <source>The 'forClass' annotation attribute for the &lt;code&gt;@Builder&lt;/code&gt; transform isn't applicable for this strategy. The 'useSetters' annotation attribute for the &lt;code&gt;@Builder&lt;/code&gt; transform is ignored by this strategy which always uses setters.</source>
          <target state="translated">&lt;code&gt;@Builder&lt;/code&gt; 转换的'forClass'注释属性不适用于此策略。 &lt;code&gt;@Builder&lt;/code&gt; 转换的'useSetters'注释属性被始终使用setter的此策略所忽略。</target>
        </trans-unit>
        <trans-unit id="45835faea7523426faaaf8fa1e49229a32a26b8c" translate="yes" xml:space="preserve">
          <source>The 'grab' command.</source>
          <target state="translated">抢 &quot;的命令。</target>
        </trans-unit>
        <trans-unit id="205fbf3975b12113a5c8bd8232bfa1665e8d1f5c" translate="yes" xml:space="preserve">
          <source>The 'help' command.</source>
          <target state="translated">帮助 &quot;命令。</target>
        </trans-unit>
        <trans-unit id="20ec27c9e0ddbd2a48fb1d21fc610eca2f90fc72" translate="yes" xml:space="preserve">
          <source>The 'history' command.</source>
          <target state="translated">'历史'命令。</target>
        </trans-unit>
        <trans-unit id="2d489d33aa47e12f822416973b70f3e5da0b4497" translate="yes" xml:space="preserve">
          <source>The 'import' command.</source>
          <target state="translated">输入 &quot;命令。</target>
        </trans-unit>
        <trans-unit id="7e8ac89c1c05e64fcbd55e0b499745677ba943e0" translate="yes" xml:space="preserve">
          <source>The 'inspect' command.</source>
          <target state="translated">检查 &quot;命令。</target>
        </trans-unit>
        <trans-unit id="551c33d159644a8f5ef1c6ac388343537009ae2b" translate="yes" xml:space="preserve">
          <source>The 'load' command.</source>
          <target state="translated">负载 &quot;命令。</target>
        </trans-unit>
        <trans-unit id="b6bc21ba2f0a2893871757da3c856326ee9de094" translate="yes" xml:space="preserve">
          <source>The 'purge' command.</source>
          <target state="translated">'清除'命令。</target>
        </trans-unit>
        <trans-unit id="ba59fbb5346c40fbb6302c6187328e618a3da7ed" translate="yes" xml:space="preserve">
          <source>The 'record' command.</source>
          <target state="translated">记录 &quot;命令。</target>
        </trans-unit>
        <trans-unit id="7c3791604975b9d1fb30c9a2bd534192e00088a0" translate="yes" xml:space="preserve">
          <source>The 'register' command. Registers a class as a new groovysh command. Requires the command to have matching constructors (shell) or (shell, name, alias).</source>
          <target state="translated">register'命令。注册一个类作为一个新的groovysh命令。要求命令有匹配的构造函数(shell)或(shell,name,alias)。</target>
        </trans-unit>
        <trans-unit id="e2c14b48e8d21dde57913f41162e2eb4486751ed" translate="yes" xml:space="preserve">
          <source>The 'save' command.</source>
          <target state="translated">'保存'命令。</target>
        </trans-unit>
        <trans-unit id="9a925ff93968b41e2b76e842b170f7ec6c6d9eb0" translate="yes" xml:space="preserve">
          <source>The 'set' command, used to set preferences.</source>
          <target state="translated">设置 &quot;命令,用于设置偏好。</target>
        </trans-unit>
        <trans-unit id="f931e78f8e44eb712f74c86f1afb6c2a241148eb" translate="yes" xml:space="preserve">
          <source>The 'shadow' command.</source>
          <target state="translated">'影子'命令。</target>
        </trans-unit>
        <trans-unit id="5a09c2bfc8378532d9a0032fb6ba7ae84db4fe0b" translate="yes" xml:space="preserve">
          <source>The 'show' command.</source>
          <target state="translated">显示 &quot;命令。</target>
        </trans-unit>
        <trans-unit id="a59faad4653d2f4a8eeb438184148004e01411e2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;closure#resolveStrategy&quot;&gt;Closure.resolveStrategy&lt;/a&gt; used by the closure.</source>
          <target state="translated">闭包使用的&lt;a href=&quot;closure#resolveStrategy&quot;&gt;Closure.resolveStrategy&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4bb77833997045b8a169e0e940948f5de47f4a41" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@AutoExternalize&lt;/code&gt; transform is implemented as a combination of the &lt;code&gt;@ExternalizeMethods&lt;/code&gt; and &lt;code&gt;@ExternalizeVerifier&lt;/code&gt; transforms.</source>
          <target state="translated">所述 &lt;code&gt;@AutoExternalize&lt;/code&gt; 变换被实现为组合 &lt;code&gt;@ExternalizeMethods&lt;/code&gt; 和 &lt;code&gt;@ExternalizeVerifier&lt;/code&gt; 变换。</target>
        </trans-unit>
        <trans-unit id="45203388f4746d69eda07f4e8e18ce996ab3c42d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@Builder&lt;/code&gt; AST transformation is used to help write classes that can be created using &lt;em&gt;fluent&lt;/em&gt; api calls. The transform supports multiple building strategies to cover a range of cases and there are a number of configuration options to customize the building process. In addition, a number of annotation attributes let you customise the building process. Not all annotation attributes are supported by all strategies. See the individual strategy documentation for more details. If you're an AST hacker, you can also define your own strategy class. The following strategies are bundled with Groovy:</source>
          <target state="translated">该 &lt;code&gt;@Builder&lt;/code&gt; AST转换用于可使用创建帮助写类&lt;em&gt;流利&lt;/em&gt;的API调用。转换支持多种构建策略以涵盖各种情况，并且有许多配置选项可自定义构建过程。另外，许多注释属性使您可以自定义构建过程。并非所有策略都支持所有注释属性。有关更多详细信息，请参见各个策略文档。如果您是AST黑客，则还可以定义自己的策略类。 Groovy捆绑了以下策略：</target>
        </trans-unit>
        <trans-unit id="294af73d6b365f57dad5fbc1d213db079ecf007c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@Canonical&lt;/code&gt; meta-annotation combines the &lt;code&gt;@EqualsAndHashCode&lt;/code&gt;, &lt;code&gt;@ToString&lt;/code&gt; and &lt;code&gt;@TupleConstructor&lt;/code&gt; annotations. It is used to assist in the creation of mutable classes. It instructs the compiler to execute AST transformations which add positional constructors, equals, hashCode and a pretty print toString to your class.</source>
          <target state="translated">该 &lt;code&gt;@Canonical&lt;/code&gt; 元注释结合了 &lt;code&gt;@EqualsAndHashCode&lt;/code&gt; ， &lt;code&gt;@ToString&lt;/code&gt; 和 &lt;code&gt;@TupleConstructor&lt;/code&gt; 注解。它用于协助创建可变的类。它指示编译器执行AST转换，该转换向您的类添加位置构造函数，equals，hashCode和漂亮的toString。</target>
        </trans-unit>
        <trans-unit id="e0722e38b1652aaa50007eeaae20094f5d8fdb78" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@EqualsAndHashCode&lt;/code&gt; annotation instructs the compiler to execute an AST transformation which adds the necessary equals and hashCode methods to the class.</source>
          <target state="translated">该 &lt;code&gt;@EqualsAndHashCode&lt;/code&gt; 注释指示编译器执行AST转换这增加了必要的equals和hashCode方法的类。</target>
        </trans-unit>
        <trans-unit id="256900570749f03c52bd249de8a600a89e77be38" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@Immutable&lt;/code&gt; meta-annotation corresponds to adding the following annotations: &lt;a href=&quot;tostring&quot;&gt;ToString&lt;/a&gt;, &lt;a href=&quot;equalsandhashcode&quot;&gt;EqualsAndHashCode&lt;/a&gt;, &lt;a href=&quot;immutablebase&quot;&gt;ImmutableBase&lt;/a&gt;, &lt;a href=&quot;immutableoptions&quot;&gt;ImmutableOptions&lt;/a&gt;, &lt;a href=&quot;propertyoptions&quot;&gt;PropertyOptions&lt;/a&gt;, &lt;a href=&quot;tupleconstructor&quot;&gt;TupleConstructor&lt;/a&gt;, &lt;a href=&quot;mapconstructor&quot;&gt;MapConstructor&lt;/a&gt; and &lt;a href=&quot;knownimmutable&quot;&gt;KnownImmutable&lt;/a&gt;. Together these annotations instruct the compiler to execute the necessary transformations to add the necessary getters, constructors, equals, hashCode and other helper methods that are typically written when creating immutable classes with the defined properties.</source>
          <target state="translated">所述 &lt;code&gt;@Immutable&lt;/code&gt; 元注释对应于加入以下注释：&lt;a href=&quot;tostring&quot;&gt;的ToString&lt;/a&gt;，&lt;a href=&quot;equalsandhashcode&quot;&gt;EqualsAndHashCode&lt;/a&gt;，&lt;a href=&quot;immutablebase&quot;&gt;ImmutableBase&lt;/a&gt;，&lt;a href=&quot;immutableoptions&quot;&gt;ImmutableOptions&lt;/a&gt;，&lt;a href=&quot;propertyoptions&quot;&gt;PropertyOptions&lt;/a&gt;，&lt;a href=&quot;tupleconstructor&quot;&gt;TupleConstructor&lt;/a&gt;，&lt;a href=&quot;mapconstructor&quot;&gt;MapConstructor&lt;/a&gt;和&lt;a href=&quot;knownimmutable&quot;&gt;KnownImmutable&lt;/a&gt;。这些批注一起指示编译器执行必要的转换，以添加必要的getter，构造函数，equals，hashCode和其他帮助程序方法，这些方法通常是在创建具有已定义属性的不可变类时编写的。</target>
        </trans-unit>
        <trans-unit id="9b3e01603be93f6ac5cc7246179a9d14cdfcb6f2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@Immutable&lt;/code&gt; transformation in earlier versions of Groovy tried to be smart in the case of an immutable class with a single HashMap property, the supplied Map constructor tried to be compatible with both expected tuple behavior and expected named-argument behavior by peeking into the supplied map and guessing as to which approach might be applicable. Recent versions of Groovy now allow both &lt;code&gt;@TupleConstructor&lt;/code&gt; and &lt;code&gt;@MapConstructor&lt;/code&gt; annotations to co-exist which provide's a more flexible solution to this problem. While more flexible, the new approach isn't fully compatible with the previous approach. If for some reason you need the old behavior, you can try this property handler. Some features of the new approach won't be available to you.</source>
          <target state="translated">在具有单个HashMap属性的不可变类的情况下，Groovy的早期版本中的 &lt;code&gt;@Immutable&lt;/code&gt; 转换试图变得聪明，所提供的Map构造函数通过窥视所提供的内容，尝试与预期的元组行为和预期的命名参数行为兼容映射并猜测哪种方法可能适用。 Groovy的最新版本现在允许 &lt;code&gt;@TupleConstructor&lt;/code&gt; 和 &lt;code&gt;@MapConstructor&lt;/code&gt; 批注共存，这为该问题提供了更灵活的解决方案。新方法虽然更灵活，但与以前的方法并不完全兼容。如果由于某种原因您需要旧的行为，则可以尝试使用此属性处理程序。您将无法使用新方法的某些功能。</target>
        </trans-unit>
        <trans-unit id="8038db35abbd1b507d6ae9f58cbd615d327ce3a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@ImmutableBase&lt;/code&gt; annotation supports customization using &lt;code&gt;@PropertyOptions&lt;/code&gt; which allows a custom property handler to be defined. This is most typically used behind the scenes by the &lt;code&gt;@Immutable&lt;/code&gt; meta-annotation but you can also define your own handler. If a custom handler is present, it will determine the code generated for the getters and setters of any property.</source>
          <target state="translated">所述 &lt;code&gt;@ImmutableBase&lt;/code&gt; 注解支持定制使用 &lt;code&gt;@PropertyOptions&lt;/code&gt; 其允许定义自定义属性的处理程序。 &lt;code&gt;@Immutable&lt;/code&gt; 元注释通常在幕后使用此方法，但您也可以定义自己的处理程序。如果存在自定义处理程序，它将确定为任何属性的getter和setter生成的代码。</target>
        </trans-unit>
        <trans-unit id="d660a9beb8629948ffda2454e012fd620ba319c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@MapConstructor&lt;/code&gt; annotation generates a public constructor unless an applicable &lt;a href=&quot;visibilityoptions&quot;&gt;VisibilityOptions&lt;/a&gt; annotation is also present. It can be useful to change the visibility if you want to also create a builder or provide your own static factory method for object creation. You can make the constructor private and access it from the builder or your factory method. (Note: you'll probably want to use &lt;code&gt;@CompileStatic&lt;/code&gt; in conjunction with such an approach since dynamic Groovy currently gives the ability to access even private constructors.)</source>
          <target state="translated">所述 &lt;code&gt;@MapConstructor&lt;/code&gt; 除非适用的注释生成的公共构造&lt;a href=&quot;visibilityoptions&quot;&gt;VisibilityOptions&lt;/a&gt;注释也存在。如果您还想创建一个生成器或提供自己的静态工厂方法来创建对象，那么更改可见性可能很有用。您可以将构造函数设为私有，然后从生成器或工厂方法中对其进行访问。（注意：您可能需要将 &lt;code&gt;@CompileStatic&lt;/code&gt; 与这种方法结合使用，因为动态Groovy当前提供了甚至访问私有构造函数的能力。）</target>
        </trans-unit>
        <trans-unit id="0c060668381620633145cbb9ddc60d4b01c27127" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@MapConstructor&lt;/code&gt; annotation instructs the compiler to execute an AST transformation which adds the necessary constructor method to your class.</source>
          <target state="translated">该 &lt;code&gt;@MapConstructor&lt;/code&gt; 注释指示编译器执行AST转换这增加了必要的构造方法类。</target>
        </trans-unit>
        <trans-unit id="5d30fb89bfdef972798dad631327fddec3510e19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@MapConstructor&lt;/code&gt; annotation supports customization using &lt;code&gt;@PropertyOptions&lt;/code&gt; which allows a custom property handler to be defined. This is most typically used behind the scenes by the &lt;code&gt;@Immutable&lt;/code&gt; meta-annotation but you can also define your own handler. If a custom handler is present, it will determine the code generated when initializing any property (or field).</source>
          <target state="translated">所述 &lt;code&gt;@MapConstructor&lt;/code&gt; 注解支持定制使用 &lt;code&gt;@PropertyOptions&lt;/code&gt; 其允许定义自定义属性的处理程序。 &lt;code&gt;@Immutable&lt;/code&gt; 元注释通常在幕后使用此方法，但您也可以定义自己的处理程序。如果存在自定义处理程序，它将确定初始化任何属性（或字段）时生成的代码。</target>
        </trans-unit>
        <trans-unit id="7a6deaa7aa228067bb49f0cfb27c83f7ba76b6ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@TupleConstructor&lt;/code&gt; annotation generates a public constructor unless an applicable &lt;a href=&quot;visibilityoptions&quot;&gt;VisibilityOptions&lt;/a&gt; annotation is also present. It can be useful to change the visibility if you want to also create a builder or provide your own static factory method for object creation. You can make the constructor private and access it from the builder or your factory method. (Note: you'll probably want to use &lt;code&gt;@CompileStatic&lt;/code&gt; in conjunction with such an approach since dynamic Groovy currently gives the ability to access even private constructors.)</source>
          <target state="translated">所述 &lt;code&gt;@TupleConstructor&lt;/code&gt; 除非适用的注释生成的公共构造&lt;a href=&quot;visibilityoptions&quot;&gt;VisibilityOptions&lt;/a&gt;注释也存在。如果您还想创建一个生成器或提供自己的静态工厂方法来创建对象，那么更改可见性可能很有用。您可以将构造函数设为私有，然后从生成器或工厂方法中对其进行访问。（注意：您可能需要将 &lt;code&gt;@CompileStatic&lt;/code&gt; 与这种方法结合使用，因为动态Groovy当前提供了甚至访问私有构造函数的能力。）</target>
        </trans-unit>
        <trans-unit id="7629884aa207cf4bfc51ba4ddfb30667cd6e46a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@TupleConstructor&lt;/code&gt; annotation instructs the compiler to execute an AST transformation which adds the necessary constructor method to your class.</source>
          <target state="translated">该 &lt;code&gt;@TupleConstructor&lt;/code&gt; 注释指示编译器执行AST转换这增加了必要的构造方法类。</target>
        </trans-unit>
        <trans-unit id="e8727009d134e37d65711ed260dc01f84627258d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@TupleConstructor&lt;/code&gt; annotation supports customization using &lt;code&gt;@PropertyOptions&lt;/code&gt; which allows a custom property handler to be defined. This is most typically used behind the scenes by the &lt;code&gt;@Immutable&lt;/code&gt; meta-annotation but you can also define your own handler. If a custom handler is present, it will determine the code generated when initializing any property (or field).</source>
          <target state="translated">所述 &lt;code&gt;@TupleConstructor&lt;/code&gt; 注解支持定制使用 &lt;code&gt;@PropertyOptions&lt;/code&gt; 其允许定义自定义属性的处理程序。 &lt;code&gt;@Immutable&lt;/code&gt; 元注释通常在幕后使用此方法，但您也可以定义自己的处理程序。如果存在自定义处理程序，它将确定初始化任何属性（或字段）时生成的代码。</target>
        </trans-unit>
        <trans-unit id="2c9da3c536494482e7240624f6308d8ee06c6f86" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LineColumnReader&lt;/code&gt; is an extension to &lt;code&gt;BufferedReader&lt;/code&gt; that keeps track of the line and column information of where the cursor is.</source>
          <target state="translated">所述 &lt;code&gt;LineColumnReader&lt;/code&gt; 是一个扩展 &lt;code&gt;BufferedReader&lt;/code&gt; 该跟踪的光标所在行与列信息。</target>
        </trans-unit>
        <trans-unit id="b12d0acf730deb6bf7ba2f89201e89542b2f1843" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;equals()&lt;/code&gt; method compares the values of the individual properties (and optionally fields) of the class. It can also optionally call equals on the super class. Two different equals method implementations are supported both of which support the equals contract outlined in the javadoc for &lt;code&gt;java.lang.Object&lt;/code&gt;</source>
          <target state="translated">所述 &lt;code&gt;equals()&lt;/code&gt; 方法比较类的各特性（以及任选字段）的值。它还可以选择在超类上调用equals。支持两种不同的equals方法实现，这两种都支持javadoc中针对 &lt;code&gt;java.lang.Object&lt;/code&gt; 概述的equals契约。</target>
        </trans-unit>
        <trans-unit id="830e28331ecb056779521290049a9d298a9e660d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hashCode()&lt;/code&gt; method is calculated using Groovy's &lt;code&gt;HashCodeHelper&lt;/code&gt; class which implements an algorithm similar to the one outlined in the book &lt;em&gt;Effective Java&lt;/em&gt;.</source>
          <target state="translated">该 &lt;code&gt;hashCode()&lt;/code&gt; 方法是使用Groovy的计算 &lt;code&gt;HashCodeHelper&lt;/code&gt; 它实现类似于本书所描述的一个算法类&lt;em&gt;有效的Java&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="6e63d7611eab2d457e68aebe6268ff6c3ef50435" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;node&lt;/code&gt; variable refers to the AST node where the AST test annotation is put. In the previous example, it means that</source>
          <target state="translated">的 &lt;code&gt;node&lt;/code&gt; 的变量是指其中AST测试注释被放在AST节点。在上一个示例中，这意味着</target>
        </trans-unit>
        <trans-unit id="80313a71d12f637fc87968a63153d3f3e87a0de9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prefix&lt;/code&gt; annotation attribute can be used to create setters with a different naming convention, e.g. with the prefix set to the empty String, you would use your setters as follows:</source>
          <target state="translated">该 &lt;code&gt;prefix&lt;/code&gt; 标注属性可以被用来创建设置方法具有不同的命名约定，如带有前缀设置为空字符串，你可以使用你的setter方法如下：</target>
        </trans-unit>
        <trans-unit id="62dadbb05ea9452a3f8698171e4c3c5adf50c815" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prefix&lt;/code&gt; annotation attribute can be used to create setters with a different naming convention. The default is the empty string but you could change that to &quot;set&quot; as follows:</source>
          <target state="translated">该 &lt;code&gt;prefix&lt;/code&gt; 标注属性可以被用来与不同的命名约定创建setter方法。默认值为空字符串，但您可以将其更改为&amp;ldquo; set&amp;rdquo;，如下所示：</target>
        </trans-unit>
        <trans-unit id="c7e7da8f8ac1f58f269f14f2223d6021171e84d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prefix&lt;/code&gt; annotation attribute, which defaults to the empty String for this strategy, can be used to create setters with a different naming convention, e.g. with the &lt;code&gt;prefix&lt;/code&gt; changed to 'set', you would use your setters as follows:</source>
          <target state="translated">该 &lt;code&gt;prefix&lt;/code&gt; 标注属性，其默认为这一战略空字符串，可以用来与不同的命名约定，例如，与创建制定者 &lt;code&gt;prefix&lt;/code&gt; 变为&amp;ldquo;设置&amp;rdquo;，你会用你的setter方法如下：</target>
        </trans-unit>
        <trans-unit id="530333b1471c9924eaa79d5f2383b3a99efb7aa0" translate="yes" xml:space="preserve">
          <source>The ASM api version to use when loading/parsing classes, and generating proxy adapter classes.</source>
          <target state="translated">当加载/解析类和生成代理适配器类时要使用的ASM api版本。</target>
        </trans-unit>
        <trans-unit id="eacac5260137714b68dfd32df8448636a7cd8c2e" translate="yes" xml:space="preserve">
          <source>The AST transformations state data.</source>
          <target state="translated">AST变换状态数据。</target>
        </trans-unit>
        <trans-unit id="bc5bdb44ecff5ba8f2ac6aeacb93c47323537a4b" translate="yes" xml:space="preserve">
          <source>The AnnotationCollector can be used to define aliases for groups of annotations. The Alias needs to be a class or annotation annotated with AnnotationCollector, otherwise nothing is required. The alias will be replaced on the AST level and will never appear in later. Any members of the class or annotation will be ignored, but could be used by a custom processor. Annotation arguments are mapped to the aliased annotations if existing. Should the default processor not be able to map one of the arguments and error will be given. Is this not wished or if you want a different mapping a custom processor has to be used. There are two ways of using the alias. The first way is by providing the annotations as list/array:</source>
          <target state="translated">AnnotationCollector可以用来定义注解组的别名。别名需要是用AnnotationCollector注释的类或注解,否则什么都不需要。别名将在AST级别上被替换,并且永远不会出现在以后。类或注解的任何成员将被忽略,但可以被自定义处理器使用。如果存在的话,注解参数会被映射到别名的注解上。如果默认处理器不能映射其中一个参数,则会给出错误信息。如果您不希望这样做,或者您想要一个不同的映射,就必须使用自定义处理器。有两种方法可以使用别名。第一种方法是以列表/数组的形式提供注释。</target>
        </trans-unit>
        <trans-unit id="5db2cc4cf1581ed432c22532522a07af4f3dc21e" translate="yes" xml:space="preserve">
          <source>The AstBuilder &quot;from code&quot; approach is used with a single Closure parameter. This transformation converts the ClosureExpression back into source code and rewrites the AST so that the &quot;from string&quot; builder is invoked on the source. In order for this to work, the closure source must be given a goto label. It is the &quot;from string&quot; approach's responsibility to remove the BlockStatement created by the label.</source>
          <target state="translated">AstBuilder的 &quot;from code &quot;方法是用一个Closure参数来实现的。这种转换将ClosureExpression转换回源代码,并重写AST,使 &quot;from string &quot;构建器在源上被调用。为了使之工作,闭包源必须被赋予一个goto标签。&quot;from string &quot;方法的责任是删除标签创建的BlockStatement。</target>
        </trans-unit>
        <trans-unit id="ba44980ebcb878656a29fe22ac4f96efa9fe21fd" translate="yes" xml:space="preserve">
          <source>The AstBuilder provides several ways to build an abstract syntax tree (AST) of Groovy code. You can convert a String into AST using the buildFromString method. You can convert code into AST using the buildFromCode method. You can use the AST DSL with the buildFromSpec method. For more information, see the resources on the Groovy wiki pages.</source>
          <target state="translated">AstBuilder提供了几种方法来构建Groovy代码的抽象语法树(AST)。你可以使用buildFromString方法将一个字符串转换为AST。你可以使用buildFromCode方法将代码转换为AST。你可以用buildFromSpec方法使用AST DSL。更多信息,请参见Groovy wiki页面上的资源。</target>
        </trans-unit>
        <trans-unit id="dab7488dc458ebefa3af6c5f3c52ee882f8cbada" translate="yes" xml:space="preserve">
          <source>The Boolean value</source>
          <target state="translated">布尔值</target>
        </trans-unit>
        <trans-unit id="2c8b0170c089fc67b7592e8b879b1010a6efb451" translate="yes" xml:space="preserve">
          <source>The Class of the caller</source>
          <target state="translated">呼叫者的类别</target>
        </trans-unit>
        <trans-unit id="ea5ebdb121347917420d0529564950593f68fffa" translate="yes" xml:space="preserve">
          <source>The Class of the matched caller, or null if there aren't enough stackframes to satisfy matchLevel</source>
          <target state="translated">匹配的调用者的类,如果没有足够的堆栈帧来满足matchLevel,则为空。</target>
        </trans-unit>
        <trans-unit id="95afa2b448d534d00f17faabf8897f23ba200f8d" translate="yes" xml:space="preserve">
          <source>The ClassLoader to use during processing</source>
          <target state="translated">处理过程中要使用的ClassLoader</target>
        </trans-unit>
        <trans-unit id="3b325fd56fcb36df68df5c37735a434ab8c3e5a2" translate="yes" xml:space="preserve">
          <source>The Closure and Class MetaClasses are not replaceable.</source>
          <target state="translated">Closure和Class MetaClass是不可替代的。</target>
        </trans-unit>
        <trans-unit id="1f74d6daad2d2751944e6a7ff0057497d3e5b83e" translate="yes" xml:space="preserve">
          <source>The CompilationUnit collects all compilation data as it is generated by the compiler system. You can use this object to add additional source units to the compilation, or force the compilation to be run again (to affect only the deltas).</source>
          <target state="translated">CompilationUnit收集编译系统生成的所有编译数据。你可以使用这个对象为编译添加额外的源单元,或者强制编译再次运行(只影响deltas)。</target>
        </trans-unit>
        <trans-unit id="9ae7fb01344a3870d231b2e7c5bef8b061d095f8" translate="yes" xml:space="preserve">
          <source>The ConfigObject instance</source>
          <target state="translated">配置对象实例</target>
        </trans-unit>
        <trans-unit id="86d6344f85a9a90bbe2e3c76743d0dab1644efa3" translate="yes" xml:space="preserve">
          <source>The GPathResult instance created by consuming a stream of SAX events Note if one of the parse methods has been called then this returns null Note if this is called more than once all calls after the first will return null</source>
          <target state="translated">通过消耗SAX事件流创建的GPathResult实例 注意,如果其中一个解析方法被调用,那么该实例将返回null 注意,如果该实例被调用不止一次,则第一次调用之后的所有调用将返回null</target>
        </trans-unit>
        <trans-unit id="a1403f3f787db7ae0a251e57befceef1c173042a" translate="yes" xml:space="preserve">
          <source>The Generated annotation is used to mark members that have been generated.</source>
          <target state="translated">生成的注解用于标记已经生成的成员。</target>
        </trans-unit>
        <trans-unit id="fee67b5a59c37f5eb850f04f216505b0ee5359f8" translate="yes" xml:space="preserve">
          <source>The Groovyc Ant task is frequently used in the context of a build system that knows the complete list of source files to be compiled. In such a context, it is wasteful for the Groovy compiler to go searching the classpath when looking for source files and hence by default the Groovyc Ant task calls the compiler in a special mode with such searching turned off. If you wish the compiler to search for source files then you need to set this flag to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Groovyc Ant任务经常在知道要编译的源文件的完整列表的构建系统的上下文中使用。在这种情况下，Groovy编译器在查找源文件时去搜索类路径是很浪费的，因此，默认情况下，Groovyc Ant任务在关闭这种搜索的特殊模式下调用编译器。如果希望编译器搜索源文件，则需要将此标志设置为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8a572e6d63360dc8ed46fe486e95453148a82ab3" translate="yes" xml:space="preserve">
          <source>The I/O container for the command to spit stuff out.</source>
          <target state="translated">命令吐出东西的I/O容器。</target>
        </trans-unit>
        <trans-unit id="9eac464c463300041620f1317542a0b36de1c9f1" translate="yes" xml:space="preserve">
          <source>The Inspector provides a unified access to an object's information that can be determined by introspection.</source>
          <target state="translated">检查员提供了一个统一的访问对象的信息,可以通过反省来确定。</target>
        </trans-unit>
        <trans-unit id="89049d18696c55626bdc93e465d8d30137733d5c" translate="yes" xml:space="preserve">
          <source>The Internal annotation is used to mark members that are internal.</source>
          <target state="translated">内部注释用于标记内部的成员。</target>
        </trans-unit>
        <trans-unit id="9590c78dcd06317a3989b6bc16c6e0ac5dd7bc8d" translate="yes" xml:space="preserve">
          <source>The JDBC data type.</source>
          <target state="translated">JDBC数据类型。</target>
        </trans-unit>
        <trans-unit id="bf1f48ddb64e5b808db4de3d772bd99c631f4770" translate="yes" xml:space="preserve">
          <source>The JDK Home to use when forked.</source>
          <target state="translated">分叉时要使用的JDK Home。</target>
        </trans-unit>
        <trans-unit id="a3cddd13c50bb85bd71529142341665bd0b10ae0" translate="yes" xml:space="preserve">
          <source>The JDK Home to use when forked. Ignored if &quot;executable&quot; is specified.</source>
          <target state="translated">分叉时要使用的JDK主页。如果指定了 &quot;可执行&quot;,则忽略。</target>
        </trans-unit>
        <trans-unit id="73a1a508d0e588f700050a09964ef490424aaf02" translate="yes" xml:space="preserve">
          <source>The JSON builder implements the &lt;code&gt;Writable&lt;/code&gt; interface, so that you can have the builder serialize itself the JSON payload to a writer.</source>
          <target state="translated">JSON构建器实现 &lt;code&gt;Writable&lt;/code&gt; 接口，以便您可以使构建器将JSON有效负载自身序列化到编写器。</target>
        </trans-unit>
        <trans-unit id="c4210607df0d96c450f5b18b723cad635f89b1b1" translate="yes" xml:space="preserve">
          <source>The Java class enhanced by this MetaClass</source>
          <target state="translated">由这个MetaClass增强的Java类</target>
        </trans-unit>
        <trans-unit id="1ac137cd80780692f3c909dfbfd354042b337fa0" translate="yes" xml:space="preserve">
          <source>The JavaBean class should have a no-args constructor.</source>
          <target state="translated">JavaBean类应该有一个无参数的构造函数。</target>
        </trans-unit>
        <trans-unit id="dd439d1414bf7dc6b93f52c0dc2f310499844e0e" translate="yes" xml:space="preserve">
          <source>The JmxBeanInfoManager creates fully-described model mbean info object using the underlying meta map. The MBeanInfo object is used to provide description about the actual exported MBean instance.</source>
          <target state="translated">JmxBeanInfoManager使用底层元映射创建完全描述的模型mbean信息对象。MBeanInfo对象用于提供关于实际导出的MBean实例的描述。</target>
        </trans-unit>
        <trans-unit id="872c671635593eaadcddb9effd4d01a4ea959ded" translate="yes" xml:space="preserve">
          <source>The JmxBuilderModelMBean is the MBean class that proxies exported POGO/POJO inside the MBeanServer. When JmxBuilder exports an object instance, an instance of this class is created and exported inside the MBeanServer.</source>
          <target state="translated">JmxBuilderModelMBean是MBean类,在MBeanServer内部代理导出的POGO/POJO。当JmxBuilder导出一个对象实例时,会在MBeanServer内部创建并导出这个类的实例。</target>
        </trans-unit>
        <trans-unit id="f935c6274b761a9b967dde493b59c201774e5020" translate="yes" xml:space="preserve">
          <source>The JmxEventEmitter is a JMX Broadcaster class that is used to send generic events on the MBeanServer's event bus. It is used by the Emitter node () to send event to registered listeners.</source>
          <target state="translated">JmxEventEmitter是一个JMX Broadcaster类,用于在MBeanServer的事件总线上发送通用事件。它被Emitter节点()用来向注册的监听器发送事件。</target>
        </trans-unit>
        <trans-unit id="0d08957bff2b6ad91314499adc0b8343bea9d846" translate="yes" xml:space="preserve">
          <source>The JmxEventListener class is used by the builder to listen to events on the event bus. It is used internally by JmxBuilder to handle attribute-change and operation-invoke events on the bean() node.</source>
          <target state="translated">JmxEventListener 类被 builder 用于监听事件总线上的事件。它被JmxBuilder内部用于处理bean()节点上的属性变化和操作调用事件。</target>
        </trans-unit>
        <trans-unit id="791c37595668d995bb3f7137a2837e7869f379f8" translate="yes" xml:space="preserve">
          <source>The JmxMetaMapBuilder class is used to collect meta data passed in JmxBuilder nodes. Once collected, the data is then normalized to be represented uniformly regardless of the resource where it was obtained.</source>
          <target state="translated">JmxMetaMapBuilder类用于收集JmxBuilder节点中传递的元数据。一旦收集到这些数据,这些数据就会被归一化,以统一表示,而不管这些数据是在哪个资源中获得的。</target>
        </trans-unit>
        <trans-unit id="e1cf8f8fe2a9841c47ea577375d10ab0b3a498ec" translate="yes" xml:space="preserve">
          <source>The JmxTimerFactory class generates a timer() node for JmxBuilder. This node crates a standard JMX Timer object that can be used to provide timing signals to registered JMX listeners.</source>
          <target state="translated">JmxTimerFactory 类为 JmxBuilder 生成一个 timer()节点。这个节点为JmxBuilder生成一个标准的JMX定时器对象,它可以用来为注册的JMX监听器提供定时信号。</target>
        </trans-unit>
        <trans-unit id="d1015aa5213030445b24890b5298e5c4b7fb29c4" translate="yes" xml:space="preserve">
          <source>The MetaClass</source>
          <target state="translated">元类</target>
        </trans-unit>
        <trans-unit id="70b9f38afa55b20e2322eb7214953e5ce4ce9d61" translate="yes" xml:space="preserve">
          <source>The MetaClass instance</source>
          <target state="translated">元类实例</target>
        </trans-unit>
        <trans-unit id="260db7c9ae9624cfa33762fdc9180e7061158fff" translate="yes" xml:space="preserve">
          <source>The MetaClassCreationHandle instance</source>
          <target state="translated">MetaClassCreationHandle实例</target>
        </trans-unit>
        <trans-unit id="304ce5f140b19a7e8c2ce15e0bd65caaaee29466" translate="yes" xml:space="preserve">
          <source>The MetaProperty or null if it doesn't exist</source>
          <target state="translated">元属性,如果不存在则为空。</target>
        </trans-unit>
        <trans-unit id="7243e642f153efeb15b0cd45bbbcf1e34d8e7b86" translate="yes" xml:space="preserve">
          <source>The Number corresponding to the addition of left and right</source>
          <target state="translated">左右相加所对应的数字。</target>
        </trans-unit>
        <trans-unit id="4aa3b37e69477a774d6c510b9eeda86f2a333e6a" translate="yes" xml:space="preserve">
          <source>The Object can either be an instance of the class that this MetaObjectProtocol instance applies to or the java.lang.Class instance itself. If a method cannot be invoked a MissingMethodException is will be thrown</source>
          <target state="translated">对象可以是这个MetaObjectProtocol实例所应用的类的实例,也可以是java.lang.Class实例本身。如果一个方法不能被调用,将抛出MissingMethodException异常。</target>
        </trans-unit>
        <trans-unit id="f01609e35830c98cb8147ed0a154760cc0327e1b" translate="yes" xml:space="preserve">
          <source>The PrintWriter to write the &lt;a href=&quot;#usage&quot;&gt;usage&lt;/a&gt; help message to when &lt;code&gt;cli.usage()&lt;/code&gt; is called.</source>
          <target state="translated">当 &lt;code&gt;cli.usage()&lt;/code&gt; 时将&lt;a href=&quot;#usage&quot;&gt;使用&lt;/a&gt;帮助消息写入的PrintWriter 。</target>
        </trans-unit>
        <trans-unit id="1ad7cb19c2bb4b46ecbb881cff1abf5fe7f4037b" translate="yes" xml:space="preserve">
          <source>The PrintWriter to write the &lt;a href=&quot;#usage&quot;&gt;usage&lt;/a&gt; help message to when &lt;code&gt;cli.usage()&lt;/code&gt; is called. Defaults to stdout but you can provide your own PrintWriter if desired.</source>
          <target state="translated">当 &lt;code&gt;cli.usage()&lt;/code&gt; 时将&lt;a href=&quot;#usage&quot;&gt;使用&lt;/a&gt;帮助消息写入的PrintWriter 。默认为stdout，但是如果需要，您可以提供自己的PrintWriter。</target>
        </trans-unit>
        <trans-unit id="f3c0b48403b15a903f91f5257a20030e1e3b89f0" translate="yes" xml:space="preserve">
          <source>The PrintWriter to write to when invalid user input was provided to the &lt;a href=&quot;#parse(java.lang.String)&quot;&gt;parse(java.lang.String[])&lt;/a&gt; method.</source>
          <target state="translated">当向&lt;a href=&quot;#parse(java.lang.String)&quot;&gt;parse（java.lang.String []）&lt;/a&gt;方法提供了无效的用户输入时要写入的PrintWriter 。</target>
        </trans-unit>
        <trans-unit id="127ae9cbb960e452f7333cb76a15c3f3dcc5fd90" translate="yes" xml:space="preserve">
          <source>The PrintWriter to write to when invalid user input was provided to the &lt;a href=&quot;#parse(java.lang.String)&quot;&gt;parse(java.lang.String[])&lt;/a&gt; method. Defaults to stderr but you can provide your own PrintWriter if desired.</source>
          <target state="translated">当向&lt;a href=&quot;#parse(java.lang.String)&quot;&gt;parse（java.lang.String []）&lt;/a&gt;方法提供了无效的用户输入时要写入的PrintWriter 。默认为stderr，但是如果需要，您可以提供自己的PrintWriter。</target>
        </trans-unit>
        <trans-unit id="7a802aa7bf26ec7a1cc42a344ad8a273e764c485" translate="yes" xml:space="preserve">
          <source>The Swing component being edited.</source>
          <target state="translated">正在编辑的Swing组件。</target>
        </trans-unit>
        <trans-unit id="bdb2fc7e68bc1e57e68935cf223ed7a03e6b0e67" translate="yes" xml:space="preserve">
          <source>The System Property to set as a filename excludes pattern for collection of Classes.</source>
          <target state="translated">系统属性设置为Classes集合的文件名不包括模式。</target>
        </trans-unit>
        <trans-unit id="6a1909fe3c15f658c03287f53b875168b744419d" translate="yes" xml:space="preserve">
          <source>The System Property to set as a filename excludes pattern for collection of Classes. When non-empty, the pattern will be used as Regular Expression pattern applied with the find operator against each candidate file.path. Key is &quot;javadocAssertion.src.excludesPattern&quot;. Default value is &quot;&quot;.</source>
          <target state="translated">系统属性设置为文件名,排除Classes集合的模式。当非空时,该模式将被用作正则表达式模式,对每个候选文件.路径使用查找操作符。关键是 &quot;javadocAssertion.src.excludesPattern&quot;。默认值是&quot;&quot;。</target>
        </trans-unit>
        <trans-unit id="6e2f804b26b209506ffe905e468265879b10275e" translate="yes" xml:space="preserve">
          <source>The System Property to set as a filename excludes pattern for collection of Test Cases.</source>
          <target state="translated">系统属性设置为文件名,排除测试用例集合的模式。</target>
        </trans-unit>
        <trans-unit id="b63561856de11fdd61e36dc53031f4a4c5c9997a" translate="yes" xml:space="preserve">
          <source>The System Property to set as a filename excludes pattern for collection of Test Cases. When non-empty, the pattern will be used as Regular Expression pattern applied with the find operator against each candidate file.path. Key is &quot;groovy.test.excludesPattern&quot;. Default value is &quot;&quot;.</source>
          <target state="translated">系统属性设置为文件名,排除测试用例集合的模式,当非空时,模式将作为正则表达式模式,对每个候选文件.路径应用查找运算符。当非空时,该模式将被用作正则表达式模式,对每个候选文件.路径使用查找操作符。关键是 &quot;groovy.test.excludesPattern&quot;。默认值是&quot;&quot;。</target>
        </trans-unit>
        <trans-unit id="47b09e49327c616d7dfdf39837fa8bd53af76f55" translate="yes" xml:space="preserve">
          <source>The System Property to set as base directory for collection of Classes.</source>
          <target state="translated">设置为Classes集合的基础目录的系统属性。</target>
        </trans-unit>
        <trans-unit id="4eeea8df2c671b1aaf1f285764880655e10de1e1" translate="yes" xml:space="preserve">
          <source>The System Property to set as base directory for collection of Classes. The pattern will be used as an Ant fileset include basedir. Key is &quot;javadocAssertion.src.dir&quot;. Defaults to the &lt;code&gt;./src&lt;/code&gt; directory</source>
          <target state="translated">设置为收集类的基本目录的系统属性。该模式将用作Ant文件集include basedir。关键字是&amp;ldquo; javadocAssertion.src.dir&amp;rdquo;。默认为 &lt;code&gt;./src&lt;/code&gt; 目录</target>
        </trans-unit>
        <trans-unit id="3bf415e47865f7516d23e95370920077c48370ee" translate="yes" xml:space="preserve">
          <source>The System Property to set as base directory for collection of Test Cases.</source>
          <target state="translated">系统属性,设置为测试用例集合的基本目录。</target>
        </trans-unit>
        <trans-unit id="31447f96bb70b187e7844f2b264f55c03201f601" translate="yes" xml:space="preserve">
          <source>The System Property to set as base directory for collection of Test Cases. The pattern will be used as an Ant fileset include basedir. Key is &quot;groovy.test.dir&quot;. Default value is &quot;./test/&quot;.</source>
          <target state="translated">系统属性,设置为测试用例集合的基础目录。该模式将作为Ant文件集include basedir使用。键是 &quot;groovy.test.dir&quot;。默认值是&quot;./test/&quot;。</target>
        </trans-unit>
        <trans-unit id="266958bc55466288051a176e383496d4feb92e74" translate="yes" xml:space="preserve">
          <source>The System Property to set as the filename pattern for collection of Classes.</source>
          <target state="translated">系统属性,设置为Classes集合的文件名模式。</target>
        </trans-unit>
        <trans-unit id="2a90fedae02d009a3ffad52f02ac8b7d11b8745b" translate="yes" xml:space="preserve">
          <source>The System Property to set as the filename pattern for collection of Classes. The pattern will be used as Regular Expression pattern applied with the find operator against each candidate file.path. Key is &quot;javadocAssertion.src.pattern&quot;. Defaults to including all &lt;code&gt;.java&lt;/code&gt; and &lt;code&gt;.groovy&lt;/code&gt; files.</source>
          <target state="translated">设置为用于收集类的文件名模式的系统属性。该模式将用作正则表达式模式，并与针对每个候选file.path的find运算符一起应用。关键字是&amp;ldquo; javadocAssertion.src.pattern&amp;rdquo;。默认情况下包括所有 &lt;code&gt;.java&lt;/code&gt; 和 &lt;code&gt;.groovy&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="0000bd75ba6a74e57ac9cf53044c50c3c9d010ff" translate="yes" xml:space="preserve">
          <source>The System Property to set as the filename pattern for collection of Test Cases.</source>
          <target state="translated">系统属性,设置为测试用例集合的文件名模式。</target>
        </trans-unit>
        <trans-unit id="998db7b8bbfcee3c949aa177d7b90b7dfdb69720" translate="yes" xml:space="preserve">
          <source>The System Property to set as the filename pattern for collection of Test Cases. The pattern will be used as Regular Expression pattern applied with the find operator against each candidate file.path. Key is &quot;groovy.test.pattern&quot;. Default value is &quot;Test.groovy&quot;.</source>
          <target state="translated">系统属性,设置为测试用例集合的文件名模式。该模式将被用作正则表达式模式,对每个候选文件.路径使用查找操作符。关键是 &quot;groovy.test.pattern&quot;,默认值是 &quot;Test.groovy&quot;。默认值是 &quot;Test.groovy&quot;。</target>
        </trans-unit>
        <trans-unit id="84337e91be9e8ef75be1d04b6fdba516cbd8151f" translate="yes" xml:space="preserve">
          <source>The TimeUnit of the value parameter.</source>
          <target state="translated">值参数的时间单位。</target>
        </trans-unit>
        <trans-unit id="718e7ae897428930781dc6de636d2e594031a23c" translate="yes" xml:space="preserve">
          <source>The TimeUnit of the value parameter. By default it is TimeUnit.SECONDS.</source>
          <target state="translated">值参数的时间单位。默认为TimeUnit.SECONDS。</target>
        </trans-unit>
        <trans-unit id="c92a8a6f01fd8d4e068bc1d01714e753c4596b32" translate="yes" xml:space="preserve">
          <source>The URL for a repo containing the grape/artifact.</source>
          <target state="translated">包含葡萄/人工制品的回购的URL。</target>
        </trans-unit>
        <trans-unit id="de6a560d5da664892b518e4682d24979363ecddc" translate="yes" xml:space="preserve">
          <source>The URL for a repo containing the grape/artifact. A non-empty value is required unless value() is used.</source>
          <target state="translated">包含葡萄/工件的repo的URL。除非使用value(),否则必须使用非空值。</target>
        </trans-unit>
        <trans-unit id="b6aadb5f5ba9e2b129360252950ed1939f90ac0b" translate="yes" xml:space="preserve">
          <source>The URL pattern does not require the &quot;*.groovy&quot; mapping. You can, for example, make it more Struts-like but groovy by making your mapping &quot;*.gdo&quot;.</source>
          <target state="translated">URL模式并不要求使用 &quot;*.groovy &quot;映射。例如,你可以将你的映射设置为 &quot;*.gdo&quot;,从而使它更像Struts,但又更像groovy。</target>
        </trans-unit>
        <trans-unit id="adca94d915cd2e4151b8eb5471618fdec37d9c2b" translate="yes" xml:space="preserve">
          <source>The XML template engine can also be used as the engine for &lt;a href=&quot;../servlet/templateservlet&quot;&gt;TemplateServlet&lt;/a&gt; by placing the following in your web.xml file (plus a corresponding servlet-mapping element):</source>
          <target state="translated">通过将以下内容放在web.xml文件中（以及相应的servlet-mapping元素），XML模板引擎也可以用作&lt;a href=&quot;../servlet/templateservlet&quot;&gt;TemplateServlet&lt;/a&gt;的引擎：</target>
        </trans-unit>
        <trans-unit id="d9495cf1739a07e775ac543e8d0f74d2f8dd5b54" translate="yes" xml:space="preserve">
          <source>The YAML builder implements the &lt;code&gt;Writable&lt;/code&gt; interface, so that you can have the builder serialize itself the YAML payload to a writer.</source>
          <target state="translated">YAML构建器实现 &lt;code&gt;Writable&lt;/code&gt; 接口，以便您可以使构建器将YAML有效载荷自身序列化到编写器。</target>
        </trans-unit>
        <trans-unit id="a412e1e1d8cd3a68e2efff325b41048db7ad21bd" translate="yes" xml:space="preserve">
          <source>The above example prints this to standard output:</source>
          <target state="translated">上面的例子将其打印成标准输出。</target>
        </trans-unit>
        <trans-unit id="ec91d8d1308de75b03d0376ac9545cec66180c83" translate="yes" xml:space="preserve">
          <source>The above example will generate code that is similar to the next snippet. Notice the difference between a String property and a def/Object property:</source>
          <target state="translated">上面的例子将生成与下一个片段类似的代码。请注意String属性和def/Object属性之间的区别。</target>
        </trans-unit>
        <trans-unit id="b257bfac16ef28eecdac4b554708ae5f69748970" translate="yes" xml:space="preserve">
          <source>The actual number of characters skipped</source>
          <target state="translated">实际跳过的字符数</target>
        </trans-unit>
        <trans-unit id="052bfa45246c41d68e26ad806f4e38a47fba851d" translate="yes" xml:space="preserve">
          <source>The alternative supported style regards any kind of inheritance as creation of a new type and is illustrated in the following example:</source>
          <target state="translated">另一种支持的样式将任何形式的继承视为创建一个新类型,并在下面的例子中进行了说明。</target>
        </trans-unit>
        <trans-unit id="4bdb04cd00d0c115ee207c0ae5337f0b546086bb" translate="yes" xml:space="preserve">
          <source>The annotated Collection field must have a generic type</source>
          <target state="translated">注释的集合字段必须有一个通用的类型</target>
        </trans-unit>
        <trans-unit id="aceff9ab81f781b7ab6d9e62431c1055127d2723" translate="yes" xml:space="preserve">
          <source>The annotated Collection field must not have a generic wildcard declared</source>
          <target state="translated">注解的集合字段必须没有声明的通用通配符。</target>
        </trans-unit>
        <trans-unit id="9e547ff00f70b525a9f0ec9c47c86f3334dc81ae" translate="yes" xml:space="preserve">
          <source>The annotated variable will become a private field of the script class. The type of the field will be the same as the type of the variable. Example usage:</source>
          <target state="translated">注释的变量将成为脚本类的一个私有字段,字段的类型将与变量的类型相同。该字段的类型将与变量的类型相同。使用示例。</target>
        </trans-unit>
        <trans-unit id="f318a85f6a5756ab184456f34f3ce55011832330" translate="yes" xml:space="preserve">
          <source>The annotation being referenced.</source>
          <target state="translated">被引用的注释。</target>
        </trans-unit>
        <trans-unit id="5c20ea5b9d49bb4d3079400f6c7b508d5ddfe6c4" translate="yes" xml:space="preserve">
          <source>The annotation can be placed at the class level in which case it applies to all methods, constructors, and closures within the class and any inner classes. It can also be applied to an individual method, constructor, field with a Closure initial value or a Closure assigned to a local variable. In the case of fields (or local variables) it only adjusts the parameters of the referenced Closure not the field (or local variable) itself.</source>
          <target state="translated">注解可以放置在类的层面,在这种情况下,它适用于类和任何内部类中的所有方法、构造函数和闭包。它也可以应用于单个方法、构造函数、带有闭包初始值的字段或分配给局部变量的闭包。在字段(或局部变量)的情况下,它只调整被引用的 Closure 的参数,而不是字段(或局部变量)本身。</target>
        </trans-unit>
        <trans-unit id="9517f13d3119a99ae37232e6f8925dc3dc606f99" translate="yes" xml:space="preserve">
          <source>The annotation can be used on a whole class as shown above or selectively on a particular method, constructor or field.</source>
          <target state="translated">该注解可以如上图所示在整个类上使用,也可以选择性地在特定的方法、构造函数或字段上使用。</target>
        </trans-unit>
        <trans-unit id="9dcd4f54b47563f3bd43966ca8e9a4fbea0a7944" translate="yes" xml:space="preserve">
          <source>The annotation can take the following parameters:</source>
          <target state="translated">注释可以采用以下参数。</target>
        </trans-unit>
        <trans-unit id="06f750d18a3b109b97c136361abf51e190db88be" translate="yes" xml:space="preserve">
          <source>The annotation is intended to be used sparingly; perhaps in DSL scenarios or when using deeply nested structural types. In particular, there is no support for using the facility with two similarly named classes from different packages at the same time. Though it is OK to have different packages in different contexts. Also, there is no support for turning &quot;Ruby-style&quot; conversions off at the method, constructor or field level if already turned on at the class level.</source>
          <target state="translated">该注解旨在少用;或许在DSL场景中或使用深层嵌套结构类型时使用。特别是,不支持同时使用两个来自不同包的类似名称的类来使用该设施。尽管在不同的环境下,使用不同的包也是可以的。另外,如果已经在类级开启了 &quot;Ruby-style &quot;转换,则不支持在方法、构造函数或字段级关闭。</target>
        </trans-unit>
        <trans-unit id="3190b6c4518ac7ad1bc48cdc3e3e48499552b444" translate="yes" xml:space="preserve">
          <source>The annotation takes an optional parameter for the name of the field. This field must exist on the class and must be of type ReentrantReadWriteLock.</source>
          <target state="translated">注解需要一个可选的参数来表示字段的名称,这个字段必须存在于类中,并且必须是ReentrantReadWriteLock类型。这个字段必须存在于类中,并且必须是ReentrantReadWriteLock类型。</target>
        </trans-unit>
        <trans-unit id="6d2a41c58f84b983c4307e184fcf2882ccbdc7cf" translate="yes" xml:space="preserve">
          <source>The attribute value</source>
          <target state="translated">属性值</target>
        </trans-unit>
        <trans-unit id="dd9423271c2e0be1493ebeaf945a08093f8a561f" translate="yes" xml:space="preserve">
          <source>The attribute values of annotations must be primitive, String or Enum constants.</source>
          <target state="translated">注释的属性值必须是基元、字符串或Enum常量。</target>
        </trans-unit>
        <trans-unit id="e91a7321fc7ae255dea783ee8a8e3fd6aea9d2cb" translate="yes" xml:space="preserve">
          <source>The attribute values of annotations must be primitive, String or Enum constants. In various places, such constants can be seen during type resolution but won't be readily accessible in later phases, e.g. they might be embedded into constructor code. This method transforms constants that would appear in annotations early so they aren't lost. Subsequent processing determines whether they are valid, this method simply retains the constant value as a constant expression.</source>
          <target state="translated">注解的属性值必须是基元、String或Enum常量。在不同的地方,这些常量可以在类型解析期间看到,但在后期阶段不会轻易被访问,例如,它们可能被嵌入到构造函数代码中。这个方法可以在早期将出现在注释中的常量进行转换,这样它们就不会丢失。后续的处理决定它们是否有效,这个方法只是将常量值作为一个常量表达式保留下来。</target>
        </trans-unit>
        <trans-unit id="ba9d0f179fb12288dcac51469b2a074466e2e0af" translate="yes" xml:space="preserve">
          <source>The average of all of the items</source>
          <target state="translated">所有项目的平均数</target>
        </trans-unit>
        <trans-unit id="70783273967fb37a38f643afd98e6b9187891321" translate="yes" xml:space="preserve">
          <source>The average of the items</source>
          <target state="translated">项目的平均数</target>
        </trans-unit>
        <trans-unit id="8395f1aa4e19271ad68a33fd7315e6d494f3ac12" translate="yes" xml:space="preserve">
          <source>The average of the values returned by applying the closure to each item from the Iterator.</source>
          <target state="translated">对来自迭代器的每个项目应用闭包返回的值的平均值。</target>
        </trans-unit>
        <trans-unit id="3eb091fbf86b30307fd9a7fb7c9aaa700930da46" translate="yes" xml:space="preserve">
          <source>The average of the values returned by applying the closure to each item of the Iterable.</source>
          <target state="translated">对Iterable的每个项目应用闭包返回的值的平均值。</target>
        </trans-unit>
        <trans-unit id="7c9801aab1db27901fd7a9be59509eda4d8846c8" translate="yes" xml:space="preserve">
          <source>The average of the values returned by applying the closure to each item of the array.</source>
          <target state="translated">对数组中的每个项目应用闭包返回的值的平均值。</target>
        </trans-unit>
        <trans-unit id="4bbf0434c30c3cf5371d3ed8bebd25d1c43ff05a" translate="yes" xml:space="preserve">
          <source>The bind path object. This class represents one &quot;step&quot; in the bind path.</source>
          <target state="translated">绑定路径对象。该类代表绑定路径中的一个 &quot;步骤&quot;。</target>
        </trans-unit>
        <trans-unit id="4408519a715193017dfb9b02caa80e83767ca7d0" translate="yes" xml:space="preserve">
          <source>The binding also provides convenient methods:</source>
          <target state="translated">绑定也提供了方便的方法。</target>
        </trans-unit>
        <trans-unit id="1c8a6a5839bf78280f2f5d8f72a3b8f0dac48502" translate="yes" xml:space="preserve">
          <source>The binding provided by TemplateServlet does already include some default variables. As of this writing, they are (copied from &lt;a href=&quot;servletbinding&quot;&gt;ServletBinding&lt;/a&gt;):</source>
          <target state="translated">TemplateServlet提供的绑定已经包含一些默认变量。在撰写本文时，它们是（从&lt;a href=&quot;servletbinding&quot;&gt;ServletBinding&lt;/a&gt;复制的）：</target>
        </trans-unit>
        <trans-unit id="170305b27b6f2f428a171b71d8192fdfc6377fe8" translate="yes" xml:space="preserve">
          <source>The cached class.</source>
          <target state="translated">缓存类。</target>
        </trans-unit>
        <trans-unit id="3de13709d4a99443765990411d8804e7d936d4c5" translate="yes" xml:space="preserve">
          <source>The call should be invoked separately</source>
          <target state="translated">应单独调用</target>
        </trans-unit>
        <trans-unit id="fed53e69261b2dc331e4fdcb563927c92a857a5a" translate="yes" xml:space="preserve">
          <source>The character read, as an integer in the range 0 to 65535 (0x00-0xffff), or -1 if the end of the stream has been reached</source>
          <target state="translated">读取的字符,为整数,范围为0至65535 (0x00-0xffff),如果已经到达流的末端,则为-1。</target>
        </trans-unit>
        <trans-unit id="0b1006004394eb9f2a6da42ea7c5b946608b286e" translate="yes" xml:space="preserve">
          <source>The character used to split a single command line argument into parts.</source>
          <target state="translated">用于将单个命令行参数分割成若干部分的字符。</target>
        </trans-unit>
        <trans-unit id="e358d3e84c4ddc0c51dee898e085378748c11c44" translate="yes" xml:space="preserve">
          <source>The check works &lt;b&gt;only for options &lt;b&gt;one&lt;/b&gt; block below the current block. E.g. &lt;code&gt;config.isSet('foo.password')&lt;/code&gt; will always return false. &lt;dl&gt;
&lt;dt&gt;&lt;b&gt;Parameters:&lt;/b&gt;&lt;/dt&gt;
&lt;dd&gt;
&lt;code&gt;option&lt;/code&gt; - The name of the option&lt;/dd&gt;
&lt;/dl&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;b&gt;Returns:&lt;/b&gt;&lt;/dt&gt;
&lt;dd&gt;
&lt;code&gt;true&lt;/code&gt; if the option is set &lt;code&gt;false&lt;/code&gt; otherwise&lt;/dd&gt;
&lt;/dl&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;b&gt;Since:&lt;/b&gt;&lt;/dt&gt;
&lt;dd&gt;2.3.0&lt;/dd&gt;
&lt;/dl&gt; &lt;/b&gt;</source>
          <target state="translated">该检查&lt;b&gt;仅适用于当前块下方&lt;b&gt;一个&lt;/b&gt;块的选项。例如 &lt;code&gt;config.isSet('foo.password')&lt;/code&gt; 将始终返回false。 &lt;dl&gt; &lt;dt&gt; &lt;b&gt;参数：&lt;/b&gt; &lt;/dt&gt; &lt;dd&gt; &lt;code&gt;option&lt;/code&gt; -选项的名称 &lt;/dd&gt; &lt;/dl&gt; &lt;dl&gt; &lt;dt&gt; &lt;b&gt;返回值：&lt;/b&gt; &lt;/dt&gt; &lt;dd&gt; &lt;code&gt;true&lt;/code&gt; 如果该选项设置 &lt;code&gt;false&lt;/code&gt; ，否则 &lt;/dd&gt; &lt;/dl&gt; &lt;dl&gt; &lt;dt&gt; &lt;b&gt;自从：&lt;/b&gt; &lt;/dt&gt; &lt;dd&gt; 2.3.0 &lt;/dd&gt; &lt;/dl&gt; &lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="12f6e1d7ed0f1c99877990e1030d0f1489d503a8" translate="yes" xml:space="preserve">
          <source>The class contained by this metaclass</source>
          <target state="translated">这个元类所包含的类</target>
        </trans-unit>
        <trans-unit id="02889e40310a5938acf27d4e92b62a80c8bb0b34" translate="yes" xml:space="preserve">
          <source>The class is automatically made final.</source>
          <target state="translated">该班级自动成为决赛。</target>
        </trans-unit>
        <trans-unit id="d55ce426f3bc5d724c2889dfa22ff395fbda6a39" translate="yes" xml:space="preserve">
          <source>The class passed as a constructor parameter must be an AST transformation annotation. Alternatively, you can apply a global AST transformation by calling the &lt;a href=&quot;asttransformationcustomizer#ASTTransformationCustomizer(org.codehaus.groovy.transform.ASTTransformation)&quot;&gt;AST transformation&lt;/a&gt;. In that case, the transformation is applied once for the whole source unit. Unlike a global AST transformation declared in the META-INF/services/org.codehaus.groovy.transform.ASTTransformation file, which are applied if the file is in the classpath, using this customizer you'll have the choice to apply your transformation selectively. It can also be useful to debug global AST transformations without having to package your annotation in a jar file.</source>
          <target state="translated">作为构造函数参数传递的类必须是AST转换批注。或者，您可以通过调用&lt;a href=&quot;asttransformationcustomizer#ASTTransformationCustomizer(org.codehaus.groovy.transform.ASTTransformation)&quot;&gt;AST转换&lt;/a&gt;来应用全局AST转换。在这种情况下，转换将对整个源单元应用一次。与META-INF / services / org.codehaus.groovy.transform.ASTTransformation文件中声明的全局AST转换不同（如果文件位于类路径中，则将应用该转换），使用此定制程序，您可以选择有选择地应用转换。调试全局AST转换而不必将批注打包在jar文件中也很有用。</target>
        </trans-unit>
        <trans-unit id="8cad1da7d481a03ef9916a2ff7d8844930ea3cea" translate="yes" xml:space="preserve">
          <source>The classifier if in use, e.g.: &quot;jdk14&quot;</source>
          <target state="translated">个分类器,如果在使用,例如。&quot;jdk14&quot;</target>
        </trans-unit>
        <trans-unit id="ca27fb66cfe5fba5a9ac754d02a9f29c0105033f" translate="yes" xml:space="preserve">
          <source>The classpath as URL[] from this configuration.</source>
          <target state="translated">将此配置中的classpath作为URL[]。</target>
        </trans-unit>
        <trans-unit id="8d1bf1f2d2c67f0aae89b6c3bc480661749348cd" translate="yes" xml:space="preserve">
          <source>The classpath as URL[] from this configuration. This can be used to construct a class loader.</source>
          <target state="translated">将此配置中的classpath作为URL[]。这可以用来构造一个类加载器。</target>
        </trans-unit>
        <trans-unit id="bd3926225e9f00ef4ebec16fbc04d966c7fe2b75" translate="yes" xml:space="preserve">
          <source>The closure</source>
          <target state="translated">结案</target>
        </trans-unit>
        <trans-unit id="479f86662ac269b97cc2d894e9bac34d9794dd34" translate="yes" xml:space="preserve">
          <source>The closure code is executed after the specified phase has completed. If no phase is provided, then the code is executed after the &lt;a href=&quot;../../org/codehaus/groovy/control/compilephase#SEMANTIC_ANALYSIS&quot;&gt;semantic analysis&lt;/a&gt; phase and each subsequent phase.</source>
          <target state="translated">在指定阶段完成后，将执行关闭代码。如果未提供任何阶段，则在&lt;a href=&quot;../../org/codehaus/groovy/control/compilephase#SEMANTIC_ANALYSIS&quot;&gt;语义分析&lt;/a&gt;阶段和每个后续阶段之后执行代码。</target>
        </trans-unit>
        <trans-unit id="d7e22c2e0c44fd389e3b41fde1dda05fedb35439" translate="yes" xml:space="preserve">
          <source>The closure is wrapped in a thread, and the thread is started immediately, only if the current thread is the EDT, otherwise the closure will be called immediately.</source>
          <target state="translated">闭包在一个线程中,只有当当前线程是EDT时,才会立即启动该线程,否则会立即调用闭包。</target>
        </trans-unit>
        <trans-unit id="66a119bbf2479d278c5b03976bf4d331b5a07a07" translate="yes" xml:space="preserve">
          <source>The closure must accept either 1 or 2 parameters. The first parameter is required and will be instance of the &lt;code&gt;type&lt;/code&gt; for which the closure is registered. The second optional parameter should be of type &lt;code&gt;String&lt;/code&gt; and, if available, will be passed the name of the key associated with this value if serializing a JSON Object. This parameter will be &lt;code&gt;null&lt;/code&gt; when serializing a JSON Array or when there is no way to determine the name of the key.</source>
          <target state="translated">闭包必须接受1或2个参数。第一个参数是必需的，并且将是为其注册关闭的 &lt;code&gt;type&lt;/code&gt; 实例。第二个可选参数应为 &lt;code&gt;String&lt;/code&gt; 类型，如果可用，则在序列化JSON对象时将传递与此值关联的键的名称。当序列化JSON数组或无法确定密钥名称时，此参数将为 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d6ac82819478a5008a16cf393ea1fa535e93de24" translate="yes" xml:space="preserve">
          <source>The closure will be called with a single argument; the database statement (actually a &lt;code&gt;BatchingStatementWrapper&lt;/code&gt; helper object) associated with this batch.</source>
          <target state="translated">闭包将通过一个参数来调用。与该批处理关联的数据库语句（实际上是 &lt;code&gt;BatchingStatementWrapper&lt;/code&gt; 帮助器对象）。</target>
        </trans-unit>
        <trans-unit id="ae8cb3c86be077ae32b3b768d99be03b18c7b824" translate="yes" xml:space="preserve">
          <source>The closure will be called with a single argument; the prepared statement (actually a &lt;code&gt;BatchingPreparedStatementWrapper&lt;/code&gt; helper object) associated with this batch.</source>
          <target state="translated">闭包将通过一个参数来调用。与该批处理关联的已准备好的语句（实际上是 &lt;code&gt;BatchingPreparedStatementWrapper&lt;/code&gt; 帮助器对象）。</target>
        </trans-unit>
        <trans-unit id="4ae276d6aaf9c3b8bb8aacf648ffb3e07a64cd0f" translate="yes" xml:space="preserve">
          <source>The column.</source>
          <target state="translated">该栏目。</target>
        </trans-unit>
        <trans-unit id="b8a31b50dfe2f995289113fae596103f2b81d59f" translate="yes" xml:space="preserve">
          <source>The command synopsis displayed as the first line in the usage help message, e.g., when &lt;code&gt;cli.usage()&lt;/code&gt; is called.</source>
          <target state="translated">命令摘要显示为使用帮助消息中的第一行，例如，在 &lt;code&gt;cli.usage()&lt;/code&gt; 时。</target>
        </trans-unit>
        <trans-unit id="06cad667cd962638ca743f083a07c3b0502fe46b" translate="yes" xml:space="preserve">
          <source>The command synopsis displayed as the first line in the usage help message, e.g., when &lt;code&gt;cli.usage()&lt;/code&gt; is called. When not set, a default synopsis is generated that shows the supported options and parameters.</source>
          <target state="translated">命令摘要显示为使用帮助消息中的第一行，例如，在 &lt;code&gt;cli.usage()&lt;/code&gt; 时。未设置时，将生成一个默认的提要，其中显示了受支持的选项和参数。</target>
        </trans-unit>
        <trans-unit id="d18fc7b737edb2f0f86aeb308f5fb82c518e4b38" translate="yes" xml:space="preserve">
          <source>The compile phase after which the test code should run.</source>
          <target state="translated">编译阶段后,测试代码应该运行。</target>
        </trans-unit>
        <trans-unit id="afcc42b40006b1f09d9251010aafdffd34d40bec" translate="yes" xml:space="preserve">
          <source>The compiler will call this method each time, in a source file, a method call using a closure literal is encountered and that the target method has the corresponding &lt;a href=&quot;../../lang/closure&quot;&gt;Closure&lt;/a&gt; parameter annotated with &lt;a href=&quot;closureparams&quot;&gt;ClosureParams&lt;/a&gt;. So imagine the following code needs to be compiled:</source>
          <target state="translated">每次在源文件中，编译器都会调用此方法，该方法将遇到使用闭包文字的方法调用，并且目标方法具有相应的带有&lt;a href=&quot;closureparams&quot;&gt;ClosureParams&lt;/a&gt;注释的&lt;a href=&quot;../../lang/closure&quot;&gt;Closure&lt;/a&gt;参数。因此，假设需要编译以下代码：</target>
        </trans-unit>
        <trans-unit id="3808e32108176f69751a0339e1ed53d1e06027cc" translate="yes" xml:space="preserve">
          <source>The compiler will not output classes from these, the methods usually do not contain bodies. These kind of ClassNodes will be used in different checks, but not checks that work on the method bodies. For example if such a ClassNode is a super class to a primary ClassNode, then the abstract method test and others will be done with data based on these. Theoretically it is also possible to mix both (1 and 2) kind of classes in a hierarchy, but this probably works only in the newest Groovy versions. Such ClassNodes normally have to isResolved() returning true without having a redirect.In the Groovy compiler the only version of this, that exists, is a ClassNode created through a Class instance</source>
          <target state="translated">编译器不会从中输出类,方法通常不包含体。这类ClassNode会被用于不同的检查,但不会用于对方法体的检查。比如说如果这样的ClassNode是一个主ClassNode的超级类,那么抽象方法检查和其他的检查将基于这些数据来完成。理论上也可以在一个层次结构中同时混合(1和2)种类,但这可能只在最新的Groovy版本中有效。在Groovy编译器中,唯一存在的版本是通过Class实例创建的ClassNode。</target>
        </trans-unit>
        <trans-unit id="850b5efb5f5d9bd3f0560dbbfb14716f649e832f" translate="yes" xml:space="preserve">
          <source>The configuration if in use (normally only used by internal ivy repositories).</source>
          <target state="translated">如果使用中的配置(通常只由内部的 ivy 仓库使用)。</target>
        </trans-unit>
        <trans-unit id="d7faea022679481783e94841e801c0632c55b402" translate="yes" xml:space="preserve">
          <source>The configuration if in use (normally only used by internal ivy repositories). One or more comma separated values with or without square brackets, e.g. for hibernate you might have &quot;default,proxool,oscache&quot; or &quot;[default,dbcp,swarmcache]&quot;. This last hibernate example assumes you have set up such configurations in your local Ivy repo and have changed your grape config (using grapeConfig.xml) or the &lt;code&gt;@GrabConfig&lt;/code&gt; annotation to point to that repo.</source>
          <target state="translated">使用中的配置（通常仅由内部ivy存储库使用）。一个或多个逗号分隔的值（带或不带方括号），例如，对于休眠状态，您可能具有&amp;ldquo; default，proxool，oscache&amp;rdquo;或&amp;ldquo; [default，dbcp，swarmcache]&amp;rdquo;。最后一个休眠示例假定您已在本地Ivy存储库中设置了此类配置，并更改了grape配置（使用grapeConfig.xml）或 &lt;code&gt;@GrabConfig&lt;/code&gt; 批注以指向该存储库。</target>
        </trans-unit>
        <trans-unit id="d1a60e2fa853eacff28c12440dec49c56afecdc7" translate="yes" xml:space="preserve">
          <source>The contents of the String builder.</source>
          <target state="translated">字符串生成器的内容。</target>
        </trans-unit>
        <trans-unit id="4a4aab4772591a45dec107fd2e9fe47875d2b895" translate="yes" xml:space="preserve">
          <source>The contents of the character sequence</source>
          <target state="translated">字符序列的内容</target>
        </trans-unit>
        <trans-unit id="f665bdf073d546e255843bb7fa9544a62b7c4f16" translate="yes" xml:space="preserve">
          <source>The current implementation will trigger specialized events in the following scenarios, you need not register a different listener as those events extend from PropertyChangeEvent</source>
          <target state="translated">当前的实现将在以下情况下触发专门的事件,你不需要注册一个不同的监听器,因为这些事件是从PropertyChangeEvent扩展而来的。</target>
        </trans-unit>
        <trans-unit id="aa2b0935d80587b9e265b2719d52d7996bf5d785" translate="yes" xml:space="preserve">
          <source>The current phase</source>
          <target state="translated">当前阶段</target>
        </trans-unit>
        <trans-unit id="663e0af727247cd08dbfe73bff52e235110340bf" translate="yes" xml:space="preserve">
          <source>The custom base script may implement the run() method and specify a different method name to be used for the script body by declaring a single abstract method. For example:</source>
          <target state="translated">自定义基础脚本可以实现run()方法,并通过声明一个单一的抽象方法来指定不同的方法名用于脚本主体。例如:</target>
        </trans-unit>
        <trans-unit id="f2e34c2c7e5c999db4a0824f8059bf7756113c7d" translate="yes" xml:space="preserve">
          <source>The custom loader is used when parsing the template code</source>
          <target state="translated">当解析模板代码时,会用到自定义加载器。</target>
        </trans-unit>
        <trans-unit id="1ca6098954c43f913ba3c64e90df8088c2b564b2" translate="yes" xml:space="preserve">
          <source>The deepest cause of the exception that can be found</source>
          <target state="translated">异常的最深层原因,可以发现</target>
        </trans-unit>
        <trans-unit id="8fed7a59b4c24557c03efc1e169c4b5b8e3c0cd8" translate="yes" xml:space="preserve">
          <source>The default implementation allows mutation of MetaClass instances before initialisation (before the initialize() method is called) but not after, thus ensuring Thread safety once a MetaClass has been constructed and placed in the registry</source>
          <target state="translated">默认的实现允许在初始化之前(在调用initialize()方法之前)突变MetaClass实例,但不允许在初始化之后突变,因此一旦一个MetaClass被构造并放置在注册表中,就能确保线程安全</target>
        </trans-unit>
        <trans-unit id="0369a08ef21d243b44db8e7fa19111fcc8106a0b" translate="yes" xml:space="preserve">
          <source>The default implementation returns &lt;a href=&quot;../../../../../groovy/transform/typechecked&quot;&gt;TypeChecked&lt;/a&gt;.</source>
          <target state="translated">默认实现返回&lt;a href=&quot;../../../../../groovy/transform/typechecked&quot;&gt;TypeChecked&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ccbd3d0c31dab791dfc78e2ee441f1186a903c8a" translate="yes" xml:space="preserve">
          <source>The default implementation returns the result of calling &lt;a href=&quot;#visitChildren&quot;&gt;visitChildren&lt;/a&gt; on &lt;code&gt;ctx&lt;/code&gt;.</source>
          <target state="translated">默认实现返回在 &lt;code&gt;ctx&lt;/code&gt; 上调用&lt;a href=&quot;#visitChildren&quot;&gt;visitChildren&lt;/a&gt;的结果。</target>
        </trans-unit>
        <trans-unit id="b8c93b782d28b18159b4ef7fb9a86d95ab87ba8d" translate="yes" xml:space="preserve">
          <source>The default initial capacity</source>
          <target state="translated">默认初始容量</target>
        </trans-unit>
        <trans-unit id="921bbe96047cd5f5e009f6b1a8b71ad284e53cc5" translate="yes" xml:space="preserve">
          <source>The default initial number of table slots for this table (32).</source>
          <target state="translated">本表的默认初始表槽数(32)。</target>
        </trans-unit>
        <trans-unit id="2a0235f2f6bc645bf5e53f460b490ce2caa3598a" translate="yes" xml:space="preserve">
          <source>The default initial number of table slots for this table (32). Used when not otherwise specified in constructor.</source>
          <target state="translated">此表的默认初始表槽数(32)。在构造函数中没有指定时使用。</target>
        </trans-unit>
        <trans-unit id="cd047e4711d4b6317b4497793f156661db1b11a1" translate="yes" xml:space="preserve">
          <source>The default load factor</source>
          <target state="translated">默认负荷系数</target>
        </trans-unit>
        <trans-unit id="b4e8b83f74be0aa4cd12586b4ecddbda8abb74e9" translate="yes" xml:space="preserve">
          <source>The default source encoding.</source>
          <target state="translated">默认的源编码。</target>
        </trans-unit>
        <trans-unit id="2156c83dec97c28b53d21a341f92ef1aa0daaa7b" translate="yes" xml:space="preserve">
          <source>The default type checking handler is used by the standard type checker and doesn't handle any of the type checking errors by default. This just means that whenever a type checking error is detected, there's no additional information available to the type checker that could help it. The default handler is also capable of handling a collection of delegate handlers. If a list of delegates is set, then the type checker will try all the delegates until one is capable of handling an error.</source>
          <target state="translated">默认的类型检查处理程序被标准类型检查器使用,并且默认不处理任何类型检查错误。这只是意味着每当检测到一个类型检查错误时,类型检查器没有额外的信息可以帮助它。默认处理程序还能够处理委托处理程序的集合。如果设置了一个代表列表,那么类型检查器将尝试所有的代表,直到有一个能够处理错误。</target>
        </trans-unit>
        <trans-unit id="c93ee9502a59a55344833d10b6e63692489f009a" translate="yes" xml:space="preserve">
          <source>The default value for this option as a String; subject to type conversion and 'convert'.</source>
          <target state="translated">该选项的默认值为一个字符串;受类型转换和 &quot;转换 &quot;的影响。</target>
        </trans-unit>
        <trans-unit id="a739b1ad38b841cd2fa04a8074ef1077da23a9a2" translate="yes" xml:space="preserve">
          <source>The default value for this option as a String; subject to type conversion and 'convert'. Ignored for Boolean options.</source>
          <target state="translated">此选项的默认值为字符串,受类型转换和'convert'影响。布尔型选项可忽略。</target>
        </trans-unit>
        <trans-unit id="0bac4f7d3a0265af4cdda31389b94208873f3c79" translate="yes" xml:space="preserve">
          <source>The delegate type is either the type of the annotated field (or property) or the return type of the annotated method. The method can be thought of as a getter or factory method for the delegate. All public instance methods present in the delegate type and not present in the owner class will be added to owner class at compile time. The implementation of such automatically added methods is code which calls through to the delegate as per the normal delegate pattern.</source>
          <target state="translated">委托类型是注释字段(或属性)的类型或注释方法的返回类型。该方法可以被认为是委托人的getter或工厂方法。所有存在于delegate类型中而不存在于owner类中的公有实例方法将在编译时被添加到owner类中。这种自动添加的方法的实现就是按照正常的委托模式调用通向委托人的代码。</target>
        </trans-unit>
        <trans-unit id="0af551f931ca1824e6ae59d39c1f9fdc65593c1b" translate="yes" xml:space="preserve">
          <source>The delegate used when invoking closures</source>
          <target state="translated">调用闭包时使用的委托人</target>
        </trans-unit>
        <trans-unit id="da5a481646fd9ab2048ec3c70d70d40fc4c25698" translate="yes" xml:space="preserve">
          <source>The description for the remaining non-option arguments</source>
          <target state="translated">其余非选项参数的说明。</target>
        </trans-unit>
        <trans-unit id="60c01151d0f392e7605b5a47b38d319dce929d2b" translate="yes" xml:space="preserve">
          <source>The description of this option</source>
          <target state="translated">该选项的说明</target>
        </trans-unit>
        <trans-unit id="acf047b88dc904eaceac2bf0ff491efd1167e629" translate="yes" xml:space="preserve">
          <source>The document filter based on Parrot's lexer is for highlighting the content of text editor</source>
          <target state="translated">基于Parrot词典的文档过滤器是为了突出文本编辑器的内容。</target>
        </trans-unit>
        <trans-unit id="8897ab667aaab473e278c1a7493c2f1a2afa6c06" translate="yes" xml:space="preserve">
          <source>The empty args call will create a key whose value will be an empty JSON object:</source>
          <target state="translated">empty args调用将创建一个键,其值将是一个空的JSON对象。</target>
        </trans-unit>
        <trans-unit id="4732dbf3c3fe3c33d319cd5d0d9b4500c95066cc" translate="yes" xml:space="preserve">
          <source>The empty args call will create a key whose value will be an empty YAML object:</source>
          <target state="translated">empty args调用将创建一个键,其值将是一个空的YAML对象。</target>
        </trans-unit>
        <trans-unit id="83bac1c4520db67dc9f9751222ec424f3e1dcdc8" translate="yes" xml:space="preserve">
          <source>The encoding as returned by the underlying OutputStreamWriter.</source>
          <target state="translated">由底层 OutputStreamWriter 返回的编码。</target>
        </trans-unit>
        <trans-unit id="7209071caba4b5b26858a3a9b872daaeac068996" translate="yes" xml:space="preserve">
          <source>The encoding as returned by the underlying OutputStreamWriter. Can be the historical name.</source>
          <target state="translated">由底层 OutputStreamWriter 返回的编码。可以是历史名称。</target>
        </trans-unit>
        <trans-unit id="b32ee3e8c38d4c93010daac30bf6c76f82e10a7e" translate="yes" xml:space="preserve">
          <source>The encoding as returned by the underlying OutputStreamWriter. Will be the preferred name.</source>
          <target state="translated">由底层 OutputStreamWriter 返回的编码。将是首选名称。</target>
        </trans-unit>
        <trans-unit id="c4a1b6c77417175321e74a3e09c3c5bfa3b1a669" translate="yes" xml:space="preserve">
          <source>The example below shows the various possible use cases:</source>
          <target state="translated">下面的例子显示了各种可能的用例。</target>
        </trans-unit>
        <trans-unit id="cda0c1c869121c0516b4b7eef52cfb72926a1f0c" translate="yes" xml:space="preserve">
          <source>The exit code.</source>
          <target state="translated">退出代码。</target>
        </trans-unit>
        <trans-unit id="507fe61a8f648672fa6038e5dfbc9edeb36a23b2" translate="yes" xml:space="preserve">
          <source>The expanded toString() of this CharSequence</source>
          <target state="translated">该CharSequence的扩展toString()。</target>
        </trans-unit>
        <trans-unit id="c2d08e701963d2aabc470d83a9d8da90b7362df5" translate="yes" xml:space="preserve">
          <source>The extension method registry is responsible for collecting methods (or static methods) which are added to existing classes and may be called like regular methods.</source>
          <target state="translated">扩展方法注册表负责收集方法(或静态方法),这些方法被添加到现有的类中,可以像普通方法一样被调用。</target>
        </trans-unit>
        <trans-unit id="aa6754ebfc303c012b03fb4abba3b5f12ccb8b6c" translate="yes" xml:space="preserve">
          <source>The extension of the artifact (normally safe to leave at default value of &quot;jar&quot; but other values like &quot;zip&quot; are sometimes useful).</source>
          <target state="translated">人造物的扩展(通常安全地保留默认值 &quot;jar&quot;,但其他值如 &quot;zip &quot;有时也有用)。</target>
        </trans-unit>
        <trans-unit id="2e641d1d3bf6e1800547d3ef352762fcba029ed7" translate="yes" xml:space="preserve">
          <source>The extra grab configuration.</source>
          <target state="translated">额外的抓取配置。</target>
        </trans-unit>
        <trans-unit id="4cd2c5f11d6d27f858d5d3dc59a3083f35bfd20b" translate="yes" xml:space="preserve">
          <source>The field of this property</source>
          <target state="translated">该财产的领域</target>
        </trans-unit>
        <trans-unit id="b234649fde6d931b7e01052a7041604ee37062c4" translate="yes" xml:space="preserve">
          <source>The first argument of the method is only used to tell the class for which we add a static method. You can now define an extension module:</source>
          <target state="translated">方法的第一个参数只用来告诉我们为其添加静态方法的类。现在你可以定义一个扩展模块了。</target>
        </trans-unit>
        <trans-unit id="8f1c3d2c6a3794b89910b38b5fc0a80c1e72651e" translate="yes" xml:space="preserve">
          <source>The first element returned by the Iterable's iterator is returned. If the Iterable doesn't guarantee a defined order it may appear like a random element is returned.</source>
          <target state="translated">Iterable的迭代器返回的第一个元素被返回。如果Iterable不保证定义的顺序,它可能看起来像一个随机元素被返回。</target>
        </trans-unit>
        <trans-unit id="f788a50cfac60f792deddd7ec215420ae4c26518" translate="yes" xml:space="preserve">
          <source>The following attributes are optional.</source>
          <target state="translated">以下属性是可选的。</target>
        </trans-unit>
        <trans-unit id="7a78a58b8d15f66560b1ee62392912456c7f7d2b" translate="yes" xml:space="preserve">
          <source>The following code is generated:</source>
          <target state="translated">生成以下代码。</target>
        </trans-unit>
        <trans-unit id="c6db6ec58fab215cd6939fb661b05cc65eb0427a" translate="yes" xml:space="preserve">
          <source>The following example describes a closure as accepting a single signature (List&amp;lt;T&amp;gt; list -&amp;gt;):</source>
          <target state="translated">以下示例将闭包描述为接受单个签名（List &amp;lt;T&amp;gt; list-&amp;gt;）：</target>
        </trans-unit>
        <trans-unit id="1deb2c32e07a91866a38699ca2b5e5576a8b7889" translate="yes" xml:space="preserve">
          <source>The following example shows how you can use this annotation on fields of a class:</source>
          <target state="translated">下面的示例显示了如何在类的字段上使用这个注解。</target>
        </trans-unit>
        <trans-unit id="38490d2869c131045bab21ff7ca6b124ab7e1e94" translate="yes" xml:space="preserve">
          <source>The following is an example usage. Note that within a &quot;with&quot; block you need to specify a parameter name so that this.println is not called instead of IndentPrinter.println:</source>
          <target state="translated">下面是一个使用示例。请注意,在 &quot;with &quot;块中,您需要指定一个参数名,以便不会调用 this.println 而不是 IndentPrinter.println。</target>
        </trans-unit>
        <trans-unit id="bb6e88658d6aafa0e1c5fb88a8e22112ec44c060" translate="yes" xml:space="preserve">
          <source>The following is sample usage of the annotation forcing the script to timeout after 5 minutes (300 seconds):</source>
          <target state="translated">以下是强制脚本在5分钟(300秒)后超时的注释的使用示例。</target>
        </trans-unit>
        <trans-unit id="7079281a140b1fc8b280d5f645e024ae9a37bc71" translate="yes" xml:space="preserve">
          <source>The following is sample usage of the annotation:</source>
          <target state="translated">以下是注释的使用示例。</target>
        </trans-unit>
        <trans-unit id="879e99e6a011963f4f6df39ba4aa585918568fcd" translate="yes" xml:space="preserve">
          <source>The following properties are referenced when setting the configuration:</source>
          <target state="translated">设置配置时,会参考以下属性。</target>
        </trans-unit>
        <trans-unit id="20f832237a68dcebeb6521dde3b85b13bd8f5117" translate="yes" xml:space="preserve">
          <source>The following scenarios can not set accessible, i.e. the return value is false 1) SecurityException occurred 2) the accessible object is a Constructor object for the Class class</source>
          <target state="translated">以下情况不能设置可访问,即返回值为false 1)发生了SecurityException 2)可访问对象是Class类的构造函数对象</target>
        </trans-unit>
        <trans-unit id="5775c2755497d25926312a1fe22b019fe16dce69" translate="yes" xml:space="preserve">
          <source>The following servlet init parameter name can be used to specify the encoding TemplateServlet will use to read the template groovy source files:</source>
          <target state="translated">下面的servlet init参数名可以用来指定TemplateServlet将用来读取模板groovy源文件的编码。</target>
        </trans-unit>
        <trans-unit id="6c10ecb3564857baa02ca7a4bdd0fbed3c5fdf34" translate="yes" xml:space="preserve">
          <source>The following shows all of the different syntax forms supported by the node.</source>
          <target state="translated">下面显示了该节点支持的所有不同语法形式。</target>
        </trans-unit>
        <trans-unit id="402c79945cb622bc852b23a63a5a225b6b97c510" translate="yes" xml:space="preserve">
          <source>The following system properties are referenced when setting the configuration optimization options:</source>
          <target state="translated">设置配置优化选项时,会参考以下系统属性。</target>
        </trans-unit>
        <trans-unit id="589daf472d87f60da3820df2375540a65850b000" translate="yes" xml:space="preserve">
          <source>The following will be output:</source>
          <target state="translated">将输出以下内容:</target>
        </trans-unit>
        <trans-unit id="3affea3413fcaa516e9b68e8682b4216a488ecf1" translate="yes" xml:space="preserve">
          <source>The found MetaProperty or null if it doesn't exist</source>
          <target state="translated">找到的MetaProperty,如果不存在则为空。</target>
        </trans-unit>
        <trans-unit id="363824e3df035b97ca5a7ffba69200b946d3b768" translate="yes" xml:space="preserve">
          <source>The functionality provided by tr can be achieved using regular expressions but tr provides a much more compact notation and efficient implementation for certain scenarios.</source>
          <target state="translated">tr所提供的功能可以使用正则表达式来实现,但tr为某些场景提供了更为紧凑的符号和高效的实现方式。</target>
        </trans-unit>
        <trans-unit id="8f49e8b4f671d3af1ab3b54839c50c3ad9cb19cd" translate="yes" xml:space="preserve">
          <source>The generated &lt;code&gt;equals&lt;/code&gt; and &lt;code&gt;canEqual&lt;/code&gt; methods will be something like below:</source>
          <target state="translated">生成的 &lt;code&gt;equals&lt;/code&gt; 和 &lt;code&gt;canEqual&lt;/code&gt; 方法将如下所示：</target>
        </trans-unit>
        <trans-unit id="016adc8430975ce5b3714e3f00410813056eb5c1" translate="yes" xml:space="preserve">
          <source>The generated &lt;code&gt;toString&lt;/code&gt; will include property names and exclude the &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; properties.</source>
          <target state="translated">生成的 &lt;code&gt;toString&lt;/code&gt; 将包含属性名称，并排除 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="36d5e288e1f29d364f8118145d20f640ba8a3434" translate="yes" xml:space="preserve">
          <source>The generated Groovy class will:</source>
          <target state="translated">生成的Groovy类将。</target>
        </trans-unit>
        <trans-unit id="6ed368a0eaa66dbac47a9b89c0164f8d4c95bba4" translate="yes" xml:space="preserve">
          <source>The generated equals method will be something like below:</source>
          <target state="translated">生成的等值方法将是类似下面的东西。</target>
        </trans-unit>
        <trans-unit id="7d1e1567f7025b7a32483c0df7c9b9df0c6d2e4e" translate="yes" xml:space="preserve">
          <source>The generated map constructor will have an argument of type &lt;code&gt;Map&lt;/code&gt; unless a single property (or field) is included and the type of that property (or field) is Object, AbstractMap, Map or HashMap. In this case, the generated constructor will be of type &lt;code&gt;LinkedHashMap&lt;/code&gt;. This allows the possibility of also adding a tuple constructor without conflict, although no such constructor is added automatically. You can disable this behavior by setting the specialNamedArgHandling annotation attribute to false. This means that for the special case mentioned above, you will not be able to also add a tuple constructor with a single Map argument but you can supply any kind of map as your argument. We'd also recommend not having both a map constructor and a tuple constructor with a single Object, AbstractMap or HashMap since it can cause confusion as to which will be called.</source>
          <target state="translated">除非包含单个属性（或字段）并且该属性（或字段）的类型为Object，AbstractMap，Map或HashMap，否则生成的地图构造函数将具有 &lt;code&gt;Map&lt;/code&gt; 类型的参数。在这种情况下，生成的构造函数将为 &lt;code&gt;LinkedHashMap&lt;/code&gt; 类型。这样就可以添加一个没有冲突的元组构造函数的可能性，尽管不会自动添加这样的构造函数。您可以通过将specialNamedArgHandling批注属性设置为false来禁用此行为。这意味着对于上述特殊情况，您将无法同时添加具有单个Map参数的元组构造函数，但可以提供任何类型的map作为参数。我们还建议不要同时使用单个Object，AbstractMap或HashMap的map构造函数和tuple构造函数，因为这会引起混淆。</target>
        </trans-unit>
        <trans-unit id="2054e20238e38cbabff60cf87d59cd3bda71ca2d" translate="yes" xml:space="preserve">
          <source>The generated method/constructor retains the visibility and return type of the original method/constructor but the &lt;a href=&quot;visibilityoptions&quot;&gt;VisibilityOptions&lt;/a&gt; annotation can be added to customize the visibility. You could have the annotated method/constructor private for instance but have the generated one be public.</source>
          <target state="translated">生成的方法/构造函数保留原始方法/构造函数的&lt;a href=&quot;visibilityoptions&quot;&gt;可见&lt;/a&gt;性和返回类型，但是可以添加VisibilityOptions批注以自定义可见性。例如，您可以将带注释的方法/构造函数设为私有，但将生成的方法/构造函数设为公开。</target>
        </trans-unit>
        <trans-unit id="9d8c55bbbf0e4e8d80618bab6f8e1e859dd3d404" translate="yes" xml:space="preserve">
          <source>The generated methods must not already exist</source>
          <target state="translated">生成的方法必须是不存在的</target>
        </trans-unit>
        <trans-unit id="c757fafc4af8d85241ca605d29734fb8e7040c3a" translate="yes" xml:space="preserve">
          <source>The groovy.lang.Closure will be given the class name as parameter. the return value decides if the element will be added or not.</source>
          <target state="translated">groovy.lang.Closure将被赋予类名作为参数,返回值决定元素是否被添加。</target>
        </trans-unit>
        <trans-unit id="73d792c97d713c524a35ad9cb7269ec2f224a2f7" translate="yes" xml:space="preserve">
          <source>The groovy.mock.interceptor is an all-groovy mock testing library.</source>
          <target state="translated">groovy.mock.interceptor是一个全groovy模拟测试库。</target>
        </trans-unit>
        <trans-unit id="d08cb5974fee471582bb6c391e801a198206f54c" translate="yes" xml:space="preserve">
          <source>The handle should be registered with the Groovy runtime &lt;strong&gt;before&lt;/strong&gt; Groovy loads, for example in your main method. &lt;code&gt;GroovySystem.metaClassRegistry.metaClassCreationHandle = new ExpandoMetaClassCreationHandle()&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;在&lt;/strong&gt;Groovy加载&lt;strong&gt;之前&lt;/strong&gt;，应该在Groovy运行时中注册该句柄，例如在您的main方法中。 &lt;code&gt;GroovySystem.metaClassRegistry.metaClassCreationHandle = new ExpandoMetaClassCreationHandle()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d7a6bf7e30e4e5adaebfa336015e1d6db546b0dc" translate="yes" xml:space="preserve">
          <source>The hash table data.</source>
          <target state="translated">哈希表数据。</target>
        </trans-unit>
        <trans-unit id="0be72dcbde8376507858e5e3b4f88ceb470819fe" translate="yes" xml:space="preserve">
          <source>The idea for this AST transformation originated in &lt;a href=&quot;../test/groovytestcase#notYetImplemented()&quot;&gt;GroovyTestCase.notYetImplemented&lt;/a&gt;.</source>
          <target state="translated">AST转换的思想起源于&lt;a href=&quot;../test/groovytestcase#notYetImplemented()&quot;&gt;GroovyTestCase.notYetImplemented&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1e6b7d618961498090102436a153ea6769f4ea92" translate="yes" xml:space="preserve">
          <source>The index of the generic type that will be the type of the closure's delegate.</source>
          <target state="translated">通用类型的索引,它将是闭包的委托人的类型。</target>
        </trans-unit>
        <trans-unit id="4a05df6a03c832914a468e9a8f09e99bb76121ca" translate="yes" xml:space="preserve">
          <source>The index of the generic type that will be the type of the closure's delegate. The generic types are considered with respect to the &lt;code&gt;@DelegatesTo.Target&lt;/code&gt; annotated parameter for this usage, with the index starting at 0.</source>
          <target state="translated">通用类型的索引，它将是闭包的委托类型。对于此用法，将针对 &lt;code&gt;@DelegatesTo.Target&lt;/code&gt; 注释的参数考虑泛型类型，索引从0开始。</target>
        </trans-unit>
        <trans-unit id="8f4812f2fcebeff3b4ebb6e2b6159d4da2a14e7a" translate="yes" xml:space="preserve">
          <source>The initial size of the memory for the underlying VM if javac is run externally; ignored otherwise.</source>
          <target state="translated">如果javac在外部运行,则底层虚拟机的初始内存大小;否则忽略。</target>
        </trans-unit>
        <trans-unit id="9906cb8cda50e01b5fc0296c2ebddf1998c07481" translate="yes" xml:space="preserve">
          <source>The initial size of the memory for the underlying VM if javac is run externally; ignored otherwise. Defaults to the standard VM memory setting. (Examples: 83886080, 81920k, or 80m)</source>
          <target state="translated">如果javac在外部运行,则底层虚拟机的初始内存大小;否则忽略。默认为标准虚拟机内存设置。例如:83886080、81920k或80m)。</target>
        </trans-unit>
        <trans-unit id="09418ac5ed51e2ae7deca28347160febab7297a9" translate="yes" xml:space="preserve">
          <source>The initial value</source>
          <target state="translated">初始值</target>
        </trans-unit>
        <trans-unit id="cca553e21f81b340e4552ee970c2d402d976a297" translate="yes" xml:space="preserve">
          <source>The interface implemented by all Groovy objects.</source>
          <target state="translated">所有Groovy对象实现的接口。</target>
        </trans-unit>
        <trans-unit id="d36584fdf4c93d8244b01640584ce4681a2619d4" translate="yes" xml:space="preserve">
          <source>The isCallToSuper and fromInsideClass help the Groovy runtime perform optimisations on the call to go directly to the super class if necessary</source>
          <target state="translated">isCallToSuper和fromInsideClass帮助Groovy运行时对调用进行优化,必要时直接进入超级类。</target>
        </trans-unit>
        <trans-unit id="7a7346df5fc4b24f592e6ab3da8efbdbdb2e3f57" translate="yes" xml:space="preserve">
          <source>The iterator stepped along by &lt;code&gt;num&lt;/code&gt; elements if they exist.</source>
          <target state="translated">如果存在，则迭代器将逐步增加 &lt;code&gt;num&lt;/code&gt; 个元素。</target>
        </trans-unit>
        <trans-unit id="825771f9b59209884bd5990f89392f472ab52a1c" translate="yes" xml:space="preserve">
          <source>The java.lang.Class instance</source>
          <target state="translated">java.lang.Class实例</target>
        </trans-unit>
        <trans-unit id="39162451983f218a6022c93f55c40cf3576ffa56" translate="yes" xml:space="preserve">
          <source>The last element returned by the Iterable's iterator is returned. If the Iterable doesn't guarantee a defined order it may appear like a random element is returned.</source>
          <target state="translated">返回Iterable的迭代器所返回的最后一个元素。如果Iterable不保证定义的顺序,它可能看起来像一个随机元素被返回。</target>
        </trans-unit>
        <trans-unit id="d2b9d6958fb3428a858e3ff1b7e7d575c9444949" translate="yes" xml:space="preserve">
          <source>The lexer for Groovy programming language, which is based on the lexer generated by Antlr4</source>
          <target state="translated">Groovy编程语言的词典,它是基于Antlr4生成的词典。</target>
        </trans-unit>
        <trans-unit id="9bacfbe842c2f1b3272b7632dbf718566ac8d700" translate="yes" xml:space="preserve">
          <source>The lexer reads JSON tokens in a streaming fashion from the underlying reader.</source>
          <target state="translated">该词典以流式方式从底层阅读器中读取JSON标记。</target>
        </trans-unit>
        <trans-unit id="f5ca3610dac449f90a9e358ccee55e7567cc07b1" translate="yes" xml:space="preserve">
          <source>The line.</source>
          <target state="translated">这条线。</target>
        </trans-unit>
        <trans-unit id="b7ba62139a54b7638c01550fb541cf6269ed40be" translate="yes" xml:space="preserve">
          <source>The list of (classpath resources) paths to type checking DSL scripts, also known as type checking extensions.</source>
          <target state="translated">类型检查DSL脚本的(classpath资源)路径列表,也称为类型检查扩展。</target>
        </trans-unit>
        <trans-unit id="e9ece14574ea4cdf3337639446998372a41bef30" translate="yes" xml:space="preserve">
          <source>The listener is invoked by &lt;a href=&quot;concurrentlinkedhashmap&quot;&gt;ConcurrentLinkedHashMap&lt;/a&gt; on a caller's thread and will not block other threads from operating on the map. An implementation should be aware that the caller's thread will not expect long execution times or failures as a side effect of the listener being notified. Execution safety and a fast turn around time can be achieved by performing the operation asynchronously, such as by submitting a task to an &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html&quot;&gt;ExecutorService&lt;/a&gt;.</source>
          <target state="translated">侦听器由&lt;a href=&quot;concurrentlinkedhashmap&quot;&gt;ConcurrentLinkedHashMap&lt;/a&gt;在调用者的线程上调用，并且不会阻止其他线程在映射上进行操作。一个实现应该意识到，调用者的线程不会期望较长的执行时间或失败，这是通知监听者的副作用。通过异步执行操作（例如，将任务提交给&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html&quot;&gt;ExecutorService）&lt;/a&gt;，可以实现执行安全性和快速的周转时间。</target>
        </trans-unit>
        <trans-unit id="47f12bc7a7163b88b7c40a6143c735e189ed9d15" translate="yes" xml:space="preserve">
          <source>The load factor for the hash table.</source>
          <target state="translated">哈希表的负荷系数。</target>
        </trans-unit>
        <trans-unit id="24eb861382bd4ecd59d0d7b27ffc4a02974042ef" translate="yes" xml:space="preserve">
          <source>The long name of this option.</source>
          <target state="translated">这个选项的长名。</target>
        </trans-unit>
        <trans-unit id="16e53b8a2be8a710bfb615e37e77de8bcde7fbfe" translate="yes" xml:space="preserve">
          <source>The long name of this option. Defaults to the name of member being annotated.</source>
          <target state="translated">这个选项的长名。默认为被注释的成员名称。</target>
        </trans-unit>
        <trans-unit id="a1c14e51c7082ed212704f80fa16a5caa5f4b2e7" translate="yes" xml:space="preserve">
          <source>The lower value in the range.</source>
          <target state="translated">范围内的较低值。</target>
        </trans-unit>
        <trans-unit id="d70a0a182db9bd82ea7fc6368b0f23fdc024a4f0" translate="yes" xml:space="preserve">
          <source>The main class code visitor responsible for static type checking. It will perform various inspections like checking assignment types, type inference, ... Eventually, class nodes may be annotated with inferred type information.</source>
          <target state="translated">主类代码访问者,负责静态类型检查。它将执行各种检查,如检查赋值类型,类型推理,......。最终,类节点可能会被注解推断类型信息。</target>
        </trans-unit>
        <trans-unit id="a35d780b7b7d71330b5a704f00aff27069bd32b6" translate="yes" xml:space="preserve">
          <source>The main function of the registry If a meta class exists then return it otherwise create one, put it in the registry and return it</source>
          <target state="translated">注册表的主要功能 如果一个元类存在,那么就返回它,否则就创建一个元类,把它放在注册表中,然后返回它。</target>
        </trans-unit>
        <trans-unit id="e07dbd7ee535fe35b6529b949ce03a3cdd12de16" translate="yes" xml:space="preserve">
          <source>The main instance method of a script which has variables in scope as defined by the current &lt;a href=&quot;binding&quot;&gt;Binding&lt;/a&gt; instance.</source>
          <target state="translated">脚本的主要实例方法，该实例的作用域具有当前&lt;a href=&quot;binding&quot;&gt;Binding&lt;/a&gt;实例所定义的范围。</target>
        </trans-unit>
        <trans-unit id="a25dec9e9a77a814a53504ab23b75ca4e697cf0f" translate="yes" xml:space="preserve">
          <source>The map values are the normal values provided as the second parameter to &lt;code&gt;java.util.Calendar#set(int, int)&lt;/code&gt;. The keys can either be the normal fields values provided as the first parameter to that method or one of the following Strings:</source>
          <target state="translated">映射值是作为 &lt;code&gt;java.util.Calendar#set(int, int)&lt;/code&gt; 的第二个参数提供的常规值。键可以是作为该方法的第一个参数提供的常规字段值，也可以是以下字符串之一：</target>
        </trans-unit>
        <trans-unit id="731e1e3475853eb36e2f419522ace251acd1d87b" translate="yes" xml:space="preserve">
          <source>The maximum elapsed time the script will be allowed to run for.</source>
          <target state="translated">脚本允许运行的最长时间。</target>
        </trans-unit>
        <trans-unit id="8a9744c288c3ec0b1b71c029102e0ca0c0c4e606" translate="yes" xml:space="preserve">
          <source>The maximum elapsed time the script will be allowed to run for. By default it is measure in seconds</source>
          <target state="translated">脚本允许运行的最大时间。默认情况下,它的单位是秒。</target>
        </trans-unit>
        <trans-unit id="4c2ffed2aec71628097d548244a5403333d478d2" translate="yes" xml:space="preserve">
          <source>The maximum number of directory levels when recursing (default is -1 which means infinite, set to 0 for no recursion)</source>
          <target state="translated">递归时目录层数的最大值(默认为-1,表示无限大,设置为0表示不递归</target>
        </trans-unit>
        <trans-unit id="a3d134d4c35a591a550b0133ec3ffcec626a2ca1" translate="yes" xml:space="preserve">
          <source>The maximum size of the memory for the underlying VM if javac is run externally; ignored otherwise.</source>
          <target state="translated">如果javac在外部运行,底层虚拟机的最大内存大小;否则忽略。</target>
        </trans-unit>
        <trans-unit id="d53256043cb34b5f9af6acb675b49a62d63df5c8" translate="yes" xml:space="preserve">
          <source>The maximum size of the memory for the underlying VM if javac is run externally; ignored otherwise. Defaults to the standard VM memory setting. (Examples: 83886080, 81920k, or 80m)</source>
          <target state="translated">如果javac在外部运行,底层虚拟机的最大内存大小;否则忽略。默认为标准虚拟机内存设置。例如:83886080、81920k或80m)。</target>
        </trans-unit>
        <trans-unit id="be8a261b2c86bdec542c4bdc16f3f9b00cf90718" translate="yes" xml:space="preserve">
          <source>The maximum size the cache can grow to.</source>
          <target state="translated">缓存可以增长到的最大尺寸。</target>
        </trans-unit>
        <trans-unit id="a932fa7b6f4119b32f6b4708d0afeedb86270516" translate="yes" xml:space="preserve">
          <source>The mechanics: during compilation, all methods are transformed to static ones with an additional self parameter of the type you supply as the annotation parameter (the default type for the self parameters is &lt;code&gt;Object&lt;/code&gt; which might be more broad reaching than you like so it is usually wise to specify a type). Properties invoked using 'this' references are transformed so that they are instead invoked on the additional self parameter and not on the Category instance. (Remember that once the category is applied, the reverse will occur and we will be back to conceptually having methods on the &lt;code&gt;this&lt;/code&gt; references again!)</source>
          <target state="translated">机制：在编译过程中，所有方法都将转换为静态方法，并带有一个您自己提供的类型作为注释参数的自变量（自变量的默认类型是 &lt;code&gt;Object&lt;/code&gt; ，其对象范围可能比您喜欢的范围广，因此通常明智地指定类型）。使用'this'引用调用的属性将进行转换，以便改为在其他self参数上而不在Category实例上调用它们。 （请记住，一旦应用了类别，就会发生相反的情况，我们将在概念上再次在 &lt;code&gt;this&lt;/code&gt; 引用上使用方法！）</target>
        </trans-unit>
        <trans-unit id="2666c74280324e9c05645b343443d5ae919ca593" translate="yes" xml:space="preserve">
          <source>The message is a little cryptic, but it is basically the static compiler telling us that the third parameter, &lt;code&gt;age&lt;/code&gt; in our case, is unset. You can also add this annotation to your predefined constructors. These will be made private and an initializer will be set up to call your constructor. Any parameters to your constructor become the properties expected by the initializer. If you use such a builder on a constructor as well as on the class or on more than one constructor, then it is up to you to define unique values for 'builderClassName' and 'builderMethodName' for each annotation.</source>
          <target state="translated">该消息有点神秘，但基本上是静态编译器告诉我们，第三个参数（本例中为 &lt;code&gt;age&lt;/code&gt; ）未设置。您也可以将此注释添加到预定义的构造函数中。这些将被设为私有，并且将设置一个初始化程序来调用您的构造函数。构造函数的任何参数都将成为初始化程序期望的属性。如果在构造函数以及类或多个构造函数上使用这样的生成器，则由您为每个注释定义&amp;ldquo; builderClassName&amp;rdquo;和&amp;ldquo; builderMethodName&amp;rdquo;的唯一值。</target>
        </trans-unit>
        <trans-unit id="233f1eda634fadbf2d6de9fdbba96a43cfac37b3" translate="yes" xml:space="preserve">
          <source>The meta map generated.</source>
          <target state="translated">生成的元地图。</target>
        </trans-unit>
        <trans-unit id="481ab6cb4af59496e16e981430f5212574c520b3" translate="yes" xml:space="preserve">
          <source>The method &quot;is&quot; is used to test for equal references.</source>
          <target state="translated">用 &quot;是 &quot;的方法来检验是否有相等的引用。</target>
        </trans-unit>
        <trans-unit id="10a0b965a2d07d42bb108200564cd0092fef8a4b" translate="yes" xml:space="preserve">
          <source>The method &quot;is&quot; is used to test for equal references. This method will return true only if the given parameter is null</source>
          <target state="translated">方法 &quot;is &quot;用于测试等价引用。只有当给定参数为null时,该方法才会返回true。</target>
        </trans-unit>
        <trans-unit id="046b59ea660985a374595a12ce69c4e51a167400" translate="yes" xml:space="preserve">
          <source>The method descriptor of the method from the trait</source>
          <target state="translated">来自性状的方法描述符。</target>
        </trans-unit>
        <trans-unit id="0b11d5e3b0af8fe608284cd9acdeefcad67a7934" translate="yes" xml:space="preserve">
          <source>The method is invoked when an AST Transformation is active.</source>
          <target state="translated">当AST转换处于活动状态时,该方法被调用。</target>
        </trans-unit>
        <trans-unit id="3ad8ddc19cf1fe16c4946011a31c3d7615aae395" translate="yes" xml:space="preserve">
          <source>The method is invoked when an AST Transformation is active. For local transformations, it is invoked once each time the local annotation is encountered. For global transformations, it is invoked once for every source unit, which is typically a source file.</source>
          <target state="translated">当AST变换处于活动状态时,该方法被调用。对于局部转换,每次遇到局部注释时都会被调用一次。对于全局转换,它对每个源单元(通常是源文件)都会被调用一次。</target>
        </trans-unit>
        <trans-unit id="16096b1fa8363d7f7f3486f5931631ff7821604c" translate="yes" xml:space="preserve">
          <source>The method is similar with &lt;a href=&quot;genericsutils#makeDeclaringAndActualGenericsTypeMap(org.codehaus.groovy.ast.ClassNode,%20org.codehaus.groovy.ast.ClassNode)&quot;&gt;GenericsUtils.makeDeclaringAndActualGenericsTypeMap&lt;/a&gt;, The main difference is that the method will try to map all placeholders found to the relevant exact types, but the other will not try even if the parameterized type has placeholders</source>
          <target state="translated">该方法与&lt;a href=&quot;genericsutils#makeDeclaringAndActualGenericsTypeMap(org.codehaus.groovy.ast.ClassNode,%20org.codehaus.groovy.ast.ClassNode)&quot;&gt;GenericsUtils.makeDeclaringAndActualGenericsTypeMap&lt;/a&gt;相似，主要区别在于该方法将尝试将找到的所有占位符映射到相关的精确类型，但是即使参数化类型具有占位符，其他方法也不会尝试</target>
        </trans-unit>
        <trans-unit id="ebd121539032d1aa634563f13cd1d7bb73f83b33" translate="yes" xml:space="preserve">
          <source>The method name</source>
          <target state="translated">方法名称</target>
        </trans-unit>
        <trans-unit id="9107c6d41421afd6c4262deaacc88cd7b897fd8a" translate="yes" xml:space="preserve">
          <source>The method name to use for a builder factory method in the source class for easy access of the builder helper class for strategies which create such a helper class.</source>
          <target state="translated">用于源类中的构建器工厂方法的方法名,以便于创建这种帮助类的策略访问构建器帮助类。</target>
        </trans-unit>
        <trans-unit id="d156486b828194de0dc1376f435a69303f46b5c6" translate="yes" xml:space="preserve">
          <source>The method name to use for a builder factory method in the source class for easy access of the builder helper class for strategies which create such a helper class. Must not be used if using &lt;code&gt;forClass&lt;/code&gt;. Default is determined by the strategy, e.g. &lt;em&gt;builder&lt;/em&gt; or &lt;em&gt;createInitializer&lt;/em&gt;.</source>
          <target state="translated">源类中用于构建器工厂方法的方法名称，以方便访问构建器帮助器类的策略，以创建此类帮助器类。如果使用 &lt;code&gt;forClass&lt;/code&gt; ,则不得使用。默认值由策略确定，例如&lt;em&gt;builder&lt;/em&gt;或&lt;em&gt;createInitializer&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="19190b8bf1a50223552a2ea9092d0e868f9b58bb" translate="yes" xml:space="preserve">
          <source>The method omits padding and is equivalent to calling &lt;a href=&quot;encodinggroovymethods#encodeBase64Url(Byte%5B%5D,%20boolean)&quot;&gt;EncodingGroovyMethods.encodeBase64Url&lt;/a&gt; with a value of &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">该方法省略了填充，等效于使用 &lt;code&gt;false&lt;/code&gt; 值调用&lt;a href=&quot;encodinggroovymethods#encodeBase64Url(Byte%5B%5D,%20boolean)&quot;&gt;EncodingGroovyMethods.encodeBase64Url&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fd16bad639c8dbfe1c2afb5d210c9fca412a986a" translate="yes" xml:space="preserve">
          <source>The method omits padding and is equivalent to calling &lt;a href=&quot;encodinggroovymethods#encodeBase64Url(byte%5B%5D,%20boolean)&quot;&gt;EncodingGroovyMethods.encodeBase64Url&lt;/a&gt; with a value of &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">该方法省略了填充，等效于使用 &lt;code&gt;false&lt;/code&gt; 值调用&lt;a href=&quot;encodinggroovymethods#encodeBase64Url(byte%5B%5D,%20boolean)&quot;&gt;EncodingGroovyMethods.encodeBase64Url&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="977caf0a01596f416e854564419eecf39b01c39d" translate="yes" xml:space="preserve">
          <source>The method returns</source>
          <target state="translated">该方法返回</target>
        </trans-unit>
        <trans-unit id="233550ffa2aace49d6789bba08354b9269776fba" translate="yes" xml:space="preserve">
          <source>The methods found in this class are made directly available in type checking scripts through the &lt;a href=&quot;groovytypecheckingextensionsupport&quot;&gt;GroovyTypeCheckingExtensionSupport&lt;/a&gt; class.</source>
          <target state="translated">通过&lt;a href=&quot;groovytypecheckingextensionsupport&quot;&gt;GroovyTypeCheckingExtensionSupport&lt;/a&gt;类，可以在类型检查脚本中直接使用此类中找到的方法。</target>
        </trans-unit>
        <trans-unit id="3f7b0d22db711005969846defb7c99717fa91841" translate="yes" xml:space="preserve">
          <source>The modified implementation is based on StringUtils#replace(String text, String searchString, String replacement, int max), Apache commons-lang3-3.6</source>
          <target state="translated">修改后的实现基于StringUtils#replace(String text,String searchString,String replacement,int max),Apache commons-lang3-3.6。</target>
        </trans-unit>
        <trans-unit id="50fbba6f75c792f1af5c5472d076319e1dc8e8c0" translate="yes" xml:space="preserve">
          <source>The module or artifact, e.g.: &quot;ant-junit&quot;.</source>
          <target state="translated">的模块或工件,例如:。&quot;ant-junit&quot;。</target>
        </trans-unit>
        <trans-unit id="9ecf7b850507e5a2a96948e13f72e6da5a6b2250" translate="yes" xml:space="preserve">
          <source>The module or artifact, e.g.: &quot;ant-junit&quot;. A non-empty value is required unless value() is used.</source>
          <target state="translated">的模块或工件,例如:。&quot;ant-junit&quot;。除非使用value(),否则需要一个非空值。</target>
        </trans-unit>
        <trans-unit id="8998068077ca7885c0e4186f470a1345f7bcaabe" translate="yes" xml:space="preserve">
          <source>The module or artifact, e.g.: &quot;ant-junit&quot;; required unless the compact form is used.</source>
          <target state="translated">模块或人工制品,如。&quot;ant-junit&quot;;除非使用紧凑形式,否则需要。</target>
        </trans-unit>
        <trans-unit id="67b83bce5d6428054b151a952a38c76fc1400e95" translate="yes" xml:space="preserve">
          <source>The name of the command.</source>
          <target state="translated">命令的名称。</target>
        </trans-unit>
        <trans-unit id="43aae32f2ac7a4701fa066c8a7276ef64ed1c079" translate="yes" xml:space="preserve">
          <source>The name of the property. The name is &quot;get&quot;+ the capitalized propertyName or, in the case of boolean values, &quot;is&quot; + the capitalized propertyName</source>
          <target state="translated">属性的名称。名称为 &quot;get &quot;+大写的属性名,如果是布尔值,则为 &quot;is &quot;+大写的属性名。</target>
        </trans-unit>
        <trans-unit id="38191355c55cbbc00969fffa25036a9e046325a0" translate="yes" xml:space="preserve">
          <source>The name of the property. The name is &quot;set&quot;+ the capitalized propertyName.</source>
          <target state="translated">属性的名称。名称为 &quot;设置 &quot;+大写的属性名。</target>
        </trans-unit>
        <trans-unit id="a15c19401cb99e1843f9f1f65dd9a34cd037b984" translate="yes" xml:space="preserve">
          <source>The new MetaClass</source>
          <target state="translated">新的MetaClass</target>
        </trans-unit>
        <trans-unit id="ce3d1a75c8717139ff820f7f834e634eaf7a158b" translate="yes" xml:space="preserve">
          <source>The newly created Calendar</source>
          <target state="translated">新创建的日历</target>
        </trans-unit>
        <trans-unit id="c75c777743c28c6ddb34992b6df6f585ae387f8b" translate="yes" xml:space="preserve">
          <source>The newly created Date</source>
          <target state="translated">新创建的日期</target>
        </trans-unit>
        <trans-unit id="343fa99691cb8eb1227394b817b70099749bdacd" translate="yes" xml:space="preserve">
          <source>The next example describes a closure as accepting two signatures (List&amp;lt;T&amp;gt; list -&amp;gt;) and (T t -&amp;gt;):</source>
          <target state="translated">下一个示例将闭包描述为接受两个签名（List &amp;lt;T&amp;gt; list-&amp;gt;）和（T t-&amp;gt;）：</target>
        </trans-unit>
        <trans-unit id="35ccc24e2e75124aaac905d871e93bf9a5f09134" translate="yes" xml:space="preserve">
          <source>The node must be called with either a value argument or a title: attribute.</source>
          <target state="translated">调用该节点时必须使用值参数或title:属性。</target>
        </trans-unit>
        <trans-unit id="032b81eac6a8ead6bf3bea51101baeb3b3e0d8f0" translate="yes" xml:space="preserve">
          <source>The number of characters actually skipped</source>
          <target state="translated">实际跳过的字符数</target>
        </trans-unit>
        <trans-unit id="3c9016a339d21ce2a804e220ce7a8e37661b04db" translate="yes" xml:space="preserve">
          <source>The number of characters read or -1 if there are no more</source>
          <target state="translated">读取的字符数,如果没有更多字符,则为-1。</target>
        </trans-unit>
        <trans-unit id="ecf5ab475eeef8fcb49643a9532fa7b4dc7af88a" translate="yes" xml:space="preserve">
          <source>The number of characters read, or -1 if the end of the stream has been reached</source>
          <target state="translated">读取的字符数,如果已经到达流的终点,则为-1。</target>
        </trans-unit>
        <trans-unit id="0f80b964b2a13be3af83a2b98edb531c0a483f10" translate="yes" xml:space="preserve">
          <source>The number of needed instructions is thus reduced from 15 to 4. For every entry we save 3 bytecode instructions. This allows better readable bytecode and it allows the JIT to see less bytecode to optimize, helping under the inlining threshold here or there.</source>
          <target state="translated">因此,所需的指令数量从15条减少到4条。每一个条目我们都会保存3条字节码指令。这使得字节码具有更好的可读性,并且它允许JIT看到更少的字节码来优化,有助于在这里或那里的内联阈值下。</target>
        </trans-unit>
        <trans-unit id="d66cf7d98d8141c6d3db9afd12ffdb8fc3310252" translate="yes" xml:space="preserve">
          <source>The object holding the data value.</source>
          <target state="translated">持有数据值的对象。</target>
        </trans-unit>
        <trans-unit id="850f532ee8584882c8e75e990fb14ebbbde70875" translate="yes" xml:space="preserve">
          <source>The object that registers method calls on it for the use with Mocks and Stubs. For each call a CallSpec object is added to the recorded list.</source>
          <target state="translated">在其上注册方法调用的对象,供Mocks和Stubs使用。对于每个调用,一个CallSpec对象被添加到记录列表中。</target>
        </trans-unit>
        <trans-unit id="4375205097b015888ab65280d3b96851ded2b956" translate="yes" xml:space="preserve">
          <source>The old MetaClass</source>
          <target state="translated">旧的MetaClass</target>
        </trans-unit>
        <trans-unit id="58e4156ceefaea5d9509b6380a238b14d924e012" translate="yes" xml:space="preserve">
          <source>The oldest entry(i.e. the Less Recently Used entry) will be evicted</source>
          <target state="translated">最老的条目(即较少使用的条目)将被驱逐。</target>
        </trans-unit>
        <trans-unit id="2dd46ef926874e9055f1e4cf7568213be97d6b34" translate="yes" xml:space="preserve">
          <source>The one and only implementation of a meta class. INTERNAL USE ONLY.</source>
          <target state="translated">一个元类的唯一实现。仅供内部使用。</target>
        </trans-unit>
        <trans-unit id="91a1c774e1d0fe1b0b5303c859052c21b6258376" translate="yes" xml:space="preserve">
          <source>The one-sentence summary for the package derived from the beginning of the description.</source>
          <target state="translated">从描述开头得出的包件的一句话摘要。</target>
        </trans-unit>
        <trans-unit id="9b73f8f765fe9a956ade4dde4833c77ee65e1eb9" translate="yes" xml:space="preserve">
          <source>The only difference between Java strings and JavaScript strings is that in JavaScript, a single quote must be escaped.</source>
          <target state="translated">Java字符串和JavaScript字符串的唯一区别是,在JavaScript中,单引号必须被转义。</target>
        </trans-unit>
        <trans-unit id="39accb2b332a1b9e56c3ee6ac627961ec2636b16" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;interceptConstruction&lt;/code&gt; flag allows mocking of constructor calls.</source>
          <target state="translated">可选的 &lt;code&gt;interceptConstruction&lt;/code&gt; 标志允许模拟构造函数调用。</target>
        </trans-unit>
        <trans-unit id="2144302020ab0d839d4af265778a87ee9caa1988" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;interceptConstruction&lt;/code&gt; flag allows mocking of constructor calls. These are represented in the demand specification using the class name as this example shows:</source>
          <target state="translated">可选的 &lt;code&gt;interceptConstruction&lt;/code&gt; 标志允许模拟构造函数调用。这些在需求规范中使用类名表示，如本示例所示：</target>
        </trans-unit>
        <trans-unit id="d46ce745b7d040a6af0b7952e782405f90be5a6f" translate="yes" xml:space="preserve">
          <source>The optional parameter for tags like &quot;throws&quot; and &quot;param&quot;.</source>
          <target state="translated">&quot;throws &quot;和 &quot;param &quot;等标签的可选参数。</target>
        </trans-unit>
        <trans-unit id="7e32f979195511f753ad4cf62e43dcd18cd136c7" translate="yes" xml:space="preserve">
          <source>The options array is used to modify the behavior of this hint. Each string in the option array consists of a key=value pair.</source>
          <target state="translated">选项数组用于修改该提示的行为。选项数组中的每个字符串都由key=value对组成。</target>
        </trans-unit>
        <trans-unit id="7b48b46c9d0ec14ed87e0211dbb48b950e8e8d55" translate="yes" xml:space="preserve">
          <source>The order of parameters is given by the properties of any super classes (if &lt;code&gt;includeSuperProperties&lt;/code&gt; is set) with the most super first followed by the properties of the class followed by the fields of the class (if &lt;code&gt;includeFields&lt;/code&gt; is set). Within each grouping the order is as attributes appear within the respective class.</source>
          <target state="translated">参数的顺序是由任何超级类的属性（如果设置了 &lt;code&gt;includeSuperProperties&lt;/code&gt; ）给出的，其优先级最高，其次是该类的属性，其次是该类的字段（如果设置了 &lt;code&gt;includeFields&lt;/code&gt; ）。在每个分组中，顺序是属性出现在相应类中时的顺序。</target>
        </trans-unit>
        <trans-unit id="5fbc45ad553a921f8843e5823598f573c5e856ec" translate="yes" xml:space="preserve">
          <source>The organisation or group, e.g.: &quot;org.apache.ant&quot;.</source>
          <target state="translated">组织或团体,例如:&quot; org.apache.ant&quot;。&quot;org.apache.ant&quot;。</target>
        </trans-unit>
        <trans-unit id="adc438730ea65642ec0cc71f1ada8471e6f24d75" translate="yes" xml:space="preserve">
          <source>The organisation or group, e.g.: &quot;org.apache.ant&quot;. A non-empty value is required unless value() is used.</source>
          <target state="translated">组织或团体,例如:&quot; org.apache.ant&quot;。&quot;org.apache.ant&quot;。除非使用value(),否则需要一个非空值。</target>
        </trans-unit>
        <trans-unit id="5c1050236f9bfcb9f997fc983fb0d67f42762c0d" translate="yes" xml:space="preserve">
          <source>The organisation or group, e.g.: &quot;org.apache.ant&quot;; required unless the compact form is used.</source>
          <target state="translated">组织或团体,如 &quot;org.apache.ant&quot;;必须填写,除非使用紧凑形式。</target>
        </trans-unit>
        <trans-unit id="cf0ae96fdb2085b66ea3bb93836f5dbda67d76df" translate="yes" xml:space="preserve">
          <source>The original AST or null if it cannot be returned</source>
          <target state="translated">原始AST,如果不能返回则为空。</target>
        </trans-unit>
        <trans-unit id="463c8561d710e01b478880e4165ed134de96d70b" translate="yes" xml:space="preserve">
          <source>The original Throwable but with a sanitized stack trace</source>
          <target state="translated">原始的Throwable,但有一个经过消毒的堆栈跟踪。</target>
        </trans-unit>
        <trans-unit id="550e2fe2cda92d999ef8b8744582f726ca7d70d3" translate="yes" xml:space="preserve">
          <source>The original slurper and lexer use this class. This is kept around in case someone needs its exact behavior. Enum listing all the possible JSON tokens that should be recognized by the lexer.</source>
          <target state="translated">原来的slurper和lexer使用这个类。保留这个类是为了防止有人需要它的确切行为。枚举列出了所有可能的JSON标记,这些标记应该被lexer识别。</target>
        </trans-unit>
        <trans-unit id="4cf6c32888a66c7be9b42c3c4ddc926c89cf2d2d" translate="yes" xml:space="preserve">
          <source>The other typical usage, uses the self object while creating some value:</source>
          <target state="translated">另一种典型的用法,使用self对象,同时创造一些价值。</target>
        </trans-unit>
        <trans-unit id="ca0fdc2ddc244d43905d142929aaff47d915c14d" translate="yes" xml:space="preserve">
          <source>The other way is to add annotations to the alias:</source>
          <target state="translated">另一种方式是给别名添加注释。</target>
        </trans-unit>
        <trans-unit id="f9e8045bb0c75ecafe6640585dfaad1f947bcf4b" translate="yes" xml:space="preserve">
          <source>The owning shell.</source>
          <target state="translated">自己的外壳。</target>
        </trans-unit>
        <trans-unit id="74c2e67b95c48b05cb96c4651b224ecc651abf77" translate="yes" xml:space="preserve">
          <source>The parser for Groovy programming language, which is based on the parser generated by Antlr4</source>
          <target state="translated">Groovy编程语言的解析器,它是基于Antlr4生成的解析器。</target>
        </trans-unit>
        <trans-unit id="c4db92f843c33741921f53930bfa252393bdb5ad" translate="yes" xml:space="preserve">
          <source>The particular unit decremented by depends on the specific sub-type of &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/temporal/Temporal.html&quot;&gt;Temporal&lt;/a&gt;. Most sub-types use a unit of &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/temporal/ChronoUnit.html#SECONDS&quot;&gt;ChronoUnit.SECONDS&lt;/a&gt; except for</source>
          <target state="translated">递减的特定单位取决于&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/temporal/Temporal.html&quot;&gt;Temporal&lt;/a&gt;的特定子类型。大多数子类型使用&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/temporal/ChronoUnit.html#SECONDS&quot;&gt;ChronoUnit.SECONDS&lt;/a&gt;的单位，但</target>
        </trans-unit>
        <trans-unit id="0931b94d8ae13c47b9a85df31fbc353bf2a74861" translate="yes" xml:space="preserve">
          <source>The particular unit incremented by depends on the specific sub-type of &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/temporal/Temporal.html&quot;&gt;Temporal&lt;/a&gt;. Most sub-types use a unit of &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/temporal/ChronoUnit.html#SECONDS&quot;&gt;ChronoUnit.SECONDS&lt;/a&gt; except for</source>
          <target state="translated">递增的特定单位取决于&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/temporal/Temporal.html&quot;&gt;Temporal&lt;/a&gt;的特定子类型。大多数子类型使用&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/temporal/ChronoUnit.html#SECONDS&quot;&gt;ChronoUnit.SECONDS&lt;/a&gt;的单位，但</target>
        </trans-unit>
        <trans-unit id="e3baee579d0f99a112462a4af57608a9a896b5c9" translate="yes" xml:space="preserve">
          <source>The permission groovy.security.GroovyCodeSourcePermission will be used to determine if the given codeBase may be specified. That is, the current Policy set must have a GroovyCodeSourcePermission that implies the codeBase, or an exception will be thrown. This is to prevent callers from hijacking existing codeBase policy entries unless explicitly authorized by the user.</source>
          <target state="translated">groovy.security.GroovyCodeSourcePermission这个权限将被用来决定是否可以指定给定的代码库。也就是说,当前的策略集必须有一个暗示代码库的GroovyCodeSourcePermission,否则将抛出一个异常。这是为了防止调用者劫持现有的codeBase策略条目,除非用户明确授权。</target>
        </trans-unit>
        <trans-unit id="b23c39fbfa279511d3e7fc40992076c646fe704c" translate="yes" xml:space="preserve">
          <source>The phases as an array, with a null entry.</source>
          <target state="translated">阶段作为一个数组,有一个空条目。</target>
        </trans-unit>
        <trans-unit id="5a50aa1f415a2950a9c3ea1c28386340df92373c" translate="yes" xml:space="preserve">
          <source>The phases of the GroovyCompiler. This is an enum facade on top of the Phases object. In general, prefer using this object over Phases.</source>
          <target state="translated">GroovyCompiler的阶段。这是在Phases对象之上的一个枚举门面。一般来说,比起Phases,更喜欢使用这个对象。</target>
        </trans-unit>
        <trans-unit id="d0555c21af552adf2c625446c48cfa44d487360f" translate="yes" xml:space="preserve">
          <source>The position of the curried parameters will be calculated eagerly and implies all arguments prior to the specified n index are supplied. Default parameter values prior to the n index will not be available.</source>
          <target state="translated">夤缘参数的位置将被急切地计算出来,并意味着指定的n索引之前的所有参数都被提供。在n索引之前的默认参数值将不可用。</target>
        </trans-unit>
        <trans-unit id="b99f34149701f4f317b757b6f7be07e6c77a0502" translate="yes" xml:space="preserve">
          <source>The position of the curried parameters will be calculated lazily, for example, if two overloaded doCall methods are available, the supplied arguments plus the curried arguments will be concatenated and the result used for method selection.</source>
          <target state="translated">咖哩参数的位置将被懒惰地计算出来,例如,如果有两个重载的doCall方法,提供的参数加上咖哩参数将被连在一起,结果用于方法选择。</target>
        </trans-unit>
        <trans-unit id="d4d57362120a781eed62a17257a436f5c3b9c1de" translate="yes" xml:space="preserve">
          <source>The position tree of multi-line comments.</source>
          <target state="translated">多行注释的位置树。</target>
        </trans-unit>
        <trans-unit id="3d2d8d4480d18b9fc0a2174c8cfea817348cc881" translate="yes" xml:space="preserve">
          <source>The prefix to use when creating the setter methods.</source>
          <target state="translated">创建setter方法时使用的前缀。</target>
        </trans-unit>
        <trans-unit id="6dec45555f03c899ffc22df52915fd879b9c58b0" translate="yes" xml:space="preserve">
          <source>The prefix to use when creating the setter methods. Default is determined by the strategy which might use &quot;&quot; or &quot;set&quot; but you can choose your own, e.g. &quot;with&quot;. If non-empty the first letter of the property will be capitalized before being appended to the prefix.</source>
          <target state="translated">创建setter方法时要使用的前缀。默认值由策略决定,可能使用&quot;&quot;或 &quot;set&quot;,但你可以选择你自己的,例如 &quot;with&quot;。如果非空,属性的第一个字母将在附加到前缀前大写。</target>
        </trans-unit>
        <trans-unit id="c03948908d1373a091dc6fd5073476e494fdead0" translate="yes" xml:space="preserve">
          <source>The problem this annotation tries to solve is to define the expected parameter types of the</source>
          <target state="translated">这个注解试图解决的问题是定义预期参数类型的</target>
        </trans-unit>
        <trans-unit id="404ee7e80d97420044d8572424c53f96977d7292" translate="yes" xml:space="preserve">
          <source>The produced code for the above example looks like this:</source>
          <target state="translated">上面的例子产生的代码是这样的。</target>
        </trans-unit>
        <trans-unit id="66d47ea438a29f8f03b670b0bcbb6770f0998399" translate="yes" xml:space="preserve">
          <source>The properties to use can be filtered using either the 'includes' or 'excludes' annotation attributes for &lt;code&gt;@Builder&lt;/code&gt;. The &lt;code&gt;@Builder&lt;/code&gt; 'buildMethodName' annotation attribute can be used for configuring the build method's name, default &quot;build&quot;. The &lt;code&gt;@Builder&lt;/code&gt; 'builderMethodName' and 'builderClassName' annotation attributes aren't applicable for this strategy. The &lt;code&gt;@Builder&lt;/code&gt; 'useSetters' annotation attribute is ignored by this strategy which always uses setters.</source>
          <target state="translated">可以使用 &lt;code&gt;@Builder&lt;/code&gt; 的'includes'或'excludes'注释属性来过滤要使用的属性。该 &lt;code&gt;@Builder&lt;/code&gt; &amp;ldquo;buildMethodName&amp;rdquo;注释属性可用于配置构建方法的名称，默认情况下&amp;ldquo;打造&amp;rdquo;。该 &lt;code&gt;@Builder&lt;/code&gt; &amp;ldquo;builderMethodName&amp;rdquo;和&amp;ldquo;builderClassName&amp;rdquo;注释属性不适用于这一策略。该 &lt;code&gt;@Builder&lt;/code&gt; &amp;ldquo;useSetters&amp;rdquo;注释属性这个战略，总是使用制定者忽略。</target>
        </trans-unit>
        <trans-unit id="0bccb759e3c0e6e0247c634660331a9f94034269" translate="yes" xml:space="preserve">
          <source>The properties value</source>
          <target state="translated">属性值</target>
        </trans-unit>
        <trans-unit id="d776cd3bdbba7c1073d917e7c7a9132e4549183f" translate="yes" xml:space="preserve">
          <source>The properties within the class must themselves be &lt;code&gt;Comparable&lt;/code&gt; or &lt;code&gt;@Sortable&lt;/code&gt;.</source>
          <target state="translated">类中的属性本身必须是 &lt;code&gt;Comparable&lt;/code&gt; 或 &lt;code&gt;@Sortable&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7ed4236c8f797aaa8636050cfd80ec30bfeeed44" translate="yes" xml:space="preserve">
          <source>The property handler class which creates the necessary code for getting, setting or initializing properties.</source>
          <target state="translated">属性处理程序类,为获取、设置或初始化属性创建必要的代码。</target>
        </trans-unit>
        <trans-unit id="5c2099cb7601f141e152a819c05e4db6c35a60d7" translate="yes" xml:space="preserve">
          <source>The property name equivalent</source>
          <target state="translated">相当于财产名称</target>
        </trans-unit>
        <trans-unit id="068bd70d79a0f3161e77c6b20503123007a1632e" translate="yes" xml:space="preserve">
          <source>The property to set on compilation failure.</source>
          <target state="translated">编译失败时要设置的属性。</target>
        </trans-unit>
        <trans-unit id="1bed8d7b5a8bdc81a2320b7e7824add1844ac6dc" translate="yes" xml:space="preserve">
          <source>The property to set on compilation failure. This property will be set if the compilation fails.</source>
          <target state="translated">编译失败时要设置的属性。如果编译失败,将设置此属性。</target>
        </trans-unit>
        <trans-unit id="b106043c5c6468760b416e5a4f5dc8142c486625" translate="yes" xml:space="preserve">
          <source>The property to set on compilation success.</source>
          <target state="translated">编译成功时要设置的属性。</target>
        </trans-unit>
        <trans-unit id="39baf3f1877fa6a76dce4eda62ece0b8909c7323" translate="yes" xml:space="preserve">
          <source>The property to set on compilation success. This property will not be set if the compilation fails, or if there are no files to compile.</source>
          <target state="translated">编译成功时要设置的属性。如果编译失败或没有文件可编译,则不会设置此属性。</target>
        </trans-unit>
        <trans-unit id="bc70b9bacce6273f76ef6e4471c4dab865527fa7" translate="yes" xml:space="preserve">
          <source>The purpose is the reduction of the size of the bytecode. Consider creating a three element Object[] with null values:</source>
          <target state="translated">目的是减少字节码的大小。考虑创建一个带有空值的三元素Object[]。</target>
        </trans-unit>
        <trans-unit id="666faa1948c36e5a23029d8167b7a82bae76aa8a" translate="yes" xml:space="preserve">
          <source>The qualified name including any dimension information.</source>
          <target state="translated">包括任何尺寸信息的限定名称。</target>
        </trans-unit>
        <trans-unit id="98b1825554dc394c8049d1d532250cea4ed423f2" translate="yes" xml:space="preserve">
          <source>The qualified name including any dimension information. For example, a two dimensional array of String returns &quot;&lt;code&gt;java.lang.String[][]&lt;/code&gt;&quot;, and the parameterized type &lt;code&gt;List&amp;lt;Integer&amp;gt;&lt;/code&gt; returns &quot;&lt;code&gt;java.util.List&amp;lt;java.lang.Integer&amp;gt;&lt;/code&gt;&quot;.</source>
          <target state="translated">限定名称，包括任何尺寸信息。例如，String的二维数组返回&amp;ldquo; &lt;code&gt;java.lang.String[][]&lt;/code&gt; &amp;rdquo;，而参数化类型 &lt;code&gt;List&amp;lt;Integer&amp;gt;&lt;/code&gt; 返回&amp;ldquo; &lt;code&gt;java.util.List&amp;lt;java.lang.Integer&amp;gt;&lt;/code&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="6749c09dae1f16ee309de33291725a38354b80c1" translate="yes" xml:space="preserve">
          <source>The qualified name of this type excluding any dimension information.</source>
          <target state="translated">此类型的限定名称,不包括任何尺寸信息。</target>
        </trans-unit>
        <trans-unit id="5524ad7e8d6e056655d2c24925da6512f7f6b810" translate="yes" xml:space="preserve">
          <source>The qualified name of this type excluding any dimension information. For example, a two dimensional array of String returns &quot;&lt;code&gt;java.lang.String&lt;/code&gt;&quot;.</source>
          <target state="translated">此类型的限定名称，不包括任何尺寸信息。例如，String的二维数组返回&amp;ldquo; &lt;code&gt;java.lang.String&lt;/code&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="afc755459d1d6c162948ac88fb407664086e913e" translate="yes" xml:space="preserve">
          <source>The recommended way of securing shells is to use allowed lists because it is guaranteed that future features of the Groovy language won't be accidentally allowed unless explicitly added to the allowed list. Using disallowed lists, you can limit the features of the language constructs supported by your shell by opting out, but new language features are then implicitly also available and this may not be desirable. The implication is that you might need to update your configuration with each new release.</source>
          <target state="translated">推荐的保障shell安全的方式是使用允许列表,因为它可以保证Groovy语言未来的功能不会被意外允许,除非明确地添加到允许列表中。使用不允许列表,你可以通过选择退出来限制你的shell所支持的语言构造的功能,但是新的语言功能就会被隐含在其中,这可能是不可取的。这意味着你可能需要在每个新版本中更新你的配置。</target>
        </trans-unit>
        <trans-unit id="7890a44bd59bb88228f8c74508210c196c09f718" translate="yes" xml:space="preserve">
          <source>The replace method to use on the matcher.</source>
          <target state="translated">在匹配器上使用的替换方法。</target>
        </trans-unit>
        <trans-unit id="2d65383712d8a239399641a0d18670d69f0cea91" translate="yes" xml:space="preserve">
          <source>The replacement used by the resource name matcher.</source>
          <target state="translated">资源名称匹配器使用的替换。</target>
        </trans-unit>
        <trans-unit id="183b2d9cf750ef4356762e7761f879eb6c2e10e8" translate="yes" xml:space="preserve">
          <source>The resgistry</source>
          <target state="translated">资源部</target>
        </trans-unit>
        <trans-unit id="8b60066e74974428693cf317396c392559fe4dcf" translate="yes" xml:space="preserve">
          <source>The resolve strategy</source>
          <target state="translated">决心战略</target>
        </trans-unit>
        <trans-unit id="d6a1ea6deab0be8f01a56df21bf7e874402baa48" translate="yes" xml:space="preserve">
          <source>The result is a closure which can have the following forms:</source>
          <target state="translated">其结果是一个闭合,可以有以下形式:</target>
        </trans-unit>
        <trans-unit id="f8073c98c26e1541e605cf9192ccb46ebece88e7" translate="yes" xml:space="preserve">
          <source>The result of the merge</source>
          <target state="translated">合并的结果</target>
        </trans-unit>
        <trans-unit id="b4fd3dd77a58f818d8c3faf56a7c1b1b58fac08e" translate="yes" xml:space="preserve">
          <source>The result of the propertyMissing method or throws MissingPropertyException</source>
          <target state="translated">propertyMissing方法的结果或引发MissingPropertyException。</target>
        </trans-unit>
        <trans-unit id="becf539a2208e344834f816674f2d5fcf96548ba" translate="yes" xml:space="preserve">
          <source>The resulting translated &lt;code&gt;String&lt;/code&gt;</source>
          <target state="translated">结果转换后的 &lt;code&gt;String&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c1d34dfb3088ea17d04b40b40c5f003d8f05e4fe" translate="yes" xml:space="preserve">
          <source>The results of methodMissing or throws MissingMethodException</source>
          <target state="translated">methodMissing的结果或者抛出MissingMethodException。</target>
        </trans-unit>
        <trans-unit id="476c927d4d90fe65f6bab20cb57f17b4834562dd" translate="yes" xml:space="preserve">
          <source>The return value of the invocation</source>
          <target state="translated">调用的返回值</target>
        </trans-unit>
        <trans-unit id="f772844e69ffcc0220695a141278b4ea7430de9f" translate="yes" xml:space="preserve">
          <source>The return value of the invoked method.</source>
          <target state="translated">被调用方法的返回值。</target>
        </trans-unit>
        <trans-unit id="62d80f160e3301c563f71de2f15701a15461fe3a" translate="yes" xml:space="preserve">
          <source>The return value of the method</source>
          <target state="translated">该方法的返回值</target>
        </trans-unit>
        <trans-unit id="d97df77d5d16cf6f0d57a6d6752ee61825a4cc88" translate="yes" xml:space="preserve">
          <source>The return value of the method which is null if the return type is void</source>
          <target state="translated">方法的返回值,如果返回类型为void,则返回值为空。</target>
        </trans-unit>
        <trans-unit id="8583dcdd18eee679eec49286a13176c4259a5294" translate="yes" xml:space="preserve">
          <source>The returning parameter is commonly set to true when using with to simplify object creation, such as this example:</source>
          <target state="translated">当使用with简化对象创建时,返回参数通常设置为true,如本例。</target>
        </trans-unit>
        <trans-unit id="875acf317a8f8529a69052fe176958b2bd26bb44" translate="yes" xml:space="preserve">
          <source>The revision or version, e.g.: &quot;1.7.1&quot;.</source>
          <target state="translated">修订版或版本,例如:&quot;1.7.1&quot;。&quot;1.7.1&quot;.</target>
        </trans-unit>
        <trans-unit id="5cd485b893e87dd0b6efe0f84be74a2b0e50d049" translate="yes" xml:space="preserve">
          <source>The revision or version, e.g.: &quot;1.7.1&quot;. A non-empty value is required unless value() is used.</source>
          <target state="translated">修订版或版本,例如:&quot;1.7.1&quot;。&quot;1.7.1&quot;.除非使用value(),否则需要一个非空值。</target>
        </trans-unit>
        <trans-unit id="7c207af991fb99091fa8f287c2da7adabb871197" translate="yes" xml:space="preserve">
          <source>The right way to use it for JUnit 3 is:</source>
          <target state="translated">JUnit 3的正确使用方法是。</target>
        </trans-unit>
        <trans-unit id="7d858a85c56dc4b03eac0fe169dc4fa68051e7d8" translate="yes" xml:space="preserve">
          <source>The root cause exception instance, with its stace trace modified to filter out groovy runtime classes</source>
          <target state="translated">根原因异常实例,其stce跟踪被修改为过滤掉了groovy运行时类</target>
        </trans-unit>
        <trans-unit id="865af8ea215cefa5991c9cc5122354fadb48bb74" translate="yes" xml:space="preserve">
          <source>The root cause exception instances, with stack trace modified to filter out groovy runtime classes</source>
          <target state="translated">根源异常实例,堆栈跟踪修改为过滤掉groovy运行时类。</target>
        </trans-unit>
        <trans-unit id="e93c1b520cbd7836f0f8c1b4fd013c4e8d1129b1" translate="yes" xml:space="preserve">
          <source>The root of the Abstract Syntax Tree for the source</source>
          <target state="translated">源的抽象语法树的根。</target>
        </trans-unit>
        <trans-unit id="67a7915a02520c39d9f254645135aa63e22bb403" translate="yes" xml:space="preserve">
          <source>The root of the lexical parsing tree.</source>
          <target state="translated">词汇解析树的根。</target>
        </trans-unit>
        <trans-unit id="56fa669d54b1368623bad8fc50daad712171e89f" translate="yes" xml:space="preserve">
          <source>The short name of this option.</source>
          <target state="translated">该选项的简称。</target>
        </trans-unit>
        <trans-unit id="d865d69887c0552a76349586553be28eee417b21" translate="yes" xml:space="preserve">
          <source>The short name of this option. Defaults to the name of member being annotated if the longName is empty.</source>
          <target state="translated">这个选项的简称。如果longName为空,默认为被注释的成员名称。</target>
        </trans-unit>
        <trans-unit id="ba2891c2488b5c6f4342d686b2788cfdf34b392d" translate="yes" xml:space="preserve">
          <source>The shortcut switch</source>
          <target state="translated">捷径开关</target>
        </trans-unit>
        <trans-unit id="1dc02e4e7a9421805995dea237ea87f71134df23" translate="yes" xml:space="preserve">
          <source>The signature of this method</source>
          <target state="translated">这种方法的特征</target>
        </trans-unit>
        <trans-unit id="f1492be12bee4c707c0282e56184b32b47ef4804" translate="yes" xml:space="preserve">
          <source>The simple name of the annotation including the &quot;@&quot; or null if no such name is defined</source>
          <target state="translated">注释的简单名称,包括&quot;@&quot;,如果没有定义这样的名称,则为空。</target>
        </trans-unit>
        <trans-unit id="2b4b71213506f4e0356dfd5fc20a5f6e429010dd" translate="yes" xml:space="preserve">
          <source>The source units from which this unit is built.</source>
          <target state="translated">本单位的源单位是由。</target>
        </trans-unit>
        <trans-unit id="01401bd4b3d5f57ed6503d187a050f41b2a42df8" translate="yes" xml:space="preserve">
          <source>The standard use for this method is when a table has an autoincrement ID column and you want to know what the ID is for a newly inserted row. In this example, we insert a single row into a table in which the first column contains the autoincrement ID:</source>
          <target state="translated">这个方法的标准用法是当一个表有一个自动增加ID列,你想知道新插入的行的ID是什么。在这个例子中,我们在表中插入一条单行,其中第一列包含自动增量ID。</target>
        </trans-unit>
        <trans-unit id="9275509b872e0adb76980a0373cc6d87c6055af3" translate="yes" xml:space="preserve">
          <source>The stream can be for example a FileInputStream from a file with the following format:</source>
          <target state="translated">例如,该流可以是来自文件的FileInputStream,格式如下。</target>
        </trans-unit>
        <trans-unit id="15cc0423f1955111b4c08c47e52328fbdd00b69f" translate="yes" xml:space="preserve">
          <source>The string must be in the form returned by the QName.toString() method, i.e. &quot;{namespaceURI}localPart&quot;, with the &quot;{namespaceURI}&quot; part being optional.</source>
          <target state="translated">该字符串必须采用QName.toString()方法返回的形式,即&quot;{namespaceURI}localPart&quot;,&quot;{namespaceURI}&quot;部分是可选的。</target>
        </trans-unit>
        <trans-unit id="22771b89b44cb0db24fad01ea17fe01b726ba658" translate="yes" xml:space="preserve">
          <source>The string representation of the annotation reference.</source>
          <target state="translated">注释引用的字符串表示。</target>
        </trans-unit>
        <trans-unit id="5e599db1ac6ef94f8579d026e88b608cf27ff8b8" translate="yes" xml:space="preserve">
          <source>The string representation of the annotation reference. Initially implemented as a temporary hack stored from the source. To be replaced with strong-typed finer grained information.</source>
          <target state="translated">注释引用的字符串表示。最初是作为临时黑客实现的,从源头存储。将被强类型的细粒度信息所取代。</target>
        </trans-unit>
        <trans-unit id="fb22d22c184c47ba3163340422accef7dd9ed1ff" translate="yes" xml:space="preserve">
          <source>The sum of all of the items</source>
          <target state="translated">所有项目的总和</target>
        </trans-unit>
        <trans-unit id="40d0ac42b8edc1dae134c503efef716fc53d98f4" translate="yes" xml:space="preserve">
          <source>The sum of all of the items.</source>
          <target state="translated">所有项目的总和。</target>
        </trans-unit>
        <trans-unit id="989e25ec9928e09df7ee1acc43fc9c0880df69ad" translate="yes" xml:space="preserve">
          <source>The sum of the values returned by applying the closure to each item from the Iterator.</source>
          <target state="translated">对来自迭代器的每个项目应用闭包返回的值的总和。</target>
        </trans-unit>
        <trans-unit id="c9e7ecaf4ca357ee681a27b991a11fab6d65dff1" translate="yes" xml:space="preserve">
          <source>The sum of the values returned by applying the closure to each item of the Iterable.</source>
          <target state="translated">对Iterable的每个项目应用闭包返回的值的总和。</target>
        </trans-unit>
        <trans-unit id="0e89a462ab069558ccc92abaa6becf7fe7ca0492" translate="yes" xml:space="preserve">
          <source>The sum of the values returned by applying the closure to each item of the array.</source>
          <target state="translated">对数组中的每个项目应用闭包返回的值的总和。</target>
        </trans-unit>
        <trans-unit id="e0fe680303e1ca58932bb92ab26453355acda86b" translate="yes" xml:space="preserve">
          <source>The sum of the values returned by applying the closure to each item of the collection.</source>
          <target state="translated">对集合中的每个项目应用闭包返回的值的总和。</target>
        </trans-unit>
        <trans-unit id="5ca0e801895a43143eb85bd9dd3e4c911b3a6cad" translate="yes" xml:space="preserve">
          <source>The table is rehashed when its size exceeds this threshold.</source>
          <target state="translated">当表的大小超过这个阈值时,就会被重做。</target>
        </trans-unit>
        <trans-unit id="8516c49e4447a484bd801473d4d78b70be591b01" translate="yes" xml:space="preserve">
          <source>The table is rehashed when its size exceeds this threshold. (The value of this field is always (int)(capacity * loadFactor).)</source>
          <target state="translated">当表的大小超过这个阈值时,表会被重写。此字段的值总是(int)(capacity*loadFactor)。</target>
        </trans-unit>
        <trans-unit id="2509a2b15c4fec90b1a89dfc73783afc5e5011fd" translate="yes" xml:space="preserve">
          <source>The tag name, e.g.</source>
          <target state="translated">标签名称,例如:</target>
        </trans-unit>
        <trans-unit id="db1db9824ee90a8accc29a6f47094d8320d3122c" translate="yes" xml:space="preserve">
          <source>The tag name, e.g. &quot;deprecated&quot;, &quot;param&quot;, &quot;see&quot; or &quot;author&quot;.</source>
          <target state="translated">标签名称,如 &quot;废弃的&quot;、&quot;param&quot;、&quot;see &quot;或 &quot;作者&quot;。</target>
        </trans-unit>
        <trans-unit id="bab8307ff605a63f18f27b4b6a7d097cd05e8a14" translate="yes" xml:space="preserve">
          <source>The tail of a declaration.</source>
          <target state="translated">宣言的尾巴。</target>
        </trans-unit>
        <trans-unit id="f9066d16633090f75058b4bd1ecc26ce2c11677e" translate="yes" xml:space="preserve">
          <source>The tail of a declaration. Either v1, v2, ... (with possible initializers) or else m(args){body}. The two arguments are the modifier list (if any) and the declaration head (if any). The declaration head is the variable type, or (for a method) the return type. If it is missing, then the variable type is taken from its initializer (if there is one). Otherwise, the variable type defaults to 'any'. DECIDE: Method return types default to the type of the method body, as an expression.</source>
          <target state="translated">声明的尾部。要么是v1,v2,...(包括可能的初始化器),或者是m(args){body}。两个参数是修饰符列表(如果有的话)和声明头(如果有的话)。声明头是变量类型,或者(对于一个方法)返回类型。如果缺少声明头,那么变量类型将从它的初始化器(如果有的话)中获取。否则,变量类型默认为'any'。DECIDE.Method的返回类型默认为'any'。方法返回类型默认为方法主体的类型,作为一个表达式。</target>
        </trans-unit>
        <trans-unit id="80c1cd374807e18badc9c825a6ddb035ef579c09" translate="yes" xml:space="preserve">
          <source>The template engine can also be used as the engine for &lt;a href=&quot;../servlet/templateservlet&quot;&gt;TemplateServlet&lt;/a&gt; by placing the following in your &lt;code&gt;web.xml&lt;/code&gt; file (plus a corresponding servlet-mapping element):</source>
          <target state="translated">通过将以下内容放置在 &lt;code&gt;web.xml&lt;/code&gt; 文件中（加上相应的servlet-mapping元素），模板引擎还可以用作&lt;a href=&quot;../servlet/templateservlet&quot;&gt;TemplateServlet&lt;/a&gt;的引擎：</target>
        </trans-unit>
        <trans-unit id="c41f5167f4c55b11e4ca434e73cfd1cfefc8c204" translate="yes" xml:space="preserve">
          <source>The template engine makes an effort to throw descriptive exceptions with context lines, ie:</source>
          <target state="translated">模板引擎努力抛出带有上下文行的描述性异常,即。</target>
        </trans-unit>
        <trans-unit id="b8bfd67b666067ef82bd6d072ceb9ecda1903dc6" translate="yes" xml:space="preserve">
          <source>The template engine uses JSP style &amp;lt;% %&amp;gt; script and &amp;lt;%= %&amp;gt; expression syntax or GString style expressions. The variable '&lt;code&gt;out&lt;/code&gt;' is bound to the writer that the template is being written to.</source>
          <target state="translated">模板引擎使用JSP样式&amp;lt;％％&amp;gt;脚本和&amp;lt;％=％&amp;gt;表达式语法或GString样式表达式。变量' &lt;code&gt;out&lt;/code&gt; '绑定到正在写入模板的作者。</target>
        </trans-unit>
        <trans-unit id="b1e19b0f009154f105e8d40314ebe5b64bfebc12" translate="yes" xml:space="preserve">
          <source>The template that will produce the response text.</source>
          <target state="translated">将产生响应文本的模板。</target>
        </trans-unit>
        <trans-unit id="a5ff9da155da96f8ae444a0f421dd2eedfdd8503" translate="yes" xml:space="preserve">
          <source>The text associated with the tag.</source>
          <target state="translated">与标签相关的文本。</target>
        </trans-unit>
        <trans-unit id="79600bf9bc91a3b3f63e7ddccbd148d4dbd124ed" translate="yes" xml:space="preserve">
          <source>The timer task which has been scheduled.</source>
          <target state="translated">已安排的定时器任务。</target>
        </trans-unit>
        <trans-unit id="1a25852356fb8328146e29a2fd46930da5616780" translate="yes" xml:space="preserve">
          <source>The tool to simulate running script files via groovy command</source>
          <target state="translated">通过groovy命令模拟运行脚本文件的工具。</target>
        </trans-unit>
        <trans-unit id="74e34865ea7d26c8fa280a51bc74328d5c56b6b2" translate="yes" xml:space="preserve">
          <source>The total number of mappings in the hash table.</source>
          <target state="translated">哈希表中的映射总数。</target>
        </trans-unit>
        <trans-unit id="10ed76980b7be55f6560da1b7d64f4c53cb55453" translate="yes" xml:space="preserve">
          <source>The traversal can be adapted by providing various options in the &lt;code&gt;options&lt;/code&gt; Map according to the following keys:</source>
          <target state="translated">可以通过根据以下键在 &lt;code&gt;options&lt;/code&gt; Map中提供各种选项来调整遍历：</target>
        </trans-unit>
        <trans-unit id="31d840e6eaa37d1fb137aba5bd262f3661e3cc96" translate="yes" xml:space="preserve">
          <source>The type descriptor for a method node is a string containing the name of the method, its return type, and its parameter types in a canonical form.</source>
          <target state="translated">方法节点的类型描述符是一个字符串,以规范的形式包含了方法的名称、它的返回类型和它的参数类型。</target>
        </trans-unit>
        <trans-unit id="60a6d9396902e7a9d90719e486b0ecba2c7fd0a1" translate="yes" xml:space="preserve">
          <source>The type descriptor for a method node is a string containing the name of the method, its return type, and its parameter types in a canonical form. For simplicity, we use the format of a Java declaration without parameter names or generics.</source>
          <target state="translated">方法节点的类型描述符是一个字符串,以规范的形式包含了方法的名称、它的返回类型和它的参数类型。为了简单起见,我们使用的是Java声明的格式,没有参数名和属姓。</target>
        </trans-unit>
        <trans-unit id="bfcc6988d78bb654bf23686ac195aa641257ac4b" translate="yes" xml:space="preserve">
          <source>The type member should be used when the type of the delegate cannot be represented with &lt;a href=&quot;#value()&quot;&gt;value()&lt;/a&gt;, &lt;a href=&quot;#genericTypeIndex()&quot;&gt;genericTypeIndex()&lt;/a&gt; or &lt;a href=&quot;#target()&quot;&gt;target()&lt;/a&gt;.</source>
          <target state="translated">当委托的类型不能用&lt;a href=&quot;#value()&quot;&gt;value（）&lt;/a&gt;，&lt;a href=&quot;#genericTypeIndex()&quot;&gt;genericTypeIndex（）&lt;/a&gt;或&lt;a href=&quot;#target()&quot;&gt;target（）&lt;/a&gt;表示时，应使用type成员。</target>
        </trans-unit>
        <trans-unit id="50630842e00d8b1cbbbfcf22c64fecd77803f9f9" translate="yes" xml:space="preserve">
          <source>The type member should be used when the type of the delegate cannot be represented with &lt;a href=&quot;#value()&quot;&gt;value()&lt;/a&gt;, &lt;a href=&quot;#genericTypeIndex()&quot;&gt;genericTypeIndex()&lt;/a&gt; or &lt;a href=&quot;#target()&quot;&gt;target()&lt;/a&gt;. In this case, it is possible to use a String to represent the type, at the cost of potential uncaught errors at compile time if the type is invalid and increased compile time.</source>
          <target state="translated">当委托的类型不能用&lt;a href=&quot;#value()&quot;&gt;value（）&lt;/a&gt;，&lt;a href=&quot;#genericTypeIndex()&quot;&gt;genericTypeIndex（）&lt;/a&gt;或&lt;a href=&quot;#target()&quot;&gt;target（）&lt;/a&gt;表示时，应使用type成员。在这种情况下，可以使用String表示类型，如果类型无效且编译时间增加，则可能会在编译时出现未捕获的错误。</target>
        </trans-unit>
        <trans-unit id="1bc0f50f2984205e14cb09cbea32c757feab1695" translate="yes" xml:space="preserve">
          <source>The type of exception thrown when timeout is reached.</source>
          <target state="translated">超时时抛出的异常类型。</target>
        </trans-unit>
        <trans-unit id="e3db5653f498161246a313203cbeabe10b294791" translate="yes" xml:space="preserve">
          <source>The type of the artifact (normally safe to leave at default value of &quot;jar&quot; but other values like &quot;sources&quot; and &quot;javadoc&quot; are sometimes useful).</source>
          <target state="translated">人造物的类型(通常可以使用默认值 &quot;jar&quot;,但其他值如 &quot;sources &quot;和 &quot;javadoc &quot;有时也有用)。</target>
        </trans-unit>
        <trans-unit id="9c9e817a3159fb3177fbc64ceea3fd2bfa224982" translate="yes" xml:space="preserve">
          <source>The type of the artifact (normally safe to leave at default value of &quot;jar&quot; but other values like &quot;sources&quot; and &quot;javadoc&quot; are sometimes useful). But see also the &quot;classifier&quot; attribute which is also sometimes used for &quot;sources&quot; and &quot;javadoc&quot;.</source>
          <target state="translated">人造物的类型(通常可以使用默认值 &quot;jar&quot;,但其他值如 &quot;sources &quot;和 &quot;javadoc &quot;有时也有用)。但也可以参考 &quot;classifier &quot;属性,它有时也用于 &quot;sources &quot;和 &quot;javadoc&quot;。</target>
        </trans-unit>
        <trans-unit id="4ca920006f30ed914765d9c352a38d568933b700" translate="yes" xml:space="preserve">
          <source>The type of the last encountered &quot;it&quot; implicit parameter.</source>
          <target state="translated">最后遇到的 &quot;it &quot;隐含参数的类型。</target>
        </trans-unit>
        <trans-unit id="9145cf3f9b4a0d09e2af2393fd727c71ebcbb50d" translate="yes" xml:space="preserve">
          <source>The type of the variable annotated with &lt;code&gt;@BaseScript&lt;/code&gt; must extend &lt;a href=&quot;../lang/script&quot;&gt;Script&lt;/a&gt;. It will be used as the base script class. The annotated variable will become shortcut to &lt;code&gt;this&lt;/code&gt; object. Using this annotation will override base script set by Groovy compiler or &lt;a href=&quot;../../org/codehaus/groovy/control/compilerconfiguration&quot;&gt;CompilerConfiguration&lt;/a&gt; of &lt;a href=&quot;../lang/groovyshell&quot;&gt;GroovyShell&lt;/a&gt; Example usage:</source>
          <target state="translated">&lt;code&gt;@BaseScript&lt;/code&gt; 注释的变量类型必须扩展&lt;a href=&quot;../lang/script&quot;&gt;Script&lt;/a&gt;。它将用作基本脚本类。带注释的变量将成为 &lt;code&gt;this&lt;/code&gt; 对象的快捷方式。使用该注释将覆盖由Groovy编译或碱脚本集合&lt;a href=&quot;../../org/codehaus/groovy/control/compilerconfiguration&quot;&gt;CompilerConfiguration&lt;/a&gt;的&lt;a href=&quot;../lang/groovyshell&quot;&gt;GroovyShell&lt;/a&gt;实例：</target>
        </trans-unit>
        <trans-unit id="e03953b92d1333f0ce4ca03983b13c88c5391b2e" translate="yes" xml:space="preserve">
          <source>The type of the variable annotated with &lt;code&gt;@SourceURI&lt;/code&gt; must be assignment compatible with &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/net/URI.html&quot;&gt;URI&lt;/a&gt;. It will be used to hold a URI object that references the source for the current script.</source>
          <target state="translated">用 &lt;code&gt;@SourceURI&lt;/code&gt; 注释的变量的类型必须与&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/net/URI.html&quot;&gt;URI&lt;/a&gt;赋值兼容。它将用于保存引用当前脚本源的URI对象。</target>
        </trans-unit>
        <trans-unit id="72e862454a23154b9c1eada46b694794e382df1f" translate="yes" xml:space="preserve">
          <source>The type on which the field was attempted to be called</source>
          <target state="translated">试图调用该字段的类型。</target>
        </trans-unit>
        <trans-unit id="0ed994342edba2dd4caa2ae969bfced6ca083812" translate="yes" xml:space="preserve">
          <source>The type on which the method was attempted to be called</source>
          <target state="translated">试图调用该方法的类型。</target>
        </trans-unit>
        <trans-unit id="f49a0db00f8e949a09804dd63a36e2982c2bdcc0" translate="yes" xml:space="preserve">
          <source>The type on which the property was attempted to be called</source>
          <target state="translated">试图调用财产的类型。</target>
        </trans-unit>
        <trans-unit id="b5a0be639b682e898850486f3c19bb899731dea4" translate="yes" xml:space="preserve">
          <source>The type that could not be resolved</source>
          <target state="translated">无法解决的类型</target>
        </trans-unit>
        <trans-unit id="22bda5fdc5e6227a7a0c58e47015e24d57b30c81" translate="yes" xml:space="preserve">
          <source>The underlying builder</source>
          <target state="translated">基本建设者</target>
        </trans-unit>
        <trans-unit id="49cf8100ba29bc770b0147077438349a48624460" translate="yes" xml:space="preserve">
          <source>The underlying template engine or &lt;code&gt;null&lt;/code&gt; on error.</source>
          <target state="translated">基础模板引擎或错误时为 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="de822d367304dba12ea8e0e5913a14a4fba0d3f8" translate="yes" xml:space="preserve">
          <source>The unescaped text</source>
          <target state="translated">未填写的文本</target>
        </trans-unit>
        <trans-unit id="66a791c097d23f087f3b2006b4a3b0840ed65768" translate="yes" xml:space="preserve">
          <source>The unqualified name of this type excluding any dimension information.</source>
          <target state="translated">此类型的非限定名称,不包括任何尺寸信息。</target>
        </trans-unit>
        <trans-unit id="932bb11f5980b36dd397c11008ff195342c0ab60" translate="yes" xml:space="preserve">
          <source>The unqualified name of this type excluding any dimension information. For example, a two dimensional array of String returns &quot;&lt;code&gt;String&lt;/code&gt;&quot;.</source>
          <target state="translated">此类型的标准名称，不包括任何尺寸信息。例如，String的二维数组返回&amp;ldquo; &lt;code&gt;String&lt;/code&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="64ffcabf1d928e33cdd955774a39dbcd5dd5d5a5" translate="yes" xml:space="preserve">
          <source>The unqualified name of this type excluding any dimension or nesting information.</source>
          <target state="translated">此类型的非限定名称,不包括任何维度或嵌套信息。</target>
        </trans-unit>
        <trans-unit id="d7aa9ba3ba0215b9edea5f76f8e108e86c3953aa" translate="yes" xml:space="preserve">
          <source>The unqualified name of this type excluding any dimension or nesting information. For example, the class &lt;code&gt;Outer.Inner&lt;/code&gt; returns &quot;&lt;code&gt;Inner&lt;/code&gt;&quot;.</source>
          <target state="translated">此类型的标准名称，不包括任何尺寸或嵌套信息。例如，类 &lt;code&gt;Outer.Inner&lt;/code&gt; 返回&amp;ldquo; &lt;code&gt;Inner&lt;/code&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="b210e5f5ae502f06e3eee85bb0d3cddc4c712ed2" translate="yes" xml:space="preserve">
          <source>The updated class</source>
          <target state="translated">更新后的班级</target>
        </trans-unit>
        <trans-unit id="b40cc89ba60352f68fafcc4ac4c159121fb14767" translate="yes" xml:space="preserve">
          <source>The upper value in the range.</source>
          <target state="translated">范围内的上限值。</target>
        </trans-unit>
        <trans-unit id="e7fce3baf91efcfcd8801fb20b926ae96377e08f" translate="yes" xml:space="preserve">
          <source>The usage message for this example (obtained using &lt;code&gt;cli.usage()&lt;/code&gt;) is shown below:</source>
          <target state="translated">该示例的用法消息（使用 &lt;code&gt;cli.usage()&lt;/code&gt; 获得）如下所示：</target>
        </trans-unit>
        <trans-unit id="6b984acccdc007ab5614270b95defc6666e03e99" translate="yes" xml:space="preserve">
          <source>The valid targetBytecode values.</source>
          <target state="translated">有效的 targetBytecode 值。</target>
        </trans-unit>
        <trans-unit id="26e0cfaca318b8f4da7cebac77fcdbc02f5aa88f" translate="yes" xml:space="preserve">
          <source>The value at which the range originates (may be &lt;code&gt;null&lt;/code&gt;).</source>
          <target state="translated">范围起源的值（可以为 &lt;code&gt;null&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="0402397f26735b2ed2400f8ddcfcc924e0ce9a91" translate="yes" xml:space="preserve">
          <source>The value can be retrieved by calling the &lt;code&gt;get&lt;/code&gt; method with a key that is equal to the original key.</source>
          <target state="translated">可以通过使用等于原始键的键调用 &lt;code&gt;get&lt;/code&gt; 方法来检索该值。</target>
        </trans-unit>
        <trans-unit id="f18423b74c988542bc6f5c88a519429fcc1c89e9" translate="yes" xml:space="preserve">
          <source>The value of a QName contains a &lt;b&gt;namespaceURI&lt;/b&gt;, a &lt;b&gt;localPart&lt;/b&gt; and a &lt;b&gt;prefix&lt;/b&gt;. The localPart provides the local part of the qualified name. The namespaceURI is a URI reference identifying the namespace.</source>
          <target state="translated">QName的值包含一个&lt;b&gt;namespaceURI&lt;/b&gt;，一个&lt;b&gt;localPart&lt;/b&gt;和一个&lt;b&gt;前缀&lt;/b&gt;。localPart提供限定名称的本地部分。namespaceURI是标识名称空间的URI参考。</target>
        </trans-unit>
        <trans-unit id="d581e8a0b9a8abf2d88f586b7d5f11976e2b4718" translate="yes" xml:space="preserve">
          <source>The value of the executable attribute, if any.</source>
          <target state="translated">可执行属性的值,如果有的话;</target>
        </trans-unit>
        <trans-unit id="a9c238280b9b2287b4cd66fc20e8037b6edcacf3" translate="yes" xml:space="preserve">
          <source>The value returned by the script</source>
          <target state="translated">脚本返回的值</target>
        </trans-unit>
        <trans-unit id="87217bb3f735edd3580af114cd6ab58dbbe6f228" translate="yes" xml:space="preserve">
          <source>The value returned from the execution of the script (if supported by the Script engine)</source>
          <target state="translated">脚本执行后返回的值(如果脚本引擎支持的话)</target>
        </trans-unit>
        <trans-unit id="d702c028dc14f7beea06e57a018660f6784af85a" translate="yes" xml:space="preserve">
          <source>The value separator for this multi-valued option.</source>
          <target state="translated">这个多值期权的值分隔符。</target>
        </trans-unit>
        <trans-unit id="38f5980b9a59a25ffdbd05535eef7c76cba55950" translate="yes" xml:space="preserve">
          <source>The value separator for this multi-valued option. Only allowed for array-typed arguments.</source>
          <target state="translated">这个多值选项的值分隔符。只允许用于数组类型的参数。</target>
        </trans-unit>
        <trans-unit id="6847d558c266cc9ad7b554d665f6eb7a61327329" translate="yes" xml:space="preserve">
          <source>The value the option should have if it did not appear on the command line. The specified String value will be split into parts with the &lt;code&gt;valueSeparator&lt;/code&gt; and converted to the option &lt;code&gt;type&lt;/code&gt; before it is set.</source>
          <target state="translated">如果选项未出现在命令行中，则该选项应具有的值。指定的String值将与 &lt;code&gt;valueSeparator&lt;/code&gt; 拆分为多个部分，并在设置之前转换为选项 &lt;code&gt;type&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3481a95548ae3ca973619a2db287d20033ea8206" translate="yes" xml:space="preserve">
          <source>The values of each of the attributes on the MBean</source>
          <target state="translated">MBean上的每个属性的值</target>
        </trans-unit>
        <trans-unit id="53301301b27b5840479d76543713ebc0154d3193" translate="yes" xml:space="preserve">
          <source>The xmlns namespace definition for &lt;code&gt;gsp:&lt;/code&gt; tags will be removed but other namespace definitions will be preserved (but may change to an equivalent position within the XML tree).</source>
          <target state="translated">&lt;code&gt;gsp:&lt;/code&gt; 标记的xmlns名称空间定义将被删除，但其他名称空间定义将被保留（但可能会更改为XML树中的等效位置）。</target>
        </trans-unit>
        <trans-unit id="5ba86101ce4cb5b4110e9233defd7487d64710f7" translate="yes" xml:space="preserve">
          <source>Then calling the command line with:</source>
          <target state="translated">然后用命令行调用。</target>
        </trans-unit>
        <trans-unit id="21704ce2ef786ce4f4d39ef635a67321094be364" translate="yes" xml:space="preserve">
          <source>Then for the objects defined earlier, the following would be true:</source>
          <target state="translated">那么对于前面定义的对象,下面的内容将是真的。</target>
        </trans-unit>
        <trans-unit id="ef5935a3802e9c731a629c2d3dea2e39fefd2688" translate="yes" xml:space="preserve">
          <source>Then it can be used inside a template like this:</source>
          <target state="translated">那么就可以用在这样的模板里面。</target>
        </trans-unit>
        <trans-unit id="7717c315c219349dde87bf9f638b3cb7bca01e90" translate="yes" xml:space="preserve">
          <source>Then the output will be:</source>
          <target state="translated">那么输出将是。</target>
        </trans-unit>
        <trans-unit id="864c134c8c6b2e00f7e8bc3ed68b30a559cbae27" translate="yes" xml:space="preserve">
          <source>Then this description is supplied to CliBuilder during parsing, e.g.:</source>
          <target state="translated">然后在解析时将这个描述提供给CliBuilder,例如:。</target>
        </trans-unit>
        <trans-unit id="8374b2c2645caacda80d91902c858cf6eea4f9dd" translate="yes" xml:space="preserve">
          <source>Then you can create the structure using:</source>
          <target state="translated">然后你可以使用以下方法创建结构。</target>
        </trans-unit>
        <trans-unit id="947e20775c08c2347253e8e5fa3ea40f8f8dd552" translate="yes" xml:space="preserve">
          <source>There are numerous options to customize the format of the generated output. E.g. if you change the first annotation to:</source>
          <target state="translated">有许多选项可以自定义生成输出的格式。例如,如果您将第一个注释改为:。</target>
        </trans-unit>
        <trans-unit id="563196ba8420a662ed40e16f59935b76206ff249" translate="yes" xml:space="preserve">
          <source>There are several variables in the script binding:</source>
          <target state="translated">脚本绑定中有几个变量。</target>
        </trans-unit>
        <trans-unit id="b4572f137c1c0ff3c8ab5a5964aa37a98f650fc5" translate="yes" xml:space="preserve">
          <source>There are three types of ClassNodes:</source>
          <target state="translated">ClassNodes有三种类型。</target>
        </trans-unit>
        <trans-unit id="1bba0d9440062e4b938ad280aac889cc0eb5c94e" translate="yes" xml:space="preserve">
          <source>There is also a convenience form of ignore that matches the same style as demand. E.g. instead of &lt;code&gt;mock.ignore('hasNext')&lt;/code&gt; you can use &lt;code&gt;mock.ignore.hasNext()&lt;/code&gt;. A Closure variation is also provided. This convenience shorthand only applies to the &lt;code&gt;String&lt;/code&gt; form of ignore and cannot be used with methods from &lt;code&gt;java.lang.Object&lt;/code&gt;. Be careful using this feature while mocking some of the fundamental Java classes like &lt;code&gt;String&lt;/code&gt; or &lt;code&gt;Pattern&lt;/code&gt;. As these are used within the implementation of the ignore capability, strange behavior may be observed.</source>
          <target state="translated">还有一种方便的忽略形式，与需求样式相同。例如，您可以使用 &lt;code&gt;mock.ignore.hasNext()&lt;/code&gt; 来代替 &lt;code&gt;mock.ignore('hasNext')&lt;/code&gt; ）。还提供了Closure变体。此便捷速记仅适用于 &lt;code&gt;String&lt;/code&gt; 形式的ignore，不能与 &lt;code&gt;java.lang.Object&lt;/code&gt; 中的方法一起使用。在模拟一些基本的Java类（如 &lt;code&gt;String&lt;/code&gt; 或 &lt;code&gt;Pattern&lt;/code&gt; )时,请谨慎使用此功能。由于这些是在忽略功能的实现中使用的，因此可能会观察到奇怪的行为。</target>
        </trans-unit>
        <trans-unit id="16ebe4c456d8370715d9755e4586403958f169f6" translate="yes" xml:space="preserve">
          <source>There is also support for including or excluding fields/properties by name when constructing the equals and hashCode methods as shown here:</source>
          <target state="translated">在构造等价和hashCode方法时,还支持按名称包含或排除字段/属性,如这里所示。</target>
        </trans-unit>
        <trans-unit id="09e297702b5735499b1fd1768938b8ac48de65f4" translate="yes" xml:space="preserve">
          <source>There's no way in Java or Groovy to express the type signature of the expected closure call method from outside the closure itself, so we rely on an annotation here. Unfortunately, annotations also have limitations (like not being able to use generics placeholder as annotation values) that prevent us from expressing the type directly.</source>
          <target state="translated">在Java和Groovy中,没有办法从闭包本身之外表达预期闭包调用方法的类型签名,所以我们在这里依靠一个注解。不幸的是,注解也有局限性(比如不能使用generics占位符作为注解值),使我们无法直接表达类型。</target>
        </trans-unit>
        <trans-unit id="c18b23776942b361d4b98fa35e6f9472dbefb7b1" translate="yes" xml:space="preserve">
          <source>Therefore, f(x,y, a:p, b:q) {s} is equivalent in all ways to f(x,y, [a:p,b:q], {s}). Spread arguments of sequence type count as unlabeled arguments, while spread arguments of map type count as labeled arguments. (This distinction must sometimes be checked dynamically.) A plain unlabeled argument is allowed to match a trailing Map or Closure argument: f(x, a:p) {s} === f(*[ x, [a:p], {s} ])</source>
          <target state="translated">因此,f(x,y,a:p,b:q){s}在所有方面都等同于f(x,y,[a:p,b:q],{s})。序列类型的展期参数算作未标注的参数,而映射类型的展期参数算作标注的参数。(这种区别有时必须被动态检查。)一个普通的无标签参数被允许匹配一个尾部的Map或Closure参数:f(x,a:p){s}===f(*[x,[a:p],{s}])</target>
        </trans-unit>
        <trans-unit id="bdf6f329bdd2bfe03d147cee437e1f28acbe9bec" translate="yes" xml:space="preserve">
          <source>These rules are different from Java's &quot;dumb expression&quot; restriction. Unlike Java, Groovy blocks can end with arbitrary (even dumb) expressions, as a consequence of optional 'return' and 'continue' tokens.</source>
          <target state="translated">这些规则与Java的 &quot;哑巴表达式 &quot;限制不同。与Java不同的是,Groovy块可以用任意(甚至是哑巴)表达式结束,这是可选的 &quot;return &quot;和 &quot;continue &quot;标记的结果。</target>
        </trans-unit>
        <trans-unit id="1dd6b0156ded337bff046c6c15b9f9acafbe9d9f" translate="yes" xml:space="preserve">
          <source>Things that can show up as expressions, but only in strict contexts like inside parentheses, argument lists, and list constructors.</source>
          <target state="translated">可以以表达式形式出现的东西,但只能在严格的上下文中出现,比如括号内、参数列表和列表构造器。</target>
        </trans-unit>
        <trans-unit id="3f14934bd3a85bcc4e7a08b55ecfe6eb236ddcff" translate="yes" xml:space="preserve">
          <source>This (&lt;code&gt;&quot;1.4&quot;&lt;/code&gt;) is the value for targetBytecode to compile for a JDK 1.4.</source>
          <target state="translated">这个（ &lt;code&gt;&quot;1.4&quot;&lt;/code&gt; ）是targetBytecode可以为JDK 1.4编译的值。</target>
        </trans-unit>
        <trans-unit id="41689f1ac38712a28ee794030339205948d12a07" translate="yes" xml:space="preserve">
          <source>This (&lt;code&gt;&quot;1.5&quot;&lt;/code&gt;) is the value for targetBytecode to compile for a JDK 1.5.</source>
          <target state="translated">这个（ &lt;code&gt;&quot;1.5&quot;&lt;/code&gt; ）是targetBytecode可以为JDK 1.5编译的值。</target>
        </trans-unit>
        <trans-unit id="9f297bc1639a07cc1f354bdef8b770444ae17d9a" translate="yes" xml:space="preserve">
          <source>This (&lt;code&gt;&quot;1.6&quot;&lt;/code&gt;) is the value for targetBytecode to compile for a JDK 1.6.</source>
          <target state="translated">这个（ &lt;code&gt;&quot;1.6&quot;&lt;/code&gt; ）是targetBytecode可以为JDK 1.6编译的值。</target>
        </trans-unit>
        <trans-unit id="9fb8c7a4c95ce1386b3f28c134d8693268f0f7af" translate="yes" xml:space="preserve">
          <source>This (&lt;code&gt;&quot;1.7&quot;&lt;/code&gt;) is the value for targetBytecode to compile for a JDK 1.7.</source>
          <target state="translated">此（ &lt;code&gt;&quot;1.7&quot;&lt;/code&gt; ）是targetBytecode可以为JDK 1.7编译的值。</target>
        </trans-unit>
        <trans-unit id="1cb5fc7c5b688d3d7cf1465b6b36be120c55f7d5" translate="yes" xml:space="preserve">
          <source>This (&lt;code&gt;&quot;1.8&quot;&lt;/code&gt;) is the value for targetBytecode to compile for a JDK 1.8.</source>
          <target state="translated">这个（ &lt;code&gt;&quot;1.8&quot;&lt;/code&gt; ）是targetBytecode可以为JDK 1.8编译的值。</target>
        </trans-unit>
        <trans-unit id="4db730fb6bbc9127357c8981de76c8767a22995c" translate="yes" xml:space="preserve">
          <source>This (&lt;code&gt;&quot;10&quot;&lt;/code&gt;) is the value for targetBytecode to compile for a JDK 10.</source>
          <target state="translated">这个（ &lt;code&gt;&quot;10&quot;&lt;/code&gt; ）是targetBytecode可以为JDK 10编译的值。</target>
        </trans-unit>
        <trans-unit id="7253e572c58af323680948d9124eb666a503dc70" translate="yes" xml:space="preserve">
          <source>This (&lt;code&gt;&quot;11&quot;&lt;/code&gt;) is the value for targetBytecode to compile for a JDK 11.</source>
          <target state="translated">这个（ &lt;code&gt;&quot;11&quot;&lt;/code&gt; ）是targetBytecode可以为JDK 11编译的值。</target>
        </trans-unit>
        <trans-unit id="f1a0d2ab0453c0d76f9aec2ffa7dab4ddcaac8ea" translate="yes" xml:space="preserve">
          <source>This (&lt;code&gt;&quot;12&quot;&lt;/code&gt;) is the value for targetBytecode to compile for a JDK 12.</source>
          <target state="translated">这个（ &lt;code&gt;&quot;12&quot;&lt;/code&gt; ）是targetBytecode可以为JDK 12编译的值。</target>
        </trans-unit>
        <trans-unit id="92239128e3fca4fd124d3c3ff8f83f20507689db" translate="yes" xml:space="preserve">
          <source>This (&lt;code&gt;&quot;13&quot;&lt;/code&gt;) is the value for targetBytecode to compile for a JDK 13.</source>
          <target state="translated">此（ &lt;code&gt;&quot;13&quot;&lt;/code&gt; ）是targetBytecode可以为JDK 13编译的值。</target>
        </trans-unit>
        <trans-unit id="c9227107e2eef78c2490b7685cfcbd9e12fac74d" translate="yes" xml:space="preserve">
          <source>This (&lt;code&gt;&quot;14&quot;&lt;/code&gt;) is the value for targetBytecode to compile for a JDK 14.</source>
          <target state="translated">这个（ &lt;code&gt;&quot;14&quot;&lt;/code&gt; ）是targetBytecode可以为JDK 14编译的值。</target>
        </trans-unit>
        <trans-unit id="a8c680713844e7c900b549a36c6de7e34f563c98" translate="yes" xml:space="preserve">
          <source>This (&lt;code&gt;&quot;15&quot;&lt;/code&gt;) is the value for targetBytecode to compile for a JDK 15.</source>
          <target state="translated">这个（ &lt;code&gt;&quot;15&quot;&lt;/code&gt; ）是targetBytecode可以为JDK 15编译的值。</target>
        </trans-unit>
        <trans-unit id="f1c463b78b8f124ac2eec3fd756cac7f533dfce9" translate="yes" xml:space="preserve">
          <source>This (&lt;code&gt;&quot;16&quot;&lt;/code&gt;) is the value for targetBytecode to compile for a JDK 16.</source>
          <target state="translated">这个（ &lt;code&gt;&quot;16&quot;&lt;/code&gt; ）是targetBytecode可以为JDK 16编译的值。</target>
        </trans-unit>
        <trans-unit id="7b242e1445386ea26fd4353cac30d1a7873acc0d" translate="yes" xml:space="preserve">
          <source>This (&lt;code&gt;&quot;9&quot;&lt;/code&gt;) is the value for targetBytecode to compile for a JDK 9.</source>
          <target state="translated">这个（ &lt;code&gt;&quot;9&quot;&lt;/code&gt; ）是targetBytecode可以为JDK 9编译的值。</target>
        </trans-unit>
        <trans-unit id="beee2f48ce8c2bdd9d82e37070e460c27f51fba0" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;../classnode&quot;&gt;ClassNode&lt;/a&gt; specialization is used when the lowest upper bound of two types cannot be represented by an existing type.</source>
          <target state="translated">当无法用现有类型表示两种类型的最低上限时，将使用此&lt;a href=&quot;../classnode&quot;&gt;ClassNode&lt;/a&gt;专业化。</target>
        </trans-unit>
        <trans-unit id="f55f8d16febb565101695bf40d07384fdcedba3d" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;../classnode&quot;&gt;ClassNode&lt;/a&gt; specialization is used when the lowest upper bound of two types cannot be represented by an existing type. For example, if B extends A, C extends A and both C and B implement a common interface not implemented by A, then we use this class to represent the bound. At compile time, some classes like &lt;a href=&quot;../../classgen/asmclassgenerator&quot;&gt;AsmClassGenerator&lt;/a&gt; need to know about a real class node, so we compute a &quot;compile time&quot; node which will be used to return a name and a type class.</source>
          <target state="translated">当无法用现有类型表示两种类型的最低上限时，将使用此&lt;a href=&quot;../classnode&quot;&gt;ClassNode&lt;/a&gt;专业化。例如，如果B扩展了A，C扩展了A，并且C和B都实现了A没有实现的公共接口，则我们使用此类来表示边界。在编译时，某些类（例如&lt;a href=&quot;../../classgen/asmclassgenerator&quot;&gt;AsmClassGenerator）&lt;/a&gt;需要了解真实的类节点，因此我们计算了一个&amp;ldquo;编译时&amp;rdquo;节点，该节点将用于返回名称和类型类。</target>
        </trans-unit>
        <trans-unit id="bd4628d474bbecaf52d4fae2554f6f6dafd33e5e" translate="yes" xml:space="preserve">
          <source>This AST transform creates (potentially) numerous constructors. You should take care to avoid constructors with duplicate signatures if you are defining your own constructors or combining with other AST transforms which create constructors (e.g. &lt;code&gt;@TupleConstructor&lt;/code&gt;); the order in which the particular transforms are processed becomes important in that case.</source>
          <target state="translated">此AST转换会（可能）创建许多构造函数。如果要定义自己的构造函数或与其他创建构造函数的AST转换（例如 &lt;code&gt;@TupleConstructor&lt;/code&gt; ）结合使用，则应避免使用具有重复签名的构造函数。在这种情况下，处理特定变换的顺序就变得很重要。</target>
        </trans-unit>
        <trans-unit id="e36f809432dd63402bc50997d22ab6edaf317f70" translate="yes" xml:space="preserve">
          <source>This AST transform might become a no-op if you are defining your own constructors or combining with other AST transforms which create constructors (e.g. &lt;code&gt;@InheritConstructors&lt;/code&gt;); the order in which the particular transforms are processed becomes important in that case. See the &lt;code&gt;force&lt;/code&gt; attribute for further details about customizing this behavior.</source>
          <target state="translated">如果您要定义自己的构造函数或与其他创建构造函数的AST变换（例如 &lt;code&gt;@InheritConstructors&lt;/code&gt; ）结合使用，则此AST转换可能会变成空操作。在这种情况下，处理特定变换的顺序就变得很重要。有关自定义此行为的更多详细信息，请参见 &lt;code&gt;force&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="15f2811221f75ab7d18ebc91f442dd8504abe34a" translate="yes" xml:space="preserve">
          <source>This AST transform normally uses default parameter values which creates multiple constructors under the covers. You should use with care if you are defining your own constructors or combining with other AST transforms which create constructors (e.g. &lt;code&gt;@InheritConstructors&lt;/code&gt;); the order in which the particular transforms are processed becomes important in that case. See the &lt;code&gt;defaults&lt;/code&gt; attribute for further details about customizing this behavior.</source>
          <target state="translated">此AST转换通常使用默认参数值，该参数值在后台创建多个构造函数。如果要定义自己的构造函数或与其他创建构造函数的AST转换（例如 &lt;code&gt;@InheritConstructors&lt;/code&gt; ）结合使用，则应格外小心。在这种情况下，处理特定转换的顺序变得很重要。有关自定义此行为的更多详细信息，请参见 &lt;code&gt;defaults&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="81e45867f90c0607353adaf6e73abff7c9d75404" translate="yes" xml:space="preserve">
          <source>This AST transformation aims at helping in debugging other AST transformations. It provides a basic infrastructure for performing tests on AST nodes. You can place this annotation on any node which accepts an annotation (types, methods, annotations, constructors, fields, local variables, packages or parameters), then use a script which is run against this AST node at a specific phase. For example, you could test the &lt;a href=&quot;field&quot;&gt;Field&lt;/a&gt; AST transformation this way:</source>
          <target state="translated">此AST转换旨在帮助调试其他AST转换。它提供了用于在AST节点上执行测试的基本基础结构。您可以将此注释放置在任何接受注释的节点上（类型，方法，注释，构造函数，字段，局部变量，包或参数），然后使用在特定阶段针对此AST节点运行的脚本。例如，您可以通过以下方式测试&lt;a href=&quot;field&quot;&gt;Field&lt;/a&gt; AST转换：</target>
        </trans-unit>
        <trans-unit id="29dcdadce343c996ed956f4651064a49228e35e3" translate="yes" xml:space="preserve">
          <source>This ClassLoader should be used as root of class loaders. Any RootLoader does have its own classpath. When searching for a class or resource this classpath will be used. Parent Classloaders are ignored first. If a class or resource can't be found in the classpath of the RootLoader, then parent is checked.</source>
          <target state="translated">这个ClassLoader应该被用作类加载器的根。任何RootLoader都有自己的classpath。当搜索一个类或资源时,将使用这个classpath。父类加载器将首先被忽略。如果在RootLoader的classpath中找不到一个类或资源,那么就会检查父类。</target>
        </trans-unit>
        <trans-unit id="bf55f18fc8d0076e97f9f960b82f80de35bb3681" translate="yes" xml:space="preserve">
          <source>This MetaBeanProperty will create a pseudo property whose value is bound to an object using weak references. The values will go out of scope and be garbage collected when the object is collected In fact, this class should be called ExpandoProperty.</source>
          <target state="translated">这个MetaBeanProperty将创建一个伪属性,其值使用弱引用绑定到一个对象上。这些值将超出范围,并在对象被收集时被垃圾回收事实上,这个类应该叫做ExpandoProperty。</target>
        </trans-unit>
        <trans-unit id="704cf8159f321950d7439d8157804780ec00808e" translate="yes" xml:space="preserve">
          <source>This MetaClass is for internal usage only!</source>
          <target state="translated">此Meta类仅供内部使用</target>
        </trans-unit>
        <trans-unit id="550e8ef2b445d11145333f7d61692b3a9a8521d7" translate="yes" xml:space="preserve">
          <source>This TestHarness exists so that a global transform can be run without using the Jar services mechanism, which requires building a jar. To use this simply create an instance of TransformTestHelper with an ASTTransformation and CompilePhase, then invoke parse(File) or parse(String). This test harness is not exactly the same as executing a global transformation but can greatly aide in debugging and testing a transform. You should still test your global transformation when packaged as a jar service before releasing it.</source>
          <target state="translated">这个TestHarness的存在是为了使全局变换可以在不使用Jar服务机制的情况下运行,而Jar服务机制需要构建一个jar。要使用它,只需创建一个带有ASTTransformation和CompilePhase的TransformTestHelper实例,然后调用parse(File)或parse(String)。这个测试线束与执行全局变换并不完全相同,但可以极大地帮助调试和测试一个变换。在发布全局变换之前,您仍然应该测试您的全局变换,当它被打包成一个jar服务时。</target>
        </trans-unit>
        <trans-unit id="c82a01d51cf967248d2d13c51ea281168a11d159" translate="yes" xml:space="preserve">
          <source>This Writer is used to generate the call invocation byte codes for usage by invokedynamic.</source>
          <target state="translated">这个写入器用于生成调用调用的字节码,供 invokedynamic 使用。</target>
        </trans-unit>
        <trans-unit id="3d417d2cc7f087e2cdc7df384d7a9c24827840c1" translate="yes" xml:space="preserve">
          <source>This allows callbacks to the ExpandoMetaClass for registering appending methods</source>
          <target state="translated">这允许回调到ExpandoMetaClass来注册追加方法。</target>
        </trans-unit>
        <trans-unit id="d5ec4e7b6ccc818185756b4b5a332b9d3ffec2cf" translate="yes" xml:space="preserve">
          <source>This allows equals to be overridden by a closure</source>
          <target state="translated">这允许等价物被闭合覆盖</target>
        </trans-unit>
        <trans-unit id="1a87473814b341719aa50b456949655ef70f8692" translate="yes" xml:space="preserve">
          <source>This allows hashCode to be overridden by a closure</source>
          <target state="translated">这使得hashCode可以被一个闭包所覆盖</target>
        </trans-unit>
        <trans-unit id="9be7fcf1022ddc09fab428bf809d227229df0478" translate="yes" xml:space="preserve">
          <source>This allows toString to be overridden by a closure</source>
          <target state="translated">这允许toString被一个闭包覆盖。</target>
        </trans-unit>
        <trans-unit id="904b268e24ef2338f73c60ee6653805eb03db45f" translate="yes" xml:space="preserve">
          <source>This annotation adds Java-style listener support to a class based on an annotated Collection-property.</source>
          <target state="translated">这个注解为基于注解集合属性的类添加了Java风格的监听器支持。</target>
        </trans-unit>
        <trans-unit id="456bbcadaaaab286f459087a19ee8bf423978b1b" translate="yes" xml:space="preserve">
          <source>This annotation can also be used to help the type checker (&lt;a href=&quot;../transform/typechecked&quot;&gt;TypeChecked&lt;/a&gt;) which would not report errors then if the delegate is of the documented type. Of course, it is also compatible with &lt;a href=&quot;../transform/compilestatic&quot;&gt;CompileStatic&lt;/a&gt;.</source>
          <target state="translated">此注释还可以用于帮助类型检查器（&lt;a href=&quot;../transform/typechecked&quot;&gt;TypeChecked&lt;/a&gt;），如果委托是文档化的类型，则该类型检查器将不会报告错误。当然，它也与&lt;a href=&quot;../transform/compilestatic&quot;&gt;CompileStatic&lt;/a&gt;兼容。</target>
        </trans-unit>
        <trans-unit id="f85deef9d102451f990e95bce3bc073d25fbab0b" translate="yes" xml:space="preserve">
          <source>This annotation can be added on a trait to declare the list of types that a class implementing that trait is supposed to extend. This is useful when you want to be able to call methods from the class implementing the trait without having to declare all of them as members of the trait. Self types are particularly useful in combination with &lt;a href=&quot;compilestatic&quot;&gt;CompileStatic&lt;/a&gt;, if you know that a trait can only be applied to a specific type but that the trait cannot extend that type itself. For example, imagine the following code:</source>
          <target state="translated">可以在特性上添加此注释，以声明实现该特性的类应扩展的类型列表。当您希望能够从实现特征的类中调用方法而不必将所有方法都声明为特征成员时，此方法很有用。如果您知道特征只能应用于特定类型，但是特征不能扩展该类型本身，则将自身类型与&lt;a href=&quot;compilestatic&quot;&gt;CompileStatic&lt;/a&gt;结合使用特别有用。例如，想象下面的代码：</target>
        </trans-unit>
        <trans-unit id="90bf79a957044e0c4bcbe98180025021e13ba83a" translate="yes" xml:space="preserve">
          <source>This annotation can be used by API or DSL writers to document parameters which accept a closure. In that case, using this annotation, you can specify what the delegate type of the closure will be. This is important for IDE support.</source>
          <target state="translated">API 或 DSL 编写者可以使用这个注解来记录接受闭包的参数。在这种情况下,使用这个注解,您可以指定闭包的委托类型。这对于 IDE 支持来说是很重要的。</target>
        </trans-unit>
        <trans-unit id="ecea2ce9782577916440255f7ef418cba5693cc7" translate="yes" xml:space="preserve">
          <source>This annotation can only be applied to a field of type Collection</source>
          <target state="translated">这个注解只能应用于类型为集合的字段。</target>
        </trans-unit>
        <trans-unit id="23faf967c5242f98ba0f1bfb8360a62caf1714ca" translate="yes" xml:space="preserve">
          <source>This annotation is a declarative wrapper around the JDK's &lt;code&gt;java.util.concurrent.locks.ReentrantReadWriteLock&lt;/code&gt;. Objects containing this annotation will have a ReentrantReadWriteLock field named &lt;code&gt;$reentrantLock&lt;/code&gt; added to the class, and method access is protected by the lock. If the method is static then the field is static and named &lt;code&gt;$REENTRANTLOCK&lt;/code&gt;.</source>
          <target state="translated">此批注是JDK的 &lt;code&gt;java.util.concurrent.locks.ReentrantReadWriteLock&lt;/code&gt; 的声明性包装。包含此批注的对象将向类添加名为 &lt;code&gt;$reentrantLock&lt;/code&gt; 的ReentrantReadWriteLock字段，并且方法访问受锁保护。如果该方法是静态的，则该字段为静态，并命名为 &lt;code&gt;$REENTRANTLOCK&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9ee69ca6c59b77f4f301dba9f69b7ae03123c8fb" translate="yes" xml:space="preserve">
          <source>This annotation is added by</source>
          <target state="translated">该注解由以下人员添加</target>
        </trans-unit>
        <trans-unit id="284afc2f65c87063203dea977155cf54b2e047bd" translate="yes" xml:space="preserve">
          <source>This annotation is used in conjunction with &lt;a href=&quot;withreadlock&quot;&gt;WithReadLock&lt;/a&gt; to support read and write synchronization on a method.</source>
          <target state="translated">该注释与&lt;a href=&quot;withreadlock&quot;&gt;WithReadLock&lt;/a&gt;一起使用，以支持对方法的读写同步。</target>
        </trans-unit>
        <trans-unit id="17c946a06e7f552c5a667fd66607967ecf31f9f4" translate="yes" xml:space="preserve">
          <source>This annotation is used in conjunction with &lt;a href=&quot;withwritelock&quot;&gt;WithWriteLock&lt;/a&gt; to support read and write synchronization on a method.</source>
          <target state="translated">该批注与&lt;a href=&quot;withwritelock&quot;&gt;WithWriteLock&lt;/a&gt;一起使用，以支持对方法的读写同步。</target>
        </trans-unit>
        <trans-unit id="887147df53ade494df6c8d9012ec7612dd2f4226" translate="yes" xml:space="preserve">
          <source>This applies to the grab and resolve calls.</source>
          <target state="translated">这适用于抓取和解析调用。</target>
        </trans-unit>
        <trans-unit id="a921b8a7c1a5d233057197c112f7c4cb8b092bff" translate="yes" xml:space="preserve">
          <source>This behavior can be disabled by setting the annotation's &lt;code&gt;interfaces&lt;/code&gt; element to false, i.e. &lt;code&gt;@Delegate(interfaces = false)&lt;/code&gt;, e.g. in the above example, the delegate definition would become:</source>
          <target state="translated">可以通过将注释的 &lt;code&gt;interfaces&lt;/code&gt; 元素设置为false来禁用此行为，即 &lt;code&gt;@Delegate(interfaces = false)&lt;/code&gt; ，例如，在上面的示例中，委托定义将变为：</target>
        </trans-unit>
        <trans-unit id="788d0e9e6025f3d507fbe4b1a671cab778fcc046" translate="yes" xml:space="preserve">
          <source>This builder supports the usual builder syntax made of nested method calls and closures, but also some specific aspects of JSON data structures, such as list of values, etc. Please make sure to have a look at the various methods provided by this builder to be able to learn about the various possibilities of usage.</source>
          <target state="translated">本构建器支持由嵌套方法调用和闭包构成的通常的构建器语法,也支持JSON数据结构的一些特殊方面,如值列表等。请一定要看看这个构建器提供的各种方法,能够了解各种使用的可能性。</target>
        </trans-unit>
        <trans-unit id="f8635421fede240629f5bedb5b4f58cb9f602fa9" translate="yes" xml:space="preserve">
          <source>This cache contains mappings of file name to class.</source>
          <target state="translated">这个缓存包含文件名与类的映射。</target>
        </trans-unit>
        <trans-unit id="370ea64c9230c916cbe3b4f3656932f0e6a2c4bc" translate="yes" xml:space="preserve">
          <source>This cache contains mappings of file name to class. It is used to bypass compilation.</source>
          <target state="translated">这个缓存包含了文件名到类的映射。它用于绕过编译。</target>
        </trans-unit>
        <trans-unit id="88d556d068acd75020d51487e54372a78b6ff46d" translate="yes" xml:space="preserve">
          <source>This class also supports optional guaranteed exclusive reads, simply by surrounding a call within a synchronized block, as in</source>
          <target state="translated">该类还支持可选的保证独占性读取,只需在同步块中包围一个调用即可,如在</target>
        </trans-unit>
        <trans-unit id="8508f2b4673f6cfee9a6f3c2b3e95fec3b67deb5" translate="yes" xml:space="preserve">
          <source>This class and its views and iterators implement all of the &lt;em&gt;optional&lt;/em&gt; methods of the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Map.html&quot;&gt;Map&lt;/a&gt; and &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html&quot;&gt;Iterator&lt;/a&gt; interfaces.</source>
          <target state="translated">此类及其视图和迭代器实现&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Map.html&quot;&gt;Map&lt;/a&gt;和&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html&quot;&gt;Iterator&lt;/a&gt;接口的所有&lt;em&gt;可选&lt;/em&gt;方法。</target>
        </trans-unit>
        <trans-unit id="f7efe531dee1a194a6b26a56274948d2b3619130" translate="yes" xml:space="preserve">
          <source>This class checks the handling of labels in the AST</source>
          <target state="translated">这个类检查AST中标签的处理。</target>
        </trans-unit>
        <trans-unit id="c32390b3fa0798fcae7e17bde6e60d95b95add0f" translate="yes" xml:space="preserve">
          <source>This class codes around a silly limitation of StringWriter which doesn't allow a StringBuffer to be passed in as a constructor for some bizarre reason. So we replicate the behaviour of StringWriter here but allow a StringBuffer to be passed in.</source>
          <target state="translated">这个类的代码绕过了StringWriter的一个愚蠢的限制,由于一些奇怪的原因,它不允许StringBuffer作为构造函数被传递进来。所以我们在这里复制了StringWriter的行为,但允许StringBuffer被传递进来。</target>
        </trans-unit>
        <trans-unit id="ebc053f62ed97562a5d93d1422bb69af81f8e57b" translate="yes" xml:space="preserve">
          <source>This class contains a static utility method &lt;a href=&quot;#doExtendTraits(org.codehaus.groovy.ast.ClassNode,%20org.codehaus.groovy.control.SourceUnit,%20org.codehaus.groovy.control.CompilationUnit)&quot;&gt;doExtendTraits(org.codehaus.groovy.ast.ClassNode, org.codehaus.groovy.control.SourceUnit, org.codehaus.groovy.control.CompilationUnit)&lt;/a&gt; aimed at generating code for a classnode implementing a trait.</source>
          <target state="translated">此类包含静态实用程序方法&lt;a href=&quot;#doExtendTraits(org.codehaus.groovy.ast.ClassNode,%20org.codehaus.groovy.control.SourceUnit,%20org.codehaus.groovy.control.CompilationUnit)&quot;&gt;doExtendTraits（org.codehaus.groovy.ast.ClassNode，org.codehaus.groovy.control.SourceUnit，org.codehaus.groovy.control.CompilationUnit），&lt;/a&gt;旨在为实现特征的类节点生成代码。</target>
        </trans-unit>
        <trans-unit id="d1390a9bb5928eb78b502051fa6490144b85fc73" translate="yes" xml:space="preserve">
          <source>This class contains guards, runtime filters and MethodType signatures used by indy.</source>
          <target state="translated">这个类包含了indy使用的guards、运行时过滤器和MethodType签名。</target>
        </trans-unit>
        <trans-unit id="69d74fd6b193fe5e0c2269389a27f951ab4b1918" translate="yes" xml:space="preserve">
          <source>This class contains helper methods for converting and comparing types. WARNING: This class is for internal use only. do not use it outside of its package and not outside groovy-core.</source>
          <target state="translated">这个类包含了转换和比较类型的辅助方法。警告:这个类只供内部使用,不要在它的包之外使用,也不要在groovy-core之外使用。</target>
        </trans-unit>
        <trans-unit id="0e2eed5867aee96ae1999d8644dc789cf19d0975" translate="yes" xml:space="preserve">
          <source>This class contains math operations used by indy instead of the normal meta method and call site caching system. The goal is to avoid boxing, thus use primitive types for parameters and return types where possible. WARNING: This class is for internal use only. Do not use it outside of the org.codehaus.groovy.vmplugin.v7 package of groovy-core.</source>
          <target state="translated">这个类包含了indy使用的数学运算,而不是普通的元方法和调用站点缓存系统。目标是避免框定,因此尽可能使用基元类型作为参数和返回类型。警告:这个类只供内部使用。不要在groovy-core的org.codehaus.groovy.vmplugin.v7包之外使用它。</target>
        </trans-unit>
        <trans-unit id="48c7a1f038c0d6b2a23d2ab51b95c86eac51cf7a" translate="yes" xml:space="preserve">
          <source>This class contains methods special to optimizations used directly from bytecode in Groovy 1.8</source>
          <target state="translated">这个类包含了在Groovy 1.8中直接使用字节码进行优化的特殊方法。</target>
        </trans-unit>
        <trans-unit id="316c4500322f8ef05e5c4de531c7dc7bc6e842c4" translate="yes" xml:space="preserve">
          <source>This class contains several transformers for used during method invocation.</source>
          <target state="translated">这个类包含了几个变压器,用于方法调用时使用。</target>
        </trans-unit>
        <trans-unit id="1768003da8eeae27f66ecf9e1f2dbf815c0a1e83" translate="yes" xml:space="preserve">
          <source>This class contains utility methods to determine which class called the current class to multiple levels of depth. Calls used to handle the groovy MOP are excluded from the level counting.</source>
          <target state="translated">该类包含实用方法,用于确定哪个类调用当前类的多级深度。用于处理groovy MOP的调用不包括在级别计算中。</target>
        </trans-unit>
        <trans-unit id="221b99a286abc745efa1b934a4f00c7b6aa4732f" translate="yes" xml:space="preserve">
          <source>This class controls the conversion from a Groovy script as a String into a tree representation of the AST of that script. The script itself will be a tree node, and each class in the script will be a tree node. The conversion creates tree nodes for any concrete class found within an AST visitor. So, if a tree node should be shown once for each ASTNode and the parent types will not appear as nodes. Custom subclasses of expression types will not appear in the tree. The String label of a tree node is defined by classname in AstBrowserProperties.properties.</source>
          <target state="translated">该类控制将一个Groovy脚本作为一个字符串转换为该脚本AST的树状表示。脚本本身将是一个树节点,脚本中的每个类也将是一个树节点。转换会为AST访问者中发现的任何具体类创建树节点。因此,如果树节点应该为每个ASTNode显示一次,而父类将不会作为节点出现。表达式类型的自定义子类将不会出现在树中。树节点的字符串标签是由AstBrowserProperties.properties中的classname定义的。</target>
        </trans-unit>
        <trans-unit id="d454a30f57963a7de123921ca0b60e62b5e13e35" translate="yes" xml:space="preserve">
          <source>This class defines a single static method taking the string instance as first argument, allowing to define a new instance method on the String class:</source>
          <target state="translated">该类定义了一个单一的静态方法,将字符串实例作为第一个参数,允许在String类上定义一个新的实例方法。</target>
        </trans-unit>
        <trans-unit id="3e8b6ae7361745c2ea205471fce2c8b2f23b8fe8" translate="yes" xml:space="preserve">
          <source>This class defines a wrapper for accessing a specific column in &lt;code&gt;ResultSetMetaData&lt;/code&gt;. This allows iteration over columns using idiomatic Groovy, e.g.:</source>
          <target state="translated">此类定义用于访问 &lt;code&gt;ResultSetMetaData&lt;/code&gt; 中特定列的包装器。这允许使用惯用的Groovy在列上进行迭代，例如：</target>
        </trans-unit>
        <trans-unit id="3f3f0165db0a67f63374a90150dc420fe8fa8906" translate="yes" xml:space="preserve">
          <source>This class defines all the encoding/decoding groovy methods which enhance the normal JDK classes when inside the Groovy environment. Static methods are used with the first parameter the destination class.</source>
          <target state="translated">这个类定义了所有的编码/解码groovy方法,这些方法在Groovy环境中增强了普通JDK类的功能。静态方法的第一个参数是目标类。</target>
        </trans-unit>
        <trans-unit id="ddd6dbb32c165e8ccdc7c778b5ff92b6e5a6e046" translate="yes" xml:space="preserve">
          <source>This class defines all the new SQL-related groovy methods which enhance the normal JDK SQL classes when inside the Groovy environment. Static methods are used with the first parameter the destination class.</source>
          <target state="translated">该类定义了所有新的与SQL相关的groovy方法,这些方法在Groovy环境中增强了普通JDK SQL类的功能。静态方法的第一个参数是目标类。</target>
        </trans-unit>
        <trans-unit id="0e4cf1f1d1626756e2ccfaa4e27ca5b4fe7667ce" translate="yes" xml:space="preserve">
          <source>This class defines all the new Swing-related groovy methods which enhance the normal JDK Swing classes when inside the Groovy environment. Static methods are used with the first parameter the destination class.</source>
          <target state="translated">该类定义了所有新的与Swing相关的groovy方法,这些方法在Groovy环境中增强了普通JDK Swing类的功能。静态方法的第一个参数是目标类。</target>
        </trans-unit>
        <trans-unit id="6bc8d743038c2ddaea690f3c08b6f791f09b985b" translate="yes" xml:space="preserve">
          <source>This class defines all the new XML-related groovy methods which enhance the normal JDK XML classes when inside the Groovy environment. Static methods are used with the first parameter the destination class.</source>
          <target state="translated">该类定义了所有新的与XML相关的groovy方法,这些方法在Groovy环境中增强了普通JDK XML类的功能。静态方法的第一个参数是目标类。</target>
        </trans-unit>
        <trans-unit id="98e53123fb5c78332de5d2876769f4a204051159" translate="yes" xml:space="preserve">
          <source>This class defines all the new static groovy methods which appear on normal JDK classes inside the Groovy environment. Static methods are used with the first parameter as the destination class.</source>
          <target state="translated">这个类定义了所有新的静态groovy方法,这些方法出现在Groovy环境中的普通JDK类上。静态方法的第一个参数是目标类。</target>
        </trans-unit>
        <trans-unit id="faf10e978d074ae7e5e07e788c9748ff6b749eed" translate="yes" xml:space="preserve">
          <source>This class defines new Groovy methods which appear on normal JDK Date/Time API (java.time) classes inside the Groovy environment. These extensions require JDK 8 or above.</source>
          <target state="translated">该类定义了新的Groovy方法,这些方法出现在Groovy环境中的普通JDK Date/Time API (java.time)类中。这些扩展需要JDK 8或以上版本。</target>
        </trans-unit>
        <trans-unit id="5e8a356a24d0f45345f38f9c5e624401ea122feb" translate="yes" xml:space="preserve">
          <source>This class defines new Java 5 specific groovy methods which extend the normal JDK classes inside the Groovy environment. Static methods are used with the first parameter the destination class.</source>
          <target state="translated">该类定义了新的Java 5特定的groovy方法,这些方法扩展了Groovy环境中的普通JDK类。静态方法的第一个参数是目标类。</target>
        </trans-unit>
        <trans-unit id="3335bc6567d5a0923632b42415b2259b7d1a9ca9" translate="yes" xml:space="preserve">
          <source>This class defines new Java 6 specific groovy methods which extend the normal JDK classes inside the Groovy environment. Static methods are used with the first parameter the destination class.</source>
          <target state="translated">该类定义了新的Java 6特定的groovy方法,这些方法扩展了Groovy环境中的普通JDK类。静态方法的第一个参数是目标类。</target>
        </trans-unit>
        <trans-unit id="fbc656debe43046569a9d23c80bd193a41215a53" translate="yes" xml:space="preserve">
          <source>This class defines new Java 6 specific static groovy methods which extend the normal JDK classes inside the Groovy environment.</source>
          <target state="translated">该类定义了新的Java 6特有的静态groovy方法,这些方法扩展了Groovy环境中的普通JDK类。</target>
        </trans-unit>
        <trans-unit id="48c87f705bf49123468d54ad93a33becf3eeea6d" translate="yes" xml:space="preserve">
          <source>This class defines new groovy methods for Files, URLs, URIs which appear on normal JDK classes inside the Groovy environment. Static methods are used with the first parameter being the destination class, i.e. &lt;code&gt;public static long size(File self)&lt;/code&gt; provides a &lt;code&gt;size()&lt;/code&gt; method for &lt;code&gt;File&lt;/code&gt;.</source>
          <target state="translated">此类为文件，URL和URI定义了新的Groovy方法，这些方法出现在Groovy环境中的普通JDK类上。静态方法与第一参数是所述目标类使用，即 &lt;code&gt;public static long size(File self)&lt;/code&gt; 提供了一个 &lt;code&gt;size()&lt;/code&gt; 用于方法 &lt;code&gt;File&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aea9ee44a185e75c57ac3db064101c0dc7b71846" translate="yes" xml:space="preserve">
          <source>This class defines new groovy methods for Readers, Writers, InputStreams and OutputStreams which appear on normal JDK classes inside the Groovy environment. Static methods are used with the first parameter being the destination class, i.e. &lt;code&gt;public static T eachLine(InputStream self, Closure c)&lt;/code&gt; provides a &lt;code&gt;eachLine(Closure c)&lt;/code&gt; method for &lt;code&gt;InputStream&lt;/code&gt;.</source>
          <target state="translated">此类为Reader，Writer，InputStreams和OutputStreams定义了新的Groovy方法，这些方法出现在Groovy环境中的常规JDK类上。静态方法与第一参数是所述目标类使用，即 &lt;code&gt;public static T eachLine(InputStream self, Closure c)&lt;/code&gt; 提供了一个 &lt;code&gt;eachLine(Closure c)&lt;/code&gt; 对方法 &lt;code&gt;InputStream&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eb04b5af77efd219c4b5a9414f1ff8646ff26a61" translate="yes" xml:space="preserve">
          <source>This class defines new groovy methods for Sockets which enhance JDK classes inside the Groovy environment.</source>
          <target state="translated">该类为Socket定义了新的groovy方法,这些方法增强了Groovy环境中的JDK类。</target>
        </trans-unit>
        <trans-unit id="94e1494a582102e49d29876303786a0362da0d77" translate="yes" xml:space="preserve">
          <source>This class defines new groovy methods which appear on Jaxb-related JDK classes (&lt;code&gt;JAXBContext&lt;/code&gt;, &lt;code&gt;Marshaller&lt;/code&gt;) inside the Groovy environment. Static methods are used with the first parameter being the destination class.</source>
          <target state="translated">此类定义了新的Groovy方法，这些方法出现在Groovy环境内与Jaxb相关的JDK类（ &lt;code&gt;JAXBContext&lt;/code&gt; ， &lt;code&gt;Marshaller&lt;/code&gt; ）上。静态方法与第一个参数一起用作目标类。</target>
        </trans-unit>
        <trans-unit id="afb7507827959ad4b29159fe5d7fffc42f2f585e" translate="yes" xml:space="preserve">
          <source>This class defines new groovy methods which appear on String-related JDK classes (String, CharSequence, Matcher) inside the Groovy environment. Static methods are used with the first parameter being the destination class, e.g. &lt;code&gt;public static String reverse(String self)&lt;/code&gt; provides a &lt;code&gt;reverse()&lt;/code&gt; method for &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">此类定义了新的Groovy方法，这些方法出现在Groovy环境中与String相关的JDK类（String，CharSequence，Matcher）上。静态方法与第一参数是所述目标类使用，例如 &lt;code&gt;public static String reverse(String self)&lt;/code&gt; 提供了一个 &lt;code&gt;reverse()&lt;/code&gt; 进行方法 &lt;code&gt;String&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f855a0c8edce7e177b8b45a6cbe1be9748fa85a5" translate="yes" xml:space="preserve">
          <source>This class defines new groovy methods which appear on normal JDK Date and Calendar classes inside the Groovy environment.</source>
          <target state="translated">该类定义了新的groovy方法,这些方法出现在Groovy环境中的普通JDK日期和日历类中。</target>
        </trans-unit>
        <trans-unit id="7539a6b02de0acc678a620086fdddde40b1d36f7" translate="yes" xml:space="preserve">
          <source>This class defines new groovy methods which appear on normal JDK classes inside the Groovy environment. Static methods are used with the first parameter being the destination class, i.e. &lt;code&gt;public static String reverse(String self)&lt;/code&gt; provides a &lt;code&gt;reverse()&lt;/code&gt; method for &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">此类定义了新的Groovy方法，这些方法出现在Groovy环境中的普通JDK类上。静态方法与第一参数是所述目标类使用，即 &lt;code&gt;public static String reverse(String self)&lt;/code&gt; 提供了一个 &lt;code&gt;reverse()&lt;/code&gt; 进行方法 &lt;code&gt;String&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="22d775343e0c1cedc8e65538de82853d5aec499d" translate="yes" xml:space="preserve">
          <source>This class defines new groovy methods which appear on normal JDK classes related to process management.</source>
          <target state="translated">这个类定义了新的groovy方法,这些方法出现在与流程管理相关的普通JDK类中。</target>
        </trans-unit>
        <trans-unit id="93c83296c1339bc893ca28a97ad7ad9e35c69b38" translate="yes" xml:space="preserve">
          <source>This class defines new groovy static methods which appear on normal JDK Date and Calendar classes inside the Groovy environment.</source>
          <target state="translated">该类定义了新的groovy静态方法,这些方法出现在Groovy环境中的普通JDK Date和Calendar类中。</target>
        </trans-unit>
        <trans-unit id="48764622300d44ff21eff5891fc9ff2ebe3f07cb" translate="yes" xml:space="preserve">
          <source>This class defines new static extension methods which appear on normal JDK Date/Time API (java.time) classes inside the Groovy environment.</source>
          <target state="translated">该类定义了新的静态扩展方法,这些方法出现在Groovy环境中的普通JDK Date/Time API (java.time)类中。</target>
        </trans-unit>
        <trans-unit id="cf24bf76d96add06db8b90790f6d00a2cfad2055" translate="yes" xml:space="preserve">
          <source>This class does not provide the ability to customize the resulting output. A &lt;a href=&quot;jsongenerator&quot;&gt;JsonGenerator&lt;/a&gt; can be used if the ability to alter the resulting output is required.</source>
          <target state="translated">此类不提供自定义结果输出的功能。甲&lt;a href=&quot;jsongenerator&quot;&gt;JsonGenerator&lt;/a&gt;可以，如果需要，以改变所得到的输出的能力来使用。</target>
        </trans-unit>
        <trans-unit id="c469cd04a8269f915fbdad81a3e9c2f515539197" translate="yes" xml:space="preserve">
          <source>This class handles caching internally and its advisable to not store references directly to objects of this class. The static factory method &lt;a href=&quot;classinfo#getClassInfo(java.lang.Class)&quot;&gt;ClassInfo.getClassInfo&lt;/a&gt; should be used to retrieve an instance from the cache. Internally the &lt;code&gt;Class&lt;/code&gt; associated with a &lt;code&gt;ClassInfo&lt;/code&gt; instance is kept as &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/ref/WeakReference.html&quot;&gt;WeakReference&lt;/a&gt;, so it not safe to reference and instance without the Class being either strongly or softly reachable.</source>
          <target state="translated">此类在内部处理高速缓存，建议不要将引用直接存储到此类的对象。应该使用静态工厂方法&lt;a href=&quot;classinfo#getClassInfo(java.lang.Class)&quot;&gt;ClassInfo.getClassInfo&lt;/a&gt;从缓存中检索实例。在内部，与 &lt;code&gt;ClassInfo&lt;/code&gt; 实例关联的 &lt;code&gt;Class&lt;/code&gt; 保持为&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/ref/WeakReference.html&quot;&gt;WeakReference&lt;/a&gt;，因此在不能强地或软地访问该Class的情况下，引用和实例是不安全的。</target>
        </trans-unit>
        <trans-unit id="6dde5778cb52a324896ffae7cfbf596d97d66c91" translate="yes" xml:space="preserve">
          <source>This class handles converting Strings to ASTNode lists.</source>
          <target state="translated">这个类处理将Strings转换为ASTNode列表。</target>
        </trans-unit>
        <trans-unit id="9e92e6926c2a201584cdcb9f5d948909b564b830" translate="yes" xml:space="preserve">
          <source>This class handles the invocation of the ASTAnnotationTransformation when it is encountered by a tree walk. One instance of each exists for each phase of the compilation it applies to. Before invocation the</source>
          <target state="translated">该类处理树行遇到ASTAnnotationTransformation时的调用。每一个实例在它所适用的编译阶段都存在一个实例。在调用</target>
        </trans-unit>
        <trans-unit id="c7e6d3f76a3c4311415b9304af550d64f39dd083" translate="yes" xml:space="preserve">
          <source>This class has several inner classes that also helps picking generic argument types instead of the parameter type.</source>
          <target state="translated">这个类有几个内部类,也有助于挑选通用参数类型而不是参数类型。</target>
        </trans-unit>
        <trans-unit id="3837874bec8e4931d877954a86a0917c89371a7f" translate="yes" xml:space="preserve">
          <source>This class is &lt;b&gt;not&lt;/b&gt; thread-safe.</source>
          <target state="translated">此类&lt;b&gt;不是&lt;/b&gt;线程安全的。</target>
        </trans-unit>
        <trans-unit id="bb171051a560c489be8ec957676e4fd0c5c42c0f" translate="yes" xml:space="preserve">
          <source>This class is a general adapter to adapt a closure to any Java interface.</source>
          <target state="translated">这个类是一个通用的适配器,可以将一个闭包适配到任何Java接口。</target>
        </trans-unit>
        <trans-unit id="1904a5f416e052d74d08f3361764dad66bf5f12b" translate="yes" xml:space="preserve">
          <source>This class is a general adapter to adapt a map of closures to any Java interface.</source>
          <target state="translated">该类是一个通用的适配器,用于将闭包映射到任何Java接口。</target>
        </trans-unit>
        <trans-unit id="cd0e9b1d846e158bbf918633b43cd721a0206943" translate="yes" xml:space="preserve">
          <source>This class is a general adapter to map a call to a Java interface to a given delegate.</source>
          <target state="translated">该类是一个通用适配器,用于将对Java接口的调用映射到一个给定的委托。</target>
        </trans-unit>
        <trans-unit id="407993abd5f454fb2d6c0556db6a1d0ca2f05505" translate="yes" xml:space="preserve">
          <source>This class is extended by several hint providers that make it easier to use as annotation values.</source>
          <target state="translated">该类由几个提示提供者扩展,使其更容易作为注解值使用。</target>
        </trans-unit>
        <trans-unit id="75718b0560771207235791afb3b9fda1625fc4bb" translate="yes" xml:space="preserve">
          <source>This class is for internal use only! This class will dispatch to the right type adapters according to the kind of binary expression that is provided.</source>
          <target state="translated">该类只供内部使用!该类将根据所提供的二进制表达式的种类派遣到合适的类型适配器。该类将根据所提供的二进制表达式的种类派遣到正确的类型适配器。</target>
        </trans-unit>
        <trans-unit id="76d7804b1c6dc7652647c993f4fdf0eded744a8a" translate="yes" xml:space="preserve">
          <source>This class is important to the performance of the parser. It stores Value objects in a map where they are evaluated lazily. This is great for JSONPath types of application, and Object Serialization but not for maps that are going to be stored in a cache.</source>
          <target state="translated">这个类对解析器的性能很重要。它将Value对象存储在一个地图中,在那里它们被懒惰地评估。这对于JSONPath类型的应用和对象序列化是非常好的,但对于要存储在缓存中的地图就不是了。</target>
        </trans-unit>
        <trans-unit id="96572291f640285f4a1f9ecf3aa073f0a992daab" translate="yes" xml:space="preserve">
          <source>This class is instantiated and invoked when an AST transformation is activated. For Global AST Transformations, this interface is called once per SourceUnit, which is usually a Groovy source file. For Local AST Transformations, this interface is invoked once every time the Local annotation marker is encountered.</source>
          <target state="translated">这个类在AST转换被激活时被实例化并被调用。对于全局AST变换,每个SourceUnit(通常是一个Groovy源文件)都会调用这个接口一次。对于局部AST变换,每次遇到局部注释标记时,这个接口就会被调用一次。</target>
        </trans-unit>
        <trans-unit id="cc67996ced277a761581444c4cf862c08d075467" translate="yes" xml:space="preserve">
          <source>This class is responsible for assembling JMX Attribute Info from the meta map. It cycles through the meta map from the Node and generate JMX Info objects used to expose information in the MBeanServer.</source>
          <target state="translated">该类负责从元图中组合JMX属性信息。它从节点循环浏览元图,并生成用于在MBeanServer中公开信息的JMX Info对象。</target>
        </trans-unit>
        <trans-unit id="075476029820d79cc983f42159f8eb4cdea63809" translate="yes" xml:space="preserve">
          <source>This class is responsible for assembling JMX Operation Info from the meta map. It cycles through the provided meta map from the bean() node and generate JMX Info objects used to expose information in the MBeanServer.</source>
          <target state="translated">该类负责从元图中组合JMX操作信息。它从 bean()节点循环浏览所提供的元地图,并生成 JMX Info 对象,用于在 MBeanServer 中公开信息。</target>
        </trans-unit>
        <trans-unit id="4b30124afd1417d4b385c76f80bcf34578d51bd0" translate="yes" xml:space="preserve">
          <source>This class is the base for any annotation alias processor.</source>
          <target state="translated">该类是任何注解别名处理器的基础。</target>
        </trans-unit>
        <trans-unit id="5924197edb00c649d5d755fc6516a87d87145be3" translate="yes" xml:space="preserve">
          <source>This class is the factory for the emitter node. This node facilitates the declaration of a JMX event emitter. The emitter is used to broadcast arbitrary event on the MBeanServer's event bus. Registered listeners are able to consume event once sent.</source>
          <target state="translated">该类是发射器节点的工厂。这个节点方便了JMX事件发射器的声明。该发射器用于在MBeanServer的事件总线上广播任意事件。注册的监听者能够在事件发送后进行消费。</target>
        </trans-unit>
        <trans-unit id="653683ec37c7baebfd2f2bbe95b36d002cf25d2e" translate="yes" xml:space="preserve">
          <source>This class is used as a pluggable way to resolve class names. An instance of this class has to be added to &lt;a href=&quot;compilationunit&quot;&gt;CompilationUnit&lt;/a&gt; using &lt;a href=&quot;compilationunit#setClassNodeResolver(org.codehaus.groovy.control.ClassNodeResolver)&quot;&gt;CompilationUnit.setClassNodeResolver&lt;/a&gt;. The CompilationUnit will then set the resolver on the &lt;a href=&quot;resolvevisitor&quot;&gt;ResolveVisitor&lt;/a&gt; each time new. The ResolveVisitor will prepare name lookup and then finally ask the resolver if the class exists. This resolver then can return either a SourceUnit or a ClassNode. In case of a SourceUnit the compiler is notified that a new source is to be added to the compilation queue. In case of a ClassNode no further action than the resolving is done. The lookup result is stored in the helper class LookupResult. This class provides a class cache to cache lookups. If you don't want this, you have to override the methods &lt;a href=&quot;classnoderesolver#cacheClass(java.lang.String,%20org.codehaus.groovy.ast.ClassNode)&quot;&gt;ClassNodeResolver.cacheClass&lt;/a&gt; and &lt;a href=&quot;classnoderesolver#getFromClassCache(java.lang.String)&quot;&gt;ClassNodeResolver.getFromClassCache&lt;/a&gt;. Custom lookup logic is supposed to go into the method &lt;a href=&quot;classnoderesolver#findClassNode(java.lang.String,%20org.codehaus.groovy.control.CompilationUnit)&quot;&gt;ClassNodeResolver.findClassNode&lt;/a&gt; while the entry method is &lt;a href=&quot;classnoderesolver#resolveName(java.lang.String,%20org.codehaus.groovy.control.CompilationUnit)&quot;&gt;ClassNodeResolver.resolveName&lt;/a&gt;</source>
          <target state="translated">此类用作解析类名称的可插入方式。必须使用&lt;a href=&quot;compilationunit#setClassNodeResolver(org.codehaus.groovy.control.ClassNodeResolver)&quot;&gt;CompilationUnit.setClassNodeResolver&lt;/a&gt;将此类的实例添加到&lt;a href=&quot;compilationunit&quot;&gt;CompilationUnit&lt;/a&gt;中。然后，每次编译时，CompilationUnit都会在&lt;a href=&quot;resolvevisitor&quot;&gt;ResolveVisitor&lt;/a&gt;上设置解析器。 ResolveVisitor将准备名称查找，然后最后询问解析器该类是否存在。然后，此解析器可以返回SourceUnit或ClassNode。在使用SourceUnit的情况下，会通知编译器要向编译队列添加新的源。在ClassNode的情况下，除了解析之外，没有其他动作。查找结果存储在助手类LookupResult中。此类提供了用于缓存查找的类缓存。如果您不想这样做，则必须重写方法&lt;a href=&quot;classnoderesolver#cacheClass(java.lang.String,%20org.codehaus.groovy.ast.ClassNode)&quot;&gt;ClassNodeResolver.cacheClass&lt;/a&gt;和&lt;a href=&quot;classnoderesolver#getFromClassCache(java.lang.String)&quot;&gt;ClassNodeResolver.getFromClassCache&lt;/a&gt;。自定义查找逻辑应该输入到方法&lt;a href=&quot;classnoderesolver#findClassNode(java.lang.String,%20org.codehaus.groovy.control.CompilationUnit)&quot;&gt;ClassNodeResolver.findClassNode中，&lt;/a&gt;而输入方法是&lt;a href=&quot;classnoderesolver#resolveName(java.lang.String,%20org.codehaus.groovy.control.CompilationUnit)&quot;&gt;ClassNodeResolver.resolveName&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f14354187c290397fd82b9881697595ff4486600" translate="yes" xml:space="preserve">
          <source>This class is used internally by the compiler to transform expressions like multiple assignments into a list of assignments.</source>
          <target state="translated">该类在编译器内部用于将多重赋值等表达式转换为赋值列表。</target>
        </trans-unit>
        <trans-unit id="8b644eb64cd81a47f8da1cd879e99bb7530c7027" translate="yes" xml:space="preserve">
          <source>This class is used to describe generic type signatures for ClassNodes.</source>
          <target state="translated">该类用于描述ClassNodes的通用类型签名。</target>
        </trans-unit>
        <trans-unit id="ec6a7563ff7840c43f2735a87393e68cb11d3a71" translate="yes" xml:space="preserve">
          <source>This class is used to make extension methods lookup faster. Basically, it will only collect the list of extension methods (see &lt;a href=&quot;../../runtime/m12n/extensionmodule&quot;&gt;ExtensionModule&lt;/a&gt; if the list of extension modules has changed. It avoids recomputing the whole list each time we perform a method lookup.</source>
          <target state="translated">此类用于使扩展方法查找更快。基本上，它只会收集扩展方法的列表（如果扩展模块的列表已更改，请参阅&lt;a href=&quot;../../runtime/m12n/extensionmodule&quot;&gt;ExtensionModule&lt;/a&gt;。它避免了每次执行方法查找时都重新计算整个列表。</target>
        </trans-unit>
        <trans-unit id="5036dcc6c04f6c16da5439995a0999d3e2a24e94" translate="yes" xml:space="preserve">
          <source>This class may be used as a direct replacement for any use of java.util.Hashtable that does not depend on readers being blocked during updates. Like Hashtable but unlike java.util.HashMap, this class does NOT allow</source>
          <target state="translated">这个类可以直接替代java.util.Hashtable的任何使用,它不依赖于更新过程中读者被阻止。与Hashtable一样,但与java.util.HashMap不同,该类不允许使用</target>
        </trans-unit>
        <trans-unit id="d272b41b9db7786d68de80b43d127b8fd19109cd" translate="yes" xml:space="preserve">
          <source>This class mutates the Java AST, whilst it is still a Java AST, in readiness for conversion to Groovy, yippee-ky-a !</source>
          <target state="translated">这个类在Java AST还是Java AST的情况下,对Java AST进行了突变,为转换为Groovy做好了准备,yippee-ky-a !</target>
        </trans-unit>
        <trans-unit id="55d9c8517d3a0e99ce14f62132a7aaace2185bbd" translate="yes" xml:space="preserve">
          <source>This class provides a very simple linked list of memory managed elements. This class does not support concurrent modifications nor will it check for them. This class is also not thread safe.</source>
          <target state="translated">这个类提供了一个非常简单的内存管理元素的链接列表。该类不支持并发修改,也不会检查并发修改。这个类也不是线程安全的。</target>
        </trans-unit>
        <trans-unit id="28a37ccc500981db234c339f5342ff417d4b979f" translate="yes" xml:space="preserve">
          <source>This class provides an AST Transformation to add a log field to a class.</source>
          <target state="translated">该类提供了一个AST转换,以添加一个日志字段到一个类。</target>
        </trans-unit>
        <trans-unit id="b3a68d6bf431714254204e9288b4f6f5070f27cb" translate="yes" xml:space="preserve">
          <source>This class provides an empty implementation of &lt;a href=&quot;groovyparservisitor&quot;&gt;GroovyParserVisitor&lt;/a&gt;, which can be extended to create a visitor which only needs to handle a subset of the available methods.</source>
          <target state="translated">此类提供了&lt;a href=&quot;groovyparservisitor&quot;&gt;GroovyParserVisitor&lt;/a&gt;的空实现，可以将其扩展以创建仅需要处理可用方法子集的访问者。</target>
        </trans-unit>
        <trans-unit id="c9b1f302f9aedce71bb6896db58d1478516c5a7c" translate="yes" xml:space="preserve">
          <source>This class provides helper methods to determine the type from a widening operation for example for a plus operation.</source>
          <target state="translated">该类提供了辅助方法,用于确定加宽操作的类型,例如加号操作。</target>
        </trans-unit>
        <trans-unit id="9d718529ccca05eed963c102f62e0edbdeac53d0" translate="yes" xml:space="preserve">
          <source>This class represents a &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Map.html&quot;&gt;Map&lt;/a&gt; that is optimized for a small number of entries. For a number of entries up to &lt;code&gt;listSize&lt;/code&gt; the entries are stored in arrays. After &lt;code&gt;listSize&lt;/code&gt; entries are exceeded storage switches internally to a &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Map.html&quot;&gt;Map&lt;/a&gt; and converts back to being array based when its size is less than or equal to &lt;code&gt;listSize&lt;/code&gt;. Null keys or values are not supported. This class is not thread safe.</source>
          <target state="translated">此类表示针对少数条目进行了优化的&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Map.html&quot;&gt;Map&lt;/a&gt;。对于许多不超过 &lt;code&gt;listSize&lt;/code&gt; 的条目，这些条目存储在数组中。后 &lt;code&gt;listSize&lt;/code&gt; 条目超出存储在内部切换到&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Map.html&quot;&gt;地图&lt;/a&gt;和转换回基于作为阵列时，它的尺寸小于或等于 &lt;code&gt;listSize&lt;/code&gt; 。不支持空键或空值。此类不是线程安全的。</target>
        </trans-unit>
        <trans-unit id="0f6265e2af3bfac2864af2a93fa49da29483f821" translate="yes" xml:space="preserve">
          <source>This class represents a MetaMethod that is a closure that pretends to be a static method. It is used by ExpandoMetaClass to allow addition of static methods defined as closures</source>
          <target state="translated">这个类代表了一个MetaMethod,它是一个假装成静态方法的闭包,它被ExpandoMetaClass使用,允许添加定义为闭包的静态方法。它被ExpandoMetaClass使用,允许添加定义为闭包的静态方法。</target>
        </trans-unit>
        <trans-unit id="5ff97f4943b1b4f4e15e6cd296448b65369de926" translate="yes" xml:space="preserve">
          <source>This class represents a list of expressions used to create closures. Example: &lt;code&gt;
 def foo = (1;2;;)
 &lt;/code&gt; The right side is a ClosureListExpression consisting of two ConstantExpressions for the values 1 and 2, and two EmptyStatement entries. The ClosureListExpression defines a new variable scope. All created Closures share this scope.</source>
          <target state="translated">此类表示用于创建闭包的表达式的列表。示例： &lt;code&gt; def foo = (1;2;;) &lt;/code&gt; 右侧是ClosureListExpression，它由两个值1和2的ConstantExpression和两个EmptyStatement条目组成。ClosureListExpression定义了一个新的变量范围。所有创建的闭包都共享该范围。</target>
        </trans-unit>
        <trans-unit id="e490a48691949cdd943dd24ddf11e92b18b4c106" translate="yes" xml:space="preserve">
          <source>This class represents a property with multiple setters. Unlike a MetaBeanProperty you cannot get the setter in this case. Instead invocation is done through the meta class of the property recevier.</source>
          <target state="translated">这个类表示一个有多个设置器的属性。与MetaBeanProperty不同的是,在这种情况下,你不能获取设置器。相反,调用是通过属性recevier的元类完成的。</target>
        </trans-unit>
        <trans-unit id="b9fe55eb136f2d9bda5b170f7ec0b6ef4984da04" translate="yes" xml:space="preserve">
          <source>This class represents a reference to the most actual incarnation of a Metaclass. INTERNAL USE ONLY.</source>
          <target state="translated">这个类表示对元类的最实际化身的引用。仅供内部使用。</target>
        </trans-unit>
        <trans-unit id="b1af226539f2899b14379794e0635a39c3ce7e1e" translate="yes" xml:space="preserve">
          <source>This class represents a sequence of &lt;a href=&quot;bytecodeinstruction&quot;&gt;BytecodeInstruction&lt;/a&gt;s or &lt;a href=&quot;../ast/astnode&quot;&gt;ASTNode&lt;/a&gt;s. The evaluation is depending on the type of the visitor.</source>
          <target state="translated">此类表示&lt;a href=&quot;bytecodeinstruction&quot;&gt;BytecodeInstruction&lt;/a&gt;或&lt;a href=&quot;../ast/astnode&quot;&gt;ASTNode&lt;/a&gt;的序列。评估取决于访问者的类型。</target>
        </trans-unit>
        <trans-unit id="5460585a78cb458d104b1c09f4518524d3250db9" translate="yes" xml:space="preserve">
          <source>This class represents an error that is thrown when a bug is recognized inside the runtime. Basically it is thrown when a constraint is not fulfilled that should be fulfilled.</source>
          <target state="translated">这个类代表了一个错误,当在运行时发现一个错误时,就会抛出这个错误。基本上,当一个应该满足的约束没有被满足时,就会被抛出。</target>
        </trans-unit>
        <trans-unit id="9e8efb041e1d70cfb3206ad25e6c209a78c9bbd0" translate="yes" xml:space="preserve">
          <source>This class represents non public API used by AsmClassGenerator. Don't use this class in your code</source>
          <target state="translated">这个类代表AsmClassGenerator使用的非公共API。不要在你的代码中使用这个类</target>
        </trans-unit>
        <trans-unit id="8dc5c7fcffd17f002fdf6362493892385bbec93d" translate="yes" xml:space="preserve">
          <source>This class returns half bound &lt;a href=&quot;fullbinding&quot;&gt;FullBinding&lt;/a&gt;s on the source half to the model object for every property reference (and I do mean every, valid or not, queried before or not). These returned half bindings are stored strongly in a list when generated. Changing the model will keep all existing bindings but change the source on all of the bindings. Formerly Known as Model Binding.</source>
          <target state="translated">此类为每个属性引用将源一半的&lt;a href=&quot;fullbinding&quot;&gt;FullBinding&lt;/a&gt;一半返回给模型对象（我的意思是，无论是否有效，都在查询之前或之后查询过每个）。生成时，这些返回的半绑定牢固地存储在列表中。更改模型将保留所有现有绑定，但更改所有绑定的源。以前称为模型绑定。</target>
        </trans-unit>
        <trans-unit id="9e6c51aebeac50037713f9721b08801c77dc34e7" translate="yes" xml:space="preserve">
          <source>This class returns half bound &lt;a href=&quot;fullbinding&quot;&gt;FullBinding&lt;/a&gt;s on the source half to the model object for every property reference (and I do mean every, valid or not, queried before or not). These returned half bindings are stored strongly in a list when generated. Changing the model will keep all existing bindings but change the source on all of the bininfs Formerly Known as Model Binding.</source>
          <target state="translated">此类为每个属性引用将源一半的&lt;a href=&quot;fullbinding&quot;&gt;FullBinding&lt;/a&gt;一半返回给模型对象（我的意思是，无论是否有效，都在查询之前或之后查询过每个）。生成时，这些返回的半绑定牢固地存储在列表中。更改模型将保留所有现有绑定，但更改所有bininfs的源，以前称为模型绑定。</target>
        </trans-unit>
        <trans-unit id="c8b96a7d9802784a5662432c77e71b4d3622ca61" translate="yes" xml:space="preserve">
          <source>This class takes Groovy source code, compiles it to a specific compile phase, and then decompiles it back to the groovy source. It is used by GroovyConsole's AST Browser, but can also be invoked from the command line.</source>
          <target state="translated">该类接收Groovy源代码,将其编译到特定的编译阶段,然后反编译回groovy源代码。它被GroovyConsole的AST浏览器使用,但也可以从命令行调用。</target>
        </trans-unit>
        <trans-unit id="806720aed213bca40586cfe6fc91e7e7625aa6f6" translate="yes" xml:space="preserve">
          <source>This class will delegate all calls to a WriterController given in the constructor.</source>
          <target state="translated">该类将委托所有对构造函数中给出的WriterController的调用。</target>
        </trans-unit>
        <trans-unit id="2c4727fcfc1ab42e56910178a7ab2ce60355d891" translate="yes" xml:space="preserve">
          <source>This code is executed after the method is called.</source>
          <target state="translated">这段代码是在方法被调用后执行的。</target>
        </trans-unit>
        <trans-unit id="3715f6b9738b222d0f7aca024f9cc5c22e37d357" translate="yes" xml:space="preserve">
          <source>This code is executed after the method is optionally called.</source>
          <target state="translated">这段代码是在该方法被选择性调用后执行的。</target>
        </trans-unit>
        <trans-unit id="93109698a32aa712b1940a99bdbc8567f3433156" translate="yes" xml:space="preserve">
          <source>This code is executed before the method is called.</source>
          <target state="translated">这段代码是在方法被调用之前执行的。</target>
        </trans-unit>
        <trans-unit id="75ed3577608647dd335811066a354027a410204a" translate="yes" xml:space="preserve">
          <source>This code is executed before the method is optionally called.</source>
          <target state="translated">这段代码会在方法被选择性调用之前执行。</target>
        </trans-unit>
        <trans-unit id="c4b42f2f4e1fd4b46e3443559ab2f4536ce215e3" translate="yes" xml:space="preserve">
          <source>This code is transformed by the compiler into something resembling the following snippet. Notice the difference between a String and a def/Object property:</source>
          <target state="translated">这段代码被编译器转换为类似于下面的代码段。请注意String和def/Object属性之间的区别。</target>
        </trans-unit>
        <trans-unit id="c33c1278e97a91dcb6edf06c86644b99e9f271d8" translate="yes" xml:space="preserve">
          <source>This comparator is used when we return the list of methods from DGM which name correspond to a given name.</source>
          <target state="translated">当我们从DGM中返回与给定名称相对应的方法列表时,就会用到这个比较器。</target>
        </trans-unit>
        <trans-unit id="e75617b624f61b0683d73241b7a0d46ab3599d9b" translate="yes" xml:space="preserve">
          <source>This comparator is used when we return the list of methods from DGM which name correspond to a given name. As we also lookup for DGM methods of superclasses or interfaces, it may be possible to find two methods which have the same name and the same arguments. In that case, we should not add the method from superclass or interface otherwise the system won't be able to select the correct method, resulting in an ambiguous method selection for similar methods.</source>
          <target state="translated">当我们从 DGM 中返回与给定名称相对应的方法列表时,就会用到这个比较器。由于我们也在查找超类或接口的DGM方法,可能会发现两个方法的名称和参数都相同,在这种情况下,我们不应该添加超类或接口的方法,否则系统将无法选择正确的方法。在这种情况下,我们不应该添加超类或接口的方法,否则系统将无法选择正确的方法,导致类似的方法选择模糊不清。</target>
        </trans-unit>
        <trans-unit id="4894b9b16a69165c0c31e618c60bcc10ce7fe009" translate="yes" xml:space="preserve">
          <source>This compilation customizer allows addiing various types of imports to the compilation unit. Supports adding:</source>
          <target state="translated">该编译自定义器允许在编译单元中添加各种类型的导入。支持添加。</target>
        </trans-unit>
        <trans-unit id="9ba2a85f884d7fa0e633cdb111b7b24677cc8a10" translate="yes" xml:space="preserve">
          <source>This completer tries to behave as similar as possible to</source>
          <target state="translated">这个补全器的行为尽量类似于</target>
        </trans-unit>
        <trans-unit id="050f26d61c4d7297780b69903203f0b647dfe314" translate="yes" xml:space="preserve">
          <source>This constant is for comparing targetBytecode to ensure it is set to JDK 1.5 or later.</source>
          <target state="translated">这个常量用于比较targetBytecode,以确保它被设置为JDK 1.5或更高版本。</target>
        </trans-unit>
        <trans-unit id="c8629d832b003b8c89dc03855aac1608ff5226a1" translate="yes" xml:space="preserve">
          <source>This constant is for comparing targetBytecode to ensure it is set to an earlier value than JDK 1.5.</source>
          <target state="translated">这个常量用于比较targetBytecode,以确保它被设置为比JDK 1.5更早的值。</target>
        </trans-unit>
        <trans-unit id="d318776f0e97720de67dae45081b1705371f4405" translate="yes" xml:space="preserve">
          <source>This constructor is public to permit tools that require a JavaBean instance to operate.</source>
          <target state="translated">这个构造函数是公开的,以允许需要一个JavaBean实例的工具来操作。</target>
        </trans-unit>
        <trans-unit id="adebfc74f0005704245e8892d5946a9a3b3e0d7b" translate="yes" xml:space="preserve">
          <source>This converts a possibly negative index to a real index into the array.</source>
          <target state="translated">这将一个可能是负数的索引转换为数组中的实数索引。</target>
        </trans-unit>
        <trans-unit id="89580999f8cc2ab98adcb35587949a71043dac5a" translate="yes" xml:space="preserve">
          <source>This creates and starts the socket server on a new Thread.</source>
          <target state="translated">这将在一个新的线程上创建并启动socket服务器。</target>
        </trans-unit>
        <trans-unit id="4cfe97596d83c01a3c1b2f921489c411e8f50f6a" translate="yes" xml:space="preserve">
          <source>This creates and starts the socket server on a new Thread. There is no need to call run or spawn a new thread yourself.</source>
          <target state="translated">这将在一个新的线程上创建并启动socket服务器。不需要自己调用运行或生成一个新线程。</target>
        </trans-unit>
        <trans-unit id="f210b6ef5e62f107b81d83cc8ea5f60a3593e2ba" translate="yes" xml:space="preserve">
          <source>This customizer allows applying an AST transformation to a source unit with several strategies. Creating a customizer with the &lt;a href=&quot;asttransformationcustomizer#ASTTransformationCustomizer(java.lang.Class)&quot;&gt; class constructor&lt;/a&gt; will trigger an AST transformation for each class node of a source unit. However, you cannot pass parameters to the annotation so the default values will be used. Writing :</source>
          <target state="translated">该定制程序允许通过几种策略将AST转换应用于源单元。使用&lt;a href=&quot;asttransformationcustomizer#ASTTransformationCustomizer(java.lang.Class)&quot;&gt;类构造函数&lt;/a&gt;创建定制器将为源单元的每个类节点触发AST转换。但是，您不能将参数传递给注释，因此将使用默认值。写作 ：</target>
        </trans-unit>
        <trans-unit id="7c14dcaf1099adb43e65b7bae2bb439c3ad65669" translate="yes" xml:space="preserve">
          <source>This customizer allows securing source code by controlling what code constructs are permitted. This is typically done when using Groovy for its scripting or domain specific language (DSL) features. For example, if you only want to allow arithmetic operations in a groovy shell, you can configure this customizer to restrict package imports, method calls and so on.</source>
          <target state="translated">这个定制器可以通过控制哪些代码结构被允许来保证源代码的安全。这通常是在使用Groovy的脚本或特定领域语言(DSL)功能时进行的。例如,如果你只想在groovy shell中允许算术操作,你可以配置这个自定义器来限制包的导入、方法调用等。</target>
        </trans-unit>
        <trans-unit id="c5a34da6d1a917395eafdae691fc9b3b8e14c4ed" translate="yes" xml:space="preserve">
          <source>This differs from normal setters in that we need to add a declared exception java.beans.PropertyVetoException</source>
          <target state="translated">这与一般的设定器不同,我们需要添加一个声明的异常 java.beans.PropertyVetoException</target>
        </trans-unit>
        <trans-unit id="a09a623dc06b4ba819cd522a87f90fc6033ededc" translate="yes" xml:space="preserve">
          <source>This enumeration can be used whenever it is preferred to annotate a class as &lt;a href=&quot;typechecked&quot;&gt;TypeChecked&lt;/a&gt; in general, but where only one or more methods are &quot;dynamic&quot;. This allows the user to annotate the class itself then annotate only the methods which require exclusion.</source>
          <target state="translated">一般情况下，只要首选将类注释为&lt;a href=&quot;typechecked&quot;&gt;TypeChecked&lt;/a&gt;即可使用此枚举，但是只有一种或多种方法是&amp;ldquo;动态的&amp;rdquo;时才可以使用此枚举。这允许用户注释类本身，然后仅注释需要排除的方法。</target>
        </trans-unit>
        <trans-unit id="d7e2273d5cb9c0c49c2bb24c5a83bf004429212a" translate="yes" xml:space="preserve">
          <source>This enumeration is used by the AST transformations which rely on static type checking, either to store or to retrieve information from AST node metadata. The values of this enumeration are used as metadata keys.</source>
          <target state="translated">这个枚举被AST转换使用,它依赖于静态类型检查,可以存储或检索AST节点元数据的信息。这个枚举的值被用作元数据键。</target>
        </trans-unit>
        <trans-unit id="ab60dfbbe5ec836f7b35f8c976d66e68b2ce1c5a" translate="yes" xml:space="preserve">
          <source>This example prints out file counts and size aggregates for groovy source files within a directory tree:</source>
          <target state="translated">这个例子可以打印出目录树中groovy源文件的文件数和大小汇总。</target>
        </trans-unit>
        <trans-unit id="b3f387a9504f8b156c1813987d3758205ede705a" translate="yes" xml:space="preserve">
          <source>This example shows a common convention. When mixing short and long names, the short names are often one character in size. One character options with arguments don't require a space between the option and the argument, e.g. &lt;code&gt;-Ddebug=true&lt;/code&gt;. The example also shows the use of '_' when no short option is applicable.</source>
          <target state="translated">本示例显示了一个通用约定。当混合短名称和长名称时，短名称的大小通常为一个字符。带参数的一个字符选项在选项和参数之间不需要空格，例如 &lt;code&gt;-Ddebug=true&lt;/code&gt; 。该示例还显示了在没有短选项适用的情况下使用&amp;ldquo; _&amp;rdquo;的情况。</target>
        </trans-unit>
        <trans-unit id="f2dddbad35ebae3e8699d18932c17e50f8f9d1bb" translate="yes" xml:space="preserve">
          <source>This example uses a mix of the JSP style and GString style placeholders but you can typically use just one style if you wish. Running this example will produce this output:</source>
          <target state="translated">这个例子混合使用了JSP样式和GString样式的占位符,但如果你愿意,通常可以只使用一种样式。运行这个例子将产生以下输出。</target>
        </trans-unit>
        <trans-unit id="7819bf00abfa1a28062447c4112ec17536e74c15" translate="yes" xml:space="preserve">
          <source>This example will produce this output:</source>
          <target state="translated">这个例子将产生这样的输出。</target>
        </trans-unit>
        <trans-unit id="6a9df6b19f4850ac1dca0ca99754733c1765bf4e" translate="yes" xml:space="preserve">
          <source>This exception is thrown if an attempt is made to set a read only property</source>
          <target state="translated">如果试图设置一个只读属性,就会抛出这个异常。</target>
        </trans-unit>
        <trans-unit id="c3c90e86c15b6995f6996affd8fd0622412caea4" translate="yes" xml:space="preserve">
          <source>This exception is thrown if the runtime is unable to select a method. This class builds the exception text when calling getMessage.</source>
          <target state="translated">如果运行时无法选择一个方法,就会抛出这个异常。该类在调用getMessage时建立异常文本。</target>
        </trans-unit>
        <trans-unit id="7a099c6f741eb0347d0ea40c91b286e1ba7e1c6f" translate="yes" xml:space="preserve">
          <source>This extension also supports optional type checking of the model</source>
          <target state="translated">该扩展还支持对模型的可选类型检查。</target>
        </trans-unit>
        <trans-unit id="2e0f02c76915f7464bc8c11fd1e37c238231e442" translate="yes" xml:space="preserve">
          <source>This factory allows the generation of a &lt;a href=&quot;../secureastcustomizer&quot;&gt;SecureASTCustomizer&lt;/a&gt;. Embedded elements are delegated to a &lt;a href=&quot;../secureastcustomizer&quot;&gt;SecureASTCustomizer&lt;/a&gt; instance.</source>
          <target state="translated">该工厂允许生成&lt;a href=&quot;../secureastcustomizer&quot;&gt;SecureASTCustomizer&lt;/a&gt;。嵌入式元素将委派给&lt;a href=&quot;../secureastcustomizer&quot;&gt;SecureASTCustomizer&lt;/a&gt;实例。</target>
        </trans-unit>
        <trans-unit id="75bc8d98e4b55661fc8e92d226274681ee70c5d6" translate="yes" xml:space="preserve">
          <source>This factory allows the generation of an &lt;a href=&quot;../importcustomizer&quot;&gt;import customizer&lt;/a&gt;. You may embed several elements:</source>
          <target state="translated">该工厂允许生成&lt;a href=&quot;../importcustomizer&quot;&gt;导入定制器&lt;/a&gt;。您可以嵌入几个元素：</target>
        </trans-unit>
        <trans-unit id="6408936103d79d9191656e5b5b91824ad76e65c7" translate="yes" xml:space="preserve">
          <source>This factory class is used to create a listener() node for JmxBuilder. Listener nodes are used to create a generic event listener (that is automatically registered with the MBean) that can handle any event broadcasted on the MBeanServer's event bus.</source>
          <target state="translated">这个工厂类用于为JmxBuilder创建一个listener()节点。监听器节点用于创建一个通用的事件监听器(该监听器会自动注册到MBean中),它可以处理MBeanServer的事件总线上广播的任何事件。</target>
        </trans-unit>
        <trans-unit id="64a41a5aefc83666cff21add72710b51c3a25d2f" translate="yes" xml:space="preserve">
          <source>This factory generates an ASTTransformationCustomizer.</source>
          <target state="translated">这个工厂会生成一个ASTTransformationCustomizer。</target>
        </trans-unit>
        <trans-unit id="613b0e8a47bfd00974cb820fbc8fcdabb33420f9" translate="yes" xml:space="preserve">
          <source>This factory generates an array of compilation customizers.</source>
          <target state="translated">这个工厂会生成一个编译自定义器的数组。</target>
        </trans-unit>
        <trans-unit id="9250f3138d28ed13d750ef456e16992d0448f7fb" translate="yes" xml:space="preserve">
          <source>This factory is the correct way to wire together a Groovy parser and lexer.</source>
          <target state="translated">这个工厂是将Groovy解析器和lexer连在一起的正确方法。</target>
        </trans-unit>
        <trans-unit id="92ce93b17831cccaf34755de29d405aee9ba805a" translate="yes" xml:space="preserve">
          <source>This factory lets a user define a compilation customizer without having to define an anonymous inner class.</source>
          <target state="translated">这个工厂让用户可以定义一个编译自定义器,而不需要定义一个匿名的内部类。</target>
        </trans-unit>
        <trans-unit id="0f3cad60cfab134b21507e52064941c3963e3069" translate="yes" xml:space="preserve">
          <source>This factory returns a container node for all other nodes that are used to collect meta data for resources that are exported to the MBeanServer for management.</source>
          <target state="translated">这个工厂为所有其他节点返回一个容器节点,这些节点用于收集导出到MBeanServer管理的资源的元数据。</target>
        </trans-unit>
        <trans-unit id="974ec32a45157e53b4a9707aa7c20f425a6b5889" translate="yes" xml:space="preserve">
          <source>This factory returns the bean() node. This node is used to declaratively expose a POGO/POJO to be exported to the MBeanServer for management. You can use the builder node to declare the descriptor or embed the descriptor directly in the object being exposed using static variable descriptor (or jmx). You should note that embedded descriptor takes precedence over declared builder descriptor.</source>
          <target state="translated">这个工厂返回 bean()节点。这个节点用于声明性地暴露一个POGO/POJO,以便导出到MBeanServer进行管理。你可以使用构建器节点来声明描述符,或者使用静态变量描述符(或jmx)直接将描述符嵌入到被暴露的对象中。你应该注意,嵌入的描述符优先于声明的构建器描述符。</target>
        </trans-unit>
        <trans-unit id="34a50447c879fcb2342872b489a204ccc49314ed" translate="yes" xml:space="preserve">
          <source>This feature is particularly useful on operating systems which place limitations on the size of the command line (e.g. Windows). The feature is similar to the 'Command Line Argument File' processing supported by javadoc and javac. Consult the corresponding documentation for those tools if you wish to see further examples.</source>
          <target state="translated">这个功能在对命令行大小有限制的操作系统上特别有用(如Windows)。这个功能类似于javadoc和javac支持的 &quot;命令行参数文件 &quot;处理。如果你想看更多的例子,请参考这些工具的相应文档。</target>
        </trans-unit>
        <trans-unit id="ce367d20dbb2c637770c58d933db6117f53236b0" translate="yes" xml:space="preserve">
          <source>This field is used to track assignments in if/else branches, for loops and while loops.</source>
          <target state="translated">该字段用于跟踪if/else分支、for循环和while循环中的任务。</target>
        </trans-unit>
        <trans-unit id="cbf12fc93c6526242b10d4458cb6d1beee3e2d25" translate="yes" xml:space="preserve">
          <source>This field is used to track assignments in if/else branches, for loops and while loops. For example, in the following code: &lt;code&gt;if (cond) { x = 1 } else { x = '123' }&lt;/code&gt; the inferred type of x after the if/else statement should be the LUB of int and String.</source>
          <target state="translated">该字段用于跟踪if / else分支，for循环和while循环中的分配。例如，在下面的代码中： &lt;code&gt;if (cond) { x = 1 } else { x = '123' }&lt;/code&gt; if / else语句之后的x的推断类型应该是int和String的LUB。</target>
        </trans-unit>
        <trans-unit id="1d467559145b6ea3f70124f19c4aef65c4321104" translate="yes" xml:space="preserve">
          <source>This field used for type derivation Check IfStatement matched pattern: Object var1; if (!</source>
          <target state="translated">该字段用于类型推导检查IfStatement是否匹配模式。Object var1;if (!</target>
        </trans-unit>
        <trans-unit id="0bd93366cf93d2b7dd6b74705e67955660b7f0e0" translate="yes" xml:space="preserve">
          <source>This field used for type derivation Check IfStatement matched pattern: Object var1; if (!(var1 instanceOf Runnable)){ return } // Here var1 instance of Runnable</source>
          <target state="translated">该字段用于类型派生 检查IfStatement是否匹配模式。Object var1;if (!(var1 instanceOf Runnable)){return }。//这里是Runnable的var1实例</target>
        </trans-unit>
        <trans-unit id="b090238d44551f2e3d0b2f1cf114fd579922fca8" translate="yes" xml:space="preserve">
          <source>This fixes strict jline 2.12 ArgumentCompleter See https://github.com/jline/jline2/pull/202</source>
          <target state="translated">这修复了严格的jline 2.12 ArgumentCompleter 参见https://github.com/jline/jline2/pull/202。</target>
        </trans-unit>
        <trans-unit id="850443fd7300e262bc8d43a95f5840748fef1125" translate="yes" xml:space="preserve">
          <source>This gets the code statement of the closure.</source>
          <target state="translated">这就得到了封闭的代码语句。</target>
        </trans-unit>
        <trans-unit id="692a8f7be3be9f9075aa6a114742d6a2eca54b83" translate="yes" xml:space="preserve">
          <source>This gets the code statement of the closure. You can read this method to find out what actions the closure is going to perform.</source>
          <target state="translated">这可以得到闭包的代码声明。你可以通过阅读这个方法来了解闭包要执行的动作。</target>
        </trans-unit>
        <trans-unit id="3a0d23a5c458818da1444db6470960e4731416f6" translate="yes" xml:space="preserve">
          <source>This has the same interface as the original JsonSlurper written for version 1.8.0, but its implementation has completely changed. It is now up to 20x faster than before, and its speed competes and often substantially exceeds popular common JSON parsers circa Jan, 2014.</source>
          <target state="translated">这与原来为1.8.0版本编写的JsonSlurper接口相同,但它的实现已经完全改变。现在它的速度比以前快了20倍,它的速度可以和2014年1月左右流行的普通JSON解析器竞争,而且经常大幅超过。</target>
        </trans-unit>
        <trans-unit id="f01f9c203f4513ef8926ff9ee372b31db329b713" translate="yes" xml:space="preserve">
          <source>This hint handles all those cases by picking the generics from the first argument of the method (by default).</source>
          <target state="translated">这个提示通过从方法的第一个参数(默认情况下)选取属词来处理所有这些情况。</target>
        </trans-unit>
        <trans-unit id="8328da1e3c3000c040f7a4774ac735b142d97837" translate="yes" xml:space="preserve">
          <source>This holds a mapping from value key to value value to maximize laziness.</source>
          <target state="translated">这举行了从价值键到价值值的映射,以最大限度地提高懒惰。</target>
        </trans-unit>
        <trans-unit id="74974d1e6f40fe28cb6229fba49e41c77b4b9dfd" translate="yes" xml:space="preserve">
          <source>This implementation breaks the contract of &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/List.html#get(int)&quot;&gt;List.get&lt;/a&gt; as it a) possibly modifies the underlying list and b) does NOT throw an &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/IndexOutOfBoundsException.html&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; when &lt;code&gt;index &amp;lt; 0 || index &amp;gt;= size()&lt;/code&gt;.</source>
          <target state="translated">此实现破坏了&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/List.html#get(int)&quot;&gt;List.get&lt;/a&gt;的约定，因为a）可能会修改基础列表，并且b）当 &lt;code&gt;index &amp;lt; 0 || index &amp;gt;= size()&lt;/code&gt; 时，不会抛出&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/IndexOutOfBoundsException.html&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。索引&amp;gt; = size（）。</target>
        </trans-unit>
        <trans-unit id="b8e1fbe89d11c8857d6efca6ff572126bb4b9fb0" translate="yes" xml:space="preserve">
          <source>This implementation provides a verbosity flag switching log statements. The servlet init parameter name is:</source>
          <target state="translated">本实现提供了一个verbosity标志切换日志语句。servlet init参数名称为。</target>
        </trans-unit>
        <trans-unit id="bfe169c077ea389406a1a9f2f85518f31a03e1e3" translate="yes" xml:space="preserve">
          <source>This interface allows the user to provide a custom expression checker if the dis/allowed expression lists are not sufficient</source>
          <target state="translated">如果dis/allowed表达式列表不充分,该接口允许用户提供一个自定义表达式检查器。</target>
        </trans-unit>
        <trans-unit id="f685dd51bbeafd50fa968a283a1c649d74afa7b5" translate="yes" xml:space="preserve">
          <source>This interface allows the user to provide a custom statement checker if the dis/allowed statement lists are not sufficient</source>
          <target state="translated">如果dis/allowed语句列表不足,该接口允许用户提供一个自定义语句检查器。</target>
        </trans-unit>
        <trans-unit id="2337efc6043edb753db0bcb30b3f4690571b8928" translate="yes" xml:space="preserve">
          <source>This interface defines a complete generic visitor for a parse tree produced by &lt;a href=&quot;groovyparser&quot;&gt;GroovyParser&lt;/a&gt;.</source>
          <target state="translated">该接口为&lt;a href=&quot;groovyparser&quot;&gt;GroovyParser&lt;/a&gt;生成的解析树定义了完整的通用访问者。</target>
        </trans-unit>
        <trans-unit id="2900e3be61204d298b4a3fee9de9690a314c1fa7" translate="yes" xml:space="preserve">
          <source>This interface defines a high-level API for handling type checking errors. As a dynamic language and a platform for developing DSLs, the Groovy language provides a lot of means to supply custom bindings or methods that are not possible to find at compile time. However, it is still possible to help the compiler, for example by telling it what is the type of an unresolved property. For basic DSL type checking, implementing those methods would help the type checker and make it silent where it normally throws errors.</source>
          <target state="translated">这个接口定义了一个高级API,用于处理类型检查错误。作为一种动态语言和开发DSL的平台,Groovy语言提供了很多手段来提供在编译时无法找到的自定义绑定或方法。不过,还是可以帮助编译器,比如告诉编译器一个未解析的属性的类型是什么。对于基本的DSL类型检查来说,实现这些方法将帮助类型检查器,并使它在通常抛出错误的地方保持沉默。</target>
        </trans-unit>
        <trans-unit id="14a3094142b4fffa63ea1c44ae063fa652e1bd9e" translate="yes" xml:space="preserve">
          <source>This interface is for AST transformations which must be aware of the compilation unit where they are applied.</source>
          <target state="translated">这个接口用于AST转换,它必须知道它们被应用的编译单元。</target>
        </trans-unit>
        <trans-unit id="b19bc498138b8f77f8e42e14567db95fb471708c" translate="yes" xml:space="preserve">
          <source>This is JmxBuilder's factory builder class. It is the parent node to all other children nodes supported by JmxBuilder.</source>
          <target state="translated">这是JmxBuilder的工厂建造者类,是JmxBuilder支持的所有其他子节点的父节点。它是JmxBuilder支持的所有其他子节点的父节点。</target>
        </trans-unit>
        <trans-unit id="5f542101a83909bc55b807fe7fad6cb48b595713" translate="yes" xml:space="preserve">
          <source>This is a Token sub class to track line information</source>
          <target state="translated">这是一个跟踪线路信息的Token子类。</target>
        </trans-unit>
        <trans-unit id="b5b6cd0c90811ee4dbf92dd31e30b69e6a4b7932" translate="yes" xml:space="preserve">
          <source>This is a basic implementation of a map able to forget its values. This map uses internally a ConcurrentHashMap, thus should be safe for concurrency. hashcode and equals are used to find the entries and should thus be implemented properly for the keys. This map does not support null keys.</source>
          <target state="translated">这是一个能够忘记其值的地图的基本实现。这个地图在内部使用了ConcurrentHashMap,因此对于并发来说应该是安全的,hashcode和equals被用来查找条目,因此对于键来说应该是正确的实现。该地图不支持空键。</target>
        </trans-unit>
        <trans-unit id="ecd84853e48a3218ca7dae60fa14210067325fe4" translate="yes" xml:space="preserve">
          <source>This is a basic parser with no index overlay.</source>
          <target state="translated">这是一个没有索引覆盖的基本解析器。</target>
        </trans-unit>
        <trans-unit id="bd1aba50be39fcc34d283e005a86755e0b3badd7" translate="yes" xml:space="preserve">
          <source>This is a basic parser with no index overlay. It is wicked fast, but not as fast at the INDEX_OVERLAY. It should be on average the fastest known JSON parser on the JVM circa Jan 2014. But not as fast as INDEX_OVERLAY.</source>
          <target state="translated">这是一个没有索引覆盖的基本解析器。它的速度很邪恶,但在INDEX_OVERLAY上没有那么快。平均来说,它应该是2014年1月左右JVM上已知最快的JSON解析器。但没有INDEX_OVERLAY快。</target>
        </trans-unit>
        <trans-unit id="4d663199a467bd31d2d6cc978eef89dea6a3add1" translate="yes" xml:space="preserve">
          <source>This is a bit of plumbing which resumes collection of string constructor bodies, after an embedded expression has been parsed.</source>
          <target state="translated">这是在嵌入式表达式被解析后,恢复收集字符串构造体的一点管道。</target>
        </trans-unit>
        <trans-unit id="229cccdf96ec491181b6b4aefce4ce6c2b429a0f" translate="yes" xml:space="preserve">
          <source>This is a bit of plumbing which resumes collection of string constructor bodies, after an embedded expression has been parsed. Usage: new GroovyRecognizer(new GroovyLexer(in).plumb()).</source>
          <target state="translated">这是在解析完嵌入式表达式后,恢复收集字符串构造体的一点管道。用法:new GroovyRecognizer(new GroovyLexer(in).plumb())。</target>
        </trans-unit>
        <trans-unit id="0186d9b2589f2bdddecc55d72affdc0ae0321117" translate="yes" xml:space="preserve">
          <source>This is a bit of plumbing which resumes collection of string constructor bodies, after an embedded expression has been parsed. Usage: new JavaRecognizer(new JavaLexer(in).plumb()).</source>
          <target state="translated">这是一个在嵌入表达式被解析后,恢复字符串构造体收集的一点管道。用法:new JavaRecognizer(new JavaLexer(in).plumb())。</target>
        </trans-unit>
        <trans-unit id="8f11df9510d09a2eefc345dd606cc8bb630671ad" translate="yes" xml:space="preserve">
          <source>This is a generated class used internally during the writing of bytecode within the CallSiteWriter logic. This is not a class exposed to users, as is the case with almost all classes in the org.codehaus.groovy packages.</source>
          <target state="translated">这是一个在CallSiteWriter逻辑中编写字节码时在内部使用的生成类。这不是一个暴露给用户的类,就像org.codehaus.groovy包中的几乎所有类一样。</target>
        </trans-unit>
        <trans-unit id="8988c21207c9c0283d7bdfe9794fc76b8616da94" translate="yes" xml:space="preserve">
          <source>This is a helper class introduced in Groovy 2.1.0, which is used only by indy. This class is for internal use only.</source>
          <target state="translated">这是一个在Groovy 2.1.0中引入的帮助类,仅由indy使用。这个类只供内部使用。</target>
        </trans-unit>
        <trans-unit id="fd736de461897ac841a6a4d9f0a851a81005bbd5" translate="yes" xml:space="preserve">
          <source>This is a helper class, to provide a controlled entry point for the groovyc ant task forked mode.</source>
          <target state="translated">这是一个辅助类,为groovyc ant任务分叉模式提供一个可控的入口。</target>
        </trans-unit>
        <trans-unit id="1e04a2a9657e4a822125c0bfc5d51625bdcd91ab" translate="yes" xml:space="preserve">
          <source>This is a hook for subclasses to plugin a custom strategy for mapping names to explicit methods.</source>
          <target state="translated">这是一个钩子,供子类插入自定义策略,将名称映射到显式方法。</target>
        </trans-unit>
        <trans-unit id="6073183624d646ab13405c550c66ceae2d7e6073" translate="yes" xml:space="preserve">
          <source>This is a hook for subclasses to plugin a custom strategy for mapping names to factories.</source>
          <target state="translated">这是一个钩子,供子类插入自定义策略,将名称映射到工厂。</target>
        </trans-unit>
        <trans-unit id="3873541ad75fb8f477c82880ea8c90da25f7477f" translate="yes" xml:space="preserve">
          <source>This is a hook for subclasses to plugin a custom strategy for mapping names to property methods.</source>
          <target state="translated">这是一个钩子,供子类插入自定义策略,将名称映射到属性方法。</target>
        </trans-unit>
        <trans-unit id="851a6e18d0cb9ae66a159433966e5c40ef10ca00" translate="yes" xml:space="preserve">
          <source>This is a implementation of DL distance between two Object arrays instead of character streams.</source>
          <target state="translated">这是两个Object数组之间DL距离的实现,而不是字符流。</target>
        </trans-unit>
        <trans-unit id="e5dc74906a59f9ecb021663128a7faa33f6bff55" translate="yes" xml:space="preserve">
          <source>This is a implementation of DL distance between two Object arrays instead of character streams. The objects are compared using their equals method. No objects may be null. This implementation is based on Chas Emerick's implementation of Levenshtein Distance for jakarta commons.</source>
          <target state="translated">这是一个实现两个对象数组之间的DL距离,而不是字符流。使用对象的equals方法对对象进行比较。任何对象都不能为空。这个实现是基于Chas Emerick对jakarta commons的Levenshtein Distance的实现。</target>
        </trans-unit>
        <trans-unit id="3f63b7ad6a94acd9220b6ceb153faa4b94cff8d8" translate="yes" xml:space="preserve">
          <source>This is a slightly modified version of the Damerau Levenshtein distance algorithm.</source>
          <target state="translated">这是Damerau Levenshtein距离算法的略微修改版本。</target>
        </trans-unit>
        <trans-unit id="6379b9e33df64353e3c1267e96d9abfd788c6427" translate="yes" xml:space="preserve">
          <source>This is a slightly modified version of the Damerau Levenshtein distance algorithm. It has a additional test to see if a character has switched case, in the original algorithm this counts as a substitution. The &quot;cost&quot; for a substitution is given as 10 instead of 1 in this version, this enables transpositions and case modifications to have a lower cost than substitutions. Currently the lowercase versions of t_j and s_i isn't cached, its probable that some speed could be gained from this. This version is based on Chas Emerick's implementation of Levenshtein Distance for jakarta commons.</source>
          <target state="translated">这是Damerau Levenshtein距离算法的一个小修改版本。它有一个额外的测试,看看一个字符是否换了大小写,在原来的算法中,这算作一个替换。在这个版本中,替换的 &quot;成本 &quot;是10而不是1,这使得换位和大小写修改的成本比替换低。目前t_j和s_i的小写版本没有被缓存,这可能会带来一些速度。这个版本是基于Chas Emerick对jakarta commons的Levenshtein Distance的实现。</target>
        </trans-unit>
        <trans-unit id="1edb3c98dd64270eec01a19ffa8efd13aa8ca31a" translate="yes" xml:space="preserve">
          <source>This is a static access auto download enabler.</source>
          <target state="translated">这是一个静态访问自动下载的使能器。</target>
        </trans-unit>
        <trans-unit id="116aa4ab4439a80ee9ba7112e165f856489f00f2" translate="yes" xml:space="preserve">
          <source>This is a static access auto download enabler. It will set the 'autoDownload' value to the passed in arguments map if not already set. If 'autoDownload' is set the value will not be adjusted.</source>
          <target state="translated">这是一个静态访问的自动下载工具。如果还没有设置,它将把'autoDownload'的值设置为传入的参数映射。如果'autoDownload'的值被设置,则不会被调整。</target>
        </trans-unit>
        <trans-unit id="858274acd50bf067c3073a5802ebcb847cb11033" translate="yes" xml:space="preserve">
          <source>This is a static access kill-switch.</source>
          <target state="translated">这是一个静态访问杀伤开关。</target>
        </trans-unit>
        <trans-unit id="6fe1b6d5fdbc3093d68f9306c05bf649d9053221" translate="yes" xml:space="preserve">
          <source>This is a static access kill-switch. All of the static shortcut methods in this class will not work if this property is set to false. By default it is set to true.</source>
          <target state="translated">这是一个静态访问杀伤开关。如果该属性设置为false,则该类中的所有静态快捷方法将无法使用。默认情况下,它被设置为true。</target>
        </trans-unit>
        <trans-unit id="9354b1e014a107432bcac0ae43777acc06c0de53" translate="yes" xml:space="preserve">
          <source>This is a utility class used as a helper for JmxBuilder.</source>
          <target state="translated">这是一个用于帮助JmxBuilder的实用类。</target>
        </trans-unit>
        <trans-unit id="a5225ac2335eb47576067c0b8960cb72cb13bccd" translate="yes" xml:space="preserve">
          <source>This is also different than scripting.dev.java.net which used an initial lowercase.</source>
          <target state="translated">这也和scripting.dev.java.net不同,后者使用的是初始小写。</target>
        </trans-unit>
        <trans-unit id="579c6bcb0a618a267161c2207b075c96e7d5d24d" translate="yes" xml:space="preserve">
          <source>This is also different than scripting.dev.java.net which used an initial lowercase. But these are proper names and should be capitalized.</source>
          <target state="translated">这也和scripting.dev.java.net不同,后者使用的是首字母小写。但这些都是专有名词,应该大写。</target>
        </trans-unit>
        <trans-unit id="85d017a024d6049f47ed0da7428c2774554debb2" translate="yes" xml:space="preserve">
          <source>This is an AST Node that provides some sort of looping mechanism. Typically in the form of a block that will be executed repeatedly. DoWhileStatements, WhileStatements, and ForStatements are all examples of LoopingStatements.</source>
          <target state="translated">这是一个提供某种循环机制的AST节点。通常是以一个将被重复执行的块的形式。DoWhileStatements、WhileStatements和ForStatements都是LoopingStatements的例子。</target>
        </trans-unit>
        <trans-unit id="0c9815db791daee2a8e2b715b6bdfe0a35a3e307" translate="yes" xml:space="preserve">
          <source>This is an annotation on a class, currently just &lt;a href=&quot;asttransformation&quot;&gt;ASTTransformation&lt;/a&gt;. This provides information about how and when to apply the transformation, such as what phase it should be applied in. The allowed phase is a function of how the transformation is introduced into the compile process. If the transform is automatically added via a marker annotation only the SEMANTIC_ANALYSIS and latter phases are legal for the phase(). This is because the annotations are not inspected until after the classes are all resolved. Also, only annotation types present during the SEMANTIC_ANALYSIS phase will be handled. Transformations adding other annotations that are transformable will have those new annotations only considered in latter phases, and only if the type was present in the source unit during SEMANTIC_ANALYSIS.</source>
          <target state="translated">这是一个类的注释，当前仅是&lt;a href=&quot;asttransformation&quot;&gt;ASTTransformation&lt;/a&gt;。这提供了有关如何以及何时应用转换的信息，例如应在哪个阶段应用转换。允许的阶段取决于转换如何被引入编译过程。如果通过标记批注自动添加了转换，则只有SEMANTIC_ANALYSIS和后面的阶段才对phase（）合法。这是因为直到所有类都解决后才检查注释。另外，将仅处理SEMANTIC_ANALYSIS阶段存在的注释类型。添加了其他可转换注释的转换将仅在后面的阶段中考虑这些新注释，并且前提是在SEMANTIC_ANALYSIS期间源单元中存在该类型。</target>
        </trans-unit>
        <trans-unit id="11e12582da84504f1479b7b5bbe01a600457f89e" translate="yes" xml:space="preserve">
          <source>This is because the Value construct is a type of index overlay that merely tracks where the token is located in the buffer, and what if any thing we noted about it (like can be converted to a decimal number, etc.).  To mitigate memory leaks this class along with CharSequenceValue implement two constructs, namely, chop, and lazyChop.  A chop is when we convert backing buffer of a Value object into a smaller buffer. A lazyChop is when we do a chop but only when a get operation is called.  The lazyChop is performed on the tree that is touched by the JSONPath expression or its ilk.  The chop operation can be done during parsing or lazily by storing the values in this construct.</source>
          <target state="translated">这是因为Value构造是一种索引覆盖,它仅仅是跟踪token在缓冲区中的位置,以及如果我们注意到它的任何事情(比如可以转换为十进制数等)。为了减少内存泄漏,这个类和CharSequenceValue一起实现了两个构造,即chop,和lazyChop。chop是指我们将Value对象的backing buffer转换为一个较小的缓冲区。lazyChop是当我们做一个chop,但只在调用get操作时才做。lazyChop是在JSONPath表达式或其同类表达式所触及的树上进行的。切碎操作可以在解析过程中进行,也可以通过将值存储在这个构造中来进行懒惰操作。</target>
        </trans-unit>
        <trans-unit id="741dcdf92b314485a30d1f79b83cc4f348ec1d58" translate="yes" xml:space="preserve">
          <source>This is commonly used to simplify object creation, such as this example:</source>
          <target state="translated">这通常用于简化对象创建,如本例。</target>
        </trans-unit>
        <trans-unit id="1248b519078b17c04626ddc0fb70c6f2e9facdfe" translate="yes" xml:space="preserve">
          <source>This is especially useful when executing foreign scripts that you do not have control over. Inject this transformation into a script that you need to interrupt based on some custom criteria.</source>
          <target state="translated">这在执行您无法控制的外来脚本时特别有用。将此转换注入到需要根据一些自定义标准中断的脚本中。</target>
        </trans-unit>
        <trans-unit id="64f713a0f10d16561ee1c527588ce545628f9d79" translate="yes" xml:space="preserve">
          <source>This is especially useful when executing foreign scripts that you do not have control over. Inject this transformation into a script that you need to interrupt.</source>
          <target state="translated">这在执行您无法控制的外来脚本时特别有用。将此转换注入到需要中断的脚本中。</target>
        </trans-unit>
        <trans-unit id="5f5f8b6a917691ae26019a384a5b0e4890168174" translate="yes" xml:space="preserve">
          <source>This is especially useful when executing foreign scripts that you do not have control over. Inject this transformation into a script that you want to timeout after a specified amount of time.</source>
          <target state="translated">这在执行你无法控制的外来脚本时特别有用。将此转换注入到你想在指定时间后超时的脚本中。</target>
        </trans-unit>
        <trans-unit id="282c12052be9cf10b5ec3f4611f0fd964e9e4aa8" translate="yes" xml:space="preserve">
          <source>This is for internal use only.</source>
          <target state="translated">仅供内部使用。</target>
        </trans-unit>
        <trans-unit id="58697d7fd61dc831ec59911b870e50930ffb3220" translate="yes" xml:space="preserve">
          <source>This is for internal use only. When an argument method is null, we cannot determine its type, so we use this one as a wildcard.</source>
          <target state="translated">这个仅供内部使用。当一个参数方法为空时,我们无法确定它的类型,所以我们用这个作为通配符。</target>
        </trans-unit>
        <trans-unit id="4110ed8e2a3513345d548ed89e5744b457556f9f" translate="yes" xml:space="preserve">
          <source>This is helpful for tests that don't currently work but should work one day, when the tested functionality has been implemented.</source>
          <target state="translated">这对于那些目前没有工作,但总有一天会工作的测试是有帮助的,当测试的功能已经实现时。</target>
        </trans-unit>
        <trans-unit id="40f30890de5ca0bafe206b76653f0c2a1f3cc299" translate="yes" xml:space="preserve">
          <source>This is just a dummy value used because String annotations values can not be null.</source>
          <target state="translated">这只是一个虚值,因为String注解值不能为空。</target>
        </trans-unit>
        <trans-unit id="6be2a0c0559d3297ae4eb1f68ef079c6642f7daf" translate="yes" xml:space="preserve">
          <source>This is just a dummy value used because String annotations values can not be null. It will be replaced by the fully qualified class name of the annotated class.</source>
          <target state="translated">这只是一个虚值,因为String注解值不能为空。它将被注解类的完全限定的类名所取代。</target>
        </trans-unit>
        <trans-unit id="7cfc24f9ba4df725de185c873e645d95b8f9a980" translate="yes" xml:space="preserve">
          <source>This is mostly for debugging and testing.</source>
          <target state="translated">这主要是为了调试和测试。</target>
        </trans-unit>
        <trans-unit id="755a53945cc3fcceccdbfdf945d1dd8ce166c6d1" translate="yes" xml:space="preserve">
          <source>This is not 100% true for days. Days can actually be 23, 24 or 25 hours long (due to daylight saving adjustments.)</source>
          <target state="translated">对于日来说,这不是100%正确的。日子实际上可以是23、24或25小时(由于夏令时的调整)。</target>
        </trans-unit>
        <trans-unit id="e69572989e14bc32e4253df5a71968b90a55a7b4" translate="yes" xml:space="preserve">
          <source>This is similar to pop on a Stack where the first item in the list represents the top of the stack. Note: The behavior of this method changed in Groovy 2.5 to align with Java. If you need the old behavior use 'removeLast'.</source>
          <target state="translated">这类似于堆栈上的pop方法,列表中的第一个项目代表堆栈的顶部。注意:这个方法的行为在Groovy 2.5中发生了变化,与Java保持一致。如果你需要旧的行为,请使用'removeLast'。</target>
        </trans-unit>
        <trans-unit id="2541054c8b1af0657d417013a4c3cc09b16432fc" translate="yes" xml:space="preserve">
          <source>This is similar to push on a Stack where the first item in the list represents the top of the stack. Note: The behavior of this method changed in Groovy 2.5 to align with Java. If you need the old behavior use 'add'.</source>
          <target state="translated">这类似于Stack上的push,列表中的第一个项目代表堆栈的顶部。注意:这个方法的行为在Groovy 2.5中发生了变化,与Java保持一致。如果你需要旧的行为,请使用'add'。</target>
        </trans-unit>
        <trans-unit id="aef33e4880a31dfb6572ddc1eafa9904f03c5153" translate="yes" xml:space="preserve">
          <source>This is so we don't have to reorder the stack when we call this method.</source>
          <target state="translated">这样我们在调用这个方法的时候就不用重新排序堆栈了。</target>
        </trans-unit>
        <trans-unit id="e6d75685c8a50a89d652d071d7093c3bf15cd602" translate="yes" xml:space="preserve">
          <source>This is so we don't have to reorder the stack when we call this method. At some point a better name might be in order.</source>
          <target state="translated">这是为了让我们在调用这个方法时,不必对栈进行重新排序。在某些时候,可能需要一个更好的名字。</target>
        </trans-unit>
        <trans-unit id="f165cfd45f1ba553776e75f2e2f8cd2ea732f465" translate="yes" xml:space="preserve">
          <source>This is the base class for classes responsible for creating modules using properties.</source>
          <target state="translated">这是负责使用属性创建模块的类的基类。</target>
        </trans-unit>
        <trans-unit id="afb852c75331161be3de5047f08fe81e729e8211" translate="yes" xml:space="preserve">
          <source>This is the complement the behavior of the decapitalize(string) method.</source>
          <target state="translated">这是对decapitalize(string)方法行为的补充。</target>
        </trans-unit>
        <trans-unit id="80b2bed606ff187cd7718223d7b85bc65c304789" translate="yes" xml:space="preserve">
          <source>This is the complement the behavior of the decapitalize(string) method. We handle names that begin with an initial lowerCase followed by upperCase with special JavaBean behavior (which is to make no change). See GROOVY-3211.</source>
          <target state="translated">这是对 decapitalize(string)方法行为的补充。我们用特殊的JavaBean行为(即不做任何改变)来处理以小写字母开头的名字,然后是大写字母。参见GROOVY-3211。</target>
        </trans-unit>
        <trans-unit id="aa3d520cd1c348add237bd7a66f5ecae3276e75e" translate="yes" xml:space="preserve">
          <source>This is the factory for node JmxBuilder.connectorClient. A call to this node returns an instance of the JMXConnector interface.</source>
          <target state="translated">这是 JmxBuilder.connectorClient 节点的工厂。对该节点的调用会返回一个 JMXConnector 接口的实例。</target>
        </trans-unit>
        <trans-unit id="1940febb7e000c374518f8af3b2bab8b6e867ba7" translate="yes" xml:space="preserve">
          <source>This is the grammar for what can follow a dot: x.a, x.</source>
          <target state="translated">这是点后面可以跟的语法:x.a,x。</target>
        </trans-unit>
        <trans-unit id="40f014c6ef17ec9a663f43144dcaa01def5b2977" translate="yes" xml:space="preserve">
          <source>This is the grammar for what can follow a dot: x.a, x.@a, x.&amp;amp;a, x.'a', etc. Note: &lt;code&gt;typeArguments&lt;/code&gt; is handled by the caller of &lt;code&gt;namePart&lt;/code&gt;.</source>
          <target state="translated">这是点之后的语法：xa，x。@ a，x。＆a，x.'a'等。注意： &lt;code&gt;typeArguments&lt;/code&gt; 由 &lt;code&gt;namePart&lt;/code&gt; 的调用者处理。</target>
        </trans-unit>
        <trans-unit id="e3383554d710d086a6eaaccc8bcae06fb7d68886" translate="yes" xml:space="preserve">
          <source>This is the implemented method for NotificationListener.</source>
          <target state="translated">这是NotificationListener的实现方法。</target>
        </trans-unit>
        <trans-unit id="443ffb1b205dda6b43691a31bf4efab8981aa292" translate="yes" xml:space="preserve">
          <source>This is the implemented method for NotificationListener. It is called by an event emitter to dispatch JMX events to listeners. Here it handles internal JmxBuilder events.</source>
          <target state="translated">这是NotificationListener的实现方法。它被事件发射器调用,以将JMX事件派遣到监听器。这里它处理内部的JmxBuilder事件。</target>
        </trans-unit>
        <trans-unit id="8507fa3ee221e6d15aa495ec0771ccde8a6a13ad" translate="yes" xml:space="preserve">
          <source>This is the main method responsible for writing a tag and its attributes.</source>
          <target state="translated">这是负责编写标签及其属性的主要方法。</target>
        </trans-unit>
        <trans-unit id="8e6641635e8b64ec4febd6d638bc3e9143705eca" translate="yes" xml:space="preserve">
          <source>This is the main method responsible for writing a tag and its attributes. The arguments may be:</source>
          <target state="translated">这是负责编写标签及其属性的主要方法。参数可以是:</target>
        </trans-unit>
        <trans-unit id="bc39540baf6302d792409499cb068b434a441c03" translate="yes" xml:space="preserve">
          <source>This is the management interface for JmxEventEmitter. This MBean is used internally by JmxBuilder to broadcast events to registered listeners of the underlying MBeanServer.</source>
          <target state="translated">这是JmxEventEmitter的管理接口。这个MBean被JmxBuilder内部用于向底层MBeanServer的注册听众广播事件。</target>
        </trans-unit>
        <trans-unit id="a5b95a30505f17692ef2b43986549d96c8c4624a" translate="yes" xml:space="preserve">
          <source>This is the original slurper included in case someone relies on its exact behavior. JSON slurper which parses text or reader content into a data structure of lists and maps.</source>
          <target state="translated">这是原始的Slurper,以防止有人依赖它的确切行为。JSON slurper将文本或读者内容解析为列表和地图的数据结构。</target>
        </trans-unit>
        <trans-unit id="99a8ced6206d14a027d70a5e32a450ce537c155b" translate="yes" xml:space="preserve">
          <source>This is the parser interface that backs the new JsonSlurper. It was derived from the Boon JSON parser.</source>
          <target state="translated">这是支持新的JsonSlurper的解析器接口。它是由Boon JSON解析器衍生出来的。</target>
        </trans-unit>
        <trans-unit id="a3d06e9412c890cb691176655a805bf3748ea2d9" translate="yes" xml:space="preserve">
          <source>This is the server connector factory used for node JmxBuilder.connectorServer(). A call to this node returns an instance of JMXConnectorServer interface (rmi default).</source>
          <target state="translated">这是用于 JmxBuilder.connectorServer()节点的服务器连接器工厂。对该节点的调用会返回一个 JMXConnectorServer 接口的实例(rmi 默认)。</target>
        </trans-unit>
        <trans-unit id="230e13efb9db1565670b6fea571db7753bc5e0ed" translate="yes" xml:space="preserve">
          <source>This is the standard Groovy module factory. This factory will build a module using the &lt;a href=&quot;metainfextensionmodule&quot;&gt;MetaInfExtensionModule&lt;/a&gt; by default, unless a key named &quot;moduleFactory&quot; is found in the properties file. If this is the case, then a new factory is instantiated and used instead of this factory.</source>
          <target state="translated">这是标准的Groovy模块工厂。除非在属性文件中找到名为&amp;ldquo; moduleFactory&amp;rdquo;的键，否则该工厂将默认使用&lt;a href=&quot;metainfextensionmodule&quot;&gt;MetaInfExtensionModule&lt;/a&gt;构建模块。如果是这种情况，那么将实例化并使用一个新工厂代替该工厂。</target>
        </trans-unit>
        <trans-unit id="a7ec506a9828d694bfe5804799dc8c732a9b5a54" translate="yes" xml:space="preserve">
          <source>This is used to defer content creation until the point when it is streamed to the output destination. Oftentimes, content will be defined but not necessarily created (as is may be the case with a Closure definition.) In that case, the output is then 'deferred' to the point when it is serialized to the writer. This class may be used whenever an object should be responsible for creating its own textual representation, but creating the entire output as a single String would be inefficient (such as outputting a multi-gigabyte XML document.)</source>
          <target state="translated">这用于推迟内容的创建,直到将其流式化到输出目的地。通常情况下,内容会被定义,但不一定会被创建(就像Closure定义的情况一样。)在这种情况下,输出会被 &quot;推迟 &quot;到它被序列化到写入器的时候。每当一个对象应该负责创建它自己的文本表示时,这个类就可以使用,但将整个输出创建为一个单一的String是低效的(比如输出一个多GB的XML文档)。</target>
        </trans-unit>
        <trans-unit id="f8e14e7d5baf0cfd30f91810036e80282c090c67" translate="yes" xml:space="preserve">
          <source>This is useful to temporary change the building context to another builder without the need for a contrived setup. It will also take care of restoring the previous proxyBuilder when the execution finishes, even if an exception was thrown from inside the closure.</source>
          <target state="translated">这对于临时改变构建上下文到另一个构建器是很有用的,不需要人为的设置。当执行结束时,它还会负责恢复之前的proxyBuilder,即使在闭包中产生了异常。</target>
        </trans-unit>
        <trans-unit id="ad15a34847d2c1a8ad922f0d89041ba75723b49e" translate="yes" xml:space="preserve">
          <source>This is useful to temporary change the building context to another builder without the need for a contrived setup. It will also take care of restoring the previous proxyBuilder when the execution finishes, even if an exception was thrown from inside the closure. Additionally it will use the closure's result as the value for the node identified by 'name' and assign any attributes that might have been set.</source>
          <target state="translated">这对于临时改变构建上下文到另一个构建器是很有用的,不需要人为的设置。当执行结束时,它还会负责恢复之前的proxyBuilder,即使是在闭包中产生了异常。此外,它将使用闭包的结果作为'name'标识的节点的值,并分配任何可能已经设置的属性。</target>
        </trans-unit>
        <trans-unit id="c37a541753d2b221857f2d671ab7f729da865698" translate="yes" xml:space="preserve">
          <source>This is useful to temporary change the building context to another builder without the need for a contrived setup. It will also take care of restoring the previous proxyBuilder when the execution finishes, even if an exception was thrown from inside the closure. Additionally it will use the closure's result as the value for the node identified by 'name'.</source>
          <target state="translated">这对于临时改变构建上下文到另一个构建器是很有用的,不需要人为的设置。当执行结束时,它还会负责恢复之前的proxyBuilder,即使是在闭包中产生了异常。此外,它将使用闭包的结果作为'name'标识的节点的值。</target>
        </trans-unit>
        <trans-unit id="456d789e81e107b1750587cc65f969df3b091526" translate="yes" xml:space="preserve">
          <source>This local transform adds a logging ability to your program using Apache Commons logging. Every method call on a unbound variable named</source>
          <target state="translated">这个本地转换使用Apache Commons日志记录为你的程序增加了一个日志记录功能。每个方法调用一个名为</target>
        </trans-unit>
        <trans-unit id="ccdbe2f2abb77f14d2958b7203c74bc3c3238f26" translate="yes" xml:space="preserve">
          <source>This local transform adds a logging ability to your program using Log4j logging. Every method call on a unbound variable named</source>
          <target state="translated">这个本地转换使用Log4j日志为你的程序增加了一个日志功能。每个方法调用一个名为</target>
        </trans-unit>
        <trans-unit id="7ca89366d56f13b0ae77d15760011e4c8ce3c9d6" translate="yes" xml:space="preserve">
          <source>This local transform adds a logging ability to your program using Log4j2 logging. Every method call on a unbound variable named</source>
          <target state="translated">这个本地转换使用Log4j2日志记录为你的程序增加了一个日志记录功能。每个方法调用一个名为</target>
        </trans-unit>
        <trans-unit id="5c21e31e0e213d1b747f0881d81cf15af0983e63" translate="yes" xml:space="preserve">
          <source>This local transform adds a logging ability to your program using LogBack logging. Every method call on a unbound variable named</source>
          <target state="translated">这个本地转换使用 LogBack 日志为你的程序增加了一个日志记录功能。每一个方法调用一个名为</target>
        </trans-unit>
        <trans-unit id="f0a3244e657380e150930ad3c42321efd1a93ab0" translate="yes" xml:space="preserve">
          <source>This local transform adds a logging ability to your program using java.util.logging. Every method call on a unbound variable named</source>
          <target state="translated">这个本地转换使用java.util.logging为你的程序增加了一个日志记录功能。每一个方法调用一个名为</target>
        </trans-unit>
        <trans-unit id="9f16b0ae746e9cea59cf9a1537bd1d3eab7d8506" translate="yes" xml:space="preserve">
          <source>This map is for object serialization mainly. The idea is the final conversion of the Value objects are delayed until the last possible moment, i.e., just before injected into a bean.</source>
          <target state="translated">这个映射主要用于对象序列化。其想法是将Value对象的最终转换延迟到最后可能的时刻,即在注入Bean之前。</target>
        </trans-unit>
        <trans-unit id="133261c522611d55bc1ac660860148968370dbb5" translate="yes" xml:space="preserve">
          <source>This maps only builds once you ask for a key for the first time. It is designed to not incur the overhead of creating a map unless needed.</source>
          <target state="translated">这个地图只有在你第一次要钥匙的时候才会建立。它的设计是为了除非需要,否则不会产生创建地图的开销。</target>
        </trans-unit>
        <trans-unit id="8a8f2d66e087d02e8f596d67c48d249055c88c63" translate="yes" xml:space="preserve">
          <source>This may be true even for values not contained in the range. Example: from = 1.5, to = 3, next() increments by 1 containsWithinBounds(2) == true contains(2) == false</source>
          <target state="translated">即使对于不包含在范围内的值,这也可能是真的。例如:from=1.5,to=3,next()以1为单位递增 containsWithinBounds(2)==true contains(2)==false。</target>
        </trans-unit>
        <trans-unit id="75f0bf4a66a79592bf20cb9599e2cee6c0cf02d5" translate="yes" xml:space="preserve">
          <source>This may not be available in future groovy.util.CliBuilder versions.</source>
          <target state="translated">在未来的groovy.util.CliBuilder版本中可能无法使用。</target>
        </trans-unit>
        <trans-unit id="0bf475abb2d654e508f4a3ea6b60068d3049398d" translate="yes" xml:space="preserve">
          <source>This may not be available in future groovy.util.CliBuilder versions. Use groovy.cli.commons.CliBuilder if you need this feature.</source>
          <target state="translated">在未来的groovy.util.CliBuilder版本中,这个功能可能无法使用。如果你需要这个功能,请使用groovy.cli.commons.CliBuilder。</target>
        </trans-unit>
        <trans-unit id="29237a4ce5bb61ce2deb69d6d749c4af551bfff9" translate="yes" xml:space="preserve">
          <source>This means that &lt;code&gt;executeBatch()&lt;/code&gt; will be called automatically after the &lt;code&gt;withBatch&lt;/code&gt; closure has finished but may be called explicitly if desired as well for more fine-grained partitioning of the batch.</source>
          <target state="translated">这意味着， &lt;code&gt;withBatch&lt;/code&gt; 闭包完成后，将自动调用 &lt;code&gt;executeBatch()&lt;/code&gt; ,但如果需要，还可以显式调用executeBatch（），以进行更细粒度的批处理分区。</target>
        </trans-unit>
        <trans-unit id="8281417fefc279cbb9a25f17712e4ba86882d29f" translate="yes" xml:space="preserve">
          <source>This method adds a SyntaxException to the error collector.</source>
          <target state="translated">本方法将一个SyntaxException添加到错误收集器中。</target>
        </trans-unit>
        <trans-unit id="0973d91b058fb6569284667e2f673bb040878f3c" translate="yes" xml:space="preserve">
          <source>This method adds a SyntaxException to the error collector. The exception should specify the line and column number of the error. This method should be reserved for real errors in the syntax of the SourceUnit. If your error is not in syntax, and is a semantic error, or more general error, then use addException or use the error collector directly by retrieving it with getErrorCollector().</source>
          <target state="translated">本方法向错误收集器添加一个SyntaxException。这个异常应该指定错误的行号和列号。这个方法应该保留给SourceUnit语法中的真正错误。如果你的错误不在语法中,而是语义错误,或者更一般的错误,那么使用addException或者直接使用getErrorCollector()检索错误收集器。</target>
        </trans-unit>
        <trans-unit id="d41389a9f429a0e723f818e52d3c8405048d8434" translate="yes" xml:space="preserve">
          <source>This method adds an exception to the error collector.</source>
          <target state="translated">本方法向错误收集器添加一个异常。</target>
        </trans-unit>
        <trans-unit id="ad248a00756ca0b2876764f3cadf2058210b535e" translate="yes" xml:space="preserve">
          <source>This method adds an exception to the error collector. The Exception most likely has no line number attached to it. For this reason you should use this method sparingly. Prefer using addError for syntax errors or add an error to the &lt;a href=&quot;errorcollector&quot;&gt;ErrorCollector&lt;/a&gt; directly by retrieving it with getErrorCollector().</source>
          <target state="translated">此方法将异常添加到错误收集器。异常很可能没有附加行号。因此，您应谨慎使用此方法。首选使用addError处理语法错误，或者通过使用getErrorCollector（）检索错误将错误直接添加到&lt;a href=&quot;errorcollector&quot;&gt;ErrorCollector&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="26b9b9919b102efb75bc0c62d72758785b908443" translate="yes" xml:space="preserve">
          <source>This method builds a single ModelMBeanAttribute info from a given meta data map object.</source>
          <target state="translated">这个方法从给定的元数据映射对象中建立一个单一的ModelMBeanAttribute信息。</target>
        </trans-unit>
        <trans-unit id="7ef8522c2c1425ca76a2dd9e7f7424d35413e383" translate="yes" xml:space="preserve">
          <source>This method calls the JsonLexer to parser the output of the builder, so this may not be an optimal method to call, and should be used mainly for debugging purpose for a human-readable output of the JSON content.</source>
          <target state="translated">这个方法调用JsonLexer来解析构建器的输出,所以这个方法可能不是一个最佳的调用方法,应该主要用于调试目的,以获得人类可读的JSON内容输出。</target>
        </trans-unit>
        <trans-unit id="573fa6ce3c9bb7134c818285958a90ae1c94d15a" translate="yes" xml:space="preserve">
          <source>This method can be used to ensure that no threaded created by a reference manager will be active.</source>
          <target state="translated">这个方法可以用来确保引用管理器创建的线程不会被激活。</target>
        </trans-unit>
        <trans-unit id="1267ce3e9e0625435626c7617e6d61f20f27e4e8" translate="yes" xml:space="preserve">
          <source>This method can be used to ensure that no threaded created by a reference manager will be active. This is useful if the Groovy runtime itself is loaded through a class loader which should be disposed off. Without calling this method and if a threaded reference manager is active the class loader cannot be unloaded! Per default no threaded manager will be used.</source>
          <target state="translated">这个方法可以用来确保引用管理器创建的线程不会被激活。如果Groovy运行时本身是通过一个类加载器加载的,而这个类加载器应该被处理掉,那么这个方法就很有用。如果不调用这个方法,并且如果一个线程引用管理器是活动的,那么类加载器就不能被卸载!如果不调用这个方法,那么线程引用管理器就不能被加载。默认情况下,不使用线程管理器。</target>
        </trans-unit>
        <trans-unit id="736cd8a3422bc2feffa8beea26a3ea358d3a8479" translate="yes" xml:space="preserve">
          <source>This method can return &lt;code&gt;null&lt;/code&gt; if the &lt;code&gt;Class&lt;/code&gt; is no longer reachable through any strong or soft references. A non-null return value indicates that this &lt;code&gt;ClassInfo&lt;/code&gt; is valid.</source>
          <target state="translated">如果无法通过任何强引用或软引用访问 &lt;code&gt;Class&lt;/code&gt; ,则此方法可以返回 &lt;code&gt;null&lt;/code&gt; 。非空返回值表示此 &lt;code&gt;ClassInfo&lt;/code&gt; 有效。</target>
        </trans-unit>
        <trans-unit id="1756cd8d9775e9730b98c4c1627c9b5e632ec24f" translate="yes" xml:space="preserve">
          <source>This method does not check the elements to verify they contain non-null reference values.</source>
          <target state="translated">本方法不检查元素是否包含非空引用值。</target>
        </trans-unit>
        <trans-unit id="465f96fa4d41f78b2ce5fda3f4227272109aa863" translate="yes" xml:space="preserve">
          <source>This method doesn't do a full validation of the resulting QName. In particular, it doesn't check that the resulting namespace URI is a legal URI (per RFC 2396 and RFC 2732), nor that the resulting local part is a legal NCName per the XML Namespaces specification.</source>
          <target state="translated">这个方法并不对产生的QName进行全面验证。特别是,它不会检查产生的命名空间URI是否是合法的URI(根据RFC 2396和RFC 2732),也不会检查产生的本地部分是否是XML命名空间规范中的合法NCName。</target>
        </trans-unit>
        <trans-unit id="52e513008c99e7d305fccff13849c1a1c80774aa" translate="yes" xml:space="preserve">
          <source>This method exists to be binary compatible with 1.7 - 1.8.6 compiled code.</source>
          <target state="translated">这个方法的存在是为了与1.7-1.8.6的编译代码二进制兼容。</target>
        </trans-unit>
        <trans-unit id="c641e7c52a070377f45e131e44d063d090fa6d00" translate="yes" xml:space="preserve">
          <source>This method extracts ModelMBeanConstructorInfo from provided meta map.</source>
          <target state="translated">本方法从提供的元映射中提取ModelMBeanConstructorInfo。</target>
        </trans-unit>
        <trans-unit id="34c2983f225d2e36614f43dbb936a7baf6ddf732" translate="yes" xml:space="preserve">
          <source>This method extracts ModelMBeanConstructorInfo from provided meta map. It also iterates over any parameters and builds the necessary MBeanParameterInfo array.</source>
          <target state="translated">本方法从提供的元映射中提取ModelMBeanConstructorInfo。它也会遍历任何参数并建立必要的MBeanParameterInfo数组。</target>
        </trans-unit>
        <trans-unit id="150789d2ce17bb14a2771276abea7c787a906d8f" translate="yes" xml:space="preserve">
          <source>This method extracts an array of MBeanConstructorInfo from a list of meta maps.</source>
          <target state="translated">本方法从元地图列表中提取MBeanConstructorInfo数组。</target>
        </trans-unit>
        <trans-unit id="60a3e8f2070dce89ae81b802d499b2bd30f90563" translate="yes" xml:space="preserve">
          <source>This method extracts an array of MBeanOperationInfo from a list of meta maps.</source>
          <target state="translated">本方法从元地图列表中提取MBeanOperationInfo数组。</target>
        </trans-unit>
        <trans-unit id="263fa2d4242a10d1bba7914ee9c3b6eaba971c49" translate="yes" xml:space="preserve">
          <source>This method is &quot;safe&quot; in that it will always return a value and never throw an exception</source>
          <target state="translated">这个方法是 &quot;安全的&quot;,因为它总是会返回一个值,而且不会产生异常。</target>
        </trans-unit>
        <trans-unit id="6f930ab10785ce3649f57bd225433f23ebd52975" translate="yes" xml:space="preserve">
          <source>This method is a default implementation for the invoke method given in InvocationHandler.</source>
          <target state="translated">该方法是InvocationHandler中给出的invoke方法的默认实现。</target>
        </trans-unit>
        <trans-unit id="181a7ec346ddcc5f94d1cf5c7bd4f8177dda29ec" translate="yes" xml:space="preserve">
          <source>This method is a default implementation for the invoke method given in InvocationHandler. Any call to a method with a declaring class that is not Object, excluding toString() and default methods is redirected to invokeCustom.</source>
          <target state="translated">该方法是InvocationHandler中给出的 invoke方法的默认实现。任何对声明类不是Object的方法的调用,不包括toString()和默认方法,都会被重定向到invokeCustom。</target>
        </trans-unit>
        <trans-unit id="0243bed2cf01409831d3e3bb5e0becbccc0e7f22" translate="yes" xml:space="preserve">
          <source>This method is called by he handle to realize the bean constructor with property map.</source>
          <target state="translated">这个方法被他的句柄调用,实现带有属性映射的Bean构造函数。</target>
        </trans-unit>
        <trans-unit id="32f82b3d67ea451eb2c3571e5b0255127a98cff1" translate="yes" xml:space="preserve">
          <source>This method is called by the ++ operator for enums.</source>
          <target state="translated">本方法由枚举的++运算符调用。</target>
        </trans-unit>
        <trans-unit id="1c4289e3c70251c89708316752c7fc742b1a3b57" translate="yes" xml:space="preserve">
          <source>This method is called by the ++ operator for enums. It will invoke Groovy's default next behaviour for enums do not have their own next method.</source>
          <target state="translated">这个方法被枚举的++操作符所调用,对于没有自己的next方法的枚举,它将调用Groovy的默认next行为。对于没有自己的next方法的枚举,它将调用Groovy的默认next行为。</target>
        </trans-unit>
        <trans-unit id="457141bbf0ee6f1da111f0f8db21015e1177879a" translate="yes" xml:space="preserve">
          <source>This method is called by the -- operator for enums.</source>
          <target state="translated">本方法由枚举的--操作符调用。</target>
        </trans-unit>
        <trans-unit id="80cf9ab5395bfa1c37797650a89d31d82b67f5fb" translate="yes" xml:space="preserve">
          <source>This method is called by the -- operator for enums. It will invoke Groovy's default previous behaviour for enums that do not have their own previous method.</source>
          <target state="translated">这个方法被枚举的--操作符所调用,它将调用Groovy对没有自己的先前方法的默认先前行为。它将调用Groovy对没有自己先前方法的枚举的默认先前行为。</target>
        </trans-unit>
        <trans-unit id="1d7f17602988167c7174cc4303d3eb837ccaa4f4" translate="yes" xml:space="preserve">
          <source>This method is called by the handle to realize the bean constructor with property map.</source>
          <target state="translated">该方法由句柄调用,实现带有属性映射的bean构造函数。</target>
        </trans-unit>
        <trans-unit id="3250ef3629af744acf4f1c9198cc633e9a922e7c" translate="yes" xml:space="preserve">
          <source>This method is called by the type checker before throwing an &quot;ambiguous method&quot; error, giving the chance to the extension to select the method properly.</source>
          <target state="translated">该方法在抛出 &quot;模棱两可的方法 &quot;错误之前被类型检查器调用,给扩展提供了正确选择方法的机会。</target>
        </trans-unit>
        <trans-unit id="bf23fd2465394a74d715d408a8f25c8bce28f2b6" translate="yes" xml:space="preserve">
          <source>This method is called by the type checker before throwing an &quot;ambiguous method&quot; error, giving the chance to the extension to select the method properly. This means that when this method is called, the &quot;nodes&quot; parameter contains at least two methods. If the returned list still contains at least two methods, then the type checker will throw an ambiguous method call error. If the returned method contains 1 element, then the type checker will not throw any error. It is invalid to return an empty list.</source>
          <target state="translated">在抛出 &quot;模棱两可的方法 &quot;错误之前,类型检查器会调用这个方法,给扩展提供正确选择方法的机会。这意味着当这个方法被调用时,&quot;节点 &quot;参数至少包含两个方法。如果返回的列表仍然包含至少两个方法,那么类型检查器将抛出一个模糊方法调用错误。如果返回的方法包含1个元素,那么类型检查器将不会抛出任何错误。返回一个空列表是无效的。</target>
        </trans-unit>
        <trans-unit id="5bd058a5f1dad9fd10cd41da813b584b34292dcf" translate="yes" xml:space="preserve">
          <source>This method is called by the type checker when a method call cannot be resolved.</source>
          <target state="translated">当一个方法调用不能被解析时,类型检查器会调用这个方法。</target>
        </trans-unit>
        <trans-unit id="d1635a0a9cf4ddc4f991b78c462cd28f64e95f41" translate="yes" xml:space="preserve">
          <source>This method is called by the type checker when a method call cannot be resolved. Extensions may override this method to handle missing methods and prevent the type checker from throwing an error.</source>
          <target state="translated">当一个方法调用不能被解析时,类型检查器会调用这个方法。扩展可以重写这个方法来处理缺失的方法,防止类型检查器抛出错误。</target>
        </trans-unit>
        <trans-unit id="5d562c165b33158604a8d7b6404c28720d2074f3" translate="yes" xml:space="preserve">
          <source>This method is called by the type checker when a property expression cannot be resolved (for example, when a property doesn't exist).</source>
          <target state="translated">当一个属性表达式不能被解析时(例如,当一个属性不存在时),类型检查器会调用这个方法。</target>
        </trans-unit>
        <trans-unit id="132aa2a69d68d1893ec79f63a47c8d6c72a91536" translate="yes" xml:space="preserve">
          <source>This method is called by the type checker when a property expression cannot be resolved (for example, when a property doesn't exist). It gives the extension a chance to resolve it.</source>
          <target state="translated">当一个属性表达式不能被解析时(例如,当一个属性不存在时),类型检查器会调用这个方法。它让扩展有机会解析它。</target>
        </trans-unit>
        <trans-unit id="af1e5a5ee4210f5472ccdfef7a053239430f1f37" translate="yes" xml:space="preserve">
          <source>This method is called by the type checker when a variable expression cannot be resolved.</source>
          <target state="translated">当一个变量表达式不能被解析时,类型检查器会调用这个方法。</target>
        </trans-unit>
        <trans-unit id="76c7e2b17c02ed11975ad5a1246ebf8e0384df5b" translate="yes" xml:space="preserve">
          <source>This method is called by the type checker when a variable expression cannot be resolved. It gives the extension a chance to resolve it for the type checker.</source>
          <target state="translated">当一个变量表达式不能被解析时,类型检查器会调用这个方法。它让扩展有机会为类型检查器解析它。</target>
        </trans-unit>
        <trans-unit id="24c509ff50700509e7072e5bf1d5cfe4ccd9c387" translate="yes" xml:space="preserve">
          <source>This method is called by the type checker when an assignment is not allowed by the type checker.</source>
          <target state="translated">当一个赋值不被类型检查器允许时,类型检查器会调用这个方法。</target>
        </trans-unit>
        <trans-unit id="788e0b6b33909d27195a8757233c0e6432f5e5eb" translate="yes" xml:space="preserve">
          <source>This method is called by the type checker when an assignment is not allowed by the type checker. Extensions may override this method to allow such assignments where the type checker normally disallows them.</source>
          <target state="translated">当一个赋值不被类型检查器允许时,类型检查器会调用这个方法。扩展可以重写这个方法,允许类型检查器通常不允许的这种赋值。</target>
        </trans-unit>
        <trans-unit id="dae2966d00451172c913ae2ad39d7fd262e4b659" translate="yes" xml:space="preserve">
          <source>This method is called by the type checker when an attribute expression cannot be resolved (for example, when an attribute doesn't exist).</source>
          <target state="translated">当一个属性表达式不能被解析时(例如,当一个属性不存在时),类型检查器会调用这个方法。</target>
        </trans-unit>
        <trans-unit id="f407dcbe206c19d0fc48753b7163e649e8b6df6d" translate="yes" xml:space="preserve">
          <source>This method is called by the type checker when an attribute expression cannot be resolved (for example, when an attribute doesn't exist). It gives the extension a chance to resolve it.</source>
          <target state="translated">当一个属性表达式不能被解析时(例如,当一个属性不存在时),类型检查器会调用这个方法。它让扩展有机会解析它。</target>
        </trans-unit>
        <trans-unit id="f24dfabfb34102b6f318752ab09222b7e3d270a2" translate="yes" xml:space="preserve">
          <source>This method is called for all Methods not defined on Object.</source>
          <target state="translated">此方法被调用于所有未定义在Object上的方法。</target>
        </trans-unit>
        <trans-unit id="c123aa6bd463d76f74528853afb07e35dfbd4af8" translate="yes" xml:space="preserve">
          <source>This method is called for all Methods not defined on Object. The delegate should be called here.</source>
          <target state="translated">所有未在Object上定义的Methods都要调用这个方法。委托人应该在这里被调用。</target>
        </trans-unit>
        <trans-unit id="e263d0484bccb2058d38f8bf9eacd404f003eccc" translate="yes" xml:space="preserve">
          <source>This method is called once the template engine is initialized, providing the resolver with the template engine configuration and its template class loader.</source>
          <target state="translated">一旦模板引擎被初始化,就会调用该方法,向解析器提供模板引擎配置及其模板类加载器。</target>
        </trans-unit>
        <trans-unit id="0d82b61e044bfa56fbd2265af61cf2acecdd51e0" translate="yes" xml:space="preserve">
          <source>This method is called when an exception occurs while invoking this method.</source>
          <target state="translated">当调用本方法时发生异常时,本方法被调用。</target>
        </trans-unit>
        <trans-unit id="3383d8f9c80df52829fdca412aee2ffee5f93888" translate="yes" xml:space="preserve">
          <source>This method is for convenience.</source>
          <target state="translated">这种方法是为了方便。</target>
        </trans-unit>
        <trans-unit id="9242bd1cd2be2a765050fb4ef347893057fa4da1" translate="yes" xml:space="preserve">
          <source>This method is for convenience. It allows to get around the need for defining dump ctors in subclasses. See unit tests for details.</source>
          <target state="translated">这个方法是为了方便。它允许避开在子类中定义dump ctors的需要。详情请看单元测试。</target>
        </trans-unit>
        <trans-unit id="c7d7725943eccf3c92e66a0d48dd502528f6b703" translate="yes" xml:space="preserve">
          <source>This method is meant to be overridden by custom GroovyDoc implementations, using custom class templates.</source>
          <target state="translated">这个方法是为了被自定义的GroovyDoc实现所覆盖,使用自定义的类模板。</target>
        </trans-unit>
        <trans-unit id="8e09772b977dedc07d07d96cc2d72542f64ca1c5" translate="yes" xml:space="preserve">
          <source>This method is meant to be overridden by custom GroovyDoc implementations, using custom doc templates.</source>
          <target state="translated">这个方法是为了被自定义的GroovyDoc实现所覆盖,使用自定义的doc模板。</target>
        </trans-unit>
        <trans-unit id="e3f94c56bab43f0b3780ed88b92cbab7aa06914d" translate="yes" xml:space="preserve">
          <source>This method is meant to be overridden by custom GroovyDoc implementations, using custom package templates.</source>
          <target state="translated">这个方法是为了被自定义的GroovyDoc实现所覆盖,使用自定义的包模板。</target>
        </trans-unit>
        <trans-unit id="be3f5aaf4fe5b29a387b1c08f22380405a4b43e6" translate="yes" xml:space="preserve">
          <source>This method is not in use anymore.</source>
          <target state="translated">这个方法已经不使用了。</target>
        </trans-unit>
        <trans-unit id="d479a6f7032861e095021709f96d24a323c7ce9f" translate="yes" xml:space="preserve">
          <source>This method is not in use anymore. Use &lt;a href=&quot;groovyc#makeCompileUnit(groovy.lang.GroovyClassLoader)&quot;&gt;Groovyc.makeCompileUnit&lt;/a&gt; instead.</source>
          <target state="translated">该方法不再使用。请改用&lt;a href=&quot;groovyc#makeCompileUnit(groovy.lang.GroovyClassLoader)&quot;&gt;Groovyc.makeCompileUnit&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8df7d11b3e43da5003d64921acb230c01052ce02" translate="yes" xml:space="preserve">
          <source>This method is responsible for instantiating a node and configure its properties.</source>
          <target state="translated">这个方法负责实例化一个节点并配置它的属性。</target>
        </trans-unit>
        <trans-unit id="2553db016825bd58a6c41d37b4ac7d9fdb343726" translate="yes" xml:space="preserve">
          <source>This method is responsible for performing type inference on closure argument types whenever code like this is found: &lt;code&gt;foo.collect { it.toUpperCase() }&lt;/code&gt;.</source>
          <target state="translated">每当找到类似以下代码的代码时，此方法负责对闭包参数类型执行类型推断： &lt;code&gt;foo.collect { it.toUpperCase() }&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="96aa2c86a54f44a86c05cf0e9b642e0ff2c34049" translate="yes" xml:space="preserve">
          <source>This method is responsible for performing type inference on closure argument types whenever code like this is found: &lt;code&gt;foo.collect { it.toUpperCase() }&lt;/code&gt;. In this case, the type checker tries to find if the &lt;code&gt;collect&lt;/code&gt; method has its &lt;a href=&quot;../../../../../groovy/lang/closure&quot;&gt;Closure&lt;/a&gt; argument annotated with &lt;a href=&quot;../../../../../groovy/transform/stc/closureparams&quot;&gt;ClosureParams&lt;/a&gt;. If yes, then additional type inference can be performed and the type of &lt;code&gt;it&lt;/code&gt; may be inferred.</source>
          <target state="translated">每当找到类似以下代码的代码时，此方法负责对闭包参数类型执行类型推断： &lt;code&gt;foo.collect { it.toUpperCase() }&lt;/code&gt; 。在这种情况下，类型检查器尝试查找 &lt;code&gt;collect&lt;/code&gt; 方法的&lt;a href=&quot;../../../../../groovy/lang/closure&quot;&gt;Closure&lt;/a&gt;参数是否带有&lt;a href=&quot;../../../../../groovy/transform/stc/closureparams&quot;&gt;ClosureParams&lt;/a&gt;注释。如果是，则可以执行其他类型推断， &lt;code&gt;it&lt;/code&gt; 可以推断出其类型。</target>
        </trans-unit>
        <trans-unit id="39e70e7519f9c69520febf8336038092afe788f5" translate="yes" xml:space="preserve">
          <source>This method is similar to &lt;a href=&quot;#propX(org.codehaus.groovy.ast.expr.Expression,%20org.codehaus.groovy.ast.expr.Expression)&quot;&gt;propX(Expression, Expression)&lt;/a&gt; but will make sure that if the property being accessed is defined inside the classnode provided as a parameter, then a getter call is generated instead of a field access.</source>
          <target state="translated">此方法类似于&lt;a href=&quot;#propX(org.codehaus.groovy.ast.expr.Expression,%20org.codehaus.groovy.ast.expr.Expression)&quot;&gt;propX（Expression，Expression），&lt;/a&gt;但是将确保如果要访问的属性是在作为参数提供的classnode内定义的，则将生成getter调用，而不是字段访问。</target>
        </trans-unit>
        <trans-unit id="5af1f84f364b43bda693a94d6efdcb175387d500" translate="yes" xml:space="preserve">
          <source>This method is used to pull all the new methods out of the local thread context with a particular name.</source>
          <target state="translated">该方法用于将所有新方法从本地线程上下文中拉出一个特定名称。</target>
        </trans-unit>
        <trans-unit id="debc8862f9ee94379022acc734d3d04be7a4a835" translate="yes" xml:space="preserve">
          <source>This method looks up a simple (weak) hash map for an existing template object that matches the source URL. If there is no cache entry, a new one is created by the underlying template engine. This new instance is put to the cache for consecutive calls.</source>
          <target state="translated">这个方法为匹配源URL的现有模板对象查找一个简单的(弱)哈希图。如果没有缓存条目,则由底层模板引擎创建一个新条目。这个新的实例会被放到缓存中供连续调用。</target>
        </trans-unit>
        <trans-unit id="50f405bf763411bbbae4b569b75520c8c6ab7da2" translate="yes" xml:space="preserve">
          <source>This method looks up a simple (weak) hash map for an existing template object that matches the source file. If the source file didn't change in length and its last modified stamp hasn't changed compared to a precompiled template object, this template is used. Otherwise, there is no or an invalid template object cache entry, a new one is created by the underlying template engine. This new instance is put to the cache for consecutive calls.</source>
          <target state="translated">这个方法为现有的模板对象查找一个简单的(弱)哈希图,并与源文件相匹配。如果源文件的长度没有变化,而且与预编译的模板对象相比,它的最后一次修改戳记也没有变化,那么就会使用这个模板。否则,没有或无效的模板对象缓存条目,则由底层模板引擎创建一个新的模板对象。这个新的实例会被放到缓存中进行连续调用。</target>
        </trans-unit>
        <trans-unit id="70b580668132556ed8e21d6f55d11fdd505e1db6" translate="yes" xml:space="preserve">
          <source>This method may be used by a caller in class C to check whether to enable access to a member of declaring class D successfully if Java8#checkCanSetAccessible(java.lang.reflect.AccessibleObject, java.lang.Class) returns true and any of the following hold:</source>
          <target state="translated">如果Java8#checkCanSetAccessible(java.lang.reflect.AccessibleObject,java.lang.Class)返回true,并且以下任何一项保持不变,那么C类中的调用者可以使用该方法来检查是否成功启用对声明类D的成员的访问。</target>
        </trans-unit>
        <trans-unit id="403c2e4b9a79e63110b8121635756398ae996fda" translate="yes" xml:space="preserve">
          <source>This method returns the left hand side of the declaration cast to the TupleExpression type.</source>
          <target state="translated">本方法返回声明投向TupleExpression类型的左手。</target>
        </trans-unit>
        <trans-unit id="3eeba1201f99a5e2e68118e5c0e2cd8aa46418b3" translate="yes" xml:space="preserve">
          <source>This method returns the left hand side of the declaration cast to the TupleExpression type. This is an unsafe method to call. In a single assignment statement, the left hand side will be a VariableExpression and a ClassCastException will occur. If you invoke this method then be sure to invoke isMultipleAssignmentDeclaration() first to check that it is safe to do so. If that method returns true then this method is safe to call.</source>
          <target state="translated">本方法返回声明投向TupleExpression类型的左手。这是一个不安全的方法,可以调用。在单个赋值声明中,左手边将是一个VariableExpression,并且会发生一个ClassCastException。如果你调用这个方法,那么一定要先调用isMultipleAssignmentDeclaration()来检查这样做是否安全。如果该方法返回true,那么这个方法就可以安全调用。</target>
        </trans-unit>
        <trans-unit id="781dddff54ea389bba98f4620fb6ffb4990bacbc" translate="yes" xml:space="preserve">
          <source>This method returns the left hand side of the declaration cast to the VariableExpression type.</source>
          <target state="translated">本方法返回投向VariableExpression类型的声明的左侧。</target>
        </trans-unit>
        <trans-unit id="6d0cf4b5f8e84212c7ef85c55fbf13a8f51d14d1" translate="yes" xml:space="preserve">
          <source>This method returns the left hand side of the declaration cast to the VariableExpression type. This is an unsafe method to call. In a multiple assignment statement, the left hand side will be a TupleExpression and a ClassCastException will occur. If you invoke this method then be sure to invoke isMultipleAssignmentDeclaration() first to check that it is safe to do so. If that method returns true then this method is safe to call.</source>
          <target state="translated">本方法返回投向VariableExpression类型的声明的左侧。这是一个不安全的方法,可以调用。在多重赋值声明中,左手边将是一个TupleExpression,并且会发生一个ClassCastException。如果你调用这个方法,那么一定要先调用isMultipleAssignmentDeclaration()来检查这样做是否安全。如果该方法返回true,那么这个方法就可以安全调用。</target>
        </trans-unit>
        <trans-unit id="557432b29293b21b623d72897910f098d1d9b99f" translate="yes" xml:space="preserve">
          <source>This method returns the list of methods named against the supplied parameter that are defined on the specified receiver, but it will also add &quot;non existing&quot; methods that will be generated afterwards by the compiler, for example if a method is using default values and that the specified class node isn't compiled yet.</source>
          <target state="translated">这个方法返回针对所提供的参数命名的方法列表,这些方法在指定的接收器上被定义,但它也会添加 &quot;不存在 &quot;的方法,这些方法将在编译器之后生成,例如,如果一个方法使用默认值,并且指定的类节点还没有被编译。</target>
        </trans-unit>
        <trans-unit id="7c021d108112247d1976e0f0916701f3b8b31579" translate="yes" xml:space="preserve">
          <source>This method returns the method name as String if it is no dynamic calculated method name, but a constant.</source>
          <target state="translated">如果不是动态计算的方法名,而是一个常量,那么这个方法返回的方法名是String。</target>
        </trans-unit>
        <trans-unit id="ea5673ca5049872b33d116e64a53321be9dfe401" translate="yes" xml:space="preserve">
          <source>This method satisfies the general contract of the &lt;code&gt;Object.equals&lt;/code&gt; method.</source>
          <target state="translated">此方法满足 &lt;code&gt;Object.equals&lt;/code&gt; 方法的常规协定。</target>
        </trans-unit>
        <trans-unit id="e6de05f9ed26a209b6ba119f444e9aeb1971f83b" translate="yes" xml:space="preserve">
          <source>This method sets the leftExpression for this BinaryExpression.</source>
          <target state="translated">本方法为这个BinaryExpression设置leftExpression。</target>
        </trans-unit>
        <trans-unit id="9538691d379a9f29ae41a5c0329eeba449cfee5a" translate="yes" xml:space="preserve">
          <source>This method sets the leftExpression for this BinaryExpression. The parameter must be either a VariableExpression or a TupleExpression with one or more elements.</source>
          <target state="translated">本方法为这个BinaryExpression设置leftExpression,参数必须是一个VariableExpression或一个或多个元素的TupleExpression。参数必须是一个VariableExpression或一个包含一个或多个元素的TupleExpression。</target>
        </trans-unit>
        <trans-unit id="cabac7eca3eafa23e66e3fc5b9e599e6f515924d" translate="yes" xml:space="preserve">
          <source>This method supports named and named ordinal parameters by supplying such parameters in the &lt;code&gt;params&lt;/code&gt; array. See the class Javadoc for more details.</source>
          <target state="translated">此方法通过在 &lt;code&gt;params&lt;/code&gt; 数组中提供此类参数来支持命名和命名序数参数。有关更多详细信息，请参见类Javadoc。</target>
        </trans-unit>
        <trans-unit id="5ac687259610806fa3ccf67d52b8a0cdcf309f5f" translate="yes" xml:space="preserve">
          <source>This method supports named and named ordinal parameters by supplying such parameters in the &lt;code&gt;params&lt;/code&gt; list. Here is an example:</source>
          <target state="translated">此方法通过在 &lt;code&gt;params&lt;/code&gt; 列表中提供这样的参数来支持命名和命名序数参数。这是一个例子：</target>
        </trans-unit>
        <trans-unit id="08f6b6d6cce9316b59fc041647b88bdcb3661eb8" translate="yes" xml:space="preserve">
          <source>This method supports named and named ordinal parameters by supplying such parameters in the &lt;code&gt;params&lt;/code&gt; list. See the class Javadoc for more details.</source>
          <target state="translated">此方法通过在 &lt;code&gt;params&lt;/code&gt; 列表中提供这样的参数来支持命名和命名序数参数。有关更多详细信息，请参见类Javadoc。</target>
        </trans-unit>
        <trans-unit id="35c38527fe587a9d1b961b352a1036dd0d02b5a0" translate="yes" xml:space="preserve">
          <source>This method supports named and named ordinal parameters. See the class Javadoc for more details.</source>
          <target state="translated">本方法支持命名和命名序数参数。更多细节请参见类Javadoc。</target>
        </trans-unit>
        <trans-unit id="a1cb160878d23efb8494710e1845624e733ba117" translate="yes" xml:space="preserve">
          <source>This method takes source code, compiles it, then reverses it back to source.</source>
          <target state="translated">此方法获取源代码,编译后再反转回源代码。</target>
        </trans-unit>
        <trans-unit id="1802525bd308357b0932ba02bb3c41457d24c77a" translate="yes" xml:space="preserve">
          <source>This method tells you if this declaration is a multiple assignment declaration, which has the form &quot;def (x, y) = ...&quot; in Groovy.</source>
          <target state="translated">这个方法可以告诉你这个声明是否是一个多重赋值声明,它在Groovy中的形式是 &quot;def (x,y)=...&quot;。</target>
        </trans-unit>
        <trans-unit id="647f4610cd39ef87d4f0b710da06531ff2a5d253" translate="yes" xml:space="preserve">
          <source>This method tells you if this declaration is a multiple assignment declaration, which has the form &quot;def (x, y) = ...&quot; in Groovy. If this method returns true, then the left hand side is an ArgumentListExpression. Do not call &quot;getVariableExpression()&quot; on this object if this method returns true, instead use &quot;getLeftExpression()&quot;.</source>
          <target state="translated">这个方法可以告诉你这个声明是否是一个多重赋值声明,在Groovy中的形式是 &quot;def (x,y)=...&quot;。如果这个方法返回true,那么左手边就是一个ArgumentListExpression。如果这个方法返回true,不要在这个对象上调用 &quot;getVariableExpression()&quot;,而是使用 &quot;getLeftExpression()&quot;。</target>
        </trans-unit>
        <trans-unit id="03ceb4930438c953107282fc0e25906885994308" translate="yes" xml:space="preserve">
          <source>This method tokenizes a string by space characters, but ignores spaces in quoted parts,that are parts in '' or &quot;&quot;.</source>
          <target state="translated">本方法通过空格字符对字符串进行标记,但忽略引号部分的空格,即''或&quot;&quot;的部分。</target>
        </trans-unit>
        <trans-unit id="25594fed498b016c91d8453a3caab76c908e2263" translate="yes" xml:space="preserve">
          <source>This method tokenizes a string by space characters, but ignores spaces in quoted parts,that are parts in '' or &quot;&quot;. The method does allows the usage of &quot;&quot; in '' and '' in &quot;&quot;. The space character between tokens is not returned.</source>
          <target state="translated">本方法通过空格字符标记字符串,但忽略引号部分的空格,即''或&quot;&quot;中的部分。本方法允许使用''中的&quot;&quot;和&quot;&quot;中的&quot;&quot;。本方法不返回标记之间的空格字符。</target>
        </trans-unit>
        <trans-unit id="b2a84c08a545e26a0cfa5751f177172834124990" translate="yes" xml:space="preserve">
          <source>This methods creates a list of all methods with this name of the current class and of all super classes</source>
          <target state="translated">这个方法创建了当前类的所有带这个名字的方法和所有超级类的列表。</target>
        </trans-unit>
        <trans-unit id="d2b2f984e596021625b1464da65d3078af780eae" translate="yes" xml:space="preserve">
          <source>This methods returns a list of all methods of the given name defined in the current class</source>
          <target state="translated">该方法返回当前类中定义的所有给定名称的方法的列表。</target>
        </trans-unit>
        <trans-unit id="45509752471fda490b1c2f1641894ee63c1ba53e" translate="yes" xml:space="preserve">
          <source>This methods returns the same array as used in the constructor. Changing the values will result in changes of the GString. It is not recommended to do so.</source>
          <target state="translated">本方法返回与构造函数中使用的相同的数组。改变数值会导致GString的改变。不建议这样做。</target>
        </trans-unit>
        <trans-unit id="b66768732e0971c70f8284792c2afe59afe722c7" translate="yes" xml:space="preserve">
          <source>This modifies the original instance and returns it, it does not clone</source>
          <target state="translated">这将修改原始实例并将其返回,而不是克隆。</target>
        </trans-unit>
        <trans-unit id="d03be5ef16854ca34754ab795102a0c1c0f386c3" translate="yes" xml:space="preserve">
          <source>This object is a GUI for looking at the AST that Groovy generates. Usage: java groovy.console.ui.AstBrowser [filename] where [filename] is an existing Groovy script.</source>
          <target state="translated">这个对象是一个用于查看Groovy生成的AST的GUI。用法:java groovy.console.ui.AstBrowser[filename],其中[filename]是一个现有的Groovy脚本。</target>
        </trans-unit>
        <trans-unit id="3e97fa1c7af0c729d57b97541a44507ce0cc0d67" translate="yes" xml:space="preserve">
          <source>This object is a GUI for looking at the AST that Groovy generates. Usage: java groovy.inspect.swingui.AstBrowser [filename] where [filename] is an existing Groovy script.</source>
          <target state="translated">这个对象是一个用于查看Groovy生成的AST的GUI。用法:java groovy.inspect.swingui.AstBrowser [filename],其中[filename]是一个现有的Groovy脚本。</target>
        </trans-unit>
        <trans-unit id="e2ffc04181a72b4f0f1c3e416c94b05a7ff37bfe" translate="yes" xml:space="preserve">
          <source>This object represents a Groovy script</source>
          <target state="translated">这个对象代表一个Groovy脚本</target>
        </trans-unit>
        <trans-unit id="a3a6a41f25ea556ddea2ab91cb5c7b51b70dd65b" translate="yes" xml:space="preserve">
          <source>This only leaves the 'out' argument unbound. The only method on the &lt;a href=&quot;../lang/writable&quot;&gt;writable&lt;/a&gt; interface is &lt;a href=&quot;../lang/writable#writeTo&quot;&gt;writeTo(Writer out)&lt;/a&gt; so groovy rules about casting a closure to a one-method-interface apply and the above works. I.e. we return the now one argument closure as the Writable which can be serialized to System.out, a file, etc according to the Writable interface contract.</source>
          <target state="translated">这样只会使&amp;ldquo; out&amp;rdquo;参数不受约束。&lt;a href=&quot;../lang/writable&quot;&gt;可写&lt;/a&gt;接口上的唯一方法是&lt;a href=&quot;../lang/writable#writeTo&quot;&gt;writeTo（Writer out），&lt;/a&gt;因此适用于将闭包强制转换为一个方法接口的常规规则，上述方法适用。即，我们将现在的一个参数闭包作为Writable返回，可以根据Writable接口协定将其序列化为System.out，文件等。</target>
        </trans-unit>
        <trans-unit id="3860a813e268f2ea6fc72207bdceca72d569484a" translate="yes" xml:space="preserve">
          <source>This pattern can therefore be used to avoid explicit casts everywhere you need to call a method that you know is defined in the class that will implement the trait but normally don't have access to, which is often the case where a trait needs to be applied on a class provided by a third-party library.</source>
          <target state="translated">因此,这种模式可以用来避免在需要调用一个方法的地方进行显式casts,因为你知道这个方法是在将实现特质的类中定义的,但通常没有访问权,这通常是在需要将特质应用在第三方库提供的类上的情况下。</target>
        </trans-unit>
        <trans-unit id="ace59be916b50b31486861d73ed18eaca30ec5fa" translate="yes" xml:space="preserve">
          <source>This property allows customizing the program name displayed in the synopsis when &lt;code&gt;cli.usage()&lt;/code&gt; is called.</source>
          <target state="translated">此属性允许在调用 &lt;code&gt;cli.usage()&lt;/code&gt; 时自定义大纲中显示的程序名称。</target>
        </trans-unit>
        <trans-unit id="51e8331273416e517eaeaf7fa7a23b0549036735" translate="yes" xml:space="preserve">
          <source>This property allows customizing the program name displayed in the synopsis when &lt;code&gt;cli.usage()&lt;/code&gt; is called. Ignored if the &lt;a href=&quot;#usage&quot;&gt;usage&lt;/a&gt; property is set.</source>
          <target state="translated">此属性允许在调用 &lt;code&gt;cli.usage()&lt;/code&gt; 时自定义大纲中显示的程序名称。忽略是否设置了&lt;a href=&quot;#usage&quot;&gt;用法&lt;/a&gt;属性。</target>
        </trans-unit>
        <trans-unit id="8e7c100040c65811e98b4b5e3b269e9270590f58" translate="yes" xml:space="preserve">
          <source>This property controls whether to include the destination classes directory in the classpath given to the compiler.</source>
          <target state="translated">此属性控制是否在给编译器的classpath中包含目标类目录。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
